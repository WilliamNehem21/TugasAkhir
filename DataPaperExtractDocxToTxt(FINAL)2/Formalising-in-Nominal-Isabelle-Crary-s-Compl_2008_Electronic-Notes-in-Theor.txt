Electronic Notes in Theoretical Computer Science 196 (2008) 3–18	
www.elsevier.com/locate/entcs

Formalising in Nominal Isabelle Crary’s Completeness Proof for Equivalence Checking
Julien Narboux1 and Christian Urban2
TU Munich, Germany

Abstract
In the book on Advanced Topics in Types and Programming Languages, Crary illustrates the reasoning technique of logical relations in a case study about equivalence checking. He presents a type-driven equiv- alence checking algorithm and verifies its completeness with respect to a definitional characterisation of equivalence. We present in this paper a formalisation of Crary’s proof using Isabelle/HOL and the nominal datatype package.
Keywords: logical relations, proof assistants, formalisations, Isabelle/HOL, nominal logic work.



Introduction
Logical relations are a powerful reasoning technique for establishing properties about programming languages. The idea of logical relations goes back to Tait [8] and is usually employed for showing strong normalisation results. However this technique has wide applicability. Crary illustrates this by using a logical relation argument to prove completeness of an equivalence checking algorithm [3]. One reason for formalising proofs involving logical relations is that they are fairly intricate: First they require a logic that is sufficiently strong (see comment in [4, Page 58]). Also in the final step of such proofs, one has to establish by induction a property under a closing substitution. These substitutions might, however, interfere with binders and one has to be careful that the proof covers all cases that are required by the induction. We will show in this formalisation that there are a few places where one

1 Email: narboux(at)in.tum.de
2 Email: urbanc(at)in.tum.de

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.09.014

has to pay attention to this issue and that the strong induction principles [10] that have the variable convention already built in are quite convenient to get the formal arguments through.
There have already been a number of formalisations of proofs involving logical relations. For example Altenkirch [1] formalises the usual strong normalisation proof for System F in the theorem prover LEGO. To our knowledge all these formalisations use de Bruijn indices to represent α-equated terms. We attribute this to the fact that proofs using logical relations heavily rely on terms being a representation for α-equivalence classes. We assume that this is the reason why a formalisation based on a concrete (un-quotioned) representation has never been attempted.
One practical reason why we do not wish to formalise Crary’s proof using de Bruijn indices is that we like to stay as faithful as possible to the source and thus do not need to invent any of the formal arguments ourselves. This intention ma- terialised quite a bit in our formalisation, except in one place where we developed a completely different argument than the one Crary had mind, but did not com- pletely spell out its details (we found this out after we completed the formalisation by communicating with Crary about our proof). Even so we also had to spend con- siderable work to implement the informal rules presented by Crary and to justify that our implementation captures the intended behaviour of these rules.
Our formal proof is carried out in Isabelle/HOL and relies much on the infras- tructure provided by the nominal datatype package [9,10,11]. This package uses many ideas from the nominal logic work by Pitts [6]. The ability to directly de- fine in the nominal datatype package α-equivalent terms and obtain automatically recursion combinators and strong induction principles that have the usual variable convention already built was of great help in our formalisation. There is one place were we had to derive manually some infrastructure, which we hope can be derived automatically in the future. In the rest of the paper we give a guided tour through our formalisation.
Terms, Types and Substitution
Terms, types and substitutions are relatively standard and follow closely Crary’s notes. Terms are given by the grammar
Definition 2.1 (Terms)
trm ::= Var name | App trm trm | Lam name.trm | Const nat | Unit
where in the Lam-clause, as usual, a variable is bound; there is also an infinite supply of constants all represented by natural numbers. By stating this definition in the nominal datatype package we immediately obtain α-equivalent terms. Types are given by the grammar
Definition 2.2 (Types)  ty ::= TBase | TUnit | ty →ty
where there is no binding. We define the usual size function for types (details omitted), as this will be the measure over which we define the logical relation later

on.
The most important operation we need for our terms is that of applying simul-
taneous substitutions, which we represent as finite lists of (name,trm)-pairs. Crary defines them as functions from some set of variables to terms. One reason for our choice is that it is easier to deal with finitary structures in the nominal datatype package than with infinite ones (functions are considered as infinitary structures and would require additional theorem prover code). Using our list representation we define:
Definition 2.3 (Simultaneous Substitution)
θ(Var x )	= lookup θ x
θ(App t 1 t 2) = App θ(t 1) θ(t 2)
θ(Lam x.t )	= Lam x.θ(t )	provided x # θ θ(Const n)	= Const n
θ(Unit )	= Unit
where in the first clause we use the auxiliary function lookup defined by the clauses:
lookup [] x	= Var x
lookup ((y, T )::θ) x = if x = y then T else lookup θ x
Single substitutions are a derived concept by defining e[x :=e ′] d=ef [(x , e ′)](e) with [(x , e ′)] being a singleton list.
Note that in the Lam-clause we attach the side-condition about x being fresh for θ (written x # θ), which is equivalent to x being not free in the list of (name,trm)- pairs. Despite imposing this side-condition, the definition above yields a total func- tion, since we work with α-equivalence classes where renamings are always possible. Because we define a function over the structure of α-equated terms, we must be careful to not introduce any inconsistencies [9]. The reason is that we can specify functions over the structure of such terms that do not respect α-equivalence (for example the function that calculates the bound names of a term or returns the immediate subterms) and consequently lead to inconsistencies in Isabelle/HOL. In our formalisation this means that we have to give two four-line proofs that ensure that simultaneous substitutions respect α-equivalence.

Typing and Definitional Equivalence
Next, we define the typing judgements for our terms. In order to stay faithful to Crary’s notes we introduce the notion for when a typing context Γ is valid, namely when it includes only a single association for every variable occurring in Γ . Again we use lists to represent these typing contexts; this time because Isabelle/HOL does not provide out-of-the-box a type of finite sets. Using the lists we can define the notion of validity by the two rules:



valid []
valid Γ	x # Γ


valid ((x , T )::Γ )

where we attach in the second rule the side-condition that x must be fresh for Γ ,

which in case of our typing contexts is equivalent to x not occurring in Γ . The typing rules are then defined as:

valid Γ	(x , T ) ∈ Γ Γ ⊢ Var x : T
T-Var
Γ ⊢ e1 : T 1→T 2	Γ ⊢ e2 : T 1
Γ ⊢ App e1 e2 : T 2
T-App

x # Γ	(x , T 1)::Γ ⊢ t : T 2
Γ ⊢ Lam x.t : T 1→T 2
T-Lam

valid Γ
Γ ⊢ Const n : TBase
T-Const
valid Γ
Γ ⊢ Unit : TUnit
T-Unit

where we ensure that only valid contexts appear in typing judgements by including validity in the rules for variables and Units. To preserve validity in the rule T- Lam, we have the side-condition that x must be fresh for Γ . (We can infer this freshness condition also from the premise (x , T 1)::Γ ⊢ t : T 2 and the fact that in typing-judgements contexts are always valid, but this requires a side-lemma.) In rule T-Var we use the notation (x , T ) ∈ Γ to stand for list-membership.
The completeness of the typing algorithm is proved with respect to some rules characterising definitionally the equivalence between typed terms. The correspond- ing judgements Crary is using for this are of the form Γ ⊢ s ≡ t : T where s and t are terms and T is a type. We formalise his rules of definitional equivalence as follows:

Γ ⊢ t : T


Γ ⊢ t ≡ t : T
Q-Refl
Γ ⊢ t ≡ s : T


Γ ⊢ s ≡ t : T
Q-Symm

Γ ⊢ s ≡ t : T	Γ ⊢ t ≡ u : T


Γ ⊢ s ≡ u : T
Q-Trans

Γ ⊢ s1 ≡ t 1 : T 1→T 2	Γ ⊢ s2 ≡ t 2 : T 1


Γ ⊢ App s1 s2 ≡ App t 1 t 2 : T 2
x # Γ	(x , T 1)::Γ ⊢ s2 ≡ t 2 : T 2
Q-App

Γ ⊢ Lam x.s2 ≡ Lam x.t 2 : T 1→T 2
Q-Abs

x # (Γ , s2, t 2)	(x , T 1)::Γ ⊢ s1 ≡ t 1 : T 2	Γ ⊢ s2 ≡ t 2 : T 1


Γ ⊢ App (Lam x.s1) s2 ≡ t 1[x :=t 2] : T 2
x # (Γ , s, t )	(x , T 1)::Γ ⊢ App s (Var x ) ≡ App t (Var x ) : T 2
Γ ⊢ s ≡ t : T 1→T 2
Γ ⊢ s : TUnit	Γ ⊢ t : TUnit
Q-Beta Q-Ext

Γ ⊢ s ≡ t : TUnit
Q-Unit

Validity of the typing contexts are implied by the validity in the typing rules, which are included in the premises of Q-Refl and Q-Unit, and by having the side-condition about x being fresh for Γ in Q-Abs, Q-Beta and Q-Ext.
Comparing our rules with the ones given by Crary, slightly unusual are the side- conditions x # (s2, t 2) in the rule Q-Beta and x # (s, t ) in the rule Q-Ext. In the former case we can relatively easily show that our Q-Beta is equivalent to

(x , T 1)::Γ ⊢ s1 ≡ t 1 : T 2	Γ ⊢ s2 ≡ t 2 : T 1


Γ ⊢ App (Lam x.s1) s2 ≡ t 1[x :=t 2] : T 2
Q-Beta’.

However this requires explicit α-conversions and the fact that all typing contexts in the definitional equivalence judgements are valid. In light of this equivalence, the question arises why we insist on the more restricted rule: The reason is that based on those constraints the nominal datatype package can automatically derive a strong induction principle that has the variable convention already built in. This will be very convenient in some proofs later on. To do the same without those constraints is possible, but slightly more laborious.
In case of Q-Ext the side-conditions represent the fact that the extensionality rule should hold for a fresh variable x only. By imposing x # (Γ , s, t ) we can show that Q-Ext is equivalent to
∀ x . x # Γ −→ (x , T 1)::Γ ⊢ App s (Var x ) ≡ App t (Var x ) : T 2

Γ ⊢ s ≡ t : T 1→T 2
Q-Ext’

The argument for this uses the some/any-property from [6] and relies on the fact that the definitional equivalence is equivariant; by this we mean it is invariant under swapping of variables, namely Γ ⊢ s ≡ t : T implies (x y )·Γ ⊢ (x y )·s ≡ (x y )·t :
T for all x and y (see [10,11] for more details). The side-conditions in Q-Ext are
not explicitly given by Crary and the equivalence with Q-Ext’ gave us confidence to have captured with them the “idea” of an extensionality rule.


The Equivalence Checking Algorithm
One feature of Crary’s equivalence checking algorithm is that it includes a fair amount of optimisations, in the sense that in some circumstances two lambda terms are not completely normalised but only transformed into a weak-head normal-form. For this Crary introduces the following four rules:
t 1 ~ t 1

App (Lam x.t
1) t 2
~ t 1
[x :=t
QAR-Beta
2]
App t 1
t 2 ~ App t 1
′	QAR-App
2

s ~ t		t ⇓ u s ⇓ u
QAN-Reduce
t /~


t ⇓ t
QAN-Normal

The algorithm is then defined by two mutual recursive judgements, called respec- tively algorithmic term equivalence and algorithmic path equivalence. The former is written as Γ ⊢ s ⇔ t : T and the latter as Γ ⊢ s ↔ t : T. Their rules are
s ⇓ p   t ⇓ q   Γ ⊢ p ↔ q : TBase

Γ ⊢ s ⇔ t : TBase
QAT-Base

x # (Γ , s, t )	(x , T 1)::Γ ⊢ App s (Var x ) ⇔ App t (Var x ) : T 2


Γ ⊢ s ⇔ t : T 1→T 2
Arrow
QAT-

valid Γ


Γ ⊢ s ⇔ t : TUnit
QAT-One

valid Γ	(x , T ) ∈ Γ Γ ⊢ Var x ↔ Var x : T
QAP-Var

Γ ⊢ p ↔ q : T 1→T 2	Γ ⊢ s ⇔ t : T 1


Γ ⊢ App p s ↔ App q t : T 2
valid Γ
QAP-App



Γ ⊢ Const n ↔ Const n : TBase
QAP-Const

following quite closely Crary’s definition. One difference, however, is the inclusion of the validity predicate in the rules QAT-One, QAP-Var and QAP-Const ensuring that only valid typing contexts appear in the judgements. Another, more interesting, difference is the fact that by imposing the side-condition x # (s, t ) in the rule rule QAT-Arrow we explicitly restricting the algorithm to consider only fresh variables. Recall that we imposed a similar restriction in the rule Q-Beta given in Sec. 3. There, however, the side-condition was innocuous as we could show that the rule with the side-condition is equivalent to the one without the side-condition. With rule QAT-Arrow the situation is different—the side-condition is a “real” restriction, meaning that
x # Γ	(x , T 1)::Γ ⊢ App s (Var x ) ⇔ App t (Var x ) : T 2
Γ ⊢ s ⇔ t : T 1→T 2
and QAT-Arrow are not interderivable. (The reason for this is that in the judgement Γ ⊢ s ⇔ t : T the free variables of s and t do not necessarily need to be contained in Γ . Therefore we cannot infer from x # Γ that x # (s, t ) holds, as we did with Q-Beta.) While this restriction seems reasonable from an algorithmic point of view, it will turn out that it is actually crucial in our proofs: in order to get the inductions through for the properties of transitivity and monotonicity for the rules given above, we like to assume a sort of variable convention for x. That means we like to structure our argument so that the x in case of QAT-Arrow is fresh not just for Γ , s and t, but also for some other variables specified in the lemma at hand. This is very much like the informal reasoning using the variable convention, except that x in QAT-Arrow is not a binder. Still the nominal datatype package is able to derive automatically a strong induction principle, which allows us later on to make the reasoning with the variable convention completely formal. One proviso for deriving this strong induction principle is however that we formulate the QAT-Arrow as we have (essentially we have to make sure that the variable x does not occur freely in the conclusion of the corresponding rule; for more details we refer again to [10]). To see the improvement we obtain with the strong induction principle, consider the

usual induction principle that comes with the rules specified above:
. . .
∀x Γ s t T1 T2.
x#(Γ, s, t) ∧ P1 ((x : T1) :: Γ ) (App s (V ar x)) (App t (V ar x)) T2
−→ P1 Γ s t (T1 → T2)
. . .
Γ ⊢ s ⇔ t : T −→ P1 Γ s t T	Γ ⊢ s ↔ t : T −→ P2 Γ s t T

This induction principle states that if one wants to prove two properties P1 and P2 by mutual induction over the rules for algorithmic term equivalence and algorith- mic path equivalence, then one can assume in the QAT-Arrow the side-condition x#(Γ, s, t) and P1 for the premise, and one has to establish P1 for the conclusion. The strong induction principle is similar
. . .
∀x Γ s t T1 T2 c.
 x#c  ∧ x#(Γ, s, t) ∧ (∀c. P1 c ((x : T1) :: Γ ) (App s (V ar x)) (App t (V ar x)) T2)
−→ P1 c Γ s t (T1 → T2)

. . .
Γ ⊢ s ⇔ t : T −→ P1 c Γ s t T	Γ ⊢ s ↔ t : T −→ P2 c Γ s t T


except that it includes an induction context c in the properties P1 and P2, and we can assume that in the QAT-Arrow-case the x is fresh with respect to this induction context (see highlighted box). Over this induction context we have control when we set up an induction: if we want to employ the variable convention in our formal proofs, we just need to instantiate this induction context appropriately.
Before we can describe our proofs in detail we need two more definitions. We need to formalise Crary’s notion of logical equivalence, written Γ ⊢ s is t : T, and the logical equivalence of two simultaneous substitutions, say θ1 and θ2, over a context Γ . The latter is a derived concept and will be written as Γ ′ ⊢ θ is θ ′ over Γ . The former is defined by recursion over the size of the types. The clauses are as follows:

Γ ⊢ s is t : TUnit d=ef true
Γ ⊢ s is t : TBase d=ef Γ ⊢ s ⇔ t : TBase
Γ ⊢ s is t : (T 1 → T 2) d=ef ∀ Γ ′ s ′ t ′. Γ ⊆ Γ ′ ∧ valid Γ ′ ∧ Γ ′ ⊢ s ′ is t ′ : T 1 −→
Γ ′ ⊢ (App s s ′) is (App t t ′) :T 2
using in the last clause the notion of a weaker context, written Γ ⊆ Γ ′ (for Γ ′ to be weaker than Γ , every (name,type)-pair in Γ must also appear in Γ ′). Logical equivalence for simultaneous substitutions over a context Γ is defined as
Γ ′ ⊢ θ is θ ′ over Γ d=ef ∀ x T. (x ,T ) ∈ set Γ −→ Γ ′ ⊢ θ(Var x ) is θ ′(Var x ) : T
With this we have all necessary definitions in place.

Proofs
The first mayor property we need to establish is transitivity for algorithmic term equivalence and algorithmic path equivalence. These proofs are not detailed in Crary’s notes and we diverged in our formalisation from the proofs he had in mind. We first show that type unicity holds for algorithmic path equivalence
Lemma 5.1 (Type Unicity)
If Γ ⊢ s ↔ t : T and Γ ⊢ s ↔ u : T ′ then T = T ′.
and subsequently show symmetry for both the algorithmic path equivalence and the algorithmic term equivalence.
Lemma 5.2 (Algorithmic Symmetry)
If Γ ⊢ s ⇔ t : T then Γ ⊢ t ⇔ s : T.
If Γ ⊢ s ↔ t : T then Γ ⊢ t ↔ s : T.
Both proofs are by relatively straightforward inductions over Γ ⊢ s ⇔ t : T and Γ ⊢ s ↔ t : T . This then allows us to prove transitivity, where we need the strong induction principle in order to get the induction through.
Lemma 5.3 (Algorithmic Transitivity)
If Γ ⊢ s ⇔ t : T and Γ ⊢ t ⇔ u : T then Γ ⊢ s ⇔ u : T.
If Γ ⊢ s ↔ t : T and Γ ⊢ t ↔ u : T then Γ ⊢ s ↔ u : T.
Proof. By mutual induction over Γ ⊢ s ⇔ t : T and Γ ⊢ s ↔ t : T where we instantiate the induction context with the term u. In the QAP-App-case we then have the induction hypotheses
ih1:	∀ u. Γ ⊢ q ↔ u : T 1→T 2 −→ Γ ⊢ p ↔ u : T 1→T 2
ih2:	∀ u. Γ ⊢ t ⇔ u : T 1 −→ Γ ⊢ s ⇔ u : T 1
and the assumptions
(i ): Γ ⊢ App q t ↔ u : T 2	and	(ii ): Γ ⊢ p ↔ q : T 1→T 2

From the first assumption we obtain by inversion of the typing rule an r, T ′
and

v such that

: Γ ⊢ q ↔ r : T ′ →T 2

: Γ ⊢ t ⇔ v : T ′

and u = App r v hold. From the second assumption we obtain Γ ⊢ q ↔ p : T 1→T 2
by symmetry of ↔ (Lemma 5.2), and then can use this and (iii ) to find out by the
type unicity of ↔ (Lemma 5.1) that T ′ →T 2 = T 1→T 2 holds. This in turn implies
that T ′  = T 1, which allows us to use (iii ) and (iv ) in the induction hypotheses.

This gives us

Γ ⊢ s ⇔ v : T 1	and	Γ ⊢ p ↔ r : T 1→T 2 .

Hence we know that Γ ⊢ App p s ↔ u : T 2 holds by the rule QAP-App and the equation u = App r v.

The case QAT-Base uses the fact that normalisation produces unique results, that is if t ⇓ q and t ⇓ q ′ then q = q ′.
In the QAT-Arrow case we have Γ ⊢ t ⇔ u : T 1→T 2 and thus can infer that the judgement (x , T 1)::Γ ⊢ App t (Var x ) ⇔ App u (Var x ) : T 2 holds. By induction we obtain further that (x , T 1)::Γ ⊢ App s (Var x ) ⇔ App u (Var x ) : T 2 holds. Finally we can infer the proof obligation in this case, namely Γ ⊢ s ⇔ u : T 1→T 2, provided we know x # (Γ ,s,u). The freshness for Γ and s is given by the side- conditions of QAT-Arrow. The freshness for u is given by the strong induction principle (recall that we instantiated the induction context with u). Thus we are done.	2
Next we prove closure under weak-head reductions, but we restrict our argument to the single step case (Crary proves closure under multiple steps) as this is easier to prove (actually it can be derived automatically by Isabelle’s automatic search tools) and is sufficient for our formalisation.
Lemma 5.4 (Algorithmic Weak-Head Closure)
If Γ ⊢ s ⇔ t : T and s ′ ~ s and t ′ ~ t then Γ ⊢ s ′ ⇔ t ′ : T.
This lemma is by a simple induction over Γ ⊢ s ⇔ t : T. The following lemma establishes a kind of weakening property for the judgements of the algorithm.
Lemma 5.5 (Algorithmic Monotonicity)
If Γ ⊢ s ⇔ t : T and Γ ⊆ Γ ′ and valid Γ ′ then Γ ′ ⊢ s ⇔ t : T.
If Γ ⊢ s ↔ t : T and Γ ⊆ Γ ′ and valid Γ ′ then Γ ′ ⊢ s ↔ t : T.
Proof. By mutual induction using the strong induction principle. This time we instantiate the induction context with Γ ′. The only interesting case (that is the one which is not automatic) analyses the rule QAT-Arrow: There we have by assumption Γ ⊆ Γ ′ from which we can infer (x ,T 1)::Γ ⊆ (x ,T 1)::Γ ′. In order to apply the induction hypotheses, we need the fact that valid ((x , T 1)::Γ ′) holds. At this point the usual induction would start to become ugly since explicit renamings need to be performed. However we based our argument on the strong induction principle with the induction context being instantiated with Γ ′. This gives us x # Γ ′ from which we can easily infer the desired fact. We can then conclude in this case with appealing to the induction hypotheses.	2
The next lemma will help us to establish the fact that logical equivalence implies algorithmic equivalence.
Lemma 5.6 (Algorithmic Path Equivalence implies Weak-Head-Normal Form)
If Γ ⊢ s ↔ t : T then s /~ and t /~.
This is by straightforward induction on Γ ⊢ s ↔ t : T. The main lemma in Crary’s proof is then stated as follows (where we had to include in our formal version of this lemma that Γ is valid).

Lemma 5.7 (Main Lemma)
If Γ ⊢ s is t : T and valid Γ then Γ ⊢ s ⇔ t : T.
If Γ ⊢ p ↔ q : T then Γ ⊢ p is q : T.
Proof. The proof is by simultaneous induction over T generalising over Γ , s, t, p and q. The non-trivial case is for T = T1 → T2. For the first property we have the induction hypotheses
ih1:  ∀ Γ s t . Γ ⊢ s is t : T 2 ∧ valid Γ −→ Γ ⊢ s ⇔ t : T 2
ih2:  ∀ Γ s t . Γ ⊢ s ↔ t : T 1 −→ Γ ⊢ s is t : T 1
and the assumptions Γ ⊢ s is t : T 1→T 2 and valid Γ . We choose a fresh x (fresh w.r.t. Γ , s and t). We can thus derive that valid ((x , T 1)::Γ ) holds and hence (x , T 1)::Γ ⊢ Var x ↔ Var x : T 1. From this we can derive (x , T 1)::Γ ⊢ Var x is Var x : T 1 using the second induction hypothesis. Using the our assumptions we can then derive (x , T 1)::Γ ⊢ App s (Var x ) is App t (Var x ) : T 2 which by the first induction hypothesis leads to (x , T 1)::Γ ⊢ App s (Var x ) ⇔ App t (Var x ) : T 2. Because we chosen x to be fresh, we can then derive Γ ⊢ s ⇔ t : T 1→T 2, as needed. The proof for the other property uses Lemma 5.5, but we omit the details.    2
In his notes Crary carefully designs the logical equivalence so that it has the following property:
Lemma 5.8 (Logical Monotonicity)
If Γ ⊢ s is t : T and Γ ⊆ Γ ′ and valid Γ ′ then Γ ′ ⊢ s is t : T.
whose proof is by induction on the definition of the logical equivalence, appealing in the TBase-case to Lemma 5.5. From logical monotonicity we can deduce the following corollary:
Corollary 5.9 (Logical Monotonicity for Substitutions)
If Γ ′ ⊢ θ is θ ′ : Γ and Γ ′ ⊆ Γ ′′ and valid Γ ′′ then Γ ′′ ⊢ θ is θ ′ : Γ.
The next three lemmas infer some properties about logical equivalence needed in the fundamental theorems. They are all by relatively routine inductions over the type T , so we only state them here.
Lemma 5.10 (Logical Symmetry)
If Γ ⊢ s is t : T then Γ ⊢ t is s : T.
Lemma 5.11 (Logical Transitivity)
If Γ ⊢ s is t : T and Γ ⊢ t is u : T then Γ ⊢ s is u : T.
Lemma 5.12 (Logical Weak Head Closure)
If Γ ⊢ s is t : T and s ′ ~ s and t ′ ~ t then Γ ⊢ s ′ is t ′ : T.
Note that in Lemma 5.12 we prove again only the case of closure under single weak- head reductions since this is sufficient for the the fundamental theorems, which are shown next.

Theorem 5.13 (Fundamental Theorem 1)
If Γ ⊢ t : T and Γ ′ ⊢ θ is θ ′ : Γ and valid Γ ′ then Γ ′ ⊢ θ(t ) is θ ′(t ) : T.
Proof. By induction over the definition of Γ ⊢ t : T . We use the strong induction principle for typing and instantiate the induction context so that binders avoid the substitutions θ and θ′. This will give us the two facts
(∗)	(x , s)::θ(t ) = θ(t )[x :=s]	and	(x , s)::θ ′(t ) = θ ′(t )[x :=s]
which state how we can pull apart a simultaneous substitution such that we obtain a separate single substitution. These facts will be crucial in our induction argument since the left-hand sides correspond to what we have by the induction hypotheses and the right-hand sides will correspond to what we have to prove. These facts do, however, not hold for general x, only for ones that are fresh for the substitu- tion. Since we can assume that x is fresh for θ and θ′, our argument goes through smoothly. In the T-Lam-case we have the induction hypothesis

ih:  ∀ Γ ′ θ θ ′. Γ ′ ⊢ θ is θ ′ : (x , T 1)::Γ ∧ valid Γ ′ −→ Γ ′ ⊢ θ(t 2) is θ ′(t 2) : T 2
and we can assume Γ ′ ⊢ θ is θ ′ : Γ and further that x # (Γ , θ, θ ′) (the first freshness assumption comes from the T-Lam rule; the second and third from the strong induction). We need to show that Γ ′ ⊢ θ(Lam x.t 2) is θ ′(Lam x.t 2) : T 1→T 2 holds. For this it is sufficient to show for all Γ ′′, s′ and t′ that
Γ ′′ ⊢ App (Lam x.θ(t 2)) s ′ is App (Lam x.θ ′(t 2)) t ′ : T 2
whereby we can assume that Γ ′ ⊆ Γ ′′, Γ ′′ ⊢ s ′ is t ′ : T 1 and valid Γ ′′. From these assumptions we obtain by Lemma 5.8 that Γ ′′ ⊢ θ is θ ′ : Γ holds and by the freshness conditions also that Γ ′′ ⊢ (x , s ′)::θ is (x , t ′)::θ ′ : (x , T 1)::Γ (we proved that logical equivalence can be so extended in a side-lemma). Now by induction hypothesis we can infer that
Γ ′′ ⊢ (x , s ′)::θ(t 2) is (x , t ′)::θ ′(t 2) : T 2
holds. Now we can apply the facts mentioned under (∗) to obtain
Γ ′′ ⊢ θ(t 2)[x :=s ′] is θ ′(t 2)[x :=t ′] : T 2
Since we know that
App (Lam x.θ(t 2)) s ′ ~ θ(t 2)[x :=s ′]
App (Lam x.θ ′(t 2)) t ′ ~ θ ′(t 2)[x :=t ′]
hold, we can apply Lemma 5.12 to conclude with Γ ′′ ⊢ App (Lam x.θ(t 2)) s ′ is App (Lam x.θ ′(t 2)) t ′ : T 2. This completes, the proof as the T-Lam-case is the only non-automatic case in our formal proof.	2
The second fundamental lemma shows that logical equivalence is closed under si- multaneous substitutions.

Theorem 5.14 (Fundamental Theorem 2)
If Γ ⊢ s ≡ t : T and Γ ′ ⊢ θ is θ ′ : Γ and valid Γ ′ then Γ ′ ⊢ θ(s) is θ ′(t ) : T.


Proof. By strong induction over the definition of the definitional equivalence Γ ⊢ s ≡ t : T. The induction context is again instantiated with θ and θ′. There are several interesting cases. However we only show the cases for Q-Abs, Q-Beta and Q-Ext.
In the first case we have the induction hypothesis

ih:	∀ Γ ′ θ θ ′. Γ ′ ⊢ θ is θ ′ : (x , T 1)::Γ ∧ valid Γ ′ −→ Γ ′ ⊢ θ(s2) is θ ′(t 2) : T 2
and need to show that
Γ ′ ⊢ θ(Lam x.s2) is θ ′(Lam x.t 2) : T 1→T 2
holds. Because by the strong induction principle, we can assume that x # (θ, θ ′), we are able to immediately move the substitutions under the lambdas, i.e. we have to proceed with showing
Γ ′ ⊢ Lam x.θ(s2) is Lam x.θ ′(t 2) : T 1→T 2.
This can be done by establishing Γ ′′ ⊢ App (Lam x.θ(s2)) s ′ is App (Lam x.θ ′(t 2)) t ′ : T 2 for all Γ ′′, s′ and t′. The reasoning is similar to Theorem 5.13 and therefore omitted.
In the second case we need to establish that Γ ′ ⊢ θ(App (Lam x.s1) s2) is θ ′(t 1[x :=t 2]) : T 2 holds. Again, by the convenience afforded by the strong induction principle we can immediately move the substitution inside the terms, that is we have to show
Γ ′ ⊢ App (Lam x.θ(s1)) θ(s2) is θ ′(t 1)[x :=θ ′(t 2)] : T 2
We omit the other details, because they just amount to using the induction hy- potheses and adjusting substitutions appropriately.
In the third case we do not have additional freshness assumptions about θ and θ′ (we do not need them in this case). However, the side-conditions about x being fresh for s and t will turn out to be crucial. The reason is that we can then simplify the terms
(∗∗)	(x , s ′)::θ(s) = θ(s)	and	(x , t ′)::θ ′(t ) = θ ′(t ) The induction hypothesis in this case is
∀ Γ ′ θ θ ′. Γ ′ ⊢ θ is θ ′ over (x ,T 1)::Γ ∧ valid Γ ′
−→ Γ ′ ⊢ θ(App s (Var x )) is θ ′(App t (Var x )) : T 2.
and we have the assumptions that Γ ′ ⊢ θ is θ ′ : Γ , valid Γ ′ and x # (Γ , s, t ). We show that Γ ′ ⊢ θ(s) is θ ′(t ) : T 1→T 2 holds which by the assumption about the validity of Γ ′ amounts to showing that

Γ ′′ ⊢ App θ(s) s ′ is App θ ′(t ) t ′ : T 2
holds for all Γ ′′, s′ and t′, using the assumption about Γ ′ ⊆ Γ ′′, Γ ′′ ⊢ s ′ is t ′ : T 1
and valid Γ ′′. Using Lemma 5.8 we can infer that
Γ ′′ ⊢ θ is θ ′ : Γ
holds, from which we obtain
Γ ′′ ⊢ (x , s ′)::θ is (x , t ′)::θ ′ : (x , T 1)::Γ . Using the induction hypothesis gives us then
Γ ′′ ⊢ (x , s ′)::θ(App s (Var x )) is (x , t ′)::θ ′(App t (Var x )) : T 2.
Moving the substitutions inside and using the facts (∗∗) we can conclude with
Γ ′′ ⊢ App θ(s) s ′ is App θ ′(t ) t ′ : T 2
This completes the proof.	2
Completeness of the algorithm is now a simple consequence of the Theorem 5.14 by using the fact that Γ ⊢ Var x is Var x : T holds by Lemma 5.7 and that Γ ⊢ [] is [] : Γ holds.
Corollary 5.15 (Completeness)
If Γ ⊢ s ≡ t : T then Γ ⊢ s ⇔ t : T.
Thus we have formally verified that the algorithm says “yes” for all equivalent terms. The soundness property is left as an exercise in [3]. We have not formalised this part.

About the Formalisation
We can generally remark that having a formalised proof allows one to quickly test changes whether they affect the whole proof. This proved convenient for testing if lemmas or definitions need to be strengthened or can be weakened. Having the for- mal proof at our disposal also made it easy to compile this paper, as Isabelle has an extensive infrastructure for using formal definitions in papers and providing sanity checks. This is especially useful to keep formalisations and papers synchronised. The inductive rules and the statements of the lemmas and theorems presented in this paper have been generated from the formal definitions.
More specifically we can say that our formalisation follows a good deal the infor- mal reasoning of Crary (see Figure 1 which shows the first fundamental lemma as an example in the Isar proof language [12]). The strong induction principles proved crucial in order to get the inductions through. Such strong induction principles are derived automatically for any nominal datatype (which can at the moment only include lambda-type of bindings, but they can occur iterated and can bind different kinds of variables). The strong induction principles are also derived automatically

for inductive definition satisfying certain freshness conditions (see [10]).
The only sore point we see in our formalisation is the lack of automation in inversion lemmas. While this is not a serious problem in the formalisation of Crary’s chapter (we only need one such inversion lemma and that can be proved in 5 lines), it can be painful in other formalisations. We hope this problem can be solved in the future. To see what the issues are, re-consider the T-Lam-rule:
x # Γ	(x , T 1)::Γ ⊢ t : T 2

Γ ⊢ Lam x.t : T 1→T 2
T-Lam

and assume that we have given the typing judgement Γ ⊢ Lam x.t : T . In in formal reasoning we can match this judgement against all typing rules, which is only successful in case of T-Lam. The informal matching would then produce that there exists an T 1 and T 2 such that T = T 1→T 2 and that (x , T 1)::Γ ⊢ t : T 2 as well as x # Γ hold. However, this is not how we can proceed in the nominal datatype package, where terms are α-equivalent classes. There we obtain for the
assumption Γ ⊢ Lam x.t : T the “matcher” that there exists Γ ′, x′, t′, T ′ and T ′
′	′  ′	′	′	1	2
so that Γ = Γ , Lam x.t = Lam x .t and T = T1 → T2. As properties we obtain
Γ ′ ⊢ Lam x ′.t : T ′ and x ′ # Γ ′. Solving these equation would be no problem if we had term-constructors that are injective (that is a characteristics of standard, unquotioned datatypes). However, our constructors for α-equivalence classes are clearly not injective. What we have to do is to analyse Lam x.t = Lam x ′.t ′ according to the built-in notion of the nominal datatype package for α-equivalence. We end up with two cases: one is simple and the other needs explicit renamings. However these reasoning maneuvers should really be performed automatically by the nominal datatype package.

Conclusion
We presented a formalisation of Crary’s case study about logical relations. This is in addition to the usual strong normalisation proof of the simply-typed lambda- calculus, which has been part of the nominal datatype package for quite some time. It remains to be seen whether the nominal datatype package is up to the task of formalising strong normalisation for System F, where also types have binders. In this case the definition of logical relations is not completely trivial like in the completeness proof we presented above.
We are aware of work by Schu¨rmann and Sarnat about formalising logical re- lation proofs in Twelf [7]. This involves a clever trick of implementing an object logic in Twelf and coding the logical relation proof in this object logic. We un- fortunately do not know how convenient this style of reasoning is. We are also aware that Aydemir et al [2] use a locally nameless approach (which goes back to work by McKinna and Pollack [5]) to representing binders and work on formalising programming language theory. It would be interesting to compare in detail our formalisation and the approach taken by Aydemir et al. Our initial opinion is that in our formalisation we do not have to deal with the concepts of open and closed


theorem fundamental-theorem-1 :
assumes a1: Γ ⊢ t : T
and	a2: Γ ′ ⊢ θ is θ ′ over Γ
and	a3: valid Γ ′
shows Γ ′ ⊢ θ(t ) is θ ′(t ) : T
using a1 a2 a3
proof	(nominal-induct	Γ	t T avoiding : θ θ ′ arbitrary : Γ ′ rule: typ- ing.strong-induct )			(**)
case (T-Lam x Γ T 1 t 2 T 2 θ θ ′ Γ ′)
have vc: x # θ x # θ ′ by fact		(variable convention) have fs: x # Γ by fact	(freshness condition from the rule) have asm1: Γ ′ ⊢ θ is θ ′ over Γ by fact
have ih:Vθ θ ′ Γ ′. [[Γ ′ ⊢ θ is θ ′ over (x ,T 1)::Γ ; valid Γ ′]] =⇒ Γ ′ ⊢ θ(t 2) is θ ′(t 2)
: T 2
by fact	(induction hypothesis)
show Γ ′ ⊢ θ(Lam x . t 2) is θ ′(Lam x . t 2) : T 1→T 2 using vc	(*)
proof (simp, intro strip)	(unfolding the definition of logical equivalence)
fix Γ ′′ s ′ t ′
assume sub: Γ ′ ⊆ Γ ′′
and	asm2: Γ ′′⊢ s ′ is t ′ : T 1
and	val : valid Γ ′′
from asm1 val sub have Γ ′′ ⊢ θ is θ ′ over Γ using logical-subst-monotonicity
by blast
with asm2 vc fs have Γ ′′ ⊢ (x ,s ′)::θ is (x ,t ′)::θ ′ over (x ,T 1)::Γ	(*)
using equiv-subst-ext by blast
with ih val have Γ ′′ ⊢ ((x ,s ′)::θ)(t 2) is ((x ,t ′)::θ ′)(t 2) : T 2 by auto
with vc have Γ ′′⊢θ(t 2)[x ::=s ′] is θ ′(t 2)[x ::=t ′] : T 2 by (simp add : psubst-subst )
(*)
moreover
have App (Lam x . θ(t 2)) s ′ ~ θ(t 2)[x ::=s ′] by auto
moreover
have App (Lam x . θ ′(t 2)) t ′ ~ θ ′(t 2)[x ::=t ′] by auto
ultimately show Γ ′′⊢ App (Lam x . θ(t 2)) s ′ is App (Lam x . θ ′(t 2)) t ′ : T 2
using logical-weak-head-closure by auto
qed
qed (auto)	(all other cases are automatic)

Fig. 1. The complete formalised proof of the first fundamental lemma (Lemma 5.13) in the readable Isar proof-language. In the places marked with a single star, one appeals in informal reasoning to the variable convention about the binder x. This variable convention is given in our proof by the strong induction principle and by declaring that x should avoid θ and θ′ (see line marked with two stars). The fact logical-subst-monotonicity is Corollary 5.9; equiv-subst-ext establishes that for a fresh x one can extend the logical equivalence of simultaneous substitutions; and psubst-subst is a lemma that allows us to pull apart a simultaneous substitution in order to obtain a single substitution. We can do this provided the variable convention about x holds.

terms; and that we do not have to discard any pre-terms.
The sources of our formalisation are included in the nominal datatype pack- age (see http://isabelle.in.tum.de/nominal/). From the web-page of the first author one can also download a longer version of the documented proofs.

Acknowledgement
We thank Karl Crary for the discussions about his proof. We are also very grateful to Carsten Schu¨rmann who made us aware of typos and omissions in an early version of this paper.


References
T. Altenkirch. A Formalization of the Strong Normalisation Proof for System F in LEGO. In Proc. of TLCA, volume 664 of LNCS, pages 13–28, 1993.
B. Aydemir, A. Chargu´eraud, B. C. Pierce, and S. Weirich. Engineering Aspects of Formal Metatheory, 2007. Submitted for publication.
K. Crary. Logical Relations and a Case Study in Equivalence Checking. In B. C. Pierce, editor,
Advanced Topics in Types and Programming Languages, pages 223–244. MIT Press, 2005.
R. Harper and D. Licata. Mechanizing Metatheory in a Logical Framework. Journal of Functional Programming, 2007. To appear.
J. McKinna and R. Pollack. Pure Type Systems Formalized. In Proc. of the International Conference on Typed Lambda Calculi and Applications (TLCA), number 664 in LNCS, pages 289–305. Springer- Verlag, 1993.
A. M. Pitts. Nominal Logic, A First Order Theory of Names and Binding. Information and Computation, 186:165–193, 2003.
C. Schu¨rmann and J. Sarnat. Towards a Judgemental Reconstruction of Logical Relation Proofs. Submitted, 2007.
W. W. Tait. Intensional Interpretations of Functionals of Finite Type I. Journal of Symbolic Logic, 32(2):198–212, 1967.
C. Urban and S. Berghofer. A Recursion Combinator for Nominal Datatypes Implemented in Isabelle/HOL. In Proc. of the 3rd International Joint Conference on Automated Reasoning (IJCAR), volume 4130 of LNAI, pages 498–512, 2006.
C. Urban, S. Berghofer, and M. Norrish. Barendregt’s Variable Convention in Rule Inductions. In
Proc. of the 21th International Conference on Automated Deduction (CADE), 2007. To appear.
C. Urban and C. Tasson. Nominal Techniques in Isabelle/HOL. In Proc. of the 20th International Conference on Automated Deduction (CADE), volume 3632 of LNCS, pages 38–53, 2005.
M. Wenzel. Isar — A Generic Interpretative Approach to Readable Formal Proof Documents. In Proc. of the 12th International Conference on Theorem Proving in Higher Order Logics (TPHOLs), number 1690 in LNCS, pages 167–184, 1999.
