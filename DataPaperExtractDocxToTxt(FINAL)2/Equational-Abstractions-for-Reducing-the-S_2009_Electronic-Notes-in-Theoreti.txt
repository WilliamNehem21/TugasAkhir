

Electronic Notes in Theoretical Computer Science 238 (2009) 139–154
www.elsevier.com/locate/entcs

Equational Abstractions for Reducing the State Space of Rewrite Theories
Lars Helge Haß1 and Thomas Noll2
Software Modeling and Verification Group RWTH Aachen University
52056 Aachen, Germany

Abstract
The combinatorial explosion of state spaces is the biggest problem in applying model checking methods to concurrent systems. In this paper we present a new state-space reduction technique that is tailored to system specifications in Rewriting Logic, a unified semantic framework for concurrency which is based on conditional term rewriting modulo equational theories. The idea is to hide “unimportant” details of the system’s behavior (such as internal computations) in the equations, and to represent only “interesting”
state changes (such as communication operations) by explicit transitions. We show how this optimization can be implemented by transforming the Rewriting Logic specification, avoiding the construction of the full state space. Moreover we establish the correctness of our technique by proving that the original and the reduced system are weakly bisimilar, and demonstrate its usability by applying it to the concurrent functional programming language Erlang.
Keywords: state-space reduction, equational abstraction, weak bisimilarity


Introduction
In this paper we address the issue of software verification, concentrating on the first part of the validation procedure, the construction of the (transition-system) model to be checked. This work is carried out in the context of the Rewriting Logic framework as introduced by J. Meseguer in [9] and [10], which has proven to be an adequate modeling formalism for many concrete specification and programming languages [8]. In this approach, the state of a system is represented by an equiv- alence class of terms modulo a given set of equations, and transitions correspond to rewriting operations on the representatives. Hence Rewriting Logic supports both the definition of programming formalisms and, by employing (equational) term rewriting methods, the execution or simulation of concrete systems.

1 Email: hass@cs.rwth-aachen.de
2 Email: noll@cs.rwth-aachen.de

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.017

Here we will employ equations to define abstraction mappings which reduce the state space of the system. More concretely the idea is to turn certain transi- tions which represent “unimportant” details of the system’s behavior into equations. Thus these transitions are “hidden” in the current state, generally reducing the num- ber of states, which in turn enables large concurrent systems to become formally verifiable.
Technically the modification of the given Rewriting Logic specification is achieved by choosing a special action label τ , the silent or unobservable action (which is often
used in calculi such as CCS [12] for denoting internal operations), for distinguishing internal computations of the system from those which should be represented by explicit transitions. We will show under which restrictions it is possible to modify the given Rewriting Logic specification by turning τ -transitions into equations in such a way that the resulting transition system is equivalent to the original one. Here equivalence has to be interpreted as weak bisimulation, meaning that each step of the original system can be simulated by a corresponding action of the reduced system and vice versa, where τ -transitions are ignored.
The consequence of this equivalence is that our abstraction is sound and complete with respect to specification formalisms which cannot distinguish weakly bisimilar systems. Examples of temporal logics with this property are CTL\X and CTL∗
where the subscript “\X” refers to the respective fragment without the “next” operator (see [3] for details). Here, for every formula of such a logic, the property holds true in the abstract system if and only if it can be guaranteed for the original system. Thus the efficiency of model checking can be improved by considering the abstract instead of the original system.
An important aspect of our work is that the abstraction transformation is not carried out on the actual transition system itself but on its “compact description”, the Rewriting Logic specification. This is very different from settings where the complete original systems is required, such as the transformation of nondeterministic to deterministic finite automata by removal of ε-transitions, and generally reduces the peak memory requirements.
The remainder of this paper is organized as follows. Section 2 introduces the Rewriting Logic framework, which is then employed in Section 3 to formalize the operational semantics of the Erlang programming language. In Section 4 we present our abstraction technique, demonstrate its application to Erlang in Section 5, and establish its correctness in Section 6. Finally Section 7 concludes with some remarks.



The Rewriting Logic Approach
This section introduces our modeling formalism, Rewriting Logic, which is based on conditional term rewriting modulo equational theories. In order to support the efficient implementation of rewrite theories we will present a variant of the original definition in [10], which has been developed in [6,7].

Syntax of Labeled Rewrite Theories
Our goal is to model concurrent systems which are composed of (dynamically cre- ated) sequential processes. We therefore distinguish between terms that represent single processes and terms that represent concurrent process systems.
Definition 2.1 Let Σ be a signature and X = XP ∪ XS a set of (process and sys- tem) variables. The set of process terms over X, denoted by TP (X), is inductively defined by XP ⊆ TP (X), and f (t1,..., tn) ∈ TP (X) whenever t1,..., tn ∈ TP (X)
Σ	Σ	Σ
and f ∈ Σ(n). Let	∈/ Σ moreover be a binary function symbol. The set of system
terms over X, written TS(X), is inductively defined by XS ∪ TP (X) ⊆ TS(X) and
Σ	Σ	Σ
t1  t2 ∈ TS(X) whenever t1, t2 ∈ TS(X).
Σ	Σ
After these preliminaries we can introduce the syntax of labeled rewrite theories as our modeling formalism.
Definition 2.2 A labeled rewrite theory (LRT) is a quadruple T = (Σ, E, L, R)
where Σ is a signature, E ⊆ TP × TP is a finite set of (process) equations, L is a
Σ	Σ

Σ
transition rules, each represented as
c


→α1 d
Σ

... c




αk d

  1	1	k →  k 
l →α r
Thus a transition rule expresses how the (sub-)system represented by term l can evolve to r provided that the component processes ci have respective successor states di, for each 1 ≤ i ≤ k.

Semantics of Labeled Rewrite Theories
Reduction systems are the abstract mathematical models by which we represent computations of arbitrary systems. We are interested in particular reduction sys- tems in which certain labels are attached to the reductions to indicate the type of the reduction, and in which an element is distinguished as the initial state.
Definition 2.3 A labeled transition system (LTS) is a quadruple (S, s0, L, →) where
S is a set of objects called states, s0 ∈ S is the initial state, L is a finite set of labels,

and → = 
α∈L →
is a transition relation such that →α
⊆ S × S for every α ∈ L.

Here we assume that the set of labels, L, contains a distinguished element τ . This label indicates a local evaluation step without side effects, that is, a transition which does not “essentially” modify the current state. From now on we will use the symbol a to denote a transition which (possibly) involves side effects, that is, a ∈ L \ {τ}.
Based on this definition we can now give the (operational) semantics of labeled rewrite theories in terms of labeled transition systems. It formalizes the under- standing that a concurrent system whose current state is represented by the term s (or some E-equivalent thereof) can evolve to the state t provided that there exists

a transition rule whose left-hand side matches a subterm of s modulo E and whose conditions are fulfilled. This intuitive notion can be formally described as follows.
Definition 2.4 The transition relation of a labeled rewrite theory T ,
→T =		→α T ⊆ TS(X)/E × L × TS(X)/E,

is inductively defined by →α T := ∅ and

α	c  →α1 d
... c
αk d

→Tn+1
:= {([s]E, α, [t]E) |∃	1
1	k → k
l →α r
∈ R, w ∈ Pos(s),σ ∈ Sub

such that s|w =E lσ, t =E s[w ← rσ],


Here
and [ciσ]
α
E →Tn
[diσ]E
for every 1 ≤ i ≤ k}.

TS(X)/E := {[t]E | t ∈ TS(X)} is the quotient of TS(X) w.r.t. E,
Σ	Σ	Σ
[t]E := {s ∈ TS(X) | s =E t} denotes the E-equivalence class of t,
Pos(s) is the set of positions of s,
s|w denotes the subterm of s at position w ∈ Pos(s),
s[w ← t] is obtained from s by replacing s|w by t, and
Sub := {σ | σ : X → TS(X)} is the set of substitutions. Moreover n is called the depth of the respective transition.
Note that the transition relation induced by an LRT operates on system terms, and that it is closed under substitutions and contexts.

Weak Bisimulation
Our final goal is to reduce the size of the transition system which is induced by a given rewrite theory. To guarantee the correctness of the abstraction, the reduced system, in some sense, has to be equivalent to the original one. Here we will require that both systems are weakly bisimilar, meaning that each step of the original system can be simulated by a corresponding action of the reduced system and vice versa, where τ -transitions are ignored.
∗
Definition 2.5 Let (S, s0, L, →) be a LTS and s, t ∈ S. We write s ⇒ε t if s τ	t,
i.e., if there is a (possibly empty) sequence of τ -labeled transitions leading from s
to t. Moreover, for each α ∈ L, we write s ⇒α t if there exist s', t' ∈ S such that
s ⇒ε s' →α t' ⇒ε t. For each label α ∈ L, we mean αˆ to stand for ε if α = τ , and for
α otherwise.
A binary relation R ⊆ S1 × S2 over the sets of states of two LTSs A = (S1, s1, L, →1) and B = (S2, s2, L, →2) is a weak bisimulation if, whenever s R t and α ∈ L,
if s →α 1 s', then there exists t' ∈ S2 such that t ⇒αˆ 2 t' and s' R t', and
if t →α 2 t', then there exists s' ∈ S1 such that s ⇒αˆ 1 s' and s' R t'.

Two states s, t ∈ S are weakly bisimilar, written s ≈ t, if there is a weak bisimulation R such that s R t. The LTSs A and B with initial states s1 and s2, respectively, are weakly bisimilar if s1 ≈ s2.
We note that weak bisimilarity is an equivalence relation [12].

Modeling the Erlang Programming Language
In this section we present the application of the former framework to the program- ming language Erlang, which is mainly employed in telecom applications.

The Erlang Programming Language
Erlang/OTP is a programming platform providing the functionality for program- ming open distributed systems: the language Erlang with support for concurrency, and the OTP (Open Telecom Platform) middleware providing ready-to-use compo- nents and services such as, e.g., a distributed data base manager, support for “hot code replacement”, and design guidelines for using the components. For a complete description see [1].
In the following we consider a core fragment of the Erlang programming language which supports the implementation of dynamic networks of processes operating on data types such as atomic constants (atoms), integers, lists, tuples, and process identifiers (pids), using asynchronous, call-by-value communication via unbounded ordered message queues called mailboxes. Real Erlang has several additional fea- tures such as modules, distribution of processes (onto nodes), and support for ro- bust programming and for interoperation with non-Erlang code written in, e.g., C or Java.
Besides Erlang expressions e we operate with the syntactical categories of match- ing clauses cs, patterns p, and values v. The abstract syntax of Erlang expressions is summarized as follows:
e ::= e1, e2 | e(e1,..., en) | case e of cs end | p = e | e1!e2
| receive cs end | op(e1,..., en) | spawn(e1, e2) | self() | X cs ::= p1 → e1; ... ; pn → en
p ::= op(p1,..., pn) | X
v ::= op(v1,..., vn)
Here X ranges over Erlang variables, and op ranges over a set of primitive constants and operations including tupling {e1, e2}, list prefix [e1|e2], the empty list [], integers, pid constants, and atoms.
The functional sublanguage of Erlang is rather standard: atoms, integers, lists and tuples are value constructors; e1, e2 denotes sequential composition; and a func- tion call is represented by e(e1,..., en). An expression of the form case e of cs end involves matching: the value that e evaluates to is matched sequentially against the patterns pi. If this succeeds, evaluation continues with ei where the variables bound by pi are correspondingly instantiated, otherwise a runtime error is raised. The same is true for the assignment p = e where a runtime error is raised if the

-module locker	start() ->
-export([start/0]).	Locker = spawn(locker, []), spawn(client, [Locker]), spawn(client, [Locker]).
locker() ->
receive	client(Locker) ->
{request, Client} ->	Locker!{request, self ()},
Client!ok,	receive
receive	ok ->
{release, Client} ->	% critical section locker()	Locker!{release, self ()},
end	client(Locker)
end.	end.
Fig. 1. A Resource Locker in Erlang

value of e does not match p, and where this value is returned as the result otherwise. The constructs involving non-functional behavior (i.e., side effects) are e1!e2 which denotes an output operation, sending the value of e2 asynchronously to the process identified by e1, whereas receive cs end inspects the mailbox q of the local process and retrieves (and removes) the first element in q that matches any pattern in cs. Once such an element v has been found, evaluation continues analogously to case v of cs end; otherwise, the process waits for a corresponding message to arrive. The expression spawn(e1, e2) dynamically creates a new process in which the function given by e1 is applied to the arguments given by the list e2 (and returns
the pid of the new process), and self() returns the pid of the local process.
As an introductory example we consider a short Erlang program which imple- ments a simple resource locker, i.e., an arbiter which, upon receiving corresponding requests from client processes, grants access to a single resource. It is given in Figure 1. An extended version of the algorithm is presented in [2].
Any Erlang program consists of a set of modules. Each module basically contains a list of function declarations. In our example the system is defined in one module. It is initialized using the start function, which, according to the export declaration, is the only function accessible from outside the locker module. By calling the spawn function, it generates three new processes: one locker and two clients.
The locker process runs the locker function in a non-terminating loop. It employs the receive construct to check whether a request message has arrived. The latter is expected to be a pair composed of a request tag and a client process identifier (which is matched by the variable Client). The client is then granted access to the resource by sending an ok flag. Finally, after receiving the release message from the respective client, the locker returns to its initial state.
A client process exhibits the complementary behavior. By issuing a request, it demands access to the resource. Here, the self builtin function returns the process identifier of the client process, which is then used by the locker process as a handle to the client. After receiving the ok message it accesses the resource, and releases

it afterwards.

A Formal Semantics of Erlang
In this section we present an overview of the formal semantics of Erlang. For details see [5,14].
The Erlang runtime system maintains a set of user processes. Any such process consists of three components: an Erlang expression which has to be evaluated, a process identifier which uniquely identifies the respective process, and which is internally determined by the system, and a mailbox for incoming messages, which is essentially a list of Erlang values. Moreover we will attribute a current evaluation environment to a process, which stores the bindings between the Erlang variables and the values assigned to them.
As before we will use certain standard denotations for the Rewriting Logic vari- ables occurring in the rules, possibly in indexed or primed form. We let e denote an Erlang expression, p a pattern, X an Erlang variable, a an atom, v a value, f a function name, and c a clause. Moreover α refers to a transition label, cs to a list of clauses, i, j, k to pids, q to a mailbox, ρ to an environment, and s to a concurrent process system. Thus a single process is represented by a term of the form ⟨e | i | q | ρ⟩.

The Equational Theory
The next step involves the definition of the set of equations, E, of our rewrite theory. We only declare the parallel operator  to be associative and commutative: E := {s1  (s2  s3) = (s1  s2)  s3 , s1  s2 = s2  s1}.

The Transition Rules
The most important part of our definition is the formalization of the operational behavior of Erlang process systems by conditional transition rules. To obtain a cleaner structure we decompose R into two disjoint subsets: R := RP ∪ RS. Here, RP contains the so-called process-level rules which operate on single processes while RS, the set of system-level rules, deals with concurrent process systems. In the following we present some examples from both categories, again referring to [14] for the complete definition.


Process-Level Rules
The first rule describes the recursive evaluation of lists. Due to the leftmost- innermost evaluation strategy of Erlang we have to start the evaluation with the first expression in the list constructor.
⟨e1 | i | q | ρ⟩ →α ⟨e' | i | q' | ρ'⟩
	1	
(list1)
⟨[e1 | e2] | i | q | ρ⟩ →α ⟨[e' |e2] | i | q' | ρ'⟩

As soon as the first subexpression of the list constructor is irreducible (i.e., a value), evaluation proceeds with the second subexpression:

⟨e | i | q | ρ⟩ →α
⟨e' | i | q' | ρ'⟩

(list2)
⟨[v|e] |
i | q
| ρ⟩ →α
⟨[v|e'] |
i | q' |
ρ'⟩

The next rules formalize the behavior of the sequencing construct. The evalu- ation starts with the first subexpression and then proceeds to the second, ignoring the result of the first.
⟨e1 | i | q | ρ⟩ →α ⟨e' | i | q' | ρ'⟩
	1	
(seq1)
⟨e1, e2 | i | q | ρ⟩ →α ⟨e' , e2 | i | q' | ρ'⟩

(seq2)
⟨
v, e | i | q | ρ⟩ →τ  ⟨e | i | q | ρ⟩

The following rules deal with pattern-matching operations. Here we just formal- ize the case construct.

⟨e | i | q | ρ⟩ →α
⟨e' | i | q' | ρ'⟩

(case1)
⟨case e of
cs end |
i | q
| ρ⟩ →α
⟨case
e' of
cs end |
i | q' |
ρ'⟩

match(v, cs, ρ) →τ
(e, ρ')

(case2)
⟨case v
of cs
end | i | q
| ρ⟩ →τ
⟨e | i | q
| ρ'⟩

Here match(v, cs, ρ) tests whether one of the clauses in cs matches the value v, and if successful returns both the instantiated right-hand side expression and the modified environment.
Next we consider one of the Erlang builtin functions which evoke side effects on the system level of the semantics:

(spawn)

⟨spawn(a, v) | i | q | ρ⟩

spawn(a,v,j)
−→	⟨j | i | q | ρ⟩

Here j denotes a fresh pid which uniquely identifies the new process, and which is returned as the result of the call of spawn. This can be formalized by introducing a “next pid” component in the system states; details can be found in [13,14].
Finally the following rule handles one of the central concepts of Erlang: asyn- chronous sending of messages. As we shall see the message will be appended to the mailbox of the target process. Note that a process can also send a message to itself.

(send)

⟨j!v | i | q | ρ⟩

msg(j,v)
−→	⟨v | i | q | ρ⟩


System-Level Rules
The first rule just expresses that if a single process in a concurrent system performs a computation step then so does the complete system.

⟨e | i | q | ρ⟩ →τ
⟨e' | i | q' | ρ'⟩

(Silent)
⟨
τ	'	'	'

Process generation is formalized as follows. As can be seen from rule (spawn), the spawn builtin function comes with two arguments: a function atom, and a list

of arguments. The new process will call this function with these arguments, starting with the empty mailbox and the empty environment.
⟨e | i | q | ρ⟩ spawn(a,v,j) ⟨e' | i | q | ρ⟩
(Spawn)
⟨	τ	'
Next we specify how a message is stored in the mailbox of the receiving process.

⟨e | i | q | ρ
msg(j,v) ⟨e'
| i | q' | ρ' ⟩

(Com)
⟨
1	1	1⟩	−→
τ	'
1	1	1
'	'

e1 | i | q1 | ρ1⟩  ⟨e2 | j | q2 | ρ2⟩ s → ⟨e1 | i | q1 | ρ1⟩  ⟨e2 | j | q2 · v | ρ2⟩ s
Many more rules are required to complete the definition of our rewrite theory for Erlang. Together with an initial expression e0, it induces the LTS (S, s0, L, →) where s0 is the initial state given by s0 = [⟨e0 | i0 | ε | ε⟩]E for some initial pid i0.

Equational Abstraction
In the following we describe how to use equational abstractions to reduce the state space of the transition system. The idea is to “hide” computation steps which are defined by unconditional τ -rules because those do not involve side effects which could be interesting to observe. An example is rule (seq2) from our Erlang specification in the previous section, which merely discards the first expression in a sequence as soon as it has been evaluated to normal form. Another example is the invocation of a function by replacing the call with its body.
Of course it would be possible to apply this abstraction on the original transition system, similar to transforming of nondeterministic to deterministic finite automata by removing ε-transitions. This, however, would imply that we have to compute the complete LTS before, meaning that the peak memory requirements are not improved.
Here we follow an alternative approach by modifying the Rewriting Logic spec- ification instead such that the reduced LTS can be directly computed. Technically
this will be achieved by moving unconditional τ -rules from the set of transition rules to the equational theory. This simple idea yields the following ad hoc definition.
Let T = (Σ, E, R, L) be a LRT. The modiﬁed LRT T ' = (Σ, E', R', L) is obtained by shifting rules from R to E as follows:
R' := R \  l →τ r ∈ R | l, r ∈ TP (X),
E' := E ∪  (l, r) | l →τ r ∈ R, l, r ∈ TP (X),
However this simple modification is not correct in the sense that the induced LTSs of the original and of the modified LRT are generally weakly bisimilar. This is due to the following two problems.
Nondeterminism: We assume an LRT T = (Σ, E, R, L) with E = ∅, and with

the following transition rules: R =	b →τ
'
c , b →τ
d , c →a
a
d	.
'

In the modified LRT T , b =E' c =E' d and c → d  ∈ R .  Hence there is

an infinite sequence of a-transitions of the form [b]E' →T ' [b]E' →T ' ... In the
original LRT, however, every computation is terminating: [b]E →τ T [c]E →a T [d]E and [b]E →τ T [d]E. Thus the two transition systems are not weakly bisimilar.
τ -rules in conditions: Let T = (Σ, E, R, L) with E = ∅, and with the following transition rules:


	x1 →τ

y1 x2 →a y2
a	,	τ	,	a	.

h(x1, x2) → h(y1, y2)
b → c
d → e


Then [h(b, d)]E →T [h(c, e)]E, but [h(b, d)]E' does not have an a-successor in T '.
It is clear that the first problem, which is caused by the possible choice between an unconditional τ -transition and some other transition, cannot be solved by a sim- ple construction. We therefore proceed by restricting the LRTs under consideration, assuming all unconditional τ -rules to be deterministic in the following sense.



Definition 4.1 A labeled rewrite theory T = (Σ, E, L, R) is called restricted if it satisfies the following conditions:

if l1 →τ r1 ∈ R, then there exist no 	C	
∈ R and w ∈ Pos(l2) such that

l1 =E l2|w, and
l2 →α r2

l →τ  r

all transition rules on system level are of the form
l	s →τ  r	s
∈ R where

s ∈ TS(X), or
l →a r
a
∈ R where s, s'
'
∈ TS(X).

l  s → r  s



We note that it is decidable whether a given LRT is restricted or not, provided that the equational theory is decidable.
The second problem, the presence of τ -rules in conditions, can be solved by changing the construction of the modified LRT. The idea is the following: whenever a condition can be satisfied by applying an unconditional τ -rule, we add a new rule which is obtained by dropping this condition under the appropriate instantiation. This can be formalized as follows.



Definition 4.2 Let T = (Σ, E, R, L) be a restricted labeled rewrite theory.  Its
modiﬁcation T ' = (Σ, E', R', L) is obtained by applying the following algorithm:



R' := R; E' := E;
for all l1 →τ  r1 ∈ R with l1, r1 ∈ TP (X) do
R' := R' \  l1 →τ r1 , ;
E' := E' ∪ {(l1, r1)};
c →α1 d  ... c  αk d

for all
  1	1	k → k  ∈ R', 1 ≤ i ≤ k and σ ∈ Sub

l2 →α r2
such that l1σ =E ciσ and r1σ =E diσ do


R' := R' ∪
	... ci−1
αi−1
σ → d

i−1
σ ci+1
αi+1
σ → d

i+1
σ ... 


end for end for
l2σ →α
r2σ

Obviously the algorithm terminates for all LRTs as the number of unconditional τ -rules in R is finite. If this number is denoted by n and if m denotes the maximal number of conditions in R-rules, then the size of the modified set of transition rules, R', is quadratically bounded:
|R'|≤ |R|− n + (|R|− n)mn ≤ m|R|2.
Note that the transformation possibly creates new unconditional τ -rules in R', in which case it can be applied iteratively. The overall correctness is then guaranteed since, as we will see in Section 6, the LTSs of the modified rewrite theory is weakly bisimilar to the original one, and since weak bisimilarity is an equivalence (and thus transitive).
Application to Erlang
Before studying the effect of hiding unconditional τ -rules we have to show that the LRT for Erlang is restricted. But this is straightforward since unconditional τ -rules are deterministic and all rules on the system level have the required form.
We now demonstrate the construction of the modified LRT for Erlang, concen- trating on the rules for lists and for sequential evaluation which were developed in Section 3:
⟨e1 | i | q | ρ⟩ →α ⟨e' | i | q' | ρ'⟩
	1	
(list1)

⟨[e1 | e2] | i | q | ρ⟩ →α
(seq2)	τ
⟨
⟨[e' |e2] | i | q' | ρ'⟩

v, e | i | q | ρ⟩ → ⟨e | i | q | ρ⟩
The construction in Def. 4.2 then removes (seq2) from the set of transition rules, adds it to the equational theory, and yields the following modification of (list1):
(list' )
1  ⟨[(v, e )|e ] | i | q | ρ⟩ →τ  ⟨[e |e ] | i | q | ρ⟩
1	2	1  2



Table 1
Original vs. Abstract Locker System

Applying this modification procedure iteratively to the complete Erlang speci- fication, we obtain a modified LRT which induces the abstract LTS. Adapting our prototype implementation of (Core) Erlang in Maude [13], we can now compare the size of the state space of the original and abstracted LTS for a varying number of client processes. The corresponding figures are given in Table 1. 3
We see that the equational abstraction reduces the state space by orders of magnitude, implying that typical verification problems such as mutual exclusion, the absence of deadlocks, and starvation freedom can be analyzed more efficiently. The following section shows that this approach is correct: the original and the abstract system can be shown to be weakly bisimilar. This means, e.g., that for deciding the model-checking problem for logics which do not distinguish weakly bisimilar systems it suffices to consider the abstract system.

Correctness Proof
We can now show that the LTS which is induced by a (restricted) LRT and the LTS which is induced by the modification of the former are weakly bisimilar. To this aim we first prove two intermediate results, which only deal with single processes. The first one expresses that every transition in the original system which is not obtained via an unconditional τ -rule is also present in the abstract system.
Lemma 6.1 Let 7 = (Σ, E, R, L) be a restricted LRT, 7 ' = (Σ, E', R', L) the
P	α
corresponding modiﬁed LRT, s, t ∈ TΣ (X), and α ∈ L. If [s]E →T [t]E and s /=E'\E
t, then [s]E' →T ' [t]E' .
Proof. We prove the claim by induction over the depth of the transition in the original LRT 7 according to Def. 2.4.
n = 0: clear since →T0 = ∅
α
n → n + 1: let [s]E →Tn+1 [t]E and s /=E'\E t. According to Def. 2.4, there exist
c →α1 d  ... c  αk d

  1	1	k →  k 
∈ R, w ∈ Pos(s) and σ ∈ Sub such that s|w =E lσ,

l →α r

t =  s[w ← rσ], and [c ]	αi	[d ]
for every 1 ≤ i ≤ k.

E	i E →Tn	i E
We distinguish the following cases:
α = τ :  here k ≥ 1 since otherwise s =E'\E  t.  Now the analysis of the

3 The numbers differ from those obtained in [15] since the latter does not consider the core language, and since it employs the ELAN rewriting tool.

conditions [c ]	αi	[d ]
for 1 ≤ i ≤ k yields:

i E →Tn	i E

if ci /=
E'\E
di, then [ci]E →α
T ' [di]E by induction hypothesis.

if ci =E'\E di, then by construction of the modified LRT according to Def. 4.2
there exists 	C	 ∈ R' where C is obtained by dropping ci →τ di, which
lσ →α  rσ
α

is therefore satisfied. Thus [s]  → '
n+1
[t]E.

' τ	'

α /= τ : here s /=E'\E t since otherwise there exists l → r ∈ R, w ∈ Pos(s)
and σ ∈ Sub such that s|w =E l'σ and t =E s[w ← r'σ]. This, however,
α

contradicts the first restriction in Def. 4.1. Thus [s] → '
n+1
[t]E by induction

hypothesis.

The next lemma claims that every transition in the modified LRT corresponds to a transition in the original LRT.
Lemma 6.2 Let 7 = (Σ, E, R, L) be a restricted LRT, 7 ' = (Σ, E', R', L) the cor-
P	α	α
responding modiﬁed LRT, s, t ∈ TΣ (X), and α ∈ L. If [s]E' →T ' [t]E' , then [s]E →T
[t]E.
Proof. Again we prove the claim by induction over the depth of the transition, now in the modified LRT.
n = 0: clear

α	c  →α1 d
... c
αk d

n → n + 1: let [s] ' → '
n+1
E' . Then there exist
  1	1	k →  k 
l →α r
∈ R', w ∈
αi

Pos(s) and σ ∈ Sub such that s|w =E' lσ, t =E' s[w ← rσ], and [ci]E' →T ' [di]E'
for every 1 ≤ i ≤ k. We distinguish the following cases:
c →α1 d  ... c  αk d	α

If   1	1	k → k  ∈ R, then, by induction hypothesis, [ci]E →i T
[di]E

l →α r	n

for every 1 ≤ i ≤ k, and hence [s]E →α T

n+1
[t]E.

Otherwise, the transition rule has been added in the construction of the modified LRT as described in Def. 4.2. Corresponingly, there exist m > k, ck+1,..., cm, dk+1,..., dm ∈ TP (X) and σ ∈ Sub such that
c →α1 d  ... c  αk d  c	→τ  d	... c	→τ  d
  1	1	k →  k  k+1	k+1	m	m  ∈ R,
l' →α r'

l =	l'σ, r =	r'σ, [c ]	αi	[d ]
for 1 ≤ i ≤ k, and [c σ]	→τ	[d σ]
for

E	E	i E →Tn	i E
j	E	Tn	j	E

k +1 ≤ j ≤ m. Altogether this again implies [s]E →α T

n+1
[t]E


Both results now enable us to give the full bisimulation proof, showing that our construction of the modified LRT yields an abstract system which is weakly bisimilar to the original one.
Theorem 6.3 Let 7 = (Σ, E, R, L) be a restricted LRT, 7 ' = (Σ, E', R', L) the cor- responding modiﬁed LRT, and s0 ∈ TS(X) be some initial term. Then the induced LTSs (TS(X)/E, [s0]E, →T , L) and (TS(X)/E', [s0]E' , →T ' , L) are weakly bisimilar.
Σ	Σ

Proof. We show that the following relation is a weak bisimulation:
R := {([s]E, [s']E' ) | s =E' s'}.
To this aim we have to prove that both transition systems weakly simulate each other w.r.t. R.
(TS(X)/E', [s0]E' , →T ' , L) simulates (T S(X)/E, [s0]E, →T , L):
Σ	Σ
let [s]E →α T [t]E. We distinguish the following cases:

s ∈ TP : if s /=
E'\E
t,  then  [s]E'  →
T ' [t]E
αˆ
' by Lemma 6.1. Hence [s]E'	T '

[t]E' . Otherwise, α = τ and thus [s]E' ⇒T ' [t]E' .
s ∈ TS \ TP : here s can be represented as s = p	ps where p ∈ TP (X) and
Σ	Σ	Σ
ps ∈ TS(X). Moreover [s]E →α T [t]E implies that there exist
c →α1 d  ... c  αk d
  1	1	k → k  ∈ R,

l →α r
w ∈ Pos(s) and σ ∈ Sub such that s|w =E lσ, t =E s[w ← rσ] and [ciσ]

α
E →T

[diσ]E for every 1 ≤ i ≤ k. According to Def. 4.1, two cases are possible:

l →τ  r
·	τ
∈ R: if s /=E'\E t, then [s]E' →T ' [t]E' by Lemma 6.1, and

l  u → r  u
αˆ	αˆ
thus [s]E' ⇒T ' [t]E' . Otherwise, [s]E' ⇒T ' [t]E' since the transition can be simulated by equational transformations.

l →a r
·	a
∈ R: here s /=E'\E t and t = p'
'
ps'
since otherwise

l  u → r  u
'	τ
p =E'\E p , and thus there would exist l → r ∈ R, w ∈ Pos(p) and σ ∈ Sub
such that p|w =E l'σ and t =E p'[w ← r'σ], in contradiction to Def. 4.1.
α	αˆ
Hence [s]E' →T ' [t]E' by Lemma 6.1, and thus [s]E' ⇒T ' [t]E' .
(TS(X)/E, [s0]E, →T , L) simulates (T S(X)/E', [s0]E' , →T ' , L):
Σ	Σ
α
let [s]E' →T ' [t]E' . Again we distinguish two cases:
s ∈ TP : here the transition can be divided into the following three parts.
equational transformations: s =E'\E s'
'	α	'
actual transition: [s ]E' →T ' [t ]E'
equational transformations: t' =E'\E t
Each of these parts can be simulated in (TS(X)/E, [s0]E, →T , L) as follows.
Since E' and E only differ in the equations added by unconditional τ -rules, there exist [t1]E,..., [tn]E with [ti]E →τ T [ti+1]E for 1 ≤ i ≤ n − 1, [t']E →τ
[t1]E, and [tn]E →τ  [t]E.
Here [s']E →α T [t']E by Lemma 6.2.
just as in (a)
Altogether we conclude that [s]E ⇒αˆ T [t]E.
s ∈ TS \ TP : here s and t can be represented as s = p	ps and t = q	ps',
Σ	Σ

respectively.  Correspondingly there exists	l →α
l	x →α
r
r	x'
∈ R, and the

transition can be divided into the following four parts.
equational transformations: p =E'\E p'

actual transition: [p'
 ps]E' →T ' [q'
 ps'']E'

equational transformations: q' =E'\E q
equational transformations: ps'' =E'\E ps'
Again each of these parts can be simulated in (TS(X)/E, [s0]E, →T , L) as
follows.
Since E' and E only differ in the equations added by unconditional τ -rules,
there exist [p1  ps]E,..., [pn  ps]E with [pi  ps]E →τ T [pi+1	ps]E for
every 1 ≤ i ≤ n − 1), [p  ps]E →τ [p1  ps]E, and [pn	ps]E →τ  [p'	ps]E.
Since [p']E →α [q']E by Lemma 6.2, [p'  ps]E →α T [q'	ps'']E.
just as in (a)
By applying equational transformations we can only stay in the same equiv- alence class.
Altogether we again conclude that [s]E ⇒αˆ T [t]E.

Conclusions and Related Work
In this paper we have shown how equational abstractions can be used in the Rewrit- ing Logic framework to reduce the state space of concurrent systems. In particular we have seen how to construct for a given restricted LRT a new one whose in- duced LTS is weakly bisimilar to the LTS induced by the original LRT, avoiding the construction of the (big) original LTS. Thus our abstraction can be employed to obtain efficient model-checking algorithms for logics such as CTL\X which cannot distinguish weakly bisimilar systems. We have demonstrated the use of the pro- posed method with the concurrent functional programming language Erlang. For the locker example we have seen that equational abstraction leads to a significant reduction of the state space.
The work described in the present paper builds on results in [15] where the idea of moving unconditional τ -transitions to the equational theory has been introduced, again in the context of the Erlang programming language, but no correctness proof has been given. In fact, as the discussion in Section 4 shows, the simple idea of turning unconditional τ -rules to equations does not work out; requiring a more elaborate construction.
Another publication which employs equations to define abstraction mappings on the state space is [11]. Here, in contrast to our work, the abstraction is expected to be correct only w.r.t. linear-time properties such that the resulting abstract systems are generally not weakly bisimilar to the original one. Moreover [4] studies the application of partial-order reduction techniques in a Rewriting Logic setting, again employing a notion of equivalence (stuttering) which is different from ours.

References
Armstrong, J., S. Virding, M. Williams and C. Wikstr¨om, “Concurrent Programming in Erlang,” Prentice Hall International, 1996, 2nd edition.

Arts, T., C. Earle and J. Derrick, Verifying Erlang code: a resource locker case study, in: Formal Methods – Getting IT Right, Lecture Notes in Computer Science 2391 (2002), pp. 184–203.
Emerson, E., “Temporal and Modal Logics,” Handbook of Theoretical Computer Science B, Elsevier, 1990 pp. 996–1072.
Farzan, A. and J. Meseguer, State space reduction of rewrite theories using invisible transitions, in: 11th Int. Conference on Algebraic Methodology and Software Technology (AMAST ’06), Lecture Notes in Computer Science 4019 (2006), pp. 142–157.
Fredlund, L.-A. and H. Svensson, McErlang: a model checker for a distributed functional programming language, SIGPLAN Not. 42 (2007), pp. 125–136.
Leucker, M. and T. Noll, Rapid prototyping of specification language implementations, in: Proceedings of the 10th IEEE International Workshop on Rapid System Prototyping (RSP’99) (1999), pp. 60–65.
Leucker, M. and T. Noll, Rewriting logic as a framework for generic verification tools, in: Proceedings of Third International Workshop on Rewriting Logic and Its Applications (WRLA’00), Electronic Notes in Theoretical Computer Science 36 (2001), pp. 121–137.
Mart´ı-Oliet, N. and J. Meseguer, Rewriting logic: Roadmap and bibliography, Theoretical Computer Science 285 (2002), pp. 121–154.
Meseguer, J., Rewriting as a unified model of concurrency, in: Proceedings Int. Conference on Concurrency Theory (CONCUR’90), number 458 in Lecture Notes in Computer Science (1990), pp. 384–400.
Meseguer, J., Conditional rewriting logic as a unified model of concurrency, Theoretical Computer Science 96 (1992), pp. 73–155.
Meseguer, J., M. Palomino and N. Mart´ı-Oliet, Equational abstractions, in: 19th Int. Conference on Automated Deduction (CADE-19), Lecture Notes in Computer Science 2741 (2003), pp. 2–16.
Milner, R., “Communication and Concurrency,” International Series in Computer Science, Prentice– Hall, 1989.
Neuh¨außer, M. and T. Noll, Abstraction and model checking of Core Erlang programs in Maude, in: Proceedings of the 6th International Workshop on Rewriting Logic and its Applications (WRLA’06), Electronic Notes in Theoretical Computer Science 176 (2007), pp. 147–163.
Noll, T., A rewriting logic implementation of Erlang, in: Proceedings of First Workshop on Language Descriptions, Tools and Applications (ETAPS/LDTA’01), Electronic Notes in Theoretical Computer Science 44(2) (2001), pp. 206–224.
Noll, T., Equational abstractions for model checking Erlang programs, in: Proceedings of the International Workshop on Software Verification and Validation (SVV ’03), Electronic Notes in Theoretical Computer Science 118 (2005), pp. 145–162.
