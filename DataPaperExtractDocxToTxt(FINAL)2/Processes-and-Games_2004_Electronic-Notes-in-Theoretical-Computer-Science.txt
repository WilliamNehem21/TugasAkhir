Electronic Notes in Theoretical Computer Science 71 (2003)
URL: http://www.elsevier.nl/locate/entcs/volume71.html 30 pages


Processes and Games

Kohei Honda 1,2
Department of Computer Science, Queen Mary, University of London, London, E1 4NS, UK.


Abstract
A general theory of computing is important, if we wish to have a common mathemat- ical footing based on which diverse scientific and engineering efforts in computing are uniformly understood and integrated. A quest for such a general theory may take different paths. As a case for one of the possible paths towards a general theory, this paper establishes a precise connection between a game-based model of sequential functions by Hyland and Ong on the one hand, and a typed version of the π-calculus on the other. This connection has been instrumental in our recent efforts to use the π-calculus as a basic mathematical tool for representing diverse classes of behaviours, even though the exact form of the correspondence has not been presented in a published form. By redeeming this correspondence we try to make explicit a convergence of ideas and structures between two distinct threads of Theoretical Computer Science. This convergence indicates a methodology for organ- ising our understanding on computation and that methodology, we argue, suggests one of the promising paths to a general theory.
Key words: Game semantics, typed π-calculus


Introduction
Computing in the modern world is characterised by diversity and rapid change. Science of computing is no exception, where we have diverse activities and theories dealing with different subject matters and using different approaches. All the more so there is a value in seeking a general theory of computing which can, among others, offer a common mathematical footing on which we can unify and integrate these diverse scientific theories and engineering disci- plines. Such a general theory is expected to act on science and engineering of computing as basic physical theories have acted on natural sciences and engi- neering, in spite of a different nature of computing from physical phenomena (on this difference we do not extend further here; except noting the complexity

1 Partially supported by EPSRC grant GR/N/37633
2 Email: kohei@dcs.qmul.ac.uk
◯c 2003 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


of computing systems – in particular software – nowadays practically requires their general and precise treatment as needed for natural phenomena). From a scientific viewpoint, a general theory would help us organise scientific knowl- edge on computing and for promoting further research based on the obtained unified understanding. From an engineering viewpoint. without such a unify- ing theory, it is hard to envisage how we can integrate diverse methodologies for building and controlling computing systems. Such integration becomes essential when we need to control the behaviour of an application consisting of distributed components written in different programming languages which, as a whole, serve users’ needs.
Thus a search for a general theory of computing is important, both from scientific and engineering viewpoints. And a quest to reach a general theory may take different paths and methodologies. For example we may introduce a general algebraic framework which capture different notions of computation, as in Concurrent term rewriting introduced by Meseguer [33] and tile model of computation by Montanari and others [12], recent results from both of these strands being discussed in the present proceedings; another model developed with a similar goal is Milner’s theory of bigraphs [39]. As exemplified in the present proceedings and in a recent work by Jensen and Milner [26], such an algebraic framework can offer a basis of integrated, and often illuminating, understanding of existing systems and theories, as well as a broad platform
for experimentation and development of new concepts, methodologies and engineering ideas.
A different approach to a general theory would start from distinct, but equivalent, presentations of a theory for a core, if restricted, class of compu- tation, so that one can find the fundamental shape of such a theory. Each of these different presentations serves a specific scientific/engineering need: as a whole, they offer a firm basis for ramifications and applications. After we reach a satisfactory account of the theory, which may in particular include the equivalence of different presentations, one may extend it to a broader class of computation. Hoare [16] laid down a strong case for this approach, focussing on a theory of basic imperative programming, for which he studies different (observational, algebraic and operational) ways of presenting the same the- ory, and showing they are equivalent to each other in the sense that each is derivable from another in a cyclic way. Different presentations not only serve different engineering purposes but also clarify distinct forms mathematical theories of computing can take: their mutual derivability allows flexibility in applications and adds the confidence to their mathematical status.
Finally, yet another approach would single out a concrete mathematical structure which can represent a large class of computational phenomena, and would try to develop a general theory on the basis of the structure. When the chosen structure has a wide repertoire for representing computation, and when this representation helps us reason about, and control, computational phenomena effectively (in comparison with directly dealing with them), this


method would particularly be successful. Theory of domains and denotational semantics, initiated by Scott and Strachy [45], is a forerunner of this approach. These different approaches compensate each other: without ambient gen- eral algebraic theories, the understanding of specific structures would be a limited one; but a general algebraic theory may as well become most effective when combined with a powerful concrete structure. Different presentations of a core theory may as well be extended to a general algebraic universe, gaining in both richness and applicability; and the former may suggest an alternative, useful presentation of a general algebraic universe which would help its deeper understanding. In fact, any general theory, however powerful, can give only one way of abstracting computational phenomena: other abstraction would always be possible, and the interplay among different mathematical abstrac- tions will enrich our scientific understanding. Thus distinct directions may as
well be pursued, while allowing mutual enriching interactions.
This paper tries to place a small piece of a technical result in this broad arena of conversations, establishing an equivalence between a semantic uni- verse introduced by Hyland and Ong [24], 3 on the one hand, and a theory of typed processes [5] centring on Milner, Parrow and Walker’s π-calculus [40] on the other. The equivalence between these two theories, initially observed in [5], as well as its connection to Linear Logic [14] has been instrumental in our recent efforts to use the typed π-calculus as a basic tool for representing and analysing diverse classes of computations [5,6,47,23], even though the ex- act shape of correspondence has not been presented in a published form. By presenting this correspondence in a precise form, we hope to show how two distinct threads of studies have reached a common structure for representing computation. These two threads have quite different origins: the π-calculus is a calculus which, based on the preceding study on process algebra [4,15,35], tries to capture concurrent computation with dynamic change of structure in a simple syntax; while the semantic universe by Hyland and Ong, based on the preceding semantic studies on sequentiality (cf. [44,34,27,7,8,42]), was introduced for giving a precise semantic account of sequentiality in higher- order functions. Furthermore, the version of the π-calculus which is at the centre of this coincidence, is the minimal system which Boudol, Tokoro and I introduced in the beginning of 90’s as a formalism for capturing distributed computation, whose dynamics is based on the following communication rule:
x(→y).P |x⟨→v⟩ −→ P{→v/→y}.
The asynchronous communication is the unconstrained, fluid[35] form in com- parison with the synchronous communication, maximising potential concur- rent activities. Processes in this asynchronous version of the π-calculus are precisely those constituting interactions in the semantic universe of sequen-

3 Closely related semantic universes were independently introduced by Abramsky, Ja- gadeesan and Malacaria [1] and by Nickau [41].


tiality, combined with a notion of types which impose a behavioural constraint by which processes behave just like sequential higher-order functions do.
The significance of this coincidence arises in two ways. First, it suggests the breadth of computational phenomena which are precisely representable by the operational structure found in both strands, name passing processes. 4 It may be safe to say that sequential pure functions are what the π-calculus was least expected to precisely capture: thus its representability in the π-calculus, ob- tained through its connection to Hyland-Ong games, strongly suggests similar results for other classes of computation, including diverse forms of concurrent and distributed computation. In other words, the precise representability of sequential higher-order functions in Hyland-Ong games gets positioned in a broader context by moving into the π-calculus.
Secondly, the technical result which relates Hyland-Ong games to the π- calculus accompanies a concrete method by which we may obtain precision in representation of computation for name passing processes. In the π-calculus, there have been a series of studies (starting from Milner [37], cf. [43,29,17,18]) on a notion of types called sorting, which essentially constrain the usage of names in processes and thus their behaviour. It turned out that a clean and
simple type structure arises from the π-calculus representation of Hyland-Ong games which can in fact be positioned as a ramification of the existing notions of types for the π-calculus processes. A couple points are notable regarding this type structure. First it has several novel features in comparison with exist- ing process types, among others duality (in a form close to Linear Logic [14]). Second, this type structure was only implicitly present in Hyland-Ong games,
at least in its entirety: there, dynamic behavioural specifications on interac- tion, including innocence, are used in conjunction with static type structure. By moving to the π-calculus, a simple static type discipline is made explicit which in fact turns out to be equivalent to the original specifications. Third,
and most interestingly, the resulting typed universe of processes articulates a broader class of sequential pure functions than in the original Hyland-Ong games, capturing, for example, call-by-value behaviour (see [5]; in Section 6 later we show how we can “read off” the universe of Hyland-Ong games from that of typed processes as a proper subset of the latter). By subsequent stud- ies on game semantics and on typed π-calculi, both discussed below, we find the sequential types born from Hyland-Ong games constitutes one member of a uniform family of types for processes which characterise various forms of computation.
Thus the connection between the π-calculus and Hyland-Ong games not only indicates the significance of a certain operational structure they have in common; it also indicates a concrete way to use this structure for precise representability, suggesting a new tool and framework for studying computa-

4 Regarding this point, Milner’s address at Bologna [38] described the π-calculus as a calculus whose goal is the “analysis ... of informatic systems”, comparing it to the differential calculus whose goal is the “analysis of physical systems”.


tion. The π-calculus and its types based on duality together offer a uniform basis for precisely modelling the behaviour and algebras of different classes of computation, anticipating one possible form of a general theory.
We conclude this introduction with further discussions on the relationship of the present work to other studies. As we already mentioned, the π-calculus is one of the recent forms of process algebras. Different forms of process alge- bras (including ACP [4], CSP[15] and CCS/SCCS [35]) are based on different notions of synchronisations and process composition. The use of name passing in the π-calculus — its distinguishing feature — is better positioned as a way to enrich structures of interaction in a way orthogonal to distinction among different process calculi. In this sense, that a very simple form of name passing suffices to induce a large universe of computation is encouraging to explore larger universes in which different notions of synchronisations and other con- currency primitives are combined with name passing. It is notable that the common strata of many process algebras, among others parallel composition and hiding, play the essential roˆle in the present theory: while its use of types and asynchrony in communication may constitute novel elements from the viewpoint of standard process algebras.
Connection between Hyland-Ong games and the π-calculus was observed by Hyland and Ong themselves [25].  The difference between the result in
[25] and this work, as well as [5], is that [25] specifies processes based on behavioural characterisation which directly comes from their game semantics, while here and in [5] sequential processes are generated purely by a syntactic type discipline, from which behavioural characterisation is derived.
Syntactic and semantic theories of types have been studied in the context of sequential programming languages for decades, centring on, among others, the λ-calculus. The main difference between types for interaction and those for functions lies in the class of representable behaviour. For example, even the untyped λ-calculus arises as strongly typed processes, as we shall see in Section
3.6. Types for higher-order functions are a rich realm, with deep theories and powerful applications. One significant aspect of the connection between Hyland-Ong games and the typed π-calculus is its suggestion to the way by which types for processes may inherit the richness of types for functions.
As we already mentioned, the notion of types in the present work can be positioned among the variety of types for the π-calculus studied in the past, cf. [43,29,17,18]. In this context, the presented type discipline arises as a specific form of linear typing in which duality of types plays a fundamental role. Exploration of the precise positioning of the presented notion of types among a general universe of types for the π-calculus (as discussed in, for example, [19]) would be an interesting subject of study.
Abramsky, McCusker, Laird and others, as well as the present author, have explored different variants of Hyland-Ong games and have established em- beddability of different language constructs in games, cf. [2,3,11,28,22,30,32]. These studies contribute to the identification of distinct universes of compu-


tation based on types for interaction, offering in-depth algebraic properties of each universe using the languages of logics and categories. As the present study reveals, the characterisations of typed interactions precisely correspond, and fundamentally differ in articulation, between games and the π-calculus. By positioning different notions of games in the context of the π-calculus, di- verse operators and their algebras in games are recaptured on a common, and more terse, footing of name passing processes and their algebra; while logical and categorical articulation given by games can be an effective means for clar- ifying structures of typed interaction. A closely related field is the polarised versions of Linear Logic studied in, e.g. [31], which offer yet another, and this time proof-theoretic, articulations of classes of typed interactions studied by games and typed π-calculi (precise connection in this regard will be reported elsewhere). The interplay between these three strands of studies enrich our understanding on the common structure these studies are working at from different angles and using different technical tools, leading to its thorough and deeper understanding.
Finally we compare the sequential type discipline in the present work to its original version [5], the latter being used as a basis of our subsequent stud- ies. The only difference in the two type disciplines lies in different ways in
representing “choices”.  [5] uses branching/selection types (written [&i∈I→τi]↓
and [⊕i→τi]↑) for representing choices, which involve enriched dynamics similar to the sums in the λ-calculus and the additives in Linear Logic; while, in the present note, we solely use unary interaction for representing choices, which in fact corresponds to Hyland-Ong games (and also to [9,10], whose emphasis on untyped dynamics brings the idea closer to the choice in the present study). The presentation of choices used in [5] has the merit in that it offers a tractable syntax for representing various notions of choices, including general value pass- ing and objects. On the other hand, the representation studied in the present work offers a more analytical view on choices: in fact, its operational struc- ture directly corresponds to the standard protocol for encoding choices in the unary π-calculus, known since Milner’s early work [36] (revealing yet another coincidence in these two threads of study). As a merit of a different kind, the syntactic type discipline for this protocol would suggest a possible way to type similar operational structures. Because of these interests, presenting an alternative form of type structure for choices, a fundamental notion of com- puting, may have a merit in its own right, apart from its correspondence with Hyland-Ong universe.
Structure of the Paper. In the remainder, Section 2 informally illustrates the basic ideas of the protocol of choices in the π-calculus, after introducing the latter’s syntax. Section 3 introduces the syntax of the typed π-calculus with sums. Section 4 gives a short presentation of Hyland and Ong’s universe of sequential higher-order recursion. Section 5 constructs a categorical uni- verse from typed processes and show the equivalence between the resulting universe and the Hyland-Ong’s universe.



Acknowledgement. My view on typed π-calculi as a core tool for a basic theory of computing has been enriched by a series of my ongoing collaborative work with Berger and Yoshida, starting from [5]. My warm thanks go to Ugo Montanari who invited me to the workshop on rewriting logic at Pisa, 2002, a lively discussion at which eventually led me to the writing of the present note. I particularly appreciate discussions with Jose Meseguer, both on technical and non-technical topics. I thank Fabio Gadduci for enjoyable discussions in the workshop as well as for his patience and relaxed attitude as an editor of the proceedings. This work is partially supported by EPSRC grant GR/N/37633.

Sums in the π-Calculus: a Preview
Protocol for Choices
Before going into technical discussions, we informally outline central ideas of operational structure and types for representing choices. The following is the grammar of the π-calculus which uses bound, asynchronous output. Let x, y,... and a, b,... range over an infinite collection of names (also called channels or ports).

P ::= x(→y).P | !x(→y).P | x(→y)P | P|Q | (ν x)P | 0.

x(→y).P is an input, which receives a vector of names (to be instantiated in formal parameters →y in P ) via x. !x(→y).P is its replicated version. x(→y).P (resp.
!x(→y).P ) is often called linear input (resp. replicated input). An output x(→y)P
outputs a vector of new names →y. P|Q is a parallel composition. We sometimes write Πi∈IPi for the n-ary parallel composition of {Pi}i∈I (where if I = ∅ then Πi∈IPi = 0). (ν x)P says x is local to P . 0 is the inaction, denoting the lack of behaviour. We assume | is the weakest in precedence, so that x(y).P |Q
(resp. x(y)P|Q, resp. (ν x)P|Q) denotes (x(y).P )|Q (resp. (x(y)P )|Q, resp. ((ν x)P )|Q). The output prefix should be regarded as an asynchronous output in the sense that x(→y)P corresponds to (ν →y)(x⟨→y⟩|P ) in the standard syntax. The structural congruence ≡ is standard except it includes the rules for output asynchrony just mentioned, and is listed in Appendix. On processes modulo
≡, the reduction rules are given as follows.

x(→y).P |x(→y)Q −→ (ν →y)(P |Q)
!x(→y).P |x(→y)Q −→ !x(→y).P |(ν →y)(P |Q)

The relation −→ is closed under |, (ν x) and x(→y), but not under (linear and replicated) input prefixes.
Using this syntax, we outline how the choice is realisable by a series of


unary name passing, which follows [36,21].
x(z1z2)(z1.P1|z2.P2) | x(z1z2)z1
The process on the left-hand side, which offers two choices, sends to the con- tinuation c two names, z1 and z2; then it waits with these names. If z1 is invoked, then P1 becomes active: similarly for z2 and P2. On the other hand, the process on the left-hand side, which selects information, receives two new names after the initial invocation, then selects the first one by outputting to it. As a result we obtain the following reduction:

x(z1z2)(z1.P1|z2.P2)|x(z1z2)z1 −→ (ν z1z2)(z1.P1|z2.P2|z1)
−→ P1|(ν z2)z2.P2
Above we assume neither z1 nor z2 occur in P1 and P2. Note (ν z2)z2.P2 behaves as 0 since it can neither reduce by itself or interact with the outside. Thus P1 is selected, instead of P2. Note that, for this protocol to represent choice, it is important that the selecting side only invokes either z1 or z2, but not both: this is what the side offering the choice expects as the behaviour of the choosing side. On the other hand, the choosing side expects that there is exactly one occurrence of each of these names, so that selection is done in a deterministic way (one may also represent a nondeterministic choice by
ramification, but in this paper we only consider this simple form, since it would give the basis of other related protocols). This “expectation” is an essential part of well-organised — or typed — behaviour of name passing processes, as we shall discuss below.

Typing Choices
Let us focus on the following subterm of the above process.
(z1.P1|z2.P2)
For this process, the assumption on name usage mentioned above says that only one of z1 and z2 will be invoked, which is where the choice comes in. This means, for this term, the following reduction is natural:
(z1.P1|z2.P2) | z1 −→ P1
which is of course not correct from the viewpoint of untyped processes, since z2 is still available for invocation: but, in typed processes. because we expect that the environment obeys the choice protocol, z2 will never be invoked, hence z2.P2 will be safely garbage collected, justifying the reduction. Since this justification depends on the typing of the process, we may add an annotation as, for example: (z1.P1 & z2.P2), which, as an untyped process, is still the same


thing as (z1.P1|z2.P2). Now we can write the reduction above as:
(z1.P1 & z2.P2) | z1 −→ P1.
The syntax is similar to the standard (guarded) sum, usually written z1.P1 + z2.P2, even though the present sum notation involves type information as its essential element. Thus, the underlying untyped process is in fact the summation-less π-calculus, combined by the standard parallel composition operator |. The involved dynamics can be justified via a basic untyped equa- tional law as far as the underlying processes are well-typed.
This annotation, replacing some of | with &, is also essential for tractable syntactic discpline for choice, where we wish to type two possible choices, at z1 and z2, as a single collection. For example, we may type, assuming P1 and P2 has the same typing Γ:
▶ (z1.P1 & z2.P2) d z1 :()↓&z2 :()↓, Γ.
The type says it assumes that the environment would select either z1 or z2, and not both (here ↓ indicates a linear input: thus ()↓ says a one-time input which does not carry any value). Dually we have a typing for selection:
▶ z1 d z1 :()↑ ⊕ z2 :()↑.
Reading ↑ as an output, the typing this time indicates that it assumes the environment is waiting with two options, one at z1 and another at z2, and that there is a potential for the process to choose either z1 or z2. In this case, the process selects z1. Naturally there is another “inhabitant” of this type, which is:


selecting the left-branch.
▶ z1 d z1 :()↑ ⊕ z2 :()↑,

As suggested by the notations, the input choice and the output choice have a natural notion of duality: in the above examples, the typings are strictly dual between input and output, at z1 and z2, both individually (()↓ and ()↑) and collectively (& and ⊕). In composition, these dual typings annihilate each other, so that we obtain:
▶ (z1.P1 & z2.P2) | z1 d z1 : ‡, z2 : ‡, Γ
where ‡ means no further composition is possible at the channel, which makes sense since there is no longer the possibility of the choice at either names. This duality is fundamental for having a coherent notion of composition: in fact, while we can type the output z1 as ▶ z1 dz1 :()↑, this process is not composable with the above input, since it does not accompany the other choice in the typing. This duality is fundamental for having a coherent universe of typed processes.

A Typed π-Calculus with Sums
Processes
In this section we formally introduce the typed π-calculus with sums which is the centre of the present study. As the syntax of processes, we use the same grammar as we gave in Section 2, except that the linear input “x(→y).P ” is now replaced by “&i∈Ixi(→yi).Pi” (with I being a finite set and xi /= xj for i /= j). The process “&ixi(→yi).Pi” is called the sum of {xi(→yi).Pi}, which, as we already discussed, is best understood as a short-hand for the parallel composition Πi∈Ixi(→yi).Pi under the assumption — later concretised as types
— that the environment obeys the sum protocol. We may further add type annotation on bound names, which we omit for simpler presentation. The reduction for the linear input is accordingly extended:
&i∈Ixi(→yi).Pi | xi(→yi)Q −→ (ν →yi)(Pi|Q)
which throws away the unchosen branches. It is important to remember that the reduction of sums given above only makes sense in the typed setting: how- ever, when processes are indeed typed, we can recover the untyped dynamics from the typed dynamics, as we shall formally demonstrate later.
Channel Types
Channel types represent the structure of interaction a process would have at its channels. It uses four action modes, ↓, ↑, ! and ?. As the symbols indicate,
↓ and ↑ are mutually dual, while ! and ? are mutually dual. Channel types are then given by the following grammar.
τ ::= τI | τO | ‡	τI ::= (→τO)↓ | (→τO)!	τO ::= (→τI)↑ | (→τI)?
Here →τ indicates a vector of types. We call τI input type and τO output type. In each input/output type, an element of the vector inside the parenthesis of the type is carried in that type. We sometimes say a type of the form (→τ )p is a p-type. If τ is a p-type, we sometimes write τp. Given an input/output type τ , the dual of τ , written τ , is given by dualising action modes in τ inductively. We set md(τ ) as the outermost mode except md(‡) d=ef ‡.
As may be guessed, an input type represents an input behaviour, similarly for an output type. A pair type indicates, at one channel, both input and output are present. We only use channel types which obey the following constraint:
In (→τO)↓, each carried type is ?-type, dually for (→τI)↑.
In (→τO)!, each carried type is either a ?-type or a ↑-type, dually for (→τO)↓.
In [5], essentially the same constraint was used, though a replicated type in
[5] can carry only a unique linear type. In contrast, here a replicated type


can carry multiple linear types. As we shall see later this indicates the choice behaviour.

We define a partial commutative operation τ ⊙ τ' by: (1) τ ⊙ τ = ∗ (md(τ ) =↓) (2) τ ⊙ τ = τ (md(τ ) = !) and (3) τ ⊙ τ = τ (md(τ ) = ?). τ ⊙ τ ' is not defined if none of these rules apply, in which case we write τ = τ'.

Action Types
We first define a prime action type as follows.
&i∈Ixi : τi is a prime action type when xi /= xj if i /= j and md(τi) =↓. Dually for ⊕i∈Ixi : τi. {xi} is called the domain of this prime action type.
x : τ is a prime action type when md(τ ) ∈ {!, ?}. {x} is called the domain
of this prime action type.
A prime action type of the form (1) is sometimes called sum type. Then an action type is a finite collection of prime action types such that any two of their domains are disjoint from each other. 5 Γ, ∆,... range over action types. We often regard an action type as the underlying finite map from names to action types, writing Γ(x) for the image of Γ at x and dom(Γ) for the domain of, or the named used in, Γ. Note Γ is determined by the underlying map together with the groupings by & and ⊕ of linearly typed names. We also write Γ/→x for the result of taking off →x from the domain of Γ.
Next we define the partial algebra ⊙ on action types.
Definition 3.1 Γ = ∆ when the following conditions are all satisfied:
For each x ∈ dom(Γ) ∩ dom(∆), Γ(x) = ∆(x).
If &ixi : τi ∈ Γ and xi ∈ dom(∆) then ⊕ixi : τi ∈ ∆; dually if ⊕ixi : τi ∈ Γ and xi ∈ dom(∆) then &ixi : τi ∈ ∆.
The symmetric case of (ii).
If Γ = ∆, we set Γ ⊙ ∆ as follows: (Γ ⊙ ∆)(x) = τ iff either (1) x /∈ dom(∆) and τ = Γ(x), (2) x /∈ dom(Γ) and τ = ∆(x), or (3) x ∈ dom(Γ) ∩ dom(∆) and τ = Γ(x) ⊙ ∆(x). Further a sum type is in Γ ⊙ ∆ iff either it is in Γ/fn(∆) or in ∆/fn(Γ).
By the algebra, when we compose Γ and ∆, the resulting type can only contain a prime action type which comes from either Γ or ∆, or the result of composing prime action types at common channels. Note a sum prime action type is treated as a whole, involving multiple names in general. This constraint is essential for the consistency of the type discipline.

5 In many examples (including types representing games in Hyland-Ong games), an action type does not contain two ⊕-prime action types, or two &-prime action types. In such cases, it is not necessary to group them by ⊕ and &. However the groupings by prime action types become necessary in typed processes in general, for example in labelled transition.

Tying Rules
The sequent has the form ▶φ P d Γ where φ is an IO-mode, an element from the set {I, O}. We write φ = ψ when either (or both) of φ and ψ is I. If so φ ⊙ ψ is I if both are, and is O if else.
We introduce the typing rules one by one. In each rule, we assume chan- nel/action types introduced in the antecedent are well-formed. The basic composition rules are straightforward, which are from [5].




(Zero)
—
▶I 0 d ∅
(Par)
▶φi Pi d Γi	(i = 1, 2) Γ = ∆	φ = ψ
▶φ⊙ψ P|Qd Γ ⊙ ∆
(Res)
▶φ P d Γ,x : τ
md(τ ) ∈ {!, ‡}
▶φ (ν x)P d Γ
(Weak)
▶φ P d Γ-x
md(τ ) ∈ {?, ‡}

▶φ P d Γ,x : τ


In (Par) we use the partial algebra on types and IO-modes, so that the re- sulting process is always sequential. In (Res) we do not hide a channel which indicates the need for its dual — that which has either ↓, ↑ or ?-mode. In
(Weak), Γ-x indicates x /∈ dom(Γ). The weakening intuitively says that it is
OK not to use ?-channels at all; and that a ‡-channel can be absent since linear input and output annihilate each other.
Next we introduce the linear prefix rules, which are the only place we introduce the idea of choices.


(In↓)
▶O Pi d ↑ ?Γ-→x, →yi :→τi	(1 ≤ i ≤ n)
▶I &ixi(→yi).Pi d Γ, &ixi : (→τi)↓
(Out↑)
▶I P d Γ, →y :→τi	Γ = ⊕ixi : (→τi)↑

▶O xi(→yi)P d Γ ⊙ ⊕ixi : (→τi)↑


In (In↓), Γ-→x is understood as before, indicating dom(Γ) ∩ {→x} = ∅. Some observations on these rules:
In (In↓), Γ-→x ensures linearity of x1, .., xn. Here, as illustrated in Section 2, “&ixi : (→τi)↓” indicates the provision of choices. Note also Γ only contains output types so that an input prefix does not suppress another input, and the output mode is turned into the input mode. This follows [5], and is closely related to so-called input-output alternation in game semantics [1,1].
(Out↑) introduces a collection of selection types, dual to (In↓). “⊕ixi : (→τi)↑” indicates possible selections a process may do. (Out↑) has the input-output alternation dual to (In↓), turning an input mode to an output mode. Finally the use of = and ⊙ indicates the asynchronous character of output.


We conclude with the typing rules with replicated input and output.


(In!)
▶O P d ?Γ-x, →y :→τ
▶I !x(→y).P d Γ,x : (→τ )!
(Out?)
▶I P d Γ, →y :→τ	Γ = x : (→τ )?

▶O x(→y)P d Γ ⊙ x : (→τ )?

Neither of these rules involves choices: this is because these names can be used as many times as needed. In (In!), the suppressed channels in Γ cannot contain a linear output since, by being under a replication, these channels can be used for outputs for arbitrarily many times. (Out?) is the same as (Out↑) except for the lack of sum typing. Simple examples of typed processes follow.

Example 3.1 (i) Let t⟨x⟩ d=ef!x(b b ).b and f⟨x⟩ d=ef!x(b b ).b . Then, with R being one of t⟨x⟩ or f⟨x⟩, we have ▶I R d x : (()↑()↑)!. t⟨x⟩ and f⟨x⟩ represent (call-by-name) truth and falsity, respectively.  Their dual is
the conditional, given as: if x then P else P d=ef x(b b ).(b .P & b .P ). which is typed as ▶O if x then P1 else P2 d x : (()↓()↓)?⊗A, assuming
▶O Pi d A (i = 1, 2), We can then check t⟨x⟩| if x then P1 else P2 −→2
t⟨x⟩| P1 and, symmetrically, f⟨x⟩| if x then P1 else P2 −→2 f⟨x⟩| P2.
(ii) We can also construct the call-by-value versions of these agents. In this case the truth and false become ▶O b1db1 :()↑⊕b2 :()↑ and ▶O b2db1 :()↑⊕b2 : ()↑, while the conditional becomes ▶I b1.P2 & b2.P2 d b1 : ()↓&b2 : ()↓. An indirection in the call-by-name encoding is eliminated in these encodings.

Basic Syntactic Properties
We first list basic properties of the dynamics in sequential processes. Below we let →→d=ef≡∪ −→∗.
Proposition 3.2  (i) (subject reduction) If ▶φ P d Γ and P →→ Q then
▶φ Qd Γ.
(ii) (sequentiality) If ▶O P d Γ and P −→ P '	then P ' ≡ P ',
1,2	1	2
Proof. See Appendix.	✷
Next we formally establish the relationship between the untyped calculus and
the typed calculus in their dynamics. We first define Erase(▶φ Pd ↓↑ !?A,‡ w→ )
as (ν w→ )P ' where P ' is the result of turning each & in P into parallel compo- sition. Since names of mode ‡ are never composed with other names, hiding them does not influence algebra and dynamics. Further write ≡' for the re-
sult of adding the axiom (ν x)x(→y).P ≡ 0 to ≡ (this equation is justifiable by
the untyped strong bisimilarity, so that it has no effect on the behaviour of processes). We can now state the following. The proof is easy by inspecting the two generation rules for reduction.


def
Proposition 3.3 Let	φ P d A and P0 = Erase( φ P d A). Then:

P −→ P ' implies P
−→≡' P ' where P ' def Erase(▶
P ' d A).

0	0	0 =	φ
P0 −→ P ' implies P ' ≡' Erase(▶φ P ' d A) such that P −→ P '.
Finally we list one property which we shall repeatedly use in the next section. Let us say a process P is prime with subject x, or simply prime, if either P is input with subject x or P ≡ x(y1..yn)Πi∈IPi such that each Pi is prime with subject yi. Then we consider a variant of the typing for output prefixes which is given by adding the condition “P ≡ ΠPi with Pi prime with subject yi” in the premise of (Out↑,?). This restricted typing system is called prime typing. Note that, in the prime typing system, we can assume active names under an
output prefix are bound by that prefix. We can then easily check:
Proposition 3.4 If ▶ P d A is derivable in the original typing rules then for some P0 ≡ P we have ▶ P0 dA in the prime typing system.
Proposition 3.4 says that we can assume, without loss of generality, that all prefixed processes are primes whenever we are discussing properties invariant under ≡.
Inﬁnitary Extension
In this subsection we extend the π-calculus to its infinitary counterpart, both in types and processes. While this is not necessary, at least in its most gen- eral form, in order to capture many standard computational behaviours, the infinitary extension is needed for having the precise equivalence with the orig- inal category by Hyland and Ong [24]. It also has some interest in modelling untyped sequential calculi, as we shall see later. The construction is quite simple.
A process is now a possibly infinite tree of at most countable height 6 such that each of its full subtrees 7 has the following shape:
&i∈Ixi(→yi).P | !x(→y).P | x(→y)P | Πi∈IPi | (ν →x)P | 0.
with I and each vector of names being possibly infinite (for simplicity assume such a vector are indexed by an initial segment of ordinals, starting from 0). To make the α-conversion possible under infinite name occurrences, we set the whole collection of names to be a proper class. The resulting processes are sometimes called inﬁnitary, which include the original finitary processes as a proper subset. On infinitary processes we define ≡ using the obvious extension
of the original equations (in particular we assume nested Πi is commutative and associative with the identity 0; the rules involving hiding are extended to

6 The restriction to countable height is not substantial, but makes many discussions simpler.
7 A full subtree T of a tree T0 is a subtree of T0 such that, at each vertex, T contains all branches of those of T0 at the corresponding vertex.


possibly infinite vectors, as in (→x)(→y)P ≡ (→y)(→x)P ). The reduction rules are given precisely as before.
Channel types are similarly extended, allowing each vector to be finite or infinite and each type to be of a finite or countably infinite height, with the same well-formedness conditions as before. A sum type can have an infinite domain; so is an action type in general. Using infinitary processes and types, the typing rules are given precisely as before, reading each rule as a constraint on each full subtree of a process.
Example 3.2 (representation of untyped λ-calculus) The infinitary extension has some interest from the viewpoint of representation of untyped higher-order functions. The following is an encoding of the untyped λ-calculus, known to the present author since 1996.

[[x]] d=ef CC⟨ux⟩
[[λx.M ]] d=ef !u(x·{y }	).P	([[M ]]	d=ef!u({y }	).P )
[[MN ]] d=ef !u({y }	).(ν x)(P|[[N ]] ) ( [M ]]	d=ef!u(x·{y }	).P )

where we set CC d=ef µX⟨ab⟩.!a({y } ).b({z } )Π X⟨z y ⟩, which defines an infinite tree as a least fixed point (X⟨ab⟩ etc. indicates the instantiation by names in the obvious way). In the definitions above, {yi}i∈ω is a vector of names indexed by the set of natural numbers; x·{yi}i∈ω inserts x at the initial position of the vector, and shifts the indices of the remaining ones by one (note this results in the vector with the same indexing set). Let us show how (λx.x)M −→ M is modelled. Below we omit the indexing set ω, and let [[M ]] d=ef!x({z }).P .


[[(λx.x)M ]]	d=ef
!u({yi}).(ν x)(x({zi})ΠiCC⟨ziyi⟩| [[M ]]x)

−→ !u({yi}).(ν {zi})(ΠiCC⟨ziyi⟩| P )

≈ !u({z }).P d=ef
[M ]]u.


In the first line, note λx.x d=ef!u(x·{yi}).x({zi})ΠiCC⟨ziyi⟩. In the last line, ≈ is the standard (untyped) weakbisimilarity, whose establishment is easy by using a closure following [36]. In this way we can justify both β and η-equalities: in fact, the encoded processes modulo ≈ capture the untyped λ-calculus up to the standard maximal consistent theory. Being independently conceived, the encoding is closely related to the games models of the untyped λ-calculus in [13,28]. In comparison, the process encoding is terse in presentation and directly captures the dynamics of the original calculus; while the models in [13,28] offer rich algebraic insights on ambient semantic structures.

Hyland-Ong Games
Arenas
Hyland and Ong games were introduced as an intensional structure for repre- senting sequential higher-order recursion (as noted in Introduction, Abramsky, Jagadeesan and Malacaria [1] and Nickau [41] introduced closely related, and essentially equivalent, semantic universes around the same time). In this sec- tion we give a concise presentation of their universe.
The construction by Hyland and Ong is based on two notions, arenas and strategies. We first define arenas. Below a forest is an acyclic directed graph (X,'→) (writing x → y if there is a directed edge from x to y for x, y ∈ X) in which there is at most one incoming edge for each node and for which there
are minimal elements w.r.t. the partial order '→∗. These minimal elements are called its roots. We only consider forests of at most countable height (having uncountably high forests does not pose any technical problem, but is insignificant). We count the height of each node in a forest, starting from 1 at each root.
Definition 4.1 An arena, ranged over by A, B,... is a (possibly infinite, but of at most countable depth) forest (X,'→) (with x, y,... ∈ X) together with two labelling functions op : X → {O, P} and qa : X → {Q, A} such that:
If x is of an odd-height (resp. even-height) then op(x) = O (resp. op(x) = 
P ). Further if x is a root then qa(x) = Q.
If qa(x) = A then for no y we have x '→ y. Nodes in an arena are often called moves.
The op-labelling is redundant: however having it explicitly is convenient for establishing its connection with the π-calculus. O stands for an opponent while P stands for a player. On the other hand, Q and A stands for question and answer. We set the dualisation operator as O = P and P = O (there is no dualisation on qa-labels). We combine these modes as OQ, OA, PQ and P A. The following shorthand notations for these actions are used in [24]: [ stands
for an OQ-move, ( for a P Q-move, ) for an OA-move, and ] for a P A-move.
Example 4.1 A simple example of an arena is a boolean arena B, which has the single root labelled as OQ and two subsequent nodes both labelled as PA (which may be written true and false), and no more. Later we shall see B
corresponds to an action type x : (()↑()↑)!. In fact, if we extend its channel type (()↑()↑)! as a syntax tree, the root has the !-mode, which we regard as
an OQ-, or [-, move; and each ()↑ can simply be considered as the node of label ↑, which we regard as a P A-, or ]-, move, giving as a whole B. We can guess, in this way, !, ?, ↓ and ↑ respectively correspond to [, (, ) and ]
(in particular, and perhaps confusingly, Opponent corresponds to input and Player corresponds to output).


Strategies

We next construct strategies. Our presentation benefits from [32]. Write A for the dualisation of A, which exchanges OP -labelling but not QA-labelling. Given an arena A and B, an arena A ⇒ B is made by combining A and B disjointly and adding a directed edge from each root of B to each (original) root of A. Note this is again an arena, called the function arena from A to B. Below a (ﬁnite) sequence is a mapping from a finite initial segment of ω, the set of natural numbers, to a set of elements. The elements of the associated initial segment are called its indices. If σ is a sequence and i is its index, then σ[i] denotes the i-th element of σ.
Definition 4.2 An action sequence from A to B is a finite sequence σ of moves in A ⇒ B together with a justiﬁcation relation on its indices, written i a j (where i, j are indices of σ), such that:
(initial move) If σ = xσ' then x is a root of A⇒B.
(justification) If i a j then σ[i] '→ σ[j] in A ⇒ B. Further if i1, i2 a j
then i1 = i2.

(IO-alternation) If σ = σ1 · x · y · σ2 then op(x) = op(y).
Two action sequences are equal if they coincide both in the underlying se- quences and their justification relations.
Fixing an action sequence σ, we sometimes write xi a yj, or even x a y when there is no ambiguity, for i a j such that σ(i) = x and σ(j) = y. When xi a yj, then xi is the justifying move of yj. If xi a yj and y is an answer then we say yj is answered by xi. We often write σ·x to denote a concatenated sequence together with an implicit justification to x from some move in σ.
Given σ, its player view PV (σ) is given as:

PV (ε) = ε
PV (σ · x) = PV (σ) · x	op(x) = P
PV (σ1 · x · σ2 · y) = PV (σ1) · x · y	op(xn) = O, x '→ y PV (σ · x) = x	x is a root
where, in the second line (resp. the third line), we assume the justification relation in σ as well as on x (resp. on x and y) are preserved in the obvious way: for example, in the third line, we assume x '→ y again in the new sequence for the mentioned occurrences of x and y. Dually we define the opponent view OV (σ). We can now define legal action sequences.
Definition 4.3 (i) (visibility) σ is P-visible if, for each prefix σ' · x of σ such that op(x) = P , the justifying move of x in σ occurs in PV (σ). σ is O- visible if the dual condition is satisfied. It is visible if it is both P-visible and O-visible.


(well-bracketing) σ is well-bracketing if no question is answered earlier than a later question.
(legal sequences) σ is legal if it is visible and well-bracketing.
Well-bracketing means, simply put, the parentheses match properly when writ- ten using the notations [, (, ) and ], taking the justification into consideration (e.g. [ can only be closed by ] which it justifies). We can now define an innocent strategy.
Definition 4.4 An innocent strategy f from A to B is a prefix-closed set of action sequences from A to B satisfying the following condition:
(contingency completeness) Whenever σ ∈ f and σ·x is legal with op(x) = 
O, we have σ · x ∈ f .
(innocence) Whenever σ1, σ2 ∈ f where both end with an opponent move and PV (σ1) = PV (σ2), σ1 ·x ∈ f implies σ2 ·x ∈ f such that PV (σ1 ·x) = PV (σ2 · x).
We write f : A → B when f is an innocent strategy from A to B.
By innocence and contingency completeness, an innocent strategy is precisely characterised by a partial function from odd-length legal player views to next actions (if any). Such functions are called innocent functions. An innocent function uniquely defines an innocent strategy and vice versa. In essence, contingency completeness says that a strategy is always ready to receive any legal input; innocence says that a strategy always reacts in the same way in the same context (where the sameness in both instances takes the notion of
justification on sequences into account).
Example 4.2 Let 1 be the empty arena. An innocent strategy from 1 to B is that which returns true after the initial move (the latter justifies the former); another returns false; and the third one returns nothing. These respectively correspond to the three constants, the truth, the falsity, and the undefined, which are all and the only inhabitants of the boolean type. An innocent function from B to B starts from the root of the co-domain, and returns true immediately at the co-domain. This is a constant function of value true. Another innocent function of the same type would, after the initial action at the co-domain, asks at the domain, receives true (resp. false) then outputs false (resp. true) at the co-domain, defining the negation.
We may visualise an action sequence in a strategy using the two rows corre- sponding to its co-domain and domain. For example, writing • for the unique initial move, we may draw the following picture for representing the longest action sequence in the “truth” strategy:

1	:
B	:	•	true


We should further draw the justification, which leaves implicit. Similarly we can write one of the two longest sequences in the negation strategy as follows (another is its symmetric case):

B	:	•	true
B	:	•	false

We again omit justification. In the next subsection we shall see how the above two strategies can be composed to induce the falsity.


Composition and Category of Games
Proposition 4.5 An action sequence is well-knit if a root occurs only as its initial move. We write wk(f ) for the subset of sequences which are well-knit. Then wk(f ) = wk(g) iff f = g for any f, g : A → B.
Proof. Since if wk(f ) = wk(g) the actions of f and g after the identical P-views coincide by the construction of P-views.	✷

We note Hyland-Ong defined their innocent strategies solely in terms of well- knit sequences. We use non-well-knit sequences since this form is more con- venient for composition of strategies.
The composition of two strategies can be defined in various ways: here we use the 4-row based presentation (cf. [32,22]). Let f : A → B and g : B → C. A composite sequence from f and g is an array of the following shape (with justification pointers implicit), such that:

In the A-B rows, we write an action sequence from f . In the B-C rows, we write a well-knit action sequence from g.
The initial entry (if any) is in the C-row.

The entries at B and B should always be both empty, or both non-empty and coincide as moves (with OP -labelling dualised).

:	z	...
:	y	w	...

:	y	w	...
:	x	u	...
Above we write y etc. to show the dualisation w.r.t. OP-labelling. In these four rows, we call the first and fourth rows (A and C above) visible rows. Let us see how we can compose action sequences using this idea by examples.

Example 4.3	(i) We first compose the truth strategy and the negation:

1	:
B	:	•	true

B	:	•	true
B	:	•	false
Here the projection onto the visible rows give the behaviour of the falsity (as should be expected): the strategy receives a question at B, then it in effect answers by the (justified) false.
(ii) Next we consider the negation composed with itself.

B	:	•	true
B	:	•	false

B	:	•	false
B	:	•	true
If we focus on the visible rows, it first receives an opponent question at B, to which it reacts (in effect) by asking the opponent at B. If it receives true as a result, then it (in effect) reacts at the original type by answering by true, i.e. precisely by the same value as it has received from the oppo- nent. The composite sequence when the opponent answers by false at the third step is precisely symmetric. These composite sequences suggest this composition results in the identity on B.
Given f : A → B and g : B → C and a composite sequence from f and g, we can check the projection of the latter to the visible rows give an action sequence from A to C by adding the justification from the root moves in C to those in A, which we call the visible projection of the composite sequence. The set of the visible projection of all composite sequences from f : A → B and g : B → C is called the composition of f and g, which we write f ; g. Hyland
and Ong [24] showed that, for each f : A → B and g : B → C, f ; g always gives an innocent strategy from A to C. Further they showed:
Proposition 4.6 The following data deﬁnes a Cartesian-closed category, which we write CA.
Objects: arenas.
Arrows: innocent strategies.
Composition of arrows: the composition of innocent strategies.
In the next section we construct CA using processes in the typed π-calculus.

Equivalence
Sequential Transition
This section constructs a category from typed processes in Section 3 and show that it coincides with CA in Section 4. For this purpose we select action types of a specific form, and take them modulo a typed weak bisimilarity, which become morphisms in a category, which in fact coincides with CA. The bisimilarity is defined by the typed labelled transition which makes explicit the sequential behaviour of a typed process when interacting with another typed process. The rules generate transition for infinitary processes, though they do not differ those for finitary processes. We use the following labels for transitions.
l ::= x(→y) | x(→y) | τ
where vectors can be infinitary. The transition is defined on terms modulo
≡, so that, via Proposition 3.4, we can safely assume all processes are typed under the alternative typing. The transition rules follow [5], with an additional treatment of sums.
We start with the linear input. In this rule as well as the remaining ones, we assume the process on the left-hand side in the conclusion is well-typed (which, as we shall see later, implies the same for the process on the right-hand side.)
(In↓)	−	∆ = 
▶ &x (→y ).P d Γ, & x : (→τ )↓	xi(→yi)	P d Γ, →y :→τ

I	i	i	i
i  i	i
−→ ▶O	i	i	i

The rule says that the i-th branch of the branching input is selected by in- teraction with the environment, and, as the result, all other branches are discarded, and all sum types are together taken away. Note the rule is ob- tained by reading the typing rule (In↓) backward. The linear output rule is precisely dual.
(Out↑)	−	
▶ x (→y)P d Γ, ⊕ x : (→τ )↑	xi(→y)	P d Γ, →y :→τ



O i	i  i	i
−→ ▶I	i

After the output at xi is done, we no longer need the typing for xi and other related linear channels, which are together taken off. Again the transition rule is backward-reading of the typing rule (Out↑), restricted to the case of prime output. For a replicated input, the rule is straightforward. Below we set, for simplicity, each τi in →τ has ?-mode while each ρj in ρ→ has ↑-mode.
(In!)	−
▶ !x(→y→z).P d Γ,x : (→τ ρ→)! xi(→y→z)	!x(→y→z).P | P d Γ,x : (→τ )!, →y :→τ, ⊕ y : τ

I	−→ ▶O
j j	j

Note the channel x and its typing remain in the resulting process. Dually for


replicated output (with the dual convention for →τ and ρ→):

(Out?)	−

▶ x(→y→z)P d ? ↑ Γ,x : (→τ ρ→)?O x(→y→z)	P d ? ↑ Γ,x : (→τ ρ→)?, →y :→τ, & y
j j
: ρj


We also have the composition rules, (Com), (Par) and (Res).


x(→y)
▶ P d Γ
P ' d Γ'	▶
x(→y)
Qd ∆
Q' d ∆'

(Com)
 I	−→ ▶O	O	−→ ▶I	

τ
▶O P|Qd Γ ⊙ ∆	−→ ▶ (ν →y)(P '|Q') d (Γ' ⊙ ∆')/→y

In (Par) below, we say Θ allows l when neither (1) Θ(x) =‡ and either l = x(→y) or l = x(→y); nor (2) Θ(x) = ! and l = x(→y).

l	'	'
(Par) ▶φ P d Γ −→ ▶φ' P d Γ	Γ = ∆	Γ ⊙ ∆ allows l
τ	'	'
▶φ P|Qd Γ ⊙ ∆	−→ ▶φ' P |Qd Γ ⊙ ∆

In (Par) we require that the IO-mode φ is preserved after the parallel com- position, indicating Q is in the input mode. In fact, if Q is in the output mode, either P|Q or P '|Q (or both) become the composition of two output moded processes. The condition “Γ ⊙ ∆ allows l” prohibits the action to take place which is impossible in the typed environment: for example, if Γ ⊙ ∆ contains !-type at x, an ?-output cannot take place since it already exists in- side and two occurrences of the same ! channel cannot be combined in typed composition.
l	'	'
(Res) ▶φ P d Γ −→▶φ' P d Γ	x /∈ fn(l)
▶φ (ν x)P d Γ/x −→▶φ' P ' d Γ'


For brevity we often write P
−→l
P ' omitting type information. We observe

the following properties. The proofs follow [5] and are omitted.

Proposition 5.1	(i) (subject transition) If ▶φ P d Γ and ▶φ P d Γ −→▶φ' P d Γ then ▶φ' P d Γ .
(transition and IO-modes) Let ▶φ P d Γ −→▶φ' P ' d Γ'. Then (a) if l is
an input, φ = I and φ' = O, (b) if l is an output, φ = O and φ' = I, and
(c) if l = τ , φ = φ' = O.
(transition and reduction) Let ▶ P d Γ. Then ▶ P d Γ −τ→▶ P ' d Γ iff
P −→ P '.
l	'	'	'
(determinacy, 1) If ▶φ P d Γ −→▶φ' P1,2 d Γ1,2 then P1 ≡ P2 and Γ1 = Γ2.
l1,2
(determinacy, 2) If ▶O P d Γ −→ then either (a) l1 = l2 = τ or (b)
l1 = x(→y) and l2 = x(→y').

Typed Transition and Innocence
A surprising observation [5] is that typed transition sequences of sequential processes precisely obey the conditions used to define strategies in Hyland- Ong games, where justification is made explicit as binding. In the following we outline the essential points of this coincidence, reaching the characterisation by innocence. Since the proofs precisely follow those in [5] we omit them.

Write ▶φ
P d Γ
=⇒s
▶ψ Qd ∆ for the standard weak transition, i.e. given

a sequence s = l ..l of non-τ actions, we write ▶ P d Γ =⇒s	▶ Qd ∆ when
1	n	φ	ψ

▶φ P d Γ =⇒
−l→1
... 
−l→n
▶	Q d ∆ where =⇒ d=ef−τ→∗. Without loss of

generality, we assume the standard bound name condition on these sequences,
i.e.	binding names are always distinct and disjoint from free names.	By Proposition 5.1 (4,5) we observe:

Proposition 5.2 (IO-alternation) If ▶φ P d Γ
=⇒s
then s is IO-alternating,

i.e. whenever s = s1 · l1 · l2 · s2 then l1 is input and l2 is output or vice versa.
We next introduce views analogous to those of Hyland-Ong games. First, a notation: given a sequence l1..ln of non-τ actions under the bound name convention, we write li ab lj when fn(lj) ⊂ bn(li), i.e. a binder in li binds the free subject of lj.
Now let s be a sequence of non-τ actions. Then the output view of s, denoted ps’O, is given by the following induction. Below ε is the empty se- quence.


Dually we define the input view ps’I. Note these definitions precisely follow those of the player/opponent views in Section 4. The visibility is defined accordingly: the empty sequence ε is output visible, a non-empty sequence s = l1...ln is output visible if (a) each proper prefix of s is output visible, (b) if ln is an output and li ab ln then li is in pl1...ln’O. Dually we define input visibility. A sequence is visible if it is both input and output visible.

Proposition 5.3 Let ▶φ P d Γ
visible.
=⇒s
. If s is input visible then it is output

Let s be visible. Then s is well-bracketing if, whenever s' = s0 · li · s1 · lj for a prefix s' of s is such that (1) li is a question and (2) lj is an answer free in s1 · lj, we have li ab lj.

Proposition 5.4 If ▶ P d Γ =s⇒l
, l is output and s is well-bracketing, then

sl is well-bracketing.
A weak transition sequence is legal if it is visible and well-bracketing. By determinacy, the bisimilarity (and other branching equivalences) and the trace equivalence on legal sequences coincide.  We write the induced equivalence
≈seq.
Proposition 5.5 ≈seq is a congruence.
Finally we observe:
s1,2
Proposition 5.6 (innocence) Let ▶φ P dΓ =⇒ such that each of s1,2 ends with

an input action. Then if ps ’O ≡ ps ’O and ▶ P d Γ =s1⇒l1
such that ps1’Ol1 ≡α ps2’Ol2.
then ▶ P d Γ =s2⇒l2

Thus the behaviour of a sequential process is precisely characterised by a partial function which maps, up to α-equality, each output views ending with an input to the next output action (if any), which we again call the innocent function. We write inn(▶φ P d Γ) or simply inn(P ) with the typing implicit, for the innocent function of ▶φ P d Γ. Immediately inn(P ) = inn(Q) iff P ≈seq Q.

From Processes to Categories
From the universe of typed processes, we read off those processes which live in Hyland-Ong games. We make the essential use of injective renaming on both action types and processes [20]. Write Γ=p∆ if ∆ is the result of permuting
names in Γ.  Note =p is the equivalence relation.  We write [Γ]=p for the
quotient set containing Γ. Note all action types in [Γ]=p have precisely the same structure: the difference is only on names at interaction points.
Definition 5.7 An action type Γ is Hyland-Ong if, for each x ∈ dom(Γ), (1) the mode of Γ(x) is !; and (2) if ρ of mode ↓ occurs in Γ(x) then ρ = ()↓, dually if ρ of mode ↑ occurs in Γ(x) then ρ = ()↓. If Γ is Hyland-Ong, then [Γ]=p is called a π-arena. We let α, β,... range over π-arenas.
Note a π-arena, when each channel type is expanded as a (possibly infinite) syntax tree, gives a forest such that, for each component tree of the forest:
Each node of an odd height (resp. even height) is labelled by ! or ↓ (resp.
? or ↑), that is it is an input (resp. an output). In particular, a root node is labelled only by !.
If a node is labelled ↓ or ↑ then it has no child node.
Note these conditions precisely correspond to Definition 4.1, reading input (resp. output) as “opponent” (resp. “player”) and !, ? (resp. ↓, ↑) as questions (resp. answers). Note also π-arenas are clearly a proper subset of all possible action types.


We next consider processes. Since we consider processes modulo ≈seq, we write p, q,... for the equivalence classes of the (typed) processes modulo ≈seq. Note the (typed) operation such as p|q makes sense because of Proposition
5.5. We often write ▶φ p d Γ to make the typing of p explicit. Finally [p]=p denotes, as before, the equivalence class of p modulo renaming.
Definition 5.8 Given π-arenas α and β, we say p inhabits from α to β iff
▶I p d Γ, ∆ for some Γ ∈ α and ∆ ∈ β such that dom(Γ) ∩ dom(∆) = ∅. If p inhabits from Γ to ∆ then [p]=p is called a π-strategy from α to β. We let F, G,... range over π-strategies and write F : α → β if F is from α to β.
Proposition 5.9 The following data deﬁnes a category.
Objects: π-arenas.
Arrows from α to β: π-strategies from α to β.
Composition of arrows: Given F : α → β and G : β → γ, we deﬁne
F ; G as the π-strategy [(ν fn(∆))(p|q)]=p where, for mutually disjoint Γ ∈ α,
∆ ∈ β and Θ ∈ γ, we have ▶I pd Γ, ∆, p ∈ F, ▶I q d ∆, Θ and q ∈ G.
We call the resulting category πseq .
Proof. Firstly, F ; G does give a π-strategy from α to γ by Proposition 5.5. Secondly, the associativity of ; is immediate from that of |, that is, given disjoint sets of names X and Y , we have:
(ν Y )((ν X)(p|q)|r) ≈ (ν X ∪ Y )(p|q|r) ≈ (ν X)(p|(ν Y )(q|r)).
Finally we construct the identity. Define a (possibly infinitary) process CC(→τρ→)! ⟨ab⟩ and CC(→τ)↓ ⟨ab⟩ by the following construction:

CC(→τρ→)! ⟨ab⟩ = !a(→zw→ ).b(→y→u)(Π CCτi⟨y z ⟩ | & CCρi⟨w u ⟩)
CC(→τ)↓ ⟨ab⟩ = a(→z).b(→y)Π CCτi⟨y z ⟩
For infinitary types, these recursions are meant to define the shape of a process at each height, so that the process is defined uniquely even for infinitary cases. For Γ which is Hyland-Ong, we may write CC⟨Γ, Γ'⟩ for the parallel composition of copy-cat agents for each prime action type, where Γ' is the renaming variant of Γ such that dom(Γ) ∩ dom(Γ') = ∅.
Now fix a π-arena α and let Γ, Γ' ∈ α such that dom(Γ) ∩ dom(Γ') = ∅.
We then set:

idα
d=ef
[CCτ ⟨Γ, Γ'⟩]= ,≈ .

We can then check that, for each P from Γ to ∆ such that dom(Γ')∩dom(∆) =
∅ without loss of generality,
(ν →x)(P |ΠiCC⟨xiyi⟩) ≈seq P{→y/→x}
where dom(Γ) = {→x} and dom(Γ') = {→y}, hence as required.	✷


We can now conclude:
Theorem 5.10 πseq and CA are categorically equivalent.
Proof. By construction we already know πseq is a subcategory of CA. More-
over the inclusion is subjective in objects up to isomorphism (under the well- ordering axiom) by appropriately indexing the nodes in an arena, at each height and at each tree. Thus it suffices to check the fullness. For this pur- pose we construct a concrete typed process which realises an arbitrary innocent
behaviour. Firstly, an abstract transition is defined solely by type information
as follows:


▶	• d Γ, ∆  xi(→yi)
d Γ, →y :→τ
(∆ = & x : (→τ )↓)

I	−→ ▶O •	i	i
i  i	i



▶	• d Γ, ∆  xi(→yi)
d Γ, →y :→τ
(∆ = ⊕ x : (→τ )↑)

O	−→ ▶O •	i	i
i  i	i



▶	• d Γ,x : (→τ ρ→)! x(→y→z)
d Γ,x : (→τ )!, →y :→τ, ⊕i→z : ρ→





▶	• d Γ,x : (→τ )? x(→y→z) ▶	•
d Γ,x : (→τ )?, →y :→τ .&izi : ρi


An abstract innocent process Ψ under Γ,φ is a prefix-closed set of abstract transition sequences which are (visible, well-bracketing and) innocent. Since for any arrow f in CA between π-arenas, we can find an abstract innocent process which realises f sequence by sequence up to renaming, it suffices to construct a (concrete) process whose weak transition coincides with Ψ. For this purpose we define P as the tree characterised by a relation between its node(s) and the corresponding transition in the output views in Ψ (for ex- ample, if it has an linear input as in the initial rule above, we can decide one component of a process as &ixi(→yi).Pi with each Pi characterised by the subsequent transitions in the same way; if, in the output mode, no output is defined we use a diverging process of an appropriate type). Since each tree is at most of countable height, this uniquely characterises a syntax tree.   ✷


References
S. Abramsky, R. Jagadeesan, and P. Malacaria. Full Abstraction for PCF.
Info. & Comp. 163 (2000), 409-470.

S. Abramsky, K. Honda, and G. McCusker. A Fully Abstract Game Semantics for General References. LICS, 334-344, IEEE, 1998.


S. Abramsky and G. McCusker. Linearity, Sharing and State: a fully abstract game semantics for Idealized Algol with active expressions, ENTCS, Vol.3, North Holland, 1996.
J. C. M. Baeten and W. P. Weijland. Process Algebra. Cambridge University Press, 1990.
M. Berger, K. Honda, and N. Yoshida. Sequentiality and the π-Calculus,
TLCA01, LNCS 2044, pp.29-45, Springer, 2001.
M. Berger, K. Honda, and N. Yoshida. Genericity and the π-Calculus,
FoSSacs03, LNCS, Springer, 2003.
G. Berry and P. L. Curien. Sequential algorithms on concrete data structures
TCS, 20(3), 265-321, North-Holland, 1982.
P. L. Curien. Sequentiality and full abstraction. Proc. of Application of Categories in Computer Science, LNM 177, 86–94, Cambridge Press, 1995.
P. L. Curien. Abstract Bo¨hm Trees, Mathematical Structure of Computer Science, 8(6), 1998.
P. L. Curien and H. Herbelin. Computing with Abstract Bo¨hm Trees, Proc. of Third International Symposium on Functional and Logic Programming, World Scientific, 1998.
M. Fiore and K. Honda. Recursive Types in Games: axiomatics and process representation, LICS’98, 345-356, IEEE, 1998.
F. Gadducci and U. Montanari. The Tile Model. Proof, Language and Interaction: Essays in Honour of Robin Milner, MIT Press,
P. Di Gianantonio, G. Franco and F. Honsell. Game semantics for untyped
λ-calculus, LNCS, 1998.
J.-Y.Girard. Linear Logic, TCS, Vol. 50, 1–102, 1987.
C.A.R. Hoare. Communicating Sequential Processes. Prentice Hall, 1985.
C.A.R. Hoare. Unified Theories of Programming, 58pp. Computing Laboratory, Oxford University, 1994.
K. Honda. Types for Dyadic Interaction. CONCUR’93, LNCS 715, 509-523, 1993.
K. Honda. Composing Processes, POPL’96, 344-357, ACM, 1996.
K. Honda. A Theory of Types for the π-calculus. Typescript, 113 pp, October, 1999. Available from: http://www.dcs.qmw.ac.uk/~kohei/.
K. Honda. Elementary Structures for Process Theory (1): Sets with Renaming. MSCS, 2001.
K. Honda and M. Tokoro. An object calculus for asynchronous communication. ECOOP’91, LNCS 512, 133–147, 1991.


K. Honda and N. Yoshida. Game-theoretic analysis of call-by-value computation. Proc. ICALP’97, Proceedings of 24th International Colloquium on Automata, Languages, and Programming, Lecture Notes in Computer Science 1256, pp.225–236, Springer-Verlag, July, 1997.
K. Honda and N. Yoshida. A uniform type structure for secure information flow,
POPL’02, ACM, 2002.
M. Hyland and L. Ong. ”On Full Abstraction for PCF”: I, II and III.
Info. & Comp. 163 (2000), 285-408.
M. Hyland and L. Ong. Pi-calculus, dialogue games and PCF, FPCA’95, ACM, 1995.
O. Jensen and R. Milner. Bigraphs and Transistions. POPL’03, ACM, 2003.
G. Kahn and G. Plotkin. Concrete Domains. Theoretical Computer Science, 1993 (originally appeared as report 338 of Inria-Laboria, 1978).
A. D. Ker, H. Nickau and L. Ong. Innocent game models of untyped lambda calculus. Theoretical Computer Science 272, pp. 247-292, 2002.
N. Kobayashi, B. Pierce, and D. Turner. Linear Types and π-calculus, POPL’96, 358–371, ACM Press, 1996.
J. Laird. Full abstraction for functional languages with control, LICS’97, IEEE, 1997.
O. Laurent. Polarized games, LICS 2002, 265-274, IEEE, 2002.
G. McCusker. Games and Full Abstraction for a Functional Metalanguage with Recursive Types. Ph.D.thesis, Imperial College, 1998.
J. Meseguer. Research Directions in Rewriting Logic. Computational Logic. NATO Advanced Study Institute Series F, Vol. 165, pp. 345-398, Springer- Verlag, 1999.
R. Milner. Fully abstract models of typed lambda calculi. TCS, 4:1–22, 1977.
R. Milner. A Calculus of Communicating Systems, LNCS 92, Springer, Berlin, 1980.
R. Milner. Functions as Processes. MSCS, 2(2), 119–146, CUP, 1992.
R. Milner. Polyadic π-Calculus: a tutorial. Proceedings of the International Summer School on Logic Algebra of Specification, Marktoberdorf, 1992.
R. Milner. Address at Bologna on receiving Honorary Degree from the University of Bologna, 1997.
R. Milner. Bigraphical reactive systems: basic theory. Computer Laboratory Technical Report No. 523, University Cambridge, 2002.
R. Milner, J. Parrow, and D. Walker. A Calculus of Mobile Processes,
Info. & Comp. 100(1), pp.1–77, 1992.


M. Nickau. Hereditarily Sequential Functionals, LNCS 813, pp.253–264, Springer-Verlag, 1994.
L. Ong. Correspondence between operational and denotational semantics. Handbook of Logic in Computer Science, Vol 4, pp. 269–356, Oxford University Press.
B. Pierce and D. Sangiorgi. Typing and subtyping for mobile processes, MSCS
6(5):409–453, 1996.
G. D.Plotkin. Call-by-name, call-by-value and the λ-calculus. Theoretical Computer Science, 1:125–159, 1975.
D. Scott and C. Strachey. Towards a Mathematical Semantics for Computer Languages. Computers and Automata. Polytechnic Institute of Brooklyn Press,
pp. 19-46, 1971.
N. Yoshida, M. Berger, and K. Honda. Strong Normalisation in the π-Calculus, LICS’01, IEEE, 2001. The full version as MCS technical report, 2001-09, University of Leicester, 2001. Available at www.mcs.le.ac.uk/˜nyoshida.
N. Yoshida, K. Honda, and M. Berger. Linearity and Bisimulation, Proc. of 5th International Conference, Foundations of Software Science and Computer Structures (FoSSaCs 2002), LNCS 2303, pp.417–433, Springer, 2002.

Appendix
Structural Congruence
The structural congruence ≡ is the least congruence which includes the stan- dard α-equality and the above equations.
P|0 ≡ P , P|Q ≡ Q|P , (P |Q)|R ≡ P|(Q|R).
(ν x)0 ≡ 0, (ν x)(ν y)P ≡ (ν y)(ν x)P and, if x /∈ fn(Q), (ν x)(P|Q) ≡
(ν x)P|Q.
x(→y)u(→v)P ≡ u(→v)x(→y)P , (ν z)x(→y)P ≡ x(→y)(ν z)P (z /∈ →y) and, if {→y}∩ 
fn(Q) = ∅, x(→y)(P |Q) ≡ x(→y)P |Q.

Proof of Proposition 3.2
For (1), the closure under ≡ is by rule induction on the generation rules of ≡, precisely following the same proof in [5]. For the closure under −→, it suffices to show the statement for the two generation rules. The case for replication is the same as [5]. The interesting case is linear reduction, which involves choice. Assume we have
▶O &ixi(→yi).Pi | xi(→yi)Qd Θ.	(A.1)
Our goal is to show (ν →yi)(Pi|Q) has the same typing as this term. By rolling back (Weak) (which is always possible except for the initial rule (Zero)), it


loses no generality if we assume this sequent is inferred by (Par). Thus we assume,
▶φ1 &ixi(→yi).Pi d Θ1,  ▶φ2 xi(→yi)Qd Θ2	(A.2)
such that φ1 ⊙ φ2 = φ and Θ1 ⊙ Θ2 = Θ. We can again safely assume these terms are inferred by (In↓) and (Out↑), respectively. Thus, for input, we can set Θ1 = Γ1, ∆ such that dom(∆) = {→x} and φ1 = I. By (In↓) we infer:
▶O Pi d Γ1, →y :→τ	(A.3)
For output, by (1) and (2) of Definition 3.1 and by noting xi ∈ dom(Θ1) ∩
dom(Θ2), we have Θ2 = Γ2, ∆ where ∆ denotes the pairwise dual of ∆ and
(Γ1 ⊙ Γ2) ⊗ →x :‡ = Θ,	(A.4)
as well as φ2 = O. By (Out↑) we have:

▶I Qd Γ2, →y :→τ.	(A.5)
By (A.3) and (A.5) we are done.

Proof of Proposition 5.1
(1) is by observing the correspondence between the transition rules and the typing rules.  (2) is direct from the transition.  For (3), the “if” direction

x(→y)
is immediate, while the “only if” direction is by showing P −→
P ' implies

P ≡ x(→y)Q|R as well as the dual case, from which we can generate the cor- responding reduction (note we are taking terms modulo ≡ in defining the transition). (4) and (5) are easy inspection of each rule.
