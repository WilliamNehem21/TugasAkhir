Electronic Notes in Theoretical Computer Science 117 (2005) 89–111 
www.elsevier.com/locate/entcs


The Polymorphic Rewriting-calculus
[Type Checking vs. Type Inference]

Luigi Liquoria and Benjamin Wackb
a INRIA Sophia Antipolis
b LORIA & Universit´e Henri Poincar´e, Nancy

Abstract
The Rewriting-calculus (Rho-calculus), is a minimal framework embedding Lambda-calculus and Term Rewriting Systems, by allowing abstraction on variables and patterns. The Rho-calculus fea- tures higher-order functions (from Lambda-calculus) and pattern-matching (from Term Rewriting
Systems). In this paper, we study extensively a second-order Rho-calculus `a la Church (RhoF)
that enjoys subject reduction, type uniqueness, and decidability of typing. Then we apply a clas- sical type-erasing function to RhoF, to obtain an untyped Rho-calculus `a la Curry (uRhoF). The related type inference system is isomorphic to RhoF and enjoys subject reduction. Both RhoF and uRhoF systems can be considered as minimal calculi for polymorphic rewriting-based program- ming languages. We discuss the possibility of a logic existing underneath the type systems via a
Curry-Howard Isomorphism.
Keywords: Rewriting-calculus, Pattern-matching, Polymorphism, Type-checking vs.
Type-inference.

Introduction
A promising line of research unifying the logic paradigm with the functional paradigm is that of rewriting-based languages [29] (Elan[39], Maude
[38], ASF+SDF[41,36], OBJ∗[17,20], ... ). Although these languages are less used than object-oriented languages (Java[33], C#[27], ... ), they can also
serve as (formal) common intermediate languages for implementing compilers for rewriting-based, functional, object-oriented, logic, and other “high-level” modern languages.
One of the main advantages of the rewriting-based languages is pattern- matching which allows one to discriminate between alternatives. Each pattern


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.027


is associated with an action; once an instance of a pattern is recognized, the corresponding term is rewritten to a new one. Another advantage of rewriting- based languages (in contrast with ML or Haskell) is the ability to handle non- determinism by means of a collection of results: pattern-matching needs not to be exclusive, i.e. multiple branches can be taken simultaneously. An empty collection of results represents a matching failure, a singleton represents a
deterministic result, and a collection with more than one element represents a non-deterministic choice between the elements of the collection.
Useful applications of pattern-matching lie in the field of pattern recogni- tion, and strings/trees manipulation. It has also been widely used in functional and logic programming, for instance in ML[30,34], Haskell[37], Scheme[40], or
Prolog[35]. However, in all these applications, pattern-matching is considered
as a convenient mechanism for expressing complex requirements about the function’s argument, rather than a basis for an ad hoc paradigm of compu- tation; we argue that the computational behavior of a calculus can be really influenced by the presence of pattern-matching.
One of the most commonly used models of computation, the Lambda- calculus, uses only trivial pattern-matching. This calculus has recently been extended, initially for programming concerns, either by introducing patterns in Lambda-calculi [31,42], or by introducing matching and rewrite rules in functional languages. More concerned with extending logics, Stehr has studied a Calculus of Constructions enhanced with rewriting logic [32].
The Rewriting-calculus [9,12] integrates matching, rewriting and functions
in a uniform way. Its abstraction mechanism is based on the rewrite rule formation: in a term of the form P d A, one abstracts over the pattern P . Note that the Rewriting-calculus is a generalization of the Lambda-calculus, since we get the Lambda-calculus back if every pattern P is a variable.
If an abstraction P d A is applied to the term B, then the evaluation mechanism is based on the instantiation (in A) of the free-variables present in P with the appropriate subterms of B. Indeed, this instantiation is achieved by matching P against B. One of the advantages of matching is that it can be customized with elaborated equational theories.
A large class of Term Rewriting Systems are also embedded in the Rewriting- calculus. In particular, the notions of rule application and result (basic ingredi- ents of Term Rewriting Systems) become explicit. A rewrite rule is a first-class
citizen, which can be created, manipulated and modified by the calculus itself. The abilities to manipulate rules and to define evaluation strategies repres- ent the basic methods in rewriting-based languages. These strategies can be
implicit as in ASF+SDF[41], local as in OBJ∗ and Maude, or user deﬁned as in Elan and Maude[13]. Previous papers [7,8,12] showed that the Rewriting-


calculus can be used as a core engine calculus for rewriting-based languages such as Elan and Maude.
Finally, static analysis via a type system (inherited from the Lambda- calculus) enforces a safer programming discipline. This paper presents a Rho- calculus `a la Church (called RhoF) featuring second-order polymorphic types. Then we apply a classical erasing function to RhoF in order to obtain a corres- ponding type inference system `a la Curry (uRhoF). We discuss the possibility
of a logic existing underneath both type systems via the well-known Curry- Howard Isomorphism. The two systems are good candidates for giving the static semantics of a family of rewriting-based languages such as Elan and
Maude.
The main contributions of this paper are:
to present and study a fully-typed Polymorphic Rewriting-calculus (RhoF); this type system could be used to give a static type discipline for fully typed rewriting-based languages.
to study the corresponding Type Inference Polymorphic Rewriting-calculus (uRhoF) obtained from RhoF via a type-erasing function;
to discuss a possible common logic underneath the two type systems.

Plan of the paper.
In Section 2, we present the syntax of the calculus and its small-step se- mantics. In Section 3, we introduce the fully typed second-order rewriting calculus `a la Church RhoF: types of the bound variables are specified in the term, making type reconstruction and verification quite straightforward. The
calculus enjoys subject reduction, and type uniqueness. In Section 4, we present the calculus `a la Curry uRhoF: type information is not given in the term, and the type system is not fully syntax-directed, thus enforcing a flex-
ible polymorphic type discipline. The calculus enjoys subject reduction, but as it is well-known for the λ-calculus, type inference is undecidable. Section 5 conclude.

The System RhoF
We detail the syntax and the semantics of RhoF, and we give some examples.

Syntax
Notational Conventions.
We consider the meta-symbols “ d ” (function- and type-abstraction), and “[   ]” (delayed matching constraint), and “ ; ” (structure operator).




Syntactic Cat.
K ∈ Kinds τ.ι ∈ Type Γ.∆ ∈ Context
Abstract Syntax
K ::= ∗
τ	::= ι | α | τ d τ | ∀α.τ
∆ ::= ∅ | ∆, α:K | ∆,f :τ | ∆,X:τ

P.Q ∈ Pattern P ::= stk | α | X | f (P ) (all vars occur only once in any P)
A.B.f ∈ Term	A ::= stk | f | X | P d∆ A | [P  ∆ A]A | A A | A τ | A ; A

Figure 1. Syntax of RhoF
The application operator is denoted by concatenation.
We assume that the application operator associates to the left, while the other operators associate to the right. The priority of the application is higher
than that of “[  ] ” which is higher than that of “d “ which is, in turn, of higher priority than the “ ;”. The symbol τ ranges over the set Type of types, the symbol ι ranges over the set TypeK of type constants (TypeK ⊆ Type), the symbols α, β range over the set TypeV of type-variables (TypeV ⊆ Type), the symbols A, B, C,..., U, V, W,Z range over the set Term of (un)typed terms, the symbols X, Y, Z,... range over the set Var of term variables (Var ⊆ Term), the symbols a, b, c,... , f, g, h,... range over a set TermK of term constants (TermK ⊆ Term). The symbols P, Q range over the set Pattern of pat- terns, (Var ⊆ Pattern ⊆ Term). The symbols θ, φ, ψ range over substitu- tions. Finally, the symbols A, B, C range over Type ∪ Term. We denote A for
A1 ··· An, for n ≥ 0. The application of a constant, say f , to a term A will be usually denoted by f (A), following the algebraic folklore; this convention can be currified in order to denote a function taking multiple arguments, e.g.
Δ	Δ

f (A) = f (A1, ··· , An) = f A1 ··· An.

Syntax (Figure 1).
The types are as one would expect from a polymorphic type system (i.e. type-variables can be bound in types through the ∀ binder). The patterns are algebraic terms (i.e. terms constructed only with variables, constants and applications) which can be used as left-hand sides of the rewriting rules; the
set of patterns is obviously included in the set of terms. The well-known linearity restriction [42] is needed to keep the small-step semantics confluent. A typed rewriting rule of the form P d∆ A abstracting over the free-variables


of P is a first-class citizen of the calculus. The context ∆ records the type of the free-variables of P (bound in A). When a pattern is a variable, we write X dτ A, instead of X d(X:τ) A (by a little abuse of notation). An application
is implicitly denoted by concatenation; note that “terms can be applied to
types”. The delayed matching constraint [P  ∆ A]B can be seen as the term B with its free-variables (declared in ∆) constrained by the matching between P and A. The symbol stk is the special constant representing all the delayed matching constraints whose matching problem is unsolvable. A structure is a collection of terms that can be seen either as a set of rewriting rules or as a
set of results.

Free-Variables and Substitutions.
Definition 2.1 [Free-variables Fv]


As usual, we work modulo α-conversion and we adopt Barendregt’s “hygiene- convention” [1], i.e. free- and bound-variables have different names. This al- lows us to define substitutions quite straightforwardly, since it avoids problems
like variable capture.
Definition 2.2 [Substitutions]
A substitution θ is a mapping from the set of term variables (resp. type variables) to the set of terms (resp. types). A finite substitution θ has the form
{A1/X1 ... Am/Xm}, or {τ1/α1 ... τm/αm}, and its domain Dom(θ) denotes
{X1,... , Xm}, resp. {α1,... , αm}. The application of a substitution θ to a term A (resp. type τ ), denoted by Aθ (resp. τθ), is defined as follows:


Δ
fθ	= f
(P d∆ A)θ
Δ
= P d∆ Aθ

stkθ

Δ
= stk
([P  ∆ A]B)θ

Δ
= [P  ∆ Aθ]Bθ

(A τ )θ
Δ
= (Aθ) (τθ)
(A ; B/A B)θ
Δ
= Aθ ; Bθ/Aθ Bθ


Xiθ
Δ 8< Ai ifXi ∈ Dom(θ)
Xi otherwise
Δ

αiθ
Δ 8< τi	if αi ∈ Dom(θ)
αi	otherwise
Δ

ιθ	= ι
(τ1 d τ2)θ
= τ1θ d τ2θ


Matching Equations, Theories and Term Approximations.
The core mechanism of the Rewriting-calculus is pattern-matching.  When a delayed matching constraint is evaluated, then a corresponding matching problem has to be solved. We use a theory for the Rho-calculus (introduced in [12]) that handles uniformly matching failures and eliminates them when not significant for the computation. We define rules for handling this kind of terms and we show how they are integrated in the calculus. The classical notions of matching equations and matching solutions are defined as usual.
Definition 2.3 [Matching] Given a theory T
A matching equation is a problem T = P <<T A where P is a pattern and
A is a term;
T
A substitution θ is a solution of the matching equation T if Pθ = A.
Different theories and the corresponding pattern-matching problems can be formally defined and solved, for example as explained in [8]. If the equation P <<T A has a unique solution, we denote it by θ(P <<T A).
We define a superposition relation ± : Уattern × 7erm between patterns
and terms whose aim is to characterize a broad class of matching equations that are potentially solvable. If P ± A we say that “P does potentially super- pose with A” and, by negation, if P /± A then “P surely does not superpose with A”.
Definition 2.4 [Superposition]
The relation of superposition P ± A is defined according to the structure of P as follows:

			

f  ± f
stk ± stk
X  ± A  (∀A)
α  ± τ	(∀τ )
f (P ) ± A if A ≡ f (B) ∧ P ± B
8 X ∨ (A1 ; A2) ∨ A τ ∨
P ± A if A ≡ >< (A1 A2 ∧ A1 ∈/ Pattern )∨
>: ([Q  ∆ A1]A2 ∧ Q ± A1 ∧ P ± A2) (∀P )


If P ± A is not satisfied we write P /± A.
Starting from the superposition relation, we define a reduction relation that eliminates from a term all the definitively stuck subterms, i.e. all the delayed matching constraints whose matching problem is unsolvable independently of subsequent instantiations and reductions.
Definition 2.5 [Stuck Theory, Tstk]




Figure 2. Top-level Rules of RhoF
The relation →stk is defined by the following rules:
[P  ∆ A]B →stk stk	if P /± A
stk ; A	→stk A
A ; stk	→stk A
stk A	→stk stk
We denote by →stk the contextual closure induced by these rules. Its reflex- ive and transitive closure is denoted by →stk. The symmetric and transitive
stk
closure of →stk is denoted by =.  Let Tstk be the theory associated to the
stk
congruence =. Matching equations in the theory Tstk are denoted P <<stk A.
As mentioned previously, these rules are used to propagate or eliminate the definitively stuck terms.

The Polymorphic Rewriting-calculus, RhoF
Figure 2 shows the reduction rules of RhoF parameterized by the theory Tstk
(recall the symbols A, B, C range over 7ype ∪ 7erm).
Let us quickly explain the top-level rules:
(ρ) this rule triggers the application of an abstraction to a term, but does not immediately try to solve the associated matching equation.
(σ) this rule is applied if and only if the matching equation P <<stk B has at least one solution: in this case the matching solutions are computed and applied to the term A. If there is more than one match, a structure collecting all the different results is obtained when the rule is applied. If there is no solution, this rule does not apply and thus, the term that is on the left-hand side represents a matching failure. As we shall see, further reductions or instantiations are likely to modify B so that the equation has a solution and the rule can be triggered.


(δ) this rule distributes structures on the left-hand side of the application. This gives the possibility, for example, to apply in parallel two distinct pattern-abstractions A and B to a term C.
(stk) pushes into the operational semantics the rewriting rules that are par- ticular to the theory adopted in the calculus; in our case the above defined Tstk-theory.
We denote by →ρσδ the contextual closure induced by these rules. Its reflexive and transitive closure is denoted by →ρσδ. The symmetric and transitive closure of →ρσδ is denoted by =ρσδ. Notice that these relations are parameterized by

the adopted theory Tstk. We denote by →stk the relation →stk ∪ '→
. For → ,

the following holds.
ρσδ
ρσδ
ρσδ

Theorem 2.6 (Church Rosser for RhoF [12])
The relation →ρσδ is confluent.
The Polymorphic Type System RhoF
Types can be used as predicates for terms of Rho-calculus. Terms can be directly decorated with types and then every closed term comes directly with a unique, intrinsic type. In this fully typed approach, a type judgment will be denoted by the symbol ▶T (for Typed terms). A typed system is a set of rules for proving judgments of the shape Γ ▶T A : τ , where A is a typed term, τ is a type, and Γ is a context. The meaning of such a judgment is: the term A has type τ under the context Γ, and Γ records the types of the free-variables of Γ and τ . Figures 3, and 4 presents the kinding/typing rules of RhoF, which
are directly inspired by the Girard System F [19]. More precisely, the system proves judgment of the shape:
Γ ▶T ok and Γ ▶T τ : ∗ and Γ ▶T P : τ and Γ ▶T A : τ
We discuss only the typing rules for well-formed terms and patterns, the other typing rules being standard.
(T erm·V ar)(T erm·Const): As usual, the context determines the type of variables. It cannot contain two declarations for the same variable (or con- stant);
(T erm·Stuck): Since stk can appear in any structure, its type can be virtu- ally anything but falsum, i.e. ⊥ = ∀α.α;
(T erm·Absd): For the left-hand side of the arrow-type, we use the type of the pattern P ; this rule allows one to hide some type information in a pattern containing applications (e.g. τ2 disappears in the final type of f (X) in the judgment f :τ2 d τ1,X:τ2 ▶ f (X) : τ1). The context ∆ gives the types of the free-variables of P . The type system ensures that the solutions of the corresponding matching equations are well-typed;



Well-formed Contexts

(Ctx·Empty)
∅ ▶T ok

Γ ▶T ok	α /∈ Dom(Γ) Γ, α:∗ ▶T ok




(Ctx·V ar∀)



Γ ▶T ok	ι /∈ Dom(Γ) Γ, ι:∗ ▶T ok


(Ctx·Const)
Γ ▶T ok	Γ ▶T τ : ∗	X /∈ Dom(Γ) Γ,X:τ ▶T ok


(Ctx·V ar)



Well-kinded Types
Γ1, ι:∗, Γ2 ▶T ok
(Type·Const)
Γ1, ι:∗, Γ2 ▶T ι : ∗

Γ1, α:∗, Γ2 ▶T ok


Γ1, α:∗, Γ2 ▶T α : ∗




(Type·V ar)


Γ, α:∗ ▶T τ : ∗	Γ ▶T τ1 : ∗	Γ ▶T τ2 : ∗
(Type·P oly)	(Type·Arrow)
Γ ▶T ∀α.τ : ∗	Γ ▶T τ1 d τ2 : ∗
Figure 3. The Kind System for RhoF


(T erm·Appl): We directly exploit the information given in the type of the function, statically checking that the given argument has the expected type τ1;
(T erm·Abs∀): The rationale is: α d∗ A  α d(α:∗) A. Abstraction on type- variables makes the polymorphic mechanism available at the user-level: note that a trivial pattern is used in polymorphic-abstraction.
(T erm·Appl∀): The rationale is: all free occurrences of α in τ1 are substi- tuted with τ2. Any well-formed type τ2 is suitable, which makes the typing fully polymorphic.
(T erm·Struct): This rule states that all the members of a structure have the same type. This is important when considering structures as a collection of results; if a function can return different results, then we would at least expect them to have the same type;
(T erm·Matchd)(T erm·Match∀): The first rule states that the constraint [P  ∆ B]A gets the same type as (P d∆ A) B. This is sound since (P d∆ A) B →ρ [P  ∆ B]A. The second rule instantiates α with τ2.

Example 3.1 [Some derivable typing judgments [2]-inspired]


Well-formed Terms and Patterns

Γ1,X:τ, Γ2 ▶T ok


Γ1,X:τ, Γ2 ▶T X : τ


(T erm·V ar)
Γ1,f :τ, Γ2 ▶T ok


Γ1,f :τ, Γ2 ▶T f : τ


(T erm·Const)



Γ ▶T A : τ1 d τ2
Γ ▶T B : τ1
Γ ▶T A B : τ2




(T erm·Appld)
Γ, ∆ ▶T P : τ1 Fv(P ) = Dom(∆) Γ, ∆ ▶T A : τ2 Γ, ∆ ▶T τ1 d τ2 : ∗
Γ ▶T P d∆ A : τ1 d τ2




(T erm·Absd)



Γ, α:∗ ▶T A : τ


Γ ▶T α d∗ A : ∀α.τ

(T erm·Abs∀)
Γ ▶T A : ∀α.τ1	Γ ▶T τ2 : ∗


Γ ▶T A τ2 : τ1{τ2/α}

(T erm·Appl∀)



Γ ▶T A : τ
Γ ▶T B : τ


Γ ▶T A ; B : τ




(T erm·Struct)
Γ, ∆ ▶T P : τ1 Fv(P ) = Dom(∆) Γ, ∆ ▶T A : τ2 Γ ▶T B : τ1
Γ ▶T [P  ∆ B]A : τ2




(T erm·Matchd)


Γ ▶T τ : ∗	τ /= ⊥	Γ ▶T τ2 : ∗	Γ, α:∗ ▶T A : τ1
(T erm·Stuck)	(T erm·Match∀)
Γ ▶T stk : τ	Γ ▶T [α  ∗ τ2]A : τ1{τ2/α}
Figure 4. The Type System for RhoF
Let Γ = ι:∗,f :ι d ι, a:ι. The following judgments are derivable:
∅ ▶T ⊥ ≡ ∀α.α : ∗	Second-order definition of falsum
∅ ▶T α d∗ X d⊥ (X α) : ∀α.(⊥ d α)  Ex falso sequitur quodlibet 1
∅ ▶T β d∗ Y dβ X : ∀β.(β d β)	Polymorphic identity
Γ ▶T (γ d∗ f (Z) d(Z:γ) Z) ι f(a) : ι	Polymorphic instantiation-application



Metatheory of RhoF
The type system ensures that arguments of a function have the same types as the corresponding formal parameters. The rule (T erm·Appl) only checks that the pattern expected by a function and the argument (considered as a single term) have the same type. The shape of pattern is essential to guarantee the

1 Anything follows from a false judgment: the subject of this judgment is its proof.


soundness of the type system: the more expressive the patterns are, the more non-sense can follow.
Remark 3.2 [Spoofer [3]] If we allow variables as the head symbol of a pattern (called “active variables”), then we can write the following counter- example. In the context Γ = X:τ1 d τ2,Y :τ1,f :τ3 d τ2, a:τ3, the pattern


Γ ▶T X : τ1 d τ2  Γ ▶T Y : τ1


Γ ▶T X(Y ) : τ2	and the term
Γ ▶T f : τ3 d τ2  Γ ▶T a : τ3

Γ ▶T f (a) : τ2


have a common type, but the solution of the matching problem X(Y ) << f (a) instantiates X and Y with terms not having the expected type (i.e. subject
Δ	Δ
reduction is lost); if Γ = f :τ3 d τ2, a:τ3 and ∆ = X:τ1 d τ2,Y :τ1, then Γ ▶T
(X(Y ) d∆ Y )f (a) : τ1 but Γ ▶T a : τ3.
All the metaproperties presented below for RhoF are adapted from the classical properties of the Girard’s Lambda-calculus.
Lemma 3.3 (Substitution Lemma)
If Γ, ∆ ▶T P : τ and Γ ▶T B : τ and Dom(∆) = Fv(P ), are such that P <<stk B has a solution θ, then for all X ∈ Fv(P ), there exists σ such that Γ, ∆ ▶T X : σ and Γ ▶T Xθ : σ.
If Γ, ∆ ▶T A : τ, then for any well-typed substitution θ such that Dom(θ) = 
Dom(∆), we have Γ ▶T Aθ : τ.
Theorem 3.4 (Subject Reduction for RhoF)
If Γ ▶T A : τ and A →ρσδ B, then Γ ▶T B : τ.
Proof By an induction on the derivation of Γ ▶T A : τ.	 
Theorem 3.5 (Type Uniqueness for ρFix )
If Γ ▶T A : τ1 and Γ ▶T A : τ2, and stk ∈/ A, then τ1 ≡ τ2.
Proof By an easy induction on the structure of A.	 
Theorem 3.6 (Decidability of Typing for RhoF)
For a closed A such that stk ∈/ A, the following problems are decidable:
Type Reconstruction: is there a type τ such that ∅ ▶T A : τ ?
Type Checking: for a given τ, is it true that ∅ ▶T A : τ ?
Proof
We give the sketch of a recursive algorithm (Figure 5) for building τ (or returning false if it does not exist).


We use the previous algorithm for type reconstruction (Figure 6). By uniqueness of typing, Γ ▶T A : τ if and only if τ is equivalent to the type found for A.

The next example shows that termination is not guaranteed for typable terms in RhoF.
Example 3.7 [Non Termination of Typable Terms [11]]
Δ	Δ
If Γ ▶T A : τ then A can diverge.  Take Γ = f :(ι d ι) d ι, and ∆ = X:ι,
Δ	Δ
and A = ω f (ω) with ω = f (X) d∆ X f (X). Therefore, Γ ▶T ω f (ω) : ι, but
ω f (ω) →ρσδ .. .. This negative result proves that conjecture (i) of Exercise at pp. 14 of [10] was false. Notice that ωf (ω) is typable without using the second-order features of RhoF.

The Polymorphic Type Inference uRhoF
In the previous section, we studied terms of the Rho-calculus decorated with types. In this fully typed approach, every closed term comes directly with a unique, intrinsic type. In this section, we discuss another way of giving types to terms of the Rho-calculus: the type assignment approach introduced by Curry [14] for the Theory of Combinators, and then modified by Curry and Feys [5,6]. The judgments have the shape Γ ▶U U : τ , where U is a term of the (untyped) Rho-calculus, τ is a type, and Γ is the context that assigns types
to the free-variables of U and τ .
In this approach (called `a la Curry by Barendregt), types are viewed as predicates (properties) of terms, and each closed term can be assigned either none or infinitely many types. Those systems are called type assignment sys- tems. When we look at the Rho-calculus as a kernel calculus underneath a
pattern-matching based programming language, this approach corresponds to Elan, or Maude, or OBJ∗, or ASF+SDF, or Haskell, or ML-like languages, where the user can write programs in a completely untyped language, and types are
automatically inferred at compilation-time. Type inference can be also inten- ded as the construction of an abstract interpretation of the program, that can be used as a correctness criterion.
For the Lambda-calculus, in [14,23,21], it was observed that some of the type assignment systems already known in the literature can also be obtained from a fully typed system by means of an erasing function that erases type information from terms in a typed system.  In particular, the Curry type
assignment system (F 1) [14] can be obtained from Λ d, the polymorphic type assignment system (F 2) [23] from Λ2, and the higher-order type assignment


Type2(A; Γ) Δ match A with
α	⇒ ∗
if α:∗ ∈ Γ
X/f	⇒ τ
if X/f :τ ∈ Γ
A1 ; A2	⇒ Type2(A1; Γ)
if Type2(A1; Γ) = Type2(A2; Γ)
P d  A	⇒ Type2(P ; Γ, ∆) d Type2(A ; Γ, ∆)
if Type2(P ; Γ, ∆) /= false /= Type2(A1; Γ, ∆)
and P /≡ α
[P  ∆ A1]A2 ⇒ Type2(A2; Γ, ∆)
if Type2(P ; Γ, ∆) = Type2(A1; Γ, ∆) /= false and P /≡ α
A1 A2	⇒ τ2
if Type2(A1; Γ) = τ1 d τ2 and Type2(A2; Γ) = τ1 α d∗ A1	⇒ 6α.Type2(A1; Γ, α:∗)
if Type2(A1; Γ, α:∗) /= false
[α  ∗ τ ]A	⇒ Type2(A ; Γ, α:∗){τ/α} A1 τ	⇒ τ1{τ/α}
if Type2(A1; Γ) = 6α.τ1
⇒ false
Figure 5. The Algorithm Type2
system (Fω) [21] from the higher-order λ-calculus Λω.
Let ÐerT be a typed derivation, and Q — ¢ be the erasing function.  By applying Q — ¢ to the “subject” of every judgment in ÐerT, we obtain a valid


Typecheck2(A; Γ; τ ) Δ if Type2(A; Γ) = τ then true else false
Figure 6. The Algorithm Typecheck2


Syntactic Cat.
As for RhoF
U.V.f ∈ 7erm
Abstract Syntax
As for RhoF
U.V ::= stk | f | X | P d U | [P  U ]U | U U | U ; U


Figure 7. Syntax of uRhoF
type assignment derivation ÐerU with the same structure of the typed one. Vice versa, every type assignment derivation can be viewed as the result of an application of Q — ¢ to a typed one. In particular, the erasing function Q — ¢ induces an isomorphism between every typed system and the corresponding type assignment system.
Definition 4.1 The Erasing Function.

Q stk ¢ Q f ¢ Q X ¢ Q A B ¢ Q A ; B ¢

Δ
= stk
Δ
= f
Δ
= X
Δ
= Q A ¢ Q B ¢
Δ
= Q A ¢ ; Q B ¢

Q A τ ¢
Q α d∗ A ¢ Q [α  ∗ τ ]B ¢ Q P d∆ A ¢
Q [P  ∆ A]B ¢

Δ
= Q A ¢
Δ
= Q A ¢
Δ
= Q B ¢
Δ
= P d Q A ¢	P /≡ α
Δ
= [P  Q A ¢]Q B ¢	P /≡ α

This definition can easily be extended to derivations.

Syntax (Figure 7).
One can easily see that the syntax is obtained by simply “hiding” the types from the user. Type abstraction (α d∗ A) and type application (A τ ) are no longer necessary since the polymorphism is fully implicit. As in ML, a 
term can be seen as an untyped one, but the typing machinery is called before accepting such a term.

Typing Rules (Figures 8 and 9).
A primitive polymorphic type assignment system was sketched in [10] (without any metatheory). It proves judgment of the shape:
Γ ▶U ok and Γ ▶U τ : ∗ and Γ ▶U P : τ and Γ ▶U U : τ
We discuss only the typing rules for well-formed terms and patterns which differ from the the corresponding typed ones.



Well-formed Contexts

(Ctx·Empty)
∅ ▶U ok

Γ ▶U ok	α /∈ Dom(Γ) Γ, α:∗ ▶U ok




(Ctx·V ar∀ )



Γ ▶U ok	ι /∈ Dom(Γ) Γ, ι:∗ ▶U ok


(Ctx·Const)
Γ ▶U ok	Γ ▶U τ : ∗	X /∈ Dom(Γ) Γ,X:τ ▶U ok


(Ctx·V ar)



Well-kinded Types
Γ1, ι:∗, Γ2 ▶U ok
(Type·Const)
Γ1, ι:∗, Γ2 ▶U ι : ∗

Γ1, α:∗, Γ2 ▶U ok


Γ1, α:∗, Γ2 ▶U α : ∗




(Type·V ar)


Γ, α:∗ ▶U τ : ∗	Γ ▶U τ1 : ∗	Γ ▶U τ2 : ∗
(Type·P oly)	(Type·Arrow)
Γ ▶U 6α.τ : ∗	Γ ▶U τ1 d τ2 : ∗
Figure 8. The Kind Assignment System for uRhoF
(T erm·Absd): The domain of ∆ is given by the free-variables of P , i.e.
Dom(∆) = Fv(P ).
(T erm·Abs∀): This rule is not syntax directed; the classical side-condition about the freshness of α is enforced by the well-formedness of the context in the premises.
(T erm·Appl∀): This rule is not syntax directed; the type τ2 is guessed.
(T erm·Matchd): The context ∆ is built from the free-variables of P , i.e.
Dom(∆) = Fv(P ).
All the metaproperties presented below for uRhoF are adapted from system
F 2 of Leivant and for RhoF.
Theorem 4.2 (Subject Reduction for uRhoF)
If Γ ▶U U : τ and U →stk V , then Γ ▶U V : τ.
Proof By an induction on the derivation of Γ ▶U U : τ.	 
Since uRhoF is essentially the counterpart of F 2 of Leivant, and since Rho- calculus is a conservative extension of Lambda-calculus, it follows that type inference problem is undecidable.
Theorem 4.3 (Undecidability of Type Inference for uRhoF)
For a closed U such that stk ∈/ U, the following problem is undecidable:


Well-formed Terms and Patterns
Γ ▶U τ : ∗	τ /= ⊥

Γ ▶U stk : τ
(T erm·Stuck)



Γ1,X:τ, Γ2 ▶U ok


Γ1,X:τ, Γ2 ▶U X : τ

(T erm·V ar)
Γ1,f :τ, Γ2 ▶U ok


Γ1,f :τ, Γ2 ▶U f : τ

(T erm·Const)



Γ ▶U U : τ1 d τ2
Γ ▶U V : τ1
Γ ▶U U V : τ2




(T erm·Appld)
Γ, ∆ ▶U P : τ1 Dom(∆) = Fv(P ) Γ, ∆ ▶U U : τ2 Γ, ∆ ▶U τ1 d τ2 : ∗
Γ ▶U P d U : τ1 d τ2




(T erm·Absd)



Γ, α:∗ ▶U U : τ


Γ ▶U U : 6α.τ

(T erm·Abs∀)
Γ ▶U U : 6α.τ1	Γ ▶U τ2 : ∗


Γ ▶U U : τ1{τ2/α}

(T erm·App∀)



Γ ▶U U : τ
Γ ▶U V : τ


Γ ▶U U ; V : τ




(T erm·Struct)
Γ, ∆ ▶U P : τ1 Dom(∆) = Fv(P ) Γ, ∆ ▶U U : τ2 Γ ▶U V : τ1
Γ ▶U [P   V ]U : τ2




(T erm·Matchd)


Figure 9. The Type Assignment System for uRhoF
Type Inference: given Γ (gives meaning to constants), is there a type τ such that Γ ▶U U : τ ?
Proof It follows a fortiori from the well known result of Wells [43].	 

RhoF vs. uRhoF vs. Logics
RhoF vs. uRhoF.
Writing or inferring types in programming languages is often a matter of taste; nice examples of flexible (often polymorphic) type-disciplines are ML and Haskell languages. The user can freely decorate his program with types or simply leave that job to the type inference module. The former choice
gives to the user full-control on data-structures, while the latter delegates some choices to the type inference module. Both views are sound and opera- tional. For example, since type-checking in RhoF is decidable, adding decidable


polymorphic-types seems feasible and natural for Elan (since it is dynamically typed), and intriguing for Maude, because the latter has a sophisticated form of polytypic programming [4,16], where parameterized modules and theories can be defined and manipulated in a “nesting dolls” style (matrioshka).
From the point of view of type inference, the main motivation in introdu- cing uRhoF is to find an easy way to validate a posteriori many existing lines of rewriting-based algorithms via static analysis.
The type inference module provides a safeguard to type-free code that is external rather than built-in. To be correctly applied, a type assignment system must enjoy fundamental properties, like the Church-Rosser property and the subject-reduction property. Normalization is not really an issue for
kernel calculi underneath real programming languages. Therefore, to design a decidable version of uRhoF by customization of the well-known algorithm W of Damas-Milner [15] is an interesting challenge with practical consequences.

Logics.
The design of RhoF and uRhoF was also driven by a genuine interest in find- ing a suitable logic underneath both systems. The above mentioned erasing function Q · ¢, at least for RhoF and uRhoF, induces an isomorphism between the derivations in the corresponding systems. More precisely, if Ðer is a derivation in a typed system, by applying Q · ¢ to every object (i.e. term, constructor, or kind) in Ðer, a valid derivation in the corresponding type assignment system is obtained. The other way around, every type assignment derivation can be
obtained by applying Q · ¢ to a typed one.
Definition 5.1 [Isomorphism]
Let Set(ÐerT) and Set(ÐerU) be the sets of all derivations in RhoF and uRhoF. Systems RhoF and uRhoF are isomorphic, via Q · ¢, if and only if there are F : Set(ÐerT) ⇒ Set(ÐerU) and G : Set(ÐerU) ⇒ Set(ÐerT), such that:
(Soundness) If ÐerT : Γ ▶T A : τ , then F(ÐerT) : Q Γ ¢ ▶U Q At ¢ : τ .
(Completeness) If ÐerU : Γ' ▶U U : τ , then G(ÐerU) : Γ ▶U A : τ , and
Q Γ ¢ = Γ', with Q M ¢ = U .
F◦G and G◦F are the identity on Set(ÐerU) and Set(ÐerT), respectively.
Both F and G preserve the structure of derivations, (i.e., the tree obtained from a derivation by erasing all judgments, but not the names of the rules).
Notice that the definition of isomorphism expresses more than just sound- ness and completeness of F. Indeed soundness and completeness imply an isomorphism between the judgments of the two systems, but they do not im-



	

\
\
\
\\ ÐerT
/	\
/ 	F	) \
/	\
/	\
/
/
/
ÐerU //

\	/	(
\	/
\	/
\ /
\/
(
G	\	/
\	/
\	/
\ /
Q · ¢ )	\/

Γ ▶T A : τ
Q · ¢−1
Γ ▶U Q A ¢ : τ

Figure 10. Functions between Typed and Untyped Judgments and Derivations.

ply necessarily a one-to-one correspondence between proofs.
Functions F and G are omitted; their constructions are left as an easy exer- cise to the interested reader. Figure 10 depicts the various functions between typed and untyped systems of Rho-calculus that realize the above relations between typed and untyped judgments and derivations. Similar functions for
the Lambda-calculus, relating typed system `a la Church with corresponding type assignments systems `a la Curry can be found in [24,28].
Theorem 5.2 (RhoF vs. uRhoF)
Systems RhoF, and uRhoF are isomorphic.
Proof The proof follows the same lines of [18].	 
The relation with logic through the so-called Curry-Howard isomorphism [22], or “formulæ-as-types and proofs-as-terms” principle, has been deeply studied for the Lambda-calculus. As demonstrated in [9,3], this relation is not so clear for the Rho-calculus. The principle could be adapted for RhoF as follows:
Given a typed term A, if we can derive for A a type τ in the typed system RhoF, with a derivation ÐerT, then the term A can be seen as the coding of a logical proof, proving the formula ϕ that can be interpreted as the type τ assigned to A.
For the typed system RhoF, the current issue is to find a suitable logic that fits with the calculus. If patterns are simple variables, the logic is minimal second-order propositional logic, but in the case of more complicated patterns, much work has to be done.
For the type assignment system uRhoF the relation with logic is not so
clear even for the corresponding type assignments for the Lambda-calculus. The ‘formulæ-as-types’ principle of Curry and Howard can be extended to the above type assignment systems as follows [24]:


Given an untyped term U, if we can assign a type τ in the type assignment system uRhoF, with a derivation ÐerU, then:
ÐerU can be interpreted as the coding of a proof for the logic formulas
ϕ which corresponds to the interpretation of the type τ assigned to U ;
U can be interpreted as the coding of a “logical proof schemas”, whose instances (of the schema) prove, respectively, all the logic formulas ϕi’s that can be interpreted as the types τi’s that can be assigned to U .
Clearly, the fact that the classes of derivations for the typed system and the type assignment system are isomorphic means that they have the same un- derlying logical system.

Logical (In)Consistency.
One major requirement when associating a type system with a logic is consistency, i.e. the impossibility to write a closed term with type falsum; the term below seems to “spoof” consistency at the price of only one algebraic constant f declared in the context.
Example 5.3 [Logical Inconsistency] Let Γ = f :⊥ d ⊥ d ⊥.
Γ,X:⊥ ▶T X : ⊥
Γ,X:⊥ ▶T f : ⊥ d ⊥ d ⊥

Γ,X:⊥ ▶T f (X) : ⊥ d ⊥	Γ,X:⊥ ▶T X : ⊥

Γ ▶T f (X) d(X:⊥) X : (⊥ d ⊥) d ⊥	Γ ▶T X d⊥ X : ⊥ d ⊥

Γ ▶T (f (X) d(X:⊥) X) (X d⊥ X) : ⊥
The key point of this spoofer seems to be the contravariant position of ⊥ in the typing of f : this allows to inhabit falsum, that is, prove the inconsistency of the system. This is not surprising, since our application rule hides in the first premise a “logical-cut”, e.g. here the assumption X : ⊥ is forgotten.

Recovering Consistency.
Below, we propose a well-known restriction, due to Mendler [25] that would block the counterexample to the Strong Normalization (Example 3.7), and the counterexample to the Logical Consistency (Example 5.3). The consistency of the system is guaranteed by shrinking the set of typable terms. Mendler has shown that, when introducing recursive definitions in the typed Lambda- calculus, strong normalization is no longer enforced by typing if the type


constructors do not satisfy a “positiveness condition”. This kind of condition is still present in the Calculus of Inductive Constructions which is the basis of the Coq proof assistant. The issue appears in programming languages too: for instance, in ML, one can define any recursive function without using the keyword let rec.
As simple modification in both RhoF and uRhoF can restrict the (Type·Arrow) as follows:
Γ ▶T τ1 : ∗  Γ ▶T τ2 : ∗  if τ2 ≡ τ 1 d ... τn d α then α > 0 in τ1

2	2
Γ ▶T τ1 d τ2 : ∗
(Type·Arrow')

where α > 0 in τ1 if:
α does not occur in τ1;
or τ1 = τ 1 d τ 2 where α does not occur in τ 1 and α > 0 in τ 2.
1	1	1	1
This positiveness condition is the price to pay in order to have a sound logical system.
Conjecture 5.4 (Consistency)
For RhoF and uRhoF (with the rule (Type·Arrow')) and every closed A and U, and for a suitable Γ giving meaning to the algebraic constants of A and U, respectively, the following holds: Γ /▶T A : ⊥, and Γ /▶U U : ⊥.
The above conjecture left open another conjecture about the existence of a powerful logic that checks the shape of the proofs/terms (inhabitants of formulæ/types) via pattern-matching before applying a cut/application rule.

Conjecture 5.5 (Polymorphic Rho-gic) We conjecture that there exists a logical system underneath RhoF and uRhoF based on pattern-matching.
It would be worthy to explore Meseguer’s Conditional Rewriting Logic [26].

Related Work and Conclusions
In this paper we presented two systems, the Fully-typed Polymorphic Rho- calculus (RhoF) and the Type Inference Polymorphic Rho-calculus (uRhoF): both systems enjoy subject reduction of typable terms. RhoF also enjoys the decidability of type checking and of type reconstruction.
Because of the decidability of type-checking in RhoF, customizing an ex- isting rewriting-language with polymorphic-types seems an interesting altern- ative to validate code without limiting code expressiveness. From the point of view of type inference, the main motivation, in introducing uRhoF, is to


find an easy way to validate code of many existing lines of rewriting-based algorithms via static analysis.
We also discussed the problematic of finding a suitable consistent logic that corresponds to the two systems via the Curry-Howard isomorphism.
The next question in our agenda is to study a variant of uRhoF (called
uRhoFmlet ) featuring a restricted form of polymorphism a` la Damas-Milner-
Tofte and to customize of the well-known algorithm W of Damas-Milner [15],
conjecture (ii) of Exercise pp. 14 in [10].

Acknowledgments.
The authors are sincerely grateful to Claude Kirchner for many fruitful discussions and invaluable comments about this work, and the anonymous referees for their extremely useful comments.

References
H. Barendregt. Lambda Calculus: its Syntax and Semantics. North Holland, 1984.
H. Barendregt. Lambda Calculi with Types. In Handbook of Logic in Computer Science, volume II, pages 118–310. Oxford University Press, 1992.
G. Barthe, H. Cirstea, C. Kirchner, and L. Liquori. Pure Patterns Type Systems. In Proc. of POPL, pages 250–261. The ACM press, 2003.
M. Clavel, F. Dur´an, and N. Mart´ı-Oliet. Polytypic Programming in Maude. In Proc. of WRLA. ENTCS, 2000.
H.B. Curry and R. Feys. Combinatory Logic, volume 1. North-Holland, Amsterdam, 1958.
H. B. Curry, J. R. Hindley, and J. P. Seldin. Combinatory Logic, volume 2. North-Holland, Amsterdam, 1972.
H. Cirstea. Rewriting Calculus: Foundations and Applications. PhD thesis, Universit´e Henri Poincar´e - Nancy I, 2000.
H. Cirstea, C. Kirchner, and L. Liquori. Matching Power. In Proc. of RTA, volume 2051 of
LNCS, pages 77–92. Springer-Verlag, 2001.
H. Cirstea, C. Kirchner, and L. Liquori. The Rho Cube. In Proc. of FOSSACS, volume 2030 of LNCS, pages 166–180, 2001.
H. Cirstea, C. Kirchner, and L. Liquori. Rewriting Calculus with(out) Types. In Proc. of WRLA, volume 71 of ENTCS, 2002.
H. Cirstea, C. Kirchner, L. Liquori, and B. Wack. The Rho Cube : Some Results, Some Problems. In Proc. of HOR, 2002. Also as LORIA Research Report A02-R-470.
H. Cirstea, L. Liquori, and B. Wack. Rho-calculus with Fixpoint: First-order System. In Proc. of TYPES. Springer-Verlag, 2004.
M. Clavel and J. Meseguer. Reflection in Conditional Rewriting Logic. Theoretical Computer Science, 285(2):245–288, 2002.
H.B. Curry. Functionality in Combinatory Logic. In Proc. Nat. Acad. Sci. U.S.A., volume 20, pages 584–590, 1934.



L. Damas and R. Milner. Principal Type-Schemes for Functional Programs. In Proc. of POPL, pages 207–212. The ACM Press, 1982.
F. Dur´an and J. Meseguer. Parameterized Theories and Views in Full Maude 2.0. In Proc. of WRLA. ENTCS, 2000.
K. Futatsugi and A. Nakagawa. An Overview of Cafe Project. In Proc. of CafeOBJ Workshop, 1996.

P. Giannini, F. Honsell, and S. Ronchi della Rocca. Type Inference: Some Results, Some Problems. Fundamenta Informaticae, 19((1,2)):87–126, 1993.
J.Y. Girard. The System F of Variable Types, Fifteen Years Later. Theoretical Computer Science, 45:159–192, 1986.
J. Goguen. The OBJ Family Home Page, 2004.
http://www.cs.ucsd.edu/users/goguen/sys/obj.html.
P. Giannini and S. Ronchi della Rocca. Characterization of Typings in Polymorphic Type Discipline. In Proceedings of the Third Annual Symposium on Logic in Computer Science, pages 61–70, 1988.
W. Howard. The formulas–as–types notion of construction. In Essays on Combinatory Logic, Lambda Calculus, and Formalism, pages 479–490. Academic Press, 1980.
D. Leivant. Polymorphic Type Inference. In Proc. of POPL, pages 88–98. The ACM Press, 1983.
L. Liquori. Type Assigment Systems for Lambda Calculi and for the Lambda Calculus of Objects. PhD thesis, University of Turin, 1996.
N. P. Mendler. Inductive Deﬁnition in Type Theory. PhD thesis, Cornell University, Ithaca, USA, 1987.
Jos´e Meseguer. Conditional Rewriting Logic: an Unified Model of Concurrency. Theoretical Computer Science, 96(1):73–155, 1992.
Microsoft. The C# Home Page, 2004.
http://msdn.microsoft.com/vcsharp/ .
A. Miquel.  Le Calcul des Constructions Implicite: Syntaxe et S´emantique.  PhD thesis, Universit´e Denis Diderot, Paris 7, 2001.
Narciso Mart´ı-Oliet and Jos´e Meseguer.	Rewriting Logic: Roadmap and Bibliography.
Theoretical Computer Science, 285(2):121–154, 2002.
Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. The Deﬁnition of Standard ML (Revised). MIT Press, 1997.
S. Peyton Jones. The Implementation of Functional Programming Languages. Prentice Hall, 1987.
M.-O. Stehr. Programming, Speciﬁcation and Interactive Theorem Proving – Towards a Uniﬁed Language based on Equational Logic, Rewriting Logic and Type Theory. PhD thesis, Universit¨at Hamburg, Fachbereich Informatik, 2002.
Sun. Java Technology, 2004. http://java.sun.com/.
The Cristal Team. The Objective Caml Home Page, 2003.
http://www.ocaml.org/.
The GNU Prolog Team. The GNU Prolog Home Page, 2003.
http://pauillac.inria.fr/~diaz/gnu-prolog/ .
The	Asf+Sdf	Team.	The	Asf+Sdf	Meta-Environment	Home	Page,	2004.
http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/MetaEnvironment.



The Haskell Team. The Haskell Home Page, 2004.
http://www.haskell.org/.
The Maude Team. The Maude Home Page, 2004.
http://maude.cs.uiuc.edu/.
The Protheo Team. The Elan Home Page, 2004.
http://elan.loria.fr.
The Scheme Team. The Scheme Language, 2004.
http://www.swiss.ai.mit.edu/projects/scheme/.
A. van Deursen, J. Heering, and P. Klint. Language Prototyping. World Scientific, 1996.
V. van Oostrom. Lambda Calculus with Patterns. Technical Report IR-228, Faculteit der Wiskunde en Informatica, Vrije Universiteit Amsterdam, 1990.
J. B. Wells.  Typability and Type Checking in System F are Equivalent and Undecidable.
Annals of Pure and Applied Logic, 98(1–3):111–156, 1999.
