Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 280 (2011) 69–80
www.elsevier.com/locate/entcs

Bounded Retransmission in Event-B CSP: a Case Study
Steve Schneider1 Helen Treharne2
Department of Computing, University of Surrey Guildford, Surrey, UK
Heike Wehrheim3
Institut fu¨r Informatik, Universit¨at Paderborn Paderborn, Germany

Abstract
Event-B  CSP is a combination of Event-B and CSP in which CSP controllers are used in conjunction with Event-B machines to allow a more explicit approach to control flow. Recent results have provided an approach to stepwise refinement of such combinations. This paper presents a simplified Bounded Retrans- mission Protocol case study, inspired by Abrial’s treatment of this example, to illustrate several aspects new in the approach. The case study includes refinement steps to illustrate four different aspects of this ap- proach to refinement: (1) splitting events; (2) introducing convergent looping behaviour; (3) the relationship
between anticipated, convergent, and devolved events; and (4) converging anticipated events.
Keywords: Event-B, CSP, Bounded Retransmission Protocol, Stepwise Refinement


Introduction
This paper presents a case study illustrating a refinement chain in a combination of CSP [7] and Event-B [6,1]. The case study is inspired by Abrial’s treatment of the Bounded Retransmission Protocol [1], which was based on [4]. The approach is founded on the Event-B approach to stepwise refinement, in which additional detail is introduced at each stage, in particular new aspects of the state. New events need careful introduction, to relate to previous events and to control when they can occur. Our approach uses CSP rather than control variables in Event-B to manage the control flow of events in an explicit and visible way.

1 Email: s.schneider@surrey.ac.uk
2 Email: h.treharne@surrey.ac.uk
3 Email: wehrheim@mail.uni-paderborn.de

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.11.019

In Event-B, there are proof obligations at each stage to establish the validity of the refinement. The introduction of CSP allows some of the burden of proof to be handled within the CSP framework. In particular, those obligations concerned with flow of control can be discharged more easily with refinement checks. Establishing properties such as trace refinement and divergence-freedom for a model now allow a degree of automation. The technical details of this approach are given in [9,8]. The intention of this paper is to illustrate the kind of refinement steps that are now supported, and to provide an example of the approach.

CSP Background
CSP is a process algebra, which describes systems in terms of communicating com- ponents with particular attention to the interactions between them. Components consist of processes, which perform patterns of events, and which communicate by synchronising on events.
CSP provides a language to describe processes. STOP is the process that can perform no events. RUN (A) can perform any sequence of events from the set of events A. The prefix process a → P is initially ready to perform event a, and its subsequent behaviour is that of process P . The external choice P 2 Q is a choice between process P and process Q . The parallel composition P  Q is the parallel combination of P and Q : they synchronise on events that they have in common, and can perform other events independently. The interleaved composition P ||| Q is a parallel combination of P and Q where they execute independently and do not synchronise on any events. The abstraction process P \ A behaves as P except that events in A are hidden: they are executed internally, and are no longer in the interface of P . Finally, a mapping f from one set of events to another can be used to rename alphabets: f (P ) is an alphabet renaming of P whereby f (P ) can perform f (a) whenever P can perform a; similarly, f −1(P ) can perform a whenever P can perform f (a).
CSP also provides a variety of semantic models. In this paper we are primarily concerned with the traces model, which associated each process with a set of traces (sequences of events) that they can perform during some execution. The set of all possible traces of a process P is denoted traces(P ). Process P is trace reﬁned by process Q if any trace of process Q is also a trace of process P . This is written P ±T Q .
In this paper we are also concerned with divergence. A process diverges if it can perform an infinite sequence of internal events at some point. We generally aim to establish that processes do not diverge, and will make use of results for establishing divergence-freedom.
There are model-checking tools for CSP, such as FDR [3] and ProB [5]. These al- low automated checking of refinement claims P ±T Q , and also divergence-freedom checking for CSP processes, as well as other checks. All of the CSP proof obliga- tions in this paper can be checked using FDR. A fuller explanation of CSP and its semantics can be found in [7].

Refinement principles of Event-B CSP

Event-B [1] models systems in terms of machines with state, and with events which update the state. Refinement between machines involves data refinement of existing events, and can also introduce new events.
In Event-B, when new events Ni+1 are introduced in Mi+1, they can be assigned a status of ‘convergent’ or ‘anticipated’. Furthermore, events which refine antic- ipated events of Mi can also be assigned a status of convergent or anticipated in Mi+1. Events which refine either convergent events or events without a status, are not assigned a status. Proof obligations arising from the status of events are that convergent events must decrease the variant of Mi+1; and anticipated events must not increase it. We will write Mi “ Mi+1 when the standard Event-B data refine- ment proof obligations hold between Mi and Mi+1, and so do the proof obligations on convergent and anticipated events.
In Event-B  CSP, we deal with controlled components consisting of a non-divergent CSP process Pi , and an Event-B machine Mi , synchronising on their common events. The semantic foundation for this combination is given in [8].
A refinement step introduces a new non-divergent process Pi+1 such that Pi ±T Pi+1, and a new machine Mi+1 such that Mi “ Mi+1. Events of Mi+1 are present for one of two reasons:
They may be refinements of events of Mi , with either the same name or a different name (this includes events which are exactly the same in each level). Refinement events give rise to a mapping fi+1 which maps events of Mi+1 to events of Mi . The mapping is obtained from the refines clauses of event definitions, where ainMi+1 refines fi+1(a)inMi . Note that Event-B allows one event in Mi+1 to refine several in Mi in the most general case, but here we allow an event to refine at most one other.
They may be new events that do not refine any event in Mi . The new events for Mi+1 will be denoted by Ni+1.
We extend Abrial’s approach to the use of convergent and anticipated status by introducing an additional status: ‘devolved’. Further, to support reasoning about divergence-freedom (i.e. that the system does not diverge when the new events are hidden), we will require all newly introduced events to be given a status, and all refinements of anticipated events to be given a status. A devolved event is treated similarly to an anticipated event, but in the context of Event-B  CSP, responsibility for ensuring its convergence is devolved to the CSP controller Pi+1 rather than delayed to some future refinement step as anticipated events are. Hence events that refine devolved events will not be assigned a status, in contrast to those refining anticipated events. Thus in Mi+1 the only events with a status (convergent, anticipated, or devolved) are newly introduced events Ni+1 and those that refine Mi ’s anticipated events. Figure 1 shows the events that we will use in our case study at the various refinement levels, with the mappings fi also shown. Convergent, anticipated, and devolved events are labelled with (c), (a), and (d) respectively.
















Fig. 1. Events introduced through the development


To establish the refinement relation, several proof obligations must be dis- charged:
We require Mi “ Mi+1: the Event-B refinement relation holds between Mi and
Mi +1.
We require f −1 (Pi ) ||| RUN (Ni+1) ±T Pi+1. If Ni+1 = ∅ then this is equivalent to f −1 (Pi ) ±T Pi+1, also equivalent to Pi ±T fi+1(Pi+1).
It follows from Theorem 5.4 of [9] that a sequence of refinement steps from P0  M0 to Pn  Mn , discharging these two obligations at each level, establishes the following relationship:
(P0  M0) ±T f ((Pn  Mn ) \ N )


  

Fig. 2. Level 0: Machine M0 events and control process P0

where f = fn ; ... ; f1 is the composition of the event renamings, and N = Nn ∪ f −1(Nn−1) ∪ ... ∪ (fn ; ... ; f2)−1(N1) is the set of all the new events introduced in the refinement steps, appropriately renamed.
To obtain divergence-freedom, we use a third proof obligation, to establish that the CSP controller does not allow devolved events to diverge:
Devolved events (like anticipated events) must not increase the variant. The additional proof obligation on devolved events (unlike anticipated events) is that if Di+1 is the set of all devolved events in Mi+1, then Pi+1 \ Di+1 must be divergence-free.
It follows from Corollary 5.18 of [9] that if Mn contains no anticipated events, then the combination (Pn  Mn ) \ N is divergence-free.

Bounded Retransmission Protocol
This case study illustrates the transfer of a file by sending data packets over an unreliable medium. CSP is used to describe the repetitious behaviour in the sender (repeated transmission, and progress through the file) and the receiver (progressive receipt of the data packets), whereas the Event-B part of the model focuses on the state. For the purposes of this case study we focus only on the unreliability of the transmission medium, allowing reliable acknowledgements.

Level 0
In the initial level, given in Figure 2, we see the CSP controller split into a sender controller and a receiver controller. We begin with Abrial’s model, with a single sender and a single receiver event. The event brp occurs after the protocol has completed.


 


Fig. 3. Level 1: Machine M1 events and control process P1

Level 1
In the first refinement step the progress events are split into success and failure events, and an additional requirement on the relationship between the sender’s and the receiver’s final state is introduced. The resulting machine and controller are given in Figure 3. The associated renaming function is
f1(SND success)= f1(SND failure)= SND progress f1(RCVsuccess)= f1(RCVfailure)= RCVprogress
f1(brp)= brp
There are no new events at this level.
Then P0 ±T f1(P1). Also each event a of M1 has that a refines f1(a). Hence
P0  M0 ±T f1(P1  M1)



Fig. 4. Level 2: Machine M2 new and altered events, and control process P2
Level 2
In the second refinement step, we introduce the data file p : 1..n → D to be transferred. Reception of data packets will be modelled with a new convergent event in the receiver part of the description, and an adjustment to RCVsuccess, with all other events remaining unchanged. A loop is introduced into the CSP controller.
Observe that in this case it is the convergence of the B event that ensures that the new event cannot occur indefinitely.
N2 is the set of events that have been newly introduced at this level. There is only one such event:
N2 = {RCVrcv current data}
No event renaming has occurred, so f2 will be the identity function and can be ignored. In fact this will be the case with all subsequent refinement levels.
The new event introduced for M2, and the event strengthened from M1 and M2, are given in Figure 4, along with the control process P2.
Then P1 ||| RUN (N2) ±T P2.
Hence (P1  M1) ||| RUN (N2) ±T (P2  M2).
Level 3
In the third refinement step, we make use of the new status for events in controlled components: ‘devolved’. We introduce new events into the sender controller: a devolved event, a convergent event, and an anticipated event. We also refine two of


Fig. 5. Level 3: Machine M3 new and changed events

the receiver events. These are given in Figure 5. All other events remain unchanged. We also introduce a data channel db which is set and reset by the sender when sending data.
The CSP controller, shown in Figure 6, is used to manage the flow of events in the sender. In the pure Event-B version [1], an additional control variable is needed to manage the interaction between the sender events. Here, the relationship between their occurrence is given explicitly in S3.
The requirement M2 “ M3 requires that SNDrcvcurrack decreases the variant V3, that SNDtimeout does not increase V3, and that the strengthened receiver events are appropriate refinements. We must also show that the devolved event SNDsnddata does not increase V3.
Then P2 ||| RUN (N3) ±T P3, where
N3 = {SND snd data , SND rcv curr ack , SND timeout}
Observe also that P3 \ D3 is divergence-free, where D3 = {SND snd data}.
Thus (P2  M2) ||| RUN (N3) ±T (P3  M3).



Fig. 6. Level 3: Control process P3
Level 4
In the final refinement step, we refine the anticipated event SNDtimeout by a convergent event. This is achieved by introducing a counter variable c which places a bound on the number of times the SND timeout event can occur without receiving an acknowledgement.
We also model the unreliability of the data channel by introducing the new event DMNdatachannel corresponding to loss of data. The new event and the changed events are given in Figure 7.
At this level, the timeout is refined to a convergent event. Also, the new event DMNdatachannel, which resets the data channel db, is convergent. All events in M3 are refined by their corresponding events in M4. Hence M3 “ M4. Thus (P3  M3) ||| RUN (N4) ±T (P4  M4).
Reﬁnement chain
Finally, we consider the whole chain of refinements from P0  M0 to P4  M4.
The set of all new events introduced is given by N = N2 ∪ N3 ∪ N4. The relationship between the initial and final levels is:
P0  M0 ±T f1((P4  M4) \ N )
Further, there are no anticipated events left in M4. Hence (P4  M4) \ N is divergence-free.
Discussion
This paper has shown the development of a simple bounded retransmission pro- tocol in Event-B  CSP through a chain of refinement steps. Each step illustrates a refinement rule underpinned by the Event-B  CSP semantics. The result is a description of the protocol with a clear relationship to the original specification. Further, though not considered explicitly in this paper, the protocol transmitting the file is also deadlock-free prior to completing the file transfer. Establishing this requires rules concerned with failures refinement or deadlock-freedom beyond the scope of this paper, and will be addressed in a subsequent paper.
Our example has been chosen in part to enable comparison with the pure Event- B approach taken in [1]. We believe that inclusion of the CSP controllers alongside





Fig. 7. Level 4: Machine M4 new and changed events, and control process P4





the Event-B description has allowed a clearer and more natural expression of the flow of control of events, particularly with respect to the timeout and repeated transmission of the data. It also allows for simpler event descriptions in the Event- B machine, since control variables in event guards and assignments can be removed where their effect is now taken care of by the CSP controller. For example, in the pure Event-B version, at Level 3 there are several control bits w , ab, db, which are set and reset by events, and are used within event guards, to manage the flow of control. In any state, no more than one of them can have the value 1. Thus the event SNDsndcurrentdata is given as follows:



Here we see that the control value w = 1 is used (alongside other conditions) to guard this event. After the event occurs w is set to 0, and a different control value db is set to 1. This results in different events being enabled and gives rise to a flow of control. The equivalent event in our example, SNDsnddata, appears explicitly in the CSP control process S3 in Figure 6. Its place in the overall flow of control is more readily apparent: it either leads to success or failure, or else to an acknowledgement or timeout which reactivates it. In our view the overall behaviour of the system is easier to understand. The cost of this benefit is the need to reconcile two formalisms, and some overhead in ensuring consistency between them.
In terms of tool support available for the approach, one notable model-checking tool that checks combinations of CSP with Event-B (and also classical B) is ProB [5], which allows Event-B machines with CSP controllers to be explored for consistency. Results from this form of model-checking augment our approach, since it supports the verification of machine invariants under CSP controllers, even if the machine in isolation is not consistent. Our rules for establishing consistency do not yet cover this case, since they require consistency of the Event-B machine. ProB also supports refinement checking of combinations, though currently this is practicable only on small examples. Alongside ProB, support for the approach will also come from Event-B tools such as the RODIN platform [2], and from CSP tools such as FDR [3] which can be used to check the proof obligations on the CSP controllers.
Acknowledgement
We are grateful to the anonymous reviewers for their constructive comments.
References
Abrial, J.-R., “Modeling in Event-B: System and Software Engineering,” Cambridge University Press, 2010.
Abrial, J.-R., M. J. Butler, S. Hallerstede, T. S. Hoang, F. Mehta and L. Voisin, Rodin: an open toolset for modelling and reasoning in Event-B, STTT 12 (2010), pp. 447–466.
Formal Systems (Europe) Ltd., The FDR model checker, http://www.fsel.com/ (accessed 8/3/11).


Groote, J. F. and J. van de Pol, A bounded retransmission protocol for large data packets, in: AMAST, 1996, pp. 536–550.
Leuschel, M. and M. J. Butler, ProB: an automated analysis toolset for the B method, STTT 10 (2008),
pp. 185–203.
M´etayer, C., J.-R. Abrial and L. Voisin, Event-B language (2005), RODIN Project Deliverable 3.2,
http://rodin.cs.ncl.ac.uk/deliverables/D7.pdf, accessed 25/5/10.
Schneider, S., “Concurrent and Real-time Systems: The CSP approach,” Wiley, 1999.
Schneider, S., H. Treharne and H. Wehrheim, A CSP approach to control in Event-B, in: IFM, 2010,
pp. 260–274.
Schneider, S., H. Treharne and H. Wehrheim, Stepwise refinement in Event-B CSP. Part 1: Safety, Technical Report CS-11-03, University of Surrey (2011).
