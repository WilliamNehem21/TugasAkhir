 Electronic Notes in Theoretical Computer Science 96 (2004) 153–172 
www.elsevier.com/locate/entcs




Weak Bisimilarity and Regularity of Context-Free Processes is EXPTIME -hard

Richard Mayr
Department of Computer Science Albert-Ludwigs-University Freiburg
Georges-Koehler-Allee 51, D-79110 Freiburg, Germany.
E-mail: mayrri@informatik.uni-freiburg.de

Abstract
We show that checking weak bisimulation equivalence of two context-free processes (also called BPA-processes) is EXPTIME -hard, even under the condition that the processes are normed. Fur- thermore, checking weak regularity (finiteness up to weak bisimilarity) for context-free processes is EXPTIME -hard as well. Adding a finite control of the minimal non-trivial size of 2 to the BPA process already makes weak bisimilarity undecidable.
Keywords: Context-free processes, BPA, pushdown automata, bisimulation

Introduction
Bisimulation equivalence plays a central role in the theory of process algebras [12]. The decidability and complexity of bisimulation problems for infinite- state systems has been studied intensively (see [2,16] for surveys). Here we consider the complexity of checking weak and strong bisimulation equivalence for several subclasses of pushdown automata (PDA). BPA (Basic Process Al- gebra; also called context-free processes) are equivalent to the subclass of pushdown automata where the finite control has size 1. The subclasses of
normed PDA and BPA (denoted as nPDA and nBPA) satisfy the additional
condition that from every reachable configuration it is possible to empty the stack. A normed PDA/BPA is called totally normed if the stack can always be emptied, but not by internal τ -actions alone.


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.026

The state of the art: Strong bisimilarity was shown to be decidable for normed PDA by Stirling [21], and later for general PDA by S´enizergues [14].
However, no upper complexity bound for this problem is known so far. The best known lower bound is EXPTIME -hardness [8], which holds even for (to- tally) normed PDA. Weak bisimulation equivalence for (normed) PDA is un-
decidable [20].
The best known algorithm for strong bisimilarity of BPA requires dou- bly exponential time (and space) [3], while the best known lower bound is PSPACE -hardness [18]. However, strong bisimilarity of normed BPA is de-
cidable in polynomial time [6]. The decidability of weak bisimilarity for BPA is an open question. The undecidability proof for PDA does not carry over to BPA, and it is widely conjectured that this problem is decidable for BPA. It is known that weak bisimilarity is decidable for the subclass of totally normed BPA [5]. The best known lower bound for weak bisimilarity of general BPA
was PSPACE -hardness [23], while the best lower bound for weak bisimilarity
of (totally) normed BPA was only NP-hardness [23].
Our contribution. We show that weak bisimilarity of BPA is EXPTIME - hard, even for normed BPA. Then we use this result to show that the problem
of deciding if a given BPA is weakly regular (finite up to weak bisimilarity) is also EXPTIME -hard. This improves a previously known PSPACE lower bound [18]. Furthermore, we show that adding a finite control of the minimal
size of 2 to the BPA process already makes weak bisimilarity undecidable.


Definitions
BPA processes correspond to pushdown automata with a finite control of size 1. They can be described by (1, S)-PRS in the framework of process rewrite systems (PRS) [10].  Let Act = {τ } ∪ {a, b, c,.. .} and Const =
{ϵ} ∪ {X, Y, Z,.. .} be disjoint countably infinite sets of actions and process constants, respectively. The action τ is a special ‘silent’ internal action and the special constant ϵ denotes the empty term. The class of sequential process expressions S is defined by E  ::=  X | E.E, where X ∈ Const and ‘.’ is
a binary operator of sequential composition. We do not distinguish between expressions related by structural congruence which is given by the following laws: ‘.’ is associative and ‘ϵ’ is a unit for ‘.’. (In particular it follows that ϵ.E = E).

A BPA is a finite set ∆ of rules which have the form X →a
E, where

X ∈ Const − {ϵ}, E ∈ S, a ∈ Act . Const (∆) and Act (∆) denote the sets of
process constants and actions which are used in the rules of ∆, respectively (note that these sets are finite).

Each BPA ∆ defines a unique labeled transition system where states are process expressions. Act (∆) is the set of labels. The transitions are deter- mined by ∆ and the following inference rules:

(E →a
F ) ∈ ∆
E → E'

E → F
E.F →
E'.F

We extend the notation E →a  F to elements of Act ∗ in a standard way.

Moreover, we say that F is reachable from E if E →w
F for some w ∈ Act ∗. A 

BPA-process (α, ∆) is given by an expression α ∈ S and a set of rules ∆. ∆ is omitted if it is clear from the context. The length of a string of symbols α is denoted by |α|.
Definition 2.1 The norm  α  of a BPA-process α is defined as the length of the shortest derivation sequence from α to ϵ, not counting τ -moves. A BPA
∆ is normed if for every X in Const(∆) we have 0 ≤  X  < ∞. A BPA ∆ is totally normed if for every X in Const(∆) −{ϵ} we have 0 <  X  < ∞. We denote the classes of normed BPA, totally normed BPA and normed PDA
processes by nBPA, tnBPA and nPDA, respectively.
We consider the semantic equivalences weak bisimilarity and strong bisim- ilarity [12] over labeled transition systems (e.g., those generated by BPA).
a	a
Definition 2.2 The extended transition relation ‘⇒’ is defined by E ⇒ F iff

either E = F and a = τ , or E τi
E' →a
E'' τj
F for some i, j ∈ N0. A binary

relation R over states in a labeled transition graph is a weak bisimulation
iff whenever (E, F ) ∈ R then for every a ∈ Act : if E →a E' then there is
F ⇒a F ' s.t. (E',F ') ∈ R and if F →a F ' then there is E ⇒a E' s.t. (E',F ') ∈
R. States E, F are weakly bisimilar, written E ≈ F , iff there is a weak
bisimulation relating them. (Sometimes weak bisimulation is defined with ⇒
instead of → everywhere. However, the two definitions are equivalent.) Strong
a	a
bisimulation is defined similarly with → instead of ⇒ everywhere. E, F are
strongly bisimilar, written E ∼ F , iff there is a strong bisimulation relating them.
Sometimes the following game theoretic characterization of bisimulation is more useful for reasoning about it. Bisimulation equivalence can be described by bisimulation games [22] between two players. One player, the ‘attacker’,
tries to prove that two given processes are not bisimilar, while the other player, the ‘defender’, tries to frustrate this. In every round of the game the attacker chooses one process and performs an action. The defender must imitate this move and perform the same action in the other process (possibly together with several internal τ -actions in the case of weak bisimulation). If one player

cannot move then the other player wins. The defender wins every infinite game. Two processes are bisimilar iff the defender has a winning strategy and non-bisimilar iff the attacker has a winning strategy.
We consider the problem of weak bisimulation equivalence of normed context- free processes (nBPA).
nBPA ≈ nBPA (Weak bisimilarity of normed BPA)
Instance: A set of BPA rules ∆ and two normed processes α and α'.
Question: (α, ∆) ≈ (α', ∆) ?
We show an EXPTIME -lower bound for this problem by a polynomial-time reduction from the EXPTIME -complete acceptance problem of alternating linear-bounded automata (alternating LBA).
Definition 2.3 An alternating LBA (alternating linear-bounded automaton)
[4] is a tuple ł = (S, Σ, γˆ, γ, s0, ▶, E, π) S is a finite set of control-states, s0 is the initial control-state, Σ is the set of tape symbols, ▶, E ∈ Σ are the left-end and right-end markers, respectively (▶ and E cannot be overwritten or moved), and π : S → {6, E, acc, rej } is a function which partitions the control states of S into universal, existential, accepting, and rejecting, respectively. The com- putation step function γˆ : S ×Σ → 2S×Σ×{−1,0,1} takes as input a control-state and the symbol under the head and returns a set of possible steps containing
each: a new control state, the symbol to be written and the instruction where to move the head (left, same place, right). For a more convenient notation we define the function γ as the restriction of γˆ to the (successor) control-states,
i.e., γ : S × Σ → 2S with γ(s, A) := {s' ∈ S | EB, x. (s', B, x) ∈ γˆ(s, A)}.
We assume (w.l.o.g.) that γ has the following properties:
for all s ∈ S and A ∈ Σ such that π(s) = 6 or π(s) = E we have that
|γ(s, A)| = 2 (i.e., γ(s, A) = {s1, s2} for some s1, s2 ∈ S). The first element of γ(s, A) is denoted by first (s, A), and the second one by second (s, A). It
means that each configuration of ł where the control state is universal or existential has exactly two immediate successors (configurations reachable in one computation step).
for all s ∈ S and A ∈ Σ such that π(s) = acc or π(s) = rej we have that γ(s, A) = ∅, i.e., each configuration of ł where the control state is accepting or rejecting is ‘terminated’ (without any successors).
A computation tree for ł on a word w ∈ Σ∗ is a finite tree T satisfying the following: the root of T is (labeled by) the initial configuration s0▶wE of ł, and if N is a node of ł labeled by a configuration usv where u, v ∈ Σ∗ and s ∈ S, then the following holds:
if s is accepting or rejecting, then T is a leaf;

if s is existential, then T has one successor whose label is one of the two configurations reachable from usv in one step (here, the notion of a compu- tation step is defined in the same way as for ‘ordinary’ Turing machines);
if s is universal, then T has two successors labeled by the two configurations reachable from usv in one step.
ł accepts w iff there is a computation tree T such that all leaves of T are accepting configurations. The acceptance problem for alternating LBA is known to be EXPTIME -complete [4].
Remark 2.4 We assume that all branches of a computation tree of an al- ternating LBA M on an input word w have a finite length, which is at most exponential in |w|. This is no restriction, since there are at most |Σ||w||S||w| different configurations. For any alternating LBA M one could construct an
equivalent one with the required property by counting the number of compu- tation steps on the tape (using only linear space).

The Idea
We prove EXPTIME -hardness of the nBPA ≈ nBPA problem by a reduction of the acceptance problem of alternating LBA to it. First, we describe the general ideas of our construction in an informal way.
For an alternating LBA M = (S, Σ, γˆ, γ, s0, ▶, E, π) with input word w (of length n) we construct in polynomial time a normed BPA ∆ and two processes α and α' s.t. M accepts w iff α /≈ α'. Thus we reduce the EXPTIME - complete problem of alternating LBA acceptance [4] to weak non-bisimilarity of BPA processes. This shows EXPTIME -hardness of weak bisimilarity of BPA processes, since the class EXPTIME is closed under complement.
We represent an LBA configuration as a sequence usv where u ∈ Σ∗ is the content of the tape to the left of the head, s is the control-state, and v ∈ Σ+ is the content of the tape under the head and to the right of it. The construction ensures that the bisimulation game on α, α' proceeds in three phases.
Phase 1: First, a sequence of LBA configurations is pushed onto the stack in both processes. The attacker determines the tape symbols (from Σ) of these configurations and the successor control-states (from S) if the current control-state is existential. The defender determines the successor control- states (from S) if the current control-state is universal. (This is achieved by an application of the so-called ‘existential quantification technique’ (also called ‘defender power technique’) which is due to Janˇcar [7]; a more explicit formulation is due to Srba [17].) This construction does not guarantee that this sequence of configurations really is a correct branch of a computation

tree of the LBA. However, the rest of the construction ensures that the attacker can win if and only if the sequence of configurations is a correct branch of a computation tree that ends in an accepting LBA configuration.
Phase 2: At an accepting LBA configuration the attacker can do the special action ‘f ’ in process α and thus enter the next phase. Action ‘f ’ is not immediately enabled in the process α'. Thus, the defender can only reply
by popping the whole content of the stack of process α' (by τ -actions) and
rebuilding the stack content (again by τ -actions). However, only incorrect branches of a computation tree of the LBA can be generated in this way. This long defender-move ends with the visible action ‘f ’. This means that if the stack content of process α (on the attacker’s side) is not a correct accepting branch of a computation tree of the LBA then the defender can make the two processes syntactically equal (and thus weakly bisimilar). Otherwise the two resulting processes will not be syntactically equal (and also not weakly bisimilar as the next phase will show).
Phase 3: In the last phase the content of the stack will be popped by char- acteristic actions for each symbol. So, in this phase, the current processes will be weakly bisimilar if and only if they are syntactically equivalent.
Thus, the only way to win for the attacker is to push a sequence of LBA configurations onto the stack that represents a correct accepting branch of a computation tree of the LBA. If the attacker can do this despite the defender’s interference in choosing the successor control-states at the universal control- states, then the attacker will win. In any other case the game will either continue forever, or the defender can make the two processes syntactically equal and so the defender will win. Thus, the attacker can win iff M accepts w.

The Construction
For an alternating LBA M = (S, Σ, γˆ, γ, s0, ▶, E, π) with input word w (of length n), we construct (in polynomial time) a normed BPA ∆ with Γ := Const (∆) and Act := Act (∆) and processes α, α' s.t. ł accepts w iff α /≈ α'. We represent an LBA configuration as a sequence usv where u ∈ Σ∗ is the content of the tape to the left of the head, s is the control-state, and v ∈ Σ+ is the content of the tape under the head and to the right of it.
The set of constants Γ of the BPA is defined as
Γ := T ∪ Σ ∪ S ∪ {B, C, G, F }
where T (the top symbols) is a set of additional constants that occur only at the top of the stack in the processes α and α'. T is defined as follows: Let S' :=

{s' | s ∈ S}. T := T1 ∪ T2 ∪ T3 ∪ T4 ∪ T5 ∪ T6 ∪ T7, where T1 := S ×{0,... ,n − 1}
(used in process α for pushing new LBA configurations. LBA control-state and number of symbols pushed already), T2 := (S ×Σ)×{1,..., n} (used in process α for pushing new LBA configurations. LBA control-state, tape symbol under the head and number of symbols pushed already), T3 := S' × {0,... ,n − 1} (like T1, but for process α'), T4 := (S' × Σ) × {1,..., n} (like T2, but for process α'), T5 := {(s˜, 0) | s ∈ S} (used in choosing the successor control- state), T6 := (S ×S)×{0} (used to store two possible successor control-states), T7 := {(E, j, i) | 1 ≤ j ≤ |ERROR|, 0 ≤ i ≤ n − 3} (used by the defender player in phase 2 to push a sequence of LBA configurations with a least one error onto the stack). (The set ERROR will be defined later.)
For every state s ∈ S, the states s' and s˜ are seen as being associated to
s. Act := Σ ∪ S × Σ ∪ S ∪ {a, b, c, f, τ }.
The initial configurations α, α' are defined as follows: α := ((s0, A), n)s0wB and α' := ((s' , A), n)s0wB where A ∈ Σ is the first symbol of w (i.e., w = Aw' for some w'). This means that we start with the first configuration s0w al- ready on the stack. B is the bottom-symbol. The first symbol ((s0, A), n) encodes the facts that the LBA control-state is s0 and A is the symbol under the head, and the number n means that the complete configuration (of length
is present on the stack.
The set of transitions ∆ is defined in several steps. First we define the transition rules for phase 1: Intuitively, the rules 1–6 push a new configuration onto the stack. With the rules 7–8 the attacker chooses the next control-state if the current one is existential. With the rules 9–19 the defender chooses the next control-state if the current one is universal.
The weak bisimulation game starts with the processes α, α' where the first configuration is already on the stack. So the first thing that happens is the
choice of the next control-state by rules 7–8 or 9–19.



(s, i) →X
(s, i + 1)X	for all s ∈ S, X ∈ Σ, 0 ≤ i ≤ n − 2;

(s, i)
(s,Y )
→ ((s, Y ),i + 1)sY	for all s ∈ S, Y ∈ Σ, 0 ≤ i ≤ n − 1;
X

((s, Y ), i) → ((s, Y ),i + 1)X	for all s ∈ S, X, Y ∈ Σ, 0 ≤ i ≤ n − 1;

(s', i) →X
(s',i + 1)X	for all s ∈ S, X ∈ Σ, 0 ≤ i ≤ n − 2;

(s', i) (s,Y ) ((s',Y ),i + 1)sY	for all s ∈ S, Y ∈ Σ, 0 ≤ i ≤ n − 1;
((s',Y ), i) →X ((s',Y ),i + 1)X	for all s ∈ S, X, Y ∈ Σ, 0 ≤ i ≤ n − 1;
s1
((s, Y ), n) → (s1, 0)	if π(s) = E and s1 ∈ γ(s, Y );

((s',Y ), n) →s1
((s, Y ), n) →a
a
(s' , 0)	if π(s) = E and s1
(s˜1, 0)	if π(s) = 6 and s1
∈ γ(s, Y );
= first (s, Y );

((s, Y ), n) → (s˜2, 0)	if π(s) = 6 and s2 = second (s, Y );

((s, Y ), n) →a
((s ,s ), 0)	if π(s) = 6, s = first (s, Y )

1	2	1
and s2 = second (s, Y );

((s',Y ), n) →a
((s',Y ), n) →a
((s ,s ), 0) →s1
(s˜1, 0)	if π(s) = 6 and s1
(s˜2, 0)	if π(s) = 6 and s2
(s , 0)
= first (s, Y );
= second (s, Y );

1	2	1
s2
((s1, s2), 0) → (s2, 0)

s1
(s˜1, 0)
s2
(s' , 0)

(s˜1, 0) → (s2, 0)
s1
(s˜2, 0)	(s1, 0)

s2
(s˜2, 0)
(s' , 0)

Now we define the transition rules for phase 2.
In this phase we need to make it possible to generate all incorrect branches of a computation tree of the LBA. This is possible, since any incorrect branch of a computation tree can be characterized as containing at least one error in a computation step, which can be detected locally, i.e., by comparing 3 symbols of an LBA configuration with the 3 symbols at the same tape location
at the previous LBA configuration.  We now define the set ERROR that
describes all these possible errors in computations. It consists of elements of the form (err 1, err 2)i, (with err 1, err 2 ∈ (Σ ∪ S)3) that are pairs of strings of symbols that occur at the same position of successive LBA configurations.

The set ERROR contains exactly those pairs that cannot occur in correct computations of the LBA M. Thus ERROR depends on M. To define this formally, we first construct the set CORR of all correct pairs of this form, i.e., the complement of ERROR.
CORR := {(α(i)α(i+1)α(i+2), β(i)β(i+1)β(i+2)) | α →M β, 0 ≤ i ≤ n − 2}
where α, β are configurations of M (of length n + 1, since the control-state is stored as well), α(i)/β(i) is the symbol at position i of α/β and α →M β means that β is a successor-configuration of α, according to the computation of M.
ERROR := {(err 1, err 2)1,... , (err 1, err 2)m}
:= ((Σ ∪ S)3 × (Σ ∪ S)3) − CORR
Thus, |ERROR| = m ≤ (|Σ| + |S|)6.

((s, Y ), n) →τ
((s',Y ), n) →τ
f
ϵ	if π(s) = rej
ϵ	if π(s) = rej

((s, Y ), n) → C	if π(s) = acc
((s, Y ), n) → ϵ	if π(s) = acc
((s',Y ), n) →τ  ϵ	if π(s) = acc
τ
Z → ϵ	for all Z ∈ Σ ∪ S

B →τ
G →τ
τ
GB
GZ	for all Z ∈ Σ ∪ S

G → (E, j, 0)err 1	for all (err 1, err 2)j ∈ ERROR
(E, j, i) →τ  (E, j, i + 1)Z	for all Z ∈ Σ ∪ S, 0 ≤ i ≤ n − 3
τ
(E, j, n − 2) → Ferr 2	for all (err 1, err 2)j ∈ ERROR
F →τ FZ	for all Z ∈ Σ ∪ S
f
F → C
Note that a series of τ -actions by rules 26–31 can push arbitrarily long sequences of symbols onto the stack. However, by definition of the set ERROR, none of these sequences represents a correct branch of a computation tree of
the LBA M. Furthermore, this sequence of τ -actions must always end with the visible action ‘f ’ (by rule 32). Finally, we define the transitions for phase 3.
C →c ϵ


Z → ϵ	for all Z ∈ Σ ∪ S
B →b ϵ

The Proof
We assume now that the alternating LBA M, the input word w, the BPA ∆ and the processes α and α' are defined as in Section 4.
Lemma 5.1 The following properties are equivalent.
M accepts w.
Starting with processes α, α', the attacker has a strategy in the weak bisimulation game to enforce (whatever the defender does) that the game reaches a configuration of processes β = ((s, Y ), n)γB, β' = ((s',Y ), n)γB, where π(s) = acc and γ is a sequence of LBA configurations that describes a correct accepting branch of a computation tree of M.
Proof. In the process α, by the rules 1–3, LBA configurations of length n +1 are pushed onto the stack (n tape symbols plus one symbol for the control- state). The control-state of the simulated LBA is stored in the top symbol of the stack. After the control-state has been pushed (by rule 2), it is stored in
the top symbol of the stack together which the tape symbol under the head of the (simulated) LBA. Exactly the same is done in the process α' by rules 4–6. (The defender is forced to copy the attacker’s moves. In this phase the only difference between α and α' is in the top symbol of the stack.) The attacker determines which tape symbols are pushed onto the stack.
After a configuration has been pushed onto the stack, the successor control- state is determined. If the current control-state is existential (π(s) = E) then the attacker determines the successor control-state by rule 7 (or 8). The defender must imitate this move by rule 8 (or 7 resp.). If the current control- state is universal (π(s) = 6) then the attacker must apply rule 11 in process α.  In any other case (if the attacker uses rule 9 or 10 in α or rule 12 or
13 in α') the defender can make the two processes syntactically equal (by
rule 9,10,12 or 13) in the same round and wins. The defender then chooses the successor control-state by applying either rule 12 or rule 13 in α'. We now assume that the defender chose rule 12, i.e., control-state s1. The other case is symmetric. Then the top symbols of α and α' are ((s1, s2), 0) and (s˜1, 0), respectively. The attacker must now play a rule with action s1 (either 14 in α or 16 in α') which yields the new top symbols (s1, 0) and (s' , 0) of α and α', respectively. If the attacker chooses rule 15 or 17 then the two processes become syntactically equal and the defender wins. The effect of

this construction is, that at universal control-states s it is the defender who chooses between the two possible successor control-states s1 and s2.
⇒ If M accepts w then, by Definition 2.3, there is a computation tree of M on w where all branches end with an accepting leaf. By the construction above the attacker selects the tree and the defender selects the branch. By pushing only correct successor configurations of the LBA onto the stack, the attacker creates a stack content γ that corresponds to a branch in the accepting tree. The defender can only copy his moves in the other process.
Thus a configuration of processes β = ((s, Y ), n)γB and β' = ((s',Y ), n)γB
is reached, where π(s) = acc and γ is a sequence of LBA configurations that describes a correct accepting computation of M.
⇐ If M does not accept w then, by Definition 2.3, every computation tree has at least one branch that does not accept. By the construction above the defender can select the successor control-states at the universal nodes in such a way that a non-accepting branch of the computation-tree is cho- sen. Therefore, if the attacker chooses to push the right tape symbols onto the stack (s.t. a correct branch of a computation tree of M is pushed onto the stack) this will end in a rejecting configuration. However, the at- tacker might also introduce errors into the computation by pushing wrong LBA configurations onto the stack and thus reach a pair of configurations
β = ((s, Y ), n)γB and β' = ((s',Y ), n)γB, where π(s) = acc and γ is not a
correct branch of a computation tree of the LBA. In either case it is impossi- ble for the attacker to enforce a configuration of processes β = ((s, Y ), n)γB and β' = ((s',Y ), n)γB, where π(s) = acc and γ is a sequence of LBA con- figurations that describes a correct accepting branch of a computation tree
of M.

Lemma 5.2 Let γ, γ' ∈ (Σ ∪ S)∗. We have γB ≈ γ'B if and only if γ = γ'
Proof. The ‘if’ direction is trivial. For the ‘only if’ direction assume that γ /= γ' and (without restriction) |γ| ≥ |γ'|. We prove γB /≈ γ'B by induction on |γ'|.

In the base case |γ'| = 0 and |γ| > 0, since γ /= γ'. Thus γB →Z
δB (by rule

34) for some Z ∈ Σ∪ S, but γ'B = B ⇒/ Z . So the attacker wins and γB /≈ γ'B.
For the induction step the attacker plays γB → δB by rule 34 (i.e., he removes the top symbol Z of γ). The defender can respond in two ways. First, if the top symbol of γ' is the same Z as that of γ then the defender

can play γ'B →Z
δ'B by rule 34. It follows that δ /= δ' and |δ'| = |γ'|— 1. By

induction hypothesis δB /≈ δ'B. Second, if the symbol Z occurs at some other



position in γ' then the defender can play γ'B ⇒Z
δ'B (by rules 25. and 34.).

However, in this case |δ'| < |γ'| — 1 while |δ| = |γ| — 1. Therefore |δ'| < |δ|
and thus δ' /= δ. By induction hypothesis again δB /≈ δ'B. (Using the rules 26–32 to generate new symbols on the stack is not an option for the defender, since this always ends with the visible action ‘f ’.) Thus, the attacker has a
winning strategy and γB /≈ γ'B.	 

τ ∗ f
Lemma 5.3 B →→ CγB if and only if γ ∈ (Σ ∪ S)
a computation tree of M.
is not a correct path in

Proof. Directly from the definition of the set ERROR and the rules 26–32. 
Lemma 5.4 Let β = ((s, Y ), n)γB and β' = ((s',Y ), n)γB be processes, where π(s) = acc. We have β /≈ β' if and only if γ is a correct branch of a computation tree of the LBA M.
Proof.
⇒ We assume that γ is not a correct branch of a computation tree of M
and show that β ≈ β' under this condition. The defender has the follow-
τ
ing winning strategy.  If the attacker plays β = ((s, Y ), n)γB → γB or
β' = ((s',Y ), n)γB →τ  γB then the defender can make the two processes
syntactically equal in the same round of the game and wins. If the at-
f
tacker plays β = ((s, Y ), n)γB → CγB then the defender can reply by

β' = ((s',Y ), n)γB →τ	B
τ ∗ f
→→ CγB by Lemma 5.3, because γ is not a

correct branch of a computation tree of M. Again the two processes are syntactically equal and the defender wins. Thus β ≈ β'.
⇐ If γ is a correct branch of a computation tree of the LBA M then the attacker has the following winning strategy. The attacker plays the move
f
β = ((s, Y ), n)γB → CγB. The defender can only reply by popping the
whole stack (by rules 24 and 25), pushing a new sequence of symbols onto the stack (by rules 26–31) and finally doing action ‘f ’ (by rule 32). So the
'	'	τ ∗	f	'

defender can only play β
= ((s ,Y ), n)γB → B ⇒ Cγ B. However, by

Lemma 5.3, γ' does not represent a correct computation of M and thus
γ' /= γ.
We assume w.l.o.g. that |γ| ≥ |γ'|. (The other case is symmetric.) Then the attacker plays CγB → γB. If the defender uses the rule 26 in his reply

then the result will be Cγ'B ⇒c
δB for some δ s.t. δ /⇒
for all h /= f and

thus the attacker can win in next move. Therefore the defender can only
reply Cγ'B ⇒c  γ''B, where γ'' is a suffix of γ' (by rules 33 and 25). Thus
γ /= γ'' and, by Lemma 5.2, γB /≈ γ''B and so the attacker wins.
Therefore the attacker has a winning strategy and β /≈ β'.

 
Lemma 5.5 Let α, α' be the processes from Section 4. α /≈ α' if and only if
M accepts w.
Proof.
⇐ If M accepts w then the attacker has the following winning strategy. By Lemma 5.1 the attacker has a strategy in the weak bisimulation game to reach a configuration of processes β = ((s, Y ), n)γB and β' = ((s',Y ), n)γB, where π(s) = acc and γ is a sequence of LBA configurations that describes a correct branch of a computation tree of M. (It must be a correct accepting computation branch on w, since it starts with w and π(s) = acc). By Lemma 5.4 β /≈ β' and the attacker wins. Thus α /≈ α'.
⇒ If M does not accept w then the defender has a winning strategy. By Lemma 5.1 the defender has a strategy to avoid a configuration β = ((s, Y ), n)γB and β' = ((s',Y ), n)γB, where π(s) = acc and γ is a sequence of LBA configurations that describes a correct branch of a computation tree of M. The defender plays according to this strategy until one of the follow-
ing two situations occurs: If the top symbols correspond to a rejecting state then only rules 20 and 21 are applicable, the processes become syntactically equal and the defender wins. If the top symbols correspond to accepting states then the two current processes must have the form β = ((s, Y ), n)γB
and β' = ((s',Y ), n)γB, where π(s) = acc. By Lemma 5.1 γ does not rep-
resent a correct branch of an accepting computation tree of M and thus by Lemma 5.4 β ≈ β'. So the defender always wins and α ≈ α'.

Lemma 5.6 Let ∆ be the BPA from Section 4, depending on the alternating LBA M. It is normed for every M.
Proof. All constants Z ∈ Σ∪ S have norm 0, because of rule 25. Constants B and C have norm 1, because of rules 35 and 33. F  =  C  +1 = 2, by rule 32.  G  = 2, because of rules 28–30, 32, 33 and 25. All constants t ∈ T have finite norm, because by Remark 2.4 all correct branches of a computation tree of M have finite length. It is possible to push a correct branch of a computation tree of M onto the stack. This sequence will end in an accepting or a rejecting state after an at most exponential number of steps by Remark 2.4. Thus all constants in T have finite norm, because of rules 1–24, 33 and 25. Therefore all constants in Γ have finite norm.	 
Note that our system ∆ is normed, but not totally normed (see Def. 2.1), because some constants have norm 0.

Theorem 5.7 Weak bisimulation equivalence for normed BPA is EXPTIME- hard.
Proof. By reduction of the acceptance problem for alternating LBA. For any alternating LBA M with input word w we construct the BPA ∆ and processes α, α' as in Section 4. By Lemma 5.6 the BPA is normed and by Lemma 5.5
α /≈ α' if and only if M accepts w.	 

The Regularity Problem
The regularity problem is to check if a given infinite-state process is regular (i.e., finite) up-to a given notion of semantic equivalence.
Weak regularity of BPA
Instance: A BPA process (P, ∆).
Question: Does there exist a finite-state system F s.t. (P, ∆) ≈ F ?
We show that weak regularity of BPA is EXPTIME -hard by a modification of the construction of Section 4. The problem with the construction from Section 4 is, that it is possible to generate infinitely many different wrong branches of a computation tree (of the LBA) on the stack, which are all
pairwise non-weakly-bisimilar. Thus our processes α, α' are always infinite
(i.e., non-regular) up-to weak bisimilarity. Here we modify our construction to make the processes regular up-to weak bisimilarity. (The idea is to make all the processes containing wrong computation sequences (of the LBA) weakly bisimilar to each other.) Then we use a standard reduction (from [15]) from weak bisimilarity of weakly regular processes to the weak regularity problem. However, unlike in Section 4, our modified processes are not normed.
The modification of the construction is done as follows:

We replace the old rule 25: Z →τ
ϵ (for all Z ∈ Σ ∪ S) by the new rule 25:

Z →τ GB (for all Z ∈ Σ ∪ S).

We replace the old rule 35: B →b
ϵ by the new rule 35: B →
B. (Thus the

new system is no longer normed, since  B  = ∞.)
We add the new rule number 36: F →τ ϵ.
Let ∆' be this new modified set of rules. We obtain that γB ≈ γ'B for all branches of a computation tree γ, γ' (of the alternating LBA) that contain
at least one error, because all sequences with errors can be generated by τ - actions. Formally, we show a modified version of Lemma 5.2 for the new system ∆' as follows:
Lemma 6.1 Let γ, γ' ∈ (Σ ∪ S)∗. If γ and γ' are incorrect branches of a

computation tree (of the alternating LBA) then γB ≈ γ'B. If γ is a correct branch of a computation tree and γ' /= γ then γB /≈ γ'B.
Proof.
Let γ, γ' ∈ (Σ ∪ S)∗ be incorrect branches of computation trees (of the alternating LBA). Then the defender has the following winning strategy in the weak bisimulation game starting at γB, γ'B. Let Z, Z' ∈ Σ ∪ S be the first symbols in γ, γ' respectively, i.e., γ = Zδ and γ' = Z'δ'. (Z, Z' exist, since the empty sequence is a correct branch of a computation
tree, because it does not contain any wrong steps.) There are only two possibilities for the attacker’s move:
If the attacker plays γB = ZδB →τ  GBδB by the new rule 25 then
the defender responds by γ'B = Z'δ'B →τ  GBδ'B (by rule 25), and
vice versa. Since B  = ∞ we have GBδB ≈ GB ≈ GBδ'B and
thus the defender can win.
If the attacker plays γB = ZδB → δB (by rule 34) then the defender
responds by a long move: First γ'B = Z'δ'B →τ  GBδ'B by rule 25.
'	τ ∗	'
Then GBδ B → FγBδ B by rules 27–31 (this is possible, because γ
is an incorrect branch of a computation tree of the alternating LBA).
Then FγBδ'B →τ  γBδ'B = ZδBδ'B (by the new rule 36). Finally,

ZδBδ'B →Z
δBδ'B by rule 34. Since  B  = ∞ we have δB ≈ δBδ'B

and thus the defender can win.
The other case where the attacker plays γ'B = Z'δ'B →Z
δ'B is

symmetric, because γ' is also an incorrect branch of a computation
tree of the alternating LBA.
Thus the defender has a winning strategy and so γB ≈ γ'B.
Now we assume that γ is a correct computation sequence and γ' /= γ. We show that γB /≈ γ'B by induction on |γ|. We describe a winning strategy for the attacker in the weak bisimulation game.
In the base case |γ| = 0 and |γ'| > 0, since γ /= γ'. Thus γB = B →b B
(by rule 35), but γ'B /⇒b . So the attacker wins and γB /≈ γ'B.
For the induction step |γ| ≥ 1 and thus γ = Zδ for some Z ∈ (Σ ∪ S)
and δ ∈ (Σ∪ S)∗. In the special case that |γ'| = 0 we have γ'B = B →b  B
(by rule 35), but γB = ZδB ⇒/ b . So the attacker wins and γB /≈ γ'B. So we now assume |γ'| ≥ 1 and thus γ' = Z'δ' for some Z' ∈ (Σ ∪ S) and

δ' ∈ (Σ ∪ S)∗. The attacker plays γB = ZδB →Z
defender can respond in two ways:
δB (by rule 34). The

If Z = Z' then the defender can do γ'B = Z'δ'B = Zδ'B →Z
δ'B

(by rule 34). Then δ is still a correct branch of a computation tree

of the LBA and δ' /= δ. Furthermore, |δ| < |γ|. Thus, by induction hypothesis δB /≈ δ'B and so the attacker can win.
In any case (if Z = Z' or not) the defender can do γ'B = Z'δ'B ⇒Z δ''Bδ'B by rules 27–31, 36 and 34, where δ'' is an incorrect branch of a computation tree of the LBA and |δ''| > 0. We get δ''Bδ'B ≈ δ''B. Again we have that δ is a correct branch of a computation tree, and thus δ'' /= δ and furthermore |δ| < |γ|. By induction hypothesis δB /≈ δ''B and so the attacker can win.
Thus the attacker has a winning strategy and γB /≈ γ'B.



Theorem 6.2 Weak regularity of BPA is EXPTIME-hard.

Proof. We use the modified set of rules ∆' as described above. By Lemma 6.1 all the infinitely many incorrect branches of computation trees are weakly bisimilar to each other. Since, by Remark 2.4, all correct branches of compu- tation trees have exponentially bounded length, it follows that the processes
α, α' (defined as in Section 4) in the new system ∆' are finite up to weak bisim- ilarity, i.e., weakly regular. However, they still satisfy the property α /≈ α' iff
M accepts w, because
Lemma 5.1 carries over directly to ∆'.
Lemma 5.2 is replaced by Lemma 6.1 for ∆'.
Lemma 5.3 carries over directly to ∆'.
Lemma 5.4 carries over to ∆'. The proof must be modified slightly to use Lemma 6.1 instead of Lemma 5.2. Also the long moves of popping the whole stack (by rule 25 in ∆) till the bottom symbol B and generating a new stack content (by rules 26–31) are modified. By the new rule 25 in ∆' the stack content is not popped but cut off by the introduction of a new bottom symbol B, which cannot be removed in ∆'. (Remember that in ∆' we have  B  = ∞ and thus γBδ ≈ γB for all γ, δ.)
Lemma 5.5 carries over directly to ∆'.
Note that Lemma 5.6 does not carry over to ∆', since  B  = ∞.
So we obtain that (α, ∆'), (α', ∆') are weakly regular and (α, ∆') /≈ (α', ∆') if and only if M accepts w.
Then we can apply the general polynomial time reduction from weak bisim- ilarity of weakly regular BPA (which we have just shown to be EXPTIME - hard) to the weak regularity problem for BPA from [15] and obtain our result. 

Undecidability for Two Control-States
BPA correspond to the subclass of pushdown automata with a finite control of size 1. Undecidability of weak bisimilarity for general (normed) pushdown automata has been shown by Srba in [20] by a reduction from Minsky 2- counter machines. The reason why this proof does not carry over to BPA is that BPA lack a global finite control and thus cannot remember control- information when decreasing the stack. (However, while increasing the stack, the top stack symbol can be used to encode a control-state.) The question arises how many control-states are needed in pushdown automata to make weak bisimilarity undecidable. It follows directly from the construction in [20] that a certain fixed number suffices, since one can apply this reduction to the fixed universal Minsky machine, but the number obtained in this way is certainly much bigger than 2.
However, weak bisimilarity is already undecidable for pushdown automata with only 2 control-states (a very weak extension of BPA). This can be shown by a straightforward adaption of the technique used in Srba’s proof of unde- cidability of weak bisimilarity for PA-processes [19] (although PDA and PA are incomparable).
Theorem 7.1 Weak bisimilarity is undecidable for normed pushdown au- tomata with only 2 control-states.
Proof. (sketch) Consider an instance of Post’s correspondence problem (PCP) with two sets of words A = {u1,..., un} and B = {v1,... , vn} where ui, vi ∈ Σ+. It is undecidable whether there exist finitely many indices i1,... , im ∈
{1,..., n} s.t. ui1 ... uim = vi1 ... vim [13]. One can effectively construct a PDA with only 2 control-states p1, p2 s.t. p1X ≈ p1X' iff the PCP instance
has a solution. For every word ui one defines a symbol Ui and transition rules
s.t. p1Ui → p1 and (by using some intermediate stack symbols corresponding

to suffixes of u ) p U
→ui
p . Similarly for v
and V . One can construct the

i	2 i	2	i	i
bisimulation game in such a way that the defender first pushes (by τ -moves) an arbitrarily long sequence Ui1 ... Uim onto the stack of the left process and then in the next round an arbitrarily long sequence Vj1 ... Vj ' onto the stack
of the right process. During these operations the control-state will always be
p1, since the top stack symbol can be used to store control-information in- stead. After these operations the processes will have the form p1Y Ui1 ... Uim

and p1Y 'Vj1 ... V '
. Then one ads the rules p Y →a p , p Y ' →a
p , p Y →b  p ,

p Y ' →b p . It is easy to see that p U ... U	≈ p V  ... V
iff m = m' and

1	2	1 i1	im	1 j1	'
ik = jk for all k ∈ {1,..., m}. On the other hand p2Ui1 ... Uim ≈ p2Vj1 ... Vj '
iff ui1 ... uim = vj1 ... vjm' . The configuration represents a solution of the PCP

iff both these conditions are satisfied. (Remember that it was the defender who chose the sequences Ui1 ... Uim and Vj1 ... Vj ' .) However, it is the at- tacker in the bisimulation game who decides which of the two conditions is
checked, by choosing either action ‘a’ or action ‘b’ and thus either control-state
p1 or p2. Therefore we have p1X ≈ p1X' iff p1Y Ui1 ... Ui	≈ p1Y 'Vj ... Vj
m	1	'
iff the PCP has a solution. The constructed PDA is trivially normed.	 

Remark 7.2 Note that in this undecidability proof the stack of the PDA is first only increased and then only decreased. In other words, there is only one reversal between stack-increasing and stack-decreasing mode. (The proof in [20] used an arbitrary number of reversals.) Thus, weak bisimilarity is also undecidable for normed 1-reversal-bounded PDA with just two control-states.

Remark 7.3 It has been shown in [11] that weak bisimilarity is undecidable even for (normed) 1-counter machines (just one-counter instead of a stack). In fact, it is undecidable for an even weaker model: one-counter nets, i.e, Petri nets with just one unbounded place. However, one-counter nets/machines and BPA are incomparable in their expressive power.
It has also been shown in [11] that a fixed number of control-states in 1- counter machines suffices to make weak bisimilarity undecidable. The exact number of control-states required is unknown, but it is very unlikely that just 2 should suffice as for PDA.



Conclusion

We have shown an EXPTIME lower bound for the problem of checking weak bisimulation equivalence for general and normed BPA. However, our proof does not carry over to the class of totally normed BPA. The following table summarizes the known complexity results about strong and weak bisimilarity on PDA and BPA. New results are in boldface. (For an extensive list of results on the complexity of bisimulation checking for infinite-state systems see [16].)



It is interesting to compare these results with the results on checking bisim- ilarity with finite-state systems. For example, checking strong and weak bisim- ilarity between (normed) PDA and finite-state systems is PSPACE -complete
[8] and checking weak (and strong) bisimilarity between BPA and finite-state systems is polynomial [9].
Furthermore, we have shown a new EXPTIME lower bound for weak reg- ularity of BPA. For normed BPA, the best known lower bound for weak reg-
ularity is still NP-hardness [15]. For totally normed BPA, weak regularity coincides with boundedness, which is NLogspace-complete [18].

References
Balcazar, J., J. Gabarro and M. Santha, Deciding bisimilarity is P-complete, Formal Aspects of Computing 4 (1992), pp. 638–648.
Burkart, O., D. Caucal, F. Moller and B. Steffen, Verification on infinite structures, in:
J. Bergstra, A. Ponse and S. Smolka, editors, Handbook of Process Algebra, Elsevier Science, 2001 pp. 545–623.
Burkart, O., D. Caucal and B. Steffen, An elementary bisimulation decision procedure for arbitrary context-free processes, in: MFCS’95, LNCS 969 (1995).
Chandra, A. K., D. C. Kozen and L. J. Stockmeyer, Alternation, Journal of the ACM 28
(1981), pp. 114–133.
Hirshfeld, Y., Bisimulation trees and the decidability of weak bisimulations, Electronic Notes in Theoretical Computer Science (ENTCS) 5 (1997).
Hirshfeld, Y., M. Jerrum and F. Moller, A polynomial algorithm for deciding bisimilarity of normed context-free processes, Theoretical Computer Science 158 (1996), pp. 143–159.
Janˇcar, P., High undecidability of weak bisimilarity for Petri nets, in: Proceedings of CAAP’95, LNCS 915 (1995), pp. 349–363.
Kuˇcera, A. and R. Mayr, On the complexity of semantic equivalences for pushdown automata and BPA, , 2420 (2002), pp. 433–445.
Kuˇcera, A. and R. Mayr, Weak bisimilarity between finite-state systems and BPA or normed BPP is decidable in polynomial time, Theoretical Computer Science 270 (2002), pp. 667–700.
Mayr, R., Process rewrite systems, Information and Computation 156 (2000), pp. 264–286.
Mayr, R., Undecidability of weak bisimulation equivalence for 1-counter processes, in: Proc. of ICALP 2003, LNCS 2719 (2003).
Milner, R., “Communication and Concurrency,” Prentice Hall, 1989.
Post, E. L., A variant of a recursively unsolvable problem, Bulletin of the American Mathematical Society 52 (1946), pp. 264–268.


S´enizergues, G., Decidability of bisimulation equivalence for equational graphs of finite out- degree, in: Proc. of FOCS’98 (1998).
Srba, J., Complexity of weak bisimilarity and regularity for BPA and BPP, Electronic Notes in Theoretical Computer Science (ENTCS) 39 (2000), proceedings of the 7th International Workshop on Expressiveness in Concurrency (EXPRESS’00).
Srba, J., Roadmap of infinite results, Bulletin of the European Association for Theoretical Computer Science 78 (2002), pp. 163–175, columns: Concurrency. Regularly updated online version at http://www.brics.dk/~srba/roadmap.
Srba, J., Strong bisimilarity and regularity of basic parallel processes is PSPACE-hard, in:
Proceedings of STACS 2002, LNCS 2285 (2002), pp. 535–546.
Srba, J., Strong bisimilarity and regularity of basic process algebra is PSPACE-hard, in: Proc. of ICALP 2002, LNCS 2380 (2002), pp. 716–727.
Srba, J., Undecidability of weak bisimilarity for PA-processes, in: Proceedings of 6th International Conference on Developments in Languague Theory (DLT’02), LNCS (2002), to appear.
Srba, J., Undecidability of weak bisimilarity for pushdown processes, in: Proc. of CONCUR 2002, LNCS 2421 (2002), pp. 579–593.
Stirling, C., Decidability of bisimulation equivalence for normed pushdown processes, Theoretical Computer Science 195 (1998), pp. 113–131.
Stirling, C., The joys of bisimulation, in: Proc. of MFCS’98, LNCS 1450 (1998), pp. 142–151.
Stˇr´ıbrna´, J., Hardness results for weak bisimilarity of simple process algebras, Electronic Notes in Theoretical Computer Science (ENTCS) 18 (1998).
