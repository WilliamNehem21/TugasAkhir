Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 308 (2014) 49–64
www.elsevier.com/locate/entcs

Applicative Bisimilarities for Call-by-Name and Call-by-Value λμ-Calculus
Dariusz Biernacki 1
Institute of Computer Science University of Wroc-law
Wroc-law, Poland

Sergue¨ı Lenglet 2
LORIA
Universit´e de Lorraine Nancy, France


Abstract
We propose the first sound and complete bisimilarities for the call-by-name and call-by-value untyped λμ- calculus, defined in the applicative style. We give equivalence examples to illustrate how our relations can be used; in particular, we prove David and Py’s counter-example, which cannot be proved with Lassen’s preexisting normal form bisimilarities for the λμ-calculus.
Keywords:  contextual equivalence, applicative bisimulation, continuation, control operator


Introduction
Contextual equivalence [13] is considered as the most natural behavioral equivalence in languages based on the λ-calculus. Two terms are equivalent if an outside ob- server cannot tell them apart when they are evaluated within any context (a term with a hole). However, the quantification over contexts makes proving the equiva- lence of two given programs cumbersome. Consequently, other characterizations of contextual equivalence are sought for, such as coinductively defined bisimilarities.
Several kinds of bisimilarity have been proposed, such as, e.g., applicative bisim- ilarity [1], which relates terms by reducing them to values (if possible), and then compares these values by applying them to an arbitrary argument. The idea is the

1 Email: dabi@cs.uni.wroc.pl
2 Email: serguei.lenglet@univ-lorraine.fr

http://dx.doi.org/10.1016/j.entcs.2014.10.004
1571-0661/© 2014 Elsevier B.V. All rights reserved.

same for environmental bisimilarity [18], except the values are tested with argu- ments built from an environment, which represents the knowledge of an observer about the tested terms. Finally, normal form bisimilarity [11] (initially called open bisimilarity [17]) reduces open terms to normal forms and then compares their sub- terms. Applicative and environmental bisimilarities still contain some quantifica- tion over arguments, and usually coincide with contextual equivalence. In contrast, normal form bisimilarity is easier to use, as its definition does not contain any quan- tification over arguments, but it is generally not complete, i.e., there exist equivalent terms that are not normal form bisimilar.
This article treats the behavioral theory of the untyped λμ-calculus [15]. The λμ-calculus provides a computational interpretation of classical natural deduction and thus extends the Curry-Howard correspondence from intuitionistic to classical logic. Operationally, the reduction rules of the calculus express not only function applications but also capturing of the current context of evaluation. Therefore, when considered in the untyped setting, the calculus offers an approach to the semantics of abortive control operators such as call/cc known from the Scheme programming language and it may be viewed as a closely related alternative to Felleisen and Hieb’s syntactic theory of control [6].
So far no characterization of contextual equivalence has been proposed for either call-by-value or call-by-name λμ-calculus. Lassen defined normal form bisimilari- ties for call-by-name weak-head reduction [10], for head reduction [12], and, with Støvring, for call-by-value weak-head reduction [19] that are not complete. However, normal form bisimilarity is complete for the Λμ-calculus [5] with head reduction [12], and also for the λμ-calculus with store [19] under call-by-value weak-head reduc- tion. Lassen also defined an incomplete applicative bisimilarity for call-by-name weak-head reduction in [10]. A definition of applicative bisimilarity has also been proposed for a call-by-value typed μPCF [14], but the resulting relation is neither sound nor complete.
In this work, we propose the first characterizations of contextual equivalence for λμ-calculus for both call-by-name and call-by-value weak-head reduction semantics. The applicative bisimilarities we define are harder to use than Lassen’s normal form bisimilarity to prove the equivalence of two given terms, but because they are complete, we can equate terms that cannot be related with normal form bisimilarity, such as David and Py’s counter-example [4]. Even though the two applicative bisimilarities we define are built along the same principles, the relation we obtain in call-by-value is much more difficult to use than the one for call-by-name. However, we provide counter-examples showing that simplifying the call-by-value case so that it matches the call-by-name one leads to an unsound definition.
The paper is organized as follows. We first discuss the behavioral theory of the call-by-name (abbreviated as CBN) λμ-calculus in Section 2. We propose a notion of contextual equivalence (in Section 2.2) which observes top-level names, and we then characterize it with an applicative bisimilarity (Section 2.3). In particular, we compare our definition of bisimilarity with Lassen’s work and we prove David and Py’s counter-example using our relation. We then discuss call-by-value (CBV) in

Section 3. We propose a definition of applicative bisimilarity (Section 3.2) which coincides with contextual equivalence. We also provide counter-examples showing that the definition cannot be naively simplified to match the one for call-by-name. Although the relation we obtain is harder to use than the one for call-by-name, we can still prove some interesting equivalences of terms, as we demonstrate in Sec- tion 3.3. We conclude in Section 4. The accompanying research report [3] contains the proofs missing from this paper, and also discusses environmental bisimilarity for call-by-name.

Call-by-Name λμ-calculus
Syntax and Semantics
The λμ-calculus [15] extends the λ-calculus with named terms and a μ constructor that binds names in terms. We assume a set X of variables, ranged over by x, y, etc., and a distinct set A of names, ranged over by a, b, etc. Terms (T ) and named terms (U ) are defined by the following grammar:

Terms:	t ::= x | λx.t | tt | μa.u
Named terms:	u ::= [a]t

Values (V ), ranged over by v, are terms of the form λx.t. A λ-abstraction λx.t binds x in t and a μ-abstraction μa.t binds a in t. We equate terms up to α-conversion of their bound variables and names, and we assume bound names to be pairwise distinct, as well as distinct from free names. We write fv(t) and fv(u) for the set of free variables of, respectively, t and u, and we write fn(t) and fn(u) for their set of free names. A term t or named term u is said closed if, respectively, fv(t) = ∅ or fv(u) = ∅. Note that a closed (named) term may contain free names. The sets of closed terms, closed values, and named terms are T 0, V 0, and U 0, respectively. In any discussion or proof, we say a variable or a name is fresh if it does not occur in any term under consideration.
We distinguish several kinds of contexts, represented outside-in, as follows:

Contexts:	C ::=   | C t | t C | λx.C | μa.C
Named contexts:	 C ::= [a]C CBN evaluation contexts:	E ::=  | E t
Named evaluation contexts:	E ::= [a]E
The syntax of (named) evaluation contexts reflects the chosen reduction strategy, here call-by-name. Contexts can be filled only with a term t, to produce either regular terms C [t], E [t], or named terms C[t], E[t]; the free names and free variables of t may be captured in the process.

We write t0{t1/x} and u0{t1/x} for the usual capture-avoiding substitution of terms for variables. We define the capture-avoiding substitution of named contexts for names, written t⟨E/a⟩ and u⟨E/a⟩, as follows. Note that the side-condition in the μ-binding case can always be fulfilled using α-conversion.


x⟨E/a⟩ d=ef x
(λx.t)⟨E/a⟩ d=ef λx.t⟨E/a⟩
(μb.u)⟨E/a⟩ d=ef μb.u⟨E/a⟩ if b ∈/ fn(E) ∪ {a}
[b]t⟨E/a⟩ if a /= b
([b]t)⟨E/a⟩ =

E	def	E	E

(t0 t1)⟨ /a⟩ = t0⟨ /a⟩ t1⟨ /a⟩
⎩ E[t⟨E/a⟩] if a = b

We define the CBN reduction relation →n inductively by the following rules:
(βn)	[a](λx.t0) t1 →n [a]t0{t1/x} (μ)		[a]μb.u →n u⟨[a] /b⟩
(app)	[a]t0 t1 →n u⟨[a]  t1/b⟩ if [b]t0 →n u and b ∈/ fn([a]t0 t1)
Reduction is defined on named terms only. The rule (βn) is the usual call-by-name β-reduction. In rule (μ), the current continuation, represented by a, is captured and substituted for b in u. In an application (cf. rule (app)), we reduce the term t0 in function position by introducing a fresh name b which represents the top level. We then replace b with [a] t1 in the result u of the reduction of [b]t0. We can also express reduction with top-level evaluation contexts as follows.
Lemma 2.1 u →n uj iff u = E[(λx.t0) t1] and uj = E[t0{t1/x}], or u = E[μa.ujj]
and uj = ujj⟨E/a⟩.
Reduction is also compatible with evaluation contexts in the following sense.
Lemma 2.2 If u →n uj, then u⟨E/a⟩ →n uj⟨E/a⟩.
We write →∗ for the transitive and reflexive closure of →n, and we define the
evaluation relation of the calculus as follows.
Definition 2.3 We write u ⇓n uj if u →∗ uj and uj cannot reduce further.
If u ⇓n uj, then uj is a named value. If u admits an infinite reduction sequence, we say it diverges, written u ⇑n. For example, let Ω d=ef (λx.x x) (λx.x x); then [a]Ω ⇑n for all a.
Contextual Equivalence
As in the λ-calculus, contextual equivalence in the λμ-calculus is defined in terms of convergence. However, unlike previous definitions [10,12], we define contextual equivalence on named terms first, before extending it to any terms.
Definition 2.4 Two closed terms u0, u1 are contextually equivalent, written u0 ≈c u1, if for all closed contexts C and names a, there exist b, v0, and v1 such that C[μa.u0] ⇓n [b]v0 iff C[μa.u1] ⇓n [b]v1.

Note that we can plug only terms ina context, therefore we prefix u0 and u1 with a μ-abstraction. Definition 2.4 is not as generic as it could be, because we require the resulting named values to have the same top-level name b; a more general definition would simply say “C[μa.u0] ↓n iff C[μa.u1] ↓n.” Our definition is strictly finer than the general one, because contexts cannot discriminate upon top-level names in some cases, as we can see with the next example.
Example 2.5 Let Θ d=ef (λx.λy.y (xx y)) (λx.λy.y (xx y)) be Turing’s CBN fixed- point combinator, and let v d=ef λx.λy.x. The terms u0 d=ef [a]λx.μc.[b]λy.Θ v and u1 d=ef [b]λy.Θ v are distinguished by Definition 2.4 if a /= b, but we show they are related by the general contextual equivalence. To do so, we verify that E[μc.u0] ↓n iff E[μc.u1] ↓n holds for all E and c, and we can then conclude that u0 and u1 are in the general equivalence with David and Py’s context lemma [4]. Let E be of the form [d]E t for some d, E , t. Then E[μa.u0] ↓n [b]λy.Θ v and E[μa.u1] ↓n [b]λy.Θ v, E[μb.u0] ↓n [a]λx.μc.E[λy.Θ v] and E[μb.u1] ↓n [d]λy.Θ v, and finally E[μc.u0] ↓n u0 and E[μc.u1] ↓n u1 for c ∈/ {a, b}. The case E = [d]  is easy to check as well.
We choose Definition 2.4 because it gives more information on the behaviors of terms than the general equivalence. Besides, only very peculiar terms u0 and u1 are related by the general equivalence but not by Definition 2.4. These terms are like black holes: they reduce (in some context C) to values [a]v0 and [b]v1 with a /= b that never evaluate their arguments. Indeed, if E = [c] t0 ... tn, then E[μa.[a]v0] →n E[v0⟨E/a⟩], and E[μa.[b]v1] ↓n [b]v1⟨E/a⟩. Suppose that when evaluating E[v0⟨E/a⟩], we evaluate one of the ti’s. Then by replacing ti with Ω, we obtain a context Ej such that Ej[μa.[a]v0] ⇑n (because Ω will be evaluated), and Ej[μa.[b]v1] ↓n, which is in contradiction with the fact that u0 and u1 are in the general equivalence (they are distinguished by Ej[μa.C]).
We extend Definition 2.4 to any closed terms t0, t1, by saying that t0 ≈c t1 if [a]t0 ≈c [a]t1 for any fresh a. Other versions of the extension are possible, for example by replacing “for any a” by “for some a”, or by dropping the freshness requirement; as can be shown using the results of Section 2.3, all these definitions are equivalent. We can also define contextual equivalence on open terms, using the notion of open extension, which extends any relation on closed (named) terms to open (named) terms. We say a substitution σ closes t (or u) if σ replaces the variables in fv(t) (or fv(u)) with closed terms.
Definition 2.6 Let Y be a relation on closed (named) terms. Two terms t0 and t1 are in the open extension of Y, written t0 Y○ t1, if for all substitutions σ closing t0 and t1, we have t0σ Y t1σ (and similarly for u0 Y○ u1).

Applicative Bisimilarity
We propose a notion of applicative bisimulation, which tests values by applying them to a random closed argument. As with contextual equivalence, we give the definitions for named terms, before extending it to regular terms.

Definition 2.7 A relation Y on closed named terms is an applicative bisimulation if u0 Y u1 implies
if u0 →n uj , then there exists uj such that u1 →∗ uj and uj Y uj ;
0	1	n  1	0	1
if u0 = [a]λx.t0, then there exists t1 such that u1 →∗ [a]λx.t1 and for all t, we
have [a]t0⟨[a]  t/a⟩{t/x}Y [a]t1⟨[a]  t/a⟩{t/x};
the symmetric conditions on u1.
Applicative bisimilarity, written ≈, is the largest applicative bisimulation.
For regular terms, we write t0 Y t1 if [a]t0 Y [a]t1 for any a ∈/ fn(t0, t1). The first item of Definition 2.7 plays the bisimulation game for named terms which are not named values. If u0 is a named value [a]λx.t0, then u1 has to reduce to a named value [a]λx.t1, and we compare the values by applying them to an argument t. However, a context cannot interact with [a]λx.t0 and [a]λx.t1 by simply applying them to t, because ([a]λx.t0) t is not allowed by the syntax. Consequently, we have to prefix them first with μa. As a result, we consider the named terms [a](μa.[a]λx.t0) t and [a](μa.[a]λx.t1) t, which reduce to, respec- tively, [a](λx.t0⟨[a] t/a⟩)t and [a](λx.t1⟨[a] t/a⟩)t, and then to [a]t0⟨[a] t/a⟩{t/x} and [a]t1⟨[a] t/a⟩{t/x}; we obtain the terms in the clause for values of Definition 2.7.
Remark 2.8 When considering [a](μa.[a]λx.t0) t and [a](μa.[a]λx.t1) t, we use the same top-level name a as the one of the named values [a]λx.t0 and [a]λx.t1. We could use a fresh name b instead; reusing the same name makes the bisimulation proofs easier (we do not have to introduce unnecessary fresh names).
We can also define a big-step version of the bisimulation, where we consider only evaluation to a value.
Definition 2.9 A relation Y on closed named terms is a big-step applicative bisim- ulation if u0 Y u1 implies
if u0 →∗ [a]λx.t0, then there exists t1 such that u1 →∗ [a]λx.t1 and for all t, we
n	n
have [a]t0⟨[a]  t/a⟩{t/x}Y [a]t1⟨[a]  t/a⟩{t/x};
the symmetric condition on u1.
Lemma 2.10 If Y is a big-step applicative bisimulation, then Y⊆ ≈.
As a first property, we prove that reduction (and therefore, evaluation) is in- cluded in bisimilarity.
Lemma 2.11 We have →∗ ⊆ ≈.
Proof. By showing that {(u, uj) | u →∗ uj}∪ {(u, u)} is a big-step bisimulation. 2
We give a basic example to show how applicative bisimulation can be used.

Example 2.12 For all closed v and a, b ∈/
fn(v) 3 , we prove that [a]v  ≈

[a]λx.μb.[a]v by showing that {([a]v, [a]λx.μb.[a]v) | b ∈/ fn(v)}∪ ≈ is an applicative

3 Note that the result still holds if a ∈ fn(v).

bisimulation. Indeed, if v = λx.t, then for all tj, we have [a]t{tj/x} ≈ [a]μb.[a]v tj, because [a]μb.[a]v tj →∗ [a]t{tj/x} (and by Lemma 2.11).

Soundness and Completeness
We now prove that ≈ coincides with ≈c. We first show that ≈ is a congruence using Howe’s method [8,7], which is a classic proof method to show that an applicative bisimilarity is a congruence. As in [10], we need to slightly adapt the proof to the λμ-calculus. Here we only sketch the application of the method, all the details can be found in [3, Appendix A.1].
The principle of the method is to prove that a relation called the Howe’s closure of ≈, which is a congruence by construction, is also a bisimulation. The definition of Howe’s closure relies on an auxiliary relation, called the compatible reﬁnement Y of a relation Y, and inductively defined by the following rules:


t0 Y t1
t0 Y t1	tj
Y tj
u0 Y u1



x Y˜ x


λx.t0 Y˜ λx.t1
t0 tj
Y˜ t1 tj


μa.u0 Y˜ μa.u1



  t0 Y t1	
[a]t0 Y˜ [a]t1

  Y˜ 
t0 Y t1	E0 Y˜ E1


t0⟨E0/a⟩ Y˜ t1⟨E1/a⟩
E0 Y˜ E1	t0 Y t1


E0 t0 Y˜ E1 t1
u0 Y u1	E0 Y˜ E1


u0⟨E0/a⟩ Y˜ u1⟨E1/a⟩
E0 Y˜ E1


E0 Y˜ [a]E1


In the original definition of compatible refinement [7], two terms are related by Y if they have the same outer language constructor, and their subterms are related by Y. In the λμ-calculus, compatible refinement is extended to (named) evaluation contexts, and we allow for the substitution of names with related named contexts.
Given two relations Y1 and Y2, we write Y1Y2 for their composition, e.g., t0 Y1Y2 t2 holds if there exists t1 such that t0 Y1 t1 and t1 Y2 t2. We can now define Howe’s closure of ≈, written ≈•, as follows.
Definition 2.13 The Howe’s closure ≈• is the smallest relation verifying:

•	•  ○	•	•	•

≈ ⊆≈ 
≈ ≈ ⊆≈ 
≈˜ ⊆≈ 


Howe’s closure is defined on open (named) terms as well as on (named) evalu- ation contexts. Because it contains its compatible refinement, ≈• is a congruence. To prove it is a bisimulation, we need a stronger result, called a pseudo-simulation lemma, where we test named values not with the same argument, but with argu-
ments tj , tj related by ≈•.
0	1
Lemma 2.14 Let (≈•)c be ≈• restricted to closed terms, and let u0 (≈•)c u1.
If u0 →n uj , then u1 →∗ uj and uj (≈•)c uj .
0	n  1	0	1

If u0 = [a]λx.t0, then u1 →∗
λx.t1 and for all tj
(≈•)c  tj , we have

t'	j	• c	[a] t'	j
[a]t0⟨	0/a⟩{t0/x} (≈ ) [a]t1⟨	1/a⟩{t1/x}.
With this result, we can prove that (≈•)c is a bisimulation, and therefore in- cluded in ≈. Because it also contains ≈ by definition, we have ≈=(≈•)c, and this implies that ≈ is a congruence. As a result, ≈ is sound w.r.t. to ≈c.
Theorem 2.15 ≈⊆ ≈c.
To simplify the proof of completeness (the reverse inclusion), we consider an alternate definition of contextual equivalence, where we test terms with named evaluation contexts only. By doing so, we prove a context lemma in the process. 4
.
Definition 2.16 Let u0, u1 be closed terms. We write u0 ≈c u1 if for all closed
contexts E and names a, there exist b, v0, v1 such that E[μa.u0] ↓n [b]v0 iff
E[μa.u1] ↓n [b]v1.
.
Theorem 2.17 ≈c ⊆ ≈c ⊆ ≈.
.
The first inclusion is by definition, and the second one is by showing that ≈c is
a big-step applicative bisimulation.
Comparison with Lassen’s Work
In [10], Lassen also proposes a definition of applicative bisimilarity that he proves sound, but he conjectures that it is not complete. We discuss here the differences between the two approaches.
Lassen defines a notion of bisimulation for regular terms only, and not for named terms. The definition is as follows.
Definition 2.18 A relation Y on closed terms is a Lassen applicative bisimulation if t0 Y t1 implies:
for all a, if [a]t0 →∗ [b]λx.tj , then there exists tj such that [a]t1 →∗ [b]λx.tj , and
n	0	1	n	1
for all t, we have tj ⟨[b]  t/b⟩{t/x}Y tj ⟨[b]  t/b⟩{t/x};
0	1
the symmetric condition on t1.
Lassen’s definition is quite similar to our definition of big-step applicative bisim- ulation (Definition 2.9), except it requires t0⟨[b] t/b⟩{t/x} Y t1⟨[b] t/b⟩{t/x}, which implies that these terms must be related when reduced with any top-level name a. This is more restrictive than our definition, where we compare these terms only with the top-level name b (or, as discussed in Remark 2.8, we could instead com- pare [c]t0⟨[c] t/b⟩{t/x} and [c]t1⟨[c] t/b⟩{t/x} for some fresh name c). To illustrate the difference, we consider Lassen’s counter-example from [10].
Example 2.19 Let t0 d=ef (λx.λy.x x) (λx.λy.x x), and t1 d=ef μa.[a]λy.μc.[a]t0 (with
c /= a). These terms are not bisimilar according to Lassen’s definition. For all b, we

4 We cannot directly use David and Py’s context lemma [4], because we use a different notion of contextual equivalence.

have [b]t0 →∗ [b]λy.t0 and [b]t1 →∗ [b]λy.μc.[b]t0. With Lassen’s definition, one has
n	n
to relate t0 and μc.[b]t0 t for any t, which means comparing [d]t0 and [d]μc.[b]t0 t for
all d. But these two terms are not equivalent if d /= b.
Lassen conjectures in [10] that these terms are contextually equivalent, and we can indeed prove that they are (big-step) bisimilar with our definition: we just have to compare [b]t0 and [b]μaj.[b]t0 t (or [c]t0 and [c]μaj.[c]t0 t for some fresh c) for any t, and both terms evaluate to [b]λx.t0 (or [c]λx.t0) and are therefore equivalent.
By comparing primarily named terms, as we do in our definition, we can keep track of what happens to the top level, and especially of any connection between the top level and a subterm. In Example 2.19, we can see that it is essential to remember that b represents the top level in μc.[b]t0 t, and therefore it does not make sense to compare [d]t0 and [d]μc.[b]t0t for any d /= b, as we have to do with Lassen’s definition. We believe that comparing named terms is essential to obtain completeness w.r.t. contextual equivalence; note that the sound and complete normal form bisimilarity for the λμρ-calculus [19] is also defined on named terms.
David and Py’s Counter-Example
In [4], David and Py give a counter-example showing that B¨ohm’s theorem fails in CBN λμ-calculus. They prove that their terms are contextually equivalent us- ing a context lemma. Here we slightly simplify their counter-example, and prove equivalence using applicative bisimilarity. Note that these terms cannot be proved equivalent with (a CBN variant of) eager normal form bisimilarity [10,19].
Example 2.20 Let 0 d=ef λx.λy.y, 1 d=ef λx.λy.x, and ta d=ef μc.[a]0. Then we have
λx.μa.[a]x μb.[a]x ta 0 ≈ λx.μa.[a]x μb.[a]x ta 1 5 .
Proof. [Sketch] We only give the main ideas here, the complete equivalence proof can be found in [3, Appendix A.2]. First, λx.μa.[a]x μb.[a]x ta 0 is not normal form bisimilar to λx.μa.[a]x μb.[a]x ta 1, because the subterms of these two terms are not normal form bisimilar (0 is not equivalent to 1).
To prove applicative bisimilarity, let c be a fresh name and t be a closed term. We want to relate [c]μa.[a]tμb.[a]tta 0 and [c]μa.[a]tμb.[a]tta 1, which reduce respectively to [c]tμb.[c]t tc 0 (1) and [c]tμb.[c]t tc 1 (2). Let d ∈/ fn(t); we distinguish several cases depending on the behavior of [d]t. The interesting case is when [d]t ↓n [d]λy.tj; then μb.[c]t tc 0 or μb.[c]t tc 1 is passed as an argument to λy.tj in respectively (1) and
(2). If tj executes its argument (that is, if tj reduces to E [y] for some E ), then (1) reduces to [c]t tc 0 (3), and (2) to [c]t tc 1 (4). But we know that [d]t ↓n [d]λy.tj, and tj executes its argument, so when evaluating (3) and (4), tc will be reduced, and therefore (3) and (4) will evaluate to [c]0.
In the other cases (e.g., [d]t ↓n [e]λy.tj with e /= d), either (1) and (2) eventually get to a point similar to the situation above where tc is executed, or they diverge.

5 The terms David and Py consider in their work are λx.μa.[a]xμb.[a](xta 0)ta and λx.μa.[a]xμb.[a](xta 1)ta. However, the additional argument ta would not come into play in the proof we present, so we have elided it.

In all cases, they are applicative bisimilar.	2

Call-by-Value λμ-calculus
Semantics and Contextual Equivalence
In this section, we use CBV left-to-right evaluation, which is encoded in the syntax of the CBV evaluation contexts:
E ::=  | E t | v E
The CBV reduction relation →v is defined by the following rules.
(βv)	[a](λx.t) v →v [a]t{v/x} (μ)		[a]μb.u →v u⟨[a] /b⟩
(app)	[a]t0 t1 →v u⟨[a] t1/b⟩ if [b]t0 →v u and b ∈/ fn([a]t0 t1) (appv)		[a]v t →v u⟨[a]v /b⟩  if [b]t →v u and b ∈/ fn([a]v t)
With rule (appv), we reduce arguments to values, to be able to apply CBV β- reduction (rule (βv)). The rules (μ) and (app) are unchanged. We could also express reduction with top-level named evaluation contexts, as in Lemma 2.1. Furthermore, CBV reduction is compatible with CBV contexts, as in Lemma 2.2. We write →∗ for the reflexive and transitive closure of →v, ↓v for CBV evaluation, and ⇑v for CBV divergence.
We use the same definition of contextual equivalence as in CBN.
Definition 3.1 Let u0, u1 be closed named terms. We write u0 ≈c u1, if for all closed contexts C and names a, there exist b, v0, and v1 such that C[μa.u0] ↓v [b]v0 iff C[μa.u1] ↓v [b]v1.
However, unlike in CBN, this definition (where we require the resulting values to have the same top-level names) coincides with the general definition where we simply say “C[μa.u0] ↓v iff C[μa.u1] ↓v.” Indeed, if C[μa.u0] ↓v [b]v0 and C[μa.u1] ↓v [c]v1 with c /= b, then we can easily distinguish them, because [b]μb.C[μa.u0] Ω →∗
v0⟨[b]  Ω/b⟩ Ω ⇑v, and [b]μb.C[μa.u1]Ω ↓v [c]v1⟨[b]  Ω/b⟩.
We extend ≈c to any closed terms as in CBN. The definition of open extension is slightly changed in CBV, compared to CBN: we close open terms by substituting their variables with closed values only, and not any closed terms.
Applicative Bisimilarity
Before giving its complete definition, we explain how applicative bisimilarity ≈ should compare two named values [a]λx.t0 and [a]λx.t1. The following reasoning explains and justifies the clauses in Definition 3.4. In particular, we provide counter- examples to show that we cannot simplify this definition.

In CBV λ-calculus (and also with delimited control [2]), values are tested by applying them to an arbitrary value argument. Following this principle, it is natural to propose the following clause for CBV λμ-calculus.
For all v, we have [a]t0⟨[a]  v/a⟩{v/x}≈ [a]t1⟨[a]  v/a⟩{v/x}.
As with Definition 2.7, we in fact compare [a](μa.[a]λx.t0) v with [a](μa.[a]λx.t1) v, which reduce to the terms in clause (1). However, such a clause would produce an unsound applicative bisimilarity; it would relate terms that are not contextually equivalent, like the ones in the next example.
Example 3.2 Let v0 d=ef λx.μb.[a]w x, v1 d=ef λx.w x x, with w d=ef λy.λz.z y. Then we have ([a]v0)⟨[a] v/a⟩ = [a](λx.μb.[a]w x v) v →∗ [a]w v v and ([a]v1)⟨[a] v/a⟩ = [a](λx.w x x) v →∗ [a]w v v. Because they reduce to the same term, ([a]v0)⟨[a] v/a⟩ is contextually equivalent to ([a]v1)⟨[a] v/a⟩, and using clause (1) would lead us to conclude that [a]v0 and [a]v1 are equivalent as well.

However, [a]v0 and [a]v1 can be distinguished with t d=ef
μd.[d]λy.μc.[d]wj,

where wj d=ef
λx.μc.[d]x wjj and wjj d=ef
λx.λy.λz.Ω.  Indeed, we can check that

([a]v0)⟨[a] t/a⟩ →∗
λz.Ω and ([a]v1)⟨[a] t/a⟩ →∗
Ω. This discrepancy comes from

the fact that, in ([a]v1)⟨[a] t/a⟩, t is reduced to a value once, capturing [a]v1  in the process, while t is reduced twice to a value in ([a]v0)⟨[a] t/a⟩, and each time it captures a different context. Therefore, [a]v0 and [a]v1 are distinguished by the context [a](μa. ) t, and they are consequently not contextually equivalent.
Example 3.2 suggests that we should compare [a]λx.t0 and [a]λx.t1 with con- texts of the form [a] t, instead of [a] v. Therefore, we should compare u0 d=ef [a](λx.t0⟨[a]  t/a⟩) t with u1 d=ef [a](λx.t1⟨[a]  t/a⟩) t. However, we can restrict a bit
the choice of the testing term t, based on its behavior. Let b ∈/ fn(t); if [b]t di-
verges, then u0 and u1 diverge as well, and we gain no information on [a]λx.t0 and
λx.t1 themselves. If [b]t →∗ [c]v with b /= c, then u0 →∗ [c]v⟨[a]λx.t0 ⟨[a]  t/a⟩ /b⟩,
v	v
and similarly with u1. The values [a]λx.t0 and [a]λx.t1 are captured by [b]t, and
no interaction between t and the two named values takes place in the process ([a]λx.t0 and [a]λx.t1 are not applied to any value); again, we do not gain any

new knowledge on the behavior of [a]λx.t0 and [a]λx.t1. Finally, if [b]t →∗
v,

then u0 →∗
[b](λx.t0⟨[a]  t/a⟩) v⟨[a]λx.t0 ⟨[a]  t/a⟩ /b⟩, and similarly with u1; in this

case, a value is indeed passed to [a]λx.t0 and [a]λx.t1, and we can compare their respective behaviors. Therefore, an interaction happens between t and the tested values iff [b]t →∗ [b]v, and the results of the interaction (after β-reduction) are the two terms in the clause below.
For all t, b, v such that [b]t →∗ [b]v and b ∈/ fn(t), we have
[a]t0⟨[a]  t/a⟩{v⟨[a]λx.t0 ⟨[a]  t/a⟩  /b⟩/x}≈ [a]t1⟨[a]  t/a⟩{v⟨[a]λx.t1 ⟨[a]  t/a⟩  /b⟩/x}.

Unfortunately, clause (2) is not enough to obtain a sound bisimilarity. The next example shows that an extra clause is needed.

Example 3.3 Let v0 d=ef λx.μb.[a](λy.λz.wy)x and v1 d=ef w with w d=ef λx.wj(xλy.y), and wj d=ef λy.y λz.Ω. We first show that [a]v0 and [a]v1 are related by clause (2).

Let t such that [b]t ↓v [b]v for b ∈/
fn(t).	Then we have ([a]v0)⟨[a] t/a⟩ →∗

[a]wj (v⟨[a]v0 ⟨[a]  t/a⟩ /b⟩ λx.x) and ([a]v1)⟨[a] t/a⟩ →∗ [a]wj (v⟨[a]v1 /b⟩ λx.x). We
can prove that the two resulting terms are contextually equivalent by showing that the relation {(u⟨[a]E [v0 ⟨[a]E [ t]/a⟩ ]/b⟩, u⟨[a]E [v1 ]/b⟩) | [b]t ↓v [b]v, b ∈/ fn(t)} is an ap- plicative bisimulation according to Definition 3.4, and by using Theorem 3.9 (see [3, Appendix B.1]). Because ([a]v0)⟨[a] t/a⟩ and ([a]v1)⟨[a] t/a⟩ are contextually equiv- alent, using only clause (2) would lead us to conclude that [a]v0 and [a]v1 are also equivalent.
However, these two named values can be distinguished with the context

[a](λx.x x) μa. , because in one case we have ([a]v0)⟨[a](λx.x x) /a⟩ →∗
λz.Ω, and

in the other ([a]v1)⟨[a](λx.x x) /a⟩ →∗
Ω.	As in Example 3.2, when evaluating

([a]v0)⟨[a](λx.x x) /a⟩, the body of v0 is evaluated twice, and two different contexts are captured each time. In contrast, v1 does not contain any control effect, so when its body is evaluated twice, we get the same result.
Example 3.3 shows that we have to compare two values [a]λx.t0 and [a]λx.t1 by also testing them with contexts of the form [a]v , i.e., by considering [a]v λx.t0⟨[a]v /a⟩ and [a]v λx.t1⟨[a]v /a⟩. If v = λx.t, then these terms reduce in one β-reduction step into [a]t{λx.t0⟨[a]v /a⟩/x}, and [a]t{λx.t1⟨[a]v /a⟩/x}. Taking this and clause (2) into account, we obtain the following definition of applicative bisimulation.
Definition 3.4 A relation Y on closed named terms is an applicative bisimulation if u0 Y u1 implies
if u0 →v uj , then there exists uj such that u1 →∗ uj and uj Y uj ;
0	1	v  1	0	1
if u0 = [a]λx.t0, then there exists t1 such that u1 →∗ [a]λx.t1, and:
for all t, b, v such that [b]t →∗ [b]v and b ∈/ fn(t), we have
[a]t0⟨[a]  t/a⟩{v⟨[a]λx.t0 ⟨[a]  t/a⟩  /b⟩/x}Y [a]t1⟨[a]  t/a⟩{v⟨[a]λx.t1 ⟨[a]  t/a⟩  /b⟩/x};
for all v = λx.t, we have
[a]t{λx.t0⟨[a]v  /a⟩/x}Y [a]t{λx.t1⟨[a]v  /a⟩/x};
the symmetric conditions on u1.
Applicative bisimilarity, written ≈, is the largest applicative bisimulation.
The definition is extended to regular terms t0, t1 as in CBN, by using a fresh top-level name a. Note that clause (ii) implies that a bisimulation Y is a congruence
w.r.t. (regular) values; indeed, if v0 Y v1, then [a]v0 Y [a]v1 for a fresh a, and so we have [a]t{v0/x} Y [a]t{v1/x} for all t (by clause (ii)). This property simplifies the congruence proof of ≈ with Howe’s method.
As in CBN, we can define a big-step version of the bisimulation (where we use evaluation instead of reduction), and bisimilarity contains reduction.

Lemma 3.5 We have →∗ ⊆ ≈.
The applicative bisimulation for CBV is more difficult to use than the one for CBN, as we can see by considering again the terms of Example 2.12.
Example 3.6 Let v = λx.t and a, b ∈/ fn(v); then [a]v ≈ [a]λx.μb.[a]v.	To
prove clause (i), we consider tj be such that [b]tj →∗ [b]vj for b ∈/ fn(tj); we have
to compare [a]t{vj⟨[a]v  /b⟩/x} with [a]μb.[a]v tj. But [a]μb.[a]v tj →v [a]v tj →∗
[a]t{vj⟨[a]v  /b⟩/x}, therefore we can conclude with Lemma 3.5.
For clause (ii), we have to relate [a]tj{v/y} and [a]tj{λx.μb.[a]vj v/y} for all vj = λy.tj. We proceed by case analysis on tj; the most interesting case is tj = E [yvjj]. In this case, we have [a]tj{λx.μb.[a]vj v/y} →∗ [a]vj v →v [a]tj{v/y}, therefore we can conclude with Lemma 3.5. To handle all the possible cases, we prove in [3,

Appendix B.1] that {(u{v/y}, u{λx.μb.[a]t0/y}) | [a]t0 →∗
u{v/y}} ∪ ≈ is an

applicative bisimulation.
In the next example, we give two terms that can be proved equivalent with applicative bisimilarity but not with eager normal form bisimilarity [19].

Example 3.7 Let u0 d=ef
[b]λxy.Ω, v d=ef
λy.μa.[b]λx.y, and u1 d=ef
[b]λxy.Θv v y,

where Θv d=ef (λxy.y (λz.xx y z)) (λxy.y (λz.xx y z)) is Turing’s call-by-value fixed- point combinator. For u0 and u1 to be normal form bisimilar, we need [c]Ω to be related to [c]Θv vy for a fresh c, but [c]Θv vy ↓v [b]λy.Θvvy and [c]Ω ⇑v. In contrast, we can prove that u0 ≈ u1 (see [3, Appendix B.1]).
We now briefly sketch the proofs of soundness and completeness; more details can be found in [3, Appendix B.2]. The application of Howe’s method is easier than in CBN because, as already pointed out, an applicative bisimulation (and, therefore, the applicative bisimilarity) is already a congruence for regular values by definition. What is left to prove is congruence for (named) terms. We use the same definitions of compatible refinement and Howe’s closure ≈• as in CBN. However, because ≈ is a congruence for values, we can prove directly that the restriction of
≈• to closed terms (written (≈•)c) is an applicative bisimulation, without having to prove a pseudo-simulation lemma (similar to Lemma 2.14) beforehand.
Lemma 3.8 The relation (≈•)c is an applicative bisimulation.
As in CBN, we can conclude that (≈•)c=≈, and therefore ≈ is a congruence. We can then deduce that ≈ is sound w.r.t. ≈c. For the reverse inclusion, we use an alternate definition of contextual equivalence where we test terms with evaluation contexts (see Definition 2.16), and we prove it is an applicative bisimulation. As a result, ≈ coincides with ≈c.
Theorem 3.9 ≈=≈c.
Remark 3.10 In [9], Koutavas et al. show that applicative bisimilarity cannot be sound in a CBV λ-calculus with exceptions, a mechanism that can be seen as a form of control. Our work agrees with their conclusions, as their definition of

applicative bisimilarity compares λ-abstractions by applying them to values only, and Example 3.2 shows that it is indeed not sufficient.
Examples
Even if applicative bisimulation for CBV is difficult to use, we can still prove some equivalences with it. Here we give some examples inspired from Sabry and Felleisen’s axiomatization of call/cc [16]. Given a name a, we write a† for the term λx.μb.[a]x, and we encode call/cc into λx.μa.[a]x a†. Given a named context E, we also write
E† for λx.μb.E[x], where b ∈/ fn(E). The first example is the axiom Ctail of [16],
where call/cc is exchanged with a λ-abstraction.
Example 3.11 If y ∈/ fv(t1) and b is fresh, then [b](λx.μa.[a]x a†) (λy.(λz.t0) t1) ≈
[b](λz.(λx.μa.[a]x a†) (λy.t0)) t1.
Proof. Let v0 d=ef λz.t0{b†/y} and v1 d=ef λz.(λx.μa.[a]xa†) (λy.t0). The term on the left reduces to [b]v0 t1, so we relate this term to the one the right, i.e., [b]v1 t1. We distinguish several cases depending on t1. Let c be a fresh name. If [c]t1 ↓v [c]v,
then [b]v0 t1 →∗ [b]t0{b†/y}{v⟨[b]v0  /c⟩/z} and [b]v1 t1 →∗ [b]t0{b†/y}{v⟨[b]v1  /c⟩/z};
v	v
because c is fresh, it does not occur in t0, and the previous terms can be written
u⟨[b]v0 /c⟩ and u⟨[b]v1 /c⟩ with u d=ef [b]t0{b†/y}{v/z}.
Similarly, if [c]t1 ↓v [d]v with c /= d, then [b]v0 t1 ↓v [d]v⟨[b]v0 /c⟩ and [b]v1 t1 ↓v [d]v⟨[b]v1 /c⟩. When testing these two values with clauses (i) and (ii), we obtain each time terms of the form u⟨[b]v0 /c⟩ and u⟨[b]v1 /c⟩ for some u. With this reasoning, we can prove that {(u⟨[b]v0 /c⟩, u⟨[b]v1 /c⟩) | u ∈ U 0} is an applicative bisimulation, by case analysis on u.	2
With the next example and congruence of ≈, we can prove the axiom Cabort.
Example 3.12 Let a /= b; we have [b]E [a† t] ≈ [b]a† t.
Proof. We prove that the relation Yd=ef {(u⟨[b]E [E† ]/c⟩, u⟨[b]E† /c⟩) | u ∈ U 0} is an applicative bisimulation by case analysis on u. For example, if u = [c]t and u ↓v [c]v,
then u⟨[b]E [E†  ]/c⟩ →∗ [b]E [E† v⟨[b]E [E†  ]/c⟩] →v E[v⟨[b]E [E†  ]/c⟩] and u⟨[b]E†  /c⟩ →∗
v	v
[b]E† v⟨[b]E†  /c⟩ →v E[v⟨[b]E†  /c⟩]. If E /= [d]  for all d, then the resulting terms
are in Y, otherwise we get two named values; when checking clauses (i) and (ii), we obtain terms of the form uj⟨[b]E [E'† ]/c⟩ and uj⟨[b]E'† /c⟩ that are in Y. The remaining cases are similar.	2
Example 3.13 [axiom Clift] We have [b]E [(λx.μa.[a]x a†) t] ≈ [b]E [t (λx.b† E [x])].
Proof. In this proof, we use an intermediary result, proved in [3, Appendix B.1]: if E = E0[E1 ], then E† ≈ λx.E† (E1 [x]).  The proof of the axiom itself is by

case analysis on t. An interesting case is when [d]t ↓v [d]λy.tj where d ∈/
fn(t).

Then [b]E [(λx.μa.[a]x a†) t] →∗ [b]E [(λx.μa.[a]x a†) λy.tj⟨[b]E [(λx.μa.[a]x a† ) ]/d⟩] →∗
v	v
[b]E [tj⟨[b]E [(λx.μa.[a]x a† )  ]/d⟩{E†/y}] (with E = [b]E ), and [b]E [t (λx.b† E [x])] →∗
[b]E [tj⟨[b]E [ (λx.b† E [x])]/d⟩{λx.b† E [x]/y}]. From the intermediary result, and be- cause ≈ is a congruence, we know that [b]E [tj{E†/y}] ≈ [b]E [tj{λx.b† E [x]/y}].

Hence, to conclude the proof, one can show that
{(u0⟨E[(λx.μa.[a]x a† )  ]/d⟩, u1⟨E[  (λx.E† E1 [x])]/d⟩) | u0 ≈ u1, E = E0[E1 ]}
is an applicative bisimulation.	2
Conclusion
In this work we propose a definition of applicative bisimilarity for CBN and CBV λμ-calculus. Even if the two definitions seem quite different, they follow the same principles. First, we believe it is essential for completeness to hold to relate pri- marily named terms, and then extend the definition to all terms, as explained when discussing Lassen’s definition of applicative bisimilarity (Section 2.5). The top-level names allow to keep track of how the top level is captured and manipulated in the compared terms.
Then, the idea is to test named values with elementary contexts, [a] t for CBN, and [a] t and [a]v  for CBV. In the CBV case, we slightly restrict the terms t tested when considering [a] t, but the resulting definition remains complex to use compared to CBN, as we can see with Examples 2.12 and 3.6. However, we provide counter-examples showing that we cannot simplify it further (see Examples 3.2 and 3.3). In CBV as well as in CBN, applicative bisimilarity is harder to use than eager normal form bisimilarity [19], but our relations are complete characterizations of contextual equivalence, and we can therefore prove equivalences of terms that cannot be related with normal form bisimilarity, such as David and Py’s example (see Example 2.20) and Example 3.7. To prove the equivalence between two given λμ-terms, one should start with the bisimulation of [19], and if it fails, try next our applicative (or environmental [3]) bisimulations.
We believe the relations we define remain complete w.r.t. contextual equivalence in other variants of the λμ-calculus (perhaps with some slight variations), such as λμ with different reduction semantics (like, e.g., in [4]), typed λμ-calculus [15], or de Groote’s extended calculus (Λμ-calculus [5]). However, any direct implications of this work for other calculi for abortive continuations such as the syntactic theory of control [6] are unclear and remain to be investigated. The reason is that our approach hinges on the syntactic notion of names, unique to the λμ-calculus, that allows one to keep track of the whereabouts of the top level.
Acknowledgments: We thank Wojciech Jedynak and the anonymous referees for helpful comments on the presentation of this work. The first author has been supported by the Polish NCN grant number DEC-011/03/B/ST6/00348.

References
S. Abramsky. The lazy lambda calculus. In D. A. Turner, editor, Research Topics in Functional Programming, pages 65–116. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 1990.
D. Biernacki and S. Lenglet. Applicative bisimulations for delimited-control operators. In L. Birkedal, editor, FOSSACS’12, number 7213 in LNCS, pages 119–134, Tallinn, Estonia, Mar. 2012. Springer- Verlag.


D. Biernacki and S. Lenglet. Sound and complete bisimilarities for call-by-name and call-by-value λμ- calculus. Research report RR-8447, Inria, Nancy, France, Jan. 2014. Available at http://hal.inria. fr/hal-00926100.
R. David and W. Py. λμ-calculus and B¨ohm’s theorem. Journal of Symbolic Logic, 66(1):407–413, 2001.
P. de Groote. On the relation between the λμ-calculus and the syntactic theory of sequential control. In
F. Pfenning, editor, LPAR’94, number 822 in LNAI, pages 31–43, Kiev, Ukraine, July 1994. Springer- Verlag.
M. Felleisen and R. Hieb. The revised report on the syntactic theories of sequential control and state.
Theoretical Computer Science, 103(2):235–271, 1992.
A. D. Gordon. Bisimilarity as a theory of functional programming. Theoretical Computer Science, 228(1-2):5–47, 1999.
D. J. Howe. Proving congruence of bisimulation in functional programming languages. Information and Computation, 124(2):103–112, 1996.
V. Koutavas, P. B. Levy, and E. Sumii. From applicative to environmental bisimulation. Electronic Notes in Theoretical Computer Science, 276:215–235, 2011.
S. B. Lassen. Bisimulation for pure untyped λμ-caluclus (extended abstract). Unpublished note, Jan. 1999.
S. B. Lassen. Eager normal form bisimulation. In P. Panangaden, editor, LICS’05, pages 345–354, Chicago, IL, June 2005. IEEE Computer Society Press.
S. B. Lassen. Head normal form bisimulation for pairs and the λμ-calculus. In R. Alur, editor, LICS’06, pages 297–306, Seattle, WA, Aug. 2006. IEEE Computer Society Press.
J. H. Morris. Lambda Calculus Models of Programming Languages. PhD thesis, Massachusets Institute of Technology, 1968.
C.-H. L. Ong and C. A. Stewart. A Curry-Howard foundation for functional computation with control. In N. D. Jones, editor, POPL, pages 215–227, Paris, France, Jan. 1997. ACM Press.
M. Parigot. λμ-calculus: an algorithmic interpretation of classical natural deduction. In A. Voronkov, editor, LPAR’92, number 624 in LNAI, pages 190–201, St. Petersburg, Russia, July 1992. Springer- Verlag.
A. Sabry and M. Felleisen. Reasoning about programs in continuation-passing style. Lisp and Symbolic Computation, 6(3/4):289–360, 1993.
D. Sangiorgi. The lazy lambda calculus in a concurrency scenario. In A. Scedrov, editor, LICS’92, pages 102–109, Santa Cruz, California, June 1992. IEEE Computer Society.
D. Sangiorgi, N. Kobayashi, and E. Sumii. Environmental bisimulations for higher-order languages.
ACM Transactions on Programming Languages and Systems, 33(1):1–69, Jan. 2011.
K. Støvring and S. B. Lassen. A complete, co-inductive syntactic theory of sequential control and state. In M. Felleisen, editor, POPL’07, SIGPLAN Notices, Vol. 42, No. 1, pages 161–172, Nice, France, Jan. 2007. ACM Press.
