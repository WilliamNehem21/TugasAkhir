Electronic Notes in Theoretical Computer Science 122 (2005) 229–245 
www.elsevier.com/locate/entcs


A Coalgebraic Semantic Framework for Component-based Development in UML
Sun Menga,1 , Bernhard K. Aichernigb, Lu´ıs S. Barbosac,2 and Zhang Naixiaoa,1
a LMAM, School of Mathematical Science, Peking University, Beijing, China
b International Institute for Software Technology, The United Nations University
c Department of Informatics, Minho University, Braga, Portugal

Abstract
This paper introduces a generic semantic framework for component-based development, expressed in the unified modelling language UML. The principles of a coalgebraic semantics for class, object and statechart diagrams as well as for use cases, are developed. It is also discussed how to for- malize the refinement steps in the development process based upon a suitable notion of behavior refinement. In this way, a formal basis for component-based development in UML is studied, which allows the construction of more complex and specific systems from independent components.
Keywords: Unified modeling language, refinement, UML, coalgebras


Introduction
Component-based development [22] became accepted in industry as a new ef- fective paradigm and widely considered the cornerstone of software engineering in the years to come. Within the component-based paradigm a system con- sists of a collection of components. Each component is a unit of composition

1 This piece of research is partially supported by the National Natural Science Foundation of China under grant no. 60273001.
2 The	work	of	Lu´ıs	S.	Barbosa	is	supported	by	FCT,	under	contract
POSI/ICHS/44304/2002, in the context of the PURe project.


1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.051


with contractually specified interfaces. It can be deployed independently and is subject to composition by third parties.
It has been widely recognized that component-based development is a rather intricate activity and there is still no general agreement on precise definitions of both components and component assembly. Thus the need for formal foundations of component-based development was identified, especially in relation to widely used component-oriented design notations such as UML [20].
The starting point of the research reported here is the observation that coalgebraic structures [11,21] may provide not only a powerful semantic do- main for componentware, but also handy techniques for defining and reasoning about system’s behavior, including a general notion of (bi)simulation and a coinduction proof principle. Therefore, this paper aims to a semantic frame- work in which the most popular notations used in UML can be mapped, in order to provide a basis for rigorous component-based development. The pa- per begins with a brief glimpse of the “components as coalgebras” approach, proposed by the authors in a series of previous papers [1,2,3]. This is followed, in Section 3, by a coalgebraic characterization of some crucial diagrams used in UML. In Section 4, the author’s previous work on refinement of coalgebraic models discussed in [15], is framed to entail appropriate notions of refinement of UML models. This enables not only the formalization of (parts of) UML descriptions but also of its transformations as a basis for stepwise separate development. Finally, the prospects for future work are discussed in Section 5.

Components as Coalgebras
In this section we introduce a coalgebraic model for state-based components, following closely the “components as coalgebras” approach proposed by L. Bar- bosa et al in [1,2,3]. This approach provides an observational semantics for software components and a generic assembly calculus, in the sense that the proposed constructions are parametric on a notion of component behavior.
Components interact with their environment via interfaces. Every interface provides a set of typed channels for receiving and sending messages, acting as a type for the corresponding component.
Definition 2.1 Let I and O be sets of typed input and output channels, respectively. The pair (I, O), denoted by I ► O, is called an interface and
any component p with such an interface is typed as p : I → O.
In the simplest, deterministic case, the behavior of a component p is cap-


tured by the output it produces, which is determined by the supplied input. But reality is often more complicated, for one may have to deal with com- ponents whose behavioral pattern is, e.g., partial or even non deterministic. Therefore, to proceed in a generic way, the behavior model is abstracted to a strong monad B. Of course, B = Id retrieves the simple deterministic behav-
ior, whereas B = P or B = Id + 1 would model non deterministic or partial behavior, respectively. Therefore, a component p : I → O can be modelled by a coalgebra for the Set endo-functor TB = B(Id × O)I. In this way, its computation will not simply produce an output and a continuation state, but
a B-structure of such pairs. Formally, such a component p is modelled as a pointed concrete coalgebra
⟨Up, αp : Up → B(Up × O)I, u0 ∈ Up⟩
dynamics is captured by currying the state-transition function αp : Up × I → where a specific value u0 is taken as its ‘initial state’ (or ‘seed’) and the B(Up × O).
terns. For each state value u ∈ Up, the behavior of p at u (more precisely, from Successive observations of a component p reveal its allowed behavioral pat- u onwards) organize itself into a tree-like structure, because it depends on the
sequences of input items processed. Such trees, whose arcs are labelled with I values and nodes with O values, can be represented by functions from non empty sequence of I to B-structures of output items. In other words, the space of behaviors of a component with interface I ► O is the set (BO)I+ , which is in
fact the carrier νT of the final TB-coalgebra (νT, ωT : νT → TBνT). Therefore,
by finality, from any other TB-coalgebra p, there is a unique morphism [(p)]
making the following diagram to commute:
ν	ωT) B(ν × O)I

ˆ
[(p)]
ˆ
B([(p)] × O)I

U	αp) B(U × O)I
Applying morphism [(p)] to a state value u ∈ Up gives the observable behavior
strong monads like P and Id + 1, it is possible to model different behavior of a sequence of p transitions starting at u. By instantiating B with concrete patterns such as non-determinism and partial behavior respectively.
Having defined generic components as concrete coalgebras, one may nat- urally wonder how do they get composed and what kind of calculus emerges from this framework. Components are “arrows” and so arrows between com- ponents are “arrows between arrows”, which motivates the adoption of a bi-


egory Cp is built whose objects are the interface universes I, O, ··· , arrows categorical framework to structure our semantic universe. In brief, a bicat- are seeded concrete coalgebras and 2-cells (arrows between arrows) are the
corresponding coalgebra morphisms. 2-cell composition is inherited from Set
of p. Then for each pair ⟨I, O⟩ of objects, the construction of Cp defines a and the identity on component p is defined as the identity idUp on the carrier hom-category Cp(I, O), whose arrows
h : ⟨Up, αp : Up → B(Up × O)I, up ∈ Up⟩→ ⟨Uq, αq : Uq → B(Uq × O)I, uq ∈ Uq⟩
are maps h : Up → Uq that satisfy the following conditions:
αq · h = TBh · αp  and  hup = uq
For each triple of objects ⟨I, K, O⟩, a composition law is given by a functor:
;I,K,O : Cp(I, K) × Cp(K, O) → Cp(I, O)
whose action on components p and q is given by
p; q = ⟨Up × Uq, αp;q, ⟨up, uq⟩∈ Up × Uq⟩
where αp;q : Up × Uq × I → B(Up × Uq × O) is detailed as follows 3 :

αp;q
: Up × Uq × I
−−=−→ U × I × U
αp ×id
−−−→ B(Up × K) × Uq

−−τ−r→ B(U
× K × U )	∼=
B(U × (U
× K))

p
B(id×αq )
q	−−−→
p	q
Bτl

−−−−−→ B(Up × B(Uq × O)) −−−→ BB(Up × (Uq × O))

−−=−→ BB(U × U × O)
µ
−−−→ B(Up × Uq × O)

The action of “;” on 2-cells is simply given by h; k = h × k. Finally, for
each object K, an identity law is given by a functor copyK : 1 → Cp(K, K), whose action on objects is the constant component ⟨1, αcopyK , ∗∈ 1⟩, where αcopyK = η1×K. Similarly, the action on morphisms is the constant morphism
id1.
Besides the ‘pipeline’ sequential composition defined above, components can be aggregated in a number of different ways. A calculus emerges in [2] from the structure of Cp including a ‘wrapping’ combinator as well as combinators capturing external choice p ☒ q, parallel composition p ☒ q and concurrent composition p q. Finally, generalized interaction is catered through a sort of ‘feedback’ mechanism on a subset of input ends.

3 Notice that µ is the monad multiplication, η its unit and τr and τl the right and left strengths, respectively.

A Formal Semantics for UML
The central idea of our research on the formalization of UML is that a set of UML diagrams denote coalgebraic specifications as introduced by Jacobs [8,9]. More precisely, we intend to translate all the graphical symbols and annotations in the UML syntax, into functors and properties of a coalgebraic specification. Therefore standard definitions in universal coalgebra, such as bisimilarity and refinement, become available to reason and transform UML designs.

Class Diagrams
One of the main components in a UML description (as presented in [17]) is the class diagram. A class diagram shows the static structure of a system, consisting of a set of classes and relationships between them.
In UML, a class is an abstract description of a set of objects with similar structure, behavior and relationships. The description of a class includes the attributes and operations common to all of the objects belonging to it. Every object o of a class C in a system has an identifier ido which is unique within the system. We denote the set of all identifiers by Id. Therefore, an object o : C is
represented as a triple o = (ido, UC, αC : UC → T(UC)) where UC is the state
space of class C, which consists of all the possible states for a C-object, and T
is a functor encapsulating a signature of attributes and methods. During the lifetime of an object, its local state u may change over the state space UC, but its identifier ido, UC itself and the transition structure αC remain the same.
Following the work of Jacobs et al [7,8,19] on coalgebraic semantics, every class in a UML class diagram is taken as a coalgebraic specification Spec, i.e.,
Definition 3.1 A coalgebraic specification Spec is a tuple (T, Φ, Ψ) in which:
T is a functor on a local state space U , representing the signature of all the attributes and methods of the class;
Φ is a set of axioms giving the constraints on the functors for the attributes and methods to characterize the properties of the class;
Ψ is an axiom describing the properties that hold for newly created objects.

(T, Φ, Ψ) is a triple c = (U, α : U → T(U ), u0), where U is a carrier set A model (class implementation) of a given class specification Spec = interpreting the state space of the class, α : U → T(U ) is the transition struc- ture which satisfies all the properties given by Φ and u0 ∈ U is an initial state satisfying Ψ.
The semantics of a concrete class C in a UML class diagram is defined


as the category Coalg(Spec), whose objects are models of the corresponding coalgebraic class specification Spec and the arrows are initial state preserving homomorphisms between them. Formally,


[[C]]
=∆ Coalg(T , Φ , Ψ )	if isAbstract(C)= F alse

where (TC, ΦC, ΨC) is the specification of class C and the boolean value func- tion isAbstract specifies whether the class C can be directly instantiated. This category is a subcategory of Cp, defined in the previous section. In detail, its objects are
Obj(Coalg(TC, ΦC, ΨC)) = {c = (UC, αC : UC → TC(UC), u0 ∈ UC) |
(c |= ΦC) ∧ (c, u0 |= ΨC)}
where c |= ΦC means that all the axioms in ΦC are satisfied by coalgebra c and c, u0 |= ΨC means that the properties in ΨC are satisfied by the initial state u0 of c. Their formalization is immaterial for the purposes of the present
paper.
Let us now look at the specification of attributes. The default UML syntax
is
visibility name: type-expr[multiplicity ordering] = initial value{property-string}
Therefore, the semantic function of an attribute At in class C is defined as
follows:

[[v At : T [m]= i{p}]]
=∆ {At : U → T (U ) | [[At[m]]] ∧ [[At = i]] ∧ [[At{p}]]}

where TAt = P[[T ]], with P standing for the powerset functor, which is required
to model attribute’s multiplicity (it can be dropped whenever the multiplicity
is exactly one). The semantics for multiplicity of an attribute At in class C is


[[At[m]]] =∆
∀u ∈ UC . card(At(u)) = m

or, if specified as a range,
[[At[l..k]]] =∆
∀u ∈ UC .l ≤ card(At(u)) ≤ k

The initial value is used for initializing the attribute of a newly created object.
Hence,

[[At = i]]
=∆ ∀(U ,α ,u ) ∈ Obj([[C]]).At(u )= i

C	C	0	0
The optional property string indicates property values of the attribute, like changeability. Due to length restrictions, we omit its semantics as well as the


Fig. 1. Association

semantic functions for visibility of attributes, operations, interfaces, etc. which can be found in [14]. Note that in this framework attributes and operations are very similar: only the form of the signature functor changes. The distinction lies in the difference between observation and computation, only the latter being the source of change in object states.
An association in a class diagram describes the connections among objects in a system. It may have two or more association ends. Figure 1 shows an example of an association.
Suppose SpecU and SpecV are the class specifications of classes U and V in a class diagram and A is a binary association between them. Also assume that c = (U, α, u0) and d = (V, β, v0) are objects in Coalg(SpecU) and Coalg(SpecV) respectively. Then association A, which connects the two
coalgebras, can be interpreted 4 as a space SA ⊆ P((Id × U ) × (Id × V )).
being in the same state. An element s ∈ SA is a state of the association Identifiers in the set Id are necessary to distinguish objects of the same class which records a set of object pairs linked by the association simultaneously at
the individual states paired at s. Every pair of objects in SA is called a link between them.
Every association has three basic components: a name, a role and the multiplicity at each of its ends. The semantics for an association is given by the corresponding observers in each of the classes being related by the association. Let A be such an association between classes U and V. The role names and multiplicities on the two ends are, respectively, uA, vA, and mU , mV , the later being two sets of non-negative integers. Then the semantics of A is defined as a pair of the coalgebraic observers:
(uA : (Id × V ) → P(Id × U ), vA : (Id × U ) → P(Id × V ))	(1)
where U and V are the statespaces of coalgebras (U, α : U → TU (U ), u0) and (V, β : V → TV (V ), v0) corresponding to the semantics of classes U and V. Furthermore, the two coalgebraic observers must be related as follows:
oU ∈ uA(oV ) ⇔ oV ∈ vA(oU )	(2)
4 strictly speaking, what is connected by the association A are their classes: and the two
coalgebras are connected by a link of A.


Summing up, the semantics of an association is given by the pair of ob- servers in (1) which satisfies (2):

[[UuA 	 vA V]] =∆ {(u
, vA) | (2)}

The UML specification [17] states that each association end has a multiplicity
constraint (may be unspecified in an incomplete model) which is “a subset of the open set of non-negative integers”. Should multiplicity be given explicitly in the diagram, the semantic function will become:


[[UuA 	 vA V]] =∆ {(u
mU A mV	A
, vA) | (2) ∧ (∀oU
: Id × U.(card(vA
(oU
)) ∈ mV
))∧

(∀oV : Id × V.(card(uA(oV )) ∈ mU ))}
There is an entire family of optional properties that is provided by UML
and may be given to associations in a class diagram. For example, UML allows an association to have its own attributes, which is represented by an associa- tion class, i.e., an association which is also a class. Generally, an association class can be represented as a class with two one-to-many associations.
Therefore, the semantics of an association class is defined by the tupling of the semantics of this class together with the semantics of the two associations, as follows:


[[UuV 	 vU V]] =∆ {(ac, (u
,a ), (a ,v )) | ac ∈ Obj([[AC]])∧

mU AC mV
A	U	V	A

(uA, aU ) ∈ [[UuA −aU AC]] ∧ (aV , vA) ∈ [[ACaV  −vA V]]∧
1	mV	mU	1
∀oU : Id × U, oV : Id × V.((oV ∈ vU (oU ) ⇔
∃!oA : Id × AC.oV = vA(oA) ∧ oA = aU (oU ))∧
(oU ∈ uV (oV ) ⇔ ∃!oA : Id × AC.oU = uA(oA) ∧ oA = aV (oV )))}
The last predicate ensures the wellformedness of the object links via AC in
both directions. Let us now turn to the semantics of generalization.
Generalization in a class diagram describes the inheritance relationship between a general class (superclass) and a more specialized class (subclass). The fact that a class D is a subclass of C in a class diagram is represented as
C D−−− D. It is also said that D inherits from C.
functor G : Coalg(D) → Coalg(C) between the corresponding categories If there is such an inheritance relationship between D and C, a forgetful of models can be derived as shown in [7]. In our framework, the semantics
of the generalization relationship in UML class diagrams is given by the col- lection of all the possible inheritance morphisms between the models of the

corresponding class specifications, i.e.,
[[C D−−− D]] =∆ {g : d → c | d ∈ Coalg(D) ∧ c ∈ Coalg(C)}
where g is the inheritance morphism from d to c. Such a morphism con-
sists of a forgetful functor and a natural transformation between the functors corresponding to the two classes.
Generalization relations organize classes into a lattice, with the most gen- eralized class at the top of the hierarchy (eventually an abstract class). The meet and join operators are defined as the superclass and subclass (for mul- tiple inheritance) of classes respectively. Note that an abstract class may not have direct instances, and, therefore, it can not be interpreted in the same way as a concrete class. However, from the generalization relationship between an abstract class and its subclasses, its semantics can be recovered as the smallest superclass of all of its subclasses (or the least upper bound in the lattice of classes). Translated to category theory this means that the semantics of an abstract class with respect to its subclasses is the colimit of the corresponding subclass coalgebras, i.e.,
[[C{Abstract} D−−− ∗{C , C ,... , C }]] =∆ Colimit	(c ,c ,... ,c )
1	2	n	Cp  1  2	n
where ci are the coalgebras in [Ci ] respectively.
Object Diagrams and Class Diagrams
We may now sum up the previous discussion, centered at the class level, in order to give the semantics of class diagrams, which is defined via object diagrams.
An object diagram is a snapshot of the corresponding class diagram. It exhibits a set of objects and their relationships in a system at a specific point in time. These objects and their relationships are semantically defined as above.
system state σ ∈ Σ and can be seen as an instance of the corresponding class Thus, denoting the system state space by Σ, an object diagram represents a diagram. Therefore, an element σ ∈ Σ is interpreted as the product of states
of different objects at the same point in time.
Then, the system can be modelled as a coalgebra c = (Σ,α :Σ → T(Σ)), where α describes all the possible transitions between system states. Formally,

egory Coalg(CD), whose objects are coalgebras (Σ,c : Σ → T(Σ)), where Definition 3.2 The semantics of a class diagram CD is defined by the cat- Σ is the system state space which contains all the possible system states. T
is the tensor product of all the signature functors of the component classes


and associations in the class diagram, which describes the possible system state transitions and observations. The arrows are T-homomorphisms between them.

Use Cases
In UML, use cases describe functional requirements. A use case is defined as “a sequence of transactions in a system, whose task is to yield a measurable value to an individual actor of the system” [12]. Thus, we can interpret a use case coalgebraically as a sequence of actions followed by some (eventu- ally combined) observations. Single actions represent atomic use cases which change the system from one state to another. Such actions include creating new objects and deleting old objects, forming or deleting links between objects or modifying attribute values of objects.
The signature of an atomic use case is again defined by a functor T. Let Σ
a use case is interpreted as a function uc : Σ → T(Σ). An example should be the system state space, as defined in the semantics of class diagrams. Then demonstrate the coinductive formalization of use cases.
Consider a use case BB describing the process of borrowing a book in a library (see [14] for the complete example) as specified in Figure 2.
defined by a coalgebraic function bb :Σ → ΣStudent×Book. If student s0 borrows Let Σ be the state space of the system. Then the behavior of BB can be book b0, then the observable effects can be specified coinductively:
pre ▶ loans(s' (bb(σ, s0, b0))) = loans(s' (σ)) ∪ {b0}
0	0
pre ▶ borrower(b' (bb(σ, s0, b0))) = s' (σ)
0	0
where s' , b' are observers on Σ for obtaining the objects s0, b0 and σ ∈ Σ.
0  0
Notice that, the purpose of precondition pre is to guarantee the multiplicity
constraints in the class diagram.
In addition to the system operations, an actor may also perform other actions to change the system state. So use cases are more generically specified by integrating the system actions and actor actions together. How can this be specified in our framework? The component calculus mentioned in section 2 provides a set of combinators (notably, for sequential and parallel composition) which can be used for getting more complex use-cases from composing atomic ones. For example, the use case BB is defined as a sequential composition of the atomic actions corresponding to events 1 and 2, another use case for returning a book, corresponding to event 3, when the condition is true, and event 4.


Fig. 2. Borrow Book use case
Statechart Diagrams
In UML statechart diagrams describe the dynamic behavior of systems. Sev- eral formal semantics for statechart diagrams have been proposed previously. For example, in [13] input-output labelled transition systems are used as the semantic domain. Our aim is to give a coalgebraic characterization of stat- echarts, so that consistency checks between class diagrams and statechart diagrams became proofs that the coalgebra (statechart) is a model of the corresponding coalgebraic specification (class diagram). Similarly, refinement (implementation) relations can be defined ranging over different view models. Because of the hierarchical structure of statecharts, we will endow the set of configurations with a coalgebraic structure induced by the operational semantics rather than simply construct the coalgebraic structure over the set
of states. Functor T captures the shape of such a coalgebra:
T(X)= B(X × PE)E
where E denotes the set of all events — notice that events, at this stage, may
have parameters rather than remaining just primitive signals. B is a strong monad which specifies the behavior pattern of the statechart (typically the powerset monad). For a given statechart SC, let CF be the set of configura-
tions and (CF, α : CF → T(CF )) the corresponding T-coalgebra. Hence, the behavior of SC is given by
[[SC]] : λs : CF . α(s)
Note that directly defining the coalgebraic semantics may lead to a more faithful model, since we have the freedom to choose the signature functor appropriately. Concerning verification, the coalgebraic approach often allows for a smaller state space, when compared with direct encoding as a Kripke


structure, and makes the verification of system properties more effective (as shown by D. Pattinson in [18] ). A detailed discussion can be found in [16]. Furthermore, the generic notion of component refinement, proposed by the authors in [15], can be adapted to the context of UML and used for checking consistency of different models. Such is purpose of the following section.


Refinement
To make proper use of UML models in a development process we need a clear notion of refinement between components clarifying what it means for a component to implement another. Orthogonal to the horizontal decompo- sition of the system structure, the vertical refinement of concrete components from abstract ones provides an approach for stepwise separate development of component-based systems. In the coalgebraic framework sketched in this paper, three kinds of refinement relations between components can be de- fined. In any case the semantic mapping defined for UML models makes them associated with a proper refinement ordering.
Behavioral reﬁnement, which typically relates components of the same inter- face, where the refinement is based on a simulation preorder between the two components. Since morphisms between components of the same interface are in fact coalgebra homomorphisms which, therefore, entail bisimilarity, we must seek for a weaker notion of a morphism between components, still preserving the source component dynamics. Concerning UML, this kind of refinement is mainly used for refinement of behavioral models, especially, for statechart diagrams.
Interface reﬁnement, which is concerned with what one may call plugging compatibility. It relates components of different interfaces, and the ques- tion is whether a component can be transformed, by suitable wiring, to replace another component with a different interface. As the structure of components interface types encodes the available operations, this may cap- ture situations of extension of component’s functionality, in the sense that the ‘concrete’ component may introduce new operations, and is used for development with conceptual models, i.e., class diagrams and use cases.
and architectural reﬁnement, which is used for decomposing a component with a specified behavior into a distributed system architecture, i.e., a family of components combined in parallel, which is also modelled as a concrete coalgebra. Such a notion of refinement is mainly used in the development of system architectures, i.e., for component and deployment diagrams.


We say that a component p behaviorally refines component q if the behav- ioral patterns observed for p are a structural restriction, with respect to the behavioral model captured by monad B, of those of q. To make such a ‘defi- nition’ more precise we describe behavioral patterns concretely as generalized transitions. Thus a possible (and intuitive) way of regarding component p as a behavioral refinement of q is to consider that p transitions are preserved in q. For non deterministic components this is understood simply as set inclusion. But one may also want to consider additional restrictions. For example, to stipulate that if p has no transitions from a given state, q should also have no transitions from the corresponding state(s). Recall that a component mor-
phism from p to q is a seed preserving function h : Up −→ Uq such that B(h × id) · αp = αq · (h × id). In terms of transitions, this equation is trans- lated into the following two requirements (by a straightforward generalization
of an argument in [21]):

⟨i,o⟩	'	⟨i,o⟩	'

u −→p u
⟨i,o⟩
h u −→q v
⇒ h u −→q h u 
⟨i,o⟩
⇒ ∃u'∈U s.t. u −→p u
∧ u'

= h v'
(3)
(4)

which capture the fact that, not only p dynamics, as represented by the in-
duced transition relation, is preserved by h (3), but also q dynamics is reflected
back over the same h (4).
To define a weaker notion of coalgebra morphism, let ≤ be an order on a preorders  ≤TU ),  referred  to  as  a  reﬁnement  preorder.  Then, Set endo-functor T [10] (concretely, mapping every set U into a collection of
two T-coalgebras p = (U, α : U → T(U )) and q = (V, β : V → T(V )). A Definition 4.1 Let T be an extended polynomial functor on Set and consider forward morphism h : p → q with respect to a refinement preorder ≤, is a
function from U to V such that
T h · α ≤ β · h
The existence of a forward morphism connecting two components p and
q witnesses a refinement situation whose symmetric closure coincides, as ex- pected, with bisimulation. In the sequel we define behavioral reﬁnement as the existence of a forward morphism up to bisimulation 5 . Formally,
Definition 4.2 Given components p and q, p is a behavioral reﬁnement of q,

5 In [15] the dual notion of a backwards morphism, i.e., one that satisfies β · h ≤ T h · α, is also studied, leading to a notion of backward refinement which do have some applications, although the underlying intuition seems less familiar.


written p ±B q, if there exist components r and s such that p ∼ r, q ∼ s and there exists a (seed preserving) forward morphism from r to s.
Behavioral refinement characterizes the preservation of component behav- ior. But if we rely solely on behavioral refinement, the inability to change the syntactic interface will force us to work at the same level of interface abstrac- tion throughout the whole development process. To avoid this, a more general notion of refinement, called interface refinement is introduced, which relates components with different interfaces.
Definition 4.3 Let p : I → O and q : I' → O' be components. If there exist functions w1 : I' → I and w2 : O → O', such that
p[w1, w2] ±B q
the  upwards  function  w2,  written  as  p  ±(w1 ,w2)   q. then p is an interface reﬁnement of q modulo the downwards function w1 and
Interface refinement supports the systematic construction of new compo- nents from existing ones. Generally, for any component p, and functions w1, w2,
p ±(w1 ,w2) p[w1, w2]
One situation where this technique is useful is when we have an already com-
pleted off-the-shelf component and want to adapt the syntactic interface of this component to fit some context requirements. Therefore, interface refinement provides a systematic pattern for interface adaptation of components.
Both kinds of refinement relations introduced above are defined with re- spect to the underlying black-box behavior of components. However, when we develop a system, it is certainly not enough to characterize its black-box behavior only, we also need to capture some internal structural aspects. For this purpose, we introduce the notion of architectural reﬁnement.
For this let us define an architecture as a tuple S = ⟨I, O, C, R⟩ where I
and O are the input and output interface of the system, respectively, C =
{pk = ⟨Uk, αk, uk⟩}k=1,2,··· ,n denotes a finite set of components, and R denotes a finite set of combinators together with the components being combined by
them. In fact, systems can be decomposed hierarchically, and regarded as ordinary components again, which means that the notion of behavioral re- finement remains applicable. The architectural refinement relation is then therefore defined as a behavioral refinement within the given interface:
Definition 4.4 Let S and S' be two systems. If I = I', O = O', and [S]] ±B [[S']], then we say that S is an architectural refinement of S', written as S ±A S'.


The most obvious use of a notion of refinement is to compare two alterna- tive designs for the same component. We take every design as a separate model in UML and compare them at the semantic level by defining their semantics as coalgebras. For M1 and M2 UML models, we define
M1 ±B M2 ⇔ [[M1]] ±B [[M2]]
M1 ±(w1 ,w2) M2 ⇔ [[M1]] ±(w1 ,w2) [[M2]] M1 ±A M2 ⇔ [[M1]] ±A [[M2]]
Another use of the refinement order is to check the consistency between models of the same system.

Conclusions and Future Work
We have presented a generic semantic framework for component-based devel- opment starting from UML descriptions, extending previous work on com- ponentware detailed on a series of papers under the slogan “components as coalgebras” [1,2,3,15], where components are made generic in the sense that their behavioral patterns are described by strong monads acting as parame- ters in the calculus. Essential parts of a coalgebraic semantics for UML class diagrams have been presented in this paper. It has been shown in detail how classes, associations and generalizations in a UML diagram can be interpreted as coalgebraic specifications. Furthermore an outlook on the formalization of object, use-case and statechart diagrams has also been given. Although, space limitation preclude a more technical discussion of other diagrams, the reader should by now get an idea how a coalgebraic semantics facilitate the integration of static and dynamic aspects of UML.
Another major aspect of our framework is refinement, which formalizes the replaceability of components. Refinement is a very basic idea in sequential pro- gramming whose foundations can be traced back to Hoare’s landmark paper
[6] (see [5] for a recent account). However, for component-based systems, the situation is far more complex (see, e.g., [4]). In this paper we investigated re- finement at three, inter-related, levels: behavioral, interface and architectural level. Our framework allows the notion of refinement to change the interface and granularity of components.
A major influence in our work was Jacobs and Tews research on object- oriented systems [8,9,23]. However, instead of defining and resorting to a spe- cific (coalgebraic) specification language (Ccsl), we adopt a rather pragmatic approach: that of using UML diagrams to denote coalgebraic specifications. Another difference between our work and the formalization of UML in [23] is that we do not restrict ourselves to class diagrams.


Actually, this paper intends to be a step towards a unifying coalgebraic semantics for UML. Currently, our research programme includes further work on use cases, statechart diagrams, and suitable notions of consistency among UML models. Further UML elements, such as interaction diagrams, will be addressed at a later stage. The calculus provided in the framework is a promis- ing candidate to model the interactions. However, having a formal semantics is not enough. The next step will involve research on applications of the seman- tics: our long term research aim is to propose a use-case driven development method for UML designs, supported by algebraic laws and coinductive proof methods. On the technological side, the approach will be supported by a combination of a model checker and a test-case generator for UML diagrams.

References
Lu´ıs S. Barbosa. Towards a Calculus of State-based Software Components. Journal of Universal Computer Science, 9(8):891–909, August 2003.
Lu´ıs S. Barbosa and Jos`e Nuno Fonseca de Oliveira. State-based components made generic. In H. Peter Gumm, editor, Elect. Notes in Theor. Comp. Sci. (CMCS’03 - Workshop on Coalgebraic Methods in Computer Science), volume 82.1, Warsaw, April 2003.
Lu´ıs S. Barbosa and Sun Meng. Generic components. In Graham Hutton, editor, Proceedings of First APPSEM-II Workshop, Nottingham, March 2003. APPSEM Network Report.
Manfred Broy and Ketil Stølen. Speciﬁcation and development of interactive systems : focus on streams, interfaces, and reﬁnement, volume 62 of Monographs in computer science. Springer, 2001.
Willem-Paul de Roever and Kai Engelhardt. Data Reﬁnement: Model-Oriented Proof Methods and their Comparison. Cambridge University Press, 1998.
Charles Antony Richard Hoare. Proof of correctness of data representations. Acta Information, 1:271–281, 1972.
Bart Jacobs. Inheritance and cofree constructions. In P. Cointe, editor, European Conference on Object-Oriented Programming, volume 1098 of LNCS, pages 210–231. Springer, Berlin, 1996.
Bart Jacobs. Objects and classes, co-algebraically. In B. Freitag, C. Lengauer C.B. Jones, and H.-J. Schek, editors, Object-Orientation with Parallelism and Persistence, pages 83–103. Kluwer, 1996.
Bart Jacobs. Exercises in coalgebraic specification. In R. Backhouse, R. Crole, and J. Gibbons, editors, Algebraic and Coalgebraic Methods in the Mathematics of Program Construction, volume 2297 of LNCS, pages 237–280. Springer, 2002.
Bart Jacobs and Jesse Hughes. Simulations in coalgebra. In H. Peter Gumm, editor, Elect. Notes in Theor. Comp. Sci. (CMCS’03 - Workshop on Coalgebraic Methods in Computer Science), volume 82, pages 245–263, Warsaw, April 2003.
Bart Jacobs and Jan Rutten. A tutorial on (co)algebras and (co)induction. Bulletin of the European Association for Theoretical Computer Science, 62:222–259, 1997.
Ivar Jacobson. Object Oriented Development in an Industrial Environment. In Norman K. Meyrowitz, editor, Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA’87), October 4-8, 1987, Orlando, Florida, Proceedings, volume 22 of SIGPLAN Notices, pages 183–191, 1987.


Diego Latella, Istvan Majzik, and Mieke Massink. Towards a formal operational semantics of UML statechart diagrams. In Proc. FMOODS’99. Kluwer, 1999.
Sun Meng and Bernhard Aichernig. Towards a Coalgebraic Semantics of UML: Class Diagrams and Use Cases. Technical Report 272, UNU/IIST, January 2003.
Sun Meng and Lu´ıs S. Barbosa. On Refinement of Generic State-based Software Components. In Proceedings of 10th International Conference on Algebraic Methods And Software Technology, AMAST’04, LNCS. Springer, 2004.
Sun Meng, Zhang Naixiao, and Lu´ıs S. Barbosa. On Semantics and Refinement of Statecharts: A Coalgebraic View. In Proceedings of 2nd IEEE International Conference on Software Engineering and Formal Methods. IEEE Computer Society Press, 2004.
OMG. OMG Uniﬁed Modeling Language Speciﬁcation, Version 1.4 , 2001.
Dirk Pattinson. Coalgebraic techniques in modelchecking, 2001. Available from http://siskin.pst.informatik.uni-muenchen.de/ pattinso/Publications/.
Horst Reichel. An approach to object semantics based on terminal co-algebras. Mathematical Structures in Computer Science, 5:129–152, 1995.
James Rumbaugh, Ivar Jacobson, and Grady Booch. The Uniﬁed Modeling Language Reference Manual. Addison Wesley Longman, 1999.
Jan Rutten. Universal coalgebra: a theory of systems. Theoretical Computer Science, 249:3–80, 2000.
Clemens Szyperski. Component Software – Beyond Object-Oriented Programming. Addison- Wesley, 1998.
Hendrik Tews. Coalgebraic Methods for Object-Oriented Speciﬁcation. PhD thesis, TU Dresden, 2002.
