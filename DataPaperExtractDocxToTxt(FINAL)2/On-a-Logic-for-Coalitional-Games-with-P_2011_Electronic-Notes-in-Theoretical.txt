Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 278 (2011) 215–228
www.elsevier.com/locate/entcs

On a Logic for Coalitional Games with Priced-Resource Agents
Dario Della Monica 1 Margherita Napoli 2 Mimmo Parente3
Dipartimento di Informatica Universit`a di Salerno
Italy

Abstract
Alternating-time Temporal Logic (ATL) and Coalition Logic (CL) are well-established logical formalisms particularly suitable to model games between dynamic coalitions of agents (like e.g. the system and the environment). Recently, the ATL formalism has been extended in order to take into account boundedness of the resources needed for a task to be performed. The resulting logic, called Resource-Bounded ATL (RB-ATL), has been presented in quite a variety of scenarios. Even if the model checking problem for extensions of ATL dealing with resource bounds is usually undecidable, a model checking procedure for RB-ATL has been proposed. In this paper, we introduce a new formalism, called PRB-ATL, based on a different notion of resource bounds and we show that its model checking problem remains in EXPTIME and has a PSPACE lower bound.
Then, we tackle the problem of coalition formation. How and why agents should aggregate is not a new issue and has been deeply investigated, in past and recent years, in various frameworks, as for example in algorithmic game theory, argumentation settings, and logic-based knowledge representation. We face this problem in the setting of priced resource-bounded agents with the goal specified by an ATL formula. In particular we solve the problem of determining the minimal cost coalitions of agents acting in accordance to rules expressed by a priced game arena and satisfying a given formula. We show that such problem is computationally not harder than verifying the satisfaction of the same formula with fixed coalitions.
Keywords: multi-agent systems, coalition logics, bounded resources, model checking, coalition formations


Introduction
Automated verification of multi-agent systems is a significant topic in the recent literature in artificial intelligence [1]. The need of modeling this kind of systems has inspired logical formalisms, the most famous being the Alternating-time Temporal Logics [4] and the Coalition Logic (CL) [10,11], oriented towards the description of collective behaviors.

1 Email: ddellamonica@unisa.it
2 Email: napoli@dia.unisa.it
3 Email: parente@unisa.it

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.10.017

The idea of such logics is that agents can join together in teams (or coalitions) and share resources to accomplish a task (reach a goal). In particular, Alternating- time Temporal Logics have been introduced in [4], where the full alternating-time
temporal language, denoted by ATL∗, has been presented, along with two significant fragments, namely, ATL and ATL+. These logics are natural specification languages for open system, that is, systems whose behavior depends on the interactions with an external entity, usually called the environment.
In [9], Goranko has studied the relationship between the (expressive power of the) two formalisms. In particular, he has shown that CL can be embedded into ATL. Recently these two logics have been used for the verification of multi-agent systems (MAS), where the agents are equipped with a limited amount of resources to reach their goal [2,3,6,7] (more on this in the Related works section below).
The framework we present here hinges on these approaches and represents a further step towards the formalization of such complex systems: multi-agent sys- tems in which agents can cooperate to perform a task and are subject to a limited availability of resources, that is an intrinsic feature of most real-world systems. In particular formulae of the formalisms proposed in [2,3,6,7] allow one to assign an endowment of resources to the agents by means of the so-called team operators (borrowed from ATL). The problem is then to determine whether the agents in the proponent team have a strategy to carry out the assigned goals with that bounded amount of resources, whatever the agents in the opponent team do. Anyway, the treatment of this boundedness presents some weakness, as we will point out below. Based on the natural observation that, in order to acquire a resource, there is a price to be paid, usually depending also on the availability of the resource on the market, we propose to consider bounded resources that have each a price to be paid by the agents for their use in reaching the goal. Thus differently from the existing approaches, agents are equipped with an amount of money instead of an endowment of resources. Money is in a sense a meta-resource. On one hand, its introduction is essential to model the natural scenario in which acquiring the resources needed to perform the task, has a price that depends on several factors: on their global availability, on the acting agent, and on the current system state. On the other hand, money has the peculiarity of “measuring” the value of all the resources, thus, it makes sense to consider problems of optimization (e.g., minimization of the
amount of money needed to acquire the resources to perform a task).
In the previous approaches the notion of boundedness of resources is somehow weak, in the sense that resource bounds only appear in the formulae and are applied solely to the proponent team, but they are not represented inside the model at all. This means that it is possible to ask whether a team can reach a goal with a given amount of resources, but it is not possible to keep trace of the evolution of the availability of resources in the world (in particular, the resource consumption due to the actions of the opponent is not controlled). For example, consider the formula
⟨⟨Ab⟩⟩2p, belonging to the formalism proposed in [3]. Its intuitive semantics is that the team A can guarantee that p always holds, independently from the behavior of the opponent (AG \ A), using an amount of resources bounded by b. A model for

this formula must contain a loop where the joint actions of agents in the team A do not consume resources, but the joint actions of agents in the opponent team may possibly consume resources, leading to an unlimited consumption of resources. In our opinion, such a behavior is not realistic.
We introduce hence a notion of global availability of resources on the market (or in nature) that evolves depending on both proponent and opponent behaviors. Such resources are shared, in the sense that all the agents draw on resources from a shared pool and acquisition of a resource by an agent (independently if the agent belong to the proponent or opponent team) implies that the resources will be available in smaller quantity.
The notion of money used here presents several similarity with the notion of resources used in [3]. Indeed, here money is given to the agents to perform a task (like resources are given to the agents in [3]). Moreover, the consumption of money of the opponent is not controlled (like resource consumption of the opponent in [3]). Money, unlike the other resources, can thus be thought of as a private (non-shared) resource. Additionally, opponent has unlimited economic power, in the sense that opponent’s agents are supposed to have enough money to acquire all resources they need (this reflects the choice to not limit the opponent power, as it is usual in game theory, to look for robust strategies of the proponent). Roughly speaking, the opponent can buy everything, except for resources that do not exist anymore.
Another aspect that has not been fully analyzed in the literature is the problem of actions producing resources. On the one hand, in [2,3], actions can only consume resources; on the other hand, in [7], the authors state that whenever actions can pro- duce resources the model checking problem is undecidable. It can be easily argued that the undecidability comes from the unboundedness production of resources, thus we naturally constrain the way in which actions can produce resources: it is possible for an action to produce a resource in a quantity that is not greater than the amount that has already been consumed so far. Such a notion makes sense as, in practical terms, it allows one to model significant real-world scenarios, such as, acquiring memory by a program, leasing a car during a travel, and, in general, any scenario in which an agent is releasing resources previously acquired.
Finally, we also tackle the problem of coalition formation. How and why agents should aggregate is not a new issue and has been deeply investigated, in past and recent years, in various frameworks, as for example in algorithmic game theory, argumentation settings, and logic-based knowledge representation (see [8,5]). We face this problem in the setting of priced resource-bounded agents with the goal specified by an ATL formula. In particular we solve the problem of determining the minimal cost coalitions of agents acting in accordance to rules expressed by a priced game arena and satisfying a given formula.
We show that both the model checking problem and the optimal coalition prob- lem are in EXPTIME and have a PSPACE lower bound.
Related works. In [2], Alechina et al. introduce the logic RBCL, whose language extends the one of CL with explicit representation of resource bounds. In [3], the same authors propose an analogous extension for ATL, called RB-ATL, and give a

model checking procedure that runs in time O(|ϕ|2·r+1 ×S), where ϕ is the formula to be checked, S is the model, and r is the number of resources. Thus, if the number of resources is treated as constant, the model checking problem for RB-ATL is in PTIME. However, the problem of determining a lower bound to the model checking
problem and, in particular, whether a PTIME algorithm exists even if the number of resources is not treated as a constant factor is left open.
In [7], Bulling and Farwer introduce the logics RAL and RAL∗. The former represents a generalization of Alechina et al.’s RB-ATL, the latter is ATL∗ extended with bounded resources. The authors study several syntactic and semantic variants of RAL and RAL∗ with respect to the (un)decidability of the model checking problem. In particular, while previous approaches only conceive actions consuming resources, they introduce the notion of actions producing resources. It turned out that such a new notion makes the model checking problem undecidable.
The paper is structured as follows. In the next section, we formalize our logic to consider priced resources, then in section 3 we analyze the complexity of the model checking problem and in section 4 we deal with the problem of finding op- timal coalitions. Last, we conclude with some considerations on future research directions.
A logical formalization: PRB-ATL
In this section we define the logic Priced RB-ATL (PRB-ATL). We start with the introduction of some notations we will use in the rest of the paper. The set of agents is AG = {1, 2,..., n} and a team is any subset of AG. The set of resources types, called also simply resources, is R = {R1, R2,..., Rr}, where R1 represents the resource ‘time’. The numbers n and r will be used through the paper to denote the number of agents and resources, respectively. Let M = (N∪{∞})r denote the set of global availabilities of resources on the market (or in nature) and N = (N ∪ {∞})n denote the set of money availabilities for the agents, where N is the set of non- negative integers. Given a money availability $ ∈ N , by $[a] we denote the money availability for the agent a, for each a ∈ AG. Finally, the set Π is a finite set of atomic propositions.
The formulae of PRB-ATL are given by the following grammar:
ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | ⟨⟨A$⟩⟩ ⃝ ϕ | ⟨⟨A$⟩⟩ϕUϕ | ⟨⟨A$⟩⟩2ϕ | ∼ b
where p ∈ Π, A ⊆ AG, ∼∈ {<, ≤, =, ≥, >}, b ∈ M and $ ∈ N . Intuitively, formulae of the kind ∼ b test the current availability of resources on the market.
Formulae of the kind ⟨⟨A$⟩⟩ψ, with ψ ∈ {⃝ϕ, ϕUϕ, 2ϕ}, state that the team A has a strategy such that, for every action performed by the opponent (i.e, AG \ A), ψ is satisfied, and such that the total expenses of each agent a ∈ A is less than or equal to $[a]. Without loss of generality, we can assume $[a]= ∞ for each a ∈/ A. Formulae of this logic are evaluated with respect to (a location of) a priced game structure and an initial availability of resources. Intuitively, a priced game structure G is a graph whose vertices, called locations, are labeled by atomic propositions.

In each location, each agent can choose among a non-empty set of actions to be performed. Any possible combination of actions gives rise to transitions, that are the edges of the graph. In general, actions consume and produce resources. Each resource has a price that is variable and depends on, inter alia, the current avail- ability of that resource on the market. Thus, a transition can be executed if the resources needed to perform the actions are available and the agents of a team have enough money to acquire them.
We extend the sum operation to sum between vectors component-wise. Addi- tionally, we use the usual component-wise comparison relations between vectors and denote by 0k the vector of k 0s. When the size of the vector is clear, we will simply write 0. Finally, the behavior of ∞ with respect to the sum operation is defined as usual, that is, ∞ + c = c + ∞ = ∞ + ∞ = ∞, for each constant c.
Formally, priced game structures are defined extending the definitions of con- current game structure and resource-bounded concurrent game structure given in, respectively, [4] and [3].
Definition 2.1 [priced game structure] A priced game structure G is defined as a tuple ⟨Q, π, d, qty, δ, ρ, m0⟩, where:
Q is the finite set of locations.
π : Q → 2Π is the valuation function.
d : Q×AG → N is the action function, that defines the actions which are available to each agent a ∈ AG at each location q ∈ Q. We assume that each agent has at least one available action at each location, that could be thought of as the action do-nothing and without loss of generality we assume it is always the first, denoted thus by the natural number 1. As a consequence, we have that d(q, a) ≥ 1, for each a ∈ AG,q ∈ Q. Given a team A, an action proﬁle αA is a vector assigning an action to each agent a ∈ A. Action profiles represent joint actions of a team. For each location q ∈ Q and team A = {a1,..., ak} ⊆ AG, we denote by DA(q) the set of action proﬁles available to the team A at the location q, defined as DA(q)= {1,..., d(q, a1)}× ... × {1,..., d(q, ak)}. For the sake of readability, we denote DAG(q) by D(q). Given a team A, an agent a ∈ A, and an action profile αA, we will refer to the component of the vector αA corresponding to the agent a as αA(a). Actions (resp., action profiles) are usually denoted by α, α1,... (resp., α, α1,.. .).
qty : Q×AG×N → Zr is a partial function, defined over the triples (q, a, i) with i ∈ d(q, a), defining the amount of resources required by an available action to a given agent at a given location. A negative cost represents a resource consumption, while a positive one represents a resource production. Moreover, we have that qty(q, a, 1) = 0r, that is the vector whose components are all equal to 0, for every q ∈ Q, a ∈ AG (doing nothing neither consumes nor produces resources). With an abuse of notation we also denote by qty the function defining the amount of resources required by an action profile αA ∈ DA(q), that is qty(q, αA) = a∈A qty(q, a, αA(a)). Finally, we define the function consd : Q × AG × N → Nr
in such a way that consd(q, a, α) returns the vector of the resources which are

consumed by an agent a for an action α. This vector is obtained from qty(q, a, α) by replacing the positive components, representing a resource production, with zeros, and the negative components, representing a resource consumption, with their absolute values.
δ : Q × Nn → Q is the transition function, that defines the next location reached from q if the agents perform the action profile α ∈ Nn. It is a partial function defined over the set of pairs (q, α) ∈ Q × Nn such that α ∈ D(q).
ρ : M× Q × AG → Nr is the price function, denoting the price of each resource, depending on the current resource availability, the acting agent, and the current location. Without loss of generality, we can assume the price of the resource ‘time’ to be always zero, as it is a resource that cannot be acquired and thus its price is meaningless.
m0 is the initial global availability of resources. It represents the resource avail- ability on the market at the initial state of the system.
In order to give the formal semantics we must define the following notions.
Definition 2.2 [configuration and computation] A conﬁguration c of a priced game graph G is a pair ⟨q, m⟩ ∈ Q × M. A computation over G is an infinite sequence of configurations of G λ = c1c2 .. ., such that, for each i, if ci = ⟨qi, mi⟩ and ci+1 =
⟨qi+1, mi+1⟩, then there exists a transition δ(qi, α)= qi+1, with α = ⟨α1,..., αn⟩,
such that mi+1 = mi + qty(qi, α).
Let λ = c1c2 ... be a computation. We denote by λ[i] the i-th configuration ci
in λ and by λ[i, j], with i ≤ j, the finite sequence of configurations cici+1 ... cj in λ.
Definition 2.3 [strategy] A strategy FA for the team of agents A is a function which associates, to each finite sequence of configurations c1c2 ... cs, with s ≥ 1, and cs = ⟨qs, ms⟩, an action profile αA ∈ DA(qs).
In other words, a strategy FA determines the behavior, that is action profile αA, of the agents in the team A. Anyway, for each action profile αA and configuration c ∈ Q×M, depending on the different action profiles of the opponent team AG \ A, there are several possibilities for the next configuration, called outcomes of αA at the conﬁguration c.
In determining such outcomes, we do not consider unfeasible action profiles of the proponent (resp., opponent) team, that is, action profiles which consume an amount of resources greater than the current availability m or produce an amount of resources greater than m0 − m. (Notice that an action profiles can be unfeasible even if each action of a single agent is feasible) This reflects the natural concept that the proponent team cannot conceive a strategy based on unfeasible action profiles. Analogously, the opponent team cannot prevent the achievement of a goal by the proponent through an unfeasible action profile.
Formally, given a configuration c = ⟨q, m⟩, the set out(c, αA) of the outcomes of αA at the configuration c, contains ⟨qj, mS⟩ if there exists αAG extending αA such that

qj = δ(q, αAG),
mS = m + qty(q, αAG),
0 ≤ qty(q, αA)+ m ≤ m0.
0 ≤ qty(q, αAG\A)+ m ≤ m0, where αAG\A is the restriction of αAG to the team AG \ A.
As a consequence of the above definition, given a configuration c,a strategy FA gives rise to a tree of computations. A computation λ = c1c2 ... is called an outcome of the strategy FA from the conﬁguration c, if c1 = c and ci+1 ∈ out(ci, FA(λ[1, i])), for each i ≥ 1. The set of such computations is denoted by out(c, FA).
Finally, we introduce the concept of consistent strategy, whose outcomes are such that in every configuration the agents have enough money to realize it.
Definition 2.4 [($, m0)-strategy] Let $ ∈ N and m0 ∈ M. A strategy FA is said to be a ($, m0)-strategy if for each λ = c1c2 .. ., with ci = ⟨qi, mi⟩ for all i, belonging to out(c1, FA), the following conditions hold, for every i ≥ 1 and a ∈ A:
0r ≤ mi ≤ m0,

i
j=1
ρ(mj, qj, a) · consd(qj, a, FA(q1 ... qj)(a)) ≤ $[a].

The two above conditions state the consistency of a computation with respect to the m and $, where the dot operator denotes the usual scalar product of vectors. Observe that, in the second condition, only the money availability of the team A is tested. Actually, we suppose that the opponent team AG \ A always have money enough to make its choice. Notice also that, as another consequence of the second condition, the actions producing resources do not cause a reimbursement of money to the agents.
Observe that, as it is usual when dealing with temporal logics, we guarantee that priced game structures are non-blocking, in the sense that a finite prefix of a computation satisfying the two conditions can always be followed by a next config- uration without violating the consistency. Actually, a team A can always choose all the do-nothing actions of its agents, and the opponent team have choices which do not require an amount of resources greater than the resource availability.
We now can give the semantics of PRB-ATL formulae. The truth of a formula of PRB-ATL is defined with respect to a priced game structure G and a configura- tion c = ⟨q, m⟩. The definition of the semantics of PRB-ATL is completed by the definition of the satisfaction relation |=, as follows:
(G, c) |= p iff p ∈ π(q)
(G, c) |= ¬ψ iff (G, c) |= ψ
(G, c) |= ψ1 ∧ ψ2 iff (G, c) |= ψ1 and (G, c) |= ψ2
(G, c) |= ⟨⟨A$⟩⟩ ⃝ ψ iff there exists a ($, m0)-strategy FA such that, for all
λ ∈ out(c, FA), it holds that (G, λ[1]) |= ψ
(G, c) |= ⟨⟨A$⟩⟩ψ1Uψ2 iff there exists a ($, m0)-strategy FA such that, for all
λ ∈ out(c, FA), there exists i ≥ 0 such that (G, λ[i]) |= ψ2 and, for all 0 ≤ j < i,

it holds that (G, λ[j]) |= ψ1
(G, c) |= ⟨⟨A$⟩⟩2ψ iff there exists a ($, m0)-strategy FA such that, for all λ ∈
out(c, FA), it holds that (G, λ[i]) |= ψ for all i ≥ 0
(G, c) |= ∼ b iff m∼ b

Model checking
In this section we study the model checking problem for PRB-ATL and we show that it is in EXPTIME and has a PSPACE lower bound. The model checking problem consists in verifying whether a formula ϕ is satisfied with respect to a configuration c = ⟨q, m⟩ of a priced game structure G, (G, c) |= ϕ.

A model-checking algorithm
The algorithm for model checking our logic is mostly based on the ones proposed in
[4] and [3] for model checking, respectively, ATL and its resource-bounded extension RB-ATL (see Algorithm 1, where M≤m denotes the set {mS ∈ M | mS ≤ m}, for a resource availability m ∈ M). Roughly speaking, it computes, for each sub-formula ϕj of the formula ϕ to be checked against a model G, the set of configurations in which ϕj holds. Note that in our setting it is not sufficient to compute the set of states where a sub-formula holds, we need to take into account also the current resource availability. The main issues when dealing with bounds on resources are the following. First, the set of sub-formulae must be replaced by an extended set of formulae, called Sub+, that includes also, for each sub-formula of the form ⟨⟨A$⟩⟩ϕj, all the formulae ⟨⟨A$0 ⟩⟩ϕj, with $S < $. Second, we need to take trace not only of the states but also of the configurations since we must take into account the resource availability on the market to guarantee that during the computation the
needed resources are available, as well as to be able to compute the current prices of
these resources, that depend also on their availability. Finally, it must be ensured that, even if actions can produce resources, availability of each resource may not be higher than the initial availability. Let us stress that such a requirement is crucial to preserve decidability even when actions are allowed to produce resources.
Algorithm 1 heavily relies on the function Pre(A, [ϕ], $, G, m) (see Algorithm 2) which computes the pre-image of a set of configurations with respect to the transition relation of G and according to the resource and money availabilities. More precisely, it returns all the configurations ⟨qj, mS⟩ for which there exists an
action profile αA such that for all αAG extending αA, the configuration ⟨qjj, mSS⟩
satisfies ϕ where qjj = δ(qj, αAG), mSS = mS + qty(qj, αAG), and the conditions of Definition 2.4 are satisfied.
Let M be the maximum component occurring in the initial resource availability vector m0 and S be the maximum component occurring in the money endowment vectors $i occurring in ϕ. Thus the proposed algorithm runs in time O(|ϕ|·|G|·Mr · Sn). Indeed, the outermost loop (line 1) is executed at most |Sub+(ϕ)| = |ϕ|· Sn times. The cases in which ϕj is of the form ⟨⟨A$⟩⟩ψ1Uψ2 or ⟨⟨A$⟩⟩2ψ require 2 loops.



Algorithm 1 MC(ϕ, G, q, m)	// returns true iff (G, ⟨q, m⟩) |= ϕ
1: for all ϕ′ ∈ Sub+(ϕ) do
2:	if ϕ′ = p then
3:	[ϕ′] → {⟨q′, m0⟩ | p ∈ π(q′), m0 ≤ m0}
4:	else if ϕ′ =∼ b then
5:	[ϕ′] → {⟨q′, m0⟩ | m0 ∼ b and m0 ≤ m0}
6:	else if ϕ′ = ¬ψ then
7:		 [ϕ′] → (Q × M≤m0 ) \ [ψ] 8:	else if ϕ′ = ψ1 ∧ ψ2 then 9:		[ϕ′] → [ψ1] ∩ [ψ2]
10:	else if ϕ′ = ⟨⟨A$⟩⟩ ⃝ ψ then
11:	[ϕ′] → Pre(A, [ψ], $, G, m)

12:	else if ϕ′ = ⟨⟨A0n ⟩⟩ψ U ψ
13:	τ → [false],σ → [ψ2]
14:	while τ /= σ do
15:	τ → σ
then

16:		σ → τ ∪ (Pre(A, τ, 0n, G, m) ∩ [ψ1]) 17:	end while
18:	[ϕ′] → σ
19:	else if ϕ′ = ⟨⟨A$⟩⟩ψ1U ψ2, with $ ≥ 0n, ¬($ = 0n) then
20:	τ → [⟨⟨A0n ⟩⟩ψ U ψ ]
1	2
21:	for all $0 s.t. $0 ≤ $, ¬($0 = $) do
22:	σ → τ ∪ (Pre(A, [⟨⟨A$0 ⟩⟩ψ U ψ ], $ − $0, G, m) ∩ [ψ ])
1	2	1
23:	while τ /= σ do
24:	τ → σ
25:		σ → τ ∪ (Pre(A, τ, 0n, G, m) ∩ [ψ1]) 26:	end while
27:	end for
28:	[ϕ′] → σ
29:	else if ϕ′ = ⟨⟨A0n ⟩⟩2ψ then
30:	τ → [true],σ → [ψ]
31:	while τ /= σ do
32:	τ → σ
33:		σ → [ψ] ∩ Pre(A, τ, 0n, G, m) 34:	end while
35:	[ϕ′] → σ
36:	else if ϕ′ = ⟨⟨A$⟩⟩2ψ, with $ ≥ 0n, ¬($ = 0n) then
37:	τ → [⟨⟨A0n ⟩⟩2ψ]
38:	for all $0 s.t. $0 ≤ $, ¬($0 = $) do
39:	 σ → τ ∪ (Pre(A, [⟨⟨A$0 ⟩⟩2ψ], $ − $0, G, m) ∩ [ψ]) 40:	while τ /= σ do
41:	τ → σ
42:		σ → τ ∪ (Pre(A, τ, 0n, G, m) ∩ [ψ]) 43:	end while
44:	end for
45:	[ϕ′] → σ
46:	end if
47: end for
48: return (⟨q, m⟩ ∈ [ϕ])

Algorithm 2 Pre(A, [ϕ], $, G, m)
1: res → ∅ 
2: for all ⟨q′, m0⟩ ∈ Q × M≤m0 do
3:	for all αA ∈ DA(q′) s.t. 0 ≤ qty(q, αA)+ m ≤ m0 do
4:	ins → true
5:	for all ⟨q′′, m00⟩ where (i) q′′ = δ(q′, αAG ) for some αAG ∈ D(q′)
that generalizes αA, (ii) m00 = m0 + qty(q, αAG ), and
(iii) 0 ≤ qty(q, αAG\A)+ m ≤ m0 do
6:	if ⟨q′′, m00⟩ /∈ [ϕ] or ¬(0r ≤ m00 ≤ m0)
or ¬($[a] ≥ ρ(m0, q′, a) · consd(q′, a, αAG (a)) for some a ∈ A then
7:	ins → false
8:	end if
9:	end for
10:	if ins then
11:	res → res ∪ {⟨q′, m0⟩}
12:	end if
13:	end for
14: end for
15: return res

The outer one (lines 19 and 36, respectively) is executed at most Sn times, while the inner one (lines 21 and 38, respectively) is executed at most |Q×M≤m0 | ≤ |Q|· Mr times. Since |Q| ≤ |G|, we have the above asymptotic complexity. Notice that the complexity of the function Pre can be ignored as it is absorbed in the complexity
of the main algorithm. To sum up, the algorithm runs in exponential time with respect to the size of the input.
Theorem 3.1 Model checking PRB-ATL can be solved in exponential time in the number of agents and resources.
PSPACE-hardness
Here, we provide a lower bound to the complexity of the model checking problem for PRB-ATL. To this aim, we will reduce the problem of determining the truth value of Fully Quantiﬁed Boolean Formulae, TQBF problem [12], to the model checking problem for PRB-ATL. A fully quantified Boolean formula is a Boolean formula in which all the Boolean variables occur inside the scope of an existential or universal quantifier. A fully quantified Boolean formula is said to be in prenex normal form if all the quantifiers appear at the beginning of the formula and each quantifier’s scope is everything following it. Any formula may be easily put into prenex normal form, thus we consider formulae in this form only. Without loss of generality, we can also assume that the Boolean quantifier-free part of the formula is in conjunctive normal form with clauses having at most three literals, where a literal is either a variable or its negation. For example, ∀x∃y[(x∨y) ∧ (¬x∨¬y)] and
∃x1∀x2∃x3[(x1 ∨ x2 ∨ ¬x3) ∧ (¬x1 ∨ ¬x2 ∨ x3)] are fully quantified Boolean formulae
in the desired normal form. TQBF is the problem of determining whether a fully quantified Boolean formula is true.
Let Φ = Q1x1Q2x2 ... Qkxk[(x1 ∨ x1 ∨ x1) ∧ ... ∧ (xh ∨ xh ∨ xh)] be a fully
1	2	3	1	2	3
quantified Boolean formula, where Qi are quantifiers, xi are Boolean variables, for
1 ≤ i ≤ k, and xj , xj , xj are literals, for 1 ≤ j ≤ h. We must exhibit a priced game
1	2	3
structure G, a configuration c of G, and a PRB-ATL formula ϕ such that (G, c) |= ϕ
if and only if Φ is true.
The priced game structure GΦ corresponging to Φ is computed as follows. (As
an example, in Figure 1 the graph of the priced game structure generated from
the formula Φ = ∃x1∀x2∃x3[(x1 ∨ x2 ∨ ¬x3) ∧ (¬x1 ∨ ¬x2 ∨ x3)] is shown). The set of locations is made up of the following locations:
3 locations, denoted qi, qT, q⊥ for each quantifier Qi,
i	i
the location qk+1,
a location qci for each clause ci,
2 locations, denoted qxi and qчxi , for each variable xi,
the locations qT.
There exist r = 2 · k resources, two for each Boolean variable, that is, R =
{RT , R⊥ ,..., RT , R⊥ } and only one agent (AG = {1}). Initially, there is only
x1	x1	xk	xk
one item available for each resource, that is, the vector m0 has all components

equal to 1. Notice that, since there is only one agent, there are only 2 possible teams, namely ∅ and AG. This means that the reduction (and the hardness result) also applies to the extension of CTL with prices for bounded resources.
The idea of the reduction is that from any location qi there are only two sig-
nificant transitions, leading to qT and q⊥. The intended meaning of the transition
i	i
leading to qT (resp., q⊥), which is called true transition (resp., false transition),
i	i
is to assign the truth value true (resp., false) to the Boolean variable xi. We
need a machinery to remember such an assignment. To this aim, we make use of the resources and their limited availability: the transition leading from qi to qT
(resp., q⊥) is such that exactly 1 item of the resource RT (resp., R⊥ ) is consumed.
i	xi	xi
Analogously, there exists a transition starting from the location qxi (resp., qчxi )
and leading to qT. The transition leading from qxi (resp., qчxi ) to qT is such that
exactly 1 item of the resource R⊥ (resp., RT ) is consumed. In this way, if in the
location qi the true (resp., false) transition has been chosen, when the game is on
the location qчxi (resp., qxi ), the agent is not able to choose the transition leading to qT, indicating that the literal is false. There exists only one atomic proposition, namely p, that is true only over the location qT.


Fig. 1. The graph of the priced game structure GΦ corresponding to the fully quantified Boolean formula Φ= Ex16x2Ex3[(x1 V x2 V чx3) Λ (чx1 V чx2 V x3)].


Let Φ be a fully quantified Boolean formula with k Boolean variables, let m0 be the vector, of length 2 · k, with all components equal to 1, and let ϕΦ = ⟨⟨A0⟩⟩ ⃝
⟨⟨AG0⟩⟩⃝⟨⟨A0⟩⟩⃝⟨⟨AG0⟩⟩⃝... ⟨⟨A0⟩⟩⃝⟨⟨AG0⟩⟩⃝⟨⟨AG0⟩⟩⃝⟨⟨∅0⟩⟩⃝⟨⟨AG0⟩⟩⃝p,
2	k
with Ai = ∅ if Qi is an universal quantifier, Ai = AG, otherwise, for all 1 ≤ i ≤ k.
It is possible to show that (GΦ, ⟨q1, m0⟩) |= ϕΦ if and only if Φ is true.

Theorem 3.2 The model checking problem for PRB-ATL is PSPACE-hard.

Optimal coalitions
In this section we define the problem of determining optimal coalitions that are capable to satisfy a PRB-ATL formula. In doing that, we introduce the notion of parametric PRB-ATL formula, that is, a PRB-ATL formula in which parametric team operators ⟨⟨X$⟩⟩ may occur in the place of the classical team operators ⟨⟨A$⟩⟩. If
⟨⟨X$⟩⟩ is a parametric team operator, then X is a team variable.
Given a parametric PRB-ATL formula ϕ with team variables X = ⟨X1,..., Xk⟩, and a vector A = ⟨A1,..., Ak⟩ of k teams, we denote by ϕ[X/A] the PRB-ATL formula obtained from ϕ by replacing every occurrence of Xi with Ai, for every 1 ≤ i ≤ k. We denote by Solϕ the set of the vectors A of teams such that (G, c) |= ϕ[X/A].
Finally, we associate a cost to each PRB-ATL formula by means of the function f cost, defined as follows. Suppose that a team A is represented by means of the characteristic vector of the set A, that is, A is a vector of n binary components such that the i-th component is 1 if and only if the agent i belongs to the team A, for each 1 ≤ i ≤ n. For every PRB-ATL formula ϕ, containing the team operators
⟨⟨A$1 ⟩⟩, ⟨⟨A$2 ⟩⟩,..., ⟨⟨A$k ⟩⟩,
1	2	k
f cost(ϕ)= Σ($i · Ai)
i=1
The problem
In this section, we introduce the problem of finding an optimal (with respect to the function f cost) vector of teams that satisfies a given parametric PRB-ATL formula. Given a parametric PRB-ATL formula ϕ, a priced game structure G, a configu- ration c of G, the Optimal Coalition problem for PRB-ATL (OC, for short) consists in finding a vector A, if any, such that (G, c) |= ϕ[X/A] and that minimizes the
function f cost.
Thus, an algorithm to solve such problem takes the following parameters as input:
a PRB-ATL formula ϕ, over team variables X = ⟨X1, X2,..., Xk⟩
the priced game structure G,
a configuration c of G,
and outputs the triple ⟨res, A∗, cost⟩, where:
res ∈ {true, false} is true if and only if there exists a vector of teams A such that (G, c) |= ϕ[X/A],

A∗ is a vector of teams such that f cost(ϕ[X/A∗]) = min
A∈Solϕ
f cost(ϕ[X/A]); its

value is undefined if Solϕ = ∅,
cost ∈ N is the value of the function f cost applied to ϕ[X/A∗].
Our aim is to show that OC has the same complexity as the model checking

problem for PRB-ATL.
The upper bound is given by a brute force algorithm that tries to solve the model checking problem for each possible vector of teams. Since there are (2n)k different vectors of teams, the algorithm will call (2n)k times the algorithm for model checking PRB-ATL.
For the lower bound, consider the decisional version of the OC problem: given a parametric PRB-ATL formula ϕ, a priced game structure G, a configuration c of G, and an integer U , decide if there is a vector A such that (G, c) |= ϕ[X/A] and f cost applied to ϕ[X/A] does not exceed U . The hardness for such a problem directly descends from Theorem 3.2.
Theorem 4.1 The decisional OC problem is in between PSPACE and EXPTIME.
Discussion
In this paper we have studied the model checking problem for the logic PRB-ATL, very suitable for modeling scenarios in which teams of agents have to perform a task and they are subject to boundedness of resources.
Several formalisms have already been proposed to model such a kind of real- word situations [3,7]. Our main contribution is to present a new formalism, called PRB-ATL, based on a stronger notion of resource bounds and we show that its model checking problem We also introduce the problem, called the optimal coalitions (OC) problem, of finding optimal coalitions (with respect to the amount of money needed by the different coalitions) capable to perform the task. We have shown that both the model checking problem for PRB-ATL and the OC problem are in EXPTIME and have a PSPACE lower bound. As a matter of fact, to solve the OC problem we give an algorithm that explores the entire space of solutions to compute the optimum. The problem of finding the exact characterization of the computational complexity is an open problem and currently is under investigation.
Further research directions concern the study of variants of the logic, to naturally express more kinds of scenarios. As an example, it is interesting in our opinion to consider the money endowment as a component of the game arena (i.e., the model), instead of explicitly specifying a fresh money availability for each occurrence of a team operator in the formula. Furthermore, related to this argument, one can consider the money availability not as an input of the problem, but rather as a parameter to minimize, to establish how much money each agent should be provided with, to perform a given task.

References
˚Agotnes, T., W. van der Hoek and M. Wooldridge, On the logic of coalitional games, in: AAMAS, 2006,
pp. 153–160.
Alechina, N., B. Logan, N. H. Nga and A. Rakib, A logic for coalitions with bounded resources, in: Proc. of the 21st International Joint Conference on Artificial Intelligence, IJCAI ’09, 2009, pp. 659–664.
Alechina, N., B. Logan, N. H. Nga and A. Rakib, Resource-bounded alternating-time temporal logic, in:
Proc. of the 9th International Conference on Autonomous Agents and Multiagent Systems: Volume 1,

AAMAS ’10, 2010, pp. 481–488.
URL http://portal.acm.org/citation.cfm?id=1838206.1838274
Alur, R., T. A. Henzinger and O. Kupferman, Alternating-time temporal logic, Journal of ACM 49
(2002), pp. 672–713.
Bulling, N. and J. Dix, Modelling and verifying coalitions using argumentation and ATL, Inteligencia Artificial, Revista Iberoamericana de Inteligencia Artificial 14 (2010), pp. 45–73.
Bulling, N. and B. Farwer, Expressing properties of resource-bounded systems: The logics RTL∗ and RTL, in: J. Dix, M. Fisher and P. Nov´ak, editors, Computational Logic in Multi-Agent Systems (CLIMA X) (2009), pp. 22–45.
Bulling, N. and B. Farwer, On the (un-)decidability of model checking resource-bounded agents, in:
Proc. of the 19th European Conference on Artificial Intelligence, ECAI ’10, 2010, pp. 567–572.
Dunne, P. E., S. Kraus, E. Manisterski and M. Wooldridge, Solving coalitional resource games, Artificial Intelligence 174 (2010), pp. 20–50.
URL http://www.sciencedirect.com/science/article/pii/S0004370209001076

Goranko, V., Coalition games and alternating temporal logics, in: Proc. of the 8th Conference on Theoretical Aspects of Rationality and Knowledge, TARK ’01 (2001), pp. 259–272.
Pauly, M., A logical framework for coalitional effectivity in dynamic procedures, Bulletin of Economic Research 53 (2001), pp. 305–324.
URL  http://dx.doi.org/10.1111/1467-8586.00136
Pauly, M., A modal logic for coalitional power in games, Journal of Logic and Computation 12 (2002),
pp. 149–166.
Sipser, M., “Introduction to the Theory of Computation,” International Thomson Publishing, 1996, 1st edition.
