 Electronic Notes in Theoretical Computer Science 91 (2004) 229–245 
www.elsevier.com/locate/entcs




How to Collect Balls Moving in the Euclidean Plane
Yuichi Asahiroa,1, Takashi Horiyamac,2, Kazuhisa Makinob,3, Hirotaka Onod,4, Toshinori Sakumad,4, Masafumi Yamashitad,4
a Department of Social Information Systems, Faculty of Information Science, Kyushu Sangyo University, Fukuoka 813-8503, Japan.
b Division of Systems Science, Graduate School of Engineering Science, Osaka University, Toyonaka, Osaka 560-8531, Japan.
c Depatment of Communications and Computer Engineering, Graduate School of Informatics,
Kyoto University, Kyoto 606-8501, Japan
d Department of Computer Science and Communication Engineering, Graduate School of Information Science and Electrical Engineering, Kyushu University, Fukuoka 812-8581, Japan.

Abstract
In this paper, we study how to collect n balls moving with constant velocities in the Euclidean plane by k robots moving on straight track-lines through the origin. Since all the balls might not be caught by robots, differently from Moving-Target TSP, we consider the following 3 problems in various situations: (i) deciding if k robots can collect all n balls, (ii) maximizing the number of the balls collected by k robots, and (iii) minimizing the number of the robots to collect all n balls. The situations considered here contain the cases in which track-lines are given (or not), and track-lines are identical (or not). For all problems and situations, we provide polynomial time algorithms or proofs of intractability, which clarify the tractability-intractability frontier in the ball collecting problems in the Euclidean plane.
Keywords: Moving-Target TSP, Vehicle routing problem, Partially ordered set, Combinatorial optimization.


1 Email:asahiro@is.kyusan-u.ac.jp
2 Email: horiyama@i.kyoto-u.ac.jp
3 Email: makino@sys.es.osaka-u.ac.jp
4 Email: ono@csce.kyushu-u.ac.jp, sakuma@tcslab.csce.kyushu-u.ac.jp, mak@
csce.kyushu-u.ac.jp



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.12.015

Introduction

We consider the problem of collecting n balls (or objects) moving around by using k robots. We often encounter this kind of situation as real-world applications (e.g., [8,9]). For example, supply ships resupply patrolling boats in the sea, and aircraft must intercept a number of mobile ground units. In the first example, boats and ships correspond to balls and robots, respectively. The problem can be seen as a natural extension of the classical Traveling Salesman Problem (TSP) and was studied under the names of Moving-Target TSP [9] and Kinetic TSP [8].
In the classical TSP, we are given a set of balls (or cities) associated with the distances between each pair of balls. The objective is to computed a shortest tour that collects all the balls by a robot (or visits all the cities by a salesman). In the Moving-Target TSP, the balls collected by a robot are not stationary but moving around. Clearly, Moving-Target TSP is NP-hard, since classical TSP is a special case of Moving-Target TSP in which the velocities of all objects are permanently 0.
Helvig, et al. [9] investigated this problem when each ball bi moves at a given constant velocity vi from an initial position pi ∈ IRd, and a robot starts at the origin with the maximum speed v > |vi|. They showed that the problem can be solved in O(n2) time if d = 1 (i.e., the robot and all balls are confined to a single line), and can be approximated in polynomial time with ratio (1 + α), where α is an approximation ratio of an arbitrary classical TSP heuristic, if O(log n/log log n) balls are moving. They also considered the case in which multi-robots can be used. Hammar and Nilsson [8] studied the 2-dimensional Euclidean case. For example, it can be shown that, if all the balls move with the same velocity, the problem has a PTAS, but in general, it
cannot be approximated better than by a factor of 2Ω(√n) in polynomial time,
unless P=NP.
In the Moving Target TSP (or kinetic TSP), it is assumed that any robot can move faster than any ball, and hence robots can always collect all balls. However, in some scenarios (e.g., [4,15]), it is natural to consider the case in which robots cannot collect all balls. This situation results from the fact that robots cannot move faster than balls and/or robots can move only in the restricted spaces such as lines. In this situation, the following fundamental problems have to be studied.
deciding if given k robots can collect given n balls, and if yes, computing such a robot schedule.
computing a robot schedule that maximizes the number of the balls col-
lected by given k robots.

computing a robot schedule that minimizes the number of the robots collecting given n balls.
It is clear that (ii) and (iii) are natural extensions of (i). We generically call these kinds of problems the Ball Collecting Problems (BCPs).
This paper investigates the BCPs in the Euclidean plane, under the as- sumption that each robot can move only on a straight line. More formally, our problems can be defined as follows.
Given a set B = {b1, b2, ··· , bn} of balls in the Euclidean plane (with x- and
y-axes), each bi moving at a constant velocity vi = (vi cos ϕi, vi sin ϕi) from
an initial point p(0) = (x(0), y(0)) ∈ IR2, and a set R = {v1, v2, ··· , vk} of
i	i	i
(homogeneous) robots, each vj starting from the origin (or depot) o = (0, 0)
and moving with maximum speed v > 0 on a line lj through the origin o, compute robot schedules described in (i), (ii) and (iii).

Fig. 1. BCP with 2 robots on 2 track-lines
Fig. 1 illustrates our problems, when 2 robots move on 2 different lines. We also consider the case in which lines lj are not predetermined (i.e., we can decide an angle θj of line lj as a part of the scheduling). Note that the assumption that each ball moves at a constant velocity has been studied in [8,9] (see [8,9] for the motivations). The assumption that each robot moves on a line is motivated as follows. First, it is reasonable to consider a kind of symmetric condition between balls and robots. Both move on straight lines. Second, a line is one of the most fundamental tracks of a robot. Actually, many kinds of tracks of a robot can be decomposed into several lines. This means that the results under the assumption above are useful for general shapes of tracks. Finally, the assumption is often encountered in the real world, e.g., railway, bridge and ropeway.
We remark that our problems when n robots all move on a given single line
l can be regarded as new models of the Vehicle Scheduling Problem (VSP) on

line-shaped network (e.g., [10,14,2,16]). VSPs are classified by the conditions on release times, handling times, due times (or deadlines), and the objectives such as minimizing the completion time and minimizing the maximum late- ness. Robots and catching balls in our case are regarded as vehicles and jobs, respectively. We consider only the balls which crosses line l exactly once (see the discussion in Section 2.1). The handling time of each job is defined as 0, and the release time and the due time of job bi are defined as the time when it crosses line l. Each job bi is located at the position where it crosses line l. Then we can see that problem (i) is to decide whether the maximum lateness of this VSP is 0. This kind of setting is well studied. However, the objectives corresponding to problems (ii) and (iii) (for example, to compute a schedule of vehicles that maximizes the number of the jobs done by their due times) are not investigated as the VSPs.
We extensively study the BCPs defined above mainly from computational points of view. For all problems, polynomial time algorithms or proofs of in- tractability are provided (although it remains important to improve efficiency of the algorithms for polynomially solvable cases and to develop polynomial approximation algorithms for NP-hard cases). Thus, our work gives a com- plete picture of the tractability-intractability frontier in the 2-dimensional Euclidean BCP when balls bi move with fixed constant velocities vi and ho- mogeneous robots vj move lines lj through the depot o. A summary of the results in this paper is given in Table 1.
We first consider the case in which n robots all move on a given single line l, i.e., lj = l for all j. In this case, we present an O(n log n) time algorithm for the problem (iii) (and hence (i) is solvable in O(n log n) time). This is optimal in the sense that the problem contains the sorting problem as a special case, where the sorting problem is known to need Ω(n log n) time for the comparison-based algorithms. Moreover, we show that the problem (ii) is solvable in O(n log n) time, if k = 1, and O(n3) time if k ≥ 2. The result when k = 1 is also optimal in the sense above.
On the other hand, if given lines lj are not identical, most problems seems to be intractable. Note that the case of k = 1 is studied in the single line case. We show that the problem (i) can be solved in O(n2) time when k = 2, however, it is NP-complete when k ≥ 3. The problems (ii) and (iii) are both NP-hard.
We finally study the case in which lines lj are not given (i.e., we can decide an angle θj of line lj as a part of the scheduling). We show that Θ(n2) lines are essentially different for our problems, although there exist infinitely many lines through the origin. By combining this with the previous positive results, we provide polynomial time algorithms. For example, if we choose a single

line l for all robots, then the problem (iii) is solvable in O(n log n) × O(n2)= 
O(n3 log n) time, and if we can choose distinct lines for each robot, the problem
(i) when k = 2 can be solved in O(n2) × O(n2) = O(n6) time. We show that the problem (i) when k = 1 can be solved in O(n2 log n) time, which improves upon the simple combined algorithm. Furthermore, we show the intractability of the problems does not depend on the fact that lines are given or not.
Table 1 Summary of results.
Input and Output mean that lines lj are chosen as a part of input and output, respectively.
The rest of the paper is organized as follows. In Sections 2 and 3, we investigate the BCPs when the track-lines lj are given in advance. Section 2 deals with the case in which all lj are identical, and Section 3 deals with the general case. Section 4 considers the BCPs when lj are not given. Section 5 concludes this paper and discusses some possible extensions of the BCPs.
BCPs with a given single track-line
In this section, we consider the BCPs when all k robots move on the identical line l.
Single robot BCP
We start with the most fundamental situation that a single robot tries to collect all n balls. We first exclude two kinds of balls: (1) the balls which do not cross the track-line l and (2) the balls which move on l. Note that the robot never catches the balls of type (1). Let bi be a ball of type (2). If bi

goes away from the origin with the speed vi > v, then the robot cannot catch up with it; Otherwise, it is always caught by the robot. Hence we assume without loss of generality that all balls cross l exactly once.
Let ti denote the time when ball bi crosses the line l, and let pi = (xi, yi) denote the point where bi crosses l. Define di = dist(o, pi) if xi ≥ 0, and di = −dist(o, pi), otherwise, where dist(o, pi) denotes the Euclidean distance between the origin o and pi. 5 It is clear that if the robot can catch all balls, then the balls have to be caught in the order of ti. Therefore, the problem (i) can be solved by first sorting ti (i = 1,..., n) and then checking if
v(tpk+1 − tpk ) ≥ |dpk+1 − dpk |,  k = 1, 2,...,n − 1,
where tp1 ≤ tp2 ≤ ... ≤ tpn . This immediately implies the following result.
Theorem 2.1 It can be checked in O(n log n) time if all balls can be collected by a robot moving on a given track-line. Furthermore, if so, such a robot schedule can be computed in O(n log n) time.	 
In the following sections, we show that the problem (ii), which is a gener- alization of the problem (i), is also solvable in O(n log n) time. This is optimal in the sense discussed in the introduction.
Before describing an optimal algorithm, we first present a simple O(n2) time algorithm for the problem (ii) in order to understand the optimal one easily. The algorithm makes use of a directed acyclic graph (DAG) constructed from di and ti above.
DAG based algorithm
Let θ denote the angle of a track-line l. A directed graph G(θ) = (V =
{1, 2,..., n},A =  n	Ai) is defined by
A0 = {(0, i) | The robot starting at the origin o can catch ball bi}
Ai = {(i, j) | The robot can catch ball bj after catching bi},i = 1, 2,..., n.
It is easy to see that (0, i) ∈ A0 if and only if v·ti ≥ di, and (i, j) ∈ Ai for i ≥ 1 if and only if v · (tj − ti) ≥ |dj − di|. For example, Fig. 2 shows the situation that all balls can be caught directly by the robot starting at the origin o (since G(θ) contains arcs (0, 1), (0, 2) and (0, 3)), ball b1 can be caught after catching b2 (since G(θ) contains arc (2, 1)), but b3 cannot be caught after catching b1 (since G(θ) does not contain arc (1, 3)), and so on.
Note that G(θ) is transitive, i.e., if (i1, i2), (i2, i3) ∈ A then (i1, i3) ∈ A. If G(θ) contains a cycle C, then C does not contain node 0, since no arc enters node 0, and all nodes in C have the same di and ti (i.e., d = di and t = ti

5 If l coincides with y-axis, di = dist(o, pi) if yi ≥ 0, and di = −dist(o, pi) otherwise.



Fig. 2. An example of a directed graph G(θ)
for all i ∈ C), since i, j ∈ C implies (i, j), (j, i) ∈ A by the transitivity of A, which further implies tj − ti, ti − tj ≥ |dj − di|/v (≥ 0). Moreover, we can see the following proposition.
Proposition 2.2 Any directed path from node 0 in G(θ) represents feasible robot schedules. Conversely, any feasible robot schedule can be represented by a directed path from node 0. Furthermore, the length of the path in G(θ) represents the number of the balls collected under the corresponding schedules.
 
We now construct the directed acyclic graph (DAG) G∗(θ)= (V ∗, A∗) from G(θ) by contracting every strongly connected component in it. Here node 0∗ in V ∗ corresponding to 0 in V has a weight w(0∗) = 0, and each node i∗(/= 0∗) in V ∗ has a weight w(i∗) representing the number of the nodes in V contracted into i∗. Then the problem (ii) (i.e., maximizing the number of the collected balls) can be solved by finding a longest (or critical) path starting from 0∗ (corresponding to 0 in G(θ)) in this DAG G∗(θ), where the length of a path P is the weighted sum of the nodes in P . This problem is also studied in PERT as one of the scheduling problems, and is solvable in in O(|V ∗| + |A∗|) time (e.g., [11]). Since |V | ≤ n, |A∗| ≤ n2, and G∗(θ) can be constructed in O(n2) time, the problem (ii) is solvable in O(n2) time.
Theorem 2.3 We can compute in O(n2) time a robot schedule that maxi- mizes the number of the balls collected by a robot moving on a given track-line.
 
One might see that the size of G∗(θ) is small if it is constructed from a problem instance of the BCP. Unfortunately, this is not the case. We have a problem instance such that |A∗| = Ω(n2). More precisely, even if we remove from A∗ all transitive arcs a (i.e., a = (i1, i3) if (i1, i2), (i2, i3) ∈ A∗), the size of arcs is still Ω(n2). This means that all the algorithms constructing G∗

explicitly require Ω(n2) time. Therefore, we need a method to represent G∗
(or G) implicitly, in order to construct a faster algorithm.
Chart based algorithm
This section introduces a chart H(θ) to represent G(θ) implicitly, and based on this chart, we present an O(n log n) time algorithm for the problem (ii) when a single robot moves on a given track-line. We first consider a 2-dimensional chart F (θ) with t- and d-axes. F (θ) has n + 1 points (ti, di), i = 0, 1,... n, associated with the region Ri defined by the following 2 inequalities:
d ≤ v(t − ti)+ di
d ≥ −v(t − ti)+ di.
Here (t0, d0) = (0, 0), representing the origin o in the (original) Euclidean plane IR2. Fig. 3 shows an example of F (θ). In this chart, a point (t, d) represents a state that a robot is located at point d at time t. Therefore, a point (t, d) is contained in Ri if and only if a robot starting at state (ti, di) can reach the state (t, d). For example, (t1, d1) ∈ R2 ⊆ R0 in Fig. 3 means that robot can catch ball b1 after moving from the origin at time 0 and even after catching ball b2.

Fig. 3. A chart F (θ) corresponding to the directed graph G(θ) in Fig. 2
We now define a chart H(θ) with α- and β-axes to understand this relations easily. For each i, we define αi and βi by αi = (vti − di)/(2v) and βi = (vti + di)/2v; t values of the points at which lines d = −vt (resp., d = vt) and d = v(t − ti)+ di (resp., d = −v(t − ti)+ di). Chart H(θ) has n +1 points (αi, βi), i = 0, 1,... n. Here we identify the points (αi, βi) (i = 1, 2,..., n) with balls bi. Fig. 4 shows an example of H(θ) (corresponding to F (θ) in Fig. 3).
For two points (αi, βi) and (αj, βj), we write (αi, βi) ≤ (αj, βj) if αi ≤ αj
and βi ≤ βj, and (αi, βi) < (αj, βj) if (αi, βi) ≤ (αj, βj) and (αi, βi) /= (αj, βj).



Fig. 4. A chart H(θ) corresponding to F (θ) in Fig. 3
Lemma 2.4 Let αi and βi be defined as above. Then we have the following necessary and sufficient conditions.
Ball bi can be caught by a robot starting at origin o if and only if (0, 0) ≤ (αi, βi) holds.
Ball bj can be caught by a robot after catching ball bi if and only if
(αi, βi) ≤ (αj, βj) holds.	 
Corollary 2.5 Given a chart H(θ), we can construct G(θ) (and hence G∗(θ)) by connecting arcs from i to j if (αi, βi) ≤ (αj, βj).	 
For example, we can see that Fig. 2 can be constructed from Fig. 4. Our algorithm uses H(θ) instead of G∗(θ). Before showing how to use this H, let us consider the dual of the problem (ii).
Note that a transitive DAG G∗(θ)= (V ∗, A∗) can be regarded as a partially ordered set (poset, in short) P (θ) = (V ∗, ≤), where i∗ ≤ j∗ if either i∗ = j∗ or (i∗, j∗) ∈ A∗. Let us recall that a chain (resp., antichain) in a poset is a set of pairwise comparable (resp., incomparable) elements. Then the following theorem is well-known, called a weighted version of the polar (or dual) Dilworth theorem [12].
Theorem 2.6 Let P be a finite poset with a nonnegative integer weight w(e) of each element e. Then the maximum weight of a chain is equal to the minimum number of antichains covering all elements e in P by w(e) times. 
It follows from Proposition 2.2 and the subsequent discussion that the problem (ii) is to compute a maximum weighted chain of P . Therefore, by Theorem 2.6, the dual of the problem (ii) is to compute a minimum w-multiple antichain covering of P . We construct an optimal algorithm for the problem
(ii) by solving this dual problem with the help of chart H.
Given a set of balls (or points) S in chart H(θ), bi in S is called pareto- optimal if no bj ∈ S satisfies (αj, βj) > αi, βi), and S' ⊆ S is called a pareto-

optimal set of S if all balls in S' are pareto-optimal and no two balls bi and bj in S' satisfy (αi, βi)= (αj, βj). Note that a maximal pareto-optimal set is always maximum, and pareto-optimal sets correspond to antichains of P (θ). More- over, a minimum w-multiple antichain covering of P (θ) can be computed by the following algorithm which finds (and removes) maximum pareto-optimal sets of B repeatedly.
Algorithm Antichain-partition
Input: A set of balls B = {b1, b2,..., bn}.
Output: A minimum antichain partition (S1, S2,..., Sr) of B (corresponding to a minimum w-multiple antichain covering of P (θ))
Step 0: Compute (αi, βi) for all bi ∈ S. Set S := {bi | (αi, βi) ≥ (0, 0)} and
v := 1.
Step 1: Compute a maximal pareto-optimal set Sr in S and remove Sr from
S.
Step 2: If S := ∅, then halt. Otherwise, let v := v + 1 and return to Step
1.	 
Fig. 5 illustrates Algorithm Antichain-partition. Let (S1, S2,..., Sr) be an antichain partition obtained by Algorithm Antichain-partition. A maximum weighted chain of P (θ) can be constructed from Si, i = 1,..., v, as follows. Choose a ball bi1 from Sr arbitrarily, and then find a ball bi2 in Sr−1 such that (αi2 , βi2 ) ≥ (αi1 , βi1 ). By the maximality of Sr−1, such a bi2 always exits. We then find a ball bi3 in Sr−2 such that (αi3 , βi3 ) ≥ (αi2 , βi2 ). By repeating this argument, we finally have a path i0 = 0, i1,..., ir in G(θ). This path clearly corresponds to a weighted chain C of P (θ). Since the weight of chain C is v, it follows from Theorem 2.6 that (S1, S2,..., Sr) corresponding to a minimum w-multiple antichain covering of P (θ) and C is a maximum weighted chain of P (θ).
Although we skip the details how to compute a maximal pareto-optimal set Si in chart H(θ), due to the space limitation, it is not difficult to see that Si can be computed (and deleted) in O(|Si| log n) time by using a balanced binary search tree such as AVL- and splay trees to store H(θ). Therefore, we have the following result which improves upon the one in the previous section. 6
Theorem 2.7 We can compute in O(n log n) time a robot schedule that maxi- mizes the number of the balls collected by a robot moving on a given track-line.
 
Note that the problem contains the sorting problem, since a robot schedule

6 The same result can be obtained by using O(n log |Si|)-algorithm to compute a maximal pareto-optimal set, such as the one proposed in [13].

decides the ordering of balls caught, i.e., sorts the balls caught in the order of ti. Since any (comparison-based) sorting algorithm needs Ω(n log n) time, our algorithm is optimal. We finally remark that our algorithm is based on the fact that each ball crosses at most once, but not the one that balls and robots move on lines, respectively. This means that our method may be applicable in some other situations.

Fig. 5. Algorithm AntiChain-partition


k-robot BCP with a given single track-line
This section considers the case when more than 1 robot can be used. Let us first consider the problem (iii), i.e., minimizing the number of robots to catch all the balls. We show that the problem can be solved in O(n log n) time by using the technique shown in the previous section.
Note that the problem (iii) can be reduced to compute a minimum chain covering of the poset P (θ). We solve the problem by applying the algorithm similar to AntiChain-partition to the chart H∗(θ) defined below.
Let t' = maxi ti, d' = mini,j:di/=dj |di—dj|, and v' = v+δ where 0 < δ < d'/t'. Let H'(θ) be a 2-dimensional chart with t- and d-axes. H(θ) has n +1 points (ti, di), i = 0, 1,... n, associated with the region Ri' defined by d ≤ v'(t—ti)+di and d ≥ —v'(t — ti)+ di. In other words H' is obtained from H by enlarging each region Ri by a small δ. By this modification, no point (ti, di) is on the boundary of Rj, if (ti, di) /= (tj, dj), and since δ is small, H' still has a good property of H, i.e., a point (t, d) is contained in Ri if and only if a robot starting at state (ti, di) can reach the state (t, d).
Let αi∗ = —ti + di/v' and βi∗ = ti + di/v'. Let H∗(θ) denote the chart of the n + 1 points (αi∗, βi∗), i = 0, 1,... n. Similarly to H(θ), the points (αi∗, βi∗) (i = 1, 2,..., n) are identified with balls bi. We can see that H∗ is a dual chart of H in the following sense. Let bi and bj be balls such that (ti, di) /= (tj, dj).

Then (αi, βi) and (αj, βj) are comparable (i.e., (αi, βi) ≤ (αj, βj) or (αi, βi) ≥
(αj, βj)) if and only if (αi∗, βi∗) and (αj∗, βj∗) are incomparable.
Since the problem (iii) is to compute a minimum chain covering of the poset P (θ) (corresponding to H(θ)), the problem (iii) can be solved by computing a minimum antichain covering of the poset P∗(θ) corresponding to H∗(θ). Thus
we can use the algorithm similar to AntiChain-partition for the problem.
The difference of the algorithms are the following 2 points: Step 0 initializes S as S = {bi | αi∗ ≤ 0, βi∗ ≥ 0} and Step 1 computes the set of all pareto- optimal points instead of a maximal pareto-optimal set. The second difference follows from the one between a minimum antichain covering and a minimum w-multiple antichain covering. Similarly to Theorem 2.7, we have the following theorem.
Theorem 2.8 We can compute in O(n log n) time a robot schedule minimiz- ing the number of the robots on a given single track-line that collect all balls.
 
We finally consider the problem (ii) when k ≥ 2. When k is not enough to collect all balls, we can formulate the problem as a minimum cost network flow problem [1,5] of the following network N = (V ', A') associated with the capacity, cost and demand functions. The network N can be constructed from G(θ)= (V, A) as follows.
V '={1+,..., n+}∪ {1−,..., n−}∪ {0,n + 1}
A'={(i+, j−) | (i, j) ∈ A}∪ {(i−, i+) | i = 1,..., n}
∪{(0, i−), (i+,n + 1) | i = 1,..., n}
demand (v)=—k if v = 0, k if v = n + 1, and 0 otherwise
cap(e)=1 for all e ∈ A'
cost (e)=—1 if e = (i+, i−), and 0 otherwise.
Since the demand function demand is integer, one can compute a minimum cost integral flow. Although the details are omitted due to the space limitation, we can show that integral feasible flows correspond to k-robot schedules, and moreover, such minimum cost flows correspond to optimal k-robot schedules. Minimum cost flow problem has been extensively studied [1,5]. Here we make use of primal-dual algorithm with least-cost augmenting paths to the network
N . Since |V '| = O(n), |A'| = O(n2) and k ≤ n, the problem can be solved in
O(n3) time.
Theorem 2.9 We can compute in O(n3) time a k-robot schedule that maxi- mizes the number of the balls collected by k robots moving on a given track- line.	 

Before concluding this section, we note that, differently from Theorems 2.7 and 2.8, Theorem 2.9 does not use the property (or structure) of G(θ), and hence more efficient algorithms may be possible.

BCPs with given multiple track-lines
In this section, we address the case that k (≥ 2) robots move on their own track-line given.
Let θj be an angle for the track-line lj which robot vj moves on. We first study the problem (i) when k = 2.
Theorem 3.1 It can be checked in O(n2) time if all balls can be collected by two robots moving on two given track-lines. Furthermore, if so, such a robot schedule can be computed in O(n2) time.	 
Proof. We reduce the problem to the problem 2-SAT whose size is O(n2). Since 2-SAT is solvable in linear time [6], our problem is solvable in O(n2) time.
We define a Boolean variable ui for each ball bi. Here ui = 1 means that bi is caught by robot v1 and ui = 0 means that bi is caught by robot v2. A 2-CNF ψ contains the following 4 types of clauses.
u¯i, if G(θ1) contains no arc (0, i).
(u¯i ∨ u¯i' ), if G(θ1) contains neither arc (i, i') nor arc (i', i).
ui, if G(θ2) contains no arc (0, i).
(ui ∨ ui' ), if G(θ2) contains neither arc (i, i') nor arc (i', i).
It is easy to see that the size of ψ is O(n2). Note that 3 and 4 are dual of 1 and 2, respectively. By the definitions of G(θ1) and G(θ2), if all balls can be collected by two robots, ψ is satisfiable. On the other hand, if ψ is satisfiable, we shall below show that all balls can be collected. Let u∗ be an assignment such that ψ(u∗) = 1, and let S1 = {i | ui∗ = 1} and S2 = {i | ui∗ = 0}. For any pair of i and i' in S1, G(θ1) contains arc (i, i') or (i', i). It follows from the transitivity of G(θ1) that it must contain a directed path through all the nodes in S1. This implies that S1 can be caught by robot v1. Similarly, S2 can be caught by robot v2. Since S1 ∪ S2 = {1, 2,..., n}, two robots can collect all balls. This completes the proof.	 
Unfortunately, the problem becomes intractable if we generalize the prob- lem slightly.
Theorem 3.2 (i) It is NP-hard to maximize the number of the balls collected by 2 robots with 2 given track-lines.

(ii) It is NP-complete to decide if all balls can be collected by k robots with given track-lines, if k ≥ 3.	 
The next corollary follows from Theorem 3.2 (ii).
Corollary 3.3 It is NP-hard to minimize the number of the robots with given track-lines that collect all balls.	 

BCPs with arbitrary track-lines
In Sections 2 and 3, we consider the BCPs under the assumption that track- lines lj are given in advance. In this section, we consider the case in which a track-line of each robot can be chosen as a part of the robot scheduling.

Selecting track-lines
This section shows that the number of the track-lines that have to be con- sidered for the BCPs is polynomial, although there exist infinitely many lines through the origin.
Let θ denote the angle of a line l through the origin. For any ordered pair of i and j in V (= {0, 1,..., n}), let
Iij = {θ ∈ [0, π) | G(θ) contains arc (i, j)}.
Moreover, let Iij =  Ip , with interval Ip in [0, π). Note that Ip might not

be closed.
p ij	ij	ij

Lemma 4.1 The number of the intervals Ip
representing Iij for i, j ∈ V is

O(1), and the interval representation of Iij can be computed in O(1) time. 
The proof is omitted, since it is rather complicated. The lemma immedi- ately implies the following lemma, since we have n2 ordered pairs (i, j).
Lemma 4.2 There exists O(n2) different directed graphs G(θ), θ ∈ [0, π). 
One might see that O(n2) is overestimated, since G(θ) contains many tran- sitive arcs, in general. However, we can construct a problem instance having Ω(n2) directed graphs G(θ). By combining Lemma 4.2 with the results in the previous sections, we have the following results.
Theorem 4.3 Assume that a track-line of each robot can be decided as a part of the robot scheduling. Then
We can compute in O(n3 log n) time a robot schedule that maximizes the number of the balls collected by a robot.

We can compute in O(n3 log n) time a robot schedule minimizing the number of the robots on a single track-line that collect all balls.
We can compute in O(n5) time a k-robot schedule that maximizes the number of the balls collected by k robots moving on a single track-line.
It can be checked in O(n6) time if all balls can be collected by two robots moving on two track-lines. Furthermore, if so, such a robot schedule can be computed in O(n6) time.	 
Theorem 4.3 (i), (ii), (iii), and (iv) follow from Theorems 2.7, 2.8, 2.9 and 3.1, respectively.
Collecting all balls by a single robot
Theorem 4.3 (i) implies that we can decide whether all balls can be collected by a single robot in O(n3 log n) time. This section shows that a faster algorithm is possible for the problem.
For the angle θ of a line l, let E(θ)= {(i, j) | i < j, G(θ) contains arc (i, j) or (j, i)}.
Lemma 4.4 All balls can be collected by a robot on a line l if and only if
|E(θ)| = n(n + 1)/2.	 
This lemma implies that it is not necessary to check if G(θ) has a directed path from 0 whose length is n, but is sufficient to check the size of E(θ).
Here we only present an outline of the algorithm, due to the space limita- tion. Recall that Iij can be represented by the union of O(1) intervals. We first compute such representations of all Iij, which requires O(n2) time. Let I denotes the family of all such intervals I =< L, R >. Here < is either [ or (, and > is either ] or ). Then we sort all the left and right elements L and R in I, which is possible in O(n2 log n) time. Let J1, J2,..., Jq be such an ordering. We finally check if |E(θ)| = n(n + 1)/2 for all θ = 0, J1 + ϵ, J2 + ϵ,..., Jq + ϵ in this order, where ϵ is sufficiently small positive. ϵ is used for open intervals. It is not difficult to see that these angles are sufficient to check. Since this can be done in O(n2) time, we have an O(n2 log n) time algorithm.
Theorem 4.5 It can be checked in O(n2 log n) time if there exists a track-line l such that a robot can collect all balls by moving on l. Furthermore, if so, such a robot schedule (including l) can be computed in O(n2 log n) time. 

The NP-hardness cases
Similarly to Theorem 3.2, we have the negative results even if the track-lines can be chosen.

Theorem 4.6 Even if a track-line of each robot can be chosen as a part of the robot scheduling, the following statements holds.
It is NP-hard to maximize the number of the balls collected by 2 robots with 2 track-lines.
It is NP-complete to decide if all balls can be collected by k robots with track-lines, if k ≥ 3.	 

Conclusion and Discussions
We have studied the problem of collecting balls moving in the Euclidean plane by robots moving on straight lines through the origin. From the viewpoint of computational complexity, we have investigated the following 3 problems in various situations: (i) deciding if k robots can collect all n balls, (ii) maxi- mizing the number of the balls collected by k robots, and (iii) minimizing the number of the robots to collect all n balls. The results are summarized in Table 1 in Section 1.
There are many possible extensions of the problems. For example, we can relax the track shapes of robots and/or balls. Unfortunately, it is shown that the problems become intractable, if robots and/or balls move on general tracks.
Acknowledgements
The authors would like to thank Prof. Tiko Kameda and Prof. Ichiro Suzuki for their helpful comments. This work was partially supported by the Scientific Grant-in-Aid by the Ministry of Education, Science, Sports and Culture of Japan.

References
Ahuja, R. K., T. L. Magnanti and J. B. Orlin, Network Flows : Theory, Algorithms and Applications, Prentice-Hall, 1993.
Atallarh, M. and S. Kosaraju, Efficient solutions to some transportation problems with applications to minimizing robot arm travel, SIAM Journal on Computing, 17, pp.849–869, 1988.
Bauern¨oppel, F., E. Kranakis, D. Krizanc, A. Maheshwari, J.-R. Sack, J. Urrutia, Planer stage graphs: Characterizations and applications, Theoretical Computer Science, 175, pp. 239–255, 1997.
Chalasani, P., R. Motwani and A. Rao, Approximation Algorithms for Robot Grasp and Delivery, 2nd International Workshop on Algorithmic Foundations of Robotics (WAFR), pp.347–362, 1996.


Cook, W. J., W. H. Cunningham, W. R. Pulleyblank and A. Schrijver, Combinatorial Optimization, John Wiley & Sons, 1998.
Evan, S., A. Itai and A. Shamir, On the Complexity of Timetabling and Multicommodity Flow Problems, SIAM Journal of Computing, 5(4), pp.691–703, 1976.
Garey, M. R. and D. S. Johnson, Computers and Intractability, Freeman, New York, 1979.
Hammar, M. and B. J. Nilsson, Approximation results for kinetic variants of TSP, 26th International Colloquium, Automata, Languages and Programming, ICALP’99, LNCS 1644, pp.392–401, 1999.
Helvig, C. S., G. Robins, and A. Zelikovsky, Moving Target TSP and Related Problems,6th Annual European Symposium, Algorithms - ESA ’98, LNCS 1461, pp.453–464, 1998.
Karuno, Y., H. Nagamochi and T. Ibaraki, Better Approximation Ratios for the Single-Vehicle Scheduling Problems on Line-Shaped Networks, Networks, 39(4), pp. 203–209, 2002.
Knuth, D. E., Fundamental Algorithms, Third Edition, Addison-Wesley, 1997.
Lova´sz, L. and M.D. Plummer, Matching Theory, Annals of Discrete Matghematics, 29, North- Holland, 1986.
Nielsen, F., Output-sensitive peeling of convex and maximal layers, Information Processing Letters, 59, pp. 255 – 259, 1996.
Psaraftis, H. N., M. M. Solomon, T. L. Magnanti, and T. Kim, Routing and Scheduling on a Shoreline with Release Times, Management Science, 36(2), pp. 212–223, 1990.
G. Rote, The N-line traveling salesman problem, Networks, 22, pp.91-108, 1992.
Tsitsiklis, J. N., Special cases of traveling salesman and repairman problems with time windows,
Networks 22, pp.263–282, 1992.
