

Electronic Notes in Theoretical Computer Science 225 (2009) 83–98
www.elsevier.com/locate/entcs

Definite Descriptions and Dijkstra’s Odd Powers of Odd Integers Problem
Hugh Gibbons1
Computer Science Dept., Trinity College, Dublin, Ireland

Abstract
The use of Frege-Russell style definite descriptions for giving meaning to functions has been long established and we investigate their use in the development of Functional Programs and from these to the development of correct imperative programs. In particular, we investigate the development of a functional program for a problem, "Odd powers of odd integers", discussed by Dijsktra. If the correctness of termination is not a concern then it is straightforward to develop a partially correct program. Further properties of the specification are needed to develop a totally correct program.
Keywords: definite descriptions, functional programming, assertions, partial and total correctness.


1	Introduction
The use of definite descriptions dates back to Frege and Russell [13] and also to fur- ther development by Quine [12] and Scott [14]. The use and definitions of definite descriptions are explained in Kalish and Montague [9]. In this article we consider reusing definite descriptions in the development of functional programs. As asser- tions have a central role in the development of imperative programs as promoted by Dijkstra [5] and Gries [8] and the Refinement Calculus [11], we consider the role of definite descriptions in the development of functional programs which can then be further developed to imperative programs.
In this article we investigate in detail the formal development of totally correct programs for a specification described by Dijkstra [6].
For 1	p and odd p and 1	k and odd r such that 1	r < 2k , a value x
exists such that
≤ x < 2k ∧ 2k |(x p − r ) ∧ odd x

1 Email: hugh.gibbons@cs.tcd.ie


1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.068

We are using ‘|’ for ‘divides’.
If proof of termination is not a concern then a very straightforward partially correct program can be easily developed. Proving termination uses induction and from the induction proof a simple functional program is derived. Based on this functional program, a totally correct imperative program is developed similar to that given by Dijkstra. Further properties of the specification are derived using the functional program and an alternative functional program is derived. While the alternative functional program is straighforward, its development into an imperative program is not. This development involves the tranformation of linear recursion to an appropriate tail recursive form which can then be directly transformed to imperative programs with the tail recursive programs providing the invariants for the associated loops.
In the development of the functional versions of the specification we make use of the definite descriptors, ‘the’ and ‘least’.
Definite description, ‘the’
y = the one and only item satisfying p y = (the x • p x)
{Russell}
≡ (∀x • x = y ≡ p x)
{Quine}
{y} = {x • p x}

Definite description, ‘least’
y = (least x • n ≤ x ∧ p x)
≡ n ≤ y ∧ p y ∧ (∀x • n ≤ x < y → ¬(p x))
In particular,
g n = (least x • n ≤ x ∧ p x)
= (p n → n) ∧ (¬(p n) → (least x • (n + 1) ≤ x ∧ p x)
= if p n then n else g (n + 1)
In terms of functional programming lists,
y = (least x • n ≤ x ∧ p x) y = head[x | x ← [n..], p x]
Simple Floor Square Root
As an introductory application of definite descriptions we develop a simple program for finding the integer square root of a number.
For 0 ≤ x we define the (positive) square root of x, as
√x = (the r • 0 ≤ r ∧ r2 = x)

We can define the floor square root, [√x♩ as
r = [√x♩
≡ r ≤ √x < r +1 
≡ r2 ≤ x < (r + 1)2
i.e. [√x♩ = (the r • 0 ≤ r ∧ r2 ≤ x < (r + 1)2)
Show that
[√x♩ = (least r • 0 ≤ r ∧ x < (r + 1)2)
Theorem 1.1
y = (least r • 0 ≤ r ∧ x < (r + 1)2) ⇒ y ∈ {r • 0 ≤ r ∧ r2 ≤ x < (r + 1)2}
Proof Since
y = (least r • 0 ≤ r ∧ x < (r + 1)2)
⇒ 0 ≤ y ∧ x < (y + 1)2
Need to just show that y2 ≤ x
y = (least r • 0 ≤ r ∧ x < (r + 1)2)
⇒ (∀r • 0 ≤ r < y → ¬(0 ≤ r ∧ x < (r + 1)2)
≡ (∀r • 0 ≤ r < y → (0 > r ∨ x ≥ (r + 1)2))
≡ (∀r • 0 ≤ r < y → x ≥ (r + 1)2)
{witness rˆ = y − 1}
⇒ x ≥ y
End proof.	 
Let
fl_sqrt x n = (least r • n ≤ r ∧ x < (r + 1)2)
= if x < (n + 1)2 then n else fl_sqrt x (n + 1)
therefore
fl_sqrt x 0= [√x♩
Writing this as a functional program:
√x	fl _sqrt x 0
where
fl _sqrt x n
| x < (n + 1)2 ≡ n
| x ≥ (n + 1)2 ≡ fl _sqrt x (n + 1)

We can rewrite this tail recursive functional program as an imperative program with the loop invariant based directly on the functional program.
[√−♩::Real → Int

[√x♩≡ 
{ Pre: 0 ≤ x }
local n:Int begin
n := 0
{Inv: fl_sqrt x 0 = fl_sqrt x n } while x ≥ (n + 1)2do
n := n+1
end {fl_sqrt x 0 = n }
{[√x♩ = n}
Result := n
end.
Here the tail recursive program, fl_sqrt, is used as a loop invariant. This connection between tail recursion and loop invariants is further developed in Gibbons [7] and in Broy and Krieg-Bruckner [3].

Dijkstra’s Odd Powers of Odd Integers
For clarity, we repeat the Dijkstra specification given above.
For 1  p and odd p and 1  k and odd r such that 1  r < 2k , a value x exists such that
1 ≤ x < 2k ∧ 2k |(x p − r ) ∧ odd x
Example 2.1  13 is a witness for the existential quantifier x in
(∃x • 1 ≤ x < 24 ∧ 24|(x3 − 5) ∧ odd x) as
24|(133 − 5) ≡ 16|(2197 − 5)
≡ 2192 = 137 × 16
A witness for x in (∃x • 0 ≤ x ∧ 2k|(xp − r)) must be odd as if 2k | (xp − r) then
xp − r is even, hence xp is odd since r is odd, therefore x is odd.
Definite Description function
Consider the following function, f, described by a definite description for finding a witness for x,
Let pre p r k = 1 ≤ p ∧ odd p ∧ 1 ≤ k ∧ odd r ∧ 1 ≤ r < 2k
pre p r k →
f p r k ≡ (least x • 1 ≤ x < 2k ∧ odd x ∧ 2k | (xp − r ))

i.e. using a precondition
{ pre p r k }
f p r k ≡ (least x • 1 ≤ x < 2k ∧ odd x ∧ 2k | (xp − r ))


We rewrite f p r k as a functional program. using list comprehension,
{ pre p r k }
f p r k ≡ head [x | x ← [1..2k ], odd x , 2k | (xp − r )]
or using the higher order function, filter
pre p r k
f p r k	head (ﬁlter b [1, 3, ..])
where
bx ≡ x < 2k ∧ 2k | (xp − r )
Since in general,
g n ≡ (least x • n ≤ x ∧ b x)
≡ if b n then n else g (n + 1)
we get an alternate (tail recursive) functional program, f1,
pre p r k
f1 pr k	floc 1
where
floc x
| 2k |(x p − r ) ∧ x < 2k ≡ x
| otherwise	≡ floc (x + 2)
We can use Quickcheck [4] to test if the functions f and f1 are the same.
We can rewrite the functional program f1 as an iterative imperative program: see figure Algorithm 1 (Imperative f1)

Algorithm 1 Imperative f1
f1::Int×Int×Int → Int
f1 (p,r,k) ≡	k

{Pre: 1 ≤ p ∧ 1 ≤ k ∧ 1 ≤ r < 2
local x:Int begin
x := 1
{Inv:floc 1 = floc x }
∧ odd r }

while ¬( 2k|(xp − r) ∧ x < 2k ) do
x := x+2
end {floc1 = x }
{f1 p r k = x }
{ 2k|(xp − r) ∧ x < 2k ∧ odd x }
Result := x
end.

The loop in this imperative program iterates through the odd integers until it reaches an x such that 2k (xp  r) x < 2k. When tested the program halts for the given inputs but testing is not enough to prove correctness. If the loop terminates then the program will give the correct result.
Alternative FP Version
To show that the loop terminates we are back to showing


under the assumption
(∃x • odd x ∧ 1 ≤ x < 2k ∧ 2|(xp − r))

Pre p r k : 1 ≤ p ∧ odd p ∧ 1 ≤ k ∧ odd r ∧ 1 ≤ r < 2k.
A normal strategy in the context of the refinment calculus is to strenghten the precondition but here the precondition is weakened by dropping the conjunct,
1	r < 2k as it can be shown that ( x	1	x	2k (xp	r)) from the weaker assumption
Pre' rk : 1 ≤ p ∧ odd p ∧ 1 ≤ k ∧ odd r
Whatever satisfies Pre also satisfies Pre', i.e. Pre	Pre'.
Later we will show that the least witness, xˆ, for ( x	1	x	2k (xp	r)) is such that xˆ < 2k.
Theorem 3.1
1 ≤ p ∧ odd p ∧ 1 ≤ k ∧ odd r ⇒ (∃x • odd x ∧ 2k| (xp − r))
Proof (By induction on k) Base case (k=1)
Let x = 1; since r is odd then 1p − r is even therefore 2| (1p − r)
Also, x = 1 is the least such x.
Induction step:
Assume x is the least x such that odd x ∧ 2k| (xp − r), determine least odd y
such that 2k+1|(yp − r).
If 2k+1| (xp − r), let y = x
If ¬(2k+1| (xp − r))then xp−r is odd.
Let y = x + 2k,
yp−r
2k
(x+2k)p−r
2k
xp+p xp−12k+...+px 2(p−1)k+2pk−r

2k
=	xp−r + p xp−1 + ... + px 2(p−2)k + 2(p−1)k

xp	r
{	2k	and p x
yp − r

p−1
are odd }

2k	is even

2k+1| (yp − r)
Also, y = x + 2k is the least such y as if y = x + n with (even n) and n < 2kthen
(x + n)p − r
=	xp−r + p xp−1n+...+np
	
2k	2k
=	xp−r + n (p xp−1+...+np−1)
	
2k	2k
2k (xp	r) but	(2k n (pxp−1 + ... + np−1)) as n < 2k and p xp−1 + ... + np−1 is odd.			 
From this inductive proof, we get the recursive functional program, f2 pr k, for finding x such that odd x ∧ 2k| (xp − r)
{ ≤ p ∧ odd p ∧ 1 ≤ k ∧ odd r }
2
f2 pr (k + 1)	if 2k +1 (xp	r ) then x else x + 2k
where
x ≡ f2 pr k
It is clear this function terminates with respect to the precondition: 1 ≤ k.

Theorem 3.2
pre p r k	⇒	f2 pr k < 2k
where
pre p r k ≡ 1 ≤ p ∧ odd p ∧ 1 ≤ k ∧ odd r ∧ 1 ≤ r < 2k
Proof (By induction on k) Base case: (k=1)
f2 pr 1=1 
< 2
Induction Step: (k > 1) Assume f2 pr k < 2k
Case 2k+1| f2 pr k
f2 pr (k + 1) = f2 pr k
< 2k
< 2k+1
Case ¬(2k+1| f2 pr k)
f2 pr (k + 1) = f2 pr k + 2k
< 2k + 2k
= 2k+1
End Proof.	 

The function, f2 pr k , also satisfies the stronger specification :
1 ≤ p ∧ odd p ∧ 1 ≤ k ∧ odd r ∧ 1 ≤ r < 2k →
f2 pr k ≡ (least x • 1 ≤ x < 2k ∧ odd x ∧ xp mod 2k = r)
and thus is a functional program that satisfies the specification given by Dijkstra.
Dijkstra provides an imperative solution based on the invariant
1 ≤ x < 2k ∧ 2k|(xp − r) ∧ odd x
Concerning his own imperative solution, Dijkstra states in [6]:
“I have evidence that, despite the existence of this very simple solution, the prob- lem is not trivial: many computer scientists could not solve the programming problem within an hour. Try it on you colleagues, if you don’t believe me”
We derive an iterative solution from the recursive version f2 pr k .
Iterative version
The imperative program, f1 above, may be considered an imperative solution of the original f once termination has been guaranteed.
A more direct version of an iterative program can be developed from the recursive program f2. Consider the set
F = {((p, r, k), y) • 1 ≤ k ∧ odd p ∧ 1 ≤ p ∧ odd r ∧ y = f2 pr k}
Let pre p r k = 1	k	odd p	1	p	odd r	1 le r
For k = 1


If ((p, r, k), x) ∈ F then

if 2k +1 (xp	r ) then ((r, k + 1), x )	F
else
((p, r, k + 1), x + 2k ) ∈ F
((p, r, 1), 1) ∈ F.


The set F is an inductively defined set of ordered pairs such that
((p, r, k), y) ∈ F ⇒ y = f2 pr k
Based on the inductive set F we get the specification for an iterative function ft
1 ≤ k ∧ odd p, r ∧ 1 ≤ p, r →
ft p n rkx ≡ (least y • k = n ∧ ((p, r, k ), y ) ∈ F ∧ x = y )

We write ft p n rkx as the functional program,
{ odd p ∧ 1 ≤ k ∧ odd r }
ft p n rkx	− −{ x = f2 pr k ∧ 1 ≤ k ≤ n }

| k = n	≡ x
| 2k +1|(xp − r ) ≡ ft nr (k + 1) x
| otherwise	≡ ft pn r (k + 1) (x + 2k )




Rewriting this as an imperative program; see Algorithm 2 (Imperative ft),






Algorithm 2 Imperative ft
ft::Int×Int×Int → Int
ft (p,r,k) ≡	k
{Pre: 1 ≤ p ∧ odd p ∧ 1 ≤ k ∧ odd r ∧ 1 ≤ r < 2	}
local
j, x : Int
begin
x := 1; j := 1
{Inv: 2k|(xp − r) ∧ odd x ∧ 1 ≤ j ≤ k}
while j /= k do
if 2j+1|(xp − r) then
j := j+1
else
x := x + 2j ; j := j+1
end
end
{ 2k|(xp − r) ∧ odd x }
Result := x
	end.	








Rather than explicitly using 2k we can calculate it implicitly as in the following: see Algorithm 3 (Dijkstra version). This is the version similar to that developed by Dijkstra and like the version developed here does not make use of the restriction
1 ≤ r < 2k in the initial precondition.



Algorithm 3 Dijkstra version
ft::Int×Int×Int → Int
ft (p,r,k) ≡	k
{Pre:	1 ≤ p ∧ odd p ∧ 1 ≤ k ∧ odd r ∧ 1 ≤ r < 2 }
local
j,x,d : Int
begin
j := 1; x := 1; d := 2
{Inv: 2j|(xp − r) ∧ odd x ∧ 1 ≤ j ≤ n ∧ d = 2j }
while j /= k do
if ¬(2 ∗ d |(xp − r)) then
x := x+d
end
d := 2*d j := j+1
end
{ 2k|(xp − r) ∧ odd x }
Result := x end.

Linear Recursion
As a consequence of the following theorem the restriction in the precondition of the specifiction that 1  r < 2k is redundant. A linear recursive function results which also satifies the Dijkstra specification and which then can be developed into an imperative program.
Theorem 4.1
2k|(xp − r) ≡ 2k|(xp − (r mod 2k))
Proof For some q1 and q2,
2k|(xp − r)
≡ (xp − r) = q1 2k
≡{ r = q2 2k + r mod 2k }
(xp − (q2 2k + r mod 2k)) = q1 2k
≡ xp − r mod 2k = q1 2k + q2 2k
≡ xp − r mod 2k = (q1 + q2)2k
≡ 2k|(xp − r mod 2k)
End Proof.	 
From this theorem can conclude that
f2 pr k = f2 p (r mod 2k) k

Since r mod 2k < 2k we also have,
{ 1 ≤ p ∧ odd p ∧ 1 ≤ r ∧ odd r }
f2 p r k < 2k
therefore, the restriction that r < 2k is redundant.
If x = f2 pr k then x < 2k ∧ xp mod 2k = r mod 2k
Alternative program
Taking advantage of the result that f2 pr k = f2 p (r mod 2k ) k and without loss of generality fixing p to be the odd number 3 we can rewrite f2 3 as a new function f3 where
1	k		odd r f3 r 1		1
f3 r (k + 1)   if 2k +1 (x 3   r ) then x else x + 2k
where
r1 ≡ mod r 2k
x ≡ f3 r1 k
This program, f3 is more difficult to transform to an imperative/iterative version. In order to derive an imperative version we use the result that f3 can be rewritten in a linear recursive form by progressive transformations.
Define auxillary functions
dv x r k ≡ if 2k | (x 3 − r ) then 0 else 1
and
next x r k ≡ x + (dv x r k ) ∗ 2k−1 −− ﬁnds the next terms after x
then we can rewrite f3 as
1	k		odd r f3 r 1		1
f3 r (k + 1)   next x r (k + 1)
where
r1 ≡ mod r 2k
x ≡ f3 r1 k
Writing this in an ’if - then - else’ format we get
1	k	odd r
f3 rk	if k = 1
then next (f3 (mod r 2k−1) (k	1)) rk else 1
Using ordered pairs and auxillary functions
nt (xr, xk ) (yr, yk ) ≡ (next xr yr yk, yk )

gt (r, k ) ≡ (mod r 2k−1 , k − 1)
bt (r, k ) ≡ k /= 1
we can reduce this further to a standard form.
f3 x ≡ if bt x then nt (f3 (gt x )) x else x

Transforming Linear Recursion
Termination of the linear recursive function, lr,
lr x ≡ if b x then n (lr (g x )) x else x
depends on the existence of an number i	0 such that	b (gi x )  where
g 0 x = x and gi +1 x = g (gi x ) .
For a binary function f , similar to definitions in Bird [2], we will use the following higher order function \f ‘left-reduce’
\f [] = []
\f [x]= x
\f [x1 ... xn]= f (\f [x1 ... xn−1]) xn
In particular,
\f [x1, x2, x3]= f (f x1 x2) x3
If we have an infix operator  , not necessarily associative, then
\ [x1 ... xn]= (..(x1  x2) .. .)  xn
Given the sequence or list
gs = [gi x , gi−1 x , ... , g x, x ] where i = (least j • ¬ b (gj x ))
then the linear recursive function, lr x = if b x then (n (lr (g x)) x) else x can be implemented as
lr x = \n gs
A more general version of this result is proved in Gibbons [7] which is related to the approach of the Computer aided Intuition guided Programming (CIP) group in Munich Technical University led by Bauer [1].
Theorem 4.2
lr x		=	\n gs where
i = (least j • ¬b (gj x))
gs = [gix, gi−1x, . . . g x, x]

Proof (By Induction)
Notation:
If i < 0 then [gix, gi−1x, . . . g x, x] = []
If i = 0 then [gix, gi−1x, . . . g x, x] = [x]
end Notation
i = 0 
0 = (least j • ¬b (gj x))
tf. ¬b (x)
tf. lr x = x Also, \n gs = x tf. lr x = \n gs
i > 0, Assume true for i − 1, show true for i. i = (least j • ¬b (gj x))
tf. considering gx 
i − 1 = (least j • ¬b (gj (g x)))
Let gs1 = [gi−1(g x), gi−2(g x),...g x]
By induction,
\n gs1 = lr (g x)
Since i > 0
lr x = n (lr (g x)) x
= n (\n gs1) x
{defn. \n }
= \n gs
End proof.	 

Implementing lr x
Since lr x = \n [gix, gi−1x...g x, x] where = (least j • ¬b (gj x)) we consider imple- menting \n (x : xs).
For an item x and a list xs , define a function lrt via
lrtx xs = \n (x : xs)
tf.
lrt x [] = \n [x]
= x
Also, for xs = y : ys /= [],
lrtx xs = \n (x : (y : ys))
{prop. \n}
= \n((nx y) : ys)
= lrt (n x, y) ys

The function, lrt, is the tail recursive function
lrt x xs = if xs /= [ ] then lrt (nx (head xs)) (tail xs) else x
which can be rewritten as an imperative program which we can use to write an imperative program for lrt.(Algorithm 4)



Algorithm 4 lrti x ≡


i	i−1

{ Pre: gs = [g x, g
local y:Int; ys:[Int]
begin
x, . . . g x, x] }

y := head gs; ys := tail gs
{Inv: \n gs = \n(y : ys)}
while ys /= [ ]do
y := n y (head ys) ys := tail ys
en d
{y = lrt x } Result := y
	end lrti	

Finalising Implementation
What is still needed is a program to establish
gs		=	[gix, gi−1x, . . . g x, x] where


Notation:
i = (least j • чb (gj x))

For lists xs, ys
xs ++ ys is the concatenation of the lists.
end Notation
In a similar way to implementing \n gs we consider implementing the function
px xs = [gi−1x, . . . g x, x ] ++ xs
as for each 0 ≤ j < i we have b (gj x).
If чbx then i = 0 and therefore px xs = xs.
If bx then
p (g x ) (x : xs) = [gi−2(g x ), . . . g x ] ++ x : xs
= [gi−1x, . . . g x, x ] ++ xs
= px xs

We can write p x xs as a tail recursive function
px xs	if b x then p (g x ) (x : xs) else xs
Based on this function we can write the following imperative program, init_lrt, (Algorithm 5) that will establish
gs		=	[gix, gi−1x, . . . g x, x] where



Algorithm 5
i = (least j • чb (gj x))

init_lrt : Int -> [Int]
init_lrt x ≡
{ Pre: (∃i • i = (least j • чb (gj
local y:Int; gs:[Int]
begin
y := x; gs := []



x)) }

while (b y) do	{Inv: p x [] = p y gs } gs := y:gs
y := g y
end {y = gix } gs := y:gs
{Post:gs = [gix, gi−1x, . . . g x, x] }
Result := gs
	end init_lrt	



Conclusion
Based on Dijkstra’s specification of the problem of ’Odd Powers of Odd Integers’ this article applies the theory of definite descriptions and functional programming to first develop a correct functional program and from this to the development of a correct imperative program. If the correctness of termination is not a concern then it is straightforward to develop a partically correct imperative program. By developing functional programs many properties of the program are established and while Dijkstra develops a totally correct program via his own weakest precondition technique it is not clear how other properties could be established. Here it is shown that
f p r k = f p (r mod 2k) k
and hence the restriction of r < 2k is redundant which is not noted by Dijkstra.
The development of the totally correct functional programs was done indepen- dently of Dijstra’s article and it was the discovery of Dijkstra’s article that motivated

the more complete development presented here. Including the development of the functional programs clarifies the development of the imperative program and this article agrees with the view of Manna and Waldinger [10] who state that
“Recursion seem to be the ideal vehicle for systematic program construction”.
In this article recursion is also used as the vehicle for the development of the loop invariants of imperative programs and as a result integrates the development of imperative programs with that of functional programs.

References
Bauer, F. and H. Wossner, “Algorithmic Language and Program Development,” Springer-Verlag, 1981.

Bird, R., An introduction to the theory of lists, in: M. Broy, editor, Logic of Programming and Calculi of Discrete Design, Springer-Verlag, 1987 .
Broy, M. and B. Krieg-Bruckner, Derivation of invariant assertions during program development by transformation, ACM Transactions on Programming Languages and Systems 2 (1980).

Claessen, K. and J. Hughes, Speciﬁcation-based testing with quickcheck, in: J. Gibbons and O. de Moor, editors, the fun of programming, Palgrave Macmillan, 2003 .
Dijkstra, E., “A Discipline of Programming,” Prentice Hall, 1976.

Dijkstra, E., “Selected Writings on Computing: A Personal Perspective,” Springer-Verlag, 1982.

Gibbons, H., “Integrating Relational and Imperative Programming via a Weakest Precondition Calculus,” Ph.D. thesis, Trinity College Dublin (1990).
Gries, D., “The Science of Programming,” Springer-Verlag, 1981.

Kalish, D., R. Montague and G. Mar, “Logic Techniques and Formal Reasoning,” Harcourt Brace Jovanovich, 1980.
Manna, Z. and R. Waldinger, Synthesis: Dreams => programs, Technical report, Standford Research Institute (SRI) (1977).

Morgan, C., “Programming from Specifications,” Prentice-Hall, 1990.

Quine, W., “Set Theory and its Logic,” Harvard, 1969.

Russell, B., On denoting, in: A. Martinich, editor, The Philosophy of Language, Oxford University Press, 1996 .

Scott, D., Existence and description in formal logic, in: K. Lambert, editor, Philosophical Applications of Free Logic, Oxford University Press, 1991 .
