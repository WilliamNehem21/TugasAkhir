

Electronic Notes in Theoretical Computer Science 238 (2010) 3–13
www.elsevier.com/locate/entcs

An I/O Automata-based Approach to Verify Component Compatibility:
Application to the CyCab Car
Samir Chouali, Hassan Mountassir, Sebti Mouelhi 1
Laboratoire d’Informatique de l’Universit´e de Franche-Comt´e - LIFC 16, route de Gray - 25030 Besanc¸on cedex, France

Abstract
An interesting formal approach to specify component interfaces is interface automata based approach, which is proposed by L. Alfaro and T. Henzinger. These formalisms have the ability to model both the input and output requirements of components system. In this paper, we propose a method to enrich interface automata by the semantics of actions in order to verify components interoperability at the levels of signatures, semantics, and protocol interactions of actions. These interfaces consist of a set of required and offered actions specified by Pre and Post conditions. The verification of the compatibility between interface automata reuse the L.Alfaro and T.Henzinger proposed algorithm and adapt it by taking into account the action semantics. Our approach is illustrated by a case study of the vehicle CyCab.
Keywords: component based systems, interface compatibility, I/O automata.


Introduction
Interface formalisms play a central role in the component-based design of many types of systems. They are increasingly used thanks to their ability to describe, in terms of communicating interfaces, how a component of a system can be composed and connected to the others. An interface should describe enough information about the manner of making two or more components working together properly. Several approaches and models based on components have been proposed notably those of Szyperski [10] and Medvidovic [7]. Most of these models specify the components behaviors, the connectors ensuring their communications and the services provided or requested. Assembling components is performed by passing through different levels of abstraction, from the conception of the software architectures ADL until the

1 Email: {samir.chouali, hassan.mountassir, sebti.mouelhi}@lifc.univ-fcomte.fr

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.06.002

implementation using platforms like CORBA, Fractal or .NET. The crucial question that arises to the developers is to know if the proposed assembling is correct or not. In this paper, our interests concern components which are described by interface automata. These interfaces specify action protocols: scheduling calls of component actions. As some related works, we can mention the model in [3] where the protocols are associated to the component connectors. Others works as the ones in [9], the authors proposed a comparison between models at three grades of interoperability using the operation signatures, the interfaces protocols and the quality of service. The protocols in [6] based on transitions systems and concurrency including the reachability analysis. The composition operation is essential to define assembly and check the surety and vivacity properties. The approach in [8] aims to endow
the UML components to specify interaction protocols between components.  The
behavioral description language is based on hierarchical automata inspired from StateCharts. It supports composition and refinement mechanisms of system be- haviors. The system properties are specified in temporal logic. In [4], the authors
define a component-based model Kmelia with abstract services, which does not take
into account the data during the interaction. The behavior described by automata associated to services. This environment uses the tool MEC model-checker to verify the compatibility of components. Other works consider real-time constraints [5].
The idea is to determine the component characteristics and define certain criteria to verify the compatibility of their specifications using the tool Kronos.
The works of L.Alfaro and T.Henzinger [1,2], allows to specify component in- terfaces by interface automata. These interfaces are specified by automata which are labelled by input, output, and internal actions. The composition of interfaces is achieved by synchronizing actions. Our approach reuse this model and strengthen- ing it by taking into account the action semantics to ensure a more reliable verifica- tion of components interoperability. The paper is organized as follows: In section 2, we describe the interface automata as well as the definitions and the algorithm used to verify the compatibility between component interfaces. In section 3, we present our approach to verify the interface compatibility, and we apply the approach to the case study of the vehicle CyCab in section 4. We conclude our work and present perspectives in section 5.

Input/Output Automata
The I/O automata are defined by Nancy A.Lynch and Mark.Tutle [12] as a labelled transition systems.Commonly, they are used to model distributed and concurrent systems. Labels of I/O automata fall into three categories of actions: input, output, and hidden actions where input actions are enabled at every state of an automaton.
Definition 2.1 An I/O automaton A = ⟨SA, IA, ΣI , ΣO, ΣH, δA⟩ consists of

a ﬁnite set SA of states;
a subset of initial states IA ⊆ SA;
three disjoint sets ΣI , ΣOand ΣH
A	A	A




of inputs, output, and hidden actions. All

A	A	A

actions, as a whole, are denoted by ΣA = ΣI  ∪ ΣO ∪ ΣH;
A	A	A
a set δA ⊆ SA × ΣA × SA of transitions. It gives a transition relation with the property that for every state s and an input action a there is a transition (s, a, s) in δA.

Interface automata
The formalism of interface automata are introduced by L.Alfaro and T.Henzinger [1,2], to model component interfaces. These automata are I/O automata where it is not necessary to enable input actions at every state. Every component is described by one interface automaton. In an interface automaton, output actions define the called actions by a component in his environment. They describe the required actions of a component. They are labelled by the symbole ”!”. Input actions describe the offered actions of a component. They are labelled by the symbole ”?”. Internal (or hidden) actions are enabled actions inside a component by the component himself. They are labelled by the symbole ”;”.
Both for I/O automata (IOAs) and interface automata (IAs), the input and output actions of an automaton A are called external actions uniformly (Σext=
I  ∪ ΣO) while output actions and internal actions are called locally-controlled
actions (Σloc= ΣO ∪ ΣH ). We define by ΣI (s), ΣO(s), ΣH (s) the input, output,
A	A	A	A	A	A
and internal actions enabled at the state s.
Definition 2.2 An interface automaton A = ⟨SA, IA, ΣI , ΣO, ΣH, δA⟩ consists of


a ﬁnite set SA of states;
A	A	A

an subset of initial states IA ⊆ SA. It contains at most one state. If IA = ∅, then A is called empty;
three disjoint sets ΣI , ΣO and ΣH of inputs, output, and hidden actions;
A	A	A
a set δA ⊆ SA×ΣA×SA of transitions between states. Contrarily to I/O automata, the input actions are not necessarily enabled at every state.
The optimistic view of interface automata incorporates a notion of interface com- position that leads to smaller compound automata than the input-enabled view. When we compose two interface automata, the resulting composite automaton may contain illegal states, where one automaton issues an output that is not acceptable as input in the other one. The proposed approach to compute compatibility between interface automata based on the fact that each interface expects the environment to provide only legal inputs. The compound interface expects the environment to pass over transitions leading only to legal states. The existence of a such legal en- vironment for the composition of two interfaces indicates that there is a way to use their corresponding components together by ensuring the encounter of their envi- ronment assumptions. The composite interface automaton combines the behaviors of the two component interfaces and the environment assumptions under which the components can work together properly.

Composition and Compatibility
In this section we present the approach of L.Alfaro a T.Henzinger [1,2] to verify the compatibility of components which are specified by interface automata. The following definition presents the composition of two interface automata.
Definition 2.3 Two interface automata A1 and A2 are composable if

I  ∩ ΣI
1	2
= ΣO
1
∩ ΣO
2
= ΣH
1
∩ ΣA2
= ΣH
2
∩ ΣA1 = ∅

Shared (A1,A2) = (ΣI  ∩ ΣO ) ∪ (ΣI  ∩ ΣO ) is the set of shared actions between
A1	A2	A2	A1
A1 and A2. We can now define the product automaton A1 ⊗ A2 properly.
Definition 2.4 Let A1 and A2 be two composable interface automata. The product
A1 ⊗ A2 is deﬁned by
SA1⊗A2 = SA1 × SA2 and IA1⊗A2 = IA1 × IA2 ;

I
A1⊗A2
= (ΣI
1
∪ ΣI
2
) \ Shared(A1, A2);

O
A1⊗A2
= (ΣO
1
∪ ΣO ) \ Shared(A1, A2);

H
A1⊗A2
= ΣH
1
∪ ΣH
2
∪ Shared(A1, A2);

((s1, s2), a, (s' , s' )) ∈ δA ⊗A  if
1	2	1	2

· a /∈ Shared(A1, A2) ∧ (s1, a, s' ) ∈ δA
· a /∈ Shared(A1, A2) ∧ (s2, a, s' ) ∈ δA
· a ∈ Shared(A1, A2) ∧ (s1, a, s' ) ∈ δA
∧ s2 = s'
∧ s1 = s'
∧ (s2, a, s' ) ∈ δA .

1	1	2	2
The incompatibility between two composable interface automata is due to the ex- istence of some states (s1,s2) in the product where one of the automata outputs a shared action sa from the state s1 which is not accepted as input from the state s2 or vice versa. These states are called illegal states.
Definition 2.5 Given two composable interface automata A1 and A2, the set of illegal states Illegal (A1, A2) ⊆ SA1 × SA2 of A1 ⊗ A2 is defined by {(s1, s2) ∈ SA1 ×
SA |∃a ∈ Shared(A1, A2). (a ∈ ΣO (s1) ∧ a /∈ ΣI  (s2)) ∨ (a ∈ ΣO (s2) ∧ a /∈

2
ΣI  (s1))}.
A1	A2	A2

A1
The reachability of states in Illegal (A1, A2) do not implies that A1 and A2 are not compatible. The existence of an environment E that produces appropriate inputs for the product A1 ⊗ A2 ensures that illegal states will not be entered and then A1 and A2 can be used together. The compatible states, denoted by Comp(A1,A2), are states from which the environment can prevent entering illegal states. The compatibility can be defined differently, A1 and A2 are compatible if and only if their initial state is compatible.
Definition 2.6 Given two compatible interface automata A1 and A2. The compos- tion A1  A2 is an interface automaton deﬁned by: (i ) SA1  A2 = Comp(A1,A2), (ii ) the initial state is IA1  A2 = IA1⊗A2 ∩ Comp(A1,A2), (iii ) ΣA1  A2 = ΣA1⊗A2 , and (iv ) the set of transitions is δA1  A2 = δA1⊗A2 ∩ (Comp(A1,A2) × ΣA1  A2 × Comp(A1,A2)).

In this approach, the verification of the compatibility between a component C1 and a component C2 is obtained by verifying the compatibility between their interface automata A1 and A2. The verification steps of the compatibility between A1 and A2 are listed below.

Algorithm
Input : interface automata A1, A2
Output : A1  A2
Algorithm steps:
verify that A1 and A2 are composable,
calculate the product A1 × A2,
calculate the set of illegal in A1 × A2,
calculate the bad states in A1 × A2 : the states from which the illegal state are reachable by enabling only the internal action or the output actions (one suppose the existence of a helpful environment),
Calculate A1  A2 by eliminating from the automaton A1 × A2, the illegal state, the bad state, and the unreachable states from the initial states,
after performing the above step, if the automaton A1  A2 is empty then the interface automata A1, A2 are not compatible, therefore C1 and C2 can not be assembled correctly in any environment. Otherwise A1 and A2 are compatible.
The complexity of this approach is in time linear on |A1| and |A2| [1].

Considering action semantics in the verification of interface automata compatibility
In this section, we present an approach to verify the compatibility between com- ponent interfaces based on the I/O automata and the approach of L.Alfaro and T.Henzinger [1].The contribution of our approach compared to the one presented in [1], is the consideration of the action semantics in the component interfaces and in the verification of the component compatibility. In [1], one verify component com- patibility by considering only action signatures. We consider, that action signatures are not sufficient to decide on the component compatibility using an approach based on I/O automata.
We propose to annotate transitions in an interface automaton by pre and post conditions of actions. We adapt the compatibility verification algorithm presented in [1], to take into account pre and post of actions. In the following definitions we formalise the adaptations on the L.Alfaro and T.Henzinger approach in order to introduce action semantics in the interface automata.
We introduce a finite set of variables x ∈ V with their respective domain Dx. These variables are used to represent the effect of actions by updating there values. The variable updates are modeled by pre and post atomic formulas over V.
Definition 3.1 Let A = ⟨SA, IA, ΣI , ΣO, ΣH,PreA, PostA, δA⟩ be an IA strength-
A	A	A

ened by action semantics where
a ﬁnite set SA of states;
an initial state IA ⊆ SA;
three disjoint sets ΣI , ΣOand ΣH of inputs, output, and hidden actions;
A	A	A
Pre and Post are the set of pre and post-conditions of actions, they are atomic formulae over the set of variables V;
a set δA ⊆ SA × PreA × ΣA × PostA × SA of transitions.
For a ∈ ΣA, we denote by PreAa and PostQa respectively the precondition and post-condition of the action a in the automaton A.

The composition condition is the same as the preexisting approach. The composi- tion of two automata may take effect only if their actions are disjoint, except shared input and output actions between them. When we compose them, shared actions are synchronized and all the others are interleaved asynchronously.
Definition 3.2 Let A1 and A2 be two composable interface automata. The product
A1 ⊗ A2 is deﬁned by
SA1⊗A2 = SA1 × SA2 and IA1⊗A2 = IA1 × IA2 ;

I
A1⊗A2
= (ΣI
1
∪ ΣI
2
) \ Shared(A1, A2);

O
A1⊗A2
= (ΣO
1
∪ ΣO ) \ Shared(A1, A2);

H
A1⊗A2
= ΣH
1
∪ ΣH
2
∪ Shared(A1, A2);

((q1, q2), Pre, a, Post, (q' , q' )) ∈ δA ⊗A  if
1  2	1	2

· a /∈ Shared(A1, A2)  ∧ (q1,Pre1, a, Post1, q' ) ∈ δA
∧ q2 = q'
∧ Pre ≡

Pre1 ∧ Post ≡ Post1
· a /∈ Shared(A1, A2)  ∧ (q2,Pre2, a, Post2, q' ) ∈ δA
∧ q1 = q'

∧ Pre ≡

Pre2 ∧ Post ≡ Post2
· a ∈ Shared(A1, A2)	∧	((q1,Pre1, a, Post1, q' )  ∈  δA

∧	a ∈ ΣI )	∧
1

((q2,Pre2, a, Post2, q' ) ∈ δA	∧ a ∈ ΣO ) ∧ Pre ≡ Pre2 ∧ Post ≡ Post1

such that Pre2 ⇒ Pre1 ∧ Post1 ⇒ Post2
· a ∈ Shared(A1, A2)	∧	((q1,Pre1, a, Post1, q' )  ∈  δA

∧	a ∈ ΣO )	∧
1

((q2,Pre2, a, Post2, q' ) ∈ δA
∧ a ∈ ΣI
2
) ∧ Pre ≡ Pre1 ∧ Post ≡ Post2

such that Pre1 ⇒ Pre2 ∧ Post2 ⇒ Post1
Illegal states are the states at which the shared actions do not synchronize. We distinguish two different cases: (i) a component requires a shared action which is not provided by the environment, or (ii) they synchronize on a shared action between them but the required action and the provided one are not compatible at the semantic level.
Definition 3.3 Given two composable interface automata A1 and A2, the set of illegal states Illegal (A1,A2) ⊆ S1 × S2 of A1 ⊗ A2 is deﬁned by {(q1, q2) ∈ SA1 × S2 | ∃ a ∈ Shared(A1, A2). such that the following conditions hold } .



⎛	a ∈ ΣO(q1) Λ a ∈/ ΣI (q2)
⎜	V
⎜	(a ∈ ΣO(q1) Λ a ∈ ΣI (q2)
⎞	⎛	a ∈ ΣO(q2) Λ a ∈/ ΣI (q1)	⎞
⎟	⎜	V	⎟
⎟ or ⎜	(a ∈ ΣO(q2) Λ a ∈ ΣI (q1)	⎟

1	2	2	1
⎜	Λ	⎟	⎜	Λ	⎟
⎝ (Pre1 ⇒/	Pre2) V (Post2 ⇒/	Post1)) ⎠	⎝ (Pre2 ⇒/	Pre1) V (Post1 ⇒/	Post2)) ⎠

The set of illegal states in the product A1 ⊗ A2 describes the possibility that one of the two automata may produce an output action that is an input action of the other, but it is not accepted. In our contribution, we extend the previous definition by the possibility that, for some states (q1, q2) in the set of illegal states, an output action issued from q1 in A1 can be synchronized with the same action enabled as input at q2 in A2 but the precondition of the output action does not imply the the precondition of the input action or its post-condition is not implied by the post-condition of the input one.
Compatible states, denoted by Comp(A1,A2), are states from which the en- vironment can prevent entering illegal states. The compatibility can be defined differently, A1 and A2 are compatible iff their initial state is compatible.
Definition 3.4 Given two composable interface automata A1 and A2. The com- postion A1  A2 is an interface automaton deﬁned by: (i ) SA1  A2 = Comp(A1,A2), (ii ) the initial state is IA1  A2 = IA1⊗A2 ∩ Comp(A1,A2), (iii ) ΣA1  A2 = ΣA1⊗A2 , and (iv ) the set of transitions is δA1  A2 = δA1⊗A2 ∩ (Comp(A1,A2) × PreA1⊗A2 × ΣA1  A2 × PostA1⊗A2 × Comp(A1,A2)).
In this approach, the verification of the compatibility between a component C1 and a component C2 is obtained by verifying the compatibility between their interface automata A1 and A2.Therefore, one verify if there is a helpful environment where it is possible to assemble correctly the components C1 and C2. So, one suppose the existence of such environment which accepts all the output actions of the automaton of the product A1 × A2, and which do no not call any input actions in A1 × A2.
In order to verify the compatibility between two components C1 and C2, it is necessary to verify of the compatibility between their respective interface automata A1 and A2. So, one verify if there is a helpful environment (other components) where it is possible to assemble correctly the components C1 and C2. So, one suppose the existence of such environment which accepts all the output actions of the automaton of the product A1 × A2, and which do no not call any input actions in A1 × A2.
Remark 3.5 The verification steps in this approach are the same as the ones pre- sented in the section 2.1.1(the same steps as in [1]). However, in our approach we consider the action semantics in :
the interface automata definition,

the product of two interface automata,
the definition of the illegal states.
Consequently, our approach does not increase the linear complexity of the veri- fication algorithm.
The CyCab case study
Several approaches have been proposed to study the concept of CyCab [11]. The CyCab car is a new electrical means of transportation conceived essentially for free- standing transport services. It is totally manipulated by a computer system and it can be driven automatically according to many modes.


Fig. 1. A UML-like model of the CyCab components.
The goal of the CyCab car system design is to allow for users the displacement of the vehicle from one station to another. As an illustration of its concept, we consider the following requirements and functionalities of the CyCab car and its environment:
(i) a CyCab has and appropriate road where stations are equipped by sensors, (ii) the driving of the CyCab is guided by information received from the station allowing to position of the CyCab from the stations, (iii) there is no obstacle in the roads,
(vi) the vehicle has a starter and also an emergency halt button.
The CyCab car and its environment can be seen as an abstract system composed of four components: the vehicle, the emergency halt button, the starter, and the station. The Figure 1 represents the UML 2 component model of our system. The emergency halt button can be activated at every moment during the running of the vehicle. It is specified by sending a signal emergency!. The starter allows the starting of the vehicle. The station is materialized by a sensor that receives signals position? from the vehicle to know its position. The station sends as consequence a signal far! or halt! to the vehicle to indicate if it is far from the station or not.
Assume that Av is the interface automaton associated to the component vehicle and V = { carstrd, isknpos, isacstr, isrcstn, isnuldist } be the set of five boolean variables used to define pre and post-conditions of actions.

2 The component diagram showed in Figure 1 do not respect exactly the UML 2 notation. It is simply used















Fig. 2. The IAs Av and As of the Vehicle and the Station
The variable carstrd indicates if the vehicle is started or not, the variable isknpos in- dicates if the vehicle knows its position from the station, isacstr equals to true when the starter is active, isrcstn equals to true when the station is reached, and finally the variable isnuldist indicates if the distance between the vehicle and the station is null or not. The automaton Av is given by the tuple ⟨Sv, Iv, ΣI, ΣO, ΣH,Prev, Postv, δv⟩

where
v	v	v

Prev = {V PrH, V PrS, V PrE, V PrF, V PrP, V PrR} where
VPrH ≡ carstrd = true Λ isrcstn = false Λ isknpos = true Λ isnuldist = true;
VPrS ≡ isknpos = false Λ carstrd = false Λ isacstr = true;
VPrE ≡ carstrd = true;
VPrF ≡ carstrd = true Λ isrcstn = false Λ isknpos = true Λ isnuldist = false;
VPrP ≡ carstrd = true Λ isknpos = false;
VPrR ≡ carstrd = false Λ isacstr = false;
Postv = {V PsH, V PsS, V PsE, V PsF, V PsP, V PsR} where
VPsH ≡ carstrd = false Λ isrcstn = true;
VPsS ≡ carstrd = true;
VPsE ≡ carstrd = false Λ isacstr = false;
VPsF ≡ carstrd = true Λ isrcstn = false;
VPsP ≡ carstrd = true Λ isknpos = true;
VPsR ≡ isacstr = true.
The automaton As is given by the tuple ⟨Qs, Is, ΣO, ΣH,Pres, Posts, δs⟩ where
s	s
Pres = {SPrP, SPrH, SPrF} where:
SPrP ≡ carstrd = true Λ isknpos = false;
SPrH ≡ carstrd = true Λ isrcstn = false Λ isknpos = true;
SPrF ≡ carstrd = true Λ isrcstn = false Λ isknpos = true;
Posts = {SPsP, SPsH, SPsF} where:
SPsP ≡ carstrd = true Λ isknpos = true;
SPsH ≡ carstrd = false Λ isrcstn = true Λ isacstr = true;
SPsF ≡ carstrd = true Λ isrcstn = false;

to clarify the CyCab system

The composition of the two interfaces Av and As is possible because the set Shared(Av,As) = {position, halt, far} /= ø and they are composable. The syn- chronized product between them as shown in the figure 3, have as pre and post conditions of operations Prev⊗s = {PrS, PrP, PrH, PrF, PrE, PrR} and Postv⊗s
= {P sS, P sP, P sH, P sF, PsE, P sR} where
PrP ≡ VPrP if VPrP ⇒ SPrP , PrH ≡ SPrH if SPrH ⇒ VPrH, PrF ≡
SPrF if SPrF ⇒ VPrF , PrS ≡ VPrS, PrE ≡ VPrE, and PrR ≡ VPrR;
PsP ≡ SPsP if SPsP ⇒ VPsP , PsH ≡ VPsH if VPsH ⇒ SPsH, PsF ≡
VPsF if VPsF ⇒ SPsF , PrS ≡ VPsS, PrE ≡ VPsE, and PrR ≡ VPsR. We compute the synchronized product automaton
PrH,halt;,VPsH  SPsH
Fig. 3. Illegal states in the product Vehicle⊗Station
After computing the set of illegal states in the product, we obtain the set Illegal(Av,As) = {32, 12}. The state 32 is an illegal state because from the state 3 in the automaton Vehicle, the postcondition of the input shared action, halt?, do not imply the postcondition of the corresponding output action, halt!, from the state 2 in the component Station (VPsH a SPsH). In fact, the component Vehicle in- puts the actions halt which provokes strictly the vehicle halt, while the component Station solicits an action halt which provokes the the vehicle halt and the station reach.
Next, we compute by performing a backward reachability analysis from Illegal states which traverses only internal and output steps, all states thus reachable. The resulting set is {11, 21, 42} and so the set of unreachable states is {41}. Finally, we remove all incompatible and unreachable states {11, 21, 42, 32, 12, 41} and from the product automaton to obtain their composite automaton Av  As. The set of remaining states is empty then, the two interfaces Vehicle and Station are not compatible.
Remark 4.1 If we apply the approach proposed by L.Alfaro and T.Henzinger [1] on the same use case, we can detect a compatibility between the components Vehicle and Station, which is contrasted by considering the semantics of the action halt.

Conclusion and perspectives
The proposed work in this paper is a methodology to analyze the compatibility between component interfaces. We are inspired by the method proposed by L. Al- faro and T. Henzinger where interfaces are described by protocols modeled by I/O automata . We improved these automata by pre and post conditions of component actions in order to handle the action semantics in the verification of interface com- patibility. This verification is made up of two steps. The first determines if two components are composables or not by checking some conditions on the actions fea- sibility by considering their semantics. The second aims is to detect inconsistencies between the sequences of action calls given by communicating protocols. This phase is obtained by considering the synchronized product of interface automata. These results are applied on the case study of the autonomous vehicle CyCab.
In this context, we are interesting for two research directions. The first consists in implementing a verification tool which takes into account pre and post conditions of actions to check compatibility between interfaces. The second concerns composite components and their refinement to define under which conditions a set of assembled components satisfies constraints of the composite component.

References
L. Alfaro and T. A. Henzinger. Interface automata. In 9 th Annual Aymposium on Foundations of Software Engineering, FSE, pages 109-120. ACM Press, 2001.
L. Alfaro and T. A. Henzinger. Interface-based design. Engineering Theories of Softwareintensive Systems (M. Broy, J. Gruenbauer, D. Harel, and C.A.R. Hoare, eds.), NATO Science Series : Mathematics, Physics, and Chemistry, 195 :83-104, 2005.
Robert Allen and David Garlan. A formal basis for architectural connection. ACM Transactions on Software Engineering and Methodology, 6(3): 213-249, July 1997.
Pascal Andr, Gilles Ardourel, and Christian Attiogb. Behavioural Verification of Service Composition. In ICSOCWorkshop on Engineering Service Compositions,WESC05, pages 77-84, Amsterdam, The Netherlands, 2005. IBM Research Report RC 23821.
J.-P. Etienne and S. Bouzefrane. Vers une approche par composants pour la modlisation dapplications temps rel. In (MOSIM06) 6me Confrence Francophone de Modlisation et Simulation, pages 1-10, Rabat, 2006. Lavoisier.
Jeff Magee, Jeff Kramer, and Dimitra Giannakopoulou. Behaviour analysis of software architectures. In WICSA1 : Proceedings of the TC2 First Working IFIP Conference on Software Architecture (WICSA1), pages 35-50, Deventer, The Netherlands, The Netherlands, 1999. Kluwer, B.V.
Nenad Medvidovic and Richard N. Taylor. A classification and comparison framework for software architecture description languages. Software Engineering, 26(1): 70-93, 2000.
S. Moisan, A. Ressouche, and J. Rigault. Behavioral substitutability in component frameworks : A formal approach, 2003.
Becker Steffen, Overhage Sven, and Reussner Ralf. Classifying software component interoperability errors to support component adaption. In Crnkovic Ivica, Stafford Judith, Schmidt Heinz, and Wallnau Kurt, editors, Component Based Software Engineering, 7th International Symposium, CBSE 2004, Edinburgh, UK, Proceedings, pages 68-83. Springer, 2004.
C. Szyperski. Component Software. ACM Press, Addison-Wesley, 1999.
Baille Grard, Garnier Philippe, Mathieu Herv and Pissard-Gibollet Roger. The INRIA Rhˆone-Alpes Cycab. INRIA technical report, Avril 1999.
N. Lynch and M. Tuttle, Hierarchical Correctness Proofs for Distributed Algorithms, 6th ACM Symp on Principles of Distributed Computing,137-151, ACM Press,1987.
