

Electronic Notes in Theoretical Computer Science 218 (2008) 53–72
www.elsevier.com/locate/entcs
Proofs as Polynomials
Esfandiar Haghverdi2
School of Informatics Indiana University
Bloomington, Indiana 47408, USA
Philip J. Scott1,3
Department of Mathematics & Statistics University of Ottawa
Ottawa, Ontario K1N 6N5, CANADA

Abstract
Girard’s Geometry of Interaction (GoI) develops a mathematical framework for modelling the dynamics of cut-elimination. In previous work we introduced a typed version of GoI, called Multiobject GoI (MGoI) for multiplicative linear logic [22]. This was later extended to cover the exponentials by the first author [23]. Our development of MGoI depends on a new theory of partial traces, as well as an abstract notion of orthogonality (related to work of Hyland and Schalk.) In this paper we recall the MGoI semantics for MLL,
and discuss how it relates to denotational semantics of MLL in certain *-autonomous categories. Finally, we prove characterization theorems for the MGoI interpretation of MLL in partially traced categories with an orthogonality, and for the original untyped GoI interpretation of MLL in a traced unique decomposition category.
Keywords: Geometry of Interaction, Linear Logic, Traced Categories, Unique Decomposition Categories, Characterization Theorems.


Introduction
Geometry of Interaction (GoI) is an interpretation of linear logic, introduced by Girard in a fundamental series of papers beginning in the late 80’s [13,11,14] and continued recently in [15], and [16]. One striking feature of this work is that it provides a mathematical framework for modelling cut-elimination (normalization) as a dynamical process of information flow, independent of logical syntax. Girard

1 Research supported by an NSERC Discovery Grant.
2 Email: ehaghver@indiana.edu
3 Email: phil@site.uottawa.ca

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.005

introduces methods from functional analysis and operator algebras to model proofs and their dynamical behaviour. wires
In Girard’s Geometry of Interaction, the dynamics of cut-elimination is captured in a solution of a system of feedback equations, summarized in an operator EX(u, σ) (the Execution Formula). We remark that our general categorical framework (based
on partial traces) permits a structured approach to solving such feedback equations and deriving properties of the Execution formula. The main feature is that for the GoI interpretation θ(Π) of proofs of appropriate sequents in multiplicative, exponential linear logic (MELL) [13,20], and proofs in System F [13], EX(θ(Π), σ) is an invariant of cut-elimination.
Categorical foundations of GoI were initiated in the 90’s in lectures by M. Hyland and by S. Abramsky. An early categorical framework was given in [4]. Recent work has stressed the role of Joyal-Street-Verity’s traced monoidal categories [25] (with
additional structure). For example, Abramsky’s GoI Situations [1,18,3] provide a
basic algebraic foundation for GoI interpretation of MELL. We used a special kind of GoI Situation (with traced unique decomposition categories) to axiomatize the details of Girard’s original GoI 1 paper [20].
In our previous papers, we emphasized several important aspects of Girard’s early GoI papers, especially from the categorical viewpoint:
The original Girard framework is essentially untyped: there is a reflexive object U in the underlying model (with various retractions and/or domain isomor- phisms, e.g. U ⊗ U  U ).
Cut-elimination is interpreted by feedback, which can be naturally represented in traced monoidal categories. The execution formula can be defined via a trace and provides an invariant for cut-elimination.
Girard introduced an orthogonality operation ⊥ on endomaps of U together with the notion of types (as sets of endomaps equal to their biorthogonal) to interpret the formulas of logic. More recently, orthogonalities have been studied abstractly by Hyland and Schalk [24].
Proofs with cuts are thought-of as algorithms. One runs these algorithms by applying the Execution formula, a formal power series representing the dynamics of cut-elimination. The convergence of this execution/trace formula leads to cut-free proofs, thought-of as data.
We also emphasize that Girard’s GoI, and MGoI in this paper, form a novel interpretation of proofs: one which explicitly incorporates the cuts. For us, the associated mathematical models of MGoI, and their theory of dynamical invariants, form a fundamental structure separate from the denotational lit- erature. However, one can make meaningful comparisons with this literature. We include some basic results of such a comparison here. We show the de- notational versus GoI interpretations (when defined) in certain ∗-autonomous “GoI” categories are quite different in general, although in a precise sense they agree on cut-free proofs.

Points (i) and (ii) above were already emphasized in the Abramsky program, as well as in the work of Danos and Regnier [1,3,20,7]. The points (i)–(v), especially the last two, are crucial to our overall program of axiomatizing Girard’s GoI categorically in [20,21].
The contributions of this paper can be summarized as follows:
We compare (M)GoI interpretations to denotational interpretations in appropri- ate GoI (or Int) categories.
We prove a characterization theorem for our MGoI interpretation of MLL in arbitrary partially traced categories with an appropriate orthogonality relation.
We prove a characterization theorem for the untyped GoI semantics of MLL
(fully described in [20]) in a traced UDC-based GoI Situation.

Trace Class
The notion of categorical trace was introduced by Joyal, Street and Verity in an influential paper [25]. The motivation for their work arose in algebraic topology and knot theory, although there have been many applications recently in Computer Science. For references and history, see [1,3,20].
In [22] we went one step further and looked at partial traces. The idea of generalizing the abstract trace of [25] to the partial setting is not new. For example, partial traces were already studied in work of Abramsky, Blute, and Panangaden [2], in unpublished lecture notes of Gordon Plotkin [28], work of Blute, Cockett, and Seely [5], and others. For a comparative account, see [22].We shall briefly recall the notion of partial trace from [22].
Recall, following Joyal, Street, and Verity [25], a (parametric) trace in a sym- metric monoidal category (C, ⊗,I, s) is a family of maps


U X,Y
: C(X ⊗ U, Y ⊗ U ) → C(X, Y ),

satisfying various well-known naturality equations.  A partial (parametric) trace

requires instead that each TrU
be a partial map (with domain denoted TU
) and

satisfy various closure conditions.
Definition 2.1 (Trace Class) Let (C, ⊗,I, s) be a symmetric monoidal category. A (parametric) trace class in C is a choice of a family of subsets, for each object U of C, of the form


U X,Y
⊆ C(X ⊗ U, Y ⊗ U ) for all objects X, Y  of C

together with a family of functions, called a (parametric) partial trace, of the form


U X,Y
U X,Y
→ C(X, Y )

subject to the following axioms. Here the parameters are X and Y and a morphism

U X,Y
, by abuse of terminology, is said to be trace class.

Naturality in X and Y : For any f ∈ TU	and g : X' → X and h : Y → Y ',


(h ⊗ 1U )f (g ⊗ 1U ) ∈ TU '  ' ,

and	TrU '  ' ((h ⊗ 1U )f (g ⊗ 1U )) = hTrU


(f ) g.

X ,Y	X,Y
Dinaturality in U : For any f : X ⊗ U → Y ⊗ U', g : U' → U ,


(1Y
⊗ g)f ∈ TU
iff f (1X
⊗ g) ∈ TU'  ,



and	TrU
((1Y
⊗ g)f ) = TrU'
(f (1X
⊗ g)).

Vanishing I: TI	= C(X ⊗ I, Y ⊗ I), and for f ∈ TI


I X,Y
= ρY fρ−1.

Here ρA : A ⊗ I → A is the right unit isomorphism of the monoidal category.
Vanishing II: For any g : X ⊗ U ⊗ V → Y ⊗ U ⊗ V , if g ∈ TV	, then


U⊗V X,Y
V
X⊗U,Y ⊗U
∈ TU	,



and	TrU⊗V (g) = TrU
(TrV
(g)).

X,Y
X,Y
X⊗U,Y ⊗U

Superposing: For any f ∈ TU	and g : W → Z,




and	TrU
U
W ⊗X,Z⊗Y

(g ⊗ f ) = g ⊗ TrU
,

(f ).

W ⊗X,Z⊗Y	X,Y

Yanking:	sUU ∈ TU
,	and	TrU
(sU,U ) = 1U .

A symmetric monoidal category (C, ⊗,I, s) with such a trace class is called a
partially traced category, or a category with a trace class.
If we let X and Y be I (the unit of the tensor), we get a family of operations

U I,I
U I,I
→ C(I, I) defining what we call a non-parametric (scalar-valued) trace.

Examples of Partial Traces
Finite Dimensional Vector Spaces
The category Vecfd of finite dimensional vector spaces and linear transformations is a symmetric monoidal, indeed an additive, category (see [26]), with monoidal product taken to be ⊕, the direct sum (biproduct). Hence, given f : ⊕IXi → ⊕J Yj with |I| = n and |J| = m, we can write f as an m × n matrix f = [fij] of its components, where fij : Xj → Yi (notice the switch in the indices i and j).
We give a trace class structure on the category (Vecfd, ⊕, 0) as follows. We shall say an f : X ⊕ U → Y ⊕ U is trace class iff (Id − f22) is invertible, where Id is the identity matrix, and Id and f22 have size dim(U ). In that case, we write

(1)
U X,Y
(f ) = f11 + f12(Id − f22)−1f21

This definition is motivated by a generalization of the fact that for a matrix A, (Id− A)−1 =  i Ai, whenever the infinite sum converges. Clearly this sum converges when the matrix norm of A is strictly less than 1, or when A is nilpotent, but in
both cases the general idea is the desire to have (Id − A) invertible. If the infinite
sum for (Id − f22)−1 exists, the above formula for TrU	(f ) becomes the usual
“particle-style” trace in [1,3,20]. One advantage of formula (1) is that it does not a
priori assume the convergence of the sum, nor even that (Id−f22)−1 be computable by iterative methods.
Proposition 2.2 (Vecfd, ⊕, 0) is partially traced, with trace class as above.
The proof of Proposition 2.2 uses the following standard facts from linear algebra, a connection which we find very interesting:
⎡ A B ⎤

Lemma 2.3 Let M = ⎣
be a partitioned matrix with blocks A (m × m),
C D 

B (m × n),C (n × m) and D (n × n). If D is invertible, then M is invertible iff
A − BD−1C (the Schur Complement of D) is invertible.
Lemma 2.4 Given A (m×n) and B (n×m), (Idm−AB) is invertible iff (Idn−BA)
is invertible. Moreover (Idm − AB)−1A = A(Idn − BA)−1.
The category (Vecfd, ⊕) is not partially traced in the sense of [2].
Metric Spaces
Consider the category CMet of complete metric spaces with non-expansive maps. Define f : (M, dM ) → (N, dN ) to be non-expansive iff dN (f (x),f (y)) ≤ dM (x, y), for all x, y ∈ M . Note that the tempting collection of complete metric spaces and con- tractions (dN (f (x),f (y)) < dM (x, y), for all x, y ∈ M ) is not a category: there are no identity morphisms! CMet has products, namely given (M, dM ) and (N, dN ) we define (M × N, dM×N ) with dM×N ((m, n), (m', n')) = max{dM (m, m'), dN (n, n')}.
We define the trace class structure on CMet (where ⊗ = × ) as follows. We
say that a morphism f : X × U → Y × U is in TU	iff for every x ∈ X the induced
map π2λu.f (x, u) : U → U has a unique fixed point; in other words, iff for every
x ∈ X, there is a unique u, and a y, such that f (x, u) = (y, u). Note that in this case y is necessarily unique. Also, note that contractions have unique fixed points, by the Banach fixed point theorem.

Suppose f ∈ TU
. We define TrU
: X → Y by TrU
(f )(x) = y, where

f (x, u) = (y, u) for the unique u. Equivalently, TrU	(f )(x) = π1f (x, u) where u is
the unique fixed point of π2λt.f (x, t).
Proposition 2.5 (CMet, ×, {∗}) is a partially traced category with trace class as above.
Total Traces
Of course, all (totally-defined) traces in the usual definition of a traced monoidal category yield a trace class, namely the entire homset is the domain of Tr.

Remark 2.6 (A Non-Example) Consider the structure (CMet, ×). Defining the trace class morphisms as those f such that π2λu.f (x, u) : U → U is a contrac- tion, for every x ∈ X, does not yield a partially traced category: all axioms are true except for dinaturality and Vanishing II.

Orthogonality Relations
Girard introduced orthogonality relations into linear logic for several reasons; one was to model formulas (or types) as sets equal to their biorthogonal (see [9], [11]). Recently M. Hyland and A. Schalk gave an abstract approach to orthogonality relations in symmetric monoidal closed categories [24]. They also point out that an orthogonality on a traced symmetric monoidal category C can be obtained by first considering their axioms applied to Int(C), the compact closure of C, and then translating them down to C. We follow our treatment in [22].
An axiom involving a partial trace should be read with the proviso: “whenever all traces exist”. Finally hereafter, without loss of generality and for readability we consider strict monoidal categories. It is well known that every monoidal category is equivalent to a strict one.
Definition 3.1 Let C be a traced symmetric monoidal category. An orthogonality relation on C is a family of relations ⊥UV between maps u : V → U and x : U → V
V −u→ U ⊥UV U −x→ V

subject to the following axioms:
Isomorphism : Let f : U ⊗ V ' → V ⊗ U' and fˆ : U' ⊗ V → V ' ⊗ U be such that

V '	U'
−1	ˆ
V	U	−1 ˆ

Tr	(Tr 
((1⊗1⊗sU',V ' )α
(f⊗f )α)) = sU,V and Tr 
(Tr 
((1⊗1⊗sU,V )α
(f⊗

f )α)) = sU',V ' . Here α = (1 ⊗ 1 ⊗ s)(1 ⊗ s ⊗ 1) with s at appropriate types. Note that this simply means that f : (U, V ) → (U',V ') and fˆ : (U',V ') → (U, V ) are inverses of each other in G(C).
Then for all u : V → U and x : U → V,


u ⊥UV x iff TrU'

' (sU,U' (u ⊗ 1U' )fsV ',U ) ⊥U'V ' TrV '
' ((1V ' ⊗ x)fˆ);


that is, orthogonality is invariant under isomorphism.
Precise Tensor : For all u : V → U , v : V ' → U' and h : U ⊗ U' → V ⊗ V ',

(u ⊗ v) ⊥U⊗U',V ⊗V ' h

iff
U'	U
u ⊥UV TrU,V ((1V ⊗ v)h) and v ⊥U'V ' TrU',V ' (sU,V ' (u ⊗ 1V ' )hsU',U ).
Identity : For all u : V → U and x : U → V ,

u ⊥UV x implies 1I ⊥II TrV (xu).

Symmetry : For all u : V → U and x : U → V ,

u ⊥UV x iff  x ⊥VU u.

In the context of GoI, we will be working with orthogonality relations on endo- morphism sets of objects in the underlying categories. Biorthogonally closed subsets (i.e. X = X⊥⊥) of certain endomorphism sets are important as they define types (the GoI interpretation of formulae.) We have observed that all the orthogonality relations that we work with in this paper can be characterized using trace classes. This suggests the following, which seems to cover many known examples.
Example 3.2 [Orthogonality as trace class] Let (C, ⊗,I,Tr) be a partially traced category where ⊗ is the monoidal product with unit I, and Tr is the partial trace operator as in Section 2. Let A and B be objects of C. For f : A → B and g : B → A, we can define an orthogonality relation by declaring f ⊥BA g iff gf ∈ TA . Axioms can be checked easily, which we omit. It turns out that this is a variation of the notion of Focussed orthogonality of Hyland and Schalk [24].
Hence, from our previous discussion on traces, we obtain the following examples:
Vecfd . For A ∈ Vecfd , f, g ∈ End(A), define f ⊥ g iff Id − gf is invertible. Here Id is the identity matrix of size dim(A).
CMet. Let M ∈ CMet. For f, g ∈ End(M ), define f ⊥ g iff gf has a unique fixed point.

The MGoI Interpretation of MLL
We quickly review the Multiobject Geometry of Interaction (MGoI) semantics for multiplicative linear logic without units (MLL) in a partially traced symmetric monoidal category (C, ⊗,I,Tr, ⊥) equipped with an orthogonality relation ⊥ as in the previous section. Here ⊗ is the monoidal product with unit I and Tr is a partial trace operator as in Section 2. We do not require that the category C have a reflexive object U , so uni-object GoI semantics ([13,20]) may not be possible to carry out in C.
The MGoI semantics, denoted θ, interprets formulas and proofs inductively in a structure (C, ⊗,I,Tr, ⊥). The ideas below were inspired by Girard’s original uni- object GoI semantics referred to above.
Interpreting formulas:
Let A be an object of C and let f, g ∈ End(A). We say that f is orthogonal to
g, denoted f ⊥ g, if (f, g) ∈⊥. Also given X ⊆ End(A) we define

X⊥ = {f ∈ End(A) | ∀g ∈ X, f ⊥ g}.

We now define an operator on the objects of C as follows: given an object A,
T (A) = {X ⊆ End(A) | X⊥⊥ = X}. Elements of T (A) are often called types.

We first define a “compact” interpretation map  −  on the formulas of MLL as follows. Given the value of  −  on the atomic propositions as objects of C, we extend it to all formulas by:
 A⊥  =  A 
.....
A .. B  =  A ⊗ B  =  A  ⊗ B .
We then define the MGoI-interpretation θ for formulas as follows.
θ(α) ∈T (  α  ), where α is an atomic formula.
θ(α⊥) = θ(α)⊥, where α is an atomic formula.
θ(A ⊗ B) = {a ⊗ b | a ∈ θ(A),b ∈ θ(B)}⊥⊥

θ(A
....
...
= {a ⊗ b | a ∈ θ(A)⊥
,b ∈ θ(B)⊥}⊥

Easy consequences of the definition are: (i) for any formula A, (θA)⊥ = θ(A⊥), (ii)
θ(A) ⊆ End(  A  ), and (iii) θ(A)⊥⊥ = θ(A). Hence, θ interprets formulas as types.
Interpreting proofs:
We define the MGoI interpretation for proofs of MLL without units, as in [22] (cf. also [20]). Every MLL sequent will be of the form ▶ [Δ], Γ whereΓ isa sequence of formulas and Δ is a sequence of cut formulas that have already been made in the proof of ▶ Γ (see [13,20]). This device is used to keep track of the cuts in a proof of
▶ Γ. A proof Π of ▶ [Δ], Γ is represented by a morphism θ(Π) ∈ End(⊗  Γ  ⊗  Δ  ). With Γ = A1, ··· , An, ⊗  Γ  stands for  A1  ⊗ · · ·⊗  An  , similarly for Δ. We drop the double brackets wherever there is no danger of confusion. We also define σ = s ⊗···⊗ s (m-copies) where s is the symmetry map at different types (omitted
for convenience), and |Δ| = 2m. The morphism σ represents the cuts in the proof of ▶ Γ, i.e. it models Δ. In the case where Δ is empty (that is for a cut-free proof), we define σ : I → I to be 1I where I is the unit of the monoidal product in C.
Let Π be a proof of ▶ [Δ], Γ. We define the MGoI interpretation of Π, denoted by θ(Π), by induction on the length of the proof as follows.
Π is an axiom ▶ A, A⊥, θ(Π) := sV,V where  A  =  A⊥  = V .
Π is obtained using the cut rule on Π' and Π'' that is,



Π. '
.
▶ [Δ'], Γ',A 
Π. ''
.
▶ [Δ''], A⊥, Γ''

▶ [Δ', Δ'', A, A⊥], Γ', Γ''	cut


Define θ(Π) = τ−1(θ(Π') ⊗ θ(Π''))τ , where τ is the permutation Γ' ⊗ Γ'' ⊗ Δ' ⊗ Δ'' ⊗ A ⊗ A⊥ −τ→ Γ' ⊗ A ⊗ Δ' ⊗ A⊥ ⊗ Γ'' ⊗ Δ''.

Π is obtained using the exchange rule on the formulas Ai and Ai+1 in Γ'. That

is Π is of the form

Π. '
.
▶ [Δ], Γ'


▶ [Δ], Γ



exchange

where Γ' = Γ' , Ai, Ai+1, Γ' and Γ = Γ' , Ai+1, Ai, Γ' . Then,
1	2	1	2
θ(Π) = τ−1θ(Π')τ , where τ = 1Γ' ⊗ s ⊗ 1Γ' ⊗Δ.
1	2
Π is obtained using an application of the par rule, that is Π is of the form:


Π'
.
▶ [Δ], Γ', A,B 







.......

▶ [Δ], Γ',A 
.....	..
..
. Then θ(Π) = θ(Π').

Π is obtained using an application of the times rule, that is Π is of the form:

Π. '
.
▶ [Δ'], Γ',A 

Π.''
.
▶ [Δ''], Γ'',B 

▶ [Δ', Δ''], Γ', Γ'',A ⊗ B	⊗
Then θ(Π) = τ−1(θ(Π') ⊗ θ(Π''))τ , where τ is the permutation Γ' ⊗ Γ'' ⊗ A ⊗ B ⊗ Δ' ⊗ Δ'' −τ→ Γ' ⊗ A ⊗ Δ' ⊗ Γ'' ⊗ B ⊗ Δ''.
When Δ' and Δ'' are empty sequences, this corresponds to the definition of tensor product in Abramsky’s G(C) (see [1,18].)



Example 4.1 (a) Let Π be the following proof:
▶ A, A⊥	▶ A, A⊥


▶ [A⊥, A], A, A⊥


cut

Then the MGoI semantics of this proof is given by
θ(Π) = τ−1(s ⊗ s)τ = sV ⊗V,V ⊗V
where τ = (1 ⊗ 1 ⊗ s)(1 ⊗ s ⊗ 1) and  A  =  A⊥  = V .
(b) Now consider the following proof
▶ B, B⊥	▶ C, C⊥
▶ B, C, B⊥ ⊗ C⊥

▶ B, B⊥ ⊗ C⊥,C 
▶ B⊥ ⊗ C⊥, B,C 

▶ B⊥
⊗ C⊥,B 
.....
...

Its denotation is sV ⊗W,V ⊗W , where  B  =  B⊥  = V and  C  =  C⊥  = W .
Interpreting cut-elimination (dynamics):
Dynamics is at the heart of the GoI interpretation as compared to denotational semantics and it is hidden in the cut-elimination process. The mathematical model of cut-elimination is given by the so called execution formula defined as follows:

(2)
EX(θ(Π), σ) = Tr⊗Δ
((1 ⊗ σ)θ(Π))

where Π is a proof of the sequent ▶ [Δ], Γ, σ = s ⊗···⊗ s (m times) models Δ, and 2m is the number of formulas in Δ. Note that EX(θ(Π), σ) is a morphism from
⊗Γ → ⊗Γ, when it exists. By Theorem 5.4 below, the execution formula always exists for any MLL proof Π.
Example 4.2 Consider the proof Π in Example 4.1(a) above. Recall also that σ = s in this case (m = 1). Then EX(θ(Π), σ) = Tr((1 ⊗ sV,V )sV ⊗V,V ⊗V ) = sV,V . Note that we obtain the MGoI interpretation of the cut-free proof of ▶ A, A⊥, obtained by applying Gentzen’s Hauptsatz to the proof Π (cf. Theorem 5.5 below).
4.1	MGoI versus Denotational Semantics
In the original paper on traced monoidal categories [25], those authors construct a notion of “free compact closure” of a traced monoidal category, Int(C), in which composition is given by the trace. An isomorphic notion (in the symmetric case) was introduced by Abramsky, in his construction G(C). For an exposition, see [3]. In this subsection we assume the reader is familiar with these constructions, which we call “Int” constructions.
There have been several works interpreting various logics in Int-like “GoI” cat- egories, beginning with the Abramsky-Jagadeesan paper [4] as well as unpublished lectures of Hyland, to more recent (and interesting) interpretations of classical logic by Fuhrman and Pym [8]. In all cases, cut is interpreted as composition in an Int category.
Let us see to what extent we can compare two obvious kinds of GoI interpreta- tions in a category G(C): denotational  −  vs our GoI interpretation θ. We shall roughly follow Abramsky and Jagadeesan [4].
Denotational interpretation of formulas in G(C):
Formulas will be interpreted as diagonal objects in G(C), that is as pairs of objects in C of the form (V, V ). We shall indicate the denotational semantics in G(C) as  −  D to distinguish it from  −  , which is used in the MGoI interpretation θ of formulas given above. We assign arbitrary objects to atomic formulas:  p  D = (V, V ), where V is an object in C.  Relative to such an assignment, we define

A⊥ D =  A
⊥ . Also, we define  A ⊗ B D =  A
....
...
B D =  A D ⊗ B D. Note

that	A⊥ D =  A  D for every formula A; indeed suppose  A  D = (V, V ), then
 A⊥ D = (V, V )⊥ = (V, V ).
Remark 4.3 Notice that if we choose  p  D = ( p  , p  ) for atomic formulas p, then  A  D = (  A  , A  ) for any formula A, (see Proposition 4.4 below.) This is as

far as the resemblance goes, however, since the MGoI interpretation of the formula
A is θ(A) (a type), not  A  .
Interpreting proofs: In the denotational semantics into the category G(C) we shall ignore the information collected in Δ. Let Π be a proof of ▶ [Δ], Γ, with Γ = A1, ··· , An. Then  Π  D : I → ⊗  Ai  D in G(C); in other words,  Π  D : V1 ⊗ V2 ⊗ · · · ⊗ Vn → V1 ⊗ V2 ⊗ · · · ⊗ Vn in C, where  Ai  D = (Vi, Vi). For a morphism h : A ⊗ B → C in G(C), let Λ(f ) : A → B⊥ ⊗ C denote its transpose.

Axiom ▶ A, A⊥. Then Π  D = Λ(1  A 
translated into C, we have  Π  D = sV,V .
). Let A 	= (V, V ). Then, when
D

Cut: Suppose Π is obtained by applying the cut rule on A, A⊥ to proofs Π' and Π''. Suppose also that  Π'  D = f : I → ⊗  Γ'  D ⊗ A  D and  Π''  D = g : I →  A⊥  D ⊗ Γ''  D. Then
 Π  D : I →  Γ'  D ⊗ Γ''  D = Λ(Λ−1(g)Λ−1(f )) .
Let Γ' = A' , ··· , A' and Γ'' = A'', ··· , A'' ,	A' D = (V ',V ') and	A'' D =
1	n	1	m	i	i	i	i
(V '',V ''), and  A  D = (V, V ). When translated into C we get:
i	i
Λ−1(f ) : V ' ⊗· · ·⊗ V ' ⊗ V → V ' ⊗· · ·⊗ V ' ⊗ V and
1	n	1	n
Λ−1(g) : V ⊗ V '' ⊗· · ·⊗ V '' → V ⊗ V '' ⊗· · ·⊗ V ''. So
1	m	1	m


 Π  D = TrV ⊗V
((1Γ' ⊗ 1Γ'' ⊗ sV,V )ρ−1
(Λ−1
⊗ Λ−1
)ρ)

where ρ is the permutation, ρ :  Γ'  D ⊗  Γ''  D ⊗V ⊗V →  Γ'  D ⊗V ⊗V ⊗  Γ''  D
Exchange:  Given  Π'  D  : I  → ⊗  Γ' D with Γ' = Γ' , Ai, Ai+1, Γ' , Γ'  =
1	2	1
A1, ··· , Ai−1, Γ'  = Ai+2, ··· , An, and	Ai  D = (Vi, Vi) for all i.  We define

 Π  D = (1Γ'
⊗ sV ,V
⊗ 1Γ' )  Π'  D. When we translate this into C we get:

1	i  i+1	2
given  Π' D : V1 ⊗· · ·⊗ Vi ⊗ Vi+1 ⊗· · ·⊗ Vn → V1 ⊗· · ·⊗ Vi ⊗ Vi+1 ⊗· · ·⊗ Vn,

 Π  D = ρ−1  Π'  Dρ where ρ = 1Γ' ⊗ sV
i+1
,Vi
⊗ 1 ' .
2

Tensor: Given  Π'  D = f : I → ⊗  Γ'  D ⊗  A  D and  Π''  D = g : I →
⊗  Γ''  D ⊗ B  D, then we define
 Π  D : I →⊗  Γ'  D ⊗ Γ''  D ⊗ A  D ⊗ B  D = ρ(f ⊗ g)
where ρ is the permutation ρ : ⊗  Γ'  D ⊗ Γ''  D ⊗ A  D ⊗ B  D →	Γ' D ⊗
 A  D ⊗ Γ''  D ⊗ B  D. Let Γ' = A' , ··· , A' and Γ'' = A'', ··· , A'' ,	A' D =
1	n	1	m	i
(V ',V ') and	A'' D = (V '',V ''),  A  D = (V, V ), and  B  D = (W, W ). When
i	i	j	j	j
translated into C we get f : V ' ⊗ · · · ⊗ V ' ⊗ V → V ' ⊗ · · · ⊗ V ' ⊗ V and g :
1	n	1	n
V '' ⊗· · ·⊗ V '' ⊗ W → V '' ⊗· · ·⊗ V '' ⊗ W . Then

1	m	1
m
 Π  D = ρ−1(f ⊗ g)ρ

where ρ is the permutation, ρ = 1Γ' ⊗ sΓ'',V ⊗ 1W
Par: Given  Π'  D : I →⊗  Γ'  D ⊗ A  D ⊗ B  D, define  Π  D =  Π'  D.

Proposition 4.4 Let Π be an MLL proof of ▶ [Δ], Γ and σ model the cuts Δ. Suppose p  D = (  p  , p  ) for all atomic formulas p. Then,
 A  D = (  A  , A  ), for any formula A.
EX(θ(Π), σ) =	Π  D. In particular, if Π is cut-free, (i.e., |Δ| = 0,σ = 1I) then θ(Π) =  Π D.
Example 4.5 Observe that even at the simple level of two axioms joined by a cut, the MGoI and denotational interpretations differ. For let Π be the proof ob- tained by applying the cut rule to two axioms ▶ A, A⊥, as in Example 4.1(a) above, and suppose A  D = (V, V ) with V =  A  an object of C. Then the denota- tional semantics of Π is  Π  D = sV,V . On the other hand, for the MGoI seman- tics of Π, θ(Π) = sV ⊗V,V ⊗V . Note however that we do have: EX(θ(Π), sV,V ) = EX(sV ⊗V,V ⊗V , sV,V ) = sV,V =  Π  D, as in Proposition 4.4(ii) above.
Remark 4.6 (Comparing Interpretations) As we have seen above, the two se- mantics are entirely different regarding the way they interpret the formulas, and the interpretations of proofs are related by the Execution formula as in Proposition 4.4 above. In particular, for cut-free proofs, the MGoI and Denotational interpretations into the Int category G(C) coincide.
There are, however, more general ∗-autonomous categories we might consider for such a comparison. For example, in our paper [21] we discussed a noncompact
*-autonomous category whose objects are Girard types and whose morphisms arise from the GoI interpretation of proofs. The same construction could be done here. This might be a more natural domain for a denotational modelling than the compact category G(C) which we worked with above. We shall examine this in the full version of this paper
In summary, denotational semantics does not normally keep track of cuts and has no separate formulation (interpretation) for the removal of cuts (e.g. the execution formula): the removal of cuts is hidden in the composition in the model category. In this paper we wanted to have cut-elimination steps incorporated directly into the interpretation, while still being able to compare this with the denotational view, as in Proposition 4.4 above.

Soundness of the MGoI Interpretation
In this section we recall, without proof, one of the main results of [22]: the sound- ness of the MGoI interpretation.  We show that if a proof Π is reduced (via cut-elimination) to another proof Π', then EX(θ(Π), σ) = EX(θ(Π'),τ ); that is, EX(θ(Π), σ) is an invariant of reduction. In particular, if Π' is cut-free (i.e. a nor- mal form) we have EX(θ(Π), σ) = θ(Π'). Intuitively this says that if one thinks of cut-elimination as computation then θ(Π) can be thought of as an algorithm. The computation takes place as follows: if EX(θ(Π), σ) exists then it yields a datum (cf. cut-free proof). This intuition will be made precise below (Theorems 5.4 & 5.5).
The next fundamental lemma (also in several of Girard’s papers) is a version of

the Church-Rosser theorem. It follows directly from the axioms of trace.
Lemma 5.1 (Associativity of cut) Let Π be a proof of ▶ [Γ, Δ], Λ and let σ and
τ be the morphisms representing the cut-formulas in Γ and Δ respectively. Then
EX(θ(Π),σ ⊗ τ ) = EX(EX(θ(Π),τ ), σ) = EX(EX((1 ⊗ s)θ(Π)(1 ⊗ s), σ),τ ),
whenever all traces exist.
The next definitions are analogous to concepts arising in realizability and Girard’s method of candidats (cf . [10]). We work in a partially traced symmetric monoidal category equipped with an orthogonality relation. We suppress mentioning the use of the Symmetry axiom of the orthogonality relation.
Definition 5.2 Let Γ = A1, ··· , An and Vi =  Ai  .
A datum of type θΓ is a morphism M : ⊗iVi → ⊗iVi such that for any ai ∈ θ(A⊥),
we have ⊗iai ⊥ M and both M .a1 and Mˆ.(a2 ⊗· · ·⊗ an) below exist,

M .a1 := TrV1 (s−1
(a1 ⊗ 1V
⊗· · ·⊗ 1V
)Ms⊗
V ,V )

⊗i/=1Vi,V1	2
n	i/=1 i 1

Mˆ.(a2 ⊗· · ·⊗ an) := TrV2⊗···⊗Vn ((1 ⊗ a2 ⊗· · ·⊗ an)M )
An algorithm of type θΓ is a morphism M : ⊗iVi ⊗  Δ  → ⊗iVi ⊗  Δ  for
some Δ = B1, B2, ··· , B2m with m a nonnegative integer and B2i = B⊥	for

i = 1 ··· , m, such that if σ : ⊗2m
Bj	→ ⊗2m
Bj	is ⊗m
s B2j—1 , B2j  ,

EX(M, σ) exists and is a datum of type θΓ.  (Here σ is defined to be 1I for
m = 0, that is when Δ is empty.)
Lemma 5.3 Let Γ = A2, ··· , An and Γ = A1, Γ. Let Vi =  Ai  , and M : ⊗iVi →
⊗iVi, for i = 1, ··· , n. Then, M is a datum of type θ(Γ) iff for all ai ∈ θ(A⊥), M .a1 and Mˆ.(a2 ⊗ · · ·⊗ an) (deﬁned as above) exist and are in θ(Γ) and θ(A1), respectively.
Theorem 5.4 (Proofs as algorithms) Let Π be an MLL proof of a sequent
▶ [Δ], Γ. Then, θ(Π) is an algorithm of type θ(Γ).
Theorem 5.5 (EX is an invariant) Let Π be an MLL proof of a sequent
▶ [Δ], Γ. Then,
If Π reduces to Π' by any sequence of cut-eliminations, then EX(θ(Π), σ) =
EX(θ(Π'),τ ). So EX(θ(Π), σ) is an invariant of reduction.
In particular, if Π' is any cut-free proof obtained from Π by cut-elimination, then
EX(θ(Π), σ) = θ(Π').
Proofs as Polynomials
Proofs as Permutations in MGoI
In this section we prove a characterization theorem for the MGoI interpretations of proofs as special permutations. This is similar to familiar representations of proofs in MLL via permutations, [12] although the details here will be used in the

next section to give a characterization of MLL proofs in untyped GoI via formal polynomials.
Proposition 6.1 Let Π be an MLL proof of ▶ [Δ], Γ where |Δ| = 2m and |Γ| = n (counting occurrences of propositional variables). Then θ(Π) is a ﬁxed-point free involutive permutation on n + 2m objects of C. That is θ(Π) : V1 ⊗· · ·⊗ Vn+2m → V1 ⊗· · ·⊗ Vn+2m induces a permutation π on {1, 2 ··· ,n + 2m} and
π2 = 1 
For all i ∈ {1, 2, ··· ,n + 2m}, π(i) /= i.
For all i ∈ {1, 2, ··· ,n + 2m}, Vi = Vπ(i).
Proof.  By induction on the length of the proof Π.


So the above Proposition 6.1 shows that the denotation of a proof θ(Π) induces a fixed-point free involutive permutation. We now seek a converse.
Theorem 6.2 (Characterization) Let M be a ﬁxed-point free involutive permu- tation from V1⊗· · ·⊗Vn → V1⊗· · ·⊗Vn (induced by a permutation μ on {1, 2, ··· , n}) where n > 0 is an even integer, Vi =  Ai  , and Vi = Vμ(i) for all i = 1, ··· , n. Then there is a provable MLL formula φ built from the Ai, with a cut-free proof Π such that θ(Π) = M.
Proof.  We define a formula φ out of the Ai and A⊥ = Aμ(i) and show that it is provable by constructing a proof net for it. The proof Π in sequent calculus is then completely determined by φ. Here is the algorithm for the construction of the formula φ.
Initialize φ := A1
For i := 2 to n do

If μ(i) < i then φ := (φ
else, φ := (φ ⊗ Ai)
.....
...
Ai),

In order to construct the proof structure for φ, we first arrange the Ai in increas- ing order of their indices. Note that the proof structure for φ is uniquely determined: given the permutation μ, the axiom links are uniquely specified by connecting Ai to A⊥ = Aμ(i). In the full paper we show that it is a proof net.
The proof Π is cut-free by construction. It remains to show that θ(Π) = M . Note that θ(Π) is an endomorphism on V1 ⊗· · ·⊗ Vn as the variables in φ occur in increasing order from A1 to An. The permutation induced by θ(Π) on {1, ··· , n} is uniquely determined by the location of formulas (as they occur in φ) connected by axiom link specifications, which are given by μ. Thus we have that θ(Π) = M . 

Let’s consider an example:
Example 6.3 Suppose μ is given by (1, 4)(2, 3) on the set {1, 2, 3, 4}. Then, fol-

lowing the algorithm above we get

⊥	⊥	....	⊥	⊥

φ(A1, A2, A3, A4) = φ(A1, A2, A2 , A1 ) = ((A1 ⊗ A2)
. A2 )  .

and one possible Π is (ignoring exchange):
▶ A1, A⊥	▶ A2, A⊥
	1	2 
  ▶ A1 ⊗ A2, A⊥, A⊥
....	⊥	⊥
▶ (A1 ⊗ A2)  . A2 , A1

▶ ((A1 ⊗ A2)
....
...
A⊥)
.....	⊥
...	1

As an application of this result, in the next section we prove a characterization theorem for MLL in any traced Unique Decomposition Category with a reflexive object U , under (uni-object) GoI semantics [20].

A Characterization Theorem For Uni-GoI Semantics
Theorem 6.2 in Section 6.1 above may be applied to give a characterization theorem for the untyped (i.e. uni-object) GoI semantics for MLL, as discussed in our papers [20,21]. The theorem below is related to work of Danos and Regnier on path-based computing [7]. We hope in future work to detail these connections. We shall recall only the definitions that we use in the theorem below and refer the reader to [20] for details about GoI semantics in UDCs.
Let C be a traced UDC and U be a reflexive object in C with retraction pair (j, k), that is U ⊗U  U (j, k). We shall use j1, j2, k1, k2 to denote the components of j and k respectively, (In Girard’s terminology [13] j1 = p, j2 = q, k1 = p∗, k2 = q∗.)
Definition 6.4 Formal polynomials are defined as the set E of expressions built on the set A = {0, 1, j1, j2, k1, k2} using binary operations + and · (which we shall omit writing) subject to the axioms:
(E, +, ·, 0, 1) is a commutative semiring, and
k1j1 = 1, k2j2 = 1, k2j1 = 0, and k1j2 = 0.
Note that these are formal expressions and when interpreted in C(U, U ), for some C and U , 0 and 1 are interpreted as 0UU (the zero morphism in C(U, U )) and 1U (the identity morphism on U ), respectively. Also j1, j2, k1, and k2 are interpreted by their namesakes (as morphisms in C(U, U )). It should be noted that given a polynomial ψ ∈ E, its interpretation in C(U, U ) may not exist, that is the summands in the polynomial ψ may not form a summable family in the Σ-monoid C(U, U ) (see [20] for the definition of a Σ-monoid.)
We next define an operation, ( )∗ on E , as follows: 0∗ = 0, 1∗ = 1, j∗ = k1, j∗ =
1	2
k2, k∗ = j1 and k∗ = j2 and we extend ( )∗ to words by induction: (wα)∗ = α∗w∗,
1	2
(w + v)∗ = w∗ + v∗ for w, v ∈E and α ∈ A. In a word w = uv we say that v occurs
before u, or equivalently that u occurs after v. Note that words w on A cannot have k’s occurring after j’s because of equations k1j1 = k2j2 = 1 and k2j1 = k1j2 = 0. Thus words w on A are of the form w = uv where v is a word on A consisting of

k1, k2 only and u a word on A consisting of j1, j2 only (either u or v can be 1). We call v the k-part and u, the j-part of w. For example, the k part of j1j2k2k2 is k2k2
1	1
and its j-part is j1j2.
Given a polynomial ψ ∈ E we define a k-tree which gives a tree representation of the k-parts of summands in ψ, as follows: given a summand w in ψ, we associate a path (from the root to a leaf) in the k-tree to w, such that the path corresponds to the k-part of w, when read from right to left. Similarly we define a j-tree, except that each path in the j-tree corresponds to the respective j-part, when read from left to right. Trees are grown upwards, at every branching point in a j-tree, the left branch is labelled j1 and the right branch j2, similarly in a k-tree, the left branch is labelled k1 and the right branch k2. For this representation to be well-defined one requires that the k-parts be mutually incomparable with respect to the prefix ordering relation, a similar requirement is demanded for the j-parts.
Here is an example : consider the polynomial ψ = j3k2 + j2k3 + j1j2k2k2 +

j2j2k2k1, the j and k trees are shown below.
1	1	1


	
j and k-trees
Note that a k-tree will have the same number, n, of leaves as the number of summands in ψ with nonempty k-parts. A similar argument holds for a j-tree.
Note that by construction every path from the root of the k-tree to the root of the j-tree is a term built out of j1, j2, k1, k2. Not all such terms will be summands in a given ψ, however every summand in ψ can be obtained in this way.
Theorem 6.5 Let C be a traced UDC, U a reflexive object in C and U ⊗U U (j, k). Consider a polynomial ψ ∈ E. Then, ψ is the denotation of an MLL proof iff
ψ has an even number n > 0 of summands,
For each summand w, w2 = 0 and w∗ is a summand in ψ,
The k-tree of ψ is a binary tree with n leaves.
The proof of Theorem 6.5 below uses the Characterization Theorem 6.2 and the following lemma:
Lemma 6.6 Let ▶ Γ be a provable MLL sequent of length (counting the variable occurrences) n and Π be a proof of ▶ Γ. Then Π  G = Jθ(Π)K, where Π  G is the GoI interpretation of Π and θ(Π) is the MGoI interpretations of Π restricted to the single reflexive object U. Here J : Un → U is a morphism built from j and 1U by tensoring and composition whose tree representation is a binary tree with n leaves, and K = J∗. Here ( )∗ is as deﬁned above and U ⊗ U  U (j, k).

Proof.	By induction on proofs. We refer the reader to [20] for the untyped GoI

interpretation of proofs. The difference is that in that work, as in [13], we used matrices to interpret proofs. Here, instead we view those matrices as morphisms from U → U , using appropriate morphisms built from j and k that we denote by
Jˆ and Kˆ respectively, below.We give two cases; the remaining cases will appear in
the full journal version.
Suppose Π is an axiom (we restrict to propositional variables), then  Π  G =
JˆsU,U Kˆ = jsU,U k = jθ(Π)k.
Suppose Π is obtained by an application of the cut rule to subproofs Π' and Π''.

 Π  G = Jˆ(τ −1(  Π'  G ⊗ Π''  G)τ )Kˆ
by definition of GoI semantics

= Jˆ(τ −1(J'θ(Π')K' ⊗ J ''θ(Π'')K'')τ )Kˆ
by ind.	hypothesis

= Jˆ(τ −1(J' ⊗ J '')(θ(Π') ⊗ θ(Π''))(K' ⊗ K'')τ )Kˆ
= Jˆ(J˜(τ −1(θ(Π') ⊗ θ(Π''))τ )K˜ )Kˆ
= Jˆ(J˜(θ(Π))K˜ )Kˆ
= Jθ(Π)K


where J˜ and K˜
are appropriate morphisms Un → U built from j’s (resp. k’s)

and 1U by tensoring and composition.


Proof. (of Theorem 6.5) We shall give a sketch of the full proof that will appear in the journal version. Recall that as we are working in a traced UDC, the MGoI interpretations of proofs restricted to a single object U can be represented by ma- trices of their components. As such they are symmetric permutation matrices with zero diagonal entries, by Proposition 6.1.
Let Π be an MLL proof and M denote θ(Π) where θ(Π) is as defined in Lemma
6.6. Suppose ψ is the denotation of Π, note that ψ = JMK. Recall that M is n × n permutation matrix with n even, and all n entries of J (as a 1 × n matrix) are nonzero; thus there will be n summands in ψ. The k-tree of ψ is just the tree representation of the morphism K which by Lemma 6.6 is a binary tree with n leaves. Hereafter we shall use J and K to refer to their tree representations.
Every summand in ψ can be obtained by following a path u in K from root to a leaf and continuing on with a path, (specified by M ) in J from a leaf to the root of J .
Let w be a summand in ψ, then so will be w∗, because K = J∗ and M is symmetric. Finally, it can be shown that any path w in ψ, has the property that w2 = 0.
Conversely, suppose ψ ∈E satisfies the properties stated in the theorem. We can show that ψ = JMK, with M a symmetric permutation matrix with zero diagonal entries and K = J∗. Then by Theorem 6.2 and Lemma 6.6, we conclude that it is the denotation of a proof in MLL.
 

We shall illustrate the proof of Theorem 6.5 by some examples. In all our examples we choose to arrange the axioms in increasing index order of the Ai.)

Example 6.7 Let ψ = j3k2 + j2k3 + j1j2k2k2 + j2j2k2k1, then
1	1	1	1

⎡ 0 0 0 1 ⎤
M =	0 0 1 0	.
0 1 0 0 
1 0 0 0 

Moreover, following the construction in the proof above, J : U 4 → U = [j3, j2j2, j1j2, j2] = j(j ⊗ 1)(j ⊗ 1 ⊗ 1) and K = J∗ = (k ⊗ 1 ⊗ 1)(k ⊗ 1)k.
1	1
The permutation above is μ = (1, 4)(2, 3) on {1, 2, 3, 4} and using Theorem 6.2,
and the discussion in Example 6.3, we see that ψ is the denotation of the proof (ignoring exchange)
▶ A1, A⊥	▶ A2, A⊥
	1	2 
  ▶ A1 ⊗ A2, A⊥, A⊥
....	⊥	⊥
▶ (A1 ⊗ A2)  . A2 , A1

▶ ((A1 ⊗ A2)
....
...
A⊥)
.....	⊥
...	1


Example 6.8  Let ψ = j2j1k4+j2k2k3+j1j2k2k2+j2j2k2k1+j4k1k2+j3j2k2.  Then
1	2	1	1	1	1	1	2
we have μ = (1, 5)(2, 6)(3, 4), J = j(j⊗1)(j⊗1⊗1)(j⊗1⊗1⊗j) and K = J∗. Then by
Theorem 6.2, we get that ψ(A1, A2, A3, A4, A5, A6) = ψ(A1, A2, A3, A⊥, A⊥, A⊥) = 

.....
⊥  .....
⊥  ....	⊥
3	1	2

((((A1 ⊗ A2) ⊗ A3)
. A3 )
. A1 )
. A2 and Π (ignoring exchange rule) is:

▶ A1, A⊥	▶ A2, A⊥
	1	2 
▶ A1 ⊗ A2, A⊥, A⊥	▶ A3, A⊥
	1	2	3
▶ (A1 ⊗ A2) ⊗ A3, A⊥, A⊥, A⊥

1
....
2	3
⊥	⊥	⊥

▶ ((A1 ⊗ A2) ⊗ A3) . A3 , A1 , A2

....
⊥  .....	⊥	⊥

▶ (((A1 ⊗ A2) ⊗ A3)
. A3 )
. A1 , A2

▶ ((((A1 ⊗ A2) ⊗ A3)
.....
...
A⊥)
.....
...
A⊥)
....	⊥
...	2


Example 6.9 Let ψ = j2j1k3 + j1j2j1k2 + j2j2k2k1 + j1j2k2k2 + j2k1k2k1 + j3k1k2.
1	2	1	2	2	1	2	1
Incidentally this is the definition of combinator B in the linear combinatory algebra
C(U, U ) where C is a traced UDC. See [3] for the development of such algebras.
In this case, we have μ = (1, 5)(2, 4)(3, 6), J = j(j ⊗ 1)(j ⊗ j ⊗ j) and
K  =  J∗.	Then by Theorem 6.2, we get that ψ(A1, A2, A3, A4, A5, A6)  =

⊥	⊥	⊥
.....	⊥	.....
⊥	....	⊥

ψ(A1, A2, A3, A2 , A1 , A3 ) = ((((A1 ⊗ A2) ⊗ A3)
(ignoring exchange rule) is:
.  A2 )
.  A1 )	.  A3  and Π

▶ A1, A⊥	▶ A2, A⊥
	1	2 
▶ A1 ⊗ A2, A⊥, A⊥	▶ A3, A⊥
	1	2	3
▶ (A1 ⊗ A2) ⊗ A3, A⊥, A⊥, A⊥

1
....
2	3
⊥	⊥	⊥

▶ ((A1 ⊗ A2) ⊗ A3) . A2 , A1 , A3

....
⊥  .....	⊥	⊥

▶ (((A1 ⊗ A2) ⊗ A3)
. A2 )
. A1 , A3

▶ ((((A1 ⊗ A2) ⊗ A3)
.....
...
A⊥)
.....
...
A⊥)
....	⊥
...	3

Conclusion and Future Work
In this work we recalled a new semantical interpretation called Multiobject Geome- try of Interaction (MGoI), from [22]. This semantics, while inspired by GoI, differs from it in significant points: (i) it is defined on endomorphism monoids of objects (and there is no reflexive object U ); (ii) the execution formula is based on a new theory of partial traces and trace classes. Moreover, there is an orthogonality rela- tion linked to the notion of trace class, which allows us to develop Girard’s theory of types, data and algorithms in our setting. This permits a structured approach to Girard’s concept of solving feedback equations [15], and an axiomatization of the critical features needed for showing that the execution formula is an invariant of cut-elimination. Computationally, GoI provides a kind of algorithm for normal- ization based on the execution formula. In future work, we hope to explore the algorithmic and convergence properties of the execution formula in various models, independently of the syntax.
An obvious direction for future research is to extend our MGoI interpretation to the exponentials and additives of linear logic. First steps in this program, at the level of exponentials, are in [23]. As mentioned above, we are also examining the intrinsic ∗-autonomous category of types and terms from our [21] in this new multiobject setting as perhaps a better “target” for a denotational semantics.
It is natural to seek examples of traces that are induced by more general notions of orthogonalities, especially those arising in functional analysis. We hope this may lead to new classes of MGoI models, perhaps connected to von Neumann algebras and general solutions to feedback equations, as in [15,16].

References
Abramsky, S. (1996), Retracing Some Paths in Process Algebra. In CONCUR 96, Springer LNCS
1119, 1-17.
Abramsky, S., Blute, R. and Panangaden, P. (1999), Nuclear and trace ideals in tensored *-categories,
J. Pure and Applied Algebra vol. 143, 3–47.
Abramsky, S., Haghverdi, E. and Scott, P.J. (2002), Geometry of Interaction and Linear Combinatory Algebras. MSCS, vol. 12(5), 2002, 625-665, CUP.
Abramsky, S. and Jagadeesan, R. (1994), New Foundations for the Geometry of Interaction. Information and Computation 111 (1), 53-119.
Blute, R., Cockett, R., and Seely RAG. (2000), Feedback for linearly distributive categories: traces and fixpoints Bill(Lawvere)Fest, Journal of Pure and Applied Algebra, vol. 154, 27-69.


Danos, V. (1990), La logique lin´eaire appliqu´ee a` l’´etude de divers processus de normalisation et principalement du λ-calcul. PhD thesis, Universit´e Paris VII.
Danos, V. and Regnier, L. (1995), Proof-nets and the Hilbert Space. In: Advances in Linear Logic, London Math. Soc. Notes, 222, CUP, 307–328.
Fuhrman C. and Pym, D. (2004), On the Geometry of Interaction for Classical Logic (Extended Abstract). Proc. LICS 04, IEEE Computer Society Press, 211-220.
Girard, J.-Y. (1987), Linear Logic. Theoretical Computer Science 50 (1), pp. 1-102.
Girard, J.-Y., Lafont, Y., Taylor, P. (1989), Proofs and Types, Cambridge Tracts in Theoretical Computer Science 7.
Girard, J.-Y. (1988), Geometry of Interaction II: Deadlock-free Algorithms. In Proc. of COLOG’88 , LNCS 417, Springer, 76–93.
Girard, J.-Y. (1988), Multiplicatives, in Lolli, ed. Logic and computer science, new trends and applications, in Rend. del seminario matematica dell’universita de Torino, special issue, 11–34.
Girard, J.-Y. (1989a) Geometry of Interaction I: Interpretation of System F. In Proc. Logic Colloquium 88, North Holland, 221–260.
Girard, J.-Y. (1995), Geometry of Interaction III: Accommodating the Additives. In: Advances in Linear Logic, LNS 222,CUP, 329–389,
Girard, J.-Y. (2007). Le Point Aveugle I, II, Hermann E´diteurs, Paris , 567 + pp.
Girard, J.-Y. (2008). Geometry of Interaction V: logic in the hyperfinite factor. Manuscript.
Gonthier, G., Abadi, M. and L´evy, J.-J. (1992), The geometry of optimal lambda reduction. In Proceedings of Logic in Computer Science, vol. 9, 15-26.
Haghverdi, E. (2000), A Categorical Approach to Linear Logic, Geometry of Proofs and Full Completeness, PhD Thesis, University of Ottawa, Canada.
Haghverdi, E. (2000), Unique Decomposition Categories, Geometry of Interaction and combinatory logic, Math. Struct. in Comp. Science, vol. 10, 205-231.
Haghverdi, E. and Scott, P.J. (2006), A categorical model for the Geometry of Interaction, Theoretical Computer Science Volume 350, Issues 2-3, 252-274. (Preliminary Version in: in Automata , Languages, Programming (ICALP 2004), Springer LNCS 3142, 708-720).
Haghverdi, E. and Scott, P.J. (2004), From Geometry of Interaction to Denotational Semantics. Proceedings of CTCS2004. In ENTCS, vol. 122, 67-87. Elsevier.
Haghverdi, E. and Scott, P.J. (2005), Towards a Typed Geometry of Interaction, CSL2005 (Computer Science Logic), Luke Ong, Ed. SLNCS 3634, 216-231.
Haghverdi, E. (2006), Typed GoI for Exponentials. in: M. Bugliesi et al. (Eds.): Proc. of ICALP 2006, Part II, LNCS 4052, 384-395. Springer Verlag.
Hyland, M and Schalk, A. (2003), Glueing and Orthogonality for Models of Linear Logic. Theoretical Computer Science vol. 294, 183–231.
Joyal, A., Street, R. and Verity, D. (1996), Traced Monoidal Categories. Math. Proc. Camb. Phil. Soc.
119, 447-468.
Mac Lane, S. (1998), Categories for the Working Mathematician, 2nd Ed. Springer.
Malacaria, P. and Regnier. L. (1991), Some Results on the Interpretation of λ-calculus in Operator Algebras. Proc. LICS 63-72, IEEE Press.
Plotkin, G. (2003), Trace Ideals, MFPS 2003 invited lecture, Montreal.
Regnier, L. (1992), Lambda-calcul et R´eseaux, PhD Thesis, Universit´e Paris VII.
