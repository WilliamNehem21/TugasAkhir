Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 323–336
www.elsevier.com/locate/entcs

A Characterisation of Expressivity for Coalgebraic Bisimulation and Simulation
Toby Wilkinson1,2
University of Southampton, UK

Abstract
In a previous paper we introduced internal models for coalgebraic modal logics and showed how they characterise expressivity for bismulation. Here we extend this work by enriching over preordered sets, and in so doing derive a characterisation that subsumes expressivity for both bisimulation and simulation.
Keywords: Enriched logical connection; Preordered set; Coalgebra; Bisimulation; Simulation.


Introduction
In [15] an abstract, category theoretic, characterisation of expressivity for coalge- braic bisimulation was given. This characterisation is in terms of internal models for a modal logic, and these were also introduced in [15]. In this paper we extend that work to include both bisimulation and simulation.
Our new characterisation is achieved by enriching over the preordered sets of [13], and thus the carrier of each coalgebra carries a preorder relation. It is this relation that gives our notion of simulation. This idea was first proposed in [6,7], where the authors enriched over Pos (partial orders), but we generalise this to incorporate bisimulation by noting (as in [13]) that sets can be viewed as preordered sets with the discrete preorder - i.e. Set ∼= DiscSetoid (discrete setoids).
In fact we go further than this, and observe that by enriching over Preord (preorders), Pos, Setoid (setoids), and DiscSetoid, that we can characterise sim- ulation, simulation where mutual simulation is bisimulation, mutual simulation, and bisimulation respectively.

1 Research supported by an EPSRC Doctoral Training Account.
2 Email: stw08r@ecs.soton.ac.uk

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.021

The notion of expressivity for a coalgebraic modal logic with respect to bisim- ulation states that, two states are logically equivalent if and only if they are be- haviourally equivalent. Here logically equivalent means “have the same theory”, and behaviourally equivalent means “can be identified in a model”, where the identifi- cation is by means of coalgebra homomorphisms. Thus there is an implicit reliance on the equality relation associated with the set of all theories, and the equality relation associated with the carrier of each coalgebra. It is this that we generalise, and instead use the preorder relations that these objects now carry.
For brevity we summarise the important ideas from [15] that we need, and it should be consulted for further details.
A general outline of this paper is as follows. In Section 2 we give an overview of the framework in which we work. Then in Section 3 we define the preordered sets. In Section 4 we recall from [15] the definitions and results we need, and in Section 5 define our generalised notion of expressivity. Section 6 contains our main characterisation result, and finally in Section 7 we work through the well known expressivity result for simulation of finite branching labelled transition systems as an example.
Dual-Adjunction Framework
Increasingly, the standard approach to coalgebraic modal logic is to formulate it in a dual-adjunction framework [10,8,5]. In [12] this is extended to an enriched setting, where the enrichment is over a symmetric monoidal closed category that is complete and cocomplete. It this enriched version that we use, and in the remainder of this paper all categories, functors, etc. should be assumed to be enriched.

S
L	A ,¸
P
The framework consists of two categories A and X, and two contravariant functors
P and S that form a dual adjunction i.e. there exists a natural isomorphism
Φ: A(−1,P (−2)) ⇒ X(−2, S(−1))
Such a dual-adjunction is often referred to as a logical connection [14], and we denote the unit and counit by
ρ : idA ⇒ PS σ : idX ⇒ SP
The category X represents a collection of state spaces, and a collection of gen- eralised transition systems is defined on these state spaces as coalgebras for an endofunctor T . Similarly, the category A represents a collection of base logics to which modal operators are to be added. These are introduced via an endofunc- tor L, and the corresponding modal logics are the L-algebras. The semantics of

these modal logics is given in two stages. First the dual adjunction gives a seman- tics for the base logics in terms of the state spaces, and then secondly, a natural transformation
δ : LP ⇒ PT 
gives the semantics of the modal operators in terms of the transition structures introduced by T [9,11].
The literature contains many examples for the unenriched case, for example see [5], and in Example 3.4 we will develop an enriched example.
Enrichment over Preordered Sets
Recall the category Preord of preordered sets and monotone functions, the objects of which are pairs consisting of a set, and a preorder relation on that set. Similarly, the categories Pos (partially ordered sets), Setoid (setoids), and DiscSetoid (dis- crete setoids) have for objects pairs consisting of a set and respectively, a partial order, equivalence relation, or the equality relation, on that set. In [13] these ex- amples are collectively known as the preordered sets, and they have significance for the coalgebraic analysis of simulation, which we shall come back to later.
We can consider these examples together by means of the following definition, where by a relation of “type R” we mean either a preorder, partial order, equivalence relation, or equality. The type is fixed, and every object in the category SetR must have a relation of that type.
Definition 3.1 The category SetR has for objects pairs (X, RX ) consisting of a set X, and RX a binary relation of type R on X. The morphisms are the R-preserving functions i.e. f : (X, RX ) → (Y, RY ) is a morphism if and only if for all x, x× ∈ X
xRXx× ⇒ f (x)RY f (x×) To be explicit we have the following four cases:
If R is the type preorder, then SetR is Preord.
If R is the type partial order, then SetR is Pos.
If R is the type equivalence relation, then SetR is Setoid.
If R is the type equality, then SetR is DiscSetoid (which is obviously isomor- phic to Set).
It is easy to verify that the forgetful from SetR to Set creates limits and col- imits - the product of (X, RX ) and (Y, RY ) is given by (X × Y, RX×Y ), where (x, y)RX×Y (x×, y×) ⇔ xRXx× and yRY y×, and the final object is (1, R1), where 1 is the singleton set, and R1 = 1 × 1.
It is also easy to verify that binary product and the final object form the tensor and unit of a symmetric monoidal category. To make SetR also closed we need internal hom objects [(X, RX ), (Y, RY )] such that [(Y, RY ), −] is right adjoint to −× (Y, RY ). The obvious definition for [(X, RX ), (Y, RY )] is the set of all R-preserving

functions from X to Y carrying the relation
f R[(X,RX ),(Y,RY )]g ⇔ ∀x ∈ X f (x)RY g(x)
Further, we can define the unit of the adjunction
η(X,RX ) : (X, RX ) → [(Y, RY ), (X, RX ) × (Y, RY )]
by η(X,RX )(x) = fx : (Y, RY ) → (X, RX ) × (Y, RY ), where fx(y) = (x, y), and the counit of the adjunction
ε(Z,RZ ) : [(Y, RY ), (Z, RZ)] × (Y, RY ) → (Z, RZ)
by ε(Z,RZ )(g, y)= g(y). Thus we have the following proposition.
Proposition 3.2 The category SetR is cartesian closed.
For the rest of this paper we make the following assumptions.
Assumption 1 The categories A and X are enriched over SetR for some ﬁxed type R of relations. Further, the categories A and X are concrete categories i.e. the objects are sets with some additional structure and carry a relation of type R, and the morphisms have underlying R-preserving functions.
We do this for two reasons. Firstly enriching over SetR is an obvious generali- sation of the approach of [6,7], and secondly to investigate expressivity we need to access individual states of objects in X.
Example 3.3 In the case where R is the type equality, then enrichment over SetR is just ordinary category theory, and so we have all the examples of logical connec- tions from the literature, see for example [5].
The following example is our leading example, and will feature prominently when we discuss expressivity.
Example 3.4 There is a logical connection enriched over SetR between MSL (meet semilattices with top) and SetR itself. To see this we need to observe that the objects of MSL come with two built-in preorders. The first is the well known par- tial order defined by x ≤ y ⇔ x = x∧y, and the second is equality. In what follows, if type R represents preorders or partial orders, then objects of MSL should be considered as having the standard partial order, and if R represents equivalence re- lations or equality, then they should be considered as carrying the equality relation. The functor P : SetR → MSL sends an object (X, RX ) to the meet semilattice of its right R-closed subsets. A subset U ⊆ X is right R-closed if x ∈ U and xRXy implies y ∈ U . P (X, RX ) is either ordered by inclusion or equality, depending upon the type R. The functor S : MSL → SetR sends a meet semilattice A to the set of its filters, again either ordered by inclusion or equality depending upon the type R.

Models, Internal Models, and R-Models
In [15] we introduced the concepts of models and internal models for an L-algebra. We summarise these definitions below, and extend them to the case of enrichment over SetR.
Definition 4.1 [Models] For an L-algebra (A, α) we define Mod(A, α), the cate- gory of models for (A, α), with objects given by pairs
((X, γ),f : X → S(A))
where (X, γ) is a T -coalgebra, and f is a morphism such that
X	ƒ	 S(¸A)
S(α)
J 
g	SL(,A,)
∗
A
J 	 ¸

T (X)
T (ƒ )
TS(A)

commutes. Such an f is called a theory map. Here δ∗ : TS ⇒ SL is defined as
δ∗ = SLρ ◦ δbS
where ρ is the unit of the logical connection, and δb is the adjunct of δ under the logical connection. The morphisms of Mod(A, α)
g : ((X1, γ1), f1) → ((X2, γ2), f2)
are given by T -coalgebra morphisms g : (X1, γ1) → (X2, γ2) such that f1 = f2 ◦ g.
Like the categories Alg(L) and CoAlg(T ), the category Mod(A, α) is enriched over SetR, and the relation (of type R) on each homobject is given be the corre- sponding relation on the underlying homobject in SetR.
Definition 4.2 [Internal Models] Given a class M of monomorphisms in X, we define the category IntModM (A, α) to be the full subcategory of Mod(A, α) where the theory maps are in M , and write
G : IntModM (A, α) → Mod(A, α) for the corresponding inclusion functor.
We parameterise by the class M , as sometimes we require the morphisms of M
to have additional properties, for example, that the members of M are preserved by T . In [15] this was exploited for the Giry functor which does not preserve all monomorphisms, but does preserve a particular subclass of them.

In [15] internal models were used to characterise expressivity for bisimulation. As we shall see in Section 6, to characterise simulation we shall need the following generalised definition.
Definition 4.3 [R-Models] The category R−Mod(A, α) is the full subcategory of Mod(A, α) where the theory maps are R-reflecting. A function f : X → Y is R- reflecting if for all x, y ∈ X if f (x)RY f (y) then xRXy. We write
H : R−Mod(A, α) → Mod(A, α) for the corresponding inclusion functor.
It should be noted that if the monomorphisms of the class M are also R-
reflecting, then the morphisms of M correspond to embeddings of the type R rela- tions, and IntModM (A, α) is a full subcategory of R−Mod(A, α).
The following definition is very important for our characterisation of expressivity, and we shall make extensive use of it.
Definition 4.4 We say a model X in Mod(A, α) factors via the internal model I in IntModM (A, α) if there exists a morphism g : X → G(I) in Mod(A, α). Similarly, X factors via the R-model J in R−Mod(A, α) if there exists a morphism h : X → H(J ) in Mod(A, α).
In future sections we will also need colimits of models. Because we are working in an enriched setting the general case is that of weighted colimits, but we shall only need conical colimits i.e. those that correspond to colimits in the ordinary categorical sense. However, we must not forget that homobjects of mediating mor- phisms and cocones (for a fixed diagram and object) must be isomorphic as objects in SetR, not just as sets.
The following two theorems follow immediately from the corresponding results of [15]. This is because created colimits are preserved, and the relation of type R on the set of cocones from a diagram to an object, corresponds to the underlying one in SetR.
Theorem 4.5 The forgetful functor U : CoAlg(T ) → X creates small conical col- imits.
Theorem 4.6 The forgetful functor U : Mod(A, α) → X creates small conical col- imits.
Expressivity
To develop a notion of expressivity that covers both bisimulation and simulation, we first need to extend the notions of logical equivalence and behavioural equivalence.
Definition 5.1 Given two models X1, X2 in Mod(A, α), and states x1 ∈ X1, x2 ∈
X2, we say x1 and x2 are logically R-related if
f1(x1) RS(A) f2(x2)

where f1 and f2 are the theory maps of X1 and X2 respectively.
Definition 5.2 Given two models X1, X2 in Mod(A, α), and states x1 ∈ X1, x2 ∈ X2, we say x1 and x2 are behaviourally R-related if there exists in Mod(A, α) a cospan


such that f1(x1) RX3 f2(x2).
X   ƒ1  X¸¸ƒ,2	X

To see that these are the correct definitions we first consider the case where the type R is equality. In this case logically R-related simply becomes equality of theories, as expected. For the definition of behaviourally R-related we see that the forgetful functor from Mod(A, α) to CoAlg(T ) yields the usual definition of behavioural equivalence as a cospan in CoAlg(T ) [9], but in addition, the forgetful functor to X yields a condition that the theory maps are compatible. This is because we are working with arbitrary L-algebras 3 , and not just the initial L-algebra, and is similar to the definition of bisimulation in [2]. Thus when the type R represents equality we have, as in [15], the case of bisimulation.
In the case where the type R represents preorders, we want to interpret the definition that x is behaviourally R-related to y, as saying that x is simulated by y. How is this so?
The usual way of approaching simulation in coalgebras is via something called a relator [4,3,13]. In the case of a functor F : Set → Set, an F -relator is a functor Γ: Rel → Rel that satisfies certain additional properties. Using this a general notion of Γ-simulation for F -coalgebras can be defined. Further, associated with F and Γ is a functor T : Preord → Preord [4, Lemma 5.5] and [13, Definition 11] given by
T (X, RX )= (F (X), Γ(RX ))
and under certain conditions [4, Theorem 9.4] the final T -coalgebra is the fi- nal F -coalgebra with the preorder given by the Γ-similarity relation. This final T -coalgebra characterises Γ-similarity of F -coalgebras as every set carries a dis- crete preorder (equality). Thus for every F -coalgebra there is a corresponding T -coalgebra, and given two F -coalgebras, the Γ-similarity relation on those two F - coalgebras is given by the preorder on the images of states under the corresponding unique cospan of morphisms to the final T -coalgebra [3, Remark 21].
Now in our general framework, for the initial L-algebra, every T -coalgebra has a unique theory map making it a model. Therefore if there exists a final T -coalgebra, it is a model, and moreover every other model factors uniquely via it. It is thus the final model Z. So for any cospan of models
X   ƒ1  X¸¸ƒ,2	X

such that f1(x1) RX3 f2(x2), there exists a unique model morphism g : X3 → Z, and this gives g ◦ f1(x1) RZ g ◦ f2(x2). So if T is given by an F -relator as above, our

3 The use of arbitrary L-algebras allows propositional variables to be treated directly, rather than as nullary modailities.

notion of similarity coincides with Γ-similarity.
Our notion of simulation can thus be seen as taking the F -relator notion of simulation and extending it to arbitrary cospans in Mod(A, α), not just those with the final T -coalgebra as the target, and also to an arbitrary functor T , rather than one arising from a functor F on Set and an F -relator Γ.
The idea of approaching coalgebraic simulation via enrichment first appeared in [7], though there the authors enrich over Pos, not Preord. It is also in [7] that the link between enrichment over preordered sets and the relator approach to simulation was first made.
Example 5.3 Consider the logical connection of Example 3.4, and where we fix the type R to be preorders. Then logically R-related corresponds to inclusion of theories. To explain behaviourally R-related we can consider a generalisation of the finite powerset functor on SetR. We define
Pfin(X, RX )= (Pfin(X), RPfin(X))


where

URPfin(X)V ⇔ ∀x ∈ U ∃y ∈ V.xRXy

(this can be seen to be an example of the Sim relator of [13]). Then using this we can define
T (X, RX )= Pfin((Σ, RΣ) × (X, RX ))
making the T -coalgebras finite branching labelled transition systems with labels from Σ. Further, we assume that RΣ is the equality relation. Then we see that for a T -coalgebra γ : (X, RX ) → T (X, RX ), the fact that γ must be R-preserving, means that xRXy implies for all (l, z) ∈ γ(x) there exists (l, z×) ∈ γ(y) such that zRXz×, which will be seen to be the usual notion that x is simulated by y.
The other two case for the type R are variations on simulation, and are sum- marised as follows:
If R is the type preorder, then we have simulation.
If R is the type partial order, then we have simulation where mutual simulation is bisimulation.
If R is the type equivalence relation, then we have mutual simulation.
If R is the type equality, then we have bisimulation.
The type R determines which type of behavioural relation we have e.g. simula- tion or bisimulation, but it is the definition of the functor T , specifically the way it defines an R relation on the codomain (in practice probably via a relator), that determines what is actually meant by simulation for the T -coalgebras.
The following result is a simple consequence of the fact that morphisms in X are
R-preserving.
Proposition 5.4 Given two models X1, X2 in Mod(A, α), and states x1 ∈ X1, x2 ∈ X2, if x1 and x2 are behaviourally R-related then x1 and x2 are logically R-related.

Finally, our expressivity definition is as follows.
Definition 5.5 An L-algebra (A, α) is R-expressive for Mod(A, α) if for all mod- els in Mod(A, α), states are logically R-related if and only if they are behaviourally R-related.

Characterisation of Expressivity
In [15] we gave an abstract, category theoretic, characterisation of expressivity for bisimulation. Here we extend this to include simulation. In actual fact the changes are minimal, and amount to little more than replacing IntModM (A, α) with R−Mod(A, α), and injective functions with R-reflecting ones.
The following theorem gives sufficient conditions for R-expressivity.
Theorem 6.1 Given an L-algebra (A, α), if the following hold:
every model in Mod(A, α) factors via some model in R−Mod(A, α),
for every pair I1, I2 in R−Mod(A, α) there is a cospan I1 → I3 → I2 in
R−Mod(A, α),
then (A, α) is R-expressive for Mod(A, α).
Proof. Take any pair of models X1 and X2 in Mod(A, α). Then these factor via the R-models I1 and I2 respectively, and by assumption there exists an R-model I3 such that there exists a cospan I1 → I3 → I2 in R−Mod(A, α). Thus both X1 and X2 factor via I3.
Spelling this out, the models ((X1, γ1), f1) and ((X2, γ2), f2) factor via the R-model ((I3, ζ3), m3) via T -coalgebra morphisms g1 : (X1, γ1) → (I3, ζ3) and g2 : (X2, γ2) → (I3, ζ3) such that f1 = m3 ◦ g1 and f2 = m3 ◦ g2.
Now suppose two states x1 ∈ X1 and x2 ∈ X2 are logically R-related for (A, α). Then f1(x1) RS(A) f2(x2), which means m3 ◦ g1(x1) RS(A) m3 ◦ g2(x2), and since m3 is R-reflecting, g1(x1) RI3 g2(x2), and x1 and x2 are behaviourally R-related.
The converse direction is given by Proposition 5.4.	2
In addition to Assumption 1, for several of the results that follow we will also need to make assumptions about the category Mod(A, α). These assumptions contain the precise category theoretic properties that we require to prove our results, however, in Corollary 6.5 we shall see that these assumptions actually follow from more basic assumptions about the category X and the functor T . Whenever we require these additional assumptions this will be indicated in the premises of the relevant proposition, lemma, or theorem.
Assumption 2 Given an L-algebra (A, α) the category Mod(A, α) has small pushouts, a factorisation system (EMod(A,α), MMod(A,α)), and is EMod(A,α)- cowellpowered, where MMod(A,α) is a subclass of those morphisms in Mod(A, α) with R-reflecting underlying functions, and EMod(A,α) is a subclass of those mor- phisms in Mod(A, α) with surjective underlying functions.

Using Assumption 2 we can prove a converse to Theorem 6.1. The most difficult part is the proof that expressivity of (A, α) for Mod(A, α) implies that all models factor via R-models.
Theorem 6.2 Given an L-algebra (A, α), and assuming the conditions of Assump- tion 2 hold, if (A, α) is R-expressive for Mod(A, α) then every model in Mod(A, α) factors via an R-model in R−Mod(A, α).
Proof. The proof is quite long and technical, but essentially the same as the bisim- ulation version of [15]. Thus we shall only sketch the outline:
Observe that all model morphisms have an (EMod(A,α), MMod(A,α))- factorisation.
For a model ((X, γ),f ) use that Mod(A, α) is EMod(A,α)-cowellpowered to take the pushout ((	I ,ζ),f†) of the E	-quotient objects of ((X, γ),f ).
j

Construct a model epimorphism h : ((X, γ),f ) → ((`

<ej >
Ij,ζ),f†).

Use the diagonalisation property of the factorisation system to show h, pj ∈
EMod(A,α) for all j ∈ J .
Use that morphisms in MMod(A,α) have underlying functions that are R- reflecting to show that f† has an underlying function that is R-reflecting.

Observe that this makes ((`

<ej >
Ij,ζ),f†) an R-model.
2

Corollary 6.3 Given an L-algebra (A, α), and with the following assumptions:
the conditions of Assumption 2 hold,
Mod(A, α) has binary coproducts,
if (A, α) is R-expressive for Mod(A, α) then for every pair I1, I2 in R−Mod(A, α)
there is a cospan I1 → I3 → I2 in R−Mod(A, α).
Proof. Given two R-models I1 and I2, since they are also models their coproduct exists, and by Theorem 6.2 the coproduct factors via an R-model, say I3, and this induces an obvious cospan between I1 and I2.	2
From Theorems 6.1, 6.2, and Corollary 6.3 we obtain our main expressivity result
an abstract, category theoretic, characterisation of R-expressivity.
Theorem 6.4 Given an L-algebra (A, α), and with the following assumptions:
the conditions of Assumption 2 hold,
Mod(A, α) has binary coproducts,
(A, α) is R-expressive for Mod(A, α) if and only if
every model in Mod(A, α) factors via an R-model in R−Mod(A, α),
for every pair I1, I2 in R−Mod(A, α) there is a cospan I1 → I3 → I2 in
R−Mod(A, α).

The conditions of Assumption 2 follow from appropriate conditions on the cat- egory X and the functor T . Essentially what is required is that X have enough colimits, and that X has a proper factorisation system, the monomorphisms of which are preserved by T .
Corollary 6.5 Given an L-algebra (A, α), and with the following assumptions:
X is a concrete category (over SetR) that has small conical colimits, has a factorisation system (EX, MX), and is EX-cowellpowered, where MX is chosen to be a subclass of those morphisms in X that have underlying functions that are injective and R-reflecting, and EX is chosen to be a subclass of those morphisms in X with underlying functions that are surjective,
T preserves MX i.e. m ∈ MX ⇒ T (m) ∈ MX,
(A, α) is R-expressive for Mod(A, α) if and only if
every model in Mod(A, α) factors via an R-model in R−Mod(A, α),
for every pair I1, I2 in R−Mod(A, α) there is a cospan I1 → I3 → I2 in
R−Mod(A, α).

Proof. We have to show that the premises of Theorem 6.4 hold. Firstly we observe that by Theorem 4.6 Mod(A, α) has small conical colimits.
To show that the factorisation system of X lifts to Mod(A, α) we note that in [5] it is observed that if T preserves MX, and the members of MX are monomorphisms, then the factorisation system of X lifts to CoAlg(T ), and it is easy to see that this extends to Mod(A, α).
Finally, Mod(A, α) is EX-cowellpowered since the morphisms in EX are epimor- phisms, and this ensures that given a span in Mod(A, α) where the underlying morphisms are in EX, there is an isomorphism between the two so defined EX- quotient objects in Mod(A, α), if and only if, there is an isomorphism between the underlying EX-quotient objects in X.	2


A Simulation Example
In order to better illustrate what actually is going on with R-models, we shall cast into our framework the well known result that the logic given by the syntax

Le φ ::= tt | φ ∧ φ | ⟨l⟩φ	where l ∈ Σ

is expressive for simulation of finite branching labelled transition systems. This continues Example 5.3, and again the type R is fixed to be preorders.
What we aim to do is define an L and δ such that L is the initial L-algebra, then any T -coalgebra has a unique theory map that makes it a model for L. For

any such model (((X, RX ), γ),f ) we then factor it as follows



(X, RX )	e


g
ƒ

 (I¸, RI )

ζ


z_
m	 S(¸L)
S(∼=)
J 
SL(,L,)
∗ L

J 	T (e)	 ¸ J 	T (m)	 ¸

T (X, RX )
T (I, RI )
_T S (L)


T (ƒ )
where (((I, RI ),ζ), m) is an R-model for L.
We start by defining the modalities using the forgetful functor U : MSL → SetR and its left adjoint F : SetR → MSL that creates free meet semilattices with a top element. Specifically, F (X, RX ) is the usual free meet semilattice F (X), over the set of variables X, with the relation RF (X) given by the equality relation extended by [x]RF (X)[y] ⇔ xRXy for all x, y ∈ X. The functor L is then defined by L(A)= 

l∈Σ
U (A), and we choose δ as follows

δ(X,RX ) : LP (X, RX ) → PT (X, RX )
TLP (X,RX ) '→ Pfin((Σ, RΣ) × (X, RX ))
[Vl]LP (X,RX ) '→ {W ∈ Pfin((Σ, RΣ) × (X, RX )) | ∃(l, x) ∈ W.x ∈ Vl}
[Vl1 ∧ Vl2 ]LP (X,RX ) '→ δ(X,RX )([Vl1 ]LP (X,RX )) ∩ δ(X,RX )([Vl2 ]LP (X,RX ))
where the notation Vl indicates that V is from the copy of UP (X, RX ) indexed by
l. This corresponds to a modal operator ⟨l⟩ for each l ∈ Σ, where ⟨l⟩a is satisfied at a state if there is an l transition from that state to one where a is satisfied. From this we get
δ∗ : TS(A) → SL(A)
V '→ {[W ]L(A) ∈ L(A) | V ∈ δS(A) ◦ L(ρA)([W ]L(A))}
where ρA(a)= {s ∈ S(A) | a ∈ s} is the unit of the logical connection, and so
δS(A) ◦ L(ρA): L(A) → PTS(A)
TL(A) '→ Pfin((Σ, RΣ) × (S(A), RS(A)))
[al]L(A) '→ {V ∈ Pfin((Σ, RΣ) × (S(A), RS(A))) | ∃(l, s) ∈ V.al ∈ s}
[al1 ∧ al2 ]L(A) '→ δS(A) ◦ L(ρA)([al1 ]L(A)) ∩ δS(A) ◦ L(ρA)([al2 ]L(A))
where again the notation al indicates that a is from the copy of U (A) indexed by l. To go back to our plan, what we need to do next is factor a theory map f via an
R-reflecting morphism m. We do this using the well known result that Hennessy-

Milner logic (L with negation) is expressive for bisimulation of finite branching labelled transition systems.
Specifically, using a functor U : X → X that assigns to every object the discrete preorder (in other words, forgets the current preorder), any model (((X, RX ), γ),f ) can be quotiented via a surjective T -coalgebra morphism e : (X, γ) → (I, ζ), where I is a subset of the ultrafilters (maximally consistent sets) of Hennessy-Milner logic. There is then an obvious function m : I → US(A) that maps an ultrafil- ter in Hennessy-Milner logic to the corresponding filter in L by throwing out all the formulae that contain negation, and moreover, U (f )= m ◦ e. The way to think of this, is that a filter in L lists all the possible future things a state in a transition system can do, and an ultrafilter in Hennessy-Milner logic explicitly adds all the things it cannot do. Note: it is well known that mutual simulation is not the same as bisimulation, therefore m is clearly not injective.
Now S(A) is ordered by inclusion, and it is easy to see that I can be given a preorder RI such that e is R-preserving, and m is both R-preserving and R- reflecting. Specifically, we can order the ultrafilters of I by the inclusion order on their negation free subsets.
Further, since e is surjective, ((I, U (ζ)),U (m)) is a model for L. What re- mains to be shown is that ζ preserves the preorder RI , for if that is the case, then (((I, RI ),ζ), m) is an R-model for L. It is easily seen that this is the case if T

preserves R-reflecting morphisms, and δ∗
is R-reflecting. The former is not very

hard to show, so what remains is to show that δ∗
is R-reflecting. In fact we shall

show this for an arbitrary L-algebra (A, α).
To do this suppose V /RTS(A)V ×, then
V /RTS(A)V × e E(l, s) ∈ V. 6(l, s×) ∈ V × either l /= l× or s/RS(A)s×
Now, our plan is to find [al]L(A) ∈ L(A) such that al ∈ s, and for all (l×, s×) ∈ V × either l /= l× or al /∈ s×. If there is no (l×, s×) ∈ V × such that l = l× then we can take al = (TA)l. If that is not the case, then there is a finite set of pairs (l, s×) ∈ V × such that s/RS(A)s×. Now s/RS(A)s× means s /⊆ s×, so it is possible to find an element of s that is not in any of the s× (do it pairwise and then take the meet - we can do this as V × is finite). Therefore δ∗ (V ) /⊆ δ∗ (V ×), which means δ∗ (V )/RSL(A)δ∗ (V ×), and

thus δ∗
A	A	A	A
is R-reflecting.

We have thus shown that every model for L factors via an R-model. Further, since SetR has coproducts, by Theorem 4.6 the coproduct of any pair of R-models, as models, exists, and since any model factors via an R-model, this yields a cospan of R-models. Therefore we have satisfied the premises of Theorem 6.1 and so we can conclude, as expected, that L is expressive for simulation of finite branching labelled transition systems.
Acknowledgement
The author would like to thank Corina Cˆırstea for the many interesting discussions and her invaluable guidance. Special thanks also go to Alexander Kurz for sharing

an unpublished version of [7].

References
Ad´amek, J., H. Herrlich, G. E. Strecker, “Abstract and Concrete Categories,” Wiley New York, 1990.
Blackburn, P., M. de Rijke, Y. Venema, “Modal Logic,” Cambridge University Press, 2001.
Cˆırstea, C., A modular approach to defining and characterising notions of simulation, Information and Computation 204(4) (2006), 469–502.
Hughes, J., B. Jacobs, Simulations in coalgebra, Theoretical Computer Science 327(1–2) (2004), 71–108.
Jacobs, B., A. Sokolova, Exemplaric Expressivity of Modal Logics, Journal of Logic and Computation
20(5) (2010), 1041–1068.
Kapulkin, K., A. Kurz, J. Velebil, Expressivity of Coalgebraic Logic over Posets, CMCS 2010 Short contributions, CWI Technical report SEN-1004, 2010, 16–17.
Kapulkin, K., A. Kurz, J. Velebil, Expressivity of Coalgebraic Logic over Posets, unpublished extended version, 2011.
Klin, B., Coalgebraic modal logic beyond sets, Electronic Notes in Theoretical Computer Science 173
(2007), 177–201.
Kupke, C., A. Kurz, D. Pattinson, Algebraic semantics for coalgebraic logics, Electronic Notes in Theoretical Computer Science 106 (2004), 219–241.
Kupke, C., A. Kurz, Y. Venema, Stone coalgebras, Theoretical Computer Science 327(1–2) (2004), 109–134.
Kupke, C., A. Kurz, D. Pattinson, Ultrafilter extensions for coalgebras, Lecture Notes in Computer Science 3629 (2005), 263–277.
Kurz, A., J. Velebil, Enriched Logical Connections, Applied Categorical Structures (online first), 2011,
http://dx.doi.org/10.1007/s10485-011-9267-y.
Levy, P., Similarity Quotients as Final Coalgebras, Lecture Notes in Computer Science 6604 (2011), 27–41.
Mislove, M., D. Pavlovic, J. Worrell, Testing Semantics: Connecting Processes and Process Logic, Lecture Notes in Computer Science 4019 (2006), 308–322.
Wilkinson, T., Internal Models for Coalgebraic Modal Logics, Lecture Notes in Computer Science
7399 (2012), 238–258.
