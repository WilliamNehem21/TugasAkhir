

Electronic Notes in Theoretical Computer Science 259 (2009) 105–121
www.elsevier.com/locate/entcs

Refinement by Interpretation in a General Setting
Manuel A. Martins1
Dep. Mathematics, Aveiro University, Aveiro, Portugal
Alexandre Madeira2
CCTC, Minho University and Dep. Mathematics, Aveiro University and Critical Software S.A., Portugal
Luis S. Barbosa3
Dep. Informatics & CCTC, Minho University, Portugal


Abstract
Refinement by interpretation replaces signature morphisms by logic interpretations as a means to translate specifications and witness refinements. The approach was recently introduced by the authors [13] in the context of equational specifications, in order to capture a number of relevant transformations in software design, reuse and adaptation. This paper goes a step forward and discusses the generalization of this idea to deductive systems of arbitrary dimension. This makes possible, for example, to refine sentential into equational specifications and the latter into modal ones. Moreover, the restriction to logics with finitary consequence relations is dropped which results in increased flexibility along the software development process.
Keywords: Refinement; algebraic specification; logic interpretation.


Introduction
In the framework of algebraic specification [17,11,18,15,19], signature morphisms are traditionally used to translate specifications and, in particular, to witness re- finements. This enables renaming, adding, removing and grouping together various signature components which is very useful during the specification and development

1 Email: martins@ua.pt
2 Email: madeira@ua.pt
3 Email: lsb@di.uminho.pt

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.020

processes. In a number of situations, however, transformations based in signature morphisms are too rigid to be useful. This is the case in the context of software reuse. But also the emergence of new computing paradigms entails the need for more flexible approaches to what is taken as a valid transformation of specifications (see, for example, [4]).
In a recent paper [13] the authors introduced an alternative approach to refine- ment of equational specifications in which signature morphisms are replaced by logic interpretations. Intuitively, an interpretation is a logic translation which preserves meaning. Originally defined in the area of algebraic logic, in particular as a tool for studying equivalence semantics (see, e.g., [2,1,3,5]), the notion proved effective to capture a number of transformations difficult to deal with in classical terms. Ex- amples include data encapsulation and the decomposition of operations into atomic transactions.
If there exists a translation τ interpreting a specification SP such that SP |= ξ ⇒ SP' |= τ (ξ) for all relevant conditional equations ξ, we say that SP' reﬁnes the speciﬁcation SP via the interpretation τ . The following example, adapted from [13], illustrates the approach.
Example 1 Consider the following fragment of a speciﬁcation of a bank accoun management system whose signature Σ1 is deﬁned by
sorts


ops
Ac;
Int ;
bal : Ac → Int ;
cred : Ac × Int → Ac deb : Ac × Int → Ac

involving account deposits (operation cred), withdrawals (deb) and a balance query (bal). The speciﬁcation is given as the axiomatic extension of the free equational logic EQΣ1 and the traditional speciﬁcation of integers:
spec BAMS = enrich EQΣ1 and INT with
axioms
⟨bal (cred (x , n)), bal (x )+ n⟩;
⟨bal (deb(x, n)), bal (x )+ (−n)⟩.

where the pair of terms ⟨t, t'⟩ represents equation t ≈ t', a kind of representation discussed latter in this paper.
Consider, now, an implementation where transactions operations affecting account balances are previously validated. This is achieved through a signature Σ2 which extends Σ1 with a new operation symbol

ops
...
val : Ac → Ac
and axioms
spec BAMS2 = enrich EQΣ2 and INT with
axioms
...
⟨bal (val (cred (x , n)), bal (x )+ n⟩;
⟨bal (val (deb(x, n)), bal (x )+ (−n)⟩.

Clearly,
τ : Eq(Σ1) −→ Eq(Σ2) = {⟨op(x), y⟩ '→ {⟨val(op(x)), y⟩}| op ∈ userOp}
where userOp = {cred, deb}, is the required interpretation.
Can this approach be generalized to arbitrary logic systems? What properties will remain valid? What can be expected from such a generalization relevant to the pragmatics of algebraic specification? Such are the questions addressed in the present paper, motivated by a well-known engineering concern: often changes in the application requirements enforce change in the underlying specification logics. The envisaged generalization resorts to a notion of k-dimensional logic to represent arbitrary deductive systems. Refinement by interpretation in such a general setting enables, for example, to refine sentential into equational specifications and into modal ones.
This observation answers our last question: the paper’s contribution is placed at the meta-level, addressing refinement across different specification logics. The example above, as well as all the results in [13], comes simply from a reduction to the equational setting. How this is achieved is discussed in the following sections. Section 2 introduces k-dimensional deductive systems and their semantics, following
[1] and paving the way to the formulation of refinement by interpretation in such a general setting in sections 3 and 4. Additionally, section 4 presents a number of examples and discusses further properties of this notion of refinement. Finally, section 5 concludes and suggests some problems deserving further attention.

Background
k-dimensional deductive systems
An equation, usually represented by a formal expression t ≈ t', can be regarded as a pair of formulas ⟨t, t'⟩. This, in turn, is an instance of a binary predicate stand- ing for the equality of two formulas. Similarly, a unary predicate representing the assertion of a formula is enough to represent a proposition. In general, adding a k-ary predicate to a strict universal Horn theory without equality, gives rise to a representation of a k-dimensional logic, thus providing a suitable context to deal si-

multaneously with different specification logics (e.g., assertional, equational, modal,
...).
The syntactic support is that of a k-term for any nonzero natural number k: A 
k-term of sort s over a signature Σ is a sequence of k Σ-terms all of the same sort
s. We indicate k-terms by overlining, i.e., ϕ¯:s = ⟨ϕ0 :s,..., ϕk−1 :s⟩, or omitting references to sorts, ϕ¯. A k-variable of sort s is a sequence of k variables all of the same sort s. Tek (X) is the sorted set of all k-terms over Σ with variables in X. Thus Tek (X)= ⟨(TeΣ(X))k : s is a sort in Σ⟩.
Σ	s
Let us now introduce some streamlined notation and terminology: if A is a Σ- algebra and ϕ¯(x0 :T0,..., xn−1 :Tn−1) is a k-term over Σ and a0 ∈ AT0 ,..., an−1 ∈

ATn−1
, then we denote by ϕ¯A(a0,..., an−1) the value ϕ¯ takes in A when the variables

x0,..., xn−1 are interpreted respectively by a0,..., an−1. More precisely, if
ϕ¯(x0,..., xn−1)= ⟨ϕ0(x0,..., xn−1),..., ϕk−1(x0,..., xn−1)⟩,
then ϕ¯A(a0,..., an−1) = h(ϕ¯) := ⟨h(ϕ0),..., h(ϕk−1)⟩, where h is any homomor- phism from TeΣ(X) to A such that h(xi)= ai for all i < n.
Let Va = ⟨Vas⟩s∈S be an arbitrary but fixed family of countably infinite disjoint sets Vas of variables of sort s ∈ S. In the sequel, we assume Va fixed for every set of sorts S. As it is usually adopted in logical frameworks we will refer to formulas (k-formulas) as a synonymous of terms (k-terms respectively). For each nonzero natural number k, given a sorted signature Σ, a k-formula of sort s over Σ is an member of (Tek (Va))s. The set of all k-formulas will be denoted by Fmk(Σ). Also note that an S-sorted subset Γ of k-formulas will be identified with the unsorted set  s∈S Γs, which allows writing ϕ¯ ∈ Γ to mean that ϕ¯ ∈ Γs, for some sort s. A set Γ ⊆ Fmk(Σ) is said to be globally ﬁnite when Γs is a finite set for each sort s of Σ and Γs = ∅ except for a finite number of them, i.e., when  s∈S Γs is finite. In this setting a k-dimensional deductive system, or a k-logic, for short, is defined as a special consequence relation on the set of k-formulas, independently of any specific choice of axioms and rules of inference. More precisely, as a substitution invariant consequence relation on the set of k-formulas. Formally,
Definition 2.1 A k-dimensional deductive system is a pair L = ⟨Σ, ▶L⟩, where Σ is sorted signature and ▶L ⊆ P(Fmk(Σ)) × Fmk(Σ) is a relation that satisfies for all Γ ∪ Δ ∪ {γ¯, ϕ¯}⊆ Fmk(Σ) the following conditions:
Γ ▶L γ¯ for each γ¯ ∈ Γ;
if Γ ▶L ϕ¯, and Δ ▶L γ¯ for each γ¯ ∈ Γ, then Δ ▶L ϕ¯;
if Γ ▶L ϕ¯, then σ(Γ) ▶L σ(ϕ¯) for every substitution σ.
A k-logic is speciﬁable if ▶L is finitary, i.e., if Γ ▶L ϕ¯ implies Δ ▶L ϕ¯ for some globally finite subset Δ of Γ. The relation ▶L is called the consequence relation of L; when L is clear from the context we simple write ▶.
It is easy to see that, for any Γ ∪ Δ ∪ {γ¯, ϕ¯}⊆ Fmk(Σ), it follows that
Γ ▶ γ¯ and Γ ⊆ Δ implies Δ ▶ γ¯.

Every consequence relation ▶ has a natural extension to a relation, also denoted by ▶, between sets of k-formulas; it is defined by Γ ▶ Δ if Γ ▶ ϕ¯ for each ϕ¯ ∈ Δ. We define the relation of interderivability between sorted sets in the following way: Γ E▶ Δ if, Γ ▶ Δ and Δ ▶ Γ. We will abbreviate Γ ∪ {ϕ¯0,..., ϕ¯n−1} ▶ ϕ¯ and Γ0 ∪· · · ∪ Γn−1 ▶ ϕ¯ by Γ, ϕ¯0,..., ϕ¯n−1 ▶ ϕ¯ and Γ0,..., Γn−1 ▶ ϕ¯ respectively.
Let L be a (not necessarily specifiable) k-logic. By a theorem of L we mean a k-formula ϕ¯ such that ▶L ϕ¯, i.e., ∅ ▶L ϕ¯. The set of all theorems is denoted by Thm(L). By an inference rule we mean a pair ⟨Γ, ϕ¯⟩ with Γ a global finite set of k-formulas and ϕ¯ a k-formula, usually we represent an inference rule ⟨Γ, ϕ¯n⟩ in the general form


ϕ¯0,..., ϕ¯n−1 ϕ¯n
,	(1)


where Γ = {ϕ¯0,..., ϕ¯n−1}. A rule such as (1) is said to be a derivable rule of
L if {ϕ¯0,..., ϕ¯n−1} ▶L ϕ¯n. A set of k-formulas T closed under the consequence
relation, i.e., T ▶L ϕ¯ implies ϕ¯ ∈ T , is called a theory of L. The set of all theories is denoted by Th(L); it forms a complete lattice under set-theoretic inclusion, which is algebraic if L is specifiable. Given any set of k-formulas Γ, the set of all consequences of Γ, in symbols CnL(Γ), is the smallest theory that contains Γ. It is easy to see that CnL(Γ) = { ϕ¯ ∈ Fmk(Σ):Γ ▶L ϕ¯}. Often, a specifiable k-logic is presented in the so called Hilbert style, i.e., by a set of axioms (k-formulas) and inference rules.
We say that a k-formula ψ¯ is directly derivable froma setΓ of k-formulas by a rule
such as (1) if there is a substitution h : Va → Fmk(Σ) such that h(ϕ¯n) = ψ¯ and
h(ϕ¯0),..., h(ϕ¯n−1) ∈ Γ.
Given a set AX of k-formulas and a set IR of inference rules, we say that ψ¯ is derivable from Γ by the set AX and the set IR, in symbols Γ ▶AX,IR ϕ¯ if there is a finite sequence of k-formulas, ψ¯0,..., ψ¯n−1 such that ψ¯n−1 = ψ¯, and for each i < n one of the following conditions holds:
ψ¯i ∈ Γ;
ψ¯i is a substitution instance of a k-formula in AX;
ψ¯i is directly derivable from {ψ¯j : j < i} by one of the inference rules in IR.
It is clear that ⟨Σ, ▶AX,IR⟩ is a specifiable k-logic. Moreover, a k-logic L is
specifiable iff there exist possibly infinite sets AX and IR, of axioms and inference rules respectively, such that, for any k-formulas ψ¯ and any set Γ of k-formulas, Γ ▶L ψ¯ iff Γ ▶AX,IR ϕ¯. Hence we will present our examples of specifiable logics by their set of axioms and inference rules. If L = ⟨Σ, ▶AX,IR⟩, for some sets AX and IR with |AX ∪ IR| < ω, we say that L is ﬁnitely aximatizable. A k-logic L' = ⟨Σ, ▶L' ⟩

is an extension of the k-logic L = ⟨Σ, ▶L⟩ if, Γ ▶L'
ϕ¯ whenever Γ ▶L
ϕ¯ for all

Γ ∪ {ϕ}⊆ Fmk(Σ) (i.e.▶L ⊆ ▶' ). A k-logic L' is an extension by axioms and rules of an specifiable k-logic L if it can be axiomatized by adding axioms and inference rules to the axioms and rules of some axiomatization of L.

k-data structures
As discussed in [1], the semantics for arbitrary k-logics needs to go beyond the usual algebraic structures, resorting to algebras endowed with a set of k-tuples. Formally, a k-data structure over a signature Σ is a pair A = ⟨A, F⟩ where A is a Σ-algebra and F is just a subset of Ak. The set F , of designated elements of A, can be regarded as the set of truth values on A: a formula holds if its interpretation is one of such elements. This is why F is called a ﬁlter : a filter for a deductive system representing the constructive propositional calculus, on a Boolean algebra is just a familiar, Boolean filter.
Let A = ⟨A, F⟩ be a k-data structure. A k-formula ϕ¯:V is said to be a seman-
tic consequence in A of a set of k-formulas Γ, in symbols Γ |=A ϕ¯, if, for every
k-formula ϕ¯ is a validity of A, and conversely A is a model of ϕ¯, if ∅ |=A ϕ¯. A assignment h : Va → A, h(ϕ¯) ∈ FV whenever h(ψ¯) ∈ FW for every ψ¯:W ∈ Γ. A rule such as (1) is a validity, or a valid rule, of A, and conversely A is a model of
the rule, if {ϕ¯0,..., ϕ¯n−1} |=A ϕ¯n. A formula ϕ¯ is a semantic consequence of a set of k-formulas Γ for an arbitrary class M of k-data structures over Σ, in symbols Γ |=M ϕ¯, if Γ |=A ϕ¯ for each A∈ M. It can be proved that |=M is always a k-logic, however not always specifiable.
Similarly, a k-formula or rule is a validity of M if it is a validity of each member of M. A k-data structure A is a model of a k-logic L if every consequence of L is a semantic consequence of A, i.e.,Γ ▶L ϕ¯ always implies Γ |=A ϕ¯. The special models whose underlying algebra is the formula algebra, i.e., of the form ⟨Fmk(Σ),T⟩, with T ∈ Th(L) are called Lindenbaum-Tarski models. The class of all models of L is denoted by Mod(L). If L is a specifiable k-logic, then A is a model of L iff every axiom and rule of inference is a validity of A.
A classe of k-data structures M is a data structure semantics of L if ▶L = |=M. The classe of all models of L forms a data structure semantics of L. This fact is expressed in the so called Completeness Theorem, i.e., for any k-logic L,Γ ▶L ϕ¯ iff Γ |=Mod(L) ϕ¯, for every Γ ∪ {ϕ¯}⊆ Fmk(Σ) (cf. [14]).

The case of equational logic
In the sequel these ideas are instantiated for the equational case. Recall that, as mentioned in section 1,a Σ-equation can be represented as a pair of formulas ⟨t, t'⟩ and the set of all equations over Va as Fm2(Σ). Similar a Σ-conditional equation is a pair ⟨Γ, e⟩ where Γ is a globally finite subset of Fm2(Σ) and e ∈ Fm2(Σ). A conditional equation ⟨{t1 ≈ t' ,..., tn ≈ t' },t ≈ t'⟩ will be written as t1 ≈
1	n
' ∧ · · ·∧ tn ≈ t' → t ≈ t'. An equation may be seen as a conditional equation
equation ⟨∅,t ≈ t'⟩. The set of all Σ-conditional equations is denoted by CeqΣ. without premisses, which justifies identifying equation t ≈ t' with the conditional
Let Γ ∪ {t ≈ t'}⊆ Fm2(Σ) and A an algebra. We write Γ |=A ϕ ≈ ψ if, for every
homomorphism h : Fm(Σ) → A,
h(ξ)= h(η) for every ξ ≈ η ∈ Γ implies h(t)= h(t').

If Γ = ∅, we write |=A t ≈ t' instead of ∅ |=A t ≈ t'.
An equation t ≈ t' is an identity of A if |=A t ≈ t'. Similarly, a conditional equation ξ0 ≈ η0 ∧ ··· ∧ ξn−1 ≈ ηn−1 → ϕ ≈ ψ is a quasi -identity of A if {ξ0 ≈ η0,..., ξn−1 ≈ ηn−1} |=A ϕ ≈ ψ.
Let K be a class of Σ-algebras. The (semantic) equational consequence relation
|=K determined by K is the relation defined between sets of equations and single equations in the following way:
Γ |=K t ≈ t' iff, for every A ∈ K we have Γ |=A t ≈ t'.
In this case we say that t ≈ t' is a K-consequence of Γ.
The equational consequence relation |=K satisfies the conditions of definition
2.1. Hence it constitutes an example of a 2-logic (perhaps the most important one!) which we sometimes designate simply by K. All notions applicable to arbitrary 2-logics, do apply to equational logics.
It can be proved that, if K is a class of Σ-algebras axiomatized by a set of conditional equations then the relation |=K is specifiable (cf.[3] for the one-sorted case). In this case the relation can be defined in the Hilbert style by considering the set of Σ-equations in Φ together with the reflexivity axioms as the set of axioms, and the Σ-conditional equations in Φ together with the symmetry, transitivity and congruence rules as the inference rules. Actually, any specifiable equational logic over Σ is the natural extension (by axioms and rules) of the (2-dimensional) free equational logic (EQΣ) defined by the
Axioms:  ⟨x:s, x:s⟩ for each sort s; Inference rules:

(IR )	⟨x:s, y :s⟩
for each sort s;

1	⟨y :s, x:s⟩

(IR )	⟨x:s, y :s⟩, ⟨y :s, z :s⟩
for each sort s;

2	⟨x:s, z :s⟩
(IR )	⟨x0 :s0, y0 :s0⟩,..., ⟨xn−1 :sn−1, yn−1 :sn−1⟩
3	⟨σ(x0,..., xn−1), σ(y0,..., yn−1)⟩
for each operation symbol σ : s0,..., sn−1 → s in Σ.


Note that EQΣ equals |=Alg(Σ), where Alg(Σ) is the class of all Σ-algebras.
As usual, an algebraic speciﬁcation SP is a pair ⟨Σ, [[SP ]]⟩ where Σ is a signature, denoted by Sig(SP ) and [[SP ]] is a class of Σ-algebras. This class of Σ-algebras is called the model class of SP , and each Sig(SP )-algebra in [[SP ]] a model of SP . If ξ is the conditional equation ⟨Γ, e⟩, we write SP |= ξ for Γ |=[[SP ]] e. An algebraic specification SP is X-flat if there is a set Φ ⊆ CeqΣ(X) such that [[SP ]] = {A ∈ Alg(Σ)|A |= Φ}. We represent an axiomatised specification SP = ⟨Σ, [[SP ]]⟩ by a

pair SP = ⟨Σ, Φ⟩ omitting explicit reference to variables X; X is assumed to be a set of variables for Σ such that Φ ⊆ CeqΣ(X) and [[SP ]] = {A ∈ Alg(Σ)|A |= Φ}. When Φ is a set of equations, the specification SP = ⟨Σ, Φ⟩ is called an equational speciﬁcation.
A class K of Σ-algebras that satisfies a given set of equations is called a variety. A variety can be characterized as a nonempty class K of Σ-algebras which is closed under homomorphic images, subalgebras and direct products. This result due to Birkhoff is very useful to show that a given algebraic specification is not flat.
Translations and Interpretations
Translations
A number of notions of translation between logical systems have been proposed in the literature (see, for example, [7,6,1,12]). In the sequel we adopt the following definition, assuming that all sets of variables are locally countable infinite.
Definition 3.1 [Translation] Let Σ and Σ' be two signatures. A (k, l)-translation from Σ to Σ' is a globally finite S − S'-sorted multi-function from Fmk(Σ) to Fml(Σ'), i.e., a S − S'-sorted multi-function such for any ϕ¯ ∈ Fmk(Σ), τ (ϕ¯) be a globally finite set.
Whenever Σ = Σ', τ is said a self translation of Σ. In this case, we say that τ commutes with substitutions if for every substitution σ and every formula ϕ¯ ∈ Fmk(Σ) τ (σ(ϕ¯)) = σ(τ (ϕ¯)). In this case, we present the translation just by giving, for each sort s, the image τs(x¯ : s) of a k-variable x¯ : s (see Example 2). Given a (k, l)-translation τ and an inference rule ξ = ⟨Γ, ϕ¯⟩, we write τ (ξ) for the set of
inference rules {⟨τ (Γ), ψ¯⟩ : ψ¯ ∈ τ (ϕ¯)}.
We say that a self (k, l)-translation τ is schematic if there is a S-sorted set Δ of
l-formulas, where for each s, Δs(x¯) is a set of l-formulas over Σ' in the k-variable
⟨x0:s,..., xn−1:s⟩ such that, for any ϕ¯ ∈ Fmk(Σ)s τs(ϕ¯)= Δs(ϕ0,..., ϕk−1).We say that a (k, l)-translation is functional if the image of each k-formula is a singleton. The schematic (2,2)-translations were used to translate algebraic specifications in the context of the reﬁnements via translations [10].
Interpretations
Defined as a multi-function, in definition 3.1, a translation maps a formula into a set of formulas. This is exactly what makes translations interesting to establish re- lationships between specifications and the main source of flexibility of the approach proposed in this paper. Recall that, on the other hand, a signature morphism maps a formula into just another formula.
Not all translations, however, are suitable to base a suitable refinement relation.
The following definition singles out the relevant ones:
Definition 3.2 [Interpretation]Let τ be a (k, l)-translation from Σ to Σ'. Let L
be a k-logic over Σ. We say that τ interprets L if there is a l-logic L' over Σ' such

that, for any Γ ∪ {ϕ¯}⊆ Fmk(Σ), Γ ▶L ϕ¯ if and only if τ (Γ) ▶L' τ (ϕ¯). In this case we say that τ interprets L in L' and L' is a τ-interpretation of L.
It can be proved that interpretations can be composed in the sense that if L' is a τ -interpretation of L and L'' is a ρ-interpretation of L' then ρ ◦ τ interprets L in L''.
The special case of functional translation with k = l = 1, i.e., between sentential languages, has been intensively studied by Feitosa and Ottaviano [7], where the interpretations were called conservative translation. Based on their work we have the following sufficient condition for a translation to be an interpretation, quite useful in practice.
Theorem 3.3 Let τ be a (k, l)-translation from Σ to Σ', L a k-logic over Σ and L' a l-logic over Σ'. Suppose that τ is functional and injective. If τ (CnL(Γ)) = CnL' (τ (Γ)) for every set of formulas Γ, then τ interprets L in L'.
Proof. From the inclusion τ (CnL(Γ)) ⊆ CnL' (τ (Γ)) we have that Γ ▶L ϕ¯ ⇒
τ (Γ) ▶L' τ (ϕ¯). Suppose now that τ (ϕ¯) ∈ CnL' (τ (Γ)) = τ (CnL(Γ)). Hence there is a ψ¯ ∈ CnL(Γ) such that τ (ϕ¯)= τ (ψ¯). Since τ is injective ϕ¯ = ψ¯, and so, ϕ¯ ∈ CnL(Γ), i.e., Γ ▶L ϕ¯.	 
The following are interesting examples of interpretations, relevant to capture the
change of logic underlying the refinements one is interested in.
Example 2 (CPC vs. Boolean algebras) The equational logic of Boolean alge- bras LBA interprets the classical propositional logic (CPC), both over the one-sorted signature Σ = {→, ∧, ∨, ¬, T, ⊥}, under the self (1,2)-translation τ (p) = {⟨p, T⟩}. Moreover, the equational logic LHA, induced by the class of Heyting algebras HA also provides an interpretation of CPC under the translation ν(p) = {⟨¬¬p, T⟩}. This translation also interprets CPC into LBA which shows that a interpretation may not to be unique [3].
Reciprocally, as one would expect, CPC also interprets LBA, now under the (2,1)-translation ρ(⟨p, q⟩)= {p → q, q → p}.
Example 3 (Semilattices into posets) A semilattice can be regarded either as an algebra or as a partially order structure. Such a duality, often useful in spec- iﬁcations, can be expressed, in a natural way, by an interpretation, actually an equivalence between two 2-logics over the one-sorted signature Σ = {∧} (see [1]).
Consider the logics
spec SLV = enrich EQΣ with
axioms
⟨p, p ∧ p⟩;
⟨p ∧ q, q ∧ p⟩;
⟨p ∧ (q ∧ r );
(p ∧ q ) ∧ r⟩;
and SLP, the speciﬁable 2-logic deﬁned by the following axioms and inference rules:

spec SLP = enrich EQΣ with
axioms
⟨p, p⟩;
⟨p, p ∧ p⟩;
⟨p ∧ q, p⟩;
⟨p ∧ q, q⟩;
inference rules
⟨x , y⟩, ⟨y, z⟩ ;
⟨x , z⟩
 ⟨x0 , y0 ⟩, ⟨x1 , y1 ⟩  ; (x0 ∧ x1 , y0 ∧ y1 ⟩

The translation τ deﬁned by the multifunction τ (⟨p, q⟩) = {⟨p, q⟩, ⟨q, p⟩} witnesses that SLP interprets SLV.
Towards algebraic semantics
There are k-logics to which an algebraic specification can be associated, thus provid- ing an alternative semantics (called algebraic semantics in the context of algebraic logic). It is well known [3] that this association is not unique and may not exist.
Definition 3.4 [τ -model] Let τ bea (k, l)-translation from Σ to Σ' and L a k-logic over Σ. A l-data structure A is a τ-model of L if for any Γ ∪ {ϕ¯}⊆ Fmk(Σ), Γ ▶L ϕ¯ implies τ (Γ) |=A τ (ϕ¯). The classe of all τ -models of L, denoted by Modτ (L), is called τ-model class of L.
As mentioned above, the semantic consequence associated to a class of k-data structures, defined over Fmk(Σ), is always a k-logic, even if it fails to be specifiable. Hence, |=Modτ (L) is a logic which we will denote by Lτ . Furthermore,
Theorem 3.5 Let τ be a (k, l)-translation from Σ to Σ' and L a k-logic over Σ. If τ interprets L, then the l-logic Lτ interprets L; moreover, it is the τ-interpretation of L with the largest class of models.
Proof. Suppose that τ interprets L. Let L' be a specification that is a τ -interpretation of L. Then for any Γ ∪ {ϕ¯} ⊆ Fmk(Σ), Γ ▶L ϕ¯ iff τ (Γ) ▶L' τ (ϕ¯) iff τ (Γ) |=Mod(L')
τ (ϕ¯). Hence all models of L' are τ -models of L. Thus, Mod(L') ⊆ Modτ (L).
So, it is enough to prove that Lτ is a τ -interpretation of L. Let Γ ∪ {ϕ¯}⊆ Fmk(Σ). It is clear that Γ ▶L ϕ¯ implies τ (Γ) ▶Lτ τ (ϕ¯). Suppose now that τ (Γ) ▶Lτ τ (ϕ¯). Let L' be a specification that is a τ -interpretation of L (it exists since τ interprets
Since, Mod(L') ⊆ Modτ (L), τ (Γ) ▶L' τ (ϕ¯). Thus Γ ▶L ϕ¯ because L' is a
τ -interpretation of L.	 
Algebraic specifications are the most common way to specify a software system. Let us then explore the special case where τ is a (k, 2)-translation. This kind of translations allows us to establish important relationships between a k-logic and an appropriate algebraic specification. Note that a (k, 2)-translation maps a k-formula

in a 2-formula. In the remaining of this section we will consider a 2-formula ⟨t, t'⟩ as an equation t ≈ t'. Therefore, let τ be a (k, 2)-translation from Σ to Σ' and L a k-logic. A class K of Σ-algebras is said to be a τ-algebraic semantics of L if τ interprets L in |=K. Based on the notion of τ -model, we define the algebraic specification SPτ , over Σ', whose class of algebras is the class of algebraic reducts of the τ-model of L having as filter the identity. Specifically,
[[SPτ ]] = {A : ⟨A, ΔA⟩ is a τ -model}
It can be proved that, given a (k, 2)-translation τ from Σ to Σ', and a k-logic L over Σ, if there is a τ -algebraic semantics of L, then the algebraic specification SPτ is the largest τ -algebraic semantics of L, i.e., with the largest class of models. Moreover, SPτ is finitely axiomatized whenever SP is.
Consider now the following mapping τL,K : Th(L) → Th(K) defined by τL,K(T )= 
CnK(τ (T )), for all T ∈ Th(L). Sometimes the algebraic specification SPτ is too
wide for our purposes, namely to discuss implementations. The following theorem gives a sufficient and necessary condition for a subclass of SPτ being a τ -algebraic semantics of L. It should be mentioned that similar results are well known for sen- tential logics [3]. In this paper we reformulate them for k-dimensional and many sorted logics, since they give interesting conditions (sufficient and necessary) for a logical system to have an algebraic semantics.
Lemma 3.6 Let L be a logic, τ a self (k, 2)-translation of Σ that commutes with substitutions and K ⊆ [[SPτ ]]. The following conditions are equivalent:
K is a τ-algebraic semantics of L.
τL,K is injective.
Proof. Let T1, T2 ∈ Th(L) and α¯ ∈ T1. Suppose τL,K(T1) = τL,K(T2). We have that τ (α¯) ⊆ τ (T1) ⊆ τL,K(T1) = τL,K(T2), i.e., τ (T2) |=K τ (α¯). Since K is an τ - algebraic semantics of L, we have T2 ▶L α¯, i.e., α¯ ∈ T2. Thus T1 ⊆ T2. In analogous way, we can proved that T2 ⊆ T1. We conclude that τL,K is injective.
Conversely, let Γ ∪ {α¯}⊆ Fmk(Σ). Since K is a class of of algebraic reducts of τ -models of L, we have that Γ ▶L α¯ implies τ (Γ) |=K τ (α¯). Now, suppose τ (Γ) |=K τ (α¯). Thus, CnK(τ (Γ)) = CnK(τ (Γ ∪ {α¯})). Since Γ ⊆ CnL(Γ), we have that τ (Γ) ⊆ τ (CnL(Γ)). Thus CnK(τ (Γ)) ⊆ CnK(τ (Cns(Γ))) = τL,K(CnL(Γ)). To prove the reverse inclusion, let t ≈ t' ∈ τL,K(CnL(Γ)). Thus {τ (ξ) : Γ ▶L ξ} |=K t ≈ t'. Again, since K is a class of of algebraic reducts of τ -models of L, for all t ≈ t' ∈ Fm2(Σ) we have that Γ ▶L ξ implies τ (Γ) |=K τ (ξ). Hence τ (Γ) |=K t ≈ t', i.e., t ≈ t' ∈ CnK(τ (Γ)). Therefore, for all Γ ⊆ Fmk(Σ), τL,K(CnL(Γ)) = CnK(τ (Γ)). Thus by these results, we have that τL,K(CnL(Γ)) = τL,K(Cns(Γ ∪ {α¯})). Since τL,K is injective, CnL(Γ) = CnL(Γ ∪ {α¯}), i.e., Γ ▶L α¯.	 
Lemma 3.6 and the fact that class [[SPτ ]] is a τ -algebraic semantics, entails another important result: if L has a τ -algebraic semantics, then any extension of L also has a τ -algebraic semantics, for τ a self (k, 2)-translation of Σ commuting with substitutions.

Refinement via interpretation
Refinement is a systematic process along which specifications are transformed from an abstract level towards concrete implementations. In each step new requirements can be added (for example, forcing operations to become deterministic), but without denying the properties explicitly stated in the original specification. Refinement proceeds in a stepwise way leading to a chain of specifications
SP0 ~ SP1 ~ SP2 ~ ··· ~ SPn−1 ~ SPn,
where for all 1 ≤ i ≤ n SPi−1 ~ SPi means a valid refinement step, entailing [[SPi]] ⊆ [[SPi−1]]. Transitivity of relation ~, often referred to as vertical composi- tion, assures that SP0 ~ SPn.
What counts for a valid refinement step is precisely what is under discussion in this paper. Our starting point is the following syntactic-grounded notion,
Definition 4.1 [(Syntactic) refinement] Let Σ and Σ' be two signatures such that Σ ⊆ Σ', with identical set of sorts, L and L' be two k-logics over Σ and Σ' respec- tively. We say that L' is a (syntactic) reﬁnement of L, in symbols L ~ L', if for any Γ ∪ {ϕ¯}⊆ Fmk(Σ),
Γ ▶L ϕ¯ ⇒ Γ ▶L' ϕ¯.
Note that when L is specifiable, L ~ L' if all the axioms of L are theorems of
L' and the theories of L' are compatible with the inference rules of L.
Example 4 Modal logic S5G forms a (syntactic) reﬁnement of CPC. Consider the modal signature Σ = {→, ∧, ∨, ¬, T, ⊥, }. The modal logic K is deﬁned as an extension of CPC by adding the axiom  (p → q) → (  p →  q) and the

inference rule p
  p
. Logic S5G, on the other hand, enriches the signature of K with

the symbol  , and K itself with the axioms  p → p,  p →   p and  p →   p (cf. [1]). Hence, since the signature of both systems contain the signature of CPC and their presentations result from the introduction of extra axioms and inference rules to the CPC presentation, we have, by the previous fact that CPC ~ K and CPC ~ S5G (actually, CPC ~ K ~ S5G). Hence, reﬁning CPC in this way, we acquire expressivity sufficient to express properties over propositions like it is necessary that φ (by φ) and it is possible that φ (by φ). This kind of reﬁnement makes possible the accommodation of a new type of requirements, modally expressed, along the reﬁnement process.
Theorem 4.2 Let Σ be a signature and L and L' two k-logics over Σ. Then the following conditions are equivalent
L ~ L'
Mod(L') ⊆ Mod(L).
Proof. (i) ⇒ (ii). Suppose L ~ L'. Let A ∈ Mod(L') and Γ ∪ {ϕ¯} ⊆ Fmk(Σ).

Suppose Γ ▶L A∈ Mod(L).
ϕ¯. We have by (i) that Γ ▶L'
ϕ¯ and hence Γ ▶A
ϕ¯. Therefore

(ii) ⇒ (i). Suppose Mod(L') ⊆ Mod(L). Let Γ ∪ {ϕ¯}⊆ Fmk(Σ). Suppose Γ ▶L ϕ¯. Let A ∈ Mod(L'). By (ii) we have A ∈ Mod(L) and hence Γ ▶A ϕ¯. Therefore, by completeness, Γ ▶L' ϕ¯.	 
A coarser and more flexible definition of refinement, however, is provided by the notion of logic interpretation. Formally,
Definition 4.3 [Refinement via interpretation] Let L be a k-logic over Σ and τ a (k, l)-translation from Σ to Σ', which interprets L and such that the empty set does not belong to its codomain. We say that a l-logic L' over Σ' reﬁnes the logic L via the interpretation τ , in symbols L zτ L', if for any Γ ∪ {ϕ¯}⊆ Fmk(Σ),
Γ ▶L ϕ¯ ⇒ τ (Γ) ▶L' τ (ϕ¯).

The condition that τ has to interpret L is required in order to have some control under the class of models of the logic L'. In particular this guarantees that Mod(L') has to be smaller than SPτ .
The following two examples illustrate the reﬁnement via interpretation approach at work.
Example 5 Any subclass of the class of Boolean algebras induces a τ- reﬁnement of CPC with τ the usual (1,2)-translation deﬁned by τ (p)= {⟨p, T⟩}).
Example 6 Consider the fragment of the speciﬁcation BAMS, of a bank account management system, given in Example 1. Suppose we intend to reﬁne this system by imposing that the balance of each account has to be positive. Naturally, this cannot be expressed in a (strict) equational logic. However, this situation can be encompassed using our formalization of reﬁnement. Actually, consider now the following 2-logic over Σ:
spec ORDBAMS = enrich INT with
axioms
⟨x :s, x :s⟩, s ∈ {Ac, int};
⟨bal (cred (x , n)), bal (x )+ n⟩; ⟨bal (x )+ n, bal (cred (x , n))⟩;
⟨bal (deb(x, n)), bal (x )+ (−n)⟩; ⟨bal (x )+ (−n), bal (deb(x, n))⟩
inference rules
⟨x :Ac, y :Ac⟩ ;
⟨y :Ac, x :Ac⟩

⟨x , y⟩; ⟨w, z⟩
⟨x + w, y + z⟩
;	⟨x , y⟩
⟨−y, −x⟩

⟨x :s, y :s⟩; ⟨y :s, z :s⟩ ; s ∈ {Ac, int};
⟨x :s, z :s⟩

⟨x , y⟩
⟨bal (x ), bal (y )⟩
;	⟨x , y⟩
⟨bal (y ), bal (x )⟩
;	⟨x , y⟩
⟨cred (x ), cred (y )⟩
;	⟨x , y⟩
⟨deb(x ), deb(y )⟩


Let us take a ﬁxed-semantics approach. Consider the ﬁxed-semantics of the above logics by ﬁxing the Int component of the domains as the integer numbers (endowed

with its operations) and ﬁxing the Int component of their ﬁlters as the identity re- lation. In fact, consider the following subclasses of model class of the above 2-logics: BAMSZ = { ⟨AAc, AInt⟩, ⟨F1, F2⟩  ∈ Mod(BAMS) : AInt = Z & F2 = idZ}
ORDBAMSZ =
{ ⟨AAc, AInt⟩, ⟨G1, G2⟩  ∈ Mod(ORDBAMS) : AInt = Z & G2 =≤}.
Let now τ be the (2,2)-translation deﬁned schematically by τInt(⟨x, y⟩)= {⟨x, y⟩, ⟨y, x⟩}
and τAc(⟨x, y⟩) = {⟨x, y⟩} (the idea behind is that an equation x ≈ y of sort Int is translated in the two inequalities x ≤ y and y ≤ x). Intuitively, we can ac- cept that |=ORDBAMSZ is a τ-interpretation of |=BAMSZ . Now, adding the axiom
⟨0, balance(x)⟩ we obtain the announced speciﬁcation as a τ-reﬁnement of the orig-
inal one.
Having illustrated some typical applications of the notion of refinement put forward in this paper, it is legitimate to ask now how does it relate to the traditional ones. From the previous theorem we achieve at the following characterization of the refinement via interpretation:
Theorem 4.4 Let L and L' be a k-logic over Σ and l-logic over Σ' respectively. Let
τ be a (k, l)-translation from Σ to Σ'. Then the following conditions are equivalent
L zτ L';
L' is a reﬁnement of some τ-interpretation of L,
( i.e., there is a l-logic L0 which τ-interprets L and L0 ~ L'.)
Proof. Suppose L zτ L'. Then Mod(L') is a subclasse of τ -models of L. By Theorem 3.5 Mod(L') ⊆ Mod(Lτ ). Therefore, by Theorem 4.2, Lτ ~ L'. So, condition (ii) holds for L0 = Lτ .
Suppose now there is a l-logic L0 which τ -interprets L and L0 ~ L'. Let Γ ∪ {ϕ¯}⊆ Fmk(Σ). Then
Γ ▶L ϕ¯ ⇔ τ (Γ) ▶L0 τ (ϕ¯) ⇒ τ (Γ) ▶L' τ (ϕ¯).
The equivalence holds since τ interprets L in L0. The implication holds since
Lτ ~ L'. Therefore, L zτ L'.	 
Example 7 Suppose a requirements speciﬁcation is provided in the CPC speciﬁca- tion logic, but one would like to obtain an implementation in which the properties of the system must be shown in a constructive way, for example by resorting to some kind of theorem prover. This entails the need for the speciﬁcation refac- toring within some variant of intuitionist logic. Based on Theorem 4.4 we get CPC zτ HA zρ IPC, with τ (p) = {⟨¬¬p, T⟩} and ρ(⟨p, q⟩) = {p → q, q → p} doing the job.
The discussion concerning the composition of refinements via interpretation is not straightforward. For vertical composition one gets

Theorem 4.5 Let L, L' and L'' be k, l and m-logics over Σ, Σ' and Σ'' respectively. Let τ be a (k, l)-translation from Σ to Σ' and ρ a (l, m)-translation from Σ' to Σ''. Suppose that L zτ L', L' zρ L'' and ρ interprets Lτ . Then L zρ◦τ L''
Proof. Directly from the fact that L zτ L' and L' zρ L'' we have that Γ ▶L ϕ¯ implies ρ(τ (Γ)) ▶L'' ρ(τ (ϕ¯)) for any Γ ∪ {ϕ¯}⊆ Fmk(Σ).
On the other hand, we have by hypothesis and the previous theorem, that for any Γ, {ϕ¯}⊆ Fmk(Σ),
Γ ▶L ϕ¯ ⇔ τ (Γ) ▶Lτ τ (ϕ¯) ⇔ ρ(τ (Γ)) ▶Lτ ρ ρ(τ (ϕ¯)),
and hence, ρ ◦ τ interprets L. Therefore, L zρ◦τ L''.	 
On the other hand, horizontal composition of refinements via interpretations is still a topic of current research, which leads us to the conclusions of this paper.
Conclusions and future work
The paper succeeded in providing a smooth generalization of a rather new approach to refinement based on logic interpretations, a powerful tool used in algebraic logic, to arbitrary logic systems. As one could expect, this generic account of reﬁnement by interpretation is mainly useful at the specification meta-level, i.e., whenever an implementation step requires a change in the underlying logic. This often arises, in formal software development, with the need for accommodating new requirements (as in Example 6) or when a particular theorem prover, embodying a specific logic, is to be used for validating design (as in Example 7).
A lot of questions, however, remain to be answered. For example, one can in- tuitively accept that a refinement via signature morphism, in the usual sense, can be regarded as a refinement via interpretation. However, in the framework intro- duced in this paper, this is not achieved in a straightforward way since signature morphisms implicitly define a translation of the variables. Thus in order to ac- commodate in our framework the classical refinement procedure, a logic has to be parameterized by the variables used to generate its formulas.
On the other hand, we believe this approach has an enormous application po- tential, when tuned to the many variants of pure algebraic specification of software, namely the approaches of observational logic [8], hidden logic [16] and [14] and be- havioral logic [9]. In all of these cases the satisfaction of requirements is discussed up to some particular satisfaction relation and their verification is checked with re- spect to relations obtained by replacing, in the standard satisfaction relation, strict equality by its underlying notion of satisfaction. In this context, the adoption of a semantics based on k-data structures, offers theoretical support to the unification of all of these approaches since models in all of those cases consist of algebras whose k-data structures are of the form ⟨A, θ⟩ where θ captures the particular satisfaction relation in each formalisms.
Naturally, most of the models (and τ -models) of software specifications are not admissible choices as implementations.  For example, the structure ⟨A, ∇A⟩ is a

model of any logic over the corresponding specification signature. Therefore, the choice of adequate filters along the implementation process becomes a crucial, al- though not trivial task. It should be done according to the system nature (for example, adopting observational equality to deal with objects with encapsulated data). A similar concern is, moreover, shared by other general approaches, to for- mal development, as, for example, within the behavioral logic of [9].
Acknowledgement
This research was developed in the context of the project MONDRIAN (under the contract PTDC/EIA-CCO/108302/2008) and was supported by Fct (Portuguese Foundation for Science and Technology) under the contracts SFRH/BDE/33650/2009, PTDC/EIA/73252/2006, at Minho University, as well as PTDC/MAT/68723/2006 and the Unidade de Investigac¸˜ao Matem´atica e Aplica¸c˜oes of University of Aveiro.

References
W. Blok and D. Pigozzi. Abstract algebraic logic and the deduction theorem. Preprint. To appear in the Bulletin of Symbolic Logic. Available at http://www.math.iastate.edu/dpigozzi/ papers/aaldedth.pdf.
W. Blok and D. Pigozzi. Algebraizable logics. Memoirs of the American Mathematical Society, 396, Amer. Math. Soc., Providence, 1989.
W. Blok and J. Rebagliato. Algebraic semantics for deductive systems. Studia Logica, 74(1-2):153–180, 2003.
Don Batory, J. N. Sarvela, and A. Rauschmayer. Scaling step-wise refinement. IEEE Trans. in Sofware Engineering, 30(6):355–371, 2004.
J. Czelakowski. Protoalgebraic Logics. Trends in logic, Studia Logica Library, Kluwer Academic Publishers, 2001.
H. A. Feitosa and I. M. L. D’Ottaviano. Conservative translations. Ann. Pure Appl. Logic, 108(1- 3):205–227, 2001.
H. Feitosa. Tradu¸c˜oes Conservativas. PhD thesis, Universidade Federal de Campinas, Instituto de Filosofia e Ciˆencias Humanas, 1997.
Rolf Hennicker and Michel Bidoit. Observational logic. In AMAST ’98: Proceedings of the 7th International Conference on Algebraic Methodology and Software Technology, pages 263–277, London, UK, 1999. Springer-Verlag.
R. Hennicker. Structural specifications with behavioural operators: semantics, proof methods and applications, 1997. Habilitationsschrift.
A. Madeira. Observational refinement process. Electr. Notes Theor. Comput. Sci., 214:103–129, 2008.
M. A. Martins. Behavioral institutions and refinements in generalized hidden logics. Journal of Universal Computer Science, 12(8):1020–1049, 2006.
T. Mossakowski, R. Diaconescu, and A. Tarlecki. What is a logic translation ? Logica Universalis, 2009.
M. A. Martins, A. Madeira, and L. S. Barbosa. Refinement via interpretation. In Proc. of 7th IEEE Int. Conf. on Software Engineering and Formal Methods, Hanoi, Vietnam, November 2009. IEEE Computer Society Press.
M. A. Martins and D. Pigozzi. Behavioural reasoning for conditional equations. Mathematical. Structures in Comp. Sci., 17(5):1075–1113, 2007.


K. Meinke and J. V. Tucker. Universal algebra. In Handbook of logic in computer science, Vol. 1, volume 1 of Handb. Log. Comput. Sci., pages 189–411. Oxford Univ. Press, New York, 1992.
G. Ro¸su. Hidden Logic. PhD thesis, University of California, San Diego, 2000.
D. Sannella and A. Tarlecki. Foundations of Algebraic Specifications and Formal Program Development. Cambridge University Press, To appear.
A. Tarlecki. Abstract specification theory: An overwiew. In Models, Algebras, and Logics of Engineering Software,M. Broy, M. Pizka eds., NATO Science Series, Computer and Systems Sciences, VOL 191, pages 43–79. IOS Press, 2003.
M. Wirsing. Algebraic specification. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science (volume B), pages 673–788. Elsevier - MIT Press, 1990.
