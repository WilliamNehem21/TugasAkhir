	Electronic Notes in Theoretical Computer Science 171 (2007) 127–151	
www.elsevier.com/locate/entcs

A Calculus of Global Interaction based on Session Types
Marco Carbone1 ,a  Kohei Honda2 ,b  Nobuko Yoshida3 ,a
a Department of Computing Imperial College London London, United Kingdom
b Department of Computer Science Queen Mary College University of London
London, United Kingdom

Abstract
This paper proposes a calculus for describing communication-centred programs and discusses its use through a formal description of several use cases from real business protocols. The formalism, called global calculus, aims at representing global message flows as structured communications. The global calculus originates from the Choreography Description Language (CDL), a web service description language developed by W3C’s WS-CDL Working Group. Its type discipline is based on session types which have been studied over long years in the context of the π-calculus [15,10,22,6]. Session types offer a high-level abstraction and articulation for complex communication behaviours, and play a fundamental role to guide the programmer towards a clear, well-structured description of business protocols.
Keywords: Web Services, Communication-Centred Programming, π-Calculus, Session Types.


Introduction
The purpose of the present paper is to introduce a communication-based calculus which fundamentally differs from existing concurrency formalisms. This calculus was born as a result of a dialogue with a W3C’s working group on web service standards, and is based on the idea of global description of interactions. As its origin in W3C standardisation suggests, this formalism is the distillation of engi- neering needs for describing complex interaction which may occur in real world business processes. The associated long version [9] presents extensive examples of

1 Email: carbonem@doc.ic.ac.uk
2 Email: kohei@dcs.qmul.ac.uk
3 Email: yoshida@doc.ic.ac.uk

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.041

business protocols written in the proposed global formalism, together with a formal correspondence with a standard process formalism, the π-calculus.
The direct engineering background of the present work is Web Services Chore- ography Description Language, often abbreviated as WS-CDL [23], an XML-based web service description language developed by W3C’s WS-CDL Working Group, in collaboration with invited scientists including the present authors. WS-CDL has been developed in order to meet the engineering needs for the development of busi- ness protocols on the world-wide web. The central engineering idea of WS-CDL is embodied by the term choreography in its name. The underlying intuition can be summarised as:
“Dancers dance following a global scenario without a single point of control”.
WS-CDL is about writing down such a “global scenario”: in computational terms, it is a language for describing business protocols from a global viewpoint such that the description can be executed by communications among distributed processes without a single point of control. In other words, if a designer writes a global description in WS-CDL, it should be realisable as communicating processes with- out any central controlling agent (which contrasts with the notion of orchestration, where one master component, “conductor”, directly controls activity of one or more slave components). Thus the notion of choreography intrinsically demands an im- plementation framework of global protocols to be correctly realised in each location. For this purpose, types play a fundamental role in WS-CDL.
A broader background of the present work is the explosive growth of the Internet and world-wide. This engineering background makes it feasible and advantageous to develop applications which will be engaged in complex sequences of interactions among two or more parties. Another background is maturing of theories of pro- cesses centring on the π-calculus and its types. The introduced formalism is based on a notion of structured communication, called session. A session binds a series of communications between two parties into one, distinguishing them from com- munications belonging to other sessions. This is a standard practice in business protocols (where an instance of a protocol should be distinguished from another instance of the same or other protocols) and in distributed programming (where two interacting parties use multiple TCP connections for performing a unit of con- versation). The type disciplines for sessions have been studied for many years in the context of the π-calculus [15,10,22,6], where it has been shown that they offer a high-level abstraction for communication behaviour upon which further refined reasoning techniques can be built. Not only sessions offer a natural articulation for description of global description of complex interaction behaviour but also session types play an essential role in the presented theory for guiding the programmer towards a correct implementation of the business protocols.
This paper introduces the formal calculus and the idea of session types with many illustrative examples to those without background of process calculi and their typing systems. Section 2 and 3 introduce and illustrate the global formalism (a distilled version of WS-CDL). Section 4 illustrates the session types for the calculus. Finally Section 5 demonstrates its expressiveness by showing a large example inspired from a

use case of WS-CDL, together with its implementation as communicating processes. Further examples and the full technical development of a theoretical basis of the formalism can be found in [9].

Related Work.
Global methods for describing communication have been practiced in different en- gineering scenes in addition to WS-CDL. Representative examples include Message Sequence Charts (MSC) [14,1] and UML diagrams. These notations offer a use- ful aid at the design/specification stage, but are not intended as full-fledged pro- gramming languages, lacking in e.g. general control structures and/or notations for value/state manipulation. Petri-nets [21] can also be seen as offering a global description, though they are more useful as a specification/analytical tool.
DiCons is a notation for global programming of Internet applications [2]. Di- Cons chooses to use programming primitives close to user’s experience, such as web server invocation, email, and web form filing, rather than general communication primitives. Its semantics is given by either MSCs or direct operational semantics. DiCons differs from our global calculus in that it does not use communication- oriented types and that it is intended for a specific application domain rather than being presented as a generic calculus.
The present work shares with many recent works in its use of types for well- structured communication-centred programming [19,3]. In particular, our work is based on the studies on session type disciplines [20,15,11,10,22,6], and extends them to both global descriptions and intra-session parallel communications. All previous work are based on end-point languages and calculi.
Fournet, Gordon, Bhargavan and Corin studied security-related aspects of web services. In their recent work [5], the authors have implemented part of WS-Security libraries using a dialect of ML, and have shown how annotated application-level usage of these security libraries can be analysed with respect to their security prop- erties by translation into the security-enhanced π-calculus.
Laneve and Padovani [16] give a model of orchestrations of web services using an extensions of π-calculus to join patterns. They propose a typing system for guaranteeing a notion of smoothness i.e. a constraint on input join patterns such that their subjects (channels) are co-located in order to avoid a classical global consensus problem during communication.
A bisimulation-based correspondence between choreography and orchestration in the context of web services has been studied by Busi et al. [8], where a no- tion of state variables is used in the semantics of the orchestration model. They operationally relate choreographies to orchestration. In [12], the same authors in- troduce SOCK, a calculus for web services based on end-point descriptions. This formalism models networks of participants and their local behaviour enhanced with a mechanism for controlling communication at run-time based on logical conditions on the participant’s store. In our work, communication structures are abstracted as session types. Using session types, the error freedom can be statically guaranteed by a type inference algorithm. Their dynamic control allows concrete reasoning on

the communicated values, but may require heavy run-time mechanisms. It is an interesting topic to integrate these two methods for efficient and flexible control of interactions.
As we noted, global notations are often used for representing security proto- cols, for which there are several recent works which offer formalisations. Briais and Nestmann [7] present a global notation for representing protocol narrations and relate it to the π-calculus. Since their sole focus is on cryptographic pro- tocols, their global formalism is not intended as a fully expressive language for describing communication-centred software behaviour. Concretely their formalism does not include such notions as channel-based communication, conditional, branch- ing/selection, loops, as well as type disciplines for communication. Strand Space
[13] is a mathematical structure for analysing properties of cryptographic proto- cols. It models cryptographic protocols as causal chains of interactions, and is often presented in a global notation similar to UML sequence diagrams. Strand space does not by itself offer a description language for communication-centred programs, but rather a mathematical structure for representing them as abstract events with causality and composability. Their methods for security analysis may however be applicable to our global calculus.

The Global Calculus
Basic Ideas
In this section and the next, we introduce the syntax, dynamic semantics and static semantics of the global calculus. The syntax defines the set of terms where each term gives a description of interaction among two or more participants.
The description of interactions in the global calculus centres on the notion of session, in which two interacting parties establish a private connection for engaging a series of interactions, possibly interleaved with other sessions. More concretely, processes first exchange fresh session channels for a newly created session, then use them for interactions belonging to the session (this is equivalent to the more implicit framework where identity tokens in message content are used for signifying a ses- sion). For example, a simple protocol between Seller and Buyer can be represented as a term thus: called interaction:


Buyer → Seller : serv(νs) .
Buyer → Seller : s⟨RequestQuote, productName, x ⟩ .
Seller → Buyer : s⟨ReplyQuote, productPrice, y ⟩.0

(1)


In (1) above, a Buyer asks for a service serv creating the new session channel s which will be used for in-session message exchange. Therefore, Buyer requests a quote for a product, specifying the product name and, through the same channel,

a Seller replies with the quote value. In a single interaction:

Buyer → Seller : s⟨RequestQuote, productName, x ⟩

Here Buyer specifies the sender, Seller the receiver, s a session identifier, RequestQuote the operation name, productName the value to be sent, and x the variable at the receiver’s side which gets populated once the sending of a value is done.
Once terms are given, the dynamic semantics specifies an abstract notion of “computation” underlying the global calculus. This is represented as a transition from a global description to another global description, carrying out each step of interaction (e.g. exchange of a message). Since each participant may own its own local variables, such transition can also involve collection of local variables of the participants involved. The dynamic semantics is defined using an intuitive notation,

(σ, I) → (σ',I')

which says a global description I in a state σ (which is the collection of all local states of the participants) will be changed into I' and a new configuration σ' results. This idea comes from the small-step semantics for imperative languages.
The static semantics of the global calculus assigns types to well-formed terms. Since the calculus is based on session, we use a type discpline where we represent a structured sequence of interactions between two parties in a session as an type. Here “types” mean syntactic annotation on descriptions of interactions: in the present case, this annotation describes an abstract notion of interface of a service (or a shared service channel), and is inferred by typing rules for each description following its syntactic structure. For example, taking the example 1 above, the interactions at s can be abstracted by the following session type:
s ↑ RequestQuote(String). s ↓ ReplyQuote(Int)	(2)

The session type in (2) abstracts a sequence of actions performed at ch, specifying the following abstract behaviour:
First send (“↑”) a string with operation name RequestQuote, then receive (“↓”) an integer with operation name ReplyQuote.
Note this abstraction is given from the Buyer’s viewpoint. Similarly, we can present the abstraction from the Seller’s viewpoint:

s ↓ RequestQuote(String). s ↑ ReplyQuote(Int)	(3)

which simply reverses the direction of information flows. Note that, in this way, there is a natural notion of duality associated with session types [15].

Formal Syntax
The formal syntax of the global calculus is given by standard BNF. Below symbols I, I',... denote terms of the global calculus, also called interactions. Terms de- scribe a course of information exchange among two ore more parties from a global viewpoint.
I ::= A → B : ch(ν s˜) . I	(init)
| A → B : s⟨op, e, y⟩ . I	(com)
| x@A := e . I	(assign)
| if e@A then I1 else I2	(ifthenelse)
| I1 + I2	(sum)
| I1 | I2	(par)
| (νs)I	(new)
| X	(recVar)
| rec X . I	(rec)
| 0	(inaction)
The grammar above uses the following symbols 4 :
a, b, c, ch,... range over a collection Ch of service channels (also called session initiating channels). They may be considered as shared channels of web services.
s, s',... range over a collection S of session channels. Session channels desig- nate communication channels freshly generated for each session. They can be implemented in various ways: in TCP, the same concept is realised by so-called connection (also called session). In web services, they are realised by sending freshly generated identity information as part of messages.
A, B, C,... range over a collection P of participants. Participants are those who are engaged in communications with others, each equipped with its own local state. Each participant may have more than one threads of interactions using multiple channels.
x, y, z,... range over a collection Var of variables, which are close to variables in the traditional programming languages such as Pascal and C, in that their content is updatable.
X, Y, Z,... range over a collection of term variables, which are used for represent- ing recurrence (loop) in combination with recursion rec X.I. Note term variables occur annotated with participants.
e, e',... range over expressions, given by the grammar e  ::=  x  |  v  | f (e1,... , ek) where f ranges over an appropriate set of function symbols (includ- ing standard arithmetic/boolean operators) and v, w,... range over atomic values such as natural numbers and booleans.

4 As standard, we assume there is an unbounded supply of distinct symbols in each syntactic category.

Each construct in the above grammar is illustrated in the next subsection. We write A → B : s⟨op⟩ . I whenever the expression e and the variable x are not important in A → B : s⟨op, e, x⟩ . I.

Illustration of Syntax
The initial two constructs represent communications. First, A → B : b(ν s˜) . I indicates that A invokes a service channel b at B and initiates a new session that will use fresh session channels s˜, followed by interaction I. Subsequent communications in I belonging to this session are done through s˜ (I can have other communications belonging to different sessions). In the main part of the present study we shall assume A and B are distinct 5 . As s˜ should be local to the session (i.e. unknown outside), we set each si ∈ s˜ to be bound in I.
Second, A → B : s⟨op, e, y⟩ expresses the sending action by A whose message consists of a selected operator op, with the receiver B. The value of the expression e (which can only use variables located at A) is assigned to the variable y (which must be located at B).
Third, another primitive operation is the assignment x@A := e . I. The opera- tion is local at the specified participant (A above), where variable x at A is updated with the result of evaluating e, also located at A.
We can use the conditional if e@A then I1 else I2 or the summation I1 + I2 to branch the course of actions. The first operation evaluates e once and, if it evaluates to true, the branch I1 will be executed, else branch I2. Note the condition e is located at A. The second operation implicitly selects one of the branches by non- deterministically behaving either as I1 or as I2. The summation operator + is commutative and associative, so that we often write ΣiIi for the n-fold sum of interactions.
The term I1 | I2 denotes the parallel composition. However, unlike the standard process calculi, there is no communication between I1 and I2: I1|I2 just means two independent threads of interactions.
(νs)I denotes restriction (or hiding) of a session channel, where (νs) binds free occurrences of s in I. This is used for designating newly created session channels when a session is initiated. The term (νs˜)I stands for a sequence of restrictions. Since restriction is only added when an outermost initialisation prefix reduces, it is natural to assume that restrictions never occur under preﬁxes initiation, communi- cation and assignment nor do they occur in a summand of a summation.
Interaction which can be repeated unboundedly is realised by recursion. Then the term rec X . I is the standard recursion construct, where rec X is called recur- sor, with X, the recursion variable, binding its free occurrences in I. Finally, 0 is the inaction, representing the lack of actions.

5 This is a natural constraint if we wish to describe inter-participants interactions, which are often the only focus of many business protocols. The theoretical framework of the present study works intact when we allow intra-participant interactions.

Examples

We illustrate the syntax through simple examples. These examples will be used throughout the paper as running examples.
Example 1 (Syntax, 1) Consider the following interaction:



{Buyer → Seller : B2Sch⟨QuoteAccept, 100 , x ⟩ . I1 }
+
{Buyer → Seller : B2Sch⟨QuoteReject, xAbortNo, y ⟩ . I2 }

(4)



In this example, Buyer and Seller are the participants involved, B2Sch is a session channel name and QuoteAccept and QuoteReject are operation names. Thus, as a whole, (4) can be read as follows:
Through a session channel B2Sch, Buyer selects one of the two options offered by Seller, QuoteAccept and QuoteReject. If the ﬁrst option is selected, Buyer sends the quote “100” which will be stored in x by Seller and proceeds to I1. In the other case, Seller sends the abort number stored in the variable xAbortNo which will be stored in y by the Seller and proceeds to I2.
We interpret the sum + as an internal sum for Buyer (i.e. Buyer initiates this choice) and as an external sum for Seller (i.e. Seller passively waits for one of the branches (operators) to be chosen by the environment).
Example 2 (Syntax, 2) The following is a refinement of the description above:



if xquote ≤ 1000 @Buyer then
{  Buyer → Seller : B2Sch⟨QuoteAccept, 100 , x ⟩ . I1	}
else
{ Buyer → Seller : B2Sch⟨QuoteReject, xAbortNo, y ⟩ . I2 }


(5)



This description now specifies the “reason” why each branch is taken. Notice the condition in the conditional branch, x ≤ 1000, is explicitly located: the description says this judgement takes place at Buyer. Note also the description is still the external choice for Seller: it is Buyer who selects one of the options, which Seller waits for passively. The description becomes self-contained by adding an initial

session invocation at a service channel, say ch, and a request for a quote.


Buyer → Seller : ch(ν B2Sch, S2Bch ) . Seller → Buyer : S2Bch⟨Quote, 100 , y ⟩ . if xquote ≤ 1000 @Buyer then
{  Buyer → Seller : B2Sch⟨QuoteAccept, 100 , x ⟩ . I1	}
else
{ Buyer → Seller : B2Sch⟨QuoteReject, xAbortNo, y ⟩ . I2 }




(6)

In here, Buyer invokes Seller to initiate a session with the session channels B2Sch
and S2Bch .
Example 3 (Syntax, 3) A session can have multiple session names for communi- cation. This is the standard practice in business protocols and other interaction- centred applications, and is essential to have multiple parallel interactions inside a single session. As an example, suppose that Buyer wants to start a session at a channel acc in which it communicates acceptance of a quote on a session name Op and, in parallel, sends its address on a session name Data. This can be expressed as:

Buyer → Seller : acc(ν Op, Data) .
{Buyer → Seller : Op⟨QuoteAccept, 100 , x ⟩ . 0	|
Buyer → Seller : Data⟨QuoteAccept, Address, y ⟩ . 0	}

(7)

Here, two session channels, Op and Data, are communicated at the time of session initiation at channel acc.
Examples of other constructs, such as recursion and hiding, will be given in the last section.

Dynamics of the Global Calculus
Basic ideas of Reduction
From an engineering viewpoint, the dynamic semantics pins down a mathematical notion which designers, implementers and users can refer to when they wish to discuss about dynamic behaviour of description with rigour. For example, this would allow us to state with precision whether an implemented program conforms to the description or not. Another example usage is in monitoring, where a monitor would check the execution based on the stipulated formal dynamic semantics of a given description.
Computation in the global calculus is represented by a step-by-step transition, each step consisting of the execution of a primitive operation, such as communi- cation, assignment or conditional, which has an effect on on the local state of an involved participant.

To formalise this idea, we use a conﬁguration which is a pair of a state (a col- lection of the local states of all participants involved) and an interaction, written (σ, I). Formally a state, ranged over by σ, σ',.. ., is a function from V ar ×P to V al, i.e. a variable at each participant is assigned a value in a store. We shall write σ@A to denote the portion of σ local to A, and σ[y@A '→ v] to denote a new state which is identical with σ except that σ'(y, A) is equal to v. The dynamics is defined in the form:
(σ, I) → (σ', I')
which says I in the configuration σ performs one-step computation (which can be assignment, interaction, etc.) and becomes I' with the new configuration σ'. The relation → is called reduction or reduction relation 6 . For example, communication action will change both the state and the term shape:
(σ, A → B : s⟨send, 3, x⟩.I) → (σ[x@B '→ 3], I) which indicates:
“A sends a message send with value 3, which is received by B and stored in the
variable x at B, with the residual interaction I”.
Note communication action happens automatically, without first having sending and receiving actions separately and then having their synchronisation. Assignment is treated similarly.
(σ, x@B := 3.I)	→	(σ[x@B '→ 3], I)
Since an assignment is located, only x at B is updated, and the next interaction I is unfolded. Interaction can involve choice, where one of the branches is chosen nondeterministically, i.e. we can have either:
(σ, I1 + I2) → (σ, I1)	or	(σ, I1 + I2) → (σ, I2)
and they are both legitimate reductions.
The conditional depends on the evaluation of an expression. For example, as- suming x at A stores 0, we have
(σ, if x@A =0 then A → B : s⟨ok, 3, x⟩.I1 else ...)	→	(σ[x@B '→ 3], I1) But if x at A stores say 1, then the second branch will be selected.
For recursion, we expect a recurring behaviour. For example, the following behaviour just continues to assign 1 to a variable:
(σ, rec X.x@B := 1.X) → (σ[x@B '→ 3], rec X.x@B := 1.X)
In the following subsection, we illustrate the notion of reduction for each con- struct one by one.

6 The term “reduction” originally comes from the λ-calculus, where the sole purpose of computation is to reduce to a final answer of calculation. While it is not entirely suitable for interaction computation, we use the term from convention and from our respect to the basic formalism which started semantics studies.

Reduction Rules.
Reduction relation is defined by having one rule for each construct, together with associated rules. First we have a rule for session-initiating communication:
(Init)	−
(σ, A → B : b(ν s˜) . I) → (σ, (νs˜)I)
where s˜ is a vector of one or more pairwise distinct session channels. The rule says that, after A communicates with B for session initiation with fresh session channels s˜, A and B share s˜ locally (indicated by ν-binding), and the next I is unfolded. The state σ stays as it is since no communication of values takes place.
We have already seen an example of reduction representing communication through a session channel. We now report the the formal rule:
(Comm)	σ ▶ e@A ⇓ v
(σ, A → B : s⟨op, e, x⟩ . I) → (σ[x@B '→ v], I)
The premise of the rule above uses the judgement (called evaluation judgement):
σ ▶ e@A ⇓ v
which says:
Expression e is evaluated into the value v in the A-portion of the state σ.
For example, if σ says x at A stores 3, then we have σ ▶ (x + x)@A ⇓ 6. Thus the expression to be communicated is evaluated in the source part of the state: and the value communicated is assigned in the target part of the state.
The formal rule for assignment is given as:
(Assign)	σ ▶ e@A ⇓ v
(σ, x@A := e . I) → (σ[x@A '→ v], I)
which updates the state at the participant A and unfolds the next interaction.
The rules for conditional assumes, again using the evaluation judgement, that the conditional expression evaluates to either tt (for truth) or ff (for falsity). In the former:
(IfTrue)	σ ▶ e@A ⇓ tt
(σ, if e@A then I else 1I2) → (σ, I1)
Symmetrically, when the condition evaluates to the falsity:
(IfFalse)	σ ▶ e@A ⇓ ff
(σ, if e@A then I else 1I2) → (σ, I2)
The rule for summation is standard:
(Sum)	−
(σ, I1 + I2) → (σ', I1)

The symmetric rule is subsumed by structural congruence which will be introduced later on.
For parallel composition, the rule is defined just by considering interleaving of two components. Thus we define:


(Par)
(σ, I1) → (σ', I' )
(σ, I1 | I2) → (σ', I' | I2)

where we reduce the left-hand side. The symmetric rule is again subsumed by the use of the structural rules we stipulate later.
For restriction we have:
(Res)	(σ, I) → (σ', I')
(σ, (νs˜)I) → (σ', (νs˜)I')
which says restriction does not affect reduction. For recursion, we use the standard unfolding rule.
(Rec)(σ, I[rec X.I/X]) → (σ', I') (σ, rec X.I) → (σ', I')
The rule says that:
If the unfolding of rec X.I, I[rec X.I/X] (which substitutes rec X.I for each free X in I) under σ reduces to I' with the resulting state σ', then rec X.I itself under σ will reach (σ', I').
Finally the inaction 0 does not have any reduction. We also use the following rule, which says that when we reduce we take terms up to a certain equality, following [4,17].
(Struct) I ≡ I''	(σ, I) → (σ, I')	I' ≡ I'''
(σ, I'') → (σ', I''')
where the structural equality ≡ is defined by the following rules:
I ≡ I' (I ≡α I' )
I + I ≡ I, I1 + I2 ≡ I2 + I1, (I1 + I2)+ I3 ≡ I1 + (I2 + I3),
I|0 ≡ I, I1|I2 ≡ I2|I1, (I1|I2)|I3 ≡ I1|(I2|I3),
((νs)I1)|I2 ≡ (νs)(I1|I2) with s /∈ fn(I2))
In the last rule, fn(I) denotes the free names (including variables, channels and session channels) occurring in I. The relation ≡ is the least congruence on terms including the above equations. While the benefit of the use of structural rules in reduction rules is limited in the present context (in comparison with standard process calculi), considering terms up to ≡ is often natural and adds clarity in practice.

Examples of Reduction.
Example 4 (Reduction: Communication) Recall the following term from Example 1:

def
I0	=
{Buyer → Seller : B2Sch⟨QuoteAccept, 100 , x ⟩ . I1 }	+
{Buyer → Seller : B2Sch⟨QuoteReject, xAbortNo, y ⟩ . I2 }
(8)

We infer the reductions of I0. There is one reduction for each branch. For the first summand, we note σ ▶ 100@Buyer ⇓ 100 and infer, in two steps, using (Comm):
(σ, I0) → ... → (σ[x@Seller '→ 100], I1)	(9) Similarly we have the following reduction for the second branch. Assume xAbortNo
stores (say) 28 at Buyer in σ, hence σ ▶ xAbortNo@Buyer ⇓ 28,
(σ, I0) → (σ[y@Seller '→ 28], I2)	(10)
Example 5 (Reduction: Conditional) We now show reduction for Example 2. First we reproduce the term.




'	def
0
if xquote ≤ 1000 @Buyer then
{  Buyer → Seller : B2Sch⟨QuoteAccept, 100 , x ⟩ . I '	}
else
{ Buyer → Seller : B2Sch⟨QuoteReject, xAbortNo, y ⟩ . I ' }


(11)

If we assume σ@Buyer(xquote) = 800 then we can infer by rule (IfTrue):
σ ▶ (800 ≤ 1000)@Buyer ⇓ tt
(σ, I' ) → (σ, Buyer → Seller : B2Sch⟨QuoteAccept, 100 , x ⟩ . I ' )	(12)
0	1
Further applying (Comm) to the resulting configuration, we conclude: (σ, I' ) → (σ, Buyer → Seller : B2Sch⟨QuoteAccept , 100 , x ⟩ . I ' )
0	1
→ (σ[x@Seller '→ 100], I' )
which is the only reduction sequences from (σ, I' ) in this case. Assume on the other hand σ@Buyer(xquote) = 1200. Then we have by rule (IfFalse):


σ ▶ (1200 ≤ 1000)@Buyer ⇓ ff
(σ, I' ) → (σ, Buyer → Seller : B2Sch⟨QuoteReject, x
, y ⟩ . I ' )	(13)

0
Hence in this case we have:
AbortNo	2

(σ, I' ) → (σ, Buyer → Seller : B2Sch⟨QuoteReject, xAbortNo, y ⟩ . I ' )
0	2
→ (σ[y@Seller '→ 28], I2)
which is again the only possible reduction sequence under the assumption.

Example 6 (Reduction: Init, Par and Struct) We next consider Example 3:


J0 = Buyer → Seller : acc(ν Op, Data) .
{Buyer → Seller : Op⟨QuoteAccept, 100 , x ⟩ . 0	|
Buyer → Seller : Data⟨QuoteAccept, wAddress, y ⟩ . 0	}

(14)

Let us denote the two components of the parallel composition with J1 and J2. Then, by (Init), we obtain:
(σ, J0) → (σ, (νOp, Data)(J1 | J2))	(15)
By (Comm) we have: (σ, J1) → (σ[x@Seller '→ 100], 0), hence by (Par) we conclude with:
(σ, J1|J2) → (σ[x@Seller '→ 100], 0|J2)	(16)
For the symmetric case, assume σ@Buyer(wAddress) = adr (where adr is a string standing for an address) Then by (Comm) we have (σ, J2) → (σ[y@Seller '→ adr], 0), hence by (Par) we arrive at:
(σ, J2 | J1) → (σ[y@Seller '→ adr], 0 | J1)	(17) Noting J1 | J2 ≡ J2 | J1, we can now apply ((Struct)) to obtain:
(σ, J1 | J2) → (σ[y@Seller '→ adr], J1)	(18)
Note we also simplified the resulting term. In summary, we have two sequences of reductions up to ≡:
(σ, J0) → (σ, (ν Op, Data)(J1|J2)) → (σ[x@Seller '→ 100], (νData)J2) → (σ', 0) and
(σ, J0) → (σ, (νOp, Data)(J1|J2)) → (σ[y@Seller '→ adr], (νOp)J1) → (σ', 0) where we set σ' d=ef σ[x@Seller '→ 100][y@Seller '→ adr].
Example 7 (Reduction: Recursion) Finally we show an example of recursion re-
duction, taking the example rec X.(x@B := 1.X) before. Noting:


(x@B := 1.X)[rec X.x@B := 1.X/X]	def
x@B := 1 ; rec X.x@B := 1.X

hence we have:
(σ, rec X.x@B := 1.X) → (σ[x@B '→ 1], rec X.x@B := 1.X)
→ (σ[x@B '→ 1], rec X.x@B := 1.X)
→ ....
as expected.

Session Types for the Global Calculus
Syntax of Session Types
As briefly mentioned in §2.1, we use session types [15] as the type structures for the global calculus. In advanced web services and business protocols, the structures of interaction in which a service/participant is engaged in may not be restricted to one-way messages or RPC-like request-replies. This is why the type abstraction of the global calculus needs to capture a complex interaction structure of services, leading to the use of session types. By having structure of interactions explicitly as type abstraction, programmers are encouraged to think the communication-centred programs at a more abstract level than regarding interactions as a collection of unrelated communications, focussing on their high-level structures. The grammar of types follow.
θ ::= bool | int | ... 
α := Σis ↓ opi(θi) . αi | Σis ↑ opi(θi) . αi | α1 | α2 | t | rec t.α | 0

Above θ, θ',... range over value types, which in the present case only include atomic data types. α, α',... are session types. Note session channels s, s',... occur free in session types (this is necessary because of multiple session channels in a single session, cf. [15]). We take | to be commutative and associative, with the identity
0. Recursive types are regarded as regular trees in the standard way [18]. Brief illustration of each construct follows.
Σis ↓ opi(θi) . αi is a branching input type at s, indicating possibilities for receiving any of the operators from {opi} (which should be pairwise distinct) with a value of type θi.
Σis ↑ opi(θi) . αi,a branching output type at s, is the exact dual of the above.
α1 | α2 is a parallel composition of α1 and α2, abstracting parallel composition of two sessions. We demand session channels in α1 and those in α2 are disjoint.
t is a type variable, while rec t.α is a recursive type, where rec t binds free occurrences of t in α. A recursive type represents a session with a loop. We assume each recursion is guarded, i.e., in rec t.α, the type α should be either an input/output type or n-ary parallel composition of input/output types.
0 is the inaction type, indicating termination of a session. 0 is often omitted.
Each time a session occurs at a shared service channel, session channels are freshly generated and exchanged. Thus the interface of a service should indicate a vector of session channels to be exchanged, in addition to how they are used. This is represented by abstract session type, or service type, in which concrete instances of session channels in a session type are abstracted, written: (s˜) α where s˜ is a vector of pairwise distinct session channels which should cover all session channels in α, and α does not contain free type variables. (s˜) binds occurrences of session channels in s˜ in α, which induces the standard alpha-equality.

Before illustrating these types with examples, we introduce a natural notion of duality. The co-type, or dual, of α, written α, is given as follows.

Σisi ↑ opi(θi) . αi = Σisi ↓ opi(θi) . αi	Σisi ↓ opi(θi) . αi = Σisi ↑ opi(θi) . αi

rec t . α = rec t . α	t = t	0 = 0
For example, the co-type of s ↓ QuoteReq(string).0 is s ↑ QuoteReq(string).0, exchanging input and output.
Given a term I, we type I with service/session types in the following way:

Γ ▶ I d Δ

where Γ is a mapping from service channels to service types, and Δ is a mapping from session channels to session types. We call Γ ▶ I d Δ, a typing sequent. A typing sequent Γ ▶ I d Δ says that the usage of service/session channels in I conforms to Γ and Δ, respectively. Such a sequent is derived using typing rules, which construct service/session typings for a term I following the latter’s syntactic structure. We leave the presentation of typing rules to [9], in which we also show that they satisfy the standard properties such as subject reduction and principal typing. Here, in the next subsection, we rather illustrate typing through concrete examples.

Examples of Session Types
Example 8 (Session Type: basics) Consider the following interaction (cf. Example 1), assuming adr and prd are variables of string type, located at both Buyer and Seller.


Buyer → Seller : s1 ⟨QuoteReq, prd , prd ⟩. Seller → Buyer : s2 ⟨QuoteRep, 100 , y ⟩. Buyer → Seller : s1 ⟨Purchase, adr , adr ⟩.0

(19)

The interface which Seller offers (as far as this interaction goes) can be described by the following session type:

s1 ↓ QuoteReq(string). s2 ↑ QuoteRep(int). s1 ↓ Purchase(string). 0	(20) the same interaction can be type-abstracted from the viewpoint of Buyer:
s1 ↑ QuoteReq(string). s2 ↓ QuoteRep(int). s1 ↑ Purchase(string). 0	(21)

which is nothing but the co-type of (20). Now let us add a session initiation to (20):


Buyer → Seller : ch(s1s2).
Buyer → Seller : s1 ⟨QuoteReq, prd , prd ⟩. Seller → Buyer : s2 ⟨QuoteRep, 100 , y ⟩. Buyer → Seller : s1 ⟨QuoteAcc, adr , adr ⟩.0


(22)

Then the service type of Seller at channel sh is given as:
(s1s2) s1 ↓ QuoteReq(string). s2 ↑ QuoteRep(int). s1 ↓ Purchase(string). 0  (23)
which says: firstly, two fresh session channels s1s2 (in this order) are exchanged; then, using these two channels, communication of the represented shape takes place. Thus the service type (23) describes the whole of the behaviour starting from ch, albeit abstractly.
Example 9 (Session Type: branching) Let us refine (19) with branching.


Buyer → Seller : s1 ⟨QuoteReq, prd , prd ⟩.
Seller → Buyer : s2 ⟨QuoteRep, 100 , y ⟩.
⎛ Buyer → Seller : s1 ⟨Purchase, adr , adr ⟩.0 ⎞



(24)

⎜	+	⎟
⎝ Buyer →Seller : s1 ⟨Nothanks⟩.0	⎠

This can be abstracted, from the viewpoint of Seller:


s1 ↓ QuoteReq(string). s2 ↑ QuoteRep(int).
(s1 ↓ Purchase(string).0 + s1 ↓ Nothanks().0)
(25)

Note the sum + in (25) means the inputting party (here Seller) waits with two options, Purchase and Nothanks: on the other hand, the co-type of (25) (seen from Buyer’s side) becomes:


s1 ↑ QuoteReq(string). s2 ↓ QuoteRep(int).
(s1 ↑ Purchase(string).0 + s1 ↑ Nothanks().0)
(26)

in which the sum + in (25) means that the outputting party (here Buyer) may select one of Purchase and Nothanks from the two options.
Example 10 (Session Type: recursion) Consider the following behaviour, in which

B continuously greets A.
rec X.B → A : s⟨Greeting, “hello'', x ⟩. X	(27) We can then abstract this behaviour as, from B’s viewpoint:
rec Y. s ↑ Greetings(string). Y	(28) whereas for A the same interaction is abstracted as:
rec Y. s ↓ Greetings(string). Y	(29)
which states that A repeatedly receives greetings. As a more meaningful recursion, consider the following refinement of (24):
⎛ Buyer → Seller : s1 ⟨QuoteReq, prd , prd ⟩.	⎞
⎜ Seller → Buyer : s2 ⟨QuoteRep, 100 , y ⟩.	⎟

rec X.
⎜ ⎛ Buyer → Seller : s1 ⟨Purchase, adr , adr ⟩.0 ⎞ ⎟
(30)

⎜ ⎜	+	⎟ ⎟
⎝ ⎝ Buyer →Seller : s1 ⟨Nothanks⟩. X	⎠ ⎠
This behaviour, seen from the viewpoint of Seller, can be abstracted as the following session type:

⎛

⎜
rec Y. ⎜
s1 ↓ QuoteReq(string).	⎞
s2 ↑ QuoteRep(int).
⎛ s1 ↓ Purchase(string).0 ⎞ ⎟



(31)

⎜ ⎜	+	⎟ ⎟
⎝ ⎝ s1 ↓ Nothanks().Y	⎠ ⎠
It may be notable that the following conditional has the same session type as (31).





rec X.
⎛ Buyer → Seller : s1 ⟨QuoteReq, prd , prd ⟩.	⎞
⎜ Seller → Buyer : s2 ⟨QuoteRep, 100 , y ⟩.	⎟
⎜ if reasonable(y)@Buyer then	⎟





(32)

⎜
⎜ else
Buyer → Seller : s1 ⟨Purchase, adr , adr ⟩.0 ⎟
⎟

Buyer →Seller : s1 ⟨Nothanks⟩. X
One can further prefix (32) with a session initiation, for example with Buyer →

Seller : ch(s1s2), in which case we obtain the service type for ch:


⎛

⎜
(s1s2) rec Y. ⎜
s1 ↓ QuoteReq(string).	⎞
s2 ↑ QuoteRep(int).
⎛ s1 ↓ Purchase(string).0 ⎞ ⎟




(33)

⎜ ⎜	+	⎟ ⎟
⎝ ⎝ s1 ↓ Nothanks().Y	⎠ ⎠

which says that, after initialisation request exchanging two fresh session channels (designated as s1 and s2), it first waits for a QuoteReq message at s1, to which it replies with QuoteRep via s2, then it waits for two options Purchase and Nothanks at s1: in the former case it finishes this session while in the latter it recurs to the initial state, waiting for another QuoteReq message.

Examples of Typing
Example 11 We conclude the section, by showing how it is possible to type an example: consider the buyer-seller case with the following interaction described in the global calculus.

Buyer → Seller : B2SCh(s) . Buyer → Seller : s⟨RequestForQuote⟩ .
Seller → Buyer : s⟨QuoteResponse, vquote, xquote⟩ .
(Buyer → Seller : s⟨QuoteReject⟩ + Buyer → Seller : s⟨QuoteAcceptance⟩ . Seller → Shipper : S2ShCh(s') .
Seller → Shipper : s'⟨RequestDelDetails, Buyer, xClient⟩ .
Shipper → Seller : s'⟨DeliveryDetails, DD, xDD⟩ .
Seller → Buyer : s⟨DeliveryDetails, xDD, xDD⟩)

Above there are two sessions: the one between the buyer and the seller, and the one between the seller and the shipper. Note that both are initialised by a session “init” operation and we have also included the choice. Another notable thing is that in the last two interactions, the variable xDD is involved three times: the first two times it is indeed the same variable located at the seller and assigned with the delivery details DD, but the third one is another variable located at the buyer which just happen to have the same name, but completely distinguished by the semantics of mini-CDL. But what are the types for channels B2SCh and S2ShCh? It can be verified by the rules in [9] the interactions above can be typed by Δ = B2SCh@Seller(s)[Buyer, Seller] : α · S2ShCh@Shipper(s')[Seller, Shipper] : α'

where
α =s ↑ RequestForQuote() . s ↓ QuoteResponse(QuoteType) .(s ↑ QuoteReject()+
s ↑ QuoteAcceptance() . s ↓ OrderConfirmation() .
s  ↓  DeliveryDetails(DDType))
and α' = s' ↑ RequestDelDetails(PType) . s' ↓ DeliveryDetails(DDType).

A Larger Example and its Process Representation
This section demonstrates the expressiveness of the global calculus with a larger business protocol. The example is an extension of the Buyer-Seller protocol treated in Section 2 and comes from a use case discussed in [23]. After illustration of the protocol, we present the description of the protocol using the global calculus. We also show how this global description can be faithfully projected onto distributed communicating processes, written in a variant of the π-calculus, so that they realise precisely the original behaviour. The presentation of the projection procedure is informal, but it offers a glimpse of how a global description can be uniformly mapped to endpoint processes which faithfully realise the original behaviour.
Informal Description.
There are five participants involved in this protocol:
Buyer (B), Seller (S), Vendor (V ), CreditChecker (CC) and RoyalMail (R).
The purpose of the protocol is for Buyer to ask for a quote of a product to Seller, negotiates the price, and buys the product if its price is cheap enough. Before asking for a quote, Buyer asks CreditChecker whether Seller is credible or not. The negotiation process is done as a loop, which involves not only Buyer and Seller but also Vendor (which only interacts with Seller). When the negotiation is successful, Seller asks CreditChecker if Seller is credible, and if the answer is positive, asks RoyalMail (a shipper) to ship the good. The following illustrates the protocol step by step.
Buyer requests a service chCC for company check to the credit checker Cred- itChecker by sending its name.
At this point CreditChecker can either give a positive or negative answer.
If the answer is negative, the protocol terminates. If, on the other hand, the answer is positive, then the interactions enter the following negotiation loop:
Buyer asks Seller for a quote about product prod;
Seller then asks Vendor for service chV
Seller starts recursion and asks Vendor for a quote about product prod;
Vendor replies with a quote quote;
Seller forwards quote to Buyer increasing it by 10 units (quote+10);
if the quote is reasonable (reasonable(quote + 10)) then:

Buyer sends Seller a confirmation (QuoteOK) together with the credit (cred);
Seller then contacts CreditChecker for checking the credit;
If the credit is good then:
Seller contacts RoyalMail (through the service channel chSh);
Seller sends the delivery address;
RoyalMail sends a confirmation;
Seller forwards confirmation to Buyer;
If the credit is bad:
CreditChecker tells Buyer;
Buyer tells Seller terminating the protocol;
if the quote is not reasonable the protocol goes back to point c;
This concludes the informal presentation of the protocol.
Representation in Global Calculus
We now give the formal description of this protocol using the global calculus. Since the description is long, we divide it into several parts. First we present a basic skeleton of the protocol.
B → CC : chCC (νs) . CC → B : s⟨Ack⟩ .
B → CC : s⟨CompanyCheck, sellerName, compName⟩ .
{	CC → B : s⟨Good⟩ . IGood
4.   +
5.	CC → B : s⟨Bad⟩ . 0	}
In Line 3, IGood represents the interactions which take place after CreditChecker tells
Buyer that the company is good, which is given as:
B → S : chS(νt) . S → B : t⟨Ack⟩ .
B → S : t⟨QuoteReq, prod, prod⟩ .
S → V : chV (νr) . V → S : r⟨Ack⟩ .
rec X . {
S → V : r⟨QuoteReq, prod, prod⟩ .
V → S : r⟨QuoteRes, quote, quote⟩ .
S → B : t⟨QuoteRes, quote + 10, quote⟩ .
if reasonable(quote)@B then
B → S : t⟨QuoteOK, cred, cred⟩ .
S → CC : chCC (νu) .
CC → S : u⟨Ack⟩ .
S → CC : u⟨P ersonalCreditCheck, cred:adr, cred:adr⟩ .
{	CC → S : u⟨Good⟩ . I'

14.	+
CC → S : u⟨Bad⟩ .
S → B : t⟨YourCreditIsBad⟩ . 0	}
else
B → S : t⟨QuoteNotOK⟩ . X	}

Finally I'
in Line 13 above is given as:

S → R : chR(νp) .
R → S : p⟨Ack⟩ .
S → R : p⟨Deliv, adr, adr⟩ .
R → S : p⟨Conf⟩ .
S → B : t⟨Conf⟩ . 0
This concludes the formal representation of the protocol.





Implementation of the Global Protocol

A global description such as above, when deployed, should be realised as commu- nication processes located at each endpoint (participant). We now show how the global description above can be correctly implemented in each location. We shall in- formally use a distributed version of the π-calculus as we show in [9]. In particular, each participant will have a process P built on basic concurrency constructs.
The construct s D Σiopi(xi) . P denotes an input action on the session channel s with operations (options) opi. The received value will be stored in one of the variables xi according to which branch is selected.
Dually, the construct s  op⟨e⟩ . P denotes the action of outputting the value e
on the session channel s with operation op.
The construct ! ch(s˜) . P is the input session initiation. It denotes the action of offering a replicated service ch.

Dually, the construct ch(νs˜) . P is a request for the service ch (session initiation).
The standard constructs if e then P else Q, P | Q, P ⊕ Q and rec X . P denote the the conditional operation, the parallel composition, a generic summation (not for input) and the recursion respectively.
For readability reasons, we will give different threads for each participants which will then be composed in parallel. Similarly to the global case, unimportant parameters in inputs and outputs will be omitted, e.g. s D op stands for s D op(x) for some x.

We start with Buyer’s only thread:


chCC (νs) . s D Ack . s  CompanyCheck⟨sellerName⟩ . s D
{ Good . chS(νt) . t D Ack . t  QuoteReq⟨prod⟩ .
rec X . t D QuoteRes(quote) .
if reasonable(quote) then t  QuoteOK⟨cred⟩ .
t D {YourCreditIsBad + Conf}
else t  QuoteNotOK . X
+
Bad	}


Note this thread starts before the recursion and go through inside the (global) recursion. Thus this local behaviour also contains recursion. The next is a thread of CreditChecker.


! chCC (s) . s  Ack . s D CompanyCheck(compName) .
{ s  Good ⊕ s  Bad }


The symbol ! indicates replication i.e. the service chCC can be called an unbounded number of times. We now have another component of CreditChecker.


! chCC (u) . u  Ack⟨⟩ . u D PersonalCreditCheck(cred:adr) .
{u  Good ⊕ u  Bad }


Note that both processes above do not include the recursion. This is because, in the global description, their sessions are inside a recursion so that they initiate a new instance of a session each time a recursion takes place. Furthermore, the two threads above describe the same service. Thus both interactions should come from the same process. Since, however, they differ in the second action, there should be a choice operation so that both possibilities are given. This results in:


! chCC (u) . u  Ack . u D
{	CompanyCheck(cred:adr) . Pgb + PersonalCreditCheck(cred:adr) . Pgb	}

where Pgb = u  Good ⊕ u  Bad. We now move to the end-point thread of Seller

! chS(t) . t  Ack . t D QuoteReq(prod) . chV (νr) . t D Ack .
rec X . r  QuoteReq⟨prod⟩ . r D QuoteRes(quote) .
t  QuoteRes⟨quote + 10⟩ . t D

{ QuoteOK(cred) . chCC (νu) . u D Ack .
u  PersonalCreditCheck⟨cred:adr⟩ . u D

{Good . chR(νp) . p D Ack .
p  Deliv⟨adr⟩ . p D Conf . t  Conf
+
Bad . t  CreditIsBad }
+
uoteNotOK . X
This thread starts outside of the recursion in the global description and carries through the loop, so that both the recursion and the recursion variable are used as they are, leading to the recursive behaviour of the process. The thread of Vendor follows.
! chV (r) . t  Ack .
rec X . r D QuoteReq(prod) . r  QuoteRes⟨quote⟩ . X
Finally, we give the behaviour of RoyalMail.
! chR(p) . p  Ack . p D Deliv(adr) . p  Conf
A detailed formal analysis of a mapping of global descriptions to their endpoint representations are given in [9].

References
Alur, R., K. Etessami and M. Yannakakis, Realizability and verification of msc graphs, Theoretical Computer Science 331 (2005), pp. 97–114.
Baeten, J., H. van Beek and S. Mauw, Specifying internet applications with DiCons, in: SAC’01 (2001),
pp. 576–584.
Benton, N., L. Cardelli and C. Fournet, Modern concurrency abstractions for C#, ACM Trans. Program. Lang. Syst. 26 (2004), pp. 769–804.
Berry, G. and G. Boudol, The Chemical Abstract Machine, TCS 96 (1992), pp. 217–248.
Bhargavan, K., C. Fournet and A. Gordon, Verified reference implementations of WS-Security protocols, in: WS-FN’06, LNCS, 2006.
Bonelli, E., A. B. Compagnoni and E. L. Gunter, Correspondence assertions for process synchronization in concurrent communications., JFP 15 (2005), pp. 219–247.
Briais, S. and U. Nestmann, A formal semantics for protocol narrations, in: TGC, 2005, pp. 163–181.
Busi, N., R. Gorrieri, C. Guidi, R. Lucchi and G. Zavattaro, Choreography and orchestration conformance for system design, in: Coodination, LNCS 4038, 2006, pp. 63–81.


Carbone, M., K. Honda, N. Yoshida, R. Milner, G. Brown and S. Ross-Talbot, A theoretical basis of communication-centred concurrent programming, To be published by W3C. Available at http://www.dcs.qmul.ac.uk/$\sim$carbonem/cdlpaper/workingnote.pdf (2006).
Dezani-Ciancaglini, M., D. Mostrous, N. Yoshida and S. Drossopoulou, Session Types for Object- Oriented Languages, in: Proceedings of ECOOP’06, LNCS, 2006.
Gay, S. and M. Hole, Subtyping for session types in the pi calculus, Acta Informatica 42 (2005),
pp. 191–225.
Guidi, C., R. Lucchi, G. Zavattaro, N. Busi and R. Gorrieri, Sock: a calculus for service oriented computing, in: ICSOC ’06, LNCS, 2006.
Guttman, J. D., F. J. Thayer and L. D. Zuck, The faithfulness of abstract protocol analysis: message authentication, in: CCS ’01: Proceedings of the 8th ACM conference on Computer and Communications Security (2001), pp. 186–195.
Henriksen, J. G., M. Mukund, K. N. Kumar, M. A. Sohoni and P. S. Thiagarajan, A theory of regular msc languages, Information and Computation 202 (2005), pp. 1–38.
Honda, K., V. Vasconcelos and M. Kubo, Language primitives and type disciplines for structured communication-based programming, in: ESOP’98, LNCS 1381, 1998, pp. 22–138.
Laneve, C. and L. Padovani, Smooth orchestrators, in: FoSSaCS’06, LNCS 3921, 2006, pp. 32–46.
Milner, R., Functions as processes, MSCS 2 (1992), pp. 119–141.
Pierce, B. C., “Types and Programming Languages,” MIT Press, 2002.
Pierce, B. C. and D. N. Turner, Pict: A programming language based on the pi-calculus, in: Proof, Language and Interaction: Essays in Honour of Robin Milner, MIT Press, 2000 .
Takeuchi, K., K. Honda and M. Kubo, An interaction-based language and its typing system, in:
PARLE’94, LNCS 817, 1994, pp. 398–413.
van der Aalst, W., Inheritance of interorganizational workflows: How to agree to disagree without loosing control?, Info. Tech. and Management J. 2 (2002), pp. 195–231.
Vasconcelos, V., A. Ravara and S. J. Gay, Session types for functional multithreading., in: CONCUR’04, LNCS 3170, 2004, pp. 497–511.
W3C WS-CDL Working Group, Web services choreography description language version 1.0,
http://www.w3.org/TR/2004/WD-ws-cdl-10-20040427/  .
