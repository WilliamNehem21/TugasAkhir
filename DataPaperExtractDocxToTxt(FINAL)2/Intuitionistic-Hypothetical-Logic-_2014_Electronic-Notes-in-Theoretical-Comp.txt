Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 300 (2014) 89–103
www.elsevier.com/locate/entcs
Intuitionistic Hypothetical Logic of Proofs
Gabriela Steren1,2
Computer Science Department Universidad de Buenos Aires Argentina
Eduardo Bonelli3
UNQ and CONICET
Argentina

Abstract
We study a term assignment for an intuitonistic fragment of the Logic of Proofs (LP). LP is a refinement of modal logic S4 in which the assertion 2A is replaced by [[s]]A whose intended reading is “s is a proof of A”. We first introduce a natural deduction presentation based on hypothetical judgements and then its term
assignment, which yields a confluent and strongly normalising typed lambda calculus λIHLP. This work is part of an ongoing effort towards reformulating LP in terms of hypothetical reasoning in order to explore its applications in programming languages.
Keywords: Curry-Howard, Logic of Proofs, Lambda Calculus, Programming Languages


Introduction
This paper is part of our ongoing exploration of the applications of Sergei Artemov’s Logic of Proofs LP [2,4] in foundations of programming languages and type theory by means of the Curry-de Bruijn- Howard isomorphism. LP is a refinement of S4 in which 2A is replaced by [[s]]A and whose intended reading is “s is a proof of A”. It has its roots in Provability Logic, and is one possible approach to the formalisation of the BHK interpretation of Intuitionistic Logic given that (1) it realizes all S4 theorems; and (2) is arithmetically sound and complete. One interesting feature of LP is that it is capable of reflecting its own derivations in the sense that if a formula A is provable, then [[s]]A is also provable, where s encodes a derivation of A. The

1 Work partially supported by STIC-AmSud project 12STIC-04 – “Formal Development of Computer Programs and Applications” and Instituto Tecnolo´gico de Buenos Aires (ITBA).
2 Email: gsteren@yahoo.com
3 Email: ebonelli@unq.edu.ar

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.12.013

aforementioned exploration aims at proposing natural deduction presentations of LP and their corresponding term assignment, with the hope of obtaining computational formalisms that cater both for terms and type derivations in a uniﬁed setting.
This work adds to previous results that we have developed [6,10,12]. Here we propose a natural deduction presentation of ILP, an intuitionistic fragment of LP, based on a judgemental analysis of modal logic [15,16,21] which includes the plus proof polynomial constructor of LP and also explore a variant of the term assignment of [6]. Judgements of ILP take the form Θ; Γ ▶ A | s (read “A is true with proof witness s under truth hypotheses Θ and validity hypotheses Γ”). Their meaning is given by appropriate axiom and inference schemes.
The paper is structured as follows. Sec. 2 introduces IHLP, a natural deduction presentation of ILP. We then study the correspondence with ILP in Sec. 3. Sec. 4 presents the term assignment, λIHLP, and then shows subject reduction, strong nor- malisation and confluence. Sec. 5 discusses related work. Finally, we conclude and suggest avenues for further research. For further details please consult [25].
IHLP
Formulae and proof witnesses of IHLP are given by the following grammar:
A, B ::= P | A⊃B | A ∧ B | A ∨ B | [[s]]A
r, s, t ::= xA | vA | λxA.s | s · t | ⟨s, t⟩| fst(s) | snd(s)
| inl(s) | inr(s) | case r [xA].s [yB].t | !s | LetB vA be r, s in t | s + t
where P, Q,... ranges over a set of propositional variables, xA, yA, zA,... over a set of truth variables and uA, vA,... over a set of validity variables. A formula may either be a propositional variable, an implication A ⊃ B, a conjunction A ∧ B, a disjunction A ∨ B or a modality [s]]A. A proof witness may either be a truth or validity variable, an abstraction λxA.s, an application s · t,a pair ⟨s, t⟩, projections fst(s) and snd(s), injections inl(s) and inr(s), a case case r [xA].s [yB].t, a bang !s, an unbox LetB vA be r, s in t or a plus s + t. We write A{xA:= r} (resp. A{vA:= r}) for the capture-avoiding substitution of truth (resp. validity) variables for proof witnesses in formulae; similarly for substitution of truth/validity variables in proof terms s{xA:= t} (resp. s{vA:= t}).
Free variables of validity FVV(s) and truth FVT(s) over a proof witness s are as expected. Some sample defining clauses are illustrated below, where FVT(t, s) abbreviates FVT(t) ∪ FVT(s). These definitions extend in the obvious way to for- mulae.

FVT(xA)	def
FVT(vA)	def
FVT(!s)	def
{xA}
∅
FVT(s)
FVV(xA)	def
FVV(vA)	def
FVV(!s)	def
∅
{vA}
FVV(s)

FVT
(LetB vA
def
be u,s in t) =	FVT(t, s)
FVV(LetB vA
def
be u,s in t) = (FVV(t)	v
}) ∪ FVV(s)

FVT(λxA.s)	defFVT(s) \ {xA}
FVV(λxA.s)	def
FVV(s)

Judgements take the form Θ; Γ ▶ A | s with validity context Θ =
v1A1 ,..., vmAm , truth context Γ = x1B1 ,..., xnBn , A a formula, and s a proof witness. We write “·” for empty contexts. In a judgement, in addition to the





Θ; Γ, xA ▶ A | xA
Var


Θ, vA;Γ ▶ A | vA
VarM



Θ; Γ, xA ▶ B | s
⊃ I
Θ; Γ ▶ A ⊃ B | λxA.s
Θ; Γ ▶ A ⊃ B | s Θ; Γ ▶ A | t
⊃ E
Θ; Γ ▶ B | s · t



Θ; Γ ▶ A | s Θ; Γ ▶ B | t
∧I
Θ; Γ ▶ A ∧ B | ⟨s, t⟩
Θ; Γ ▶ A ∧ B | s


Θ; Γ ▶ A | fst(s)

∧E1
Θ; Γ ▶ A ∧ B | s


Θ; Γ ▶ B | snd(s)

∧E2



Θ; Γ ▶ A | s

Θ; Γ ▶ A ∨ B | inl(s)

∨I1
Θ; Γ ▶ B | s

Θ; Γ ▶ A ∨ B | inr(s)

∨I2

Θ; Γ ▶ A ∨ B | r  Θ; Γ, xA ▶ C | s  Θ; Γ, yB ▶ C | t
∨E
Θ; Γ ▶ C | case r [xA].s [yB].t


Θ; ·▶ A | s  Θ; ·▶ s ≡ t : A

Θ; Γ ▶ [[t]]A | !t
Θ; Γ ▶ [[r]]A | s Θ, vA;Γ ▶ C | t
2I		 2E
Θ; Γ ▶ C{vA:= r}| LetB vA be r, s in t



Θ; Γ ▶ A | s


Θ; Γ ▶ A | s + t

PlusL
Θ; Γ ▶ A | t


Θ; Γ ▶ A | s + t

PlusR

Fig. 1. Axiom and inference schemes of IHLP (1/2)


requirement that the vAi and xBi be distinct, we also require that they be fresh (i.e.
i	i
that they do not occur in the A1,..., Am and B1,..., Bn).
A judgement is said to be derivable if it may be inferred using the axiom and inference schemes of Fig. 1. Note that if a derivation π of a judgement Θ; Γ ▶ A | s is obtained using these axioms and inference schemes, then s does not necessarily determine π (due to 2I, PlusL and PlusR). Most of these axioms and inference schemes are self-explanatory. For example, the axiom VarM states that if A is assumed valid, then we can conclude that A is true. The salient schemes are 2I and those for plus. The former is a generalization of the following simpler one, which is a natural explicit counterpart of the standard introduction scheme for the 2 modality in the judgemental setting [15,16,21].
Θ; ·▶ A | s



Θ; Γ ▶ [[s]]A | !s
2I0

Although sound, 2I0 is not satisfactory from the point of view of normalisation of derivations. For example, consider the derivation on the left in Fig. 2, where π1,2 are derivations of Θ; xA ▶ B | s and Θ; · ▶ A | t, resp. and π3 is obtained from an appropriate substitution principle. A normalisation step would produce the one on the right. However, this derivation is not valid since the proof witness in the hypothesis of 2I0 must be identical to the one in the argument of “!” in the judgement in the conclusion. Indeed this is not the case, since on one hand we have s{xA:= t}, while on the other we have (λxA.s) · t. The introduction scheme 2I for the modality remedies this situation by obtaining the derivation:



π1
Θ; xA ▶ B | s
⊃ I
Θ; ·▶ A ⊃ B | λxA.s



π2
Θ; ·▶ A | t	→
⊃ E


π3
Θ; ·▶ B | s{xA:= t}




2I0

Θ; ·▶ B | Θ; ·▶ B | (λxA.s) · t

Θ; Γ ▶ [[(λxA.s) · t]]B | !((λxA.s) · t)
2I0
Θ; Γ ▶ [[(λxA.s) · t]]B | !((λxA.s) · t)

Fig. 2. Failure of SR in the presence of 2I0


Θ; Γ, xA ▶ B | s  Θ; Γ ▶ A | t


Θ; Γ ▶ (λxA.s) · t ≡ s{xA := t} : B

Eq-β



Θ; ·▶ A | s Θ, vA;Γ ▶ C | t

Θ; Γ ▶ LetB vA be s, (!s) in t ≡ t{vA := s} : C{vA := s}

Eq-γ



Θ; Γ ▶ A ⊃ B | r Θ; Γ ▶ A | t


Θ; Γ ▶ (r + s) · t ≡ (r · t)+ s : B

Eq-ψL
Θ; Γ ▶ A ⊃ B | s Θ; Γ ▶ A | t


Θ; Γ ▶ (r + s) · t ≡ r · (s + t): B

Eq-ψR



Θ; Γ ▶ [[r]]A | s  Θ, vA;Γ ▶ C | q

Θ; Γ ▶ LetB vA be r, (s + t) in q ≡ LetB vA be r, s in q + t : C{vA := r}

Θ; Γ ▶ [[r]]A | t Θ, vA;Γ ▶ C | q

Θ; Γ ▶ LetB vA be r, (s + t) in q ≡ s + LetB vA be r, t in q : C{vA := r}

Eq-φL



Eq-φR


Fig. 3. Axiom and inference schemes of IHLP (2/2)
π3

Θ; ·▶ B | s{xA:= t}	Θ; ·▶ s{xA:= t}≡ (λxA.s) · t : A
2I
Θ; Γ ▶ [[(λxA.s) · t]]B | !((λxA.s) · t)
A sample of the axiom and inference schemes defining the judgement Θ; Γ ▶ s≡ t : A are depicted in Fig. 3 (see [25] for the full set).  These schemes are closely tied to the normalisation relation on derivations. Indeed, since LP is capable of reflecting its own derivations and these derivations are equated by normalisation, the induced relation between derivations must also be formalised in the logic itself. It should be noted that LP was originally formulated in a Hilbert-style presentation, which does not allow such an observation to be made.
Regarding the schemes for plus, they are a consequence of the fact that LP is a multi-conclusion logic in the sense that a proof witness may prove more than one formula. Indeed, note that the following holds in LP: [[s]]A ∧ [[t]]B ⊃ [[s + t]]A ∧ [[s + t]]B and hence s + t proves both A and B. In the particular case that A and B coincide, s + t denotes two proofs of A. This non-deterministic conjunction of proofs is necessary to be able to realize all theorems of IS4 (cf. Sec 5). By realize [4, Def.9.2] we mean decorate the boxes of IS4 theorems so that the resulting formulae are provable in ILP. As an example, we show how the IS4 theorem 2A∨ 2B ⊃ 2(A∨B) may be realized in IHLP as [s]]A ∨ [[t]]B ⊃ [[inl(s)+ inr(t)]](A ∨ B), for any s and t.

Example 2.1 Let Θ1 d=ef vA, Θ2 d=ef uB, Γ d=ef z[[s]]A∨[[t]]B Γ1 d=ef z[[s]]A∨[[t]]B , x[[s]]A and Γ2 d=ef z[[s]]A∨[[t]]B, y[[t]]B in the following two derivations π1,2:
Θ1; ·▶ A | vA

Θ1; ·▶ A ∨ B | inl(vA)



Θ1; ·▶ A ∨ B | inl(vA)+ inr(t)
PlusL
2I

·; Γ1 ▶ [[s]]A | x[[s]]A
Θ1; Γ1 ▶ [[inl(vA)+ inr(t)]](A ∨ B) | !(inl(vA)+ inr(t))
2E

·; Γ1 ▶ [[inl(s)+ inr(t)]](A ∨ B) | LetB vA be s, x[[s]]A in !(inl(vA)+ inr(t))
Θ2; ·▶ B | uB



Θ2; ·▶ A ∨ B | inr(uB)
∨I2

PlusR


·; Γ2 ▶ [[t]]B | y[[s]]B
Θ2; ·▶ A ∨ B | inl(s)+ inr(uB)
2I
Θ2; Γ2 ▶ [[inl(s)+ inr(uB)]](A ∨ B) | !(inl(s)+ inr(uB))
2E

·; Γ2 ▶ [[inl(s)+ inr(t)]](A ∨ B) | LetB vA be t, y[[s]]B in !(inl(s)+ inr(uB))
Finally, for π3 below consider the definitions
r1 d=ef LetB vA be s, x[[s]]A in !(inl(vA)+ inr(t)),
r2 d=ef LetB uB be t, y[[t]]B in !(inl(s)+ inr(uB)), and
r3 d=ef case z[[s]]A∨[[t]]B [xA].r1 [yB].r2.
π1	π2
·;Γ ▶[[s]]A∨[[t]]B | z[[s]]A∨[[t]]B ·; Γ1▶[[inl(s)+inr(t)]](A∨B) | r1 ·; Γ2 ▶ [[inl(s)+inr(t)]](A∨B) | r2
∨E
·;Γ ▶ [[inl(s)+inr(t)]](A∨B) | r3
Note that the use of PlusL in π1 and PlusR in π2 is required in order to concate- nate the two alternative proofs of A ∨ B into a unique non-deterministic proof, and allow the application of ∨E in π3.
Remark 2.2 One may wonder whether, for the implicative fragment, the plus may be dispensed with while still maintaining realization of all S4 theorems. This is the case if, in the terminology of LP, so called non-injective specification sets and non- normal realizations are allowed (see [18] and also [5, Sec.11.2]).
The following basic results are proved by induction on the derivation.
Lemma 2.3
(Weakening) If the judgement Θ; Γ ▶ A | s is derivable, then so is Θ ∪ Θj;Γ ∪ Γj ▶
A | s.
(Strengthening) If the judgement Θ; Γ ▶ A | s is derivable, then so is the judgement
Θ ∩ FVV(s); Γ ∩ FVT(s) ▶ A | s.
(Substitution of Truth Variables) If Θ; Γ, xA ▶ B | s and Θ; Γ ▶ A | t are derivable, then so is Θ; Γ ▶ B | s{xA := t}.
(Substitution of Validity Variables) If Θ, vA;Γ ▶ B | s and Θ; · ▶ A | t are deriv- able, then so is Θ; Γ ▶ B{vA := t}| s{vA := t}.

Relating ILP and IHLP
This section addresses the relation between ILP and IHLP. We begin by recalling the definition of ILP and then state the required results, restricting our attention to the implicative fragment. Then we show that all ILP theorems are derivable in IHLP (Prop. 3.1) and conversely that all judgements derivable in IHLP may be translated to judgements derivable in ILP (Prop. 3.9).
Assume given a set of proof constants C and c ∈ C. The formulae of ILP are those of IHLP except that the proof witnesses encode Hilbert-style proofs and are called proof polynomials [2,4]:
s, t ::= xA | c | s · t | !s | s + t
The axioms and inference schemes of ILP are as follows, where a context Γ is a set of hypotheses of the form xA and we assume 4 that C includes at least one constant for each instance of an axiom scheme A0-A5:
A0. Axioms of minimal propositional logic in the language of ILP.
A1. [[t]]A ⊃A
A2. [[s]](A ⊃B) ⊃ ([[t]]A ⊃ [[s · t]]B)
A3. [[t]]A ⊃ [[!t]][[t]]A
A4. [[s]]A ⊃ [[s + t]]A
A5. [[t]]A ⊃ [[s + t]]A
R1. Γ ▶ A⊃B and Γ ▶ A implies Γ ▶ B. (MP )
R2. If A is an axiom A0-A5, and c ∈ C corresponds to A, then Γ ▶ [[c]]A. (Neces- sitation)
The translation • from ILP formulae and proof polynomials to IHLP formulae and proof witnesses is simply the structure preserving mapping that replaces all occurrences of proof constants by IHLP proof witnesses that prove the corresponding axioms (cf. [25]). Some sample defining clauses are:

A0
A,B


A1
t,A


A2
s,t,A,B


A3
s,A


A4
s,t,A
d=ef (λxA.λyB.x)
d=ef λx[[t]]A.LetB vA be t,x in v
d=ef λx[[s]]A⊃B.λy[[t]]A.LetB vA be t,y in LetB wA⊃B be s,x in !(w · v)
d=ef λx[[s]]A.LetB vA be s, x[[s]]A in !!vA
d=ef λx[[s]]A.LetB vA be s,x in !(v + t)



It extends naturally to contexts of hypotheses Γ d=ef {xA s.t. xA ∈ Γ}.
Proposition 3.1 If Γ ▶ F is derivable in ILP, then so is ·; Γ  ▶ F | s in IHLP for some proof witness s.

4 More general assumptions are possible. See [2,4].

Remark 3.2 In PlusL, no requirements on the truth or validity variables of t are assumed in relation to the contexts Θ and Γ. An alternative inference scheme for PlusL (and similarly for PlusR) might be:
Θ; Γ ▶ A | s	FVV(t) ⊆ Θ	FVT(s) ⊆ Γ

Θ; Γ ▶ A | s + t
PlusL

However, this scheme does not allow the proof of proposition 3.1 to go through in the case of axiom A4, since no restriction is a priori placed on t in that axiom, and 2I requires that there be no truth dependencies. It may be possible to retain the alternative scheme proposed above, by drawing ideas from Contextual Modal Type Theory [19].
Suppose Γ is the context {xA1 ,..., xAn } and s = s1,... .sn. Then we write [s]]Γ
1	n
for the context {x[[s1]]A1 ,..., x[[sn]]An }.
1	n
Definition 3.3 Let π be a derivation in ILP of [s]]Γ ▶ F . The extracted witness of π, denoted r below, is defined by induction on the length n of π. Suppose that n = 1. Then either F is an instance of an axiom or is a hypothesis in Γ. In the former we analyse each case:

F = A ⊃ B ⊃ A or F = (A ⊃ B ⊃ C) ⊃ (A ⊃ B) ⊃ A ⊃ C, then r d=ef
A,B or

def A0
A,B,C
, resp.

F = [[t]]A ⊃A, then r d=ef cA1 .
F = [[s]](A ⊃B) ⊃ ([[t]]A ⊃ [[s · t]]B), then r d=ef cA2	.
F = [[t]]A ⊃ [[!t]][[t]]A, then r d=ef cA3 .
F = [[s]]A ⊃ [[s + t]]A, then r d=ef cA4 .
F = [[t]]A ⊃ [[s + t]]A, then r d=ef cA5 .
In the latter case (i.e. F is a hypothesis, say [s]]B in [s]]Γ), we set r d=ef!s. For the inductive case, we consider each possible case for the last step:
It is an axiom or a hypothesis, then we proceed as above.
F is obtained from formulae F1,2 using MP. Let r1,2 be the witnesses extracted from the derivations ending in F1,2. Set r d=ef r1 · r2.
F is obtained from an application of Necessitation: F = [[c]]F1, where F1 is an instance of an axiom A. Then we set r d=ef!cA.
The following result, proved by induction on [s]]Γ ▶ A, states that ILP can internalise its own derivations.
Lemma 3.4 (Internalisation) Suppose [[s]]Γ ▶ A is a derivable judgement in ILP with a derivation π. Then [[s]]Γ ▶ [[r]]A is derivable, where r is the proof witness extracted from π.

Let us write π(Γ ▶ A) to denote that π is an ILP-derivation of Γ ▶ A. The following result shows how the deduction lemma can be internalized. Its proof relies on a lemma called the Stripping Lemma, which is stated below.
Lemma 3.5 (λ-Abstraction) If [[u]]Γ, y[[xA]]A ▶ [[s(u, xA)]]B is derivable and
xA ∈/ Γ, B, then there exists tA>B([[u]]Γ) such that [[u]]Γ ▶ [[tA>B([[u]]Γ)]](A ⊃B),
λ	λ
and tA>B([[u]]Γ) is an extracted witness of A⊃B in [[u]]Γ.
Lemma 3.6 (Stripping) Suppose π is an ILP-derivation of Γ, x[[yA]]A ▶ B and
yA ∈/ Γ. Then there is a derivation of Γ, yA ▶ Bj, where Bj results from B, by
replacing all occurrences of [[t]]A by A for every proof term t containing yA (including constants for instances of axioms containing yA).
One last result shall be required for the proof of our main result (Prop. 3.9).

Lemma 3.7 (Substitution) Γ ▶ [[s]]A and Γ, y[[xA]]A ▶ B and xA ∈/
Γ ▶ B{xA := s}.
Γ implies

A proof witness s is provable if for some Θ, Γ and A, the judgement Θ; Γ ▶ A | s is derivable. The translation from IHLP formulae and proof witnesses to ILP formulae and proof polynomials is as follows, where cA1 is the proof constant denoting any instance of A1:
P ٨ d=ef P

(A⊃B)٨ d=ef A٨⊃B٨
[[s٨]]A٨,	if s is provable
([[s]]A) =
⎩ [[cA1·cA1]]A٨, if s is not provable
xA٨d=ef xAs
vA٨d=ef vAs
(s+t)٨d=ef s٨+t٨
(s · t)٨d=ef s٨ · t٨
(!s)٨d=ef !(s٨)

A	٨ def ٨	As	٨

(LetB v
be r, s in t) = t {v	:= r }

A	٨ def
As>Bs	٨	٨	A

(λx
.s)
= tλ	(Θ
∪ Γ ) if ∃Θ, Γ s.t. Θ; Γ ▶A⊃B |λx .s derivable
·٨ d=ef ·

A ٨ def	٨
As	٨

(Θ,v  )	= Θ , [[v
]]A

A ٨ def	٨
As	٨

(Γ,x  )	= Γ , [[x
]]A

(Θ; Γ ▶ A | s)٨ d=ef Θ٨ ∪ Γ٨ ▶ [[s٨]]A٨
Remark 3.8 Sometimes there is more than one possible translation for a proof witness or a formula (for instance, λxA.(yB + zB) and [[λxA.(yB + zB)]]A ⊃ B). This happens only when the proof witness in question, or some witness within the formula, contains abstractions. By Internalization, if Θ٨ ∪ Γ٨ ▶ A٨ ⊃ B٨ is derivable, then any extracted witness t of A٨ ⊃B٨ in Θ٨ ∪ Γ٨ will suffice to derive Θ٨ ∪ Γ٨ ▶ [[t]]A٨ ⊃ B٨. This means that t can be chosen freely among all possible extracted witnesses. So, whenever a formula or proof witness appears more than once within a derivation and multiple translations exist for it, it is always possible

to use the same translation in all cases by choosing the extracted witnesses in the same way. If different contexts have been used to obtain the formula/proof witness in each case, we can use Weakening to make the contexts coincide (by taking the union of the contexts used in all cases).

Proposition 3.9 For every derivable judgement Θ; Γ ▶ A | s in IHLP, the ILP- judgement Θ٨ ∪ Γ٨ ▶ [[s٨]]A٨ is derivable in ILP.
Corollary 3.10 If ·; · ▶ A | s is derivable in IHLP, then both · ▶ [[s٨]]A٨ and · ▶ A٨
are derivable in ILP.

λIHLP – Syntax and Semantics
We study a term assignment for IHLP, dubbed λIHLP, together with the reduction rules over the set of terms which mimic normalisation of derivations in IHLP and address subject reduction, strong normalisation (SN) and confluence.
The set of terms for IHLP is defined as follows:
M, N ::= xA | vA | (λxA.M B)A>B | (M A>BNA)B | (⟨M, N⟩)A∧B | fst(M A∧B)A
|  snd(M A∧B)B | inl(M )A∨B | inr(M )A∨B | (case M [xA].P [yB].Q)C
| (!M A)[[s]]A | (LetB vA be r, M A in N B)B{vA:=r}
| (M A+L s)A | (s+R N B)B
Free variables of validity and truth for terms are defined analogously to those for proof witnesses. Type decorations are often omitted where it is safe. To the already introduced notions of substitution we add substitution of truth/validity variables in terms by proof witnesses/terms: M B{aA := NA} and M B{vA := NA}. A typing judgement has the form Θ; Γ ▶ M A | s. The typing rules in Fig. 4 (obtained by assigning terms to the axiom and inference schemes of IHLP) define when a typing judgement is derivable. The following example term of type [s]]A ∨ [[t]]B ⊃ [[inl(s)+ inr(t)]](A ∨ B) illustrates the term assigned to the derivation of Exm. 2.1:
λz[[s]]A∨[[t]]B .case z[[s]]A∨[[t]]B [x[[s]]A].LetB vA be s, x[[s]]A in !(inl(vA)+ inr(t))
[y[[t]]B].LetB uB be t, y[[t]]B in !(inl(s)+ inr(uB))

Remark 4.1 Also in λIHLP (as already mentioned for IHLP), terms do not deter- mine complete derivations due to the 2I typing rule. For variations where this property does hold, see the discussion in Sec. 5.

λIHLP-reduction is defined as the compatible closure of the following two groups of reduction rules. The first set of rules, the principal rules, arises from the principal cases of normalisation of derivations.





Θ; Γ, xA ▶ xA | xA
T-Var


Θ, vA;Γ ▶ vA | vA
T-VarM



Θ; Γ, xA ▶ M B | s

Θ; Γ ▶ (λxA.M)A⊃B | λxA.s

T- > I
Θ; Γ ▶ M A⊃B | s Θ; Γ ▶ N A | t

Θ; Γ ▶ (MN)B | s · t

T- > E



Θ; Γ ▶ M A | s Θ; Γ ▶ N B | t

Θ; Γ ▶ ⟨M, N ⟩A∧B | ⟨s, t⟩

T-∧I
Θ; Γ ▶ M A∧B | s

Θ; Γ ▶ fst(M)A | fst(s)

T-∧E1
Θ; Γ ▶ M A∧B | s

Θ; Γ ▶ snd(M)B | snd(s)

T-∧E2



Θ; Γ ▶ M A | s

Θ; Γ ▶ inl(M)A∨B | inl(s)

T-∨I1
Θ; Γ ▶ M B | s

Θ; Γ ▶ inr(M)A∨B | inr(s)

T-∨I2



Θ; Γ ▶ M A∨B |r Θ; Γ, xA ▶ P C |s Θ; Γ, yB ▶ QC | t

Θ; Γ ▶ (case M [xA].P [yB].Q)C | case r [xA].s [yB].t

T-∨E



Θ; ·▶ M A | s  Θ; ·▶ s ≡ t : A


Θ; Γ ▶ (!M)[[t]]A | !t

T-2I
Θ; Γ ▶ M [[r]]A | s Θ, vA;Γ ▶ N C | t
T-2E
Θ; Γ ▶ (LetB vA be r, M in N)C{vA:=r} | LetB vA be r, s in t



Θ; Γ ▶ M A | s


Θ; Γ ▶ (M +L t)A | s + t

T-PlusL
Θ; Γ ▶ N B | t


Θ; Γ ▶ (s+R N)B | s + t

T-PlusR

Fig. 4. Typing schemes

β :  (λxA.M B)NA	→ M B{xA := NA}
β2 : LetB vA be r, (!NA)[[t]]A in M B	→ M B{vA := NA} ρ1 : fst(⟨M A,N B⟩)	→ M A
ρ2 : snd(⟨M A,N B⟩)	→ N B
δL : case inl(M A)A∨B [xA].P C [yB].QC → P C{xA := M A}
δR : case inr(M B)A∨B [xA].P C [yB].QC → QC{yB := M B}
The second set of rules, the permutative rules, arise from the permutative cases of normalisation. They simply permute all term constructs that encode an instance of an elimination scheme with the plus.

ψL: (M A>B +L t)A>BNA	→ (M A>BNA)B +L t
ψR: (s+R M A>B)A>BNA	→ s+R (M A>BNA)B
φ : LetB vA be r, (M [[r]]A+ t) in N B	→ (LetB vA be r, M in N B)B{vA:=rA} + t

φR: LetB vA be r, (s+R
M [[r]]A) in N B	→ s+R
(LetB vA be r, M in N B)B{vA:=rA}

πL : fst((M A∧B +L s)A∧B)A	→ (fst(M A∧B)A+L s)A
πR: fst((s+R M A∧B)A∧B)A	→ (s+R fst(M A∧B)A)A
σL : snd((M A∧B +L s)A∧B)B	→ (snd(M A∧B)B +L s)B
σR: snd((s+R M A∧B)A∧B)B	→ (s+R snd(M A∧B)B)B
κL: case (MA∨B+L s)A∨B [xA].P C [yB].QC → (case M A∨B [xA].P C [yB].QC)C +L s κR: case (s+RMA∨B)A∨B [xA].P C [yB].QC→ s+R (case M A∨B [xA].P C [yB].QC)C

The first property we address is subject reduction.
Lemma 4.2 (Subject Reduction) If Θ; Γ ▶ M B | s is derivable and M B → N B′ , then Bj = B and Θ; Γ ▶ N B | sj is derivable for some witness sj such that Θ; Γ ▶ s≡sj : B.
It would be tempting to expect that, Θ; Γ ▶ M B | s is derivable and M B → N B, then Θ; Γ ▶ N B | s should also be derivable. However, this is not the case. For instance, ·; · ▶ ((λxA>A.x)λyA.y)A>A | (λxA>A.x) · λyA.y is derivable, but ·; · ▶ (λyA.y)A>A | (λxA>A.x) · λyA.y is not.
However, the above result holds for terms having a ! as their outermost operator.
Corollary 4.3 If Θ; Γ ▶ (!MB)A|t is derivable and MB → NB, then Θ; Γ ▶ (!N B)A | t
is derivable.
The above result gains significance in a programming setting where proof wit- nesses are used as certificates (see for example [12]), and all code must be certified in order to be executed. In this case, programs can be closed by an outer !, and thus full subject reduction is achieved.
Regarding strong normalisation, we define a mapping from λIHLP-terms into terms of the simply typed lambda calculus λ1,×,+ (1 denotes the unit type) that preserves certain reduction properties. The result then follows from the fact that λ1,×,+ is strongly normalising [22].
The mapping ⟨|· |⟩, associates types (formulae) and terms (proofs) in λIHLP with types and terms in λ1,×,+. It preserves the structure of formulae except in the case of the modal type [s]]A which is mapped to a functional type whose domain is the unit type 1 and whose co-domain is the mapping of A (i.e. 1 ⊃ ⟨|A|⟩). Both truth and validity variables are translated to the term variables of λ1,×,+. See [25] for full details.
Lemma 4.4 (⟨| • |⟩ preserves typability) If Θ; Γ ▶ M A | s is derivable in IHLP, then ⟨|M |⟩ : ⟨|Θ|⟩ ∪ ⟨|Γ|⟩ ▶ ⟨|A|⟩ is derivable in λ1,×,+.
Lemma 4.5 (⟨| • |⟩ commutes with substitution of truth variables)
For all λIHLP-terms M, N, for every truth variable xA:
⟨|M |⟩{x⟨|A|⟩ := ⟨|N |⟩} = ⟨|M {xA := N}|⟩.
Although ⟨| • |⟩ does not commute with substitution of validity variables, the following result suffices for our purposes.
Lemma 4.6 For all λIHLP-terms M, N, for every validity variable vA and every truth variable y1 /∈ FVT(⟨|N |⟩): ⟨|M |⟩{x1>⟨|A|⟩:= λy1.⟨|N |⟩}−−→→ ⟨|M {vA := N}|⟩.
v	β
Lemma 4.7 If M → N in IHLP without the use of permutative rules, then
⟨|M |⟩ →+ ⟨|N |⟩ in λ1,×,+.
Lemma 4.8 If M → N in IHLP using only permutative rules, then ⟨|M |⟩ = ⟨|N |⟩.
By means of the following polynomial interpretation (·)A in N≥2, using the standard order for natural numbers, we can show SN of permutative reduction:

xB = vB d=ef 2
A	A
(M C>B N A)B d=ef M C>B × N A
A	A	A
(λxA.M B)A>B d=ef 2 × M B
A	A
⟨M, N⟩)A∧B d=ef MA + NA
fst(M )A = snd(M )A d=ef 2 × MA
A	A
inl(M )A∨B = inr(M )A∨B d=ef MA
A	A
(case M [xA].P [yB].Q)C d=ef 2 × MA + PA + QA
(!M B)[[s]]B d=ef 1 + M B
A	A
(LetB vC be r, M in N B)B{vC :=r} d=ef N B × M [[r]]B +1 
A	A	A

(M B +
t)B d=ef 2 × M B +2 

L  A	A
(s+ M B)B d=ef 2 × M B +2 
R	A	A
Lemma 4.9 Permutative reduction is SN.
We can now obtain SN for λIHLP.
Proposition 4.10 Every typable IHLP-term is SN.
Proof. By contradiction. Assume that there is an infinite reduction sequence start- ing from a typable λIHLP-term M0. We will distinguish between principal reductions (→B ) and permutative reductions (→P ) within this sequence.
Since, by Lemma 4.9, permutative reduction is SN, our sequence must contain an infinite number of principal reduction steps. Between any two principal steps, there may be 0 or more permutative steps (always a finite number). Therefore, the

reduction sequence has the form: M0 −−→P→M j →B
M1 −−→P→M j →B
M2 −−→P→M j →B
· · ·

Additionally, by Lemma 4.8, ⟨|Mi|⟩ = ⟨|M j|⟩ for every i. Also, by Lemma 4.7, we know that for every i ⟨|Mi|⟩ →+ ⟨|Mi+1|⟩ in λ1,×,+. We can therefore construct an infinite λ1,×,+-reduction sequence: ⟨|M0|⟩ →+ ⟨|M1|⟩ →+ ⟨|M2|⟩ →+ ··· .
However, M0 is typable in λIHLP and, by Lemma 4.2, so is every Mi. Since the mapping preserves typability (Lemma 4.4), then we have an infinite reduction sequence of typable λ1,×,+-terms. This is an absurd, since reduction of typable λ1,×,+-terms is SN.	2
Finally, since λIHLP is an orthogonal higher-order rewrite system (it has no crit- ical pairs) and is left linear, it is confluent. This follows from standard results in higher-order rewriting [20].
Discussion and Related Work
LP through the Curry-de Bruijn-Howard looking glass has already suggested some interesting programming idioms. For example, in [6] a lambda calculus where the

reduction history is part of the term is introduced. The following scheme is used to recover subject reduction (which fails for the naive scheme as discussed in Sec. 2), e encoding the derivation of the judgement Θ; Γ ▶ s≡t : A|e:
Θ; Γ ▶ M A | s	Θ; Γ ▶ s≡t : A|e
Eq
Θ; Γ ▶ e D M A | s
Strong normalisation is deduced for the resulting term assignment λI from weak- normalisation using techniques from higher-order rewriting. Also, a Church-Rosser theorem yields confluence of λI. Note that since terms carry information on how a result is computed (very much in line with L´evy labels in rewriting), the CR result may be considered a strengthening of the standard CR result of the typed lambda calculus.
In [10] the history or computation trail is allowed to be inspected by introducing trail variables; this permits the calculus to model history-based access control [1] and history-based information flow [9]. In that work the following term assignment for 2I is proposed, where Δ is a set of trail variables (affine variables that may be read at most once for the purposes of inspecting computation trails):
Θ; Δ; ·▶ M A | s	Θ; Δ; ·▶ s≡t : A|e
2I
Θ; Δj;Γ ▶ (!ΔM )[[t]]A | !t
A term of the form !ΔM operates as an audited computation unit, where all com- putation is audited and locally scoped within M .
Also, in [12] by interpreting 2A as mobile code of type A, LP suggests a calculus of certiﬁed mobile units which enriches mobile code with certificates (representing type derivations). Such units take the form boxs M , s being the certificate and M the executable. Composition of certified mobile units allows one to build mobile code out of other pieces of mobile code together with certificates that are also composed out of other certificates. For example, the term
• ◦	• ◦	• •
λa.λb.unpack a to ⟨u, u⟩ in (unpack b to ⟨v, v⟩ in (box ◦ ◦ u v))
u·v
•
reads as follows: “Given a mobile unit a and a mobile unit b, extract code v and
◦	•	◦
certificate v from b and extract code u and certificate u from a. Then create new
• •	•	•	◦	◦
code u v by applying u to v and a new certificate for this code u · v. Finally, wrap
both of these up into a new mobile unit.”. The type system ensures that certificates always correspond to the mobile code with which it is enclosed.
In contrast to [6] this work includes the plus and also explores a more relaxed term assignment (derivation of proof witness equality is not reflected in the term assignment). The reason for relaxing the term assignment is to place the focus of the analysis on the plus, thereby simplifying the terms that it manipulates. That being said and based on current preliminary results, the main role of the plus that suggests itself is its use for typability, as illustrated in Exm. 2.1. It seems to have no run-time effect. However, more work is required in order to gain deeper insight.

Conclusions
We study a natural deduction presentation of ILP, an intuitionistic fragment of LP, together with its corresponding term assignment, a variant of those already intro- duced by the first author and discussed in the previous section. The basic properties of subject reduction, strong normalisation and confluence are easily shown to hold.
We think that a fresh look on realization of IS4 in the setting of IHLP could be an interesting avenue for exploration. It should be noted that this is a non-trivial problem in the presence of inference schemes which mix polarities such as ⊃ E, hence the reason why the first such proof [2,4] relied on a cut-free sequent calculus presentation of LP. Indeed, all known (to the authors of this work) realization proofs rely on presentations where related 5 occurrences of a 2 do not occur both in positive and negative positions. We think it could be interesting to put the well-developed type-inference technology to work but to infer the decorations of boxes rather than to infer types. Relations with higher-order unification may appear along the way.
In [7] the so called Basic Intuitionistic Logic of Proofs is developed. A modality of the form [u]]A is introduced, for u a proof variable, and a number of axioms over this modality, together with the axioms of IPC and MP, are shown to capture HA- tautologies. Towards the end of op.cit. operations on proof terms are added and the resulting system is proved to be arithmetically complete in [14]. Developing a proof theory for the latter could be an interesting line of work.
There are numerous proof theoretic approaches to intuitionistic modal logic such as [24,13,17,11], just to name a few. It could be interesting to recast the Logic of Proofs using some of these other approaches rather than the judgemental style adopted here.
Further avenues are those related to the use of natural deduction presentations of fragments of first-order LP. Although first-order LP is not finitely axiomatiz- able [23,8] (although see [3]), at the cost of losing the connection with Peano Arith- metic, the resulting type theory system could serve as the foundation for a logical framework with decidable forms of reflection. Additionally, we are currently ex- tending our results to full LP, based on classical logic.

References
Abadi, M. and C. Fournet, Access control based on execution history, in: In Proceedings of the 10th Annual Network and Distributed System Security Symposium, 2003, pp. 107–121.
Art¨emov, S., Operational modal logic, Technical Report Technical Report MSI 95-29, Cornell University (1995).
Artemov, S. and T. Yavorskaya, First-order logic of proofs, Technical report, Technical Report TR– 2011005, CUNY Ph. D. Program in Computer Science (2011).
Art¨emov, S. N., Explicit provability and constructive semantics, Bulletin of Symbolic Logic 7 (2001),
pp. 1–36.
Artemov, S. N. and L. D. Beklemishev, Provability logic, in: Handbook of Philosophical Logic, 2nd ed, 13 (2005), pp. 189–360.

5 See notion of “family” in [4].

Art¨emov, S. N. and E. Bonelli, The intensional lambda calculus, in: S. N. Art¨emov and A. Nerode, editors, LFCS, Lecture Notes in Computer Science 4514 (2007), pp. 12–25.
Art¨emov, S. N. and R. Iemhoff, The basic intuitionistic logic of proofs, J. Symb. Log. 72 (2007),
pp. 439–451.
Artemov, S. N. and T. Yavorskaya (Sidon), On first order logic of proofs, Moscow Mathematical Journal
1 (2001), pp. 475–490.
Banerjee, A. and D. A. Naumann, History-based access control and secure information flow, in: Construction and Analysis of Safe, Secure, and Interoperable Smart Devices, International Workshop (CASSIS 2004), Revised Selected Papers, volume 3362 of Lecture Notes in Computer Science (2005),
pp. 27–48.
Bavera, F. and E. Bonelli, Justification logic and history based computation, in: A. Cavalcanti,
D. D´eharbe, M.-C. Gaudel and J. Woodcock, editors, ICTAC, Lecture Notes in Computer Science
6255 (2010), pp. 337–351.
Bellin, G., E. Ritter and V. de Paiva, Extended curry-howard correspondence for a basic constructive modal logic, in: Proceedings of Methods for Modalities, 2001.
Bonelli, E. and F. Feller, Justification logic as a foundation for certifying mobile computation, Ann. Pure Appl. Logic 163 (2012), pp. 935–950.
Borghuis, T. J., “Coming to Terms with Modal Logic: On the interpretation of modalities in typed
λ-calculus,” Ph.D. thesis, Technical University of Eindhoven (1994).
Dashkov, E., Arithmetical completeness of the intuitionistic logic of proofs, J. Log. Comput. 21 (2011),
pp. 665–682.
Davies, R. and F. Pfenning, A modal analysis of staged computation, in: H.-J. Boehm and G. L. S. Jr., editors, POPL (1996), pp. 258–270.
Davies, R. and F. Pfenning, A modal analysis of staged computation, J. ACM 48 (2001), pp. 555–604.
Ghani, N., V. de Paiva and E. Ritter, Explicit substitutions for constructive necessity, in: K. G. Larsen,
S. Skyum and G. Winskel, editors, ICALP, Lecture Notes in Computer Science 1443 (1998), pp. 743– 754.
Kuznets, R., A note on the use of sum in the logic of proofs (2009).
Nanevski, A., F. Pfenning and B. Pientka, Contextual modal type theory, ACM Trans. Comput. Log. 9
(2008).
Oostrom, V. v., “Confluence for abstract and higher-order rewriting,” Ph.D. thesis, VU University Amsterdam (1994).
Pfenning, F. and R. Davies, A judgmental reconstruction of modal logic, Mathematical Structures in Computer Science 11 (2001), pp. 511–540.
Schellinx, H., Basic proof theory, a.s. troelstra and h. schwichtenberg, Journal of Logic, Language and Information 7 (1998), pp. 221–223.
Sidon, T., Nonaxiomatizability of predicate logics of proofs, Moscow University Mathematics Bulletin
53 (1998), pp. 18–22.
Simpson, A., “The Proof Theory and Semantics of Intuitionistic Modal Logic,” Ph.D. thesis, Univeristy of Edinburgh (1994).
Steren, G. and E. Bonelli, Intuitionistic hypothetical logic of proofs, Technical report, UBA, UNQ (2013), http://tinyurl.com/ihlp-report.
