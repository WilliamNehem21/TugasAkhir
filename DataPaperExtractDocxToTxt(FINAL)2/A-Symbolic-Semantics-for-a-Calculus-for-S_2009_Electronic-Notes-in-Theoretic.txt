

Electronic Notes in Theoretical Computer Science 241 (2009) 135–164
www.elsevier.com/locate/entcs

A Symbolic Semantics for a Calculus for Service-Oriented Computing 1
Rosario Pugliese2	Francesco Tiezzi3
Dipartimento di Sistemi e Informatica, Universita` degli Studi di Firenze
Nobuko Yoshida4
Department of Computing, Imperial College London

Abstract
We introduce a symbolic characterisation of the operational semantics of COWS, a formal language for specifying and combining service-oriented applications, while modelling their dynamic behaviour. This alternative semantics avoids infinite representations of COWS terms due to the value-passing nature of communication in COWS and is more amenable for automatic manipulation by analytical tools, such as
e.g. equivalence and model checkers. We illustrate our approach through a ‘translation service’ scenario.
Keywords: Service-oriented computing, service orchestration, process calculi, symbolic semantics.


Introduction
In recent years, the increasing success of e-business, e-learning, e-government, and other similar emerging models, has led the World Wide Web, initially thought of as a system for human use, to evolve towards an architecture for service-oriented computing (SOC) supporting automated use. SOC advocates the use of loosely coupled ‘services’, to be understood as autonomous, platform-independent, com- putational entities that can be described, published, discovered, and assembled, as the basic blocks for building interoperable and evolvable systems and applications. While early examples of technologies that are at least partly service-oriented date

1 This work has been supported by the EU project SENSORIA, IST-2 005-016004, the EPSRC projects, GR/T03208, GR/T03215, EP/F003757 and the EU project MOBIUS, IST 2005-15905.
2 Email: pugliese@dsi.unifi.it
3 Email: tiezzi@dsi.unifi.it
4 Email: yoshida@doc.ic.ac.uk


1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.008

back to CORBA, DCOM, J2EE and IBM WebSphere, the most successful instan- tiation of the SOC paradigm are probably the more recent web services. These are sets of operations that can be published, located and invoked through the Web via XML messages complying with given standard formats. To support the web service approach, several new languages and technologies have been designed and many international companies have invested a lot of efforts.
Current software engineering technologies for SOC, however, remain at the de- scriptive level and lack rigorous formal foundations. We are still experiencing a gap between practice (programming) and theory (formal methods and analysis tech- niques) in the design of SOC applications. The challenges come from the necessity of dealing at once with such issues as asynchronous interactions, concurrent ac- tivities, workflow coordination, business transactions, failures, resource usage, and security, in a setting where demands and guarantees can be very different for the many different components. Many researchers have hence put forward the idea of using process calculi, a cornerstone of current foundational research on specification and analysis of concurrent, distributed and mobile systems through mathematical
— mainly algebraic and logical — tools. Indeed, due to their algebraic nature, process calculi convey in a distilled form the compositional programming style of SOC. Thus, many process calculi have been designed (e.g. [9,8,16,13,10,15,4,6,27]), addressing one aspect or another of SOC and aiming at assessing the adequacy of diverse sets of primitives w.r.t. modelling, combining and analysing service-oriented applications.
By taking inspiration from well-known process calculi and from the standard language for orchestration of web services WS-BPEL [22], in [17] we have designed COWS (Calculus for Orchestration of Web Services), a process calculus for spec- ifying and combining service-oriented applications, while modelling their dynamic behaviour. We have shown that COWS can model and handle distinctive features of (web) services, such as, e.g., correlation-based communication, compensation activities, service instances and interactions among them, race conditions among service instances and service definitions.
A major benefit of using process calculi is that they enjoy a rich repertoire of elegant meta-theories, proof techniques and analytical tools that can be likely tai- lored to the needs of SOC. Concerning this, in [12] we have developed a logic and a model checker to express and check functional properties of services specified in COWS, while in [24] we have studied observational semantic theories for COWS. However, such tools suffer from a lack of compositionality and efficiency. Indeed, generally speaking, model and equivalence checkers, and other similar verification tools, do not work directly on syntactic specifications but rather on abstract repre- sentations of the behaviour of processes. Thus, for value-passing languages, such as COWS, using an inappropriate representation can lead to unfeasible verifications. Indeed, according to the COWS’s original operational semantics, if the communi- cable values range over an infinite value set (e.g. natural numbers and strings), the behaviour of a service that performs a receive activity is modelled by an infinite abstract representation. Such representation is a Labelled Transition System whose

initial state has infinite outgoing edges, each labelled with an input label having a different value as argument and leading to a different state.
Hence, by taking inspiration from Hennessy and Lin [14], in this paper we define a symbolic operational semantics for COWS. Differently from the symbolic seman- tics for more standard calculi, such as value-passing CCS or π-calculus, ours deals at once with, besides receive transitions, a number of complex features, such as, e.g., generation and exportation of fresh names, pattern-matching, expressions evalua- tion, and priorities among conflicting receives. The new semantics avoids infinite representations of COWS terms due to the value-passing nature of communication in COWS and associates a finite representation to each finite COWS term. It is then more amenable for automatic manipulation by analytical tools, such as e.g. equivalence and model checkers. Our major result is a theorem of ‘operational cor- respondence’. We prove that, under appropriate conditions, any transition of the original semantics can be generated using the symbolic one, and vice versa. In gen- eral, however, additional transitions can be derived using the symbolic semantics since it also accounts for services ability to interact with the environment.
The rest of the paper is organised as follows. Section 2 provides some motivations for the symbolic semantics of COWS; this is done by means of an ‘Italian-English translation service’ scenario that is used also to informally describe in a step-by- step fashion the main features of COWS. Section 3 presents the original syntax and operational semantics of COWS. Section 4 introduces the symbolic variant of the operational semantics of COWS and our major results, together with some clarifying examples. Section 5 shows an extension of the symbolic semantics for dealing with polyadic communication. Finally, Section 6 touches upon comparisons with related work and directions for future work.

A ‘translation service’ scenario
In this section, we present COWS main features and syntax in a step-by-step fashion while modelling an Italian-English translation service. By means of this scenario, we discuss some verification problems and present the major intuitions underlying the symbolic operational semantics for COWS. For the time being, we use a monadic variant of COWS, i.e. we assume that invoke and receive activities can carry one single parameter at a time. In fact, for the sake of presentation, the symbolic semantics is introduced for the monadic variant in Section 4, and is then extended to polyadic communication in Section 5.
Let us consider a service that provides to its customers an Italian-English trans- lation service. Specifically, when the service is invoked by a customer, that commu- nicates first her partner name and then an Italian word, it replies to the request with either the corresponding English word or the string “unknown word ”. A high-level specification of the service can be rendered in COWS as follows:
[x] t • req ?x. [y] t • word ?y. x • resp!trans(y)	(1)
where t is the translation service partner name, req , word and resp are operation

names, x and y are variables that store the customer partner name and the Italian word to be translated respectively, and trans( ) is a total function that maps a large subset of Italian words to the corresponding English ones and returns the string “unknown word ” for all words that do not appear in the Italian words set. The service simply performs a sequence of two receive activities t • req ?x and t • word ?y, corresponding to reception of a request and of an Italian word sent by a customer, and replies with the translated word, by invoking the operation resp of the customer by means of the invoke activity x • resp!trans(y). Receives and invokes are the basic communication activities provided by COWS. Besides input parameters and sent values, they indicate the endpoint, i.e. a pair p • o made of a partner name p and an operation name o, through which the communication should occur. Differently from most process calculi, receive activities in COWS bind neither names nor variables. The only binding construct is delimitation: [e] s binds the delimited element e in the scope s (the notions of bound and free occurrences of a delimited element are defined accordingly). For example, the service (1) uses the delimitation operator to declare the scope of variables x and y. An inter-service communication takes place when the arguments of a receive and of a concurrent invoke along the same endpoint do match, and causes replacement of the variables arguments of the receive with the corresponding values arguments of the invoke (within the scope of variables declarations). For example, variable x will be initialised by the first receive activity with data provided by a customer.
At a lower level, the service could be described in terms of three entities com- posed by using the parallel composition operator | that allows them to be concur- rently executed and to interact with each other. A low-level COWS specification of the translation service can be
[reqDB1 , reqDB2 , respDB1 , respDB2 ]( Translator | DB1 | DB2 )	(2)
The delimitation operator is used here to declare that reqDB1 , reqDB2 , respDB1 and respDB2 are private operation names known to the three components Translator , DB1 and DB2 , and only to them (at least initially, since during a computation private names can be exported exactly as in π-calculus). The three subservices are defined as follows:
Translator   [x] t • req?x. [y] t • word?y. 
[k]( t • reqDB1 !y | [x1] t • respDB1 ?x1 . ( kill(k) | {|x • resp!x1|} )
| t • reqDB2 !y | [x2] t • respDB2 ?x2 . ( kill(k) | {|x • resp!x2|} ) ) 
DB1  t • reqDB1 ?“a”.t • respDB1 !“to”
+ t • reqDB1 ?“albero”.t • respDB1 !“tree”
+ ... + t • reqDB1 ?“zucca”.t • respDB1 !“pumpkin”
DB2    [z]( t • reqDB2 ?z. t • respDB2 !“unknown word ”
+ t • reqDB2 ?“a”.t • respDB2 !“to”
+ t • reqDB2 ?“abate”.t • respDB2 !“abbot”
+ ... + t • reqDB2 ?“zuppo”.t • respDB2 !“soaked”) 

Service Translator is publicly invocable and can interact with customers other than with the ‘internal’ services DB1 and DB2 . These latter two services, instead, can only be invoked by Translator (indeed, all the operations used by them are re- stricted) and have the task of looking up in databases the English word correspond- ing to a given Italian one and replying accordingly. In particular, DB1 performs a quick search in a small database of commonly used words, while DB2 performs a slower search in a bigger database (that exactly corresponds to that modelled by the function trans( )). After the two initial receives, for e.g. performance or fault tolerance purposes, Translator invokes services DB1 and DB2 concurrently. When one of them replies, Translator immediately stops the other search. This is done by executing the kill activity kill(k), that forces termination of all unprotected par- allel terms inside the enclosing [k] , that stops the killing effect. Then, Translator forwards the response to the customer and terminates. Kill activities are executed eagerly with respect to the other parallel activities but critical code can be protected from the effect of a forced termination by using the protection operator {| |}; this is indeed the case of the response x • resp!x1 in our example. Services DB1 and DB2 use the choice operator + to offer alternative behaviours: one of them can be selected by executing an invoke matching the receive leading the behaviour. In case the word to be translated is unknown, DB1 does not reply, while DB2 returns the string “unknown word ”. Indeed, the semantics of parallel composition avoids that DB2 returns “unknown word ” in case of known words. This is done by assigning the receive t • reqDB2 ?z less priority than the other receive activities, so that it is only executed when none of the other receives matches the word to be translated (see Section 3 for further details about the prioritised semantics of COWS).
Now, the point is that equivalence and model checkers, and other similar veri- fication tools, do not work directly on syntactic specifications such as those above, but rather on more abstract representations of the behaviour of processes. Thus, using an inappropriate representation can lead to unfeasible verifications. In the rest of the section, we discuss verification problems and how to cope with them by exploiting a symbolic approach.
Verification problems. When the considered specification language is a value- passing process algebra and the value-space is infinite, using standard Labelled Transition Systems (LTSs) for the semantics can lead to infinite representations. For example, the operational behaviour of service (1) can be represented by the infinite LTS in the left-hand side of Figure 1, where nodes denote states and edges denote transitions between states implicitly oriented from top to bottom. Notably, for the sake of presentation, the LTSs shown in the figures rely on an operational semantics in early style, where substitutions are applied when receive actions are inferred. However, the problem of infinite representations remains also in case of late semantics, due to the fact that the continuation of a receive action with argument a variable x has to be considered under all possible substitutions for x.
The symbolic approach. To tackle the problems above, in [14] Hennessy and Lin have introduced the so-called symbolic LTSs and used them to define finite seman-


	

Fig. 1. LTS and symbolic LTS for the translation service (high-level specification)


tical representations of terms of the value-passing CCS. For example, the symbolic LTSs corresponding to the COWS service (1) is shown in the right-hand side of Fig- ure 1. The symbolic actions t • req?x and t • word?y denote reception of unknown values x and y along endpoints t • req and t • word, respectively; the condition- guarded symbolic action (z = trans(y) , x • resp!z) denotes sending of an unknown value z such that z = trans(y). Of course, for the same reasons, also the LTS rep- resenting the behaviour of service (2) is infinite, while the corresponding symbolic LTS is finite. Indeed, if for the sake of presentation we assume that database DB1 contains only the association for word “a” and database DB2 contains only the associations for “a” and “abate”, the symbolic LTS representing (2) is that shown in Figure 2.
Applying the symbolic approach to COWS. The main contribution of this work is the development of a symbolic operational semantics for COWS. To achieve this goal, the main issue is to give receive activities a proper semantics, because variables in their arguments are placeholders for something to be received. For example, let
p •o?x
us consider the service p • o?x.s. If p • o?x.s −−−−−→ s then the behaviour of
the continuation service s must be considered under all substitutions of the form
{x '→ v} (i.e. the semantics of s can intuitively be thought of as a function λx. s from values to services). In case of the standard semantics for π-calculus [21], for example, this problem is not tackled at the operational semantics level, but it is postponed to the observational semantics level. In fact, in the definition of late

a(x)
bisimulation for π-calculus, whenever P is bisimilar to Q, if P −−−−→
P ' then there

is Q' such that Q	a(x)
Q' and P '{u/x} is bisimilar to Q'{u/x} for every u. Thus,

continuations P ' and Q' are considered under all substitutions for x. Instead, here we aim at defining an operational semantics for COWS that properly handles input transitions, and allow finite state LTSs to be associated to finite COWS terms.
The basic idea is to allow receive activities to evolve by performing a communi- cation with the ‘external world’ (i.e. a COWS context), this way they do not need to synchronise with invoke activities within the considered term. To avoid infinite branching (as in the case of early operational semantics), we replace variables with



Fig. 2. Symbolic LTS for the (simplified) translation service (low-level specification)




unknown values rather than with specific values. We denote by x the unknown value that replaces the variable x. This way, the term [x]( p • o?x. q • o'!x ) can evolve as follows:

'	p •o ?[x]
'	q •o'!x

[x]( p • o?x. q • o !x ) −−−−−−→ q • o !x −−−−−→ 0
Also receive activities having a value as argument (e.g. p • o?v) and invoke activities (e.g. p • o!v) can evolve by communicating with the external world. Of course, these kinds of communication do not produce substitutions.
When an external communication takes place, the behaviour of the continuation service depends on the admittable values for the unknown value. To take care of the real values that the unknown values can assume, we define a symbolic semantics for COWS, where the label on each transition has two components: the condition that must hold for the transition to be enabled and, as usual, the action of the transition. Moreover, to store the conditions that must hold to reach a state and the names exported along the path, we define the semantics over configurations of the form Φ, Δ ▶ s, called constrained services, where the condition Φ and the set of names Δ are used to determine the actions that s can perform. Thus, the symbolic

transitions are of the form Φ, Δ ▶ s
Φ',α 
1 >−−−−→
Φ', Δ' ▶ s2, meaning “if the condition

Φ' (such that Φ is a subterm of Φ') holds then s1 can perform the action α leading to s2 by extending the set of exported private names Δ to the set Δ'”.
The symbolic LTS associated to a COWS term conveys in a distilled form all the semantics information on the behaviour of terms. More specifically, besides receive transitions, symbolic representations take into account generation and exportation of fresh names, pattern-matching, expressions evaluation, and priorities among con- flicting receives. Dealing at once with all the above features at operational semantics level makes the development of a symbolic semantics for COWS more complex than for more standard calculi, such as value-passing CCS or π-calculus.


Killer labels: k, k', . . .	Elements (i.e. Killer labels/Variables/Names): e, e', . . .
Expressions: є, є', ...	Variables/Names: u, u', . . .
Variables: x, y, . . .	Variables/Values: w, w', . . .
Values: v, v', . . .
Names: n, m, . . .	Endpoints:
Partners: p, p', . . .	without variables: p • o, . . . , n, m, . . .
Operations: o, o', . . .	may contain variables: u • u', ... , u, u', . . .



Services:
s  ::=
kill(k)	(kill)
Receive-guarded choice:
g ::=
0	(nil)

|	u • u'!є¯
(invoke)
|	p • o?w¯.s	(request processing)

|	g	(receive-guarded choice)
|	s | s	(parallel composition)
|	{|s|}	(protection)
|	[e] s	(delimitation)
|	∗ s	(replication)
|	g + g	(choice)

Table 1
COWS syntax

COWS and its standard operational semantics
COWS (Calculus for Orchestration of Web Services, [17]) is a recently designed pro- cess calculus for specifying, combining and analyzing service-oriented applications, while modelling their dynamic behaviour. COWS combines in an original way a number of ingredients borrowed from well-known process calculi, e.g. asynchronous communication, polyadic synchronization, pattern matching, protection, delimited receiving and killing activities, while resulting different from any of them. In this section, we present the standard syntax and operational semantics of COWS. We re- fer the interested reader to [17] for many examples illustrating COWS peculiarities and expressiveness, and for comparisons with other process-based and orchestration formalisms.
The syntax of COWS is presented in Table 1. It is parameterized by three countable and pairwise disjoint sets: the set of (killer) labels, the set of values and the set of ‘write once’ variables. The set of values is left unspecified; however, we assume that it includes the set of names, mainly used to represent partners and operations. The language is also parameterized by a set of expressions, whose exact syntax is deliberately omitted. We just assume that expressions contain, at least, values and variables, but do not include killer labels that, hence, are non- communicable values. This way the scope of killer labels cannot be dynamically extended and the activities whose termination would be forced by execution of a kill can be statically determined. Partner names and operation names can be combined to designate communication endpoints, written p • o, and can be communicated, but dynamically received names can only be used for service invocation (as in Lπ [20]). Indeed, communication endpoints of receive activities are identified statically because their syntax only allows using names and not variables. Notice also that, to model asynchronous communication, invoke activities cannot be used as prefixes

and choice can only be guarded by receive activities (as in asynchronous π-calculus [1]).
Notation ¯· stands for tuples of objects, e.g. x¯ is a compact notation for denoting the tuple of variables ⟨x1,... , xn⟩ (with n ≥ 0). We assume that variables in the same tuple are pairwise distinct. All notations shall extend to tuples component- wise. We adopt the following conventions about the operators precedence: monadic operators bind more tightly than parallel composition, and prefixing more tightly than choice. In the sequel, we shall use n to range over communication endpoints that do not contain variables (e.g. p • o), and u to range over communication endpoints that may contain variables (e.g. u • u'). We will omit trailing occurrences of 0, writing e.g. p • o?w¯ instead of p • o?w¯.0, and write [e1,... , en] s in place of [e1] ... [en] s. We will write I  s to assign a name I to the term s.
The only binding construct is delimitation: [e] s binds the element e (i.e. either a killer label, a name or a variable) in the scope s. In fact, to enable concurrent threads within each service instance to share (part of) the state, receive activities in COWS bind neither names nor variables, which is different from most process calculi. Instead, the range of application of the substitutions generated by a com- munication is regulated by the delimitation operator, that additionally permits to generate fresh names (as the restriction operator of the π-calculus) and to delimit the field of action of kill activities. Thus, the occurrence of an element is free if it is not under the scope of a delimitation for it. We denote by fk(t) the set of killer labels that occur free in the term t, and by fe(t) that of free elements in t. Two terms are alpha-equivalent if one can be obtained from the other by consistently renaming bound elements. As usual, we identify terms up to alpha-equivalence.
The operational semantics of COWS is defined only for closed services, i.e. services without free variables/labels, but of course the rules also involve non-closed services (see e.g. the premises of rules (delcom) and (delkill1)).
Formally, the semantics is given in terms of a structural congruence and of a labelled transition relation. The structural congruence ≡ identifies syntactically different services that intuitively represent the same service. It is defined as the least congruence relation induced by a given set of equational laws. We explicitly show in Table 2 the laws for replication, protection and delimitation, while omit the (standard) laws for the other operators stating that parallel composition is commutative, associative and has 0 as identity element, and that guarded choice enjoys the same properties and, additionally, is idempotent. All the presented laws are straightforward. In particular, commutativity of consecutive delimitations implies that the order among the ei in [⟨e1,... , en⟩] s is irrelevant, thus in the sequel we may use the simpler notation [e1,... , en] s. Notably, the last law can be used to extend the scope of names (like a similar law in the π-calculus), thus enabling communication of restricted names, except when the argument e of the delimitation is a free killer label of s2 (this avoids involving s1 in the effect of a kill activity inside s2 and is essential to statically determine which activities can be terminated by a kill).
To define the labelled transition relation, we need a few auxiliary functions.


[e1] [e2] s ≡ [e2] [e1] s	s1 | [e] s2 ≡	[e] (s1 | s2) if e ∈/ fe(s1)∪fk(s2)
Table 2
COWS structural congruence (excerpt of laws)



M(x, v)= {x '→ v}	M(v, v)= ∅	M(⟨⟩, ⟨⟩)= ∅
M(w1, v1)= σ1 M(w¯2, v¯2)= σ2

M((w1, w¯2), (v1, v¯2)) = σ1 σ2

Table 3 Matching rules

First, we exploit a function [ ] for evaluating closed expressions (i.e. expressions without variables): it takes a closed expression and returns a value. However, [ ]] cannot be explicitly defined because the exact syntax of expressions is deliberately not specified.
Then, through the rules in Table 3, we define the partial function M( , ) that permits performing pattern-matching on semi-structured data thus determining if a receive and an invoke over the same endpoint can synchronize. The rules state that two tuples match if they have the same number of fields and corresponding fields have matching values/variables. Variables match any value, and two values match only if they are identical. When tuples w¯ and v¯ do match, M(w¯, v¯) returns a substitution for the variables in w¯; otherwise, it is undefined. Substitutions (ranged over by σ) are functions mapping variables to values and are written as collections of pairs of the form x '→ v. Application of substitution σ to s, written s · σ, has the effect of replacing every free occurrence of x in s with v, for each x '→ v ∈ σ, by possibly using alpha conversion for avoiding v to be captured by name delimitations within s. We use | σ | to denote the number of pairs in σ and σ1 σ2 to denote the union of σ1 and σ2 when they have disjoint domains.
We also define a function, named halt( ), that takes a service s as an argument and returns the service obtained by only retaining the protected activities inside s. halt( ) is defined inductively on the syntax of services. The most significant case is halt({|s|})= {|s|}. In the other cases, halt( ) returns 0, except for parallel composi- tion, delimitation and replication operators, for which it acts as an homomorphism.

halt(kill(k)) = halt(u!ϵ¯) = halt(g) = 0	halt({|s|})= {|s|}
halt(s1 | s2)= halt(s1) | halt(s2)	halt([e] s)= [e] halt(s)	halt(∗ s)= ∗ halt(s)
Finally, in Table 4, we inductively define two predicates: noKill(s, e) holds true if either e is not a killer label or e = k and s cannot immediately perform a free kill activity kill(k); noConf(s, n, v¯, l), with l natural number, holds true if s does not produce communication conflicts, i.e. s cannot immediately perform a receive activity over the endpoint n which matches v¯ and generates a substitution with fewer pairs than l.


noKill(s, e) = true if fk(e)= ∅	 noKill(s | s', k) = noKill(s, k) ∧ noKill(s', k) noKill(kill(k), k) = false	noKill([e] s, k) = noKill(s, k) if e /= k noKill(kill(k'), k) = true if k /= k'	 noKill([k] s, k) = true
noKill(u!є¯, k) = noKill(g, k) = true	noKill({|s|}, k) = noKill(∗ s, k) = noKill(s, k)
noConf (kill(k), n, v¯, l) = noConf (u!є¯, n, v¯, l) = noConf (0, n, v¯, l) = true noConf (n'?w¯.s, n, v¯, l) =	false	if n' = n ∧ |M(w¯, v¯) |< l 
true	otherwise
noConf (g + g', n, v¯, l) = noConf(g, n, v¯, l) ∧ noConf (g', n, v¯, l)
noConf (s | s', n, v¯, l) = noConf(s, n, v¯, l) ∧ noConf(s', n, v¯, l) noConf ([e] s, n, v¯, l) =	noConf (s, n, v¯, l)	if e ∈/ n
true	otherwise
noConf ({|s|}, n, v¯, l) = noConf (∗ s, n, v¯, l) = noConf (s, n, v¯, l)
Table 4
There are not active kill(k) / There are not conflicting receives along n matching v¯




k	n Q w¯
[[є¯]] = v¯
α
g −−−→ s

kill(k) −−→ 0 (kill)	n?w¯.s −−−−−→ s (rec)
n Q v¯
n!є¯ −−−−−→
(inv)		 (choice)
g + g' α	s



n σ {x'→v} Æ v¯
s −−−−−−−−−−−−→ s
s −−→ s'
s −−→ s' k /= e



[x] s −n σ Æ v¯→ s' ·{x '→ v}
(delcom)
†	(delkill1 )
[k] s −−→ [k] s
k	(delkill2 )
[e] s −−→ [e] s



s −−→ s'
s −−−→ s'
e ∈/ e(α) α /= k, † noKill(s, e)


[e] s −−→ [e] s'
(delkill3 )
[e] s −−−→ [e] s'
(del)



α
s ≡ s	s	s
s ≡ s'
n σ Æ v¯
s

1	1 −−−→ 2	2
1 −−−−−−→ s1  noConf(s2, n, v¯, l)

(cong)
α
n σ Æ v¯	'
(parcom )

s −−−→ s'	s1 | s2 −−−−−−→ s1 | s2


s  α	'
n Q w¯	'
n Q v¯	'

−−−→ s
s1−−−−−→s1 s2−−−−−→s2  M(w¯, v¯)= σ  noConf (s1 | s2, n, v¯, | σ |)

(prot)
α	'
n σ | σ | v¯	'	'
(com)

{|s|}
−−−→ {|s |}
s1 | s2 −−−−−−−→ s1 | s2


s	k	'	α	'
1 −−→ s1	s1 −−−→ s1 α /= k, n σl v¯

k	'	(parkill )
s1 | s2 −−→ s1 | halt(s2)
(par)
s | s −α → s' | s



Table 5
COWS operational semantics


The labelled transition relation
α
−−→ is the least relation over services induced

by the rules in Table 5, where label α is generated by the following grammar:

α	::=	n  v¯
|	n D w¯
|	n σl v¯
|	k	|	†

In the sequel, we use e(α) to denote the set of names, variables and killer labels occurring in α, except for α = n σl v¯ for which we let e(n σl v¯) = e(σ), where e({x '→ v})= {x}∪ fe(v) and e(σ1  σ2)= e(σ1) ∪ e(σ2).
The meaning of labels is as follows: n v¯ and n D w¯ denote execution of invoke and receive activities over the endpoint n, respectively, n σl v¯ (if σ /= ∅) denotes execution of a communication over n with matching values v¯, generated substitu- tion having l pairs, and substitution σ to be still applied, k denotes execution of a request for terminating a term from within the delimitation [k], † and n ∅ l v¯ denote computational steps corresponding to taking place of forced termination and com- munication (without pending substitutions), respectively. Hence, a computation from a closed service s0 is a sequence of connected transitions of the form

s	α1
α2	α3

0 −−−→ s1 −−−→ s2 −−−→ s3 ... 
where, for each i, αi is either † or n ∅ l v¯ (for some n, l and v¯); services si, for each
i, will be called reducts of s0.
We comment on salient points. Activity kill(k) forces termination of all unpro- tected parallel activities (rules (kill) and (parkill)) inside an enclosing [k] , that stops the killing effect by turning the transition label k into † (rule (delkill1)). Existence of such delimitation is ensured by the assumption that the semantics is only defined for closed services. Critical code can be protected from killing by putting it into a protection {| |}; this way, {|s|} behaves like s (rule (prot)). Similarly, [e] s behaves like s (rule (del)), except when the transition label α contains e, in which case α must correspond either to a communication assigning a value to e (rule (delcom)) or to a kill activity for e (rule (delkill1)), or when a free kill activity for e is active in s, in which case only actions corresponding to kill activities can be executed (rules (delkill2) and (delkill3), that also apply when the third premise of rule (del) does not hold, i.e. α = k or α = †). This means that kill activities are executed eagerly with respect to the activities enclosed within the delimitation of the corresponding killer label.
A service invocation can proceed only if the expressions in the argument can be evaluated (rule (inv)). A receive activity offers an invocable operation along a given partner name (rule (rec)), and the execution of a receive permits to take a decision between alternative behaviours (rule (choice)). Communication can take place when two parallel services perform matching receive and invoke activities (rule (com)). Communication generates a substitution that is recorded in the transition label (for subsequent application), rather than a silent transition as in most process calculi. If more then one matching is possible, the receive that needs fewer substitutions is selected to progress (rules (com) and (parcom)). This mechanism permits to correlate different service communications thus implicitly creating interaction sessions and can be exploited to model the precedence of a service instance over the corresponding service specification when both can process the same request.
When the delimitation of a variable x argument of a receive is encountered, i.e. the whole scope of x is determined, the delimitation is removed and the substitution for x is applied to the term (rule (delcom)); variable x disappears from the term and


Conditions: Φ, Φ', . . .	Exported private names: Δ, Δ', . . .
Unknown values: x, y, ...	Variable/Names/Unknown values: u, u', . . . Values/Unknown values: v, v', . . .	Variable/Values/Unknown values: w, w', . . . Names/Unknown values: n, m', . .., p, o, . . .	Endpoints/Unknown values: n, m', . . . , u, u', . . .
Constrained services: Φ, Δ ▶ s
Services: s  ::= kill(k) |  u • u'!є  |  g  |  s | s  |  {|s|}  |  [e] s  |  ∗ s
Receive-guarded choice: g ::= 0 | p • o?w.s | g + g

Table 6 Constrained services

cannot be reassigned a value (for this reason we say that COWS’s variables are ‘write once’). Notably, during the inference of the transition, the length of the substitution to be applied decreases, while the length l of the initial substitution does never change, which makes it suitable to check, in any moment, existence of better matching, i.e. of parallel receives with greater priority. Rule (cong) is standard and states that structurally congruent services have the same transitions.
Execution of parallel services is interleaved (rule (par)), but when a kill activity or a communication is performed. Indeed, the former must trigger termination of all parallel services (according to rule (parkill)), while the latter must ensure that the receive activity with greater priority progresses (rules (com) and (parcom)).

A symbolic semantics for COWS
In this section, we introduce a symbolic operational semantics for COWS. For the sake of simplicity, here we consider a monadic version of COWS, i.e. communica- tion activities are of the form u!ϵ and n?w.s (we discuss in Section 5 how to tailor the symbolic semantics to handle polyadic communication). Many illustrative examples shed light on the technical development.
Symbolic operational semantics
The symbolic operational semantics of COWS is defined over configurations of the form Φ, Δ ▶ s, called constrained services and defined in Table 6, where Φ is the condition that must hold to reach the current state, Δ is the set of private names previously exported, and s is a service whose actions are determined by Φ and Δ. The set Δ will be omitted when empty, writing e.g. Φ ▶ s instead of Φ, ∅▶ s. We define the semantics over an enriched set of services that also includes those auxiliary terms resulting from replacing (free occurrences of) variables with unknown values in terms produced by the syntax introduced in Section 3, where now expressions contain also unknown values. In the extended syntax we use x to denote an unknown value and t to denote an unknown value or a term t (where t can be n, v, u, w, n or u). Therefore, u • u'!ϵ and p • o?w.s denote invoke and receive activities, respectively.
As in the standard semantics, the only binding construct is delimitation: let

Φ, Δ ▶ C[[[d] s ] be a constrained service (where C is a context 1 ), [d] binds d in the scope s, in the condition Φ and in the set Δ. We denote by bn(t) the set of names that occur bound in a term t, and by uvar(t) the set of variables that have been replaced by corresponding unknown values in t (i.e. if x is an unknown value in t, then x ∈ uvar(t)). For simplicity sake, in the sequel we assume that bound variables in constrained services are pairwise distinct and different from variables corresponding to the unknown values of the constrained services, and bound names are all distinct and different from the free ones (of course, these conditions are not restrictive and can always be fulfilled by possibly using alpha-conversion). This assumption avoids that distinct unknown values are denoted by the same x in a condition Φ of a constrained service (see Example “Evaluation function, condition x /∈ uv and assumption on bound variables” in Section 4.2), and permits identifying the name delimitation binding each private name within a condition Φ and a set Δ of a constrained service (see Remark 4.1).
The symbolic operational semantics of COWS is defined only for closed services, and is given in terms of a structural congruence and of a (bi-)labelled transition relation. The structural congruence ≡ is the trivial extension of that defined in Section 3 to the enriched syntax of services used here. To define the labelled tran- sition relation, we exploit the trivial extension to the enriched syntax of function halt( ) and predicate noKill( , ) defined in Section 3. We also extend function [ ]] to deal with unknown values. Now, it takes a closed expression and returns a pair (Φ, v): the (possibly unknown) value v is the result of the evaluation provided that the condition Φ holds. Specifically, let ϵ be an expression, if ϵ does not contain un- known values and can be computed, then [ϵ]] = (true, v) where v is the result of the evaluation, as in the original COWS semantics. Similarly, if ϵ is an unknown value x, then [ϵ]] = (true, x). If ϵ contains unknown values and is not a single unknown value (i.e. ϵ /= x for every x), then [ϵ]] = ((y /= bn Λ y /∈ uv Λ y = ϵ Λ Φ'), y) where y is a fresh unknown value that must be different from all private names (i.e. y /= bn) and from all existent unknown values (i.e. y /∈ uv) 2 , and Φ' is a condition that permits dealing with expression operators partially defined 3 . Function [ ]], and hence condition Φ', cannot be explicitly defined because the exact syntax of expressions is deliberately not specified. Then, consider as an example the following simple language for expressions:
ϵ  ::= x  |  x  |  i  |  ϵ + ϵ  |  ϵ — ϵ  |  ϵ ∗ ϵ  |  ϵ/ϵ  |  (ϵ) where i is an integer value. For the above language function [ ]] is such that:
[[(5 — 2) ∗ 3]] = (true, 9);
[[5 — x ] is undefined, because the expression 5 — x is not closed;

1 A context C is a service with a ‘hole’ [· ] such that, once the hole is filled with a service s, the resulting term C[[s]] is a COWS service.
2 Notably, here y can be any unknown value, provide that it satisfies conditions y /= bn and y /∈ uv. Notice
that condition y /∈ uv is a syntactical condition on the variable name y. Later we shall explain the exact meaning of the above conditions and show how they are evaluated in the last step of the inference of a transition.
3 Of course, if all operators used in the considered expression are total functions, then condition Φ' is true.

[[5 — x]] = ((y /= bn Λ y /∈ uv Λ y =5 — x), y);
[[5/0 ] is undefined;
[[5/x]] = ((y /= bn Λ y /∈ uv Λ y = 5/x Λ x /= 0), y), where condition x /= 0 is due to the fact that operator / is not defined when its second argument is 0.
We also define a function confRec( , ), that takes a service s and an endpoint n as an arguments and returns the set of (possibly unknown) values that are parame- ters of receive activities over the endpoint n active in s. This function plays the role of predicate noConf( , , , ) of the standard semantics and, indeed, is exploited to disable transitions in case of communication conflicts (by setting transition condi- tions to false). The function is inductively defined as follows:

confRec(0, n) = confRec(kill(k), n) = confRec(u!ϵ, n) = confRec(n?x.s, n) = ∅ confRec(g + g', n)= confRec(g, n) ∪ confRec(g', n)		confRec(n?v.s, n)= { v } confRec(n'?w.s, n)= ∅ if n /= n'	confRec({|s|}, n)= confRec(s, n) confRec(s | s', n)= confRec(s, n) ∪ confRec(s', n) confRec([e] s, n)= ∅ if e ∈ n confRec([e] s, n)= confRec(s, n)\{e}  if e ∈/ n		confRec(∗ s, n)= confRec(s, n)
Φ ,α 
The labelled transition relation over constrained services, written >————→, relies
Φ ,α 
on a labelled transition relation ————→, that is the least relation over services
induced by the rules in Table 7. Conditions Φ and actions α are generated by the following grammar:
Φ ::=  true  |  false  |  v = v'  |  v /= v'  |  x /= bn  |  x /∈ uv
|	x /∈ {xi}i∈I	|	x = ϵ	|	Φ Λ Φ'
α  ::=  n  v  |  n  [n]  |  n D w  |  n D [x ]  |  n σlv  |  k  |  †
where, now, a substitutions σ can be either the empty substitution ∅ or a substitu- tion {x '→ v} that maps the variable x to the (possibly unknown) value v.
The meaning of labels is as follows:
Conditions: true (resp. false) denotes the condition always (resp. never) satisfied, v = v' (resp. v /= v') denotes an equality (resp. inequality) between (possibly unknown) values, x /= bn means that the unknown value x must be different from all bound names of the considered service, x /∈ uv means that the set of variables corresponding to the unknown values of the considered constrained service may not contain the variable x, x /∈ {xi}i∈I means that x must not be in the set
{xi}i∈I , x = ϵ states that the unknown value x is equal to the evaluation of the closed non-evaluable expression ϵ (conditions of this form are generated by the evaluation function, e.g. condition y = 5/x is generated by evaluation of expression 5/x), and as usual Λ denotes the logic conjunction. In the sequel, we will use notation v /= {v 1,... , v n} to indicate the condition v /= v 1 Λ ... Λ v /= v n (where v /= ∅ indicates true). Moreover, we will use a function У( , , ) that,



kill(k) true ,k 
true , n Q w

−−−−−−→ 0 (s-kill)	n?w.s −−−−−−−−−→ s (s-rec)


Φ , n Q x
s −−−−−−−→ s
Φ ,α 
g −−−−−→ s

Φ ∧ x/=bn ∧ x /= confRec(s,n) , n Q[x]	'
(s-reccom)
'  Φ ,α 
(s-choice)

[x] s −−−−−−−−−−−−−−−−−−−−−−−−−−→ s ·{x '→ x}

[[є]] = (Φ, v )
g + g

Φ , nQ n
s
−−−−−→ s

'

Φ , nQ v
n!є
(s-inv)
−−−−−−−→ s
Φ , n Q [n]
n ∈/ n
(s-open)
'

−−−−−−−→ 0
[n] s −−−−−−−−−→ s



Φ , n {x '→v} 1 v
s −−−−−−−−−−−−→ s
Φ ,k 
s −−−−−→ s

Φ , n ∅ 1 v	'
(s-delcom)
Φ , †
(s-delkill1)
'

[x] s −−−−−−−−→ s ·{x '→ v}	[k] s −−−−→ [k] s


Φ ,k 
s −−−−−→ s
k /= e
Φ , †
s −−−−→ s

Φ ,k 
[e] s −−−−−→ [e] s
(s-delkill2)


Φ , †
[e] s −−−−→ [e] s
(s-delkill3)



Φ ,α 
s −−−−−→ s
e ∈/ e(α) α /= k, † noKill(s, e)

(s-del)
Φ ,α 
s −−−−−→ s

(s-prot)

Φ ,α 
[e] s
Φ ,α	'

−−−−−→ [e] s

Φ1 , n Q v'	'


Φ2 , n' Q v	'
{|s|} −−−−−→ {|s |}

s1 −−−−−−−−→ s1	s2 −−−−−−−−→ s2
(s-match)

'	'

s | s
Φ1 ∧ Φ2 ∧ n=n ∧ v =v , n ∅ 0 v
s' | s'

1	2 −−−−−−−−−−−−−−−−−−−−−−→ 1	2


Φ1 , n Q x	'

Φ2 , n'Q v	'



s | s
s1 −−−−−−−−→ s1	s2 −−−−−−−−→ s2
'
Φ1 ∧ Φ2 ∧ n=n ∧ v /= confRec(s1 | s2 ,n) , n {x'→v} 1 v


s' | s'
(s-com)

1	2 −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→ 1	2


Φ , n σ 1 v	'
Φ ,k 
s

s1 −−−−−−−−→ s1	1 −−−−−→ s1

Φ ∧ v /= confRec(s2 ,n) , n σ 1 v	'
(s-parcom1)
Φ ,k	'
(s-parkill)

s1 | s2 −−−−−−−−−−−−−−−−−−−−−→ s1 | s2	s1 | s2 −−−−−→ s1 | halt(s2 )


Φ , n Q[x ]
s

Φ ,α	'

1 −−−−−−−−→ s1
Φ ∧ x /= confRec(s2 ,n) , n Q[x ]	'
(s-parcom2)
s ≡ s1 s1 −−−−−→ s2 s2 ≡ s
Φ ,α 
(s-cong)

s1 | s2 −−−−−−−−−−−−−−−−−−−−−→ s1 | s2	s −−−−−→ s'

Φ ,α 
s

1 −−−−−→ s1	α /= k, n σ 1 v , n Q [x ]
(s-par)

s1 | s
Φ ,α 
2 −−−−−→
s' | s2

Table 7
COWS symbolic semantics (rules for  Φ ,α  )








given a condition Φ, a service s and a set of variables {xi}i∈I , returns a condition obtained by conjuncting Φ with all inequalities between the unknown values of Φ and the bound names of s and with all conditions x /∈ {xi}i∈I for each x /∈ uv in

Φ. Formally, У( , , ) is defined as follows:

У(true, s, {xi}i∈I )= true	У(false, s, {xi}i∈I )= false
У(v = v', s, {xi}i∈I )= v = v'	У(v /= v', s, {xi}i∈I )= v /= v'
У(x /= bn, s, {xi}i∈I )= x /= bn Λ x /= bn(s)	 У(x /∈ uv, s, {xi}i∈I )= x /∈ {xi}i∈I У(x /∈ {yj}j∈J , s, {xi}i∈I )= x /∈ {yj}j∈J	У(x = ϵ, s, {xi}i∈I )= x = ϵ
У(Φ Λ Φ', s, {xi}i∈I )= У(Φ, s, {xi}i∈I ) Λ У(Φ', s, {xi}i∈I )
Actions: n [n] denotes execution of a bound invoke activity over the endpoint n, while n D [x ] denotes taking place of external communication over the endpoint n with receive parameter x (that will be replaced by the unknown value x). The remaining labels have the usual meaning. Notably, due to the restraint on monadic communication, here the natural number l can only be either 0 or 1.
We comment on the aspects of the symbolic semantics rules that mainly differ from the standard ones. Bound invocations, that transmit private names, can be generated by rule (s-open). Notably, bound invocation actions do not appear in rules (s-match) and (s-com), and therefore cannot directly interact with receive actions. Such interactions are instead inferred by using structural congruence to pull name delim- itation outside both interacting activities. Although the bound transitions and rule (s-open) can be omitted, we include them both to give a proper semantics to terms
[m] n!m and to support the development of behavioural equivalences for COWS. Communication can be either internal or external to a service. Internal communi- cation can take place when two matching receive and invoke activities (rules (s-match) and (s-com)) are simultaneously executed. External communication can take place when a value is transmitted to the environment (rules (s-inv) and (s-open)) or when a receive activity matches an unknown value provided by the environment (rules (s-rec) and (s-reccom)). Differently from the standard semantics, conflicting receives cannot be dealt with by using a predicate in the premises of rules for communi- cation and interleaving, because unknown values can be involved. Here, the check for conflicting receives is simply a condition of the form v /= confRec(s, n) (rules
(s-reccom), (s-com), (s-parcom1)) and (s-parcom2)).
Φ ,α 
The labelled transition relation >————→ is the least relation over constrained
services induced by the rules reported in Table 8, where notation n ∈/ Δ means that set Δ does not contain the names of endpoint n. Rule (constServ) states that a constrained service Φ, Δ ▶ s can perform all the ‘non-invoke’ transitions performed by s with an enriched condition Φ'' obtained by composing Φ and the condition on the label Φ'. Condition Φ'' takes care of the relationship between unknown values and private names. Indeed, by private names definition, each unknown value, that is a value coming from the environment, must be different from all bound (private)

Φ',α 
names of the considered service. If the transition s ————→
s' introduces a new

unknown value x (rules (s-inv) and (s-reccom)), it is not sufficient to add the condition
x /= bn(s') (i.e. the unknown value is different from all bound names of the current



'
Φ ,α 
s

''	'  '

−−−−−→ s
α /= n Q [n] , n Q v	Φ = B(Φ ∧ Φ ,s , uvar(Φ))
''
(constServ)

Φ, Δ ▶ s
Φ ,α 
>−−−−−→
Φ'', Δ ▶ s'



Φ', n Q [n]
s −−−−−−−−−→ s'	n ∈/ Δ	Φ'' = B(Φ ∧ Φ', s', uvar(Φ))


''

(constServexp )

Φ, Δ ▶ s
Φ , n Q [n]
>−−−−−−−−−→
Φ'', Δ ∪ {n} ▶ s'



Φ' , nQ v	'

''	'  '

s −−−−−−−→ s
n ∈/ Δ	Φ
''
= B(Φ ∧ Φ ,s , uvar(Φ))
(constServinv)

Φ, Δ ▶ s
Φ , nQ v
>−−−−−−−→
Φ'', Δ ▶ s'

Table 8
COWS symbolic semantics (rules for

Φ ,α 
>−−−−→)

service), but we need also to consider bound names that could be subsequently generated. For example, let us consider the following transition:


true ▶ [x] n?x.s | ∗ [n] n'!n
x/=bn ∧ x/=n, n Q[x ]
>——————————————→
x /= bn Λ x /= n ▶ s·{x '→ x}| ∗ [n] n'!n

Now, if the obtained service performs the transition:


s · {x '→ x}| ∗ [n] n'!n	Φ ,α 
s' · {x '→ x}| ∗ [n] n'!n | [n'] n'!n' | [n''] n'!n''

then, let Φ' ▶ s'' be the obtained constrained service, the condition Φ' must contain x /= n' and x /= n''. To update after any transition the condition of a constrained service with inequalities between unknown values and private names, we use the condition x /= bn, that simply states that x has been introduced in the considered term (rules (s-inv) and (s-reccom)), and function У( , , ), that adds the inequalities for each unknown value (rules (constServ), (constServexp) and (constServinv)). Moreover, function У( , , ) adds conditions of the form x /∈ {xi}i∈I to guarantee that unknown values introduced by rule (s-inv) because of expression evaluation differ from those of the considered constrained service (i.e. uvar(Φ) if the constrained service is Φ, Δ ▶ s; for further details see Example “Evaluation function, condition x /∈ uv and assumption on bound variables” in Section 4.2).
Rules (constServexp) and (constServinv) deal with the localized receiving feature of COWS. Indeed, if a COWS term communicates a private (partner or operation) name to the environment, then the latter (that is a COWS context) may use the name to define a sending endpoint, but not a receiving one. For example, consider the following constrained service:
true ▶ [p]( q • o!p | p • o'!v )
It can perform the activity q • o!p (rule (s-open)) and become the term true, {p}▶ p • o'!v which is stuck. In fact, to further evolve it needs the environment to be able to perform first a receive q • o?x and then a receive along the endpoint x • o', that

is disallowed by the syntax. Therefore, to block invoke activities performed along endpoints using previously exported private names, we record all exported private names in the set Δ of the constrained service and perform the check n ∈/ Δ when an invoke activity along n communicating with the environment is executed.
Remark 4.1 The assumption “bound names are all distinct and different from the free ones” is used to guarantee the correlation between conditions and services. For example, if we do not rely on this assumption, for the constrained service x /= n ▶ [n] s | [n] s' we are not able to understand what is the binder for the n in the condition x /= n. In fact, by definition of bound names, the constrained service x /= n ▶ [n] x • o!n is alpha-equivalent to x /= m ▶ [m] x • o!m, not to x /= n ▶ [m] x • o!m.

Remark 4.2 In the definition of relation
Φ ,α 
, the conditions are never eval-

>————→
uated. Thus, at operational semantics level, we do not distinguish unfeasible transitions (whose condition holds false ) from feasible ones. For example, tran- sitions having the following conditions are unfeasible: (oreq = oresp), (x /= x) and (x = y Λ x /= y). Of course, to identify unfeasible transitions, we can replace the condition Φ'' in the conclusion of rules (constServ), (constServexp) and (constServinv) with S(Φ''), where S( ) is a function for evaluating conditions.
Φ ,α 
Remark 4.3 Since the transition relation >————→ is defined over constrained ser-
vices, i.e. configuration of the form Φ, Δ ▶ s, the operational semantics can be naturally interpreted on L2TS [11]. Indeed, each edge label (of the form Φ, α) in- dicates the condition which must hold for the transition to be enabled and the performed action, while each state label (of the form Φ, Δ) indicates the condition which must hold to reach the considered state from the initial one and the set of previously exported private names.
We can now formalize the correspondence between the original semantics intro- duced in Section 3 and the symbolic semantics. We exploit here a function S( ) for evaluating conditions: it takes a condition Φ and returns false if certainly Φ does not hold; otherwise, it returns Φ. For example, S(Φ' Λ (5 = 3)) is false whatever Φ' may be. Since a condition Φ can be of the form x = ϵ and the syntax of expres- sions ϵ is not specified, function S( ) cannot be explicitly defined (like function [ ]]). For the proof of semantics correspondence, we use the following lemma concerning function У( , , ). For the sake of simplicity, a condition Φ is deemed favourable if uvar(Φ) = ∅ and S(Φ) /= false , i.e. it does not contain unknown values and can be positively evaluated.
Lemma 4.4 Let Φ be a favourable condition, then S(У(Φ, s, ∅)) /= false for any s. Proof.  The thesis follows from the fact that, under the considered hypotheses,
У( , , ) acts as an homomorphism on the first argument, except when the argument is x /= bn and x /∈ uv. We do not need to consider the former case because, by the hypothesis uvar(Φ) = ∅, we have that Φ does not contain unknown values. For the latter case, we get that У(x /∈ uv, s, ∅) = x /∈ uv since the third argument of

У( , , ) is ∅.	 
Our major result is a theorem of ‘operational correspondence’. It is quite stan- dard and states that for each transition of the original LTS associated to a COWS term there exists a corresponding symbolic transition of the symbolic LTS that does not involve unknown values and bound names, and vice versa. Notice that, since the original semantics does not take bound invocations into account, only constrained services of the form Φ ▶ s are considered in the theorem.

Theorem 4.5 Let uvar(α)= ∅ and α /= n  [n] . s	α
s' if and only if, for any

favourable condition Φ, Φ ▶ s
Φ' ,α 
>————→
Φ' ▶ s' for some favourable condition Φ'.

Proof.	The proof of the “if” part proceeds by induction on the length of the

α
inference of s ——→
s'. For the base case, we reason by case analysis on the axioms

of the original operational semantics.
(kill) In this case, α = k, s = kill(k) and s' = 0. By rule (s-kill), kill(k)	true ,k 

0. Then, by rule (constServ), we get that Φ ▶ kill(k)
Φ' ,k 
>————→
Φ' ▶ 0, where

Φ' = У(Φ Λ true, 0, ∅) (since uvar(Φ) = ∅). By definition, У(Φ Λ true, 0, ∅) = У(Φ, 0, ∅) Λ У(true, 0, ∅). Since Φ is favourable, by Lemma 4.4, we have that S(У(Φ, 0, ∅)) /= false . Since У(true, 0, ∅) = true /= false , we can conclude that S(Φ') /= false .

(rec) In this case, α = n D w and s = n?w.s'. By rule (s-rec), n?w.s'	true , n Q w
s'.

Then, by rule (constServ), we get that Φ ▶ n?w.s'
Φ' , n Q w
>——————→
Φ' ▶ s', where

Φ' = У(Φ Λ true, 0, ∅). As before, we can conclude that S(Φ') /= false.
(inv) In this case, α = n  v, s = n!ϵ where [ϵ]] = v, and s' = 0. By rule (s-inv),

n!ϵ	true , n Q v
Φ' , n Q v	'

————————→ 0. Then, by rule (constServinv), we get that Φ ▶ n!ϵ >——————→ Φ ▶
0, where Φ' = У(Φ Λ true, 0, ∅). As before, we can conclude that S(Φ') /= false.
For the inductive step, we reason by case analysis on the last applied inference rule of the original operational semantics.

(choice) In this case, s = g + g'. By the premise of the rule (choice), g	α
s'. By

induction, Φ ▶ g
Φ' ,α 
>————→
Φ' ▶ s' for any favourable Φ and some favourable Φ'.

By the premise of the rule
Φ'' ,α 
, we get that g
s' where Φ'' is such

(constServ)
that Φ' = У(Φ Λ Φ'', s', ∅). By rule
—————→
, g + g'	Φ'' ,α 

s'. Finally, by rule

'	Φ' ,α	'	'
(constServ), we can conclude Φ ▶ g + g >————→Φ ▶ s .
(delcom) In this case, s = [x] s1 and s' = s2 · {x '→ v}.	By the premise of
n {x'→v} 1 v
the rule (delcom), s1 —————————→ s2.	By induction, we get that Φ ▶ s1 >

Φ' , n {x'→v} 1 v
——————————→ Φ
▶ s2 for any favourable Φ and some favourable Φ'. By the
Φ'' , n {x'→v} 1 v

premise of rule (constServ), we get that s1 ———————————→ s2 and, by rule (delcom),
Φ'' , n ∅ 1 v
[x] s1 ————————→ s2 · {x '→ v}. Finally, by rule (constServ), we can conclude.
(delkill1), (delkill2), (delkill3), (del), (cong), (prot), (parkill), (par), (parcom) These cases are

similar to the previous one; the latter case relies on the fact that noConf(s2, n, v, 1) = true implies that confRec(s2, n) = {vi}i∈I such that v /= vi for all i ∈ I.
(com) First, we consider the case α = n ∅ 0 v. By the premises of rule (com), s = (s1 |

s ), s' = (s'
| s' ), s
n Q v
s' and s
n Q v
s' . By induction, we get that

2	1	2
1 ————→ 1
2 ————→ 2

Φ' , n Q v
Φ1 ▶ s1>———1 ———→Φ'
▶ s'
Φ' , n Q v
and Φ2 ▶ s2 >———2 ———→ Φ'
▶ s' , for any favourable

conditions Φ1 and Φ2, and some favourable Φ' and Φ' . By the premises of rules

(constServ) and (constServ

inv
), we get that s1
Φ'' , n Q v
———1 ————→ s'
and s2
Φ'' , n Q v
———2 ————→ s' ,

where conditions Φ'' and Φ'' are such that Φ' = У(Φ1 ΛΦ'', s' , ∅) and Φ'
= У(Φ2 Λ

1	2	1	1	1	2

Φ'', s' , ∅). By rule
, s  | s
Φ' , n ∅ 0 v
s' | s' , where Φ' = Φ'' Λ Φ'' Λ n =

2	2	(s-com)	1	2 ———————→ 1	2	1	2

n Λ v = v. Finally, by rule (constServ), we can conclude that Φ ▶ s1
Φ'' , n ∅ 0 v
| s2 >———————→

Φ'' ▶ s'
| s' , where Φ'' = У(Φ Λ Φ', s'
| s' , ∅). The case α = n σ 1 v proceeds as

1	2	1	2
above, by also relying on the fact that noConf(s1 | s2, n, v, 1) = true implies that
confRec(s1 | s2, n)= {vi}i∈I with v /= vi for all i ∈ I.
Consider now the “only if” part of the theorem. By the premises of rules (con-

Φ'' ,α	'	'
''	'

stServ) and (constServinv), we get that s —————→ s where Φ
= У(Φ Λ Φ ,s , ∅). By

hypothesis S(Φ') /= false, hence S(Φ'') /= false too. The proof proceeds by induc-

Φ'' ,α 
tion on the length of the inference of s —————→
s'. We omit the details because the

proof proceeds as that of the “if” part, but the steps are executed in the reverse order. For the base case, we reason by case analysis on the axioms of the symbolic operational semantics. We take a look at one base case:
(s-rec) In this case, Φ'' = true, α = n D w and s = n?w.s'. Trivially, by rule (rec),

n Q w
—————→
s'.

For the inductive step, we reason by case analysis on the last applied inference rule of the symbolic operational semantics. We take a look at two cases:
'	Φ'' ,α	'
(s-choice) In this case, s = g + g . By the premise of the rule (s-choice), g —————→ s .

α
By induction, we get that g ——→
s'. Finally, by rule (choice), we can conclude

g + g'	α
s'.

(s-com) In this case, s = (s1 | s2), Φ'' = (Φ1 Λ Φ2 Λ n = n Λ v /= confRec(s1 | s2, n)),
α = n {x '→ v} 1 v and s' = (s' | s' ). Since S(Φ'') /= false, we get that S(Φ1) /=
false , S(Φ2) /= false and confRec(s1 | s2, n) = {vi}i∈I such that v /= vi for all
i ∈ I. This means that noConf(s1 | s2, n, v, 1) holds true. By induction and since

S(Φ ) /= false and S(Φ ) /= false, we have that s
n Q x
s' and s
n Q v
s' .

1	2	1 —————→ 1	2 ————→ 2

Thus, by rule (com), we can conclude that s1
n {x'→v} 1 v
| s2 —————————→
' | s' .	 


Examples
In this section, we show some simple examples aimed at clarifying some peculiarities of COWS symbolic semantics. In the sequel, for the sake of readability, we shall

evaluate conditions, writing e.g. x /= n instead of (p = p Λ o = o Λ true Λ x /= n).

External communication
According to the operational semantics introduced in Section 3, the service
[x] n?x. m!x is blocked (because it cannot perform the receive activity). Instead, according to the symbolic semantics defined in this section, the constrained service true ▶ [x] n?x. m!x can evolve as follows:


n?x. m!x  true , n Q x
(s-rec)


(s-reccom)

[x] n?x. m!x	x/=confRec((n?x. m!x),n) Λ x/=bn , n Q[x]
x/=bn , n Q[x]
true ▶ [x] ?x. !x >—————————→ x /= bn ▶ !x

(constServ)

since (x /= confRec((n?x. m!x), n)) = (x /= ∅) = true. Then, the continuation can perform the following transition:


[[x]] = (true, x)

true , mQ x
 ————————→ 0
x/=bn , mQ x

(s-inv)



(constServinv)

x /= bn ▶ m!x >————————→ x /= bn ▶ 0
Notice that, although the external communication generates the condition x /= bn (that means that the received unknown value must be different from all delimited names), the condition is never exploited because the term does not contain delimited names.

External communication within name delimitations
Consider the constrained service true ▶ [n] [x] n?x. x • o!n. Differently from the previous example, the above service contains a delimited name (i.e. n). Thus, this time, condition x /= bn is exploited to generate the specific condition x /= n. Indeed, the service evolves as follows:




true , n Q x
?x. x • o!n ————————→ x • o!n
(s-rec)


(s-reccom)

x/=confRec((n?x. x • o!n),n) Λ x/=bn , n Q[x]
[x] n?x. x • o!n ————————————————————————————→ x • o!n

x/=confRec((n?x. x • o!n),n) Λ x/=bn , n Q[x]
[n] [x] n?x. x • o!n ————————————————————————————→ [n] x • o!n
x/=n Λ x/=bn , n Q[x]

(s-delpass)

(constServ)

true ▶ [n] [x] n?x. x • o!n >—————————————→ x /= n Λ x /= bn ▶ [n] x • o!n
since (x /= confRec((n?x. x • o!n), n)= true and У(x /= bn, ([n] [x] n?x. x • o!n), ∅)= x /= n Λ x /= bn. Then, the continuation can evolve only provided that condition x /= n holds.

Internal communication
Consider the constrained service true ▶ [p] [x]( p • o?x. n!x | p • o!v ), where p ∈/ n. In this case, due to the delimitation [p] , the receive activity cannot communicate with the environment, but can synchronize with the internal invoke:




true ,p • o Qx
p • o?x. !x —————————→ !x

(s-rec)
[[v]] = (true, v)

true ,p • oQv
p • o!v —————————→ 0

(s-inv)

(s-com)

Φ ,p • o {x'→v} 1 v
p • o?x. !x | p • o!v ————————————→ !x


Φ ,p • o $ 1 v
[x]( p • o?x. !x | p • o!v ) —————————→ !x · {x '→ v}


Φ ,p • o $ 1 v
[p] [x]( p • o?x. !x | p • o!v ) —————————→ [p] !v ≡ !v

Φ ,p • o $ 1 v
[p] [x]( p • o?x. !x | p • o!v ) —————————→ !v
Φ ,p • o $ 1 v

(s-delcom) (s-delpass) (s-cong)
(constServ)

true ▶ [p] [x]( p • o?x. n!x | p • o!v ) >————————→ Φ ▶ n!v

where Φ = ( true Λ true Λ p = p Λ o = o Λ v /= confRec(p • o?x. n!x | p • o!v, p • o) ). Since confRec(p • o?x. n!x | p • o!v, p • o)= ∅, condition Φ holds true.


External and internal communication
Consider the constrained service true ▶ [x]( n?x. m!x | n!v ). In this case, both internal and external communication can take place. Its initial transitions are the following ones:
x/=bn , n Q[x]
(ext. com.)	true ▶ [x]( ?x. !x | !v ) >—————————→ x /= bn ▶ !x | !v
true , n Q v
(ext. com.)	true ▶ [x]( ?x. !x | !v ) >———————→ true ▶ [x]( ?x. !x )
Φ , n $ 1 v
(int. com.)	true ▶ [x]( ?x. !x | !v ) >——————→ Φ ▶ !v
where Φ = ( true Λ true Λ n = ce Λ v /= confRec(n?x.m!x | n!v, n) ).  Since
confRec(n?x.m!x | n!v, n)= ∅, condition Φ holds true.


Conflicting receive
Consider the constrained service true ▶ [x]( n?v | n?x | n!v ). Due to the presence of the receive n?v, that has greater priority to synchronize with an invocation n!v, the receive n?x can communicate with the environment only if the received value is not v (indeed, confRec((n?v | n?x | n!v), n)= {v} ):
x/=bn Λ x/=v, n Q[x]
true ▶ [x]( ?v | ?x | !v ) >—————————————→ x /= bn Λ x /= v ▶ ?v | !v
Other possible transitions are as follows:

true , n Q v
true ▶ [x]( ?v | ?x | !v ) >———————→ true ▶ [x]( ?v | ?x )
true , n Q v
true ▶ [x]( ?v | ?x | !v ) >———————→ true ▶ [x]( ?x | !v )
true , n $ 0 v
true ▶ [x]( ?v | ?x | !v ) >————————→ true ▶ [x] ?x

On constrained services
Consider the (plain) service [x, y]( n?q | n?x | x • o!v | q • o?y ) where n /= q • o. It can perform the following transition:

x/=bn Λ x/=q, n Q[x]
[x, y]( ?q | ?x | x • o!v | q • o?y ) ——————————————→ [y]( ?q | x • o!v | q • o?y )
The obtained service can further perform the following transition:

x=q, q • o $ 1 v
[y]( ?q | x • o!v | q • o?y ) ——————————→ ?q

Condition x = q of this transition contradicts condition x /= q of the previous one, but the service can however evolve. Instead, by considering constrained services, we would have:
x/=bn Λ x/=q, n Q[x]
true ▶ [x, y]( ?q | ?x | x • o!v | q • o?y ) >—————————————→
x=q Λ x/=bn Λ x/=q, q • o $ 1 v
x /= bn Λ x /= q ▶ [y]( ?q | x • o!v | q • o?y ) >——————————————————→ false ▶ ?q

because x = q Λ x /= q holds false , and the second transition could not be performed. That’s why we resort to constrained services.

Evaluation function, condition x /∈ uv and assumption on bound variables Consider the service s   [y, z]( n!(5 + x) | n?y.s' | m?z. m'!z' ), where n, m and m' are pairwise distinct. If [5 + x]] = ((r /= bn Λ r /∈ uv Λ r =5 + x), r) then
(r/=bn Λ r/∈uv Λ r=5+x) , n Q r
 ————————————————————→ 0

Therefore, the constrained service x /= bn Λ x' /= bn Λ z' /= bn ▶ s can evolve as follows:
'	'	Φ' , n $ 1 r	'	'	'  '
x /= bn Λ x /= bn Λ z /= bn ▶ s >———————→ Φ ▶ [z] (s · {y '→ r} | m?z. m !z )
`	˛¸	x
s''

for Φ' = У((x /= bn Λ x' /= bn Λ z' /= bn Λ r /= bn Λ r /∈ uv Λ r = 5 + x), s'', {x, x', z'})= (x /= bn Λ x' /= bn Λ z' /= bn Λ r /= bn Λ r ∈/ {x, x', z'} Λ r = 5+ x). Now, we cannot alpha-convert variable z into r, because we would violate the assumption that bound variables differ from variables corresponding to unknown values (in this case, variable z must be different from r because r is an unknown

value occurring in the constrained service). Similarly, if [5 + x]] = ((z /= bn Λ z /∈
uv Λ z =5 + x), z), then the constrained service would become
Φ'' ▶ [z] (s' · {y '→ z} | m?z. m'!z' )
for some Φ'', and the assumption would be violated again (because the service contains both z and z). Finally, if [[5 + x]] = ((z' /= bn Λ z' /∈ uv Λ z' = 5 + x), z'),
i.e. the unknown value returned by the evaluation function is not fresh, then the condition on the symbolic transition holds false , because z' /∈ {x, x', z'} does not hold.

Symbolic semantics for COWS with polyadic commu- nication
In this section, we present an extension of COWS symbolic semantics for dealing with polyadic communication. We first extend the syntax of invoke and receive activities as follows: u • u'!ϵ¯ stands for an invoke over the endpoint u • u' with parameter the tuple of expressions ϵ¯, while p • o?w.s stands for a receive over the endpoint p • o with parameter the tuple of variables/(unknown) values w and con- tinuation s. Tuples can be constructed using a concatenation operator defined as
⟨a1,... , an⟩ : ⟨b1,... , bm⟩ = ⟨a1,... , an, b1,... , bm⟩. To single out an element of a tuple, we will write (a¯, c, ¯b) to denote the tuple ⟨a1,... , an, c, b1,... , bm⟩, where a¯ or ¯b might not be present. We will use a¯i to denote the i-th element of the tuple a¯ and, when convenient, we shall regard a tuple simply as a set writing e.g. a ∈ ¯b to mean that a is an element of ¯b. Finally, we denote by v(t) the set of variables in t.
Φ ,α 
The labelled transition relation ————→ over services now is induced by the
modified rules shown in Table 9 (the remaining ones are those of Table 7, except for rule (s-match) which we do not need anymore), where:
conditions can also have the form Φ V Φ'; we will use x /= bn to denote condition
x1 /= bn Λ ... Λ xn /= bn for x = ⟨x1,... , xn⟩;
action labels are generated by the following grammar:
α  ::=	n  v	|	n [n¯] v	|	n D w	|	n D [x¯] w	|	n σlv	|	k	|	†

Φ ,α 
All the above definitions shall extend to relation >————→.
The new rules exploit a modified version of functions ł( , ) and noConf( , , , ) defined in Tables 3 and 4, now redefined by the rules in Table 10. The rules in the upper part of the table state that variables match any value, and two values v and v' do match only if condition v = v' holds. When tuples w and v do match, ł( w, v ) returns a pair (Φ, σ), where Φ is the condition so that the matching holds and σ is a substitution for the variables in w; otherwise, it is unde- fined. Function noConf(s, n, v, l) now returns a condition that guarantees absence of conflicts for the inferred transition. Basically, noConf(s, n, v, l) exploits function rec(s, n, v, l) to identify the conflicting receives of s, then for each argument w of



true , n Q w
v( w )= x¯
|x¯ | ≥ 1

n?w.s −−−−−−−−−→ s (s-rec)
x/=bn , n Q [x¯ ] w
n?w.s −−−−−−−−−−−−−→ s
(s-reccom)



Φ , n Q [x¯ ] w
s
[[є1]] = (Φ1, v  )  .. .  [[єn]] = (Φn, v  )

−−−−−−−−−−→ s
y ∈ x¯
(s-del	)
	1	n	 (s-inv)

Φ , n Q [x¯ ] w	'
sub1
n!⟨є , ... ,є 
Φ1 ∧ ... ∧ Φn , nQ (v1 ,...,v n ⟩	0

[y] s −−−−−−−−−−→ s · {y '→ y}
1	n⟩ −−−−−−−−−−−−−−−−−−−−−→




Φ , nQ v
s −−−−−−−→ s
n ∈ v n ∈/ n
Φ , nQ [m¯ ] v
s −−−−−−−−−→ s

n ∈ v n ∈/ n

Φ , nQ [n] v
[n] s −−−−−−−−−→ s
(s-open1)
Φ , nQ [(n⟩:m¯ ] v
[n] s −−−−−−−−−−−−→ s
(s-open2)


Φ1 , n Q w	'

Φ2 , n' Q v	'		'

s1 −−−−−−−−→ s1 s2 −−−−−−−−→ s2  M( w, v )= (Φ, σ) noConf (s1 | s2, n, v, | σ | )= Φ
(s-com)

'	'

s | s
Φ1 ∧ Φ2 ∧ n=n ∧ Φ ∧ Φ , n σ |σ | v
s' | s'

1	2 −−−−−−−−−−−−−−−−−−−−−−−−→ 1	2


Φ , n σ {x'→v} Æ v	'
Φ ,α 
s

s −−−−−−−−−−−−−−→ s
1 −−−−−→ s1 α /= k, n Q [x¯ ] w , n σl v

Φ , n σ Æ v	'
(s-delsub2)
Φ ,α	'
(s-par)

[x] s −−−−−−−−→ s · {x '→ v}
s1 | s2 −−−−−→ s1 | s2


Φ , n σ Æ v
s

1 −−−−−−−−→ s1	noConf (s2, n, v, l)= Φ
'
(s-parcom1)



Φ , n Q [x¯ ] w
s
s1 | s

'
Φ ∧ Φ , n σ Æ v
2 −−−−−−−−−−−→
s' | s2

'

1 −−−−−−−−−−→ s1	noConf (s2, n, w · {x¯ '→ x}, |x¯ | )= Φ
'	
(s-parcom2)

s1 | s
Φ ∧ Φ , n Q [x¯ ] w
2 −−−−−−−−−−−−−→
s' | s2


Table 9
Operational semantics of COWS with polyadic communication (excerpt of rules)

these receives it determines a condition (i.e. a logical disjunction of inequalities) that makes the conflicting matching between w and v false. Finally, it returns the logical conjunction of the determined conditions. We use the auxiliary function gval ( ) that, given a tuple w, returns a collection of pairs of the form (x, i), where x is an unknown value such that w i = x. Notably, if rec(s, n, v, l) = ∅ then func- tion noConf(s, n, v, l) returns the condition true, because there are not conflicting receives; while, if there is a w ∈ rec(s, n, v, l) such that gval ( w )= ∅, then the func- tion returns the condition false , because there are not conditions that can make the conflicting matching false.
We end this section with an example aimed at clarifying how pattern-matching and conflict checking functions work. Consider the following term:
n!⟨v1, v2, v3⟩| [x, y, z] n?⟨x, y, z⟩ | [x'] n?⟨x', y', z'⟩| [x'', y''] n?⟨x'', y'', z''⟩

In this case, the invoke activity n!⟨v1, v2, v3⟩ can synchronize with each receive ac- tivity of the term. Firstly, consider the receive n?⟨x, y, z⟩: its argument ⟨x, y, z⟩ matches the tuple ⟨v1, v2, v3⟩ by generating the substitution {x '→ v1,y '→ v2,z '→ v3}. The other two receive activities are in conflict, because they satisfy the match- ing with the invoke and generate substitutions with fewer pairs than 3. Thus, func-


M(x, v)= (true, {x '→ v})	M(v, v')= (v = v', $)	M(⟨⟩, ⟨⟩)= (true, $) M(a1, b1)= (Φ1, σ1) M(a¯2, ¯b2)= (Φ2, σ2)
M((a1, a¯2), (b1, ¯b2)) = (Φ1 Λ Φ2, σ1  σ2)

noConf (s, n, v, l)= Vw∈ rec(s,n,v,Æ)( W(x ,i)∈gval( w ) x /= v i Λ ( gval ( w )= $ ⇒ false ) ) 


rec(n?w.s, n, v, l)=	{ w } if M( w, v )= (Φ, σ) Λ |σ| < l 
$	otherwise
rec(0, n, v, l) = rec(kill(k), n, v, l) = rec(u!є¯, n, v, l) = $	rec(n'?w.s, n, v, l) = $ if n /= n'

rec([e] s, n, v, l)= rec(s, n, v, l) if e ∈/ n	rec([e] s, n, v, l)= $  if e ∈ n

rec(g + g', n, v, l)= rec(g, n, v, l) ∪ rec(g', n, v, l)	rec({|s|}, n, v, l)= rec(s, n, v, l)

rec(s | s', n, v, l)= rec(s, n, v, l) ∪ rec(s', n, v, l)	rec(∗ s, n, v, l)= rec(s, n, v, l)
Table 10
Modified matching and conflicting receives rules


tion rec( , , , ) applied to the whole term 4 returns the set {⟨x', y', z'⟩, ⟨x'', y'', z''⟩}. Then, function noConf( , , , ) returns the condition (y' /= v2 V z' /= v3) Λ z'' /= v3.
Hence, a transition of the term is

n!⟨v1, v2, v3⟩| [x, y, z] n?⟨x, y, z⟩ | [x'] n?⟨x', y', z'⟩| [x'', y''] n?⟨x'', y'', z''⟩

(y'/=v2 ∨ z'/=v3) Λ z''/=v3 , n $ 3 ⟨v1,v2,v3⟩	'
'	'	'
''	''
''	''	''

——————————————————————————→ [x ] n?⟨x , y , z  ⟩| [x ,y ] n?⟨x
,y , z  ⟩


Consider now the receive n?⟨x'', y'', z''⟩: in this case the matching function returns condition z'' = v3 and substitution {x'' '→ v1, y'' '→ v2}. Function rec( , , , ) applied to the whole term returns the set {⟨x', y', z'⟩}, because the only conflicting receive is n?⟨x', y', z'⟩. Thus, the corresponding transition is

n!⟨v1, v2, v3⟩| [x, y, z] n?⟨x, y, z⟩ | [x'] n?⟨x', y', z'⟩| [x'', y''] n?⟨x'', y'', z''⟩

(y'/=v2 ∨ z'/=v3) Λ z''=v3 , n $ 2 ⟨v1,v2,v3⟩
'	'	'	'

——————————————————————————→ [x, y, z] n?⟨x, y, z⟩ | [x ] n?⟨x , y , z  ⟩

Moreover, the receive activities can communicate with the environment; in this case the conflict checks are performed by rule (s-parcom2). For example, the transition


4 This means that the last rule applied in the inference is (s-com). Of course, the last rule could be also (s-parcom1); in this case, two or three conflict checks will be performed on subterms of the considered service.

corresponding to the execution of n?⟨x, y, z⟩ is
n!⟨v1, v2, v3⟩| [x, y, z] n?⟨x, y, z⟩ | [x'] n?⟨x', y', z'⟩| [x'', y''] n?⟨x'', y'', z''⟩
x/=bn Λ y/=bn Λ z/=bn Λ (y'/=y ∨ z'/=z) Λ z''/=z , n Q [⟨x,y,z⟩] ⟨x,y,z⟩
		
——————————————————————————————————————————→
n!⟨v1, v2, v3⟩| [x'] n?⟨x', y', z'⟩| [x'', y''] n?⟨x'', y'', z''⟩
Finally, as another example consider the following term:
n!⟨v1, v2, v3⟩| [x, y, z] n?⟨x, y, z⟩ | [x'] n?⟨x', v2, v3⟩
If we try to infer the transition corresponding to the communication between n!⟨v1, v2, v3⟩ and n?⟨x, y, z⟩, we have that the condition on the transition label is false , because function rec( , , , ) returns ⟨x', v2, v3⟩ and gval (⟨x', v2, v3⟩)= ∅.

Related work and concluding remarks
Symbolic semantics and symbolic bisimulation were first introduced in [14] by Hen- nessy and Lin on value-passing process algebras. The symbolic approach has been then applied to π-calculus in [25] by Sangiorgi and in [5] by Boreale and De Nicola. Victor has adopted a similar approach in [26] to efficiently characterise hyperequiv- alence for the fusion calculus. A more recent work on a symbolic semantics for a fusion-based calculus is [7] by Buscemi and Montanari. A revisited symbolic tech- nique for π-calculus has been recently proposed in [3] by Bonchi and Montanari.
COWS is a process calculus introduced in [17] for specifying and combining service-oriented applications, while modelling their dynamic behaviour. Since its definition, a number of methods and tools have been devised to analyse COWS specifications, such as a type system to check confidentiality properties [18], a logic and a model checker to express and check functional properties of services [12], a stochastic extension to enable quantitative reasoning on service behaviours [23], a static analysis to establish properties of the flow of information between services [2], and bisimulation-based observational semantics to check interchangeability of services and conformance against service specifications [24]. An overview of some of the above tools, with an application to the analysis of a case study, can be found in [19].
We believe that the alternative symbolic operational semantics defined in this paper can pave the way for the development of efficient model and equivalence checkers for COWS. In fact, the model checking approach of [12] does not support a fully compositional verification methodology. It allows to analyse systems of services ‘as a whole’, but does not enable analysis of services in isolation (e.g. a provider service without a proper client). The symbolic operational semantics should permit to overcome this limitation that is somewhat related to the original semantics of COWS which, although based on an LTS, follows a reduction style. Furthermore, the symbolic operational semantics can be used to improve efficiency of checking the equivalences introduced in [24]. This, of course, requires defining

alternative characterizations of the equivalences on top of the symbolic transition system. We plan to pursue these lines of research in the near future, and in particular to implement the operational semantics and equivalence and model checkers on top of it.

Acknowledgement
We thank the anonymous referees for their useful comments.

References
R.M. Amadio, I. Castellani, and D. Sangiorgi. On bisimulations for the asynchronous pi-calculus.
Theor. Comput. Sci., 195(2):291–324, 1998.
J. Bauer, F. Nielson, H.R. Nielson, and H. Pilegaard. Relational analysis of correlation. In Mar´ıa Alpuente and Germ´an Vidal, editors, The 15th International Static Analysis Symposium (SAS’08), volume 5079 of Lecture Notes in Computer Science, pages 32–46. Springer, 2008.
F. Bonchi and U. Montanari. Symbolic semantics revisited. In FoSSaCS, volume 4962 of LNCS, pages 395–412. Springer, 2008.
M. Boreale, R. Bruni, R. De Nicola, and M. Loreti. Sessions and pipelines for structured service programming. In G. Barthe and F.S. de Boer, editors, FMOODS, volume 5051 of LNCS, pages 19–38. Springer, 2008.
M. Boreale and R. De Nicola. A symbolic semantics for the pi-calculus. Inf. Comput., 126(1):34–52, 1996.
R. Bruni, I. Lanese, H.C. Melgratti, and E. Tuosto. Multiparty sessions in SOC. In D. Lea and
G. Zavattaro, editors, COORDINATION, volume 5052 of LNCS, pages 67–82. Springer, 2008.
M. Buscemi and U. Montanari. Open Bisimulation for the concurrent Constraint Pi-Calculus. In
ESOP, volume 4960 of LNCS, pages 254–268. Springer, 2008.
N. Busi, R. Gorrieri, C. Guidi, R. Lucchi, and G. Zavattaro. Choreography and orchestration conformance for system design. In COORDINATION, volume 4038 of LNCS, pages 63–81. Springer, 2006.
M.J. Butler, C.A.R. Hoare, and C. Ferreira. A trace semantics for long-running transactions. In 25 Years Communicating Sequential Processes, volume 3525 of LNCS, pages 133–150. Springer, 2005.
M. Carbone, K. Honda, and N. Yoshida. Structured communication-centred programming for web services. In ESOP, volume 4421 of LNCS, pages 2–17. Springer, 2007.
R. De Nicola and F. Vaandrager. Three logics for branching bisimulation. J. ACM, 42(2):458–487, 1995.
A. Fantechi, S. Gnesi, A. Lapadula, F. Mazzanti, R. Pugliese, and F. Tiezzi. A model checking approach for verifying COWS specifications. In FASE, volume 4961 of LNCS, pages 230–245. Springer, 2008.
C. Guidi, R. Lucchi, R. Gorrieri, N. Busi, and G. Zavattaro. SOCK: a calculus for service oriented computing. In ICSOC, volume 4294 of LNCS, pages 327–338. Springer, 2006.
M. Hennessy and H. Lin. Symbolic bisimulations. Theor. Comput. Sci., 138(2):353–389, 1995.
I. Lanese, V. Vasconcelos, F. Martins, and A. Ravara. Disciplining orchestration and conversation in service-oriented computing. In Int. Conf. on Software Engineering and Formal Methods (SEFM’07), pages 305–314. IEEE Computer Society, 2007.
C. Laneve and G. Zavattaro. Foundations of web transactions. In FoSSaCS, volume 3441 of LNCS, pages 282–298. Springer, 2005.
A.	Lapadula,	R.	Pugliese,	and	F.	Tiezzi. A calculus for orchestration of web services. Technical report, DSI, Univ. Firenze, 2007. Available at http://rap.dsi.unifi.it/cows/papers/cows-esop07-full.pdf . An extended abstract appeared in Proc. of ESOP’07, LNCS 4421, pages 33-47, Springer.

A. Lapadula, R. Pugliese, and F. Tiezzi. Regulating data exchange in service oriented applications. In
FSEN, volume 4767 of LNCS, pages 223–239. Springer, 2007.
A. Lapadula, R. Pugliese, and F. Tiezzi. Specifying and analysing soc applications with cows. In
Concurrency, Graphs and Models, volume 5065 of LNCS, pages 701–720. Springer, 2008.
M. Merro and D. Sangiorgi. On asynchrony in name-passing calculi. Mathematical Structures in Computer Science, 14(5):715–767, 2004.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, I and II. Inf. Comput., 100(1):1– 40, 41–77, 1992.
OASIS	WSBPEL	TC.	Web	Services Business Process Execution Language Version 2.0. Technical report, OASIS, April 2007. Available at http://docs.oasis-open.org/wsbpel/2.0/OS/wsbpel-v2.0-OS.html .
D. Prandi and P. Quaglia. Stochastic COWS. In ICSOC, volume 4749 of LNCS, pages 245–256. Springer, 2007.
R.	Pugliese,	F.	Tiezzi, and N. Yoshida. On observing dynamic prioritised actions in SOC. Technical report, DSI, Univ. Firenze, 2008. Available at http://rap.dsi.unifi.it/cows/papers/bis4cows-full.pdf .
D. Sangiorgi. A theory of bisimulation for the pi-calculus. Acta Inf., 33(1):69–97, 1996.
B. Victor. Symbolic Characterizations and Algorithms for Hyperequivalence. Technical Report DoCS 98/96, Uppsala University, December 1998.
H.T. Vieira, L. Caires, and J. Costa Seco. The conversation calculus: A model of service-oriented computation. In S. Drossopoulou, editor, Programming Languages and Systems (ESOP’08), volume 4960 of LNCS, pages 269–283. Springer, 2008.
