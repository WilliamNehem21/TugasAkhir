Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 302 (2014) 155–176
www.elsevier.com/locate/entcs

A Framework to Generate Synthetic Multi-label Datasets
Jimena Torres Tomas1,a,2 Newton Spolaˆora,3 Everton Alvares Chermana,4 Maria Carolina Monarda,5
a Laboratory of Computational Intelligence Institute of Mathematics and Computer Science University of Sa˜o Paulo
13560-970 S˜ao Carlos, SP, Brazil

Abstract
A controlled environment based on known properties of the dataset used by a learning algorithm is useful to empirically evaluate machine learning algorithms. Synthetic (artificial) datasets are used for this purpose. Although there are publicly available frameworks to generate synthetic single-label datasets, this is not the case for multi-label datasets, in which each instance is associated with a set of labels usually correlated. This work presents Mldatagen, a multi-label dataset generator framework we have implemented, which is publicly available to the community. Currently, two strategies have been implemented in Mldatagen: hypersphere and hypercube. For each label in the multi-label dataset, these strategies randomly gener- ate a geometric shape (hypersphere or hypercube), which is populated with points (instances) randomly generated. Afterwards, each instance is labeled according to the shapes it belongs to, which defines its multi-label. Experiments with a multi-label classification algorithm in six synthetic datasets illustrate the use of Mldatagen.
Keywords: data generator, artificial datasets, multi-label learning, publicly available framework, Java, PHP


Introduction
Classical supervised learning algorithms are single-label, in which only one label from a disjoint set of labels L is associated to each example in the dataset. If L = 2, the task is called binary classification, and it is called multi-class classification if

1 This research was supported by the S˜ao Paulo Research Foundation (FAPESP), grants 2011/02393-4, 2010/15992-0 and 2011/12597-6. The authors would like to thank Victor Augusto Moraes Carvalho for his help in additional analysis, as well as the anonymous reviewers for their helpful comments.
2 Email: jimenat.tomas@gmail.com
3 Email: newtonspolaor@gmail.com
4 Email: echerman@icmc.usp.br
5 Email: mcmonard@icmc.usp.br

http://dx.doi.org/10.1016/j.entcs.2014.01.025
1571-0661 © 2014 Elsevier B.V. Open access under the CC BY-NC-ND license.

L > 2. However, an increasing number of applications in which examples are anno- tated using more than one label, such as bioinformatics, emotion analysis, semantic annotation of media and text mining [15], requires different algorithms to extract patterns from data. These applications, in which the examples can be associated to several labels simultaneously, characterize a multi-label learning problem.
In practice, the effectiveness of machine learning algorithms depends on the quality of the generated classifiers. This makes fundamental research in machine learning inherently empirical [6]. To this end, the community carries out exten- sive experimental studies to evaluate the performance of learning algorithms [9]. Synthetic (artificial) datasets are useful in these empirical studies, as they offer a controlled environment based on known properties of the dataset used by the learn- ing algorithm to construct the classifier [2]. A good classifier is generally considered to be one that learns to correctly identify the label(s) of new examples with a high probability. Thus, synthetic datasets can be used instead of real world datasets to derive rigorous results for the average case performance of learning algorithms.
Several frameworks to generate synthetic single-label datasets are publicly avail- able to the community 6 7 8 . However, despite some proposals of strategies to generate synthetic multi-label datasets [17,18,3,11], to the best of our knowl- edge, there is a lack of publicly available frameworks to generate data for multi- label learning. Thus, this work contributes to bridging this gap by proposing the Mldatagen framework, which we have implemented and it is hosted at http:
//sites.labic.icmc.usp.br/mldatagen.
The remainder of this work is organized as follows: Section 2 briefly de- scribes multi-label learning concepts and strategies to generate synthetic multi-label datasets. The proposed framework is presented in Section 3 and illustrated in Sec- tion 4. Section 5 presents the conclusions and future work.
Background
This section presents basic concepts and terminologies related to multi-label learn- ing, including the evaluation measures used in this work, as well as some strategies proposed in the literature to generate synthetic multi-label datasets.
Basic concepts of multi-label learning
Let D be a dataset composed of N examples Ei = (xi, Yi), i = 1..N . Each example (instance) Ei is associated with a feature vector xi = (xi1, xi2,..., xiM ) described by M features (attributes) Xj, j = 1..M , and a subset of labels Yi ⊆ L, where L = {y1, y2,... yq} is the set of q labels. Table 1 shows this representation. In this scenario, the multi-label classification task consists in generating a classifier H which, given an unseen instance E = (x, ?), is capable of accurately predicting its subset of labels (multi-label) Y , i.e., H(E) → Y .

6  http://archive.ics.uci.edu/ml/machine-learning-databases/dgp-2
7 http://www.datasetgenerator.com
8 http://www.burningart.com/meico/inventions/datagen/index.html


Table 1 Multi-label data.











Multi-label learning methods can be organized into two main categories: algo- rithm adaptation and problem transformation [15]. The first one consists of methods which extend specific learning algorithms to handle multi-label data directly, such as the Multi-label Naive Bayes (MLNB) algorithm [18]. The second category is algorithm independent, allowing one to use any state of the art single-label learn- ing method. Methods which transform the multi-label classification problem into several single-label classification problems, such as the Binary Relevance (BR) ap- proach, fall within this category. Specifically, BR transforms a multi-label dataset into q single-label datasets, classifies each single-label problem separately and then combines the outputs.





Evaluation measures
The evaluation of single-label classifiers has only two possible outcomes, correct or incorrect. However, evaluating multi-label classification should also take into account partially correct classification. To this end, several multi-label evaluation measures have been proposed, as described in [15]. In what follows, we briefly describe the example-based and label-based evaluation measures used in this work. All these performance measures range in [0..1].
Example-based evaluation measures Let Δ be the symmetric difference between two sets; Yi and Zi be, respectively, the set of true and predicted labels; I(true) = 1 and I(false) = 0. The Hamming-Loss, Subset-Accuracy , Precision, Recall and Accuracy measures are defined by Equations 1 to 5.

1
Hamming Loss(H, D)= 
N
N
N
YiΔZi .	(1)
|L|
i=1

1
Subset Accuracy(H, D)= 
N
I(Zi
i=1
N
= Yi).	(2)

1
Precision(H, D)= 
N
1
Recall(H, D)= 
N
1
Accuracy(H, D)= 
N
|Yi ∩ Zi| .	(3)
|Z |
i=1
N
Yi   Zi .	(4)
|Y |
i=1
N
Yi   Zi .	(5)
|Y ∪ Z |
i=1

Unlike all other evaluation measures described in this section, for Hamming-Loss, the smaller the value, the better the multi-label classifier perfor- mance is. Moreover, it is worth observing that Subset-Accuracy is a very strict evaluation measure as it requires an exact match of the predicted and the true set of labels.
Label-based evaluation measures In this case, for each single-label yi ∈ L, the q binary classifiers are initially evaluated using any one of the binary evaluation measures proposed in the literature, such as Accuracy, F-Measure, ROC and others, which are afterwards averaged over all labels. Two averaging operations, macro- averaging and micro-averaging, can be used to average over all labels.
Let B(TPy , FPy , TNy , FNy ) be a binary evaluation measure calculated for a
i	i	i	i
label yi based on the number of true positive (TP ), false positive (FP ), true nega-
tive (TN ) and false negative (FN ). The macro-average version of B is defined by Equation 6 and the micro-average by Equation 7.


1
Bmacro =

B  TPy , FPy , TNy , FNy

.	(6)


 Σq

q
i=1
Σ

i	i	i	i

Σ	Σ	 
			

	

Thus, the binary evaluation measure used is computed on individual labels first and then averaged for all labels by the macro-averaging operation, while it is com- puted globally for all instances and all labels by the micro-averaging operation. This means that macro-averaging would be more affected by labels that partici- pate in fewer multi-labels, i.e., fewer examples, which is appropriate in the study of unbalanced datasets [5].
In this work, we use Precision (PC), Recall (RL) and F-Measure (FM), defined by Equations 8 to 10 respectively, as binary evaluation measures.
PC(H, D)= 	TP	.	(8)	RL(H, D)= 	TP	.	(9)
TP + FP	TP + FN


FM (H, D)= 	2TP	.	(10) 2TP + FP + FN

Strategies to generate synthetic multi-label datasets
As already mentioned, few strategies to generate synthetic multi-label datasets have been proposed in the literature. In what follows, some of these strategies are briefly described.
In [3] it is proposed to build a synthetic multi-label dataset based on specific functions to label instances which extends an earlier proposal for single-label learn- ing [1]. Many of the M = 9 features of the dataset are defined according to uniform distribution.
Synthetic datasets with different properties are generated in [11] to study multi- label decision trees. In this study, the power to identify good features, related to the feature selection task [10], was also verified. The strategy used to generate the datasets considers several functions to define feature values related to the labels.
To illustrate a new multi-label learning algorithm, a synthetic dataset is specified in [17]. Given three labels and a covariance matrix, instances are labeled according to seven Gaussian distributions, such that each distribution is related to one multi- label. The number of instances per multi-label is arbitrarily defined.
Hyperspheres are used to generate twelve synthetic datasets in [18]. First, a
M
hypersphere HS with radius r is generated in R 2 . For each label in a dataset,
a smaller hypersphere hsi, i = 1..q, is also randomly generated. Then, the small hyperspheres are populated with points (instances) randomly generated. The di-

mension of these points increases by adding M
irrelevant features, with random

values, and M
redundant ones, which copy the original features. Finally, each in-

stance Ei is labeled according to the small hyperspheres it belongs to, which define the multi-label Yi.

Synthetic multi-label dataset generator proposed
This section describes in detail the two strategies we have implemented to generate multi-label synthetic datasets, HyperSpheres and HyperCubes, which are based on the proposal presented in [18]. These two strategies are integrated in the framework Mldatagen, implemented in Java 9 and PHP 10 .
The framework outputs a compressed file which contains a noiseless synthetic dataset with the characteristics specified by the user, as well as similar datasets in which noise has been inserted. Mldatagen will generate as many datasets with noise as the number of different noise levels requested by the user. Each dataset is in the Mulan format 11 , which consists of two files: an ARFF file and a XML file. These

9 http://www.oracle.com/technetwork/java/index.html
10 http://php.net
11 http://mulan.sourceforge.net/format.html

files can be directly submitted to the multi-label learning algorithms available in the Mulan library [16].



The HyperSpheres strategy
This strategy has 9 input parameters to generate datasets with M = Mrel + Mirr +
Mred features.
Mrel - Number of relevant features.
Mirr - Number of irrelevant features.
Mred - Number of redundant features.
q - Number of labels in the dataset.
N - Number of instances in the dataset.
maxR - Maximum radius of the small hyperspheres.
minR - Minimum radius of the small hyperspheres.
μ - Noise level(s).
name - Name of the relation in the header of the ARFF file.
As mentioned, a dataset with noise is generated by Mldatagen for each noise level. Moreover, the optional parameters maxR, minR, μ and name have default values in Mldatagen, as described in Section 3.3.
To prevent the user setting invalid values, the following constraints are assigned to the parameters.
Mrel > 0	q > 0	minR > 0	minR < maxR ≤ 0.8
Mirr ≥ 0	N > 0	μ ≥ 0	0 < minR ≤	10
q
Mred ≥ 0	maxR > 0	Mred ≤ Mrel
It should be emphasized that Mldatagen extends the strategy proposed in [18] by enabling the user to choose the number of different kinds of features, i.e., rel- evant, irrelevant and redundant, the maximum and minimum radius of the small hyperspheres, as well as the noise level of the datasets generated.
The main steps to generate the synthetic datasets are:
Generating the hypersphere HS in RMrel .
Generating the q small hyperspheres hsi, i = 1..q inside HS.
Generating the N points (instances) in RM .
Generating the multi-labels based on the q small hyperspheres and inserting the noise level(s) μ.
In what follows, each of these steps is described in detail.

Generating the hypersphere HS
A hypersphere HS in RMrel , centered on the origin of the Cartesian coordinate system and with radius rHS = 1, is created.

Generating the q small hyperspheres
All the small hyperspheres are generated in such a way that they are inside the hypersphere HS in RMrel . In addition, each hypersphere hsi = (ri, Ci) is defined by a specific radius ri and center Ci = (ci1, ci2, ci3,..., ciMrel ). This radius is randomly generated and ranges from minR to maxR. On the other hand, the Ci coordinates must fulfill the initial requirement defined by Equation 11 to generate hsi inside HS.

∀ i ∈ [1..q] cij ≤ (1 − ri),j = 1..Mrel.	(11)
Nevertheless, this requirement is insufficient to ensure that hsi is inside HS. For example, if a value ci1 = (1 −ri) were generated, the other cij values for j /=1 would be zero, i.e., the remaining Mrel − 1 features have to be zero. Thus, all coordinates of each Ci, i = 1..q, must range in the restricted domain defined by Equation 12.
Mrel
cij2 ≤ (1 − ri)2.	(12)
j=1
The filled area in Figure 1 shows the domain of the Ci coordinates of a hyper- sphere hsi for Mrel = 2, such that hsi is inside HS.

Fig. 1. Domain to define Ci, given ri, in R2

As specified in Equation 12, setting the coordinates of Ci, i = 1..q, must take into account its radius ri, as well as the already set coordinate values of the hsi hypersphere center. This requirement is defined by Equation 13 for each randomly generated coordinate cij, j = 1..Mrel, in which only coordinates cis, s /= j, already set are considered.

−, ,(1 − ri)2 −

Mrel
(cis)2 ≤ cij ≤ , ,(1 − ri)2 −

Mrel

(cis)2.	(13)

	

As the possible range to define each coordinate of Ci reduces whenever a new coordinate is set, it is necessary to avoid determinism during the generation of the Ci coordinates of the hypersphere hsi, i.e., to avoid always generating ci1 as the first coordinate and ciMrel as the last one. To this end, the index of the coordinates j to be set, j = 1..Mrel, is randomly defined.
Algorithm 1 summarizes the generation of the hyperspheres hsi = (ri, Ci), i =
1..q. In this algorithm, the function random(x, y) outputs a value ranging from x to y according to the uniform distribution. The functions updateminC(x) and updatemaxC(x) respectively refresh the lower and upper bounds of the next Ci coordinate to be defined using Equation 13. These procedures are useful to avoid generating instances with empty multi-labels.

Algorithm 1 Generation of the small hyperspheres
1: for i =1 → q do
2:   Ci →∅ 
3:	ri → random(minR, maxR)
4:	maxC → (1 − ri)
5:	minC → −(1 − ri)
6:	for j =1 → Mrel (j randomly defined) do
7:	cij → random(minC, maxC)
8:	Ci → Ci ∪ {cij}
9:		minC → updateminC(minC) 10:		maxC → updatemaxC(maxC) 11:	end for
12:	hsi → (ri, Ci)
13: end for
14: return {hs1, hs2,..., hsq}


Generating the points
After defining the q small hyperspheres, the main hypersphere HS is populated with N points (instances). Recall that in each instance Ei = (xi, Yi), i = 1..N , xi denotes the vector of feature values and Yi ⊆ L the multi-label of the instance. Thus, to populate HS in RM , it is required to generate the values (xi1, xi2,..., xiM ) and the multi-label Yi for each instance Ei.
To ensure that the multi-labels contain at least one of the q possible labels, the generation of the N instances is oriented, such that, for each instance Ei, the point with coordinates (xi1, xi2,..., xiMrel ) is at least inside one small hypersphere. By using this procedure, none of the instances will have an empty multi-label. All small hyperspheres hsi, i = 1..q, are populated using this criterion.
Moreover, as the radiuses of the small hyperspheres are different, the distribution (balance) of instances in each hypersphere should be kept, i.e., an hypersphere with greater radius should be proportionally more crowded than an hypersphere with smaller radius. To this end, the framework uses the balance factor defined by Equation 14. Therefore, Ni = round(f × ri) points are generated inside each

hypersphere hsi, i = 1..q.


N
f =	q
i=1
.	(14)
ri

As the procedure to generate the small hypersphere centers does, a random point xk = (xk1, xk2,..., xkMrel ) inside hsi = (ri, Ci) must be generated obeying the restrictions given by Equation 15.
Mrel
2	2
i
j=1
However, the domain to generate the xk coordinates is different, and is reduced to the region inside hsi. As the hsi center is not on the origin, it is required to take into account the coordinates of this center. Figure 2 exemplifies, for Mrel = 2, that a random point xk must be inside the filled area to belong to the hypersphere hsi = (ri, Ci).

Fig. 2. Domain to define xk, given ri and Ci, in R2
Therefore, to randomly generate each coordinate xkj , j = 1..Mrel, of point xk, it is required to assure that |xkj − cij| ≤ ri. However, in an extreme case, if the first coordinate were xk1 = ci1 + ri, then the remaining xkj values, j /= 1, would be mandatorily equal to cij to ensure that point xk is inside hsi. Thus, the xkj coordinate, ∀j ∈ [1..Mrel], should be randomly generated taking into account the already set coordinates. To this end, the range should be constrained as defined by Equation 16 for each randomly generated coordinate xkj , j = 1..Mrel, in which only coordinates xks, s /= j, already set are considered.

cij − , ,r2 −

Mrel
(xks − cis)2 ≤ xkj ≤ cij + , ,r2 −

Mrel

(xks − cis)2,

s=1,s/=j
s=1,s/=j
∀i ∈ [1..q] e ∀k ∈ [1..N ].	(16)

As the procedure to generate the Ci coordinates does, it is required to avoid determinism during the specification of the coordinates of point xk, i.e., to avoid always generating xk1 as the first coordinate and xkMrel as the last one. Thus, the index of coordinates j, j = 1..Mrel, is also randomly defined.

Algorithm 2 summarizes the generation of the instances xk, k = 1..N , in- side the small hyperspheres hsi = (ri, Ci), i = 1..q. Similar to Algorithm 1, the updateminX(x) and updatemaxX(x) functions refresh respectively the lower and upper bounds of the next xk coordinate to be defined inside the corresponding hy- persphere hsi. The already set coordinates are also taken into account to randomly generate the remaining coordinates.

Algorithm 2 Generation of the points inside the hyperspheres
1: for k =1 → N do
2:   xk →∅ 
3:	maxX → cij − ri
4:	minX → cij + ri
5:	for j =1 → Mrel (j randomly defined) do
6:	xkj → random(minX, maxX)
7:	xk → xk ∪ {xkj}
8:			minX → updateminX(minX) 9:		maxX → updatemaxX(maxX) 10:	end for
11: end for
12: return {x1, x2,..., xN }

After generating the N points related to Mrel, Mirr and Mred features are set by adding Mirr irrelevant features, with random values, and Mred redundant features. The features to be replicated as redundant are chosen randomly. In the end, the N points are in RM , M = Mrel + Mirr + Mred.
Generating the multi-labels
Any instance xk ∀k ∈ [1..N ] has the label yi, i = 1..q, in its multi-label Yk, if xk is inside the hypersphere hsi. The final multi-label Yk consists of all labels fulfilling this condition, which can be easily verified according to the distance between xk and each center Ci, i = 1..q. If this distance is smaller than the radius ri, then xk is inside hsi and yi ∈ Yk; otherwise, yi ∈/ Yk. The procedure to assign the label yi to the multi-label Yk of xk ∀k ∈ [1..N ] is implemented as defined by Equation 17. Note that only the Mrel features have to be considered.

(xkj − cij)2 ≤ ri,	(17)
∀i ∈ [1..q], ∀j ∈ [1..Mrel], ∀k ∈ [1..N ].
After constructing this dataset, if requested by the user, the noisy dataset(s) are generated. To this end, for each instance Ei, the procedure to insert noise in the constructed dataset flips the label yj ∈ Yi, j = 1..q, with probability μ. In other words, if the label yj is in the multi-label Yi, the flip will remove yj from the multi-label Yi with probability μ. Otherwise, the label yj will be inserted with probability μ.
Based on the HyperSpheres strategy, we propose a similar strategy named Hy- perCubes described next, in which hypercubes are used instead of hyperspheres.

The HyperCubes strategy
The main motivation behind this strategy is that hypercubes could be appropriate to evaluate multi-label learning algorithms, such as decision trees [4], which classify instances by dividing the space using hyperplanes.
The HyperCubes strategy also has 9 parameters and the corresponding con- straints to generate synthetic datasets without and with noise. However, different from the HyperSpheres strategy, maxR and minR denote, respectively, the maxi- mum and minimum half-edges ( edge ) of the small hypercubes.
The main steps considered to generate synthetic datasets according to the Hy- perCubes strategy are similar to the ones required by HyperSpheres.
Generating the hypercube HC in RMrel .
Generating the q small hypercubes hci, i = 1..q inside HC.
Generating the N points (instances) in RM .
Generating the multi-labels based on the q small hypercubes and inserting the noise level(s) μ.
Generating the hypercube HC
A hypercube HC in RMrel , centered on the origin of the Cartesian coordinate system with half-edge eHC = 1, is created.
Generating the q small hypercubes
As HyperSpheres does, HyperCubes generates q small hypercubes hci = (ei, Ci), i = 1..q, such that they are inside HC in RMrel . Each small hypercube is defined by a specific half-edge ei and center Ci = (ci1, ci2, ci3,..., ciMrel ). This half-edge is randomly generated and ranges from minR to maxR. On the other hand, the Ci coordinates must fulfill the initial requirement defined by Equation 18 to generate hci inside HC.
∀ i ∈ [1..q] cij ≤ (1 − ei),j = 1..Mrel.	(18)
Different from HyperSpheres, this requirement is enough to ensure that hci is inside HC. Therefore, the domain in which the Ci coordinates range is given by Equation 18. The filled area in Figure 3 shows the domain of the Ci coordinates of a hypercube hci for Mrel = 2, such that hci is inside HC.
Different from HyperSpheres, the possible ranges to define each coordinate cij are the same for all coordinates. Thus, Algorithm 3 is simpler than Algorithm 1, as the functions updateminC(x) and updatemaxC(x) are not needed to generate the hypercubes hci = (ei, Ci), i = 1..q.
Generating the points
As HyperSpheres does, after defining the q small hypercubes, the main hypercube HC is populated with N points (instances). To populate HC in RM , it is required to generate the values (xi1, xi2,..., xiM ) and the multi-label Yi for each instance



Fig. 3. Domain to define Ci, given ei, in R2

Algorithm 3 Generation of the small hypercubes
1: for i =1 → q do
2:	Ci →∅ 
3:	ei → random(minR, maxR)
4:	maxC → (1 − ei)
5:	minC → −(1 − ei)
6:	for j =1 → Mrel do
7:	cij → random(minC, maxC)
8:	Ci → Ci ∪ {cij}
9:	end for
10:	hci → (ei, Ci)
11: end for
12: return {hc1, hc2,..., hcq}

Ei.
In addition, HyperCubes also oriented the generation of points, such that each
point is at least inside one small hypercube. By using this procedure, no instances have empty multi-labels and all small hypercubes hci, i = 1..q, are populated.
To ensure that the distribution of instances inside each small hypercube is pro- portional to the corresponding half-edge, the framework uses a balance factor similar to the one in Equation 14. However, instead of summing radiuses, half-edges are summed. Thus, Ni = round(f ×ei) points are generated inside each hypercube hci, i = 1..q.
As the procedure to generate the small hypercube centers does, a random point xk = (xk1, xk2,..., xkMrel ) inside hci = (ei, Ci) must be generated as defined by Equation 19.
|(xkj − cij)|≤ ei, ∀i ∈ [1..q] e ∀j ∈ [1..Mrel].	(19)
Similar to Section 3.1.3, the domain to generate the xk coordinates is different, being reduced to the region inside hci. As the hci center is not on the origin, it is required to take into account the coordinates of this center. Figure 4 exemplifies, for Mrel = 2, that a random point xk must be inside the filled area to belong to the hypercube hci = (ei, Ci).



Fig. 4. Domain to define xk, given ei, in R2

Algorithm 4 summarizes the generation of the instances xk, k = 1..N , inside a small hypercube hci = (ei, Ci), i = 1..q. This algorithm is simpler than Algo- rithm 2 by discarding the functions updateminX(x) and updatemaxX(x), as the coordinates range in the same domain.

Algorithm 4 Generation of the points inside the hypercubes
1: for k =1 → N do
2:	xk →∅ 
3:	maxX → cij − ei
4:	minX → cij + ei
5:	for j =1 → Mrel do
6:	xkj → random(minX, maxX)
7:	xk → xk ∪ {xkj}
8:	end for
9: end for
10: return {x1, x2,..., xN }

As HyperSpheres does, after generating the N points related to Mrel, the Mirr and Mred features are set by adding Mirr irrelevant features, with random values, and Mred redundant features. The features to be replicated as redundant are chosen randomly. In the end, the N points are in RM , M = Mrel + Mirr + Mred.
Generating the multi-labels
Similar to HyperSpheres, any instance xk ∀k ∈ [1..N ] has the label yi, i = 1..q, in its multi-label Yk, if xk is inside the hypercube hci. The final multi-label Yk is thus composed of all labels fulfilling this condition, which can be easily verified according to the distance between xk and each center Ci, i = 1..q. If this distance is smaller than the half-edge ei, then xk is inside hci and yi ∈ Yk; otherwise, yi ∈/ Yk. The procedure to assign the label yi to the multi-label Yk of xk ∀k ∈ [1..N ] is implemented as defined by Equation 20. Note that only the Mrel features have to be considered.
|(xkj − cij)|≤ ei, ∀i ∈ [1..q] e ∀j ∈ [1..Mrel].	(20)

After constructing this dataset, if requested by the user the noisy dataset(s) are generated in the same way as the HyperSpheres strategy does.
The Mldatagen framework
Currently, both strategies HyperSpheres and HyperCubes (Sections 3.1 and 3.2) are implemented in the Mldatagen framework, which is publicly available at http:
//sites.labic.icmc.usp.br/mldatagen. In this web site, the user finds a short introduction to Mldatagen, as well as the interface to configure the framework pa- rameters and download the output.
Figure 5a shows the parameter setting interface, which considers mandatory and optional parameters. The user can set one or more noise levels in parameter μ by separating them with the “;” character. Furthermore, the optional parameters maxR, minR, μ and name have default values: 0.8, (  q  + 1)/q , {0.05; 0.1} and “Dataset test”, respectively. After filling in the fields, the user should click on the “Generate” button.

(a) Mldatagen parameter setting	(b) Mulan statistics of a dataset generated by Mldata-
gen
Fig. 5. Framework screenshots

To avoid setting invalid values, the constraints described in Section 3.1 are ver- ified. If any constraint is not fulfilled, Mldatagen will display an error message indicating the parameter that should be reviewed.

After execution, Mldatagen displays information about the generated dataset, such as the distribution of instances inside the geometrical shape used and multi- label statistics, which are calculated by Mulan, as shown in Figure 5b.
To download the Mldatagen output, the user should click on the “Download the generated dataset” button. The output consists of a compressed file named according to the pattern
<x>_<y>_<w>_<z>.tar.gz
in which <x> is the strategy (HyperSpheres or HyperCubes), <y>, <w> and <z> are numbers denoting, respectively, the number of relevant, irrelevant and redundant features. As already mentioned, this compressed file contains the user specified synthetic dataset without noise, as well as one synthetic dataset per noise level set in the μ parameter. Each dataset can be directly submitted to Mulan for learning purposes.
Illustrative example
Mldatagen was used to generate 6 synthetic multi-label datasets, 3 using the Hyper- Spheres strategy and the other 3 the HyperCubes strategy. To generate the datasets, different values of the Mrel, Mirr and Mred parameters were used. These values were chosen to analyze how the number of features (M = Mrel + Mirr + Mred) and the number of unimportant features (Mirr and Mred) influence the performance of the multi-label BRkNN-b learning algorithm [13], available in Mulan. In what follows, information about the synthetic datasets generated, BRkNN-b and the classification results are presented.
Dataset description
The parameters Mrel, Mirr and Mred were set with different values. Table 2 shows these values and the generation strategy used for each dataset.
Table 2
Number of relevant, irrelevant and redundant features in the six synthetic datasets


Aside the features, Mldatagen was executed with default value parameters, ex- cept for the noise level μ, the number of instances N and the number of labels q,

which were set as shown in Table 3.

Table 3

Setting of other Mldatagen parameters

q	N	maxR	minR	μ

10	1000	0.8	 ( q + 1)/q	0

Table 4 shows, for each dataset, the single-label frequencies; the lowest and the highest single-label frequencies, as well as the first, second (median) and third quartiles, as suggested by [14]; the Label Cardinality (LC), which is the average number of single-labels associated with each example defined by Equation 21; and the Label Density (LD), which is the normalized cardinality (LD(D)= LC(D)/|L|) defined by Equation 22.
|D|	|D|
LC(D)=  1  Σ |Y |.	(21)	LD(D)=  1  Σ |Yi| .	(22)

Figure 6 depicts dispersion of the single-label frequencies by boxplots, with a
dashed line at frequency = 500 (50%). As can be observed, all single-label frequen- cies are not higher than 50% for datasets A and B. Furthermore, the datasets with less features (E and F) have higher single-label frequencies, with the 3rd quartiles above the dashed line.













A	B	C	D	E	F


Fig. 6. Boxplots of the single-label frequencies
Table 5 shows, for each synthetic dataset, the percentage of multi-labels in the dataset with number of labels ranging from 1 to 10. For example, in dataset A, 45.90% of the multi-labels have only one single label, 30.90% have two single-labels and this percentage reduces to 0.50% for 6 single-labels. Moreover, there is no multi-label with more than 6 single-labels.
As can be observed, in the four datasets with M = 20 features, the higher the number of single-labels, the lower the percentage in the multi-label is. On the other hand, the datasets E and F with M = 5 features show a better frequency distribu- tion. These different behaviors could be explained by the curse of dimensionality [8], which can harm analyses of high-dimensional data.

Table 4
Single-label frequencies and multi-label statistics of the synthetic datasets



The multi-label BRk NN-b learning algorithm
Lazy algorithms are useful in the evaluation of datasets with irrelevant features, as the classifiers built by these algorithms are usually susceptible to irrelevant features. The multi-label learning algorithm BRkNN is an adaptation of the single-label lazy k Nearest Neighbor (kNN ) algorithm to classify multi-label examples proposed in [13]. It is based on the well-known Binary Relevance approach, which transforms a multi- label dataset into q single-label datasets, one per label. After transforming the data, kNN classifies each single-label problem separately and then BRkNN aggregates the prediction of each one of the q single-label classifiers in the corresponding multi- label, which is the one predicted. Despite the similarities between the algorithms, BRkNN is much faster than kNN applied according to the BR approach, as BRkNN performs only one search for the k nearest neighbors.

Table 5
Percentage of multi-labels with different number of labels


To improve the predictive performance and to tackle directly the multi-label problem, the extensions BRkNN-a and BRkNN-b were also proposed in [13]. Both extensions are based on a label confidence score, which is estimated for each label from the percentage of the k nearest neighbors having this label. BRkNN-a classifies an unseen example E using the labels with a confidence score greater than 0.5, i.e., labels included in at least half of the k nearest neighbors of E. If no label satisfies this condition, it outputs the label with the greatest confidence score. On the other hand, BRkNN-b classifies E with the [s] (nearest integer of s) labels which have the greatest confidence score, where s is the average size of the label sets of the k nearest neighbors of E.
In this work, we use the BRkNN-b extension proposed in [7] and implemented in Mulan, which was executed with k = 11 and the remaining parameters with default values.
Results and discussion
All the reported results were obtained by Mulan using 5x2-fold cross-validation, which randomly repeats 2-fold cross-validation five times.
The evaluation measures described in Section 2.1.1 were used to evaluate the classifiers constructed by BRkNN-b. Table 6 shows the average and the standard deviation (in brackets) of the evaluation measure values. The example-based eval- uation measures are denoted in Table 6 as: Hamming-Loss (HL); Subset-Accuracy (SAcc); Precision (Pr ); Recall (Re); Accuracy (Acc). The label-based evaluation measures are denoted as: Micro-averaged Precision (Pμ); Micro-averaged Recall

(Rμ); Micro-averaged F-Measure (F1μ) and Macro-averaged Recall (RM ). Best re- sults among the datasets with M = 20, as well as between the two datasets with M = 5 are highlighted in gray.
Table 6 Classification performance

Example-based measures
HL	SAcc	Pr	Re	Acc
D	0.17 (0.00)	0.10 (0.01)  0.60 (0.01)	0.81 (0.02)	0.52 (0.00) 
E	0.19 (0.01)	0.12 (0.01)	0.68 (0.01)	0.80 (0.02)	0.61 (0.01)
F  0.12 (0.01)	0.23 (0.02)	0.76 (0.01)	0.93 (0.01)	0.71 (0.01) 
Label-based measures

Pμ	Rμ	F1μ	RM
A	0.49 (0.01)	0.57 (0.01)	0.52 (0.00)	0.29 (0.01)
B	0.52 (0.02)	0.71 (0.02)	0.60 (0.01)	0.73 (0.02)
C	0.57 (0.02)	0.69 (0.01)	0.62 (0.01)	0.36 (0.01)
D  0.60 (0.01)	0.76 (0.02)	0.67 (0.01)	0.75 (0.02) 
E	0.73 (0.02)	0.85 (0.01)	0.78 (0.01)	0.78 (0.01)
F   0.79 (0.01)	0.91 (0.01)	0.85 (0.01)	0.89 (0.01) 
It can be observed that between the two datasets with M = 5 features, dataset F , which was created using the HyperCubes strategy, shows the best results. Among the four datasets with M = 20, dataset B obtained the best example-based mea- sure values for Hamming-Loss (HL) and Subset-Accuracy (SAcc), while dataset D obtained the best results for the remainder of the example-based measures and for all the label-based measures considered. Both datasets were also created using the HyperCubes strategy.
In what follows, spider graphs summarizing the results of the performance mea- sures in Table 6 (except Hamming-loss) are shown. Thus, greater values indicate better performance. These graphs were generated using the R framework 12 . Fig- ure 7 shows the graphs for datasets A, B, C and D (M = 20), while Figure 8 shows the graphs for datasets E and F (M = 5). Each colored line plots the per- formance of the classifier built with an specific dataset, while each axis represents an evaluation measure.
As stated before, for M = 20 the classifiers build with datasets B and D show better performance than the ones build with datasets A and C. Moreover, for M = 5 the classifier build with dataset F shows better results than the one build with dataset E. Observe that these datasets (B, D and F ) were generated using the HyperCubes strategy.
One possible cause of this behavior is that in the HyperSpheres strategy the volume of the main hypersphere HS increases with the dimensionality up to a max- imum value, which depends on the initial volume of the hypersphere. Afterwards, the volume decreases with the dimensionality, tending to zero. As the main hyper- sphere HS used by the HyperSpheres strategy has radius one, its maximum volume

12 http://www.r-project.org







Precision	Micro.Recall

Accuracy	Macro.Recall


A	B	C	D
Example-based measures
A	B	C	D
Label-based measures

Fig. 7. Spider graphs for the A, B, C and D datasets





Precision	Micro.Recall

Accuracy	Macro.Recall


E	F
Example-based measures
E	F
Label-based measures

Fig. 8. Spider graphs for the E and F datasets

is reached for M = 5, decreasing afterwards. This problem is well described in [12]. On the other hand, in the HyperCubes strategy the volume of the main hypercube HC always increases with the dimensionality. Both cases are related to the curse of dimensionality.

Conclusion
This work proposes two strategies to generate synthetic multi-label datasets. Both strategies were implemented in the framework Mldatagen, which is publicly avail- able, improving the lack of publicly available multi-label generators. Although these

strategies are based on one initial proposal described in [18] for a specific problem, we have extended the initial proposal by offering the user of Mldatagen the flexibility to choose the number of unimportant features and the noise level for the datasets to be generated, as well as avoiding the occurrence of empty multi-labels. Further- more, Mldatagen outputs the generated datasets in the Mulan format, a well-known framework for multi-label learning, which is frequently used by the community.
To illustrate Mldatagen, multi-label classifiers were built from six synthetic datasets. The results suggest that the datasets generated by the HyperCubes strat- egy provide better classification results than the ones based on HyperSpheres. In fact, despite both strategies being sensitive to the curse of dimensionality, the vol- ume of a hypercube always increases with the dimensionality, showing better behav- ior than a hypersphere, whose volume decreases from one dimension upwards. As future work, we plan to implement more strategies into the Mldatagen framework and make them available to the community.

References
Agrawal, R., S. Ghosh, T. Imielinski, B. Iyer and A. Swami, An interval classifier for database mining applications, in: International Conference on Very Large Databases, 1992, pp. 560–573.
Bol´on-Canedo, V., N. S´anchez-Maron˜o and A. Alonso-Betanzos, A review of feature selection methods on synthetic data, Knowledge and Information Systems 34 (2013), pp. 483–519.
Chou, S. and C.-L. Hsu, MMDT: a multi-valued and multi-labeled decision tree classifier for data mining, Expert Systems with Applications 28 (2005), pp. 799–812.
Clare, A. and R. D. King, Knowledge discovery in multi-label phenotype data, in: European Conference on Principles of Data Mining and Knowledge Discovery, 2001, pp. 42–53.
Dendamrongvit, S., P. Vateekul and M. Kubat, Irrelevant attributes and imbalanced classes in multi- label text-categorization domains, Intelligent Data Analysis 15 (2011), pp. 843–859.
Dietterich, T. G., Exploratory research in machine learning, Machine Learning 5 (1990), pp. 5–10.
dos Reis, D. M., E. A. Cherman, N. Spolaˆor and M. C. Monard, Extensions of the multi-label learning algorithm BRkNN (in Portuguese), in: Encontro Nacional de Inteligˆencia Artificial, 2012, pp. 1–12.
Hastie, T., R. Tibshirani and J. Friedman, “The Elements of Statistical Learning,” Springer-Verlag, 2001.
Langley, P., Crafting papers on machine learning, in: International Conference on Machine Learning, 2000, pp. 1207–1212.
Liu, H. and H. Motoda, “Computational Methods of Feature Selection,” Chapman & Hall/CRC, 2008.
Noh, H. G., M. S. Song and S. H. Park, An unbiased method for constructing multilabel classification trees, Computational Statistics & Data Analysis 47 (2004), pp. 149–164.
Richeson, D., Volumes of n-dimensional balls (2010).
URL  http://divisbyzero.com/2010/05/09/volumes-of-n-dimensional-balls

Spyromitros, E., G. Tsoumakas and I. Vlahavas, An empirical study of lazy multilabel classification algorithms, in: Hellenic conference on Artificial Intelligence (2008), pp. 401–406.
Tsoumakas, G., Personal communication (2013).
Tsoumakas, G., I. Katakis and I. P. Vlahavas, Mining multi-label data, in: O. Maimon and L. Rokach, editors, Data Mining and Knowledge Discovery Handbook, Springer, 2010 pp. 667–685.
Tsoumakas, G., E. S. Xioufis, J. Vilcek and I. P. Vlahavas, Mulan: A java library for multi-label learning, Journal of Machine Learning Research 12 (2011), pp. 2411–2414.


Younes, Z., F. Abdallah, T. Denoeux and H. Snoussi, A dependent multilabel classification method derived from the k-nearest neighbor rule, EURASIP Journal on Advances in Signal Processing 2011 (2011), pp. 1–14.
Zhang, M.-L., J. M. Pen˜a and V. Robles, Feature selection for multi-label naive bayes classification, Information Sciences 179 (2009), pp. 3218–3229.
