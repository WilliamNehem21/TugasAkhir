

Electronic Notes in Theoretical Computer Science 265 (2010) 369–387
www.elsevier.com/locate/entcs

An Alternative Direct Simulation of Minsky Machines into Classical Bunched Logics
via Group Semantics
Dominique Larchey-Wendling
LORIA – CNRS, UMR 7503
Vandœuvre-l`es-Nancy, France

Abstract
Recently, Brotherston & Kanovich, and independently Larchey-Wendling & Galmiche, proved the undecid- ability of the bunched implication logic BBI. Moreover, Brotherston & Kanovich also proved the undecid- ability of the related logic CBI, as well as its neighbours. All of the above results are based on encodings of two-counter Minsky machines, but are derived using different techniques. Here, we show that the technique of Larchey-Wendling & Galmiche can also be extended, via group Kripke semantics, to prove the unde- cidability of CBI. Hence, we propose an alternative direct simulation of Minsky machines into both BBI and CBI. We identify a fragment called elementary Boolean BI (eBBI) which is common to the BBI/CBI families of logics and we show that the problem of Minsky machine acceptance can be encoded into eBBI. The soundness of the encoding is derived from the soundness of a goal directed sequent calculus designed for eBBI. The faithfulness of the encoding is obtained from a Kripke model based on the free commutative group Zn.
Keywords: Boolean/classical bunched logics, Kripke semantics, Minsky machines, decidability.

Introduction
The logic of bunched implications of Pym and O’Hearn [16] contains two impor- tant families of logics: Boolean BI (BBI) and Classical BI (CBI). BBI is the core logical framework of separation logic, and has been well studied for a number of years [2,7,13]. CBI was introduced more recently by Brotherston and Calcagno [3]. The undecidability of BBI, which was a long-standing open problem, was recently established independently by two groups of researchers [5,14]. Using different tech- niques, both Larchey-Wendling & Galmiche [14] and Brotherston & Kanovich [5] derived the undecidability of BBI from a (different) encoding of two counter Minsky machines into a fragment of BBI. Moreover, Brotherston and Kanovich’s results also include the undecidability of CBI (and its neighbours), again via an encoding of Minsky machines [5]. The aim of the present paper is to show that the technique

1571-0661© 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.08.022

of [14] can also be adapted, via group Kripke semantics, to simultaneously prove the undecidability of both BBI and CBI.
Recall that the logic BI of bunched implications [16] is a sub-structural logic which freely combines additive connectives ∧, ∨, → and multiplicative connectives
∗, −∗. In BI, both the multiplicatives and the additives behave intuitionistically. From its inception, BI was given a nice bunched sequent proof-system enjoying cut- elimination [17]. Later, Galmiche et al. [8] gave BI a sound and complete labeled tableaux system from which decidability was derived. The logic BI is sometimes called intuitionistic BI to distinguish it with other variants where either the multi- plicatives or the additives include a negation and thus behave classically.
From a proof-theoretical perspective, Boolean BI (or simply BBI) can be consid- ered as the first investigated variant of BI which contained a negation: BBI combines intuitionistic multiplicatives with Boolean additives. This focus on BBI is the con- sequence of the natural links between BBI and separation or spatial logics. Indeed, for instance, the pure part of separation logic is essentially obtained by consider- ing a particular model of BBI, based on a (partial) monoid of heaps [11] (see [13] for a more general discussion on these links). The Hilbert proof-system of BBI was proved complete w.r.t. relational (or non-deterministic) Kripke semantics [7]. How- ever, the proof-theory of BBI was rather poorly developed because it was difficult to conceive how the bunched sequent calculus of (intuitionistic) BI could be extended to BBI without losing key properties such as e.g. cut-elimination.
Then Classical BI (CBI) was introduced [3] as a bunched logic which contained both a multiplicative negation and an additive negation. It could be used as a basis for resource models which contain a dualizing operator. For this logic, Broth- erston and Calcagno [4] provided a Display calculus `a la Belnap and established its soundness and completeness both w.r.t. the Hilbert proof-system and (dualiz- ing) relational Kripke semantics. They proved cut-elimination as a by product of their Display proof-system and described a substantial part of the model theory of CBI, including the proof of the incompleteness of CBI w.r.t. the (dualizing) partial monoidal Kripke semantics. However, no decidability result followed from these achievements.
Then, back to BBI, two main families of results emerged giving a contrasted view of its proof-theory. On the one hand, Brotherston [2] adapted the Display proof- system of CBI to BBI, circumventing the difficulty of the multiplicatives of BBI lacking a negation. This system was proved sound and complete w.r.t. relational Kripke semantics. Cut-elimination was also derived but, despite the expectations of Brotherston, no decidability result followed. On the other hand, Larchey-Wendling and Galmiche [13] proposed a labeled tableaux proof-system for (partial monoidal) BBI and by the study of the relations between the proof-search generated counter- models of BI and BBI, showed that (intuitionistic) BI could be faithfully embedded into BBI. This result, at first counter-intuitive, hinted that BBI, originally thought simpler than BI, could in fact be much more difficult to decide. To complete the picture, Larchey-Wendling and Galmiche [14] recently established that relational Kripke semantics and partial monoidal Kripke semantics define different notions

of (universal) validity in BBI, as in CBI [4]. Nevertheless, all the logics defined by theses classes of models are undecidable, as explained in [5,14] and the present paper.
Indeed, our aim here is to show that it is possible to find an encoding of Minsky machines that is suitable for both BBI and CBI, even when restricted to simple sub- classes of models like commutative groups. A different encoding of Minsky machines in CBI was already proposed in [5], with the consequence of the undecidability of CBI. However it corresponds to classes of separation models and would not apply to commutative groups because it requires that the models have indivisible units. 1 The faithfulness of our encoding is established by building a model of CBI based on the group Zn where n is the number of counters of the Minsky machine. Thus, this model suits for both BBI and CBI whether one considers relational, partial monoidal, total monoidal, or even group Kripke semantics. As a consequence, both BBI and CBI are undecidable even when their Kripke semantics is restricted Z × Z.
The paper is structured as following: we first outline the Kripke model theory of BBI/CBI based on the notion of non-deterministic (or relational monoid) and recall different results w.r.t. the semantics of both logics on particular sub-classes of models. Then we introduce a fragment of BBI/CBI which we call elementary BBI (eBBI). This fragment is provided with a set of sound goal-directed sequent calculus rules called gBBI. Then, we present an encoding of Minsky machines acceptance into elementary BBI. For each input m ∈ Nn of the machine, we compute a sequent Sm in eBBI. We prove the soundness of this encoding: if m is accepted by the Minsky machine then Sm has a proof tree in gBBI. This proof tree is extracted from the successful computation of the Minsky machine starting with m. The faithfulness of the encoding is established by building a model based on the group Zn. Hence, if Sm is semantically valid in Kripke semantics (even when the semantic interpretation is restricted to the group Zn) then the Minsky machine accepts the input m.

Non-Deterministic Monoids and Groupoids
In this section, we present the algebraic notions necessary for the definition of the relational Kripke semantics of BBI/CBI. Let us consider a set M . We denote by P(M ) the powerset of M , i.e. its set of subsets. A binary function ◦ : M × M −→ P(M ) is naturally extended to a binary operator on P(M ) by
X ◦ Y = [{x ◦ y | x ∈ X, y ∈ Y }	(1)

for any subsets X, Y of M . Using this extension, we can view any element m ∈ M as the singleton set {m} and derive the equations m◦X = {m}◦X and a◦b = {a}◦{b}.
Definition 2.1 A non-deterministic (or relational) monoid is a tuple (M, ◦, ϵ) where ϵ ∈ M and ◦ : M × M −→ P(M ).  We require the following conditions to hold:

1 The unit є is indivisible if the following property holds:  ∀x, y x ◦ y = є ⇒ x = y = є.

∀a ∈ M, ϵ ◦ a = {a} (neutrality)
∀a, b ∈ M, a ◦ b = b ◦ a (commutativity)
∀a, b, c ∈ M, a ◦ (b ◦ c) = (a ◦ b) ◦ c (associativity) 2
The term non-deterministic was introduced in [7] in order to emphasize the fact that the composition a ◦ b may yield not only one but an arbitrary number of results including the possible incompatibility of a and b in which case a ◦ b = ∅. If (M, •, e) is a (usual) commutative monoid then, defining a ◦ b = {a • b} and ϵ = e induces a non-deterministic monoid (M, ◦, ϵ). Using the bijection x '→ {x} mapping elements of M to singletons in P(M ), we can view (usual) commutative monoids as a particular case of non-deterministic monoids (later called total deterministic monoids). Partial monoids can also be represented using the empty set ∅ as the result of undefined compositions.
The term relational is sometimes used because the map ◦ : M ×M −→P(M ) can equivalently be understood as a ternary relation −◦− e − : M × M × M −→ {0, 1} through the Curry-Howard isomorphism and the axioms correspond to those of an internal monoid in the category of relations [9]. The two presentations are equivalent but we rather use the monoidal presentation in this paper.
Proposition 2.2 The extension of ◦ to P(M ) deﬁned by (1) induces a commuta- tive monoidal structure with unit element {ϵ} on P(M ).
The proof of this trivial proposition is left to the reader. As a consequence of Proposition 2.2, the denotation a1 ◦ · · · ◦ ak is unambiguous for any multiset
{a1,..., ak} because it is identical to the product {a1}◦· · ·◦{ak} in the commutative
monoid P(M ).
Proposition 2.3 For any m ∈ M and any X, Y ∈ P(M ), if m ∈ X ◦Y then there exists x ∈ X such that m ∈ x ◦ Y .
This is a direct consequence of the defining equation (1) of the extension of ◦ to P(M ). As a particular case, if m ∈ a1 ◦ ··· ◦ ak ◦ b1 ◦ ··· ◦ bp then there exists α ∈ a1 ◦· · · ◦ ak such that m ∈ α ◦ b1 ◦· · · ◦ bp.
Let (M, ◦, ϵ) be a non-deterministic monoid. It is a partial deterministic monoid if for any x, y ∈ M , the composition x◦ y is either empty or a singleton. (M, ◦, ϵ) is a total deterministic monoid if for any x, y ∈ M , the composition x◦y is a singleton. If moreover for every x ∈ M there exists y such that ϵ ∈ x ◦ y then (M, ◦, ϵ) is a total deterministic group. Total deterministic monoids exactly correspond to those non-deterministic monoids derived from usual commutative monoid.
Definition 2.4 The class of non-deterministic (resp. partial deterministic, resp. total deterministic) monoids is denoted NDm (resp. Dm, resp. Tm). The class of total deterministic groups is denoted G.
Proposition 2.5 The strict inclusions G Ç Tm Ç Dm Ç NDm hold.

2 Associativity should be understood using the extension (1) of ◦ to P(M).

Proof. The inclusion between those classes of non-deterministic monoids is obvious. We illustrate NDm ¢ Dm by the following structure: ({ϵ, x, y}, ◦, ϵ) where x ◦ x =
{ϵ, y} and y ◦ α = {y} for any α ∈ {ϵ, x, y}.	2
Definition 2.6 A non-deterministic groupoid is a tuple (M, ◦, ϵ, −, ∞) where (M, ◦, ϵ) is a non-deterministic monoid and − : M −→ M and ∞∈ M satisfy:
∀a ∈ M, ∞∈ a ◦− a
∀a, b ∈ M, ∞∈ a ◦ b ⇒ b = − a
The pseudo inverse operator − is extended point-wise to P(M ) −→ P(M ) by
— X = {− x | x ∈ X}. The identities − ϵ = ∞ and −− x = x hold for any x ∈ M . The reader can find proofs of these identities in [3] as well as many examples of non-deterministic groupoids (called CBI-models there), though many of them are
only partial deterministic.
Let (M, ◦, ϵ, −, ∞) be a non-deterministic groupoid. It is a partial deterministic groupoid if for any x, y ∈ M , the composition x ◦ y is either empty or a singleton. (M, ◦, ϵ, −, ∞) is a total deterministic groupoid if for any x, y ∈ M , the composition x ◦ y is a singleton. If moreover ϵ = ∞ then (M, ◦, ϵ, −, ∞) is a total deterministic group.
Definition 2.7 The class of non-deterministic (resp. partial deterministic, resp. total deterministic) groupoids is denoted NDg (resp. Dg, resp. Tg). The class of total deterministic groups is denoted G.
Remark that there is no contradiction in the definition of total deterministic groups (class G) from Definition 2.4 and Definition 2.7 because in this case, the inverse and the pseudo inverse are identical operators.
Proposition 2.8 The strict inclusions G Ç Tg Ç Dg Ç NDg hold.
Proof. See [3,4] for a justification of the strictness of the inclusions. For instance, the bit-arithmetic model is a witness for Tg ¢ G.	2

Kripke Semantics for BBI and CBI
We first present the syntax of BBI and CBI. In fact, the operators of BBI form a strict subset of the operator of CBI. The formulae of CBI are defined as following: starting from a set Var, they are freely build using the logical variables in Var, the logical constants in {O, I, T, ⊥}, the unary connectives in {∼, ¬} or the binary connectives in {∗, −∗, ∧}. The formulae of BBI are those formulae of CBI that contain neither O nor ∼. Formally, the set of formulae of BBI/CBI is described by the following grammar:

BBI :	A ::= v | I |T|⊥| ¬ A | A ∗ A | A −∗ A | A ∧ A
CBI :	A ::= v | O | I |T|⊥| ∼ A | ¬ A | A ∗ A | A −∗ A | A ∧ A

with v ∈ Var. Hence, BBI appears as a fragment of CBI. 3 If δ : Var −→ P(M ) is an interpretation of variables where M = (M, ◦, ϵ) is a non-deterministic monoid, then we say that (M, δ) is a model of BBI. On the other hand, if (M, ◦, ϵ, −, ∞) is a non-deterministic groupoid, we say that (M, δ) is a model of CBI. We define the Kripke interpretation of the formulae of BBI/CBI from a given model (M, δ) of BBI/CBI, by induction on the structure of formulae:

m H v iff m ∈ δ(v)
m H ⊥ iff never	m H O iff m /= ∞
m H T iff always	m H I iff m = ϵ
m H ¬ A iff m K A	m H ∼ A iff − m K A m H A ∧ B iff m H A and m H B
m H A ∗ B iff ∃a, b, m ∈ a ◦ b and a H A and b H B m H A −∗ B iff ∀a, b (b ∈ m ◦ a and a H A) ⇒ b H B

A formula F is valid in the model ((M, ◦,.. .), δ) if m H F holds for any m ∈ M . A formulae F is valid in a structure M = (M, ◦,.. .) if for any interpretation δ : Var −→ P(M ) of propositional variables, F is valid in the model (M, δ). A counter- model of the formula F of BBI (resp. CBI) is given by a non-deterministic monoid (resp. groupoid) (M, ◦,.. .), an interpretation δ : Var −→ P(M ) and an element m ∈ M such that m K F .

Definition 3.1 We denote by BBIND (resp. BBID, BBIT, BBIG, CBIND, CBID, CBIT, CBIG) the set of formulae of BBI (resp. CBI) which are valid in every structure belonging to the class NDm (resp. Dm, Tm, G, NDg, Dg, Tg, G).

The following theorem collects some previously known results (see below) with a new one, namely CBIT ¢ CBID, to give an overview of the relations between the different flavors of BBI and CBI.

Theorem 3.2 The two following inclusions sequences hold:

BBIND Ç BBID Ç BBIT Ç BBIG	(ii) CBIND Ç CBID Ç CBIT Ç CBIG

Proof. For a given BBI/CBI-model M = (M, ◦, ϵ,.. .), the following table lists the


3 We did not include the two other additive connectives ∨ and → or the other multiplicative connective
∨∗ which we consider definable in BBI/CBI by the De Morgan equations A ∨ B = ¬(¬ A ∧ ¬ B), A → B =
¬(A ∧ ¬ B) and A ∨∗ B = ∼(∼ A ∗∼ B).

Kripke interpretations of some BBI/CBI formulae in the model M:

For BBID ¢ BBIND (resp. BBIT ¢ BBID), the witness formula (I∗ I) →I (resp. T ) was given in [14]. The formula I encodes invertibility in BBI/CBI, thus I belongs to BBIG but not to BBIT. Hence BBIG ¢ BBIT.
For CBID ¢ CBIND, the witness formula K→ L was given in [4]. The formula O
encodes the equation ∞ = ϵ and is thus a witness for CBIG ¢ CBIT.
Let us provide a witness for CBIT ¢ CBID. The formula O' is valid in a structure of the class Tg if and only if ∞ = ϵ and thus the structure must also be of the class G and hence, the formula O must also be valid in that structure. Hence the formula o O' →O belongs to CBIT.
Let us show that o O' →O does not belong to CBID. Consider the partial deterministic groupoid M = ({ϵ, x, y, ∞}, ◦, ϵ, −, ∞) defined by the following tables:

There is no need to provide δ because no logical variable appear in the formulae we consider. We let the reader check that the structure M verifies the axioms of non-deterministic groupoids. Thus, M∈ Dg holds. The formula O' is valid in this structure because ∞◦∞ = ∅. Hence, o O' is valid in M. Obviously ∞ /= ϵ holds in M and thus M is a counter-model to the formula o O' →O. Moreover, M belongs to the class Dg.	2
We do not discuss the relations between the different sub-classes of BBI/CBI
models further. See [3,5,13,14] for a more detailed presentation.

A ▶ A
⟨id⟩
	Γ ▶ B	
Γ, I ∧ A ▶ B
⟨w⟩
Γ, I ∧ A, I ∧ A ▶ B
Γ, I ∧ A ▶ B
⟨c⟩
Γ,A ▶ B
Γ, I ∧ A ▶ B
⟨IL⟩

Γ ▶ A	Δ,B ▶ C
Γ, Δ,A −∗ B ▶ C	⟨−∗L⟩
Γ,A ▶ B
Γ ▶ A −∗ B ⟨−∗R⟩
Γ ▶ A	Γ ▶ B ⟨∧R⟩
Γ ▶ A ∧ B


Fig. 1. Sequent calculus rules for BBI/CBI
Sequents for BBI/CBI
Contrary to (intuitionistic) BI or Linear Logic [10,18], bunched logics with classical additives like BBI and CBI are usually not described by sequent calculi. There is no known sequent calculus enjoying decent proof-theoretical properties like cut- elimination or the sub-formula property. Only Display style proof-systems exist for BBI/CBI [2,3]. Nevertheless, we present a set of sound sequent calculus rules with are suitable for many bunched logics with classical additives, because they preserve validity in a particular model.
Let us consider a fixed BBI or CBI model (M, δ) with δ : Var −→ M, depending on whether we only want to interpret the fragment BBI or full CBI.
Definition 4.1 A sequent is a pair denoted Γ ▶B where Γ is a multiset of formulae and B is a single formula. The sequent A1,..., Ap ▶ B is valid in the model (M, δ) and we write (M, δ) H A1,..., Ap ▶ B if
∀m, m1,..., mp ∈ M, (m ∈ m1 ◦ ... ◦ mp and ∀i, mi H Ai) implies m H B  (2)
When Γ ▶ B is valid in the model (M, δ), we also say that (M, δ) is a model of the sequent Γ ▶ B.
Because of the associativity and commutativity of ◦, property (2) is stable by permutation of the Ai’s and thus, validity is a well-defined notion for sequents. Universal validity w.r.t. a sub-class of non-deterministic monoids (resp. groupoids) means validity in all the models belonging to that particular sub-class. With Defi- nition 4.1, we derive the following obvious result:
Proposition 4.2 The sequent A1,..., Ap ▶ B is valid in (M, δ) if and only if the formula ¬((A1 ∗ ··· ∗ Ap) ∧ ¬ B) is valid in (M, δ).

Sequent Calculi for BBI/ CBI
In general, a proof rule is sound if it preserves universal validity from the premises to the conclusion. A proof rule is strongly sound if it preserves models from the premises to the conclusion. Hence strong soundness implies soundness. The next result establishes the strong soundness of the sequent calculus rules of Figure 1. Re- mark that these sequent rules can be viewed as a subset of the rules of intuitionistic linear logic where the exponential ! A has been replaced by I ∧ A.
Proposition 4.3 The rules of Figure 1 preserve validity in the model (M, δ).




ΣI,A ▶ A

⟨Ax⟩
ΣI, Γ ▶ A	ΣI, Δ ▶ B
ΣI, Γ, Δ ▶ C

A −∗ (B −∗ C) ∈ Σ

ΣI, Γ,A ▶ B
ΣI, Γ ▶ C

(A −∗ B) −∗ C ∈ Σ
ΣI, Γ ▶ A	ΣI, Γ ▶ B
ΣI, Γ ▶ C

(A ∧ B) −∗ C ∈ Σ


Fig. 2. gBBI: a set of goal-directed sequent calculus rules for BBI/CBI
The proof of this result is standard and is reproduced in Appendix A. In this paper, we will not use the rules of Figure 1 directly. We rather use a set gBBI of goal- directed sequent rules which better correspond to the computation steps of Minsky machines. In the set gBBI of goal-directed rules described in Figure 2, we denote ΣI for the multiset ΣI = I ∧ A1,..., I ∧ Ak when Σ is the multiset Σ = A1,..., Ak. Moreover, we name the rules of gBBI according to the form of their corresponding side condition, i.e. ⟨Ax⟩, ⟨(−∗)−∗⟩, ⟨−∗(−∗)⟩ and ⟨(∧)−∗⟩.
Theorem 4.4 For any BBI (resp. CBI) model (M, δ), if a BBI-sequent (resp. CBI- sequent) has a proof in gBBI then it is valid in (M, δ).
Proof. First, we show that each rule of gBBI can be obtained as a combination of the rules of Figure 1.

case of rule ⟨Ax⟩	case of rule ⟨−∗(−∗)⟩
⟨id⟩
ΣI, Δ ▶ B	C ▶ C
⟨−∗L⟩

⟨id⟩
ΣI, Γ ▶ A	ΣI, Δ,B −∗ C ▶ C

A ▶ A
⟨w⟩
ΣI, Γ, ΣI, Δ,A −∗ (B −∗ C) ▶ C ⟨−∗L⟩

.	applied n times


ΣI, Γ, ΣI, Δ, I ∧ (A −∗ (B −∗ C)) ▶ C
⟨IL⟩

⟨w⟩
ΣI,A ▶ A
.	⟨c⟩

.	applied n + 1 times
⟨c⟩
ΣI, Γ, Δ ▶ C

case of rule ⟨(−∗)−∗⟩	case of rule ⟨(∧)−∗⟩

ΣI, Γ,A ▶ B


ΣI, Γ ▶ A −∗ B

⟨−∗R⟩



C ▶ C

⟨id⟩
⟨−∗L⟩
ΣI, Γ ▶ A	ΣI, Γ ▶ B


ΣI, Γ ▶ A ∧ B

⟨∧R⟩



C ▶ C

⟨id⟩
⟨−∗L⟩

ΣI, Γ, (A −∗ B) −∗ C ▶ C


ΣI, Γ, I ∧ ((A −∗ B) −∗ C) ▶ C


ΣI, Γ ▶ C
⟨IL⟩
⟨c⟩
ΣI, Γ, (A ∧ B) −∗ C ▶ C


ΣI, Γ, I ∧ ((A ∧ B) −∗ C) ▶ C


ΣI, Γ ▶ C
⟨IL⟩
⟨c⟩


Remark that in the cases of rules ⟨Ax⟩ and ⟨−∗(−∗)⟩, n represents the size of the multiset Σ (counting all the occurrences of the formulae that appear in Σ). Since the rules of rules of Figure 1 preserve validity in (M, δ) (see Proposition 4.3), thus

the rules of gBBI preserve validity in (M, δ). Hence, the root of a proof tree must be a sequent which is valid in (M, δ).	2
Neither the set of rules of Figure 1 nor the set of rules of Figure 2 constitute a complete proof-system for either BBIND or CBIND. However, there exists some completeness results w.r.t. gBBI and fragments of BBI/CBI discussed in Section 4.3. The important property of gBBI in the context of this paper is that gBBI is sufficient to be able to simulate Minsky machines computations and it is the simplest system we could design for such a goal.

The elementary fragment of BBI
We define a fragment called elementary BBI (eBBI) which is common to BBI and CBI. eBBI will be used to encode Minsky machines and corresponds to an extension of the fragment s-IMELL( of multiplicative exponential linear logic [6,14].
Definition 4.5 A formula of BBI/CBI is (−∗, ∧)-elementary if it is of the form (u −∗ v) −∗ w, u −∗ (v −∗ w) or (u∧v) −∗ w where u, v and w are logical variables. The sequents of the fragment eBBI are those of the form ΣI, Γ ▶ c where Γ is a multiset of variables, c is a variable and Σ is a multiset of (−∗, ∧)-elementary formulae.
One can view eBBI as a fragment of BBI/CBI through Proposition 4.2 and in this sense, it seems to be a bit simpler than minimal BBI as defined in [5]. Validity in eBBI is the restriction of validity in BBI/CBI. Hence (see Theorem 3.2), this notion may depend on the class of models chosen among NDm, Dm, Tm, NDg, Dg, Tg and
G. However, by Theorem 4.4, gBBI is sound w.r.t. any of those classes of models. Hence, we are safe as long as we use gBBI to establish validity of eBBI sequents. It is obvious that eBBI is stable by backward application of the rules of gBBI, hence any gBBI proof of a sequent of eBBI contains only sequents of eBBI.

Completeness issues for gBBI on the fragment eBBI
On the fragment eBBI, the question of the completeness of gBBI w.r.t. the different classes of models considered in this paper is still partially open. In [14], the reader can find a proof that gBBI is sound and complete w.r.t. the classes of models NDm, Dm and Tm. We have a proof that gBBI is sound and complete w.r.t. the class Dg. Hence, gBBI is also sound and complete w.r.t. the class NDg. But none of these two proofs would fit for the classes Tg and G. To our knowledge, the question of the completeness of gBBI on the fragment eBBI for the classes Tg and G is open. In general, the question of completeness of fragments w.r.t. subclasses of models can be difficult to solve, as illustrated by the examples of the incompleteness of BBI [14] and CBI [4] w.r.t. partial monoidal Kripke semantics.

Encoding Minsky machines in BBI/CBI
We propose an encoding of Minsky machines [15] in BBI/CBI. As in [14], the encoding differs from Kanovich’s encoding of Minsky machines in the (!,  )-Horn

fragment of intuitionistic linear logic [12]. Compared to the encoding proposed in [14], the one we give here is a bit more complex for two reasons. First reason: it is suitable for many counter Minsky machines. Second reason: it is designed such that its faithfulness can be derived from a model taken in the sub-class of groups, more precisely (Zn, +, 0). 4

Many counters Minsky machines
In the following discussion, n > 0 represents the number of counters of the Minsky machine and l > 0 the number of instructions of the Minsky machine. The names p, q range over the interval [1, n] and the names i, j, k,... range over the interval [0, l]. Hence, the variables n, l, p, q, i, j, k all represent positive integers. The values of the counters of the Minsky machine can be represented by a vector in Nn, that is a n-uplet of the form m = (m1,..., mn). Given the values of counters m ∈ Nn and p ∈ [1, n], we denote by mp the value of the p-th counter, that is the p- th component of the vector m. Let us denote by ep = (0,..., 0, 1, 0,..., 0) the vector of Nn with all components to 0 except the p-th which as value 1. Hence, (e1,..., en) is the canonical base of Nn and we have the canonical decomposition: m = m1e1 + ··· + mnen. We denote by 0 the vector (0,..., 0) where all components are null.
A n-counter Minsky machine with l instructions is given by a total function

ψ : [1, l] −→ {+}× [1, n] × [0, l]  {−} × [1, n] × [0, l] × [0, l]

where, represents disjoint set union. Minsky machines instructions (incremen- tation, zero test/decrementation) are encoded as illustrated in the two following examples:

ψ(1)= (+, 2, 3) ~ 1: c[2]:=c[2]+1 ; goto 3
ψ(2)= (−, 6, 4, 5) ~ 2: if c[6]=0 then goto 4 else c[6]:=c[6]-1 ; goto 5

where c[] contains the array of counters of the Minsky machine.
Given a Minsky machine M = (n, l, ψ), its state is given by the index of the next instruction and the value of the counters. We represent the set S(M) of states by S(M) = [0, l] × Nn. The computation steps of the machine are represented by a (binary) transition relation between states →M ⊆ S(M) × S(M). For any two states (i, m) and (i', m'), the relation (i, m) →M (i', m') holds if there exists some p ∈ [1, n] and some j, k ∈ [0, l] such that one of the following conditions holds:

ψ(i) = (+, p, i') and m' = m + ep
or	ψ(i) = (−, p, i', k), mp = 0 and m' = m
or	ψ(i) = (−, p, j, i'), m' + ep = m (and mp /= 0)

4 whereas it was the total monoid (N × N, +, 0) in [14].

Remark that (i, m) →M (i', m') does not hold if i = 0 because ψ(0) is not defined.
Let →٨ be the reflexive and transitive closure of the relation →M.
We say that the machine M = (n, l, ψ) accepts the input m if starting from the state (1, m), there exists a sequence of transitions leading to the state (0, 0) and we define the set A(M ) of accepted inputs of M by:
A(M) =  m ∈ Nn | (1, m) →٨  (0, 0)}
We give the following example of a 2-counters 3-instructions Minsky machine informally described by the following pseudo-code:


1: if c[2]=0 then goto 0 else c[2]:=c[2]-1 ; goto 2
2: if c[1]=0 then goto 3 else c[1]:=c[1]-1 ; goto 1
3: c[1]:=c[1]+1 ; goto 3
ψ0(1)= (−, 2, 0, 2)
ψ0(2)= (−, 1, 3, 1)
ψ0(3)= (+, 1, 3)

with formal definition corresponding to M0 = (2, 3, ψ0). With this definition, the reader can check that A(M0) = {(c, c) | c ∈ N}.

The encoding of Minsky machines in eBBI
In the following discussion, we consider a fixed Minsky machine M = (n, l, ψ). We denote ΣM (resp. →M) simply by Σ (resp. →). We describe how we encode instructions and simulate computations. The instructions of M will be represented by (−∗, ∧)-elementary formulae in the fragment eBBI. For this, we need the following set of propositional variables:
{c1,..., cn}∪ {r1,..., rn}∪ {k}∪ {q0,..., ql}∪ {q1,..., q1}∪· · ·∪ {qn,..., qn}
0	l	0	l

composed of (n + 1)(l + 3) − 1 (distinct) logical variables.
Let Σ0 be the following multiset composed of n(n+1)+2 many (−∗, ∧)-elementary formulae:
⎡	 cp −∗ (k −∗ k) | p ∈ [1, n]}	∪ cp −∗ (rq −∗ rq) | p /= q ∈ [1, n]} ⎤
Σ0 =	⎦
∪ (c1 −∗ c1) −∗ rq | q ∈ [1, n]} ∪  (c1 −∗ c1) −∗ k, (c1 −∗ c1) −∗ q0}
For i ∈ [1, l], from the value of ψ(i), we define the multiset Σi composed of two (−∗, ∧)-elementary formulae by:

Σi = {(cp −∗ qj) −∗ qp, (k ∧ qp) −∗ qi}	when ψ(i) = (+, p, j)
j	j
or	Σi = {(rp ∧ qj) −∗ qi, cp −∗ (qk −∗ qi)}	when ψ(i) = (−, p, j, k)

Collecting Σ0,..., Σl, we obtain a multiset composed of n(n + 1)+ 2(l + 1) formulae. The Minsky machine instructions of M = (n, l, ψ) are thus encoded as the multiset ΣM = Σ0, Σ1,..., Σl of (−∗, ∧)-elementary formulae.

Given a vector m ∈ Nn, we define cm = m1.c1,..., mn.cn as the multiset com- posed of mi occurrences of the variable ci for each i ∈ [1, n], i.e. the encoding of the vector m as a multiset of {c1,..., cn}. As an example, when m = (2, 1, 3) ∈ N3, we have cm = c1, c1, c2, c3, c3, c3. Then, it is trivial to verify that for any vector
m ∈ Nn and any i ∈ [0, l], the sequent ΣI , cm ▶ qi belongs to the fragment eBBI.
The following result states that acceptance by M is simulated by validity in
eBBI, whichever sub-class of models of BBI/CBI is chosen.
Theorem 5.1 For any X ∈ {ND, D, T, G},

A(M) = {m ∈ Nn | ΣI , cm ▶ q1 is universally valid in BBIX }	(resp. CBIX )

We detail the proof in Sections 5.3 and 5.4. But before we prove this charac- terization, let us come back to our previous example of the two counters Minsky machine M0 = (2, 3, ψ0). With the previous description, the encoding of the in-
structions of M0 will be given by the following multiset Σ(2,3,ψ0):


⎧⎪c1 −∗ (r2 −∗ r2), c2 −∗ (r1 −∗ r1),⎪⎫
⎧(r ∧ q ) −∗ q , c −∗ (q −∗ q ),⎫⎪

∪	(r1 ∧ q3) −∗ q2, c1 −∗ (q1 −∗ q2),

(c1 −∗ c1) −∗ r1, (c1 −∗ c1) −∗ r2,
⎪	⎪

⎪⎩⎪(c −∗ q ) −∗ q1, (k ∧ q1) −∗ q	⎭⎪


Soundness of the encoding

Proposition 5.2 For any m ∈ Nn and p ∈ [1, n], if mp = 0 then the sequent
ΣI, cm ▶ rp has a proof in gBBI.
Proof. Let us fix p ∈ [1, n]. Supposing mp = 0, we build of gBBI proof tree of the sequent ΣI, cm ▶ rp by induction on the size s = m1 + ... + mn of m.
If s = 0 then m1 = ··· = mn = 0 and cm is the empty multiset. Here is a gBBI
proof tree:



ΣI, c1 ▶ c1

ΣI ▶ rp
⟨Ax⟩
(c1 −∗ c1) −∗ rp ∈ Σ0 ⊆ Σ

If s > 0, let us choose q such that mq > 0. Then p /= q holds (because mp = 0 is an hypothesis). Let m' be the unique vector such that m' + eq = m. We derive
the identity cm = cm' , c between multisets. The size s' of m' is s' = s − 1 and we
obviously have m' = mp = 0. So we can apply the induction hypothesis to m' and
obtain a proof tree Q for ΣI, cm' ▶ r . From it, we build a proof tree suitable for

ΣI, cm ▶ rp:




ΣI, cq ▶ cq

⟨Ax⟩
Q
ΣI, cm'

▶ rp


cq −∗ (rp −∗ rp) ∈ Σ0 ⊆ Σ

ΣI, cm' , c
▶ rp

Hence the sequent ΣI, cm ▶ rp has a proof in gBBI.	2
Proposition 5.3 For any m ∈ Nn, the sequent ΣI, cm ▶ k has a proof in gBBI.
Proof. Same argument as Proposition 5.2 but using side conditions (c1 −∗ c1) −∗ k ∈
Σ0 and cq −∗ (k −∗ k) ∈ Σ0 instead of cq −∗ (rp −∗ rp) ∈ Σ0.	2
Lemma 5.4 For any r ∈ N, i ∈ [0, l] and m ∈ Nn, if (i, m) →r (0, 0) then the sequent ΣI, cm ▶ qi has a proof in gBBI.
Proof. We build a gBBI proof tree for the sequent ΣI, cm ▶ qi by induction on r. If r = 0 then we have (i, m) = (0, 0). As c0 is the empty multiset, the sequent ΣI, c0 ▶ q0 has the following proof tree:
⟨Ax⟩

ΣI, c1 ▶ c1
ΣI ▶ q0
(c1 −∗ c1) −∗ q0 ∈ Σ0 ⊆ Σ

Let us now consider a transition sequence (i, m) → (i', m') →r (0, 0) of length
r + 1. By the evident induction hypothesis, let P be a proof tree for the sequent
I	m'	'	'
Σ , c	▶ qi' . We consider the three cases for (i, m) → (i , m ).
If ψ(i) = (+, p, i') and m' = m + e .  Hence the identity cm' = cm, c  holds.
p	p
Let Q be a proof tree for ΣI, cm ▶ k according to Proposition 5.3. We provide the following proof tree for ΣI, cm ▶ qi:
P
Q	ΣI, cm, cp ▶ qi'

ΣI	m
I	m	p
(cp −∗ qi' ) −∗ qi' ∈ Σi

, c  ▶ k	Σ , c
ΣI, cm ▶ qi
▶ qi' (k ∧ qp ) −∗ q ∈ Σ

If ψ(i) = (−, p, i', k), mp = 0 and m' = m. Let Q be a proof tree for ΣI, cm ▶ rp
according to Proposition 5.2. We provide the following proof tree for ΣI, cm ▶ qi:

Q
ΣI, cm ▶ rp
P
ΣI, cm ▶ qi'
(rp ∧ qi' ) −∗ qi ∈ Σi

ΣI, cm ▶ qi
If ψ(i) = (−, p, j, i'), m' + ep = m (and mp /= 0). Then the identity cm' , cp = cm

holds. We provide the following proof tree for ΣI, cm' , c ▶ q :




ΣI, cp ▶ cp

⟨Ax⟩

'
P
ΣI, cm'

▶ qi'


cp −∗ (qi' −∗ qi) ∈ Σi

ΣI, cm , cp ▶ qi
In any case we obtain a gBBI proof tree for ΣI, cm ▶ qi which fulfills the require- ments of the induction step.	2
Thus for any X ∈ {ND, D, T, G}, if the relation (1, m) →٨ (0, 0) holds, then by Lemma 5.4 we obtain a proof of ΣI, cm ▶ q1 in gBBI and by Theorem 4.4, this sequent is (universally) valid in BBIX (resp. CBIX).

Faithfulness of the encoding
We use a particular Kripke semantics interpretation in the free abelian group (Zn, +, 0, −). This is the crucial point: provide a model which is suitable for both BBI and CBI. Considering Nn ⊆ Zn as the strict subset of Zn whose vectors have positive components, we define x ◦ y = {x + y} and (Zn, ◦, 0, −, 0) is thus a non- deterministic groupoid of the class G.
We provide the following Kripke interpretation for the variables that might occur in Σ. For p ∈ [1, n] and i ∈ [0, l], we define:

δ(cp) = {ep}	δ(rp) = {m ∈ Nn | mp = 0}	δ(k) = Nn
δ(qi) = {m ∈ Nn | (i, m) →٨ (0, 0)}	δ(qp) = {m ∈ Zn | m + ep ∈ δ(qi)}

Let us now consider the Kripke semantics of the compound formulae of Σ.
Proposition 5.5 For any σ ∈ Σ, 0 H σ holds.
Proof. First let us prove that m H c1 −∗ c1 iff m = 0. Indeed, m H c1 −∗ c1 iff
m ◦ δ(c1) ⊆ δ(c1) iff m ◦ {e1}⊆ {e1} iff {m + e1}⊆ {e1} iff m = 0.
Then m H (c1 −∗ c1) −∗ x iff m ◦ {0} ⊆ δ(x) iff m ∈ δ(x). As 0 belongs to δ(rq), δ(k) and δ(q0), for any variable x ∈ {rq | q ∈ [1, n]}∪ {k, q0}, we have 0 H (c1 −∗ c1) −∗ x.
Let us choose p /= q ∈ [1, n] and let us prove that 0 H cp −∗ (rq −∗ rq). We derive the following logical equivalences: m H cp −∗ (rq −∗ rq) iff m ◦δ(cp) ◦δ(rq) ⊆ δ(rq) iff

m ◦ {ep}◦ {m' ∈ Nn | m'
= 0} ⊆ {m' ∈ Nn | m'
= 0} iff {m + ep + m' | m' ∈

Nn and m'
= 0}⊆ {m' ∈ Nn | m'
= 0}. But for any m' ∈ Nn s.t. m'
= 0, we have

(m + ep + m')q = mq +0+0 = mq. Now (0 + ep + m')q = 0, so 0 H cp −∗ (rq −∗ rq).
Let us choose p ∈ [1, n] and let us prove that 0 H cp −∗ (k −∗ k). We compute: m H cp −∗ (k −∗ k) iff m ◦ {ep}◦ Nn ⊆ Nn iff {m + ep + m' | m' ∈ Nn}⊆ Nn iff m+ ep ∈ Nn. Thus, as 0 + ep = ep ∈ Nn holds, we obtain 0 H cp −∗ (k −∗ k).
Let us consider the formulae in Σi for i ∈ [1, l]. Let us prove that the relation
0 ∈ [[σ ] holds for any σ ∈ Σi.

If ψ(i) = (+, p, j). Let us prove 0 H (cp−∗qj)−∗qp, i.e. m H cp−∗qj implies m H qp
j	j
for any m ∈ Zn. Let us suppose m H cp −∗ qj. Then {m + ep} = m ◦ δ(cp) ⊆ δ(qj)
and thus m + ep ∈ δ(qj). By definition of δ(qp), we obtain m ∈ δ(qp) and thus
j	j
m H qp.
Then let us prove 0 H (k ∧ qp) −∗ qi, i.e. m H k and m H qp implies m H qi for any
n	n  j	j	p
m ∈ Z . Let us pick m ∈ Z  and let us suppose m H k and m H qj . From m H k,
we derive m ∈ δ(k) and hence m ∈ Nn. From m H qp, we derive m + ep ∈ δ(qj). Let m' = m + ep. From m' ∈ δ(qj), we get (j, m') →٨ (0, 0). As m ∈ Nn and ψ(i) = (+, p, j), we have (i, m) → (j, m'). Thus (i, m) → (j, m') →٨ (0, 0) and we conclude m H qi.
If ψ(i) = (−, p, j, k). Let us first prove that 0 H (rp ∧ qj) −∗ qi, i.e. δ(rp) ∩δ(qj) ⊆ δ(qi). Let us pick m ∈ δ(rp) ∩ δ(qj). Then m ∈ δ(rp) and thus mp = 0 and m ∈ Nn. As ψ(i) = (−, p, j, k), we obtain (i, m) → (j, m).  From m ∈ δ(qj), we obtain
(j, m) →٨ (0, 0). Thus (i, m) → (j, m) →٨ (0, 0) and we conclude m ∈ δ(qi).
Let us finally prove that 0 H cp −∗ (qk −∗ qi), i.e. δ(cp) ◦ δ(qk) ⊆ δ(qi). As
δ(cp) = {ep}, let us choose m' ∈ δ(qk) and define m = m' + ep. From m' ∈ δ(qk),
we derive m' ∈ Nn and (k, m') →٨ (0, 0). Then m ∈ Nn and mp = m' + 1 /= 0.
As ψ(i) = (−, p, j, k), we get (i, m) → (k, m'). We derive (i, m) → (k, m') →٨ (0, 0) and obtain m ∈ δ(qi). Thus m' + ep ∈ δ(qi). Hence, for any m' ∈ δ(qk) we get δ(cp) ◦ m' ⊆ δ(qi). Thus δ(cp) ◦ δ(qk) ⊆ δ(qi).	2
In the following lemma and subsequent discussion, we use the common denota- tion ((Zn,.  ), δ) to represent either the BBI-model ((Zn, ◦, 0), δ) or the CBI-model
((Zn, ◦, 0, −, 0), δ). In fact, the non-deterministic monoidal structure is sufficient to interpret the sequents of the fragment eBBI.
Lemma 5.6 For any m ∈ Nn and any i ∈ [0, l], if the sequent ΣI, cm ▶ qi is valid in the model ((Zn,.. .), δ) then the relation (i, m) →٨ (0, 0) holds.
Proof. Let ΣI = {ϕ1,.	, ϕr}. Let ϕ ∈ ΣI. There exists σ ∈ Σ s.t. ϕ = I ∧ σ. Then
0 H σ by Proposition 5.5 and thus we get 0 H I ∧ σ. Hence, for any ϕ ∈ ΣI, we have
0 H ϕ. As ep H cp for any p ∈ [1, n], 0 H σ for any σ ∈ ΣI and
m = m1e1 + ··· + mnen ∈ 0 ◦ ··· ◦ 0 ◦ e1 ◦· · · ◦ e1 ◦ ··· ◦ en ◦	◦ en
(where 0 occurs r times and ep occurs mp times for each p ∈ [1, n]), from the validity of ΣI, cm ▶ qi in the interpretation ((Zn,.  ), δ), we obtain m H qi. Thus m ∈ δ(qi)
and by definition of δ(qi), (i, m) →٨ (0, 0) holds.	2
As the relational monoid (Zn, ◦, 0) (resp. groupoid (Zn, ◦, 0, −, 0)) belongs to all the sub-classes of non-deterministic monoids (resp. groupoids) considered in this paper, for any X ∈ {ND, D, T, G}, if the sequent ΣI, cm ▶ q1 is universally valid in BBIX (resp. CBIX), then it is valid in the model ((Zn,.  ), δ), and by Lemma 5.6,
the relation m ∈ A(M) must hold.
Corollary 5.7 BBI and CBI restricted to their Kripke interpretation on pairs of integers in Z × Z are both undecidable.

Proof. Choose a two counter Minsky machine for which acceptance is not recur- sive [15].	2

Perspectives and Acknowledgments
From this direct simulation of Minsky machines, we obtain a proof of the undecid- ability of BBI/CBI based on a very simple semantic structure, the free commutative group Z × Z. Our undecidability proof would not work for the group Z. Indeed, one counter Minsky machines are a special case of pushdown automata 5 for which the acceptance/reachability problems are known to be decidable [1]. An interesting development would be to study the decidability of BBI/CBI restricted to Z (or only N for BBI).
I wish to thank the anonymous referees for their helpful reviews. Thanks to some observations, Theorem 3.2 has been strengthened. As to one of the remarks, I would not say that the undecidability of the BBI/CBI logics presented in this paper is purely a consequence of the undecidability of the calculus gBBI on the fragment eBBI: we do not know (yet) whether gBBI is complete for all the classes of models considered (i.e. Tg and G).

References
Bouajjani, A., J. Esparza and O. Maler, Reachability Analysis of Pushdown Automata: Application to Model-Checking, in: A. W. Mazurkiewicz and J. Winkowski, editors, CONCUR, Lecture Notes in Computer Science 1243 (1997), pp. 135–150.
Brotherston, J., A cut free proof theory for Boolean BI, Technical Report DTR09-13, Imperial College London (2009), available at http://www.doc.ic.ac.uk/~jbrother.
Brotherston, J. and C. Calcagno, Classical BI: a logic for reasoning about dualising resources, in:
Z. Shao and B. C. Pierce, editors, POPL (2009), pp. 328–339.
Brotherston, J. and C. Calcagno, Classical BI: Its Semantics and Proof Theory, Logical Methods in Computer Science (2010), to appear, available at http://www.doc.ic.ac.uk/~jbrother.
Brotherston, J. and M. Kanovich, Undecidability of propositional separation logic and its neighbours, in:
LICS (2010), also available as technical report http://www.doc.ic.ac.uk/research/technicalreports
/2010/DTR10-1.pdf.
de Groote, P., B. Guillaume and S. Salvati, Vector addition tree automata, in: LICS’04 (2004), pp. 64–73.
Galmiche, D. and D. Larchey-Wendling, Expressivity properties of Boolean BI through relational models, in: S. Arun-Kumar and N. Garg, editors, FSTTCS, LNCS 4337 (2006), pp. 357–368.
Galmiche, D., D. M´ery and D. Pym, The semantics of BI and resource tableaux, Mathematical Structures in Computer Science 15 (2005), pp. 1033–1088.
Ghilardi, S. and G. Meloni, Modal logics with n-ary connectives, Zeitschr. f. math. Logik und Grundlagen d. Math 36 (1990), pp. 193–215.
Girard, J.-Y., Linear logic, Theoretical Computer Science 50 (1987), pp. 1–102.
Ishtiaq, S. and P. O’Hearn, BI as an Assertion Language for Mutable Data Structures, in: POPL, 2001,
pp. 14–26.

5 with just one stack symbol and a non-removable bottom symbol for the empty stack.


Kanovich, M., The direct simulation of Minsky machines in linear logic, in: J.-Y. Girard, Y. Lafont and L. Regnier, editors, Advances in Linear Logic, London Mathematical Society Lecture Note Series 222, Cambridge University Press, 1995 pp. 123–145.
Larchey-Wendling, D. and D. Galmiche, Exploring the relation between Intuitionistic BI and Boolean BI: an unexpected embedding, Math. Struct. in Comp. Science 19 (2009), pp. 435–500.
Larchey-Wendling, D. and D. Galmiche, The Undecidability of Boolean BI through Phase Semantics, in: LICS (2010), full version available at http://www.loria.fr/~larchey.
Minsky, M., Recursive unsolvability of Post’s problem of ‘tag’ and other topics in the theory of Turing machines, Annals of Mathematics 74 (1961), pp. 437–455.
O’Hearn, P. and D. Pym, The logic of bunched implications, Bulletin of Symbolic Logic 5 (1999),
pp. 215–244.
Pym, D., “The Semantics and Proof Theory of the Logic of Bunched Implications,” Applied Logic Series
26, Kluwer Academic Publishers, 2002, errata available at http://www.cs.bath.ac.uk/~pym/BI.html.
Troelstra, A., “Lectures on Linear Logic,” Lecture Notes 29, Center for the Study of Language and Information, Stanford, California, 1992.

A  The soundness of sequent rules
Proposition 4.3 The rules of Figure 1 preserve validity in the model (M, δ).
Proof. The case of rules ⟨id⟩ and ⟨∧R⟩ are trivial. For the other rules, let us write Γ = Γ1,..., Γp (resp. Δ = Δ1,..., Δk) where the Γi’s (resp. Δi’s) are the BBI/CBI formulae composing the multiset Γ (resp. Δ).
For rule ⟨w⟩, we suppose (M, δ) H Γ1,..., Γp ▶ B and we prove (M, δ) H Γ1,..., Γp, I ∧ A ▶ B. For this, let us pick m, m1,..., mp,a ∈ M such that m ∈ m1 ◦ ... ◦ mp ◦ a, m1 H Γ1,..., mp H Γp and a H I ∧ A. Let us prove m H B. From a H I ∧ A, we deduce a H I and thus a = ϵ. Hence, m ∈ m1 ◦ ... ◦ mp ◦ ϵ and thus m ∈ m1 ◦ ... ◦ mp. We also have m1 H Γ1,..., mp H Γp, so, by validity of the sequent Γ1,..., Γp ▶ B in (M, δ), we deduce m H B.
For rule ⟨c⟩, we suppose (M, δ) H Γ1,..., Γp, I ∧ A, I ∧ A ▶ B and we prove (M, δ) H Γ1,..., Γp, I ∧ A ▶ B. For this, let us pick m, m1,..., mp,a ∈M such that m ∈ m1 ◦ ... ◦ mp ◦ a, m1 H Γ1,..., mp H Γp and a H I ∧ A. Let us prove m H B. From a H I ∧ A, we deduce a H I and thus a = ϵ. Hence {a} = a ◦ a and thus m ∈ m1 ◦ ... ◦ mp ◦ a ◦ a. We also have m1 H Γ1,..., mp H Γp, so, by validity of the sequent Γ1,..., Γp, I ∧ A, I ∧ A ▶ B in (M, δ), we deduce m H B.
For rule ⟨IL⟩, we suppose (M, δ) H Γ1,..., Γp,A ▶ B and we prove (M, δ) H Γ1,..., Γp, I ∧ A ▶ B. For this, let us pick m, m1,..., mp,a ∈ M such that m ∈ m1 ◦ ... ◦ mp ◦ a, m1 H Γ1,..., mp H Γp and a H I ∧ A. Let us prove m H B. From a H I ∧ A, we deduce a H A. We also have m1 H Γ1,..., mp H Γp, so, by validity of the sequent Γ1,..., Γp,A ▶ B in (M, δ), we deduce m H B.
For rule ⟨−∗L⟩, we suppose that Γ1,..., Γp ▶ A and Δ1,..., Δk,B ▶ C are valid in (M, δ) and we prove that the sequent Γ1,..., Γp, Δ1,..., Δk,A −∗ B ▶ C is valid

in (M, δ).  For this, let us pick m ∈ m1 ◦ ... ◦ mp ◦ m'
· · · m'
α such that

m1 H Γ1,..., mp H Γp, m' H Δ1,..., mk H Δk and α H A −∗ B. Let us prove
m H C. From m ∈ (m1 ◦... ◦mp) ◦ (m' ◦· · · m' ◦α), we obtain a ∈ m1 ◦... ◦mp such
1	k

that m ∈ a ◦ m' ◦ ··· m' ◦ α (see Proposition 2.3). From m ∈ m' ◦ ··· m'
(a ◦ α),

1	k	1	k
we obtain b ∈ a ◦ α such that m ∈ m' ◦ · · · m' ◦ b.  By validity of the sequent

Γ1,..., Γp ▶ A, we deduce a H A. Since, α H A −∗ B, a H A and b ∈ α◦ a, we deduce b H B. Then, by validity of the sequent Δ1,..., Δk,B ▶ C in (M, δ), we deduce m H C.
For rule ⟨−∗R⟩, we suppose that (M, δ) H Γ1,..., Γp, A▶B and we prove (M, δ) H Γ1,..., Γp ▶ A −∗ B. For this, let us pick m, m1,..., mp ∈ M such that m ∈ m1 ◦ ... ◦ mp and m1 H Γ1,..., mp H Γp. Let us prove m H A −∗ B. Thus, let a, b be such that b ∈ m ◦ a and a H A and let us prove b H B. From b ∈ m ◦ a and m ∈ m1 ◦ ... ◦ mp, we deduce b ∈ m1 ◦ ... ◦ mp ◦ a. By validity of the sequent Γ1,..., Γp,A ▶ B in (M, δ), we obtain b H B.	2
