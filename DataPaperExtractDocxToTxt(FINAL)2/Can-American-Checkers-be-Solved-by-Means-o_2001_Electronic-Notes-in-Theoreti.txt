Electronic Notes in Theoretical Computer Science 47 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume47.html pp. 1 – 19


Can American Checkers be Solved by Means of Symbolic Model Checking?

Michael Baldamus Klaus Schneider Michael Wenz Roberto Ziller
University of Karlsruhe
Institute for Computer Design and Fault Tolerance Formal Methods Group http://goethe.ira.uka.de/fmg



Abstract
Symbolic model checking has become a successful technique for verifying large finite state systems up to more than 1020 states. The key idea of this method is that extremely large sets can often be efficiently represented with propositional formulas. Most tools implement these formulas by means of binary decision diagrams (BDDs), which have therefore become a key data structure in modern VLSI CAD systems.
Some board games like American checkers have a state space whose size is well within the range of state space sizes that have been tackled by symbolic model checking. Moreover, the question whether there is a winning strategy in these games can be reduced to two simple µ–calculus formulas. Hence, the entire problem to solve such games can be reduced to simple µ–calculus model checking problems.
In this paper, we show how to model American checkers as a finite state system by means of BDDs. We moreover specify the existence of winning strategies for both players by simple µ–calculus formulas. Further still, we report on our exper- imental results with our own model checking tool, and we describe some powerful improvements that we have found in trying to solve the game.





Michael Baldamus’s and Roberto Ziller’s work is supported by the Deutsche Forschungsge- meinschaft (German Research Society) within the project Design and Design Methodology of Embedded Systems.
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.















			


Figure 1.	We consider American checkers on boards of different sizes. This figure shows numberings of the squares used in checkers for board sizes from 3 × 3 to 8 × 8.

Introduction
Board games such as checkers, chess or nine men’s morris have a long history of many centuries. This proves the quality of these games, for most of them have survived numerous attempts to be solved, which means to either find a winning strategy for one of the players or to prove that no such strategy exists. The latter case would imply that both players are always able to conduct the game from the initial position to a draw.
Even when such a solution can be found, it is in general too complex to be used by a human player. However, from a computational point of view, this kind of solution is highly interesting, since it leads to a better understanding of practical problems.
A notable success in solving board games has been achieved by Gasser [15]. He showed that there is no winning strategy for nine men’s morris. To obtain this result, Gasser implemented special search algorithms that considered a large state set. Gasser’s work benefited from the fact that nine men’s morris has a highly symmetric state space so that a reduction to symmetry classes reduces the problem to far fewer states.
Computers can play checkers on world champion level with a combination of brute force search and various heuristics [18]. We present an attempt at finding a solution for the game. It is remarkable that checkers does not have any symmetries that can be exploited to reduce the state space. We are there- fore confronted with a much larger state space than in the case of nine men’s morris. Our main idea consist of handling this large state space by symbolic traversal methods that have become popular in the domain of hardware design and finite state verification procedures. In particular, we show in this paper how the problem of finding winning strategies in checkers can be reduced to an equivalent µ–calculus verification problem (see also [20]), and we give results of our experiments. To illustrate the influence of the size of the state space on the computation time, we begin with a 3 × 3 board version of the game and then proceed increasing it towards the 8 × 8 official board size.
The paper is organized as follows: In Section 2, we present the basics of symbolic state traversal techniques and µ–calculus model checking; in Sec- tion 3, we then show how winning strategies in checkers are formulated by µ–calculus formulas, so that the problem of finding such strategies is reduced to µ–calculus model checking; in Section 4 we describe what we have done in the way of actually carrying out that model checking using automated meth- ods. – It turned out that time and memory utilisation are both critical issues. Finally, we conclude the paper with a short summary and a discussion of possible future work.

Basics
One of the most challenging problems in verifying finite state systems is the state space explosion problem. This means that the number of states of a system may exponentially grow with the number of its components. In general, this can not be circumvented, and for this reason, there is a strong interest in algorithms that can traverse large state sets. A successful approach is known as symbolic model checking. This technique has been independently developed by Burch, Clarke, McMillan, and Dill [9,8,10,7], and by Berthet, Coudert, and Madre [4] (both were inspired by [2]). We give in this section a brief explanation of the basics of symbolic µ–calculus model checking. The next subsection is concerned with the use of ordered binary decision diagrams as the key data structure for these algorithms; the subsection afterward formally defines the propositional µ–calculus and a simple model checking procedure for it.
Implicit Representation of Large Sets by OBDDS
The first key idea of this approach is to store sets not by explicit enumeration. Instead, characteristic functions are used to represent sets: Recall that given a set G, the characteristic function χG,M of a subset M ⊆ G is the function that maps any e ∈ M to true, and any e ∈ G \ M to false.
The second key idea is to encode the set G (which must be a finite one) by some boolean variables. Clearly, we need at least [log(|G|)♩ + 1 such variables, but we may use more, say {x1, ... , xn} with n > [log(|G|)♩. Formally, this means that we define two functions ΦG : G → Bn and ΦB : Bn → G, such that
∀e ∈ G.e = ΦB(ΦG(e)) holds. With such an encoding, we can represent any characteristic function χG,M as a propositional formula ϕG,M over the variables
{x1, ... , xn} such that ϕG,M is satisfied by a minterm whenever this minterm encodes a member of the set M . As all equivalent formulas obviously encode the same set, we are particularly interested in propositional normal forms.
While there are many normal forms for propositional formulas that could all be used in this setting, OBDDs as developed by Bryant [5] are best suited for this purpose. OBDDs are based on the so–called Shannon decomposition of a propositional formula ϕ, which says that a formula ϕ is equivalent to x ∧ ϕx:=1 ∨ ¬x ∧ ϕx:=0, denoting by ϕx:=τ the formula obtained by replacing x with τ in ϕ. This decomposition may be viewed as a case distinction where in the first case, it is assumed that x is true, so that ϕ = ϕx:=1 holds, and in the second case, it is assumed that x is false, so that ϕ = ϕx:=0 holds. The formulas ϕx:=1 and ϕx:=0 are sometimes called the cofactors of ϕ.
An OBDD of a formula is obtained by a complete Shannon decomposi- tion until only constants are obtained as cofactors. Bryant’s observation was that OBDDs provide a normal form for propositional formulas whenever the Shannon decomposition is done in the same order for all cofactors. — Hence, they are called ordered BDDs, or OBDDs for short. In the following, we only

1    J,y˜¸` 1z,¸¸¸¸¸¸¸¸¸¸ 0

      
J,x˜¸` z, ¸¸ c
¸¸¸¸¸¸
¸¸zJ,x˜¸` z,

¸¸¸¸¸¸¸¸¸¸
¸¸¸¸¸¸¸¸¸
1	¸¸zJ,y˜¸` z, ¸¸ c	0

0	1,,,,,,,
,,,,,,

z˛
¸¸¸¸¸¸0¸	1
¸¸¸¸¸¸z_
,Jx¸˜ `2,z
1



1 
J,x˜¸` z, , s
n ¸¸¸¸0
¸¸¸z 
J,x˜¸` z,

¸¸¸	n
0	¸¸¸	1

¸¸¸	¸¸¸	¸¸ 1	J,˜¸z` ,z,  0
,,	,,

¸¸¸¸¸¸¸¸¸¸¸¸¸¸
¸¸¸¸	1
,,,,,,,,,,,,,

¸¸¸¸¸ ¸¸¸ ¸¸
  ,,,, ,,,,

¸¸¸¸¸¸¸¸¸¸
 ,,,,,,,,,

¸¸¸¸¸J,˜¸zz` ,, z,,_˛ ,,,s .,,
Figure 2.	BDD for  n


xi ≡ yi.


consider OBDDs, so we simply speak of BDDs.
BDDs can be efficiently implemented and allow us therefore to manipulate large propositional formulas. Hash–tables are used to keep track of previously computed BDDs, so that recomputations are avoided, and common sub–BDDs are shared. For this reason, BDDs may be pictorially represented as acyclic graphs as given in Figure 2 with a single root vertex. Vertices of these graphs are also often called nodes. We denote the number of nodes of a BDD B as
|B|.
Tautologies are all reduced to the leaf node 1, and unsatisfiable formulas to the leaf node 0. For any other formula, we obtain a model of the formula by following any path from the root to a leaf 1.
Using special algorithms given in [5], we can moreover efficiently perform boolean operations such as conjunction or disjunction on BDDs B1 and B2: the result will have at most |B1||B2| nodes. On the other hand, BDDs may still suffer from an exponential blow–up (as any normal form will necessarily do [12]). The size of a BDD crucially depends on the ordering in which the Shannon decomposition is done (also simply called variable orderings). Dif- ferent variable orderings lead to different BDDs that may considerably differ
in their size. For example, any BDD for the formula  n	xi ≡ yi with an
ordering where all xi’s appear before any yi will have an exponential size in n
while the one given in Figure 2 has size 3n + 2.
Today, BDDs are used in many applications, in particular to solve graph based problems. Many variants using different decomposition schemes have been developed [3,13]. A couple of publicly available BDD packages can be downloaded from the Internet [19].

Symbolic Model Checking of the Propositional µ–Calculus
Most verification problems, including the verification of temporal logic specifi- cations, can be reduced to equivalent fixed point problems. This view has been advocated by Emerson and Lei [14] early on in that they have shown how var- ious problems can be naturally expressed using the propositional µ–calculus [16].
Definition 2.1 (Syntax of µ–Calculus) The following rules define the set of
µ–calculus formulas Lµ over a given finite set of variables V:
Variables: each variable is a µ–calculus formula: V ⊆ Lµ
Closure under Boolean Operators: ¬ϕ, ϕ ∧ ψ, ϕ ∨ ψ ∈ Lµ if ϕ, ψ ∈ Lµ Closure under Next–State Operators: EX ϕ, AX ϕ ∈ Lµ if ϕ ∈ Lµ Closure under Fixed Point Operator: µ x.ϕ ∈ Lµ if x ∈V and ϕ ∈ Lµ
We must additionally impose the restriction on Lµ formulas that in case of fixed point formulas µx.ϕ, all occurrences of x in ϕ must be positive, that is, occur beneath an even number of negation symbols. This requirement assures that fixed points exist, and in particular that least fixed points exist. The semantics is given with respect to Kripke structures, which are sometimes also simply called labelled transition systems.
Definition 2.2 (Kripke Structures) A Kripke structure K = (I, S, R, L) for a set of variables V is given by a finite set of states S, a set of initial states I ⊆ S, a transition relation R⊆S× S, and a labeling function L : S → 2V that maps each state to a set of variables.
To define the semantics of µ–calculus formulas, we need to define the existen- tial and the universal predecessor sets of a set of states Q ⊆ S. These are formally defined as:
preR(Q) := {s1 ∈S | ∃s2.(s1, s2) ∈R ∧ s2 ∈ Q}
preR(Q) := {s1 ∈S | ∀s2.(s1, s2) ∈R =⇒ s2 ∈ Q}
preR(Q) is the set of all states that have at least one successor state in Q; and preR(Q) is the set of all states where all successor states belong to Q. To define the semantics, we need one more piece of notation: Given a Kripke structure K, a variable x and a set of states Q ⊆ S, we denote the structure where exactly the states in Q are labelled with x as KQ. All other labels are
retained in the modified structure KQ.
Definition 2.3 (Satisfying States of a Formula) Given a Kripke structure K = (I, S, R, L), we define the set of satisfying states of a state formula Φ as follows:
x)K := {s ∈S | x ∈ L(s)} for all variables x ∈V 
¬ϕ)K := S\ ϕ)K

ϕ ∧ ψ)K :=  ϕ)K ∩ ψ)K
ϕ ∨ ψ)K :=  ϕ)K ∪ ψ)K
EX ϕ)K := preR( ϕ)K)

AX ϕ)
:= preR( ϕ)  )

K	∀	K
µ x.ϕ)	:=	{Q ⊆S |  ϕ) Q ⊆ Q}
x
One can easily verify that  µ x.ϕ)K is the least set of states Q ⊆ S such

that Q =  ϕ) Q
x
holds. Moreover, with the requirement that all occurrences

of x in ϕ are positive, it follows that such a fixed point always exists, and that
there is always a (uniquely determined) least one.
The set of states that satisfy a µ–calculus formula ϕ can be computed by symbolic model checking using Tarski’s famous fixed point theorem [21]. A simple algorithm is given in Figure 3. It is easily seen that the algorithm runs in exponential time in case there are nested fixed point operators. This can be significantly improved [11]. However, the formulas we need to check in order to find winning strategies do not have nested fixed point operators, and therefore the algorithm of Figure 3 is well suited for our purposes.

function  Φ)K
case Φ of
is var(Φ): return {s | Φ ∈ L(s)};
¬ϕ	: return S\  ϕ)K;
ϕ ∧ ψ	: return  ϕ)K ∩ ψ)K;
ϕ ∨ ψ	: return  ϕ)K ∪ ψ)K;
EX ϕ	: return preR( ϕ) );
∃	K
AX ϕ	: return preR( ϕ) );
∀	K
µ x.ϕ	: Q1 := {};
repeat
Q0 := Q1; L := LQ1 ; Q1 :=  ϕ)K;
until Q0 = Q1;
return Q0;
end;

Figure 3. Algorithm for Checking µ calculus formulas

It is easily seen that the set operations can be replaced with corresponding boolean operations when a symbolic encoding with BDDs is used. The com- putation of AX ϕ)K can be reduced to the computation of EX ϕ)K, since we have AX ϕ ≡ ¬ EX ¬ϕ. Hence, the only problem that remains is to compute the function preR(Q).
To see how this is implemented with BDDs, assume that the states

of a particular Kripke structure K are encoded with some boolean state variables, say {x1,... , xn}. The transition relation can then be rep- resented by a propositional formula R(x1,... , xn, x' ,... , x' ) over vari-
1	n
ables {x1,... , xn, x' ,... , x' }, where x1,... , xn encode a current state and
1	n

x' ,... , x'
a successor state.	There is a transition from a state en-

1	n

coded by x' ,... , x' to another one encoded by x' ,... , x'
iff the formula

1	n	1	n
R(x1,... , xn, x' ,... , x' ) is evaluated to true under this assignment of vari-
1	n
ables. In a similar way, we can represent sets of states by propositional for-
mulas over the variables {x1,... , xn}. Now, assume that Q(x1,... , xn) repre- sents a set of states. Then, we can compute the set of existential predecessors preR(Q) with BDDs as follows:
preR(Q) := ∃ x' ... x' .Q(x1,... , xn) ∧ R(x1,... , xn, x' ,... , x' )
∃	1	n	1	n
Existential quantification over a boolean variable is thereby defined as ∃x.ϕ := ϕx:=0 ∨ ϕx:=1. It is important to implement the above ‘relational product’ efficiently, since it is frequently used in the model checking algorithm given in Figure 3. There are a lot of state–of–the–art techniques to do that. We will discuss this issue in more detail in Section 4.

Reducing the Checkers Problem to µ–Calculus Model Checking
Rules
Checkers is played in many variations around the world. The rules presented below are extracted from the web site of the American Checkers Federation [1].
Checkers is played on the dark fields of an 8 × 8–grid of light and dark square fields. The board is placed between the players in such a way that each of them has a light square on his or her near right corner. Each player places his or her pieces on the dark squares of the rows nearest to him or her. The player with the darker pieces makes the first move of the game, and the players take turns thereafter, making one move at a time.
The objective of the game is to prevent the opponent from moving, either by capturing all of his or her pieces or by blocking them. If neither player can accomplish this, the game is a draw.
Single pieces, known as men, move forward only, one square at a time in diagonal direction. They can capture any opposing checker on a diag- onally adjacent square by jumping over it to a free square immediately beyond. Jumping continues as part of the same move as long as there are adjacent opposing pieces with a free square beyond them. Men may not jump over pieces of their own colour.
A man that reaches the far side of the board becomes a king. The op-

ponent must crown the new king before making his or her next move. This implies that a new king cannot continue jumping in the same turn it became crowned.
Kings move and jump forward or backward. They may not jump over pieces of the same colour and may not jump over the same opposing man or king more than once.
When a player is able to make a capture, he or she must do so. If there is more than one way to capture, the player can choose any possibility. However, all the possible captures in the chosen sequence must be made.

Modelling the Game
According to the methodology presented in Section 2, constructing a model for the game amounts to defining the associated Kripke structure and set of variables. An automatic test tool can then verify whether a given assertion in the form of a µ–calculus formula — for example the statement that black (or white) can always win — is true for the given model.
In order to define the state space of the Kripke structure, we use a set of variables that reflect all situations that can possibly be achieved during a game. We choose the variables considering the different states in which a square of the board can be. In addition to being empty, a square can have a man or a king, which can be black or white. Another important consideration that comes from rule VI is whether a man or king must go on capturing during its turn. While in the real game jumping over many pieces is considered a single move, we model each jump as a single transition. The equivalence to the real game is guaranteed through the fact that we do not toggle turns while capturing must go on.
The possible states associated with each square are therefore: ‘empty’, ‘black man’, ‘white man’, ‘man must capture’, ‘black king’, ‘white king’, and ‘king must capture’. These seven possible states for the square i, j can be encoded with three binary variables xi,j, yi,j, and zi,j (with one unused com- bination). An additional variable m tells which player has to move. This information is also used in conjunction with the states where a man or a king must capture, in order to determine its colour. Thus, the number of binary variables for a board of size n × n with d dark squares is


3 × d + 1, where d is given by d =
2
1(n2 + 1)	n odd.

We still need a copy of each variable to represent the current state and the next states in the transition relation of the Kripke structure. Hence, the total number of binary variables is twice the number of variables used to represent the states of the game. We moreover immediately see that there are at most 23 (n2+1)+1 possible game situations.

Defining the State Space and the Initial State
Each state in the Kripke structure corresponds to one of the possible value assignments to the set of variables. This allows us to define the state set of the Kripke structure as the set of all possible value assignments that can be made to the chosen set of variables; we do not list all of those combinations explicitly, since this is clearly impracticable. The variable assignments corresponding to the initial state reflect the starting position of the game with m telling that black has to play.

Defining the Transition Relation
The transition relation φcheckers for the Kripke structure can now be given as a boolean formula that takes into account all the possible moves that can happen from each square. For example, the fact that a black man can move from the leftmost lower corner to the diagonally adjacent square is stated like:
the leftmost lower square has a black man
and the diagonally adjacent square is empty
and in the next state the leftmost lower square will be empty
and in the next state the diagonally adjacent corner will have a black man
and it is black’s turn
and in the next state it will not be black’s turn
and black can not capture
and the next state for all other squares remains equal to the current state
and it is not already a winning state for either black or white
(terms like “its not already a winning state” are also expanded into Boolean assertions about the defined variables). This completes the definition of the Kripke structure. The next step is to write down the formulas that express the behaviour we want to verify in the given model. Two different statements must be made to find out whether there is a winning strategy for black or white. In the formulas presented below, φblack has won is expanded into the Boolean assertion “not black’s turn and white can not move and white can not capture”; φwhite has won is the corresponding term for white. The formula that specifies a winning strategy for black, φblack can win, is

meaning that:
the state is an end–state in which black has won (φblack has won) or
it is black’s turn (m = 1) and there is a next state in which the formula is recursively true for at least one next move (EX x) or
it is white’s turn (m = 0) and the formula is recursively true for all possible next moves (AX x)

The formula that specifies a winning strategy for white, φwhite can win, is defined analogously:

The formulas φblack has won and φwhite has won can also be easily defined by µ– calculus formulas: φblack has won := ¬m ∧ AX 0 and φwhite has won := m ∧ AX 0. To see that these definitions are correct, note that AX 0)K is the set of states of K that have no outgoing transition. Hence, φblack has won means that it is white’s turn (m = 0), but there is no possibility to proceed with the game, and analogously for φwhite has won. Using these definitions of φblack has won and φwhite has won, we can furthermore simplify our µ–calculus formulas as follows:
φwhite can win ≡ µx.φwhite has won ∨ (¬m ∧ EX x) ∨ (m ∧ AX x)
≡ µx.(m ∧ AX 0) ∨ (¬m ∧ EX x) ∨ (m ∧ AX x)
≡ µx.(m ∧ (AX 0 ∨ AX x)) ∨ (¬m ∧ EX x)
≡ µx.(m ∧ AX x) ∨ (¬m ∧ EX x),

using the law AX 0 ∨ AX φ ≡ AX φ. With this formalisation of winning strategies as µ–calculus formulas, the problem is now reduced to µ–calculus model checking. This means that all we have to do is to use the algorithm given in Figure 3 to compute the set of states  φblack can win)Kcheckers , where
Kcheckers is the Kripke structure for the checkers game, and φblack can win is
	
the above–defined formula. Note that φblack can win)Kcheckers is the set of states where black has a winning strategy. In particular, this is the case for the states where black has won, hence, we clearly have  φblack has won)Kcheckers ⊆
 φblack can win)Kcheckers , so this set is certainly not empty. The important ques-
tion is, however, whether the initial position of the game belongs to either
 φblack can win)Kcheckers or φwhite can win)Kcheckers , which would mean that either black or white has a winning strategy from the beginning.

Carrying Out the Model Checking Using Automated Methods
In Section 2 we have recalled the basics of the symbolic model checking of µ– formulas; in Section 3 we have described a reduction of the checkers problem to the satisfaction of two specific µ–formulas. This section combines these strands: We describe how we have used automated symbolic methods in trying to solve the verification task set out in Section 3.

Building the BDD Representation of φcheckers
To begin with, we consider the BDD representation of checkers, that is, the BDD normal form of the transition relation of checkers given in the preceding section. This sub–task has to be completed for all attempts to solve checkers by symbolic traversal methods. The aim is to find a representation with as few BDD nodes as possible.
Several values can be found in Table 1, as we have not only considered the 8 × 8–board but also smaller boards starting from a 3 × 3–board. It is thereby possible to find out just how far one can get in solving checkers through symbolic model checking.
All values are stated for both a fixed and a heuristically optimised variable ordering. The fixed ordering is respectively called the horizontal ordering and was chosen for simplicity. It is given by


m	≺	xi1
i1 ≺ yi1
i1 ≺ zi1
'	≺	... 

...	≺	xin
in ≺ yin
in ≺ zin	in

where n is the number of black squares, i1,..., in is the numbering of these squares as it is depicted in Figure 1 and ‘'’ designates a next state variable. The optimised ordering was in all cases computed by the built–in sifting algorithm of the SMV model checker.


Table 1
BDD sizes in representing checkers.

As for interpreting these figures, the tool that we have used for trying to solve checkers needs 16 bytes to store each BDD node (cf. Figure 4 on the next page). It is thus possible to represent checkers in 74 MB of main memory, given that one uses the horizontal variable ordering. Only 26 MB are required if one uses the ordering computed by the SMV tool.


Figure 4.	SymQuest — a verification tool.

Verifying φblack can win and φwhite can win
Failure of Straightforward Symbolic Model Checking
For our experiments, we mustered a PC with 1 GB of main memory. Two facts gave hope that we might be able to solve checkers: first, the possibility of using just 26 MB to represent the game; second, 500,995,484,682,338,672,639 is the number of positions according to [22], a figure well within the range of state space sizes tackled with symbolic model checking to date. Our next step was
therefore to compute φblack can win)Kcheckers or φwhite can win)Kcheckers right away, without any optimisations. The result was disappointing, as the verification process got stuck due to memory overflow. Using swap space is not an op-
tion; the reason is that BDD packages slow down drastically once swapping occurs, confirming a general experience with the runtime behaviour of BDD algorithms.
Investigating Various Optimisation Heuristics
Because of the above–described failure, we concluded that the decisive issue was to reduce the peak number of BDD nodes allocated during verification. This proposition, in turn, led us to investigating various techniques that can influence BDDs sizes in symbolic model checking.

Restricting Model Checking to Reachable States
One technique consists of restricting model checking to reachable states. It depends on the particularities of the respective verification task whether the BDDs involved become smaller in this way, but often they do become smaller. As far as our purposes are concerned, this approach requires a BDD that represents the set of reachable states. This BDD can also be subject to the size problem. It turns out that checkers is a case where this calamity occurs. Specifically, we have not been able to build the BDD for the set of reachable states beyond the 5 × 5–case (cf. Table 2). We concluded that restricting
model checking to reachable states is, therefore, not a road to success.

3 × 3
4 × 4
70
2081

5 × 5 ≈ 1, 400, 000

Table 2
BDD sizes in representing the reachable states of checkers using SMV with sifting turned on.

Ruling out States with Too Many Pieces
A technique that is similar to restricting model checking to reachable states consists of ruling out at least some unreachable states, again hoping that the ensuing BDDs become smaller. We have found such a technique; it leads to a significant reduction of the peak number of BDD nodes at least in the 3 × 3– and 4 × 4–cases. What is more, the peak number in these cases is actually smaller than what is achieved by the restriction to reachable states. We expect that this overall situation also prevails in all other cases.
The idea is simply to rule out (unreachable) states that contain more black or white pieces than are theoretically possible; on an 8 × 8 board, for example, at most 12 pieces of each color are possible. Technically, let φlimit be a formula that characterises all (reachable or un–reachable) states with at most p black pieces and at most p white pieces, where p is the number of pieces of each color at the beginning. The model checking algorithm is so modified as to substitute the formula φcheckers ∧ φlimit for the formula φcheckers at all places. Concrete results are such that the peak number of BDD nodes in verifying 4 × 4–checkers is reduced from 90, 125 to 19, 725 relative to the horizontal variable ordering. Another benefit is a reduction of the number of fixed point iterations from 32 to 16.

Finding a Good Variable Ordering
Up to this point, we had not devoted any serious attention to the issue of finding a variable ordering that was as good as possible. There are lots of heuristics for this task, but we adopted a brute force method. What we did was to consider all permutations of the black squares of the 4 × 4–board; we verified φblack can win with each one of the corresponding variable orderings, analysing what orderings led to the lowest peak in BDD node usage. This program was manageable because of the short runtime of the 4 × 4–case on a 500 Mhz PC combined with the fact that there are only 40, 320 permutations of those 12 squares. — We only considered placing m at the beginning or at the end of the ordering. Also, our orderings were always such that xi, x' , yi y',
i	i
zi and z' occurred in this same order and without any interspersed variables

for each square i. To our experience, tearing apart such blocks of closely connected variables is almost never advantageous.
The result was that all of the 100 best orderings were variations of a unique diagonal pattern, and that this pattern itself was only marginally worse than the best ordering. The pattern is shown in Figure 5. It reduces the above– stated peak of 19, 725 to 16, 415 when m is placed at the beginning. We expect that analogous orderings are also good for verifying φblack can win and φwhite can win for the other board sizes.



Figure 5.	Diagonal square ordering.
On a more intuitive remark, it is not unusual in symbolic model checking that problems with some kind of regular structure are best encoded with some kind of regular variable ordering. This situation seems to prevail in the case of American checkers as well. Specifically, the game has a regular structure in the sense that the board is regular and in the sense that only a small number of adjacent squares are directly involved in each individual move, where the rules governing this move are always the same up to the possible promotion of a man to a king. Then, the diagonal variable ordering is obviously regular too.
Partitioning the BDD Used to Represent φcheckers
Still another possibility of reducing the peak number of BDD nodes consists of partitioning the BDD used to represent φcheckers (cf. [6]).
The background consists in part of the fact that the most costly BDD operation that we need is the relational product of φcheckers and ψ (cf. Sec- tion 2).; its (exponential) worst case complexity is |BDD(χ))||X|, where χ is the formula beneath the quantifier, BDD(χ) is its BDD representation and X is the set of quantified variables.
The other background aspect of partitioning is that φcheckers has the form
φ1 ∨ ··· ∨ φk
for some k ≥ 1, where every φi describes what moves can occur on two specific, diagonally adjacent squares s1 and s2, or what jumps can occur on three such squares s1, s2 and s3, where a piece on s2 is taken. Every φi is given as
φi := φi,change ∧ φi,stable.

The first formula, φi,change, is a formula over m, m' and the variables associated with s1 and s2 or with s1, s2 and s3; this formula describes the actual moves or jumps. The second formula, φi,change, is a formula over all other variables; this formula is a conjunction of equivalences of the form x ≡ x', which determine that those moves or jumps leave the rest of the board unaffected.
The idea is to rewrite the relational product of φcheckers and ψ so that existential quantification occurs not once over all but several times over some next state variables. To this end, we exploit that existential quantification distributes over disjunction, meaning that

∃s '.φcheckers ∧ ψ[s '/s ] ≡ (∃s '.φ1 ∧ ψ[s '/s ]) ∧· · ·∧ (∃s '.φk ∧ ψ[s '/s ]).

We also exploit that substituting x' for x in ψ and quantifying over it is unnecessary if φi,stable determines x ≡ x'; this property entails


∃s '.φi ∧ ψ[s '/s ] ≡ ∃s '
.φi,change ∧ ψ[s '
/si,change],



'
i,change
is the vector of free variables of φi,change,1 ≤ i ≤ k.

In sum, each quantification involves 7 or 10 variables regardless of the
board size, and the formula beneath the quantifier does not involve φcheckers but φi,change, 1 ≤ i ≤ k. What is more, such a φi,change is only moderately complex and also independent of the board size up to variable renaming; for this reason, its BDD representation is much smaller than that of φcheckers. The effect is another reduction of the space and time requirements of verifying φblack can win and φwhite can win. A particular advantage is that building the BDD representation of φcheckers becomes unnecessary; it suffices to build the BDD representation of each individual φi,change. This situation is the reason why one speaks of partitioning, or of disjunctive partitioning, as far as our context is concerned.
A tradeoff involved in partitioning consists of the time and space necessary to form the BDD representation of


k
'
i,change

.φi,change ∧ ψ[s '

/si,change]

i=1


in terms of the representation of each individual disjunct ∃s '
.φi,change ∧

'
i,change
/si,change]. Working with fewer partitions may in general be more

time but less space efficient. Indeed, our most space efficient run for the
4 × 4–board involves full partitioning, has a peak of 11, 945 nodes and requires 37.09 seconds of user time on a 500 MHz Pentium III PC under Linux. The user time can be reduced to 15, 77 seconds by keeping all options but using 10 partitions. In this case the peak is 16, 180.

Putting Everything Together
Finally, putting everything together means to use our optimisations all at once, that is, replacing φcheckers by φcheckers ∧ φlimit, using the diagonal variable ordering and partitioning φcheckers ∧ φlimit, which is possible since φcheckers ∧ φlimit ≡ (φ1 ∧ φlimit) ∨ · · · ∨ (φk ∧ φlimit). The above–stated peak of 11, 945 nodes is actually the outcome of that. Specifically, our experimental results indicate that 11, 945 nodes is the best 4 × 4–peak that those optimisations can achieve.
Conclusions
We have explored the question whether American checkers can be solved by means of symbolic model checking of µ–formula. To this end, we have first described how the game can be represented with a boolean formula; second, we have described what those µ–formulas look like; third, we have reported our failure in terms of straightforward model checking; fourth, we have examined the effect of various optimisations on the verification process.
The next question is how far our optimisations can get us with respect to board sizes bigger than 4 × 4. Here, we mention that a 5 × 5–run without optimisations got stuck for days in the fourth iteration before we terminated it; with the maximum number of partitions and the other optimisations, the average over several weeks is between one and two days per iteration. More- over, memory utilisation stabilises at a staggering 500 MB. At far lower levels, this kind of stabilisation can also be observed in the 3 × 3– and 4 × 4–cases. For the record, our results in terms of solving the game are stated in Figure
6. The total user time needed to solve the 5 × 5–case was about two months on platform mentioned in Section 4.


3 × 3
4 × 4
5 × 5
6 × 6– 8 × 8
white can win a draw
black can win
?


Figure 6.	Final results. Note that the 3 × 3–case can very easily be solved without a computer.
We conclude two things: First, our optimisations scale up as the 5 × 5– case becomes solvable if one is patient enough; second, the jump from 4 × 4 to 5 × 5 in terms of memory utilisation is so drastic that it is not obvious how one could get beyond 5 × 5, even if time utilisation were not an issue. The checkers problem thus seems to be a very hard and peculiar one if one tries to solve it with symbolic model checking.

References
American	Checkers	Federation,	Official	Website	(May	2000),
http://www.acfcheckers.com.
Beatty, D., R. Bryant and C.–J. Seger, Synchronous Circuit Veriﬁcation by Symbolic Simulation: an Illustration, in: W. Dally, editor, Advanced Research in VLSI (1990), pp. 98–112, conference proceedings.
Becker, B. and K. Drechsler, How Many Decomposition Types Do We Need?, in: Design and Test (1995), pp. 438–443, proceedings EDTC ’95.
Berthet, C., O. Coudert and J. Madre, New Ideas on Symbolic Manipulation of Finite State Machines, in: Computer Aided Design, 1990, proceedings ICCAD ’90.
Bryant, R., Graph–Based Algorithms for Boolean Function Manipulation, IEEE Transactions on Computers C–35 (1986), pp. 677–691.
Burch, J., E. Clarke and D. Long, Representing Circuits More Efficiently in Symbolic Model Checking, in: Design Automation, 1991, pp. 403–407, proceedings DAC ’91.
Burch, J., E. Clarke, D. Long, K. McMillan and D. Dill, Symbolic Model Checking for Sequential Circuit Veriﬁcation, IEEE Transactions on Computer– Aided Design of Integrated Cicuits and Systems 13 (1994), pp. 401–424.
Burch, J., E. Clarke, K. McMillan and D. Dill, Sequential Cicuit Veriﬁcation Using Symbolic Model Checking, in: Design Automation (1990), pp. 46–51, proceedings DAC ’90.
Burch, J., E. Clarke, K. McMillan, D. Dill and L. Hwang, Symbolic Model Checking: 1020 States and Beyond, in: Logic in Computer Science (1990), pp. 1–33, proceedings LICS ’90 symposium.

Burch, J., E. Clarke, K. McMillan, D. Dill and L. Hwang, Symbolic Model Checking: 1020 States and Beyond, Information and Computation 98 (1992),
pp. 142–170.
Cleaveland, R. and B. Steffen, A Linear–Time Model Checking Algorithm for Alternation–Free µ–Calculus, Formal Methods in System Design 2 (1993),
pp. 121–147.
Cook, S., The Complexity of Theorem Proving Procedures, in: Theory of Computing, 1971, ACM symposium proceedings.
Drechsler, R., B. Becker and A. Jahnke, On Variable Ordering and Decomposition Type Choice in OKFDDs, in: W. Grass and M. Mutz, editors, Anwendung formaler Methoden beim Entwurf von Hardwaresystemen (1995),
pp. 98–107, GI/ITG workshop proceedings.

Emerson, E. and C.–L. Lei, Temporal Reasoning under Generalised Fairness Constraints, in: B. Monien and G. Vidal–Naquet, editors, Theoretical Aspects of Computer Science (1986), pp. 21–36, proceedings TACAS ’86 conference.
Gasser, R., “Efficiently Harnessing Computational Resources for Exhaustive Search,” Ph.D. thesis, computer science department, Eidgeno¨ssische Technische Hochschule Zu¨rich (1994).
Kozen, D., Results on the Propositional µ–Calculus, Theoretical Computer Science 27 (1983), pp. 333–354.
Sanghavi, J., R. Ranjan, R. Brayton and A. Sangiovanni–Vincentelli, High– Performance BDD Package by Exploiting Memory Hierarchy, in: Design Automation, 1996, pp. 635–640, proceedings DAC ’96.
Schaeffer, J., R. Lake, P. Lu and M. Bryant, Chinook: The Man–Machine World Checkers Champion, AI Magazine 17 (1996), pp. 21–29.
Sentovich, E., A Brief Study of BDD Package Performance, in: M. Srivas and
A. Camilleri, editors, Formal Methods in Computer Aided Design, LNCS 1166 (1996), pp. 389–403, proceedings FMCAD ’96 conference.
Shilov, N. and K. Yi, Puzzles for Learning Model Checking, Model Checking for Programming Puzzles, Puzzles for Learning Model Checkers, in: H. Bowman, editor, Formal Methods Elsewhere, Electronic Notes in Theoretical Computer Science (2001), proceedings FM–Elsewhere 2001 workshop.
Tarski, A., A Lattice–Theoretical Fixpoint Theorem and its Applications, Pacific Journal of Mathematics 5 (1955), pp. 285–309.
University of Alberta, Department of Computer Science, Chinook Website (May 2000), http://www.cs.ualberta.ca/∼chinook.
