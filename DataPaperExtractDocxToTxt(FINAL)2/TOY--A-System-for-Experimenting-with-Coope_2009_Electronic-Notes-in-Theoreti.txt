

Electronic Notes in Theoretical Computer Science 258 (2009) 79–91
www.elsevier.com/locate/entcs

TOY: A System for Experimenting with Cooperation of Constraint Domains
S. Est´evez-Mart´ın†, A. J. Ferna´ndez Leiva∓, and F. Sa´enz-P´erez‡1

†Dept. Sistemas Informa´ticos y Programaci´on, ‡Dept. Ingenier´ıa del Software e Inteligencia Artiﬁcial
Universidad Complutense de Madrid, Spain
∓Dept. Lenguajes y Ciencias de la Computacio´n Universidad de M´alaga, Spain
s.estevez@fdi.ucm.es, afdez@lcc.uma.es, fernan@sip.ucm.es


Abstract
This paper presents, from a user point-of-view, the mechanism of cooperation between constraint domains that is currently part of the system T OY , an implementation of a constraint functional logic programming scheme. This implementation follows a cooperative goal solving calculus based on lazy narrowing. It manages the invocation of solvers for each domain, and projection operations for converting constraints into mate domains via mediatorial constraints. We implemented the cooperation among Herbrand, real arithmetic (R), finite domain (FD) and set (S) domains. We provide two mediatorial constraints: The first one relates the numeric domains FD and R, and the second one relates FD and S.
Keywords: Tools, Multiparadigm Programming, Constraint Functional Logic Programming, Domain Cooperation.


Introduction
T OY [1] is a multiparadigm programming language and system designed to support the main declarative programming styles and their combination. One

1 First and third authors partially supported by projects TIN2008-06622-C03-01, S- 0505/TIC/0407 and UCM-BSCH-GR58/08-910502. Second author partially supported by Spanish MICINN under contract TIN2008-05941 (NEMESIS project).




1571-0661© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.006

of its characteristics is that it provides support for functional logic program- ming, and programs in T OY can include definitions of types, operators, lazy functions in Haskell style, as well as definitions of predicates in Prolog style. A predicate is viewed as a particular kind of function whose right-hand side is true. A function definition consists of an optional type declaration and one or more deﬁning rules, which are possibly conditional rewrite rules. Both func- tions and predicates must be well-typed with respect to a polymorphic type system [4].
With the aim of increasing the efficiency of goal solving, T OY also provides capabilities for constraint programming, and programs can use constraints within the definitions of both predicates and functions. Constraints are inte- grated as functions to make them first-class citizens what means that they can be used in any place where a data can (e.g., as arguments of functions). This provides a powerful mechanism to define higher order constraints. The con- straints that have been integrated and supported by the system in recent years include symbolic equations and disequations [2], linear and non-linear arith- metic constraints over the real numbers [12], and finite domain constraints [9]. Now, T OY also incorporates a solver to manage set constraints [6].
It is well-known that constraint solving defined on specific domains (e.g., reals, finite domain, sets, etc.) can help to speed up the goal resolution, and also opens up the range of problems that a system can efficiently attack. How- ever, it also presents evident drawbacks as, in practice, constraints are often not specific to any given domain, and thus the formulation of real problems has to be artificially adapted to a domain that is supported by the system. Many problems are more naturally expressed using heterogeneous constraints, involving more than one domain. Precisely, this problem can be smoothed via solver cooperation and T OY has recently incorporated a mechanism to sup- port it [5,7]. A detailed description of the mechanism involving three specific domains, namely Herbrand, real, and ﬁnite domains, is given in [8].
This document belongs to this collection of papers-illustrating-T OY-features. However, the reader should note that, even though many features of T OY have already been reported in a number of papers, this paper presents original ma- terial and highlights some of the recent acquired capacities of T OY by means of examples. In particular, the paper focuses in the solver cooperation mech- anism including the cooperation between the finite domain and set solvers that has recently been integrated into T OY [6]. Besides illustrating the new features of the T OY system, an additional goal of this paper is to show that this system constitutes an adequate framework on which experimentation with solver collaboration can be carried out.

T OY Distribution
From http://toy.sourceforge.net the preferred distribution for T OY can be downloaded. There are some possibilities: Choose either a binary distribu- tion (a portable application that does not need installation) or a source-code distribution (which requires SICStus Prolog previously installed). Therefore, almost any platform can run T OY (e.g., the system can be started as a Win- dows application or in a Linux console). It features a command interpreter for submitting goals and system commands. In addition, it has been con- nected to ACIDE [15], a graphical and configurable integrated development environment.
An Overview of T OY
T OY computations solve goals and display computed answers. T OY solves goals by means of a demand driven lazy narrowing strategy [13] combined with constraint solving. Answer constraints can represent bindings for logic vari- ables, as in answers computed by a Prolog system. Some features of T OY are:
Curried Style. This allows that partial applications of curried functions can be used to express functional values as partial patterns.
Non-deterministic Functions. These are introduced either by means of defining rules with overlapping left-hand sides or using extra variables in the right-hand side that do not occur in the left-hand side.
Sharing for values of all variables which occur in the left-hand sides of defining rules and have multiple occurrences in the right-hand side and/or the conditions. Sharing implements the so-called call-time choice seman- tics of non-deterministic functions.
Higher-Order Functions in the style of Haskell, except that lambda ab- stractions are not allowed. In T OY, higher-order can be naturally com- bined with non-determinism.
Dynamic Cut. Optimization that detects deterministic functions at com- pile time, and the generated code includes a test for detecting at run-time the computations that can actually be pruned [3].
Finite Failure. The primitive Boolean function fails is a direct counter- part to finite failure in Prolog.
A Constraint Functional Logic Programming Scheme
T OY implements a Constraint Functional Logic Programming scheme CFLP (D) over a parametrically given constraint domain D, proposed in [14]. CFLP (D)

is a logical and semantic framework for lazy Constraint Functional Logic Pro- gramming over D, which provides a clean and rigorous declarative semantics for CFLP languages.
In particular, D is the coordination domain C introduced in [7] as the amalgamated sums of the domains to be coordinated, D1,..., Dn, along with a mediatorial domain M which supplies special communication constraints, called bridges, used to impose the equivalence between values of different base types.
The Cooperative Constrained Lazy Narrowing Calculus CCLNC(C) pre- sented in [7] provides a fully sound formal framework for functional logic pro- gramming with cooperating solvers over various constraint domains. CCLNC(C) has been proved fully sound w.r.t. the CRWL(C) semantics [14].
Cooperation in T OY: Bridges and Projections
The current downloadable version of T OY (see Section 1.1) comes equipped with solvers corresponding to three constraint domains:
Herbrand, with equality and disequality constraints.
Real Arithmetic, with arithmetic constraints over real numbers.
Finite domain, with constraints over integer numbers.
The Herbrand Solver is always available, and the real and finite domain solvers can be optionally loaded. A beta version of T OY (available soon) now also includes a solver to handle set constraints that allows constraint solving on intervals of sets of integers. The set constraint domain has been implemented in the beta version which has not been yet released.
With the aim of extending the system applicability, a mechanism for solver cooperation on these domains has been recently incorporated. This mecha- nism has two main pillars: bridges, necessary for solver communication, and projection, that improves the efficiency of some programs.
A bridge is a special kind of ‘hybrid’ constraint which allows the communi- cation between two constraint domains and instantiates a variable occurring at one end of a bridge whenever the other end becomes ground. The next examples show this communication between FD and R.
Example 3.1 In the cooperation ﬁnite domain-real domain, a bridge con- straint (identified by the function #== /2; see the code below) can be used to impose an integral constraint over its right (real) argument. As an example, suppose we want to know whether two different lines can meet at one integer point. A line can be described algebraically by the linear equation y = m * x
+ b, and the corresponding T OY program and goal are as follows, where the

symbol <== starts the conditional guard, == represents the equality constraint, and -> stands for a substitution.

Projection takes place during goal solving whenever a constraint is sub- mitted to its solver. At that moment, projection builds a mate constraint which is submitted to the mate solver (think, for instance, of a finite domain solver as the mate of a real solver, and vice versa). Projection rules described in [5,7] relying on the available bridges are used for building mate constraints between the finite and real domains. The next example shows how projection builds and posts new mate constraints.
Example 3.2 Suppose we want to calculate the intersection of a triangular region (defined in the continuous plane) with an (N×N)-size square discrete grid (defined in the discrete plane). A T OY goal that solves the problem, for any given even integer number N, is shown below; the triangular region is described by the inequalities in the real domain whereas the square grid is described by the finite domain constraints (i.e., those labeled with # and the function labeling/2).

In this example, mate constraints generated during goal solving, allow the

finite domain solver to drastically prune the domains of X and Y. Therefore, if we have a huge grid and a tiny triangle and the projection is enabled, then the computation time is notably reduced. Note that not all the constraints are projected; for example, the labeling constraint.	 
The new bridge constraint for the cooperation ﬁnite domain-set domain is provided via the infix function: #--/2, where its left argument is an integer and the right one is a set, which follows the datatype declaration data setOfInt
= set [int]. The next example shows its behaviour when projection has been both disabled and enabled.
Example 3.3 The following table shows a goal with projection disabled, where no mate constraints have been created. Here, FDVar in Min..Max stands for a domain constraint stating that the value of FDVar must be in the integer closed range [Min,Max]. Also, SVar in Min..Max is a domain con- straint stating that SVar must contain, at least, the elements in the set Min, and, at most, the elements in the set Max.

Next, enabling projection, we get a more constrained answer because of the projection due to the constraints domainSet and subSet. Here, it can be seen a finite domain interval constraint which is expressed by means of integer closed intervals and unions of integers (1..5 represents the set containing integers from 1 to 5, and ∨ is set union).


We have borrowed the idea of constraint projection from [11], adapting it to our CFLP scheme and adding bridge constraints as a novel technique which

makes projections more flexible and compatible with the type discipline.

Getting Started with the T OY System
Whichever method you use to start T OY as described in the manual [1], you get a banner and a system prompt as displayed in the bottom panel of Figure 1.

Fig. 1. A Screenshot of Toy running into ACIDE.

This figure shows T OY running into ACIDE [15], a configurable IDE (In- tegrated Development Environment) consisting of three main panels. The left panel shows the organization of the current project, the MDI windows to the right are the opened files, which may belong to the project (files can be opened without assigning them to the project). Below, the T OY console panel is shown, which allows the user to interact by means of typed commands and expressions. Both shell and project panels can be hidden and, moreover, it is not mandatory to work with projects if they are not needed. The menu bar in- cludes some common entries about files, edition, projects, views, configuration and help. In addition, there is a fixed toolbar which includes common buttons for file and project-related basic operations: New, Open, Save, and Save All (this last one only for files). Next to the fixed toolbar, there is the configurable

toolbar, which in this case includes the most usual T OY commands.
The last line in the console panel (Toy>) is the T OY system prompt, which allows writing commands, executing goals, and computing expressions. The typical way of using the system is to write T OY program files (with default extension .toy) and consulting them before submitting goals. Following this, you write the program in a text file, and then you use the following command in order to compile and load the T OY program:
Toy> /run(Filename)
Where Filename is the name of the file, as bothIn.toy (the default extension
.toy can be omitted). If the file is located in the distribution directory, you can also type:
Toy> /run(bothIn.toy)
Otherwise, when the file is located at another path, you can firstly change to the new path using the command /cd(Path), where Path is the new direc- tory (relative or absolute). However, things are much easier from the ACIDE environment since you can simply push the button run and get the file com- piled and loaded. In addition, solvers can be activated by pushing the buttons cflpr, cflpfd, and cflpset.

Examples
The main part of the demonstration will be devoted to display examples of T OY programs to solve cooperation problems, as those described in the fol- lowing.

Scheduling Tasks Problem via Cooperation between solveFD and solveS





Fig. 2. Precedence Graph.
The tasks scheduling problem requires resources to complete, and consists of fulfilling precedence constraints. Figure 2 shows a precedence graph for four

tasks which are labeled as tXY
, where X stands for the identifier of a task t,

Y for its time to complete (duration), and Z for the identifier of a machine m (a resource needed to perform task tX). In this case, this problem is solved using the cooperation of solveFD and solveS with the program below. The constraint functions and operators that belong to the finite domain are: sum, #=, and #<, and set constraint functions are: domainSet, cardinalSet, and intersectSet. Bridges between finite domain variables and set variables are established by the function #--/2 in such a way that a goal F #-- S projects constraints involving the variable S into constraints involving the variable F.
durationList :: [int] durationList = [3,1,2,2]
% Auxiliary Functions listFrom1To :: int -> [int]
listFrom1To X = take X (iterate (+ 1) 1)
% Main Function
scheduling :: [setOf int] -> [int] -> bool scheduling TasksSet TasksFD = true <==
TasksSet == [T1S, T2S, T3S, T4S], TasksFD == [T1FD, T2FD, T3FD, T4FD],
% Bridges T1FD #-- T1S ... T4FD #-- T4S
foldl and true (zipWith (#--) TasksFD TasksSet),
% The time of execution of all tasks is, at most,
% the sum of the durations of all the tasks, sum durationList (#=) Time,
% The time of execution of every task can be placed in the time
% interval defined from 1 to Time
domainSet TasksSet (set []) (set (listFrom1To Time)),
% The duration of a task corresponds to the cardinal of its set map cardinalSet TasksSet == durationList,
% Precedences
fd_max T1FD #< fd_min T3FD, fd_max T2FD #< fd_min T3FD,
% Machine m1 can be assigned to a single task at a time

intersectSet T1S T2S (set []),
% Machine m2 can be assigned to a single task at a time intersectSet T3S T4S (set [])
Some solutions to a goal for this problem are represented in Fig. 3, which corresponds to selected answers given at the system prompt Toy(FD+R+S+p). In this prompt, FD+R+S+p indicates that FD, R, and S constraints libraries are loaded, and projection (p) has been enabled, respectively. The next interactive session excerpt corresponds to the solution of the left-upper part of this figure. Here, TiS are the S variables whilst TiFD are the FD variables.
T4	T4


T1


T4
T1	T2
T2	T3	T4
T1
T4

T1	T3	T3
T4
T2	T1	T3

T4
T1	T1	T2
T4
T1	T3


Fig. 3. Some Solutions of the Scheduling Problem.

Toy(FD+R+Set+p)> scheduling [T1S,T2S,T3S,T4S] [T1FD,T2FD,T3FD,T4FD]
cardinalSet T1S 3,
cardinalSet T3S 2,
cardinalSet T4S 2,
T3S in ([],close):*:(min T4S)..top,
T4S in ([],close):*:(min T3S)..top, T1FD in 1..3,
T3FD in 5..6, T4FD in {1}\/{3} }

This problem can be solved using only finite domain constraints [1], but solver cooperation leads to a more natural formulation.

Electrical Circuit Problem requiring the Cooperation between solveFD and
solveR
Consider also a problem taken from [10], in which one has an electric circuit with some connected resistors (i.e., real variables) and a set of capacitors (i.e., FD variables). The goal consists of knowing which capacitor has to be used so that the voltage reaches the 99% of the final voltage within a given time range. Particularly, we consider an instance of the problem (see Figure 4) with a resistor R1 of 0.1 M Ω connected in parallel with a variable resistor R2 of between 0.1 M Ω and 0.4 M Ω, a capacitor K connected in series with the two resistors. Also, capacitors of 1μF , 2.5μF , 5μF , 10μF , 20μF , and 50μF are available. The considered range time is [0.5,1], i.e., the duration until the capacitor is loaded is between 0.5 seconds and 1 second. Below we show a very simple T OY program (and a goal solved at the command line level) to solve this instance using distinct numerical solvers. Note that this problem cannot be solved by a unique solver and thus requires solver cooperation.
ecircuit :: int
ecircuit = KI <== R1 == 10000,
10000 <= R2, R2 <= 40000,	% R Constraints
R == R1*R2/(R1+R2),	%
50000.0 <= R, R <= 80000.0,	% T == -(ln 0.01)*R*K/10000000.0,	%
0.5 <= T, T <= 1.0,	%
KI #== K,	% FD-R Bridge
belongs KI [10,25,50,100,200,500], % FD constraints labeling [ ] [KI]	%
Toy(R+FD)> ecircuit == L	% Goal solving
{ L -> 25 }

Conclusions and Further Work
This paper demonstrates, via examples, the potential of the cooperation mech- anism available in the T OY system, a functional logic language that provides four constraint computation domains (i.e., Herbrand domain, real numbers, integers - the finite domain -, and sets of integers), and one domain (i.e., the mediatorial constraint domain), for communicating the computation domains.



R2

Fig. 4. Electrical Circuit Problem.
As a novelty, the paper has also illustrated the collaboration between the fi- nite and set domains. Moreover, it should be clear from our exposition that T OY constitutes an appropriate setting to experimenting with solver collab- oration.
As future work, we plan to optimize the set solver in T OY as well as for- malize the cooperation between the Herbrand, finite domain and set domains following the same approach described in [8] for the Herbrand, real and finite domains.

References
Arenas, P., A. Fern´andez, A. Gil, F. L´opez, M. Rodr´ıguez and F. S´aenz, T OY. A Multiparadigm Declarative Language. Version 2.3.0 (2007), R. Caballero and J. S´anchez (Eds.), Available at http://toy.sourceforge.net.
Arenas, P., A. Gil and F. L´opez, Combining Lazy Narrowing with Disequality Constraints, in:
PLILP’94, LNCS 844 (1994), pp. 385–399.
Caballero, R. and Y. Garc´ıa-Ruiz, Implementing Dynamic Cut in Toy, ENTCS 177 (2007),
pp. 153–168.
Damas, L. and R. Milner, Principal Type-Schemes for Functional Programs, in: POPL’82
(1982), pp. 207–212.
Est´evez, S., A. Fern´andez, T. Hortal´a, M. Rodr´ıguez, F. S´aenz and R. del Vado, A Proposal for the Cooperation of Solvers in Constraint Functional Logic Programming, ENTCS 188 (2007),
pp. 37–51.
Est´evez, S., A. Fern´andez and F. S´aenz, Cooperation of the Finite Domain and Set Solvers in TOY, in: P. Lucio, G. Moreno and R. Pen˜a, editors, IX Jornadas sobre Programacio´n y Lenguajes (Prole’09), San Sebast´ıan, Spain, 2009, pp. 217–226.
Est´evez, S., A. J. Fern´andez, M. T. Hortal´a, M. Rodr´ıguez and R. del Vado, A Fully Sound Goal Solving Calculus for the Cooperation of Solvers in the CFLP Scheme, ENTCS 177 (2007),
pp. 235–252.
Est´evez-Mart´ın, S., T. Hortal´a-Gonz´alez, Rodr´ıguez-Artalejo, R. del Vado-V´ırseda, F. S´aenz- P´erez, and A. J. Fern´andez, On the Cooperation of the Constraint Domains H, R and FD in CFLP , Theory and Practice of Logic Programming 9 (2009), pp. 415–527.

Fern´andez, A. J., T. Hortal´a, F. S´aenz and R. del Vado, Constraint Functional Logic Programming over Finite Domains, Theory and Practice of Logic Programming 7 (2007),
pp. 537–582.
Hofstedt, P., Better Communication for Tighter Cooperation, in: CL’2000, LNCS 1861 (2000),
pp. 342–357.
Hofstedt, P. and P. Pepper, Integration of Declarative and Constraint Programming, Theory and Practice of Logic Programming 7 (2007), pp. 93–121.
Hortal´a, T., F. L´opez, J. S´anchez and E. Ull´an, Declarative Programming with Real Constraints, Research Report SIP 5997, U.C.M. (1997).
Loogen, R., F. L´opez-Fraguas and M. Rodr´ıguez-Artalejo, A Demand Driven Computation Strategy for Lazy Narrowing, in: Proc. PLILP’93, LNCS 714 (1993), pp. 184–200.
L´opez, F., M. Rodr´ıguez and R. del Vado, A New Generic Scheme for Functional Logic Programming with Constraints, Higher-Order and Symbolic Computation 20 (2007), pp. 73– 122.
S´aenz-P´erez, F., ACIDE: An Integrated Development Environment Conﬁgurable for LaTeX, The PracTeX Journal 2007 (2007).
