Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 322 (2016) 135–151
www.elsevier.com/locate/entcs

Partial and Complete Processes in Multiparty Sessions 1
Mario Coppo	Mariangiola Dezani-Ciancaglini Ines Margaria		Maddalena Zacchi 2
Dipartimento di Informatica Universita` di Torino, corso Svizzera 185, 10149 Torino, Italy

Abstract
Multiparty sessions describe the interactions among multiple agents in a distributed environment and require essentially two steps: the specification of the communication protocols and the implementation of such protocols as processes. Multiparty session types address this methodology: global and session types provide the communication protocols, whereas the processes describe the behaviour of the peers involved in the sessions. Because of the close relationships between types and processes, some information, such as the names of senders and receivers, are replicated both in types and in processes.
In multiparty conversations it is quite natural that participants with essentially the same role are imple- mented by processes that follow the same pattern, differing only in the senders and receivers of commu- nication actions. In order to allow for a lighter and less rigid development of processes, we propose a translation tool which allows one to write processes in a simplified syntax, called partial syntax, where the names of senders/receivers for input/output operations are omitted. By adding the missing information, partial processes can be automatically translated in complete processes, for which an operational semantics is defined. The partial syntax, in particular, allows one to use the same process template to implement similar participants.
In this paper we present a translation and type checking algorithm from partial to complete processes, which, if successful, also assures that the target processes are well typed. The algorithm is synthesised from a rule-based description of the translation in natural semantics and it is proved sound and complete with respect to the translation rules.
Keywords: π-calculus, session types, multiparty sessions.


Introduction
Session types are one of the most successful formalisms introduced to describe com- municating processes and to study their behaviour. The basic idea, appeared first in [11] and [6], is to introduce a new form of polymorphism which permits the typing of channel names by structured sequences of types, abstractly representing the trace

1 This work was partially supported by ICT COST Action IC1201 BETTY, MIUR PRIN Project CINA Prot. 2010LHT4KM and Torino University/Compagnia San Paolo Project SALT.
2 Email: {coppo,dezani,ines,zacchi}@di.unito.it

http://dx.doi.org/10.1016/j.entcs.2016.03.010
1571-0661/© 2016 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

of the usage of the channels. In modelling distributed systems, where processes in- teract by means of message passing, it is appropriate to allow many interactions to occur within the scope of private channels following disciplined protocols. As usual, we call sessions such private interactions and session types the protocols describing them. In its simplest form, a session is established between two peers, such as a client connecting with a server. In general, a session may involve any (usually fixed) number of peers. In these cases, we speak of multiparty sessions and of multiparty session types [7] for their protocol descriptions. A multiparty session type theory consists of three parts: global types, processes, and local types, called also session types. Global types describe communication protocols in terms of the interactions between peers, of the order of these interactions, and of the kind of exchanged messages. The description given by a global type is neutral, independent from the peers and their viewpoints. Processes describe, by means of a formal language, the behaviour of the peers involved in the session. For each peer a session type describes the same communication protocol as the global type, but from the viewpoint of the peer. Local and global types are related by a projection operation that extracts local types from the global ones, and a type system makes sure that a process uses the communication channels it owns according to their local types. Among the more interesting features of interactions between peers, session delegation is a key operation, which permits to rely on other parties for completing specific tasks transparently, in a type safe manner. A typical scenario is given by the protocol of Remote Procedure Call for server/client distributed systems. In such a case the server, after receiving a request from a client, delegates remaining interactions with the client to an application process. The client and the application process are ini- tially unknown to each other, but later communicate directly, transparently to the client, through dynamic mobility of the communication channel. Such protocol is usually synchronous, because the processes involved in the communications remain tightly coupled.
Regarding the syntax of processes, the need to specify sender and receivers for
each input/output operation makes cumbersome the code writing; moreover, in distributed applications often many processes perform exactly the same pattern of input/output operations, differing only for the involved participants. For example in the Remote Procedure Call protocol, the application processes, that provide the services, in many interesting cases differ only in the process names involved in the communications. In this paper we present a translation algorithm that allows one to code processes in a simplified syntax, called partial syntax, which does not require to specify the names of senders/receivers for input/output operations. Partial code is simpler to write and can be shared by different participants in a conversation, but it is incomplete and cannot be directly executed. The executable code of the processes, written in complete syntax (i.e. including the names of the processes involved in the communications) can be obtained automatically from the partial code by exploiting the information given by the global types. The translation is successful only if the target process is well typed according to standard typing rules for multiparty sessions, so the translation algorithm also includes type checking.

The translation from partial processes to complete processes is formalised in natural semantics by a set of rules. These rules implicitly define a recursive translation and type checking function, whose code is given in a ML-like language. The sound- ness and completeness of both the natural semantics rules and the corresponding algorithm can be easily proved.
In the present paper process execution is defined by a synchronous operational semantics. However the translation does not depend on the way in which commu- nications are performed, and could be applied as well to an asynchronous calculus like that defined in [1].
Multiparty sessions arise motivated by the applications to financial protocols in the context of the development of the language Scribble [12]. The first the- oretical works on multiparty session types are [2] and [7]. The paper [2] uses a distributed calculus where each channel connects a master endpoint to one or more slave endpoints. Both processes and types in [7] share a vector of channels and each communication uses one of these channels. The process syntaxes in the present pa- per are similar to those in [1]; the main difference is that communications in [1] are asynchronous. The paper [4] takes advantage of partial syntax flexibility for dealing with self-adapting protocol participants. Bisimulation of a synchronous multiparty session calculus is studied in [9], where the calculus syntax differs from our complete syntax only for the lack of multiple receivers. We refer to [5,3,8] for comprehensive overviews of related works.

Outline
Section 2 introduces global types and partial syntax by means of examples. The whole calculus and the type system are given in Sections 3 and 4, respectively. Section 5 concludes with the natural semantics rules, mapping processes written in partial syntax to processes written in complete syntax. Lastly a translation and type checking algorithm is provided.

Motivating Examples
We present the syntax of the calculus with the aid of examples, in order to give a basic idea of functionalities and linguistic features.
The overall scenario, involving a manager (M), an Italian factory (IF), an Amer- ican factory (AF) and two transport companies (IC) and (AC), proceeds as follows.
The manager sends to the factories an identifier of items to supply.
The factories communicate to the manager the numbers of items they can provide.
If the total number is satisfactory, the manager notifies the factories and the transport companies to arrange the details and waits for the expedition date from both transport companies. Otherwise the manager notifies all participants to quit the protocol.

M	=	a [5](y).y!⟨"identifier"⟩.y?(x1).y?(x2). if good(x1, x2) then y ⊕ ok.y?(d1).y?(d2).0
else y ⊕ quit.0
F[j]	=	a[j](y).y?(id).y!⟨number⟩.y&{ok : y!⟨number⟩.0, quit : 0}
C[k]	=	a[k](y).y&{ok : y?(n).y!⟨date⟩.0, quit : 0}
Fig. 1. The manager-factories example.

Multiparty session programming consists of two steps: specifying the intended communication protocols via global types, and implementing these protocols as pro- cesses. The specifications of the manager-factories protocol are given by the global type Ga. The participants are actually coded by numbers: in Ga we have M = 5, IF = 1, AF = 2, IC = 3, AC = 4.
Ga  =
5 −→ {1, 2} :	⟨string⟩.
1 −→ {5} :	⟨nat⟩.
2 −→ {5} :	⟨nat⟩.
5 −→ {1, 2, 3, 4} : {ok : 1 −→ {3} : ⟨nat⟩.
2 −→ {4} : ⟨nat⟩.
3 −→ {5} : ⟨date⟩.
4 −→ {5} : ⟨date⟩.end
quit : end}

In Ga, line 1 denotes M multicasts the same string to IF and AF. Lines 2 and 3 say both IF and AF send a natural value to M. In lines 4-8 M sends either ok or quit to all other participants. In the first case both IF and AF send to IC and AC, respectively, the number of items to deliver (lines 4-5) and the transport companies communicate delivery date to M directly (lines 6-7); in the second case there are no further communications.
Figure 1 gives the code, associated with Ga, for participants in the partial syntax, formally defined in the following section. We only need three partial processes because the two factories IF and AF are realised by two instances of the same partial process F[j] and similarly the two transport companies are realised by two instances of the partial process C[k].
Session name a establishes the session corresponding to Ga. Process M initiates a session involving five participants as fifth one by a [5](y); the first and second participants are obtained by instantiating j by 1 and 2, respectively, in F[j], the third and forth participants are obtained as two instances, for k = 3 and k = 4, of C[k]. Each participant uses a bound variable as a placeholder for the channel that will be used in the communications. Sender and receivers of the exchanged data are specified by the global type.
The first line of Ga is implemented by the output and input actions y!⟨"identifier"⟩ in the code of M and y?(id) in the code of F[j]. Lines 2 and 3 are implemented by y?(x1).y?(x2) in the code of M and y!⟨number⟩ in the code of F[j] (j = 1, 2), respec- tively. The next lines of Ga are implemented by the selection and branching: actions y⊕ok.y?(d1).y?(d2).0 and y⊕quit.0 in the code of M, y&{ok : y!⟨number⟩.0, quit : 0}
in the code of F[j] and y&{ok : y?(n).y!⟨date⟩.0, quit : 0} in the code of C[k].

F[j]	=	a[j](y).y?(id).y!⟨number⟩.y&{ok : b[j](z).z!⟨number⟩.z!⟨⟨y⟩⟩.0, quit : 0}

C	=	b [3](z).z?(n).z?((t)).t!⟨date⟩.z?(n).z?((t)).t!⟨date⟩.0
Fig. 2. The manager-factories example with delegation.

We now enrich this protocol introducing delegation. In the initial session a the participants are only the manager and the two factories, which also send the de- livery date to the manager, according to the new global type Ga. Actually, after receiving ok, both factories accept a new session b offered by a unique transport company. In this session, described by the global type Gb, each factory sends to the transport company not only the number of items, but also the channel used to communicate with the manager. In this way each factory delegates the transport company to send the delivery date to the manager. This delegation is transparent to the manager. The new global types Ga and Gb are then:


Ga =
3 −→ {1, 2} : ⟨string⟩.
1 −→ {3} :	⟨nat⟩.
2 −→ {3} :	⟨nat⟩.
3 −→ {1, 2} : {ok : 1 −→ {3} : ⟨date⟩.
2 −→ {3} : ⟨date⟩.end
quit : end}
Gb =
1 −→ {3} : ⟨nat⟩.
1 −→ {3} : ⟨T ⟩.
2 −→ {3} : ⟨nat⟩.
2 −→ {3} : ⟨T ⟩.end

T = !⟨{3}, date⟩.end

where the session type T says that the exchanged channel must be used to send a date to participant 3 in session a, i.e. to the manager. The new code for the factories and the transport company is given in Figure 2. Notice that the code for the manager does not change, but for the replacement of a [5] with a [3]. This example then shows also how the partial syntax allows one to write processes which can fit different global types. In this example, unlike the previous one, if the man- ager decides to quit the protocol, session b is not open, so transport company is not involved in the conversation.

In the last example we add recursive-branching behaviour to the protocol with delegation. In particular we allow M repeatedly negotiates with the factories IF and AF the number of items to supply. The scenario is basically the same, the only part that changes is that, if the number of items the factories can provide is too small, the manager initiates a negotiation with the factories to increase that number. The manager starts asking the factories for a first number of items. At each step each factory answers with a new offer. The manager can accept the offer, ask for a new proposal or give up. When the manager decides to end the negotiation (accepting the last offers or giving up) he communicates his decision to the factories; in the first case, as before, the transport company is contacted.
The communication protocol is described by the following global types, where Ga differs from the one of the previous example for the recursive part, which repre- sents the (possibly) recursive negotiation between the manager and the factories.

M	=	a [3](y).y!("identifier"⟩. def X(t)= t?(x1).t?(x2). if good(x1, x2) then t ⊕ ok.t?(d1).t?(d2).0
else if negotiable(x1, x2) then t ⊕ more.X(t⟩
else t ⊕ quit.0
in X(y⟩

F[j]	=	a[j](y).y?(id). def X' (x, t' )= t' !(x⟩.t' &{ok : b[j](z).z!(x⟩.z!((t' ⟩⟩.0,
more : X'(newnumber(x), t'⟩,
quit : 0}
in X'(number, y⟩

Fig. 3. The manager-factories example with delegation and recursion.

Ga =
3 −→ {1, 2} : ⟨string⟩.
μt. 1 −→ {3} :	⟨nat⟩.
2 −→ {3} :	⟨nat⟩.
3 −→ {1, 2} : {ok : 1 −→ {3} : ⟨date⟩.
2 −→ {3} : ⟨date⟩.end
more : t}
6.	quit : end}


Gb =
1 −→ {3} : ⟨nat⟩.
1 −→ {3} : ⟨T ⟩.
2 −→ {3} : ⟨nat⟩.
2 −→ {3} : ⟨T ⟩.end

T = !⟨{3}, date⟩.end

The code of participants, shown in Figure 3, is similar to the previous one, but for the recursive definitions in the processes M and F[j].
Calculus for Multiparty Sessions
As explained in the Introduction, we consider two different syntaxes, the first one, called partial syntax, to write flexible code, that can be used to implement different participants involved in sessions, the other one to describe the final code. We call the latter complete syntax since it specifies sender and receivers for any input/output operation.
Partial syntax
The partial processes, ranged over by P, Q . . . , and expressions, ranged over by e, ej,... , are given by the grammar in Table 1. To simplify the formal treatment we assume each recursively defined process having one data parameter and one channel parameter. The generalisation to multiple data and channel parameters however is straightforward.
A partial process of the form u [p](y).P initiates a new session through a service name identified by u with the other participants, each of shape u[q](y).Pq, where 1 ≤ q ≤ p − 1. The (bound) variable y represents the channel that will be used for the communications. We call p, q,... (ranging over natural numbers) the participants of a session. Session communications, i.e. communications that take place inside an established session, are performed using the next three pairs of primitives: the sending and receiving of a value, the session delegation and reception, where the former delegates to the latter the capability to participate in a session by passing a channel associated with the session; and the selection and branching, where the former chooses one of the branches offered by the latter. Notice that the hiding of service names specifies their global types. The rest of the syntax is standard from [6].


	
Table 1
Partial syntax for processes and naming conventions.


P	::=	c!⟨Π, e⟩.P	Value sending
|	c?(p, x).P	Value reception
|	c!⟨⟨p, c′⟩⟩.P	Session delegation
|	c?((p, y)).P	Session reception
|	c ⊕ ⟨Π, l⟩.P	Selection

Table 2
Complete syntax: the other syntactic forms are as in Table 1.

M	=	a [5](y).y!⟨{1, 2}, "identifier"⟩.y?(1, x1).y?(2, x2).
if good(x1, x2) then y ⊕ ⟨{1, 2, 3, 4}, ok⟩.y?(3, d1).y?(4, d2).0
else y ⊕ ⟨{1, 2, 3, 4}, quit⟩.0

Fig. 4. The manager-factories example in complete syntax.
Complete Syntax
To define the operational semantics, partial processes must be put in an executable form (see Section 5) by adding the information about senders an receivers of mes- sages provided by the global types. The complete syntax is defined in Table 2. It differs from the syntax of Table 1 since the input/output operations (including delegation/reception and branching/selection) specify the sender and the receivers, respectively. We use Π to range over non-empty sets of participants. Thus, c!⟨Π, e⟩ means to send a value to all the participants in Π; accordingly, c?(p, x) denotes the reception of a value from participant p. The same holds for selection/branching and delegation/reception, but in this last case there is only one receiver.
As usual, we call s[p] a channel with role: it represents the input/output port of the participant p in the session s.
Figure 4 gives the processes implementing the manager-factories protocol of the first example in complete syntax. According to the global type Ga all input/output operations specify also the sender and the receivers, respectively.



a[1](y).P1 | ... | a[n − 1](y).Pn−1 | a [n](y).Pn −→ (νs)(P1 {s[1]/y} | ... | Pn−1 {s[n − 1]/y} | Pn {s[n]/y})	[Link]
s[p]!(Π ∪ {q}, e⟩.P | s[q]?(p, x).Q −→ s[p]!(Π, e⟩.P | Q{υ/x}  (e↓υ) if Π /= ∅ and q ∈/ Π	[Comm]
s[p]!({q}, e⟩.P | s[q]?(p, x).Q −→ P | Q{υ/x}  (e↓υ)	[Comm1]
s[p]!((q, s' [p' ]⟩⟩.P | s[q]?((p, y)).Q −→ P | Q{s' [p' ]/y}		[Deleg] s[p] ⊕ (Π ∪ {q}, li0 ⟩.P | s[q]&(p, {li : Pi}i∈I ) −→ s[p] ⊕ (Π, li0 P ⟩. | Pi0 (i0 ∈ I) if Π /= ∅ and q ∈/ Π	[Label] s[p] ⊕ ({q}, li0 ⟩.P | s[q]&(p, {li : Pi}i∈I ) −→ P | Pi0 (i0 ∈ I)	[Label1]
if e then P else Q −→ P	(e ↓ true)		if e then P else Q −→ Q  (e ↓ false)		[If-T], [If-F] def X(x, y)= P in (X(e, s[p]⟩ | Q) −→ def X(x, y)= P in (P {υ/x}{s[p]/y} | Q) (e ↓ υ)			[ProcCall] P −→ P'  ⇒ (νr) P −→ (νr) P '	P −→ P ' ⇒ P | Q −→ P ' | Q	[Scop], [Par]
P −→ P '  ⇒ def D in P −→ def D in P '	[Defin]
P ≡ P ' and P ' −→ Q' and Q ≡ Q'  ⇒  P −→ Q	[Str]
Table 3 Reduction rules.

P | 0 ≡ P	P | Q ≡ Q | P	(P | Q) | R ≡ P | (Q | R)	(νr)P | Q ≡ (νr)(P | Q) (νrr′)P ≡ (νr′r)P	(νr)0 ≡ 0	def D in 0 ≡ 0	def D in (νr)P ≡ (νr)def D in P (def D in P ) | Q ≡ def D in (P | Q)		def D in (def D′ in P ) ≡ def D′ in (def D in P )
Table 4 Structural equivalence.

Operational Semantics
As usual the operational semantics consists of reduction rules (Table 3) and struc- tural equivalence rules (Table 4) that allow to rearrange the terms in order to apply the reduction rules. In writing processes we use “Barendregt’s convention”, i.e. we assume that all bound names/variables are different from one another and from the free ones.
Rule [Link] describes the initiation of a new session among n participants that synchronise over the service name a. The last participant a [n](y).Pn, distinguished by the overbar on the service name, specifies the number n of participants. For this reason it is called the initiator of the session. Obviously each session must have a unique initiator. After the connection, the participants share the private session name s. The variables y in each participant p will then be replaced with the corresponding channel with role s[p]. The communication rules [Comm], [Comm1], [Deleg], [Label] and [Label1] formalise a communication between two processes in- side a session. We denote with e↓υ the evaluation of the expression e to the value υ. We need to remove the receiving participant from the set of the receivers in order to avoid exchanging the same message more than once. If there is only one receiver (rules [Comm1], [Deleg] and [Label1]) the whole sending action is removed. Rule [Link] is synchronous and atomic, involving all participants at once. Message sender and receiver must synchronise, but multicast communication is not atomic, since the receivers get the same message in different reduction steps. These choices are debatable, but they are quite common in the literature [5].
In the following we use −→∗ with the expected meaning.


(p → Π: (U⟩.G' ) † q =
!(Π,U⟩.(G' † q)  if q = p,
?(p,U ).(G' † q)	if q ∈ Π,
⎩G' † q	otherwise.
⎧⎪⎨⊕(Π, {li : Gi † q}i∈I ⟩ if q = p

(p → Π: {li : Gi}i∈I ) † q =
&(p, {li : Gi † q}i∈I )  if q ∈ Π
⎪⎩Gi0 † q	where i0 ∈ I if q /= p, q /∈ Π and Gi † q = Gj † q for all i, j ∈ I.


(μt.G) † q = μt.(G † q) if G † q /= t,
end	otherwise.

t † q = t	end † q = end.
Table 5

Projection of global types onto participants.
Type System
This section introduces the type system, which assures soundness of communica- tions.
Global Types
Global types, ranged over by G, Gj, .. describe the whole conversation scenarios of multiparty sessions. The grammar is:
Global	G	::=	p → Π: ⟨U⟩.G′	Exchange	U	::=	S | T

The global type p → Π : ⟨U⟩.Gj says that participant p multicasts a message of type U to the set of participants Π and then the interactions described in Gj take place. Exchange types U, Uj, ... consist of sorts S, Sj,... for values (either base types or global types), and session types T, T j,... for channels (discussed in § 4.2). The global type p → Π : {li : Gi}i∈I says participant p multicasts one of the labels li to the set of participants Π. If lj is sent, interactions described in the global type Gj take place. In both cases we assume p ∈/ Π. The global type μt.G is a recursive type, assuming type variables (t, tj,... ) are guarded in the standard way, i.e., type variables only appear under some prefix. We assume that G in the grammar of sorts is closed, i.e., without free type variables. Type end represents the termination of the session.
Session Types
Local types of processes, called session types are defined as follows:

Session	T	::=	!⟨Π,U⟩.T	send
|	?(p,U ).T	receive
|	⊕⟨Π, {li : Ti}i∈I ⟩	selection
|	&(p, {li : Ti}i∈I )	branching
|	μt.T	recursive
|	t	variable
|	end	end

While global types represent whole protocols, session types correspond to the view-points of single participants in sessions. The send type !⟨Π,U⟩.T expresses the sending to all participants in Π of a value or of a channel of type U , followed by the communications of T . The selection type ⊕⟨Π, {li : Ti}i∈I⟩ represents the transmission to all participants in Π of a label li chosen in the set {li | i ∈ I} followed by the communications described by Ti. The receive and branching are the


Γ,u : S ▶ u : S	[Name♩	Γ ▶ true, false : bool	[Bool♩

Table 6
Γ ▶ e1 : bool  Γ ▶ e2 : bool

Γ ▶ e1 and e2 : bool

[And♩

Some typing rules for expressions.


Γ ▶ u : G  Γ ▶ P d Δ,y : G † p p = pn(G) Γ ▶ u [p](y).P d Δ

[MCast♩
Γ ▶ u : G  Γ ▶ P d Δ,y : G † p  p < pn(G) Γ ▶ u[p](y).P d Δ
[MAcc♩

Γ ▶ e : S	Γ ▶ P d Δ,c : T


Γ ▶ c!(Π, e⟩.P d Δ,c : !(Π,S⟩.T
[Send♩
Γ,x : S ▶ P d Δ,c : T


Γ ▶ c?(q, x).P d Δ,c :?(q,S).T
[Rcv♩



Γ ▶ P d Δ,c : T


Γ ▶ c!((p, c' ⟩⟩.P d Δ,c : !({p},T'⟩.T, c' : T'
Γ ▶ P d Δ,c : T, y : T'
[Deleg♩		
Γ ▶ c?((q, y)).P d Δ,c :?(q,T' ).T

[Srec♩



Γ ▶ P d Δ,c : Tj	j ∈ I

Γ ▶ c ⊕ (Π, lj⟩.P d Δ,c : ⊕(Π, {li : Ti}i∈I ⟩
Γ ▶ Pi d Δ,c : Ti	∀i ∈ I
[Sel♩		
Γ ▶ c&(p, {li : Pi}i∈I ) d Δ,c : &(p, {li : Ti}i∈I )
Table 7
[Branch♩

Typing rules for processes I.


Γ ▶ P d Δ	Γ ▶ Q d Δ′


Γ ▶ P | Q d Δ, Δ′

[Par♩
Γ,a : t ▶ P d Δ Γ ▶ (νa)P d Δ

[NRes♩

Γ ▶ e : bool Γ ▶ P d Δ Γ ▶ Q d Δ Γ ▶ if e then P else Q d Δ
[If♩

Δ end only Γ ▶ 0 d Δ
[Inact♩
Γ ▶ e : S	Δ end only Γ,X : S F ▶ X⟨e, c⟩ d Δ,c : F

[Var♩

Γ,X : S F, x : S ▶ P d y : F	Γ,X : S F ▶ Q d Δ


Γ ▶ def X(x, y)= P in Q d Δ
[Def♩



Γ,s : t ▶ P d Δ, {s[p]: t T p | 1 ≤ p ≤ n} s ∈/ Dom(Δ) n = pn(t) Γ ▶ (νs)P d Δ
Table 8
Typing rules for processes II.

[SRes♩


dual types, respectively, and they need only one sender. Other types are standard. Following [10, §20.2] we take an equi-recursive view of recursive types, equating types with the same (possibly infinite) regular tree.
The relation between session and global types is formalised by the notion of projection as in [7]. The projection of G onto q (G T q) is defined by induction on G, see Table 5.
Typing Rules for Complete Processes
The typing judgements for expressions and processes are of the shape:
Γ ▶ e : S	and	Γ ▶ P d Δ
where Γ is the standard environment which associates variables with sorts, service

and session names with global types and process variables with pairs of sorts and session types; Δ is the session environment which associates channels with session types. Formally we define:
Γ ::= ∅ | Γ,u : S | Γ,s : G | Γ,X : S T	and	Δ ::= ∅ | Δ,c : T
assuming that we can write Γ,u : S only if u does not occur in Γ, briefly u /∈ dom(Γ) (dom(Γ) denotes the domain of Γ, i.e., the set of identifiers which occur in Γ). We use the same convention for X : S T and Δ (thus we can write Δ, Δj only if dom(Δ) ∩ dom(Δj)= ∅).
Table 6 gives some typing rules for expressions. Tables 7 and 8 present the typing rules for processes. Rule [MCast♩ permits to type a service initiator identified by u, if the type of y is the p-th projection of the global type G of u and the number of participants in G (denoted by pn(G)) is p. Rule [MAcc♩ permits to type the p-th participant in the service identified by u, which uses the channel y, if the type of y is the p-th projection of the global type G of u. The successive six rules associate the input/output processes with the input/output types in the expected way. Note that, according to our notational convention on environments, in rule [Deleg♩ the channel which is sent cannot appear in the session environment of the premise, i.e., cj /∈ dom(Δ) ∪ {c}. Rule [Par♩ permits to put in parallel two processes only if their session environments have disjoint domains. A session environment is “end only” when all channels are typed by end. Rule [SRes♩ restricts a session s only if the session environment contains the channels with role of all participants in the global type G, which is the type of s in the standard environment. Moreover these channels must be typed with the projections of G on the respective participants.
Subject Reduction
Since session environments represent the forthcoming communications, by reducing processes, session environments can change. This can be formalised as in [7] by introducing the notion of reduction of session environments, whose rules are:
{s[p]: !⟨Π ∪ {q},U⟩.F, s[q] :?(p,U ).F ′}  ⇒ {s[p]: !⟨Π,U⟩.F, s[q]: F ′}	Π /= ∅ and q /∈ Π
{s[p]: !⟨{q},U⟩.F, s[q] :?(p,U ).F ′} ⇒ {s[p]: F, s[q]: F ′}
{s[p]: ⊕⟨Π ∪ {q}, {Li : Fi}i∈I ⟩, s[q]: &(p, {Li : F ′}i∈I )} ⇒ {s[p]: ⊕⟨Π, {Li : Fi}i∈I ⟩, s[q]: F ′}   Π /= ∅
i	i
and q /∈ Π
{s[p]: ⊕⟨{q}, {Li : Fi}i∈I ⟩, s[q]: &(p, {Li : F ′}i∈I )} ⇒ {s[p]: Fi, s[q]: F ′}
i	i

Δ ∪ Δ′′ ⇒ Δ′ ∪ Δ′′ if Δ ⇒ Δ′
The first two rules correspond to the exchange of a value or channel from the participant p to the participant q, the third and fourth rules correspond to the choice of the label li by the participant p.
Subject reduction only holds if the types of the channels with role are the pro- jections of the global type of the corresponding session. More formally:
Definition 4.1 A session environment Δ is coherent for the standard environment Γ if s[p]: T ∈ Δ implies s : G ∈ Γ and G T p = T .

Θ,u : t, y : t T p ▶ P ⇒ P∗ pn(p)= t Θ,u : t ▶ u [p](y).P ⇒ u [p](y).P∗

(MCast)

Θ,u : t, y : t T p ▶ P ⇒ P∗  pn(p) < t 

Θ,u : t ▶ u[p](y).P ⇒ u[p](y).P∗
Θ,y : F ▶ P ⇒ P∗  Θ ▶ e : S

(MAcc)



Θ,y : !⟨Π,S⟩.F ▶ y!⟨e⟩.P ⇒ y!⟨Π, e⟩.P∗
Θ,x : S, y : F ▶ P ⇒ P∗


Θ,y :?(p,S).F ▶ y?(x).P ⇒ y?(p, x).P∗
Θ,y : F ▶ P ⇒ P∗
(Send)


(Rcv)


(DeLeg)

Θ,y : !⟨{p},F ′⟩.F, z : F ′ ▶ y!⟨⟨z⟩⟩.P ⇒ y!⟨⟨p, z⟩⟩.P ∗
Θ,y : F, z : F ′ ▶ P ⇒ P∗



Θ,y :?(p,F′).F ▶ y?((z)).P ⇒ y?((p, z)).P ∗
Θ,y : Fj ▶ P ⇒ P∗  j ∈ I
(Srec)



(SeL)

Θ,y : ⊕⟨Π, {Li : Fi}i∈I ⟩ ▶ y ⊕ ⟨Π, Lj ⟩.P ⇒ y ⊕ ⟨Π, Lj ⟩.P∗

Θ,y : Fi ▶ Pi ⇒ P∗
∀i ∈ I

(Branch)

Θ,y : &(p, {Li : Fi}i∈I ) ▶ y&{Li : Pi}i∈I p ⇒ y&(p, {Li : P∗}i∈I )
Table 9 Translation rules I
We can state type preservation under reduction as follows:
Theorem 4.2 (Type Preservation) If Γ ▶ P d Δ with Δ coherent for Γ and
P −→∗ Pj, then Γ ▶ Pj d Δj for some Δj coherent for Γ, such that Δ ⇒∗ Δj.
The condition of coherence is needed to show subject reduction when rule [Comm] or [Comm1] is applied. Type preservation is proved in [3], where com- munications are asynchronous. In the synchronous case the proof is similar and easier.
Natural Semantics Translation
The translation for completing processes is defined via a set of formal rules in natural semantics. The rules are defined following the syntax of the processes and so they provide a basis to define a recursive deterministic procedure implementing the translation.
A translation environment Θ is defined by:
Θ ::= ∅ | Θ,u : S | Θ,X : S T | Θ,y : T
i.e. it contains assumptions of both standard and session environments. As for session environments, a translation environment is “end only” if all channel variables are typed by end. Two translation environments Θ and Θj are compatible (notation Θ = Θj) when their domains restricted to channel variables are disjoint.

Θ ▶ P ⇒ P∗ Θ′ ▶ Q ⇒ Q∗ Θ = Θ′ Θ ∪ Θ′ ▶ P | Q ⇒ P∗ | Q∗

(Par)

Θ ▶ P ⇒ P∗  Θ ▶ Q ⇒ Q∗  Θ ▶ e : bool

Θ ▶ if e then P else Q ⇒ if e then P∗ else Q∗
(If )

Θ end only Θ ▶ 0 ⇒ 0

(Inact)
Θ,a : t ▶ P ⇒ P∗


Θ ▶ (νa : t)P ⇒ (νa : t)P∗

(NRes)

Θ ▶ e : S  Θ end only


Θ,y : F, X : SF ▶ X⟨e, y⟩ ⇒ X⟨e, y⟩
(V ar)
Θ ▶ Q ⇒ Q∗  X /∈ dom(Θ)


Θ ▶ def X(x, y)= P in Q ⇒ Q∗
(Def S)

ΓΘ,X : S F, x : S, y : F ▶ P ⇒ P∗  Θ,X : SF ▶ Q ⇒ Q∗


Θ ▶ def X(x, y)= P in Q ⇒ def X(x, y)= P∗ in Q∗
Table 10 Translation rules II

(Def )


Θ' ▶ nn(x): nat	Θ' end only	Θ', t' : end end only

Ð  Θ'', t' : T ▶ X'(nn(x), t'⟩ c X'(nn(x), t'⟩	Θ'', t' : end ▶ 0 c 0


Θ'', t' : &(3, {ok .. .}) ▶ t' &{.. .} c t' &(3, {ok .. .})

Θ ▶ num : nat	Θ end only


 
Θ'', t' : T ▶ t' !(x⟩ ... c t' !({3}, x⟩ ...	Θ,y : T, X' : nat T ▶ X'(num, y⟩ c X'(num, y⟩

Θ,y : T ▶ def X' (x, t' )= ... in X'(num, y⟩ c def X' (x, t' )= ... in X'(num, y⟩

a : Ga,b : Gb,y :?(3, string).T ▶ y?(id) ... c y?(3, id) ... 

a : Ga,b : Gb ▶ F[1] c a[1](y) ... 
where Θ = a : Ga,b : Gb, id : string, T = μt.!({3}, nat⟩.&(3, {ok :!({3}, nat⟩.end, more : t, quit :end})
Θ' = Θ,x : nat,	Θ'' = Θ',X' : nat T
num is short for number, nn is short for newnumber and Ð is the derivation

Θ'', t' :!({3}, nat⟩.end,z : end ▶ 0 c 0

Θ'', t' :!({3}, nat⟩.end,z : (3, !({3}, nat⟩.end⟩.end ▶ z!((t' ⟩⟩.0 c z!((3, t' ⟩⟩.0

Θ'', t' :!({3}, nat⟩.end,z :!({3}, nat⟩.(3, !({3}, nat⟩.end⟩.end ▶ z!(x⟩.z!((t' ⟩⟩.0 c z!({3}, x⟩.z!((3, t' ⟩⟩.0

Θ'', t' :!({3}, nat⟩.end ▶ b[1](z).z!(x⟩.z!((t' ⟩⟩.0 c b[1](z).z!({3}, x⟩.z!((3, t' ⟩⟩.0

Fig. 5. Translation of F[1] in Figure 3.

A translation environment can clearly be split into a standard environment and a session environment. We define
ΔΘ = {y : T | y : T ∈ Θ} and ΓΘ =Θ \ ΔΘ
The typing rules for expressions can be easily modified to allow translation envi- ronments instead of standard environments. The translation judgments have the shape:
Θ ▶ P  ⇒ P∗
meaning that from the environment Θ the process P in partial syntax is translated to the process P∗ in complete syntax. A translation judgment is well formed when the sets of process variables in Θ and in P∗ coincide. We assume that all translation

judgments are well formed. The translation rules are given in Tables 9 and 10. Rule (Def S) is needed since, if there are no calls to X, then the global type does not contain a type for the channel y. In this case the translated process is simplified, since the recursive definition is erased. In rule (Def ) the use of ΓΘ assures that P can contain only the channel y. As an example Figure 5 shows the application of this translation rules to the process F[1] of Figure 3.
The translation rules include type checking in the sense that, if a translation statement is provable, then the corresponding complete process is typable using the standard and the session environments obtained by splitting the translation environment. More precisely we have the following soundness result:
Theorem 5.1 (Soundness of the translation rules) If Θ ▶ P  ⇒ P∗, then
ΓΘ ▶ P∗ d ΔΘ.
Notice that all recursive definitions in P∗ are called at least once in their bodies.
Let |P | be the partial process obtained from the complete process P by erasing senders and receivers. If a complete process P without channels with role is typable, then the judgment which states the translation of |P | is provable. The process resulting from this translation coincides with the original P , but for erasing recursive definitions of process variables which are never called. More precisely:
Theorem 5.2 (Completeness of the translation rules) Let P be a complete
process without channels with role. If Γ ▶ P d Δ, then Γj ∪ Δ ▶ |P | ⇒ Pˆ, where Pˆ
is the process resulting from P by erasing unused deﬁnitions and Γj is the restriction of Γ to the process variables which occur in Pˆ.
Translation rule (Def S) requires to use Γj instead of Γ. Notice that the restriction to complete processes without channels with role is needed, since otherwise the mapping || becomes meaningless.
The proofs of these theorems can be done by induction on the translation rules and the typing rules, respectively. These proofs are standard, thanks to the simi- larity between translation and typing rules.
Following the translation rules it is rather easy to design an algorithm to realise them. We split each translation environment Θ in two disjoint parts, Υ and Ξ where:
Υ, the deﬁnition environment, contains only assumptions of the shape X : S T ;
Ξ, the basic environment, contains any kind of assumptions.
The algorithm, written as the recursive function trans in a ML-like language, is given in Table 11. This function takes as input a basic environment Ξ and a partial process P and returns a pair formed by a definition environment Υ, which collects the types of the process variables free in P , and a complete process P∗.
We introduce now the notation used in Table 11. The function typeof(e, Ξ) gives the type of the expression e in the standard environment ΓΞ, if any. We define
ΞP = Ξ \ {y : T | y : T ∈ Ξ and y does not occur in P}

function trans(Ξ ; R) case R of
u [p](y).P :	if Ξ(u)= G and p = pn(G) then let T = G † p and (Υ, P ∗ )= trans(Ξ,y : T ; P )
in return (Υ, u [p](y).P ∗ )
else FAIL
u[p](y).P :	if Ξ(u)= G and p < pn(G) then let T = G † p and (Υ, P ∗ )= trans(Ξ,y : T ; P )
in return (Υ, u[p](y).P ∗ )
else FAIL
y!(e⟩.P :	if Ξ= Ξ',y : !(Π,S⟩.T and typeof(e, Ξ) = S then let (Υ, P∗ )= trans(Ξ',y : T ; P )
in return (Υ, y!(Π, e⟩.P ∗ )
else FAIL
y?(x).P :	if Ξ= Ξ',y :?(p,S).T then let (Υ, P∗ )= trans(Ξ',x : S, y : T ; P )
in return (Υ, y?(p, x).P ∗ )
else FAIL
y!((z⟩⟩.P :	if Ξ= Ξ',y :!(p,T '⟩.T, z : T' then let (Υ, P∗ )= trans(Ξ',y : T ; P )
in return (Υ, y!((p, z⟩⟩.P ∗ )
else FAIL
y?((z)).P :	if Ξ= Ξ',y :?(p,T' ).T then let (Υ, P∗ )= trans(Ξ',y : T, z : T' ; P )
in return (Υ, y?((p, z)).P∗ )
else FAIL
y ⊕ lj.P :	if Ξ= Ξ',y : ⊕(Π, {li : Ti}i∈I ⟩ and j ∈ I then let (Υ, P∗ )= trans(Ξ',y : Tj ; P )
in return (Υ,y ⊕ (Π, lj⟩.P ∗ )
else FAIL
y&{li : Pi}i∈I :	if Ξ= Ξ',y : &(p, {li : Ti}i∈I ) then for all i ∈ I let (Υi, P ∗ )= trans(Ξ',y : Ti ; Pi )
in return ( i∈I Υi, y&(p, {li : P ∗}i∈I ))
else FAIL
-if e then P else Q:	if typeof(e, Ξ) = bool then let (Υ, P∗ ) = trans(Ξ ; P ) and (Υ' , Q∗ ) = trans(Ξ ; Q)
in return (Υ  Υ' , if e then P ∗ else Q∗ )
else FAIL
P | Q:	let (Υ, P∗ ) = trans(ΞP ; P ) and (Υ' , Q∗ ) = trans(ΞQ ; Q)
in return (Υ  Υ', P ∗ | Q∗ )
- 0 :	return ($, 0)
(νa : G) P :	let (Υ, P∗ )= trans(Ξ,a : G ; P ) in return (Υ, (νa : G) P ∗ )
X(e, y⟩:	let S = typeof(e, Ξ) and Ξ(y)= T in if X ∈/ dom(Ξ) then return ({X : S T}, X(e, y⟩)
else if Ξ(X)= S T then return ($, X(e, y⟩)
else FAIL
def X(x, y)= P in Q :	let (Υ, Q∗ ) = trans(Ξ ; Q)
in if X ∈/ dom(Υ) then return (Υ, Q∗ )
else let Υ= Υ' ,X : S T and (Υ'',P ∗ ) = trans(ΓΞ ,y : T, x : S, X : S T ; P )
in return (Υ'  Υ'' , def X(x, y)= P ∗ in Q∗ )

Table 11
The translation function.


This is useful to split the typing of the channels in translating the parallel compo- sition of processes.
The union  between definition environments is defined only if the same process variables have the same sorts and session types (as trees). We assume unions be- tween definition environments to be always defined when we write them in Table 11, otherwise the trans function fails. We can always assume session types written in forms different from μt.T , by unfolding them when needed.

The more interesting cases in the definition of the function trans are the last two. To translate a recursion def X(x, y)= P in Q we first compute the type of X inside Q by calling trans(Ξ ; Q). When trans is applied to a call X⟨e, z⟩ inside Q it adds the assumption X : S T (where S is the sort of the expression e and T is the type of z) to the definition environment. If Q does not contain calls of X we simply erase the declaration. Otherwise we check that P can be typed from the environment Ξ,y : T, x : S, X : S T . When trans is applied to a call X⟨ej, y⟩ inside P , it only checks that the types of X, ej and y agree, i.e. that the sorts of X and ej are the same and that the session types of X and y have the same tree.
The following Theorems state the correctness and completeness of the trans function. They can be shown by induction on the definition of trans and on the translation rules, respectively.
Theorem 5.3 (Soundness of trans) If trans(Ξ ; P ) = (Υ,P∗), then Ξj, Υ ▶ P ⇒ P∗, where Ξj is the restriction of Ξ to the process variables which occur in P∗.
Theorem 5.4 (Completeness of trans) If Ξ, Υ ▶ P ⇒ P∗, then trans(Ξ ; P )= (Υ,P∗).
We say that a process is closed if the only names occurring free in it are service names. Let Θ0 be an environment containing only assumptions for service names and P a closed partial process. If the call trans(Θ0 ; P ) terminates without rising errors, then the result is of the shape (∅,P∗), where P∗ is the well-typed translation of P and the definition environment is empty.
Acknowledgment
We are grateful to the anonymous reviewers for their useful suggestions and remarks.

References
Lorenzo Bettini, Mario Coppo, Loris D’Antoni, Marco De Luca, Mariangiola Dezani-Ciancaglini, and Nobuko Yoshida. Global Progress in Dynamically Interleaved Multiparty Sessions. In Franck van Breugel and Marsha Chechik, editors, CONCUR’08, volume 5201 of LNCS, pages 418–433. Springer, 2008.
Eduardo Bonelli and Adriana Compagnoni. Multipoint Session Types for a Distributed Calculus. In Gilles Barthe and C´edric Fournet, editors, TGC’07, volume 4912 of LNCS, pages 240–256. Springer, 2008.
Mario Coppo, Mariangiola Dezani-Ciancaglini, Luca Padovani, and Nobuko Yoshida. A Gentle Introduction to Multiparty Asynchronous Session Types. In Marco Bernardo and Einar Broch Johnsen, editors, Formal Methods for Multicore Programming, volume 9104 of LNCS. Springer, 2015. To appear.
Mario Coppo, Mariangiola Dezani-Ciancaglini, and Betti Venneri. Self-Adaptive Monitors for Multiparty Sessions. In Alberto Alberto Lluch-Lafuente and Emilio Tuosto, editors, PDP’14, pages 688–696. IEEE, 2014.
Mariangiola Dezani-Ciancaglini and Ugo de’ Liguoro. Sessions and Session Types: an Overview. In Cosimo Laneve and Jianwen Su, editors, WS-FM’09, volume 6194 of LNCS, pages 1–28. Springer, 2010.
Kohei Honda, Vasco T. Vasconcelos, and Makoto Kubo. Language Primitives and Type Disciplines for Structured Communication-based Programming. In Chris Hankin, editor, ESOP’98, volume 1381 of LNCS, pages 22–138. Springer, 1998.


Kohei Honda, Nobuko Yoshida, and Marco Carbone. Multiparty Asynchronous Session Types. In George C. Necula and Philip Wadler, editors, POPL’08, pages 273–284. ACM Press, 2008.
Hans Hu¨ttel, Ivan Lanese, Vasco Thudichum Vasconcelos, Lu´ıs Caires, Marco Carbone, Pierre-Malo Deni´elou, Dimitris Mostrous, Luca Padovani, Ant´onio Ravara, Emilio Tuosto, Hugo Torres Vieira, and Gianluigi Zavattaro. Foundations of Behavioural Types. http://www.behavioural-types.eu/ publications/WG1-State-of-the-Art.pdf, 2014.
Dimitrios Kouzapas and Nobuko Yoshida. Globally Governed Session Semantics. Logical Methods in Computer Science, 10, 2014.
Benjamin C. Pierce. Types and Programming Languages. MIT Press, 2002.
Kaku Takeuchi, Kohei Honda, and Makoto Kubo. An Interaction-based Language and its Typing System. In C. Halatsis, D. Maritsas, G. Philokyprou, and S. Theodoridis, editors, PARLE’94, volume 817 of LNCS, pages 398–413. Springer, 1994.
Nobuko Yoshida, Raymond Hu, Rumyana Neykova, and Nicholas Ng. The Scribble Protocol Language. In Mart´ın Abadi and Alberto Lluch-Lafuente, editors, TGC’13, volume 8358 of LNCS, pages 22–41. Springer, 2013.
