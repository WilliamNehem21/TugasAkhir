Electronic Notes in Theoretical Computer Science 42 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume42.html 11 pages


On Elementary Computability-Theoretic Properties of Algorithmic Randomness

Asat Arslanov 1
School of Computer Science and Software Engineering Monash University
Victoria 3800 Australia



Abstract
In this paper we apply some elementary computability-theoretic notions to algo- rithmic complexity theory with the aim of understanding the role and extent of computability techniques for algorithmic complexity theory. We study some compu- tability-theoretic properties of two different notions of randomness for finite strings: randomness based on the blank-endmarker complexity measure and Chaitin’s ran- domness based on the self-delimiting complexity measure. We introduce the notion of complex infinite sequence of finite strings, which we call K-bounded sequences.


Introduction
In this paper we apply some elementary computability-theoretic notions to algorithmic randomness theory with the aim of understanding the role and extent of computability techniques for algorithmic randomness theory. Two standard textbooks in the area of algorithmic randomness are Calude [3] and Li-Vitanyi [11]. Our notation is standard, following that used by Chaitin [5] and Soare [15]. In particular, ω = {0, 1,.. .} is the set of all non-negative integer numbers and {We}e∈ω is a standard enumeration of all computably enumerable (c. e.) sets, and {ϕe}e∈ω is a G¨odel numbering of all partial computable functions. Let {0, 1}∗ be the set of binary strings (also called programs), and let {0, 1}n be the set of binary strings of length n. We will use the letters α, β, γ, δ to denote finite strings. We let |α| denote the length of α and λ denote the empty string.
A tt–condition is a pair < {x1, x2,..., xn},η >, where x1, x2,..., xn are natural numbers and η is an n-ary Boolean function, n ≥ 1. We assume an

1 Email: asat@cs.monash.edu.au
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


effective enumeration of all tt–conditions and we will denote the tt–condition with index k by ttk. Let B ⊆ ω. We say that B satisﬁes the tt–condition ttk and write B |=tt ttk, if η((B(x1),..., B(xn)) = 1. If there exists a com- putable function f such that x ∈ A ⇔ B |=tt ttf(x), for all x, then we say that A is tt-reducible to B and write A ≤tt B. A set A is tt-complete if A is c. e. and every c. e. set is tt-reducible to A. In general, for any Turing reducibility R, a set A is R–complete if A is c. e. and every c. e. set is R-reducible to A. We shall work with Turing machines operating on strings. The absolute program-size complexity induced by a Turing machine ϕ (sometimes called
blank-endmarker computer) is defined by Kϕ(α) = min{|β| : β ∈ {0, 1}∗, ϕ(β)= α}. A Chaitin computer is a Turing machine (operating on strings) which has a preﬁx-free domain (see Calude [3]). For a Chaitin computer C one associates the absolute self-delimiting program-size complexity, or Chaitin complexity, HC(α) = min{|β| : β ∈ {0, 1}∗, C(β) = α}. The Invariance Theorem states the existence of a Turing machine ψ (Chaitin computer U ) such that for every Turing machine ϕ (Chaitin computer C) there exists a constant const such that Kψ(α) ≤ Kϕ(α)+ const (HU (α) ≤ HC(α)+ const) for all strings α. For this paper we fix a universal Chaitin computer U and denote by H the induced program-size complexity. Also, we fix a universal blank-endmarker computer ψ and denote by K its induced program-size complexity. The notion of ran- domness for finite strings was defined in an attempt to capture the idea that a string is random if it cannot be algorithmically compressed. The original approach (by Chaitin and Kolmogorov) to define the algorithmic randomness for finite strings was by using the notion of blank-endmarker program-size complexity K.
Definition 1.1 [Chaitin [3], Kolmogorov [3]] A string α ∈ {0, 1}∗ is Kol- mogorov t-random if K(α) ≥ |α|− t; α is K-random if it is Kolmogorov 0-random.
Definition 1.2 [Chaitin [3]] A string α ∈ {0, 1}∗ is Chaitin t-random if

H(α) ≥	max
β∈{0,1}|α|
H(β) − t; α is C-random if it is Chaitin 0-random.

We will denote by RANDK and RANDC the sets of Kolmogorov and Chaitin random strings, respectively. For more details on algorithmic ran- domness we refer the reader to Calude [3].
Our aim is to study the computability-theoretic properties of RANDK and RANDC in an attempt to estimate the computational difference between these two sets. It is known that both RANDK and RANDC are effectively immune sets, and Turing equivalent to the halting problem. Below we note that the positions of RANDK and RANDC are at the same level in the scale of immunity notions since they are not hyperimmune sets. This concept of a hyperimmune set turned out to have very interesting characterizations which were later shown to have important applications in many areas of computabil- ity and complexity theory. The characterization of hyperimmunity due to

Medvedev and Uspensky (e. g. see [12]) states that for a hyperimmune set A there is no computable function f such that, for each n, an ≤ f (n), where an is the number coding the n-th string of A in an increasing order. Thus from the computability-theoretic point of view both RANDK and RANDC, being non-hyperimmune, are not “meagre”. Below we can see how these and some other recent results on RANDK and RANDC can be easily derived from the few classical facts in the literature. We would like to remark here that, nevertheless, we found some interesting differences between these two notions of randomness in terms of other computability-theoretic hierarchies (see [1]). In the following section on hyperimmunity and K-bounded sequences we will look at a special kind of hyperimmune sets and obtain results which justify the introduction of the concept of complex infinite sequences of finite strings. We call them K-bounded sequences.
Hypersimple sets and program-size complexity
In this preliminary section we can see how some scattered results on RANDK and RANDC can be easily derived from classical facts in the literature. Chaitin in his abstract on the information-theoretic aspects of Post’s con- struction of a simple set (see Chaitin [6], p. 288) defines, for any integer n ≥ 0, the following sets P (n) and Q(n) of finite binary strings:
α ∈ P (n) if and only if there is a program β with |α| > n + |β| and α is the first string computed by β, i.e. ψ(β)= α.
α ∈ Q(n) if and only if n + K(α) < |α|.

Theorem 2.1 (Chaitin [6]) There is a constant c such that for all n, P (n+
c) is contained in Q(n), and Q(n) is contained in P (n).
The set P (n) is a version of Post’s original construction of a simple set and, in particular, P (n) is an effectively simple, non-hypersimple set. Consequently, all Q(n), n ≥ 0, are effectively simple and non-hypersimple sets. Notice that Q(0) = {α : α ∈ {0, 1}∗, K(α) < |α|} = RANDK . Therefore we have the following results.
Corollary 2.2 The set of K-random strings is an effectively immune, non- hyperimmune co-c. e. set.
Naturally, it is easy to see that the set RANDC is non-hyperimmune. Indeed, let {Fn}n∈ω be the following strong array: Fn = {α : |α| = n}, for every n. Obviously, the sequence {Fn}n∈ω is a computable sequence of pairwise disjoint finite sets. For every n, Fn ∩ RANDC /= ∅, and the set RANDC is non-hyperimmune.
Theorem 2.3 The set of non-K-random strings is wtt-complete.

Proof. It follows from the theorem (see [8]) that every effectively simple, non-hypersimple set is wtt-complete.	✷

Theorem 2.4 (Kummer [9]) The set of non-K-random strings can be tt- complete or non-tt-complete, depending on the acceptable numbering of the partial computable functions.

Proof. Lachlan has shown (see [10]) that Post’s construction of a simple set can produce both tt-complete and non-tt-complete effectively simple sets depending on which acceptable numbering of partial computable functions we are working with. Therefore we can now transfer this property to the set of non-K-random strings.	✷

It is known that all results proven for Kolmogorov’s definition of random strings hold for Chaitin’s model of random strings. The underlying complex- ities H and K are “asymptotical equivalent”. Moreover, it is known that Chaitin’s definition of randomness is more demanding than Kolmogorov’s one (see Calude [3]). The following modified Post’s construction of a simple tt- complete set(see [13]) “effectively approximates” a proper subset of the set of K-random strings which is effectively immune, non-hyperimmune and co-c. e. Question: it would be interesting to determine whether or not a variant of Post’s construction could be used to effectively enumerate the set of non-C- random strings.
Let S be a coinfinite, non-hypersimple c. e. set. Then there exists a disjoint strong array {Fn}n∈ω such that Fn ∩ S /= ∅ for all n. We will construct the desired c. e. superset S∗ of S by meeting the following list of requirements:

Re : n ∈ We	⇐⇒	S∗ |=tt ttf(e,n),

that is, n ∈ We if and only if the tt-condition with the index f (e, n) satisfies
S∗ and f (e, n) is a computable function to be constructed.
Obviously, if we construct S∗ ⊇ S meeting all these requirements, then
We ≤tt S∗ for any e and the theorem will be proved.
We first effectively split the strong array {Fn}n∈ω into the computable sequence of strong arrays {F (e, n)}(e,n)∈ω×ω defining for all e, n: F (e, n) = F⟨e,n⟩, so that we will connect the requirement Re to the array {F (e, n)}n∈ω. (Here ⟨e, n⟩ = 1/2(e2 +2en+n2 +3e+n) denotes the standard pairing function from ω × ω onto ω, e. g. see Soare [15], page 3.) We define (for fixed e and n) the value of the function f (e, n) as follows. Let F (e, n)= {a1, a2,..., ak}. Then f (e, n) gives the index of the tt–condition < {a1, a2,..., ak},η >, where η is the following Boolean function of k arguments:

η(x1, x2,..., xk) = 1 if and only if x1 =1& x2 =1& ... & xk = 1.


Now let S∗ be the following c. e. superset of S:

S∗ = S ∪ 
n∈We
F (e, n).



If n /∈ We, then by the construction, F (e, n) ∩ S∗ /= ∅. It follows that η(S∗(a1), S∗(a2),..., S∗(ak)) = 0 and, therefore, the tt–condition ttf(e,n) is not satisfied by S∗. If n ∈ We then F (e, n) ⊆ S∗, and
η(S∗(a1), S∗(a2),..., S∗(ak)) = 1.
Therefore, we have n ∈ We if and only if the tt-condition ttf(e,n) satisfies S∗.
Above we considered sets P (n) and Q(n) defined by Chaitin as sets which reflect information-theoretic aspects of Post’s simple set. Generalizing his ideas to Dekker’s construction of hypersimple sets (see [7]) and to known constructions of effectively hypersimple sets, we arrive at the below definition, which we believe reflects the information-theoretic aspects of these sets. Let Φ denote a Turing machine which is total and injective, i. e. it has the following properties.
Every program computes some string, i. e. Φ(u) converges for all programs
u;
Different programs compute on Φ different strings: if u /= v then Φ(u) /= Φ(v).

Definition 2.5 Let
HΦ = {α : Φ(α)= α1 =⇒ (∃β)(|β| > |α| and Φ(β)= β1 and |α1| > |β1|)}.
Then, HΦ is the set of all programs α such that if α computes a string α1 then there exists a program β such that |β| > |α| and β computes a program β1 with |α1| > |β1|.
Obviously, this definition can be considered as a version of Dekker’s origi- nal hypersimple set (see [7]). The following theorem about HΦ holds true.

Theorem 2.6 For any Turing machine Φ, let A be the c. e. set of all strings which are computed by Φ, i.e. A = range(Φ). If the set A is non-computable then HΦ is hypersimple.
Proof. The proof has been motivated by the original proof of Dekker’s theo- rem. Obviously, the set HΦ is c. e. and, since Φ computes different strings for different programs, the set HΦ is infinite. Let HΦ = {β0 < β1 < . . .}. Then, by the definition of HΦ, we have for any β that
β ∈ A ⇐⇒ β ∈ {α0, α1,..., αbβ }.



Now, if HΦ is majorized by a computable function g, then it follows that
β ∈ A ⇐⇒ β ∈ {α0, α1,..., αg(β)},

which means that A is computable. This is a contradiction.	✷
Corollary 2.7 For any Turing c. e. degree a > 0 there exists a Turing machine Φ such that HΦ is a hypersimple set of degree a.
Proof. It is easy to see that in Theorem 2.6 the set HΦ has the same Turing degree as the set A.	✷

Hyperimmunity and K-bounded sequences
In this section we study a special kind of hyperimmune set. Basing on this notion we introduce a new notion of complexity for infinite sequences of finite strings.
Definition 3.1 A sequence {Fn}n∈ω of finite sets is a disjoint strong (and singular) array if there is a computable function f such that:
Fn = Df(n) for all n;
n /= m ⇒ Df(n) /= Df(m) for all n, m;
(and |Df(n)| = 1 for all n).
In the early forties, Post introduced a hyperimmune set with computably enumerable complement in order to solve Post’s Problem (see Soare [15] or Post [13]) for tt-reducibility. The intuition which led to the definition of a hyperimmune set was to strengthen the notion of simple set, which solved Post’s Problem for m-reducibility, but did not solve Post’s Problem for tt- reducibility. The idea was to consider in the definition of an immune set A infinite c. e. sets as disjoint strong singular arrays (i. e. arrays whose members are all singular sets), and to weaken this condition by replacing singular sets with finite sets, so that each Fn contains some x ∈ A but we cannot explicitly compute which x ∈ Fn has this property.
Definition 3.2 A set A is hyperimmune if it is infinite, and there is no disjoint strong array with members all intersecting it, i. e. Fn ∩ A /= ∅ for all n.
Definition 3.3 If f and g are total functions, f majorizes g if f (n) ≥ g(n) for all n, and f dominates a partial function ϕ if f (n) ≥ ϕ(n) for all but finitely many n such that ϕ(n) is defined. If A = {a0 < a1 < a2 .. .} is an infinite set, the principal function of A is pA, where pA(n)= an. A function f majorizes (dominates) an infinite set A if f majorizes (dominates) pA. A set A dominates a partial function ϕ if pA(n) dominates ϕ.

Later on, in the early fifties, Kolmogorov presented to the participants of the Moscow’s seminar “Recursive Arithmetic” the problem (see Uspensky [16]) of which sets are not majorizable by computable functions . Medvedev and Us- pensky had shown independently that those sets are exactly the hyperimmune ones in the original sense of Post. Nowadays this beautiful characterization of hyperimmune sets by means of nonexistence of any majorizing computable function is often adopted as a definition of those sets (e. g. see Rogers [14]).
Theorem 3.4 (see [12] or [17]) An inﬁnite set A is hyperimmune if and only if no computable function f majorizes A.
The notion of effectively hyperimmune set was defined as a natural effec- tivization of the definition of the hyperimmune set.
Definition 3.5 [see [2]] An infinite set A = {a0, a1,.. .} is effectively hy- perimmune if and only if there is a computable function f such that for any e,
ϕe total	=⇒ (∃n ≤ f (e))(an > ϕe(n)).
Knowing an index e of a total computable fuction ϕe, we effectively find the interval {0, 1,...,f(e)} such that the function ϕe does not dominate A via a witness n from this interval.
The notion of effectively hyperimmune set naturally suggests studying the following notion of complexity for infinite sequences of finite strings. Let U (e, x) be a universal Turing machine defined on ω × ω, i. e. U (e, x)= ϕe(x) for every e and ϕe is the Turing program with G¨odel number e. Let A =
{α0, α1, α2,.. .} be an infinite sequence of binary strings. Here and below we write α ⊆ β if α ∗ γ = β for some γ /= ∅.
Definition 3.6 We will say that the infinite sequence A of binary strings is
ϕe–bounded for a fixed ϕe if the following three conditions hold:
(∀i, j) (i < j =⇒ K(αi) < K(αj)),
(∀i) (αi ⊆ αi+1),
(∃n) (∀m > n) (ϕe(m) < ∞ and ϕe(m) < K(αm)).
We can easily see that for any total computable function ϕe there exist ϕe–bounded sequences. Indeed, let us fix an enumeration of all binary strings and define by induction the following sequence:
α0 = µβ{ϕe(0) < K(β)},
αn+1 = µβ{αn ⊆ β & ϕe(n + 1) < K(β)& K(αn) < K(β)}. It is obvious that the sequence {α0, α1,.. .} is ϕe–bounded.
Definition 3.7 We say that a sequence A is K-bounded if it is ϕ–bounded for every total computable function ϕ.

Again, it is easy to see, that there are K-bounded sequences. Indeed, let A = {a0, a1,.. .} be an infinite set which majorizes all partial computable functions. Now we define the sequence {α0, α1,.. .} as follows:
α0 = µβ{K(β) > a0},
αn+1 = µβ{αn ⊆ β & K(β) > an+1 & K(β) < K(αn)}.
It is obvious that the sequence {α0, α1,.. .} is K-bounded.
In the next theorem, which is our main theorem, we prove that in the definition of K-bounded sequence we can change the condition
(∃n > 0) (∀m > n) (ϕe(m) < ∞ and ϕe(m) < K(αm)) to the apparently much weaker condition
(∃f ≤T ∅)(∀e)(∃y)(ϕe total =⇒ y ≤ f (e)& K(αy) ≥ ϕe(y)).


Theorem 3.8 Let A be an inﬁnite sequence of binary strings
α0, α1,... such that the following properties hold:
(∀i, j) (i < j =⇒ K(αi) < K(αj)),
(∀i) (αi ⊆ αi+1),
there is a computable function f such that for any e, if ϕe is total then for some y ≤ f (e), K(αy) > U (e, y).
Then A is a K-bounded sequence.
Remark 3.9 It follows that if a set A satisfies the hypotheses of the theorem, then A is effectively K-bounded in the sense that for any ϕe we can effectively compute the place n(e) (which obviously depends on e) from where the se- quence is ϕe–bounded, i.e. (∀m > n(e)) (ϕe(m) < ∞ =⇒ ϕe(m) < K(αm)).
The previous example gives a K-bounded sequence with n(e) ≤ e: (∀m > e) (ϕe(m) < ∞ =⇒ ϕe(m) < K(αm)).
Indeed, if for infinitely many e,
(∃m > e)(ϕe(m) < ∞ =⇒ ϕe(m) ≥ K(αm)),
then A does not majorize the following partial computable function f : for all e, f (e) = ϕe(e) if ϕe(e) < ∞, and f (e) be undefined otherwise. This contradicts the choice of A. 2

2 It is proved in [2] that a set dominating all partial computable functions is effectively immune.

Proof of Theorem 3.8 The proof will immediately follow from Theorem
3.11 below, which is interesting on its own and was already proved in [2]. We present here a new and simpler proof based on Lemma 3.10.
Lemma 3.10 Let g be an increasing computable function. Then there exists a increasing computable function α such that for any x:
ϕα(x) is a non-decreasing computable function;
ϕα(x)(0) ≥ g(α(x + 1)) for all x ≥ x0, where x0 is some ﬁxed number. Further, there exists a computable procedure which given an index of g produces this number x0.
Proof. Let β be an increasing computable function such that β(0) = 1, and, for e > 0,
ϕβ(e)(n)= g(ϕeϕe(n)) Let b be an index > 0 of β. Then,
ϕβ(b)(n)= g(ϕbϕb(n)) = gββ(n)= g(β)2(n);

ϕββ(b)(n)= gϕβ(b)ϕβ(b)(n)= gg(β)2g(β)2(n) ≥ g(β)4(n);

And for any x > 0,
ϕβx(b)(n) ≥ g(β	(n)).

Let α(x)= βx(b), if x > 0, and α(0) = b.
Then we have, for x ≥ b + 1,
ϕα(x)(0) ≥ g(β2x)(0) ≥

≥ gβx+b+1(0) ≥ gβx+1βb(0) ≥ gβx+1(b)= g(α(x + 1)).
✷
✷
Theorem 3.11 Let A = {a0 < a1 < a2 .. .} be an effectively hyperimmune set and h be a computable function such that
(∀x)(ϕx is total =⇒ (∃y ≤ h(x))(ϕx(y) < ay)).
Let f be an arbitrary increasing computable function. Then for some x0, which can be computed from the index of f, and for any x > x0, we have ax > f(x).

Proof. Without loss of generality, we assume that the given set A is effectively hyperimmune via an increasing computable function h. Then let α and x0 be obtained from g = fh as in Lemma 3.10. For any n ≥ h(α(x0)) there exists x ≥ x0 such that
h(α(x)) ≤ n < h(α(x + 1)).
Since A is effectively hyperimmune, we have
(∃t ≤ h(α(x)))[at > ϕα(x)(t) ≥ ϕα(x)(0)].
So, if n, x are as before, with x ≥ x0, we have:
an ≥ ah(α(x)) > ϕα(x)(0) ≥ fh(α(x + 1)) > f(n).
✷
Thus, for any effectively hyperimmune set we can get a K-bounded se- quence as in the previous examples.

Acknowledgements
I would like to thank Cris Calude, Douglas Bridges, Douglas Cenzer, John Crossley and one anonymous referee for their interest in this research and numerous suggestions on improvements of the paper. I would like to thank Graham Farr and Chris Wallace for their interest and support of this work. This work was supported in part by Australian Research Council Large Grant A49703170.

References
Arslanov, A., On the difference between two notions of randomness for ﬁnite objects, in preparation.
Arslanov, M.M., Effectively hyperimmune sets and majorants, Mat. Zametki 38
(1985), 302–309.
Calude, C.S., “Information and Randomness. An Algorithmic Perspective,” Springer–Verlag, Berlin, 1994.
Calude, C.S., Algorithmic Information theory: Open Problems, Journal of Universal Computer Science 5 (1996), 439–441.
Chaitin, G.J., “Algorithmic Information Theory,” third printing 1990, Cambridge University Press, Cambridge, 1987.
Chaitin, G.J., “Information, Randomness and Incompleteness, Papers on Algorithmic Information Theory,” second edition, World Scientific, 1987.


Dekker, J.C.E., A theorem on hypersimple sets, Proc. Amer. Math. Soc. 5
(1954), 791–796.
Kanovich, M.I., On the decision complexity of a recursively enumerable set as a criterion for its completeness, Dokl. Acad. Nauk 194 (1970), 500–503.
Kummer, M., On the complexity of random strings, Lecture Notes in Computer Science, STACS’96 1046 (1996), 25–36.
Lachlan, A.H., wtt-complete sets are not necessarily tt-complete, Proc. Amer. Math. Soc. 48 (1975), 429–434.
Li, M., and P.M. Vita´nyi, “An Introduction to Kolmogorov Complexity and Its Applications,” Springer-Verlag, Berlin, 1993.
Medvedev, Y., On non-isomorphic recursively enumerable sets, Dokl. Acad. Nauk 102 (1955), 211–214.
Post, E.L., Recursively enumerable sets of positive integers and their decision problems, Bull. Amer. Math. Soc. 50 (1944), 284–316.
Rogers, H., Jr., “Theory of Recursive Functions and Effective Computability,” McGraw-Hill, New York, 1967.
Soare, R.I., “Recursively Enumerable Sets and Degrees,” Springer–Verlag, Berlin, 1987.
Uspensky, V.A., Kolmogorov and mathematical logic, J. Symbolic Logic 57
(1992), 385–412.
Uspensky, V.A., Some remarks on r. e. sets, Zeit. Math. Log. Grund. Math. 3
(1957), 157–170.
