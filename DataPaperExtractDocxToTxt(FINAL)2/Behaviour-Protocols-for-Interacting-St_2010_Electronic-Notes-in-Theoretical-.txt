

Electronic Notes in Theoretical Computer Science 263 (2010) 47–66
www.elsevier.com/locate/entcs

Behaviour Protocols for Interacting Stateful Components 1
Sebastian S. Bauer, Rolf Hennicker, Stephan Janisch
Institut fu¨r Informatik
Ludwig-Maximilians-Universita¨t Mu¨nchen
{bauerse, hennicker, janisch}@pst.ifi.lmu.de


Abstract
We propose a formal foundation for behaviour protocols of interacting, concurrent components with data states. Formally, behaviour protocols are given by labelled transition systems which specify the order of operation invocations as well as the allowed changes of data states of components in terms of pre- and postconditions. We study the compatibility of protocols and we consider their composition which yields a behaviour protocol for a component assembly. Behaviour protocols are equipped with a model-theoretic semantics which describes the class of all correct component or assembly implementations. Implementation models are again formalised in terms of labelled transition systems and the correctness notion is based on an alternating simulation relation between protocol and implementation which takes into account concrete control and data states. As a major result we show that our approach is compositional, i.e. that locally correct implementation models of compatible protocols compose to a globally correct implementation, thus ensuring independent implementability.
Keywords: Behaviour protocol, pre- and postcondition, stateful component, alternating simulation relation, compositionality


Introduction
Component-based software development has received much attention not only in practice but also in theory during the last decade. An important role is played by formal specifications of component behaviours which are usually based on a control-flow oriented perspective describing the sequences of actions a component can perform when interacting with its environment; cf., e.g., [16]. Some approaches also consider data that can be transmitted by value passing messages but less atten- tion has been directed towards the integration of data states that a component can possess and which are typically specified by invariants and pre- and postconditions. The integrated treatment of control flow and data flow is, however, an important

1 This research has been partially supported by the GLOWA-Danube project 01LW0602A2 sponsored by the German Federal Ministry of Education and Research.

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.05.004

issue in system development, since both aspects appear quite naturally in many business applications. We claim that the combination of the two aspects is far from being well understood. For instance, it is well-known that pre/postcondition style specifications do, in general, not work for systems of concurrent components, but we believe that it is still important to investigate how far one can go by combining both aspects in a concurrent environment. More specifically, this concerns the impact of integrated control flow and data flow on specifications, implementations, formal correctness and compatibility notions, composition, and, last not least, independent implementability.
The working hypothesis of our study is that only on the basis of a precise formal semantics we can capture the subtilities which arise when considering concurrently running components whose interactions have an effect on their data states. Since specifications are inherently loose, leaving freedom to design decisions in imple- mentations, we will follow here the loose semantics approach which, in the spirit of Hoare [10], considers the semantics of a specification as the class of all its cor- rect implementations, also called models of the specification. In such a framework one gets for free notions like consistency, semantic equivalence of specifications etc. Thus it is the general goal of this work to take up these ideas in the context of be- haviour protocols for components and their implementations and to provide a solid semantical basis on top of which correctness notions and compatibility concepts can be defined and evaluated. We propose a strict separation of specification and implementation because specifications are considered as contracts describing the mutual assumptions and guarantees from the implementor’s and from the user’s point of view, while implementations have simply to adhere to the implementation requirements induced by a protocol. In order to study implementation correct- ness, we propose an alternating simulation relation in the spirit of de Alfaro and Henzinger [6] which relates behaviour protocols and implementation models by tak- ing into account properties of data states as well. Our approach is elaborated in a component-oriented setting with distinguished input and output actions which model messages that are received and sent via the ports of components.
When composing systems out of components it is essential that the single com- ponents are behaviourally compatible, i.e. work correctly together. In the context of distinguished input and output actions, an important compatibility requirement concerns the question, whether any output issued by one component meets the part- ner component in a state, where it expects the corresponding input; cf., e.g., [6]. In the context of data states this should also subsume that a caller must satisfy the precondition of the operation provided by the callee and, conversely, that then the callee guarantees the corresponding postcondition. We have formalised these ideas in terms of a behavioural compatibility relation which extends the concept of strong compatibility in [3], and similar notions in [6,12], to take into account data states. As our main result we show that the proposed concepts for protocol compatibility and implementation correctness work smoothly together. This means, implementation models which are locally correct w.r.t. compatible behaviour protocols compose to a correct implementation model of the composed behaviour protocol of a component

assembly. As a consequence, our framework supports independent implementability of behaviour protocols and substitutability of correct implementations.
The paper is organised as follows. After providing some technical preliminaries, we introduce the main structural elements of our component model in Sect. 2. Then, we define behaviour protocols and consider their compatibility in Sect. 3. In Sect. 4, we provide our formal, model-theoretic semantics for behaviour protocols in terms of component (and assembly) implementations and we present our central compositionality result.
Preliminaries. For the specification and implementation of the control-flow as- pects of component behaviours we will use labelled transition systems. A labelled transition system (LTS) M = (Q, q0, L, Δ) consists of a set Q of states, an initial state q0 ∈ Q, a set L of labels, and a transition relation Δ ⊆ Q × L × Q.
To deal with the specification and implementation of the data aspects of com- ponent behaviours we use observer signatures which describe the externally visible data states of components. An observer signature ΣObs consists of a set of (visible) state variables, also called observers. A ΣObs-data state σ : ΣObs → V assigns to each state variable in ΣObs a value in some predefined data universe V. The class of all ΣObs-data states is denoted by D(ΣObs). For any observer signature ΣObs and set X of (logical) variables such that ΣObs ∩ X = ∅, we assume given a set S(ΣObs,X) of state predicates ϕ and a set T (ΣObs,X) of transition predicates π with associated sets varlog(ϕ) ⊆ X and varlog(π) ⊆ X of (logical) variables. State predicates refer to single states and transition predicates refer to pre- and poststates. We assume that state predicates ϕ ∈ S(ΣObs,X) are equipped with a satisfaction relation σ; ρ ▶ ϕ for states σ ∈ D(ΣObs) and valuations ρ : varlog(ϕ) → V. Similarly, for transition predicates π ∈ T (ΣObs,X) we assume a satisfaction relation σ, σ'; ρ ▶ π, for two states σ, σ' ∈ D(ΣObs) and valuations ρ : varlog(π) → V. We do not fix a particular syntax for observer signatures, observers, and predicates here, neither a particular definition of ▶. How these notations can be instantiated, e.g., in the context of the Object Constraint Language OCL, is shown in [4].

Example 1.1 In our running example we will model a Turnstile component lo- cated at the entrance of a subway. We assume that the data state of a turnstile can be observed via two visible state variables: fare for the actual costs of a trip, and passed for the number of persons who have already passed the turnstile. Thus the set {fare, passed} constitutes an observer signature for the turnstile, in the following denoted by obs(Turnstile). An obs(Turnstile)-data state is given by an assignment σ : obs(Turnstile) → V, e.g. σ(fare) = 5, σ(passed ) = 100. For the notation of state and transition predicates we use usual logical expressions where unprimed observer symbols refer to the prestate and primed observer symbols to the poststate of a transition. For instance, x ≥ fare is a state predicate with varlog(x ≥ fare) = {x} and passed' = passed + 1 is a transition predicate which contains no (logical) vari- able. The satisfaction relation for predicates is defined as expected. For instance, for σ as above and ρ(x) = 7, it holds σ; ρ ▶ x ≥ fare, and for the same σ, for σ' with σ'(passed ) = 101 and for an arbitrary ρ, we have σ, σ'; ρ ▶ passed' = passed + 1 .

Component Model

In this section we summarize the structural concepts of our component model which extends the one in [9] by introducing observer signatures for ports and components. We do, however, not consider hierarchical components here and we make the sim- plifying assumption that names of ports and components are globally unique.
An interface is a pair (ΣObs, Op) consisting of an observer signature ΣObs and a set Op of operations. We assume that an operation op is of the form opname(Xin) where Xin is a (possibly empty) set of input variables. We write varin(op) to refer to the input variables of an operation op.
Ports are the access points of components where required operations can be called and invocations of provided operations can be received. A port signature (Iprov, Ireq) consists of a provided interface Iprov and a required interface Ireq. When we talk about a port P , we always assume given a port declaration P : Σ where Σ is a port signature and P is a globally unique port name. We write prv (P ) for the provided interface of Σ, obsprv (P ) for the observer signature and opnsprv (P ) for the operations of prv (P ). The operations in opnsprv (P ) are offered at port P and the observer signature obsprv (P ) defines the possible observations that can be made at this port (about the data state of its owning component). Symmetrically, we write req (P ) for the required interface of Σ, obsreq (P ) refers to the observer signature and opnsreq (P ) to the operations of req (P ). In this case, the operations in opnsreq (P ) are required from components which are connected to P and the observer signature obsreq (P ) defines which observations are required about the data states of connected components. Thus the idea of the required observer signature obsreq (P ) is to express which information of another (connected) component is expected to be visible. Therefore, the state variables occurring in the required interface of a port do not belong to the component which owns the port but are expected from the provided interface of (the port of) a component to be connected.
Components encapsulate data states and interact with their environment via ports. The data states of a component can only be observed via observers which are determined by the component’s observer signature. The access points of a component are given by ports. Formally, a component signature (ΣObs, (P : ΣP )P ∈I ) consists of an observer signature ΣObs and a finite family of port declarations P : ΣP . In the following when we talk about a component C, we always assume given a component declaration C : Σ where Σ is a component signature and C is a globally unique component name. We write obs(C) to refer to the observer signature and ports(C) to refer to the ports declared in Σ. We require that for all ports P ∈ ports(C), obsprv (P ) = obs(C), i.e. on each port all observers of its owning component are visible. For a port P , cmp(P ) denotes its owning component.
For building assemblies we connect ports of components. If P1 and P2 are ports whose interfaces match, i.e. req (P1) = prv (P2) and req (P2) = prv (P1), then K :
{P1, P2} is a (binary) connector declaration where K is a globally unique connector
name. In the following when we talk about a connector K, we always assume given a connector declaration of the form K : {P1, P2} and we write ports(K) to refer to

K1	K2



its set of ports {P1, P2}.
Figure 1. Assembly of the turnstile system.

An assembly A = ⟨(C : ΣC)C∈I ; (K : {PK,PK})K∈I' ⟩ consists of a finite
1	2
family of component declarations C : ΣC and a finite family of connector dec-
larations K : {PK,PK}. We write cmps(A) to refer to the components of the
1	2
assembly, conns(A) to refer to its connectors and we define the set ports(A) =
 C∈cmps(A) ports(C). The open ports of A, i.e., the ports which are not connected, are given by open(A) = ports(A) \ K∈conns(A) ports(K). For an assembly A, we require that (i) the connectors in conns(A) refer to ports of components inside A,
and (ii) there is at most one connector for each port.
Let A = (Aλ)λ∈Λ be a family of assemblies over a finite set of indices Λ =
{1,..., n}. We define conns(A) as the set of all possible connectors between open ports of different assemblies Aλ, Aκ ∈ A with λ /= κ . A subset K ⊆ conns(A) is called valid, if K contains at most one connector for each port. We write ports(K) to refer to the set K∈K ports(K). Finally, composition of a family of assemblies A = (Aλ)λ∈Λ via a valid connector set K ⊆ conns(A) is denoted by +KA and defined by cmps(A) = λ∈Λ cmps(Aλ) and conns(A) = λ∈Λ conns(Aλ). Note that +KA satisfies requirements (i) and (ii) again.
Example 2.1 The static structure of a simple simulation system for a turnstile is given by the assembly depicted in Fig. 1. The assembly consists of three components, Client, Turnstile and Operator, and of two connectors K1:{U, S} and K2:{O, T}. The observer signature of the Turnstile component is given by obs(Turnstile) = 
{fare, passed} as explained in Ex. 1.1. The turnstile has two ports S and O. At port
S no observer and no operation is required, i.e. obsreq (S) = ∅ and opnsreq (S) = 
∅. The port S provides both turnstile observers and two operations: coin(x) for dropping a coin with amount x into the turnstile’s slot, and pass() for passing through the turnstile. Formally, the provided interface of port S consists of the observer signature obsprv (S) = obs(Turnstile) and of the set of provided operations opnsprv (S) = {coin(x), pass()} with varin(coin(x)) = {x} and varin(pass()) = ∅.
At port O the turnstile requires no observer but an operation alarm() to inform the operator that a client has tried to pass the turnstile without paying, i.e. formally obsreq (O) = ∅ and opnsreq (O) = {alarm()}. The port O provides both turnstile observers and an operation ready () to switch off the alarm mode, i.e. formally obsprv (O) = obs(Turnstile) and opnsprv (O) = {ready()}.
For the other components, Client and Operator, no data states are considered,
i.e. obs(Client) = obs(Operator) = ∅, and for their ports the following holds: The required (provided) interface of U coincides with the provided (required) interface of S, the required (provided) interface of T coincides with the provided (required) interface of O, and for the open port P we have obsreq (P ) = ∅, opnsreq (P ) = {ok()}, obsprv (P ) = ∅, opnsprv (P ) = ∅.



Figure 2. Labels for behaviour protocols.

Restrictions of the component model. In our component model all connectors are binary which would not allow, e.g., broadcasting of messages. In principle, we see no problem to extend our approach to n-ary connectors but, as a matter of fact, the composition of protocols and implementation models discussed later on would then be more involved and the contract principle behind the compatibility notion for protocols must be reworked. For instance, it would be a design decision whether for an n-ary connector with n > 2 it would be sufficient to find two partners which can interact according to a protocol or whether full compliance of all n partners would be required.
Concerning data state observers we have required that each port provides all observers of its owning component. Of course, in many examples the observers of a port may only be a subset of the component’s observers. The visible state variables (observers) can be considered as simple queries without arguments. In a more general setting one would like to use also n-ary queries as observers. Moreover, we can only connect ports whose interfaces fully agree on required and provided observers and operations. In general, one would wish that the required observers and operations of one port can be strictly included in those of a connected port in the usual contravariant way. These issues concern no serious restrictions and could be resolved at the cost of more involved notations.
A more fundamental restriction is that, unlike [1,9], we do not consider hierarchi- cal components here. The reason is that encapsulating an assembly in a hierarchical component would naturally lead to hidden state variables of components and silent transitions which would need a significant extension of the presented framework.

Behaviour Protocols and their Compatibility
Behaviour protocols provide a means to specify the observable behaviour of com- ponents and assemblies which integrate the specification of control and data flow behaviour. The transitions in a behaviour protocol are marked with protocol labels which are divided into labels LP (P ) for ports P and labels LP (K) for connectors K; see Fig. 2. Labels for ports model either receiving (?) or sending (!) of a message. Messages which can be received must correspond to operations of the provided in- terface of a port while messages which can be sent must correspond to operations

of the required interface of a port. Protocol labels are equipped with pre- and postconditions represented by state and transition predicates of the respective ob- server signatures. More precisely, for a port P , a label [ϕ]?P.m[π] models that an operation provided at port P is invoked under the precondition ϕ and with post- condition π. In this case ϕ must be a state predicate and π a transition predicate over the observer signature of the provided interface of port P , since the operation execution concerns the data state of the owning component of P . Conversely, a label [ϕ]!P.n[π] expresses that a message n is sent on port P with precondition ϕ and postcondition π. Here ϕ is a state predicate and π a transition predicate over the observer signature of the required interface of port P , because the operation execution concerns the data state of a connected component which implements the required operation n. A behaviour protocol for a component whose transitions are labelled with receive labels and/or send labels can be considered as a contract with obligations for both, for the implementor of the component and for a partner com- ponent which is going to be connected. The contract principle is detailed in Table 1 where, for a behaviour protocol of a component C, we describe the assumptions that can be made and the guarantees that must be ensured by an implementor and by a communication partner of C. In Table 1 we assume that the component C has a port P with a provided operation m and with a required operation n.

Table 1
Contract principle of behaviour protocols

Table 1 shows that for an implementor of C a transition with receive label [ϕm]?P.m[πm] expresses that the port P must be ready to receive an operation invocation of m under the assumption that the precondition ϕm holds, and then the implementor will guarantee that after the execution of m the postcondition πm holds. Conversely, for the correct use of m a partner component must guarantee the precondition ϕm if it invokes m, while after the operation execution the partner can assume that the postcondition πm holds.
A send label [ϕn]!P.n[πn] imposes the obligation on the implementor of C to guarantee that the precondition ϕn is satisfied when the operation n is called while the implementor of C can assume that πn holds when the operation has been exe- cuted by the partner. Note, that for the correct use of n in a concrete implemen- tation of C it may be necessary to query first the partner component in order to check whether the precondition ϕn holds in the actual state of the partner; for more details see Sect. 4. Conversely, the partner component (which offers n) can assume that upon operation call of n the precondition ϕn is satisfied and the partner must guarantee that then, after the execution of n, the postcondition πn holds.
For a connector K which connects two ports Pi and Pj, a label [ϕ]Pi dK Pj.m[π] stands for the synchronised sending, reception and execution of an operation m via the connected ports Pi and Pj. In this case the pre- and postconditions are

predicates over the observer signature obsreq (Pi), which is the same as obsprv (Pj) since the ports are connected. For an assembly A the protocol labels in LP (A) are those labels which correspond to connectors or to open ports of A. Here and in the following all definitions and results are provided for assemblies but they carry over to components since a component C can be identified with a degenerated assembly
⟨{C}; ∅⟩ which contains only the component C and no connectors.
Definition 3.1 [Behaviour Protocol]
Let A be an assembly. A behaviour protocol for A, also called A-protocol, is an LTS F = (S, s0, LP (A), Δ) where S is a finite set of protocol states, s0 ∈ S is the initial protocol state, LP (A) is the set of protocol labels, and Δ ⊆ S × LP (A) × S is a finite protocol transition relation. The class of all A-protocols is denoted by Prot (A).
From the methodological point of view behaviour protocols for a proper assembly A correspond to architecture protocols in [15] while behaviour protocols for com- ponents C correspond to frame protocols in [15] and to interface automata in [6] which are supplemented here by pre- and postconditions. In contrast to [6], we do not consider internal transitions of a component here.
Example 3.2 Fig. 3 presents the protocol FT of the component Turnstile. If in the initial state LOCKED a coin is deposited whose value is at least the required fare, the turnstile becomes UNLOCKED . Then, a person can pass through the turnstile with the effect that the number of passed persons is increased by one and the state LOCKED is reached again. If a person tries to pass the turnstile without dropping a coin into its slot an alarm is sent on port O. On the same port the alarm can be shut off by invoking ready(). Fig. 4, shows the frame protocol FC of component Client which says that the client may continously call, first coin(x) with x being equal to the required fare of the turnstile, then pass(), and then ok() on its open port P. The frame protocol FO of component Operator is shown in Fig. 5. An operator can receive an alarm() message after which it can invoke ready().
If a protocol label shows no explicit pre- or postcondition we implicitly assume the trivial predicate true. For instance, in Fig. 3 the transition with label ?S.pass() between the states LOCKED and ON ALERT has the implicit pre- and postcondi- tion true while for the same operation called in state UNLOCKED the postcondition is passed' = passed + 1. Hence, the effect of an invocation of a particular operation may depend on the source control state where the operation is called.
Behaviour protocols can be combined to protocols of assemblies which specify the behaviour of a system of interacting components. For this purpose, we introduce a composition operator ☒K which composes assembly protocols in accordance with a set K of valid connectors for a family A of assemblies. The composition synchronises transitions whose labels match on corresponding inputs and outputs on a connector in K. For instance, if K : {Pλ, Pκ}∈ K, a transition with label [ϕλ]!Pλ.op[πλ] of one protocol is synchronised with a transition with label [ϕκ]?Pκ.op[πκ] of another pro- tocol which results in a transition with label [ϕλ ∧ϕκ]Pλ dK Pκ.op[πλ ∧πκ] where the original preconditions (postconditions resp.) are combined by conjunction. Tran- sitions whose labels concern connected ports which cannot be synchronised are



Figure 3. Protocol FT of component Turnstile.

Figure 4. Protocol FC of component Client.

Figure 5. Protocol FO of component Operator.
dropped while transitions whose labels concern unconnected ports are kept in the composition.
Definition 3.3 [Protocol Composition]
Let A = (Aλ)λ∈Λ be a family of assemblies, let F = (Fλ)λ∈Λ be a family of protocols Fλ = (Sλ, s0,λ, LP (Aλ), Δλ) ∈ Prot (Aλ), and let K ⊆ conns(A) be a valid set of connectors. The protocol composition of F via K yields the behaviour protocol
☒KF ∈ Prot (+KA) defined by
☒KF = (S1 × ... × Sn, (s0,1,..., s0,n), LP (+KA), Δ)
where Δ is the least relation satisfying: if (s1,..., sn) ∈ S1 × ... × Sn, then
for all K : {Pλ, Pκ}∈ K, for i /= j ∈ {λ, κ},
if (si, [ϕi]!Pi.op[πi], s' ) ∈ Δi and (sj, [ϕj]?Pj.op[πj], s' ) ∈ Δj, then
i	j
((s1, .., si, .., sj, .., sn), [ϕi ∧ ϕj]Pi dK Pj.op[πi ∧ πj], (s1, .., s' , .., s' , .., sn)) ∈ Δ;
i	j
for all lλ ∈ LP (Aλ) \ LP (ports(K)),
if (sλ, lλ, s' ) ∈ Δλ, then ((s1, .., sλ, .., sn), lλ, (s1, .., s' , .., sn)) ∈ Δ.
λ	λ
The composition operator is related to the synchronous product of symbolic transition systems defined in [7], where synchronisation vectors are used instead of corresponding input/output labels. While in [7] predicates occurring in labels

always refer to the data states of the owning component, in our case the predicates occurring in send labels refer to the (required) data states of the connected com- ponent. Altough this may look as a minor technical discrimination, this reflects a crucial difference of the proposed method. Indeed, referring in required inter- faces to the (visible) data states of connected components is a prerequisite for the contract-oriented approach which we follow here.
When composing systems out of components it is important that the single components are behaviourally compatible, i.e. work correctly together. Since we can assume that for components, say C and C', behaviour protocols are given, which both express assumptions and guarantees from their particular viewpoint (cf. Tab. 1), the crucial idea is to ensure that the mutual assumptions and guarantees of the protocols of C and C' fit together. In the context of distinguished input and output actions an important compatibility requirement concerns the question, whether any output issued by one component meets the partner component in a state where it expects the corresponding input; cf., e.g., [6]. In our approach we have to consider this requirement not only from the control flow but also from the data state perspective. In the following, we introduce a compatibility notion for behaviour protocols which extends the concept of strong compatibility in [3] (and similar notions in [6,12]) to take into account data states.
Definition 3.4 [Protocol Compatibility]
Let A = (Aλ)λ∈Λ be a family of assemblies, let F = (Fλ)λ∈Λ be a family of protocols Fλ = (Sλ, s0,λ, LP (Aλ), Δλ) ∈ Prot (Aλ), and let K ⊆ conns(A) be a valid set of connectors. The family F is K-compatible if for all reachable states (s1,..., sn) in
☒KF, for all K : {Pλ, Pκ}∈ K, for i /= j ∈ {λ, κ} and for all σ ∈ D(obsreq (Pi)) and
ρ : varin(op) →V the following holds:
if (si, [ϕi]!Pi.op[πi], s' ) ∈ Δi and σ; ρ ▶ ϕi,
then there exists (sj, [ϕj]?Pj.op[πj], s' ) ∈ Δj such that
σ; ρ ▶ ϕj, and
for all σ' ∈ D(obsprv (Pj)), (σ, σ'; ρ ▶ πj and σ; ρ ▶ ϕi) implies σ, σ'; ρ ▶ πi.
Compatibility essentially formalises the requirement that for every (outgoing) operation call specified by a protocol there must exist a corresponding reception, specified by the partner protocol, with compatible preconditions and compatible postconditions. Note that also protocols with a terminal state can be compatible, if all possible outputs specified in one protocol are accepted by the communication partner. More precisely, condition (1) states that whenever for an output label [ϕi]!Pi.op[πi] the precondition ϕi is satisfied in some state σ ∈ D(obsreq (Pi)) w.r.t. some valuation ρ for the input variables of op, i.e. a caller has fullfilled his guarantee
w.r.t. σ and ρ, then a callee has a transition with a precondition ϕj which is also satisfied w.r.t. σ and ρ, and hence meets the assumptions of the callee. Note that the chosen transition for op on the callee’s side may depend on the state σ and on the valuation ρ where the call was issued. Thus condition (1) allows that a precondition of op on the caller’s side can be matched by the disjunction of various preconditions which are distributed over different transitions for op on the callee’s side. Condition

(2) says that whenever the execution of op reaches a state σ' ∈ D(obsprv (Pj)) where the postcondition πj of op (on the chosen transition) is satisfied, i.e. a callee has fulfilled his guarantee, then the postcondition πi of op, assumed from a caller, is also satisfied in the respective states. Condition (2) also shows, that for the latter implication to hold one can even additionally assume that the precondition ϕi holds
w.r.t. σ and ρ, because this has already been guaranteed by the caller before.
For instance, the two protocols shown in Fig. 3 and Fig. 5 are {K2 }-compatible, already without taking into account pre- and postconditions. The protocols in Fig. 3 and Fig. 4 are {K1 }-compatible. In this case, it is essential that the precondition x = fare of coin(x) in the Client protocol has guaranteed the precondition x ≥ fare assumed by the Turnstile protocol. Obviously, also the whole family of protocols used in the turnstile example is {K1 , K2 }-compatible; note that some states of the turnstile and the operator are not even reachable in the fully composed protocol.
Restrictions of behaviour protocols. First, in a more general setting one would like to specify also data invariants for the states of behaviour protocols which could be integrated in our framework along the lines of [2]. Secondly, in the send labels [ϕ]!P.op[π] of a behaviour protocol we have assumed that the precondition ϕ refers only to the observer signature of the required interface of the port P . More generally, it would be possible to admit also observers of the provided interface of P in ϕ. In this way one could express, e.g., that a message can only be emitted if the values of the state variables of the owning component are in a particular relation to the values of the state variables of the connected component. For notational convenience we have omitted this generalisation here.
Moreover, behaviour protocols do not support silent transitions which would require a major extension, in particular of the notion of compatibility. We be- lieve, however, that this would work on the basis of our weak compatibility notion introduced in [3] without taking into account data states yet.
The transitions in a behaviour protocol model the full execution of an operation and hence may require mutual exclusion in an implementation, thus reducing the degree of possible concurrency. In a more flexible setting one would like to discrim- inate the events of sending out an operation call, receiving an operation invocation, internal operation execution, sending out the operation result and receiving the re- sult (cf. [15]) and, moreover, to support asynchronous communication and remote resolution of preconditions; cf. [1]. Of course, this flexibility is rather problematic if one wants to trust pre- and postconditions and it is a real challenge to investigate appropriate communication patterns where pre/postcondition reasoning can still be sound in such an environment.

Compositional Semantics of Behaviour Protocols
Behaviour protocols are used for the specification of component and assembly be- haviours. In order to understand unambiguously the meaning of a specification, it is generally desirable to have a formal semantics of the specification at hand, which can be used as a basis for analysis and further reasoning, concerning, e.g.,

consistency and semantic equivalence of specifications. Since the purpose of any specification formalism is to specify programs and since specifications are inher- ently loose, leaving freedom to design decisions in implementations, we will follow here the loose semantics approach which, in the spirit of Hoare [10], considers the semantics of a specification as the class of all its correct implementations, also called models of the specification. In order to realise this idea in our setting, we first have to define appropriate mathematical structures that can represent implementations and, secondly, we must define a correctness notion for implementations w.r.t. a given behaviour protocol. Finally, we will prove a compositionality result which relates compositions on the level of protocols (which are of syntactic nature) with com- positions on the (semantic) level of implementations. The compositionality result ensures, under the condition of protocol compatibility studied in the last section, the independent implementability of protocols and the substitutability of (correct) implementations.
In order to formalise implementations in our framework, we will use particu- lar labelled transition systems, in the following called implementation models. In contrast to a behaviour protocol, an implementation model describes in a unique way the possible executions of a concurrent program with interleaving semantics. Hence, an implementation model will not be loose like a specification. It cannot be further refined and it is merely abstract in the sense that it provides a compact notation which does not depend on a particular programming language. On the contrary, the implementation models considered here could even be used as a basis to provide a big-step semantics for a subset of concurrent programs written in a concrete programming language, like concurrent Java, similarly as it is done for (a subset) of sequential Java programs in [17]. Though this goes beyond the scope of this paper, it still provides a perspective how to define a formal correctness relation between behaviour protocols and (concurrent) Java programs.
Let us now describe in more detail the construction of implementation models. The states of an implementation model must carry information for both, the control flow and the evolution of data states. To discriminate the two aspects we distinguish between control states and data states. As already explained, a (visible) data state is determined by the values of the observers of a given observer signature. Hence, for a component C, a (visible) data state is an element σ ∈ D(obs(C)). The underlying state space of C in an implementation model is then formed by the cartesian product Ctrl C × D(obs(C)) where Ctrl C is a set of control states. The state space of an assembly is formed by the cartesian product of the state spaces of all its components.
The labels of an implementation model are split into labels L(P ) for ports P and labels L(K) for connectors K; see Fig. 6. The labels in L(P ) describe incoming and outgoing operation invocations on port P with particular actual parameters. A label of the form ?P.(m, ρ) expresses the invocation of a provided operation m on port P with actual parameters determined by a valuation ρ : varin(m) → V. A transition labelled with ?P.(m, ρ) connects a state where the operation is called with the state after execution of the operation. Hence the implementation models considered here assume atomic operation executions. A label of the form (T, !P.(m, ρ)) expresses



Figure 6. Labels for implementation models.
that the implementation sends out an operation call of m with actual parameters determined by ρ provided that a receiver is in some state whose data part matches
T . More precisely, T is a set of data states over the required observers which models the fact that the implementation only invokes m if the visible data state of a (potential) receiver component belongs to T . In a concrete program this may require that the sender component performs in an atomic action a test on the data state of a receiver component (by means of the receiver’s observers) and, depending on the result, invokes the required operation.
Implementation models for assemblies must also include labels for communica- tion via connectors. For a connector K between ports P1 and P2, the set L(K) consists of labels of the form P1 dK P2.(m, ρ) which express the synchronised op- eration invocation (m, ρ) sent on P1 and received on P2. The target state of a transition labelled by P1 dK P2.(m, ρ) is reached when the operation has finished its execution. For an assembly A, the implementation labels in L(A) are those labels which correspond to connectors or to open ports of A.
Definition 4.1 [Implementation Model]
For an assembly A, an A-implementation model (A-implementation for short) is an LTS M = (Q, q0, L(A), Δ) with state space


Q =	 
C∈cmps(A)
Ctrl C × D(obs(C))

where for each component C ∈ cmps(A), Ctrl C is a set of control states. We require that an implementation model is input-enabled, i.e. for each label of the form ?P.(m, ρ) ∈ L(A) with P ∈ open(A), and for each state q ∈ Q, there exists a transition (q, l, q') ∈ Δ. The class of all A-implementations is denoted by Impl (A). For a state q ∈ Q and a component C ∈ cmps(A) we write qC for the projection of q to the state of the component C, which is a pair qC = (c, σ) ∈ Ctrl C ×D(obs(C)). We write δ(qC) to refer to the data state part σ of qC.
Actually, we have implemented component assemblies with Java/A [11] making use of the facilities of concurrent Java to realise the dynamic behaviour of implemen- tation models. Outputs are (usually) performed within the thread of a component and inputs are implemented by methods. To ensure the atomicity of the transitions

in implementation models the Java blocking mechanisms must be carefully applied. Let us now discuss implementation correctness for an implementation model M
w.r.t. a given behaviour protocol F . As described in Sect. 3, the protocol F can be
considered as a contract between the implementor of a component and its partner. Of course, an implementation model needs only to take into account the assumptions and guarantees as depicted for the implementor of a component in Tab. 1. This means that, for a protocol transition with label [ϕm]?P.m[πm], the implementor can assume that the provided operation m is called in accordance with the protocol state
and with the precondition ϕm and then the implementation must ensure that after
the execution of m the postcondition πm is valid and one can proceed as specified by the protocol. Conversely, for a protocol transition with label [ϕn]!P.n[πn], the implementation must ensure that it calls the operation n only in accordance with
the protocol state and with the precondition ϕn.  After the execution of n the
implementation can assume the postcondition πn and it must ensure that one can proceed as specified by the protocol. These considerations can be formalised by adapting the concept of an alternating simulation relation for interface automata in [6] to our needs, where we have to deal with predicates on the specification level and with concrete data states and actual parameters on the implementation level. In this context the alternating simulation relation contains pairs (s, q), where s is a protocol state and q is an assembly state; i.e. q determines, for each component C in the assembly, the component’s state qC = (c, σ) with control state c and data state σ. The simulation relation is alternating, because reception of messages as specified in the protocol must be simulated in the implementation model, and conversely, every sending of a message in the model must be allowed (i.e. simulated) by the protocol. Thus an implementation may provide more inputs and, conversely, may produce less outputs than the protocol allows.
Definition 4.2 [Alternating Simulation Relation]
Let A be an assembly, F = (S, s0, LP (A), ΔF ) ∈ Prot (A) be an A-protocol, and M = (Q, q0, L(A), ΔM ) ∈ Impl (A). An alternating simulation relation between F and M is a relation R ⊆ S × Q such that for all (s, q) ∈ R,
for all P ∈ open(A), C = cmp(P ),
for all labels l = [ϕ]?P.op[π] ∈ LP (P ) and for all ρ : varin(op) → V,
if (s, l, s') ∈ ΔF and δ(qC); ρ ▶ ϕ, then for all transitions (q, ?P.(op, ρ), q') ∈
ΔM it holds (s', q') ∈ R and δ(qC), δ(q' ); ρ ▶ π;
for all labels l = (T, !P.(op, ρ)) ∈ L(P ), if (q, l, q') ∈ ΔM , then there exists a transition (s, [ϕ]!P.op[π], s') ∈ ΔF such that for all σ ∈ T it holds σ; ρ ▶ ϕ and (s', q') ∈ R;
for all K : {P1, P2}∈ conns(A), C1 = cmp(P1), C2 = cmp(P2) it holds: for i, j ∈ {1, 2}, i /= j, for all labels l = Pi dK Pj.(op, ρ) ∈ L(K),
if (q, l, q') ∈ ΔM , then there exists a transition (s, [ϕ]Pi dK Pj.op[π], s') ∈ ΔF
such that (s', q') ∈ R and δ(qC ); ρ ▶ ϕ and δ(qC ), δ(q' ); ρ ▶ π.
j	j	Cj
Conditions (1)(a) and (1)(b) formalise the obligations of the implementor of a component according to the contract principle as described above. Condition (2) ex-

presses that communications between components on the implementation level must be allowed, i.e. simulated, by corresponding protocol transitions. Thus, unlike [6], we do not treat communications as invisible (silent) actions, which are abstracted in a refinement relation, because for assembly implementations it is still important that communications conform to the protocol.
Definition 4.3 [Implementation Correctness]
Let A be an assembly, F = (S, s0, LP (A), ΔF ) ∈ Prot (A) be an A-protocol, and M = (Q, q0, L(A), ΔM ) ∈ Impl (A). M is a correct A-implementation of F , if there exists an alternating simulation relation R between F and M such that (s0, q0) ∈ R. The class of all correct A-implementations of F provides the semantics of F and is denoted by F ).
Implementation models can be composed to build larger systems from smaller ones. For this purpose we introduce the operator ⊗K which composes implemen- tation models in accordance with a set K of valid connectors for a family A of assemblies. The composition of implementation models synchronises transitions concerning connected ports if their labels, e.g. (T, !Pλ.(op, ρ)) and ?Pκ.(op, ρ) for a connector K : {Pλ, Pκ} ∈ K, express the same operation invocation (op, ρ) and if the caller, say Mλ, meets the callee, say Mκ, in a state whose visible data part lies in the set T which has guarded the send message. Transitions with labels not in L(ports(K)) concern open ports and are interleaved in the model composition. Note that the model composition expresses the linking of programs in our semantical do- main for implementations. If implementation models were not input-enabled one would need, in general, a more involved composition operator and also condition (1a) of the alternating simulation relation must be adjusted.
Definition 4.4 [Model Composition]
Let A = (Aλ)λ∈Λ be a family of assemblies, let M = (Mλ)λ∈Λ be a family of imple- mentation models Mλ = (Qλ, q0,λ, L(Aλ), Δλ) ∈ Impl (Aλ), and let K ⊆ conns(A) be a valid set of connectors. The model composition of M via K yields the imple- mentation model ⊗KM∈ Impl (+KA) defined by
⊗KM = (Q1 × ... × Qn, (q0,1,..., q0,n), L(+KA), Δ)
where Δ is the least relation satisfying: if (q1,..., q1) ∈ Q1 × ... × Qn, then
for all K : {Pλ, Pκ}∈ K, for i /= j ∈ {λ, κ},
if (qi, (T, !Pi.(op, ρ)), q' ) ∈ Δi and (qj, ?Pj.(op, ρ), q' ) ∈ Δj
i	j
and δ(qj,cmp(Pj )) ∈ T , then
((q1, .., qi, .., qj, .., qn), Pi dK Pj.(op, ρ), (q1, .., q' , .., q' , .., qn)) ∈ Δ;
i	j
for all lλ ∈ L(Aλ) \ L(ports(K)),
if (qλ, lλ, q' ) ∈ Δλ, then ((q1, .., qλ, .., qn), lλ, (q1, .., q' , .., qn)) ∈ Δ.
λ	λ
We are now able to prove our central result which shows that locally correct implementations of compatible protocols can be composed to a globally correct im- plementation of the composed protocol for the component assembly. As an impor- tant consequence this result ensures, under the condition of protocol compatibility,

independent implementability of protocols and substitutability of correct implemen- tations.
Theorem 4.5 Let A = (Aλ)λ∈Λ be a family of assemblies, F = (Fλ)λ∈Λ be a family of Aλ-protocols, M = (Mλ)λ∈Λ be a family of Aλ-implementations, and let K⊆ conns(A) be a valid set of connectors. If Mλ ∈ Fλ) for all λ ∈ Λ and if F is K-compatible, then ⊗KM∈ ☒KF).
Proof For all λ ∈ Λ, let
Fλ = (Sλ, s0,λ, LP (Aλ), ΔF ) and Mλ = (Qλ, q0,λ, L(Aλ), ΔM ).
By assumption there exist alternating simulation relations Rλ ⊆ Sλ×Qλ between Fλ and Mλ. For proving the correctness of ⊗KM we must find an alternating simulation relation R between ☒KF and ⊗KM such that ((s0,1, .., s0,n), (q0,1, .., q0,n)) ∈ R. We define
R ={((s1, .., sn), (q1, .., qn)) |
(sλ, qλ) ∈ Rλ for all λ ∈ Λ and (s1, .., sn) reachable in ☒K F}.

Obviously, ((s0,1, .., s0,n), (q0,1, .., q0,n)) ∈ R. We prove that R is indeed an alter- nating simulation relation. Assume ((s1, .., sn), (q1, .., qn)) ∈ R. It is straightfor- ward to see that condition (1) of Def. 4.2 is satisfied for R, since open(+KA) ⊆
 λ∈Λ open(Aλ). Condition (2) for connectors K' ∈/ K is also satisfied by assump- tion. Hence, we only need to consider condition (2) in Def. 4.2 for connectors
K : {Pλ, Pκ} ∈ K: Let Cλ = cmp(Pλ), Cκ = cmp(Pκ) and assume, w.l.o.g., a transition
((q1, .., qλ, .., qκ, .., qn), Pλ dK Pκ.(op, ρ), (q1, .., q' , .., q' , .., qn)) in ⊗KM.
λ	κ

By the rules of model composition, we have
(qλ, (T, !Pλ.(op, ρ)), q' ) ∈ ΔM  and (qκ, ?Pκ.(op, ρ), q' ) ∈ ΔM
such that the data state δ(qκ,Cκ ) belongs to T . By assumption we know (sλ, qλ) ∈
Rλ and hence, by condition (1b) of Def. 4.2 for Rλ, there exists a transition
(sλ, [ϕλ]!Pλ.op[πλ], s' ) ∈ ΔF	such that for all σ ∈ T it holds σ; ρ ▶ ϕλ and

(s' , q' ) ∈ Rλ; in particular, since δ(qκ,C ) ∈ T , we have δ(qκ,C
); ρ ▶ ϕλ.  By

compatibility (cf. Def. 3.4) there exists a transition (sκ, [ϕκ]?Pκ.op[πκ], s' ) ∈ ΔF
such that δ(qκ,Cκ ); ρ ▶ ϕκ and
(*) for all σ' ∈ D(obsprv (Pκ)), δ(qκ,C ), σ'; ρ ▶ ϕλ ∧πκ implies δ(qκ,C ), σ'; ρ ▶ πλ.

. By protocol composition it follows that
((s1, .., sλ, .., sκ, .., sn), [ϕλ ∧ ϕκ]Pλ dK Pκ.op[πλ ∧ πκ], (s1, .., s' , .., s' , .., sn)
λ	κ



Figure 7. Protocol F' of component Client which is not compatible to FT in Fig. 3.
is a transition in ☒KJ, and hence (s1, .., s' , .., s' , .., sn) is reachable in ☒KJ. By
λ	κ
assumption, we have (sκ, qκ) ∈ Rκ, and, moreover, we know δ(qκ,Cκ ); ρ ▶ ϕκ.
Then, it follows from condition (1a) of Def. 4.2 for Rκ that (s' , q' ) ∈ Rκ and
κ	κ

δ(qκ,Cκ
), δ(q'
κ
); ρ ▶ πκ, and by (*) also δ(qκ,Cκ
), δ(q'
κ
); ρ ▶ πλ (taking into

account δ(qκ,C ); ρ ▶ ϕλ). Hence, ((s1, .., s' , .., s' , .., sn), (q1, .., q' , .., q' , .., qn)) ∈ R
κ	λ	κ	λ	κ

such that δ(qκ,Cκ
); ρ ▶ ϕλ Λ ϕκ and δ(qκ,Cκ
), δ(q'
κ
); ρ ▶ πλ Λ πκ. Therefore also

condition (2) of Def. 4.2 is satisfied for R.	 
The following example illustrates that in the absence of protocol compatibility, Thm. 4.5 would not hold, i.e. independent implementability would not be guaran- teed anymore.
Example 4.6 Fig. 7 shows another protocol F' for the component Client. The
difference to the original protocol in Fig. 4 is that the precondition [x = fare] of the call coin(x) has been omitted, i.e. changed to true. Now the two protocols F'
and FT (cf. Fig. 3) are not compatible. Assume correct implementations MC of F' and MT of FT such that MT has an initial data state σ ∈ Ð(obs(Turnstile)) with σ(fare) = 5. Moreover, assume that the implementation model MC first sends out the operation call coin(3) which is allowed by F' , since there is a corresponding
transition in F' where the precondition true is trivially satisfied. On the other hand,
MT must only follow the protocol transitions in FT if the precondition of coin(x)
in FT is met, otherwise MT can have an arbitrary behaviour while still remaining a model of FT . In our example, the expected precondition is not satisfied (3 /≥ 5) when MC is synchronised with MT on the operation invocation coin(3). Hence, after the synchronisation MT could, e.g., issue alarm(). This is, however, not an admissible action according to the protocol composition ☒{K1}{F' , FT }. Thus the theorem does not hold without the assumption of compatible protocols.

Related Work
Our work is strongly influenced by the semantical considerations in [4,2] and by the concept of alternating simulation relation in [6]. The crucial difference to [6] is that we have integrated (changing) data states and that we have considered different formalisms for specification (finite behaviour protocols) and for implemen- tation (implementation models with possibly infinitely many states). As deviations from [6] we have not considered communications as internal actions, in order to be able to study the conformance of assembly implementations to assembly protocols,

and we have not assumed input-determinism for transition systems but, instead, have used a slightly stronger condition for the preservation of inputs in condition (1a) of Def. 4.2. In contrast to [6] we have only considered protocol compatibility since implementation compatibility is meaningless in the context of input-enabled implementations. In a recent work [14], Mouelhi et al. also consider an extension of the theory of interface automata to the case of data states. Indeed their ideas to deal with protocols are similiar to our treatment but they assume a global set of state variables, they require a stronger condition for compatibility and instead of considering implementation models and implementation correctness, they stay on the level of behaviour protocols and study alternating simulation relations between them. Moreover, their work is not adjusted to a component model with assemblies and connectors yet.
Other related approaches are based on symbolic transition systems (STS) whose labels can be enriched with guards and effect expressions [7,1]. While the ap- proach in [1] is motivated by using STS as finite abstractions of programs for model- checking, the approach of [7] is more directed towards model-checking of symbolic transition systems as specifications and a generative approach to obtain Java code. None of these formalisms focuses on formal correctness notions for implementations and on a contractual interpretation of pre- and postconditions. For instance, there is no compatibility relation between the guards of synchronised transition systems. On the other hand, it would be interesting to see, in what extent the model checking techniques used in [7,1] could be adjusted to check compatibility of components as proposed here.
A methodologically related approach is followed by Cˇern´a et al. in [5]. They use component-interaction automata for behavioural modelling of interfaces and define a notion of equivalence on these automata as well as a powerful, parameterised composition operator to prove substitutability and independent implementability properties, similar to our results. The main difference to our work is that they do not consider data states of components. Moreover, refinement and implementation notions in [5] do not follow the idea of alternating simulations where less outputs may be produced by an implementation than allowed by the specification.
Frameworks like CSP-OZ [8] or rCOS [13] deal also with the specification of event-based systems and they take into account data states as well. They do, however, not distinguish (at least semantically) between input and output actions and their expressive power is limited to cases where the effect of an operation on data states is always the same, independent of the control-flow behaviour of a component.

Concluding Remarks
We have proposed a formalism for the specification and implementation of com- ponent and assembly behaviour in a concurrent environment which integrates the aspects of control flow and evolving data states. The approach is based on a for- mal semantics for behaviour protocols supporting compositionality and hence in- dependent implementability of components. We clearly separate between specifi-

cations and implementations. The former are given by behaviour protocols which are contract-oriented and express the assumptions and guarantees concerning the implementor and the user of a component. Our approach can be considered as a study of the fundamental concepts that are needed to support the development of concurrent, component-oriented systems when data states of components are taken into account. Hence, on the specification level, our approach is independent from a particular assertion language for pre- and postconditions and, on the implemen- tation level, it is independent from a particular programming language notation. Of course, the instantiation to appropriate subsets of concrete languages, like OCL for assertions, UML for protocols, and concurrent Java for implementations is an interesting objective of further research.
In this paper we have assumed several restrictions concerning the underlying component model and the expressive power of protocols which have been described in the corresponding sections. Some of these restrictions are merely done for nota- tional convenience, others require a significant amount of further research. Under these we consider most important to take into account also silent, internal actions, that may have an effect on the data state of a component, and the investigation of communication patterns which allow more flexibility for concurrent implementa- tions while still ensuring the required assertions for the data states of a component.

Acknowledgement
We would like to thank Moritz Hammer, Alexander Knapp and Michel Bidoit for careful reading of a draft of this paper, Philip Mayer and Andreas Schroeder for their implementations of behaviour protocols with concurrent Java, and the anonymous reviewers of the previous version of this paper for many useful hints and suggestions.

References
Tom´as Barros, Rab´ea Ameur-Boulifa, Antonio Cansado, Ludovic Henrio, and Eric Madelaine. Behavioural models for distributed fractal components. Annales des T´el´ecommunications, 64(1-2):25– 43, 2009.
Sebastian S. Bauer and Rolf Hennicker. Views on behaviour protocols and their semantic foundation. In Proc. CALCO 2009, volume 5728 of Lect. Notes Comp. Sci., pages 367–382. Springer, 2009.
Sebastian S. Bauer, Philip Mayer, Andreas Schroeder, and Rolf Hennicker. On weak modal compatibility, refinement, and the MIO Workbench. In Proc. TACAS 2010, volume 6015 of Lect. Notes Comp. Sci., pages 175–189. Springer, 2010.
Michel Bidoit, Rolf Hennicker, Alexander Knapp, and Hubert Baumeister. Glass-box and black-box views on object-oriented specifications. In Proc. SEFM’04, Beijing, China, pages 208–217. IEEE Comp. Society Press, 2004.
Ivana Cern´a, Pavl´ına Varekov´a, and Barbora Zimmerova. Component substitutability via equivalencies of component-interaction automata. Electr. Notes Theor. Comput. Sci., 182:39–55, 2007.
Luca de Alfaro and Thomas A. Henzinger. Interface-based Design. In Manfred Broy, Johannes Gru¨nbauer, David Harel, and C.A.R. Hoare, editors, Engineering Theories of Software-intensive Systems, volume 195 of NATO Science Series: Mathematics, Physics, and Chemistry, pages 83–104. Springer, 2005.
Fabr´ıcio Fernandes and Jean-Claude Royer. The STSLib project: Towards a formal component model based on STS. Electr. Notes Theor. Comput. Sci., 215:131–149, 2008.

Clemens Fischer. CSP-OZ: a combination of Object-Z and CSP. In H. Bowman and J. Derrick, editors,
Proc. FMOODS, pages 423–438, Canterbury, UK, 1997. Chapman and Hall, London.
Rolf Hennicker, Stephan Janisch, and Alexander Knapp. On the observable behaviour of composite components. Electr. Notes Theor. Comput. Sci., 260:125–153, 2010.
C.A.R. Hoare. Proofs of correctness of data representations. Acta Informatica, 1:271–281, 1972.
Alexander Knapp, Stephan Janisch, Rolf Hennicker, Allan Clark, Stephen Gilmore, Florian Hacklinger, Hubert Baumeister, and Martin Wirsing. Modelling the CoCoME with the Java/A component model. In The Common Component Modeling Example: Comparing Software Component Models, volume 5153 of Lect. Notes Comp. Sci., pages 207–237. Springer, 2007.
Kim G. Larsen, Ulrik Nyman, and Andrzej Warsowski. Modal I/O automata for interface and product line theories. In Proc. ESOP’07, volume 4421 of Lect. Notes Comp. Sci., pages 64–79. Springer, 2007.
Zhiming Liu, Jifeng He, and Xiaoshan Li. rCOS: Refinement of Component and Object Systems. In
Proc. FMCO 2004, volume 3657 of Lect. Notes Comp. Sci., pages 183–221. Springer, 2004.
Sebti Mouelhi, Samir Chouali, and Hassan Mountassir. Refinement of interface automata strengthened by action semantics. Electr. Notes Theor. Comput. Sci., 253(1):111–126, 2009.
Frantisek Plasil and Stanislav Visnovsky. Behavior protocols for software components. IEEE Trans. Software Eng., 28(11):1056–1076, 2002.
Andreas Rausch, Ralf Reussner, Raffaela Mirandola, and Frantisek Plasil, editors. The Common Component Modeling Example: Comparing Software Component Models, volume 5153 of Lect. Notes Comp. Sci. Springer, 2008.
Bernhard Reus, Martin Wirsing, and Rolf Hennicker. A Hoare calculus for verifying Java realizations of OCL-constrained design models. In Proc. FASE’01, volume 2029 of Lect. Notes Comp. Sci., pages 300–317. Springer, 2001.
