

Electronic Notes in Theoretical Computer Science 253 (2009) 3–23
www.elsevier.com/locate/entcs

Uniform Logical Characterizations of Testing Equivalences for Nondeterministic, Probabilistic and Markovian Processes
Marco Bernardo
Universita` di Urbino “Carlo Bo” – Italy Istituto di Scienze e Tecnologie dell’Informazione

Abstract
Logical characterizations of nondeterministic, probabilistic, and Markovian variants of bisimulation equiva- lence rely on similar modal languages, each including true, negation, conjunction, and diamond. Likewise, logical characterizations of the corresponding variants of trace equivalence rely on similar modal languages, each including only true and diamond. Unfortunately, this is not the case with the existing logical char- acterizations of the corresponding variants of testing equivalence, as they are based on different modal languages. In this paper we show that the logical characterizations of testing equivalences for fully nonde- terministic processes, fully probabilistic processes, and fully Markovian processes without silent moves can be harmonized by means of a modal language comprising true, disjunction, and diamond.
Keywords: testing equivalence, modal logic, nondeterministic processes, probabilistic processes, Markovian processes.

Introduction
Behavioral equivalences [14] establish whether computing systems possess the same behavioral properties. The specific set of properties that are preserved by a specific behavioral equivalence clearly depends on how the system behavior is observed and can usually be characterized by means of a modal logic.
In [3] we considered three different approaches to the definition of behavioral equivalences – bisimulation [23], testing [12], and trace [6] – applied to three different classes of processes – fully nondeterministic, fully probabilistic, and fully Markovian. Then we surveyed the nine resulting modal logic characterizations, each of which relies on a subset of (possibly modified) operators of the Hennessy-Milner logic (HML) [17]: true, negation, conjunction, and diamond.
The survey was the basis for a comparative study of the involved modal lan- guages. The comparison is shown in Fig. 1, where on the horizontal axis we have the three approaches to the definition of behavioral equivalences, while on the ver-

1571-0661© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.002



Fig. 1. Comparison of logical characterizations for behavioral equivalences

tical axis we have the three classes of processes. The figure emphasizes both dif- ferences across the three approaches to the definition of behavioral equivalences (inter-column comparison) and regularities within some of the three approaches (intra-column comparisons).
The inter-column comparison reveals that, when moving from bisimulation equiv- alence to trace equivalence, the number of logical operators that are needed tends to diminish, in accordance with the decreasing distinguishing power of the three approaches. More precisely, in the case of bisimulation equivalence we have all the logical operators of HML, then negation is dropped in the case of testing equivalence, and finally the binary operator is left out as well in the case of trace equivalence.
Another inter-column difference is related to probabilistic and Markovian pro- cesses and has to do with the treatment of probabilistic and temporal information, which can be local or global as shown by the third axis in Fig. 1.
In a local characterization, probabilistic and temporal aspects are considered at the level of each individual action occurring in the computations. Thus probabilistic and temporal constraints have to be attached to individual logical operators and the interpretation of the resulting formulas is qualitative as usual, i.e. it returns a truth value. This is the case with probabilistic and Markovian bisimulation equivalences where the diamond operator is decorated with a probability/rate lower bound [21,8], consistently with the fact that the notion of bisimulation captures step-by-step behavior mimicking.
In a global characterization, instead, probabilistic and temporal aspects are con- sidered at the level of the overall computations. Thus probabilities and durations of entire computations become of interest and the interpretation of the usual nondec- orated formulas is quantitative, in the sense that it returns a number that measures how much a formula is satisfied. This is the case with probabilistic and Markovian testing and trace equivalences [20,3].
On the other hand, intra-column comparisons reveal regularities with respect to the involved logical operators among the three variants of bisimulation equivalence

(up to the diamond decorations discussed before) and among the three variants of trace equivalence.
In particular, the three logical characterizations of bisimulation equivalence rely on true, negation, conjunction, and diamond. More precisely, negation occurring in the logical characterization of [22] for the probabilistic case is not necessary as long as the considered probabilistic processes are reactive [13], but it has to be reintroduced as soon as the considered probabilistic processes admit nondetermin- ism [24]. 1 The logical characterization of [8] for the Markovian case includes an additional operator for asserting that actions with a certain name cannot be exe- cuted, which is clearly unnecessary in the presence of negation (and hence is not shown in Fig. 1).
Unfortunately, this regularity disappears in the case of testing equivalence (see the grey column). For nondeterministic processes, the logical characterization pro- vided by [16] captures a broom semantics, as the related modal language permits to ask simple questions after a certain trace has been executed. Therefore, the syntax of the modal language has a two-layer definition. In the top layer we have a modal operator on traces. In the bottom layer we have true, disjunction, and diamond with no continuation. Then two satisfaction relations are defined, which express that a process may or must satisfy a certain bottom-layer formula after executing a certain trace. By contrast, for probabilistic and Markovian processes, the logical characterizations of testing equivalence provided by [3] – on the basis of the original equivalence definition of [7] and of the fully abstract characterizations of [9,2]– rely on true and a conditional variant of diamond.
This paper addresses the problem of reconciling the logical characterizations for the three testing equivalences by means of a single modal language.
A way of tackling this problem is to exploit the relation between testing equiv- alence and failure equivalence [11] – which extends to ready equivalence in the probabilistic and Markovian cases [19,2] – and hence using the logical characteri- zation of the latter. This comprises true, diamond, and a failure predicate, i.e. a predicate for expressing the fact that actions whose name belongs to a given set cannot be executed [14].
However, we deem this solution not to be satisfactory because it disrupts the direct connection with HML operators. In other words, what we are searching for is a uniform modal language for the three variants of testing equivalence built from a suitable subset of (direct and dual) operators of HML, so as to preserve the inter-column decreasing trend shown in Fig. 1 for the operator set.
Since testing equivalence is finer than trace equivalence and the latter is charac- terized by true and diamond, those two operators will have to be part of the uniform modal language for testing equivalence. While trace equivalence is a linear-time re- lation, testing equivalence is sensitive to branching points, hence a binary operator will be necessary too. The logical characterization of [16] seems to suggest the in- clusion of disjunction rather than conjunction. Including conjuction would in fact

1 Should probability and nondeterminism coexist in the same states, a further operator is even necessary.

provide a different distinguishing power, as the modal language formed by true, diamond, and conjunction characterizes simulation equivalence [17], which is inde- pendent of testing equivalence [14].
In this paper we demonstrate that a uniform modal language for the three vari- ants of testing equivalence that retains a direct connection with HML exists and is precisely formed by true, disjunction, and diamond. With respect to [16], the lan- guage is no more concerned with traces but still keeps a may-satisfaction relation and a must-satisfaction relation. The latter has to be carefully defined for disjunc- tion and diamond, in order to be consistent with the notion of having to pass a test. In the probabilistic and Markovian cases, a syntax restriction has to be imposed on formulas of the form φ1 ∨ φ2, which requires the set of initial actions of φ1 to be disjoint from the set of initial actions of φ2. This constraint is necessary for a correct and easier computation of the probability of satisfying such formulas. For the sake of simplicity and uniformity, we restrict ourselves to finite-state processes without silent moves and we consider only their finite-length test-driven computations.
This paper is organized as follows. In Sect. 2 we recall the definitions of test- ing equivalence for fully nondeterministic, fully probabilistic, and fully Markovian finite-state processes without silent moves. In Sect. 3, 4, and 5 we provide three alternative logical characterizations for the three testing equivalences, each based on the uniform modal language mentioned above. Finally, in Sect. 6 we provide some concluding remarks as well as some comments on the presence of silent moves and the coexistence of nondeterminism and probabilistic/temporal aspects.

Testing Equivalences
In this section we present the definitions of the three variants of testing equivalence in a process algebraic setting. Firstly we introduce three calculi based on the same set Name of observable action names and the same set of behavioral operators – the inactive term, the action prefix operator, the alternative composition operator, and recursion – which generate all the fully nondeterministic, fully probabilistic, and fully Markovian finite-state processes. For the sake of simplicity, silent moves are not admitted within such processes, as it is not possible to abstract from them in the Markovian case.
Secondly, we recall the notions of execution probability and stepwise average duration for finite-length computations. Since in the Markovian testing case the presence of average time upper bounds makes infinite computations unimportant, for the sake of uniformity we focus only on finite-length test-driven computations for all three kinds of processes. As a consequence, since the behavior of a process under test is observed for a finite amount of time, we restrict ourselves to nonrecursive, finite-state tests for all three kinds of processes.
Thirdly, we describe the structure of tests and interaction systems. In order not to interfere with the quantitative aspects of the behavior of probabilistic and Markovian processes under test, we avoid the introduction of a success action ω. For the sake of uniformity, for all three kinds of processes the successful completion

of a test is formalized in the text syntax by replacing the inactive term with a zeroary operator denoting a success state. A failure state is not necessary as it can be encoded through an action not occurring in the processes under test.
Nondeterministic, Probabilistic, and Markovian Processes
In the nondeterministic process calculus (NPC for short), the choice among all the actions that are simultaneously enabled is nondeterministic. We denote by Act N = Name the set of actions of NPC, which are all observable.
Definition 2.1 The set of process terms of NPC is generated by the following syntax:

where 0 is the inactive term, a ∈ Act N, and A is a process constant defined through the (possibly recursive) equation A =Δ P .
The semantics for NPC can be provided in the usual operational style by asso- ciating a labeled transition system with each process term. The transition relation
−−−→N for the set PN of closed and guarded terms of NPC is defined as the least subset of PN × Act N × PN satisfying the rules shown in the first column of Table 1.
In the probabilistic process calculus (PPC for short), every action is represented as a pair composed of the name of the action and the probability of executing the action. We denote by Act P = Name × R]0,1] the set of actions of PPC. In order to ensure that the sum of the probabilities of the actions that are simultaneously enabled is either 0 or 1, we replace the action prefix operator and the binary al- ternative composition operator with a set of n-ary guarded alternative composition operators, with n ranging over the whole N>0.
Definition 2.2 The set of process terms of PPC is generated by the following syntax:


where I is a nonempty finite index set, <ai, pi> ∈ Act P for all i ∈ I, and it holds
i∈I pi = 1.
The semantics for PPC can be defined in the usual operational style, provided that a labeled multitransition system is associated with each process term. In other words, the multiplicity of the transitions has to be taken into account, where by multiplicity we mean the number of different ways in which a transition can be de- rived by applying the operational semantic rules. The reason is that idempotency (i.e. P + P = P ) no longer holds when moving from nondeterministic processes to probabilistic ones. As an example, a term like <a, 0.5>.P + <a, 0.5>.P cannot be equated to <a, 0.5>.P , which can be achieved by observing that there are two dif- ferent ways of deriving – through the operational semantic rules – a 0.5-probability transition labeled with a and reaching P (one for the left-hand side <a, 0.5>.P

summand plus another one for the right-hand side <a, 0.5>.P summand). The multitransition relation −−−→P for the set PP of closed and guarded terms of PPC is defined as the least multiset of elements of PP × Act P × PP satisfying the rules shown in the second column of Table 1. The stochastic process underlying a labeled multitransition system produced by the application of these rules turns out to be a discrete-time Markov chain.
In the Markovian process calculus (MPC for short), every action is represented as a pair composed of the name of the action and the rate of the exponential distri- bution quantifying the duration of the action. We denote by Act M = Name × R>0 the set of actions of MPC. The choice among all the actions that are simultaneously enabled is governed by the race policy. As a consequence, the execution probability of each action is proportional to its rate and the average sojourn time in the state associated with a process term is quantified by an exponentially distributed random variable whose rate is the sum of the rates of the enabled actions.
Definition 2.3 The set of process terms of MPC is generated by the following syntax:

where <a, λ> ∈ Act M.
Similarly to PPC, idempotency no longer holds and hence the multiplicity of the transitions has to be taken into account by associating a labeled multitransition system with each process term. As an example, a term like <a, 4.6>.P +<a, 4.6>.P is not equivalent to <a, 4.6>.P but to <a, 9.2>.P , because rates sum up due to the race policy. The multitransition relation −−−→M for the set PM of closed and guarded terms of MPC is defined as the least multiset of elements of PM×Act M×PM satisfying the rules shown in the third column of Table 1. The stochastic process underlying a labeled multitransition system produced by the application of these rules turns out to be a continuous-time Markov chain.
In the following, we denote by init (P ) the set of names of actions initially enabled by P ∈ PN ∪ PP ∪ PM.
Computations
A computation of a process term P ∈ PN ∪ PP ∪ PM is a sequence of transitions that can be executed starting from P . The length of a computation is given by the number of transitions occurring in it. We say that two distinct computations are independent of each other if neither is a proper prefix of the other one. We denote by Cf(P ) the multiset of finite-length computations of P and by If(P ) the multiset of maximal finite-length computations of P . Moreover, we denote by:

rate t(P ) = Σ{| λ ∈ R>0
a,λ
| ∃a, P '.P −−−→M
P ' |}

probc(P |N ) =	{| p ∈ R
a∈N

]0,1]
a,p
| ∃P '.P −−−→P
P ' |}

rate
c(P |N ) =	{| λ ∈ R>0
a∈N
a,λ
| ∃P '.P −−−→M
P ' |}


Table 1
Semantic rules for PN, PP, and PM


the total rate of P ∈ PM (which corresponds to the reciprocal of the average sojourn time in the state associated with P ), the conditional probability for P ∈ PP of executing actions whose name belongs to N ⊆ Name, and the conditional rate for P ∈ PM of executing actions whose name belongs to N ⊆ Name, respectively.
Definition 2.4 Let P ∈ PP ∪ PM and c ∈ Cf(P ). The probability of executing c is the product of the execution probabilities of the transitions of c, which is defined by induction on the length of c through the following R]0,1]-valued function:
We also define the probability of executing a computation in C ⊆ Cf(P ) as:


whenever C is finite and all of its computations are independent of each other.
Definition 2.5 Let P ∈ PM and c ∈ Cf(P ). The stepwise average duration of c is the sequence of the average sojourn times in the states traversed by c, which is defined by induction on the length of c through the following (R>0)∗-valued function:

where ε is the empty sequence and ◦ is the concatenation operator. We also define the multiset of computations in C ⊆ Cf(P ) whose stepwise average duration is not

greater than θ ∈ (R>0)∗ as:
Tests and Interaction Systems
The most convenient way to represent a test is through another process term, which interacts with the term under test by means of a parallel composition operator that enforces synchronization on all action names. We denote by s the success state of a test. Ambiguous tests including several summands among which at least one equal to s are avoided through a two-level syntax.
In the nondeterministic case, tests are made out of the same kind of actions that can occur in nondeterministic process terms.
Definition 2.6 The set TN of nondeterministic tests is generated by the following syntax:

where a ∈ Name.
The following operational rule defines the interaction of P ∈ PN and T ∈ TN:



In the probabilistic and Markovian cases, instead, tests are made out of passive actions, each equipped with a weight w ∈ R>0. The idea is that, in any of its states, a process term under test generates the proposal of an action to be executed by probabilistically selecting one of the actions enabled in that state. Then the test reacts by probabilistically selecting a passive action (if any) with the same name as the proposed action.
Definition 2.7 The set TR of reactive tests is generated by the following syntax:
where a ∈ Name and w ∈ R>0.
Let us denote by −−−→R the multitransition relation for reactive tests. Accord- ing to the terminology of [15], the following operational rule defines the probabilistic generative-reactive interaction [5] of P ∈ PP and T ∈ TR:

where init (T ) = {a ∈ Name | ∃w, T '.T a,∗w
T '} is the set of names of actions

enabled by T and weight (T, a)= Σ{| w ∈ R>0 | ∃T '.T	T ' |} is the weight of T
a,∗w
with respect to a. Note that, due to the normalization taking place in the conclusion of the rule above, if P  T has outgoing transitions, then the probabilities of those transitions sum up to 1.
Likewise, the following operational rule defines the Markovian generative-reactive interaction [4] of P ∈ PM and T ∈ TR, which preserves the conditional rate of P with respect to init (T ) due to the normalization taking place in the conclusion of the rule:
Definition 2.8 Let P ∈ PN and T ∈ TN, or P ∈ PP ∪ PM and T ∈ TR. The interaction system of P and T is process term P  T , where we say that:
A configuration is a state of the labeled (multi)transition system underlying P  T .
A configuration is successful iff its test component is s.
A computation is successful iff so is its last configuration.
We denote by SC(P, T ) the multiset of successful computations in Cf(P  T ).
All the computations in SC(P, T ) are independent of each other because of the maximality of successful test-driven computations. Moreover, SC(P, T ) is finite because of the finitely-branching structure of the considered terms.
Nondeterministic Testing Equivalence
Two nondeterministic processes are testing equivalent if they are indistinguishable with respect to the possibility and the necessity of passing an arbitrary test [12].
Definition 2.9 Let P ∈ PN and T ∈ TN. We say that:
P may pass T iff at least one computation of P  T is successful:
SC(P, T ) /= ∅
P must pass T iff all maximal computations of P  T are successful:
SC(P, T ) = If(P  T )
Definition 2.10 Let P1, P2 ∈ PN. We say that P1 is nondeterministic testing equivalent to P2, written P1 ∼NT P2, iff for all nondeterministic tests T ∈ TN:
P1 may pass T ⇐⇒ P2 may pass T P1 must pass T ⇐⇒ P2 must pass T
Probabilistic Testing Equivalence
In the probabilistic case, the possibility and the necessity of passing an arbitrary test are subsumed by the probability of passing the test.

Definition 2.11 Let P1, P2 ∈ PP. We say that P1 is probabilistic testing equiva- lent to P2, written P1 ∼PT P2, iff for all reactive tests T ∈ TR:
prob(SC(P1,T )) = prob(SC(P2,T ))

Markovian Testing Equivalence
In the Markovian case, we have to consider the probability of passing an arbitrary test within an arbitrary sequence of average amounts of time.
Definition 2.12 Let P1, P2 ∈ PM. We say that P1 is Markovian testing equivalent to P2, written P1 ∼MT P2, iff for all reactive tests T ∈ TR and sequences θ ∈ (R>0)∗ of average amounts of time:
prob(SC≤θ(P1,T )) = prob(SC≤θ(P2,T ))

Alternative Logical Characterization of ∼NT
The modal language characterizing ∼NT provided by [16] has a two-layer syntax. In the top layer there is a modal operator on traces, whereas in the bottom layer there are true, disjunction, and a modal operator on actions with no continuation. This language is interpreted by means of two satisfaction relations, which express that a process may or must perform certain actions after executing a certain trace. In the following we show an alternative characterization based on a modal lan- guage with a syntax related to actions only that includes true, disjunction, and diamond. With respect to HML, this language is less powerful as it is devoid of negation. Moreover, it replaces conjunction with disjunction. This is unavoidable, as ∼NT is the intersection of may-testing equivalence and must-testing equivalence, with the former coinciding with trace equivalence and hence not admitting con- junction in its characterization. We also observe that conjunction cannot simply be discarded but must be replaced, as having only true and diamond would not be
enough to characterize must-testing equivalence.
Definition 3.1 The set of formulas of MLT is generated by the following syntax:

where a ∈ Name.
Definition 3.2 The set init(φ) of names of actions initially occurring in a formula
φ ∈ MLT is defined by structural induction as follows:


The new modal language retains the two satisfaction relations, but the one for the must case has to be carefully defined for disjunction and diamond in order for it to be consistent with the notion of having to pass a test.
Definition 3.3 The satisfaction relation |=may of MLT over PN is defined by struc- tural induction as follows:



Definition 3.4 The satisfaction relation |=must of MLT over PN is defined by struc- tural induction as follows:
The intuition behind the definition of |=must is that, given P ∈ PN and φ ∈ MLT − {true}, init (P ) must intersect init (φ) and P must satisfy φ along each of its computations starting with a transition labeled with an action name belonging to init (P ) ∩ init(φ).
A must-interpretation of disjunction like the following:
P |=must φ1 ∨ φ2	if P |=must φ1 or P |=must φ2
would be wrong. As an example, it is not the case that a.0 + b.0 must pass a.s+ b.c.s because of the unsuccessful maximal test-driven computation composed of transition b, but it would be a.0+b.0 |=must ⟨a⟩true∨⟨b⟩⟨c⟩true because a.0+b.0 |=must ⟨a⟩true.
Likewise, a must-interpretation of diamond like the following:

P |=
must
⟨a⟩φ	if for all P ' whenever P	a
P ' then P ' |=
must φ

would be wrong. As an example, it is not the case that 0 must pass a.s because
SC(0, a.s) = ∅ /= {ε} = If(0  a.s), but it would trivially be 0 |=must ⟨a⟩true because there is no P ' reachable from 0 via a.
We observe that our must-interpretation of diamond differs from the must- interpretation of the modal operator on traces defined in [16]. In fact, we addi- tionally require the existence of at least one a-transition leaving P as a necessary condition for the must-satisfaction of ⟨a⟩φ. By contrast, due to the two-layer syntax of the modal language, and consistently with an alternative characterization of [12], for the modal operator on traces it is simply required that P does not diverge when accepting the specified trace.

Lemma 3.5 For all T ∈ TN there exists φT ∈ MLT such that init (φT )= init(T )
and for all P ∈ PN:
P may pass T =⇒ P |=may φT P must pass T =⇒ P |=must φT
Lemma 3.6 For all φ ∈ MLT there exists Tφ ∈ TN such that init(Tφ) = init (φ)
and for all P ∈ PN:
P |=may φ =⇒ P may pass Tφ P |=must φ =⇒ P must pass Tφ
Theorem 3.7 Let P1, P2 ∈ PN. Then P1 ∼NT P2 iff for all φ ∈ MLT:
P1 |=may φ ⇐⇒ P2 |=may φ P1 |=must φ ⇐⇒ P2 |=must φ


Alternative Logical Characterization of ∼PT
A slight variant of MLT denoted by MLT,ind can be employed to characterize
∼PT. In order for probabilities to be computed correctly, in MLT,ind each formula of the form φ1 ∨ φ2 must satisfy the constraint init (φ1) ∩ init (φ2)= ∅. In this way, φ1 and φ2 are guaranteed to exercise independent computations of an arbitrary process term, hence the probability that the term satisfies φ1 ∨ φ2 can essentially be computed as the sum of the probabilities of satisfying φ1 and φ2.
On the test side, this constraint amounts to work with the set TR,det of name- deterministic reactive tests, in which each test of the form T1 + T2 must satisfy init (T1) ∩ init(T2)= ∅. From [7,9] it is known that the canonical reactive tests for
∼PT are generated by the following syntax:

T ::= s | <a, ∗1>.T +
b∈E−{a}
<b, ∗1>.<z, ∗1>.s

where E is a finite subset of Name including a, the summation disappears whenever
E − {a} = ∅, and z is a fresh action name that cannot occur in any process term. Since canonical reactive tests are name-deterministic, we can restrict ourselves to TR,det without loss of distinguishing power.
While MLT has been interpreted over PN through two qualitative satisfaction relations, MLT,ind will be equipped with a quantitative interpretation function in the spirit of [20]. This function measures the probability of satisfying a formula under the condition that – consistently with the testing approach – the formula itself establishes the names of the only actions that can be enabled.

Definition 4.1 The interpretation function [.]]PT of MLT,ind over PP is defined by letting [φ]]PT(P ) = 0 for φ ∈ MLT,ind − {true} whenever init (P ) ∩ init (φ) = ∅,

otherwise by structural induction as follows:

p	 prob c(P |init(φj )) 	j	,
probc(P |init(φ1∨φ2))
In the definition above, pj represents the probability with which P performs actions whose name is in init(φj) rather than actions whose name is in init (φk), k =3 − j, given that P can perform actions whose name is in init (φ1 ∨φ2). These probabilities are used as weights for the correct account of the probabilities with which P satisfies φ1 alone and φ2 alone in the context of the satisfaction of φ1 ∨ φ2. If such weights were omitted, then the fact that φ1 ∨ φ2 offers a set of initial actions at least as large as the ones offered by φ1 alone and φ2 alone would be ignored, thus leading to a potential overestimate of the probability of satisfying φ1 ∨ φ2.

Lemma 4.2 For all T ∈ TR,det there exists φT ∈ MLT,ind such that init (φT ) = 
init (T ) and for all P ∈ PP:
[[φT ]]PT(P ) = prob (SC(P, T ))

Lemma 4.3 For all φ ∈ MLT,ind there exists Tφ ∈ TR,det such that init(Tφ) = 
init (φ) and for all P ∈ PP:
prob(SC(P, Tφ)) = [φ]]PT(P )

Theorem 4.4 Let P1, P2 ∈ PP. Then P1 ∼PT P2 iff for all φ ∈ MLT,ind:
[[φ]]PT(P1) = [φ]]PT(P2)


Alternative Logical Characterization of ∼MT
The same constrained version MLT,ind of MLT can be used for ∼MT so as to compute probabilities correctly. Since the canonical reactive tests for ∼MT are the same as those for ∼PT [2], also in this case we can restrict ourselves to TR,det without loss of distinguishing power. The difference with respect to the probabilistic case is that the quantitative interpretation function will have to measure the probability of satisfying a formula within a sequence of average amounts of time.

Definition 5.1 The interpretation function [.]]MT of MLT,ind over PM × (R>0)∗ is defined by letting [φ]]MT(P, θ) = 0 for φ ∈ MLT,ind − {true} whenever init (P ) ∩

init (φ)= ∅ or θ = ε, otherwise by structural induction as follows:









  rate c(P |init(φj )) 
rate c(P |init(φ1∨φ2))
1
ratec(P |init(φj ))
	1	
rate c(P |init(φ1∨φ2))

j ∈ {1, 2}.
In the definition above, tj represents the extra average time granted to P for sat- isfying φj. This extra average time is equal to the difference between the average sojourn time in P when only actions whose name is in init (φj) are enabled and the average sojourn time in P when also actions whose name is in init(φk), k =3 − j, are enabled. Since the latter cannot be greater than the former due to the race pol- icy (more enabled actions means less time spent on average in a state), considering t instead of tj in the satisfaction of φj would lead to a potential underestimate of the probability of satisfying φ1 ∨ φ2 within the given time bound, as P may satisfy φ1 ∨ φ2 within t ◦ θ even if P satisfies neither φ1 alone nor φ2 alone within t ◦ θ.
Lemma 5.2 For all T ∈ TR,det there exists φT ∈ MLT,ind such that init (φT ) = 
init (T ) and for all P ∈ PM and θ ∈ (R>0)∗:
[[φT ]]MT(P, θ) = prob(SC≤θ(P, T ))
Lemma 5.3 For all φ ∈ MLT,ind there exists Tφ ∈ TR,det such that init(Tφ) = 
init (φ) and for all P ∈ PM and θ ∈ (R>0)∗:
prob(SC≤θ(P, Tφ)) = [φ]]MT(P, θ)
Theorem 5.4 Let P1, P2 ∈ PM. Then P1 ∼MT P2 iff for all φ ∈ MLT,ind and
θ ∈ (R>0)∗:
[[φ]]MT(P1, θ) = [φ]]MT(P2, θ)
Conclusion
Starting from the comparison of [3], in this paper we have tackled the problem of finding a uniform modal language for characterizing three variants of testing equiv- alence. We have demonstrated that such a language exists and comprises true, disjunction, and diamond. In the nondeterministic case, similarly to [16] we have defined a may-satisfaction relation and a must-satisfaction relation, with the latter being carefully designed for disjunction and diamond in order to characterize cor- rectly must-testing equivalence. In the probabilistic and Markovian cases, we have provided a quantitative interpretation inspired by [20], after imposing an indepen- dence constraint on the occurrences of disjunction. The revised comparison resulting



Fig. 2. Revised comparison of logical characterizations for behavioral equivalences

from the alternative characterizations of the three variants of testing equivalence is shown in Fig. 2.
The figure hides the fact that two different satisfaction relations have been pro- vided in the nondeterministic case, and that must-satisfaction results in a non- standard interpretation of disjunction and diamond. However, this seems to be unavoidable due to the way testing equivalence is defined. By contrast, a single in- terpretation function is enough in the probabilistic and Markovian cases, as the fact that a process may or must pass a test is encoded within a probability interval. It is also worth pointing out that, similarly to [20], in those two cases no quantititative information is necessary within the uniform modal language.
In [3] and in the present work we have compared (on a modal logic basis) bisimu- lation, testing, and trace equivalences for fully nondeterministic, fully probabilistic, and fully Markovian finite-state processes without silent moves. In the nondeter- ministic and probabilistic cases, τ actions can be handled by means of a weak interpretation of diamond, as shown e.g. in [23,24,10]. However, the situation is more complicated for Markovian processes, as it is rarely the case that we can ab- stract from the durations of τ actions while remaining in the field of exponential distributions [18].
As far as the coexistence of nondeterminism and probabilistic/temporal aspects is concerned, for bisimulation equivalence we have already mentioned in the intro- duction that the modal language shown in the first column of Fig. 2 is valid as long as nondeterminism and probability are not simultaneously present in the same states, otherwise a further operator is necessary [24]. For the testing case, in [10] it is shown that a modal language different from the one in the second column of Fig. 2 is necessary, which is composed of true, conjunction, diamond, failure predicate, and convex combination. However, the testing equivalence considered in [10] for mixed nondeterministic/probabilistic processes is not a conservative extension of the test- ing equivalence of [12] for fully nondeterministic processes. The reason is that [10] allows for probabilistic choices within tests, which is enough for distinguishing non-

deterministic processes that are equivalent according to [12]. In fact, probabilistic choices within tests provide the capability of making copies of the states of the processes being tested and experimenting on each of them independently, which increases the distinguishing power [1].
Future work will be devoted to investigating whether and to which extent our uniform modal language for testing equivalence is suitable for the framework of [10] under the constraint that tests are fully nondeterministic. Moreover, it would be interesting to find a way of encoding the uniform modal language of this paper into modal languages for which model-checking algorithms already exist.

Acknowledgement
We thank Michele Loreti for some initial discussions on modal logics for test- ing equivalences. This work has been funded by MIUR-PRIN project PaCo – Performability-Aware Computing: Logics, Models, and Languages.

References
S. Abramsky, “Observational Equivalence as a Testing Equivalence”, in Theoretical Computer Science 53:225-241, 1987.
M. Bernardo, “Non-Bisimulation-Based Markovian Behavioral Equivalences”, in Journal of Logic and Algebraic Programming 72:3-49, 2007.
M. Bernardo and S. Botta, “A Survey of Modal Logics Characterizing Behavioral Equivalences for Nondeterministic and Stochastic Systems”, in Mathematical Structures in Computer Science 18:29- 55, 2008.
M. Bernardo and M. Bravetti, “Performance Measure Sensitive Congruences for Markovian Process Algebras”, in Theoretical Computer Science 290:117-160, 2003.
M. Bravetti and A. Aldini, “Discrete Time Generative-Reactive Probabilistic Processes with Different Advancing Speeds”, in Theoretical Computer Science 290:355-406, 2003.
S.D. Brookes, C.A.R. Hoare, and A.W. Roscoe, “A Theory of Communicating Sequential Processes”, in Journal of the ACM 31:560-599, 1984.
I. Christoff, “Testing Equivalences and Fully Abstract Models for Probabilistic Processes”, in Proc. of the 1st Int. Conf. on Concurrency Theory (CONCUR 1990), LNCS 458:126-140, 1990.
G. Clark, S. Gilmore, and J. Hillston, “Specifying Performance Measures for PEPA”, in Proc. of the 5th AMAST Int. Workshop on Formal Methods for Real Time and Probabilistic Systems (ARTS 1999), LNCS 1601:211-227, 1999.
R. Cleaveland, Z. Dayar, S.A. Smolka, and S. Yuen, “Testing Preorders for Probabilistic Processes”, in Information and Computation 154:93-148, 1999.
Y. Deng, R.J. van Glabbeek, M. Hennessy, C. Morgan, and C. Zhang, “Characterising Testing Preorders for Finite Probabilistic Processes”, in Proc. of the 22nd IEEE Symp. on Logic in Computer Science (LICS 2007), IEEE-CS Press, pp. 313-325, 2007.
R. De Nicola, “Extensional Equivalences for Transition Systems”, in Acta Informatica 24:211-237, 1987.
R. De Nicola and M. Hennessy, “Testing Equivalences for Processes”, in Theoretical Computer Science 34:83-133, 1984.
J. Desharnais, A. Edalat, and P. Panangaden, “Bisimulation for Labelled Markov Processes”, in Information and Computation 179:163-193, 2002.
R.J. van Glabbeek, “The Linear Time - Branching Time Spectrum I”, in “Handbook of Process Algebra”, pp. 3-99, Elsevier, 2001.


R.J. van Glabbeek, S.A. Smolka, and B. Steffen, “Reactive, Generative and Stratified Models of Probabilistic Processes”, in Information and Computation 121:59-80, 1995.
M. Hennessy, “Acceptance Trees”, in Journal of the ACM 32:896-928, 1985.
M. Hennessy and R. Milner, “Algebraic Laws for Nondeterminism and Concurrency”, in Journal of the ACM 32:137-162, 1985.
J. Hillston, “A Compositional Approach to Performance Modelling”, Cambridge University Press, 1996.
C.-C. Jou and S.A. Smolka, “Equivalences, Congruences, and Complete Axiomatizations for Probabilistic Processes”, in Proc. of the 1st Int. Conf. on Concurrency Theory (CONCUR 1990), LNCS 458:367-383, 1990.
M.Z. Kwiatkowska and G.J. Norman, “A Testing Equivalence for Reactive Probabilistic Processes”, in Proc. of the 2nd Int. Workshop on Expressiveness in Concurrency (EXPRESS 1998), ENTCS 16(2):114-132, 1998.
K.G. Larsen and A. Skou, “Bisimulation through Probabilistic Testing”, in Information and Computation 94:1-28, 1991.
K.G. Larsen and A. Skou, “Compositional Verification of Probabilistic Processes”, in Proc. of the 3rd Int. Conf. on Concurrency Theory (CONCUR 1992), LNCS 630:456-471, 1992.
R. Milner, “Communication and Concurrency”, Prentice Hall, 1989.
A. Parma and R. Segala, “Logical Characterizations of Bisimulations for Discrete Probabilistic Systems”, in Proc. of the 10th Int. Conf. on Foundations of Software Science and Computational Structures (FOSSACS 2007), LNCS 4423:287-301, 2007.

Appendix: Proofs
Proof of Lemma 3.5: We proceed by induction on the syntactical structure of
T ∈ TN:
Let T ≡ s and take φT ≡ true. Since for all P ∈ PN we have that P may pass s,
P must pass s, P |=may true, and P |=must true, the result follows.
Let T ≡ T1 + T2 and P ∈ PN.
If P may pass T , then P  T has at least one successful computation. Since T ≡ T1 + T2, this successful computation must belong to P  T1 or P  T2, hence P may pass T1 or P may pass T2. From the induction hypothesis it follows that there exist φT1 , φT2 ∈ MLT with init (φT1 ) = init (T1) and init (φT2 ) = init (T2) such that P |=may φT1 or P |=may φT2 . Therefore P |=may φT1 ∨ φT2 .
If P must pass T , then all the maximal computations of P  T are successful.
Since T ≡ T1 + T2, it must be the case that init(P ) ∩ (init (T1) ∪ init (T2)) /=
∅. Moreover, init (P ) ∩ init (T1) /= ∅ necessarily implies that P must pass T1. Likewise, init (P )∩init(T2) /= ∅ necessarily implies that P must pass T2. From the induction hypothesis it follows that there exist φT1 , φT2 ∈ MLT with init(φT1 )= init (T1) and init (φT2 )= init (T2) such that init(P )∩init (φT1 ) /= ∅ implies P |=must φT1 and init (P ) ∩ init (φT2 ) /= ∅ implies P |=must φT2 . From init(P ) ∩ (init (φT1 ) ∪ init (φT2 )) /= ∅ we derive that P |=must φT1 ∨ φT2 .
The result then follows by taking φT ≡ φT1 ∨ φT2 .
Let T ≡ a.T ' and P ∈ PN.
If P may pass T , then P  T has at least one successful computation. Since

T ≡ a.T ', there must exist P ' ∈ PN
a
such that P −−−→N
P ' and P ' may pass T '.

From the induction hypothesis it follows that there exists φT ' ∈ MLT such that
P ' |=may φT ' . Therefore P |=may ⟨a⟩φT ' .
If P must pass T , then all the maximal computations of P	T are successful. Since

T ≡ a.T ', there must exist P ' ∈ PN
a
such that P −−−→N
P ' and each such P ' must

pass T '. From the induction hypothesis it follows that there exists φT ' ∈ MLT
such that each such P ' |=must φT ' . Therefore P |=must ⟨a⟩φT ' .
The result then follows by taking φT ≡ ⟨a⟩φT ' .	 
Proof of Lemma 3.6: We proceed by induction on the syntactical structure of
φ ∈ MLT:
Let φ ≡ true and take Tφ ≡ s. Since for all P ∈ PN we have that P |=may true,
P |=must true, P may pass s, and P must pass s, the result follows.
Let φ ≡ φ1 ∨ φ2 and P ∈ PN.
If P |=may φ, then P |=may φ1 or P |=may φ2. From the induction hypothesis it follows that there exist Tφ1 , Tφ2 ∈ TN with init (Tφ1 )= init(φ1) and init (Tφ2 )= init (φ2) such that P may pass Tφ1 or P may pass Tφ2 . Therefore P may pass Tφ1 + Tφ2 .
If P |=must φ, then it must be the case that init (P ) ∩ (init (φ1) ∪ init (φ2)) /= ∅.
Moreover, init (P ) ∩ init(φ1) /= ∅ necessarily implies that P |=must φ1. Likewise, init (P ) ∩ init (φ2) /= ∅ necessarily implies that P |=must φ2. From the induction hypothesis it follows that there exist Tφ1 , Tφ2 ∈ TN with init(Tφ1 )= init (φ1) and init (Tφ2 ) = init(φ2) such that init(P ) ∩ init (Tφ1 ) /= ∅ implies that P must pass Tφ1 and init(P ) ∩ init(Tφ2 ) /= ∅ implies that P must pass Tφ2 . From init(P ) ∩ (init (Tφ1 ) ∪ init(Tφ2 )) /= ∅ we derive that P must pass Tφ1 + Tφ2 .
The result then follows by taking Tφ ≡ Tφ1 + Tφ2 .
Let φ ≡ ⟨a⟩φ' and P ∈ PN.

If P |=
may
φ, then there exists P ' ∈ PN
a
such that P −−−→N
P ' and P ' |=may
φ'.

From the induction hypothesis it follows that there exists Tφ' ∈ TN such that P '
may pass Tφ' . Therefore P may pass a.Tφ' .

If P |=must
φ, then there exists P ' ∈ PN
a
such that P −−−→N
P ' and each such

P ' |=must φ'. From the induction hypothesis it follows that there exists Tφ' ∈ TN
such that each such P ' must pass Tφ' . Therefore P must pass a.Tφ' .
The result then follows by taking Tφ ≡ a.Tφ' .	 
Proof of Thm. 3.7: A straightforward consequence of the one-to-one correspon- dence between tests in TN and formulas in MLT established by Lemma 3.5 and Lemma 3.6.	 
Proof of Lemma 4.2: We proceed by induction on the syntactical structure of
T ∈ TR,det:
Let T ≡ s and take φT ≡ true. Since for all P ∈ PP we have [true]]PT(P )= 1= 
prob(SC(P, s)), the result follows.
Let T ≡ T1 + T2 and P ∈ PP. In order to avoid trivial cases, assume init (P ) ∩

init (T ) /= ∅. So prob (SC(P, T )) = probc(P |init(T1 )) ·prob (SC(P, T1))+ probc(P |init(T2 )) ·
probc(P |init (T ))	probc(P |init (T ))
prob(SC(P, T2)). From the induction hypothesis it follows that there exist φT1 , φT2
∈ MLT,ind with init (φT1 ) = init(T1) and init(φT2 ) = init (T2) s.t. [φT1 ]]PT(P )
= prob(SC(P, T1)) and [φT2 ]]PT(P ) = prob(SC(P, T2)). Thus prob(SC(P, T )) =

probc (P |init(φT1 ))
probc (P |init(φT1 ∨φT2 ))
[[φT1 ]]
probc (P |init(φT2 ))
PT	probc (P |init(φT1 ∨φT2 ))
[[φT2 ]]
PT(P ). From T ∈

TR,det we derive that φT1 ∨ φT2 ∈ MLT,ind, hence the result follows by taking
φT ≡ φT1 ∨ φT2 .
Let T ≡ <a, ∗w>.T ' and P ∈ PP.	In order to avoid trivial cases, assume
init (P )∩init(T ) /= ∅. Then prob(SC(P, T )) =	Σ 	p	 ·prob(SC(P ',T ')).
P −−→P P '
From the induction hypothesis it follows that there exists φT ' ∈ MLT,ind such that [φT ' ]]PT(P ') = prob(SC(P ',T ')) for each P ' reachable from P via a. Thus

prob(SC(P, T )) =
a,p
p
probc(P |{a})
[[φT ' ]]PT(P '). The result follows by taking

P −−→P P '
φT ≡ ⟨a⟩φT ' .	 
Proof of Lemma 4.3: We proceed by induction on the syntactical structure of
φ ∈ MLT,ind:
Let φ ≡ true and take Tφ ≡ s. Since for all P ∈ PP we have prob(SC(P, s)) = 1 = [[true]]PT(P ), the result follows.
Let φ ≡ φ1 ∨ φ2 and P ∈ PP. In order to avoid trivial cases, assume init(P ) ∩
init (φ) /= ∅.	Then [φ]]PT(P ) = probc (P |init(φ1 )) · [[φ1]]PT(P ) + probc(P |init (φ2 )) ·

probc (P |init(φ))	probc (P |init(φ))
[[φ2]]PT(P ). From the induction hypothesis it follows that there exist Tφ1 , Tφ2 ∈
TR,det with init (Tφ1 )= init (φ1) and init (Tφ2 )= init (φ2) s.t. prob(SC(P, Tφ1 )) =

[[φ1]]PT
(P ) and prob(SC(P, Tφ2
)) = [φ2]]PT
(P ), so [φ]]
probc(P |init(Tφ1 ))
PT	probc(P |init (Tφ1 +Tφ2 ))

prob(SC(P, Tφ1
)) +	probc(P |init (Tφ2 ))
probc (P |init(Tφ1 +Tφ2 ))
prob (SC(P, Tφ2
)). From φ ∈ ML
T,ind we

derive that Tφ1 + Tφ2 ∈ TR,det, hence the result follows by taking Tφ ≡ Tφ1 + Tφ2 .
Let φ ≡ ⟨a⟩φ' and P ∈ PP. In order to avoid trivial cases, assume init(P ) ∩
init (φ) /= ∅. Then [φ]]PT(P )=	Σ 	p	 · [[φ']]PT(P '). From the induction
P −−→P P '
hypothesis it follows that there exists Tφ' ∈ TR,det such that prob(SC(P ', Tφ' )) = [[φ']]PT(P ') for each P ' reachable from P via a. Thus [φ]]PT(P )=	Σ 	p	 ·
P −−→P P '
prob(SC(P ', Tφ' )). The result follows by taking Tφ ≡ <a, ∗w>.Tφ' .	 
Proof of Thm. 4.4: A straightforward consequence of the one-to-one correspon- dence between classes of tests in TR,det differring only for the action weights and formulas in MLT,ind established by Lemma 4.2 and Lemma 4.3.	 
Proof of Lemma 5.2: We proceed by induction on the syntactical structure of
T ∈ TR,det:
Let T ≡ s and take φT ≡ true. Since for all P ∈ PM and θ ∈ (R>0)∗ we have [[true]]MT(P, θ)=1= prob(SC≤θ(P, s)), the result follows.

Let T ≡ T1 + T2, P ∈ PM, and θ ∈ (R>0)∗. In order to avoid trivial cases, assume
init (P ) ∩ init(T ) /= ∅ and θ ≡ t ◦ θ'. Then prob (SC≤θ(P, T )) = ratec(P |init(T1 )) ·
prob(SC≤t1 ◦θ' (P, T1)) + rate c(P |init(T )) · prob(SC≤t2 ◦θ' (P, T2)) where tj = t  +
( 	1	 − 	1	) for j ∈ {1, 2}. From the induction hypothesis
rate c(P |init(Tj ))	ratec(P |init (T ))
it follows that there exist φT1 , φT2 ∈ MLT,ind with init (φT1 ) = init (T1) and
init (φT ) = init (T2) such that [φT ]]MT(P, t1 ◦ θ') = prob (SC≤t ◦θ' (P, T1)) and
2	1	1
[[φT ]]MT(P, t2 ◦ θ')	=	prob(SC≤t ◦θ' (P, T2)).	Thus prob(SC≤θ(P, T ))	=

2
rate c(P |init(φT1 ))
ratec(P |init(φT1 ∨φT2 ))
[[φT1 ]]
MT(P, t1
2
θ')+	ratec(P |init(φT2 ))
ratec(P |init(φT1 ∨φT2 ))
[[φT2 ]]
MT(P, t2
θ').

From T ∈ TR,det we derive that φT1 ∨ φT2 ∈ MLT,ind, hence the result follows by taking φT ≡ φT1 ∨ φT2 .
Let T ≡ <a, ∗w>.T ', P ∈ PM, and θ ∈ (R>0)∗.	In order to avoid trivial

cases, assume init(P ) ∩ init (T ) /= ∅, θ ≡ t ◦ θ', and 	1	
c
≤ t.  Then

prob(SC≤θ(P, T )) =	Σ 	λ	 · prob (SC≤θ' (P ',T ')). From the induction
a,λ
P −−→M P '
hypothesis it follows that there exists φT ' ∈ MLT,ind such that [φT ' ]]MT(P ', θ')= 
prob(SC≤θ' (P ',T ')) for each P ' reachable from P via a. Thus prob (SC≤θ(P, T )) =

a,Σλ
rate (P |{a}) · [[φT ' ]]MT(P , θ ). The result follows by taking φT ≡ ⟨a⟩φT ' . 

P −−→M P '
Proof of Lemma 5.3: We proceed by induction on the syntactical structure of
φ ∈ MLT,ind:
Let φ ≡ true and take Tφ ≡ s. Since for all P ∈ PM and θ ∈ (R>0)∗ we have
prob(SC≤θ(P, s)) = 1 = [[true]]MT(P, θ), the result follows.
Let φ ≡ φ1 ∨ φ2, P ∈ PM, and θ ∈ (R>0)∗. In order to avoid trivial cases, as- sume init(P ) ∩ init (φ) /= ∅ and θ ≡ t ◦ θ'. Then [φ]]MT(P, θ) = ratec(P |init(φ1 )) ·
[[φ1]]MT(P, t1 ◦θ)+ ratec(P |init (φ2 )) ·[[φ2]]MT(P, t2 ◦θ) where tj = t +( 	1	 −
ratec(P |init(φ))	ratec(P |init (φj ))
	1	) for j ∈ {1, 2}.	From the induction hypothesis it follows that
c
there exist Tφ1 , Tφ2 ∈ TR,det with init (Tφ1 ) = init (φ1) and init (Tφ2 ) = init (φ2) such that prob (SC≤t1 ◦θ (P, Tφ1 )) = [φ1]]MT(P, t1 ◦ θ) and prob(SC≤t2 ◦θ (P, Tφ2 )) =

[[φ2]]MT
(P, t2◦θ). Thus [φ]]
rate c(P |init(Tφ1 ))
MT	ratec(P |init (Tφ1 +Tφ2 ))
·prob (SC≤t1 ◦θ
(P, Tφ1
))+

ratec(P |init(Tφ2 ))
ratec(P |init(Tφ1 +Tφ2 ))
prob(SC≤t2 ◦θ
(P, Tφ2
)). From φ ∈ MLT,ind
we derive that

Tφ1 + Tφ2 ∈ TR,det, hence the result follows by taking Tφ ≡ Tφ1 + Tφ2 .
Let φ ≡ ⟨a⟩φ', P ∈ PM, and θ ∈ (R>0)∗. In order to avoid trivial cases, as- sume init (P ) ∩ init (φ) /= ∅, θ ≡ t ◦ θ', and 	1	 ≤ t. Then [φ]]MT(P, θ)= 

a,Σλ
	λ	 · [[φ']]MT(P ', θ'). From the induction hypothesis it follows that

P −−→M P '
there exists Tφ' ∈ TR,det such that prob(SC≤θ' (P ', Tφ' )) = [φ']]PT(P ', θ') for each
P ' reachable from P via a, so [φ]]MT(P, θ)=	Σ 	λ	 ·prob(SC≤θ' (P ', Tφ' )).
a,λ
P −−→M P '
The result follows by taking Tφ ≡ <a, ∗w>.Tφ' .	 

Proof of Thm. 5.4: A straightforward consequence of the one-to-one correspon- dence between classes of tests in TR,det differring only for the action weights and formulas in MLT,ind established by Lemma 5.2 and Lemma 5.3.	 
