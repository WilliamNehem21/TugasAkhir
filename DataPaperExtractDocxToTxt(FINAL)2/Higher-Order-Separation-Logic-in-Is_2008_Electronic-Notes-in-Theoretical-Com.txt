

Electronic Notes in Theoretical Computer Science 218 (2008) 371–389
www.elsevier.com/locate/entcs

Higher-Order Separation Logic in Isabelle/HOLCF
Carsten Varming1 ,2 and Lars Birkedal3 ,4
Carnegie Mellon University	IT Univsersity of Copenhagen

Abstract
We formalize higher-order separation logic for a first-order imperative language with procedures and local variables in Isabelle/HOLCF. The assertion language is modeled in such a way that one may use any theory defined in Isabelle/HOLCF to construct assertions, e.g., primitive recursion, least or greatest fixed points etc. The higher-order logic ensures that we can show non-trivial algorithms correct without having to
extend the semantics of the language as was done previously in verifications based on first-order separation logic [2,20]. We provide non-trivial examples to support this claim and to show how the higher-order logic enables natural assertions in specifications. To support abstract reasoning we have implemented rules for representation hiding and data abstraction as seen in [1].
The logic is represented as lemmas for reasoning about the denotational semantics of the programming language. This follows the definitional approach common in HOL theorem provers, i.e., the soundness of our model only relies on the soundness of Isabelle/HOL [6].
We use our formalization to give a formally verified proof of Cheney’s copying garbage collector [4] using a tagged representation of objects. The proof generalizes the results in [2]. The proof uses an encoding of the separation logic formula this(h) to capture the heap from before the garbage collection and thus shows another novel use of higher-order separation logic.
Keywords: Copying Garbage Collection, Isabelle/HOL, Reliability, Separation Logic, Verification


Introduction
Separation logic [13,18] is a program logic for reasoning modularly about pointer- manipulating programs. Modular reasoning is achieved via the now well-known frame rule, expressed using the separating conjunction logical connective. Ori- ginally separation logic was devised for C-like languages and since then it has been extended to concurrent, higher-order, and object-oriented programming lan- guages [12,3,11,14]. In [1] higher-order separation logic was proposed. “Higher-

1 Email: varming@cmu.edu
2 Research supported in part by National Science Foundation Grants CCF-0541021, CCF-0429505 and by the FIRST Ph.D. school at the IT University of Copenhagen.
3 Email: birkedal@itu.dk
4 Research supported in part by the Danish Research Council (FNU Grant No. 272–07–9305)

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.022

order” here refers to the possibility of quantifying over assertion-level predicates, both in the assertion logic and in the specification logic. In loc. cit. it was proposed that higher-order separation logic would be useful for two main purposes: (1) to model and reason about data abstraction via existential quantification over hidden resource invariants, and (2) to ease formalizations of separation logic by having one general expressive logic in which it is possible to deﬁne predicates, etc., needed for applications. The first purpose (data abstraction) was sketched in loc. cit. and has proved useful in further investigations [11,7,15]. In this paper we investigate the second purpose (ease of formalization) by developing a formalization of higher- order separation logic in Isabelle/HOL and by applying the formalization to give a formal separation logic proof of Cheney’s copying garbage collector [4]. The form- alization uses Isabelle/HOLCF [10] which is defined in Isabelle/HOL [16]. The formalized separation logic is for a programming language with simple procedures and address arithmetic. The resulting proof of Cheney’s algorithm improves upon the proof in [2] qua the use of higher-order logic: In [2], following [20], the language of separation logic was retrofitted to express the correctness of Cheney’s algorithm, but here we can define the needed assertions directly in the higher-order logic. Moreover, the formalization deals properly with procedures; we found that early versions of [1] had left out a side-condition regarding the free variables of the post condition of procedure calls, which is made explicit here.
Even though the ease of formalization purpose was suggested in [1], no sugges- tions of how to actually achieve this goal in practice were included in loc. cit. Here we achieve the goal by including the higher-order logic of Isabelle/HOL in the assertion language of higher-order separation logic. This lets the user use other packages developed in Isabelle/HOL to define assertions, including packages for least or greatest fixed points, total functions, etc. In particular, we show in this paper how the approach is used in the verification of Cheney’s algorithm. The formalization is approximately 15000 lines of definitions and proofs. The proof of Cheney’s algorithm takes up an additional 7500 lines.

Outline and overview of the technical development
We now give a brief overview of the technical development. In Section 2.1 we define the syntax of our programming language using a deep embedding of commands (by defining a new inductive type of commands) and a shallow embedding of expressions.
In Section 2.2 we present our Isabelle/HOL definition of the denotational
semantics of the programming language. The definition makes use of the imple- mentation of basic domain theory in Isabelle/HOL[10] (Isabelle/HOLCF). We also define the frame property expressing that commands behave locally [13], as needed for the verification of the frame rule, and prove that the meaning of any command satisfies the frame property.
In section 3 we present our shallow embedding og higher-order separation logic in Isabelle/HOL. We have chosen to use a shallow embedding since it makes it easy to use Isabelle/HOL to define new assertions, and as the logical implications in

the rule of consequence can be defined directly as implications in Isabelle/HOL. Using the shallow embedding of the assertion logic of higher-order separation logic, we then define validity of separation-logic triples. The proof rules of higher-order separation logic [1] are then formalized in Isabelle/HOL by means of a series of lemmas, stating essentially that if the triples in the antecedent of the rule are valid then also the triple in the conclusion is valid.
In Section 4 we present a couple of reasoning examples in the formalized higher- order separation logic. As already mentioned, our main example is a formal proof of Cheney’s copying collector, but we also show an example of formal reasoning about a copying routine for trees and dags. We explain how the invariants of Cheney’s algorithm can be defined in the implementation of higher-order separation logic and outline its correctness proof. The proof is a clear improvement over the one in [2]
— all the necessary predicates can be defined in the logic, rather than extending the logic in an ad-hoc fashion as in [2]. Moreover, we avoid having to build up a mathematical representation of the heap in order to relate the current heap to the old heap as in [2], by making use of a (definable) predicate this(h) that holds only when the current heap can be described by h.
Finally, in Section 5 we discuss related work and conclude in Section 6.

Semantic Model of Programming Language
In this section we present our programming language model, as implemented in Isabelle/HOL. The programming language is a first-order imperative language with simple procedures, i.e., a language with a store (sometimes called a stack) and a heap. The language allows for full address arithmetic and has suitable commands for manipulating the heap, as is standard in separation logic [13,18]. Procedures are simple in that they can only refer to their formal parameters, not to global variables.
Syntax
Our model of the language uses a shallow embedding of expressions and a deep embedding of commands. This enables us to focus on the separation logic for com- mands. Of course, a real programming language will have a proper syntax for expression; the idea is that any such expression can easily be given meaning in our shallow embedding, and thus modeling its syntax only complicates the implementa- tion and the uses thereof. In this presentation we use the syntax commonly seen in presentations of separation logic. (This makes the presentation easier to read, but as many of the symbols are already used in Isabelle/HOLCF and cannot be over- loaded, the syntax of this presentation and the syntax used in our implementation are slightly different.)
Expressions
The set S of stores is a the set of functions from V, an infinite set of variables, to the set Z of integers. We define an equivalence relation on stores −  − − such that

s  V s' witnesses that s and s' agrees on V ⊆ V.
An expression consists of a pair (f, V ) where f is a function from stores S to values and V is a set, containing the free variables of the expression. An expression (f, V ) is well-defined if and only if V is finite and ∀s, s' ∈ S. s  V s' ⊃ f s = f s'. This complication enables us to reason about non-aliasing substitutions on com- mands. We say that an expression is an α-expression if and only if the expression evaluates to a value of type α. We model α-expressions in Isabelle/HOL by a new type α exp, defined as the set
α exp = {(f, V ): (S → α) × (V set) | ∀s, s' ∈ S. s  V s' ⊃ f s = f s'}.
We define two operations on α-expressions: evaluating an expression in a store ev − − : α exp → S → α, and getting the free variables of an expression free(−): α exp → V set.
We have overloaded constants for numbers and arithmetic operations, extend- ing them to appropriate expression types. We have also defined a constant trivExp : V → Z exp for encoding program variables (i.e., variables whose value is given by the store) as expressions, and some constants for comparisons between integer expres- sions. We have also defined a constant funExp : (α → β) → α exp → β exp that lifts a function of type α → β to a function defined on α expressions. This expression is quite useful for defining interesting assertions, but if used in the program text, care must be taken to avoid unimplementable expressions. In our program text for Cheney’s collector this constant is used to form expressions out of the representation functions (see section 4.1).
Commands
The commands are given by this grammar:
c :: = skip | v:=e | v:=le | e1:=ue2 | c1;c2 | if b then c1 else c2 | while b do c
| v := cons [e1,. .., en] | dispose e | newvar v in c | call name([x1, ... , xn]; [y1, ... , ym])
2name1 = λ[x11 ,. .. , x1n ], [y11 , ... , y1m ]. c1 3
| let 64	.	75 in c end
namek = λ[xk1 ,. .., xkn ], [yk1 ,. .. , ykm ]. ck
Most constructs are standard: v:=e is assignment, e1:=ue2 updates the heap loc- ation pointed to by e1 with the value of e2, v:=le looks up the location pointed to by e in the heap and assigns the resulting value to v, v := cons [e0,... , en] stores the values of [e0,... , en] at an address a and assigns a to v, dispose e disposes the location pointed to by e. Procedures can be defined using a let construct, and each procedure has a list of modifiable variables followed by a list of read-only variables. Having a list of modifiable variables enables a procedure to “return” multiple values from a procedure call.
We define two sets of free variables for commands: the set mod(c) of modifiable variables, and the set read(c) of read variables.
mod(call name([x1,. .., xn]; [e1,. .., em])) = {x1, ... , xn},
mod(newvar v in c)= mod(c)\{v},
mod(v:=e)= {v},
read(call name([x1,. .., xn]; [e1,. .., em])) = {x1, ... , xn}∪ `Sm  free(ei)´,
read(newvar v in c)= read(c)\{v},
read(v:=e)= free(e),

and so forth. A procedure body may only mention the formal parameters of the procedure. Hence the set of modifiable variables is a superset of the variables that may be assigned to by a command, and the set of read variables is a superset of the variables a command may depend on. In the rest of this paper we will assume commands are well-formed, i.e., the formal parameters of a procedure are all distinct, a procedure assigns only to modifiable parameters, a procedure mentions only its formal parameters, in a call to a procedure the actual modifiable parameters are all distinct, and the two lists of actual parameters have the same lengths as the two lists of formal parameters. We define a constant goodCmd : (names → (N0 × N0) option)× Cmd → B such that if Γ encodes the length of the parameter lists for the free procedure names in C then goodCmd (Γ,C) asserts the well-formedness of C.
Semantics
Heaps (ranged over by h) are partial functions from the natural numbers to integers (represented in Isabelle/HOL as terms of type N0 → Z option) and states are pairs of stores S and heaps H.
Expressions
Expressions are modeled by their meanings; thus we can either evaluate an expres- sion in a given store or get its free variables, as described in section 2.1.1.
Commands
The meaning of a command is defined relative to an environment providing meanings to the free procedure names in the command. An environment is a pair
(Θ,ζ) ∈ env = (names →c state discr →c state option set)×(names → (V list×V list))
of functions. In the above display we use the Isabelle/HOL package for basic domain theory: for a type α, α discr is the discretely ordered cpo, and for cpos α and β, the type α →c β denotes the continuous functions from α to β. The notation α option is used for the Isabelle/HOL type of values of the form None or Some(a), for a in α, and α set denotes the powerset type of α, ordered by set inclusion. The option type is used to capture the possibility of abortion. The meaning of the pro- cedure name n is (Θ n, ζ n), i.e., a continuous state transformation function, a list of formal modifiable variables, and a list of formal read-only variables. (The envir- onment consist of two functions only to make the encoding in Isabelle/HOLCF easier.) Given an environment (Θ,ζ) the meaning of a command is a triple:
((state discr →c state option set) × (V set × V set))
consisting of a continuous state transformation function, a set of modifiable vari- ables, and a set of read variables. (Notice that in Isabelle/HOL a triple of type α × β × γ is represented by the type α ×(β × γ).) The set of read variable may inter- sect with the set of modifiable variables, e.g., the meaning of v:=2 ∗ v both reads the value of v and modifies the store at v. We define two constants fr = λt. snd(snd(t)),

fm = λt. fst(snd(t)), to get the free read variables and the free modifiable variables from the meaning of commands.
To ease the definition of the meaning of a command we have defined a few Isabelle/HOL constants: up that lifts functions in state discr →c state option set to functions in state option set →c state option set, defined by
up g X =  x∈X case x of None ⇒ {None} | Some(x') ⇒ g x';
find that given a list of procedure declarations and a name will return the first procedure with that name or None if such a procedure isn’t present in the list, and funZip that given a function f and two lists l1, l2 of equal length, returns the function whose graph is the graph of f restricted to dom f \(set l1) union the zip of l1 and l2. Besides these constants we also make use of constants defined in the Isabelle/HOL library: nat that maps non-negative integers to natural numbers and negative integers to 0, int that map natural numbers to integers, set that maps lists to sets, override on that given two functions f, f ' : A → B and a set C ⊆ A gives the function that is f outside C and f ' on C, and Inv that given a set S and a function f such that S ⊆ dom f and f is injective on S, gives a function that maps f s to s for all s ∈ S.
A semantic substitution has four elements (f, M, g, R), a function f : V → V that maps modifiable variables, e.g. members of M , to modifiable variables, a function g : V → Z exp that maps read variables, e.g. members of R, to expressions, and two sets M and R. A substitution (f, M, g, R) is well-defined if and only if
∀v ∈ M. g v = trivExp (f v)	∀v ∈ M ∪ R. free(g v) ∩  x∈M \{v}{f x} = {}, and can be applied to a command c if and only if M is a superset of fm(c) and R is a superset of fr(c).
We write csubst σ c for the result of applying a substitution (f, M, g, R) to a command c and define its meaning to be:
(λ(s, h). up
(λ(s', h'). {Some(λv. if v ∈  v∈fm(c){f v} then s' (Inv (fm(c)) f v) else s v, h')})
(fst(c) (λv. ev (g v) s, h)),  v∈fm(c){f v},  v∈fr(c) free(g v)).
Besides the constants defined above we also define a constant: procsubst that given a list of formal modifiable parameters, a list of actual modifiable parameters, a list of read-only parameters, and a set of variable names to avoid, will give a substitution σ and a list of variables rl such that σ substitutes the actual modifiable parameters for the formal modifiable parameters and rl for the formal read-only parameters. The elements of rl are, if possible, chosen outside the set of variables to be avoided, and ensures that the particular choice of names for the formal parameters doesn’t limit the set of variables that can be used as actual modifiable parameters.
The meaning of commands is then given by Figure 1. Notice we have given the read only parameters of procedure calls a call-by-value semantics, and that we never allocate heap space at address 0. We also notice that the modifiable (resp. read) variables of the meaning of a command coincides with the modifiable (resp. read) variables derived from the syntax in sections 2.1.2.


[[skip]]c(Θ,ζ)= (λ(s, h). {Some(s, h)}, ∅, ∅)
[[v:=e]]c(Θ,ζ)= (λ(s, h). {Some(s(v '→ (ev e s)), h)}, {v}, free(e))
[[c1;c2]]c(Θ,ζ)= (λ(s, h). up (fst([[c2]]c(Θ,ζ))) (fst([[c1]]c(Θ,ζ))(s, h)),
fm([[c1]]c(Θ,ζ)) ∪ fm([[c2]]c(Θ,ζ)),
fr([[c1]]c(Θ,ζ)) ∪ fr([[c2]]c(Θ,ζ)))
[[while b do c]]c(Θ,ζ)= (μF. λ(s, h). if ev b s then up F (fst([[c]]c(Θ,ζ))(s, h)) else {Some(s, h)},
fm([[c]]c(Θ,ζ)), fr([[c]]c(Θ,ζ)) ∪ free(b))
[[if b then c1 else c2]]c(Θ,ζ)= (λ(s, h). if ev b s then [[c1]]c(Θ,ζ)(s, h) else [[c2]]c(Θ,ζ)(s, h),
fm([[c1]]c(Θ,ζ)) ∪ fm([[c2]]c(Θ,ζ)),
fr([[c1]]c(Θ,ζ)) ∪ fr([[c2]]c(Θ,ζ)) ∪ free(b))
[[dispose e]]c(Θ,ζ)= (λ(s, h). case h(nat(ev e s)) of None ⇒ {None}
| Some(n) ⇒ {Some(s, h(n '→ None))}, ∅, free(e))
[[e1:=ue2]]c(Θ,ζ)= (λ(s, h). case h(nat(ev e1 s)) of None ⇒ {None}
| Some(n) ⇒ {Some(s, h(nat(ev e1 s) '→ ev e2 s))}, ∅, free(e1) ∪ free(e2))
[[v:=le]]c(Θ,ζ)= (λ(s, h). case h(nat(ev e s)) of None ⇒ {None}
| Some(n) ⇒ {Some(s(v '→ n), h)}, {v}, free(e))
[[newvar v in c]]c(Θ,ζ)= (λ(s, h). up (λ(s', h').{Some(s'(v '→ s(v)), h')})
(up (fst([[c]]c(Θ,ζ))) (S {Some(s(v '→ n), h)})),

[[v := cons [e1,. .., en]]]c(Θ,ζ)= (λ(s, h). S
fm([[c]]c(Θ,ζ))\{v}, fr([[c]]c(Θ,ζ))\{v})
mif ∀i. m < i ≤ m + n ⊃ h(i)= None

then {Some(s(v '→ int(m + 1)),
h(m +1 '→ ev e1 s,... ,m + n '→ ev en s))}
else ∅, {v}, S0<i≤nfree(ei))
[[call p(x; e)]]c(Θ,ζ)= let (σ, rl') = procsubst (fst(ζ p)) x (snd(ζ p))
(set(fst(ζ p)) ∪ set(snd(ζ p)))
in (λ(s, h). up (λ(s', h'). {Some(override on s s' (set x), h')})
(fst(csubst σ (Θ p, set (fst(ζ p)), set (fst(ζ p)) ∪ set (snd(ζ p))))
(funZip s rl' (map (λe. ev e s) e), h)), set x, set x ∪ [ free(e))
e∈e
[[let l in c end]]c(Θ,ζ)= let vars = λp. case find l p of None ⇒ ζ p | Some(c', ml, rl) ⇒ (ml, rl)
in [[c]]c(μΘ'. λp. case find l p of None ⇒ Θ p
| Some(c', ml, rl) ⇒ fst([[c']]c(Θ', vars)), vars) Figure 1. Language Semantics
The semantics satisfies two important properties. A consistency property, ex- pressing how the semantics of a command relates to its modifiable and readable variables, and the frame property.
Definition 2.1 A set of states S : state option set is less than another set of states
S' on a set V ⊆ V (written S ≤V S'), if and only if
∀σ ∈ S. case σ of None ⇒ None ∈ σ' | Some(s, h) ⇒ ∃s', h'. Some(s', h') ∈ S' ∧ s  V s' ∧ h = h'.
Definition 2.2 A set of states S : state option set is smaller on the V part of the store than another set of states S' (written S ŒV S'), if and only if
∀σ ∈ S. case σ of None ⇒ true | Some(s, h) ⇒ ∃s', h'. Some(s', h') ∈ S' ∧ s  V s'.
We define the consistency property wb : ((state discr →c state option set) ×
V set × V set) → B by letting wb c mean
∀s, s', h. s  fm(c)∪fr(c) s' ⊃ fst(c) (s, h) ≤fm(c) fst(c) (s', h) ∧ fst(c) (s, h) ŒV\fm(c) {Some(s, h)}.



T = {h | true}	emp = {λx. None}
pure b = {h | b}		∀ P = {h | ∀x : α. h ∈ P x} P −∗ Q = {h | ∀h1. h⊥h1 ∧ h1 ∈ P ⊃ h ∈ Q}	P ⊃ Q = {h | h ∈ P ⊃ h ∈ Q}
i '→ i' = {h | h (nat(i)) = Some i' ∧ i > 0 ∧ ∀j. j /= i ⊃ h j = None}
P ∗ Q = {h | ∃h0, h1. h = h0  h1 ∧ h0⊥h1 ∧ h0 ∈ P ∧ h1 ∈ Q}
Figure 2. Separation Logic Constants
Lemma 2.3 For any command C and any environment (Θ,ζ) satisfying that, for every free procedure name n in C, we have wb(Θ n, set (fst(ζ n)), set (snd(ζ n))), it holds that wb [[C]]c(Θ,ζ).
Lemma 2.3 essentially shows that a command C may only change a store on the modifiable variables of C. And if C is executed from (s, h) and s and s' agrees on the free varaibles of C, then there exists an execution from (s', h) such that the two resulting stores match on the modifiable variables and the two resulting heaps are equal.
Definition 2.4 We say two heaps h, h' are disjoint (written h ⊥ h') if and only if
∀n, j. (h n = Some(j) ⊃ h' n = None) ∧ (h' n = Some(j) ⊃ h n = None). Given two heaps h, h', let h  h' be the heap
h h' = λn. if (∃n'. h n = Some(n')) then h n else h' n.
We define the frame property as follows. Let fp : (state discr →c state option set) →
B be the predicate such that fp f means
∀s, s', h1, h2. h1 ⊥ h2 ⊃ (None ∈ f (s, h1  h2) ⊃ None ∈ f (s, h1)) ∧
(Some(s', h') ∈ f (s, h1  h2) ∧ None ∈/ f (s, h1) ⊃
∃h3. Some(s', h3) ∈ f (s, h1) ∧ h' = h3  h2 ∧ h3 ⊥ h2).
Lemma 2.5 (Frame Property) For any command C and any environment (Θ,ζ) such that for every free procedure name n in C, the frame property fp (Θ n) holds, we have that the frame property fp (fst([[C]]c(Θ,ζ))) holds.

Higher-Order Separation Logic
We define a shallow embedding of higher-order separation logic in Isabelle/HOL. Recall that predicates in higher-order separation logic are subsets of heaps. A shallow embedding enables us to use the meta-logic to define predicates. Thus to model separation logic we give suitable inhabitants of the type H set and define constants with these meanings.
Definition 3.1 Let the following constants be defined with meanings given in Fig- ure 2.

As standard in higher-order logics, the existential quantifier is definable by:

∃ − : (α → H set) → H set	∃P = ∀λQ : H set. ((∀λx : α. (P x ⊃ Q)) ⊃ Q).
The above definitions of quantifiers satisfy the following expected properties:
∀P =  x P x	∃P =  x P x
To define the rule for allocation it is convenient to have an array predicate. Thus we let − '→l − : Z → Z list → H set be defined by primitive recursion on its second argument: i '→l [] = emp and i '→l (i'#ir) = (i '→ i') ∗ (i +1 '→l ir). (−#− is Isabelle/HOL syntax for the cons operation on lists).
In Isabelle/HOL we can introduce special syntax for binding operators and thus given a lambda abstraction λx : α. P we get syntactic translations: ∀ (λx : α. P )= 
∀x : α. P and ∃ (λx : α. P )= ∃x : α. P .
Assertions
Assertions are functions of type A = S → H set. To make it easy to keep track of the free program variables of an assertion, we have defined suitable constants, lifting the constants from Definition 3.1 to assertions. This makes it easier to keep track of which program variables an assertion depends upon and is useful because many separation logic rules have side-conditions of the kind: “variable x must not occur free in assertion F .” We encode such side-conditions using a constant fv : A → V set → B such that fv F V if and only if ∀s, s'. s  V s' ⊃ F s = F s', i.e., the function F only depends on the values of the variables V in the store.
Validity
We encode the following partial correctness property as the meaning of the constant:
— ▶ {−} − {−} : env → (S → H set) → Cmd → (S → H set) → B.
Definition 3.2 The partial correctness formula (Θ,ζ) ▶ {P } C {Q} holds iff, for all free procedure names n in C, (Θ n, ζ n) is well-behaved in the sense of Lemma 2.3 and satisfies the frame property, C is well-formed as described in Section 2.1.2, and for all stores s ∈ S and heaps h ∈ P s, fst([[C]]c(Θ,ζ))(s, h)

doesn’t abort, i.e., None ∈/
fst([[C]]c(Θ,ζ))(s, h), and for all stores s' and heaps

h', if C executed in the state (s, h) terminates with (s', h') then h' ∈ Q s', i.e.,
Some(s', h') ∈ fst([[C]]c(Θ,ζ))(s, h) ⊃ h' ∈ Q s'.
We prove a number of rules sound with respect to this definition. The rules fall in two categories: primitive rules and structural rules. The primitive rules for heap manipulating commands are tight, i.e., the pre- and post-condition specifies only the footprint of the command. The structural rules can be applied anywhere in a proof and bridge the gap between the tight primitive rules and complicated specifications. The frame rule and the rule of consequence are the most profound structural rules, but more rules comes in handy, especially a rule for introducing existential quantifiers.
By combining primitive and structural rules we can get a set of very useful rules. As an example of this technique we can prove the following specification for looking

up values in the heap: Given arbitrary functions f, q, r : Z exp → A such that v is not free in e, and for all x, v is not free in f x, and for all x, q x and r x do not depend on the value of v:
(Θ,ζ) ▶ {∃e'. (e '→ f e' ∗ r e') ∧ q e'} v:=le
{∃e'. pure (trivExp v = f e') ∧ e '→ trivExp v ∗ r e' ∧ q e'}.
The proof uses a tight rule for lookup, the rule of consequence, the frame rule, and the fact that we can factor out strictly exact parts of a formula, as expressed by the following lemma.
Lemma 3.3 Assuming R is strictly exact (i.e., for all heaps h0, h1 and stores s, if
h0 ∈ R s and h1 ∈ R s then h0 = h1) then (P ∧ (Q ∗ R)) ⊃ (R ∗ (R −∗ P ∧ (Q ∗ R))).
3.3  Procedures
The environment in the definition of validity is meant to capture the meaning of procedures. This could potentially complicate reasoning using our rules, but it doesn’t have to. If a program doesn’t introduce or call procedures the proof will make no assumptions about the environment, and thus we can universally quantify over it. If the program does use procedures then we want to make the interaction between environments as simple as possible. We do this by introducing a constant
va : env → (name → (V list × V list × (A × A) set)) → B
that captures the pre- and post conditions we will assume of the procedures in scope. This constant relates a given environment to a set of pre- and post conditions a procedure satisfies, and to the formal parameters of the procedure. To make it clear why the environment doesn’t complicate proofs we give a stylized and simplified version of the rule for let declarations:
va Γ Ctx =⇒  Γ', va Γ' [Ctx|n '→ (x, y, {(P, Q)})] =⇒ Γ' ▶ {Pc} c {Qc} 
va Γ Ctx =⇒  Γ', va Γ' [Ctx|n '→ (x, y, {(P, Q)})] =⇒ Γ' ▶ {P } cn {Q} 

va Γ Ctx =⇒ Γ ▶ {Pc} let n(x; y)= cn in c end {Qc}
where =⇒ is Isabelle/HOLs entailment on the meta-level. The rule assumes that for all fresh environments Γ' you can produce a proof of the client and a proof of the procedure body and the proofs may use the current assumptions about pre- and post conditions of procedures. As Γ' is a parameter it only takes up one symbol in a proof, and thus the environments doesn’t complicate the use of the logic. The introduction of the constant va in the Isabelle/HOL context enables us to forget about it until either we have a let declaration or a procedure call.
The meaning of va (Θ,ζ) Ctx is: for every procedure name n, assuming Ctx n = (ml, rl, pqs) then ζ n = (ml, rl), the variables in ml @ rl are all distinct, and (Θ n, ζ n) is well-behaved in the sense of Lemma 2.3 and satisfies the frame property. Moreover, for every pair of assertions (P, Q) ∈ pqs we must have that (P, Θ n, Q)

satisfies the partial correctness properties set out in the definition of validity, i.e., if P holds of a given heap and store then the procedure, executed in that state, does not abort, and if the procedure terminates then Q holds of the resulting heap and store.
Now that we have made assumptions about procedures concrete via va, we get a method for changing the assumptions by ensuring that the new assumptions hold of the same environment:
Lemma 3.4 Assuming va Γ Ctx and Ctx n = (ml, rl, pqs) and for every (P, Q) ∈ pqs', Γ ▶ {P } call n(ml; rl) {Q}, then va Γ Ctx' where Ctx' is Ctx updated with (n, (ml, rl, psq')).
Notice how Lemma 3.4 enables us to use any structural rule to change the assumptions about procedures.
The rule for procedure calls is then:
va Γ Ctx  distinct x  (ml, rl, pqs) ∈ Ctx n  (P, Q) ∈ pqs  |ml| = |x|  |rl| = |y|  fv Q FQ
∀e ∈ set y. free(e) ∩ set x = {}  FQ ∩ (set x\set (ml@rl)) = {}	,
Γ ▶ {lsubst P (ml@rl) ((map trivExp x)@y)} call n(x; y) {lsubst Q (ml@rl) ((map trivExp x)@y)}
where lsubst : A → V list → Z exp list → A, and lsubst P vl es performs the denotational substitution specified by the zip of vl and es on P .
To support modularity and data abstraction (the first purpose of higher-order separation logic mentioned in the Introduction), we have a derived rule for let declarations that lets the assertions for the procedures be functions f of type α → A. The procedure bodies are then verified using f P for some P : α, and the client is verified using f x for a fresh parameter x : α. Hence if α is the type A or H set a group of procedures may share information about a piece of the heap but the information is kept secret from the client. This enables us to build modules as collections of procedures and abstract away their internal representations of data structures, as suggested in [1].

Examples
Cheney’s Garbage Collector
We now give an overview of our formalization of Cheney’s garbage collection al- gorithm [4]. As mentioned in the Introduction, the formalization and the proof improves upon the one in [2], which used a retrofitted version of first-order separa- tion logic with additional basic predicates, etc., tailored to this particular algorithm. To ease the proof in [2], the authors simplified the algorithm to a representation that only allows pointers to pairs, and their extensions to the logic relied heavily on this representation, thus simplifying both the program and the proof. Our proof fits entirely in higher-order separation logic and makes use of Isabelle/HOL’s library for defining functions over lists, finite sets, etc. We discharge the actual layout of records in memory by assuming that we are given two representation functions that given a tag will tell us how big a record is and which fields contain pointers. It

proved valuable to identify a fraction of the program as a copying routine and give a proof of its specification separately from the main proof. The main proof then uses the frame rule to utilize the copying routine.

Representation
We assume that we are given two functions len : Z → N0 option and isptr : Z → N0 → B that gives the representation of records. Each record is a block of continuous memory with a tag at its smallest address and size given by the len function, i.e., len t is Some(l) if and only if t is a proper tag and the record it represents has length l. Given a proper record, i.e., a record with a tag t such that len(t)= Some(l) for some l, for all i such that 0 < i < l, isptr t i if and only if the i’th field in the record is a pointer. We require ¬isptr t 0, for all t. We reserve the tag −1 for the garbage collector and we don’t allow skewed sharing between records. We disallow dangling pointers, and pointers not pointing to the least address of a record. That the records doesn’t contain dangling pointers can be formalized as a closure property of a set of pointers:
Definition 4.1 A set P of pointers is closed if and only if for every p ∈ P , any pointer in the record pointed to by p is in P .

Notice that if P is closed and is a subset of the domain of the heap then every pointer in every record must be a member of P , and thus every pointer points to a record.
We say that a set P of pointers determines a heap if every pointer p ∈ P points to a record in the heap and P is closed.
The main complications dealing with closed sets of pointers stems from the fact that if you take away a single pointer from the set, it may not be closed afterwards, i.e., our proofs by induction on finite closed sets of pointers have required some generalizations to heaps with dangling pointers.
In the following sections we need a few Isabelle/HOL constants: the of type α option → α that is undefined on None and given Some(e) will return e, −!− of type α list → N0 → α such that if n is less than the length of l then l!n will return the n’th element in l and be undefined otherwise, −≺− such that given two functions f, f ' : α → β option, f ≺ f ' states that if f a = Some(b) then f ' a = Some(b) for all a, b.

Heap invariant
Given the representation assumptions above we need an appropriate heap invariant. Disallowing skewed sharing enables us to express every record by a precise formula and then use the separating conjunction to glue it all together. As the separating conjunction is associative and commutative this approach will give a unique set of heaps.
The heap invariant hinv isptr len root can be expressed in Isabelle/HOL by:

hinv isptr len root = ∃P. pure (funExp(λr. nat(r) ∈ P ∧ finite P ) root) ∧
(λs. Finite Set.fold (op ∗) f {empty} P )
where f is the function
f p = ∃t, il. int(p) '→l (t#il) ∧
pure (len t = Some(length (t#il)) ∧ length il > 0 ∧ t /= −1 ∧
∀i. i < length il ∧ isptr t (i + 1) ⊃ il!i > 0 ∧ il!i ∈ P )
The meaning of Finite Set.fold op f u S is to apply f to every element of S and then fold op over the result starting with u. This is part of the Isabelle/HOL library. Intuitively, hinv isptr len root is saying that there exists a set of pointers P such that P is finite, the value of the expression root is in P , every pointer p in P points to a well-defined record, i.e., it has a tag t different from −1, the heap at p,... ,p + len t − 1 is defined and every pointer in the record is a member of P , i.e., P is closed and determines a heap.
Correctness
The main correctness criteria of a garbage collector is that it preserves the structure of the heap, i.e., the old heap and the new heap should be isomorphic, and it should preserve the heap invariant. To make this precise we define what it means to have a heap isomorphism.
Definition 4.2 [Heap Isomorphism] A function φ is a heap isomorphism between two heaps oldh and h, on a set of pointers ALIV E if and only if
∀p ∈ ALIV E. ∃t. oldh p = Some(t) ∧ t ∈ dom len ∧ p ∈ dom φ ∧
∀i. i < the(len t) ⊃ p + i ∈ dom oldh ∧ (¬isptr t i ⊃ h(the (φ p)+ i)= oldh (p + i))
∧ (isptr t i ⊃ h(the (φ p)+ i)= option map int φ(nat(the (oldh (p + i))))).
We say two heaps h, h' are heap isomorphic if and only if there exists a heap isomorphism φ between h and h'.
Reachability
Cheney’s collector only touches the part of the heap that is reachable from the root pointer. Separation logic prides itself as a logic of local reasoning and as such the proof should only deal with the reachable part of the heap. Hence we define a predicate reachable : (Z → N0 → B) → (Z → N0 option) → Z → N0 list → H → Z option such that reachable isptr len r nl h = Some(p) if and only if p is reachable from r in h by following pointers determined by nl (in the i’th step follow the pointer in the nl!i’th field). We also define a constant reach : (Z → N0 → B) → (Z → N0 option) → Z → H → N0 set with the meaning
reach isptr len r h = {p | ∃nl. reachable isptr len r nl h = Some(p) ∧ p > 0}.
Lemma 4.3 If the heap invariant holds for the set of pointers P and r ∈ P then P can be divided into two disjoint sets P1, P2 such that P1 is closed, contains r, every pointer in P1 is reachable from r, and no pointer in P2 is reachable from r. Hence the set of pointers P can be split into a set of pointers determining the part of the heap reachable from r and a set of pointers pointing to garbage.

The division of pointers into two disjoint sets expressed in the above lemma lets us frame in the correctness proof of the collector next to the garbage to get a complete scenario.
Isomorphisms
Cheney’s collector builds an isomorphism between heaps which we will express as a bijection between sets of pointers.
Definition 4.4 We define a constant Iso : α set → β set → (α → β option) → B
with the meaning:
Iso A B φ = dom φ = A ∧ ∀a ∈ A. (∃b ∈ B. φ a = Some(b)) ∧ ∀b ∈ B. ∃!a ∈ A. φ a = Some(b)
If Iso A B φ we say φ is an isomorphism from A to B (written φ : A → B).
Notice that from Iso A B φ and φ a = Some(b) we can prove a ∈ A and b ∈ B. Given an isomorphism φ : A → B and a b ∈ B there is a unique a such that φ a = Some(b). We define a constant InvIso : α set → (α → β option) → β → α option such that if b ∈ B then InvIso A φ b is Some(a) and if b ∈/ B then InvIso A φ b = None. Notice that if b ∈ B then a must be a member of A. It turns out we can define this constant using the Inv : α set → (α → β) → β → α constant from the Isabelle/HOL library.
InvIso A φ b = if ∃x. φ x = Some(b) then Some((Inv A (λx. the (φ x))) b) else None
Invariants of the collector
The loop-invariants of the collector is a conjunction of a pure part and a precise part. We start with the precise part. The invariant should relate the current heap with the heap as it was before the garbage collection. In our formalization of higher- order separation logic we encode a formula “this(h)” that holds only for the heap h. We use that to get a hold on the heap from before the execution of the collector and the following formulas to relate the current heap to the old heap.
Definition 4.5 Let gh : (N0 → B) → (Z → Z option) → N0 → N0 → N0 → H → (Z list) option be a constant such that gh ptest f p l 0 h returns the record pointed to by p of length l from the heap h, with f applied to every pointer in the record. gh is formally defined by primitive recursion on the length l.
Definition 4.6 Let hs : (Z → N0 → B) → (Z → N0 option) → N0 set → N0 set → (N0 → N0 option) → (N0 → N0 option) → H → H set be an Isabelle/HOL constant with the meaning:
hs isptr len P P ' g f h = Finite Set.fold (op ∗) Θ {empty} P
whereΘ is the function
λp. ∃il, t. int(p) '→l (t#il) ∧ pure ∃l, on. len t = Some(l) ∧ f n = Some(on) ∧
gh (isptr t) (λi. option map int (g (nat(i)))) on l 0 h)= Some(t#il) ∧
l > 1 ∧ ∀i. i < l − 1 ∧ isptr (i + 1) ⊃ il!i > 0 ∧ nat(il!i) ∈ P '.

Hence hs isptr len P P ' g f h states that every pointer p in P points to a record ob such that every pointer in the record is in P '. And the heap h has an equivalent record at f p such that if we map the pointers of that record with g we get ob.
Notice that if f and g are the everywhere defined identity functions (λn. Some(n)) then hs isptr len P P ' g f h states that the current heap agrees with h on the records determined by P .
Definition 4.7 Let fw : (Z → N0 option) → (N0 → N0 option) → N0 set → H →
H set be an Isabelle/HOL constant with the meaning:
fw len f P h = Finite Set.fold (op ∗) Θ {empty} P
whereΘ is the function
λp. ∃p', t, rest. int(p') '→l (−1#p'#rest) ∧ pure (f p = Some(p') ∧ p' > 0 ∧
h p = Some(t) ∧ t ∈ dom len ∧ Some(length rest + 2) = len t).
Hence fw len f P h states that for every pointer p in P , p points to a record with tag −1 anda pointer f p. Moreover, the size of the record is given by the tag found at p in the heap h.
Now that we have the proper heap predicates we can state Lemma 4.3 precisely:
Assuming h ∈ hinv isptr len root s and ∀t. ¬isptr t 0 then
h ∈ ∃P, P ', h, h'. pure (funExp(λr. λr. nat(r) ∈ P ∧ finite P  ∧ finite P ' ∧
P ∩ P ' = {} ∧ P = reach isptr len r h ∧ r > 0) root) ∧
((λs. {h}∧ hs isptr len P P (λn. Some(n)) (λn. Some(n)) h) ∗
(λs. {h'}∧ hs isptr len P ' (P ∪ P ') (λn. Some(n)) (λn. Some(n)) h')).
Notice the encoding of this(h) as {h}.
Assuming we have sets of pointers QUEUE, FW, UNFORW, DONE, ALIV E, an isomorphism φ, an old heap oldh, and an integer list d and that ALIV E = FW ∪ UNFORW then the impure part of the outer loop invariant is, given a store s:
hs isptr len UNFORW ALIV E (λx. Some(x)) (λx. Some(x)) oldh ∗
hs isptr len DONE (DONE ∪ QUEUE) φ (InvIso FW φ) oldh ∗ hs isptr len QUEUE ALIV E (λx. Some(x)) (InvIso FW φ) oldh ∗ fw len φ FW oldh ∗ s freep '→l d,
which informally means that the heap can be split into: The part of the heap determined by UNFORW which is as in oldh, the part determined by DONE which has been updated according to φ, the part determined by QUEUE which has yet to be updated, and we may find the records in oldh by following the inverse of the isomorphism φ, the part of the heap pointed to by pointers in FW where each record represents a part of φ, and some free space.
To keep track of the space needed to complete the garbage collection we define a constant heap size.

Definition 4.8 Let heap size : (Z → Z option) → N0 set → H → N0 be the
Isabelle/HOL constant with the meaning:
heap size len P h = Pp∈P case h p of None ⇒ 0 | Some(t) ⇒ case len t of None ⇒ 0 | Some(l) ⇒ l
The pure part of the heap invariant is derived from the assumptions of the following lemmas.
The following lemma shows that any record, pointed to by a pointer p reachable from r in the old heap oldh, has been been copied to the to-space, and thus no record alive is left behind.
Lemma 4.9 Assume
∀t. ¬isptr t 0 ∧ finite DONE ∧ p ∈ reach isptr len (int(r)) oldh ∧ r ∈ FW ∧
h ∈ hs isptr len DONE DONE φ (InvIso FWφ) oldh ∧ Iso FW DONE φ
Then p ∈ FW .
The lemma below expresses that if QUEUE is nonempty and the invariant ensures that the records determined by QUEUE are densely packed in the interval [n,... ,f [, then we may conclude that the least pointer in QUEUE is n.
Lemma 4.10 Assume
∀t. ¬isptr t 0 ∧ finite DONE ∧ Iso FW (DONE ∪ QUEUE) φ ∧
DONE ∩ QUEUE = {} ∧ QUEUE /= {} ∧ QUEUE ⊆ [n,... ,f [ ∧
h ∈ hs isptr len QUEUE ALIV E (λx. Some(x)) (InvIso FWφ) oldh ∧
∀P, ψ. Iso P QUEUE ψ ∧ ψ ≺ φ ⊃ n + heap size isptr len P oldh = f
∀p ∈ QUEUE. p + the (len(the (oldh(the (InvIso FW φ))))) ≤ f
Then n ∈ QUEUE.
Using the lemmas above we have given a proof of the following Hoare triple in
Isabelle/HOL.
Γ ▶ {pure (funExp(λr. nat(r) ∈ ALIV E ∧ finite ALIV E ∧ ALIV E = reach isptr len r oldh ∧ r > 0) (trivExp rootp)) ∧ (λs. {oldh} ∩ hs isptr len ALIV E ALIV E (λx. Some(x)) (λx. Some(x)) oldh) ∗
(∃d. trivExp freep '→l map intExp d ∧ pure (boolExp (|d| = heap size len ALIV E oldh)))} cheney
{∃oldroot, DONE, φ. pure (funExp(λr, f. nat(oldroot) ∈ ALIV E ∧ 0 < oldroot ∧ finite ALIV E ∧ ALIV E = reach isptr len oldroot oldh ∧ 0 < r ∧ Iso ALIV E DONE φ ∧ nat(r) ∈ DONE ∧ DONE ⊆ [nat(r),. . ., nat(f )[)) ∧ (λs. hs isptr len DONE DONE φ (InvIso ALIV E φ) oldh ∗
fw len φ ALIV E oldh)}
where cheney is Cheney’s garbage collector.
It is easy to show that the post condition of Cheney’s collector implies that the isomorphism φ : ALIV E → DONE is a heap isomorphism in the sense of definition 4.2.
Copying a dag to a tree
In [18] John Reynolds gives a procedure copytree([j]; [i]) that copies a tree pointed to by i to a newly allocated tree pointed to by j. The procedure uses recursion,

first on the left subtree and then on the right subtree. As sketched in [18], if you give the procedure a pointer to a dag then the result will be a tree where any shared structure in the dag is copied multiple times to eliminate the sharing. We did the exercise of formalizing this proof in our Isabelle/HOL implementation. The exercise illustrates the use of higher-order separation logic to quantify over heap sets across a Hoare triple, it exercises our proof rules for procedures, and Lemma 3.4 is needed to simplify the assumptions about the procedure to what is originally sought. The proof also relies crucially on the rule for lookup in Section 3.2. The main observation about this proof is that it fits entirely within higher-order separation logic in the sense that all the needed predicates are definable in our implementation.
We assume we are given a standard definition of trees as an inductive datatype tree in Isabelle/HOL. Then it is easy to define a predicate htree : tree → Z exp → A that given a tree and an expression specifies that the expression points to a representation of the tree in the heap. Following Reynolds we can also give a predicate hdag : tree → Z exp → A that given a tree and an expression asserts that the expression points to a dag:
Definition 4.11 Let hdag : tree → Z exp → A be defined by primitive recursion on tree as follows:
hdag Atom e = pure (e = 0)
hdag Node(t1, t2) e = ∃i1, i2 : Z. e '→ [int(i1), int(i2)]∗
We would like to show
∀t : tree. Γ ▶ {hdag t e} copytree([j]; [e]) {hdag t e ∗ htree t j}	(1)
As Reynolds points out, following the proof for copying trees doesn’t work, as we will be unable to give a proof of the necessary specification for the first recursive call. Instead we prove the stronger specification
∀p : heap set. ∀t : tree. Γ ▶ {(λs. p) ∧ hdag t i} copytree([j]; [i]) {(λs. p) ∗ htree t j},
which uses quantification over arbitrary heap sets, a key property of higher-order separation logic.
The proof that the procedure body satisfies the above specification has two important parts. The first is that in order to look up the pointers to the sub-nodes of the dag we are faced with a precondition of the sort (λs. p)∧(v0 '→ i0 ∗v0+1 '→ i1) for some arbitrary p. We need the derived lookup rule from Section 3.2 to avoid the complication of Lemma 3.3 to get the standard lookup to work. The second important part is that in the first recursive call we can instantiate the first quantifier in the assumed specification with p ∧ hdag t2 i2, and then the proof works out.
Finally, we remark that the original specification in (1) of course follows from the stronger specification which we showed by means of Lemma 3.4 and the rule of consequence.

Related work
We have mentioned related work along the way. In this section we discuss other related work on formalizing separation logic.
In [19] Weber describes a formalization of first-order separation logic for a simple while-language without procedures in Isabelle/HOL and prove the soundness of the frame rule. He also includes a simple example, the verification of in-place list reversal.
Preoteasa [17] devised a formalization of first-order separation logic in PVS for a language with recursive procedures based on a predicate-transformer semantics. Again, the main result was the formal soundness proof the frame rule.
Here we extend these previous works with a formalization of higher-order separ- ation logic for a language with procedures and substantial case studies, in particular the verification of Cheney’s algorithm.
Our formalization of Cheney’s garbage collector enables separate verification of mutators and the garbage collector, as is also the case in the recent work by Mc- Creight, Shao, Lin and Li [9] on a Coq-implementation of Hoare logic for verification of garbage collectors written in assembly code.

Conclusion and Future Work
We have presented a formalization in Isabelle/HOL of higher-order separation logic for a language with simple procedures and address arithmetic. We have ex- plored the applicability of the formalization by verifying non-trivial algorithms in it, and have found that the use of higher-order separation logic does indeed simplify formalized proofs as conjectured in [1]. In particular, our new formalized higher- order separation logic proof of correctness of Cheney’s copying collector is at the same time both more general and simpler than the one in [2].
Future work includes further case studies of formal verification of programs, extending the formalization to languages with more features, e.g., concurrency, first class functions, and/or heaps with procedures. Future work also includes more automated reasoning in higher-order separation logic with, for instance, tactics for entailment of higher-order separation logic formulas.

Acknowledgements
We thank John Reynolds for interesting discussions regarding our system, and the anonymous referees for their helpful comments.


References
Biering, B., L. Birkedal and N. Torp-Smith, BI-hyperdoctrines, higher-order separation logic, and abstraction, ACM Trans. Program. Lang. Syst. 29 (2007).


Birkedal, L., N. T. Smith and J. C. Reynolds, Local reasoning about a copying garbage collector, in: Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (2004), pp. 220–231.
Brookes, S., A semantics for concurrent separation logic, Theoretical Computer Science 375 (2007),
pp. 227–270.
Cheney, C. J., A nonrecursive list compacting algorithm, Commun. ACM 13 (1970), pp. 677–678.
Church, A., A formulation of the simple theory of types, The Journal of Symbolic Logic 5 (1940),
pp. 56–68.
Gordon, M., Introduction to the HOL system, in: HOL Theorem Proving System and Its Applications, 1991., International Workshop on the, 1991, pp. 2–3.
Krishnaswami, N., J. Aldrich and L. Birkedal, Modular verification of the Subject-Observer pattern via higher-order separation logic, in: 9th Workshop on Formal Techniques for Java-like Programs (FTfJP 2007), 2007.
Lin, C., A. Mccreight, Z. Shao, Y. Chen and Y. Guo, Foundational typed assembly language with certified garbage collection, in: TASE ’07: Proceedings of the First Joint IEEE/IFIP Symposium on Theoretical Aspects of Software Engineering (2007), pp. 326–338.
McCreight, A., Z. Shao, C. Lin and L. Li, A general framework for certifying garbage collectors and their mutators, SIGPLAN Not. 42 (2007), pp. 468–479.
Mu¨ller, O., T. Nipkow, D. Von Oheimb and O. Slotosch, HOLCF = HOL + LCF, J. Funct. Program.
9 (1999), pp. 191–223.
Nanevski, A., A. Ahmed, G. Morrisett and L. Birkedal, Abstract Predicates and Mutable ADTs in Hoare Type Theory, in: Proceedings of ESOP’07, LNCS 4421, 2007, pp. 189–204.
O’Hearn, P., Resources, concurrency, and local reasoning, Theoretical Computer Science 375 (2007).
O’Hearn, P. W., J. C. Reynolds and H. Yang, Local reasoning about programs that alter data structures, in: CSL ’01: Proceedings of the 15th International Workshop on Computer Science Logic (2001), pp. 1–19.
Parkinson, M., When separation logic met Java, in: FTfJP’06, 2006.
Parkinson, M. and G. Biermann, Separation logic, abstraction and inheritance, in: Proc. 35th POPL, 2008.
Paulson, L. C., Isabelle: The next seven hundred theorem provers, in: Proceedings of the 9th International Conference on Automated Deduction (1988), pp. 772–773.
Preoteasa, V., Mechanical verification of recursive procedures manipulating pointers using separation logic, in: 14th International Symposium on Formal Methods, 2006, pp. 508–523.
Reynolds, J. C., Separation logic: A logic for shared mutable data structures (2002).
Weber, T., Towards mechanized program verification with separation logic, in: Proceedings of CSL’04, LNCS 3210 (2004), pp. 250–264.
Yang, H., An example of local reasoning in BI pointer logic: the Schorr-Waite graph marking algorithm
(2000).
