

Electronic Notes in Theoretical Computer Science 220 (2008) 129–143
www.elsevier.com/locate/entcs

Branching Bisimulation Congruence for Probabilistic Systems
Nikola Trˇckaa,1 and Sonja Georgievska a,2
a Department of Mathematics and Computer Science Eindhoven University of Technology
Eindhoven, The Netherlands

Abstract
The notion of branching bisimulation for the alternating model of probabilistic systems is not a congruence with respect to parallel composition. In this paper we first define another branching bisimulation in the more general model allowing consecutive probabilistic transitions, and we prove that it is compatible with parallel composition. We then show that our bisimulation is actually the coarsest congruence relation included in the existing branching bisimulation when restricted to the alternating model.
Keywords: probabilistic systems, branching bisimulation, alternating model, congruence


Introduction
Labeled transition systems are a well established formalism for modeling of the qualitative aspects of systems, focusing on the behavioral part. A transition sys- tem is a directed graph where nodes represent states of the system, and labels on edges represent the actions that the system performs when moving from one state to another. Reasoning on transition systems is usually done by relating states ac- cording to some behavioral equivalence. If two states agree on every step they can take, then they are equivalent modulo strong bisimulation equivalence [15,14]. If a system can perform internal, unobservable steps, then strong bisimulation becomes less appropriate because it equates too few states. To solve this problem weaker equivalences are introduced that abstract from internal steps but require that the observable steps are exactly simulated. The two most commonly used equivalences of this type are weak bisimulation [14] and branching bisimulation [8,6] equivalence.

1 Email: n.trcka@tue.nl
2 Email: s.georgievska@tue.nl

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.11.023

The difference between the two is that the latter is known to preserve the branching structure of a transition system better [8].



c	b





Fig. 1. A generalized alternating model of probabilistic systems

To model random behavior in systems several probabilistic extensions of tran- sition systems have been proposed, different in the way they combine probability with non-determinism [5]. One of the models that have attracted attention is the alternating model introduced in [21]. This model makes a distinction between non- deterministic states, in which non-deterministic choice is resolved, and probabilistic states, in which probabilistic (random) choice is resolved according to a given dis- tribution. In the non-strict version of the model [16] it is only required that prob- abilistic states are succeeded by nondeterministic ones; in the strictly alternating model [10] an action transition must also end in a probabilistic state. In this paper we consider a more general alternating model in which consecutive probabilistic steps are also allowed. An example of this system is depicted in Figure 1.
The notion of branching bisimulation in the probabilistic framework was first introduced in [18] for the non-alternating model (a transition system in which ev- ery action transition leads to a probability distribution of states instead to a single state [17]). Branching bisimulation was also defined for the fully-probabilistic model in [4]. This model, however, disallows any non-determinism by attaching proba- bilities to action labels so that the probability of all outgoing transitions from a state sums up to one. For the strictly alternating model a definition of branching bisimulation was given in [2]. By using colored traces, as in the original definition of non-deterministic branching bisimulation [8], they proved that their notion relates exactly those states that are intuitively branching bisimilar. Although originally defined for the strictly alternating model only, the same definition applies in the (non-strictly) alternating setting, too. They also point out that their branching bisimulation is incomparable to the one of [18].
Transition systems and their extensions are mostly used as a semantical model of some process algebra [3,11,13]. For a behavioral equivalence to be useful in a process algebraic setting, it is essential that it is compatible with all the operators under consideration, i.e. that it is a congruence relation. In the non-deterministic setting branching bisimulation is known to have the congruence property (with a slight adaptation needed for the compatibility with alternative composition) [8]. In the probabilistic setting, however, this issue has only been considered in [18] for the non-alternating model. In fact, branching bisimulation of [2] for the strictly alternating model fails to be a congruence for parallel composition [1]. Consider the following example.



a)	s
s ↔b t	b)	s  u
s  u /↔b t  u

τ	τvvvvv
 J	,svvvv
¸¸¸¸¸
¸¸z$

t
˛r	,[
t	u	s  v

π˛r  ˛r
   ˛r
,[ 1,[ −π
,[ zz
˛r
˛r  ˛r
,Z 1,Z −π	 τ

u 	a	// v
 r	zz


 J



,Z 1−π
zz
v	v



Fig. 2. Branching bisimulation of [2] is not a congruence for parallel composition

Example 1.1 States s and t in the alternating model from Figure 2a are branching bisimilar; each one can perform a with probability π and deadlock, or just deadlock with probability 1−π (τ is an internal step). However, states s u and t  u are not branching bisimilar, as is easily seen from Figure 2b. State s u can perform an action a and proceed to state s  v, from which action a can be observed exactly with probability π. State t  u, on the other hand, by executing action a (possibly preceded by τ or probabilistic steps) cannot at all reach a state that behaves as s  v, i.e. that performs a with probability π. (Note that the usual addition of the root condition which solves the problem for alternative composition does not solve the problem here.)
The standard parallel composition for the alternating model, as defined in [10], is based on the resource oriented view of non-determinism: a non-deterministic choice is deduced only when the user knows which resources are offered. This means that parallel components must resolve their probabilistic choices first, and then start interleaving. In Figure 2b state t  u has to make the random choice in t before doing the action a from u, while state s  u can choose to perform a immediately. This leads to a problem since, as previously explained, the branching structure of the two states is not the same. Note that, as the definition of parallel composition is the same for any version of the alternating model, the problem remains when switching from one setting to another.
There are two ways of solving the congruence problem for a given equivalence satisfying the (rest of the) desired properties. The first way is to adapt the prob- lematic operator, i.e. change its semantics. This approach can sometimes be hard to motivate since it also affects other behavioral equivalences. The other, more popular, approach is to strengthen the equivalence in consideration, preferably in such a way that the obtained notion is the coarsest congruence contained in the original equivalence. For branching bisimulation this idea has been employed many times, for instance in the extensions of process theory with priorities [7] and with timing [20].
In this paper we define the notion of branching bisimulation for the (generalized) alternating model, and prove this notion compatible with parallel composition. In

our bisimulation probabilistic transitions can be taken as silent when action behavior is simulated, but they themselves must be simulated in the strong sense (abstracting only from intermediate probabilistic transitions which are allowed in our model). This restriction implies that states s and t from Figure 2a are not branching bisimilar in our definition. Our motivation comes from the fact that probabilistic steps are always given priority in parallel contexts, and therefore a probabilistic state that leads to different classes cannot be related to a (non-prioritized) non-deterministic state. In this manner we follow a similar line of reasoning as in [7] where non- probabilistic branching bisimulation is adapted to become compatible with action priorities.
In contrast to [2] our definition does not need the notion of scheduler. However, by giving an alternative definition involving schedulers we prove that our bisimu- lation, when applied to the alternating model, is actually the coarsest equivalence relation included in the branching bisimulation of [2] that is compatible with par- allel composition. We thus solve the congruence problem of [2] by using the second approach described above.
When used for simplification of systems, our bisimulation appears to be too strong at first since, in general, it eliminates less τ ’s than the one from [2]. However, the examples we provide illustrate that the equivalence is still powerful enough for the elimination of internal non-determinism. In other words, the non-determinism that remains after the branching bisimulation reduction procedure is actual, and does not artificially persist because of our decision to preserve those τ ’s that precede probabilistic choices. Note that the remaining τ ’s can later be ignored when the congruence property is no longer needed (e.g. for performance analysis of a closed system).
The structure of the paper is as follows. In Section 2 we introduce proba- bilistic transition systems as the generalized alternating model, and we define the notion of branching bisimulation. In Section 3 we define parallel composition with- out synchronization for our model, and prove that our branching bisimulation is a congruence relation with respect to this operator. In Section 4 we show that our bisimulation is the smallest congruence in the branching bisimulation from [2]. Finally, the last section gives some conclusions and some directions for future work.

Model and Branching Bisimulation
In this section we define our model, a probabilistic transition system, as the gen- eralized alternating system. We then define the notion of branching bisimulation for this model. Throughout the rest of the paper we presuppose a set A of actions that includes the special action τ .
Definition 2.1 [Probabilistic transition system] A probabilistic transition system is a tuple (S, →, ~), where S is a finite set of states, → ⊆ S × A × S is an action transition relation, and ~ ⊆ S × (0, 1] × S is a probabilistic transition relation such that, for all s ∈ S, (s,π,t)∈~ π ∈ {0, 1}. Moreover, for a given s ∈ S, if there exist t ∈ S and π ∈ (0, 1] such that (s, π, t) ∈ ~, then (s, a, t′) /∈ → for all t′ ∈ S, a ∈ A.

We write s −→a  t rather than (s, a, t) ∈ →, and s ~π  t rather than (s, π, t) ∈ ~.

We also write s ~ t when there exists a π ∈ (0, 1] such that s ~π
Note that

the relations → and ~ induce a partitioning of the set S into two sets Sn and
Sp, denoting nondeterministic and probabilistic states, respectively. Formally, Sp =

{s ∈ S | ∃π ∈ (0, 1], ∃t ∈ S, s ~π
t} and Sn = S \ Sp. Note that a state without

any outgoing transitions, i.e. a deadlock state, belongs to Sn.
We now introduce some preliminaries necessary for defining our branching bisim- ulation.
To be able to use some results from Markov chains theory, we first represent the probabilistic transition relation as a matrix. Given a probabilistic transition system (S, →, ~), we define the matrix P : S × S → [0, 1] by:
,,π,	if s ~π t

P (s, t) =
1,	if s = t and s ∈ Sn
,,0,	otherwise.

Since consecutive probabilistic transitions exist in (S, →, ~), we next compute the overall probabilities. P is clearly a probabilistic matrix, which implies that there exists its Cesaro limit [12], defined by Π = limn→∞(I + P + P 2 + . . . + Pn)/(n + 1). For t ∈ Sn, Π(s, t) denotes the probability with which s reaches t via zero or more probabilistic transitions; for t ∈ Sp, Π(s, t) holds the probability that the system

is found in t in the long run of probabilistic transitions. We write s ~π
ces
t when

Π(s, t) = π > 0, and s ~ces t if there is such π. For a set D ⊆ S, we define Π(s, D) =	t∈D Π(s, t).
Remark 2.2 If (S, →, ~) is a probabilistic transition system belonging to the al- ternating model, then matrices Π and P coincide.

In the sequel the following notation will be used: s −−· t denotes s
−→τ
t or

(a)	a
s
ces t; s −−→ t denotes s −→ t, or s = t and a = τ . Given an equivalence relation
R ⊆ S × S and a state s ∈ S, S/R denotes the partitioning of S induced by R, and [s]R denotes the equivalence class of s with respect to R.
Definition 2.3 [Branching bisimulation] Let (S, →, ~) be a probabilistic transi- tion system. An equivalence relation R ⊆ S × S is a branching bisimulation iff, for every (s, t) ∈ R, the following holds:

if s ∈ Sn and s −→a
s′ for some a ∈ A and s′ ∈ S, then there exist t0, . . . , tn, t′ ∈ S

such that t = t, t −−· t −−· . . . −−· t −(−a→)
and (s′, t′) ∈ R;	and
if s ∈ Sp, then
Π(s, D) = Π(t, D) for all D ∈ S/R; and
Π(s, s) > 0 implies t ∈ Sp.
t′, (s, ti) ∈ R for all 0 ≤ i ≤ n,

We write s ∼b t if (s, t) ∈ R for some branching bisimulation relation R.
The first condition of branching bisimulation says that, as usual, when action

a)	b)
c)	
1 ,' ,' ,t,t 1,ר ,ר 1
	

1  ,' ,'


,ר ,ר 1

τ
6 ,'	,t 3 ,ר 2
2 ,'
,ר 2

// J  ,¸
 J,t
,ר zz ,'
,ר zz

τ	,'
π,' ,'
,ר	τ
,ר ,ר1−π
π t,
t,J’
-z,t
,t 1
ee	1  ,'
,'
,'	,ר
,ר 2

,ר

 ,'
,,
,ר zz
e
t,,¸ ,¸
,t
*,,t
,ר zz

,,,
eee
,t 1−π
,,,
eee

a , ee b	,t,t
a ,,
ee b






Fig. 3. Probabilistic transition systems with branching bisimulations
execution is simulated, it can possibly be preceded by a sequence of internal tran- sitions connecting states within the same equivalence class. For an internal step we take either a step labeled with the τ action, or a probabilistic Cesaro transition. The second condition ensures that probabilistic steps are (more) strongly simulated. Generally we do not allow any τ ’s in this case, and the only abstraction is the one induced by using the matrix Π instead of P . Due to this condition, in our setting states s and t of Figure 2a cannot be related. The extra requirement in the second condition, namely that Π(s, s) > 0 implies t ∈ Sp, prevents a deadlock state to be related to a state that is in a class of consecutive probabilistic states, from which no other class is reachable. This requirement is needed to establish the congruence property since such a class blocks any action in a parallel context.
It is not hard to show that the conditions of Definition 2.3 are compositional, and that the transitive closure of the union of all branching bisimulations is itself a branching bisimulation. From the last it follows easily that ∼b is the maximal branching bisimulation.
Remark 2.4 Note that the type of abstraction induced by Π is more of a weak bisimulation type than of a branching bisimulation type since it allows intermediate probabilistic steps to be in different equivalence classes. It is, however, not hard to show that these intermediate steps are all branching bisimilar whenever the last state is non-deterministic and branching bisimilar to the first one. From this it follows that our branching bisimulation satisfies the stuttering property or, in other words, that using the relation ~ instead of ~ces in the first condition would lead to the same notion of branching bisimilarity.
The following illustrates our notion of branching bisimulation.
Example 2.5 Figure 3 depicts three probabilistic transition systems with branch- ing bisimulations on them; bisimilar states are given the same color. Figures 3a and 3b illustrate the application of the first condition. They also show that not every state that guards a probabilistic choice with a τ must be in a different bisim- ulation class. The second and the third state in Figure 3b are bisimilar because Π ensures that these states must both leave the loop eventually with probability

one (the loop is not closed). Figure 3c shows another case, where Π abstracts from intermediate probabilistic transitions, and illustrates the point made in the above remark.

Parallel Composition
In this section we define the merge operator parallel composition without synchro- nization for probabilistic transition systems, and prove that ∼b is compositional with respect to this operator. (For now we omit synchronization, since it does not add complexity to the problem).
Definition 3.1 [Merge] The operation merge transforms a probabilistic transition system (S, →, ~) into the probabilistic transition system (S × S, →, ~) 3 defined as follows (we standardly write s t instead of (s, t)):

s  t −→a
•
u iff s, t ∈ Sn and
′	a	′	′

there exists s
∈ S such that s −→ s
and u = s	t, or

there exists t′
∈ S such that t −→ t′
and u = s	t′;	and

for all π ∈ (0, 1], s	t ~π  u iff

π
t ∈ Sn, there exists s′ ∈ S such that s ~
s′, and u = s′	t, or

π
s ∈ Sn, there exists t′ ∈ S such that t ~
t′, and u = s  t′, or

there exist π , π ∈ (0, 1] and s′, t′ ∈ S, such that s ~π1 s′, t ~π2 t′, π = π π ,
1	2	1 2
and u = s′	t′.
The rest of this section is devoted to proving that branching bisimulation is a congruence for the merge operator. We need some lemmas for that. The first lemma establishes the connection between P and Π on the level of elements. Its proof can be found in any book on standard Markov chain theory (see e.g. [12]).
Lemma 3.2 Let s, t ∈ S. Then
if Π(s, t) > 0, then Π(t, t) > 0;
if P (s, s) = 1, then Π(s, s) = 1.
The next lemma shows that a probabilistic state related to a non-deterministic state can reach only its own class via a Cesaro transition; moreover, the transition must be to a non-deterministic state.
Lemma 3.3 Let R ⊆ S ×S be a branching bisimulation and let s ∈ Sp. If (s, t) ∈ R for some t ∈ Sn, then Π(s, [s]R) = 1; moreover, for all r ∈ S such that Π(s, r) > 0, it holds that r ∈ Sn.
Proof. From t ∈ Sn we have P (t, t) = 1, and so, by Lemma 3.2(ii), we have Π(t, t) = 1. Since (s, t) ∈ R, we have Π(s, [s]R) = 1. This means that any state reachable from s via a Cesaro transition belongs to [s]R. For the second part of the lemma, let us assume that r ∈ S is such that Π(s, r) > 0. Then Π(r, r) > 0 by

3 We overload symbols → and ~ for simplicity

Lemma 3.2(i). Suppose that r ∈ Sp. By Definition 2.3 it follows that t ∈ Sp, which contradicts the assumption that t ∈ Sn. Therefore, r ∈ Sn.	2
Finally, the last lemma shows how the Cesaro limit of the merge can be calculated by the Cesaro limits of the individual components.
Lemma 3.4 For all s, t, s′, t′ ∈ S, Π(s  t, s′  t′) = Π(s, s′) · Π(t, t′).
Proof. Note that the probabilistic transition matrix of the merge is just the Kro- necker product [9] of the probabilistic transition matrices of the parallel compo- nents. The proof then easily follows from the fact that matrix powers distribute over Kronecker products.	2
We can now prove the main theorem of this section.
Theorem 3.5 (Congruence theorem) Branching bisimulation is a congruence with respect to the merge operator.
Proof. Let R = {(s  u, t  v) | s, t, u, v ∈ S, s ∼b t, u ∼b v}. We show that R is a branching bisimulation relation. It is clearly an equivalence relation.
Let s, t, u, v ∈ S be such that (s	u, t	v) ∈ R.
Suppose that s  u −→a  r for some r ∈ S × S and a ∈ A. Without loss of generality

we assume that s −→ s′ for some s′
∈ S, therefore u ∈ Sn and r = s′
u. From s ∼b t it

follows that there exist t0, . . . tn, t′ ∈ S such that t0 = t, t ∼b ti for 0 ≤ i ≤ n, s′ ∼b t′,

and t0
−−· t1
−−· . . . −−· tn
(a)
−−→
t′. By induction on n we now show that there exist

t¯0 = t, t¯1, . . . , t¯k , v¯0 = v, v¯1, . . . , v¯k, and r¯ ∈ S × S, such that (t  v, t¯i
 v¯i) ∈ R for

0 ≤ i ≤ k, (r, r¯) ∈ R, and t¯0
 v¯0
−−· t¯1
 v¯1
−−· . . . −−· t¯k
 v¯k
(a)
−−→
r¯. We distinguish

two cases: when v ∈ Sn and when v ∈ Sp. Suppose first that v ∈ Sn.

If n = 0, then there is a t′
∈ S such that t
(a)
−−→ t
and t′
∼b s′. From this

(a)
t	v −−→ t	v.

Suppose that n > 0. If t0
−→τ
t1, then t0  v
−→τ
t1  v.  If t0 ~ces t1, then

t0  v ~ces t1  v, by Lemma 3.4 and because Π(v, v) = 1. The rest follows by the inductive assumption.
Suppose now that v ∈ Sp. From v ∼b u and Lemma 3.3, it follows that there exists a v¯ ∈ Sn such that Π(v, v¯) > 0 and v ∼b v¯.
′	(a)	′	′	′	′

If n = 0, then there is a t
∈ S such that t −−→ t and t ∼b s . If t = t , then

(a)
t	v −−→ t
v. If t /= t′, then by Lemma 3.4 we have t ∈ Sn, Π(t, t) = 1, and

t  v ~ces t
(a)
v¯ −−→ t
v¯.

Suppose that n > 0. If t0 −→τ
t1, then t0  v ~ces t0
v¯ −→τ
t1  v¯. If t0 ~ces t1, then

t0  v ~ces t1
assumption.
v¯ by Lemma 3.4. In both cases the rest follows by the inductive

Suppose that s	u is a probabilistic state.

– Let p, q ∈ S and D = [p  q]R. Then, using Lemma 3.4, we have Π(s  u, D) =
ΣΣp¯q¯∈D Π(s  u, p¯  q¯) = Σp¯q¯∈D Π(s,p¯)Π(u, q¯) = Σp¯∼b p,q¯∼b q Π(s, p¯)Π(u, q¯) =
(	p¯∼b p Π(s, p¯))(Σq¯∼bq Π(u, q¯))	=	(Σp¯∼bp Π(t, p¯))(Σq¯∼bq Π(v, q¯))	=
Σp¯∼bp,q¯∼b q Π(t, p¯)Π(v, q¯) = Σp¯ q¯∈D Π(t	v, p¯ q¯) = Π(t	v, D). 	
– Without loss of generality we assume that s ∈ Sp. Suppose Π(s  u, s  u) > 0 and
t  v is nondeterministic. Then t ∈ Sn and v ∈ Sn. If Π(s, s) > 0, then t ∈ Sp. If
Π(s, s) = 0, then because of Lemma 3.4, Π(s  u, s	u) = Π(s, s)Π(u, u) = 0. In both cases we obtain a contradiction. Therefore, t v ∈ Sp.
2
The Coarsest Congruence
In this section we show that our branching bisimulation is the coarsest congru- ence included in the branching bisimulation of [2]. We proceed with definitions involved in formalizing schedulers, necessary for the comparison of the two notions of branching bisimulation.
Definition 4.1 [Paths] A finite path (from a state s) is a sequence s0 l1 s1 . . . lk sk

such that s = s0, si
∈ S, li
∈ (0, 1] ∪ A, and s
i−1
li
−→ si or si−1
~li
ces
si for all

1 ≤ i ≤ k. An infinite path from a state s ∈ S is an infinite sequence s0 l1 s1 . . .

such that s = s0, si
∈ S, li
∈ (0, 1] ∪ A, and s
li
i−1 −→ si or si−1
~li
ces si
for all 1 ≤ i.

A path is a finite or infinite path. The set of all finite paths is denoted as Pathsf.
Given a finite path c = s0 l1 s1 . . . lk sk, we define last(c) = sk. The probability of c is the product of all probability labels found on it, if any, or 1 otherwise, i.e.
Prob(c) =	li∈(0,1] li,	if lj ∈ (0, 1] for some 1 ≤ j ≤ k
1,	otherwise.
We now introduce the notion of scheduler; a scheduler is used to resolve non- determinism.
Definition 4.2 [Scheduler] A scheduler is a function σ : Pathsf '→ (→ ∪ {⊥}),
such that, if σ(c) = s −→ s′ for some s, s′ ∈ S and a ∈ A, then last(c) = s.
If a path ends with a non-deterministic state, a scheduler schedules the next action transition or it schedules nothing (i.e. ⊥). If a path ends with a probabilistic state, a scheduler schedules nothing (⊥) since in this case the next state is determined by the probability distribution.
Definition 4.3 Let σ be a scheduler.  A scheduled path by σ is a finite path
s0 l1 s1 . . . sk where, for each 0 ≤ i < k, si ∈ Sn implies σ(s0 l1 s1 . . . si) =
li+1
si −−→ si+1, or an infinite path s0 l1 s1 . . . , where for each i ≥ 0, si ∈ Sn implies
li+1
σ(s0 l1 s1 . . . si) = si −−→ si+1. A maximal scheduled path is either an infinite
scheduled path, or a finite scheduled path c for which last(c) ∈ Sn and σ(c) = ⊥. The set of all maximal scheduled paths by σ is denoted by Pathsm(σ).

Any scheduler σ induces a probability space on Pathsm(σ) in the usual way [2].
Next, given an equivalence relation on the states, we formally define paths that silently traverse through equivalent states, perform an action and then reach another class.
Definition 4.4 Let R ⊆ S × S be an equivalence relation and let D ∈ S/R. Let c = s0 l1 s1 . . . lk sk be a finite path such that sk ∈ D, and for all 1 ≤ i ≤ k − 1, si ∈ [s0]R and li ∈ A implies li = τ . For a given a ∈ A \ {τ }, we say that c is of
type s0 ⇒a D if lk = a, and we say that c is of type s0 ⇒τ D if lk = τ , lk ∈ (0, 1], or
k = 0. We write s0 ⇒ D rather than s0 ⇒τ D.


For a scheduler σ, by Pathsm(σ)

a
/t⇒D
we denote the set of all paths in Pathsm(σ)

that are of type t ⇒a D.
The following lemma is needed in the comparison of the two notions of branching bisimulation.
Lemma 4.5 Let R ⊆ S × S be a branching bisimulation relation and let (s, t) ∈ R.
If s −→a  s′ for some a ∈ A and s′ ∈ S, then there exists a scheduler σ such that
Prob(Pathsm(σ) a  ′  ) = 1.
/t⇒[s ]R


Proof. Since s −→a
s′ and (s, t) ∈ R, there exists at least one path of type t ⇒a
[s′]R.

The proof goes by induction on the minimal number of non-deterministic states
a	′
that appear in a path of type t ⇒ [s ]R, not counting the last node. To formalize
this, for a given path c, we define N (c) = {i | i ∈ Sn, i ∈ c, i /= last(c)} and
a	′
minn(t) = min{|N (c)|, where c is of type t ⇒ [s ]R}. The proof is by induction on
minn(t).
Let t ∈ S be such that (s, t) ∈ R and minn(t) = 0. Then t ∈ Sp, Π(t, [s′]R) > 0, and a = τ . Since (s, t) ∈ R and Π(s, [s]R) = 1, it follows that Π(t, [t]R) = 1. From Π(t, [s′]R) > 0, we obtain [s′]R = [t]R. The scheduler σ, defined by σ(c) = ⊥ for every path c, satisfies Prob(Pathsm(σ)/t⇒[s′]R ) = 1.
Suppose that, for every t ∈ S such that (s, t) ∈ R and minn(t) = m ≥ 0, there
exists a scheduler σ such that Prob(Pathsm(σ) a  ′  ) = 1. Let t ∈ S be such that

(s, t) ∈ R and minn(t) = m + 1.
/t⇒[s ]R

a	′	′

Suppose first that t ∈ Sn.  Then either t −→ t , for some t
∈ S such that

(s′, t′) ∈ R, or there exists a t′′ ∈ S such that (t′′, t) ∈ R, t −→τ
In the first case, the required scheduler is defined by
t′′, and minn(t′′) = m.




σ(c) =
(t −→a
t′,	if last(c) = t

⊥,	otherwise.

In the second case, by the inductive assumption there exists a scheduler ρ, such

that Prob(Pathsm(ρ)

′′ a  ′
) = 1. Define scheduler σ by

( τ	′′


/t ⇒[s ]R


The scheduler σ satisfies Prob(Pathsm(σ)  a  ′  ) = 1.
/t⇒[s ]R
Suppose now that t ∈ Sp. Then Π(t, [t]R) = 1. Let T = {u | t ~ces u} be the set of all states that can be reached from t by Cesaro transitions. By Lemma 3.3 it follows that u ∈ Sn for all u ∈ T . Thus, for every u ∈ T , either there exists a u′′ ∈ S
such that u −→τ  u′′, (u, u′′) ∈ R, and minn(u′′) = m, or there exists a u′ ∈ S such that
a	′	′	′
u −→ u and (u , s ) ∈ R. In the first case, by the inductive assumption there exists a

scheduler ρu that satisfies Prob(Pathsm(ρu)
′′ a  ′
) = 1. Define schedulers ρ and

σ by

(	τ	′′
/u ⇒[s ]R


′′	′′
n





and


σ(c) =

(u −→a  u′,	if last(c) = u and (u′, s′) ∈ R

ρ(c),	otherwise.
Using	that	Π(t, t)	=	0,	we	can	calculate	Prob(Pathsm(σ) a  ′  )	=

Σu∈T Π(t, u) · Prob(Pathsm(σ)
/t⇒[s ]R
a  ′  ) =	u∈T Π(t, u) = 1.	2

/u⇒[s ]R
Note that our branching bisimulation can now be defined in terms of schedulers by replacing condition (i) of Definition 2.3 with the following condition: If s ∈ Sn
and s −→ s′ for some a ∈ A and s′ ∈ S, then there exists a scheduler σ such that
Prob(Pathsm(σ) a  ′  ) = 1. One direction of the proof follows immediately from
/t⇒[s ]R
Lemma 4.5, while the other direction is trivial.
For the rest of this section we restrict ourselves to the alternating model in which the probabilistic transition relation ~ is a subset of S × (0, 1] × Sn. Recall that in this case the matrices Π and P coincide.
For an equivalence relation R ⊆ S × S we define the probabilistic function
µR : S × S/R '→ [0, 1] by:
(   Π(s,D)   ,	if s ∈ Sp, D /= [s]R, and Π(s, [s]R) /= 1

µR(s, D) represents the conditional probability that in one Cesaro transition s can reach class D, assuming that it leaves its own class.
We now give the definition of branching bisimulation as defined in to [2].
Definition 4.6 [Branching bisimulation according to [2]] An equivalence relation
R ⊆ S × S is a branching bisimulation iff, for every (s, t) ∈ R the following holds:

if s −→a
s′ for some a ∈ A and s′ ∈ S, then there exists a scheduler σ, such that

Prob(Pathsm(σ) a  ′  ) = 1;	and
/t⇒[s ]R
if  s  ∈  Sp,  then  there  is  a  scheduler  σ  such  that  µR(s, D)  =
Prob(Pathsm(σ)/t⇒D) for all D ∈ S/R, D /= [s]R.
We write s ↔b t if there exists a branching bisimulation relation R ⊆ S × S as of [2] such that (s, t) ∈ R. The relation ↔b is the maximal branching bisimulation as of [2].
The following lemma and Lemma 4.5 show that ∼b is stronger than ↔b. That it is strictly stronger follows directly from the fact that in Figure 2a we have s ↔b t, whereas s ∼b t.
Lemma 4.7 Let R ⊆ S × S be a branching bisimulation. Let (s, t) ∈ R be such that s ∈ Sp. Let σ be a scheduler such that σ(c) = ⊥ for all paths c. Then µR(s, D) = Prob(Pathsm(σ)/t⇒D), for all D ∈ S/R such that D /= [s]R.
Proof. Let D /= [s]R. If Π(s, [s]R) = 0, then µR(s, D) = Π(s, D) = Π(t, D) = Prob(Pathsm(σ)/t⇒D). If Π(s, [s]R) > 0, then, since every Cesaro transition leads to a nondeterministic state, there exists an s′ ∈ Sn, such that Π(s, s′) > 0 and (s, s′) ∈ R. Since Π(s′, s′) = 1, we have Π(s, [s]R) = 1. From this, µR(s, D) = 0 and Π(t, D) = Π(s, D) = 0. Then Pathsm(σ)/t⇒D is the empty set, from which it follows directly that Prob(Pathsm(σ)/t⇒D) = 0.	2
The following lemma plays the central role in the coarsest congruence proof.
Lemma 4.8 Let s, t ∈ S. Let x be an action label that does not appear in any
path in (S, →, ~). Let x be a new state such that x −→x  δ, x has no other outgoing
transitions, and δ has no transitions at all. If s  x ↔b t  x, then s ∼b t.
Proof. Define the equivalence relation R ⊆ S×S by R = {(p, q) | p  x ↔b q  x}. We prove that R is a branching bisimulation according to our definition. Let (s, t) ∈ R.

Suppose that s −→ s′
for some s′
∈ S and a ∈ A. Then s	a
′	x. Since

s  x ↔b t  x, there exists a scheduler σ such that Prob(Pathsm(σ)	a  ′
) = 1.

/t  x⇒[s x]↔b
a	′
From this it easily follows that there exists a path of type t ⇒ [s ]R, which directly
implies the first condition of Definition 2.3.
	Suppose now that s ∈ Sp. We show that for all D ∈ S/R, Π(s, D) = Π(t, D). Suppose first that t ∈ Sn. Since Π(t, [t]R) = 1, it is sufficient to show that

x
Π(s, [s]R) = 1. We have t  x −→ t. From s  x
↔b t  x it follows that there exists a

scheduler σ such that Prob(Pathsm(σ)	x	) = 1. Assume that Π(s, [s]R) /= 1,
/s  x⇒[t]↔b
i.e. that there exist s′ ∈ S and π ∈ (0, 1] such that Π(s  x, s′  x) = π and s  x /↔b s′  x.
But then Prob(Pathsm(σ)	x	) ≤ 1 − π for any scheduler σ, which leads to a
/s  x⇒[t]↔b
contradiction. We conclude that Π(s, [s]R) = 1.
Suppose now that t ∈ Sp. Suppose first that Π(s, [s]R) > 0. Then there exists an s′ ∈ Sn such that Π(s  x, s′  x) > 0 and s  x ↔b s′  x. As s is related to a

non-deterministic state, similarly to the previous case, it follows that Π(s  x, [s  x]↔b ) = Π(s, [s]R) = 1. We show that Π(t, [s]R) = 1. Assume the opposite, i.e. that Π(t, [s]R) < 1. Then Π(t  x, [s  x]↔b ) < 1. This means that there exists a class D /= [s  x]↔b such that Π(t x, D) > 0. This contradicts the fact that Prob(Pathsm(σ)/t  x⇒D) = µR(s, D) = 0 for some scheduler σ.
Suppose now that Π(s, [s]R) = 0. Assume that Π(t, [s]R) > 0. Then Π(t  x, [s 
x]↔b ) > 0. This means that there exists a t′ ∈ S, t′ /= t, such that Π(t  x, t′ x) > 0

and t  x ↔b t′  x. Since t′  x ∈ Sn, it follows that t′  x
−→x
t′. This means

that Prob(Pathsm(σ)	x  ′	) = 1 for some scheduler σ. But this implies that
/s  x⇒[t ]↔b
there is an s′ ∈ S, s′ /= s, such that Π(s  x, s′  x) > 0 and s  x ↔b s′  x, which contradicts the fact that Π(s, [s]R) = 0. We conclude that Π(t, [s]R) = 0.
Let D ∈ S/R be such that D /= [s]R. Then µR(s, D) = Π(s, D) and there exists a scheduler σ such that Prob(Pathsm(σ)/t⇒D) = Π(s, D). Since Π(t, [t]R) = 0, it must hold that Prob(Pathsm(σ)/t⇒D) = Π(t, D).
It is left to show that Π(s, s) > 0 implies t ∈ Sp. This is, however, always true because, in the alternating model, Π(s, s) = 0 for all s ∈ Sp.	2
We now prove that, when applied in the alternating model, our branching bisim- ulation is the largest equivalence included in ↔b that is compatible with the merge operator.
Theorem 4.9 Let R ⊆ S × S be an equivalence relation that is a congruence for the merge operator. If R ⊆ ↔b, then R ⊆ ∼b.
Proof. Suppose that (s, t) ∈ R and let x be as in Lemma 4.8. Then (s  x, t  x) ∈ R because R is a congruence relation. Since R ⊆ ↔b, we have s  x ↔b t  x. From Lemma 4.8, it follows that s ∼b t.	2
5	Conclusions and Future work
We have defined a notion of branching bisimulation for a general alternating model of probabilistic systems that allows successive probabilistic transitions. We have proved our notion to be compatible with parallel composition without synchroniza- tion. We have also shown that our bisimulation is the coarsest congruence included in the branching bisimulation of [2] (when restricted to the alternating model), thus properly solving the congruence problem of [2].
Although we have only considered the merge operator, it is easy to extend the theory with the rest of the standard operators. The only non-standard modification involves the sequential composition operator, because we have to forbid processes x · τ and x to be bisimilar. This, however, can be easily solved, for example by using the same termination condition as in [7].
In this paper we worked with the (generalized) alternating model of probabilis- tic systems, and we did not consider e.g. the non-alternating model of [17], for which branching bisimulation exists and is a congruence [18]. In [19] an embed- ding from the (general) alternating to the non-alternating model is proposed, that

uses a special internal action for the purpose of translating the probabilistic tran- sitions. This embedding, however, does not preserve parallel composition, because the parallel composition of two alternating systems does not map to the parallel composition of their individual images. One way to preserve parallel composition is to adapt the standard parallel operator from the non-alternating setting to give special treatment to the newly introduced action, i.e. to give this action a priority. This would, however, either introduce the same congruence problems as in the al- ternating model, or would require that the special action is the τ action, thus not obtaining a conservative extension.
In [19] there is also another type of mapping proposed, that does preserve par- allel composition. This transformation can be applied only in one version of the alternating model, and is simply based on combining probabilistic transitions with action transitions that pass through them (if any). For future work we schedule to investigate how our branching bisimulation is related to the notion that is naturally obtained by propagating the notion of [18] to our setting.
In future we also plan to develop an algorithm for deciding our bisimulation, and to find a sound and complete axiomatization and study application.

Acknowledgement
We thank Suzana Andova and Jos Baeten for the useful suggestions on an earlier version of this work. We thank also the anonymous referees for their suggestions and to the participants of the QAPL’08 workshop for the interesting discussions.

References
Andova, S., J. Baeten, P. D’Argenio and T. Willemse, A compositional merge of probabilistic processes in the alternating model, in: 18th Nordic Workshop on Programming Theory, Reykjavik, Iceland, 2006.
Andova, S. and T. Willemse, Branching bisimulation for probabilistic systems: characteristics and decidability, Theor. Comput. Sci. 356 (2006), pp. 325–355.
Baeten, J. and W. Weijland, “Process Algebra,” Number 18 in Cambridge Tracts in Theoretical Computer Science, Cambridge University Press, 1990.
Baier, C. and H. Hermanns, Weak bisimulation for fully probabilistic processes, in: CAV ’97: Proceedings of the 9th International Conference on Computer Aided Verification (1997), pp. 119–130.
Bartels, F., A. Sokolova and E. de Vink, A hierarchy of probabilistic system types, Theor. Comput. Sci.
327 (2004), pp. 3–22.
Basten, T., Branching bisimilarity is an equivalence indeed!, Information Processing Letters 58 (1996),
pp. 141–147.
Bergstra, J., A. Ponse and M. van der Zwaag, Branching time and orthogonal bisimulation equivalence, Theoretical Computer Science 309 (2003), pp. 313–355.
Glabbeek, R. v. and W. Weijland, Branching time and abstraction in bisimulation semantics, JACM
43 (1996), pp. 555–600.
Graham, A., “Kronecker Products and Matrix Calculus With Applications,” Ellis Horwood Lim., Chichester, 1981.
Hansson, H. A., “Time and Probability in Formal Design of Distributed Systems,” Elsevier, 1994.
Hoare, C., “Communicating Sequential Processes,” Prentice Hall, Englewood Cliffs, 1985.

Kemeny, J. and J. Snell, “Finite Markov chains,” Springer, 1976.
Milner, R., “A Calculus of Communicating Systems,” Springer-Verlag New York, Inc., Secaucus, NJ, USA, 1982.
Milner, R., Operational and algebraic semantics of concurrent processes, in: Handbook of Theoretical Computer Science, Volume B: Formal Models and Sematics (B), Elsevier and MIT Press, 1990 pp. 1201–1242.
Park, D., Concurrency and automata on infinite sequences, in: Proceedings of the 5th GI-Conference on Theoretical Computer Science, LNCS 104 (1981), pp. 167–183.
Philippou, A., I. Lee and O. Sokolsky, Weak bisimulation for probabilistic systems, Lecture Notes in Computer Science 1877 (2000), pp. 334–349.
Segala, R., “Modeling and verification of randomized distributed real-time systems,” Ph.D. thesis, MIT (1995).
Segala, R. and N. Lynch, Probabilistic simulations for probabilistic processes, Nordic J. of Computing
2 (1995), pp. 250–273.
Segala, R. and A. Turrini, Comparative analysis of bisimulation relations on alternating and non- alternating probabilistic models, in: QEST (2005), pp. 44–53.
Trˇcka, N., “Silent Steps in Transition Systems and Markov Chains,” Ph.D. thesis, Eindhoven University of Technology (2007).
Vardi, M., Automatic verification of probabilistic concurrent finite-state programs, in: 26th FOCS
(1985), pp. 327–338.
