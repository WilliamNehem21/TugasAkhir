Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 346 (2019) 613–624
www.elsevier.com/locate/entcs

A Branch and Price Algorithm for List Coloring Problem
Mauro Lucci1,2 Graciela Nasini1,3 Daniel Sever´ın1,4
Depto. de Matem´atica, FCEIA, Universidad Nacional de Rosario, Argentina CONICET, Argentina

Abstract
Coloring problems in graphs have been used to model a wide range of real applications. In particular, the List Coloring Problem generalizes the well-known Graph Coloring Problem for which many exact algorithms have been developed. In this work, we present a Branch-and-Price algorithm for the weighted version of the List Coloring Problem, based on the one developed by Mehrotra and Trick (1996) for the Graph Coloring Problem. This version considers non-negative weights associated to each color and it is required to assign a color to each vertex from predetermined lists in such a way the sum of weights of the assigned colors is minimum. Computational experiments show the good performance of our approach, being able to comfortably solve instances whose graphs have up to seventy vertices. These experiences also bring out that the hardness of the instances of the List Coloring Problem does not seem to depend only on quantitative parameters such as the size of the graph, its density, and the size of list of colors, but also on the distribution of colors present in the lists.
Keywords: List Coloring, Branch and Price, Weighted Problem.


Introduction
The Graph Coloring Problem (GCP) models a wide range of planning problems such as timetabling, scheduling, electronic bandwidth allocation and sequencing. Some applications impose additional constraints to the GCP, giving rise to known variants such as Equitable Coloring, Precoloring Extension, (γ, μ)-coloring and List Coloring, see e.g. [1,2]. Actually, List Coloring generalizes GCP, Precoloring Ex- tension and (γ, μ)-coloring and has several specific applications such as channel al- location in wireless networks [3]. In many practical situations, colors have different weights (or costs) and it is required to find the coloring of minimum weight in- stead of minimum cardinality. Particularly, in [4], the design of workdays of drivers

1 This work is supported by grants ANPCyT PICT-2016-0410 and PID-UNR ING538.
2 Email: mlucci@fceia.unr.edu.ar
3 Email: nasini@fceia.unr.edu.ar
4 Email: daniel@fceia.unr.edu.ar

https://doi.org/10.1016/j.entcs.2019.08.054
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

in a public transport company is modeled as a Minimum Weighted List Coloring Problem (MWLCP).
Let G = (V, E) be an undirected simple graph and C be a set of colors. A coloring of G is a function f : V → C such that f (u) /= f (v) for every edge (u, v) of G. Given a coloring f of G, the class color of j ∈ C , denoted by f−1(j), is the set of vertices v colored by j, i.e. such that f (v)= j. Clearly, each class color is a stable set of G and, therefore, any coloring can be thought as a partition of vertices into stable sets. The active colors of a coloring f , denoted by A , are those ones
assigned to some vertex, i.e. A . {j ∈ C : f−1(j) /= ∅}. The GCP consists of
finding a coloring of G with minimum cardinality of A . This minimum is called the chromatic number of G, denoted by χ(G), and it is known that obtaining this number is NP-hard for general graphs.
Despite its hardness, the need of obtaining concrete solutions to numerous ap- plications motivated the development of several exact algorithms for GCP: combi- natorial branch-and-bound such as DSATUR [5,6], branch-and-cut BC-COL [7] and branch-and-price LPCOLOR [8,9,10].
In the case of BC-COL, an Integer Linear Programming (ILP) compact formulation (GCP-CF from now on) based on classic vertex-color assignment variables is used. Instead, LPCOLOR is based on set-covering ILP formulation (GCP-SC from now on), where each variable represents a stable set of G. As the number of variables is usually exponential in the size of G, the resolution of the linear relaxation of GCP-SC is addressed by a column generation procedure.
In List Coloring, each vertex v ∈ V has a preassigned list L(v) ⊂ C defining those colors that can be assigned to v. Formally, a list coloring of G is a coloring f of G with the additional condition that f (v) ∈ L(v) for all v ∈ V . Note that classic colorings of G are list colorings for which L(v)= C for all v ∈ V .
Given a vector w ∈ ZC , the MWLCP consists of finding a list coloring of G such that the sum of weights of the active colors, i.e. Σj∈A wj, is minimum. As colorings of G can be thought as particular cases of list colorings, MWLCP can be seen as
a generalization of a weighted version of GCP. However, this weighted version can
be trivially reduced to GCP since one can pick the cheapest χ(G) colors from C to obtain the coloring of minimum weight.
Clearly, MWLCP is NP-hard in general graphs since it generalizes GCP. How- ever, some known results reveal that MWLCP is indeed harder than GCP.
As a first remark, unlike GCP, which is feasible whenever |C |≥ χ(G), MWLCP can be infeasible even if |L(v)|≥ χ(G) for all v. A well-known example is presented in Figure 1 where the available colors for each vertex are enclosed in braces.
Actually, asking whether G has a list coloring is NP-complete even when re- stricted to instances where the size of lists is at most 3 and G is a cograph or complete bipartite [11]. In contrast, GCP can be solved on cographs and bipartites in linear time.
Another example where these problems differ in difficulty is when graphs are

{1,2}



{1,3}




{2,3}
{1,2}



{1,3}




{2,3}


Fig. 1. An infeasible instance

parameterized by treewidth. For a given graph G with fixed treewidth t, there is a dynamic programming algorithm that finds χ(G) in polynomial time, while asking if G has a list coloring is W[1]-Hard [12].
Formulation GCP-CP (resp. GCP-SC) mentioned above can be extended to the MWLCP in such a way that they coincide when applied to instances of GCP. In this work, we present these extended ILP formulations, respectively called MWLCP-CP and MWLCP-SC, and we develop a Branch-and-Price algorithm to solve MWLCP via MWLCP-SC, by following some ideas provided in [8]. However, we have to take into account some additional issues that arise from the difference between GCP and MWLCP. In GCP every vertex can be colored with any element of C and all colors have the same weight, thus making the colors indistinguishable from each other. Clearly, this property is not met for MWLCP forcing us to consider one variable for each stable set and each color in MWLCP-SC. In spite of that, we designed a mechanism to take advantage of those cases where the indistinguishability between colors is partially met. Feasibility is another issue, as mentioned before.
In Section 2, we formally present the ILP formulations MWLCP-CP and MWLCP-SC. In Sections 3 and 4, we explain the main components that define our Branch-and-Price algorithm: the way LP relaxations are solved, how columns are generated and how the node branching is performed. In Section 5, computa- tional experiments are conducted to evaluate the performance of our algorithm over random instances of different sizes and types. Finally, in Section 6, some conclusions are drawn.

ILP formulations for MWLCP
Consider an instance of the MWLCP, given by a graph G = (V, E), a set of colors C with weights wj ∈ Z+ for each j ∈ C and lists L(v) ⊂ C for each vertex v. W.l.o.g we can assume that G is connected and C =  v∈V L(v).
For each color j, let Vj = {v ∈ V : j ∈ L(v)}, Gj be the subgraph of G induced
by Vj, Ij be the set of isolated vertices in Gj and S (Gj) be the set of maximal stable sets of Gj.
The first formulation is based on GCP-CF [7]. We have a binary variable xvj, for each v ∈ V and j ∈ L(v), such that its value is 1 if and only if f (v) = j, and binary variables yj such that yj =1 if j is an active color in f . Then, the MWLCP

can be formulated as follows:
(MWLCP-CF) min Σ wjyj
j∈C

s.t.
Σ

xvj =1	∀ v ∈ V	(1)

Constraints (1) ensure that each vertex is assigned a color, (2) impose that no pair of adjacent vertices receive the same color (when that color is used), and (3) control the activation of yj when v is an isolated vertex in Gj.
The second ILP model corresponds to a formulation of colorings as covering of

vertices by stable sets, based on GCP-SC. Here, we have a binary variable xj
for

each j ∈ C and each stable set S ∈ S (Gj). Observe that, for any color j, its color class is a stable set from Gj and, unlike GCP, no more than one maximal stable set of Gj can be used by the covering. The following ILP model arises naturally:
min Σ wj	Σ	j


s.t.
j∈C
S∈S (Gj )

Σ

j∈L(v)
Σ

S∈S (Gj )
v∈S
j ≥ 1	∀ v ∈ V	(4)

Σ

S∈S (Gj )
j ≤ 1	∀ j ∈ C	(5)

j ∈ {0, 1}	∀ j ∈ C , S ∈ S (Gj)
Constraints (4) say that, for each vertex v, at least one stable set containing v is selected, while (5) allow to take at most one stable set for each color.
However, this formulation does not properly generalize GCP-SC in the sense that an instance of GCP gives rise to a model with many more variables than GCP-SC. As we have said in the introduction, GCP-SC takes advantage of the indistinguishability between colors. In order to overcome this drawback, we say that two colors j, k ∈ C are indistinguishable if wj = wk and Gj = Gk. Let C k = {j ∈ C : j, k are indistinguishable} and {C k : k ∈ K} be a partition of C where K ⊂ C . In other words, each k ∈ K is a color that represents those ones from C k.
Now, we can take advantage of the symmetry between those colors and allow the existence of at most |C k| stable sets of Gk instead of a single one. Moreover,

if |Gk| ≤ |C k|, such constraint can be removed since there is an optimal solution verifying this condition. Now, the MWLCP can be re-formulated:
(MWLCP-SC) min Σ wk	Σ	k


s.t.
k∈K
S∈S (Gk )

Σ

k∈K
Σ

S∈S (Gk)
v∈S
xk ≥ 1	∀ v ∈ V	(6)

Σ

S∈S (Gk )
xk ≤ |C k|	∀ k ∈ K : |Gk|≥ |C k| +1	(7)

xk ∈ {0, 1}	∀ k ∈ K, S ∈ S (Gk)
Therefore, for instances corresponding to GCP, we have K = {1} and C 1 = C . If, in addition, |C | ≥ |V (G)|, constraints (7) are no longer needed and our last formulation turns out to be the same as GCP-SC.
Solving LP relaxations of MWLCP-SC

Given an instance (G, C
.
, w, L) of MWLCP, let X =
{(S, k): S ∈ S (Gk), k ∈ K}.

The variables of the linear relaxation of MWLCP-SC are xk
for (S, k) ∈ X and

its constraints can be written as Ax ≥ 1, Bx ≥ −b and x ≥ 0 where, for every variable xk , the corresponding column in A is the characteristic vector of S and the columns in B have a non-zero entry, −1, in the row corresponding to k ∈ K.
Moreover, for each k ∈ K, bk = |C k|. Note that constraints of the form xk ≤ 1
are not necessary (non-negative weights ensure that at least one optimal solution verifies these conditions).
For any Xˆ ⊂ X, let x(Xˆ) be the vector of variables xk restricted to (S, k) ∈ Xˆ
and LP (Xˆ) be the linear relaxation of MWLCP-SC restricted to x(Xˆ). We first
give some results concerning the integrality of solutions of the LP relaxation, which will be used in Section 4.

Lemma 3.1 Let x∗ be an optimal solution of LP (X) and let X˜
= {(S, k) ∈ X :

|S|≥ 2}. If x∗(X˜) is integral then LP (X) has an optimal integer solution.

Proof. Consider the partition {X0,X+}
.
of X where X
. {(S, k): x∗k = 0} and

X+ = X \ X0. Clearly, x∗(X+) is an optimal solution for LP (X+). Since x∗(X˜)
is integral, variables from X˜ ∩ X+ are set to 1. Then, by replacing occurrences
of those variables by 1 in LP (X+), we obtain a linear program LPj over variables X+ \ X˜, such that x∗(X+ \ X˜) is an optimal solution for LPj. Observe that the stable sets represented by variables in X+ \ X˜ are singletons.
Let Aj and Bj be the submatrices of A and B corresponding to constraints
(6) and (7) in LPj, respectively. Since columns of Aj are characteristic vectors of singleton stable sets, they have one positive entry equal to 1. Similarly, columns of Bj have at most one negative entry equal to -1, thus implying that the matrix

of coefficients of LPj is totally unimodular. Therefore, there exist integer optimal solutions for LPj and also LP (X).	2

Note that when every Gj is complete, stable sets are singletons and X˜ the statement of the previous lemma. Then, we obtain:
= ∅ in

Corollary 3.2 If, for all j ∈ C , Gj is a complete graph, then LP (X) has an integral optimal solution.
Actually, Corollary 3.2 can be also derived from a reduction of MWLCP to the Minimum Weighted Perfect Matching Problem on Bipartite Graphs, described below.
Consider an instance (G, C , w, L) of MWLCP such that Gj is a complete graph for all j ∈ C . Observe that each color can be assigned to at most one vertex. Then, we can assume that |V (G)| ≤ C (otherwise, MWLCP would be infeasible). Let Z be a set of dummy elements such that |Z| = |C |− |V (G)|.
Now, consider the bipartite graph G˜ with vertex partition defined by V (G) ∪ Z
and C , and such that for all v ∈ V (G) and j ∈ C , (v, j) is an edge of G˜ if and only if
j ∈ L(v). The weight of (v, j) is wj. We also consider edges (z, j) for all z ∈ Z and j ∈ C with weight zero. Clearly, if f is a list coloring of G, there exists a perfect matching of G˜ containing edges (v, f (v)) for all v ∈ V (G) and edges (z, j(z)) for
all z ∈ Z and some j(z) taken from the non-active colors in f . The weight of this perfect matching coincides with the weight of the list coloring. Conversely, for any perfect matching M of G˜, edges (v, j) ∈ M for every v ∈ V (G) define a list coloring of G with the same weight that M . Moreover, G˜ has a perfect matching if and only if MWLCP is feasible.
In practice, this problem can be addressed much faster via the Hungarian Algo- rithm than by solving the LP relaxation.

Column generation
Let Xˆ ⊂ X, x∗(Xˆ) be an optimal solution of LP (Xˆ), and (π∗, γ∗) be the optimal dual solution of LP (Xˆ), where π and γ are the dual variables corresponding to
constraints (6) and (7), respectively (for those k ∈ K such that |Gk| ≤ |C k|, we

assume γ∗ = 0). Note that, for any (S, k) ∈
k	k  .

k
π∗ − (wk + γ∗).
X, the reduced cost of xS is cS =

v∈S  v	k
We recall that the x∗ obtained from x∗(Xˆ) by padding zeros, i.e. x∗(X \ Xˆ)= 0,
is feasible for LP (X) but not necessarily optimal. In order to know that, we have

to decide if there exists (S, k) ∈ X such that ck
> 0 or, equivalently, to solve the

following auxiliary problem:
(Aux)	∃ (S, k) ∈ X such that Σ

π∗ > wk + γ∗?

Clearly, (Aux) is equivalent to solve, for each k ∈ K, the Maximum Weighted Stable Set Problem (MWSSP) on Gk with weight π∗ for each v ∈ V (Gk).
Despite the MWSSP being NP-hard, the enumerative routine given in [9] shows to be reasonably fast when it is called by the branch-and-price algorithm. In addi-

tion, it is not always necessary to solve the MWSSP to optimality. One can stop the optimization as soon as a set S ∈ S (Gk) with weight greater than the threshold
k .	∗
T  = wk + γk is found.
Moreover, if we have Gk = Gl and Tk > Tl for some k /= l ∈ K, there is no
need to run the enumerative routine for Gl since the stable set found for Gk can be reused for Gl.
Although finding one column is enough for the column generation process, pre- liminary experiments have shown that incorporating many columns at the same time decreases the number of iterations of the process and, thus, the overall time. In our implementation, we search for (if exists) one entering variable per k ∈ K.
Observe that the column generation process needs to start with a set Xˆ ⊂ X
for which LP (Xˆ) is feasible. We recall that, unlike GCP, to know if an instance of
MWLCP is feasible is an NP-complete problem and the best algorithm that finds a list coloring, whenever it exists, is O(2n)nO(1) [13]. In the following section we propose an initialization procedure.


Initializing the linear relaxations
Our approach consists in extending the solution space by creating a dummy color per vertex. Given an instance (G, C , w, L) of MWLCP we generate an extended instance (G, C j, wj, Lj) where C j = C ∪ {dv : v ∈ V (G)}, wj = wj for all j ∈ C and
j = M for all v ∈ V (G), where M is a big number (e.g. M =1 + Σj∈C wj). In
addition, Lj(v)= L(v) ∪ {dv} for all v ∈ V (G).
Now, the linear relaxation obtained from the instance (G, C j, wj, Lj) is trivially

feasible since xdv
=1 for all v ∈ V (G) is a feasible solution which allows us to start

our column generation process. That is, Xˆ = {({v}, dv): v ∈ V (G)}.
It is expected that dummy colors will no longer be used as optimization proceeds. In fact, if some dummy color is still active in the optimal solution of the relaxation associated to the extended instance (G, C j, wj, Lj), then (G, C , w, L) is infeasible.
Preliminary experiments have revealed that starting with dummy colors is better than a feasible initial coloring, when the latter can be generated (there are heuristics algorithms that deliver list colorings, such as k-Greedy-List [14]). We speculate the cause of this may be that the initial columns yielded by such colorings are of poor quality, thus making the LP solver to perform more iterations.
Since our column generation process is embeeded in a Branch-and-Price frame- work, the subproblems we have to solve for each node of the B&B tree should correspond to new instances of the MWLCP. To achieve that purpose, we need to devise a robust branching rule. In the next section we present such a rule, adapting the one first proposed in [15] and used in [8] for the GCP.

A robust branching rule
The idea behind the rule given in [8] is to pick two non-adjacent vertices u and v and divide the space of solutions between those ones satisfying f (u) = f (v) (both share the same color) and those others satisfying f (u) /= f (v). Finding the optimal coloring in the latter case is equivalent to solve GCP on a graph obtained by adding edge (u, v) to G. In the former case, one has to solve GCP on a graph obtained from G by collapsing vertices u and v into a single one (that is, connecting u to every vertex from NG(u) ∪NG(v) and removing v, where NG(x) is the open neighborhood of x in G).
We follow the same strategy, with the additional condition that vertices u and v must satisfy L(u) ∩ L(v) /= ∅. Indeed, finding the optimal list coloring f of (G, C , w, L) with f (u) /= f (v) is equivalent to solve MWLCP for the instance (G1, C , w, L) where G1 = (V (G), E(G) ∪ {u, v}), whereas finding the optimal f with f (u) = f (v) is equivalent to solve MWLCP for the instance (G2, C , w, L2) where G2 = G \ {v} and u is connected to every vertex from NG(v), L2(z)= L(z) for all z ∈ V (G2) \ {u} and L2(u)= L(u) ∩ L(v).
Note that, in a finite number of applications of the previous rule, we get instances where all graphs Gk are complete. At that point, the optimal solutions of their LP relaxations are integers by Corollary 3.2.
In addition, due to the intersection performed to obtain L2(u), it is likely to reach subproblems whose instances have a vertex with a singleton list. Since such vertex is forced to be colored with the unique available color for it, the instance can be preprocessed according to the following result:
Lemma 4.1 Let (G, C , w, L) be an instance of the MWLCP such that L(u)= {j} for some u ∈ V (G) and j ∈ C . Solving (G, C , w, L) is equivalent to solve MWLCP for an instance (Gj, C , w, Lj) where Gj = G\{u}, Lj(z)= L(z)\{j} for all z ∈ N (u) and Lj(z)= L(z) for all z ∈ V (Gj) \ N (u).
Proof. If fj is an optimal list coloring of (Gj, C , w, Lj) then f (u)= j, f (z)= fj(z) for all z ∈ V (Gj) is an optimal list coloring of (G, C , w, L). Instead, if (Gj, C , w, Lj) is infeasible, (G, C , w, L) is also infeasible.	2
It only remains to specify a criterion for selecting vertices u and v, which we address below.
Branching variable selection strategy
In [8], a simple but efficient rule is proposed. We explain it briefly in terms of our formulation for the case K = {1} (superscripts are omitted). Assume that x∗ is a non-integer optimal solution of the LP relaxation. The authors first search for

the most fractional variable, i.e. an x∗
1
that minimizes |x∗
1
— 1 |, and pick u ∈ S1.

Since x∗
1
∈/ {0, 1} and (6) holds for u, there exists another S2 such that x∗  > 0

and u ∈ S2. Then, they search for the first vertex v such that v ∈ S1ΔS2 and, due
to the fact that stable sets are different from each other, such v exists and it is not adjacent to u.

In our case, we search for the most fractional x∗k
1
satisfying |S1| ≥ 2 and we

pick u ∈ S1. Lemma 3.1 guarantees the existence of such stable set (otherwise,
the solution would be integral). Now we need a pair (S2, l) such that S1 /= S2,

u ∈ S2, and x∗l
> 0. If such (S2, l) exists, we pick v ∈ S2 \ S1. Otherwise, we pick

v ∈ S1 \ {u}. In this way, we can assert that u and v are non-adjacent and satisfy the pre-condition L(u) ∩ L(v) /= ∅ since they must have colors k or l in their lists.

Computational results
This section is devoted to analyze the performance of the proposed Branch-and- Price algorithm over randomly generated instances, with number of vertices n ∈
{50, 60, 70} and edge probability p ∈ {0.25, 0.50, 0.75}.
Cardinality of C and distribution of colors in the lists are ruled by two pa- rameters c ∈ {0.5, 1.0, 1.5} and q ∈ {0.25, 0.50, 0.75}. The former is used to set C = {1,..., [cn♩}. The latter, which we refer to as membership-to-list probability, is the probability that a color j ∈ C belongs to L(v), for each v. Weights are set to 1 for all colors. Random numbers are yielded by an uniform distribution.
The experiment consists of comparing two approaches, which we call CPLEX- CF and BP-SC. In the former, the ILP solver of CPLEX (with default parameters) solve the MWLCP-CF formulation. The latter is our Branch-and-Price algorithm, which was manually implemented in C++ and uses CPLEX only for the resolution of LP relaxations. In order to speed up the generation of subproblems, we copy and perform minimum changes to the data structure where the instance lies. This saves time since it is not necessary to re-compute the partition of the set of colors nor the subgraphs Gk among them from scratch. Lemma 4.1 is applied during this stage. Then, subproblems are solved in a depth-first search fashion. Regarding the pricing routine, we traverse graphs Gk according to the value Tk in decreasing order, in order to avoid solving the MWSSP over the same graph more than once. On the other hand, our current implementation does not use the Hungarian Algorithm for the relaxations related to Corollary 3.2. This feature will be incorporated in a future version.
The experiment is carried out by a desktop computer equipped with an AMD Phenom II X4 3.4 GHz (a single thread is used), 3.6 GB of memory, Ubuntu 16.04 operating system, GCC 5.4.0 and IBM ILOG CPLEX 12.7 as the integer and linear programming solver. A time limit of 1 hour is imposed on solving each instance.
Results are summarized in Table 1. In each row, averages over 5 instances generated with the same combination of values (n, p, c, q) are reported: averages of CPU time (in seconds) for CPLEX-CF and BP-SC with best times highlighted, and average of number of nodes explored by BP-SC. Only instances solved to optimality within the time limit are considered in the averages. For those cases when at least one of the 5 instances is not solved, the number of solved ones is reported in brackets. If none of them is solved, a symbol “–” is displayed.
As we can see from the table, BP-SC achieves a remarkable performance, being able to solve to optimality 98% of the instances (397 of 405). In particular, all





0.25

70	0.50

0.75
0.5
1.0
1.5
0.5
1.0
1.5
0.5
1.0
1.5
8467
2669
4814
523
1506
661
59
64
77
388
3167
1853
2333
200
1506
68
40
52
1154.8(3) –
–
–
–
–
–
–
–
71	–
95	–
101	–
166	–
153	–
161	–
45	–
45	–
46	–

Table 1
Results on random graphs (average of 5 instances per row).

instances with 50 and 60 vertices can be solved in a couple of minutes. The same behavior is observed when increasing the number of vertices to 70 and considering an edge probability of 0.5 or 0.75 (medium to high density). In contrast, instances with edge probabilities of 0.25 (low density) are occasionally harder to solve, except when membership-to-list probability is high.
Note that the number of explored nodes is low, pointing out that the linear relaxations provide tight bounds and the node selection strategy is good enough, but also the resolution of each relaxation is very time consuming.
Regarding CPLEX-CF, we notice that it solves half of the instances within the time limit (202 of 405). One of the disadvantages of this formulation is the weak lower bound provided by the value of the LP relaxation. In fact, LP relaxations of BP-SC are 174% larger (in average) than those from CPLEX-CF, and this gap is accentuated as the size of the instance grows in any parameter (n, p, c or q). The peak is reached on instances with n = 70, p = 0.75, c = 1.5 and q = 0.75 where LP relaxations of BP-SC are 604% larger.
Although CPLEX-CF outperforms BP-SC in 5% of the cases, these ones usually have low density graphs and lists with a small amount of colors, making MWLCP- CF smaller in number of variables and constraints. In the case of BP-SC, the lower the density of the graph, the harder the resolution of the MWSSP on graphs Gk (whose tend to be sparse).
Last but not least, both approaches evidence perturbations in the performance not only when varying number of vertices and density but also when changing the

structure of the lists of colors. In the case of BP-SC, this behavior seems to be unpredictable. Even when we fix the number of vertices, edge probability and membership-to-list probability, the performance does not always get worse as the number of colors increases.
Conclusions
In this work, we present a Branch-and-Price algorithm to solve the weighted version of the List Coloring Problem, which has many applications and generalizes several other coloring problems. In order to achieve that, we propose a column generation process and a robust branching scheme based on the ones given in [8] for the GCP. In particular, when restricting to instances coming from GCP, our approach behaves just like LPCOLOR. However, other aspects should have been taken into account, such as the feasibility and the lack of indistinguishability between the colors. As far as we are concerned, this is the first exact algorithm based on ILP for this problem. The computational experiments show that our algorithm has a remarkable per- formance, being able to solve to optimality randomly generated instances up to 70 vertices and within a time limit of 1 hour. Our results also expose that the hardness of the instances does not seem to depend only on the generation parameters (n, p, c and q), but also on the distribution of colors present in the lists. In this respect, we believe that further research still remains to be done. Particularly, it should be studied how the structure of graphs Gk, i.e. size, density and overlap (number of vertices they share each other), influence the performance of the Branch-and-Price algorithm. A better understanding of tough instances can help to detect improve-
ment opportunities in our algorithm.
In future works, we plan to evaluate the performance of our algorithm over other types of instances. For example, by adding different weights to colors, varying the number of indistinguishable colors, using instances coming from applications (see e.g. [4]) and other coloring problems (e.g. Precoloring Extension, (γ, μ)-coloring) or by creating instances from benchmark graphs such as the ones from COLORLIB (DIMACS).

References
Kubale, M., Graph Colorings, American Mathematical Society (2004).
Bonomo, F., G. Dur´an, J. Marenco, Exploring the complexity boundary between coloring and list- coloring, Ann. Oper. Res. 169 (2009), 3–16.
Wang, W., and X. Liu, List-coloring based channel allocation for open-spectrum wireless networks, IEEE 62nd Vehicular Technology Conference, Dallas, TX, USA (2005), 690–694.
Lucci, M., G. Nasini, and D. Sever´ın, Planning the Workday of Bus Drivers by a Graph List-Coloring Model, Electronic Journal SADIO 17 (2018), 77–91.
Br´elaz, D., New Methods to Color the Vertices of a Graph, Commun. ACM 22 (1979), 251–256.
San Segundo, P., A new DSATUR-based algorithm for exact vertex coloring, Comp. Oper. Res. 39
(2012), 1724–1733.

M´endez-D´ıaz, I., and P. Zabala, A cutting plane algorithm for graph coloring, Discr. Appl. Math. 156
(2008), 159–179.
Mehrotra, A., and M. Trick, A Column Generation Approach for Graph Coloring, INFORMS J. Comput. 8 (1996), 331–437.
Held, S., E. Sewell, and W. Cook, Safe Lower Bounds For Graph Coloring, Lect. Notes Comput. Sc.
6655 (2011), 261–273.
Malaguti, E., M. Monaci, and P. Toth, An exact approach for the Vertex Coloring Problem, Discr. Optim. 8 (2011), 174–190.
Golovach, P., M. Johnson, D. Paulusma, and J. Song, A Survey on the Computational Complexity of Coloring Graphs with Forbidden Subgraphs, J. Graph Theory 84 (2017), 331–363.
Cygan, M., F. Fomin, L. Kowalik, D. Lokshtanov, D. Marx, M. Pilipczuk, M. Pilipczuk, and S. Saurabh,
Parameterized Algorithms, Springer International Publishing (2015).
Bjorklund, A., T. Husfeldt, and Mikko Koivisto, Set partitioning via inclusion-exclusion, SIAM Journal Comput. 39 (2009), 546–563.
Achlioptas, D., and M. Molloy, The analysis of a list-coloring algorithm on a random graph, 38th Annual Symposium on Foundations of Computer Science, Miami, FL, USA (1997), 204–212.
Zykov, A. A., On some properties of linear complexes, Matematicheskij Sbornik 24 (1949), 163–188.
