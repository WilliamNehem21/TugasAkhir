Electronic Notes in Theoretical Computer Science 180 (2007) 17–34	
www.elsevier.com/locate/entcs

Secured Information Flow for Asynchronous Sequential Processes

Isabelle Attali, Denis Caromel, Ludovic Henrio1 and Felipe Luna Del Aguila
INRIA Sophia Antipolis, CNRS - I3S - Univ. Nice Sophia Antipolis 2004, Route des Lucioles, BP 93 - F-06902 Sophia Antipolis Cedex, France
{ia, caromel, henrio, fluna}@sophia.inria.fr

Abstract
We present in this article a precise security model for data confidentiality in the framework of ASP (Asyn- chronous Sequential Processes). ASP is based on active objects, asynchronous communications, and data- flow synchronizations. We extend it with security levels attached to activities (active objects) and trans- mitted data.
We design a security model that guarantees data confidentiality within an application; this security model takes advantages of both mandatory and discretionary access models. We extend the semantics of ASP with predicate conditions that provide a formal security framework, dynamically checking for unauthorized information flows. As a final result, all authorized communication paths are secure: no disclosure of information can happen. This theoretically-founded contribution may have a strong impact on distributed object-based applications, that are more and more present and confidentiality-demanding on the Internet, it also arises a new issue in data confidentiality: authorization of secured information flow transiting (by
the mean of futures) through an unsecured component.
Keywords: Access control, distribution, objects, futures.


Introduction
The main contribution of this work is to provide data confidentiality and secure infor- mation flows for asynchronous distributed object-based applications. The proposed security model heavily relies on security policy rules with mandatory enforcements for the control of information flow. While information flows are generally verified statically [20,3,15,14,25,22,16,10], our attention is focused on dynamic verifications. To achieve it, our model has an information control policy that includes discretionary rules, and because these rules are by nature dynamically enforceable, we can take advantage of the dynamic checks to carry out at the same time all mandatory checks.

1 University of Westminster - Harrow School of Computer Science - Harrow, HA1 3TP (UK)

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.05.045

As another advantage of this approach, dynamic checks do not require to modify compilers, do not alter the programming languages, do not require modifications to existing source codes, and provide flexibility at run-time. Thus, dynamic checks fit well in a middleware layer which, in a non-intrusive manner, provides and ensures security services to upper-level applications.
Our underlying programming model [8] is based on active objects, asynchronous communications, and data-flow synchronizations. On the security side, security levels are used to independently tag the entities involved in the communication events: active objects and transmitted data. These “independent” tagging is however subject to discretionary rules. The combination of mandatory and discretionary rules allows to relax the strict controls imposed by the mandatory rules.

Overview
As activities do not share memory, our security mechanism associates a security level to each activity (an activity is a set of objects manipulated by a single thread). Ad- ditionally, a level can be associated to data transmitted between activities (request parameters and created activities). Our mechanism is based on the strict notions of “no write-down” and “no read-up” taken from the model of Bell-LaPadula [4], but discretionary rules allow to associate specific level to communicated data; thus avoiding restrictiveness of the above notions. Dynamic checks are performed at ac- tivity creation, request and reply communications. The advantages of this approach are twofold:
a sound foundation. This security model is founded on a strong theoretical back- ground, the ASP calculus [7,6], related to well-known formalisms [14,13,10,9]. We extend the formal semantics of ASP with predicate conditions. This provides a formal basis to our model, and makes it possible to dynamically check for unau- thorized accesses. Finally, in order to prove the correctness of our security model, an intuitive secure information flow property is defined and proved to be ensured by the application of access control model.
scalability and flexibility. We also target practical use of this model, with an implementation into middlewares, e.g. ProActive [21]. The granularity of our security model is defined in order to make it both efficient (because there is no security check inside an activity) and finely tunable: levels can be defined on activities but a specific level can be given to communicated data.
The impact of this work lies on the recent changes of paradigms in the area of distributed computing. The service oriented nature of ASP makes communications asymmetric (request and replies) and asynchronous. This security framework is, to our knowledge, the first to be adapted to the specificities of these communications. One of the main novel issues revealed by this work is the case of the first class futures (futures are promises of reply), and the fact that some secured information flows, impossible in other security frameworks, can be envisioned for secured asynchronous services.

Section 2 recalls our base model for objects and communications. Section 3.1 presents an access control model that can has been implemented for ASP. Section
3.2 defines and verifies an intuitive secure information flow property: an informa- tion flow is secure if all activity creations, requests and replies transmissions are secure. Section 3.3 analyzes the specificity of our security model for service-oriented computing. Next, relation to existing work is discussed in section 4. An appendix gives an example showing the kind of security policy we are able to ensure, and the specificity of our model.
A Model for Objects and Communications
distributed over (single threaded) activities, without shared memory. Activities communicate by asynchronous method calls, and reply by means of futures, thus leading to a data-flow synchronization. Futures allow latency hiding without loosing, neither ease of programming nor efficiency. This paper will soundly formalize the security of information flow for this recent programming methodology: asynchronous service-oriented programming.
Distributed Object Model
The ASP calculus is an extension of the impς-calculus [1] where asynchronous com- municating processes prevail. These processes, or activities, are running in parallel, but with their internal operations executed sequentially. What makes it outstanding are the concepts of active objects, wait-by-necessity, and futures. An active object is a “classical” object which is to be run remotely, in an activity, with its own sequential thread of execution. Table 1 presents the syntax of the ASP language. The classical sequential reduction rules for the semantics description can be found in [7].

Table 1
The ASP calculus syntax

It is important to note that an activity is composed of only one active object, many passive (i.e., classical) objects and also many references to other active objects. As an example, Figure 1 shows activities α and β, where activity α has (among other entities) its own active object, two passive objects and a reference to activity β. Additionally, there is no shared memory: passive objects can only be referenced

by objects belonging to the same activity, but any object can reference an active one.
One of the main contribution of ASP is the formalization of futures and request- reply patterns of communication. Futures are generalized references representing promises of reply that can be manipulated as a classical object (i.e. copied and transmitted inside and between activities) while their real value is not needed. An operation that needs the value of the object (e.g. a field access) is blocked until the necessary reply occurs. This automatic and transparent synchronization mechanism is called wait-by-necessity.


Fig. 1. Example of a parallel configuration

Recalling the ASP syntax and semantics, a parallel configuration is a set of activities (α, β, γ ∈ Act ) of the form:	P, Q ::= α[a; σ; ι; F ; R; f ]  β[··· ]  ··· where a is the current term to be reduced; σ is the store containing all objects belonging to activity α; ι is the active object location; F is the list associating each result of a served request to its futures; R is the list of pending requests; and f is the future of the current term. Additional semantic notations are: locations ι and future identifiers fi are local to an activity; a future fα→β is defined by an identifier fi, a source activity α and a destination activity β according to the request; a reference to the active object of activity α is denoted by AO(α); and a reference to a future is denoted by f ut(f α→β).
Informally, ASP semantics consists in partitioning objects into distinct activities manipulated by a single thread (no memory is shared). Those activities communicate by asynchronous request-response mechanism: When an object perform a method call an an active object (i.e., remote object), a request is enqueued on the callee side

and the caller receives a future (an empty object that will be filled with the result of the request).

Table 2 Parallel reduction


Communication Model
The ASP communication model is based on the parallel reduction rules shown in Table 2. These rules are based on a copy(ι, σ) operator which performs a deep copy of the store σ starting at location ι and Copy&Merge(σβ, ι' ; σα, ι) which appends, at the location ι of the store σα, a deep copy of the store σβ starting at location ι'.
From these reduction rules, only the communication rules (newact, request and reply) are involved in the security framework. The newact reduction rule creates a new activity γ containing the deep copy of an object. A generalized reference to this activity AO(γ) is stored in the source activity α. In the request reduction rule, activity α sends a new request to activity β. The new request [mj; ι''; fα→β] is made up of the target method mj, the location ι'' of the argument passed in the request message, and the future identifier fα→β which will be related to the response resulting from the request. Note that in location ι'' there is a deep copy of the argument passed to the target method. The reply reduction rule, takes a reference to a future and updates it with its value. The reference to the future must exist in one activity α and the corresponding value must have been calculated in another activity β. Note that a future fγ→β can be updated in an activity different
from the origin of the request (γ /= α).

The Security Model
In this section, we define a security model that guarantees the classic property of data confidentiality for multi-level security systems: a specific user with the appro- priate clearance will be given access only to the information that he/she is allowed to handle. This notion of data confidentiality must not be confused with the con- fidentiality provided by encryption mechanisms (i.e. information obscuring). The security terminology uses the subjects-objects relationship [24], and because the word “object” can be confusing here, we refer to this relationship as “subject-target”. We first recall usual notions of access control models and define our model in terms of entities and secured communications; which means that we formally ex- tend ASP into Secure ASP. Then, we present our notion of secure information flow between activities with an important property for data confidentiality. We finally point out a fundamental aspect of the expressiveness of our model for service-oriented
computing.
Access Control Model
Access control models are generally classified into mandatory (MAC) or discretionary (DAC) models. The MAC model can be best described through the Multi-Level Security (MLS) model which is based on a lattice of security levels assigned to sub- jects and targets. Once levels are assigned, neither “normal users” nor processes can change them; making the system more secure against unauthorized access to the information. The MLS model is suited to address the confidentiality issue in infor- mation flows, but its inconvenience is that in certain cases it is less than adequate for practical systems. DAC models are based on an access control matrix relating rights on subjects over targets, where the rights may be assigned at the “discretion” of the “normal users” or their processes; this simple form of operation makes it more flexible compared to MLS.
The solution we propose is based on the concepts of MLS, with analogous notions of “no write-down” and “no read-up” taken from the model of Bell-LaPadula [4], but it is generalized here by introducing exceptions according to discretionary rules.
We begin by describing all entities involved in our security framework:
S is the set of activities acting as subjects and/or targets: α, β, γ, ... ∈ S;
D is the set of objects sent in the arguments of REQUESTS; a REQUEST is now written as Rqα→β(d) where d = σα(ι') ∈ D,
R is the set of objects associated to futures, and returned in REPLIES; a REPLY is now written as Rpβ→α(r) where r = σβ(ιf ) ∈ R.
Let A be the set of actions involved in the security mechanisms, i.e., REQUEST, REPLY and NEWACT. The following notations are added to ASP:
Security levels λ are taken from a finite set L, partially ordered by the relation
≤, ∀i ∈S ∪ D ∪ R, λi ∈ L,
T ⊆ S × S × A represents the authorized actions (source, destination, action),

the matrix M : S × S→P(A) gives explicit (discretionary) rights to assign a level to a given data for a given action. For each subject-target pair, the matrix contains a set of authorized actions involving the assignation of a security level. P(A) classically denotes the set of sets of actions. The classic subject-target- action matrix is extended to include (allowed) security levels. This matrix can be implemented with a security policy file (e.g. XACML policy files [11]).
This results in the following characterization of actions:
Nw(γ, λγ) is a modified activity creation rule (NEWACT) in order to assign a security level λγ to a created activity γ,
Rqα→β(d, λin) is a modified REQUEST transmission rule tagging the transmitted data with a security level (the programmer gives a security level to data d),
Rpβ→α(r) is a REPLY transmission rule unchanged from original ASP.
To summarize, a ∈ A if and only if a = Rqα→β(d, λin) ∨ a = Rpβ→α(r) ∨ a = Nw(γ, λγ ). Moreover, to be precise, M only has values in REQUEST or NEWACT. That is to say, it is not possible in our model to give to replies a discretionary right. The security levels of subjects, targets, data and responses reflect the form of communications handled by activities. Figure 2 shows this form of communications. All activities are tagged with a security level and all objects and their methods therein contained will automatically inherit that level (a and b are objects, ms is the calling method of the source activity, and mt is the target method). Every data d used in a request transfer is also marked with a security level but this level is
independent from that of the source activity.




subject
target







Fig. 2. Communication between security-marked activities.

It is the programmer responsibility to assign the security level to data d. Conse- quently, the level of the transmitted data will be added to the syntax of the method call (see Table 3). Even if it is not detailed in the following, a default behavior should consist in assigning the level of the sender activity to data d sent as request parameter. In turn, every value r returned in a reply transfer will automatically be tagged with the security level of the target method (level inherited from the activ- ity). This form of tagging allows output data to be independent of input data in the processing method, in other words, the security level for the output data does not depend on the level of the input data but on the processing of the data itself.
The conditions for secure communications in ASP are then derived and formal- ized according to our policy for communications:

Definition 1 (Secure activity creation)
∀α, γ ∈ S, (α, γ, Nw(γ, λγ )) ∈T ⇐⇒ (λα ≤ λγ) ∨ Nw(γ, λγ ) ∈ M(α, γ)
An activity creation Nw(γ, λγ ) is authorized if the activity is created with a level greater or equal to the one of the source activity. Else, if α wants to downgrade the data (i.e., the objects) used to create this new activity then there must be an explicit right allowing such an operation.
Definition 2 (Secure request transmission)
∀α, β ∈ S, (α, β, Rqα→β(d, λin)) ∈T ⇔ (λin ≤ λβ) ∧
((λα > λin) ∧ Rqα→β (d, λin) ∈ M(α, β))

@∨ (λα ≤ λin)
γ→δ	A

∨ ∃γ, δ, fi, d = fut(fi	)

The request transmission Rqα→β(d, λin) is authorized if the security level λin of the transmitted data d, is smaller or equal to the security level λβ of the target activity β; or, when source activity α with level λα tries to assign a level λin to data d (i.e. a data downgrading), there is an explicit right (discretionary rule M(α, β)) that grants it. The philosophy behind a secure request transmission is to “release” information only to a target which holds the appropriate clearance.
We also have a safe request transmission if the security level of data λin is greater or equal than that of the source λα. In that case, we have λα ≤ λin ≤ λβ, showing that activity α safely releases data d because d has a greater security level, and at the same time, activity β receives a lower level data.
Moreover, a safe request transmission is also achieved when handling future references f ut(f γ→δ) as data. Future references can be freely transmitted between activities because they do not hold any valuable information. We recall that values associated to futures hold information but future references only hold addresses or directions pointing to futures. In this sense, if a future reference is known, it does not mean we can directly get the future value, because anyway, the future value transmission will be performed by, and submitted to the security rules of, a secure reply transmission.
Definition 3 (Secure reply transmission)
∀α, β ∈S : (α, β, Rpβ→α(r)) ∈T ⇐⇒ (λβ ≤ λα) ∨ (∃γ, δ, fi, r = f ut(f γ→δ))
The secure reply transmission REPLY Rpβ→α(r) is authorized if the security level λβ of target β is smaller or equal to the security level λα of subject α, or if the transmitted result r only consists of a reference to a future fγ→δ.
Table 3 shows the differences between the secure ASP calculus and the original one (Table 1): security information is added to the activation and method call terms.
After attaching a security level to each activity, parallel configurations are now of the following form:  P, Q ::= αλα [a; σ; ι; F ; R; f ]  βλβ [··· ]  ··· 
Finally, Table 4 presents the semantics of the secure parallel ASP calculus. These semantics rules ensure secure information flow. They use the security information



Table 3
Secure ASP calculus: modified primitives

Table 4
Secure parallel reduction rules
attached to the activation and method call terms (λa and λin in the Nw(γ, λa) and Rqα→β(d, λin) rules) to verify the secure transmission and activity creation defined before (Definitions 1, 2 and 3). When a communication is not authorized, from the formal point of view, it is simply blocked. In practice a dedicated exception should be raised and appropriately handled.
Secure Information Flow in the Object Model
We formally define the notion of information flow between activities. The considered entities are activities together with their passive objects, and not passive objects on their own. Because activities can be distributed, Non-Interference related notions
[12] can not be directly applied to our model.
Next, system-wide information flows are described by a path. The path is the route along which the information travels, it is constructed by a chain of communi- cating activities where a subject activity is the starting-point and a target activity is the end-point of the path. Each information transmission observed on each activity will serve for the construction of a path. This path will be called flow-path.
Flow-paths fp are lists of activities (fp := α.β. ··· ). They consist of the ordered list of transiting activities for a given information flow. For example ϕγ.δ(α, β) means that some information has been transmitted from activity α to activity β through activities γ and δ. Concatenation of flow-paths fp and fp' is denoted by fp.fp'. By application of the security mechanisms to the non-secure information flow and flow-paths, a first property results: previous definition of information flow for an activity becomes secure if all activity creations, requests and replies transmissions

are secure.
Definition 4 (Secure information flow) An elementary flow of information is either based on the sending of a request, or on the sending of a reply, or on the creation of an activity. A flow of information is sequentially composed of several elementary flows. The flow-path of any flow of information is the concatenation of
intermediate activities, it allows us to retrieve the original elementary flows. Secure information flow is built by concatenation of elementary secure information flows
which are secured communications: secure request, reply, or newact. Formally:


(α, β, Rqα→β (σ(ι'), λin)) ∈T 

Secϕ$(α, β)
(β, α, Rpβ→α(σα(ιf ))) ∈T 

Secϕ$(β, α)



(α, γ, Nw(γ, λγ )) ∈T 

Secϕ$(α, γ)
Secϕfp1 (α, γ)	Secϕfp2 (γ, β) Secϕfp1 .γ.fp2 (α, β)

The following property states that a flow of information is secured if and only if
it follows a secure path.
Property (Secure path for information flow) A flow of information is secured if and only if it is composed of elementary secure information flows.
Secϕγ1 ···γn (α, β) ⇐⇒ Secϕ$(α, γ1) ∧ Secϕ$(γ1, γ2) ∧ ··· ∧ Secϕ$(γn, β)
The proof of this property is straightforward; it is obtained by induction on the length of the information flow path and by a case analysis on the rules of Definition 4. This property does not take advantage of the MAC aspect of our model. Indeed, the same property could have been obtained with a purely DAC approach. This property rather shows that our specific and somehow less restrictive definition of information flow does not compromise secured information flow. A secured infor- mation flow property using the MAC aspect of our security policy is beyond the scope of this study. More generally, the study of the relation between mandatory
and discretionary rules is closely related to the work of Bertino et al. [5].
Compared with other solutions, our secure information flow is the simple compo- sition of a complex elementary flow. This results from the adaptation of the security formalism to a specific service-oriented framework. Complexity of the elementary flow comes from the asymmetric and asynchronous nature of ASP communications. Once such basic secure communications are ensured, the security of information flows is verified in a simple and intuitive manner. The soundness of secure infor- mation flow is thus ensured by a precise definition of information in the previous section and the fact that secure communications defined in Section 3.1 ensure that every information flow must verify the security policy.
Also note that the way our discretionary rights matrix is built allows to envision a precise tuning concerning the (dynamic) entities involved and the levels that can be assigned to data when downgrading them.

Specificity of Service-Oriented Computing
Preceding sections showed how classical MAC and DAC security principles can be adapted to ASP and extended, finally ensuring both flexibility and scalability.
Future references are first class objects and can be passed between activities (feature known as automatic continuations), thus they have an important conse- quence concerning the secured flows of information. Indeed, without automatic continuations, a flow of replies would directly follow the opposite path that a flow of requests. In other words, in a classical mandatory ruled system, a request-reply pat- tern of communications can only occur between entities that have the same security level.
A first contribution of this paper is to authorize discretionary exceptions to these rules concerning level of data transmitted by requests. This allows some request- reply pattern to occur when the request sends non confidential data.
	

Fig. 3. A classical example: delegation

The possibility to transmit future references leads to a model well adapted spe- cific to service-oriented computing. Let us focus on the configuration of Figure 3. This configuration can be obtained by a classical scenario: β makes a request to γ (future f2); but β is only an intermediate and delegates to δ the responsibility to calculate the final result (future f ' ). Let us suppose that λδ ≤ λβ < λγ, that is to say the intermediate activity γ has a (too) high security level (this may be the reason why the request has been delegated).
If one did not have automatic continuation, γ could not return the value of future f2 because it is a future reference to f ' . Anyway, δ can reply to γ (because λδ < λγ) but γ cannot forward this result value to β because λβ < λγ. Indeed, the derivation transmitting the result from δ to β cannot be derived by the preceding rules (not authorized means reduction rule cannot be applied):


		λδ < λγ	 (δ, γ, Rpδ→γ(result)) ∈ F  Secϕ∅(δ, γ)
not authorized


(γ, β, Rpγ→β (r')) ∈/ F 

Secϕ∅(γ, β)

Secϕγ (δ, β)
One could expect a better behavior because the direct reply from δ to β should be authorized according to the security model: δ cannot reply only because there is an intermediate activity γ. Indeed if the request had not transited by γ the reply

would be authorized. This is why the secured communication rules state that,futures can be freely transmitted (remember a future does not hold valuable information); consequently γ can reply to β if the response is restricted to a future reference. Afterward, δ can reply directly to β because λδ ≤ λβ, and β obtains the real value associated to f2.


r = f 'γ→δ

(γ, β, Rpγ→β (r)) ∈ F 
Secϕ∅(γ, β)
λδ ≤ λβ


(δ, β, Rpδ→β(r)) ∈ F 
Secϕ∅(δ, β)

This example justifies the possibility to freely transmit future references and demonstrates a communication pattern that would not be possible without the ex- pressiveness of futures and the specific secured rules that exist in our mechanism. Whereas, in ASP, the order in which future update occur has no consequence on the execution of a program, this example shows that in Secure ASP it is important to adopt a convenient future update strategy.
Related Work
Henessy and Riely present an extension of π-calculus [18,19], a calculus aimed at distributed systems, extended through the use of (security) types [14]. We do not employ explicit channels to communicate but the read and write actions are analo- gous to receiving or sending requests and replies (a read when the request or reply is received, and a write when the request or reply is sent). Additionally, their pro- cesses may be analogous to our activities, but in general the security policies are not compatible nor they can be encoded in our model even with analogous notions.
Bertino et al. [5] treat exception-based information flow controls in object- oriented systems. They extend close work from Jajodia, Kogan, Sandhu [17] and Samarati et al. [23] to include operations (exceptions) normally not allowed by the strict security policy. They use an ACL (discretionary control) to operate on write and create actions, and with the permissive exceptions, they relax the strict policy imposed on those same actions. The use of exceptions to alter the strict appli- cations mandatory rules of [5] is similar to the use of discretionary conditions in our framework. Both mechanisms allow one to bypass the rigorous application of strict/mandatory access controls.
Attali, Caromel and Contes present high-level rules which define a security policy for GRID applications built upon ProActive [2]. It is based on a discretionary approach where entities follow a hierarchical structure and relies on a Public Key Infrastructure. By comparison, our work focuses only on the communication actions, studies confidentiality in information flows specific to service-oriented applications, and uses both discretionary and mandatory approaches.
On the practical (implementation) side, Java-like languages that include infor- mation flow controls (as in [3,20]) could be complemented with our model. They control information flows inside a program, so they could be enhanced to control all communication interactions with other local and non-local programs, in either distributed or cooperative systems.

Comparing to previous work, Definitions 1 and 2 put together a combination of independent mandatory and discretionary controls, but the discretionary condition is evaluated only when the transmission involves a data downgrading case. This does not represent a standard way of policy enforcement because we also have the ability to verify the security level of a new activity (i.e. a whole entity which encapsulates data), and of a single transmitted data (i.e. data sent in requests). Moreover, definition 4 is implicitly based on the Bell-LaPadula model, where security at run- time takes into account a state machine with an initial secure state, and whose transitions from state to state are secure if the access rules are not violated.


Concluding Remarks and Future Work

We have presented a precise security model for the secure information flow in ASP. The solution is mainly founded on three cornerstones: the concept of flow of infor- mation, security levels attached to activities, and the definition of security rules to be applied to all communications.
The security policy (involving assignation, use, and definition of security lev- els) also takes into account the way information is handled in our model. When confidentiality is involved, there may exist high-level activities which may need to communicate with low-level activities (normally denied by the mandatory access rules of "no write down"). So by also tagging data with a security level we gain flexibility as the mandatory rules are not broken, and still, with the help of ad- ditional discretionary rules, we guarantee that this kind of actions are explicitly allowed. Communications are then controlled according to specific security rules. These rules are predefined in the case of mandatory rules, where the security levels of processes and data are always compared and applied; and in the case of discre- tionary rules, they are externally defined (for example in a file describing permissions for the whole system). By allowing discretionary exceptions to the mandatory rules, we obtain a highly expressive system. Consequently, the resulting properties are rather weak as we do not take advantage of the MAC aspect of our model; however, stronger properties could be guaranteed by imposing some consistency requirements to the DAC rules.
Finally, we have demonstrated the specificity of our security mechanism: its application to service-oriented computing with replies by the means of futures, and the specific issues that are arisen by our communication mechanism.
A prototype of this security model has been implemented in the ProActive mid- dleware [21] for distributed and mobile (Grid) computing, and is currently under evaluation on real-size examples for scalability and flexibility. In the future, it is planned to study more specifically moblility aspects and to use a role-based access control (RBAC) approach in order to extend and improve the discretionary access to activities.

References
Martin Abadi and Luca Cardelli. A Theory of Objects. Springer-Verlag, 1996.
Isabelle Attali, Denis Caromel, and Arnaud Contes. Hierarchical and declarative security for grid applications. In International Conference On High Performance Computing, HIPC, Hyderabad, India, December 17-20, Springer Verlag, 2003. Lecture Notes in Computer Science, LNCS.
Anindya Banerjee and David A. Naumann. Using access control for secure information flow in a java-like language. In 16th IEEE Computer Security Foundations Workshop (CSFW-16), July 2003.
David E. Bell and Leonard J. LaPadula. Secure computer system: Unified exposition and multics interpretation. Technical Report MTR-2997 Rev. 1, The MITRE Corporation, Bedford, MA, March 1976.
Elisa Bertino, Sabrina De Capitani di Vimercati, Elena Ferrari, and Pierangela Samarati. Exception- based information flow control in object-oriented systems. ACM Transactions on Information and System Security (TISSEC), 1(1):26–65, November 1998.
Denis Caromel and Ludovic Henrio. A Theory of Distributed Objects. Springer-Verlag, New York, 2005.
Denis Caromel, Ludovic Henrio, and Bernard Serpette. Asynchronous and deterministic objects. In 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2004, pages 123–134. ACM Press, 2004.
Denis Caromel, Wilfried Klauser, and Julien Vayssiere. Towards seamless computing and metacomputing in java. Concurrency: Practice and Experience, 10(11-13):1043–1061, 1998.
Agostino Cortesi and Riccardo Focardi. Information flow security in mobile ambients. In International Workshop on Concurrency and Coordination (ConCoord’01), volume 54 of Electronic Notes on Theoretical Computer Science. Elsevier, July 2001.
Silvia Crafa, Michele Bugliesi, and Giuseppe Castagna. Information flow security in boxed ambients. In Electronic Notes in Theoretical Computer Science, volume 66:3. Elsevier, 2002.
XACML	eXtensible	Access	Control	Markup	Language.
http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=xacml  .
Riccardo Focardi and Roberto Gorrieri. Classification of security properties (part i: Information flow). In Foundations of Security Analysis and Design (FOSAD 2000) - Tutorial Lectures, volume 2171 of Lecture Notes in Computer Science, pages 331–396. Springer-Verlag, 2001.
Matthew Hennessy. The security picalculus and non-interference. Journal of Logic and Algebraic Programming, 2003. To Appear.
Matthew Hennessy and James Riely. Information flow vs. resource access in the asynchronous pi- calculus. Computer Science Technical Report 2000:03, The University of Sussex, 2000.
Peter Herrmann. Information flow analysis of component-structured applications. In 17th Annual Computer Security Applications Conference. The Applied Computer Security Associates (ACSA), 2001.
Kohei Honda, Vasco Vasconcelos, and Nobuko Yoshida. Secure information flow as typed process behaviour. In Programming Languages and Systems, volume 1782 of Lecture Notes in Computer Science. Springer-Verlag, 2000.
Sushil Jajodia, Boris Kogan, and Ravi S. Sandhu. A multilevel secure object-oriented data model. In Marshall D. Abrams, Sushil Jajodia, and Harold J. Podell, editors, Information Security: An Integrated Collection of Essays, pages 596–616. IEEE Computer Society Press, 1995.
Robin Milner. Communicating and Mobile Systems: the π-Calculus. May 1999.
Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile processes, part I/II. 100:1–77, September 1992.
Andrew C. Myers. Jflow: Practical mostly-static information flow control. In 26th ACM Symposium on Principles of Programming Languages (POPL 99), pages 228–241. ACM Press, January 1999.
ProActive. http://www-sop.inria.fr/oasis/proactive/ .
Andrei Sabelfeld. The impact of synchronisation on secure information flow in concurrent programs. In 4th International Conference on Perspectives of System Informatics, volume 2244 of Lecture Notes in Computer Science. Springer-Verlag, July 2001.


Pierangela Samarati, Elisa Bertino, Alessandro Ciampichetti, and Sushil Jajodia. Information flow control in object-oriented systems. IEEE Transactions on Knowledge and Data Engineering, 9(4):524– 538, July-August 1997.
Pierangela Samarati and Sabrina De Capitani Di Vimercati. Access control: Policies, models, and mechanisms. In Foundations of Security Analysis and Design : Tutorial Lectures, volume 2171 of Lecture Notes in Computer Science, page 137. Springer-Verlag, 2001.
Steve Zdancewic, Lantian Zheng, Nathaniel Nystrom, and Andrew C. Myers. Untrusted hosts and confidentiality: Secure program partitioning. In 18th ACM Symposium on Operating System Principles (SOSP ’01), volume 35, pages 1–14. ACM Press, October 2001.

An Example
Context
We focus an a financial application specifically oriented to the stock market. The global scenario has the following actors: a stock exchange market, a few banks, and some clients. In this scenario, the main idea is to transform some source information in order to produce another type of information latter used as support in a trade decision process (e.i. decisions to make with respect to the buying and selling of actions in the stock market). In this sense, the stock exchange market will act as the provider of the raw or source information, transferring it to its direct clients, which in this case are the banks.



Bank A
trade study results




Client 1







Stock exchange market








raw

trade orders




Bank B







trade orders



Client 2



Client n

information
Bank C





Bank Z

Fig. A.1. Generalized business schema for a financial application.

By unfolding the general bank process (Figure A.1), we notice that it is composed of other subprocesses. Figure A.2 exposes with the BPMN notation the composition of a bank process. A reception process takes the information coming from the stock exchange, and according to some filtering and redistribution rules, it sends the possible narrowed information to its specified targets. The targets may be external business partners or they can be internal.
Following the bank’s internal or private workflow, after reception of the infor- mation by the stockbroker process, the provided information is passed to a statis- tic analysis, then confronted with historic forecasts, the result studied by market experts, producing buying and selling orders, which are finally sent to the stock exchange through the same initial stockbroker process. Finally, there is a new re- distribution of information executed by the trade orders dispatcher. In this new information distribution, the whole or part of the analysis results can be offered and







External entities

stock market

investment groups

bank’s own branches
other clients (individuals)

Fig. A.2. A bank’s private business processes.

sold to other kind of clients, meanwhile the stockbroker places the trade orders to the stock market. Moreover, the stockbroker process has two important activities, one is the reception of information, and the other is the reply to this reception with the trade orders.
An Implementation in Secured ProActive
The internal processes presented in the previous section are grouped into general processes corresponding to ProActive activities named E (experts), A (analysis), C1 and C2 (Communications), S (stock), I (investment), B (branch), and Clnt (client).
Figure A.3 shows the information flows translated into a ProActive communica- tion schema (based on REQUESTS –Rq– and REPLIES –Rp).

Fig. A.3. ProActive model for the banking process, with request and reply transmissions.

In the case of Rq1, S provides information to C1 in a "push" manner (through a repetitive transmissions of requests), a constant feeding of information can be done, and in consequence, there is no need of replies from C1 to S.

Emission of information from C1 to A is achieved with Rq2. Exchange of infor- mation between A and E is done with the pair Rq3-Rp3.
The communication between C2 and C1 requires a series of transmissions. C1 will require the results from C2 and will have to communicate through A and E. Then, with Rq4, C1 asks the results to A; with Rq4’, A demands the results to E ; in turn, with Rq4”, E communicates with C2 ; and finally, the response will return to C1 trough the corresponding replies.
Information from C1 to I and B is provided on demand, hence the respective pairs Rq5-Rp5 and Rq6-Rp6. Rq7 between C2 and Clnt follows the same methodol- ogy as Rq1. Finally, transactions of trade orders between C1 and S are accomplished with Rq8-Rp8.
From Figure A.3, the assignation of security levels is to be done, and depending on these affectations, entries for matrix M have to be added.
For the bank’s internal processes, let us define a relation of security levels with λE = λA > λC1 > λC2 meaning that, process E gets the highest security level because it represents the financial expert’s work; process A also gets a high level because it saves the results coming from E for the historic analysis; and process C1 gets the next highest level after A mostly because it has to manipulate the results or trade decisions. With respect to the security levels for the bank’s external processes, we suppose: λS > λC1 (the stock market requires to have a high level of protection), λI > λC1 (the investment group requires also a high level), λB = λC1 (considering the bank’s branches are "internal" processes), and λC2 > λClnt (the bank has a higher level of security than the clients).
Once the security levels are assigned to processes, REQUESTS are analyzed in order to determine what are the levels to be assigned to data transmitted, corre- sponding entries are also required for the discretionary access.

Table A.1
Summary of security levels assigned to the bank’s processes

Table A.1 gives the complete overview of security levels given to data, the re- quired entries for matrix M, and the values returned in the responses. From this table, in the case of request Rq1, by assigning to the transmitted data the same security level of the target (λC1), it is needed an entry or explicit rule, allowing communications from S to C1.
For request Rq2 there is no needed entry for the matrix, and also there is no reply.
In the case of request Rq3, there is no needed entry, and the corresponding reply will be the value of r (i.e. whatever value process E will return as result for this request). It is also shown the condition that allows the reply, which for Rq3 is because λE = λA.
For the combined case of the "fourth" request, replies to Rq4, Rq4' , and Rq4'' will contain the reference to a future (corresponding to the value to be produced by C2). Consequently the value of reply to C1 must be obtained directly from C2 by another reply Rp4''', and hence allowed to be transmitted because λC2 < λC1. Other replies must only contain informations stating aliasing between futures (e.g.
the value of future f 'A→E is the future f ''E→C2). Note that aother possible replies
4	4
go from E to C1, from C2 to A, but a reply containing the result from A to C1 is
forbidden, thus C1 must first receive aliasing informations stating that the future
f C1→A is the future f ''E→C2 before receiving Rp4'''.
4	4
For requests Rq5, and Rq6, there is no data transmitted in the request but they
both receive a reply value.
Rq7 is similar to Rq1.
This example shows the specificity of our security model. Considering secure path for information flow from C1 to C2, formally written SecϕA.E(C1,C2), the flow of information transits through high-level processes (i.e. processes A and E). Classically, these high-level process would block any subsequent communication be- cause of the "no write down" property (e.g. request Rq4'' is sending (or writing) data from a high to a low level process, and in consequence, it would be blocked). Nevertheless, the security model allows a safe communication from end-to-end (in this case between C1 and C2).
