

Electronic Notes in Theoretical Computer Science 253 (2009) 73–90
www.elsevier.com/locate/entcs
Compilation of Interaction Nets
Abubakar Hassan Ian Mackie Shinya Sato
Department of Informatics, University of Sussex, Falmer, Brighton, BN1 9QJ, U.K. LIX, CNRS UMR 7161, E´cole Polytechnique, 91128 Palaiseau Cedex, France
Faculty of Econoinformatics, Himeji Dokkyo University, 5-7-1 Kamiohno, Himeji-shi, Hyogo 670-8524, Japan

Abstract
This paper is about a new implementation technique for interaction nets—a visual programming language based on graph rewriting. We compile interaction nets to C, which offers a robust and efficient implementa- tion, in addition to portability. In the presentation of this work we extend the interaction net programming paradigm to introduce a number of features which make it a practical programming language.
Keywords: interaction nets, compilation

Introduction
Interaction nets [6] are a graph rewriting system where programs are represented as graphs and computation is based on graph rewriting. They enjoy good properties such as strong confluence, Turing completeness and locality of reduction. For these reasons, optimal [3,7] and efficient [9] λ-calculus evaluators based on interaction nets have evolved. Indeed, interaction nets have proved to be very fruitful in the study of the dynamics of computation. However, they are currently only useful for theoretical investigations.
In this paper we take a step towards developing a practical programming lan- guage for interaction nets. In the same way that functional languages are based on the λ-calculus, logic languages are based on Horn clauses, or the pict [10] language is based on the π-calculus, here we present a language based on this graph rewriting system and give a compilation into C.
There are several implementations of interaction nets [12,8,4,5], but they all suf- fer at least from one or more drawbacks: execution speed, lack of modern language constructs such as built-in types, input/output etc. The main goal of this paper is to address these issues so that we can shift the use of interaction nets from theoretical investigations to a practical programming paradigm. Firstly, we develop a textual

1571-0661© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.018

syntax for interaction nets with higher level constructs that provide programming comfort. We then show how this language can be compiled down to native codes via the C programming language [13]. We can use C as a machine independent low-level language that is well suited as a portable target language for the implementation of programming languages. Over the years, C compilers have gone through many im- provements to generate optimised machine code. By compiling to C, we also benefit in the improvements of C code generation. In addition, we gain instant portability because C is implemented on a variety of platforms. Many languages [15,1,14] have benefited from this line of compilation.
To summarise, the main contributions of this paper are as follows:
We extend the definition of interaction nets to allow: built-in data types and conditional rewrite rules; states and state transformers.
We define a compiler from interaction nets to native codes via the C language.
The extensions will break some of the main theoretical properties of interaction nets, but our computations stay deterministic since we fix a particular strategy. Interaction nets are one-step confluent, which means that all reduction sequences to normal form are the same length: by picking one at random we are not affecting the efficiency of the system.
In our previous work [4] we defined a textual language for interaction nets (Pin)
and described how it is transformed into an intermediate language. We then defined an abstract machine that executes Pin instructions. This paper is concerned with: developing a richer language for interaction nets, extending the language to cater
for the introduced source language constructs and compiling into C code.
In the next section we give some background material on interaction nets. We discuss our source language in Section 3. In Sections 4 and 5 we define the compila- tion schemes from our source language to C. In Section 6 we give the implementation details before concluding the paper in Section 7.

Interaction nets
Here we review the basic notions of interaction nets. We refer the reader to [6] for a more detailed presentation. Interaction nets are specified by the following data:
A set Σ of symbols. Elements of Σ serve as agent (node) labels. Each symbol has an associated arity ar that determines the number of its auxiliary ports. If ar(α) = n for α ∈ Σ, then α has n +1 ports: n auxiliary ports and a distinguished one called the principal port. Each agent may have attributes. In this paper, we will restrict attributes to just base types: integers and booleans, and we write the attribute in brackets after the name.

x1
···
,xn

	/
α(n)
 v J
We can represent this agent textually as x0 ∼ α(n)[x1,..., xn], where x0 is the

principal port.
A net built on Σ is an undirected graph with agents at the vertices. The edges of the net connect agents together at the ports such that there is only one edge at every port. A port which is not connected is called a free port. A set of free ports is called an interface.
Two agents (α, β) ∈ Σ × Σ connected via their principal ports form an active pair (analogous to a redex). An interaction rule ((α, β) =⇒ N ) ∈R replaces the pair (α, β) by the net N . All the free ports are preserved during reduction, and there is at most one rule for each pair of agents. The following diagram illustrates the idea, where N is any net built from Σ.

xn . ,,,/,. y1
xn  .
.  y1

.  α )( β	.
=⇒	.	.

x1 / J Jym
x1	ym

Figure 1 gives a simple example of an interaction net system that encodes the addition operation. We represent numbers using agents S and Z, corresponding to the usual constructors. Figure 2 gives an example reduction sequence that shows how a net representing 1 + 1 is reduced to 2.



Add
s
/
 J


Add
s
/
 J
,ˆ,


 ,J,
/s J


Fig. 1. Rules for addition

,ˆ,

,,	, ,J

,ˆ,

Add
Add	 J

,’,/s
 J
,ˆ,


 J
 `,,=⇒
 J
,ˆ,


 J
,’,/s
 J
 `,,=⇒
 J
,ˆ,


 J
,ˆ,


 J
,ˆ,

 J

Fig. 2. Example reduction sequence


The Source Language - INETS
Following [2], an interaction net system can be described as a configuration c = (Σ, Δ, R), where Σ is a set of symbols, Δ is a multiset of active pairs, and R is a set of rules. A language for interaction nets needs to capture each component of the

configuration, and provide ways to structure and organise the components. Starting from a calculus for interaction nets we build a core language. A core language can be seen both as a programming language and as a target language where we can compile high-level constructs. Drawing an analogy with functional programming, we can write programs in the pure λ-calculus and can also use it as a target language to map high-level constructs. In this way, complex high-level languages can be obtained which by their definition automatically get a formal semantics based on the core language.
We write nets textually as a comma separated list of agents. This just corre- sponds to a flattening of the net, and there are many different (equivalent) ways to do this depending on the order the agents are enumerated. As an example, we write the initial net in Figure 2 as:
a∼Add[x,y], a∼S[b], b∼Z, y∼S[v], v∼Z.
This can be simplified by replacing equals for equals:
S[Z]∼Add[x,S[Z]].
In this notation the general form of an active pair is α[.. .] ∼ β[.. .]. All variable names occur at most twice. If a name occurs once, then it corresponds to a free port of the net (x is free in the above). If a name occurs twice, then it represents an edge between two ports, in which case we say that the variable is bound.
We represent rules by writing l =⇒ r, where l is an active pair on the left of the rule, and r is the resulting net. In particular, we note that l will always consist of two agents connected at their principal ports. We also note that all rules can be written in a form α(..)[..] ∼ β(..)[..] =⇒ N , and as such we replace the ‘∼’ by ‘><’ so that we can distinguish an occurrence of a rule from an occurrence of an active pair. For example, the rules for the addition operation in Figure 1 can be represented using the syntax:
Add[x,y] >< Z =>	x∼y
Add[x,y] >< S[a] =>	x∼S[b], a∼Add[b,y]
or in a more compact way:
Add[x,y] >< Z =>	x∼y
S[a] =>	x∼S[b], a∼Add[b,y]
The names of the bound variables in the two nets must be disjoint, and the free variables must coincide, which corresponds to the condition that the free variables must be preserved under reduction.
The introduction of agents with values provide us with an efficient representation of data types in interaction nets. For example, we can represent numbers in a way that is directly supported by hardware rather than using S and Z agents. We also introduce a set of deterministic operations on the built-in data types: booleans, integers and characters. The example rule below shows how we can encode the addition operation in a way that is directly supported by hardware.

Fact[result] >< Num(int x) => if(x < 0)
result∼Error;
else	if(x == 0) result∼Num(1);
else
Fact[Mult(x)[result]]∼Num(x-1) ; Mult(int x)[res] >< Num(int y) =>
res∼Num(x*y);
main(){ Fact[result]∼Num(6);
}

Fig. 3. Example program: factorial




Add(int x)[res] ><	Num(int y) => res∼Num(x+y);





Conditional rewrite rules

We allow rules to contain multiple right-hand side (rhs) nets. If either (or both) of the interacting agents are holding a value, then we can use these values to give different rhs of the rule by specifying a condition. The conditions must be all disjoint (there cannot be two rhs nets that can be applied). During reduction, we evaluate the conditional expression to determine which net will be applied to an active pair. Proposition 3.1 shows that these conditional rewrite rules do not affect the Strong Confluence property of interaction nets. Figure 3 gives an example program that computes the factorial of a number. The rhs net for the rule between agents Fact and Num will depend on the value x.




State transformers
We allow our programs to be decorated with states and state transformers. For- mally, a State : Adr ‹→ V al is a partial function from (memory) locations Adr to (storable) values V al. A state transformer ST ∈ {agn, new, read} : State → (V al × State) is a function which given a state produces a value and a new state. The transformer agn updates the value at a memory location, new allocates a new

memory location and read reads the value at a given location:
⎧ (⊥, ⊥),	if y ∈/ dom(σ)
agn(x, y) σ =	(v, σ[x '→ v]),	otherwise
⎧ ⎪⎪⎩ where σ(y) = v
⎪⎪⎨ (⊥, ⊥),	if σ = ⊥

new x σ =
(⊥, σ[x '→ ⊥]),	otherwise
⎪⎪⎩ where x ∈/ dom(σ)
⎪ (⊥, ⊥),	if x ∈/ dom(σ)

read x σ = ⎪⎨ (v, σ)	otherwise
⎪⎪⎩ where σ(x) = v
We represent these transformers in our source language using:
stm ∈ ST ::= x = y | T x | x | stm;stm
where x=y represents agn(x, y), T ∈ {int,bool,char},T x is a declaration of a variable and represents the function new x. An occurrence of a variable represents the read operation and stm;stm represents a sequence of state transformers. State transformers defined in a rule will be executed either before or after reducing the active pair. The structure of a rule is given by:
α(..)[..] >< β(..)[..]  =⇒ stm1 N stm2
The sequence of statements stm1 will be executed before the application of the rule α, β and stm2 will be executed after the rewrite. The example in Figure 3 can be written with state decorations, as we show in Figure 4. In this example a global variable counter is declared that counts the number of interactions. When each rule is applied, the counter is incremented. The net named main is the entry point to the program. In the main net, we initialise the global variable counter followed by an active pair definition and a print statement.
Generally speaking, the use of states breaks the Strong Confluence property. Below we give an example program where the result depends on the evaluation strategy.
Boolean b;
P >< Q[r] => if(b) {r∼N1; b = false;} else r∼N2; P >< R[r] => if(b) {r∼N3; b = false;} else r∼N4;

main(){
b = true;
P∼Q[r1],P∼R[r2]; // reduces to r1∼N1,r2∼N4
// P∼R[r1],P∼Q[r2];	reduces to r1∼N3,r2∼N1
}

int counter;
Fact[result] >< Num(int x) => counter = counter + 1; if(x < 0)
result∼Error;
else	if(x == 0) result∼Num(1);
else
Fact[Mult(x)[result]]∼Num(x-1) ;

Mult(int x)[res] >< Num(int y) => counter = counter + 1; res∼Num(x*y);
main(){ counter = 0;
Fact[result]∼Num(6);
print "total number of interactions ",counter;
}
Fig. 4. Example program: factorial with state

However, if we restrict the use of states in our programs, we preserve this property.
Proposition 3.1 (Strong Confluence) Let each interaction rule be free from state transformers. For a net N without states, if N =⇒ N1 and N =⇒ N2 with N1 /= N2, then there is a net N3 such that N1 =⇒ N3 and N2 =⇒ N3.
Proof. Assume that N =⇒ N1 and N =⇒ N2 with N1 /= N2 by using the rules r1
and r2 respectively.
In the reduction steps, active pairs to which the rules are applied do not overlap because there is at most one rule for each pair of agents. The result of applying a rule to an active pair can be uniquely determined because: the operations for the attributes are deterministic, and conditions in a conditional rewrite rule are all disjoint. In addition, connections of auxiliary ports are preserved during rewritings. Therefore, N1 =⇒ N3 and N2 =⇒ N3 by using rules r2 and r1 respectively.	 

Evaluation Strategy
A net may contain more than one active pair, so reduction can proceed by alternative routes. In order to guarantee uniqueness of normal forms (in the sense that the same net will always give the same result), we give one simple reduction strategy which reduces a net to full normal form using a last-in-first-out (LIFO) order. We keep all active pairs in a stack and reduce them according to LIFO. We simulate this strategy using a big-step structured operational semantics:
⟨t ∼ u⟩⇓ ⟨Γ⟩

⟨Δ,t ∼ u⟩⇓ ⟨Δ, Γ⟩

where Δ, Γ are sequences of active pairs. Given a sequence of active pairs with the pair t ∼ u as the last in the sequence, we first reduce t ∼ u. If the reduction of t ∼ u creates a sequence Γ of new active pairs, we append these to the end of the original sequence. We assume that the active pairs in Γ are created in a deterministic way: agents connected to the auxiliary ports of an active pair are wired to the corresponding rhs net in a linear order and the next connection that creates an active pair is added to the top/end of the sequence.

Representing interaction nets in C

Definition 4.1 Let Loc ⊆ N be a set of memory locations. We define a set of agent nodes Agent = {(Id × P × V )} where Id ∈ Σ is an identifier that represents the name of the agent, V is the set of values that an agent holds, and P is a set of ports. Each port p ∈ P is a pair (la, n) where la ∈ Loc is a pointer to another agent node, n is the port that the other node connects to this. The heap H : Loc → Agent returns a node a ∈ Agent given some location l ∈ Loc.
We represent an agent node graphically using:

where ar is the arity of the agent. The port p0 represents the principal port. It is straightforward to represent this memory model in the C language. We use the following C structure to represent agent nodes 1 :


typedef struct Agent{ unsigned int Id; struct Port *port; union Val *val;
}Agent;
typedef struct Port{ unsigned int portNum; unsigned int agent;
}Port;
typedef union Val{ char char_value; int int_value; float float_value;
}Val;


We use a function mkAgent : Σ × N → Loc that given an Id and the arity will construct an agent node in the heap and return its location l ∈ dom(H). We define two functions that manipulate agent nodes:
connect : Loc × N × Loc × N → Void that connects two agent ports. For example, if we have the agents:
H(lα) = 

H(lβ) = 

1 there exists alternative representations which are more efficient in terms of memory.

then connect(lα, 1, lβ, 0) will transform the structure of the nodes to:

H(lα) = 

H(lβ) = 
where ar(α) = n , ar(β) = m. The updated nodes above represent the net α[β[s1,..., sm], t2,..., tn]. The function connect updates the connection in- formation in the ports of two agent nodes. We can represent this function using the following C macro definition:
#define connect(a1,p1,a2,p2)	\ heap[a1].port[p1].agent = a2; \ heap[a1].port[p1].portNum = p2; \ heap[a2].port[p2].agent = a1; \ heap[a2].port[p2].portNum = p1; \
if(p1 == 0 && p2 == 0) pushActive(a1,a2)
The conditional statement checks if we are connecting principal ports and subsequently pushes the two (interacting) agents into a stack S of active pairs. We can build nets using the instructions mkAgent and connect defined above.
Below we give an example sequence of instructions that will construct the net
p∼Add[S[Z],y] in memory. lAdd = mkAgent (Add,2) lS = mkAgent (S,1)
lZ = mkAgent (Z,0) connect(lAdd,1,l_S,0) connect(lS,1,l_Z,0)

Note that the ports which have no connections represent the interface of the net. The ports p and y are the free ports in the example net above. As another example, the cyclic net x∼B[x] can be represented using:
lB = mkAgent (B, 1)
connect(lB, 0, lB, 1)
The function getPort : Loc × N → Loc × N returns the connection informa- tion stored in a port of some agent. getPort(la, n) = (lb, m) where la,n ∈ Loc × N and lb,m ∈ Loc × N. As a consequence of the connect function, if getPort(la, n) = (lb, m) then getPort(lb, m) = (la, n). We can represent the function getPort using the following C macro definition:
#define getPort(a,p) (heap[a].port[p])
To represent a rule, we construct the rhs net of the rule and connect it to the auxiliary agents of the active pair. The rewiring is accomplished with the help of the function getPort which is used to fetch the auxiliary agents that will connect to the rhs net. As an example, the rule:
Add[x,y] >< S[a] => x∼S[b],a∼Add[b,y]

can be represented by the following sequence of instructions:
(lx, px) = getPort(laAdd ,1) ls = mkAgent(S,1) connect(ls,0,lx, px)
(la, pa) = getPort(laS ,1) lAdd = mkAgent(Add,2) connect(lAdd,0,la, pa) connect(lAdd,1,ls,1)
(ly, py) = getPort(laAdd ,2) connect(lAdd,2,ly, py)
where laAdd and laS are the locations of the active pair agents Add and S respectively.

Compilation
In this section we define the compilation schemes from our source language to C source code. We use existing C compilers to translate the generated C source files to native codes. When executed, the generated codes will build the corresponding net in memory and reduce it to full normal form.
The basic model is that we compile each rule and each net to a C function. The functions generated for rules take a pair of (active) agents as parameters. They contain code that will build the rhs net of a rule and wire it to the agents that are connected to the auxiliary ports of the active pair.

Runtime Environment
The compiled C files need to be linked with a run-time library. That library contains the internal INETS primitives, runtime error reporting routines and definition of the runtime data areas. The generated files contain a main method that calls for the initialisation of the three runtime data areas:
the heap H. All agents are allocated in the heap.
the evaluation stack S, contains pointers to active pairs. Evaluation pops a pointer to an active pair, evaluates the pair and pushes any newly created pairs into S. Thus, our default reduction strategy is based on a stack (LIFO).
the rule table R maps pointers to functions generated for the rules. The evaluation function examines this table to select the appropriate function to reduce a given pair.
We define R in C using:
typedef void(*RuleFun)(); RuleFun R[MAXRULES];
For simplicity, we assume a pre-defined constant MAXRULES that gives the maximal number of rules in a given program. When we compile a rule to a C function, we create an entry of the function name in the table R. We shall see later that function

names are formed from an ordered concatenation of active pair names. Since there can only be one conditional interaction rule for any pair of agents, all function names that are generated for a rule are unique. The injective function hash takes a string (function name) and returns a unique integer i, 0 ≤ i ≤ MAXRULES. The hash function ensures that each entry in R has a unique index.
The evaluation function eval reduces a given net to normal form. It pops an active pair (α, β) from S, examines the rule table R (by computing hash of the ordered concatenation of the active pair names (α, β)) to determine the appropriate function to invoke. The function is invoked with the arguments (α, β). Evaluation stops once S is empty.

Compilation schemes
Here, we present the compilation function T that will translate our source language into the intermediate language C. The environment Γ maps identifiers to memory locations l ∈ Loc. We write [] for the empty map and Γ(x) = ⊥ when there is no entry for x in Γ. We use the notation: Γ[x '→ s](z) = s (if z = x), or Γ(z) otherwise. The function fresh returns a unique string and is used to generate fresh variables for our target language. The notation {x} will replace the variable x with its actual value. For example, if x = “abc”, then “123{x}456” = “123abc456”. The given value of x may be an integer. We write {p1} + “str” to concatenate the value of the string variable p1 to the sequence of characters str.
The compilation of INETS into C is governed by the schemes: Tinet compiles a program, Texps compiles expressions, Tns compiles nets and Trs compiles rules. We will now look at each of these schemes in turn.
The scheme Tinet calls for the compilation of an INETS program composed of
a set of rules, nets and state declarations.
T	(Σ, ⟨e ,...,e ⟩, ⟨n ,...,n ⟩, R) = ⎧⎨ Texps(e1,... ek, ); Tns(n1,..., nn);

inet	1	k	1	n
⎩ Trs(r1); ... ; Trs(rn); initRules

where Σ is a set of symbols, r1, ..., rn = R are instances of rules, each ei is a state declarations and each ni is a net definition. The function initRules generates code that will fill the table R with function pointers.
initRules = let
p1 = “R[”+ hash({α1} + {β1})+ “] =”+ {α1} + {β1} + “;”;
··· 
pn = “R[”+ hash({αn} + {βn})+ “] =”+ {αn} + {βn} + “;”;
in “void initRules() {”+ {p1} + ... + {pn} + “}” end
where αi, βi are the interacting agents for each rule ri ∈ R. The string {α} + {β}
is an ordered concatenation of the active pair names.
The compilation scheme Tns(n1,..., nn) compiles a sequence of net definitions:
Tns(n1,..., nn) = Tn(n1); ... ; Tn(nn);

A net named myNet with formal parameters x1,..., xn and body P translates to a C function named myNet:

Tn(myNet(x1 : T1,..., xn : Tn){xs, es}) = let px = Texps(xs); pe = Teqs(es, ∅);
in “void myNet(T1 x1,..., Tn xn){”+ {px} + {pe} + “}” end

where the parameter xi is of type Ti and the body of the net contains a list of expressions xs and/or a list of active pairs es. We use the scheme Texps to translate the list of expressions and Teqs to translate the list of active pairs. A C function named main will be generated: “int main() {...}”, which is the entry point for the execution of our generated program and allow the codes to run as stand alone programs. Our main function simply calls for the execution of the codes generated for the main net.
The scheme Tt emits codes that will construct a term in memory. Given a term T which is not a variable, the scheme Tt generates code that will: create the root agent, construct the sub-terms ti that connect to the auxiliary port of the root agent, and finally connect the sub-terms to the appropriate auxiliary port. If ti is an agent α ∈ Σ, it will connect to its parent agent via its principal port (port 0).

Tt(α(e1 : T1, ..., em : Tm)[t1,..., tn], l, p, Γ) = let a = fresh;
pr0 = “int {a}= mkAgent("{α}",n,m);”;
prv = “heap[{a}].val[1].T1={e1};”+ ··· +“heap[{a}].val[m].Tm={em}; ”; (pr1, (l1, p1), Γ1) = Tt(t1, a, 1, Γ); ... ;
(prn, (ln, pn), Γn) = Tt(tn, a, n, Γn−1);
in ({pr0} + {prv} + {pr1} + “connect({a},1,{l1},{p1});”+ ··· +
{prn} + “connect({a},n,{ln},{pn});”, a, 0, Γn) end

where the expression ei is of type Ti.
The compilation of a variable x does not generate any code. We consider two cases to compile variable nodes: 1) when Γ(x) = ⊥, we create an entry Γ[x '→ (l, p)] that maps the variable name x to the location and port number of the (parent ) agent node that the variable wants to connect to. 2) when Γ(x) = (l2, p2), we use the pair (l2, p2) to connect to the parent node of the variable. This scheme provides a mechanism to connect the ports of agents in a direct way other than through variable nodes.
T (x, l, p, Γ) = ⎧⎨ if (Γ(x) = ⊥∨ x ∈/ dom(Γ)) then (−, l, p, Γ[x '→ (l, p)])
⎩ else let (lx, px) = Γ(x) in (−, lx, px, Γ[x '→ ⊥]) end

We use the scheme Texps to translate a list of expressions.
Texps(e1,..., en) = Texp(e1); ... ; Texp(en);



Texp
(e1 op e2) = ⎧⎨ let r1 = Texp(e1);	r2 = Texp(e2); in {r1} + op + {r2}
⎩ where op ∈ {+, −, /, ∗, =, <, >, <=, >=, %, ! =, ==} end

Texp(print e1,..., en) = 
⎧⎪ let r1 = Texp(e1); ... ; rn = Texp(en);
⎪⎨ in “printf(F ,{r1});”+ ... + “printf(F ,{rn});”
where F = “%d” if ri is an integer, F = “%c” if ri is a character
⎪
⎪⎩ end
Texp(n) = “{n}” where n ∈ Z or n is a variable name
Texp(T n) = “{T} {n};” where T ∈ {int, char, bool}
The scheme Teqs translates a list of active pairs. We use Teq to generate the code for each active pair.

Teqs(u1 ∼ v1,... un ∼ vn, Γ) = ⎪⎨

(prn, l, p, Γn) = Teq(un ∼ vn, 0, 0, Γn−1);

⎪⎪ in ({pr1} + {pr2} + ... + {prn}, Γn) end
For each active pair, we use the scheme Teq to generate the code for each inter- acting agent, which is given in Figure 5.

Teq(α(Vα)[u1,..., un] ∼ β(Vβ)[v1,..., vy], l, p, Γ) =
let (pr1, (l1, p1), Γ1) = Tt(α(Vα)[u1,..., un], l, p, Γ);
(pr2, (l2, p2), Γ2) = Tt(β(Vβ)[v1,..., vy], l, p, Γ1);
in ({pr1} + {pr2} + “connect({l1},{p1},{l2},{p2}); eval();”, l, p, Γ2) end
Teq(x ∼ α(Vα)[u1,..., un], l, p, Γ) =
let (pr1, (l1, p1), Γ1) = Tt(α(Vα)[u1,..., un], l, p, Γ); (pr2, (l2, p2), Γ2) = Tt(x, l1, p1, Γ1);
in ({pr1} + {pr2} + “connect({l1},{p1},{l2},{p2});”, l, p, Γ2) end

Fig. 5. Compilation scheme Teq



The compilation scheme Trs compiles a rule definition. We use the scheme Tr
to generate a C function for each binary rule. This function contains code that will

build the rhs net and wire it to the corresponding auxiliary ports of the active pair.
Trs(α(x1 : T1,..., xj : Tj)[t1,..., tn] >< e1 ..., em {r1,..., rk}) = 
⎪⎨	.
⎪⎪⎩ Tr(rk, α(x1 : T1,..., xj : Tj)[t1,..., tn], e1,..., en); where each ri is either of the form
β(y1 : Ty1 ,..., yn : Tyn )[s1,..., sn]⇒e1,..., ek, eqs, If
or
{e1,..., em, β(y1 : Ty1 ,..., yn : Tyn )[s1,..., sn]⇒em+1,..., en, eqs, If},
eqs = u1 ∼ v1,..., un ∼ vn,
If = If (b) eqs1 else If, eqs2.
In Figures 6 and 7 we gather together the remaining schemes that will generate the codes for a rule. We conclude this section with an example hand-compiled code generated for the main net given in the example program in Section 3.2:
void main(){ counter = 0;
int Fact = mkAgent("Fact",1,0); int Num = mkAgent("Num",0,1); heap[Num].val[1].int_value = 6; connect(Fact,0,Num,0);
eval();
printf("total number of interactions"); printf("%d",counter);
}

The implementation
Here we give a brief overview of the pragmatics of the language. We have imple- mented the compiler, and here we show example programs, the use of the system, and also some benchmark results comparing with other implementations of interac- tion nets. The prototype implementation of the compiler can be downloaded from the project’s web page 2 . The compiler reads a source program and outputs an executable file. Various examples and instructions on how to compile and execute a program are provided on the webpage.
The table below shows some benchmark results that we have obtained. We com- pare the execution time in seconds of our implementation (INETS) with Amine

2 http://www.interaction-nets.org/



Tr(β(y1 : Ty1 ,..., yk : Tyk )[u1,..., un]⇒ e1,..., ek, eqs, If,
α(x1 : T1,..., xl : Tl)[t1,..., tm], ek+1,..., el) = 
let a = fresh; b = fresh;
pr0 = “{Ty1 } {y1};”+ ... + “{Tyk } {yk};”+ “{T1} {x1};”+ ... + “{Tl} {xl};”;
pr1 = Texps(el,..., ek,..., e1);
pr2 = rewrite(β[u1,..., un], α[t1,..., tm], eqs, a, b, []);
pr3 = Tif (If, β[u1,..., un], α[t1,..., tm], a, b);
in “void {α} + {β}(int {a}, int {b}){”+ {pr0}+
“{y1} = heap[{b}].val[1].Ty1 ;” + ... + “{yk} = heap[{b}].val[k].Tyk ; ”+
“{x1} = heap[{a}].val[1].T1;” + ... + “{xl} = heap[{a}].val[l].Tl; ”+
{pr1} + {pr2} + {pr3} + “}”
where If = if (b) eqs1 else If, eqs2 eqs = u1 ∼ v1,..., un ∼ vn end

Tr({e1,..., em , r, em+1,..., en}α(x1 : T1,..., xn : Tn)[t1,..., tm]) =
Texps(e1,..., em);
Tr(r, α(x1 : T1,..., xn : Tn)[t1,..., tm]);
Texps(em+1,..., en);


Tif (if (b) eqs1 else If, eqs2, α[t1,..., tn], β[s1,..., sn], a, b) = let label = fresh; next = fresh; pr1 = Texp(b);
pr2 = rewrite(α[t1,..., tn], β[s1,..., sn], eqs1, a, b, []);
pr3 = Tif (If, α[t1,..., tn], β[s1,..., sn], a, b);
pr4 = rewrite(α[t1,..., tn], β[s1,..., sn], eqs2, a, b, []);
in “if (!{pr1}) goto {label};”+ {pr2} + “goto {next};”
“{label}:”+ {pr3} + {pr4} + “goto {next};”+ “{next}:” end
Fig. 6. Compilation of Rules



rewrite(α[x1,..., xk], β[y1,..., ym], t1 ∼ s1,..., tn ∼ sn, a, b, Γ) = let N = {x1 ..., xn}∪ {y1,..., ym};
Γ[x1 '→ (a, 1),..., xn '→ (a, n), y1 '→ (b, 1),..., ym '→ (b, m)]; (prt1 , (lt1 , pt1 ), Γ1) = Ttr (t1, −, −, Γ, N );
(prs1 , (ltn , ptn ), Γ2) = Ttr (s1, −, −, Γ1, N );
.
(prtn , (ls1 , ps1 ), Γj+1) = Ttr (tn, −, −, Γj, N );
(prsn , (lsn , psn ), Γk) = Ttr (sn, −, −, Γk−1, N );
in
({prt1 } + {prs1 } + “connect({lt1 },{pt1 },{ls1 },{ps2 });”+ ... +
{prtn } + {prsn } + “connect({ltn },{ptn },{lsn },{psn });”, l, p, Γ2)
Ttr (x, l, p, Γ, N ) = let (lx, px) = Γ(x)
pr1 = “Port p = getPort(lx, px);”; la = “p.agent”; pl = “p.portNum”;
in
if (Γ(x) = ⊥∨ x ∈/ dom(Γ)) then (−, l, p, Γ[x '→ (l, p)]) else if (x ∈ N ) then (pr1, la, pl, Γ)
else (−, lx, px, Γ[x '→ ⊥])
end
Ttr (α[t1,..., tn], l, p, Γ, N ) = let a = fresh;
pr0 = “{a}= mkAgent({α}, n);”;
(pr1, (l1, p1), Γ1) = Ttr (t1, a, 1, Γ, N ); ... ;
(prn, (ln, pn), Γn) = Ttr (tn, a, n, Γn−1, N );
in
({pr0} + {pr1} + “connect({a},1,{l1},{p1});”+ ... +
{prn} + “connect({a},n,{ln},{pn})”, a, 0, Γn)

Fig. 7. Compilation of Rules, continued

[11]—an interaction net interpreter. The last column gives the number of inter- actions performed by both INETS and Amine. The first two input programs are applications of Church numerals where n = λf.λx.fnx and I = λx.x. The en- codings of these terms into interaction nets are given in [9]. The next programs compute the Ackermann function defined by:
⎧ n +1 if m = 0 
A(m, n) =	A(m − 1, 1) if n = 0 and m > 0
⎪⎪⎩ A(m − 1, A(m, n − 1)) if m > 0 and n > 0
The following rules are the interaction net encoding of the Ackermann function:
Pred[Z] >< Z,	Dup[Z, Z] >< Z,
Pred[x] >< S[x],	Dup[S[a], S[b]] >< S[Dup[a, b]],
A[r, S[r]] >< Z,	A1[Pred[A[S[Z], r]], r] >< Z,
A[A1[S[x], r], r] >< S[x],	A1[Dup[Pred[A[r1, r]], A[y, r1]], r] >< S[y],
and A(3,8) means computation of A[S[S[S[S[S[S[S[S[Z]]]]]]]], r] ∼ S[S[S[Z]]].

We can see from the table that the ratio of the average number of interactions/sec of Pin to Amine is approximately 6 : 1. This performance is achieved partly because in our implementation, the indirection rule (see [2]) is performed at compile time. We represent interaction nets using undirected graph structure. In Amine, interaction nets are represented using tree data structures which introduces extra computational rules. Another major factor for this performance comes from the optimisations of the C code generator. C compilers have matured over many years and their optimisation techniques have advanced significantly. By using a C compiler to generate native codes, we benefit from the improvements of the compilers code generator. We have identified various optimisations (source to source optimisations, code and memory optimisations, etc.) for our source language and our compiler. With these optimisations in place, we anticipate to obtain better results.

Conclusions
In this paper we have presented our language for interaction nets, and given a compilation into C. We have implemented this language, which is available from the

web page: http://www.interaction-nets.org/, and is one of the main building blocks for building a programming environment for interaction nets. Current work is focussed on giving a formal operational semantics of this language, and also building a richer set of programming tools.

References
D. Diaz. Wamcc: Compiling prolog to c. In In 12th International Conference on Logic Programming, pages 317–331. MIT PRess, 1995.
M. Fern´andez and I. Mackie. A calculus for interaction nets. In G. Nadathur, editor, Proceedings of the International Conference on Principles and Practice of Declarative Programming (PPDP’99), number 1702 in LNCS, pages 170–187. Springer-Verlag, September 1999.
G. Gonthier, M. Abadi, and J.-J. L´evy. The geometry of optimal lambda reduction. In Proceedings of the 19th ACM Symposium on Principles of Programming Languages (POPL’92), pages 15–26. ACM Press, Jan. 1992.
A. Hassan, I. Mackie, and S. Sato. Interaction nets: programming language design and implementation. In Proceedings of the seventh international workshop on Graph Transformation and Visual Modeling Techniques, March 2008.
M. J.B. Almeida, J.S.Pinto. A tool for programming with interaction nets. Technical report, University of Minho, 2006.
Y. Lafont. Interaction nets. In Proceedings of the 17th ACM Symposium on Principles of Programming Languages (POPL’90), pages 95–108. ACM Press, Jan. 1990.
J. Lamping. An algorithm for optimal lambda calculus reduction. In Proceedings of the 17th ACM Symposium on Principles of Programming Languages (POPL’90), pages 16–30. ACM Press, Jan. 1990.
S. Lippi. in2 : A graphical interpreter for interaction nets. In S. Tison, editor, Rewriting Techniques and Applications (RTA’02), volume 2378 of Lecture Notes in Computer Science, pages 380–386. Springer, 2002.
I. Mackie. YALE: Yet another lambda evaluator based on interaction nets. In Proceedings of the 3rd ACM SIGPLAN International Conference on Functional Programming (ICFP’98), pages 117–128. ACM Press, September 1998.
B. C. Pierce and D. N. Turner. Pict: a programming language based on the pi-calculus. In G. D. Plotkin, C. Stirling, and M. Tofte, editors, Proof, Language, and Interaction, pages 455–494. The MIT Press, 2000.
J. S. Pinto. Sequential and concurrent abstract machines for interaction nets. In J. Tiuryn, editor, Proceedings of Foundations of Software Science and Computation Structures (FOSSACS), volume 1784 of Lecture Notes in Computer Science, pages 267–282. Springer-Verlag, 2000.
J. S. Pinto. Parallel evaluation of interaction nets with mpine. In A. Middeldorp, editor, RTA, volume 2051 of Lecture Notes in Computer Science, pages 353–356. Springer, 2001.
D. M. Ritchie. The c programming language, 1988.
D. Tarditi, P. Lee, and A. Acharya. No assembly required: Compiling Standard ML to C. Technical report, ACM Letters on Programming Languages and Systems, 1990.
G. Wong. Compiling erlang via C. Technical report, 1998.
