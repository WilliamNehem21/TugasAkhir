Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 279 (2) (2011) 17–31
www.elsevier.com/locate/entcs

Enhanced Type-based Component Compatibility Using Deployment Context Information 1
Premek Brada
Department of Computer Science and Engineering University of West Bohemia, Pilsen, Czech Republic brada@kiv.zcu.cz

Abstract
Consistency and compatibility in component-based applications have been the subject of many methods and approaches, from formally sound ones with difficult practical implementation to pragmatic rules for comparing version meta-data which offer only weak guarantees. This is especially true of many industrial component frameworks in routine use. In this paper we contribute a formal description of a method which ensures application run-time type consistency, by performing type-based substitutability checks as part of the component binding and update processes. The method takes into account the environment of the currently deployed component version and uses its so-called contextual complement in the checks. This novel approach overcomes the limitations of the standard notion of compatibility by allowing non-contravariant differences on the required side of the component’s surface. The method was successfully implemented for the OSGi component framework, and in later parts of the paper we share the experiences gained through the implementation.
Keywords: component, application consistency, subtyping, compatibility, deployment context


Introduction
Component frameworks have become commonplace in software engineering and are increasingly often used to develop software systems with complex architectures. More and more projects see the benefit of frameworks like Spring or OSGi [18] despite their relative simplicity in terms of the underlying component models.
Even though it is easier to manage complex architectures with components, safe evolution of these architectures — and preserving the internal consistency of the application throughout the evolution in particular — is still a challenging task. This is especially true for dynamic architectures (those which can evolve during

1 This work was partially supported by the Grant Agency of the Czech Republic under grant number 201/08/0266 “Methods and models for consistency verification of advanced component-based applications”.

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.11.009

application run-time) where changes cannot be fully anticipated by the architects and are not necessarily governed by any rules or patterns.
In our work we address the common scenario in which consistency verification is needed — the dynamic replacement of a component currently deployed in an architecture by another component, be it a completely different one (leading to the verification of substitutability ) or a new version of the current one (resulting in the verification of backward compatibility as a special case). The verification is governed by the general principle of substitutability, summarised by Wegner and Zdonik [25]: a replacement component should be usable whenever the current one was expected, without the client noticing it.
Goals and Structure of this Paper
Research approaches to safe substitution aim to ensure reliable substitutability by employing formal methods. However, the models used in these approaches tend to be too complicated to be usable by average software developers and the meth- ods often suffer from prohibitive algorithmic or space complexity (cf. for example [15,16]).
Industrial systems on the other hand almost exclusively use rather simple meta- data, most often version identifiers (e.g. [18]), to manually tag components as being compatible with their previous versions. The key disadvantage of this approach is fragility caused by the reliance on human effort to provide correct meta-data.
In this paper we describe a practically-oriented method of verifying substitutabil- ity of black-box components. It aims at being readily usable in today’s component frameworks with their relatively simple means of component specification while at the same time providing a high level of formally-backed assurance about substi- tutability.
The method therefore uses the (sub)type relation as its foundation since its formal strength is sufficient to prevent serious run-time errors while its evaluation can be done on current state of the practice component models, with relative sim- plicity and low algorithmic complexity. The method is only as strong in terms of formal verification of component’s substitutability as the component specification at hand allows. Mostly, it will therefore offer type-safety guarantees for current industrial component frameworks but it is able to incorporate the assessment of extra-functional properties compatibility [14] or advanced formal checking (e.g. to assert behavioural protocol compliance [19]) where appropriate data are available as part of the component’s specification.
A novel and significant aspect of the method is the possibility to overcome the limits of standard subtyping — strict covariance of provided and contravariance of required features — by considering the environment in which the components are deployed (e.g. the application architecture or component framework’s container), hereafter termed the deployment context.
The paper is structured as follows. The following section provides an overview of the state of the art in component substitutability. Section 3 contains foundational formal definitions of component type and deployment context, and section 4 defines

the notion of contextual substitutability.
The second part of the paper contains validation of the formal part. In section 5 we describe an implementation of the method for the OSGi component frame- work and discuss several fundamental issues we encountered. Both the formal and practical aspects of the method are evaluated in section 6, and the paper concludes with notes on the subsequent work.

Related Work
This work contributes to the challenging area of correctness and robustness in com- ponent frameworks “in the absence of a closed-world assumption” [22]. This is still a relevant issue, since for example Taylor [23] notes that in service-oriented architecture research there has been “little attention to orchestrating [architectural] changes across service (. . . ) boundaries”.
On a very high abstraction level, Georgas et al. [12] use a model of application architecture at run-time to manage its evolution. Constraints can be specified on the policies governing the evolution (adaptation) in order to preserve chosen archi- tectural properties. The work however does not provide concrete details about the model, the constraints and ways to check them.
Many research approaches have addressed this need using holistic approaches with global integrity properties [21,11]. Chaki et al. [9] for example use composi- tional reasoning and dynamic assume-guarantee checks to provide formally sound evaluation of substitutability with similar practical properties as our contextual one. Most of these methods are however based on advanced formal systems (e.g. model checking, behavioural subtyping) often supported by specialized specifica- tion notations. These methods tend to suffer from prohibitive algorithmic or state complexity [16,9] and the notations tend to be too complicated to be usable by
average software developers [15].
Few research works have been concerned with use in industrial component frameworks. Polakovic et al. [20] implement architectural consistency checks for a resource-constrained component model, using a combination of compile-time type conformance verification and error handling code. Our approach would be hardly feasible in such cases due to the resource demands.
The work closest to ours in its spirit is Belguidoum and Dagnat’s [3] which extends an earlier version of our contextual substitutability [5] with the notion of forbidden dependencies. This prevents multiple conflicting implementations of the same component feature (e.g. a messaging service) to invalidate context invariants. While this is an important observation, the substitutability itself is formalized on a rather abstract level and further refinement of service comparison methods, effects of component (de)installation, and forbidden dependencies representation is needed for a full applicability of the approach.
Last but not least, several methods that use type systems have been proposed [11,17]. They moreover enable multi-component substitution which goes beyond our method proposed in this paper. However, their approaches have not been validated

on industrial component frameworks.
Component Type and Deployment Context
To provide a sound basis for type-based substitutability and compatibility verifi- cation, a formal model at the type level of the compared components has to be available. In this section we describe such a model together with the representation of component’s view of its deployment context.
Type Representation of Component Interface
A component implementation, available in some form of distribution package, may comprise many different elements — executable code, meta-data, resource objects, etc. All elements that are part of the component’s interface (i.e. are accessible on the surface of the component’s black box) may participate in inter-component interactions — both the provided ones, used by component’s clients, and required ones, which express component’s dependencies that need to be satisfied in order to guarantee the provided functionality or properties.
We capture the structure of the component interface in the form of component type, a structured data type [8] which contains all such elements and their role with respect to inter-component interactions. The information about the component and its interface elements is assumed to be available from some kind of specification; the internals of the implementation are abstracted from since the component is a black box.
Definition 3.1 A component interface element is a tuple e = (n, T, r, o, a) where n ∈ String ∪ {ϵ} is the element’s name (possibly empty), T is element’s type (in the respective specification language type system), r ∈ {provided, required} is the element’s role on the component interface, o ∈ Boolean is an indication whether the presence of the element at run time is optional, and a ∈ N ∪ {∗} denotes arity (how many counterpart elements can be bound to it; ‘*’ stands for “any”).
Examples of component interface elements are: a named OSGi service typed to an interface or class, a Java interface implemented by a EJB component (in this case e.n = ϵ) 2 , or property with a primitive type of a SOFA component. Optionality of the element can be indicated directly in the component specification (as in OSGi “optional” directive on imported packages or similar Fractal attribute of a component’s interface) or via element cardinality.
Definition 3.2 Let EC = {ei}i∈I (for a finite index set I) be the set of all compo- nent interface elements of a component implementation C which can be observed from outside of its black box.
The component type C of C is a pair of provided and required element sets:
C = (EP , ER) | (EP ∪ER = EC) ∧ (EP ∩ER = ∅) where (∀e ∈ EP : e.r = provided)

2 Notational remark: Throughout the text, we use the dot notation to denote the individual parts of a tuple, so for A = (a, b) the expression A.a denotes the first part of A’s structure.

Λ (6e ∈ ER : e.r = required).
The component as a run-time instance of C is a tuple c = (id, C, P, R) where id is a unique identification of the instance, C its component type, P and R are the sets of interface elements actually present at the instance’s interface. (We will abbreviate the expression “component C with type C” to just “component C” where unambiguous.)
The element role (provided, required) is distinguished in the component type for a fundamental reason: it affects handling of component during type operations, namely matching and subtype comparison. In this respect this definition of compo- nent type and its associated (sub)typing rules, while similar to standard structured data types, reflect the core notion of component-based programming.
The latter two parts of the component’s tuple represent its effective type at the given time. It holds that c.P ⊆ c.C.EP and c.R ⊆ c.C.ER because (some of) the optional elements may be omitted by the instance. We note further that the set of c’s interface elements may change in time, i.e. Et1 /= t2 · c.P/t1 /= c.P/t2 and likewise with c.R.
The subtype relation for interface elements is the standard reflexive transitive one, so it is a preorder on types:
Definition 3.3 We say that component interface element ei is a subtype of ele- ment ej (denoted ei <: ej) if all of the following conditions hold:
ei.T <: ej.T (the element types are in a subtyping relation);
ei.r = ej.r;
⎧⎨ чej.o ⇒ ei.o = false if ei.r = provided,
⎩ ej.o ⇒ ei.o = true	if ei.r = required;
⎧⎨ ei.a ≥ ej.a if ei.r = provided,
⎩ ei.a ≤ ej.a if ei.r = required.
The next subsection formalizes the representation of the environment in which a component is deployed.
Component Context
We noted in the introduction that it is useful to capture the deployment environ- ment of a particular component for evaluating substitutability. This component deployment context contains the other components and architectural connections within the environment in which the component is employed. The environment can be a component cluster (a closely coupled part of a component application), the component-based application or the whole run-time environment surrounding a deployed component in the run-time framework.
Definition 3.4 The deployment context of a component instance c is a tuple
D = (K, B) where K = {ci}i∈I , c ∈ K is the set of components existing in the

deployment environment of c, and B = {(ep, er) | ECp, Cr ∈ K · (Cp /= Cr) Λ (ep ∈ Cp.P ) Λ (er ∈ Cr.R) Λ er is bound to ep} are the bindings between component elements within the context.
A deployment context D is architecturally consistent if all the inter-component bindings are correctly resolved (including the matching of types of bound elements) and the components are correctly functioning.
A subset of this environment which is particularly interesting from the sub- stitutability point of view is a component’s complement within the deployment context. The model of the complement uses the same abstractions as that of the component type described in the previous subsection.
Definition 3.5 Assume an architecturally consistent context D and component c ∈ D.K with component type C. The contextual complement of c in D is a “virtual” component type C¯D = (P¯, R¯) such that
P¯ = {e | (Ecr ∈ D.K · cr /= c, e ∈ cr.R) Λ (Eep ∈ c.P · (ep, e) ∈ D.B)} – this set consists of the actual client elements of c’s provided ones.
R¯ =	s cs.P | cs ∈ D.K, cs /= c – this set consists of all elements available in D
which can satisfy a component’s requirements;
The complement can be seen as an inverted effective type of c at the given time
(cf. the P, R element sets of the component instance). It captures the following two aspects of the context from the point of view of the component:
The real usage of the component’s provided elements, as given by the bindings to particular required elements of other components.
The elements available in the environment that can possibly satisfy any c’s substitute component’s requirements, most commonly via other component’s provided elements.

Fig. 1. Component in an architecture and the elements forming its contextual complement
Several interesting observations can be made about the contextual complement from typing perspective. They are summed up in the following lemma.
Lemma 3.6 (Properties of contextual complement) Assume a component c with type C = (P, R) and its contextual complement C¯D = (P¯, R¯) according to the deﬁnitions above. Let Pj = {ej | (ej ∈ P ) Λ (Ee¯ ∈ P¯ · (ej, e¯) ∈ D.B)} be the set of actually bound provisions of C. Then it holds that

Pj ⊆ P (not all provisions need to be bound).
6e¯ ∈ P¯, e ∈ P · (e, e¯) ∈ D.B : e.T <: e¯.T (context’s bound required elements can have generalized types).
6e ∈ R · e.o = false ER¯e ⊆ R¯ such that R¯e /= ∅Λ 6e¯ ∈ R¯e : e¯.T <: e.T (all
component’s mandatory requirements are satisﬁable by the context, via one or more elements with possibly specialized types).
Proof. The proof of these properties is straightforward:
If all e ∈ c.P are bound to client elements in the context, then Pj = P ; otherwise, |P|− |P j| is the number of unbound provided elements.
Assume there is a required element e¯x of some component cx ∈ D.K bound to a provided element e of c (consequently e¯x ∈ R¯) such that e¯x.T <: e.T . Then the binding of the provided e to the other component’s required e¯x would be type-unsafe, since e cannot cover all the type features of e¯x. This violates
the assumption of architectural consistency of the deployment context. (In practice, the run-time framework would decline to establish such binding a- priori.)
(a) Assume P¯e = ∅, meaning the non-optional required element e isn’t bound to any corresponding provider. This again violates the architectural consistency assumption. (b) Assume e.T <: e¯.T which is a situation analogical to point 2. The type unsafety of the binding between e and e¯ would eventually lead to a malfunction of c, which contradicts the assumptions (with the same practical interpretation).
2
Note finally that the P¯ captures the real types of elements bound to the actually used c.P elements, not simply the types of these, and that there is no requirement for element name uniqueness in the P¯, R¯ sets.
The idea of component’s complement and its properties is illustrated on Figure
1. Component Gate is deployed in a simple architecture, bound to the Control and ParkingPlace components. An additional TrafficLane component is installed in the run-time framework. The deployment context of Gate comprises the two counterparts of its provided interfaces in the R¯ set, and the three other provided interfaces available in the framework as its P¯ set.
Component Substitutability
The principle of substitutability introduced in Section 1 provides a very general definition of the notion. In the context of component-based software engineering, it can be elaborated upon by taking into account the features available in the current state-of-the-art component models.
The replacement component is substitutable for a component currently deployed in a consistent application architecture if it satisfies the following general require- ments [4]:

Presents the same operational interface (at the syntactic and typing level) to its environment.
Exchanges the same data (with respect to their location and format) as the current one.
Conforms to the semantics and behavioural specifications of the current com- ponent in all interactions in which it is engaged.
Exhibits compatible extra-functional (quality of service) characteristics.
In the approach presented here we concentrate on the first area, which is a deliberate simplification of the issue. The rationale for this decision is based on the challenges faced when working with industrial component frameworks. There, specifications of advanced aspects are not available or cannot be reconstructed from implementation in most cases; therefore, especially semantic compatibility is hard to verify.
We therefore need to base the formal notion of substitutability only on such artifacts and abstractions that are products of standard component development process. This lead us to (a) working with information directly available in the component distribution package — semi-formal component interface specifications, possible meta-data created during development, and data extracted by run-time component introspection; (b) using the least common denominator of the formal foundations — the type system and its subtyping rules — which are always available for any programming or specification language and provide a reasonable degree of trust in the conclusions as to the run-time safety of substitute component.
Let us now define the basic kind of type-based substitutability (presented in earlier versions in [6]). The following section then presents the novel kind of substi- tutability which considers the deployment context.
Definition 4.1 We say that a (replacement) component type R = (P j, Rj) is strictly substitutable for the (current) component type C = (P, R) if (6e ∈ P Eej ∈ Pj : ej.n = e.n Λ ej <: e) Λ (6ej ∈ Rj Ee ∈ R : ej.n = e.n Λ e <: ej). This fact is denoted as R ≺ C.
The definition corresponds to the natural understanding of “vertical” compat- ibility [3]: the replacement component provides at least the same, and requires at most the same, component interface elements with respect to their names and types (irrespective of element’s optionality). It uses the common notion of co- and contra-variance at the component type level (cf. [24] or [7]). This definition ensures a-priori substitutability of any pair of a component instance and its replacement which have the types C and R.
Contextual Substitutability
The principle of substitutability tells us that this property does not concern just the two components (current, replacement) in question: we also need to take into account their use by clients. From this point of view, changes in the provided and required parts of component interface do not affect substitutability equally.

In many component-based architectures not all of the component’s provided features are utilised, i.e. bound to clients. On a case-by-case basis, these unused features can therefore be omitted when evaluating substitutability in the given de- ployment context. Similarly, it is common that new features are added during component evolution which results in the need to add corresponding dependencies to make them work. In the programming language research this led to the notion of covariance. In the case of deployed software components, we can take the advantage of the knowledge of deployment context and match the replacement component’s extended requirements with any of those provided by the context’s components.
From the architectural point of view this is a clean solution since the component should be agnostic of who is providing the required functionality, as long as it conforms to its stated specification. This leads to the following definition:
Definition 4.2 Given a currently deployed component c with type C and its con- textual complement C¯D, we say that the (replacement) component type R = (P j, Rj) is contextually substitutable for C if it holds that R ≺ C¯D that is if (6e¯ ∈ P¯ Eej ∈ Pj : ej <: e¯) Λ (6ej ∈ Rj Ee¯ ∈ R¯ : e¯ <: ej). This is denoted R ≺D C.
In plain words, the contextually substitutable replacement component provides at least the same features as are those used by the clients of the current one, and requires at most what is available in the context. It can be said it is horizontally compatible [3] with the context.

Fig. 2. New component version vs. the contextual complement of the currently deployed one
Continuing with the example introduced in the previous section, Figure 2 shows a second version of the Gate component that should replace the original one. Its requirements are clearly greater than those of the original version, moreover one of the provided interfaces has changed its type. However, comparing Gate v2 to the contextual complement of its currently deployed version shows that it can actually be used in the given architecture (provided the LaneGateStats interface isa subtype of CountingStats).
Intuitively, one would expect that strict substitutability implies contextual.
Proposition 4.3 (Strict substitutability implies contextual) Assume components c and r with types C and R respectively. It holds that 6D · c ∈ D.K : R ≺ C ⇒ R ≺D C, i.e. if R is strictly substitutable for C then it is also contextually substitutable for C in any architecturally consistent deployment context D.

Proof. We first need to prove that 6D : C ≺D C¯D meaning that C “fits in” its (any) context. Using the standard notation C = (P, R) and C¯D = (P¯, R¯) this can be done in two parts:
6e¯ ∈ P¯ Ee ∈ P : e <: e¯ (P is a substitute for P¯) – follows from Lemma 3.6 items 1 and 2.
6e ∈ R Ee¯ ∈ R¯ : e¯ <: e (R is a “supertype of” R¯) – follows from Definition 3.4 (|R|≤ |R¯|) and Lemma 3.6 item 3.
From the assumptions of the proposition we have R ≺ C, the above says that effectively C ≺ C¯D and since the substitutability relation is transitive, it follows that R ≺ C¯D.	2
This fact can be useful in certain common scenarios, e.g. in the special case of component backward compatibility : for a subsequent revision of a component we can easily prove strict substitutability with its immediatelly preceding revision at component release, store appropriate indication in its meta-data, and use it when upgrading the component.
Only if no such indication is available the assessment of substitutability must be carried out at the component binding or upgrade time. At this time it also makes sense to perform the contextual substitutability checks.
Due to its time-dependent nature, both the component’s effective type (the actu- ally used provided and required elements) and the deployment context may change in component instance’s lifetime. Once compatibility is verified during upgrade, architectural consistency needs therefore to be continuously verified and ensured by other means.
Realization for the OSGi framework
Building on our previous work [6] we have implemented a contextual substitutability verifier for the OSGi framework [18]. The overall technical design of the verifier was driven by several goals motivated by the need for practical utility. One of them was a simplified scope (evaluate compatibility of subsequent bundle 3 revisions, not any-to-any substitutability checks), another one a non-intrusive integration in the host framework.
The verifier application has the form of a set of OSGi bundles. The overall archi- tecture of the implementation comprises three layers — a simple user interface, bun- dle and context representation loaders plus substitutability verifier (comparator), and an underlying Java type system model and subtyping rules implementation.
The first two layers are shown in Figure 3. Once the type representations for both the contextual complement and the replacement bundle are created by the Loader bundles (forming a tree data structure with provisions for primitive types and circular references), they are submitted to the Bundle Comparator which im- plements the substitutability verification. The result of its work is essentially an

3 Bundle is the OSGi term for a component.

annotated type tree. It is aggregated into a single assertion about the type rela- tion between the bundle and the complement. The Substitution Veriﬁer bundle wraps the whole process, taking care of activating the loaders and comparator, and interpreting its result for the user.

Fig. 3. Architecture of the OSGi bundle compatibility verifier

There are several fundamental issues that an implementation of contextual sub- stitutability needs to address in general. Firstly it has to implement the element subtype relation at run-time, and choose appropriate type representation on which to perform it. Secondly there needs to be a means of extracting this component types and contextual complement representation from various sources. In the folow- ing paragraphs we will discuss our approach to addressing these issues for the OSGi case.

Type Representation
The foundational issue is the means of obtaining and representing the types of el- ements contained in the component specification. Normally this issue is delegated to the relevant language compiler; however, in our case a run-time component type representation is needed together with mechanisms to obtain it from both the in- stalled and replacement components. Additional complication is that in OSGi, the specification data is scattered in several places (the manifest file as the pivotal point, XML and other additional meta-data e.g. for the declarative services, and the bytecode of bundle implementation).
Since no suitable run-time type representation of OSGi bundles is available, we created a custom-build model [1] called BundleTypes. It consists of domain classes capturing selected characteristics of the whole bundle, both at the module layer (its exported and imported packages) and the service layer (provided and depended-on services). This representation then references a lower layer model, called JavaTypes, which captures the type information of the individual Java classes.
The reconstruction of the type representations uses different means depending on the bundle in question. For the replacement bundle we use bytecode analysis with the ASM library 4 wrapped by a custom classloader. Also, stubs are created

4 http://asm.ow2.org/

for shared (JRE, OSGi core, . . . ) or unreachable classes. These techniques have to be used because the bundle package of the replacement version is accessible only as standalone .jar file in the filesystem (the component has not been installed in the framework yet) so we can’t use reflection and framework APIs. For the imported packages in particular we assemble their type representation [2] from class and operation references extracted from the bundle bytecode.
To obtain the type representation of the current bundle and its contextual com- plement, we use standard OSGi framework services (package admin, bundle meta- data and classloader methods) and Java reflection API. This information is easily reachable since the bundle’s metadata and bindings to client and provider compo- nents are available in the respective framework registries.
Subtype and Compatibility Veriﬁcation
Concerning subtype relation implementation, the design of the algorithms had to reconcile the differences between the theoretical notion of the type relation — as used in the previous section — and the rules employed by Java as the actual spec- ification language, its linking mechanism and the run-time system of the OSGi framework.
Most prominently, Java uses subclassing rather than subtyping [10] in its type matching rules and differentiates subtyping from binary compatibility [13]. This relation is actually the source of the underlying element “subtype” relation since OSGi bundles are bound and updated as binary .jar files.
In the bundle substitutability verifier, subtyping is evaluated by the JavaTypes layer and the results are aggregated by the BundleTypes layer to represent compat- ibility at both the module and service layer of OSGi bundles. Although OSGi is rich in features and modifiers at the module layer (optional imports, “uses” constraint, version ranges, etc.) most of them do not affect substitutability on the exported side and the effective type on the imported side (which reflects the effects of these modifiers) is easily obtained. At the service layer, element substitutability is veri- fied implicitly — all service interfaces must be declared in the exported/imported packages so their type comparison is handled at the module layer.
Evaluation and Lessons Learned
The presented method of component substitutability verification can be considered a rather simple one. It uses only typing rules as its basis, leaving out the much more powerful levels of semantic and behavioural compatibility.
Apart from the reasons given in preceding sections, this design can be defended for the following fundamental reason: the method does not place any limitations on the kinds of component interface elements it is applied to. Therefore it can incorporate any semantic or behavioural specification compatible with our model of component type. An example of an advanced kind of component interface element for which our method could be applied is the behaviour protocol [19] originated in the SOFA component model. In its case, the protocol compliance relation plays the

role of element subtyping.
With respect to the presented OSGi substitutability verifier, we would like to share several observations. For obtaining the type representation of the imported packages, the bytecode analysis techniques used are working solutions but neither method is completely reliable — e.g. the bytecode need not contain return types of class operations. The only good solution to this problem would probably be to somehow include the type information of the the referenced classes with the component distribution package.
Also, it is essentially difficult to reliably obtain the complete list of bundle’s services for both standalone (not installed) and running bundles. The reason in the first case is that the bundle meta-data need not statically declare the services which use the simple core OSGi model 5 so even if the bundle uses the alternative declarative services model with explicit specification, some services may not be found.
The situation is only partially better in the latter case: the sets of services which a bundle exports and uses are available via the framework API but they may change in time. Thus the bundle context representation is only on a current snapshot (plus possibly the history) of the bundle’s bindings and may not cover all its elements. Evaluation of component substitutability for the OSGi framework will therefore always suffer from potential incorrectness, due to the nature of the component model.
The current implementation of the substitutability verifier has several short- comings. At the bundle representation and comparison level, it does not handle fragment bundles and optional imports. It also intentionally omits dynamic im- ports and bundle dependencies (known bad practices in the OSGi world). Also, the chosen architecture — implementing the tool as user-space bundles — enables its portability but prevents integration into the bundle installation/resolving/updating process (which would be a desirable goal since it would provide user-transparent compatibility verification). These issues are the subject of further improvements of the implementation.

Conclusion
In this paper we presented the formal definition and practical implementation of a component substitutability verification method. Its key contributions are the novel use of the component’s deployment context to enable safe substitution for non-subtype replacement components, and the ability to provide sufficiently strong formal guarantees of type consistency even when applied on current industrial com- ponent frameworks.
This type-based substitutability verification can be wrapped into easy to use tools and data that promote its practical use. One such practical extension imple- mented by our team is the automated creation of correct semantic version identifiers

5 The Export-Service and Import-Service manifest headers are deprecated.

for the OSGi framework.
Concerning further research, the formal definitions of the method should be extended to clusters of components (e.g. to support safe substitution of larger sub- sets of applications) and applied more specifically to inter-component relations in dynamic architectures. The practical implementation for OSGi will need to supply the missing aspects of the component model, and overcome the issues of tighter integration in the frameworks.

References
Bauml, J. and P. Brada, Automated versioning in OSGi: a mechanism for component software consistency guarantee, in: Proceedings of Euromicro SEAA (2009).
Bauml, J. and P. Brada, Reconstruction of type information from java bytecode for component compatibility, in: 5th workshop on Bytecode Semantics, Verification, Analysis and Transformation (Satellite Event of ETAPS 2010), Paphos, Cyprus, 2010 .
Belguidoum, M. and F. Dagnat, Formalization of component substitutability, Electronic Notes on Theoretical Computer Science 215 (2008), pp. 75–92.
Beugnard, A., J.-M. J´ez´equel, N. Plouzeau and D. Watkins, Making components contract aware, Computer 32 (1999), pp. 38–45.
Brada, P., “Specification-Based Component Substitutability and Revision Identification,” Ph.D. thesis, Charles University in Prague (2003).
Brada, P. and L. Valenta, Practical verification of component substitutability using subtype relation, in:
Proceedings of the 32nd Euromicro SEAA conference (2006), pp. 38–45.
Bruneton, E., T. Coupaye, M. Leclercq, V. Qu´ema and J.-B. Stefani, The fractal component model and its support in java: Experiences with auto-adaptive and reconfigurable systems, Software Practice and Experience 36 (2006), pp. 1257–1284.
Cardelli, L., Type systems, in: Handbook of Computer Science and Engineering, CRC Press, 1997 .
Chaki, S., E. Clarke, N. Sharygina and N. Sinha, Verification of evolving software via component substitutability analysis, Formal Methods in System Design 32 (2008).
Cook, W. R., W. Hill and P. S. Canning, Inheritance is not subtyping, in: POPL ’90: Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (1990), pp. 125–135.
Desnos, N., M. Huchard, C. Urtado, S. Vauttier and G. Tremblay, Automated and unanticipated flexible component substitution, in: Proceedings of 10th International Symposium on Component-Based Software Engineering, Lecture Notes in Computer Science 4608/2007 (2007).
Georgas, J., A. van der Hoek and R. Taylor, Using architectural models to manage and visualize runtime adaptation, IEEE Computer 42 (2009), pp. 52–60.
Gosling, J., B. Joy, G. Steele and G. Bracha, “The Java Language Specification, Third Edition,” Prentice Hall, 2005.
Jeek, K. and P. Brada, Compatibility verification of components in terms of functional and extra- functional properties - tool support, in: Proceedings of the 12th International Conference on Enterprise Information Systems - Information Systems Analysis and Specification (2010), pp. 510–514.
Leavens, G., K. Leino and P. Mller, Specification and verification challenges for sequential object- oriented programs, Formal Aspects of Computing 19 (2007), pp. 159–189.
Mach, M., F. Pla´ˇsil and J. Kofron, Behavior protocol verification: Fighting state explosion, International Journal of Computer and Information Science 6 (2005), pp. 22–30.
McCamant, S. and M. D. Ernst, Formalizing lightweight verification of software component composition, in: Proceedings of SAVCBS 2004: Specification and Verification of Component-Based Systems, Newport Beach, CA, USA), 2004, pp. 47–54.

The OSGi Alliance, “OSGi Service Platform Core Specification,” (2009), release 4, Version 4.2.
Pl´aˇsil, F. and S. Viˇsnovsky´, Behavior protocols for software components, IEEE Transactions on Software Engineering 28 (2002).
Polakovic, J., S. Mazare, J.-B. Stefani and P.-C. David, Experience with safe dynamic reconfigurations in component-based embedded systems, in: Proceedings of 10th International Symposium on Component- Based Software Engineering, Lecture Notes in Computer Science 4608/2007 (2007).
Stuckenholz, A., Component updates as a boolean optimization problem, Electronic Notes on Theoretical Computer Science 182 (2007), pp. 187–200, proceedings of the Third International Workshop on Formal Aspects of Component Software (FACS’06).
Szyperski, C., Component technology - what, where, and how?, in: Proceedings of the 25th International Conference on Software Engineering (ICSE 2003), Portland, Oregon, 2003.
Taylor, R. N., N. Medvidovic and P. Oreizy, Architectural styles for runtime software adaptation, in: Proceedings of Joint Working IEEE/IFIP Conference on Software Architecture 2009 & European Conference on Software Architecture 2009, 2009.
Vallecillo, A., J. Hern´andez and J. M. Troya, Component interoperability, Technical Report ITI-2000-37, Universidad de M´alaga, Spain (2000).
Wegner, P. and S. B. Zdonik, Inheritance as an incremental modification mechanism or what like is and isn’t like, , 322 (1988), pp. 55–77.
