

Electronic Notes in Theoretical Computer Science 229 (2009) 117–129
www.elsevier.com/locate/entcs

Counting the Cost in the Picalculus (Extended Abstract)
Matthew Hennessy 1 ,2
Department of Computer Science Trinity College Dublin
Dublin, Ireland
Manish Gaur3
Department of Informatics University of Sussex Brighton, UK

Abstract
We design a new variation on the picalculus, πcost, in which the use of channels or resources must be paid for. Processes operate relative to a cost environment, and communications can only happen if principals have provided sufficient funds for the channels associated with the communications.
We define a bisimulation-based behavioural preorder in which two processes are related if, intuitively, they exhibit the same behaviour but one may be more efficient than the other. We justify our choice of preorder by proving that it is characterised by three intuitive properties which behavioural preorders should satisfy in a framework in which the use of resources must be funded.
Keywords: picalculus, resources, cost bisimulations


Introduction
The picalculus [20] is a basic abstract formal language for describing communicat- ing processes and has a very developed behavioural theory [28], expressed as an equivalence relation between process descriptions; P ≈ Q signifies that, although P and Q may be intentionally very different they offer essentially the same behaviour to users.

1 This work is a part of the doctoral studies of the second author and is supported by Commonwealth Scholarship Commission UK (Ref: INCS-2005-145). The support of SFI, Ireland is also acknowledged.
2 Email: Matthew.Hennessy@cs.tcd.ie
3 Email: M.H.C.Gaur@sussex.ac.uk


1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.042

The basic language and its related theory has been extended in myriad ways in order to incorporate many different aspects of concurrent behaviour [1,26,8]. In one family of extensions the judgements of the behavioural theory take the form
Γ |= P ≈ Q	(1)
where Γ represents some aspect of the infrastructure in which the processes P, Q operate. The primary example, initiated in [25], is when Γ is a type environment describing the type of the communicating channels used by P, Q. But in [9,23] it represents the state of the underlying network, recording for example the current connectivity between the sites at which processes execute, or the failures which have occurred.
In this short paper we show how this framework, in particular the version from [13,11], can also be adapted to develop a theory in which there is a cost associated with the resources used in a computation. Here Γ will represent a cost environment, which could record for example the cost of using particular channels or resources, the current funds available to the various principals involved, and could also keep a tally of the total funds which have been expended so far. Indeed if the latter is included in the notion of a cost environment then (1) could be adapted to judgements of the form
Γ |= P  Q	(2)
meaning informally that, relative to the cost environment Γ, processes P and Q offer essentially the same behaviour to users, but that Q is as least as efficient as P , and possibly more efficient.
We envisage two immediate applications for these ideas. The first is web ser- vices, [2]. In [17,6] a basic theory of contracts for web services is introduced, based on a variation of CCS, [19]. Our use of cost environments could immediately be applied here, and indeed we intend to pursue this line of work in future publications. The second is in the development of a more realistic theory of networked processes. Communication across a network is not instantaneous; by introducing some repre- sentation of routers into the process description language, we can associate as the cost of a communication the number of routers through which the message has to travel. This is pursued in [10].
The current paper seeks to lay the foundations for a theory of costed process behaviour. In Section 2 we describe a very simple variation on the (asynchronous) picalculus, which we call πcost, in which channels are viewed as resources, as in [6], but which can only be used if sufficient funds are available. The reduction semantics is relative to a cost environment, so that the judgements are of the form
Γ1 D P1 −→ Γ2 D P2
We refer to the pairs (Γi D Pi) as systems. The rules governing the judgements are minor variations on those used in the standard reduction semantics for the

P, Q ::=	Process terms
u?(x) .P	Provide resource u
u!⟨v⟩.P	Use resource u subscribe(o, u, c).P	Subscribe to resource u if u = v then P else Q Matching
(new a:R) P	Resource creation
P | Q	Concurrency
∗P	Repetition
stop	Termination
del(a, v)	Asynchronous message delivery
Fig. 1. Syntax of πcost

(asynchronous) picalculus; it turns out that the rules only depend on three high- level operations on cost environments. However we also give a concrete instantiation of cost environment which supports these operations.
In Section 4 we define a labelled transition system for πcost, and use the resulting actions to define the relation referred to above, (2), using a (minor) variation on the standard definition of (asynchronous) bisimulation equivalence, [14,4,28]. We claim that this does indeed form the basis for an adequate theory of costed process behaviour. To support this claim we offer one theorem, Theorem 4.4, which says that this relation is completely determined by three natural properties of behavioural relations between systems. These properties are outlined in Section 3, and the main ingredient is the manner in which processes are observed, in particular who pays the cost of performing observations. The paper ends with some remarks on related and future work.

The language πcost
We assume a set of channel or resource names Chan, ranged over by a, b, c,... whose use requires some cost. As already stated we have two examples in mind. The first is where these names actually represent web services, as in [6], and the second is where they represent the transmission of data through routers in a distributed network. We also assume a set of principals or owners Own, ranged over by o, who register for these resources and pay for their use. The syntax of πcost is then given in Figure 1, and is essentially a very minor extension to the picalculus; the meta-variables u, v range over identiﬁers, which are either resource names a ∈ Chan, or variables x from a distinct set Var. We employ the standard abbreviations associated with the picalculus, and associated terminology.
Since resource usage incurs a cost, the execution of processes is now relative to

a cost environment Γ; this records which owners are registered for which resources, and both the costs required to use resources, and the effect of actually using them. Thus judgements of the reduction semantics take the form

Γ1 D P1 −→ Γ2 D P2

where Pi are processes, that is closed terms from πcost, and Γi represent cost envi- ronments.
There are many possibilities for cost environments, and we will provide a par- ticular instance shortly. But no matter how they are defined, we need to be able to define at least three operations on them:

resource charging : Γ1−→a
Γ2 means that relative to Γ1 sufficient funds are available

for the use of resource a, and if it is used, the consumption of appropriate funds is recorded in the transformation from Γ1 to Γ2.

resource subscription: Γ1 −su−b−(o−,−a,→c)
Γ2 records the effect of allowing owner o to

subscribe, with the funds c, to the resource a.
resource registration: Γ,a:R records the result of extending Γ with a new resource named a, with the information contained in the type R. In this paper these types will take the form ⟨Rc, Rs⟩, where Rc is a usage cost, and and Rs records the amount of funds which owners have allocated to the resource.
Relative to these operations, the reduction semantics for πcost is then defined as the least relation which satisfies the rules in Figure 2. This uses the standard structural equivalence between process terms of the picalculus which is recalled in Figure 3.
The idea behind this semantics is that a!⟨v⟩.P is a request to use the service a with parameter v; so with rule (r-out) it spawns an atom del(a, v), which is implicitly delivered through the network to the site of the resource a. In (r-comm)

this request is satisfied, at least if the cost environment allows it, that is Γ1 −→a
Γ2.

We have not yet actually specified this relation, but one would also expect it to record the cost of this request. Most of the remaining rules are standard from the picalculus, but the novel (r-subscribe) allows an owner to subscribe to a channel, that is allocate funds for the use of the channel.
But the final rule (r-new) is non-standard. In Γ1 D (new b:R) P , the process P may evolve by using the internal resource b. In general this requires the expenditure of funds, and therefore will effect funds available for any subsequent use of b. This is reflected in the change of the type, from R to R'; the possible values for R' are deduced by examining the possible evolution of P relative to the extended cost environment Γ1,b:R.
For the remainder of the paper we take a cost environment Γ to consist of a 4-tuple ⟨Γc, Γo, Γs, Γr⟩ where
Γc : Chan ~ N ∞
Γc(a) records the cost of using the resource a; since Γc is a partial function it also implicitly records the valid resources known to Γ, namely dom(Γc).

(r-out)
Γ D a!⟨b⟩.P −→ Γ D del(a, b) |P
(r-comm)
Γ1 −→a Γ2
Γ1 D del(a, b) |a?(x) .P −→ Γ2 D P {|b/x|}
(r-subscribe)
Γ1 −s−ub−(o−,−a,→c) Γ2

Γ1 D subscribe(o, a, c).P −→ Γ2 D P
(r-match)
Γ D if a = a then P else Q −→ Γ D P
(r-mismatch)
Γ D if a = b then P else Q −→ Γ D Q a /= b
(r-struct)
P ≡ P ', Γ1 D P −→ Γ2 D Q, Q ≡ Q'
Γ1 D P ' −→ Γ2 D Q'
(r-cntx)
 Γ1 D P −→ Γ2 D Q	 Γ1 D P | R −→ Γ2 D Q | R Γ1 D R | P −→ Γ2 D R | Q
(r-new)
Γ1,b:R D P −→ Γ2,b:R' D Q
Γ1 D (new b:R) P −→ Γ2 D (new b:R') Q
Fig. 2. Reduction semantics

(s-scope − extrusion)	(new a:R)(P | Q) ≡ P | (new a:R) Q	if a /∈ fn(P ) (s-monoid − com)		P | Q ≡ Q | P
(s-monoid − assoc)	(P | Q) | R ≡ P | (Q | R) (s-monoid − id)		P | stop ≡ P
(s-new − flip)	(new a:R) (new b:S) P ≡ (new b:S) (new a:R) P   if a /= b (s-new)		(new a:R) P ≡ P	if a /∈ fn(P ) (s-rec)			∗P ≡ P | ∗P
Fig. 3. Structural equivalence of π-Cost

Γo : Own −→ N ∞
For an owner o ∈ Own, Γo(o) records the (unsubscribed) funds which o has in the system. These are available for o to allocate to particular resources, via the subscribe(o, a, c) command.
Γs : Chan ~ (Own ~ N ∞)
Γs(a) records the subscriptions that owners have on resource a; since Γs(a) is a partial function it also implicitly records the owners registered to use a, namely

dom(Γs(a)). We also use |Γs(a)| to denote	{ Γs(a)(o) | o ∈ dom(Γs(a)) }, the entire funds available for the use of the resource a.
Γr : N ∞
This is a record of the cost which has already been expended by the system.
The required operations are defined as follows:

resource charging : informally Γ1 −→a
Γ2 if there are sufficient funds subscribed to

a in Γ1 to cover the costs of using it, and Γ2 records their consumption. Formally it holds when
· |Γs(a)| = |Γs(a)| −Γc(a)
2	1	1
Γr = Γr + Γc(a)
2	1	1
Γc = Γc , Γo = Γo, and Γs(b)= Γs(b) whenever b /= a.
2	1	2	1	2	1
Note that here no record is kept of which owners actually contributed to this
particular use of the resource a.
resource subscription: Intuitively Γ1 −su−b−(o−,−a,→c) Γ2 if Γ2 can be constructed from Γ1, by decreasing Γo(o) by c, and increasing Γs(a)(o) by the same amount. Formally
1	1
it holds when
o ∈ dom(Γs(a)); that is o is actually registered to use resource a
Γo(o)= Γo(o) − c
2	1
Γs(a)(o)= Γs(a)(o)+ c
2	1
Γc = Γc, Γr = Γr, and Γo(o')= Γo(o') whenever o' /= o, and Γs(b)= Γs(b) for
2	1	2	1	2	1	2	1
every other b different from a.
resource registration: The cost environment Γ,a:R, is only defined if a is fresh to Γ, that is, if a is not in dom(Γc). In this case it gives the new cost environment Φ defined by
c	 Γc(b)	if b ∈ dom(Γ)

· Φ (b)= 

s
Rc	a=b
  Γs(b)	if b ∈ dom(Γ)


So we require Rs to be a partial function in (Own ~ N ∞). Note that this also implicitly defines the set of owners registered to use the new channel a, namely dom(Rs).
· Φo and Φr are taken to be Γo and Γr respectively.
The pair (ΓDP ) is called a system if fn(P ) ⊆ dom(Γc), that is every free resource name in P is known to the cost environment Γ. We use S to denote the set of all systems.
Proposition 2.1 If (Γ1 DP1) is a system and (Γ1 DP1) −→ (Γ2 DP2) then (Γ2 DP2)
is also a system.	 
Reductions in a system affects it’s cost environment, and as a sanity check we can describe precisely the kinds of changes which are possible:
Proposition 2.2 Suppose (Γ1 D P1) −→ (Γ2 D P2). Then

Γ1 = Γ2
or Γ1 −→a

Γ2, for some resource a

or Γ1 −s−ub−(o−,−a,→c)
Γ2, for some resource a, owner o and cost c.	 


Observing systems
Here we adapt the standard theory of reduction barbed congruence, [14,28,13,11], to πcost. The theory enables one to say that relative to an environment Γ the processes P1 and P2 are observationally equivalent. We modify this in two ways. In the first we will actually relate systems, Γ1 D P1 and Γ2 D P2, thereby enabling us to compare, for example, the same process running under different cost environments. Secondly, because our cost environments accumulate expenditure we will be able to define what it means for one system to be more efficient than another, while offering similar observational behaviour to observers: (Γ1 D P1)  cbp (Γ2 D P2).

Observations:
There is lots of scope for defining what it means to observe processes in sce- narios where communication, and therefore observation, must be paid for. In this preliminary paper we take a simple approach, in which the observations of a system (Γ D P ) are paid for by the funds available within the cost environment Γ; in other words observers are allowed access to the funds available in Γ.
Because πcost is based on the asynchronous picalculus it turns out that only one kind of observable is required. Intuitively (Γ D P ) ⇓c del(a) means that it will cost the system at most c for an observer to be assured that some value can be delivered to the resource a.
First let us define strong observations. We write (Γ D P ) ↓c del(a) whenever
P ≡ (new ˜b:)(del(a, v) |Q), where a does not occur in (˜b)
Γ −→a  Γ' for some Γ'
Γc(a) ≤ c
So this means that an observer can immediately obtain some value on resource a, and the cost of obtaining it is at most c. Then weak observations are defined by letting
(Γ D P ) ⇓c del(a)
whenever (Γ D P ) −→∗ (Φ D Q) where (Φ D Q) ↓d del(a), for some d such that d + (Φr − Γr) ≤ c. Here the total cost to the system is still at most c, taking into account the cost required to get to the state where the actual (strong) observation can be made.
We say that a relation R⊆ S ×S is observation improving if, whenever S1 R S2, S1 ⇓c del(a) implies S2 ⇓c del(a).
Intuitively this means that any observation made on the system S1 can be made on
S2 for a possibly smaller cost.

Contextual:
A relation R⊆S × S is called contextual if
(Γ1 D P1) R(Γ2 D P2) implies (Γ1 D P1 | O) R(Γ2 D P2 | O), whenever (Γ1 D P1 | O) and (Γ2 D P2 | O) are both systems
(Γ1 D P1) R (Γ2 D P2) implies (Γ1,a:R D P1) R (Γ2,a:R D P2), whenever a is fresh to Γi.

Reduction cost improving:
A relation R⊆S × S is called reduction cost improving if, whenever (Γ1 D P1) R
(Γ2 D P2)
(Γ1 D P1) −→ (Γ' D P ') implies (Γ2 D P2) −→∗ (Γ' D P ') for some system
1	'1	'	2	2
(Γ' D P ') such that (Γ r − Γr) ≤ (Γ r − Γr) and (Γ' D P ') R (Γ' D P ').
2	2	2	2	1	1	1	1	2	2
conversely (Γ2 D P2) −→ (Γ' D P ') implies (Γ1 D P1) −→∗ (Γ' D P ') for some
2 '	2	'	1	1
system (Γ' D P ') such that (Γ r − Γr) ≤ (Γ r − Γr) and (Γ' D P ') R (Γ' D P ').
1	1	2	2	1	1	1	1	2	2

'
Here (Γ  − Γ ) represents the cost of doing the reduction (Γ
D P ) −→ (Γ' D P ').

i	i	i	i	i	i
So (Γ1 D P1) R (Γ2 D P2) means that the systems can mimic each other’s reductions, but the reductions from (Γ2 D P2) are no more expensive, and possibly cheaper,
than those from (Γ1 D P1).
Definition 3.1 Cost barbed precongruence:
Let  cbp ⊆S × S be the largest relation which is
observation improving
contextual
reduction cost improving.
The main result of the paper is a non-contextual purely coinductive characteri- sation of this observational preorder between systems.
Bisimulation equivalence for πcost
In Figure 4 we give a set of rules for deriving judgements of the form (Γ1 D P1) −→μ
(Γ2 D P2), where μ can take one of the forms
internal action, τ :
input, a?b, (b:R)a?b: input by resource a of a known or fresh name, respec- tively
output: del(a, b), (b:R) del(a, b): delivery of known or fresh name, respectively, to resource a
external subscription, sub(o, a, c): subscription by owner o to resource a
external consumption, τa: use by some external entity of resource a.
We use α to range over the free actions a?b or del(a, b), and in the rules we employ the standard complementary notation for them, α denoting the complement of α. For

(l-in)
Γ −a→ Γ'


a?b  '

b ∈ dom(Γc)
(l-in)
Γ −a→ Γ'


(b:R)a?b  '

b /∈ dom(Γc)

Γ Q a?(x) P −−→ Γ Q P {|b/x|}	Γ Q a?(x) P −−−−−→ Γ ,b : R Q P {|b/x|}


(l-asy)
Γ Q P −a−?→b Γ Q P | del(a, b) b ∈ dom(Γc)
(l-asy)
Γ Q P −(−b:−R−)a−?→b Γ,b : R Q P | del(a, b)  b /∈ dom(Γc)



(l-out)

Γ Q a!⟨b⟩.P −τ→ Γ Q del(a, b) |P
(l-del)
Γ −a→ Γ'

Γ Q del(a, b) −d−el−(a−,→b) Γ' Q stop

(l-comm)

Γ Q Q −α→ Γ' Q Q', Γ Q P −α→ Γ' Q P '
Γ Q P | Q −τ→ Γ' Q (P ' | Q')
(l-comm)

Γ Q Q −(−b−:R−)→α Γ',b:R Q Q',  Γ Q P −(−b−:R−)→α Γ',b:R Q P '
Γ Q P | Q −τ→ Γ' Q (new b:R)(P ' | Q')


(l-open)
Γ,b:R Q P −d−el−(a−,→b) Γ' Q P '
Γ Q (new b:R) P −(−b:−R−)−de−l(−a−,→b) Γ' Q P '  a /= b

(l-subscribe)
Γ −s−ub−(−o,−a−,→c) Γ'


Γ Q subscribe(o, a, c).P −τ→ Γ' Q P

(l-match)
Γ Q if a = a then P else Q −τ→ Γ Q P
(l-mismatch)
Γ Q if a = b then P else Q −τ→ Γ Q Q a /= b



(l-cntx)
Γ,b:R Q P −μ→ Γ',b:R' Q P '
Γ Q (new b:R) P −μ→ Γ' Q (new b:R') P '  b /∈ n(μ)
(l-cntx)
Γ Q P −μ→ Γ' Q P '
Γ Q P | Q −μ→ Γ' Q P ' | Q

(l-ext.subscribe)
Γ −s−ub−(−o,−a−,→c) Γ'

Γ Q P −s−ub−(−o,−a−,→c) Γ' Q P
(l-ext.com)
Γ −a→ Γ'

Γ Q P −τ→a Γ' Q P
Fig. 4. An action semantics for πcost

convenience, we sometimes use (˜b:R˜)α to denote an arbitrary action; α is considered to be a degenerate instance of (˜b :R˜)α, where the sequence (˜b:R˜) is empty. We will also assume, as usual, that all bound names are fresh in the context in which they
are used.
Many of the rules are a very simple modification of those used in the standard action semantics for the asynchronous picalculus, to take into account the presence
of cost environments. Resource charging Γ −→a  Γ' is required for both input (l-in)
and delivery (l-del). Resource registration is required in (l-open), as is usual for the picalculus, but also in (l-cntx) because of the effect that internal moves may have on resource types. The rule (l-asy) is required because our language is asynchronous. Intuitively it represents an attempt by a user to observe a process P performing the input action a?v, by sending it the package del(a, v). This is ignored by P , and the resulting system is P | del(a, v). Note it does not require any intervention of the cost environment ; intuitively a request has been made to the resource a, but is has not yet been serviced. The use of (l-asy) has been discussed at length in [11], and was originally suggested in [14].
There are two novel actions which take into account the indirect effect that observers may have on the cost environment of a system.  The first, (l-ext.subscribe), models some observer adding some funds to the resource a, while (l-ext.comm) is required to take into account the use of a resource a by some external party.

We can perform a number of sanity checks on these rules. For example one
can show that if (Γ1 D P1) −(b−:R−)→α (Γ2 D P2) Then Γ2 = Φ,b:R for some Γ2 such

that Γ1 −→a
Φ, where a is the channel used in α. In fact the cost to the system of

performing this action is precisely the cost of using this channel: Φr − Γr = Γc(a).
1	1
The actions also preserve systems:
Proposition 4.1 If (Γ1 D P1) is a system and (Γ1 D P1) −μ→(Γ2 D P2) then (Γ2 D P2)
is also a system.	 
As another sanity check we can relate the internal actions of the action semantics of Figure 4 with the reduction semantics of Figure 2. We lift the structural equiva- lence from processes to systems by writing Γ1 D P1 ≡ Γ2 D P2 to mean P1 ≡ P2 and Γ1 = Γ2.


Lemma 4.2
S1 −→ S2 implies S1 −τ→ S'

for some S' ≡ S2

S1 −→τ S2 implies either S2 ≡ S1 or S1 −→ S2.	 
The bisimulation equivalence is defined using a slight abstraction from these judgements. As usual we ignore the type information on the freshly exported re- source names [13], but more importantly we explicitly record the cost of actions:
(Γ1 D P1) −(−b)−d−el−(a−,→b) c (Γ2 D P2) whenever (Γ1 D P1) −(−b:−R)−d−e−l(a−,→b) (Γ2 D P2) can be deduced from the rules for some R, where (Γr − Γr) ≤ c.
2	1
For all other μ, we write (Γ1DP1)−μ→c(Γ2DP2) whenever (Γ1DP1)−→μ (Γ2DP2)
can be deduced from the rules in Figure 4, where again (Γr − Γr) ≤ c.
2	1
This means intuitively that the system can perform the μ action with at most cost
c. These are extended to weak actions (Γ1 D P1) =μ⇒c (Γ2 D P2) in the standard manner, where the cost c is the accumulation of the cost bound associated with the action μ together with the cost bounds of all the pre and post internal τ actions.
Definition 4.3 Cost bisimulation
A relation R ⊆ S × S is a cost bisimulation if whenever S1 R S2,
S1 −μ→c S' implies S2 =μ⇒ˆ c S' for some S' such that S' R S'
1	2	2	1	2

conversely, S2 −μ→c S' implies S1 =μ⇒ˆ
c S' for some S' such that S' R S' .

2
Here we are using the notation =μ⇒ˆ
1	1	1	2
c to mean:

• =⇒τ c ∪ Id, where Id is the identity relation over configurations, when μ is τ
• =μ⇒c, otherwise.
Let ±cost be the largest cost bisimulation, that is S1 ±cost S2 whenever there is some cost bisimulation R such that S1 RS2. Intuitively this means that the systems S1 and S2 are bisimulation equivalent in the traditional sense, but that the latter is more cost efficient than the former. Note that in general, when resources have non-trivial costs, this relation will not be symmetric.

Theorem 4.4 (Full abstraction) Suppose dom(Γc) = dom(Γc).	Then (Γ1 D
1	2
P1) ±cost (Γ2 D P2) if and only if (Γ1 D P1)  cbp (Γ2 D P2).
Proof. (Outline) The structure of the proof is very similar to the corresponding one in [13], Corollary 6.9. In one direction it is sufficient to prove that cost bisimulation
±cost satisfies the three defining properties in Definition 3.1. The only difficulty here is Contextuality; the proof is long, but not as complicated as the corresponding proof in [13], Proposition 6.4. However some care is required because actions can change the types of bound resources. This phenomenon already occured in [9].
To prove the converse it is sufficient to show that the relation cbp is a cost bisimulation between systems. The essence of this result is to show that the de- rived actions can be simulated by suitable contexts. A version of the Deﬁnability result, Proposition 4.4 of [13], must be established for cost environments, where the simulating contexts should not expend more funds than the original action. 

Conclusion
In this short paper we have shown how the well-established theory of typed bisim- ulation equivalence for the picalculus can be easily adapted to provide an adequate theory of costed process behaviour, in which actions can only be performed if there are sufficient funds available to pay for them. Moreover the theory is relatively independent of the precise details of the cost environment relative to which compu- tations takes place.
We intend to pursue this line of work in two directions. In the first we wish to apply it to the various calculi being developed for web services, such as those in [17,6], and to see to what extent practical examples can be treated. In the second, more theoretical, we intend to revisit the idea of observing costed processes, as discussed in Section 3. There we assumed that observers of a system had access to the funds of the system; a more realistic point of view would be that observers were required to provide themselves the funds necessary to perform observations. This change should have some implications for the required labelled transition system, but at the moment their extent is unclear.
There is already a considerable literature on topics related to this line of research. For example in [16] an efficiency preorder is defined between CCS processes; here the cost, or speed of a (weak) action simply depends on the number of internal moves it contains. Interesting properties of this preorder were further studied in [21]. In [15] a cost is associated with a subset of actions (which can not be synchronised) and a theory of amortised bisimulations is developed in this framework. Here amortised refers to the fact that the cost of each individual action is not compared; instead it is the overall cost which counts, where the high cost of one action may be compensated for by another at a low cost. It should be possible to develop amortised bisimulations for πcost; but an interesting theoretical question is how the resulting equivalence can be justified in terms of observations. Faster than preorders between processes have also been developed in work on timed process algebras; see [18] for an attempt at unifying different approaches.

In [3] there is a slightly different notion of the cost of a computation. The setting is mobile ambients [5] and the cost of computation is in terms of space consumption; essentially mobile agents can only migrate if the target location has sufficient capacity to accommodate it. Finally in [7] (and related publications such as [27]) a quite general theory of resource-based computation is being developed. The setting is SCCS [22], but the operational semantics is with respect to a resource. The generality is obtained by only requiring certain operations on the resource; in effect their use of resource is very similar to our use of cost environments, although the required operations are quite different. However they also have resource based modal logic for expressing properties of processes. The interesting point about the logic, a variation on Hennessy-Milner logic [12], is that satisfiabilty is resource dependent, being based on the bunched logic of [24]. It would be interesting to see if a similar logic could be developed for πcost.

References
Mart´ın Abadi and Andrew D. Gordon. A calculus for cryptographic protocols: The spi calculus. In
Fourth ACM Conference on Computer and Communications Security, pages 36–47. ACM Press, 1997.
Gustavo Alonso, Fabio Casati, Harumi A. Kuno, and Vijay Machiraju. Web Services - Concepts, Architectures and Applications. Data-Centric Systems and Applications. Springer, 2004.
Franco Barbanera, Michele Bugliesi, Mariangiola Dezani-Ciancaglini, and Vladimiro Sassone. A calculus of bounded capacities. In Vijay A. Saraswat, editor, ASIAN, volume 2896 of Lecture Notes in Computer Science, pages 205–223. Springer, 2003.
G. Boudol. Asynchrony and the π-calculus. Technical Report 1702, INRIA-Sophia Antipolis, 1992.
Luca Cardelli and Andrew D. Gordon. Mobile ambients. Theor. Comput. Sci., 240(1):177–213, 2000.
G. Castagna, N. Gesbert, and L. Padovani. A theory of contracts for web services. In POPL ’08, 35th ACM Symposium on Principles of Programming Languages, jan 2008.
Matthew Collinson and David Pym. Algebra and logic for resource-based systems modelling. Technical report, Hewlett-Packard Laboratories, 2007. Submitted for Publication.
Vincent Danos and Jean Krivine. Formal molecular biology done in ccs-r. Electr. Notes Theor. Comput. Sci., 180(3):31–49, 2007.
Adrian Francalanza and Matthew Hennessy. A theory for observational fault tolerance. Information and Computation, 206(6): 711-759, 2008.
Manish Gaur. PhD thesis, University of Sussex, 2008. to appear.
Matthew Hennessy. A distributed picalculus. Cambridge University Press, 2007.
Matthew Hennessy and Robin Milner. Algebraic laws for nondeterminism and concurrency. Journal of the ACM, 32(1):137–161, January 1985.
Matthew Hennessy and Julian Rathke. Typed behavioural equivalences for processes in the presence of subtyping. Mathematical Structures in Computer Science, 14:651–684, 2004.
Kohei Honda and Mario Tokoro. On asynchronous communication semantics. In P. Wegner M. Tokoro, O. Nierstrasz, editor, Proceedings of the ECOOP ’91 Workshop on Object-Based Concurrent Computing, volume 612 of LNCS 612. Springer-Verlag, 1992.
Astrid Kiehn and S. Arun-Kumar. Amortised bisimulations. In Farn Wang, editor, FORTE, volume 3731 of Lecture Notes in Computer Science, pages 320–334. Springer, 2005.
S. Arun-Kumar and M. Hennessy. An efficiency preorder for processes. Acta Informatica, 29(8):737– 760, 1992.


Cosimo Laneve and Luca Padovani. The must preorder revisited. In Lu´ıs Caires and Vasco Thudichum Vasconcelos, editors, CONCUR, volume 4703 of Lecture Notes in Computer Science, pages 212–225. Springer, 2007.
Gerald Lu¨ttgen and Walter Vogler. Bisimulation on speed: A unified approach. In Vladimiro Sassone, editor, FoSSaCS, volume 3441 of Lecture Notes in Computer Science, pages 79–94. Springer, 2005.
R. Milner. Communication and Concurrency. Prentice-Hall, 1989.
R. Milner. Communicating and mobile systems: the π-calculus. Cambridge University Press, 1999.
R. Milner and D. Sangiorgi. Techniques of weak bisimulation up-to, 1992.
Robin Milner. Calculi for synchrony and asynchrony. Theor. Comput. Sci., 25:267–310, 1983.
Rocco De Nicola, Daniele Gorla, and Rosario Pugliese. Basic observables for a calculus for global computing. Inf. Comput., 205(10):1491–1525, 2007.
Peter W. O’Hearn and David J. Pym. The logic of bunched implications. Bulletin of Symbolic Logic, 5(2):215–244, 1999.
B. Pierce and D. Sangiorgi. Typing and subtyping for mobile processes. Journal of Mathematical Structures in Computer Science, 6(5):409–454, 1996. An extended abstract in Proc. LICS 93, IEEE Computer Society Press.
Benjamin C. Pierce and David N. Turner. Pict: A programming language based on the pi-calculus. In
G. Plotkin, C. Stirling, and M. Tofte, editors, Proof, Language and Interaction: Essays in Honour of Robin Milner. MIT Press, 2000.
David J. Pym and Chris M. N. Tofts. Systems modelling via resources and processes: Philosophy, calculus, semantics, and logic. Electr. Notes Theor. Comput. Sci., 172:545–587, 2007.
D. Sangiorgi and D. Walker. The π-calculus: a Theory of Mobile Processes. Cambridge University Press, 2001.
