 Electronic Notes in Theoretical Computer Science 97 (2004) 155–174 
www.elsevier.com/locate/entcs




A Logic with Temporal Glue for Mixed Specifications
Marc Aiguier, Fabrice Barbier and Pascal Poizat1
LaMI, UMR 8042
CNRS - Universit´e d’E´vry Val d’Essonne, Genopole
Tour Evry II, 523 place des terrasses de l’Agora, 91000 E´vry, France

Abstract
Separation of concerns or aspects is nowadays recognized as an important issue in software engineer- ing, both at the programming and at the design/specification level. The goal of mixed specification languages (e.g. SDL, value-passing process algebras such as extensions of CSP or full-LOTOS, Ko- rrigan) is to take into account all - or at least several - aspects of systems. We found out from our experience that a lot of mixed specification languages do share most of their features. However, specific theories, such as the symbolic transition systems one, still have to be studied for several families of mixed specification languages. In this paper we propose a logic with an expressive temporal gluing mechanism. This logic aims at providing an abstract denotational semantics for mixed specification languages. This logic enables one to reason about mixed specifications at a high level, without targeting a specific model or language. We show how our logic can be seen as an institution, which has the benefits of enabling a common refinement theory for mixed specification languages.
Keywords: mixed formal specifications, temporal logic glue, denotational semantics, logic, institution, refinement.


Introduction
In the last few years, the need for a separation of concerns with reference to dif- ferent aspects of systems to be specified (datatypes, behaviours, architectures, communications, real-time constraints, ...) appeared at both the programming and the specification level [1]. Systems are said to be mixed when they have more than one aspect. A lot of languages have been defined to deal with

1 Email:poizat@lami.univ-evry.fr


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.035

mixed specifications, but may be classified within two groups (see [2] for more references we cannot give here by lack of space). The homogeneous approach (CASL-LTL, TLA) uses a single formalism (often extending it in a syntactical way) to specify both aspects. The heterogeneous approach (LOTOS, SDL, PSF) uses different formalisms. We think this last approach is well suited to the mixed specification as it enables one to use the more adapted formalism for each aspect - adapted eventually meaning the formalism one knows well or the formalism of a given component one wishes to reuse. Therefore this is the approach we followed in previous works on Korrigan [9,10,11], integrating al- gebraic specifications (for datatypes), Symbolic Transition Systems (STS, for behaviours and interfaces) and temporal logic (to glue components). However, we also think that the homogeneous approach is better suited (i.e. simpler) to the verification part of the specification process: no integration problems arise as the verification may be done in a unique framework.
We found out from our experience [3] that mixed specification languages do share a lot of features, both in their syntax and their semantics. As far as semantics are concerned, the important issue is now to stay symbolic, that is avoid the state explosion problem that arises either when one has value- passing events (the domain of the exchanged values may be infinite) or when components encapsulate some non finite datatype (e.g. a buffer may contain any number of elements). This problem has been studied in the value passing process algebras framework, leading to the definition of Symbolic Transition Graphs, symbolic bisimulation and symbolic modal logics [5]. More recently, the previous works had to be modified and extended to deal with LOTOS specificities [8,7].
Both Architectural Description Languages [13] (ADL) and more recently aspect-oriented approaches [1] expressed the need for the description of system at a high abstraction level and for very expressive means to glue components (or aspects) altogether. An example of such an expressive glue is the tempo- ral logic used in Korrigan to synchronize components within a configuration [10]. Such an explicit temporal logic glue is much more expressive than the implicit ones used in formal ADLs based on process algebras such as Wright for example (see the presentation of our gluing mechanisms below definition 3.6). However, Korrigan only has an operational semantics [9]. If operational semantics are better suited to lower level specifications, a denotational (logic- oriented) semantics is better suited to express such abstract and expressive gluing mechanisms, all the more if data are involved in the exchanges between components. A logical approach is also better suited to enable consistency checks for languages translations (e.g. translating Korrigan from/to SDL and LOTOS [11]) or for multi-languages specifications (e.g. a part of the system

is given in LOTOS, another one in SDL).
In this paper, we present such a logic for mixed specification languages with expressive gluing mechanisms, and give a refinement theory for it. We herein address the theoretical aspects of this logic. More syntactical/expressiveness elements and examples can be found in [10] where we address the definition of components, patterns and architectures using Korrigan, the specification language that led us in the design of this logic. The paper is structured as follows. Section 2 presents the single-component part of the logic and its denotational semantics. Then, in Section 3, we extend the logic to the specification of components and compositions of components. In Section 4 we propose an institution for our logic and present some fundamental results on refinement this institution enables. To end, Section 5 concludes and gives some perspectives.

Basic Mixed Specifications
In this Section, we address the specification of basic components, made up of a static part (datatypes) and a dynamic part (behaviour and communication).

Data Part
The data part addresses the functional issues of components. It will be de- scribed with a many-sorted first order logic. As usual, Σ-terms, noted TΣ(V ), and Σ-formulas, noted Sen(Σ), are inductively built over a many-sorted ﬁrst order signature, noted Σ = (S, F , R), and a set of many-sorted variables, noted V = (Vs)s∈S.
The mathematical interpretation of any signature Σ = (S, F , R) is given by a S-set M = (Ms)s∈S provided with a total function f M : Ms × ··· × Msn → Ms for each function name f : s1 ... sn → s ∈F and a n-ary relation
rM : Ms ×··· × Msn for each predicate name r : s1 ... sn ∈ R. The evaluation
of Σ-terms from a Σ-model M is given by any total function σ  : TΣ(V ) → M
defined as the canonical extension of any interpretation of variables σ : V →
M. Therefore, we extend any interpretation σ into an unary relation M |=σ on Σ-formulas as usual. The validation of Σ-formulas from Σ-models is defined by: M |= ϕ if and only if for any σ : V → M, M |=σ ϕ.

Behaviour Part
This part addresses the behavioural and communication issues of components (when and under which conditions do some event may take place). As usual with first order logics, the syntax is given by a signature from which we in-

ductively define first syntactical elements which are terms, and then extend them into formulas to specify the expected properties of systems.
To instantiate the structures we give below, we will use examples written using a toy abstract language that has been defined for this purpose. Such a language can be seen as a generalization of languages such as LOTOS, SDL or Korrigan. We first define exchange profiles and dynamic profiles to be the generalization of the event typing information that is usual in languages such as LOTOS, SDL or their generalization in Korrigan [9]. Exchange proﬁles (over a set δS of dynamic sorts) are a typing of components with which the component taken into account will communicate. Their form may be ↑δs for a sending to a δs component, ↓δs for a reception from a δs component or any combination of these. Dynamic proﬁles (over a set S of sorts and a subset δS of S) then take into account both exchange profiles and the typing of data exchanges. With η being an exchange profile, the form of dynamic profiles may be either !sη for a sending of a value of sort s, ?sη for a reception of a value of sort s, or any combination of these. A more formal definition of dynamic profiles and exchange profiles may be found in [2].
Dynamic signatures correspond in the behaviour part to the (more usual) signatures in the data part. They relate event names with their profiles.
Definition 2.1 (Dynamic signatures) Let Σ= (S, F , R) be a many-sorted ﬁrst-order signature. A dynamic signature δΣ over Σ is a couple ((δS, δs), E v) where:
δS is a subset of S with a distinguished element, δs, called sort of interest 2
of δΣ,
E v is a set of event names, each one equipped with a dynamic proﬁle ρ over
(S, δS). Moreover, E v ∩ (F ∪ R)= ∅.
Let us note E v∗ = E v ∪ {κ} where κ is a special event, called empty event, equipped with the empty dynamic proﬁle ε and which does not belong to F ∪ R.
Members of δS are dynamic sorts, and values of dynamic sorts are used as identifiers in our logic.
Example 2.2 We take as a running example a gas station. The station is made up of several tanks with an associated tank pump, and of several pumps equipped with a card reader and a pump manager. Several events may be observed: the user gives his/her card to the card reader, the user identifies himself/herself, the card reader returns a card, the user chooses the gas he/her wants (either unleaded 95, unleaded 98 or diesel), the card reader send the in-

2 The sort of interest corresponds to the sort of the component (one would use the term class in the object-oriented paradigm) we are defining, other sorts being “used” sorts.

formation of the chosen gas to the pump manager, the pump manager activates a tank pump. This will lead to the following definitions, taking CardReader as the (dynamic) sort of interest:
(δS, δs)= ({CardReader,PumpMgr,TankPump}, CardReader)
S = {Card, Gas}∪ δS,
CardReader has a the card :→ Card (static) operation
E v = {give :?Card, identif : ε, return :!Card, choose :?Gas, on duty :
!Gas ↑PumpMgr}
Notation 1 Let S be a set of sorts. Let A and B be two S-sets. We note BA the set of partial functions from A to B compatible with S (i.e. for all ν ∈ BA, for all s ∈ S, for all a ∈ As, if ν(a) is deﬁned then ν(a) ∈ Bs). In the following, we will note ν(a)  (respectively ν(a) 3) to mean that ν(a) is deﬁned (respectively undeﬁned).
A semantics for dynamic signatures may be now given. Events are inter- preted by binary relations between states, here interpretation of variables, i.e. elements of MV .
Definition 2.3 (Dynamic model) Let δΣ= ((δS, δs), E v) be a dynamic sig- nature over a many-sorted ﬁrst order signature Σ. Let V be a set of many- sorted variables. A dynamic model D for δΣ, also called a δΣ-model, is a Σ-model M equipped for every e ∈ E v with a binary relation eD on MV .
We now address the issue of defining some kind of dynamic terms and dynamic formulas in the same way static ones are defined from static signa- tures and variables. They are used to glue the static and dynamic aspects of components altogether, or to define (time) relations between events.
Exchange offers (respectively offers) will correspond to the well-typed “in- stantiation” of exchange profiles (respectively dynamic profiles). A η-exchange offer corresponds to the η exchange profile where sorts in reception have been instantiated by a variable and sorts in emission by a term. A ρ-offer corre- sponds to the ρ dynamic profile where sorts in reception have been instantiated by a variable, sorts in emission by a term and every η exchange profile by an η-exchange offer. A more formal definition of exchange offers and offers may be found in [2].
Example 2.4 With (static) sort Gas being defined as {U n95,U n98, Diesel}, and variable pm being of (dynamic) sort PumpMgr, then !U n98 ↑pm is a pos- sible offer for the on duty event whose dynamic profile was !Gas ↑PumpMgr.
From the set of offers, we can build the set of transition terms. Their interpretation will be a binary relation on states. This comes from the fact that

transition terms are used as transition formulas denoting sets of transitions. Such a set-theoretical interpretation is usual in temporal logics as it enables one to use usual set-theoretical operations (union, intersection, ...) which are syntactically denoted by propositional connectors and first-order quantifiers.
Definition 2.5 (Transition terms) A transition term on a dynamic signa- ture δΣ is any well-formed formula built on e.ω with e : ρ ∈ E v∗ and ω being a ρ−offer, true, propositional connectives in {¬, ∧, ∨, ⇒, ⇔} and ﬁrst-order quantiﬁers in {∀, ∃}. Let us note TδΣ(V ) the whole set of transition terms.
Notation 2 (Read Variables (RV) and Sent Terms (ST )) Let ω be an offer. We note RV(ω) (respectively ST (ω)) the whole set of variables x (re- spectively terms t) such that ?x or ↓x (respectively !t or ↑t) occurs in ω.
Definition 2.6 (Evaluation of transition terms) Let δΣ be a dynamic sig- nature over a signature Σ. Let V be a set of variables on Σ. Let D be a δΣ- model. Let τ ∈ TδΣ(V ). The evaluation of τ on D, noted τ )D, is the binary relation on MV inductively deﬁned on the structure of τ as follows:

 (σ, σ') ∈ eD
 (states are related by the event interpretation)



(σ, σ') ∈  e.ω)D











 ∀xτ )D =


 ∃xτ )D =
⇐⇒  (sent terms have an interpretation in the source state)
∧(∀x ∈ RV (ω), σ'(x)  )
 (received variables are bound in the target state)
∧(∀x ∈ V \ RV (ω), σ(x) ⇒ σ (x)  ∧σ (x)= σ(x))
 (the value of non received variables has not changed)

 true)D =   eD
e∈E v
 τ )D if ∀v ∈ M, ∃σ' ∈ MV , (σ, σ') ∈  τ )D ∧ σ'(x)= v
 ∅	otherwise
 τ )D if ∃v ∈ M, ∃σ' ∈ MV , (σ, σ') ∈  τ )D ∧ σ'(x)= v
 ∅	otherwise

Other operators may be treated in a usual way, that is  τ1 ∧ τ2)D = τ1)D ∩
 τ2)D,  τ1 ∨ τ2)D =  τ1)D ∪  τ2)D,  τ1 ⇒ τ2)D =  ¬τ1)D ∪  τ2)D, and  ¬τ )D =
 true)D \ τ )D.
To complete our logic for the behavioural aspects, we now have to define how dynamic properties may be expressed, that is dynamic formulas. These formulas correspond to some form of value-passing extension of HML. Such formulas exists in Korrigan [9] or, as far as LOTOS is concerned, in FULL [7].
Definition 2.7 (Dynamic formulas) A dynamic formula on a dynamic sig- nature δΣ is any well-formed formula built on (static) Σ-formulas, true, tem- poral connectives [τ ]ϕ and ⟨τ ⟩ϕ with τ being a transition term and ϕ being a dynamic formula, propositional connectives in {¬, ∧, ∨, ⇒, ⇔} and ﬁrst-order quantiﬁers in {∀, ∃}. Let us note δSen(δΣ) the whole set of dynamic formulas.
Definition 2.8 (Satisfaction of dynamic formulas) Let δΣ be a dynamic signature over a signature Σ. Let V be a set of variables over Σ. Let ϕ ∈ δSen(δΣ). Let D be a δΣ-model. D satisﬁes ϕ on a state σ ∈ MV , noted D |=σ ϕ, is inductively deﬁned on the structure of ϕ as follows:
if ϕ is a Σ-formula, then D |=σ ϕ if and only if, if σ is deﬁned on all free variables of ϕ then M |=σ ϕ,
for all σ ∈ MV , D |=σ true,
if ϕ is of the form [τ ]ψ then D |=σ [τ ]ψ if and only if for all σ' ∈ MV such that (σ, σ') ∈ τ )D, D |=σ' ψ,
if ϕ is of the form ⟨τ ⟩ψ then D |=σ ⟨τ ⟩ψ if and only if there exists σ' ∈ MV
such that (σ, σ') ∈ τ )D, D |=σ' ψ,
propositional connectives and ﬁrst-order quantiﬁers are handled as usual.
As usual, D |= ϕ is defined as ∀σ ∈ MV , D |=σ ϕ.
Example 2.9 We will take events in the card reader as examples. Dynamic formulas may be used both to relate dynamic events with static operations
after the user gave a card c, the the card operation yields c:
∀c : Card [give?c] the card = c
or dynamic events with dynamic events
after the user identifies himself/herself, the card reader either (nondeter- minism) returns the card or asks for the gas choice:
[identif ](⟨return!the card⟩true ∨ ∀gas : Gas⟨choose?gas⟩true)
Signatures of components and their properties may then be integrated within a dynamic specification : a view.

Definition 2.10 (View) Given a many-sorted ﬁrst order signature Σ= (S, F ,R), a Σ-view V is a 4-tuple (δΣ, Ax, State, Init), where δΣ is a dynamic signature over Σ, Ax is a set of Σ-formulas, and State and Init are sets of dynamic formulas.
Definition 2.11 (View model) Let V = (δΣ, Ax, State, Init) be a view. A view model for V is a pair (D, <D) where D is a δΣ-model and <D is a pre-order on MV such that the following conditions hold:
for all (σ, σ') ∈ eD, σ <D σ',
M |= Ax,
D |= State,
for all σ ∈ MV , if D |=σ Init then for all σ' ∈ MV , σ <D σ'.
The pair (D, <D) can be seen as a Kripke structure where states are valua- tion of variables (MV ) and where the reachability relation is naturally denoted by the <D pre-order which contains the execution of events. Therefore, the semantics of view specifications can be seen as a possible worlds semantics. The satisfaction of formulas depends on states (i.e. partial functions of MV ) in which they are evaluated (they are contingent).

Composed Mixed Specifications
This part addresses the composition, architectural, synchronizing and inter- component communication aspects of systems. As for the basic mixed spec- ifications, we here define first composed signatures, then composed formulas and finally composed specifications. Here we have no need for any composed equivalent of terms. Throughout this Section, we will use the . symbol to denote concepts related to composed specifications (e.g. Σ was a signature in the previous Section, Σ will be a composed signature in this Section).
Notation 3 Given a view V = ((δΣ, δs), Ax, State, Init) with δΣ= (δS, E v)
and Σ= (S, F , R), we will use the following notations:

δSig[V]= δΣ
Sig[V]=Σ 
δSort[V]= δS
Rel[Sig[V]] = R
δint [V]= δs
F un[Sig[V]] = F

Definition 3.1 (Composed mixed signature) A composed mixed signa- ture Σ is a ﬁnite set {V1,... , Vn/n ∈ IN} such that for each 1 ≤ i ≤ n, Vi is a Σi-view with Σi = (Si, Fi, Ri). Moreover, Σ satisﬁes for any couple of views (Vi, Vj) of Σ the following conditions:
δint [Vi]= δint [Vj] ⇒ Vi = Vj (unicity of view types deﬁnitions),
if we note Si,j = Si ∩ Sj and δSi,j = δSi ∩ δSj, then:



· ∀α ∈ S∗ , ∀s ∈ Si,j, ∀f : α → s, f ∈ Fi ⇔ f ∈ Fj,
· ∀α ∈ S∗ , ∀r : α, r ∈ Ri ⇔ r ∈ Rj.
(same sorts share the same function names and predicate names)
Let us note δs = {δsi} (δsi is the sort of interest of Vi), and S = 
1≤i≤n




Si.

We first define the models for composed mixed signatures, and then global states and environments for these models (to deal with the gluing between the individual models).
Definition 3.2 (Composed mixed model) Let Σ = {V1,... , Vn} be a com- posed mixed signature. A composed mixed model over Σ, or for short a Σ- model, D consists on one view model (Di, <Di ) for each Vi (1 ≤ i ≤ n), such that:
∀1 ≤ i, j ≤ n, ∀s ∈ Si ∩ Sj, (Mi)s = (Mj)s (same sorts share the same interpretation ...),
∀1 ≤ i, j ≤ n :
∀f ∈ Fi ∩ Fj, f Mi = f Mj ,
∀r ∈ Ri ∩ Rj, rMi = rMj ,
∀e ∈ E vi ∩ E vj, eDi = eDj .
(... and same interpretations for their functions, predicates and events 3 )
Let us note M the S-set obtained by gluing all Si-sets Mi (1 ≤ i ≤ n) together. Finally, let us note MδeS the restriction of M to sorts in δS.
Composed mixed states denote functions that, taking the identification of a component, yield the substitutions for this component’s states (i.e. within this component’s model).
Definition 3.3 (Composed mixed state) Let Σ˜ = {V1,... , Vn} be a com-
posed mixed signature. Let V˜ be a S˜-indexed family of sets of variables. Let
D be a Σ-model. For every 1 ≤ i ≤ n, let us note VSi the restriction of V
to Si. A composed mixed state over D is any δS-indexed family of functions
Ve
γ˜δsi : M˜δSi → Mi	such that ∀1 ≤ i, j ≤ n, ∀n ∈ M˜ ∩M˜δS , γ˜δS (n)= ˜δSγ	(n).
Si
j	i	j
Let us note St[D] the set of composed mixed states over D.
Environments are used to take the gluing of different components into account within our global models. The components concerned are dealt with by the σ part of the environments. Valuations are dealt with by the state (γ) part of the environments.

3 Overloading can easily be achieved through renaming.

Definition 3.4 (Environment) With all the notations of Deﬁnition 3.3, an environment over D˜ is a pair E = (σ, γ) where σ : V˜δeS → M˜δeS is a function compatible with sorts (i.e. σ(V˜δs) ⊆ M˜δs) and γ ∈ St[D˜] such that:
∀1 ≤ i ≤ n, ∀m ∈ Mδint[Vi], ∀y ∈ Vi ∩ VδS, γ(m)(y)= σ(y)
(identiﬁers denote one component only : the identiﬁcation value of a component - i.e. the value of the variable denoting it - and the one known in other components - i.e. the value of the same variable in other components
- are equal)
∀1 ≤ i, j ≤ n, ∀m ∈ M˜δint [V ], ∀m' ∈ M˜δint [V ], ∀x ∈ Vi ∩ Vj, γ˜δS (m)(z) = 

(the same variable used in two states of two components have the same
value - value exchange)
We now define the way to express properties on our composed specifica- tions. Projected formulas and projected state formulas enable one to express properties of the systems in terms of properties on the elements that compose it. They are used to restrict the set of models of composed mixed signatures.
Definition 3.5 (Projected state formula) Let Σ = {V1,... , Vn} be a com- posed mixed signature. Let V be a S-indexed family of sets. A projected state formula on Σ is any well-formed formula built on:
x.ϕ where x ∈ Vδes and ϕ ∈ δSen(δSig[V]),
propositional connectives in {⇒, ⇔, ∧, ∨, ¬} and ﬁrst-order quantiﬁers in
{∀, ∃},
Qx.ϕ where x ∈ Vδes, ϕ is a projected state formula and Q ∈ {∀, ∃}.
Let us note PδSen(Σ) the set of projected state formulas, and PSen(Σ) (set of projected formulas), the subset of PδSen(Σ) where ϕ in x.ϕ is taken in the Sen(Sig[V]) subset of δSen(δSig[V]), and ϕ in Qx.ϕ is a projected formula.
Definition 3.6 (Satisfaction of projected state formulas) Let Σ = {V1,
... , Vn} be a composed mixed signature. Let ϕ ∈ PδSen(Σ) be a projected state formula. Let D˜ be a Σ˜-model. Let E = (σ˜, γ˜) be an environment. Let us note

δV the restriction of V if:
to S˜.
D˜ satisﬁes ϕ˜ for E , noted D˜ |=E ϕ˜, if and only

if ϕ˜ is of the form x.ψ with x ∈ V˜δsi then D˜ |=E ϕ˜ if and only if Di |=γe(σe(x)) ψ,
if ϕ is of the form ∀x.ψ˜ then D˜ |=E ϕ if and only if for any environment E '
such that for all y /= x ∈ δ˜V , σ˜(y)= σ˜'(y), D˜ |=E' ψ˜.
if ϕ˜ is of the form ∃x.ψ˜ then D˜ |=E ϕ˜ if and only if there exists an environ-

ment E ' such that for all y /= x ∈ δV , σ(y)= σ'(y), D |=E' ψ.
Propositional connectives and ﬁrst-order quantiﬁers are handled as usual.
Satisfaction of projected formulas is handled in the same way. As usual,
D |= ϕ is defined as: ∀E , D |=E ϕ.
These formulas are a very expressive (temporal) gluing mechanism and generalize more implicit synchronizing glues of languages such as CCS, CSP, Wright or LOTOS. Let us take some examples (here CCS and LOTOS).
In CCS events are synchronized pairwise (event a with event a) ina 1-to-1 fashion. This yields a non observable event, τ , which may not be synchronized anymore. LOTOS is more expressive, taking data exchange and synchronizing with value agreement into account. In LOTOS one also explicitly states which events are synchronized and which ones are not. For example, if one has two processes P = a; stop and Q = a; stop (both do a and stop), then (s)he may either state that they synchronize on a (P |[a]|Q), or not (P |||Q). Finally, unless explicitly hidden, events in synchronizings may be synchronized again (in (P |[a]|Q)|[a]|Q, the three processes synchronize on a)
Our formulas generalize and extend these gluing mechanisms. In languages which may be based on our logic, we can express things such as 4 :
(explicit) synchronizing: c1.[a]true ⇔ c2.[a]true (c1 and c2 must synchro- nize on a)
connecting event ports with different names: c1.[a1]true ⇔ c2.[a2]true
value passing: ∀x : Nat(c1.[a?x]true ⇔ c2.[a!x]true)
broadcasting (1-to-N, all in the same time):
server.[send]true ⇒ ALL(client.i : [1..N ]).[receive]true
exclusive peer-to-peer (1-with-N, but one at a time):
server.[send]true ⇒ ONE(client.i : [1..N ]).[receive]true
exclusive states: ¬(cooler1.(active = true) ∧ cooler2.(active = true)), both coolers are not active at the same time
Korrigan, which is an example of such a language, has a graphical notation for components and compositions taking these formulas into account [10].
Definition 3.7 (Composed mixed specification) A composed mixed spec-
˜

ification C˜ is a 4-tuple (Σ˜, A˜x, State, I˜nit), where Σ˜
is a composed mixed
˜

signature, Ax is a set of projected state formulas, and State and Init are
sets of projected formulas.




4 With ALL(S).ψ˜ being defined as 


x∈S
x.ψ˜ (set/range quantification) and ONE(S).ψ˜ as

 x∈S (x.ψ˜ y∈S,x/y=¬y.ψ˜) (one and only one in a set/range).

Example 3.8 We suppose here that within the composed mixed specification of the system, the card reader is identified with cr, the pump manager with pm and the tank pumps with un95 tp, un98 tp and diesel tp. Using projected term formulas, we may now express that when the card reader sends the gas choice to the pump manager, the pump manager activates the correct pump: cr.[on duty!U n98 ↑pm]true ⇒ pm.[activate ↑un98 tp]true
Notation 4 Let D˜ be a Σ˜-model. Let us deﬁne the pre-order on St[D˜] as
follows: γ˜<˜γ˜' ⇔ (∀1 ≤ i ≤ n, ∀m ∈ M˜δS , γ˜(m) <Di γ˜'(m))
Definition 3.9 (Models of specification) Let C˜ = (Σ˜, A˜x, State, I˜nit)
be a composed mixed speciﬁcation. A C˜-model is a Σ˜-model D˜ such that:
D˜ |= A˜x ∪ State,
∀γ ∈ St[D], (∀σ, D |=(σe,γe) Init) ⇒ (∀γ' ∈ St[D], γ<γ').
In this Section we have defined a logic which enables one to reason on concrete mixed specification languages (e.g. Korrigan, LOTOS, SDL) in an abstract way (defining a denotational semantics for them). This logic could also be used to deal with multi-languages issues as long as the languages are defined using it. In the next Section we will see that another benefit of this logic is to be granted with a generic refinement theory for such languages.

Institution and Refinement
In the field of axiomatic specifications (i.e. based on logical frameworks), a lot of different formalisms have been defined, each one devoted to some aspects of software engineering (typing, dynamical aspects, temporality, real-time, theorem-proving issues, modularity issues, refinement, etc.). Most of the time, beside the original idea underlying a new formalism, the authors must develop a lot of inevitable formal results which generalize some well-known classical results. Since J. Goguen and R. Burstall’s works on institutions [12], it has been established that such results can be generalized at a meta-level. Showing that a formalism is an institution allows its authors to directly use general results such as existence of quotients, free models, amalgamation properties underlying to modularity issues, and refinement issues.
Here, we are going to show that our mixed specification logic is an institu- tion in order to define a refinement theory for views. We will show that results on horizontal and vertical refinements for institutions hold for composed mixed specifications. For this purpose, we will use notations and results established in [6] and [14]. By lack of place, we do not give proofs nor definitions of cat-

egory theory (used in the definition of institutions) in this paper. The reader interested in proofs can find them in [2]. A simple presentation of category theory can be found in [15].
An Institution for the Mixed Speciﬁcation Logic
Institutions formally axiomatize the notion of logical system from a theoret- ical point of view. An institution is a quadruple (Sig, Sen, Mod, |=) where Sig is a category (a class of objects and morphisms between these objects) of signatures, Sen : Sig → Set is functor (a couple of mappings, one between classes and one between morphisms) which maps every signature to its set of sentences, Mod : Sig → Cat is a contravariant functor which maps every signature to its category of models, and |== (|=Σ)Σ∈|Sig| is a |Sig|-indexed family of relations |=Σ⊆ |Mod(Σ)|× |Sen(Σ)|. Given a signature morphism σ :Σ → Σ', Mod(σ): Mod(Σ') → Mod(Σ) is called reduct functor. Moreover, this quadruple satisfies the following property, the so-called satisfaction con- dition: ∀(σ : Σ → Σ') ∈ HomSig, ∀M ∈ |Mod(Σ')|, ∀ϕ ∈ |Sen(Σ)|, M |=Σ' Sen(σ)(ϕ) ⇔ Mod(σ)(M) |=Σ ϕ. In such a generic framework, a specification is any couple SP = (Σ, Ax) where Σ ∈ |Sig| and Ax ⊆ Sen(Σ). The nota- tions M |=Σ ϕ is extended in the usual way to categories of models and sets of formulas. Given a specification SP = (Σ, Ax), the category of Σ-models M such that M |=Σ Ax is noted Mod(SP ). A Σ-sentence ϕ is a semantic consequence of a specification SP if and only if for every M ∈ |Mod(SP )|, M |= ϕ.
The category of composed mixed models.
First, we must define an appropriate morphism notion between view models.
Notation 5 For any interpretation of variables σ : V → M, we note µ(σ) : 
V → M' the application deﬁned by x '→ µ(σ(x)). Finally, with R being a binary relation on MV , we note µ(R) the set {(µ(σ), µ(σ')) | (σ, σ') ∈ R}.
Definition 4.1 (View model morphisms) Given a view V,a V-morphism between two view models for V (D, <D) and (D', <D ) is a Σ-morphism µ : M→ M' such that:
µ(eD) ⊆ eD' (event compatibility)
µ(<D) ⊆<D' (pre-order compatibility)
We then extend it to composed mixed models.
Definition 4.2 (Composed mixed model morphisms) Let Σ˜ = {V1,... , Vn} be a composed mixed signature. A Σ˜-morphism between two Σ˜-models D˜ and D˜' is deﬁned for each 1 ≤ i ≤ n by a Vi-morphism µi : Di → D'i. More-

over, for every 1 ≤ i, j ≤ n and every s ∈ Si ∩ Sj, we have: (µi)s = (µj)s. Clearly, Σ˜-models and Σ˜-morphisms form a category. Let us note it Mod(Σ˜).

Reduct functor and satisfaction condition.
An essential ingredient which is missing is an appropriate morphism notion for composed mixed signatures. We first have to define morphisms between dynamic signatures and morphisms between views.
Definition 4.3 (Dynamic signature morphism) Let δΣ = ((δS, δs), E v) and δΣ' = ((δS', δs'), E v') be two dynamic signatures. A dynamic signature morphism ν : δΣ → δΣ' is a signature morphism ν :Σ → Σ' such that:
ν(δS) ⊆ δS' and ν(δs)= δs',
for every event e : ρ in δΣ, ν(e) : ν(ρ) belongs to δΣ' where ν(ρ) is the natural extension of ρ to dynamic proﬁles of PS,δS.
Definition 4.4 (View morphism) Let V = (δΣ, Ax, State, Init) and V' = (δΣ', Ax', State', Init') be two views. A view morphism ν : V → V' is a dy- namic signature morphism ν : δΣ → δΣ' such that ν(Ax) ⊆ Ax', ν(State) ⊆ State' and ν(Init) ⊆ Init.
Given a a view morphism ν, let us note ν its canonical extension to dynamic formulas. We may now define morphisms between composed mixed signatures.
Definition 4.5 (Composed mixed signature morphisms) Let Σ = {V1,
... , Vn} and Σ' = {V'1,... , V'm} be two composed mixed signatures. A Com- posed mixed signature morphism ν is a set {ν1,... , νn} such that:
for every 1 ≤ i ≤ n, νi : Vi → V'i is a view morphism;
for every 1 ≤ i, j ≤ n:
∀s ∈ Si ∩ Sj, νi(s)= νj(s);
∀f ∈ Fi ∩ Fj, νi(f )= νj(f );
∀r ∈ Ri ∩ Rj, νi(r)= νj(r);
∀e ∈ E vi ∩ E vj, νi(e)= νj(e);

Given a composed mixed signature morphism ν, let us note ν its canonical extension to both projected formulas and projected state formulas.
Proposition 4.6 Let ν : V → V' be a view morphism. Let (D', <D' ) be a
V-model. Let us note D'†ν the dynamic-model D for δΣ deﬁned as follows:
the Σ-model M = M'†ν, and

for every e ∈ E v, eD = {(σ†ν
' ) | (σ, σ') ∈ eD' }

where σ†ν is the restriction of σ to sorts of S.

Then, for any ϕ ∈ δSen(δΣ), we have: D' |= ν(ϕ) ⇐⇒ D'†ν |= ϕ.
Corollary 4.7 With all the notations of Proposition 4.6, Let us note <D'†ν
the pre-order on MV deﬁned by: <D'†ν = {(σ	' ) | (σ, σ') ∈<D' }. Then, the

couple (D'†ν
, <D'†ν ) is a V'-model.

Proposition 4.6 is the satisfaction condition for the view specification logic.
Definition 4.8 (Reduct functor) Let ν : Σ˜ → Σ˜' be a composed mixed sig- nature morphism. Let D˜' be a Σ˜'-model. The reduct functor †νe : Mod(Σ˜') → Mod(Σ˜) is deﬁned as follows:
for each Σ˜'-model D˜', D˜'†νe is the Σ˜-model D˜ where for every 1 ≤ i ≤ n,

Di = (D'i)†ν
and <Di = (<D'i )
†νi
(by Corollary 4.7, the couple (Di, <Di ) is

a Vi-model).
for each Σ'-morphism µ : D → D', µ†νe : D†νe → D'†νe is the Σ-morphism deﬁned for all 1 ≤ i ≤ n by the Vi-morphism (µi)†νi where µi is the corre- sponding V'i-morphism of µ˜.
Theorem 4.9 (Satisfaction condition) Let ν˜ : Σ˜ → Σ˜' be a composed
mixed signature morphism. Let D' be a Σ'-model. Let ϕ be projected formula or a projected state formula over Σ˜. Then, we have: D˜' |= ν˜(ϕ˜) ⇐⇒ D˜'†νe |= ϕ˜.
Corollary 4.10 Let C = (Σ, Ax, State, Init) and C' = (Σ', Ax', State', Init')
be two composed mixed speciﬁcations such that there is a signature morphism
˜	˜		˜
	
ν : Σ → Σ', ν(Ax) ⊆ Ax', ν(State) ⊆ State', and ν(Init) ⊆ Init'. Then, the
reduct functor †νe can be co-restricted to †νe : Mod(C') → Mod(C).
In order to fit composed mixed specifications within the institution frame- work, we must mention for every formula the signature on which it is defined.
Definition 4.11 Let Σ = {V1,... , Vn} be composed mixed signature. A well- formed Σ-formula is:
for every 1 ≤ i ≤ n, any pair (Vi, ϕ) where ϕ ∈ δSen(δΣi);
and any pair (Σ˜, ϕ˜) where ϕ˜ is any projected formula or a projected state

At last, all this enables us to define an institution for our composed mixed specifications.
Theorem 4.12 (Institution of composed mixed specifications)
The quadruple INSCMS = (SigCMS,ModCMS, SenCMS, |=CMS) is an institu- tion whereby:
SigCMS is the category of composed mixed signatures and composed mixed

signature morphisms.
The functor SenCMS : SigCMS → Set maps:
each composed mixed signature Σ to the set of well-formed Σ-formulas (see Deﬁnition 4.11) and
each composed mixed signature morphism ν to ν.
The contravariant functor ModCMS : SigCMS → Cat maps:
each composed mixed signature Σ˜ to the category Mod(Σ˜) and
each composed mixed signature morphism σ˜ to the reduct functor †σe.

|=CM S = (|=Σe )Σe ∈|Sig


CMS
| where for each composed system signature Σ˜ =

{V1,... , Vn}, |=Σe is the satisfaction relation of a well-formed Σ˜-formula
Γ by a Σ-model D deﬁned as follows:
if Γ is of the form (Σ, ϕ) then D |=e Γ iff D |= ϕ (see Deﬁnition 3.6);
if Γ is of the form (Vi, ϕ) then D |=e Γ iff Di |= ϕ (see Deﬁnition 2.8).
By Proposition 4.6, we can easily define, using the same arguments than for Theorem 4.12, the institution for view specifications. Let us note it Insview.



Views Reﬁnement
Specification refinement consists in removing axioms of specifications and re- placing them by more concrete ones. In our framework, this will be simply defined as follows:
Definition 4.13 (View refinement) A view Vimpl is a refinement of a view
V if and only if Sig[Vimpl] = Sig[V]. Let us note V ~Sig[V] Vimpl such a reﬁnement.
A refinement is correct provided that the behaviour of the implementation is indistinguishable from the behaviour of the higher level specification under consideration. When dealing with loose semantics, since design choices can be made through refinement steps, the refinement semantics consists on cutting down the class of specification models. This is expressed as follows:
Definition 4.14 (Semantic refinement) Let V ~Σ V' be a reﬁnement. V' is a semantic refinement of V, written V HΣ V', if and only if Mod(V') ⊆ Mod(V).
Usually, specification refinements allow us to extend signatures. This can be abstractly obtained from the following basic set of specification building operations:

union:	for any two views V1 and V2 with S ig[V1]= S ig[V2],
V1 ∪ V2 is a view with semantics
Mod(V1 ∪ V2 )= Mod(V1 ) ∩ Mod(V2 )
translate:	for any view V and any signature morphism ν : S ig[V] → Σ',
translate V by ν is a view with semantics
'	D'	'	D'

Mod(translate V by ν)= {(D ,<  ) | (D †ν, (<
)†ν ) ∈ Mod(V)}

derive:	for any view V' and any signature morphism ν :Σ → S ig[V'],
derive from V' by ν is a view with semantics
Mod(derive from V' by ν)= Mod(V')†ν
Definition 4.15 (Conservative extension along ν) With all the notations of Deﬁnition 4.14, V' is a conservative extension of V along ν if and only if Mod(V')†ν = Mod(V).
From there, we can instantiate the institution independent proof system of [6] and obtain the following rules:
Definition 4.16 (Rules) Let V = (δSig[V], Ax, State, Init). Let iso be a signature isomorphism. Let ν be a signature morphism. The family of reﬁne- ment relations (~Σ)Σ∈|Sig| is deﬁned by the following set of rules:

V |=Ax'∪State'
(Sig[V ],Ax',State',Init)~Sig[V]V
V1~Sig[V]V	V2~Sig[V]V
V = (δSig[V], Ax, State, Init)
V ~Sig[V]translate V' by iso−1

(Sum)
(Trans2)
V1∪V2~Sig[V]V	(Trans1)
V ~Sig[V]derive from V' by ν

translate V by ν~Sig[V']V '
V ~Sig[V'']V ''


translate V by iso~Sig[V'] V '

V'' is a conservative extension

(Derive) derive from V' by ν~

' V '
of V' along ν


(Trans − equiv)
Sig[V ]
translate (translate V by iso) by ν~Sig[V''] V ''
translate V by ν ◦ iso~Sig[V'']V ''

Theorem 4.17 (Soundness and completeness) For any views V and V', we have: V ~Sig[V] V' ⇐⇒ V HSig[V] V'.

Composition.
Of course, it is not reasonable to implement a specification as a whole in a single step. Complex systems usually require many refinement steps before ob- taining efficient programs. This leads to the notion of sequential composition of implementation steps. Usually, the composition of enrichments is divided into two separate concepts: horizontal composition and vertical composition. Horizontal composition deals with refinement of subparts of composed mixed specifications when they are structured into specification “blocks”. In our framework, blocks are views. On the contrary, vertical composition deals with

many refinement steps and denotes the transitive closure of refinement rela- tions.
Notation 6 Let C be a composed mixed speciﬁcation. Let V be a view be- longing to C and let V ~Sig[Vimpl] Vimpl. Let us note C[V/Vimpl] the composed mixed speciﬁcation obtained from C by substituting V by Vimpl.
Theorem 4.18 (Horizontal refinement) With all the previous notations,
if V ~Sig[Vimpl] Vimpl, then: ∀ϕ˜ ∈ Sen(Σ˜), C˜ |= ϕ˜ =⇒ C˜[V/Vimpl] |= ϕ˜.
Corollary 4.19 Mod(C[V/Vimpl])†νe ⊆ Mod(C).
Theorem 4.18 means that as soon as composed mixed specifications are structured into view specifications, these view specifications can be refined by any correct realization (according the meaning given here) independently of each other. Thus, we gain an incremental method.
Theorem 4.20 (Vertical composition) The following rule is sound:
V ~Sig[V ] V'	V' ~Sig[V ] V''
V ~Sig[V ] V''
In this Section we have established an institution vision of our logic and we have shown that a refinement theory could be defined for it, in a generic way (hence non language specific). This should help in defining, in the future, generic theories for mixed specification languages such as the STS one which was firstly defined for value passing CSP [5] and had to be modified and extended for LOTOS [8,7].

Conclusion
In this paper we presented a logic and denotational model for mixed specifica- tions. We first presented a logic for simple mixed systems and then extended it to take into account the specification of components and composition of com- ponents. Our logic aims at describing systems at a high level of abstraction (describe the “what” and not the “how”). For this purpose, it uses implicit states and dynamic observations of events. Such a high-level description of systems is also advocated in Architectural Description Languages (ADL). In- deed, we are investigating the use of Korrigan as a formal ADL. One of its interesting features is its very expressive synchronizing mechanisms (gluing components in architectures using temporal logic). However, Korrigan had no denotational semantics. This issue is now dealt with by our logic which may be used to give an abstract denotational semantics to other languages that do not have one, such as LOTOS. Moreover, we have shown that our

logic could be seen as an institution, which has the benefits of enabling a refinement theory for mixed specification languages mapped into our logic.
A track of research is actually devoted to the study of symbolic models (STS). Our next work will be to study symbolic bisimulation and symbolic temporal logics (with actions) in the context of our logic, and to see if current proposals done specifically for CSP with value passing or for LOTOS may be generalized for a class of mixed specification languages such as Korrigan and our generic framework proposal for the integration of formal datatypes within state diagrams [4]. Further on, we are beginning a work on the categorization of notions of aspects and aspect combination operators. We already noticed common points between the definition of static and dynamic aspects within our logic and we think this can be investigated.

References
Aspect-Oriented Software Development, http://www.aosd.net/.
Aiguier,
M., F. Barbier and P. Poizat, A Logic for Mixed Specifications, Technical Report 73-2002, LaMI (2002), http://www.lami.univ-evry.fr/~poizat/documents/publications/RR-AB P02.ps.gz.
Allemand, M., C. Attiogbe, P. Poizat, J.-C. Royer and G. Salau¨n, SHE’S Project: a Report of Joint Works on the Integration of Formal Specification Techniques, in: INT’2002, Workshop on Integration of Specification Techniques with Applications in Engineering, 2002.
Attiogb´e, C., P. Poizat and G. Salau¨n, Integration of Formal Datatypes within State Diagrams, in: M. Pezz`e, editor, Fundamental Approaches to Software Engineering (FASE’2003), Lecture Notes in Computer Science 2621 (2003), pp. 341–355.
Bergstra, J., A. Ponse and S. Smolka, editors, “Handbook of Process Algebra,” North-Holland, 2001 pp. 427–478.
Borzyszkowski, T., Logical systems for structured specifications, Theoretical Computer Science
286 (2002), pp. 197–245.
Calder, M., S. Maharaj and C. Shankland, A Modal Logic for Full LOTOS Based on Symbolic Transition Systems, The Computer Journal 45 (2002), pp. 55–61.
Calder, M. and C. Shankland, A Symbolic Semantics and Bisimulation for Full LOTOS, in: M. Kim, B. Chin, S. Kang and D. Lee, editors, Formal Techniques for Networked and Distributed Systems (FORTE), IFIP Conference Proceedings 197 (2001), pp. 185–200.
Choppy, C., P. Poizat and J.-C. Royer, A Global Semantics for Views, in: T. Rus, editor, International Conference on Algebraic Methodology And Software Technology (AMAST’2000), Lecture Notes in Computer Science 1816 (2000), pp. 165–180.
Choppy, C., P. Poizat and J.-C. Royer, Formal Specification of Mixed Components with Korrigan, in: Asia-Pacific Software Engineering Conference (APSEC’2001) (2001), pp. 169– 176.
Choppy, C., P. Poizat and J.-C. Royer, The Korrigan Environment, Journal of Universal Computer Science 7 (2001), pp. 19–36, special issue on Tools for System Design and Verification.
Goguen, J. A. and R. M. Burstall, Institutions: abstract model theory for specifications and programming, Journal of the ACM 39 (1992), pp. 95–146.


Medvidovic, N. and R. N. Taylor, A Classification and Comparison Framework for Software Architecture Description Languages, IEEE Transactions on Software Engineering 26 (2000),
pp. 70–93.
Sannella, D. and A. Tarlecki, Toward formal development of programs from algebraic specifications: implementations revisited, Acta Informatica 25 (1988), pp. 233–281.
van  Oosten,  J.,  Basic  category  theory,  Lecture  Series  LS-95-1,  BRICS  (1995),
http://www.brics.aau.dk/BRICS/LS/95/1/BRICS-LS-95-1.ps.gz.
