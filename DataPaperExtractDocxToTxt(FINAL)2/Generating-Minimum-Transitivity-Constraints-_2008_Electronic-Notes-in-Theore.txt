Electronic Notes in Theoretical Computer Science 198 (2008) 3–17	
www.elsevier.com/locate/entcs


Generating Minimum Transitivity Constraints in P-time for Deciding Equality Logic
Mirron Rozanov and Ofer Strichman
Information Systems Engineering, IE, Technion, Israel.
mirron@tx.technion.ac.il	ofers@ie.technion.ac.il


Abstract
In a CAV’05 paper [6] we introduced a new decision procedure for Equality Logic: each equality predicate is encoded with a Boolean variable, and then a set of transitivity constraints are added to compensate for the loss of transitivity of equality. The constraints are derived by analyzing Contradictory Cycles: cycles in the equality graph with exactly one disequality. Such a cycle is called constrained under a formula ϕ if ϕ is not satisfied with an assignment of true to all equality edges and false to the disequality edge. While we proved in [6] that it is sufficient to constrain all simple contradictory cycles, we left open the question of how to find the necessary constraints in polynomial time. Instead, we showed two possible compromises: an exponential algorithm, or, alternatively, a polynomial approximation that constrains all contradictory cycles rather than only the simple ones. In this article we show a polynomial algorithm that constrains only the simple contradictory cycles.
Keywords: Equalities with Uninterpreted Functions

Introduction
Equality Logic with Uninterpreted Functions is a major decidable logic used in verification of infinite-state systems. Well-formed expressions in this logic are Boolean combinations of equality predicates, where the equalities are defined between term-variables (variables with some infinite domain) and Uninter- preted Functions. The Uninterpreted Functions can be reduced to equalities via, e.g., Ackermann’s reduction [1], hence the underling theory that is left to solve is that of Equality Logic. We refer the reader to [6] for a description of some of the usage cases of this logic and a survey of previous work on decision procedures for it.


1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.077

The following framework is used by [2,6] and the current work to reduce the problem of deciding whether an Equality Logic formula ϕE is satisfiable, to the problem of deciding a propositional formula:
Let E denote the set of equality predicates appearing in ϕE. Derive a Boolean formula У by replacing each equality predicate (xi = xj) ∈ E with a new Boolean variable ei,j. Encode disequality predicates with negations, e.g., encode i /= j with чei,j.
Recover the lost transitivity of equality by conjoining У with explicit transitivity constraints jointly denoted by 7 (7 for 7ransitivity). 7 is a formula over У’s variables and, possibly, auxiliary variables.
The Boolean formula Ул7 should be satisfiable if and only if ϕE is satisfiable. Further, it should be possible to construct a satisfying assignment to ϕE from an assignment to the ei,j variables.
In an earlier work [6] this framework was instantiated as follows (the terms that follow will be formally defined in Section 2). The transitivity constraints are derived by analyzing Contradictory Cycles: cycles in the Equality Graph with exactly one disequality. Such a cycle is called constrained under a formula ϕ if ϕ is not satisfied with an assignment of true to all equality edges and false to the disequality edge. While it was proven in [6] that it is sufficient to constrain all simple contradictory cycles, the question of how to find the necessary constraints in polynomial time was left open. Instead, two possible compromises were suggested: an exponential algorithm [5], or, alternatively, a polynomial approximation that constrains all contradictory cycles rather than only the simple ones. In this article we show a polynomial algorithm that constrains only the simple contradictory cycles.
While this article only replaces one (crucial) component in a previously- published decision procedure [6], it is written with the goal of being self- contained, assuming most readers are not familiar with the previous work 1 . In the next section we list several basic definitions that are necessary for understanding the setting; in Section 3 the main theorem on which this work (as well as [6]) is based on is re-presented; in Section 4 we describe the new decision procedure, and we conclude with a list of experiments in Section 5. A detailed comparison to [6,5] appears in Section 4.2.

Basic Definitions
The equality formula ϕE is assumed to be given in Negation Normal Form (NNF), which means that negations are only applied to atoms, or equality

1 Some of the definitions and examples from [6] are in fact repeated here without change.


x5	x6
x7	x8




x1	x2
x3	x4

Fig. 1. An Equality Graph G (ϕ )

predicates in our case. Every formula can be transformed to this form in linear time in the size of the formula. Given an NNF formula, denote by E= the set of (unnegated) equality predicates, and by E/=the set of disequalities (negated) equality predicates. The Reduced Transitivity Constraints (RTC) method of [6] relies on graph-theoretic concepts.
Definition 2.1 [Equality Graph] Given an Equality Logic formula ϕE, the Equality Graph corresponding to ϕE, denoted by GE(ϕE), is an undirected graph (V, E=, E/)= where each node v ∈ V corresponds to a variable in ϕE, and each edge in E= and E/=corresponds to an equality or disequality from the respective equality predicates sets E= and E/.= By convention E= edges are dashed and E/=edges are solid.
Every edge in the Equality Graph corresponds to a variable ei,j ∈ У. It follows that when we refer to an assignment of an edge, it should be understood as an assignment to the variable that corresponds to this edge. Also, we will simply write GE to denote an Equality Graph when not referring to a specific formula.
Note that Equality Graphs abstract the formulas from which they are built: they ignore the Boolean connectives. Hence, an Equality Graph GE(ϕE) represent all formulas that have the same predicate sets as ϕE.
Example 2.2 Figure 1 shows an Equality Graph GE(ϕE) for some equality formula ϕE for which E= : {(x1 = x5), (x5 = x6), (x6 = x2), (x3 = x7), (x7 = x8), (x8 = x4)} and E/=: {(x1 /= x2), (x2 /= x3), (x3 /= x4), (x3 /= x8)}. An assignment true to an edge (regardless whether it is an E= or E/=edge), means that the equality is satisfied. Hence, to satisfy an E/=edge an assignment false is required.
Transitivity of equality can be enforced for every three variables in ϕE:
Definition 2.3 [Transitivity Constraint] For variables xi, xj, xk, the con- straint
ei,j л ej,k → ei,k
is called a transitivity constraint.

Such constraints can be added to 7 for every three variables in ϕ (in fact, this was one of the methods suggested by Bryant and Velev in [2]), although typically it is possible to find efficiently a small subset of them that is still sufficient for the reduction, as shown in [2,6] and in this article.
Definition 2.4 [Equality Path] An Equality Path in an Equality Graph GE is a path made of E= (dashed) edges. Denote by x =∗ y the fact that x has an Equality Path to y in GE, where x, y ∈ V .
Definition 2.5 [Disequality Path] A Disequality Path in an Equality Graph GE is a path made of E= (dashed) edges and a single E/=(solid) edge. Denote by x /=∗ y the fact that x has a Disequality Path to y in GE, where x, y ∈ V .
Equality and Disequality paths are called simple if no vertex in the path is repeated. In Figure 1 it holds, for example, that x2 =∗ x5 due to the simple path x2, x6, x5; x2 /=∗ x5 due to the simple path x2, x1, x5; and x5 /=∗ x7 due to the simple path x5, x6, x2, x3, x7.
Intuitively, an Equality Path xi =∗ xj in GE implies that xi and yi are possibly required to be equal in order to satisfy the formula from which GE was built. A Disequality Path xi /=∗ xj implies the opposite: xi and xj are possibly required to be different in order to satisfy this formula. More formally, if xi =∗ xj in some equality graph GE, then there exists a satisfiable equality formula ϕE such that GE(ϕE) ≡ GE and in every satisfying assignment to ϕE, xi = xj. The formal description for xi /=∗ xj is similar.
Definition 2.6 [Contradictory Cycle] A Contradictory Cycle in an Equality Graph is a cycle with exactly one disequality (solid) edge.
Several characteristics of contradictory cycles are:
For every pair of nodes x, y in a Contradictory Cycle, it holds that x =∗ y
and x /=∗ y.
For every Contradictory Cycle C, either C is simple or a subset of its edges forms a Simple Contradictory Cycle. It is sufficient, therefore, to refer only to simple contradictory cycles.
It is impossible to satisfy simultaneously all the predicates that corre- spond to edges of a Contradictory Cycle. Further, this is the only type of subgraph with this property.
Let the positive set S of α be the positive literals in φ assigned true and the negative literals in φ assigned false. The polarity information (whether the edge represents an equality or disequality) in the equality graph is useful due to the following property of NNF formulas.

Theorem 2.7 (Monotonicity of NNF) Let φ be an NNF formula and α be an assignment such that α |= φ. Every assignment α' with a positive set S' such that S ⊆ S' satisﬁes φ as well.
The same theorem was used, for example, in [7].
Two graph-theoretical concepts that are used by our algorithm are:
Definition 2.8 [Chord] A chord in a cycle is an edge between two non- adjacent vertices.
Definition 2.9 [Chordal graphs] A graph is called chordal if no cycle of size four or more in the graph is chord-free.
Every graph can be made chordal in polynomial time by adding edges. The following procedure returns a set of chords sufficient for making a graph G(V, E) chordal:
While V /= ∅:
Choose a vertex v ∈ V ;
Add to E an edge between every two neighbors of v (if it was not already in E).
Remove v and its incident edges.
Return the set of edges that were added in line b.
The order by which vertices are chosen in line a affects the number of added chords. A simple greedy criterion is to choose the vertex that adds the least number of edges (finding the smallest set of edges that make a graph chordal is NP-hard).
Chordal graphs were used by [2] in the context of their observation that transitivity should be enforced only on chord-free cycles (which, in a chordal graph, are only the triangles). In [6], as well as in this paper, it is used in a different context, but with a similar purpose: it enables the algorithm to constrain only triangles. More specifically, although a graph (V, E) can contain an exponential number of contradictory cycles in |V |, it can only contain a polynomial number of triangles. Yet, enforcing transitivity on triangles (whether they are contradictory or not) is sufficient for enforcing it on all contradictory cycles, as shown in [6] and in Section 4.

Main Theorem
The key idea that is formulated by Theorem 3.4 below and later exploited by our algorithm rtcS , can first be demonstrated by a simple example.


x2
x0	x1


Fig. 2. An equality graph for Example 3.1, demonstrating how an assignment that contradicts transitivity, can be changed to one that respects transitivity.

Example 3.1 For the Equality Graph in Figure 2(left), the single transitivity constraint 7 = (e0,2 л e1,2 → e0,1) is sufficient.
To justify this claim, it is sufficient to show that for every assignment α that satisfies У л 7 , there exists an assignment α' that satisfies У and transitivity of equality. Since this, in turn, implies that ϕE is satisfiable as well, then it is implied that ϕE is equisatisfiable to У л 7 .
It is possible to construct such an assignment α' because of the monotonic- ity of NNF (recall that the polarity of the edges in the Equality Graph are according to their polarity in the NNF representation of ϕE). There are only two satisfying assignments to 7 that do not satisfy transitivity. One of these assignments is shown in the α column in the table to the right of the drawing. The second column shows a corresponding assignment α', which clearly sat- isfies transitivity. It is left to prove that every formula У that corresponds to the above graph, is still satisfied by α' if it was satisfied by α. For example, for У = (чe0,1 ∨ e1,2 ∨ e0,2), both α |= Ул 7 and α' |= У and respects transitiv- ity. Intuitively, this is guaranteed to be true because α' is derived from α by flipping an assignment of a positive (un-negated) predicate (e0,2) from false to true. Similarly, we can flip an assignment to a negated predicate (e0,1 in this case) from true to false.
A formalization of this argument requires a reference to the monotonicity of NNF (Theorem 2.7): Let S and S' denote the positive sets of α and α' respectively. Then in this case S = {e1,2} and S' = {e1,2, e0,2}. Thus S ⊂ S' and hence, according to Theorem 2.7, α |= У → α' |= У.
Several definitions are needed in order to generalize this example into a theorem.
Definition 3.2 [A constrained Contradictory Cycle] Let C = (es, e1,... , en) be a Contradictory Cycle where es is the solid edge. Let ψ be a formula over the Boolean variables in У that encodes the edges of C. C is said to be constrained in ψ if the assignment (es, e1,... , en) ← (F, T,... ,T ) contradicts ψ.

Definition 3.3 [A Reduced Transitivity Constraints formula 7 ] A Reduced Transitivity Constraints (RTC) formula 7 for an equality graph GE is a con- junction of transitivity constraints that constrains all the simple contradictory cycles in GE 2 .
Consider, for example, an Equality Graph in which all edges are solid (disequalities): in such a graph there are no contradictory cycles and hence no constraints are required: 7 = true.
Theorem 3.4 (Main) Let ϕE be an equality formula, and let 7 be an RTC formula for GE(ϕE ). Then ϕE is satisﬁable if and only if У л 7 is satisﬁable.
The proof of this theorem appears in [6] and [5]. Since 7 is a conjunction of transitivity constraints, the proof of the ‘only if’ direction (⇒) is trivial. To prove the other direction it is shown in [5] that there exists an algorithm for reconstructing an assignment that satisfies all transitivity constraints from a given assignment α that only satisfies 7 .
Given Theorem 3.4, it is left to show an algorithm that generates a formula that constrains all simple contradictory cycles. In [6] we presented the rtc algorithm for this purpose, parts of which are re-used here in the description of the new algorithm rtcS . The latter only constrains simple contradictory cycles, as it should according to Theorem 3.4, hence the superscript S. It is also simpler to describe and implement than rtc.

The	S algorithm
The rtcS algorithm processes Biconnected Components (BCC) [3] in the given Equality Graph.
Definition 4.1 [Maximal Biconnected Component] A Biconnected Compo- nent of an undirected graph is a maximal set of edges such that any two edges in the set lie on a common simple cycle.
It is sufficient to focus on BCCs because only cycles need to be constrained (more specifically, contradictory cycles). Each considered BCC contains a solid edge es and all the contradictory cycles that it is part of. In line 4, rtcS makes the BCC chordal, by adding edges. After the graph is chordal rtcS

calls
Generate-constraintsS , which strengthens 7 with all the transitivity

constraints that are necessary for constraining all the contradictory cycles in this BCC with respect to es.

2 The definition of this term in [6] includes an additional requirement, that it is not more restrictive than the constraint generated by Bryant and Velev’s Sparse method technique. This restriction is not necessary in our context.



Algorithm 1 rtcS returns a formula 7 , which conjoins all the transitivity constraints that are sufficient and necessary in order to constrain all simple contradictory cycles in a given equality graph.
rtcS (Equality Graph GE(V, E=, E/)=)
1: 7 = true
2: for all es ∈ E/=do
3:    Find B(es), the maximal BCC in G  that is made of es and E= edges;
4:    Make B(es) chordal;	d This step adds new dashed edges.
5:	Generate-constraintsS (B(es));	d see Algorithm 2.
6: end for
7: return 7 ;
A possible optimization to rtcS is to reuse chords: denote by Ep the union of chords that were added in previous iterations of the algorithm (when other
BCCs were considered), and GE edges. The greedy criterion by which vertices
/=
are chosen (see the algorithm for making graphs chordal after Definition 2.9) should be changed as follows: rather than counting the number of added edges, count only those edges that are added and are also not in Ep (since Ep edges are already represented in the resulting formula). This optimization reduces the number of added chords and, consequently, the number of variables and constraints.

Deriving transitivity constraints in P time
Let B be a chordal biconnected component in which there is a single solid edge es adjacent to vertices xs,x' . The algorithm in Fig. 2 finds the necessary and sufficient constraints for constraining all the simple contradictory cycles with respect to es. We will use a convention by which removing a vertex implies removing its incident edges. Also, we will use set notation for graph elements when the meaning is clear from the context, for example:
(xi, xj) ∈ B means that the graph B has an edge (xi, xj),
B' ⊆ B means that B' is a subgraph of B,
B \ v is the graph B after the removal of the vertex v and its incident edges from B.
Two comments about Generate-constraintsS :
An optimization for line 5 is to add the constraint only if it was not added before. Our implementation in fact maintains the constraints as a set, and generates 7 only in the end.
The condition in line 4.1 can be checked in polynomial time, by, for example,

Algorithm  2
Generate-constraintsS  adds transitivity constraints to a

(global) formula 7 , that are sufficient and necessary for constraining all the simple contradictory cycles in a given bi-connected component with a single
 solid edge es = (xs, x' ).
1: procedure Generate-constraintsS (Chordal BCC B(V, E))
2:	for each vertex v ∈ {V \ {xs, x' }} do
3:	Let B' = B \ v.
4:	for every (xi, xj) that
is on a simple cycle with es in B' (or es ≡
(xi, xj)), and
{(v, xi), (v, xj)} ∈ B
do
5:	7 = 7 л (ev,xi л ev,xj → exi,xj )
6:	end for
7:	end for
8: end procedure





x1	x2	x3

x6	x5	x4
Examining...	Added constraints
x2	e1,2 л e2,5 → e1,5
x3	e2,3 л e3,4 → e2,4
x4	e2,4 л e4,5 → e2,5
x5	e1,5 л e5,6 → e1,6



Fig. 3. An Equality Graph for Example 4.2.
building a maximal BCC B'' around es in B'. Every edge in B'' is on a simple cycle with es in B'.
Example 4.2 Consider the Equality Graph in Figure 3. Assume that the vertices are examined in line 2 in an order corresponding to the variable index. For this graph, x1, x6 are those vertices called xs, x' in Generate-constraintsS . The first vertex examined in line 2 is therefore x2. The edge (x1, x5) is the only one fulfilling the two conditions: (x2, x1), (x2, x5) are edges in B, and it is on a simple cycle with es in B'. Indeed, (x1, x5) is an edge in B'' = (x1, x6, x5), the maximal BCC that contains es after the removal of x2 and its incident edges. Therefore the constraint e1,2 л e2,5 → e1,5 is the only one added in this iteration. The table below shows the constraints added in each iteration.
Theorem 4.3 For a chordal BCC B with a single solid edge es, the con- straints added by Generate-constraintsS (B) are suﬃcient and necessary for

constraining all simple contradictory cycles in B.
Proof. (Sufficiency) We first prove the following:
Lemma 4.4 If for every triangle (xi, v, xj) in B such that (xi, v), (v, xj) /= es and (xi, v), (v, xj) is part of a simple contradictory cycle, the transitivity constraint ei,vлev,j → ei,j is in 7 , then 7 constrain all the simple contradictory cycles in B.
Proof. Let C be a simple contradictory cycle in B. By induction on the size of C:
Base: Let C be a triangle (xi, v, xj), where (xi, xj) is the solid edge es. Since (xi, v), (v, xj) are part of a contradictory cycle, the constraint ei,v лev,j → ei,j is in 7 . Thus, C is constrained in C.
Step: Assume the Proposition holds for C of size n (n ≥ 3), and consider C with size n+1. Since C is chordal, it can be decomposed into a triangle, say xi, v, xj, and another contradictory cycle C' = C \ {(xi, v), (v, xj)} ∪ (xi, xj) (this observation is proven as Proposition 2 in [5]). By the induction hypoth- esis, C' is constrained by 7 (since |C'| = n). The constraint ei,v л ev,j → ei,j is in 7 because (xi, v), (v, xj) is part of C, which, recall, is a simple contradic- tory cycle. Now, assume that C is not constrained by 7 , i.e. an assignment α that assigns true to all dashed edges and false to es still satisfies 7 . In this assignment ei,v, ev,j are assigned true, but then ei,j is assigned true as well due to the constraint mentioned above. Hence, in C' all dashed edges are assigned true whereas es is assigned false, which contradicts the induction hypothesis.	 
It is left to show that the constraints added by rtcS satisfy the premise of Lemma 4.4, i.e., that it adds a constraint ei,v л ev,j → ei,j for every triangle (xi, v, xj) in B such that (xi, v), (v, xj) /= es and (xi, v), (v, xj) are part of a simple contradictory cycle.
Lemma 4.5 Let (xi, v, xj) be a dashed triangle in B such that there exists a simple contradictory cycle through (xi, v), (v, xj). Then there exists a simple contradictory cycle in B through (xi, xj) that does not go through v.
Proof. Let C be a simple contradictory cycle that goes through (xi, v), (v, xj), and let C' = C \ {(xi, v), (v, xj)}∪ (xi, xj). Observe that in a simple cycle C, the degree of each vertex (counting only C edges) is 2. It is easy to see that the degree of each vertex in C' is the same as in C, other than v for which the degree is reduced from 2 to 0 (which means that is not part of C'). Hence C' is simple and does not go through v.	 


x1	x2	x3	x4

x8	x7	x6	x5
Fig. 4. An Equality Graph that demonstrates the difference between rtc and rtcS.
The contra-positive conclusion from Lemma 4.5 is that if (xi, xj) is not part of a simple contradictory cycle with es in B', then (xi, v), (v, xj) is also not in a simple contradictory cycle with es. But since this is the only case in which Generate-constraintsS does not add a constraint, we conclude that it adds the constraints as required by the premise of Lemma 4.4, i.e. it adds a constraint ei,v л ev,j → ei,j for every triangle (xi, v, xj) in B such that (xi, v), (v, xj) /= es and (xi, v), (v, xj) are part of a simple contradictory cycle. Hence, by Lemma 4.4, 7 constrains all simple contradictory cycles in B.
(Necessity) Falsely assume that there is a redundant constraint, e.g. there exists a constraint exi,v лev,xj → exi,xj although (xi, v), (v, xj) is not part of a simple contradictory cycle or that (xi, xj) /∈ B. If this constraint is added (in line 5), it means that (xi, xj) is part of a simple contradictory cycle C' with es not through v. But this means that C = C' \(xi, xj) ∪ {(xi, v), (v, xj)} must be simple as well (it adds a vertex v with degree 2, and does not change the degree of the other vertices), which contradicts the assumption.

The differences between rtc and rtcS
As was mentioned earlier, the original Generate-Constraints procedure that appeared in [6] added enough transitivity constraints to constrain all contra- dictory cycles, and not just the simple ones as required by Theorem 3.4. The graph in Figure 4 demonstrates the difference between the results of the two al- gorithms. Consider the constraints that are added when removing x7 in line 2 of rtcS : the edge (x1, x8) is es itself and hence the constraint e1,7лe7,8 → e1,8 is added. No other edge fulfills the condition in line 4.1. Generate-Constraints, on the other hand, adds, for example, also the constraint e6,7 л e5,7 → e5,6, because of the non-simple cycle (x1, x2, x3, x5, x7, x6, x7, x8, x1).  All together

Algorithm
Generate-constraintsS generates 16 constraints for this graph,

whereas Generate-Constraints generates 26 constraints.
Algorithm Generate-constraints of [6] traverses the BCC, each time ex- panding the contradictory cycle while adding transitivity constraints. It starts from each triangle that one of its edges is es. From there it gradually increases the cycle it examines (at each step it replaces an edge with two edges that lean


Table 1
Experimental results of rtcS vs. rtc on randomly generated graphs. Each line in the table corresponds to an average on (the same) 10 graphs, but with a varying percentage of dashed vs. solid edges.
on that edge) while adding constraints. To avoid traversing an exponential number of paths, it uses a cache of constraints, and stops traversing the graph in a direction that results in a constraint that already appears in the cache. This, in turn, requires that all cycles are traversed, rather than only the simple ones. In [5] we also showed an algorithm that does not use the cache, and hence generates the requested formula (i.e. not overly constrained), but the algorithm there is worst-case exponential.

Experiments and conclusions
We re-ran the experiments with random equality graphs, which were first presented in [6]. Table 1 presents the comparison. Each line in the table cor- responds to the same 10 randomly generated topologies, with 1% of ‘double edges’ (edges that are both solid and dashed), the % of dashed edges as spec- ified in the first column, and the rest are solid. The number of vertices is 200, and the number of edges is 800.
Overall, there is a decrease of 17% in the number of transitivity constraints, and 32% decrease in the run time of the algorithm (not including SAT time). For comparison, on the same graphs the sparse method [2], which generates three constraints for each triangle in the graph regardless of their polarity, generates 390165 constraints on average (regardless of the ratio between solid and dashed edges). For most of these graphs the formula could not be generated by the exponential method of [5].
As expected, rtcS is better in practice than rtc, both in terms of the size of the generated formula, and the overall running time. The difference in the run time of SAT between the formulas generated by rtc and rtcS was quite

x2	x5


x1	x3n+1



Fig. 5. An equality formula corresponding to the crafted examples.
negligible in these cases.
Is rtcS competitive with lazy-style solvers? Although we did not check it systematically, we expect that on instances with many uninterpreted functions (as most of the benchmarks in the SMT-LIB [8] suite are), the answer is no. As was noted in [6], lazy solvers are likely to perform better in such cases, since the reduction to equality logic using Bryant’s reduction creates graphs in which most of the edges are both dashed and solid, a case in which rtcS has no advantage in comparison to the sparse method of Bryant and Velev [2] (which by itself, as far as we know, has never been compared experimentally to some of the modern implementations based on congruence closure, such as [4]). We also noticed that large graphs (with a 150 nodes or more) with a high degree of connectivity, as the ones created when reducing uninterpreted functions, frequently lead to an excessive run time in making them chordal, despite the polynomial upper-bound on the running time of this operation.
Are there cases in which rtcS has an advantage over lazy-style solvers? To test this question we compared rtcS to Yices (version 1.09), where the propositional formulas generated by rtcS were solved with Yices as well. The comparison was done on crafted examples without uninterpreted functions. It turns out that generating random CNF-s is rather meaningless in this context, because it is very unlikely that in such formulas every assignment that satis- fies the skeleton will correspond to a contradictory cycle. Indeed, in all the experiments we made with random CNFs, the formulas were satisfiable and very easy to solve by both methods. We therefore crafted a set of formulas whose respective equality graph follow the pattern that appears in Figure 5. The number of ‘diamonds’ is denoted by n, hence the right most node is x3n+1.
The checked formula is
x1 /= x3n+1л
((x1 = x2 л x2 = x4) ∨ (x1 = x3 л x3 = x4))л
(1)
.
((x3n−2 = x3n−1 л x3n−1 = x3n+1) ∨ (x3n−2 = x3n л x3n = x3n+1)) ,
which is unsatisfiable for all n > 0. There are 4n + 1 edges and hence Boolean

variables in the formula’s skeleton. Satisfying either the top or bottom path of each diamond (or both), together with the disequality x1 /= x3n+1, satisfies the Boolean skeleton of the formula.	Yet each such satisfying assignment corresponds to a contradictory cycle, which makes the formula unsatisfiable. This type of formula is expected to be hard for lazy-style solvers, because there is an exponential number of solutions that satisfy the skeleton, none of which is a real solution (it seems that theory propagation and learning cannot be effective in this case either). The results, in seconds, appear in the table below. TO denotes a timeout of 1 hour. It is clear that in such formulas
indeed rtcS has an advantage.

To summarize, as indicated in the introduction, rtcS dominates the two previ- ously published alternatives: rtcS is polynomial in contrast to the exponential algorithm described in [5], and it generates formulas that are guaranteed to be smaller and less constrained than the formulas generated by the polyno- mial approximation offered by rtc (or, if it happens to be that there are no non-simple cycles, it generates an equivalent formula). It is also simpler to implement and (subjectively) more elegant than rtc.

References
Ackermann, W., “Solvable cases of the Decision Problem,” Studies in Logic and the Foundations of Mathematics, North-Holland, Amsterdam, 1954.
Bryant, R. and M. Velev, Boolean satisﬁability with transitivity constraints, in: Proc. 12th Intl. Conference on Computer Aided Veriﬁcation (CAV’00), Lect. Notes in Comp. Sci. 1855, 2000.
Cormen, T., C. Leiserson and R. Rivest, “Introduction to Algorithms,” MIT press, 2000 p. 563.
Ganzinger, H., G. Hagen, R. Nieuwenhuis, A. Oliveras and C. Tinelli, DPLL(T): Fast decision procedures, in: Proc. 16th Intl. Conference on Computer Aided Veriﬁcation (CAV’04), number 3114 in Lect. Notes in Comp. Sci. (2004), pp. 175–188.
Meir, O., “A decision procedure for equality logic,” Master’s thesis, Technion (2005), URL: ie.technion.ac.il/∼ofers/publications/theses/orly-meir.pdf.gz.
Meir, O. and O. Strichman, Yet another decision procedure for equality logic, in: K. Etessami and
S. Rajamani, editors, Proc. 17th Intl. Conference on Computer Aided Veriﬁcation (CAV’05), Lect. Notes in Comp. Sci. 3576 (2005), pp. 307–320.

Pnueli, A., Y. Rodeh, O. Strichman and M. Siegel, The small model property: How small can it be?, Information and computation 178 (2002), pp. 279–293.
Ranise,  S.  and  C.  Tinelli,  The Satisﬁability Modulo Theories Library (SMT-LIB),
www.SMT-LIB.org (2007).
