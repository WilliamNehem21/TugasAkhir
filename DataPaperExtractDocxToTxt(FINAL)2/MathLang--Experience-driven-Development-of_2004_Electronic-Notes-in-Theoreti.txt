 Electronic Notes in Theoretical Computer Science 93 (2004) 138–160 
www.elsevier.com/locate/entcs




MathLang: Experience-driven Development of a New Mathematical Language
Fairouz Kamareddine1	Manuel Maarek1	J. B. Wells1
ULTRA Group Heriot-Watt University Edinburgh, Scotland

Abstract
In this paper we report on the design of a new mathematical language and our method of designing it, driven by the encoding of mathematical texts. MathLang is intended to provide support for checking basic well-formedness of mathematical text without requiring the heavy and difficult-to- use machinery of full type theory or other forms of full formalization. At the same time, it is intended to allow the addition of fuller formalization to a document as time and effort permits. MathLang is intended to, ultimately, be useful in providing better software support for authoring mathematics, reading mathematics, and organizing and distributing mathematics. The preliminary language presented in this paper is intended only for machine manipulation and for debugging of the design of MathLang.
Keywords: Mathematical language, Mathematical vernacular, Mathematical knowledge management Weak types, MathLang


Introduction
Data management has become an important area for automation. Editing, storage, publishing, data retrieving and other computations are gratefully helped by computers with appropriate software. Nowadays computers could be used at each step of writing texts, the use of pen & paper may not be essential. Could we make the same remark for mathematical work? Would it be possible for a mathematician to use computers as a help tool from scratch to treatise?

1 http://www.macs.hw.ac.uk/ultra/



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.12.032

Current situation of mathematics on computers
Putting mathematics on computers.
First of all, to use computers for mathematical purposes, we need to put mathematical content inside them. Different ways to do so exist:
One can scan mathematical books and store their images on electronic sup- port. This solution brings no facilities of computation and even no auto- matic search on data.
One can encode mathematics. Programs could then deal with these encoded mathematical data. Storage is possible, and so are computations on data such as visualizing, calculating, analysing and searching.

Existing encodings.
Many languages to encode mathematics exist already. We sort them in categories based on what they were invented for:
Languages for printing mathematical symbols on paper/screen (e.g. LATEX). Since they follow a rendering aim, they encode only the shape of a docu- ment and not its meaning.
Languages for theorem provers and computer algebra systems (see [14]) which try to formalize mathematics. These systems claim to assist the mathematician to prove theorems by verifying them.
Languages which store the semantical structure of mathematical texts without checking it (e.g. OMDoc [6]). They combine natural language with notions like formulae or text structures (theorems, examples,...).

Use of encoded texts.
Choosing an encoding depends on its intended use. Hence we need to know what computers could do to assist the mathematician in his work. Mathemat- ical work could be summarized in three levels:
At the first one, the mathematician starts from scratch to put down more or less random ideas. He organizes, polishes and refines them.
At the second level, ideas evolve into clearer views and theories begin to take shape. Things move to a concrete form that allows publications.
At the last level, calculations and proofs take place. Details need to be clarified to reach complete theories. This level leads to a full formalization.
At each of these levels we deal with mathematical data. From structured but not complete content in the first level to formalized data at the latter. None of the encoding listed above satisfies the needs of all these levels:

Languages for rendering (A) do not capture the semantics of a text (for use in level 3).
Languages in (B) are too strict to encode incomplete (from level 1) or partly- formalized (from level 3) mathematical contents.
Languages in (C) do not allow enough automation to benefit from computers at each level.
Thus we gather that currently there is no language to encode mathematics to be used at every level of mathematical work.

Our Concerns
N.G. de Bruijn in his extensive writings and different stages of mathematical languages and vernaculars proposed that “the way mathematical material is to be presented to the [computer] system should correspond to the usual way we write mathematics.” We are proposing a language, MathLang to realise this proposition. MathLang goals could be described following four main concerns for mathematics on computers.
The first concern is to be able to automate computations of data encoded in MathLang to use computer skills. For this reason we have designed Math- Lang using a full symbolism (that is to say every element of the language consists of recognisable symbols). This facilitates the manipulations that can be done by the computer.
When using existing formal languages to write mathematics, one needs to be sure that the mathematics used will fit in the underlying logic of the lan- guage. This restricts the expressivity of the language. To cover all math- ematics, MathLang is intended to describe the structure of mathematical texts and their reasoning steps.
Having a grammatical encoding for mathematical texts brings obviously the need to have properties of these texts. A type system validates the grammatical structure of a MathLang text. A sentence like “if x belongs to M then x + y = y + x” will be valid if x, y, M, “belongs to”, “if”, + and = are known beforehand and satisfy some weak typing relations. Otherwise, “if x belongs to M then x + y” does not make sense and is pointed as incorrect with the MathLang type system.
Our last important concern is to provide a user interface for the working mathematician. Providing one language which allows to encode any mathe- matics and to leave the possibility of further transformations through more formal data, will make the step of bridging mathematics and computers as smooth as possible.

From MV to WTT to MathLang

In 1979, de Bruijn developed a course on the Mathematical Vernacular (MV) intended to be a language to write mathematics. This course became part of the curriculum for mathematics teachers in the Netherlands. In 1987, almost twenty years after the beginning of Automath, de Bruijn published an article on MV (cf. F3 of [11]). In MV, a Mathematical text is seen as a set of lines. Each line being either the introduction of a new notion or an assumption, these in a certain context. The structure of a text is line-by-line where each notion used in a line should have been defined beforehand. This structure was inspired by the development of the language Automath. In MV a notion of typing gives meta-information in the language. Two levels of typing are described: the low typing which expresses that an object is part of a certain set and the high typing which indicates the grammatical category of which an expression is part. All this makes MV:
faithful to the mathematician’s language while being formal and avoiding ambiguities;
close to the way in which mathematicians express themselves in writing;
possess a syntax based on linguistic categories rather than sets/types;
mainly concerned with structural rather than logical correctness.
The type theory of MV is weak because it is composed mostly by atomic types. These types refer to the grammatical categories of a Mathematical text. Using the rules of MV one can check if the reasoning structure of a text is valid. After de Bruijn’s retirement, Nederpelt took over the course and continues to teach it today. Nederpelt refined MV into the so-called Weak Type Theory (WTT) which has a precise abstract syntax. This makes it possible to establish important desirable properties such as strong normalisation, decidability of type checking and subject reduction as was done by Kamareddine. For details on MV and WTT, see [11,5].
Since MV and WTT are said to help provide a language to encode math- ematics which can be used at every level of mathematical work, we set out to test these languages through the Foundations of Analysis (E. Landau [9]) which is already fully formalised in Automath [13] by Bert van Benthem- Jutting. Since our aim is not the full formalisation, but an encoding which allows a full formalisation at a later stage, we felt that choosing a fully for- malised book for our encoding, would allow us in the future, to compare the already existing full formalisation, with the full formalisation that could be built on top of our encoding. This paper reports the extensions that had to be made to WTT to encode the first chapter while remaining faithful to

the mathematician’s intentions and keeping the road open to reach (in the long run) a full formalisation that can be compared to that of Automath. In particular, we present the language MathLang, the implementation we have made of its type checker and an overview of the MathLang translation we have done of the first chapter of E. Landau [9]. In Section 2, we give the abstract syntax of MathLang. To illustrate the use and extensions of Math- Lang we give examples taken from our translation of the first chapter of [9]. In Section 3, we describe the derivation rules of MathLang. In Section 4 we discuss our implementation of MathLang and present the full translation of the first chapter which is automatically checked by our software. In Section 5 we discuss related and future work and we conclude.

Abstract syntax of MathLang
MathLang is an extension of both MV and WTT. It attempts to be closer to a grammatical encoding of the reasoning structure of Mathematics. MathLang is designed to encoded entire mathematical texts. It is composed by several grammatical levels to distinguish mathematical structures from symbols to en- tire books. The levels define grammatical categories as groups of mathematical objects. In this section we will first explain what we mean by grammatical categories (Section 2.1) and then describe the grammatical levels (Section 2.2). The abstract syntax is presented here with examples of MathLang encodings taken from our translation of the first chapter of E. Landau’s Foundations of Analysis [9].
Grammatical categories
MathLang extends the grammatical categories of WTT which in turn extends those of MV.
T We first have a grammatical category that groups the so-called terms which are common mathematical objects like “x+ 1”, “the point A”, or “a triangle ABC”. T denotes the set of terms.
S Then we have the sets of mathematical objects like “N” (the set of natural numbers). We name this category sets and use S for the set of sets.
N The nouns grammatical category is commonly used in mathematics to desig- nate families of terms. For example in the sentence “1 is a natural number”, “natural number” is a noun. The set of nouns is represented by N.
A In MathLang, a noun could be defined from another noun. For example, “isosceles triangle” is a noun. It is a restricted family of “triangle”. We define adjectives as the kind of expressions that refine and/or change the

meaning of a noun. “Isosceles” is then an element of the set A of adjectives.
P Expressions like “x = 1” or “∀x ∈ N,x ≥ 1” which describe mathematical properties are statements in MathLang. P is the set of statements.
D The sentences that define new symbols in mathematical texts are called definitions in MathLang. For example, “We define x + y such that ...” belongs to the set D of definitions.
Z The grammatical category of declarations groups variable declarations like “let M be a set”. Elements of the set of declaration Z could be components of contexts (see below).
Γ, ΓF and ΓFS Construction like “let x be in M”, “assume that y > x + 1 ”, etc., are elements that build a context. These are declarations and assumptions needed before stating properties. Combinations of this kind of expressions are named contexts and belong to the set Γ. Furthermore, for assumptions and declarations which cover a certain paragraph, we have the notion of flags (see Example 2.3).
L Lines in MathLang are steps of reasoning in mathematical texts. They sometimes correspond to real lines in texts.
K Proofs, examples, paragraphs or sections are groups of lines. We designate them by blocks. K is the set of blocks.
B The grammatical category of books designates MathLang documents. A mathematical text corresponds to a book and so is an element of B.
Figure 1 shows an example of a mathematical text with a diagram of the corresponding MathLang structure. MathLang can be seen as providing for a mathematical text, a grammatical structure that is not necessarily what would result from an analysis by linguists. Section 3 explains how one can check the well-formedness of a MathLang structure. Although the long-term goals of MathLang include the integration with mathematical texts written in natural language, we do not yet do this — the figure is purely to help understand the eventual role we expect MathLang to play. We do not yet have any mechanism for matching a MathLang structure with actual natural language mathematical text.

Grammatical levels
In this section we describe the four grammatical levels of MathLang: atomic, phrase, sentence and discourse. We extend the elements of the third and fourth levels of WTT. We will illustrate these extensions with examples taken from our translation of the first chapter of [9] (see the authors’ web pages for the translation of the full chapter). Examples 2.2, 2.3, 2.4 and 2.5 illustrate Math-


Let	M	be the set of ...,	y	a natural number,... if	x	belongs to	M
S		T		N	T		S Z		Z			P
Γ
then	x	+	y	=	y	+	x

Fig. 1. A mathematical line and its MathLang grammatical categories

Lang constructions: flags, definitions by cases, blocks and references. As to the notations we use to print MathLang texts, note that the language Math- Lang is still in development since the translations of the other chapters will no doubt call for further extensions. For this reason the MathLang texts given here are rendered with an experimental syntax which we intend to improve. Currently, the concrete syntax of MathLang is implemented using the XML recommendations. We have made this choice to facilitate transformations on MathLang data. One of these transformations produces automatically the renderings shown in this paper. Below is an example. (i) being line numbers and {i.i} being block indices. In a line, the symbol D separates the context from the new statement or the new definition.
context elements D line body	(1)


lines in
block
block name



{list of constants local to the block }
{1.1}
(2)
(3)
(4)



lines	(5)
sharing	(6)
the same	(7)
flag	(8)
The atomic level is composed by identifiers: the mathematical symbols. There are three kinds of identifiers: variables (undefined mathematical objects), constants (defined objects) and binders (to write constructions which locally introduce a variable).
Variables v ∈ V	Constants c ∈ C	Binders b ∈ B

Whereas constants and binders can be of any grammatical category, a variable can only be a term or a set or a statement. We use superscripts to denote the relevant category. For example, v ∈ V T means that v is a variable of category T.

Example 2.1 Identifiers
In an expression (taken from our translation of the first chapter of [9]) like ∀x : M,x +1 = x':
x, M are variables
:, 1, +, = and ' are constants
∀ is a binder

The phrase level is the formula level. It describes how to construct terms, sets, nouns and adjectives. Four constructions exists. Variable instanti-
→
ations V . Constant calls C( E). Abstractions with binders BZ(E). And
attributions AN that attribute an adjective to a noun to create a new noun.
Terms	t ∈	T ::=	V T | CT(→) | BT(E)

E
Sets	s ∈	S ::=	V S | CS →
Z
| BS(E)

Nouns	n ∈	N ::=	CN →
Adjectives	a ∈	A ::=	CA →
| BN(E) | AN
| BA(E)

→
We take E and Z as below. We also take E to be a list of E’s.
Expressions	e ∈	E ::=	T | S | N | P
Declarations	z ∈	Z ::=	V T : S | V T : N | V S : SET | V P : STAT
The set Z describes the four constructions which declare a new variable. In the first two constructions, the colon states the belonging of the de- clared variable. The variable on the left side of the colon belongs to the entity on the right side of the colon. The first construction introduces a term variable by stating in which set the term belongs (expression from S). The second also introduces a term variable but by stating of which noun it is an instance of (expression from N). With the keyword : SET (resp. : STAT), the third (resp. fourth) construction introduces a new set (resp. statement) variable.
The sentence level defines how to construct one step of reasoning: either statement or definition. Note the extension with definitions by cases in
→
C( E) := E.



Statements	p ∈	P ::=	V P | CP →
| BP(E)

Definitions	d ∈	D ::=	CT
|	CS
|	CN
|	CA
|	CP
→
(V ) :=
→
(V ) :=
→
(V ) :=
→
(V ) :=
→
(V ) :=
→
( E) := T
→
( E) := S
→
( E) := N
→
( E) := A
→
( E) := P

As we see, the set of definitions D is composed by two kinds of con-
→
structions. The first, C(V ) := E (representing constructions of the left column) gives an expression as a full definition for the constant. Each
parameter of the constant is a variable (these parameters are represented
→	→
as a list of variables: V ). The second, C( E) := E (representing construc-
tions of the right column) is used to define a constant with several cases (by providing each time an expression). Each case of the definition will be described using one definition line (see the lines in the discourse level).
→
The parameters are now pattern expressions that match the case ( E). MathLang type analysis (see Section 3) checks that variables appearing
in the patterns are well declared in the context. MathLang checking per- forms only this kind grammatical analysis. Note that no comparisons of cases to find uncovered cases or unused ones are done while this is a more semantical analysis.
Example 2.2 Definitions by cases
A common way to define mathematical objects is to use cases. As an ex- ample we take the following text from Landau’s Definition 1 of Chapter 1, Section 2:
We only consider the definition of the + operator which is recursively defined by two equations. The definition by cases we have introduced in MathLang gives an encoding of this kind of mathematical definitions. This encoding is closer to the original text than was the normal encoding in MV and WTT (that is to say, providing a unique object as definition). This normal encoding of MV and WTT can still be made in MathLang

as follows:


x : N,y : N	D +(x, y) := ιz:N ((y =1 =⇒
′
z = x )
∧ ∃t:N
(y = t′
=⇒ z = (x + t) ))


This MathLang text defines x + y in one line. The two cases of the original text are represented by a conjunction of two implications. This encoding however is not close enough to the original text. The original definition of + is explicitly composed by two cases while here it is merged in one case using the logical symbols of implication =⇒ and conjunction
∧ which are not properly defined in E. Landau’s text.
Let us see now how the same definition of the addition of natural numbers could be expressed in MathLang using, this time, a definition by cases. As it is written in E. Landau’s text, in both cases we assign a term to the addition of a pair of terms:

Definition 1
x : N D+(x, 1) := x'
x : N, y : N D+(x, y') := (x + y)'
{2.4}
(38)
(39)

In MathLang, a definition by cases defines a constant using several lines. Each line being one case. This construction brings MathLang closer to the original text for two reasons. First, to each original case corresponds one case in MathLang. Second, in this encoding we are not using additional constants. We do not need logical symbols as we did in the earlier translation of MV and WTT. These logical constructions may not always be explicitly defined in the mathematical text.
The discourse level gives constructions to describe the structure of math- ematical texts. Note the extension with flags, flagstaffs and blocks.






C
Books	b	∈	B	::=	∅B | B ◦ L | B ◦ {K}→
C
It starts with the line construction which could be seen as a step of rea- soning. A line is a mathematical sentence expressed in a specific context.

A context being a sequence of declarations (Z) and assumptions (state- ments P). Then we have blocks that group lines and sub-blocks together (expressing for example that several consecutive lines proving a certain proposition should be considered as one entity together). They allow one to specify a set of constants ({ }c1,...,cn) which will be local to the block.
→
We take C to be a list of C’s. The use of these constants is then restricted
to the block in question. ∅K stands for the empty block. Lastly books are defined as sequences of lines and blocks. ∅B stands for the empty book.
MathLang contexts are described using the three sets Γ, ΓF and ΓFS.
∅Γ stands for the empty context. To extend MV and WTT contexts, we have introduced in MathLang’s abstract syntax a construction to scope variables or assumptions on several lines. This uses the flag notation already present in MV but only as syntax sugaring. Flags were used as syntax sugaring to avoid repetition of similar elements in consecutive contexts and so to reduce the size of MV or WTT examples. Moreover, flags help clarify the scope of a variable or an assumption over several lines. We introduce flags in MathLang’s abstract syntax since we consider it important to have this scope information encoded in the language. Flags are composed of a head (a statement or a variable declaration in [ ]) and a flagstaff (several •). We will use a specific notation for flags as shown here:
ezi is a statement or a variable declarations and ei is a line body.

Example 2.3 Flags
Our MathLang translation of the definition and the proof of theorem 2 from chapter 1, section 2 illustrates the use of flags. In Figure 2, we

give the original text of this example and an output of our MathLang translation. Note that line numbering starts at 24 since the earlier parts of the chapter occupy the other 23 lines. Note also that x' is the successor of x. We refer the reader to authors’ web pages for the translation of all the first chapter.





x : N DTh2(x) := x /= x′	(24)
Proof Theorem 2 {2.2}


6x:MTh2(x)
Ax1, Ax3(1) D1′ /=1 (25), (Def Th2) D1: M

(25)
(26)



Dx′ /= x
, Th1(x′, x) Dx′′ /= x′
, (Def Th2) Dx′ : M
(27)
(28)


Ax5(M, (26), (29)) DN ⊂ M	(30)

D6x:N
Th2(x)








Fig. 2. Flags example

By looking quickly at this example we see that a commonly used sentence “let a variable be something in the following ...” is easily expressible with a flag in MathLang. In this example the first two flags respectively introduce a set of variables and state that Theorem 2 holds for it. The third flag introduce the hypothesis that x is in M. With MathLang’s flags, one could express that the variables x used in lines 27 to 29 stand for the same object. In MV and WTT these variables x would have been introduced three times (one time per line) and there would have been no possibility to retrieve the strong link that unify them together.

Example 2.4 Blocks
In MathLang we introduced in the abstract syntax the notion of blocks of lines. Blocks were already used at the metalevel in F3 of [11] where they were linked with flags. In MathLang we have separated both no- tions: flags extend the contexts whereas blocks describe the structure of a text. In mathematics, sections or delimiters (of proofs or examples) give important information to the reader and help him understand and follow the author’s reasonings. Blocks in MathLang describe the structure of the text. Our encodings above of Definition 1 (see Example 2.2) and of the Proof of Theorem 2 (see Figure 2 of Example 2.3), give examples of blocks.
In MathLang, a block denotes a structure. It is possible to restrict the definition of a constant to a precise block, we call this constant local. An example of these local constant could be seen in our translation of the first chapter of [9] with blocks {2.5.1} and {4.2.1}. Each of these blocks represents a part of a proof of a theorem (respectively part A of Theorem 4 and part A of Theorem 28) where the local constants a and b are defined.
Although we make heavy use of blocks and we fully incorporate them in the implementation, we still do not have rules that help derive useful information about these blocks. For example, we still cannot formally state that a certain block is a proof of a given theorem.
Example 2.5 References
The example given in Figure 3, from chapter 1, section 2 (part of the proof of Theorem 4), illustrates the use of line and definition references in MathLang. Referencing is already implemented but is not yet part of the definition of MathLang’s abstract syntax. We have annotated the original text with the line numbers of our translation in parentheses.
References to previous steps of the reasoning are commonly used in math- ematics. A sentence like “By definition of ...” could be encoded in Math- Lang by adding in the line context a reference to the definition of a constant.
In addition to such referencing, mathematicians use the habit of group- ing several steps of reasoning together. For example, to show that x' +1 = (x')', E. Landau first states that x' +1 = (x + 1)' and then states that (x + 1)' = (x')' and writes these steps in one equation. In MathLang we have represented A = B = C as three explicit steps of reasoning. Each step corresponds to one line. The first one states that A = B. The second states that B = C. Then the third concludes that A = C by ref- erencing the two previous lines. References make this kind of reasoning



6y:N∃z:Nz = x + y
x′ + y = (x + y)′
Dx′ +1 = (x + 1)′	(70)
(Def +	) D(x + 1)′ = x′′	(71)
(70), (71) Dx′ +1 = x′′	(72)
Dx′ + y′ = (x + y′)′	(73)

(Def +	) D(x + y′)′
= (x + y)′′
(74)

′′	′	′

D(x + y) = (x + y)
(75)

(73), (74), (75) Dx′ + y′ = (x′ + y)′(76)
(72), (76) Dx′ : M	(77)
Fig. 3. References example
constructions easier to encode.

The derivation rules of MathLang
The derivation rules of MathLang assign (unique) types to well formed Math- Lang expression. The set of types is a subset of the grammatical categories. We list here all the types which are atomic: T, S, N, A, P, D, Γ, K, B. In the example given in Figure 1, the type analysis assigns types corresponding to the grammatical categories while the sentence is well formed. The same sentence slightly modified will this time be badly formed. Figure 4 points out the type error.
Let	M	be the set of ...,	y	a natural number,... if	x	belongs to	M
S		T		N	T		S Z		Z			P
Γ
then	x	+	y

Fig. 4. An invalid mathematical line and its assigned MathLang types
The type analysis will raise an error while applying the line-in-book (or
line-in-block) rule. The context is valid but the expression given as the body

of line (x + y) should either be a statement (P) or a definition (D) while here x + y is a term (T). See later on in this Section for a description of the derivation rules.

Typing notations.
Before giving the derivation rules of MathLang we need to make precise the notations we use. A typing states that a type is assigned to an expres- sion in a certain environment. This is written as follow: environment ▶ expression • type. The environment consists of a book in which the expression is typed. For expressions at the sentence and phrase level, the environment also contains a context.

Flattening flags.
The flag construction we have introduced in the previous section has an important role in the encoding of mathematical texts. To make our typing rules more readable these are only applicable to MathLang without flags (con- text elements are restricted to assumptions from P and declarations from Z). We are able by flattening each flag of a MathLang text to keep the typing information they contained. Each flagstaff element is then replaced by the content of the corresponding flag’s head. With this flattening operation we lose the information that the same assumption holds on several lines or that a variable stands for the same object on several lines as well, but this does not change the typing of a book. The derivation rules are defined on MathLang texts obtained after doing a flags flattening operation.

Functions.
We use in the set of derivation rules some specific functions. We only describe these functions here rather than giving their full formal definitions.
dvars returns the set of variables declared in a given context (dvars :Γ → ℘(V )).
dconsB returns the set of defined constant in a given book. This excludes local constants (dconsB : B → ℘(C)).
dconsK returns the set of defined constant in a given block. This excludes constants defined locally in inner blocks (dconsK : K → ℘(C)).
inC(i, c, b) gives the type of the ith argument of constant c as defined in the book b.
inB(i, b, b) represents the type expected by the binder b.

fvars returns the set of free variables of a given expression (fvars : E → ℘(V )).
casedconsB (resp. casedconsK) returns the set of constants defined by cases in a given book (resp. block), excluding local definitions (casedconsB : B →
℘(C) and casedconsK : K → ℘(C)).
OK(b ; γ) is an abbreviation for ▶ b • B and b ▶ γ • Γ.
Rules for expressions.
These rules assign a type to the expressions taken from the phrase and the sentence levels. That is to say variable instances, constant calls, binding expressions and adjective attributions. A special rule rec-cons allows calls to annotated constant which is currently being defined (c' with its input types wti). This rule allows recursive definitions of constants (see rules full-def and case-def-first).
OK(b ; γ)	v ∈ V T/S/P	v ∈ dvars(γ)

b ; γ ▶ v • T/S/P
OK(b ; γ)	c ∈ CT/S/N/A/P
var

c ∈ dconsB(b)	6i ∈ {1,... , n}, b ; γ ▶ e • in
(i, c, b)

i •	C
•
b ; γ ▶ c(e1,... , en)	T/S/N/A/P
cons

OK(b ; γ)	c ∈ CT/S/N/A/P
'	RECc'

c = c
6i ∈ {1,... , n}, b
wt1 ,...,wt n ; γ ▶ e
wt

RECc'
i •	i rec-cons

•
b wt1 ,...,wtn ; γ ▶ c(e1,... , en)	T/S/N/A/P


OK(b ; γ)	b ∈ BT/S/N/A/P	b ; γ, z ▶ e • in
(b)

b ; γ ▶ bz(e) • T/S/N/A/P
B
bind

b ; γ ▶ e1 • A	b ; γ ▶ e2 • N

•
b ; γ ▶ e1e2 • N

attr

Grouping rules. In the above rules, we use the symbol / to group similar rules. For example the var rule is in place of three rules, the first of which is:
OK(b ; γ)	v ∈ V T	v ∈ dvars(γ)

b ; γ ▶ v • T
var-term

Typically, the rule var assigns the type corresponding to the variable’s gram- matical category. The constant rules cons and rec-cons will do the same after

checking the coherence of the arguments’ typings with what the constant ex- pects (the function inC gives the list of types of the constant’s parameters). The bind rule, in addition, introduces the new variable in the typing environ- ment of the inner expression. The rule attr describes how to construct a new noun by attributing an adjective to an existing noun.


Rules for contexts.
These rules check the coherence of contexts. The first one states that an empty context is a valid context. The last one checks if an assumption in the context is a well formed statement expression. The three remaining rules correspond to the three constructions of variable introduction. The grammat- ical category of the introduced variable must fit the kind of construction used: either a set or a statement or a term.


▶ b • B b ▶ ∅Γ • Γ
empty-cont

OK(b ; γ)		v ∈ V S	v /∈ dvars(γ) b ▶ γ, v : SET • Γ
OK(b ; γ)		v ∈ V P	v /∈ dvars(γ) b ▶ γ, v : STAT • Γ

set-var-decl


stat-var-decl



OK(b ; γ)	v ∈ V T	v /∈ dvars(γ)	b ; γ ▶ e • S/N



term-var-decl

b ▶ γ, v : e • Γ


OK(b ; γ)	b ; γ ▶ p • P



assump

b ▶ γ, p • Γ


Rules for definitions.
There are two kinds of definitions in the abstract syntax with three typing rules. First, we have a rule for the basic constant definition which provides a unique expression as a value for the constant. Then there are two other rules for the definitions by cases: one for the first (basic) case, the other for the following cases and checks if the types of the constant’s arguments correspond to those of the first case.



OK(b ; γ)
c ∈ CT/S/N/A/P	c /∈ dconsB(b)	dvars(γ)= ∪n  v

wt i
RECc	•

6i ∈ {1,... , n}, vi ∈ V
b wt 1,...,wtn ; γ ▶ e • T/S/N/A/P
full-def

b ; γ ▶ c(v1,...,v ) := e • D

n

OK(b ; γ)		c ∈ CT/S/N/A/P c /∈ casedconsB(b)	dvars(γ)= ∪n
•




fvars(ei)

6i ∈ {1,... , n}, b ; γ ▶ e • wt

RECc
i •	i
•

b wt 1,...,wtn ; γ ▶ e • T/S/N/A/P
case-def-first

•
b ; γ ▶ c(e1,... , en) := e D


OK(b ; γ)		c ∈ CT/S/N/A/P c ∈ casedconsB(b)	dvars(γ)= ∪n

fvars(ei)

6i ∈ {1,..., n}, b ; γ ▶ e • in
(i, c, b)

i •	C
b ; γ ▶ e • T/S/N/A/P

case-def-alter

b ; γ ▶ c(e1,... , en) := e • D
In rules full-def and case-def-first, to allow recursive definitions, we are
RECc
annotating the environment (notation b wt1 ,...,wt n ) in which we will type the
body of the definition (expression e). This annotation contains the constant currently defined and the types of its parameters. This information will be kept in the environment to allow calls to this constant (see rule rec-cons).

Rules for blocks.
A block could either be empty, end with a line or end with a block. The rules below describe how to build a block from an already well-formed one. This is done by adding a line or a sub-block to the existing block.
▶ b • B



b ▶ ∅K • K
empty-block



b ▶ k • K	b ◦ {k} ; γ ▶ p/d • P/D



line-in-block

b ▶ k ◦ γ D p/d • K


▶ b • B
b ▶ k • K	{c1,... ,c } ⊆ dconsK(k')	b ◦ {k}

▶ k' • K

n
b ▶ k ◦ {k'}

•
c1,...,cn •
∅	•	block-in-block

Rules for books.
The rules for books are similar to the rules for blocks while a book could be seen as the outermost block.

▶ b • B	b ; γ ▶ p/d • P/D



▶ ∅B • B
empty-book
•	•
▶ b ◦ γ D p/d • B
line-in-book

▶ b • B	{c1,... , cn} ⊆ dconsK(k)	b ▶ k • K

•
▶ b ◦ {k}

•
c1,...,cn •
•
block-in-book

Implementation
A main improvement of MathLang over MV and WTT is the implementation we have made of a language checker which was fully guided by the translation of the first chapter.

Concrete syntax
Our choice for the concrete syntax was to use XML recommendations. We intend this XML syntax to be used only by the MathLang framework and by software developers. The MathLang user, instead of using a concrete syntax, will use a specific user-friendly editor (see Section 5). This choice has been made to fit in our main requirement for a mathematical software which is to be easy to use by mathematicians. By choosing a computer oriented syntax we avoid the need of the user to learn a new specific syntax. This is avoided by including MathLang in a common scientific text editor.
In MathLang’s concrete syntax, each occurrence of an identifier is com- posed by its name and the grammatical category of which it is part. The concrete syntax is then mainly verbose. This facilitates the checking and al- lows local analysis of the typing. This duplication of information also eases the design of software rendering and enforces the use of an editor rather than allowing editing by hand.

The type checker
We have implemented a type checker that analyses a MathLang text by applying the rules of the type system (see Section 3). This software has been programmed using Camlp4 (parser part) and OCaml (type inference part). This program checks the typing of a given MathLang document. If the typing succeeds, the XML document is then considered as a well formed MathLang

book. Otherwise, if the document is not correctly formed, the checker will point the syntax or type error that has been found. We have used our checker during the translation of Landau’s first chapter.

Rendering
We apply syntactic transformations on MathLang texts in order to obtain presentable versions of the XML concrete syntax. For this paper we have used one XSL transformation that produces a LATEX document. We have automat- ically generated the examples of Section 2.2 and the full translation of the first chapter of [9] using this transformation. This rendering is experimental.
It remains close to MV and WTT while also being clearer thanks to the flags and blocks, and also to some syntactic sugaring (the grammatical category of each identifier is not printed and we use common symbols to help the reader). We explain our goals for MathLang rendering in Section 5.

Translation
In order to experiment with our language MathLang we have used in its development, a translation of E. Landau’s Foundations of Analysis[9]. Trans- lating an existing mathematical text and checking the resulting MathLang text with our software show the feasibility of such a mathematical encoding. This experience demonstrates the usability of our language and guides our research and development as closely as possible to effective mathematicians’ writing habits. We have achieved so far the translation of the full first chap- ter. This translation and the original text can be found in an appendix to this article reachable at the authors’ web pages.

Related and Future work
M. Scheffer’s master thesis [12] gives a translation of the same first chapter of [9] but in the original calculus WTT with sugared notation called WTTS. The meta theory developed for WTT did not involve the syntactic sugar- ing and we suspect that R. Ko¨rvers’ implementation of WTT (upon which M. Scheffer’s encoding was based) did not involve the syntactic sugaring ei- ther. This means that:
There is a gap between the language used in M. Scheffer’s encoding and the theory and its implementation. Our encoding on the other hand takes place in a framework where there is a harmony between the language, its metatheory and its implementation. We give the translation in MathLang, an extended version of WTT where much of the sugaring of WTT is replaced

by first class status in MathLang. Furthermore, the implementation is that of MathLang and hence we can guarantee the coherence of our encoded texts. This would be hard to guarantee in M. Scheffer’s case since the implementation is of WTT whereas the encoding is in another language WTTS.
The rendering we automatically obtain from the encoding is closer to the mathematicians’ text than that of Scheffer’s. This is since both the language MathLang and its implementation contain flags and blocks.
Moreover, references to lines, definitions and blocks make our encoding closer to the mathematician’s intentions.
As we said earlier, MathLang is still under development. We believe that it is important that this development be guided by existing mathematical texts and practice and that the encoding should be in the language under development and not in syntactic sugaring versions of it. It is also important that the metatheory and implementation be as faithful as possible to the language itself.
M. Scheffer also discusses the step of moving from WTT into a more formal language. Although this step is an important future direction, we believe that first, a more stable language of mathematics needs to be found and extensively tested before moving into higher levels of formalisation. Already, we have developed many type theories with many of the features of Automath (e.g., explicit substitutions, parameters, definitions, local and/or global reductions, notions of unification). These type theories will guide us into the more formal levels of MathLang. But, to avoid the danger of creating “toy” levels of formalisation, we need to have a good basis for the mathematical language under development which can then lead us into more trustworthy formal levels.
There exist different frameworks for putting mathematics on the com- puter, each with a particular aim: calculation, analysis, storage, visualization, checking, etc. However, none of these frameworks is expressive enough to allow the integration of many aims in one system. In [7], we proposed to design a language influenced by MV [11] and WTT [5] and driven by the en- coding of three books: 1) the Landau’s Foundations of Analysis [9] since it was fully-formalised in Automath (and hence provides an excellent basis for comparison), 2) the Elements of Euclid [4] since it is known to have many er- rors (and hence helps distinguish between logical and structural correctness), and 3) The Compendium of Lattices [3] since 60% of it has been formalised in Mizar. We have not yet tackled the third book. On the other hand, work on Euclid’s book is under development by a student for his degree project while work on Landau’s book has been in progress for over a year now [10], and we

have already completed the translation of the first chapter while building at the same time, a basis of a refined language MathLang, its implementation and useful associated software packages. The immediate future work on MathLang and its framework will follow three directions strongly linked together.
Specifications. The MathLang language is still in development. We need to incorporate references in the MathLang syntax and to put the notion of blocks into action by adding some constructions to enable us to derive information about blocks. These extensions will always be made in parallel with the guiding translation work. At every stage, we will make sure that the metatheory is well developed and that the implementation is faithful to the language.
Translation. Continuing the translation of Landau’s book (and making progress on the translation of Euclid’s book) is a main target to guide the design of MathLang. This translation guides us as to how we should further develop MathLang and enables us to build an implementation that is easy to use which we can then pass for external feedbacks from mathematicians or programmers as our future users.
Framework. Because our language will be as exhaustive as possible in its way to encode mathematical texts we will need to have a specific ed- itor to assist the mathematician. This editor should have a user friendly interface. It should be able to print mathematical symbols on the screen. An integrated checker should give instantaneous feedback about the type analysis of the text. We have planned and started to use the What-You-
See-Is-What-You-Get editor TEXmacs 2 for this development. TEXmacs is an editor dedicated to mathematical texts. It is mostly interactive and has been developed to allow extensions. MathLang’s framework should assist mathematicians to create new documents and to translate existing math-
ematical texts (such as LATEX and OMDoc documents). For this second purpose we aim to develop a tool to semi-automate the work of translation. The work described in the article [2] is a good basis for this development.
Y. Baba and M. Suzuki present a grammatical analyser which extends its own grammatical rules on the fly. After translating one sentence, the gram- matical analyser will be able to recognize the same kind of pattern used by the mathematician in the rest of the text.
In addition to this discussed development of a language of mathematics MathLang, we will also use earlier developments we made on extensions of type systems (with notions like definitions, explicit substitutions, parameters and higher order unification) in order to take our full encoding of Landau’s

2 http://www.texmacs.org/


book in MathLang into a fully formalised version which can then be compared with the existing Automath formalisation. At each stage, we will be working on general methods that can be applied to other books.

References
Asperti, Buchberger and Davenport (Eds.). The Second International Conference on Mathematical Knowledge Management, MKM 2003, Bertinoro, Italy, February 16-18. Lecture Notes in Computer Science 2594, 2003.
Yusuke Baba and Masakazu Suzuki. An annotated corpus and a grammar model of theorem description. In [1], 2003.
G. Gierz, K. H. Hofmann, K. Keimel, J. D. Lawson, M. Mislove, and D. S. Scott. A Compendium of Continuous Lattices. Springer-Verlag, 1980.
Heath. The 13 Books of Euclid’s Elements. Dover, 1956.
Fairouz Kamareddine and Rob Nederpelt. A refinement of de Bruijn’s formal language of mathematics. To appear in Journal of Logic, Language and Information. 2004.
Michael Kohlhase. OMDoc: An Open Markup Format for Mathematical Documents (Version 1.1). http://www.mathweb.org/omdoc, 2003.
Fairouz Kamareddine and Joe Wells. Promath: presenting, proving and programming mathematical books. Revised under the title: MathLang, A new language for Mathematics, Logic and Computation, August 2001.
Edmund Landau. Grundlagen der Analysis. Chelsea, 1930.
Edmund Landau. Foundations of Analysis. Chelsea, 1951. Translation of [8] by F. Steinhardt.
Manuel Maarek. First year PhD report. Technical report, Heriot-Watt University, August 2003.
	R.P. Nederpelt and J.H. Geuvers and R.C. de Vrijer (Eds.), Selected papers on Automath, North-Holland, 1994.
Mark Scheffer. Formalizing Mathematics using Weak Type Theory. Master’s thesis, Technische Universiteit Eindhoven, September 2003.
L. S. van Benthem Jutting. Checking Landau’s “Grundlagen” in the AUTOMATH system. PhD thesis, Eindhoven University of Technology, 1977. Mathematical Centre Tracts nr. 83, Math. Centre, Amsterdam 1979.
Freek Wiedijk. Comparing mathematical provers. In [1], 2003.
