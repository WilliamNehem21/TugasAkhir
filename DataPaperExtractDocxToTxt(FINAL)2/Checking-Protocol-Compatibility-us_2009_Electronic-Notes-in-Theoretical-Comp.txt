

Electronic Notes in Theoretical Computer Science 255 (2009) 65–81
www.elsevier.com/locate/entcs

Checking Protocol Compatibility using Maude
Francisco Dura´n1	Meriem Ouederni2	Gwen Salau¨n3
Dept. of Computer Science University of Ma´laga
Ma´laga, Spain

Abstract
Checking compatibility of services accessed through their behavioural interfaces is a crucial issue in Service Oriented Computing which aims at building new systems from existing software services. In this paper, we consider a model of services which takes value passing and non-observable actions into account. We propose an approach to check in a unified way several compatibility notions between two service protocols using the rewriting logic system Maude. In particular, we illustrate our approach with three widely used compatibility notions, namely opposite behaviours, unspecified receptions and deadlock freeness. These notions as well as several strategies to handle non-observable actions have been formalised and fully implemented into a prototype tool which is able to automatically detect whether two services are compatible, and return a counterexample if they are not.
Keywords: Symbolic Transition Systems, non-observable actions, compatibility, Maude.


Introduction
The main principle of Component Based Software Engineering (CBSE) and Service- Oriented Computing (SOC) is the reuse of existing software components or Web services 4 when building new systems in order to save time and efforts. In this context, interoperability issues must be avoided and reused services have to fit with other services in the system being developed. Therefore, compatibility checking is a crucial concern to ensure whether services can interoperate successfully. However, verifying compatibility is especially difficult when the model of services takes inter- action protocols into account which is essential [20] to avoid erroneous behaviours or deadlock situations when executing together a set of services.

1 Email: duran@lcc.uma.es
2 Email: meriem@lcc.uma.es
3 Email:salaun@lcc.uma.es
4 In the remainder of this paper, we will refer to both software component and Web service using the generic term service.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.025

Numerous compatibility notions have already been proposed based upon several description models of service interfaces, see for instance [23,9,20,2] for automata,
[4,10] for π-calculus, [14,16,17] for Petri nets and [1,5] for state machines. Most of these approaches focus on a unique compatibility notion defined with respect
to a specific application area, see for instance [17] for service composition, [1,5,14] for service substitution, [10] for service choreography, etc. Compared to existing works, new contributions of our proposal are the following: (i) our model takes into
account value-passing as well as non-observable or internal actions (τ actions), and considers different strategies to handle them; (ii) we propose a framework where
several notions of compatibility can be checked automatically, and this framework can be extended with new compatibility notions and new strategies to handle in- ternal actions. Note that internal actions in interface models are very important because some services can be compatible from an observable point of view, but their execution will behave erroneously due to uncontrolled internal behaviours.
Our model of service interfaces allows to specify interaction protocols (messages and their application order). Value-passing and internal actions are also consid- ered. Our framework provides a uniform and systematic way of checking different notions of compatibility, considering different strategies to deal with internal ac- tions. Here, we focus on three widely used compatibility notions, namely opposite behaviours [21], unspecified receptions [3,23], and deadlock freeness [2]. But other
sidered in the future. Moreover, we consider three different τ handling strategies, notions are already available in our framework and additional ones could be con- namely the strong, weak, and trace strategies introduced by Robin Milner in the
context of equivalence checking in the 80s [21], and similarly, additional ones could be added to the framework as well. Note that it is important considering different strategies, since each of them makes sense depending on the objective of the com- patibility check. Thus, for example, a trace strategy is well suited if one wants to compare external behaviours, whereas a weak strategy allows to detect some subtle errors when composing services. A strong strategy is required when two services must exactly match from an internal and external point of view as it is the case while substituting one service for another.
Our solution for checking protocol compatibility is independent of any specific application, and therefore can be useful for several issues, such as automatic service composition, software adaptation, service substitution, service discovery, code re- engineering, etc. Our proposal has been implemented in the rewriting logic system Maude [7]. Its powerful rewriting engine and searching capabilities open a very wide range of possibilities. Moreover, its expressivity has allowed us to implement the different notions and strategies at a very high level of abstraction, without compro- mising efficiency, and allowing such a flexible and extensible general framework.
The remainder of this paper is structured as follows. Section 2 formalises our model of services. Section 3 introduces some preliminaries and the notions of com- patibility we use in this paper for illustration purposes. In Section 4, we present how service compatibility is checked using Maude. Section 5 presents a comparison with related approaches. Finally, Section 6 draws up some conclusions.

τ	'

(s −−→ s ) ∈ T


⟨s, E ⟩ τ	⟨s', E ⟩
(TAU)

a!v	'	'	a?x	'

(s −−−→ s ) ∈ T v = ev (v , E )	(s −−−→ s ) ∈ T
(EM)
(REC)


a!v '	'

a?x	'

⟨s, E ⟩ −−−−→b ⟨s , E ⟩	⟨s, E ⟩ −−−→b ⟨s , E ⟩
Fig. 1. Operational Semantics of one STS
Model of Services
We assume that service interfaces are equipped both with a signature (set of required and provided operations) and a protocol represented by a Symbolic Transition Sys- tem (STS). Communication between services is represented using events relative to the emission and reception of messages corresponding to operation calls. Events may come with a list of parameters whose types respect the operation signatures.
In our model, a label is either the internal action τ or a tuple (m, d , (p1,... , pn ))
emission ! or a reception ?), and (p1,... , pn ) is either a list of data terms if the label where m is the message name, d stands for the communication direction (either an corresponds to an emission, or a list of variables if the label is a reception.

(A, S , I , F , T ) where: A is an alphabet which corresponds to the set of labels asso- Definition 2.1 [STS] A Symbolic Transition System or STS is a tuple ciated to transitions, S is a set of states, I ∈ S is the initial state, F ⊆ S are the
final states, and T : S × A × S is the transition function.

In the remainder of this paper, we describe a transition using a tuple (s, l , s') such that s and s' denote the source and target states, respectively, and l stands for the
label.
in [15]. Here, guards are abstracted as τ transitions, which denote internal (non- Our STS is a reduced version of STG (Symbolic Transition Graph) introduced observable) activity to the service. The operational semantics of one STS (−→b) is
defined with three rules (TAU, EM, REC, Figure 1).
The operational semantics of n (n > 1) STSs (−→c) is formalised using a syn- chronous communication rule (COM, Figure 2) in which value-passing and variable
rule (INEτ , Figure 2). {as1,... , asn } is a set of couples ⟨si , Ei ⟩, where each couple substitutions rely on a late binding semantics [19], and an independent evolution
⟨s, E ⟩ is composed by an active state s ∈ S and a data environment E . A data
environment is a set of couples ⟨x , v ⟩ where x is a variable and v a ground value. We use a function type which returns the type of a variable or a value, and we define
the environment update “ ”, and the evaluation function ev as follows:

E  ⟨x , v ⟩  E (x )= v ev (E , x )  E (x )
ev (E , f (v1,... , vn ))  f (ev (E , v1),... , ev (E , vn))
The STS formal model has been chosen because it is simple, graphical, and it
can be easily derived from existing implementation platforms’ languages (see for instance [12,22,11] where such abstractions for Web services were used for verifi-



a!v
i , j ∈ {1..n}  i /= j
'


a?x	'

⟨si , Ei ⟩ −−−→b ⟨si , Ei ⟩ ⟨sj , Ej ⟩ −−−→b ⟨sj , Ej ⟩
type(x )= type(v ) E ' = Ej  ⟨x , v ⟩

(COM)

a!v
'	'	'

{as1, .., ⟨si , Ei ⟩, .., ⟨sj , Ej ⟩, .., asn } −−−→c {as1, .., ⟨si , Ei ⟩, .., ⟨sj , Ej ⟩, .., asn }

i ∈ {1..n}	'

	⟨si , Ei ⟩ −−→b ⟨si , Ei ⟩	
(INE )

τ	'	τ
{as1, .., ⟨si , Ei ⟩, .., asn } −−→c {as1, .., ⟨si , Ei ⟩, .., asn }
Fig. 2. Operational Semantics of n STSs

Fig. 3. User and Server Behavioural Interfaces

cation, composition or adaptation purposes). For space reasons, in the rest of the paper, we will describe service interfaces only with their STSs. Signatures will be left implicit, yet they can be inferred from the typing of arguments (made explicit here) in STS labels.

Example. We use as running example a travel advice system which gives infor- mation for travelers. As it can be observed in Figure 3, the user interface can first log on to a server by sending its user name and password (login!). Then, it can request (searchFlight!) and receive (searchFlight?) a flight identifier and price ac- cording to the wished destination and departure and return dates. Depending on
its preferences (internal choice specified with τ transitions in the user protocol), the
user can either start a new flight request, ask for a hotel advice (searchHotel!), and
then it receives the answer (searchHotel?), or ask for a car advice (searchCar!), get the answer (searchCar?), and then start a hotel advice request. The server service starts by receiving a user name and password (login?). Next, this service can receive and reply several flight requests until a request for a car and/or a hotel advice is received and replied.

Service Protocol Compatibility

patibility that we will present in Section 3.4. Since our model considers τ actions, We start with some definitions useful for the formalisation of service protocol com- actions are handled. In this paper, we consider three widely used τ handling strate- the definition of different compatibility notions depends on how these non-observable gies, namely strong, weak and trace [21], and the compatibility notions can be
checked with respect to each of these strategies. Moreover, we formalise the differ- ent notions of protocol compatibility using the concepts of set of global reachable states and transition compatibility.
Preliminaries
(Ai , Si , Ii , Fi , Ti ), i ∈ {1, 2}. We define a function outT (s) which returns the set In this paper, we focus on the case of two services described using STSs STSi = of transitions going out from the state s in the transition set T . Last, functions
reachableT (s) and reachableT,l (s) return the set of states which can be reached from the given state s, and the set of states which can be reached from the given state s using transitions labeled with l in the transition set T , respectively:
outT (s)= {(s', l , s'') | (s', l , s'') ∈ T , s = s'}
reachableT (s)= {s1, .., sm } ∪ reachableT (s1) ∪ ... ∪ reachableT (sm ) where {s1, .., sm } = {s'' | (s', l , s'') ∈ T , s = s'}
reachableT,l (s)= {s1, .., sm } ∪ reachableT,l (s1) ∪ ... ∪ reachableT,l (sm ) where {s1, .., sm } = {s'' | (s', l ', s'') ∈ T , s = s', l = l '}
Comparison of labels is useful to check whether exchanged messages are com- patible or not. Formally, we define label compatibility as follows:
Definition 3.1 [Label compatibility] A label l1 is compatible with a label l2 if:

l1 = (m1, d1, (p11,... , p1n )), l2 = (m2, d2, (p21,... , p2m )) such that m1 = m2, d1 = d2, n = m, and ∀ k = 1, .., n	type(p1k )= type(p2k ) or,
l1 = τ and l2 = τ .
where ! =?, ? =!.
Successor States

Given two STSs STSi = (Ai , Si , Ii , Fi , Ti ), i ∈ {1, 2}, we define a global state as a pair of states (s1, s2) where si is a current state of STSi . Then, the protocol compat- functions successorsTS ((s1, s2)) and reachableTS ((s1, s2)) which respectively provide ibility will be checked for all global reachable states. Therefore, we use the auxiliary
(s1, s2), and the set of all global reachable states for two STSs, where TS stands for the set of global states that can be reached, in one step, from a current global state the considered τ handling strategy, namely strong, weak or trace, etc. Note that both successorsTS ((s1, s2)) and reachableTS ((s1, s2)) sets are obtained by application of the COM and INEτ rules given in Figure 2.

dealing with τ actions. In the following, we present the successor states function In our approach, the successor states function depends on the different ways of for the strong, weak and trace strategies.
We start by defining the strong successor states, in which every label held by a
by a transition going out from a state of the other service, even for τ actions. transition going out from a state of one service must be matched with a label hold
Definition 3.2 [Strong Successor States] The set of global states which are strongly
reachable, in one step, from a current global state (s1, s2) is defined as follows:
successorsstrong ((s1, s2)) = {(s' , s' ) | (s1, l1, s' ) ∈ T1, (s2, l2, s' ) ∈ T2 such that l1
1  2	1	2
and l2 are compatible}

We define now the weak successor states. As far as τ actions are concerned, we require that each τ action is matched by zero or more τ actions.
Definition 3.3 [Weak Successor States] The set of global states which are weakly
reachable, in one step, from a current global state state (s1, s2) is defined as follows:
successorsweak ((s1, s2)) = {(s' , s' ) | (s1, l1, s' ) ∈ T1, (s2, l2, s' ) ∈ T2, l1 /= τ such
1  2	1	2
that l1 and l2 are compatible}
∪ {(s' , s2) | s' ∈ reachableT ,τ (s1), and reachableT ,τ (s' )= 
1	1	1	1	1
∅ or ∃(s' , l1, s'') ∈ T1 such that l1 /= τ}
1	1
∪ {(s1, s' ) | s' ∈ reachableT ,τ (s2), and reachableT ,τ (s' )= 
2	2	2	2	2
∅ or ∃(s' , l2, s'') ∈ T2 such that l2 /= τ}
2	2

A weaker definition of successor states consists in determining the set of global states that can be reached from the current one, in one step, by execution of the
same traces. By doing so, τ actions are just not considered in the service protocols.
Definition 3.4 [Trace Successor States] The set of global states which are trace
reachable, in one step, from a current global state (s1, s2) is defined as follows:
successorstrace ((s1, s2)) = {(s' , s' ) | (s1, l1, s' ) ∈ T1, (s2, l2, s' ) ∈ T2, l1 /= τ and such
1  2	1	2
that l1 and l2 are compatible}


∪	 
(s1,τ,s'')∈T1
∪	 
(s2,τ,s'')∈T2
successorstrace ((s'', s2))
successorstrace ((s1, s''))

Example. We focus on small parts of our running example to illustrate how the successor states can be obtained for the strong, weak and trace strategies. Let us
consider the global state (u1, s1):
successorsstrong ((u1, s1)) = successorsweak ((u1, s1))
= successorstrace ((u1, s1))

= {(u2, s2)}
Since there is no τ action hold by a transition going out from u1 and s1, we obtain the same set of global states reachable, in one step, from (u1, s1) according to any τ strategy.
Now, let us consider the global state (u4, s4):
successorsstrong ((u4, s4)) = ∅
successorsweak ((u4, s4)) = {(u2, s4), (u5, s4), (u7, s4)}
successorstrace ((u4, s4)) = {(u3, s3), (u6, s5), (u8, s9)}
As it can be observed in Figure 3, all the transitions going out from u4 hold τ actions, namely {((u4, τ, u2)), (u4, τ, u5), (u4, τ, u7)}, while all actions hold by the transitions outgoing from s4 are different to τ , namely {(s4, searchFlight ? dis : string , dep : tdate, ret : tdate, s3), (s4, searchHotel ? dep : tdate, ret : tdate, cat : string , s9), (s4, searchCar ? d 1 : date, d 2 : date, type : string , s5)}. By application of the strong successor states definition, the τ actions at u4 do not match with u4. Hence, there is no global state that can be strongly reachable from (u4, s4). any action at s4, and none of the expected receptions at s4 can be emitted at Considering the definition of weak successor states, the τ actions at state u4 are skipped because all the transitions going out from this state are labeled with τ . Therefore, the set of global states weakly reachable, in one step, from (u4, s4) is
{(u2, s4), (u5, s4), (u7, s4)} since reachableTuser ,τ (u2) = ∅, reachableTuser ,τ (u5) = ∅
as it is shown in Figure 3, the set of global states {(u3, s3), (u6, s5), (u8, s9)} can be and reachableTuser ,τ (u7)= ∅. Finally, following the trace successor states definition, reached, in one step, from (u4, s4) using traces of compatible labels.

from an initial global state (s1, s2), we present the following definition: In order to obtain the set of all global reachable states for two STSs starting


reachableTS ((s1, s2)) = {(s1, s2)}∪	 
reachableTS ((s' , s' ))

1  2
(s' ,s' )∈successorsTS ((s1,s2))
1 2
Transition Compatibility

As successor states, compatibility of transitions going out from a global state (s1, s2) depends on how τ actions are handled. Transition compatibility consists in checking if the sent (respectively, received) messages at a state s1 could be received (respec-
tively, sent) at another state s2 and vice versa. To do so, we took inspiration from the equivalence notions stated by Milner [21] to present the following definitions:
Definition 3.5 [Strong Transition Compatibility] Given a global state (s1, s2),
comp-em-recstrong ((s1, s2)) = true iff ∀(si , li , s') ∈ Ti , with i ∈ {1, 2}, ∃(sj , lj , s' ) ∈
i	j
Tj , with j = i mod 2 + 1, such that li and lj are compatible.
Definition 3.6 [Weak Transition Compatibility] Given a global state (s1, s2),
comp-em-recweak ((s1, s2)) = true iff:

∀(si , li , s') ∈ Ti with i ∈ {1, 2}, li /= τ, ∃(sj , lj , s' ) ∈ Tj , with j = i mod 2 + 1
i	j
such that li and lj are compatible, and
∀(si , τ, s'') ∈ Ti , with i ∈ {1, 2},  comp-em-recweak ((s'', sj )) = true, and
i	i
∀(sj , τ, s'') ∈ Tj , with j = i mod 2 + 1, comp-em-recweak ((si , s'')) = true.
j	j
Definition 3.7 [Trace Transition Compatibility] Given a global state (s1, s2),
comp-em-rectrace ((s1, s2)) = true iff:
∀(si , li , s') ∈ Ti , with i ∈ {1, 2}, li /= τ, ∃(sj , lj , s' ) ∈ Tj , with j = i mod 2 + 1
i	j
such that li and lj are compatible, and
∀(si , τ, s'') ∈ Ti , with i ∈ {1, 2}, ∃(s, l , s') ∈ Ti , l /= τ , such that s ∈
reachableT ,τ (si ) then ∃(s', s' ) ∈ successorstrace ((s1, s2)) where s' = s'.
i	i	j	i
state (u4, s4), com-em-recTS ((u4, s4)) returns false if TS is strong or weak , and Example. Figure 4 shows a part of our running example. Considering the global true if TS is trace.  Since there are transition labels at u4 (respectively at s4)
recstrong ((u4, s4)) = false. By application of the weak transition compatibility notion, which do not match with transition labels at s4 (respectively at u4), com-em- com-em-recweak ((u4, s4)) = true iff:
com-em-recweak ((u2, s4)) = true and com-em-recweak ((u5, s4)) = true and com-em- recweak ((u7, s4)) = true.
Let us focus on (u2, s4). The transition label (searchCar ? d 1: date, d 2: date, type :
recweak ((u2, s4)) = false.  Therefore,  com-em-recweak ((u4, s4)) = false. string ) at s4 does not match with any transition label at u2, and thus com-em-
Last, by skipping the transitions holding τ actions at u4, we always have traces of
compatible labels starting from (u4, s4). Hence, com-em-rectrace ((u4, s4)) = true.
Formalising Some Service Compatibility Notions
Various notions of service compatibility exist [4,17,14,1,5] setting different require- ments on how services are compatible. There is no standard or unique service compatibility notion, all of them are useful for different application domains. For illustration purposes, we focus here on three widely used notions, namely opposite behaviours, unspecified receptions and deadlock freeness.

Opposite behaviours. The strongest and most intuitive compatibility notion is that of opposite behaviours. In this paper, our definition of opposite behaviours compatibility is inspired from the bisimilarity concept originally stated by Mil- ner [21]. Here, the opposite behaviours compatibility consists in the fact that when one service can send a message, then the other service must be willing to receive that message, and when one service is waiting to receive a message, then the other
service must be sending that message. Hence, for any τ handling strategy TS , we
formalise the opposite behaviours compatibility notion as follows:
Two STSs STSi = (Ai , Si , Ii , Fi , Ti ), i = {1, 2}, are opposite behaviours compatible if and only if for each global state (s1, s2) ∈ reachableTS ((I1, I2)):



Fig. 4. Strong and Weak Incompatible Emissions Receptions at (u4, s4)
comp-em-recTS ((s1, s2)) = true, and
if s1 ∈ F1 (s2 ∈ F2, respectively) then s2 ∈ F2 (s1 ∈ F1, respectively).
section, com-em-recTS ((u4, s4)) = false if TS is strong or weak . Then, the user and Example. Considering our running example, as we have explained in the previous server protocols are not opposite behaviours compatible with respect to the strong
and weak strategies. However, these protocols are opposite behaviours compatible according to the trace strategy. For the user and server protocols, we can check that
for each trace global reachable state (ui , sj ) from (u1, s1) com-em-rectrace ((ui , sj )) =
true. We can easily also check the second condition given in the opposite behaviours
definition.
Unspecified receptions. One compatibility notion which is less restrictive than opposite behaviours is that of unspeciﬁed receptions. Here, our unspecified receptions definition is close to that given in [3,23] which consider that two service protocols are compatible even if one service can receive a message that cannot be sent by the other service, i.e. additional receptions, and this works in both directions. However, this definition requires that if one service can send a message at a reachable state, then that emission must be willing to be received by the other service. By doing so, it is also possible that one protocol holds an emission that will not be received by its partner as long as the state from which this emission goes out is unreachable during an established interaction.
Two STSs STSi = (Ai , Si , Ii , Fi , Ti ), i ∈ {1, 2}, are unspecified receptions compat- ible if and only if for each global state (s1, s2) ∈ reachableTS ((I1, I2)):
comp-em-recTS ((s1, s2)) = true, and if s1 ∈ F1 (s2 ∈ F2, respectively) then
s2 ∈ F2 (s1 ∈ F1, respectively), or
∃(si , li , s') ∈ Ti , with i = {1, 2}, li = (mi , ?, pl ), / ∃(sj , lj , s' ) ∈ Tj , with j =
i	j
i mod 2 + 1, such that li and lj are compatible.
Example. In our travel advice running example, the user and server protocols are unspecified receptions incompatible according to the strong strategy since at
the global state (u4, s4) there are transition labels, different to receptions, at u4
(respectively s4) which do not match with transition labels at s4 (respectively u4).



Fig. 5. Additional Receptions at (u4, s4)

and trace strategies because for all global reachable states (ui , sj ), if there is a However, both protocols are unspecified receptions compatible with respect to weak transition label l at ui (respectively sj ) which cannot be matched with a transi-
sider the global reachable state (u7, s4) in Figure 5. At state s4, there are two tion label at sj (respectively ui ) thus l is a reception. For instance, let us con- additional receptions, namely (searchCar ?d 1 : date, d 2 : date, type : string ) and (searchFlight ?dis : string , dep : tdate, ret : tdate), that do not match with the emission at u7.
Deadlock freeness. This notion is less restrictive than the two previous ones. It considers that two service protocols are compatible if and only if, starting from their initial states, they can always evolve until reaching a final global state. In order to formalise our deadlock freeness compatibility, we took inspiration from [2].
Two STSs STSi = (Ai , Si , Ii , Fi , Ti ), i = {1, 2}, are deadlock freeness compatible if and only if for each global state (s1, s2) ∈ reachableTS ((I1, I2)):
(s1, s2) ∈ (F1 × F2), or
successorsTS ((s1, s2)) /= ∅.
Example.  Going back to the travel advice system, the user and server are in-
reachable state from (u4, s4), and u4 and s4 are not final states. Nevertheless, compatible with respect to the strong strategy since there exists no global strongly these two protocols are deadlock free compatible according to the weak and trace
reachable state (ui , si ) successorsTS ((ui , si )) /= ∅ until reaching a final global state, strategies because, starting from their initial states, for each weak (or trace) global where TS is weak or trace.

Compatibility Checking
described using STSs, a compatibility notion CN and a τ handling strategy TS . We now present a protocol compatibility definition UPC for two given protocols This definition enables one to check if two service protocols, described using STSs,
are compatible with respect to CN and TS , and reports a counterexample CE if they are not.

UPC : {STS1, STS2}× CN × TS → < Boolean, CE >
Encoding into Maude and Tool Support
In this Section, we respectively present a short introduction to Maude, the Maude encoding of our compatibility checking framework, and the prototype tool that automates the compatibility verification.

Maude Overview
Maude [6,8,7] is a high-level language and a high-performance interpreter and com- piler in the OBJ [13] algebraic specification family that supports membership equa- tional logic and rewriting logic specification and programming of systems. Thus, Maude integrates an equational style of functional programming with rewriting logic computation. In this section we provide an informal description of those Maude fea- tures necessary for understanding the paper; the interested reader is referred to [8,7] for more details.
Maude’s underlying equational logic is membership equational logic [18], a Horn logic whose atomic sentences are equalities t = t ' and membership assertions of the form t : S , stating that a term t has sort S . Such a logic extends order- sorted equational logic, and supports sorts, subsort relations, subsort polymorphic overloading of operators, and the definition of partial functions with equationally defined domains.
In Maude, there are three different types of modules: functional, system and object-oriented modules. We focus here on functional modules (see [8,7] for addi- tional information). For example, the following Maude functional module defines the natural numbers (with sorts Nat of natural numbers and NzNat of nonzero natural numbers), using the Peano notation, with the zero (0) and successor (s_) operators as constructors (note the ctor attribute). Then, the addition operation (_+_) is defined, being its behaviour specified by two equational axioms. The op- erators s_ and _+_ are defined using mixﬁx syntax (underscores indicate places for arguments).
fmod MY-NAT is sort NzNat Nat .
subsort NzNat < Nat . op 0 : -> Nat [ctor] .
op s_ : Nat -> NzNat [ctor] .
op _+_ : Nat Nat -> Nat [assoc comm id: 0] . vars M N : Nat . 
eq s M + s N = s (M + N) . endfm
If an equational specification is confluent, terminating, and sort-decreasing, then it can be executed. Computation in a functional module is accomplished by using the equations as simplification rules from left to right until a canonical form is reached. Some equations, like the one expressing the commutativity of a binary operator, are not terminating, but nonetheless they are supported by means of operator attributes, so that Maude performs simplification modulo the equational theories provided by such attributes, that can be associative (assoc), commutativity
















Fig. 6. Diagram of Maude Modules
(comm), and identity (id). The above properties must therefore be understood in the more general context of simplification modulo such equational theories.
In Maude, specifications may be generic, that is, they may be defined with other specifications as parameters. The requirements that a datatype must satisfy are described by theories. Parameterized modules are instantiated by means of views. A view shows how a particular module satisfies a theory, by mapping sorts and operations in the theory to sorts and operations in the target module, in such a way that the induced axioms are provable in the target module.
Maude Encoding
In this section, we will overview the different Maude modules (see Figure 6) used to encode our approach:

STS Specification. A module called STS specifies the service model. STSs are represented as objects of the form:
< Oid : STS | is : State, fss : Set{State}, ts : Set{Transition} >.
An STS object has an identifier (Oid), a type (STS), and an attribute set which consists of an initial state (is), a set of final states (fss), and a set of transitions (ts). A transition is a tuple of the form St1 - L -> St2 where St1 and St2 are,
respectively, the source and target states, and L is the label. A label is either a τ
(T) or a tuple of the form M d (PRS), where M is the message name, d stands for
the direction being ? or !, and PRS denotes the parameter list.
Tau Strategies. Two operations successors and comp-em-rec encode the successorsTS and comp − em − recTS functions, respectively, in three Maude mod- ules called STRONG, WEAK and TRACE, respectively. For space reasons, we cannot give all the Maude specifications implementing these functions. For instance, Figure 7 shows the encoding of the successorstrace function. The successors operation ex- plores two STS objects (first and third arguments in line 1) starting from a global state (second and forth arguments in line 1) in order to return the set of global



1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29


Fig. 7. Maude Encoding of Successors Function wrt the Trace Strategy

states (Set{Pair{State,State}}) reachable, in one step, from the current one using traces of compatible labels. Regarding the label compatibility, the expres- sions St1 - M d1 (PRS1) -> St1’ and St2 - M d2 (PRS2) -> St2’ in lines 8-9 require that the two transition labels at St 1 and St 2 have the same name and oppo- site directions such that d1 = d2. Then, the compatible-parameters(PRS1, PRS2) call checks if both parameter lists PRS1 and PRS2 have identical type lists (same types in the same order).

Compatibility  Notions.   The opposite behaviours, unspecified receptions and deadlock freeness compatibility notions presented in Section 3.4 are speci- fied into three operations opposite-behaviours, unspecified-receptions and
ibility of two STSs at all reachable global states with respect to a τ strategy. For deadlock-freeness, respectively. Each of these operations evaluates the compat- instance, Figure 8 shows the specification of the opposite behaviours compatibility
notion. In the very first step, the opposite-behaviours operation (line 1) ac- cepts as arguments two STS objects and returns a tuple consisting of a Boolean value and a counterexample (Tuple{Bool, Tuple{List{Transition}}}). Then, in order to check the protocol compatibility at all global reachable states using a recursive execution, an auxiliary opposite-behaviours operation (lines 8-10) is called. As it is shown in line 13, the auxiliary opposite-behaviours operation calls
the comp-em-rec operation for each global reachable state (St 1, St 2). Depending on the returned Boolean value, it might be possible to recursively call (lines 14-
set of global states that can be reached from (St 1, St 2). In the case in which the 15) the opposite-behaviours operation for each global state in SPS , i.e., the comp-em-rec operation returns false, the auxiliary get-counterexample operation
returns a couple of transition sequences starting from the initial states until reach- ing the incompatibility source. The recursive call can stop if the current global



1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

Fig. 8. Maude Encoding of Opposite Behaviour Notion

reachable state (St 1, St 2) has previously been visited (line 17) in order to avoid an infinite execution in the case of looping protocols.
Compatibility Checking. A module COMPATIBILITY{TSNOTION} implements the compatibility definition. The parameter TSNOTION refers to a compatibility notion (opposite behaviours, unspecified receptions or deadlock freeness) encoded into a
module called NOTION{STRATEGY}, according to a τ strategy (strong, weak or trace) taken as a parameter.
Tool Support
The compatibility checking framework that we have presented in the previous sections has been fully implemented into a prototype tool (see Figure 9 for an overview). The STS Maude specifications are automatically generated using our script STS2Maude implemented in Python. In order to check the protocol compat- ibility, we call the Maude’s red(uce) command for the operation which implements
the chosen compatibility notion (e.g., opposite-behaviours), and the τ handling strategy. A Boolean value and a counterexample are returned indicating whether
two STSs are compatible according to the checked compatibility notion and identi- fying the incompatibility source, respectively.
So far, our prototype tool has been validated on more than 75 examples, which range from small examples to real-world ones. The largest example of our database consists of two services where each one consists of more than 85 states and around 90 transitions. The maximum computation time for this example was about 7 seconds, and that was needed to check the trace deadlock freeness compatibility.

Related Work
During the last 25 years, compatibility has been intensively studied as a main is- sue in Software Engineering. Let us survey some key related works in this area. [3,23] have formally defined a compatibility notion for software components using an automata-based formalism. Their compatibility notion consists of checking two pro- tocol properties, namely unspecified receptions and deadlock. More recently, [1,5]



Fig. 9. Compatibility Checking Process





have used a Finite State Machine (FSM) model to formalise a compatibility notion for Web services which aims to check whether one service can substitute another service. In [1], the authors adopt an asymmetric relation, namely simulation, for determining if a new version of a service behaviour simulates a previous one. [5] gives a restrictive notion of behavioural compatibility saying that each trace in one Web service must also be preserved in another Web service. In [16,17,14], the au- thors rely on bisimulation algorithms to define the compatibility of Web services
proposed a compatibility notion based on the π-calculus to ensure the successful which are described using Petri nets. As regards process algebra, [4] and [10] have composition of Software components and Web services, respectively. Bordeaux et
al. [2] were the first who survey several compatibility notions. However, the Labeled Transition System (LTS) model presented in [2] does not consider value-passing and internal behaviour, and no tool support exists.
account τ actions, and those that deal with them only use one of the possible To sum up, there are few compatibility approaches [4,14,17] which take into strategies. Most of the previous works [3,5,2,1,17,14] consider models where value-
passing is not taken into account. In addition, only a few proposals [1,5] have at their disposal an implementation to automatically check the proposed compatibil- ity notions. Compared to these works, we consider a formal interface model which takes into account both non-observable actions and value-passing. Moreover, we propose a framework which enables to check, in a unified manner, several compati- bility notions, and therefore make our proposal useful for many possible application
domains. Our solution also deals with the subtleties of τ actions, and we have im- plemented several τ strategies to handle them properly. Since our proposal relies on an encoding into Maude, the compatibility check is fully automated. Last, the
prototype tool that we implemented goes beyond the check of protocol compatibility since it is able to return a counterexample.

Concluding Remarks
In this paper we have presented a unified way to check different protocol compat- ibility notions using the rewriting logic system Maude. The compatibility notions
presented in this paper deal with the subtlety of τ actions in service protocols.
automated check of different compatibility notions with respect to the different τ Our proposal is completely implemented into a prototype tool which enables a fully handling strategies. Our prototype tool checks whether two protocols are compati-
ble, but also returns a counterexample to identify the incompatibility source.
bility for n (n > 2) service protocols. We also aim at including more compatibility As regards future work, we first plan to extend our approach to check compati- notions as well as more τ strategies, and to propose a methodology to make easier
the extension of our approach with these new definitions. As far as possible applica-
tions are concerned, we would like to rely on our compatibility checking techniques in order to measure similarity of service protocols. Similarity goes farther than “Boolean” compatibility by detecting existing mismatches, and measuring the de- gree of compatibility of two (or more) protocols. Finally, we would like to propose a high-level language to enable a user to define his own compatibility notion, and some encoding techniques that would automatically generate the Maude code needed to verify this compatibility.

Acknowledgement
This work has been partially supported by the RESCUE (TIN2008-05932) and MDD-MERTS (TIN2008-03107) projects funded by the Spanish Ministry of Inno- vation and Science (MICINN).

References
A. A¨ıt-Bachir and M. Dumas and M.C. Fauvet. BESERIAL: Behavioural Service Interface Analyser. In Proc. of the 6th International Conference on Business Process Management (BPM’08), volume 5240 of Lecture Notes in Computer Science, pages 374–377. Springer-Verlag, 2008.
L. Bordeaux, G. Salau¨n, D. Berardi, and M. Mecella. When are Two Web Services Compatible? In Proc. of the 5th Int. Workshop on Technologies for E-Services (TES’04), volume 3324 of Lecture Notes in Computer Science, pages 15–28. Springer-Verlag, 2004.
D. Brand and P. Zafiropulo. On Communicating Finite-State Machines. J. ACM, 30(2):323–342, 1983.
C. Canal, E. Pimentel, and J. M. Troya. Compatibility and Inheritance in Software Architectures. Sci. Comput. Program., 41(2):105–138, 2001.
H.S. Chae, J.S. Lee, and J.H. Bae. An Approach to Checking Behavioral Compatibility between Web Services. International Journal of Software Engineering and Knowledge Engineering, 18(2):223–241, 2008.
M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and J.F Quesada. Maude: Specification and Programming in Rewriting Logic. Theoretical Computer Science, 285(2):187–243, 2002.
M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and C. Talcott. Maude 2.4 Manual, November 2008. Available in http://maude.cs.uiuc.edu .


M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and C.L. Talcott, editors. All About Maude - A High-Performance Logical Framework, How to Specify, Program and Verify Systems in Rewriting Logic, volume 4350 of Lecture Notes in Computer Science. Springer, 2007.
L. de Alfaro and T. Henzinger. Interface Automata. In Proc. of the 8th European Software Engineering Conference held jointly with the 9th ACM SIGSOFT International Symposium on Foundations of Software Engineering (ESEC/FSE’01), pages 109–120. ACM Press, 2001.
S.G. Deng, Z. Wu, M. Zhou, Y. Li, and J. Wu. Modeling Service Compatibility with Pi-Calculus for Choreography. In Proc. of the 25th International Conference on Conceptual Modeling (ER’06), volume 4215 of Lecture Notes in Computer Science, pages 26–39. Springer-Verlag, 2006.
H. Foster, S. Uchitel, and J. Kramer. LTSA-WS: A Tool for Model-based Verification of Web Service Compositions and Choreography. In Proc. of the 28th International Conference on Software Engineering (ICSE’06), pages 771–774. ACM Press, 2006.
X. Fu, T. Bultan, and J. Su. Analysis of Interacting BPEL Web Services. In Proc. of the 13th International Conference on World Wide Web (WWW’04), pages 621–630. ACM Press, 2004.
J. Goguen, T. Winkler, Jo. Meseguer, K. Futatsugi, and J.P. Jouannaud. Introducing OBJ. In Joseph Goguen and Grant Malcolm, editors, Software Engineering with OBJ: Algebraic Specification in Action. Kluwer, 2000.
N. Hameurlain. Flexible Behavioural Compatibility and Substitutability for Component Protocols: A Formal Specification. In Proc. of the 5th IEEE International Conference on Software Engineering and Formal Methods (SEFM’07), pages 391–400. IEEE Computer Society, 2007.
M. Hennessy and H. Lin. Symbolic Bisimulations. Theor. Comput. Sci., 138(2):353–389, 1995.
A. Martens. On Compatibility of Web Services. Petri Net Newsletter, 65:12–20, 2003.
A. Martens, S. Moser, A. Gerhardt, and K. Funk. Analyzing Compatibility of BPEL Processes. In Proc. of the Advanced International Conference on Telecommunications and International Conference on Internet and Web Applications and Services (AICT/ICIW’06), pages 147–156. IEEE Computer Society, 2006.
J. Meseguer. Membership Algebra as a Logical Framework for Equational Specification. In Proc. of the 12th International Workshop on Recent Trends in Algebraic Development Techniques (WADT’97), volume 1376 of Lecture Notes in Computer Science, pages 18–61. Springer-Verlag, 1997.
R. Milner, J. Parrow, and D. Walker. Modal Logics for Mobile Processes. Theor. Comput. Sci., 114(1):149–171, 1993.
F. Plasil and S. Visnovsky. Behavior Protocols for Software Components. IEEE Transactions on Software Engineering, 28(11):1056–1076, 2002.
R. Milner. Communication and Concurrency. Prentice Hall International Series in Computer Science. Prentice-Hall, Inc., 1989.
G. Salau¨n, L. Bordeaux, and M. Schaerf. Describing and Reasoning on Web Services using Process Algebra. International Journal of Business Process Integration and Management, 1(2):116–128, 2006.
D. M. Yellin and R. E. Strom. Protocol Specifications and Component Adaptors. ACM Trans. Program. Lang. Syst., 19(2):292–333, 1997.
