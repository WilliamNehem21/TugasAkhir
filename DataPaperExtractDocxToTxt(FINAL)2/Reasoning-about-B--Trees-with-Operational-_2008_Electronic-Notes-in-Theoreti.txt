

Electronic Notes in Theoretical Computer Science 218 (2008) 355–369
www.elsevier.com/locate/entcs

Reasoning about B+ Trees with Operational Semantics and Separation Logic
Alan Sexton and Hayo Thielecke1
School of Computer Science, University of Birmingham, UK

Abstract
The B+ tree is an ordered tree structure with a fringe list. It is the most widely used data structure for data organisation and searching in database systems specifically, and, probably, computing in general. In this paper, we apply two techniques from programming language theory to B+ trees: operational semantics, in the form of an abstract machine, and separation logic. We use an abstract machine to give a precise and tractable formalisation of the operations on B+ trees. Separation logic is then used to formalise a data structure invariant for B+ trees and to establish correctness by showing that the invariant is preserved by the operations. As usual in separation logic, a frame property is essential for keeping the reasoning local. In our setting, that means that we concentrate on the subtree reached from the top of the stack of the abstract machine, while the remainder of the B+ tree stays invariant. A particularly attractive feature of this approach is the smooth way that proofs can cope with algorithms that begin with a tree descent and switch to fringe list traversal.
Keywords: B+ Trees, Separation Logic, Abstract Machines, Data Structure, Invariant.


Introduction
The B+ tree [1,4] is the most widely used data structure for data organisation and searching in database systems today. In this paper we present a formalisation of the B+ tree and its insert and search algorithms that succinctly captures its behaviour. We present data structure invariants for the tree and use these to prove correctness of insertion. We also prove correctness of a general find algorithm that, given lower- and upper-bound key values, returns a list of matching data items by descending the tree to find the first data item in the range, and then traversing the fringe list to obtain all the remaining required items.
Separation logic: To reason about B+ trees rigorously, we will express a data structure invariant for them in a fragment of separation logic [3,6,9]. The central feature here is the separating conjuction ∗, which splits a store into disjoint parts, and allows reasoning to be local. While the literature on separation logic has largely

1 Email: a.p.sexton@cs.bham.ac.uk and h.thielecke@cs.bham.ac.uk

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.021

used separation logic predicates as the assertions of a Hoare logic, we do not use Hoare logic here. That is, rather than formally deriving Hoare triples {P } c {Q} for some code c, we reason semantically about stores σ satisfying some formula, σ |= P . Abstract machines: To formalize the operations on B+ trees, we use an abstract machine based operational semantics to give a somewhat more abstract and concise specification than pure code. Abstract machines were pioneered by Landin with his SECD machine [7]. Since then, a large variety of abstract machines have been used to formalise programming languages and features, mainly for functional and logic programming languages. A central feature of many abstract machines is the stack. Our machine uses its stack not as a function call stack, but for traversal of the B+ tree. The tree itself is held in what we call the store. In B+ tree implementations, the nodes of the tree are stored in disk pages. The way these pages are linked together is analogous to the way pointers refer across the heap in separation logic. (We call that part of the machine the “store” rather than “heap” to avoid clashes with database terminology). In related work [10,11], we have used this approach to specify the BV-tree [5], a structure that is significantly more complex than the B+ tree, and used it to solve some open problems on this structure as well as obtaining an implementation by hand-translating the abstract machine rules into Java.
Local reasoning and footprint: Our correctness statements will be formulated in terms of the operational semantics and predicates on stores. They typically take the following form: If the initial store σ satisfies σ |= P , then there is a sequence of machine transitions
⟨... , σ⟩ ~ ··· ~ ⟨... , σ'⟩
such that the new store σ' satisfies σ' |= Q. Here P and Q are separation logic pred- icates using our B+ tree invariant. A key advantage of the separating conjunction
∗ is that it gives rise to local reasoning. In a Hoare triple {P } c {Q} for a command
c, another formula R can be added via the frame rule:
{P } c {Q}
{P ∗ R} c {Q ∗ R}
Intuitively, anything that is not mentioned in the specification of the command c cannot be altered by it, so we can assume that R stays invariant. Informally, one speaks of the command having a certain “footprint” to which all possible changes are confined. In the present machine setting it is not obvious what the footprint should be, or how a local reasoning is to be achieved (compare the situation in the presence of code pointers [12]). Since we do not reason about code in some given language, but about machine transitions, there is no ready-made frame rule that we could appeal to in proofs. Rather, we have to find some analogue of the footprint that enables us to reason locally. Roughly speaking, in the abstract machine transitions, we have a current B+ tree pointer that identifies the footprint, and such pointers can be pushed onto the stack as we descend the tree. Our reasoning stays local by focusing on transition sequences that restore the stack π after a series of push and pop operations:
⟨... , π, σ⟩ ~ ··· ~ ⟨... , π, σ'⟩

Outline: We formalize B+ trees as a data structure invariant, formulated in sep- aration logic, in Section 2. We then introduce abstract machine semantics for B+ tree operations and show their correctness: insertion (Section 3) and finding ele- ments in a range query (Section 4). Deletion of elements is discussed in Section 5. Finally, we remark on some issues raised by this work, discuss our conclusions and indicate our planned future work in Section 6.

B+ trees in separation logic
The B+ tree is a ordered, n-ary branching, balanced, search tree supporting de- structive updates. In order to preserve the B+ tree invariant, updates can trigger further updates at higher levels of the tree. Data items are stored only in the leaves and all nodes except the root are guaranteed to be kept at least half full. Leaf pages are maintained in a singly-linked list.
We describe our term structure for B+ tree nodes and for abstract machine commands with a BNF grammar extended with sequence constructors: thus [X] means a sequence of terms of type X.
We assume that there is function key: Entry → Key and that Key is totally ordered. For entries a and a', we write a ± a' for key (a) ≤ key (a'), and analogously for и. This notation is extended both to sets of entries, by quantification, and to keys: thus S ± k, where S is a set of entries and k is a key, stands for ∀a ∈
S. key (a) ≤ k.
For simplicity, we assume that the maximum number of entries in a leaf page and that the maximum number of child pages (i.e., the maximum fanout) of an internal page are the same and given by a parameter MaxN .
The grammar for a node of a B+ tree is as follows:
Node ::=		INode | LNode INode ::=	I ([Key]; [PageID ]) LNode ::=		L ([Entry ]; PageID )
The intention is that an INode represents an internal node of the tree (i.e., a disk page containing a sequence of keys and a sequence of child page pointers), whereas an LNode corresponds to a leaf node of the tree, i.e., a disk page containing a sequence of data entries and a forward page pointer.
We assume a store, defined as a finite partial map from page identifiers (or locations) to nodes σ : PageID → Node .
For a store σ, we define dom σ ::= {p | ∃n ∈ Node. p '→ n ∈ σ } and the store update notation σ[p '→ v] to mean {q '→ n | q '→ n ∈ σ ∧ q /= p } ∪ {p '→ v}. We further define σ[p0 '→ v0, p1 '→ v1,.. .] to mean σ[p0 '→ v0][p1 '→ v1] .. .. Finally, to accommodate release of a location r in a store σ, where r ∈ dom σ, we define σ \ r to mean the restriction of σ with r removed, σ |dom σ\{r}
For example, consider a store initialised to contain an empty B+ tree with root page pointer r. It maps r to a leaf node containing an empty sequence of entries

and a null forward pointer, that is, it is of the form:
{r '→ L ([ ] ; null)}
The invariants on stores containing B+ trees will be expressed in predicate logic; but, crucially, the logic is augmented with the spatial (or separating) conjunction of Separation Logic. We briefly recall some relevant definitions from the literature [6,9]. The partial operation ∗ on stores is defined only if σ0 and σ1 are disjoint, that is, dom σ0 ∩ dom σ1 = ∅. If so, then σ0 ∗ σ1 = σ0 ∪ σ1 as partial functions.

Fig. 1. Semantics of some separation logic connectives
Figure 1 gives the semantics of the separation logic connectives in terms of what it means for a store σ to satisfy a formula Q, written as σ |= Q. We also use equality of integers and standard predicate logic quantification. For instance, σ |= ∃x.Q iff, for some v, we have σ |= Q[x '→ v]. We elide the type of x, as it is typically clear from the context.
The B+ trees contain two data structures superimposed on each other: a tree and a linked list at the fringe of the tree. In terms of separation logic, the tree is handled by a spatial conjunction ∗ among each internal node and its subtrees. Such a data structure consisting of a tree with a list at the leaves is one of the cases studied by Bornat, Calcagno and O’Hearn [3]; B+ trees are a more complex version of this common situation. In our version, the list is not specified directly, but as the linking of the first and last nodes of subtrees to make the induction go through. It specialises to a list at the leaves, and this is what searching for entries relies on. Formally, we define a predicate Btreeh(r, S, a, z, n) on stores.	Intuitively, it means that r points to a B+ tree of height h, which contains n immediate chil- dren if h > 1 or n entries if h = 1, and whose set of entries is S, such that a is the
address of the first leaf node and the last leaf node has z as its forward pointer.
Definition 2.1 The predicate Btreeh(r, S, a, z, n) is defined by induction over h as follows:
Btree1(r, S, a, z, n) ⇐⇒ ∃e1,... , en. n ≤ MaxN
∧	r '→ L (e1 ... en ; z)
∧	S = {e1,... , en}∧ a = r ∧ e1 и ··· и en

Btreeh+1(r, S, a, z, n) ⇐⇒ ∃d1,... , dn−1, q1 ... qn, m1,... , mn. n ≤ MaxN
∧	(r '→ I (d1 ... dn−1 ; q1 ... qn)
∗ Btreeh(q1, S1, a1, a2, m1)
∗ Btreeh(q2, S2, a2, a3, m2)
∗ ··· 
∗ Btreeh(qn, Sn, an, an+1, mn))
∧	a1 = a ∧ an+1 = z
∧	S = S1 ∪ ··· ∪ Sn
∧	(∀j. 1 < j < n − 1 ⇒ dj ± Sj и dj+1)
∧	(∀j. 1 < j ≤ n ⇒ [MaxN /2| ≤ mj)
∧	(S1 и d1)
∧	(dn−1 ± Sn)
For a complete B+ tree, we define that the list of leaves is null-terminated:
ComBtree(r, S) ≡ ∃h, a, n.Btreeh(r, S, a, null, n)
Note that the Btree predicates directly limit the maximum occupancy of a node to its maximum capacity, MaxN . Also, the Btreeh+1 predicate limits the minimum occupancy of each child node to be at least half its maximum capacity. The usual occupancy guarantee of B+ trees, namely that all except the root node are at least half full, then follows from the obvious inductive argument.

Insertion as abstract machine rules
We present a number of ancillary definitions and notations in Figure 2. While most of these are fairly standard, we make them precise here because of ongoing work on automatic generation of implementations of index structures from the abstract machine specification.
In the rules for the transition relation ~, we draw a distinction between the conditions and the definitions for the purpose of generation of efficient code: the conditions must be tested before a transition can be triggered, however, only those definitions that are used in the source configuration or in the condition should be substituted in before the condition test succeeds. The rules are ordered so that if multiple rule heads and conditions match an abstract machine configuration, only the first is triggered. This ordering allows the removal of non-determinism without requiring tedious repetition of negated conditions of previous rules with the same heads.
Insertion configurations are tuples of the form C , r , π , σ where C is a com- mand, r is a page identifier, π is a stack of pairs of the form (q, i), where q is a page identifier, i is an integer, and σ is a page store.
The grammar for the B+ tree insertion command terms is as follows:
InsertionCommand ::= Insert (Entry ) | S | D (Key, PageID ) | Ret






Fig. 2. Definitions

The initial configuration for an insert of an entry a into some B+ tree ⟨r, σ⟩, where σ is a (page) store and r is the page identifier of the root page of the B+ tree, is Insert (a) , r , [] , σ . A terminal configuration is Ret , r' , [] , σ' , where the resulting B+ tree is ⟨r', σ'⟩.
We need two ancillary definitions for use in the insertion rules. These define the policy for splitting the contents of leaf and internal nodes when such a split in necessary.
The first, splitL (i, a, e), defines the components that are produced when a sequence of entries, e, has another entry, a, inserted into it at position i. The components of the result are ⟨e', k, e''⟩, where e' ⊕ e'' = ins (a, i, e), k = key (e'')
and ||e'|− |e''|| ≤ 1.
The second, splitI (i, k, q, d, p), defines the components, d', p', k', d'', p'' , that are produced when a key, k, and page identifier, q, are inserted into the paired key and page identifier sequences, ⟨d, p⟩ with |p| = |d| + 1, of an internal node at position i, which must then be split.
The components of the result, d', p', k', d'', p'' , satisfy the conditions: d' ⊕ [k'] ⊕ d'' = ins (k, i, d), p' ⊕ p'' = ins (q, i + 1, p), |p'| = d' + 1, |p''| = d'' + 1, and ||p'|− |p''|| ≤ 1.
The abstract machine transition rules for insertion are described in figure 3.



Fig. 3. B+ tree insertion rules

They are split into 4 sections. The first contains the single rule for descending down the correct path of internal nodes in the tree, while pushing the path location information on the stack at each step. The second section describes the three cases that can occur when a leaf page is encountered: (i) The entry to be inserted has the same key value as an existing entry in the page and so replaces the existing entry and no further action is necessary (a single page result has occurred). (ii) The entry fits into the page so the page is updated. Again no further action is necessary as a single page result has occurred. (iii) The entry did not fit and the page had to be split between the original leaf page and a new one. As a double page result has occurred, a new key/page pointer pair has to be inserted into the parent level
The third section describes the possible ripple in post operations up the tree. Again there are three cases, each popping the parent location off the stack: (i) If the result from the level below was a single page, there is no change necessary in this level so we pass on a single page result to the level above. (ii) If the result from below was a double page, we have to insert a new pair in this level. If it fits then we return a single page result to the level above. (iii) If the result from below was a double page, and there is insufficient space in this node to insert the new key/pointer pair, then we have to split this page and return a double page result to the level above.
The final section specifies the behaviour when the upward rippling finds the stack to be empty. At this point the system is trying to return a result from the root page level: Either the old root has not been split, in which case the root of the

new tree is the old root itself, or the root page has been split, in which case a new root page has to be constructed and made to point to the two sub-trees.
The main result for insertion (Theorem 3.2 below) states that the insert com- mand, if run on a well-formed B+ tree in the store, leaves a tree in the store that also contains the new entry. To be more precise, it could happen that an old entry with the same key could have been overwritten; we introduce the notation
S + e = S \ {e' | key e' = key (e)}∪ {e}
to state this insertion of entries. We need to show that when the machine starts with an insertion Insert (e) , r , [] , σ , it transforms its initial store satisfying σ |= ComBtree(r, S) into a new store σ' satisfying σ' |= ComBtree(q, S + e). In the proof, we reason, not about individual machine steps, but about longer transition sequences that process a whole subtree (if the subtree is a leaf, then the transition sequence is actually a single step). This is essential, as it allows us to treat the rest of the store with a sort of frame property as we descend the tree to focus on smaller subtrees. We need the following lemma to make the induction go through:
Lemma 3.1 Let R be any predicate on stores and assume σ |= Btreeh(r, S, a, z, n) ∗
R. Then one of the following holds:
There is a transition sequence
Insert (e) , r , π , σ  ~ ··· ~ S , r , π , σ'
and σ' |= Btreeh(r, S + e, a, z, n') ∗ R and either n' = n or n' = n + 1.
There is a transition sequence
Insert (e) , r , π , σ  ~ ··· ~ D (k, q) , r , π , σ'
where σ' |= Btreeh(r, Sr, a, b, n') ∗ Btreeh(q, Sq, b, z, n'') ∗ R. Moreover, Sr ∪
Sq = S + e and Sr и k ± Sq and MinN ≤ n' and MinN ≤ n''.
Proof. By induction over the height of the B+ tree. We sketch the induction, emphasising the spatial logic part, while eliding some straightforward checking of side conditions.
Assume that σ |= Btree1(r, S, a, z, n) ∗ R. and consider the configuration before the transition:
Insert (e) , r , π , σ
By Definition 2.1, if the height of the tree is 1, then r points to a leaf node, that is,
σ |= Btree1(r, S, a, z, n) ∗ R implies σ = {r '→ L (e ; z)}∗ σR, where σR |= R.
If the transition leads to an S command, this gives us a sequence of length 1:
Insert (e) , r , π , σ  ~ S , r , π , σ'
where only r has been updated in σ', so that σR remains unchanged. Hence σ' |=
Btree1(r, S + e, a, z, n') ∗ R. Furthermore, the two possible transitions that lead to

an S command when r points to a leaf node either replace a single entry in the node or insert one extra entry, so n' = n or n' = n + 1.
Now suppose the transition leads to a D command:
Insert (e) , r , π , σ  ~ D (k, q) , r , π , σ'
where σ' = σ[r '→ L (e' ; q) ,q '→ L (e'' ; z)]. Then r has been updated, q is fresh, thus not affecting σR. Further, |e'| + |e''| = n + 1 and, by the requirements of splitL, MinN ≤ |e'| and MinN ≤ |e''|. We have
σ' |= Btree1(r, Sr, r, q, n') ∗ Btree1(q, Sq, q, z, n'') ∗ R
and MinN ≤ n' and MinN ≤ n'' as required.
Next, suppose the tree has a height greater than 1: σ |= Btreeh+1(r, S, a, z, n) ∗
R. That implies that r points to an internal node, σ(r)= I (d ; p). Hence we have a transition
Insert (e) , r , π , σ  ~ Insert (e) , pi , (r, i) :: π, σ
Now σ |= Btreeh+1(r, S, a, z, n) ∗ R implies
σ |= r '→ I (d ; p) ∗ Btreeh(p1, S1, a1, a2, m1) ∗ ··· ∗ Btreeh(pn, Sn, an, an+1, mn) ∗ R
with an+1 = z. Let R' describe the store with the subtree rooted at pi removed:
R' = r '→ I (d ; p)
∗ Btreeh(p1, S1, a1, a2, m1) ∗ ··· ∗ Btreeh(pi−1, Si−1, ai−1, ai, mi−1)
∗ Btreeh(pi+1, Si+1, ai+1, ai+2, mi+1) ∗ ··· ∗ Btreeh(pn, Sn, an, an+1, mn)
∗ R
We can then plug the subtree back in, giving σ |= Btreeh(pi, Si, ai, ai+1, mi) ∗ R', as ∗ is commutative and associative. We can therefore apply the induction hypoth- esis for trees of height h and the predicate R'. There are two possible transition sequences, leading either to a S or a D (·, ·) configuration. We need to show that both these possible resulting configurations lead on further to an S or a D (·, ·) con- figuration that matches the pattern described in the lemma for trees of height h + 1:
First, suppose we obtained a S configuration:
Insert (e) , pi , (r, i) :: π, σ  ~ ··· ~ S , pi , (r, i) :: π, σ'
where σ' |= Btreeh(pi, Si + e, ai, ai+1, mi') ∗ R'. Then the next transition pops the stack and restores r:
S , pi , (r, i) :: π, σ' ~ S , r , π , σ'
Combining the above transitions, we have
 Insert (e) , r , π , σ ~ ··· ~ S , r , π , σ' 

where σ' |= Btreeh+1(r, S + e, a, z, n') ∗ R. Further, n' = n as the internal node pointed to by r has not changed. This gives us a transition sequence of the required form.
Next, suppose that the induction hypothesis tells us that the transition se- quence lead to a D (·, ·) configuration:
 Insert (e) , pi , (r, i) :: π, σ ~ ··· ~ D (k, q) , pi , (r, i) :: π, σ' 
and also that the store satisfies
σ' |= Btreeh(pi, S', ai, b, mi') ∗ Btreeh(q, Sq, b, ai+1, mi'') ∗ R'
From this D (·, ·) configuration, there are two possible next transitions, depend- ing on whether the key/page pointer pair fits or the page has to be split.
Assume the former. In this case the transition is to an S configuration:
 D (k, q) , pi , (r, i) :: π, σ' ~ S , r , π , σ'' 


where
σ'' = σ'[r '→ I (ins (k, i, d); ins (q, i + 1, p))]

Then σ'' |= Btreeh+1(r, S + e, a, z, n') ∗ R, where n' = n + 1. Thus, in the updated store, r points to a B+ tree of height h + 1 with the split subtrees inserted in their correct places.
In the latter case the transition is to a D (·, ·) configuration:
 D (k, q) , pi , (r, i) :: π, σ' ~ D k', q' , r , π , σ'' 


where
σ'' = σ'[r '→ I ds ; ps , q' '→ I dss ; pss ]

and d', p', k', d'', p'' = splitI (i, k, q, d, p). By the definition of splitI, and given that |p| = MaxN , we have that [MaxN /2| ≤ n' and [MaxN /2| ≤ n'', σ'' |= Btreeh+1(r, Sr, a, b, n') ∗ Btreeh+1(q', Sq' , b, z, n'') ∗ R and Sr ∪Sq' = S +e.
 
Given Lemma 3.1, we now prove correctness of insertion:
Theorem 3.2 Assume that σ |= ComBtree(r, S). Then
Insert (e) , r , [] , σ  ~ ··· ~ Ret , q , [] , σ'
and σ' |= ComBtree(q, S + e).
Proof. Suppose σ |= ComBtree(r, S).	Then for some h and a, we have σ |=
Btreeh(r, S, a, null, n) ∗ emp, since emp is the neutral element of ∗.
We apply Lemma 3.1, with R = emp. There are two possible cases, leading to an S or a D (·, ·) configuration. In the first case, we have


~ ··· ~
Insert (e) , r , [] , σ
S , r , [] , σ' 

~	Ret , r , [] , σ'
and σ' |= Btreeh(r, S + e, a, null, n') ∗ emp where n' = n or n' = n + 1. That implies
σ' |= ComBtree(r, S + e), and we are done with this case.
Now consider the case that the last node had to be split, resulting in a D (·, ·) configuration. Then we have transitions



where
~	 Ret , t , [] , σ'' 

σ' |= Btreeh(r, Sr, a, b, n') ∗ Btreeh(q, Sq, b, null, n'') ∗ emp

with Sr ∪Sq = S +e, and furthermore σ'' = σ'[t '→ I ([k]; [r, q])] for some t ∈/ dom σ'. Then the store with the newly allocated node satisfies:
σ'' |= t '→ I ([k]; [r, q]) ∗ Btreeh(r, Sr, a, b, n') ∗ Btreeh(q, Sq, b, null, n'')
hence σ'' |= Btreeh+1(t, a, S + e, null, 2) and thus σ'' |= ComBtree(t, S + e), as required. Thus either the insertion completes by leaving the occupancy of the root page unchanged or increased by one, or the root page was already full and inserting the new subtree caused it to split into two nodes, each at least half full, and a new root node containing precisely two subtrees is grafted on top.	 

Find as abstract machine rules
We consider a range query that takes a lower and an upper bound key value, and returns a list of entries. This can be specified in two phases, such that the first phase takes only the lower bound key value and descends the tree to find the first leaf page that can contain matching entries. We describe the transition rules for the first phase in Figure 4. The second phase simply iterates across the linked list of pages at the leaf level extracting matching entries until the upper bound is reached. As it has been well discussed in the literature, we omit the details of the iterator phase here. The operational semantics of these two phases can be verified separately, and connected only at the level of predicates. Moreover, logically the first phase is more interesting, as it starts with a tree predicate and successively “transfers” leaf nodes into a list predicate, in the sense of the “transfer of ownership” concept in separation logic.
For reasoning about the list of results of a find operation, we need a list predicate: FList(p, i, S) means that p points to a list of leaf nodes, such that S is the set of all the entries from the i-th position in the first node of the list and all entries in all subsequent nodes. It is essentially a standard list predicate, apart from the additional index into the first sequence of entries:





Definition 4.1
Fig. 4. B+ tree find rules

FList(r, i, S) ⇐⇒ (r = null ∧ S = ∅∧ emp)
∨	∃f, e1,... , en, Sf .
(r '→ L (e1,... , en ; f ) ∗ FList(f, 1, Sf ))
∧ S = Sf ∪ {ei,... , en}
We will also need to filter out all those entries from a set that are greater than the lower bound of a query:
Definition 4.2 For a set of entries S and key k, let
S ↑ k = {e | e ∈ S ∧ key (e) ≥ k}.
The correctness of find (Theorem 4.5 below) that we are aiming for states that starting the machine as Find (k) , r , σ in a store satisfying σ |= ComBtree(r, S) results in a final configuration Ret(q, i), so that q and i identify the start of the list of results. If there are no entries with keys greater than k, Find (k) returns the address of the last leaf node together with an index one past the end of the entry sequence of that page. In that case the list predicate holds only for an empty set of entries, which is the appropriate result.
In reasoning about the find operation, we need to be able to append the fringe of a tree to a list, as stated by Lemma 4.3:
Lemma 4.3 Suppose
σ |= Btreeh(r, Sr, a, z, n) ∗ FList(z, 1, Sz) ∗ true
Then σ |= FList(a, 1, Sr ∪ Sz) ∗ true.
Proof. By induction on h. For h > 1, there is a nested induction over the number of children of the top internal node, pointed to by r.	 
The correctness proof for find relies on a lemma (Lemma 4.4) that generalizes it to make the induction go through. It partitions the store into three disjoint parts: the current B+ tree, a list of leaf nodes to the right of the current B+ tree, and everything else, expressed with the catch-all predicate true. During the descent of the tree by Find (k) transitions, the list acts like a data structure continuation

or an accumulator, to put it in functional programming terminology. As Find (k) descends the tree, nodes are transfered into the accumulator.
Lemma 4.4 Let σ |= Btreeh(p, Sp, a, z, n) ∗ FList(z, 1, Sz) ∗ true. Then we have a sequence of h transitions
Find (k) , p , σ  ~ ··· ~ ⟨Ret(q, i), σ⟩
for some q and i with σ |= FList(q, i, (Sp ↑ k) ∪ Sz) ∗ true.
Proof. Induction on the height of the B+ tree.
Suppose the height of the tree is 1, so σ |= Btree1(r, Sr, a, z, n) ∗ FList(z, 1, Sz) ∗ true. That implies r '→ L (e1 ... en ; z) with Sr = {e1,... , en}. Then there is one transition step
Find (k) , r , σ  ~ ⟨Ret(r, i), σ⟩
such that Sr ↑ k = {ei,... , en}. We have σ |= FList(r, i, (Sr ↑ k) ∪ Sz) ∗ true, as required.
Now suppose the height of the tree is h +1 > 1, so that the store satisfies
σ |= Btreeh+1(r, S, a, z, n) ∗ FList(z, 1, Sz) ∗ true

Unrolling the definition of B+ trees once, we see that there is an internal node at the top, so that
σ |= r '→ I (d1 ... dn−1 ; p1 ... pn)
∗ Btreeh(p1, S1, a1, a2, m1)
∗ Btreeh(p2, S2, a2, a3, m2)
∗ ··· 
∗ Btreeh(pn, Sn, an, an+1, mn)))
∗ FList(z, 1, Sz) ∗ true
where a1 = a and an+1 = z. Hence the next transition step is of the form
 Find (k) , r , σ ~ Find (k) , pi , σ 
such that S ↑ k = (Si ↑ k) ∪ Si+1 ∪ ··· ∪ Sn. Notice that
σ |= Btreeh(pi, Si, ai, ai+1, mi)
∗ Btreeh(pi+1, Si+1, ai+1, ai+2, mi+1)
∗ ··· 
∗ Btreeh(pn, Sn, an, an+1, mn)))
∗ FList(z, 1, Sz) ∗ true
To see this, split the store into two parts σ = σ0 ∗ σ1 such that σ1 satisfies the above formula. Since σ0 |= true, and the formula contains ... ∗ true, all of σ satisfies it as well. Intuitively, the internal node as well as all leaf nodes on the left (below the lower bound of the query) are thus swept into true to be ignored.

By Lemma 4.3, applied (n − i) times to σ, we conclude that
σ |= Btreeh(pi, Si, ai, ai+1, mi) ∗ FList(ai+1, 1, Si+1 ∪ ··· ∪ Sn ∪ Sz) ∗ true

(Recall that an+1 = z.) Intuitively, the fringes of the trees to the right are appended to the accumulator. With the preceding gerrymandering of the store, we can now apply the induction hypothesis for trees of height h to the tree rooted at pi together with the list starting from ai+1. That gives us a transition sequence of length h
Find (k) , pi , σ ~ ··· ~ ⟨Ret(t, j), σ⟩
where σ |= FList(t, j, (Si ↑ k) ∪ Si+1 ∪ ··· ∪ Sn ∪ Sz) ∗ true. That is, we have
Find (k) , r , σ  ~ ··· ~ ⟨Ret(t, j), σ⟩
in h + 1 steps, where σ |= FList(t, j, (S ↑ k) ∪ Sz) ∗ true as required.	 
The required correctness of the find operation now arises as a special case:
Theorem 4.5 If σ |= ComBtree(r, S), then
Find (k) , r , σ  ~ ··· ~ ⟨Ret(q, i), σ⟩
for some q and i with σ |= FList(q, i, S ↑ k) ∗ true.
Proof. The theorem follows from Lemma 4.4 for the special case of a complete B+ tree with an empty list: σ |= Btreeh(r, S, a, null, n) ∗ FList(null, 1, ∅) ∗ true. 

Deletion
A full account of deletion is beyond the scope of this paper. When written out in full detail, the rules are lengthy, since they require attention to a number of corner cases. Broadly speaking, deletion is analogous to insertion. A stack is maintained while descending the tree. To maintain occupancy, nodes may need to be merged with one of their siblings (as opposed to being split for insertion). As in the case for insertion, this process may ripple up the tree and can lead to the tree shrinking in height by replacing its root page with its single remaining child page. The rules for deletion also model the deallocation of storage.
From our perspective, a central question is how we can keep reasoning about the B+ tree invariant locally in this setting. The changes to the store need not be confined to the tree pointed to by the node that the machine is currently processing (as they were for insertion). A node may “steal” entries from its left or right siblings to maintain occupancy. However, this does not mean that there is no locality. Since both the current node and its siblings are children of their common parent node on the stack, this parent node gives us a footprint to which updates are confined.This allows us to prove correctness with the same technique we used for insertion.

Conclusions and Future Work
We have shown that B+ trees can be formalised with our techniques building on abstract machines and separating conjunction. B+ trees are instances of the kind of data structures with disciplined sharing that separation logic is well equipped to handle [3]. Whereas the separation logic literature is mainly about Hoare logics, we do not use a formal proof system for code verification. Rather, we reason about in- variants semantically. This informal (not proof-theoretic), but nonetheless rigorous approach may also be suitable for more involved index structures.
In related work [10,11], we have developed rules, in our abstract machine style, for the significantly more complex BV-tree [5]. We have also experimented with automatically translating the abstract machine rules into executable code, with the particular aim of obtaining a high performance implementation of the index structure algorithms. Our first prototype was able to successfully generate high- quality correct code for executing insertions on a B+ tree. Work on reimplementing this prototype to extend the rules to the somewhat more complex ones that were required for the BV-tree is planned.
We believe that the present work will scale up to some of the more complicated index structures. Some, such as R-trees [2], require more complex stack manipu- lations. By adopting a machine that manipulates its stack explicitly, we have a framework in which these trees may also be accommodated. More speculatively, separation logic may also be useful for index structures that appear to have, con- ceptually, holes in the store which could be expressed with the separation logic connective −−∗. Example are BV-trees and the “holey brick” (hB) trees [8].

References
R. Bayer and E. M. McCreight. Organization and maintenance of large ordered indexes. Acta Informatica, 1(3):173–189, 1972.
N. Beckmann, H.-P. Kriegel, R. Schneider, and B. Seeger. The R*-tree: an efficient and robust access method for points and rectangles. In ACM SIGMOD, 322–331, 1990.
R. Bornat, C. Calcagno, and P. O’Hearn. Local reasoning, separation and aliasing. In SPACE 04 workshop, 2004.
D. Comer. The ubiquitous B-tree. Computing Surveys, 11(2):121–137, June 1979.
M. Freeston. A general solution of the n-dimensional B-tree problem. In ACM SIGMOD, 80–91, 1995.
S. Ishtiaq and P. O’Hearn. BI as an assertion language for mutable data structures. In ACM POPL. 2001.
P.J. Landin. The mechanical evaluation of expressions. The Computer Journal, 6(4):308–320, Jan 1964.
D.B. Lomet and B. Salzberg. The hB-tree: a multiattribute indexing method with good guaranteed performance. ACM Trans. Database Syst., 15(4):625–658, 1990.
J.C. Reynolds. Separation logic: A logic for shared mutable data structures. In Logic in Computer Science (LICS), 55–74, 2002.
A.P. Sexton and R. Swinbank. Virtual forced splitting, demotion and the BV-tree. In British National Conference on Databases, BNCOD’08, LNCS. Springer Verlag, June 2008. to appear.
R. Swinbank. Virtual Forced Splitting in Multidimensional Access Methods. PhD thesis, School of Computer Science, University of Birmingham, 2008. Due for completion May 2008.
H. Thielecke. Frame rules from answer types for code pointers. In ACM POPL, 309–319. 2006.
