Electronic Notes in Theoretical Computer Science 205 (2008) 49–65	
www.elsevier.com/locate/entcs

Sequent Calculi for ‘Generally’
Leonardo Bruno Vana1
Program of Systems and Computer Engineering - COPPE Federal University of Rio de Janeiro (UFRJ)
Rio de Janeiro, Brazil
Paulo A. S. Veloso2
Program of Systems and Computer Engineering - COPPE Federal University of Rio de Janeiro (UFRJ)
Rio de Janeiro, Brazil
and
Sheila R. M. Veloso3
Department of Systems and Computer Engineering State University of Rio de Janeiro (UERJ)
Rio de Janeiro, Brazil

Abstract
Logics of ‘generally’ (LG’s) were introduced for handling assertions with some versions of vague notions (e.g. ‘generally’, ‘most’, ‘several’), which occur often in ordinary language and in science. LG’s provide a framework for distinct notions of ‘generally’: one builds a specific logic for the notion one has in mind. We introduce deductive systems, in sequent calculus style, for LG’s and we examine cut elimination.
Keywords: Logics of ‘generally’, vague notions, generalized quantifiers, sequent calculus, cut elimination.


Introduction
Vague notions (e.g. ‘generally’, ‘most’, ‘several’), occur often in ordinary language and in science [1]. Logics of ‘generally’ (LG’s) were introduced for handling as- sertions with some versions of such vague notions [4,11]. Axiomatic and natural deduction style deductive systems have been developed for these logics [11,12]. In

1 Email: leobvana@cos.ufrj.br
2 Email: veloso@cos.ufrj.br
3 Email: sheila@cos.ufrj.br

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.065

this paper, we examine deductive systems, in sequent calculus style, for logics cap- turing distinct notions of ‘generally’. In this context, derivations without cut rule applications are of special interest. We provide a way to eliminate cut rule applica- tions following the ideas presented by Gentzen [6], i.e., we examine cut elimination for sequent derivations in LG’s.
The structure of this paper is as follows. In Section 2 we briefly review some ideas about logics of ‘generally’ (motivation, syntax, semantics and axiomatic sys- tems) and we introduce the idea of marked formulas (in 2.5). In Section 3 we present sequent calculi for some logics of ‘generally’ and in Section 4 we examine cut elimination for such sequent calculi. Finally, in Section 5 we comment on the main features of our approach and on on-going work.

Logics of ‘Generally’
In this section we briefly review some ideas about logics of ‘generally’ (LG’s) [11]. Their goal is to provide a framework for reasoning with distinct notions of ‘generally’ by means of (non-standard) generalized quantifiers [8,7]. 4

Motivation
Vague notions, such as ‘generally’, ‘rarely’, ‘most’, ‘several’ etc. appear often in assertions and arguments in ordinary language and in some branches of science [1,11]. Logics of ‘generally’ (LG’s) are designed to capture some distinct intuitive notions of ‘generally’. 5 We will now illustrate their underlying ideas.
First, consider the universe of Brazilians and imagine that one accepts the two assertions: (α) “Brazilians generally shave their legs” and (β) “Brazilians generally have their faces shaved”. In this case, one is likely to accept also the assertion
(∪) “Brazilians generally have their faces shaved or sport a moustache”; but one is not likely to accept the assertion
(∩)  “Brazilians generally shave their legs and their faces”.
Next, consider the universe of natural numbers and imagine that one accepts the assertions: (γ) “naturals generally are larger than fifteen” and (δ) “naturals generally do not divide twelve”. Then, one would probably accept also the assertions
(∨)  “naturals generally are larger than fifteen or even”; and
(∧)  “naturals generally are larger than fifteen and do not divide twelve”.
LG’s provide a framework for capturing distinct notions of ‘generally’. One builds a specific logic depending on the particular notion one has in mind. Thus, we will have a calculus that allows to conclude (∪) (but one cannot obtain (∩)) from

4 The starting point [3] was the idea of providing an alternative treatment for defaults [9], (cf. [4]).
5 Fuzzy logics also have similar aims [16].

{α, β} and a different one that enables one to conclude (∨) and (∧) from {γ, δ}, although (∩) and (∧) have similar syntactic structures.
Expressions involving ‘generally’, or similar vague notions, occur often in asser- tions and arguments, as in the above examples. One wishes to express such asser- tions in a precise manner. To express “objects generally have a given property”, one adds to First Order Logic (FOL) a new quantifier ∇ to represent ‘generally’.
Syntax
The syntax of the logics for ‘generally’ is obtained by adding the new quantifier ∇
to the usual FOL syntax.
Given a first-order language L, we will use L∇ for the extension of L by the new quantifier ∇. The formulas of language L∇ are built by the usual formation rules [5], together with the new (variable binding) rule giving generalized formulas: if v is variable and A is a formula of L∇, then so ∇vA is a formula of L∇.
The notions of variable occurring (free) in a formula are as usual. We shall use the notations occ[A] for the set of variables occurring in formula A and free[Γ] for the set of variables with free occurrences in some formula in the set Γ of formulas. We shall also use familiar notions concerning substitution of variables [5].
Semantics
Assertions such as “Objects generally have property P ” may be understood as “the set of objects that have the property P is important (among the subsets of the universe of discourse)”. So, one gives the semantics for ‘generally’ by adding a family of sets (those that are considered important) to a usual first-order structure and extending the definition of satisfaction to ∇.
A modulated structure MK = ⟨M, K⟩ consists of a usual structure M together with a complex K: a family of subsets of the universe M of M. We extend the definition of satisfaction of a formula in a structure under an assignment s : V → M to the variables as follows: for a formula ∇vA we define
MK|= ∇vA[s] iff {b ∈ M : MK|= A[s(v '→ b)]} belongs to the complex K 6 . Other concepts, such as model (MK|= A and MK |= Γ), are as usual [5].
On the other hand, the concept of consequence depends on the specific notion of
‘generally’ involved. For instance, the assertions “Sport lovers watch SporTV” and “Boys generally love sports” appear to lead to “Boys generally watch SporTV”. This will be correct if the complexes are closed under supersets (which seems reasonable in the case of ‘many’). More precisely, we say that a formula A is an up-closed consequence of a set Γ of sentences iff MK|= A whenever MK |= Γ, for every model MK whose complex K is closed under supersets (of its universe). We use the notation Γ |=S A, where S is the class of up-closed complexes.
In this manner, each notion of ‘generally’ gives rise to a corresponding conse- quence relation. Given a module C, i.e., a class of complexes (sharing some proper-

6 The assignment s(v '→ b) is as usual: it agrees with s on every variable, except on v, where it is b.

ties), we have the C-consequence relation: Γ |=C A iff MK|= A whenever MK |= Γ, for every model MK whose complex K is in the module C.
Besides the basic module B (complexes without restriction), we shall also con- sider some specific modules, given by their characteristic properties.
The table below shows some properties of complexes. 7

In principle, each combination of the properties from the table above can be used to define a notion of ‘generally’, originating a consequence relation. Some of these modules are familiar, among these we can mention the following ones.
Proper (P): universe (M ∈ K) and non-void (∅ /∈ K).
Up-closed (S): superset.
Lattices (L): intersection and union.
Proper Filters (F): universe, non-void, intersection and superset.
Proper Ultraﬁlters (U ): proper filters that are prime (or have attraction) 8 .

Axiomatic Systems
We have deductive systems for several logics of ‘generally’ adequate for the diverse interpretations of ‘generally’: ‘most’, ‘several’, etc. Axiomatic systems for LG’s are obtained from an axiomatic system for FOL by adding to it some new axioms and axiom schemas concerning the ∇ quantifier. We now indicate how this can be done. Each characteristic property (in 2.3) can be expressed by means of a corresponding axiom/schema, as in the following table. 9 For instance, the schema [∇∧] expresses intersection-closure, whereas the schema [∇∨] reflects an idea of ‘several’.


7 Note that S ⊆ T iff S = S ∩ T . Other similar proprieties can also be envisaged.
8 The properties prime and attraction are equivalent for proper filters (if the underlying logic is classic).
9 Much as ‘⊥’ stands for “falsum”, ‘T’ stands for “verum” (T behaves as ⊥ → ⊥). ∇vT and ¬∇v⊥ are axioms and [∇∧], [∇∨], [∧∇], [∨∇], [¬∇] and [∇¬] are axiom schemas.

Consider also the following two schemas
[↔ ∇]: ∀v(A ↔ B) → (∇vA → ∇vB)	(equivalence);
[∇α]: ∇xA ↔ ∇yA[x/y] (y is new to A: y /∈ occ[A])	(alphabetic variant).
The schemas [↔ ∇] and [∇α], denoted by [B], axiomatize the Basic Logic for ‘generally’ (corresponding to the class B of all complexes, without restriction), i.e., Γ |=BA iff Γ∪[B]▶FOL A. Sound and complete systems for other LG’s are obtained by means of the schemas corresponding to properties of their complexes [11]. Such an LG is axiomatized by adding to [B] a set Ω of schemas from the above table; we will denote this axiomatization by B(Ω).

Marked Formulas
In the next section, we will present deductive systems, in sequent calculus style, for some logics of ‘generally’, emphasizing the treatment of generalized formulas. For this purpose, we will use marked formulas with the same intended meaning as the generalized formulas.
Marked formulas handle the interaction of the ∇-operator with the other logical constants. As the behavior of the ∇-operator depends on the logic for ‘generally’ being considered, the rules of the different LG’s will discipline the use of marked formulas.
A marked formula has the form ⟨A( )⟩ and is supposed to represent a generalized formula ∇xA(x) 10 . The idea is that ‘ ’ represents a generic object and ‘⟨’ and ‘⟩’ emphazise that A(x) is the scope of a generalized quantifier.
More formally, we consider a new symbol ‘ ’ (not in L∇). Given a formula A and a variable v of L∇, the generic instance of formula A with respect to variable v is the result (noted A[v/ ]) of replacing every free occurrence of v in A, if any, by the new symbol ‘ ’. The generic dialect associated to L∇ consists of all such generic instances A[v/ ], for a formula A of L∇ and a variable v. Now, a marked formula has the form ⟨A⟩, where A is a formula of the generic dialect associated to L∇. Let L∇ be the set of all marked formulas associated to L∇. We add L∇ to L∇ to obtain L∇ , i.e. L∇ = L∇ ∪ L∇ . Within L∇ we allow substitution for the new symbol ‘ ’: note that A[v/ ][ /w]= A[v/w].
We extend the familiar concept of degree of a formula A (notation gr(A)) to handle generalized and marked formulas. We define gr(A) recursively as follows:
(Basis) if A is a atomic formula, ⊥ or T, then gr(A) := 0;
(¬) if A is ¬B, then gr(A) := gr(B)+ 1;
(b) if A is (B1bB2), with a binary connective b, then gr(A) := gr(B1)+ gr(B2)+ 1;
(Q) if A is QvB, where Q ∈ {∀, ∃, ∇}, then gr(A) := gr(B)+ 1;
(⟨⟩) for a marked formula ⟨A[v/ ]⟩: gr(⟨A[v/ ]⟩) := gr(A)+ 0.5.

10 So, besides ∇xA(x), ⟨A( )⟩ represents variants like ∇yA(y), ∇zA(z), etc.

Sequent Calculus for ‘Generally’
We will now present sequent calculus for some logics of ‘generally’ following a strat- egy similar to the one we have employed to obtain for natural deduction systems for LG’s in [10,12]. We will first present a sequent calculus for the basic logic of ‘generally’ (in 3.1) and then extend it to specific logics of ‘generally’ (in 3.2).
We will start with a sequent calculus for the underlying first-order logic and we will extend it so as to cover new formulas: with generalized quantifier ∇ and marked ones. The expected structure of a derivation is a first-order logic derivation with local manipulations of ∇ and of marked formulas.
These systems will have two parameters as follows.
A sequent calculus SC for the underlying first-order logic (concerning the con- nectives and the quantifiers, other than ∇). 11
A particular logic G of ‘generally’ (concerning the generalized quantifier ∇ and its behavior with respect to the first-order connectives and the quantifiers).
We will then construct a sequent calculus SC(G), where rules manipulating marked formulas will capture the behavior of ∇.
Here, we will consider Classical Logic as the underlying first-order logic. A sequent S is a pair of sequences of formulas, with the form
A1, ..., Am ⇒ B1, ..., Bn,
where A1, ..., Am, B1, ..., Bn are (unmarked or marked) formulas.  The formulas A1, ..., Am form the antecedent, and the formulas B1, ..., Bn form the consequent, of the sequent S.
The above sequent S has the same meaning as the formula
T (A1) ∧ ... ∧ T (Am) → T (B1) ∨ ... ∨ T (Bn),
where T is the translation T : L∇∗ → L∇ (unmarking the marked formulas), given by T (⟨G⟩) := ∇zG[ /z] where z is the first new variable (such that z ∈/ occ[G]).
The sequent calculus for the Classical Logic (SC) presented in [6] contains op- erational inference rules and the following structural inference rules:
Attenuation:


Contraction:
Γ ⇒ Θ
A, Γ ⇒ Θ
(Aa)
Γ ⇒ Θ
Γ ⇒ Θ,A 
(Ac)

A, A, Γ ⇒ Θ (Ca)	Γ ⇒ Θ, A,A (Cc)

Permutation:
A, Γ ⇒ Θ
Δ, A, B, Γ ⇒ Θ


Δ, B, A, Γ ⇒ Θ

(P a)
Γ ⇒ Θ,A 
Γ ⇒ Θ, A, B, Λ


Γ ⇒ Θ, B, A, Λ

(P c)

The concept of a derivation is as in [6]. To represent the derivation of the sequent
S
S' from the sequent S by several structural rule applications, we use	.

S'

11 The formula A ↔ B can be defined as (A → B) ∧ (B → A).

Sequent Calculus for Basic Logic of ‘Generally’
We will now present sequent calculus rules for the basic logic of ‘generally’ (com- plexes without restriction) (cf. 2.3 in Section 2).
We will extend the sequent calculus SC for Classical Logic [6] to cover general- ized and marked formulas, thereby obtaining the basic sequent calculus SC(B).
We have rules introducing ∇ into the antecedent and the consequent:

⟨A⟩, Γ ⇒ Δ
∇vA[ /v], Γ ⇒ Δ (∇a)
(with v /∈ occ[A])
Γ ⇒ Δ, ⟨A⟩
(∇c)
Γ ⇒ Δ, ∇vA[ /v]

The equivalence rule (🅘) is as follows (with v /∈ free(Γ ∪ Δ)):
A, Γ ⇒ Δ,B	B, Γ ⇒ Δ,A (🅘)
⟨A[v/ ]⟩, Γ ⇒ Δ, ⟨B[v/ ]⟩
We thus obtain the basic sequent calculus SC(B) := SC ∪ {(∇a), (∇c), (🅘)}. We can see that the basic sequent calculus SC(B) is equivalent to the corre-
sponding basic logic for ‘generally’ (axiomatized by [B]).
Proposition 3.1 Given sequences of formulas Γ and Δ in L∇∗ : the sequent Γ ⇒ Δ is derivable in SC(B) iff, for some subset {B1, ..., Bn} ⊆ [B], the sequent T (Γ), B1, ..., Bn ⇒ T (Δ) is derivable in SC.
Proof.
(⇐) We show that each instance of the schemas in [B] can be proved in SC(B). [ ∇α ]: For an instance ∇xA ↔ ∇yA[x/y] (with y /∈ occ[A]) of [∇α], considering 12
⟨A[x/ ]⟩ ⇒ ⟨A[x/y][y/ ]⟩ (∇c)	⟨A[x/y][y/ ]⟩ ⇒ ⟨A[x/ ]⟩ (∇c)
	
 ⟨A[x/ ]⟩ ⇒ ∇yA[x/y]			 ⟨A[x/y][y/ ]⟩ ⇒ ∇xA	  D1 =	 (∇a)	D2 =		 (∇a)

∇xA ⇒ ∇yA[x/y]
we have the following derivation:
D1
∇xA ⇒ ∇yA[x/y]
(→ c)
⇒ ∇xA → ∇yA[x/y]
∇yA[x/y] ⇒ ∇xA

D2
∇yA[x/y] ⇒ ∇xA
(→ c)
⇒ ∇yA[x/y] → ∇xA

⇒ ∇xA ↔ ∇yA[x/y]	(∧c)
[↔ ∇ ]: For an instance ∀v(A ↔ B) → (∇vA → ∇vB) of [↔ ∇], we have the derivation:
	D1			D2	
(P a)	(P a)

A, ∀v(A ↔ B) ⇒ B
B, ∀v(A ↔ B) ⇒ A
(🅘)

	⟨A[v/ ]⟩, ∀v(A ↔ B) ⇒ ⟨B[v/ ]⟩	
	∇vA, ∀v(A ↔ B) ⇒ ⟨B[v/ ]	(∇a) (∇c)
	∇vA, ∀v(A ↔ B) ⇒ ∇vB	
	∀v(A ↔ B) ⇒ ∇vA → ∇	(→ c)
(→ c)
⇒ ∀v(A ↔ B) → (∇vA → ∇vB)

12 Note that ⟨A[x/ ]⟩ = ⟨A[x/y][y/ ]⟩, so ⟨A[x/ ]⟩ ⇒ ⟨A[x/y][y/ ]⟩ is an initial sequent.

where

A ⇒ A B ⇒ B


(→ a)

B ⇒ B  A ⇒ A


(→ a)

 A → B, A ⇒ B	 (∧a)	 B → A, B ⇒ A	 (∧a)
D1 = 	A ↔ B, A ⇒ B	(∀a) D2 = 	B ↔ A, B ⇒ A	(∀a)
∀v(A ↔ B),A ⇒ B	∀v(A ↔ B),B ⇒ A
(⇒) One can transform each derivation Π in SC(B) into a derivation T (Π) in SC
by induction on the size (considering the last rule applied).




(∇a) For
Π
⟨A⟩, Γ ⇒ Δ
∇vA[ /v], Γ ⇒ Δ (∇a), in SC we have:
T (Π)

∇vA[x/v] ⇒ ∇vA[x/v]	T (⟨A⟩)= ∇xA, T (Γ) ⇒ T (Δ)






(∇c) For
∇vA[x/v] → ∇xA, ∇vA[x/v],T (Γ) ⇒ T (Δ)	(→ a)
∇vA[x/v] ↔ ∇xA, ∇vA[x/v],T (Γ) ⇒ T (Δ)	(∧a)
∇vA[x/v], ∇vA[x/v] ↔ ∇xA, T (Γ) ⇒ T (Δ)
Π
Γ ⇒ Δ, ⟨A⟩
(∇c), in SC we have:
Γ ⇒ Δ, ∇vA[ /v]

(P a)

T (Π)
T (Γ) ⇒ T (Δ),T (⟨A⟩)= ∇xA	∇vA[x/v] ⇒ ∇vA[x/v]
∇vA[x/v] → ∇xA, T (Γ) ⇒ T (Δ), ∇vA[x/v]	(→ a)
∇xA ↔ ∇vA[x/v],T (Γ) ⇒ T (Δ), ∇vA[x/v]	(∧a)


Σ1
A, Γ ⇒ Δ,B 
Σ2
B, Γ ⇒ Δ,A 

(🅘) For
⟨A[x/ ]⟩, Γ ⇒ Δ, ⟨B[x/ ]⟩	(🅘), in SC we have:
D1	D2


∀x(A ↔ B) → (∇xA → ∇xB),T (Γ), ∇xA ⇒ T (Δ), ∇xB


(→ a)



∇xA, T (Γ), ∀x(A ↔ B) → (∇xA → ∇xB) ⇒ T (Δ), ∇xB
where

T (Σ1)
A, T (Γ) ⇒ T (Δ),B 


T (Γ) ⇒ T (Δ),A → B


(→ c)
T (Σ2)
B, T (Γ) ⇒ T (Δ),A 

T (Γ) ⇒ T (Δ),B → A


(→ c)


(∧c)

D1 = 	T (Γ) ⇒ T (Δ), A ↔ B	(∀c)
T (Γ) ⇒ T (Δ), ∀x(A ↔ B)

D2 =
T (⟨A⟩)= ∇xA ⇒ T (⟨A⟩)= ∇xA  T (⟨B⟩)= ∇xB ⇒ T (⟨B⟩)= ∇xB
∇xA → ∇xB, ∇xA ⇒ ∇xB	(→ a)
 


Sequent Calculi for Speciﬁc Logics of ‘Generally’
Sequent Calculi for specific logics of ‘generally’ are obtained by extending the basic calculus SC(B) (in 3.1) with appropriate rules. In fact, the rules will correspond to the schemas of the axiomatic presentations of LG’s in 2.4 in Section 2.
We wish to create new rules corresponding to the specific schemas. The con- struction hinges on adding new rules for handling marked formulas.
To introduce the basic idea, consider the case of closure under intersection, expressed by the schema [∇∧] : (∇vA ∧ ∇vB) → ∇v(A ∧ B). This schema [∇∧] can be formulated as a rule:
Γ ⇒ Δ, ∇vA	Γ ⇒ Δ, ∇vB

Γ ⇒ Δ, ∇v(A ∧ B)
(∇∧).

The preceding rule (∇∧) can be easily reformulated as the following rule (∧∗c) for conjunction introduction in a marked environment:
Γ ⇒ Δ, ⟨A⟩	Γ ⇒ Δ, ⟨B⟩ (∧∗c).
Γ ⇒ Δ, ⟨A ∧ B⟩
We will consider the following operational rules corresponding to the properties of complexes in Section 2 (cf. 2.3 and 2.4).
⟨T⟩, Γ ⇒ Δ (T∗a)	Γ ⇒ Δ, ⟨⊥⟩ (⊥∗c)


⟨A⟩, Γ ⇒ Δ
⟨A ∧ B⟩, Γ ⇒ Δ
Γ ⇒ Δ
(∧∗a)	⟨B⟩, Γ ⇒ Δ
⟨A ∧ B⟩, Γ ⇒ Δ
Γ ⇒ Δ
(∧∗a)	Γ ⇒ Δ, ⟨A⟩  Γ ⇒ Δ, ⟨B⟩ (∧∗c)
Γ ⇒ Δ, ⟨A ∧ B⟩


⟨A⟩, Γ ⇒ Δ ⟨B⟩, Γ ⇒ Δ (∨∗a)	Γ ⇒ Δ, ⟨A⟩  Γ ⇒ Δ, ⟨B⟩ (∨∗c)
⟨A ∨ B⟩, Γ ⇒ Δ	Γ ⇒ Δ, ⟨A ∨ B⟩


Γ ⇒ Δ, ⟨A⟩


⟨¬A⟩, Γ ⇒ Δ
(¬∗a)		⟨A⟩, Γ ⇒ Δ Γ ⇒ Δ, ⟨¬A⟩
(¬∗c)

Recall that a specific logic for ‘generally’ can be axiomatized by B(Ω) = [B] ∪ Ω, where Ω is a set of specific axioms and schemas (cf. 2.4 in Section 2). Now, consider the set of rules Ω∗ ⊆ {(T∗a), (⊥∗c), (∧∗a), (∧∗c), (∨∗a), (∨∗c), (¬∗a), (¬∗c)} corresponding to the schemas in Ω. We thus obtain the speciﬁc sequent calculus SC(Ω) := SC(B) ∪ Ω∗.
Much as before (cf. Proposition 3.1 in 3.1), we can see that a specific sequent calculus is equivalent to the corresponding specific logic for ‘generally’.
Proposition 3.2 Consider sequences of formulas Γ and Δ in L∇∗ . Then, the sequent Γ ⇒ Δ is derivable in SC(Ω) iff, for some subset {W1, ..., Wn} ⊆ B(Ω), the sequent T (Γ), W1, ..., Wn ⇒ T (Δ) is derivable in SC.

Proof. As in Proposition 3.1, for (⇐), we show a derivation in SC(Ω) for each instance of a schema in SC(Ω), and, for (⇒), we show how one can inductively transform each derivation Π in SC(Ω) into a corresponding one T (Π) in SC.
We will illustrate the case of schema [∇∧] and rule (∧∗c).
(⇐) A derivation for instance (∇vA ∧ ∇vB) → ∇v(A ∧ B) of [∇∧] is as follows:

⟨A⟩ ⇒ ⟨A⟩
(∇a)
⟨B⟩ ⇒ ⟨B⟩
(∇a)

 ∇vA ⇒ ⟨A⟩	
∇vA ∧ ∇vB ⇒ ⟨A⟩ (∧a)
 ∇vB ⇒ ⟨B⟩	
∇vA ∧ ∇vB ⇒ ⟨B⟩ (∧a)

(∧∗c)

	∇vA ∧ ∇vB ⇒ ⟨A ∧ B⟩	
	∇vA ∧ ∇vB ⇒ ∇v(A ∧ 	(∇c)
(→ c)
⇒ ∇vA ∧ ∇vB → ∇v(A ∧ B)
(⇒) Consider a derivation in SC(B) whose last rule is an application of (∧∗c):

Π1
Γ ⇒ Δ, ⟨A⟩
Π2
Γ ⇒ Δ, ⟨B⟩


(∧∗c)

Γ ⇒ Δ, ⟨A ∧ B⟩
In SC we have the following situation, with derivations D1 and D2. Let D1 be the derivation
T (Π1)
Γ ⇒ Δ, ∇xA = T (⟨A⟩)	∇zA[x/z] ⇒ ∇zA[x/z]
∇xA → ∇zA[x/z],T (Γ) ⇒ T (Δ), ∇zA[x/z]	(→ a)
∇xA ↔ ∇zA[x/z],T (Γ) ⇒ T (Δ), ∇zA[x/z]	(∧a)
 ∇yB ↔ ∇zB[y/z], ∇xA ↔ ∇zA[x/z],T (Γ) ⇒ T (Δ), ∇	(Aa)
(P a)
∇xA ↔ ∇zA[x/z], ∇yB ↔ ∇zB[y/z],T (Γ) ⇒ T (Δ), ∇zA[x/z]






Let D2
T (Π1)
Γ ⇒ Δ, ∇yB = T (⟨B⟩)	∇zB[y/z] ⇒ ∇zA[y/z]
∇yB → ∇zB[y/z],T (Γ) ⇒ T (Δ), ∇zB[y/z]	(→ a)


	∇yB ↔ ∇zB[y/z],T (Γ) ⇒ T (Δ), ∇zB[y/z]	
=	(Aa)
∇xA ↔ ∇zA[x/z], ∇yB ↔ ∇zB[y/z],T (Γ) ⇒ T (Δ), ∇zB[y/z]

Let W be the sequence ∇xA ↔ ∇zA[x/z], ∇yB ↔ ∇zB[y/z]. 13

Let D3
	D1	D2	
=	(∧c)
T (Γ),W ⇒ T (Δ), ∇xA[x/z] ∧ ∇zB[y/z]

Then, as T (⟨A ∧ B⟩)= ∇z(A[x/z] ∧ B[y/z]), we obtain the derivation:
D3	∇z(A[x/z] ∧ B[y/z]) ⇒ T (⟨A ∧ B⟩)
(∇zA[x/z] ∧ ∇zB[y/z]) → T (⟨A ∧ B⟩)),T (Γ),W ⇒ T (Δ),T (⟨A ∧ B⟩)

(→ a)



13 Note that both formulas in W are derivable from the basic schemas in [B] (cf. 2.4).

Cut Elimination for ‘Generally’
We will now examine the cut elimination property [6] for some sequent calculi for ‘generally’ introduced in Section 3. We will first present the basic ideas, which we will apply to the basic sequent calculus ‘generally’ (cf. 3.1) in 4.1, and then examine specific sequent calculi of ‘generally’ (cf. 3.2) in 4.2).
The idea is as usual: one introduces a new inference rule, called mix, which corresponds to a version of the cut rule, and then one examines the property below.
Mix Rule:
Γ ⇒ Δ Θ ⇒ Λ
Γ, Θ∗ ⇒ Δ∗, Λ (M ix)
Here, Δ and Θ are sequences of formulas in L∇∗ , where a formula M (called mix formula) occurs at least once, and Δ∗ and Θ∗ are the sequences obtained from Δ and Θ, respectively, by omitting all occurrences of M .
Example 4.1 The following derivation π has mix formula ⟨A⟩:
⟨A⟩ ⇒ ⟨A⟩



⟨B⟩, ⟨A⟩ ⇒ ⟨A⟩
(Aa)

(Pa)
⟨B⟩ ⇒ ⟨B⟩

(Aa)

⟨A⟩ ⇒ ⟨A⟩
(∧∗a)
⟨A⟩, ⟨B⟩ ⇒ ⟨A⟩
⟨A⟩, ⟨B⟩ ⇒ ⟨B⟩
(∧∗c)

⟨A ∧ B⟩ ⇒ ⟨A⟩
⟨A⟩, ⟨B⟩ ⇒ ⟨A ∧ B⟩
⟨A ∧ B⟩, ⟨B⟩ ⇒ ⟨A ∧ B⟩
(M ix)

A derivation with a mix as its lowest inference rule, and not containing any other mix will be called special.
The concepts of degree and rank of a derivation are easily adapted to the sequent calculi for the LG’s.
Let π be a special derivation with mix formula M . The degree of π (denoted by gr(π)) is gr(M ). The rank of mix π (denoted by r(π)) is the sum of its rank on the left and its on the right. The left (right) rank is the largest number of consecutive sequents in a path so that the lowest of these sequents is the left-hand (right-hand) upper sequent of the mix and each of the sequents contains the mix formula in the consequent (antecedent).
For instance, in example 4.1, the degree of π is gr(⟨A⟩) and the rank is 6.
The crucial property concerns elimination of mix rules from special derivations.
Property SDM : Every special derivation can be transformed into a derivation (with the same endsequent) in which no mix occurs.
Property SDM can be established by induction on the pair (gr(π), r(π)), by relying on the ordering (gr(π), r(π)) < (gr(π'), r(π')) iff gr(π) < gr(π') or gr(π)= gr(π') and r(π) < r(π').

Cut Elimination for Sequent Calculus for Basic Logic of ‘Generally’
We first prove the cut elimination result for the sequent calculus for basic logic of ‘generally’. We will establish property SDM for this calculus (emphasizing the treatment of the generalized quantifier ∇).

As usual, we first consider a derivation of rank 2 with a unique mix rule ap- plication which occurs as its lowest inference rule application. Then, we have the following cases, depending on the mix formula.
(∇) The mix formula is a generalized formula:

Σ1
Γ ⇒ Θ, ⟨A⟩


(∇c)
Σ2
⟨A⟩, Δ ⇒ Λ


(∇a)

 Γ ⇒ Θ, ∇xA[ /x]	∇xA[ /x], Δ ⇒ Λ	
π =	(M ix)
Γ, Δ ⇒ Θ, Λ
We can transform the derivation π into:

Σ1
Γ ⇒ Θ, ⟨A⟩
Σ2
⟨A⟩, Δ ⇒ Λ

Γ, Δ∗ ⇒ Θ∗, Λ	(M ix)

ρ =
Γ, Δ ⇒ Θ, Λ
As gr(⟨A⟩) < gr(∇xA[ /x]), we have (gr(ρ), r(ρ)) < (gr(π), r(π)). So, by induction hypothesis, ρ can be transformed into a derivation π' where no mix rule application occurs.
(⟨⟩) The mix formula is a marked formula. We then have the following derivation π:

Σ1
A, Γ ⇒ Θ,B 
Σ2
B, Γ ⇒ Θ,A 
Σ3
C, Δ ⇒ Λ,D 
Σ4
D, Δ ⇒ Λ,C 

⟨A[x/ ]⟩, Γ ⇒ Θ, ⟨B[x/ ]⟩	(🅘)
⟨C[y/ ]⟩, Δ ⇒ Λ, ⟨D[y/ ]⟩	(🅘)
(M ix)

⟨A[x/ ]⟩, Γ, Δ ⇒ Θ, Λ, ⟨D[y/ ]⟩
where ⟨B[x/ ]⟩ = ⟨C[y/ ]⟩, x /∈ free(Γ ∪ Θ) and y /∈ free(Δ ∪ Λ).
We can transform the derivation π, taking z as a variable new in π, as follows.

Σ1[x/z]
A[x/z], Γ ⇒ Θ, B[x/z]
Σ3[y/z]
C[y/z], Δ ⇒ Λ, D[y/z]


Let D1 =
A[x/z], Γ, Δ∗ ⇒ Θ∗, Λ, D[y/z]	(M ix)
A[x/z], Γ, Δ ⇒ Θ, Λ, ⟨D[y/z]



Σ4[y/z]
D[y/z], Δ ⇒ Λ,C[y/z]
Σ2[x/z]
B[x/z], Γ ⇒ Θ, A[x/z]


Let D2 =
D[y/z], Δ, Γ∗ ⇒ Λ∗, Θ, A[x/z]	(M ix)


D[y/z], Γ, Δ ⇒ Θ, Λ, A[x/z]
ρ = 	D1	D2	 (🅘)
⟨A[x/z][z/ ]⟩, Γ, Δ ⇒ Θ, Λ, ⟨D[y/z][z/ ]⟩

Note that, as x /∈ free(Γ∪Θ) and y /∈ free(Δ∪Λ), we have Γ[x/z]= Γ, Θ[x/z]= Θ, Δ[y/z] = Δ and Λ[y/z] = Λ. On the other hand, as B[x/ ] = C[y/ ], we have B[x/z] = C[y/z]. Thus, as gr(B) < gr(⟨B⟩), then (gr(ρ), r(ρ)) < (gr(π), r(π)). So, by induction hypothesis, ρ can be transformed into a derivation π' without applications of the mix rule.
Now, consider a derivation π with r(π) > 2 and right rank is greater than 1. Several cases should be considered. We will illustrate the case of the deriva-
tion whose last inference rule application immediately before the mix rule is (🅘), occurring in the right hand side, and the mix formula M /∈ Γ. Then
Σ1	Σ2
A, Δ ⇒ Λ,B	B, Δ ⇒ Λ,A 

Γ ⇒ Θ
⟨A[x/ ]⟩, Δ ⇒ Λ, ⟨B[x/ ]⟩	(🅘)

π =	Γ, (⟨A[x/ ]⟩)∗, Δ∗ ⇒ Θ∗, Λ, ⟨B[x/ ]⟩	(M ix)
We can transform the derivation π into:
	D1	D2	 (🅘)
⟨A[x/ ]⟩, Γ, Δ∗ ⇒ Θ∗, Λ, ⟨B[x/ ]⟩


where

ρ =	Γ, ⟨A[x/ ]⟩, Δ∗ ⇒ Θ∗, Λ, ⟨B[x/ ]⟩
Σ1	Σ2

Γ ⇒ Θ
A, Δ ⇒ Λ,B 
Γ ⇒ Θ
B, Δ ⇒ Λ,A 


D1 =
Γ, (A)∗, Δ∗ ⇒ Θ∗, Λ,B	(M ix)

A, Γ, Δ∗ ⇒ Θ∗, Λ,B	D2 =
Γ, (B)∗, Δ∗ ⇒ Θ∗, Λ,A  (M ix)


B, Γ, Δ∗ ⇒ Θ∗, Λ,A 

Σ1
As the ranks of
A, Δ ⇒ Λ,B 
Σ2
and
B, Δ ⇒ Λ,A 
are less than the rank of π,

we have r(ρ) < r(π), whence (gr(ρ), r(ρ)) < (gr(π), r(π)).
Now, we have two cases to consider, depending on the mix formula M .
If M /= ⟨A[x/ ]⟩, then by induction hypothesis, as (gr(ρ), r(ρ)) < (gr(π), r(π)), ρ
can be transformed into a derivation π' without applications of the mix rule.
If M = ⟨A[x/ ]⟩, then by induction hypothesis one can transform
δ = 	D1	D2	 (🅘)
⟨A[x/ ]⟩, Γ, Δ∗ ⇒ Θ∗, Λ, ⟨B[x/ ]⟩
into a derivation δ' where no mix rule application occurs:
δ' =	Σ
⟨A[x/ ]⟩, Γ, Δ∗ ⇒ Θ∗, Λ, ⟨B[x/ ]⟩
As M = ⟨A[x/ ]⟩, the endsequent of the derivation π is Γ, Δ∗ ⇒ Θ∗, Λ, ⟨B[x/ ]⟩. So, we can eliminate ⟨A[x/ ]⟩ from ⟨A[x/ ]⟩, Γ, Δ∗ ⇒ Θ∗, Λ, ⟨B[x/ ]⟩ by applying a mix rule. We thus obtain the derivation below:








δ'' =

Γ ⇒ Θ
Σ
⟨A[x/ ]⟩, Γ, Δ∗ ⇒ Θ∗, Λ, ⟨B[x/ ]⟩
Γ, Γ, Δ∗ ⇒ Θ∗, Θ∗, Λ, ⟨B[x/ ]⟩	(M ix)
Γ, Δ∗ ⇒ Θ∗, Λ, ⟨B[x/ ]⟩

As ⟨A[x/ ]⟩ /∈ Δ∗ and ⟨A[x/ ]⟩ /∈ Γ, we have r(δ'') < r(π), whence (gr(δ''), r(δ'')) < (gr(π), r(π)). So, by induction hypothesis, δ'' can be trans- formed into a derivation without applications of the mix rule.
In all other cases, the mix rule can be eliminated in a similar manner. We thus have SDM property.

Lemma 4.2 The basic sequent calculus SC(B) has the SDM property.

Now, given a derivation π in SC(B) one can transform it into a cut free derivation by applying the following steps:
first, replace each cut rule application in π by a mix rule application (as in [6]) obtaining a derivation π';
next, apply Lemma 4.2 to eliminate each mix rule application in π'.

Theorem 4.3 Each SC(B) derivation can be transformed into a derivation, with the same endsequent, in which no cut occurs.


Cut Elimination for Sequent Calculi for Speciﬁc Logics of ‘Generally’
We will now examine cut elimination in sequent calculi for specific logics of ‘gener- ally’ (cf. 3.2 in Section 3).
We will consider the sequent calculus SC(Ω) = SC(B) ∪ Ω∗, obtained by adding to the sequent calculus SC(B) the set Ω∗ of operational rules for marked formulas. The rules that precede a mix rule application depend on the specific rules in Ω∗.
For instance, consider the case where the last inference rule application immediately before the mix rule is (∧∗a), occurring in the right hand side of the derivation π, with the mix formula M /∈ Γ, r(π) > 2 and right rank is greater than 1:



Γ ⇒ Θ, ⟨A⟩  Γ ⇒ Θ, ⟨B⟩ (∧∗c)
π =	Γ ⇒ Θ, ⟨A ∧ B⟩
Σ
⟨A⟩, Δ ⇒ Λ
⟨A ∧ B⟩, Δ ⇒ Λ


(∧∗a)



(M ix)

Γ, (⟨A ∧ B⟩)∗, Δ∗ ⇒ Θ∗, Λ
We can transform the derivation π into:




Γ ⇒ Θ, ⟨A⟩
Σ
⟨A⟩, Δ ⇒ Λ

Γ, (⟨A⟩)∗, Δ∗ ⇒ Θ∗, Λ	(M ix)



⟨A⟩, Γ, Δ∗ ⇒ Θ∗, Λ
⟨A ∧ B⟩, Γ, Δ∗ ⇒ Θ∗, Λ
ρ =	Γ, ⟨A ∧ B⟩, Δ∗ ⇒ Θ∗, Λ


(∧∗a)





As the rank of

Σ
⟨A⟩, Δ ⇒ Λ


is less than the rank of
Σ
⟨A⟩, Δ ⇒ Λ


⟨A ∧ B⟩, Δ ⇒ Λ


, we have

r(ρ) < r(π), whence (gr(ρ), r(ρ)) < (gr(π), r(π)).
Two cases should be considered, depending on the mix formula M .
M /= ⟨A ∧ B⟩
Inductively, it suffices to transform derivation ρ into a derivation π' where no mix rule application occurs.
M = ⟨A ∧ B⟩
Assume inductively that one can transform derivation ρ into a derivation ρ'
without applications of the mix rule:
ρ' =	Σ
⟨A ∧ B⟩, Γ, Δ∗ ⇒ Θ∗, Λ
As M = ⟨A ∧ B⟩, the endsequent of the derivation π is Γ, Δ∗ ⇒ Θ∗, Λ. Thus, applying the mix rule to eliminate ⟨A ∧ B⟩ of the sequent
⟨A ∧ B⟩, Γ, Δ∗ ⇒ Θ∗, Λ we obtain the following derivation:
Γ ⇒ Θ, ⟨A⟩  Γ ⇒ Θ, ⟨B⟩ (∧∗c)	Σ

Γ ⇒ Θ, ⟨A ∧ B⟩
⟨A ∧ B⟩, Γ, Δ∗ ⇒ Θ∗Λ


ρ'' =
Γ, Γ, Δ∗ ⇒ Θ∗, Θ∗, Λ	(M ix)
Γ, Δ∗ ⇒ Θ∗, Λ

As ⟨A[x/ ]⟩ /∈ Δ∗ and ⟨A[x/ ]⟩ /∈ Γ, we have r(ρ'') < r(π), whence (gr(ρ''), r(ρ')) < (gr(π), r(π)). Thus, it suffices to transform derivation ρ'' into a derivation without applications of the mix rule.
There are cases of mix rule application that we think cannot be eliminated. For instance, consider the derivations

A, A ↔ C ∧ D ⇒ C ∧ D  C ∧ D, A ↔ C ∧ D ⇒ A

⟨A⟩,A ↔ C ∧ D ⇒ ⟨C ∧ D⟩
⟨A⟩,A ↔ C ∧ D ⇒ ⟨D⟩
(🅘)
⟨D⟩ ⇒ ⟨D⟩

⟨C ∧ D⟩ ⇒ ⟨D⟩
(∧∗a)

(Mix)

and
⟨A⟩, ⟨B⟩ ⇒ ⟨A⟩  ⟨A⟩, ⟨B⟩ ⇒ ⟨B⟩

⟨A⟩, ⟨B⟩ ⇒ ⟨A ∧ B⟩



∗
(∧ c)


A ∧ B, C ↔ A ∧ B ⇒ C C, C ↔ A ∧ B ⇒ A ∧ B

⟨A ∧ B⟩,C ↔ A ∧ B ⇒ ⟨C⟩


(🅘)



(Mix)

⟨A⟩, ⟨B⟩,C ↔ A ∧ B ⇒ ⟨C⟩
Note that both derivations are special with rank 2 and the mix formula is ob- tained by applying (🅘)-rule and one of the rules of a specific logic.
In all other cases, except those mentioned above, the mix rule can be eliminated.

Conclusion
We have introduced and analyzed deductive systems, in sequent calculus style, for logics of ‘generally’ (LG’s). In section 3, we have presented sequent calculi for LG’s, basic calculus (in 3.1) and specific calculi (in 3.2), and considered cut elimination for them in section 4. We have established the cut elimination result for the basic calculus of ‘generally’ (in 4.1) and examined when a specific calculus of ‘generally’ has the cut elimination property (in 4.2).
As in [12], marked formulas are employed for handling more easily the interaction of the ∇-operator with the other logical constants, since the behavior of the ∇- operator depends on the logic of ‘generally’ being considered. Thus, we have rules involving marked formulas localized in the antecedent and consequent of a sequent. The proof of the cut elimination result involving applications of rules on marked formulas is very similar to the corresponding one in FOL-formulas; special attention must be given, however, to derivations involving applications of the rule (🅘) (cf. 4.2). The construction of these sequent calculi is modular, in the sense that each one can be built from the basic one by adding appropriate schemas. These calculi have two parameters: the underlying first-order deductive systems and the specific notion
of ‘generally’ involved (cf. section 3).
We can regard the construction of the sequent calculi for LG’s presented here as an application of a general strategy to obtain deductive systems for LG’s. Similar steps were followed to obtain natural deduction style systems for LG’s [12]. Thus, once one has a FOL deductive system (e.g. intuitionist deductive system for FOL) one extends it by adding the axioms corresponding to the LG’s and translate these axioms to rules of a particular deductive style system, as we have illustrated here translating the axioms to sequent calculus rules (in 3.2).
So, one has a modular framework for constructing and analyzing sequent calculi for logics of ‘generally’. As such, this approach may be expected to pave the way for proof methods and automatic theorem provers for logics of ‘generally’ (cf. [14,15]). In the future, we intend to compare our approach to other formalisms, such as
Fuzzy Logic [16] and those related to Linguistics [2].

References
J. Barwise & R. Cooper. Generalized quantifiers and natural language. Linguistics and Philosophy 4, 159-219, 198.

J. van Benthem. Handbook of Logic and Language: A. ter Meulen (eds), Elsevier, 1997.
A. W. Carnielli & A. M. Sette. Default operators. In Abstracts of Workshop on Logic, Language, Information and Computation, Recife, 1994.
A. W. Carnielli & P. A. S. Veloso. Ultrafilter logic and generic reasoning. In G. Gottlob, A. Leitsch &
D. Mundici (eds.) Computational Logic and Proof Theory (LNCS 1289): 34-53, Berlin, Springer-Verlag, 1997.
H. B. Enderton. A Mathematical Introduction to Logic. Academic Press, New York, 1972.
G. Gentzen. Investigations into logical deduction. In M. E. Szabo (ed.), The Collected Papers of Gerhard Gentzen, North-Holland, Amsterdam, 1969.
J. H. Keisler. Logic with the quantifier there exist uncountably many. Annals of Mathematical Logic 1, 1-93, 1970.
A. Mostowski. On a generalization of quantifiers. Fundamenta Mathematicae 44, 1236, 1957.
K. Schlechta. Defaults as generalized quantifiers. Journal of Logic and Computation 5, 473-494, 1995.
L. B. Vana; P. A. S. Veloso, & S. R. M. Veloso. Sobre l´ogicas para geralmente em ambiente de dedu¸c˜ao matural. In XXV Congresso da SBC (ENIA V): 622-630, 2005.
P. A. S. Veloso & A. W. Carnielli. Logics for qualitative reasoning. In D. Gabbay, S. Rahman, J. Symons & J. P. van Bendegem (eds..) Logic, Epistemology and the Unity of Science: 487-526, Kluwer Press, Dordretch, 2004.
P. A. S. Veloso, L. B. Vana & S. R. M. Veloso. Natural deduction strategies for ‘generally’. In Actas de la XI Conferencia de la Asociacio´n Espan˜ola para la Inteligencia Artificial : 173-182, Santiago de Compostela, 2005.
P. A. S. Veloso & S. R. M. Veloso. On ultrafilter logic and special functions. Studia Logica 78, 459-477, 2004.
S. R. M. Veloso & P. A. S. Veloso. On special functions and theorem proving in logics for ‘generally’. In
G. Bittencourt & G. L. Ramalho (eds.) Advances in Artificial Intelligence: 16th Brazilian Symposium in Artificial Intelligence (SBIA 2002) (LNAI 2507): 1-10, Springer-Verlag, Berlin 2002.
S. R. M. Veloso & P. A. S. Veloso. On logics for ‘generally’ and their relational interpretations In First World Congress on Universal Logic Handbook: 101-102, Montreux, 2005.
L. A. Zadeh, G. J. Klir & B. Yuan. Fuzzy Sets, Fuzzy Logic and Fuzzy Systems (Advances in Fuzzy Systems - Applications and Theory , Vol 6) World Scientific, 1996.
