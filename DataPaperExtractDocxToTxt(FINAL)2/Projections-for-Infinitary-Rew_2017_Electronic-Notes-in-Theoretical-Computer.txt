Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 332 (2017) 131–148
www.elsevier.com/locate/entcs
Projections for Infinitary Rewriting
Carlos Lombardi
Universidad Nacional de Quilmes – Argentina – carlos.lombardi@unq.edu.ar
Alejandro R´ıos
Universidad de Buenos Aires – Argentina – rios@dc.uba.ar
Roel de Vrijer
Vrije Universiteit Amsterdam – The Netherlands – r.c.de.vrijer@vu.nl

Abstract
Proof terms in term rewriting are a representation means for reduction sequences, and more in general for contraction activity, allowing to distinguish e.g. simultaneous from sequential reduction. Proof terms for finitary, first-order, left-linear term rewriting are described in [15], ch. 8. In a previous work [12] we defined an extension of the finitary proof-term formalism, that allows to describe contractions in infinitary first-order term rewriting, and gave a characterisation of permutation equivalence.
In this work, we discuss how projections of possibly infinite rewrite sequences can be modeled using proof terms. Again, the foundation is a characterisation of projections for finitary rewriting described in [15], Sec. 8.7. We extend this characterisation to infinitary rewriting and also refine it, by describing precisely the role that structural equivalence plays in the development of the notion of projection. The characterisation we propose yields a definite expression, i.e. a proof term, that describes the projection of an infinitary reduction over another.
To illustrate the working of projections, we show how a common reduct of a (possibly infinite) reduction and a single step that makes part of it can be obtained via their respective projections. We show, by means of several examples, that the proposed definition yields the expected behavior also in cases beyond those covered by this result. Finally, we discuss how the notion of limit is used in our definition of projection for infinite reduction.
Keywords: infinitary term rewriting, proof terms, permutation equivalence, projection

Introduction
The general scope of this article is infinitary, first-order, left-linear term rewriting, with strong convergence as the criterion for limits of infinite reductions.
The same principles and notions used to study sequences of numbers, or more generally, of points in a topological space, can be applied to reduction sequences (which are sequences of rewriting steps), and particularly to inﬁnite ones. By adapting the notions of limit and convergence, a target term can be determined for some infinite sequences. Such targets are, usually, infinite terms.

http://dx.doi.org/10.1016/j.entcs.2017.04.009
1571-0661/© 2017 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

The possibility of infinite reduction sequences having targets leads to the realm of inﬁnitary rewriting. It is natural to wonder whether the notions and results known for finite rewriting have extensions in the infinitary setting. Several results, both positive and negative, appear in the literature of the last 25 years [4], [8], [15]. The notion of projecting a reduction sequence over another, coinitial, one, has been extensively studied and finds its origin in a key lemma for confluence of lambda calculus and orthogonal term rewriting, the Parallel Moves Lemma [3], [2], [15]. Projections may be used to formulate stronger versions of confluence 1 . Given two
δ	γ
coinitial sequences δ and γ, where t −→ s and t −→ u, a common reduct of s and u
can be obtained by applying to them the projection of γ over δ, and that of δ over γ, respectively. This statement can be further strengthened using characterisations of permutation equivalence of reductions. If we use the notation δ/γ for the projection of δ over γ, ≈ for permutation equivalence and an infix colon ; for concatenation of reductions, then a stronger variant of confluence can be stated as follows:
δ ; γ/δ  ≈ γ ; δ/γ
The aim of this article is to present some preliminary definitions and results re- lated to projections, taken from our ongoing work on infinitary permutation equiv- alence. More in particular, our goal is to define projection in such a way that an explicit expression is obtained, representing the projection of an infinitary reduc- tion over another. We also want to find out to which extent such a characterisation involves the notion of limit.
To this end, we use the representation of infinitary rewriting by means of proof terms given in [12], which extends that given for finitary, first-order, left-linear term rewriting in [15]. A proof term is an expression, namely a term, that describes a reduction. As a matter of fact, something more general: any combination of simultaneous (i.e. multistep) and sequential reduction can be denoted by a proof term. Composition, or concatenation, of reductions is represented in the proof term formalism by a binary symbol. An infix dot is used, so that the composition of (the reductions denoted by) the proof terms ψ and φ is noted ψ · φ. Infinitary permutation equivalence is modeled by equational logic applied to proof terms.
The study of equivalence between reductions in [15] includes a characterisation of projection of one reduction over another, by means of the binary operation / defined between proof terms. That is, if ψ and φ are proof terms, then ψ/φ is a proof term that represents the projection of ψ over φ. The definition of the projection operation is given modulo structural equivalence, a subrelation of permutation equivalence that is specific for the proof term formalism. Therefore, some details about how to obtain the proof term corresponding to a projection are left open in that definition.
Results and discussion
We give a definition of projections for infinitary rewriting, which extends and refines that given in [15] for the finitary case. The refinement consists in specifying

1 The study of infinitary confluence is not a mere extension of the results known for the finitary case. E.g., the infinitary counterpart of the Newman lemma does not hold, cfr. [7,10].

some of the permutation-equivalence transformations that are needed in order to compute projections.
We show a partial confluence result about this definition. Given a (possibly infinite) reduction ψ and one of its constituent steps, let us call it φ, such that the step can be performed on the source of ψ, we prove that ψ · (φ/ψ) ≈ φ · (ψ/φ). This statement corresponds to the strengthened variant of confluence described earlier, as expressed by means of proof terms. We prove this result not in full generality. The minimal requirement on the step φ would be that it can already be performed in the source term of the proof term ψ, that is, that it does not depend on any previous step in the reduction represented by ψ. This requirement is strengthened in the sense that it not only holds for φ, but that, moreover, this is in some sense evident, just from the syntactic form of the proof term ψ.
This restriction, made specifically for this exploratory paper, has a twofold mo- tivation. Firstly, it keeps matters simple, so that they can be clearly explained. Generalisations can be obtained, but they require more complicated techniques. Secondly, it turns out that in our work on infinitary standardisation, a major mo- tivation for our interest in projections, nothing more is needed.
We show that our definition behaves as expected in some cases that extend the scope of the proven property, by means of several examples. We remark that in many cases the computation of the (proof term representing the) projection uses the notion of limit only to obtain the source or target term of a proof term; limits are not needed in order to reason specifically about projections. This includes computations of the projection of an infinite reduction over a finite one, and conversely, of a finite reduction over an infinite one.
We point out that limits are needed though, in some finite-over-infinite cases, related to inﬁnitary erasure, and also to compute infinite-over-infinite projections.
Structure of the paper
In Section 2, we give the needed definitions about infinitary rewriting and the proof term model. After a preliminary discussion in Section 3, we introduce the definition of projection in Section 4, analyzing it through several examples, and we state and prove our partial confluence result in Section 5. In Section 6, we explore cases where the explicit mention of limits in the definition of projection cannot longer be avoided. Finally, some preliminary conclusions of this work-in-progress, and possible directions for future research, are given in Section 7. An extended version [13] includes the omitted proofs, and also some additional material regarding the formal definition of projections.
Preliminaries
We briefly introduce infinitary rewriting by means of the TRS with signature
{a/0,f/1, g/1, k/1} and the rules f (x) → g(x), g(x) → k(x). Consider the term fn(a) for some n < ω. In the tree rendering of this term, a sequence of n oc- currences of f precedes the occurrence of a. An inﬁnite sequence of chained f symbols represents an inﬁnite term, which we denote as fω. For each n < ω, this

linear tree has an occurrence of f at depth n. This term is the source of the in- ﬁnite reduction sequence fω → g(fω) → g2(fω) ... gn(fω) → gn+1(fω)    Note
that the infinite sequence formed by the targets of the successive prefixes of this reduction, namely ⟨g(fω), g2(fω),... gn(fω) .. .⟩, converges with gω as limit. Addi- tionally, the sequence given by the depth (distance to the root) in which each step is performed, is simply ⟨0, 1, 2,...n.  ⟩, so that it tends to infinity. Such a reduction
sequence is considered as (strongly) convergent, having gω as target. In turn, it can be further extended from this target, leading to the following reduction sequence fω → g(fω) → g2(fω) → ... gω → k(gω) → k2(gω) →   kω, whose length is ω ∗ 2.
These simple examples show that the application of the notions of limit and convergence to the study of reduction sequences, lies in the foundation of infinitary term rewriting.
Infinitary term rewriting allows to rigorously define infinite terms and convergent infinite reductions, and study their properties. We refer to Chapter 12 in [15] and to [10] for the basic definitions. Here we just remark that we adopt the strong convergence criterion: for a transfinite rewrite sequence to be convergent, we require the depths of the successive steps to tend to infinity at each limit ordinal.
Projections of possibly infinite reductions are also defined in [8], and in a similar way, in [15], Chapter 12; our work proposes an alternative approach to that subject, via proof terms. Proof terms for term rewriting were introduced in [15], Chapter 8 and have been adapted to the infinitary setting in [12] and [11].
The idea motivating the definition and application of proof terms is to denote the reductions of some calculus as terms over an extended signature. For each reduction rule in the original TRS, a rule symbol is introduced. The arity of a rule symbol coincides with the number of different variables occurring in the left-hand side of the rule it represents. E.g., the signature of proof terms for a first-order TRS T including the rules f (x) → g(x), j(m(x), m(y)) → k(x) and g(x) → k(x) adds the rule symbols μ/1, ρ/2 and ν/1.
The initial stage in the definition of infinitary proof terms, as given in [11,12], is the set of inﬁnitary multi-steps, i.e., the finite or infinite terms over the sig- nature extended with rule symbols. Multi-steps with exactly one occurrence of a rule symbol denote single reduction steps, e.g. μ(a) : f (a) → g(a), g(ρ(a, b)) : g(j(m(a), m(b))) → g(k(a)). We identify such proof terms as one-steps. With more occurrences of rule symbols, we denote multi-steps, like j(μ(a), μ(b)) : j(f (a),f (b)) → j(g(a), g(b)), ρ(μ(a), b) : j(m(f (a)), m(b)) → k(g(a)). A multi- step can be infinite, and even contain infinitely many rule symbol occurrences, as
e.g. μω : fω → gω.
The beginning and end terms of the corresponding reductions are called the source and target of the proof term. For the proof terms considered so far, they can be obtained via rewriting in two companion TRSs, denoted as SRC and TGT respectively. For each rule symbol ρ : l → r, SRC includes a rule ρ(x1,.  , xm) →
l[x1,..., xm] and TGT a rule ρ(x1,..., xm) → r[x1,..., xm]. Source and target of a proof term are its normal forms in SRC and TGT , respectively. Of course there are the questions of existence and uniqueness. First note that both SRC and TGT

have unique normal forms, since they are orthogonal infinitary TRSs. It is also not hard to verify that SRC enjoys infinitary strong normalisation (SN∞). Contrarily, TGT does not enjoy even infinitary weak normalisation (WN∞) if the TRS includes collapsing rules. We conclude that the source of an infinitary multi-step ψ is always uniquely defined. The target is only defined if ψ is WN∞, but if so, it is also unique. If ψ is not WN∞ for TGT , then we say that tgt(ψ) is undefined.
The set of redexes in src(ψ) corresponding to the rule symbol occurrences in ψ admits at least one convergent development (respectively, all developments are convergent) precisely if ψ is WN∞ (respectively SN∞) in the TRS TGT . An infinitary multistep is called convergent, if its target can be computed.
To complete the definition of the set of finitary proof terms, we add a new binary function symbol · (written infix), expressing concatenation, or composition, of reductions. Just to give a simple example, the proof term f (μ(a)) · f (ν(a)) denotes the two-step reduction f (f (a)) → f (g(a)) → f (k(a)). The same reduction is represented by the proof term f (μ(a) · ν(a)). Not all terms over the thus extended signature are valid proof terms though, but only those that can be constructed starting from the infinitary multi-steps by the following three inductive clauses.
First, closure under function or rule symbols: if ψ1,..., ψn are proof-terms, then so are f (ψ1,..., ψn) and μ(ψ1,..., ψn). Source and target terms are defined as expected, e.g. src(μ(ψ1,..., ψn)) = l[src(ψ1),..., src(ψn)], where μ : l → h.
Secondly, binary composition: if ψ, φ are proof terms, then so is ψ · φ, provided that tgt(ψ)= src(φ). This presupposes convergence of ψ. The proof term ψ · φ is convergent iff φ is. We define src(ψ · φ)= src(ψ) and tgt(ψ · φ)= tgt(φ).

Thirdly, inﬁnite composition: the term correspond-
ing to the figure is a proof term, if ψ0, ψ1, ψ2,... are, provided that for each i < ω we have convergence of ψi and tgt(ψi) = src(ψi+1). A linear rendering would be ψ0 · (ψ1 · (ψ2 · .. .)). We use ·i<ω ψi as shorthand for this proof term.
·
ψ ,7 z· 
ψ1	· zz
   .
ψ	.

For ψ = ·i<ω ψi, we define src(ψ)= src(ψ0), and declare that ψ is convergent
iff the sequence ⟨mind(ψi)⟩i<ω tends to infinity. Here mind stands for the minimal activity depth of a proof term. E.g., mind(f (μ(a)) · μ(g(a))) = 0, since the denoted activity includes a root step; while mind(m(f (μ(a))) · m(μ(g(a)))) = 1 as the denoted steps are at depths 2 and 1 resp.. Cfr. [11] for details. If ·i<ω ψi is convergent, then tgt(ψ) is defined as the limit of the sequence ⟨tgt(ψi)⟩i<ω.
By the above definition of proof terms an infinite composition is also a binary composition: ·i<ω ψi = ψ0 · ( ·i<ω ψi+1). To preserve unique constructibility, in- finitary proof terms are defined in [11] in layers corresponding to ordinal numbers, such that each proof term has a unique layer. Particularly, the (unique) layer of ψ is a limit ordinal iff ψ is an infinite composition.
Permutation equivalence (noted ≈ henceforth) relates the proof terms that de- note the same reduction in different ways, regarding parallelism/nesting degree, sequential order, and/or localisation. This relation is defined, in [11,12], as the congruence generated by the following seven basic equivalences:

(IdLeft)	src(ψ) · ψ ≈ ψ
(IdRight)	ψ · tgt(ψ) ≈ ψ
(Assoc)	ψ · (φ · χ) ≈ (ψ · φ) · χ
(Struct)	f (ψ1,..., ψm) · f (φ1,..., φm) ≈ f (ψ1 · φ1,..., ψm · φm) (InfStruct)		·i<ω f (ψ1,..., ψm) ≈ f ( ·i<ω ψ1,..., ·i<ω ψm)
i	i	i	i
(OutIn)	μ(ψ1,..., ψm) ≈ μ(s1,..., sm) · r[ψ1,..., ψm]
(InOut)	μ(ψ1,..., ψm) ≈ l[ψ1,..., ψm] · μ(t1,..., tm) where μ : l → r, si = src(ψi) and ti = tgt(ψi) in (InOut) and (OutIn), augmented with the following equational logic rules:

ψi ≈ φi	for all i < ω 


·i<ω ψi  ≈	·i<ω φi
InfComp

for all k < ω
exists χk, ψj , φj
j
k
φ ≈1 χk · φj
mind(ψj ) > k mind(φj ) > k 

Lim

k	k	k	k
ψ  ≈ φ
Here ≈1 is the congruence generated by the seven basic equations, augmented by
InfComp, but excluding the Lim-rule itself.
As a first example of proof terms including composition, and also of permutation equivalence, we consider the proof terms fνa · μka and μga · gνa (we omit some unary symbol parentheses in the sequel). These proof terms represent the two possible reduction sequences that transform the source term fga into gka. Note that simultaneous reduction of a set of coinitial redexes is given, in the proof-term model, a specific denotation. In this case, the proof term μνa denotes, specifically, the simultaneous step fga −◦→ gka.
We prove that the three given proof terms are permutation equivalent, as fol- lows. By (InOut) and (OutIn) we obtain μνa ≈ fνa · μka and μνa ≈ μga · gνa. Symmetry and transitivity, which are included in the generated congruence, yield fνa · μka ≈ μga · gνa. Note that the (InOut) and (OutIn) equations model the permutation of a head step w.r.t. internal activity.
In turn, the (Struct) equation allows to reason about activity lying inside a ﬁxed context, as in the following permutation equivalence judgement: mfνa · mμka ≈ m(fνa · μka) ≈ mμνa ≈ m(μga · gνa) ≈ mμga · mgνa where the first use of (Struct) enables the permutation of steps, and the second one yields the equivalence between reduction sequences. Here the fixed context is m(2).
The next example involves infinite composition. Consider ψ = ψ1 · ψ2 where ψ1 = ·i<ω gi(μ(fω)) and ψ2 := ·i<ω ki(ν(gω)), and φ = ·i<ω χi where χi = ki(μ(fω) · ν(fω)). The proof terms ψ and φ denote, respectively, the reduction sequences fω → gfω → g2fω → gω → kgω → k2gω → kω and fω → gfω → kfω → kgfω → k2fω → kω, that are two different ways to perform the transformation of each occurrence of f in fω to g and subsequently to k, by means of the μ- and ν-rules respectively.
Using the augmented congruence, including the Lim rule, the assertion ψ ≈ φ

can be justified. To start, note that ψ1 = μfω · ·i<ω g(giμfω) just by definition of infinite compositions. In turn, (InfStruct) yields ·i<ω g(giμfω) ≈1 g( ·i<ω giμfω)= g(ψ1). Applying a similar argument on ψ2, and then (Assoc), we obtain ψ ≈1 μfω · (g(ψ1) · νgω) · k(ψ2). Then, a permutation of steps based on (InOut) and (OutIn) yields ψ ≈1 μfω · (νfω · k(ψ1)) · k(ψ2), so that we get ψ ≈1 (μfω · νfω) · k(ψ1 · ψ2)= χ0 · k(ψ), by (Assoc) and (Struct). For any n < ω, iterating over the whole argument yields ψ ≈1 χ0 · χ1 · ... · ... · χn · kn+1(ψ). On the other hand, it is straightforward to obtain φ ≈1 χ0 · χ1 · ... χn · ·i<ω χn+1+i. Hence Lim yields ψ ≈ φ.
This example shows the relevance of the Lim rule for permutation equivalence judgements. Proof terms ψ and φ can be proven ≈1 -equivalent up to an arbitrary activity depth level n: we have ψ ≈1 χ0 · ... · χn · ψj and φ ≈1 χ0 · ... · χn · φj, where mind(ψj) > n and mind(φj) > n. So, ψ and φ can be transformed into forms whose difference, represented by ψj and φj, can be made arbitrarily irrelevant (with minimum activity depth as the relevance measure). It is not possible to obtain ψ ≈1 φ, however. The Lim rule allows taking limits to conclude ψ ≈ φ.
Similarly, the infinite multistep μω and the infinite composition ·i<ω gn(μ(fω)) denote, respectively, the simultaneous and sequential contraction of the infinite set of μ-redexes present in the source term fω. In fact, the latter corresponds to the reduction sequence fω → g(fω) → g2(fω) → ... → gω. Other sequential reductions of the same set of redexes are denoted by specific infinite composition proof terms. As an example, the sequence fω → f (g(fω) → g2(fω) → g2(f (g(fω)) → g4(fω) →
→ gω can be faithfully denoted by ·i<ω g2i(f (μ(fω))) · g2i(μ(g(fω))). Again, all these proof terms can be proven permutation equivalent. In the infinite case, the corresponding equivalence judgement makes use of the Lim equational rule.
In [12] we showed that any convergent reduction sequence can be given a precise denotation as a stepwise proof term, i.e., a proof term constructed from one-steps, by only using binary and infinitary composition. Moreover, this representation is unique modulo the associativity of the composition symbol. Note that e.g. (μ(f (a))· ν(f (a))) · k(μ(a)) and μ(f (a)) · (ν(f (a)) · k(μ(a))) are different, albeit equivalent, proof terms.
We gave in [12] also an alternative proof of the compression property for con- vergent transfinite rewrite sequences, using their representations as proof terms. In fact, we proved a strong version: the compressed (i.e. having length at most ω) reduction sequence is permutation equivalent (and not only coincident in source and target) to the original one. The general argument of our compression proof reflects a remark in [9]: compression can be considered as a degenerate form of standardisation. Based on this idea, we are currently working on standardisation results for infinitary rewriting, also based on the representation of reductions by means of proof terms.
Finally, we remark that our definition of the set of proof terms, as well as our characterisation of permutation equivalence, are based on inductive notions and techniques. In particular, inductive reasoning can be used on the set of occurrences in a term, considering their distance to the root which is always finite. Also, trans-

finite induction can be used to reason about infinite reduction sequences, since their length can always be expressed as an ordinal.
An alternative approach that incorporates coinductive techniques, appears in [6]. There, convergent reduction sequences are represented by coinductively defined trees, and the reduction relation is characterised through a combination of induc- tive and coinductive fixed points. The latter characterisation is formalised in Coq, leading to a Coq-certified proof of compression. The approach is also extended to study infinitary equational reasoning. On the other hand, their proposal does not describe the space of transfinite reductions in full detail. In particular, it does not allow different descriptions of sequential and simultaneous reduction, and the order in which disjoint steps are performed cannot be expressed. Neither permutation equivalence nor projections are addressed 2 . Hence, we perceive this work to be complementary with our characterisation of infinitary rewriting.
Finitary and infinitary projections
Let δ be a reduction sequence, and γ a coinitial step. The following commutation diagram describes the argument of the Parallel Moves Lemma (PML).
δ


`	δ˛/¸γ	x
This diagram establishes a particular confluence property: a common target can be reached by performing γ/δ and δ/γ, after δ and γ respectively.
If δ is an inﬁnite reduction sequence, the diagram gets infinite as well:
δ


`	δ˛/¸γ	x
leading to an infinite variant of PML. A concrete example follows, using the rule
f (x) → g(x) and omitting parentheses for unary symbols
δ
¸ fω 	 gf¸ω 	 gf¸gf ω 	 gf¸g2fω	x`gf gnfω 	 gf¸gn+1fω 	 	>>> gfgω˛
γ

fgfω 	 g2¸f ω 	 g3¸f ω 	 g4¸f ω	gn+2fω 	 gn¸+3f ω 	    >>> gω
γ/δ

`	δ˛/¸γ	x
Note that each step in δ has a nonempty projection after (the respective projec- tion of) γ. The projection of γ after δ can be naturally defined as the limit of the projections after its successive prefixes. In turn, the projection of δ after γ can be defined as the limit of the projections of the successive prefixes of the former. Ob- serve that the notion of limit is relevant for the definition of projections, whenever

2 A limited form of permutation equivalence is currently being studied [5].

infinite reductions are involved.
In the sequel, we define the projection of one reduction over another as a binary operation on (their representation as) proof terms. As permutation equivalence is also characterized on proof terms, we can express in this formalism the stronger version of the confluence criterion suggested by the PML described in the introduc- tion, as follows: ψ · φ/ψ ≈ φ · ψ/φ, where ψ and φ represent δ and γ resp.. This statement also expresses the idea of orthogonality between ψ and φ in a way independent from the syntax of terms, or more generally, the form of the objects being rewritten. As such, it is closely related to the axiom called PERM in [14], and Semantic orthogonality in [1].
In the next section, we extend to the infinitary realm a definition given in [15], showing that the role of limits in computing projections is very restricted in some cases, as in the example just given. The strong confluence result is proved, for a very limited case, in Section 5.

Projection through proof terms
The projection of a reduction over another is defined in [15] Ch. 8, for finitary term rewriting, as the operation on proof terms defined as follows.
μ(φ1,..., φm) / μ(ψ1,..., ψm) = h[φ1/ψ1,..., φm/ψm]
μ(φ1,..., φm) / l[ψ1,..., ψm] = μ(φ1/ψ1,..., φm/ψm)
l[φ1,..., φm] / μ(ψ1,..., ψm) = h[φ1/ψ1,..., φm/ψm]
f (φ1,..., φm) /f (ψ1,..., ψm) = f (φ1/ψ1,..., φm/ψm)
(φ · ψ)/χ = φ/χ · ψ/ (χ/φ) χ/(φ · ψ) = (χ/φ) /ψ 
where μ : l → h. We give a simple example, using the rules: ρ : j(g(x), y) → j(x, y), μ : f (x) → g(x), π : a → b, τ : c → d, σ : m(x) → n(x).
j(μ(π), m(c)) · ρ(b, σ(c)) / j(f (π), σ(τ ))
= j(μ(π), m(c))/j(f (π), σ(τ )) · ρ(b, σ(c)) / (j(f (π), σ(τ ))/j(μ(π), m(c)))
= j(μ(b), n(d)) · ρ(b, σ(c)) / j(g(b), σ(τ ))
= j(μ(b), n(d)) · ρ(b/b, σ(c)/σ(τ ))
= j(μ(b), n(d)) · ρ(b, n(d))
The projection denotes the steps in j(μ(π), m(c)) · ρ(b, σ(c)) that are not performed in j(f (π), σ(τ )), namely the μ and ρ-steps, applied on the target of the latter proof term. We remark that in the last step of this example, we obtain b/b = b by applying the fourth clause with m = 0.
The projection operation is defined modulo (the relation generated by) the equa- tion (Struct). The following example shows why this is required.
ρ(m(c), b) / j(g(σ(c)) · g(n(τ )), b) = ρ(m(c), b) / j(g(σ(c) · n(τ )), b)
= ρ(m(c) / (σ(c) · n(τ )), b/b)	= ρ((m(c)/σ(c))/n(τ ), b)	=	ρ(n(d), b) Observe that j(g(σ(c)) · g(n(τ )), b) must be transformed into j(g(σ(c) · n(τ )), b) in order to apply the second clause in the definition of projection.

In the following, we give a variant of the definition of the projection operation, aiming at two goals. First, to produce a more precise definition, making the use of structural equivalence explicit. Secondly, to obtain proof terms for projections involving inﬁnite reductions, at least in some cases. For the first goal we establish the necessity, in some cases, to transform a proof term into a form that makes a fixed reduction prefix explicit. This is the role of structural equivalence in the projection, as shown in the last developed example w.r.t. the fixed prefix j(g(2), 2).
Let C be a context having a finite number of holes, and ψ a proof term. We say that C is a ﬁxed preﬁx for ψ, iff any of the following items apply:
C = 2
ψ = f (ψ1,..., ψm),C = f (C1,..., Cm), and Ci is a fixed prefix for ψi for all i
ψ = ψ1 · ψ2 or ψ = ·i<ω ψi, and C is a fixed prefix for ψi for all i
Observe that C being a fixed prefix for ψ implies that C is composed by func- tion (opposed to rule and dot) symbols only. C being a fixed prefix is stable by permutation equivalence.
Let C be a context and ψ a proof term, such that C is a fixed prefix for ψ. We define the explicit ﬁxed-preﬁx form of ψ w.r.t. C, notation ψ γ C, as follows:
ψ γ 2 := ψ
f (ψ1,..., ψm) γ f (C1,..., Cm) := f (ψ1 γ C1,..., ψm γ Cm)
(ψ1 · ψ2) γ f (C1,..., Cm) := f (ψ11 · ψ21 γ C1,..., ψ1m · ψ2m γ Cm)
where ψi γ f2 = f (ψi1,..., ψim) for i = 1, 2 ( ·i<ω ψi) γ f (C1,..., Cm) := f ( ·i<ω ψi1 γ C1,..., ·i<ω ψim γ Cm)
where ψi γ f2 = f (ψi1,..., ψim) for all i < ω 
In this definition, as well as in the sequel, f 2 denotes the context f (2,..., 2). We use also l2 and h2, where μ : l → h. Observe that j(g(σ(c)) · g(n(τ )), b) γ j(g(2), 2)= j(g(σ(c)) · g(n(τ )) γ g(2),bγ 2)= j(g(σ(c) · n(τ ) γ 2), b)= j(g(σ(c) · n(τ )), b), the form needed to compute the projection in the last given example.
We say that a proof term ψ includes head steps, if ψ = μ(ψ1,..., ψm), or either
ψ = ψ1 · ψ2 or ψ = ·i<ω ψi, and some ψn includes head steps.
Given two coinitial proof terms ψ and φ, we define the projection of ψ over φ, notation ψ/φ, as the operation given by the following clauses, considered in order.
src(ψ) /ψ := tgt(ψ)	ψ/ src(ψ) := ψ
μ(φ1,..., φm) / μ(ψ1,..., ψm) := h[φ1/ψ1,..., φm/ψm]
μ(φ1,..., φm) /ψ := μ(φ1/ψ1,..., φm/ψm)	if l2 is a fixed prefix for ψ
φ/ μ(ψ1,..., ψm) := h[φ1/ψ1,..., φm/ψm]	if l2 is a fixed prefix for φ
(φ · ψ) /χ := φ/χ · ψ/ (χ/φ)
if φ · ψ includes head steps and χ = μ(χ1,..., χm), f (χ1,..., χm) or ·i<ω χi
χ/ (φ · ψ) := (χ/φ) /ψ	if either φ · ψ or χ include head steps
φ/ψ := f (φ1/ψ1,..., φm/ψm)	if f 2 is a fixed prefix for both φ and ψ
where in clauses 2, 3 and 4, μ : l → h; and also ψ γ l2 = l[ψ1,..., ψm] in clause 3,
φγ l2 = l[φ1,..., φm] in clause 4, and analogously for φγf 2 and ψγ f 2 in clause 7.

We remark that clauses 5 and 6 apply to both binary and infinitary composition.
We add a few comments on this definition of projection. First, when using the definition we will always consider proof terms modulo the relation generated by the equations (IdLeft), (IdRight) and (Assoc), the so-called reduction identities in [15]. Secondly, we assume that ψ and φ are mutually orthogonal, even if the underlying TRS is not. This implies in particular that if φ = μ(φ1,..., φm) where μ : l → h, and ψ does not include head steps, then l2 is a fixed prefix for ψ. Finally, we note that clause 1 is needed to avoid infinite iteration if src(ψ) is an inﬁnite term. Otherwise, e.g. to compute fω/fω clause 7 would have to be applied ad infinitum. We show some simple cases of projections involving infinite proof terms, using the rule μ : f (x) → g(x). Omitting parentheses for unary function symbols,we have
e.g. fμω/μfμfω = g(μω/fμfω) = gμ(μω/μfω) = gμg(μω/fω) = gμgμω, applying clauses 4, 3, 2 and 1 respecively. We can also obtain the projection over an infinite reduction: μfμfω/fμω = μ(fμfω/μω)= μg(μfω/μω)= μgg(fω/μω)= μgω.
Sequential reductions lead to more laborious projection computations:
·i<ω fgiμfω / (μfω · gfμfω)
= ( ·i<ω fgiμfω/μfω) / gfμfω	clause 6
= g( ·i<ω giμfω/fω) / gfμfω	clause 4
= g( ·i<ω giμfω) / gfμfω	clause 1
= g( ·i<ω giμfω /fμfω)	clause 7
= g((μfω/fμfω) · ( ·i<ω gi+1μfω / (fμfω/μfω)))	clause 5
= g(μgfω · ( ·i<ω gi+1μfω / gμfω))
= g(μgfω · g( ·i<ω giμfω / μfω))	clause 7
= g(μgfω · g(μfω/μfω · ( ·i<ω gi+1μfω / (μfω/μfω)))) clause 5
= g(μgfω · g(gfω · ( ·i<ω gi+1μfω / gfω)))
= g(μgfω · g(gfω · ·i<ω gi+1μfω))	clause 1
= g(μgfω · g( ·i<ω gi+1μfω))	reduction identities
Note that the explicit fixed-prefix form of an infinite composition is used several times, namely, in the use of clause 4 and both uses of clause 7.
By relating the given examples, we observe that simultaneous and sequential descriptions of the same reduction lead to permutation equivalent projections. In this case we have gμgμω ≈ g(μgfω · g( ·i<ω gi+1μfω)), as we prove in the following. Note that for any n < ω, using just (Assoc) we obtain ·i<ω giμfω ≈1 μfω · gμfω · ... · gnμfω · ·i<ω gi+n+1μfω. On the other hand, (OutIn) and (Struct) yield μω ≈1 μfω · gμω ≈1 μfω · g(μfω · gμω) ≈1 μfω · gμfω · g2μω, so that a simple iteration entails μω ≈1 μfω · gμfω · ... · gnμfω · gn+1μω. Hence Lim allows to assert ·i<ω giμfω ≈ μω. In turn, gμgμω ≈ g(μgfω · g2μω) while g(μgfω · g( ·i<ω gi+1μfω)) ≈ g(μgfω · g2( ·i<ω giμfω)), where (InfStruct) is used for the latter assertion. Hence, congruence allows to conclude.
Finally we remark that in the given examples, projections involving an infinite proof term are successively decomposed, until clause 1 can be used to obtain a final expression for the projection. Limits are only indirectly involved, to compute source or target terms in the uses of that clause. In Section 6 we discuss some examples

of projections where limits should be used in a more essential way.
A partial confluence property
The definition of infinitary projections given in Section 4 allows to study the state- ment ψ · (φ/ψ) ≈ φ · (ψ/φ), that we described in Section 3. Let us verify this property for the first example of Section 4, where ψ = f μω and φ = μfμfω, and the projections are ψ/φ = gμgμω and φ/ψ = μgω. We have
ψ · φ/ψ = f μω · μgω  ≈ μω  ≈ μfω · gμω	(InOut), (OutIn)
≈ μfω · g(f μω · μgω)	(InOut)
≈ μfω · g(fμfω · fgμω · μgω)  (OutIn), (Struct)
≈  μfω · gfμfω · g(fgμω · μgω) (Struct)
≈  μfμfω · gμgμω	(OutIn), (InOut)
= φ · ψ/φ
This section is devoted to proving the above mentioned result in a very limited case; namely, when φ denotes a single step on the source term of ψ, that is actually included in ψ. Moreover, we ask φ to denote a step easily extractable from ψ. The forthcoming statement covers e.g. this case: ψ = μω or ψ = ·i<ω giμfω, and φ = μfω. The example just described is not comprised: φ denotes two (simultaneous) steps , and one of them (the outermost one) is not included in ψ.
Easily extractable steps
Roughly speaking, a step included in a proof term ψ, that is, a rule symbol occur- rence in ψ, is easily extractable if there are no other rule symbols in ψ denoting activity performed before that step, that affect positions in its pattern (that is, in the left-hand side pattern that is replaced by that step) or above it. E.g., if μ : f (x) → g(x), ν : g(x) → k(x), and π : a → b, then the only easily extractable step in μ(a) · ν(π) is the μ occurrence, since it denotes a step that is performed be- fore both the ν- and the π-steps and affects the root position, the same as the ν-step, and above that corresponding to the π-step. On the other hand, both the μ and the π occurrences are easily extractable in the equivalent μ(π) · ν(b), since they are per- formed simultaneously. We note that function symbols do not affect extractability,
e.g. all the rule symbol occurrences are easily extractable in j(μ(π), ν(c)).
Formally, we define the set of easily extractable rule symbol occurrences in a proof term ψ, notation ers(ψ), as a set of pairs of positions. The left component is the contraction position, i.e. the position in src(ψ) where the step can be applied. The right component is the position of the rule symbol occurrence in the proof term. E.g., if ψ = μ(a) · ν(π), the only element of ers(ψ) is ⟨δ, 1⟩: the μ occurrence at position 1 in ψ can be applied at position δ on src(ψ)= f (a).
As the material of this section is deeply based on position analysis, we define an analogous to the fixed-prefix context property, given in terms of positions. Let P be a set of positions and ψ a proof term. We say that ψ respects P iff the latter is finite and prefix-closed, and any of the following applies

ψ is an infinitary multistep, P ⊆ pos(ψ) and ψ(p) ∈ Σ for all p ∈ P .
ψ = ψ1 · ψ2, or ψ = ·i<ω ψi, and all ψi respect P
ψ = f (ψ1,..., ψm) and either P = ∅ or ψi respects P |i for all i
ψ = μ(ψ1,..., ψm) and P = ∅
where P |i := {p / ip ∈ P}, and ψ is assumed not a multistep in the last two clauses. It is easy to verify that: (1) for any proof term ψ and context C, C is a fixed prefix for ψ iff ψ respects the set of non-hole positions of C, (2) if ψ respects P , then src(ψ)(r)= tgt(ψ)(r) for all r ∈ P , and (3) permutation equivalence preserves
the respects property. Cfr. [11], Sec. 5.5.
We now give the formal definition of ers.
ers(μ(ψ1,..., ψm)) := {⟨δ, δ⟩} ∪ {⟨r1r2, ip⟩ / ⟨r2, p⟩∈ ers(ψi) ∧ l(r1)= xi}
where μ : l → h
ers(f (ψ1,..., ψm)) :=  {⟨ir, ip⟩ / ⟨r, p⟩∈ ers(ψi)}
i
ers(ψ1 · ψ2) := {⟨r, 1p⟩ / ⟨r, p⟩∈ ers(ψ1)} ∪ {⟨r, 2p⟩ / ⟨r, p⟩∈ ers(ψ2)
∧ ψ1 respects {rj / rj < r}∪ (r · Ppos(ψ2(p)))}
ers( ·i<ω ψi) := {⟨r, 2j1p⟩ / ⟨r, p⟩∈ ers(ψj)
∧ ψi respects {rj / rj < r}∪ (r · Ppos(ψj(p)))} for all i < j 
where Ppos(μ)= {p ∈ l / l(p) ∈/ Var} and μ : l → h.
The set of easily extractable steps is restricted to keep the definition simple, avoiding non-trivial analysis of positions. E.g. in ψ = μ(a) · ν(π), the π-step, while not included in ers(ψ), could be performed on src(ψ)= f (a).
We verify that all easily extractable rule symbol occurrences are indeed ex- tractable (to the source of the proof term) rule symbol occurrences.
Lemma 5.1 Let ψ be a proof term, and ⟨r, p⟩∈ ers(ψ). Then ψ(p) is a rule symbol, say ψ(p)= μ, and src(ψ)|r = l[s1,..., sk] where μ : l → h.
Proof A simple induction on ⟨ψ, r⟩ suffices 3 . If ψ = μ(ψ1,..., ψm) and r = r1r2, recall that r1 /= δ, then we conclude by induction on ⟨ψi, r2⟩. If ψ = f (ψ1,..., ψm), so that r = irj, then induction on ⟨ψi, rj⟩ suffices to conclude.
Assume that ψ = ψ1 · ψ2. If p = 1pj, implying ⟨r, pj⟩∈ ers(ψ1), then IH applies to ⟨ψ1, r⟩. Recalling that src(ψ) = src(ψ1), the conclusions of the IH suffice to conclude. If p = 2pj, implying ⟨r, pj⟩∈ ers(ψ2), then IH on ⟨ψ2, r⟩ yields that ψ(p)= ψ2(pj)= μ, and also that src(ψ2)|r = tgt(ψ1)|r = l[t1,..., tk] for some t1,..., tk. In turn, ⟨r, 2pj⟩ ∈ ers(ψ) implies that ψ1 respects {rj / rj < r}∪ (r · Ppos(l)), so that src(ψ)|r = src(ψ1)|r = l[s1,..., sk].
If ψ = ·i<ω ψi, then an argument similar to that given for the previous case, where p = 2j1pj instead of p = 2pj suffices; an iteration over ⟨ψj—1,..., ψ0⟩ is required to verify src(ψ1)|r = l[s1,..., sk].	2
The elements of ers(ψ) correspond to the steps that can be extracted, i.e., applied to src(ψ). The following definition formalises the notion of applying a rule symbol
3 If ψ = μ(ψ1,..., ψm) or ψ = f (ψ1,..., ψm), then ψi is not smaller than ψ w.r.t. its ordinal number layer if ψ is a multistep; this is the reason to consider induction on pairs, adding r as the second component.

occurrence to a term. Let t be a term, r a position, and μ : l → h a rule, such that t|r = l[t1,..., tm]. We define the insertion of μ into t at position r as follows: irs(t, μ, r) := t[μ(t1,..., tm)]r.

Basic properties
In order to prove the main result of this section, some basic properties of explicit fixed-prefix forms, easily extractable steps, and projections are required. We will state these auxiliary results, along with some description. Their proofs, straightfor- ward once the proper induction principle is determined, are given in [13].
First, we verify that the explicit fixed-prefix forms of a proof term, as defined in Section 4, are equivalent to that proof term.
Lemma 5.2 Let ψ be a proof term, and C a context such that C is a ﬁxed preﬁx for ψ. Then ψ γ C = C[ψ1,..., ψm], and ψ ≈1 ψ γ C. Moreover, these proof terms are structurally equivalent, i.e., a permutation equivalence derivation exists whose conclusion is ψ γ C ≈1 ψ and where neither (InOut) nor (OutIn) are used.
The next result states that easily extractable steps are compatible with explicit fixed-prefix forms, where the contraction position does not change. E.g., consider ψ = m(f (π)) · m(μ(b)), so that ψγm(2)= m(f (π) · μ(b)). We have ⟨1, 21⟩∈ ers(ψ), denoting that the μ-step at position 21 is easily extractable to the position 1; note that src(ψ)= m(f (a)). The element of ers(ψ γ m(2)) for the same step is ⟨1, 12⟩. The position of the rule symbol changed, while the contraction position is the same.
Lemma 5.3 Let ψ be a proof term and f a function symbol, such that f 2 is a ﬁxed preﬁx for ψ, and r, p such that ⟨r, p⟩ ∈ ers(ψ). Then there exists q ∈ pos(ψ γ f 2) such that (ψ γ f 2)(q)= ψ(p) and ⟨r, q⟩∈ ers(ψ γ f 2).
The following lemmas state that projections behave as expected in two straight- forward cases: the projection of one step over a reduction that respects the set of pattern positions of the left-hand side of the corresponding rule; and the projection of one step over a reduction that includes that step.
Lemma 5.4 Let μ : l → h be a rule, r a position, and ψ a proof term, such that ψ respects {rj / rj < r}∪ (r · Ppos(μ)), src(ψ) |r = l[s1,..., sm], and consequently tgt(ψ)|r = l[t1,..., tm]. Then irs(src(ψ), μ, r) /ψ = irs(tgt(ψ), μ, r).
Lemma 5.5 Whenever ⟨r, p⟩∈ ers(ψ), we have irs(src(ψ), ψ(p), r) /ψ = tgt(ψ).

Main results
We prove that the projection behaves as expected, in the sense described at the beginning of this Section, i.e. that ψ · φ/ψ ≈1 φ · ψ/φ, in two situations in which φ is a one-step. Firstly, if ψ does not interfere with φ, that is, if the activity described by ψ neither overlaps nor embeds the step described by φ. Secondly, if φ is an easily extractable step for ψ.

Lemma 5.6 Let ψ be a proof term, μ : l → h a rule symbol, and r a position, such that ψ respects {rj / rj < r}∪ (r · Ppos(μ)) and src(ψ)|r = l[s1,..., sm]. Then irs(src(ψ), μ, r) · ψ/ irs(src(ψ), μ, r) ≈1 ψ · irs(tgt(ψ), μ, r)= ψ · irs(src(ψ), μ, r) / ψ; cfr. Lemma 5.4.
Proof We give only a sketch here, the full details can be found in [13]. The statement can be proved by induction on r.
If r = δ, then l2 is a fixed prefix for ψ, so that we can consider ψ γ l2 = l[ψ1,..., ψm]; let src(ψi) = si and tgt(ψi) = ti for all i.	It is easy to obtain irs(src(ψ), μ, r) = μ(s1,..., sm) and irs(tgt(ψ), μ, r) = μ(t1,..., tm).
Then irs(src(ψ), μ, r) · ψ/ irs(src(ψ), μ, r) = μ(s1,..., sm) · h[ψ1,..., ψm] ≈1
μ(ψ1,..., ψm) ≈1 l[ψ1,..., ψm] · μ(t1,..., tm).
If r = ir1, then f 2 is a fixed prefix for ψ for some f , so that we have ψ γ f 2 = f (ψ1,..., ψm).  If src(ψi) = si for all i, then irs(src(ψ), μ, r) = f (s1,..., irs(src(ψi), μ, r1),..., sm) and similarly for irs(tgt(ψ), μ, r). It turns out that IH can be applied on ψi which, along with structural equivalence, suffices to conclude.	2
Proposition 5.7 Let ψ be a proof term, and ⟨r, p⟩ ∈ ers(ψ).  Then irs(src(ψ), ψ(p), r) · (ψ/ irs(src(ψ), ψ(p), r)) ≈1 ψ ≈1 ψ · (irs(src(ψ), ψ(p), r)/ψ); cfr. Lemma 5.5.
Proof We proceed by induction on ⟨r, p⟩.
Assume that r = p = δ, so that ψ = μ(ψ1,..., ψm) and irs(src(ψ), ψ(p), r) = 
μ(src(ψ1),..., src(ψm)).	Say μ  :  l  →  h.	We have irs(src(ψ), ψ(p), r) ·
(ψ/ irs(ψ, ψ(p), r)) = μ(src(ψ1),..., src(ψm)) · h[ψ1/src(ψ1),..., ψm/src(ψm)] = μ(src(ψ1),..., src(ψm)) · h[ψ1,..., ψm] ≈1 ψ applying (OutIn) in the last step. Note that clause 2 applies to ψ/ irs(src(ψ), ψ(p), r).
Assume that ψ = μ(ψ1,..., ψm) where μ : l → h, and r /= δ. In this case, r = r1r2, p = ip2, l(r1) = xi, and ⟨r2, p2⟩ ∈ ers(ψi). Observe that irs(src(ψ), ψ(p), r) = l[src(ψ1),..., irs(src(ψi), ψi(p2), r2),..., src(ψm)].  IH on
⟨r2, p2⟩ entails irs(src(ψi), ψi(p2), r2) · (ψi / irs(src(ψi), ψi(p2), r2)) ≈1 ψi, implying in particular that tgt(ψi / irs(src(ψi), ψi(p2), r2)) = tgt(ψi). We have
irs(src(ψ), ψ(p), r) · (ψ/ irs(src(ψ), ψ(p), r))
= l[src(ψ1),..., irs(src(ψi), ψi(p2), r2),.	, src(ψm)]
μ(ψ1,..., ψi / irs(src(ψi), ψi(p2), r2),.	, ψm)
≈1 l[src(ψ1),..., irs(src(ψi), ψi(p2), r2),.	, src(ψm)]
l[ψ1,..., ψi / irs(src(ψi), ψi(p2), r2),.	, ψm]
μ(tgt(ψ),..., tgt(ψi),.	, tgt(ψm))
≈1 l[ψ1,..., irs(src(ψi), ψi(p2), r2) · (ψi / irs(src(ψi), ψi(p2), r2)),.	, ψm]
μ(tgt(ψ),..., tgt(ψi),.	, tgt(ψm))
≈1 l[ψ1,..., ψi,..., ψm] · μ(tgt(ψ),..., tgt(ψi),..., tgt(ψm))	≈1	ψ
by: definition of projection, where clause 3 applies to ψ/ irs(src(ψ), ψ(p), r) and clause 1 to assert ψj/src(ψj)= ψj if j /= i; (InOut); structural equivalence includ- ing (Struct) and (IdLeft); IH as described above; and finally (InOut).

Assume ψ = ψ1 · ψ2 is a binary composition that includes head steps. In this case p = jp1, src(ψ) = src(ψ1), ψ(p) = ψj(p1), and ⟨r, p1⟩ ∈ ers(ψj). Clause 5 applies to ψ/ irs(src(ψ), ψ(p), r), so that irs(src(ψ), ψ(p), r) · (ψ/ irs(src(ψ), ψ(p), r)) =
irs(src(ψ), ψ(p), r) · (ψ1 / irs(src(ψ), ψ(p), r)) · (ψ2 / (irs(src(ψ), ψ(p), r)/ψ1)).
If j = 1, then IH on ⟨r, p1⟩ yields irs(src(ψ), ψ(p), r) · (ψ1 / irs(src(ψ), ψ(p), r)) ≈1 ψ1, and Lemma 5.5 implies irs(src(ψ), ψ(p), r)/ψ1 = tgt(ψ1) = src(ψ2). Conse- quently, irs(src(ψ), ψ(p), r) · (ψ/ irs(src(ψ), ψ(p), r)) ≈1 ψ1 · (ψ2/src(ψ2)) = ψ.
If j = 2, recall that ψ1 respects {rj / rj < r} ∪ (r · Ppos(ψ(p)).  More- over, Lemma 5.1 implies that src(ψ) |r = l[s1,..., sm]. Then Lemma 5.4 implies irs(src(ψ), ψ(p), r)/ψ1 = irs(src(ψ2), ψ(p), r), and Lemma 5.6 entails irs(src(ψ), ψ(p), r) · (ψ1 / irs(src(ψ), ψ(p), r)) ≈1 ψ1 · irs(src(ψ2), ψ(p), r). Consequently,  application  of  clause  5  yields  irs(src(ψ), ψ(p), r) · (ψ/ irs(src(ψ), ψ(p), r)) ≈1 ψ1 · irs(src(ψ2), ψ(p), r) · ψ2 / irs(src(ψ2), ψ(p), r)). In turn, IH on ⟨r, p1⟩ yields irs(src(ψ2), ψ(p), r) · (ψ2 / irs(src(ψ2), ψ(p), r) ≈1 ψ2; recall that ψ(p)= ψ2(p1). Hence we conclude.
Assume ψ = ·i<ω ψi and ψ includes head steps. Then p = 2j1p1, where ⟨r, p1⟩∈ ers(ψj), ψi respects {rj / rj < r}∪(r · Ppos(ψ(p)), and ψ(p)= ψj(p1). Lemma 5.1 im- plies src(ψ)|r = src(ψ0)|r = l[s01,..., s0m]. Clause 5 yields ψ/ irs(src(ψ), ψ(p), r)= (ψ0/irs(src(ψ), ψ(p), r)) · ·i<ω ψi+1 / (irs(src(ψ), ψ(p), r)/ψ0). In turn, Lemma 5.6
implies irs(src(ψ), ψ(p), r) · (ψ0/irs(src(ψ), ψ(p), r)) ≈1 ψ0 · irs(src(ψ1), ψ(p), r), and Lemma 5.4 entails irs(src(ψ), ψ(p), r)/ψ0 = irs(src(ψ1), ψ(p), r). There- fore, irs(src(ψ), ψ(p), r) · (ψ/irs(src(ψ), ψ(p), r)) ≈1 ψ0 · irs(src(ψ1), ψ(p), r) ·
·i<ω ψi+1/irs(src(ψ1), ψ(p), r).  This argument can be iterated for all n < j; observe ⟨r, 2j—n1p1⟩ ∈ ers( ·i<ω ψi+n) and ψ(p) = ·i<ω ψi+n(2j—n1p1). We obtain irs(src(ψ), ψ(p), r) · (ψ/irs(src(ψ), ψ(p), r)) ≈1 ψ0 · ... · ψj—1 · irs(src(ψj), ψ(p), r) · ·i<ω ψi+j/irs(src(ψj), ψ(p), r). IH applies on ⟨r, p1⟩, allowing to assert irs(src(ψj), ψ(p), r) · ·i<ω ψi+j/irs(src(ψj), ψ(p), r) ≈1 ·i<ω ψi+j; recall ψ(p)= ψj(p1). This suffices to conclude.
Assume that f 2 is a fixed prefix for ψ, where src(ψ) = f (s1,..., sm). It is easy to obtain r /= δ, that is, r = ir1.	Say ψ γ f 2 = f (ψ1,..., ψm).	Then src(ψ) = src(ψ γ f 2) implies src(ψi) = si. Moreover, Lemma 5.3 implies ⟨r, q⟩ ∈ ers(ψγ f 2) for some q such that ψ(p)= ψγ f 2(q). In turn, this implies q = iq1 and ψ(p) = ψi(q1). Therefore, irs(src(ψ), ψ(p), r) = irs(src(f (ψ1,..., ψm), ψi(q1), ir1)
=	f (src(ψ1),..., irs(src(ψi), ψi(q1), r1),..., src(ψm)).	Clause  7  applies  to
ψ/irs(src(ψ), ψ(p), r), so that
irs(src(ψ), ψ(p), r) · (ψ/ irs(src(ψ), ψ(p), r))
= f (src(ψ1),..., irs(src(ψi), ψi(q1), r1),..., src(ψm))
· f (ψ1,..., ψi / irs(src(ψi), ψi(q1), r1),..., ψm)
≈1 f (ψ1,..., irs(src(ψi), ψi(q1), r1) · ψi / irs(src(ψi), ψi(q1), r1),..., ψm)
≈1 f (ψ1,..., ψi,..., ψm) = ψ γ f 2 ≈1 ψ
by definition of projection where clause 1 yields ψj/sj = ψj if j /= i; structural equivalence; and IH on ⟨r1, q1⟩ along with Lemma 5.2.	2

Limitations of this approach
As shown by the discussion at the beginning of Section 5, the definitions given in Section 4 allow to obtain proper projections for cases beyond the scope of Lemma 5.6 and Prop. 5.7. However, this is not always the case, even for projections involving an infinite and a finite reduction.
As an example, consider the rules ρ : gx → fgx, π : a → b, and let ψ = ·i<ω fiρa, φ = gπ. We claim that according to the intuitive notion of projection, the result of ψ/φ should be ·i<ω fiρb, that is the same reduction denoted by ψ, applied to the target of φ, namely g(b). W.r.t. φ/ψ, we note that the π step denoted by φ vanishes in tgt(ψ) = fω, while it can be performed on each partial target fnga. This phenomenon is referred to as inﬁnitary erasure in [12]. Accordingly, we could expect the result of φ/ψ to be fω.
We have ψ/φ = (ρa/gπ) · ·i<ω fi+1ρa / (gπ/ρa) = ρb · ·i<ω fi+1ρa / fgπ = ρb · f ( ·i<ω fiρa / gπ)= ρb · f (ψ/φ), where the first and third equalities are justified by clauses 5 and 7 resp., and the last one just considers the definitions of ψ and φ. Successive iterations yield ρb · f (ρb · f (ψ/φ)), ρb · f (ρb · f (ρb · f (ψ/φ))), etc., i.e., we obtain always expressions including an occurrence of the projection operator. On the other hand, φ/ψ = (gπ/ρa) / ·i<ω fi+1ρa = fgπ / ·i<ω fi+1ρa = f (gπ / ·i<ω fiρa) = f (φ/ψ) = f 2(φ/ψ) .. ., where clauses 6 and 7 are used in the first and third equalities resp.. As in the previous case, the successive expressions obtained always include an occurrence of the projection operator. This differs from the behaviour of the examples in Section 4, where a final (i.e. without occurrences of the projection operator) expression is obtained.
Observe that in both cases, the partial results approximate the expected final results. A similar phenomenon occurs when applying our definition to obtain the projection of an infinite composition over another one. These observations suggest the need of incorporating the notion of limit in the proposed definition of projection, in order to cover the cases not currently considered.


Conclusions and future research directions
In this article, we describe our work-in-progress about a possible characterisation, based on proof terms, of the projection of one reduction over another for infinitary, left-linear, first-order rewriting. We introduce this characterisation, show that it conveys the expected results in several cases, and prove a partial confluence property. We also discuss some limitations of the current form of the characterisation.
Two obvious further directions of work are: to extend the proposed definition, in order to comprise all projections of an infinitary reduction over another one, and to extend the soundness property expressed in Prop. 5.7 to all projections. Additionally, it would be interesting to further delimit the scope of the current version, that is, to understand in which cases the development of a projection can be performed without explicit use of the notion of limit.

References
B. Accattoli, E. Bonelli, D. Kesner, and C. Lombardi. A nonstandard standardization theorem. In
S. Jagannathan and P. Sewell, editors, POPL, pages 659–670. ACM, 2014.
H.P. Barendregt. The Lambda Calculus: Its Syntax and Semantics. Elsevier, Amsterdam, 1984.
H. B. Curry and R. Feys. Combinatory Logic. North-Holland Publishing Company, Amsterdam, 1958.
N. Dershowitz, S. Kaplan, and D. Plaisted. Rewrite, rewrite, rewrite, rewrite, rewrite, . . Theor. Comput. Sci., 83(1):71–96, 1991.
J. Endrullis. Personal communication, 2016.
J. Endrullis, H. Hvid Hansen, D. Hendriks, A. Polonsky, and A. Silva. A coinductive framework for infinitary rewriting and equational reasoning. In M. Ferna´ndez, editor, RTA 2015, volume 36 of LIPIcs, pages 143–159. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2015.
R. Kennaway. On transfinite abstract reduction systems. Technical Report CS-R9205, Centrum voor Wiskunde en Informatica, Netherlands, 1992.
R. Kennaway, J.W. Klop, M. Ronan Sleep, and F.-J. de Vries. Transfinite reductions in orthogonal term rewriting systems. Inf. Comput., 119(1):18–38, 1995.
J. Ketema. Reinterpreting compression in infinitary rewriting. In A. Tiwari, editor, RTA 2012 (Nagoya, Japan), volume 15 of LIPIcs, pages 209–224. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2012.
J.W. Klop and R. de Vrijer. Infinitary normalization. In We Will Show Them: Essays in Honour of Dov Gabbay, volume 2, pages 169–192. College Publications, 2005.
C. Lombardi. Reduction spaces in non-sequential and infinitary rewriting systems. Phd thesis, Universidad de Buenos Aires – Universit´e Paris-Diderot, 2014.
C. Lombardi, A. R´ıos, and R. de Vrijer. Proof terms for infinitary rewriting. In G. Dowek, editor,
RTA-TLCA’14, volume 8560 of Lecture Notes in Computer Science, pages 303–318. Springer, 2014.
C. Lombardi, A. R´ıos, and R. de Vrijer. Projections for infinitary rewriting. Online at http://arxiv. org/abs/1605.07808, 2016.
P.-A. Melli`es. Description abstraite des Syst`emes de R´e´ecriture. PhD thesis, Univ. Paris VII, 1996.
Terese. Term Rewriting Systems, volume 55 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, Cambridge, UK, 2003.
