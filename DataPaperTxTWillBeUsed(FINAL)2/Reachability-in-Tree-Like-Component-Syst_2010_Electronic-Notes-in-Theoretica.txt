

Electronic Notes in Theoretical Computer Science 263 (2010) 197–210
www.elsevier.com/locate/entcs

Reachability in Tree-Like Component Systems is PSPACE-Complete
Mila Majster-Cederbaum1	Nils Semmelrock 2
Department of Computer Science University Mannheim Mannheim, Germany

Abstract
The reachability problem in component systems is PSPACE-complete. We show here that even the reacha- bility problem in the subclass of component systems with “tree-like” communication is PSPACE-complete. For this purpose we reduce the question if a Quantified Boolean Formula (QBF) is true to the reachability problem in “tree-like” component systems.
Keywords: Component-Based Modeling, Architectural Constraints, Reachability, PSPACE-Completeness


Introduction
In component-based modeling techniques the size of the global state space of a system is in the worst case exponential in the number of its components. This problem is often referred to as the effect of state space explosion. Thus, checking properties of a component-based system by exploring the state space very quickly becomes inefficient. Here we explore the complexity-theoretical classification of reachability.
As a formal model for component-based systems we consider here interaction systems [8], a formalism for component-based modeling which offers in general an arbitrary degree of synchronization. Reachability in general interaction systems was proved to be PSPACE-complete [15] similar to results in 1-safe Petri nets [6].
Tree-like component systems are component systems where the communication structure forms a tree. This is an important class of systems which has been early studied e.g. in [9,5] and more recently e.g. in [4,12].

1 Email:mcb@informatik.uni-mannheim.de
2 Email:nsemmelr@informatik.uni-mannheim.de

1571-0661© 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.05.012

Here we show that even in the subclass of tree-like interaction systems the reachability problem (and therefore proving deadlock-freedom as well) is PSPACE- complete. We also sketch that deciding progress in tree-like interaction systems is PSPACE-complete.

Interaction Systems
Interaction systems are a component-based formalism, i.e. a system is composed of subsystems called components. Components are put together by some kind of glue-code. Interaction systems are defined in two layers. The first layer, the in- teraction model, describes the interfaces of the components and the glue-code of a system by connecting the interfaces of the components. The second layer describes the behavior of the components, which is here given in form of labeled transition systems.
Definition 2.1 Let K = {1,... , n} be a finite set of components. For each i ∈ K

let Ai be a finite set of ports such that ∀
i,j∈K
i /= j ⇒ Ai ∩ Aj = ∅. An interaction

model is a tuple IM := (K, {Ai}i∈K,C), where C is a set such that

∀c ∈ C : c ⊆ 
i∈K
Ai,
∀c ∈ C∀i ∈ K : |c ∩ Ai| ≤ 1 and

 
c∈C
c = 
i∈K
Ai.

The elements of C are called connectors. Let for c ∈ C and i ∈ K i(c) := c ∩ Ai
be the set of ports of i which participate in c, i.e. |i(c)| ≤ 1.
Let Ti = (Qi, Ai, →i, q0) for i ∈ K be a labeled transition system with a finite set of states Qi, a transition relation →i⊆ Qi × Ai × Qi and an initial state q0 ∈ Qi. A transition system Ti for i ∈ K models the behavior of component i. We will write
q  ai	'	'
i →i qi instead of (qi, ai, qi) ∈→i.
Definition 2.2 An interaction system is a tuple Sys := (IM, {Ti}i∈K ). The behavior of Sys is given by the transition system
T = (QSys, C, →, q0) where
QSys :=   Qi is the state space,
i∈K
q0 = (q0,... , q0) ∈ QSys is the initial state and
1	n

→⊆ QSys × C × QSys is the transition relation with q →c
q' iff for all i ∈ K

i(c)
q
i →i qi if i(c) /= ∅ and qi = qi otherwise.
Definition 2.3 Let Sys be an interaction system and T = (QSys, C, →, q0) the associated global transition system. A global state q ∈ QSys is called reachable iff there is a path that leads from the initial state q0 to q in T .
As mentioned we focus on a structural constraint on interaction systems. More precisely we look at the important class of interaction systems such that the glue-

code describes a tree-like communication pattern, i.e. components never form a cycle with respect to their connectors.
A tree-like communication structure induces an important class of component- based systems. Many interesting systems belong to this class, e.g. hierarchical systems or networks built by a master-slave operator [9]. For these reasons, this class of component systems has been studied intensely e.g. in [3,4,5,12].
Definition 2.4 Let IM = (K, {Ai}i∈K,C) be an interaction model. The interac- tion graph G∗ = (K, E) of IM is an undirected graph with {i, j} ∈ E iff there is a connector c ∈ C with i(c) /= ∅ and j(c) /= ∅.
An interaction model IM is called tree-like iff the associated interaction graph G∗ is a tree. An interaction system Sys is called tree-like if its associated interaction model is tree-like.
Remark 2.5 Note, that a tree-like interaction system with a set C of connectors implies that on all c ∈ C |c| ≤ 2.
Example 2.6 Consider the dining philosophers problem with n philosophers and n forks. The philosophers, respectively the forks, are labeled with 0,... ,n − 1. The philosophers are placed in order around a table such that between philosopher i and i+ 1 (we assume modulo n arithmetics) fork i is placed. We construct an interaction system such that each philosopher and each fork corresponds to a component. Let i ∈ {0,... ,n − 1} then philosopher i is modeled by component P hili with the set of ports AP hili := {t lefti,t righti,p lefti,p righti} such that the ports are modeling, from left to right: “take left fork”, “take right fork”, “put left fork back on the table” and “put right fork back on the table”. Fork i is modeled by component F orki with the set of ports AF orki := {takei, releasei}.
The following connectors describe the synchronization between the philosophers and the forks, corresponding to the seating order.
take lefti := {t lefti, takei}	take righti := {t righti, takei−1}
put lefti := {p lefti, releasei}	put righti = {p righti, releasei−1}
Consider the problem for n = 3 philosophers, then the set K of components is given by K = {P hil0,Phil1,Phil2,Fork0,Fork1,Fork2} and the set C of connectors by C := {take lefti, take righti, put lefti, put righti|i = 0,... , 2}. The interaction model is given by IM = (K, {Ai}i∈K,C). The corresponding interaction graph G∗ for IM is given in Figure 1 and forms a cycle.
QBF Reduction to Tree-Like Interaction Systems
We will show that reachability in tree-like interaction systems is PSPACE-complete. The PSPACE-hardness will be proved by a reduction from QBF [7]. PSPACE- hardness of reachability in general interaction systems was shown by a reduction from reachability in 1-safe Petri nets [15]. To show the PSPACE-hardness of reach- ability in 1-safe Petri nets a reduction from QBF was used [6].



	


Fig. 1. Interaction graph G∗ for the interaction model IM .
Reduction
Reachability in tree-like interaction systems is in PSPACE. Given a tree-like inter- action system and a global state q one can guess a sequence of connectors (because PSPACE=NPSPACE) and check in linear space if it leads from the initial state q0 to q. At any time we story exactly one global state from which we guess a valid successor state. To prove the PSPACE-hardness we present a reduction from the va- lidity problem for Quantified Boolean Formulas (QBF) to the reachability problem in tree-like interaction systems.
QBF
An instance of QBF [7] is given as a well-formed quantified Boolean formula where its variables x1,... , xn are all bound and distinct. Without loss of generality we look at QBF instances over the grammar
P ::= x|¬P |P ∧ P |∃x.P.
In the following we will assume that a QBF formula is built over this grammar. Let H be a QBF then the question is if H is true. The language TQBF is defined as the set of true QBF instances and is well known to be PSPACE-complete.
There is a straightforward, recursive algorithm called eval to determine whether a QBF P given over the grammar above is in TQBF.
Algorithm 1
eval(P )
if (P = x)
return value(x)
4	if (P = ¬P ')
return ¬eval(P ')
if (P = P ' ∧ P '')
return eval(P ') ∧ eval(P '')
// P = ∃x.P ' is the only remaining possibility
return eval(P '	) ∨ eval(P '	)
In line 9 P '	denotes the subformula P ' with true assigned to the variable x.
In line 3 value(x) returns the truth value that is assigned to x. This is possible
because every variable x in H is bound by an existential quantifier and therefore a

truth value is assigned in line 9. Obviously, H ∈ TQBF ⇔ eval(H)= true.
RIST
Let IST be the class of tree-like interaction systems. For Sys ∈ IST let Reach(Sys) ⊆
QSys be the set of reachable states. Let

RIST :=	 
Sys∈IST
({Sys}× QSys) .

For (Sys, q) ∈ RIST we want to decide if q is reachable in Sys. Let TRIST ⊆ RIST
be the set of true RIST instances, i.e.

TRIST =	 
Sys∈IST
({Sys}× Reach(Sys)) .

In the following we will introduce for a QBF H a tree-like interaction system SysH
and a global state qt such that
H ∈ TQBF ⇔ (SysH, qt) ∈ TRIST and
the size of SysH is polynomial in the size of H.
The idea for the construction of SysH can be sketched as follows: the interaction system basically simulates the evaluation of the formula H, as in algorithm eval (see Algorithm 1), based on the syntax tree of H. The subformulas of H are the components of the system, and the interaction model describes the propagation of truth values between the nodes of the syntax tree.
Example 3.1 Consider the formula H = ¬∃x1.(x1 ∧ ¬x1). The associated inter-
action graph G∗  of IMH is given in Figure 2 where components with highlighted
frames denote components that do not model subformulas of H. IMH is constructed
accordingly to the following reduction.







Fig. 2. Interaction graph G∗
of IMH .

We now describe in detail how SysH is constructed:
Components
Let H be a QBF with variables x1,... , xn and K2 = {x'|xi is a variable in H}. The set of components K2 is needed to avoid cycles in the interaction graph. Generally,

there may be several occurrences of a variable xi in H. Let xi occur ki times for i = 1,... ,n as a subformula in H, then we assume that the jth occurrence of variable xi is renamed in H as xj for j ∈ {1,... , ki}.
Let KH = K1 ∪ K2 ∪ {H'} be a set of components such that
K1 = {P |P is a subformula of H}. The component H' is an auxiliary component which simplifies the definition of the behavior of the components in K1.
Given a truth assignment to the variables, subformulas are assigned true or false. Therefore, when we mention an assignment to a component in K1 ∪ K2 we refer to the assignment of the subformula that is modeled by this component.
In the following we will give the port sets of the components. Many ports, in different components, serve the same purpose and only differ in their subscripts. Once such a port is introduced it will not be explicitly explained again.
Port sets of components modeling variables
For i = 1,... ,n and j = 1,... , ki the component P = xj ∈ K1 represents the jth occurrence of variable xi in H. The set AP of ports is given by
AP := {aP , tP , fP , rP t}∪ {rP xlt, rP xlf |l = 1,... , n}.
aP abbreviates “activate P ” and starts the evaluation of P .
tP respectively fP confirm that currently true respectively false is assigned to P.
rP xlt abbreviates “P receives instruction to set xl true”. If l = i then true is assigned to P . For i /= l rP xlt has no effect on P . The same applies to rP xlf setting xl to false.
rP t has the function to assign true to P .
Port sets for negated formulas
A component modeling a negation, i.e. a subformula of the form P = ¬P1 has the following set of ports AP
AP := {e1 , aP , sub1 t, sub1 f, tP , fP , rP t, s1 t}∪ 
P	P	P	P
{rP xlt, rP xlf, s1 xlt, s1 xlf |l = 1,... , n}.
P	P

e1
P
abbreviates “evaluate the first subformula of P ” and evaluates the subformula

P1.
sub1 t (abbreviates “subformula 1 is true”) respectively sub1 f affirm that P1 was
P	P
evaluated true respectively false.
According to the structure of a negation fP (abbreviates “P = ¬P1 is false”) is enabled if P1 was evaluated true. Conversely tP is enabled if P1 was evaluated false.
As above rP xlt models that P receives the instruction to set xl true. On the other hand s1 xlt (“set xl true in the first subformula of P ”) models that P itself sends the instruction to set xl to true to P1. The same applies to s1 xlf if xl
needs to be set to false.

s1 t has the function to set the truth assignment of P ’s subformula P1 to true.
Port sets for conjunctions
The component that models a conjunction, i.e. a subformula of the form P = P1∧P2
has the set of ports
AP := {aP , e1 , e2 , sub1 t, sub1 f, sub2 t, sub2 f, tP , fP , rP t, s1 t, s2 t}∪ 
P	P	P	P	P	P	P	P
{rP xlt, rP xlf, s1 xlt, s1 xlf, s2 xlt, s2 xlf |l = 1,... , n}.
P	P	P	P
This is the only formula that has two direct subformulas. P = P1 ∧ P2 needs
to evaluate P1 and P2, therefore there are ports e1 and e2 . Similarly there are
sub1 t, sub1 f , sub2 t, sub2 f for actually receiving the truth values of P1 and P2.
P	P	P	P
Likewise, s1 xlt and s2 xlt model that P needs to set xl to true in its first and second
P	P
subformula and respectively s1 xlf and s2 xlf to false.
P	P
Port sets for existentially quantiﬁed formulas and associated component x'
In the interaction system SysH a component for a subformula of the form P =
∃xi.P1 with i = 1,... ,n needs to have access to the current truth assignment of the variable xi. For this purpose the set of components K2 was introduced. Let xi be the variable that is quantified by the subformula P = ∃xi.P1. The component x'
models the truth assignment of xi. The set of ports Ax' is given by





txi


respectively fxi
Ax' := {rxit, rxif, txi, fxi }.
affirm that the current state of x' is true respectively false. rxit

assigns x' true. Analogously rxif switches the assignment to false.
The port set AP for P = ∃xi.P1 is given by
AP := {aP , e1 , sub1 t, sub1 f, tP , fP , xit, xif, sxit, sxif, rP t, s1 t}∪ 
P	P	P	P
{rP xlt, rP xlf, s1 xlt, s1 xlf |l = 1,... , n}.
P	P
aP , e1 , sub1 t, sub1 f , tP and fP act similarly to the corresponding ports of the
P	P	P
other components specified above. xit confirms that true is assigned to xi, and sxit
sets xi to true if the current assignment is false. On the other hand xif confirms that false is assigned to xi, and sxif assigns false to xi if that is not the case.
Port set for the auxiliary component H'
Given the syntax tree for H, whose root is labeled H, H' can be interpreted as a direct dummy predecessor formula of H without any logical operator. The set of ports AH' is given by
AH' := {e1 ' , sub1 ' t, sub1 ' f, s1 ' t, endH' }.
H	H	H	H
All ports but endH' act exactly as the ports described above. It will be shown that the formula H is in TQBF iff the component associated with H is evaluated true,
i.e. sub1 ' t can interact eventually. When the evaluation of the QBF H has been simulated, i.e. H' reached a state that represent the fact that H was evaluated true

or false, then the port endH' becomes enabled. This only assures that the behavior of H' does not deadlock.
Connectors
We will now define a set C of connectors. Let P ∈ K1 ∪ {H'} be a subformula which is not an occurrence of a variable. P can have one direct subformula which is P1 or two direct subformulas P1 and P2. If P needs the truth value of Pk, k ∈ {1, 2}, to be evaluated then the evaluation in Pk needs to be activated. This is realized by

the synchronization of ek
and aPk . Furthermore P can ask Pk for its current truth

value. These interactions are realized by
eval P → Pk := {ek , aP }	P ask Pk true := {subk t, tP }
P	k	P	k
P ask Pk f alse := {subk f, fP }
P	k
for k ∈ {1, 2}. These connectors already connect all components in K1 ∪ {H'} and result in an interaction graph that is related to the syntax tree of the QBF H.
If P needs all occurrences of variable xi to be set to true or false a direct interaction with the components that model these variables would lead to a cycle
in the associated interaction graph. Therefore, P passes this information to its subformulas, i.e. sk xit in P has to synchronize with rP xit in Pk where Pk is a direct
P	k
subformula of P . Let i ∈ {1,... , n}. The following connectors, for k ∈ {1, 2}, realize
the synchronizations needed to propagate the information to switch a variable.
set xi true P → Pk := {sk xit, rP xit}
P	k
set xi f alse P → Pk := {sk xif, rP xif }
P	k
If the QBF H is true, we need all components to be in one fixed state – this will be a state that models the assignment true. In fact, the component H' will observe if H is true and reach a fixed state. To assure that all components can reach a fixed state, a similar technique as above is used. A component can set the truth assignment of the components that represent its subformulas to true by the following connector for k ∈ {1, 2}.
set Pk true P → Pk := {sk t, rP t}
P	k
Consider a subformula of the form P = ∃xi.P1 ∈ K1 and the associated compo- nent x' ∈ K2. The component representing P can assign x' the truth value true or
i	i
false and can ask x' whether the current truth assignment is true or false. This is
realized by
set x' true := {sxit, rxit}	ask truex' := {xit, tx }
i	i	i
set x' f alse := {sxif, rxif }	ask f alsex' := {xif, fx }
i	i	i
IF H' reaches a state that indicates that H was evaluated true or false, i.e. the simulation of the evaluation of H is finished, then the unary connector evaluated :=
{endH' } becomes enabled.

Let C be the set of connectors given by
{eval P → Pk,P ask Pk true, P ask Pk f alse|P ∈ K1 ∪ {H'} with succ. Pk}∪
{set x' true, set x' f alse, ask truex' , ask f alsex' |x' ∈ K2}∪
i	i	i	i  i
{set Pk true P → Pk|P ∈ K1 ∪ {H'} with succ. Pk}∪
{set xi true P → Pk, set xi f alse P → Pk|P ∈ K1with succ. Pk,i ∈ {1,... , n}}∪
{evaluated}.

So far we have the interaction model IMH := (KH , {AP }P ∈KH ,C). This way any QBF formula H over the grammar, given above, can be mapped to an interac- tion model IMH .
Remark 3.2 The interaction graph G∗ , associated to IMH, is a tree, as it is constructed along the syntax tree and augmented with the components H' and x'
for i = 1,... ,n without forming cycles.
Local Behavior
The local behavior of the components is given by labeled transition systems. Every system has one state labeled t and one labeled f . These states model the fact that either true respectively false was assigned to this component or it was evaluated true respectively false. The initial state will be denoted by an ingoing arrow.
Figure 3(a) depicts the transition system of the component modeling the jth occurrence of variable xi. Figure 3(b) gives the local behavior of a component x' ∈ K2. The behavior of H' is given in 3(c). The transition systems for a variable xj and
a x' ∈ K2 are self-explanatory. If in TH' the port e1 ' is performed, i.e. component
i	H
H needs to be evaluated, then TH' waits to perform either sub1 ' t or sub1 ' f . This
H	H
ports can only be performed if TH reaches its state labeled t respectively f . It will
be shown that this indicates whether the associated QBF is true or false.



t , aP ,
xlt(l = 1,. .. , n),	i
xlf (l /= i)
endH'
, aP ,

xlf (l = 1, ... , n),
rP xlt(l /= i)
(a) P = xj
xi


(b) x'


(c) H'


Fig. 3. Transition systems T j for a component xj (a), T ' for x' (b) and TH' for the component H' (c).

xi	i
xi	i

In Figure 4 the transition system for a component of the form P = ¬P1 is pictured. Note, that for better readability, the transition system in Figure 4(a) is not completely displayed. In system 4(a) the transitions and states pictured in

Figure 4(b) and 4(c) have to be included between the states labeled t and f for
l = 1,... , n.


s1 xlt








fP	tP

P = ¬P1





Section of 4(a) and 5(a), for l ∈
{1,. .. , n}




s1 xlf
s1 t


Section of 4(a)


Fig. 4. Main section of the transition systems T¬P1 (a), part of T¬P1 for l ∈ {1, . .., n} (b), part of T¬P1
(c).


In Figure 5 the transition system for a component of the form P = ∃xi.P1 is pictured. For better readability, the transition system in Figure 5(a) is not completely displayed. In system 5(a) the transitions and states pictured in Figure 4(b) and 5(b) have to be included between the states labeled t and f for l = 1,... , n.








a



tP







P = ∃xi.P1
sxit, xit	s1 t




Section of 5(a)


Fig. 5. Main sections of the transition system T∃xi.P1 (a), part of T∃xi.P1 (b).


In Figure 6 the transition system for a component of the form P = P1 ∧ P2 is pictured. Note, that the transition system in Figure 6(a) is not completely displayed. The transitions and states pictured in Figure 6(b) and 6(c) have to be included between the states labeled t and f for l = 1,... , n.








fP
s1 xlt








P = P1 ∧ P2
P
s1 xlf
Section of 6(a), for l ∈ {1,. .. , n}


Section of 6(a)


Fig. 6. Transition system TP1 ∧P2 .
The resulting interaction system is denoted by SysH := (IMH , {TP }P ∈KH ).
Theorem 3.3 Let H be a QBF over the grammar P ::= x|¬P |P ∧ P |∃x.P and SysH the associated interaction system obtained from the reduction. Let qt be the global state in which all components are in their state labeled t, then
H ∈ TQBF ⇔ (SysH, qt) ∈ TRIST.


The proof of Theorem 3.3 can be found in the Appendix of [14].
QBF Reduction to Progress in Tree-Like Interaction Systems
By minor modification of the reduction given above it is possible to show the PSPACE-completeness of the progress property in tree-like interaction systems. At first we give some definitions to introduce progress in interaction systems and then give an overview why it is PSPACE-complete to decide this property in tree-like interaction systems. In general interaction systems progress is PSPACE-complete [15], so progress in tree-like interaction systems is in PSPACE.
Definition 4.1 Let Sys be an interaction system and T = (QSys, C, →, q0) the associated global transition system. A global state q ∈ QSys is called a deadlock if

no connector is enabled in q, i.e. there is no c ∈ C and q' ∈ QSys such that q c
q'.

A system Sys is free of deadlocks if there is no reachable state q ∈ QSys such
that q is a deadlock.
Definition 4.2 Let Sys be a deadlock-free interaction system. A run of Sys is an infinite sequence σ

q0 c1
c q ... ,

with ql ∈ QSys and cl ∈ C for l ≥ 1.
Definition 4.3 Let Sys be a deadlock-free interaction system with components K. k ∈ K may progress in Sys if for every run σ k participates infinitely often in σ.
An instance of the progress problem in interaction systems is given by a tuple (Sys, k) where Sys is a deadlock-free interaction system with components K and k ∈ K. The question is if k may progress in Sys.
We modify SysH as follows:
We introduce an additional component called pro with the set of ports Apro :=
{tpro} and the behavior given by the transition system Tpro in Figure 7. The idea is to embed pro in SysH such that tpro will participate infinitely often in every run σ iff H is true.


tpro

Fig. 7. Transition system Tpro for the component pro.

In addition we modify the component H' as follows. The set of ports AH' of the component H' is now given by
AH' := {e1 ' , sub1 ' t, sub1 ' f, s1 ' t, end trueH' , end f alseH'},
H	H	H	H

i.e. endH' is removed and the ports end trueH' and end f alseH' are added. The modified behavior of H' is given by the transition system TH' in Figure 8.







end falseH'



Fig. 8. Modified transition system TH' for the component H'.

In addition, the connector evaluated is removed von the set C of connectors, and the two following connectors are added.
evaluated true := {end trueH' , tpro}, evaluated f alse := {end f alseH' }.
It is easy to see that the connector evaluated true is the only connector that is enabled if the state qt is reached. In this case, evaluated true will perform in- finitely often, i.e. the component pro will participate infinitely often. Therefore the component pro may progress iff H is true.

Conclusion and Related Work
We investigated a complexity issue for component-based systems. In [6] the reach- ability in 1-safe Petri nets was proven to be PSPACE-complete and [15] used this result to show the PSPACE-completeness of the reachability problem in component- based systems. Here we restricted ourselves to tree-like systems and showed that even in this class deciding reachability is PSPACE-complete.
We conjecture that this result can be still strengthened such that it should be possible to show that even for the class of linear interaction systems, where the interaction graph forms a sequence of components, the reachability problem is PSPACE-complete. Given these complexity issues it makes sense to look for conditions that can be tested in polynomial time and guarantee a desired property. For general component systems this is pursued e.g. in [1,2,10,11,13,16]. For tree-like component systems [3,4,5,12] have followed this approach and in particular
established conditions that ensure deadlock-freedom.

References
Robert Allen and David Garlan. A Formal Basis for Architectural Connection. ACM Transactions on Software Engineering and Methodology, 6:213–249, 1997.
Paul Attie and Hana Chockler. Efficiently Verifiable Conditions for Deadlock-Freedom of Large Concurrent Programs. In Proceedings of VMCAI’05, LNCS 3385, pages 465–481, 2005.
H. Baumeister, F. Hacklinger, R. Hennicker, A. Knapp, and M. Wirsing. A Component Model for Architectural Programming. In Proceedings of FACS’05, volume 160 of ENTCS, pages 75–96. Elsevier, 2006.
Marco Bernardo, Paolo Ciancarini, and Lorenzo Donatiello. Architecting Families of Software Systems with Process Algebras. ACM Trans. on Software Engineering and Methodology, 11:386 – 426, October 2002.
Stephen D. Brookes and A. W. Roscoe. Deadlock Analysis in Networks of Communicating Processes.
Distributed Computing, 4:209–230, 1991.
Allan Cheng, Javier Esparza, and Jens Palsberg. Complexity Results for 1-safe Nets. In Theoretical Computer Science, pages 326–337. Springer-Verlag, 1995.
M. R. Garey and D. S. Johnson. Computers and Intractability : A Guide to the Theory of NP- Completeness (Series of Books in the Mathematical Sciences). W. H. Freeman, January 1979.
Gregor G¨ossler and Joseph Sifakis. Composition for Component-Based Modeling. Sci. Comput. Program., 55(1-3):161–183, 2005.
Charles A. R. Hoare. Communicating Sequential Processes. Prentice-Hall International series in computer science. Prentice-Hall International, Englewood Cliffs, NJ [u.a.], 1985.
Paola Inverardi and Sebasti´an Uchitel. Proving Deadlock Freedom in Component-Based Programming. In FASE ’01: Proceedings of the 4th International Conference on Fundamental Approaches to Software Engineering, pages 60–75, London, UK, 2001. Springer-Verlag.
M. Majster-Cederbaum, M. Martens, and C. Minnameier. A Polynomial-Time Checkable Sufficient Condition for Deadlock-Freedom of Component-Based Systems. Lecture Notes in Computer Science, 4362/2007:888–899, 2007.

Mila Majster-Cederbaum and Moritz Martens. Compositional Analysis of Deadlock-Freedom for Tree- Like Component Architectures. In EMSOFT ’08: Proceedings of the 7th ACM international conference on Embedded software, pages 199–206, New York, NY, USA, 2008. ACM.
Mila Majster-Cederbaum, Moritz Martens, and Christoph Minnameier. Liveness in Interaction Systems.
Electron. Notes Theor. Comput. Sci., 215:57–74, 2008.


Mila Majster-Cederbaum and Nils Semmelrock. Reachability in Tree-Like Component Systems is PSPACE-Complete. Technical Report TR-2009-004, University of Mannheim, Germany, 2009.
Mila E. Majster-Cederbaum and Christoph Minnameier.	Everything Is PSPACE-Complete in Interaction Systems. In ICTAC, pages 216–227, 2008.
Christoph Minnameier and Mila Majster-Cederbaum. Cross-Checking – Enhanced Over-Approximation of the Reachable Global State Space of Component-Based Systems, 2009. submitted for puplication.
