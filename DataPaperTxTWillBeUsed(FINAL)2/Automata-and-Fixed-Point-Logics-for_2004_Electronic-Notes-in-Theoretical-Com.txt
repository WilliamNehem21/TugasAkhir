Electronic Notes in Theoretical Computer Science 106 (2004) 355–375 
www.elsevier.com/locate/entcs


Automata and Fixed Point Logics for Coalgebras
Yde Venema1
Institute for Logic, Language and Computation University of Amsterdam
Plantage Muidergracht 24, NL–1018 TV Amsterdam.

Abstract
It is the aim of this paper to generalize existing connections between automata and logic to a more general, coalgebraic level.
Let F : Set → Set be a standard functor that preserves weak pullbacks. We introduce the notion of
an F-automaton, a device that operates on pointed F-coalgebras; the criterion under which such an automaton accepts or rejects a pointed coalgebra is formulated in terms of an infinite two-player graph game.
We also introduce a language of coalgebraic fixed point logic for F-coalgebras, and we provide a
game semantics for this language. Finally we show that any formula p of the language can be transformed into an F-automaton Ap which is equivalent to p in the sense that Ap accepts precisely those pointed F-coalgebras in which p holds.
Keywords: coalgebra, automata, modal logic, fixed point operators, game semantics, bisimulation, parity games


Introduction
There is a long and respectable tradition in theoretical computer science link- ing the research fields of automata theory and logic. This link becomes par- ticularly strong when automata are used to classify inﬁnite objects like words,
trees or graphs. Interestingly, this research area has provided not only funda- mental theoretical results, such as Rabin’s decidability theorem [13], but also quite concrete applications in computer science, such as tools for the auto- matic verification of reactive systems, see for instance [4] on model checking.

1 Email: yde@science.uva.nl



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.038


Over the last ten years, the links between logic and automata theory have only grown stronger, to the effect that in many cases, the distinction between automata and formulas has almost disappeared. Of the many interesting re- sults that have been obtained we just mention the connection that Janin & Walukiewicz [9] established between modal fixpoint logics, such as the modal µ-calculus, and alternating parity automata operating on labeled transition systems. For an up to date introduction to the world of automata, logic and infinite games, we refer the reader to Gra¨del, Thomas & Wilke [5].
Although this has to our knowledge never been exploited, or even made explicit, much of the work relating logic and automata theory has a strong coalgebraic flavour. In itself this should not come as a surprise since both (modal) logic and automata theory admit a lucrative coalgebraic perspective. This certainly applies to logic, and to modal logic in particular. Since coalgebra can be seen as a very general model of state-based dynamics, and modal logic as a logic for dynamic systems, the relation between modal logic and coalgebra is rather tight. Starting with the work of Moss [11], the de- velopment and study of modal languages for the specification of properties of coalgebras has been actively pursued and studied by various authors, includ- ing Jacobs [6], Kurz [10], Pattinson [12], and Ro¨ßiger [14]. However, given the intended application of coalgebraic modal languages as specification for- malisms restricting the behavior of state-based systems, it is rather surprising that until now no languages have been developed that incorporate explicit fixed point operators. In addition, the only work on coalgebraic modal lan- guages in which specimens of fixed point formulas are admitted, or in which the need for coalgebraic modal fixed point logics is discussed, seems to be by
Jacobs ([8] and [7], respectively).
The coalgebraic perspective on automata may not have been developed so systematically, automata theory contains some of the paradigmatic examples of coalgebras, as any introduction to the field of coalgebra witnesses. As exam- ples we confine ourselves to mentioning Rutten’s work on automata working on finite and infinite words ([15] and [17], respectively).
Summarizing the above discussion, we find that the relation between au- tomata theory and (modal) logic has been investigated intensively and suc- cessfully, but not uniformly or systematically. Various modal languages have been developed uniformly for coalgebras of arbitrary type, but none of these languages admits explicit fixed point operators. And lastly, we see that cer- tain kinds of automata have been studied from a coalgebraic perspective, but automata for arbitrary coalgebras have not been developed. It thus seems that there is a clear gap here, and it is precisely this gap that we intend to start filling with this paper.


We believe that the connections between automata and logic could and perhaps should be studied from a general, coalgebraic perspective, and it is the main purpose of this paper to introduce a framework for doing so. We
confine our attention to the functors F : Set → Set which are standard and
preserve weak pullbacks — such functors will be called R-standard. For each such functor F, we will define the notion of an F-automaton; the purpose of these devices is to classify pointed F-coalgebras (pairs consisting of an F-
coalgebra and an element of the carrier set of the coalgebra). The criterion under which such an automaton A accepts or rejects such a pointed coalgebra (S, s) is formulated in terms of an infinite two-player game, to be played on a
certain graph induced by A, S and s.
We also introduce a language µLF of coalgebraic fixed point logic for F- coalgebras. This language is finitary in the sense that every formula comes with a ﬁnite set of subformulas. Combining ideas from the game semantics
for the modal µ-calculus as formulated by Janin & Walukiewicz [9], and the semantic games for coalgebraic languages introduced by Baltag [2], we provide a game-theoretical semantics for this language µLF. Finally, the resemblance
between these games and the acceptance games for F-automata leads to the main result of the paper: Theorem 2 states that any µLF-formula can be trans- formed into an F-automaton that accepts precisely those pointed F-coalgebras
in which the formula is true.
It should be mentioned that there are other approaches that study au- tomata from a category-theoretic perspective. For instance, there is a series of articles by Arbib and Manes and a theory of functorial automata devel- oped by Ada´mek, Trnkova´ and others, see [1] (also for references). This work is certainly related to ours, but two differences are that the mentioned re- search focuses on an algebraic rather than a coalgebraic framework, and that it generalizes automata for finite rather than for infinite objects. The precise connection with this work remains to be investigated though.

Overview
We first fix notation and terminology on Set-based functors and coalgebras, and define R-standard functors; we also give a brief introduction to two-person infinite parity games. Section 3 introduces F-automata for R-standard func- tors, and gives a detailed description of the acceptance games for F-automata.
Then we move to logic: in section 4 we introduce the syntax and semantics of the coalgebraic fixed point logic µLF for coalgebras over an R-standard functor
F. The following section provides the details of the game-theoretic approach to
the semantics of this language. Section 6 is both the most important and the briefest section of the paper: here we state the above-mentioned main result


of the paper. We finish the paper with a list of ideas for further research.

Preliminaries
This paper presupposes some familiarity with the basic concepts of category theory and universal coalgebra. The main purpose of this section is to fix notation and terminology. We also give a very brief introduction to so-called
graph games.

Set-based functors and coalgebras
Basics
We let Set denote the category of sets with functions. For an endofunctor F : Set → Set, an F-coalgebra is a pair S = (S, σ) consisting of a set S and a function σ : S → FS. Given two F-coalgebras S = (S, σ) and T = (T, τ ), a function f : S → T is an F-coalgebra morphism or F-homomorphism if F(f ) ◦ σ = τ ◦ f . The category Coalg(F) has the F-coalgebras as objects and the F-homomorphisms as arrows. A relation Z ⊆ S × T is an F-bisimulation if we can impose coalgebra structure ζ : Z → FZ on Z in such a way that the two projections π1 : Z → S and π2 : Z → T are F-coalgebra morphisms. We write Z : S,s ↔ T,t if Z is a bisimulation between S and T that links s ∈ S to t ∈ T , and S,s ↔ T,t if there is such a Z.

Functors and relators
Let Rel denote the category with sets as objects and binary relations as morphisms.  Identity arrows in this category are given, for any set S, by
∆S = {(s, s) | s ∈ S}; composition of arrows in this category is ordinary relation composition, but we will write composition as is usual for functions. A functor Q : Rel → Rel is called a relator.
It is well-known that Set can be embedded in Rel by the graph functor ϕ which is the identity on sets and maps a function f : S → T to its graph ϕ(f ) = {(s, f (s))|s ∈ S}. We say that a relator Q : Rel → Rel extends a functor F : Set → Set if is satisfies (i) QS = FS for all sets S, and (ii) Q(ϕ(f )) = ϕ(F(f )) for all functions f : S → T . Extensions need not always exist, but are unique if they do; we denote the extension of the functor F by F.
It follows from a result by Carboni, Kelly and Wood [3] that an endofunctor on Set can be extended to a relator if and only if it preserves weak pullbacks. In the sequel we will need the following fact; for details, consult Rutten [16].
Fact 2.1 Let F : Set → Set be a functor that preserves weak pullbacks. Then

The unique relator F extending F is given, for R ⊆ S × T, by F(R) = 
F(π2) ◦ F(π1)−1.
F is monotone, that is, if R ⊆ Q then F(R) ⊆ F(Q).
Z is a bisimulation between S and T iff (s, t) ∈ Z implies (σ(s),τ (t)) ∈
FZ, for all s, t.

R-standard functors
A functor F : Set → Set is called standard if it preserves inclusions; that is, whenever f : A ‹→ B is an inclusion, then so is F(f ) : FA ‹→ FB. We need the following property, proved in Ada´mek & Trnkova´ [1].
Fact 2.2 Let F be a standard endofunctor on Set. Then F preserves ﬁnite intersections, that is: F(A ∩ B) = FA ∩ FB.
During most of this paper we will be working with endofunctors on Set that are both standard and preserve weak pullbacks. Hence, it is convenient to introduce terminology.
Definition 2.3 A functor F : Set → Set is called R-standard if it is standard and preserves weak pullbacks.

Graph games
Two-player infinite graph games, or graph games for short, are defined as follows. For a more comprehensive account of these games, the reader is referred to Gra¨del, Thomas & Wilke [5].
First some preliminaries on sequences. Given a set A, let A∗, Aω and A٨ denote the collections of finite, infinite, and all, sequences over A, respectively. (Thus, A٨ = A∗ ∪ Aω.) Given α ∈ A∗ and β ∈ A٨ we define the concatenation of α and β in the obvious way, and we denote this element of A٨ simply by juxtaposition: αβ. Given an infinite sequence α ∈ Aω, let Inf (α) denote the set of elements a ∈ A that occur infinitely often in α.
A graph game is played on a board B, that is, a set of positions. Each position b ∈ B belongs to one of the two players, ∃ (E´loise) and ∀ (Ab´elard). Formally we write B = B∃ ∪ B∀, and for each position b we use P (b) to denote
the player i such that b ∈ Bi. Furthermore, the board is endowed with a binary relation E, so that each position b ∈ B comes with a set E[b] ⊆ B of successors. Formally, we say that the arena of the game consists of a directed bipartite graph B = (B∃ ∪ B∀, E).
A match of the game consists of the two players moving a pebble around
the board, starting from some initial position b0. When the pebble arrives at a position b ∈ B, it is player P (b)’s turn to move; (s)he can move the pebble


to a new position of their liking, but the choice is restricted to a successor of b. Should E[b] be empty then we say that player P (b) got stuck at the position. A match or play of the game thus constitutes a (finite or infinite) sequence of positions b0b1b2 ... such that biEbi+1 (for each i such that bi and bi+1 are defined). A full play is either (i) an infinite play or (ii) a finite play in which the last player got stuck. A non-full play is called a partial play.
The rules of the game associate a winner and (thus) a looser for each full play of the game. A finite full play is lost by the player who got stuck; the winning conditions of infinite games is given by a subset Ref of Bω (Ref is short for ‘referee’): our convention is that ∃ is the winner of β ∈ Bω precisely if β ∈ Ref . A graph game is thus formally defined as a structure G = (B∃∪B∀, E, Ref ). Sometimes we want to restrict our attention to matches of a game with a certain initial position; in this case we will speak of a game that is initialized at this position.
Just like automata, there are various well-known kinds of winning condi- tions; here, we will restrict our attention to parity games, that is, games in which the set Ref is defined in terms of a parity function. A parity function on a set A is a map Ω : A → ω with finite range; put differently, a parity map on A is a map Ω : A → {0,..., k} for some natural number k. Given a parity
map on A, we put

Aω := {α ∈ Aω | max{Ω(a) : a ∈ Inf (α)} is even}.

In a parity game, the set Ref is of the form Bω for some parity function Ω on
the board B.
A strategy for player i is a function mapping partial plays β = b0 ··· bn with P (bn) = i to admissible next positions, that is, to elements of E[bn]. In such a way, a strategy tells i how to play: a play β is conform or consistent with strategy f if for every proper initial sequence b0 ··· bn of β with P (bn) = i, we have that bn+1 = f (b0 ··· bn). A strategy is winning from position b ∈ B
if it guarantees i to win any match with initial position b, no matter how the adversary plays — note that it is not required that P (b) = i. A position b ∈ B is called a winning position for player i if i has a winning strategy from position b; the set of winning positions for i in a game G is denoted as Wini(G).
Parity games form an attractive and important game model because they have many nice properties, such as history-free determinacy. However, none of these are needed in the present paper — the interested reader is again referred to [5].

Coalgebraic automata theory
Basic deﬁnitions
Our first definition concerns the most important notion of the paper: F- automata.
Definition 3.1 Let F be an R-standard endofunctor on Set. An (alternating) F-automaton is a quadruple A = (A, aI, ∆, Acc), with A some finite set of objects called states, aI ∈ A the initial state, ∆ : A → PPFA the step function, and Acc ⊆ Aω the acceptance condition.
An F-automaton is called solitary (or non-deterministic) if all members of each ∆(a) are singletons. An F-automaton is called deterministic if for each a ∈ A there is an element δ(a) ∈ FA such that ∆(a) = {{δ(a)}} (in particular,
such an automaton is solitary).
The meaning of this definition should become clear below when we discuss the acceptance games. In the sequel we will never explicitly use the adjec- tive ‘alternating’ when describing an automaton. We just mentioned it in the definition to make clear that in our framework, the generic automaton is alternating, and deterministic and solitary automata are special instances of alternating ones. This issue will be discussed in more detail further on.
There are various kinds of acceptance conditions known from the literature. For almost all of these, the criterion, whether an infinite sequence α ∈ Aω belongs Acc or not, is formulated in terms of the set Inf (α). For instance, a
Bu¨chi condition puts α ∈ Acc if and only if Inf (α) contains at least one of a
set of special acceptance states. In this paper we will work exclusively with
parity automata.
Definition 3.2 Let F be an R-standard endofunctor on Set.  A parity F-

automaton is an F-automaton A = (A, aI, ∆, Acc), such that Acc = Aω
for

some parity map Ω : A → ω, see (1). Such an automaton is usually pre-
sented as A = (A, aI, ∆, Ω). The map Ω is called the parity function of the automaton.

Acceptance game
F-automata are supposed to operate on pointed F-coalgebras. A pointed F- coalgebra is a pair (S, s) such that S is an F-coalgebra and s is an element of the (underlying set of) S. Basically, the idea is that the F-automaton will either accept or reject a given pointed F-coalgebra. The best way to express
the evaluation process leading to either acceptance or rejection, is in terms of a two-player infinite graph game, or graph game, see section 2. However, it is


useful to first consider another example of a graph game.
Example 3.3 There are various ways to put the notion of bisimulation into this game-theoretic framework. At this stage it is very instructive to consider the following approach from Baltag [2].
Let S = (S, σ) and S' = (S', σ') be two F-coalgebras for some endofunctor F on Set which preserves weak pullbacks. The bisimulation game B(S, S') between S and S' is defined as the graph game (B∃, B∀, E, Ref ) with B∃ := S × S', B∀ := P(S × S'), Ref := Bω (i.e., all infinite matches are winning for
∃), while the edge relation E is given as follows:

in position (s, s') ∃ may choose any set Z ⊆ S × S' with (σ(s), σ'(s')) ∈ FZ;
in position Z ⊆ S × S', ∀ may choose any element (t, t') of Z.
We leave it to the reader to verify that
(s, s') ∈ Win∃(B) iff S,s ↔ S', s'.
The key observation for the direction from left to right is that the relation
Win∃(B) itself is a bisimulation between S and S. For the other direction, let
∃ choose, at an arbitrary position (t, t'), any bisimulation between S and S'
that links t to t', cf. Fact 2.1(3).
Definition 3.4 Let A = (A, aI, ∆, Ω) be an F-automaton, and let S = (S, σ) be an F-coalgebra. The acceptance game G(A, S) associated with A and S is the parity graph game (B∃, B∀, E, Ω) with
B∃ := A × S	∪ FA × FS B∀ := P(FA) × S ∪ P(A × S),

while E and Ω are given by the table below:

Finally, A accepts the pointed F-coalgebra (S, s) if (aI, s) is a winning position for ∃ in the game G(A, S).
In order to get an understanding of this game, consider an F-automaton A and an F-coalgebra S. Of all the positions in the game G = G(A, S), those in A × S are the basic ones — the other positions are just intermediate stages.
Roughly, one should see a pair (a, s) ∈ A × S as a situation in which the automaton is in state a, inspecting the point s of the coalgebra. The aim of


∃ is to show that this description ‘fits’; while the aim of ∀ is to convince her that this is not the case. Going into detail we first look at two special cases.
First suppose that the automaton A is deterministic. That is, there is a map δ : A → FA such that for each a ∈ A it holds that ∆(a) = {{δ(a)}}.
Now at any position (a, s) ∈ A × S of the game G, ∃ can only make one move, namely, to the position {(δ(a), s)} ∈ P(FA × S); after that, ∀ has no choice either: he has to move the pebble to (δ(a), σ(s)) ∈ FA × FS. Note that
this position is completely determined by the first position — hence the name ‘deterministic’. A position of the form (δ(a), σ(s)) is like the position (a, s) of the bisimulation game of Example 3.3: ∃ chooses a relation Z ⊆ A × S such
that (δ(a), σ(s)) ∈ FZ, after that, ∀ chooses a new pair (b, t) ∈ Z, and we are
back in one of the basic positions. So in the deterministic case, a parity au- tomaton itself can be represented as a ‘decorated’ F-coalgebra: apart from an initial state it also carries an acceptance condition Ω : A → ω. Likewise, the acceptance game G(A, S) for such an automaton is like a ‘decorated’ bisimula- tion game. But of course, much of the power of automata working on infinite
objects precisely stems from the intricacies of the ‘decorations’.
Now take the more general case in which we only know that A is solitary, and consider a position (a, s) ∈ A × S. Here ∃ has a real choice: she can
pick any singleton {α} from ∆(a) and move the pebble to position {(α, s)}∈ P(FA × S). After that, ∀s choice is forced: he must move the pebble to position (α, σ(s)) ∈ FA × S. Effectively then, at position (a, s) it is ∃ on her own who determines the later position (α, σ(s)) ∈ FA × S - this explains
why we call such an automaton ‘solitary’. Note that at positions of the form (α, σ(s)) ∈ FA × S the game proceeds as in the deterministic case, until another central position is reached.
Finally, we consider the most general case, in which A is an arbitrary automaton. Here it is still the aim to arrive, starting from a position (a, s) ∈ A × S, at a position (α, σ(s)) ∈ FA × S, but now ∃ and ∀ play a little ‘subgame’ in order to get there. In the version presented here, first ∃ makes a preselection, that is, she chooses some subset Ξ ⊂ FA; then ∀ picks an element ξ ∈ Ξ, and the new position is (ξ, σ(s)); from here, play proceeds as before. In this most general case we are thus dealing with an alternating automaton.

Variation: chromatic F-automata
The reader may not have recognized his or her favorite, or at least familiar, type of automaton in Definition 3.1. In particular, the transition function or relation of standard automata operating on (infinite) words or trees take input from an alphabet or set of labels. Here we briefly indicate how this can easily be incorporated into our approach.


Definition 3.5 Let F be an endofunctor on the category Set, and C an arbi- trary finite set of objects that we shall call colors. We let FC denote the functor FCS = C × FS. FC-coalgebras will also be called C-colored F-coalgebras.
Note that FC-coalgebras are pairs of the form S = (S, σ) with σ : S → C × FS. We use π1 and π2 to denote the two projection functions, and call π1σ(s) ∈ C the color of s.  Now obviously, we can use FC-automata for
recognizing FC-coalgebras, but the following definition seems to be more in line with standard usage in automata theory.
Definition 3.6 Let F be an R-standard endofunctor on Set. A chromatic F- automaton over C is a quintuple A = (A, aI, C, ∆, Acc) such that ∆ : A×C → PPFA (and A, aI, and Acc are as before).
Given such an automaton and an FC-coalgebra S = (S, σ), we define the acceptance game GC(A, S) in a very similar way as before, witnessed by the following table:

Example 3.7 Unfortunately, we do not have the space here for a detailed example. It is not very hard, however, to show that, say, non-deterministic Bu¨chi automata on C-labeled binary trees, can be represented as solitary,
chromatic Bu¨chi automata over C, for the binary tree functor BS = S × S.
It is also good to note that the differences between the two kinds of au- tomata for recognizing C-colored F-coalgebras are only superficial:
Proposition 3.8 FC-automata and chromatic F-automata over C recognize the same classes of pointed FC-coalgebras.
In fact, there are fairly direct procedures to turn an FC-automaton into an equivalent chromatic F-automaton over C, and vice versa. For lack of space we cannot go into the details.

Variation: logical automata
A different perspective on the step function ∆ of an F-automaton A is that for all states a, ∆(a) is a disjunction of conjunctions of elements of FA. In the
acceptance game we see that ∃ chooses between the disjuncts, and ∀ chooses between the conjuncts. This suggests the following generalization.


Definition 3.9 Given a set X, let DL(X) be the smallest collection of objects that includes X and contains P and P whenever P is a set of objects in DL(X).
Let F be an R-standard endofunctor on Set. A logical F-automaton is a quadruple A = (A, aI, ∆, Acc) with A, aI and Acc as before, and ∆ : A → DL(FA).
The acceptance game for this A is defined in a completely obvious way, making ∃ choose between disjuncts, moving from (  P, s) to (p, s) for some
position (p, s) with p ∈ P , until a position (α, s) is reached with α ∈ FA.
This generalization to logical automata is nice and useful, but it does not add any recognizing power to our automata:
Proposition 3.10 F-automata and logical F-automata recognize the same classes of pointed F-coalgebras.
The proposition can be proved using some standard game-theoretical ar- gumentation (basically, it just involves applying the distributive laws of dis- junction over conjunction, and vice versa).

Coalgebraic fixed point logic
Syntax
Definition 4.1 Let F be an R-standard endofunctor on Set, and let X be a set of objects to be called variables. Inductively we define, for each natural number n, the set µLF(X) of coalgebraic ﬁxed point formulas over X of depth
n:
µLF(X) is the smallest set S which contains T, ⊥, and all variables in X and satisfies (i) if p and q belong to S, then so do p ∧ q and p ∨ q; and (ii) if p belongs to S, then so do µx.p and νx.p, for each x ∈ X.

F
n+1
(X) is the smallest superset of µLF(X) containing the formula ∇π

for each π that belongs to FQ for some finite Q ⊆ µLF(X), which is closed
under the same formation rules (i) and (ii).

The union µLF(X) = 

n∈ω
µLF(X) is the set of all coalgebraic fixed point

formulas over X. Given a formula p ∈ µLF(X), we define the depth of p as
the least natural number n such that p ∈ µLF(X).
Quite often we have no reason to make the set X of variables explicit and so we will frequently write µLF rather than µLF(X).


Example 4.2 Our definition is intended to generalize that of the modal µ- calculus to arbitrary R-standard endofunctors on Set. Recall that the modal µ-calculus is a language for coalgebras for the functor FS = P(Prop)×P(S)Act, where Prop is some set of propositional variables and Act some set of atomic actions. In the formulation of the modal µ-calculus of Janin & Walukiewicz [9],
the modal operators ⟨a⟩ and [a] are replaced with a single connective ‘a → ·’ operating on finite sets of formulas: if Φ is a finite set of formulas, then a → Φ is a formula. The meaning of a → Φ can be expressed in terms of ⟨a⟩ and [a]: a → Φ is equivalent to  {⟨a⟩p | p ∈ Φ}∧ [a] {p | p ∈ Φ}. This is of course quite familiar in coalgebraic logic, and it would not be difficult to rephrase the language of Janin & Walukiewicz in such a way that a family of modal
operators remains, each expressing a condition of the form
   ±q ∧   (a → Φa)
q∈Prop	a∈Act
with ±q denoting either q or ¬q. Doing so, we would have brought the lan- guage of the modal µ-calculus exactly in the format of our definition.
Before we turn to the coalgebraic semantics of this language, there are a number of syntactic issues to be settled.
We start with the important observation that every coalgebraic fixed point formula comes with a unique construction tree; the key insight here is that every formula p comes with a unique, naturally defined set of ‘immediate

subformulas’. In case p is of the form ∇π ∈ µLF
this insight is based on

the fact that for all finite sets Q ⊆ µLF, and all π ∈ FQ there is a (unique)
smallest set Q' ⊆ µLF such that π ∈ FQ' — the existence of such a set easily follows from Fact 2.2. We leave it for the reader to give a formal definition
of construction trees; we do provide an explicit definition of the notion of subformula.
Definition 4.3 We will write q Œ p if q is a subformula of p. Inductively we define the set Sfor (p) of subformulas of p as follows:
Sfor (p)	:= {p}	if p ∈ {T, ⊥} ∪ X,
Sfor (p♥q) := {p♥q}∪ Sfor (p) ∪ Sfor (q) if ♥ ∈ {∧, ∨},
Sfor (ηx.p) := {ηx.p}∪ Sfor (p)	if η ∈ {µ, ν},
Sfor (∇π)  := {∇π}∪  p∈Base(π) Sfor (p),
where Base(π) denotes the smallest set Q such that π ∈ FQ; the elements of
Base(π) will be called the immediate subformulas of ∇π.
The following proposition can then be proved by a straightforward induc-


tion on the complexity of formulas.
Proposition 4.4 Every formula p ∈ µLF has ﬁnitely many subformulas.
Definition 4.5 The ﬁxed point operators µ and ν bind the variable that they occur with, everywhere in the subformula to which they are applied. This notion of binding is completely standard, and so are the definitions of the sets FVar (p) and BVar (p) of free and bound variables, respectively, of a formula
p ∈ µLF. The set Var (p) = FVar (p) ∪ BVar (p) denotes the collection of all
variables occurring in p, free or bound. As in first order logic, we will call a formula without free variables, a sentence.
A formula p ∈ µLF is called clean if no variable occurs both free and bound in p, and no two distinct occurrences of fixed point operators bind the same variable. Hence, in a clean formula p, with each x ∈ BVar (p) we may associate a unique subformula of p where x is bound; we will denote this formula as ηxx.qx, and call x a µ-variable if ηx = µ, and a ν-variable if ηx = ν. A formula p ∈ µLF is called guarded if every subformula ηx.q of p has the property that all occurrences of x inside q are within the scope of a ∇.
Now let p be a clean formula. We define the following relation FrOcc ⊆
BVar (p) × BVar (p):
FrOcc(x, y) : ⇐⇒ y occurs freely in FVar (qx),
and let ≤p⊆ BV (p) × BV (p) denote the transitive closure of the relation
FrOcc. This relation is called the dependency order of p.

Semantics
We now introduce the semantics of coalgebraic fixed point logic. Although we are primarily interested in the interpretation of sentences, we also need to worry about the semantics of formulas with free variables. For this purpose
we define the notion of an F-model over a set of variables.
Definition 4.6 Let F be an R-standard endofunctor on Set, and let X be a set of variables. An F-model over X is a triple (S, σ, V ) such that S = (S, σ) is an F-coalgebra, and V : X → P(S) is a valuation on S.
Given such a valuation on S, a variable x ∈ X and a subset T ⊆ S, we define the valuation V [x '→ T ] as the map given by V [x '→ T ](x) = T while V [x '→ T ](y) = V (y) for all variables y ∈ X that are distinct from x.
Of course, it would be more in style with the coalgebraic paradigm to present an F-model (S, σ, V ) as a coalgebra for the functor FP(X) (cf. Defini- tion 3.5). We follow the present approach because it seems to lend itself better
towards the treatment of fixed point operators.


Definition 4.7 Inductively we define the notion of truth, i.e., we define when a µLF(X)-formula p is true or holds at a state s of a coalgebra S = (S, σ) under the valuation V .
More precisely, we define a relation HV ⊆ S × µLF(X); when the pair (s, p) belongs to HV , we say that p is true at or holds in s ∈ S under the valuation V , and usually write S, V,s H p. We also use [· ] for the extension of a formula in a coalgebra: [p]]S,V := {s ∈ S | S, V,s H p}.
The clauses of the inductive truth definition are as follows:
S, V,s H T,
S, V,s /H ⊥
S, V,s H x	if s ∈ V (x)
S, V,s H p ∧ q if S, V,s H p and S, V,s H q,
S, V,s H p ∨ q if S, V,s H p or S, V,s H q,
S, V,s H µx.p if s ∈  {T ⊆ S | [[p]]S,V [x'→T ] ⊆ T },
S, V,s H νx.p if s ∈  {T ⊆ S | T ⊆ [[p]]S,V [x'→T ]},

S, V,s H ∇π	if (σ(s), π) ∈ F(HTBase(π) ),
where, in the last clause, the set HTBase(π) ⊆ S × µLF(X) is given as HTBase(π)
= H ∩ (S × Base(π)).
We say that a formula p is true throughout a model M = (S,V ), notation: M H p, if [[p]]M ⊆ S. A formula is valid, notation: |= p, if it is true throughout every model; two formulas p and q are called equivalent, notation: p ≡ q, if
[[p]]M = [[q]]M for every model M.
All clauses of this truth definition are completely standard, with the pos- sible exception of the one for ∇π. The standard definition from the literature (cf. Moss [11]) would require that S, V,s H ∇π if (σ(s), π) ∈ F(H). However,
given our definition of the language, and the assumption that the truth of
a formula should only depend on the interpretation of its immediate subfor- mulas, the truth definition of ∇π seems to be quite natural. We don’t know whether there are instances in which our definition would really deviate from Moss’.
Concerning the fixed point operators, it will be convenient to introduce some further terminology.
Definition 4.8 Let S be a set, and ϕ : P(S) → P(S) a map. A subset X ⊆ S is called a pre-ﬁxed point of ϕ if ϕ(X) ⊆ X, a post-ﬁxed point if X ⊆ ϕ(X), and a ﬁxed point if X = ϕ(X).


It then immediately follows from the definitions that the set [µx.p]]M is the intersection of the collection of all pre-fixed points of the map λX ⊆ S.[[p]]M[x'→X], while [νx.p]]M is the union of the collection of all post-fixed points of this map.

Basic semantic results
Before we can do anything interesting, there are some a few technicalities that we have to get out of the way. First, we need a Finiteness Lemma stating that the truth of a formula only depends on its free variables. We omit the proof for lack of space.
Proposition 4.9 (Finiteness) Let F be an R-standard endofunctor on Set, let Y ⊆ X be two sets of variables, and let (S, σ) be an F-coalgebra. Now suppose that V and V ' are two X-valuations on S such that V (y) = V '(y) for all y ∈ Y . Then for all p with FVar (p) ⊆ Y , and all s ∈ S it holds that
S, σ, V H p iff S, σ, V ' H p.
For sentences in particular, it follows from the previous proposition that it does not matter which valuation we take into consideration. This inspires the following definition.
Definition 4.10 Let F be an R-standard endofunctor on Set, p a µLF-sentence, S an F-coalgebra and s a point in S. Then we say that p is true at s in S, notation: S,s H p, if S, V,s H p for some valuation V , (or, equivalently, for all valuations V ).
Next we turn to the Monotonicity Lemma.
Proposition 4.11 (Monotonicity) Let F be an R-standard endofunctor on Set, X a set of variables, and S an F-coalgebra. Now suppose that V and V ' are two X-valuations on S such that V (x) ⊆ V '(x) for all x ∈ X. Then for all p with FVar (p) ⊆ X it holds that
[[p]]S,V ⊆ [[p]]S,V ' ,
that is: for all s ∈ S we have that S, σ, V H p only if S, σ, V ' H p.
Proof. This can be proved by a standard induction on the complexity of p. The proof in the inductive case of p = ∇π is based on the fact that F is monotone (Fact 2.1).	 
Remark 4.12 The Monotonicity Lemma justifies the terminology ﬁxed point in the name of our formalism: by the Knaster-Tarski Theorem in fixed point theory, every monotone operation ϕ on a complete lattice (such as a full power set) has a least and a greatest fixed point, and these can be obtained as the


intersection of the collections of pre-fixed points and post-fixed points of ϕ, respectively. In particular, for every formula p and every model M = (S, σ, V ), the set [µx.p]]M is the least fixed point of the operation λX ∈ P(S). [[p]]M[x'→X], and the set [νx.p]]M is the greatest fixed point of this operation.
Remark 4.13 It also follows from standard fixed point theory that least and greatest fixed points of monotone operations on complete lattices (such as full power set algebras) can be approximated by ordinal unfoldings. Using this, there is a nice connection between our coalgebraic fixed point logic, and more standard coalgebraic logics.
Let LF (X), the language of infinitary coalgebraic F-logic, be the smallest collection of formulas which includes the set {T, ⊥} ∪ X and satisfies (i) if β is

some ordinal, and {pα | α < β} is a set of LF (X)-formulas, then both 
α<β pα

and 

α<β
pα belong to LF (X), and (ii) if π belongs to FQ for some Q ⊆ S,

then ∇π belongs to S. Note that F-models, with the obvious interpretation
for  and  , form a natural semantics for this language.
Now for each ordinal α there is a translation tα mapping µLF-sentences to LF -formulas. This translation is defined as follows; first, we define, for any LF (X)-formula p, any variable x ∈ X, and any ordinal α, the formulas µα.p and ναx.p via transfinite induction:

µ0x.p := ⊥,
µα+1x.p := p[µαx.p/x], µλx.p :=  α<λ µαx.p,
Using these formulas, one puts
ν0x.p := T,
να+1x.p := p[ναx.p/x], νλx.p :=  α<λ ναx.p.

tαp	:= p	for p ∈ {T, ⊥} ∪ X, tα(p♥q) := tαp♥tαq	for ♥ ∈ {∧, ∨}, tα(ηx.p) := ηαx.tαp	for η ∈ {µ, ν},
tα(∇π)  := ∇(Ftα)(π).
Observe that tα translates µLF-sentences into variable-free LF -formulas.
One can show that these translations locally embed µLF inside LF , in the
following sense:
[[p]]M = [[tαp]]M, for any F-model M = (S, σ, V ) and any ordinal α > |S|+.
Note however, that in general, the ‘unfolding ordinal’ α of (2) depends on the size of the model M. Coalgebraic fixed point logic cannot be embedded in infinitary coalgebraic logic, as is known from the modal µ-calculus.
An important property of our coalgebraic fixed point logic is that truth


is bisimulation invariant. Using the appropriate notion of bisimulation for F-models this can be proven for arbitrary µLF-formulas, but here we state it just for sentences.
Proposition 4.14 Let S and S' be two F-coalgebras. Then for any bisimula- tion Z ⊆ S × S' and any two points s ∈ S, s' ∈ S' with (s, s') ∈ Z, and any µLF-sentence p it holds that
S,s H p iff S', s' H p.
Proof. A simple proof for this proposition uses the ordinal unfolding of Re- mark 4.13, and the easily established fact that truth of LF -sentences is a bisimulation invariant property.	 
We are now ready to state our last basic semantic result; for lack of space we have to omit the (fairly standard) proof.
Proposition 4.15 (Normal Form) Let F be an R-standard endofunctor on Set. Then every formula p ∈ µLF is equivalent to some clean, guarded formula p' of the same depth.
Game semantics
In this section we develop a game-theoretic characterization of the semantics of our coalgebraic fixed point logics, generalizing results on for instance the modal µ-calculus to a general coalgebraic framework.

Evaluation games
Given an F-model (S, σ, V ) and a coalgebraic fixed point formula q, we will define the evaluation game E = E(S, σ, p) as the following infinite two-player graph game.
Definition 5.1 Let F be an R-standard endofunctor on Set. Given an F- model M = (S, σ, V ) and a clean coalgebraic fixed point formula q, we first define the arena of the evaluation game E = E(M, q).
The board of E is given as the set
B = Sfor (q) × S ∪ P(Sfor (q) × S).
The partition of B into positions for ∃ and ∀, respectively, and the edge relation E of the graph are given by the table of Figure 1.
Note that positions of the form (x, s) or (ηx.p, s) have a unique successor, whence the moves that are made at such positions are completely determined. Thus it does not matter to which player these positions are assigned.



Fig. 1. Admissible moves in the evaluation game

In order to get some intuitions for this kind of game, the reader is advised to assign the following aims to the players. Basically, in a position (p, s) it is the aim of ∃ to show that p is actually true at s, while ∀ tries to convince her that this is not the case. This already explains the rules for positions of the
form (p, s) with p an atomic constant, a conjunction, or a disjunction. For instance, in (p1 ∨ p2, s), ∃ may win by winning either (p1, s) or (p2, s), because p1 ∨ p2 holds at s if either p1 or p2 does.
Each time during a match when the pebble moves from a position (x, s) to its successor (qx, s), we say that the fixed point variable x is unfolded. Roughly spoken, the intuition behind this is that the formula ηx.qx (represented by x) is equivalent to the formula qx[ηx.qx/x] (represented by qx). This applies to both
µ and ν-variables. The difference between the two kinds of fixed point variables only comes out in infinite matches. We need the following observation, which is not hard to see.
Proposition 5.2 Let F be an R-standard endofunctor on Set, q a clean µLF- formula and M an F-model. Then in any inﬁnite match β of the game E(M, q), the set of variables that are unfolded inﬁnitely often during β contains a max- imal member (in the dependency order).
Definition 5.3 Let F be an R-standard endofunctor on Set. Given an F- model M = (S, σ, V ) and a clean coalgebraic fixed point formula q, we now define the winning conditions of the evaluation game E = E(M, q).
Let β be a full match played on the arena of E, and let x be the highest ranking fixed point variable that got unfolded infinitely often during β. Then
β is winning for ∃ if either (i) β is finite and ∀ got stuck, or (ii) β is infinite and x is a ν-variable;
β is winning for ∀ if either (i) β is finite and ∃ got stuck, or (ii) β is infinite


and x is a µ-variable.

Adequacy of game semantics
The following theorem states that the evaluation games as introduced above, indeed constitute an equivalent characterization for the semantics of coalge- braic fixed point formulas.
Theorem 1 (Adequacy) Let F be an R-standard endofunctor on Set. Then for any µLF-formula q, any F-model (S, σ, V ) and any state s ∈ S it holds that
S, σ, V, s H q iff (q, s) ∈ Win∃(E(M, q)).

Automata and fixed point logic
The reader will have noticed the similarity between the evaluation game of a formula and the acceptance game of an automaton. But the connection is much tighter than a mere resemblance, witness the Theorem, which forms the main result of the paper:
Theorem 2 (Formulas are automata) Let F be an R-standard endofunc- tor on Set. Then any µLF-sentence q can be transformed into an F-automaton Aq such that for any pointed F-coalgebra (S, s):
S,s H q iff Aq accepts (S, s).
Unfortunately we cannot go into the details of the proof. Let us just men- tion that roughly, the first step of the proof is to turn p into a clean, guarded
equivalent p'. In the second and most important step of the construction we construct an automaton-like object based on the set Sfor (p) of subformulas of p, and in the next step this structure is tidied up into a logical automa-
ton as presented in Definition 3.9. The final step of the construction then simply consists of replacing this logical automaton with a standard one, as in Proposition 3.10.

Further research
We believe that it is interesting and useful to develop the automata theory for coalgebras on an (almost) arbitrary functor F : Set → Set, and to apply this theory to the study of coalgebraic fixed point logics. It is obvious that
in this paper we have only scratched the surface of these topics. Of the many questions that naturally arise I just mention the following.


As we already mentioned in the introduction, there are earlier studies of automata that are based on categories and functors, see for instance Ada´mek & Trnkova´ [1]. This connection clearly has to be investigated further.
Important issues in the theory of automata include the question whether a given automaton can be replaced with an equivalent one that satisfies some additional properties, and the closure properties of the class of rec-
ognizable languages (here defined in a broad sense). All such questions can be studied for other types of coalgebras, and from a general coal- gebraic perspective. It could be hoped that coalgebraic methods would
produce some new insights.
As particularly interesting questions in this line we mention the following: ‘determinization’ and ‘solitariﬁcation’ For which functors F can we re- place each solitary automata with an equivalent deterministic one,
and/or each alternating automata with an equivalent solitary one?
‘closure under complementation’ For which functors F, and which kinds of F-automata, can we find, for a given F-automaton A of the mentioned type, another F-automaton A of the same type, with the property that A recognizes precisely the complement of the class of pointed automata accepted by A?
Our parity F-automata have a coalgebraic shape themselves: the automa- ton A = (A, aI, ∆, Ω) can be represented as a pointed coalgebra over the functor FAutS = P(P(FS)) × ω.  This perspective clearly needs inves-
tigation – recall that the coalgebraic perspective on ordinary automata (operating on finite words) has already proven to be very enlightening, see Rutten [15].
Our definition of coalgebraic fixed point logic is only one out of many. In fact, fixed point operators may be added to any kind of language of coalgebraic logic. It would be good to see more case studies on coalgebraic fixed point logics from an automata-theoretic perspective. Related to one of the above questions, I would like to understand what happens if
we add negation to the language µLF discussed in section 4. But also,
the relation between the modal µ-calculus and a fixed point extension of the coalgebraic modal logics developed in Pattinson [12] might be an intriguing object of study.

References
J. Ad´amek and V. Trnkov´a. Automata and Algebras in Categories.	Kluwer Academic Publishers, 1990.



A. Baltag. A logic for coalgebraic simulation. In H. Reichel, editor, Coalgebraic Methods in Computer Science (CMCS’00), volume 33 of Electronic Notes in Theoretical Computer Science, pages 41–60, 2000.
A. Carboni, G. Kelly, and R. Wood. A 2-categorical approach to change of base and geometric morphisms I. Technical Report 90-1, Department of Pure Mathematics, University of Sydney, 1990.
E. Clarke, O. Grumberg, and D. Peled, editors. Model Checking. The MIT Press, 2000.
E.Graedel, W. Thomas, and T. Wilke, editors. Automata, Logic, and Inﬁnite Games, volume 2500 of LNCS. Springer, 2002.
B. Jacobs. Many-sorted coalgebraic modal logic: a model-theoretic study. Theoretical Informatics and Applications, 35(1):31–59, 2001.
B. Jacobs. Exercises in coalgebraic specification. In R. Backhouse, R. Crole, and J. Gibbons, editors, Algebraic and Coalgebraic Methods in the Mathematics of Program Construction, volume 2297 of LNCS, pages 237–280, Berlin, 2002. Springer.
B. Jacobs. The temporal logic of coalgebras via galois algebras. Mathematical Structure in Computer Science, 12:875–903, 2002.
D. Janin and I. Walukiewicz. Automata for the modal µ-calculus and related results. In Proc. 20th International Symposium on Mathematical Foundations of Computer Science (MFCS’95), volume 969 of LNCS, pages 552–562, Berlin, 1995. Springer.
A. Kurz.  A co-variety-theorem for modal logic.  In M. Zakharyaschev, K. Segerberg,
M. de Rijke, and H. Wansing, editors, Advances in Modal Logic 2. Center for the Study of Language and Information, Stanford University, 2001.
L. Moss. Coalgebraic logic. Annals of Pure and Applied Logic, 96:277–317, 1999. Erratum published APAL 99 (1999) 241–259.
D. Pattinson.  Semantical principles in the modal logic of coalgebras.  In H. Reichel and
A. Ferreira, editors, Proc. 18th International Symposium on Theoretical Aspects of Computer Science (STACS 2001), volume 2010 of LNCS, Berlin, 2001. Springer.
M.O. Rabin. Decidability of second-order theories and automata on infinite trees. Transactions of the American Mathematical Society, 141:1–35, 1969.
M. R¨oßiger. Coalgebras and modal logic. In H. Reichel, editor, Coalgebraic Methods in Computer Science (CMCS’00), volume 33 of Electronic Notes in Theoretical Computer Science, pages 299–320, 2000.

J. Rutten.  Automata and coinduction (an exercise in coalgebra).  In D. Sangiorigi and R. de Simone, editors, Proc. 9th International Conference on Concurrency Theory (CONCUR’98), volume 1466 of LNCS, pages 194–218. Springer, 1998.
J. Rutten. Relators and metric bisimulations. In B. Jacobs, L. Moss, H. Reichel, and J. Rutten, editors, Coalgebraic Methods in Computer Science (CMCS’98), volume 11 of Electronic Notes in Theoretical Computer Science, pages 257–263, 1998.
J. Rutten. Behavioural differential equations: a coinductive calculus of streams, automata, and power series. Theoretical Computer Science, 308:1–53, 2003.
