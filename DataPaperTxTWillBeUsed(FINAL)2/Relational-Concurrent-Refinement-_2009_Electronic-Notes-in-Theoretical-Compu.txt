

Electronic Notes in Theoretical Computer Science 259 (2009) 21–34
www.elsevier.com/locate/entcs

Relational Concurrent Refinement: Automata
John Derrick1
Department of Computer Science, University of Sheffield, Sheffield, UK
Eerke Boiten2
School of Computing, University of Kent, Canterbury, Kent, UK

Abstract
Data refinement in a state-based language such as Z is defined using a relational model in terms of the behaviour of abstract programs. Downward and upward simulation conditions form a sound and jointly complete methodology to verify relational data refinements. In models of concurrency, refinement takes a number of different forms depending on the exact notion of observation chosen, which can include the events a system is prepared to accept or refuse, or depend on explicit properties of states and transitions. In this paper we continue our program of deriving relational simulation conditions for behavioural notions of refinement by defining embeddings into the relational model that extend our framework to include various notions of automata based refinement.
Keywords: Data refinement, Z, simulations, automata-based refinements.


Introduction
The last 10 years have seen significant research effort in comparing notions of refine- ment in different models of specification and computation, particularly motivated by the desire to integrate specification languages that use different paradigms. In par- ticular, we have considered the integration of state-based and concurrent specifica- tion methods, and the introduction of relational verification methods for refinement into a concurrency context.
In a process algebra such as CSP [15] a system is defined in terms of actions (or events) which represent the interactions between a system and its environment. The exact way in which the environment is allowed to interact with the system varies

1 Email: J.Derrick@dcs.shef.ac.uk
2 Email: E.A.Boiten@kent.ac.uk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.12.015

between different semantics. Typical semantics are set-based, associating one or more sets with each process, for example traces, refusals, divergences. Refinement is then defined in terms of set inclusions and equalities between the corresponding sets for different processes. A survey of many prominent process algebraic refinement relations is given in [25].
In state-based systems, specifications are considered to define abstract data types (ADTs), consisting of an initialisation, a collection of operations and a finalisation, all of which are relations. A program over an ADT is a sequential composition of these elements, transforming a global visible state into another one via a sequence
of hidden local states. Refinement is defined to be inclusion of behaviour for all programs, and is normally verified through simulations [9]. For a complete method, often two kinds of simulations are defined: downward and upward simulations.
Research on combining relational and concurrent refinement concentrated ini- tially on providing joint semantics, and on identifying correspondences between variations of the relational models and concurrency semantics. In the latter cate- gory, see e.g. work by Bolton and Davies [6,7] and Reeves and Streader [19]. Our work on relational concurrent refinement started [5,10] from the powerful idea that the relational ﬁnalisations can encode the observations embedded in concurrency semantics. The relational simulation rules can then be used to extract simulations for concurrency. These provide a “canned induction” method of verifying concur- rent refinement, by checking a fixed number of conditions for each possible action, rather than checking inclusion between potentially large sets. We derived simula- tion rules for failures-divergences refinement [10], including also outputs and internal operations [4], and for readiness refinement [10]. These were mostly based on the total relations model (as described below). Trace refinement and other relations based on the partial relations model were considered in [11], and different interpre- tations of divergent behaviour in [3]. In all these cases, the refinement notions have been imported from a concurrency context, represented in a relational formalism, and then expressed in terms of Z data types. Thus it provides for an integration of paradigms by allowing specification using Z schemas and sets while adapting a concurrency-style semantics.
This paper continues the programme by considering concurrent refinement no- tions in the context of automata based specification. In Section 2 we provide the basic definitions and background. In Section 3 we introduced automata and IO automata, their refinement notions, and derive their relational simulation rules. We conclude in Section 4.

Background
This background section presents the standard refinement theory [12] for abstract data types in a relational setting. The relational model of data refinement where all operations are total, as described in the 1986 paper by He, Hoare and Sanders

[14], traditionally received the most attention. The standard refinement theory of Z [26,12], for example, is based on this version of the theory. However, later publications by He and Hoare, in particular [13], dropped the restriction to total relations, and proved soundness and joint completeness of the same set of simulation rules in the more general case. De Roever and Engelhardt [9] also present the partial relations theory, without putting much emphasis on this aspect.

A partial relational model
A program (defined here as a sequence of operations) is given as a relation over a global state G, implemented using a local state State. The initialisation of the pro- gram takes a global state to a local state, on which the operations act, a ﬁnalisation translates back from local to global. In order to distinguish between relational for- mulations (which use Z as a meta-language) and expressions in terms of Z schemas etc., we use the convention that expressions and identifiers in the world of relational data types are typeset in a sans serif font.
Definition 1 (Data type) A  (partial)  data  type  is  a  quadruple (State, Init, {Opi}i∈J , Fin). The operations {Opi }, indexed by i ∈ J , are rela- tions on the set State; Init is a total relation from G to State; Fin is a total relation from State to G. If the operations are all total relations, we call it a total data type.
Definition 2 (Program) For a data type D = (State, Init, {Opi}i∈J , Fin) a pro- gram is a sequence over J. The meaning of a program p over D is denoted by pD,
and deﬁned as follows. If p = ⟨p1, ..., pn⟩ then pD = Init o Opp o ... o Opp o Fin.
9	1 9	9	n 9
As usual we assume that the data types are conformal, i.e., they use the same index set for the operations.
Definition 3 (Data refinement) For data types A and C, C refines A, denoted A ±data C (dropping the subscript if the context is clear), iff for each program p over J, pC ⊆ pA.
Downward and upward simulations [9] form a sound and jointly complete [14,9] proof method for verifying refinements. In a simulation a step-by-step comparison is made of each operation in the data types, and to do so the concrete and abstract states are related by a retrieve relation.
Definition 4 (Downward simulation) Assume data types A = (AState, AInit,
{AOpi}i∈J , AFin) and C = (CState, CInit, {COpi}i∈J , CFin). A downward simula- tion is a relation R from AState to CState satisfying
CInit ⊆ AInit o R R o CFin ⊆ AFin
∀ i : J • R o COp ⊆ AOp o R
9	i	i 9
Any relational data types A and C in this paper are assumed to be defined as in the above definition (occasionally with extra conditions imposed).

Definition 5 (Upward simulation) For data types A and C, an upward simula- tion is a relation T from CState to AState such that
CInit o T ⊆ AInit CFin ⊆ T o AFin

∀ i : J • COp
o T ⊆ T o AOp

i 9	9	i

Totalisations
The natural encoding of particular programmes being “impossible”, e.g. leading to a deadlock, in the partial relational model is through the empty relation. However, a non-deterministic choice (union of relations) may then ensure that possible rather than certain erroneous behaviour is not observable at all – see [11] for a detailed discussion. Sticking with the core idea of relational concurrent refinement, this can be solved by observing more (e.g. refusals) at the end of a program as we have done elsewhere. A more traditional approach is to encode error behaviour explicitly in operations. This is often called “totalisation”, as it typically increases operations’ domains to become total, but here and elsewhere we also apply it resulting in relations that remain partial.
There are two main types of totalisation: the non-blocking (or non-strict, or chaotic) totalisation represents erroneous behaviour as leading to all possible states including a new error state; the blocking (or strict) totalisation maps error traces only to a “sink” state. The totalisations turn a partial relation on a set S into a
total relation on a set S⊥, which is S extended with a distinguished value ⊥ not in
S.
Definition 6 (Totalisation) For a partial relation Op on State, its totalisation is a total relation on State⊥, deﬁned in the non-blocking model by
^nb
Op	== Op ∪ {x, y : State⊥ | x /∈ dom Op • (x, y)}
or in the blocking model by
^b
Op == Op ∪ {x : State⊥ | x /∈ dom Op • (x, ⊥)}.
Characterisations of downward and upward simulations on these totalised rela- tions can be simplified to remove any reference to ⊥. This results in the standard definitions of downward and upward simulations for partial relations, see [12].
Although in this paper we explore the partial relation model, we will need, on occasion, elements of the kind of totalisation we have just described in order to give a relational counterpart to some of the refinement preorders we look at below.

Reﬁnement in Z
The definition of refinement in a specification language such as Z is usually based on the totalised framework just given. Specifically, a Z specification can be thought of as a data type, defined as a tuple (State, Init, {Opi }i∈J ). The operations Opi are defined in terms of (the variables of) State (its before-state) and State' (its

after-state). The initialisation is also expressed in terms of an after-state State'. In addition to this, operations can also consume inputs and produce outputs. As finalisation is implicit in these data types, it only has an occasional impact on specific refinement notions. If specifications have inputs and outputs, these are included in both the global and local state of the relational embedding of a Z specification. See [12] for the full details on this – in this paper we only consider data types without inputs and outputs. In concurrent refinement relations, inputs add little complication; outputs particularly complicate refusals as described in [4]. In a context where there is no input or output, the global state contains no
information and is a one point domain, i.e., G == {∗}, and the local state is State ==
State. In such a context the other components of the embedding are as given below.

Definition 7 (Basic embedding of Z data types) The Z data type (State,
Init, {Opi }i∈J ) is interpreted relationally as (State, Init, {Opi}i∈J , Fin) where
Init == {Init •∗ '→ θState'}
Op == {Op • θState '→ θState'}
Fin == {State • θState '→ ∗}
Given these embeddings, we can translate the relational refinement conditions of downward simulations for totalised relations into refinement conditions for Z ADTs, where we note that the finalisation conditions are always satisfied in this Z inter- pretation.
Definition 8 (Standard downward simulation in Z) Given Z data types A = (AState, AInit, {AOpi }i∈J ) and C = (CState, CInit, {COpi }i∈J ). The relation R on AState ∧ CState is a downward simulation from A to C in the non-blocking model if
∀ CState' • CInit ⇒ ∃ AState' • AInit ∧ R'
∀ i : J ; AState; CState • pre AOpi ∧ R ⇒ pre COpi
∀ i : J ; AState; CState; CState' • pre AOpi ∧ R ∧ COpi
⇒ ∃ AState' • R' ∧ AOpi In the blocking model, the correctness (last) condition becomes
∀ i : J ; AState; CState; CState' • R ∧ COpi ⇒ ∃ AState' • R' ∧ AOpi
and then the applicability (second) condition above is equivalent to
∀ i : J ; AState; CState • R ⇒ (pre AOpi ⇔ pre COpi )

Any Z data types A and C in this paper are assumed to be defined as in the above definition.
The translation of the upward simulation conditions is similar, however this time the finalisation produces a condition that the simulation is total on the concrete state.
Definition 9 (Standard upward simulation in Z) For Z data types A and C ,

the relation T on AState ∧ CState is an upward simulation from A to C in the non-blocking model if
∀ AState'; CState' • CInit ∧ T' ⇒ AInit
∀ i : J ; CState • ∃ AState • T ∧ (pre AOpi ⇒ pre COpi )
∀ i : J ; AState'; CState; CState' •
(COpi ∧ T') ⇒ (∃ AState • T ∧ (pre AOpi ⇒ AOpi ))
In the blocking model, the correctness condition becomes
∀ i : J ; AState'; CState; CState' • (COpi ∧ T') ⇒ ∃ AState • T ∧ AOpi

Process algebraic based reﬁnement
Process algebras [15,18,2] provide a means to describe and verify concurrent systems and processes, and provide operators such as synchronisation, communication, and various flavours of composition. The semantics of a process algebra is often given by means of a semantics which associates a labelled transition system (LTS) to each term. Varying how the environment interacts with a process leads to differing observations and these can be thought of as differing testing scenarios, and therefore different preorders (i.e., refinement relations) – an overview and comprehensive treatment is provided by van Glabbeek in [24,25]. We will need the usual notation for labelled transition systems (LTSs):
Definition 10 (Labelled Transition Systems (LTSs)) A labelled transition system is a tuple L = (States, Act , T, Init ) where States is a non-empty set of states, Init ⊆ States is the set of initial states, Act is a set of actions, and T ⊆ States × Act × States is a transition relation. The components of L are also accessed as states(L) = A and init (L) = Init.
Every state in the LTS represents a process itself – namely the one representing all possible behaviour from that point onwards. Specific notation needed includes the
usual notation for writing transitions as p −a→ q for (p, a, q ) ∈ T and the extension

of this to traces (written p −t→r
is defined as:
q ) and the set of enabled actions of a process which

next (p) = {a ∈ Act | ∃ q • p −a→ q}.
In [11] we showed how different process algebraic preorders can be embedded into the relational model. Here we review how this is achieved for the trace preorder which defines refinement as trace inclusion. In the next section, we provide that type of characterisation for each notion of automata refinement.
Definition 11 σ ∈ Act ∗ is a trace of a process p if ∃ q • p −σ→ q. T (p) denotes the set of traces of p. The trace preorder is deﬁned by p ±tr q iff T (q ) ⊆T (p).
As observed previously [10] the partial relations model records exactly trace information for the embedding with trivial finalisation in Definition 7: possible traces lead to the single global value; impossible traces produce the empty relation. To prove the correspondence between trace preorder and data refinement we need

to provide a definition of the traces of an abstract data type.
Definition 12 The traces of a Z data type (State, Init, {Opi }i∈J ) are all sequences

⟨i1,..., in ⟩ such that ∃ State' • Init o Opi
o ... o Opi
. We denote the traces of an

ADT A by T (A).
9	1 9	9	n

Then the following can be proved [11]:
Theorem 2.1 With the trace embedding, data reﬁnement corresponds to trace pre- order. That is, when Z data types A and C are embedded as A and C,
A ±data C iff T (C ) ⊆T (A)

On the basis of this result, we can extract the simulation rules that correspond to this notion of refinement from the partial relation simulations as applied to this embedding (i.e., without a totalisation in between). These are of course the rules for standard Z refinement but omitting applicability of operations, as used also e.g., in Event-B [1]. The conditions for a downward simulation in the partial relational model are (c.f. Definition 4):
CInit ⊆ AInit o R
R o CFin ⊆ AFin
∀ i : J • R o COp ⊆ AOp o R
9	i	i 9
The first and last of these are just the standard initialisation and correctness condi- tions, respectively. The finalisation condition in fact places no further requirements with the trace embedding. The same is true for upwards simulations, hence we have:
Definition 13 (Trace simulations in Z) Given Z data types A and C , the rela- tion R on AState ∧ CState is a trace downward simulation from A to C if
∀ CState' • CInit ⇒ ∃ AState' • AInit ∧ R'
∀ i ∈ J • ∀ AState; CState; CState' • R ∧ COpi ⇒ ∃ AState' • R' ∧ AOpi
The total relation T on AState ∧ CState is a trace upward simulation from A to C if
∀ AState'; CState' • CInit ∧ T' ⇒ AInit
∀ i : J • ∀ AState'; CState; CState' • (COpi ∧ T') ⇒ (∃ AState • T ∧ AOpi )

Automata based refinement
Automata [17] offer another perspective on refinement to those given by a process algebra or state-based context. In [17] Lynch and Vaandrager provide a comprehen- sive treatment of refinement for automata, defining a number of simulation defini- tions and results relating them. In this section we describe the relationship between automata based refinement and our relational characterisation, hence answering the question raised in [17] concerning their connection.
In Section 3.2 we subsequently consider IO-automata and thus provide a rela- tional characterisation for IO-automata refinement and a set of simulation rules.

Basic deﬁnitions
For our purposes automata are simply LTSs. We do not consider systems with internal evolution, thus there is no special element τ ∈ Act .
Lynch and Vaandrager use the trace preorder as the definition of refinement; simulations are then used to provide sound and jointly complete techniques. How- ever, slightly confusingly the term reﬁnement is also used in [17] to mean a restricted form of downward simulation. To remain consistent with the notation introduced above we use refinement to mean data refinement in a relational setting. Lynch and Vaandrager define simulations in the standard fashion, that is, use Definitions
and 5 transcribed into the framework of automata 3 . Thus we have (eliding some obvious quantification):
Definition 14 (Simulations for automata) Let A and C be automata. A down- ward simulation from A to C is a relation f over states(A) and states(C ) such that
If s ∈ init (A) then f (s) ∩ init (C ) /= ∅
If astate −a→ astate' and cstate ∈ f (astate)
then ∃ cstate' ∈ f (astate') • cstate −a→ cstate'.
An upward simulation from A to C is a total relation f over states(A) and states(C )
such that
If s ∈ init (A) then f (s) ⊆ init (C )
If astate −a→ astate' and cstate' ∈ f (astate')
then ∃ cstate ∈ f (astate) • cstate −a→ cstate'.

Along with many other results and examples, the standard soundness and joint completeness results are given for these simulations with respect to the trace pre- order.
Lynch and Vaandrager raise a number of questions regarding the relationship between the refinement theory and simulations given for automata and those for data refinement. In particular, they comment in [17]:
Surprisingly, the definition of refinement between data types is completely differ- ent from the definition of trace inclusion between automata: informally, one data type is refined by another if any program that uses the former would function at least as well using the latter.
Clearly, an important topic of future research is to study the connection between automata based simulation techniques and methods for data refinement.
As should be clear, the partial relational framework can be used to answer these questions. In particular, the most natural relational embedding of an automaton in that framework is the following.

3 Downward and upward simulations are called forward and backward simulations, respectively, as is some- times the case.

Definition 15 (Automata embedding) An	automaton	(states(A), Act , −→
, init (A)) has the following embedding into the relational model.
G == {∗}
State == states(A)
Init == {s : init (A) •∗ '→ s}

Opi
== {s, s' : states(A) | s −→i
s' • s '→ s'}

Fin == {s : states(A) • s '→ ∗}

As can easily be seen, with this embedding the definitions in Definition 14 are equivalent to the trace simulations described in Definition 13. This answers the query in [17] in the following way. The automata embedding in Definition 15 is equivalent to the trace embedding given in Definition 7. Furthermore, the au- tomata simulations are equivalent to the trace simulations (Definition 13). Thus with this embedding relational data refinement is trace inclusion (Theorem 2.1), and the ’completely different’ goes away, or put another way, with this automata embedding looking at consistency of program behaviour is the same as trace inclu- sion. The question for connections between automata based simulation techniques and methods for data refinement can now be seen as one of varying the embedding as has been described in this paper.

IO automata
IO automata [16] are a class of automata that distinguish explicitly between the input and output of a system, and thus share characteristics with both standard automata and state-based languages such as Z and B. In such a model the set of actions is partitioned into input and output actions. A particular computational interpretation is taken, viz: output actions are actions initiated by the system, while input actions are under the control of the environment. A system can never refuse to perform its input actions, and its output actions can never be blocked by the environment.
Since we are considering systems without internal evolution in this paper, IO automata do not differ from IO transition systems as discussed by Tretmans in [22], and we use the notation introduced there.
Definition 16 (Partitioned automaton; IO automata) A partitioned au- tomaton is a LTS where the set of actions Act is partitioned into input actions LI and output actions LU (LI ∪ LU = Act , LI ∩ LU = ∅). An IO automaton p is a partitioned automaton for which all input actions are always enabled in any state. That is, for all states p: ∀ a ∈ LI • p −a→ . The class of IO automata with input
and output actions LI and LU is denoted IOT S(LI , LU ).
Example 3.1 Four IO automata are given in Figure 1 (adapted from [22]), where LI = {but}, LU = {liq, choc}. Input actions are always enabled, but may have no effect in a particular state; where this occurs it is denoted graphically with a



q0	q1	q2	q3


but

but






liq


liq	choc
but







liq




Fig. 1. Four IO automata

self-loop without explicit label.

To define refinement between IOTSs we use the idea of refusals sets after a particular trace given in the definition below.
Definition 17 (Refusals after a trace) Let p be an LTS, σ a trace of p, and X ⊆ Act. Then p after σ ref X iff E q • p —σ→ q and X ∩ next (q ) = ∅
This was used in [11] to define conformance and extension, however, it can also be used to define the input-output testing relation, ±iot . It is defined via the notion of weakly quiescent traces, which are traces after which no more outputs are possible.
Definition 18 (Weakly quiescent traces, IOTS preorder) The weakly quies- cent traces of a partitioned LTS A are denoted by δ–traces(A), and consist of all the traces σ ∈ Act ∗ such that A after σ ref LU . The IOTS preorder is deﬁned for IOTSs A and C by: A ±iot C iff 7 (C ) ⊆7 (A) and δ–traces(C ) ⊆ δ–traces(A)
The definition of ±iot is the same as that given in [21,20] for IO-automata, which is shown to be equivalent to the quiescent trace preorder of [23]. Introducing internal actions gives rise to some minor differences between the definitions which we do not repeat here, see references given above for more details.
The following hold between the systems introduced above: q0 ±iot q1 but q1 /±iot
q0, q2 ±iot q1, q3 ±iot q1, but q1, q3 /±iot q2 and q1, q2 /±iot q3.

Relational characterisation of IOTS reﬁnement
The IOTS preorder can be defined for arbitrary partitioned LTSs, in which case it is usual to interpret these as under-specified IOTSs, where some input actions are not specified in some states. One might define an alternate relation, ±ioconf , specifically for partitioned LTSs. Another approach, given in [8], is to give a demonic semantics for process expressions. In this semantics a transition is added for each non-specified input, and after this transition any behaviour is possible. We will follow the latter approach here. We give a relational characterisation of ±iot , and in doing so derive

simulation rules for it. To do this we will use the partial relational framework, but with some elements of totalisation used to deal with the demonic process semantics. To define ±iot between arbitrary partitioned LTSs, we define A ±iot C iff A^ ±
C^ , where A^ is an appropriate relational embedding – i.e., rather than explicitly
constructing the IOTS representing its demonic semantics, we give its relational version directly. This relational embedding needs to totalise operations in LI to represent the fact that they are always enabled, and include a modification of LU
to represent the fact that after an unspecified input any behaviour is possible, and an appropriate finalisation to ensure subsetting of δ–traces. We thus make the following definition.
Definition 19 (IOTS embedding) A partitioned LTS L = (states, LI , LU , —→
, init ) is embedded into the relational model as L^ = (State, Init, {O^ pi }i∈LI ∪LU , Fin), where
G == {∗, LU }
State ==states ∪ {⊥}, where ⊥ /∈ states
Init == {g : G; s : init • g '→ s}

O^ pi
== —→
∪{⊥ '→ ⊥} ∪ {x : states, y : State | i ∈ LI ∧ x —→i
x '→ y}

Fin == {x : State • x '→ ∗}∪ {(⊥, LU )}
∪ {x : states | (∀ i ∈ LU • x —→i
) • x '→ LU }

Theorem 3.2 With the IOTS embedding, data reﬁnement corresponds to the IOTS preorder. That is, let A˜ denote the IOTS obtained by giving the partitioned LTS A a
demonic semantics, then A^ ± C^ iff 7 (C˜) ⊆7 (A˜) and δ–traces(C˜) ⊆ δ–traces(A˜).
Proof	The crucial point to note is that ∗ represents the observation of a trace, and LU the observation of a quiescent trace, i.e., we have that
(g, ∗) ∈ trAb ≡ tr ∈7 (A˜)
(g, LU ) ∈ trAb ≡ tr ∈ δ–traces(A˜)
The latter means that either A after tr ref LU , or tr contains an input action that was impossible in A (encoded in the pair (⊥, LU ) ∈ Fin).
Suppose A^ ± C^ , i.e., for all tr we have trCb ⊆ trAb .
Given tr ∈7 (C˜). Then we have (g, ∗) ∈ trCb ⊆ trAb . Thus tr ∈7 (A˜). Given tr ∈ δ–traces(C˜). Then (∗, LU ) ∈ trCb ⊆ trAb . Thus tr ∈ δ–traces(A˜).
Suppose that 7 (C˜) ⊆7 (A˜) and δ–traces(C˜) ⊆ δ–traces(A˜).
Consider a program tr . If trCb is empty (due to some output action being im-

possible in tr ) then trCb ⊆ trAb as required. If (g, ∗) ∈ trCb
then tr ∈ 7 (C˜). Thus

tr ∈ 7 (A˜) and consequently (g, ∗) ∈ trAb . If (g, LU ) ∈ trCb
Thus tr ∈ δ–traces(A˜) and consequently (g, LU ) ∈ trAb .
then tr ∈ δ–traces(C˜).

Thus trCb ⊆ trAb for any tr , and A^ ± C^
as required.	 

We can now extract the simulation rules that correspond to this notion of re- finement.

Simulations
We have embedded an IOTS into a partial relational model, but one augmented with both refusals and a distinguished element, ⊥. The downward simulation conditions for this data type are, of course:
CInit ⊆ AInit o R^
R^ o CFin ⊆ AFin
∀ i : I • R^ o C^Op ⊆ A^Op o R^
9	i	i 9
We will extract the underlying conditions in the usual fashion, however, one will obtain different conditions depending on whether an operation is in LI or LU .
First, the initialisation condition, which under the totalisation adds no extra constraints beyond normal. Second, if i ∈ LU , then O^ pi == Opi ∪ {(⊥, ⊥)}, so that
R^ o C^Op ⊆ A^Op o R^	iff	R o COp ⊆ AOp o R
9	i	i 9	9	i	i 9

Third, if i ∈ LI , then Oˆpi
is the non-blocking totalisation over states ∪ {⊥}, thus

R^ o C^Op ⊆ A^Op o R^	iff	(dom AOp D R) o COp ⊆ AOp o R	and
9	i	i 9	i	9	i	i 9
ran (dom AOpi D R) ⊆ dom COpi
Note, that for an IOTS (as opposed to an arbitrary partitioned LTS), input actions are always enabled, and thus in that case this correctness condition reduces to
R o COp ⊆ AOp o R for LI .
9	i	i 9
Finally, the finalisation condition adds in the condition to check for refusals as needed for δ–trace inclusion. So R^ o CFin ⊆ AFin will become
∀ R • (∀ i ∈ LU • ¬ pre COpi ) ⇒ (∀ i ∈ LU • ¬ pre AOpi )
That is, if states are linked by the retrieve relation and C refuses output actions, then so must A.
For upwards simulations, we use a similar line of reasoning to find that one requires the standard initialisation, blocking correctness for output actions, non- blocking applicability and correctness for input actions together with the refusal condition
∀ CState • (∀ i ∈ LU • ¬ pre COpi ) ⇒ E AState • T ∧ (∀ i ∈ LU • ¬ pre AOpi )
which can be combined with the usual totality of upward simulation to give
∀ CState • E AState • T ∧ ((∀ i ∈ LU • ¬ pre COpi ) ⇒ (∀ i ∈ LU • ¬ pre AOpi )) These are summarised in the following definition.
Definition 20 (IOTS simulations in Z) Given Z data types A and C , both rep- resenting partitioned LTSs, J = LI ∪ LU . The relation R on AState ∧ CState is an IOTS downward simulation from A to C if
∀ CState' • CInit ⇒ E AState' • AInit ∧ R'
∀ i : LU ; AState; CState; CState' • R ∧ COpi ⇒ E AState' • R' ∧ AOpi
∀ i : LI ; AState; CState • pre AOpi ∧ R ⇒ pre COpi
∀ i : LI ; AState; CState; CState' • pre AOpi ∧ R ∧ COpi
⇒ E AState' • R' ∧ AOpi
∀ R • (∀ i : LU • ¬ pre COpi ) ⇒ (∀ i : LU • ¬ pre AOpi )

The relation T on AState ∧ CState is an IOTS upward simulation from A to C
if
∀ AState'; CState' • CInit ∧ T' ⇒ AInit
∀ i : LU ; AState'; CState; CState' • (COpi ∧ T') ⇒ (E AState • T ∧ AOpi )
∀ i : LI ; CState • E AState • T ∧ (pre AOpi ⇒ pre COpi )
∀ i : LI ; AState'; CState; CState' •
(COpi ∧ T') ⇒ (E AState • T ∧ (pre AOpi ⇒ AOpi ))
∀ CState • E AState • T ∧ ((∀ i : LU • ¬ pre COpi ) ⇒ (∀ i : LU • ¬ pre AOpi ))

Angelic process semantics
Above we used a totalisation to define ±iot between an LTS and an IOTS, specifi- cally the demonic process semantics discussed in [8]. An alternative view of under- specified input actions is that the under-specification represents an implicit skip. Such an interpretation was introduced in [23] and discussed in [8], where it is called the angelic process semantics.
The relational embedding of such a semantics only alters the input action com- ponent from that we defined above. Thus, when deriving simulation conditions for such an embedding, the initialisation, refusal conditions and correctness for output actions remain the same.
For input actions, they are embedded as

O^ pi
== Opi
∪ {(state, state) | state /—→i }

and the downward simulation condition
R^ o C^Op ⊆ A^Op o R^
9	i	i 9
evaluates to
R o (COp ∪ (dom COp D skip)) ⊆ (AOp ∪ (dom AOp D skip)) o R
9	i	i	i	i	9
However, this does not have a particular interesting simplification.

4	Conclusions
This paper has explored the relation between automata based refinement and no- tions of refinement for relational data types and process algebras. The notions of trace refinement and basic refinement for automata were shown to coincide through sharing the same sound and complete set of simulation rules. Refinement for IO automata (IO transition systems [22]) was shown to be different from any refine- ment relation considered so far in our relational concurrent refinement programme [10,4,11,3]. This was due to the separation of input and output actions, requiring a different treatment in refinement, each sharing some characteristics with previously considered methods of “totalising” operations.

References
Abrial, J.-R., D. Cansell and D. M´ery, Refinement and reachability in event-B, in: H. Treharne, S. King,
M. C. Henson and S. A. Schneider, editors, ZB, Lecture Notes in Computer Science 3455 (2005), pp.

222–241.
Bergstra, J. A., A. Ponse and S. A. Smolka, editors, “Handbook of Process Algebra,” Elsevier Science Inc., New York, NY, USA, 2001.
Boiten, E. and J. Derrick, Modelling divergence in relational concurrent refinement, in: M. Leuschel and H. Wehrheim, editors, IFM 2009: Integrated Formal Methods, LNCS 5423 (2009), pp. 183–199.
URL http://www.cs.kent.ac.uk/pubs/2009/2838
Boiten, E., J. Derrick and G. Schellhorn, Relational concurrent refinement II: Internal operations and outputs, Formal Aspects of Computing 21 (2009), pp. 65–102.
URL http://www.cs.kent.ac.uk/pubs/2007/2633
Boiten, E. A. and J. Derrick, Unifying concurrent and relational refinement, ENTCS 70 (2002), proceedings REFINE’02, Editors: J. Derrick, E. A. Boiten, J. von Wright and J. C. P. Woodcock.
Bolton, C. and J. Davies, Refinement in Object-Z and CSP, in: M. Butler, L. Petre and K. Sere, editors,
Integrated Formal Methods (IFM 2002), Lecture Notes in Computer Science 2335 (2002), pp. 225–244.
Bolton, C. and J. Davies, A singleton failures semantics for Communicating Sequential Processes, Formal Aspects of Computing 18 (2006), pp. 181–210.
de Nicola, R. and R. Segala, A process algebraic view of I/O automata, Theoretical Computer Science
138 (1995), pp. 391–423.
de Roever, W.-P. and K. Engelhardt, “Data Refinement: Model-Oriented Proof Methods and their Comparison,” CUP, 1998.
Derrick, J. and E. Boiten, Relational concurrent refinement, Formal Aspects of Computing 15 (2003),
pp. 182–214.
Derrick, J. and E. Boiten, More relational refinement: traces and partial relations, Electronic Notes in Theoretical Computer Science 214 (2008), pp. 255–276, proceedings of REFINE 2008 (Turku, May 2008). URL http://www.cs.kent.ac.uk/pubs/2008/2722
Derrick, J. and E. A. Boiten, “Refinement in Z and Object-Z,” Springer-Verlag, 2001.
He Jifeng and C. A. R. Hoare, Prespecification and data refinement, in: Data Refinement in a Categorical Setting, Technical Monograph, number PRG-90, Oxford University Computing Laboratory, 1990 .
He Jifeng, C. A. R. Hoare and J. W. Sanders, Data refinement refined, in: B. Robinet and R. Wilhelm, editors, Proc. ESOP 86, Lecture Notes in Computer Science 213 (1986), pp. 187–196.
Hoare, C. A. R., “Communicating Sequential Processes,” Prentice Hall, 1985.
Lynch, N. and M. Tuttle, An introduction to input/output automata, CWI quarterly 2 (1989), pp. 219– 246.
Lynch, N. and F. Vaandrager, Forward and backward simulations I.: untimed systems, Information and Computation 121 (1995), pp. 214–233.
Milner, R., “Communication and Concurrency,” Prentice-Hall, 1989.
Reeves, S. and D. Streader, Data refinement and singleton failures refinement are not equivalent, Formal Aspects of Computing 20 (2008), pp. 295–301.
Segala, R., Quiescence, fairness, testing, and the notion of implementation (extended abstract), in:
International Conference on Concurrency Theory, 1993, pp. 324–338.
Segala, R., Quiescence, Fairness, Testing, and the Notion of Implementation, Information and Computation 138 (1997), pp. 194–210.
Tretmans, J., Test Generation with Inputs, Outputs, and Quiescence, in: T. Margaria and B. Steffen, editors, Second Int. Workshop on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’96), Lecture Notes in Computer Science 1055 (1996), pp. 127–146.
Vaandrager, F. W., On the relationship between process algebra and input/output automata, in: Logic in Computer Science, 1991, pp. 387–398. URL citeseer.ist.psu.edu/vaandrager91relationship.html

van Glabbeek, R. J., The linear time - branching time spectrum, in: J. C. M. Baeten and J. W. Klop, editors, CONCUR 90, Lecture Notes in Computer Science 458 (1990), pp. 278–297.
van Glabbeek, R. J., The linear time - branching time spectrum I. The semantics of concrete sequential processes, in: J. Bergstra, A. Ponse and S. Smolka, editors, Handbook of Process Algebra, North-Holland, 2001 pp. 3–99.
Woodcock, J. C. P. and J. Davies, “Using Z: Specification, Refinement, and Proof,” Prentice Hall, 1996.
