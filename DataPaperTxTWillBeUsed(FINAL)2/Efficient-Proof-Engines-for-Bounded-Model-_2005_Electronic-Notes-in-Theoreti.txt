Electronic Notes in Theoretical Computer Science 133 (2005) 119–137 
www.elsevier.com/locate/entcs


Efficient Proof Engines for Bounded Model Checking of Hybrid Systems
Martin Fr¨anzle1 ,3
Informatics and Mathematical Modelling, The Technical University of Denmark, Richard Petersens Plads, Bldg. 322, DK-2800 Kgs. Lyngby, Denmark
Christian Herde2 ,3
Department of Computing Science, Carl-von-Ossietzky Universita¨t Oldenburg, P.O. Box 2503, D-26111 Oldenburg, Germany

Abstract
In this paper we present HySat, a new bounded model checker for linear hybrid systems, incorpo- rating a tight integration of a DPLL–based pseudo–Boolean SAT solver and a linear programming routine as core engine. In contrast to related tools like MathSAT, ICS, or CVC, our tool exploits all of the various optimizations that arise naturally in the bounded model checking context, e.g. iso- morphic replication of learned conflict clauses or tailored decision strategies, and extends them to the hybrid domain. We demonstrate that those optimizations are crucial to the performance of the tool.
Keywords: verification, bounded model checking, hybrid systems, infinite-state systems, decision procedures, satisfiability.


Introduction
During the last ten years, formal verification of digital systems has evolved from an academic subject to an approach accepted by the industry, with

1 Email: mf@imm.dtu.dk
2 Email: christian.herde@informatik.uni-oldenburg.de
3 This work was partly supported by the German Research Council (DFG) as part of the Transregional Collaborative Research Center “Automatic Verification and Analysis of Complex Systems” (SFB/TR 14 AVACS). See www.avacs.org for more information.


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.08.061


dozens of commercial tools now available and used by major companies. Among the most successful methods in formal verification of discrete systems is bounded model checking (BMC), as suggested by Groote et al. in [17] and by Biere et al. in [9]. The idea of BMC is to encode the next–state relation of a system as a propositional formula, unroll this to some given finite depth k, and to aug- ment it with a corresponding finite unravelling of the tableau of (the negation of) a temporal formula in order to obtain a propositional SAT problem which is satisfiable iff an error trace of length k exists. Enabled by the impressive gains in performance of propositional SAT checkers in recent years, BMC can now be successfully applied even to very large finite-state designs.
Though originally formulated for discrete transition systems only, the basic idea of BMC to reduce the search for an error path to a satisfiability problem of a formula also applies to hybrid discrete–continuous systems. However, the BMC formulae arising from such systems are no longer purely propositional, but usually comprise complex Boolean combinations of arithmetic constraints over real-valued variables, thus entailing the need for new decision procedures to solve them.
Our tool HySat provides a decision procedure that is tailored to fit the needs of BMC of infinite–state systems with piecewise linear variable updates,
e.g. of linear hybrid automata. HySat tightly integrates a state–of–the–art Davis–Putnam style SAT solver for pseudo–Boolean constraints with a linear programming routine, combining the virtues of both methods: Linear pro- gramming adds the capability of solving large conjunctive systems of linear inequalities over the reals, whereas the SAT solver accounts for fast Boolean search and efficient handling of disjunctions.
The idea to combine algorithms for SAT with decision procedures for con- junctions of numerical constraints in order to solve arbitrary Boolean com- binations thereof has been pursued by several groups. A tight integration of a resolution based SAT checker with linear programming has first been pro- posed and successfully applied to planning problems by Wolfman and Weld [30]. More recently, Audemard et al. [3] have followed up with MathSAT, a tool combining SAT solving with a Bellman–Ford algorithm for difference logic constraints and a simplex algorithm for general linear constraints, used for applications in the context of temporal reasoning and model checking of timed automata. Tools supporting a more general class of formulae are CVC
[6] and ICS [15], both integrating decision procedures for various theories, in- cluding Boolean logic, linear real arithmetic, uninterpreted function symbols, functional arrays, and abstract data types.
However, except for HySat, all tools mentioned above lack some or all of the particular optimizations that arise naturally in the bounded model check-


ing context. As observed by Shtrichman [26], BMC yields SAT instances that are highly symmetric as they comprise a k–fold unrolling of the systems tran- sition relation. This special structure can be exploited to accelerate solving,
e.g. by copying the explanation for a conflict which was encountered during the backtrack search performed by the SAT solver, to all isomorphic parts of the formula in order to prune similar conflicts from the search tree. This technique, in the following referred to as isomorphy inference, has been shown to yield considerable performance gains when performing BMC with propo- sitional SAT engines. To the best of our knowledge, HySat is the first solver that extends isomorphy inference accross transitions, as well as other domain– specific optimizations described in [26], to the hybrid domain. We will show that, compared to purely propositional BMC, similar or even higher perfor- mance gains can be accomplished within this context. The reason is that an inference step in the hybrid domain is computationally much more expensive than in propositional logic, as now richer logics have to be dealt with.
The paper is organized as follows. In the following two sections we explain the logical language solved by our SAT checker and review briefly how a linear hybrid automaton can be translated into a predicative formula suitable for bounded model checking. In section 4 we explain in detail the algorithmic ingredients of HySat. In particular, we discuss the BMC–specific optimizations implemented in our tool. In section 5 we report some experimental results, and section 6 draws conclusions and describes directions for future research.

The logics
As we are aiming at automated state-exploratory analysis of linear hybrid au- tomata [20,19] without prior finite-state abstraction, HySat addresses satisfia- bility problems in a two-sorted logics entailing Boolean-valued and real-valued variables. When encoding properties of linear hybrid automata, the Boolean variables are used for encoding the discrete state components, while the real variables represent the continuous state components.
The formulae are actually propositional, being conjunctions of linear zero- one constraints [16] (also known as pseudo-Boolean constraints [7]) for the Boolean part and of guarded linear constraints [30] for the real-valued part:
formula ::= {clause ∧}∗clause
clause ::= linear ZO constraint | boolean var =⇒ linear constraint
Here, linear constraint denotes a conjunction of linear inequalities over real- valued variables, i.e. the constraint part of an arbitrary linear program, while linear ZO constraint denotes a linear inequality over Boolean-valued vari- ables. The reason for using linear zero-one constraint clauses instead of, e.g.,


disjunctive clauses (like in conjunctive normal forms) is that linear zero-one constraints are much more concise than disjunctive clauses and that we have a very efficient SAT solver —called “Goblin” [16]— for such constraint systems, yielding the base engine for HySat.


Zero-one linear constraints
Rewriting arbitrary propositional formulae to conjunctive normal form (CNF) yields a worst-case exponential blowup in formula size if the number of propo- sitional variables is to be preserved. To avoid this, all practical verification environments take advantage of satisfiability-preserving transformations that yield linear-size encodings through introduction of a linear number of auxil- iary variables [27,25,28]. The price for introducing a linear number of auxil- iary variables is, however, a worst-case exponential blow-up in the size of the search tree upon backtrack search. Yet, it has been observed that both causes of blow-up can often be avoided, as the Davis-Putnam-Loveland-Logemann search procedure for satisfying valuations generalizes smoothly to zero-one linear constraint systems (ZOLCS), which are the constraint parts of zero-one linear programs [7,29,2,16]. Zero-one linear constraint systems are expressive enough to facilitate a linear-size encoding of, e.g., gate-level netlists without use of auxiliary variables.
In a zero-one linear constraint system or linear pseudo-Boolean constraint systems, formulae are conjunctions of linear zero-one constraints. A linear zero-one constraint is of the form a1x1 + a2x2 + ... anxn ≥ k, where the xi are literals, i.e. positive or negated propositional variables, the ai are natu- ral numbers, called the weights of the individual literals, and k ∈ N is the threshold.
Given a Boolean valuation of the propositional variables, a zero-one con- straint is satisfied iff its left hand side evaluates to a value exceeding the threshold when the truth values false and true of the literals are identified with 0 and 1, respectively. Zero-one constraints can represent a wide class of monotonic Boolean functions, e.g. 1a + 1b + 1c + 1d ≥ 1 is equivalent to a ∨ b ∨ c ∨ d, 1a + 1b + 1c + 1d ≥ 4 is equivalent to a ∧ b ∧ c ∧ d, and 1a + 1b + 3c + 1d ≥ 3 is equivalent to c =⇒ (a ∧ b ∧ d). Consequently, ZOLCS can be exponentially more concise than CNF: a CNF expressing that at least


n k
in k and logarithmic in n.
k
, whereas the corresponding ZOLCS has size linear

Formally, the syntax of linear zero-one constraints is

linear ZO constraint ::= linear term ≥ threshold
linear term ::= {weight literal +}∗weight literal weight ::∈ N

literal ::= boolean var | boolean var boolean var ::∈ BV
threshold ::∈ N
where BV is a countable set of Boolean variable names.
Zero-one constraints are interpreted over Boolean valuations σB : BV −to→tal B of the propositional variables. σB satisfies a constraint a1x1 + a2x2 + ... anxn ≥ k iff a1χσB (x1)+ a2χσB (x2)+ ... anχσB (xn) ≥ k, where
⎧⎪⎨ 0	if x ∈ V and σB(x)= false,
	
⎪ 1 − χσB (y) if x ≡ y for some y ∈ V.
Guarded linear constraints
Zero-one constraints can only express constraints on Boolean variables. A sec- ond kind of clauses in our logics is Boolean-guarded linear constraints which express (linear) constraints between real-valued variables, as well as their in- terdependence with the Boolean valuation. A guarded linear constraint simply is an implication
boolean var =⇒ linear constraint
between a Boolean variable and a linear constraint over real-valued variables,
i.e. a conjunction of linear inequations. Such a guarded linear constraint is
interpreted over a valuation σ = (σB, σR) ∈ (BV −to→tal B) × (RV −to→tal R), where
RV is the set of real variables occurring in linear constraints. The guarded linear constraint v =⇒ c is satisfied by σ = (σB, σR) iff σR satisfies the linear constraint c or if σB(v)= false.
Satisfaction of formulae
A formula φ is a conjunction of linear zero-one constraints and of guarded linear constraints and is thus interpreted over valuations


total
σ = (σB, σR) ∈ (BV −→	) × (RV
−to→tal R) .

Obviously, φ is satisfied by σ = (σB, σR), denoted σ |= φ, iff all linear zero-one constraints in φ are satisfied by σB and all guarded linear constraints in φ are


x

5


0
5	10	15	20	t
Fig. 1. A linear hybrid automaton and a sample trajectory. lx and ux denote the lower and upper bounds on the slope of x in the corresponding states, while x ≤ 10 and x ≥ 4 are state invariants constraining x itself.

satisfied by (σB, σR).
When solving satisfiability problems of formulae with Davis-Putnam-like procedures, we will build valuations incrementally such that we have to reason

about partial valuations ρ ∈ (BV
part
−→ B) × (RV
part
−→ R) of variables. We say

that a variable v ∈ BV ∪ RV is unassigned in ρ iff v /∈ dom(ρB) ∪ dom(ρR). A partial valuation ρ is called consistent for a formula φ iff there exists a total

extension σ : (BV
−to→tal B) × (RV
−to→tal R) of ρ that satisfies φ. Otherwise, we

call ρ inconsistent for φ. Furthermore, a partial valuation ρ is said to satisfy φ iff all its total extensions satisfy φ. As this definition of satisfaction agrees with the previous one on total valuations, we will use the same notation ρ |= φ for satisfaction by partial and by total valuations.

Predicative encoding of linear hybrid automata
A linear hybrid automaton A = (Σ,T, R, inv, l, u, m, g, ass, init), as depicted in Fig. 1, consists of
a finite set Σ of locations,
a finite set T of transitions,
a finite set R of continuous state components,
a family inv = (invσ)σ∈Σ of state invariants, where each state invariant invσ
is a linear predicate over R which constrains the valuations of the continuous state components when control resides in the discrete location σ,
two families l = (lσ,x)σ∈Σ,x∈R and u = (uσ,x)σ∈Σ,x∈R assigning two each location σ ∈ Σ and each continuous state component x ∈ R the minimum and maximum slope of x while control resides in location σ. The individual lσ,x are constants in Q ∪ {−∞} and similarly uσ,x ∈ Q ∪ {∞}.

a mapping m :
total
T −→ Σ assigning to each transition the pair of source and

sink state of the transition,
a family g = (gt)t∈T assigning to each transition a transition guard enabling that transition, where the transition guard is a linear predicate over R,


a family ass = (asst)t∈T assigning to each transition a (possibly nondeter- ministic) assignment which is a linear predicate over R and R', where R' denotes primed variants of the state components in R. The interpretation is that undecorated state components x ∈ R refer to the state immediately before the transition, while the primed variant x' ∈ R' refers to the state immediately thereafter.
a family init = (initσ)σ∈Σ of initial state predicates, where each initσ is a linear predicate over R which constrains the valuations of the continuous state components when control resides initially in the discrete location σ. 4
Hybrid automata engage in an alternation of continuous evolutions and dis- crete transitions. A continuous evolution of A = (Σ,T, R, inv, l, u, m, g, ass, init ) can be represented by a tuple (σ, x, δ, x') consisting of a discrete state σ ∈ Σ

the automaton resides in, a source continuous state x ∈ (R −to→tal
R) and a

target continuous state x' ∈ (R
−to→tal
R), as well as a duration δ ∈ R≥0.

Such a tuple is a continuous evolution of A iff for each y ∈ R it holds that x'(y) ≥ x(y)+lσi,y ·δ and x'(y) ≤ x(y)+uσi,y ·δ, and both x and x' satisfy invσ. Thus, δ represents the duration of A residing in state σ, and all continuous variables y evolve according to their slope bounds, and the invariant is true in the start and the end state (and thus, by convexity, in between). Similarly, an immediate transition can be represented by a tuple (σ, x, σ', x') consisting of a discrete source state σ ∈ Σ and a discrete target state σ', plus a continuous

source state x ∈ (R −to→tal
R) and a continuous target state x' ∈ (R −to→tal
R).

Such a tuple is an immediate transition iff there is a transition t ∈ T with m(t) = (σ, σ') such that x satisfies gt and such that asst is satisfied if x is substituted for the variables in R and x' is substituted for the variables in R'.
A run r = ⟨(σ0, x0, δ0, x'0),... , (σn, xn, δn, x'n)⟩∈ (Σ×(R −to→tal R) ×R	×
(R −to→tal R))∗ is a sequence of continuous evolutions of A linked by immediate transitions and grounded in a viable initial state. I.e., a run r satisfies the following properties:
Initialization: x0 satisfies initσ0 .
Progression by continuous evolution: for all i, the tuple (σi, xi, δi, x'i) is a continuous evolution of A.
Progression by immediate transitions: the tuple (σi, x'i, σi+1, xi+1) is an immediate transition of A for all i < n.
In order to perform bounded model checking (BMC) [9] with HySat, i.e. checking of validity of temporal properties on finite unrollings of a transition system, we need to encode all runs of a given length k ∈ N in HySat’s logics.

4 A discrete location σ not to be taken initially takes the predicate init σ = false.


There are various ways of doing this, all with specific strengths and weak- nesses. Yet all the reasonable ones share the property of featuring a plethora of structurally similar sub-formulae stemming from the iterated application of the transition relation and from the iterated continuous evolution in the k-fold unrolling. In order to exemplify this, we present here one particular form of such an unrolling which is very similar to the one used by Audemard et al. for MathSAT-based BMC of linear hybrid automata [4] and by Bemporad et al. for MILP-based BMC of linear hybrid automata [8].
Let A = (Σ,T, R, inv, l, u, m, g, ass, init) be a linear hybrid automaton. In order to encode a transition sequence of A of some given length k ∈ N, we proceed as follows:
For each discrete state σ ∈ Σ we take k + 1 Boolean variables σi, with 0 ≤ i ≤ k. The value of σi encodes whether the automaton A is in state σ in step i. Here, we take “one-hot” encoding, i.e. σi = true iff A is in state σ in step i. With one-hot encoding, there consequently is, for any i ≤ k, exactly one σ ∈ Σ such that σi holds, which is enforced in the BMC formula by the 2k + 2 linear zero-one constraints




i =0
 Σσ∈Σ

1σi ≤ 1


∧
i=0
 σΣ∈Σ


1σi ≥ |Σ|− 1

For each transition t ∈ T we take k Boolean variables ti, with 1 ≤ i ≤ k. The value of ti encodes via one-hot encoding whether the ith move in the run is transition t. Wellformedness of the unrolling in the sense that exactly one transition is taken in each step is guaranteed by conjunctively adding the 2k linear zero-one constraints




i =1
to the formula.
 Σt∈T

1ti ≤ 1


∧
i=1

 Σt∈T


1ti ≥ |T |− 1

For each continuous state component x ∈ R we take k + 1 real-valued variables xi and another k + 1 real-valued variables x'i, with i ≤ k. The value of xi encodes the value of x immediately after the ith transition in the run, whereas x'i represents the value immediately before transition (i + 1). For each i ≤ k we do, furthermore, take one real-valued variable δi representing the time spent in the ith state of the run. This allows us to formalize the continuous evolutions by conjoining the guarded linear constraint
σi =⇒ (x'i ≥ xi + lσ,xδi ∧ x'i ≤ xi + uσ,xδi)


for each σ ∈ Σ and each i ≤ k to the formula. 5 Furthermore, we have to keep track of the state invariants, which are enforced by the guarded linear constraints
σi =⇒ (invσi [xi ,... , xi /x1,... , xn] ∧ invσi [x'i,... , x'i/x1,... , xn]) ,
1	n	1	n
where {x1,... , xn} = R.
The interplay between discrete states and transitions requires that ti implies σi−1 and σi for (σ, σ) = m(t). With linear zero-one constraints, this can be expressed by a single constraint
2ti + 1σi−1 + 1σi ≥ 2
for each t ∈ T and each 1 ≤ i ≤ k. Furthermore, enabledness of the transition, i.e. validity of the transition guard, is enforced through the guarded linear constraint
ti+1 =⇒ gt[x'i,... , x'i/x1,... , xn] .
1	n
Likewise, assignments are dealt with by
ti+1 =⇒ asst[xi ,... , xi /x1,... , xn][x'i,... , x'i/x' ,... , x' ]
1	n	1	n	1	n
Finally, we have to add constraints describing the allowable initial states through the guarded linear constraint system
σ0 =⇒ initσ
σ∈Σ
Satisfying valuations of the formula thus obtained are in one-to-one correspon- dence to the runs of A of length k. As in BMC [9], satisfaction of temporal properties on all runs of depth k can thus be checked by adding to the formula the k-fold unrolling of a tableaux of the (negated) property, then checking the resulting formula for unsatisfiability. Using standard techniques from pred- icative semantics [18], the translation scheme can be extended to both shared variable and synchronous message-passing parallelism, thereby yielding for- mulae of size linear in the number of parallel components.
Note that, except for step (v) of above encoding scheme, all steps generate multiple copies of the same basic formula, where the k or k + 1 individual copies differ just in a consistent renaming of the variables. Therefore, a sat- isfiability checker tailored towards BMC of hybrid automata should exploit

5 If lσ,x = −∞ or uσ,x = ∞, the corresponding part of the constraint is left out.


such isomorphies between subformulae for accelerating satisfiability checking, which is the distinguishing feature of HySat. In order to simplify detection of isomorphic copies, HySat is in fact fed with just a single copy of the transition and evolution predicates and performs the unrolling itself.

Ingredients of HySat
The predicative encoding outlined above yields formulae which are Boolean combinations of linear arithmetic contraints. To deal with such formulae, HySat’s main components are
the solver core, consisting of a tight integration of a SAT solver with a linear programming routine, described in section 4.1, and enhanced with domain-specific optimizations for BMC, as explained in section 4.2,
an API to the solver core, providing methods for formula generation, sim- plification, common subexpression eliminiation, and for rewriting the re- sulting formula into a conjunctive form, namely a conjunction of zero-one linear constraints and guarded linear constraints, which is the input format of the solver core,
a frontend, consisting of HySat’s input language and a bounded model checker, which performs the unwinding of the transition relation and con- trols the solver core via API calls.
To fit the needs of BMC, which involves checking the same system on different unrolling depths, the solver core and the API are designed to work in an incremental fashion in the sense that they allow to add (as well as delete) successively sets of constraints to (from) an existing problem and then redo the satisfiability check without starting SAT search from scratch each time.

Integration of DPLL-SAT and Linear Programming
Before addressing the integration of a propositional SAT solver with linear programming, we first briefly review some basics of the individual methods.

Boolean SAT
The best currently known procedures for deciding Boolean SAT problems im- plement variants of the classical Davis-Putnam-Loveland-Logemann (DPLL) procedure [12] and are based on backtracking in the space of partial value assignment. Given a Boolean formula Φ in conjunctive normal form (CNF) and a partial valuation ρ, which is empty at the start, the DPLL procedure incrementally extends ρ until either ρ |= φ holds or ρ turns out to be incon-


sistent for φ, in which case another extension is tried through backtracking. Extensions are constructed by performing decision steps, which entail select- ing an unassigned variable “blindly” and assigning a truth-value to it, each followed by a deduction phase, involving the search for propagating clauses that enforce certain assignments to preserve satisfiability, where execution of the latter might cause the need for further such assignments, in this context also referred to as implications. However, deduction may also yield a con- flicting clause which has all its literals assigned false, indicating the need for backtracking.
Like all pure backtracking algorithms, the classical DPLL procedure suffers from thrashing, i.e. repeated failure due to the same reason. To overcome this problem, modern SAT solvers implement a technique called conflict-driven learning [31], which attempts to derive sufficiently general reasons for con- flicts being encountered and stores them for future guidance of the search. The standard scheme traces the reason back to a small (ideally minimal) number of assignments that triggered the particular conflict, and stores this reason by adding the negation of that assignment as as clause, termed con- flict clause, to the clause database. Besides learning, state-of-the-art SAT solvers, as the one being integrated in HySat, enhance the basic DPLL pro- cedure by sophisticated heuristics for selecting the assignment performed at decision steps [22,24], and add various algorithmic refinements, among them non-chronological backtracking [23,24], random restarts [5] and lazy clause evaluation [24], to accelerate the proof search.
A pecularity of HySat’s SAT solver is its ability to directly handle linear zero-one constraint systems, a considerably more concise language than CNF.

Linear programming
Linear programming deals with finding extreme values of a linear function when the variables are constrained by linear (in)equalities, i.e. with problems that can be put in the general form


maximize	cT x
subject to	Ax ≤ b
(1)

where x is the vector of variables to be solved for, and A, b and c are given matrices or vectors of known coefficients. The linear expression cT x is called the objective function, (1) is referred to as a linear program.
HySat uses LP as a black-box method to decide the feasibility of a set of linear constraints, i.e. to check whether for a given system of inequalities


Ax ≤ b the set of solutions {x ∈ R | Ax ≤ b} is non-empty. Linear programming is known to be polynomial. Commercial codes like CPLEX tackle instances with more than 106 variables. In HySat, however, we use the free LP library glpk 6 by Andrew Makhorin which provides a simplex solver, an interior point solver, and a solver supporting mixed integer linear programming (MILP), where some of the variables are required to be integer.
Coupling SAT and LP
The basic idea of the integration is to guard each non-propositional constraint occuring in the input formula with a new Boolean variable and to pass the corresponding constraint to the linear programming routine whenever the SAT solver assigns that variable to true. In turn, constraints are removed from the LP-solver’s database when their guard variables are unassigned again due to backtracking.
After each deduction phase in which no Boolean conflict was encountered, the SAT solver checks if new constraints have been added to the linear pro- gramm since its last evaluation. If so, the linear programming routine is called to decide the feasibility of the set of constraints residing in its database. If the linear program turns out to be inconsistent, a conflict is reported to the SAT solver. Otherwise the SAT solver can proceed with the next decision step.
In case of a conflict, however, HySat invokes a conflict-analysis routine that extracts an irreducible infeasible subsystem (IIS) from the linear program 7 ,
i.e. a subset of constraints which itself is infeasible, but becomes feasible if any one constraint is removed. The IIS, providing a minimal (however in general not unique) reason for the conflict, is communicated back to the SAT solver, which uses the guard variables of the linear constraints involved to construct a conflict clause which prevents that particular combination of constraints to be investigated again. The resulting interaction between DPLL proof search and feasibility check via LP is illustrated in Figure 2.
Optimizations for BMC
Compared to related tools like ICS which aim at being general-purpose de- cision procedures suitable for arbitrary formulae, HySat’s decision procedure has been tuned to exploit the unique characteristics of BMC formulae.
As observed by Shtrichman [26], the highly symmetric structure of the k- fold unrolling as shown in section 3 as well as the incremental nature of BMC

6 http://www.gnu.org/software/glpk/glpk.html
7 See [10] and [11] for surveys of methods for doing so. Our current implementation of HySat employs the Deletion-Filter method for isolating IISs.



Davis Putnam
2e + C + D ≥ 2
2f + A + B ≥ 2
f + g + e ≥ 1
g + f ≥ 1
3e + 2g + C + D ≥ 3
Linear Programming
y









x


e	e


Davis Putnam
C + D ≥ 2
2f + A + B ≥ 2
f + g ≥ 1
g + f ≥ 1

Linear Programming
y

Davis Putnam	Linear Programming
y

2f + A + B ≥ 2

g + f ≥ 1

x	2g + C + D ≥ 3	x






Davis Putnam


Deduce C, D

Linear Programming

Deduce g, f, A, B
Deduce C from conflict clause Deduce D
Davis Putnam	Linear Programming

y	D

2f + A + B ≥ 2
f + g ≥ 1
g + f ≥ 1
C	x
y	A  D




B
x



f	f


Davis Putnam	Linear Programming

Davis Putnam

Linear Programming

y	D	y	D



g ≥ 1
g ≥ 1
A + B ≥ 2


C	x	C	x




Davis Putnam



Conflict !

Deduce g, g
Linear Programming
y	D



Davis Putnam

Deduce A, B
Linear Programming
y	A  D
Conflict !



B







Minimal infeasible subsystem is {A, B, C}

 
Solver learns conflict clause A ∨ B ∨ C

C	x	C	x

Fig. 2. Backtrack-search tree arising in a tight integration of DPLL proof search with linear programming. x and y are real-valued, while e, f, g and A, B, C, D are Boolean. A, B, C, D are, furthermore, guard variables for arithmetic facts.
can both be exploited for various optimizations in the underlying decision pro- cedure. Currently, HySat implements three optimizations which are described below.
Isomorphy inference
The learning scheme employed in propositional SAT solvers accounts for a sub- stantial fraction of the solver’s running time as it entails a non-trivial analysis of the implications that led to an inconsistent valuation. The creation of a conflict clause is in general even considerably more expensive in a combined solver like HySat, as the analysis of a conflict involving non-propositional con-

straints requires the computationally expensive extraction of an IIS. Isomorphy inference uses the (almost) symmetric structure of a BMC for-
mula in order to add isomorphic copies of a conflict clause to the problem, thus multiplying the benefit taken from the time-consuming reasoning process which was required to derive the original conflict clause.
The concept is best illustrated using an example. Suppose that while solving a BMC instance the solver has encountered a conflict which yields the conflict clause C0 = (xj1 ∨ xj2 ∨ xj3 ), relating three variables from cycles j1, j2
3	4	9
and j3. The solver then not only adds C0 to φk, but also all possible clauses
Ci = (xj1±i ∨ xj2 ±i ∨ xj3 ±i), i = 1, 2,.. ., obtained from C0 simply by index
3	4	9
shifting.
Note, however, that BMC is not fully symmetric because of the initializa- tion properties of runs (clause (v) of the translation scheme of section 3) and perhaps the verification goal. This implies that only conflict clauses inferred from facts which are independent from such asymmetric formula parts may be soundly replicated. Such dependency can be traced cheaply by marking initialization/goal predicates and dominantly inheriting such marks upon all inferences, inhibiting isomorphy inference whenever a mark is encountered.

Constraint sharing
When carrying out BMC incrementally for longer and longer unrollings, the consecutive formulae passed to the solver share a large number of clauses. Thus, when moving from the k-instance to the (k + 1)-instance, we can simply conjoin the conflict clauses derived when solving k-instance to the formula for step k + 1. However, this is only allowed for conflict clauses that were inferred from clauses which are common to both instances. We do currently decide this based on simple syntactic criteria, namely that the conflict clause was inferred purely from clauses stemming from the automaton. I.e. the inference may not involve the verification goal, which tends to become a weaker predicate on longer instances, as it usually entails reachability or recurrence. More elaborate schemes have, however, been investigated for propositional BMC in [21].

Tailored decision strategy
When applying general-purpose decision strategies to BMC formulae one can observe the phenomenon described in [26] that during the SAT search large sets of constraints belonging to distant cycles of the transition relation are being satisfied independently, until they finally turn out to be incompatible, often entailing the need for backtracking over long distances in the search tree.


In HySat we adopt the solution proposed by Shtrichman [26] to avoid this problem: The heuristics of the SAT solver selects the decision variables in the natural order induced by the variable dependency graph of the BMC formula,
i.e. either starting with variables from x0, then from x1, etc., or vice versa. This allows conflicts to be detected and resolved more locally, speeding up the search.

Benchmark results
For a first evaluation of HySat we conducted a series of experiments in which we compared our tool with the ICS solver [13] on BMC problems for hybrid automata. The unwindings fed to ICS were obtained through either SRI’s
infinite-state BMC frontend to ICS as distributed in the SAL tool-set, or through A´brah´am et al.’s corresponding frontend [1], yet the latter without learning across instances, as it was not available when our experiments were performed. Our benchmarks are the “leaking gas burner” and “water-level
monitor” included in the SAL distribution, as well as various instances of an elastic approach to distance control of trains running on the same track, sim- ilar to the car platooning system used in the PATH project. Here, trains can accelerate or decelerate freely if they do not violate their mutual safety en- velopes, yet an automatic speed control takes authority over a train if another train gets close, thereby controlling acceleration proportional (within physical limits) to the front and/or back proximity of the neighboring trains.
The results are shown in Figure 3, with each dot representing a single BMC instance. As expected, isomorphy inference typically provides performance benefits, with the merits becoming more evident with increasing unrolling depth, corresponding to computationally costly SAT instances. An exception is the extremely deterministic gasburner model, where a strict state alternation is enforced by the discrete part such that learning of infeasible subsystems provides negligible extra information.

Conclusion and further work
Even though development of HySat is still in an early stage, first experiments indicate a very competitive performance when used for bounded model check- ing of linear hybrid systems. A substantial part of this performance gain can be attributed to inheritance of inference results along the temporal axis, called isomorphy inference. The pure base engine of HySat without BMC-specific optimizations exhibits a performance comparable to major other engines like SAL/ICS [13]. The isomorphy inference scheme along the temporal axis was




1000	1000


100	100


10	10


1	1


0.1	0.1



0.01
a)
1	1	1	a’)
0.01


1	1	1


1000	1000


100	100


10	10


1	1


0.1	0.1



0.01
b)
0.01	0.1	1	10	b’)
0.01


0.01	0.1	1	10


10000	10000

1000	1000

100	100

10	10

1	1


0.1

0.01
c)



0.01	0.1	1	10	100	c’)

0.1

0.01






0.01	0.1	1	10	100


10000	10000

1000	1000

100	100

10	10

1	1

0.1	0.1


0.01
d)

0.01	0.1	1	10	100	d’)

0.01



0.01	0.1	1	10	100


10000	10000

1000	1000

100	100

10	10

1	1

0.1	0.1


0.01
e)

0.01	0.1	1	10	100	f)

0.01



0.01	0.1	1	10	100

Fig. 3. BMC times for a) gasburner model, b) water-level monitor, and c) – f) different scenarios of the train distance control model, involving 3 (c and d), 4 (e) and 5 (f) trains with different parameters. The graphics show the performance of HySat relative to ICS (a, b, c, d) and the impact of isomorphy inference (a’, b’, c’, d’, e, f). Computation times of 10000 denote timeouts.

inspired by a similar scheme developed by Shtrichman for finite-state BMC
[26]; however such inference-inheritance schemes exhibit an even better payoff on the two-sorted logics used here, as the price for copying inferences increases only marginally while the computational cost of individual inferences grows dramatically in the hybrid-state case.
An interesting aspect of isomorphically copying inference results is that even extremely costly inferences may amortize, provided that their results can be reused sufficiently often. Our next step will thus be to implement more advanced —and computationally more costly— techniques for finding infeasible subsystems of linear constraint systems. In particular, we will try to extract and learn multiple different irreducible infeasible subsystems from a single conflict encountered. While the cost of finding an actually irreducible subsystem, and even more so of finding multiple such, is by far the most expensive inference operation in a combined DPLL-plus-LP solver, doing so can provide very aggressive proof-tree pruning.
Another direction for future development will be to add inheritance of in- ference results across similar components in a multi-component system. While this is in principle similar to inheriting inferences along the temporal axis in k-bounded model checking, the possible forms of symmetry breaks in multi- component ensembles are more diverse and thus harder to detect, as witnessed by the extensive research on symmetry reductions.
Besides exploiting similarity within subformulae for accelerating inference, there obviously also remains ample opportunity for optimizing the underly- ing decision procedure for HySat’s base logic. To this end, we will attack the benchmarks performed by de Moura and Rueß in [14] to obtain a more profound evaluation of the capabilities of HySat’s core decision procedure.
Acknowledgements. The authors are grateful for the tight cooperation within the project area “Hybrid Systems” of the Transregional Research Ac- tion “AVACS” funded by the Deutsche Forschungsgemeinschaft. Special thanks go to Bernd Becker, Erika A´brah´am, and Felix Klaedtke for their kind hospi-
tality and for many fruitful discussions during research visits to Freiburg.

References
E. A´brah´am, B. Becker, F. Klaedtke, and M. Steffen. Optimizing bounded model checking for linear hybrid systems. To be submitted to VMCAI ’05.
F. A. Aloul, A. Ramani, I. L. Markov, and K. A. Sakallah. Generic ILP versus specialized 0-1 ILP: An update. In Proc. ACM/IEEE Intl. Conf. Comp.-Aided Design (ICCAD), pages 450–457, Nov. 2002.
G. Audemard, P. Bertoli, A. Cimatti, A. Kornilowics, and R. Sebastiani. A SAT-based approach for solving formulas over boolean and linear mathematical propositions.  In


A. Voronkov, editor, Proc. of the 18th International Conference on Automated Deduction, volume 2392 of Lecture Notes in Artiﬁcial Intelligence, pages 193–208. Springer-Verlag, 2002.
G. Audemard, M. Bozzano, A. Cimatti, and R. Sebastiani. Verifying industrial hybrid systems with MathSAT. ENTCS, 89(4), 2004.
L. Baptista, I. Lynce, and J. Marques-Silva. Complete search restart strategies for satisfiability. In Proc. of the IJCAI’01 Workshop on Stochastic Search Algorithms (IJCAI-SSA), August 2001.
C. Barrett, D. Dill, and A. Stump. Checking satisfiability of first-order formulas by incremental translation to SAT. In 14th International Conference on Computer-Aided Veriﬁcation, 2002.
P. Barth. A Davis-Putnam based enumeration algorithm for linear pseudo-boolean optimization. Technical Report MPI-I-95-2-003, Max-Planck-Institut fu¨r Informatik, Saarbru¨cken, Germany, 1995.
A. Bemporad and M. Morari. Verification of hybrid systems via mathematical programming. In F. W. Vaandrager and J. H. van Schuppen, editors, Hybrid Systems: Computation and Control (HSCC’99), volume 1569 of Lecture Notes in Computer Science, pages 31–45. Springer- Verlag, 1999.
A. Biere, A. Cimatti, and Y. Zhu. Symbolic model checking without BDDs. In TACAS’99, volume 1579 of Lecture Notes in Computer Science. Springer-Verlag, 1999.
J. W. Chinneck. Finding a useful subset of constraints for analysis in an infeasible linear program. INFORMS Journal on Computing, 9(2):164–174, 1997.
J. W. Chinneck and E. W. Dravnieks. Locating minimal infeasible constraint sets in linear programs. ORSA Journal on Computing, 3(2):157–168, 1991.
M. Davis, G. Logemann, and D. Loveland.	A machine program for theorem proving.
Communications of the ACM, 5:394–397, 1962.
L. de Moura, S. Owre, H. Ruess, J. Rushby, and N. Shankar. The ICS decision procedures for embedded deduction. In 2nd International Joint Conference on Automated Reasoning (IJCAR), volume 3097 of Lecture Notes in Computer Science, pages 218–222, Cork, Ireland, July 2004. Springer-Verlag.
L. de Moura and H. Rueß. An experimental evaluation of ground decision procedures. In
Proceedings of CAV’04, Lecture Notes in Computer Science. Springer-Verlag, July 2004.
L. de Moura, H. Rueß, J. Rushby, and N. Shankar. Embedded deduction with ICS. In
B. Martin, editor, HCSS’03—High Conﬁdence Software and Systems Conference, Baltimore, MD, 1-3 April 2003.
M. Fr¨anzle and C. Herde. Efficient SAT engines for concise logics: Accelerating proof search for zero-one linear constraint systems. In M. Vardi and A. Voronkov, editors, Logic for Programming, Artiﬁcial Intelligence, and Reasoning (LPAR 2003), volume 2850 of Lecture Notes in Artiﬁcial Intelligence. Springer-Verlag, 2003.
J. F. Groote, J. W. C. Koorn, and S. F. M. van Vlijmen. The safety guaranteeing system at station hoorn-kersenboogerd. In Compass ’95: 10th Annual Conference on Computer Assurance, pages 57–68, Gaithersburg, Maryland, 1995. National Institute of Standards and Technology.
E. C. R. Hehner. Predicative programming. Communications of the ACM, 27:134–151, 1984.
T. A. Henzinger, P.-H. Ho, and H. Wong-Toi. HyTech: The next generation. In 16th Annual IEEE Real-time Systems Symposium (RTSS 1995), pages 56–65. IEEE Computer Society Press, 1995.
T. A. Henzinger, P. W. Kopke, A. Puri, and P. Varaiya. What’s decidable about hybrid automata. In Proceedings of the Twenty-Seventh Annual ACM Symposium on the Theory of Computing, pages 373–382. ACM, 1995.


H. Jin and F. Somenzi. An incremental algorithm to check satisfiability for bounded model checking. In A. Biere and O. Strichman, editors, Preliminary Proceeding of BMC’04. ETH Zu¨rich,	2004.	Available	from http://bmc04.inf.ethz.ch/JinSomenzi-BMC04-preliminary.pdf.
J. P. Marques-Silva. The impact of branching heuristics in propositional satisfiability algorithms. In Proc. of the 9th Portuguese Conference on Artiﬁcial Intelligence (EPIA), Sept. 1999.
J. P. Marques-Silva and K. A. Sakallah. GRASP: A search algorithm for propositional satisfiability. IEEE Transactions on Computers, 48(5):506–521, May 1999.
M. W. Moskewicz, C. F. Madigan, Y. Zhao, L. Zhang, and S. Malik. Chaff: Engineering an Efficient SAT Solver. In Proc. of the 38th Design Automation Conference (DAC’01), June 2001.
A. Nonnengart and C. Weidenbach. Computing small clause normal forms. In A. Robinson and A. Voronkov, editors, Handbook of Automated Reasoning. Elsevier Science B.V., 1999.
O. Shtrichman. Tuning SAT checkers for bounded model checking. In E. A. Emerson and
A. P. Sistla, editors, Computer Aided Veriﬁcation (CAV 2000), volume 1855 of Lecture Notes in Computer Science, pages 480–494. Springer-Verlag, 2000.
G. Tseitin. On the complexity of derivations in propositional calculus. In A. Slisenko, editor,
Studies in Constructive Mathematics and Mathematical Logics, 1968.
J. P. Warners. A linear-time transformation of linear inequalities into conjunctive normal form.
Information Processing Letters, 68(2):63–69, 1998.
J. Whittemore, J. Kim, and K. Sakallah. SATIRE: A new incremental satisfiability engine. In Proc. of the Design Automation Conference (DAC 2001), pages 542–545, Las Vegas (Nevada, USA), June 2001.
S. A. Wolfman and D. S. Weld. The LPSAT engine & its application to resource planning. In
T. Dean, editor, Proc. 16th International Joint Conference on i Artiﬁcial Intelligence, pages 310–315. Morgan Kaufmann Publishers, 1999.
L. Zhang, C. F. Madigan, M. W. Moskewicz, and S. Malik. Efficient conflict driven learning in a Boolean satisfiability solver. In Proc. of the International Conference on Computer-Aided Design (ICCAD01), pages 279–285, Nov. 2001.
