Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 310 (2015) 135–155
www.elsevier.com/locate/entcs

Obtaining Optimal Thresholds for Processors with Speed-Scaling
Ronny J. Polansky1,
Samyukta Sethuraman1 and Natarajan Gautam1
Department of Industrial and Systems Engineering Texas A&M University
College Station, Texas, USA

Abstract
In this research we consider a processor that can operate at multiple speeds and suggest a strategy for optimal speed-scaling. While higher speeds improve latency, they also draw a lot of power. Thus we adopt a threshold-based policy that uses higher speeds under higher workload conditions, and vice versa. However, it is unclear how to select ”optimal” thresholds. For that we use a stochastic fluid-flow model with varying processing speeds based on fluid level.
First, given a set of thresholds, we develop an approach based on spectral expansion by modeling the evolution of the fluid queue as a semi-Markov process (SMP) and analyzing its performance. While there are techniques based on matrix-analytic methods and forward-backward decomposition, we show that they are not nearly as fast as the spectral-expansion SMP-based approach. Using the performance measures obtained from the SMP model, we suggest an algorithm for selecting the thresholds so that power consumption is minimized, while satisfying a quality-of-service constraint. We illustrate our results using a numerical example.
Keywords: server speed-scaling, data center, power management, quality of service, fluid model, spectral expansion


Introduction
The well-studied area of analysis of queues with state-dependent service rates has seen a renewed interest in the last decade or so. The major difference between traditional and contemporary queueing models is that in the former case the service rates were control-knobs while the latter uses workload processing speeds as control- knobs. In the latter case, each arriving entity brings a random amount of work which is an attribute of the entity, whereas the speed of processing (a deterministic, but variable quantity) of an entity’s work is an attribute of the server. Of course, if the workload brought by each arriving entity is exponentially distributed, then selecting

1 Email: ronny.polansky@gmail.com,{samyukta,gautam}@tamu.edu

http://dx.doi.org/10.1016/j.entcs.2014.12.016
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/3.0/).

service rates or processing speeds are mathematically equivalent. However, if the distribution is not exponential or if the entities are fluids, there is a need for new analysis.
Analysis of queues with variable workload processing speeds can be classified broadly into two lines of research. In one case, the workload processing speed is variable but not in a controllable fashion, while in the other case the service speed is controllable. On one hand, examples of the former case include Huang and Lee [9], and Mahabhashyam and Gautam [14] where the workload is exponentially dis- tributed but since the workload processing speeds vary as an uncontrollable Markov modulated process, the resulting service time is not exponential. Such situations are especially applicable in modeling wireless channels and available CPU capacities in shared systems. On the other hand, there is a wide variety of application domains where the workload processing speed is controllable. For example in manufactur- ing systems one could control the cutting speed in lathes, conveyor belt speeds in tunnel freezers, and variable speed drives in motors. Likewise in computer systems, especially servers in data centers, one could use dynamic voltage/frequency scaling (DVFS) to process jobs at different speeds. This research study falls into the latter category.
In all the aforementioned examples, controlling the service speeds is fueled by the need to manage energy consumption. Typically, higher speeds imply higher power consumption but faster service completion. Thus there is a trade off between energy and quality of service. We wish to explore this trade off in this research and strike a balance. We begin by considering a policy that is widely accepted in the literature and use it to determine workload processing speeds based on buffer contents. In particular, we consider a monotonic and threshold-type policy: if there are N +1 service speeds c1, c2,..., cN+1 such that 0 < c1 < c2 < . . . < cN+1, then there are N thresholds x1, x2,..., xN , where 0 = x0 ≤ x1 ≤ x2 ≤ ... ≤ xN < xN+1 = ∞ such that if the amount of fluid in the system is between xi−1 and xi for some i ∈ [1,N + 1], then speed ci is used.
The goal of our study is to determine the optimal thresholds x∗, x∗,..., x∗ so
1	2	N
that the long-run average energy consumption per unit time (i.e. time-averaged
power) is minimized subject to satisfying a quality of service metric that we will subsequently describe. Although there are several articles that describe structures of optimal policies, our study belongs to the minority that delve into methods to obtain the resulting numerical values of the optimal parameters (viz. thresholds). Our models and numerical examples are motivated by applications in data center servers (using technology such as DVFS) where it is crucial to reduce energy consumption (see McKinsey Report [16]). Our focus is on DVFS with the understanding that other techniques such as HVAC control, air-flow control, virtualization, cluster- sizing and chip cooling have all been implemented. Our goal is to further reduce energy consumption through DVFS which can be done in a distributed manner with local information. Since the load experienced by data center servers is stochastic and bursty in nature, we analyze data center server systems as fluid queues with varying processing speeds corresponding to a discrete set of DVFS levels.

We consider a stochastic fluid flow setting where fluid arrives into a buffer at piece-wise constant rates modulated by a continuous time Markov chain (CTMC). Such a CTMC environment process that drives the fluid entering rates is also called Markov modulated fluid process. These models are frequently referred to as stochas- tic fluid-flow models or first-order fluid queues where the flow rate is piece-wise con- stant for random times (pioneering work by Anick et al [3]). Fluid is removed from the buffer at one of N +1 different rates c1,..., cN+1 based on thresholds x1,..., xN as described earlier. For a given set of thresholds we evaluate the long-run average costs per unit time and other performance metrics based on steady-state distribution of buffer contents. Using that we determine optimal thresholds x∗,..., x∗ . There
1	N
are two techniques to obtain the buffer-content distribution: (1) spectral expansion,
and (2) matrix analytic methods.
There are a significant number of articles that use spectral expansion (some of the earlier ones include Anick et al [3]), where the researchers have assumed a constant output capacity. Only a few articles consider varying output capacities, but most of them are to accommodate multi-class traffic. For example, Narayanan and Kulkarni [17] analyze a multi-class fluid model that uses a static-priority service policy and Agarwal et al [1] consider a threshold-based policy where the processing rate is shared between two classes of fluid based on the amount of content waiting to be served. However, they consider only two possible service capacities and the inputs are on-off CTMCs. Further, there are a few articles in multi-class fluid models that work around varying output capacities by considering compensating sources (see Elwalid and Mitra [7] and Kulkarni and Gautam [13]). Finally, Kankaya et al [10] use spectral expansion for fluid models with varying output capacity which is identical to the setting we consider here. Their solution method involves reduction to the Schur form for stability when the input and output rates are very close. However, calculation of optimal thresholds requires solving the fluid models repeatedly for different set of thresholds. Therefore, computational efficiency is of utmost importance and we will present arguments in favor of our method in that respect.
The second technique, namely matrix analytic methods, has received signifi- cant attention. Soohan and Ramaswami [2] consider matrix-analytic methods for transient analysis, steady state analysis and first passage times of both finite and infinite sized buffers. Da Silva Soares and Latouche [5] explore the relationship between matrix-analytic methods and that of discrete state quasi-birth-and-death process and present a derivation for the stationary distribution of a fluid queue with a finite buffer. Additionally, similar to [6], Da Silva Soares and Latouche [6] study a numerically stable counting-process based matrix-analytic method to arrive at the stationary distribution of the buffer contents for a fluid model with varying output capacity which is again identical to the setting we consider here. Although matrix analytic methods are appealing in terms of simplicity and compact notations, it is unclear how it compares against spectral expansion methods, computationally. We seek to explore this as it is critical to obtain a fast algorithm for performance anal- ysis so that one could expeditiously search through the space to obtain the optimal

thresholds x∗,..., x∗ .
1	N
In Section 2 we formally define the problem and formulate an abstract model.
In Section 3 we describe our model and approach for buffer content analysis given x1,..., xN . We devote Section 4 for discussion of the steady-state performance measures. In Section 5 we describe an algorithm for obtaining the optimal thresh- olds. In Section 6 we describe our approach through a numerical example. Finally, in Section 7 we present concluding remarks followed by some directions for future work.
Problem Description
We consider a single infinite-sized buffer. Let {Z(t) : t ≥ 0} be the environment process that governs inputs to the buffer from a fictitious “source” such that {Z(t): t ≥ 0} is a CTMC with finite state space S and infinitesimal generator matrix Q = [quv]u,v∈S . We denote r(Z(t)) to be the rate at which fluid flows from the source into the buffer when the environment process is in state Z(t) at time t. Let C(t) be the drainage capacity of the buffer at time t. That means, if there is non-zero fluid in the buffer at time t, it gets removed from the buffer at rate C(t). However, if the buffer is empty with r(Z(t)) < C(t), then fluid is removed at rate r(Z(t)). The buffer can be emptied at one of N + 1 different rates c1, c2,..., cN+1. Note that these correspond to the N + 1 different speeds that servers in data centers can be run at using DVFS technology. We adopt a threshold policy with respect to the buffer contents to determine the rate at which fluid is drained from the buffer. There are N thresholds which we denote by x1, x2,..., xN where 0 = x0 ≤ x1 ≤ x2 ≤ ... ≤ xN < xN+1 = ∞. The N thresholds essentially partition the buffer into N + 1 “regions”. Throughout this article, we let x0 = 0 and xN+1 = ∞, by convention. We define X(t) to be the amount of fluid in the buffer at time t. Then C(t) is indeed a piece-wise constant function of X(t) and we define C(t) for some 0 < c1 < c2 < ··· < cN+1 by the following threshold policy:
⎧⎪ c1	if x0 < X(t) < x1,
⎪ 2	1	2

⎪ cN	if xN−1 < X(t) < xN ,


A graphical representation of this system can be seen in Figure 1. By examin- ing Figure 1, we can see that a threshold lies between each region. For example, threshold 1 lies between regions 1 and 2 within the buffer.
Remark 2.1 The setting is identical to that in Kankaya and Akar [10] and da Silva Soares and Latouche [6]. However, our approach is based on spectral expansion and semi-Markov process modeling while [10] uses spectral expansion and Schur form


Fig. 1. System Model


reduction and [6] uses matrix analytic methods. We first explain our approach in the next few sections and subsequently in Section 5 compare the approaches briefly.
Towards the end of this section we will make a case for the need for an extremely fast approach to compute the metrics when we use them in an optimization context. Thus, although it may be a matter of seconds for a single run, when one needs to run multiple cases, the other methods could take a possibly large amount of time. Before delving into further details, we present another remark.
Remark 2.2 Two main extensions to our setting have been considered by Malho- tra et al [15] for N = 1 and O’Reilly [18] for any N : (i) a state-dependent arrival process, i.e. piece-wise constant arrival rates and environment processes are both state dependent; (ii) a hysteresis policy is used for switching between output ca- pacities, i.e. when threshold xiu is crossed from above, speed goes from ci to ci−1 whereas while crossing xil from below, speed goes from ci−1 to ci (while we consider xil = xiu = xi). However, it should be noted that extending our results to cases
(i) and (ii) is not difficult. We do not consider them here because they are not applicable in our motivating application of data center servers. The arrival process is completely exogenous and independent in this case. Furthermore, since there is no cost for performing DVFS, the optimal policy is typically threshold-type (if there is a switching cost, then one would use a hysteretic policy).
In summary we have an infinite-sized buffer with piece-wise constant fluid input modulated by a CTMC and a piece-wise constant fluid output capacity that is state-dependent. Next we state some assumptions. For ease of exposition, we assume that r(u) and ci for every u ∈ £ and i = 1, 2,...,N + 1 are chosen such that r(u) — ci /= 0. Although relaxing this assumption still maintains analytical tractability, it is notationally cumbersome. An important aspect that needs to be addressed in our system is what if there exist u and i such that r(u) > ci but r(u) < ci+1? This would result in the buffer content process “bouncing back- and-forth” between region i and region i + 1. To understand this, suppose that
{X(t),t ≥ 0} is in region i so that r(u) > ci. While {Z(t),t ≥ 0} remains in state u the buffer content process crosses threshold xi from below and enters region i + 1. At this point, if {Z(t),t ≥ 0} still remains in state u, then the buffer content process will instantaneously cross threshold xi from above since r(u) < ci+1. Once again, the buffer content process will instantaneously cross threshold xi from below, repeating this process as long as the source modulating process remains in state u. In effect we would get C(t)= r(Z(t)) whenever X(t)= xi, Z(t)= u, r(u) > ci and

r(u) < ci+1. This is because the output capacities ci and ci+1 would alternate for appropriate infinitesimal times so that the effective output capacity becomes r(u). Thus X(t) would have a mass at xi.
Having described the scenario and assumptions we next explain the output we desire and subsequently the goal of this study. Given the definition of X(t), the process {X(t),t ≥ 0} needs to be characterized and is typically called buffer content analysis. We assume the system is stable, i.e. E[r(Z(∞))] < cN+1 (see Kulkarni and Rolski [8] and da Silva Soares and Latouche [6]). For such a buffer, we seek to obtain the following steady-state measures (i.e. our output metrics):
pi = lim P{xi−1 < X(t) < xi} for all i = 1, 2,...,N + 1,
t→∞
θi = lim P{X(t)= xi} for all i = 1, 2,...,N , and
t→∞
O = lim P{X(t) > x} for any x > xN .
t→∞
Notice that pi is the long-run fraction of time that the buffer content process
{X(t),t ≥ 0} spends in region i for i = 1,...,N . Note that since the last threshold is xN , we let pN+1 = limt→∞ P{X(t) > xN }. Similarly, θi is the long-run fraction of the time that the buffer content process spends on threshold i for i = 1,...,N . When the buffer content process is in region i, the output capacity of the buffer is ci. If the buffer content has mass at threshold i, the output capacity is assumed to be r(u) where u is the state of the environment process {Z(t),t ≥ 0}. Also notice that O is the steady-state probability of having more than x amount of fluid in the buffer. In this research, we are interested in O for some sufficiently large x. It is also important to realize that pi, θi and O are functions of x1, x2,..., xN which we are interested in determining in an optimal fashion (in Section 5).
Once we have expressions for pi for all i = 1, 2,...,N + 1 and θi for all i = 1, 2,...,N , as well as O, our goal is to obtain optimal thresholds x∗,..., x∗ . For
1	N
that we define the vector x¯ = [x1 ... xN ] and explicitly write down our performance
metrics as pi(x¯) and θi(x¯). Also note that O is a function of x and x¯, hence we say O(x, x¯). For the purpose of clarity, we restate that x is a scalar denoting an element of the sample space of X(t) while x¯ denotes a vector of thresholds. For the objective function we let C (x¯) be the long-run average cost per unit time under threshold vector x¯. Assuming that we can write down C (x¯) as a function of c1,..., cN+1, pi(x¯) and θi(x¯), we state the following optimization problem for some given B and ϵ:

Minimize	C (x¯) subject to: O(B, x¯) ≤ ϵ
x0 =0 
xi−1 ≤ xi, for all i = 1, 2,...,N xN ≤ B
which upon solving would give us the optimal thresholds x∗,..., x∗ .
1	N

Note that it is not possible to write down closed form algebraic expressions for C (x¯) and O(B, x¯) in terms of x1,..., xN . Hence our algorithm to solve the opti- mization problem which we present in Section 5 would essentially search through the space of values that x¯ can take and compute C (x¯) and O(B, x¯) for every candidate x¯ value. Thus we need an approach that can compute C (x¯) and O(B, x¯) expedi- tiously. We will show in Section 5 that our method is faster than the approaches that use Schur form reduction or matrix analytic methods. However, we first ex- plain our approach using spectral expansion. Given a set of thresholds x1,..., xN , next we present an analysis of fluid queues to determine pi, θi and O for all i (since x¯ is fixed, we remove the parenthesis for pi, θi and O).

Semi-Markov Process Model
In this section we focus on characterizing the {X(t),t ≥ 0} process. In particular, we use a semi-Markov process (SMP). We define the Markov regeneration epoch Sn to be the nth time the buffer content process {X(t),t ≥ 0} enters or leaves a region or the nth time at which the environment process {Z(t),t ≥ 0} changes from one state to another at a threshold. This means that a Markov regeneration epoch can occur when one of two possible events occur. The first event is when the buffer content process enters or leaves a region. The second event is when the buffer content process remains on a threshold and the environment process changes state. We now define Yn that captures necessary information about the system at each Markov regeneration epoch Sn (assuming S0 = 0) and encapsulates this information in two dimensions. We let
Yn = (i, u) if X(Sn)= xi and Z(Sn)= u for i = 1, 2,...,N and u ∈ £.
The first component of Yn tells us which threshold the buffer content process
{X(t),t ≥ 0} is crossing at the nth regeneration epoch. The second component of Yn tells us the state of the source modulating process {Z(t),t ≥ 0} at the time of the nth regeneration epoch. Given this information along with values for ci and r(u), we can deduce which “direction” the threshold is being crossed from; above or below or whether it stays at a threshold. By this definition, we are able to take care of both types of epochs, i.e. entering or leaving a region or being stuck on a threshold.
Lemma 3.1 The sequence {(Yn, Sn): n ≥ 0} is a Markov renewal sequence.
Proof. The sequence of epochs {Sn,n ≥ 0} is nondecreasing in n and the conditional probability P{Yn+1  =  (j, v), Sn+1 — Sn  ≤  t|Yn  = (i, u), Sn, Yn−1, Sn−1,..., Y0, S0} = P{Y1 = (j, v), S1 ≤ t|Y0 = (i, u)} because of the Markovian nature of both X(t) and Z(t). In particular, once we know the buffer contents at a given time and the environment, to predict the future we do not need anything from the past. Thus {(Yn, Sn) : n ≥ 0} is a Markov renewal sequence.	2

Lemma 3.2 Let N (t)= sup{n ≥ 0: Sn ≤ t}. Thus, N (t) is the number of times up to time t the buffer content process {X(t),t ≥ 0} enters or leaves a region or the environment process {Z(t),t ≥ 0} changes state at a threshold . Let W (t)= YN (t) for t ≥ 0. The stochastic process {W (t),t ≥ 0} is a semi-Markov process.
Proof. By definition (see Definition 9.5. on pp. 510 in Kulkarni [11]), {W (t),t ≥ 0} is a semi-Markov process (SMP).	2
The next step is to obtain the kernel of the Markov renewal sequence
{(Yn, Sn),n ≥ 0}.
SMP Kernel
Since {W (t),t ≥ 0} is an SMP, we can obtain pi and θi by using the kernel of the Markov renewal sequence {(Yn, Sn),n ≥ 0}. We denote the conditional probability P{Y1 = (j, v), S1 ≤ t|Y0 = (i, u)} by G(i,u),(j,v)(t), so the kernel of the Markov renewal sequence is given by G(t)= [G(i,u),(j,v)(t)].
Given values for ci and r(u), if Yn = (i, u), r(u) — ci > 0 (r(u) — ci < 0) and r(u) — ci+1 > 0 (r(u) — ci+1 < 0), then {X(t),t ≥ 0} is crossing the threshold xi from below (above), while the environment process is in state u, corresponding to a positive (negative) drift. When Yn = (i, u), r(u) — ci > 0 and r(u) — ci+1 < 0, the buffer content process {X(t),t ≥ 0} will “bounce back-and-forth” across threshold xi.
Suppose, for example, that X(Sn) = xi, Z(Sn) = u, and Yn = (i, u), where r(u) — ci < 0 and r(u) — ci+1 < 0. Now for some v /= u, if r(v) — ci < 0 and r(v) — ci+1 < 0, then it is impossible to transition from Yn = (i, u) to Yn+1 = (i, v) without first making a transition to some Yn+1 = (i, vj), such that r(vj) — ci > 0 for unique u, v, vj. Essentially, this means that if X(t) crosses a threshold from above, then X(t) must cross the same threshold from below before it can cross the threshold again from above. Similarly, it is impossible to transition from Yn = (i, u), where r(u) — ci > 0, to some (i, v) with r(v) — ci > 0 without first making a transition to some Yn+1(i, vj), such that r(vj) — ci < 0 for unique u, v, vj. This means that if X(t) crosses a threshold from below, then X(t) must cross the same threshold from above before it can cross the threshold again from below. Additionally, if X(t) crosses threshold i from below (above), then it is impossible to cross threshold i +2 (i — 2) from below (above) without first crossing threshold i +1 (i — 1) from below (above). Therefore, for the cases just mentioned, the corresponding elements of the kernel will be equal to 0.
Now we consider the case where the buffer content bounces back-and-forth across threshold xi while the environment process remains in state u. For a given i, there are only three possible transitions that could occur. The first two possible transitions happen when the {Z(t),t ≥ 0} process changes to state v, the drift could be either positive or negative causing the buffer content to drift off of threshold xi. The third possible transition is when the {Z(t),t ≥ 0} process changes to another zero drift state, v that will cause the buffer content to bounce back-and-forth across threshold xi. Finally, G(i,u),(i,u)(t) = 0 for all i and u.

Having listed the elements of G(t) that are equal to zero, now, the non-zero elements of the kernel need to be obtained, which we show next.

Modularization of the kernel
In this section, we demonstrate how to obtain the non-zero elements of the kernel. We take a modular approach to obtaining the elements of the kernel by considering each region and threshold of the buffer separately; and, after analyzing each region and threshold, we combine the results to obtain the kernel of the SMP.
Computing elements of the kernel for a threshold
Computing elements of the kernel for a given threshold is relatively straightforward. Here we consider the case where Yn = (i, u), such that r(u)—ci > 0 and r(u)—ci+1 < 0, for all i = 1, 2,...,N and u ∈ £. Recall that G(i,u),(i,v)(t)= P{Y1 = (i, v), S1 ≤ t|Y0 = (i, u)}. This is the probability of making a transition to state (i, v) before time t given that the initial state is (i, u). This is equivalent to the probability that
{Z(t),t ≥ 0} will be in state v when the Markov regeneration epoch S1 occurs, given that {Z(t),t ≥ 0} is initially in state u. That is, G(i,u),(i,v)(t) = P{Z(S1) = v|Z(0) = u}. Since {Z(t),t ≥ 0} is a CTMC,


G(i,u),(i,v)
(t) =  quv   1 — eΣv/=uquv t	if r(u) — c
—quu	i

> 0, r(u) — ci+1
< 0 and v /= u.
(1)

Thus, given Q, we can obtain the elements of the kernel that correspond to being stuck on a threshold using Equation (1). Now we compute elements of the kernel for each region.

Computing elements of the kernel for a region
Now that we have shown how to compute the elements of the kernel that correspond to states where the buffer content process is stuck on a threshold, we show how to compute the remaining elements that correspond to the buffer content process drifting through a region. Although the dynamics of the buffer content process do not change according to which region the buffer content is in, there are some key differences between each type of region, which we now discuss. Essentially, there are three types of regions. The first type is that of region 1, which only has an upper threshold (hitting or remaining on the lower threshold in this region does not result in a Markov regeneration epoch). The second type of region is that of region N + 1, which only has a lower threshold. The third type of region is that of regions 2,...,N . Regions of this type have an upper and lower threshold. Ultimately, the type of region that we analyze will effect our boundary conditions, which will be discussed shortly. To obtain all remaining kernel elements, the steps that follow are carried out for each region individually, using a first passage time analysis. We leverage upon the results of Mahabhashyam et al [14] and similarly define a first passage time by T = inft∈R+ {t ≥ 0: X(t)= xi−1 or X(t)= xi} where xi−1 and xi are the lower and upper thresholds of the given region. Recall that we assume

x0 = 0 and xN+1 = ∞. Now, we define Huv(x, t) = P{T ≤ t, Z(T ) = v|X(0) = x, Z(0) = u} for xi < x < xi+1 and u, v ∈ £, and H(x, t) = [Huv(x, t)]u,v∈E . To compute the nonzero elements of the kernel for the given region, we need to obtain H(x, t). Actually, it turns out that we only need H(x, w) which is the Laplace- Stieltjes Transform (LST) of H(x, t) with respect to t, and this will become apparent shortly. The dynamics (Mahabhashyam et al [14]) of H(x, t) are governed by the following partial differential equation


∂H(x, t)


∂t
∂H(x, t)
— D
∂x
= QH(x, t)	(2)

where D = R — cI. Here c is the output capacity for the given region while I is the identity matrix and R = diag{r(1), r(2),..., r(|£|)}. Since each region has a different output capacity, states that have positive drift could be different from region to region and likewise for states with negative drift. The boundary conditions will change depending on which region we are analyzing.
Theorem 3.3 The boundary conditions for region 1 are
Huv(x1 — x0, t)=0 for r(u) — c1 < 0, r(v) — c1 < 0,	(3)
Huu(x1 — x0, t)=1 for r(u) — c1 > 0,	(4)
Huv(x1 — x0, t)=0 for r(u) — c1 > 0, u /= v,	(5)

˜	Σ ˜
quv′
	—quu

Huv(0, w)= 
v′/=u
Hv′u(0, w)
uu


—quu + w
for r(u) — c1 < 0, r(v) — c1 > 0.
(6)

The boundary conditions for region i (for i = 2,...,N) are
Huu (0, t)=1 for r(u) — ci < 0,	(7)
Huv (0, t)=0 for r(u) — ci < 0, u /= v,	(8)
Huu (xi — xi—1, t)=1 for r(u) — ci > 0,	(9)
Huv (xi — xi—1, t)=0 for r(u) — ci > 0, u /= v.	(10)
The boundary conditions for region N +1 are
Huu (0, t)=1 for r(u) — cN+1 < 0,	(11)
Huv (0, t)=0 for r(u) — cN+1 < 0, u /= v.	(12)
Proof. Equation (3) is because the first-passage time cannot occur when the drift is negative (the only way a first-passage time will occur is when the buffer content process hits threshold x1 from below, which cannot happen when the drift is neg- ative). Equation (4) is because the first-passage time occurs instantaneously and the state of the source modulating process cannot change states instantaneously. Therefore, the probability that the first-passage time occurs before t and the source modulating process remains in the same state is one. Equation (5) is similar to the second boundary condition in that the first-passage time occurs instantaneously but the source cannot be in two different states when this occurs. Therefore, the proba- bility that the first-passage time occurs before t and the source modulating process

is in two different states is zero. To derive Equation (6) which is in terms of the LST of Huv(0, t), where r(u) — c1 < 0 and r(v) — c1 > 0, notice that if the buffer content process reaches zero while the environment process is in state u, then the buffer content will remain at zero until the environment process changes to some state vj /= u. Necessarily, state vj must be such that r(vj) < c1 so that the buffer content can actually reach zero. Thus, the first passage time will be equal to the amount of time spent in state u plus some remaining time from state vj until the first passage time starting in state v. So by conditioning on vj and then unconditioning, we get Equation (6).
Equation (7) is because if the buffer content process is initially at the lower thresh- old, the first-passage time will occur instantaneously since the drift is negative. Therefore, the probability that the first-passage time will occur before time t and the source modulating process remains in the same state is one. Equation (8) is sim- ilar to the first in that the first-passage time occurs instantaneously, but the source modulating process cannot be in two different states at the same time. Therefore, the probability that the first-passage time will occur before time t and the source modulating process is in two different states is zero. The same reasoning that was applied to Equations (4) and (5) also applies to Equations (9) and (10).
Equations (11) and (12) are derived in the same way as Equations (7) and (8). 2
To solve the partial differential equations (PDE) in Equation (2), we take the LST across the PDE with respect to t and let A(w)= D—1(wI — Q) to obtain the following ordinary differential equation (ODE):
dH(x, w) = A(w)H(x, w).	(13)
dx
By using a spectral decomposition technique, the solution to Equation (13) can be obtained. For some j ∈ £, a general solution to the ODE is

⎛ H˜1v ⎞


|E|

H˜·v = ⎜	.
⎟ = Σ auv(w)eλu(w)xφu
(w)

⎝ H˜
|E|v ⎠
u=1


where auv(w) are unknown coefficients and λu(w) and φu(w) are, respectively, the eigenvalues and eigenvectors that are obtained by solving
Dλu(w)φu(w)= (wI — Q)φu(w) for u ∈ £.
Remark 3.4 To obtain the unknown coefficients auv(w) we use (i) the boundary conditions of the appropriate region through Theorem 3.3; and (ii) set auv(w)=0 if λu(w) > 0 to ensure that Huv(x, t) will be a joint probability distribution as x → ∞. This would result in the right number of equations to solve for the unknown coefficients auv(w).

Solving the differential equation for each region actually yields the LST H(x, w) but this is all that is needed for our analysis, which become apparent shortly. Hence we do not need to invert the LST at all. We now show how to use the results of this section to obtain the LST of the kernel G˜ (w).

Obtaining the kernel
In this section, we show how to combine the results from previous sections to obtain
G(w). Having solved Equation (13) for each region and using Equation (1), we now have all the elements of G˜ (w). Recall that
G(i,u),(j,v)(t)= P{Y1 = (j, v), S1 ≤ t|Y0 = (i, u)} and

Huv(x, t)= P{T ≤ t, Z(T )= v|X(0) = x, Z(0) = u}.
We let Hi(x, w) be the matrix obtained from the first-passage time analysis of region
i. With this in mind, we can determine the nonzero elements of G˜ (w) by
⎧ H˜i+1(0, w)	if j = i + 1, r(u) > ci+1 and r(v) > ci+1,

˜	⎨⎪ H˜i
(xi — xi—1, w) if j = i — 1, r(u) < ci and r(v) < ci,



⎪⎩ H˜i
(xi — xi—1, w) if j = i, r(u) < ci and r(v) > ci.

(14)


Note that G(i,u),(j,v)(t) is the conditional probability that a sojourn time will end at threshold xj when the state of the source modulating process is in state v in a time less than t, given that the previous Markov regeneration epoch occurred at threshold xi and the state of the source modulating process was initially state
u. Notice that if j = i + 1, then the buffer content process drifts from threshold xi to threshold xi+1 while the state of the source modulating process is in state u initially, and in state j when the buffer content crosses threshold xi+1. Therefore, G(i,u),(i+1,v)(w) is equivalent to Hi+1(0, w). In a similar fashion, the other cases follow. Having obtained the kernel, next we show how to compute the steady-state performance measures.

Obtaining the Steady-State Measures
Having obtained G(w), we are in a position to compute the steady-state measures pi and θi and subsequently O. Recall that these measures are a function of x1,..., xN . With that understanding, for ease of exposition we leave pi, θi and O as they are and not write them as pi(x¯), θi(x¯) and O(x, x¯) where x¯ is a vector containing the threshold values and for some arbitrary x > xN+1.

Expressions for pi and θi for all i
We first need to obtain the limiting probabilities for the states of the SMP {W (t),t ≥ 0} as well as their expected sojourn times. Let τ(i,u) to be the expected sojourn time the SMP {W (t),t ≥ 0} spends in state (i, u) for i = 1, 2,...,N and u ∈£ and τ = [τ(1,1) τ(1,2) ··· τ(N,|E|)]. Thus,



τ(i,u)
= —
(j,v)∈{1,2,...,N }×E
  
dw G˜

(i,u),(j,v)
(w)
w=0
(15)

Notice that {Yn,n ≥ 0} is a discrete-time Markov chain (DTMC) embedded in
{W (t),t ≥ 0}. Let π = [π(1,1) π(1,2) ··· π(N,|E|)] be the steady-state transition probabilities of the embedded DTMC. Using the fact that π = πG˜ (0) (since π =
π and τ , the steady-state measure pi can be computed for i = 1, 2,...,N +1 by

p = ΣΣ(i,u)∈Ri π(i,u)τ(i,u)
 

(16)

where T is an index set for the set of thresholds and Ri is an index set that determines an appropriate subset of states from the state space of {W (t),t ≥ 0}. We let R1 = {(1, u): r(u) — c1 < 0, u ∈ £} which is the set of all states that drift through region 1. Similarly, we let RN+1 = {(N + 1, u): r(u) — cN+1 > 0, u ∈ £} which is the set of all states that drift through region N +1. Finally, for i = 2,...,N , we let Ri = {(i — 1, u) : r(u) — ci—1 > 0, u ∈ £} ∪ {(i, u) : r(u) — ci < 0, u ∈ £}. In this case, Ri is the set of all states that drift through region i for i = 2,...,N . Similarly, the steady-state measure θi can be computed for i = 1, 2,...,N by

θ = ΣΣ(i,u)∈Ti π(i,u)τ(i,u)



(17)

where Ti = {(i, u) : r(u) — ci > 0, r(u) — ci+1 < 0, u ∈ £} for i = 1, 2,...,N . In other words, Ti is the set of states that get stuck on threshold i (with the under- standing that θi =0 if Ti is the null set).

Computing the Tail Probability (O)
In this section we demonstrate how to compute the tail probability O = limt→∞P{X(t) > x} for some x > xN . For that, let DN+1 be the diagonal drift matrix in region N + 1. Therefore, DN+1 = R — cN+1I. Now, let γ1,..., γ|S| be the eigenvalues of (DN+1)—1Q and ψ1,..., ψ|S| be the corresponding left eigenvectors. Let M be the set of states with positive drifts, i.e. M = {u ∈ £ : r(u) > cN+1}. Define constants lu for all u ∈£ that satisfy the following conditions:

lu =0	if Re(γu) > 0
lu = 1/(ψu1)	if γu =0 


v∈M∪{0}
lvψv(u)=0	if u ∈ M



where 1 is a column vector of ones and l0 is equal to the lu for which γu = 0 (likewise ψ0 as well). Thereby, the following theorem gives an expression for the tail probability O.
Theorem 4.1 For any given x > xN , the tail probability O is given by

1 — Σ|E|
Σ|E|

lveγv(x—xN )ψv (u)

|E|
u=1
.
|E|
v=1
lvψv(u)

Proof. By conditioning on the region that the buffer content process is in we get
O = lim P{X(t) > x}
t→∞
= lim P{X(t) > x|X(t) < x1}p1 + Σ lim P{X(t) > x|xi—1 < X(t) < xi}pi

+ lim P{X(t) > x|X(t) > xN }pN+1
t→∞
= lim P{X(t) > x|X(t) > xN }pN+1
t→∞

where the last equality comes from the fact that the buffer content process cannot si- multaneously be less than xN and greater than xN . Notice that P{X(t) > x|X(t) > xN } is stochastically identical to P{ξ(t) > x — xN |ξ(t) > 0} where {ξ(t),t ≥ 0} corresponds to the amount of fluid in an infinite-sized buffer with constant output capacity of cN+1. Therefore, we get
O = lim P{ξ(t) > x — xN |ξ(t) > 0}pN+1
t→∞

= lim
P{ξ(t) > x — xN , ξ(t) > 0} p

t→∞

= lim
P{ξ(t) > 0}
P{ξ(t) > x — xN } p
N +1

(18)

t→∞
P{ξ(t) > 0}
N +1

Thus, we need to compute limt→∞ P{ξ(t) > y} and to do so, we leverage upon the results of a standard single-buffer model where the output capacity of the buffer is equal to cN+1 and the source modulating process is a CTMC with state space £. Using the results from Kulkarni [12] we get

|E|  |E|
lim P{ξ(t) > y} =1 —	lveγvyψv(u).
t→∞
u=1 v=1
Now substituting x— xN and 0 for u in the numerator and denominator in Equation

(18), we get

1 — Σ|E|

Σ|E|


lveγv(x—xN )ψv (u)

|E|
u=1
|E|
v=1
lvψv(u)
2

Computing Optimal Thresholds
Given a set of thresholds x1,..., xN , in Section 3 we outlined how to obtain the probabilities pi for all i ∈ {1,...,N +1}, θi for all i ∈ {1,...,N } and O. In this sec-

tion we devote our attention to obtaining optimal thresholds x∗,..., x∗
by solving

1	N
the optimization problem described in Section 2. We now describe an algorithm to
search through the space of x1, .. ., xN values by computing the objective function and constraint using the method in Section 3 to obtain the optimal one.

Search Algorithm
To obtain the optimal thresholds x∗, .. ., x∗ , we describe an iterative algorithm as
1	N
follows:
Generate a candidate vector of thresholds x = [x1 ... xN ] such that 0 ≤ x1 ≤
... ≤ xN ≤ B.
Compute pi(x) for all i ∈ {1,...,N + 1} and θi(x) for all i ∈ {1,...,N } using Equations (16) and (17) respectively.
Letting x = B in Theorem 4.1, compute O(B, x) and check if O(B, x) ≤ ϵ. If TRUE go to step 4, else to step 1 for a new x and report current x as infeasible.
Calculate C (x) using

N +1	N
C (x)= Σ βRpi(x)+ Σ βT θi(x)

where βR is the cost per unit time incurred when speed ci is used and βT is
i	i
the cost per unit time incurred toggling between speeds ci and ci+1.
If C (x) is the lowest cost then set the optimal threshold x∗ = [x∗ ... x∗ ] as
x.
If stopping criterion has not been attained go to step 1, else stop.
In the above algorithm, we need to determine an approach to generate candidates for the vector x as well as a criterion to stop. A natural candidate for that is a metaheuristic such as simulated annealing, genetic algorithm, tabu search, ant colony optimization, evolutionary computations, etc. However, since the elements of x are not discrete and there is an order 0 ≤ x1 ≤ ... ≤ xN ≤ B, some of the metaheuristics may need to be modified suitably. Since this is not the focus of the article, we have not delved into methods to solve the optimization problem. One may be able to take advantage of the characteristics of the function to be optimized.

In a few examples we found that with respect to one variable, say xi, the objective function and constraint function are convex or concave with respect to xi. Thus it may be possible to obtain more efficient gradient descent type algorithms as well. On the other end of the spectrum, especially for small problem instances (such as the one in the next section) it would be possible to do a complete (discretized) enumeration. For example by dividing the segment from 0 to B into B/Δ discrete values that xi can take by mapping into tiny segments of length Δ, one can completely enumerate by considering all (B/Δ)N alternative locations for the N thresholds.
It is worthwhile observing that as an alternative approach to the one outlined in Section 3, one could use the results in [6] and [10] based on matrix-analytic methods and Schur approximations respectively and obtain pi, θi and O. Since we need to compute the metrics for several candidate threshold values in the above algorithm, it is crucial to select the approach that is faster.
Remark 5.1 Based on our experiments in MATLAB version R2013B, we observed that for one iteration of the algorithm described above, our method requires on an average, half or less of the time required by the methods in [6] and [10]. Even though, the theoretical complexity of the three methods is the same, (O(N 3|S|3)), the difference in performance of the three methods arises from the fact that our method computes the pi values directly. The other two methods result in the prob- ability density function which has to be integrated over the regions to obtain the pi values.
Now we present a numerical example for computing the optimal thresholds for a given input process.

Numerical Example
Having described an algorithm to compute the steady-state measures pi and θi as well as an algorithm to obtain optimal threshold, next we demonstrate an applica- tion to energy consumption in data centers. A commonly used relationship between the output capacity and the energy consumed by a server is that of a cubic relation- ship (see for example Chen et al [4]). Using that, we let the energy cost per unit time associated with operating the server under output capacity ci be k0 +kc3 where k and k0 are fixed constants for all i ∈ {1,...,N + 1}. However, the output capacity of the server will be ci only when the buffer content process is in region i. Therefore, βR = k0 + kc3 is equal to the energy cost incurred per unit time while the buffer
i	i
content process is in region i. As previously stated, when the buffer content process
gets stuck on a threshold, the buffer contents spend an infinitesimal amount of time in each region that surrounds the threshold bouncing back-and-forth between the two regions. Thus, we denote the energy cost associated with operating on threshold

i (for all i ∈ {1,...,N }) by βT = Σ
j∈E
αij k0 + kc3 + Σ
j∈E
(1 — αij) k0 + kc3

where 0 < αij < 1. In order to compute the energy cost associated with operating
on threshold i while being in state j, we first consider which threshold the buffer content process is stuck on and the state of the environment process to compute αij,

then we compute βT . The output capacity C(t) will be equal to r(Z(t)) whenever, say X(t) = xi, Z(t) = j and cj < r(i) < cj+1. Therefore, we define αij to be the solution to r(j)= αci +(1—α)ci+1. With this in mind, we can compute the long-run average cost per unit time for running the server which we denote by C . If we know the output capacity at a given time then we know how much cost we are incurring per unit time. Say, for example, that the output capacity is c1 and we are in region 1, then we know that we are incurring a cost of βR per unit time. Similarly, if the buffer content process is stuck on, say, threshold x1 then we are incurring a cost

of βT
per unit time. Therefore, it can be shown that, by conditioning on the SMP

{W (t),t ≥ 0} in steady-state and unconditioning, the long-run expected cost per unit time is given by
N +1	N

C = Σ piβR + Σ θiβT

(19)

Further, using Equation (19) we can select the optimal set of thresholds x∗ by minimizing the long-run energy cost for running the server subject to O(B, x∗) ≤ ϵ

and 0 ≤ x∗ ≤ ... ≤ x∗
≤ B. Now that we have shown how to compute the steady-

1	N
state measures pi and θi as well as the long-run expected cost for running the server
C , we present a numerical example.
For our numerical example to demonstrate how the above procedure can be used to compute the steady-state measures pi and θi, and obtain the optimal set of thresholds x∗, we consider N = 3, i.e. a buffer with 3 thresholds, x1, x2, and x3, which creates four regions. We first consider the case where x1, x2 and x3 are fixed (subsequently we will optimize it). In particular, we let xi = i for i = {1, 2, 3}. This means that the distance between each threshold is 1. We let the buffer output capacity (in MB/sec) for region i, ci = i for i = {1, 2, 3, 4}. In this example, the environment process that governs fluid input into the buffer {Z(t),t ≥ 0} has state-space £ = {1, 2, 3, 4, 5, 6} and the infinitesimal generator matrix Q is given by:
⎛ —11 2.5	3	1.5 2.5 1.5 ⎞

⎜
Q = ⎜
⎜
⎜⎜⎝
⎟
⎟ .
⎟
⎟⎟⎠



The rate at which fluid flows (in MB/sec) into the buffer for each state is given by the vector [r(1) r(2) r(3) r(4) r(5) r(6)] = [0.7 0.9 2.2 3.7 4.2 8.0]. We solve Equation (13) for each region to determine the nonzero elements of the kernel. We use Equation (1) to obtain elements of the kernel that correspond to states where the buffer content process bounces back-and-forth across a threshold. To obtain the

LST of the kernel we use Equation (14). In this example, there are two states that bounce back-and-forth across thresholds, namely states (2, 3) and (3, 4). To see this, consider the state (2, 3), i.e. threshold 2 and environment state 3. Fluid flows into the buffer at rate 2.2 MB/sec when Z(t) = 3 and the output capacity for region 2 is 2 MB/sec. This results in a positive drift of 0.2 MB/sec, however, in region 3, the output capacity is 3 MB/sec. This results in a negative drift of 0.8 MB/sec. As a result of this, the buffer content process bounces back-and-forth across threshold x2 when the state of the environment process is Z(t) = 3. A similar situation occurs at threshold x3 when Z(t) = 4. The next step is to compute the expected sojourn times that the SMP {W (t),t ≥ 0} spends in each state. Using Equation (15), we get the sojourn times found in Table 1.
Table 1 Expected Sojourn Times

Recall that π is the vector of steady-state transition probabilities of the embedded DTMC. In this example π = [π(1,1) π(1,2) ··· π(3,6)] and using the fact that π = πG(0) and  (i,j) π(i,j) = 1 we can compute the steady-state transition probabilities
which are shown in Table 2.
Table 2 Transition Probabilities

At this point, we have everything needed to compute the steady-state measure pi and θi. Using Equations (16) and (17) we compute values for pi and θi which can be found in Table 3.

Table 3
Steady-State Measures

From Table 3, we can see that the buffer content process spends approximately 60% of the time in region 3. Notice that θ1 = 0. This is because there is no state so that the buffer content process can bounce back-and-forth across threshold x1. Also, there is no θ4 since there are only three thresholds. After computing the steady-state measures pi and θi, we can now use Equation (19) to compute the long-run average cost per unit time for running the server. For example, letting k0 = 10 and k = 1.5, and using Equation (19) along with values from Table 3 results in a long-run expected cost of 53.63. However, if we always run the server at the highest speed, the long-run expected cost per unit time would be 106 since
k0 + kc3 = 10 + 1.5 · 43. Therefore, we have significantly reduced the long-run
expected cost by approximately 51%.
So far in this section we have considered threshold values x1 = 1, x2 = 2 and

x3 = 3. Now we turn our attention to obtaining optimal thresholds x∗, x∗
and

1	2
x∗. For that we use B = 10 MB and ϵ = 0.0001 to find the smallest average cost
per unit time given in Equation (19) so that O(B, x1, x2, x3) computed by letting

x = B in Theorem 4.1 is such that O(B, x∗, x∗, x∗) ≤ ϵ and 0 ≤ x∗ ≤ ... ≤ x∗
≤ B.

1	2	3	1	N
We generate new instances of x1, x2 and x3 described in the algorithm in Section
5 using complete enumeration with a step size of 0.5, and the stopping criteria is when all the points are enumerated. The algorithm resulted in an optimal solution of x∗ = 0.5, x∗ = 1.0 and x∗ = 7.5 (all in MB).
1	2	3
7	Concluding Remarks
In this article, we present the computation of steady-state performance measures for an infinite-sized fluid buffer with multiple thresholds and state-dependent out- put capacity and consequently an algorithm to come up with the optimal set of thresholds. In our model, the N thresholds partition the buffer into N + 1 regions where each region has a given output capacity, while the environment process that controls the rate at which fluid flows into the buffer is a continuous-time Markov chain. When the environment process is in state u, fluid flows into the buffer at rate r(u). We model the system as a semi-Markov process with the state of the system represented by the region in which the buffer fluid level is at any point of time and the state of the source modulating process. We show how to compute the steady-state performance measures pi, which is the long-run fraction of time the

buffer content process spends in region i and θi, which is the long-run fraction of time the buffer content process spends on threshold xi.
It is also possible to obtain pi and θi using other methods (see [10] and [6]). However, we found that our method using semi-Markov process modeling and spec- tral methods is much faster. In particular, while obtaining optimal thresholds x∗,
.. ., x∗ , we certainly need an extremely fast way to obtain the metrics. In this arti- cle we also obtained the probability of exceeding a buffer content level B in steady state. We used those to formulate and solve an optimization problem to minimize energy cost per unit time subject to quality of service (in terms of fluid level in the buffer) constraints. We suggested simple algorithms such as complete enumeration and meta-heuristics for this purpose. In the future we will consider other methods that leverage upon the structure and relationship between the threshold values and the costs. In addition, we seek to model an entire data center as a network of fluid buffers so that we can determine an optimal routing strategy for k classes of fluid customers in an attempt to further minimize energy consumption in data centers. Our work continues in this direction.
Acknowledgment
This material is based upon work partially supported by NSF under grant CMMI- 0946935 and the AFOSR under Contract No. FA9550-13-1-0008.

References
V. Aggarwal, N. Gautam, S. R. T. Kumara, and M. Greaves. Stochastic fluid flow models for determining optimal switching thresholds with an application to agent task scheduling. Performance Evaluation, 59(1):19–46, 2004.
S. Ahn and V. Ramaswami. Efficient algorithms for transient analysis of stochastic fluid flow models.
Journal of Applied Probability, 42(2):531–549, 2005.
D. Anick, D. Mitra, and M. M. Sondhi. Stochastic theory of a data handling system with multiple sources. Bell System Technical Journal, 61:1871–1894, 1982.
Y. Chen, A. Das, W. Qin, A. Sivasubramaniam, Q. Wang, and N. Gautam. Managing server energy and operational costs in hosting centers. SIGMETRICS Perform. Eval. Rev., 33:303–314, June 2005.
A. da Silva Soares and G. Latouche. Matrix-analytic methods for fluid queues with finite buffers.
Performance Evaluation, 63:295–314, May 2006.
A. da Silva Soares and G. Latouche. Fluid queues with level dependent evolution. European Journal of Operational Research, 196(3):1041–1048, August 2009.
A. I. Elwalid and D. Mitra. Analysis, approximations and admission control of a multi-service multiplexing system with priorities. In Proc. IEEE INFOCOM, volume 2, pages 463–472, Apr 1995.
N. Gautam, V. G. Kulkarni, Z. Palmowski, and T. Rolski. Bounds for fluid models driven by semi- markov inputs. Probability in Engineering and Informational Sciences, 13(4):429–475, 1999.
L. Huang and T.T. Lee. Generalized pollaczek-khinchin formula for markov channels. IEEE Transactions on Communications, 61(8):3530–3540, August 2013.
H. E. Kankaya and N. Akar. Solving multi-regime feedback fluid queues. Stochastic Models, 24(3):425– 450, 2008.
V. G. Kulkarni. Modeling and analysis of stochastic systems. CRC Press, 1996.


V. G. Kulkarni. Fluid models for single buffer systems. Frontiers in queueing: Models and applications in science and engineering, 321:338, 1997.
V. G. Kulkarni and N. Gautam. Admission control of multi-class traffic with service priorities in high speed networks. Queueing systems: Theory and Applications, 27(1-2):79–97, 1997.
S. R. Mahabhashyam, N. Gautam, and S. R. T. Kumara. Resource-sharing queueing systems with fluid-flow traffic. Operations Research, 56:728–744, May 2008.
R. Malhotra, M. Mandjes, W. Scheinhardt, and J. van den Berg. A feedback fluid queue with two congestion control thresholds. Mathematical Methods of Operations Research, 70:149–169, 2009.
McKinsey & Company. Revolutionizing Data Center Efficiency. Uptime Institute Symposium, http://uptimeinstitute.org/content/view/168/57, 2008.
A. Narayanan and V. G. Kulkarni. First passage times in fluid models with an application to two- priority fluid systems. In IEEE International Computer Performance and Dependability Symposium, 1996.
M. OReilly. Multi-stage stochastic fluid models for congestion control. European Journal of Operations Research (submitted), 2013.
