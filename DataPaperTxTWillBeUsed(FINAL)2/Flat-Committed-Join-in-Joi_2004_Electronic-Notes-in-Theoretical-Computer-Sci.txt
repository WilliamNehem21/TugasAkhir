Electronic Notes in Theoretical Computer Science 104 (2004) 39–59  
www.elsevier.com/locate/entcs


Flat Committed Join in Join 1
Roberto Bruni, Herna´n Melgratti and Ugo Montanari
Dipartimento di Informatica, Universita` di Pisa, I-56127 Pisa, Italy,
{bruni,melgratt,ugo}@di.unipi.it


Abstract
Committed Join (cJoin) is an extension of Join with high-level primitives for programming dynamic nested negotiations with compensations. In this paper we show that flat cJoin processes (i.e. processes without sub-negotiations) can be encoded in the ordinary Join calculus by exploiting a distributed two-phase commit protocol. In particular, we first define a type system that singles out flat processes and prove subject reduction for it. Then, we show that all flat cJoin processes can be written in an equivalent canonical form, where a few elementary definition patterns are used. Finally, we show that canonical flat processes can be implemented in Join. It is worth noting that negotiation primitives are encoded as fully distributed agreements between all participants, thus avoiding a centralized coordinator.
Keywords: Committed Join, Join Calculus, Distributed Negotiations, Zero-safe Nets, Orchestration.


Introduction
Recently, in the area of formal languages, there is a renewed interest from both Academic and Industrial research concerning the design of orchestra- tion primitives for programming largely distributed and long-running decision processes [3,8,2,13]. The increasing number of applications in the area of e-commerce, web services choreography and orchestration patterns demands a rigorous mathematical presentation of such languages, to support formal analysis and verification.

1 Research supported by the MSR Cambridge Project Napi, by the FET-GC Project IST-2001-32747 Agile, by the MIUR Project COFIN 2001013518 CoMeta, and by the MURST-CNR 1999 Project, Software Architectures on Cooperative WAN.


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.09.021


Committed Join (cJoin) [5] is an extension of the Join calculus with prim- itives for handling distributed negotiations (also called contracts). Roughly, negotiations are processes that execute in a controlled environment until com- pletion, when they commit and make their results observable to the rest of the system. Additionally, they can be explicitly aborted, in which case, suit- able compensation programs can be activated to resume a locally consistent state. A distinctive feature of cJoin is that several negotiations can be merged during their execution into a larger one. This occurs when two or more par- ticipants to different negotiations communicate through special ports, called merge names. Interacting negotiations are bound together, and thus they will jointly reach the same decision, i.e. if one of them eventually commits (resp. aborts) all will eventually commit (resp. abort). This is particularly inter- esting for designing multi-party negotiations, where independent participants can provide transactional services making explicit the ways in which parties can interact, and where the actual structure of a negotiation is discovered at runtime.
The approach of cJoin contrasts with approaches such as [3], where business processes are described as graphs that spawn across organization boundaries requiring all participants to be known statically. Moreover, partners cannot hide interactions with third parties that can influence the final decision.
Crucial points about the implementation of cJoin are: (1) the commit of interacting negotiations as a global decision, and (2) the number of parti- cipants and their identities are not known statically. We show that, for a significant fragment of cJoin, global decisions can be implemented in a fully distributed way by using the distributed two phase commit protocol (d2pc) proposed in [4] for implementing zero-safe nets [6] (a transactional extension of Petri nets). Note that the Join code written for the d2pc in the case of zero-safe nets can be imported and reused with minor modifications in the encoding of cJoin, giving evidence of its generality.
cJoin is much more expressive than zero-safe nets, as it retains the full expressive power of ordinary Join. The presence of compensations and of merge names increases the level of complexity of the encoding, making it far from trivial. Indeed, we restrict ourselves to consider cJoin processes that can be typed as flat, meaning that they will never generate nested negotiations. We show that flat processes form a sub-calculus of cJoin by proving the subject reduction property for them. Moreover, a suitable form of serializability is guaranteed to hold for flat cJoin. We show that the cJoin encoding of any zero-safe net is a flat process.
To facilitate the translation, we define the encoding of flat processes that are written in a suitable canonical form, where only a few elementary definition


patterns are allowed. This can be done without loss of generality, as we show that any flat process can be transformed in an equivalent process in canonical form. The elementary definition patterns we consider are inspired by the basic shapes of transitions in zero-safe nets: they are obtained by imposing a strict bound on the number of messages that can be consumed / produced within a single reduction.
Although we show that Join is expressive enough to encode flat cJoin, i.e. that the new primitives for flat negotiations do not increase the expressivity of the language, we argue that the syntax of cJoin yields a separation of concerns that is difficult to achieve at the level of Join, thus cJoin facilitates programming and reasoning about distributed contracts. We conjecture that by further elaborating the encoding of flat processes one should be able to implement full cJoin in Join.
Structure of the paper. In § 2 we present the syntax and semantics of cJoin. In § 3 we define the type system for flat processes, prove subject reduction and show that the encoding of zero-safe nets presented in [5] yields flat processes. Moreover, we show that flat processes have equivalent canonical represent- atives that employ only elementary definition patterns. In § 4 we present a correct and complete distributed encoding of canonical flat cJoin processes in Join.

Background
cJoin syntax. The Join calculus [10] isa process description language (PDL) with asynchronous name-passing communication and it has the same express- ive power as the asynchronous π-calculus. Committed Join (cJoin) [5] is a conservative extension of Join with additional high-level primitives for pro- gramming dynamic nested negotiations with compensations. Like Join, cJoin relies on an infinite set of names x, y, ..., u, v, ... to model communication chan- nels and transmitted values. Name tuples are written →u. The syntax of cJoin is given in Figure 1. cJoin differs from Join because of the additional operators abort, [P : Q] and J ► P .
Messages M can be either the inert process 0, the asynchronous emission
x⟨→y⟩ of message →y on port x, or the parallel composition of messages M|N.
Processes P , can be plain messages, the special constant abort causing the abort of its enclosing negotiation, a negotiation [P : Q], where P is the normal execution of the activity and Q is its compensation in case of abort, the parallel composition of processes P |Q, or a process def D in P equipped with local ports defined by D.
A deﬁnition D is a conjunction of ordinary and merge reaction rule, J d P


M, N ::= 0 | x⟨y→⟩ | M |N	 D, E ::= J d P | J ► P | D ∧ E P, Q ::= M | abort | [P : Q] | P |Q | def D in P	J, K ::= x⟨y→⟩ | J|K
Figure 1. cJoin Calculus Syntax.
dn(x⟨y→⟩)={x}		dn(J|K)=dn(J) ∪ dn(K)			rn (x⟨y→⟩)={y→}		rn(J|K)=rn(J) ∪ rn (K) dn o(D ∧ E) =dno (D) ∪ dno (E)		dno (J d P ) =dn (J)				dn o(J ► P ) =∅ dn m(D ∧ E)=dnm(D) ∪ dn m(E)		dnm(J d P )=∅				dnm(J ► P )=dn(J) fn(D ∧ E)=fn(D) ∪ fn(E)			fn(J ► P )= fn(J d P )=dn(J) ∪ (fn(P )\rn(J)) fn(0)=∅	fn(abort )= ∅	fn(x⟨y→⟩)={x}∪ {y→}		fn(P |Q)=fn(P ) ∪ fn(Q) fn(def D in P )= (fn(P ) ∪ fn(D))\dn(D)				fn([P : Q]) = fn(P ) ∪ fn(Q)
Figure 2. Defined, received, and free names.
m ::= P | D | ıPτ | {[S]}	S ::= m | m, S

Figure 3. Syntax of cJoin molecules and solutions.

and J ► P respectively, that associate join-patterns J with guarded processes
P . Names introduced by the definition D of def D in P are bound in the whole process P as well as in the guarded processes contained in D. The sets of defined names dn, received names rn and free names fn are defined in Figure 2. In particular, we distinguish between defined ordinary names dno(D) and defined merge names dnm(D) that are always assumed to be disjoint sets of names.

cham.
The operational semantics of cJoin is given in the reflexive cham style [10], where states (called solutions) are finite multisets of terms (called molecules), and computations are multiset rewrites. Multisets are written as m1,... , mn. We usually abbreviate m1,... , mn with ⊗i mi. Solutions can be structured in a hierarchical way by using the operator membrane {[.]}, grouping a solution into a molecule. Transformations are described by a set of chemical rules, which can be of two different kinds: heating / cooling (or structural ) rules for syntactical rearrangements of molecules in a solution, and reaction rules → for basic computation steps. Rules only address the part of the solution that actually moves and can be applied at any level in the hierarchy. Molecules m and solutions S for cJoin are in Figure 3.
Note that processes and definitions are molecules. Additionally, molecules having the form ıQτ denote compensations that are frozen inside a solution and that will not be executed unless their negotiation aborts. To reason up-to structural equivalence, we shall overload → to denote also sequences  ∗→  ∗.


Operational semantics of cJoin.
The chemical rules for cJoin are given in Figure 4. The first five chemical rules are the ordinary ones for Join. Rule str-null states that 0 can be added or removed from any solution. Rules str-join and str-and stand for the
associativity and commutativity of | and ∧. str-def denotes the activation
of a local definition, which implements a static scoping discipline by properly renaming defined ports by globally fresh names. We write the substitution of names x1 ... xn by y1 ... yn as σ = {y1...yn/x ...x }, with dom(σ)= {x1,..., xn} and range(σ)= {y1,... , yn}. We indicate with σN an injective substitution σ such that dom(σ)= N. We require newly defined names to be globally fresh, which means fresh w.r.t the implicit context in which the rule is applied. The reaction red describes the application of an active definition JdP to messages Jσ matching the pattern J (for a suitable substitution σ, with dom(σ) = rn(J)). The instance of J is consumed and replaced by a new instance Pσ of the guarded process P .
Rule str-cont states that a term denoting a contract corresponds to a sub-solution consisting of two molecules: the process P and its compensation Q, which is frozen (because the operator ı.τ forbids the enclosed process to compute). At commit time, the local resources M produced inside a nego- tiation are released via the rule commit, which can be executed only when all internal computations have finished. At commit time, private definitions of a contract can be discarded, because neither the messages that are being released contain those names nor they could have been extruded previously. After commit, its compensation procedure ıQτ is useless and can be discarded as well. The abortion of a negotiation is handled by the rule Abort, which releases Q whenever abort is present in the solution.
Interactions among negotiations are dealt with merge, which consumes messages from different contracts and creates a larger negotiation by combin- ing the definitions and messages of the original ones with a new instance of the guarded process Pσ, where dom(σ) = rn(J1| ... |Jn). Name clashes are avoided because we assume that str-def generates globally fresh names. The compensation for the joint negotiation is the parallel composition of all the original compensations.


Example 2.1 Mailing list. Consider a data structure that allows to send atomically a message to a list of subscribers (in the sense that it is either sent to all or to none). Such structure can be defined as ML ≡ MailingList ⟨k ⟩ d MLDef, where:
MLDef ≡ def List in k⟨add , tell , close⟩ | l⟨nil⟩


str-null	0 
str-join	P | Q   P, Q
str-and	D ∧ E   D, E
str-def	def D in P   Dσdn(D),Pσdn(D) (range(σdn(D)) globally fresh)
red	J d P, Jσ → J d P, σ
str-cont	[P : Q]   {[P, ıQτ]}
commit	{[M |def D in 0, ıQτ]} → M
abort	{[abort |P, ıQτ]} → Q
merge	J1 | ... |Jn ► P, N {[Jiσ, Si, ıQiτ]} → J1 | ... |Jn ► P, {[N Si,Pσ, ıQ1 | ... |Qnτ]}
i	i
Figure 4. Operational semantics of cJoin.

List ≡	nil⟨v, w⟩ ► w⟨⟩
∧ l⟨y⟩| add ⟨x⟩ d def z⟨v, w⟩ ► x⟨v⟩ | y⟨v, w⟩ in l⟨z⟩
∧ l⟨y⟩| tell ⟨v⟩ d [def z⟨⟩ d 0 in y⟨v, z⟩ | l⟨y⟩ : l⟨y⟩]
∧ l⟨y⟩| close⟨⟩ d 0
A new mailing list is created by sending a message to the port MailingList. Since cJoin adheres to the “continuation passing” style of programming, the content of the message sent to MailingList is a continuation port k, which expects information about the newly created mailing list. The creation of a new list defines five fresh ports nil, l, add, tell and close: three of them (namely add, tell, and close) will be used to interact with the list from “outside” and will be sent to the port k as the outcome of the creation. The remaining two ports will never be extruded. They denote the empty list (nil ) and the actual state of the list (l).
Once a list is created, a new subscriber can be added by sending a message add with the name x of the port where it will be listening to for new messages. In this case, the list is modified by installing x (on top of it), a forwarder of messages to x.
The port tell is used to send a message v to the list. When tell is received a new negotiation identified by a fresh name x is generated, and the state of the structure is put inside the negotiation, therefore all other activities, such as adding or closing are blocked until the negotiation ends. Inside the negotiation, the message v is sent to the forwarder at the top of the list y with the identifier of the negotiation x. Note that each forwarder sends the message to the corresponding subscriber and to the following forwarder in the list. This is repeated until nil is reached, when a message to the identifier of the transaction is sent. The firing rule x⟨⟩ d 0 consumes the last local name and the contract commits by releasing all the messages addressed to the subscribers and the state of the list. Then the list is ready to serve new requests.

Flat cJoin
Flat transactions were introduced in database community as a basic mechan- ism to assure atomic execution of composed activities. The term flat specifies that the activities forming a transaction are basic actions, such as read and write, but they cannot be transactions themselves. Similarly, we define a sub- calculus of cJoin, called flat cJoin, where negotiations cannot be nested. In this section we characterize flat processes as well-typed terms and we show that any cJoin process can be written in an equivalent canonical form.
A type system for flat cJoin
We single out flat processes of cJoin with the type system in Figure 5. It takes the set T = { 0, 1, 2} of types and uses the following type judgments:
▶ P :  0	The constructor of negotiations [ : ] does not appear at all in P .
▶ P : 1	P does not contain active negotiations but can activate flat contracts.
▶ P :  2	P can have or generate flat negotiations but not nested ones.
▶ D :  0	D does not contain constructors for negotiations.
▶ D :  1	D can contain or initiate flat negotiations but not nested ones.
Rules (Sub-P) and (Sub-D) stand for the sub-type order 0 < 1 < 2. We say that a process P (resp. a definition D) is well-typed if ▶ P :  2 (resp.
▶ D :  1).
Clearly, the inert process 0, the emission of a message x⟨→y⟩ and the constant abort do not contain constructors for negotiations, and are typed 0. By rule (Par), the parallel composition P |Q can be typed i if both P and Q type i. Consequently, the type of P |Q corresponds to the greatest of the lower types that can be assigned to P and Q. In fact, considering P and Q well-typed, if P contains an active negotiation (i.e., ▶ P : 2), independently of the structure of Q, the process P |Q contains an active contract (i.e., ▶ P |Q : 2). Rule (Neg) prevents nesting by stating that [P : Q] can be typed  2 only when P does not have negotiations (i.e., ▶ P : 0). Instead, the compensation Q can use negotiations in definitions. This will not compromise flat condition because compensations execute at the top-level and not inside the negotiations they are originated from. Rule (Def) combines the typing of definitions and processes. Note that def D in P can be typed  0 only if neither D nor P use constructors for negotiations, i.e. if both have type 0. Instead, it can be typed  1 when negotiations appear only in definitions (D or those contained


Figure 5. Flat cJoin Typing.

in P ). Finally, if def D in P types  2, its active negotiations appear in P , which therefore types 2.
By rule (Conj), a conjuction of definitions is typed  i only when both

sub-terms type  i. By rules
(Ord)
and
(Ord-0), an ordinary definition

J d P is well-typed when its guarded processes P is well-typed. Moreover, it has type 0 if P does not contain constructors for negotiations (i.e., ▶ P : 0). Differently, a merge rule is well-typed only if P has type 0 (rule (Merge)). This is required in order to avoid nesting, because the instances of P will execute inside a negotiation.
Example 3.1 Well-typed terms. Consider the mailing list process introduced in Example 2.1. Several subterms and their types are below:
P1 ≡ def z⟨⟩ d 0 in y⟨v, z⟩ | l⟨y⟩	P2 ≡ [P1 : l⟨y⟩]
D1 ≡ l⟨y⟩ | tell ⟨v⟩ d P2	D2 ≡ l⟨y⟩| close⟨⟩ d 0
▶ P1 :  0	▶ P2 :  2	▶ D1 :  1	▶ D2 :  0	▶ D1 ∧ D2 :  1
Moreover, ▶ MLDef :  1 (it does not have active negotiations but can initiate them), and also ▶ ML :  1.
Example 3.2 Counterexample. The term def x⟨⟩ ► [P : 0] in [def D in x⟨⟩ : 0] is not well-typed because it has a merge definition whose guarded process is a negotiation (rule (Merge) cannot be applied because /▶ x⟨⟩ ► [P : 0]:  0). In fact, it reduces to def x⟨⟩ ► [P : 0] in [def D in [P : 0] : 0] when x /∈ dn(D), which has nested contracts.
Proposition 3.3 (Join processes are  0) Let P be a Join process, then ▶
P :  0.
Lemma 3.4 (Subject Reduction for  0) Let P :  0. If P →∗ P ' then
P ' :  0.
The following result assures that flat processes do not introduce nesting.

Theorem 3.5 (Subject Reduction for  2) Let P :  2. If P →∗ P ' then
P ' :  2.
Subject reduction does not hold for  1. Consider P ≡ def x⟨⟩ d [Q : Q'] in x⟨⟩, where ▶ Q :  0 and ▶ Q' :  1. Although ▶ P :  1, P reduces to P ' ≡ def x⟨⟩ d [Q : Q'] in [Q : Q'], which can be typed  2 but not  1.
Definition 3.6 [Flat cJoin] Let P be a cJoin process. P is flat iff ▶ P :  2. Flat cJoin is the sub-calculus of all flat processes.
In [5] we defined the class of shallow processes and proved a serializability result for them, meaning that disjoint negotiations cannot interfere with each other (unless they are merged). Although the definition of shallow processes is not reported here, it is trivial to check that flat processes are also shallow.
Corollary 3.7 (Serializability) Any flat process P is shallow and thus seri- alizable.
Zero Safe Nets and cJoin.
Zero-safe nets (zs nets) [6] have been introduced to model serializable trans- actions in concurrent systems. They support multiway transactions, i.e. with several entry and exit points and a statically unknown number of participants. Recently, they have been used in [4] to encode short-running transactions of Microsoft Biztalk◯r , a commercial workflow management system [13]. How- ever, zs nets are not suitable to model interesting aspects such as name mo- bility, programmable compensations and nesting, which are the main features of cJoin.
Analogously to Petri nets, zs nets rely on places (i.e. repositories of re- sources, messages), tokens (i.e. instances of places), markings U (i.e. multis- ets of place) and transitions U [⟩U ' (i.e. basic activities to fetch and produce multisets of tokens). However, the places of zs nets are partitioned into or- dinary and transactional ones (called stable and zero, respectively). Corres- pondingly, markings U can be seen as pairs (S, Z) with U = S + Z, where S and Z are the multisets of stable and zero resources, respectively. Tokens in zero places are transient data belonging to some ongoing negotiation, while tokens in stable places model committed decisions achieved via negotiations, which start from and lead to stable markings (i.e. multisets of stable places). The key point is that stable tokens produced inside a negotiation are made available only at commit time, when no zero tokens are left.
The operational semantics of zs nets is defined by the two relations ⇒T and
→T (indexed by the set of transitions T ) in Figure 6. Rules firing and step
are the ordinary ones for Petri nets. The rule concatenation composes zero



(firing)

S + Z [⟩ S' + Z' ∈ T
(step)
(S1 , Z1 ) →T (S' ,Z' ) (S2 , Z2 ) →T (S' ,Z' )

1  1	2  2
(S + S'',Z + Z'') →T (S' + S'',Z' + Z'')	(S1 + S2 , Z1 + Z2 ) →T (S' + S' ,Z' + Z' )

(concatenation)
(close)
1	2  1	2

(S1,Z) →T (S' ,Z'') (S2,Z'') →T (S' ,Z')	(S, ∅) →T (S', ∅)

1	2


(S1 + S2,Z) →T (S' + S' ,Z')


(S, ∅) ⇒T (S', ∅)

1	2
Figure 6. Operational semantics of zs nets (+ denotes multiset union).

tokens in series but stable tokens in parallel, hence stable tokens produced by the first step cannot be consumed by the second step. A negotiation (S, ∅) ⇒T (S', ∅) is a concatenation of steps from a stable marking to a stable markings (rule close).
In the literature, zs nets have been already encoded in Join [4] (via a dis- tributed two-phase commit protocol for establishing the end of a negotiation) and in cJoin [5] (almost straightforwardly, taking advantage of the additional negotiation primitives). We briefly recall the latter encoding  )cJ because:
Without loss of generality, both encodings are defined for zs nets made with the basic shapes in Figure 7(a) (which are as expressive as the general nets), for E any stable place and e, e1, e2 any zero places. We use mnemonic names like E open e to denote a transition E [⟩ e that can spawn a fresh local negotiation and e fork e1, e2 to denote a transition e [⟩ e1+e2 that can create parallel threads within a running negotiation. Basic shapes are analogous to the elementary definition patterns we shall consider when encoding flat cJoin in Join.
zs nets do not have programmable compensations. The encoding )cJ shows that suitable default compensations can just restore the initial state of the negotiation. As an original result, in Proposition 3.8 below we prove that zs nets are encoded as flat processes.

Encoding zs nets in cJoin.
The translation )cJ in Figure 7(b) associates a cJoin definition (resp. message) with each basic shape of transitions (resp. stable marking). Places are seen as ports and tokens as messages. Tokens in stable places carry no
value, while tokens in zero places carry the identifier of the transaction they belong to. For T the set of transitions and S the initial marking of the zs nets,

we let  T )cJ = 
t∈T
 t)cJ and then take the cJoin process def  T )cJ in  S)cJ,

which consists of the translation of the initial marking S in the environment
containing all the definitions associated with transitions in T . Transitions whose pre-sets contain zero places are translated as merge definitions, other- wise as ordinary Join definitions.



r,¸~ ~z, E



e,,.,,.,,fork e1, e,,.,,.,,2



 E open e)cJ ::= E⟨⟩ d [def z⟨⟩ d 0 in e⟨z⟩ : E⟨⟩]
 e fork e1, e2 )cJ ::= e⟨z⟩ ► e1⟨z⟩|e2 ⟨z⟩
 e1, e2 join e)cJ ::= e1 ⟨z1⟩|e2⟨z2⟩ ► e⟨z1⟩
 e1 calc e2 )cJ ::= e1 ⟨z⟩ ► e2⟨z⟩
 e drop )cJ ::= e⟨z⟩ ► 0
 e close E)cJ ::= e⟨z⟩ ► E⟨⟩

 E)cJ ::= E⟨⟩
 S1 + S2 )cJ ::= S1 )cJ| S2 )cJ

(b) Translation of basic shapes and markings.

e1, e2 join e	e close E
(a) Basic shapes of zs
nets.

Figure 7. Encoding of zs Nets in cJoin.

We shortly discuss a few peculiarities of the encoding (details are in [5]). The translation of a transition of the form E open e is a cJoin definition that can open a new negotiation containing the definition of a fresh name x (the identifier of the transaction) together with the message e⟨x⟩, and whose default compensation is the only stable resource E⟨⟩. The dummy definition x⟨⟩ d 0 is a convenient way to define a local identifier for the negotiation and has no computational meaning. In fact, no message will ever be produced on port
x. The port e corresponds to the homonymous zero place and it is a name defined externally via merge definitions (originated from those transitions in T fetching from place e), which can be used to compute inside negotiations and even merge them via the reaction merge of cJoin. For example, two disjoint negotiations with local tokens in e1 and e2 can be merged by firing a transition e1, e2 join e, i.e. by executing the merge reaction for e1⟨x1⟩|e2⟨x2⟩ ► e⟨x1⟩. Note that the identifiers x1 and x2 become then equivalent identifiers for the same larger negotiation. The key point is that when stable messages E⟨⟩ are released inside a negotiation, e.g., by firing e close E, then they cannot be fetched before the negotiation commits, because all the rules that can consume them are ordinary ones and float outside the negotiation boundaries.
While the correctness and completeness of the encoding can be found in [5], here we state the following original result based on the type system in Figure 5.


Figure 8. Definition of count (P ).

Figure 9. Definitions in canonical form

Proposition 3.8 (The cJoin encoding of zs nets is flat)
▶ def  T )cJ in  S)cJ :  2.

A canonical form for flat processes
As done with zs nets, we will restrict our attention to processes built with some basic shapes to simplify the definition of the encoding of flat cJoin into Join. In particular, we forbid definitions to consume and produce messages freely. The auxiliary function count in Figure 8 counts the atomic agents present in a process.
Definition 3.9 [Canonical Form] Let P be a flat process, P is in canonical form if any definition in P satisfies one of the conditions in Figure 9.
It is worth noting that these conditions match with the basic shapes of zs nets. By (Open), a reaction that creates a new negotiation consumes exactly one message and produces only one agent inside the new negotiation. Rule (Ord-Join) assures that a synchronization consumes two messages and produces exactly a new agent. Differently, rule (Merge-Join) allows to join several negotiations simultaneously. Moreover, a join cannot spawn directly a new negotiation (a task left to (Open)). Finally, rules (Ord-Mov) and (Merge-Mov) are instances of transitions calc, fork, and close (with drop as a particular case) of zs nets.
Proposition 3.10 Let P be a flat process. P can be written as an equivalent canonical flat process.
Example 3.11 The process MLDef in Example 2.1 is not in canonical form. In fact, the definition Tell ≡ l⟨y⟩ | tell ⟨v⟩ d [def x⟨⟩ d 0 in y⟨v, x⟩ | l⟨y⟩ : l⟨y⟩] is a join that creates a negotiation with two internal messages. It can be rewritten as


Tell' ≡ l⟨y⟩| tell ⟨v⟩ d a⟨y, v⟩
∧ a⟨y, v⟩ d [def x⟨⟩ d 0 in def b⟨⟩ d y⟨v, x⟩| l⟨y⟩ in b⟨⟩ : l⟨y⟩]
where a and b are fresh names. Note that ▶ Tell' : 1. Its first rule is an Ord-Join, while the second is an Open. In fact, the process contained in the negotiation has type 0 and the count of emitted messages is 1 (i.e. b⟨⟩). The definitions appearing inside the contract are in canonical form, actually they corresponds to Ord-Mov: x⟨⟩ d 0 is a drop and b⟨⟩ d y⟨v, x⟩ | l⟨y⟩ is a fork.
Proposition 3.12 (The encoding of zs is in canonical form) Let N = (T, S) be a zs net, then def T )cJ in S)cJ is already in canonical form.

Encoding flat cJoin in Join.
In this section we describe the encoding in Join of canonical flat cJoin pro- cesses. As we are interested in computations that start from and lead to consistent states, we restrict our attention to processes that start without act- ive negotiations, that is canonical flat cJoin processes that additionally type
 1. For simplicity, the encoding relies on Join calculus extended with the data type SET, for finite sets and the standard operations of emptyset ∅, union ∪, and difference \.
Processes are encoded by considering two sets of names: S denoting a set of ordinary names and B containing merge names, which are used to decide whether a free name in P is an ordinary or a merge one. Therefore, the encoding is well-defined only when fn(P ) ⊆ S ∪ B and S ∩ B = ∅.
Definition 4.1 [Encoding]. The Join process associated to a canonical flat
cJoin process P with type  1 is P )fn(P ),∅ (see Figure 10).

Top-level processes.
The function P )S,B defines the encoding for top-level processes. Note that the emission of a message in a stable name x is translated as a message on xs or xb considering whether the parameters →u are ordinary or merge names. Ports xs or xb are introduced by the encoding of definitions presented below. For simplicity we assume all names in →u are either ordinary or merge, but the presentation can be extended by using a different port for any possible combination.
A top-level message x⟨→u⟩ on a merge name (x ∈ B) lives outside a negoti- ation and cannot be consumed. Moreover, it is not observable because x is a


Top-level processes
0	'	'
 def D in P )S,B = def  D)S' ,B' in  P )S' ,B'	S = S  dno (D) & B = B  dn m(D)
 [P : Q])S,B	= def D ∧ cmp⟨⟩ d Q )S,B in state⟨{cmp }⟩ | P )put ,abt ,{lock }
Processes in a negotiation

p,a,Æ
S,B
 x⟨→u⟩)p,a,Æ
 x⟨→u⟩)p,a,Æ
 x⟨→u⟩)p,a,Æ
 x⟨→u⟩)p,a,Æ
 x⟨→u⟩)p,a,Æ
 x⟨→u⟩)p,a,Æ
 x⟨→u⟩)p,a,Æ
 x⟨→u⟩)p,a,Æ
 x⟨→u⟩)p,a,Æ
 abort)p,a,Æ
= p⟨l, ∅, ∅⟩
= p⟨l, ∅, {xs⟨→u⟩}⟩	if x ∈ S & →u ∈ S
= p⟨l, ∅, {xb⟨→u⟩}⟩	if x ∈ S & →u ∈ B
= 0	if x ∈ S & →u /∈ (S ∪ B)
= xs⟨→u, p, a, l⟩	if x /∈ S ∪ B & →u ∈ S
= xb⟨→u, p, a, l⟩	if x /∈ S ∪ B & →u ∈ B
= xz⟨→u, p, a, l⟩	if x /∈ S ∪ B & →u /∈ S ∪ B
= xs ⟨→u, p, a, l⟩	if x ∈ B & →u ∈ S
= xb⟨→u, p, a, l⟩	if x ∈ B & →u ∈ B
= xz ⟨→u, p, a, l⟩	if x ∈ B & →u /∈ S ∪ B
= a⟨⟩

 def D in P )p,a,Æ
= def D)1
in P )p,a,Æ
if count (P )=1 

 def D in P )(p1,p2),(a1,a2),Æ = def  D)1
in P )(p1,p2),(a1,a2),Æ
if count (P )=2 

S,B
S,B
S,B

 P | Q)(p1,p2),(a1,a2),Æ
= P )p1,a1,Æ | Q)p2,a2,Æ
if count (P )= count (Q)= 1

S,B
S,B
S,B

Figure 10. Encoding of canonical flat processes.

defined name. Consequently, it is useless and encoded as the inert process 0. Analogously for abort, which is meaningless outside contracts.
Note that S and B are updated when encoding a top-level process with local definitions, i.e. to S' and B' when defining def D in P )S,B. In this case, both D and P are encoded by taking into account dn(D). We use  to denote the union of disjoint sets. (Note that defined names can always be renamed with fresh ones.)
When a negotiation is translated into Join, it is associated with a new co- ordinator D (Figure 12), which will monitor the execution of the contract. As P will run as part of a negotiation, it is encoded as P )put,abt,{lock} where put, abt, lock ∈ dno(D). We can safely assume that P initiates with a unique thread because we are translating canonical processes with type 1, and therefore ne- gotiations [P : Q] appear in definitions with count (P ) = 1. The compensation Q is encoded as a top-level process, which is activated with a message on the local port cmp. As cmp is used only to initialize the state of the coordinator (state⟨{cmp}⟩), the message cmp⟨⟩ is emitted only when the coordinator (and

consequently the contract) aborts.

Processes in negotiations.
The auxiliary encoding )p,a,l describes the implementation of a thread being monitored by a manager D that defines channels p and a for receiving commit or abort confirmations. The set l collects the references to known parties in the same negotiation (called synchronization set). The inert process 0 in a negotiation means thread completion and it is translated as p⟨l, ∅, ∅⟩ to notify that it is ready to commit. The message contains l to inform D about known parties.
The encoding of a message x⟨→u⟩ requires a case analysis on the different kinds of names involved in it. When the message is sent to a free name or to an ordinary name defined at the top-level (x ∈ S) there are two different cases. If the arguments →u are not local names, e.g. →u ∈ S, then the thread is attempting to close the negotiation by releasing x⟨→u⟩. Hence it is encoding as a commit notification p⟨l, ∅, {xs⟨→u⟩}⟩. Note that xs⟨→u⟩ will be released if the negotiation finally commits.
Instead, when the arguments are names defined in a contract, the negoti- ation can enter in a stall situation unless other participants abort the whole contract. In fact such message cannot be consumed before commit, which is required to enable the commit of the contract (commit requires all local names not to appear in messages). The stall situation is encoded with 0, in this way the thread finishes without notifying its coordinator neither com- mit nor abort, and the coordinator will be blocked (unless one of its parties aborts).
On the other hand, a name x defined in a negotiation is encoded by using three different ports: xz, xb and xs to handle different types of parameters, i.e., local, merge and top-level. Similarly, merge names are encoded taking into account the type of their parameters, but they also should consider that a negotiation can finish when the received names are not local. Port xk (with k ∈ {z, b, s}) is used to encode the behavior of a merge name that receives names of type k and continues the execution of the negotiation. Instead, port xk allows also the possibility of committing a contract even when the message is not consumed. Note that the emission on x is translated as a message that carries the values p, a and l for interacting with the manager. (A thoughtful discussion about encoding merge definitions is below).
The constant process abort is translated into a message a⟨⟩ that informs the manager about the abort. The translation of a process def D in P involves the translation of D and P . When count (P )= 1, P is encoded by using the same coordinator assigned to the whole process.We remark that the sets of



Definitions
 D ∧ E)i

= D)i

∧ E)i

for i = 1, 2

 x⟨→u⟩ dP )0 = xs⟨→u⟩ d P )S {→u},B ∧ xb⟨→u⟩ d P )S,B {→u}	(remaining patterns omitted)

 x⟨→u⟩ dP )1
= xz⟨→u, p, a, l⟩ d P )p,a,Æ ∧ xb⟨→u, p, a, l⟩ d P )p,a,Æ
∧ xs⟨→u, p, a, l⟩ d P )p,a,Æ

S,B
S,B
S,B {→u}
S {→u},B
if count (P )=1 

 x⟨→u⟩ dP )1
= xz⟨→u, p, a, l⟩ d def D1 ∧ D2 in  P )(put1,put2),(abt1,abt2),{lock1 ,lock2 }∪Æ
| p⟨l ∪ {lock1 , lock2 }, {abt 1, abt2 }, ∅⟩
| state 1 ⟨{abt2 , a}⟩ | state 2⟨{abt1 , a}⟩
∧ xb⟨→u, p, a, l⟩ d ... ∧ xs⟨→u, p, a, l⟩ d. . .	if count (P )=2 

 x⟨→u⟩|y⟨→v⟩ dP )1
= xz⟨→u, p1, a1 , l1⟩|yz⟨→v, p2, a2, l2⟩d
def D in p1⟨l1 ∪ l2 ∪ {lock}, {abt , a2 }, ∅⟩ | P )put,abt,Æ1∪Æ2∪{lock}
| p2⟨l1 ∪ l2 ∪ {lock}, {abt , a1 }, ∅⟩ | state⟨{a1 , a2 }⟩
∧ xz⟨→u, p1, a1, l1 ⟩|yb⟨→v, p2, a2, l2 ⟩ d ... ∧ ...	if count (P )=1 

 x⟨→u⟩ ► P )0 = V
(xk⟨→u, p, a, l⟩ d p⟨l, ∅, ∅⟩ ∧ xk⟨→u, p, a, l⟩ d xk ⟨→u, p, a, l⟩)

S,B
k=s,b	s	s	z

∧ xs ⟨→u, p, a, l⟩ d P )p,a,Æ	∧ xb ⟨→u, p, a, l⟩ d P )p,a,Æ

z	S {→u},B	z
S,B {→u}

∧ xz ⟨→u, p, a, l⟩ d P )p,a,Æ
if count (P )=1 

z
 x⟨→u⟩ ► P )0 = V
S,B
(xk⟨→u, p, a, l⟩ d p⟨l, ∅, ∅⟩ ∧ xk⟨→u, p, a, l⟩ d xk ⟨→u, p, a, l⟩)

S,B
k=s,b	s	s	z

xz ⟨→u, p1, a1 , l⟩ d def D1 ∧ D2 in P )(put1,put2),(abt1,abt2),{lock1 ,lock2 }∪Æ
z	S,B
| p⟨l ∪ {lock1 , lock2 }, {abt1 , abt2}, ∅⟩
| state 1⟨{abt2 , a}⟩ | state 2 ⟨{abt1 , a}⟩
xs ⟨→u, p1, a1 , l⟩ d ... ∧ ...	if count (P )= 2
 x1⟨u→1 ⟩| ... | xn⟨u→n⟩ ► P )0 = V	V xk ⟨u→i, p, a, l⟩ d p⟨l, ∅, ∅⟩ ∧

S,B
k=s,b  i is

V	V xk ⟨u→i, p, a, l⟩ d xk ⟨u→i, p, a, l⟩
k=s,b  i is	iz
∧ xz ⟨u→1 , p1, a1 , l1⟩| ... |xz ⟨u→n, pn, an, ln⟩d
1z	nz	S
def D in state⟨S {a }⟩ | P )put ,abt , i Æi ∪{lock } |
i  i	S,B
Q pj ⟨S li ∪ {lock}, S {ai }∪ {abt}, ∅⟩
j	i	i


 J ► P )1 = T
∧ ...	if count (P )=1 

Figure 11. Encoding of canonical flat definitions.




variables S and B are not updated in this case, because D introduces just local

names. Also, D is encoded with  )1
and not with  )0
, which is used only

for top-level definitions.
The encoding of the parallel execution P |Q requires information about two different coordinators: two ports p1 and p2 for notifying the commit, and two ports a1 and a2 for aborting. Then, P is encoded by using p1, a1 and Q using p2, a2. Similarly for def D in P )S,B when count (P ) = 2. The generation of different coordinators is due to the encoding of fork definitions described below.



Definitions.
The encoding of definitions is in Figure 11. We recall that  )0

is for

top-level definitions, while  )1
is for definitions inside negotiations. In both

cases the encoding of a conjunction D ∧ E is the obvious one. The translation of a top-level definition of the port x creates two new ports xs and xb, which handle ordinary and merge parameters respectively. Such ports are associated to different translations of the guarded process P : xs considers →u as ordinary names and xb as merge names. We recall that, for simplicity, we assume all names in →u being of the same kind. We also commit in Figure 11 the encoding of a join, which generates four different rules: one for each combination of argument types.
The definition in a contract of x⟨→u⟩ dP where count (P ) = 1 is translated into three rules. Each rule introduces a new port xk (k ∈ {z, b, s}) to handle a particular kind of received names →u. Port xz receives local names, xb merge names, and xs top-level names. Additionally, the new ports xk have as para- meters p, a and l because the encoding in Figure 10 needs such information to contact the manager of the contract where the message x belongs to. In fact, the guarded process P must be encoded w.r.t. the values p, a, l of the manager of the fetched message on xk.
Similarly, a fork is encoded with three rules (Figure 11 shows only the rule for xz) but the guarded process P is translated by using two new coordinators D1 and D2. Ports put i, abti and locki are defined names of the new coordinators Di, while p and a are the channels associated to the thread that forks (they are retrieved from the message on x). Channels locki are added to the participant list l, which will be common to both new threads. For simplicity, we close the original thread (and create two new ones) instead of reusing it. The compensations for the new threads are the channels necessary to abort the other two participants.
The remaining shape for ordinary definitions is a join x⟨→u⟩|y⟨→v⟩ dP where two different threads are synchronized and only one of them remains active (count(P ) = 1). The translation states that the execution of a join ends both threads (messages to pi), and encodes the guarded process P with a new coordinator D. The participant list for the three threads is l1 ∪ l2 ∪ {lock}. In this case, the omitted rules correspond to the different combinations of ports associated to x and y.
The last rules encode merge definitions, whose basic shapes are similar to ordinary definitions, consequently they are translated analogously. The main difference is that merge names have a non-deterministic behavior, because a negotiation can commit also when it contains messages addressed to a merge name or it can wait until those messages are consumed. Therefore, a merge


D ≡	state⟨A⟩| put ⟨l, A', C ⟩ d commit⟨l \ {lock }, l, {lock }, C , A ∪ A'⟩
∧	state⟨A⟩| abt ⟨⟩ d failed ⟨⟩ | release⟨A⟩
∧	commit⟨{l }∪ l, l', l'', C , A⟩ d commit⟨l, l', l'', C , A⟩| l ⟨l', lock, abt ⟩
∧ commit⟨l, l', l'', C , A⟩| lock ⟨l''', l , a⟩ d commit⟨l ∪ (l''' \ l'), l' ∪ l''', l'' ∪ {l }, C , A ∪ {a}⟩
∧	commit⟨∅, l, l, C , A⟩ d release⟨C⟩
∧	commit⟨∅, l', l'', C , A⟩| abt ⟨⟩ d failed ⟨⟩ | release⟨A⟩
∧	failed ⟨⟩ | put ⟨l, A', C ⟩ d failed ⟨⟩ | release⟨A'⟩
∧	failed ⟨⟩ | lock ⟨l, l , a⟩ d failed ⟨⟩ | a⟨⟩
∧	failed ⟨⟩ | abt ⟨⟩ d failed ⟨⟩

Figure 12. The encoding of coordinators.

name x is encoded with five different ports: xk encode the waiting behavior (i.e., the negotiation will not commit until the message is consumed), and
xs and xb allow both behavior because they can choose non-deterministically
s	s
either to commit or to wait. Note that messages sent to merge names that are
not used inside a negotiation are discarded when the thread commits, because they are useless outside contracts. In the encoding of a generalized join (with n participants) we abbreviate D1 ∧ ... ∧ Dn with   Di and P1| ... |Pn with
i
i Pi. In this case all threads are finished and the guarded process P is
encoded using a new coordinator.
Finally, when a merge name x is defined more than once in a conjunction, redundant definitions for xk are introduced. However, redundant definitions do not change the behavior of a process. Additionally, merge definitions are useless when appearing inside negotiations, because no sub-negotiations exist that can be merged. Hence, we omit their translation (the special symbol T denotes this fact).

Coordinator.
Coordinators D in Figure 12, which are reused with minor variations from the encoding of zs nets in Join [4], implement the d2pc, a variant of the or- dinary two-phase commit protocol, where the role of the coordinator is played by all participants (it differs from the decentralized 2pc [1] because in d2pc the number of participants and their names are not statically fixed). We use the operation release which takes a set of messages and delivers them.
Roughly, the channel state records the messages that must be released in case of abort: (i) the channel that activates the compensation of the negoti- ation; and (ii) the list of ports abti of known participants. The commit protocol starts upon emission of the message put ⟨l, A', C ⟩ (via a join, or close, or drop), which triggers a commit message (first rule of D). Each participant can also abort when it receives the message abt, which changes the modality of the coordinator to failed ⟨⟩ and releases the abort notification to any other known

participant.
During the commit phase, messages on commit carry values ⟨l, l', l'', C, A⟩:
l records the set of known participants that must still be contacted;
l' stores the synchronization set of the thread (i.e. the list of known par- ticipants involved in the same transaction), which is typically augmented during the d2pc with the synchronization sets of other participants;
l'' records the parties who have already sent their consensus for commit;
Sets C and A store the messages to be released in case of successful and unsuccessful completion, respectively.
The d2pc is based on the following steps performed by every participant:
first phase. The participant sends a request to every thread in its own synchronization set (third rule of D). The message contains known par- ticipants.
second phase. The participant collects the messages sent by other parties and updates its own synchronization set (fourth rule of D). A request will be also sent to the new items in the synchronization set (by repeating (i) for them).
When the synchronization set is transitively closed, the commit protocol terminates locally and C is released (fifth rule of D).
If the participant transits in the state failed, it releases A, i.e. the com- pensation and the abort messages to known parties.
In the rest of this section we discuss the correctness and completeness of our encoding. Given a Join process P , norm(P ) denotes the process obtained by the repeated application of definitions in coordinators D until termination,
i.e., completing the executions of the d2pc protocol. norm(P ) is defined
for any P because the d2pc algorithm always terminates [4]. Moreover, we say norm(P ) stable, when it does not contain messages to ports state, i.e., all instances of the d2pc have finished either with the commit or abort of their participants. Hence, definitions in coordinators will never be used, and therefore they can be removed (for instance, as part of a garbage collection process). Moreover, when a negotiation aborts, norm(P ) can also contain messages sent by aborted negotiations (e.g. a negotiation sends x⟨→u, pi, ai, li⟩ and then aborts), which can also be removed. We use norm(P ) to denote the process obtained by removing garbage from a stable norm(P ). Note that norm(P ) is well-deﬁned only when all negotiations have finished.
The following results state that our encoding is correct and complete. We use the symbol ≈ to denote weak barbed bisimilarity [12].

Theorem 4.2 (Correctness) Let P be a canonical flat process and ▶ P :  1.
If P →∗  P ' with ▶ P ' :  1, then ∃Q s.t.  P )fn(P ),∅ →∗ Q, and norm(Q) ≈
cJ	J		
'
 P )fn (P '),∅.
Theorem 4.3 (Completeness) Let P be a canonical flat process and ▶ P :
  1. If P )fn(P ),∅ →∗ Q such that norm(Q) is well-deﬁned, then ∃P ' s.t. P →∗
J			cJ
'	'
P and  P )fn(P '),∅ ≈ norm(Q).

Concluding remarks
cJoin is a conservative extension of the Join calculus coming equipped with few primitives for programming dynamic multi-party negotiations and their compensations. In this paper we show that flat cJoin processes can be im- plemented in Join in a fully distributed way. The result is achieved by first defining a type system for flat processes and proving the subject reduction property for it, then providing a canonical representative of flat processes that employs a few elementary definition patterns. Finally, it is shown that canonical representatives can be encoded in Join.
By Proposition 3.12, the encoding of zs nets in cJoin produces processes in canonical form, which can therefore be encoded in Join by exploiting the implementation described in Section 4. We conjecture that the resulting en- coding def D)cJ in P )cJ) is just a slightly redundant version of the direct translation in [4], but we leave as future work to spell out the formal details and proofs.
Finally, the results presented here suggest that full cJoin, including nested negotiations and compensations, can be modeled back in ordinary Join by further elaborating on the d2pc, but we leave this as a challenging future work.

References
Bernstein, P., V. Hadzilacos and N. Goodman, “Concurrency, Control and Recovery in Database Systems,” Addison-Wesley Longman, 1987.
Bocchi, L., C. Laneve and G. Zavattaro, A calculus for long-running transactions, in:
Proceedings of FMOODS 2003, Lect. Notes in Comput. Sci. (2003), to appear.
Business Process Execution Language for Web Services ( bpel-ws) ver.1.1, (2003).
http://www-106.ibm.com/developerworks/webservices/library/ws-bpel .
Bruni, R., C. Laneve and U. Montanari, Orchestrating transactions in join calculus, in: L. Brim,
P. Jancar, M. Kretinsky and A. Kucera, editors, Proceedings of CONCUR 2002, Lect. Notes in Comput. Sci. 2421 (2002), pp. 321–336.
Bruni, R., H. Melgratti and U. Montanari, Nested commits for mobile calculi: extending Join
(2003), submitted manuscript. Available at the URL
http://www.di.unipi.it/~melgratt/publications/cjoin.ps



Bruni, R. and U. Montanari, Zero-safe nets: Comparing the collective and individual token approaches, Inform. and Comput. 156 (2000), pp. 46–89.
Bruni, R. and U. Montanari, Transactions and zero-safe nets, in: H. Ehrig, G. Juh´as, J. Padberg and G. Rozenberg, editors, Advances in Petri Nets: Unifying Petri Nets, Lect. Notes in Comput. Sci. 2128, Springer Verlag, 2001 pp. 380–426.
Butler, M., M. Chessell, C. Ferreira, C. Griffin, P. Henderson and D. Vines, Extending the concept of transaction compensation, IBM Systems Journal 41 (2002), pp. 743–758.
Fournet, C., “The Join-Calculus: a Calculus for Distributed Mobile Programming,” Ph.D. thesis, Ecole Polytechnique (1998).
Fournet, C. and G. Gonthier, The reflexive chemical abstract machine and the Join calculus, in: Proceedings of POPL’96 (1996), pp. 372–385.
Fournet, C., G. Gonthier, J.-J. L´evy, L. Maranget and D. R´emy, A calculus of mobile agents, in: U. Montanari and V. Sassone, editors, Proceedings of CONCUR’96, Lect. Notes in Comput. Sci. 1119 (1996), pp. 406–421.
Fournet, C. and C. Laneve, Bisimulations in the join-calculus, Theoret. Comput. Sci. 266
(2001), pp. 569–603.
Roxburgh,	U.,	Biztalk	orchestration:	Transactions, exceptions, and debugging, Microsoft BizTalk Server Technical Articles (2001). Available at the URL http://msdn.microsoft.com/library/en-us/dnbiz/html/btsorch.asp?_r=1 .
