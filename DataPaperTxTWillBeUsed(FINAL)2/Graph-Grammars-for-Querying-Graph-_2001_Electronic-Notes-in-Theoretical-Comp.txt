Electronic Notes in Theoretical Computer Science 50 No. 3 (2001) { Proc. GT-VMT 2001 URL:  http://www.elsevier.nl/locate/entcs/volume50.html  10 pages



Graph Grammars for Querying Graph-like Data


S. Flesca, F. Furfaro, S. Greco DEIS, Universit a della Calabria,
87036 Rende (CS), Italy
fflesca,furfaro,grecog@si.deis.unical.it


Abstract
Recently research has deeply investigated the problem of querying semi-structured data and data which can be represented by means of graphs (e.g. object-oriented data, XML data, etc.). Typically queries on graph-like data, called path queries, are expressed by means of regular expressions denoting paths in the graph. The result of a path query is the set of nodes reachable by means of a path expressed by a speci ed regular expression. In this paper we investigate the problem of extracting a subgraph satisfying a given property from a given graph representing some information. We propose a new form of queries, called graph queries, whose answers are (marked) graphs having a particular structure, extracted from the source graph. We show that a simple form of graph grammars can be pro tably used to de ne graph queries. The result of a graph query, using a grammar G over a database D, is a marked subgraph of D `matching' a graph derived from G. We consider di erent types of graph grammars which can be used to query graph-like data and consider their expressiveness and complexity.


1	Introduction

The widespread use of the web has renewed the interest in problems that had been already investigated with di erent aims in other contexts, and particu- larly in the problem of querying graph-like data. Indeed, graphs can be used as an abstract model to represent a wide variety of data, such as semistructured documents, object-oriented data, XML data, etc. [1,2,6,18]. Many queries that can be easily expressed on a relational database are not so \natural" on graph-like data. Accessing this type of data usually requires to navigate the graph searching for the desired information. Recently, several languages and prototypes have been proposed for searching graph-like data such as the Web [1,4,5,8,13,19,20,22]. All these languages permit us to express (declarative) navigational queries, called path queries, whose answer is the set of nodes of the graph which are reachable from a certain node by means of a path speci-
 c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


 ed by a regular expression [4,7,9,11,23,16]. However, this kind of navigational queries is not completely satisfactory since in many cases we would like to ex- press queries verifying whether the graph has a given structure (e.g. a tree or a chain) or to extract from the source graph a subgraph which satis es some property.
In this paper we investigate the problem of extracting a subgraph (a con- sistent subset of nodes and edges) satisfying some property from a given data graph. We propose a new form of queries, called graph queries, whose answers are (marked) subgraphs having a particular structure. A graph query is based on a graph grammar [12], that is used to de ne the structural properties of the subgraph that has to be extracted. A graph grammar is a graph rewriting sys- tem consisting of a set of rewriting rules (or productions). Like a production of a standard grammar de nes how to substitute a non terminal symbol (or a group of symbols) with a string, a production of a graph grammar de nes how to replace a node (or an edge) in a graph with a sub-graph. A graph grammar de nes a class of graphs which have common structural properties (e.g. the class of complete graphs, the class of trees, etc.): such classes are named graph languages. Discussing whether a graph belongs to a certain graph language is equivalent to discussing whether the structure of such a graph satis es the structural property of that language. For example, we can state that a cer- tain graph is a tree by simply de ning a graph grammar generating trees and then demonstrating that the graph belongs to the language generated by that grammar.
Our paradigm permits to de ne queries that search in a given graph for a subgraph belonging to the language de ned by a given graph grammar. In this way it is novel: while other query languages intend to nd some nodes in a graph such that each of these nodes has a certain property (e.g. the set of the nodes which are the answer of a path query), our model searches for entire sub-structures. Let's consider the following example. Assume that we want to extract all the available online \books" about swing classes from a web site containing documentation about java. In particular we are interested in extracting web pages having a hierarchical structure like the one shown in the following gure:


Path queries fail to identify an online book structured in this way, whereas it is easy to describe a structure like this using a graph grammar.


In the following sections we de ne our graph query language, by introduc- ing a restricted form of node replacement context-free graph grammars [12], called parsing graph grammars and specifying how these grammars identify subgraphs of the original data graph. We point out that our paradigm can also be used to create new graphs. However, in this paper we only consider the extraction of subgraphs.

2  NR graph grammars

Node Replacement (NR) graph grammars generate labeled directed graphs. A production of a NR graph grammar is of the form X ! (D; C) where
X is a nonterminal node label, D is a graph and C is the set of connection instructions. A rewriting step of a graph H according to such a production consists of removing a node u labeled X from H, adding D to H and adding edges between D and H as speci ed by the connection instructions in C. The pair (D; C) can be viewed as a new type of object, and the rewriting step can be viewed as the substitution of the node u with (D; C) in the graph H. Intuitively, these objects are quite natural: they are graphs ready to be embedded in an environment. Their formal de nition is as follows.
Let be an alphabet of node labels and an alphabet of edge labels. A graph with embedding is a pair K = (D; C) where D is a graph over and and C       N  fin; outg is the connection relation of K. Each element ( ; 1; 2; v; d) 2 C is a connection instruction of K and is generally written as ( ; 1= 2; v; d). The components of a graph with embedding K will be denoted as NK; EK; K and CK.
Intuitively, for a graph with embedding K, the meaning of a connection instruction ( ; 1= 2; v; out) is as follows: if there was a 1-labeled edge from a node u which has been substituted by K to a -labeled node w, then the embedding mechanism de nes a 2-labeled edge from v to w. Similarly, the meaning of a connection instruction ( ; 1= 2; v; in) is as follows: if there was a 1-labeled edge from a -labeled node w to a node u which has been substituted by K, then the embedding mechanism de nes a 2-labeled edge from w to v. The feature which replaces edge labels is called dynamic edge labeling. Let H be a graph over  and , K be a graph with embedding over the same alphabets, and let v 2 NH. The substitution of K for v in H is denoted by H[v=K]. In the following connection rules of the form ( ; = ; v; a) (i.e. rule which do not re-label edges) are simply written as ( ; ; v; a).


Example 2.1 The grammar G de ned by the following productions 1 and 2
(or, equivalently, by the productions 0 and 0 ) describes a language containing
chains.:


 0  and  0  have the same meaning, respectively, of   and  , but in  0  and  0
1	2	1	2	1	2
the connection rules are expressed graphically.
The following gure illustrates a chain derivation by means of G produc- tions:


De nition 2.2 A node replacement (NR) grammar is a tuple G = ( ; ; P; S) where  is the alphabet of labels,    is the alphabet of terminal labels, P is the nite set of productions, and S 2  is the initial nonterminal symbol. A production is of the form X ! (D; C) where X 2    and (D; C) is a graph with embedding.	2
The graph appearing in the right side of a production can be empty and a production of the form X ! (;; ;) will be simply denoted as X !	Let
G = (  ;  ; P; S) be an NR grammar. Let H and H0 be two graphs, let v 2 N and let p : X ! (D; C) be a production of G. Then, we say that H0 is directly derived from H (and write H )	H0 , or just H ) H0 ), if   (v) = X and H0 = H[v=D]. Moreover, we say that H0 is derived from H if there is a nite sequence H ) H )  ) H0 .
Thus, a graph grammar de nes a class of graphs which have common structural properties. The set of graphs generated by PG is called graph language and denoted L(P G).
3	Querying Data Graphs
We start by de ning a simple graph model on an alphabet with two di erent types of symbols: constant and variables. A variable can take any value and, therefore, it can be associated to any constant. In the following, constants are represented by strings starting with digits or lowercase letters (e.g. b1), variable names are denoted by strings preceded by a dollar (e.g. $b1) and non terminal symbols are denoted by strings starting with uppercase letters (e.g. X).


De nition 3.1 Given an alphabet , a graph over is a tuple G = (N; E; ) where N is a set of nodes, E  f(u; ; v)ju; v 2 N; 2 g is a set of labeled edges and : N ! is a node labeling function. We way that G is a data graph if  contains only constants otherwise it is called query graph.	2
The alphabet used by (general) graphs may also contain, other than ter- minal symbols (variables and constants), non terminal symbols. Thus, data graphs contain only constants and they are used to represent the input database, query graphs are used to denote graphs which can be `mapped' on data graphs and general graphs are used in the intermediate states of the derivation pro- cess. Graph grammars can be used to denote sub-structures from a given data graph.
Given a graph , we shall denote with T erminal( ) the sub-graph de- rived from by deleting nodes marked with non terminal symbols and arcs connected to deleted nodes. Observe that if the graph is connected and all terminal symbols does not have out-going arcs, T erminal( ) is also connected.
Example 3.2 The graph grammar G consisting of the productions of Fig. 1 de nes a language consisting of trees.


Fig. 1. Graph grammar de ning trees

Fig. 2 illustrates a tree derivation by means of G productions. Note that the


Fig. 2. Graph derivation

root nodes of the trees in the language de ned by this grammar have a speci c data label (n1), the internal nodes have label $i and the leaf nodes have label
$l.	2
Since in this context we are not interested in generating new graphs, but only in identifying sub-graphs of a given data graph, we shall not consider the whole language generated by a grammar, but only a subset containing graphs which identify some portion of the input data graph. To this purpose we de ne a mapping from query graphs to sub-graphs of a given data graph.


De nition 3.3 Let  = (N; E; ) be a query graph over  and D = (ND; ED; D) a data graph over . A mapping ' from  to D is a total function mapping, respectively, nodes in N to nodes in ND and edges in E to edges in ED such that i) for each node n 2 N either (n) = ('(n)) or (n) is a variable label,
ii) for each arc (u; ; v) 2 E there is an arc ('(u); ; '(v)) 2 ED such that
either = or  is a variable, and iii) there are no two nodes u and v such that (u) = (v) and '(u) = '(v) (i.e. two nodes with the same label cannot by associated to the same node).	2
A data graph D is recognized by a graph grammar PG if there exists a derivation from S to a query graph  (S )  ) and a mapping from  to D. The set of data graphs recognized by PG is denoted DL(P G). The set of subgraphs of a given data graph D recognized by PG is denoted DL(P G; D).
De nition 3.4 Let D be a data graph. A mapping pair on D is a pair ( ; ')
where is a general graph and ' is a data mapping from T erminal( ) to D. 2
Observe that T erminal( ) is a query graph, i.e. a graph whose node labels can be either constant or variables. Like embedded graphs, mapping pairs can be seen as a new type of object consisting of query graphs (derived from graph grammars) mapped over a given data graph. The derivation of query graphs from parsing grammars can be extended to mapping pairs. Let D be a data graph, PG a graph grammar and ( ; ') a mapping pair over D. We say that a mapping pair ( ; ) is directly derived from ( ; ') through a production of PG (and write ( ; ') ) ( ; )) if and only if ) and extends '. 1 Moreover, we say that a mapping pair ( n; 'n) is derived from a mapping pair ( 0; '0) over a data graph D if ( 0; '0) ) 1 ( 1; '1) ) 2  ) n ( n; 'n). Given a graph grammar PG and a data graph D, (P G; D) de nes the set of mapping pairs derived from (S; ;) where ; denotes an empty mapping.
A mapping pair applied to a data graph D allows us to identify a subgraph of D having the property de ned by the grammar. Each node of the extracted subgraph can be associated to more than one node of the query graph, if these nodes have di erent \role" labels. Di erent labels are used to distinguish di erent classes of nodes and arcs (e.g. in a tree internal nodes and leaf nodes may have di erent labels).

1 ('   ).


Example 3.5 Consider the parsing grammar of Example 2, the derivation shown in Example 2 and the data graph shown in the left side of the following
 gure:


The query graphs produced respectively at the third and at the last step of the derivation can be mapped on D as shown in the centre and in the right side of Fig	3.5.
Note that the production de ning the axiom (start symbol) of the graph gram- mar) contains an arc whose start node is marked with the constant label n1. This means that all derived query graphs are trees whose root node is marked with n1. Therefore, every tree generated by such grammar can be mapped only to a tree whose root node has label n1. In the above mapping
 (1) =  ('(1)) = n1 whereas all other nodes in the query graph have associ-
ated a variable. Although not represented in the gure, the arcs in the query graph are mapped to arcs in the data graph; for instance the arc e = (1; 2; a) and the arc '(e) have the same label a (i.e. '(e) = ('(1); '(2); a)).	2

Parsing grammars
We now introduce a new type of graph grammars, called parsing grammars, which are specialized to extract information from data graphs. Parsing gram- mars have the following characteristics: 1) the set of production rules is lin- early ordered (in order to drive the derivation process and reduce the nonde- terminism); 2) a rule can be applied only if a certain condition on the extracted data is satis ed.
De nition 3.6 A Parsing (Graph) Grammar is a tuple PG = ( ; ; P; S), where: is an alphabet of terminal symbols, is an alphabet of node non terminal symbols ( \ = ;), S 2  is the axiom. P is a linearly ordered set of productions of the form X ! ( ; C), where
(i) X 2  is a non-terminal symbol,
(ii)  is a (general) graph in G( [ ),
(iii) C is a set of connection rules, i.e. a set of tuples ( ; ; v; d) where d	2
fin; outg,  2  ,  2  and v is a node,
(iv) for each symbol X 2  there is a production X ! in P ,
(v) for each pair of productions  i : X ! ( ; C) with  not empty and
 j : X ! is  i < j	2
Parsing grammars generate query graphs without allowing edge re-labeling. The order on the productions de nes an order on derivations of mapping pairs.


Given a data graph D, a parsing grammar P G, and two productions and of PG such that < , we say that a derivation d1 of a pair ( 1; '1) from a pair ( ; ') precedes a derivation d2 of a pair ( 2; '2) from ( ; ') (written d1  d2),

if 1) d
= ( ; ') ) (  ;' ) )  (  ;' ), d
= ( ; ') ) (  ;' ) )  (  ;' ), or

1	i	i
1	1	2
j	j	2	2

there are three derivations d, d3 and d4 such that d1 = dd3 and d2 = dd4 and d3  d4.
We can now use the relation to de ne a partial order on the set of derived mapping pairs (P G; D). Given two mapping pairs M1; M2 2 (P G; D), we say that M <  M if for each derivation d = (S; ;) )  M , there exists a derivation d = (S; ;) )  M such that d  d . The order introduced on the productions of PG makes (P G; D) partially ordered. A mapping pair M	2
 (P G; D) is said to be minimal if there is no mapping pair M0 2 (P G; D) such that M0 <  M.
Theorem 3.7 Let PG be a parsing grammar and D a data graph. A minimal mapping pair in (P G; D) can be selected nondeterministically in polynomial time.	2
Clearly, any mapping pair in (P G; D) selected nondeterministically can be also computed in polynomial time.
Graph queries
Parsing grammars have a limited expressive power since they are not able to express NP-complete problems. Their expressiveness can be increased by specifying, separately from the grammar, a checking property (that will be expressed as an F O(COUNT ) [17] formula) that the extracted graph (i.e. the nodes of the data graph that have been associated to nodes in the generated query graph) must satisfy. F O(COUNT ) is an extension of FO containing counting quanti ers [17]. For instance, the meaning of the formula (9i x) '(x) is that there exist at least i distinct elements x such that '(x). In the previous formula the quanti er binds the variable x but leaves i free. For a given data graph D, we assume three relations ND, ED and  containing, respectively, the set of its nodes, the set of its arcs and the association of nodes and arcs to labels. For a given mapping pair ( ; ') on D we consider a unary relation V for each variable v appearing in  which is de ned as: V = fxjx 2 ND ^ 9n 2 N s.t.  (n) = v ^ '(n) = xg. The set of all these relations will be denoted as V(M).
When such a property is de ned, the generation process ends successfully only if a terminal graph which satis es the property has been produced. Oth- erwise, the generation process must be continued until an \acceptable" graph has been produced or no other graph can be generated.
De nition 3.8 Let D be a data graph D and M a Mapping pair on D. A checking property for D and M is a formula of F O(COU NT ) over the relations used for storing D and the variables appearing in M.	2


The application of a property  to a data graph D and a mapping pair M on D, denoted by (M; D), gives a boolean value (true if the formula is satis ed and f alse otherwise).
Example 3.9 Let D be a data graph D and M a mapping pair on D. The property that M identi es at least k distinct nodes can be expressed by the formula (9k w)[v1(w) _  _ vn(w)], where v1;  ; vn are all the variables that can appear in M. The property that M is a clique is expressed by the formula (8x)(8y) v(x) ^ v(y) ^ (x 6= y) ! (9z)[ED(x; y; z)], whereas the property that the clique has a size greater than or equal to k is expressed by the formula (9kw) v(w) ^ (8x)(8y) v(x) ^ v(y) ^ (x 6= y) ! (9z)[ED(x; y; z)]	2
De nition 3.10 An extended graph query Q is a pair (P G; ) where PG is a graph grammar and is a FO(COUNT) formula. The answer to an extended graph query Q over a data graph D is Q(D) = fMjM 2  (P G; D)^ (M; D)g.
2
Theorem 3.11 Let Q = (P G; ) be an extended graph query and D a data graph. The problem of checking if Q(D) is not empty is NP-complete.	2
Example 3.12 Consider the parsing grammar G de ned by the production on the left side of Fig. 3 (the " production is omitted), the property = (94w)(c(w)) and the data graph D reported on the center of Fig. 3.


Fig. 3. Extracting a clique
The answer to the query G(D; ) is the clique of size 4 `extracted' from D and reported in the right side of Fig. 3. If the property required only 3 nodes in the extracted sub-graph, the query would have identi ed a set of cliques of size  3.	2
References
[1] Abiteboul, S. Semistructured Data. Proc. Int. Conf. on Database Theory, 1997.
[2] Abiteboul, S., Buneman, P., and Suciu, D. Data on the Web: From Relations to Semistructured Data and XML. Morgan Kau man, 1999.
[3] Abiteboul S., Hull R., and Vianu V. Foundations of Databases. Addison- Wesley, 1994.
[4] Abiteboul S., Vianu V. Regular Path Queries with Constraints. In Proc. PODS, pages 122-133,	1997.
[5] Abiteboul S., D. Quass, J. McHugh, J. Widom, J. L. Wiener, The Lorel Query Language for Semistructured Data. in Journal of Digital Libraries 1(1), pages 68-88, 1997.


[6] Buneman P. Semistructured Data. Proc. PODS. 1997.
[7] Buneman P., Fan W., Weinstein S. Path Constraints in Semistructured and Structured Databases. In Proc. PODS, pages 129-138,	1998.
[8] Ceri S., Comai S., Damiani E., Fraternali P., Paraboschi S., Tanca L. XML- GL: A Graphical Language for Querying and Restructuring XML Documents. In Computer Networks 31(11-16), pp. 1171-1187,	1999.
[9] Christophides,V., S. Cluet, G. Moerkotte, Evaluating Queries with Generalized Path Expressions, in Proc. of the ACM SIGMOD Conf., pages 413-422, 1996.
[10] Consens M, Mendelzon A., GraphLog: a Visual Formalism for Real Life Recursion. Proc. Ninth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, pages 404-416, 1990.
[11] Cruz I., Mendelzon A., P. Wood. G+: Recursive Queries Without Recursion. Proc. 2nd Int. Conf. on Expert Database Systems, pages 355-368,	1988.
[12] Engelfriet J. Context-Free Graph Grammars. In Handbook of Formal Languages, Volume 3: Beyond Words (G. Rozenberg, A. Salomaa, eds.), Springer-Verlag, pp. 125-213,	1997.
[13] Fernandez M.F., D. Florescu, J. Kang, A. Y. Levy, D. Suciu, STRUDEL: A Web-site Management System. in Proc. ACM SIGMOD Conf., pages 549-552, 1997.
[14] Flesca, S, and Greco, S. Querying Graph Databases. Proc. Int. Conf. on
Extending Database Technology (EDBT) 2000, pp. 510-524.
[15] Flesca, S., and Greco, S. Partially Ordered Regular Languages for Graph Queries. Proc. Int. Colloquium on Automata, Languages and Programming (ICALP) 1999, pp. 321-330.
[16] Grahne G., Thomo A. An Optimization Technique for Answering Regular Path Queries. In Proc. of the Third International Workshop on the Web and Databases (WebDB), pp. 99-104, 2000.
[17] Immerman, N. Descriprive Complexity. Springer-Verlag, 1999.
[18] Kifer, M., W. Kim, Y. Sagiv, Querying Object-Oriented Databases, Proc. ACM-SIGMOD International Conference on Management of Data, pages 393- 402, 1992.
[19] Konopnicki, D., O. Shmueli, W3QS: A Query System for the World-Wide- Web, in Proc. Int. Conf. on Very Large Data Bases (VLDB), pages 54-65, 1995.
[20] Lakshmanan L., F. Sadri, I. Subramanian, A declarative language for querying and restructuring the web, Proc. 6th Int. Work. on Research Issues in Data Engineering, RIDE'96, 1996.
[21] Mecca G., Atzeni P., Masci A., Merialdo P. and Sindoni G. The Araneus Web- Base Management System. In Proc. of SIGMOD Conference, pp. 544-546, 1998.
[22] Mendelzon A., G. Mihaila, T. Milo, Querying the World Wide Web, Journal of Digital Libraries, 1997.
[23] Mendelzon A., Wood P. Finding Regular Simple Paths in Graph Databases. In SIAM Journal on Computing. 24(6), pp. 1235-1258,	1995.
[24] Yannakakis M., Graph-theoretic methods in database theory, In Proc. Ninth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, pages 230-242, 1990.
