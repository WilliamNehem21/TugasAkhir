	Electronic Notes in Theoretical Computer Science 141 (2005) 123–151	
www.elsevier.com/locate/entcs

Object-Oriented Connector-Component Architectures

H. Ehrig, B. Braatz, M. Klein1
Institut fu¨r Softwaretechnik und Theoretische Informatik, Technische Universit¨at Berlin, Germany

F. Orejas, S. P´erez, E. Pino2
Departament de Llenguatges i Sistemes Informa`tics, Universitat Polit`ecnica de Catalunya, Barcelona, Spain


Abstract
This paper presents an important extension of our contribution to FESCA ’04, which presented a generic framework for connector architectures. These architectures were defined by components, consisting of a body specification and a set of export interfaces, and connectors, consisting of a body specification and a set of import interfaces plus connecting transformations in both cases. A major restriction of this framework was given by the assumption of non-overlapping connector interfaces.
In order to make the generic framework for connector architectures more applicable, it is enriched by the possibility of handling overlapping connector interfaces. Fortunately, it is possible to extend the main results presented at FESCA ’04 also to the new framework. Moreover, it is shown that the new framework can be applied to UML class diagrams, state machines and sequence diagrams as heterogeneous specification techniques. The resulting connector framework, including a concept for the composition of components and architectural reduction for UML specifications, is illustrated by a case study concerning the meta data management in Topic Maps.
Keywords: Modules and Interfaces, Components and Connectors, Object-Orientation



1 Email: [ehrig,bbraatz,klein]@cs.tu-berlin.de
2 Email: [orejas,sperezl,pino]@lsi.upc.es



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.02.048

Introduction

The importance of architecture descriptions has become most obvious over the last decade (see e. g. [15,16,7,8,6]). Various formalisms have been proposed to deal with the complexity of large software systems. The idea of dividing computation and coordination in software programs and in the corresponding specifications, mainly motivated by Allen and Garlan in [1], found a wide acceptance in today’s software engineering and research (see e. g. [17]). In most of these approaches, the division is realized by the use of components as computation units and connectors as coordination units. In our recent paper [4] we presented a generic approach based on [3] to handle this kind of architectures, including a notion of component composition and a semantics that calculated a single component for each architecture. Moreover, we have studied instantiations to formal specification techniques like Petri Nets and CSP. In our approach a component consists of a body and a set of export interfaces, and connections between export and body. A connector consists of a body and a set of disjoint import interfaces. These connections are generic to allow a great variety of instantiations.
This paper has two main aims. The first one is to extend the generic framework by allowing overlapping connector interfaces. The second aim is to apply the new generic framework to object-oriented specification techniques in the sense of UML(see [14]).
In order to reach the first aim, we have to relax the requirements for the parallel extension property, which is used to calculate the composition of components along connectors. The difference with respect to the framework in [4] is that we require a parallel extension of transformations, if all given transformations are compatible with all given embeddings instead of requiring complete independence of the embeddings.
The second aim includes an instantiation of the generic concepts to UML diagrams, where we consider class diagrams, state machines and sequence di- agrams in this paper. This requires to define transformations, embeddings, extension and parallel extension for these types of UML diagrams. Compati- bility of transformations and embeddings means that all overlapping parts are commonly refined by the given transformations.
The paper is organized as follows. In Section 2 we start with a small case study for an object-oriented component architecture. This is an explicit example of the advanced generic architecture framework presented in Sec- tion 3. Based on that, we define the semantics of connector architectures in Section 4. The main result in Section 4 shows existence and uniqueness of architecture semantics, which is based on compatibility of component com-

position in Section 3, within the extended framework allowing overlapping connector interfaces. Section 5 then presents the instantiation of the generic framework to UML diagrams, which is the concrete framework for our case study in Section 2. In Section 6 we conclude with a brief discussion of related work and an outlook to future research.

Case Study: Meta data Management in Topic Maps
In this section we will model a small case study concerning the management of meta data using an object-oriented connector-component architecture based on UML. The corresponding architecture framework for UML is an instantia- tion of the generic framework for architectures presented in Sections 3 and 4. This instantiation will be described in more detail in Section 5.
In our case study we consider an example system for the management of meta data in Topic Maps [9], which is an ISO standard for the ‘Semantic Web’. The main notions of Topic Maps are topics and associations between them. For example we want to describe the meta data of music media files. Topics in this area include medium, track, and artist, which are related by associations like the release of a medium by an artist, the containment of a track on a medium, or the production of a track by some performer and composer.
The system shall be able to exchange the data of arbitrary Topic Maps via the HTTP protocol (see [12]). This way it shall be possible to share the data on one hand in a server based fashion, where a powerful web server processes the queries of lots of clients, and on the other hand in a peer-to-peer fashion, where clients exchange data directly. As exchange format the standardized XML transfer syntax [10] for Topic Maps shall be applied.
The music meta data shall also be used to manage media like MP3 files. The system shall be able to change the ID3 meta data (see [13]) of existing MP3 files according to the meta data in the Topic Map and move the file into a media file hierarchy with canonicalized names.
The domain of this example can easily be enhanced to capture other media and their meta data. For example the bibliographic data concerning scientific publications could be modeled this way and used to organize a collection of bookmarks and electronic versions of these publications.

Architecture of the Example
The requirements are specified in an architecture consisting of compo- nents and connectors as shown in Figure 1, where we use the package stereo- types <<component>> and <<connector>> and the dependency stereotype
<<transform>> to identify the notions of the generic architecture framework.

The <<architecture>> packages in this abstract view correspond to the ar- chitecture graphs of our generic framework in Section 3. The components are Ontology, Server, and Manager representing the three main areas of re- quirements. They are connected via the connectors SrvSrc between Server and the data model in Ontology and ManOnt between Manager and the domain ontology in Ontology.





<<transform>>
<<connector>>
SrvSrc
<<transform>>
<<connector>>
ManOnt
<<transform>>



<<transform>>


<<component>>
Server

<<component>>
Ontology

<<component>>
Manager


Fig. 1. Architecture of the example
We will use the additional package stereotypes <<componentBody>>,
<<componentExport>>, <<connectorBody>> and <<connectorImport>> and the dependency stereotype <<embed>> to describe the substructure of components and connectors according to the generic framework. A component consists of several export packages with transform dependencies to a body package and a connector consists of several import packages with inclusion dependencies to a body package.

Ontology Component
The Ontology component consists of the packages DataModel and MusicOn- tology and corresponding export packages for both of them. The structure of the component is depicted in Figure 2. The DataModel package shown in Fig- ure 3 specifies a simplified version of the Topic Maps data model described in
[11] by a UML class diagram. Additionally two methods are declared which will be used by the Server component below. The first method getByIdentifier of TopicMap takes a URI as parameter and returns a topic containing the given URI as identifier if it exists. This is specified by the OCL constraint for the method. The second method serialize of Topic shall return an XTM

Fig. 2. Component Ontology



Fig. 3. Data model of the system
serialization [10] of the topic. A requirement not specified in the UML model is the intention that the serialization includes the topic with all non-local occurrences, all topic names, and all associations, where the topic plays an association role. The data model is completely exported in the ExpDataModel export package in Figure 2 in order to be accessible for applications. The domain ontology itself is specified by the class diagram of the MusicOntology package in Figure 4. Topics are specialized by the classes Track, Medium, and Artist, which are related by the associations Containment, Release, and Produc- tion. There are attributes for selected names in UTF8 and ASCII encoding in the topic classes, which are required to be included in the topic names of the data model by OCL constraints in the notes attached to the classes in Figure 4. The Track class additionally declares some methods to access the names of it’s associates directly and add MP3 files as occurrences to the track. The effects of these methods are again specified by OCL constraints in the notes of the class diagram. Only the class Track and the used File class are exported in ExpMusicOntology in Figure 2, so that applications can access the data through the methods of Track.

Server-Source Connector
To connect the Ontology component with an HTTP server to provide the topic map data to clients we use a generic connector SrvSrc modeling the con- nection from some data server to it’s underlying data source. This connector is given in Figure 5. The data server retrieves the resource for a given URI




topicNames 0..*


context Track
inv: self.topicNames−>exists(value = nameUTF8) self.topicNames−>exists(value = nameASCII)




medium


context Track::getName(): String
post: result=self.nameUTF8

context Track::getPerformer(): String
post: result=self.performer.nameUTF8
Containment	0..1





Release


context Track::getComposer(): String
post: result=self.composer.nameUTF8

context Track::getAlbum(): String
Production


performer
1
releaser
1

post: result=self.medium.nameUTF8

context Track::getFilename(): String
post: result=self.nameASCII

context Track::getPath(): String
post: result= if self.medium−>notEmpty() then
self.medium.releaser.nameASCII + "/" + self.medium.nameASCII
else
self.performer.nameASCII

context Track:.addMP3File(file: File)
post: self.occurrences−>exists(resource.reference = file.getURI())
composer
0..1
context Medium
inv: self.topicNames−>exists(value = nameUTF8) self.topicNames−>exists(value = nameASCII)
context Artist
inv: self.topicNames−>exists(value = nameUTF8) self.topicNames−>exists(value = nameASCII)


Fig. 4. Ontology of the system















Fig. 5. Connector SrvSrc
from the data source and afterwards serializes it. This sequence is specified by the sequence diagram of the package. The import ImpServer is identical to the connector body, because a data server component will need all entities de- scribed in the connector. On the other hand the interface ImpSource contains



Fig. 6. Component Server








Fig. 7. Export package ExpServer
only the classes DataSource and Resource, since a data source component does not need to know about the server. There is a connection conSrc, which is a
<<transform>> dependency, between ImpSource and ExpDataModel renaming the class DataSource with the method getByURI to the class TopicMap with method getByIdentifier and the class Resource to Topic (the method serialize is not renamed). The renamed model is included in ExpDataModel. The con- nection conSrv to the export of the Server component will be described in the next paragraph.

Server Component
The server component in Figure 6 shall be used to satisfy the ImpServer import of the connector in the previous paragraph. One of the requirements of the generic architecture framework in Section 3 is that overlapping parts of imports are identically transformed. So we have to perform the renamings of conSrc also in conSrv. Moreover we restrict the sequence to only use the serialize method if a topic was found by getByIdentifier. These transformations yield the export of the Server component in Figure 7. This export is further transformed to the model of the internal HTTP server and it’s protocol in the HTTPServer package in Figure 8. This server receives HTTP requests and tries to find a topic which has the requested URI as one of it’s subject identifiers. It responds with an HTTP response with the serialization of the found topic


 












Fig. 8. HTTP server requirements
or a response with status “404 – Not Found” if no topic was found. With this protocol it is possible to ask a server for possible information about a subject identified by some URI. In a peer-to-peer network this could be used to share information about topics among clients knowing topics for the same subject identifier.

Manager-Ontology Connector
In order to connect the ontology to some resource manager, e. g. the MP3 file manager in the next paragraph, we define the connector ManOnt shown in Figure 9. The connector abstractly describes the relation between some manager and a topic being able to describe files, i. e. files can be added as occurrences to the topic and their meta data can be exported as strings. The manager is now required to have a method insertFile which alters some meta data tag inside the file to reflect the data in the topic and then adds the file as occurrence to the topic. This is specified by the state machine in Figure 9. The import ImpOntology just contains FileTopic and File, because these have to be provided by the ontology. This import can be connected via the connection conOnt to the export ExpMusicOntology by choosing Track as FileTopic and refining the getMetadata method to special methods for different kinds of meta data. The import ImpManager contains the whole body of the connector, because managers will access and transform all of it’s contents. This import is connected via conMan to the export of the Manager component described in the next paragraph.




















Fig. 9. Connector ManOnt

Fig. 10. Component Manager

Manager Component
Figure 10 shows the structure of the component Manager. To instantiate the ImpManager package of the ManOnt connector it is transformed via the connection conMan resulting in the package in Figure 11. Because FileTopic is transformed to Track in ExpMusicOntology this is also done in ExpManager. To reflect this change also for the Tag class it is transformed to ID3Tag which represents the meta data in ID3 tags of MP3 files. The export is then further transformed to the FileManager package in BodManager shown in Figure 12. In this body the requirement of a canonicalized hierarchy of media files is














Fig. 11. Export package ExpManager















Fig. 12. File management requirements



Fig. 13. Detailed architecture of the example

Fig. 14. Architecture semantics of the example
additionally considered by adding a Directory class and a move method for files and enriching the state machine for insertFile.

Detailed Architecture of the Example
With these components we obtain the detailed architecture of the system shown in Figure 13. This detailed architecture corresponds to the architecture diagram as defined in the generic architecture framework in Section 3.
In order to define the semantics of the architecture in Figure 13 the archi- tecture framework demands in Section 4 the ability to flatten such architec- tures. This is done by applying all transformations simultaneously to get one global body and then forget the connectors and connected exports which is justified by Theorem 3.11. The instantiation of this requirement to UML will be discussed in Section 5. Applying this complete reduction to the example architecture yields the component in Figure 14, where the body is given by the packages DataModel in Figure 3, MusicOntology in Figure 4, HTTPServer in Figure 8, and FileManager in Figure 12 and the dependencies between them induced by the usage of classes in the connector bodies. Note that in this

case we have no export packages left in the resulting component, because all exports have been used by the connectors already.
Such complete reductions of architectures to single components will be defined as the semantics of architectures in Section 4. But first the generic architecture framework itself is formally introduced in the next section.

The Generic Architecture Framework
In this section we present a generic framework for connector architectures, which is based on the ideas of our framework presented at FESCA ’04 in [4]. The new version in this paper, however, is more flexible, because it allows overlapping connector interfaces in contrast to non-overlapping ones in [4]. The present framework is generic with respect to several parameters. We use a class of specifications (or models, respectively) and classes of corresponding transformations and embeddings between specifications (or models) that can be instantiated to concrete specification (modeling) techniques. We only re- quire the following properties, which have to be ensured by the used concrete specification (modeling) technique, when the framework is instantiated.
tions t : SP ⇒ SP ' and t ': SP ' ⇒ SP '', then there exists a composed trans- formation     t  '     ◦   t  :   SP      ⇒    SP  ''. • Transformations are closed under composition, i. e. given two transforma-
There is a special identity transformation which is neutral with respect to
we have a transformation idSP with t ◦ idSP = t = idSP' ◦ t for each trans- formation       t  :    SP        ⇒      SP  '. the composition of transformations. This means for each specification SP
two embeddings e1 : SP1 → SP2 and e2 : SP2 → SP3 , then we require a com- posed   embedding    e2   ◦  e1 :  SP1    →   SP3  . • Embeddings of specifications have to be closed under composition. Given
Analog to the transformations we require identical embeddings idSP with
e ◦ idSP = e = idSP' ◦ e.
Finally, we have to require that embeddings are a special case of transfor-
mations, such that the identities are compatible.
For these generic notions of transformations and embeddings we require the following extension and parallel extension property.
Definition 3.1 (Extension Property) Given an embedding e: SP → SP1 and a transformation t : SP ⇒ SP ' as depicted in Figure 15, such that e is consistent with respect to t. Then there is a canonical extension diagram (1)
with embedding e' and transformation t1. In the special case of t being also

SP   e  SP 1	SP   e  SP 1

t	(1)	t1
cz	cz
f	(2)	f1
J	J 

SP '
'  SP '
SP '
'  SP '

Fig. 15. Extension diagrams


SPj
ej	 SP 
SPj
ej	 SP 

tj	(3)	t
cz	cz
fj	(4j )	f
J	J 

SP ' 	 SP '
j
SP ' 	 SP '
j

Fig. 16. Parallel Extension Diagrams
an embedding f , we have consistency and a unique mutual extension diagram (2), where f1 extends f via e and e' extends e via f and (2) commutes.
tions e' ◦ t and t1 ◦ e, but only equality of the corresponding domain SP and Note that in diagram (1) we do not require equality of the transforma- co-domain SP ' . The above mentioned consistency between embeddings and
transformations is generic in the general framework and can be instantiated differently for each instantiation. In order to handle multiple interfaces we will also need the following parallel extension property.
Definition 3.2 (Parallel Extension Property) Given families of transfor-
mations tj : SPj ⇒ SP ' and embeddings ej : SPj → SP for indices j in some
finite index set J as shown in Figure 16, such that the family of embeddings
(ej)j∈J is consistent with respect to the family of transformations (tj)j∈J, then there is a canonical parallel extension diagram (3) with embeddings e'
and transformation t, such that:
Parallel extension diagrams are closed under vertical composition.
embedding f and (4j) commutes for all j ∈ J . If additionally for some k ∈ J all other tj with j ∈ J \ {k} are identities, then (4k) is a mutual (ii) If all tj are embeddings fj, then we have consistency, the result t is an
extension diagram.
Again, the notion of consistency for a family of embeddings w.r.t. a family of transformations is generic and can be instantiated differently for different specification or modeling techniques. Now we are able to define generic com- ponents and connectors.
Definition 3.3 (Component) A component COMP = (B, (ek)k∈K) is given by the body B and a family of export interfaces Ek with export transforma-



I  bj  B 
CON

j
con j
cz
con j1 
       
¸¸¸¸¸¸¸¸con
¸¸¸¸z˛

Ejk(j)
ejk(j)
j∈J
COMPj1	···	COMPjn

Ejk
 ejk 
cz
zB i	k∈Kj\{k(j)}

Fig. 17. Connector Diagram and Connector Graph
tions ek: Ek ⇒ B for k ∈ K.
the body B and a family of import interfaces Ij with body embeddings bj: Ij → B         for       j         ∈      J   . Definition 3.4 (Connector) A connector CON = (B, (bj)j∈J) is given by
Next, we define formally how a connector connects different components.
CON = (B, (bj)j∈J ) of arity n = |J | and for each j ∈ J a component COMPj = (Bj, (ejk)k∈Kj ) with a connector transformation conj: Ij ⇒ Ejk(j) Definition 3.5 (Connector Diagram and Graph) Given a connector with k(j) ∈ K(j), such that (bj)j∈J is consistent with respect to (ejk(j) ◦ conj)j∈J, then we obtain the connector diagram in Figure 17 and the connec-
tor graph in Figure 17, where the following conditions have to hold:
A connector diagram conΣsists of n import interface nodes Ij of n +1 body
nodes Bj and B, and of	j∈J |Kj| export interface nodes Ejk, even if some
of the specifications may be equal, e.g. B1 = B2.
Circular connections as in (2) of Figure 18 are forbidden, unless we dupli- cate the body as in (1) of Figure 18. Otherwise the semantics of such a circular architecture is not defined, as it would cause the identification of the export interfaces E1k(1) and E1k(2) of component COMP1 or other kinds of unwanted side effects.
Note that the interfaces bj: Ij → B for the connector are not required to be disjoint, but they are allowed to overlap.
Next, we carry the concept of overlapping connector interfaces forward to whole architectures of components and connectors. Similarly to connectors we obtain an architecture diagram and an architecture graph. The first describes the architecture at the level of specifications and the second as a graph, where nodes are connectors or components.
Definition 3.6 (Architecture diagram) An architecture diagram DA of arity (k, l) is a diagram built up from the l connector diagrams, the k com-

I 	b1	 B ¸,b2	I	I   b1	 B ¸,	 I

1
con 1
cz
2
con 2
cz
1
con 1
cz
b2	2
con 2
cz

E1k(1)
¸¸¸¸
¸¸¸¸¸¸
E2k(2)
     
   
E1k(1)
E2k(2)

¸ v˛ j
cz	cz

E1k  zB 1 = B2

k∈K1\{k(1),k(2)}
E1k  zB 1 = B2	B1 = B2 ¸cE2k


k∈K1\{k(1)}	k∈K2\{k(2)}

Fig. 18. Non-circular and circular connector diagrams
ponent diagrams, and the connection transformations satisfying the following conditions
by an arrow, labeled with a connection transformation con : I ⇒ E, to (i) Connector Condition: Each import interface I of a connector is connected exactly one export interface E of one component.
Component Condition: Each export interface E of a component is con- nected at most to one import interface I of a connector by an arrow from
I to E, labeled with a connection transformation con : I ⇒ E.
Non-circularity: The architecture diagram DA is connected and non-
circular aside from the arrows’ direction.
In order to depict whole architectures clearer we introduce the notion of architecture graphs abstracting from the direct interface connections and only revealing, which components are connected by which connectors.
Definition 3.7 (Architecture graph) An architecture graph GA for an ar- chitecture diagram DA is obtained by shrinking each connector diagram in DA to the corresponding connector graph. Hence, it consists of nodes labeled by the connectors and components and arrows in between labeled with the corresponding connection transformations.
Definition 3.8 (Architecture) An architecture A of arity (k, l) consists of k components and l connectors, an architecture diagram DA and an architecture graph GA.
Definition 3.9 (Component Composition) The composition by a connec- tor with index set J is defined as follows: Given the corresponding connector diagram (see Figure 17) we construct the parallel extension diagram (1) in Figure 19. The result of the composition of the components (COMPj)j∈J by
the connector CON with the connection transformations (conj)j∈J is again a
component COMP = (B', (e' : Ejk ⇒ B')(j,k)∈J⊗K) with J ⊗ K = { (j, k) | j ∈


j∈J	I   bj	 B 
con j

I 	bj	 B 

cz
k∈Kj\{k(j)} Ejk(j)
ejk(j)
tj =ejk(j)◦con j (1)	t

cz	cz	b'
cz	(j,k)∈J ⊗K

Ejk
ejk
zB j
Bj	j	 B '
Ejk	'
ejk
zB '


CON ¸
Fig. 19. Composition

CON '

con
....
¸¸¸¸¸¸con
con'
,,,,,
¸¸¸¸¸¸¸con'

.j...
..	j∈J \{jc}
¸¸¸¸jc
¸¸ z 
,,k,c,,,
,,
k∈K\{kc}
¸¸¸ k
¸¸¸

 . s
COMPj
...	COMPjc  =
¸, c '
COMPkc
z_
COMPk

Fig. 20. General connectors and components

J, k ∈ Kj \ {k(j)}} and e'
:= b'
ejk for all (j, k) ∈ J ⊗ K. In this case

we say that e'	are extensions of ejk (See Figure 19).	In case of binary
components and binary connectors we use the following nice infix notation
COMP = COMP1 +CON COMP2 . Otherwise we use the notation
COMP = CON ((COMPj )j ∈J , (conj )j ∈J ) .
The next theorem states that the result of two overlapping compositions via two connectors is independent of the order the single compositions are calculated.
Theorem 3.10 (Compatibility of Component Composition)    Given an architecture A with arbitrary components and two connectors with the ar- chitecture graph GA in Figure 20, then we have the equality of the following three expressions:
(E1) CON ((COMPj )j ∈J\{j }, CON '((COMP ' )k∈K ))
c	k
(E2) CON '(CON (COMPj ∈J ), (COMP ' )k∈K \{k })
k	c
(E3) CON + CON '((COMPj )j ∈J , (COMPk )k∈K )
where (E1) and (E2) are different sequential compositions and (E3) is a par- allel composition of the components via the two connectors.
In the following we consider the special case of binary connectors and components with two export interfaces each. The proof of this special case shows how to use the extension and the parallel extension property and can be extended without problems to the general case of Theorem 3.10 which is needed in the proof of Theorem 4.5.

CON1¸	CON3¸

...
_. s
¸¸¸¸¸
.....
z_ _. s
¸¸¸¸¸¸¸¸¸

COMP1	COMP2	COMP3
Fig. 21. Binary connectors and components (GA)


I11
con11
 b11  B ¸b1,2
I12
con12
I21
con21
 b21  B ¸b2,2
I22
con22

cz
E2
e23
cz
E3
,,,,
e ,,,,
cz
E4
c
cccec
cz
E5
e55

cz	,	cc	cz
z ,r
E1 e13 zB 3	B4	B5 ¸e cE6
Fig. 22. Architecture diagram DA

Theorem 3.11 (Associativity of Binary Component Composition) Given an architecture A with binary components and binary connectors with the architecture graph GA in Figure 21, then we have the following associativity law:
(E1) (COMP1 +CON1 COMP2 ) +CON2 COMP3 = (E2) COMP1 +CON1 (COMP2 +CON2 COMP3 ) = (E3) COMP1 +CON1 COMP2 +CON2 COMP3 ,
where the last expression corresponds to a parallel composition explained below.

Proof. Let us consider the architecture diagram DA in Figure 22 correspond- ing to the architecture graph GA given above. We first present the paral- lel composition corresponding to the result of expression (E3). Note, that the embeddings (b11, b12) are consistent with respect to the transformations
(e23 ◦ con11 , e34 ◦ con12 ) according to the definition of connector diagrams
(see Definition 3.5), which allows to construct the parallel extension diagram

in the left part of Figure 23 with transformation t1: B1 ⇒ B'
and embeddings

b0: B3 → B' and b' : B4 → B' . For similar reasons we obtain the parallel ex-
1	1	1
tension diagram in the right part of Figure 23 with transformation t2: B2 ⇒ B'

and embeddings b' : B4 → B5 and b5: B5 → B' . From the embeddings b'
and

2	2	1
' we construct the mutual extension diagram (1) in Figure 23, where we do
not need an additional consistency condition by the extension property (see
Definition 3.1). The composition (COMP1 +CON1 COMP2 ) +CON2 COMP3 in expression (E1) corresponds to the diagram in Figure 24, where the result of

COMP1 +CON
COMP2 is given by (B' ,E  ⇒ B  →
B' ,E ⇒ B
b'
→1 B' ) by

1	1	1	3	1	4	4	1

I11 	 B 1 ¸,I12	I21 	 B 2 ¸,I22

con11	t1
cz
con12
cz
con21	t2
cz
con22
cz

E2	E3	E4
,
(2)
E5

,,,,
,,
c
cccc

 e 	czb
cz	b'
, z ,ccr b'
czb
cz e	

E	13 zB 
0 B ' ¸, 1	B
2	 B ' ¸5,B
¸6c5  E

1	3	1 ¸¸¸¸
¸¸¸¸¸
4
(1)
...  2	5	6
...

b	¸¸¸
.. b'

¸z '	s
4
Fig. 23. Parallel composition


I21 	 B 2 ¸,  I22

con21	t2
cz
con22
cz

E4  (2)	(3)  E5

czb'	czb	cze
B4 	2  B ' ¸,5  B5 ¸6c5  E6

'	(4)
b4 (5)
id5

 e13 
  b0  J	J	J e65

E1	zB 3
 B ' 	 B + ¸,'
B5 ¸c  E6

1	b3	2	b5
Fig. 24. Stepwise composition


Definition 3.9. Now we consider in Figure 24 the same parallel extension dia- gram (2,3) as above in Figure 23 and a new one by (4,5) according to part (ii) of the parallel extension property (see Definition 3.2). Using part (i) the vertical composition property implies that (2+4, 3+5) is a parallel extension diagram leading to the bottom line in Figure 24 as result of expression (E1). But (4,5) is a special case of a parallel extension diagram with identity, such that, ac- cording to (ii) of Definition 3.2, (4) becomes a mutual extension diagram of

b' by b' and hence equal to (1) above. This implies B' = B+, b' = b3, b'
= b4

1	2	4	2	3	4

and b4 ◦ b5 = b'
by (5). This implies that the result of expression (E1), given

by (B' ,E	e
b'
B  → B' →3
B' ,E	e
b'
B  → B' →4
B' ), and of expression

4	1	3
1	4	6
5	2	4

(E3), given by the bottom line of the diagram in Figure 24, are equal. The
dual argument shows that the result of expressions (E2) and (E3) are equal,
where diagram (1) has to be considered as extension of b' by b' . But this is
appropriate, because we have assumed in the general framework that (1) is a
mutual extension diagram.	 

L ¸,  K 	 R 
m	(1)	(2)
J	J	J 
G ¸,  D 	 H 
Fig. 25. G ⇒ H


CON D :

I	bj	 B 
con j
cz

Ejk(j)
ejk(j)
e	cz
j∈J
¸ ,lD 

Ejk 	jk   zB 

k∈Kj\{k(j)}

Fig. 26. Diagram reduction rule
Semantics of Architectures
In this section we define the semantics of architectures. In fact, we show that we can construct a well-defined single component as semantics, which corresponds to the composition of all components using all connectors of the given architecture. More precisely, for an architecture there are reduction rules
Both reduction rules are productions p = (L ← K → R) in the sense of that visualize step by step the composition of components via connectors. the algebraic approach to graph transformation, more precisely the Double
by two pushout diagrams (1) and (2) in Figure 25, written G ⇒ H via (p, m), where m : L → G is a graph morphism that represents the match of L in Pushout approach (see [2]). In fact, a derivation step in this approach is given
G. Intuitively, we remove (L − K) from G in step 1 leading to the context
graph D in (1). And then we add (R − K) leading to the result H in (2). The pushout property of (1) and (2) means intuitively that G is the gluing
of D and L along K in (1), and H is the gluing of D and R along K in (2), respectively.
Definition 4.1 (Diagram Reduction Rule) Given an architecture A with the architecture diagram DA there is for each connector CON the diagram
reduction rule COND , as depicted in Figure 26, where B' and e'  = b' ◦ ejk is
defined by the composition:
COMP = CON ((COMPj )j ∈J , (conj )j ∈J )

= (B', (e'
: Ejk ⇒ B')(j,k)∈J ⊗K )

jk

CON G :

Fig. 27. Graph reduction rule

Definition 4.2 (Graph Reduction Rule) Given an architecture A with the architecture graph GA. The corresponding graph reduction rule CONG is shown in Figure 27, where COMP 1,... , COMPn are mapped to COMP .
A reduction step CON D: DA ⇒ DA' and CON G: GA ⇒ GA' , respectively, is given by a derivation step in the Double Pushout approach to graph trans-
formations at the level of architecture diagrams or architecture graphs, re- spectively. For both derivation steps we have inclusions for the matches. Note that although rG is neither injective nor label-preserving, the labels of GA'
for the reduction rule CON G: GA ⇒ GA' are well-defined by GA and COMP , nevertheless.
Definition 4.3 (Architecture Reduction Rule) An architecture reduction rule for a given architecture A is a tuple CON = (COND, CONG ) given by a diagram reduction rule COND for the architecture diagram DA and a corre- sponding graph reduction rule CONG for the architecture graph GA.
We can show by an Architecture Reduction Lemma that an architecture reduction rule CON = (COND , CONG) reduces an architecture A to a well- defined smaller architecture A' with DA' and GA' as defined above. The appli-
cation of CON is denoted by A CO⇒N A'. A' is smaller than A in the following sense: If A is of arity (k, l) we can show that A' is of arity (k − n + 1,l − 1), if CON has arity n.
Given an architecture A consisting of k components and l connectors and a corresponding architecture reduction rule CON = (COND , CONG) we obtain
reductions COND : DA ⇒ DA' , CONG : GA ⇒ GA' and CON : A ⇒ A', where A' is a new architecture with k−n+1 components, l−1 connectors, architecture diagram DA' and architecture graph GA' .
The corresponding proof will be presented in [5]. Now we can give the se- mantics of an architecture as the result of as many reduction rules as possible.

Definition 4.4 (Architecture semantics) The semantics of an architec- ture A is any component COMP obtained by a sequence of architecture re-



duction steps from A to COMP ,
A ⇒∗ COMP.

The main result given in Theorem 4.5 shows that this semantics always
exists and is unique.
Theorem 4.5 (Exist. and Uniqueness  of Architecture Semantics) For each architecture A there is a unique component COMP which is the se- mantics of A. COMP is obtained by any reduction sequence, where connectors of A are reduced in arbitrary order:
A ⇒∗ COMP
Proof Idea. This theorem uses the fact that the presented reduction rules
satisfy the Church-Rosser property, i. e. the result of a sequence of reduction steps is independent from the order of the steps. This can be shown using a well known local Church-Rosser property for independent graph transfor- mations (see [2]), which are independent reduction steps in our case. For the case of dependent reduction steps we need Theorem 3.10. The result of the reduction sequence is well-defined and unique, since the maximal number of necessary reduction steps is given by the number of connectors and the order of calculation is not relevant.	 
The full proof of this theorem will be given in the report [5].

Instantiation to UML Models
In this section we will show, how the abstract connector framework can be ap- plied to UML diagrams. In this paper, we regard only the concrete graphical representation of UML diagrams on a more or less intuitive level. This implies that also our instantiation can be given only on an intuitive level. In later stages of our research we want to deal with the corresponding meta-model in- stances as formal abstract syntax, which would enable us to give a much more detailed definition of connector architectures for UML diagrams. Moreover, we could respect the syntactical dependencies between different diagrams, e. g. the case that a state machine refers to a certain method defined in the class diagram, which are documented in the UML meta-model instances.
Transformations and Embeddings of UML Diagrams
We will consider (restricted versions) of the following diagram types: class diagrams, state machines and sequence diagrams. For a definition of these diagrams we refer to UML (see [14]).

We allow to attach state machines to classes only. This implies that each state machine SM refers to a corresponding class diagram cd (SM ) defining the methods that can be used to label transitions. A sequence diagram SD is also attached to some class diagram cd (SD ) defining the classes for all object nodes and the methods used by the message edges. In the first step of the instantiation we will define transformations and embeddings for each of our techniques. In the case study in Section 2 these two notions of connections between UML specifications are referred to as package dependency relations stereotyped by <<transform>> and <<embed>>, respectively.
A transformation of class diagrams tCD : CD ⇒ CD ' is given by a mapping of each class cd ∈ CD to a class cd ' ∈ CD ', where the image cd ' has to offer at least the functionality of cd up to consistent signature renaming. This
means for example, that an attribute number : Nat of CD may be translated to an attribute number : Int, if all other occurrences of number : Nat in the class diagram CD are translated to number : Int. Of course, the images of the classes are allowed to have additional functionality with respect to their preimage. All connections between classes have to be transformed to corresponding connections of the same type, e. g. associations have to be mapped to associations. Again we allow a renaming of the inscriptions of the connections.
A transformation of a state machine tSM : SM ⇒ SM ' requires a transfor- mation of the related class diagram first. This transformation is used to
st ∈ SM we require an image st' ∈ SM ', which may be renamed. This con- translate the labels of the transitions of the state machine. For each state dition is also required for the state transitions, whose labels have to be
transformed in accordance with the transformation of the related class di- agram. We allow that the target state machine SM ' adds new states and transitions, but we require that all accepted traces of SM are also accepted by the ’enriched’ state machine SM ', after they have been translated ac- cording to the class diagram transformation.
In the case of sequence diagrams, we consider transformations of sets of
ones. Transformations tSD : SD ⇒ SD ' are defined in three steps. First, as diagrams (where each of them represent a possible scenario) instead of single in the previous case, a transformation of the related class diagram is needed
to translate the labels of the interactions in the diagram. The second step is to replace lifelines by disjoint sets of lifelines (including the given lifeline) and interactions (l, m, l') (where l and l' are lifelines and m is a message sent from l to l') by sets of diagrams involving only the lifelines included in the refinements of l and l'. Finally, each diagram in SD must be included in a diagram in SD '.


Fig. 28. Sample Transformation of State Machine and Class Diagram
The idea is that when refining a sequence diagram, we may refine lifelines and interactions. In particular, the refinement of a lifeline may involve other lifelines which are considered hidden at a higher level of abstraction. On the other hand, a simple interaction may be replaced by a more complex interaction represented by a set of diagrams.
Now we define embeddings of class diagrams, state machines and sequence diagrams. For sake of simplicity embeddings are inclusions in this paper, which do not allow any renamings. Thus, we are enabled to define the following extension constructions as unions of sets. In both cases, embeddings and transformations, the target diagram is allowed to have additional elements.
Figure 28 shows a transformation of a state machine SM and the related class diagram cd (SM )= CD . The transformation of the methods in the sam- ple class, which is not shown explicitly in the figure, renames the methods a(): to c(): and b(): to d():. Since there are no designated final states, the state
machine SM accepts (ab)∗, (ab)∗a. This is translated along the transforma- tion to (cd)∗, (cd)∗c, which is a part of the accepted traces of SM '. Thus, this sample transformation fulfills our requirements for diagram transformations stated above.

Extension of Diagram Transformations
In the next step of the instantiation we have to verify the extension prop- erty (see Definition 3.1), i. e. to define the extension of transformations along embeddings.

CD   e  C D1

tCD
cz
tCD,1
cz

CD '
'  C D '

Fig. 29. Extension of Class Diagram Transformations
For class diagrams consider Figure 29, where three class diagrams CD , CD '
and CD1 are given, connected by a transformation tCD : CD ⇒ CD ' and

an embedding e: CD →
t
CD1 . The transformation arrows CD =⇒
CD ' and

tCD,1	'
CD1 =⇒ CD1 in Figure 29 represent a UML dependency relation of the
corresponding packages which is stereotyped as <<transform>>.
The extension of tCD along e as depicted in Figure 29 is now constructed
as follows: We define CD ' by adding CD1 without CD, written CD1 \ CD ,
to the result CD ' of the transformation tCD . Note that CD1 \ CD is con-
structed by removing all classes and class relations from CD1 that are also
part of CD and thus, embedded by e. This may cause ill formed class rela- tions since their targets might have been removed. The well-formedness is restored in CD ' , since the loose ends of the class relations are connected to the tCD images of the deleted classes.
We obtain the extension tCD,1 , because the elements of CD1 are either
directly included to CD ' or their renamed versions are taken from CD '.
By taking the renaming of the latter elements and the identical embedding
of the former we can construct a renaming transformation. Moreover, we
obtain the embedding e': CD ' → CD ' , since CD ' is a part of CD ' .
1	1
Note that the construction as described above does only work, if we do
not have any name clashes between CD1 \ CD and CD '. We could drop this

constraint by defining the construction of CD '
by a pushout construction,

which avoids name clashes by suitable renaming.
The extension of state machine transformations works analogous. Given three state machines SM , SM ', and SM1 connected by a transformation
tSM : SM ⇒ SM ' and an embedding s: SM → SM1 . Since we required re-
lated class diagrams for the state machines we can calculate the corre-
sponding class diagram extension. Then we add SM1 \ SM to SM '. This
construction ensures that SM ' accepts all valid traces of SM1 , because no
transitions are deleted.
In the case of sets of sequence diagrams, we consider that a set SD is embedded in SD ' if every diagram in SD is included in some diagram in SD '.
Now, if SD is embedded in SD1 and tSD : SD ⇒ SD ' is a transformation, we

define the extension tSD,1 : SD ⇒ SD '
as follows. First, we replace all the

labels in SD1 by the corresponding labels according to the transformation



Fig. 30. Sample Extension of State Machine and Class Diagram

of the associated class diagrams. Then we replace all the lifelines in SD1 by their corresponding refinement according to tSD (if a lifeline is not in SD we assume that it’s refinement is the lifeline itself). Finally, we replace all the interactions by their corresponding refinements according to tSD (again, if an interaction is not in SD we assume that it’s refinement is the diagram consisting just of that interaction). It may be proven that this construction

ensures that there is a transformation from SD to SD '
and an embedding

from SD1 to SD ' .
Figure 30 shows the extension of a state machine transformation and the corresponding class diagram transformation. Intuitively, the transformation
SM =⇒ SM', which renames the transition labels a to c and b to d and adds
a new transition labeled with c, and it’s corresponding class diagram trans-
formation are applied to the state machine SM1. This means, the diagram elements embedded from the state machine SM1 and it’s corresponding class
diagram, are replaced by their images w. r .t. the transformation SM =⇒ SM'.
The remaining elements in the state machine SM1 and the related class dia-
gram are copied unchanged. Finally, all new elements of SM', e. g. the method
add, are added.
In the final step of the instantiation we have to verify the parallel extension
tions. Let class diagrams CD and CDj with transformations tCD,j : CDj ⇒ CD ' and embeddings ej : CDj → CD for j ∈ J be given. For the consistency of the property (see Definition 3.2), i. e. to define the parallel extension of transforma-
families (ei)i∈I of embeddings and (ti)i∈I of transformations, we require that
(ei)i∈I is compatible with (ti)i∈I, which means that all overlappings in CD

CDj
tCD,j
cz
ej	 C D
tCD
cz

CD ' 	 C D '
j
Fig. 31. Parallel Extension of Class Diagrams

ment c ∈ CDj1 ∩ CDj2 is in the intersection of two class diagrams, it’s image with respect to (ej )j ∈J are commonly transformed by (ti)i∈I, i. e. if an ele- with respect to both transformations, tCD,j1 and tCD,j2 , has to be the same in
' ∩ CD ' .
The result CD ' of the parallel transformation tCD is constructed as follows.
First, we join all CD ' for j ∈ J to a single class diagram. In the next step we

add CD \
 
j ∈J
j
CDj to the previous result.

c is an image of any cj ∈ CDj then select the image of cj with respect to the The parallel transformation tCD is then defined as follows. If an element transformations of the overlappings. Otherwise, i. e. there is no cj ∈ CDj with transformation tj. This selection is well defined since we required common ej(cj) = c, c remains unchanged by the constructed parallel transformation

tCD . The embeddings e'
for j ∈ J are directly induced by the construction of

CD '.
In order to avoid name clashes in CD ' we require that CD \   CDj is

disjoint to
 
j ∈J
j ∈J
CD '. As discussed above, this could be avoided by constructing

CD ' by a suitable colimit construction.
The parallel extension property of state machines and sequence diagrams is verified in a similar way.
Summarizing we obtain the following result.
Fact 5.1 (Architecture Framework for UML Models)	Restricted class diagrams, state machines and sequence diagrams as considered above to- gether with the corresponding notions of transformations and embeddings are satisfying the extension property (Deﬁnition 3.1) and the parallel extension property (Deﬁnition 3.2) of the generic architecture framework in Section 3.
Proof Idea. The construction of extension and parallel extension diagrams has been discussed already above. It remains to show the properties. First of all, all embeddings preserve the type of the diagram elements and they do not change any inscriptions. Hence, they are special cases of the defined transfor-
the extension diagram of two embeddings e : SP → SP1 and f : SP → SP ' mations. Embeddings and transformation are closed under composition and

(with SP1 ∩ SP ' = SP for the simplified construction) is given by the union

SP '
= SP1 ∪ SP ' and embeddings e' : SP ' → SP '
and f '' : SP1 → SP ' , which

leads to a mutual extension diagram. The construction of parallel extension
diagrams above implies that they are closed under vertical composition. More- over, if all transformations ti are embeddings, then also t is an embedding and if in addition all t2,... , tn are identities, then 31 in Figure 15 is a mutual extension diagram, because embeddings are diagram inclusions and do not merge any elements (and they do not change any inscriptions in our simplified version).	 
This allows to apply the generic architecture framework to UML models, leading to the concept of components, connectors and architecture diagrams and graphs, architectures, component composition and semantics of architec- tures as presented in Sections 3 and 4 for UML models. Especially, we obtain the main results “Compatibility of Component Composition”(Theorem 3.10) and “Existence and Uniqueness of Architecture Semantics”(Theorem 4.5) for the UML models considered above.

Conclusion
In this paper we have presented object-oriented connector-component archi- tectures of a subset of UML diagrams. More precisely, we have extended our generic framework for connector architectures presented at FESCA ’04 (see [4]) to the case of overlapping connector interfaces which allows to apply it to class diagrams, state machines and sequence diagrams with suitable restric- tions. In the extended general framework we are able to show as main result compatibility of component composition as well as existence and uniqueness of architecture semantics. The third main result shows that this framework can be instantiated to UML diagrams as discussed above using suitable no- tions of transformations and embeddings. This allows to apply the generic results to these UML diagrams in general and to an object-oriented connector- component architecture for a meta data management system as a case study in this paper.
The component concept of the UML 2.0, as well as most programming language oriented component approaches, is orthogonal to our approach in the following sense. In contrast to our approach, UML 2.0 components as pre- sented in [14] are intended to describe the distribution of executable program pieces. Our approach is concerned with the structuring of the specification of system requirements and system design. Thus, each of our components might be realized by a set of these software components. Though it might be pos- sible to understand UML 2.0 components as a special case of our approach.

The further examination of this relation would yield a formal foundation for several parts and application scenarios of the UML 2.0 component notion.
The approach in this paper is based on an intuitive graphical representa- tion of UML diagrams. In future work we want to deal with the corresponding meta-model instances as formal abstract syntax, which would allow a much more detailed discussion of the instantiation, and we will also consider more general notions of transformations and embeddings. Moreover, it is possible to consider other UML techniques. Especially with respect to the example in Section 2 it seems sensible to include UML profiles to the components. Ontolo- gies could then be modeled as class hierarchies with respect to an ontology profile. On the other hand profiles could also be used for platform specific implementation models.
In view of system evolution, as for example in the sense of [18], it seems promising to extend the presented framework by means to transform or refine, respectively, not only specifications but whole components and connectors, and thus also by transformations and refinements of component architectures. Refinements of components and connectors can be necessary for different rea- sons. For example, if a company adds any requirements to their product spec- ification in the middle of the specification process, the developers might have to adapt component interfaces to meet the new requirements. But component refinements should preserve the mutual dependencies with related connectors and concerned components. Such architecture refinement concepts could also be used to formalize the steps between different stages in a defined software development process. With respect to the example in Section 2 this could mean to refine the given architecture by an implementation in Java or .NET.

Acknowledgement
This work is partially supported by the TMR network SEGRAVIS and the Spanish project MAVERISH (TIC2001-2476-C03-01) and by the CIRIT Grup de Recerca Consolidat 2001SGR 00254.
We would like to thank the anonymous referees for their valuable comments and suggestions for improvements of this paper.

References
Allen, R. and D. Garlan, A Formal Basis for Architectural Connection, ACM Transactions on Software Engineering and Methodology (1997).
Ehrig, H., Introduction to the Algebraic Theory of Graph Grammars (A Survey), in: V. Claus,
H. Ehrig and G. Rozenberg, editors, Graph Grammars and their Application to Computer Science and Biology, Lecture Notes in Computer Science 73 (1979), pp. 1–69.


Ehrig, H., F. Orejas, B. Braatz, M. Klein and M. Piirainen, A Generic Component Concept for System Modeling, in: R.-D. Kutsche and H. Weber, editors, Fundamental Approaches to Software Engineering (FASE ’02), Lecture Notes in Computer Science 2306 (2002), pp. 33–48.
Ehrig, H., J. Padberg, B. Braatz, M. Klein, F. Orejas, S. Perez and E. Pino, A Generic Framework for Connector Architectures based on Components and Transformations, in: Formal Foundations of Embedded Software and Component-Based Software Architecture (FESCA ’04), Electronic Notes in Theoretical Computer Science 108 (2004), pp. 53–67.
Ehrig, H., J. Padberg, B. Braatz, M. Klein, F. Orejas, S. Perez and E. Pino, A Generic Framework for Connector-Component Architectures, Forschungsbericht, Fakult¨at IV – Elektrotechnik und Informatik, TU Berlin (2005), to appear.
Garlan, D., R. Monroe and D. Wile, Acme: An Architecture Description Interchange Language, in: Proc. of CASCON ’97, 1997, pp. 169–183.
Griffel, F., “Componentware – Konzepte und Techniken eines Softwareparadigmas,” dpunkt Verlag, 1998.
Hofmeister, C., R. Nord and D. Soni, “Describing Software Architecture in UML,” Kluwer Academic Publishers, 1999 pp. 145–159.
International	Organization
for Standardization, “Topic Maps,” Second edition (2002), ISO/IEC 13250, ISO/IEC JTC 1/SC34 N0322 available from http://www.y12.doe.gov/sgml/sc34/document/0322.htm , last accessed on February 11, 2005.
International Organization for Standardization, “The XML Topic Maps Syntax (XTM 1.1),” (2003),	ISO/IEC	13250-3,	ISO/IEC
JTC1/SC34 N0398 available from http://www.y12.doe.gov/sgml/sc34/document/0398.htm, last accessed on February 11, 2005.
International	Organization	for	Standardization, “Topic Maps – Data Model,” (2003), ISO/IEC 13250-2, ISO/IEC JTC1/SC34 N0443 available from http://www.y12.doe.gov/sgml/sc34/document/0443.htm, last accessed on February 11, 2005.
Internet Engineering Task Force, “Hypertext Transfer Protocol – HTTP/1.1,” (1999), available from http://www.ietf.org/rfc/rfc2616.txt, last accessed on February 11, 2005.
Nilsson,	M.,
“ID3 tag version 2.4.0,” id3.org (2000), available from http://www.id3.org/develop.html, last accessed on February 11, 2005.
Object Management Group, “Unified Modeling Language – Version 2.0 (UML 2.0),” (2004), available from http://www.omg.org/, last accessed on February 11, 2005.
Shaw, M., R. Deline, D. V. Klein, T. L. Ross, D. M. Young and G. Zelesnik, Abstractions for Software Architecture and Tools to Support Them, IEEE Transactions on Software Engineering 21 (1995), pp. 314–315.
Shaw, M. and D. Garlan, “Software Architecture - Perspectives on an Emerging Discipline,” Prentice Hall, 1996.
Wermelinger, M. and J. L. Fiadeiro, Connectors for Mobile Programs, IEEE Transactions on Software Engineering 24 (1998), pp. 331–341.
Wermelinger, M. and J. L. Fiadeiro, A graph transformation approach to software architecture reconﬁguration, Science of Computer Programming 44 (2002), pp. 133–155.
