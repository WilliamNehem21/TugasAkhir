

Electronic Notes in Theoretical Computer Science 229 (2009) 27–47
www.elsevier.com/locate/entcs
Relational Semantics Revisited
Eike Best1
Parallel Systems, Department of Computing Science Carl von Ossietzky Universita¨t, D-26111 Oldenburg, Germany
Kerstin Strecker
Max-Planck Gymnasium, D-37073 Go¨ttingen, Germany

Abstract
This paper describes the systematic use of fixpoints for the relational semantics of unboundedly nondeter- ministic sequential programs. The focus is on analysing the expressiveness of various semantic definitions and of powerdomains including or excluding an ‘error’ element ⊥.
Keywords: Denotational semantics, Egli-Milner ordering, fixpoints, Hoare ordering, powerdomains, relational semantics, Smyth ordering.


Introduction
This paper describes a set of fixpoint schemes suitable for defining the relational semantics of sequential nondeterministic programs, while focussing on the expres- siveness of such semantics. For the purpose of this paper, expressiveness of a se- mantics is defined as the set of programs that are discriminated by it. For exam- ple, traditional partial correctness semantics equates the two programs skip and skip or abort but distinguishes skip or abort from abort, while traditional to- tal correctness semantics identifies skip or abort with abort but distinguishes between skip or abort and skip.
We consider general nondeterminstic programs, allowing unbounded nondeter- minism as well as nonterminating behaviour. Usually, a special ‘error’ symbol called
⊥ (the bottom symbol) is employed in order to describe the effect of failing pro-
grams such as abort or of nonterminating programs such as do true → skip od. We investigate the possibility of using denotational (in particular, fixpoint-based)

1 Email: eike.best@informatik.uni-oldenburg.de

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.072

methods while avoiding the ⊥ symbol as an initial state. This is done for three se- mantics of different degrees of expressiveness: partial correctness semantics, which is as expressive as Hoare proof rules, total correctness semantics, which is as expres- sive as Dijkstra weakest preconditions, and full semantics, which is as expressive as both of them in combination. Parametrised fixpoint definitions are introduced in order to accommodate these semantic variants.
The paper is organised as follows. Section 3 contains direct definitions of the three semantics (full, partial correctness, and total correctness). Section 4 gives equivalent fixpoint semantics while using the ⊥ symbol as little as possible and set theory as much as possible. This is compared with traditional powerdomain approaches described in section 5. The concluding section 6 contains some remarks and a short bibliographic overview. Results whose proofs are believed by the authors not to be readily accessible elsewhere (for instance the proof of proposition 4.3, referring to a Smyth-ordering-free denotational semantics of total correctness) are contained in an appendix.


Notation and syntax
Let S be any set. The powerset of S is denoted by 2S , and the disjoint union of
two sets is denoted by ∪• . Let ρ ⊆ S×S be any relation on S. The set dom(ρ) is
defined as {x∈S | ∃y∈S: (x, y)∈ρ}. For a∈S, we write aρ = {x∈S | (a, x)∈ρ} and ρa = {x∈S | (x, a)∈ρ}. The relation id S is defined as {(a, a) | a∈S}. Let ρ1 ⊆ S×S', ρ2 ⊆ S''×S''' with S'' ⊆ S' be any two relations. Relational composition is defined by ρ1◦ρ2 ⊆ S×S''' and (a, b)∈ρ1◦ρ2 ⇔ ∃x∈S'': (a, x)∈ρ1∧(x, b)∈ρ2. Programs p are
built from the following syntax (see e.g. [6,9]):
p ::= skip | abort | x:=E | x:=? | p1;p2 | if B1→p1  B2→p2 fi | do B→p od.
Using this syntax, one may express nondeterminism (using the if ... fi construct), infinite nondeterminism (using x:=?, meaning that x is assigned an arbitrary nat- ural number), and iteration (using do ... od). E and B are expressions and Boolean expressions, respectively. As a (non-essential) simplification, we assume that the evaluation of an expression in a state never leads to an error. Errors may be introduced explicitly by the abort command, implicitly by non-applicable if
commands, or by nonterminating do commands. Program if true→p1  true→p2 fi 
is abbreviated as p1 or p2.
All variables are assumed to be typed, so that, as usual, a state space Z(p) (the set of functions from variables to values) can be associated with every program p. To simplify formulae, we write Z instead of Z(p) and m instead of m(p) if the program p is known from the context. Also, Z⊥(p) = Z(p) ∪• {⊥} and Z⊥ = Z ∪• {⊥}. A state s∈Z⊥ is called proper if s/=⊥. We will use the following notation consistently:
p	to denote an arbitrary program
DO to denote a loop do B → c od with entry condition B and body c.

Let E be an expression, x a program variable, and s' a state. Then s'[x←E] is defined as the same state as s', except that the value of variable x is the value of E when evaluated in state s'.

Direct definitions of relational semantics
Relational semantics (also called ‘natural semantics’ [19]) associates a relation be- tween initial and final states to a program. Since if a program does not terminate properly, no proper final state is produced, an artefact is used in order to describe (potential) nontermination. This is achieved by the artificial ‘error’ state ⊥. The production of such a state as a final state indicates prior, not properly terminating execution. Adding it to the set of initial states may be viewed (intuitively and op- erationally) as redundant, since error states do not give rise to further executions. Therefore, our investigations start by considering relations ρ of the form ρ ⊆ Z ×Z⊥, where the first factor, Z, denotes the initial states (excluding ⊥) and the second factor, Z⊥, denotes the final states (including ⊥).

Full relational semantics m(p)
A semantic relation m(p) ⊆ Z×Z⊥ is associated with every program p, such that (s', s)∈m(p) expresses the following operational meaning: When started in (the proper state) s'∈Z, program p may end in (proper) state s (if s∈Z), or may fail to terminate (if s=⊥). Relation m(p) is defined by induction on the syntax of p:
m(skip)	= {(s', s') | s'∈Z}
m(abort)	= {(s', ⊥) | s'∈Z}
(s', s)∈m(x:=E) ⇔ s=s'[x←E] (section 2 explains notation) (s', s)∈m(x:=?) ⇔ ∃i∈N: s=s'[x←i]
(s', s)∈m(p1;p2)  ⇔ ((s', s)∈m(p1)◦m(p2)) ∨ (s=⊥∧(s', ⊥)∈m(p1))
(s', s)∈m(if B1→p1  B2→p2 fi)  ⇔
∃j∈{1, 2}: Bj(s')=true ∧ (s', s)∈m(pj) ∨ (s=⊥∧ B1(s')=B2(s')=false). 
For the definition of m(DO ), with DO = do B→c od, let a finite sequence s0,..., sr (an infinite sequence s0, s1,.. .) of states in Z⊥ be called a valid m-sequence (with respect to do B→c od) if B(sj)∧(sj, sj+1)∈m(c) for 0≤j<r (respectively, for 0≤j). Then,
(s', s) ∈ m(do B→c od)
⇔	[s/=⊥∧ ∃ valid m-sequence s0,..., sr: s'=s0, sr=s and ¬B(sr)]
∨ [s=⊥∧ ∃ valid m-sequence s0,..., sr: s'=s0 and sr=⊥]
∨ [s=⊥∧ ∃ infinite valid m-sequence s0, s1,... : s'=s0].

The first term describes normal termination of the loop, the second term describes the case that the loop body leads to nontermination, and the third term describes infinite execution. Note that, as a consequence of the definition, all sj, except possibly sr, are proper.
For later use, the conjunction ((s', s)∈m(DO )∧⊥∈/s'm(DO )) is rewritten as fol- lows:
((s', s)∈m(DO )∧⊥∈/s'm(DO ))
⇔	[∃ valid m-sequence s0,..., sr: s'=s0, sr=s and ¬B(sr)]	(A)
∧ [¬∃ valid m-sequence s0,..., sr: s'=s0, B(sr) and ⊥∈srm(c)]	(B)
∧ [¬∃ infinite valid m-sequence s0, s1,... : s'=s0].	(C)
(A) rewrites (s', s)∈m(DO ) and (B)∧(C) rewrites ⊥∈/s'm(DO ).
Examples: If there is only a single integer variable x, every state can be written as (x=i), and we have, for instance:
((x=−2), (x=3))	∈ m(x:=x+5)
((x=−2), (x=3))	∈ m(x:=?)
((x=−2), (x=−1)) /∈ m(x:=?)
((x=−2), ⊥)	/∈ m(x:=?)
((x=−2), (x=0))  ∈ m(do x<0→(x:=x+1 or x:=−x) od)
((x=−2), (x=1)) ∈ m(do x<0→(x:=x+1 or x:=−x) od) ((x=−2), ⊥)	/∈ m(do x<0→(x:=x+1 or x:=−x) od) ((x=−2), ⊥)	∈ m(do x<0→(x:=x+1 or skip) od)
(since the loop may fail to terminate)
((x=−2), ⊥)	/∈ m(do x/=0→if x>0→x:=x−1  x<0→x:=? fi od).

Partial and total relational semantics m1(p) and m2(p)
From m(p), two relations m1(p), m2(p) ⊆ Z(p) × Z(p) are derived as follows:
m1(p)  =  m(p) ∩ (Z(p) × Z(p))
m2(p)  =  m(p) ∩ ( (Z(p)\(m(p)⊥)) × Z(p) ).
The relation m1 describes partial correctness semantics; it simply forgets about non- termination and thus equates, for instance, skip and (skip or abort). By contrast, m2 describes total correctness semantics; it contains a pair (s', s)∈m(p)∩(Z×Z) only if s' under no circumstances leads to nontermination, and thus it equates (skip or abort) and abort. It can be shown [6] – and is well-known – that m1(p) is as expressive as Hoare’s proof rules [13], while m2(p) is as expressive as Dijkstra’s

weakest precondition function wp(p) [9], and that m(c) can be reconstructed if both m1(p) and m2(p) are known. Thus, m1 and m2 are incomparable and individually less expressive than m, but both together are as expressive as m.
In the next two subsections we show, briefly, that instead of deriving them from
m(p), the two relations m1(p) and m2(p) can also be defined inductively.

Inductively deﬁned partial correctness semantics m' (p) = m1(p) Clauses of m' (p) ⊆ Z×Z that differ from those of m(p) are given below.
m' (skip)	= id Z
m' (abort)	= ∅
m' (p1;p2)	= m'(p1) ◦ m'(p2)
(s', s)∈m' (if B1→p1  B2→p2 fi) ⇔ ∃j∈{1, 2}: Bj(s')=true ∧ (s', s)∈m' (pj).
1	1
Let s0,..., sr be called a valid m' -sequence if B(sj)∧(sj, sj+1)∈m' (c) for all 0≤j<r.
1	1
(s', s)∈m' (do B→c od) ⇔ ∃ valid m' -sequence s0,..., sr:
1	1
s'=s0, sr=s and B(sr)=false.
Lemma 3.1 Let p be any program. Then m' (p) = m1(p).
Inductively deﬁned total correctness semantics m' (p) = m2(p) Clauses of m' (p) ⊆ Z×Z that differ from those of m' (p) are given below.
2	1
m' (abort)	= {(s', ⊥) | s' ∈ Z}
(s', s)∈m' (p1;p2) ⇔ ((s', s)∈m' (p1)◦m' (p2)) ∧ (s'm' (p1)⊆dom(m' (p2)))
2	2	2	2	2
(s', s)∈m' (if B1→p1  B2→p2 fi)  ⇔
∃j∈{1, 2}: Bj(s')=true ∧ (s', s)∈m' (pj) ∧ ∀j∈{1, 2}: Bj(s')=true ⇒ s'm' (pj)/=∅ .
2	2
Let s0,..., sr (s0, s1,.. .) be called a finite (resp.  infinite) valid m' -sequence iff
B(sj)∧(sj, sj+1)∈m2(c) for all 0≤j<r (resp., for all 0≤j). Then,
(s', s) ∈ m' (do B→c od)
⇔   [∃ valid m' -sequence s0,..., sr: s'=s0, sr=s and ¬B(sr)]	(A2)
∧ [¬∃ valid m' -sequence s0,..., sr: s'=s0, B(sr) and srm2(c)=∅]   (B2)
∧ [¬∃ infinite valid m' -sequence s0, s1,... : s'=s0].	(C2)
Note how the semantics of the sequential composition takes the intended meaning of m2 into account: a pair (s', s) is included in m' (p1;p2) only if for every state t with (s', t)∈m' (p1) there is some state s'' with (t, s'')∈m' (p2), i.e., p2 terminates
2	2
when started with t.
Lemma 3.2 Let p be any program. Then m' (p) = m2(p).

Fixpoint definitions of relational semantics
The objective of the present section is to provide alternative (denotational-style) definitions of a triple of relations m(p), m1(p) and m2(p), such that they equal m(p), m1(p) and m2(p), respectively. To this end, we consider the following function, N , on relations, intended for describing a loop:


(1)

N˜ :
⎧⎨ (2Z×Y , ±˜) → (2Z×Y , ±˜)

⎩	ρ	'→ N˜(ρ) = ( (¬B×Z) ∩ id Z) ∪ ((B×Z) ∩ (A˜(c) ☒ ρ) ).
Here, ¬B is the set of states for which B evaluates to false and B is the set of states for which B evaluates to true (as said before, we assume that evaluating B does not lead to any error). The operational intuition behind the last line of (1) is that: either B is false and the loop stops with unchanged initial state, or B is true and the body A(c) is executed, ‘after’ (i.e., ☒) which the same situation is repeated.
We consider N to be parametric in terms of Y , ±, A(c) and ☒, with the following intentions. As for using 2Z×Y , the set of initial states is always Z, excluding ⊥, and the set Y of final states should be either Z (for m˜1, m˜2) or Z⊥ (for m˜ ); this
provides for avoiding ⊥ as much as possible. The ordering ±˜ should be either ⊆
or ⊇, providing for maximal use of set theory. The relation A(c) is always given inductively, since c is the loop body. The relational composition ☒ may need to vary in order to discriminate between m˜ , m˜1 and m˜2.

Fixpoint for partial correctness semantics m1(p)=m1(p) In this section, equation (1) is specialised as follows:
Y	=  Z
±˜	=  ⊆
A˜(c) = m˜1(c)	(known inductively)
☒  =  ◦	(ordinary relational composition).
Let N , with these definitions, be called N 1. Then N 1 is continuous (and hence monotonic) with respect to ⊆. This follows from the continuity of ∩ and ∪ in both arguments, as well as the continuity of ◦ in its second (as well as its first) argument. Hence N˜1 has a minimal fixpoint. Let m1(DO ) be defined as this least fixpoint. The other clauses of m˜1 follow the same definition as that of m' .
Proposition 4.1 m˜1(p) = m1(p) for all programs p.

Fixpoint for total correctness semantics m˜2(p) = m2(p)
There is a suitable relational composition ☒ such that the minimal fixpoint of N˜, so defined, is m˜2(DO ):

Definition 4.2 [Demonic composition, cf. [8]] Let σ and τ be two relations ⊆ Z ×Z. Then σ ∗ τ is a new relation ⊆ Z × Z which is defined by (a, b) ∈ (σ ∗ τ ) ⇔ ((a, b) ∈ (σ ◦ τ ) ∧ (aσ ⊆ dom(τ ))).
Note that ∗ exactly mimics the sequential definition for m' in section 3.4. It is
associative and monotonic in the second argument (see appendix A). Equation (1) is specialised as follows:
Y	=  Z
±˜	=  ⊆
A˜(c) = m˜2(c)	(known inductively)
☒  =  ∗	(definition 4.2).
Let N 2 be defined as N with this choice. By the above, N 2 is, in its turn, monotonic with respect to ⊆, and has a unique minimal fixpoint. Let m2(DO ) be defined as this least fixpoint. The other clauses of m2 follow the same definition as that of m' .
We can now state the first main result of this paper. Its proof (appendix A) is surprisingly nontrivial:
Proposition 4.3 m˜2(p) = m2(p) for all programs p.
Examples: First, consider p1 = var x : {−2, −1, 0, 1, 2}; do x<0→(x:=x+1 or x:=−x) od.
Moreover, consider
γ1 = {((x=−2), (x=2)), ((x=−2), (x=1)), ((x=−2), (x=0)), ((x=−1), (x=1)),
((x=−1), (x=0)), ((x=0), (x=0)), ((x=1), (x=1)), ((x=2), (x=2))}
δ1 = γ1.
Then γ1 is a fixpoint of N˜1 (with respect to p1). It is approximated as follows:
γ0 = ∅	(the empty relation)
γ1 = N˜1(∅) = {((x=0), (x=0)), ((x=1), (x=1)), ((x=2), (x=2))}
γ2 = N˜1(γ1) = γ1 ∪ {((x=−2), (x=2)), ((x=−1), (x=1)), ((x=−1), (x=0))}
γ3 = N˜1(γ2) = γ1.
By contrast, for N˜2, δ1 (which is the same as γ1) is approximated as follows:
δ0 = ∅
δ1 = N˜2(∅) = {((x=0), (x=0)), ((x=1), (x=1)), ((x=2), (x=2))}
δ2 = N˜2(δ1) = δ1 ∪ {(((x=−1), (x=1)), ((x=−1), (x=0))}
δ3 = N˜2(δ2) = γ1.
The difference is that in δ1, the pair (x=−2), (x=2)) is added only when it is abso- lutely certain that initial state (x=−2) does not lead to nontermination.

Consider next p2 = do x<0→(x:=x+1 or skip) od and
γ2 = δ2 ∪ {((x=k), (x=0)) | k < 0}
with δ2 = {((x=i), (x=i)) | i ≥ 0}.
Then γ2 is (least) fixpoint of N 1 (with respect to p2), and it happens also to be a (non-minimal) fixpoint of N 2. Moreover, δ2 is (least) fixpoint of N 2, but no fixpoint of N 1. Thus, m1(p2) = γ2 and m2(p2) = δ2. Note how the pair ((x=−1), (x=0)) is added to m1(p2) by the definition of ◦ and by the facts that ((x=−1), (x=0)) is one of the possible executions of the loop’s body and ((x=0), (x=0)) is in m1(p2) because the entry condition evaluates to false in state x=0. The definition of ∗, by contrast, prevents ((x=−1), (x=0)) from being included in the least fixpoint of N 2.
Consider p3 = do x/=0→if x>0→x:=x−1  x<0→x:=? fi od and
δ3 = {((x=i), (x=0)) | i ∈ Z}.
Then δ3 is both a (minimal) fixpoint of N 1 and a (minimal) fixpoint of N 2 with respect to p3.

Fixpoint for full relational semantics m(p) = m(p)
Since m(p) is a subset of Z × Z⊥, we are led to consider Y = Z⊥, i.e. the set of relations 2Z×Z⊥ , and a suitable partial order as well as a suitable relational composition for ☒ on it. Keeping in mind that ☒ = ◦ in section 4.1 and ☒ = ∗ in section 4.2 simulate, respectively, the sequential composition in the definitions of
' (section 3.3) and m' (section 3.4), the following is a candidate, since it captures
the sequential composition as defined in section 3.1.
Definition 4.4 [Erratic composition] Let σ and τ be two relations ⊆ Z × Z⊥. Then σ ⬦ τ is a new relation ⊆ Z × Z⊥ defined by (a, b) ∈ (σ ⬦ τ ) ⇔ ((a, b) ∈ (σ ◦ τ ) ∨ ((a, ⊥) ∈ σ∧b=⊥).
The example p4 = var x : {0}; do x=0 → skip od shows that neither ⊆
nor ⊇ can be chosen as ±˜.  This is because the m semantics of p4 is m(p4) =
{(x=0, ⊥)}, but the least fixpoints of N˜ under ⊆ and under ⊇ are, respectively, ∅
and {(x=0, x=0), (x=0, ⊥)}. The same example shows that switching from least to greatest fixpoints does not help, either.
Instead, the set 2Z⊥ will be provided with the following ordering. For X, Y ∈
2Z⊥ :
(2)	X ±full Y	⇔ (X\{⊥}⊆Y ) ∧ (⊥∈X ∨ ⊥∈/Y ).
Lemma 4.5 (2Z⊥ , ±full ) is a complete lattice.
(2Z⊥ , ±full ) is actually isomorphic to the lattice product (2Z, ⊆) ⊗(2{⊥}, ⊇) with its induced partial ordering. Taking ⊆ in the first lattice and ⊇ in the second can be interpreted as follows. The ⊆ indicates ‘less definite information’, that is: if X and Y are two sets of (final) proper states and if X ⊆ Y , then we know less of the possible results if we know X than if we know Y . Similarly, the fact that {⊥} lies ‘below’

∅ can be interpreted as saying that the former represents less definite information than the latter, that is: if we know that some computation potentially does not terminate, we know less of the possible results than if we know that nontermination is not possible.
The partial order ±full can be lifted to relations ρ ⊆ Z×Z⊥ by putting
ρ1 ±full ρ2	⇔	∀s∈Z: sρ1 ±full sρ2.
Then (2Z×Z⊥ , ±full ) is another complete lattice. In particular, ±full is reflexive, transitive, and antisymmetric. It is also a congruence with respect to ∩ and ∪, and moreover, ⬦ is monotonic with respect to ±full in its second argument. Equation
(1) is now specialised as follows:
Y	=  Z⊥
±˜	=  ±full
A˜(c) =  m˜ (c)	(known inductively)
☒  =  ⬦	(definition 4.4).
Let N˜ be defined as N˜ with this choice. N˜ is monotonic with respect to ⊆ and has
a unique minimal fixpoint. Let m˜ (p) be the least fixpoint of N˜ for p = DO , and



Proposition 4.6
m˜ (p) = m(p) for all programs p.

Powerdomain definitions of relational semantics
The purpose of this section is to recall Egli-Milner, Hoare and Smyth constructions for, respectively, m(p), m1(p) and m2(p). We focus on the loop
DO  =  do B → c od,
because this is where fixpoints come into play. Our aim is to define m(DO ), m1(DO ) and m2(DO ), such that they equal m(DO ), m1(DO ) and m2(DO ), respectively. We follow standard powerdomain theory in the sense that we now include ⊥ in the set of initial states, that is, we consider uniformly the set (‘flat domain’) Z⊥ as the ground set for both initial and final states. The constructions in this section differ (as usual in powerdomain theory) in terms of which subsets of this ground set (and which order on them) are taken as the basis for fixpoint constructions. The proofs of the claims in this section are well-known, or are easily derivable from well-known ones, and are therefore omitted.
Often, the standard denotational semantics of DO employs a functional fixpoint scheme [3,18], that is, a function mapping (partial) functions to functions. We reformulate this scheme in terms of relations, because that is what will make the considerations uniform with those of section 4. Moreover, in the standard theory of powerdomains, the relational composition that has been a parameter in the previous sections (variously called ☒, ◦, ∗, and ⬦) is uniformly the relational composition ◦.





(3)
Thus, we consider the following function N^ , where D, ±^ and A^(c) are parametric:
N^ : ⎧⎨ (D, ±^ ) → (D, ±^ )

⎩	ρ	'→ ( (¬B×Z) ∩ id Z) ∪ (B⊥×{⊥}) ∪ ((B×Z⊥) ∩ (A^(c)◦ρ) ) .
Here, ¬B is the set of states for which B evaluates to false, B⊥ is the set of states where B evaluates to ⊥ (which, by our assumption that evaluating B in a proper initial state does not lead to any error, equals {⊥}), and B is the set of states for which B evaluates to true.

Full relational semantics M (p) and the Egli-Milner ordering
Commonly, the semantics of DO is given as a function from Z⊥ to P0(Z⊥), where P0(Z⊥) is the set of all nonempty subsets of Z⊥ which are finite or contain ⊥ [16]. On P0(Z⊥), the Egli-Milner ordering, is defined as follows [1], for X, Y ∈P0(Z⊥):
(4)	X ±EM Y	⇔ (⊥/∈X ∧ X=Y ) ∨ (⊥∈X ∧ (X\{⊥})⊆Y ).
This yields a complete partial order (P0(Z⊥), ±EM ) with least element {⊥}.
For unbounded nondeterminism a generalisation along the lines of [12] may be incorporated. Let P (Z⊥) denote the set of all nonempty subsets of Z⊥ (without the restriction of being finite or containing ⊥). The ordering ±EM ⊆ P (Z⊥) × P (Z⊥) can be defined on this extended set by the same formula, (4). Let P (Z⊥×Z⊥) denote the set of all relations ρ∈2Z⊥×Z⊥ such that for all s∈Z⊥, sρ∈P (Z⊥). Clearly, this set is closed under relational composition. Moreover, ±EM may be extended as follows to P (Z⊥×Z⊥):
ρ1 ±EM ρ2	⇔	∀s∈Z⊥: sρ1 ±EM sρ2.
This is the relational analogue of extending ±EM to functions from Z⊥ to P (Z⊥), as in [3,18]. Let (3) be specialised by specifying D, ±^ and A^(c), as follows:
D	=  P (Z⊥×Z⊥)
±^	=  ±EM
A^(c) = M (c) (known by induction).
Let N^ denote N^ , with this choice. Then N^ is monotonic with respect to ±EM .
This follows from the monotonicity of ∩ and ∪ in both arguments, as well as the monotonicity of ◦ in its second (as well as its first) argument with respect to ±EM . Hence N has a unique minimal fixpoint. Define M (DO ) as this smallest fixpoint. Since M (DO ) ⊆ Z⊥×Z⊥ is not of the same type as m(DO ) ⊆ Z×Z⊥, let m(DO ) = M (DO )∩(Z×Z⊥). When p is not a loop, m(p) follows the same definition as for
m(p).
Lemma 5.1 Let p be any program. Then m(p) = m^ (p).
Note that M (DO ) and m^ (DO ) carry exactly the same information:  above,
m^ (DO ) has been derived from M (DO ); conversely, when m^ (DO ) ⊆ Z×Z⊥ is given,

M (DO ) can be derived as M (DO ) = m(DO )∪{(⊥, ⊥)}. In this sense, adding ⊥ to the set of initial states can be viewed (mathematically, cf. also section 3) as redundant.
There is a relationship between the orderings ±full in (2) and ±EM in (4). On the subset P (Z⊥) of 2Z⊥ , ±full generalises ±EM in the sense of satisfying ±EM ⊆ ±full .

Partial correctness semantics M1(p) and the Hoare ordering
Let Q(Z⊥) be defined as 2Z (without ⊥) and ±H ⊆ Q(Z⊥) × Q(Z⊥) as ordinary inclusion ⊆ on 2Z . Let Q(Z⊥×Z⊥) denote the set of relations ρ∈2Z⊥×Z⊥ such that for all s∈Z⊥, sρ∈Q(Z⊥). ±H may be extended to Q(Z⊥×Z⊥) by
ρ1 ±H ρ2	⇔	∀s∈Z⊥: sρ1 ±H sρ2.
Let (3) be specialised as follows:
D	=  Q(Z⊥×Z⊥)
±^	=  ±H
A^(c) = M1(c) (known by induction).
Let N 1 be N , with this choice. Then N 1 is clearly continuous (and hence mono- tonic) with respect to ⊆. Let M1(DO ) be the smallest fixpoint of N 1 with these parameters. Since M1(DO ) ⊆ Z⊥×Z⊥ is not of the same type as m1(DO ) ⊆ Z×Z, let m1(DO ) = M1(DO )∩(Z×Z). The other clauses of m1(p) follow the same defi- nition as for m' (p).
Lemma 5.2 Let p be any program. Then m1(p) = m1(p).
Again, M1(DO ) and m1(DO ) carry exactly the same information (as it turns out, they are actually equal).
Total correctness semantics M2(p) and the Smyth ordering
Finally, let R(Z⊥) be defined as (2Z \{∅})∪{Z⊥} and ±S ⊆ R(Z⊥) × R(Z⊥) as re- verse inclusion ⊇ on R(Z⊥). Let R(Z⊥×Z⊥) denote the set of all relations ρ∈2Z⊥×Z⊥ such that for all s∈Z⊥, sρ∈R(Z⊥). Again, this set is closed under relational com- position. ±S may be extended to R(Z⊥×Z⊥) by
ρ1 ±S ρ2	⇔	∀s∈Z⊥: sρ1 ±S sρ2.
Let equation (3) be specialised as follows:
D	=  R(Z⊥×Z⊥)
±^	=  ±S
A^(c) = M2(c) (known by induction).
Let N 2 be defined as N , with these definitions. Then N 2 is monotonic with respect to ±S. This follows from the monotonicity of ∩ and ∪ in both arguments, as well as the monotonicity of ◦ in its second (as well as its first) argument w.r.t. ±S. We

define M2(DO ) as the smallest fixpoint of N 2 with these parameters. Once more, M2(DO ) ⊆ Z⊥×Z⊥ is not of the same type as m2(DO ) ⊆ Z×Z. Therefore, let m ⊆ Z×Z be defined as follows: for s'∈Z,
⎧⎨ ∅	if s'M2 = Z⊥

s'm^2(DO ) =
⎩ s'M2	if s'M2 /= Z⊥.

The other clauses of m^2(p) follow the same definition as for m' (p).
Lemma 5.3  Let p be any program. Then m2(p) = m2(p).
Again, M2(DO ) and m2(DO ) carry exactly the same information: above, m2(DO ) has been derived from M2(DO ); conversely, when m2(DO ) ⊆ Z×Z⊥ is given,
M2(DO ) =	{(s', s) ∈ m2(DO ) | s'm2(DO ) /= ∅}
∪ {(s', s) ∈ Z⊥×Z⊥ | s'm2(DO ) = ∅}.
In all three cases, the full state space Z⊥ has been used both for initial and for final states. The ‘leaner’ relations, which do not allow ⊥ to be an initial state, have been derived a posteriori. The derivation has been particularly noticeable in the case of m2, where the ‘chaotic’ interpretation of failure (yielding Z⊥ as set of final states), as described by M2, was trimmed down to the ‘operational’ interpretation of failure, as described by m2 (yielding ∅ as set of final states). When sections 4.2 and 5.3 are compared, it appears that denotational semantics can be given both for the chaotic interpretation of failure induced by the Smyth ordering and for the non-chaotic interpretation of failure induced by the notion of demonic composition. The Smyth fixpoint described above uses a least fixpoint on reverse subset ordering (or, equivalently, a maximal fixpoint on ordinary ordering) while the construction described in section 4.2 uses a least fixpoint on ordinary ordering, and yet they are equally expressive, because the distinction in terms of their orderings is neutralised by the distinction in terms of their relational composition operations.

Conclusion
In sections 4.1 and 4.2, it was shown how the relational correspondents of Hoare’s (original) proof rules for partial correctness semantics and Dijkstra’s wp function for total correctness semantics can be defined denotationally without needing to introduce the ⊥ state or using powerset constructions other than provided by set theory. The former should hardly be surprising, since the traditional Hoare ordering is the same as subset ordering (cf. section 5.2). The latter (and the concomitant result, proposition 4.3) came as slightly more of a surprise, since total correctness semantics is frequently thought to be intimately linked to the Smyth ordering, which does use the ⊥ state (section 5.3). For full relational semantics (section 4.3 and proposition 4.6), we have used a double generalisation of the original Egli-Milner ordering. A first generalisation (as also discussed in [12]) allows for infinite state sets not containing the ⊥ element and thus encompasses unbounded nondeterminism. A second generalisation uses a product of two lattices.

Since ±full is a mixture of subset and superset orderings, reduction to pure set theory has not completely been achieved for full semantics. However, consider re- placing the ⊥ symbol by T, indicating ‘certain termination’ and yielding a semantic relation mtop(p) ⊆ Z × ZT for programs p, with ZT = (Z ∪• {T}), such that, for instance:
mtop(skip)	= {(s', s') | s' ∈ Z}∪ {(s', T) | s' ∈ Z}
mtop(skip or abort) = {(s', s') | s' ∈ Z}
mtop(abort)	= ∅.
Going through the motions of section 4.3 and all previous sections with T rather
than ⊥, will quite likely lead to a lattice (2ZT , ±'	) which is isomorphic to the
lattice product (2Z, ⊆) ⊗ (2{T}, ⊆) rather than (2Z, ⊆) ⊗ (2{⊥}, ⊇), and thus also to
the lattice (2ZT , ⊆), yielding, by ±'	=⊆, a more complete reduction to set theory.
While Hesselink has shown in [12] that the Egli-Milner ordering can be gen- eralised in order to encompass infinite nondeterminism, it is not discussed there whether or not ⊥ can be avoided as an initial state. Discussions about eschewing
⊥ are contained in [4] (pages 128 ff.) and in [10]. In [10], Doornbos has argued
that ⊥ can be avoided in special cases, but no operational or other general formal justifications have been given.
The demonic composition ∗ has been defined previously: e.g., implicitly in [5] and explicitly in [15]. In [5,11], moreover, ‘functionals’ such as N 1 and N 2 have been used. In [14], a pairing construction is used to capture total/partial correctness semantics.
In [8], we find a relational definition of the loop employing the ∗ operator, which, we believe, is not the best choice. Instead of set theoretic ones, this definition uses various demonic versions of set-theoretic operators in order to construct a domain
in which a maximal fixpoint can be used.  This may lead to complications.  For
instance, the very involved calculation of the maximal fixpoint of the example given on page 175 of [8] may be compared with the function N 2, coming from the present paper (which is actually continuous, although we have neither proved nor used this fact in this paper). When applied to the same example, N 2 yields stability of approximation after only two steps from the empty relation as starting point, using a much easier calculation. Nevertheless, it might be possible and interesting to conduct a study similar to the one in the present paper, using the union and intersection operators as parameters.
The semantics given in this paper suggests an approximation relation between nondeterministic programs, which in terms of (partial or total) correctness formulae, is antimonotonic. That is, if c1 approximates c2, then the set of valid (partial or
total) correctness formulae pertaining to c2 is a subset of those pertaining to c1.
This holds in all cases, as opposed to the usual Smyth ordering, where the set of valid total correctness formulae pertaining to c1 is a subset of those pertaining to c2, provided c1 approximates c2 (i.e., the logical characterisation is monotonic).
In future work, we propose to investigate the following two questions. First,

the generalised Egli-Milner ordering (2) of section 4.3 may appear to be rather un- derived. We would like to actually derive it, that is, show that there are no good alternatives. Second, we would like to strengthen the above remark about partial or total correctness formulae by showing – if possible – that the set of such formulae actually characterise the corresponding relational semantics.

Acknowledgement
This paper has benefitted from discussions with Jaco W. de Bakker, Rudolf Bergham- mer, Wim H. Hesselink and Burghard von Karger, to whom the observation that (2) corresponds to a lattice product is due. We would also like to thank the anonymous reviewers and non-anonymous participants of SOS’2008, in particular Bartek Klin, Matthew Hennessy and Peter Mosses, for comments.

References
J.W. de Bakker: Recursive Programs as Predicate Transformers. Proc. Working Conference on Formal Description of Programming Concepts, IFIP, North Holland, Erich Neuhold (ed.), 15 pages (1977).
J.W. de Bakker: Mathematical Theory of Program Correctness. Prentice Hall (1980).
R. Berghammer: Semantik von Programmiersprachen. Lecture Notes, Universit¨at Kiel (1996/97).
R. Berghammer, B. v. Karger: Relational Semantics of Functional Programs. Chapter 8, pages 115–130, of [7].
R. Berghammer, H. Zierer: Relational Algebraic Semantics of Deterministic and Nondeterministic Programs. Theoretical Computer Science 43, 123–147 (1986).
E. Best: Semantics of Sequential and Parallel Programs. Prentice Hall (1996).
C. Brink, W. Kahl, G. Schmidt (eds): Relational Methods in Computer Science. Advances in Computing Science, Springer-Verlag (Wien, New York) (1996).
J. Desharnais, A. Mili, T.T. Nguyen: Refinement and Demonic Semantics. Chapter 11, pages 166–183, of [7].
E.W. Dijkstra: A Discipline of Programming. Prentice Hall (1976).
H. Doornbos: A Relational Model of Programs Without the Restriction to Egli-Milner Monotone Constructs. Proc. ProCoMet’94 (E.R. Olderog, ed.). IFIP Transactions A-56, 363–382, North Holland (1994).
Th.F. Gritzner, R. Berghammer: A Relation Algebraic Model of Robust Correctness. Theoretical Computer Science 159, 245–270 (1996).
W.H. Hesselink: Interpretations of Recursion under Unbounded Nondeterminacy. Theoretical Computer Science 59, 211—234 (1988).
C.A.R. Hoare: An Axiomatic Basis for Computer Programming. Communications of the ACM 12, 576–580 (1969).
R. Maddux: Relation-algebraic Semantics. Theoretical Computer Science 160, 1—85 (1996).
T.T. Nguyen: A Relational Model of Demonic Nondeterministic Programs. Intern. J. Found. of Comp. Sci. 2, 101–131 (1991).
G.D. Plotkin: A Powerdomain Construction. SIAM J. Comp. 5, 452–486 (1967).

K.M. Richter: Denotationale Formulierungen fu¨r relationale Semantiken. Diplomarbeit, Universit¨at Hildesheim (1998).
D. Schmidt: Denotational Semantics: a Methodology for Language Development. Allyn and Bacon (1986).
G. Winskel: The Formal Semantics of Programming Languages. Foundations of Computing. The MIT Press, Cambridge, Massachusetts (1993).

A	Some proofs
Proof of lemma 3.1: This follows directly by comparing the clauses in the defi-
nition of m' with the corresponding clauses in the definition of m, keeping in mind
that m1 = m∩(Z×Z).	 
Proof of lemma 3.2: This follows directly, except for the loop, for which we may use the following six implications, the first three of which are true because every valid m2-sequence is also a valid m-sequence: (A2) implies (A); (B) implies (B2);
(C) implies (C2); (A)∧(B) implies (A2); (B2) implies (B); and finally, (B2)∧(C2) implies (C). (Note that the r in (B) is the r−1 in (B2).)	 
Proof of Proposition 4.1: Along the same lines as the proof of proposition 4.3, cf. [17].	 
Proof that ∗ is associative, i.e., satisfies (ρ ∗ τ ) ∗ σ = ρ ∗ (τ ∗ σ): By definition 4.2, (a, b) ∈ (ρ ∗ τ ) ∗ σ can be rewritten as follows:
[ ∃d : [(∃c: (a, c)∈ρ∧(c, d)∈τ ) ∧ (∀c': (a, c')∈ρ ⇒ ∃d': (c', d')∈τ )] ∧ (d, b)∈σ ]

`(˛1¸1)x `
(1˛1¸1)	x	`
(1˛1¸2)
x	` (1˛1¸3) x


∧ [ ∀d'' : [(∃c'': (a, c'')∈ρ∧(c'', d'')∈τ ) ∧ (∀c''': (a, c''')∈ρ ⇒ ∃d''': (c''', d''')∈τ )]

`(˛1¸2)x `
(1˛2¸1)	x	`
(1˛2¸2)	x

⇒  ∃b': (d'', b')∈σ ].
`	(1˛2¸3)	x
By the same definition, (a, b) ∈ ρ ∗ (τ ∗ σ) becomes:
[ ∃c : [(a, c)∈ρ ∧ (∃d: (c, d)∈τ ∧(d, b)∈σ) ∧ (∀d': (c, d')∈τ ⇒ ∃b'': (d', b'')∈σ)] ] 

`(˛2¸1)x
` (2˛1¸1) x	`
(2˛1¸2)	x	`
(2˛1¸3)	x


∧ [ ∀c' : (a, c')∈ρ  ⇒

`(˛2¸2)x `
(2˛2¸1) x

( ∃b': [∃d'': (c', d'')∈τ ∧(d'', b')∈σ] ∧[∀d''': (c', d''')∈τ ⇒ ∃ b''': (d''', b''')∈σ]) ].

`	(2˛2¸2)
x	`(2˛2¸3x) `
(2˛23¸1) x
`	(2˛23¸2)	x

We prove that the first formula implies the second. To verify (21), take the c that exists by (111). It satisfies (211) by the first part of (111). It satisfies (212) by
(111) and (113), taking the d that exists by (11). It also satisfies (213). To see this, consider any d' with (c, d')∈τ . Then (121) is satisfies with d' for d'' and c for c'';

also, (122) is satisfied because of (112). The conclusion (123) yields the conclusion of (213). To verify (22), consider any c' with (a, c')∈ρ. From (112), there is a d with (c', d)∈τ . From (12), with d for d'', there is a b with (d, b)∈σ. To satisfy (22), take b for b'. Then (222) is satisfied by d for d'', and (223) is satisfied because if d''' satisfies (2231), the existence of a b''' satisfying (2232) follows from (123).
Next, we prove the converse, viz. that the second formula implies the first. To verify (11), we may take c and d as in (21) and (212). This satisfies (111), (112) (using (221)) and (113) (using 212). To verify (12), consider any d'' with (121) and
(122). The c'' that exists by (121) satisfies (221) (by c'' for c'), and hence there is a b' with ((222) and) (223). The chosen d'' satisfies (2231), hence (2232), which implies (123).	 
Proof that ∗ is monotonic in the second argument: If τ1⊆τ2 then σ◦τ1⊆σ◦τ2
and dom(τ1)⊆dom(τ2). The claim follows.	 
Proof of proposition 4.3: By induction on program p. We restrict ourselves to the loop DO = do B → c od, because that is the most involved case. On the one hand, we have the operational semantics m(DO ), from which we get m2(DO ), and on the other hand, we have the fixpoint semantics m2(DO ). Since ((s', s)∈m(DO )∧⊥∈/s'm(DO )) ⇔ (s', s)∈m2(DO ), we may use, for the former, lines (A)–(C) in the definition of m(DO ), cf. section 3.1, and for the latter, lines (A2)– (C2) in the definition of m' (DO ), cf. section 3.4.
Let the notion of a valid m2-sequence (in what follows abbreviated by m2vseq) be defined as that of a valid m2-sequence, except that m2 is replaced by m2. Moreover, let the set of states which start an infinite m˜2-execution be defined as follows:
INF (DO ) = {s'∈Z | ∃ infinite m˜2vseq s0, s1,... : s'=s0}.
For the proof of m2(DO ) = m2(DO ), we may assume, as an inductive step, that m2(c) = m2(c). Therefore, the notions of an m2-sequence and an m2-sequence coincide, and INF (DO ) is the same set, independently of whether m2-sequences or m2-sequences are considered.	 
Proof of m2(DO ) ⊆ m2(DO ): Assume that (s', s)∈m2(DO ). We prove (s', s)∈m2(DO ) by verifying (C2), (A2) and (B2), in that order, and using Lemma 3.2(⇐).
(C2): s' ∈/ INF (DO ).
Proof: By contradiction.  We assume that s'∈INF (DO ) and define m2'(DO ) = 
m2(DO )\(INF (DO )×Z). We show that m2'(DO ) (which is strictly contained in m2(DO ) by (s', s) ∈ (m2(DO )∩(INF (DO )×Z))) is also a fixpoint of N 2, contra- dicting the fact that m2(DO ) was defined as the smallest one. To this end, we show the two directions of m2'(DO ) = N 2(m2'(DO )) separately:
(⊆:) Assume (t', t)∈m2'(DO ). We intend to show (t', t)∈N 2(m2'(DO )). By defini- tion of m2'(DO ), (t', t)∈m2(DO ) ∧ t'∈/INF (DO ). Because m2(DO ) is a fixpoint, we also have (t', t)∈N 2(m2(DO )) (we use part m2(DO )⊆N 2(m2(DO )) of the fixpoint equation). By definition of N˜2, there are two cases.
Case 1: ¬B(t') ∧ t'=t. Then, by definition of N˜2, (t', t)∈N˜2(m˜2'(DO )).

Case 2: B(t') ∧ (t', t)∈(m˜2(c)∗m˜2(DO )), i.e.,
(A.1)	B(t') ∧ (t', t)∈(m˜2(c)◦m˜2(DO )) ∧ t'm˜2(c)⊆dom(m˜2(DO )).
By the second conjunct, there is a state u with (t', u)∈m2(c) and (u, t)∈m2(DO ). If u∈INF (DO ) then also t'∈INF (DO ), because any infinite sequence starting with u could be prefixed by t'. However, this contradicts a prior assumption, so that u∈/INF (DO ). Hence (u, t)∈m2'(DO ). Also, using the third conjunct of (A.1), t'm2(c) ⊆ dom(m2'(DO )) since dom(m2'(DO )) = dom(m2(DO ))\INF (DO ), and because v∈t'm2(c) implies, as before, v∈/INF (DO ). Hence, using also the first con- junct of (A.1), B(t') ∧ (t', t)∈(m˜2(c)∗m˜2'(DO )), and hence, by the definition of N˜2,

(⊇:) Assume (t', t)∈N 2(m2'(DO )). We intend to show (t', t)∈m2'(DO ). By the definition of N˜2, we have two cases:
Case 1: ¬B(t') ∧ t'=t. Then, by the definition of m2, (t', t)∈m2(DO ). By ¬B(t'), no infinite m2vseq can start at t'. Hence t'∈/INF (DO ), and hence, by definition of m˜2', (t', t)∈m˜2'(DO ).
Case 2: B(t') ∧ (t', t)∈(m˜2(c)∗m˜2'(DO )), i.e.,
'	'
(A.2) B(t') ∧ (t', t)∈(m˜2(c)◦m˜2 (DO )) ∧ t m˜2(c)⊆(dom(m˜2(DO ))\INF (DO )),
using also dom(m2'(DO )) = dom(m2(DO ))\INF (DO ).
First, we prove that (t', t)∈m2(DO ). By the monotonicity of ∗ in its second argu- ment, m2(c)∗m2'(DO ) ⊆ m2(c)∗m2(DO ), whence, by the second conjunct of (A.2), (t', t)∈(m2(c)∗m2(DO )). From this, B(t'), and the definition of N 2, it follows that (t', t)∈N 2(m2(DO )), and hence, since m2(DO ) is a fixpoint of N 2, (t', t)∈m2(DO ) (using direction m2(DO )⊇N 2(m2(DO )) of the fixpoint equation). Secondly, we prove that t'∈/INF (DO ). For, suppose that t'∈INF (DO ). Then there is t with (t', t)∈m2(c) and t∈INF (DO ), contradicting the third conjunct of (A.2). Hence (t', t)∈m2'(DO ), which was to be shown.
Thus we have proved that, under the assumption that s'∈INF (DO ), we can find a fixpoint of N 2 which is strictly contained in m2(DO ), in contradiction to the definition of m2(DO ). This proves that s'∈/INF (DO ).
(A2): There is an m2vseq (and hence a valid m2-sequence) s0,..., sr with s'=s0, sr=s and ¬B(sr). (In particular, it follows that ¬B(s).)
Proof: We construct a valid m2-sequence starting with s', which cannot be in- finite because, by the above, s'∈/INF (DO ). Initially, put s'=s0. Then we use (s0, s)∈m2(DO )⊆N˜2(m2(DO )). Again there are two cases.
Case 1: ¬B(s0) ∧ s0=s. Then we may put r=0 to obtain the desired sequence. Case 2: B(s0) ∧ (s0, s)∈(m2(c)∗m2(DO )), i.e.
B(s0) ∧ (s0, s)∈(m2(c)◦m2(DO )) ∧ s0m2(c)⊆dom(m2(DO )).
Using the second conjunct, choose s1 with (s0, s1)∈m2(c) and (s1, s)∈m2(DO ). Us- ing m˜2(DO )⊆N˜2(m˜2(DO )), there are again two cases to be considered for s1. Be-

cause, by (C2), s' is not in INF (DO ), this construction will eventually stop with a desired sequence (validity follows from the construction and the fact that B(sj) holds of all states except the last one).
(B2): There is no m2vseq (and hence no valid m2-sequence) s0,..., sr with s'=s0, B(sr) and srm2(c)=∅.
Proof: Consider any arbitrary valid m2-sequence s0,..., sr with s'=s0 and B(sr). We shall prove that srm2(c)/=∅. By induction on j, we prove that
∀j, 0≤j≤r: sjm2(c)⊆dom(m2(DO )).
Base j=0: We know that (s0, s)∈m2(DO )=N 2(m2(DO )). By B(s0), this implies (s0, s)∈(m2(c)∗m2(DO )), and by the definition of ∗, s0m2(c)⊆dom(m2(DO )) as desired.
Step j→j+1 (j<r): By the induction hypothesis, sjm2(c)⊆dom(m2(DO )). Since (sj, sj+1)∈m2(c), this implies sj+1∈dom(m2(DO )). That is, there is some u such that (sj+1, u)∈m2(DO ). By B(sj+1), we conclude (similarly as in the base case) that (sj+1, u)∈(m2(c)∗m2(DO )) and sj+1m2(c)⊆dom(m2(DO )).
Take j=r. Then the above yields srm2(c)⊆dom(m2(DO )), i.e. there is some v with (sr, v)∈m2(DO ). By the previously shown result, i.e. (A2), there is a valid m2-sequence leading from sr to v, and, in particular, ¬B(v). Hence, by B(sr), this sequence must be of length at least 1 (where the length of a sequence s0,..., sr is defined as r), leading to srm2(c)/=∅, which was to be proved.
Thus far, we have proved (A2), (B2) and (C2) for the pair (s', s)∈m2(DO ).
Together with Lemma 3.2(⇐), it follows that (s', s)∈m2(DO ).
Proof of m2(DO ) ⊇ m2(DO ): Now assume that (s', s)∈m2(DO ). We shall prove that (s', s)∈m2(DO ). By Lemma 3.2(⇒), all of (A2), (B2) and (C2) are true and may be used in the proof. We will use a standard tree construction (e.g., [2]). We will consider trees whose nodes are labelled by states in Z. The same state may occur twice or more as a label of such a tree, but the children of a given node will always be labelled by mutually different states. More precisely, starting from s', we construct (i.e. define inductively) the following tree, called the s'-tree: 2
The root of the s'-tree is a node labelled by s'.
If k is a node of the s'-tree labelled by a state t, then the set of children (i.e. direct successors) of k is a set of nodes which is in 1–1 correspondence with the set {t'∈Z | B(t) ∧ (t, t')∈m2(c)} and carries the states from this set as labels.
As a consequence of this definition, the leaves of the s'-tree are the set of nodes k for whose labels t we have ¬B(t) ∨ tm2(c)=∅. Property (B2) implies that the states t at the leaves of the s'-tree – and, by the definition of the tree, only those – satisfy ¬B(t). Property (A2) implies that s actually occurs as a label of one of the leaves of the tree. Property (C2) implies that the s'-tree has no infinite paths (however, the s'-tree could still be infinite, or even have no upper bound for the

2 It is unique up to isomorphism.

lengths of paths). It also has another pleasant property: from each node there is at least one finite path to some leaf (the length of a path is defined as the number of nodes on it, minus 1). This follows immediately from the absence of infinite paths: a node is either already a leaf (in which case a path of length 0 leads from it to itself), or a path can be constructed by successively following through children and children’s children, a construction which must stop eventually because there is no infinite path.
We will now show (s', s)∈m2(DO ) by proving two claims, (Ca) and (Cb), simul- taneously. Let k be any node on the s'-tree and let t be its label. Then,
(Ca) if B(t) then tm2(c) ⊆ dom(m2(DO ));
(Cb) if x is a leaf with label u and a path leads from k to x, then (t, u)∈m2(DO ).
We prove (Ca) and (Cb) by induction on the smallest length, l, of a path from k to a leaf; this number is well-defined because at least one such path exists.
Base l=0: Then k is itself a leaf. Then, for the label t of k, we have ¬B(t), which implies that (Ca) is satisfied for k and t. Moreover, by definition of N 2, (t, t)∈N 2(m2(DO )) by the fact that (t, t)∈((¬B×Z)∩id Z). By the fixpoint equa- tion, (t, t)∈m2(DO ). Hence (Cb) is also satisfied, since the path from k to k (of length 0) is the only one to be considered.
Step l→l+1: Let k be a node with label t, whose smallest distance to a root is l+1. Then B(t), since k is not a leaf. Let k' be any child of k and t' its label; then and only then, by definition of the tree, t'∈tm2(c). We will prove t'∈dom(m2(DO )). Consider any path from k' to some leaf x with label u. By (Cb) for k' and t' (which is true by the induction hypothesis), (t', u)∈m2(DO ). Hence t'∈dom(m2(DO )), which proves (Ca) for k and t. To prove (Cb) for k and t, consider any path from t to some leaf y with label v and let k'' with label t'' be the child of k on that path (such a child exists by the fact that k is not a leaf, and it is unique by the general properties of trees). For k'' and t'', the induction hypothesis applies again, and hence (t'', v)∈m2(DO ) by (Cb). By the definition of ∗ and by the already proved property (Ca) for t, we have (t, v)∈(m2(c)∗m2(DO )), hence (t, v)∈(m2(c)∗m2(DO )) by the general induction hypothesis that m2(c)=m2(c). Adding to this the fact that B(t), we have (t, v)∈N 2(m2(DO )) and (t, v)∈m2(DO ) by the fixpoint equation, part (⊇).
The above may be applied to the root with label s' and a particular leaf with label s (such a leaf exists by (s', s)∈m2(DO ) and (A2)) of the s'-tree. Then (Cb) yields (s', s)∈m2(DO ), which was to be proved.	 
Proof of Lemma 4.5: It is easy to check that (2Z⊥ , ±) is isomorphic to the direct lattice product between (2Z, ⊆) and (2{⊥}, ⊇) (reverse ordering for the latter lattice). Such products inherit all the nice properties from their components. 
More precisely, let {Xj | j∈J } be any set of subsets of 2Z⊥ (with index set J ).
Then

H X = ⎧⎨  (Xj∪{⊥}) if ∃Xj: ⊥∈Xj

and H X
= ⎧⎨  (Xj\{⊥}) if ∃Xj: ⊥∈/Xj

j	⎩  X
if ∀X : ⊥∈/X
j	⎩  X
if ∀X : ⊥∈X

are the greatest lower and least upper bounds, respectively, of {Xj | j∈J }.
Proof of the properties of ±: Because ± is the ordering of the direct product of two lattices enjoying these properties, they are bequeathed upon ±.
Proof that ⬦ is monotonic with respect to ± in its second argument:
Let μ, ρ1, ρ2 be relations ⊆ Z×Z⊥ with ρ1 ± ρ2. We show (μ ⬦ ρ1) ± (μ ⬦ ρ2) by proving that for arbitrary a∈Z, a(μ ⬦ ρ1) ± a(μ ⬦ ρ2). More precisely, we need to show that (1): a(μ ⬦ ρ1)\{⊥} ⊆ a(μ ⬦ ρ2), and (2): ⊥∈a(μ ⬦ ρ1) ∨ ⊥∈/a(μ ⬦ ρ2).
Ad (1): b ∈ a(μ ⬦ ρ1)\{⊥} ⇒ (definition of ⬦)  b ∈ a(μ ◦ ρ1)\{⊥}
⇒ (definition of ◦)  ∃x: x ∈ aμ ∧ b ∈ xρ1\{⊥}
⇒ (ρ1 ± ρ2)	x ∈ aμ ∧ ∃x: b ∈ xρ2\{⊥}
⇒ (definition of ◦)  b ∈ a(μ ◦ ρ2)\{⊥}
⇒ (definition of ⬦)  b ∈ a(μ ⬦ ρ2)\{⊥}.

Ad (2): ⊥ ∈ a(μ ⬦ ρ2) ⇒ (definition of ⬦) (a, ⊥)∈μ ∨ ∃x: (a, x)∈μ ∧ (x, ⊥)∈ρ2
⇒ (ρ1 ± ρ2) (a, ⊥)∈μ ∨ ∃x: (a, x)∈μ ∧ (x, ⊥)∈ρ2 ∧ (x, ⊥)∈ρ1
⇒ (definition of ◦) (a, ⊥)∈μ ∨ (a, ⊥)∈μ ◦ ρ1
⇒ (definition of ⬦ and μ ◦ ρ1 ⊆ μ ⬦ ρ1) ⊥ ∈ a(μ ⬦ ρ2).
Proof of Proposition 4.6: We only need to prove m(DO ) = m(DO ) for DO =
do B → c od, assuming as an induction hypothesis that m(c) = m(c).
Proof of m(DO ) ± m(DO ): The smallest fixpoint of N can be expressed as follows:
m(DO ) = Η{ρ | N (ρ) ± ρ}.
Hence m(DO ) is below (in the sense of ±) every element of the set {ρ | N (ρ) ± ρ}. Therefore, in order to prove the claim, it suffices to show that m(DO ) is a member of this set. Thus, we will show N˜(m(DO )) ± m(DO ), and more precisely:
∀s'∈Z: (s'N˜(m(DO ))\{⊥} ⊆ s'm(DO )) ∧ (⊥∈s'N˜(m(DO ))∨⊥∈/s'm(DO )) .

 	
(1)
`	 ˛¸	x


Ad (1): Let s ∈ s'N (m(DO )\{⊥}. By the definition of N , either ¬B(s') or B(s') ∧
(s', s) ∈ m ⬦ m(DO ).
In the first case, clearly, s ∈ s'm(DO ), since a valid m-sequence (of length 0) leads from s' to s, and hence (A) of the definition of m(DO ) holds true.
In the second case, s/=⊥ implies that B(s') ∧(s', s) ∈ m ◦ m(DO ). The induction hypothesis m(c) = m(c) then further implies that there is some t ∈ Z with
B(s') ∧ (s', t) ∈ m(c) ∧ (t, s) ∈ m(DO ).
(t, s) ∈ m(DO ) implies (A), (B) or (C) for the pair (t, s), and no matter which one of these is the case, it will remain the case for (s', s) because of B(s') ∧(s', t) ∈ m(c).

Hence (s', s) ∈ m(DO ), and (1) is proved.
Ad (2): Assume that ⊥ ∈ s'm(DO ). We prove that ⊥ ∈ s'N (m(DO )). By (s', ⊥) ∈ m(DO ) and the definition of m(DO ), we have either (B) or (C) for the pair (s', ⊥). In the first case, there is a sequence of states s0, s1,..., sr with r≥1, s'=s0, sr=⊥ and B(sj) ∧ (sj, sj+1)∈m(c) for all 0≤j<r. If r=1 and s1=⊥, the definition of ⬦ yields (s', ⊥) ∈ m(c) ⬦ m(DO ), and hence (taking into account B(s') and the induction hypothesis m(c) = m(c)) also (s', ⊥) ∈ N (m(DO )). If r>1, then by (B) applied to the pair (s1, ⊥), (s1, ⊥) ∈ m(DO ); hence the definition of ⬦ (together with (s', s1∈m(c)) yields again that (s', ⊥) ∈ m(c) ⬦ m(DO ), and together with
B(s') and the induction hypothesis we have (s', ⊥) ∈ N˜(m(DO )).  In all cases,
⊥ ∈ s'N˜(m(DO )), which proves (2). This ends the proof of m˜ (DO ) ± m(DO ). 3
Proof of m˜ (DO ) ± m(DO ): We need to show:


 	
(1)
`	 ˛¸	x


Ad (1): Let s ∈ s'm(DO )\{⊥}. Then (A) holds for the pair (s', s). That is, there is a valid m-sequence s0, s1,..., sr with s'=s0, sr=s and B(sj) ∧ (sj, sj+1)∈m(c) for all 0≤j<r. If r=0, then clearly (s', s) ∈ m(DO ) because of the first disjunct in the definition of N . If r>0, then B(s') and (s1, s) ∈ m(DO ), and again (s', s) ∈ m(DO ) because of the second disjunct of the definition of N (and the induction hypothesis m(c) = m(c)). In all cases, s ∈ s'm(DO ), which proves (1).
Ad (2): Assume ⊥ ∈ s'm(DO ). We prove ⊥ ∈ s'm(DO ). Using ⊥ ∈ s'm(DO ), the fixpoint equation m(DO ) = N (m(DO )) and the definition of ⬦, we may construct s0, s1,... starting with s'=s0. If we ever get to the second disjunct of ⬦, then we will have (B) and thus (s', ⊥) ∈ m(DO ). Otherwise, the construction continues indefinitely and then we have (C) and hence, again, (s', ⊥) ∈ m(DO ). In both cases, ⊥ ∈ s'm(DO ), which proves (2). This ends the proof of m(DO ) ± m(DO ).
The main result now follows from the antisymmetry of ±.	 















3 One may be tempted to use the same idea in order to simplify the first part of the proof of proposition
4.3. However, this does not seem to work as nicely as it does here.
