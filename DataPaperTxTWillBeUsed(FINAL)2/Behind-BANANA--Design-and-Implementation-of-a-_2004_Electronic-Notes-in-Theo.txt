 Electronic Notes in Theoretical Computer Science 99 (2004) 319–337 
www.elsevier.com/locate/entcs




Behind BANANA:
Design and Implementation of a Tool for Nesting Analysis of Mobile Ambients*
C. Braghina,1 , A. Cortesia,2 , R. Focardia,3 , F. L. Lucciob,4 , and C. Piazzaa,5
a Dipartimento di Informatica, Universita` Ca’ Foscari di Venezia
b Dipartimento di Scienze Matematiche, Universita` di Trieste

Abstract
We present a survey of the work on control-flow analysis carried on by the Venice Team during the Mefisto project. We study security issues, in particular information leakage detection, in the context of the Mobile Ambient calculus. We describe BANANA, a Java-based tool for ambient nesting analysis, by focussing on analysis accuracy and algorithmic optimizations.
Keywords: Static Analysis, Ambient Calculus, Security.


Introduction
In recent years networks have become an essential aspect of our daily comput- ing environment. In such a framework, mobility may be supported in different

 Partially supported by the MIUR Project “Modelli formali per la sicurezza”, the EU Con- tract IST-2001-32617 “MyThS”, and the FIRB project (RBAU018RCZ) “Interpretazione astratta e model checking per la verifica di sistemi embedded”.
1 Email:braghin@dsi.unive.it
2 Email:cortesi@dsi.unive.it
3 Email:focardi@dsi.unive.it
4 Email:luccio@dsm.univ.trieste.it
5 Email:piazza@dsi.unive.it


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.014

forms: physical, e.g., laptops, personal organizers moving around, smart cards entering a network computer slot, and logical, e.g., code or agent mobility.
The main scientific and technological challenge in this setting is to provide security to applications which operate in untrusted and possibly unknown en- vironments. Indeed, distributed applications rely on network communications thus, apart from being potential victims of computer viruses, they can be tam- pered and eavesdropped in many ways, and for this reason they are vulnerable and insecure. In general, mobile code and communication may need to cross administrative domains and firewalls, and untrusted sites as well. Techniques such as cryptography may solve some problems related to data communica- tion, but, when executable code is exchanged, such techniques may not be sufficient anymore. Much research effort has been devoted to protect servers from untrusted and potentially malicious mobile code. On the converse, mo- bile code must be protected from potentially malicious servers that may try to disclose or modify its sensible private data.
These security issues constitute a very interesting workbench to evaluate the theoretical and practical impact of static analysis techniques. Giving a way for statically verifying a security property has, in principle, the advantage of making the checking of the properties more efficient; moreover it allows us to write programs which are secure-by-construction, e.g., when the performed analysis is proved to imply some behavioural security properties. A substan- tial body of research is available, relying on different static techniques and modeling languages, verifying different security properties [3,14,16,25].
In this paper we present a survey of the work on control-flow analysis carried on by the Venice Team during the Mefisto project. The goal was twofold: on one side, to tackle information flow security of mobile code with control flow analysis techniques, on the other side, to optimize time and space complexities of our and existing approaches.
Our approach is based on the calculus of Mobile Ambients (MA), pro- posed by Cardelli and Gordon [11], where the notion of ambient captures the structure and properties of wide area networks, of mobile computing, and of mobile computation. An ambient is an abstraction of the notion of both agent and location. Like an agent, an ambient may move around by exploiting its capabilities. Furthermore, ambients can be arbitrarily nested, forming a tree structure that models the hierarchical organization of administrative domains. In order to study this problem in an abstract manner, we consider the “pure” Mobile Ambients calculus, with no communication channel and where the only possible actions are represented by the moves performed by mobile processes. In this way, we may study a very general notion of information flow which, in our opinion, should be applicable also to more “concrete” versions of the

calculus [9,17].
Our focus is on Multilevel Security, a particular Mandatory Access Con- trol security policy: every entity is bound to a security level (for simplicity, we consider only two levels: high and low), and information may only flow from the low level to the high one. Typically, two access rules are imposed:
(i) No Read Up, a low level entity cannot access information of a high level entity; (ii)No Write Down, a high level entity cannot leak information to a low level entity. In order to detect information leakages, a typical approach (see, e.g., [1,2]) consists of directly defining how information may flow from one level to another one. Then, it is sufficient to verify if, in any system exe- cution, no flow of information is possible from level high to level low. We have followed the above approach.
The starting point of our research was the Control Flow Analysis by Niel- son et al. presented in [15]. In [7], we refined such an analysis in order to detect information leakage. Both analyses have been implemented in the Banana(Boundary Ambient Nesting ANAlysis) tool [4], a Java applet avail-
able at http://www.dsi.unive.it/∼mefisto/BANANA/. This survey will describe both the technical details of the analyses implemented in the tool, and the imple- mentation issues behind Banana.
The rest of the paper is organized as follows. In Section 2 we introduce the basic terminology of Mobile Ambient calculus and we briefly report the control flow analyses of [15,20] and of [6,7]. Then, in Section 3, we present the algorithms implemented in the Banana tool, which is described in detail in Section 4. Section 5 concludes the paper.

Information Flow in Mobile Ambients
In this section we first introduce the basic terminology of Mobile Ambient calculus, then we briefly report the Control Flow Analysis of [15,20] and its refinement proposed in [6,7].
Mobile Ambients
The Mobile Ambient calculus has been introduced in [10,11] with the main purpose of explicitly modeling mobility. Indeed, ambients are arbitrarily nested boundaries which can move around through suitable capabilities. The syntax of processes is given as follows, where n ∈ Amb denotes an ambient name.
Intuitively, the restriction (νn)P introduces the new name n and limits its scope to P ; process 0 does nothing; P | Q is P and Q running in parallel; replication provides recursion and iteration as !P represents any number of


Fig. 1. Mobile Ambients Syntax


copies of P in parallel. By

nla
[ P ]
we denote the ambient named n with

t	t
the process P running inside it. The capabilities inl n and outl n move their

enclosing ambients in and out ambient n, respectively; the capability
openlt n

is used to dissolve the boundary of a sibling ambient n. The operational semantics of a process P is given through a suitable reduction relation → between processes. Intuitively, P → Q represents the possibility for P of reducing to Q through some computation. (See [10] for more details.) We will use the standard notation P →∗ Q to denote a reduction of process P to
process Q performed in 0 or more steps.
Labels la ∈ Laba on ambients and labels lt ∈ Labt on capabilities (transi- tions) are introduced as it is customary in static analysis to indicate “program points”. We denote with Lab the set of all the labels Laba ∪ Labt. We use the special label env ∈ Laba to denote the external environment, i.e., the environment containing the process under observation.
Given a process P , we also introduce the notation Laba(P ) to denote the set of ambient labels in P plus the special label env, Labt(P ) to denote the set of capability labels in P , and Lab(P ) to denote Laba(P ) ∪Labt(P ). Moreover, Na = |Laba(P )|, Nt = |Labt(P )|, and NLab = |Lab(P )| = Na +Nt. With N we denote the global number of operators occurring in P . Note that NLab < N , as there is at least one occurrence of 0 in every non-empty process.
In the rest of the paper, we assume that the ambient and capability labels occurring in a process P are all distinct. Performing the Control Flow Anal- ysis with all distinct labels produces a more precise result that can be later approximated by equating some labels.

Example 2.1 Let P1 be a process modeling an envelope sent from venice to

pisa:
venice [ envelope [ out venice . in pisa . 0 ] | Q ] |
pisa [ open envelope . 0 ]
Initially, envelope is in site venice. Then, it exits venice and enters site pisa by applying its capabilities out venice and in pisa, respectively. Once site pisa receives envelope, it reads its content by consuming its open envelope capability. Finally, process P1 reaches the state: venice [ Q ] | pisa [ 0 ] . 
In order to deal with security issues, information is classified into different levels of confidentiality. This is obtained by exploiting the labelling of ambi- ents. In particular, the set of ambient labels is partitioned into three disjoint
sets: high, low and boundary labels (Laba , Laba and Laba , respectively).
H	L	B
Ambients labelled with boundary labels (boundary ambients) are the ones re-
sponsible for confining confidential information. Information leakage occurs if a high level ambient exits a boundary, thus becoming possibly exposed to a malicious ambient attack.
Example 2.2 Let P2 be a labelled extension of process P1, in which the envelope contains confidential data hdata (labelled high) which need to be safely sent from venice to pisa.

veniceb1 [ envelopeb2 [ outc1 venice . inc2 pisa . 0 | hdatah [ 0 ] ] ] |
pisab3 [ openc3 envelope . 0 ]

In this case, venice, pisa and envelope must be labelled boundary to pro- tect hdata during the whole execution.	 
The flow of high level data/ambients outside security boundaries, which we want to detect and avoid, may be formalised as follows.
Definition 2.3 [Information Leakage] Given a process P and a labelling Laba(P), P does not leak a secret h ∈ Laba (P ) if and only if ∀Q such that P →∗ Q,
all occurrences of h are contained inside, i.e., “protected by”, at least one
boundary ambient.

Control Flow Analysis
The Control Flow Analysis (CFA for short) of a process P described in [15] aims at modeling the possible ambient nestings occurring in the execution of
P . It works on pairs (Iˆ, Hˆ ), where:

The first component Iˆ is an element of ℘(Laba(P ) × Lab(P )). If process P , during its execution, contains an ambient labelled la having inside either a capability or an ambient labelled l, then (la, l) is expected to belong to Iˆ.
The second component Hˆ ∈ ℘(Laba(P ) × Amb) keeps track of the cor-
respondence between names and labels. If process P contains an ambient labelled la with name n, then (la, n) is expected to belong to Hˆ . 6
The pairs are component-wise partially ordered by set inclusion.
The analysis is defined as usual by a representation and a specification func- tions [21]. They are recalled in Figure 2 and Figure 3, respectively, where H denotes the component-wise union of the elements of the pairs.

Fig. 2. Representation Function for the Control Flow Analysis
The representation function aims at mapping concrete values to their best abstract representation. It is given in terms of a function βCF(P ) which maps process P into a pair (Iˆ,Hˆ ) corresponding to the initial state of P , with respect to an enclosing ambient labelled with l. The representation of a process P is
defined as βCF (P ).

Example 2.4 Let P
be the process	l	l	l
. The representa-

tion function of P3 is βCF (P3)= ({(env, la), (la, la), (la, lt)}, {(la, n), (la, m)}).
env	1	1  2	2	1	2
Notice that all ambient nestings are captured by the first component {(env, la),
(la, la), (la, lt)}, while all the correspondences between ambients and labels of
1  2	2
P3 are kept by the second one, i.e., {(la, n), (la, m)}.	 
1	2
6 We are assuming that ambient names are stable, i.e., n is a representative for a class of α- convertible names, following the same approach of [20]. In [15,23], an alternative treatment of α-equivalence is used, where bound names are annotated with markers, and a marker environment me is associated to constraints.



Fig. 3. Specification of the Control Flow Analysis
The specification states a closure condition of a pair (Iˆ, Hˆ ) with respect to all the possible moves executable on a process P . It mostly relies on recursive calls on subprocesses except for the three capabilities open, in, and out. For instance, the rule for open-capability states that if some ambient labelled la has an open-capability lt on an ambient n, that may apply due to the presence of a sibling ambient labelled la' whose name is n, then the result of performing
that capability should also be recorded in Iˆ, i.e., all the ambients/capabilities
nested in la' have to be nested also in la.
Example 2.5 Consider again process P3 of Example 2.4. Note that it may

evolve to
a
n 1 [ 0 ] |
a
m 2 [ 0 ]
. It is easy to prove that the least solution for P3 is

(Iˆ,Hˆ ), where Iˆ= {(env, la), (env, la), (la, la), (la, lt)}, Hˆ = {(la, n), (la, m)}.
1	2	1  2	2	1	2
Notice that the analysis correctly captures, through the pair (env, la), the
possibility for m to exit from n.	 
The correctness of the analysis is proven by showing that every reduction of the semantics is properly mimicked in the analysis, with ± denoting the component-wise set inclusion.

Theorem 2.6 [15] Let P be a process. If (Iˆ, Hˆ ) |=CF P and βCF (P ) ± (Iˆ, Hˆ )
and P →∗ P ', then βCF (P ') ± (Iˆ, Hˆ ).
Boundary Ambients Nesting Analysis
The analysis presented in the previous section was not security-oriented, thus it did not exploit the information about “secure” nestings inside boundaries. In [6,7], we propose a more accurate abstract domain that separately consid- ers nesting inside and outside security boundaries, yielding to a much more sophisticated control flow analysis for detecting unwanted boundary crossing, i.e., information leakage. The main idea is to distinguish among nestings either

protected or unprotected by boundaries. More specifically, the Iˆ
component

of the abstract domain is split into two (not necessarily disjoint) sets, IˆB and
IˆE , recording the protected and unprotected nestings, respectively, with B
standing for Boundary, and E for External environment. Thus the result of the refined analysis is given by means of a triplet (IˆB, IˆE , Hˆ ).
Also in this case, the analysis is defined by a representation function and a specification. The representation function collects in IˆB (IˆE ) all the nestings of ambients initially (not) contained in at least one boundary ambient.
Example 2.7 Consider again process P3 of Example 2.4, i.e., of the form:

P =	la	la	lt
a	a	a	a

3	n 1 [ m 2 [ out  n ] ] , with l1 ∈ LabB (P ) and l2 ∈ LabL(P ), thus the
representation function of P is the following: βB (P ) = ({(la, la), (la, lt)},
env	1	2	2
{(env, la)}, {(la, n), (la, m)}). The representation function correctly captures
1	1	2
the fact that boundary ambient n protects all of his sub-ambients and capa-
bilities, i.e., both (la, la) and (la, lt) are recorded in IˆB .	 
We do not report the whole analysis specification (see [6,7] for more de- tails). Instead, we explain how it differs from [15] by considering, e.g., the out-capability (see Figure 4). Within the specification of the analysis, the predicate pathB(la, l) is used to simplify the notation. Intuitively, it repre- sents a protected path of nestings from ambient labelled la to ambient labelled l, in which none of the ambients is a boundary. The rule for the out-capability states that if some ambient labelled la has an out-capability lt on an ambient n, that may apply due to the presence of a direct ancestor ambient labelled la' whose name is n, then the result of performing that capability should also
be recorded in either IˆB or IˆE , depending on the level of protection of the
newly generated nestings. The rule is split into three distinct cases: (i) an ambient exits a boundary, thus moving to an unprotected environment, (ii) all ambients are protected, and finally (iii) all ambients are unprotected. In the first case, all the nestings from the moving ambient la to new protecting
boundaries have to be copied in IˆE , since after the out move they become

unprotected. The in and open-capabilities behave similarly.

Fig. 4. Specification of the refined Control Flow Analysis - the out rule

Example 2.8 Let P be the process of Example 2.7. The least solution of P is the triplet (IˆB ,IˆE ,Hˆ ) where IˆB = {(la, la), (la, lt)}, IˆE = {(env, la), (env, la),
(la, lt)}, and Hˆ = {(la, n), (la, m)}.	 
2	1	2

We now obtain an extension of Theorem 2.6:
Theorem 2.9 Let P be a process.	If (IˆB, IˆE , Hˆ ) |=B P and βB

(P ) ±

(IˆB, IˆE , Hˆ ) and P →∗ P ', then βB (P ') ± (IˆB, IˆE , Hˆ ).
The result of the analysis should be read, as expected, in terms of informa- tion flows. No leakage of secret data/ambients outside the boundary ambients is possible if in the analysis h (a high level datum) does not appear in any of the pairs belonging to IˆE .
Corollary 2.10 Let P be a process and h ∈ Laba (P ) a high level label. Let

B	ˆ	ˆ	ˆ
ˆ	ˆ	ˆ	B
H  '	''
ˆ	''

βenv(P ) ± (IB, IE, H) and (IB, IE, H) |=
P does not leak secret h.
P and ∀(l ,l ) ∈ IE,l 
/= h. Then,

Example 2.11 Consider, for instance, a further refinement of process P2 of Example 2.2. In this case, the high level data is willing to enter some translator process, which could possibly be low level code coming from the external environment.
veniceb1 [ envelopeb2 [ outc1 venice . inc2 pisa . 0 |
hdatah [ inc3 translator . 0 ] ] ] |
pisab3 [ openc4 envelope . 0 ] |
translatorm [ inc5 envelope . 0 ] | openc6 translator . 0
In this case, the translator behaves correctly with respect to information leak- age, i.e., it only enters boundaries. In particular, this means it will never carry

high level data outside the security boundaries. However, if we compute the CFA of [15], we obtain the following least solution:
Iˆ= {(env, b1), (env, b2), (env, h), (env, b3), (env, m), (env, c5), (env, c6),
(b1, b2), (b2, h), (b2, m), (b2, c1), (b2, c2), (h, c3), (b3, b2), (b3, h), (b3, b3),
(b3, m), (b3, c1), (b3, c2), (b3, c4), (m, h), (m, c5)}
Kˆ = {(b1, venice), (b2, envelope), (b3, pisa), (h, hdata), (m, translator)}
Notice that the pair (env, h) appears in Iˆ, even though there is no execution leading to such a situation. On the other hand, the refined analysis properly captures the fact that the translator is entered by confidential data hdata only once inside boundary pisa, and it never gets out of it, i.e., h appears only inside protected nestings IˆB .
IˆB = {(b1, b2), (b2, h), (b2, m), (b2, c1), (b2, c2), (h, c3), (b3, b2), (b3, h), (b3, b3),
(b3, m), (b3, c1), (b3, c2), (b3, c4), (m, h), (m, c5)}
IˆE = {(env, b1), (env, b2), (env, b3), (env, m), (env, c5), (env, c6), (m, c5)}
Kˆ = {(b1, venice), (b2, envelope), (b3, pisa), (h, hdata), (m, translator)}

Thus, the boundary analysis is strictly more precise than the one of [15]. 

Algorithms for Nesting Analyses
In this section we describe the different implementations of the analyses de- scribed so far, which are the core of the Banana tool.
Eﬃcient algorithms for the Control Flow Analysis
The computation of ambient nesting analysis, like [7,15,20], requires consid- erably high complexities, thus the design of efficient techniques is very impor- tant.
This is the first motivation behind the work presented in [23] by Nielson and Seidl. Assuming N is the size of a process, the authors introduce two different algorithms that in O(N 4) and O(N 3) steps, respectively compute the ambient nesting analysis. The algorithms first perform a translation of the Control Flow Analysis constraints into ground Horn clauses. Then, these clauses are processed through satisfiability standard algorithms [12] in order to compute the least solution. As such algorithms always consider all the ground clauses corresponding to the analysis constraints, even in the best case, all the clauses need to be generated.
In [5], we introduce two new algorithms which improve both time and space complexities of the techniques proposed by Nielson and Seidl. Space

complexity of those algorithms is O(N 4 log N ) and O(N 3 log N ) bits, respec- tively, while the one of both our algorithms is O(N 2 log N ) bits. Regarding time, the worst case complexity is of the same order, i.e., O(N 4) and O(N 3) steps, respectively. In the Nielson and Seidl techniques, those complexities are tight because of the need of generating all the ground Horn clauses, as ex- plained above. Instead, our schemes perform better for some particular small solutions (e.g., solutions that are linear to the size of the process), reaching a complexity of O(N 3) and O(N 2) steps, respectively.
These improvements are first achieved by enhancing the data structure representations. Then, we attack the problem with a direct operational ap- proach, i.e., without passing through Horn formulas. Finally, we reduce the computation to the Control Flow Analysis constraints that are effectively nec- essary to get to the least solution. In fact, the algorithms dynamically choose, in an on the fly manner, only the constraints that are effectively necessary for the computation of the analysis. This implies that no useless repetition occurs and there is no need of representing in memory all the possible instantiation of constraints as done in the Nielson and Seidel approach.
Let us now shortly describe our O(N 4) algorithm, called Algorithm 1, and depicted in Figure 5. The algorithm starts with an empty analysis Iˆ
and with a set of buffers containing all the pairs corresponding to the initial process representation. Recall that, for the correctness of the analysis, these pairs should be contained in the final Iˆ. At each round, one pair is extracted from the buffer and it is added to the solution Iˆ. Only the constraints that are potentially “activated” by the extracted pair are then considered, i.e., only the constraints that have such an element in the premise. All the pairs required
by such constraints are then inserted into the buffer, so that they will be
eventually added to the solution. This is repeated until a fix-point is reached, i.e., until all the elements required by the constraints are in the solution. The most important ingredient in this on-the-fly generation is the use of a buffer together with a matrix which allows to use each pair of labels in the buffer exactly once to generate new pairs.
Let us now analyse Algorithm 1 in more details. We assume that the parsing of the process has already been done, producing an array cap of length Nt containing all the capabilities of the input process. For instance, cap[i] may contain ‘inlt n”, representing an in capability labelled with lt and with n as target. 7 During the parsing, the representation βCF (P ) is computed
giving two initial sets Iˆ0 and Hˆ0 that are stored into an Na × NLab bit matrix

7 n here represents an integer 1 ≤ n ≤ Na corresponding to the n-th ambient name. The correspondence between names and integers is kept in the symbol-table produced at the parsing-time.



while bufIˆ != NIL do
(l,l’) := popIˆ (); MIˆ [l,l’] := true; for i := 1 to Nt do
case cap[i] of:
inÆt n: if (l’ ∈ Labt(P) and l’ = lt) then for j := 1 to Na do
for k := 1 to Na do
if (MIˆ [k,l] and MIˆ [k,j] and MHˆ [j,n]) then push cIˆ (j,l) else if (l’ ∈ Laba(P) and Mˆ [l’,lt]) then for j:= 1 to Na do
if (MIˆ [l,j] and MHˆ [j,n]) then push cIˆ (j,l’);
if (l’ ∈ Laba(P) and M ˆ [l’,n]) then for j:= 1 to Na do
t	H
if (MIˆ [j,l ] and MIˆ [l,j]) then push cIˆ (l’,j);
outÆt n: if (l’ ∈ Labt(P) and l’ = lt) then for j := 1 to Na do
for k := 1 to Na do
if (MIˆ [j,l] and MIˆ [k,j] and MHˆ [j,n]) then push cIˆ (k,l)
else if (l’ ∈ Laba(P) and Mˆ [l’,lt] and M ˆ [l,n]) then for j:= 1 to Na do
I	H
if MIˆ [j,l] then push cIˆ (j,l’);

if (l’ ∈ Laba(P) and M ˆ [l’,n]) then for j:= 1 to Na do
t	H
if (MIˆ [j,l ] and MIˆ [l’,j]) then push cIˆ (l,j);
openÆt n: if (l’ ∈ Labt(P) and l’ = lt) then for j := 1 to Na do
for k := 1 to NLab do
if (MIˆ [l,j] and MIˆ [j,k] and MHˆ [j,n]) then push cIˆ (l,k)
else if (l’ ∈ Laba(P) and Mˆ [l,lt] and M ˆ [l’,n]) then for j:= 1 to NLab do
I	H
if MIˆ [l’,j] then push cIˆ (l,j);
if (l’ ∈ Laba(P) and M ˆ [l,n]) then for j:= 1 to Na do
t	H
if (MIˆ [j,l ] and MIˆ [j,l]) then push cIˆ (j,l’);

Fig. 5. Algorithm 1


BIˆ, and into an Na × Na bit matrix MHˆ , respectively. By parsing P twice, we can build BIˆ in such a way that columns from 1 to Na are indexed by ambient labels, while all the other columns by capability ones. All the pairs in Iˆ0 are also stored in a stack bufIˆ, on which the usual operations pushIˆ (l,l’) and popIˆ () apply. Matrix BIˆ is used to efficiently check whether an element has ever been inserted into bufIˆ, thus ensuring that a pair is inserted in bufIˆ at most once. In particular, the new command push cIˆ (l,l’) applies if BIˆ [l,l’]=false, and it both executes pushIˆ (l,l’) and sets BIˆ [l,l’] to true. Finally, we initialize to false another bit matrix MIˆ of size Na × NLab that will contain the final result of the analysis. Also in MIˆ the columns from 1 to Na are indexed by ambient labels and the ones from Na +1 to NLab by capability labels. This initialization phase requires only O(N ) steps, since two parsings of P are sufficient.

Example 3.1 Let P be the Firewall Access process of [10,11], where an agent crosses a firewall by means of previously arranged passwords k, k' and k''

(see [22] for a detailed analysis of the security issues related to this example):

P = (νw) wa1[ ka2[ outt1 w.int2 k'.int3 w.0 ] | opent4 k' . opent5 k'' . 0 ] |
k'a3 [ opent6 k . k''a4 [ 0 ] ]

The least solution of P , as computed using the specification of the Control Flow Analysis depicted in Figure 3, is the pair (Iˆ, Hˆ ), where:
Iˆ= {(env, a1), (env, a2), (env, a3), (a1, a1), (a1, a2), (a1, a3), (a1, a4),
(a1, t1), (a1, t2), (a1, t3), (a1, t4), (a1, t5), (a1, t6), (a2, t1), (a2, t2), (a2, t3),
(a3, a1), (a3, a2), (a3, a3), (a3, a4), (a3, t1), (a3, t2), (a3, t3), (a3, t6)}, Hˆ = {(a1, w), (a2, k), (a3, k'), (a4, k'')}.
Let us see how Algorithm 1 applies to process P . In this case, Na =5 and Nt = 6, thus BIˆ and MIˆ are 5 × 11 bit matrices, MHˆ is a 5 × 5 bit matrix, and cap an array of length 6, initialized as ⟨outt1 w, int2 k', int3 w, opent4 k', opent5 k'',

opent6 k⟩. After the initial parsing, the only pairs in M ˆ
which are set to

'	''	H
true are {(a1, w), (a2, k), (a3,k ), (a4,k )}, while bufIˆ and BIˆ contain the
pairs ⟨(env, a1), (env, a3), (a1, a2), (a3, a4), (a1, t4), (a1, t5), (a2, t1), (a2, t2),
(a2, t3), (a3, t6)⟩.
Let the pair (env, a1) be the top element of bufIˆ. The first 6 rounds of the while-loop just move pairs from bufIˆ to MIˆ (no push is performed). Then, at round 7:
bufIˆ = ⟨(a2, t1), (a2, t2), (a2, t3), (a3, t6)⟩
MIˆ = ⟨(env, a1), (env, a3), (a1, a2), (a3, a4), (a1, t4), (a1, t5)⟩
BIˆ = ⟨(env, a1), (env, a3), (a1, a2), (a3, a4), (a1, t4), (a1, t5), (a2, t1),
(a2, t2), (a2, t3), (a3, t6)⟩.
We extract the top element (a2, t1) of bufIˆ, thusl := a2, and l’ := t1. We show the first iteration, i = 1, where cap[1] is “outt1 w”. Thus, we have l’ = lt and n = w. Since l’ ∈ Labt(P ) and l’ = lt, we are in the “then” branch. The only case that makes true the if condition is when j = a1 and k = env. Since
(a1, w) ∈ MHˆ and both (a1, a2) and (env, a1) are in MIˆ, the pair (env, a2) is
pushed in bufIˆ (note that it is not already in BIˆ). The algorithm ends after
the 24th round, when bufIˆ is empty.	 

More details may be found in [5], where we also present an improved algo- rithm, called Algorithm 2, based on an optimization of the analysis depicted in Figure 3. For space reasons, we omit its description.

Boundary Ambients Nesting Analysis
In Section 2.3 we described the analysis in terms of a representation and a specification function. It is possible to prove that a least solution for this analysis always exists and it may be computed as follows: first apply the representation function to the process P , then apply the analysis to validate the correctness of the proposed solution, adding, if needed, new information to the triplet until a fix-point is reached. The iterative procedure computes the least solution independent of the iteration order.


Boundary Inference for Enforcing Security Policies in Mobile Ambients
The notion of “boundary ambient” and the refined control flow analysis can be further enhanced to infer which ambients should be “protected” to guarantee the absence of information leakage for a given process. More specifically, in [8] we consider a process P wherein only high level data are known (i.e, LabH is fixed) and the aim of the analysis is to detect which ambients among the “un- trusted” ones should be protected and labelled “boundary” to guarantee that the system is secure. This problem can be properly addressed by re-executing the Boundary Ambients Nesting Analysis of Section 2.3. A successful analy- sis infers boundary ambients until a fix-point is reached, returning the set of ambients that should be “protected”.
The algorithm is described Figure 6. It analyses process P starting from the initial labeling L0. It may either succeed (in this case a labeling Lk is reached that fulfills the security property we are interested in) or it may fail. The latter case simply means that the process P cannot be guaranteed to be secure by our analysis.
The analysis is currently implemented with a simple fix-point algorithm, but we are working to extend the optimizations presented in Section 3.1 also to the Nesting Analysis.
Example 3.2 Consider process P2 of Example 2.2:

venicex [ envelopey [ outc venice . inc pisa ] | hdatah [ inc envelope ] ] |
| pisaz [ openc envelope ]

Given the set of high level labels LabH in P , the initial label partitioning
0	0
L0 is computed. L0 = (LabH = {h}, Lab  = {x}, Lab  = {y, z})



Boundary Inference Algorithm
Input: a process P and a partition labeling L0.
Compute the Nesting Analysis with input P and labels Li.
During the execution of the Fix-Point Algorithm, whenever a high level ambient
n labelled h gets into an unprotected environment, i.e. ∃l : (l, h) ∈ IˆE do:
if (env, h) ∈ IˆE , the analysis terminates with failure, as it cannot infer a satisfactory labeling that guarantees absence of information leakage;
otherwise, if (env, h) /∈ IˆE :
a new labeling Li+1 should be considered, labeling every l such that (l, h) ∈ IˆE as a boundary. Let L = {l| (l, h) ∈ IˆE } then Li+1 =
(LabH, Labi ∪ {L}, Labi \ {L}).
L
go to (i) with i = i + 1.

Fig. 6. Boundary inference algorithm
Applying the representation function βL0 to P , it returns the triplet (Iˆo , Iˆo , Hˆ ):
B	E
ˆo = {(x, y), (x, h), (y, c), (h, c)}
ˆo = {(env, x), (env, z), (z, c)}
Hˆ = {(h, hdata), (x, venice), (y, envelope), (z, pisa)}

Executing the Fix-Point Algorithm, the pair (y, h) is introduced in IˆE , re- flecting the fact that ambient envelope leaves ambient venice during the execution of process P .
At this point, a new label partitioning should be considered:
1	1
L1 = (Lab(P )H = {h}, Lab  = {x, y}, Lab  = {z})
is computed again. During its execution, the pair (z, h) ∈ IˆE , reflecting
the fact that the boundary envelope, containing confidential data, is opened inside the low ambient pisa during the execution of process P .
At this point, the following new label partitioning is considered:
2	2
L2 = (Lab(P )H = {h}, Lab  = {x, y, z}, Lab  = ∅)
the Fix-Point Algorithm is computed again, and a fix-point is finally reached.
Thus, the set of ambients that should be labelled as boundaries is {venice, envelope, pisa}.

Tool Overview
The control flow analysis algorithms described in the previous sections have been implemented in the Banana(Boundary Ambient Nesting ANAlysis) tool,

a Java applet available at http://www.dsi.unive.it/∼mefisto/BANANA/.
The main components of Banana can be summarized as follows:
A textual and graphical editor for Mobile Ambients, to specify and modify the process by setting ambient nesting capabilities and security attributes in a very user-friendly fashion.
A parser which checks for syntax errors and builds the syntax tree out of the Mobile Ambient process.
An analyzer which computes an over approximation of all possible nestings occurring at run-time. The tool supports three different control flow anal- yses, namely the one of Nielson et al. in [15], the one by Braghin et al. in [6] (called Focardi Cortesi Braghin in the tool), and the one by Braghin et al. in [8] (FCB Boundary Inference). Five different implementations of the analysis described in [15] are available in the tool. They correspond to:
a fix-point computation of the least solution of the constraints in Figure 3 (called Nielson in the tool) 8 ;
a fix-point computation of the least solution of the constraints of the optimized algorithm of Nielson and Siedl (Nielson Optimized);
Algorithm 1 of Figure 5 (Buffered Boundary Analysis, B.B.A., v1);
Algorithm 2 of [5] (B.B.A. v2);
Algorithm 2 of [5] with some code optimizations (B.B.A. v2 Optimized).
A post-processing module, that interprets the results of the analysis in terms of the boundary-based information-flow model proposed in [6], where infor- mation flows correspond to leakages of high-level (i.e., secret) ambients out of protective (i.e., boundary) ambients, toward the low-level (i.e., untrusted) environment.
A detailed output window reporting both the analysis and the security results obtained by the post-processing module, and some statistics about the computational costs of the performed analysis.

Fig. 7. Overview of the Banana tool.

8 This implementation does not use the algorithm in [12] and it has a O(N 5) worst-case time complexity.

Figure 7 gives an overview of the architecture of the tool. Banana is im- plemented in Java and strongly exploits the modularity of object-oriented technology, thus allowing scalability to other analyses and extensions of the target language (e.g., [17]). Moreover, Banana is conceived as an applet based on AWT and thus compatible with the majority of current web browsers sup- porting Java.
A screen-shot of the Banana tool is shown in Figure 8. A user can edit

Fig. 8. Screen-shot of the Banana tool.
the process to be analyzed by using either the Textual or the Graphical Editor. The security labelling (i.e., the labels denoting untrusted, confidential, and boundary ambients) can be inserted directly by the user, or automatically derived by the tool during the parsing phase. In the latter case, ambients starting with letter ‘b’ are labelled boundaries, while ambients starting with ‘h’ are labelled high. By selecting an item in the Project Explorer window, the user can check/modify the properties of the ambient/capability. The syntax correctness of the process can be verified by selecting the Parsing button.
The user can then choose to launch one of the algorithms which implement the analysis described in [6,8,15]. Once the analysis has started, the tool parses the process, builds a syntax tree, and computes the algorithm yielding to an over-approximation of all possible ambient nestings. The result of the analysis is reported in the Output Console as a list of pairs of labels.
By post-processing the analysis results, Banana reports in the filed Pro- tective the sure absence of information leakages.
The Banana tool has been tested using a suite of use cases consisting of processes differing in the size and number of capabilities.

Conclusion
Security is a major concern for computation in open networks, and is often considered a serious source of potential limitation to a widespread use of mobile code technologies. In this paper, we have studied information flow security in the calculus of Mobile Ambients with a static approach.
Plans of future work include the refinement of the analysis abstract do- mains, and the study of the relationship among types, abstract interpretation, and control flow analysis. Enhancing the precision of the analysis result can affect the efficiency of the analysis: a careful study is therefore needed to bal- ance the precision and the efficiency of the analysis. In addition, we believe that the formalization of the CFA and types in a common setting would allow us to compare their expressive power, understand the relative merits of each approach, and, possibly, for which class of properties one method is more ad- equate than another. We are presently studying how to extend our approach to the full calculus and to more “concrete” version of Ambients, e.g., Boxed and Safe Ambients [9,17].

References
C. Bodei, P. Degano, F. Nielson, and H. Riis Nielson. Static Analysis for the π-calculus with Applications to Security. Information and Computation, 168:68–92, 2001.
C. Bodei, P. Degano, F. Nielson, and H. Riis Nielson. Control Flow Analysis for the π-calculus. In D. Sangiorgi, R. de Simone, editors, Proc. of International Conference on Concurrency Theory (CONCUR’98), LNCS 1466, pages 84–98. Springer-Verlag, 1998.
C. Bodei, P. Degano, F. Nielson, and H. Riis Nielson. Static Analysis of Processes for No Read- Up and No Write-Down. In Proc. FoSSaCS’99, number 1578 in Lecture Notes in Computer Science, pages 120–134. Springer-Verlag, 1999.
C. Braghin, A. Cortesi, S. Filippone, R. Focardi, F.L. Luccio, and C. Piazza. BANANA: A tool for Boundary Ambients Nesting ANAlysis. In H. Garavel and J. Hatcliff, editors, Proc. of the Ninth International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS’03), LNCS 2619, pages 437–441. Springer-Verlag, 2003.
C. Braghin, A. Cortesi, R. Focardi, F.L. Luccio, C. Piazza. Complexity of Nesting Analysis in Mobile Ambients. In L.D. Zuck, P.C. Attie, A. Cortesi, S. Mukhopadhyay, editors, Proc. of the 4-th International Conference on Verification, Model Checking and Abstract Interpretation (VMCAI’03), LNCS 2575, pages 86–101. Springer-Verlag, 2003.
C. Braghin, A. Cortesi, and R. Focardi. Security Boundaries in Mobile Ambients. Computer Languages, Elsevier, 28(1):101–127, Nov. 2002.
C. Braghin, A. Cortesi, and R. Focardi. Control Flow Analysis of Mobile Ambients with Security Boundaries. In B. Jacobs and A. Rensink, editors, Proc. of Fifth Int. Conf. on Formal Methods for Open Object-Based Distributed Systems (FMOODS’02), pages 197–212. Kluwer Academic Publisher, 2002.
C. Braghin, A. Cortesi, R. Focardi, and S. van Bakel. Boundary Inference for Enforcing Security Policies in Mobile Ambients. In Proc. of The 2nd IFIP International Conference on Theoretical Computer Science (IFIP TCS’02). Kluwer Academic Publisher, pages 383–395, 2002.


M. Bugliesi, G. Castagna and S. Crafa, Boxed Ambients, in: Proc. of the 4th Int. Conference on Theoretical Aspects of Computer Science (TACS’01), LNCS 2215 (2001), pp. 38–63.
L. Cardelli and A.D. Gordon. Mobile Ambients. In M. Nivat, editor, Proc. of Foundations of Software Science and Computation Structures (FoSSaCS’98), LNCS 1378, pages 140–155. Springer-Verlag, 1998.
L. Cardelli and A.D. Gordon. Mobile Ambients. Theoretical Computer Science (TCS), 240(1):177–213, 2000.
W. F. Dowling and J. H. Gallier. Linear–Time Algorithms for Testing the Satisfiability of Propositional Horn Formulae. Journal of Logic Programming, 3:267–284, 1984.
P. Degano, F. Levi, and C. Bodei. Safe Ambients: Control Flow Analysis and Security. In Jifeng He and Masahiko Sato, editors, Proc. of Advances in Computing Science - 6th Asian Computing Science Conference, Penang, Malaysia (ASIAN’00), LNCS 1961, pp. 199–214. Springer, 2000.
R. Focardi and R. Gorrieri. A Classification of Security Properties for Process Algebras.
Journal of Computer Security, 3(1):5–33, 1995.
R.R. Hansen, J.G. Jensen, F. Nielson, and H. Riis Nielson. Abstract Interpretation of Mobile Ambients. In A. Cortesi and G. File’, editors, Proc. of Static Analysis Symposium (SAS’99), LNCS 1694, pp. 134–148. Springer, 1999.
M. Hennessy and J. Riely. Information Flow vs. Resource Access in the Asynchronous Pi- Calculus. In U. Montanari, J. Rolim, and E. Welzl, editors, Proc. of the International Colloquium on Automata, Languages and Programming, volume 1853 of Lecture Notes in Computer Science, pages 415–427, Geneva, August 2000. Springer-Verlag.
F. Levi and D. Sangiorgi. Controlling Interference in Ambients. In Proc. 28th ACM Symposium on Principles of Programming Languages (POPL’01), pages 352–364, 2000.
D.A. McAllester. On the Complexity Analysis of Static Analyses. Journal of the ACM, 49(4): 512-537, July 2002.
R. Muth and S. K. Debray. On the Complexity of Flow-Sensitive Dataflow Analyses. In Proc. of the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL’00), pages 67–80. ACM Press, N.Y., U.S.A., 2000.
F. Nielson, R. R. Hansen, and H. Riis Nielson. Abstract Interpretation of Mobile Ambients.
Science of Computer Programming, Special Issue on Static Analysis edited by A. Cortesi and
G. File’, vol. 47(2-3), pp. 145-175, 2003.
F. Nielson, H. Riis Nielson, C.L. Hankin. Principles of Program Analysis. Springer, 1999.
F. Nielson, H. Riis Nielson, R. R. Hansen, and J. G. Jensen. Validating Firewalls in Mobile Ambients. In J.C.M. Baeten, S. Mauw, editors, Proc. of International Conference on Concurrency Theory (CONCUR’99), LNCS 1664, pages 463–477. Springer-Verlag, 1999.
F. Nielson and H. Seidl. Control-flow Analysis in Cubic Time. In D. Sands, ed., Proc. of European Symposium On Programming (ESOP’01), LNCS 2028, pp. 252–268. Springer, 2001.
F. Nielson, H. Riis Nielson, and H. Seidl. Automatic Complexity Analysis. In D. Le Metayer, ed.,Proc. of European Symposium On Programming (ESOP’02), LNCS 2305, pp.243–261. Springer, 2002.
G. Smith and D. Volpano. Secure Information Flow in a Multi-Threaded Imperative Language. In Conference Record of POPL 98: The 25TH ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, San Diego, California, pages 355–364, New York, NY, 1998.
