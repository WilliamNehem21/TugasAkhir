

Electronic Notes in Theoretical Computer Science 250 (2009) 87–103
www.elsevier.com/locate/entcs

An Inductive Technique for Parameterised Model Checking of Degenerative Distributed Randomised Protocols
Douglas Graham,a  Muffy Calder a and Alice Millera
a Department of Computing Science, University of Glasgow, Glasgow, UK

Abstract
We present a technique to tackle the parameterised probabilistic model checking problem for a particular class of randomised distributed systems, which we model as Markov Decision Processes. These systems, termed degenerative, have the property that a model of a system with some communication graph will eventually behave like a model of a system with a reduced graph. We describe an induction schema for reasoning about models of a degenerative system over arbitrary graphs. We thereby show that a certain class of quantitative LTL properties will hold for a model of a system with any communication graph if it holds for all models of a system with some base graph. We demonstrate our technique via a case study (a
randomised leader election protocol) specified using the PRISM modelling language.
Keywords: Probabilistic model checking, parameterised model checking, degenerative systems, PRISM.

Introduction
Model checking of distributed systems is restricted to verifying systems with a fixed number of processes. Proving a property for a system with N identical processes, for any N > 0, is known as the parameterised model checking problem (PMCP). This problem is undecidable in general [2] but techniques can be used to solve it for certain types of system.
Probabilistic model checking augments traditional model checking, enabling quantitative as well as qualitative analysis. Probabilistic model checking has become an important area of research due to the increased use of probabilistic algorithms and the requirement for analysis of not just system correctness but also system per- formance. Probabilistic model checkers, such as PRISM [14], enable properties such as “the system will fail with probability less than 0.01” and “with probability 1, the system will terminate” to be verified. Probabilistic model checking tools vary in the type of underlying model that they support. We focus on probabilistic model check- ing of randomised distributed systems, models of which exhibit both probabilistic

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.08.007

and non-deterministic choice, therefore we restrict our attention to reasoning over MDPs.
In this paper we tackle the PMCP for randomised distributed systems by ex- tending an inductive proof for a non-probabilistic parameterised distributed system [16]. We generalise this proof for a class of probabilistic systems, described as de- generative – they have the property that a system configuration of a given size eventually behaves like a smaller configuration. The proof employs induction over the topology of the system in order to show that any property in a class of prop- erties that holds for a model of a base system topology will hold for a model of a system of any size and configuration. The induction relies on determining that any behaviour of a model of the system of a given size is equivalent to a behaviour in a model of a smaller system. To illustrate our technique we consider a family of models of the IEEE 1394 Firewire tree identify protocol [11] specified using PRISM.

Background
Markov Decision Processes
In the sequel, for a set Y , Dist(Y ) denotes the set of all discrete probability distri-

butions over Y i.e. the set of all functions μ : Y → [0, 1] such that Σ

y∈Y
μ(y)= 1.

We model randomised distributed systems as Markov Decision Processes
(MDPs). In particular, we consider state-labelled MDPs, where the states are aug- mented with a set of (atomic) propositions true in that state.
Definition 2.1 (See, for example, [18]). A (labelled) Markov Decision Process is a tuple M = (S, s0, Steps , Act , L) where S is a finite set of states, s0 ∈ S is the initial state, Act is a set of actions, Steps : S → 2Act×Dist(S) is the probabilistic transition function such that, ∀s ∈ S, Steps (s) /= ∅ and L : S → 2AP is a labelling function over a set of propositions AP .
For an MDP, M = (S, s0, Steps, Act , L), the function Steps maps each state in S to a non-empty subset of Act × Dist (S). Intuitively, for s ∈ S, Steps makes a non-deterministic choice over |Steps(s)| action, distribution pairs, choosing action a and distribution μ, say. A probabilistic choice is made over S where the probability of moving to a state s' is given by μ(s'). We say that a is enabled from s. If μ(s') > 0 for some state s' we say there is a transition from s to s', written s a,μ s'. Action a ∈ Act is non-probabilistic iff, ∀s ∈ S, ∀(a, μ) ∈ Steps(s), μ(s')= 1 for some s' ∈ S and is a stutter action iff, ∀s ∈ S, ∀(a, μ) ∈ Steps(s), μ(s') > 0 =⇒ L(s)= L(s').

An infinite path, α in M is a non-empty sequence s
a0,μ0
0 −→ s
a1,μ1
1 −→ ... where for i ≥ 0,

si ∈ S, (ai, μi) ∈ Steps(si), μ(si+1) > 0. Similarly, a finite path is a non-empty

sequence, s
a0,μ0 s
a1 ,μ1 ... an−1 ,μn−1 s
for some n ≥ 0. For a finite or infinite

0 −→
1 −→
−→	n

path, α, |α| denotes the length (the number of actions) of the path (with |α| = ∞
for an infinite path), and tr AP (α) the sequence given by the labelling of the states

in α restricted to the set of propositions in AP . For a finite path, α = s0
a0,μ0
−→

a1,μ1
s1 −→ ... 
an−1 ,μn−1
−→	sn, let last (α) = sn and P(α) = μ0(s1).μ1(s2) ... μn−1(sn)

(with P(α)= 1 if α = s0). For two paths, α and α' with α finite, if α is a prefix of α' we write α ≤ α' (and α < α' if it is a strict prefix). The set of all infinite paths starting at state s is given by Path(s) and the set of all finite paths starting at s by Pathfin(s).
Adversaries
In order to analyse an MDP we need to resolve the non-determinism. This is done by considering adversaries, constructs that make a choice over Steps(s) for each state s of an MDP, based on the history of choices made up to state s. Formally, an adversary A of an MDP M = (S, s0, Steps , Act , L) maps every finite path α of M onto an element A(α) of the set Steps (last (α)) [19]. An adversary produces an infinite-state Markov chain, with each state given by the history of states so far vis- ited. An adversary uniquely determines a Markov chain of this form, so in the sequel it will be convenient to refer to an adversary of an MDP when describing the Markov chain induced by it. Also, Adv M denotes the set of adversaries for MDP M and, for adversary A and state s, PathA(s) denotes the subset of Paths which corresponds

to A and similarly, PathA
(s), the subset of Pathfin(s) that corresponds to A [19].

For path α ∈ PathA (s), define the path cylinder, C(α) = {ω ∈ PathA(s)|α ≤ ω}.
The probability measure, ProbA, is defined on the smallest σ-algebra that contains
all the sets C(α) for all α ∈ PathA (s), such that, ProbA(C(α)) = P(α) (for more
detail see, for example, [13]).
Cuts
Definition 2.2 Let M =(S,s0,Steps ,Act ,L) be an MDP and let A ∈ Adv M. Define
Cut (A) to be a family of sets s.t. for D ∈ Cut (A), D ⊆ PathA (s0) where, for all
α ∈ D , α # α' and α' # α for any α' ∈ D, α' /= α and Σ	ProbA (C(α)) = 1.
Intuitively, a cut (a simplification of a fringe as defined for probabilistic au- tomata by Segala [20]) represents a finite portion of the Markov chain induced by an adversary. Given an adversary A of an MDP, for n ≥ 0, let cutA(n) ∈ Cut (A) be defined such that for all α ∈ cutA(n), |α| = n. For C ∈ Cut(A) we say that C is a cut of A. Furthermore, we describe cut A(n) as a cut of A at depth n.
Quantitative Linear Time Logic
To specify properties of MDPs we employ Linear Time Logic (LTL). LTL for- mulae are defined in terms of paths of an MDP and have a formal syntax φ :: true | a | ¬φ1 | φ1 ∧ φ2 | φ1 U φ2 |X φ1 where a is an atomic proposition, and U and
X are the standard until and next-time operators. See for example, [7] for a full description. LTL\X is defined as for LTL but without the next-time operator (the exclusion of this operator is not a great hardship since one seldom reasons about exactly the next state in a distributed algorithm).
A quantitative LTL (QLTL) formula, is defined over states of an MDP with syntax φ ::= PDаp[ψ], where Da ∈ {≤, <, >, ≥},p ∈ [0, 1] and ψ is a LTL path formula

(similarly for QLTL\X ). For MDP, M, state s of M, adversary A of M and LTL path formula ψ, by abuse of notation, in the sequel, we let ProbA(ψ)= ProbA({α ∈
s	s
PathA(s)|α |= ψ}). For QLTL property, φ ≡ PDаp[ψ], s satisfies φ, denoted s |= φ, iff, ∀ A ∈ Adv M, ProbA(ψ) Da p. M satisfies φ, (M |= φ) iff s0 |= φ where s0 is the
initial state of M.

Stuttering equivalence
For any string v, the stuttering removal operator # applied to v replaces every maximal finite subsequence of identical elements by a single copy of this element. Let M and M' be MDPs with propositions AP and AP ' respectively. A path α of M is said to be stuttering equivalent to a path α' in M' (denoted α  α') with respect to AP '' ⊆ AP ∩ AP ' if and only if #tr AP (γ) = #tr AP (β). We extend stuttering equivalence of paths to adversaries by considering trace cylinders over sequences of sets of atomic propositions. Our definitions are based on those given in [5].
Definition 2.3 Let  AP  be  a  set  of  propositions.   The  trace  cylinder
C(l+, l+,... , l+) (for l0, l1,... , ln ∈ 2AP pairwise distinct, n ≥ 0) is defined by
0	1	n
C(l+, l+,... , l+)= {t ∈ (2AP )ω)|t = lk0 , lk1 ,... , lkn,... for some k0, k1,... , kn ≥ 1}
0	1	n	0	1	n
where, for k ≥ 1, lk = l, l,... ,l for l ∈ 2AP .
`  ˛¸  x
For an adversary A of an MDP M with initial state s0, and set of propositions
AP , by abuse of notation in the sequel let ProbA (C(l+, l+,... , l+)) = ProbA ({α ∈

PathA(s0)|tr AP (α) ∈ C(l+, l+,... , l+)}).
s0	0	1	n	s0

0	1	n
Definition 2.4 Given two MDPs, M  = (S, s0, Steps, Act , L) and M'  = (S', s' , Steps ', Act ', L'), with propositions AP and AP ' respectively, two adver- saries A ∈ Adv M, A' ∈ Adv M' are probabilistic stuttering equivalent (denoted
A   A') w.r.t.  AP '' ⊆ AP ∩ AP ' if and only if, ProbA (C(l+, l+,... , l+)) =

A'	+ +	+
s0	0	1	n
AP ''

Probs' (C(l0 , l1 ,... , ln )) for all pairwise disjoint l0, l1,... , ln ∈ 2
,n ≥ 0.

For convenience, and consistency with [5], we henceforth use the shorthand stuttering equivalence for probabilistic stuttering equivalence when it is clear that we are referring to equivalence between adversaries.
Let S, T be sets, R ⊆ S × T and μ ∈ Dist(S), ν ∈ Dist (T ). A weight function for μ and ν with respect to R is a function w : S × T → [0, 1] such that w(s, t) >

0 ⇒ sRt, μ(s)= Σ
t∈T
w(s, t) for any s ∈ S and ν(t)= Σ
s∈S
w(s, t) for any t ∈ T .

We write μ ±R ν iff there is a weight function for μ and ν with respect to R.
We now give conditions on a pair of adversaries that allow us to show stuttering equivalence without considering trace cylinders and examining only finite paths. The proof of Lemma 2.5 is given in [20] for a more general case.
Lemma 2.5 Let M = (S, s0, Steps , Act , L) and M' = (S', s' , Steps', Act ', L') be MDPs with sets of propositions AP and AP ' respectively. Let AP '' ⊆ AP ∩ AP '.

x=0  a 

x=0  b 
1	'	1

M	M
Fig. 1. Two MDPs, M and M', with stuttering equivalent adversaries
Let A and A' be adversaries of M and M' respectively. A  A' if there exists cuts
D0, D1,... with, ∀i ≥ 0Di ∈ Cut (A'), such that
∀i ≥ 0, ∀α ∈ Di+1, α ∈ Di or α = β.a, μ, s and β ∈ Di,

For every α ∈ PathA (s0), limi→∞ Σ

β∈Di,α≤β
P(β)= ProbA (C(α)),

For each i ≥ 0, deﬁne μi : cut A → [0, 1], μ' : Di → [0, 1] such that for α ∈ cutA,
i	i
α' ∈ Di, μi(α) = P(α), μ'(α') = P(α'). Then μi ±R μ' where for α ∈ cutA,
i	i	i
α' ∈ Di, R(α, α') iff α  α' w.r.t. AP ''.
LTL\X properties induce stutter-invariant measurable languages [22] and so, by standard arguments of measure theory, it follows that
Lemma 2.6 If M and M' are MDPs with propositions AP and AP ' and adver- saries A and A', respectively, then for any LTL\X path formula ψ with propositions

in AP '' ⊆ AP ∩ AP ', if A	'
''	A	A'

A w.r.t. AP
then Probs0 (ψ)= Probs' (ψ).

Example 2.7 In Figure 1 we give an example of MDPs, M and M', both over set

of propositions AP = {x = 0,x = 1}, with initial states s0 and s'
respectively and

action sets {a, b, c} and {b, c} respectively. There is only one adversary associated with each MDP: let these be A and A', then A  A' w.r.t. AP since,

ProbA (C({x = 0}+
A'	+
'
0

ProbA (C({x = 0}+, {x = 1}+
A'	+	+
'
0

and the probability measure over all other trace-cylinders is zero. If ψ is LTL\X

property, (true U
A	A'
M and M' satisfy

P≥1[ψ].
(x = 1)), Probs0 (ψ) = Probs' (ψ) = 1. Thus,

Isomorphism between Adversaries
Isomorphic adversaries must have exactly the same structural behaviour (up to labelling of states). Definition 2.8 and Lemma 2.9 are adapted from [9].
Definition 2.8 Let M = (S, s0, Steps, Act , L) and M' = (S', s' , Steps ', Act ', L') be
'	A 0	A'	'
MDPs with adversaries A and A respectively. Let ρ : Pathfin(s0) → Pathfin(s0)

be a bijection with ρ(s0) = s' . Suppose, for all α ∈ PathA
(s0), if A(α) = (a, μ)

(a,μ)
0
' (a',μ') '	'  '
fin

and ρ(α −→ t)= α
−→ t
then μ(t)= μ (t ) for all t s.t. μ(t) > 0. Then ς is an

isomorphism from A to A', and A and A' are isomorphic (denoted A = A').
Lemma 2.9 Let M = (S, s0, Steps , Act , L) and M' = (S', s' , Steps', Act ', L') be MDPs with propositions AP and AP ', respectively and let Σ : AP → AP ' be a

bijection. For LTL property ψ with propositions in AP, Σ(ψ) is the LTL formula obtained from ψ by replacing every proposition a with Σ(a). Let ς be an isomorphism between adversaries A (of M) and A' (of M') such that, for all α ∈ PathA (s0) and a ∈ AP, a ∈ L(last (α)) ⇐⇒ Σ(a) ∈ L'(last (ς(α))). Then for any LTL formula ψ
A	A'
with propositions from AP, Probs0 (ψ)= Probs' (Σ(ψ)).
Note that in Example 2.7, A and A' are not isomorphic.
Graphs
We define a graph, G = (E, V, I), to be a tuple with V a set of vertices, E, a set of edges between pairs of vertices and I, a labelling of vertices with each vertex v ∈ V uniquely labelled by a value I(v) ∈ {0, 1,... , |G| − 1} (where |G| = |V | is the size of the graph). By abuse of notation, i denotes the vertex v with I(v) = i. Given a permutation, σ on {0, 1,... , |G| − 1}, we define the permuted graph under σ as σ(G)= (E, V, I') where I'(v)= σ(I(v)) and describe σ as a permutation on G. For a graph, G = (E, V, I) and V ' ⊆ V , G[V ']= (E',V ',I') is the subgraph induced by V ' obtained by deleting the vertices in V \ V ' and the associated edges from G.

Parameterised Model Checking for Randomised De- generative Systems
Communication Graphs and Reductions
In the sequel we use the term communication graph to describe a vertex-labelled, non-empty, finite, simple, connected graph (by abuse of notation, we refer to a communication graph simply as a graph). Also, for a communication graph G we refer to vertex v, with I(v) = i as process i and describe i as a process index. If there is an edge (v, w) of G, with I(v)= i, I(w)= j, we say process i and process j communicate. A set of communication graphs is defined as a communication topology (or simply a topology).
Informally a system is degenerative if it eventually behaves as a ‘smaller’ system. We formalise the notion of ‘smaller’ in terms of the topology of the system and define a set of ‘least’ elements of a topology as follows.
Definition 3.1 Let Γ be a topology and G = (E, V, I) ∈ Γ. Let σ be a permutation of G and let W ⊂ V . Then R = (W, σ) is a reduction of G in Γ iff the graph R(G) = σ(G)[W ] belongs to Γ. We describe R(G) as the reduced communication graph of G in Γ under R or simply a reduced communication graph of G.
Example 3.2 Consider the topology Γ consisting of graphs G, G1 and G2, illustrated in Figure 2. Define sets W1 and W2 thus: W1 = {0, 1, 2, 3} and W2 = {0, 1, 2, 3, 4}, and let permutations σ1 and σ2 be the identity permutation and a permutation that fixes 0 and 1 and maps 3 to 2, 4 to 3 and 5 to 4 respectively. Then, if R1 = (W1, σ1) and R2 = (W2, σ2), R1(G)= G1 and R2(G)= G2. Hence R1 and R2 are reductions of G in Γ.









Fig. 2. Communication Topology Γ for Example 3.2
Definition 3.3 Let Φ and Γ be topologies such that Φ ⊂ Γ and let QΓ = {QG |G ∈ Γ} be a family of sets of reductions for communication graphs in Γ such that for all G ∈ Φ, QG = ∅. Then Γ is reducible to Φ under QΓ iff, for all G ∈ Γ \ Φ, there exists a sequence of reductions, R1, R2,... , Rn (for some n ≥ 1) such that, for all 1 ≤ i ≤ n, Ri ∈ QRi−1 (Ri−2 (...(R1 (G)))) and Rn(Rn−1(... (R1(G)) .. .)) ∈ Φ.
Specifying Sets of Models Over a Communication Topology
We consider MDPs defined with respect to some variable set. For a communication graph G, we consider variable sets over G, XG = ∪N−1Xi ∪ GG ∪ CG where, for 0 ≤
i=0	G

i ≤ N −1, each Xi
is a set of local variables associated with process i. These are the

same (up to indexing) for each process. The set GG are the global variables that are common to all processes. The channel variables, CG = {cj,k|j and k communicate}, are used to send messages between a pair of processes. For x ∈ XG , D(x) denotes the domain of x and D(XG ) the cross-product of the domains of the variables in XG . We assume that D(c) = D(c') for all c, c' ∈ CG . We define the set of propositions over XG as, AP G = {x = d|x ∈ XG ,d ∈ D(x)}.
In the sequel, we distinguish between indexed and unindexed variables in XG . A variable is indexed if it is subscripted with a process index (all local and channel variables are indexed), or if its domain is the set of process indices plus the unas- signed value, ⊥ (otherwise it is unindexed). The elected variable in the example described in Section 4 is an indexed variable. For the same example, a local vari- able mymsg (say) storing the most recent message received by a given process would have domain {⊥, bmp, bmc, ack} and would therefore be unindexed.
We can extend this definition to the set of propositions AP G over XG . A propo- sition x = d (x ∈ XG , d ∈ D(x)) is indexed if x is indexed and d /= ⊥ (otherwise it is unindexed). A LTL or QLTL property is unindexed if it contains only unindexed propositions.
We also assume for an MDP that there is a set of actions over a graph G, Act G = ∪N−1Act i, such that each action is defined with respect to a process and that the sets of ‘local’ actions, Act i, are isomorphic (up to process indexing).
Definition 3.4 Let G = (E, V, I) be a communication graph, XG a variable set over G and ActG an action set over G. If the initial value of the vari- ables in XG is given by the tuple init (XG ) then a model over G is an MDP, MG = (D(XG ), init (XG ), Steps G , Act G , LG ) such that LG labels states with the set of propositions AP where AP is defined over XG . Given a topology, Γ, let MΓ = {MG |G ∈ Γ} denote a set of models over Γ.

Mappings Induced by the Permutation of a Communication Graph
Given graph G and a permutation of G, σ, let MG be a model over G and Mσ(G) be a model over σ(G). For adversaries A of MG and A' of Mσ(G) we define the index map
on A induced by σ, ρ : PathA (sG) → PathA' (sσ(G)) that maps the process indices
fin	0	fin	0
associated with any indexed variables and any actions, according to σ. Similarly, we
can define the propositional index map induced by σ, Σ, between the propositions AP over variable set XG and AP ' over Xσ(G). Since Σ respects ρ, from Lemma 2.9 we can show that, for an unindexed LTL property ψ with propositions in AP , if ρ
A	A'
is an isomorphism then, Probs0 (ψ)= Probs' (ψ).
Degenerative Families of Models
We now turn to our main definition that gives conditions for a family of models (over a topology) to be degenerative. The key condition is that the communication graphs of the topology are reduced such that every adversary of a model over some graph is stuttering equivalent to an adversary of a model over a reduced graph.
Definition 3.5 Let Γ be a topology that is reducible to Φ under a family of sets of reductions, QΓ = {QG |G ∈ Γ}. Suppose MΓ = {MG |G ∈ Γ} is a set of models over Γ. For each G ∈ Γ let XG be a set of variables over G and let AP G be the

propositions over XG . For each R ∈ QG , define a set of variables X'
⊆ XR(G)

(with AP '
⊆ AP R(G), the set of propositions over X'
). MΓ is degenerative

with base Φ under QΓ iff,
(Reduced Variables and Actions:) For G ∈ Γ and R = (W, σ) ∈ QG, Xσ(G) \ CG = XG \ CG , D(Xσ(G))= D(XG ), Act σ(G) = Act G ,
XR(G) ⊆ Xσ(G), D(XR(G)) ⊆ D(Xσ(G)), Act R(G) ⊆ Act σ(G),
(Matching Adversaries:) For G ∈ Γ \ Φ, there exists R = (W, σ) ∈ QG such that, for every adversary A of MG , there exists an adversary A' of Mσ(G) that is isomorphic to A under the index map induced by σ, with A' stuttering
equivalent to some adversary A'' of MR(G) with respect to AP '	.
The establishment of a set of models, parameterised by a topology, that is de- generative provides an inductive basis (over the topology) with which to establish properties of the models.
Theorem 3.6 Let Γ be a topology that is reducible to Φ under the family of sets of reductions, QΓ and let MΓ be a set of models over Γ. Suppose, for each G ∈ Γ, R ∈ 

QG , there is a set of variables X'
⊆ XR(G) (with AP '
⊆ AP R(G), the set of

propositions over X'	) such that MΓ is degenerative with base Φ under QΓ. Then
R(G)
'

for any unindexed QLTL\X property φ with propositions in
if MF |= φ for all F ∈ Φ, MG |= φ for all G ∈ Γ.
G∈Γ\Φ
R∈QG AP R(G),

Proof. Let G ∈ Γ and suppose φ is an unindexed QLTL\X property with propo-

sitions in 
' R(G)
. Assume MR(G) |= φ, for every R ∈ QG . We can show

MG |= φ, as follows. Let A ∈ Adv MG . Choose R = (W, σ) ∈ QG such that A is

isomorphic to some A' ∈ Adv M


σ(G)
under ρ, the index map on A induced by σ,

with A' stuttering equivalent to some A'' ∈ Adv M

R(G)
w.r.t. AP '
. Property φ

has the form PDаp[ψ]. Let Σ be the proposition index map induced by σ. For every
adversary B of MR(G), ProbB (ψ) Da p. If MG , Mσ(G) and MR(G) have initial states
0
s0, s' and s'' respectively then,
A	A'	'

Probs0 (ψ)= Probs' (ψ) from Section 3.3 since A = A
= ProbA'' (ψ) since A'  A'' w.r.t. AP '
under ρ

''
0
Da p by the above.
R(G)

Since the above is true for every adversary of MG , MG |= φ.
Let	φ	be	an	unindexed	QLTL\X	formula	with	propositions	in
AP '	.	Let G  ∈  Φ then, by the statement of the theorem,

G∈Γ
R∈QG
R(G)
'

MG |= φ. Assume G ∈ Γ \ Φ. φ is defined over
R∈QG AP R(G) and is unindexed,

so by the above, MG |= φ if MR(G) |= φ for all R ∈ QG . For each R ∈ QG ,
either R(G) ∈ Φ or it can be reduced further. Since Γ is reducible to Φ under QΓ, continuing in this way, we can construct a tree of graphs in which every terminal node is a graph in Φ. Finally, by statement of the theorem, each of the models associated with the graphs at these terminal nodes satisfy φ and, by propagation up the tree of graphs, it follows that MG |= φ.	 

Model Checking the IEEE 1394 (Firewire) Tree Iden- tify Protocol
We illustrate our technique with a case study. The IEEE 1394 (Firewire) Tree Identify Protocol (TIP) [11], is designed to elect a leader from a set of processes arranged in an acyclic topology. A process may send one of three messages to a neighbouring process: be my parent (bmp), be my child (bmc) or acknowledge (ack ). Any process that has received bmp messages from all or all but one of its neighbours responds with bmc messages and, if necessary, sends a bmp to the remaining neighbour. The neighbouring processes will send an ack upon receiving a bmc, from which point the processes play no further part in the protocol (and hence the protocol is degenerative). In this manner the protocol builds a spanning tree with the root process elected as leader.
It is possible for two neighbouring processes to attempt to become leader by sending bmp requests to each other simultaneously. In order to resolve this con- tention, each process probabilistically chooses to wait for a long or short amount of time, before attempting to send a request again. If a process then receives a request before it has sent one, it will be elected leader. Otherwise, another contention situ- ation ensues and the “back-off” procedure must be repeated. Much work has been done on proving correctness of root contention in the TIP [21]. Appealing to these results, in earlier work [6] we modelled the TIP with non-deterministic contention resolution. Here we consider a family of MDP models for the TIP in which con- tention is resolved probabilistically. We model contention with a contending process



Fig. 3. Transition in MG corresponding to contention resolution between processes j and i1 (j < i1).

Table 1
Transitions in MG made by process j when it receives requests from all of its neighbours


(the one with the smallest index) making a simple probabilistic choice: with prob- ability 1 , the process loses and the other process sends its bmp; with probability 1 ,
4	4
the process wins and transmits its request to the other process; or with probability
1 contention is not resolved and the process must choose again.
We have modelled the TIP and verified a suite of properties for all configurations of systems with three, four and five processes, using PRISM. For reasons of space we do not give our PRISM specifications or all of our properties here. We concentrate on one property which we refer to throughout the rest of the paper. Here elected is a global variable (see the subsequent section) that is initially equal to ⊥ and is set to the value of the index of any process that is elected leader.
Property 1. A leader will almost surely be elected: P≥1[true U ¬(elected = ⊥)].

A Family of Models of the TIP over Acyclic Communication Graphs
Using the PRISM specifications for small configurations of the TIP as a basis, we have defined a script for automatically generating PRISM specifications of the TIP for any topology. We can view this script as specifying a family of models for the TIP system, MΓ = {MG |G ∈ Γ} over the topology Γ, the set of communication graphs that are acyclic. Given G ∈ Γ, with |G| = N , model MG over G has variable set XG over G with, for i ∈ {0,... ,N − 1},
GG = {elected, toss0, toss1,... , tossN−1}, CG = {cg,h, ch,g|(g, h) ∈ E}, Xi = {state i, child i,0, child i,1,... , child i,N−1, adj i,
remaining partner i, no of requestsi},
The variable domains are, for i, j ∈ {0, 1,... ,N − 1}, cg,h ∈ CG ,

Table 2
Transitions in MG made by process j when it receives requests from all but one of its neighbours (i1).


D(state i)= {start , child, parent , conten, response , complete , winner, loser , b child, ﬁnish }, D(no of requestsi)= D(adj i)= {0, 1,... ,N −1}, D(remaining partner i)= D(child i,j)= D(elected )= {⊥, 0, 1,... ,N − 1}, D(cg,h)= {empty, bmp, bmc, ack }, D(toss i)= {0, 1, 2}.
The set of actions over G is given by ActG = ∪N−1Act i . A sample of the non-
i=0	G

probabilistic actions in Act i
are shown in Tables 1 and 2 (for reasons of space we

do not provide them all). The sole probabilistic action that a process can make, that of resolving contention, is shown in Figure 3. The conditions for an action to occur and the result of that action are given in each as the value of the local variables of process j along with some of the channel and global variables. The local variables are presented as a tuple, (s, [ch0,... , chN−1], a, r, n), representing the values of state j, childj,0,... , childj,N−1, adj j , remaining partner j , no of requestsj respectively. The value of a channel variable ch,i is represented by [msg]h,i (where msg is bmp, bmc, ack) or []h,i if ch,i = empty. If a variable is not presented then its value is not considered for that action. We assume process j has k neighbours, i1, i2,... , ik and for Table 2 and Figure 3, that i1 is the neighbour that does not initially send a bmp to j.

Parameterised Model Checking of the TIP
We demonstrate our proof technique for tackling the PMCP for probabilistic de- generative systems, describing how it can be applied to the TIP and showing that,
Theorem 5.1 Let φ be Property 1. Then MG |= φ for all G ∈ Γ.
We tackle Theorem 5.1 by showing that MG is degenerative with base Φ ⊂ Γ, the set of stars, under some family of sets of reductions. We do so by considering each of the conditions given in Definition 3.5 in turn, having defined an appropriate set of reductions and corresponding ‘reduced’ set of variables for each model in MΓ. First, however, we show that Property 1 is satisfied by all models in MΦ. Note that in order to show all models in MΦ satisfy Property 1, we have to tackle



(clip2 (Γ),σΓ)
Γ	2
Fig. 4. An example of graph G (left) and the graph σG (G)[clip2(G)] (right) obtained under a clipping
reduction, with respect to level-1 vertex, vertex 2.
another instance of the PMCP. However, the topology Φ is regular, making the problem easier. We prove Lemma 5.2 by showing that MΦ is degenerative with base {MG(2)} where G(2) is the star with two vertices. The proof, omitted, is a simpler version of that for Theorem 5.1.
Lemma 5.2 For all G ∈ Φ, MG |= φ, where φ is Property 1.
Clipping Reductions
The main decision in defining a set of reductions is how vertices are removed from communication graphs. In the TIP example we define clipping reductions where we remove sets of leaf vertices that are connected to a particular kind of non-leaf vertex. These non-leaf vertices, termed level-1 vertices, are the set of vertices for which all but one of the neighbouring vertices are leaves (the non-leaf neighbour is the inner vertex of j). They are guaranteed to exist in acyclic communication graphs that are not stars [16]. Given a level-1 vertex j of a graph G, clipj(G) is the set of vertices of G excluding leaf vertices of j. We also have to identify a permutation of the vertex labels that ensures the reduced graph is labelled correctly. In the sequel, we let σG be a permutation (for G ∈ Γ and level-1 vertex j) on the vertex labels of G, which permutes the indices such that the leaves of j have the largest indices and the order of the indices of the remaining vertices is preserved (see [16] for a formal definition). We now define a set of reductions on a graph G ∈ Γ.
Definition 5.3 For G ∈ Γ, let JG = {j1, j2,... , jm} be the set of all level-1 vertices
in G. Let Clipj  = (clipj(G), σG ) and define the set of clipping reductions of G

as ClipG
= {Clipj |j ∈ J G }. Furthermore, define the family of sets of clipping

reductions, ClipΓ = {ClipG |G ∈ Γ}.
An example of a graph obtained under a clipping reduction for the level-1 vertex, vertex 2, is shown in Figure 4. We now show that we can reduce any communication graph in Γ to a star under a sequence of clipping reductions. The proof, by induction over the number of level-1 vertices, is omitted.
Lemma 5.4 The topology, Γ, is reducible to the set of stars, Φ under ClipΓ.
Reduced variable Sets
We define a subset of the variable set of a model of a clipping reduced graph. Let
G ∈ Γ and let j be a level-1 vertex. For variable set, XG and a clipping reduction,
Clipj = (clipj(G), σG ) (with j' = σG (j)) we remove variables associated with the
G	j	j

leaf processes of j. Specifically, we define Xj'
G
to be equivalent to XClipj (G)
but

G	Table 3	G
Result of applying Σj to a proposition, a, for 0 ≤ h, k ≤ N and 0 ≤ i ≤ N − 1 (σ abbreviates σj ).

excluding the variables childj',0, childj',1, .. ., childj',N −1, adj j' , no of requestsj' .
In the sequel APj'	is the set of propositions over Xj'	.
G	G

Matching Adversaries
To show that MΓ, with clipping reductions, is degenerative we demonstrate that the conditions of Definition 3.5 are fulfilled. Here we establish condition (ii).
We partition the adversaries of a model MG over G ∈ Γ according to their behaviour in terms of the level-1 vertices. Specifically, we classify them according to which level-1 vertex receives bmp requests from all its leaf vertices, but not its inner vertex, first. If, under A ∈ Adv MG , j is such a vertex then A is ﬁrst-full with respect to j. The leaf neighbours of j are then guaranteed to terminate without being elected leader and their effect under the adversary can be ignored (this is

key to showing that MΓ is degenerative). In the sequel, Adv j
⊆ AdvMG
denotes

the set of adversaries that are first-full with respect to j. The proof of Lemma 5.5
is as for the proof given in [16] for the non-probabilistic case. Intuitively, at the initialisation of the protocol only leaf processes can progress beyond their starting state. Thus a state must be reached where a level-1 process receives bmp requests from all of its leaf neighbours but not its inner vertex. The adversary corresponding to this scheduling must therefore be first-full with respect to a level-1 process.
Lemma 5.5 For G ∈ Γ \ Φ, let J G = {j1, j2,... , jk}, be the set of level-1 vertices.

Then, 

j∈J
G Adv j
= Adv MG .

Let G ∈ Γ \ Φ and for level-1 vertex j let (clipj(G), σG ) be a clipping reduction.

ΣG , the proposition index map induced by σG
is shown in Figure 3 (by abuse of

j	j
notation we let σG (⊥) = ⊥). In Lemma 5.6 we show every adversary Aj of MG
(first-full with respect to j) is isomorphic to an adversary of MσG (G) under the index
map induced by σj . The proof (omitted) is by considering transitions under Aj.
Lemma 5.6 Let G ∈ Γ \ Φ. Let j be a level-1 vertex and let Clipj = (clipj(G), σj )
be the clipping reduction for j. For every adversary Aj of MG that is ﬁrst-full w.r.t.
'	G
j, there exists an adversary Aj' of Mσj (G) that is ﬁrst-full w.r.t. j = σ (j) such
that ρG , the index map induced by σj , is an isomorphism between Aj and Aj' .
j	G
In Lemma 5.7 we show that, for every adversary of the model of a permuted

graph, first full with respect to j, say, there exists a stuttering equivalent adversary of the model of the clipping reduced graph.

Lemma 5.7 Let G ∈ Γ \ Φ, j a level-1 vertex and Clipj = (clipj(G), σj ) be the
clipping reduction for j. For every adversary A of MσG (G) that is ﬁrst-full w.r.t. j

there exists an adversary A' of M	j
s.t. A  A' w.r.t. APj	.

ClipG (G)
Clipj (G)


Proof.  (Sketch)	Let	MσG (G)	=	(S, s0, Steps, Act , L)	and	MClipj (G)	=

j
(S', s' , Steps ', Act ', L'). Let A be an adversary of M
, AP ∗ = APj'
G
[clipj(G)]

0	σG (G)
σG (G)

and H ⊆ Pathfin(s0) × Pathfin(s' ) be the relation given by ∀α ∈ Pathfin(s0),
α' ∈ Pathfin(s' ), H(α, α') iff tr AP ∗(α)  tr AP ∗(α'). We define an adversary, A' of
M	j	and sets, D0, D1, D2, ... s.t. ∀n ≥ 0, Dn ⊆ Pathfin(s' ), by induction
ClipG (G)	0
over the cuts of A at depth i. We show ∀n ≥ 0,
IH1 For every α ∈ cutA , α' ∈ Dn, if H(α, α') then for every m < n there exists prefixes β ≤ α and β' ≤ α' such that β ∈ cutA(m), β' ∈ Dm and H(β, β').
IH2 If μn, μ' are the distributions over cutn(A) and Dn, respectively, defined by,
for α ∈ cutA(n), α' ∈ Dn, μn(α)= P(α) and μ' (α')= P(α') then μn ±H μ' .
n	n
IH3 For every α ∈ cutA , α' ∈ Dn, if H(α, α') then for every β ∈ cut A , β' ∈ Dn
s0	s0
such that β /= α and β' /= α', (β, α') ∈/ H and (α, β') ∈/ H.
Base case: Clearly cut A(0) = {s0}. Let D0 = {s' }. Immediately, IH1 and IH3

hold. By definition P(s0)= P(s' ) = 1. Therefore, μ0 ±H μ'
and so IH2 holds.

0	0
Induction step: Assume IH1, IH2 and IH3 hold for some n ≥ 0. Suppose

α ∈ cut A(n + 1). Then for γ ∈ PathA
a,μ
(s ), (a, μ) ∈ Steps(last (γ)), α = γ	s.

fin  0	−→
Since |γ| = n, γ ∈ cutA(n) and since μn ±H μ' by IH2, there exists γ' ∈ Dn such
that H(γ, γ') and by IH3 no other path is related to γ' or γ. We now define Dn+1
a,μ
by considering transition last (γ) −→ s. We need to consider four cases (we consider
just one here).
Case (i): Let leaf (j) denote the leaf vertices of level-1 vertex j. Suppose a ∈
∪i∈leaf (j)Act i. Notice that for process j to send a bmp request to one of its leaves (k say) it must have received a bmp request from its inner vertex and all its other leaves. This would imply, however, that A is not first-full with respect to j. Therefore, process j cannot send a bmp request to any of its leaves and so none of the leaves can reach a contention state with j. Thus, we only need consider non-probabilistic stutter actions w.r.t. AP ∗ i.e. for which μ(s)= 1 and L(last (γ)) ∩ AP ∗ = L(s) ∩ AP ∗. Thus, since we also have that γ is stuttering equivalent to γ' w.r.t. AP ∗, α and γ' are stuttering equivalent w.r.t. AP ∗. Let α' = α.
We let Dn+1 be the set of finite paths, {α'|α ∈ cut A(n), and α' is derived from α as described above} and extend A' by these paths. By the definition of this set, IH1, IH2 and IH3 are satisfied. We can show that the conditions of Lemma 2.5 are
satisfied by A and A' and it follows that A  A' w.r.t. APj	.	 
G

Proof of Theorem 5.1
Proof. From Lemma 5.4, Γ is reducible to Φ under the clipping reductions. Con- dition (i) of Definition 3.5 follows by definition of the action sets, variable sets and variable domains for MΓ. From Lemmas 5.5, 5.6 and 5.7, it follows that condition
(ii) of Definition 3.5 is satisfied for MΓ. Thus, MΓ is deterministically degenerative with base Φ under ClipΓ. By Lemma 5.2, Property 1 holds for all models over stars. Since Property 1 is unindexed with appropriately defined propositions, by Theorem 3.6, it is satisfied by MG for all G ∈ Γ.	 

Related Work
Certain classes of probabilistic systems have been verified for arbitrary number of processes [17] e.g. Arons et al. [3] present two methods for verifying liveness prop- erties with probability 1 over parameterised probabilistic systems by converting the probabilistic system to an ‘equivalent’ non-deterministic one. Duflot et. al. [10] consider the convergence of self-stabilising randomised protocols for a ring topology. They show that given a non-increasing measure on the state space of the model, if there exists a ‘distance’ measure between states and an ordering relation on the distance metric that satisfies certain conditions then it can be deduced that the pro- tocol will converge to some legitimate set of states with probability 1. The methods described above have only been applied to verification of qualitative properties i.e. properties that hold with probability 0 or 1. Parameterised model checking of quan- titative properties has not been widely addressed, although some manual proofs of quantitative properties have been devised. For example, Aspnes and Herlihy [4], by appealing to results from random walk theory, give a lower bound for the probability of all processes returning heads in a weak shared coin protocol.
Much work has been carried out on analysing the TIP (see for example, [15]). We mention [1] since it describes an inductive proof for a protocol that is similar to the TIP. The authors observe that only a leaf can initially transmit an “up” (bmp) message and it will then move to a “dead” state after which the protocol behaves as if started in the graph with that leaf deleted. They note that, continuing in this manner, eventually a graph with only one or two vertices will be reached. The protocol is not specified formally, whereas we use state-based verification. Our work extends that described above as it allows us to formally reason about quantitative properties over parameterised systems.

Conclusion and Future Work
We have described an inductive proof technique for a class of randomised distributed systems (modelled as MDPs) described as degenerative. The technique is an induc- tion schema over the underlying communication topology, represented by a set of graphs. The key idea is that topologies are reduced such that every adversary of a model of a system over some graph is stuttering equivalent to an adversary of a model of a system over a reduced graph. Reduction involves the removal of one or

more vertices from the communication graph. The base case(s) are those graphs that are not reduced. We applied this technique to the IEEE 1394 (Firewire) tree identify protocol showing that a class of QLTL\X properties that are true of the systems with a star topology will hold for a system with any acyclic topology. In this case, reduction is by removal of the leaf vertices of level-1 vertices.
Our technique is only applicable to degenerative protocols. These are, however, widespread in distributed systems e.g gossip-style multicast protocols such as [8], the weak shared coin protocol of Aspnes and Herlihy [4], the Itai Rodeh leader election protocol for rings [12]. These systems present further challenges because the pro- tocols degenerate probabilistically (whereas the TIP degenerates deterministically). This necessitates extending our induction schema. This is work in progress.

Acknowledgement
Douglas Graham was supported by a University of Glasgow scholarship.

References
Angluin, D., Local and global properties in networks of processors (extended abstract), in: Proc. ToC’80
(1980), pp. 82–93.
Apt, K. R. and D. C. Kozen, Limits for automatic verification of finite-state concurrent systems, Information Processing Letters 22 (1986), pp. 307–309.
Arons, T., A. Pnueli and L. D. Zuck, Parameterized verification by probabilistic abstraction., in:
FoSSaCS’03, LNCS 2620 (2003), pp. 87–102.
Aspnes, J. and M. Herlihy, Fast randomized consensus using shared memory, Journal of Algorithms 11
(1990), pp. 441–461.
Baier, M., C. Gr¨osser and M. a. Ciesinski, Partial order reduction for probabilistic systems, in: Proceedings of the 1st International Conference on quantitative and qualitative evaluation of systems (QEST’04) (2004), pp. 230–239.
Calder, M. and A. Miller, Using SPIN to analyse the tree identification phase of the IEEE 1394 high performance serial bus (FireWire) protocol, in: Maharaj et al. [15], pp. 247–266.

Clarke, E. M., O. Grumberg and D. Peled, “Model Checking,” The MIT Press, Cambridge, Masachusetts, 1999.
Demers, A., D. Greene, C. Hauser, W. Irish, J. Larson, S. Shenker, H. Sturgis, D. Swinehart and
D. Terry, Epidemic algorithms for replicated database maintenance, in: Proc. PoDC’87 (1987), pp. 1–12.
Donaldson, A. F. and A. Miller, Symmetry reduction for probabilistic model checking using generic representatives., in: ATVA 2006, 2006, pp. 9–23.
Duflot, M., L. Fribourg and C. Picaronny, Randomized finite-state distributed algorithms as Markov chains, in: J. L. Welch, editor, Distributed algorithms, LNCS 2180, 2001, pp. 240–254.
IEEE 1394-1995, “IEEE Standard for a High Performance Serial Bus Std 1394-1995,” Institute of Electrical and Electronic Engineers (1995).
Itai, A. and M. Rodeh, Symmetry breaking in distributed networks, Information and Computation 88
(1990), pp. 60–87.
Kemeny, J. G., J. L. Snell and A. W. Knapp, “Denumerable Markov Chains,” Graduate Texts in Mathematics 40, Springer-Verlag, New York, 1976, second edition.

Kwiatkowska, M., G. Norman and D. Parker, Probabilistic symbolic model checking with PRISM: A hybrid approach, International Journal on Software Tools for Technology Transfer (STTT) 6 (2004),
pp. 128–142.
Maharaj, S., J. Romijn and C. Shankland, editors, “Formal specification of the IEEE 1394 Tree identify protocol,” Formal Aspects of Computing 14(3), Springer-Verlag, 2003.
Miller, A. and M. Calder, Two verification results for networks of arbitrary size, Technical Report TR2006-220, University of Glasgow,Department of Computing Science (2006).
Norman, G., Analyzing randomized distributed algorithms, in: Validation of Stochastic Systems: A Guide to Current Research, LNCS (Tutorial Volume) 2925 (2004), pp. 384–418.
Puterman, M. L., “Markov Decision Processes: Discrete Stochastic Dynamic Programming,” John Wiley and Sons, New York, 1994, first edition.
Rutten, J., M. Kwiatkowska, G. Norman and D. Parker, “Mathematical Techniques for Analyzing Concurrent and Probabilistic Systems,” CRM Monograph Series 23, American Mathematical Society, Providence, Rhode Island, 2004.
Segala, R., “Modeling and Verification of Randomized Distributed Real-Time Systems,” Ph.D. thesis, MIT, Dept. of Electrical Engineering and Computer Science (1995).
Stoelinga, M., Fun with firewire: A comparative study of formal verification methods applied to the IEEE 1394 root contention protocol., Formal Asp. Comput. 14 (2003), pp. 328–337.
Vardi, M. Y., Automatic verification of probabilistic concurrent finite-state programs, in: Proceedings of FoCs’85, 1985, pp. 327–338.
