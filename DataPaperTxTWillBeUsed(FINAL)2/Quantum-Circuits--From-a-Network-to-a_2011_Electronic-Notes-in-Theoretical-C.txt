

Electronic Notes in Theoretical Computer Science 270 (1) (2011) 191–210
www.elsevier.com/locate/entcs

Quantum Circuits: From a Network to a One-Way Model
Larisse Voufo1
Institute for Scientiﬁc Interchange Foundation, 10133 Torino, Italy Department of Computer Science, Indiana University, Bloomington, IN 47405

Abstract
We present a translation from the standard network model of quantum computation to the one-way model of quantum computation. The translation is compositional, i.e., it preserves the structure of computations, which allows us to abstract the concrete realizations in a monadic abstraction layer.
We briefly review the By-Product and Measurement Calculus approaches to combining circuits in the one-way model, and show how the procedures can be expressed in the exact same notation, bearing a direct relationship with the representation of circuits in the standard network model, and using monads. Discussions on improving the abstraction yield us to introducing an alternative approach to combining circuits in the one-way model: a graphical one.
Keywords: Computation, Monads, Measurement Calculus, By-Product, Graphical


Introduction
There are several models and implementations of quantum computation, most no- tably: quantum Turing machines and automata, quantum circuit (or network) mod- els, adiabatic quantum computation, measurement-based (one-way) quantum com- putation, and topological quantum computation. Although all these models have been shown to be equivalent, their presentation typically “looks different.” In par- ticular, a given computation in the circuit model is likely to look rather different — structurally — when expressed in the one-way model.
In this paper, we study two of these models of computation in detail: the standard network (SN) model and the one-way (OW) model [11,3]. We study how computa- tions are expressed in each of these two models and how to translate from one model to the other in a compositional manner, i.e., while preserving the structure of the computation.

1 Email: lvoufo@cs.indiana.edu

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.01.018

Once defined, the compositional translation exposes common structures that are abstracted using the mathematical construction of a monad. In more detail, we provide an abstract model of quantum computation which can, with a choice of two parameters, be instantiated to either the SN model or the OW model. The construction gives an elegant way to translate from one model to the other, and potentially enables optimizations expressed in one model to be easily transferred to the other model. Throughout the translation, we pay close attention to its efficiency and ability to be systematic.
In addition, the construction allows us to introduce an alternative approach to reasoning about circuits in the OW model that is both graphical and allows to easily approximate circuits.
In the following, we assume a basic familiarity with notions of quantum mechanics and computation, fundamental differences between the circuit and the OW models, as well as with the relation of OW realizations to graphs. 2 In addition, for simplicity,
we will refer to the Pauli matrices σx, σy and σz as X, Y and Z, respectively. We will also precede any controlled operation with the letter C.

Composition in the One-Way Model
We begin with a review of the OW model of computation with a focus on composi- tion. More precisely, we are interested in understanding the various ways in which two OW computations can be combined to produce a larger OW computation.

Elementary One-Way Computations
The premise of the OW model is to drive the computation by performing several one- qubit measurements (most of them in parallel), on a highly entangled state (ideally given by nature). Often, due to the non-deterministic nature of measurements, the process results in some temporary state, encoding the desired result in a Pauli basis. To uncover that result, one thus needs to perform what is known as classical post-processing, which consists of applying the appropriate Pauli operators.
For example, take the realization of a Hadamard – H = √1  " 1 1 #, and given an
2  1 −1
input |ψ⟩ = , a ! (with a2 + b2 = 1), compute H |ψ⟩. Given an initial state preparation
that entangles 3 |ψ⟩ (qubit 1) with some ancilla qubit |+⟩ = √1  , 1 ! (qubit 2), i.e.,
2	1
resulting in,
 1


= (a + b) |+⟩ + (a − b) |−⟩
2
(a   b)  + + (a + b) 
√2	|1⟩	(1)

one simply needs to measure qubit 1 in the X-basis — signaling an outcome s1 of
0 (or 1) if the measurement had collapsed the state into the positive (or negative)

2 For more information, please see references [7], [10,9] and [1].
3 Through some Ising-type interaction simulated by CZ operations

eigenstate |+⟩ (or |−⟩) of X.
This propagates the information from the logical input – qubit 1, to the logical output – qubit 2, so that, if s1 = 1, then one must apply the Pauli X onto the result in qubit 2. To put it another way, one must apply Xs1 on qubit 2 after the measurement of qubit 1.
So, from Eq.(1), we get:	⎧⎨|+⟩⊗ a√+b |0⟩ + a√−b |1⟩  with probability 1	and s1 =0 
⎩|−⟩ ⊗ a√−b |0⟩ + a√+b |1⟩  with probability 1	and s1 =1 
after the measurement. Then, the correction brings us to	a√+b |0⟩ + a√−b |1⟩ = H |ψ⟩ .
Typically, to indicate the qubit acted upon by a given operation, one subscripts the operation with the index of the qubit. And to distinguish a reference to a logical qubit, from that to a general one (including ancillae), one simply surrounds the index of the logical qubit with braces. For instance, we say that the H-procedure described above realizes the unitary H[1] to indicate that the logical input value
is initially stored in qubit 1.  In addition, while Xs1 indicates the correction on
the actual qubit 2, Xs1 indicates a correction on the logical output that qubit 2
corresponds to.
When it comes to composing circuits, there are several approaches that vary based on the understanding and expression of the OW procedure we just described above. Nevertheless, they all share a common understanding: Circuits compositions must be standardized before being applied to the input.

Composition
Take the composition of two H’s into an Identity I =  1 0 , that is, attempting to
0 1 
realize  I[1] = H[2] · H[1] .
Taken straightforwardly, this applies one H-procedure after another, making the output from the first application become the input into the second. Notably, it in- terleaves sequences of entanglement, measurement, and correction operations. Even though the process returns a valid result, it is not the behavior we desire.
Instead, by the definition of the OW procedure, we want the overall procedure for I to be in some standard form that has all entanglements coming first, followed by all measurements, and then followed by all corrections.
This standardization process differs from one approach to the other. From cur- rent literature, we find two main such approaches: The original – Raussendorf et al.’s By-Product (BP) [11], and its automated generalization – Danos et al.’s Mea- surement Calculus (MC) [3].

The By-Product Approach
This approach seems mostly mathematically grounded. It tends to reason about OW circuits in terms of the unitaries they realize before the corrections have been applied, and in association with the necessary entangled state preparation followed by the sequence of measurements. It then calls the conjugate transpose of the corrections that have yet to be performed “ by-product ” operators.
For example, for the H-procedure above, the realized unitary of concern is


ow	s1

where Xs1
H [1] = X[2] · H[1] ;
is the BP operator.  Then, the associated preparation is constituted

of the initial entanglement between qubits 1 and 2 (after their tensor product);
while the measurement pattern is constituted of the single measurement Mx. (Note that a measurement is typically super-scripted with an indication of the basis it is measuring in. In this case, we are measuring in the X-basis.)
To construct the realization for I, one needs to standardize
ow	s2	s1	ow	˜

I [1] = X[3] · H[2] · X[2] · H[1]	into a form where I˜ is the BP operator.
I [1] = I · I[1] ;

Concurrently, one must also reorganize the sequence of preparations and mea- surements, from both sub-circuits, consistently.
By some principles of graph state properties and algebraic manipulations (e.g. the stabilizer formalism), we are able to propagate the previous BP operator Xs1

over the subsequent unitary H
, and find	ow
= Xs2 · Zs1 · H  · H	;

[2]
yielding the BP operator I˜ = Xs2 · Zs1 .
I [1]
[3]
[2]
[2]
[1]

Concurrently, we find we can simply combine the preparations and measure- ments from the sub-circuits directly. Thus, for I, the preparation consists of the entanglement of qubits 1 and 2, then of that of qubits 2 and 3. Meanwhile, the measurements consist of those of qubits 1 and then 2, in the X-basis.
As a general observation, since the overall composition and standardization (C&S) process here manipulates unitaries, it is not simple to systematically im- plement it in a computer program.
To make matters worse, non-Clifford operators 4 , i.e. those operators that do not
map (sequences of) Pauli operators to one another, add complexity, as they cause the resulting sequences of measurements to have to be revisited. Essentially, their presence in a composition causes the final realized unitary to be different from that desired, by some set of defining parameters. And as a result, one must substitute those defining parameters in accordingly in order to recover the desired unitary.
The overall procedure has time complexity quadratic in the number of sub- circuits and linear in the input size.
Things get simpler than this under the next approach.

The Measurement Calculus Approach
This approach defines a number of commands to express each entanglement, mea- surement, and correction in a sequence. We will be referring to such sequence as

4 For instance, take a general unitary rotation Urot (α, β, ζ)= Ux(ζ) · Uz (β) · Ux(α), with Ux (α)= e−i 2 X
and Uz (α)= e−i 2 Z .
When mapped to Pauli operators, it undergoes some modifications according to the following:

Urot (α, β, ζ) · X = X · Urot (α, −β, ζ) . Urot (α, β, ζ) · Z = Z · Urot (−α, β, −ζ)
Clearly, for some parameter values – such as α = ζ = 0 and β = ±π for a ±πPhase = " 1 0 #, either

2	2
Urot (α, β, ζ) /= Urot (α, −β, ζ) or Urot (α, β, ζ) /= Urot (−α, β, −ζ).
0 ±i



Eij Xs
−→ XsZsEij
AkZs
−→ ZsAk, with A /= X and A /= Z

Eij Zs

−→ ZsEij

t Mα s −→ S tMα s

Eij Ak −→ AkEij , with A /= E
XsSt

−→  StXs[t+si/si ]

t Mα sXr

−→ t Mα s+r
j  i


i  j
s[t+s /s ]

t Mα sZr

−→ t+r Mα s
j  i
t	 s
i  j
t[r+si/si ] 

 s[r+si/si ]

i
AkXs
i	i
−→ XsAk,

α	r −→ Sr	α

with A /= X and A /= Z	(xii) ⊥ S −→ ⊥


Figure 1. Standardization passes.
“CmdSeq”. For now, let us describe its structure in more detail.
We have already seen the measurement command in the form of Mα (q represents a qubit). An extension of this representation accounts for cases where some angle
α′ = (−1)s α+πt, with s, t ∈ Z. Then, the measurement is represented as:	Mα' = t Mα s .
Correction commands are of the form Xs we saw earlier, except that one can also use Z in place of X. For entanglement, a notation Epq indicates the entanglement between two qubits p and q.
There is also a shift command Ss used to express and manipulate dependencies
incurred by applying Z-corrections before measurements.
The command sequence is part of a larger representation for an entire procedure
— a.k.a. patterns, that includes the set of qubits (V ), and logical inputs (I) and outputs (O):
( V, I, O, CmdSeq ) .
For	example,	the	H-procedure	above	is	now	represented	as
 {1, 2} , {1} , {2} , Xs1 MxE12 .
Here, the standardization into I is now a matter of applying a set of symmetric passes, such as the ones in Fig. 1, on the composition of the command sequences for the two H-operations involved.  Xs2 MxE23Xs1 MxE12.
3	2	2	1
Concurrently, the remaining components of the pattern also needs to be updated accordingly.
After Passes i, iii, iv, and vii, we obtain the following as the pattern for I:
 {1, 2, 3} , {1} , {3} , Xs2 Zs1 MxMxE23E12  .
In a general perspective, the MC process simplifies the BP approach out of the effects from non-Clifford operators ( cf. end of Section 2.2.1). A basic procedure is described in Alg. 1. Essentially, Steps 1 and 2 of the new procedure constitute its core part, while Step 3 is optional; since it only serves in simplifying patterns, by shifting dependencies induced by Z-corrections out of consideration when specifying measurements (cf. Passes v and x).
Not accounting for Step 3, the time complexity is linear in the number n of sub- circuits, and cubic in the input size s. The inclusion of Step 3 makes it quadratic in (n ∗ s).
So, to recap, no matter the choice of approach, during a composition step, we



Algorithm 1 A Basic C&S Procedure.

Standardizing C M E C M E
into some form
˜ ˜ ˜  ˜
, with each ∼-decoration indi-

cating a change in the pattern.

Propagate each element of E2 backwards, across C1	−→ E = E2 · E1 ; C˜

Propagate each element of M2 backwards, across C˜	−→ M = M˜ · M1 ; C˜
; C = C2 · C˜

For each M:
Introduce shift	CS M˜ E 
Propagate the shift forward, across the remaining part of M and C,

dropping it at the end of the command sequence.	−→
C˜ M˜ E 



Ex, Mx, and Cx respectively represent the sequence of entanglement, measurement and Pauli correction operations of two standard sub-patterns 1 and 2, with x indicating the sub-pattern that is acted upon.


have a notion of two given sub-realizations Ri and Rj that need to be combined into a larger realization R. The process requires that the composition of the sub- realizations be standardized before we can move on. Particular to each approach are both the representations for the realizations and the way that the C&S procedure is performed. Overall, the MC approach addresses the efficiency and systematization needs of our translation better.
However, as the sizes of circuits increase, these patterns can quickly become too tedious to manipulate, or simply reason about, at a high level. For instance, simply consider generating the command sequence for a CCZ operation, when it is expressed in terms of controlled rotations. Fig. A.1 in the Appendix (A) gives us a pretty good idea.
Consequently, one has to wonder whether there would not be a better way to represent these patterns (and any model-specific quantum computation in general), in a way that hides some implementation details and mostly reason about the circuits in terms of input/output.
As it so happens, this is very possible if one defines an appropriate monad for computations in the OW model. In a broader spectrum, an abstraction using this concept of monads provides a unified framework for understanding and reasoning about quantum computation in general, across differing models.
We are now moving on to present our monadic abstraction.

A Unifying Framework for Quantum Computation
Again, take the composition of two H-operations into a I-operation.

The Representation
In quantum mechanics, under the vector-state approach,

I = " 1 0 # = √1  " 1 1
# · √1  " 1 1
# = H · H . 

0 1	2  1 −1	2  1 −1
That is, given a quantum state |ψ⟩, one can obtain the same state after two consecutive applications of H:	I |ψ⟩ = H (H |ψ⟩) .
We express this as


I (A)	=	H (A)	 =	\ (B)	→
H (B)	 =	\ (C)	→	(2)
return (C)
If A represents the logical input, then B represents the logical output of the first application of H. Then, B becomes the logical input of the second application, and C represents the logical output of the entire operation. Naturally, both A and C refer to the same value. The sequencing is expressed with the arrows →. We will define
  = and return shortly.
The application of an operation to a given state is a matrix-vector multiplication.
And two consecutive applications correspond to a matrix multiplication.
The SN model provides a diagrammatic perspective for understanding and in- terpreting quantum mechanics. Here, matrices are now represented by some labeled squares, while the vectors acted upon are quantum registers represented by lines. For example, with time flowing from left to right, the operations we are working with are now represented as follows:
I    	and   H    .
It is common practice to label each line with a name for the register or an indication of the value it holds at some given time 5 .
To combine operations, or multiply their
matrices, one simply connects output regis-	 ters from one operation to input registers into

another one, as in Fig. 2 for our ongoing ex- ample.
Figure 2.	Identity as Two Consecutive Hadamards, in the SN model

Our abstract expression is certainly the same as in Eq. (2), even though our underlying representation has changed.
Under the OW model, our abstract expression is still the same as in Eq. (2). However, due to the need for the standardization of results, one needs to remember previous realizations at each sequential step; which makes things a little bit trickier. To better illustrate this, let us first generalize the abstraction, by presenting the concepts of using monads.

The Unified Framework: The Monads
In Eq. (2), =(bind) and return are, in fact, monadic operations that abstract the representation of computations away from their implementation or meaning; encap- sulating each possible implementation (or meaning) in a so-called “monad”. While we maintain the exact same notation across different models, the model-specific implementation details are specified by simply changing the underlying monad.

5 For multiple registers, it suﬃces to display multiple lines in parallel, and apply individual or collective operations on them. Varying other conventions are used to represent controlled operations, some special operations such as negations, and operations over multiple registers. Please see Chapter 3 of [10] for a general example.

In earlier work, A. Sabry [12], then Vizzotto et al. [14] used these operations (as well as arrow -constructors), to relate “unusual” features of quantum computing,
i.e. quantum parallelism and measurement, to monads (and arrows). Herein, we
exploit the idea to unify differing approaches to reasoning about quantum circuits, giving an approach that centers around considering logical inputs and outputs of operations solely.
Before we move further, it helps to briefly describe the concept of a monad. Since we are using its semantic constructions from the theory of Programming Languages, we will be defining it from that perspective. 6

Brief Review
Basically, the idea is as follows:
Take an element of type A, and define some “context” m for it. Within the context, elements are now of type m A.
For example, in our case herein, we take a classical bit, and the context of the bit is its “quantumness”, hence defining a qubit. Type A is Bit, whereas mA is
Qubit.
return lifts given elements into some monadic layer. In other words, it takes an element of type A and returns a corresponding element of type m A. We say that return is of type A → m A.
In our case, the type is Bit → Qubit, and this means producing the quantum equivalent of given classical bits. So,
return 0= |0⟩, return 1= |1⟩, and more generally  return A = |A⟩.
	=(bind), on some input of type mA and special function f of type A → m B, binds f to the input elements in a way that simulates the application of some quantum function f∗, of type mA → m B. We say that = is of type mA → (A → m B) → m B, and f∗ = ( = f ) , f .
For example, to simulate the application of a H-matrix in the SN model – as taking in a vector and returning another vector, the H used in our abstraction (Eq. (2)) is defined as follows – taking in a bit and returning a vector:
H 0 =	|+⟩ .	(3)
H 1 =	|−⟩
Concurrently,  = may be defined as follows 7 :
, a ! = f = (a ‘* ’ (f 0)) ‘+’ (b ‘* ’ (f 1)) .	(4)

From Eqs. (3) and (4), applying ( = H) on input |ψ⟩ is equivalent to multiplying it with the corresponding matrix since


 1 (a |+⟩ ‘+’ b |−⟩) = √2
a + b a − b

= H |ψ⟩ .




6 A more mathematically-based definition of a monad is provided by Category theory.
7 ‘* ’ denotes a scalar product, and ‘+’ a vector addition.


Figure 3. Monadic Operations for the SN model.

Importantly, there are three laws that must be satisfied in order to ensure the consistency of computations that are based on these monads:
Left-identity: ma  = return = ma
Right-identity: return x = f = f x 
Associativity: (ma  = f )  = g = ma  = (\a → (f a)  = g)
Now, we can clearly describe our abstraction.

The Monadic Abstraction
For our abstraction herein, we basically have return lifting an element A of the computational basis (classical) to the quantum layer – i.e. to |A⟩. However, whenever appropriate, it can lift the information further to a model-specific quantum layer,
e.g. the OW model. (We will come back to the latter shortly.)
For now, to each expression |A⟩ = \A → Op A — or equivalently |A⟩ = Op, we associate an operation QOp that simulates the underlying matrix multiplication as in Eq. (4). Then, based on this association, we illustrate how one could define the monadic operations for the SN model in Fig. 3.
The implementations resulting from such abstraction constitute a level of im- plementation details hidden away by the abstraction. In reality, these details are often tedious to manipulate, as per our earlier consideration for expressing the CCZ operation under the MC approach to the OW model.  But, given this ab-

straction, we can now express it simply as in Fig. 4.
Figure 4. CCZ – Monadic Abstraction.

On that note, let us now take a look at the OW model, and define its monadic layer as well.

The One-Way Model
We start with an expression
|A⟩  = Opi ;	(5)
where ( = Opi) corresponds to the application of some OW realization Ri — and some operation QOpi. This is trivial, as one can just go ahead and apply the said realization, and still conform to the OW procedure, by definition.


Figure 5. Monadic Operations for the OW model.


Now consider taking an output B from Eq. (5), and apply it to another real- ization Rj as in
|A⟩  = \ (A) →  Opi (A)  = \ (B) →	(6)
Opj (B)  = \ (C) →	(7)
return (C)

In the Step represented by Eq. (7), one must know about the previous Ri, in order to standardize its composition with Rj before applying the result onto the initial input |A⟩. So, in some sense, the output from the first application must incorporate both the initial state and previous realization(s) somehow.
Our definition of the monadic layer as it stands now (Fig. 3) — with return A = |A⟩, cannot accomplish that. One must at the very least lift values – say A – further to {|A⟩ ; R}; with R representing the value of the C&S-ed realizations up to the current position.
As a result, by the definition of =, at a Step such as (7) of a composition, the corresponding QOpj – before standardization, will return |C⟩ ; Rj .
Then, say we have a function ‘extract_from’ that takes in QOpj and returns Rj .
We define the monadic layer in Fig. 5.
As it turns out, in Programming Languages, the behavior described here corre- sponds to some special types of monads whose roles center around maintaining and manipulating global data, e.g., the Output and State monads.
To keep things simple, at each monadic step, we do not update the input state, but rather simply pass it along; leaving it up to later considerations to apply the associated C&S realization onto it.
Importantly, note that for all the different OW approaches we reviewed earlier in Section 2.2, the format for the monadic abstraction looks exactly the same. The only difference is in the representations of the realizations and associated C&S procedure. However, we do have to wonder whether one could improve definitions of monadic layers somehow; and if so, what factors the process could involve. In the upcoming Section, we consider improving our OW monadic abstraction defined above. The process unveils a set of conditions for abstraction of the C&S procedure, which comes with applications in defining additional approaches to reasoning about circuits in the
OW models.

For each interleaving qubit q,
A X-correction always introduces shifts on the neighbors (within circuit 2) of the interleaving qubit.
Meanwhile, the measurement
either simply remains unchanged, if it is in the X-basis,
or remains unchanged AND introduces a shift on q, if it is in the Z-basis,
(C:) or becomes dependent on the correction’s signals, otherwise.
A Z-correction always leaves the measurement unchanged AND introduces a shift on q.
Figure 6. Basic Conditions for Abstraction.

Improving Abstractions
Two considerations are important, especially for translating circuits. First, we want to reduce the “context” that is being manipulated as a monad. Second, we want to improve the implementation of =.

The C &S conditions
By observing the effects of standardization passes on the final pattern, as the basic C&S procedure (Alg. 1) is executed, we are able to discard those input (from subsequent applications) and output (from previous applications) qubits that are not outputs-turning-inputs, or interleaving qubits as we call them, from consideration.
Further, when realizations are considered to be simplified prior to executions of the C&S procedure, we also discard previous entanglements and measurements, as they no longer have any effect on subsequent applications (cf. ∼-decorations in Alg. 1).
Essentially, we come down to the set of conditions in Fig. 6 as a standard that any C&S procedure must meet.
Following the basic procedure sans Step 3, the conditions inform one of where shifts may be introduced so one can consider either propagating them — execut- ing the optional Step 3 — for each q that is measured, or leaving them as Z- dependencies 8 otherwise.  Herein, the introduction of a shift refers to that of a
Z-correction that eventually translates into a Z-dependency on the associated mea- surement (Pass v), which is then shifted out of the measurement pattern (Pass viii). Note that, due to the latter, our reasoning is biased towards patterns being simplified
as in resulting from Step 3, and we use the term “dependent” to mean “ X-dependent”
(cf. Pass vi).
In any event, based on the C&S conditions, we abstract and improve our C&S procedures even more. Alg. 3 from the Appendix (B) describes the abstracted C&S procedure, along side a discussion of its workings.
The time complexity is linear in the number of sub-circuits, and quadratic in the input size s, with or without accounting for Step 3 of the basic C&S procedure.


8 By Z-dependencies, we mean the effect of propagating Z-corrections over measurements (Pass v).


Figure 7. Simplified Monadic Operations for the OW model.
The simplified monad
With respect to our earlier monadic abstraction, we redefine our return as lifting A to {|A⟩ ; C}; while =, on input {|A⟩ ; Ci}, now follows the abstract C&S procedure to combine Ci and Rj . Fig. 7 illustrates the new monad.
Note that, now, we can consistently apply the entanglement and measurement parts of patterns onto the input state, and then pass on the updated values; only leaving the application of the final sequence of corrections up for later consideration (rather than the whole realization as in previously).
Other applications of the C&S conditions introduce alternative approaches to the OW model, either extending or reducing from the abstracted C&S procedure. For example, we propose an approach that is based on a particular graphical repre- sentation for OW realizations, one that would allow one to consistently approximate circuits. We later on use this approach to illustrate our circuits translations from the SN model (Section 5).

A Graphical One-Way Approach
Definitions:
We start with a representation for different types of qubits, e.g., ancillae, logical inputs/outputs as in Fig. 8
Two entangled qubits are connected by a “wire” (simple line) as in . Whenever possible, reduce the usage of “wires” by gluing the two qubits side by side: .
In a broader view, the prospect of this exercise is for the final realization to vi- sually indicate how close it is to being a

cluster state.
In all, this representation is an adapta-
Figure 8. Some Qubits.

tion from Raussendorf et al.’s 2-dimensional lattice grid design [11], extended with
a finer characterization for qubits, as well as the following.
To combine two circuits 1 and 2, introduce directed arrows (  ) to indicate which output qubit from circuit 1 is becoming which input qubit from circuit 2.



Algorithm 2 A Reduced Graphical C&S Procedure.
For each interleaving qubit q	(O1  I2):
Consider the only measurement mq and the corrections cq .
If one of the corrections satisfy (cq == Xr) and (mq == t Mα 0) : 

Else :
Leave the measurement type alone, BUT convert the representation of q from input/output mode to ancilla.

Only adaptive measurements, and measurements in X, Y , and ±π , are considered.

The standardization procedure then reduces the entire circuit representation by consistently eliminating the occurrences of arrows; while respecting the abstraction conditions in Fig. 6.
In any event, as we will see in the upcoming practical example (Section 5), an important use for this kind of visual representation for graph states, which can very quickly grow complex, is to get an approximation of the result of their combination when one can afford to overlook certain defining details. For example, let us look move onto the next Section.

Approximating Combinations: A Reduced Scheme
Whether one is missing information about, or simply less interested in, measure- ments outside of a restricted scope or the exact Pauli corrections, the following framework will always derive the entanglement and basic measurement patterns of a final circuit.
Essentially, and similarly to what one might find in common papers – e.g. Raussendorf et al.’s [11], we restrict our attention to whether measurements are
adaptive and to the particular measurements in X, Y , and ±π when they are not.
As a result, based on the abstraction conditions, interleaving qubits with adaptive (i.e. dependent) measurements need no further analysis.
In fact, our whole concatenation procedure boils down to the procedure in Al- gorithm 2. Step i checks whether the condition labeled (C:) is satisfied, if the measurement is not already adaptive. The time complexity is a linear gain in the input size s – over the abstract procedure, and a linear gain in the number n of sub-circuits – over the BP approach.
Shall one decide to proceed ahead with Step 3 of the basic C&S procedure (Fig.
1), one can simply assume that signals accumulate in increasing order and thus never cancel out. In addition, when information about the exact corrections on an interleaving qubit is missing, it suffices to assume that it is at least X-corrected.
For illustration, we construct a representation for a CCZ in Fig. 9, from its abstracted representation in Fig. 4.

Generalizing the Scheme
The graphical approach defined herein is equivalent to the MC, since it is ultimately based on its patterns and their composition. The explanation lays in the following.


	
(a)	(b)

Figure 10. 6-qubit addition circuit (a), and its higher-parallelism version (b). [Pictures from [2]]


As one extends the reduced graphical representation (Section 4.1) to include more specific information about the measurement angles, types of corrections , e.g., X or Z, or existing signals, one moves into a more general representational framework. Conceptually, one extends the representational reasoning accordingly, modifying the associated concatenation procedure to eventually mimic the MC’s completely.


Practical Example: A (new) One-Way Quantum Rip- ple Carry Addition Circuit
Consider translating the ver- sions of Cuccaro et al.’s “new quantum ripple-carry addition circuit” [2] in Fig.
10. Both circuits reduce the number of ancillae needed in typical ripple-carry addition circuits (cf. [13,6,5]) down to a single one from a lin- ear bound. If we don’t count negations, they also lower the number of gates needed, relatively by the size of the input. Then, the second cir- cuit optimizes the first one

by lowering the depth, and hence producing a version
Figure 9. Building a CCZ gate from controlled rotations.

with higher parallelism. Essentially, the second version re-arranges the gates in the circuit representation, compacting them to fit as many as possible within a given time-frame, after replacing the UMA gate with an appropriate version.
Following a building-block approach, we start our combination procedure from


	
(a) From general graph-states	(b) From cluster-states
Figure 11. Building the MAJ gate.
deriving realizations for the MAJ and UMA (both versions 9 ) subdivisions, using those for some elementary CX and CCX — or H, CZ and CCZ .
For a general graph-state realization, we can use the CCZ-realization we generated in Fig. 9. However, representations built on top of this quickly become indiscernible. For instance, just take a look at the realization of a MAJ circuit in Fig. (11a).
Luckily, we can get an alternative CCZ-realization from Raussendorf et al. [11].
However, this comes without explicit information about the angle of adaptive mea- surements, nor the signals, nor corrections in use.
We are thus left with having to apply our reduced graphical concatenation pro- cedure. The MAJ-realization obtained here (Fig. 11b) is not exactly a cluster-state, but it is close. We eventually build up the 6-qubit addition translations in Fig. 12
from the following 10 .
First, we form 1-qubit addition translations from each MAJ-UMA combination. Then, following the structure of the circuit in the SN model, we link logical inputs and outputs appropriately, using double-Hadamard transformations 11 whenever appro-
priate. The latter allows to (1) keep a sense of legibility from a visual perspective, and (2) maintain the cluster-like structure of the realizations.

Analysis: Optimization(s) Lost in Translation
Even though we are missing some information from the underlying CCZ- realization, we can still approximately assess the complexity difference between the two versions of the circuit in the OW model. First, we assume that all parts that correspond to MAJ or UMA subdivisions can run in parallel. Then, we take each occurrence of adaptive measurement on the underlying CCZ-realization as to be ex- ecuted in a separate round of measurements. It turns out that whether we translate the original addition circuit (Fig. 10a), or its higher-parallelism version (Fig. 10b), the resulting OW realizations both have a low constant bounded depth and the difference in extra ancillae is negligible.
This does not seem to be a very surprising result. In fact, as Raussendorf et al.

9 Note that in our translation of the higher-parallelism version of the circuit, we do not need to re-arrange the gates as well since that would not change the number of elementary gates we are working with.
10 Certainly, this process is extensible to n > 6-qubit addition translations.
11 Essentially composing with the identity several times.


 
(a)	(b) Higher-parallelism version
Figure 12. One-way realizations of Fig.10.

[11] points out, optimizations that manipulate gates in the Clifford group can only affect the spacial and operational resources while those involving changes in non- Clifford operations affect the final depth. Further, Danos et al.’s “no dependency theorems” state that operations in the Clifford group can be associated with patterns in which measurements are only in either the X or Y bases [3]; which can all be performed in a single round of execution. Therefore,
Circuit optimizations performed under the circuit model cannot be expected to make a considerable diﬀerence under the one-way model, unless they at least involve changes in non-Cliﬀord operations.
For our example herein, the only non-Clifford effect we can be concerned with comes from the CCZ, as their decomposition in terms of controlled rotations includes C(±π )Phase — and C(±π )Phase are not in the Clifford group.
2	2
Comparing the complexity of OW realizations against the SN ones, there is not a question that the translation takes a linear procedure down to a constant one.
The only other consideration is the physical limitations on applying the OW realization, which may have one split the resulting graph into several subdivisions to be applied consecutively.

Conclusion: Towards a Complete Translation Frame- work
We considered the OW composition stage of translating circuits from the standard circuit (or network) model to the one-way one. With focus on improving the effi-

ciency and systematization of the translation, we considered two main approaches from current literature, and abstracted them using the mathematical concept of monads; more generally, proposing an abstract model of quantum computation.
The abstraction allowed us to define some basic conditions for composing circuits in the one-way model, independently of any approach. These conditions later on served as a basis for improving the abstractions in the one-way model, including introducing an additional approach based on a graphical representation of circuits. This approach addressed the occasional need for circuits approximation and was thus perfect for the translations in our practical example, where gathered information were incomplete.
Notable here is that this idea of abstracting using monads can extend to other models, beyond the standard and the one-way models focused on here. Further, given recent developments on a generalization of monads called arrows [8,14], we find it potentially helpful to consider using those constructions as well.
In any event, another consideration that may be worthwhile in the long term is to define the graphical approach more formally, clearly separating the reduced monadic layers, from more general ones; perhaps modeling the additional(completing) infor- mation as monadic (or arrow-based) effects.
On an efficiency and effectiveness note, one could add optimization passes to the translation procedure, and consider the different ways that they play out in the overall complexity, with respect to the class of practical/realization needs they meet. Last but not the least, one could also consider comparing the complexity of this compositional approach to translation against alternative ones such as the phase-
map decomposition [4].
It is our hope that all these considerations would potentially lead us to a com- plete translation framework, that efficiently and systematically generating circuit realizations with immediate practical use.

Acknowledgement
We would like to thank all direct and indirect contributors to this work. We ap- preciated fruitful inputs from the Quantum Information Unit group at the Institute for Scientific Interchange, as well as the Programming Languages group at Indiana University. We would especially like to thank Profs Amr Sabry and Gerardo Ortiz for their continued guidance throughout this work.

References
Browne, D. E. and H. J. Briegel, One-way quantum computation - a tutorial introduction (2006).
URL  http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/0603226

Cuccaro, S. A., T. G. Draper, S. A. Kutin and D. P. Moulton, A new quantum ripple-carry addition circuit (2004).
URL  http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/0410184

Danos, V., E. Kashefi and P. Panangaden, The measurement calculus (2004). URL http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/0412135


de Beaudrap, N., V. Danos and E. Kashefi, Phase map decompositions for unitaries (2006).
URL  http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/0603266
Draper, T. G., Addition on a quantum computer (2000).
URL  http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/0008033

Draper, T. G., S. A. Kutin, E. M. Rains and K. M. Svore, A logarithmic-depth quantum carry-lookahead adder (2004).
URL  http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/0406142
Ekert, A., P. Hayden and H. Inamori, Basic concepts in quantum computation (2000).
URL  http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/0011013
Hughes, J., Generalising monads to arrows, Science of Computer Programming 37 (1998), pp. 67–111.
Mermin, N. D., “Quantum Computer Science: An introduction,” Cambridge University Press, Cornell University, New York, 2007.
Nielsen and Chuang, “Quantum computation and quantum information,” Cambridge University Press, New York, NY, USA, 2000.
Raussendorf, R., D. E. Browne and H. J. Briegel, Measurement-based quantum computation with cluster states, Physical Review A 68 (2003), p. 022312.
URL  http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/0301052

Sabry, A., Modeling quantum computing in Haskell, in: Haskell ’03: Proceedings of the 2003 ACM SIGPLAN workshop on Haskell (2003), pp. 39–49.
Vedral, V., A. Barenco and A. Ekert, Quantum networks for elementary arithmetic operations (1995).
URL  http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/9511018

Vizzotto, J., T. Altenkirch and A. Sabry, Structuring quantum eflects: superoperators as arrows, Mathematical. Structures in Comp. Sci. 16 (2006), pp. 453–468.

Defining the pattern for a CCZ operation
Fig. A.1 illustrates the translation from the pattern definition in Fig. 4 to that of Danos et al. [3], making an explicit use of the trivial pattern
T (1) = ( {1}, {1}, {1}, ⊥ ) .




Abstracting the C&S procedures
Based on the abstraction conditions from Fig. 6, we modify the basic C&S procedure from Algorithm 1 into that in Algorithm 3. Note that this one primarily deals with interleaving qubits.
Essentially, Step 1 of the basic procedure is translated into a constant Step 1a
here.
Steps 2 and 3a are translated into Steps 3 and 4; while Step 3 is now infiltrated within the new Steps 2 and 3 — precisely Steps 2a and 3d, labeled [S].
When the procedure is extended to concatenating n circuits, the new Step 2a can
be performed only once, during the first round of iteration.
Both [S]-Steps optimize the old (basic) Step 3b by eliminating unnecessary traver- sals during shift -propagation steps.
In the new Steps 3 and 4, the number of measurements M2’s traversals over cor-
rections C˜ is reduced by the number of potential extra corrections resulting from

π
CCZ {A0,B0,C0} = (T{B4} ⊗ C 2Phase{A0,C2}) · (∧X{A0,B3} ⊗ T{C2})
π	π
·(T{A0} ⊗ C(− 2 )Phase{B2,C1}) · (∧X{A0,B1} ⊗ T{C1}) · (T{A0} ⊗ C 2Phase{B0,C0})
= Zsi4 +sg4 +se4 +sc4 +sC2 +sh4 +sd4 +sb4 +1Xsj4 +sh4 +sf 4 +sd4 +sb4 Xsa4 ZsA0 +se4 +sc4 +sd4 +sb4 ·

C3
x	−	x	y	x


y	x	y
C3
x   − π sb4  x	−
A1  A1




Ea4A1EA0a4Ej4C3Ei4j4Eh4i4Eg4h4Ef 4g4EA0f 4Ee4f 4Ed4e4Ec4d4Eb4c4 EC2b4Eb4A0
sb3 sB3 sB3  x	x
· XB4 ZB4 ZA0 Mb3MB3EA0b3EB3b3Eb3B4

si2 +sg2 +se2 +sc2 +sC1 +sh2 +sd2 +sb2  sj2 +sh2 +sf 2 +sd2 +sb2
sa2
sB2 +se2 +sc2 +sd2 +sb2 +1

· ZC2	XC2	XB3 ZB3	·

π
x	x	y	x

y	x	y
x π sb2  x	π
	

Ea2B3EB2a2Ej2C2Ei2j2Eh2i2Eg2h2Ef 2g2EB2f 2Ee2f 2Ed2e2Ec2d2Eb2c2 EC1b2EB2b2
sb1 sB1 sB1  x	x
· XB2 ZB2 ZA0 Mb1MB1EA0b1EB1b1Eb1B2

si0 +sg0 +se0 +sc0 +sC0 +sh0 +sd0 +sb0 +1  sj0 +sh0 +sf 0 +sd0 +sb0
sa0
sB0 +se0 +sc0 +sd0 +sb0

· ZC1	XC1	XB1 ZB1	·

x	−	x	y	x

y	x	y


x   − π sb0  x	−

Ea0B1EB0a0Ej0C1Ei0j0Eh0i0Eg0h0Ef 0g0EB0f 0Ee0f 0Ed0e0Ec0d0Eb0c0 EC0b0Eb0B0
= ZξC3 XχC3 Xsa4 ZξA1 XχB4 ZξB4 ·

C3	C3
x	−

A1  A1	B4	B4
x	y	x	y	x	y

x   − π sb4 +μC2	x

— π μC2

Mx Mx  ·

b3 B3
x π sb1 +sa0  x	y	x

y	x	y
x  π μc2 x 
	

π  μC1

Mx Mx  ·

b1 B1
x	y	x	y	x

y	x	y


x   − π sb0  x	−







with
Ea4A1EA0a4Ej4C3Ei4j4Eh4i4Eg4h4Ef 4g4EA0f 4Ee4f 4Ed4e4Ec4d4Eb4c4 EC2b4Eb4A0  ·
EA0b3EB3b3Eb3B4 ·
Ea2B3EB2a2Ej2C2Ei2j2Eh2i2Eg2h2Ef 2g2EB2f 2Ee2f 2Ed2e2Ec2d2Eb2c2 EC1b2EB2b2 ·
EA0b1EB1b1Eb1B2 ·
Ea0B1EB0a0Ej0C1Ei0j0Eh0i0Eg0h0Ef 0g0EB0f 0Ee0f 0Ed0e0Ec0d0Eb0c0 EC0b0Eb0B0



μC1 =	sj0 + sh0 + sf 0 + sd0 + sb0 μc2 =	sb2 + sb1 + μC1 + sa0
μC2 =	sj2 + sh2 + sf 2 + sd2 + sb2 + μC1
⎪⎨ξA1 =	se4 + sc4 + sd4 + sb4 + sB3 + sB2 + sj2 + sh2 + sf2 + se2 + sc2 + sb1 + sa0 + sA0 +1	.

χB4
⎪
=	sb3
+ sa2
+ sb1
+ sa0

ξB4 =	sB3 + sB2 + se2 + sc2 + sd2 + sb2 + sB1 + sb1 + sB0 + sj0 + sh0 + sf 0 + se0 + sc0 + sa0 χC3 =	sj4 + sh4 + sf 4 + sd4 + sb4 + sj2 + sh2 + sf 2 + sd2 + sb2 + sj0 + sh0 + sf 0 + sd0 + sb0 ξC3 =	si4 + sg4 + se4 + sc4 + sh4 + sd4 + sb4 + sC2 + sj2 + si2 + sg2 + sf 2
+se2 + sc2 + sC1 + sb1 + sC0 + si0 + sh0 + sg0 + se0 + sd0 + sc0 + sb0 + sa0
Figure A.1. Working out the CCZ’s pattern.

propagating the entanglements E2 over corrections C1 (in the old Step 1). Also, the old Step 3a essentially translates for free, in the same Steps as the ones introducing
Z-corrections.
However, these optimizations, however minor relative to big-O notation, might just cancel out with the collection of neighbors (and propagation of shifts through to



Algorithm 3 The C&S Procedures – Abstracted.

Standardizing C2M2E2C1M1E1 into some form CM E = C˜ C˜ M˜ M˜ E2E1, with each ∼-decoration indi-
cating a change in the pattern.	p-decorations refer to the remaining part of a pattern from point p on forward; And variables are assumed to be global.


Initialization:
a. E	E2 E1 ; C	C2 ; M	M1	C2M2C1M1E2E1
Consider M.
For each m1 in M – from back to front:	C2M2C˜ M˜ E2E1

a. [S] reduce&prop m1
 C1 ·
1  1
→m1
M

3. Consider M2 and C1.

For each mq  in M
from back to front:	C˜ C˜ M˜ M˜ E2E1

2	2
s → 0
2 1  2  1

reduce2signal mq2 s
For each cq1 in C1 – from front to back:
If q1 == q2:

If cq1 == Xr :

→mq2

[I] N	(Collect all neighbors of q2 acted upon by
For each n in N:
M2 )

→mq2
- [I] prop2neighbor n r  M2
If mq2 == Mx :

Else If mq2
- s+= r .
Else If mq


== My :
== t Mα s:

Else If cq1 == Zr :
s+= r .
Else:
C1 → C1\cq1 (removing cq1 from C1).

[S] propagate q1 s
4. e. M → mq2 · M
,C ·
→mq2
M2

	C → C · C1	
DEFINITIONS:
reduce m = Introduce a shift from m.
reduce&prop m SeqList = reduce m, THEN propagate the shift forwards across the elements in SeqList. reduce2signal m sp = reduce m, THEN store the signal of the shift in sp (instead of propagating). prop2neighbor n r SeqList = Propagate Sr forwards across SeqList,
until one finds the measurementt[Mn]s then changes it tot+r[Mn]s.
propagate n r SeqList = Propagate Sr forwards across SeqList, normally.
them) in Steps 3c(1)(a) and 3c(1)(b) – labeled [I].
Therefore, the time complexity for this procedure is simply that of the old Step
When considering Step 3, the latter result gets augmented by that of the new [S]-Steps. The complexity gain from the basic C&S procedure ends up being linear in the size of the input, when Step 3 is not accounted for; and linear in the number of composed circuits, when Step 3 is.
