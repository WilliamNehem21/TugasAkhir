Electronic Notes in Theoretical Computer Science 213 (2008) 55–74	
www.elsevier.com/locate/entcs

Behavior-Preserving Simulation-to-Animation Model and Rule Transformations
Claudia Ermel1 and Hartmut Ehrig2
Institut fu¨r Softwaretechnik und Theoretische Informatik Technische Universit¨at Berlin,
Germany

Abstract
In the framework of graph transformation, simulation rules define the operational behavior of visual models. Moreover, it has been shown already how to construct animation rules from simulation rules by so-called S2A-transformation. In contrast to simulation rules, animation rules use symbols representing entities from the application domain in a user-oriented visualization. Using anima- tion views for model execution provides better insights of model behavior to users, leading to an earlier detection of model inconsistencies. Hence, an important requirement of the animation view construction is the preservation of the behavior of the original visual model. This means, we have to show on the one hand semantical correctness of the S2A-transformation, and, on the other hand, semantical correctness of a suitable backwards-transformation A2S . Semantical correctness of a model and rule transformation means that for each sequence of the source system we find a corresponding sequence in the target system. S2A-transformation has been considered in our con- tribution to GraMoT 2006. In this paper, we give a precise definition for animation-to-simulation (A2S ) backward transformation, and show under which conditions semantical correctness of an A2S backward transformation can be obtained. The main result states the conditions for S2A- transformations to be behavior-preserving. The result is applied to analyze the behavior of a Radio Clock model’s S2A-transformation.
Keywords: graph transformation, model and rule transformation, semantical correctness, simulation, animation, behavior-preserving transformation


Introduction
In recent years, visual models represented by graphs have become very pop- ular in model-based software development, as the wide-spread use of UML

1  Email: claudia.ermel@tu-berlin.de
2 Email: ehrig@cs.tu-berlin.de



1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.074

and Petri nets proves. For the definition of an operational semantics for vi- sual models, the transformation of graphs plays a similar central role as term rewriting in the traditional case of textual models. The area of graph transfor- mation provides a rule-based setting to express the semantics of visual models (see e.g. [3]). The objective of simulation rules (graph transformation rules for simulation) is their application to the states of a visual model, deriving subsequent model states, thus characterizing system evolution. A simulation scenario, i.e. a sequence of simulation steps, can be visualized by showing the states before and after each rule application as graphs.
For validation purposes, simulation may be extended to a domain specific view, called animation view [8], which allows one to define scenario visual- izations which are closer to the application domain than the abstract, graph- based model. Such an animation view is defined by extending the alphabet of the original visual modeling language by symbols representing entities from the application domain. The simulation rules for a specific visual model are translated to so-called animation rules conforming to the animation view by performing a simulation-to-animation model and rule transformation (S2A transformation), realizing a consistent mapping from simulation steps to ani- mation steps. This visualization of animation steps in the animation view is called animation, in contrast to simulation, where simulation steps are shown as changes of the underlying abstract graph model.
S2A transformation is defined by a set of graph transformation rules, called S2A rules, and an additional formal construction allowing for applying S2A rules to simulation rules in order to obtain animation rules, which define the model behavior in the animation view. An important requirement of S2A transformation is that the behavior of the model is preserved in the animation view to ensure that validation results can be conferred to the original model. This means, on the one hand, semantical correctness of the S2A transforma- tion, and, on the other hand, semantical correctness of a suitable backward transformation A2S . Semantical correctness of S2A means that for each sim- ulation sequence of the model we find a corresponding animation sequence in the animation view, and has been considered in [6]. Semantical correctness of A2S means that for each animation sequence in the animation view we find a corresponding simulation sequence in the original model.
In this paper, we give a precise definition for animation-to-simulation (A2S ) model and rule backward transformation, and show under which condi- tions semantical correctness of A2S backward transformation can be obtained, thus giving criteria for S2A-transformations to be behavior-preserving. In our approach, an S2A transformation generates one animation step for each simu- lation step, and the corresponding A2S transformation relates each animation

step to a simulation step. Please note that there are more general definitions for the semantical correctness of model transformations which establish a cor- respondence between one simulation step in the source model and a sequence of simulation steps in the target model [1]. For S2A transformation it is suffi- cient to relate single simulation and animation steps. Intermediate animation states providing smooth state transitions are possible nonetheless: They are defined by enriching an animation rule by animation operations to specify con- tinual changes of object properties. Since animation operations leave the states before and after a rule application unchanged, they do not influence behavior- preserving S2A transformations. Our approach has been implemented in the
generic visual modeling environment GenGED [5,9]. The implementation
includes an animation editor to define animation operations visually, and to export animation scenarios to the SVG format [18].
The paper is organized as follows: In Section 2, our running example, an animation view for a Radio Clock Statechart, is introduced. Section 3 re- views the basic concepts of simulation, animation, and model and rule trans- formation. In Section 4, the main result on semantical correctness of S2A transformation is reviewed. As new contribution in this paper, it is shown that for each S2A transformation there exists a corresponding A2S backward- transformation. Semantical correctness of A2S transformations is shown for the case without negative application conditions (NACs). Extensions to cope with NACs are discussed. Section 5 discusses related work, and Section 6 concludes the paper.

Case Study: Radio Clock
In this section, we illustrate the concepts simulation and animation along the well-known Radio Clock case study from Harel [10]. The behavior of a radio clock is modeled by the nested Statechart shown in Fig. 1.

Fig. 1. Radio Clock Statechart
The radio clock display can show alternatively the time, the date or the alarm time. The changes between the modes are modeled by transitions la- beled with the event mode. The nested state Alarm allows one to change to modes for setting the hours and the minutes (transition Select) of the alarm

time. A Set event increments the number of hours or minutes which are cur- rently displayed.
The abstract syntax graph of the Radio Clock Statechart is the given by the graph GI in Fig. 2.

Fig. 2. Abstract Syntax Graph GI of the Radio Clock Statechart
The set of model-specific simulation rules PS = {paddObject, paddEvent, pdownT ime, pdownDisp, pupAlarm, pupClock, pmodeTD , pmodeDA , pmodeAD , pselectH, pselectM , pselectD, psetH, psetM } to be applied to GI contains initialization rules
which generate an object node with initial attribute values, set the current pointer to the top level state Radio Clock, and fill the event queue. Additional simulation rules are defined which realize the actual simulation, processing the events in the queue. For each superstate there is a rule moving the current pointer down to its initial substate. Analogously, there are rules moving the pointer from a substate to its superstate. For each transition there is a rule which moves the pointer from the transitions’s source state to its target state and removes the triggering event from the queue. The full set PS of simula- tion rules is given in [7]. Fig. 3 shows the sample simulation rule psetH for the transition set whose source and target is the state Set:Hours. In addition to processing the event set, this rule increments the hour value of the alarm time.

Fig. 3. A Simulation Rule psetH
A domain-specific animation view of the Radio Clock is illustrated in Fig. 4. The two snapshots from a possible simulation run of the Statechart in Fig. 1 correspond to the active state Set:Hours before and after the set event has been processed. The animation view shows directly the current display of the clock and indicates by a red light that in the current state the hours may be set. Furthermore, buttons are shown either to proceed to the state where the minutes may be set (button Select), or to switch back to the Time display (button
Mode).



Fig. 4. Animation View Snapshots for the Radio Clock
Basic Concepts of Simulation and Animation
We use typed algebraic graph transformation systems (TGTS) in the double- pushout-approach (DPO) [3] which have proven to be an adequate formalism for visual language (VL) modeling. A VL is modeled by a type graph capturing the definition of the underlying visual alphabet, i.e. the symbols and relations which are available. Sentences or diagrams of the VL are given by graphs typed over the type graph. We distinguish abstract and concrete syntax in alphabets and models, where the concrete syntax includes the abstract symbols and relations, and additionally defines graphics for their visualization. Formally, a VL can be considered as a subclass of graphs typed over a type graph TG in the category GraphsTG.
For behavioral diagrams like Statecharts, an operational semantics can be given by a set of simulation rules PS, using the abstract syntax of the modeling VL, defined by simulation type graph TGS. A simulation rule p = (L ← I → R) ∈ PS is a TGS-typed graph transformation rule, consisting of a left-hand side L, an interface I, a right-hand side R, and two injective morphisms. Applying rule p to a graph G means to find a match of L −m→ G and to replace the occurrence m(L) of L in G by R leading to the target graph
G'. Such a graph transformation step is denoted by G (p,m)	', or simply by
=⇒ G
G ⇒ G'. In the DPO approach, the deletion of m(L) and the addition of R are described by two pushouts (a DPO) in the category GraphsTG of typed graphs. A rule p may be extended by a set of negative application conditions (NACs) [3], describing situations in which the rule should not be applied
to G. Formally, match L −m→ G satisfies NAC L −n→ N if there does not
exist an injective graph morphism N −x→ G with x ◦ n = m. A sequence
G0 ⇒ G1 ⇒ ... ⇒ Gn of graph transformation steps is called transformation
∗	∗
and denoted as G0 ⇒ Gn. A transformation G0 ⇒ Gn, where rules from P
are applied as long as possible (i.e. as long as matches can be found satisfying

the NACs), is denoted by G =P⇒!
Gn.

We regard a model’s simulation language V LS, typed over the simulation alphabet TGS, as a sublanguage of the modeling language V L, such that all diagrams GS ∈ V LS represent different states of the same model during simulation. Based on V LS, the operational semantics of a model is given by a simulation speciﬁcation.

Definition 3.1 (Simulation Specification) Given a visual language VLS typed over T GS, i.e. VLS ⊆ GraphsTGS , a simulation speciﬁcation SimSpecVLS = (VLS , PS) over VLS is given by a TGTS (TGS, PS) such that VLS is closed under simulation steps, i.e. GS ∈ VLS and GS ⇒ HS via pS ∈ PS implies HS ∈ VLS . The rules pS in PS are called simulation rules.
The simulation specification SimSpecV LS = (VLS , PS) for the Radio Clock consists of the simulation language VLS typed over TGS, where T GS is the simulation alphabet depicted in the left-hand side of Fig. 5, PS is the set of simulation rules, and VLS consists of all graphs that can occur in any Radio

Clock simulation scenario: VL
= {G
|∃G
PS∗
, where G
is the initial

S	S	I =⇒ GS}	I
graph shown in Fig. 2.
In order to visualize the model behavior, an animation view type graph TGA is defined, which is a disjoint union of the simulation alphabet T GS and the new visualization alphabet TGV . Fig. 5 shows the animation view type graph TGA for the Radio Clock, where TGV consists of visualization symbols for a domain-specific view of the radio clock modes. The abstract syntax symbols of TGV are connected to their concrete representation graphics by layout arcs. The graphics are part of the type graph, but they are not needed in the animation rules since layout arcs express a 1-to-1-correspondence between abstract symbols and their graphics.

Fig. 5. Simulation and Animation Type Graphs for the Radio Clock
Three radio clock modes are visualized by five different displays: a date display, a time display, and three alarm displays showing the alarm time but differing in the states of two red lights which indicate the states Display (both lights off), Set:Hours (light SetH on), and Set:Minutes (light SetM on). A state in the Statechart corresponds to a display in the animation view. Thus, during animation, the display for the current active state is shown and displays the corresponding attribute values of the object pointer’s attributes.
In order to transform a simulation specification to an animation view, we define an S2A transformation S2A = (S2AM , S2AR) consisting of a

simulation-to-animation model transformation S2AM , and a corresponding rule transformation S2AR. The S2AM transformation applies S2A transfor- mation rules from a rule set Q to each GS ∈ V LS as long as possible, adding symbols from the application domain to the model state graphs. The resulting set of graphs comprises the animation language V LA.

Definition 3.2 (S2AM -Transformation) Given a simulation specification SimSpecV LS = (V LS, PS) with VLS typed over TGS and a type graph T GA, called animation type graph, with T GS ⊆ TGA, a simulation-to-animation model transformation, short S2AM -transformation, S2AM : V LS → V LA is given by S2AM = (VLS ,TGA, Q) where (TGA, Q) is a TGTS with non-
Q !
deleting rules q ∈ Q, and S2AM -transformations GS =⇒ GA with GS ∈ VLS .
Q !
The animation language VLA is defined by VLA = {GA|∃ GS ∈ VLS ∧ GS =⇒
Q !
GA}. This means, GS =⇒ GA implies GS ∈ VLS and GA ∈ VLA, where each

intermediate step G
q
i =⇒ Gi+1
is called S2AM -step.


Our aim is not only to transform model states but to obtain a complete animation specification, including animation rules, from the simulation specifi- cation. Hence, we define a construction allowing us to apply the S2A transfor- mation rules from Q also to the simulation rules, resulting in a set of animation rules. The following definition reviews the construction for rewriting rules by rules from [6].

Definition 3.3 (Transformation of Rules by Non-Deleting Rules)

Given a non-deleting rule q = (L  → R ) and a rule p  = (L  ←l1
I →r1
R1),

then q is applicable to p leading to a rule transformation step p1	q _zp2 , if the precondition of one of the following three cases is satisfied, and
l2	r2
p2 = (L2 ← I  → R2) is defined according to the corresponding construc-
tion.


Case (1)
Precondition (1): There is a match L


−h→ I .
Lq	q	 R q

h	(1 )

q	1	J  qI	J 
I1	I 

Construction (1): I2, L2, and R2 are defined by pushouts


l1 

(1), (1a) and (1b), leading to injective morphisms l
and
 ( 1aj) r 1
 lj 

2	L 	 L  2 r2

r2.
qL	2

J (1b)
R1	qR
J 
R 2

Case (2)
Precondition (2): There is no match Lq

−h→ I , but a

Lq	q	 R q

match
h'
Lq −→ L1.
h'	(2 )

Construction (2): L2 is defined by pushout (2), and
J  q	J 

I = I , R = R , r = r , and l = q  ◦ l .
L1 	L	 L 

1	2
1	2	1
2	L	1	2

Case (3)
Precondition (3): There are no matches Lq
−h→ I
and
L 	q	 R 

h'	h''
h''
(3 )

Lq −→ L1, but there is a match Lq −→ R1.
Construction (3): R2 is defined by pushout (3), and
L = L , I = I , l = l , and r = q  ◦ r .
J	J 
R1	 R 2

2	1	2
1	2	1
2	L	1

Def. 3.3 extends the construction for rewriting rules by rules given by Parisi-Presicce in [14], where a rule q is only applicable to a rule p if it is applicable to the interface graph I of p. This means, q cannot be applied if p deletes or generates objects which q needs. In this paper, we want to add animation symbols to simulation rules even if the S2A transformation rule is not applicable to the interface of the simulation rule: Case (1) in Def. 3.3 corresponds to the notion of rule rewriting in [14], adapted to non-deleting S2A transformation rules. In Case (2), the S2A transformation rule q is not applicable to the interface I, but to the left-hand side of a rule p1, and in Case (3), q is not applicable to I, but to the right-hand side of p1. Note that it is possible that both Case (2) and Case (3) can be true for different matches of
q. Then, q is applied in a first step to L1 according to (2), and in a second step to R1 according to (3).
Def. 3.3 now allows us to define an S2AR transformation of rules, leading to an S2A transformation S2A = (S2AM , S2AR) from the simulation specifi- cation SimSpecV LS to the animation specification AnimSpecV LA .
Definition 3.4 (S2AR-Transformation) Given a simulation specifica- tion SimSpecV LS = (VLS , PS) and an S2AM -transformation S2AM = (VLS ,TGA, Q), then a simulation-to-animation rule transformation, short S2AR-trafo, S2AR : PS → PA is given by S2AR = (PS,TGA, Q) and S2AR

transformation sequence pS	Q _!zpA  with p
∈ PS
, where rule transformation

steps p1	q _zp2 with q ∈ Q (see Def. 3.3) are applied as long as possible. The
animation rules P	are defined by P	= {p | ∃ p  ∈ P ∧ pS	Q _!zpA  }. This

means pS	Q _!zpA  implies p
∈ PS
and pA
∈ PA
, where each intermediate step

pi	qi _zpi +1 is called S2AR-step.
In our Radio Clock example, the S2A transformation rules Q = {qClock,
qDate, qT ime, qDisp, qSetH, qSetM } add visualization symbols to the simulation

rule graphs and to the initial radio clock graph. The initial S2A rule qClock adds the root symbol Clock to all graphs it is applied to. The remaining S2A rules add visualization symbols depending on the state of the current pointer. We visualize only basic states which do not have any substates. Superstates are not shown in the animation view, as they are considered as transient states which are active on the way of the current pointer up and down the state hierarchy between two basic states, but have no concrete visualization graphics themselves.
The full set Q of S2A rules is given in [7]. The top row of Fig. 6 shows the sample S2A transformation rule qsetH which adds a SetHours symbol and links it to the clock symbol in the case that the current pointer points to the state named “Set:Hours”. The attributes are set accordingly. Note that each S2A rule q has to be applied at most once at the same match, which is formalized by a NAC Lq → Nq, such that Nq and Rq are isomorphic. A sample S2AR

transformation step p'
qsetH zA 
setH
is shown in Fig. 6.	Here, S2A rule





Fig. 6. S2A Transformation Step p'
qsetH  A




qsetH
setH

'
−→ psetH

Lq −→ Rq is applied to the rule psetH , according to Case (1) of Def. 3.3. Rule

'
setH
= (L' ← I' → R') in Fig. 6 corresponds to rule p1 = (L1 ← I1 → R1) in

Def. 3.3. The result of the rule rewriting step in Fig. 6 is rule pA	= (LA ←
IA → RA), which corresponds to rule p2 = (L2 ← I2 → R2) in Def. 3.3. Rule

A
setH
is a completely transformed animation rule, since no more S2A rules

are applicable to it. Note that variables for node attributes can be assigned
to other variables or to expressions.	For instance, in Fig. 6, the variable
h for attribute AlarmH in I' is assigned to the expression incr(h) in R' by the

morphism I
'
−→ R
'. Hence, a resulting animation rule can contain variables

or expressions for attributes to be assigned to corresponding attribute values in graphs when the animation rule is applied.
Definition 3.5 (Animation Specification and S2A Transformation) Given a simulation specification SimSpecV LS = (VLS , PS), an S2AM transfor- mation S2AM : VLS → VLA and an S2AR transformation S2AR : PS → PA, then
AnimSpecV LA = (VLA, PA) is called animation speciﬁcation, and each

transformation step GA
p
=⇒ HA
with GA
, HA
∈ VLA
and pA
∈ PA is

called animation step.
S2A : SimSpecV LS → AnimSpecV LA , defined by S2A = (S2AM , S2AR) is called simulation-to-animation model and rule transformation, short S2A transformation.
The Radio Clock animation specification AnimSpecV LA = (VLA, PA) based on the S2A transformation S2A = (S2AM , S2AR) is given by the anima- tion language VLA, obtained by the Radio Clock S2AM transformation, and the animation rules PA, obtained by the Radio Clock S2AR transformation. The full set PA of animation rules is given in [7].
Fig. 7 shows a sample animation scenario in the concrete notation of the animation view, where animation rules from PA are applied. The first state of the scenario in Fig. 7 is obtained by applying the initial animation rules setting the attribute values, initializing the event queue with the events mode, mode, select, set, mode, and processing the first mode event. The subsequent animation steps result from applying animation rules for processing the remaining events or for moving up and down the state hierarchy.

Fig. 7. Radio Clock Animation Scenario

Behavior-Preserving S2A Transformations
In this section, we continue the general theory of Section 3 and study prop- erties of behavior-preserving S2A-transformations, i.e. S2A-transformations which are semantically correct and where a semantically correct A2S - backward-transformation exists. After reviewing semantical correctness of S2A transformation (which has been treated in depth in [6]), we define the con- struction of an A2S -backward-transformation for a given S2A-transformation, and give requirements for the semantical correctness of A2S . The main result

in Theorem 4.14 states the conditions for S2A transformations being behavior- preserving.
Semantical correctness of S2A-transformations
In our case, semantical correctness of an S2A-transformation means that for

each simulation step GS
p
=⇒ HS
there is a corresponding animation step

p
GA =⇒ HA where GA (resp. HA) are obtained by S2A model transformation
from GS (resp. HS), and pA by S2A rule transformation from pS. Note that this is a special case of semantical correctness defined in [1], where instead of

a single step G
are allowed.
p
A =⇒ HA
more general sequences G
∗
A =⇒ HA
and H
∗
S =⇒ HA

Definition 4.1 (Semantical Correctness of S2A Transformations)
An S2A-transformation S2A : SimSpecV LS  → AnimSpecV LA  given by
S2A = (S2AM : VLS → VLA, S2AR : PS → PA) is semantically correct,

if we have for each simulation step GS
p
=⇒ HS
with GS
∈ VLS
and each

S2AR-transformation	sequence	pS	Q _!zpA 
Def. 3.4):
Q !
(see

G 	Q  !  zG 

S2AM -transformation sequences GS =⇒ GA and	pS
Q !
HS =⇒ HA, and
Q ! _zpA 

an animation step G	pA
cz	Q  !  zcz
S	A

In [6,7], it is shown that the following properties have to be fulfilled by an
S2A-transformation in order to be semantically correct:
Definition 4.2 (Termination of S2AM and Rule Compatibility of
S2A)
An S2AM transformation S2AM : VLS → VLA is terminating if each trans-
Q ∗	Q ∗	Q ∗

formation GS
=⇒ Gn can be extended to GS =⇒ Gn =⇒ Gm such that no

q ∈ Q is applicable to Gm anymore. An S2A-transformation S2A = (S2AM : VLS → VLA, S2AR : PS → PA) with S2AM = (VLS ,TGA, Q) is called rule compatible, if for all pA ∈ PA and q ∈ Q we have that pA and q are parallel

and sequential independent. More precisely, for each G pA
with G
Q ∗
S =⇒ G

and H
Q ∗
S =⇒ H
for some GS
, HS
∈ VLS
q
and each G =⇒ G
' (resp. H =q	')

we have parallel (resp. sequential) independence of G  pA
and G =⇒ G'

q
(resp. H =⇒ H
').

Without giving the proof (which can be found in [6]), Theorem 4.3 states the main result from [6], concerning semantical correctness of S2A- transformation.

Theorem 4.3 (Semantical Correctness of S2A)
Each S2A-transformation S2A = (S2AM , S2AR) is semantically correct, pro- vided that S2A is rule compatible, and S2AM is terminating.

Construction of A2S-Backward-Transformations
In this section we consider the relation between an animation specification AnimSpecV LA and the corresponding simulation specification SimuSpecV LS related by S2A transformation. We show in Theorem 4.10 that for each S2A transformation there is a backward transformation A2S : AnimSpecV LA → SimSpecV LS , i.e. we get A2S ◦ S2A ⊆ IdV LS
Definition 4.4 (Characterization of Backward Transformations)
Given an S2AM transformation S2AM : V LS → V LA, then a transfor- mation A2SM : V LA → V LS is called backward transformation of S2AM if we have


i.e.	∀GS, G'
A2SM ◦ S2AM ⊆ IdV LS ,
∈ V LS, GA ∈ V LA : [(GS, GA) ∈ S2AM , (G' , GA) ∈

S2AM =⇒ GS = G' ]
Given an S2AR transformation S2AR : PS → PA, then the transformtion
A2SR : PA → PS is called backward transformation of S2AR if we have
A2SR ◦ S2AR ⊆ IdPS .
Given backward transformations A2SM of S2AM and A2SR of S2AR, then A2S = (A2SM , A2SR) is called backward transformation of S2A = (S2AM , S2AR).
Remark 4.5 All transformations in Def. 4.4 are considered as relations, and
is the relational composition. If S2AM is total, we also require A2SM to be total and A2SM ◦ S2AM = IdV LS , and analogously for S2AR and A2SR.
For an S2A transformation, we define an A2S backward transformation by restriction of graphs and rules to T GS in Def. 4.6. and show in Theorem 4.10 (using the propositions Prop. 4.7 and 4.8) that A2S has the desired property A2S ◦ S2A ⊆ IdV LS . If S2AM is total, we even get A2S ◦ S2A = IdV LS .
Definition 4.6 (A2S  Transformation) Given an S2A transformation
S2A = (S2AM : V LS  → V LA, S2AR : PS  → PA) : SimSpecV LS  →
AnimSpecV LA , then the transformation A2S : AnimSpecV LA → SimSpecV LS is defined by A2S = (A2SM , A2SR) is called animation-to-simulation model and rule transformation, short A2S transformation, where

A2SM : V LA → V LS is the animation-to-simulation model transfor- mation, short A2SM transformation, defined by restriction to T GS, i.e.
A2SM (GA)= GA|T GS , and
A2SR : PA → PS is the animation-to-simulation rule transforma- tion, short A2SR transformation, defined by restriction to TGS, i.e. A2SR(pA)= pA|T GS .


In the subsequent propositions Prop. 4.7 and 4.8, we use the notion of layered type-increasing TGTS to denote a typed graph transformation sys- where elements generated by a rule q ∈ Q belonging to
rule layer i generate only elements typed over new types tem with rule layers, in TGi+1 which do not occur already in Lq, such that Rq|T Gi = Lq, i.e. the diagram to the right is a pullback
for all q ∈ Q.

Lq	q	 R q
(PB)
J ˛		J 

TGi,
 T Gi+1

This property allows us to construct a parallel rule qi from all rules q belonging
to rule layer i, such that for q = qi we also have the pullback (PB).



Proposition 4.7 (Restriction of S2AM to TGS) Given an S2AM transformation S2AM : V LS → V LA based on a layered type-increasing TGTS (T GA, Q) with
Q !
TGS ⊆ T GA, then we have: GS =⇒ GA with GS ∈ V LS



GS 	 G A
(PB)

implies GA|T GS = GS, i.e. the diagram to the right is a
pullback.
J 
TGS,
J 
TGA




Q !
Proof. Given G
q
, we can assume to have a sequence G  = G


G	q1
S =⇒ GA
qn
S	0 =⇒

1 =⇒ .. =⇒ Gn+1 = GA where each qi is either a parallel rule, composed
of all q ∈ Q with rule layer i, or an identity step. In each single step we
have in the first case pushout (1) and the commutative square (2), where the typing Gi+1 → T Gi+1 is induced from Gi → TGi and pushout (1), and Lqi → T Gi, Rqi → T Gi+1 are given by our layered type-increasing GTS (TGA, Q), such that the outer diagram (1 + 2) is a pullback and all horizontal morphisms are monomorphisms.


Lqi
	qi	 
i
Gi 	id  G i+1

(1)
J  q'	J 
(3)
J ˛	J 

Gi 	i	 G i+1
TGi,	 T Gi+1

(2)
tJz 
TGi,
 
 J r
 T Gi+1

Hence, by pushout-pullback-decomposition property (see e.g. [3]), we get that (2) is a pullback. In the case that qi = id, diagram (3) is a pullback because TGi ‹→ TGi+1 is monomorphism. This leads to the following sequence of pullbacks, which can be composed to one pullback:

z 
	 	 	 ...	 

GS = G0

(PB0)
G1	G2
(PB1)
Gn	 G n+1 = GA
(PBn)

J	,˛	  J ˛	  J ˛	 ˛	
J ˛		J 

TGS = TG0
T G1,
T G2,
...,
 T Gn,
 T Gn+1 = TGA



Proposition 4.8 (Restriction of S2AR to T GS)
Given an S2AR transformation S2AR	:

PS → PA based on a layered type-increasing
L ¸,	 I
	 R 

TGTS (T GA, Q) with TGS ⊆ TGA, then	S	  S	S

we have:
Q _!z  with p
∈ P	implies
 j 
L
 j 
I
 R  j 

pS  pA	S	S
A ¸,	 A	 A

pA|T GS  = pS, i.e. for pS = (LS ← IS →	J	id	J id	J 

R ),p	= (L	← I	→ R ) the double cube
TGS ¸, TGS
 T GS

S	A	A	A	A
J j	J j	J j 

to the right commutes with pullbacks in the
TGA ¸, TGA 	 T GA

diagonal squares.	id	id
Proof Sketch. (for a full proof see [5]) Given pS	Q _!zpA , we consider the subse-

quences according to the layers Qi of Q,
Li ¸,	 Ii 	 R i

p	= p
Q0!_zp 
Q1_!zp	p
Qn_!zp  = p
 j 
 j 
 j 

S	0 	1 	2
n 	n+1
A	Li+1 ¸,  Ii+1 	 R i+1

and show that for each i = 0, .., n the double
J	J	J 

cube to the right exists with pullbacks in the diagonal squares, which can be composed to
TGi ¸,id TGi  id
J j	J j 
  T Gi
J j 

TGi+1 ¸,T Gi+1   T Gi+1

the required double cube with pS and pA.
id	id


Remark 4.9 Proposition 4.7 implies that there exists a TGTS embedding

f : SimSpec
→ AnimSpec
given by f =( 
fTG	f	),

V LS
V LA
TGS −→ TGA, PS −→ PA

where fTG is the type graph inclusion, and fP maps each simulation rule pS to

the rule pA resulting from the S2AR transformation. TGTS embeddings are morphisms between typed graph transformation systems, defined categorically via so-called retyping functors between categories GraphsTG and GraphsTG' of typed graph transformation systems (see [5], Sect. 2.1.3).
Theorem 4.10 (A2S is Backward Transformation of S2A) Given an S2A transformation S2A = (S2AM : V LS → V LA, S2AR : PS → PA) based on a layered type-increasing GTS (TGA, Q) with TGS ⊆ T GA, then the trans- formation A2S : AnimSpecV LA → SimSpecV LS deﬁned according to Def. 4.6, is a backward transformation of S2A in the sense of the characterization of backward transformations given in Def. 4.4.


Proof. A2SM	: V LA  → V LS for GA  ∈ V LA with GS
Q !
=⇒ GA for

GS ∈ V LS maps GA to GS, because GA|T GS = GS by Prop. 4.7. This implies
A2SM ◦ S2AM ⊆ IDV LS . Analogously, A2SR : PA → PS for pA ∈ PA with
pS  Q _!zpA  for p  ∈ P  maps p  to p , because we have p |   = p  by Prop. 4.8. This implies A2SR ◦ S2AR ⊆ IDPS . Hence, A2SM , A2SR and A2S = (A2SM , A2SR) are backward transformations of S2AM , S2AR and S2A, respectively, according to Def. 4.4.	 

Semantical Correctness of A2S-Backward-Transformations
Given an A2S backward transformation of A2S with A2S = (A2SM, A2SR): AnimSpecV LA → SimSpecV LS such that A2SR(pA) = pS for pA ∈ PA, pS ∈ PS and A2SM (GA) = GS for GA ∈ V LA, GS ∈ V LS, then the graph HS

resulting from the simulation step GS
p
=⇒ HS
and the graph HA
resulting

from the animation step G
p
A =⇒ HA
should be related by A2SM backward

transformation, i.e. A2SM (HA)= HS .
Definition 4.11 (Semantical Correctness of A2S Transformation)
An A2S transformation A2S : AnimSpecV LA → Sim-

SpecV LS  given by A2S = (A2SM : V LA → V LS,
A2SR : PA → PS) is semantically correct if for each
GA 	A2SM	 G S

animation step GA
p
=⇒ HA
with GA
, HA
∈ V LA
pA   A2SR	 pS 

and A2SM (GA) = GS and A2SR(pA) = pS, there

is a corresponding simulation step GS
p
=⇒ HS
with	cz	cz

A2SM (HA)= HS.
HA 	A2SM	 H S

Theorem 4.12 (Semantical Correctness of A2S Backward Transfor- mation) Each A2S backward transformation A2S = (A2SM , A2SR) of an S2A transformation S2A = (S2AM , S2AR) is semantically correct.

Proof Sketch. (for a full proof see [5])
The semantical correctness of A2S backward transformation holds due to the fact that the S2A transformation induces a TGTS embedding from SimSpecV LS to AnimSpecV LA (see Remark to Fact 4.8). TGTS embeddings

reflect the behavior in the sense that if we have a transformation GA
p ,m
=⇒ HA

in AnimSpec
V LA
, we get the transformation GS
p ,m
=⇒ HS
in SimSpec
V LS ,

where the matches are related by mA|T GS = mS. Basically, the proof works by construction of the double cube shown below, where the front squares are

pushouts corresponding to a rewriting step G
p
A =⇒ HA
in the DPO approach,

applying the animation rule pA = (LA ← IA → RA) to graph GA. It is shown that the diagonal squares are all pullbacks. Thus, the Van-Kampen property (see [3]) can be used to prove that the back squares are also pushouts, which

correspond to the rewriting step G
p
S =⇒ HS
in the DPO approach, applying

the rule pS = (LS ← IS → RS) to GS, where GS = GA|T GS .
LS ¸,	 IS 	 R S
 j	 j	 j 
LA ¸,	 IA 	 R A

TGS
J 
¸,  GS ¸,
C
J 
H S 	 TGS

 j	J j	J j	J j	 j 
TGA ¸,  GA ¸,  CA 	 H A 	 T GA

Behavior-Preserving S2A Transformations
We now present the main result in Theorem 4.14, stating the conditions for S2A transformations being behavior-preserving, based on Theorems 4.3 and 4.12.
Definition 4.13 (Behavior-Preserving S2A Transformations)
Given an S2A model and rule transformation S2A = (S2AM , S2AR) : SimSpecV LS → AnimSpecV LA (Def. 3.5), and the corresponding A2S backward-transformation A2S = (A2SM , A2SR) : AnimSpecV LA → SimSpecV LS (Def. 4.6), we say that S2A is behavior-preserving, if
S2A is semantically correct (acc. to Def. 4.1), and
A2S is semantically correct (acc. to Def. 4.11)
Theorem 4.14 (Behavior-Preserving S2A Transformation) An S2A transformation S2A = (S2AM , S2AR) : SimSpecV LS → AnimSpecV LA is behavior-preserving if
S2A is rule-compatible, and S2AM is terminating (Def. 4.2),
A2S is constructed according to Def. 4.6,

Proof. By Theorem 4.3 we have that S2A is semantically correct for rule- compatible S2A and terminating S2AM . By Theorem 4.10 and Theorem 4.12 we know that A2S is a valid backward-transformation of S2A and that A2S is semantically correct. Hence, according to Def. 4.13, S2A is a behavior- preserving model and rule transformation.	 
Finally, we can consider semantical equivalence of SimSpecV LS and AnimSpecV LA , which requires behavior-preserving S2A, such that S2A and A2S are inverse to each other, i.e. A2S ◦ S2A = Id and S2A ◦ A2S = Id . It is shown in [5] that we have semantical equivalence if S2A is behavior-preserving, and the S2A transformation rules in Q are confluent.

Extension by Negative Application Conditions
Considering rules with NACs both for the S2A rules in Q (now of the form q = (Nq ← Lq → Rq)), and for the simulation rules in PS (now of the form pS = (Ni ← L ← I → R)), has the following consequences on the con- struction of the animation specification by S2A transformation: Def. 3.3 has to be extended to deal with the additional transformation of NACs in Cases
(1) and (2) (in Case (3), the NACs remain unchanged). Moreover, a new Case (4) has to be added covering the case that preconditions (1) - (3) are not satisfied, but there are matches into Ni. Furthermore, the preconditions
n
for all cases now also require the satisfaction of N ACq = (Lq −→ N ). To
extend rule compatibility (Def. 4.2), in addition to parallel and sequential in- dependence in the case without NACs, we have to require that the induced matches satisfy the corresponding NACs. The proof of semantical correct- ness of S2A transformations with NACs requires also NAC-compatibility of

S2AM and S2AR for all q ∈ Q and G
p
i =⇒ Hi
. NAC-compatibility of S2AM

means that if q is applicable to a rule pS, then each match of q in Gi (resp.
H ) satisfies N AC . NAC-compatibility of S2AR means that if pi	q _zpi +1
i	q

satisfies NACq , and Gi
p
=⇒ Hi
satisfies NAC (pi ) then G
i+1
pi+1
=⇒
Hi+1
sat-

isfies NAC (pi+1 ). Considering these additional requirements, we can show
that each S2A-transformation S2A = (S2AM , S2AR) is semantically correct including NACs, provided that S2A is rule compatible, S2AM is terminating and S2A is NAC-compatible. This extends Theorem 4.3 and Theorem 4.14, where now rule compatibility and termination have to be required with NACs (for the complete extended theorems see [7,5]).
Moreover, the proofs of Prop. 4.7 and 4.8 can be extended to NACs in a straight-forward way. An additional property has to be required to get semantical correctness of A2S (Theorem 4.12), namely NAC-compatibility of A2S . Fortunately, NAC-compatibility can be shown in general for all A2S -

transformations (see [5] for the complete proof of Prop. 4.15).
Proposition 4.15 (NAC-Compatibility of A2S Transformations) An A2S transformation A2S = (A2SM : V LA → V LS, A2SR : PA → PS) is NAC-compatible in the following sense: Let GS  = A2SM (GA) and

pS = A2SR(pA
). Then, if GA
p
=⇒ HA
satisﬁes N AC(pA
) then GS
p
=⇒ HS

satisﬁes N AC(pS).
Behavior Preservation in the Radio Clock Case Study
Using the extended theorems, we can show behavior preservation of our Radio Clock S2A transformation (see [5,7]). Termination is shown to be fulfilled for general S2A transformation systems based on layered type-increasing TGTS. Moreover, it is shown that each S2AR transformation is NAC-compatible provided that we have layered type-increasing TGTS, as our case study has. NAC-compatibility of S2AM has been shown explicitly for the Radio Clock in [7]. For the Radio Clock case study, we even have semantical equivalence of SimSpecV LS and AnimSpecV LA , since the Radio Clock S2A transformation is shown to be confluent in [5].

Related Work
To ensure the correctness of model transformations, Varro´ et al. [15,17] use graph transformation rules to specify the dynamic behavior of systems and generate a transition system for each instance model. Based on the transition system, a model checker verifies certain dynamic consistency properties by model checking the source and target models. In [13], a method is presented to verify the semantical equivalence for particular model transformations. It is shown by finding bisimulations that a target model preserves the semantics of the source model with respect to a particular property. This technique does not prove the correctness of the model transformation rules in general, as we propose in this paper for the restricted case of S2A transformation rules. The formal background of bisimulations for graph transformations has been considered also in e.g. [4].
Backward transformations are also of interest in the context of bidirectional model transformations based on triple graph grammars [16]. In [2], it has been investigated under which conditions a given forward transformation has an inverse backward transformation, but semantical correctness has not yet been considered.
There exist related tool-oriented approaches, where different visual rep- resentations are used to visualize a model’s behavior. One example is the

reactive animation approach by Harel [11], where behavior is specified by UML diagrams. The animated representation of the system behavior is im- plemented by linking UML tools to pure animation tools like Macromedia Flash or Director [12]. Hence, the mapping from simulation to animation views happens at the implementation level and is neither specified formally, nor shown to be behavior-preserving. Analogously, different Petri net tools also offer support for customized Petri net animations In general, approaches to enhance the front end of CASE tools for simulating/animating the behavior of models are restricted to one specific modeling language.

Conclusion and Ongoing Work
In this paper we have reviewed the definition for simulation-to-animation (S2A) model and rule transformations, and defined a corresponding A2S - backward transformation A2S : SimSpecV LS → AnimSpecV LA , essentially given by restriction of all graphs and rules to the simulation type graph TGS. The main results show under which conditions an A2S transformation is se- mantically correct, in the cases without and with negative application con- ditions. Having semantical correctness both of S2A and of A2S , we have a behavior-preserving simulation-to-animation (S2A) model and rule transfor- mation system. The results have been used to show that the S2A transforma- tion of our radio clock case study preserves the behavior.
The theory has been presented in the DPO-approach for typed graphs, but it can also be extended to typed attributed graphs, where injective graph morphisms are replaced by suitable classes M and M' of typed attributed graph morphisms for rules and NACs, respectively [3].
Future work is planned to generalize our approach formalizing behavior- preserving model and rule transformations from S2A transformations to other kinds of model transformations based on graph transformation, especially to triple graph grammar specifications.

References
Ehrig, H. and K. Ehrig, Overview of Formal Concepts for Model Transformations based on Typed Attributed Graph Transformation, in: Proc. International Workshop on Graph and Model Transformation (GraMoT’05), ENTCS 152 (2005).
Ehrig, H., K. Ehrig, C. Ermel, F. Hermann and G. Taentzer, Information preserving bidirectional model transformations, in: M. B. Dwyer and A. Lopes, editors, Fundamental Approaches to Software Engineering, LNCS 4422 (2007), pp. 72–86.
Ehrig, H., K. Ehrig, U. Prange and G. Taentzer, “Fundamentals of Algebraic Graph Transformation,” EATCS Monographs in Theoretical Computer Science, Springer Verlag, 2006.

Ehrig, H. and B. Koenig, Deriving bisimulation congruences in the dpo approach to graph rewriting, in: Proc. FOSSACS 2004, LNCS 2987 (2004), pp. 151–166.
Ermel, C., “Simulation and Animation of Visual Languages based on Typed Algebraic Graph Transformation,” Ph.D. thesis, TU Berlin, Fak. IV (2006).
Ermel, C., H. Ehrig and K. Ehrig, Semantical Correctness of Simulation-to-Animation Model and Rule Transformation, in: Proc. Workshop Graph and Model Transformation (GraMoT’06), Electronic Communications of the EASST 4 (2006).
Ermel, C., H. Ehrig and K. Ehrig, Semantical Correctness of Simulation-to-Animation Model and Rule Transformation: Long Version, Technical Report 2006/10, TU Berlin, Fak. IV (2006).
URL http://iv.tu-berlin.de/TechnBerichte/2006/2006-10.pdf

Ermel, C., K. H¨olscher, S. Kuske and P. Ziemann, Animated Simulation of Integrated UML Behavioral Models based on Graph Transformation, in: M. Erwig and A. Schu¨rr, editors, Proc. IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC’05) (2005).
GenGED Homepage, http://tfs.cs.tu-berlin.de/genged.
Harel, D., Statecharts: a visual formalism for complex systems, Science of Computer Programming 8 (1987), pp. 231–274.
Harel, D., S. Efroni and I. Cohen, Reactive Animation, in: Proc. Formal Methods for Components and Objects (FMCO’02), LNCS 2852 (2003), pp. 136–153.
Macromedia, Inc., “Macromedia Flash MX 2004 and Director MX 2004,” (2004), http://www. macromedia.com/software/.
Narayanan, A. and G. Karsai, Towards Verifying ModelTransformations, in: Proc. Workshop on Graph Transformation and Visual Modeling Techniques (GT-VMT’06) (2006).
Parisi-Presicce, F., Transformation of Graph Grammars, in: 5th Int. Workshop on Graph Grammars and their Application to Computer Science, LNCS 1073 (1996).
Schmidt, A´. and D. Varr´o, Checkvml: A tool for model checking visual modeling languages., in:
Proc. UML, Modeling Languages and Applications (UML’03), LNCS 2863 (2003), pp. 92–95.
Schu¨rr, A., Speciﬁcation of Graph Translators with Triple Graph Grammars, in: Workshop on Graph-Theoretic Concepts in Computer Science, LNCS 903 (1994), pp. 151–163.
Varr´o, D., Automated formal veriﬁcation of visual modeling languages by model checking., Software and System Modeling 3 (2004), pp. 85–113.
WWW Consortium, “Scalable Vector Graphics Specification.” (2003), http://www.w3.org/ TR/svg11/.
