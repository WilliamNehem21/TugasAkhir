Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 328 (2016) 47–57
www.elsevier.com/locate/entcs

Computing the Clique-width of Cactus Graphs
J. Leonardo Gonz´alez-Ruiz1,2 J. Raymundo Marcial-Romero3,
J. A. Hern´andez-Serv´ın 4
Universidad Aut´onoma del Estado de M´exico Facultad de Ingenier´ıa
Toluca, M´exico

Abstract
Similar to the tree-width (twd), the clique-width (cwd) is an invariant of graphs. A well known relationship
between tree-width and clique-width is that cwd(G) ≤ 3 · 2twd(G)−1. It is also known that tree-width of Cactus graphs is 2, therefore the clique-width for those graphs is smaller or equal than 6. In this paper, it is shown that the clique-width of Cactus graphs is smaller or equal to 4 and we present a polynomial time algorithm which computes exactly a 4-expression.
Keywords: Graph theory, Clique-width, Tree-width, Complexity.


Introduction
The clique-width has recently become an important graph invariant in parameter- ized complexity theory because measures the difficulty of decomposing a graph in a kind of tree-structure, and thus efficiently solve certain graph problems if the graph has clique-width at most k. A decomposition of a graph G, to compute its clique- width, can be viewed as a finite term, Courcelle et al. [5] define a term based on a set of four operations such as: 1) the creation of vertices, 2) disjoint union of graphs,
3) edge creation and 4) re-labelling of vertices. The number of labels (vertices) used to build the graph is commonly denoted by k. A well defined combination of these operations, called k-expression, are necessary to build the graphs, which in turn defines clique-width. The clique-width or the corresponding decomposition of the

1 The author would like to thank CONACYT for the scholarship granted in pursuit of his doctoral studies.
2 Email:leon.g.ruiz@gmail.com
3 Email:jrmarcialr@uaemex.mx
4 Email:xoseahernandez@uaemex.mx

http://dx.doi.org/10.1016/j.entcs.2016.11.005
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

graph is measured by means of a k-expression [12]. As the clique-width increases the complexity of the respective graph problem to solve increases too, in fact for some automata that represent certain graph problems (according to the scheme in Courcelle’s main theorem), computation runs out-of-memory, see [16] for some examples of graphs with the clique-width 3 or 4 .
It is important to look for an alternative graph decomposition that can be applied to a wider classes than to those of bounded tree-width and still preserve algorithmic properties. Tree decomposition and its tree-width parameter of a graph, are among the most commonly used concepts [7]. Therefore, Courcelle and Olariu proved that the clique-width can be seen as a generalization of tree-width in a sense that every graph class of bounded tree-width also have bounded clique-width [6].
In recent years, clique-width has been studied in different classes of graphs show- ing the behavior of this invariant under certain operations; the importance of the clique-width is that if a problem on graphs is bounded by this invariant it can be solved in linear time. For example Golumbic et al. [8] show that for every distance hereditary graph G, the cwd(G) ≤ 3, so the following problems have linear time solution on the class of distance-hereditary graphs: minimum dominating set, min- imum connected dominating set, minimum Steiner tree, maximum weighted clique, maximum weighted stable set, diameter, domatic number for fixed k, vertex cover, and k−colorability for fixed k. On the other hand the following graph classes and their complements are not of bounded clique–width: interval graphs, circle graphs, circular arc graphs, unit circular arc graphs, proper circular arc graphs, directed path graphs, undirected path graphs, comparability graphs, chordal graphs, and strongly chordal graphs [8].
Another major issue in graphs of bounded clique-width is to decide whether or not a graph has clique-width of size k, for fixed k. For graphs of bounded clique-width, it was shown in [3] that a polynomial time algorithm (O(n2m)) exists that recognize graphs of clique-width less than or equal to three. However, as the authors pointed out the problem remains open for k ≥ 4. On the other hand, it is well known a classification of graphs of clique-width ≤ 2, since the graphs of clique- width 2 are precisely the cographs. There are, however, some results in general. In
[9] the behaviour of various graph operations on the clique-width are presented. For instance, for an arbitrary simple graph with n vertices the clique-width is at most n − r if 2r < n − r where r is rank [13]. In [10], it is shown that every graph of clique- width k which does not contain the complete bipartite graph Kn,n for some n > 1 as a subgraph has tree-width at most 3k(n − 1) − 1, whereas in [9] is shown that the clique-width under binary operations on graphs behaves as follows, if k1, k2 are the clique-width of graphs G1, G2, respectively, then cwd(G1 ⊕ G2)= max(k1, k2), cwd(G1[v/G2]) = max(k1, k2) where G1[v/G2] means substitute vertex v in G1 by G2. Similar results are presented for the joint, composition, substitution and some other important graph operation such as edge contraction, among others.
Regarding our present work, we are interested in the class of graphs, called cactus, which consist of non-edge intersecting fundamental cycles [11]. This class belongs to the class of bounded tree-width. These graphs have already a tree like

structure, thus we can apply a well known result by Courcelle et al. [6], for any graph G, which is cwd(G) ≤ 2twd(G)+1 + 1. Thus we can obtain a quote for the clique-width of cactus graphs. This result was further improved by Corneil and
Rotics in [4] showing that cwd(G) ≤ 3 · 2twd(G)—1. It is also known that the tree- width of Cactus graphs is 2, so by using the latter inequality, the bound clique-width smaller or equal to 6 is obtained. Therefore, our main result in this paper is to show that the clique-width of Cactus graphs is smaller or equal to 4 improving the best
known bound and also we present a polynomial time algorithm which computes the 4-expression.
This paper is organized as follows. In Section 2, we recall the definitions of graphs and clique-width. In Section 3, we show that the clique-width of cactus graphs is smaller or equal than 4. In Section 4, we discuss the time complexity of the algorithm which is the main result reported in this paper. In Section 5, we present an example of the application of the algorithm. In Section 6, we give some conclusions.

Preliminaries
All graphs in this work are simple i.e. finite with no self-loops nor multiple edges and are undirected. A graph is a pair G = (V, E) where V is a set of elements called vertices and E is a set of unordered pairs of vertices. As usual we let |A| denote the cardinality of a set A. An abstract graph is an isomorphism class of a graph. A path from v to w is a sequence of edges: v0v1, v1v2,... , vn—1vn such that v = v0
and vn = w and vk is adjacent to vk+1, for 0 ≤ k < n. The length of the path
is n. A simple path is a path where v0, v1,... , vn—1, vn are all distinct. A cycle is a non-empty path such that the first and last vertices are identical, and a simple cycle is a cycle in which no vertex is repeated, except the first and last that are identical. A graph G is acyclic if it has no cycles. Pn, Cn, Kn denote respectively,
a path graph, a simple cycle, and the complete graph, all of those graphs have n
vertices.
Given a graph G = (V, E), let Gj = (V j, Ej) be a subgraph of G, if V j ⊆ V and Ej contains every edge {v, w} ∈ E where v ∈ V j and w ∈ V j, then Gj is called an induced graph of G. A connected component of G is a maximal induced subgraph of G, a connected component is not a proper subgraph of any other connected subgraph of G. Note that, in a connected component, for every pair of its vertices x, y, there is a path from x to y.
A spanning tree of a graph on n vertices is a subset of n−1 edges that form a tree. Given a graph G, let TG be one of its spanning trees. The edges in TG are called tree edges, whereas the edges in E(G)\E(TG) are called fronds. Let e ∈ E(G)\E(TG) be a frond edge, the union of the path in TG between the endpoints of e with the edge e itself forms a simple cycle, such cycle is called a basic (or fundamental) cycle of G with respect to TG. Each frond e = {x, y} holds the maximum path contained in the basic cycle that it is part of.
The graphs consisting of independent cycles are known as Cactus Graphs and

they appeared in the scientific literature more than half a century ago under the name of Husimi trees [11]. Cactus graphs have many applications, for example, in the modelling of wireless sensor networks [1] and in the comparison of genomes [17]. These graphs can be used in telecommunications when considering feeder for rural, suburban and light urban regions [15] and in material handling network when automated guided vehicles are used [14]. The cactus graphs can be syntactically recognized as connected graphs in which no edge lies in more than one simple cycle. Consequently, each part of a cactus graph is either an edge or a simple cycle. Nowadays, cactus graphs have attracted attention because some NP-hard resource allocation problems were found to be solved in polynomial time for this class of graphs.
We now introduce the notion of clique-width (cwd, for short).
Let C be a countable set of labels. A labeled graph is a pair (G, γ) where γ maps V (G) into C . A labeled graph can be defined as a triple G = (V, E, γ) and its labeling function is denoted by γ(G). We say that G is C − labeled if C is finite and γ(G)(V ) ⊆ C. We denote by G (C) the set of undirected C − labeled graphs. A vertex with label a will be called an a − port.
We introduce the following symbols:
a nullary symbol a(v) for every a ∈ C and v ∈ V ;
a unary symbol ρa→b for all a, b ∈ C , with a /= b;
a unary symbol ηa,b for all a, b ∈ C , with a /= b;
a binary symbol ⊕.
These symbols are used to denote operations on graphs as follows: a(v) creates a vertex with label a corresponding to the vertex v, ρa→b renames the vertex a by b, ηa,b creates an edge between a and b, and ⊕ is a disjoint union of graphs.
For C ⊆ C we denote by T (C) the set of finite well-formed terms written with the symbols ⊕, a, ρa→b, ηa,b for all a, b ∈ C, where a /= b. Each term in T (C) denotes a set of labeled undirected graphs. Since any two graphs denoted by the same term t are isomorphic, one can also consider that t defines a unique abstract graph.
The following definitions are given by induction on the structure of t. We let
val(t) be the set of graphs denoted by t.
If t ∈ T (C) we have the following cases:
t = a ∈ C: val(t) is the set of graphs with a single vertex labeled by a;
t = t1 ⊕ t2: val(t) is the set of graphs G = G1 ∪ G2 where G1 and G2 are disjoint and G1 ∈ val(t1), G2 ∈ val(t2);
t = ρa→b(tj) : val(t) = {ρa→b(G)|G ∈ val(tj)} where for every graph G in val(tj), the graph ρa→b(G) is obtained by replacing in G every vertex label a by b;
t = ηa,b(tj): val(t)= {ηa,b(G)|G ∈ val(tj)} where for every undirected labeled graph G = (V, E, γ) in val(tj), we let ηa,b(G)= (V, Ej, γ) such that
Ej = E ∪ {{x, y}|x, y ∈ V, x /= y, γ(x)= a, γ(y)= b};



Fig. 1. A unicycle graph where the dashed vertices denote the joining vertices from C8 to three trees.
For every labeled graph G we let
cwd(G)= min{|C||G ∈ val(t),t ∈ T (C)}.
A term t ∈ T (C) such that |C| = cwd(G) and G = val(t) is called optimal
expression of G [6] and written as |C|-expression.
In other words, the clique-width of a graph G is the minimum number of different labels needed to construct a vertex-labeled graph isomorphic to G using the four mentioned operations [2].
Computing cwd(G) when G is a Cactus Graph
Let G = (V, E) be a connected graph with n = |V |, m = |E| and such that Δ(G)≥
2. Let C be the set of fundamental cycles of G. If two distinct fundamental cycles Ci and Cj from C have common edges then we say that both cycles are intersected, that is, CiΔCj forms a new cycle, where Δ denotes the symmetric difference operation between the set of edges in both cycles. In fact, CiΔCj = (E(Ci) ∪ E(Cj)) − (E(Ci) ∩ E(Cj)) constitutes a composed cycle. If two cycles are non-intersected, we say that they are independent, i.e. two independent cycles (Ci, Cj) satisfy (E(Ci) ∩ E(Cj)) = ∅. A unicyclic graph G is one where C consists of a singleton e.g. G contains a single independent cycle. A cactus graph G is one where C consists of independent cycles.
In this section we show that the clique-width of cactus graphs is smaller or equal than 4. We firstly show how to compute the clique-width of unicyclic graphs and then we extend the algorithm for cactus graphs.
Definition 3.1 Let {Gi}i∈I be a family of graphs, a joint v /∈ {Gi}i∈I is a vertex such that Gv = (V ({Gi}i∈I ) ∪ {v}, E({Gi}i∈I ) ∪ {vvi}) for at least one vi in each
{Gi}i∈I . In other words Gv is built from the family {Gi}i∈I and a new vertex v.
An unicyclic graph can be seen as the join of vertices in a cycle Cn and a family of trees (paths) {Ti}i∈I ’s. Figure 3 shows an example of an unicyclic graph where the dashed vertices are the joints.
Lemma 3.2 If G is a unicyclic graph then cwd(G) ≤ 4
Proof. Let G = Cn S{Ti}i∈I for some family {Ti}i∈I of trees. Compute the k- expression for each {Ti}i∈I without the joining vertex to Cn. It is well known that cwd({Ti}i∈I ) ≤ 3 for each Ti,i ∈ I. Relabel the k-expression of each {Ti}i∈I in order to use exactly two labels. One label for the root and the other label for the rest of the vertices of the tree. It is also well known that cwd(Cn) ≤ 4. We show how to

combine the labels in order to compute the clique-width of G. Assume that a and b are used as labels of the root and the rest of the vertices of each tree respectively. Let c and d be the free allowed labels to be used. We built the k-expression of Cn beginning with a joint vertex v. Make a label c(v).
* Built the disjoint union of c(v) and each tree {Ti}i∈I for which v is joint that is c(v)  {Ti}i∈I . Make an edge between c and the root label of each tree {Ti}i∈I for which v is joint, that is ηc,a. Relabel the root vertex of each {Ti}i∈I by b, i.e ρa→b. That means that the available labels are a and d. Since c(v) is the label of the initial vertex of Cn it must have a unique label to close the cycle. We rename c by d, i.e. ρc→d, so we have the free labels a and c. We use a and c to built the path from d to the next joint vertex, it can be done by alternating the labels and making an edge between them, those vertices whose unique edge in the cycle have been built are relabeled by b. There are two possible labels for the next joint vertex a or c. In any case we can relabel the joint vertex such that it is always c (if it is c there is nothing to be done, if it is a we change c by b and a by c).
We repeat the process from * to joint the new trees {Ti}i∈I . When the last joint vertex c(v) is reached, the k-expression from c(v) to d is built, using the labels a,b and c.	2

Algorithm 1 shows the procedure to compute the k-expression of an unicyclic graph.
We now describe how to compute the clique-width when G is Cactus. A depth first search spanning tree is a spanning tree built using the depth-first traversal algorithm, also a depth first search graph is defined. Let G = (V, E) be a connected graph, and TG a depth first search spanning tree whose set of fundamental cycles C are independent, then an enumeration of C is computed as follows:
Choose (arbitrarily) an element C1 ∈ C.
For each C ∈ C, C /= C1 compute min{|path(v, w)| | ∀v ∈ C1, ∀w ∈ C} where
path(v, w) are the edges in the path from v to w in TG.
Sort the elements of C by its minimal path with respect to C1. Elements of C
with the same minimal path can be sorted randomly.
A partition of G into unicyclic graphs is defined as follows:

Definition 3.3 Let G be a cactus graph, a family of subgraphs {{Gi}i∈I } of G is built as follows:
A depth first search graph is built over G, choosing an x ∈ C1 as the root node, starting the search, for instance, with the node x with minimum degree, and selecting among different potential nodes to visit, the node with lowest degree first and with lowest index in its label as a second criterion. Then, we obtain a unique depth first search graph Gj (in the set of all possible depth-first graphs),
which we denote here as Gj = df s(G).
For each Ci ∈C 



Algorithm 1 Procedure that computes k-expression(G) when G is unicyclic.
1:  procedure k-expression(G)
2: let (C be the unique cycle of G)
3: for each tree {Ti}i∈I \ C of G {paths are included} do
4:	{Ti}i∈I = {Ti}i∈I -expression({Ti}i∈I ) {it is well known that cwd({Ti}i∈I ) ≤
3}
5:	Relabel the root of {Ti}i∈I by a and relabel the remaining vertices by b
6: end for
7: k = ∅
8: for each joint vertex v of C {the join is given with some trees {Ti}i∈I } do
9:	c(v){Make a new node label}
10:	k = c(v)  {Ti}i∈I   k
11:	ηc,a(k) {Make an edge from the node of the cycle to each tree {Ti}i∈I who is joined with}
12:	ρa→b(k) {Relabel a by b in the new graphs to free a label}
13:	if v is the first joint vertex then
14:	ρc→d(k) {Relabel c by d in the new graph to remember the initial node of the cycle}
15:	end if
16:  add to k the k-expression of path(v, w) \ w where w is the nearest joint vertex of v {Use the labels a and c to build the edges and b to rename the interior vertices of path(v, w) \ w, such that the last vertex is label with a and the other vertices with b they are enough since cwd(Pn) ≤ 3}
17: end for
18: ηc,d(k) {Close the cycle}

Gi = Ci  {path(v, w) | (w is a leaf or w ∈ Cj ∈ C,i /= j) and
v∈Ci
/ ∃x ∈ Ck,x ∈ path(v, w),k /= j}

Lemma 3.4 If G be a cactus graph, then the family of subgraphs {Gi}i∈I over G
by Deﬁnitions 3.3 forms a set partition of E(G).
Proof. Let X, Y ∈ ∪{Gi}i∈I,X /= Y , then by definition X ∩ Y = ∅. If X or Y are unitary, assuming X = {e}, e is not member of Y because cycle(e) is independent in G and has no common edges with any other cycle in G. If X and Y are not unitary then they have no common edges because in other case, we can build S
with the common edges of X and Y and S holds the condition in Definition 3.3, and then X = Y .
Due to each element e ∈ E(G) belong to a unique partition then ∪{Gi}i∈I = G.
2	2
Lemma 3.5 Let G be a cactus graph and {Gi}i∈I a family of subgraphs over G as speciﬁed in Deﬁnitions 3.3. For each pair of graphs Gk, Gj in {Gi}i∈I , either V (Gk) ∩ V (Gj)= ∅ or V (Gk) ∩ V (Gj)= {v} is a singleton.

Proof. By contradiction suppose that V (Gk)∩V (Gj) /= ∅ and V (Gk)∩V (Gj) /= {v} it means that there are at least two vertices, let say v1, v2 in the intersection, that the edge e = (v1, v2) belongs to the intersection, contradicting the hypothesis that Gk and Gj have a set of disjoint edges. 2	2
Lemma 3.6 Each {Gi}i∈I is an unicyclic graph.
Proof. Definition 3.3, construction step 2.	2
We call the set of vertices in pairwise  V ({Gi}i∈I ), the joining vertices of the set of unicyclic graphs.
Algorithm 2 computes cwd(G) where G is a cactus graph. The input of the algorithm is the partition detailed above.

Algorithm 2 Procedure that computes cwd(G) when G is a cactus graph, from the set of unicycle graphs Gj such that G = S Gj.

1: procedure cwd(G)
2: for each Gj who has exactly one joint vertex v {select the j where Cj has maximal path with respect to C1} do
3:	kj = k-expression(Gj \ v)
4: end for
5: for each Gj who has more than one joint vertex do
6:	for each joint vertex v{we assume without loss of generality that the sub- graphs G who have v as a joint vertex have been computed} do
7:	k =  kj-expression(Gj )
8:	c(v){Make a new node label}
9:	ηc,a(k){we assume that each graph Gj has two labels: a is the label of each vertex to be joint, b is the label of the other vertices}
10:	ρa→b(k){Relabel a by b in the joined graphs to free a label}
11:	k = k-expression(path(v, w)) where w is the next joint vertex{label of v =
d, labels of the vertices /= w can be set to b and label w = c}
12:	end for
13: end for

The correctness of Algorithm 2 is supported by the following theorem.
Theorem 3.7 If G is a cactus graph then Algorithm 2 computes cwd(G) ≤ 4.
Proof. Let G = S Gj where each Gj is unicyclic. The clique-width of each Gj is smaller of equal to 4, i.e cwd(Gj ) ≤ 4. Line 2 of algorithm 2 begins with the Gj who have exactly one joint vertex v. So the k-expression of each Gj \ v can be rewritten with two labels, one is used for the vertices to be joint with v and the other for the rest of the vertices. The next steps in the construction of the k-expression is similar to the one of unicyclic graphs substituting trees {Ti}i∈I for unicyclic graphs
{Gi}i∈I who has more than one joint vertex.	2

Time Complexity Analysis
We discuss the time complexity of Algorithm 2 which is the main result reported in this paper. The complexity of Algorithm 2 is given by the two embedded procedure loops (lines 5 and 6) together with the call to Algorithm 1 (lines 7 and 11). The first loop (line 2) is outside the embedded loops so its complexity is considered apart.
The loop which begins at line 5 and ends at line 13 of Algorithm 2 has complexity
|C| which is the number of independent cycles of the graph. Since the graph is cactus and simple (neither loops nor parallel edges are in the graph), in the worst case there are [ n ♩ independent cycles. The loop between lines 6-12, takes each joining vertex. Due to the fact that in the worst case there is a joint for each pair of unicycles, there
are at most [ n ♩ joining vertices. Lines 7 and 11 call k-expression({Gi}i∈I ) whose computation is linear with respect to the number of vertices of the unicyclic graph. The worst case time complexity of Algorithm 1 is |V ({Gi}i∈I )| = n when there is a unique unicyclic. Considering the embedded loops and the calls to Algorithm 1,
the worst case time complexity is [ n ♩× [ n ♩× n which is O(n3).
2	4
Example
We present an example of the application of Algorithm 2. Let us consider the graph
G:

According to the partition procedure, the graph is partitioned in the three sub- graphs shown below:

,	,


G2
The k-expression of G3 \ {5} is: ρc→a(ηa,c(ηb,a(b(7) ⊕ a(6)) ⊕ c(10))), then the
k-expression of G3	G2 \ {3} is given by:
ρc→a(ρd→a(ηd,c(ρc→d(ρa→b(ηc,a(kG3 \{5}) ⊕ c(5))) ⊕ c(4)))).
Finally, the k-expression of G is:

k = ρa→b(ηc,a(ρc→a(ηd,c(ρc→d(ρa→b(ηa,c(kG3 ∪G2 \3 ⊕ c(3)))) ⊕ c(8))) ⊕ c(9)))


k-expresion(G)= ηc,a(ρd→b(ρa→b(ηd,c(ηc,a(ρc→a(k) ⊕ c(2))))) ⊕ a(1))

As can be seen 4 labels are only used. The next figure shows the labels assigned to each vertex.

Conclusions
Computing the clique-width of a graph G is a classic NP-complete problem for general graphs. We establish that if the depth-first graph of a given graph G has no intersected cycles, e.g. it is Cactus then the computation of cwd(G) is a tractable problem. Even more cwd(G) ≤ 4.
Notice that those conditions for computing cwd(G) efficiently do not impose restrictions on the degree of the graph, but rather, it depends on its structure.
A further work will be the computation of the clique width of graphs which intersect on some edges. We already have a result for the computation of the clique width of what are called polygonal trees which are defined as an array of polygons of k sides that follows the structure of a tree where instead of nodes we have k-gons (polygons of k sides), and any two consecutive k-gons share exactly one edge.

References
Boaz Ben-Moshe, Amit Dvir, Michael Segal, and Arie Tamir. Theory and Applications of Models of Computation: 7th Annual Conference, TAMC 2010, Prague, Czech Republic, June 7-11, 2010. Proceedings, chapter Centdian Computation for Sensor Networks, pages 187–198. Springer Berlin Heidelberg, Berlin, Heidelberg, 2010.
Flavia Bonomo, Luciano N. Grippo, Martin Milanic, and Martn D. Safe. Graph classes with and without powers of bounded clique-width. Discrete Applied Mathematics, 199:3 – 15, 2016. Sixth Workshop on Graph Classes, Optimization, and Width Parameters, Santorini, Greece, October 2013.
Derek G. Corneil, Michel Habib, Jean-Marc Lanlignel, Bruce Reed, and Udi Rotics. Polynomial-time
recognition of clique-width ≤ 3 graphs. Discrete Applied Mathematics, 160(6):834 – 865, 2012. Fourth Workshop on Graph Classes, Optimization, and Width Parameters Bergen, Norway, October 2009Bergen 09.
Derek G. Corneil and Udi Rotics. Graph-Theoretic Concepts in Computer Science: 27th InternationalWorkshop, WG 2001 Boltenhagen, Germany, June 14–16, 2001 Proceedings, chapter On the Relationship between Clique-Width and Treewidth, pages 78–90. Springer Berlin Heidelberg, Berlin, Heidelberg, 2001.
Bruno Courcelle, Joost Engelfriet, and Grzegorz Rozenberg. Handle-rewriting hypergraph grammars.
Journal of Computer and System Sciences, 46(2):218 – 270, 1993.
Bruno Courcelle and Stephan Olariu. Upper bounds to the clique width of graphs. Discrete Applied Mathematics, 101:77 – 114, 2000.
Fedor V. Fomin, Petr A. Golovach, Daniel Lokshtanov, and Saket Saurabh. Intractability of clique-width parameterizations. SIAM Journal on Computing, 39(5):1941–1956, 2010.
Martin Charles Golumbic and Udi Rotics. Graph-Theoretic Concepts in Computer Science: 25th International Workshop, WG’99 Ascona, Switzerland, June 17–19, 1999 Proceedings, chapter On the Clique—Width of Perfect Graph Classes, pages 135–147. Springer Berlin Heidelberg, Berlin, Heidelberg, 1999.
Frank Gurski. Graph operations on clique-width bounded graphs. CoRR, abs/cs/0701185, 2007.


Frank Gurski and Egon Wanke. Graph-Theoretic Concepts in Computer Science: 26th International Workshop, WG 2000 Konstanz, Germany, June 15–17, 2000 Proceedings, chapter The Tree-Width of Clique-Width Bounded Graphs without Kn,n, pages 196–205. Springer Berlin Heidelberg, Berlin, Heidelberg, 2000.
Andreas Gbel, Leslie Ann Goldberg, and David Richerby. Counting Homomorphisms to Cactus Graphs Modulo 2, pages 350–361. Schloss Dagstuhl Leibniz-Zentrum Informatik, 2014.
Sang il Oum and Paul Seymour. Approximating clique-width and branch-width. Journal of Combinatorial Theory, Series B, 96(4):514 – 528, 2006.
O¨ jvind Johansson. Clique-decomposition, NLC-decomposition, and modular decomposition - relationships and results for random graphs. Congr. Numer, 1998.
O. Kariv and S. L. Hakimi. An algorithmic approach to network location problems. i: The p-centers.
SIAM Journal on Applied Mathematics, 37(3):513–538, 1979.
W. L. G. Koontz. Economic evaluation of loop feeder relief alternatives. The Bell System Technical Journal, 59(3):277–293, March 1980.
Alexander Langer, Felix Reidl, Peter Rossmanith, and Somnath Sikdar. Practical algorithms for {MSO}
model-checking on tree-decomposable graphs. Computer Science Review, 1314:39 – 74, 2014.
Benedict Paten, Mark Diekhans, Dent Earl, John St. John, Jian Ma, Bernard Suh, and David Haussler. Research in Computational Molecular Biology: 14th Annual International Conference, RECOMB 2010, Lisbon, Portugal, April 25-28, 2010. Proceedings, chapter Cactus Graphs for Genome Comparisons, pages 410–425. Springer Berlin Heidelberg, Berlin, Heidelberg, 2010.
