Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 304 (2014) 97–110
www.elsevier.com/locate/entcs
Abstract Semantics for Alias Analysis in K
Irina M˘ariuca As˘avoae3
Computer Science Faculty University Alexandru Ioan Cuza Ia¸si, Romania

Abstract
This paper presents an approach to integrating analysis and verification methods in the K framework. We adopt the abstract interpretation perspective where the concrete system to be analyzed/verified is mapped into a suitable abstract system, and collecting semantics is applied over the abstract system to obtain the analysis/verification method itself. As such, we present the K perspective of collecting semantics over K operational semantics for abstract systems. For a good degree of generality we consider that abstract systems are K specifications of (finite) pushdown systems. We give the collecting semantics as a generic set of K rules parametrized by the K specification of a finite pushdown system. Further, we describe a case study which instances collecting semantics with alias analysis. For this, the abstract system is defined as an imperative language which maintains enough pointer and flow information for alias analysis to be decidable. The K specification of this imperative language fits the frame of a finite pushdown system specification.
Keywords: abstraction, collecting semantics, pushdown systems, alias analysis

Introduction
The spark of the K framework [14] is the observation that computation is expressed naturally with rewriting. The source of inspiration for K is the Rewriting Logic Semantics project [9,19,10] which has the declared purpose of unifying algebraic denotational semantics and operational semantics. This unification is achieved by considering the two semantics as different views over the same object. Namely, denotational semantics views the rewriting logic specification of a language as a designated model, while operational semantics focuses on the execution of the same specification.
K is built upon a continuation-based technique and a series of notational con- ventions to allow for more compact and modular programming language definitions. K definitions can be mechanically translated into rewriting logic, and in particular

1 Contract ANCS POS CCE, O2.1.2, ID nr. 602/12516, ctr.nr 161/15.06.2010, DAK.
2 European Social Fund in Romania, under the responsibility of the Managing Authority for the Sectoral Operational Programme for Human Resources Development 2007-2013 [grant POSDRU/88/1.5/S/47646]
3 Email: mariuca.asavoae@info.uaic.ro

http://dx.doi.org/10.1016/j.entcs.2014.05.005 1571-0661/© 2014 Published by Elsevier B.V.

into Maude, to obtain program analysis tools or interpreters based on term rewrit- ing. This capability makes K an executable framework, with K-Maude its prototype implementation [15,18].
A K definition is an executable specification of a transition system whose com- putations are obtained by the execution of the K definition. Moreover, one can also reuse a K definition to enable richer executions as, for example, sets of computations. When producing the plain computations, K can be seen as an interpreter while, when producing sets of computations, K can also be used as an analyzer/verifier for the specified transition system. This is the idea of the current paper in a nutshell and we frame it under the methodology proposed by abstract interpretation.
In abstract interpretation, a particular analysis/verification method is achieved by defining collecting semantics over the examined transition system [4,5]. Namely, the transition system is first transformed into a simpler “abstract” one such that the operational semantics of the two systems “agree” on the analyzed/verified set of properties. Then, collecting semantics relies on the operational semantics of the abstract transition system and collects its computations via a forward or backward fixpoint iteration. Hence, the analysis/verification methods are a semantic reflection of the operational semantics.

Contributions summary
In this paper we present an infrastructure for expressing in K the reflection of operational semantics into collecting semantics, and the alias analysis instantiation of this reflection. The cornerstone of this infrastructure is the choice of pushdown systems as suitable K definitions. The semantics reflection is nicely captured in K by the configuration abstraction mechanism and definitional modularity. The choice of pushdown systems as focal point for this study is justified by the generality of the notion, the already available theoretical results, and the close resemblance with K definitions. By the latter similitude we mean that the continuation-based technique used in K gives the stack aspect to the k-cell, while K rules usually rely on a pushed down stack mechanism.
In Section 2 we present an infrastructure for the K specification of analy- sis/verification methods for pushdown systems. In more detail, in Section 2.1 we present a discussion on the K representation of pushdown systems. We use the K specification of a pushdown system as support for deriving the analysis/verification infrastructure in Section 2.2. We also argue the opportunity to consider pushdown systems and their K specification in Section 2.3.
In Section 3 we present a case study of an abstract imperative programming language with procedures and objects, SIL˙K , via its K specification. SIL˙K is of interest in the context of the K framework for the following reasons:
This is a research language introduced in [17,16] with several bisimilar semantics. In Section 3.1 we present the K specification of one of these semantics. In partic- ular, this semantics exhibits algorithmic details which emphasize the versatility of K in the area of algorithm formulation.

This particular semantics of SIL˙K has the useful feature of producing a finite reachable state space. A benefit brought by using this semantics is decidability of the analysis/verification methods. In Section 3.2 we present alias analysis as an instantiation of the general method for analysis/verification from Section 2.2.
The current work started with the task of giving a faithful K specification of the “on paper” semantics provided in [17,16], K specification which we call SIL˙K (Section 3.1). The authors of [17,16] give the semantics as a pushdown system spec- ification. Consequently, a methodological view of the work on SIL˙K via pushdown systems comes in naturally (Section 2.1). Moreover, due to its continuation-based feature, K proves to be a suitable specification environment for pushdown systems (Section 2.3). The view of SIL˙K as an abstraction for alias analysis is the actual novelty in this work. We present this as methodology for pushdown systems, in Section 2.2, and as instantiation of the methodology, in Section 3.2.

Related work
The core of the current work is the semantics study given in [17,16] and the ideas promoted in the discussions with the authors of [17,16,2]. We take this opportunity to extend our thanks for the enriching collaboration on [2] where SIL˙K is extended with fields and the programs are verified, using the Maude LTL Model Checker [6], via bounded model checking for a regular language of heap properties. Note that the mere syntactic extension involves a drastic change in the semantics. Hence SIL˙K is semantically different from Shylock, the abstract language presented in [2]. The program analysis aspects approached here are a refinement of the idea presented in [1]. Earlier work on program analysis in K is presented in [8] where the analysis is given as an abstract semantics for a language of program assertions. That work evolved into the deductive verification tool proposed by matching logic [11,12,13,20]. The main difference in the current approach is that we propose an abstract semantics which is decoupled from the actual code, in the style of abstract
interpretation.
The champion semantics for the K framework is the specification of C described in [7]. There, the semantics is tested for validity and is also made to work for program verification, using the inherited model checking capabilities provided in Maude [6]. In this context, regarding alias analysis, we bring as witness the work in
[21] where C is abstracted into a context free, flow insensitive language of equalities and alias analysis is mapped into reachability. We provide a similar approach in SIL˙K , the only difference being that the alias analysis is interprocedural and flow sensitive.

Foundations
A K definition specifies some class of transition systems by means of a configuration and rules applied over the configuration. However, when reasoning about these transition systems for the purpose of analysis/verification, it is often the case that

one needs to restrict this class to ﬁnite transition systems. In Section 2.1 we propose a K perspective over a restricted class of potentially infinite transition systems, given by finite pushdown systems. The existence of decidability results on reasoning about finite pushdown systems is a further incentive for their integration in K. We exploit these results in Section 2.2. In Section 2.3 we emphasize that K definitional style induces a natural resemblance between K specifications of languages and pushdown systems.

K-speciﬁcation of the pushdown systems
We present next a general technique for specifying pushdown systems in K, by means of abstraction. First we establish a frame for the K specification of finite pushdown systems. Then we describe how to transform an infinite pushdown system into a K specification of a finite pushdown system. This transformation is given as an abstraction.
Recall that a pushdown system is a quadruple P = (Δ, Σ, ‹→, c0) where Δ is a set of control locations,Σ is a stack alphabet, and ‹→ is a subset of (Δ × Σ) × (Δ × Σ∗) representing the set of rules. A conﬁguration is a pair (δ, Γ) where δ ∈ Δ and Γ ∈ Σ∗. The set of all configurations is denoted as Conf (P) and c0 ∈ Conf (P) is the initial configuration. A pushdown system is said to be ﬁnite when the sets Δ, Σ, ‹→ are finite.
A pushdown system is equivalently described by its associated transition system Tr = (Conf (P), →, c0), with →⊆ (Δ × Σ∗) × (Δ × Σ∗). The relation → is defined such that if (δ, γ) ‹→ (δj, Γ) then (δ, γΓj) → (δj, ΓΓj), for all Γj ∈ Σ∗, where δ, δj ∈ Δ, γ ∈ Σ and Γ ∈ Σ∗.
In order to define a pushdown system P in K we first assume we have an algebraic representation for Δ and Σ. The K configuration describes the structure of Conf (P) as a nested bag of labeled cells, namely ⟨⟨Δ⟩ctrl⟨K⟩k⟩r . The continuation-based feature of K is introduced by the special cell ⟨⟩k which contains a list of computation tasks of a special sort K. In the K definition for P, we specify that Σ is a subsort of K by the K syntactic command K ::= Σ. When Γ = γ1..γn ∈ Σ∗ is introduced in the computation cell, it becomes ⟨γ1 a .. a γn⟩k, where a is the K separator for computation tasks.
The rules of a finite pushdown system become K computational rules as follows:

for any  (δ, γ) ‹→ (δj, Γ) we have the K rule ⟨  δ
δj
⟩ctrl⟨ γ
Γ
···⟩k

A few notational elements of K appearing in the above rule include the ellipses and local rewriting. The ellipses ··· appearing by the walls of a cell represent some unspecified content of that cell. For example, the ellipses in ⟨⟩k make γ the top of the continuation stack while the rest of the stack is encoded by ···. Note that in the above rule, δ represents the whole content of the ctrl cell. The local rewrites (specified with a bi-dimentional notation) trigger the local changes made to the configuration. As such, the rewrite in the k cell represents the “pop” of γ followed

by the “push” of Γ in the stack. The equivalent rewrite rule (available also in the K notation) is ⟨δ⟩ctrl ⟨γ a Γj⟩k ⇒ ⟨δj⟩ctrl ⟨Γ a Γj⟩k i.e., the corresponding subset of transitions in the transition system Tr .
The transition relation ‹→ is specified as a finite set of K rules. For defining the

K rules, we identify finite sets of patterns Δ˘
⊆ 2Δ, Σ˘
⊆ 2Σ. Being in a rewriting

environment, these patterns are naturally described using variables. We denote

these patterns as
δ˘ ∈
Δ˘ , primed or indexed, γ˘
∈ Σ˘ , primed or indexed. Also

Γ˘ = γ0.˘.γn, n ∈ N, has the property γ0.˘.γn = γ˘0..γ˘n.
The K rules for the relation ‹→ of an infinite pushdown system are defined such that:

for any (δ, γ) ‹→ (δj, Γ) there is a rule ⟨
δ˘ δ˘j
⟩ctrl⟨ γ˘ Γ˘
···⟩k such that

δ matches δ˘ and γ matches γ˘, δj matches δ˘j and Γ matches Γ˘
We associate to each of the patterns in Δ˘ and Σ˘ a unique constant, and we denote
kP the K specification of the finite pushdown system given by the configuration
⟨⟨Δ˘ ⟩ctrl⟨Σ˘ ⟩k⟩r and the above rules. Note that kP is an abstraction of P. The
coarsest choice of such an abstraction is given by the finite sets of patterns Δ˘ = 
{∅, Δ} and Σ˘ = {∅, Σ}.

K-speciﬁcation of the analysis/veriﬁcation for pushdown systems
We describe a generic approach for the analysis/verification problem P |= ϕ, where ϕ is a property of interest for P. We use the setting founded in abstract interpreta- tion where T |= ϕ is defined as collecting semantics [4], with T a transition system. Namely, the “concrete” system T is soundly transformed into an “abstract” system A and the property ϕ is verified by collecting the executions of A. Likewise, we aim to execute exhaustively kP and to collect information of interest along this execution.
Note that we can infer P |= ϕ from the collecting execution of kP only if kP is a sound abstraction of P wrt the property of interest ϕ. However, this aspect is outside the scope of the current paper.
Based on the results in [3], if there exists an infinite path in a finite pushdown system, then this is lasso shaped, i.e., there is a prefix of this path that ends in a loop. Namely, an infinite path presents a repetitive stack pattern as follows:


c0 →∗
(δ, γY ) →w
(δ, γXY ) →w
(δ, γXXY )...


Moreover, any infinite path (i.e., lasso shaped) is characterized by a finite prefix
(i.e., repetitive head) as c0 →∗ (δ, γY ) →w (δ, γXrY ), where Xr is a new term from
Σ∗ such that (δ, γXrY )= (δ, γXY ).
Example 2.1 We consider P0 = ({x, y}, {a, b, c}, ‹→0, (x, abc)) a pushdown system,

where the relation ‹→0 is defined by the set:
{(x, a) ‹→0 (y, a), (y, a) ‹→0 (x, bca), (x, b) ‹→0 (x, ϵ), (x, c) ‹→0 (y, ϵ)}
The only computation in P0 is:

(x, abc) →a
(y, abc) →a
(x, bcaabc) →b
(x, caabc) →c

(y, aabc) →a
(x, bcaaabc) →b
(x, caaabc) →c
(y, aaabc) ... 

Hence, we identify the lasso for δ as y, γ as a, X as a, Y as bc, and w as abc. This computation can be characterized by its finite prefix:


(x, abc) →a
(y, abc) →a
(x, bcaabc) →b
(x, caabc) →c
(y, aarbc)

We aim to develop a technique for reusing the K-definition of a pushdown sys- tem to obtain the collecting semantics, using a forward fixpoint iteration. The configuration in collecting semantics for kP, denoted k˘P, is defined as:
⟨⟨⟨Δ˘ ⟩ctrl⟨K⟩k⟩trace∗⟩traces ⟨⟨⟨Δ˘ ⟩ctrl⟨K⟩k⟩trace∗⟩traces′ ⟨Bag⟩collect
where Bag is the predefined K sort. The cells traces and tracesj are meant to guide the rewriting in order to obtain a breadth-first exhaustive execution. As such, traces contains the current execution level, while in tracesj we construct the next level. The breadth-first strategy is tantamount to imposing fairness in the application of rewrite rules. As usual, we need some fairness condition to ensure the monotonicity of the fixpoint iteration.
To obtain the rules for the collecting semantics, we first identify and group the rules in kP as follows:

for each γ˘ ∈ Σ˘ , δ˘ ∈ Δ˘ , consider all the rules ⟨
δ˘ δ˘i
⟩ctrl⟨
γ˘ Γ˘i
···⟩k,0 ≤ i ≤ n, where

n ∈ N is the nondeterminism factor of ⟨δ˘⟩ctrl⟨γ˘
···⟩k.

We denote by post(⟨δ˘⟩ctrl⟨γ˘ a Γ˘j⟩k) the set {⟨δ˘i⟩ctrl⟨γ˘i a Γ˘j⟩k | 0 ≤ i≤n}. We use the post operator in the K rules from Fig. 1, where the relation
  ⊆ Bag × Bag is well-founded over the contents of the collect cell. Note that post(⟨δ˘⟩ctrl ⟨γ˘⟩k) can be obtained with a search command as “search : ⟨⟨δ˘⟩ctrl ⟨γ˘⟩k⟩r =>1 ⟨⟨D : Δ˘ ⟩ctrl ⟨K : K⟩k⟩r ”.
The collecting rules in Fig. 1 simulate a shared memory model, where the cell collect is the shared memory. The content of collect cell is customized to maintain the desired outcome of the analysis/verification method. The first rule encodes the exhaustive step of execution of kP by consuming a current computation trace from traces and producing new computation traces in tracesj cell, provided that this step increases the contents of collect cell. The second collecting rule covers the case when the currently selected trace is not increasing the content of the collect cell, based on the given update operation. We left yet unspecified the content of the collect cell, because its structure and update operation depend on the targeted



rule	⟨··· ⟨⟨δ˘⟩ctrl⟨γ˘ a Γ˘J⟩k⟩trace


·
⟨	Bag
···⟩traces⟨···	·


post(⟨δ˘⟩ctrl⟨γ˘ a Γ˘J⟩k)
⟩collect
···⟩traces′

update( Bag, ⟨δ˘⟩ctrl ⟨γ˘ a Γ˘J⟩k )
when	Bag  update( Bag, ⟨δ˘⟩ctrl ⟨γ˘ a Γ˘J⟩k )



rule	⟨··· ⟨⟨δ˘⟩ctrl⟨γ˘ a Γ˘J⟩k⟩trace


·
···⟩traces ⟨Bag⟩collect

when	Bag / update( Bag, ⟨δ˘⟩ctrl ⟨γ˘ a Γ˘J⟩k )


Fig. 1. The rules for the K specification of the collecting semantics over kr.
analysis/verification method.
The switch to the next level of computations in the breadth-first exhaustive execution is made by the rule:


rule	⟨	·


bag2set(NextLevel )
⟩traces ⟨NextLevel⟩traces′	when NextLevel /= ·


·

where the operator bag2set eliminates duplicated elements from NextLevel .
The termination of the “exhaustive” execution of P designed in k˘P is ensured by the well-foundedness of the relation and the “fairness” mechanism introduced by the breadth-first like strategy. As previously mentioned, the infinite computations in pushdown systems present a repetitive pattern given by the lasso shape. The cell collect is basically formed by various representations or abstractions of the computations prefixes displayed by the exhaustive breadth-first execution of kP. Hence, the computation traces collected in the collect cell can pivot on the lasso shape, and stop the update as soon as a particular computation identifies the loop of a lasso.
With this design for the content of the collect cell, the relation  can be sim- ply inclusion because the update operation ensures the well-foundedness of the inclusion. As such, the collecting computation terminates due to the fact that the computations in kP are either finite, or reduced to finite prefixes.

Relating pushdown systems and programming language semantics
We now argue the relevance of studying pushdown systems in the context of pro- gramming language semantics. The K framework is specially designed for the spec- ification of programming language semantics. The great advantage in having this specification is the fact that we have a language interpreter directly based on the

semantics. However, note that the interpreter can be seen at work only when the semantics is instanced for some program. At this point pushdown systems show theoretical relevance, when a program is behaviorally equivalent with a pushdown system. Hence, designing a method for analysis/verification of pushdown systems in K is tantamount to giving a methodology for analysis/verification of programming languages defined in K.
Consider the K specification S for the semantics of a language and a program P in this programming language. According to the methodology provided in [20] for designing S , the k-cell behaves as the stack, while the control location is maintained by the cells containing the memory and the program. In this view, the semantics S is tantamount to the specification of pushdown systems produced by the syntactic part of S as stack language and all the cells, besides k, as control location. Note, however, that there are restrictions as, for example, the matching in the k cell has to be made always at the top.
The finiteness of the pushdown system produced for a program P with a spec- ification S is, nonetheless, worth discussing from the point of view of the analy- sis/verification methods. Infinite pushdown systems are usually handled by abstract interpretation via a sound finite projection which is expressive enough to render the desired result for the analysis/verification method of interest. Following the per- spective of abstract interpretation for state abstractions, the control locations of a pushdown system are coerced into a finite frame by means of a meta-operator.
Moreover, [5] shows that the abstraction meta-operator induces a transformation on the syntactic elements as well (i.e., the stack language). This transformation is quite natural, taking into account that some syntactic elements target parts of the control location which are abstracted away. For example, say that some branch conditions depend on current values of some variables but the abstraction eliminates the actual values of the variables. Then the branch condition is usually abstracted into nondeterministic choice and its semantics is replaced with the semantics of the abstract syntactic element. Hence, an abstraction meta-operator has to transform, as well, the rules in S into equivalent (abstract) rules from the abstract semantics.

A simple imperative language with object creation
In this section we describe SIL˙K - the K specification of a simple block-structured programming language which supports object creation, global variables, static scop- ing and recursive procedures with local variables. The language is introduced and studied in [17,16] as a pushdown system specification. Here we present a faithful K representation of the SIL˙K syntax, in Fig. 2, and semantics, in Section 3.1. This semantics is called “abstract” in [17,16] and is proved to produce ﬁnite pushdown systems. Hence we can apply collecting semantics over this abstract semantics. In Section 3.2 we exemplify collecting semantics with alias analysis. Note that we choose alias analysis because the control state of SIL˙K focuses on maintaining the so called “object identities equivalence classes”, i.e., alias classes.
A SIL˙K program consists of a finite set of procedures acting on some global and

Pgm ::= gvars: Ids lvars: Ids { Procs }
Ids ::= List{#Id,”,” }
Procs ::= ProcId :: B | Procs Procs ProcId ::= #Id
VExp ::= #Id
BExp ::= #Id = #Id | #Id /= #Id
B ::= VExp := VExp | VExp := new | B ; B | [ BExp ] B | B + B | ProcId IntBot ::= #Int | ⊥
Fig. 2. The SIL˙K syntax
local set of variables. SIL˙K is statically scoped. Upon a procedure’s call, the body of the procedure is executed with the same global variables and a fresh instantiation of the local variables. Upon a procedure’s return, the changes to the global variables are preserved, while the local variables from the procedure’s call point are restored. The assignment statement x := y assigns the identity stored in y (if any) to x, while the statement x := new creates a new object that will be referred to by the variable x. Sequential composition B1 ; B2 and conditional statements [ b ] B have the standard interpretation. Nondeterministic choice is implemented as two computational rules which reduce B1 + B2 to either B1 or B2.

SIL˙K abstract semantics
In this section we describe the K specification for the SIL˙K abstract semantics, i.e., the semantics which defines finite pushdown systems for alias analysis.
For decidability reasons, the collecting semantics has to work with a finite state model. In particular, the abstract semantics presented in [16,17] uses a memory allocation protocol with abstract memory addresses. As such, the SIL˙K state associates to each pointer variable some abstract memory address from the set
{⊥} ∪ 1..2|Vg| + |Vl|, where |Vg| and |Vl| represent the number of global and local variables, respectively, and ⊥ is associated to undefined objects. Consequently, the state space of SIL˙K programs is finite because the programs have a finite number of pointer variables, either global or local.
The abstraction modifies the statements concerning the memory allocation, namely object creation, procedure’s call and return. We devise a mechanism for defining abstractions which maintains the syntactic elements as they are in the k cell and dispatches the abstract computation in a special cell kAbs, exemplified in Fig. 3. As such, the abstract semantics for each statement is specified in two stages: ping and ped. The ping stage is implemented by a structural rule which pushes in the kAbs cell the processing of the next abstract state. The ped stage recognizes the fact of having received the next processed abstract state in the kAbs cell, hence it performs the transition which updates the memory and the top of the k cell.
The ping operator has an equational implementation which ends in the ped
normal form. Consequently, the ping-ped mechanism transforms the abstraction
`a la abstract interpretation into an equational abstraction. This transformation reflects the inherited orthogonality of the two abstractions. Namely, the equational

rule	⟨X := new ···⟩k ⟨S⟩state ⟨N⟩size ⟨	·


ping ⟨⟨S⟩sigma⟨N⟩size⟨X⟩var⟩new
⟩kAbs

[structural]
rule	⟨X := new


·

···⟩k ⟨


⟩state ⟨ped S⟩kAbs S	·

[transition]


rule	⟨P ···⟩k ⟨S⟩state ⟨G⟩gvars ⟨L⟩lvars ⟨	·


ping ⟨⟨S⟩sigma⟨G⟩gs⟨L⟩ls⟩cal
⟩kAbs

[structural]
rule	⟨	P


B a restore( S )
[transition]

···⟩k ⟨ S
SJ

⟩state ⟨ped SJ⟩kAbs ⟨···  P '→ B ···⟩pgm


·

⎛	⟨restore( SJ ) ···⟩k ⟨S⟩state ⟨G⟩gvars	⎞

rule
⎜ ⟨	·
⟩kAbs⎟

⎝ ping ⟨⟨S⟩sigma⟨SJ⟩sigma1⟨Set (G)⟩gi—gn⟨Set (G)⟩g1—gn⟨SJ⟩sigmai⟩ret	⎠


[structural]
rule	⟨restore(  )


·

···⟩k ⟨


⟩state ⟨ped S⟩kAbs S	·

[transition]
Fig. 3. The ping-ped abstraction mechanism.
abstraction is carried on an enhanced signature Σ ∪ ΣJ, where Σ is the signature of the specification for the “concrete” semantics. The restriction imposed for this particular equational abstraction is that, besides the structural rules initializing the ping stage, all the equations added for the abstraction are over the terms in ΣJ.
The procedure’s return is the most interesting abstract operator and constitutes the essence of the abstraction. The idea of this step is to leave the local variables as they were at the procedure’s call point and focus on reassigning the global variables according to the current alias partition. This operator is described in [16,17] as an iterative algorithm which reads as:
let σ be the current state and σJ be the state from the procedure’s call point (maintained in the k cell in the restore() operator);
let n be the number of global variables g1..gn and σ0 = σJ;
for 1 ≤ i ≤ n do the following if-then-else steps:
if σ(gi)= ⊥ then σi = σi—1[⊥/gi] else
if σ(gi)= σ(gj), for some j < i, then σi = σi—1[σi—1(gj)/gi] else
if σ(gi)= σ(gJ), for some freeze variable gJ, then σi = σi—1[σJ(g)/gi] else

K ::= ping BagItem | ped Map

rule	ping ⟨··· ⟨·⟩gi—gn ⟨Sn⟩sigmai ···⟩ret ⇒ ped Sn
[end structural]


rule	⟨··· Gi '→ ⊥ ···⟩sigma ⟨···	Gi
·
···⟩gi—gn ⟨··· Gi '→
⊥
···⟩sigmai

[step1. structural]
rule	⟨··· Gi '→ K Gj '→ K ···⟩sigma ⟨ Gi
·

Gs⟩gi—gn ⟨··· Gj ···⟩g1—gn

⟨··· Gj '→ Kj Gi '→
Kj
[step2. structural]
···⟩sigmai	when ¬Bool Gj in Gi Gs

rule	⟨Gi '→ K frz( G ) '→ K S⟩sigma ⟨··· G '→ Kj ···⟩sigma1

⟨ Gi
·
Gs⟩gi—gn	⟨G GGs⟩g1—gn	⟨··· Gi '→
Kj
···⟩sigmai

when ¬Bool K in S [ G GGs -Set Gi Gs ]
[step3. structural]


rule	⟨Gi '→ K S⟩sigma ⟨ Gi
·
Gs⟩gi—gn ⟨GGs⟩g1—gn

⟨	Si


Si [ nextFreeValue( S ( Gi ) , | values S | , S ) / Gi ]
⟩sigmai	when

¬Bool K in S [ frzSet( GGs )] ∧Bool ¬Bool K in S [ GGs -Set Gi Gs ]
∧Bool K /=Bool ⊥
[steps4-5. structural]
Fig. 4. The ping-ped structural rules for the abstract procedure’s return statement.

if in σi—1 all indices except ⊥ are used then σi = σi—1 else
σi = σi—1[k/gi], where k is the smallest abstract address not used by σi—1.
In Fig. 4 we present the specification of this algorithm in K. Namely, the cells
⟨⟩sigma, ⟨⟩sigma1, ⟨⟩sigmai contain the maps σ, σj and σi, respectively. The iteration is maintained in the cell ⟨⟩gi—gn which contains the global variables that are left to be processed by the algorithm. The cell ⟨⟩g1—gn maintains all global variables, and the freeze variables gj are represented as frz( g ).
Several considerations regarding the algorithm in Fig. 4: the iterative processing is implemented via the gi−gn cell. The first rule finalizes the iteration by sending the result to the ped operator. The concordance between the steps 1.-5. in the algorithm

are reflected by the rule attributes. The if-then-else cascade is implemented via matching and conditions.
Alias analysis for SIL˙K
Having the abstract semantics for SIL˙K , we can present the alias analysis as an instantiation of the collecting semantics introduced in Section 2.2. Namely, we describe the content of the collect cell and the relation  .
The  collect  cell  maintains  two  cells,  heads  and  aliases  as  follows:
⟨⟨⟨⟨K⟩k⟨Map⟩state⟩head∗⟩heads ⟨⟨Map⟩state∗⟩aliases⟩collect. The heads cell contains infor- mation used by the well-founded relation  to stop the exhaustive execution in- duced by collecting semantics. At the end of the exhaustive execution, the aliases cell contains all the necessary aliasing information. Hence, the aliases cell can be an-

alyzed, either post-mortem or on-the-fly, with queries like p =?
alias analysis.
q for a demand-driven

Recall that collecting semantics performs an exhaustive execution by means of fixpoint iteration. So, the relation  helps in realizing that certain computations reached a “partial” fixpoint, i.e., they cannot contribute any more to the collected result. Hence, we rely on the repetitive stack pattern guaranteed to be discovered in the pushdown systems and define the relation  using associative matching as follows:
is  false,  i.e.,  the  currently  considered  computation  trace
⟨⟨P a X a X a Y ⟩k ⟨S⟩state⟩trace does not contribute to the update of the collect cell, when the computation trace is a repetition of a previously collected head. Hence, the second rule in Fig. 1 is instanced as:

rule	⟨⟨P a X a X a Y ⟩k ⟨S⟩state⟩trace


·
⟨⟨P a X a Y ⟩k⟨S⟩state⟩head

	is true when the computation trace is not a repetition of any of the previously collected heads. Hence, the first rule in Fig. 1 reads as:

rule	⟨⟨P a K⟩k⟨S⟩state⟩trace


·
·


⟨post( ⟨P a K⟩k⟨S⟩state )⟩trace

⟨···	·


⟨S⟩state
···⟩aliases ⟨Hs	·


⟨⟨P a K⟩k⟨S⟩state⟩head
⟩heads

when	⟨P a K⟩k⟨S⟩state
∈/rep Hs

Note that, for efficiency reasons, we apply the ∈/rep test only when the current computation is a procedure call while in all the other cases the  relation is con- sidered to be true. The reason for this simplification is the fact that the procedure call is the only source of infiniteness in SIL˙K computations.
Example 3.1 We discuss alias analysis results for the SIL˙K program in Fig. 5. Due to space restrictions we do not present in detail how the computation for alias analysis evolves. Instead, we enlist only the first few steps and explain the reasoning

used by may and must alias over the final result.
gvars: x lvars: y { main ::  y := new; (x := y + x := new); flag; main; y := x }
Fig. 5. A simple SIL˙K program.
⟨⟨main⟩k⟨frz(x)'→⊥  x'→⊥  y'→⊥⟩state⟩trace⟨·⟩heads⟨·⟩aliases
$ ⟨⟨y := new a (x := y + x := new); flag; main; y := x a restore(frz(x)'→⊥ x'→⊥ y'→⊥)⟩k
⟨frz(x)'→⊥ x'→⊥ y'→⊥⟩state⟩trace ⟨⟨⟨main⟩k⟨frz(x)'→⊥ x'→⊥ y'→⊥⟩state⟩head⟩heads ... 
$ ⟨⟨(x := y + x := new) a B a restore(frz(x)'→⊥ x'→⊥ y'→⊥)⟩k
⟨frz(x)'→⊥ x'→⊥ y'→0⟩state⟩trace ...  where B is flag; main; y := x
$ ⟨⟨x := new a B a restore(frz(x)'→⊥ x'→⊥ y'→⊥)⟩k ⟨frz(x)'→⊥ x'→⊥ y'→0⟩state⟩trace
⟨⟨x := y a B a restore(frz(x)'→⊥ x'→⊥ y'→⊥)⟩k ⟨frz(x)'→⊥ x'→⊥ y'→0⟩state⟩trace ... 
∗
$ ⟨⟨flag a main; y := x a restore(frz(x)'→⊥ x'→⊥ y'→⊥)⟩k⟨frz(x)'→⊥ x'→1 y'→0⟩state⟩trace
⟨⟨flag a main; y := x a restore(frz(x)'→⊥ x'→⊥ y'→⊥)⟩k⟨frz(x)'→⊥ x'→0 y'→0⟩state⟩trace
∗
$ ⟨⟨main a y := x a restore(frz(x)'→⊥ x'→⊥ y'→⊥)⟩k ⟨frz(x)'→⊥ x'→1 y'→0⟩state⟩trace
⟨⟨main a y := x a restore(frz(x)'→⊥ x'→⊥ y'→⊥)⟩k ⟨frz(x)'→⊥ x'→0 y'→0⟩state⟩trace
∗
⟨⟨frz(x)'→⊥ x'→0 y'→0⟩state⟨frz(x)'→⊥ x'→1 y'→0⟩state⟩aliases ...  $ ... 
Note that in this example we use flag as a point of interest for answering the query “What is the alias information at that particular point in the program?”. A global alias analysis will use flags for each program point.
At branching points, we assign to each trace a unique watermark (as a Boolean sequence) which is propagated to the state cells in aliases. As such, at the end of the analysis we can reason about the execution paths. For example, until the end of the analysis, the branch with x := new will produce in the aliases cell the states: (⊥, 1, 0)1, (1, 2, 0)11, (2, 1, 0)111, (1, 2, 0)1111, (2, 1, 0)11111 (where by (a, b, c)i we un-
derstand ⟨frz(x)'→a x'→b y'→c⟩state, while i is the watermark). A query for must

alias x =?
y identifies this execution path and answers “no” to the query. Meanwhile,

the same query for may alias identifies the collected state (⊥, 0, 0)0 and answers “yes” to the same query.

Conclusions and Future Work
In this paper we propose a technique for defining analysis and verification methods over K specifications of abstract semantics. In short, we apply collecting semantics over K definitions given as finite pushdown systems. We instance this technique with alias analysis for an abstract semantics of SIL˙K .
We plan to apply the K collecting semantics technique to model checking the abstract semantics of Shylock, an extension of SIL˙K with object fields. Furthermore, we plan to study and standardize a K methodology for defining abstractions `a la abstract interpretation over “concrete” semantics, i.e., already defined semantics for “real” programming languages.
In conclusion, we would like to extend our thanks to the team of coauthors from [2] for creating the premises of this work, to the K framework and matching logic team for posing the challenge and the means not only for this work but many others, and last but not least to the anonymous reviewers for the detailed and much appreciated feedback.

References
As˘avoae, I. M., and As˘avoae, M., Collecting Semantics under Predicate Abstraction in the K Framework, Proc. WRLA, LNCS, 6381 (2010), 123–139.
As˘avoae, I. M., de Boer, F., Bonsangue, M., Lucanu, D., and Rot, J., Bounded Model Checking of Recursive Programs with Pointers in K, WRLA (2012), Accepted for presentation.
Bouajjani, A., Esparza, J., and Maler, O., Reachability Analysis of Pushdown Automata: Application to Model Checking, Proc. CONCUR, LNCS , 1243, (1997), 135–150.
Cousot, P., Abstract Interpretation, MIT course 16.399, (2005).
Cousot, P., and Cousot, R., Abstract Interpretation and Application to Logic Programs, Journal of Logic Programming, 13(2–3) (1992), 103–179.
Eker, S., Meseguer, J., and Sridharanarayanan, A., The Maude LTL Model Checker, Proc. WRLA, ENTCS, 71 (2002), 162–187.
Ellison, C., and Ro¸su, G., An Executable Formal Semantics of C with Applications, Proc. POPL, ACM, (2012), 533–544.
Hills, M., and Ro¸su, G., A Rewriting Logic Semantics Approach to Modular Program Analysis, Proc. RTA, Schloss Dagstuhl, (2010), 151–160.
Meseguer, J., and Ro¸su, G., The Rewriting Logic Semantics Project, Theoretical Computer Science
373 (2007), 213–237.
Meseguer, J., and Ro¸su, G., The Rewriting Logic Semantics Project: a Progress Report, FCT, (2011), 1–37.
Ro¸su, G., Ellison, C., and Schulte, W., Matching Logic: an Alternative Approach to Hoare/Floyd Logic,
AMAST, (2010), 142–162.
Ro¸su,   G.,   and	S¸tef˘anescu,   A.,	Matching Logic Rewriting: Unifying Operational and Axiomatic Semantics in a Practical and Generic Framework, Technical Report http://hdl.handle.net/2142/28357, University of Illinois, (2011).
Ro¸su, G., and S¸tef˘anescu, A., Matching Logic: A New Program Verification Approach, NIER ICSE’11, (2011), 868–871.
Ro¸su, G., and S¸erb˘anu¸ta˘, T. F., An Overview of the K Semantic Framework, Journal of Logic and Algebraic Programming, 79(6) (2010), 397–434.
Ro¸su, G., and S¸erb˘anu¸ta˘, T. F., K-Maude: A Rewriting Based Tool for Semantics of Programming Languages, Proc. WRLA, LNCS, 6381 (2010), 104–122.
Rot, J.,  A Pushdown System Representation for Unbounded Object Creation,  Internal Report http://www.liacs.nl/assets/Masterscripties/10-06-JurriaanRot.pdf, B.Sc. Thesis, Leiden University, (2010).
Rot, J., Bonsangue, M., and de Boer, F., A Pushdown Automaton for Unbounded Object Creation,
FOVEOOS, (2010), Accepted for presentation.
S¸erba˘nu¸ta˘, T. F., Arusoaie, A., Laz˘ar, D., Ellison, C., Lucanu, D., and Ro¸su, G., The K primer (version 2.5), In the current volume.
S¸erba˘nu¸ta˘, T. F., Ro¸su, G., and Meseguer, J., A Rewriting Approach to Operational Semantics, Inf. Comput., 207(2) (2009), 305–340.
S¸erba˘nu¸ta˘, T. F., Ro¸su, G., and S¸tef˘anescu, A., An Overview of K and Matching Logic, In the current volume.
Zheng, X., and Rugin˘a, R., Demand-driven Alias Analysis for C, POPL, (2008), 197–208.
