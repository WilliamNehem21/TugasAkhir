Electronic Notes in Theoretical Computer Science 180 (2007) 77–94	
www.elsevier.com/locate/entcs

On the Expressiveness of Mobile Synchronizing Petri Nets
Fernando Rosa-Velardo David de Frutos-Escrig Olga Marroqu´ın-Alonso
Departamento de Sistemas Informa´ticos y Programacio´n Universidad Complutense de Madrid, Spain
Email: {fernandorosa,defrutos,alonso}@sip.ucm.es


Abstract
In recent papers we have introduced Mobile Synchronizing Petri Nets, a new model for mobility based on coloured Petri Nets. It allows the description of systems composed of a collection of (possibly mobile) hardware devices and mobile agents, both modelled in a homogenous way and abstracting from middleware details. Our basic model introduced a colour to describe localities, but still lacked appropriate primitives to deal with security, and in fact it was equivalent to P/T nets. Then, we introduced the primitives to cope with security: a new colour for identifiers, basically corresponding to the natural numbers, that are created by means of a special transition. This mechanism allows us to deal with authentication issues. In this paper we discuss the expressiveness of the extended model with the authentication primitives. More specifically, we study several instances of the classical reachability and coverability problems. Finally, we also study a more abstract version of the mechanism to create identifiers, using abstract names, close to those in the π-calculus or the Ambient Calculus. We have proved that both models are strictly in between P/T nets and Turing machines.
Keywords: Mobility, Petri nets, security, expressiveness


Introduction
The term ubiquitous computing [12,13] describes environments full of devices that compute and communicate with their surrounding context and, furthermore, in- teract with it in a highly distributed but pervasive way. In order to describe and analyze such environments, some features must be taken into account [8], such us distributed and mobile computing, security, privacy, boundaries and trust.
In [5,10] we have presented a new model for mobility, based on Petri Nets [3]. In [5] we introduced a basic version of the model called Ubiquitous Nets, in which

٨ Work partially supported by the Spanish projects MIDAS TIC 2003-01000 and MASTER TIC 2003- 07848-C02-01.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.05.048

processors provide services to processes that request them. Processors remain fixed in their locations, whereas processes move between processors in order to obtain the resources they need. Demand and supply of services is modelled by the synchronized firing of two transitions: a service-demand transition in the involved process and a service-supply transition in the corresponding processor. Mobility is formalized by the execution of movement transitions.
In [10] this simple model is enhanced by introducing colours, getting our Mobile Synchronizing Petri Nets (MSPN’s). Now places can be occupied either by ordinary tokens or by locality tokens. The latter are used to specify the destination when firing a go transition. Next, in order to include a local identification mechanism, we add a new kind of coloured tokens. These are pairs of the form (i, n), where i is the index of some net and n ∈N.
As proved in [10], both Ubiquitous nets and Mobile Synchronizing nets without identifiers can be simulated by ordinary Petri nets. However, we did not know yet which was the expressiveness of MSPN systems when these identifiers are intro- duced. Since all along the paper we only consider this extension with identifiers, we will just use the term MSPN systems to refer to them. By means of labelled natural numbers that cannot be forged we get a mechanism to obtain authentica- tion, that abstracts from the particular cryptographic techniques used to achieve it, typically proving possession of a secret key issued by some authority. In our setting this authority coincides with the principal asking for authentication, as usually hap- pens in Ubiquitous Computing. In particular, it is enough to implement the most widely used authentication policy in Ubiquitous settings, the resurrecting duckling policy [11]. But one can argue that this mechanism based on natural numbers is too concrete, so that by examining the values of the corresponding tokens we can get information about when the identifiers were created. This is why we have also studied a more abstract version of the model, which we will call Abstract MSPN systems, where fresh identifiers are used instead of natural numbers.
We study the expressive power of both models by proving several decidability and undecidability results for several instances of the classical reachability and cov- erability problems. In particular, we prove that reachability and coverability are decidable for MSPN systems, but reachability of submarkings is not. Also, we prove that coverability is decidable in the case of Abstract MSPN systems, but reachab- ility is not. These results show that their expressive powers lie somewhere between P/T nets and Turing machines.
The paper is structured as follows. Section 2 gives an overview of MSPN sys- tems, together with an example. Section 3 considers reachability issues, whereas coverability results are presented in Section 4. Finally, conclusions and directions for further study are discussed in Section 5.

Mobile Synchronizing Petri Nets
In this section we will formally and intuitively describe Mobile Synchronizing Petri Nets (from now on, MSPN’s). In the following, we will use the following notations:

ffi for autonomous transitions, with go, succ ∈ ffi, S for services, S! = {s! | s ∈ S} and S? = {s? | s ∈ S} for offers and requests of those services respectively, · : S! ∪ S? → S! ∪ S? a conjugation function defined as s? = s! and s! = s?, L for
∞
locality names, Var L a set of locality variables, Id =	{(i, k) | k ∈ N}, Var Id a set
i=1
of identity variables with Var Aut ⊆ Var Id , two special variables τ +,τ − ∈ Var Id and
Var • = {ε}, and we take Tokens = L ∪ Id ∪ {•} and Var = Var L ∪ Var Id ∪ Var •.
Definition 2.1 A MSPN is a labelled Petri Net N = (P, T, F, λ, C) where P is the set of places, T is the set of transitions, F : (P × T ) ∪ (T × P ) → Var is a partial function from the set of arcs to variables, C : P → {L, Id , •} is a function colouring places extended to arcs by C((t, p)) = C((p, t)) = C(p), and λ : T → ffi ∪ S! ∪ S? is a function labelling transitions, such that:
For every a ∈ Dom(F ), C(a)= 1 ⇔ F (a) ∈ Var T for 1 ∈ {L, Id , •};
For every t ∈ T such that λ(t) ∈ ffi, I(t) ⊆ O(t);
For every t ∈ T with λ(t)= go, |•tL| = 1;
|{t | λ(t)= succ}| ≤ 1;
If λ(t)= succ there exists a place c such that:
{•tId } = {•tId ∩ t• } = {c} and c ∈/ •s ∪ s• for every s /= t;
F (c, t) = τ −, F (t, p) = τ + for every p ∈ t• and τ ∗ and τ − only appear in
those arcs;
where •t = {p ∈ P | (p, t) ∈ F }, t• = {p ∈ P | (t, p) ∈ F }, Px = C−1(x),
tx = •t ∩ Px with x ∈ {•, L, Id }, O(t) =	F (p, t)\{ε, τ +,τ −} and I(t) =
p∈•t
F (t, p)\{ε, τ +,τ −}.
p∈t•
A MSPN is a special kind of coloured Petri Net [6], with only three different colour types: one for localities, one for identifiers and a singleton colour type for ordinary black tokens. Arcs are labelled by variables that range over the set of values of the colour of its adjacent place, as stated in (i). Condition (ii) says that the variables in the outgoing arcs of a transition must appear in some incoming arcs, so that tokens can be consumed or moved by autonomous transitions, but not made up. Condition (iii) establishes the existence of a single locality precondition for movement transitions, those labelled by go, from where the net chooses its des- tination. According to the last two conditions, each net has at most one successor transition, in which case it has a single identifier precondition place that we will call counter of the net (denoted in the previous definition by c), that is also a postcon- dition of that transition, and that it is neither a precondition nor a postcondition of any other. These restrictions avoid the possibility to use these transitions as a mechanism to simulate ordinary counters, that is, natural variables. In particular, every time the succ transition is fired it produces a new value.
Definition 2.2 A marking M of a MSPN N = (P, T, F, λ, C) is a function M :
P → MSf (Tokens) mapping each place to a finite multiset of tokens. We will say a

marking is legal if M (Px) ⊆ MSf (x) for x ∈ {L, Id , •}.
A MSPN system is just a collection of MSPN’s and a marking of a MSPN system is a marking for each of its component nets together with a location function, mapping each net to a locality.

Definition 2.3 A MSPN system is a set 𝒩 = {Ni}n
of disjoint MSPN’s, Ni =

(Pi, Ti, Fi, λi, Ci). A marking of a MSPN system is a pair (M, loc) where M = (M1,... , Mn) is such that each Mi is a marking of the MSPN Ni and loc : 𝒩 → L is a function that maps each MSPN to a location.

Given such a marked MSPN system we will usually write P =
n
Pi, T =
i=1
n
Ti,
i=1

M (p) to denote Mi(p) when p ∈ Pi, F (a) to denote Fi(a) if a ∈ Fi and λ(t) to denote
λi(t) when t ∈ Ti. With these notations we can take markings of MSPN systems as pairs (M, loc) with M : P → MS f (Tokens). We use identifiers of the form (i, m) where i is the index of the net Ni where it was created, and m ∈ N. For that purpose, we will assume that when the system is composed of n nets only identifier tokens with its first component in {1,... , n} will appear in any initial marking (and consequently, in any marking as we will see).
MSPN’s may have by definition four types of transitions: autonomous trans- itions, synchronizing transitions, movement transitions and successor transitions. Autonomous transitions are just ordinary transitions in coloured nets [6], although we impose a constraint to the set of variables around any autonomous transition, so that locality and identifier tokens can be transferred or even replicated, but not made up (see Figure 1): The set of variables in outgoing arcs must be contained in the set of variables in incoming arcs. Since our nets belong to a special class of coloured nets their transitions fire relative to some mode, that chooses among the possible tokens that can be taken from the preconditions.
Definition 2.4 Using the previous notations, given an autonomous transition t ∈
Ti,a mode of t is any mapping σ : Var (t) → Tokens such that
σ(z) ∈ 1 ⇔ z ∈ Var T for 1 ∈ {L, Id , •}
If τ +,τ − ∈ Var (t) then σ(τ −)= (i, m) and σ(τ +)= (i, m + 1) for some m ∈ N.
For homogeneity we are assuming in the definition that every arc is labelled with a variable. However, we only need variables to distinguish between the occurrence of different locality tokens and identity tokens. That is why we introduce the special variable ε, that labels every arc that is adjacent to an ordinary black-token place. Moreover, variables from Var L will only be used for arcs that are adjacent to locality places and those from Var Id only for arcs next to an identifier place.
Definition 2.5 [Autonomous transition] Let 𝒩 be a MSPN system, t ∈ Ti with λ(t) ∈ ffi and (M, loc)a marking of 𝒩, using the previous notations. Transition t is enabled with mode σ if for all p ∈ •t, σ(F (p, t)) ∈ M (p). The reached state of 𝒩 after the firing of t with mode σ is the marking (M ', loc') given by:
For every p ∈ P, M '(p)= (M (p)\σ(F (p, t))) ∪ σ(F (t, p)).

If λ(t) /= go then loc' = loc. Otherwise, loc'(Nj)= loc(Nj) for every j /= i and
loc'(Ni)= σ(F (p, t)), where p ∈ •tL.
Movement transitions are as autonomous ones, except that they change the loc- ation of the net firing that transition. For that purpose, every movement transition has a single distinguished locality-place to specify the destination of movements. Finally, successor transitions take an identifier (i, m) and yield its successor in the same domain, (i, m + 1), whenever the transition belongs to net Ni. The arc from this special precondition place to the successor transition is labelled by τ − and every arc to an identifier postcondition is labelled by τ +. In fact, the use of these new special variables τ + and τ − is redundant, since the single precondition arc and all the postcondition arcs leading to identifier places must be labelled in this way. We just use them for simplicity in our definitions, so they are not shown in figures.
Definition 2.6 Given a pair of synchronizing transitions t1 and t2, we will say they are compatible if:

λ(t1)= λ(t2)
I(t1, t2) ⊆ O(t1, t2)
If z ∈ O(ti) ∩ Var Aut then z ∈ O(tj) for i, j ∈ {1, 2}, i /= j. where I(t1, t2)= I(t1) ∪ I(t2) and O(t1, t2)= O(t1) ∪ O(t2).
The firing of a synchronizing transition needs the presence of a compatible trans- ition in the same location. The compatibility conditions are merely syntactical: On the one hand, their labels must be conjugate, which intuitively means that one of- fers the service and the other must be requesting it; On the other hand, the pair of transitions must meet together the same constraint as autonomous transitions, that is, every variable appearing in outgoing arcs must appear in some incoming arc of any of the transitions (see Figure 1). Only when both transitions are co-located and separately fireable according to the ordinary firing rule, they can be simultaneously fired. The last condition justifies the use of the variables in Var Aut. Whenever such a variable labels a precondition arc of a synchronizing transition it must also appear as label of a precondition in its compatible transitions. In this way we can force the matching of two identifiers, each in one of the nets that synchronizes.
Definition 2.7 Let (t, t') be a pair of compatible transitions. We will call mode of (t, t') to any mapping σ : Var (t, t') → Tokens such that σ(z) ∈ 1 ⇔ z ∈ Var T for 1 ∈ {L, Id , •}, where Var (t1, t2)= I(t1, t2) ∪ O(t1, t2).
Definition 2.8 [Synchronizing transition] Let 𝒩 be a MSPN system, ti and tj two compatible transitions and (M, loc) a marking of 𝒩. We say that the pair of transitions (ti, tj) is enabled with mode σ if for all p ∈ •th, σ(F (th, p)) ∈ M (p) for h ∈ {i, j} . The reached state of 𝒩 after the firing of (ti, tj) with mode σ is the marking (M ', loc) where for every p ∈ P ,
M '(p)= (M (p)\   σ(F (p, th))) ∪	  σ(F (th, p))
h∈{i,j}	h∈{i,j}

l









Figure 1. Autonomous and synchronizing transitions
An important characteristic of this class of coloured nets is that we do not have predicates limiting the firing of transitions (the set of consumed tokens), except for the matching obtained when using the same variable in different arcs. In particular, we cannot check the disequality or inequality of tokens.
Abstract names generation
We have restricted the use of identity naturals in the previous section so that they can only be used for authentication purposes. In particular, those restrictions avoid the use of identifiers to simulate counters, that is, natural variables, as could be done if no restriction had been imposed on successor transitions.
We have indeed obtained a mechanism to implement authentication by means of identifiers containing natural numbers. However, the use of natural numbers as identities has several undesirable consequences: First, when examining a marking from the outside, one can know if an identifier was generated before or after any other of the same net, which is clearly unrealistic. Besides, we can also know that some identifiers have been created during the computation even if they are not present in the current marking. To avoid this we would need some kind of “garbage collection”, so that unused identifiers could be reused.
To avoid these problems we consider an alternative model, where the domain of identifiers Id is any countable set. The only difference between both models is that the successor transitions are changed by transitions new, that create fresh identifiers. The firing of the new transition changes accordingly:
Definition 2.9 [New transition] Let 𝒩 be a MSPN system, t ∈ T with λ(t)= new, Q the set of identifier postconditions of t and (M, loc) a marking of 𝒩. Transition t is enabled with mode σ if for all p ∈ •t, σ(F (p, t)) ∈ M (p). The reached state of
𝒩 after the firing of t with mode σ is the marking (M ', loc) given by:
For every p ∈ P \Q, M '(p)= (M (p)\σ(F (p, t))) ∪ σ(F (t, p)).
M '(q)= (M (q)\σ(F (q, t))) ∪ {η} where η ∈/ M (p)∀q ∈ Q.
Note that all the postcondition identifier tokens, even if associated to postcon- dition arcs labelled by different variables, are equal to the same value η.
In order to deal with really abstract names we need to introduce a notion of α-equivalence on markings, borrowed from renaming of bounded names in the π-calculus: We identify markings up to permutations of abstract names.
Definition 2.10 We say that two markings (M, loc) and (M ', loc') of a MSPN



Figure 2. α-equivalent markings
system are α-equivalent if there exists a bijection h : Id (M ) → Id (M ') such that:
loc = loc'
M (p)= M '(p) for all p ∈ P• ∪ PL
M (q)(η)= M '(q)(h(η)) for all q ∈ PId and η ∈ Id (M )
with Id(M ) = {η | ∃p ∈ PId ,η ∈ M (p)}. We will write (M, loc) ≡h (M ', loc') or just M ≡ M ' when there is no confusion.
As usually done, let us denote by M = (A1,... , Ak) the marking of a MSPN system with places P = {p1,... , pk} such that M (pi) = Ai. Then the marking ({•, •}, {k}, {η, η' }, {η'}} is α-equivalent to ({•, •}, {k}, {η, η' }, {η}}, where k ∈ L and η, η' ∈ Id , since the mapping η '→ η', η' '→ η is a bijection that fulfills the conditions.
Proposition 2.11 The behaviour of abstract MSPN systems is invariant under
α-conversion. More speciﬁcally, if M1 ≡h M2 and (M1, loc)[t(σ)⟩(M ' , loc') then

there is some M '
with M '
≡ M '
such that (M2, loc)[t(h(σ))⟩(M ' , loc'), where

h(σ)(x)= h(σ(x)), if x ∈ Var Id , and h(σ)(x)= σ(x), otherwise.
Proof If λ(t) /= new then take M ' = h(M2), where h(M )(p)(h(η)) = M (p)(η)

for p ∈ PId . It holds that M '
≡h M '
and M2[t(h(σ))⟩M ' . If λ(t) = new then

Id (M2) = Id (M1) ∪ {η} for some new η. Then t is fireable also in M2 with mode
h(σ), which yields M ' with Id (M ' )= Id (M ' ) ∪ {η'}. Let us define h' by extending
2	2	1
h with h(η)= η', that verifies M ' ≡h' M ' .	 
1	2
For example, M1 = (•, η, ∅) and M2 = (•, η', ∅) are two α-equivalent markings of the MSPN system composed by a single net shown in Figure 2. M1 can evolve to (∅, ∅, η) when firing A or to (∅, η, η'') for some new η'' when firing new. Analogously, M2 can evolve to (∅, ∅, η') when firing A or to (∅, η', η''') for some new η''' when firing new. In both cases the reached markings are indeed α-equivalent for any η'' and η''' such that η'' /= η and η''' /= η'. In particular, we can take η'' = η' and η''' = η, which would yield (∅, η, η') and (∅, η', η), that are indeed equivalent.
A mutual exclusion protocol
The following example models a simple protocol of mutual exclusion in a distributed setting. The system is composed of four principals: the ticket server, the ticket



Figure 3. Ticket server and forwarder agent

Figure 4. Critical server

forwarder, the critical server and the clients. The ticket server and the forwarder agent are shown in Figure 3. The ticket server (the one at the top of the figure) generates the tickets that clients must exhibit when accessing the critical section in the critical server. It outputs the tickets by synchronizing on transition ticket and tells the forwarder agent (bottom of Figure 3) to update the critical server (Figure 4) with that ticket as a valid one by synchronizing with it on transition forward. The ticket server and the forwarder agent communicate using a shared key K1, while the critical server and the forwarder do it using key K2. This is formalized simply by assuming that the variable c labelling some of the arcs is an authentication variable, that is, that it belongs to Var Aut. At this point the forwarder agent can go to l, the location where the critical server is, and update it, that is, synchronize with it on transition update and output the identifier that the ticker server gave to the client. The clients, that may be like the one in Figure 5, after receiving their ticket, can go to the location where the critical server is located and log in. Only at that moment, and showing its ticket once again, they can access the critical section, represented by transition critical. Only after they log out a new client may log in.
The critical system is safe if two different clients can never access the crit- ical section at the same time, that is, if the following marking cannot be covered: M (p0) = 2 and M (q) = ∅ for the rest of places. In Section 4 we will prove decid- ability of coverability for abstract MSPN systems, so that the safety of the system can be automatically proved.





Reachability results
Figure 5. Clients

In this section we will consider the classical reachability problems. We will prove that reachability is decidable for MSPN systems, but undecidable for abstract ones. Instead, submarking reachability is also undecidable for MSPN systems, what will distinguish them from P/T nets, proving that they are more expressive.
Reachability is decidable for MSPN systems
We prove decidability of reachability for MSPN systems by reducing it to reachabil- ity for MSPN systems without identifiers. As we proved in [10] these class of MSPN systems is equivalent to ordinary P/T nets, for which reachability is decidable [9]. Given the MSPN system 𝒩 = {N1,... , Nn} and the marking (M, loc) to reach from the initial marking (M0, loc0), we construct the associated system without identi-
fiers 𝒩∗ = {N ∗,... ,N ∗} with initial marking (M ∗, loc0) and a marking (M ∗, loc)
1	n	0
such that it is reachable in 𝒩∗ from (M ∗, loc0) if and only if (M, loc) is reachable
from (M0, loc0) in 𝒩.
Without loss of generality, we can suppose that every net Ni has a counter place, marked in M with an identifier token (i, ni). If that is not the case for some net Ni we can always add an isolated place, and mark it with the maximum identifer (relative to its second component) of the form (i, k) appearing in M0. Then, let us denote by Id = {(i, k) | 0 ≤ k ≤ ni, 1 ≤ i ≤ n}, the set of identifer tokens that can appear on any sequence of markings reaching M . The key point is to unfold each p ∈ PId to {p(i, k) | (i, k) ∈ Id }, so that each token in a place p(i, k) will simulate the occurrence of the identifer (i, k) in p. Of course, this simulation only works for a finite amount of time, as long as only identifiers in Id appear, which is enough to decide reachability of (M, loc).
We also need to unfold those t ∈ T adjacent to identifier places. For it, we will consider partial modes.
Definition 3.1 Let t be a transition of a MSPN system. We call partial mode of t to any mapping σ : Var Id (t) → Id such that if λ(t) = succ and t ∈ Ti then σ(τ −)= (i, m) and σ(τ +)= (i, m + 1), for some m ∈ N.
Partial modes are modes that are only defined in Var Id (t), the set of identifier variables, that is, modes that only decide which identifiers (not which localities) are taken from the preconditions. Now we unfold each t ∈ T into {tσ | σ : V arId (t) →

l


l






Figure 6. Unfolding of a MSPN system with respect to M(c)={2} and M(p)=∅

Id , σ partial mode }. If (t, p) is an arc of some net in 𝒩 with C(p) = Id we add arcs {(tσ, p(j, k)) | σ(F (t, p)) = (j, k)}, and analogously for (p, t).
Lemma 3.2 Let t be a transition of a MSPN system and σI a partial mode of t. If σ is a mode for t then there is a mode σL for tσI such that σ = σI HσL. Reciprocally, if σL is a mode for tσI then σI H σL is a mode for t.
Thus, the firing of tσI may simulate any firing of t in some mode that extends
σI. In particular, by definition of partial mode, whenever λ(t) = succ for t ∈ Ti,

q ∈ •tId we are adding arcs (q(i, m), tσ) and (tσ, p(i, m + 1)) for every p ∈ t•
and

any σ with σ(τ −) = (i, m). Figure 6 shows an unfolding of a very simple net. In that case Id = {(1, 0), (1, 1), (1, 2)} ≈ {0, 1, 2}.
For any marking M of 𝒩 with M (PId ) ⊆ Id we define M ∗ of 𝒩∗ by

M ∗(q)= ⎧⎨
⎩
M (q) if q ∈ P• ∪ PL
M (p)((i, m)) if q = p(i, m) for p ∈ PId

Then we have the following result.
Theorem 3.3 Using the previous notation, if Mi(p) ⊆ Id ∀p ∈ PId and i ∈ {1, 2}, then (M1, loc1)[t(σL H σI)⟩(M2, loc2) ⇔ (M ∗, loc1)[tσ (σL)⟩(M ∗, loc2).
1	I	2
Corollary 3.4 Reachability is decidable for MSPN systems.
Proof If (M, loc) is the marking whose reachability we want to decide, we define the MSPN system without identifiers shown above. By the previous theorem, that system faithfully simulates the original system as far as only identifer tokens in Id appear. Since M is reachable if and only if there is a sequence of states with identifiers within Id that reach M , we have that M is reachable in the original system if and only if M ∗ is reachable in the simulation, where reachability is decidable. 
Note that the key fact to obtain this last result is that the value of the counter of each net component is a bound of the identifiers generated by that net in the current marking of the system.
Reachability is undecidable for Abstract MSPN’s
We show undecidability of reachability of abstract MSPN systems by reducing reach- ability of a state ⟨p, c1 = 0, c2 = 0⟩ of a two counter machine (TCM) to that of some

marking of an abstract MSPN system, using the technique already used 1 in [4]. A TCM is a finite state machine operating on two counters, c1 and c2, that can per- form the following kind of operations on them: check whether the counter is zero; increment the counter by one; decrement the counter by one (if it’s already zero, this leaves it unchanged).
Formally, a TCM consists of a finite set of states S = {s0,... , sk} and a set of instructions I = Inc ∪ Dec: Inc(i, s, t) ∈ Inc increases counter ci by one when at state s, and moves to state t; Dec(i, s, t, u) ∈ Dec when in state s decreases the counter ci by one and moves to state t, if ci > 0, or just moves to u, otherwise. The initial state is ⟨s0, c1 = 0, c2 = 0⟩.
We reduce reachability of TCM to reachability in abstract MSPN’s by defining an abstract MSPN system, which will consist on a single net, without locality places or moving or synchronizing transitions.
At each marking there will be a single valid identifier value. To identify that value we use a special place current , where we storage the identity token with the current valid name. Then, we will simulate the value of the counter ci with the amount of (valid) tokens in place ci. We use ordinary places {s0,... , sk}, one for each state of the TCM, so that a token at si means that the TCM is at the state si. Moreover, we will use some other auxiliary ordinary places to manipulate the control.
Instructions of the form Inc(i, s, t) are simulated straightforwardly, by adding to ci a copy of the token at current and passing the control (that is, one black token) from s to t (see Figure 7). However, those of the form Dec(i, s, t, u) can only be weakly simulated, since we do not have the chance of checking for zero. The key idea is to decide non-deterministically whether ci is zero or not and proceed. As a consequence, we can have both faithful and incorrect simulations of the TCM. In a correct run of the system, only valid tokens (those that coincide with the value stored at current ) appear in places c1 and c2.
Figure 8 shows the case where we choose to decrement the counter, which can only be done when it is legal to do it, that is, when there is a (valid) token at the counter. In that case we can remove one of those valid tokens and move the black token from the old state to the new one. The case in which we guess that ci is zero is more tricky, since this could be a bad guess. Figure 9 shows the simulation in that case. In order to identify whether we made a good guess, we will generate a new valid name and substitute (transition swap) every token at the other counter with the new valid name. Since we do not manipulate counter ci, only if the guess was correct (that is, if counter ci had no tokens) we will maintain the invariant that says that every token appearing at the counters is valid, since invalid tokens cannot be removed. Once we have swapped every old token by the new valid one we can fire reset . Once again, it could be possible to fire this transition even when not every invalid identifier in the counter has been replaced, which would also leave invalid garbage identifiers.

1 Thanks to G. Delzanno for suggesting us to reuse here that technique we developed some time ago for the study of timed nets.

current	ci

s		t

Figure 7. Simulation of Inc(i, s, t)

current
x	x

s		t

Figure 8. Simulation of Dec(i, s, t, u) (guessing ci > 0)


s 





current




cj	u


Figure 9. Simulation of Dec(i, s, t, u) (guessing ci =0)

As initial marking we take M0 with only one black token at place s0 and an arbitrary identifier token at current . The weak simulation will be enough to prove undecidability of reachability.
Lemma 3.5 The state ⟨s, c1 = 0, c2 = 0⟩ is reachable from ⟨s0, c1 = 0, c2 = 0⟩ if and only if there exists a reachable marking M from M0 such that M (s) = 1, M (t) = 0 for every t /= s in P•, M (current ) = η for some η ∈ Id , M (q) = ∅ for q ∈ PId \{current }

Proof The proof is based on the fact that any run of the constructed MSPN system that reaches a marking M in which M (ci)= ∅ simulates a run of the TCM, which means that all the guesses have been correct, because otherwise there would be garbage tokens in some of the counters, that cannot be removed by construction. Besides, all the runs of the machine can be correctly simulated, by making the correct guess when deciding whether a place is empty or not.	 
Corollary 3.6 Reachability is undecidable for abstract MSPN systems.
Proof It is well known that reachability of TCM is equivalent to reachability of the special states ⟨s, c1 = 0, c2 = 0⟩. Let us suppose that reachability for abstract MSPN systems is decidable, and use it to decide whether a given ⟨s, c1 = 0, c2 = 0⟩ is reachable. We take M such that M (s) = 1, M (t) = 0 for every t /= s in P•, M (current )= η for some η ∈ Id , M (q)= ∅ for q ∈ PId \{current }. By Lemma 3.5 we know it is reachable if and only if ⟨s, c1 = 0, c2 = 0⟩ is reachable. All we have to do is to choose any of those M and decide whether it is reachable or not. 

Submarking reachability is undecidable for MSPN’s
The result that gives title to this section can be proven in a very similar manner to that of undecidability of reachability for abstract MSPN systems, but due to its importance we prefer to present it in a different section. Indeed, the fact that reachability has been proved to be decidable for MSPN systems could lead us to the wrong impression that they are equivalent to ordinary P/T-nets but, as we will see next, this is not the case.
Given ⟨p, c1 = 0, c2 = 0⟩, a marking of a TCM, we define a MSPN system that weakly simulates it. The simulation of Inc and Dec is as before. In the case in which we guess ci = 0, the label new is changed by succ with its associated counter place counter . In order to control when the test for zero is correctly simulated, we proceed as we did in the previous section. We use a succ transition generating the identifiers for the net. Each time a zero(i, s, u) transition is executed we increment the counter and then we refresh the tokens in the place cj with the new value of the counter place. However, by definition of MSPN systems, there can only be one successor transition, so that all the counter places and succ transitions must be the same for any of such instructions. For that reason we must be careful and only allow the firing of the transition reset that corresponds to that instruction. That is why we need the extra control place as postcondition of zero(i, s, u) (see Figure 10).
Now the relation between the TCM and its weak simulation is expressed in the following proposition.
Proposition 3.7 A state ⟨p, c1 = 0, c2 = 0⟩ of the given counter machine is reachable if and only if there exists N ∈ N such that the marking MN given by MN (counter ) = MN (current ) = {(1,N )}, MN (p) = 1 and MN (q) = ∅, for every q ∈/ {counter , current, p}, is reachable in the simulation.
As an immediate consequence we have the following theorem.
Corollary 3.8 Submarking reachability of MSPN systems is undecidable.
Proof Given a state ⟨p, c1 = 0, c2 = 0⟩ of the given counter machine and the MSPN system constructed above, let M be the marking defined in every place but the counter place and place current by M (p)=1 and M (q)= ∅, for every q ∈/ 
{counter , current, p}. This submarking is reachable if and only if some marking MN is reachable (following the notations of the previous proposition), which happens if and only if the state ⟨p, c1 = 0, c2 = 0⟩ is reachable in the TCM, according to the previous result.	 
It is well known that submarking reachability in P/T nets is equivalent to reach- ability, since given a partial marking M we can build a new net with transitions that remove every token from those places not in the domain of M . Then reach- ability of the partial marking M is equivalent to reachability of the global marking M ' that extends M with M (p)= ∅ for every p ∈/ Dom(M ). But the restrictions on transitions succ avoid the possibility to remove the tokens in the counter, so that this reasoning cannot be applied to our nets.





s	





Figure 10. Simulation of Dec(i, s, t, u) with naturals as identifiers (guessing ci =0)
Both simulations of the TCM’s, the one using naturals as identifiers and the one using abstract names, use a place current , where the valid tokens are stored. In the case of natural identifiers, the token in this place coincides with the value in the counter place. However, the information that can be extracted from the value at that place is rather different in each case. If we use natural numbers, we know part of the history of the process: an upper bound on the number of created identifiers and the order in which they were created. However, if we use abstract names we do not know any of the two previous facts. In fact, we do not care for the concrete name that we find in current , since we are working under α-conversion and, therefore, it could be any concrete name.
Coverability results
In the previous section we considered reachability problems. In particular, reachab- ility in abstract MSPN systems and submarking reachability in MSPN systems have been proved to be undecidable. Fortunately, safety properties of our systems are usually defined in terms of coverability. In this section we prove that coverability is indeed decidable both for MSPN systems and abstract MSPN systems.
Coverability is decidable for Abstract MSPN’s
In order to prove decidability of coverability we use the technique based on well quasi-orders [1,2,7]. The technique consists on defining a suitable order (a well quasi-order) over the set of markings.
Definition 4.1 We say that a preorder ± (a reflexive and transitive relation) is

a well-quasi order if for every sequence (ai)∞
there are indices i < j such that

ai ± aj.
To simplify our explanations we will focus on identifier places, since identifiers are our source of infinity (the order we will define is the identity when restricted to ordinary tokens and localities). Thus, regarding identifiers, a marking is a function M : P → Id → N that says given a place p and an identifier η how many tokens η can be found in p. However, we can currify them as M : Id → P → N. Since identifiers are abstract names, the behaviour of a system does not depend on the

particular names chosen, that is, it is invariant under α-conversion, as we proved in Proposition 2.11. Then we can take as (abstract) markings the multisets in MS(P → N), and since |P | = k < ∞, also those in MS(Nk).
In this way, a marking is represented by a multiset, with the cardinality of the set of different identifiers appearing in it. Consider for instance a net with two identifier places p1 and p2 and a marking M such that M (p1) = {η, η, η', ν} and M (p2) = 
{η', ν}. That marking would be represented in this way by a multiset with cardinal- ity 3, since only three different identifiers appear in it, namely {(2, 0), (1, 1), (1, 1)}, where the tuple (2, 0) represents the identifier η, one of the (1, 1) represents η' and the other (1, 1) represents ν.
The order we are interested in for coverability is the following.
Definition 4.2 Let A and B be two elements in MS(Nk). We will write A ± B if there is an injective function h : A ‹→ B such that a ≤ h(a) for all a ∈ A, where ≤ is the punctual order in Nk, that is, (a1,... , ak) ≤ (b1,... , bk) if and only if ai ≤ bi for every i ∈ {1,... , k}.
Proposition 4.3 The relation ± on MS(Nk) is a well quasi-order.
Proof See [7] and [2].	 
Notice that the order itself takes into account α-conversion so that, for instance, in the case of a net with only two identifer places, the markings (α, β) and (β, α) are in the kernel of the order.
Lemma 4.4 The α-equivalence relation ≡ is the kernel of ±.
Proposition 4.5 The ﬁring relation of Abstract MSPN systems is monotonic with respect to ±.
Coverability of a marking M is just reachability of the ideal (upward closed set) generated by M , C(M ) = {M ' | M ± M '}. Let us define the function Pre computing the predecessors of a set of states.
Definition 4.6 We define Pre as the function from markings to sets of markings defined by Pre(M, loc) = {(M ', loc') | ∃t, σ(M, loc)[t(σ)⟩(M ', loc')} and extend it trivially to sets of states.
In order to prove the following proposition, we need the following lemma stating that the transition relation is not only monotonic but injective when dealing with comparable markings.
Lemma 4.7 If M1 ± M2, M1 /≡ M2 and Mi[t(σ)⟩M ' for i ∈ {1, 2} then we have
also M ' /≡ M ' and M ' ± M ' .
1	2	1	2
Proposition 4.8 For each marking M the set min(Pre(C(M ))) is computable, where min denotes the set of minimal elements of a set.
Proof Let Pret,σ(M )= {M ' | M '[t(σ)⟩M }. By the previous lemma it holds that
min(P ret,σ(C(M ))) = Pret,σ(M ), which is computable.  Since min(P re(C(M )))

=  min(P ret,σ(C(M ))) we only have to see that there are only finitely-many such t’s and σ’s. The only case which is not straightforward is when there exists t with x ∈ I(t)\O(t), that is, when the transition deletes a locality or an identifier token. If that variable is in a locality arc then we have to consider that any of the locality tokens appearing in the initial state may have been the one deleted. Regarding identifiers, the deleted token may be any of the ones appearing in M or any other, that we could arbitrarily choose, since we are working modulo α-conversion. In both cases, t can have been fired in a finite number of modes.	 
By definition of well structured systems [1] we have the following
Corollary 4.9 Abstract MSPN systems are well structured systems.
As proved in [1], coverability (or control state reachability, as called there) is decidable for well structured systems. Indeed, without showing every detail, the infinite increasing chains of ideals generated by a well quasi order stabilize. That is, if I0 ⊆ I1 ⊆ I2 ⊆ ··· is such a chain then there is k such that Ii = Ik for every k ≥ i. In particular, we can build the following chain of ideals: If M is the marking we want to cover, we take I0 = C(M ) and In+1 = In ∪ Pre(In) for n ≥ 0.
Since Pre is monotonic each Ii is an ideal and since I0 ⊆ I1 ⊆ I2 ⊆ ··· and ± is a well quasi-order it follows that there is an index k such that Il = Ik for all l ≥ k. Then, by construction, I0 is reachable (that is, M can be covered) if and only if the initial marking M0 ∈ Ik.
Corollary 4.10 Coverability is decidable for abstract MSPN systems.
Coverability is decidable for MSPN systems
In this section we will prove that coverability is also decidable for non abstract MSPN systems. We cannot directly apply the well-quasi-order technique in this case, with numbers as identifiers, since a suitable order that does not depend on the particular marking to be covered, is not straightforward to obtain. But we can instead prove the decidability result by means of a reduction of the problem to the case of Abstract MSPN systems.
We could try to simulate the MSPN system by an abstract replica in which the succ transitions have been substituted by transitions labelled by new, and without counter places. However, abstract MSPN systems work modulo α-conversion of identifier tokens, so that a reachable abstract marking of the abstract net would correspond in this naive simulation to all the permutations of natural identifiers in the original MSPN system. Therefore, we need a way to track the order in which the abstract names are generated, to make them correspond to a single permutation. One can imagine that this would not be easy if we needed to remind the order during an arbitrary amount of time. Fortunately, given a marking M to cover, we will only need to remind the order for a finite time: exactly that corresponding to the highest identifier in the marking.
Let 𝒩 be a MSPN system and M a marking of 𝒩. Let us define an abstract MSPN system 𝒩∗ in which coverability of M in 𝒩 is reduced to coverability of some

marking M ∗. For every component net Ni of 𝒩 we proceed as follows:
Let ni = max{n | p ∈ P, (i, n) ∈ M (p)}, we define the component net N ∗
starting from Ni, removing its counter place, and changing label succ by new.

Then we add a collection of places pi ,... , pi
, that will be used to store the ni first

1	ni
names created by Ni. To do so, we would have some auxiliary transitions that will
fire in a row, after each one of the first ni firings of transition new, filling each places
pi , with the j-th identifier created.
Then we define the marking M ∗ of the abstract system as follows: Locality
and ordinary places are left as in M . Regarding identifier places, we consider a family of different new names {ηi | 1 ≤ j ≤ ni} and we define M ∗(pi )= {ηi } and
j	j	j
M ∗(q)= {ηi | (i, j) ∈ M (q)}, where we are extending the usual notation for sets to
multisets. Then we can prove the following
Proposition 4.11 The marking M of 𝒩 can be covered starting from M0 if and only if the above deﬁned marking M ∗ can be covered in 𝒩∗ from the marking M ∗ that extends M0 with M ∗(pi )= ∅, and the adequate values in the auxiliary places.
0	j
Corollary 4.12 Coverability is decidable for MSPN systems.

Conclusions and Future Work
In this paper we have proved several results regarding expressiveness of MSPN systems with natural numbers as identifiers [10]. In particular, we have shown that reachability and coverability are decidable for MSPN systems, but submarking reachability is not, for the particular class of MSPN systems in which identifiers are basically unforgeable natural numbers generated by a counter mechanism. Al- though one could expect that submarking reachability should be easier to decide than reachability, the special restrictions constraining the use of the counter places, used to generate the identifiers, which cannot be either decreased or emptied, are responsible for this special feature of the model.
We have also considered a more abstract mechanism for the creation of identi- fiers, since if we use the successor function to generate the identifiers for authen- tication, then we have the possibility to check which identifiers were created before which, having also an upper bound on the number of identifers created. To avoid the possibility to distinguish two systems by means of these properties we now con- sider a new transition, that creates fresh names as in the π-calculus. Reachability in this case turns out to be undecidable, though coverability is still decidable, which is sufficient to check usual safety properties.
As future work, we plan to make our approach scalable. More exactly, we are investigating how, and under which hypothesis, we have to modify our name generation mechanism so that it also works in open environments. In addition, the coverability techniques seen so far can only be applied to closed systems. For instance, deciding coverability in the example shown in Section 2.2 only checks the system when the clients have that particular form, which is clearly insufficient to prove the safety of the system in an open setting, where the clients can have

any unknown behaviour. We are currently developing an alternative version of our operational semantics that take into account any potential environment. Of course, in order to be able to prove properties, we have to assume that the environment does not know certain things about the system (secret keys, passwords,...), so that this semantics must be parametric with respect to that knowledge. In this new setting we can define the analogous problems of the original semantics, such as coverability. In order to make that semantics manageable we are defining an abstract version of that open semantics, that we can use to prove properties of the original semantics. We also intend to study our model in the presence of an alternative primitive for interaction between components, namely broadcasting instead of synchroniza- tion, given that broadcasting is a widely used primitive, specially in the Ubiquitous Computing framework. Finally, we plan to extend our model with recursive or
replication operators and study to what extent do the results obtained still hold.

References
P. Aziz Abdulla, K. Cerans, and B. Jonsson. Algorithmic Analysis of Programs with Well Quasi-Ordered Domains. Inf. Comput., 160(1-2):109–127, 2000.
P. Aziz Abdulla, and A. Nyl´en. Better is Better than Well. LICS’00: 132-140, 2000.
J. Desel, and W. Reisig. Place/transition petri nets. Lectures on Petri Nets I: Basic Models, LNCS vol.1491, pp.122–173. Springer-Verlag, 1998.
D. Frutos Escrig, F. Cuartero G´omez, and V. Valero Ruiz. On non-decidability of reachability for timed-arc Petri Nets. PNPM’99. 1999.
D. Frutos Escrig, O. Marroqu´ın Alonso and F. Rosa Velardo. Ubiquitous Systems and Petri Nets. Ubiquitous Web Systems and Intelligence, co-located with ICCSA 2005, LNCS vol.3841. Springer- Verlag, 2005.
K. Jensen. Coloured Petri Nets. Basic Concepts, Analysis Methods and Practical Use.. Volume 1, Basic Concepts. Monographs in Theoretical Computer Science, Springer-Verlag, 2nd corrected printing 1997. ISBN: 3-540-60943-1.
E. C. Milner. Basic wqo- and bqo-theory. In I. Rival, editor, Graphs and Orders, pages 487-502. 1985.
R. Milner. Theories for the Global Ubiquitous Computer. Foundations of Software Science and Computation Structures-FoSSaCS 2004, LNCS vol.2987, pp.5-11. Springer-Verlag, 2004.
C. Reutenauer. The Mathematics of Petri Nets. Masson and Prentice Hall, 1990.
F. Rosa Velardo, D. Frutos Escrig and O. Marroqu´ın Alonso. Mobile Synchronizing Petri Nets: a choreographic approach for coordination in Ubiquitous Systems. In 1st International Workshop on Methods and Tools for Coordinating Concurrent, Distributed and Mobile Systems, MTCoord’05. A Satellite Workshop of Coordination 2005. ENTCS (to appear).
F. Stajano. Security for Ubiquitous Computing. John Wiley and Sons, 2002.
M. Weiser. Some Computer Science Issues in Ubiquitous Computing. Comm. of the ACM vol.36(7), pp.74-84. ACM Press, 1993.
M. Weiser. The Computer for the 21st Century. Proceedings of Human-computer Interaction: Toward the Year 2000, pp.933-940. Morgan Kaufmann Publishers Inc, 1995.
