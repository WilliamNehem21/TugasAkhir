Electronic Notes in Theoretical Computer Science 192 (2007) 5–11	
www.elsevier.com/locate/entcs

A Well-behaved LTS for the Pi-calculus (Abstract)
Pawe-l Sobocin´ski1
ecs, University of Southampton, UK

Abstract
The pi-calculus and its many variations have received much attention in the literature. We discuss the standard early labelled transition system (lts) and outline an approach which decomposes the system into two components, one of which is presented in detail. The advantages of using the decomposition include a more complete understanding of the treatment of bound outputs in Pi as well as an lts which is more robust with respect to the addition and removal of language features. The present paper serves as an overview of some of the techniques involved and some of the goals of the ongoing work.
Keywords: Pi-calculus, process calculi, semantics, labelled transition systems

The Pi-calculus [2, 10] and its many variants have been widely studied in the literature. A valid criticism is that in many cases the theory is heavily optimised for the particular variant studied – meaning that while often a pleasant simplicity is achieved in the presentation of basic theoretical results, the resulting formalism is heavily locally optimised and often not robust with respect to the equivalences or language features considered. In this paper we outline an approach which promises to give a more robust method of providing a labelled transition system on which, for instance, bisimilarity agrees with contextual equivalence. The technique is also more amenable to generalisation, in the pursuit of capturing a wider family of calculi.
The Pi-calculus, roughly, extends the binary synchronisations along a chan- nel/name, familiar from ccs, with the ability to pass names as arguments. Thus, the input prefix becomes a binder and the synchronisation itself results in a substi- tution of the communicated name for the bound variable.
The calculus inherits another binder from ccs – the restriction operator. The ability to pass names as part of a synchronous communication means that it behaves rather differently in this setting - in particular, the scope of a restriction, static in ccs, becomes dynamic essentially because restricted names can be communicated

1 Research partially supported by EPSRC grant EP/D066565/1.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.10.002

along public channels. Additionally, it behaves somewhat like a global generator of new-names - since α-conversion ensures that whichever concrete name is chosen for a restricted name, it is different from all other names in the term – in fact, the global nature of new names is also enforced in the definition of bisimulation as we shall recall below. See also [12].
The (reduction) semantics of the Pi-calculus is very similar to that of css, in fact, in the sum-free fragment we can express it essentially as the axiom
a!b.P  a?x.Q → P  Q[b/x]	(1)
closed under evaluation contexts: parallel composition and restriction – reduction is not allowed under prefix. The reduction semantics naturally leads to a contextually defined equivalence: the barbed congruence. While canonical, contextually defined equivalences are difficult to reason about directly and for this reason it is helpful to define another “semantics”: the so-called early labelled transition system (lts). The labels of the transition system aim at classifying the possible interactions with the environment. Early congruence coincides with barbed congruence, but the lts is much easier to use because of the power of coinduction.


(In)
(Out)
a!b
P −−→ P
a?b
Q −−→ Q

a?xP −−→
a!b
P
P [b/x]

P '	a/=b
a!bP −−→
P

a!(b)	'


a?b
P Q −→ P ' Q'
'
(Comm)

−−→
(Open)
P −−−→ P	Q −−→ Q
τ
b∈/fn(Q)
(Close)

a!(b)
νbP −−−→P '
P Q −→ νb(P ' Q')

P −→
P '	bn(α)∩fn(Q)=∅
P −→ P '
b∈/n(α)

P Q −→ P ' Q
(Par)
νbP −→ νbP '
(Res)

The so-called early lts, presented above for the finite, sum-free fragment without match or mismatch, is widely known and can be presented and used by humans in a fairly simple way provided that a number of conventions is followed – we shall discuss these in more detail below. In order to save space we omitted the symmetric versions of (Comm), (Close) and (Par); one normally works with an abstract syntax in which  is associative and commutative – such an equivalence relation on syntax is usually referred to as structural congruence.
It is worth mentioning that rules (Open) and (Close) perform two roles: scope extrusion and generation of new name observable (the bound output label a!(b)). The side-conditions on the derivation rules deserve some further consideration. The requirements on (Res) and (Open) are fairly obvious and inherited from ccs – they ensure that ν behaves like ccs restriction in that one cannot communicate on a
restricted channel from outside its scope. The conditions required of (Close) and
(Par) merit more attention – in particular they make sure that the (Open)/(Close)
mechanism for scope extrusion functions correctly.
Indeed, consider the process P = (νb a!b)  b?x where the scope of the restriction encompasses only the left component. If the side-condition on (LPar) was lifted one

would be able to derive the label P
a!(b)
−−−→ b?x. But, using (Close), one would then

be able to derive P	a?y −→τ
νb b?x with the result that the freely occurring b in

right component of P would have become incorrectly bound after the interaction.
The side condition on (Close) exists for similar reasons.
Even with the side-conditions, the definition of bisimulation has to be altered. In
a!(b)
particular, in the bisimulation game played on (P, Q), if P challenges with P −−−→ P ' then Q must respond if and only if b ∈/ fn(Q). Technically this is due to the side condition in the (Par) rule: consider the processes

νb a!b	and	(νb a!b)  νcc!b

which are clearly equivalent; the second component of the second process has no observable behaviour – but clearly the first process can perform a a!(b) action while the second cannot. Intuitively, this phenomenon demonstrates ν’s global behaviour as a fresh name generator – whichever name is present in the system, the fresh name observed (witnessed by the bound output label) will be different.
Sangiorgi and Walker [11, Convention 1.4.10] argue that all such problems can be solved by making sure that “... the bound names of any process or actions under consideration are chosen to be different from the names free in any other entities under consideration ...”. This is certainly true, but the convention is arguably a strong one and, conventions aside, the definition of bisimulation has been tampered with. It has also been noticed by a number of authors that conventions which are fine for humans are non-trivial to implement when using proof-assistants or theorem-provers. There have been several works [1, 6, 4] which aim at formalising these conventions, roughly the idea is to index the processes with the set of names which can appear within and consider bisimulation as a name-indexed relation. See [5] for an overview and a comparison of the approaches.
As outlined above, the lts can be considered as a tool for reasoning about a contextually defined equivalence on the reduction semantics; following this line of reasoning raises a natural question as to whether the lts can be derived in some systematic way from the reduction semantics; research in this direction was com- menced by Leifer and Milner [8] and continued by Klin, Sassone and the author [7]. In Leifer and Milner’s work, the labels of the resulting transition system are cer-

c[−]
tain contexts c[−] of the language. Roughly, for a closed term t, t −−→ t
when

c[−] allows t to reduce to t' in one step, ie c[t] → t' and c[−] is the minimal such context, in other words it doesn’t contain any redundant information in order for
the reduction to occur. The minimality condition is expressed categorically; if the underlying category of terms and contexts satisfies certain assumptions then bisim- ilarity (defined in the usual way) on the lts is a congruence. One of the limitations of the framework is that the underlying reduction system is required to consist of ground rules, which practically rules out calculi such as ccs and Pi because the reduction rules contain parameters – eg P and Q in (1). A generalisation of the theory which aims at overcoming this problem was studied in [7] – reduction rules

are open terms, and given another open term, one can compute both a minimal context and a minimal parameter which allows reduction. While work in progress, in a ccs-like setting a possible label would be of the form
−1 a?x−2
⟨a!bP,−1⟩ −−−−−−→ P −1
where the context forms an (unsubstantiated) part of the term and the labels are able to modify the context. Another feature is that the information in the labels is restricted by what can be observed in one reduction step – this rules out Pi labels which also contain the name being transmitted.
We can use some of the intuitions gained from the work described in the para- graph above to develop a new lts for the Pi-calculus. To do this we expand the calculus with a typed meta-syntax for holes and contexts, the idea is that such con- texts can form a part of a term after interaction. The meta-syntax is a simply-typed lambda calculus, with β-reduction forming a part of the structural congruence.
We start with an untyped syntax on which we give type rules, starting with two base types; a name type N and a process type P. Types in this setting are included only to make the meta-syntax formal, they certainly have less structure than usual Pi-calculus type systems based on channel types. Differently from the classical presentation, we treat ν as a standard binder which binds variables of name type. We assume a countable supply of variables of each type. In all these choices, our presentation more similar to Engberg and Nielsen’s eccs [2, 3], the “precursor” to the Pi-calculus. Actually, all the basic ingredients of the theory (scope extrusion, fresh name generation) were already present in the aforementioned work; one novelty of the Pi-calculus was the collapse of the syntactic classes of variables and names. It can be argued that the resulting simplicity is deceptive.
We use the syntactic convention of a, b for name constants, k, l for terms of name type, x, y for variables (including name variables), P, Q for terms of process type, X, Y for variables of function type. Type contexts are finite maps from variables to types. We shall consider only typed terms.

Types

σ ::= N | P | σ → σ

Syntax

M ::= x | a | 0 | M  M | M !MM | M ?xM | νxM | λx : σ.M | M (M )

Type rules



Γ▶a:N
(:Name)


Γ▶0:P
(:Zero)

Γ▶M :P	Γ▶M ':P


Γ▶M M ':P
Γ,x:N ▶M :P

(:Par)
Γ▶M :P	Γ▶k:N	Γ▶l:N
Γ▶k!l.M :P Γ,x:N ▶M :P	Γ▶k:N

(:OutPref)

Γ▶νxM :P
(:Nu)
Γ▶k?x.M :P
(:InPref)

Γ(x)=σ Γ▶x:σ

(:Var)
Γ,x:σ▶M :σ'
(:λ)
Γ▶λx:σ.M :σ→σ'
Γ▶M1:σ→σ' Γ▶M2:σ Γ▶M1(M2):σ'
(:App)

We give a brief outline of the part of the lts concerned with communication and scope extrusion below. The lts is defined structurally. Because we operate in a typed setting, the states of the lts are pairs of typed context and term. We denote such pairs syntactically as ⟨Γ | V ⟩ where Γ is a type context and V is a term. The interplay between the type context and the term is explained by a type preservation result, described following an intuitive account of the transitions.
The labels in the fragment are the usual ccs labels. The intuitive idea is that a process offering an output on a channel k can perform the interaction with a context, and evolve into a process consisting of its continuation in parallel with the interacting context, which has been passed the communicated name. This context is explicitly described in the resulting state as a lambda abstraction which binds a

variable of type I = N → P (cf
(Out)). On the other hand, a process offering

an input on a channel k can perform the communication with the context and
obtain some name – the result is a lambda abstraction which binds a variable of type N (cf (In)). A process with a capability to input on k in parallel composition with a process which has a capability to output on the said channel can perform the synchronisation without the need for an external context – the abstractions are combined via an application (cf (Tau)). There is a technical similarity to the presentation of the late semantics using abstractions and concretions [9]; see the (Comm) rule below. Notice, however, that we do not say anything about the actual nature of the name transmitted in the labels. Ziegler, Miller and Palamidessi’s [13] also use higher order abstract syntax within the setting of the Pi-calculus, but their aims are somewhat different.

LTS - Communication fragment




k?
⟨Γ | k?xP ⟩ −→ ⟨Γ | λx:N .P ⟩
⟨Γ | P ⟩ −→ ⟨Γ | U ⟩
k?
(In)



( In)


k!
⟨Γ | k!lP ⟩ −→ ⟨Γ | λX:I .P X(l)⟩
⟨Γ | P ⟩ −→ ⟨Γ | T ⟩
k!
(Out)



( Out)

⟨Γ | P Q⟩ −→ ⟨Γ | λx:N .U (x)  Q⟩	⟨Γ | P Q⟩ −→ ⟨Γ | λX:I .T (X)  Q⟩

⟨Γ,y:N | P ⟩ k? ⟨Γ,y:N | U ⟩	(k/=y)

k?

(νIn)
⟨Γ,y:N | P ⟩ k! ⟨Γ,y:N | T ⟩	(k/=y)

k!

(νOut)

⟨Γ | νyP ⟩ −→ ⟨Γ | λx:N .νyU (x)⟩
k!
⟨Γ | νyP ⟩ −→ ⟨Γ | λX:I .νyT (X)⟩
k?

⟨Γ | P ⟩ −→ ⟨Γ | T ⟩	⟨Γ | Q⟩ −→ ⟨Γ | U ⟩
τ
⟨Γ | P Q⟩ −→ ⟨Γ | T (U )⟩

(Tau)

⟨Γ | P ⟩ −→
τ

⟨Γ | P '⟩
'

( Tau)
⟨Γ,y:N | P ⟩ −→τ
τ

⟨Γ,y:N | P '⟩
'

(νTau)

⟨Γ | P Q⟩ −→ ⟨Γ | P  Q⟩	⟨Γ | νyP ⟩ −→ ⟨Γ | νyP ⟩
In the rules (  In) and (νIn), the variable x in the right hand side of the result is chosen fresh for U . Similarly, in (  Out) and (νOut) the variable X is chosen fresh for
T . The lts has a regular structure – there is one axiom for each kind of label - (In), (Out) and (Tau) for input, output and τ respectively. Further, there is precisely one rule for each syntactic constructor and each kind of label.
We give a brief example in order to demonstrate how scope-extrusion is handled by the above rules. First observe that we can derive the following transition:


⟨x:N | a!x.P ⟩ a!

⟨x:N | λX:I .P X(x)⟩
(Out)

(νOut)

⟨∅| νxa!x.P ⟩ a!
⟨∅| λX:I .νx(λX':I .P X'(x))X⟩

but λX : I .νx(λX' : I .P  X'(x))X ≡ λX : I .νx(P  X(x)), and so, using (Tau)
we obtain the correct extrusion of scope:


⟨∅| a?y.Q⟩ −a→?
(In)
⟨∅| λy.Q⟩	⟨∅| νxa!x.P ⟩ −a→!

⟨∅| λX:I .νx(P  X(x))⟩

⟨∅| a?y.Q νx.a!x.P ⟩ τ
⟨∅| νx.(P (λy.Q)(x))⟩
(Tau)

since νx.(P  (λy.Q)(x)) ≡ νx(P  Q[x/y]).
One can prove a type preservation result about the lts – in particular demon- strating that the result of applying the (Tau) rule is typeable. Indeed, suppose that Γ ▶ P : P. Then the following hold:

if ⟨Γ | P ⟩ −k→?
if ⟨Γ | P ⟩ k!
if ⟨Γ | P ⟩ τ
⟨Γ | U ⟩ then Γ ▶ U : N → P;
⟨Γ | T ⟩ then Γ ▶ T : I → P;
⟨Γ | P '⟩ then Γ ▶ P ' : P.

The lts presented above is only a fragment and bisimilarity does not give a satisfactory equivalence; it is presented here only to give a basic idea of the tech- niques involved. In particular, there is no observation of the identity of the name communicated (input, output, or fresh output). The full lts contains extra labels and derivation rules which take care of such observables by suitably evaluating λ- abstracted terms, yielding the standard early equivalence. The two functions (scope extrusion and fresh name generation) of the ν operator are thus dealt with sepa- rately. Intuitively, transitions which arise out of process terms, as presented here, represent the part of the interaction which is controlled by the process; transitions out of lambda-abstracted terms, omitted in this presentation, represent the part con- trolled by the context. The full lts does not require complicated side-conditions, variable conventions and the resulting equivalence is obtained using ordinary bisim- ulation indexed by type contexts.

The reader will notice that in fact the lts resembles closely that for ccs – in particular one could give a complete lts for that calculus in a similar style (without

passing the name to the context in the result of
(Out)
and without awaiting a

name in the result of (In)). This demonstrates one feature and a design principle
associated with the lts – modularity. The idea is that the semantics for different features of a calculus should be given by standard lts modules which fit together in a largely orthogonal way: the Pi-calculus extends ccs with extra features and thus it shouldn’t be surprising that the synchronous communication feature of Pi is handled with a ccs-like subsystem. The technique is also useful when considering asynchronous and higher-order variants of Pi. In each case, the proof of the fact that bisimilarity coincides with contextual equivalence is fairly straightforward – thus the overall theoretical setting is quite robust. It may prove that the technique advocated in this paper generalises well to other calculi – eg the ambient calculus. Contrast this situation with the standard lts in which communication is more complicated - there are two different kinds of output labels (free and bound) and two different axioms for generating τ -transitions. There, the fact that bisimilarity on this lts agrees with contextual equivalence also relies on the presence of equality
testing on names in the language.

References
G. L. Cattani and P. Sewell. Models for name-passing processes: interleaving and causal. Information and Computation, 190:136–178, 2004.
U. Engberg and M. Nielsen. A calculus of communicating systems with label passing. Technical Report DAIMI PB-208, University of Aarhus, May 1986.
U. Engberg and M. Nielsen. A calculus of communicating systems with label passing - ten years after. In Proof, Language, and Interaction; Essays in Honour of Robin Milner, pages 599–622. MIT Press, 2000.
G. U. Ferrari, U. Montanari, and M. Pistore. Minimising transition systems for name passing calculi: a co-algebraic formulation. In Proc. Foundations of Software Science and Computation Structures FoSSaCS, LNCS, pages 129–158. Springer, 2002.
M. P. Fiore and S. Staton. Comparing operational models of name-passing process calculi. Information and Computation, 204(4):524–560, 2006.
M. P. Fiore and D. Turi. Semantics of name and value passing. In Proc. 16th Annual IEEE Symposium on Logic in Computer Science LiCS, pages 93–104. IEEE Press, 2001.
B. Klin, V. Sassone, and P. Sobocin´ski. Labels from reductions: towards a general theory. In Algebra and Coalgebra in Computer Science, Calco ’05, volume 3629 of LNCS, pages 30–50. Springer, 2005.
J. Leifer and R. Milner. Deriving bisimulation congruences for reactive systems. In Proc. International Conference on Concurrency Theory Concur, volume 1877 of LNCS, pages 243–258. Springer, 2000.
R. Milner. Communicating and Mobile Systems: the Pi-calculus. Cambridge University Press, 1999.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, ii. Information and Computation, 100(1):41–77, 1992.
D. Sangiorgi and D. Walker. The π-calculus: a Theory of Mobile Processes. Cambridge University Press, 2001.
L. Wischik. Old names for Nu. In Dagstuhl Seminar 04241, 2004.
A. Ziegler, D. Miller, and C. Palamidessi. A congruence format for name-passing calculi. In Proc. Workshop on Structural Operational Semantics SOS ’05, volume 156 of ENTCS, pages 169–189, 2006.
