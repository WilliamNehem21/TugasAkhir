

Electronic Notes in Theoretical Computer Science 244 (2009) 109–123
www.elsevier.com/locate/entcs

Policy Evolution in Distributed Usage Control
A. Pretschner1, F. Schu¨tz2, C. Schaefer3, T. Walter3
1 Fraunhofer IESE and TU Kaiserslautern, Germany 2RUAG Electronics, Berne, Switzerland 3DOCOMO Euro-Labs, Munich, Germany

Abstract
Usage control is a generalization of access control that also addresses how data is handled after it is released. Controlling the future usage of data includes controlling the future distribution of data. The evolution of policies upon re-distribution must hence be defined. Intuitively, clients should only strengthen policies associated with a data item when they re-distribute it. We provide a role-based re-distribution model for usage control that encompasses strengthening both rights and duties. By introducing orderings for events and parameter values we show how both rights and duties can be strengthened with the traditional abstraction of trace inclusion.
Keywords: Usag control, access control

Introduction
The subject of usage control [13,14] is the handling of data after it has been given away. Our focus is on usage control in a distributed setting, where processes act in the roles of data providers and data consumers. Data providers can give sensitive data to data consumers based on conditions both on the past and the future. The latter requirements come as obligations such as “don’t re-distribute” and “delete af- ter thirty days.” Obviously, the roles of consumer and provider change dynamically: consumers become providers if they re-distribute previously received data. One fun- damental usage control requirement then relates to restricting the re-distribution of data. Without special technology in place, in principle, a subject could distribute the data to itself, thus deleting any usage control requirements. This is obviously not in the interest of the data provider who issued the policy. These originating data providers likely want to specify how their data may and may not be used af- ter re-distribution, and thus formulate distribution requirements. In other words, they are likely not only to specify a policy for the consumer, but also to specify policies for all potential future consumers of their data. One impractical solution is to specify one policy per potential consumer subject. A somewhat more practical

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.042

solution consists of role-based policies—one policy per role rather than one pol- icy per subject. However, this solution must not leave consumers total freedom in formulating their own policies when they become providers. Intuitively, given the policy from the originating data provider, they should only be allowed to restrict usage rights and increase duties for the next consumer. If rights could be extended or duties decreased, then a consumer would be able to re-distribute data to himself with obligations that are weaker than those he received together with the respective data item.
In this paper, we tackle the problem of policy evolution in usage control when data is re-distributed. In what precise sense can policies be altered? We provide a conceptual framework for re-distribution in usage control. Roughly, the originating data provider states obligations for specific roles in a system, together with a default policy for all other roles. Whenever data consumers re-distribute data, they may only strengthen the policy that they received from the originating data provider, and they may only do this for precisely specified roles. We provide a formalization of the notion of strengthening—which, as trace inclusion or logical implication, is straightforward for access control but becomes more complicated when not only rights can be restricted but duties may also be increased. Our solution relies on specifying rights and duties as intervals on events and parameters. To the best of our knowledge, we are the first to investigate the duality of rights and duties in usage control when it comes to policy refinement, and are the first to provide a respective formalized framework.

Background
Our system model for usage control [8] is based on classes of parameterized events. The event classes include usage and other, with the latter including notification events, for instance. Parameters represent attributes. For example, a usage event must indicate on which data item it is performed, and a signaling event—one that is sent from the consumer to the outside—must name the recipient of the message. An event therefore consists of the event name and parameters, represented as a partial function ( ')→from names to values. We will describe event parameters as
(name, value) pairs. An example is the event (play, {(object , o)}), where play is the
name of the event and the parameter object has the value o.
The definition of events in the Z language is shown below. EventName, Param- Name, and ParamValue define basic types for event names, parameter names, and parameter values, respectively. In Z, such definitions are made by listing the types in square brackets. All such basic types are disjoint. EBNF-style definitions are also possible.
[EventName, ParamName, ParamValue]
EventClass ::= usage | other ;	getclass : EventName → EventClass
Params : ParamName →' ParamValue;	Event == EventName × Params
Events are ordered with respect to a refinement relation reﬁnesEv. Event e2

refines event e1 iff e2 has the same event name as e1 and all parameters of e1 have the same value in e2. e2 can also have additional parameters specified and hence the ⊆ relation in the definition below. (In such axiomatic deﬁnitions, the defined mathematical object is named and typed above the line and its properties are given
below the line.)
refinesEv : Event ↔ Event
∀ e1, e2 : Event • e2 refinesEv e1 ⇔ e1.1= e2.1 ∧ e1.2 ⊆ e2.2

The rationale is that when specifying usage control requirements, we do not want to specify all parameters. For instance, if the event (play, {(object , o)}) is prohibited, then the event (play, {(object , o), (device, d )}) should also be prohibited. x .i identifies the i -th component of a tuple x . ↔ introduces a binary relation. The event name nil of type EventName is reserved and denotes no event.
To define usage control requirements, we need a language for usage control. Its semantics is defined over traces: mappings from abstract points in time— represented by the natural numbers—to possibly empty sets of events. We cater for usage events that execute over a time interval, e.g., watching a movie, by distin- guishing between starting and ongoing events. The data type IndEvent defines such indexed events. In Z, types can, among other things, be defined by enumeration or by Cartesian products (×).
Index ::= start | ongoing ;	IndEvent == Event × Index
The Obligation Speciﬁcation Language (OSL, formally captured by Φ+) is a temporal logic similar to LTL, with additional operators for cardinality (that, in turn, can be expressed in LTL [9, §3.4.3]). OSL has been defined as part of earlier work [8]. We will later extend OSL with ordered events and intervals which are
necessary to express distribution requirements. In Z, records can be defined by stating the name of a constructor and its arguments in angular brackets, and if there is more than one argument, this is expressed with the Cartesian product.
Φ+ ::= true | false | Efst ⟨⟨Event ⟩⟩ | Eall ⟨⟨Event ⟩⟩ | not ⟨⟨Φ+⟩⟩ | and ⟨⟨Φ+ × Φ+⟩⟩ | or ⟨⟨Φ+ × Φ+⟩⟩ | implies ⟨⟨Φ+ × Φ+⟩⟩ | until ⟨⟨Φ+ × Φ+⟩⟩ | always ⟨⟨Φ+⟩⟩ | after ⟨⟨N × Φ+⟩⟩ | within ⟨⟨N × Φ+⟩⟩ | during ⟨⟨N × Φ+⟩⟩ | repmax ⟨⟨N × Φ+⟩⟩ | replim ⟨⟨N × N × N × Φ+⟩⟩ | repuntil ⟨⟨N × Φ+ × Φ+⟩⟩ | permitonlyevname ⟨⟨P EventName × Params⟩⟩ |
permitonlyparam ⟨⟨P ParamValue × ParamName × EventName × Params⟩⟩

Fig. 1. Syntax of OSL [8]
The syntax of OSL is given in Fig. 1. We distinguish between the start of an action (syntactically: Efst; semantically: an indexed event with index start ) and any lasting action (syntactically: Eall ; semantically: indexed events with any index). When specifying events in obligations, by virtue of the refinement rela- tion, there is an implicit universal quantification over unmentioned parameters. not , and , or , implies have the usual semantics, and we will use the infix operators

¬, ∧, ∨, ⇒ as shorthand. until , after , during , and within are temporal operators with an intuitive meaning that is formalized in Fig. 2.
Cardinality operators restrict the number of occurrences or the duration of an

action. The replim operator specifies lower and upper bounds of time steps within a fixed time interval in which a given formula holds. The repuntil operator does the same, but independent of any time interval. Instead, it limits the maximal number of times a formula holds until another formula holds (e.g., the occurrence of some event). With the help of repuntil , we can also define repmax , which defines the maximal number of times a formula may hold in the indefinite future. These cardinality operators are also used to express limits on the accumulated usage time. We support both the “must” and the “may” modalities. The former is given by OSL’s LTL-like semantics, and the latter is supported by two designated operators. The operator permitonlyevname defines the names of the usage events that are exclusively allowed with a set of given parameters. Similarly, permitonlyparam only allows specific values for a given parameter of an event. It prohibits all other values for this parameter. The semantics of Φ+ is formally defined by the binary relation
|=f in Fig. 2. The definition makes use of a shorthand, |=e, to relate single indexed events (rather than traces) to formulae of the form Efst(·) or Eall (·). As we will see, to express the refinement of policies, |=e will be almost all we have to adjust.

Re-Distribution
To illustrate the problems related to policy distribution, we consider the example scenario of a movie provider. FairMovies produces all sorts of movies and dis- tributes them through licensed dealers. These dealers sell the movies to customers. FairMovies requires all dealers to provide movies to ﬁlm students and reporters at no cost. The distribution scheme is depicted in Fig. 3.
FairMovies wants to receive money for each copy of a movie that is transferred to a private customer. However, FairMovies limits the price range for movies because a bad price strategy could damage its reputation. FairMovies does not want movies to be sold before they are shown in theaters. Authorities may request FairMovies to take measures that ensure that movies are only sold to customers at a proper age. Thus, FairMovies wants to control distribution based on environmental and subject attributes (see below). Dealers want to receive payments from their customers for each copy sold and they want to be able to adjust prices according to their selling strategy. Film Academia wants its students to learn about camera techniques, special effects, cutting and the like. To this end, academics must be able to play and edit the full quality content. Reporters must be able to preview the full movie to write movie reviews. Customers want to play the movie in full length and quality. They want to share movies with others. And they want to lend movies to friends and sell old movies that they don’t watch anymore. Customers want to recover fast from data loss. Therefore they demand backup capabilities.
The customer requirement to share or trade movies is in conflict with FairMovies requirement to receive money. As a solution FairMovies allows customers to share movies for free under the condition that the new copy’s video quality is reduced by 50% upon each re-distribution. Giving away free copies to academia and media does not conflict with FairMovies requirements, since this improves publicity. Un-


|=e	: IndEvent ↔ Φ+
ie : IndEvent ; ϕ : Φ+ • ie |=e ϕ ⇔ ∃ e : Event •
.1 refinesEv e ∧ ((ϕ = Efst (e) ∧ ie.2= start ) ∨ ϕ = Eall (e))
|=f	: (Trace × N) ↔ Φ+
∀ s : Trace; t : N; ϕ : Φ+ • (s, t ) |=f ϕ ⇔
ϕ = true ∨ ϕ = Efst ((nil , ∅)) ∨ ϕ = Eall ((nil , ∅))
∨ ∃ e : Event \ {(nil , ∅)}; ie : IndEvent • (ϕ = Efst (e) ∨ ϕ = Eall (e)) ∧ ie ∈ s(t ) ∧ ie |=e ϕ
∨ ∃ ψ : Φ+ • ϕ = not (ψ) ∧ ¬ ((s, t ) |=f ψ)
∨ ∃ ψ, χ : Φ+ • ϕ = or (ψ, χ) ∧ ((s, t ) |=f ψ ∨ (s, t ) |=f χ)
∨ ∃ ψ, χ : Φ+ • ϕ = until (ψ, χ)
∧ (∃ u : N | t < u • “(s, u) |=f χ ∧ (∀ v : N | t < v < u • (s, v ) |=f ψ)” ∨ (∀ v : N | t < v •
(s, v ) |=f ψ))
∨ ∃ i : N; ψ : Φ+ • ϕ = after (i , ψ) ∧ (s, t + i ) |=f ψ
∨ ∃ i : N1; m, n : N; ψ : Φ+; e : Event •
ϕ = replim (i , m, n, ψ) ∧ (ψ = Efst (e) ∨ ψ = Eall (e)) ∧
m ≤ (X #{ie : IndEvent | ie ∈ s(t + j ) ∧ ie |=e ψ} ≤ n
j =1
∨ ∃ n : N; ψ, χ : Φ+; e : Event • ϕ = repuntil (n, ψ, χ) ∧ (ψ = Efst (e) ∨ ψ = Eall (e))
∧ “(∃ u : N1 • (s, t + u) |=f χ ∧ (∀ v : N1 | v < u • ¬((s, t + v ) |=f χ))
∧ (X #{ie : IndEvent | ie ∈ s(t + j ) ∧ ie |=e ψ}) ≤ n)
j =1
∨ (X #{ie : IndEvent | ie ∈ s(t + j ) ∧ ie |=e ψ}) ≤ n”
j =1
∨ ∃ ex : P EventName; ps : Params • ϕ = permitonlyevname (ex , ps)
∧ ∀ en : EventName | getclass(en)= usage ∧ en ∈/ ex •
(t , n) |=f always (not (Eall ((en, ps))))
∨ ∃ ex : P ParamValue; pn : ParamName; en : EventName; ps : Params •
ϕ = permitonlyparam (ex , pn, en, ps) ∧ pn ∈/ dom ps
∧ ∀ pv : ParamValue | pv ∈/ ex •
(t , n) |=f always (not (Eall ((en, ps ∪ {(pn, pv )}))))
∨ ϕ = false ∧ (s, t ) |= not (true)
∨ ∃ ψ, χ : Φ+ • ϕ = and (ψ, χ) ∧ (s, t ) |=f not (or (not (ψ), not (χ)))
∨ ∃ ψ, χ : Φ+ • ϕ = implies(ψ, χ) ∧ (s, t ) |=f or (not (ψ), χ)
∨ ∃ ψ : Φ+ • ϕ = always (ψ) ∧ (s, t ) |=f until (ψ, false)
∨ ∃ i : N; ψ : Φ+ • ϕ = within (i , ψ) ∧ (s, t ) |=f replim (i , 1, i , ψ)
∨ ∃ i : N; ψ : Φ+ • ϕ = during (i , ψ) ∧ (s, t ) |=f replim (i , i , i , ψ)
∨ ∃ n : N; ψ : Φ+ • ϕ = repmax (n, ψ) ∧ (s, t ) |=f repuntil (n, ψ, false)
Fig. 2. Semantics of OSL [8]
fortunately, pirated copies often originate from one of these parties. For this reason, FairMovies wants to apply conditions that restrict reporters and academics. Re- porters are allowed to watch a movie at most three times. Academics are allowed to re-distribute (modified) movies to fellow academics only. — Studying the example scenario, we identify four requirements a system must support.
Usage Conditions: The originating data provider wants to specify conditions for

FairMovies
πD
FilmAcademia ¸,		J	 Cu stomers
πS	Dealer	πP
πR
J 
Reporters
Fig. 3. Fair Movies distribution scheme
individual subjects and/or subject groups. E.g., only customers are allowed to make backups. Thus, restrictions can be seen as individual usage policies for subjects or groups of subjects.
Distribution Conditions: Data providers want to specify pre- and postconditions for distribution. An example postcondition is the requirement that dealers must pay royalties to FairMovies after selling a movie. An exemplary precondition is that FairMovies does not allow distribution before a movie has been shown in cinema.
Distribution Path: An originating data provider wants to control which subjects are allowed to get the data. Moreover, he might want to control who can distribute to whom, thus effectively describing “paths” between subjects along which data and policies can be sent.
Policy Modiﬁcations: There are two forms of policy modifications. The explicit form is what a data provider is allowed to negotiate. The originating data provider may allow any subsequent data provider to negotiate within certain boundaries. For example, FairMovies allows dealers to negotiate the price with the customer, but does not allow the movie to be sold too cheap or too expensive. The second form of policy modifications is automatic policy evolution: the originating data provider specifies functions that must be applied to the policy before it is propagated, thus evolving the policy. An example for this is the request for quality reduction when distributing movies to others.
Strengthening Policies
Our notion of strengthening policies assumes without loss of generality the per- spective of the data provider. A policy is strengthened by reducing the consumer’s rights (benefits) or by increasing the consumer’s duties.
Rights. We start by assuming that a subject can only strengthen policies upon re-distribution of a data item. For now, we will only consider rights, as done in access control. Duties are considered below. Intuitively, one would argue that upon re-distribution, rights can only be decreased. In formal terms, the set of traces that satisfy the original policy must become smaller, or, logically speaking, the formula that corresponds to the new policy must imply the old policy.
Consider an event name play with one parameter for video quality. Video quality, vq, ranges from 0 to 100. One example event is (play, {(obj , movA), (vq, 75 )}), indicating that movA is played with 75% video quality (throughout the pa- per, we assume that the maximum value is 100). A policy specifying that movA may only be played with this restricted quality is given by permitonlyparam ({75}, vq, play, {(obj , movA)}). Now, intuitively, the data provider is unlikely to object

to any consumer playing the movie at a quality below 75%. In other words, the intended policy is probably permitonlyparam ({0, ..., 75}, vq, play, {(obj , movA)}). Note that the second policy can intuitively be refined to a policy which allows less quality, while the first policy cannot.  Similarly, let us assume a policy
permitonlyevname ({edit }, {(obj , movA)}), specifying that movA may be edited both for sound and video content. It is likely that the data provider would not ob- ject to the movie also being played, or edited for video content only, or edited for sound only. The intended policy is hence likely to be permitonlyevname ({edit , sndedit , vdoedit, play }, {(obj , movA)}). One possible restriction of this policy would then allow to edit the movie’s sound track only (and, at the same time, also allow to play the movie).
Ordered Events and Parameters. In sum, policies tend to formulate per- missions not for single events or single parameters only. Instead, they assume an implicit ordering of events. In order to simplify policies, and in order to provide a formal framework for strengthening policies, we make these orderings explicit. Events and parameters will be partially ordered, that is, ordered w.r.t. a rela- tion that is reflexive, antisymmetric, and transitive. For brevity’s sake, we omit the straightforward formalization of these concepts. In the following, all orders ≤,
possibly indexed, are assumed to be partial orders.
As a first step, we define a partial order for event names, which is, in fact, a bounded lattice. In addition to the order provided by the system designer, we assume the existence of two special event names Te and ⊥e that are larger, respec- tively smaller than any other event name. We can then define lattices on event
names, ≤e, and event parameters, ≤p; the straightforward formalization is again omitted for brevity’s sake. Fig. 4 shows an example for a partial order of events (left) and one particular set of parameter values, e.g., video quality.


..¸Te,,,¸,¸¸¸¸¸¸¸¸¸,¸
T,p ,

.....
¸¸
,,, ¸¸¸¸¸¸¸¸¸¸¸¸

..	,,
¸¸¸¸¸¸¸¸ ¸¸¸¸¸

..¸edi,t ¸,¸¸¸
,,,
¸¸¸¸ ¸¸¸¸¸ ¸¸¸¸¸¸¸
10,0 ,

.....
¸¸¸¸¸
,,,
¸¸¸¸
¸¸¸¸¸¸
¸¸¸¸¸¸¸

...
vdoedi,t¸ ¸¸
¸¸
s.n¸de,dit
,
pa,y ,
¸
se nd,
¸¸
 s ell,
¸¸
b ack¸up
99,,

¸¸¸
¸¸¸
.....
....
sss
sss
cccc
ccc
.....
.....

pla,y ,
sss	ccc
.....
· ·,· ,

ss	cccc
   .....

sss	cc   ....

preview,¸¸¸¸
ss ccc  ....
s c  ..
0,,

¸¸¸¸¸
s cc ..
sc .
⊥e	⊥p

Fig. 4. Partially ordered event names (left) and parameter values (right)
In order to use ordered events and ordered parameter values in OSL policies, we first have to extend the syntax. We introduce ordered events that consist of a pair of event names and a pair of parameter values, captured by the following definitions.

OrdParams == ParamName →'  (ParamValue × ParamValue)
OrdEventName == EventName × EventName;  OrdEvent == OrdEventName × OrdParams
Intuitively, if an ordered event is allowed to happen, then all events in between the two event names with all parameter values in between the two boundary param- eter values are also allowed to happen. Postponing the motivation for the moment, we stipulate that for each ordered event,
one of the following is true: (1) the left boundary of the event name is ⊥e; or (2) the right boundary of the event name is Te; or (3) both boundaries are identical;
and that in addition one of the following also holds for each ordered parameter value: (1) the left boundary is ⊥p; or (2) the right boundary is Tp; or (3) the left and right boundaries are identical.
Without a respective formalization, we furthermore require the following “sanity” conditions to hold. Firstly, any ordered event must have valid lower and upper bounds for the event parameters. This means that the bounds must consist of values that are defined for the respective parameters. Secondly, every parameter name given in an ordered event must be declared for at least one event from the interval given by the ordered event name. Finally, the values used for the lower and upper bounds of parameter values must exist for this event parameter. We omit a concrete formalization of these constraints here. Instead, we adjust the definition of Φ+ to cater for ordered events and ordered parameter values as defined by Φ+ in
Fig. 5. Semantically, we only have to adjust |=e to check if an indexed event lies in the specified interval, and the permission operators. Since |=e is the anchor of every definition in |=f , with most operators it suffices to replace events by ordered events. Essentially, an event satisfies a formula with an ordered event as subformula if the event name and all parameters are within the given bounds. In addition to |=e, only permitonlyevname and permitonlyparam must be redefined in such a way that not only single events or parameters can be whitelisted, but also whole intervals. For permitonlyevname this is done by checking for each event whether it falls in one of the permitted intervals. If it does not, then this single event is forbidden. permitonlyparam is defined analogously. The formalization is provided in Fig. 5.
As  an  example,  we  can  specify  that  a  movie  movA  may be  previewed  or  played  with  a  quality  of  at  most  75%: always (not (Eall (((⊥e, play ), {(obj , (movA, movA)), (vq, (76, Tp ))})))). Note that we have to use a singleton interval for the obj parameter—of course, the implementation
of our language expands a single parameter to the singleton interval. Among other things, however, the above allows movA to be edited by anyone, and the intended policy likely was rather permitonlyevname ({(⊥e, play )}, {(obj , (movA, movA))}) ∧ permitonlyparam ({(⊥p, 75)}, vq, (⊥e , play ), {(obj , (movA, movA))}), which specifies that the exclusively allowed operations on movA are those in between ⊥e and play with, if applicable, values in between ⊥p and 75 for parameter name vq. A possible restriction of this policy would be to restrict the set of events that can be executed on object movA, or to reduce the interval for video quality.
Logical Characterization. Intuitively, a formula ϕ' is stronger than a formula

Φ+ ::=true | false | E
⟨⟨OrdEvent ⟩⟩ | E
⟨⟨OrdEvent ⟩⟩ | not ⟨⟨Φ+⟩⟩ | and ⟨⟨Φ+ × Φ+⟩⟩ | or ⟨⟨Φ+ × Φ+⟩⟩ |

o	fst
all
o	o	o	o	o

implies ⟨⟨Φ+ × Φ+⟩⟩ | until ⟨⟨Φ+ × Φ+⟩⟩ | always ⟨⟨Φ+⟩⟩ | after ⟨⟨N × Φ+⟩⟩ | within ⟨⟨N × Φ+⟩⟩ |
o	o	o	o	o	o	o
during ⟨⟨N × Φ+⟩⟩ | repmax ⟨⟨N × Φ+⟩⟩ | replim ⟨⟨N × N × N × Φ+⟩⟩ | repuntil ⟨⟨N × Φ+ × Φ+⟩⟩ |
o			o			o			o	o

permitonlyevname ⟨⟨P OrdEventName × OrdParams⟩⟩ |

permitonlyparam ⟨⟨P(ParamValue × ParamValue) × ParamName × OrdEventName × OrdParams⟩⟩

o : IndEvent ↔ Φ+
IndEvent ; ϕ : Φ+ • ie |=o ϕ ⇔ ∃ en, enl , enu : EventName; ps : Params; ops : OrdParams •
o	e





|=o
ie = (en, ps) ∧ ((ϕ = Efst (((enl , enu ), ops)) ∧ ie.2= start ) ∨ ϕ = Eall (((enl , enu ), ops)))
∧ enl ≤e en ∧ en ≤e enu ∧ ∀ pn : ParamName; pv , pvl , pvu : ParamValue | (pn, pv ) ∈ ps •
(pn, (pvl , pvu )) ∈ ops ⇒ pvl ≤p pv ∧ pv ≤p pvu
: (Trace × N) ↔ Φ+

∀ s : Trace; t : N; ϕ : Φ+ • (s, t ) |=o ϕ ⇔
o	f
ϕ = true ∨ ϕ = Efst ((nil , ∅)) ∨ ϕ = Eall ((nil , ∅))
∨ ∃ e : Event \ {(nil , ∅)}; ie : IndEvent • (ϕ = Efst (e) ∨ ϕ = Eall (e)) ∧ ie ∈ s(t ) ∧ ie |=o ϕ
.. .
∨ ∃ ex : P OrdEventName; ps : OrdParams •
ϕ =permitonlyevname (ex , ps) ∧
∀ en, enu , enl : EventName; pn : ParamName; pvl , pvu : ParamValue | getclass(en)= usage
∧ (enl , enu ) ∈ ex ∧ (enu <e en ∨ en <e enl • (s, t ) |=o always (not (Eall ((en, ps))))
∨ ∃ ex : P(ParamValue × ParamValue); oen : OrdEventName; ps : OrdParams; pn : ParamName •
ϕ =permitonlyparam (ex , pn, oen, ps) ∧ pn /∈ dom ps ∧
∀ pv , pvl , pvu : ParamValue | (pvl , pvu ) ∈ ex ∧ (pvu <p pv ∨ pv <p pvl ) •
(s, t ) |=o always (not (Eall ((oen, ps ∪ {(pn, (pv , pv ))}))))

... 


Fig. 5. Syntax (Φ+) and semantics (|=o ) of OSL with ordered events and parameters

o	f
ϕ if every trace satisfying ϕ' does not give more rights and imposes at least as many duties as every trace that satisfies ϕ (note that we have not discussed the issue of duties yet, but, as we will see, this will be easy to incorporate). In other words, if every trace that satisfies ϕ' also satisfies ϕ, ϕ' is as strong or stronger than ϕ. Semantically, our notion of stronger policies then naturally boils down to trace inclusion. Having introduced the semantics for formulas with ordered events, we
lift ≤e and ≤p, the partial orders for events and parameter values, to OSL formulas by the following definition.
≤f : Φ+ ↔ Φ+
o	o
'	+	'	o	'
∀ ϕ, ϕ : Φo • ϕ ≤f ϕ ⇔	∀ s : Trace; t : N • (s, t ) |=f implies(ϕ , ϕ)

For instance, the intuition that Eall (((play, play ), {(obj , (movA, movA)), (vq, (⊥p, 50))})) is stronger than Eall (((play, play ), {(obj , (movA, movA), (vq, (⊥p , 100))}))) is met by the formal definition.
Duties. We have seen that usage control policies do not only specify permissions but also duties. Strengthening policies relates to both aspects. We have seen that one possibility to strengthen policies is the reduction of rights. Another possibility is to impose further duties on the consumer. As we will see, this can be coped with

in exactly the same way as the restriction of rights.
Consider a policy that specifies that $1 has to be paid whenever movie movA is played, formally captured by always (Efst ((play, play ), {(obj , (movA, movA))}) ⇒ Efst((pay, pay ), {(amt , (1, 1))})). Upon re-distribution of the movie, the new provider may decide that the new consumer should pay $2 rather than
$1. If the initial policy was always (Efst ((play, play ), {(obj , (movA, movA))}) ⇒ Efst ((pay, pay ), {(amt , (1, Tp ))})), this could, again simply by restricting inter- vals, be strengthened into always (Efst ((play, play ), {(obj , (movA, movA))}) ⇒ Efst ((pay, pay ), {(amt , (2, Tp ))})). This is not possible with the original policy that specified precisely $1 to be paid.
Interval Boundaries. One way to strengthen policies is hence to shorten intervals. The reason for requiring either boundaries to be identical or left or right boundaries to be bottom or top elements of the respective lattices is the following. If a provider required payments to be in between $1 and $500, then one possibility to strengthen the policy would be to require a payment in between $1 and $250. While this clearly reduces the consumer’s number of possibilities to fulfill his duties, it is not an intuitive strengthening of the duties. Increasing the lower bound, however, intuitively strengthens the duty. Conversely, it does not seem reasonable for a provider to grant the right of watching a movie at a quality that is lower than 75% but above 25%.
As it turns out, rights usually have ⊥e or ⊥p as left boundary, and duties have Te or Tp as right boundary. In other words, requiring lower bounds to be ⊥e, ⊥p or upper bounds to be Te, Tp amounts to specifying maximum rights and mininum duties. Assuming that there are no composite events that combine both rights and duties, any event can hence be classified as right or duty by simply regarding the interval boundaries. This obviously also gives rise to a slightly different syntax: upon policy specification, we could classify events into rights and duties and omit either left or right boundaries for both names and parameter values. These missing boundaries could then automatically be filled in.
One might argue that it is not always clear if an event denotes a permission or a duty. For instance, a play event may relate to both playing a movie (right) and playing a commercial (duty). However, it seems that events can be assigned a clear status of being either a right (playMovie) or a duty (playCommercial ). Furthermore, one might be concerned that negating a duty leads to a right and that negating a right leads to a duty. This can indeed be the case but need not necessarily: the negation of “pay $5 or more” would be “do not pay $5 or more”, and this is not a right in the intuitive sense (“you may pay less than $4”). Either way, not labeling events as rights or duties but rather classifying them implicitly on the grounds of interval boundaries avoids any confusion. For this reason, we stick to explicit boundaries in this paper.
Note that there is a noteworthy asymmetry. Restricting rights can, in principle, also mean to increase the lower bound. The interpretation is then that consumers are restricted in their freedom to choose, even though in the example of increasing the minimum quality, this may appear odd. In other words, one can argue that

reducing rights can happen at both sides of the spectrum. On the other hands, this does not seem too reasonable for duties, as explained above. In fact, we decided to fix lower boundaries for rights to be ⊥p or ⊥e only on the grounds of symmetry considerations.
Finally, note that our notion of strengthening policies defined by logical implica- tion “automatically” caters for strengthening along the temporal dimension: having to do something within 5 time steps can be strengthened to doing it within 3 steps.
Variables
Our policy language for distribution also includes a few variables, the most impor- tant ones being %SENDER and %RECEIVER. At runtime, these are bound to the provider and the consumer of the last distribution step. With these variables it is, for instance, possible to state that money must be paid to the last provider but not necessarily the originating data provider. Similarly, variables can relate to the current state of a system—which assumes that this local or global state can be accessed. A possible extension is the introduction of variables that allows to express requirements such as “quality to be halved upon every distribution step”, which we illustrate below.
Role-Based Distribution
We are now ready to define a role-based distribution schema. We assume that the initial policy is defined by the originating data provider. The originating data provider defines one policy per role and possibly per subject. We will assume that a subject’s policy has priority over a role’s policy. A subject can be in multiple roles, and in case of conflict, we assume some further conflict resolution mechanism to exist. In case a data item is sent to a subject for which neither a dedicated (subject) policy nor a policy for the subject’s role is defined, a default rule applies. This default rule must be provided by the original data provider.
Whenever data items are re-distributed, the provider can at most strengthen the (originating policy provider’s) policy. Any distribution component must hence be able to decide if p1 ≤f p2 holds for policies p1 and p2.
However, it may be that the originating data provider does not want future
providers to be able to strengthen the policies of all roles. To this end, we introduce a partial order on roles, ≤r . A potential data provider in role r1 may only strengthen the originating data provider’s policies for all those roles r where r ≤r r1 (that is, a “larger” role may only change the policies of ”lower” roles). Note that this is a distribution hierarchy only; we do not require that if (sub-)policies p1 and p2 are associated with roles r1 and r2 with r1 ≤r r2, then also p1 ≤f p2.
Example: FairMovies
We now present the formal policy for our running example. For brevity’s sake, we will only discuss the most interesting requirements.
Usage Conditions: First, FairMovies must come up with usage conditions for each party. A dealer can sell a movie to customers or send it for free to reporters

and academics (these potential receivers are specified below). Customers can play a movie, back it up for fast recovery, and re-distribute it under specific conditions. Reporters may play a movie up to three times. Academics can play and edit a movie. Furthermore they can send it to other academics.
{(dealer , permitonlyevname ({(⊥e , sell ), (⊥e , send )}, (obj , (movA, movA))})),

(customer , permitonlyevname ({(⊥e , play ), (⊥e , backup), (⊥e , send )}, {(obj , (movA, movA))})),

(reporter , and (permitonlyevname ({(⊥e , play )}, {(obj , (movA, movA))}),

repmax (3, Efst ((play , play ), {(obj , (movA, movA))})))),

(academia, permitonlyevname ({(⊥e , edit ), (⊥e , send )}, {(obj , (movA, movA))})),

(default , permitonlyevname ({(⊥e , preview )}, {(obj , (movA, movA))}))}.

Distribution Path: FairMovies must control distribution paths. In that way, dealers are allowed to distribute to customers, reporters and film students. Aca- demics may only distribute to other academics. Customers may distribute to their peers. Reporters are not allowed to distribute at all. In the following, we assume that the send event has a parameter recv that designates the receiver’s role.
{(dealer , permitonlyparam ({(academia, academia), (reporter , reporter ), (customer , customer )},
recv , (send , send ), {(obj , (movA, movA))})),
(academia, permitonlyparam ({(academia, academia)}, recv , (send , send ), {(obj , (movA, movA))})), (customer , permitonlyparam ({(customer , customer )}, recv , (send , send ), {(obj , (movA, movA))}))}.
Distribution conditions: Dealers are allowed to sell copies to customers at an
increased price. Whenever doing so, the dealer must pay royalties to FairMovies.
{(dealer , always (Efst ((sell , sell ), {(obj , (movA, movA))}) ⇒ Efst ((pay , pay ), {(amt , (10, Tp )), (rcv , (FairMovies, FairMovies))})))}.
Policy Modiﬁcation: Customers may distribute to others, but then the qual-
ity of the content must automatically be reduced by 50%. Therefore we in- troduce a local variable %QUALITY as proposed in §3.2. The resulting policy is then {(default , permitonlyparam ({(⊥p , %QUALITY /2), vq , (play , play ), {(obj , (movA, movA))})))}, where we omit a formal definition of the syntax for halving the quality.
Strengthening: We have seen several examples for strengthening by decreasing intervals. Assume now that a film student gets a movie from a dealer. The applicable subpolicy is that for Academia that results from combining the above aspects.
and (permitonlyevname ({(⊥e , edit ), (send , send )}, {(obj , (movA, movA))}),

permitonlyparam ({(academia, academia)}, recv , (send , send ), {(obj , (movA, movA))})).
The student edits the movie and introduces some special effects. He then sends the modified content to his supervisor.  However, he does not want his supervisor to alter anything and also wants him to not send it to anyone else. To prevent his supervisor from showing it to too many people, he also limits the number of times the movie can be played to once. Therefore he strengthens the Academic’s sub-policy as follows (which he can do because he has the same role as his supervisor), and leaves the other policies as they are:
and (permitonlyevname ({(⊥e , play )}, {(obj , (movA, movA))}), repmax (1, Efst ((play , play ), {(obj , (movA, movA))}))). It is easy to see that this new policy is stronger in the above sense, since every event that satisfies the new policy also satisfies the original one.

Checking Policy Entailment
Policy entailment can be checked automatically with a model checker. To this end, policies are simply translated into a dialect of LTL. This is, however, not the subject of this paper [16].

Related Work
Usage control has been discussed by several authors [13,3,2,7,14]. The issue of re- distribution, the subject of this paper, is not discussed in these approaches, in some cases because of the centralized perspective on usage control. Related to our work are approaches to policy and rights delegation or propagation for access control. These approaches enable a user to delegate certain access rights to other users (see, among others, [6] for references). In discretionary access control, for instance, a subject may override the system’s policy under specific circumstances (e.g., [4]). Our work differs in that we also take into account duties, and that we impose precise constraints on the discretionary modification of policies (strengthening).
The audit logic of Cederquist et al. [6] includes a notion of refinement of ad- ministrative policies that is also based on logical implication. It does not take into account intervals though, which means that it is difficult to express that “pay $6” is stronger than “pay $5.” Furthermore, this framework does not include obligations, even though the authors state that they would be straightforward to implement.
SecPAL [1] is a powerful formal authorization language that includes constructs for stating facts about delegation. Usage control is not considered, however. Sec- PAL policies are static, that is, there is no way to modify (strengthen) policies at runtime, and as a consequence, there is no support for expressing that policies may be strengthened. Given the formal semantics, however, it seems possible to include this into SecPAL.
Park et al. [12] present policies that require recipients to gain an originator’s approval for the distribution of data. The distribution process itself only concerns access control requirements. This means that the policies only specify whether the objects can be accessed by others. Park et al. present several approaches how these policies can be integrated in different usage control settings.
Other work on delegation policies and models [15,2] was published. This is similar to the work discussed above. Several authors [5,11,10] discuss the problem of delegation in distributed system. However, they sketch problems rather than solutions. If solutions are discussed, these are very application specific.

Conclusions
In this paper, we have introduced a framework for re-distribution of data objects in distributed usage control. Essentially, given a data object that is to be distributed, the originating data provider specifies a policy for each role in a system. Upon re-distribution, these sub-policies can only be strengthened by roles that have the

right to do so; this is regulated by a partial ordering of roles. These roles reflect a re-distribution hierarchy and not necessarily a hierarchy of rights and duties.
We have introduced intervals for events and parameters. For rights, the left boundary usually is the minimum value (⊥); for duties, the right boundary usually is the maximum value (T). This means that we specify maximum rights and minimum duties; upon re-distribution, rights can be decreased and duties can be increased. Formally, we have shown that this notion of strengthening policies amounts to logical implication. For rights, such a formal notion is intuitive; for duties, it is less so, and the main contribution of this paper is a common formal framework that
encompasses both rights and duties in a uniform manner.
Whether or not sub-policies are indeed strengthened must be checked upon re-distribution. Our approach allows for syntactic checking in many cases (add conjuncts, move interval boundaries in the appropriate direction). In other cases, this can be performed automatically, for instance on the grounds of model checkers, which has been done but is not described in this paper [16]. This requires of course the existence of a respective infrastructure: any distribution request must be intercepted at the potential provider’s device and routed through a policy checking mechanism. This device must also take care of policy transformation of the kind of halving the quality (§3.4).
Policy transformations w.r.t. the current consumer’s state deserve more atten-
tion. For instance, if an originating data provider wants the policy to be distributed only three times and the first consumer has distributed it already once, then the next consumer should be allowed to only distribute it once more. This also points at another problem: does “distribute no more than n times” mean that the overall number of copies in the system should be n or that every consumer can distribute it n times? Similarly, if a resource usage is allowed for two hours, and the first con- sumer has already spent one hour using it, then every subsequent policy may have to restrict the usage to only one more hour. Essentially, we may need to distinguish between this kind of “global” policies and the “local” policies we used in this paper. We have deliberately not discussed the consumer-side enforcement of policies.
We are, however, of course aware that this is a crucial ingredient of any implemen- tation of distributed usage control concepts. Moreover, the management of policies obviously is a particularly challenging task in distributed settings.
We have assumed that objects do not change when distributed. Consequently, future work is bound to the problem of rights delegation in those cases where a data item is modified (e.g., a color image is transformed into black and white), or where different objects are merged (e.g., by aggregating data in the form of statistics). Furthermore, the decision that the lattice of roles is a re-distribution rather than a rights hierarchy deserves some further considerations. In this vein, we will also have to find out if the default rule should be required to be stronger than all other sub-policies.

References
M. Becker, C. Fournet, and A. Gordon. Design and semantics of a decentralized authorization language. pages 3–15, 2007.
E. Bertino, C. Bettini, and P. Samarati. A temporal authorization model. In Proc. CCS, pages 126–135, 1994.
C. Bettini, S. Jajodia, X. S. Wang, and D. Wijesekera. Provisions and obligations in policy rule management. J. Network and System Mgmt., 11(3):351–372, 2003.
M. Bishop. Introduction to Computer Security. Addison Wesley, 2005.
O. Canovas and A. F. Gomez. Delegation in distributed systems: Challenges and open issues. In Proc. 14th Intl. Workshop on Database and Expert Systems Applications, page 499, 2003.
J. Cederquist, R. Corin, M. Dekker, S. Etalle, J. den Hartog, and G. Lenzini. Audit-based compliance control. Int. J. Inf. Secur., 6:133–151, 2007.
M. Hilty, D. Basin, and A. Pretschner. On obligations. In Proc. ESORICS, Springer LNCS 3679, pages 98–117, 2005.
M. Hilty, A. Pretschner, D. Basin, C. Schaefer, and T. Walter. A Policy Language for Distributed Usage Control. In Proc. ESORICS, pages 531–546, 2007.
M. Hilty, A. Pretschner, C. Schaefer, and T. Walter. Enforcement for Usage Control: A System Model and a Policy Language for Distributed Usage Control. Technical Report I-ST-20, DoCoMo EuroLabs, December 2006.
L. Kagal, T. Finin, and A. Joshi. Trust-based security in pervasive computing environments. IEEE Computer, 34(12):154–157, 2001.
L. Kagal, T. Finin, and A. Joshi. A policy language for a pervasive computing environment. In Proc. POLICY, pages 63–74, 2003.
J. Park and R. Sandhu. Originator control in usage control. In POLICY ’02: Proceedings of the 3rd International Workshop on Policies for Distributed Systems and Networks (POLICY’02), page 60, Washington, DC, USA, 2002. IEEE Computer Society.
J. Park and R. Sandhu. The UCON ABC Usage Control Model. ACM Transactions on Information and Systems Security, 7:128–174, 2004.
A. Pretschner, M. Hilty, and D. Basin. Distributed Usage Control. CACM, 49(9):39–44, September 2006.
C. Ruan, V. Varadharajan, and Y. Zhang. Logic-based reasoning on delegatable authorizations. In
Proc. 13th Intl. Symp. on Foundations of Intelligent Systems, pages 185–193, 2002.
J. Ru¨esch. Model Checking Usage Control Policies, 2008. Master’s Thesis, Department of Computer Science, ETH Zu¨rich.
