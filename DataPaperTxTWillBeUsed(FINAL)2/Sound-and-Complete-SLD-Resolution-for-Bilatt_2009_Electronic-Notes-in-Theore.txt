

Electronic Notes in Theoretical Computer Science 225 (2009) 141–159
www.elsevier.com/locate/entcs

Sound and Complete SLD-Resolution for Bilattice-Based Annotated Logic Programs
Ekaterina Komendantskaya 1,2
Department of Mathematics University College Cork Cork, Ireland
Anthony Karel Seda1,3
Department of Mathematics University College Cork Cork, Ireland

Abstract
We introduce the class of normal bilattice-based annotated first-order logic programs (BAPs) and develop declarative and operational semantics for them. In particular, SLD-resolution for these programs is defined and its soundness and completeness established.
Keywords: Annotated logic programming, bilattices, declarative and operational semantics, SLD-resolution.


Introduction
Since their introduction by Ginsberg [9], bilattices have become a well-known al- gebraic structure for reasoning about the sort of inconsistencies which arise when one formalises the process of accumulating information from different sources. In particular, Fitting [6,7,8] introduced quite general consequence operators for logic programs whose semantics are based on four-valued bilattices, and derived their basic properties.
Annotated (sometimes called signed) languages are an alternative formal tool for handling, for example, the semantics of logic programs over many-valued logics

1 The authors thank the Boole Centre for Research in Informatics at University College Cork for substantial support during the preparation of this paper.
2 Email: komendantskaya@gmail.com
3 Email: a.seda@ucc.ie

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.071

and probabilistic programs, see [4,11,15,23,26,31]. Their use, however, gives rise to the obvious question of how annotated logic programming compares with logic pro- gramming based on (bi)lattices, see [14,15,21,24,25,28]. In this paper, we contribute to this discussion by combining the two approaches in that we make use of bilattice structures within the framework of annotated logic programs. Specifically, we in- troduce bilattice-based annotated logic programs (BAPs) and establish declarative and operational semantics for them. BAPs, being many-valued and quantitative in nature, enable us to work with statistical knowledge, and with databases which can be incomplete or inconsistent, and thereby introduce monotonic extensions of two-valued negation. But what is particularly important is that they possess all the desirable properties of classical logic programming. Thus, we define monotonic and continuous semantic operators for BAPs and develop sound and complete proof procedures for them based on classical binary resolution.
The results which we obtain here can be seen as a further development of lattice- based logic programming for handling inconsistencies, see [4,8,14,15,26,28], for ex- ample. However, there are several original results obtained in the paper, as follows. First of all, we show that logic programs based on bilattices (and on lattices whose elements are not linearly ordered) may have logical consequences which can- not be computed by the semantic operators defined in the papers just cited. In fact, most authors who have considered lattice- and bilattice-based logic programs follow the tradition of classical logic programming and require their semantic operators to work by propagating interpretation from the body of each clause to its head. How- ever, the authors of [14] extended and enriched resolution for lattice-based logics by adding new rules reflecting the non-linear ordering of their lattices. This work distinguished proof procedures for lattice-based logics from those for many-valued logics interpreted by linearly-ordered structures, for example, fuzzy logics. The work of [14] inspired us to extend these ideas to logic programs and their semantic operators, and to SLD-resolution. As a result, we define a new semantic operator which guarantees computation of all the logical consequences of a bilattice-based annotated logic program. Unlike the case of [14], we allow infinite (but countable)
interpretations for logic programs.
Throughout, we work with first-order bilattice-based logic programs inter- preted by arbitrary (possibly infinite) distributive bilattices with finite joins, and this framework considerably enriches that of propositional-based logic programs [4,21,26,28] based on finite sets or finite lattices [2,10,14,23,24,25,31]. Moreover, we allow annotations to be variables or to contain function symbols unlike, for example, the case of [2,10,14,23,24,25,31].
We use the fact proven in [20] that the semantic operator we introduce is con- tinuous. As usual, continuity of the semantic operator ensures that it reaches its least fixed point in at most ω iterations. This property is crucial for the whole theory. It makes possible computer implementations of the operator and it also makes it possible to introduce sound and complete proof procedure for BAPs. Note that the semantic operators introduced earlier for annotated logic programs of this generality do not possess this important property, see [4,15].

Finally, we establish sound and complete SLD-resolution for BAPs. As far as we know, this is the first sound and complete proof procedure for first-order in- finitely interpreted (bi)lattice-based annotated logic programs. Compare, for exam- ple, our results with those obtained for constrained resolution for GAPs, which was shown to be incomplete, see [15], or with sound and complete (SLD)- resolutions for finitely-interpreted annotated logic programs (these logic programs do not contain annotation variables and annotation functions) [2,10,14,23,24,25,31]. 4
Thus, in summary, we fully describe a broad class of first-order, infinitely-valued, bilattice-based annotated logic programs and propose suitable proof procedures and implementations for them.
The structure of the paper is as follows. In §2, we describe bilattices, closely following Ginsberg [9] in our presentation. In §3, we give full details of the syntax and semantics of bilattice-based languages, and of BAPs in particular. We also develop a declarative semantics for BAPs in §3. In §4, we define SLD-resolution for BAPs and prove its soundness and completeness. Finally, in §5, we summarise our results and discuss further work yet to be done.

Bilattices
In this section, we briefly describe bilattices, following closely Ginsberg [9] and Fitting [6,7,8].
Definition 2.1 A bilattice B is a sextuple (B, ∨, ∧, ⊕, ⊗, ¬) such that (B, ∨, ∧) and (B, ⊕, ⊗) are both complete lattices, and ¬ : B → B is a mapping satisfying the following three properties:
¬2 = IdB,
¬ is a dual lattice homomorphism from (B, ∨, ∧) to (B, ∧, ∨), and
¬ is a lattice homomorphism from (B, ⊕, ⊗) to itself.
Certain kinds of bilattices can be obtained by taking a product of two lattices, and this property makes it easy to describe and investigate these structures.
Let L1 = (L1, ≤1) and L2 = (L2, ≤2) be two lattices, let x1, x2 denote arbitrary elements of the lattice L1, and let y1, y2 denote arbitrary elements of the lattice L2. Let ∩1, ∪1 denote the meet respectively join defined in the lattice L1, and let ∩2, ∪2 denote the meet respectively join defined in the lattice L2.
Two familiar bilattice orderings can be defined on L1 × L2. We define the truth
ordering ≤t and the knowledge ordering ≤k as follows.
⟨x1, y1⟩ ≤t ⟨x2, y2⟩ if and only if x1 ≤1 x2 and y2 ≤2 y1.
⟨x1, y1⟩ ≤k ⟨x2, y2⟩ if and only if x1 ≤1 x2 and y1 ≤2 y2.

4 Note also that [28] introduced computer programs which compute consequence operators for (proposi- tional) bilattice-based logic programs. However, this work cannot be seen as a proof procedure for the simple reason that the semantic operator of [28] is capable only of producing sets of logical consequences of a program. But we look for a proof procedure that can respond to certain goals and give correct answers together with proper substitutions for individual and/or annotation variables.

We denote the resulting structure by L1 ⊙ L2 = (L1 × L2, ≤t, ≤k) = (B, ≤t, ≤k), where B denotes L1 × L2.
Having defined L1 ⊙ L2, we define bilattice operations on it as follows. The four bilattice operations associated with ≤t and ≤k are:
⟨x1, y1⟩∧ ⟨x2, y2⟩ = ⟨x1 ∩1 x2, y1 ∪2 y2⟩,
⟨x1, y1⟩∨ ⟨x2, y2⟩ = ⟨x1 ∪1 x2, y1 ∩2 y2⟩
⟨x1, y1⟩⊗ ⟨x2, y2⟩ = ⟨x1 ∩1 x2, y1 ∩2 y2⟩
⟨x1, y1⟩⊕ ⟨x2, y2⟩ = ⟨x1 ∪1 x2, y1 ∪2 y2⟩.

Negation is defined as follows: ¬⟨x1, y1⟩ = ⟨y1, x1⟩; this latter definition assumes that L1 = L2.
Similarly, we can define infinite meet and join with respect to the t- and k- orderings, and we denote them respectively by  ,  ,  , and Σ.
Proposition 2.2 [6,9] Suppose B is a distributive bilattice. Then there are dis- tributive lattices L1 and L2 such that B is isomorphic to L1 ⊙ L2.
Thus, every distributive bilattice can be represented as a product of two lattices. In the present article, we consider only logic programs over distributive bilattices and therefore the underlying bilattice of any program we consider will always be formed as a product of two lattices.
Example 2.3 Consider the bilattice B25 =  L1 ⊙ L2, where L1 =  L2 =
({0, 1 , 1 , 3 , 1}, ≤), with 0 ≤ 1 ≤ 1 ≤ 3 ≤ 1.  The set B25 = L1 × L2 contains
4 2 4	4	2	4
the following elements: ⟨0, 0⟩, ⟨0, 1 ⟩, ⟨0, 1 ⟩, ⟨0, 3 ⟩, ⟨0, 1⟩, ⟨ 1 , 0⟩, ⟨ 1 , 1 ⟩, ⟨ 1 , 1 ⟩, ⟨ 1 , 3 ⟩,

4	2	4
4	4 4
4 2	4 4

⟨ 1 , 1⟩, ⟨ 1 , 0⟩, ⟨ 1 , 1 ⟩, ⟨ 1 , 1 ⟩, ⟨ 1 , 3 ⟩, ⟨ 1 , 1⟩, ⟨ 3 , 0⟩, ⟨ 3 , 1 ⟩, ⟨ 3 , 1 ⟩, ⟨ 3 , 3 ⟩, ⟨ 3 , 1⟩, ⟨1, 0⟩, ⟨1, 1 ⟩,

4	2	2 4	2 2	2 4	2	4
4 4	4 2
4 4	4	4

⟨1, 1 ⟩, ⟨1, 3 ⟩, ⟨1, 1⟩. The two orderings ≤k and ≤t are determined according to the
2	4
definition of L1 ⊙ L2, see Figure 1.
Informally speaking, these pairs of numbers will allow us to formalise, in the next section, the degrees of belief and doubt we assign to statements. The first element of a pair will reflect the degree of belief, and the second element will reflect the degree of doubt.

Annotated Logic Programs Based on Bilattice Struc- tures
In this section, we define annotated bilattice-based logic programs. Our definition extends previous definitions on this topic in various ways and, in particular, it ex- tends annotated (or signed) languages (see [2,4,15,23,24,25,31] and others) to the case of distributive bilattices. The languages we introduce allow variables and func- tions in annotations, unlike [14,23,24,25] and others, for example; they generalize some of the propositional lattice-based languages [4,28] to the first-order case, and allow negations unlike, for example, [4,23] and others.



k

  
t


Fig. 1. Bilattice B25
Let B = L1 ⊙L2 denote a bilattice given as the product of two complete lattices L1, L2 each of which is a sublattice of the lattice ([0, 1], ≤), where [0, 1] is the unit interval of real numbers and ≤ is the usual linear ordering on it. For the rest of the paper, we restrict our attention to bilattices with finite joins.
We define an annotated bilattice-based language L over B to consist of indi- vidual variables denoted x1, x2,.. ., constants a1, a2,.. ., functions f1, f2,... and predicate symbols R1, R2,... together with annotation terms which can consist of variables (μ1, ν1), (μ2, ν2),.. ., constants (α1, β1), (α2, β2),.. ., and functions over an- notation variables and constants. We allow six connectives and four quantifiers, as follows: ⊕, ⊗, ∨, ∧, ¬, ∼, Σ, Π, ∃, ∀. The full fragment of bilattice-based annotated logic (BAL) is considered in [18]. Here, we restrict our attention only to Horn-clause fragments of it.
An annotated formula is defined inductively as follows: if R is an n-ary predicate symbol, t1,..., tn are terms, and (τ ) is an annotation term, then R(t1,..., tn) : (τ ) is an annotated formula (called an annotated atom). Annotated atoms can be combined to form complex formulae using the connectives and quantifiers.
Example 3.1 Consider a binary predicate connected, which describes the fact of existence of an edge in a probabilistic graph. These graphs can be used to describe the behaviour of Internet connections, for example. Then connected(a, b) : ( 1 , 2 )
3 3
will describe the fact that the probability of establishing a connection between nodes

a and b is equal to 1 , while the probability of losing this connection is 2 .
3	3
A bilattice-based annotated logic program (BAP) P consists of a finite set of (annotated) program clauses of the form
A : (τ ) ← L1 : (τ1),..., Ln : (τn),
where A : (τ ) denotes an annotated atom called the head of the clause, and L1 : (τ1),..., Ln : (τn) denotes L1 : (τ1) ⊗ ... ⊗ Ln : (τn) and is called the body of the clause; each Li : (τi) is an annotated literal called an annotated body literal of the clause.
By allowing each Li : (τi) to be a literal, we assume that the connective ¬ can be applied to the atoms appearing in the bodies. However, due to the definition of ¬, each negated atom ¬F : (α, β) transforms easily into the positive atom F : (β, α). This is why, for the rest of the paper, we develop BAPs assuming that all the literals in the clauses are brought into positive form. A detailed analysis of properties of negation in BAPs can be found in [17,18].
Note that we use ⊗ to connect literals in the bodies of annotated clauses, and thus give priority to the lattice based on ≤k. This permits us to use monotonicity of this lattice relative to the negation of the language. Individual and annotation variables in the body are thought of as being existentially quantified using Σ. We showed in [20] how the remaining bilattice connectives can be introduced into an- notated clauses, but we will not address this issue in this paper.
We mention here that any logic program contains only a finite set of annotation constants. This is why there are classes of programs which can be interpreted by finite bilattices, for example, logic programs which do not contain annotation variables and/or annotation functions, and logic programs containing only functions which do not generate new annotation constants through the process of computing.
Example 3.2 Consider the following infinitely-interpreted logic program:
R1(a1) : (1, 0.5) ←
μ ν
R2(f (x)) : ( 2 , 3 ) ← R1(x) : (μ, ν)

μ ν
3 , 3
) ← R2(x) : (μ, ν)

This program receives its interpretations from the countable bilattice whose under- lying set of elements contains 0, 1, 0.5 and all the numbers which can be generated
from 0, 1, 0.5 by iterating the functions μ , μ , ν .
2  3  3
Example 3.3 Suppose we want to implement a program P which is able to make decisions about delaying and cancelling airport flights without human supervision. Let this program work with databases which are obtained through accumulating information from weather forecasts taken from different sources. These sources may give inconsistent or incomplete information which is collected in the database of P . The first and the second elements of each annotation denote evidence for, respectively against, a given fact. Let B25 from Example 2.3 be the chosen bi- lattice.  Let individual variables x, y receive, respectively, values from the set

{Monday, Tuesday} and the set with the numbers of flights {1, 2}. A suitable pro- gram for processing the database may contain the following fragment:
Storm(Monday) : ( 3 , 1 ) ←
 
4 2

Storm(x
1 3
,  ) ←

) : ( 
2 4

Delay(y, x) : (( 3 , 1 ) ∨ ( 1 , 1 )) ← Storm(x
3 3	1 1
,  ), Storm(Tuesday) : ( ,  )


 	 
4 2	2 2
) : ( 
4 4	2 2

Cancel(y, x) : (1, 0) ← Delay(y, x	3 , 1 )
) : ( 
4 2
Note that this program is able to make quantitative (fuzzy) conclusions, as in the third clause, as well as qualitative (two-valued) conclusions, as in the last clause. It can work with conflicting sources of information, see, for example, the two unit clauses.
In this section, we have defined Bilattice-Based Annotated Logic Programs (BAPs), and considered some examples. We proceed by giving a semantic char- acterization of BAPs.

Declarative Semantics and the TP -Operator
In this section, we define interpretations and Herbrand interpretations for BAPs, and investigate their properties. We define the semantic operator TP and show that it is continuous. We establish that TP computes the minimal Herbrand models for BAPs.
Let D and v denote respectively a domain of interpretation and a variable as- signment for a given language L, see [22]. An interpretation I for L consists of the following mappings. The first mapping I assigns |R|v : Dn −→ B to each n-ary predicate symbol R in L. Further, for each element ⟨α, β⟩ of B, we define a mapping χ⟨α,β⟩ : B −→ B, where χ⟨α,β⟩(⟨α', β'⟩) = ⟨1, 0⟩ if ⟨α, β⟩ ≤k ⟨α', β'⟩ and χ⟨α,β⟩(⟨α', β'⟩) = ⟨0, 1⟩ otherwise. The mapping χ is used to evaluate annotated formulae.
We will use the two functions I and χ to define interpretation I for annotated atoms. If F is an annotated atom R(t1,..., tn) : (τ ), then the value of F is given by I(F ) = χ⟨τ⟩(|R|v(|t1|v,..., |tn|v)), as follows. Given an annotated atom F : (α', β') with constant annotation (α', β'), an interpretation I for a first-order formula F , and a value ⟨α, β⟩ from B assigned to F , we use χ as follows: if the value ⟨α, β⟩ ≥k
⟨α', β'⟩, then I(F : (α', β')) = ⟨1, 0⟩, and I(F : (α', β')) = ⟨0, 1⟩ otherwise. If the annotated term τ attached to an annotated atom F : τ contains variables μ, ν, we use the existential quantifier Σ when applying χ as follows: χτ (⟨α, β⟩) = ⟨1, 0⟩ if Σ(μ, ν)(τ ≥ ⟨α, β⟩).
Furthermore, we can proceed and give interpretation to complex annotated for- mulae in the standard way [15,20,17], using the operations defined on B to evaluate connectives and quantifiers. All the connectives of the language are put into cor- respondence with bilattice operations, and in particular quantifiers correspond to

infinite bilattice operations. We call the composition of the two mappings I and χ an interpretation for the bilattice-based annotated language L and for simplic- ity of notation denote it by I. Indeed, the interpretations of BAPs possess some remarkable properties which make the study of BAPs worthwhile, as follows.
Proposition 4.1 [20]
Let F be a formula, and ﬁx the value I(F ). If I(F : (α, β)) = ⟨1, 0⟩, then
I(F : (α', β')) = ⟨1, 0⟩ for all ⟨α', β'⟩ ≤k ⟨α, β⟩.
I(F1 : (τ1) ⊗ ... ⊗ Fk : (τk)) = ⟨1, 0⟩  ⇐⇒  I(F1 : (τ1) ⊕ ... ⊕ Fk : (τk)) =
⟨1, 0⟩ ⇐⇒ I(F1 : (τ1) ∧ ... ∧ Fk : (τk)) = ⟨1, 0⟩ ⇐⇒ I(Fi : (τi)) = ⟨1, 0⟩ for each i ∈ {1,..., k}.
If I(F1 : (τ1) ⊙ ... ⊙ Fk : (τk)) = ⟨1, 0⟩, then I((F1 ⊙ ... ⊙ Fk) : ((τ1) ⊙ ... ⊙
(τk))) = ⟨1, 0⟩, where ⊙ is any one of the connectives ⊗, ⊕, ∧.
For every formula F, I(F : (0, 0)) = ⟨1, 0⟩.
These properties generalise easily to infinite bilattice operations Σ, Π, ∃, ∀; and they influence the models for BAPs.
Let I be an interpretation for L and let F be a closed annotated formula of L. Then I is a model for F if I(F ) = ⟨1, 0⟩. We say that I is a model for a set S of annotated formulae if I is a model for each annotated formula of S. We say that F is a logical consequence of S if, for every interpretation I of L, I is a model for S implies I is a model for F .
Let BP denote the annotation Herbrand base for a program P , namely, the set of all ground annotated atoms which can be formed out of the symbols of P . An annotation Herbrand interpretation HI for P is the assignment of a mapping I from BP into B. Following the convention of logic programming, each Herbrand interpretation HI for P can be identified with the subset {R(t1,..., tk) : (α, β) ∈ BP |R(t1,..., tk) : (α, β) receives the value ⟨1, 0⟩ with respect to I} of BP , where R(t1,..., tk) : (α, β) denotes a typical element of BP . This set constitutes an anno- tation Herbrand model for P . Finally, we let HIP,B denote the set of all annotation Herbrand interpretations for P .
In [20], we introduced a semantic operator TP for BAPs, proved its continuity and showed that it computes the least Herbrand model MP for a given BAP P . Detailed analysis of some of the properties of TP can be found in [17]. We define TP next.
Definition 4.2 We define the mapping TP : HIP,B → HIP,B as follows: TP (HI) =
= {A : (τ ) ∈ BP such that either
A : (τ ) ← L1 : (τ1),..., Ln : (τn) is a strictly ground instance of a clause in P
and {L1 : (τ' ),..., Ln : (τ' )}⊆ HI, and for each (τ'),
1	n	i

(τi) ≤k (τ'),
or

there are annotated strictly ground atoms A : (τ∗),...,A : (τ∗) ∈ HI such that
1	k
(τ ) ≤k (τ∗) ⊕ ... ⊕ (τ∗)}.
1	k
Item (i) above reflects the property stated in item (i) of Proposition 4.1. Item
(ii) above reflects the properties captured in items (ii) and (iii) of Proposition 4.1. Note that according to item (i) of Proposition 4.1, whenever F : (τ ) ∈ HI and (τ') ≤k (τ ), then F : (τ') ∈ HI. Also, item (iv) of Proposition 4.1 ensures that for each formula F , F : (0, 0) ∈ HI, and we assume this property of HI throughout the paper. Thus, we always assume that each HI contains all ground formulae of the type F : (0, 0) prior to any implementations of the semantic operator.
Semantic operators defined for many logic programs in the style of [4,6,7,15,31] use only some form of item (i) from Definition 4.2. However, this condition is not sufficient for the computation of the (least) Herbrand models for (bi)lattice-based logic programs, as we see next.
Let T^P denote a form of semantic operator TP with no item (ii) from Defini-
tion 4.2. The next example displays the difference between T^P and TP . Symbols [i] and [ii] refer to items of Definition 4.2.
Example 4.3 Consider the logic program from Example 3.3, and the least fixed points of TP and T^P 5 .

Thus, in this example we can see that the program will definitely cancel both flights 1 and 2 on Monday.
The following example shows the fixed point of the semantic operators reached in ω steps.
Example 4.4 Consider the logic program given in Example 3.2. The least fixed point of this program (for T^P and for TP ) is
{R1(a1) : (1, 0.5), R2(f (a1)) : (ϑ1(1), ϑ2(0.5)), R1(f (f (a1))) :
(ϑ3(ϑ1(1)), ϑ4(ϑ2(0.5))),.. ., R1(fn−1(a1)) : (ϑn(ϑn−1 ... (... ((1)) .. .)),
3	1
ϑn(ϑn−1 ... (... ((0.5)) .. .))), R2(fn(a1)) : (μ', ν'),.. .}, where n ∈ ω. Here, μ' de-
4	2

5 Note that we use the fact that (( 3 , 1 ) ∨ ( 1 , 1 ))= ( 3 , 1 ) and (( 3 , 1 ) ⊕ ( 1 , 3 ))= ( 3 , 3 ).
4 2	2 2	4 2	4 2	2 4	4 4

notes ϑn(ϑn−1(ϑn−2 ... (... ((1)) .. .))), ν' denotes
1	3	1
ϑn(ϑn−1(ϑn−2 ... (... ((0.5)) .. .))), and ϑ1, ϑ2, ϑ3, ϑ4 stand for the functions μ , ν ,
2	4	2	2  3
μ  ν
3 , 3 respectively.
The following theorem is important and plays a fundamental role in considering the computation of the least fixed points of TP .
Theorem 4.5 The mapping TP is continuous.
The proof of this theorem can be found in [17,20]. Note that TP works with sets of strictly ground formulae, and not with interpretations themselves and this, in conjunction with the requirement that B has only finite joins, guarantees that TP is continuous. Note that analogous semantic operators defined in [4,15] and elsewhere do not possess this property.
Now, using Kleene’s theorem and Theorem 4.5, we may assert that lfp(TP ) = TP ↑ ω. Indeed, we have the following generalization of a well-known theorem due to van Emden and Kowalski [30].
Theorem 4.6 [20] For a BAP P, we have MP = lfp(TP ) = TP ↑ ω.
To summarize this section, we have defined interpretations and Herbrand inter- pretations for BAPs, and showed how to characterize the minimal models of BAPs using the semantic operator TP .
We finish the section by giving a useful definition that will provide a link between the declarative semantics of this section and the operational semantics we are going to consider in the next section.
Definition 4.7 Let P be a BAP and let G be a goal ← A1 : (τ1),..., Ak : (τk). An
answer for P ∪ {G} is a substitution θλ for individual and annotation variables of
G. We say that θλ is a correct answer for P ∪ {G} if Π((A1 : (τ1),..., Ak : (τk))θλ) is a logical consequence of P .
We will give a proof theoretic counterpart for the notion of the correct answer next.

SLD-Resolution
The resolution method was first introduced by Robinson, and was implemented (as SLD-resolution) in two-valued logic programming by Colmerauer et al. A detailed exposition of this can be found in [22], and for many-valued resolution procedures see [12,14,15,23,27,29], for example. Kifer and Lozinskii show in [14] that unlike classical refutation procedures, where only the resolution rule is applied, lattice- based theories need to have four procedures: resolution, factorisation, reduction and elimination in order to be sound and complete. This enriches resolution for many-valued logics which have linearly ordered sets of values, as it was defined, for example, in [12,31]. Some very interesting ideas about the relationship between resolutions for languages with ordered and non-ordered annotations can be found

in [24,25]. Comparing with these papers, we allow variables and functions in anno- tations and adopt the additional refutation rules (which correspond to some rules of [14]) in order to obtain soundness and completeness of SLD-resolution for BAPs. Note that in [14,24,25] only constant annotations are allowed in the language and therefore each logic program becomes finitely interpreted in these settings. We ex- tend all our results to infinitely interpreted programs with functions and variables in annotations. 6 Finally, we establish an operational semantics for BAPs and prove its soundness and completeness.
Throughout this section, we denote a BAP by P , and a BAP goal by G. We refer to [22] for a description of the unification process (originally defined by Herbrand and later refined by Clark [3]) for classical logic programming. Here, we follow this development, but involve annotation variables in the process of unification, see also [17]. The unification process for the individual variables remains unchanged, and, as in two-sorted languages, unification for the first-order and annotation parts of an annotated formula are handled independently. Following conventional notation, we denote the disagreement set by S, and substitutions by θλ, possibly with subscripts, where θ denotes a first-order substitution, and λ denotes a substitution involving annotations. We will use the abbreviation mgu when talking about most general uniﬁers defined in [22] or [17], for example.
Definition 5.1 [SLD-derivation] Let Gi be the annotated goal ← B1 : (τ1),..., Bk : (τk), and let C1,..., Cl be the annotated clauses A1 : (τ∗) ← body1,..., Al : (τ∗) ← bodyl, where each bodyi from body1,..., bodyl denotes the body of the clause Ci. Then the goal Gi+1 is derived from Gi and C1,..., Cl using mgu θλ if the following conditions hold:
Bm : (τm) is an annotated atom, called the selected atom, in Gi and
θ is an mgu of Bm and A1, and one of the following conditions holds: either
λ is an mgu of (τm) and (τ∗); or (τm)λ and (τ∗)λ receive constant values
1	1
such that (τm)λ ≤k (τ∗)λ;
or
θ is an mgu of Bm and A1,..., Al, and either λ is an mgu of (τm) and (τ∗),..., (τ∗) or (τm)λ and (τ∗)λ,..., (τ∗)λ receive constant values such
1	l	l
that (τm)λ ≤k ((τ∗)λ ⊕ ... ⊕ (τ∗)λ).
1	l
in case (a), Gi+1 is the goal (← B1 : (τ1),..., Bm−1 : (τm−1), body1, Bm+1 : (τm+1),..., Bk : (τk))θλ. In this case, Gi+1 is said to be derived from Gi and C1 using θλ.
in  case  (b),  Gi+1  is  the  goal  (←  B1  :  (τ1),..., Bm−1  : (τm−1), body1,..., bodyl, Bm+1 : (τm+1),..., Bk : (τk))θλ.  In this case, Gi+1 is said to be derived from Gi, C1,..., Cl using θλ.
Whenever a goal Gi contains a formula of the form F : (0, 0), then remove F : (0, 0) from the goal and form the next goal Gi+1 that is Gi except that it does not contain F : (0, 0).

6 An SLD-resolution for lattice-based logic programs with annotation functions and annotation variables was first introduced in [15] and was shown to be incomplete.

Note that certain items in the definition of derivation correspond to certain items in Definition 4.2 of TP . For example, item (a) corresponds to item (i) in Definition 4.2, and item (ii) corresponds to item (ii) in Definition 4.2. And, as we have noted before in relation to the definition of TP , all these items serve to reflect the model properties of BAPs captured in Proposition 4.1.
Definition 5.2 Suppose that P is a BAP and G0 is a goal. An SLD-derivation of P ∪ {G0} consists of a sequence G0, G1, G2 ... of BAP goals, a sequence of finite sets S1, S2,... of BAP clauses and a sequence θ1λ1, θ2λ2,... of mgus such that each Gi+1 is derived from Gi and Ci+1 using θi+1λi+1.
Note that S1, S2,... is defined to be a sequence of ﬁnite sets of clauses, and not just a sequence of clauses as in the case of classical SLD-resolution. This happens because item (b) admits the use of a finite set of clauses at each step of the derivation. This item was not included in the classical definition of SLD-resolution.
In [16], we gave a many-sorted representation of BAPs. This translation allowed us to apply the classical definition of SLD-resolution to the many-sorted transla- tion of BAPs. This result showed that in principle, one can use just sequences of clauses, and not sequences of ﬁnite sets of clauses when defining many-sorted SLD- derivation for BAPs; but this would require many-sorted non-annotated translation.
Definition 5.3 An SLD-refutation of P ∪ G0 is a finite SLD-derivation of P ∪ G0 which has the empty clause  as the last goal of the derivation. If Gn = , we say that the refutation has length n.
Definition 5.4 The success set of P is the set of all A : (μ, ν) ∈ BP such that
P ∪ {← A : (μ, ν)} has an SLD-refutation.
Definition 5.5 A computed answer θλ for P ∪ {G0} is the substitution obtained by restricting the composition of θ1,..., θn, λ1,..., λk to the variables of G0, where θ1,..., θn, λ1,..., λk is the sequence of mgus used in the SLD-refutation of P ∪{G0}.
Example 5.6 Let P be the program from Example 3.3 and let G0 be the goal
← Cancel(1, Monday) : (μ, ν), that is, we want to know the probability of cancelling flight number 1 on Monday.
We have a clause Cancel(y, x) : (1, 0) ← Delay(y, x) : ( 3 , 1 ) in P . Form the
4 2
set S = {Cancel(1, Monday) : (μ, ν), Cancel(y, x) : (1, 0)}, find its disagree- ment set, and apply item (a) from Definition 5.1 to get its mgu:  θ0λ0 =
{y/1, x/Monday, μ/1, ν/0}.
Now G1 is ← Delay(y, x) : ( 3 , 1 )θ0λ0 = Delay(1, Monday) : ( 3 , 1 ). We have
4 2	4 2
a clause Delay(y, x) : (( 3 , 1 ) ∨ ( 1 , 1 )) ← Storm(x) : ( 3 , 3 ), Storm(Tuesday) :
4 2	2 2	4 4
( 1 , 1 ), whose head contains annotations which are unifiable with ( 3 , 1 ). This
2 2	4 2
means that item (a) from Definition 5.1 can be applied here.
G2 = ← (Storm(Monday) : ( 3 , 3 ), Storm(Tuesday) : ( 1 , 1 ))θ1λ1 = ←
4 4	2 2
Storm(Monday) : ( 3 , 1 ), Storm(Tuesday) : ( 1 , 1 ).
4 2	2 2
Let Storm(Monday) : ( 3 , 3 ) be the selected atom. We see that it is not unifiable
4 4
with any input clause so we apply item (b) from Definition 5.1. So, we find the

mgu θ2 for Storm(x) : ( 1 , 3 ), Storm(Monday) : ( 3 , 1 ) and Storm(Monday) :
2 4	4 2
( 3 , 3 ) such that θ2 = {x/Monday}, and ( 3 , 3 ) ≤k ( 1 , 3 ) ⊕ ( 3 , 1 ). So, we can
4 4	4 4	2 4	4 2
form the next goal according to item (iii) from Definition 5.1.
The goal G3 = ← Storm(Tuesday) : ( 1 , 1 ). Now Storm(Tuesday) : ( 1 , 1 ) is a 
2 2	2 2
selected atom and, choosing the input clause Storm(x) : ( 1 , 3 ) ←, we apply
2 4
item (a) from Definition 5.1: the mgu for Storm(Tuesday) and Storm(x) is
θ2 = x/Tuesday, and ( 1 , 1 ) ≤k ( 1 , 3 ).
2 2	2 4
Use item (ii) and form the last goal G4 =  .
Thus, we conclude that we have obtained an SLD-refutation of P ∪ {G0} of length 4 with computed answer θ0λ0θ1λ1θ2λ2 (λ2 = λ1 = ε), which is restricted to the variables of G0 (in our case, the computed answer is {μ/1, ν/0}, that is, the flight number 1 will definitely be cancelled on Monday). Moreover, we conclude that Cancel(1, Monday) : (1, 0) is in the success set of P . As can be seen from Example 4.3, this formula is contained in the least fixed point of the TP operator applied to P .
The next theorem shows that the computations performed by the SLD resolution algorithm are correct.
Theorem 5.7 (Soundness of SLD-resolution for BAPs) Let P be a BAP. Then every computed answer for P ∪ {G} is a correct answer for P ∪ {G}.
Proof. Let G be ← B1 : (τ1),..., Bk : (τk) and θ1λ1,..., θnλn be the sequence of mgus used in a refutation of P ∪ {G}. We have to show that Π(B1(τ1) ⊗ ... ⊗ Bk : (τk))θ1λ1 ... θnλn is a logical consequence of P .
We prove this by induction on the length n of the refutation.
Basis step Suppose first that n = 1. This means that G is a goal of the form
← B1 : (τ1), and one of the following conditions holds:
P has a unit program clause of the form A1 : (τ∗) ← and B1θ = A1θ and
either (τ1)λ = (τ∗)λ1,
or (τ1)λ and (τ∗)λ receive constant values and (τ∗)λ ≤k (τ1)λ.
1	1
According to the definition of refutation, we have the third case in which P
has clauses A1 : (τ∗) ←, .. ., Al : (τ∗) ← such that B1θ = A1θ = ... = Alθ,
1	l
and
either (τ1)λ = (τ∗)λ = ... = (τ∗)λ,
1	l
or (τ1)λ and (τ∗)λ,..., (τ∗)λ are constants, and (τ1)λ ≤k ((τ∗)λ ⊕ ... ⊕
1	l	1
(τ∗))λ.
G = ← A1 : (0, 0).
Suppose (a) holds. Since (A1 : (τ∗))θλ is an instance of a unit clause in P , we conclude that (Π(B1 : (τ1)))θλ is a logical consequence of P ∪ {G}.
Suppose (b) holds.  Since A1θ = B1θ, (τ1)λ ≤k (τ∗)λ, and A1 : (τ∗)θλ is
1	1
an instance of a unit clause in P and, using Proposition 4.1, we conclude that (Π(B1 : (τ1)))θλ is a logical consequence of P .
Suppose (ii) holds. The case (a) can be proved analogously to the proof of (a).

Consider case (b). Since all (A1 : (τ∗) ←)θλ,..., (Al : (τ∗) ←)θλ are instances of
1	l
unit clauses in P , all these formulae are logical consequences of P . But then, using
the fact that A∗θ = ... = A∗θ and Proposition 4.1, we conclude that A((τ∗) ⊕ ... ⊕
1	l	1
(τ∗)) is a logical consequence of P . Now, using Proposition 4.1 and the fact that
B1θ = A1θ, we have that (Π(B1 : (τ1)))θλ is a logical consequence of P .
Suppose (iii) holds. According to Proposition 4.1, Π(A1 : (0, 0)) is a logical consequence of P .
Inductive step. Suppose that the result holds for computed answers which come from refutations of length n − 1. Suppose θ1λ1,..., θnλn is the sequence of mgus used in a refutation of P ∪ {G} of length n. Suppose further that the first refutation step in the refutation of length n was made in accordance with item (a) in Definition 5.1, and let A1 : (τ∗) ← body1 be the first input clause, such that A1 : (τ∗)θ1 ... θn = Bm : (τm)θ1 ... θn for some Bm : (τm) in G. By the induction hypothesis, Π(B1 : (τ1) ⊗ ... ⊗ Bm−1 : (τm−1) ⊗ body1 ⊗ Bm+1 : (τm+1) ⊗... ⊗Bk : (τk))θ1λ1 ... θnλn is a logical consequence of P . (This is because only n − 1 steps are needed to obtain a refutation for the latter formula.) But then (body1)θ1λ1 ... θnλn is a logical consequence of P . This means that A1 : (τ∗)θ1λ1 ... θnλn is a logical consequence of P . Additionally, we use the fact that (τm)λ1 ... λn ≤k (τ∗)λ1 ... λn and apply Proposition 4.1 to conclude that Bm : (τm)θ1λ1 ... θnλn is a logical consequence of P .
Suppose the first refutation step in the refutation of length n was taken in accordance with item (b) in Definition 5.1. Consider input clauses A1 : (τ∗) ← body1,..., Al : (τ∗) ← bodyl; and selected atom Bm : (τm) of G
1	l
at this step of the refutation.  By the induction hypothesis, Π(B1 : (τ1) ⊗
... ⊗ Bm−1 : (τm−1) ⊗ (body1) ⊗ ... ⊗ (bodyl) ⊗ Bm+1 : (τm+1) ⊗ ... ⊗ Bk : (τk))θ1λ1 ... θnλn is a logical consequence of P . (This is because only n − 1 steps are needed to obtain a refutation for the latter formula.) Consequently, (body1),..., (bodyl))θ1λ1 ... θnλn is a logical consequence of P , which means that (A1 : (τ∗))θ1λ1 ... θnλn, ..., Al : (τ∗))θ1λ1 ... θnλn are logical consequences of P . But since A1θ1 ... θn = ... = Alθ1 ... θn = Bmθ1 ... θn, using Proposition 4.1, we see that (A1 : ((τ∗) ⊕ ... ⊕ (τ∗)))θ1 ... θn is a logical consequence of P . Moreover,
1	l
according to Definition 5.1, item (b) which we have taken as our assumption, we
have (τm)λ1 ... λn ≤k (τ∗)λ1 ... λn, ⊕ ... ⊕ (τ∗)λ1 ... λn. Now, using Proposition
1	l
, we conclude that (Bm : (τm))θ1λ1 ... θnλn is a logical consequence of P .
We can apply the same arguments for the rest of the atoms (B1 : (τ1),..., Bk : (τk)) from G. Thus, Π((B1 : (τ1),..., Bk : (τk)))θ1λ1 ... θnλn is a logical conse- quence of P .	 
Corollary 5.8 The success set of P is contained in its least annotation Herbrand model.
Proof. Let A : (τ ) ∈ BP and suppose that P ∪ {← A : (τ )} has a refutation. By Theorem 5.7, A : (τ ) is a logical consequence of P . Thus A : (τ ) is in the least annotation Herbrand model for P .	 
We have proved that the algorithm of SLD resolution we defined for BAPs is

sound. We now wish to prove that it is complete.

6	Completeness of SLD-Resolution for BAPs
This section finishes the formal discussion of BAPs by showing that the SLD reso- lution algorithm for BAPs is complete.
Some proofs in this section require the use of lemmas which are straightforward generalizations of the so-called mgu lemma and lifting lemma [22] to the case when unification is allowed with respect to annotation variables as well as individual
variables. The lemmas and proofs can be found in [17].
The following completeness theorem extends the corresponding theorem for two- valued propositional logic programming due to Apt and Van Emden.
Theorem 6.1 Let P be a BAP. The success set of P is equal to its least annotation Herbrand model.
Proof. By Corollary 5.8, it suffices to show that the least Herbrand model for P is contained in its success set.
Suppose that A : (τ ) is in the least annotation Herbrand model for P . By Theorem 4.6, A : (τ ) ∈ TP ↑ n, for some n ∈ ω. We claim that A : (τ ) ∈ TP ↑ n implies that P ∪ {← A : (τ )} has a refutation, and hence that A : (τ ) is in the success set; we prove this claim by induction on n.
Basis step. n = 1. Then A : (τ ) ∈ TP ↑ 1, which means that either A : (τ ) ← is a strictly ground instance of a clause in P or (τ ) = (0, 0). And in both cases P ∪ {← A : (τ )} has a refutation (see items (a) and (iv) in Definition 5.1).
Inductive step. Suppose the claim holds for n − 1. Let A : (τ ) ∈ TP ↑ n. By the definition of TP , one of the following holds:
there exists a strictly ground instance of a clause B : (τ') ← B1 : (τ1),..., Bk : (τk) such that A = Bθ, (τ ) = (τ')λ, and B1 : (τ' )θ, ..., Bk : (τ' )θ ∈ TP ↑ (n−1)

with τ' ,...,τ'
1	k
such that:

1	k

(τi)λ ≤k (τ'), for  i ∈ {1,..., k}.
There are strictly ground atoms A : (τ1),...,A : (τk) ∈ TP ↑ (n − 1) such that (τ ) ≤k ((τ1) ⊕ ... ⊕ (τk)).
Suppose (i) holds. By the induction hypothesis, each P ∪ {← Bi : (τ')θ} has a refutation, for i ∈ {1,..., k}. We want to show that then P ∪ {← Bi : (τi)θλ} has a refutation, for i ∈ {1,..., k}.
Consider the refutation of G0 = {← Bi : (τ')θ}. According to Definition 5.1, there are two ways in which {← Bi : (τ')θ} can be derived.
Case 1.
There is a clause C : (τ∗) ← body in P such that Biθ = Cθ, and (τ') ≤k (τ∗)λ. Taking into account that (τi)λ ≤k (τ'), by transitivity of ≤k, we conclude that (τi)λ ≤k (τ∗)λ. But then, by Definition 5.1, item (a), the goal ← Bi(τi)θλ will receive a refutation.

Case 2.
There are clauses C1 : (τ∗) ← body1, . . . , Cm : (τ∗) ← bodym in P such
1	1
that Biθ = C1θ = ... = Cmθ, and τ' ≤k (τ∗λ ⊕ ... ⊕ τ∗ λ). But then, because
i	1	m
(τi)λ ≤k (τ'), we have τiλ ≤k (τ∗λ ⊕ ... ⊕ τ∗ λ). So, by Definition 5.1, item (b) the
i	1	m
goal ← (Bi : τi)θλ will receive refutation as well.
Suppose (ii) holds, that is, there are strictly ground atoms A : (τ1),...,A : (τk) ∈ TP ↑ (n − 1) such that (τ ) ≤k ((τ1) ⊕ ... ⊕ (τk)). We want to show that then A : (τ ) has a refutation.
Using the induction hypothesis, each of P ∪ {← A : (τ1)},...,P ∪ {← A : (τk)} has a refutation. This means that, according to Definition 5.1, items (a) and (b), there are clauses A : (τ∗) ← body∗,...,A : (τ∗) ← body∗ , such that for each A : (τi)
1	1	n	n
one of the following holds:
(τi)λ ≤k (τ∗)λ. In this case, P ∪ {← body∗} has a refutation.
j	j
•• (τi)λ ≤k ((τ∗) ⊕ ... ⊕ (τ∗)). Then P ∪ {← body∗,..., body∗} has a refutation,
j	l	j	l
for some j, l ∈ {1,..., n}.
Combining all these refutations for i ∈ {1,..., n}, we obtain a refutation of P ∪ {←
(body∗,..., body∗ )θλ}. But then, according to Definition 5.1, items (a) and (b),
1	n
there is a refutation for P ∪{← A : (τ')θλ}, where τ'λ is some annotation such that

(τ')λ ≤k ((τ∗)λ ⊕ ... ⊕ (τ∗)λ)	(∗)
1	n

for each (τ')λ ≤k (τ∗)λ (in case of •) or for each (τ')λ ≤k ((τ∗) ⊕... ⊕ (τ∗)) (in case
j	j	l
of ••), for j, l ∈ {1,..., n}. Now, having that either each (τi)λ ≤k (τ∗)λ or each
(τi)λ ≤k ((τ∗) ⊕ ... ⊕ (τ∗)), for i ∈ {1,..., k} and j, l ∈ {1,..., n}, we conclude, by
j	l
monotonicity of ⊕, that

((τ1)λ ⊕ ... ⊕ (τk)λ) ≤k ((τ∗)λ ⊕ ... ⊕ (τ∗)λ).
1	n
But then, by Definition 5.1, item (a), the condition (∗) implies that, for each an- notation constant (τ ♦) such that (τ ♦) ≤k ((τ∗) ⊕ ... ⊕ (τ∗))λ, there exists a refu-
1	n
tation for P ∪ {← A : (τ ♦)θλ}. This holds in particular for all the τ ♦ such that (τ ♦) ≤k ((τ1) ⊕ ... ⊕ (τk))λ. According to item (2), among such (τ ♦) will be (τ ♦) = (τ )λ. Thus, we conclude that P ∪ {← A : (τ )θλ} has an unrestricted refuta- tion. Finally, we apply the mgu lemma to obtain a refutation for P ∪{← A : (τ )}. 
Thus, the SLD resolution algorithm is complete in that, for every BAP P , the success set of P is equal to its least annotation Herbrand model.
Next, we need to obtain the completeness with respect to correct answers. As in classical two-valued logic programming, it is impossible to prove the exact converse of Theorem 5.7. However, we can extend the classical result that every correct an- swer is an instance of a computed answer to the case of BAPs. The next lemma and associated theorem are straightforward (the proofs can be found in [17]), recall that we allow refutation to work over individual and annotation variables independently.

Lemma 6.2 Let Π(A : (μ, ν)) be a logical consequence of P. Then there exists an SLD-refutation of P ∪ {← A : (μ, ν)} with the identity substitution as a computed answer.
The next completeness result is a generalization of the analogous theorem of Clark [3], its proof can be found in [17].
Theorem 6.3 For every correct answer θλ for P ∪ {G}, there exist a computed answer θ∗λ∗ for P ∪ {G} and substitutions ϕ, ψ such that θ = θ∗ϕ and λ = λ∗ψ.
This theorem concludes our discussion of the SLD resolution algorithm.

7	Conclusions and further work
We have carefully examined the declarative and operational semantics of bilattice- based annotated logic programs. In particular, we have shown that unlike the usual approach to many-valued logic programming semantics (see, for example, [7,8,15,29] and many others), the immediate consequence operator for bilattice- based annotated logic programs cannot be obtained as a simple extension of the classical semantic operator. We have given some examples displaying the immediate consequence operators as defined in [7,8,15], and shown that these operators do not compute all the logical consequences of a program, but only certain of them. We have proposed an original definition of the immediate consequence operator computing all the logical consequences of a given bilattice-based annotated logic program, and showed that it is continuous.
The declarative semantics for BAPs allows us to propose an SLD-resolution for BAPs and prove its soundness and completeness relative to our semantics. Like the resolution procedures given in [14] for lattice-based logics, this SLD-resolution is enriched with additional rules reflecting the properties of the extended semantic operator for BAPs, and is an alternative to the constrained resolution for the general annotated logic programs of Kifer and Subrahmanian, see [15] and to resolutions for logics which are interpreted by linearly ordered sets [12,23,31] and/or finite sets [15,23,24,25].
We show in a companion paper [19] that the semantic operator for the logic pro- grams we have introduced here can be computed by learning artificial neural net- works in the style of [13], but with learning functions embedded into connections be- tween the layers. This shows that the automated proof procedure (SLD-resolution) we have introduced has its counterpart in the field of neural computation.
Further work to be done includes the elimination of annotations from the lan- guage in the same way as this was carried out in [16]. In particular, further in- vestigation of the possible computational effects of the translation of BAPs into non-annotated sorted programs [16] may be interesting. Another field of possible extension of our results is to relate BAPs to probabilistic logic programs, as they were defined and studied, for example, in [1,5] and other papers. Finally, it would be interesting to show how we can extend BAPs to logic programs with interval- based annotations, and thereby establish linear programming for them. Such work

would relate to [21,26] and others and would make use of many results established by these authors.

References
F. Bacchus. Lp, a logic for representing and reasoning with statistical knowledge. Computational Intelligence, 6:209–231, 1990.
J. Calmet, J. J. Lu, M. Rodriguez, and J. Schu¨. Signed formula logic programming: Operational semantics and applications. In Proceedings of the Ninth International Symposium on Foundations of Intelligent Systems, volume 1079 of Lecture Notes in Artificial Intelligence, pages 202–211, Berlin, June 9-13 1996. Springer.
K. Clark. Predicate logic as a computational formalism. Technical Report DOC 79/59, Department of Computing, Imperial College, 1979.
C. V. Dam´asio and L. M. Pereira. Sorted monotonic logic programs and their embeddings. In Proceedings of the 10th International Conference on Information Processing and Management of Uncertainty in Knowledge-Based Systems (IPMU-04), pages 807–814, 2004.
R. Fagin, J. Y. Halpern, and N. Megiddo. A logic for reasoning about probabilities. Information and Computation, 87(1,2):78–128, 1990.
M. Fitting. Bilattices in logic programming. In G. Epstein, editor, The twentieth International Symposium on Multiple-Valued Logic, pages 238–246. IEEE, 1990.
M. Fitting. Bilattices and the semantics of logic programming. Journal of logic programming, 11:91– 116, 1991.
M. Fitting. Fixpoint semantics for logic programming — a survey. Theoretical computer science, 278(1-2):25–51, 2002.
M. L. Ginsberg.	Multivalued logics: a uniform approach to reasoning in artificial intelligence.
Computational Intelligence, 4:265–316, 1988.
R. H¨ahnle. Towards an efficient tableaux proof procedure for multiple-valued logics. In Workshop in Computer Science and Logic, Heildelberg, volume 533 of lecture Notes in Computer Science, pages 248–260, 1990.
R. H¨ahnle. Automated Deduction in Multiple-Valued Logics, volume 10 of International Series of Monographs in Computer Science. Oxford University Press, 1994.
R. H¨ahnle and G. Escalado-Imaz. Deduction in many-valued logics: a survey. Mathware and soft computing, IV(2):69–97, 1997.
S. H¨olldobler, Y. Kalinke, and H. P. Storr. Approximating the semantics of logic programs by recurrent neural networks. Applied Intelligence, 11:45–58, 1999.
M. Kifer and E. L. Lozinskii. RI: A logic for reasoning with inconsistency. In Proceedings of the 4th IEEE Symposium on Logic in Computer Science (LICS), pages 253–262, Asilomar, 1989. IEEE Computer Press.
M. Kifer and V. S. Subrahmanian. Theory of generalized annotated logic programming and its applications. Journal of logic programming, 12:335–367, 1991.
E. Komendantskaya. A many-sorted semantics for many-valued annotated logic programs. In Proc. 4th Irish Conf. on the Mathematical Foundations of Computer Science and Information Technology (MFCSIT), pages 225–229, Cork, Ireland, August 1– August 5 2006.
E. Komendantskaya. Learning and Deduction in Neural Networks and Logic. PhD thesis, Department of Mathematics, University College Cork, Ireland, 2007.
E. Komendantskaya. A sequent calculus for bilattice-based logic and its many-sorted representation. In N. Olivetti, editor, Proc. Int. Conf. on Automated Reasoning with Analytic Tableaux and Related Methods, TABLEAUX’07, volume 4548 of LNAI, pages 165–182, Aix en Provance, 3– 6 July, 2007. Springer.
E. Komendantskaya and A. K. Seda. Logic programs with uncertainty: neural computations and automated reasoning. In Proc. CiE’06, pages 170–182, Swansea, Wales, June 30– July 5 2006.
E. Komendantskaya, A. K. Seda, and V. Komendantsky. On approximation of the semantic operators determined by bilattice-based logic programs. In Proc. 7th Int. Workshop on First-Order Theorem Proving (FTP’05), pages 112–130, Koblenz, Germany, September 15–17 2005.

L. V. S. Lakshmanan and F. Sadri. On a theory of probabilistic deductive databases. Theory and Practice of Logic Programming, 1(1):5–42, January 2001.
J. Lloyd. Foundations of Logic Programming. Springer-Verlag, 2nd edition, 1987.
J. J. Lu. Logic programming with signs and annotations. Journal of Logic and Computation, 6(6):755– 778, 1996.
J. J. Lu, N. V. Murray, and E. Rosenthal. A framework for automated reasoning in multiple-valued logics. Journal of Automated Reasoning, 21(1):39–67, 1998.
J. J. Lu, N. V. Murray, and E. Rosenthal. Deduction and search strategies for regular multiple-valued logics. Journal of Multiple-valued logic and soft computing, 11:375–406, 2005.
R. Ng and V. S. Subrahmanian. Probabilistic logic programming. Information and computation, 101(2):150–201, 1992.
M. I. Sessa. Approximate reasoning by similarity-based SLD-resolution. Theoretical computer science, 275:389–426, 2002.
U. Straccia. Query answering in normal logic programs under uncertainty. In 8th European Conference on Symbolic and Quantitative Approaches to Reasoning with Uncertainty (ECSQARU-05), Lecture Notes in Computer Science, pages 687–700, Barcelona, Spain, 2005. Springer Verlag.
M. van Emden. Quantitative deduction and fixpoint theory. Journal of Logic Programming, 3:37–53, 1986.
M. van Emden and R. Kowalski. The semantics of predicate logic as a programming language. Journal of the Assoc. for Comp. Mach., 23:733–742, 1976.
P. Vojt´as and L. Paul´ık. Soundness and completeness of non-classical extended sld-resolution. In
R. Dyckhoff, H. Herre, and P. Shroeder-Heister, editors, Extensions of Logic Programming, 5th International Workshop ELP’96, Leipzig, Germany, March 28-30, 1996, volume 1050 of Lecture notes in Computer Science, pages 289–301. Springer, 1996.
