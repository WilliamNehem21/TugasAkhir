

Electronic Notes in Theoretical Computer Science 173 (2007) 139–157
www.elsevier.com/locate/entcs

A Logical Characterisation of Static Equivalence
Hans Hu¨ttel1 and Michael D. Pedersen2 ,b
BRICS, Department of Computer Science Aalborg University, Denmark
b LFCS,School of Informatics University of Edinburgh, Scotland

Abstract
The work of Abadi and Fournet introduces the notion of a frame to describe the knowledge of the envi- ronment of a cryptographic protocol. Frames are lists of terms; two frames are indistinguishable under the notion of static equivalence if they satisfy the same equations on terms. We present a first-order logic for frames with quantification over environment knowledge which, under certain general conditions, character- izes static equivalence and is amenable to construction of characteristic formulae. The logic can be used to reason about environment knowledge and can be adapted to a particular application by defining a suitable signature and associated equational theory. The logic can furthermore be extended with modalities to yield a modal logic for e.g. the Applied Pi calculus.
Keywords: Frames, static equivalence, logic, cryptographic protocols, Applied Pi


Introduction
Formal approaches to the design and analysis of security protocols often rely on a notion of environment knowledge. Following Abadi and Fournet, [3], a frame is a substitution with name restriction which represents the messages communicated by principals at any given state in a communication protocol and hence an implicit representation of environment knowledge. Consider for example the frame


ϕ1 =Δ
(νk){ enc(b,k+)/x , k−/x }

which represents the environment knowledge in a state of a protocol where two messages have been sent on some open channel: a name b encrypted with a public

1 Email: hans@cs.aau.dk
2 Email: m.d.pedersen@sms.ed.ac.uk . This work was supported in part by Microsoft Research through the European PhD Scholarship Programme.


1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.032

key k+ and the corresponding private key k−. The intuition that the seed k should be secret is captured by the restriction (νk) on k. Individual terms can be referred through their respective variables which provides a means of ordering terms.
Arbitrary terms can be built from names and variables in a frame, and equality between terms is defined on a per-application basis by an appropriate equational theory, =E . In the frame ϕ1, which relies on public-key encryption, one would thus expect that e.g. dec(x1, x2) =E b. Two frames are statically equivalent if they cannot be distinguished by testing for equality between arbitrary terms built from variables and free names in the frames. Take for example two additional frames, where h is a one-way hash function:


ϕ'	=Δ
(νk){ enc(b,h(k)+)/x , h(k)−/x }	ϕ''  =Δ
(νk){ enc(h(b),k+)/x , k−/x }

1	1	2	1	1	2
The two frames differ from ϕ1 only in the hash function being applied to the keys

and to the clear text b, respectively. We then have that ϕ1 and ϕ'
are statically

equivalent because the same equalities hold in both frames; in particular, the equal- ity dec(x1, x2) =E b holds. On the other hand, this equality does not hold in ϕ'', so
ϕ'' is neither statically equivalent to ϕ1 nor ϕ' .
1	1
In addition to being a self-contained representation of knowledge, frames and
static equivalence play a central role in process calculi such as the Applied π calculus
[3] and the Spi calculus [4, 6] since observational equivalence on processes is defined using standard bisimulation conditions and a condition of static equivalence on the frames arising from processes. The standard definition of static equivalence does however suffer under universal quantification over terms, which raises decidability issues and which complicates a logical characterisation. In fact it has been shown that static equivalence is undecidable for some equational theories, but a class of theories for which static equivalence is decidable is also known [1, 2, 7].
The main contribution of this paper is a first order logic for frames which char- acterizes static equivalence and yields characteristic formulae under certain general conditions, namely when the equational theory is an independent convergent sub- term theory and allows term reductions to be observable. The logic includes atomic propositions for testing equality (in the equational theory), reductions and syntactic equality between terms. Quantification ranges over the synthesis of a frame which, intuitively, is a direct representation of environment knowledge. Hence the logic can be used to reason about environment knowledge and can be adapted to a particular application by defining a suitable function signature and equational theory.
Extending the logic with modalities [9] yields a modal logic for Applied π which characterizes observational equivalence on processes and which allows reasoning about environment knowledge over time. The modal logic can again be adapted to particular applications; for instance, defining an equational theory with private key cryptography results in a logic resembling the Spi logics [8].
In order to obtain the logical characterisation results we first give a refined definition of static equivalence which does not rely on universal quantification over arbitrary terms. It is shown that the refined definition coincides with the standard definition under the general conditions noted above. Our approach is inspired by

the notion of cores introduced in [6] for the Spi calculus.
The paper is structured as follows. In Section 2 we introduce some basic notions and formalise our assumptions on equational theories. Section 3 develops a refined definition of static equivalence which does not rely on universal quantification over arbitrary terms. In Section 4 we present the logic for frames, and in section 5 we briefly show how this can be extended to a modal logic for Applied π. Finally Section 6 concludes.

Basic Definitions
Terms
A signature Σ consists of a finite set of function symbols each associated with an integer arity. Let Σk be the function symbols in Σ with arity k, let N be the set of names, ranged over by a, b, c,... , k, let X be the set of variables, ranged over by x, y, z, and let U = N ∪ X . Then the set of terms T (Σ, U) is defined inductively as follows:
U ⊆ T (Σ, U ).
for all k ≥ 0: f (M1,... , Mk) ∈ T (Σ, U) if f ∈ Σ(k) and M1,... , Mk ∈ T (Σ, U)
The set of names, respectively variables, occurring in a term M ∈ T (Σ, U) will be denoted by n(M ), respectively v(M ), and we will use the abbreviation n(M1, M2) to denote n(M1)∪n(M2). A context C[x˜] isa term where v(C[x˜]) = x˜ and n(C[x˜]) = ∅. Often we will be interested in identifying substrings at certain positions of a term M ∈ T (Σ, U ). For this purpose the structure of M can be illustrated by representing it as a parse tree, where nodes are labelled by elements of Σ ∪U, nodes labelled by U are leaves and the children of a node labelled by a function symbol f are the arguments of f . A position is then a finite sequence w = w1,... , wn where wi ∈ N. The position w identifies the node found by traversing the tree from the root and for each node at level i following the edge numbered wi. The subterm of M whose parse tree is rooted at w is denoted M |w (a formal definition of positions
and subterms is given in [11]).

The Equational Theory
Following [1], we define equality between terms based on a term rewrite system. A rewrite rule r is of the form L >r R where L, R ∈ T (Σ, X ) and v(R) ⊆ v(L). A term M1 reduces primitively to M2 using rule L >r R, written M1 >r M2, if M1 = Lθ and M2 = Rθ for some substitution θ. A term rewrite system R is then a set of rewrite rules, and we are interested in the rewrite relation > induced by the rewrite system. Define M1 > M2 if and only if there is a rule L >r R in R such that M1|w = Lθ and and M2 = M1{ Rθ/M1 |w } for some substitution θ and position w. The equational theory =E is now given by the reflexive, symmetric and transitive closure of the reduction relation >.
We consider applications with encryption and pairs as a running example.

Example 2.1 For applications with symmetric key encryption and pairs the fol- lowing self-explanatory signature Σsym can be adopted:


Σsym  =Δ
{enc(·, ·), dec(·, ·), [·, ·], fst (·), snd (·)}

The equational theory E S is generated from the following rules which specify how decryption and projection works:
dec(enc(z1, z2), z2) >r1 z1	fst ([z1, z2]) >r2 z1	snd ([z1, z2]) >r3 z2
and the example equality fst(dec(enc([a, b], k), k)) =ES a then holds.
Example 2.2 To model public key cryptography we simply add public/private key

generator functions to the signature from Example 2.1, i.e. Σpub	Δ
∪ {·+, ·−}.

The equational theory E P is generated from the following rules:


dec(enc(z1, z2+), z−) >r
z1	fst([z1, z2]) >r2
z1	snd ([z1, z2]) >r3 z2

and the example equality fst(dec(enc([a, b], k+), k−)) =EP a holds.
Frames and Static Equivalence
As explained in the introduction, environment knowledge is implicitly represented by frames of the form ϕ = (νn˜)σ where n˜ is a (possibly empty) list of private names and σ is a substitution of the form { M1/x1 ,... , Mk/xk }. That is, a frame is simply a substitution with possible restrictions on names. Considered as such, it can be applied to terms in the expected way, and we write Mϕ for the term where each variable xi occurring in M is replaced with Mi. We assume that substitutions are cycle-free and that all occurring terms are on normal form (i.e. irreducible in the associated term rewrite system). We denote by dom(ϕ) and im(ϕ) the domain and image of the substitution in ϕ, respectively. Free names and bound names of a frame are denoted by fn(ϕ) and bn(ϕ) respectively and are defined as expected.
Static equivalence expresses indistinguishability of frames based on equality be- tween terms in frames:
Definition 2.3 Two terms M1 and M2 are equal in frame ϕ, written (M1 =E M2)ϕ
iff n(M1, M2) ∩ bn(ϕ)= ∅ and M1ϕ =E M2ϕ.
Definition 2.4 Two frames ϕ and ϕ' are statically equivalent in E, written ϕ ≈E ϕ', iff dom(ϕ)= dom(ϕ') and
(M1 =E M2)ϕ ⇔ (M1 =E M2)ϕ' for all terms M1 and M2
Reduction Observable Theories
In order to give a refined definition of static equivalence which coincides with the standard definition, and subsequently give a logical characterisation, we need to impose some assumptions on the theories under consideration.

The first assumption is that of reduction observable theories, defined as follows:

Definition 2.5 An equational theory E on T (Σ, U) generated from a rewrite system
R is reduction observable if
There is a constant function symbol ok ∈ Σ
For every d ∈ Σ there is a test function symbol test d ∈ Σ.
For every (d(C[z˜]) >r R) ∈R there is a reduction test rule (test d(C[z˜], ok) >r'
ok) ∈ R.
Note that any theory E can be extended with appropriate test functions and rewrite rules to become reduction observable, and we shall generally denote this extension by E+. A reduction observable theory essentially allows frames to be distinguished based on reductions in addition to equality. We argue that this is often a reasonable assumption. Consider the following two frames:


ϕ	Δ	enc(b,k+)	k−	'	Δ
enc(b,k+)	c−

2  =  (νk, b, c){
/x1 ,
/x2 }	ϕ2
=  (νk, b, c){
/x1 ,
/x2 }

The first frame contains an encrypted name and the corresponding private key which can be used for decryption. The second frame contains the same encrypted name but does not contain the corresponding private key for decryption. Now it turns out that ϕ2 ≈EP ϕ' . The only relevant attempts at constructing distinguishing equalities are dec(x1, x2) =EP b and x1 =EP enc(dec(x1, x2), k+), but these do not hold in either frame since b and k are in bn(ϕ2) and bn(ϕ' ).

The fact that ϕ2 ≈EP ϕ'
might be slightly surprising. For we then get that

the knowledge arising from a process which outputs an encrypted term together with the corresponding decryption key is semantically equivalent to a process which outputs the same encrypted term together with an unrelated decryption key! On

the other hand, ϕ2 /≈EP + ϕ'
because the equality test dec(x1, x2) > ok holds in ϕ2

but not in ϕ' .
Is this sensible? Implementations of cryptographic functions (e.g. the OpenSSL library [12]) typically do not provide means of testing whether decryption with a given decryption key is successful or not. However, in many applications it is assumed that this information is available, e.g. by appending a publicly known token to the clear text before encryption; it can then be checked if the decryption output also contains this token.
The second assumption is that of convergent subterm theories, i.e. theories generated from a convergent rewrite system R = {Li >ri Ri}i∈I in which Ri is a subterm of Li for each i ∈ I. Static equivalence has been shown to be decidable for this class of theories [1].
For the third and final assumption we introduce the notion of a destructor con- text:
Definition 2.6 A context D[x, x˜] is a destructor context with target x (identified by underline) if it is unifiable with the left hand side of some rewrite rule L >r R

and the position of x in D[x, x˜] is a proper prefix of the position of R in L.
For example, snd (x) is a destructor context while snd ([x, y]) is not; this reflects the intuition that the destructor function snd “takes apart” x in the former context but not in the latter. We can now state the third and final assumption, namely that rewrite rules are independent in the sense that they do not contain destructor contexts as proper subterms; i.e. we disregard rewrite rules such as
dec(enc(fst ([z1, z2]), z3), z3) > z1
which intuitively says that only encrypted first components of pairs can be de- crypted. This assumption is not very strong though, for the vast majority of theories with rules on the above form are not convergent. Note that if E is an independent convergent subterm theory then E+ is also an independent convergent subterm theory.

Refining Static Equivalence
In this section we develop a refined definition of static equivalence which does not suffer from universal quantification over arbitrary terms. We start by defining the analysis of a frame, which intuitively is the set of terms resulting from taking the frame to bits, e.g. by iteratively decrypting or projecting terms in the frame. The analysis may generally be big though; therefore we also define the cores of a frame as the smallest subset of the analysis sufficient for “reproducing” the analysis. The refined definition of static equivalence places conditions on contexts over cores: cor- responding terms in two frames must be equal up to cores and the same reductions and syntactic equalities over cores must hold in the two frames. In order to limit the number of contexts considered, we furthermore define the notion of partitioning contexts.

Analysis
For any equational theory we assume an associated revelation relation, >S, where
M1 >S M2 if M1 can reveal a subterm M2 based on the set of terms S.
Definition 3.1 Let S be a set of terms. Define M >S M |w if and only if there is a destructor context D[x, x˜] and terms T˜ ⊆ S such that D[M, T˜] >r M |w.
For example, we have that enc(a, k+) >S a if k ∈ S or k− ∈ S. The analysis A(M, S) is then the iterated revelation from M based on the terms in S; this is a generalisation of the analysis for cryptographic protocols given in [10]. It will be important that analysis terms can be ordered by position in their parents, and therefore we define the analysis A(M, S) asa set of pairs (M |w, w) where M |w is a term revealed from M .
Definition 3.2 Let S be a set of terms and let M ∈ S. Then the analysis of M

with respect to S is defined inductively as follows:


A0(M, S)
= {(M, ϵ)}

Ai+1	Δ	i
(M, S)  = A (M, S)∪
{(M |w, w)|∃(M |w' , w') ∈ Ai(M, S) s.t. M |w' >S	Ai(T,S) M |w}


We further define A
  M ∈S A(M, S).
(M, ϕ)
Δ	A(M, im(ϕ) ∪ fn(ϕ)) for frames ϕ and A
(S)	Δ

Whenever positions are unimportant they will be omitted in the following, in which case the analysis is simply considered a multiset of terms.
Cores and Ecores
Considered as a set of known terms, the analysis often contains redundancy. For complexity reasons we only wish to consider the smallest subset of the analysis from which the analysis can be reconstructed by applying appropriate contexts. The first step towards this aim is the following definition of cores.
Definition 3.3 Let M be a term and S a set of terms. Then


cores(M, S)
=  {(M |w, w) | (M |w, w) ∈ A(M, S) ∧ M |w />A(S)}



Define cores(M, ϕ)
=  cores(M, im(ϕ)∪fn(ϕ)), cores(x, ϕ)
Δ
= cores(xϕ, ϕ) and,

for ϕ = (νn˜){ Mi/xi}i∈I ,

cores(ϕ)
Δ
=
i∈I
{(Mi|w
, w, i) | (Mi|w
, w) ∈ cores(Mi, ϕ)}∪ {(n, , ) | n ∈ fn(ϕ)}

Note that we have defined the cores of a frame to include all free names in the frame (the place holder simply indicates that free names have no index and position) since these are an essential part of environment knowledge. As with the analysis we often take the liberty of ignoring the position information and consider cores as multisets of terms instead of pairs or triples.
Our definition of cores is a generalisation of the definition given in [6] where a core is a single term and defined only for symmetric key encryption. In contrast, our definition works for any convergent subterm rewrite system, resulting in cores which are sets.
The above definition of cores is however sometimes insufficient for capturing the idea that the analysis can be reconstructed by applying appropriate contexts to cores. Take for instance the following simple frame:


ϕ  = (νk){
enc([a,b],k+)/x ,
k−/x }

Then cores(x1, ϕ)= {a, b}, but k+ is not a core. Disregarding k+ altogether results in a loss of information: M1 = enc([a, b], k+) (and thereby the analysis of ϕ) cannot

be reconstructed by applying contexts to the cores, and the fact that the equality
dec(M1, k−) =E [a, b] holds is lost. This prompts us to define extended cores thus:
Definition 3.4 A term M |w ∈ A(M, S) is an extended core, or ecore, with respect to the set S if either
(M |w, w) ∈ cores(M, S).
There is no context C[x˜] and no terms M˜ ⊆ A(S) such that M |w = C[M˜ ].
The set of extended cores of M with respect to S is denoted by ecores(M, S), and we define ecores(M, ϕ), ecores(x, ϕ) and ecores(ϕ) as for cores.
Again we often disregard the position information in ecores.

Example 3.5 Take the frame ϕ  =Δ
(νa, b, k
,k ){[enc(a,k1+),enc(b,k2+)]/

, k−
} in

the theory E P . Then
1	2	x1
1 /x2

cores(x1, ϕ)= {a, enc(b, k2+)}
ecores(x1, ϕ)= {enc(a, k1+), enc(b, k2+), a}
Note how each term in im(ϕ) can now be written as a context over ecores, and that the analysis can be reconstructed from ecores by applying appropriate function symbols!
We impose a linear ordering on ecores for the purpose of comparing ecores with the same index in different frames and write ecores(ϕ) = (N )i∈J for an ordered sequence of ecores. The ordering is based on positions and indices in frames, but the details are insignificant and have been omitted; they can be found in [11].
Partitioning Contexts
In order to limit the complexity of the refined definition of static equivalence and subsequently give a construction of finite characteristic formula, it is crucial that we only consider a restricted class of partitioning contexts. To that end we first need a definition of a correlation relation  on variables in a context. Intuitively, y1  y2 in a context C[y˜] if y1 and y2 depend on each other in a reduction of instances of C[y˜]; in the context dec(enc(y1, y2+), y3) we thus have that y2 and y3 are correlated while y1 is neither correlated to y2 nor y3. In other words, encryption keys are mutually dependent but they are independent of the clear text. Here is the general definition:
Definition 3.6 Let L[z˜] > R[z˜] bea rewrite rule and let C[y˜] be a context which is

unifiable with L[z˜]. Let wi and wj be two positions in C[y˜] and let w' and w'
be the

i	j
longest prefixes of wi, respectively wj, such that the position w', respectively w' ,
i	j
exists in L[z˜]. We then say that wi and wj are strongly correlated, written wi « wj, if v(C[z˜]|w' ) ∩ v(C[z˜]|w' ) /= ∅.
i	j
Strong correlation is a reflexive and symmetric binary relation. Define (weak)
correlation,  , to be the transitive closure of strong correlation and say that wi
and wj are correlated if wi  wj.

For each pair of variables yi, yj ∈ v(C[y˜]) let w˜i and w˜j be the positions of yi and yj in C[y˜], respectively (there will be multiple positions if a variable has multiple occurrences). We then define yi  yj if wi  wj for every wi ∈ w˜i and wj ∈ w˜j.
Definition 3.7 A context C⊥[y˜] over variables and the distinguished name ⊥ is partitioning if it is unifiable with the LHS of some rewrite rule L[z˜] > R[z˜] and the following hold:
yi  yj for all yi, yj ∈ y˜.
C⊥[y˜]|w = ⊥ implies L[z˜]|w = z for all w and some z ∈ z˜.
The first condition says that all variables in a partitioning context must be correlated, and the second condition says that all occurrences of ⊥ must unify trivially with a variable in the rewrite rule.
Example 3.8 The following are examples of contexts which can easily be verified to be partitioning with respect to the public-key rewrite rule:
dec(enc(⊥, y1+), y−)
dec(enc(y1, ⊥+), ⊥−)
The following are examples of contexts which are not partitioning:
dec(enc(y1, y2), ⊥−) is not partitioning because y1 and y2 are not correlated (con- dition 1 fails).
dec(enc(h(⊥), y1+), y2) is not partitioning because the position of ⊥ does not match the position of z1 (condition 2 fails).
The Reﬁned Deﬁnition of Static Equivalence
Say that M1 is more general than M2, written M1 N M2, if there exists some substitution θ such that M2 = M1θ. We shall in addition write M1 M2 to mean
that M1 and M2 are unifiable but neither is more or less general than the other,
there exists a unifying substitution θ such that M1θ = M2θ, M1 /N M2 and
M2 /N M1.
We shall mainly be interested in asserting generality on contexts in relation to
the LHS of some rewrite rule. For this purpose we also define N and  as unary relation symbols, and write e.g. C[y˜]  if there exists a rewrite rule L[z˜] >r R[z˜] in
the relevant rewrite system such that C[y˜] L[z˜] (and similarly for N). With these notions we are now ready to state the refined definition of static equivalence.

Definition 3.9 Let ϕ = (νn˜){ Mi/x }	and ϕ' = (νn˜){ M '/x }
be two frames

i  i∈I	i  i  i∈I
with ecores(ϕ)= (N )j∈J , ecores(ϕ')= (N ')j∈J . Then ϕ and ϕ' are reﬁned statically
equivalent, written ϕ ≈' ϕ', if each of the following conditions holds:
For each i ∈ I there is some context C[y˜] such that Mi = C[N˜] and M ' = C[N˜'].
For any context C[y˜] and for all j ∈ J it holds that
C[N˜]= Nj ⇔ C[N˜']= N '

For any partitioning context C⊥[y˜] where C⊥[y˜] N or C⊥[y˜]  it holds for all

C⊥[y˜] that
1	1	1

C⊥[N˜] >r C⊥[N˜] ⇔ C⊥[N˜'] >r C⊥[N˜']
1	2	1	2
Contexts and ecores have been defined in such way that condition 1 is well- defined, and it is easy to see by induction that any term in a frame can indeed be written as a context over ecores. Conditions 2 and 3 contain universal quantifi- cations over contexts, but the key point here is that there are only finitely many equalities and reductions which do hold since variables in partitioning contexts must be correlated and there are only finitely many ecores. An appropriate semantics for quantifiers in a first-order logic of frames allows us to express all the (infinitely many) equalities and reductions which do not hold, which is the key to deriving characteristic formulae.


Coincidence Results
The refined definition ≈'

has been derived with the intention that it should coincide

with ≈E , which indeed turns out to be the case. Because of space constraints we only state the main results and refer the reader to [11, Chapter 4] for the full proofs.
Theorem 3.10 ≈' ⊆≈E .
The proof relies on the following lemma:
Lemma 3.11 Let ϕ and ϕ' be two frames with ϕ ≈' ϕ', ecores(ϕ)= (N )j∈J and
ecores(ϕ')= (N ')j∈J. It then holds for any contexts C1[y˜] and C2[y˜] that:
C1[N˜]= C2[N˜] ⇔ C1[N˜']= C2[N˜']
C1[N˜] >r C2[N˜] ⇔ C1[N˜'] >r C2[N˜']
C1[N˜] =E C2[N˜] ⇔ C1[N˜'] =E C2[N˜']
The first result is shown by contradiction. The second result relies on partition- ing contexts: any context C[y˜] which is unifiable with the LHS of a rewrite rule gives rise to a set of partitioning contexts {C⊥[y˜]}i∈I (which we call generated par-
titioning contexts), each over an equivalence class of variables (under correlation). We then use that C[N˜] is reducible iff C⊥[N˜] is reducible for all i ∈ I. The third result uses the first two results together with the fact that, for convergent rewrite
systems, M1 =E M2 iff M1 >∗ M3 and M2 >∗ M3 for some and M3.
Theorem 3.10 now follows fairly straight forwardly from Lemma 3.11, the defi- nition of ≈E and the fact that every term which does not contain bound names can be written as a context over ecores.
Theorem 3.12 ≈E ⊆≈' .
The proof relies on the following lemma to establish a relationship between contexts over ecores and contexts over frame terms:

Lemma 3.13 Let ϕ = (νn˜){ Mi/x }	, ϕ' = (νn˜'){ M '/x }	with ϕ ≈
ϕ'. Then

i  i∈I	i  i  i∈I	E
for each Mi|w ∈ A(Mi, ϕ) and M '|w ∈ A(M ', ϕ') there is a context Y[x˜], called an
i	i
analysis recipe, and a k ∈ N such that
Y[M˜ ] >k Mi|w /> Y[M˜ '] >k M '|w />

The lemma is shown by construction, i.e. an inductive definition of analysis recipes is given and shown to have the desired property. The argument relies on the assumption that theories are reduction observable, which immediately gives that a term can reduce in exactly the same number of steps in statically equivalent frames. Lemma 3.13 can then be used in the proof of Theorem 3.12 to show that
≈E implies condition 3 of ≈' : if we suppose that ϕ ≈E ϕ' and C⊥[N˜] >r C⊥[N˜],
E	1	2

then C⊥[Y[˜M˜]] >l C⊥[N˜] >r C⊥[N˜] for some l, and also C⊥[Y ˜˜'
l	⊥ ˜'

1	1	2
1	[M ]] >
C1 [N ].

Reduction observability then gives that C⊥[N˜'] must be reducible. The assumption
that C⊥[y˜] is partitioning, that C⊥[y˜] N or C⊥[y˜] , and that rewrite systems are
1	1	1
independent, then gives us that this last reduction must be primitive, i.e. C⊥[N˜'] >r
C⊥[N˜'] as desired. Condition 2 is shown using similar ideas.
The last result tells us when the assumption of reduction observable theories is redundant:
Theorem 3.14 If ecores(ϕ)= cores(ϕ) then ϕ ≈E ϕ' e ϕ ≈E+ ϕ'.
One direction of the proof is of course immediate. For the other direction we use that when ecores(ϕ) = cores(ϕ), any analysis term which is not a core can be written as a non-trivial context (i.e. a context which is not a variable) over ecores. This, together with confluence, can be used to “force” reductions in a statically equivalent frame using only equality. To see how this works, consider the

symmetric-key counterparts of ϕ2 and ϕ'
from Subsection 2.4:



ϕ	Δ	enc(b,k)	k	'	Δ
enc (b,k)	c

3  =  (νk, b, c){
/x1 ,
/x2 }	ϕ3
=  (νk, b, c){
/x1 ,
/x2 }



We again have that ϕ3 /≈ES+ ϕ'
because test dec(x1, x2) > ok holds in ϕ3 but not

in ϕ' . But suddenly we also have that ϕ3 /≈ES ϕ'
because the following equality

3	3
can be used to express that the above reduction holds in ϕ3 but not in ϕ' :

x1 =E enc(dec(x1, x2), x2)

This equality is possible exactly because enc(b, k) can be written as a non-trivial context over the ecores b and k, which in general means that ecores and cores coincide. In contrast, this is not possible for the term enc(b, k+) in the public-key version because k+ is not an ecore.

A Logic of Frames
In this section we introduce the first-order logic for frames, LF, which characterizes static equivalence and yields characteristic formulae.
Syntax
The syntax for LF is defined as follows, where the Mi range over terms and x ranges over variables:
A ::=M1 =E M2 | M1 > M2 | M1 = M2 | A1 ∨ A2 | ¬A1 | (A1) | ∃x(A1)
The full set of logical connectives is defined from ¬,∨ and ∃ in the usual way.
Semantics
Common for all three atomic propositions is the requirement that terms being tested do not contain private names since formulae should not be able to distinguish frames
based on private names. Hence the satisfaction relation ▶ for the propositional logic is defined as follows:
ϕ ▶ M1 =E M2	if n(M1, M2) ∩ bn(ϕ)= ∅ and M1ϕ =E M2ϕ ϕ ▶ M1 > M2	if n(M1, M2) ∩ bn(ϕ)= ∅ and M1ϕ > M2ϕ ϕ ▶ M1 = M2	if n(M1, M2) ∩ bn(ϕ)= ∅ and M1ϕ = M2ϕ ϕ ▶ A1 ∨ A2	if ϕ ▶ A1 or ϕ ▶ A2
ϕ ▶ ¬A	if ϕ /▶ A
Quantification should allow reasoning about the knowledge represented by a frame, which we define formally as the synthesis S(ϕ) (a generalisation of the corresponding notion of synthesis introduced by Paulson in [10]):
Definition 4.1
S	Δ	˜	˜
The definition of satisfaction can now be completed with the case for existentially quantified formulae:
ϕ ▶ ∃x(A1)	if	ϕ{ M/x} ▶ A1 for some term M ∈ S(ϕ)
Observe how bindings of quantified variables are represented in a natural way by extending the frame with an additional substitution. In cases where x ∈ dom(ϕ) we assume alpha-conversion of x to some x' /∈ dom(ϕ), since otherwise a quantification may overwrite existing terms in ϕ.
Example 4.2 Consider the frames


ϕ4	Δ
enc(b,k+) x
[c,k] x	'	Δ
enc(enc(b,k+),k+) x
[c,k] x

=  (νk, b){
/ 1 ,
/ 2 }	ϕ4 = (νk, b){
/ 1 ,
/ 2 }

The formula ∃y1∃y2(dec(x1, y1) > y2 ∧ ¬∃y3∃y4(dec(y2, y3) > y4)) then expresses that x1 can be decrypted using some known key and that the resulting term cannot be further decrypted. This property holds for ϕ4 but not for ϕ' .

Results
The first major result says that LF characterizes static equivalence.


Theorem 4.3 (LF characterizes ≈' ) Let ThLF
(ϕ)
Δ	{A ∈ LF | ϕ ▶ A}. It

then holds that ϕ ≈' ϕ' e ThLF (ϕ)= ThLF(ϕ').
The proof is by induction on the structure of formulae, and the induction case for existential quantification relies on the following lemma:
Lemma 4.4 (Extension Lemma) Let	ϕ	=	(νn˜){ Mi/xi}i∈I	and	ϕ'	=

(νn˜){ M '/x }	be two frames with ϕ ≈'
ϕ', and let ecores(ϕ) = (N )
and

i  i  i∈I	E
j∈J

ecores(ϕ') = (N ')j∈J . Then for any C[y˜] it holds that ϕ{ C[N˜]/x } ≈'
ϕ'{ C[N˜']/x }

(where s is any index with s /∈ I).
s	E	s

The second major result asserts the existence of characteristic formulae.
Theorem 4.5 (Characteristic formulae) For any frame ϕ there is a ﬁnite char- acteristic formula Cϕ such that for any frame ϕ' with dom(ϕ) = dom(ϕ') it holds
that ϕ ≈' ϕ' e ϕ' ▶ Cϕ.
The remaining of this subsection is devoted to a construction of the characteristic formula Cϕ for a frame ϕ = (νn˜){ Mi/xi}i∈I . Again we refer the reader to [11] for the proof that this construction does indeed work. Cϕ is of the following form:
Cϕ = ∃y1 ... ∃yk(
ψecore−1(y1) ∧ ··· ∧ ψecore−k(yk)∧ ψcond−1∧
ψcond−2a ∧ ψcond−2b ∧ ψcond−2c ψcond−3a ∧ ψcond−3b ∧ ψcond−3c)
Each ecore is represented by one of the existentially quantified variables yi and the

formulae ψecore−i(yi) state that yi is in fact an ecore. Conditions 1 − 3 of ≈'
are

then encoded in the remaining conjuncts which we elaborate below.
First note that there are infinitely many contexts over ecores in condition 3 of
' for which reductions do not hold. For example, to express that the ecores bound
to y1 and y2 are not related public/private key pairs, a characteristic formula should assert that
dec(enc(⊥, y1), y2) />, dec(enc(⊥, y1+), y2) />, dec(enc(⊥, h(y1)+), y2) />,... 
which would give rise to infinite conjunction. Instead we just choose the first of the

contexts and use existential quantification to express that
¬∃z∗.dec(enc(⊥, z∗), y2) >

in cases where y2 is not the private-key counterpart of any other synthesis term (this works because existential quantification ranges over the synthesis of a frame and any synthesis term can be written as a context over ecores). In cases where y2 is the private-key counterpart of some other synthesis term distinct from y1, we automatically get that y2 is not also the private-key counterpart of y1. The generalisation of this argument relies on the context in question being partitioning and hence z∗  y2. The above context of choice is what we refer to as a minimised context :
Definition 4.6 A minimised context C[y˜, z˜∗] is any partitioning context with

C[y˜, z˜∗] N. Each y ∈
y˜ is intended to represent an ecore while each z∗ ∈
z˜∗ is

intended to represent an arbitrary synthesis term.
Note that there are only finitely many minimised contexts which is crucial for the following construction of finite characteristic formulae.

Encoding Ecores
First we encode revelation thus:


M >	Δ
∃z∗ ... ∃z∗(D[M, z∗,... , z∗] > T )

T	=
D[y,z∗,...,z∗]
1	s	1	s

1	s
is a minimised destructor context
Let Yj[x˜] be the analysis recipe for each Nj and let kj ∈ N be such that Yj[M˜ ] >kj Nj. The ecore predicate is then encoded as follows:


ψecore−j	j	Δ	1	k	j
1	2	3
k −1	j

(y )
= ∃z
... ∃z j (Y [x˜] > z ∧ z
> z ∧ ··· ∧ z j
> y )∧

[¬∃zkj (yj > zkj )∨

 

f (z1,...,zs)∈Σ(s)
∀z1,... , zs¬(yj = f (z1,... , zs))]


Encoding Condition 1
Each Mi can be written as a context over ecores – let Ci[y˜] be any such context.

Condition 1 in ≈'
is then expressed in the following formulae:



ψcond−1  =Δ
  xi = Ci[y˜]
i∈I

Encoding Condition 2
The encodings rely on the following sets:


£2a
=Δ {(i, j) | Ni = Nj}
£¯2a =Δ
{(i, j) | Ni /= Nj}

£2b
=Δ {(C[y˜], j) | C[N˜]= Nj}

£2c	Δ	˜	j



ψcond−2a


ψcond−2b
=Δ	 
(i,j)∈S2a
=Δ	 
yi = yj Λ	 
(i,j)∈S¯2a
C[y˜]= yj
yi /= yj

(C[y˜],j)∈S2b

ψcond−2c	Δ
6z1 ... 6zk(чf (z1,... , zk)= yj)

j∈S2c f (z1,...,zk)∈Σk


Encoding Condition 3
The encodings rely on the following sets:


£3a	Δ	⊥	⊥	1
⊥ ˜	⊥ ˜	⊥ ˜

= {(C1 [y˜], C2 [y˜]) | C
[y˜] is partitioning Λ C1 [N ] N ΛC1 [N ] > C2 [N ]}

£¯	Δ	⊥	⊥
⊥ ˜	⊥ ˜	⊥ ˜

3a = {(C1 [y˜], C2 [y˜]) | C1[y˜] is partitioning Λ C1 [N ] N ΛC1 [N ] /> C2 [N ]}

£3b	Δ	⊥	⊥	1
⊥ ˜	⊥ ˜	⊥ ˜

= {(C1 [y˜], C2 [y˜]) | C
[y˜] is partitioning Λ C1 [N ]  Λ C1 [N ] > C2 [N ]}

£3c
=Δ {C⊥[y˜, z1,... , zs] | C⊥[y˜, z∗,... , z∗] is a minimised context and

1	1	1	s
чЕT1,... , Ts ∈ £(ϕ).C1[N˜, Ts,... , Ts] >}

ψcond−3a	Δ
C⊥[y˜] > C⊥[y˜] Λ	 
чC⊥[y˜] > C⊥[y˜]

=	1
(C⊥[y˜],C⊥[y˜])∈S3a
2	1	2
(C⊥[y˜],C⊥[y˜])∈S¯3a

ψcond−3b	Δ	 
1	2
C⊥[y˜] > C⊥[y˜]

=	1	2
(C⊥[y˜],C⊥[y˜])∈S3b

ψcond−3c	Δ	 
6z∗ ... 6z∗6z(чC⊥[y˜, z∗,... , z∗] > z)

=	1	s
C⊥[y˜,z∗,...,z∗]∈S3c
1	1	s

1	1	s
A Logic for Applied π
In this section we show how the frames logic can be extended to a logic for Applied π by adding suitable modalities. We start by briefly recapping Applied π and refer readers unfamiliar with the calculus to [3] for detailed information.

The Applied π Calculus
The syntax for Applied π is divided into two categories: plain and extended pro- cesses. Plain processes are similar to those of the π calculus except that arbitrary terms may be used in conditionals and in output (recall that u ranges over names and variables):
Pp, Qp ::= 0 | Pp|Qp |!P p | (νn)Pp | if M1 = M2 then Pp else Qp | u(x).P p | u⟨M ⟩.P p

Extended processes add the notion of active substitutions which intuitively capture the knowledge of an environment in the process syntax itself:
P, Q, R ::= Pp | P |Q | (νn)P | (νv)P | { M/x}

This notion of environment-sensitivity dates back to the semantics for the π-calculus given in [5] and the later semantics for a spi-calculus given in [6]. Here, though, environments were not considered part of the process syntax.
For the logic that follows, we shall refer to the labelled transition semantics of Applied π. We here give an example in place of the formal definition (for this, see [3]).
Example 5.1 The following example in the symmetric key theory E S shows a transition sequence for a process P which outputs a secret name s encrypted by k, then “accidentally” outputs k, then inputs some term bound to y and checks if it equals s.

P	= (νs, k)a⟨enc(s, k)⟩.a⟨k⟩.a(y).if y = s then Q else R

(νx1)a⟨x1⟩
−−−−−−→ (νs, k)({
enc(s,k)/x1 }|a⟨k⟩.a(y).if y = s then Q else R

(νx2)a⟨x2⟩
−−−−−−→ (νs, k)({
a(dec(x1,x2))
enc(s,k)/x1 }|{ enc(c,k)
k/x2 }|a(y).if y = s then Q else R
k

−−−−−−−−→ (νc, k)({
/x1 }|{
/x2 }|if dec(x1, x2)= s then Q else R)

−→τ
(νc, k)({ enc(c,k)/x1 }|{ k/x2 }|Q)

The two outputs give rise to bound output transitions and new active substitutions representing the terms which have been output. An arbitrary term built from vari- ables in the active substitutions is then sent as a labelled input by the environment; the active substitutions are applied to free variables in the conditional process, and an internal reduction is carried out by testing for equality in the equational theory E S.
The frame ϕ(P ) of a process P is obtained by “merging” all active substitutions in P while preserving restrictions, normalising terms and renaming if necessary. In the above example we have that ϕ(P )= (νc, k){ enc(c,k)/x1 , k/x2 }.

Syntax for The Process Logic
A logic LA for Applied π is obtained by adding modalities to the frames logic thus:
A ::=M1 =E M2 | M1 > M2 | M1 = M2 | Ex(A) | чA | A1 ∨ A2
|⟨τ ⟩A | ⟨a¯u⟩A | ⟨νa¯u⟩A | ⟨a(x)⟩A

Informally, the modalities express respectively possibility of internal action, possi- bility of output of u on a, possibility of output of bound u on a and possibility of input of x on a. These correspond to each the four possible labels featuring in the labelled semantics for Applied π. The dual modalities (i.e. necessity) can be defined in the usual way.

Semantics for The Process Logic
Let ▶LF be the satisfaction relation for the frames logic LF defined in Section 4. The satisfaction relation for the process logic LA can then be defined as follows
(where −→τ ∗ is the reflexive and transitive closure of −→τ ):
P ▶ M1 =E M2	if ϕ(P ) ▶LF M1 =E M2 P ▶ M1 = M2	if ϕ(P ) ▶LF M1 = M2 P ▶ M1 > M2	if ϕ(P ) ▶LF M1 > M2
P ▶ Ex(A)	if there exists M ∈ £(ϕ(P )) s.t. (P | { M/x}) ▶ A
P ▶ чA	if P /▶ A
P ▶ A1 ∨ A2	if P ▶ A1 or P ▶ A2
P ▶ ⟨τ ⟩A	if there exists P ' s.t. P −→τ ∗ P ' and P ' ▶ A

P ▶ ⟨a¯u⟩A	if there exists P ' s.t. P τ
∗ a⟨u⟩
τ ∗ P ' and P ' ▶ A

−→
P ▶ ⟨νa¯u⟩A	if there exists P ' s.t. P τ
−−→−→
∗ (νu)a⟨u⟩

τ ∗ P ' and P ' ▶ A

P ▶ ⟨a(x)⟩A	if there exists M, P ' s.t. P τ
∗ a(M )
τ ∗ P ' and P ' ▶ A{ M/ }

−→ −−−→−→	x


Example 5.2 The process logic can be used to reason about knowledge over time. Consider the formula A1 = ⟨νa¯x1⟩⟨νa¯x2⟩Ey1Ey2(dec(x1, y1) > y2) in the symmetric key theory E S. A1 asserts that two messages bound to x1 and x2 can be output, after which the decryption key for the first message is known by the environment. This formula is satisfied by process P from example 5.1 above. Note that the order of modalities and quantifiers is significant. For example, P does not satisfy the formula A2 = Ey1⟨νa¯x1⟩⟨νa¯x2⟩Ey2(dec(x1, y1) > y2) because the decryption key is not known by the environment until revealed by the second output in P . In this sense the modal logic can be used to reason about knowledge over time.
The process logic characterizes labelled bisimilarity under the assumption of image-finite processes; we refer the reader to [11] for further details.

Conclusion and Future Work
We have introduced a logic for frames which characterizes static equivalence and yields characteristic formulae under the assumptions that the theory under consider- ation is 1) reduction observable, 2) a convergent subterm theory and 3) independent. In addition we have shown when assumption 1 is unnecessary; this is e.g. the case for symmetric key theories, but not for public key theories. The characterisation results rely on a refined version of static equivalence defined without recourse to quantification over arbitrary terms. Finally, we briefly indicated how the logic for frames extends to a modal logic for Applied π. The resulting logic has been used to describe a well known attack on a security protocol in [11].
An interesting future direction would be to investigate if the restriction to con- vergent subterm theories can be lifted. A decision procedure for satisfaction in the frame logic would be of practical use in tools; the fact that synthesis membership is decidable for convergent subterm theories [1] raises hope that such a decision procedure does indeed exist. Finally, it may be worthwhile to investigate the com- plexity of deciding static equivalence using the refined definition in order to match or improve on the polynomial time bound given in [1].

Acknowledgements
The authors would like to thank the anynomous reviewers for their useful comments.

References
Mart´ın Abadi and V´eronique Cortier. Deciding knowledge in security protocols under equational theories. Proc. 31st Int. Coll. Automata, Languages, and Programming (ICALP’2004), Lecture Notes in Computer Science 3142 (2004), 46–58.
Mart´ın Abadi and V´eronique Cortier. Deciding knowledge in security protocols under (many more) equational theories. CSFW ’05: Proceedings of the 18th IEEE Computer Security Foundations Workshop (CSFW’05), IEEE Computer Society (2005), 62–76.
Mart´ın Abadi and Cedric Fournet. Mobile values, new names, and secure communication. POPL ’01: Proceedings of the 28th ACM SIGPLAN-SIGACT symposium on Principles of programming languages,
ACM Press (2005) 104–115
Mart´ın Abadi and Andrew D. Gordon. A calculus for cryptographic protocols: The Spi calculus. Fourth ACM Conference on Computer and Communications Security, ACM Press (1997), 36–47.
M. Boreale and D. Sangiorgi. Bisimulation in Name-Passing Calculi without Matching Proc. of 13th IEEE Symposium on Logic in Computer Science (LICS ’98), IEEE Computer Society Press, 1998.
Michele Boreale, Rocco De Nicola, and Rosario Pugliese. Proof techniques for cryptographic processes.
SIAM J. Comput. 31(3) (2001), 947–986.
Johannes Borgstr¨om. Static equivalence is harder than knowledge. Electr. Notes Theor. Comput. Sci.,
154(3) (2006), 45–57.
Ulrik Frendrup, Hans Hu¨ttel, and Jesper Nyholm Jensen Modal logics for cryptographic processes.
Electr. Netes Theor. Comput. Sci. (1997), 36–47.
R. Milner, J. Parrow, and D. Walker. Modal logics for mobile processes. Theoretical Computer Science
114(1) (1993), 149–171.


Lawrence C. Paulson. The inductive approach to verifying cryptographic protocols. Journal of Computer Security 6 (1998), 85–128.
Michael D. Pedersen.  “Logics for the Applied Pi calculus.”  Master’s thesis, Department of Computer Science, Aalborg University (2006). BRICS Research Report RS-19-06, http://www.brics.dk/RS/06/19/ .
OpenSSL: The open source toolkit for SSL/TLS. http://www.openssl.org/ .
