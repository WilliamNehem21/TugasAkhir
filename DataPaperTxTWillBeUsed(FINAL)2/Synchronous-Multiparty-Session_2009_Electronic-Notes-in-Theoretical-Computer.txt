

Electronic Notes in Theoretical Computer Science 241 (2009) 3–33
www.elsevier.com/locate/entcs

Synchronous Multiparty Session Types
Andi Bejleri1	Nobuko Yoshida2
Imperial College London

Abstract
Synchronous communication is useful to model multiparty sessions where control for timing events and strong sequentially order of messages are essential to the problem specification. This paper continues the work on multiparty session types initiated by Honda et al. [10] for synchronous communications. It provides a more relaxed syntax of the calculus, multicasting, higher-order communication via multipolarity labels and a clear definition of delegation in global types. The linearity property defines when a channel can be used in two different communications without creating a race condition and the type system checks if all the processes of a session implement the communication behavior specified in the global type. The type system of the calculus is proved to be sound with respect to the operational semantics and coherent with respect to the global types.
Key words: Synchronous Communications, Multipolarity Labels, Multicasting, Delegation, Linearity, Sub- ject Reduction Theorem


Introduction
Multiparty session types for a calculus of asynchronous communication have re- cently been introduced by Honda et al. [10] and Bonelli-Compagnoni [1]. The idea of multiparty session types in the first work is based on the choreography metaphor to describe interactions between processes: interactions are described as a global scenario. Whilst, the second work is based on the orchestration metaphor: interac- tions between processes are described as a centralised scenario between one master process and many slave processes. The system introduced in this paper follows the metaphor of the first work.
Controlling the timing of events becomes important in multiparty sessions: for example, in a fire alarm system of a building, we expect that all fire alarms run before that elevators become blocked. This scenario would be modeled by a control process that sends in multicast an ON message to fire alarms and after that a BLOCK message to elevators. The timing of events in the example can be obtained

1 Email: ab406@doc.ic.ac.uk
2 Email: yoshida@doc.ic.ac.uk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.002

by modeling the session using synchronous communications; the second multicast send will happen only after the first message is received by the multicast group of fire alarms.
Binary session types [16,9] on their own are not rich enough to express depen- dencies between different interactions in a multiparty session. A notion of global type is therefore introduced in [10] to formalise the global behaviour of a multi- party session. The example below illustrates the key ideas of multiparty sessions, dependencies between interactions and global description. In a Client-Addition- Successor-Predecessor session, the communication protocol (conversation) is de- fined as: Client sends two natural numbers to Addition and waits to receive from him the sum of them. If the second operand is equal to 0 then Addition sends to Client the first operand as result, otherwise it sends the first operand to Successor and receives from him its successor; after that it sends the second operand to Predecessor and receives from him its predecessor; this behaviour is repeated until the second operand is equal to 0. The global description of the communication protocol in a name-arrow based representation is:
Client → Addition: ⟨int⟩.
Client → Addition: ⟨int⟩.
μt.Addition → {Successor, Predecessor}: {
true : Addition → Client: ⟨int⟩.end, f alse : Addition → Successor: ⟨int⟩.
Successor → Addition: ⟨int⟩. Addition → Predecessor: ⟨int⟩. Predecessor → Addition: ⟨int⟩.t}
where A → {B, C}: ⟨U ⟩ means that participant A sends simultaneously a message of type U to participant B and C, and A → {B, C}: {l1 : ··· , ..., lj : ··· } means that participant A sends simultaneously a label li where i ∈ {1, ..., j} to participant B and C. We have omitted channels from the example for simplicity.
In binary sessions, the Client-Addition-Successor-Predecessor conversation is represented by three sessions: Client-Addition1, Successor-Addition2 and Predecessor-Addition3. The interactive structure of each participant is:
Client = !⟨int⟩; !⟨int⟩; ?⟨int⟩; end
Addition1 = ?⟨int⟩; ?⟨int⟩; !⟨int⟩; end
Successor = μt.&{true : end,f alse :?⟨int⟩; !⟨int⟩; t}
Addition2 = μt. ⊕ {true : end,f alse :!⟨int⟩; ?⟨int⟩; t}
Predecessor = μt.&{true : end,f alse :?⟨int⟩; !⟨int⟩; t}
Addition3 = μt. ⊕ {true : end,f alse :!⟨int⟩; ?⟨int⟩; t}

where !⟨U ⟩ denotes an output of type U , ?⟨U ⟩ denotes an input of type U , ⊕{l1 : ··· ,
..., lj : ··· } denotes a choice of a label and &{l1 : ··· , ..., lj : ··· } denotes branch- ing on a set of labels. Processes that implement these interaction structures are well-typed by a binary session type system as the interactive structures between Client-Addition1, Successor-Addition2 and Predecessor-Addition3 are recip- rocal to each other. However, the binary session representation of the conversa- tion breaks the order of messages because in the case when the second operand is not 0, Addition should add the second operand to the first one before return- ing it to Client and this dependency between the sessions Client-Addition1 and Addition2,3-Successor-Predecessor can not be captured by binary session types. In multiparty sessions types, the conversation is represented by the global de- scription given above and as a consequence the interactive structure of Addition
is:
?⟨int⟩; ?⟨int⟩; μt. ⊕ {true :!⟨int⟩; end,f alse :!⟨int⟩; ?⟨int⟩; !⟨int⟩; ?⟨int⟩; t}.
and of the other participant Client, Successor and Predecessor is the same to binary session types. Addition is represented now by only one interactive structure. Hence, the use of global types allows a more complete and intelligible definition of communication protocols in multiparty sessions.
In the global type definition, a programmer does not specify only the com- munications of a protocol but also the channels where the communications take place. This is an important feature in multiparty session types since global types are not a simple human interpretable descriptive language; global types together with the projection algorithm and type-system represent a type-checking tool for communication-based processes.
In synchronous communication calculi, the runtime sequence of interactions fol- lows more strictly the sequence of global types than in the asynchronous communi- cation calculus with queue [10], resulting in a simpler typing system of the global behaviour. Consider a global type:
A → B: m1⟨U ⟩.A → C: m2⟨U '⟩.end	(1)
where m1 and m2 are abstraction of channels. This ordering means “only after the first sending and receiving take place, the second sending and receiving take place” and it is modeled for calculi of synchronous communication but not for asynchronous ones; e.g. in the asynchronous calculus [10] C may receive its message before B.
A race condition problem is introduced if different interactions use the same channel. That is, two senders are sending two different messages on the same channel and two receivers are trying to receive at the same time a message on that same channel. Even though, there is no communication error, as for each send corresponds one receive and vice versa, the ambiguity introduced on which of the two receivers will the message be delivered may break the causalities. Unfortunately, global types alone do not guarantee from a possible race condition problem.
A linearity property defines when the use of a same channel in two different communications of a global type does not break the causalities of it. A precise

analysis of ordering two communications without breaking their causalities is used to define a partial order between two non consecutive communications. The existence of this partial order defines if the causalities between the two communications break or not.
Finally, each process is type-checked with the type obtained by projecting the global type on each participant. The type system analyses a set of initialization processes, i.e. processes that are willing/waiting to initiate a session, via a bottom- up strategy.
Contributions. This paragraph summarizes the main technical contributions of this paper.
Synchronous Communications. Synchronous communications are useful to model multiparty sessions where control for timing events and strong sequentially order of messages are essential to the problem specification. The runtime sequence of interactions follows more strictly the one of the global behaviour description than the asynchronous communication calculus with queue [10], resulting in a simpler linear property.
A Simpler Calculus. The syntax of the calculus is more relaxed than the one introduced by Honda et al. [10]. We do not distinguish syntactically between a primitive value send and a session channel send following the idea firstly proposed in [8]. The syntax of the calculus does not introduce queues, neither at the programmer code level nor at the runtime code level, in contrast to [10].
Multicasting. The calculus supports the delivery of messages to a group of peers simultaneously. Multicast increases the expressivity of communication behaviors in this calculus, mainly due to the restriction introduced by projection on parallel composition and branching. That is, the global type A → B : m1⟨U ⟩, A → C : m2⟨U ⟩, where the two interactions can take place in parallel, is not well-formed due to the definition of projection but we can model this behaviour if the values sent are the same, using multicast as A → {B, C} : {m1, m2}⟨U ⟩. Also, the global type A → B : m1{l1 : B → A : m2⟨U ⟩, l2 : C → A : m2⟨U '⟩} is not well-formed due to projection but we can model the branching behaviour by using multicast on labels as A → {B, C} : {m1, m3}{l1 : B → A : m2⟨U ⟩, l2 : C → A : m2⟨U '⟩}.
Higher Order Communication. High-order communication is defined as k!⟨k'⟩| k?⟨k'⟩ in the first systems [9,10], where the receiver posseses the transmitted chan- nel (k') before the communication takes place. The calculus of this paper models the transmission of channels with the receiver not possessing the channel until the communication happens. This feature is modeled safely by adding multipolarity labels to session channels as in [8,19].
Delegation. Higher-order communication models the capability of a process to delegate its session participation to another one. Global types define the inter- actions only between the participants of a session. In the asynchronous multi- party calculus, the global types of the Alice-Bob-Carol example (Section 4.4)[10] Ga = A → B: t1⟨s1!⟨int⟩; end@B⟩.end and Gb = B → C: s1!⟨int⟩.end do not satisfy the said definition. The session at b is started between A and C, and the global

type Gb should define the interaction between these two participant, A → C, and not between the participants that may be involved to send the message due to delegation at runtime, B → C. This inconsistency of information between Gb and the implementation of session initiated on b makes process Alice not type-checked even though it is correct. Following the above definition, the sequent global types Ga = A → B: t1⟨s1!⟨int⟩; end@A⟩ and Gb = A → C: s1!⟨int⟩.end type-check all three processes.

Organization. In the remainder of this paper, Section 2 defines the syntax and operational semantics of the calculus. Section 3 defines the syntax of global types and introduces the linearity property. Section 4 gives the programming methodol- ogy, syntax of local types, projection algorithm and type system. Section 5 con- cludes by comparing the system with related works and gives possible future work. Appendixes A gives the full proofs of the theorems presented in the paper.

A Synchronous Multiparty-Session Calculus
The syntax and the operational semantics of the multiparty-session synchronous calculus are basically the ones of binary session calculus [9] extended with construct and operational semantic rule for session initiation and multicasting. Throughout the paper we will refer to the calculus as the MS-calculus.

Syntax
The syntax of the MS-calculus is a more relaxed version of the one introduced by Honda et al. [9]. The calculus does not distinguish between a primitive value send and a session channel send following the idea firstly proposed in [8]. The syntax of the calculus does not introduce queues, neither at the programmer code level nor at the runtime code level. The multiparty-session request is represented in the same way as in the asynchronous calculus. The MS-calculus supports higher-order communications by introducing multipolarity labels [19,8] to session channels and multicasting by sending messages to a group of peers simultaneously.
The next part of this section will introduce some of the definitions and notations used in the formal definition of the calculus.
Definition 2.1 a, b, c, ... represent shared names; e, e’, ... represent expressions; l, l1, l2, ... refer to labels; p, q, n, r, ... range over naturals; i, j, ... denote indexes over a set of naturals; κp, ... refer to session channels; x, y, z, ... refer to variables of the calculus; X, Y, ... refer to process variables and P, P1, P2, ...Q, ... refer to processes.
Notation 2.2 The notation k˜ denotes a list of channels k1, ..., kn.
Figure 1 introduces the abstract grammar of the calculus syntax. The terms of the calculus represent a range of processes from simple inactive one to processes that implement complex communication behaviours. The paragraphs below will


P ::= a[2..n] (x˜).P	multicast session request
| a[p] (x˜).P	session acceptance
| k˜!⟨e˜⟩; P	value sending
| k?(x˜); P	value reception
| k˜  l; P	label selection
| k D {li : Pi}i∈I	label branching
| if e then P else Q	conditional branch
| P | Q	parallel composition
| 0	inaction
| (νn)P	hiding
| def D in P	recursion
| X⟨e˜⟩	process call
e ::= x | v | e and e' |  not e	...	expressions
v ::= a | true | false | k	values
k ::= x | κp	session channels variables and values
p ::= 1 | ... | n	channels multipolarity
D ::= X1(y˜1)= P1 and ··· and Xn(y˜n)= Pn	declaration for recursion

Fig. 1. Syntax

give an informal description of the constructs introduced in the figure.
A session is established among peers via shared names, which represent public points of communication. In the calculus a session initiation would be
a[2, 3](y1, y2, y3).P1 | a[2](y1, y2, y3).P2 | a[3](y1, y2, y3).P3
where a represents the shared name. The process with over-lined a represents the process willing to initiate a session with participant numbered two and three and the others represent processes waiting to initiate a session. The set of bound variables
{y1, y2, y3} represent placeholders for session channels which will be generated at runtime.
Sending of values is defined by the channel (channels in case of multicasting) and the values to send; receiving of values is defined by the channel and the placeholders of the values to receive; selecting a label is defined by the channel (channels in case of multicasting) and the label to send; branching labels is defined by the channel and the set of labels which contains the label to receive.
The conditional branch and parallel composition have the same definition as in other process calculi. 0 represents the process that cannot do any action (inaction). The hiding operation on n has the standard definition of restricting or generating new session channels (κp) or shared names (a). The recursion and process call constructs define recursion in the calculus; the recursion construct defines terms with a recursive behaviour and the process call construct invokes that behaviour.

The values sent among peers can be session channels (κp) and other primitive values as booleans, strings, natural, etc.
The association of ”|” is the weakest over all operators (ν, def D in P ). Below, we define free names (fn) and free process variables (fpv) on MS-terms:
fn(a[2..n] (x˜).P )  {a}	fn(P )
fn(a[p] (x˜).P )	 {a}	fn(P )
fn((νn)P )	  fn(P ) \ {n} fpv(def D in P )  fpv(P )\dpv(D) fpv(X⟨e˜⟩)	  {X}
where dpv(D) represents the set of process variables {Xi}i∈I introduced in X1(y˜1)= 
P1 and ··· and Xn(y˜n)= Pn.
Operational Semantics
The two communication-based operations on session channels are value sending- receiving and label selection-branching. Multicast session request-acceptance rep- resents a communication idiom that is used only at session initiation.
Structural congruence ≡ is the smallest congruence on processes that satisfies the axioms showed in Figure 2.

P | 0 ≡ P	P | Q ≡ Q | P		(P | Q) | R ≡ P | (Q | R) (νn)P | Q ≡ (νn)(P | Q)	if n /∈ fn(Q)
(νnn')P ≡ (νn'n)P	(νn)0 ≡ 0	def D in 0 ≡ 0
def D in (νn)P ≡ (νn)def D in P	if n /∈ fn(D)
(def D in P ) | Q ≡ def D in (P | Q)	if dpv(D) ∩ fpv(Q)= ∅
def D in (def D' in P ) ≡ def D and D' in P	if dpv(D) ∩ dpv(D')= ∅

Fig. 2. Structural congruence.
The operational semantics of the calculus is given via the reduction relation → where the state of the machine is defined by only MS-terms. Figure 3 defines the rules of a small step operational semantics of the calculus. The paragraphs below give a description of the rules.

Notation 2.3 κ[m1, ..., mr]p denotes κm1 p, ..., κmr p.
[Link] initiates a session between n peers. The result of the reduction is generation of session channels and substitution of them in processes. Note that session channels for each process are labeled by a multipolarity index ranging [1, ..., n], where n is the number of participants involved in a session. The calculus uses multipolarity

session channels to support higher-order communications safely (see Section 2.4). An example of session initiation reduction is:
a[2, 3](y1, y2, y3).y1!⟨5⟩; P1 | a[2](y1, y2, y3).y1?(y4); P2 | a[3](y1, y2, y3).y2!⟨”blue”⟩; P3
→  (νκ1, κ2, κ3)(κ11!⟨5⟩; P1[κ11, κ21, κ31/y1, y2, y3] |
κ12?(y4); P2[κ12, κ22, κ32/y1, y2, y3] | κ23!⟨”blue”⟩; P3[κ13, κ23, κ33/y1, y2, y3]).
[Multicasting] actions the value sending-receiving communication between two and more peers. The result of the communication is the substitution of the place holders with the received values by the receivers. Note that the reduction holds if the channels are the same in both peers despite the polarity is different. The relation ↓ evaluates the expression e to the value v and the value v to itself. An example of value communication is:
κ11!⟨5⟩; P ' | κ12?(y4); P ' → P ' | P2[5/y4].
1	2	1
[MultiLabel] actions the selection-branching communication between two and more participants. The selection process sends the label l i to the branching pro- cesses and the result of the communication is the resting part of the label selection process (P 1) in parallel with the process labeled by l i (P [2..k]i).
[If1] and [If2] action the evaluation of e; if e evaluates to true then rule [If1] is applied otherwise rule [If2].
[Def] invokes the behaviour (P ) identified by X with values for arguments v˜ in the context.
[Scop] actions the reduction of the process inside the scope of the ν operator.
(νκ1, κ2, κ3)(κ11!⟨5⟩; P ' | κ12?(y4); P ' | κ23!⟨”blue”⟩; P ')
1	2	3
→  (νκ1, κ2, κ3)(P ' | P '[5/y4] | κ23!⟨”blue”⟩; P ').
1	2	3
[Par] states that if one process (P ) evolves to another process (P ') then the parallel composition process (P | Q) can evolve to another parallel composition process with the evolved component process (P ' | Q); i.e.
κ11!⟨5⟩; P ' | κ12?(y4); P ' | P ' → P ' | P '[5/y4] | P '.
1	2	3	1	2	3
[Defin] states that if process P can evolve to a process P ' then the entire recursive term can evolve to a new recursive term.
[Str] states that the reduction relation is defined on structural congruent terms.

Examples
Addition Protocol. The program below implements the session between Client- Addition-Successor-Predecessor introduced in Section 1. The process addition implements the communication pattern of adding two natural numbers; successor and predecessor processes implement the communication pattern of receiving a num- ber and sending its successor and predecessor, respectively.

client   a[2, 3, 4] (x1, x2, x3).x1!⟨5⟩; x1!⟨4⟩; x1?(y1); 0
addition   def X1⟨y1, y2, x1, x2, x3⟩ =


a[2..n] (y˜).P1 | a[2] (y˜).P2 | ··· | a[n] (y˜).Pn →  (νκ˜)(P1[κ˜1/y˜] | P2[κ˜2/y˜] | ... | Pn[κ˜n/y˜])
[Link]
κ[m1, ..., mr]p1 !⟨e˜⟩; P1 | κ[m1]p2 ?(y˜); P2 | ··· | κ[mr]pr+1 ?(y˜); Pr+1

→  P1 | P2[v˜/y˜] | ··· | Pr+1[v˜/y˜]	(p1 /= p2 /= ··· =/
pr+1, e˜ ↓ v˜)
[Multicasting]

κ[m1, ..., mr]p1  li; P1 | κ[m1]p2 D {lj : P2j}j∈I | ··· | κ[mr]pr+1 D {lj : Pr+1j }j∈I

→  P1 | P2i | ··· | Pr+1i	(p1 /= p2 /= ··· =/
pr+1,i ∈ I)
[MultiLabel]


def D in (X⟨e˜⟩| Q) →	def D in (P [v˜/y˜] | Q)	(e˜ ↓ v˜, X(y˜)= P ∈ D)
[Def]
P → P '  ⇒  (νn)P → (νn)P '	[Scop]
P → P ' ⇒ P | Q → P ' | Q		[Par] P → P ' ⇒ def D in P → def D in P '	[Defin] P ≡ P ' and P ' → Q' and Q' ≡ Q  ⇒ P  → Q		 [Str]

Fig. 3. Operational Semantics





if (y2 = 0) then x2, x3  true; x1!⟨y1⟩; P
else x2, x3  f alse; x2!⟨y1⟩; x2?(y1); x3!⟨y2⟩; x3?(y2);
X1⟨y1, y2, x1, x2, x3⟩
in a[2] (x1, x2, x3).x1?(y1); x1?(y2); X1⟨y1, y2, x1, x2, x3⟩
successor  def X2⟨x2⟩ = x2 D {true : 0,false : x2?(y1); x2!⟨y1 + 1⟩; X2⟨x2⟩}
in a[3] (x1, x2, x3).X2⟨x2⟩
predecessor  def X3⟨x3⟩ = x3 D {true : 0,false : x3?(y1); x2!⟨y1 − 1⟩; X3⟨x3⟩}
in a[4] (x1, x2, x3).X3⟨x3⟩
Processes successor and predecessor use two different channels to communicate with addition. One receive for the first operand (x2?(y1) in successor ) and another for the second operand (x3?(y1) in predecessor ) are both from addition. Hence there is no guarantee that the receptions are in a fixed order, even though the deliveries are ordered. Thus if we were to use x2 for both actions, the message of first operand can be received by predecessor. The problem becomes visible after the fifth step of the below reduction. Later we shall show our type discipline can detect such an error. Processes Q, R and S are equal by definition to:

Q  if (y2 = 0) then x2, x3  true; x1!⟨y1⟩; P
else x2, x3  f alse; x2!⟨y1⟩; x2?(y1); x3!⟨y2⟩; x3?(y2); X1⟨y1, y2, x1, x2, x3⟩
R  x2 D {true : 0,false : x2?(y1); x2!⟨y1 + 1⟩; X2⟨x2⟩}
S  x3 D {true : 0,false : x3?(y1); x2!⟨y1 − 1⟩; X3⟨x3⟩}
then the first reduction steps of the parallel composition of the above processes are:
client | addition | successor | predecessor → [Str],[Link]
def X1⟨y1, y2, x1, x2, x3⟩ = Q, X2⟨x2⟩ = R, X3⟨x3⟩ = S in
(νκ1, κ2, κ3) (κ11!⟨5⟩; κ11!⟨4⟩; κ11?(y1); 0
| κ12?(y1); κ12?(y2); X1⟨y1, y2, κ12, κ22, κ32⟩
| X2⟨κ23⟩
| X3⟨κ34⟩) → [Multicasting],[Multicasting]


def X1⟨y1, y2, x1, x2, x3⟩ = Q, X2⟨x2⟩ = R, X3⟨x3⟩ = S in
(νκ1, κ2, κ3) (κ11?(y1); 0
| X1⟨5, 4, κ12, κ22, κ32⟩
| X2⟨κ23⟩
| X3⟨κ34⟩) → [Def]

def X1⟨y1, y2, x1, x2, x3⟩ = Q, X2⟨x2⟩ = R, X3⟨x3⟩ = S in
(νκ1, κ2, κ3) (κ11?(y1); 0
| if (4 = 0) then κ22, κ32  true; κ12!⟨y1⟩; P
else κ22, κ32   f alse; κ22!⟨5⟩; κ22?(y1); κ32!⟨4⟩; κ32?(y2);
X1⟨y1, y2, κ12, κ22, κ32⟩
| κ23 D {true : 0,false : κ23?(y1); κ23!⟨y1 + 1⟩; X2⟨κ23⟩}
| κ34 D {true : 0,
f alse : κ34?(y1); κ34!⟨y1 − 1⟩; X2⟨κ34⟩}) → [If2],[MultiLabel]

def X1⟨y1, y2, x1, x2, x3⟩ = Q, X2⟨x2⟩ = R, X3⟨x3⟩ = S in


(νκ1, κ2, κ3) (κ11?(y1); 0
| κ22!⟨5⟩; κ22?(y1); κ32!⟨4⟩; κ32?(y2); X1⟨y1, y2, κ12, κ22, κ32⟩
| κ23?(y1); κ23!⟨y1 + 1⟩; X2⟨κ23⟩
| κ34?(y1); κ34!⟨y1 − 1⟩; X2⟨κ34⟩) → [Multicasting]...
Fire Alarm Protocol. The fire alarm protocol given in Section 1 is a simple representation of the communication pattern of a fire alarm system. Only two of the main components are considered: notification appliances and building safety interfaces. The implementation of the fire alarm protocol in the MS-calculus is:
controller   a[2, 3, ..., j + k](x1, x2, ..., xj−1, yj, ..., yj+k−1).x1, ..., xj−1!⟨“ON ”⟩;
yj, ..., yj+k−1!⟨“BLOCK”⟩; P
firealarm1  a[2](x1, x2, ..., xj−1, yj, ..., yj+k−1).x1?(x); P1
... 
firealarmj−1   a[j](x1, x2, ..., xj−1, yj, ..., yj+k−1).xj−1?(x); Pj−1
elevatorj    a[j + 1](x1, x2, ..., xj−1, yj, ..., yj+k−1).yj?(x); Q1
... 
elevatorj+k−1  a[j + k](x1, x2, ..., xj−1, yj, ..., yj+k−1).yj+k−1?(x); Qk−1
First, the controller sends in multicast an ON message to the fire alarms to notify the persons in the building and then sends a BLOCK message to the elevators to safely lead the persons towards safety exits. Due to the synchronous nature of communications in the MS-calculus, the second send will take place only after the first message has been received by all the fire alarms; the implementation follows correctly the timing specification of the events in a fire alarm system.

Higher-order Communications
The system developed by Honda et al. [9,10] does not define the term
throw k[k']; P1 | catch k(k'') 3 in P2 ~
semantically correct. In order to reduce, the receiver should possess the channel k' before the communication take place. It would be nice if a system could allow the transmission of channels with the receiver not possessing the channel before the communication. Yoshida and Vasconcelos [19] describe different extensions to the operational semantics and analyze soundness of the type system with respect to the operational semantics. The first solution is to rename the bound channel k'' into k' but that might bind the free occurrences of k' in P2. Another solution could be to change the operational semantic rule in

3 The terms throw k[k'] and catch k(k'') translate k!⟨k'⟩ and k?(k') in the syntax of the MS-calculus.

throw k[k']; P1 | catch k(k'') in P2 → P1 | P2[k'/k''].
This rule breaks soundness of the type system. Indeed the process
accept b(k') accept a(k) in throw k[k'] | request b(k') request a(k) in catch
k(k'') in k''?(y) in k'![1]
is well typed by [9] type system but the derived term
k'?(y) in k'![1]
is not well-typed under the same type system because in the derived term the type of k' involves one read and one write rather than only one write as it was in the starting definition of the second process. Even though, this example might be controversial if it is useful or not in practice, it is a well formed term of the calculus that breaks soundness of the type system. The solution proposed by Yoshida and Vasconcelos defines channels as runtime entities; i.e. they are not part of the syntax used by programmers and are generated at initiation time, as in the calculus introduced in this paper. The above example written in their system is
accept b(y1) accept a(y2) in throw y2[y1] | request b(y1) request a(y2) in catch y2(y3) in y3?(y4) in y1![1].
Session channels are labeled by a polarity sign (+, -) when substituted in each process at session initiation time. By convention, the polarity label - is assigned to a channel that is substituted in the process that is requesting to establish a session and + to the process that is waiting to establish a session. The polarity label is syntax added to channels in order to extend their definition as a communication abstraction entity. In other words, a channel is not only an entity that belongs to a communication but also that belongs to one of the two endpoint processes. The reduced term of the above process
κ'+?(y) in κ'−![1]
is well-typed as k' of one endpoint differs by a polarity sign from the other. SJ [12], an implementation of binary session types in Java, rejects at runtime the above example. Indeed, this term stucks in a non final value state and fails progress of the system.
The system given in this paper uses the same logic of [19,8] to represent channels. The only change is that of having multipolarity. That is, their system used a binary polarity (+, -) because in binary sessions only two processes are involved, but for the multiparty calculus the number processes participating in a session is generally more than two, thus we introduce an index label ranging [1, ..., n], where n is the number of processes involved in a session. As it can be noticed in the operational semantics rule, a polarity label is assigned to every channel of the session when substituted in a process.
Higher-order communication models the capability of a process to delegate its session participation to another one. The example below gives the implementa- tion of a session on a where participants 1 and 2 send author and title of a book to participant 3. Participant 1 delegates its part of the conversation to another

participant, implemented by process D, by sending all the channels of the session. Participant 1, 2 and 3 are implemented by processes A, B and C, respectively.

A  a[2, 3] (x1, x2).b[2] (y1).y1!⟨x1, x2⟩;
B  a[2] (x1, x2).x2!⟨“The computer and the brain”⟩;
C  a[3] (x1, x2).x1?(y'); x2?(y'');
D  b[2] (y1).y1?(y2, y3); y2!⟨“John von Neumann”⟩;


Global Session Types and Causality Analysis
Programming multiparty sessions without errors requires a lot of programming effort to define all the communications dependencies between all the participants and avoid race conditions on channels. As illustrated by the addition protocol in Section 1, binary session types can not capture all the interaction dependencies, thus a notion of global type is introduced in [10]. However, global types do not guarantee programs from having broken causalities introduced by a race condition on channels; a linearity property checks global types for the presence of this condition. Global types and causalities will be discussed in this section.

Syntax
The syntax of global session types or global types as we will refer to them through the paper, is presented in Figure 4. The constructors to build global session types for the MS-calculus are those of [10] extended with multicast send of values and labels. Type p → {p1, ..., pr}: {m1, ..., mr} ⟨S˜⟩.G' represents all sessions, where

participant p sends a message of type S˜
to all participants {p1, ..., pr} through

channels indexed m1, ..., mr where ∀i, j ∈ {1, ..., r} s.t. i /= j then mi /= mj, and that the rest of session is represented by G'. The calculus does not sup- port global types that have multicasting delegation (see Section 5). Type p →
{p1, ...., pr}: {m1, ..., mr} {lh : Gh}h∈J represents all sessions, where participant p selects and sends to all participants {p1, ..., pr} one of the J labels through channels indexed m1, ..., mr where ∀i, j ∈ {1, ..., r} s.t. i /= j then mi /= mj and that the rest of the session is represented by G'. We abbreviate to p → p' : m when there is a single receiver.
Type G, G' represents all sessions where parts of them, in this case represented by global types G and G', run in parallel. Type μt.G represents all sessions that define a recursive behaviour on G. Type end represents the empty session and is used as a base type to build more complex global session types.
Type U represents the types of values sent among participants, such as booleans, naturals, strings, channels or names. The type ⟨G⟩ is a set ⟨T @p1, ..., T @pr ⟩ where T @p (see Section 4.2) is an end-point type for participant p, and is used to type shared names.


G ::= p → {p1, ..., pr}: {m1, ..., mr} ⟨S˜⟩.G'	values
| p → p'' : m ⟨T @q⟩.G'	values
| p → {p1, ..., pr}: {m1, ..., mr} {lh : Gh}h∈J	branching
| G, G'	parallel
| μt.G	recursion
| t	variable
| end	end
S ::= bool | nat | ... | ⟨G⟩	Sort
m ::= 1 | 2 | ··· 



Preﬁx Ordering
Fig. 4. Syntax of Global Session Types

The definitions below formally define the ordering of communications on a global type. The ordering relation will be later used to define the linearity property.
Definition 3.1 (prefix) We say the initials “p → pi : mi” for all i ∈ {1..r} in
p → {p1, ..., pr}: {m1, ..., mr} ⟨U ⟩.G' and p → {p1, ..., pr}: {m1, ..., mr} {lh : Gh}h∈J are called preﬁxes from p to pi at mi over G' and {Gh}h∈J , where in the former U is called a carried type. If U is a carried type in a prefix in G then U is also a carried type in G.
Conventions 1 We assume that in each prefix from p to p' we have p /= p', i.e. we prohibit reflexive interaction.
Definition 3.2 (prefix ordering) Write n, n', .. for prefixes occurring in a global type, say G (but not in its carried types), seen as nodes of G as a graph. We write n ∈ G when n occurs in G. Then we write n1 ≺ n2 ∈ G when n1 directly or indirectly prefixes n2 in G. Formally ≺ is the least partial order generated by:
ni ≺ nr+1 ∈ p → p1, ..., pr : m1, ..., mr ⟨U ⟩.G' if ni = p → pi : mi, nr+1 ∈ G'
i ∈ {1, ..., r}
ni ≺ nr+1 ∈ p → p1, ..., pr : m1, ..., mr {lh : Gh}h∈J if ni = p → pi : mi,
∃h ∈ J. nr+1 ∈ Gh,i ∈ {1, ..., r}
Further we set n1 ≺ n2 ∈ G if n1 ≺ n2 ∈ G' and G' occurs in G but not in its carried types.
Consider a global type:
A → B: m1 ⟨U ⟩.A → C: m2 ⟨U '⟩.end	(2)
The two prefixes are ordered by ≺, A → B : m1 ≺ A → C : m2. This ordering means “only after the first sending and receiving take place, the second sending and

receiving take place”. It is modeled for calculi of synchronous communications but not for asynchronous ones; e.g. in the asynchronous calculus [10] C may receive its message before B.

Causality Analysis
Section 2.3 discussed why the causalities between Successor-Addition and Prede- cessor-Addition can be broken if it is used the same channel in this two communi- cations. It would be nice if we could statically check programs from race conditions on channels. Global types provide a global representation of a session’s causalities and channels used. The global type of the addition protocol is:
Client → Addition: 1⟨int⟩.
Client → Addition: 1⟨int⟩.
μt.Addition → {Successor, Predecessor}: 2, 3{
true : Addition → Client: 1⟨int⟩.end,
f alse : Addition → Successor: 2⟨int⟩.
Successor → Addition: 2⟨int⟩.
Addition → Predecessor: 3⟨int⟩.
Predecessor → Addition: 3⟨int⟩.t}
Even though Addition → Successor ≺ Addition → Predecessor the receip- tions are not ordered so if a same channel is used in both communications then the causalities can be broken.
Figure 5 presents all the possible scenarios of ordering two consecutive communi- cations without breaking the causalities. The letters A and S represent respectively the asynchronous and synchronous calculus where the cases are considered. All the six cases are considered for ordering in the synchronous MS-calculus unlike the asynchronous one [10] where the output-input (OI) and output-output (OO) are not considered. The output-input case is not consider in [10] because the reception of the message from P2 can occur before that the message sent is received by P1. The situation is the same for the output-output case, the second message sent can be received before the first one. If channels are the same, in the (II) case the order of messages can break, in the (IO) case the message sent by participant P1 can be received by participant P2 breaking therefore causalities, in the case (OI) the mes- sage sent by participant P2 can be received by participant P1 as in (IO) and in the (OO) case the order of messages can break as in (II). The break of messages order turns to be as harmful as a broken causality when the values of messages sent are different.
The above observations lead to causalities order on global types.
Definition 3.3 (dependency relations) Fix G. The relation ≺φ, with φ ∈ {II, IO, OI, OO}, over its prefixes is generated from:



Fig. 5. Causality Analysis




n1 ≺II n2 if n1 ≺ n2 and ni = pi → p : mi (i = 1, 2)
n1 ≺IO n2 if n1 ≺ n2, n1 = p1 → p : m1 and n2 = p → p2 : m2. n1 ≺OI n2 if n1 ≺ n2, n1 = p → p1 : m1 and n2 = p2 → p : m2. n1 ≺OO n2 if n1 ≺ n2, ni = p → pi : mi (i = 1, 2)
An input dependency from n1 to n2 is a chain of the form n1 ≺φ1 ··· ≺φn n2
(n ≥ 0) such that if


φi ∈ {OI, II} then φi+1 ∈ {OO, OI} or
φi ∈ {IO, OO} then φi+1 ∈ {II, IO}
for 1 ≤ i ≤ n − 1 and φn ∈ {II, OI}.






Pn+1




…
κjn+1 κ1n+1?

An output dependency from n1 to n2 is a chain of the form n1 ≺φ1 ··· ≺φn n2
(n ≥ 0) such that if

φi ∈ {OI, II} then φi+1 ∈ {OO, OI} or
φi ∈ {IO, OO} then φi+1 ∈ {II, IO}
for 1 ≤ i ≤ n − 1 and φn ∈ {OO, IO}.

Pn

κjn
Pn+1

…	κ1n!

κ1n+1?



Definition 3.4 (linearity) G is linear if, whenever ni = pi → p'
: m (i = 1, 2) are

in G for some m and do not occur in different branches of a branching, then both input and output dependencies exist from n1 to n2. In case of multicasting (values or labels), all the chains achieved by distributing each prefix of multicasting on the rest of G have to be checked if they satisfy the above conditions. If G carries other global types, we inductively demand the same.
We illustrate the condition on branching by an example:
A → B : m{ok : C → D : m1.end
quit : C → D : m1.end }
branching
The type represents branching: since only one of two branches is selected, there is no conflict between the two prefixes C → D : m1 in Lines 1 and 2.
Linearity and its violation can be detected algorithmically, without infinite un- foldings. First we observe we do need to unfold once.
μX.(A → B : m.end, B → A : m1.X)
This is linear in its 0-th unfolding (i.e. we replace X with end): but when unfolded once, it becomes non-linear, as witnessed by:
A → B : m.end, B → A : m1.μX.(A → B : m.end, B → A : m1.X)
since the two prefixes A → B : m appear in parallel. But in fact unfolding once turns out to be enough. Taking G as a syntax, let us call the one-time unfolding of G the result of unfolding once for each recursion in G (but never in carried types), and replacing the remaining variable with end.
Proposition 3.5 (1) The one-time unfolding of a global type is linear iff its n-th unfolding is linear. (2) The linearity of a global type is decidable at worst case in cubic time-complexity.



Proof. See [13].	 

Typing Discipline
Programming Methodology
The programming methodology of this calculus follows a top-down approach as in the asynchronous calculus [10], CDL [18] and End Point Projection [4].
The first step when programming a multiparty session is the definition of the global type. The global type defines the communication protocol (conversation) between only the participants of a session.
In the second step, the programmer programs each participant of the session. Participants can be implemented by different programmers and they may be differ- ent from the one who has written the global type.

End-point Session Types
End-point session types (see Figure 6) or end-point types capture the behaviour of a process; the constructs used to build them are those of binary session types [9] extended with multicasting send of values and labels.


U ::= S˜
| T @p	Value

S ::= bool | ... | ⟨G⟩	Sort
T ::= m?⟨U ⟩; T	receive
| m˜ !⟨U ⟩; T	send
| m˜ ⊕ {li : Ti}i∈I	selection
| m&{li : Ti}i∈I	branching
| μt.T | t | end


Fig. 6. Syntax of Local Types

Session type m˜ !⟨U ⟩; T represents all processes that send a value of type U on
channels indexed m˜ and that the rest of behaviour is abstracted by T. Session type
m?⟨U ⟩; T represents all processes that receive a value of type U on channel indexed m and that the rest of behaviour is abstracted by T. Session type m˜ ⊕ {li : Ti}i∈I represents all processes that send one of the i labels and that the rest of behaviour is abstracted by Ti. Session type m&{li : Ti}i∈I represents all processes that receive one of the i labels and that the rest of behaviour is abstracted by Ti. Session type μt.α represents all processes that have a recursive behaviour captured by T. Type session end represents the 0 process. The type U represents the same set of values as in global types. When U defines a session type then the local type represents a session channel send or receive.

Projection and Coherence
This section defines formally the projection of a global type over its participants. The results of the projection are the end-point types that will be used by the type system to type-check the process that implements the session.
Definition 4.1 (Projection) Let G be linear. The projection of G onto p', writ- ten G Tp', is inductively given as:
(p → {p1, ..., pr}: {m1, ..., mr} ⟨S˜⟩.G') Tp'  d=ef
m1, ..., mr!⟨S˜⟩; (G' Tp')	if p' = p and p' ∈/ {p1, ..., pr}
⎪⎨mi?⟨S˜⟩; (G' Tp')	if p' ∈ {p1, ..., pr} and i ∈ {1, ..., r}

and p
⎪
/= p

⎩(G' Tp')	if p' ∈/ {p1, ..., pr} and p' /= p



(p → p'' : m ⟨T @q⟩.G') Tp'  d=ef
m?⟨T @q⟩; (G' Tp')	if p' = p'' and p' /= p
⎪⎩(G' Tp')	if p' /= p'' and p' /= p



(p → {p1, ..., pr}: {m1, ..., mr} {l
: G } ∈
) Tp'  def

m1, ..., mr ⊕ {lk : (Gk Tp')}k∈J	if p' = p and p' ∈/ {p1, ..., pr}
m &{l : (G Tp')}	if p' ∈ {p , ..., p } and i ∈ {1, ..., r}
and p' /= p


⎪⎩


'  def
∀k, j ∈ J.Gk Tp' = Gj Tp'

 Gi Tp'	if p' ∈ Gi and p' /∈ Gj,i /= j ∈ {1, 2}

 



(μt.G) Tp
'  d=ef
μt.(G Tp')	if p' ∈ G
end	if p' ∈/ G


t Tp' = t, and end Tp' = end

When a side condition does not hold the map is undefined.
The mapping is intuitive. In the branching, all projections should generate an identical end-point type (otherwise undefined). In the parallel composition, p' should be contained in at most a single type, ensuring each type is single-threaded. The single-threaded definition of the calculus does not allow programmers to define global types such as A → B : m1⟨U ⟩, A → C : m2⟨U ⟩. However, by using multicast

we can model them as A → B, C : {m1, m2}⟨U ⟩, only when the values send are the same. Also, the global type A → B : m1{l1 : B → A : m2⟨U ⟩, l2 : C → A : m2⟨U '⟩} is not well-formed due to branching condition on projection but we can model the branching behaviour by using multicast on labels as A → {B, C} : {m1, m3}{l1 : B → A : m2⟨U ⟩, l2 : C → A : m2⟨U '⟩}. Below pid(G) denotes the set of participant numbers occurring in G (but not in carried types).
Definition 4.2 (Coherence) (1) We say G is coherent if it is linear and G T p is well-defined for each p ∈ pid(G), similarly for each carried global type inductively.
(2) {Tp@p}p∈I is coherent if for some coherent G s.t. I = pid(G), we have G Tp = Tp
for each p ∈ I.
Theorem 4.3 Coherence of G is decidable at the worst case in O(n6) time com- plexity.
Proof. See [13].	 

Static Semantics
The static type system rules are basically the ones for binary session calculi [9] extended with rules that type multicasting session initiation. The typing system uses a map from shared names to their sorts (S, S', ..). As given in Figure 6, other than atomic types, a sort has the shape ⟨G⟩ assuming G is coherent. Using these sorts we define the grammar of sortings and typings as follows. Below in “Γ,a : S”,
we assume a does not occur in Γ and in “Δ, k˜ : {T @p}p∈I ”, we assume no channel
in k˜ occurs in the domain of Δ.
Γ ::= ∅ | Γ,a : S | Γ,X : S˜T˜ Δ ::= ∅ | Δ, k˜ : {T @p}p∈I
A sorting (Γ, Γ', ..) is a finite map from names to sorts and from process variables to sequences of sorts and types. Typing (Δ, Δ', ..) records linear usage of session channels. In the binary sessions, it mapped each channel in its domain to a type: now it maps each vector of session channels in its domain to a family of located types. We also write sid(G) for the set of session channel numbers in G.
Definition 4.4 A partial operator · is defined as:
{Tp@p}p∈I · {T '' @p'}p'∈J = {Tp@p}p∈I ∪ {T '' @p'}p'∈J
p	p

if I ∩ J = ∅. Then we say Δ1 and Δ2 are compatible, written Δ1 = Δ2, if for all κ˜p ∈ dom(Δ1) and κ˜q ∈ dom(Δ2) such that κ˜ = κ˜p = κ˜q and Δ1(κ˜p) · Δ2(κ˜q) is defined. When Δ1 = Δ2, the composition of Δ1 and Δ2, written Δ1 ◦ Δ2, is given as:
Δ1 ◦ Δ2 = {κ˜p, κ˜q : Δ1(κ˜p) · Δ2(κ˜q) |κ˜ ∈ dom(Δ1) ∩ dom(Δ2)}
∪Δ1 \ dom(Δ2) ∪ Δ2 \ dom(Δ1)



  Γ ▶ ei D bool 
Γ,a : S ▶ a : S	Γ ▶ true, false : bool
Γ ▶ e1or e2 : bool
Γ ▶ a : ⟨G⟩ Γ ▶ P D Δ, x˜: (G †1)@1 |x˜| = |sid(G)|
Γ ▶ a[2..n] (x˜).P D Δ
Γ ▶ a : ⟨G⟩ Γ ▶ P D Δ, x˜: (G †p)@p |x˜| = |sid(G)|

Γ ▶ a[p] (x˜).P D Δ
[NameI], [Bool], [Or]
[Mcast] [Macc]

Γ ▶ e˜: S˜	Γ ▶ P D Δ, k˜ : T @p
Γ ▶ k[m , ..., m ]!⟨e˜⟩; P D Δ, k˜ : m , ..., m !⟨S˜⟩; T @p	[Send]
1	n	1	n
Γ, y˜: S˜ ▶ P D Δ, k˜ : T @p

Γ ▶ k[m]?(y˜); P D Δ, k˜ : m?⟨S˜⟩; T @p	[Rcv] Γ ▶ P D Δ, k˜ : T @p
Γ ▶ k[m]!⟨t˜⟩; P D Δ, k˜ : m!⟨T '@p'⟩; T @p, t˜: T '@p'	[Thr]
Γ ▶ P D Δ, k˜: T @p, y˜: T '@p'
Γ ▶ k[m]?(y˜); P D Δ, k˜ : m?⟨T '@p'⟩; T @p	[Cat] Γ ▶ P D Δ, k˜ : Tj @p	j ∈ I

Γ ▶ k[m , ..., m ] Q l ; P D Δ, k˜ : m , ..., m
⊕ {l
: T }
[Sel]
@p

1	n	j
1	n	i
i i∈I

Γ ▶ Pi D Δ, k˜ : Ti@p	∀i ∈ I

Γ ▶ k[m] Q {l : P }	D Δ, k˜: m &{l : T }
[Br]
@p

i	i i∈I	i	i i∈I

Γ ▶ P D Δ	Γ ▶ QD Δ'	Δ = Δ'
Γ ▶ P | QD Δ ◦ Δ'	[Conc]
Γ ▶ eD bool	Γ ▶ P D Δ	Γ ▶ QD Δ

Γ ▶ if e then P else QD Δ Γ ▶ P D Δ	Δ <: Δ'
[If]


Δ end only
Γ ▶ P D Δ'	[<:]
Γ,a : ⟨G⟩ ▶ P D Δ

Γ ▶ 0 D Δ
Γ ▶ (νa)P D Δ
[Inact],[NRes]

Γ ▶ P D Δ, κ˜p1 : T1@p1 ◦ ... ◦ κ˜pn : Tn@pn Γ ▶ (νκ˜)P D Δ
[CRes]

Γ ▶ e˜: S˜	Δ end only
Γ,X : S˜T˜ ▶ X⟨e˜, k˜⟩ D Δ, k˜ : T˜@~p	[Var] Γ,X : S˜T˜, y˜ : S˜ ▶ P D y˜' : T˜@~p
Γ,X : S˜T˜ ▶ Q D Δ


Γ ▶ def X(y˜, y˜')= P in QD Δ
[Def]



Fig. 7. Typing System for Expressions and Processes

The paragraph gives a description of the static type system rules. A multicast session initiation (accept or request) process is well-typed if the process under (the prefix) is well-typed with the end-point type obtained by projection. The end-point types for each process of a session are stored in the typing of the shared name where the session has initiated (a : ⟨G⟩). A value process that sends or receive a value is well-typed if the process under (the prefix) is well-typed. The notation of channels in rules [Send] and [Sel] is defined in Notation 2.2 and Notation 2.3. A process that selects a label is well-typed if the continuation process is well-typed. A process that branches over a set of labels is well-typed if the continuation processes

over that set are well-typed. A parallel composition process is well-typed if each component process is well-typed and the two components belong to two different process entities. The system considers as a structural congruence rule the following one on restriction of channels: (νk)(νk')P ≡ (νk, k')P .

Type-checking Examples
This section gives the type-checking of the processes under the prefixes of multicas- ting session request or session accept introduced in Section 2.3 with the end-point types obtained by the projection algorithm.
Addition Protocol. Type-checking is defined for the process under the prefix of the multicasting session request or session accept with the sorting list Γ = {a :
⟨G⟩}, letting Client = 1, Addition = 2, Successor = 3, Predecessor = 4:
Γ ▶ client d x1, x2, x3 : 1!⟨int⟩; 1!⟨int⟩; 1?⟨int⟩; end@Client Γ ▶ addition d x1, x2, x3 : 1?⟨int⟩; 1?⟨int⟩; μt.2, 3⊕
{true : 1!⟨int⟩; end,
f alse : 2!⟨int⟩; 2?⟨int⟩; 3!⟨int⟩; 3?⟨int⟩; t}@Addition
Γ ▶ successor d x1, x2, x3 : μt.2&{true : end,f alse : 2?⟨int⟩; 2!⟨int⟩; t}@Successor
Γ ▶ predecessor d x1, x2, x3 : μt.3&{true : end,f alse : 3?⟨int⟩; 3!⟨int⟩; t}@Predecessor
Fire Alarm Protocol. With the sorting list Γ = {a : ⟨G'⟩} where G' is: Controller → FireAlarm1, ..., FireAlarmj−1 : 1, ..., j − 1⟨string⟩ Controller → Elevatorj, ..., Elevatorj+k−1 : j, ..., j + k − 1⟨string⟩
letting Controller = 1, FireAlarm1 = 2, ..., FireAlarmj−1 = j, Elevatorj = j+1,
..., Elevatorj+k−1 = j+k, the processes under the prefix of the multicasting session request or session accept are type-checked:

Γ ▶ controller d x1, ..., xj+k−1 : 1, ..., j − 1!⟨string⟩; j, ..., j + k − 1!⟨string⟩; end@Controller Γ ▶ ﬁre alarm1 d x1, ..., xj+k−1 : 1?⟨string⟩; end@FireAlarm1
··· 
Γ ▶ ﬁre alarmj−1 d x1, ..., xj+k−1 : j − 1?⟨string⟩; end@FireAlarmj−1 Γ ▶ elevatorj d x1, ..., xj+k−1 : j?⟨string⟩; end@Elevatorj
··· 
Γ ▶ elevatorj+k−1 d x1, ..., xj+k−1 : j + k − 1?⟨string⟩; end@Elevatorj+k−1
Delegation. With the assumption list Γ = {a : ⟨Ga⟩,b : ⟨Gb⟩} where Ga and
Gb are:

Gb = A → D: 1 ⟨1!⟨string⟩; end@A⟩.end
Ga = A → C: 1 ⟨string⟩.B → C: 2 ⟨string⟩.end.
letting A = 1, B = 2, C = 3, D = 4, the typechecking of the processes is defined as follows:
Γ ▶ A d y1 : 1!⟨1!⟨string⟩; end@A⟩@A, x1, x2 : 1!⟨string⟩@A Γ ▶ B d x1, x2 : 2!⟨string⟩@B
Γ ▶ C d x1, x2 : 1?⟨string⟩; 2?⟨string⟩@C Γ ▶ D d y1 : 1?⟨1!⟨string⟩; end@A⟩@D

Soundness
We now prove that the type system we have introduced is sound: its type-checking rules prove only terms that are valid with respect to the operational semantics.
We need subject congruence when proving subject reduction for [Str].
Theorem 4.5 (subject congruence)  Γ ▶ P d Δ and P ≡ P ' imply Γ ▶ P ' d Δ.
Proof. See Appendix A.	 
Theorem 4.6 (subject reduction) Γ ▶ P dΔ with Δ coherent and P → P ' imply
Γ ▶ P ' d Δ' where Δ= Δ' or Δ → Δ' with Δ' coherent.
Note the definition of coherence for Δ is given in Definition 4.2(2).
Proof. See Appendix A.	 

Related and Future Work
Synchronous Session Types
Multiparty session types have been firstly studied for asynchronous communi- cation calculi [10,1]. In these calculi, for problems that specify a strict order of communications, programmers have to specify the order by adding extra communi- cations, that send an empty message, and channels to preserve linearity of the late ones. Considering the fire alarm system introduced in Section 1 for a calculus of asynchronous communications e.g. [10], the global type is now defined:
Controller → FireAlarm1, ..., FireAlarmj−1 : 1, ..., j − 1⟨string⟩.
FireAlarm1 → Controller : j⟨⟩.
··· 
FireAlarmj−1 → Controller :2 ∗ j − 1⟨⟩.
Controller → Elevatorj, ..., Elevatorj+k−1 :2 ∗ j, ..., 2 ∗ j + k − 1⟨string⟩

where the additional communications between the fire alarms and the controller, and the new channels are introduced to preserve the order of communications be- tween Controller-FireAlarm1, ..., FireAlarmj−1 and Controller-Elevatorj, ..., Elevatorj+k−1 and linearity.
Recently, contracts for web-services [5] have been studied for a calculus of syn- chronous communications. A contract is a binary session type between a client and a service, that can capture a combination of an internal and external choice at participants. The work on contracts does not address ordering and causalities of communications in a multiparty session. Merging of sessions is modeled via inter- actions inside a session and locations in [3]; the result of the type safety property is left as future work.
A calculus of service-oriented computing is introduced in [17], where a conversa- tion models the interactions between a client and various services. New primitives of communication are introduced such as conversation context (shared interaction point) communication and communication inside an end-point. An exception han- dling mechanism similar to those proposed for functional languages is introduced for the calculus. The calculus in essence is similar to the ones presented for session types [9,16] but does not address resolution of safe communications at static time.

Choreography and Orchestration
WS-CDL [18] is the first language that uses the metaphor of choreography to de- scribe interactions between participants of a session. A distilled version of WS-CDL
[4] is used to study a theory of end-point projection (EPP). The global calculus syn- tax given in EPP offers syntactic sugar useful to write invocation-based protocols such as assignment of processes to local variables and independent choice over global behaviors. In contrast to the global calculus, global types support high-order com- munication and multicasting. “Choreography” is used to describe cryptographic protocols [7], which protect session execution from both external attackers and ma- licious participants. The work in [7] defines a model to program cryptographic systems rather than a typing discipline for programming languages.
WS-BPEL [2] is the first language that uses the metaphor of orchestration to describe interactions between participants of a session.

Implementation of Session Types
Several academic projects address the implementation of binary session types in Java [11], Haskell [14] and C++ [6]. Scribble [15] is an implementation for Java of multiparty session types as an industry project.

Future work:
Inner Delegation. A scenario of inner delegation is defined when a participant delegates its part of session to a participant that is already part of that session. Such scenario can reduce to a process that can stuck at runtime; e.g.

Ga = A → C: 1⟨string⟩.B → C: 2⟨string⟩.end
Gb = A → B: 1⟨1!⟨string⟩.end⟩.end
where the session at a is defined between participants A, B and C, and A delegates the ability of sending a-string-to-C to B. The implementation of the global type:

· A  a[2, 3] (x1, x2).b[2] (y1).y1!⟨x1, x2⟩;
B  a[2] (x1, x2).b[2] (y1).y1?(y2, y3); x2!⟨“The computer and the brain”⟩;
y2!⟨“John von Neumann”⟩;
C  a[3] (x1, x2).x1?(y'); x2?(y'');
stucks on the first interaction of process B with process C as the late one is waiting to receive on channel place hold by x1 whilst, the former is sending on channel place hold by x2.

Delegation in Multicast. The actual syntax of global types does not allow programmers to write global types that contain delegation in multicast. It is intuitive that delegating to more than one participant the same behaviour breaks progress.
Multicast in delegation as an operation where a behaviour is split and delegated to several participants, can be an interesting construct; e.g.
Ga = A → C: 1 ⟨string⟩.A → C: 1 ⟨string⟩.B → C: 2 ⟨int⟩.end. Gb = A → D, E: 1, 2 ⟨1!⟨string⟩@A, 1!⟨string⟩@A⟩.end.
where participant A splits the behaviour of sending the title and the author of a book into two independent behaviors and delegates each of them to D and E respectively. However, the splitting operation should be defined only when there is no order between the two behaviors. The implementation below illustrates the problem introduced by the new construct:

· A  a[2, 3] (x1, x2).b[2, 3] (y1, y2).y1, y2!⟨x1, x2⟩;
· B  a[2] (x1, x2).x2!⟨11⟩;
· C  a[3] (x1, x2).x1?(y'); x1?(y'); x2?(y'');
D  b[2] (y1, y2).y1?(y3, y4); y3!⟨“The computer and the brain”⟩;
E  b[3] (y1, y2).y2?(y3, y4); y3!⟨“John von Neumann”⟩;
where processes D and E are both able to send their messages at the same time, breaking therefore their order.

As future work, we plan to develop a typing theory that checks global types from inner-delegation scenarios and rejects implementation of such scenarios. We plan to extend delegation with multicasting; i.e. allowing delegation of different behaviors that do not have dependencies between them to a group of participants simultane- ously.

Acknowledgement
We thank the reviewers for their comments. The work is partially supported by EPSRC GR/T03208, EPSRC GR/T03215, and IST2005–015905 MOBIUS.

References
Bonelli, E. and A. B. Compagnoni, Multipoint session types for a distributed calculus, in: TGC, Lecture Notes in Computer Science 4912 (2008), pp. 240–256.
Web	services	business	process	execution	language	version	2.0,	Available	at
http://docs.oasis-open.org/wsbpel/2.0/wsbpel-specification-draft.html  .
Bruni, R., I. Lanese, H. C. Melgratti and E. Tuosto, Multiparty sessions in SOC, in: D. Lea and
G. Zavattaro, editors, COORDINATION, Lecture Notes in Computer Science 5052 (2008), pp. 67–82.
Carbone, M., K. Honda and N. Yoshida, Structured communication-centred programming for web services, in: ESOP, Lecture Notes in Computer Science 4421 (2007), pp. 2–17.
Castagna, G., N. Gesbert and L. Padovani, A theory of contracts for web services, in: G. C. Necula and P. Wadler, editors, POPL (2008), pp. 261–272.
Collingbourne, P. and P. Kelly, Inference of session types from control flow, FESCA, ENTCS (2008).
Corin, R., P.-M. Deni´elou, C. Fournet, K. Bhargavan and J. J. Leifer, Secure implementations for typed session abstractions, in: CSF (2007), pp. 170–186.
Gay, S. J. and M. Hole, Subtyping for session types in the pi calculus, Acta Inf. 42 (2005), pp. 191–225.

Honda, K., V. T. Vasconcelos and M. Kubo, Language primitives and type discipline for structured communication-based programming, in: C. Hankin, editor, ESOP, Lecture Notes in Computer Science 1381 (1998), pp. 122–138.
Honda, K., N. Yoshida and M. Carbone, Multiparty asynchronous session types, in: G. C. Necula and
P. Wadler, editors, POPL (2008), pp. 273–284.
Hu,	R.,	Session-based	Distributed	Programming	in	JAVA,	Available	at
http://www.doc.ic.ac.uk/~rh105/sessiondj.html .
Hu, R., N. Yoshida and K. Honda, Session-based distributed programming in JAVA, in: J. Vitek, editor,
ECOOP, Lecture Notes in Computer Science 5142 (2008), pp. 516–541.
Multiparty asynchronous session types, Available at http://www.doc.ic.ac.uk/~ab406/journal.pdf.
Sackman,	M.,	Session	Types	in	Haskell,	Available	at
http://www.wellquite.org/sessions/tutorial_1.html  .
Scribble, Available at http://pi4scribble.wiki.sourceforge.net/ .
Takeuchi, K., K. Honda and M. Kubo, An interaction-based language and its typing system, in:
C. Halatsis, D. G. Maritsas, G. Philokyprou and S. Theodoridis, editors, PARLE, Lecture Notes in Computer Science 817 (1994), pp. 398–413.
Vieira, H. T., L. Caires and J. C. Seco, The conversation calculus: A model of service-oriented computation, in: S. Drossopoulou, editor, ESOP, Lecture Notes in Computer Science 4960 (2008),
pp. 269–283.
Web	services	choreography	description	language	version	1.0,	Available	at
http://www.w3.org/2002/ws/chor/edcopies/cdl/cdl.html  .
Yoshida, N. and V. T. Vasconcelos, Language primitives and type discipline for structured communication-based programming revisited: Two systems for higher-order session communication, Electr. Notes Theor. Comput. Sci. 171 (2007), pp. 73–93.

Soundness
Notation A.1 “By inversion” denotes inversion on a rule. That is, a conclusion judgment that is achieved by applying a certain rule is true if the premises on that rule are true.
Notation A.2 “By rule” denotes applying a rule. That is, given the premises and side conditions of a rule then we can conclude the judgment by applying that rule.

Subject Reduction
Subject reduction ensures that the type of an expression is preserved during its evaluation. For the proof of subject reduction, we need three standard properties: channel replacement, weakening and substitution lemma. We need the channel replacement lemma for rules [Link], [Multicasting] and [Def], weakening for rule [Def] and subject congruence, and substitution for rule [Multicasting] and [Def].
Lemma A.3 (substitution and weakening) (1) Γ, x˜ : S˜ ▶ P D Δ and Γ ▶ v˜ : S˜ imply Γ ▶ P [v˜/x˜] D Δ.
Whenever Γ ▶ P D Δ is derivable then its weakening, Γ ▶ P D Δ, Δ' for disjoint Δ' where Δ' contains only empty type contexts and for types end, is also derivable.
Proof. Standard, see [19].	 
Lemma A.4 (Channel Replacement) If Γ ▶ P D Δ, x˜: T @p and κ˜p ∈/ dom (Δ), then Γ ▶ P [κ˜p/x˜] D
Δ, κ˜p : T @p.
Proof. A straightforward induction on the derivation tree for P . We give the proof of the most interesting cases.
Case: [Conc]
Γ ▶ P D Δ1	Γ ▶ QD Δ2	Δ1 = Δ2
Γ ▶ P | QD Δ, x˜: T @p
Γ ▶ P | QD Δ, x˜: T @p and κ˜p ∈/ dom (Δ)	By assumption Γ ▶ P D Δ1 Γ ▶ QD Δ2 Δ1 = Δ2
where Δ, x˜: T @p = Δ1 ◦ Δ2 and κ˜p ∈/ dom (Δ)	By inversion on [Conc]
First Subcase: x˜ : T @p ∈ Δ1 and x˜ : T @p ∈/ Δ2	By Δ1 = Δ2
Δ1 = Δ' , x˜: T @p	Γ ▶ P [κ˜p/x˜] D Δ' , κ˜p : T @p	By induction

1	1
Γ ▶	| QD Δ' , κ˜ : T @p ◦ Δ
By rule [Conc]

P [κ˜p/x˜]	1  p	2

Δ' , κ˜p : T @p ◦ Δ2 = Δ' ◦ Δ2, κ˜p : T @p
κ˜p ∈/ dom (Δ)

1	1
Γ ▶ P [κ˜p/x˜] | QD Δ, κ˜p : T @p
Second Subcase: x˜ : T @p ∈ Δ2 and x˜ : T @p ∈/ Δ1	By Δ1 = Δ2
Δ2 = Δ' , x˜: T @p	Γ ▶ Q[κ˜p/x˜] D Δ' , κ˜p : T @p	By induction

2	2
Γ ▶ P |	◦	'
By rule [Conc]

Q[κ˜p/x˜] D Δ1 (Δ2 , κ˜p : T @p)

(Δ' , κ˜p : T @p)= Δ' ◦ Δ2, κ˜p : T @p
κ˜p ∈/ dom (Δ)

2	1
Γ ▶ P | Q[κ˜p/x˜] D Δ, κ˜p : T @p

Note that (P | Q)[κ˜p/x˜]= P [κ˜p/x˜] | Q or (P | Q)[κ˜p/x˜]= P | Q[κ˜p/x˜].
Case: [If]
Γ ▶ eD bool	Γ ▶ P D Δ, x˜ : T @p	Γ ▶ QD Δ, x˜ : T @p
Γ ▶ if e then P else QD Δ, x˜ : T @p
Γ ▶ if e then P else Q D Δ, x˜ : T @p and κ˜p ∈/ dom (Δ)		By assumption Γ ▶ P D Δ, x˜ : T @p and Γ ▶ QD Δ, x˜ : T @p and κ˜p ∈/ dom (Δ)	By inversion on [If] Γ ▶ P [κ˜p/x˜] D Δ, κ˜p : T @p and Γ ▶ Q[κ˜p/x˜] D Δ, κ˜p : T @p			By induction
Γ ▶ (if e then P else Q)[κ˜p/x˜] D Δ, κ˜p : T @p	By rule [If]

Note that (if e then P else Q)[κ˜p/x˜]= if e then P [κ˜p/x˜] else Q[κ˜p/x˜].

Next we introduce reduction over session typings, which abstractly represent interaction (message delivery) in processes. We also assume well-formedness of types.

m1, ..., mn!⟨S˜⟩; T @p, m1?⟨S˜⟩; T1@p1, ..., mn?⟨S˜⟩; Tn@pn → T @p, T1@p1, ..., Tn@pn	[TR-Mult]
m!⟨T2@p2⟩; T @p, m?⟨T2@p2⟩; T1@p1 → T @p, T1@p1	[TR-MultD]
m1, ...mn ⊕ {... , l : T, ...}@p, m1&{..., l : T1, ...}@p1, ..., mn&{..., l : Tn, ...}@pn
→ T @p, T1@p1, ..., Tn@pn	[TR-MultL]
T1@p1, ..., Tn@pn → T '@p1, ..., T ' @pn
1	n	[TR-Context]
Δ, κ˜p , ..., κ˜p : T1@p1, ..., Tn@pn, → Δ, κ˜p , ..., κ˜p : T '@p1, ..., T ' @pn,
1	n	1	n	1	n

Definition A.5 (1) (coherence of typings) We say Δ is coherent if Δ(k˜) is coherent for each k˜ ∈ dom (Δ).
(full projection) Assume G is coherent and let G †pi = Ti for each pi ∈ pid(G). Then [[G]], called
full projection of P, denotes the family {Ti@pi}.
(causal edges on [[G]]) For [[G]] given above, regarding each type in [[G]] as the corresponding regular tree, we define the causal edges ≺II, ≺IO, ≺OI and ≺OO among its prefixes precisely we have done in G.
Proposition A.6 Each causal edge in G is preserved and reflected through the projection onto [[G]].
Proof. This is because every causal edges record prefixing on the same participant is preserved by projec- tion. The statement becomes more clear when considering the four possible cases of edges on prefixes:
Case II. B → A: m1.G.C → A: m2, where B → A: m1 ≺II C → A: m2, is mapped into {(m1!⟨⟩; G †
B)@B, (m1?⟨⟩; G †A; m2?⟨⟩)@A, (G †C; m2!⟨⟩)@C}
Case IO. B → A: m1.G.A → C: m2, where B → A: m1 ≺IO A → C: m2, is mapped into {(m1!⟨⟩; G †
B)@B, (m1?⟨⟩; G †A; m2!⟨⟩)@A, (G †C; m2?⟨⟩)@C}
Case OI. A → B: m1.G.C → A: m2, where A → B: m1 ≺OI C → A: m2, is mapped into {(m1?⟨⟩; G †
B)@B, (m1!⟨⟩; G †A; m2?⟨⟩)@A, (G †C; m2!⟨⟩)@C}
Case OO. A → B: m1.G.A → C: m2, where A → B: m1 ≺OO A → C: m2, is mapped into {(m1?⟨⟩; G †
@B, (m1!⟨⟩; G †A; m2!⟨⟩)@A, (G †C; m2?⟨⟩)@C}

Definition A.7 (merge set) Assume G is coherent. Then we say two prefixes in G in different branches of a branching prefix are mergeable with each other when they are collapsed in its projection. A prefix is always mergeable with itself. Given a prefix n, its merge set is the set of prefixes mergeable with n.
Proposition A.8 Two prefixes in G are mergeable iff they are related to one common input prefix and one common output prefix in [[G]] through projection.
Proof. This is because, in the defining clauses of projection, there are no other cases than the one for branching which collapse two prefixes.	 
Proposition A.9 (1) If a pair of prefixes in [[G]] form a redex with respect to → then they are not prefixed by any pair of prefixes that form a ≺II, ≺IO, ≺OI or ≺OO dependency.
Given coherent G, let G' be the result of taking off the merge set of a prefix from G which is not prefixed by any of ≺II, ≺IO, ≺OI or ≺OO. Then G' is again coherent.
Let G be coherent. Then the causal edges are preserved and reflected between the two merge sets in G and their images in [[G]]. Further each redex pair in [[G]] is the image of some prefix in G.
Proof. For (1), observe that redexes in the base rules over session typing, [TR-Mult], [TR-MultD] and [TR-MultL], are in the minimal positions and since there is no permuation of prefixes, as it is for the asyn- chronoous calculus for OO, we conclude. (Two output-output actions are strictly orderd due to synchrony.) For (2) , first, for linearity, suppose n1,2 are in G' sharing a channel. Then they are also in G and causal edges between them do not differ so they have the same dependencies as in G. Second, the coherence
in projection is immediate since we lose one prefix from the projection of each branch.
For (3), the first part is immediate from the construction. For the second point assume there is a redex pair in [G ] whose two parts have different pre-images. Then we have co-occurring prefixes in G which are not related by the two dependencies, by (1) and the first part of (3), a contradiction.	 
Lemma A.10 (1) Δ1 → Δ' for κ˜ and Δ1 = Δ2 imply Δ' = Δ2 and Δ1 ◦ Δ2 → Δ' ◦ Δ2.
1	1	1
(2) Let Δ be coherent. Then Δ → Δ' implies Δ' is coherent.

Proof.
For (1) suppose Δ1 → Δ'

and Δ1 = Δ2. Note Δ1 = Δ2 means that each pair of vectors of

channels from Δ1,2 either coincide or are disjoint, and that, if they coincide, their image are participant-

wise composable by ◦. Since no typed reduction rule invalidate either condition we conclude Δ'
= Δ2.

Δ1 ◦ Δ2 → Δ' ◦ Δ2 follows directly from [TR-Context].
For (2), suppose Δ is coherent and Δ → Δ'. Suppose the associated redex is in Δ(s˜). By coherence we can write Δ(s˜) as [G ] for some coherent G. Now consider the preimage of the associated redex in [G]], whose existence is guaranteed by Proposition A.9 (3). This preimage is not suppressed (related) by causal edges by Proposition A.9 (1,3). reducing [G ] corresponds to eliminating its preimage from G, say G', whose
projection [G' ] precisely gives the result of reducing [G]]. Since G' is coherent by Proposition A.9 (2) we are done.

We need subject congruence when proving subject reduction for [Str].
Theorem A.11 (subject congruence)  Γ ▶ P D Δ and P ≡ P ' imply Γ ▶ P ' D Δ.


Proof. By rule induction on the derivation of Γ ▶ P D Δ when assuming that P ≡ P ' and Γ ▶ P ' D Δ when assuming that P ' ≡ P . For each structural congruence axiom, we consider each session type system rule that can generate Γ ▶ P D Δ.
Case: P | 0 ≡ P

Γ ▶ P | 0 D Δ	By assumption
Γ ▶ P D Δ1 and Γ ▶ 0 D Δ2 where Δ = Δ1 ◦ Δ2, Δ1 = Δ2	By inversion
Δ2 is only end and for Δ2 such that dom (Δ1) ∩ dom (Δ2)= ∅	By inversion
then Γ ▶ P D Δ1, Δ2	By weakening
and Δ = Δ1 ◦ Δ2 = Δ1, Δ2
Γ ▶ P D Δ	By assumption
Γ ▶ 0 D Δ' where Δ' is only end and dom (Δ) ∩ dom (Δ')= ∅	By rule [Inact]
Γ ▶ P | 0 D Δ, Δ'	By rule [Conc]
for Δ' = ∅ we have that Γ ▶ P | 0 D Δ

Case: P | Q ≡ Q | P

Γ ▶ P | QD Δ	By assumption
Γ ▶ P D Δ1 and Γ ▶ Q D Δ2
where Δ = Δ1 ◦ Δ2 and Δ1 = Δ2 = Δ2 = Δ1	By inversion
Γ ▶ Q | P D Δ	By rule [Conc]
The other case is symmetric to the above one. Case: (P | Q) | R ≡ P | (Q | R)
Γ ▶ (P | Q) | R D Δ	By assumption
Γ ▶ P D Δ1, Γ ▶ QD Δ2 and Γ ▶ R D Δ3 where Δ = Δ1 ◦ Δ2 ◦ Δ3
and Δ1 = Δ2 = Δ3	By inversion
Γ ▶ P | (Q | R) D Δ	By rule [Conc]
The other case is symmetric to the above one.
The other axioms are proved in the similar way as in Vasconcelos and Yoshida [19].	 
Theorem A.12 (subject reduction) Γ ▶ P D Δ with Δ coherent and P → P ' imply Γ ▶ P ' D Δ' where
Δ= Δ' or Δ → Δ' with Δ' coherent.
Proof. By rule induction on the derivation of P → P '. There is a case for each operational semantics rule. For each operational semantics rule, we consider each type system rule that can generate Γ ▶ P D Δ. By Lemma A.10(2) we have that Δ' is coherent as well.
Case: [Link]
a[2..n] (x˜).P1 | a[2] (x˜).P2 | ··· | a[n] (x˜).Pn → (νκ˜)(P1[κ˜1/x˜] | P2[κ˜2/x˜] | ... | Pn[κ˜n/x˜])

Γ ▶ a[2..n] (x˜).P1 | a[2] (x˜).P2 | · · · | a[n] (x˜).Pn D Δ	By assumption Γ ▶ a[2..n] (x˜).P1 D Δ1 ... Γ ▶ a[n] (x˜).Pn D Δn where Δ = Δ1 ◦ ... ◦ Δn
and Δ1 = ... = Δn	By inversion on [Conc]
a : ⟨G⟩, Γ ▶ P1 D Δ1, x˜: (G †1)@1  |x˜| = max(sid(G))	By inversion on [Mcast]
a : ⟨G⟩, Γ ▶ P2 D Δ2, x˜: (G †2)@2, |x˜| = max(sid(G))	By inversion on [Macc]
...
a : ⟨G⟩, Γ ▶ Pn D Δn, x˜: (G †n)@n, |x˜| = max(sid(G))	By inversion on [Macc]
κ˜1 ∈/ dom (Δ1), ..., κ˜n ∈/ dom (Δn)	for every i ∈ {1, ..., n}.κ˜i are newly generated Γ ▶ P1[κ˜1/x˜] D Δ1, κ˜ : (G †1)@1		By Lemma A.4
...
Γ ▶ Pn[κ˜n/x˜] D Δn, κ˜ : (G †n)@n	By Lemma A.4
κ˜1 : (G †1)@1 = ... = κ˜n : (G †n)@n	By Definition 4.4
Γ ▶ P1[κ˜1/x˜] | P2[κ˜2/x˜] | ... | Pn[κ˜n/x˜]D
Δ1, κ˜1 : (G †1)@1 ◦ .... ◦ Δn, κ˜n : (G †n)@n	By rule [Conc]
Δ1, κ˜1 : (G †1)@1 ◦	◦ Δn, κ˜n : (G †n)@n =
Δ1 ◦ ... ◦ Δn, κ˜1 : (G †1)@1 ◦	◦ κ˜n : (G †n)@n
Γ ▶ (νκ˜)(P1[κ˜1/x˜] | P2[κ˜2/x˜] | ... | Pn[κ˜n/x˜]) D Δ	By rule [CRes]

Case: [Multicasting]
κ[m1, ..., mn]p!⟨e˜⟩; Pp | κm1 p1 ?(y˜); Pp1 | ··· | κmn pn ?(y˜); Ppn → P | Pp1 [v˜/y˜] | · · · | Ppn [v˜/y˜]
(p /= p1 /= ·· · /= pn , e˜ ↓ v˜)

Γ ▶ κ[m1, ..., mn]p!⟨e˜⟩; Pp | κm1 p1 ?(y˜); Pp1 | · · · | κmn pn ?(y˜); Ppn D Δ	By assumption Γ ▶ κ[m1, ..., mn]p!⟨e˜⟩; Pp D Δ1
Γ ▶ κm1 p1 ?(y˜); Pp1 D Δ2
.. .
Γ ▶ κmn pn ?(y˜); Ppn D Δn+1
where Δ = Δ1 ◦ ... ◦ Δn+1 and Δ1 = ... = Δn+1	By inversion on [Conc]
Δ1 = Δ' , κ˜p : m1, ..., mn!⟨S˜⟩; T @p	By rule [Send]
Δ2 = Δ' , κ˜p : m1?⟨S˜⟩; T1@p1	By rule [Rcv]
2	1
.. .

Δn+1 = Δ'
, κ˜pn
: mn?⟨S˜⟩; Tn@pn	By rule [Rcv]

Γ ▶ e˜ D S˜	Γ ▶ Pp D Δ' , κ˜p : T @p	By inversion on [Send]

Γ, y˜ : S˜ ▶ Pp
D Δ' , κ˜p
: T1@p1	By inversion on [Rcv]

1
.. .
Γ, y˜ : S˜ ▶ Ppn
2
'
n+1
1

, κ˜pn

: Tn@pn	By inversion on [Rcv]

Γ ▶ Pp [v˜/y˜] D Δ' , κ˜p : T1@p1	By Lemma A.3.1

1
.. .
Γ ▶ Ppn
2
[v˜/y˜] D Δ'
1

, κ˜pn : Tn@pn	By Lemma A.3.1

Γ ▶ Pp | Pp1 [v˜/y˜] | · · · | Ppn [v˜/y˜]
DΔ' , κ˜p : T @p ◦ Δ' , κ˜p : T1@p1 ◦ ... ◦ Δ'

, κ˜p : Tn@pn	By rule [Conc]

1	2	1	n+1	n
Δ' , κ˜p : T @p ◦ Δ' , κ˜p : T1@p1 ◦ ... ◦ Δ'	, κ˜p : Tn@pn =
1	2	1	n+1	n
Δ' ◦ ... ◦ Δ'	, κ˜p : T @p ◦ ... ◦ κ˜t : Tn@pn
1	n+1

Δ' ◦ ... ◦ Δ'
, κ˜p : m1, ..., mn!⟨S˜⟩.T @p ◦ κ˜p
: m1?⟨S˜⟩.T1@p1 ◦ ... ◦ κ˜t : mn?⟨S˜⟩.Tn@pn

1 '
→ Δ1
n+1
... ◦ Δ'
1
, κ˜p : T @p ◦ ... ◦ κ˜pn : Tn@pn	By [TR-Context, TR-Mult]



Case: [Multicasting]

κmp!⟨t˜⟩; Pp | κmp' ?(y˜); Pp' → Pp | Pp' [t˜/y˜]

Γ ▶ κmp!⟨t˜⟩; Pp | κmp' ?(y˜); Pp' D Δ	By assumption
Γ ▶ κmp!⟨t˜⟩; Pp D Δ1 Γ ▶ κmp' ?(y˜); Pp' D Δ2
where Δ = Δ1 ◦ Δ2 and Δ1 = .Δ2	By inversion on [Conc]
Δ1 = Δ' , κ˜p : m!⟨T ''@p''⟩; T @p, t˜: T ''@p''	By rule [Thr]
Δ2 = Δ' , κ˜p' : m?⟨T ''@p''⟩.T '@p'	By rule [Cat]
Γ ▶ Pp D Δ' , κ˜p : T @p	By inversion on [Send]
Γ ▶ Pp' D Δ' , κ˜p' : T '@p', y˜ : T ''@p''	By inversion on [Cat]
Γ ▶ Pp' [t˜/y˜] D Δ' , κ˜p' : T1@p', t˜: T ''@p''	By Lemma A.4
Γ ▶ Pp | Pp' [t˜/y˜] | D Δ' , κ˜p : T @p ◦ Δ' , κ˜p' : T '@p', t˜: T ''@p''	By rule [Conc]
1	2
Δ' , κ˜p : T @p ◦ Δ' , κ˜ : T '@p', t˜: T ''@p'' = Δ' ◦ Δ' , t˜: T ''@p'', κ˜p : T @p ◦ κ˜p' : T '@p'
1	2	1	2
Δ' ◦ Δ' , t˜: T˜''@p~'', κ˜p : m!⟨T ''@p''⟩; T @p ◦ κ˜p' : m?⟨T ''@p''⟩.T '@p' →
1	2
Δ' ◦ Δ' , t˜: T ''@p'', κ˜p : T @p ◦ κ˜p' : T '@p'	By [TR-Context, TR-MultD]
1	2
Case: [MultiLabel]
κ[m1, ..., mn]p Q li; P | κm1 p1 Q {lj : P1j}j∈I | · · · | κmn pn Q {lj : Pnj }j∈I → P | P1i | · · · | Pni

(p /= p1 /= ··· /= pn ,i ∈ I)
Γ ▶ κ[m1, ..., mn]p Q li; P | κm1 p1 Q {lj : P1j}j∈I | ··· | κmn pn Q {lj : Pnj}j∈I
DΔ	By assumption
Γ ▶ κ[m1, ..., mn]p Q li; P D Δ1
Γ ▶ κm1 p1 Q {lj : P1j }j∈I D Δ2
.. .


Γ ▶ κmn pn Q {lj : Pnj}j∈I D Δn+1 where Δ = Δ1 ◦ ... ◦ Δn+1
and Δ1 = ... = Δn+1	By inversion on [Conc]
Δ1 = Δ' , κ˜p : m1, ..., mn ⊕ {lj : Tj }j∈J @p	By rule [Sel]
Δ2 = Δ' , κ˜p : m1&{lj : T1j }j∈J @p1	By rule [Br]
2	1
.. .

Δn+1 = Δ'
, κ˜pn
: mn&{lj : Tnj}j∈J @pn	By rule [Br]

Γ ▶ P D Δ' , κ˜p : Ti@p and i ∈ J	By inversion on [Sel]

∀j ∈ J, Γ 1 P 1 D Δ' , κ˜ : T @p
By inversion on [Br]

.. .
▶ 1j
2  p	1j	1

∀j ∈ J, Γ ▶ Pnj
'
n+1
, κ˜pn
: Tnj @pn	By inversion on [Br]

Γ ▶ P | P1i | · · · | Pni D Δ' ◦ ... ◦ Δ'	, κ˜p : Ti@p ◦ ... ◦ κ˜p : Tn @pn	By rule [Conc]
1	n+1	1	n	i
Δ' , κ˜p : m1, ..., mn ⊕ {lj : Tj}j∈J @p, Δ' , κ˜p : m1&{lj : T1j}j∈J @p1, ...,

1
'
n+1
1
, κ˜pn
2
: mn&{lj : Tnj }j∈J @pn →

Δ' ◦ ... ◦ Δ'	, κ˜p : Ti@p ◦ ... ◦ κ˜p : Tn @pn	By [TR-Context, TR-MultL]
n+1	1	n	i

Case: [If1] and [If2] are trivial by induction. Case: [Def]
def D in (X⟨e˜⟩ | Q) →  def D in (P [v˜/y˜] | Q)	(e˜ ↓ v˜, X(y˜)= P ∈ D)
Γ ▶ def D in (X⟨e˜⟩ | Q) D Δ	By assumption
Γ,X : S˜T˜, y˜1 : S˜ ▶ P D y˜2 : T˜@~p, Γ,X : S˜T˜ ▶ X⟨e˜⟩ | Q D Δ

where y˜1 ∈ y˜ and y˜2 ∈ y˜
Γ,X : S˜T˜ ▶ X⟨e˜⟩ D Δ1 and Γ,X : S˜T˜ ▶ QD Δ2
By inversion on rule [Def]

where Δ = Δ1 ◦ Δ2 and Δ1 = Δ2	By inversion on rule [Conc]

Γ ▶ e˜1 D S˜ and Δ1 = Δ' , κ˜ : T˜@~p where κ˜, e˜1 ∈ e˜
By inversion on rule [Var]

Γ,X : S˜T˜ ▶ P [v˜/y˜] D κ˜ : T˜@~p	By Lemma A.3.1 and Lemma A.4 Γ,X : S˜T˜ ▶ P [v˜/y˜] D Δ' , κ˜ : T˜@~p		By Lemma A.3.2
Γ,X : S˜T˜ ▶ P [v˜/y˜] | Q D Δ' , κ˜ : T˜@~p ◦ Δ2 =Δ	By rule [Conc]
Γ ▶ def D in (P [v˜/y˜] | Q) D Δ	By rule [Def]


Case: [Par]

P → P ' ⇒  P | Q → P ' | Q

Γ ▶ P | QD Δ	By assumption
Γ ▶ P D Δ1 and Γ ▶ Q D Δ2 where Δ = Δ1 ◦ Δ2 and Δ1 = Δ2	By rule [Conc]

Γ ▶ P ' D Δ' where Δ1 = Δ' or Δ1 → Δ'
By induction

1  '	1	1
when Δ1 = Δ1 then the proof is trivial so we investigate the second case
when Δ1 → Δ'

Δ =  '
1
◦ Δ → Δ' ◦ Δ
By Lemma A.10 (1)

Δ1 and Δ1	2	1	2
Γ ▶ P ' | Q D Δ' ◦ Δ2	By rule [Conc]
Case: [Defin] is trivial by induction. Case: [Str]
P ≡ P ' and P ' → Q' and Q' ≡ Q  ⇒ P → Q
Γ ▶ P D Δ, P ≡ P ', P ' → Q' and Q', Q' ≡ Q		By assumption Γ ▶ P ' D Δ, P ' → Q' and Q', Q' ≡ Q	By Theorem A.11 Γ ▶ Q' D Δ, Q' ≡ Q			By induction
Γ ▶ QD Δ	By Theorem A.11
 
