

Electronic Notes in Theoretical Computer Science 173 (2007) 295–312
www.elsevier.com/locate/entcs

Relational Parametricity for Control Considered as a Computational Effect
Rasmus Ejlers Møgelberg, Alex Simpson1
LFCS, University of Edinburgh

Abstract
This paper investigates parametric polymorphism in the presence of control operators. Our approach is to specialise a general type theory combining polymorphism and computational effects, by extending it with additional constants expressing control. By defining relationally parametric models of this extended calculus, we capture the interaction between parametricity and control. As a worked example, we show that recent results of M. Hasegawa on type definability in the second-order (call-by-name) λμ-calculus arise as special cases of general results valid for arbitrary computational effects.
Keywords: Computational effects, control, denotational semantics, parametric polymorphism


Introduction
Relational parametricity [19] gives a powerful proof principle for establishing prop- erties of polymorphic programs. It has been widely studied in the context of the Girard/Reynolds second-order λ-calculus, which, in its pure form, is a calculus of total functions.
Trying to extend the notion of relational parametricity to richer calculi causes problems. Even recursion (and attendant nontermination) create difficulties, since the fixed-point property of recursion is incompatible with certain consequences of parametricity (the existence of finite coproducts). This issue led Plotkin to advocate adopting a linear type theory, in which such inconsistencies do not arise [18]. This approach has been worked out in detail in [4], and enjoys many good properties. For example, one obtains a wide class of polymorphic type definability results, with the desired universal properties following from relational parametricity.
Unfortunately, the approach of using linear type theory does not adapt to im- pure settings incorporating computational effects. In particular, a crucial aspect

1 This work was supported by the Danish Agency for Science, Technology and Innovation, and by EPSRC


1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.040

of linear logic, its monoidal closed structure, does not occur naturally in models for computational effects whose associated computational monads (in the sense of Moggi [15]) are not commutative.
One important example of a non-commutative monad is the continuations monad used to model control effects. For such effects, Hasegawa [6,7] has recently proposed a syntactic account of relational parametricity, and he has exploited this to obtain type definability results for a call-by-name version of Parigot’s second-order λμ- calculus [16]. An intriguing fact he observes is that his results on polymorphic type definability are analogous to ones that hold in Plotkin’s linear setting. However, the technical frameworks within which the two classes of results are developed are seemingly quite different.
The goal of the present paper, together with a companion paper [14], is to develop a unified semantic theory of relational parametricity, which is applicable to arbitrary computational effects, and which specialises, in the case of commutative effects, to linear parametricity, and, in the case of control, to a semantic version of Hasegawa’s account of parametricity.
The general framework we use to achieve this is presented in detail in the com- panion paper [14]. It takes the form of a polymorphic type theory loosely based on Levy’s call by push value paradigm [13], together with an associated semantic framework for defining relationally parametric models.
In the current paper, we focus on control. To this end, we extend the general type theory of [14] with extra constants which specialise it to control. The extension allows control-based program calculi to be interpreted in the type theory. We illus- trate this by giving a call-by-name translation of Parigot’s second-order λμ-calculus, closely following the formulation in [7].
The main technical effort in the paper is the construction of a relationally para- metric model of the extended type theory. Our goal is to exploit the model to show that Hasegawa’s results on type definability in the second-order λμ-calculus also hold in our setting. In fact, we show that they arise as special cases of general results valid for arbitrary computational effects. As well as providing an alternative (and denotational) account of Hasegawa’s results, this fact explains the reason that Hasegawa’s results mirror ones available in the setting of linear parametricity.

A type theory for polymorphism and control
We start by recalling the general type theory for polymorphism and effects (PE) as presented in [14], and specialising it to the case of continuations. The type theory for polymorphism and effects is based on Paul Levy’s call-by-push-value (CBPV) paradigm [13], in which types are separated into two groups: value types and compu- tation types. Following the convention of [13], we distinguish syntactically between the two kinds of type by using underlined metavariables A, B,... for computation types, as opposed to A, B,... for value types. The type theory PE allows for poly- morphic quantification over both kinds of type, and therefore types may contain type variables for value type, ranged over by X, Y,... or for computation types,

ranged over by X, Y , Z,.	Value types and computation types are defined by the
grammar
A, B ::= X | A → B | ∀X. A | X | A  B | ∀X. A A, B ::= A → B | ∀X. A | X | ∀X. A .
Notice that, in contrast to CBPV, our computation types constitute a subset of the value types. For discussion on this and other departures from CBPV, see [14]. Here we comment only on those features that will play a prominent role in our treatment of control.
There are two constructions for function types:  and →, and to distinguish the two we shall refer to the former as the linear function type. One semantic intuition of the type system is that computation types are algebras for a monad and value types are simply objects. Under this intuition → denotes ordinary function space and is the space of algebra homomorphisms, which does not in general carry an algebra structure so is a value type. Another somewhat different model will be presented in Section 4. Note that typing restrictions prevent the constructor from being iterated. For example, (A  B)  B' is not a valid type.
Terms are given by the grammar
t, s ::= x | λx : A.t | s(t) | ΛX. t | t(A) | λ◦x : A.t | ΛX.t 
Typing judgements are of the form Γ | Δ ▶ t : A, where Γ is a context of variables and Δ is a second variable context called the stoup which is either empty or con- sists of exactly one variable of computation type, in which case A must also be a computation type. The two cases are also sometimes written explicitly as
Γ |− ▶ t : A	Γ | x : B ▶ t : A .
The semantic intuition behind the stoup is that the term t, for all instantiations of the variables in Γ, denotes an algebra homomorphism from B to A. This is closely related to Levy’s notion of stack in CBPV [13].
The typing rules are given in Figure 1. We shall consider the equality theory on terms of the type theory given as the smallest congruence relation induced by the usual β and η rules for both types of term abstraction and both types of type abstraction, see Figure 2. Of course these equalities are to be understood as being between identically typed terms in the relevant contexts.
In [14], the type theory PE is studied as a generic calculus for combining poly- morphism and effects. Our purpose here is to specialise it to the case of control effects, as implemented by continuations monads. To motivate our approach, we recall that, in [14], the defined type construct
!A =def ∀X. (A → X) → X ,
which maps any value type A to a computation type !A, is shown to serve the purpose of Moggi’s type monadic type T A [15] (or, slightly more accurately, of





Γ, x : A |− ▶ x : A
Γ, x : A | Δ ▶ t : B


Γ | Δ ▶ λx : A. t : A → B
Γ | Δ ▶ s : A → B	Γ |− ▶ t : A

Γ | Δ ▶ s(t): B



Γ | Δ ▶ t : A

Γ | Δ ▶ ΛX. t : ∀X. A

X /∈ FTV(Γ, Δ)
Γ | Δ ▶ t : ∀X. A

Γ | Δ ▶ t(B): A[B/X]



Γ | x : A ▶ x : A
Γ | x : A ▶ t : B

Γ |− ▶ λ◦x : A. t : A  B
Γ | Δ ▶ t : A
X /∈ FTV(Γ, Δ)
Γ |− ▶ s : A  B	Γ | Δ ▶ t : A

Γ | Δ ▶ s(t): B
Γ | Δ ▶ t : ∀X. A


Γ | Δ ▶ ΛX. t : ∀X. A	Γ | Δ ▶ t(B): A[B/X]

Fig. 1. Typing rules for PE.


(λx : A. t)(u)= t[u/X]
λx : A. t(x)= t	if t : A → B and x ∈/ FV(t) (λ◦x : A. t)(u)= t[u/X]
λ◦x : A. t(x)= t	if t : A  B and x ∈/ FV(t) (ΛX. t) A = t[A/X]

ΛY .t Y = t	if t : ∀X. A and Y
(ΛX. t) A = t[A/X]
ΛY. t Y = t	if t : ∀X. A and Y
∈/ FTV(t)

∈/ FTV(t)


Fig. 2. Equality axioms for PE.


Levy’s free computation type construct F A [13]). In [14], a theory of relational parametricity is used to justify this encoding. As a consequence, one obtains a Girard decomposition: the types A → B and !A  B are isomorphic (as value types).
To encode control, we wish to specialise !A to be a continuations monad. One can formulate this by asking for a type constant R, to act as a result type, and requiring the type construction (A → R) → R to behave like !A. For this, the type expression (A → R) → R must be a computation type, hence so must the type constant R. Then the required properties of (A → R) → R can be implemented by requiring the canonical linear map !A  (A→ R) → R to have a linear inverse. By the Girard decomposition above, this is equivalent to asking for the canonical map
!A   (!A  R) → R to have a linear inverse.
Our actual approach to control is a natural generalisation of the above. Rather than restricting the last isomorphism above to types of the form !A, we ask for the canonical map A   (A  R) → R to be an isomorphism for every computation type A. Of course, the natural way to add such an isomorphism to the type theory is by adding a polymorphic constant. One direction of the isomorphism is directly

definable without any additions to the type theory:
η =def ΛX. λ◦x : X. λf : X   R. f (x): ∀X. X    (X  R) → R .
We thus extend the type theory with a constant
ϵ : ∀X. ((X  R) → R)   X ,

and equations ensuring that this constant is inverse to η. More precisely, using the notation ϵA for ϵ A and likewise ηA for η A, we add the equations
	

ΛX. λ◦x : X. ϵX(ηX (x)) = ΛX. λ◦ x : X.x 
ΛX. λ◦x : (X   R) → R. ηX(ϵX (x)) = ΛX. λ◦x : (X   R) → R. x.

We shall refer to this extension as the type theory for polymorphism and control, abbreviated as PE+C. Further motivation for the formulation of this theory can be found in Section 3, where it is used to model Parigot’s second-order λμ-calculus [16], and in Section 4, where the type constants and equations will be justified semanti- cally. We also mention that our use of the linear function space A  R is related to Levy’s use of stack types in his treatment of control in [13, §5.4], and our use of R is related to his use of an answer type in [13, Ch. 7]. Our combination of the two seems a very natural approach, since the requirement of having a linear isomorphism between A and (A  R) → R leads to a very simple equational theory. We now explore some simple equational properties of PE+C that follow from the βη laws and the isomorphism equations for control. First, the constant ϵ is
natural in linear maps in the sense that for any f : A  B, the diagram
(A   R) → R  ϵA	◦ A

(f   R) → R	f
◦	ϵB	◦
(B   R) → R ◦ B
commutes. This follows from the corresponding naturality of η, which is a simple consequence of the β and η rules.
Next, we show that, just from the βη equalities, one obtains a Girard decom- position of function spaces using (A → R) → R in place of !A. (Note that the cor- responding result for the polymorphic definition of !A depends upon parametricity properties.) For readability we introduce the notation ¬A for A → R.
Proposition 2.1 For any type A and computation type B in PE+C there is a bijective correspondence between terms of type A → B and terms of type ¬¬A B. The correspondence is natural in A for all maps and in B for linear maps.

Proof. The correspondence takes a term t : ¬¬A  B to λx : A. t(λf : ¬A.f (x)) and a term u : A → B to λ◦h : ¬¬A. ϵB(λf : B  R. h(f ◦ u)).	 

An important consequence of adding the constant ϵ to the type theory is that η
becomes split mono, which implies the following lemma.
Lemma 2.2 In PE+C the following principle holds. If t, t' : A are such that f (t)= 

f (t'), for a fresh variable f : A  R, then t = t'.
We end this section with another lemma that we need later.
Lemma 2.3 In PE+C if f : A   R and x : (A   R) → R then
x(f )= f (ϵA x)

Proof. Naturality of ϵ implies f (ϵA x)= ϵR(((f  R) → R)(x)). Now, by unique- ness of inverses to isomorphisms, ϵR(y)= y(id R), and so f (ϵAx)= x(f ) as desired. 

Interpreting second-order λμ-calculus in PE+C
The goal of this section is to show how the control primitives of PE+C support a natural interpretation of Parigot’s second-order λμ-calculus [16]. For this, we give a call-by-name translation, modelling the equational theory of [7].
We first recall the second-order λμ-calculus, λμ2. Generally, we follow the pre- sentation in [7], but extend the language slightly by introducing a falsity type, which allows us to break the control operations into name application and μ-abstraction. This is not a serious modification of the calculus. As shown in [7], see also Sec- tion 5, under an appropriate theory of relational parametricity, ⊥ can be encoded polymorphically as ∀X. X.
The types of λμ2 are given by the grammar
σ, τ ::= X |⊥ | σ → τ | ∀X. σ,
and terms are given by
M, N ::= x | M N | λxσ.M | M σ | ΛX. M | μα. M | [α]M.
We use x, y, z to range over ordinary variables and α, β, γ to range over continuation variables (sometimes called names). Typing judgements are written as
Γ ▶ M : σ | Δ,
where Γ is the context of ordinary variables, and Δ is a context of continuation variables. The typing rules of λμ2 are given in Figure 3.
We shall consider the equality relation on λμ2 terms given as the smallest con- gruence relation containing the axioms of Figure 4. The two last rules in Figure 4 use so-called mixed substitution. For example M [[β](−N )/[α](−)] means replace all subterms of M of the form [α]L with [β](L N ).



Γ,x : σ, Γ' ▶ x : σ | Δ
Γ,x : σ, Γ' ▶ M : τ | Δ Γ, Γ' ▶ λxσ.M : σ → τ | Δ

Γ ▶ M : σ → τ | Δ	Γ ▶ N : σ | Δ Γ ▶ M N : τ | Δ
Γ ▶ M : σ | Δ	X ∈/ FTV(Γ, Δ)

Γ ▶ ΛX. M : ∀X. σ | Δ

Γ ▶ M : ∀X. σ | Δ

Γ ▶ M τ : σ[τ /X] | Δ

Γ ▶ M : σ | Δ,α : σ, Δ'


Γ ▶ [α]M : ⊥| Δ, Δ'
Γ ▶ M : ⊥| Δ,α : σ, Δ' Γ ▶ μασ.M : σ | Δ, Δ'

Fig. 3. Typing rules for λμ2


(λxσ.M ) N = M [N/x]
λxσ.M x = M
(ΛX. M ) σ = M [σ/X] ΛX. M X = M
[α](μβ. M ) = M [α/β]
μα. [α]M = M (α ∈/ FN(M ))
(μασ→τ .M ) N = μβτ .M [[β](−N )/[α](−)]
(μα∀X.σ.M ) τ = μβσ[τ/α]M [[β](− τ )/[α](−)]

Fig. 4. Axioms for call-by-name λμ2
Our interpretation, denoted (−)∗, of λμ2 into PE+C is presented in Figure 5. Types of λμ2 are interpreted as computation types. A λμ2 typing context Γ = x1 : σ1,... xn : σn is interpeted as Γ∗ =def x1 : σ1∗,... xn : σn∗. For a continuation
context, Δ = α1 : σ' ,... αm : σ' , we use the notation Δ∗   R for the PE+C
1	m
context α1 : σ1∗  R,... αn : σ1∗  R.	The proposition below formulates the interpretation of typing judgements.
X∗ = X		⊥∗ = R	(σ → τ )∗ = σ∗ → τ ∗	(∀X. σ)∗ = ∀X. σ∗ x∗ = x	(λx : σ. M )∗ = λx : σ∗.M ∗	(M N )∗ = M ∗ N ∗
(ΛX. M )∗ = ΛX.M ∗	(M σ)∗ = M ∗σ∗
([β]M )∗ = β(M ∗)	(μασ.M )∗ = ϵσ∗ (λα : σ∗   R. M ∗)
Fig. 5. The interpretation of λμ2 into PE+C.

Proposition 3.1 (Type soundness) If Γ ▶ M : σ | Δ is a typed term in λμ2
calculus then the judgement below is well typed in PE+C.
Γ∗, Δ∗  R |− ▶ M ∗ : σ∗
Theorem 3.2 (Soundness) If Γ ▶ M1 = M2 : σ | Δ is provable using the equality rules of call-by-name λμ2 then PE+C proves:
Γ∗, Δ∗  R |− ▶ M ∗ = M ∗ .
1	2
Proof. The proof is by induction over the structure of the proof of M1 = M2. The interpretation is clearly sound with respect to the first half of the λμ2 axioms as the interpretation preserves the simply typed structure and the polymorphic structure. Consider the equality [β](μγ. M ) = M [β/γ].	By definition ([β](μγ. M ))∗ = β(ϵσ∗ (λγ. M ∗)), where σ is the type of γ, which by Lemma 2.3 is equal to M ∗[β/γ]= 
(M [β/γ])∗.
The rule μα. [α]M = M is sound because
(μα. [α]M )∗ = ϵσ∗ (λα. α(M ∗)) = ϵσ∗ (ησ∗ (M ∗)) = M ∗

We prove soundness of (μασ1 →σ2 .M ) N = μβσ2 .M [[β](− N )/[α](−)] by using Lemma 2.2. So suppose f : σ2∗ R. Then the function λ◦h : σ1∗ → σ2∗.f (h(N ∗)) is linear, so by Lemma 2.3
f ((μασ1 →σ2 .M ) N )∗ = f (ϵσ ∗→σ ∗ (λα : (σ1∗ → σ2∗)   R. M ∗)(N ∗))
= (λα : (σ1∗ → σ2∗)   R. M ∗)(λ◦h : σ1∗ → σ2∗.f (h(N ∗)))
= M ∗[f (−N ∗)/α(−)]
= (λβ : σ2∗   R. (M [[β](− N )/[α](−)])∗)f
= f (μβσ2 .M [[β](− N )/[α](−)])∗.

Soundness of the last rule (μα∀X.σ1 .M )σ2 = μβσ1 [σ2 /X].M [[β](− σ2)/[α](−)] is proved the same way.	 
Readers familiar with Reus and Streicher’s “negated domains” translation of the λμ calculus [22] may wonder how that translation is related to the one presented here. This question is also relevant for comparison with Hasegawa’s work [7] because he studies λμ2 calculus via a translation which is essentially a polymorphic extension of Reus and Streicher’s. In fact, our translation can be seen as a negated domains translation on the value types of the form A  R. For each λμ2 type σ, consider the PE+C value type σ† =def σ∗  R. Then σ† → R ∼= σ∗ and so, up to this isomorphism, any λμ2 term
x1 : σ1,... , xn : σn ▶ M : τ | α1 : σ' ,... , αm : σ'
1	m



is translated to a term
x1 : σ1† → R,... , xn : σn† → R, α1 : σ' †,... , αm : σ'


† ▶ M ∗ : τ † → R

1	m
If we add a product to the value types (as can be polymorphically encoded in the presence of parametricity) and an isomorphism X ∼= (X → R)  R for all value types X to PE+C we recover Hasegawa’s extension of Reus and Streicher’s interpretation since, for example,
(σ → τ )† ∼= ((σ† → R) → (τ † → R))  R ∼= ((¬σ†×τ †) → R)  R ∼= ¬σ†×τ † .

Relationally parametric models of PE+C
The aim of this section is to present a family of relationally parametric models for PE+C. Note that any such model will contain within it a relationally parametric model, in the usual sense, of the standard second-order λ-calculus, since this is a subsystem of the value types of PE. So it is natural to construct the model of PE+C over such a model.
Relationally parametric models of the second-order λ-calculus fall into just two known varieties: term models [8], and PER models. The latter can be viewed ex- plicitly as PER models [1], categorically as fibrations [3], or “synthetically” as full subcategories of the category of “sets” according to the internal logic of associated realizability toposes. Here, as in [14], we take the latter approach, since it allows us to work axiomatically and straightforwardly in intuitionistic set theory, performing simple set-theoretic constructions without getting encumbered by incidental techni- cal properties of the concrete models. Thus, henceforth we work in intuitionistic set theory (IZF). The reader who is unhappy with this, is urged to simply bear with us and to follow the development classically. In theory, following Reynolds [20], such reader will be able to exploit classical logic to derive an inconsistency. However, this awkward fact is unlikely to get in the way of obtaining a general understanding. We start by recalling the (somewhat involved) structure required for a model of PE in [14]. We assume that we are given a full subcategory C of the category Set
of sets that will be used to interpret value types. This is required to satisfy:
(C1) If A ∈C and A ∼= B in Set then B ∈ C.
(C2) For any set-indexed family {Ai}i∈I of sets in C, the set-theoretic product

i∈I
Ai is again in C.

(C3) Given A, B ∈ C and functions f, g : A → B, the equalizer {x ∈ A | f (x) = 
g(x)} is again in C.
(C4) There is a set C of objects of C such that, for any A ∈ C, there exists B ∈ C
with B ∼= A.
By items (C2) and (C3), the category C is complete with limits inherited from Set. Since function spaces are powers, for any set A and any B ∈ C, the function space BA is in C, i.e. C is an exponential ideal of Set. In particular, C is cartesian closed.

The last axiom states that C is weakly equivalent to a small category. This allows one to show that C is also cocomplete, by an application of Freyd’s adjoint functor theorem, cf. [9].
Computation types are modelled using a category A together with a functor U : A→ C satisfying the axioms below. For the moment, the intuition will be that A is the category of algebras for a monad on C, and U is the forgetful functor. However, soon we shall see a rather different example of model when we consider the case of control. The axioms required for A and U are:
(A1) U “weakly creates limits” in the following sense. For every diagram Δ in A and limiting cone lim U (Δ) of U (Δ) in C, there exists a specified limiting cone lim Δ of Δ in A such that U (lim Δ) = lim U (Δ).
(A2) U reflects isomorphisms (i.e. if Uf is an isomorphism then so is f ).
(A3) For objects A, B  of A, the hom-set A(A, B) is an object of C.
(A4) There exists a set A of objects of A such that, for every object A of A, there exists B ∈ A with A ∼= B in A.
Although the above axioms do not force the category A to be a category of algebras for a monad on C, for convenience and intuition, we shall nonetheless call the objects of A algebras. Since the axioms imply that U is faithful, we can identify A(A, B) with a collection of special functions from UA  to UB  which we call homomorphisms, and we shall write f : A  B to mean that f is a homomorphism from UA  to UB. We write A ∼=◦ B if A and B are isomorphic as objects of A.
For an object A of C, we write SubC(A) for the set {B ⊆ A | B ∈ C}, which gives a canonical representation for the set of C-subobjects of A. Axioms (A1) and (A2) imply that U is an injective map from A-subobjects of A ∈A to C-subobjects of U A. Accordingly, we can define
SubA(A) =def {B ⊆ UA  | B ⊆ UA  is the image of an A-subobject of A}
as a representation of the set of A-subobjects of A.
For the construction of the parametric model, we will assume that we are given, as extra data, two collections of “admissible” relations, which we shall use to for- mulate the principle of relational parametricity. More precisely, for each pair of objects A, B of C, we require a specified set of admissible C-relations RC (A, B) ⊆ SubC(A × B), and for each pair of objects A, B  of A, we require a specified set of admissible A-relations RA(A, B) ⊆ SubA(A × B). Moreover, these collections of relations are required to satisfy some closure properties, which we now define.
For A ∈ C, we write ΔA for the diagonal (identity) relation in SubC(A × A). Similarly, for A ∈ A, we write ΔA for the diagonal relation on U A, which is indeed in SubA(A × A). For f : A' → A, g : B' → B in C and R ∈ SubC(A × B) we write (f, g)−1R for {(x, y) | (f (x), g(y)) ∈ R}, which is an element of SubC(A' × B'). Note that if f : A'  A,g : B'  B and Q ∈ SubA(A × B) then (f, g)−1Q is an element of SubA(A' × B').
We impose the following requirements on admissible relations.

(R1) For each object A of C the diagonal relation ΔA is in RC(A, A) and likewise for each object A of A the diagonal ΔA is in RA(A, A).
(R2) Admissible relations are closed under inverse image, i.e., if R ∈ RC(A, B) and
f : A' → A, g : B' → B, then (f, g)−1R ∈ RC(A', B') and if Q ∈ RA(A, B) and
f : A'   A, g : B'   B, then (f, g)−1Q ∈ RA(A', B')
(R3) For any set of admissible C- (respectively A-)relations on the same pair of objects, the intersection is an admissible C- (respectively A-)relation.
(R4)  RA(A, B) ⊆ RC(UA,UB).
Notice that axioms (R1) and (R2) imply that graphs of functions are admissible, specifically if f : A → B then ⟨f ⟩ =def {(x, y) | f (x) = y} ∈ RC(A, B) and if g : A  B then ⟨g⟩ ∈ RA(A, B).
There are many ways of constructing models for axioms (C), (A) and (R). A motivating construction is to take C to be any full reflective subcategory of a real- izability topos that is weakly small (see [9,11] for how to produce such categories). Then for any (internal) monad on C, take A to be the category of (Eilenberg- Moore) algebras for the monad. Finally, take RC(A, B) and RA(A, B) to simply be SubC(A × B) and SubA(A × B) respectively. A more sophisticated example, exploiting the flexibility in specifying the admissible relations, appears below.
We briefly consider the interpretation of PE in the above structure, giving an overview sufficient for understanding this paper. For full details see [14].
Value types are interpreted in the category C and computation types are in- terpreted as objects in the category A. We shall write C[[−]] and A[[−]] for these interpretations respectively. Since any computation type A is also a value type, it is given two interpretations which satisfy U (A[[A]]) = C[[A]].
The type constructor → is interpreted as set-theoretic function space and is interpreted as the set of homomorphisms between the algebras assigned to the computation types. The computation type A → B is interpreted, using weak limit creation, as an algebra A for which UA  is the set of functions from C[[A]] to C[[B]]. In order to give a relationally parametric interpretation of polymorphic types, the type constructors are also given relational interpretations. For example, if R ∈ RC(A, B) and R' ∈ RC(A', B') then R → R' is the relation
{(f, g) ∈ (A → A') × (B → B') | ∀x : A, y : B. (x, y) ∈ R ⊃ (f (x), g(y)) ∈ R'},
and if Q ∈ RA(A, B) and Q' ∈ RA(A', B') then Q   Q' is the relation
{(f, g) ∈ (A   A') × (B   B') | ∀x : U A,y : UB. (x, y) ∈ Q ⊃ (f (x), g(y)) ∈ Q'}.
Polymorphic types are interpreted by taking products over C and A respectively, and restricting to parametric elements of the product. This restriction to parametric elements is with respect to parametricity formulated with respect to relations in RC when quantifying over value types and with respect to relations in RA when quantifying over computation types. As an illustrative example, which we shall need later, for a closed computation type B, the type ∀X. ((X   B) → B)   X is

interpreted as the object of A given by
{(fA)A∈A ∈  A∈A((A  A[[B]]) → A[[B]])  A | ∀A, B  ∈ A. ∀Q ∈ RA(A, B).
(fA, fB) ∈ ((Q  ΔA[[B]] ) → ΔA[[B]] )  Q}.
(1)
Finally, we briefly recall the interpretation of terms. For simplicity we restrict to the case in which types are closed. A well-typed term Γ | Δ ▶ t : B is interpreted as an element [t]]γ of C[[B ] relative to an environment γ mapping each variables x : A in Γ | Δ to an element γ(x) ∈ C[[A ]. In the case of Δ being non-empty, the mapping d ∈ C[[A]] '→ [[t]]γ[d/x] is a homomorphism from A[[A]] to A[[B ] for any environment γ. For the full interpretation of terms involving open types, see [14].
Having now presented the semantic structure needed to model PE, we at last turn to the issue of, in addition, modelling our constructs for control. Since there is no avoiding having a parametric model of second-order λ-calculus, we begin with an arbitrary category C satisfying the (C) axioms above. Let R be any object of C, chosen as a result type. In order to satisfy our axioms, one would like to implement the equation:
U	op	R(−)
A	) C	=def	C	) C ,
which fits in with an established tradition in continuations models, cf. [25,24,13]. Indeed, in such a structure, one would interpret the computation type constant R by A[[R]] =def 1 and C[[R]] =def R1 ∼= R. Then, for any object A of A, and hence of C, one would have A[[(A  R) → R]] ∼=◦ A,because C[[A  R]] ∼= A(A, 1) = C(1, A), hence C[[(A  R) → R]] ∼= RA = U (A), where the isomophism is indeed a homomorphism.
However, although the category Cop does satisfy axioms (A3) and (A4) above, the functor R(−) : Cop → C does not necessarily satisfy axioms (A1) and (A2). Accordingly, we modify the construction so that these axioms are satisfied.
First we address the reflection of isomorphisms. Although R(−) : Cop → C need not reflect isomorphisms on all of C, there exists a largest full reflective subcategory of C on which it does.
Definition 4.1 [10,23]A set C in C is called R-replete if for all maps f : A → B in
C, if the map Rf : RB → RA is an isomorphism then so is Cf : CB → CA.
We denote by Crep the full subcategory of C on replete objects. It is standard, cf. [10,23], that the replete objects are closed under limits in Set and so Crep satisfies (C1)–(C3). It also satisfies (C4) as we can take Crep =def {C ∈ C | C replete}. Trivially the object R is itself replete, and hence any power RA is also replete.
As a second attempt at constructing a model we replace (4) with:
U	op	R(−)
A 	) Crep	=def	Crep		) Crep ,
However, there remains a technical issue concerning satisfaction of (A1). As re- marked earlier, the axioms (C1)–(C4) imply cocompleteness, and so Crepop is com-

plete. Moreover, the functor R(−) preserves limits since it has a left adjoint (also given by R(−)). Still R(−) : Crepop → Crep does not weakly create limits in the sense of (A1), since a given limiting cone in Crep of a diagram of the form RΔ need not be in the image of the functor R(−) up to equality. We address this by considering

instead of C
op the equivalent category A (and this is our final redefinition of A):

Objects: Triples (A, i, P ), where A, P are objects in Crep and i : P → RA is an isomorphism.
Morphisms: A morphism from (A, i, P ) to (B, j, Q) is a map f : B → A.
We define the functor U : A → C to map the morphism f : (A, i, P ) → (B, j, Q) to

j−1 ◦ Rf ◦ i : P → Q. Clearly there exists an equivalence of categories between C
and A making the diagram
op rep

Crepop	) A





Crep
commute up to natural isomorphism, but U : A → Crep does have the property of weakly creating limits in the sense of (A1).
Proposition 4.2 The functor U : A→ Crep satisﬁes (A1)–(A4).
Before discussing admissible relations in this model we write out the inter- pretation of the non-polymorphic types of PE+C. If A[[A]] = (A, i, C[[A]]) and A[[B]] = (B, j, C[[B]]) then

A[[R]] = (1,R ∼= R1, R)
C[[A → B]] = C[[B]]C[[A]]
C[[A  B]] = AB
A[[A → B]] = (B × C[[A]], h, C[[B]]C[[A]])
where h is jC[[A]] composed with the isomorphism (RB)C[[A]] ∼= RB×C[[A]].
Finally, we consider how to define admissible relations. The type theory PE+C introduces the isomorphism (X  R) → R ∼=◦ X via a polymorphic constant of type
∀X. ((X  R) → R)  X inverse to η. By (1), for this inverse to be parametric, we must have, for any Q ∈ RA(A × B),
(ηA, ηB)−1((Q   ΔR) → ΔR)= Q.	(2)
This forces us to consider, as our notion of admissible relation, the collection of relations Q satisfying (2). Fortunately, (ηA, ηB)−1((Q  ΔR) → ΔR) has a familiar

looking alternative description as QTT defined as
QT = {(f, g): (A   R) × (B   R) | ∀x : U A,y : UB. (x, y) ∈ Q ⊃ f (x)= g(y)}
QTT = {(x, y) ∈ UA  × UB  | ∀f : A   R, g : B   R. (f, g) ∈ QT ⊃ f (x)= g(y)}

The (−)TT construction defines a closure operator in the sense that it is increasing (Q ⊆ QTT), idempotent and monotone with respect to the inclusion ordering, and we shall call a relation (−)TT-closed if QTT = Q. The (−)TT-closure is a familiar construction in the theory of parametricity, studied extensively by Pitts in an operational setting [17,2]. The technique also appears to be a general and powerful one from a denotational perspective, cf. [12].
Finally, we define:
RC(A, B) = SubC(A × B)
RA(A, B) = {Q ∈ SubA(A × B) | Q = QTT}


Proposition 4.3 Axioms (R1)–(R4) for admissible relations hold.
Proof. The interesting point is that, for any A ∈ A, the identity relation ΔA is (−)TT closed. This is easily seen to be equivalent to the following linear separation property: for all x, y ∈ UA, if f (x) = f (y) for all f : A  R, then x = y; and this, in turn, is equivalent to the canonical function ηA : A  (A  R) → R being injective. However, we showed above that this function is an isomorphism. 
Theorem 4.4 The structure deﬁned above is a model of PE+C.
Proof. Most of this theorem follows from Propositions 4.2 and 4.3. It remains to prove that this model of PE also models the polymorphic inverse to η. Since each ηA has an inverse ϵA we just need to show that this collection constitutes an element in the parametric model, i.e., that for any (−)TT closed relation Q between algebras A, B, the pair (ϵA, ϵB) maps elements related in (Q  ΔR) → ΔR to elements related in Q. But this happens iff (ηA, ηB)—1((Q  ΔR) → ΔR)= Q which holds for (−)TT closed relations Q since QTT = (ηA, ηB)—1((Q  ΔR) → ΔR). 

Polymorphic type encodings in λμ2
By composing the interpretation from λμ2 into PE+C with the interpretation of PE+C into any model as defined in the previous section, we get a parametric model of λμ2. In this section we study polymorphic λμ2 type encodings in such models, and compare with Hasegawa’s parametricity results for λμ2 [7].
The composite translation interprets types σ of λμ2 as objects A[[σ∗]] in A, but terms t : σ → τ of λμ2 are interpreted not as homomorphisms but as general maps from U (A[[σ∗]]) to U (A[[τ ∗ ]) (recalling that U (A[[A]]) = C[[A ]). For the following

discussion it is therefore convenient to introduce the category A!, with the same objects as A, i.e., triples (A, i, P ) consisting of replete objects A, P and an isomor- phism i : P → RA. A morphism from (A, i, P ) to (B, j, Q) is simply a map from P to Q. Note that the category A! is equivalent to the full subcategory of Set on the objects of the form RA for A in Crep. This is called the category of “negated domains” by Reus and Streicher [22], and indeed our interpretation of λμ2 in A! can be seen as a polymorphic extension of their interpretation of (simply-typed) λμ. Alternatively, one can view our interpretation as a polymorphic extension of Selinger’s [21], since A! is a control category in the sense of op. cit.
The category A embeds into A! by mapping a morphism from (A, i, P ) to (B, j, Q) given by f : B → A to j—1 ◦ Rf ◦ i. We shall call a term t : σ → τ of λμ2 linear if it is interpreted in the model as a homomorphism.
Our goal in this section is to uncover the universal properties of polymorphic type encodings in λμ2 that are induced by our relationally parametric model. All the examples we consider are taken from Hasegawa’s paper [7]. We obtain the same universal properties with respect to the category of linear maps that he obtains for his “focal” maps. The main point we wish to emphasise is that our results fall out as instances of general definability results valid for any model of PE, and hence as instances of principles that are valid for arbitrary computational effects [14].
Example 5.1 The λμ2 type ∀X. X is interpreted as an initial object in A. Indeed, for any type σ, the term λx : ∀X. X. x σ defines the unique linear map from ∀X. X to σ. This is an immediate consequence of the following general fact, cf. [14]. In any parametric model of PE, the computation type ∀X. X  is interpreted as the initial object in A, with the unique linear map given in the evident way.
Note that the λμ2 type ⊥ is also interpreted as an initial object in A (the object (1,R ∼= R1, R) is obviously initial). So relational parametricity yields the polymor- phic definability of ⊥ in λμ2. This fact can be used to justify omitting ⊥ as a primitive type constant in λμ2, and using the polymorphic type ∀X. X in its place, as, in fact, is done in [7].
An analogous observation applies to the formulation of PE+C. In any para- metric model of PE+C, the type constant R is interpreted as the initial object of
A. Thus the constant R could have simply been omitted from PE+C, and the isomorphisms formulated using the computation type ∀X. X  in its place.
Example 5.2 The λμ2 type ∀X. (σ → X) → X, where X is not free in σ, is given an interpretation that is linearly isomorphic to the interpretation of ¬¬σ. In λμ2, the canonical terms of type σ → ∀X. (σ → X) → X and (∀X. (σ → X) → X) → σ are not isomorphisms. Rather they respectively correpond to the unit for the double negation monad and double negation elimination in the control category A!.
The above properties follow from the general fact [14] that, in any parametric model of PE, the type !A = ∀X. (A → X) → X is interpreted as the free A-object over the set C[[A ]. In any model of PE+C, this specialises to C[[!A]] ∼=◦ ¬¬C[[A]], cf. the motivating discussion for the control isomorphisms in Section 2.


C[[(∀X. X → X)∗]] ∼=◦ RR

C[[(∀X. (σ → X) → (τ → X) → X)∗]]
∼=◦
RC[[σ∗]] ×RC[[τ ∗]]
(X /∈ FTV(σ, τ ))

C[[(∀X. (σ → τ → X) → X)∗]]
∼=◦
C[[σ∗]]
R
C[[τ ∗]]
× R
(X /∈ FTV(σ, τ ))

C[[(∀Y. (∀X. (σ → Y )) → Y )∗]] ∼=◦ C[[∃◦X. ¬¬σ∗]]	(Y /∈ FTV(σ))

Fig. 6. Interpretation of λμ2 types in the model
Example 5.3 Suppose σ is a type expression of λμ2 with type variable X occuring only positively. As is standard, this type induces an endofunctor on A!. One can check, by induction on the structure of σ, that this functor cuts down to one acting on the category of linear maps A.
In the pure second-order λ-calculus, the type ∀X. (σ → X) → X is an initial algebra for the functor induced by σ. However, in our model of λμ2, the type
∀X. (σ → X) → X is instead an initial algebra for the functor induced by the type
¬¬σ on the linear category A. Moreover, all the necessary structure is definable in λμ2, i.e., the structure map of the initial algebra can be defined as a linear map in λμ2, and likewise the term giving the unique algebra map out of a given algebra. Detailed definitions appear in [7].
The above facts are a conseqence of the following general property of PE mod- els, cf. [14]. For any computation type A with free computation type variable X occurring only positively, the induced functor on A, has its initial algebra μ◦X. A given by the computation type ∀X. (A  X) → X. Then in PE+C we have (∀X. (σ → X) → X)∗ = ∀X. (σ∗ → X) → X, which is isomorphic to μ◦X. ¬¬σ∗ =
∀X. (¬¬σ∗   X) → X.
A few more examples of interpretations of λμ2 types are presented in Figure 6, where the notation ∃◦X. A represents an existential computation type, see [14]. The stated isomorphisms again follow from general properties of PE models.
While the results we have presented above all follow those of Hasegawa [7], there is a difference in the formulation. We have obtained universal properties relative to our semantic notion of linear map, whereas Hasegawa obtained them with respect to a syntactically defined notion of “focal map”. Here the semantic/syntactic distinction is not crucial. We could equally well have used our translation from λμ2 to PE+C to define a syntactic notion of linear map in λμ2 (and, in effect, this is anyway how our proofs that various terms were linear proceed). Conversely, one can immediately apply the definition of focal map in our semantic setting to obtain a subcategory of focal maps within A!. Doing this, one obtains that every linear map is focal, but the converse holds if and only if the continuation monad RR(−) on C satisfies Moggi’s equalising requirement [15]. The equalising requirement seems a difficult condition to enforce for continuations monads in semantic categories modelling parametric polymorphism. For example, in [5], it is shown that the equalising requirement can fail in the category of R-replete objects. Thus, we feel that our stricter notion of linear map is the more natural one in our semantic setting.

Acknowledgement
We thank Masahito Hasegawa and Paul Levy for helpful discussions.

References
E.S. Bainbridge, P.J. Freyd, A. Scedrov, and P.J. Scott. Functorial polymorphism. Theoretical Computer Science, 70:35–64, 1990.
G. M. Bierman, A. M. Pitts, and C. V. Russo. Operational properties of Lily, a polymorphic linear lambda calculus with recursion. In Fourth International Workshop on Higher Order Operational Techniques in Semantics, Montr´eal, volume 41 of Electronic Notes in Theoretical Computer Science. Elsevier, September 2000.
L. Birkedal and R. E. Møgelberg. Categorical models of Abadi-Plotkin’s logic for parametricity.
Mathematical Structures in Computer Science, 15(4):709–772, 2005.
L. Birkedal, R. E. Møgelberg, and R. L. Petersen. Linear Abadi & Plotkin logic. Logical Methods in Computer Science, 2, 2006.
G. Gruenhage and T. Streicher. Quotients of countably based spaces are not closed under sobrification.
Math. Struct. in Comp. Sci., 16:223–229, 2006.
M. Hasegawa. Relational parametricity and control. In Proceedings Twentieth Annual LiCS Symposium, pages 72–81, 2005.
M. Hasegawa. Relational parametricity and control. Logical Methods in Computer Science, 2, 2006.
R. Hasegawa. Parametricity of extensionally collapsed term models of polymorphism and their categorical properties. In Takayasu Ito and Albert R. Meyer, editors, Proceedings of Theoretical Aspects of Computer Software.(TACS ’91), volume 526 of LNCS, pages 495–512. Springer, September 1991.
J.M.E. Hyland. A small complete category. Annals of Pure and Applied Logic, 40(2):135–165, November 1988.
J.M.E. Hyland. First steps in synthetic domain theory. In A. Carboni, M.C. Pedicchio, and G. Rosolini, editors, Proceedings of the 1990 Como Category Theory Conference, volume 1488 of Lecture Notes in Mathematics, pages 131–156. Springer, Berlin, 1991.
J.M.E. Hyland, E.P. Robinson, and G. Rosolini. The discrete objects in the effective topos. Proc. London Math. Soc., 3(60):1–36, 1990.
S. Katsumata. A Semantic Formulation of TT-lifting and Logical Predicates for Computational Metalanguage. In Proc. CSL 2005. LNCS 3634, pp. 87–102, 2005.
P. Levy. Call By Push Value, a Functional/ Imperative Synthesis. Kluwer, December 2003.
R.E. Møgelberg and A.K. Simpson. Relational parametricity for computational effects. Submited manuscript, 2007.
E. Moggi. Notions of computation and monads. Information and Computation, 93:55–92, 1991.
M. Parigot. Proofs of strong normalisation for second order classical natural deduction. Journal of Symbolic Logic, 62(4):1461–1479, 1997.
A.M. Pitts. Parametric polymorphism and operational equivalence. Mathematical Structures in computer Science, 10:321–359, 2000.
G.D. Plotkin. Type theory and recursion (extended abstract). In Proceedings, Eighth Annual IEEE Symposium on Logic in Computer Science, page 374, Montreal, Canada, 19–23 June 1993. IEEE Computer Society Press.
J.C. Reynolds. Types, abstraction, and parametric polymorphism. Information Processing, 83:513–523, 1983.
J.C. Reynolds. Polymorphism is not set-theoretic. In G. Kahn, D. B. MacQueen, and G. D. Plotkin, editors, Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, pages 145–156. Springer-Verlag, 1984.
P. Selinger. Control categories and duality: On the categorical semantics of the lambda-mu calculus.
Mathematical Structures in Computer Science, 11(2):207–260, 2001.


T. Streicher and B. Reus. Classical logic, continuation semantics and abstract machines. Journal of Functional Programming, 8(6):543–572, 1998.
P. Taylor. The fixed point property in synthetic domain theory. In 6th Annual Symposium on Logic in Computer Science, pages 152–160, Washington, 1991. IEEE Computer Society Press.
P. Taylor. Sober spaces and continuations. Theory and Applications of Categories, 10(12):248–300, 2002.
H. Thielecke.	Categorical Structure of Continuation Passing Style. Phd thesis, Laboratory for Foundations of Computer Science, Univ. of Edinburgh, 1997.
