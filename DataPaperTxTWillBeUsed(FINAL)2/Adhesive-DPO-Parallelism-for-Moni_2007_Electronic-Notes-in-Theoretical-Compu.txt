Electronic Notes in Theoretical Computer Science 175 (2007) 51–61	
www.elsevier.com/locate/entcs

Adhesive DPO Parallelism for Monic Matches
Filippo Bonchi, Tobias Heindel
Dipartimento di Informatica, Universita` di Pisa, Italy

Abstract
This paper presents indispensable technical results of a general theory that will allow to systematically derive from a given reduction system a behavioral congruence that respects concurrency. The theory is developed in the setting of adhesive categories and is based on the work by Ehrig and K¨onig on borrowed contexts; the latter are an instance of relative pushouts, which have been proposed by Leifer and Milner. In order to lift the concurrency theory of dpo rewriting to borrowed contexts we will study the special case of dpo rewriting with monic matches in adhesive categories: more specifically we provide a generalized Butterfly Lemma together with a Local Church Rosser and Parallelism theorem.
Keywords: Adhesive category, behavioral congruence, borrowed context, dpo


Introduction and Motivation
Process calculi are a well established tool to describe interactive systems. The progression of a process, if it is interpreted as a closed system, is described by a reduction system (rs); moreover each process is a state of a labeled transition system (lts), which describes how the process may interact with its environment: in this case the process is thought of as an open system. Also the the double pushout approach (dpo) can be used to model closed and open systems: a reduction step corresponds to a dpo rewrite while interaction with the environment is described as a transition that is labeled by a borrowed context, which is a part of the environment. One of the advantages of the dpo approach is that one can distinguish between concurrent and necessarily interleaved events of a closed system. Now the main motivation of this paper to lift this advantage to the setting of open systems, i.e. to provide ltss with labels that describe concurrent interaction with the environment. One of the first approaches to derive a lts from a given rs, was presented in [13].
The transitions of the generated lts are labeled by the “minimal” contexts that allow a reduction (as a consequence all the internal actions of a system correspond

1 This work is partially supported by the SegraVis research training network, the IST 2004-16004 SEn- SOria, and the MIUR PRIN 2005015824 ART.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.04.016


which has the reduction rule x¯.P | x.Q → P | Q, the process a¯.0 cannot perform to transitions which have the “empty” environment as label). For example in ccs, any reduction by itself but can only be reduced in a context of the form [−] | a.P :

hence the derived lts contains a transition a¯.0 −[−−−]|a−.→P
P . The main property of the

derived lts is that its associated bisimulation relation is a congruence, i.e. it relates two processes that exhibit the same behavior w.r.t. to every environment. However to check bisimilarity one does not need to check all contexts but it is enough to consider the “minimal” ones, which are given as the labels.
Leifer and Milner’s work [13] has been extended to an enriched category con- text by Sassone and Sobocinski in [14], while Ehrig and Ko¨nig developed a similar framework for dpo rewriting (on Graphs) in [6], called borrowed context rewrit- ing (dpobc). Finally [15] introduces an encompassing theory (following the bi- categorical approach of dpo rewriting of [7,8]). The results of this last most general work apply to every adhesive category. This means that given a system specifica- tion by an adhesive rewriting system [12] one can generate a lts with an associated bisimulation congruence.
Whereas rss and ltss are (families of) relations between states of a system, the concurrency theory for dpo rewriting is concerned with relations between the tran- sitions, i.e. the rewrites (see e.g. [10,1]). For example two consecutive applications of

the rule ◦	← ◦	→ ◦
w
may result in the graph ◦  . The two rewrites are sequential

independent, i.e. one can swap them without any further complications; moreover
one can even apply them “at the same time”, that is concurrently: the concurrent

application corresponds to a single application of the parallel rule ◦	← ◦
w
→ ◦  .

In contrast, consider a coffee vending machine: it can sell a coffee and then a latte
macchiato or do this in the reversed order but not at the same time (unless you operate a buggy machine which produces a puddle of cappuccino as the result of the concurrent execution). The latter example explains the difference between the

two ccs processes c¯ | m¯
and c¯.m¯ + m¯ .c¯, which nevertheless are equivalent according

to the standard bisimulation of ccs. Also the generated ltss discussed before do
not take into account these finer differences in behavior.
This paper is aimed towards the generation of bisimulation congruences that do respect concurrency. Here we report about the first steps of research in this direction. The main idea is to saturate a given set of productions with all parallel productions and then apply the borrowed context method to generate a bisimulation congruence that respects concurrency. More specifically, given an initial set of rules
results of [15]; the set P¯ contains for every (finite) subset P ' ⊆ P and every way in P , we will construct a saturation P¯ that will be used to synthesize a lts using the which the members of P ' might be applied concurrently the corresponding parallel
production.
One central issue is the apropriate notion of parallel rule. Parallel rules are usually defined as coproducts in dpo; but this construction cannot be used in dpobc since there, matching morphisms are required to be monic. The required notion of parallel rule is given in [10], which studies dpo rewriting with monic matches (dpoa/i), for the case of Graphs. However this work cannot be directly adapted

to the adhesive setting since the proofs of its results depend on coproducts, which adhesive cateogries do not have in general.
Local Church Rosser and Parallelism for dpoa/i
We first recall the essential definitions of dpo rewriting in adhesive categories as presented in [12], to which we refer the reader for more details. For the remainder of this section we fix an adhesive category C, to which all mentioned objects and arrows belong.
Definition 2.1 (Productions and rewriting)

A production p is a span of arrows p = L ←−l< K −→ R with
L	l K r	R

monic l. Given an arrow f : L → C we say that p rewrites
(f,p⟩
C to D at match f, and we write C ===⇒ D if there exists a
diagram containing two pushouts as shown on the right.
f	g	h
C	v E w  D

In the theory of borrowed contexts in adhesive categories, one only encounters the
special case where the matching morphism f is monic, and hence from now on we will assume all matches to be monic. This fragment of dpo rewriting in the category of Graphs has been studied in [10] by the name dpoa/i. Their results involve the strong versions of sequential and parallel independence.
Definition 2.2 ((Strong) parallel and sequential independence)	Let

be given productions pi
= Li
←−li< K  −r→i
Ri for i ∈ {1, 2} and let there be given

(f1 ,p1⟩
(f2 ,p2⟩
(f1,p1 ⟩
(f ' ,p2⟩

the rewrites D1 ⇐==== C ====⇒ D2 (C ====⇒ D1 ==2==⇒ D). They are parallel
(sequential) independent, if there exist morphisms s and t (s' and t') such that they
commute in the composed diagram of the rewrites below.



R1
⎛	⎞
R2	L1 			R2
⎜	⎟

⎜  f1	⎟

D1 w1
t
D2	⎜ C	v1
t
D ⎟⎠

They are strongly parallel (sequential) independent if w1 ◦ t and w2 ◦ s (v1 ◦ t' and
w3 ◦ s') are monic.
In [10] the Parallelism theorem for dpoa/i for the case of Graphs has been proven.
However the proof cannot be lifted directly to adhesive categories since it depends on the existence of coproducts. Moreover the Parallelism theorem for adhesive categories with coproducts presented in [12], does not transfer to dpoa/i.

Technical contribution
The main idea is to replace coproducts, which are just pushouts from the empty graph in Graphs, by pushouts. This will allow us to make the dpoa/i theory of [10] available for adhesive categories. How coproducts can be replaced by pushouts will be explained in terms of the next definition.

Definition 2.3 Let the following squares be pushouts:


Q
x2	x1
A2	A1
y2  Q  y1
B2	B1 .

	
Then we will denote A by A1 +Q A2 and B by B1 +Q B2.

Let f1 and f2 be two morphisms satisfying y1 = f1 ◦ x1 and y2 = f2 ◦ x2, and let f : A → B be the unique morphism which satisﬁes f ◦ i1 = j1 ◦ f1 and f ◦ i2 = j2 ◦ f2; then f will be denoted by f1 +Q f2.
For the initial object 0 the expression A1+0A2 is equivalent to A1+A2, and similarly for f1 +0 f2 and f1 +f2. This “generalized coproduct” is used to describe the parallel composition of two rules that rewrite an object in a parallel independent way: a combined rule is constructed that allows to apply the two rules “at the same time”,
i.e. concurrently. More specifically the two rules need to be glued together at the intersection of their read-only parts.

Definition 2.4 (Parallel productions) Let p1 = L1
l1
←− K1
r1
−→ R1 and p2 =

l2	r2	x1	x2
L2 ←− K2 −→ R2 be productions, and let K1 ←− Q −→ K2 be a span of morphisms. If the pushouts for all the pairs (l1 ◦ x1, l2 ◦ x2), (x1, x2) and (r1 ◦ x1, r2 ◦ x2) exist,
then the parallel composition of p1 and p2 over Q is

l1+Ql2	r1 +Qr2
p1 +Q p2 = L1 +Q L2 ←−−−− K1 +Q K2 −−−−→ R1 +Q R2.
The production p1 +Q p2 is called proper if all the morphisms of the three involved
pushout diagrams are monic.2
Now we are ready to formulate the main theorem, which might be of interest whenever one uses dpoa/i rewriting in adhesive categories. The proof relies on an adapted version of the Butterfly Lemma of [11] for “generalized” coproducts (see Appendix3).
Theorem 2.5 (Parallelism and Local Church Rosser in dpoa/i)

l1	r1
l2	r2	4

Let p1 = L1 ←− K1
−→ R1 and p2 = L2 ←− K2
−→ R2 be productions,
and let

L >f→−1
C and L >f→−2
C be morphisms. Then the following are equivalent.

(f1,p1 ⟩	(f2,p2 ⟩
There are strongly parallel independent rewrites D1 ⇐==== C ====⇒ D2.

(f1 ,p1⟩
(f ' ,p2 ⟩

There are strongly sequential independent rewrites C ====⇒ D1 ==2==⇒ D.

(f2 ,p2⟩
(f ' ,p1 ⟩

There are strongly sequential independent rewrites C ====⇒ D2 ==1==⇒ D.
(f1 +Qf2,p1 +Qp2⟩
There is a rewrite C ==========⇒ D with a proper parallel production p1 +Q
2 This construction is equivalent to the one given in Definition 9.5 of [10].
3 As [11] is a rather inaccessible source, we chose to give the whole proof.
4 These are not required to be linear, as is assumed in [12].

p where Q is constructed as the pullback	)K1→C, i.e. Q = K  ∩ K .
2	Q→K2)	1	2
Conclusion and work in progress
Motivated by extending the existing concurrency theory of dpo rewriting to the interactive setting of dpo with borrowed contexts (dpobc), we have defined the required kind of parallel productions and proved the Local Church Rosser and Par- allelism theorem for dpoa/i in adhesive categories. Besides filling this gap in the literature, these theorems might prove useful for future research concerned with dpoa/i rewriting in adhesive categories. This is not unlikely since the dpoa/i ap- proach is more intuitive and more expressive than dpo as shown in [10]. In fact, dpobc is not the only application where the requirement of monic matches arises naturally: consider e.g. the work on processes of adhesive rewriting systems [2] and encondig of nominal calculi [9].
We will use the presented results for the generation of a concurrency respecting bisimulation congruence from a given set of rules. More specifically the construction of parallel rules will be used to generate a closure of all given productions as follows: given a set of productions P we construct the closure P¯ via the two rules


p ∈ P p ∈ P¯
p, p' ∈ P¯ & K ←−i< Q >−→j
p +Q p' ∈ P¯
Kp'

where Kp denotes the interface of a rule p, i.e. given a rule p = X ← Y → Z we
write Kp for Y .
Usually in borrowed context rewriting and in the more general setting of the theory of reactive systems, the lts is derived using the set of rules P , while here we propose to use P¯. Reconsider the ccs example from the introduction where we hinted at the difference between the two processes c¯|m¯ and c¯.m¯ +m¯ .c¯. This now can be made formal, since the lts generated from P¯ using the borrowed context tech- nique of [15] allows the former to communicate with the environment concurrently
[—]|c.P |m.Q
at the channels m and c (this corresponds to the transition c¯ | m¯ −−−−−−−→ P | Q)

while the latter cannot (in signs c¯.m¯ + m¯ .c¯ −[−—−]|c−.P−z|−m−.→Q
P | Q).

There are several other proposals of bisimulations that respect concurrency
[4, 3, 5] however they are based on the notion of causality. Our proposal conceptu- ally differs from these since it does not allow the environment to observe causality but just the possible ways in which a system could interact with the environment concurrently. In other words, we consider systems as black boxes, while intuitively the existing equivalences seem to open the black box by observing causal dependen- cies. Reconsidering our ccs example, our proposed bisimilarity distinguishes c¯ | m¯ and c¯.m¯ + m¯ .c¯ because an external observer can parallely communicate with the former but not with the latter, while the bisimilarities of the cited works distinguish the processes because the former can perform its transitions independently and the latter cannot. The subtle interplay between causality and concurrency especially in the context of borrowed context rewriting is the main interest of ongoing research.

Acknowledgement
We would like to thank Fabio Gadducci, Ugo Montanari and the anonymous referees for their comments on the paper.


References
Baldan, P., A. Corradini, H. Ehrig, M. L¨owe, U. Montanari and F. Rossi, Concurrent semantics of algebraic graph transformations, in: H. Ehrig, H.-J. Kreowski, U. Montanari and G. Rozenberg, editors, Handbook of Graph Grammars and Computing by Graph Transformation (1999), pp. 107–188.

Baldan, P., A. Corradini, T. Heindel, B. K¨onig and P. Sobocinski, Processes for adhesive rewriting systems., in: L. Aceto and A. Ingo´lfsd´ottir, editors, FoSSaCS, Lecture Notes in Computer Science 3921 (2006), pp. 202–216.

Baldan, P., A. Corradini and U. Montanari, History preserving bisimulation for contextual nets., in:
D. Bert, C. Choppy and P. D. Mosses, editors, WADT, Lecture Notes in Computer Science 1827 (1999),
pp. 291–310.

Bednarczyk, M. A., Hereditary history preserving bisimulations or what is the power of the future perfect in program logics, Technical report, Polish Academy of Sciences, Gdansk (1991).

Best, E., R. R. Devillers, A. Kiehn and L. Pomello, Concurrent bisimulations in petri nets., Acta Inf.
28 (1991), pp. 231–264.

Ehrig, H. and B. K¨onig, Deriving bisimulation congruences in the DPO approach to graph rewriting, in: Proc. of FoSSaCS ’04 (2004), pp. 151–166, LNCS 2987.

Gadducci, F. and R. Heckel, An inductive view of graph transformation., in: F. Parisi-Presicce, editor,
WADT, Lecture Notes in Computer Science 1376 (1997), pp. 223–237.

Gadducci, F., R. Heckel and M. Llabr´es, A bi-categorical axiomatisation of concurrent graph rewriting., Electronic Notes Theoretical Computer Science 29 (1999).

Gadducci, F. and U. Montanari, Observing reductions in nominal calculi via a graphical encoding of processes, in: A. Middeldorp, V. van Oostrom, F. van Raamsdonk and R. C. de Vrijer, editors, Processes, Terms and Cycles, Lecture Notes in Computer Science 3838 (2005), pp. 106–126.

Habel, A., J. Mu¨ller and D. Plump, Double-pushout graph transformation revisited., Mathematical Structures in Computer Science 11 (2001), pp. 637–688.

Kreowski, H.-J., “Manipulationen von Graphmanipulationen,” Ph.D. thesis, Technische Universit¨at Berlin (1977).

Lack, S. and P. Sobocin´ski, Adhesive and quasiadhesive categories, Theoretical Informatics and Applications 39 (2005), pp. 511–546.

Leifer, J. J. and R. Milner, Deriving bisimulation congruences for reactive systems., in: C. Palamidessi, editor, CONCUR, Lecture Notes in Computer Science 1877 (2000), pp. 243–258.

Sassone, V. and P. Sobocin´ski, Deriving bisimulation congruences using 2-categories., Nord. J. Comput.
10 (2003), pp. 163–.

Sassone, V. and P. Sobocin´ski, Reactive systems over cospans, in: Proc. of LICS ’05 (2005), pp. 311–320.

A	The extended Butterfly Lemma

Lemma A.1 (General Butterfly Lemma)




y1 x1 i1
j1
Q



y2
A2
i2
j2



B2	A1
Q
x1	x2
A2
Q
y1	y2
	
B1	B2



C	E
(A.1)
the left one are pushouts, and f : A → B, a : A → C and e : B → E are the unique Let the above be commuting diagrams where all interior squares and the boundary of mediating morphisms, such that





Finally let C have pushouts of the diagrams B ←f−1
a1
A1 −→
f2
C and B2 ←−
a2
A2 −→ C.

Then for any morphism c : C → E the following are equivalent.
(i) There exists a commuting diagram	(ii) The diagram


A1

B1	(∗)	C
A2	A	f	B
a	e
(†)	B2

is a pushout.
where the squares (∗), (†) and (‡) are pushouts.
Proof. First we show that the implication (i) ⇒ (ii) holds. For this assemble the given diagrams into one (see Diagram (A.5)).

Next we need to check that e ◦ f = c ◦ a; for this we will use that i1 and i2 are jointly epic,
both e ◦ f ◦ i1 = c ◦ a ◦ i1 and i.e. it is enough to show that e ◦ f ◦ i2 = c ◦ a ◦ i2 hold;
these two equations are derivable
Diagram (A.5), Square (∗), and using Item (i), Equation (A.4), Square (§) of Item (ii) commutes; Equation (A.3). In other words it remains to show that it sat-
isfies the universal property of pushouts.
Hence assume there is a commuting diagram as





(A.5)



f
A
a	(§)
C 
B
e


.	(A.6)
X

h

Now we derive h ◦ a1 = k ◦ j1 ◦ f1 and h ◦ a2 = k ◦ j2 ◦ f2 using Equation (A.3), Diagram (A.6) and Diagram (A.1). Because the Squares (∗) and (†) are pushouts there are uniquely determined morphisms z1 : D1 → X and z2 : D2 → X which satisfy


Using Equation (A.7) and the fact that Square (‡) is a pushout we derive that there is exactly one morphism z : E → X such that
z ◦ d1 = z1	and	z ◦ d2 = z2	(A.9)
hold. This z is a candidate for the mediating morphism we are are looking for (see
Diagram (A.6)).
Further we derive z ◦ e ◦ j1 = k ◦ j1 and z ◦ e ◦ j2 = k ◦ j2 using Equation (A.4), epic, which yields z ◦ e = k. Moreover one can show z ◦ c = h using Square (‡), Diagram (A.1), Equation (A.9) and Equation (A.8). However j1 and j2 are jointly
Equation (A.9) and Equation (A.7), i.e. we have the equalities
z ◦ e = k	and	z ◦ c = h.	(A.10) It remains to show that z is the unique mediating morphism, i.e. that every

other morphism ζ : E → X satisfying
ζ ◦ e = k	and	ζ ◦ c = h	(A.11)
is equal to z. So assume that some morphism ζ satisfying Equation (A.11) is given.
We put


Now we derive
ζ1 := ζ ◦ d1	and	ζ2 := ζ ◦ d2.	(A.12)
ζ1 ◦ b1 = z1 ◦ b1	and	ζ2 ◦ b2 = z2 ◦ b2	(A.13)

using Equation (A.12), Item (i), Equation (A.4), Equation (A.11), Equation (A.10),
Item (i), Equation (A.12) and Equation (A.9).
Further
ζ1 ◦ c1 = z1 ◦ c1  and   ζ2 ◦ c2 = z2 ◦ c2	(A.14) follow using Equation (A.12), Square (‡), Equation (A.11), Equation (A.10), Square (‡) and Equation (A.9).
Using Equation (A.13) and Equation (A.14) we may conclude that ζ1 = z1 and
(∗) and (†) are pushouts. However using Equation (A.12) and Equation (A.9) we ζ2 = z2 since the pairs (b1, c1) and (b2, c2) are jointly epic, and because the squares can also derive ζ ◦ d1 = z ◦ d1 and ζ ◦ d2 = z ◦ d2 from which z = ζ follows since d1
and d2 are jointly epic.
Second we show the implication (ii) ⇒ (i). By assumption we have the following commuting diagrams.

A1  i1
A	i2 A2
a
C

(A.15a)
j1
1
j
B	B2
e
E

(A.15b)

Further we construct the pushouts for the pairs (f1, a1) and (f2, a2), and assemble them into the following diagram

Q
	

A1 i1

B1	(∗)
A i2
a
C
A2

(†)	B2

c1	c2
D1	D2
where the upper triangle commutes by assumption. Now we derive c ◦ a1 = e1 ◦ f1 using Diagram (A.15a), Square (§), Diagram (A.1) and Diagram (A.15b); the equation c ◦ a2 = e2 ◦ f2 follows similarly. Hence there are unique morphisms d1 : D1 → E and d2 : D2 → E such that the following hold.
d1 ◦ b1 = e1	and	d1 ◦ c1 = c	(A.16a)
d2 ◦ b2 = e2	and	d2 ◦ c2 = c	(A.16b)

It remains to show that the square C c1
c2 d1
E is a pushout.

For this let there be two morphisms h1 : D1 → X and h2 : D2 → X such that
h1 ◦ c1 = h2 ◦ c2.	(A.17)
Hence after defining k1 := h1 ◦ b1 and k2 := h2 ◦ b2, and because Diagram (A.1) commutes we arrive at the following commuting Diagram (A.18).

Q


A
a
B1	(∗)	C



(†)	B2


(A.18)





X

Using its commutativity and Equation (A.17) we derive k1 ◦ y1 = k2 ◦ y2; therefore there exists a unique morphism k : B → X such that
k1 = k ◦ j1  and  k2 = k ◦ j2.	(A.19) Moreover k1 ◦ y1 = k2 ◦ y2 implies k1 ◦ f1 ◦ x1 = k2 ◦ f2 ◦ x2 by “expansion” of y1 and y2, which provides us with a uniquely determined morphism u : A → X such that
k1 ◦ f1 = u ◦ i1   and   k2 ◦ f2 = u ◦ i2.	(A.20)

Now inspecting




y1

Q
y2







X
we see that k1 ◦ f1 = k ◦ f ◦ i1 and k2 ◦ f2 = k ◦ f ◦ i2; hence
k ◦ f = u	(A.21)

follows from the characterization of u in (A.20). However we can also derive k1◦f1 = h1 ◦ c1 ◦ a ◦ i1 and k2 ◦ f2 = h2 ◦ c2 ◦ a ◦ i2 from it, whence h1 ◦ c1 ◦ a = u (A=.21) k ◦ f (see Equation (A.20)). Since h1 ◦ c1 = h2 ◦ c2 we also get h2 ◦ c2 ◦ a = k ◦ f . where we used uniqueness of the mediating morphism u to derive the first equality
Now since Square (§) is a pushout we know that there is a unique morphism
z : E → X such that
z ◦ c = h	and	z ◦ e = k	where h = h1 ◦ c1 = h2 ◦ c2.	(A.22)
This morphism z is the candidate for the mediating morphism we are looking for.
derive that z◦d1 = h1. Now using Square (§) and (A.22) we derive z ◦ d1◦c1 = h1◦c1; To show that it is the unique one we will use that b1 and c1 are jointly epic to further using (A.16a), (A.15b), (A.19) and (A.18) we derive z ◦ d1 ◦ b1 = h1 ◦ b1. This shows that z ◦d1 = h1 and mutatis mutandis z ◦d2 = h2; hence z is a mediating morphism from E → X. It remains to show that it is the only one.
Let ζ : E → X be a morphism such that ζ ◦ d1 = h1 and ζ ◦ d2 = h2 hold; we have to show that ζ = z. Using Square (‡), the assumption and Equation (A.22) we derive ζ ◦ c = z ◦ c. If also ζ ◦ e = k then z = ζ holds because e and c are jointly epic; thus it remains to show that ζ ◦ e = k.
Since j1 and j2 are jointly epic it is enough to show that ζ ◦ e ◦ j1 = k ◦ j1 and ζ ◦ e ◦ j2 = k ◦ j2. However we can derive (see Diagram (A.18), the assumption and Diagram (A.1)) that k1 ◦ y1 = ζ ◦ e ◦ j1 ◦ y1, and mutatis mutandis also k2 ◦ y2 = ζ ◦ e ◦ j2 ◦ y2. This yields that ζ ◦ e is the unique arrow such that ζ ◦ e ◦ j1 = k1 and ζ ◦ e ◦ j2 = k2. Expanding the definition of k1 and k2 we arrive at ζ ◦ e ◦ j1 = k ◦ j1 and ζ ◦ e ◦ j2 = k ◦ j2 and the proof is finished.
