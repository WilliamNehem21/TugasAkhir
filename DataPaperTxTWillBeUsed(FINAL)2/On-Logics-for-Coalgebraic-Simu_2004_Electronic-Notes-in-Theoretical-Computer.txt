Electronic Notes in Theoretical Computer Science 106 (2004) 63–90  
www.elsevier.com/locate/entcs


On Logics for Coalgebraic Simulation
Corina Cˆırstea1
School of Electronics and Computer Science University of Southampton

Abstract
We investigate logics for coalgebraic simulation from a compositional perspective. Specifically, we show that the expressiveness of an inductively-defined language for coalgebras w.r.t. a given notion of simulation comes as a consequence of an expressivity condition between the language constructor used to define the language for coalgebras, and the relator used to define the notion of simulation. This result can be instantiated to obtain Baltag’s logics for coalgebraic simulation, as well as a logic which captures simulation on unlabelled probabilistic transition systems. Moreover, our approach is compositional w.r.t. coalgebraic types. This allows us to derive logics which capture other notions of simulation, including trace inclusion on labelled transition systems, and simulation on discrete Markov processes.
Keywords: coalgebra, simulation, modal logic


Introduction
Simulations are widely used in computer science, typically to prove refinement relations between dynamical systems. The connection between simulations and coalgebra was probably first noted in [13] (see also [8]), where the objec- tive was to prove refinement relations between recursively-defined programs. This connection was further investigated in [1], where logics capturing sim- ulation were also studied. Additional properties of coalgebraic simulations, including a characterization of the similarity relation on the final coalgebra, were subsequently proved in [10].
The method used in [1] to define logics for simulation builds on, and at the same time generalizes the approach described in [12] for defining expressive

1 Email: cc2@ecs.soton.ac.uk



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.026


logics for bisimulation. The resulting logics are generic in coalgebraic types, and employ a single modal operator derived directly from the coalgebraic signature. These logics are, however, difficult to use in actual specification, as their syntax does not reflect the structure of the underlying types.
The present paper describes a compositional method for defining logics which capture simulation. This method allows logics for combinations of coal- gebraic types to be derived from logics for the types being combined. Thus, the structure of the underlying types is reflected in the modal operators employed by the resulting logics.
A similar approach to defining logics was taken in [5], where logics captur- ing bisimulation were investigated from a compositional perspective. Specif- ically, it was shown in [5] that the expressiveness w.r.t. bisimulation of an inductively-defined language for coalgebras follows from an expressivity con- dition referring to one step in the definition of the language. In the case of logics for simulation, the situation is more complex. On the one hand, ways to combine notions of simulation for different coalgebraic types are needed. On the other hand, the sought logics must be tailored to particular notions of simulation, and therefore the expressivity condition used in [5] must be adapted accordingly.
The paper is structured as follows. In Section 2, we recall the coalge- braic approach to defining simulation. In Section 3, we provide an alternative characterization of monotonic relators, the concept underlying the definition of coalgebraic simulation [13,8], and use this characterization to define a notion of simulation for unlabelled probabilistic transition systems. Next, in Section 4, we propose an inductive method for defining logics which capture simulation, much in the spirit of [5]. Using this method, the expressiveness of a logic for simulation comes as a consequence of an expressivity condition between a language constructor and a monotonic relator. This method can be applied to obtain the logics defined in [1], as well as a logic capturing simulation on unlabelled probabilistic transition systems. Finally, in Section 5, we show that our method for defining logics for simulation is compositional w.r.t. coalge- braic types. Operations on coalgebraic types, including functor composition, product, coproduct and exponentiation are shown to induce corresponding op- erations on monotonic relators on the one hand, and on language constructors on the other. Moreover, the resulting operations are shown to preserve the previously-mentioned expressivity condition. This allows us to derive logics which capture trace inclusion on labelled transition systems and simulation on discrete Markov processes, respectively. In the latter case, the logic obtained is essentially the logic considered in [7]. Thus, in this case, we obtain both a coalgebraic characterization of simulation on discrete Markov processes, and

an alternative proof of expressiveness of the logic in [7] w.r.t. simulation.

Preliminaries
Here we fix the notation for subsequent sections, recall some basic definitions and results concerning relations and respectively coalgebras, and summarize the coalgebraic approach to defining simulation.

Relations
We write Rel for the category having objects given by tuples ⟨A, B, R⟩ with R ⊆ A × B, and arrows from ⟨A, B, R⟩ to ⟨C, D, S⟩ given by pairs ⟨f, g⟩ with f : A → C and g : B → D such that (f × g)(R) ⊆ S.
Remark 2.1 This is not the only way of defining a category of relations. One can also consider the category having, as objects, pairs consisting of a set and a binary relation on it, and as arrows, functions between sets which preserve the relations. Yet another possibility is to consider the category having sets as objects and relations as arrows. All these categories are usually denoted Rel. Our own definition of Rel follows [10].
Given a relation R ⊆ A × B, we write πR and πR for π1 ◦ ι : R → A and
1	2
π2 ◦ ι : R → B, respectively, where π1 : A × B → A and π2 : A × B → B are the product projections, and where ι : R → A × B is the inclusion map. Also,
op
we write R for the converse of a relation R, and Grf ⊆ A × B for the relation
defining the graph of a function f : A → B. The composition of relations
R ⊆ A × B and S ⊆ B × C is denoted S ◦ R ⊆ A × C.
We let U : Rel → Set × Set denote the functor taking relations to the underlying sets. Then, U is a ﬁbration 2 . For, given f : A → C, g : B → D and S ⊆ C × D, letting aR b if and only if f (a) S g(b) makes ⟨f, g⟩ : ⟨A, B, R⟩ → 
⟨C, D, S⟩ a cartesian map. The cartesian maps of U are thus the relation- reflecting maps in Rel.
We also let Preord denote the category of preorders and monotonic maps. Then, Preord is (isomorphic to) a sub-category of Rel. Moreover, if V : Preord → Set takes preorders to the underlying sets, then V is a fibration. The cartesian maps of V are the order-reflecting maps in Preord.
The following also holds:
Proposition 2.2 Rel and Preord are complete categories.

2 See [3] for a definition of this notion.


Limits in Rel and Preord are constructed from limits in Set and limits in certain fibres of U and V, respectively.

Coalgebras
For an endofunctor T : C → C,a T-coalgebra is a pair ⟨C, γ⟩ with γ : C → TC a C-arrow. Also, a T-coalgebra homomorphism from ⟨C, γ⟩ to ⟨D, δ⟩ is a C- arrow f : C → D such that Tf ◦ γ = δ ◦ f . In what follows, we will consider coalgebras over the categories Set, Rel and Preord.
Example 2.3 A-labelled, image-finite transition systems can be modelled as coalgebras of the functor (Pω)A, where Pω : Set → Set takes a set to the set of its finite subsets and a function to its direct image, and XA denotes the set of functions A → X. The functors Pω and (Pω)A preserve weak pullbacks and are ω-accessible 3 .
Example 2.4 A-labelled probabilistic transition systems can be modelled as coalgebras of the functor (1 + Dω)A : Set → Set, where Dω : Set → Set is the ﬁnite probability distribution functor , defined by:
DωX = { µ : X → [0, 1] | supp(µ) finite , Σ µ(x)= 1 } for X ∈ |Set|
x∈X
with supp(µ)= { x ∈ X | µ(x) /= 0 } for µ : X → [0, 1], and:
(Dωf )(µ)(y)= µ[f −1({y})] for f : X → Y , µ ∈ DωX , and y ∈ Y
with µ[Z]= Σ µ(x) for µ : X → [0, 1] and Z ⊆ X. The functor Dω preserves
x∈Z
weak pullbacks (see e.g. [12]), and so do the functors 1 + Dω and (1 + Dω)A. Also, all these functors are ω-accessible.
Given T : Set → Set, a T-bisimulation between T-coalgebras ⟨C, γ⟩ and
⟨D, δ⟩ is a relation R ⊆ C × D carrying a T-coalgebra structure ρ : R → TR
which makes πR : R → C and πR : R → D T-coalgebra homomorphisms. The
1	2
largest T-bisimulation between ⟨C, γ⟩ and ⟨D, δ⟩ is called T-bisimilarity and
is denoted  .
Example 2.5 A notion of bisimulation equivalence for probabilistic transi- tion systems was defined in [11]. Moreover, it was shown in [6] that this notion is essentially the same as (1 + Dω)A-bisimulation. The following char- acterization of 1 +Dω-bisimulation was also given in [6]: a relation R ⊆ C × D

3 For a regular cardinal κ, an endofunctor is κ-accessible if it preserves κ-filtered colimits.


is a 1 + Dω-bisimulation between ⟨C, γ⟩ and ⟨D, δ⟩ if and only if cRd im- plies γ(c)[X]= δ(d)[Y ] 4 for any X ⊆ C and Y ⊆ D such that (πR)−1(X)= 
(πR)−1(Y ).
For an endofunctor T : C → C on a complete category, the ﬁnal sequence of T is an ordinal-indexed sequence (Zα) of C-objects, together with a family (pα : Zα → Zβ)β≤α of C-arrows, subject to the following conditions:
Zα+1 = TZα
pα+1 = Tpα for β ≤ α
β+1	β
pα = 1Z
pα = pβ ◦ pα for γ ≤ β ≤ α
γ	γ	β
if α is a limit ordinal, the cone Zα, (pα)β<α for (pβ)γ≤β<α is limiting.
β	γ
The final sequence of T is uniquely defined by these conditions.
Remark 2.6 Given T : C → C as above, one can define, for each T-coalgebra
⟨C, γ⟩,a cone (γα : C → Zα) over the final sequence of T:
γα = Tγβ ◦ γ, if α = β + 1;
γα is the unique C-arrow satisfying pα ◦ γα = γβ for each β < α, if α is a
limit ordinal.
Then, T-coalgebra homomorphisms f : ⟨C, γ⟩ → ⟨D, δ⟩ define morphisms of cones f : (γα : C → Zα) → (δα : D → Zα). That is, δα ◦ f = γα for any α.
Under some mild constraints on C and T, the final sequence of T can be used to construct a final T-coalgebra.
Proposition 2.7 ([14]) If T : C → C is an accessible endofunctor on a locally presentable category 5 , and if T preserves monics, then the ﬁnal sequence of T stabilizes at some α 6 , and moreover, Zα is the carrier of a ﬁnal T-coalgebra.
Moreover, in the case of ω-accessible endofunctors on Set, the cardinal α
of Proposition 2.7 is at most ω + ω.
Proposition 2.8 ([14]) If T : Set → Set is ω-accessible, then the map pω+ω+1 :

Zω+ω+1 → Zω+ω is an isomorphism, whereas the maps pω+n+1
: Zω+n+1 →

Zω+n with n = 0, 1,... are all injective.

4 By convention, γ(c)[X] = 0 if γ(c) ∈ ι1(1).
5 Each of the categories Set, Rel and Preord are locally ω-presentable.
6 That is, pα+1 : Zα+1 → Zα is an isomorphism.


Simulations
Notions of simulation between coalgebras have been studied in [13,8,1,10]. A summary of these approaches is given in the following. For this, we fix an endofunctor T : Set → Set.
The concept which lies at the heart of defining simulations is that of a
relator. A (T-)relator [13] is a mapping from relations to relations, taking relations on A × B to relations on TA × TB. A monotonic (T-)relator [13] is required to satisfy some additional constraints, including preservation of in- clusions between relations and preservation of relational composition. These
constraints result in monotonic T-relators being essentially the same as endo- functors Γ : Rel → Rel satisfying:
U ◦ Γ= (T × T) ◦ U;
(ii) =TA ⊆ Γ(=A);
(iii) Γ(S ◦ R)= Γ(S) ◦ Γ(R) for any R ⊆ A × B and S ⊆ B × C.
In the sequel, we will identify monotonic relators with such endofunctors.
A generic example of a relator is the minimal relator induced by T [13], denoted Γm : Rel → Rel, and defined by:
Γm(R)= ⟨TπR, TπR⟩(TR) ⊆ TA × TB for R ⊆ A × B
1	2
The minimal relator induced by T is monotonic if and only if T preserves weak pullbacks. Although not explicitly stated in [13], this observation is an immediate consequence of the results in [13, Section 2.2]. Irrespective of the preservation of weak pullbacks by T, the minimal relator is contained in any monotonic relator Γ, that is, Γm(R) ⊆ Γ(R) for any relation R. Moreover, any
monotonic relator Γ can be defined in terms of its action on equality relations
and of Γm:
Γ(R) = Γ(=B) ◦ Γm(R) ◦ Γ(=A) for any R ⊆ A × B	(1)
Given a T-relator Γ : Rel → Rel, the transposed relator Γ∼ takes a relation
R ⊆ A × B to the relation ( Γ(Rop) )op ⊆ TA × TB.
Example 2.9 The minimal Pω-relator Γm : Rel → Rel takes a relation R ⊆
A × B to the relation Γm(R) ⊆ PωA × PωB defined by:
X Γm(R) Y  iff (∀ x ∈ X.∃ y ∈ Y. x R y and ∀ y ∈ Y.∃ x ∈ X. x R y)
for X ∈ PωA, Y ∈ PωB. Another Pω-relator Γ⊇ : Rel → Rel can be defined by:
X Γ⊇(R) Y  iff ∀ y ∈ Y.∃ x ∈ X. x R y


Both Γm and Γ⊇ are monotonic relators. Moreover, Γ⊇(R) =⊇B ◦Γm(R)◦ ⊇A, where ⊇A and ⊇B are the containment relations on PωA and PωB, respec- tively. We also note that Γ⊇ preserves monics and is ω-accessible. (This observation will be used later in the paper.) Finally, the transposed relator Γ⊆ = (Γ⊇)∼ is given by:
X Γ⊆(R) Y  iff ∀ x ∈ X.∃ y ∈ Y. x R y
[13] also shows the existence of a one-to-one correspondence between mono- tonic relators and so-called monotonic extensions of T. These are functors
± : Set → Preord such that:
V◦± = T;
if A ⊆ B then u ±A v iff u ±B v for any u, v ∈ TA;
(monotonicity) the following holds for f : A → C, g : B → C, u ∈ TA
and v ∈ TB:
(Tf )(u) ± (Tg)(v) ⇒ u (Γ±{ (a, b) ∈ A × B | f (a)= g(b) }) v	(2) where Γ± : Rel → Rel denotes the relator induced by ±, defined by:
Γ±(R) =±B ◦ Γm(R) ◦ ±A for R ⊆ A × B
Monotonic extensions induce monotonic relators, and moreover, any mono- tonic relator Γ arises from a unique monotonic extension ±Γ, given by:
±Γ,A = Γ(=A) for A ∈ |Set|	(3)
Finally, any monotonic relator Γ restricts to an endofunctor on Preord, itself denoted Γ.
Example 2.10 The functor ⊇: Set → Preord taking a set A to the contain- ment relation ⊇A on PωA defines a monotonic extension of Pω. The corre- sponding monotonic relator is Γ⊇, as defined in Example 2.9.
The following is a reformulation of the definition of simulation given in [13] (see also [10]).
Definition 2.11 Let Γ : Rel → Rel be a monotonic relator. A Γ-simulation between T-coalgebras ⟨C, γ⟩ and ⟨D, δ⟩ is a Γ-coalgebra ⟨⟨C, D, R⟩, ⟨γ, δ⟩⟩. The largest Γ-simulation between ⟨C, γ⟩ and ⟨D, δ⟩ is called Γ-similarity and is denoted  . If c ∈ C, d ∈ D are such that c  d, we say that c simulates d.
A Γ-simulation between ⟨C, γ⟩ and ⟨D, δ⟩ is thus given by a relation R ⊆
C × D such that cRd implies γ(c) Γ(R) δ(d) for any c ∈ C and d ∈ D.


By taking the relator Γ of Definition 2.11 to be the minimal relator induced by T, we recover the definition of a T-bisimulation: a relation R ⊆ C × D is a
T-bisimulation between ⟨C, γ⟩ and ⟨D, δ⟩ if γ(c) ⟨TπR, TπR⟩(TR) δ(d) holds
1	2
whenever cR d.
Example 2.12 Let Γm and Γ⊇ be as in Example 2.9. Then, Γm-simulations are the same as Pω-bisimulations. Also, a relation R ⊆ C × D is a Γ⊇- simulation between Pω-coalgebras ⟨C, γ⟩ and ⟨D, δ⟩ if, whenever cR d and d' ∈ δ(d), there exists c' ∈ γ(c) such that c' R d'.
Remark 2.13 A notion of weak monotonic relator was also defined in [1], based on ideas from [13]. This notion is similar to that of a monotonic relator, only in [1] a different category of relations, having sets as objects and relations as arrows, was considered. In this setting, the notion of relator does not depend on an endofunctor T : Set → Set. Instead, the fact that Set is a sub-
category of the above-mentioned category of relations can be used to define
what it means for a weak monotonic relator to extend an endofunctor T. A result in [4] then shows that a minimal relator extending T exists precisely when T preserves weak pullbacks. A notion of simulation induced by a weak monotonic relator was also defined in [1]. This notion is essentially the same as that of Definition 2.11. However, since the two definitions involve different categories of relations, it is not possible to directly transfer results between the two approaches.
In [10], functors ± : Set → Preord satisfying V◦± = T were taken as prim- itive, and lax relation lifting functors Rel±(T) : Rel → Rel, defined similarly to the relators Γ±, were considered. The difference w.r.t. [13] is that only the first condition in the definition of monotonic extensions was required of the functors ± : Set → Preord. As a result, the induced lax relation lifting functors are not necessarily monotonic relators. However, once monotonicity is assumed, the setting of [10] coincides with that of [13].
It is shown in [10] that monotonicity of a relator Γ results in Γ-similarity enjoying some nice properties.
Proposition 2.14 ([10]) The following hold for a monotonic relator Γ :
Rel → Rel:
Γ-similarity on a T-coalgebra ⟨C, γ⟩ is a preorder on C;
given T-coalgebra homomorphisms f : ⟨A, α⟩ → ⟨B, β⟩ and g : ⟨C, γ⟩ → 
⟨D, δ⟩, a   c if and only if f (a)   g(c), for a ∈ A and c ∈ C;
similarity on the ﬁnal T-coalgebra is the ﬁnal Γ-coalgebra.
Remark 2.15 By taking f and g in (ii) of Proposition 2.14 to be the unique


homomorphisms !α : ⟨A, α⟩ → ⟨Z, ζ⟩ and !γ : ⟨C, γ⟩ → ⟨Z, ζ⟩ into the final T- coalgebra, we obtain that Γ-similarity between ⟨A, α⟩ and ⟨C, γ⟩ is the domain of the cartesian map ⟨!α, !γ⟩ induced by the Γ-similarity relation on the final T-coalgebra. This observation, together with (iii) of Proposition 2.14, will later allow us to define logics which capture Γ-similarity.


Monotonic Relators Revisited

Here we give an alternative characterization of monotonic relators. This char- acterization will prove more convenient for our purposes; in particular, it will allow us to define a notion of simulation for probabilistic transition systems. The alternative characterization has a more categorical flavour than the orig- inal definition, as it replaces the preservation of relational composition by a monotonic relator by preservation of a property of arrows in Rel.

Proposition 3.1 Let T : Set → Set, and let Γ: Rel → Rel be such that:
(i) U ◦ Γ= (T × T) ◦ U;
(ii) =TA ⊆ Γ(=A).
Then, Γ is a monotonic relator if and only if Γ preserves cartesian maps.

Proof. Any monotonic relator Γ is uniquely determined by its induced mono- tonic extension ±Γ , defined by (3). It therefore suffices to prove that, in the presence of (i) and (ii) above, condition (2) of Section 2.3 is equivalent to the preservation by Γ of cartesian maps.
We begin by noting that (2) is equivalent to Γ preserving cartesian maps of form ⟨f, g⟩ : ⟨A, B, R⟩ → ⟨C, C, =C⟩. Thus, one half of the previously- mentioned equivalence follows immediately. To prove the other half, assume
that Γ is a monotonic relator. Then, observe that by taking g = 1C and respectively f = 1C in (2), we obtain:


op	op
ΓGr(f ) = ±Γ,C ◦ Gr(Tf )	Γ(Gr(g) ) = Gr(Tg) ◦ ±Γ,C	(4)

Now let ⟨f, g⟩ : ⟨A, B, R⟩ → ⟨C, D, S⟩ be a cartesian map. Thus, R = Gr(g)  ◦
S ◦ Gr(f ). The fact that ⟨Tf, Tg⟩ : ⟨TA, TB, ΓR⟩ → ⟨TC, TD, ΓS⟩ is itself a
op
cartesian map, i.e. ΓR = Gr(Tg)	◦ ΓS ◦ Gr(Tf ), follows from:

ΓR  =
op
Γ(Gr(g) ) ◦ ΓS ◦ Γ(Gr(f )) =	(4)
op
Gr(Tg) ◦ ±Γ,D ◦ ΓS ◦ ±Γ,C ◦ Gr(Tf ) =	(1)
Gr(Tg) ◦ ±Γ,D ◦ ±Γ,D ◦ ΓmS ◦ ±Γ,C ◦ ±Γ,C ◦ Gr(Tf ) =
Gr(Tg) ◦ ±Γ,D ◦ ΓmS ◦ ±Γ,C ◦ Gr(Tf ) =	(1)
op
Gr(Tg)	◦ ΓS ◦ Gr(Tf )
The first of the above equalities uses the preservation of relational composition by Γ, whereas the fourth equality exploits the fact that ±Γ,C and ±Γ,D are preorders. Hence, Γ preserves cartesian maps. This concludes the proof. 
Thus, monotonic relators can alternatively be defined as functors satisfying
(i) and (ii) of Proposition 3.1 and preserving cartesian maps. This observation will be used extensively in what follows.
Remark 3.2 It is also possible to give a fully categorical characterization of monotonic relators, namely by replacing condition (ii) of Proposition 3.1 by the requirement that Γ restricts to an endofunctor on Preord. However, for the purposes of this paper, the characterization provided by Proposition 3.1 is the most useful one.
Remark 3.3 The proof of Proposition 3.1 also gives:
Γ(Gr(g) ) ◦ ΓS = Gr(Tg)	◦ ΓS	ΓS ◦ Γ(Gr(f )) = ΓS ◦ Gr(Tf )
for any f : A → C, g : B → D and S ⊆ C × D.
Since all the relators considered in the following are monotonic, from now on we will simply use the term (T-)relator to refer to a monotonic (T-)relator.
We now define a relator for probabilistic transition systems, and investigate the notion of simulation induced by this relator.

Probabilistic Simulation
In defining a notion of simulation for unlabelled probabilistic transition sys- tems (modelled as 1 +Dω-coalgebras), it will prove convenient to work with an endofunctor slightly more general than 1 + Dω. Specifically, we will consider the ﬁnite sub-probability distribution functor Sω : Set → Set, defined by:
SωX = { µ : X → [0, 1] | supp(µ) finite , Σ µ(x) ≤ 1 } for X ∈ |Set|
x∈X

(Sωf )(µ)(y)= µ[f −1({y})] for f : X → Y , µ ∈ SωX , and y ∈ Y.


The coalgebraic type Sω is a generalization of the coalgebraic type 1 + Dω, in a sense made precise in the following.
Remark 3.4 Any 1 + Dω-coalgebra can be regarded as an Sω-coalgebra. To see this, let η :1 + Dω ⇒ Sω be the natural transformation given by:
ηX(ι1(∗))(x)= 0 for x ∈ X ηX (ι2(µ)) = µ
with X ∈ |Set|. Then, η induces a functor Uη : Coalg(1 + Dω) → Coalg(Sω), which takes a 1 + Dω-coalgebra ⟨C, γ⟩ to the Sω-coalgebra ⟨C, ηC ◦ γ⟩.
By using Sω to model unlabelled probabilistic transition systems, we pro- vide a unified treatment of terminal states (i.e. states for which no transition is possible) and non-terminal ones.
Proposition 3.5 Sω preserves weak pullbacks and is ω-accessible.
An Sω-relator can now be defined by relaxing the conditions in the char- acterization of 1 + Dω-bisimulation (see Example 2.5).
Definition 3.6 Let Γω : Rel → Rel be such that:
Γω takes R ⊆ A × B to ΓωR ⊆ SωA × SωB, where µ (ΓωR) ν if and only if
µ[X] ≥ ν[Y ] for any X ⊆ A and Y ⊆ B such that (πR)−1(X) ⊇ (πR)−1(Y );
1	2
Γω takes ⟨f, g⟩ : ⟨A, B, R⟩ → ⟨C, D, S⟩ to ⟨Sωf, Sωg⟩.
To see that Γω is well-defined on arrows, let ⟨f, g⟩ be as above, let µ ∈ SωA,
ν ∈ SωB be such that µ (ΓωR) ν, and let U ⊆ C, V  ⊆ D be such that
(πS)−1(U ) ⊇ (πS)−1(V ). An easy calculation shows that (πR)−1(f −1(U )) ⊇
1	2	1
(πR)−1(g−1(V )).  This, together with µ (ΓωR) ν now gives (Sωf )(µ)[U ] ≥
(Sωg)(ν)[V ]. Thus, (Sωf )(µ) (ΓωS) (Sωg)(ν).
Proposition 3.7 Γω is a relator.
Proof. The first two requirements in the definition of a relator (see e.g. (i) and (ii) of Proposition 3.1) are immediately verified. To see that Γω preserves cartesian maps, let ⟨f, g⟩ : ⟨A, B, R⟩ → ⟨C, D, S⟩ be a relation-reflecting map, let µ ∈ SωA, ν ∈ SωB be such that (Sωf )(µ) (ΓωS) (Sωg)(ν), and let X ⊆ A,
Y ⊆ B be such that (πR)−1(X) ⊇ (πR)−1(Y ). Also, let U = { c ∈ C | c =
1	2
f (a)implies a ∈ X } and V = g(Y ). Then, X ⊇ f −1(U ), g−1(V ) ⊇ Y , and
(πS)−1(U ) ⊇ (πS)−1(V ).  (Sωf )(µ) (ΓωS) (Sωg)(ν) now gives (Sωf )(µ)[U ] ≥
1	2
(Sωg)(ν)[V ], and therefore µ[X] ≥ µ[f −1(U )] ≥ ν[g−1(V )] ≥ ν[Y ]. We have thus proved that µ (ΓωR) ν.	 
We now characterize the restriction of Γω to Preord.

Proposition 3.8 Let R be a preorder on A, and let µ, ν ∈ SωA. Then:
op
µ (ΓωR) ν  iff µ[Y ] ≥ ν[Y ] for any R -closed Y ⊆ A	(5)
Proof. We begin by noting that, if X, Y ⊆ A, then (πR)−1(X) ⊇ (πR)−1(Y )
1	2
translates to X ⊇ Y , where Y = { a ∈ A |∃ y ∈ Y. a R y }. Also, the reflexivity and transitivity of Rop give Y ⊇ Y and Y Rop -closed 7 . First, let Y ⊆ A be
an Rop -closed set. Then, (πR)−1(Y ) ⊇ (πR)−1(Y ) (as Y ⊇ Y ), and hence, by
1	2
the definition of Γω, µ[Y ] ≥ ν[Y ]. Next, let X, Y ⊆ A be such that X ⊇ Y .
op
Then, since Y is R -closed, it follows by (5) that µ[Y ] ≥ ν[Y ]. We also have
µ[X] ≥ µ[Y ] (as X ⊇ Y ) and ν[Y ] ≥ ν[Y ] (as Y ⊇ Y ). Hence, µ[X] ≥ ν[Y ]. 
Next, we investigate the notion of simulation induced by Γω. For simplicity, we consider Γω-simulation on a single Sω-coalgebra ⟨C, γ⟩. In this case, a relation R ⊆ C × C is a Γω-simulation if, whenever cRd and X ⊆ C is
-closed, we have γ(c)[X] ≥ γ(d)[X]. The condition that X is R -closed
amounts to X being closed under simulation, that is, if x ∈ X and y simulates x, then also y ∈ X. The requirement γ(c)[X] ≥ γ(d)[X] asks that a one-step transition from c is at least as likely to end in a state in X as a one-step
transition from d is, whenever X is closed under simulation.
The restriction of Γω to Preord satisfies the hypotheses of Proposition 2.7.
Proposition 3.9 Γω : Preord → Preord preserves monics and is ω-accessible.
Proof (Sketch). The key observation for proving ω-accessibility is that, for
µ, ν ∈ SωA, we have:
µ (ΓωR) ν iff µTZ (Γω(RTZ×Z)) νTZ
where Z = supp(µ) ∪ supp(ν), and µTZ, νTZ ∈ Sω(A ∩ Z).	 
Remark 3.10 A notion of simulation for probabilistic transition systems has also been defined in [7], namely as a preorder R on the set S of states of a probabilistic transition system, such that sRt implies τa(s, X) ≤ τa(t, X) for any R-closed X ⊆ S (with τa(s, X) giving the probability of reaching a state in X via an a-labelled transition from s). It then follows by the previous characterization of Γω : Preord → Preord that R is a simulation preorder
op
according to [7] (in the unlabelled case) if and only if R	is a simulation
preorder w.r.t. Γω.

7 Given a preorder ⟨A, R⟩, a subset Y ⊆ A is Rop -closed if y ∈ Y and aRy imply a ∈ Y .

Logics for Simulation
We now describe an inductive method for defining logics which capture sim- ulation. We use a notion of language constructor to capture one step in the definition of a language for coalgebras, and show that the expressiveness of the resulting language w.r.t. a given notion of simulation follows from an ex- pressivity condition involving the language constructor and the given relator.

Basic Deﬁnitions
The notion of language, as defined below, will be needed when defining lan- guage constructors. A variant of this notion was used in [5].
Definition 4.1 A language is a tuple ⟨X, L, |=⟩, with X a set (the semantic domain), L a set (of formulae) containing a distinguished element T, and
|= ⊆ X ×L a binary relation such that X × {T} ⊆ |=. 
A map between languages ⟨X, L, |=⟩ and ⟨X', L', |='⟩ is a pair ⟨f, l⟩, with f : X' → X and l : L → L' being such that:
l(T)= T,
f (x') |= ϕ if and only if x' |=' l(ϕ), for x' ∈ X' and ϕ ∈ L.
The category of languages and maps between them is denoted Lang.
Thus, the only propositional structure which is required of a language is the formula T, interpreted as true. Additional propositional structure, including conjunction and disjunction, will be required in concrete examples.
Given a language ⟨X, L, |=⟩ and a formula ϕ ∈ L, we write ϕ) for the set
{ x ∈ X | x |= ϕ }.
Remark 4.2 Any language ⟨X, L, |=⟩ induces a logical map s : X → PL, defined by s(x)= { ϕ ∈ L | x |= ϕ } for x ∈ X. Then, condition (ii) defining maps between languages is equivalent to s ◦ f = Pˆl ◦ s', where Pˆ : Set → Set is the contravariant powerset functor.
op
We let E : Lang → Set denote the functor taking languages to their semantic domains, and maps between languages to the underlying functions
between the semantic domains. The next two results have been proved in [5] for a slightly different notion of language, but they also hold in the present setting.
Lemma 4.3 E is a coﬁbration 8 .

8 See [3] for a definition.


Proof (Sketch). Given ⟨X, L, |=⟩ and f : X' → X, let |=' ⊆ X' ×L be given by x' |=' ϕ if and only if f (x') |= ϕ. Then, ⟨f, 1L⟩ : ⟨X, L, |=⟩ → ⟨X', L, |='⟩ is a cocartesian map.	 
Proposition 4.4 Lang is cocomplete.
op
Proof (Sketch). Colimits in Lang are constructed from colimits in Set  and
colimits in certain fibres of E.	 
For instance, an initial object in Lang is given by the language ⟨1, {T}, |=⟩ with |== 1 × {T}. Proposition 4.4 will later allows us to join languages with different (but related) semantic domains.
We now use the notion of language constructor (a variant of which was introduced in [5]) to formalise one step in the definition of a language for coalgebras.
Definition 4.5 Let T : Set → Set be an arbitrary endofunctor. A language constructor for T is an endofunctor F : Lang → Lang satisfying E ◦ F =
op
T  ◦ E.
Thus, a language constructor takes a language of form ⟨X, L, |=⟩ to a
language of form ⟨TX, L', |='⟩.
Example 4.6 Let F⊇ : Lang → Lang denote the language constructor for Pω which takes ⟨X, L, |=⟩ to ⟨PωX, ({T} ∪ { ϕ | ϕ ∈ L })∧, |='⟩, where ( )∧ de- notes closure under binary conjunctions, and where |=' is the natural extension of the relation defined by:
Y |='  ϕ iff ∃ y ∈ Y. y |= ϕ   (Y ∈ PωX , ϕ ∈ L) to formulae containing conjunctions.
In [5], we were interested in the ability of (the formulae of) a language to characterize elements of the underlying semantic domain. Here, we are interested in characterizing certain relations on the semantic domain.
Definition 4.7 Let ⟨X, L, |=⟩ be a language, and let ⟨X, R⟩ be a preorder. Given x, y ∈ X, we write y ≥L x if y |= ϕ whenever x |= ϕ, with ϕ ∈ L. Then, ⟨X, L, |=⟩ is called adequate for ⟨X, R⟩ if R ⊆ ≥L, and expressive for ⟨X, R⟩ if, in addition, R ⊇ ≥L.
Thus, adequacy of a language ⟨X, L, |=⟩ for a preorder ⟨X, R⟩ amounts to the logical map s : X → PL defining a map s : ⟨X, R⟩ → ⟨PL, ⊇⟩ in Preord, whereas expressiveness of ⟨X, L, |=⟩ for ⟨X, R⟩ amounts to s being a cartesian (or order-reflecting) map.


Definition 4.8 Let Γ : Rel → Rel be a T-relator. A language constructor for T preserves expressiveness w.r.t. Γ if it takes a language ⟨X, L, |=⟩ expressive for ⟨X, R⟩ to a language ⟨TX, L', |='⟩ expressive for ⟨TX, ΓR⟩.
Example 4.9 It is relatively easy to check that the language constructor F⊇ from Example 4.6 preserves expressiveness w.r.t. Γ⊇. The only challenge is to define a formula φ ∈ L' which holds in Z but not in Y , whenever Y (Γ⊇R) Z does not hold (having assumed that L is expressive w.r.t. R). First, the fact that Y (Γ⊇R) Z does not hold gives z ∈ Z such that yR z does not hold for
any y ∈ Y . The expressiveness of L w.r.t. R then gives, for each y ∈ Y , a 

formula ϕy such that z |= ϕy but y |= ϕy. Then, the formula  ( 
y∈Y
ϕy) holds

in Z but not in Y .
The next two subsections contain two more examples of language construc- tors. We first consider a language constructor which mirrors the construction of Baltag’s logics for coalgebraic simulation [1], and prove that it preserves expressiveness w.r.t. the underlying relator. We then define a language con- structor for probabilistic transition systems, and prove that it preserves ex- pressiveness w.r.t. the relator defined in Section 3.1.

Baltag’s Logics for Coalgebraic Simulation
Let T : Set → Set be a functor which preserves inclusions, and let Γ : Rel → Rel
be a T-relator. Also, let FΓ : Lang → Lang be defined by:
FΓ takes ⟨X, L, |=⟩ to ⟨TX, (TL)V, (Γ|=)V⟩, where (TL)V denotes the clo- sure of TL under arbitrary conjunctions, and (Γ|=)V is the natural extension of Γ|= to formulae containing conjunctions. We let T =  ∅ ∈ (TL)V.
FΓ takes ⟨f, l⟩ : ⟨X1, L1, |=1⟩ → ⟨X2, L2, |=2⟩ to ⟨Tf, (Tl)V⟩, where (Tl)V :
(TL1)V → (TL2)V denotes the unique extension of Tl to a function preserv-
ing conjunctions.
For FΓ to be well-defined, we must prove that:
(Tf )(t) (Γ|=1) φ iff t (Γ|=2) (Tl)(φ)	(6) for any ⟨f, l⟩ : ⟨X1, L1, |=1⟩ → ⟨X2, L2, |=2⟩, any t ∈ TX2 and any φ ∈ (TL1)V.
Lemma 4.10 Let ⟨X, L, |=⟩ be a language with logical map s : X → PL, and let e : TPˆ ⇒ PˆT be given by eX(U )= { t ∈ TX | U (Γe) t } for X ∈ |Set| and U ∈ TPX 9 . Then:

9 Here, e denotes the converse of the membership relation.


e is a natural transformation;
The logical map s' : TX → УTL induced by (Γ|=) ⊆ TX × TL is given by eL ◦ Ts.
Proof. We note that, for f : X → Y , e ◦ Gr(Уˆf )= Gr(f )op ◦ e. Preservation of relational composition by Γ together with Remark 3.3 then give (Γ e) ◦ Gr(TУˆf )= Gr(Tf )op ◦(Γe), i.e. (TУˆf )(V ) (Γe) t if and only if V (Γe) (Tf )(t), for V ∈ TУˆY and t ∈ TX. But this is equivalent to eX ◦ TУˆf = УˆTf ◦ eY . Hence, e is natural.
We also note that the definition of s makes ⟨s, 1L⟩ : ⟨X, L, |=⟩ → ⟨УL, L, e⟩ a cartesian map. Preservation of cartesian maps by Γ then gives t (Γ|=) φ if and only (Ts)(t) (Γe) φ, for t ∈ TX and φ ∈ TL. That is, φ ∈ s'(t) if and only if φ ∈ eL((Ts)(t)). Hence, s' = eL ◦ Ts.	 
We now return to proving (6). Here we only consider the case when φ ∈ TL. (The remaining case follows by induction.) In this case, (6) is equivalent

to s'
Tf =
УˆTl ◦ s'
(see Remark 4.2), where s'
: TX1 → УTL1 and

' : TX2 → УTL2 are the logical maps induced by Γ|=1 and Γ|=2. By (ii) of
Lemma 4.10, this is equivalent to eL1 ◦ Ts1 ◦ Tf = УˆTl ◦ eL2 ◦ Ts2, which, in
turn, is a consequence of (i) of Lemma 4.10 and of Remark 4.2. Thus, JΓ is well-defined.
Proposition 4.11 JΓ preserves expressiveness w.r.t. Γ.
Proof. We begin by showing that, if ⟨X, L, |=⟩ is adequate for ⟨X, R⟩, then
⟨TX, TL, Γ|=⟩ is adequate for ⟨TX, ΓR⟩ (and hence so is JΓ⟨X, L, |=⟩). The adequacy of ⟨X, L, |=⟩ for ⟨X, R⟩ translates to |= ◦ R ⊆ |=. The preservation of inclusions by T and of relational composition by Γ then give (Γ|=) ◦ (ΓR) ⊆ (Γ|=). That is, ⟨TX, TL, Γ|=⟩ is adequate for ⟨TX, ΓR⟩.
Now assume that ⟨X, L, |=⟩ is expressive for ⟨X, R⟩, i.e. R = ≥L. Following

[1], we define θ : X → L by θ(x)=	 
ϕ∈L,x|=ϕ
ϕ. Then:


op
yR x iff y ≥L x iff y |= θ(x) iff y (Gr(θ) ◦ |=) x	(7)
The definition of θ also gives Gr(θ) ⊆ |=, and hence:
Gr(Tθ) ⊆ (Γ=L) ◦ Gr(Tθ) = Γ(Gr(θ)) ⊆ (Γ|=)	(8)
The first inclusion follows from the definition of a relator (alternatively see
(ii) of Proposition 3.1), the subsequent equality follows by (4), and the final inclusion follows from the preservation of inclusions by T and Γ. We then have:

op
ΓR = (ΓGr(θ)
) ◦ (Γ|=) = Gr(Tθ)
(Γ|=) ≥  ≥TL


The first equality follows from (7) using the preservation of relational com- position by Γ, while the second equality follows by Remark 3.3. To prove the containment relation, let v ≥TL u.  Then, u (Γ |=) (Tθ)(u) (by (8)),
op
and hence v (Γ|=) (Tθ)(u). This, together with (Tθ)(u) Gr(Tθ) u now yields
op
v (Gr(Tθ)	◦ (Γ |=)) u. We have therefore proved that ΓR ≥ ≥TL. Hence,
⟨TX, TL, Γ|=⟩ is expressive for ⟨TX, ΓR⟩.	 
Thus, for an inclusion-preserving endofunctor T : Set → Set and a T- relator Γ : Rel → Rel, the language constructor JΓ formalises one step in the definition of a language for T-coalgebras.

Probabilistic Transition Systems
Let Γω : Rel → Rel be as in Section 3.1, and define Jω : Lang → Lang by:
Jω takes ⟨X, L, |=⟩ to ⟨SωX, L', |='⟩, where L' = ({T} ∪ {  pϕ | p ∈ Q ∩ [0, 1] , ϕ ∈ L })∧,∨ (with ( )∧,∨ denoting closure under binary conjunctions and disjunctions), and where |=' is the natural extension of the relation defined by:

µ |='  pϕ iff µ[ ϕ)] ≥ p
to formulae containing conjunctions and disjunctions.
Jω takes ⟨f, l⟩ : ⟨X1, L1, |=1⟩ → ⟨X2, L2, |=2⟩ to ⟨Sωf, l'⟩, where l' : L'


→ L'

takes  pϕ to  pl(ϕ) and distributes over conjunctions and disjunctions.
Thus, a formula of form  pϕ holds for a finite sub-probability distribution µ
if a state satisfying ϕ is reached via µ with probability at least p.
Remark 4.2 can be used to show that Jω is well-defined on arrows.
Proposition 4.12 Jω preserves expressiveness w.r.t. Γω.
Proof. First, assume ⟨X, L, |=⟩ is adequate for ⟨X, R⟩. We immediately infer
that ϕ) is R -closed for any ϕ ∈ L. To show that ⟨SωX, L', |='⟩ is adequate
for ⟨SωX, ΓωR⟩, let µ, ν ∈ SωX be such that µ (ΓωR) ν. The proof of the fact that ν |= φ implies µ |= φ for all φ ∈ L' (and hence µ ≥L' ν) is by induction on φ. The non-trivial case is when φ is of form  pϕ with ϕ ∈ L. In this case,
op
ν |= φ translates to ν[ ϕ)] ≥ p. Also, since  ϕ) is R -closed, it follows that
µ[ ϕ)] ≥ ν[ ϕ)]. Hence, µ[ ϕ)] ≥ p, that is, µ |= φ.
Now assume ⟨X, L, |=⟩ is expressive for ⟨X, R⟩. To show that ⟨SωX, L', |='⟩
op
is expressive for ⟨SωX, ΓωR⟩, we must prove that µ[Y ] ≥ ν[Y ] for any R -
closed Y ⊆ X, whenever µ, ν ∈ SωX are such that µ ≥L' ν. We can assume
that Y /= ∅ (otherwise µ[Y ] = ν[Y ] = 0 and we are done). We note that,
for any Rop -closed ∅ /= Y ⊆ X, Y =      ϕ): the left-to-right inclusion is
y∈Y y|=ϕ


immediate, whereas the right-to-left inclusion follows from the expressiveness
op
of ⟨X, L, |=⟩ for ⟨X, R⟩ together with Y being R -closed. Thus, if both Y
and the sets { ϕ | ϕ ∈ L, y |= ϕ } with y ∈ Y are finite, the formulae
  pϕY , with p ∈ Q ∩ [ 0, ν[Y ]] and ϕY =	ϕ can be used to show that
y∈Y y|=ϕ
µ[Y ] ≥ ν[Y ]. For, ν |=  pϕY yields µ |=  pϕY for any p ∈ Q ∩ [ 0, ν[Y ] ]. That is, µ[Y ] = µ[ ϕY )] ≥ p for any p ∈ Q ∩ [ 0, ν[Y ] ]. This, in turn, gives µ[Y ] ≥ ν[Y ].
However, the previously-mentioned sets are not, in general, finite. Nev-
ertheless, it is possible to define a formula ϕ ∈ L with the property that µ[Y ] = µ[ ϕ)] and ν[Y ] = ν[ ϕ)]. Then, the above reasoning can be ap- plied to the formulae  pϕ with p ∈ Q ∩ [ 0, ν[Y ] ]. In order to define ϕ, let Z = supp(µ) ∪ supp(ν), and let ≡ denote the equivalence relation on L
given by ϕ1 ≡ ϕ2 if and only if ϕ1) ∩ Z = ϕ2) ∩ Z. Since Z is finite, there are only finitely-many equivalence classes w.r.t. ≡. For y ∈ Y , let Φy = { ϕ ∈ L | y |= ϕ }, and let Φ0 ⊆ Φy consist of a set of representatives for
Φy. Then, for z ∈ Z, z |= ϕ for all ϕ ∈ Φy if and only z |= ϕ for all ϕ ∈ Φ0.
y
0

Now let Φ = {
ϕ∈Φ0
ϕ | y ∈ Y }, and let Φ ⊆ Φ consists of a set of represen-

tatives for Φ. Then, for z ∈ Z, z |= φ for some φ ∈ Φ if and only if z |= φ
for some φ ∈ Φ0. One can therefore infer that, for z ∈ Z, z ∈ Y if and only

if z |= 
φ∈Φ0
φ. This, in turn, gives µ[Y ] = µ[ 
φ∈Φ0
φ)] and ν[Y ] = ν[ 
φ∈Φ0
φ)].

Then, µ ≥L' ν together with ν |=  p 
φ∈Φ0
φ gives µ |=  p 
φ∈Φ0
φ, or equiva-

lently µ[Y ] ≥ p, for all p ∈ Q ∩ [ 0, ν[Y ] ]. Hence, µ[Y ] ≥ ν[Y ].	 

Logics for Coalgebraic Simulation
We now fix an endofunctor T : Set → Set and a T-relator Γ : Rel → Rel, and let = Γ denote the similarity relation induced by Γ. We are interested in languages for T-coalgebras which capture Γ-similarity.
Definition 4.13 A language for T-coalgebras is a pair ⟨L, |=⟩ with L a set and |== (|=γ) a |Coalg(T)|-indexed family of relations |=γ ⊆ C × L for γ : C → TC, such that:
f (c) |=δ ϕ iff c |=γ ϕ	for any f : ⟨C, γ⟩ → ⟨D, δ⟩ , c ∈ C , ϕ ∈ L .
Given ⟨L, |=⟩ and T-coalgebras ⟨C, γ⟩ and ⟨D, δ⟩, we say that c ∈ C logically simulates d ∈ D (and write c ≥L d) if c |=γ ϕ whenever d |=δ ϕ, for any ϕ ∈ L. ⟨L, |=⟩ is said to capture Γ-similarity if, for any T-coalgebras ⟨C, γ⟩ and ⟨D, δ⟩, the logical simulation relation ≥L ⊆ C × D coincides with the

Γ-similarity relation  ⊆ C × D.
Remark 4.14 Let α be a regular cardinal.  Then, any language of form
⟨Zα, Lα, |=α⟩ induces a language ⟨Lα, |=⟩ for T-coalgebras, with c |=γ ϕ if and only if γα(c) |=α ϕ, for any T-coalgebra ⟨C, γ⟩, c ∈ C and ϕ ∈ L (where γα : C → Zα is as in Remark 2.6). The fact that coalgebra homomorphisms f : ⟨C, γ⟩ → ⟨D, δ⟩ define morphisms of cones f : (γα) → (δα) ensures the correctness of this definition.
Now assume that T admits a final coalgebra ⟨F, ζ⟩, and recall from Re- mark 2.15 that, if c and d are as in Definition 4.13, then c   d if and only if !γ(c)   !δ(d).  Also, Definition 4.13 gives c ≥L d if and only if !γ(c) ≥L
!δ(d). Thus, in order to define a language for T-coalgebras which captures
Γ-similarity, it suffices to define a language of form ⟨F, L, |=⟩ which is expres- sive for ⟨F,  ⟩. But by (iii) of Proposition 2.14, ⟨⟨F, F,  ⟩, ⟨ζ, ζ⟩⟩ is a final Γ-coalgebra. This leads us to consider the final sequence of Γ : Rel → Rel.
Proposition 4.15 The ﬁnal sequence of Γ belongs to Preord.
Proof (Sketch). The statement follows by transfinite induction. Proposi- tion 2.2 is used in the case of limit ordinals.	 
As a result, the final sequence of Γ coincides with the final sequence of the restriction of Γ to Preord. This justifies the following definition.
Definition 4.16 The relation sequence induced by Γ is the final sequence of Γ : Preord → Preord.
An immediate observation is that the Set-sequence underlying the relation sequence induced by Γ is the final sequence of T. Thus, the relation sequence induced by Γ can be written (⟨Zα,  α⟩), (pα : ⟨Zα,  α⟩ → ⟨Zβ,  β⟩)β≤α.
The next step is to define, for each element Zα in the final sequence of T,
an expressive language for ⟨Zα,  α⟩. A similar definition was given in [5].
Definition 4.17 Let J : Lang → Lang be a language constructor for T. The
language sequence induced by J is the initial sequence 10 of J.
Again, the Set-sequence underlying the language sequence induced by J
is the final sequence of T.  We therefore write (⟨Zα, Lα, |=α⟩), (⟨pα, ια⟩ :
β  β
⟨Zβ, Lβ, |=β⟩ → ⟨Zα, Lα, |=α⟩)β≤α for the language sequence induced by J, and sα : Zα → УLα for the logical map induced by ⟨Zα, Lα, |=α⟩.
The next result concerns the expressiveness of languages in the language sequence induced by J w.r.t. relations in the relation sequence induced by Γ.

10 The initial sequence of an endofunctor is defined similarly to its final sequence.


Theorem 4.18 If J preserves expressiveness w.r.t. Γ, then ⟨Zα, Lα, |=α⟩ is expressive for ⟨Zα,  α⟩, for any ordinal α.
Proof. The proof is by induction on α. If α = β + 1, the expressiveness of
⟨Zα, Lα, |=α⟩ for ⟨Zα,  α⟩ follows from the expressiveness of ⟨Zβ, Lβ, |=β⟩ for
⟨Zβ,  β⟩ together with the preservation of expressiveness by J.
Now let α be a limit ordinal, and assume that ⟨Zβ, Lβ, |=β⟩ is expressive for
⟨Zβ,  β⟩, for any β < α. To show that ⟨Zα, Lα, |=α⟩ is adequate for ⟨Zα,  α⟩,
let x, y ∈ Zα be such that y α x. Then, for β < α, pα(y)  β pα(x), and hence,
β	β
using the adequacy of ⟨Zβ, Lβ, |=β⟩ for ⟨Zβ,  β⟩, sβ(pα(y)) ≥ sβ(pα(x)). Then,
β	β
Remark 4.2 gives (Уˆια)(sα(y)) ≥ (Уˆια)(sα(x)) for β < α. Now let ϕ ∈ sα(x).
β	β
Since the cocone (ια)β<α is colimiting, we have ϕ = ια(ψ) for some β < α and
β	β
some ψ ∈ Lβ. Then, ψ ∈ sβ(pα(x)), and hence ψ ∈ sβ(pα(y)) (or equivalently,
β	β
ψ ∈ (Уˆια)(sα(y))). This now gives ϕ = ια(ψ) ∈ sα(y). Hence, sα(y) ≥ sα(x).
β	β
To show that ⟨Zα, Lα, |=α⟩ is expressive for ⟨Zα,  α⟩, let x, y ∈ Zα be such
that sα(y) ≥ sα(x). Then, for β < α, Remark 4.2 gives sβ(pα(y)) ≥ sβ(pα(x)),
β	β
while the expressiveness of ⟨Zβ, Lβ, |=β⟩ for ⟨Zβ,  β⟩ gives pα(y)  β pα(x).
β	β
The fact that the cone (pα)β<α is limiting now gives y  α x.	 
Our aim is to derive a language for T-coalgebras which captures  .
Definition 4.19 Assume that the final sequence of Γ stabilizes at α. The language induced by ⟨J , Γ⟩ is the language ⟨Lα, |=⟩, as defined in Re- mark 4.14 11 .
Example 4.20 Let Γ⊇ and J⊇ be as in Examples 2.9 and 4.6, respectively. Since Γ⊇ preserves monics and is ω-accessible, it follows by Proposition 2.7 that its final sequence stabilizes. Moreover, the initial sequence of the endo- functor L : Set → Set taking L to ({T} ∪ { ϕ | ϕ ∈ L })∧ stabilises at ω. (L defines the syntax part of J⊇.) As a result, the language induced by ⟨J⊇, Γ⊇⟩ coincides with the following fragment of the standard modal language:
ϕ ::= T |  ϕ | ϕ ∧ ψ
The coalgebraic semantics of this fragment is defined by:
c |=γ  ϕ iff ∃ d ∈ γ(c).d |= ϕ
(and the usual clauses for T and ∧).
Example 4.21 Let JΓ be as in Section 4.2. The language induced by ⟨JΓ, Γ⟩ coincides with a fragment of the language defined in [1], only containing T

11 Here, ⟨Zα, Lα, |=α⟩ is the α-indexed element of the language sequence induced by F.


and  as propositional connectives. Its coalgebraic semantics agrees with [1].
Example 4.22 Let Γω and Jω be as in Sections 3.1 and 4.3. Using an argu- ment similar to the one in Example 4.20, we obtain that the language induced by ⟨Jω, Γω⟩ has syntax given by:
ϕ ::= T |  pϕ | ϕ ∧ ψ | ϕ ∨ ψ
and semantics given by:
c |=γ  pϕ iff γ(c)[ ϕ)γ] ≥ p
where ϕ)γ = { c ∈ C | c |=γ ϕ }. This language coincides with the unlabelled version of the language considered in [7].
The next result allows us to derive languages which capture Γ-similarity from language constructors which preserve expressiveness w.r.t. Γ.
Corollary 4.23 Let Γ and J be as in Theorem 4.18, and assume that Γ preserves monics and is accessible 12 . Then, the language induced by ⟨J , Γ⟩ captures  .
Proof. Let ⟨C, γ⟩ and ⟨D, δ⟩ be T-coalgebras, and let c ∈ C and d ∈ D. Then:
c  d iff !γ(c)  !δ(d) iff !γ(c)  α !δ(d) iff !γ(c) ≥Lα !δ(d) iff c ≥Lα d
The above equivalences follow from Remark 2.15, (iii) of Proposition 2.14, Theorem 4.18 and Definition 4.13, respectively.	 
By instantiating ⟨J , Γ⟩ with ⟨JΓ, Γ⟩ and ⟨Jω, Γω⟩, we obtain alternative proofs of the expressiveness w.r.t. similarity of the logics defined in [1] and [7] (in the unlabelled case), respectively.
We conclude this section with some results concerning the final sequence of a T-relator Γ, in case the hypotheses of Corollary 4.23 are satisfied.
Proposition 4.24 Let Γ and J be as in Corollary 4.23 13 . Furthermore, assume that there exists a functor L : Set → Set such that J takes ⟨X, L, |=⟩ to a language of form ⟨TX, LL, |='⟩, for each ⟨X, L, |=⟩ ∈ |Lang|. If the ﬁnal sequence of T stabilises at α, and the initial sequence of L stabilises at β ≤ α, then the ﬁnal sequence of Γ also stabilises at α.

12 Hence, by Proposition 2.7, the relation sequence induced by Γ stabilizes at some α.
13 In particular, F preserves expressiveness w.r.t. Γ.


Proof. The construction of colimits in Lang results in the final sequence of J
being of form (⟨Lα, Zα, |=α⟩), (⟨ια, pα⟩), where (Lα), (ια) is the initial sequence
β	β	β
of L, and (Zα), (pα) is the final sequence of T. Moreover, the additional con-
straints on T and L together with the definition of arrows in Lang ensure that the final sequence of J also stabilises at α.
On the other hand, by Theorem 4.18, ≥Lα and ≥Lα+1 capture  α and
 α+1, respectively. Hence, for x, y ∈ Zα+1, the following holds:


α+1 y iff x ≥L
iff pα+1(x) ≥L pα+1(y) iff pα+1(x)  α pα+1(y)

α+1	α	α  α	α	α

with the second equivalence following from the fact that ⟨ια+1, pα+1⟩ defines
α	α
an isomorphism in Lang. As a result, pα+1 : ⟨Zα+1,  α+1⟩ → ⟨Zα,  α⟩ is an isomorphism in Rel, and hence the final sequence of Γ stabilises at α.	 

Thus, Proposition 4.24 allows us to make statements about the degree of accessibility of a T-relator Γ, by exhibiting a language constructor for T which preserves expressiveness w.r.t. Γ. All the examples considered in this paper are such that the functor L of Proposition 4.24 exists.
We now assume that T is ω-accessible. Then, as noted in [14], the final sequence of T stabilises at ω + ω. Moreover, the maps pω+n+1 with n = 0, 1,... are all injective. Combining this observation with Proposition 4.24 yields the following result.
Corollary 4.25 Let T : Set → Set be an ω-accessible endofunctor, let Γ : Rel → Rel, J : Lang → Lang and L : Set → Set be as in Proposition 4.24, and assume that L is ω-accessible. Then:
The ﬁnal sequence of Γ stabilises at ω + ω.

The maps pω+n+1
: ⟨Zω+n+1,  ω+n+1⟩ → ⟨Zω+n+1,  ω+n+1⟩ with n =

0, 1,... are order-reflecting.
Proof. The fact that L is ω-accessible results in its initial sequence stabilising at ω. The first statement then follows immediately from Proposition 4.24. The second statement follows by an argument similar to the one in the proof of Proposition 4.24.	 

Thus, under the hypotheses of Corollary 4.25, the last ω-steps in the final sequence of Γ are determined by the corresponding steps in the final sequence of T. The induced language for coalgebras is not influenced by these steps.
If Γ⊇ and Γω are as in Example 2.9 and Section 3.1, respectively, it follows from Corollary 4.25 that their final sequences stabilise at ω + ω.

Compositionality
In this section we show that various operations on coalgebraic types induce operations on relators on the one hand, and on language constructors on the other. Moreover, the expressiveness of language constructors w.r.t. given rela- tors is preserved by the induced operations. As a result, notions of similarity for complex coalgebraic types, as well as logics capturing them can be derived in a compositional manner.
We begin by recalling the definition of products and coproducts in Rel. If Ri ⊆ Xi × Yi with i = 1, 2, then R1 × R2 ⊆ (X1 × X2) × (Y1 × Y2) and R1+R2 ⊆ (X1 + X2) × (Y1 + Y2) are given by:
(x1, x2) (R1 ×R2) (y1, y2) iff x1 R1 y1 and x2 R2 y2 ιi(xi) (R1+R2) ιj(yj) iff i = j and xi Ri yi

with xi ∈ Xi and yi ∈ Yi, for i = 1, 2. Similarly to products, one can define, for each relation R1 ⊆ X1 × Y1, a relation (R1)A ⊆ (X1)A × (Y1)A by:
(xa)a∈A (R1)A (ya)a∈A iff xa R1 ya for all a ∈ A
with xa ∈ X1 for a ∈ A. The above operations on relations can be used to derive (T1 × T2)-, (T1 + T2)- and (T1)A-relators from T1- and T2-relators.
Definition 5.1 Let Γ1 and Γ2 be relators for T1 and T2, respectively. Define Γ1 ⊕ Γ2 , Γ1 ⊗ Γ2 , (Γ1)A : Rel → Rel by:
R ⊆ X × Y  Γ1⊕Γ2 zΓ,1(R)+ Γ2(R) ⊆ (T1+T2)X × (T1+T2)Y
R ⊆ X × Y  Γ1⊗Γ2 zΓ,1(R) × Γ2(R) ⊆ (T1×T2)X × (T1×T2)Y
R ⊆ X × Y (Γ1 )A zΓ,(R)A ⊆ (T X)A× (T Y )A .
1	1	1
In addition, relators can be combined using functor composition.
Proposition 5.2 Γ1◦Γ2 , Γ1⊕Γ2 , Γ1⊗Γ2 , (Γ1)A are relators for T1◦T2 , T1+ T2 , T1 × T2 and (T1)A, respectively.
This allows us to derive relators (and therefore notions of simulation) for combinations of coalgebraic types from relators for the types being combined.
Example 5.3 Let Γ⊇ be as in Example 2.9. A relation R ⊆ C ×D is a (Γ⊇)A- simulation between (Уω)A-coalgebras ⟨C, γ⟩ and ⟨D, δ⟩ if, whenever cRd and d' ∈ δ(d)(a) for some a ∈ A, there exists c' ∈ γ(c)(a) such that c' R d'. More- over, it is shown in [10] that (Γ⊇)A-similarity coincides with trace inclusion:


c  d if and only if traces(c) ≥ traces(d), where, for c ∈ C, traces(c) con- sists of all finite sequences (a1,... , an) of elements of A, such that there exist c0, c1,... , cn ∈ C with c0 = c and ci ∈ γ(ci−1)(ai) for i = 1,... , n.
Example 5.4 Let Γω be as in Section 3.1. A relation R ⊆ C × C is a (Γω)A- simulation on an (Sω)A-coalgebra ⟨C, γ⟩ if, whenever cR d, a ∈ A and X ⊆
C is R -closed, we have γ(c)(a)[X] ≥ γ(d)(a)[X]. Thus, (Γω)A-simulation
coincides with the notion of simulation defined in [7] (see Remark 3.10).
Next, we show how language constructors for combinations of coalgebraic types can be obtained by combining language constructors for the component types.
Definition 5.5 Let J1 and J2 be language constructors for T1 and T2, re- spectively. Define J1 ⊕ J2 , J1 ⊗ J2 , (J1)A : Lang → Lang by 14 15 :
⟨X, L, |=⟩  F1⊕F2 z⟨ ,(T1+T2)X, { ⟨κi⟩ϕ | ϕ ∈ Li } , (Gr(ι1)◦ |=1 ◦Gr(ι−1)) ∪
(Gr(ι2)◦ |=2 ◦Gr(ι−1)) ⟩
⟨X, L, |=⟩  F1⊗F2 z⟨ ,(T1× T2)X, { [πi]ϕ | ϕ ∈ Li } , (Gr(ι1)◦ |=1 ◦Gr(π1)) ∪
(Gr(ι2)◦ |=2 ◦Gr(π2)) ⟩

X, L, |=⟩ (F1 )A  ⟨ (T X)A, { [a]ϕ | ϕ ∈ L } ,   (Gr(ι )◦ |=
Gr(π )) ⟩

⟨	z, 1
1		a	1	a a∈A

if ⟨X, L, |=⟩  Fi z⟨ ,T X , L , |= ⟩ for i = 1, 2.
We note that the modal operators [πi] and ⟨κi⟩ with i = 1, 2 and [a] with
a ∈ A are similar to the ones used in [9].
Remark 5.6 Since the set of formulae of (J1⊕J2)⟨X, L, |=⟩ is (isomorphic to) the coproduct L1 + L2, the associated satisfaction relation could equivalently be defined as the coproduct |=1 + |=2 in Rel. We have chosen the more complex formulation in Definition 5.5 for coherence with the definitions of J1 ⊗ J2 and (J1)A. An alternative approach to defining J1⊗J2 and (J1)A would be to take L1×L2 and (L1)A as sets of formulae in (J1 ⊗J2)⟨X, L, |=⟩ and (J1)A⟨X, L, |=
⟩, respectively, in which case the corresponding satisfaction relations would be given by |=1 × |=2 and (|=1)A, respectively. The reason for not taking this approach is that, for A infinite, this yields infinitary modal operators.
Language constructors can also be combined using functor composition.

14 Similar operations on language constructors were defined in [5].
15 In each case, the formula T, with the required interpretation, is also added to the resulting
language.


Proposition 5.7 J1 ◦J2 , J1 ⊕J2 , J1 ⊗J2 , (J1)A are language constructors for T1 ◦ T2 , T1 + T2 , T1 × T2 and (T1)A, respectively.
Example 5.8 Let J⊇ be as in Example 4.6. Then, (J⊇)A takes a language
⟨X, L, |=⟩ to the language ⟨ (УωX)A , L' , |=' ⟩, where L' is generated in two steps by the following syntax:
L' e ϕ' ::= T | [a]ρ	(ρ ∈ L0)
L0 e ρ ::= T |  ϕ | ρ1 Λ ρ2	(ϕ ∈ L)
and where |=' ⊆ (УωX)A × L' is defined in two steps by:
f |=' [a]ρ iff f (a) |=0 ρ	(f ∈ Уω(X)A)
Y |=0  φ iff E x ∈ Y. x |= ϕ	(Y ∈ Уω(X))
Since the modal operator [a] distributes over conjunctions, the language in- duced by ⟨(J⊇)A, (Γ⊇)A⟩ is equivalent to a fragment of Hennessy-Milner logic (with [a]T being semantically equivalent to T, and with [a] ϕ being seman- tically equivalent to ⟨a⟩ϕ' whenever ϕ is semantically equivalent to ϕ').
Example 5.9 Let Jω be as in Section 4.3. It then follows by an argument similar to the one in Example 5.8 that the language induced by ⟨(Jω)A, (Γω)A⟩ is equivalent to a fragment of the language used in [7] (with a formula of form [a] pϕ corresponding to a formula of form ⟨a⟩pϕ').
Our next result shows that the expressivity condition required to derive ex- pressive logics for simulation is preserved by the previously-defined operations on relators and language constructors, respectively.
Proposition 5.10 If Ji preserves expressiveness w.r.t. Γi, for i = 1, 2, then J1 ◦ J2, J1 ⊕ J2, J1 ⊗ J2 and (J1)A preserve expressiveness w.r.t. Γ1 ◦ Γ2, Γ1 ⊕ Γ2, Γ1 ⊗ Γ2 and (Γ1)A, respectively.
Proof (Sketch). In the case of J1 ◦ J2, the statement follows immediately from the definition of preservation of expressiveness w.r.t. a relator. Of the remaining cases, we only consider that of coproducts. (The other two are treated similarly.) Let ⟨X, L, |=⟩ be expressive for ⟨X, R⟩. Hence, Ji⟨X, L, |=
⟩ = ⟨TiX, Li, |=i⟩ is expressive for ⟨TiX, ΓiR⟩. Now let i, j ∈ {1, 2}, ti ∈ TiX
and sj ∈ TjX. If i /= j, the fact that ιi(ti) and ιj(sj) are not related by Γ1R + Γ2R is witnessed by the formula ⟨κj⟩T, which holds in ιj(sj) but not in ιi(ti). If i = j, the fact that ιi(ti) and ιi(si) are not related by Γ1R × Γ2R (and therefore ti and si are not related by ΓiR) is witnessed by the formula
⟨κi⟩ϕi, where ϕi holds in si but not in ti.	 


Example 5.11 Taking ⟨J , Γ⟩ = ⟨(J⊇)A, (Γ⊇)A⟩ in Corollary 4.23 yields a language which characterizes trace inclusion. Its syntax is given by:
L e ϕ ::= T | [a]ρ	(ρ ∈ L0)
L0 e ρ ::= T |  ϕ | ρ1 Λ ρ2	(ϕ ∈ L)
while its coalgebraic semantics is defined inductively by:
f |= [a]ρ iff f (a) |=0 ρ	(f ∈ Уω(C)A)
Y |=0  ϕ iff E c ∈ Y. c |=γ ϕ	(Y ∈ Уω(C))
c |=γ ϕ iff γ(c) |= ϕ	(c ∈ C)
with ⟨C, γ⟩ a (Уω)A-coalgebra.
Example 5.12 Similarly, taking ⟨J , Γ⟩ = ⟨(Jω)A, (Γω)A⟩ yields a language which characterizes probabilistic simulation. Its syntax is given by:
L e ϕ ::= T | [a]ρ	(ρ ∈ L0)
L0 e ρ ::= T |  pϕ | ρ1 Λ ρ2 | ρ1 V ρ2	(ϕ ∈ L)
while its coalgebraic semantics is defined inductively by:
f |= [a]ρ iff f (a) |=0 ρ	(f ∈ £ω(C)A)
µ |=0  pϕ iff µ[ ϕ)γ] ≥ p	(µ ∈ £ω(C))
c |=γ ϕ iff γ(c) |= ϕ	(c ∈ C)
with ⟨C, γ⟩ an (£ω)A-coalgebra.
Finally, it is also possible to define language constructors for constant and identity functors: in the case of the constant functor X '→ A, the language constructor provides an atomic formula a for each a ∈ A, whereas in the case of the identity functor, the language constructor is itself the identity (on Lang). Each of these language constructors preserves expressiveness w.r.t. the corre- sponding minimal relator. As a result, the compositional techniques described in this section can be applied to any functor T of form:
T ::= A | Id | Уω | £ω | T1 ◦ T2 | T1 + T2 | T1 × T2 | (T1)A
in order to derive both a notion of simulation for T-coalgebras, and a logic which captures this notion of simulation. This yields notions of simulation and corresponding logics for a variety of probabilistic system types (see e.g. [2] for a survey of probabilistic system types studied in the literature).

Conclusions
We have presented an inductive method for defining logics which capture simulation. We used relators to define notions of simulation for coalgebraic types, language constructors to formalise one step in the definition of languages for coalgebras, and an expressivity condition involving a language constructor and a relator to ensure the expressiveness of the induced languages w.r.t. the induced notions of simulation. This method was applied to obtain Baltag’s logics for coalgebraic simulation, as well as logics capturing simulation on unlabelled (probabilistic) transition systems.
We have also shown that various operations on coalgebraic signatures in- duce corresponding operations on relators as well as on language constructors, with the expressivity condition being preserved by the induced operations. This has resulted in compositional techniques for defining notions of simula- tion and logics which capture simulation. Such techniques were used to obtain a coalgebraic characterization of simulation on discrete Markov processes, as well as a logic which captures this notion of simulation.
Our approach can also be used to derive notions of simulation and suitable logics for other probabilistic system types, including types which combine nondeterminism and probability (through a combination of Уω and £ω in the
signature functor). The study of the resulting logics and of their relevance to
system specification is the subject of ongoing work.

References
A. Baltag. A logic for coalgebraic simulation. In H. Reichel, editor, Coalgebraic Methods in Computer Science, volume 33 of Electronic Notes in Theoretical Computer Science. Elsevier, 2000.
F. Bartels, A. Sokolova, and E. de Vink. A hierarchy of probabilistic system types. In H.P. Gumm, editor, Coalgebraic Methods in Computer Science, volume 82.1 of Electronic Notes in Theoretical Computer Science, 2003.
F. Borceux. Handbook of Categorical Algebra, volume II. Cambridge University Press, Cambridge, 1994.
A. Carboni, G.M. Kelly, and R.J. Wood. A 2-categorical approach to change of base and geometric morphisms I. Technical Report 90-1, Department of Pure Mathematics, University of Sidney, 1990.
C. Cˆırstea. On expressivity and compositionality in logics for coalgebras. In H.P. Gumm, editor, Coalgebraic Methods in Computer Science, volume 82.1 of Electronic Notes in Theoretical Computer Science. Elsevier, 2003.
E.P. de Vink and J.J.M.M. Rutten. Bisimulation for probabilistic transition systems: a coalgebraic approach. Theoretical Computer Science, 221:271–293, 1999.
J. Desharnais.  A logical characterisation of simulation for labelled Markov chains.  In
Proceedings of PROBMIV’99. University of Birmingham, 1999. Technical Report CS-99-8.


W.H. Hesselink and A. Thijs. Fixpoint semantics and simulation. Theoretical Computer Science, 238:275–311, 2000.
B. Jacobs. Many-sorted coalgebraic modal logic: a model-theoretic study. Theoretical Informatics and Applications, 35, 2001.
B. Jacobs and J. Hughes. Simulations in coalgebra. In H.P. Gumm, editor, Coalgebraic Methods in Computer Science, volume 82.1 of Electronic Notes in Theoretical Computer Science. Elsevier, 2003.
K.G. Larsen and A. Skou. Bisimulation through probabilistic testing. Information and Computation, 94:1–28, 1991.
L.S. Moss. Coalgebraic logic. Annals of Pure and Applied Logic, 96:277–317, 1999.
A. Thijs. Simulation and Fixpoint Semantics. PhD thesis, Rijksuniversiteit Groningen, 1996.
J. Worrell. Terminal sequences for accessible endofunctors. In B. Jacobs and J. Rutten, editors, Coalgebraic Methods in Computer Science, volume 19 of Electronic Notes in Theoretical Computer Science. Elsevier, 1999.
