

Electronic Notes in Theoretical Computer Science 247 (2009) 51–66
www.elsevier.com/locate/entcs
Introducing Polymodal Neighbourhood Logics
Renata de Freitas1,2 Petrucio Viana3,4
Institute of Mathematics Fluminense Federal University Nitero´i, Brazil

Abstract
In this paper, we start the study of polymodal neighbourhood languages. We provide a completeness result for the basic polymodal neighbourhood system and show how some important systems based on neighbourhood like semantics can be simulated as subsystems of ours.
Keywords: polymodal logic, neighbourhood semantics, completeness, translations between logics


Introduction
We want to define a family of formal systems adequate to represent, analyse, and compare information involving vague notions, graded quantifiers, etc., as illustrated by the following examples. Our systems will be general enough to contain as sub- systems most of the systems previously proposed to deal with the same phenomena.
Example 1.1 Consider the sentence
All my friends are logicians.
Sentence (1) refers to
a set of individuals, including me;
a binary relation F of friendship between individuals of the domain; and
a concept l of being a logician, applicable to those individuals. Using ordinary modal logic, (1) can be represented as

1 Partly sponsored by FAPERJ (PRONEX E-26/171.180/2003).
2 Email: freitas@vm.uff.br
3 Partly sponsored by FAPERJ (PRONEX E-26/171.180/2003 and APQ1-170.335/2006) and FAPESP (ConsRel 2004/14107-2).
4 Email: petrucio@cos.ufrj.br

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.048

me H  F l,
where F is the unary modal operator corresponding to the binary accessibility relation F . It is well known that (2) is a shorter adequate way to represent the first-order sentence
∀x(F (me, x) → l(x)).
Now, consider the sentence
I have a friend that is a logician.
Sentence (3), referring to the same concepts as above, can be represented as
me H  F l,
where  F is the dual of  F . Similarly, (4) in its turn is a shorthand for the first- order sentence
∃x(F (me, x) ∧ l(x)).

Example 1.2 Now, consider the sentence
A good amount of my friends are logicians.
This sentence refers to the same concepts treated in (1) and (3), besides a new concept M of a good amount in the set of all my friends. Since concept M seems to have a second-order flavour, there is no obvious way to represent (5) using the apparatus sketched in Example 1.1. In fact, assuming we have a way to differentiate the sets that contains a good amount of my friends from the sets that do not have this property, (5) may be represented as
{y : F (me, y) ∧ l(y)}∈ M,
where M is a family of sets such that each set in M is considered to contain a good amount of my friends. We propose to formalize (6) as
me H qF l,
maintaining a modal setting, which is apparent from the syntactical form of (5) when compared to (1), and the fact that ‘a good amount of’ may be considered as a generalized quantifier.

It is easy to see that, in passing from Example 1.1 to Example 1.2, we indeed made a generalization. In fact, F and F are both particularizations of qF as follows. Given the set W of individuals at hand, consider the families E and A of subsets of W , defined by:



and
E = {X ⊆ {y : F (me, y)} : X /= ∅}


A = {{y : F (me, y)}}.

Under this notation, we have:
me H  F l iff ∀x(F (me, x) → l(x))
iff {y : F (me, y) ∧ l(y)} = {y : F (me, y)}
iff {y : F (me, y) ∧ l(y)}∈ A,
and, analogously,
me H  F l iff ∃x(F (me, x) ∧ l(x))
iff {y : F (me, y) ∧ l(y)} /= ∅
iff {y : F (me, y) ∧ l(y)}∈ E.
There are a number of modal like systems proposed to represent and reason formally with sentences containing such concepts as ‘a good amount’, ‘majority’, and ‘at least n’ [4,2,8,1]. In this paper, we present an alternative one, Polymodal Neighbourhood Logics — PNL, which has the following two contrasting properties:
It is a direct generalization of basic modal logic systems.
It is strong enough to have as (adequately defined) subsystems most of the main systems proposed in the literature to cover with similar phenomena.
Since PNL is a direct generalization of the basic modal logic, it is possible to gen- eralize most of the main results on modal logic to PNL. We are interested in inves- tigating expressivity, axiomatizability, and decidability issues, following the main lines adopted in [3]. Moreover, the generality conveyed by PNL makes it easy, when in the presence of a situation one desires to analyse by logical means, to extend the system with some new axioms to make it adequate for the analysis in question. We hope the (re-)formulation of known systems as instances of PNL will make it possible to use the polymodal neighbourhood versions of basic results of modal logic to study these systems.
Here, we set the basics of the system PNL, extending the idea of a basic modal system to PNL, and show how the systems presented in [4,2,8,1] can be constructed as simple instances of our formalism. More specifically, we exemplify the use of PNL by presenting simple versions of results in [8,1], obtained by applying the general strategy sketched above of extending PNL and apply general versions of basic results. This gives insight into the essential features of these systems as well as brings to light the many relations between these systems.
Mathematically, the results we present here can be viewed as direct applications of some known techniques when transported to a more general setting. Our main contributions are conceptual. On the one hand, the generalization to multi-modal and poly-modal setting is useful because it shows how many known systems can be captured in a unified way. On the other hand, the fact that complicated new techniques are not needed shows how natural this framework is.
Section 2 presents syntax and semantics for PNL. Section 3 presents a sound and complete axiomatization system for PNL. Section 4 presents the systems of modal logic for vague notions [2], graded modalities [8], and default modal logic [1]

as subsystems of PNL. Section 5 contains some directions for future work.

PNL language
Since we intend to follow the lines adopted in [3] for the study of modal like systems, there is no reason to maintain ourselves within the unary operators perspective. Besides, in certain cases, to present a more transparent treatment of the syntactical and semantical matters involved, the most general perspective we adopt here of introducing n-ary operators, for n ≥ 2, is convenient, as the following example shows.
Example 2.1 Consider again the sentence (5) from Example 1.2, which was formal- ized as qF l, by using the unary modal operator qF , indexed by F . Alternatively, we can adopt a binary modal operator q and formalize sentence (5) as q(f, l), where f is the set of all my friends, i.e., the image of me under the relation F and l is the set of all logicians. In this particular case, the proper reading of the formula q(f, l) should imply that the relation me H q(f, l) holds when the set of all my friends that are logicians contains a good amount of the set of all friends.
By using qF , we can symbolize a sentence as
A good amount of my friends are non-logicians.
directly as qF чl. On the other hand, when restricted to this language, it seems that there is no direct way to symbolize sentences as

(8)
or (9)
A good amount of my non-friends are logicians.

A majority of my non-friends are not logicians.

By using the q above, these sentences can be symbolized directly as q(чf, l) and q(чf, чl), respectively. So, in some situations, by using a binary operator we can prevent ourselves from introducing a family of ad hoc unary operators.
We say that a modal language is multimodal if its signature contains more than one modal operator. We say that a modal language is polymodal if its signature contains some n-ary operator with n ≥ 2. By adopting this nomenclature, we say that PNL is a multi and polymodal generalization of the basic modal system.
As a matter of fact, there is no syntactic difference between polymodal languages in the Kripkean setting and in the neighbourhood setting. A modal similarity type is a pair S = (O, ρ), where O = {qi : i ∈ I} is a set whose elements are called modal operators, or simply operators, typically denoted by  and q, and ρ : O → ω is a function called the rank function. We do not impose any restriction on the cardinality of the index set I, although in the specific cases treated in Section 4 it will be finite or enumerable. Given q ∈ O, the natural number ρ(q) is called the rank of q. A modal language is a pair L = (S, Pvar), where S is a modal similarity type and Pvar is a set whose elements are called propositional variables, typically denoted by p, q, r.

Definition 2.2 Let L = (S, Pvar) be a modal language. The formulas of L, typically denoted by ϕ, ψ, θ, are defined by the following grammar:
ϕ ::= p | чϕ | ϕ1 V ϕ2 | q(ϕ1,..., ϕn),
for each modal operator q of rank n in S.
We assume, as usual, that the Booleans Λ, → and — are defined operators.
Semantically, our language is a generalization of the minimal models semantics of [4], nowadays called neighbourhood semantics.
Definition 2.3 A frame is a pair F = (W, {Nq : q ∈ O}), where W is a non-empty set and Nq is a mapping




for each n-ary operator q.

Nq : W → 2
n times

 
2W × . . . × 2W ,

Definition 2.4 A model is a triple M = (W, {Nq : q ∈ O},V ), where F = (W, {Nq : q ∈ O}) is a frame and V : Pvar → 2W is an assignment. We say that M is based on F.
Definition 2.5 The meaning [[ϕ]]M of a formula ϕ in a model M is defined by the following clauses.
[[p]]M ::= V (p),
[[чϕ]]M ::= W \ [[ϕ]]M,
[[ϕ1 V ϕ2]]M ::= [ϕ1]]M ∪ [[ϕ2]]M,
[[ q (ϕ1,..., ϕn)]]M ::= {w ∈ W : ( [ϕ1]]M,..., [[ϕn]]M) ∈ Nq(w)},
for every n-ary operator q.
The relation between the last clause of Definition 2.5 and vague notions, guarded quantifiers, etc., may not be apparent at a first sight. So, let us clarify it. First, we introduce a more usual notation. We write M,w H ϕ, or simply w H ϕ, when w ∈ [[ϕ]]M. Hence, [ϕ]]M = {w ∈ W : w H ϕ} and the last clause above may be rewritten as:
w H q(ϕ1,..., ϕn) iff ({u1 ∈ W : u1 H ϕ1},..., {un ∈ W : un H ϕn}) ∈ Nq(w),
for any state w in a model M = (W, {Nq : q ∈ O},V ). Now, considering, for instance, a unary operator q, we obtain particularly w H qϕ iff {u ∈ W : u H ϕ} ∈ Nq(w). This should be read keeping in mind that the mapping Nq maps to each state w in W the family of subsets of W which w consider as interesting by having a good amount of elements, or the majority of elements, or a number of elements above a certain threshold, etc. Hence, according to Definition 2.5, a formula qϕ is satisfied in a state w iff the set of states that satisfies ϕ is one of the interesting sets under w views, i.e., is one of the sets which have a good amount

of elements, or the majority of elements, or a number of elements above a certain threshold, etc.
Satisfiability and truth of a formula in a model as well as in a class of models is defined as usual. For instance, when q is a ternary operator, then the following formula is valid:
q(ччp, ч(p Λ q), ч(p V q)) — q(p, чp V чq, чp Λ чq).
Interesting examples of formulas which, besides not being valid, are true in models satisfying certain conditions will be given throughout the text.
We will adopt the local perspective emphasized in [3] to define the notion of consequence of a formula from a set of formulas.
Definition 2.6 Let Σ ∪ {ϕ} be a set of formulas.
Given a model M and a state w ∈ W , we say that M,w H Σ when M,w H ϕ, for every ϕ ∈ Σ.
We say that Σ H ϕ when for every model M and state w ∈ W , if M,w H Σ, then M,w H ϕ.
Systems of modal logic with neighbourhood semantics [4] are generalizations of basic modal logic [3]. Here, we generalize neighbourhood semantics, since neigh- bourhood formulas and meaning definitions of [4] are just very special cases of Definitions 2.2, 2.3, 2.4, and 2.5, in which the similarity type consists of a single unary operator.
PNL proof theory
In this section we present a sound and complete calculus for the local consequence relation of PNL, that is a straighforward generalization of the system and proof techniques presented in [4].
Definition 3.1  (i) Given a modal language L = (S, Pvar), the axioms and rules of the basic neighbourhood modal calculus, BNC, are presented in Table 1.
A proof of a formula ϕ is a sequence (ϕ1,..., ϕn) such that ϕn = ϕ and, for each i = 1,..., n:
ϕi is an axiom, or
ϕi is a consequence of previous formulas in the sequence by MP or Equ.
A formula ϕ is a theorem, denoted by ▶ ϕ, if there exists a proof of ϕ.
A derivation of a formula ϕ from a set of formulas Σ is a sequence (ϕ1,..., ϕn) such that ϕn = ϕ and, for each i = 1,..., n:
ϕi ∈ Σ, or
ϕi is a theorem, or
ϕi is a consequence of previous formulas in the sequence by MP.
A formula ϕ is a derivable from a set of formulas Σ, denoted by Σ ▶ ϕ, if there is a derivation of ϕ from Σ.

Table 1
Axioms and rule of BNC


Taut ϕ	if ϕ is a propositional tautology

ϕ → ψ, ϕ
MP
ψ


Equ 	ϕ1 — ψ1,..., ϕn — ψn	
o(ϕ1,..., ϕn) — o(ψ1,..., ψn)
if o is an operator of rank n





The local semantical perspective we adopted in Definition 2.6 is captured in the items (ii) and (iv) of Definition 3.1. When using (iv) to construct derivations from hypothesis, the applications of rule Equ are restrict only to the theorems obtained by using (ii).
Soundness is easy, as usual.

Theorem 3.2 (Soundness) If Σ ▶ ϕ, then Σ H ϕ.

Proof. The proof has two parts. First, to prove every theorem is valid, just notice that all tautologies are valid and that both MP and Equ preserve validity. Second, to prove every formula derivable from a set of formulas is also a (local) consequence of this set, just notice that MP preserves satisfiability.	 

Now we shall prove completeness of our set of rules. We assume the notions of consistent and deductively closed set of formulas as well as their standard properties and adapt the canonical model approach to our semantics as follows.

Definition 3.3 The canonical model Mc = (Wc, {Nc : o ∈ O},V c) is defined by:
Wc = {Γ : Γ is consistent and deductively closed},
Nc (Γ) = {({Θ : ψ1 ∈ Θ},..., {Θ : ψn ∈ Θ}) : o(ψ1,..., ψn) ∈ Γ},
V c(p) = {Γ : p ∈ Γ}.

Lemma 3.4 (Satisfiability Lemma) Given a formula ϕ and a consistent and deductively closed set Γ,
Mc, Γ H ϕ iff ϕ ∈ Γ.

Proof. The atomic and Boolean cases are easy.  To prove the equivalence to a

generic modal operator o of rank n, we proceed as follows:
Mc, Γ H o(ϕ1,..., ϕn) iff ([[ϕ1]]Mc ,..., [[ϕ1]]Mc ) ∈ Nc (Γ) iff
({Θ : Mc, Θ H ϕ1},..., {Θ : Mc, Θ H ϕn}) ∈ Nc (Γ) iff (by IH)
({Θ : ϕ1 ∈ Θ},..., {Θ : ϕn ∈ Θ}) ∈ Nc (Γ) iff
o(ϕ1,..., ϕn) ∈ Γ.
The last equivalence is justified as follows:
(⇒) Suppose ({Θ : ϕ1 ∈ Θ},..., {Θ : ϕn ∈ Θ}) ∈ Nc (Γ). Hence, there are formulas
ψ1,..., ψn such that:
o(ψ1,..., ψn) ∈ Γ,
{Θ : ϕ1 ∈ Θ} = {Θ : ψ1 ∈ Θ},
... 
{Θ : ϕn ∈ Θ} = {Θ : ψn ∈ Θ}.
So, for every consistent and deductively closed set of formulas Θ, we have:
ϕ1 ∈ Θ iff ψ1 ∈ Θ
.
ϕn ∈ Θ iff ψn ∈ Θ,
which is equivalent to
ϕ1 — ψ1 ∈ Θ,
.
ϕn — ψn ∈ Θ.
Hence, ▶ ϕ1 — ψ1,..., ▶ ϕn — ψn. By Equ, ▶ o(ϕ1,..., ϕn) — o(ψ1,..., ψn). Now, since Γ is deductively closed, we have o(ϕ1,..., ϕn) — o(ψ1,..., ψn) ∈ Γ. Since o(ψ1,..., ψn) ∈ Γ, we have o(ϕ1,..., ϕn) ∈ Γ.
Observe that we just applied Equ to theorems.
(⇐) Suppose o(ϕ1,..., ϕn) ∈ Γ. Hence, ({Θ : ϕ1 ∈ Θ},..., {Θ : ϕn ∈ Θ}) ∈
Nc (Γ), by definition.	 

Theorem 3.5 (Completeness) If Σ H ϕ, then Σ ▶ ϕ.

Proof. As usual, by applying the Satisfiability Lemma and the fact that ▶ has all the properties we need.	 

Some comparisons
In this section we shall show that our setting is strong enough to cope with most of the approaches that have been proposed to the treatment of information based on some form of neighbourhood semantics.

Basic modal logic
The basic modal logic is a particular case of modal logic with the neighbourhood semantics, as shown in [4]. Here, we reproduce the argument, for the sake of com- pleteness. This section also can be viewed as an warm up to the work in Section 4. The basic similarity type has just one modal operator  of rank 1. So, it is
the modal similarity type ({ }, {( , 1)}) and the basic formulas are defined by the
following grammar:
α ::= p | чα | α1 V α2 |  α
The basic models are the structures M = (W, R, V ), where W /= ∅, R ⊆ W ×W , and V : Pvar → 2W is an assignment. The meaning of a basic formula α in a basic model M is defined by the usual conditions for the atomic and the Booleans, together with the following clause, where R(w) = {w' ∈ W : wRw'}:
[[ α]]M ::= {w ∈ W : R(w) ⊆ [[α]]M}.
In a more usual notation:
w H  α iff 6w' ∈ W : if wRw' then w' H α.
Let us take a similarity type having just one unary operator q. The translation from basic formulas α to neighbourhood formulas αn just replaces all occurrences of
  by q, in each place where  occurs inside α.
Given a basic model M = (W, R, V ), we define the corresponding neighbourhood model Mn = (W, Nq,V ) by setting
Nq(w) = {X ⊆ W : R(w) ⊆ X},
for every w ∈ W .
Proposition 4.1 Let α be a basic formula and M be a basic model. Then
[[α]]M = [[αn]]Mn .
Proof. The proof is straightforward from the definitions, by induction on α.	 
Reciprocally, the translation from formulas ϕ to basic formulas ϕb just replaces all occurrences of q by  , in each place where q occurs inside ϕ.
We say that a polymodal neighbourhood frame F = (W, Nq) is a b-frame when the mapping Nq satisfies properties (B1) and (B2), for all w ∈ W and X, Y ∈ 2W .
(B1)   Nq(w) ∈ Nq(w),


(B2)	if X ∈ Nq(w) and X ⊆ Y, then Y ∈ Nq(w).

The role conditions (B1) and (B2) play will be clear from the proof of Proposi- tion 4.2.
We say that a model is a b-model when it is based on a b-frame. Note that,
given a basic model M, the corresponding neighbourhood model Mn is a b-model. Now, for every b-model M = (W, Nq,V ), we define the corresponding basic model Mb = (W, R, V ) by setting
R(w) = ∩Nq(w),
for every w ∈ W .
Proposition 4.2 Let ϕ be a formula and M be a b-model. Then
[[ϕ]]M = [[ϕb]]Mb .
Proof. By induction on ϕ.  The proof of the atomic and the Boolean cases is straightforward. The modal case is proved as follows.
w ∈ [[ q ϕ]]M iff [ϕ]]M ∈ Nq(w)
iff  [ϕb]]Mb ∈ Nq(w) (by IH)
iff ∩Nq(w) ⊆ [[ϕb]]Mb (by (B1) and (B2)) iff R(w) ⊆ [[ϕb]]Mb
iff w ∈ [[ ϕb]]Mb
iff w ∈ [[(qϕ)b]]Mb .
This completes the proof.	 

Modal logic for vague notions
Modal logic for vague notions was introduced in [2] and further developed in [10]. It aims the precise treatment of assertions involving some versions of vague notions as ‘a good amount’, ‘generally’, ‘rarely’, ‘often’, etc. Here, we show the basic system introduced in [10] is a particular case of ours.
We adopt a notation for the vague operator different from the one in [10]. The vague similarity type has two modal operators  and  , both having rank 1. So, it is the modal similarity type ({ , }, {( , 1), ( , 1)}) and the vague formulas are
defined by the following grammar:
α ::= p | чα | α1 V α2 |  α |  α
The vague models are the structures M = (W, R, K, V ), where W /= ∅, R ⊆
W × W is a binary relation, K is a function mapping each w ∈ W to a family
K(w) ⊆ 2R(w), where R(w) = {w' ∈ W : wRw'}, and V  : Pvar → 2W  is an
assignment. The meaning of a vague formula α in a vague model M is defined by
the usual conditions for the atomic and the Booleans, together with the following clauses:
[[ α]]M ::= {w ∈ W : R(w) ⊆ [[α]]M},

[[ α]]M ::= {w ∈ W : R(w) ∩ [[α]]M ∈ K(w)}.
In a more usual notation:
w H  α iff 6w' ∈ W, if wRw' then w' H α,
w H  α iff {w' ∈ W : wRw' and w' H α}∈ K(w).
Let us take a similarity type having two unary operators q1 and q2. The translation from vague formulas α to neighbourhood formulas αn just replaces, re- spectively, all occurrences of  by q1 and of  by q2, in each place where they occur inside α.
Given a vague model M = (W, R, K, V ), we define the corresponding neighbour- hood model Mn = (W, Nq , Nq ,V ) by setting Nq (w) = {X ⊆ W : R(w) ⊆ X},
1	2	1
and Nq2 (w) = {X ⊆ W : R(w) ∩ X ∈ K(w)}.
Proposition 4.3 Let α be a vague formula and M be a vague model. Then
[[α]]M = [[αn]]Mn .
Proof. The proof is straightforward from the definitions, by induction on α.	 
Reciprocally, the translation from formulas ϕ to vague formulas ϕv just replaces, respectively, all occurrences of q1 by and of q2 by , in each place where they occur inside ϕ.
We say that a frame F = (W, Nq1 , Nq2 ) is a v-frame when the mapping Nq1 satisfies properties (B1) and (B2) from Section 4.1, both properly rewritten for q1, as well as the following property of mappings Nq1 and Nq2 , for all w ∈ W and
X, Y ∈ 2W :
(V ) if  N1(w) ∩ X =  N1(w) ∩ Y and X ∈ N2(w), then Y ∈ N2(w).
We say that a model is a v-model when it is based on a v-frame. Note that, given a vague model M, the corresponding neighbourhood model Mn is a v-model. Given a v-model M = (W, Nq1 , Nq2 ,V ), we define the corresponding vague model Mv = (W, R, K, V ) by setting


and

for every w ∈ W .
R(w) = ∩Nq1 (w)

K(w) = {R(w) ∩ X : X ∈ Nq2 (w)},

The following lemma shows that this definition is sound, i.e., the corresponding model Mv of a v-model is indeed a vague model.
Lemma 4.4 Let M = (W, Nq , Nq ,V ) be a v-model. Then mapping K of Mv =

(W, R, K, V ) is such that

for every w ∈ W.
1	2

K(w) ⊆ 2R(w),

Proof. Straightforward from the definitions.	 

Proposition 4.5 Let ϕ be a formula and M be a v-model. Then
[[ϕ]]M = [[ϕv]]Mv .
Proof. By induction on ϕ. The proofs for the atomic and the Boolean cases are straightforward. The proof for the q1 case is analogous to the proof of Proposi- tion 4.2. The q2 case is proved as follows.
w ∈ [[q2ϕ]]M iff [ϕ]]M ∈ Nq2 (w)
iff  [ϕb]]Mb ∈ Nq (w)	(by IH)
iff EX ∈ Nq (w) : R(w) ∩ X = R(w) ∩ [[ϕb]]Mb
iff R(w) ∩ [[ϕb]]Mb ∈ K(w)	(by (V)) iff w ∈ [[ ϕb]]Mb
iff w ∈ [[(q2ϕ)b]]Mb .
This completes the proof.	 

Graded modalities
Graded modalities were introduced in [8] and further developed in [5,9,6,7]. It is an extension of the basic modal logic to a multimodal language with modal operators ‘there are more than n accessible states that...’. Here, we show how the system presented in [8] is a particular cases of ours.
The graded similarity type has an infinite enumerable amount of unary modal operators  n, n ∈ ω. So, it is the modal similarity type ({ n : n ∈ ω}, {( n, 1) : n ∈ ω}) and the graded formulas are defined by the following grammar:
α ::= p | чα | α1 V α2 |  nα	(n ∈ ω)
The graded models are the structures M = (W, R, V ), where W /= ∅, R ⊆ W ×W is a reflexive binary relation, and V : Pvar → 2W is an assignment. The meaning of a graded formula α in a graded model M is defined by the usual conditions for the Booleans, together with the following clause, for each n ∈ ω:
[[ nα]]M ::= {w ∈ W : #(R(w) ∩ [[α]]M) > n},
where R(w) = {w' ∈ W : wRw'} and #X is the cardinality of the set X. In a more usual notation:
w H  nα iff #{w' ∈ W : wRw' and w' H α} > n.
Let us take a similarity type having an enumerable set {qn : n ∈ ω} of unary operators. The translation from graded formulas α to neighbourhood formulas αn just replaces all occurrences of  i by qi, in each place where  i occurs inside α, for every i ∈ ω.
Given a graded model M = (W, R, V ), we define the corresponding neighbour-
hood model Mn = (W, {Nq : i ∈ ω},V ) by setting, for each qi,
Nqi (w) = {X ⊆ W : #(R(w) ∩ X) > i},

for every w ∈ W .
Proposition 4.6 Let α be a graded formula and M be a graded model. Then
[[α]]M = [[αn]]Mn .
Proof. The proof is straightforward from the definitions, by induction on α.	 
Reciprocally, the translation from formulas ϕ to graded formulas ϕg just replaces all occurrences of qn by  n, in each place where qn occurs inside ϕ, for every n ∈ ω. We say that a frame F = (W, {Nqn : n ∈ ω}) is a g-frame when mapping Nq0 satisfies properties (B1) and (B2), from Section 4.1, both properly rewritten for q0, as well as the following properties of the mapping Nqn , for all n ∈ ω, w ∈ W ,
and X ∈ 2W :
(G1) if X ∈ Nq0 (w), then w ∈ X,
(G2) X ∈ Nqn (w) iff #((∩Nq0 (w)) ∩ X) > n.
We say that a model is a g-model when it is based on a g-frame. Note that, given a graded model M, the corresponding neighbourhood model Mn is a g-model. Now, for each g-model M = (W, {Nqn : n ∈ ω},V ), we define the corresponding graded model Mg = (W, R, V ) by setting
R(w) = ∩Nq0 (w),
for every w ∈ W .
The following lemma shows that this definition is sound, i.e., the corresponding model Mg of a g-model is indeed a graded model.
Lemma 4.7 Let M = (W, {Nqn : n ∈ ω},V ) be a g-model. Then the relation R of
Mg = (W, R, V ) is reflexive.
Proof. Let w ∈ W . By (B1), we have ∩Nq0 (w) ∈ Nq0 (w). By (G1), we have
w ∈ ∩Nq0 (w). I.e., w ∈ R(w) and, hence, wRw.	 
Proposition 4.8 Let ϕ be a formula and M be g-model. Then
[[ϕ]]M = [[ϕg]]Mg .
Proof. By induction on ϕ.  The proof of the atomic and the Boolean cases is straightforward. The modal case is proved as follows.
w ∈ [[ qn ϕ]]M iff [ϕ]]M ∈ Nqn (w)
iff #(R(w) ∩ [[ϕ]]M) > n (by (G2))
iff #(R(w) ∩ [[ϕg]]Mg ) > n (by IH) iff w ∈ [[( nϕg)]]Mg
iff w ∈ [[(qnϕ)g ]]Mg .
This completes the proof.	 

Default modal logic
Default modal logic was introduced in [1]. It is a logic endowed with a binary operator that has the intended meaning of ‘if α, then normally β’. Here, we show how this system is a particular case of ours.
The default similarity type has just one modal operator →   of rank 2. So, it is
the modal similarity type ({ →  }, {( →  , 2)}) and the default formulas are defined by the following grammar:
α ::= p | чα | α V α  | α  →  α
The default models, originally called ﬁlter-based models, are the structures M = (W, N, V ), where W /= ∅, N : W × 2W → 22W is a mapping satisfying X ∈ N (w, X) and N (w, X) is a filter over W , for every w ∈ W and X ⊆ W , and V : Pvar → 2W is an assignment. Recall that a family F of subsets of W is a ﬁlter when the following conditions are satisfied, for every X, Y ∈ 2W :
W ∈ F.
If X, Y ∈ F, then X ∩ Y ∈ F.
If X ∈F and X ⊆ Y , then Y ∈ F.
The meaning of a default formula α in a default model M is defined by the usual conditions for the atomic and the Booleans, together with the following clause:

[[α → 
In a more usual notation:
β]]M
::= {w ∈ W : [[β]]M
∈ N (w, [[α]]
M)}.

w H α → 
β iff [β]]M
∈ N (w, [[α]]
M).

Let us take a similarity type having just one binary operator q. The trans- lation from default formulas α to polymodal neighbourhood formulas αn is defined recursively by:
pn ::= p
(чα)n ::= чαn
(α V β)n ::= αn V βn

(α → 
β)n ::= q(αn, βn)

Given a default model M = (W, N, V ), for every w ∈ W and X ∈ 2W , we assume N (w, X) is the family {Xi : i ∈ I} indexed by a set I which depends on w and X. Using this notation, we define the corresponding polymodal neighbourhood model Mn = (W, Nq,V ) by setting
Nq(w) = {(X, Xi) : i ∈ I}.
Hence, (X, Y ) ∈ Nq(w) iff Y ∈ N (w, X), for all w ∈ W and X, Y ⊆ W .
Proposition 4.9 Let α be a default formula and M be a default model. Then
[[α]]M = [[αn]]Mn .
Proof. The proof is straightforward from the definitions, by induction on α.	 

Reciprocally, the translation from formulas ϕ to default formulas ϕd is defined recursively by:
pd ::= p
(чϕ)d ::= чϕd
(ϕ V ψ)d ::= ϕd V ψd
q(ϕ, ψ)d ::= ϕd →  ψd
We say that a frame F = (W, Nq) is a d-frame when the mapping Nq satisfies the following properties, for all w ∈ W and X, Y, Z ∈ 2W :
(D1')  (X, X) ∈ Nq(w),
(D2')  if (X, Y ), (X, Z) ∈ Nq(w), then (X, Y ∩ Z) ∈ Nq(w),
(D3')  if (X, Y ) ∈ Nq(w) and Y ⊆ Z, then (X, Z) ∈ Nq(w).
We say that a model is a d-model when it is based on a d-frame. Note that, given a default model M, the corresponding neighbourhood model Mn is a d-model. Now, for each d-model M = (W, Nq,V ), we define the corresponding default model Md = (W, N, V ) by setting
Y ∈ N (w, X) iff (X, Y ) ∈ Nq(w),
for every w ∈ W and X, Y ⊆ W .
The following lemma shows that this definition is sound, i.e., the corresponding model Md of a d-model is indeed a default model.

Lemma 4.10 Let M = (W, Nq,V ) be a d-model. Then the following properties hold for Md = (W, N, V ):
X ∈ N (x, X).
N (w, X) is a ﬁlter over W.
Proof. (i) By (D1), we have (X, X) ∈ Nq(w). Hence, X ∈ N (w, X).
(ii) Let w ∈ W and X ∈ 2W . We shall show that N (w, X) is a filter over W . First, by (D1), we have (X, X) ∈ Nq(w).  Since X ⊆ W , by (D3), we have (X, W ) ∈ Nq(w). So, W ∈ N (w, X). Second, suppose Y, Z ∈ N (w, X). hence,
(X, Y ), (X, Z) ∈ Nq(w). So, by (D2), we have (X, Y ∩ Z) ∈ Nq(w) and Y ∩ Z ∈
N (w, X). Finally, let Y ∈ N (w, X) and Y ⊆ Z. So, (X, Y ) ∈ Nq(w) and, by (D3), we have (X, Z) ∈ Nq(w). This last condition gives us Z ∈ N (w, X), as required. 
Proposition 4.11 Let ϕ be a formula and M be a d-model. Then
[[ϕ]]M = [[ϕd]]Md .

Proof. The proof is straightforward from the definitions, by induction on ϕ. 

Perspectives
In this paper, we started the study of polymodal neighbourhood languages. We provided a completeness result for the basic polymodal neighbourhood system and showed how some important systems based on neighbourhood like semantics can be simulated as special cases of our system. A lot of work remains to be done.
Since our system was built as a direct generalization of the usual polymodal lan- guages, we intend to investigate the extensions of the classical results established for modal logic to these formalisms. More specifically, we intend to adapt the notion of bisimulation, van Benthem’s characterization theorem, Goldblat-Thomason’s de- finability theorem, Sahlqvist completeness theorem, and Sahlqvist correspondence theorem for the basic polymodal neighbourhood system and investigate how far these results continue to be valid for the many interesting polymodal systems, ob- tained from the basic one by the addition of adequate sets of axioms. This is the most immediate task to be done. We believe that, after a little thought on perspec- tives, the reader will come up with a lot of many interesting questions.
Acknowledgement
Thanks are due to Systems and Computer Engineering Program of COPPE/UFRJ, which facilities made this research possible.

References
Ben-David, S., and R. Ben-Eliyahu-Zohary, A modal logic for subjective default reasoning, Artificial Intelligence 116 (2000) 217–236.
Benevides, M.R.F., C.A.D. Delgado, R.P. de Freitas, P.A.S. Veloso, and S.R.M. Veloso, On modalities for vague notions, Lecture Notes in Artificial Intelligence 3171 (2004), Springer, Berlin, 1–10.
Blackburn, P., M. de Rijke, and Y. Venema, “Modal Logic”, Cambridge University Press, Cambridge, 2001.
Chellas, B.F., “Modal Logic: an introduction”, Cambridge Univ. Press, New York, 1980.
Caro, F. De, Graded modalities II (canonical models), Studia Logica 47 (1988) 1–10.
Cerrato, C., Canonical models for graded normal logics (Graded modalities IV), Studia Logica 49
(1990) 241–252.
Cerrato, C., Decidability by filtrations for graded normal logics (Graded modalities V), Studia Logica
53 (1994) 61–74.
Fattorosi-Barnaba, M. and F. De Caro, Graded modalities, Studia Logica 44 (1985) 197–221.
Fattorosi-Barnaba, M. and C. Cerrato, Graded modalities III, Studia Logica 47 (1988) 99–110.
Veloso, P.A.S., S.R.M. Veloso, P. Viana, R. de Freitas, M. Benevides, and C. Delgado, On vague notions and modalities: a modular approach, submitted.
