

Electronic Notes in Theoretical Computer Science 267 (2010) 55–68
www.elsevier.com/locate/entcs

SMT-AI: an Abstract Interpreter as Oracle for k-induction
Pierre Roux, R´emi Delmas and Pierre-Lo¨ıc Garoche 1
ONERA – DTIM
Toulouse, France


Abstract
The last decade has seen a major development of verification techniques based on SMT solvers used to prove inductive invariants on systems. This approach allows to prove functional properties and scale up to handle industrial problems. However, it often needs a man in the loop to provide hand-written lemmas on the system in order to help the analysis and complete the proof.
This paper presents a tool that automatically generates lemmas. It takes such systems and over- approximates their collecting semantics, providing a bound on the numerical memories. It is based on the abstract interpretation methodology introduced by Cousot in 1977.
Keywords: k-induction, abstract interpretation, lemmas generator, SMT


Context and Motivation
Critical systems have to meet stringent certification requirements such as the D0- 178 for avionics [15]. Among those systems, control command software is often written in the well suited synchronous paradigm [2,11], hence a strong interest in proving functional properties on synchronous systems.
The next section will introduce and motivate a combination of analysis methods while the remaining of the article focus on the implementation of one of them. Section 3 describes the input language of our tools. Then the two following sections deal with the analysis it performs. Finally, section 6 gives some details about the implementation, section 7 details an example and section 8 concludes and gives an overview of what remains to be done.

1 Email: firstname.lastname@onera.fr

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.09.018




Figure 1. General combination of analyzes, a heuristic analysis of k-induction counter- examples could allow to finely tune cost/precision ration of abstract interpretation analysis.
A combination of analysis
k-induction
The k-induction method [16] is a SMT/SAT-based model checking technique aiming at proving properties by induction on the analyzed system.
If I and T are predicates for initial state and transition relation of a synchronous system and P a property to prove on it, k-induction uses formulas:
Base(k) := I(s0) ∧ T (s0, s1) ∧· · · ∧ T (sk−1, sk) ∧ ¬P (sk)
Step(k) := (P (s0) ∧· · · ∧ P (sk)) ∧ (T (s0, s1) ∧· · · ∧ T (sk, sk+1)) ∧ ¬P (sk+1)
Starting from 0, Base(k) and Step(k) are fed to solver for increasing values of k until either Base(k) is satisfiable meaning property P does not hold on the system or Base(k) and Step(k) are both unsatisfiable achieving a proof of P by induction. Using SMT solvers allows to handle infinite state systems. It is also interesting to notice that in case of failure, models of satisfiable formulas give counter examples. This technique proved effective [10] but often requires the user to strengthen the property P with additional lemmas in order to make it inductive for a reasonable
value of k.
Abstract interpretation
Abstract interpretation [6] is a theoretical framework to build static analyzers com- puting sound approximations of the semantics of analyzed programs. Tools based on it achieve a very high level of automation [7].
Combination of k-induction and abstract interpretation
Our goal is to use an abstract interpreter to automatically infer invariants of the system which can be used, as lemmas coming from an external oracle, by a k- induction tool. We hope to take this way advantage of both power of SMT-solvers for deductive reasoning and efficiency of abstract interpretation to infer numerical invariants. General combination is sketched in Figure 1. although this paper will only deal with the abstract interpreter.

Related work
Other works use spurious counter examples [8] or instantiation of parametrizable patterns [4] to strengthen the invariant in order to make it inductive hence prov- able by k-induction. Those methods are mostly symbolic whereas a more semantic method such as abstract interpretation could infer more easily properties not ap- pearing in the original program.

Input language
Target: Lustre synchronous language
To analyze Lustre programs [11], the k-induction engine has to compile them to SMT-lib [1] language, used by SMT solvers, during a phase very similar to code generation. Therefore, we chose to use this SMT-lib code, enriched with a few predicates to describe temporal aspects, as input language of our abstract inter- preter.

Syntax
Synchronous systems analyzed by our tool are expressed in SMT-lib [1] extended with following predicates:
init is true at initial step then always false, this would be written true -> false
in Lustre [11];
memu(v, e) means that variable v acts as a memory which takes an undefined value at first step then takes value of expression e during previous step, this is equivalent to v = pre e in Lustre;
memi(v, e1, e2) is the same as memu(v, e2) excepts that value of v at first step is defined by expression e1, this amounts to v = e1 -> pre e2.
Our input syntax is then described by the following grammar:
e   ::= v | init | const | (unop e) | (binop e e) | (nop el)
| (ite e e e) | (let (v e) e) | (memu v e) | (memi v e e) el	::= e e | e el
v   ::= V
const ::= B | Z
unop ::= − | not
binop ::= < | > | ≤ | ≥ | − | + | ∗ | implies
nop  ::= = | iff | and | or | xor | distinct
with V a set of variable names, B = {true, false} the set of booleans and Z the set of integers. B ∪ Z will be denoted Val.
Two types Bool and Int along with usual typing rules are used to ensure that only well typed expressions are considered. Moreover nested memi/memu are forbid- den.

General shape
Analyzed code coming from compilation of Lustre code takes the shape of nested let definitions for all intermediate variables sorted by topological order. Moreover the compilation ending with a common subexpression elimination phase, the result looks a bit like three address code.

Semantic
A denotational semantic is given in section 4.2.1.
It is important to notice here that we consider an idealized semantic with arith- metic on unbounded ring Z. For proven properties to remain valid at executable code level, it will be necessary to prove that no overflow can happen in compiled program. Real numbers are not considered here but if they were it would also be necessary to prove that the floating point implementation has an error in some small enough bound from model in R. Efficient tools already exist to prove those properties [7,9].

Abstract Interpretation
Synchronous Systems Main Loop
Abstract semantic is computed through usual least fixpoint increasing iterations with a delayed widening with thresholds followed by decreasing steps with narrow- ing, memi and memu predicates acting as assignments for variables used as memory of the synchronous system. Most of the work consists in analyzing the expression defining the values of those variables from the values at previous step. The re- maining of this section will focus on this second separate analysis, conducted by decreasing iterations toward a greatest fixpoint.

Analysis of Expressions
Since our goal is to compute by abstract interpretation an over-approximation, the not operator will require to also compute an under-approximation. To get rid of this, we can put expressions in negative normal form.Therefore we will only encounter not in front of variables from now on. We will also forget unary −, implies, iff, xor and distinct in the following, without restriction since they can be seen as syntactic sugar. Finally =, and and or will be treated as binary operators.
Concrete Semantic
We define here a semantic suitable for abstract interpretation.
For all expression e, Je) is a function from V → Val to Val defined by:
v (ρ)= ρ(v)	not v (ρ)= ¬ ρ(v)	c (ρ)= c  for c ∈ Val
binop e1 e2 (ρ)= e1 (ρ) binop e2 (ρ)
for binop ∈ {and, or, =, <, >, ≤, ≥, −, +, ∗}


Jite eb et
e )(ρ)= ⎧⎨ Jet)(ρ)	if Jeb)(ρ)= true

Jee)(ρ)	if Jeb)(ρ)= false
Jlet (v e1) e2)(ρ)= Je2)(ρ[v '→ Je1)(ρ)])
For all expression e of type Bool, Je)P is a function from 2(V→Val) to itself defined

by:
Je)P R = {ρ ∈ R | Je)(ρ)= true}

We can then define our second semantics of an expression e as the greatest fixpoint of Je)P :
Je)2 = gfpJe)P
This is well defined accor ding to Knaster-Tarski theore m [17] since Je)P is monotonic
The greatest fixpoint seems a bit artificial here but is convenient to define our analysis and prove its soundness.


A Combined Forward-Backward Abstract Semantic We present here a non relational analysis 2 . For this purpose, we assume an abstract domain Int for integers Z (for example intervals) and an abstract domain Bool based on lattice of figure 2 for booleans. Disjoint sum Bool  Int will be written Val and Env denotes en- vironments of such abstract values: Env = V → Val .
In case one variable is ⊥Val] , the whole environment is written ⊥Env] meaning that not any valid environment exists.


TBool]
	
true	false 
	
⊥Bool]
Figure 2: Lattice un- derlying boolean ab- stract domain Bool .


Basic Abstract Transformers
Abstract domain Val comes with following abstract transformers. They are the abstract counterparts of concrete operations in the analyzed language:
const : Val → Val , const (c) is an abstract value representing concrete value
c ∈ Val;
 
Jnot)↑ unop : Val → Val , forward abstract semantic of not: for any boolean b, if
abstract value b represents b, then Jnot)↑ unop(b ) represents ¬b;

 
Jnot)↓ unop : Val × Val → Val , backward abstract semantic of not: for b
and

r , not ↓ unop(b , r ) is a refinement of b (element lower in the lattice) knowing that for any boolean b represented by b , ¬b is represented by r ;
similar forward and backward transformers for binary operators and ite.

2 Our tool also offers relational analysis though. This is implemented thanks to the APRON [3] library, which offers relational abstract domains such as the octagons [12].

Forward Abstract Semantic
For all expression e, e ↑ is a function from Env to Val . e ↑ (ρ ) is a classical abstract evaluation of expression e in abstract environment ρ :
Jv)↑ (ρ )= ρ (v)	Jnot v)↑ (ρ )= Jnot)↑ unop(ρ (v))
Jc)↑ (ρ )= const (c) for c ∈ Val
binop e1 e2 ↑ (ρ )= binop ↑ binop( e1 ↑ (ρ ), e2 ↑ (ρ )) for binop ∈ {and, or, =, <, >, ≤, ≥, −, +, ∗}
Jite eb et ee)↑ (ρ )= Jite)↑ ite(Jeb)↑ (ρ ), Jet)↑ (ρt), Jee)↑ (ρe)) where ρ = Jeb)↓ (true , ρ ) and ρ = Jeb)↓ (false , ρ )
Jlet (v e1) e2)↑ (ρ )= Je2)↑ (ρ [v '→ Je1)↑ (ρ )])
Most cases are just usual evaluation of the expression. For ite, backward se- mantic is used to refine the environment knowing that the guard evaluates to true in the then branch and to false in the else branch.

Backward Abstract Semantic
For all expression e, e ↓ is a function from Val × Env to Env . e ↓ (n , ρ ) is a refinement of abstract environment ρ knowing that e evaluates in something over-approximated by n :
Jv)↓ (n ,ρ )= ρ [v '→ ρ (v) HVal] n ]
Jnot v)↓ (n ,ρ )= ρ [v '→ Jnot)↓ unop(ρ (v),n )]
Information about variable v is added to what is already in environment.

⎧⎨ ⊥

Env
]	if const (c) H 
Val
n = ⊥

Val]

Jc)↓ (n ,ρ )= 

We can’t refine environment except if c is incompatible with value n .
binop e1 e2 ↓ (n ,ρ )= e1 ↓ (n1,ρ ) HEnv] e2 ↓ (n2,ρ ) for binop ∈ {=, <, >, ≤, ≥, −, +, ∗}
where (n , n )= Jbinop)↓	(Je1)↑ (ρ ), Je2)↑ (ρ ), n )
We evaluate e1 and e2 forward before refining this values, since binop e1 e2 evaluates in n , giving n and n from which e1 and e2 are backward evaluated.

1	2
⎧⎪ ⊥

Env
]  if (Jand)↑ 
(Je1)↑ (ρ ), Je2)↑ (ρ ))) H 
n = ⊥

Val]

⎪⎪⎨ Je1)↓ (true , ρ ) H 
Je2)↓ (true , ρ )	if n = true

Jand e1 e2)↓ (n ,ρ )=			 
⎪⎩ ρ	otherwise
 
Env]
Je2)↓ (false , ρ )	if n = false

When the result n is false , one of the subexpressions e1 or e2 can force the value of the conjunction. We can thus only compute a join of backward evaluations to false of subexpressions. Disjunction is similar, replacing join with meet and vice versa.

Jite eb et ee)↓ (n , ρ )= Jeb)↓ (n , ρ ) H	 Jet)↓ (n , ρ ) H 
Jee)↓ (n , ρ ) 

where ρ = Jeb)↓ (true , ρ ) and ρ = Jeb)↓ (false , ρ )

t
and (n , n , n )= Jite)↓ 
e
(Jeb)↑ (ρ ), Jet)↑ (ρ ), Jee)↑ (ρ ), n )

Backward ite can return true for n for example if n and n are incompatible.
b	e
Jlet (v e1) e2)↓ (n ,ρ )= Je1)↓ (ρ1(v), ρ1[v '→ ρ (v)]) where ρ = Je2)↓ (n , ρ [v '→ Je1)↑ (ρ )])
Reassignment of value ρ (v) to variable v is here only to avoid captures when same variable name v is used multiple times. When implementing, a simpler solution can be to guarantee uniqueness of all variable names
The abstract semantics is finally computed through decreasing iterations:

Je) = .	 λX.Je)↓ (true ,X) n T


Env]

n Env]
Such backward semantics is commonly applied on guards of if ... then ... else or while loop constructs of imperative languages like C. Iterating can be needed in our case to gain precision, when some information learn in one part of an expression enables to get more precise results in another part.
Example 4.1 On the following expression, a first iteration ensures that b1 is true which allows a second iteration to discover that b2 must also be true and x must be negative which finally appears impossible during a third iteration:
(and (ite b1 (and b2 (< x 0)) true)
(<= (ite b1 (ite b2 (-x) x) 1) 0))

Partial correctness
Concrete and abstract values are linked together by a concretization function γ : Val → 2Val. For any abstract value n , γ(n ) is the set of (concrete) values repre- sented by n . There is a similar concretization function γEnv : Env → 2V→Val for environments: γEnv = ρ '→ ρ ∀v ∈ V.ρ(v) ∈ γ(ρ (v)) .
Assuming that basic abstract transformers fulfill usual soundness hypotheses, following theorem can be proved.

Theorem 4.2 For all expression e, Je)2
⊆ γEnv Je) .


This shows that the computed abstract semantic e  is a sound over-approximation of the concrete semantic 3 .

3 In particular if the abstract semantics computed is ⊥Env] , it proves that the formula is unsatisfiable. This did happen when running the tool on SMT-lib benchmarks but this is not our goal and an SMT-solver can do it much more efficiently. Moreover it cannot happen on formula describing deterministic synchronous systems.

Termination Issue
For the computatio n of the abstract sem a ntics Je)  to terminate, we need the de-

could not be the case if the lattice underlying the abstract domain Val  does not
meet the condition of absence of infinite decreasing chains (DCC). This property does not hold for the commonly used interval lattice for example which accepts the
infinite decreasing chain ([n, +∞))n∈N. This lead the analysis of expressions such as (and (> x 0) (> x y) (> y x)) not to terminate with this abstract domain.
We can not make use of a widening operator (or more precisely its dual) to accel- erate convergence since this would lead to an under-approximation of the greatest fixpoint whereas we want to compute an over-approximation of it. Only solution to enforce convergence in reasonable time is to make use of a narrowing operator which basically amounts to bound the number of iterations. This would lead to far too much coarse results if iterations were commonly stopped by narrowing. However convergence seems to be reached after only a few iterations on the formula fed to our tool (c.f. section 3.3).

Precision Issue
There are a few well located points were loss of precision usually happens: when computing join operators H under or and ite constructs and when removing of environments local variables bounded by let constructs. This can lead to forget information which can be useful at next iteration to improve precision of the result.
There are two ways to address the problem:
computing local fixpoints before any operation which could lead to a loss of information or
caching potentially lost information to reuse it a next iteration.
The first solution present the major drawback of an exponential complexity in the number of nested points where such local fixpoints are computed.
Therefore we chose to adopt the second solution for let constructs which are usually deeply nested.

Efficiency Issue
Looking at the abstract semantic, it appears that during each iteration, forward semantics of leafs of syntax tree of an expression will be recomputed again and again when computing forward semantics of each node above. Use of common dynamic programming techniques addresses this problem.
Abstract meet of two backward semantics Je1)↓  n , ρ  H	Je2)↓  n , ρ 
can also be replaced by the computation of one of them from the result of the other
Je2)↓  n , Je1)↓  n , ρ	. Doing this for the and allows to save an iteration on

Inlining and Partitioning
The analyzed code having lot of expressions defined under let constructs (c.f. sec- tion 3.3), they tend to be analyzed in a less precise environment than the one they are actually used in (e.g. in a branch of an if).
A first easy solution is to inline all let definitions. But this can, among other things, lead to coarser results by loosing correlation between multiple instances as shown in following example.
Example 5.1 The following expression:
(let (b (< x y)) (and b (not b)))
gives after inlining: (and (< x y) (<= y x)) which does not allow to conclude to unsatisfiability without using a relational domain with x and y whereas it was obvious before inlining.
A better solution is to use a symbolic abstract domain [13] keeping trace of the expression attached by a let to a variable to be able to analyze it when this variable is then encountered during the analysis.
However keeping lot of local variables in abstract environment makes compu- tation of abstract meet H and join H operators slower hence some interest for inlining. We have in particular no reason not to inline variables used only once (which is common in the expressions we analyze).
Sometime, all this is not sufficient to have some code analyzed in a precise enough context.
Example 5.2 If x ≤ N, The following expression evaluates to something not greater than N:
(+ x (ite (< x N) 1 0))
but we need to analyze the whole sum and not only the branches of the ite in both contexts x < N and x ≥ N to discover it.

A good way to do it is to use trace partitioning [14], keeping two set of traces for the ite and merging them after the sum.
Example 5.3 This technique allows to infer non trivial invariants such as check ≥
0 on the following program:
(let (check (ite b (-x) 1))
(let (neg_abs_x (ite (< x 0) x (-x))) (and (memi b true (= check 1))
(memi x (-2) (ite (not b) neg_abs_x
(ite input_0 (+ (+ x check) (-2)) (- check x)))))))
by partitioning against the value of b at current and previous step.

Implementation
We implemented the previously described analysis in a prototype. The OCaml code is available under GPL license at http://cavale.gforge.enseeiht.fr/smt-ai/.
Input language is, as described in section 3.2, raw SMT-lib [1] plus a few extra predicates:
init, memu and memi to enable description of synchronous systems (c.f. sec- tion 3.2);
trace partitioning and trace merge semantically equivalent to identities and used as pragmas for trace partitioning (c.f. section 5, a partitioning id enables not well-parenthesized partitioning).
The analysis proceeds in three consecutive phases:
parsing and type checking the input, consistency of partitioning ids is also checked;
inlining (c.f. section 5), normalization (negation normal form) and extraction of two formulas respectively describing initial state and transition relation of the system;
the analysis itself (c.f. section 4).
The tool outputs the result of the analysis, in particular bounds for values of the variables in reachable states.

Example
In the following Lustre code, k-induction cannot prove that variable OK is always true 4 . Our abstract interpreter is also unable to complete the proof but infers the invariant x + y = 42 along with bounds for numerical variables, which allows k-induction to conclude at depth k = 0, using bitblasting to handle the non linear operation.
node example(a : bool) returns (OK : bool);
var pre x : int; pre y : int; x : int; y : int; z : int; n : int;
let
n = 42;
pre x = fby(0, 1, x); pre y = fby(0, 1, y);
x = 0 → if pre x < 2 ∗ n then pre x + 1 else pre x; y = 2 ∗ n → if pre y > 0 then pre y − 1 else pre y; z = x ∗ y;
OK = z ≤ n ∗ n;
tel

4 Although bounds on variables x and y, even very coarse, and a so called path compression constraint seem to allow a proof at a depth k related to the parameter n.

Conclusion and Future Work
We have presented an implementation of an abstract interpreter intended to work in collaboration with a k-induction procedure to prove functional properties on synchronous systems.
The analysis presented here, even used with simple abstractions such as intervals, already gives interesting results. Computing non relational properties like bounds on variables allows to optimize the analysis for the SMT solver, for example relying on bit-blasting techniques [5]. On some simple systems with integer counters, for instance, the k-induction analysis could necessitate to increase the induction depth up to unreasonable values, while our abstract interpretation tool using widening with thresholds will infer bounds in a few steps of computation.
This is still work in progress and a lot remains to do. The abstract interpreter being intended to be called many times with various parameters such as trace parti- tioning points and packing for relational domains, it could be interesting to be able to reuse previously computed results to speed up subsequent analysis. Finally, we have to test our approach on industrial case studies.

References
C. Barrett, A. Stump, and C. Tinelli.  The Satisfiability Modulo Theories Library (SMT-LIB).
www.SMT-LIB.org, 2010.
A. Benveniste, P. Caspi, S. Edwards, N. Halbwachs, P. Le Guernic, and R. De Simone. The synchronous languages 12 years later. In Proceedings of The IEEE, pages 64–83, 2003.
J. Bertrand and A. Min´e. Apron: A library of numerical abstract domains for static analysis. In
A. Bouajjani and O. Maler, editors, CAV, volume 5643 of Lecture Notes in Computer Science, pages 661–667. Springer, 2009.
A. Bradley and Z. Manna. Property-directed incremental invariant generation. Formal Asp. Comput., 20(4-5):379–405, 2008.
R. Bryant, D. Kroening, J. Ouaknine, S. Seshia, O. Strichman, and B. Brady. Deciding bit-vector arithmetic with abstraction. Software Tools for Technology Transfer (STTT), 11:95–104, 2009.
P. Cousot and R. Cousot. Abstract interpretation frameworks. Journal of Logic and Computation, 2(4):511–547, 1992.
P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min´e, D. Monniaux, and X. Rival. The astre´e analyzer. In S. Sagiv, editor, ESOP, volume 3444 of Lecture Notes in Computer Science, pages 21–30. Springer, 2005.
L. de Moura, H. Rueß, and M. Sorea. Bounded model checking and induction: From refutation to verification (extended abstract, category a). In W. Hunt Jr. and F. Somenzi, editors, CAV, volume 2725 of Lecture Notes in Computer Science, pages 14–26. Springer, 2003.
E. Goubault, S. Putot, P. Baufreton, and J. Gassino. Static analysis of the accuracy in control systems: Principles and experiments. In FMICS, volume 4916 of Lecture Notes in Computer Science, pages 3–20. Springer, 2007.
G. Hagen and C. Tinelli. Scaling up the formal verification of Lustre programs with SMT-based techniques. In A. Cimatti and R. Jones, editors, Proceedings of the 8th International Conference on Formal Methods in Computer-Aided Design (Portland, Oregon), pages 109–117. IEEE, 2008.
N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. The synchronous dataflow programming language lustre. Proceedings of the IEEE, 79(9):1305–1320, September 1991.
A. Min´e. The octagon abstract domain. In AST 2001 in WCRE 2001, IEEE, pages 310–319. IEEE CS Press, October 2001.


A. Min´e. Symbolic methods to enhance the precision of numerical abstract domains. In E. Emerson and K. Namjoshi, editors, VMCAI, volume 3855 of Lecture Notes in Computer Science, pages 348–363. Springer, 2006.
X. Rival and L. Mauborgne. The trace partitioning abstract domain. ACM Trans. Program. Lang. Syst., 29(5), 2007.
RTCA. Software Considerations in Airborne systems and Equipment Certification, 1992.
M. Sheeran, S. Singh, and G. St˚almarck. Checking safety properties using induction and a sat-solver. In W. Hunt Jr. and S. Johnson, editors, FMCAD, volume 1954 of Lecture Notes in Computer Science, pages 108–125. Springer, 2000.
A. Tarski. A lattice-theoretical fixpoint theorem and its applications. Pacific Journal of Mathematics, 5(2):285–309, 1955.

Equivalent operational semantic
We already describe semantics of temporal predicates init, memi and memu and we will focus here on the semantics of other constructs.
For an expression e, c ∈ Val and a valuation ρ : V → Val assigning a value to each variable appearing in e, we define ρ ▶ e, c if e evaluates to c in ρ:
ρ ▶ v, c	if ρ(v)= c
ρ ▶ c, cj	if c = cj	where c ∈ Val
ρ ▶ (unop e),c	if ∃ cj. ρ ▶ e, cj ∧ unop cj = c	where unop ∈ {−, not}
ρ ▶ (binop e1 e2),c	if ∃ c1 c2. ρ ▶ e1, c1 ∧ ρ ▶ e2, c2 ∧ c1 binop c2 = c
where binop ∈ {<, >, ≤, ≥, −, +, ∗, implies}
n
ρ ▶ (nop e1 ... en),c	if ∃ c1 ... cn.   ρ ▶ ei, ci ∧ nopn	ci = c
i=1
where nop ∈ {=, iff, and, or, xor, distinct}
ρ ▶ (ite eb et ee),c	if (ρ ▶ eb, true ∧ ρ ▶ et, c) ∨ (ρ ▶ eb, false ∧ ρ ▶ ee, c) ρ ▶ (let (v e1) e2),c	if ∃ cj. ρ ▶ e1, cj ∧ ρ[v '→ cj] ▶ e2,c 
The semantics of an expression e is then the set of valuations ρ such that ρ ▶ e, true:
Je)1 = {ρ : V → Val | ρ ▶ e, true}
This semantic is equivalent to the one given in section 4.2.1.
Theorem A.1 Semantics are equivalent: for all expression e, Je)1 = Je)2.
Lemma A.2 For all ρ : V → Val, for all expression e and c ∈ Val, e (ρ) = c if and only if ρ ▶ e, c.
Proof By structural induction on e.	2
Proof [theorem A.1] For any ρ : V → Val, let us prove that ρ ∈ e1 implies ρ ∈ Je)2. By definition of Je)1, ρ ▶ e, true hence Je)(ρ) = true by lemma A.2. Therefore singleton {ρ} is a fixpoint of Je) and is then included in gfpJe) = Je)2.
Conversely, if ρ ∈ Je)2, Je)(ρ) = true hence ρ ▶ e, true by lemma A.2 which amounts to say that ρ ∈ Je)1.	2

Proof of analysis soundness (Theorem 4.2)
Hypotheses
γ is assumed to satisfy the following properties:
γ(⊥Val] )= ∅ and γ(TVal] )= Val;

γ is monotonic: ∀x, y ∈ Val if x ±
Val
] y then γ(x) ⊆ γ(y);

    
γ(true )= {true} and γ(false )= {false}.
It can be noticed that γEnv inherits from the three first properties according to its definition.
Moreover, the basic abstract transformers are expected to fulfill following sound- ness specifications 5 :
∀c ∈ Val, c ∈ γ const (c) ;
∀x ∈ Val , ∀x ∈ B,x ∈ γ x  ⇒ ¬x ∈ γ Jnot)↑ unop x  ;
∀x , r ∈ Val , ∀x ∈ B,x ∈ γ x  ∧ ¬x ∈ γ r  ⇒ x ∈ γ Jnot)↓ unop x , r  ;
∀x , y ∈ Val , ∀x, y ∈ Val,x ∈ γ x ∧y ∈ γ y  ⇒ x binop y ∈ γ Jbinop)↑ binop x , y  ;
∀x , y , r , xj , yj  ∈ Val , ∀x, y ∈ Val,x ∈ γ x  ∧ y ∈ γ y  ∧ x binop y ∈

γ r  ∧ xj , yj  = Jbinop)↓ 

binop
 x , y , r  ⇒ x ∈ γ xj  ∧ y ∈ γ yj  ;

∀b , x , y ∈ Val , ∀x ∈ Val, true ∈ γ b ∧x ∈ γ x  ⇒ x ∈ γ Jite)↑ ite b , x , y  ;
∀b , x , y ∈ Val , ∀y ∈ Val, false ∈ γ  b ∧y ∈ γ y  ⇒ y ∈ γ Jite)↑ ite b , x , y  ;
∀b , x , y , r , bj , xj ∈ Val , ∀x ∈ Val, true ∈ γ b  ∧ x ∈ γ x  ∧ x ∈ γ r  ∧

 bj , xj ,  = Jite)↓ 


ite
 b , x , y , r  ⇒ true ∈ γ bj  ∧ x ∈ γ xj ;

∀b , x , y , r , bj , yj ∈ Val , ∀y ∈ Val, false ∈ γ b  ∧ y ∈ γ y  ∧ y ∈ γ r  ∧

 bj , , yj  = Jite)↓ 

ite
 b , x , y , r  ⇒ false ∈ γ bj  ∧ y ∈ γ yj  .


Lemma B.1 For all expression e, Je)r ◦ γEnv ⊆˙ γEnv ◦ λX. Je)↓ true ,X  .
Proof This follows from the following property, which can be proved by structural induction on e:

∀e, ∀n ,  λX. ρ ∈ X	Je)(ρ) ∈ γ n , ◦ γEnv ⊆˙
∧ (λX.{Je)(ρ) | ρ ∈ X}) ◦ γEnv ⊆˙
γEnv ◦ λX. Je)↓  n ,X γ ◦ Je)↑ 
2

Lemma B.2 If f ∈ Env → Env is monotonic (i.e. for all x, y ∈ Env, if x ⊆ y
then f (x) ⊆ f (y)) and f : Env → Env is a sound abstraction of f (i.e. f ◦

5 Those assumptions have to be proved against the actual implementation of abstract domain Val] and its abstract transformers.


γEnv ⊆˙

γEnv
f ), then gfpf ⊆ γEnv
. 

n Env]

f n T


Env]
  .

Proof By induction on n we have: 6n ∈ N,fn γ

Env
 TEnv]
  ⊆ γ

Env
 f n T

Env]
  .

f being monotonic on a complete lattice, gfpf exists and gfpf ⊆	fn(TEnv)
n

hence gfpf ⊆	γ
n

Env
 f n(T

Env]
)  by the previous property and knowing that


γEnv

(TEnv]

) = T


Env
. Finally gfpf ⊆ γ


Env
.	f
n Env]

 n(T


Env]

)  since H 

is a

sound abstraction of ∩Env.	2
Proof [Theorem 4.2] For any expression  e, Je)r was proved monotonic in sec-
