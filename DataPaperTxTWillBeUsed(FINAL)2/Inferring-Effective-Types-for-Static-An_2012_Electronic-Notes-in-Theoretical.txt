Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 288 (2012) 37–47
www.elsevier.com/locate/entcs

Inferring Effective Types for Static Analysis of C Programs 1
Bertrand Jeannet2 Pascal Sotin2
INRIA

Abstract
The C language does not have a specific Boolean type: Boolean values are encoded with integers. This is also true for enumerated types, that may be freely and silently cast to and from integers. On the other hand, verification tools aiming at inferring the possible values of variables at each program point may benefit from the information that some (integer) variables are used solely as Boolean or enumerated type variables, or more generally as finite type variables with a small domain. Indeed, specialized and efficient symbolic representations such as BDDs may be used for representing properties on such variables, whereas approximated representations like intervals and octagons are better suited to larger domain integers and floating-points variables.
Driven by this motivation, this paper proposes a static analysis for inferring more precise types for the variables of a C program, corresponding to their effective use. The analysis addresses a subset of the C99 language, including pointers, structures and dynamic allocation.
Keywords: Static Analysis, Type Inference, C Programming Language, Boolean, Finite Types.


Introduction
Verification of C programs.
The initial motivation for this work was to infer invariants on C programs with the tool ConcurInterproc [6]. There are two main issues when one wants to connect an academic analyser to the C language:
The analyser might encounter features of the C language it was not designed to deal with. This leads in the best case to the use of imprecise fall-back treatments and in the worst case to a silently unsound analysis.
The analyser may not recognize in the C presentation features for which it was designed. This leads to a less precise treatment of the program.
This article address a problem belonging to Point (ii).

1 This work was supported by the french ANR project ASOPT.
2 Emails: bertrand.jeannet@inria.fr pascal.sotin@inria.fr


1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.10.006

int b,x;
if (b) x++;
⇒	bool b; int x; if (b) x++;


Fig. 1. Boolean typed int

Boolean values encoded with integers variables.
The verification tool ConcurInterproc distinguishes numerical, Boolean and finitely enumerated variables. We want to cast C programs as input of this analyser and to exploit its type system. Unfortunately, the C type system is too weak. For example, in Fig. 1, both b and x are declared as int but the analyser would gain precision by considering b as a boolean and x as a number (a disjunctive analysis, depending on the truth value of b would then be performed). Moreover, even if b was declared as a Boolean enumerated type {false=0, true=1}, this does not imply that it is not assigned somewhere else the value 2.

Contribution.
We propose a static analysis for C programs which specializes in a sound way the generic integer type of some variables and structure fields into Booleans or inferred enumerated types. This analysis takes into account aliasing properties raised by procedure calls and pointers. This static analysis allows the initial weakly-typed C program to be transformed into a semantically equivalent, strongly typed program, which can be more efficiently analyzed by verification tools such as ConcurInter- proc [6]. After a short presentation of the context and related work (Section 2), we first describe our analysis in a simple context involving only procedures and in- teger variables (Section 3), before extending it to pointers, structures and dynamic allocation (Section 4), and discussing remaining issues in the conclusion.
General Context and Related work
As already mentioned, our motivation is to connect the ConcurInterproc veri- fication tool [6], and its extension to pointers PInterproc [10]. These tools can treat the integer variables of C programs as numerical variables, by representing their possible values using for instance octagons [8], but they can handle more pre- cisely (ie., in a disjunctive way) those integer variables that are actually manipulated as Boolean or enumerated variables, using Bdds.
A simple solution to avoid the confusion between Boolean and numerical vari- ables is to use a strongly-typed form of C (eg. Cyclone [7]) offering types like bool and ensuring that the program respects the declared types, but then this does not address ordinary C programs.
The question of strengthening the typing of a program for analysis purpose has been tackled by [3] in the context of interpreted languages, like Javascript, with both weak and dynamic typing. The authors perform a flow-sensitive static analysis which collects the possible types of a variable at a given point. Similarly, for compilation purpose, many techniques have been proposed to infer the possible classes of objects at invocation sites in order to optimize dynamic call resolution

⟨prog⟩ ::= ⟨decl⟩⟨proc⟩+	list of variable and procedure declarations
⟨proc⟩ ::= ⟨typ⟩ f (⟨decl⟩)“{”⟨decl⟩ ⟨stm⟩s“}” contains declarations and statements
⟨decl⟩ ::= (⟨typ⟩ x)s	declaration of typed variables
⟨typ⟩ ::= int
⟨stm⟩ ::= ⟨lv⟩ = ⟨expr⟩	assignment
|  ⟨lv⟩ = p(⟨expr⟩,..., ⟨expr⟩)	procedure call
|  return x	returnig the value of a variable
⟨lv⟩ ::= x
⟨expr⟩ ::= ⟨cst⟩ | ⟨lv⟩	constant or left-value
|  ⟨boolexpr⟩ | ⟨intexpr⟩
|  ⟨expr⟩“?”⟨expr⟩“:”⟨expr⟩	conditional expression
⟨boolexpr⟩ ::= “!”⟨expr⟩ | ⟨expr⟩⟨bool binop⟩⟨expr⟩
Boolean expressions evaluating to 0 or 1 according to C99 stdandard
⟨intexpr⟩ ::= “−”⟨expr⟩ | ⟨expr⟩⟨int binop⟩⟨expr⟩
“Integer ” expressions potentially evaluating to any value
⟨cst⟩ ::= 0, 1, 2,... 
⟨bool binop⟩ ::= “&&”|“||”|“==”|“! =”|“<”| ... 
⟨int binop⟩ ::= “+”|“−”|“∗”|“/”|“&”|“|”| ... 
Fig. 2. General Syntax

into static calls. Compared to our analysis, these analyses infers sets of types in a flow-sensitive way while we are looking for a unique flow-insensitive type for each of our variables.

Programs with procedure calls and scalar variables
We first present our static analysis in the simple context of programs built from a number of procedures manipulating only scalar variables (we exclude pointers from the scalars). This allows to discuss our approach in a simple setting, before investigating the additional issues raised by pointers, casts and dynamic allocation.

The considered input language
We consider a simple subset of C, the grammar 3 of which is depicted on Fig. 2. f, g denote procedure names, x, y variable names. As our analysis is flow-insensitive, we do not detail the statements related to control. In short, in this subset all variables are declared as integers, there are no pointers, no structured types, no dynamically allocated data. We assume that all procedures return a value, and that variables are uniquely identified by their name.
We do not consider explicit enumerated type declarations, unlike a tool like SPLint [1], which complains about casts from one enumerated type to another one. This is because our analysis is not intended as an help for programmers to discover potential problems due to weak typing.

3 We ignore details about separators, etc.



x = expr ∈ ⟨stm⟩
D(x) ⊇ D(expr )
return expr ∈ ⟨stm⟩(f )
D(f ) ⊇ D(expr)
x = f (expr 1,..., exprn) ∈ ⟨stm⟩
typ f (typ1 x1,..., typn xn) ∈ ⟨proc⟩
D(x) ⊇ D(f )
∀i : D(xi) ⊇ D(expri)

(2)



D(cst ) = {cst} D(boolexpr ) = {0, 1} D(intexpr ) = Z
D(expr “?”expr 1“:”expr 2) = D(expr 1) ∪ D(expr 2)

(3)

Fig. 3. Inferring possible values for variables in scalar programs

Inferring the possible values of variables
In this simple setting, the philosophy of our analysis is not really to infer types, but just to discover the set of possible values for any variable in a given procedure. This means that we focus on an attribute-independent, flow- and context-insensitive static analysis, which computes a function
D : Proc  Var → P(Z)	(1)
where
P(Z) is the complete lattice of subsets of integers; the least upper bound op- erator of this domain coincides with the set union;
D(f ) denotes the possible return values of the procedure f and D(x) the pos- sible values of the variable x.
The functional set D = Proc  Var → P(Z) ordered pointwise is a complete lattice (the codomain of any D ∈D is finite).
This inference analysis is formalized on Fig. 3. It is based on the inspection of assignments, procedure call and return statements contained in procedures. We implicitly extend the function D to expressions using Eqn. (3). Observe that we do not exploit the context of expressions: having the subexpression “x+3” or “x?1:0” in a procedure does not allow to infer any information on the possible values contained in x in the C language. This analysis is quite similar to a constant propagation analysis, in which the constant flat lattice is replaced by the lattice P(Z).
The approximation we perform in this analysis is to consider that the set of possible values of any integer expressions (as defined in Fig. 2) is the set of all integer values. For instance, if x may take the values 1 or 3 (ie., D(x)= {1, 3}), our analysis considers that x+1 may take any value (ie., D(x+1) = Z), instead of just a value in the set {2, 4}. Without this approximation our analysis is not computable 4 , because the lattice D does not satisfy the finite ascending chain condition. An alternative could be not to perform this approximation, but instead to use a widening operator that replaces finite subsets of Z by Z when their cardinality is greater than a given threshold. This alternative corresponds to the disjunctive completion of constant propagation analysis, equipped with a widening operator to ensure convergence.

4 or at least very costly, if one considers that all variables are finite machine integers

Given a specific program, the longest chains of elements in P(Z) appearing in the analysis is of length H, being at most the number of numerical constants appearing in the program, plus 3 (because of the “predefined” constants 0, 1 returned by Boolean operators, and the top element Z). Hence the full analysis converges in at most H|Proc|+|Var| steps, where |Proc|, |Var | denotes resp. the number of procedures and variables.
Typing the analyzed program
Once the function D is computed by the previous analysis, we have to translate the weakly-typed C program into a strongly-typed variant of the C language, in which operators are typed as described on Fig. 4(a).
This transformation is based on the fact that a ﬁnite value D(x)= {v1,..., vn} implicitly defines an enumerated type, denoted typD(x) in formula. If D(x) = Z, then by convention typD(x) = int. The transformation consists in two operations:
Adding enumerated type declarations:
for each different finite value Dk = {v1,..., vnk } of D we insert the C type
k	k
declaration “typedef enum { lk1=vk1,...,lkn=vkn } tk”;
we implicitly add the predefined type “typedef enum { false=0, true=1
} bool”;
each variable declaration “int x” with D(x)= Dk is then replaced by “tk x”. The same holds for the return type of procedures.
Inserting casts between integers and finite types, to ensure proper typing. Ex- pressions and assignments are translated as defined in Fig. 4, in which we use the following operation on types:


t H tj
⎧⎨ t if t = tj
⎩ int otherwise

(4)

Fig. 5(b) shows the results of this transformation on the prog. of Fig. 5(a). Observe that the definition of the cast operators cast bool→int and cast int→bool does not follow exactly the same pattern as for ordinary enumerated type, as any non-zero integer values is associated to the Boolean true.
Discussion
The soundness criterium is that the new program should have the same operational semantics as the original program. It is easy to see that typing error will not occur, given the properties of the function D computed by the analysis and the definition of functions typ and cast .

There is however a problem if some variables are read before being initialized. Look at the program on the right. Our inference analysis assigns to x the type enum { l1=1
}. Hence, seen as a Boolean, x is always true and the function returns 1. The C99 standard specifies on the
int main()
{
int x,y;
y = x ? 1 : 0; x = 1;
return y;
}


!b	:	bool	→ bool
−b	:	int	→ int
&&b, ||b	: bool×bool → bool


typ(cst ) = int typ(x ) = typD(x)
typ(opb e) = t if opb : t1 → t

+b, ∗b, <<b, &b,.. .: int×int  → int	1	1
typ(e1 opb e2) = t if opb : t1 ×t2 → t
<b, >b,...	:  int×int  → bool	2	2
b	b	typ(e1?be2 :b e3) = typ(e2) H typ(e3)
== , !=	:	α×α	→ bool

·?b· :b ·	: bool×α×α → α


Strongly-typed versions of C99 oper- ators. α is a type variable used for poly- morphic operators.
Jcst ) =^ cst
 typ(castt2 →t1 (e)) = t2	
Typing expressions


Jop
Jlv ) = lv
e) = opb (cast

' (Je))) if
, opb : t1 → t

1	^	1
t1 →t
t′ = typ(Je))
, opb : t1 ×t2 → t

1	2 2  ^	t1 →t1	1
2	t2 →t2	2
t′ = typ(Je ))

Je op e ) = cast '	' (Je )) opb cast '	' (Je )) if
b
2
t′ = t′ H t′

1	2 2  ^	t →t1	1
2	t →t2	2	1	2
⎩



1	2	3  ^	bool→t1	1
t →t2	2
t →t3	3




Jlv = e) =^ lv = cast


t→t

(Je)) if	t = typ(lv )
t′ = typ(Je))
ti = typ(Jei))


1	⎧	n
f : t1 ×...×tn → t
if	t′ = typ(lv )
⎪⎩ t′ = typ(Jei))

cast t→t(e)= e
cast t →int(e) = (e == v1)	? l1	:	cast int→t (l) = (l == l1 )	? v1	:

k	k	k
.
.
.
k	k	k
.
.
.

(e == vnk−1) ? lnk−1 : lnk	(l == lnk−1) ? vnk−1 : vnk
k	k	k	k	k	k
cast bool→int(e) = (e == 0) ? false : true	cast int→bool(e) = e ?1:0 
cast t→t' = cast t→int ◦ cast int→t' if t /= t′
(d) Definition of cast operators
Fig. 4. Generating a strongly typed version of the program

other hand that the value of x is undefined when y is assigned, which means that it can have any value. To deal with this aspect without complicating our framework, we choose to impose that all variables are initialized before being read. Checking this assumption can be done with the classical dataflow analysis implemented in most C compilers, and enforcing it can be done on the original program by replacing any non-parameter declaration “int x” by “int x=0”.
A second important point is related to our motivation to exploit the ability of some tools to analyze more precisely finite-state variables. Because we insert casts from enumerated types to integers, we may loose at first glance the ben- efit of assigning enumerated types to some original integer variables of a pro-
gram.	This will not happen with the ConcurInterproc tool, thanks to the




int incrmod2(int x)
{
if (x==0) x=1; else x=0; return x;
}
int main()
{
int y = incrmod2(1); return y;
}
Original C program
typedef enum { k0=0,k1=1 } t; t incrmod2(t x)
{
if (cast int t(x)==0) x=cast t int(1); else x=cast t int(0);
return x;
}
t main()
{
t y = incrmod2(cast t int(1)); return y;
}
Adding finite types



typedef enum { k0=0,k1=1 } t; t incrmod2(t x)
{
if ((x==k0 ? 0 : 1)==0) x=(1==0 ? k0 : k1);
else x=(0==0 ? k0 : k1); return x;
}
int main()
{
t y = incrmod2(1==0 ? k0 : k1); return y;
}
Expanding casts
typedef enum { k0=0,k1=1 } t; t incrmod2(t x)
{
if (x==k0) x=k1; else x=k0; return x;
}
int main()
{
t y = incrmod2(k1); return y;
}
Propagating constants

Fig. 5. Inferring enumerated types and transforming the original program.

way it normalizes expressions by pushing operators in the branches of conditional expressions and simplifying trivial tests. For instance, it rewrites the expression if ((x==k0 ? 0 : 1)==0) x=(1==0 ? k0 : k1) in Fig. 5(c) as follows:
if ((x==k0 ? 0 : 1)==0) x=(1==0 ? k0 : k1)	⇒
if (x==k0 ? 0==0 : 1==0) x=k1	⇒	if (x==k0) x=k1


Adding pointers, structures and dynamic allocation
We now add pointers, structured types and dynamic allocation to our language. We extend the grammar of Fig. 2 as follows:

⟨typ⟩ ::= ⟨typ0⟩“∗”k	⟨typ0⟩ ::= int | “typedef struct {”(⟨typ⟩ n)∗“}”t
⟨expr⟩ ::= ... | ⟨pexpr⟩	⟨pexpr⟩ ::= null | “&”x | “&”(x → n)
⟨lv⟩ ::= x | “∗”x	⟨stm⟩ ::= ... | ⟨lv⟩ = alloc(⟨typ⟩)
(5)
We add in particular the operator & which creates a pointer value from a variable or a field of a structure (no function pointers). n, m, ... denotes names of structures fields, assumed to be unique. We allow only one * operator in left-values (including the implicit * of ->). Assignments like “**x=**y” should be decomposed as “px=*x; py=*y; *px=*py” and “a->n = b->m” as “pa = &(a->n); pb = &(a->m); *pa =
*pb;”.
The important assumption we do in this section is that there is no (implicit or
explicit) cast between the types t ∗k and t ∗k′ with k /= kj ∨ t /= t , and that the
1	2	1	2
program is well-typed in this respect.








int main()
{
int x = 0; int y = 1;
int* p = NULL; p = &x; *p = 2; p = &y; *p = 3; return *p;
}
Original program



typedef enum {
l0=0,l1=1,l2=2,l3=3
} t;
t main()
{
t x = l0; t y = l1;
t* p = NULL;
p = &x; *p = l2; p = &y; *p = l3; return *p;
}
Final program
typedef struct {
int n;
} t;
int main()
{
t x; t* y; int *p,*q;
y = alloc(t); p = &(y->n); y = &x;
q = &(y->n);
*p = 1;
*q = 2;
*p = *p < 1; return *p;
}
Original program
typedef enum {
l0=0,l1=1,l2=2
} e;
typedef struct {
e n;
} t;
int main()
{
t x; t* y; e *p,*q;
...
*p = l1;
*q = l2;
*p = (*p==l0)?l1:l0; return *p;
}
Final program

Fig. 6. Program with pointers to scalars	Fig. 7. Program with structures




Purpose of our inference analysis

In Section 3 our finite type inference reduced to the analysis of possible values of scalar variables. In this new setting, the goal of our type inference is
as before to detect the scalar variables that are manipulated as Boolean or enumerated types, and to infer the corresponding type;
but also to do so for the ﬁelds of structured types;
while taking into account typing and aliasing properties induced by pointers. Our analysis will return a unique type for a given field name, meaning that we renounced to capture distinct (boolean/integer) uses of the same structured type in different contexts.
Consider the program of Fig. 6(a). We want to infer that p may point to x or
y. This allows to infer that D(x)= {0, 2, 3} and D(y)= {1, 2, 3}. Now, as x and y may be pointed to by the same pointer p, they should have the same type. Hence we generate the program of Fig. 6(b).
Consider now the program of Fig. 7(a). We know that y is a pointer to a structure of type t, by its type. We do not need more information about pointers to structures, as the field n of all structures of a given type may be eventually specialized to a unique type. In other words, all the locations corresponding to the field n are summarized into a single location named .n. We still need to infer that p and q may point to the scalar field .n of an object of type t, and to deduce from this fact that the scalar field may contain a value in the set D(.n)= {0, 1, 2}. This results in the program of Fig. 7(b).
To conclude, we need a weak form of points-to analysis, in which we are only interested in points-to relation between pointers variables, integer variables and fields of structures.

x = expr ∈ ⟨stm⟩ int∗+ x ∈ ⟨decl⟩

P (x) ⊇ P (expr )
return expr ∈ ⟨stm⟩(f ) int∗+ f (.. .) ∈ Proc
P (f ) ⊇ P (expr)

P (null) = ∅
∗x = expr ∈ ⟨stm⟩ int∗∗+ x ∈ ⟨decl⟩

∀y ∈ P (x): P (y) ⊇ P (expr )
x = f (expr 1,..., exprn) ∈ ⟨stm⟩
typ f (typ1 x1,..., typn xn) ∈ ⟨proc⟩

P (x) ⊇ P (f ) if typ = int∗+
∀i | typi = int∗+ : P (xi) ⊇ P (expri)

P (&x) = {x}	(only applied to a var. of type int∗∗)
P (&(x → n)) = {.n}  (only applied to a field of type int∗∗)
P (expr “?”pexpr 1“:”pexpr 2) = P (pexpr 1) ∪ P (pexpr 2)
(6)

Fig. 8. Points-to analysis

x = expr ∈ ⟨stm⟩  int x ∈ ⟨decl⟩

D(x) ⊇ D(expr )
return expr ∈ ⟨stm⟩ int f (.. .) ∈ ⟨proc⟩
D(f ) ⊇ D(expr)
∗x = expr ∈ ⟨stm⟩  int∗+ x ∈ ⟨decl⟩

∀y ∈ P (x) : D(y) ⊇ D(expr ) x = f (expr 1,..., exprn) ∈ ⟨stm⟩
typ f (typ1 x1,..., typn xn) ∈ ⟨proc⟩
D(x) ⊇ D(f ) if typ = int
∀i | typi = int : D(xi) ⊇ D(expri)

D(cst ) = {cst}
D(∗x) =	y∈P (x) D(y) D(boolexpr ) = {0, 1} D(intexpr ) = Z
D(expr “?”expr 1“:”expr 2) = D(expr 1) ∪ D(expr 2)


(7)

Fig. 9. Inferring possible values for variables and fields
Formalization of the analysis
We still perform a weak form of flow and context-insensitive points-to analysis, that infers a function
P : Proc  Var  Field → P(Var  Field )
which maps procedure return values, variables and fields of pointer type to variables and fields. P (x) (resp. P (.n)) will be an overapproximation of the set of variables and fields to which x (resp. the field .n of any object) may point to. This function is the smallest solution of the inference rules of Fig. 8, in which Eqn. (6) extends P to expressions of type int∗k,k > 0.
We then generalize the scalar value analysis of Section 3.2 by inferring a function
D : Proc  Var  Field → P(Z)
which maps integer variables and fields to possible values. This function is the smallest solution of the inference rules of Fig. 9, in which Eqn. (7) extends D to expressions of type int.

Typing the analyzed program
As mentioned in Section 4.1, assigning types to variables is a bit more complex than in the purely scalar case, because two variables pointed to by the same pointer

should be given the same type. Otherwise, the need for a cast may depend on the value of the pointer. Therefore,
If x (or .n) is initially declared as an integer, typ(x)= typ {D(y) | ∃p:P (p)⊇{x,y}};
If x (or .n) is initially declared as a pointer int∗k,k  >  0, typ(x)  =
(typ y∈P k (x) D(y))∗ , where P  denotes the k-th iterate of P .
The insertion of casts is done exactly as in Section 3.3. Observe that we do
not need casts between pointers: we cannot have “t* x; int* y;...; y=x” in the final program, because such an assignment makes the variables and fields pointed to by x and y (hence, also x and y) having the same type.

Discussion
In this section, we extended the proposition of Section 3 to a broader subset of C. However this proposal was done under some assumptions (absence of casts and pointer arithmetic) and should be seen as a demonstration of how the value analysis and points-to analysis interact. It is possible to relax these assumptions by using classical well-studied points-to analysis. In particular, the technique of Steensgarrd
[11] seems well-suited, since it is interprocedural, flow-insensitive and it accepts the language of Equation 5. This technique infers the pointing relation and the effective structures manipulated by a C program with casts.
Handling arrays in addition to structures and pointers can be integrated to the points-to analysis by giving a unique type to the whole array and assuming that no out-of-range access occurs.
Note that the condition that variables must be initialized before being read, mentioned in 3.4, should also be satisfied for dynamically allocated memory, but this is more complex to check or to enforce.

Conclusion
We presented a way to determine the set of Boolean and enumerated variables among a set of variables of type int in a C program. This information, of little use for compilation, allows to improve the precision of program verification by assigning these variables to the adequate abstract domain.
The process takes as input a large subset of C (including functions, structures, pointers) and performs a simple points-to analysis followed by a value analysis. The results of these analyses allows to transform the program in a strongly-typed equivalent version by refining the types and by inserting explicit casts in the right place.
Note that this work would not be necessary if the abstract domains used by the analysers where able to dynamically switch the types of the variables they ma- nipulate when the latter are escaping their capabilities. But the abstract domains proposed in the literature tend to be very specialized (eg. floating points [2], nu- merical arrays [4]), and taking more general cases into account would add a burden to their complexity.

Our work is complementary with the compilation of C program to intermediate language or to simpler subsets [9,5]. These proposals can be seen as frontends dedicated to verification by reducing the gap between C and the simpler analyser input language, thus answering Point (i) of the introduction.
An implementation has been developed for ConcurInterproc [6], having
c2newspeak [5] as a frontend. The analyser only handles scalar types thus does not require the points-to version of the analysis (Section 4) but further develop- ments for analysers with richer memory model will benefit from it.

References
Evans, D. and D. Larochelle, Improving security using extensible lightweight static analysis, IEEE Software 19 (2002), pp. 42–51.
Goubault, E., M. Martel and S. Putot, Asserting the precision of floating-point computations: A simple abstract interpreter, in: D. L. M´etayer, editor, ESOP, Lecture Notes in Computer Science 2305 (2002),
pp. 209–212.
Guha, A., C. Saftoiu and S. Krishnamurthi, Typing local control and state using flow analysis, in:
G. Barthe, editor, ESOP, Lecture Notes in Computer Science 6602 (2011), pp. 256–275.
Halbwachs, N. and M. P´eron, Discovering properties about arrays in simple programs, in: R. Gupta and S. P. Amarasinghe, editors, PLDI (2008), pp. 339–348.
Hymans, C. and O. Levillain, Newspeak, Doubleplussimple Minilang for Goodthinkful Static Analysis of C, Technical report, EADS (2008).
Jeannet, B., Relational interprocedural verification of concurrent programs, in: Software Engineering and Formal Methods, SEFM’09 (2009).
Jim, T., J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney and Y. Wang, Cyclone: A safe dialect of c, in: C. S. Ellis, editor, USENIX Annual Technical Conference, General Track (2002), pp. 275–288.
Min´e, A., The octagon abstract domain, Higher-Order and Symbolic Computation 19 (2006).
Necula, G. C., S. McPeak, S. P. Rahul and W. Weimer, CIL: Intermediate Language and Tools for Analysis and Transformation of C Programs, in: R. N. Horspool, editor, CC, LNCS 2304 (2002), pp. 213–228.
Sotin, P. and B. Jeannet, Precise interprocedural analysis in the presence of pointers to the stack, in:
G. Barthe, editor, ESOP, Lecture Notes in Computer Science 6602 (2011), pp. 459–479.
Steensgaard, B., Points-to analysis by type inference of programs with structures and unions, in:
T. Gyim´othy, editor, CC, Lecture Notes in Computer Science 1060 (1996), pp. 136–150.
