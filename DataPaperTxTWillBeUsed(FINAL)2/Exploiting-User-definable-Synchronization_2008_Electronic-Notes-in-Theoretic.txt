Electronic Notes in Theoretical Computer Science 211 (2008) 27–38	
www.elsevier.com/locate/entcs

Exploiting User-definable Synchronizations in Graph Transformation 
Ivan Lanese1
Computer Science Department, University of Bologna, Bologna, Italy

Abstract
Parametric Synchronized Hyperedge Replacement (PSHR) is a graph transformation formalism where pro- ductions specifying the behavior of single components can be synchronized to give full transitions. The main feature of PSHR is that the synchronization model is user-definable. To enhance the applicability of the approach we propose a simplified and more suggestive semantics, preserving however the expressive power of the original one. We also show how some common synchronization models can be formalized and exploited inside PSHR. This allows to simplify the modelling step, and the produced model too. We apply this approach to the airport case study of FET-GC project AGILE.
Keywords: Graph transformation, Synchronized Hyperedge Replacement, synchronization algebras, mobility.


Introduction
Architectural modelling is the step of the design of a system that fixes the structure of the system, that is its components and the connections among them, and its evolution over time. Since these aspects have a large impact on all the following phases of the development process, it is important that the decisions made are clearly stated in the model. This requires modelling frameworks with a formal syntax and semantics.
Many approaches to this problem have been presented in the literature, from UML [13] to different Architecture Description Languages [3]. We choose as frame- work Synchronized Hyperedge Replacement (SHR) [6], which is a graph transfor- mation framework. Thus the system is modelled as an (hyper)graph, where (hy- per)edges are components connected through common nodes. This provides both sound mathematical foundations and a suggestive visual representation. In SHR the behavior of components is specified by productions which can be synchronized

٨ Research supported by the EC Project IST-FP6 16004 Sensoria.
1 Email: lanese@cs.unibo.it

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.027

to build transitions. In particular, productions perform actions on nearby nodes, and actions performed on the same node must be compatible according to some synchronization model. We also use mobility [9,8], allowing actions to carry nodes as parameters, and synchronization to merge them thus reconfiguring the system. In particular, we consider Parametric SHR (PSHR) [11], where both action syn- chronization and mobility patterns are specified by a user-defined Synchronization Algebra with Mobility (SAM). This allows to choose each time the most suitable synchronization model for the application at hand.
PSHR is very expressive, as shown in [11], but its formal semantics is quite heavy and difficult to understand. This problem is common to other SHR variants, and is aggravated in PSHR by the need to manage different synchronization models. The problem is due to the fact that the standard semantics of SHR is based on inference rules that exploit a representation of graphs as terms in an algebra. In this presentation each part of the transition is obtained as a result of many inference steps, thus it is not easy to guess the global effect of a set of productions. We propose a more extensional semantics, where the synchronizations allowed on a node by a specific SAM are directly characterized, and an algorithm specifies how to build a full transition. Also, the semantics is based on a set-theoretic representation of graphs instead of on an algebraic one.
We also show how a synchronization model can be formalized as a SAM, and how PSHR can be used to model the evolution of a system using this SAM. We apply this approach to the airport case study [2], which has been proposed in- side the FET-GC project AGILE [1] on architectures for mobility. We show that parametric synchronization allows a simpler model than the one presented in [4], where a synchronized version of Double Pushout [7] based on a fixed two-parties synchronization is used.
Structure of the paper. § 2 defines graphs and SHR transitions. § 3 presents SAMs, characterizes their effects, and analyzes the modelling of synchronization policies as SAMs. § 4 contains the algorithm to derive transitions from productions.
§ 5 details the application of the approach to the airport case study. Finally, § 6 presents conclusions and plans for future work.

Hypergraphs and SHR transitions
SHR [6] is an approach to (hyper)graph transformation that defines global tran- sitions using local productions. Productions define how a single (hyper)edge can be rewritten and the conditions that this rewriting imposes. Conditions are spec- ified as compatibility requirements among actions performed by productions on nearby nodes. The exact requirements depend on the chosen synchronization model. We use the extension of SHR with mobility [9,8], that allows edges to send node references together with actions, and nodes whose references are matched during synchronization are merged. In this work we use Parametric SHR (PSHR) [11], where the used synchronization model and mobility patterns can be freely chosen by specifying them via a Synchronization Algebra with Mobility (SAM). A detailed

description of different SHR frameworks can be found in [10].
The usual presentation of SHR is based on a representation of graphs as terms in a suitable term algebra and on inference rules to derive transitions from productions. This presentation allows to easily prove properties of the framework exploiting tech- niques from the process calculi field, but it is not so suggestive, since transitions are built as a result of many inference steps, and this makes difficult to understand the actual interactions. Also, the general mechanism is hidden because of heavy technicalities.
We propose here an original and more suggestive semantics, where transitions are built using an ad-hoc algorithm that highlights the main features of the syn- chronization and mobility mechanisms, and we present a direct description of the interactions allowed by a SAM. Also, our semantics is based on a set-theoretic presentation of graphs instead of on an algebraic one.
We always assume to have a countable set of nodes N , a countable set of edges E, and a countable ranked set of edge labels LE. Given L ∈ LE, rank(L) is its rank.
Definition 2.1 (Hypergraph)
A (hyper)graph is a tuple ⟨E, lab, N, conn, Γ⟩ where E ⊆ E is the set of edges, lab : E → LE is the labelling function for edges, N ⊆ N is the set of nodes, conn : E → N ∗ is a function mapping each edge e to a n-uple of nodes where n is the rank of the label lab(e), and Γ ⊆ N is the set of nodes in the interface. Nodes not in the interface are said hidden.
Graphs are considered up to bijective renamings of edges and of hidden nodes.
In the above description conn specifies to which nodes each edge is attached.
We present now the steps of an SHR computation.
Definition 2.2 (SHR transition) Let Act be a set of actions, and given a ∈ Act
let ar(a) be its arity. An SHR transition is of the form:

Λ,π	'
G

where G and G' are graphs. Let ΓG be the interface of G. Then Λ: ΓG → (Act×N ∗) is a total function and π : ΓG → ΓG is an idempotent substitution. Function Λ assigns to each node x the action a ∈ Act and the vector y of node references sent to x by the transition. If Λ(x)= ⟨a, y⟩ then we deﬁne nΛ(x)= y. We require that ar(a) = |y|. We deﬁne the set of communicated names n(Λ) as {z|∃x.z ∈ nΛ(x)}. Substitution π allows to merge nodes. Since π is idempotent, it maps every node into
a standard representative of its equivalence class. We require that ∀x ∈ n(Λ).xπ = x, i.e., only references to representatives can be sent.
SHR transitions are obtained by synchronizing productions using a specified synchronization model.
Definition 2.3 (SHR production) An SHR production is an SHR transition
Λ,id
G

G occurs exactly once in conn(e). Furthermore the node substitution in the label is
id and the interface of G' is ΓG ∪ n(Λ).

For each G of the above form there is an idle production G
Λc,id
−−−→ G where

Λє(x) = ⟨ϵ, ⟨⟩⟩ for each x ∈ ΓG (ϵ is a special “idle” action with ar(ϵ) = 0). Idle
productions are included in all sets of productions, which are also closed under
bijective renamings of nodes.

Synchronization Algebras with Mobility
We formalize a synchronization model as a Synchronization Algebra with Mobility (SAM). SAMs were first introduced in [11], extending Winskel’s synchronization algebras (SAs) [14] to deal with mobility of nodes.
As a notation, we use  to denote disjoint set union. In A B we denote with [1, x] (resp. [2, x]) the element that corresponds to x ∈ A (resp. x ∈ B).
Definition 3.1 (Synchronization algebra with mobility)
A Synchronization Algebra with Mobility < Act, ar, •, ϵ, mob,Fin > consists of a binary partial operator • on a set of actions Act, a set of mobility patterns mob and a subset F in of Act. Function ar : Act → N maps each action a ∈ Act to its arity ar(a), and ϵ ∈ Act is an action of arity 0. Here mob is a set indexed by pairs of actions (a, b) such that a • b is deﬁned, and moba,b is a partial function from
{1,... , ar(a)} {1,... , ar(b)} to N.
We impose the following conditions:
the • operator is associative and commutative;
∀a, a' ∈ Act.a • a' = ϵ ⇒ a = a' = ϵ;
∀a ∈ Act.a • ϵ is deﬁned ⇒
(a • ϵ = a ∧ ∀x ∈ {1,... , ar(a)}. moba,є([1, x]) = x);
ϵ ∈ F in;
∀a, b, c ∈ Act
∀x ∈ {1,... , ar(a)}. moba•b,c([1, moba,b([1, x])]) = moba,b•c([1, x]),
∀x ∈ {1,... , ar(b)}. moba•b,c([1, moba,b([2, x])]) = moba,b•c([2, mobb,c([1, x])]),
∀x ∈ {1,... , ar(c)}. moba•b,c([2, x]) = moba,b•c([2, mobb,c([2, x])]);
∀a, b ∈ Act, x ∈ {1,... , ar(a)}. moba,b([1, x]) = mobb,a([2, x]);
∀a, b ∈ Act. moba,b is surjective on {1,... , ar(a • b)}.
As in SAs, we have a set of actions Act and an operator • of action composition. Here a • b = c means that actions a and b can synchronize giving action c as a result. If a•b is undefined then a and b are not compatible. For instance in CCS an action a can synchronize with a coaction a producing τ as a result. Action ϵ stands for “not taking part to the synchronization”, and it allows to specify in a uniform way action synchronization and asynchronous execution of actions. In fact, a • ϵ = a means that a is executed asynchronously. With respect to SAs, now actions a in Act have a specified arity ar(a), which corresponds to the number of node references carried

by a. A mobility pattern moba,b specifies how to build the references attached to a • b starting from the references attached to a and b. The correspondence is just positional as in usual procedure calls, but many parameters can be assigned to just one position. In that case the parameters are merged and the result is assigned to the
chosen position. Using N as codomain instead of {1,... , ar(a • b)} allows to specify merges among parameters even if the chosen representative of the equivalence class defined in this way does not occur in the final label.
Simple message passing is specified by a set of mobility patterns MP that merges corresponding references and assigns the result to the corresponding position. For- mally, M Pa1 ,a2 ([n, x]) = x for each n ∈ {1, 2}, x ∈ {1,... , ar(an)}.
A mobility pattern moba1 ,a2 included in a SAM S can be applied to two actions
⟨a1, y1⟩ and ⟨a2, y2⟩ to compute both the substitution σ performing the merge of parameters and the vector of parameters of the result, given respectively by the two functions:
σ = sub(S, ⟨a1, y1⟩, ⟨a2, y2⟩)= 
mgu({yi[j]= yh[k]| moba1 ,a2 ([i, j]) = moba1 ,a2 ([h, k])}) par(S, ⟨a1, y1⟩, ⟨a2, y2⟩)[i]= (yh[k])σ
where h, k are such that moba1 ,a2 ([h, k]) = i ∧ i ≤ ar(a1 • a2)
For instance, let S be a message-passing SAM with actions a, b and c of arity 1, 3 and 2 respectively, such that a • b = c. Then sub(S, ⟨a, ⟨x1⟩⟩, ⟨b, ⟨y1, y2, y3⟩⟩)= {x1/y1} (also {y1/x1} is a valid choice) and par(S, ⟨a, ⟨x1⟩⟩, ⟨b, ⟨y1, y2, y3⟩⟩) = ⟨x1, y2⟩. If we consider an action a' of arity 3 with parameters ⟨x1, x2, x3⟩ instead of a, then σ = {x1/y1, x2/y2, x3/y3}, but x3 is not a parameter of the resulting action.
F in is the set of complete synchronizations, that is synchronizations that are
allowed on hidden nodes. For instance, in CCS-style synchronization just τ (and ϵ) are allowed on those nodes.
Conditions (i) and (ii) are from SAs. The former specifies that the result of an n- ary synchronization does not depend on the order in which actions are synchronized. The latter specifies that non ϵ actions can not disappear giving ϵ. Condition (iii) specifies that synchronization with ϵ, if allowed, just propagates the other action. Condition (iv) assures that all the edges can stay idle on any node. Conditions (v) and (vi) state that mobility patterns are associative and commutative, extending condition (i) to the mobility part. Finally, condition (vii) guarantees that each reference attached to the composed action can be computed, that is it corresponds to a non empty set of references from component actions. In particular, this guarantees the existence of h, k in the definition of function par above.
We now characterize the effects of the synchronization specified by a SAM S on a n-uple of actions ⟨⟨a1, y1⟩,... , ⟨an, yn⟩⟩. The effects of the synchronization are an action cn with a tuple of parameters wn and a substitution ρn. We use eqn({t1/x1,... , tm/xm}) to denote {t1 = x1,... , tm = xm}.
Definition 3.2 (Effects of a synchronization) The effects of a synchronization
are computed by induction on the number n of actions.
n = 1) c1 = a1, w1 = y1, ρ1 = id.

Inductive case) Let cn, wn and ρn be the effects of the synchronization among the ﬁrst n actions. Then:
cn+1 = cn • an+1,
ρn+1 = mgu(eqn(ρn) ∪ eqn(sub(S, ⟨cn, wn⟩, ⟨an+1, yn+1⟩))),
wn+1 = par(S, ⟨cn, wn⟩, ⟨an+1, yn+1⟩)ρn+1.
Conditions (i), (v), (vi) in Definition 3.1 ensure that the result is independent w.r.t. the order of a1,... , an.
We present now some simple SAMs which can be used as building blocks for more complex ones, highlighting the technical aspects of the formalization of a synchronization model as SAM. We just write the cases where • is defined. We also skip cases that can be derived by commutativity. Furthermore, in the examples,
unless explicitly stated, we use moba,b = M Pa,b. The following SAMs use the minimal number of actions necessary to model a synchronization of the chosen type, but sets of actions sharing just ϵ can be merged in a unique SAM allowing different policies. In this case the action performed chooses the protocol to be used, since it can interact only with other actions from the same group. An example of this kind is presented in § 5.
Example 3.3 (Mutual exclusion SAM)
The mutual exclusion SAM is deﬁned by:
F in = Act = {a, ϵ};
λ • ϵ = λ for each λ ∈ Act.
Mutual exclusion ensures that in each transition at most one non ϵ action can be performed on each node. Synchronization of a with ϵ is necessary to allow transitions when more than one component is attached to the node. The SAM obtained by removing this synchronization allows to detect if an edge is the only one attached to a node, and it is attached just one time to it.
Example 3.4 (Milner SAM) The Milner SAM is deﬁned by:
Act = {a, a, τ, ϵ} with ar(a)= ar(a) and ar(τ )= 0;
a • a = τ, λ • ϵ = λ for each λ ∈ Act;
F in = {τ, ϵ}.
The Milner SAM, so called since it is inspired by π-calculus synchronization, models message passing, where actions a and a are input and output respectively and τ stands for a complete message exchange. During synchronization correspond- ing parameters are merged. Technically this is a refinement of the mutual exclusion SAM, in fact mutual exclusion is imposed between different synchronizations. Hav- ing just τ and ϵ in F in ensures that on a hidden node x either nothing happens or a complete message exchange is performed. Note that a SAM that uses many actions, all interacting using the Milner protocol can be built, and many variations are possible. For instance, the desired possibilities of input-output interactions can be specified, e.g., allowing an input to interact with all the outputs in a given set.
We present now an extension of Milner SAM where communication has to be

authorized by a particular action ok, thus allowing a simple form of traffic control. Thus a τ is here obtained as a result of a synchronization among a, a and ok. We consider the simpler case of actions and coactions having arity 1.
Example 3.5 (Controlled Milner SAM) The controlled Milner SAM is deﬁned by:
- Act = {a, a, ok, (a, a), (a, ok), (a, ok), τ, ϵ} with ar(λ) = 1 for each λ ∈ Act \
{ok, (a, a), τ, ϵ}, ar((a, a)) = 2 and ar(λ')= 0 for each λ ∈ {ok, τ, ϵ};
- a • a = (a, a) with moba,a([1, 1]) = 1, moba,a([2, 1]) = 2,
(a, a) • ok = τ with mob(a,a),ok([1, x]) = 1 for each x ∈ {1, 2},
a • ok = (a, ok), a • ok = (a, ok), (a, ok) • a = τ, (a, ok) • a = τ,
λ • ϵ = λ for each λ ∈ Act;
F in = {τ, ϵ}.
We have used here a technical trick: actions (a, a), (a, ok) and (a, ok) are gen- erally not used in productions, but they are used as intermediate results in the computation of the full synchronization. Note that here mobility patterns are not always specified by MP .
Example 3.6 (Broadcast SAM) The broadcast SAM is deﬁned by:
Act = {a, a, ϵ} with ar(a)= ar(a);
a • a = a, a • a = a, ϵ • ϵ = ϵ;
F in = {a, ϵ}.
The broadcast SAM models secure broadcast, where one component performs an output and all the others perform input. Notice that here reaction with ϵ is not allowed, and this requires all the components to participate in a non idle way to the synchronization. The requirement can be weakened by allowing some components to stay idle, thus obtaining multicast.
Example 3.7 (Multicast SAM) The multicast SAM is deﬁned by:
Act = {a, a, ϵ} with ar(a)= ar(a);
a • a = a, a • a = a, λ • ϵ = λ for each λ ∈ Act;
F in = {a, ϵ}.
To clarify Definition 3.2 we show here the effects of the synchronization of a tuple of actions ⟨⟨a1, y1⟩,... , ⟨an, yn⟩⟩ according to multicast SAM. The synchronization is allowed provided that at most one action is a. On a hidden node exactly one action must be a. Also, ρ is an mgu of {yi1 = yi2 = ··· = yim } where {i1,... , im} are the indexes of the non ϵ actions. Finally, w = yi1 ρ.
Deriving transitions from productions
In this section we present an algorithm to derive all the transitions starting from a graph G (without isolated nodes) specified by a set of productions P using a SAM
S. All the actions used in P are required to belong to Act.

The steps of the algorithm are described below.
Λe,id
For each edge e a production Pe = Le −−−→ Re is chosen, in such a way that
there exists an idempotent substitution σe : ΓLe → ΓLe such that Leσe is the subgraph of G composed by the edge e and the attached nodes. Essentially Le is equal to the desired subgraph, but if e is attached many times to the same node x then all the occurrences of x but one are renamed in Le using fresh
names: σe performs the inverse substitution. Furthermore nodes created by the productions (i.e., in Λe but not in Le) must be fresh.
For each node x, all the actions performed by productions Pe on nodes y such that yσe = x are instantiated by applying σe to their tuples of parameters and then composed, producing an action cx with parameters wx and a substitution ρx.
If there is at least a node x for which the above action composition is not defined, or x ∈/ ΓG but cx ∈/ F in, then no transition can be derived for this choice of productions.
A global substitution ρ is defined as the composition of all the substitutions ρx, that is ρ = mgu{ x∈N eqn(ρx)}. Among the possible mgus we choose one where nodes in ΓG are taken as representatives of their equivalence classes
whenever possible.
Λ maps each node x in ΓG to the pair ⟨cx, wxρ⟩.
π is the restriction of ρ to the nodes in ΓG.
The final graph is obtained as follows:
a graph is obtained by merging the instances Reσe of the RHSs of all the productions Pe (choosing different representatives for hidden nodes and edges in different RHSs);
the substitution ρ is applied to the graph;
only nodes in ΓG ∪ n(Λ) that occur in the resulting graph are kept in the interface;
isolated nodes are deleted.
We will not state here a formal theorem relating our semantics with the one presented in [11], since the present semantics formalizes a more refined approach to PSHR w.r.t. the older one available in [11]. In fact, the two approaches allow slightly different classes of SAMs. We will however discuss informally the differences between the two semantics.
In [11] graphs are represented as syntactic judgments Γ ▶ T where T is a term and Γ is the set of nodes in the interface (corresponding to ΓG here). The term T is built using constants for edges and the empty graph, and operators for composing
graphs (merging common nodes) and hiding nodes. Term T is considered up to a structural congruence that abstracts from the order of edges and of hidings and allows α-conversion of nodes. Edges are not explicitly named: just the labels are considered. Judgments up to structural congruence can be interpreted into graphs, obtaining a bijective correspondence.

univ:< ,<>>

chk

inPi



inAI	chk
Fig. 1. A sample transition.

From a dynamic point of view the main difference between the semantics pre- sented here and the standard one is that here isolated nodes are forbidden in the starting graph and removed from the result, while they are allowed in the standard one. This is not an important restriction since isolated nodes can not influence the other parts of the graph. They are actually needed in the standard semantics for the internal steps of the derivation of some transitions. In our case it is enough to allow them in productions. This difference allows to remove the component Init, used in [11], from SAM definition. Also, the standard semantics allows a non identity substitution π also in productions, but this is superfluous since the same effect can be obtained by synchronizing two actions on a hidden node. However this feature can be added also to our semantics. If we restrict our attention to SAMs that can be specified in both the frameworks (and we find a suitable set Init for [11]-style SAMs), and to productions having just id as node substitution, then the two semantics are equivalent up to isolated nodes (and actions performed on them).

The airport case study
We show here how the approach described above can be applied to the airport case study [2] of FET-GC project AGILE [1]. Since we are not aiming at tackling the whole case study, but just at showing how PSHR can be applied, we will do some simplifications. For a more complete approach to this modelling problem see [4].
The airport case study concentrates on modelling planes landing and taking off at airports, with passengers boarding the planes. We model entities (which are classes in UML class diagrams [13]) as edges with attributes modelled as nodes. In particular, we have edges for airports, planes and passengers. In this example, the first connection of each edge represents the attribute AtLoc, proposed in an extension of UML diagrams with mobility [5]. The value of attribute AtLoc repre- sents the location containing a mobile object. Also, objects that are locations such as airports and planes have the dual attribute Containing. Furthermore, planes have an attribute CheckedIn, whose value is the set of passengers that have already checked in for next flight. Passengers that have already checked in have the dual attribute. A simple graph modelling a system of this kind is the left graph in Fig- ure 1, featuring one airport (P isa) located in the universe (univ), a plane (AI234) in the airport and three passengers, two which have already checked in (IL-C, UM - C), and one which has not (F G). We represent edges as rectangles containing the label and connected to bullets representing nodes. Bullets are solid for nodes in the

at:< ,<>>

in:<ack,<at>>

at





chk:



chk:
<brd,<newat>>

at:<req,<newat>>
chk



at:< ,<>>




newat

 at
newat





 at  chk

<breq,<in>>
in:< ,<>>	in

Fig. 2. Productions for the example.

interface and empty otherwise.
We want to specify a transition that models the boarding of all the passengers who have checked in and the take off of the plane. This transition requires multiple checks and reconfigurations: essentially all the passengers who have checked in must move (changing their location), and the airport must allow the plane to take off. The plane must change its location too.
This is modelled by the productions in Figure 2 (which are schemas drawn for generic labels AIR, PLA, P AS-C and P AS for airports, planes, checked in passengers and not checked in passengers respectively), where Λ is represented by decorating each node with the corresponding action.
We have now to specify the SAM S that we want to use. Actions ack and req have to synchronize using Milner synchronization, since they model a message exchange between the airport and the plane allowing the take off, while actions breq and brd have to synchronize using broadcast synchronization with breq as output action, since all the checked in passengers have to board. Thus we can build the wanted SAM using the Milner SAM and the broadcast SAM as building blocks. The resulting SAM is defined by:
Act = {req, ack, breq, brd, τ, ϵ} with ar(λ) = 1 for each λ ∈ Act \ {τ, ϵ} and ar(τ )= 0;
req • ack = τ , breq • brd = breq, brd • brd = brd, λ • ϵ = λ for each λ ∈ {req, ack, τ, ϵ};
F in = {τ, breq, ϵ}.
We can thus derive the transition in Figure 1. Let us see how the different steps of the algorithm are performed.
For each edge but FG the corresponding production in Figure 1 is used, for edge FG an idle production is used. For nodes in the LHSs the names in the graph can be used, since no edge is attached two times to the same node. For new nodes (all called newat in the figure) different names must be chosen. To this end we add the label of the corresponding edge to the nodes created by passenger edges.
Let us consider node inP i as example.  The actions performed on it are
⟨ack, ⟨univ⟩⟩, ⟨req, ⟨newat⟩⟩, ⟨ϵ, ⟨⟩⟩, ⟨ϵ, ⟨⟩⟩, ⟨ϵ, ⟨⟩⟩. These can be composed pro- ducing ρinP i = {univ/newat} and action ⟨τ, ⟨⟩⟩.
The transition is allowed since all the compositions are defined and for nodes

different from univ the resulting action is in F in.
The substitution ρ is {univ/newat, inP i/newatIL−C , inP i/newatUM−C }.
Λ maps just univ to ⟨ϵ, ⟨⟩⟩.
π is the identity substitution.
The final graph is obtained from the union of the RHSs, applying substitution
ρ and leaving only univ in the interface.
Notably, when a suitable SAM is chosen for synchronization, the implementa- tion of the communication protocol becomes trivial. In [4] instead just a simple binary synchronization is used, thus a complex procedure is required to implement broadcast. In particular, this adds to the model of the system a subgraph used for synchronization purposes which does not correspond to any entity in the real system. Our choice allows models at a more abstract level, as suited for modelling complex systems.

Conclusion and future work
We have provided a more direct characterization of the behavior of a SAM and of the transitions allowed by PSHR w.r.t. [11]. We think that this is useful to make PSHR more usable. The result applies also to most of the SHR frameworks in the literature, which are instances of PSHR with a suitable SAM. Our approach can be also straightforwardly extended to deal with nondeterministic synchronizations and the use of many SAMs inside the same graph as presented in [12].
As future work we want to formalize different forms of SAM composition using categorical tools and analyze the observational semantics of SHR systems.

References
AGILE: Architectures for mobility. http://www.pst.informatik.uni-muenchen.de/projekte/agile/ .
L. F. Andrade et al. AGILE: Software architecture for mobility. In Proc. of WADT’02, volume 2755 of LNCS, pages 1–33. Springer, 2002.
Architecture description languages. http://www.sei.cmu.edu/architecture/adl.html .
P. Baldan, A. Corradini, and F. Gadducci. Specifying and verifying UML activity diagrams via graph transformation. In Proc. of Global Computing 2004, volume 3267 of LNCS, pages 18–33. Springer, 2004.
H. Baumeister, N. Koch, P. Kosiuczenko, and M. Wirsing. Extending activity diagrams to model mobile systems. In Proc. of NetObjectDays’02, volume 2591 of LNCS, pages 278–293. Springer, 2002.
P. Degano and U. Montanari. A model for distributed systems based on graph rewriting. Journal of the ACM, 34(2):411–449, 1987.
H. Ehrig, M. Pfender, and H. J. Schneider. Graph grammars: an algebraic approach. In Proc. of SWAT ’73, pages 167–180, IEEE, 1973.
G. Ferrari, U. Montanari, and E. Tuosto. A LTS semantics of ambients via graph synchronization with mobility. In Proc. of ICTCS ’01, volume 2202 of LNCS, pages 1–16. Springer, 2001.
D. Hirsch and U. Montanari. Synchronized hyperedge replacement with name mobility. In Proc. of CONCUR ’01, volume 2154 of LNCS. Springer, 2001.


I. Lanese. Synchronization strategies for global computing models. PhD thesis, Computer Science Department, University of Pisa, Pisa, Italy, 2006.
I. Lanese and U. Montanari. Synchronization algebras with mobility for graph transformations. In
Proc. of FGUC’04 – Foundations of Global Ubiquitous Computing, volume 138 of ENTCS, pages 43–
60. Elsevier, 2004.
I. Lanese and E. Tuosto. Synchronized hyperedge replacement for heterogeneous systems. In Proc. of COORDINATION 2005, volume 3454 of LNCS, pages 220–235. Springer, 2005.
J. Rumbaugh, I. Jacobson, and G. Book. The Unified Modeling Language Reference Manual. Addison Wesley, 1999.
G. Winskel. Synchronization trees. TCS, 34:33–82, 1984.
