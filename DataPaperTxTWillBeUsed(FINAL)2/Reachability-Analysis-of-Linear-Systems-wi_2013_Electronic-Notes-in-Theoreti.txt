Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 297 (2013) 61–74
www.elsevier.com/locate/entcs

Reachability Analysis of Linear Systems with Stepwise Constant Inputs
Paul H¨ansch1 Hilal Diab1 Ibtissem Ben Makhlouf 1
Stefan Kowalewski 1
Embedded Software Laboratory (Informatik 11) RWTH Aachen University
52074 Aachen, Germany

Abstract
Reachability analysis is one major approach for safety verification of continuous and hybrid dynamical systems. In this paper we present a new approach to calculate the reachable states of linear systems with uncertain inputs under the assumption that the inputs are stepwise constant. The original system S with inputs is transformed into a system S′ without inputs such that the reachability problem of S can be reformulated as a problem that involves only S′ and thus the inputs need no longer to be considered. Finally, we show that this approach is in accordance with existing ones.
Keywords: Linear systems, reachability analysis, safety verification, uncertain input, zonotopes.


Introduction
In safety critical applications, simulations can reveal errors in the system design, but in general they are not sufficient to verify safety. One approach to formal verification, common in the field of continuous and hybrid dynamical systems, is reachability analysis which aims at computing the reachable states, taking into account all possible initial states and inputs.
In general, the exact set of all reachable states of a dynamical system cannot be computed (see [6,12]). However, for special classes of dynamical systems, ap- proximation techniques are applied to overcome this problem by calculating over- or underapproximations of the reachable states.
Common data structures used to represent the approximations of reachable states are boxes ([13]), polytopes ([5]), polyhedra ([2]), level sets, ellipsoids ([7]), zonotopes ([3,1]) and support functions ([4]), each of which has advantages and

1 Email: [haensch diab makhlouf kowalewski]@embedded.rwth-aachen.de

1571-0661 © 2013 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.12.005

drawbacks. Boxes for example, being very simple data structures, introduce larger approximation errors than others but they are easy to handle. Zonotopes can rep- resent more complex geometric figures and are still one of the most popular data structures in reachability analysis, but they are not closed under intersection. Com- puting an approximation of the intersection of two zonotopes can be expensive or inaccurate or both. In particular, computational complexity and inaccuracy of ap- proximated intersection increase with the representation size of the zonotope. In the case of linear systems with inputs, the representation size of the zonotope (approxi- mating the reachable states) increases with each step of the algorithm. Informally, the representation size of the zonotope is crucial for the accuracy and computa- tion time of reachability analysis in hybrid systems. Now, our guiding question is, whether we can diminish the growth of the zonotope. Our idea is to reshape the system matrix and to map the reachability problem of a system with inputs to a problem that involves only a system without inputs. This approach is not restricted to a special geometric data structure. We assume stepwise constant inputs, which is in many scenarios a reasonable assumption, for example if the input is determined by some digital controller.
Section 2 contains a precise formulation of the problem. In Section 3.1 we explain our approach using an example and after that, in Sections 3.2 and 3.3, the general approach is given. Section 4 deals with the implementation of the presented method and Section 4.1 shows how to include a check for safety constraints. The example in Section 5 demonstrates the presented techniques. In Section 6 we show the equivalence of our method with existing approaches and Section 7 closes with a summary.
Problem Statement
In this paper we consider linear time-invariant non-autonomous systems of the form
x˙(t)= Ax(t)+ Bu(t),	(1)
where x(t) is the system state at time t, A ∈ Rn×n and B ∈ Rn×m are constant matrices, u(t) ∈ Rm is the input to the system at time t bounded by u(t) ∈ [u1, u1]×
... × [um, um] =: U , for all t ≥ 0. We assume the input u : R+ → Rm to be stepwise constant with respect to a predefined time step r, i.e., u : (ir, ir + r) → Rm is constant for all i ∈ N. We denote the class of all such bounded and stepwise constant (in short admissible) inputs by U.
Definition 2.1 [Trajectory, Reachability] A trajectory of system (1) is a time-
valued continuous function x : R+ → Rn which satisfies the following condition:
There exists an admissible input u : R+ → Rm such that for all t ≥ 0 (except for those where u is not continuous) the function x satisfies equation (1).
A state ξ ∈ Rn is reachable from ξ0 ∈ Rn at time τ if there exists a trajectory x
of the system under consideration such that x(0) = ξ0 and x(τ )= ξ.
In the following we introduce the R-operator which will be used throughout this paper.

Definition 2.2 [R-Operator] By R(X, [t0, t1]) we denote the set of all states x(t) reachable by system (1) at a time t ∈ [t0, t1] with initial condition x(0) ∈X under some admissible input u ∈ U. If X = {x0} is a singleton we write R(x0, [t0, t1]) and for t0 = t1 we write R(X, t0).
Givena set of potential initial states I ⊆ Rn and a time horizon T , the reachabil- ity problem consists in computing a (close) overapproximation of the set R(I, [0,T ]) In general it is hopeless to compute the exact set R(I, [0,T ]). Decidability results have been obtained only for very special classes of linear systems, see e.g. [8]. However, depending on the given problem, good over- or underapproximations are often sufficient. A common task is to verify that a given system does not reach a critical state, which can be accomplished by showing that an overapproximation of the reachable states does not intersect with the critical region.  Having this
motivation in mind, we look for overapproximations of reachable states.
Approach
Our idea is to map the reachability problem of a system with input given by equation
(1) to the reachability problem of an autonomous system, i.e. a system without the input Bu. Under the assumption that the inputs are stepwise constant, this can be done by shifting the input Bu into the state space. The price we pay for having a system without inputs is that the number of dimensions increases by the number of inputs.
In the following subsection we explain the idea using a simple example. Subsec- tion 3.2 presents the approach in a general setting.
Sketch of the Idea
Let us consider the following symbolic example of an n-dimensional system,
x˙(t)= Ax(t)+ u(t),  u(t) ∈ [μ, μ] × {0}× ... × {0},	(2)
where only the first component u1 of the input u is not zero. For system (2) we define the lifted autonomous system by


A
x˙×(t)= ⎜
1
0	x×(t)	(3)
. ⎟

⎝ 0 ... 0 0 ⎠
`	˛A¸′	x

component of the state vector x×, substitutes the input. As one can tell from the

last row of A× the variable x×
does not change over time. This corresponds to

our assumption of stepwise constant input. Further, because of A×
= 1 and

×
2,n+1
×
n+1,n+1
= 0 the variable x×
has an impact only on x˙×
just as

u(t) has an impact only on x˙1. Finally, if we take for x×
(0) all values in [μ, μ]

as possible initial values into account, then the variables x× ,..., x×
can reach the

1	n
same states as x1,..., xn, as long as the input u(t) is a constant value in [μ, μ].
In order to formalize the above paragraph, we introduce some further nota- tions. R(·, ·) denotes the reachable states of system (2), i.e. the original system, and R×(·, ·) denotes those of system (3), i.e. the lifted autonomous system without input. Further we define πk as the projection of a vector onto its first k com- ponents. Then, for example π2((4, 5, 6)T ) = (4, 5)T . We extend this projection to sets of vectors by πk(V ) := {πk(v) | v ∈ V }. Then, for example, we have π2({(4, 3, 2, 1)T , (5, 6, 7, 8)T })= {(4, 3)T , (5, 6)T }.
Now we can say that, under the assumption that the input u is constant in [0, r] and restricted to values in [μ, μ],
R(I,τ )= πn(R×(I× [μ, μ],τ ))
holds for all τ ∈ [0, r] and hence also
R(I, [0, r]) = πn(R×(I× [μ, μ], [0, r]))	(4)
holds.
Time-invariant dynamical systems (as is the case for (2)) satisfy the following property
R(I, [a + δ, b + δ]) = R(R(I, [a, b]), δ).
Now, one can derive
R(I, [ir, ir+r]) = R(R(I, [ir−r, ir]), r)
= πn(R×(R(I, [ir−r, ir]) × [μ, μ], r)),	(5)
where the first equation follows immediately from the above property, and the sec- ond equation is true under the assumption that, starting from R(I, [ir−r, ir]) the input remains constant for r time units.
Equations (4) and (5) provide a way to reduce the reachability problem for the original system with inputs to the reachability problem of a system without inputs: First, equation (4) can be used to compute R(I, [0, r]) if we have a method to compute the reachable states R×(·, [0, r]) of the lifted autonomous system. Second, equation (5) shows how to compute R(I, [ir, ir+r]) if we have R(I, [ir−r, ir]) and a method to compute R×(·, r).
The necessary technique to compute R×(·, ·) will be given in Subsection 3.3.

The General Approach
We focus on the general form of linear systems given by equation (1) and consider stepwise constant inputs.
For system (1) we define its lifted autonomous system by the state vector x× =
(x× ,..., x×	)T and the dynamic behavior
1	n+m





x˙×(t)= 
0.
.
x×(t).	(6)
···	0.
.

0	···	0
`	A˛′¸:=	x
 

Whereas the variables x×
,..., x×
are substitutes for the m different inputs.

As before, R(·, ·) denotes the reachable states of the original system (1) and
R×(·, ·) those of the lifted system (6).
Equations (4) and (5) from the previous subsection can be generalized to
R(I, [0, r]) = πn(R×(I× U, [0, r]))	(7)
R(I, [ir, ir+r]) = πn(R×(R(I, [ir−r, ir]) × U ), r).	(8)
Understanding these equations involves the same arguments that have been given in the previous subsection and will not be repeated here. It remains to compute the reachable states of the lifted system, which will be done in the next subsection. Then, equation (7) gives R(I, [0, r]) which can be plugged into equation (8) and gives R(I, [r, 2r]), which can be plugged again into the same equation and gives the reachable states for [2r, 3r] and so on, until we reach the desired time horizon.

Computing Reachable States of Linear Autonomous Systems
Given a linear time-invariant autonomous system
x˙ = Ax

we briefly recapitulate methods to compute or overapproximate the operations R×(·,τ ) and R×(·, [0,τ ]) which are needed in the computation scheme in equations (7) and (8).
The above system of differential equations admits the analytical solution
x(t)= eAtx0,

where x0 = x(0) is the desired initial condition. It follows that the set of states that are reachable from a given set X at time τ is

R×(X,τ )= 
x0∈X
eAτ · x0

= eAτ ·X ,	(9)
which is simply a linear transformation of X and the matrix eAτ can be computed by standard numerical tools with a high degree of accuracy (see [10] for the underlying algorithms).

Similarly, we have
R×(X, [0,τ ]) =
t∈[0,τ ]

eAt ·X .

As proposed in [3], this set can be overapproximated by
R×(X, [0,τ ]) ⊆ CH(I, eAτ I) ⊕ {x | x  v ≤ α},	(10)

α = (e  A  mτ − 1 − A  mτ ) · sup
x∈X
 x  v,

where CH denotes the convex hull of its arguments, ⊕ is Minkowski sum of sets defined by S ⊕ T := {s + t | s ∈ S, t ∈ T} and  · m is a matrix norm which has to be submultiplicative 2 and also consistent 3 with the vector norm  · v.
Equation (9) and inequality (10) complete the general computation scheme given in equations (7) and (8). The remaining details depend on the datastructures used in an implementation of this method.
Implementation Using Zonotopes
The computation scheme presented in the previous section can be implemented with different data structures. Here, we show an implementation using zonotopes, i.e. we will overapproximate each of the sets of reachable states R(I, [ir, ir + r]) with a zonotope. Afterwards we propose a way to efficiently check safety constraints of the form ∧iΣjαijxj ≤ ci, i.e. conjunctions of linear inequalities over the state variables xj with arbitrary constant coefficients αij.
Definition 4.1 [Zonotope] A zonotope Z is a tuple Z  = (c, g1,..., gk) with
c, g1,..., gk ∈ Rn and k ≥ 0. The characteristic set of Z is
{c + Σk  αi · gi | −1 ≤ αi ≤ 1 for all i = 1,..., k}⊆ Rn.
The parameter c is called the center and g1,..., gk are the generators of the zono- tope.
The term zonotope can refer to the tuple and also to its characteristic set, which should be clear from the context.
To simplify the notation, we will sometimes write a zonotope as a matrix, where the first column represents the center and the successive columns represent the generators of the zonotope. Figure 1 shows several examples of zonotopes together with their matrix representation.
In the following we give implementations of the operations needed in the com- putation scheme from Section 3.2 (see equations (7) and (8)).
One common way to specify the initial region I and also the inputs U is to use an interval 4 . Each interval I = [a1, a1] × ... × [an, an] is also a zonotope which can

2 i.e. AB m ≤ A m B  m for all matrices A, B ∈ Rn×n
3 i.e. Ax v ≤ A m x v for all A ∈ Rn×n and x ∈ Rn
4 The term interval is used also for higher-dimensional intervals like [a1, a1] × ... × [an, an]. Another common name for intervals is axis aligned box.


   
Fig. 1. Some examples for zonotopes in 2-dimensional space. From left to right: 0 has no generators and

 0 
 0 3 
 0 3 0  0
 0 3 0 2 

represents the singleton { 0 },
over two dimensions.
0 0 represents a straight line segment,
0 0 2 and
0 0 2 1 both expand



be written as

a1+a1
2

a1−a1
2

I =	.
. . .

an+an

2
a1−a1
2

where except for the first column, the matrix is diagonal, empty entries are 0. Hence, the implementation starts by transforming I and U into a zonotope.
Given two zonotopes Z1 = (c1, g1,..., gk) and Z2 = (c2, g1,..., gk) the set Z1 ×
1	1	2	2
Z2 can be represented by
, c1 g1 ... gk	0	⎞
Z1 × Z2 = ⎝	1	k ⎠ .

We use this formula to compute I× U (see equation (7)), after having transformed
I and U into zonotopes if necessary.
Next, we have to compute R×(Z, [0, r]) for a given zonotope Z = (c, g1,..., gk). According to equation (10) we first need the convex hull of Z and eArZ. Unfortu- nately, the convex hull of two zonotopes does not need to be a zonotope 5 . In [3] the following zonotope overapproximation is proposed:

CH(Z, eAr
Z) ⊆ (
c + eArc
,
2
c − eArc
,
2
g1 + eArg1
2
g1 − eArg1
2
,..., 

,..., 
gk + eArgk
,
2
gk − eArgk
).
2

Note that it contains 2k +1 generators. If Z is simply an interval 6 and r is suffi- ciently small, a closer zonotope overapproximation can be obtained by computing the interval hull 7 of Z and eArZ:
k	k	k	k
IH(Z, eArZ)= [c1 − Σ |g1|, c1 + Σ |g1|] × ... × [ck − Σ |gk|, ck + Σ |gk|]

and transforming it into a zonotope ZH . The resulting zonotope ZH has only n

5 Each zonotope is symmetric about its center and hence, the convex hull of e.g. the line segment 0 0 and

the singleton
 1 
0 1 
is not a zonotope.

6 If I and U are both intervals then so is Z = I × U .
7 i.e. a tight interval overapproximation

generators. Back to equation (10), we have to compute the Minkowski sum of ZH and {x | x  v ≤ α}. Therefore, we have to agree on a vector norm  · v. If using zonotopes, it is handy to use the infinity norm x  ∞ := maxi |xi|. In that case
{x | x  ∞ ≤ α} = [−α, α] × ... × [−α, α],
is an interval (with α as in equation (10)) and thus a zonotope.
The Minkowski sum of two zonotopes Z1  =  (c1, g1,..., gk) and Z2  =
1	1
(c2, g1,..., gk) is simply Z1 + Z2 = (c1 + c2, g1,..., gk, g1,..., gk). Altogether, we
2	2	1	1	2	2
have a zonotope overapproximation of R×(Z, [0, r]).
The transformation of a zonotope Z = (c, g1,..., gk) by a linear map represented by the matrix A is again a zonotope and can be written as A·Z = (Ac, Ag1,..., Agk). This covers the transformation of R(I, [ir−r, ir]) by erA′ .
The projection πn(Z) is obtained by applying πn to the center and each generator of Z. The matrix representation of πn(Z) is equal to the first n rows of the matrix representation of Z. In general, the projection can produce generators that have all entries equal 0. These generators can be deleted to reduce the size of the zonotope. To sum it up, all involved operations have polynomial runtime. However, the number of generators increases in each iteration by the number of inputs, which is
due to the operation R(I, [ir−r, r]) × U .

Checking Safety Constraints
Given the dynamical system (1) with state variables x1,..., xn and a safety con- straint ∧iΣjαijxj ≤ ci over the state variables, we compute iteratively the sets R(I, [0, r]), R(I, [r, 2r]), . . . and in each step we can check the safety constraint to verify that the system cannot reach a critical state under any initial condition x ∈I and under any possible input u.
Lemma 4.2 Given a zonotope Z = (c, g1,..., gk) and a safety constraint Σiαixi ≤
b. Then there exists z ∈ Z such that   α z > b, if and only if (α ... α ) · c +
i |(α1 ... αn) · gi| > b.
Proof. Consider Z× = (α1 ... αn) · Z, a linear transformation of Z by a one-row- matrix. The result is a zonotope in R which is a one-dimensional interval.
At first we show: ∃z ∈ Z : Σi αizi > b ⇔ ∃z× ∈ Z× : z× > b.
⇒ z× :=	i αizi = (α1 ... αn) · z is in Z× and satisfies z× > b. “⇐” Assume z× ∈ Z× and z× > b 
⇒ there must be z ∈ Z such that z× = (α1 ... αn) · z
⇒	i αizi = (α1 ... αn) · z = z× > b 
Thus, it suffices to check whether there is z×  ∈  Z×  with z×  >  b. On the other hand, Z× is a one-dimensional interval with maximum value (α1 ... αn) · c +  i |(α1 ... αn) · gi|. So it suffices to check if this maximum value is > b.	2
After the computation of each R(I, [ir, ir+r]) we use the above method to check




Fig. 2. Mechanical system consisting of point masses Mi at positions xi, ideal springs with spring constants
Ki and ideal viscous dampers with damping constants Di.

,. 0	1	0	0	0	0 ⎞.
,. 0 ⎞.

.− K1
— D1	K1
D1	0	0 .	.	.

M1	M1	M1	M1
.
.	. M1 .

x˙ =
0	0	0	1	0	0

	    	
. x + .	. f



..⎝
0	0	0	0	0	1


Fig. 3. State space model of the mechanical system with x = (x1, x˙1, x2, x˙2, x3, x˙3)T .
the safety constraints in time O(nk) with n being the dimension of the system and
k the number of generators of the zonotope overapproximating R(I, [ir, ir+r]).
Example
We consider a system of three point masses interconnected by springs and dampers (see Figure 2). Here we make two assumptions: The springs follow Hooke’s Law and the dampers are ideal viscous dampers. The position variables xi of the masses Mi are defined such that x1 = x2 = x3 holds when the springs are in their idle state (i.e. not compressed and not expanded). The force f applied to M1 is the input to this dynamical system.
From Newton’s Second Law we know that ΣF = M · a where ΣF is the sum of forces applied to the mass M and a is the acceleration of M . Here, the sum of forces applied to, for example, M1, is f + K1(x2 − x1)+ D1(x˙2 − x˙1) in the positive direction of x1. Therefore
f + K1(x2 − x1)+ D1(x˙2 − x˙1)= M1a1 = M1x¨1.
The dynamic behavior of M2 and M3 can be obtained in the same way. After introducing the state vector x = (x1, x˙1, x2, x˙2, x3, x˙3)T the dynamic behavior of the whole system can be written as a six-dimensional linear system with input (see Figure (3), where, for example, the second line reflects the dynamic behavior of M1 as given in the above equation).
Mechanical systems of this type can be used to model and verify the safety of controllers for the longitudinal dynamics of vehicles in a platoon (see [9]).



Fig. 4. Simulation of the mechanical system with input force f (solid line), positions xi (dotted lines) and velocities x˙i (dashed lines) of the point masses Mi over time t.




Figure 4 shows the results of a simulation where all constants of the system have been set to 1, carried out with MATLAB/Simulink software. The force f , in other words the input to the system (solid line in figure 4) is one sine wave oscillation followed by constant zero. The system responds with oscillating velocities and positions, where M1 naturally reacts faster than M2, which in turn reacts faster than M3. After the force f reaches and stays at zero, all positions converge towards the same constant value and the velocities converge to zero.
A safety relevant question might be whether the distances x1 − x2 and x2 − x3 are within given bounds, if we assume, e.g., f ∈ [−1, 1]. Since there is still an uncountably infinite number of possible scenarios, we cannot guarantee safety by running a number of simulations. Instead, we can use the approach given in the previous section to check the safety constraints. However, we have to be aware that reachability analysis is only carried out to a predefined time horizon T .
For this example we assume the input to be bounded by f ∈ [−1, 1] and to keep it simple, we consider only one initial state, namely (0,..., 0)T . The time step is chosen to be r = 0.01 and the time horizon T = 30. To analyze the possible behaviors of the system, we plot after each step, i.e. for each computed R(I, [ir, ir+r]) the biggest possible distance x1 − x2 among the currently reachable states in R(I, [ir, ir+r]). According to Lemma 4.2 this biggest possible distance is equal to (1 0 − 1 0 0 0) · c + i |(1 0 − 1 0 0 0) · gi| where c is the center and g1,..., gk are the generators of the zonotope representing R(I, [ir, ir+r]). Figure 5 shows the result and we see, that the biggest possible distance x1 − x2 is around
0.85 and x2 − x3 is around 0.5. In particular, the biggest possible distances can be reached within around 10 time units. Further reachability computations with bigger time horizon (100) and smaller time step (0.001) produced quasi identical results.




Fig. 5. Result of reachability analysis: Biggest possible distance x1 − x2 (solid line) and x2 − x3 (dashed line) over time t.
Comparison with Existing Approaches
We briefly recapitulate the standard approach to the reachability problem of linear systems. It is known (see e.g. [11]) that the expression

x(t)= eAt
x0 +
t
eA(t−τ )
0
Bu(τ )dτ

is the solution of the initial value problem x(0) = x0 associated with system (1). From this, one can show in a straightforward manner that

R(I, [0, r]) ⊆
eAtI	⊕
  ∫ t

eA(t−τ )
Bu(τ )dτ

t∈[0,r]
t∈[0,r]
u∈U  0

holds for system (1) where U is the class of allowed input functions. An overapprox- imation of this set and hence of the reachable states in the first time interval [0, r] can be found for example in [4].
To cover the successing time intervals [r, 2r], [2r, 3r],. . . an iterative scheme is needed. It can be derived from another straightforward consequence, namely

R(I, r)= eAr
·I ⊕


u ∈U
r
eA(r−τ )
0
u(τ )dτ.	(11)

As mentioned before (p. 52), time-invariant systems satisfy the following equa- tion (12) and the subsequent (13) follows immediately from (11):
R(I, [ir, ir+r]) = R(R(I, [ir−r, ir]), r)	(12)

= eAr
· R(I, [ir−r, ir]) ⊕


u ∈U
r
eA(r−τ )
0
u(τ )dτ.	(13)

In the case of stepwise constant input, the above formula can be simplified to
R(I, [ir, ir+r]) = eAr · R(I, [ir−r, ir]) + A−1(eAr − I)BU.	(14)
which, finally, is the desired iterative formula.

In a nutshell, the standard approach is to plug the overapproximation of R(I, [0, r]) into equation (14) giving an overapproximation of R(I, [r, 2r]) which again can be plugged into equation (14) etc. until the desired time horizon T is reached.
Note that the assumption of stepwise constant inputs gives a particular advan- tage: In Equation (13) the union over all admissible inputs u is usually a full- dimensional set, whereas its counterpart in the case of stepwise constant inputs, namely A−1(eAr − I)BU (see Equation (14)) is of at most the dimension of U . Hence, the number of generators added in each iteration step can be significantly smaller if we can assume stepwise constant inputs.
Both approaches, the one above and the one proposed in Section 3.2 consist of two formulae, one giving an initial computation and another one for the iteration. The iterative formulae of both approaches are equivalent:

Theorem 6.1 The iterative schemes given by (14) and (8) are equivalent, i.e.
eAr · R(I, [ir−r, ir]) + A−1(eAr − I)BU = πn(R×(R(I, [ir−r, ir]) × U ), r).

Proof. Let A× = , A B ⎞ ∈ Rn+m×n+m as defined in equation (6). By induction

⎝ 0 0 ⎠

,	⎞

it follows easily that A×i =
matrix. Then
⎠. By Ik we denote the k × k identity

∞	×i i
erA′ =	A r i!

i=0

= In+m +


=

=


=







provided det(A) /=0 

.	(15)


In the following we use the short hand notation R := R(I, [ir − r, ir]) and
U := [u1, u1] × ... × [um, um]. For matrices P ∈ Rn×n and Q ∈ Rn×m it holds



⎝ 0 Im ⎠



Consequently
⎝ 0 Im ⎠ ⎝ u ⎠
= ,⎝ Pr + Qu ⎞⎠ | r ∈ R,u ∈ U .


π  , P Q ⎞ · (R× U )  = PR + QU.	(16)
n
0 Im
Our claim follows from equations (15) and (16):
π (erA′ (R× U )) = erAR + A−1(erA − I )BU
2
Note that in the case of A being not invertible, before applying the standard approach one needs to transform the system such that it has an invertible system matrix. This is not necessary when applying the proposed alternative approach. Further, a more careful analysis reveals that computational complexity of both approaches is essentially the same.
Summary
By reshaping the system matrix we mapped the reachability problem of linear sys- tems with inputs to a problem over autonomous linear systems. We proposed an implementation using zonotopes. However, this approach is not restricted to a spe- cific geometric data structure. Reachability analysis was demonstrated at a practical example including the verification of safety constraints. Finally, we showed that the performance of this method is in accordance with the standard approach to reach- ability analysis of linear systems with stepwise constant inputs. In particular, the representation size of the zonotope – representing the overapproximation – increases in the same manner as it does in the standard approach. However, note that the assumption of stepwise constant inputs already accounts for a slower increment of the zonotope representation size, as explained in Section 6.

References
Althoff, M., O. Stursberg and M. Buss, Verification of uncertain embedded systems by computing reachable sets based on zonotopes, in: IFAC World Congress, 2008.
Frehse, G., PHAVer: Algorithmic verification of hybrid systems past hytech, in: HSCC, 2005.
Girard, A., Reachability of uncertain linear systems using zonotopes, in: HSCC, 2005.
Guernic, C. L. and A. Girard, Reachability analysis of linear systems using support functions, Nonlinear Analysis: Hybrid Systems (2010).


Han, Z. and B. H. Krogh, Reachability analysis of large-scale affine systems using low-dimensional polytopes, in: HSCC, 2006.
Henzinger, T., P. Kopke, A. Puri and P. Varaiya, What’s decidable about hybrid automata, Computer and Systems Sciences (1998).
Kurzhanski, A. B. and P. Varaiya, Ellipsoidal techniques for reachability analysis, in: HSCC, 2000.
Lafferriere, G., G. Pappas and S. Yovine, A new class of decidable hybrid systems, in: HSCC, 1999.
Makhlouf, I. B., J. Maschuw, P. H¨ansch, H. Diab, S. Kowalewski and D. Abel, Safety verification of a cooperative vehicle platoon with uncertain inputs using zonotopes, in: IFAC World Congress, 2011.
Moler, C. and C. V. Loan, Nineteen dubious ways to compute the exponential of a matrix, SIAM Review (1978).
Perko, L., “Differential Equations and Dynamical Systems,” Springer; 3rd edition, 2006.
Puri, A. and P. Varaiya, Decidability of hybrid systems with rectangular differential inclusions, in:
CAV, 1994.
Ratschan, S. and Z. She, Constraints for continuous reachability in the verification of hybrid systems, in: AISC, 2006.
