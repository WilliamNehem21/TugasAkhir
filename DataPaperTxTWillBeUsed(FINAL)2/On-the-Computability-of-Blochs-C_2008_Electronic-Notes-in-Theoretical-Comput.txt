	Electronic Notes in Theoretical Computer Science 202 (2008) 315–322	
www.elsevier.com/locate/entcs
On the Computability of Blochs Constant
Robert Rettinger1
FernUniversita¨t Hagen
LG Komplexita¨t und Algorithmen Universit¨atsstrasse 1
D-58095 Hagen

Abstract
We prove the computability of Blochs constant by presenting the first algorithm for this constant.
Keywords: computability, algorithm, Blochs constant.

Introduction
It is well known that any holomorphic (i.e complex analytic) function is open. A quantitative version of this fact and with many respects surprising, is Blochs theorem, stating that for any r > 0 and any holomorphic function f defined on a disc Dr(z0) = z  C z  z0 < r  with f'(z0) = 0 there exists a schlicht disc of radius f'(z0)  r c in the image f (Dr(z0)), where the constant c does not depend on f ! Obviously c is bounded from above, thus its supremum, the so called Bloch constant β, exists. The best upper bound known,
Γ(1/3)Γ(11/12)
β ≤ Γ(1/4)(1 + √3)1/2
found by Ahlfors and Grunsky [2], is at the same time conjectured to be the exact value of β. However the best lower bound known so far (quite recently found by Chen and Gauthier [3]) is
√3
4 +2 · 10−4 < β 
We will give an algorithm to compute Blochs constant to any precision. Fur- thermore our algorithm can be adopted to other constants of the same type, e.g. Landaus constant.

1 Email: robert.rettinger@fernuni-hagen.de

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.024

Next we will introduce some basic notions and notations mainly on the com- putability part of this paper. As mentioned above let Dε(z0) denote the open disc of radius ε with center z0. To simplify notation we use Dε := Dε(0) and D = D1. A normed holomorphic function on a domain D, 0  D, is a holomorphic function f with f (0) = 0 and f'(0) = 1. The space of normed functions on D is denoted by  (D). Given f   (D) let β(D, f, z0) denote the supremum r > 0 so that the disc Dr(z0) is covered by f (D) and f−1 exists on Dr(z0), i.e. there exists a function f−1 : Dr(z0)  D so that f f−1 is the identity function. These discs Dr(z0) are called schlicht (with respect to D and f ). Notice that in this case f−1 is uniquely determined and again holomorphic. Let β(D, f ) be the supremum of β(D, f, z) for all z  f (D). Finally let β(D) be the infimum of β(D, f ) for all f   (D). Then, by definition, we have β = β(D).
We will frequently use the notation z = z' ε instead of z (z' ε, z' + ε). Furthermore we will use the following simple lemma freely (which can be proven by the transformation f (z) '→ εf ( 1 z)):
Lemma 1.1 Let ε > 0 and a domain D with Dε ⊆ D ⊆ D be given. Then
εβ ≤ β(D) ≤ β
To introduce computability on C and R (and  (D)) we will shortly repeat some notions of discrete and type-2-computability theory. Let Σ be some finite set (alphabet). Then partial computable functions f :  Σ∗  Σ∗ on the free monoid Σ∗ can be defined by Turing-machines. Computability can be extended to Σ∞, the set of infinite sequences of elements of Σ, as follows: A function f :  Σ∞   Σ∞ is computable iff there exists a computable function g :  Σ∗  N   Σ∗ so that for all u, w with f (u) = w and all n  N there exists exactly one m  N so that g(u m, n) = w n is defined, where w n denotes the initial word of w of length n. Here and henceforth we assume that natural numbers are given by their binary representation.
To define computability on other spaces M we can use representations, i.e. sur- jections ν :  Σ∞   M . A word w with ν(w) = m is also called (ν-)name of m. A function f between represented spaces (M1, ν1) and (M2, ν2) is computable if we can realize f by a computable g in the sense that ν2 g equals f ν1 wherever the latter is defined. Products, even for sequences of representations or names, and rep- resentations of integers and rational numbers can be defined straightforwardly, for example by using computable pairing functions N N  N. (Standard) representa- tions of R and thus C (where we identify C by R  R) can be introduced as follows: A name of a real x is a sequence (qi)i of rational numbers so that qi  x   2−i for all
i. Finally we will need a representation of holomorphic functions, defined on some domain containing 0. Using standard representations of C we identify a sequence
(a0, a1, a2, ...) with the series (and thus holomorphic function) f (z) =	i∞=0 aizi.
For more details see [5].
Beside computable functions we will also need computable multifunctions f : M ⇒ N , where m	M can have many different values. Given representations of M and N we call such a multifunction computable if there exists a computable

realization as in the definition of functions (here the image of the realization can take any name of any value of the corresponding image of f ).

Test Functions
The main idea of our algorithm is to compute for several normed functions the corresponding β-values. By definition, we have to take the infimum for all normed functions, which cannot be done in finitely many steps. Thus we will restrict the space of functions we consider in our algorithm. In this section we will give such a smaller class of functions, which we will call test functions. In the next section we will adopt this class to our purposes, so that for each precision only finitely many functions have to be considered. Finally in Section 4 we will show how to compute the β-values for these finitely many functions.
Central to the definition of test functions is the following lemma.
Lemma 2.1 Let ε > 0 be given. Then for any f ∈ N (D) with β(D,f ) = β ± ε
∫z 	1	

(1)
|f (z)|≤ c0
0
1 − |t|2 dt

for c0 = √4 (β + ε) and all z ∈ D.
Proof According to a theorem of Ahlfors, any holomorphic function f in D
fulfills the following property: If |f'(z)|· (1 − |z|2) ≥ M for some z ∈ D then the
image f (D) contains schlicht discs of radius √3 M . Taking M = c0 = √4 · (β + ε)
and taking integrals, we see, that only functions for which (1) above holds can fulfill β(D,f ) ≤ β + ε.	 
To simplify things we fix a concrete value for c0 and call it c1, say c1 = 0.48 √4 .
Furthermore let ρ(z) = ∫ z   1   dt. Then the set of test functions is defined to be

the set
0 1−|t|2

T = {f ∈ N (D)|∀z ∈ D.|f (z)|≤ c1 · ρ(z)}
Thus the above lemma implies
Corollary 2.2 For each ε > 0 there exist f ∈T so that
|β(D,f ) − β| < ε 
Finally we give a simple property on the Taylor series of test functions, which we will use in the next section.
Lemma 2.3 Let f	and ε, 0 < ε < 1 be given. Then for the Taylor series
f (z) = Σi∞=0 aizi we have
|a |≤ c1 · ρ(ε)

Proof By Lemma 2.1 we have f (z)	c1 ρ(ε) for all z with z = ε. In addition, by Cauchy formula, we have
f (i)(0)	 1	∫	 f (t) 	2πε	|f (z)|

|ai| = |
i!	| = 2π |
|z|=ε
(	)i+1 dt|≤ 2	sup
|z|=ε
εi+1


The Main Theorem
Starting with Lemma 2.3 of the last section we define sets Aε and Bε of sequences (a0, a1, ...) of complex coefficients, which we will identify with their functions f (z) = 
Σi∞=0 aizi. Let ε, varepsilon' > 0 be a fixed constants. Then
c1 · ρ(ε1/4)


and
Aε := {(0, 1, a2, ...)|ai ∈ C, |ai|≤ 
εi/4	}

Bε := {(0, 1, a2, ...)|ai ∈ C, |ai| <
(c + ε') ρ(ε1/4)
εi/4	}

The reason to introduce Bε is, that we can enumerate (in a computable sense!)
the prefixes of the elements in Bε but we cannot do this for Aε as the ”smaller or equal” condition in the definition cannot be decided. (Actually, we could use Aε and restrict the class of prefixes accordingly.)
First we have to prove that the elements of Bε do indeed define bounded, holo- morphic functions on Dε:
Lemma 3.1 For each (ai)i ∈ Bε we have
Σi aizi converges absolutely on D√ε,
| Σi aizi|≤ √ε + (c1 + ε') · ρ(ε1/4)/(1 − ε1/4) for all z ∈ D√ε.
Proof The following inequality proves 1. and 2.

| Σi
aizi| ≤ √ε + Σ

i>1
(c1+ε')·ρ(ε1/4) i εi/4

≤ √ε + (c1 + ε') · ρ(ε1/4) Σi>1 εi/4
for all z ∈ D√ε.	 

Notice that the bound in 2. does actually not depend on the element of Bε. Thus we can uniformly compute f on Dε (and even its closure) as shown e.g. in [4]. Using Cauchy inequality we see that also f' and f'' can be computed uniformly on Dε, i.e. given f (as a sequence of coefficients in Bε) together with some z Dε we can compute f (z), f'(z) and f''(z).
Next let us introduce a topological structure on Bε: For δ > 0 define the neigh- borhoods Uδ(f ) by Uδ(f ) =  g  Bε  g(z)  f (z) < δ for all z  Dε . We will call the induced topological space again Bε and its restriction Aε. The decisive properties of Bε will be given by the following lemma, where the first part follows from Lemma 2.3. We omit a detailed proof.

Lemma 3.2 Let ε with 0 < ε < 1 be given. Then
T ⊆ Aε ⊆ Bε and
Aε is compact.

The second property allows us to approximate β with fixed precision in finitely many steps. The main point is to prove, that we can find, for any f Bε, an approximation γ of β(Dε,f ) so that this approximation is actually an approximation for a whole neighborhood. Afterwards we can use standard compactness arguments (see below). The validity of the first step is guaranteed by the following lemma, which we will prove in the next section.

Lemma 3.3 There exist computable multifunctions F :⊆ R × Bε ⇒ R × R so that given any ε > 0, 0 < ε < 1, f ∈ Bε and (γ, δ) ∈ F (ε, f ) we have
δ > 0, γ > 0 and
|γ − β(Dε, g)| < 1 − ε for all g ∈ Uδ(f ).

The proof of our main theorem is now a simple realization of the above discus- sion:

Theorem 3.4 Blochs constant is computable.

Proof We have to show that β can be approximated to arbitrary precision. There- fore let the precision d > 0 be given. Then define ε := 1  d/2 and proceed as follows:
We will need a variable β' holding the currently best approximation to β. Fur- thermore we keep a list L=U0, U1,... of open subsets of Bε. At the beginning let β' be some known upper bound on β and L be an empty list.
Next enumerate the prefixes α0, α1, ... of all elements in Bε and add in step i the neighborhood Uδ(αi) given by the multifunction F of the above lemma, applied to αi, to L. At the same time update the value β' to the minimum of β' and the value γ given by F (ε, αi). Finally check after each step, wether the neighborhoods encountered in L already cover Aε. If so, the current value of β' is an accurate ap- proximation of β. Otherwise proceed with the next step. Notice that the minimum above need only taken up to precision d/2 to achieve the overall precision d.
There is a small technicality in applying the function F : As we enumerate only prefixes of the coefficients, the procedure described in the next section may need more information than this prefix provides. This can be either resolved by cancelling the step and proceeding with the next prefix in the enumeration, or assuming all digits not given by the prefix to be 0.
 

Proof of Lemma 6
Let ε with 0 < ε < 1 and f	Bε be given. W.l.o.g. we can assume that ε > 3/4. We proceed in 4 steps:
Step 1: Find all zeroes z0, z1,...,zn of f' inside Dε and discs Dεi (zi) with
|f'(z)| < (1 − ε) · (√3 − 1)/42
for all z ∈ Dεi (zi).
Notice that we are actually only interested in the discs Dεi (zi) (and Dεi/2(zi)), because points of this discs are mapped to values near the boundary of schlicht discs. There are several ways to find the zeroes and discs. A quite simple one is by using the theorem of Rouche and polynomial approximations: f is given as the approximation of polynomials. To find the zeroes we can first find a strictly positiv lower bound of f on z z = ε and approximate f by a polynomial so that the error is smaller than this lower bound. (By using small disturbations of ε such a strictly positiv lower bound can always be found.) Rouches theorem then gives the number of zeroes we have to search for. By dividing Dε by circles we can repeatedly apply this method until we got all zeroes accurately enough. This can be improved by using a fast algorithm to find the roots of the polynomials approximating f and testing (again by Rouches theorem) wether these zeroes are accurate approximations of the zeroes of f itself.

Step 2: Compute a lower bound b of and an upper bound B on |f'| on
D1/2 = Dε \	Dεi/2(zi).
i
Then fix some ε' < inf{εi/3, b/supz∈Dε |f''(z)|, (1 − ε)/4} and let
D = Dε \	Dεi (zi),
i

D2/3 = Dε−ε' \	D2εi/3(zi).
i
After step 2 we know that for any z  D2/3 the discs Dε' (z) are mapped one to one onto f (Dε' (z)). Furthermore, by Blochs theorem there exists discs of radius b · ε' · 3/4 inside f (Dε' (z)).
Step 3: In this step we will approximate β(Dε,f ). Let
ε'' = min{b · ε' · √3/4, ε'/2}

and


ε''


ε''

G := ( 4 · Z + i 4 · Z) ∩ f (Dε).
For each pair (z, f (z)) ∈ D2/3 × G and each k ∈ N, k > 0 we compute a value

k
(z,f (z))
∈ {0, 1} so that


(2)


k
(z,f (z))
= ⎧⎨ 1 if β(Dε, f,f (z)) > (k + 1) · ε''/4
⎩ 0 if β(Dε, f,f (z)) < (k − 3) · ε''/4 − (1 − ε)/4

k
(z,f (z))
= {y ∈ f (Dε)||y − f (z)| < k · ε''/4} and Gk
k
(z,f (z))
∩ G.

We proceed in 2 steps, where we start with gk	= 1. Furthermore we will
compute the values involved only up to precision ε''/(16B):

Fix for each y ∈ Gk
a shortest path πf (z),y from f (z) to y inside

k
(z,f (z))
.	Divide πf (z),y by equidistant points x0, ..., xt of πf (z),y , so that

|xi − xi−1| < ε''/4.
Compute for s = 0, 1, ..., t the pre-images X = f−1(D3ε''/8(xs)) one after the other and check wether X ⊆ D2/3, i.e. if X∩(C\Dε−ε' ) /= ∅ or X∩D2εi/3(zi) /= ∅

k
(z,f (z))
= 0.

Now we can approximate β(Dε,f ) by
max
(z,f (z))∈D2/3×G

{k · ε''/4|gk

= 1}.

The correctness of the approximation in the last step follows easily from (2), as
|β(Dε,f ) − sup(z,f(z))∈D×G{k · ε''/4|gk	= 1}|
≤ ε''/4 + sup(z,f(z))∈D×G |β(Dε, f,f (z)) − max{k · ε''/4|gk	= 1}|
≤ ε''/4+ 4ε''/4+ (1 − ε)/4
≤ (1 − ε)/2.
Thus to verify step 3 we have to prove (2) and the computability of the values

k
(z,f (z))
. The latter follows from the fact, that any decisions and computations are

made only up to precision ε''/(8B).
To prove (2), let first (z, f (z)) ∈ D2/3 × G and k ∈ N be given so that gk	=
1. We will show that then the disc Dkε''/4(f (z)) is schlicht: Take any path π inside Dkε''/4(f (z)) which starts at f (z). By construction we have f−1(π) ⊂ D, because Dkε''/4(f (z)) is covered by the discs tested in step (A) (even if we take the reduced precision into account). That means that f−1 can be continued from f (z) along π. As Dkε''/4(f (z)) is simply connected, f−1 thus exists on Dkε''/4(f (z)), i.e. Dkε''/4(f (z)) is indeed schlicht.
Next let (z, f (z)) ∈ Dε × G be given so that there exists a schlicht disc of radius γ > (1 − ε)/4 − ε'' with center f (z) inside f (Dε). Let D' = Dγ−(1−ε)/4(f (z)) and D'' = f−1(D'). Notice, that D'' ⊂ D, i.e. Dε (zi) ∩ D'' = ∅, because otherwise
there exists z' ∈ D'' ∩ Dε (zi) for some i and we have |((f−1)'(f (z'))| > 42/(1  −
ε)(√3 − 1). This implies by Blochs theorem that there exist discs of radius 1−ε · √3 ·
|((f−1)'(f (z'))| > 1 which is not possible. But now (2) immediately follows, as the
tests in the above computation will for any path in Dγ−(1−ε)/4−ε''/2(f (z)) answer, that f−1 exists.
Step 4: Finally choose δ small enough so that in all previous steps any values of f

are needed only up to precision δ.

Discussion
In this paper we have given the first algorithm to approximate Blochs constant to arbitrary precision. We can furthermore adopt this algorithm to other constants of this type as Landaus constant. Beside the pure calculation of the values of the constants, our algorithm probably allows to get more information about the holomorphic functions bounding β. Thus we hope, that an implementation of our algorithm is a step forward to prove the long standing conjecture of Ahlfors and Grunsky.
Concerning the complexity of our algorithm, we hope to achieve an efficient algorithm by recycling data of previously steps and restricting adaptively the set of test functions. However, an a priori proof of efficiency (i.e. polynomial time bound), seems to be unachievable from our current knowledge.
Acknowledgement
I thank the referee for the valuable remarks on the first version of this paper.




References
Ahlfors, L. Complex Analysis,McGraw-Hill, 1981.
Ahlfors, L., and H. Grunsky U¨ber die Blochsche Konstante, Math.Z. 42, pp. 671 - 673, 1937.
Chen, H., and P.M. Gauthier On Bloch’s constant, J. Anal.Math. 69, pp. 275 - 291, 1996.
Mu¨ller, N. Polynomial-Time Computation of Taylor Series, Proc. 22 JAIIO - PANEL ’93, Part 2, Buenos Aires, 1993, pp 259-281.
Weihrauch, K. Computable Analysis, Springer-Verlag Berlin/Heidelberg, 2000.
