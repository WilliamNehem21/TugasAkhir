

Electronic Notes in Theoretical Computer Science 271 (2011) 3–22
www.elsevier.com/locate/entcs

A Prolog-based Query Language for OWL

Jesús M. Almendros-Jiménez 1,2
Dpto. de Lenguajes y Computación Universidad de Almería
04120-Spain

Abstract
In this paper we investigate how to use logic programming (in particular, Prolog) as query language against OWL resources. Our query language will be able to retrieve data and meta-data about a given OWL based ontology. With this aim, firstly, we study how to define a query language based on a fragment of Description Logic, then we show how to encode the defined query language into Prolog by means of logic rules and finally, we identify Prolog goals which correspond to queries.
Keywords: OWL, Logic Programming, Semantic Web


Introduction
The Semantic Web framework [11,13] proposes that Web data represented by HMTL and XML have to be enriched by means of meta-data, in which mod- eling is mainly achieved by means of the Resource Description Framework (RDF) [22] and the Web Ontology Language (OWL) [16]. RDF and OWL are proposals of the W3C consortium 3 for ontology modeling. OWL is syntacti- cally layered on RDF whose underlying model is based on triples. The RDF
Schema (RDFS) [10] is also a W3C proposal and enriches RDF with specific vocabularies for meta-data. RDFS/RDF and OWL can be used for expressing both data and meta-data. OWL can be considered as an extension of RDFS

1 The author work has been partially supported by the Spanish MICINN under grant TIN2008-06622-C03-03.
2 Email: jalmen@ual.es
3 http://www.w3.org.




1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.02.008

in which a richer vocabulary allows to express new relationships. OWL offers more complex relationships than RDF(S) between entities including means to limit the properties of classes with respect to the number and type, means to infer that items with various properties are members of a particular class and a well-defined model of property inheritance. OWL is based on the so- called Description Logic (DL) [8], which is a family of logics (i.e. fragments) with different expressivity power. Most of fragments of Description Logic are
subsets or variants of C2, the subset of first-order logic (FOL) extended with counting quantifiers, with formulas without function symbols and maximum two variables, which is known to be decidable [15]. Description Logic can therefore also be understood as an attempt to address the major drawbacks of using FOL for knowledge representation and inference, and also the syntax of DL allows a variable-free notation. The most prominent fragment of DL is SROIQ which is the basis of the new standarized OWL 2. OWL 2 seman- tics has been defined in [26], in which a direct semantics is defined based on Description Logic, and in [27] a RDF-based semantics is provided.
In this paper we investigate how to use logic programming (in particular, Prolog) as query language against OWL resources. Our query language will be able to retrieve data and meta-data about a given OWL based ontology. With this aim, firstly, we study how to define a query language based on a fragment of Description Logic, then we show how to encode the defined query language into Prolog by means of logic rules and finally, we identify Prolog goals which correspond to queries.
Basically, our work goes towards the use of logic programming as query language for the Semantic Web. It follows our previous research line about the use of logic programming for the handling of Web data. In particular, we have studied the encoding in logic programming of the XML query language XPath in [2,1], and the encoding in logic programming of the XML query language XQuery in [3,5], studying extensions of XQuery for the handling of RDF and OWL in [4,7,6]. In this framework, we would like to study how OWL querying and reasoning can be achieved by means of logic programming in order to be integrated with the proposal of the implementation of XQuery in logic programming.

Description Logic
Description Logic is a formalism for expressing relationships between con- cepts, between roles, between concepts and roles, and between concepts, roles and individuals. Formulas of Description Logic can be used for representing knowledge, that is, concept descriptions, about a domain of interest. Typi- cally, Description Logic is used for representing a TBox (terminological box )

and the ABox (assertional box ). The TBox describes concept (and role) hi- erarchies (i.e., relations between concepts and roles) while the ABox contains relations between individuals, concepts and roles. Therefore we can see the TBox as the meta-data description, and the ABox as the description about data.
In this context, we can distinguish between (1) reasoning tasks and (2) querying tasks from a given ontology. In both cases, a certain inference pro- cedure should be present in order to deduce new relationships from a given ontology. The most typical (1) reasoning tasks, with regard to a given ontol- ogy, include: (a) instance checking, that is, whether a particular individual is a member of a given concept, (b) relation checking, that is, whether two individuals hold a given role, (c) subsumption, that is, whether a concept is a subset of another concept, (d) concept consistency, that is, consistency of the concept relationships, and (e) a more general case of consistency checking is ontology consistency in which the problem is to decide whether a given ontol- ogy has a model. However, one can be also interested in (2) querying tasks such as: (a) instance retrieval, which means to retrieve all the individuals of a given concept entailed by the ontology, and (b) property fillers retrieval which means to retrieve all the individuals which are related to a given individual with respect to a given role.
OWL/DL reasoning is a topic of research of increasing interest in the literature. Most of DL reasoners (for instance, Racer [20], FaCT++ [30], Pellet [28]) are based on tableaux based decision procedures. Based on logic programming, the DLog system [23] reasons with an ontology by means of the encoding into Prolog and the use of the PTTP theorem prover. The KAON2 tool [9,19] is based on the encoding of the SHIQ fragment into disjuntive Datalog [18]. They have studied a resolution-based inference.
We believe that an interesting research line would be to design a query language whose aim is to express such reasoning and querying tasks. In other words, the study of some kind of formalism in which we can express the kind of task (i.e. reasoning and querying task) one wants to achieve with respect to a given ontology. Such a language should be equipped with some kind of formulas for representing the query. In addition, such a query language should be equipped with an inference mechanism in order to reason with the ontology. Such inference mechanism could be based on an entailment relationship. The query language we propose will be based on Description Logic formulas which can contain free variables. Free variables represent the elements of the formula for which we want to retrieve values. Such values should represent the names of concepts, roles and individuals satisfying a given query (i.e. the DL formula).
In such a case, we would obtain the answers to a given querying task. In the

case of formulas without free variables, the query would represent a reasoning task, and the answer would be true or false.
The definition of a set of entailment rules for RDFS and OWL has at- tracted the attention of the Semantic Web community. An entailment rela- tionship defines which relationships can be deduced from a given ontology. In this context, the authors of [25] have observed that the rules of entailment of the official RDF Semantics specification are not complete, and have sug- gested for the case of RDFS, to identify a fragment which encompasses the essential features of RDFS, which preserves the original semantics, be easy to formalize and can serve to prove results about its properties. With this aim they have defined a fragment of RDFS that covers the crucial vocabulary of RDFS, they have proved that it preserves the original RDF semantics, and avoids vocabulary and axiomatic information that only serves to reason about the structure of the language itself and not about the data it describes. The studied fragment of RDFS lifts the structural information into the semantics of the language hiding them from developers and users. They have given a sound and entailment relationship for a fragment of RDF including rdf:type, rdfs:subClassOf, rdfs:subPropertyOf, rdfs:domain and rdfs:range. In the case of OWL, there is a proposal for extending rules for entailment with
RDFS to OWL. The so-called pD∗ approach [29] is a proposal for an exten- sion of the RDFS vocabulary with some elements of OWL: owl:Functio- nalProperty, owl:InverseFunctionalProperty, owl:sameAs, owl:Symme- tricProperty, owl : TransitiveProperty and owl:inverseOf. For such a fragment, they have defined a complete set of simple entailment rules. The pD∗ approach has been successfully applied to the SAOR (Scalable Authorita- tive OWL reasoner) [17], a system which focuses on a good performance with RDF and OWL data.
In this line, our approach considers a set of entailment rules for a fragment of OWL. Such fragment differs from the fragment of the pD∗ [29], neither pD∗ is include in our fragment, nor our fragment is included in pD∗, but our fragment includes the RDFS fragment of [25]. In addition, our fragment of DL allows to encode the entailment relationship by means of logic programming, in particular, by Prolog. For this reason, we have studied the relationship between Description Logic and Logic Programming.

Description Logic and Logic Programming
In this area of research, some authors [14,31] have studied the intersection of Description Logic and Logic Programming, in other words, which fragment of Description Logic can be expressed in Logic Programming. In [14], they have defined the so-called Description Logic Programming (DLP), which cor-

responds with a fragment of SHIQ. With this aim, firstly, the fragment of DL is encoded into a fragment of FOL; and after the fragment of FOL is encoded into logic programming. Other fragments of OWL/DL can be also encoded into logic programming, in particular, Volz [31] has encoded fragments of SHOIN into Datalog, Datalog(=), Datalog(=,IC) and Prolog(=,IC); where “=” means “with equality”, and “IC" means “with Integrity constraints”. Some other proposals have encoded the fragment SHIQ into disjunctive Datalog [18], and into Datalog(IC,/,=not) [12], where “not” means “with negation”.
In our proposal, we have focused on one of the Volz’s fragments which can be encoded into Datalog. It is a fragment of SHOIN , which includes the OWL elements: rdf:type, rdfs:subClassOf, rdfs:subPropertyOf, owl : equivalentProperty, owl:equivalentClass, rdfs:domain, rdfs:range, o- wl: someValuesFrom, owl:hasValue and owl:allValuesFrom, and handles owl:union and owl:intersection operators, and owl:TransitiveProper- ty, owl:SymmetricProperty and owl:inverseOf properties. All of them are used with some restrictions. We believe that our proposal could be extended to other fragments of SHOIN studied in [31].
Our work can be intended as an extension of the DLP framework in the following sense. The encoding of DL into logic programming defines an en- tailment relationship based on the rules. However, our encoding differs from DLP encoding: instead of encoding class and role names as Prolog predicates, we encode them as Prolog atoms. In fact, our encoding only uses a predicate called triple which defines by means of Prolog facts the relationships (i.e. the ABox and TBox elements) of the ontology. Therefore the ontology can be easily stored in secondary memory with efficient access. As a consequence of such encoding concept and role names are now first-class citizens, and they can be handled as individuals in the corresponding Prolog program and goals. In addition, in our approach, and in contrast with the DLP approach, com- plex concepts in Description Logic are handled by means of Prolog terms. For
instance, ∀P.C is represented as a Prolog term forall(P, C). It also allows to handle complex concepts also as first-class citizens. Our work can be also considered as an extension of DLP framework because we investigate a more flexible query language than in DLP. By studying the entailment relationship between Description Logic formulas of the given fragment, we are able to pro- vide semantics to a more flexible query language than the underlying query language in the DLP framework. For instance, we are able to entail in our framework typing formulas of the style ∃P.C(I), that is, I is an individual of type ∃P.C, in the spite of ∃P.C(I) is not explicitely declared in the ABox. But more interesting, such a typing (i.e., ∃P.C) can be retrieved as a answer of our query language. It is not possible with the DLP encoding because ∃P.C

formulas can not be handled as first-class citizens. Moreover, P and C can work as query result, providing more flexible queries. In other words, our DLP extension can be considered as second order extension (i.e. predicate names in DLP can be replaced by variables) of the DLP approach. For such extension, we provide an entailment relationship. The entailment relationship defined in our proposal is also an extension of the underlying entailment relationship of the DLP fragment. Our entailment relationship is able to infer new DL formulas of the kind ∃P.C ± D when they are not explicitely declared in the TBox. Such new DL formulas would correspond with the inference of new rules from the DLP encoding of the selected fragment. In summary, our entailment relationship can obtain the same statements about the ABox: in- dividual assertions and property fillers than the DLP approach for the same fragment, but we can also obtain new statements about the TBox: subclass and subproperty assertions with respect to the DLP approach.
We have developed a prototype of our approach which can be downloaded from http://indalog.ual.es/OProlog. We have tested our prototype with several examples of ontologies including the running example presented bellow. With respect to the implementation we have to make the following remarks:
We have implemented the OWL-based query language using the SWI-Prolog interpreter.
We have used the RDFS library of SWI-Prolog [32] for implementing loading of OWL triples. The RDFS library of SWI-Prolog has limited querying capabilities. Our proposal can be considered as an extension of such library for OWL querying.
The syntactic structure of entailment rules makes that the implementation in Prolog loops: the predicate triple can call to itself with the same ar- guments. However, we have solved that problem by implementing an small Prolog interpreter which runs Prolog rules in such a way that it memo- rizes the facts about the predicate triple, and avoids calls with the same arguments.
The structure of the paper is as follows. Section 2 will present the fragment of DL of our proposal. Section 3 will define the query language proposed from the fragment. Section 4 will describe the encoding of the query language in Prolog. Finally, Section 5 will conclude and present future work.

Web Ontology Language
In this section we will show what kind of ontologies will be allowed in our framework. It will also define the entailment relationship.


Fig. 1. An Example of Ontology
An ontology & in our framework contains a TBox including a sequence of definitions f1,..., fn of the form given in Table 1 below, where E, F are class (i.e. concept) descriptions of equivalence type (denoted by E, F ∈ S ) of the form:

E ::= C0 | E1 H E2 | EP.{O}

In addition, C is a class (i.e. concept) description of left-hand side type (de- noted by C ∈ L), of the form:

C ::= C0 | C1 H C2 | EP.{O} | C1 H C2 | EP.C




f ::=
C ± D |	(rdfs:subClassof)
E ≡ F |	(owl:equivalentClass)
P ± Q |	(rdfs:subPropertyOf)
P ≡ Q |	(owl:equivalentProperty)
P ≡ Q− |	(owl:inverseOf)
P ≡ P− |	(owl:SymmetricProperty) P + ± P |	(owl:TransitiveProperty) T± 6P−.D |	(rdfs:domain)
T± 6P.D	(rdfs:range)
Table 1 Definitions for an ontology O


and D is a class (i.e. concept) description of right-hand side type (denoted by
D ∈ Y), of the form:

D ::= A | D1 H D2 | EP.{O} | 6P.D

In all previous cases, C0 is an atomic class (i.e. class name), P , Q are prop- erty (i.e. role) names and O is an individual name. In addition, the ABox contains a sequence of definitions A1,..., Am of the form:

A := P (A, B) | C0(A) | T(A)

where P is a property name, C0 is a class name, and A, B are individual names.
Basically, the proposed subset of DL restricts the form of class descriptions in right and left hand sides of subclass and class equivalence definitions, and in individual assertions. Such restriction is required according to [31] in order to be able to encode the fragment of DL into logic programming. Following [31], the universal quantification is only allowed in the right hand sides of DL formulas, which corresponds in the encoding to the occurrence of the same quantifier in the left hand sides (i.e. heads) of rules. The existential quantifi- cation only occurs in the right hand by the same reason. Union formulas are required to occur in the left hand sides of DL formulas, which corresponds in the encoding to the definition of two rules.




Table 2 Inference Calculus ▶OI

Let us see an example of an ontology &0 (see Figure 1). The ontology &0 describes meta-data in the TBox defining that the elements of Man and the elements of Woman are elements of Person (cases (1) and (2)); and the elements of Paper and elements of Book are elements of Manuscript (case (4)). In addition, a Writer is a Person who is the author_of a Manuscript (case (3)), and the class Reviewed contains the elements of Manuscript reviewed_by a Person (case (6)). Moreover, the XMLBook class contains the elements of Manuscript which have as topic the value “XML” ((5)). The classes Score and Topic contain, respectively, the values of the properties rating and topic associated to Manuscript (cases (7) and (8)).  The property average_rating is a subproperty of rating (case (10)). The property writes is equivalent to author_of (case (9)), and authored_by is the inverse property of author_of (case (11)). Finally, the property author_of, and conversively, reviewed_by, has as domain a Person and as range a Manuscript (cases (12)-(15)).
The ABox describes data about two elements of Book: “Data on the Web” and “XML in Scottland” and a Paper: “Growing XQuery”. It describes the author_of and authored_by relationships for the elements of Book and the writes relation for the elements of Paper. In addition, the elements of Book and Paper have been reviewed and rated, and they are described by means of a topic.

Entailment Relationship
Now, we would like to show an inference calculus, denoted by ▶OI, which de- fines the entailment relationship between formulas of the selected fragment. The inference calculus is shown in Table 2. In the rule (Eq1) E is a class name, and D is a class name in rules (Type1) to (Type5). In the rule (Type6) A is an individual name, and in the rule (Prop1) P is a property name. In addition, in the rule (Type6) we have that Cond(E)= E(A) if E is atomic; Cond(E)= P (A, O) if E = EP.{O}, Cond(E)= P (A, B), C(B) if E = EP.C.
Finally, in the rules (Prop1) to (Prop6), and (Sub12), (Sub13), P and Q can have the form S, S− and S+. The rules from (Eq1) to (Eq4) han- dle about equivalence. (Eq1) infers equivalence by reflexivity, (Eq2) infers equivalence by transitivity, and (Eq3) infers equivalence by symmetry. (Eq4) infers equivalence from the subclass relationship. The rules from (Sub1) to (Sub13) handle inference about subclasses. Cases from (Sub3) to (Sub7)
define new subclass relationships from union and intersection operators. How- ever, the calculus does not introduce new union and intersection operators. For instance C H E ± D is not entailed from C ± D. The same can be said for C H E ± D which is not entailed from C ± D and E ± D. The same happens with C ± D H E from C ± D and C ± E.  Cases from (Sub8)

to (Sub13) define new subclass relationships for complex formulas. Such entailment of complex formulas is the main contribution of our inference cal- culus with respect to DLP framework and the pD∗ approach. In the former case, the entailment relationship can only entail formulas about individual and property fillers assertions, and not about complex formulas. In the later case, pD∗ does not handle owl:someValuesFrom, owl:allValuesFrom and owl:hasValue and therefore such rules have not sense in pD∗. However, the pD∗ handles for instance owl:FunctionalProperty which is not consider in our framework.
The rules (Type1) to (Type7) infer type relationships from subclass and equivalence relationships. The most relevant ones are the cases from (Type2) to (Type5) defining the meaning of complex formulas w.r.t. individuals. Fi- nally, the rules (Prop1) to (Prop11) infer relationships about roles. The most relevant ones are the case (Prop8) and (Prop9) about the inverse of a property and the case (Prop10) about the transitivity relationship. Our inference calculus is able to infer new information from a given ontology. For
instance, &0 ▶OI Reviewed(jjData on the Webjj), using the following TBox
and ABox information of &0:

Book (jjData on the Webjj). Book ± Manuscript .
Person(jjAnonymousjj).
reviewed _by (jjData on the Webjj,jj Anonymousjj).
Manuscript H EReviewed _by.Person ± Reviewed . by means of the following reasoning:

▶(Type1)	Manuscript(jjData on the Webjj)
▶(Type3)	Reviewed(jjData on the Webjj)
Our inference calculus can be used for proving a given Description Logic formula of the selected fragment from an ontology of the same fragment. Our inference calculus can be used for inferring all the entailments from a given ontology. The idea is to apply the rules up to a fix point is reached. In addition, we have designed the inference calculus in order to be implemented in logic programming, in particular, in Prolog. It forces to limit the inference capabilities of our system. The inference calculus only handles the user-defined DL complex formulas (i.e. those included in the TBox). For instance, we

cannot infer new relations like C ± 6P.D because it requires to check all the relations between individuals for P in the ABox. The same can be said for EP.C ± D, and P ± Q.

A Query Language based on Description Logic
In this section we will define the query language based on Description Logic. Such query language will introduce variables in DL formulas in order to express the values to be retrieved in the query result. In addition, our query language can handle conjunctions of DL formulas. We will use variable names starting with lower-case letters to distinguish them from non-variables.
Assuming a set Vc of variables for concepts c, d, ... and a set Vp of variables for roles p, q, .. ., and a set Vi of variables for individuals a,b.. ., a query Q against of an ontology & is a conjunction Q1,..., Qn where each Qi has the form:

Q ::= C ± D | E ≡ F | R ± T | R ≡ T | P (A, B) | C0(A)

where C ∈ LV , D ∈ YV , E, F ∈ SV , R, T = P, P−,P + and P ∈ PV and A, B ∈ IV , C0 ∈ Vc or is a class name. In addition, SV contains the set of formulas of the form:

c	| c ∈ Vc
C0	| atomic class
E1 H E2	| E1, E2 ∈ SV EP.{O}	| P ∈ PV , O ∈ IV
LV contains the set of formulas of the form:

c	| c ∈ Vc
C0	| atomic class
C1 H C2	| C1, C2 ∈ LV EP.{O}	| P ∈ PV , O ∈ IV C1 H C2	| C1, C2 ∈ LV EP.C	| C ∈ LV , P ∈ PV
YV contains the set of formulas of the form:



c	| c ∈ uc
C0	| atomic class
D1 H D2	| D1, D2 ∈ YV EP.{O}	 | P ∈ PV , O ∈ IV 6P.D	 | D ∈ YV , P ∈ PV
and finally, PV contains property names and elements of up, and IV contains individual names and elements of ui.
As in the case of the data and meta-data definition language, the query language is restricted to a fragment of DL in order to be encoded in logic programming (i.e. in Prolog). Assuming that variable names start with lower case letters, queries are formulas like:
type(“Growing X Query ”) whose meaning is “Find the type of Growing XQuery”.
Person(p), Reviewed _by (“Growing XQuery”,p), whose meaning is “Retrieve the reviewers of “Growing XQuery”” and
Manuscript(m), Reviewed_by(m,“Almendros”) whose meaning is “Retrieve the manuscripts in which “Almendros” is a reviewer”
Author_of (author, ‘Data on the Web”) whose means is “Retrieve the au- thors of “Data on the Web””. Let us remark that in this case, subproperties of “Author_of” are taken into account (for instance, “Authored_by” and “Writes”).
Let us remark that the previous queries can be answered from the TBox and the ABox of the ontology. Meta-data can be retrieved by means of our query language, however, queries about meta-data can be only answered from the TBox of the ontology. For instance, using union and intersection operators we can retrieve:
intersection ≡ Book H Reviewed whose meaning is “Find the intersections of Book and Reviewed”.
T± 6Writes.range whose meaning is “Find the ranges of Writes”.
T± 6p.Book whose meaning is “Find the properties whose range is Book”.
Ep.Person ± Book whose meaning is “Find the properties about Person’s in which the range belongs to Book”.
class ± Ep.{“XML”} whose meaning is “Find the classes having a role related to “XML””.

An answer of a query Q w.r.t. an ontology & and vocabulary V is a mapping θ from DV ar(Q) into V such that & ▶OI θ(Q), where DV ar(Q) denotes the set of variables of Q.
Finally, we have to remark that some syntactic sugar can be considered in our query language. For instance 6P.C(A) represents a(A),a ± 6P.C, and EP−.{O}(A) represents a ± Eq.{O},q ± P−, a(A).

Encoding into Prolog
Now, we would like to show how to use Prolog in our framework. The role of Prolog is double. Firstly, we can encode any given ontology instance of the considered fragment into Prolog. Secondly, our inference system ▶OI can be encoded into Prolog by means of rules, in such a way that a certain class of Prolog goals, which implement the Description Logic based query language can be used as query language.

Ontology Instance Encoding
The encoding of an ontology instance consists of Prolog facts of a predicate called triple, representing the RDF-triple based representation of OWL. In the case of the TBox: (a) en(C ± D ) = triple(en(C ), rdfs : subClassOf ,- en(D )); (b) en(E ≡ F ) = triple(en(E ), owl : equivalentClass, en(F )); (c) en(P ± Q ) = triple(en(P ), rdfs : subPropertyOf , en(D )); and (d) en(P ≡ Q ) = triple(en(P ), owl : equivalent Property, en(Q )). In addition, en(C ), en(D ), en(E ), en(F ), en(P ) and en(Q ) represents the encoding of classes and properties in which class and property names C , P,... are translated as Prolog atoms c, d,.. .. The special case of T is encoded as en(T) = owl : thing . In addition, Prolog terms are used for representing complex DL for- mulas as follows: (a) en(P +)= trans(en(P )); (b) en(P−)= inv (en(P )); (c)
en(6P.C )= forall (en(P ), en(C )); (d) en(EP.C )= exists(en(P ), en(C )); (e)
en(EP.{O}) = hasvalue(en(P ), en(O )); (f) en(H1≤i≤n Ci ) = inter ([en(C1 ),
..., en(Cn )]) and (h) en(H1≤i≤n Ci )= union([en(D1 ),..., en(Dn )]). Finally, the elements of the ABox are also encoded as Prolog facts relating pairs of individuals by means of properties, and defining memberships to classes:
(a) en(P (A, B )) = triple(A, en(P ), B ) and (b) en(C0 (A)) = triple(A, rdf :
type, C0 ).

Encoding of the Inference Calculus ▶OI
Now, the second element of the encoding consists of Prolog rules for encoding the ▶OI inference calculus. The set of rules can be found in Tables 3, 4 and 5

Table 3
Encoding of the Inference Calculus I





where facts for predicates class, property and individual are defined for each atomic classes, (inverse and transitive) properties and individuals.

Table 4
Encoding of the Inference Calculus II

Table 5
Encoding of the Inference Calculus III

Using Prolog as Query Language
In this section, we will show how to use Prolog as query language for OWL. Basically, each query φ = ϕ1,..., ϕn in our query language can be encoded as a Prolog goal ? − triple(en(ϕ1 )),..., triple(en(ϕn )) in which each element of uc, up and ui is encoded as a Prolog Variable. Now, we will show examples of queries against the ontology &0 and the corresponding answers. Let us remark

that in Prolog variables start with upper case letters.
Query 1: The first query we like to show is “Retrieve the authors of ma- nuscripts”, which can be expressed in our query language as Author_of(a,b), Manuscript(b). It can be encoded as:

? − triple(A, author _of , B ),triple(B, rdf : type, manuscript).

Let us remark that our inference system is able to infer that a Paper and a Book is a Manuscript and therefore the above query retrieves all the manuscripts of the ontology &0. In addition, our inference system is able to infer that author_of is a equivalent property to writes, and the inverse of authored_by, and therefore all the cases are retrieved by the query language. In this case, the answers will be ”Abiteboul”, ”Buneman”, ”Suciu”, ”Simeon”, ”Buneman” , together with names of manuscripts.
Query 2: The second query we would like to show is “Retrieve the books of topic XML” which can be expressed as Book(book), topic(book, ”XML”). Now, it can be expressed as:

? − triple(Book, rdf : type, book ),triple(Book, topic, ”XML”).

However, given that the ontology already includes the class “XMLBook” we can express the same query in a more concise way as XMLBook (book) and therefore as:

? − triple(Book, rdf : type, xmlbook )

Query 3: The third query we would like to show is “Retrieve the writers of re- viewed manuscripts”. It can be expressed as Reviewed(manuscript),Writes(au- thor, manuscript). In this case, the query can be expressed as:

? − triple(Manuscript, rdf : type, reviewed ),triple(Author, writes, Manuscript).

Query 5: Let us see an example of query for retrieving meta-data from the on- tology. For instance range ± 6Reviewed _by.domain whose meaning is “Find the domain and range of Reviewed_by” is encoded as:

? − triple(Range, rdfs : subClassOf , forall(reviewed_by, Domain)).

In this case the answers will be Manuscript, Book, Paper for Domain and
Man, Woman, Person for Range.

Conclusions and Future Work
In this paper we have proposed a query language for OWL based on Prolog. The query language is able to query about data and meta-data of a given ontology. As future work, we would like to extend our approach to richer fragments of DL and OWL.
In this line, the W3C has recently proposed a set of entailment rules for OWL, the so-called OWL RL [24]. Such set of rules subsumes our proposed entailment relationship and the pD∗ approach. Therefore, our approach can
be seen as a contribution to the OWL RL framework, providing an imple- mentation by means of Prolog rules. We believe that our approach can be extended to OWL RL following the same technique here presented.
In addition, we would like to extend our work in the line of the SWRL [21] by incorporating Prolog rules to the reasoning with OWL, and therefore for enriching the defined query language.

References
J. M. Almendros-Jiménez, A. Becerra-Terón, and Francisco J. Enciso-Baños. Magic sets for the XPath language. Journal of Universal Computer Science, 12(11):1651–1678, 2006.
J. M. Almendros-Jiménez, A. Becerra-Terón, and Francisco J. Enciso-Baños. Querying XML documents in logic programming. Theory and Practice of Logic Programming, 8(3):323–361, 2008.
J. M. Almendros-Jiménez, A. Becerra-Terón, and F. J. Enciso-Baños. Integrating XQuery and Logic Programming. In Proceedings of the 17th International Conference on Aplications of Declarative Programming and Knowledge Management, INAP’07 and 21th Workshop on (Constraint) Logic Programming, WLP’07, pages 117–135, Heidelberg, Germany, 2009. Springer LNAI, 5437.
J. M. Almendros-Jiménez. An RDF Query Language based on Logic Programming. In Proceedings of the 3rd Int’l Workshop on Automated Specification and Verification of Web Systems. Electronic Notes on Theoretical Computer Science (200), 67–85, 2008.
J. M. Almendros-Jiménez. An Encoding of XQuery in Prolog. In Procs of the Sixth International XML Database Symposium XSym’09, at VLDB’09, pages 145–155, Heidelberg, Germany, 2009. Springer, LNCS 5679.
J. M. Almendros-Jiménez. Extending XQuery for Semantic Web Reasoning. In Procs of the International Conference on Applications of Declarative Programming and Knowledge Management, INAP’09, pages 109–124, 2009.
J. M. Almendros-Jiménez. Ontology Querying and Reasoning with XQuery. In Proceedings of the PLAN-X 2009: Programming Language Techniques for XML, An ACM SIGPLAN Workshop co-located with POPL 2009. http://db.ucsd.edu/planx2009/papers.html, 2009.
F. Baader, D. Calvanese, D.L. McGuinness, P. Patel-Schneider, and D. Nardi. The description logic handbook: theory, implementation, and applications. Cambridge Univ Press, 2003.
Erol Bozsak, Marc Ehrig, Siegfried Handschuh, Andreas Hotho, Alexander Maedche, Boris Motik, et al. KAON - Towards a Large Scale Semantic Web. In E-commerce and Web technologies: Third International Conference, EC-Web 2002, pages 304–313. Springer, 2002.

Dan Brickley and R.V. Guha. RDF Vocabulary Description Language 1.0: RDF Schema. Technical report, http://www.w3.org/TR/rdf-schema/, 2004.
T. Berners-Lee, J. Hendler, O. Lassila, et al. The semantic web. Scientific american, 284(5):28– 37, 2001.
Jos de Bruijn, Rubén Lara, Axel Polleres, and Dieter Fensel. OWL DL vs. OWL flight: conceptual modeling and reasoning for the semantic Web. In WWW ’05: Proceedings of the 14th international conference on World Wide Web, pages 623–632, New York, NY, USA, 2005. ACM.
T. Eiter, G. Ianni, T. Krennwallner, and A. Polleres. Rules and ontologies for the semantic web. In Reasoning Web, pages 1–53. Springer, LNCS 5224, 2008.
Benjamin N. Grosof, Ian Horrocks, Raphael Volz, and Stefan Decker. Description Logic Programs: Combining Logic Programs with Description Logic. In Proc. of the International Conference on World Wide Web, pages 48–57, NY, USA, 2003. ACM Press.
E. Grädel, P.G. Kolaitis, and M.Y. Vardi. On the decision problem for two-variable first-order logic. Bulletin of Symbolic Logic, 3(1):53–69, 1997.
W3C Working Group. OWL 2 Ontology Web Language. Technical report, http://www.w3. org/TR/owl2-overview/, 2009.
A. Hogan, A. Harth, and A. Polleres. SAOR: Authoritative Reasoning for the Web. In Proceedings of the 3rd Asian Semantic Web Conference on The Semantic Web, pages 76–90. Springer-Verlag, 2008.
Ullrich Hustadt, Boris Motik, and Ulrike Sattler. Reasoning in Description Logics by a Reduction to Disjunctive Datalog. J. Autom. Reasoning, 39(3):351–384, 2007.
U. Hustadt, B. Motik, and U. Sattler. Deciding expressive description logics in the framework of resolution. Information and Computation, 206(5):579–601, 2008.
V. Haarslev, R. Möller, and S. Wandelt. The revival of structural subsumption in tableau-based description logic reasoners. In Proceedings of the 2008 International Workshop on Description Logics (DL2008), CEUR-WS, pages 701–706, 2008.
Ian Horrocks, Peter F. Patel-Schneider, Harold Boley, Said Tabet, Benjamin Grosof, and Mike Dean. SWRL: A Semantic Web Rule Language Combining OWL and RuleML. W3C Member Submission, 21 May 2004. Available at http://www.w3.org/Submission/SWRL/.
Graham Klyne and Jeremy J. Carroll.  Resource Description Framework (RDF): Concepts and Abstract Syntax.   Technical report, http://www.w3.org/TR/2004/ REC-rdf-concepts-20040210/, 2004.
G. Lukacsy, P. Szeredi, and B. Kadar. Prolog based description logic reasoning. In Proceedings of the 24th International Conference on Logic Programming (ICLP’08), pages 455– 469, Heidelberg,Germany, 2008. Springer, LNCS 5366.
Boris Motik, Bernardo Cuenca Grau, Ian Horrocks, Zhe Wu, Achille Fokoue, and Carsten Lutz. OWL 2 Web Ontology: Reasoning in OWL 2 RL and RDF Graphs using Rules. Technical report, http://www.w3.org/TR/owl2-profiles/#Reasoning_in_OWL_2_RL_and_RDF_Graphs_ using_Rules, 2009.
S. Munoz, J. Pérez, and C. Gutierrez. Minimal deductive systems for RDF. In Proceedings of the 4th European conference on The Semantic Web: Research and Applications, page 53, Heidelberg, Germany, 2007. Springer, LNCS 4519.
Boris Motik, Peter F. Patel-Schneider, and Bernardo Cuenca Grau.   OWL 2 Web Ontology Language Direct Semantics. Technical report, http://www.w3.org/TR/ owl2-direct-semantics/, 2009.
Michael Schneider. OWL 2 Web Ontology Language RDF-Based Semantics. Technical report,
http://www.w3.org/TR/owl2-rdf-based-semantics/, 2009.

Evren Sirin, Bijan Parsia, Bernardo C. Grau, Aditya Kalyanpur, and Yarden Katz. Pellet: A practical OWL-DL reasoner. Web Semantics: Science, Services and Agents on the World Wide Web, 5(2):51–53, June 2007.
Herman J. ter Horst. Extending the rdfs entailment lemma. In International Semantic Web Conference, pages 77–91. Springer, LNCS 3298, 2004.
D. Tsarkov and I. Horrocks. FaCT++ Description Logic Reasoner: System Description. In Proc. of the Int. Joint Conf. on Automated Reasoning (IJCAR 2006), pages 292–297. Springer, LNAI 4130, 2006.
Raphael Volz. Web Ontology Reasoning with Logic Databases. PhD thesis, Universität Fridericiana zu Karlsruhe, 2004.
J. Wielemaker, G. Schreiber, and B. J. Wielinga. Prolog-Based Infrastructure for RDF: Scalability and Performance. In International Semantic Web Conference, pages 644–658. Springer, LNCS 2870, 2003.
