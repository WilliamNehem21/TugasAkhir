

Electronic Notes in Theoretical Computer Science 265 (2010) 177–195
www.elsevier.com/locate/entcs
Fairness, Resources, and Separation
Stephen Brookes
Department of Computer Science Carnegie Mellon University Pittsburgh, USA

Abstract
Fair interleaving plays a fundamental rˆole in denotational semantic models for shared-memory parallel programs, beginning with Park’s trace semantics, based on a fairmerge relation designed so that (α, β, γ) ∈ fairmerge if and only if γ can be obtained by interleaving α and β. Park’s formulation of fairmerge used nested greatest and least fixed points of monotone functions over traces, but he remarked that fixed point induction principles seem unsuitable for proving natural algebraic properties such as associativity. Such properties are needed to validate intuitive laws of program equivalence and to support hierarchical analysis of programs. Recent models and logics for shared-memory programs with mutable state and pointers build on and extend Park’s foundations, with emphasis on resources and logical rules that embody separation principles. For example, concurrent separation logic is based on a race-detecting, resource-sensitive variant of fairmerge. For the kinds of interleaving employed in these models, and other more sophisticated variants of fairmerge, the algebraic difficulties are exacerbated. Rather than search for ad hoc techniques, we develop here a general framework for defining k-ary fairmerge operators, parameterized first by a choice of a resource model and then refined by a choice of a conflict or interference relation. Our formulation avoids nested fixed points, and supports inductive reasoning based on the length of finite prefixes of a trace. We prove a generalized associativity property, and obtain associativity proofs for prior models as a by-product.
Keywords: concurrency, shared memory, denotational semantics, fixed point induction, fairness, resources, separation logic

Introduction
Fair execution is a crucial assumption for reasoning about liveness properties of concurrent programs [18]. Indeed, fairness has played a fundamental roˆle in the de- velopment of denotational semantic models for shared-memory parallel programs, beginning with early work of Keller [14] and Park’s trace model [21]. In Park’s se- mantics the meaning of a parallel program c1  c2 is defined to be the set of all traces obtainable as a fair interleaving of a trace of c1 with a trace of c2. More formally, Park introduced a (ternary) fairmerge relation on traces, characterized as a nested combination of greatest and least fixed points of monotone functions on a cartesian product of the complete lattice of trace sets, ordered by componentwise set inclu- sion. This relation was designed so that (α, β, γ) ∈ fairmerge if and only if γ is an

1 Email: brookes@cs.cmu.edu

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.08.011

interleaving of all of α with all of β. As Park noted, fixed point induction principles do not appear suitable in attempting to establish natural algebraic properties, such as associativity of fairmerge. Such properties are needed to validate natural laws of program equivalence, such as c1  (c2  c3) = (c1  c2)  c3, as well as laws concerning the interaction between parallel composition and the scope of local declarations. Such laws help to support hierarchical analysis of networks of processes. Park derived an equivalent formula for the fairmerge relation, based on iterated concatenation, but remarked that additional (or alternative) insights were needed to prove associativity and other properties [22].
Park’s fairmerge relation serves as the foundation for much later work, for exam- ple [6,7,16]. Recent models and logics for shared-memory languages involving mu- table state and pointers also build on Park’s foundations, but emphasize resources, separation principles and race detection [4,17]. This has led to the development of semantic models that rely on resource-sensitive and race-detecting forms of fair interleaving [8,9]. Such models are vital in establishing the soundness of concur- rent separation logic [8,17]. These models, as originally presented, also suffer from algebraic problems, exacerbated by the additional technical sophistication required to deal with resource accounting and race detection. Furthermore, an associativity proof for Park’s fairmerge would not immediately imply associativity for these more sophisticated variants, and it seems wasteful to have to treat each variant on an ad hoc basis. Ideally we need a coherent tractable mathematical account of fairness that facilitates algebraic reasoning and better supports the validation of laws of program equivalence.
We address these problems here by developing an abstract and general fairness framework, parameterized by a choice of a resource model and an interference or conﬁct relation on actions, assumed to have some intuitively natural properties. A key ingredient in our approach is a generalization from Park’s 2-ary fairmerge to a uniform family of k-ary fairmerge relations with closely related properties. We avoid dealing with fixed point operators, instead working with finite prefixes of traces and supporting a style of reasoning based on induction on trace length 2 . We prove a general associativity theorem applicable to all instances of this framework. The earlier semantic models can be recast as instances of our fairness framework, so we obtain associativity proofs for these models as a by-product. The framework is robust enough to encompass resource models based on semaphores and other synchronization mechanisms, as well as models that involve permissions.

Background
We develop the main ingredients of our framework in an abstract setting, by working with an arbitrary (non-empty) “alphabet” Σ whose elements represent “actions”. We will use λ as a meta-variable ranging over Σ. Let Σ∗ be the set of finite sequences

2 Our emphasis on prefixes does not contradict the fact that fairmerge is non-monotone with respect to the prefix ordering on traces [20]. Our results do run counter to the longstanding tendency to conclude from non-monotonicity that fairness is beyond the denotational pale. Lack of monotonicity turns out to be irrelevant in our approach.

with elements from Σ, Σ+ be the set of non-empty finite sequences, and Σω be the set of (countably) infinite sequences. Let ϵ denote the empty sequence. A trace is a finite or infinite sequence of actions. Let Σ∞ = Σ∗ ∪ Σω be the set of all traces. We use α, β, γ as meta-variables ranging over Σ∞.
When α is a non-empty finite trace, let last (α) be the singleton trace consisting of the final element of α, and let last (ϵ) = ϵ. For α, β ∈ Σ∞ we let αβ denote the concatenation of α and β; when α is infinite, αβ = α. Concatenation is associative, and the empty sequence is a unit: (αβ)γ = α(βγ) and αϵ = ϵα = α.
When α ∈ Σ∞ and h : Σ → Σ, let map hα be the sequence obtained by applying h to the element occurrences in α. The function map has the usual properties: map hϵ = ϵ, map h (λα) = (h λ) (map h α), and map h (αβ) = (map h α)(map h β).
For a trace α and a subset A of Σ, we write α[A for the subsequence of α
consisting of actions from A.
Definition 2.1 For a trace α, let pre(α) be the set of finite prefixes of α, ordered by the prefix relation: α1 < α2 iff α1 is a proper prefix of α2. We also write α1 ≤ α2, and say that α1 is a prefix of α2, when α1 = α2 or α1 < α2.
Clearly, (pre(α), <) is a linear ordering, with least element ϵ; α belongs to pre(α) if and only if α is finite. We may recover α from its prefixes, by listing the members of pre(α) in prefix order and concatenating their last elements: α = map last (pre(α)). Note that if pre(α) = pre(β) then α = β.
Definition 2.2 A function f : pre(α) → pre(β) is strictly monotone if and only if
f (ϵ) = ϵ and for all α1 < α2 ∈ pre(α), f (α1) < f (α2).
For any function h : Σ → Σ it is easy to see that pre(map h α) = {map h α' | α' ∈ pre(α)}, and when α1 < α2 we also have map h α1 < map h α2. Thus map h : pre(α) → pre(map h α) is strictly monotone.
Definition 2.3 When f : pre(α) → pre(β) is strictly monotone, we define the “inverse” function f−1 : pre(β) → pre(α) such that, for all β' ∈ pre(β),
f−1(β') = max{α' ∈ pre(α) | f (α') ≤ β'}.
If f is strictly monotone, then f−1 is monotone (but not necessarily strictly mono- tone): whenever β1 ≤ β2 ∈ pre(β), f−1(β1) ≤ f−1(β2). Also note that for all α' ∈ pre(α), f−1(f (α')) = α'; and for all β' ∈ pre(β), f (f−1(β')) ≤ β'.
Using these ingredients, we can now define a family ⟨FM k | k ≥ 1⟩ of k-ary fair merge relations, with the intuitive reading that ((α1,..., αk), β) ∈ FM k iff β is an interleaving of the sequences α1,..., αk.
Definition 2.4 The k-ary fair merge relations FM k ⊆ (Σ∞)k × Σ∞, for k ≥ 1, are given by:
((α1,..., αk), β) ∈ FM k
iff there are strictly monotone functions
f1 : pre(α1) → pre(β),..., fk : pre(αk) → pre(β)

with the following properties:
For all i /= j, rge(fi) ∩ rge(fj) = {ϵ}.
pre(β) = rge(f1) ∪· · · ∪ rge(fk).
For all i and all α' ∈ pre(αi), last (fi(α')) = last (α').
We will refer to a tuple of strictly monotone functions (f1,..., fk) with the indicated types and properties as a schedule for merging α1,..., αk into β. The scheduling functions specify an interleaving of α1,..., αk that produces β, by de- scribing for each element occurrence in β, a corresponding element occurrence of one of α1 ..., αk. The constraints imposed by monotonicity and (a), (b) and (c) ensure that every element occurrence in β comes from one of α1,..., αk, each el- ement occurrence from each αi occurs in α, and the relative order of the element occurrences from each αi is preserved.
Example 2.5 Let Σ = {0, 1}.
((0ω, 1ω ), β) ∈ FM 2 if and only if β is an infinite sequence of 0’s and 1’s containing infinitely many 0’s and infinitely many 1’s. This follows easily from the definition of FM 2, since each non-empty finite prefix 0n of 0ω must generate a distinct prefix of β ending with 0, and each non-empty prefix 1m of 1ω must generate a distinct prefix of β ending with 1. In this simple example, for each such trace β there is a unique schedule.
((0ω, 0ω ), β) ∈ FM 2 if and only if β = 0ω . In this case, there are infinitely many possible schedules, since each occurrence of 0 in β can be chosen either from the first input sequence or the second; each choice of schedule produces the same result trace.
((0ω, 1), 0ω ) does not belong to FM 2, since 0ω has no prefix ending with 1, so there is no way to define a scheduling function from pre(1) to pre(0ω ).
Next we identify some obvious properties of the family ⟨FM k | k > 0⟩ of re- lations. Informally, we can summarize by saying that fairmerge is invariant under permutation of the “input” traces and invariant under map. Moreover, the empty trace makes no contribution in fair merges. We also isolate a pair of properties that express a natural connection between fair merging and the concatenation operation on traces.
Lemma 2.6 The relations FM k satisfy the following properties:
If ((α1,..., αk), β) ∈ FM k and π : {1,..., k}→ {1,..., k} is a permutation, then ((απ1,..., απk), β) ∈ FM k.
If h : Σ → Σ and ((α1,..., αk), β) ∈ FM k,
then ((map h α1,..., map h αk), map h β) ∈ FM k.
Proof. (i) is obvious. For (ii), if (f1,..., fk) is a schedule for ((α1,..., αk), β) we can define a schedule (g1,..., gk) for ((map h α1,..., map h αk), map h β) by letting gi(map h α') = map h (fi(α')), for 1 ≤ i ≤ k and α' ∈ pre(αi).	2

Lemma 2.7 The empty sequence plays a trivial role in merges.
((ϵ, α1,..., αk), β) ∈ FM k+1 iff ((α1,..., αk), β) ∈ FM k.
((α1,..., αk), ϵ) ∈ FM k if and only if each αi is ϵ.
Proof. These results follow trivially from the fact that pre(ϵ) = {ϵ}.	2
Theorem 2.8 The k-ary fairmerge relations FM k, for k ≥ 1, satisfy the following “preﬁx/suffix” and “concatenation” properties:
If ((α1,..., αk), β) ∈ FM k, β' ∈ pre(β) and β = β'β'', then there are

preﬁxes α' ∈ pre(α1),..., α' ∈ pre(αk), with suffixes α'',..., α''
such that

1	k	1	k
α1  =  α' α'',..., αk	=  α' α'', for which ((α' ,..., α' ), β')  ∈  FM k  and
1 1	k  k	1	k
((α'',..., α''), β'') ∈ FM k.
1	k
If ((α' ,..., α' ), β') ∈ FM k, ((α'',..., α''), β'') ∈ FM k, and β' is ﬁnite, then
1	k	1	k
((α' α'',..., αkα''), β'β'') ∈ FM k.
1 1	k
Proof. For (i), suppose (f1,..., fk) is a schedule for ((α1,..., αk), β) and let
β = β'β'', with β' finite.	If β' = β (so β'' = ϵ) we can take α' = αi and
'' = ϵ for i = 1,...,k and the result holds trivially by Lemma 2.7.	Other-
wise, let i be the (unique) index such that β' ∈ rge(fi), and let α' = f−1(β')
for j = 1,..., k. Then fi(α') = β' and for j /= i we have fj(α' ) < β'. The restric-
i	j
tions of f1,..., fk to pre(α' ),..., pre(α' ) form a schedule for ((α' ,..., α' ), β'), so
1	k	1	k
((α' ,..., α' ), β') ∈ FM k. Let α'',..., α'' and β'' be the suffixes corresponding to
1	k	1	k
α' ,..., α' and β', so that α1 = α' α'',..., αk = α' α'', and β = β'β''. The functions
1	k	1 1	k  k
g1 : pre(α'') → pre(β''),..., gk : pre(α'') → pre(β'') such that gj(α'') = fj(α' α''),
1	k	j
for each j and each α'' ∈ pre(α''), are well defined, strictly monotone, and sat-
isfy conditions (a), (b) and (c). So (g1,..., gk) is a schedule for ((α'',..., α''), β''),
1	k
showing that ((α'',..., α''), β'') ∈ FM k, as required.
1	k
For (ii), suppose β' is finite, (f1,..., fk) is a schedule for ((α' ,..., α' ), β'),

and (g1,..., gk) is a schedule for ((α'',..., α''), β'').  Then each α'
1	k
is finite, and

1	k	i
we can define functions hi : pre(α'α'') → pre(β'β'') by: hi(α') = fi(α') when
i  i
α' ≤ α', hi(α'α'') = gi(α'') when α'' ∈ pre(α''). These functions are well defined,
i	i	i
strictly monotone, and satisfy (a), (b) and (c).  So (h1,..., hk) is a schedule for
((α' α'',..., α' α''), β'β''), as required.	2
1 1	k  k
The next two results show that for k = 1 and k = 2 our definition yields the intended fairmerge relation at the corresponding arity: unary fairmerge FM 1 is the identity relation on traces, and binary fairmerge FM 2 is the same as Park’s fairmerge.
Theorem 2.9 FM 1 = {((α), α) | α ∈ Σ∞}.
Proof.	3 : Clearly the identity function on pre(α) is a schedule for ((α), α). So
{((α), α) | α ∈ Σ∞} ⊆ FM 1. For the converse, note that if ((α), β) ∈ FM 1 and
f : pre(α) → pre(β) is strictly monotone, rge(f ) = pre(β), and for all α' ∈ pre(α),

3 Perhaps pedantically, we distinguish notationally between a 1-tuple (α) and a trace α.

last (f (α')) = last (α'), it is easy to prove by induction on the length of α' that
f (α') = α'. It follows that β = α.	2
Theorem 2.10 FM 2 coincides with Park’s fairmerge relation.
Proof. Park’s relation fairmerge ⊆ Σ∞ × Σ∞ × Σ∞ can be characterized as fol- lows [22]. First extend the concatenation operation αβ on traces to triples of traces, componentwise: (α1, α2, α3)(β1, β2, β3) = (α1β1, α2β2, α3β3); then extend, point- wise, to sets of triples. For a set of triples T , let T 0 = {(ϵ, ϵ, ϵ)}, Tn+1 = TnT for
n ≥ 0, and T∗ = S∞  Tn. Then T∗ satisfies the following equation:
T∗ = {(α1 ... αn, β1 ... βn, γ1 ... γn) | ∃n ≥ 0. ∀i.1 ≤ i ≤ n ⇒ (αi, βi, γi) ∈ T}.
If every triple in T has non-empty components, i.e. whenever (α, β, γ) ∈ T we have
α /= ϵ, β /= ϵ and γ /= ϵ, we can define
Tω = {(α1 ... αn ..., β1 ... βn ..., γ1 ... γn .. .) | ∀i ≥ 0. (αi, βi, γi) ∈ T}.
(The non-emptiness constraint on T means we avoid the degenerate term ϵω.) Let A, B, C ⊆ Σ∞ × Σ∞ × Σ∞ be given by:
A = {(α, ϵ, α) | α ∈ Σ∞}∪ {(ϵ, β, β) | β ∈ Σ∞}
B = {(λ, ϵ, λ) | λ ∈ Σ}	C = {(ϵ, λ, λ) | λ ∈ Σ}.
As shown by Park, fairmerge = (B ∪ C)∗A ∪ (B∗CC∗B)ω. (Note that every triple (α, β, γ) ∈ B∗CC∗B has non-empty components, so the infinite iteration used here is well defined.)
We argue that ((α, β), γ) ∈ FM 2 iff (α, β, γ) ∈ fairmerge, as follows.
Suppose ((α, β), γ) ∈ FM 2. Let f : pre(α) → pre(γ),g : pre(β) → pre(γ) form a schedule for ((α, β), γ). It is easy to show that if at least one of rge(f ) and rge(g) is finite then (α, β, γ) ∈ (B ∪ C)∗A, and if both rge(f ) and rge(g) are infinite, then (α, β, γ) ∈ (B∗CC∗B)ω . Thus (α, β, γ) ∈ fairmerge, as required.
Conversely, if (α, β, γ) ∈ fairmerge we can construct a schedule (f, g) for ((α, β), γ), showing that ((α, β), γ) ∈ FM 2. The details are straightforward.    2
We now come to the crucial result concerning associativity, expressed in a suit- ably generalized manner to deal with k-ary merges. We use notation such as α to denote a k-tuple of traces, relying on the context to specify the intended value of
k. When α1,..., αn are tuples of length k1,..., kn, we write α1   αn for the tuple
of length k1 + ··· + kn obtained by concatenating and flattening, so for instance (α, β)(γ, δ) = (α, β, γ, δ).
Theorem 2.11 The relations FM k have the following “general associativity” prop- erties.
If (α1, β1) ∈ FM k1 ,..., (αn, βn) ∈ FM kn and ((β1,..., βn), γ) ∈ FM n, then
(α1   αn, γ) ∈ FM k1+  +kn .

If (α1 ... αn, γ) ∈ FM k1+···+kn and for each i, len(αi) = ki, then there exist β1,..., βn such that (α1, β1)	∈  FM k1 ,..., (αn, βn)	∈ FM kn and

((β1,..., βn), γ) ∈ FM n.
Proof. For (i), suppose that (α1, β1) ∈ FM k1 ,..., (αn, βn) ∈ FM kn and ((β1,..., βn), γ) ∈ FM n. Let f1 = (f11,..., f1k1 ) be a schedule for (α1, β1), and let f2,..., fn be schedules for (α2, β),..., (αn, βn) respectively, with similar notations fij for the component functions. Let (g1,..., gn) be a schedule for ((β1,..., βn), γ). Then define Fij = gi ◦ fij, for 1 ≤ i ≤ n and 1 ≤ j ≤ ki, and let Fi = (Fi1,..., Fiki ). The functions Fij : pre(αij) → pre(γ) are strictly monotone and satisfy the intended
properties (a), (b) and (c), since the fij and gi have the analogous properties. Thus
F1 ... Fn is a schedule for (α1 ... αn, γ), and (α1 ... αn, γ) ∈ FM k1+···+kn .
For (ii), suppose (α1 ... αn, γ) ∈ FM k1+···+kn and for each i, len(αi) = ki. Let
F1 ... Fn be a schedule for (α1 ... αn, γ), where for 1 ≤ i ≤ n each Fi has the
form (Fi1,..., Fiki ), and for 1 ≤ j ≤ ki, each Fij is a strictly monotone function
from pre(αij) to pre(γ).  Let rge(Fi) be an abbreviation for Ski  rge(Fij).  For
1 ≤ i ≤ n let βi = map last (pre(γ)[rge(Fi)), where pre(γ)[rge(Fi) denotes the set
of finite prefixes of γ that belong to the range of one of the scheduling functions Fi1,..., Fiki , enumerated in prefix order. Then for each i we have (αi, βi) ∈ FM ki , using Fi as a schedule. Moreover, we can obtain a schedule for ((β1,..., βn), γ) by defining for 1 ≤ i ≤ n the functions gi : pre(βi) → pre(γ) so that when β' ∈ pre(βi), gi(β') = Fij(α'), where j is the unique index and α' ∈ pre(αij) is the unique prefix
such that β' = map last (pre(Fij(α'))[rge(Fi)). The relevant existence properties, uniqueness, strict monotonicity, and properties (a), (b) and (c) follow from the assumed properties of the Fij and the definition of the traces βi.	2
Corollary 2.12 Park’s fairmerge is associative.
Proof. If ((α1, α2), β) ∈ FM 2 and ((β, α3), γ) ∈ FM 2 then by the previous result, ((α1, α2, α3), γ) ∈ FM 3. Hence there is a δ such that ((α2, α3), δ) ∈ FM 2 and ((α1, δ), γ) ∈ FM 2. The converse argument is similar. Since FM 2 coincides with Park’s fairmerge, the result follows.	2
It seems more difficult to find a direct proof of associativity using Park’s original fixed point formulation of fairmerge, or even from the derived formula for fairmerge based on iterated concatenation [21]. Furthermore, an attempt to generalize Park’s fixed point recipe to produce a fixed point characterization of k-ary fairmerge (per- haps using Bekic’s Theorem on iterated fixed points [2]) seems unlikely to yield the right algebraic insights; and it seems more difficult still to characterize k-ary fairmerge using iterated concatenation in a tractable manner, because of the ob- vious combinatorial explosion. Instead our approach shows the benefits of dealing explicitly with scheduling functions, which give a more intensional prefix-by-prefix account of the way the interleaving is built up from the component traces.
We have also proven a number of general results such as Lemma 2.6, Lemma 2.7, and Theorem 2.8, from which analogous results for Park’s fairmerge can be deduced. While the analogues of Lemma 2.6 and Lemma 2.7 are easy to prove directly in Park’s setting, the prefix/suffix properties (Theorem 2.8) are not so straightforward there.

Park’s work has served as foundation for many denotational models of concurrent programs, each employing some form of “fair merge” on traces of some kind. The choice of “alphabet” Σ and the kind of interleaving may vary, but the underlying ideas have much in common with the general setting outlined above. For example, in Park’s traces the steps are pairs of (global) states representing the effect of a single atomic action, so that Σ = S × S, where S is the set of states; in the transition traces model [6] each step represents the effect of a finite sequence of atomic actions, and trace sets are closed under stuttering and mumbling. In action traces semantic models such as [7] actions include reads i=v and writes i:=v to program variables, and the effect of actions on the underlying state is handled separately.

3	Resources and separation
Recent models and logics for shared-memory languages involving mutable state and pointers emphasize resources and separation principles [17], and rely on resource- sensitive forms of fair interleaving [8]. The tasks of defining a suitable fairmerge relation and establishing associativity and other natural properties are exacerbated by the need to account for resources.
Next we introduce a simple model of resources, phrased in abstract terms and with intuitive axioms along lines suggested by [11]. (A resource model corresponds to a separation algebra in [11].) We extend our framework to incorporate resources, defining a family ⟨RFM k | k > 0⟩ of resource-sensitive fairmerge relations that em- body resource separation: at all stages, the resources “owned” by parallel processes are “compatible”. We can recast the prior resource-sensitive models as instances of this framework.
We will assume that resources belong to a set M that is equipped with a partial binary operation ⊕, and we say that m1, m2 in M are compatible iff m1 ⊕ m2 is defined. We also assume that M contains a “zero” element 0, intuitively represent- ing “no resources”. When e1, e2 are meta-language expressions involving partial operations we write e1  e2 to mean that e1 and e2 are either both undefined, or both defined and equal.
Definition 3.1 A resource model is a partial commutative cancellative monoid (M, ⊕, 0), with ⊕ : M × M ~ M and 0 ∈ M , satisfying:
m1 ⊕ m2  m2 ⊕ m1
m1 ⊕ (m2 ⊕ m3)  (m1 ⊕ m2) ⊕ m3
m ⊕ m1 = m ⊕ m2 ⇒ m1 = m2
m ⊕ 0 = 0 ⊕ m = m.
Example 3.2 The following are examples of resource models.
The trivial model: the set {0}, with 0 ⊕ 0 = 0.
The resource sets model: M = Pfin (R), where R is a set of resource names, ⊕
is disjoint union, and 0 = {}.

The local states model: Let M = Ide ~fin V be a set of states, where Ide is the set of identifiers and V is a set of denotable values. Define ⊕ : M ×M ~ M by: s1 ⊕ s2 = s1 ∪ s2 iff dom(s1) ∩ dom(s2) = {}, and let 0 be the empty state.

The reader may consult [11] for further examples of resource models and their utility in formalizing intuitive notions of separation.
The ability of a process to perform actions depends on the resources being held by the process and also on the resources being held by the “environment”, i.e. by other processes assumed to be running concurrently; when an action occurs it may
affect the resources being held by the process. To describe the interplay between resources and actions abstractly we introduce a notion of resource enabling, an infix
relation of form m ▶ m1 −→λ m' , interpreted as saying that a process with resources
m1, in an environment with resources m, can do λ and then have resources m' . The
enabling relation is assumed to satisfy some intuitively natural axioms that ensure separation and frame properties: process and environment resources stay separate, extra process resources are preserved, and extra environment resources that do not
disable an action have no effect on process resources.
Definition 3.3 Given a resource model (M, ⊕, 0), and a set of actions Σ, an en- abling relation is a subset ▶ ⊆ M × (M × Σ × M ) with the following properties,
expressed using infix notation: when (m, (m1, λ, m' )) ∈ → we write m ▶ m1 −→λ m' .

If m ▶ m1 −→λ
' then m ⊕ m1 and m ⊕ m'
are defined.

If m ▶ m1 −→λ
If m ▶ m1 −→λ
' and m ▶ m1 ⊕ m2 −→λ
' and m ⊕ m2 ▶ m1 −→λ
m' then m' = m' ⊕ m2. m', then m' = m' .

If m ⊕ m2 ▶ m1 −→λ
' then m ▶ m1 −→λ
m' .

Definition 3.4 We extend enabling inductively, to finite sequences of actions. When m ⊕ m1 is defined, and λ ∈ Σ,α ∈ Σ∗:

m ▶ m1 −→є
m ▶ m1 −λ−→α
m1.
m' if m ▶ m1 −→λ m' and m ▶ m' −→α m' , for some m'

∈ M .

2	1	1	2	1
Enabling in an environment with resources 0 is a special case corresponding intuitively to execution without competition for resources.  We say that a finite

trace α is executable from m if and only if there is an m' such that 0 ▶ m
−→α
m'.

These notions extend to infinite traces in the obvious way. Finally, we say that a trace α is simply executable if it is executable from 0.
Example 3.5 Let M = {0} be the trivial resource model. For any set Σ we can

define a trivial enabling relation such that 0 ▶ 0 −→λ
combination of data, every trace is executable.
0 holds for all λ ∈ Σ. For this

Example 3.6 Let Σ = Δ ∪ {acq (r), rel (r) | r ∈ R} and M = Pfin (R) be the resource sets model. Define the relation ▶ as follows: whenever A, B ⊆fin R and

A ∩ B = {},


B ▶ A −−−−−→ A ∪ {r}	if r ∈/ A ∪ B
rel (r)

B ▶ A −−−−−→ A − {r}	if r ∈ A
B ▶ A −→λ  A	if λ ∈ Δ.
This is indeed an enabling relation, and the rules enforce mutual exclusion: each resource name r can be acquired by at most one process, after which other processes trying to acquire r must wait until its release. Traces in which the acquires and releases for named resources alternate, constrained by mutual exclusion, are com- mon in semantic clauses for synchronization constructs such as conditional critical regions [7,8]. With this enabling relation, a trace α is executable if and only if for each r ∈ R the sequence α[{acq (r), rel (r)} is a prefix of (acq (r) rel (r))ω , so at each stage during the execution of the trace, each resource r is “owned” by at most one process.
Given a resource model M and enabling relation ▶ based on Σ and M , we will define a family of “resource-sensitive” fairmerge functions
RFM k : Mk → P((Σ∞)k × Σ∞)
as follows. The idea is that when ((α1,..., αk), β) ∈ RFM k(m1,..., mk) there is a schedule for merging α1,..., αk and producing β, that assumes that for each i the process executing trace αi initially holds resources mi; at each stage the process taking the next step is enabled by its current resources, and not disabled by the resources of the remaining processes; and the resources held by the processes remain compatible. When these conditions hold we say that β is a resource-sensitive fair merge of traces (α1,..., αk) from the initial resource allocation (m1,..., mk).
We represent RFM k as a function from Mk to subsets of (Σ∞)k × Σ∞. The set RFM k(m1,..., mk) will be empty if m1,..., mk are incompatible or at some point there is no way to maintain resource compatibility. We may refer to the set RFM k(m1,..., mk) ⊆ (Σ∞)k × Σ∞ as the (resource-sensitive) k-ary fairmerge relation with initial resources (m1,..., mk).
Definition 3.7 For each k ≥ 1 the resource-sensitive fairmerge function
RFM k : Mk → P((Σ∞)k × Σ∞)

is given by:
((α1,..., αk), β) ∈ RFM k(m1,..., mk)
iff there are strictly monotone functions
f1 : pre(α1) → pre(β),..., fk : pre(αk) → pre(β) and a function res : pre(β) → Mk, satisfying the following properties:
For all i /= j, rge(fi) ∩ rge(fj) = {ϵ}.

pre(β) = rge(f1) ∪· · · ∪ rge(fk).
For all i and all α' ∈ pre(αi), last (fi(α')) = last (α').
res(ϵ) = (m1,..., mk), and for all β' ∈ pre(β), if res(β') = (m' ,..., m' ) then

m' ⊕· · · ⊕ m'
1	k
is defined.

1	k
For all i and all β' and λ, if fi(α'λ) = β'λ, res(β') = (m' ,..., m' ), and
1	k
res(β'λ) = (m'',..., m''), then m ▶ m' −→λ m'', where for all j /= i, m'' = m' ,
1	k	i	i	j	j
and m = ⊕{mj | 1 ≤ j ≤ k & j /= i}.
In (e) we may also use the abbreviation ⊕j/=imj for m; when k = 1 the for- mula for m degenerates to 0. Condition (d) ensures the desired property that RFM k(m1,..., mk) is empty when m1,..., mk are incompatible.
Intuitively, when β is a resource-sensitive fair merge of (α1,..., αk) from (m1,..., mk), β is a fair merge of (α1,..., αk) as before, and at each stage of the merge there is a compatible assignment of resources to processes, such that the process making the next step has enough resource to enable that step, given the resources of the other processes. The scheduling functions f1,..., fk, together with the initial constraint res(ϵ) = (m1,..., mk), and the enabling relation, determine res(β') for all β' ∈ pre(β), by induction on trace length.
Theorem 3.8 For all m ∈ M, RFM 1(m) = {((α), α) | α executable from m}.
Proof. Follows directly from the definitions.	2
Theorem 3.9 For the trivial resource model (Example 3.5), RFM k(0,.	, 0) coin-
cides with FM k.
Proof. In this case let res(β') = (0,..., 0) for all β' ∈ pre(β). (Indeed, this is the only way to define a resource mapping here.) Then (d) and (e) are vacuous. Conditions (a), (b) and (c) for RFM k are exactly as in FM k.	2
Theorem 3.10 For the resource sets model (Example 3.6), when A ∩ B = {} and
γ ∈ Σ∞, ((α, β), γ) ∈ RFM 2(A, B) iff γ ∈ αA  Bβ as deﬁned in [8]. 4
Proof. The definition of ·A  B· in [8] uses a resourceful “enabling” relation of form

A −−→λ
A', which coincides exactly with B ▶ A
−→λ
A' as formulated here.	If

((α, β), γ) ∈ RFM 2(A, B) use the schedule and resource assignment to show that γ ∈ αA  Bβ. If γ ∈ αA  Bβ use the Axiom of Choice to derive a schedule and resource assignment for ((α, β), γ).	2
Theorem 3.10 shows that for the resource sets model Pfin (R), the associated resource-sensitive fairmerge operation RFM 2 maintains the intended mutual ex- clusion property for each named resource. For example, the only fairmerges of α = acq (r) λ1λ2 rel (r) and β = acq (r) λ rel (r) are αβ and βα.
The analogue of 2.8 needs to be phrased carefully to account for resources.
4 The proviso that γ ∈ Σ∞ here restricts to the abort-free subset of the trace model from [8], reflecting the fact that RFM deals with resources but not yet race detection. This mismatch will be repaired in Theorem 4.6 of the next section.

Theorem 3.11 The functions RFM k have the following resource-sensitive “pre- ﬁx/suffix” and “concatenation” properties:
Let ((α1,..., αk), β) ∈ RFM k(m1,..., mk), and let res : pre(β) → Mk be the associated resource mapping. If β' ∈ pre(β) and β = β'β'', then there
are preﬁxes α' ∈ pre(α1),..., α' ∈ pre(αk), and suffixes α'',..., α'', such
1	k	1	k
that α1 = α' α'',..., αk = α' α'', ((α' ,..., α' ), β') ∈ RFM k(m1,..., mk) and
1 1	k  k	1	k
((α'',..., α''), β'') ∈ RFM k(m' ,..., m' ), where (m' ,..., m' ) = res(β').
1	k	1	k	1	k
Suppose ((α' ,..., α' ), β') ∈ RFM k(m1,..., mk), with resource mapping res :
1	k
pre(β') → Mk, and suppose β' is ﬁnite.	Let res(β') = (m' ,..., m' ).
1	k
If ((α'',..., α''), β'') ∈  RFM k(m' ,..., m' ), then ((α' α'',..., αkα''), β'β'') ∈
1	k	1	k	1 1	k
RFM k(m1,..., mk).
Proof. Adapt the proof of Theorem 2.8 to incorporate resource accounting. For
the assumptions, and the properties built into Definition 3.7, allow us to use res
to construct resource mappings for the prefix merge and for the suffix merge. For
the assumptions ensure that it is possible to combine the resource mappings	 from the prefix merges and the suffix merges, to obtain a resource mapping for	 ((α' α'',..., α' α''), β'β'').	2
1 1	k  k
We also have the appropriate analogue of Theorem 2.11, adapted to deal with resources. We use abbreviations such as m = (m1,..., mk) for k-tuples of resources, and ⊕m for the combination m1 ⊕· · · ⊕ mk.
Theorem 3.12 The functions RFM n satisfy the following resource-sensitive “gen- eral associativity” properties:
If (α1, β1) ∈ RFM k1 (m1),..., (αn, βn) ∈ RFM kn (mn),
and ((β1,..., βn), γ) ∈ RFM n(⊕m1,..., ⊕mn),
then (α1 ... αn, γ) ∈ RFM k1+···+kn (m1 ... mn).
If (α1 ... αn, γ) ∈ RFM k1+···+kn (m1 ... mn) and len(αi) = len(mi) = ki for
1 ≤ i ≤ n, then there are traces β1,..., βn such that
(α1, β1) ∈ RFM k1 (m1),..., (αn, βn) ∈ RFM kn (mn) and
((β1,..., βn), γ) ∈ RFM n(⊕m1,..., ⊕mn).
Proof. Adapt the proof of Theorem 2.11 to include resource assignment. The assumptions in (i) and (ii), and properties of M and the enabling relation, are crucial in ensuring that the resource accounting from the subsidiary merges can be dovetailed together properly. In particular, in (i) the components of m1 ... mn are compatible because m1,... mn are compatible by assumption.	2

4	Race detection
So far we have avoided explicitly dealing semantically with race conditions, such as an attempt by one process to write to a piece of state being used concurrently by another process. This avoidance is typical of early semantic accounts of shared- memory programs, which assume that assignments and expression evaluations are

executed atomically (as in Park [21]), or that reads and writes to shared variables are atomic (as in [7]). Yet race conditions may lead to unpredictable program behavior and dependence on hardware implementation details beyond the control or knowledge of the programmer.
More recent models incorporate race detection, and treat a potential race as a disaster [8,9]. We now expand our framework in an analogous manner. This expansion meshes well with a subtle gap in the formulation given above of the
resource-sensitive fairmerge relations.  The definition of RFM k does not specify
what to do when we reach a stage in which two processes, with resources mi and mj, have next actions λi and λj such that each process’s resource disables the other process’s action. Phrased in terms of our enabling relation, this arises when

mi ⊕ mj is defined but there are no m'
and m'
such that mj ▶ mi
−−λ→i
' and

λj	'
mi ▶ mj −−→ mj . When this happens condition (e) in the merge definition will be impossible to fulfill. Even when this situation does not hold, there may be pairs of actions, such as two writes to the same variable or heap cell, that we wish to treat as a disaster. We can easily adapt the prior framework to deal with such problems, by introducing an action abort to represent runtime error, and a conflict (or interference) relation on pairs of actions, and extending the merge construction
so that a potential conflict produces a trace ending with abort. We assume some
intuitive axioms that link conflict and the enabling relation.
We extend Σ with a special action abort used to represent error. Let Σˆ = Σ ∪
{abort}. We will treat abort as a zero for concatenation on the right: abortβ = abort . Let Σˆ∞ = Σ∞ ∪ Σ∗abort.
Definition 4.1 Given a set of actions Σ, a resource model (M, ⊕, 0), and an en- abling relation ▶, a conflict relation is a subset dα ⊆ Σˆ × Σˆ, written as an infix operator, such that:
If λ1 dα λ2 then λ2 dα λ1.
λ dα abort holds for all λ ∈ Σˆ.
Obviously there is always a “minimal” conflict relation for a given choice of resource model and enabling relation, characterized as the least subset dα satisfying (i), and (ii). But our definition allows more generality, as shown in the following examples.
Example 4.2 The trivial conflict relation (for the trivial resource model and the trivial enabling relation) is dα = {(abort, λ), (λ, abort ) | λ ∈ Σˆ}.
Example 4.3 Let Σ = Δ∪{acq (r), rel (r)} as in Example 3.6 and let Δ ⊆ Σ include store and heap actions, as in [8]. We can define a conflict relation dα in which a write conflicts with all actions involving the same variable or heap cell, exactly as in [8], so that a concurrent write to a variable or heap cell being either read or written is regarded as a conflict. We can also define a larger conflict relation dα' ⊇ dα by throwing in all pairs of actions that read the same variable or heap cell, if we want to regard concurrent reads as conflicting.

We can now extend the definition of RFM k to deal with conflict.
Definition 4.4 Let Σ be a set of actions, let M be a resource model, and let dα be a conflict relation for M and Σ. The conflict-sensitive fair merge functions R^FM k : Mk → P((Σˆ∞)k × Σˆ∞) are given by:
((α1,..., αk), β) ∈ R^FM k(m1,..., mk)
iff either β ∈ Σ∞ and ((α1,..., αk), β) ∈ RFM k(m1,..., mk), or β = β' abort and

there are finite prefixes α'
∈ pre(α1),..., α'
∈ pre(αk), indices i /= j, and actions

λi, λj, such that
((α' ,..., α' ), β') ∈ RFM k(m1,..., mk)
1	k
α'λi ∈ pre(αi), α' λj ∈ pre(αj), and λi dα λj.
i	j
It is possible to augment the earlier proofs to show that the family of R^F  Mk functions enjoy the same prefix/suffix and concatenation properties as the RFM k functions, although we omit the details for space reasons.
Theorem 4.5 For the trivial resource model, trivial enabling relation, and triv-

ial conflict relation, the restriction of RFM k(0,..., 0) and hence with FM k.
R^FM k(0,..., 0) to (Σ∞)k coincides with

Proof. the actions λi and λj in (b) are drawn from traces appearing in RFM k, so belong to Σ. Hence λi dα λj is always false here.	2
As promised in 3.10 we recover the race-detecting, resource-sensitive model of concurrent separation logic [8] as an instance of our framework.
Theorem 4.6 For the resource sets model (Example 4.3), when A ∩ B = {}, ((α, β), γ) ∈ R^FM  k(A, B) iff γ ∈ αA  Bβ, where ·A  B· is the race-detecting resource- sensitive fair merge used in the semantics of concurrent separation logic [8]. In particular, ((α, β), γ) ∈ R^FM 2({}, {}) iff γ ∈ α{}  {}β.
Proof. Adapt the proof of Theorem 3.10. The key point is that when λ1 dα λ2, α'λ1 ≤ α, β'λ2 ≤ β, and γ' ∈ α'A  Bβ', the fairmerge from [8] has γ'abort ∈ αA  Bβ, matching the race-detection clause of Definition 4.4.	2
Again we obtain general associativity.
Theorem 4.7 The functions R^FM n satisfy:
If (α1, β1) ∈ R^FM k1 (m1),.	, (αn, βn) ∈ R^FM kn (mn),
and ((β1,..., βn), γ) ∈ R^FM n(⊕m1,.	, ⊕mn),
then (α1 ... αn, γ) ∈ R^FM k1+···+kn (m1	mn).
If (α1 ... αn, γ) ∈ R^FM k1+···+kn (m1 ... mn, ) and len(αi) = len(mi) = ki for
1 ≤ i ≤ n, then there are traces β1,..., βn such that
(α1, β1) ∈ R^FM k1 (m1, ),.	, (αn, βn) ∈ R^FM kn (mn, ) and
((β1,..., βn), γ) ∈ R^FM n(⊕m1,.	, ⊕mn).

Proof. Follows from the general associativity of the RFM k family, and the assumed properties of dα. The prefix/suffix property of RFM k is also relevant in the error case.	2
Related work
We developed a framework for defining fairmerge relations, parameterized by a choice of resource model, enabling, and conflict relation. General theorems appli- cable to all instances of this framework yield uniform proofs of natural properties of some prior semantic models. Our fairness framework is deliberately agnostic as to the choice of “alphabet” Σ, and is sufficiently general to encompass traditional Park-style traces whose steps are pairs of states [6,21], as well as traces built from symbolic “actions” whose effect on the state is handled implicitly [7,8]. Indeed, by keeping the alphabet abstract and working with resource algebras we come closer in spirit to the general approach of [11], which also avoids explicit choices as to the concrete representation of “state”.
There is an extensive literature concerning various alternative notions of fair interleaving, characterized in different settings, notably earlier definitions based on automata and oracles [14,15,16,19,22] and a significant collection of work using traces of some kind [10,12,24,26]. A major aim in much of this prior work was to generalize the Kahn Principle [13] to dataflow networks containing non-deterministic processes [1]. A number of strikingly original and surprising results have been obtained concerning the relative expressive power of various variant forms of fair merge in dataflow networks [19,20]. Since fairness is a key factor in the semantics of concurrent programs, it is not surprising that the concepts, and some of the technical details, made explicit in our approach may have implicit or explicit roots in prior literature. However, our development shows how to spell out the details carefully in a general setting, avoiding the use of book-keeping machinery such as oracles, and avoiding the need to tag and untag actions with channel labels that typically appears in dataflow semantics. Moreover, unlike most of the earlier work, our formulation permits straightforward derivation of natural algebraic properties such as associativity.
Perhaps the most closely related work to ours is a technical report by Shanbhogue [25], which uses a trace semantics for dataflow networks based on events of form (h, v), where h is a channel name and v is a data value, and defines the trace set of a multiway fair merge process with input channels i1,.  , im and output
o to consist of all sequences α ∈ ({i1,.  , im, o}× V )∞ such that there is a function
f : N → {1,..., m} mapping the positional indices of the output events in α to input channel indices, satisfying certain natural constraints. Intuitively, for all n the data value of the nth output in α is obtained from an earlier input in α from channel if (n), and the relative order of data along each input channel is preserved
in the output subsequence. Let F (i1,..., im; o) denote this trace set, augmenting
Shanbhogue’s notation with explicit indication of the channel names involved in the construction.

Note that Shanbhogue regards fair merge (with respect to a given list of channel names) as a process and accordingly describes it as a trace set, whereas we treat fair merge as a semantic operation to be used to construct the trace set of a par- allel program from the traces of its constituent processes. Moreover, the indexing function f in Shanbhogue’s formulation operates in positional indices and serves a very different purpose from the scheduling functions that appear in the definition of FM . Our formulation, based on prefixes, avoids tags and index manipulation. Shanbhogue’s construction is limited to the dataflow setting, and it is not obvious how to generalize it to incorporate resources and race detection. Although his paper is not concerned with algebraic properties such as prefix/suffix and concatenation (Theorem 2.8), he did prove [25] that in any dataflow network built from determin- istic processes and multiway fair merge processes, every subnetwork built entirely from two-way merges can be replaced by a network containing a single multiway merge (together with some deterministic processes designed to perform some simple tagging and untagging of data); and that a multiway merge can be replaced by a cascade of two-way merge processes. Ignoring the dataflow trappings, these results look very similar in form to our general associativity theorem (Theorem 2.11), but again it is not so simple to adapt the dataflow proof from [25] to a more general setting. Indeed, our Theorem 2.11 cannot easily be derived in its full generality from Shanbhogue’s results.
A concrete connection between our work and Shanbhogue’s can be made in the following manner. Suppose α ∈ F (i1,..., im; o), using index function f : N →
{1,..., m}, according to Shanbhogue’s construction. For each j such that 1 ≤ j ≤ m, let αj be the subsequence of α containing the input events on channel ij and the output events whose indices map via f to j. Then ((α1,..., αm), α) ∈ FM m
according to our construction, the choice of relevant scheduling functions being obvious. Conversely, suppose for each j we have traces αj ∈ ({ij, o}× V )∞, such that data(αj[o) = data(αj[ij), and for every prefix β of αj, data(β[o) is a prefix of data(β[ij). (We write data(α) for the sequence of data values contained in the events of α.) If ((α1,..., αm), α) ∈ FM m according to our definition, using scheduling functions (f1,..., fm), we will also have α ∈ F (i1,..., im; o) according to Shanbhogue’s definition, the index function f being easy to derive from the fi.
To illustrate this connection, let α be the trace ((i1, 0)(i2, 1)(o, 0)(o, 1))ω and let β be the trace ((i1, 0)(i1, 0)(i2, 1)(o, 0)(o, 1))ω . Each trace belongs to F (i1, i2; o), both relying on the same indexing function f (n) = n mod 2 + 1, using 0 as the index for the first event in a trace. Corresponding to (α, f ) we have that (((i1, 0)(o, 0))ω, ((i2, 1)(o, 1))ω ), α) ∈ FM 2, and corresponding to β we have that
(((i1, 0)(i1, 0)(o, 0))ω, ((i1, 1)(o, 1))ω ), β) ∈ FM 2.
In fact, we can express the dataflow process F (i1,..., im; o) very simply in terms of FM as a fair parallel combination of “unbounded buffer” processes, defined as follows. When i and o are distinct channel names, let buf (i, o) be the trace set given

by
buf (i, o) = {α ∈ ({i, o}× V )∞ | data(α[o) = data(α[i) & 
∀α' ∈ pre(α). data(α'[o) ≤ data(α[i)}
It follows from the analysis above that, assuming the channels i1,..., im,o are all distinct, for all traces α, we have α ∈ F (i1,..., im; o) if and only if there are traces α1 ∈ buf (i1, o),..., αm ∈ buf (im, o) such that ((α1,..., αm), α) ∈ FM m.
The relationship between our fair merge relations, which manage to avoid tagging and untagging, and prior work in the dataflow setting, in which tags are prominent and participate crucially in key definitions and results, may be clarified a little by the following observation, which recasts our fair merge construction in an equivalent way that makes more explicit mention of tags. Let pre(α1)+ ··· + pre(αk) denote the “coalesced sum” of the ordered sets (pre(αi), <), which we render concretely as the set
{ϵ} ∪ {(i, α') | 1 ≤ i ≤ k & α' ∈ pre(αi)\{ϵ}},
with an ordering и such that ϵ is the least element, and (i, α') и (j, β') iff i =
j & α' < β'. Then ((α1,..., αk), β) ∈ FM k iff there is a strict, monotone injective
function F from (Σk	pre(αi), и) onto pre(β), such that for all i and all α' ∈
pre(αi), last (F (i, α')) = last (α'). Indeed, when such a function F exists, we can obtain scheduling functions fi : pre(αi) → pre(β) by letting fi(ϵ) = ϵ and fi(α') = 
F (i, α') for all i and all α' ∈ pre(αi). And conversely, given scheduling functions
(f1,..., fk) we can define a suitable function F from Σk	pre(αi) onto pre(β) by
setting F (ϵ) = ϵ and F (i, α') = fi(α') for all i and all α' ∈ pre(αi).
We prefer to work directly with the scheduling functions fi, as in the technical development given above, although it would of course be possible to repeat the entire development based on this alternative description of the FM family. Further- more, we emphasize that tags play an inessential rˆole in our framework, despite the existence of this alternative characterization that does involve tagging, and our tag-free formulation makes it easier to tackle fairness in a more general setting.

Future work
We plan to make further extensions to our framework, starting with a notion of fairmerge parameterized by a family of constraints, to allow expression of refine- ments such as fairness with respect to channels or semaphores, together with a theorem that characterizes necessary and sufficient conditions on these constraints that ensure that parallel composition is still associative. So far we have dealt with variants of weak process fairness, and we plan to augment our formalism to include various forms of weakly fair shared resource (such as a channel or a semaphore), which can be implemented by equipping a shared resource with a priority queue that keeps track of the processes currently blocked and waiting to access the resource.
We will also investigate the interaction between fairmerge and notions of trace equivalence or simplification operations on trace sets, such as those that occur in attempts to produce fully abstract models of concurrent languages [6]. For example,

it is common to assume that the alphabet includes an “idle” action δ that behaves as a unit for concatenation, inducing an equivalence relation on traces based on “stuttering” and “mumbling” with respect to idle steps. We would like to identify sufficient conditions on a trace equivalence ≡ that allow the fairmerge relations to be quotiented in the obvious way and ensure that the resulting family ⟨FM k/≡⟩ enjoys standard algebraic properties, including generalized associativity, prefix/suffix, and concatenation properties.
We also plan to tackle a wider range of semantics, including models such as [3,4,5,9] based on permissions, and to incorporate fairness notions relevant for models of message-passing processes [7]. It would also be interesting to investi- gate fairness, resources, and race detection in a “true concurrency” setting [23], such as the pomset semantics described in [7]. It should also be possible to for- mulate a general notion of ownership transfer [8,17] within our framework, aiming for a streamlined and more general soundness proof for concurrent separation logic (again inspired by [11]). This would involve an enabling relation in which resource acquisition and release combine with transfer of precisely designated pieces of state as in the “local enabling relation” of [8].

Acknowledgement
Thanks to the referees for suggesting a number of improvements and drawing my attention to Shanbhogue’s paper [25].

References
S. Abramsky. A generalized Kahn principle for abstract asynchronous networks. Proc. 5th MFPS Conference, Springer LNCS 442, pp. 1–21, 1989.
H. Bekiˇc. Definable Operations in General Algebras, and the Theory of Automata and Flowcharts. IBM Technical Report, 1969. In: Programming Languages and Their Definition, edited by C. B. Jones, Springer LNCS 177, 1984.
R. Bornat, C. Calcagno, P. W. O’Hearn, and M. Parkinson. Permission accounting in separation logic. POPL 2005, SIGPLAN Notices, 40(1), 259-270.
R. Bornat, C. Calcagno, and H. Yang. Variables as Resource in Separation Logic. MFPS XXI, Birmingham, 2005. ENTCS, Volume 155, 247-276. May 2006.
R. Bornat, M. Parkinson, and C. Calcagno. Variables as Resource in Hoare Logic. LICS 2006.
S. Brookes. Full abstraction for a shared-variable parallel language. Proc. 8th IEEE Symposium on Logic in Computer Science, IEEE Computer Society Press (1993), 98–109. Journal version in: Inf. Comp., vol 127(2):145-163, June 1996.
S. Brookes. Traces, pomsets, fairness and full abstraction for communicating processes. Proc. CONCUR 2002, Springer LNCS 2421, 466-482. August 2002.
S. Brookes. A semantics for concurrent separation logic. Invited paper, CONCUR 2004, London. Springer LNCS 3170, August 2004. Journal version in: Theoretical Computer Science, 375(1-3), May 2007.
S. Brookes. Variables as Resource for Shared-Memory Programs: Semantics and Soundness. MFPS 2006, Genova, Italy. ENTCS, Volume 158, 123-150. May 2006
M. Broy. Semantics of finite and infinite networks of communicating agents. Distributed Computing, 2:13–31, 1987.

C. Calcagno, P. W. O’Hearn, and H. Yang. Local Action and Abstract Separation Logic. LICS 2007.
B. Jonsson. A fully abstract trace model for dataflow networks. Proc. 16th POPL Conference, ACM Press, pp. 155-165, 1989.
G. Kahn. The semantics of a simple language for parallel programming. In Information Processing 74,
pp. 993 – 998. North Holland, 1974.
R. Keller. Denotational models for parallel programs with indeterminate operators. IFIP Working Conference on the Formal Description of Programming Concepts, St Andrews, New Brunswick, Canada, August 1977.
R. Milner. An approach to the semantics of parallel programs. Proceedings of Convegno di Informatica Teorica, Pisa, 1973.
Y. Moschovakis. A model of concurrency with fair merge and full recursion. Inf. Comp., vol. 93:114-171, 1991.
P. W. O’Hearn. Resources, Concurrency, and Local Reasoning. Invited paper, CONCUR 2004, London. Springer LNCS 3170, pp. 49-67, August 2004. Journal version in: Theoretical Computer Science, 375(1- 3), 271-307, May 2007.
S. Owicki and L. Lamport. Proving liveness properties of concurrent programs. ACM TOPLAS, 4(3): 455-495, July 1982.
P. Panangaden and E. W. Stark. Computations, Residuals, and the Power of Indeterminacy. Proc. 15th ICALP, Springer LNCS 317, 439–454, 1988.
P. Panangaden and V. Shanbhogue. The Expressive Power of Indeterminate Dataflow Primitives. Inf. Comp., vol. 98(1): 99-131, 1992.
D. Park. On the semantics of fair parallelism. In: Abstract Software Specifications, Springer-Verlag LNCS vol. 86, 504–526, 1979.
D. Park. Concurrency and Automata on Infinite Sequences. Proc. Conference on Theoretical Computer Science, Karlsruhe. Springer LNCS 104, pp. 167-183, March 1981.
V. Pratt. Modeling concurrency with partial orders. International Journal of Parallel Programming, 15(1):33–71, 1986.
J. Russell. Full Abstraction and Fixed-Point Principles for Indeterminate Computation. Ph. D. thesis, Cornell University, Department of Computer Science, April 1990.
V. Shanbhogue. The Relationship Between Multiway and Two-way Fair Merges. Technical Report TR 90-1146, Cornell University, Department of Computer Science, August 1990.
J. Staples and V. L. Nguyen. A Fixpoint Semantics for Nondeterministic Data Flow. J. ACM, 32(2): 411–444, April 1985.
