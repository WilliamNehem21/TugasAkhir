Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 298 (2013) 233–255
www.elsevier.com/locate/entcs

On Block Structures in Quantum Computation
Bart Jacobs
Institute for Computing and Information Sciences (iCIS), Radboud University Nijmegen, The Netherlands.
Web address: www. cs. ru. nl/ B. Jacobs
August 7, 2013

Abstract
A block is a language construct in programming that temporarily enlarges the state space. It is typically opened by initialising some local variables, and closed via a return statement. The “scope” of these local variables is then restricted to the block in which they occur. In quantum computation such temporary extensions of the state space also play an important role. This paper axiomatises “logical” blocks in a categorical manner. Opening a block may happen via a measurement, so that the block captures the various possibilities that result from the measurement. Following work of Coecke and Pavlovi´c we show that von Neumann projective measurements can be described as an Eilenberg-Moore coalgebra of a comonad associated with a particular kind of block structure. Closing of a block involves a collapse of options. Such blocks are investigated in non-deterministic, probabilistic, and quantum computation. In the latter setting it is shown that there are two block structures in the category of C∗-algebras, via copowers and via matrices.
Keywords: Block structure, non-deterministic, probabilistic, quantum program semantics, effect logic


Introduction
In imperative programming languages one may find block structures of the form:
{int v = 0; ...; return}	(1)
Such a block is a temporary extension of the state space. It is “opened” by initial- isation of some variables, and “closed” by a return statement. Although quantum programming is still in an embryonic state, it is clear, at least at the abstract level, that some sort of block structure is essential. For instance, in [9, Corollary 4.19] one finds that each completely positive map S : DM(H) → DM(H) between density matrices on a Hilbert space H — the interpretation of a quantum program — is of

1 bart@cs.ru.nl

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.09.016

the form:

S(ρ) = trK"U (ρ ⊗ ξ)U† ,

where U is unitary operator on a state space H ⊗ K enlarging H with an “ancilla” space K, ξ is a pure state |v⟩⟨ v | for some vector |v⟩∈ K, and trK is the partial trace operation. Essentially, this normal form result is based on Stinespring’s Theorem
(see loc. cit.). Here we see, similar to (1), extension of the state with K, opening of this block via the initial value ξ, and closing of the block via the partial trace trK. In this paper we explore block structures at a more elementary level. They are
defined as a collection of endofunctors Bn : A → A, for natural numbers n > 0, on a category A, together with “in” and “out” maps for opening and closing a block. A “logical” block structures comes equipped with “characteristic” or “measurement” maps X → Bn(X), induced by n-tests of predicates. Such maps can also open a block structure, via the various options that result from measurement. These log- ical block structures will be described in various categories, for non-deterministic, probabilistic (both discrete and continuous), and quantum computation. Interest- ingly, on Hilbert spaces with their standard logic of effects, there is no logical block structure, because there is no operation for closing blocks. This structure does exist on C∗-algebras. Hence, not directly on a Hilbert space H, but on the associated C∗-algebra L(H) of endomaps, we find the relevant logical block structure.
In the final section we use these logical block structures to give a diagrammatic description of two familiar quantum protocols, namely superdense coding and tele- portation. The ultimate goal is to develop an appropriate logic for such protocols and to formalise the representation in a computer algebra tool, for simulation and verification. Thus, the paper follows earlier work on semantics of quantum pro- gramming languages, like, for instance [1,19,20,21] and [7].
Among the logical predicates that we use there is a subclass of “projections”, with as typical property that iterated measurements give the same outcome. In [3] it was noticed that this property (of von Neumann projective measurements) is captured categorically by the “δ-law” for an Eilenberg-Moore coalgebra c, which requires δ ◦ c = T (c) ◦ c, where T is the comonad involved; this corresponds to the requirement PiPj = δijPi. The other equality that such a coalgebra must satisfy, namely ε ◦ c = id, corresponds to the condition i Pi = 1. The block structures that we use here allow us to generalise this approach in several directions, by showing that it also:
occurs in simpler situations than quantum models, namely in non-deterministic and in probabilistic models, represented by the Kleisli categories of the powerset monad P, and of the distribution and Giry monads D and G;
extends to C∗-algebras, but only in the commutative case, for one of the available block structures, namely the “copower” one that forms a comonad.
This paper unveils two block structures on C∗-algebras: one given by copowers and one by matrices. At this stage it fails to provide an answer to the question whether one of them is the right one, and in which sense? This will require more research.

Block structures
This section contains the basic definition of a block structure as a collection of endofunctors indexed by natural numbers, and also some examples. It starts with a very basic result describing some of the relevant endofunctors as (co)monads.
We shall write + for a coproduct in a category, with coprojections κi : Xi → X1+X2 and cotupling [f1, f2]: X1+X2 → Y , for fi : Xi → Y . For maps gi : Xi → Yi there is the coproduct of maps g1 + g2 = [κ1 ◦ g1, κ2 ◦ g2]: X1 + X2 → Y1 + Y2. Dually, we write products as ×, with projections πi : X1 × X2 → Xi and tupling
⟨f, g⟩ : Y → X1 × X2.
Lemma 2.1 Let C be a category with coproducts +. For each natural number
n > 0, the n-fold copower functor n · (−): C → C is a comonad, where
n · X = X + ·· · + X
`	n t˛im¸ es	x
The counit ε : n · X → X and comultiplication δ : n · X → n · (n · X) are given by:
ε = ∇ = [id,..., id]	δ = κ1 + ··· + κn = [κi ◦ κi]i≤n.

Dually, in presence of products ×, the n-fold power functor (−)n is a monad on C, with unit η = Δ = ⟨id,..., id⟩ : X → Xn and multiplication μ = ⟨πi ◦ πi⟩i∈n : (Xn)n → Xn.	 
On an abstract level these (co)monad structures arise because the n-element

set n carries a comonoid structure 1 →−!
id,id
−−−−→
n × n. But on a more concrete

level, it is not hard to verify the comonad equations ε ◦ δ = id = (n · ε) ◦ δ and
δ ◦ δ = (n · δ) ◦ δ.
Definition 2.2 A block structure on a category A consists of a collection of endo- functors Bn : A → A, for n > 0, with natural isomorphisms
B1(X) ∼= X	and	Bm(Bn(X)) ∼= Bm×n(X),	(2)
and with two collections of natural transformations inn : Id ⇒ Bn and outn : Bn ⇒
Id with outn ◦ inn = id, as in:
X 	inn	/Bn¸(X)
outn
J 
X
For the comonad X '→ n · X and monad X '→ Xn from Lemma 2.1 there are obvious isomorphisms as in (2), namely:
1 · X ∼= X	m · (n · X) ∼= (m × n) · X	X1 ∼= X	(Xn)m ∼= Xm×n.

One can turn the copower n· (−) into a block structure by choosing the first copro- jection κ1 : X → n · X as “in”. This however, looks rather arbitrary. In the next example we see that a more natural option exists in a quantitative setting, as given by the Kleisli category of the distribution monad D. We recall that D is the (finite discrete) distribution monad D : Sets → Sets, given by formal finite convex sums:
D(X) = {ϕ : X → [0, 1] | supp(ϕ) is finite, and Σx ϕ(x)= 1}.
Such an element ϕ ∈ D(X) may be identified with a finite, formal convex sum i rixi with xi ∈ X and ri ∈ [0, 1] satisfying	i ri = 1. The unit η : X → D(X) and multiplication μ : D2(X) → D(X) of this monad are given by singleton/Dirac convex sum ηD(x)= 1x and by matrix multiplication: μD(Φ)(x)=	ϕ Φ(ϕ) · ϕ(x).
Example 2.3 The Kleisli category Kl(D) of the distribution monad D : Sets → Sets inherits coproducts + from Sets, so that X '→ n · X is a comonad, following Lemma 2.1. We can turn n · (−) into a block structure via an “in” map in Kl(D), namely
X 	inn	/n ¸· X	given by	x 	/1 κ¸1x + ··· + 1 κnx.
Thus, inn(x) ∈ D(X) defines a uniform distribution over the various coprojections κix ∈ n · X. Taking the counit ε = ∇ : n · X → X as “out” map we get a block structure. Writing Kleisli composition as g ∗ f = μD ◦ D(g) ◦ f , we have:
"∇ ∗ inn (x) = "μD ◦ D([ηD,..., ηD]) " Σi 1 κix 
= μD" Σi 1 1x  = μD"1(1x)  = 1x = ηD(x) = id(x).
The product case X '→ Xn is a bit more subtle, because × is a tensor, not a cartesian product, on Kl(D). But since D(1) = 1, the tensor unit is the terminal object 1, so we have a tensor with projections. This allows us to define η and μ as in Lemma 2.1. An associated “out” map can be defined, again via a uniform distribution:

Xn 	outn	/X¸
namely	(x1,..., xn) 	/1 x¸1 + ··· + 1 xn



Then:
"outn ∗ η (x) = "μD ◦ D(outn) "1(x,..., x) 
= μD"1( 1 x + ··· + 1 x)  = μD"1(1x)  = 1x.

Example 2.4 In the Kleisli category Kl(P) of the powerset monad P : Sets → Sets the coproducts + are also products (and thus “biproducts”). This means that we have a particularly simple example of a block structure, namely:


X  in=η=Δ /n ¸· X  out=ε=∇ /X¸
(3)

where η and ε are the unit and counit from Lemma 2.1.  Explicitly, in(x) =
{κ1x,..., κnx} and out(κix)= {x}.
Example 2.5 The category Hilb of Hilbert spaces (over the complex numbers) also has biproducts ⊕, given by direct sums. Hence we can form blocks Bn(H) = n · H = H ⊕ · · · ⊕ H as before, for a Hilbert space H. But the obvious maps
in = Δ and out = ∇ as in (3) do not work in this case. One has to compensate by
appropriate division. This can be done on either side, as in:

	/¸

H
H
t=∇=Σ
H	in=Δ
n · H
out=  1 ∇
(4)

J 
H	H
where ( 1 Δ)(x)= ( 1 x,..., 1 x) and ( 1 ∇)(x1,..., xn)= x1+···+xn . Alternatively, it
can be done in a more symmetric manner:


in= 1  Δ
H 	n	/n ¸· H
out= √1  ∇

(5)

J 
H
In this symmetric case we have in† = out, where (−)† is the conjugate transpose. The equation in† ◦ in = id makes in a dagger mono — and out a dagger epi.
Blocks and predicates
This section describes how predicates may be related to block structures via certain “characteristic” or “measurement” maps, much like in [10]. We assume that the predicates, on an object in a base category, carry the structure of an effect algebra. Such effect algebras are generalisations of logical structures used in classical logic (esp. Boolean algebras), in probabilistic logic (fuzzy predicates), and in quantum logic (projections and effects). Briefly, an effect algebra is a partial commutative monoid, with partial binary operation ❽ and zero 0, together with a unique ortho- complenent x⊥, such that x ❽ x⊥ =1= 0⊥, and such that x ❽ 1 is defined only for x = 0. The main example is the unit interval [0, 1], with r ❽ s defined and equal to the sum r + s if r + s ≤ 1, and with r⊥ = 1 − r. In a pointwise manner this structure extends to fuzzy predicates [0, 1] , see below. Each Boolean algebra also forms an effect algebra, with x ❽ y defined and equal to the join x ∨ y if x ∧ y = 0. We shall use this below for powerset Boolean algebras P(X), where ❽ is union of disjoint sets. For more information, see e.g. [5,4,12,13]. A morphism of effect alge- bras f : E → D is a function between the underlying sets satisfying f (1) = 1 and: if x ⊥ y, then f (x) ⊥ f (y) and f (x ❽ y)= f (x) ❽ f (y). This yields a category EA. An n-test in an effect algebra E is an n-tuple e = (e1,..., en) of elements ei ∈ E
which satisfy e1 ❽ ··· ❽ en = 1. In this setting we describe a “logic of effects” categorically as a functor (or “indexed category”) Pred : A → EA . It maps an

object X ∈ A to the effect algebra Pred(X) of predicates on X. A map f : X → Y gives rise to a “substitution” functor Pred(f ): Pred(Y ) → Pred(X). In categorical logic it is often written as f−1.
Definition 3.1 Let A be a category with an indexed category Pred : A → EAop of effect algebras, and with a block structure Bn : A → A. We say this is a logical block structure if
for each X ∈ A and n > 0 there is a “universal” n-test on Bn(X), written as Ω = (Ω1,..., Ωn), with Ωi ∈ Pred(Bn(X)) satisfying Ω1 ❽ ··· ❽ Ωn = 1; moreover, these Ωi should be stable under substitution, in the sense that
Bn(f )−1(Ωi)= Ωi, for each f : X → Y in A;
for each X ∈ A and n-test p = (p1,..., pn) on X, where pi ∈ Pred(X) satisfy p1 ❽ ··· ❽ pn = 1, there is a “characteristic” map charp : X → Bn(X) in A with charp−1(Ωi)= pi, for each i ∈ n.
The characteristic map yields a block opening charp(x) ∈ Bn(X) whose n differ- ent options are determined by the n predicates pi in p.
Our first example clearly shows the importance of understanding powersets of predicates as effect algebras, because the disjoint union is crucial for having char- acteristic maps.
Example 3.2 On the Kleisli category Kl(P) of the powerset monad P there is an indexed category Pred : Kl(P) → EAop given by ordinary predicates: Pred(X) = 
P(X). This set of predicates is a Boolean algebra, and thus an effect algebra, with
sum ❽ defined as union, but only for disjoint subsets. For a Kleisli map f : X → Y
we have a substitution functor:
P(Y ) f−1=Pred(f )/P¸(X)	given by	V 	/{x¸| f (x) ⊆ V }.

(This substitution f−1 is not the same as inverse image, which is often also written as f−1.)
We show that the block structure Bn(X) = n · X from Example 2.4 is a logical block structure. For each number n > 0 and set X there is an n-test Ω= (Ω1,..., Ωn) on Bn(X)= n · X given by subsets:
Ωi = {κix | x ∈ X} ⊆ n · X = X + ··· + X = Bn(X).

These subsets Ωi are all disjoint, so their effect algebra sum Ω1 ❽ ··· ❽ Ωn exists and equals the maximal predicate 1 = n · X ⊆ n · X in Pred(n · X). It is easy to see that Ω is stable under composition: for f : X → Y in Kl(P),

Bn(f )−1(Ωi) = {z ∈ n · X | (n · f )(z) ⊆ Ωi} = {κix | x ∈ X} = Ωi.

For an arbitrary n-test U = (U1,..., Un) on X, where U1 ❽ ··· ❽ Un = 1, there

is a characteristic map in the Kleisli category Kl(P):
X 	charU	/Bn¸(X)	namely	x 	/{κ¸ix},	if x ∈ Ui.

Since the predicates Ui are mutually disjoint with join X, this forms a well-defined map. The required substitution equation in Definition 3.1 (2) holds:
char−1(Ωi) = {x | charU (x) ⊆ Ωi} = {x | x ∈ Ui} = Ui.
It is not hard to verify that this map charU : X → Bn(X) is an Eilenberg-Moore coalgebra of the comonad Bn = n · (−), i.e. that the equations outn ∗ charU = id and δ ∗ charU = Bn(charU ) ∗ charU hold, where δ is the comultiplication from Lemma 2.1. In fact one can prove that there is a bijective correspondence:
Boolean n-tests U = (U1,..., Un) in P(X)

========================================
Eilenberg-Moore coalgebras X −→ Bn(X) in Kl(P)
(6)

With intersection ∩ as multiplication operation, each of these predicates Ui is a projection, since U 2 = Ui ∩ Ui = Ui.
Example 3.3 The Kleisli category Kl(D) carries an indexed category Pred : Kl(D) → EAop given by fuzzy predicates: Pred(X) = [0, 1]X .  The effect algebra structure on [0, 1]  is inherited pointwise from [0, 1]. In particular,
for p, q ∈ [0, 1]X , if p(x)+ q(x) ≤ 1 for all x ∈ X, then p ❽ q is defined and (p ❽ q)(x) = p(x)+ q(x). Each map f : X → Y in Kl(D) yields a substitution functor:
[0, 1]Y f−1=Pred(f )/[0¸, 1]X	by	q 	/λx¸. Σ f (x)(y) · q(y).

We show that the copower block structure X '→ n · X from Example 2.3 is logical.
The “universal” n-test Ω consists of predicates Ωi ∈ [0, 1]n·X , given by Ωi(κjx) is 1 if i = j and 0 otherwise. Then: Ω1❽·· ·❽Ωn = 1; moreover these predicates Ωi are stable under substitution.
For an arbitrary n-test p on X, given by pi ∈ [0, 1]X with p1 ❽ ··· ❽ pn = 1, we define a characteristic map charp : X → n · X in Kl(D) via the convex sums:
charp(x) = p1(x)κ1x + ··· + pn(x)κnx,
using that p1(x)+ ··· + pn(x) = 1. Then:
charp−1(Ωi)(x) = Σz∈n·X charp(x)(z) · Ωi(z)

= pi(x).

In general the map charp : X → Bn(X) does not form an Eilenberg-Moore coalgebra of the comonad Bn: we do have outn ∗ charp = id, but the δ-law may fail. However, the law holds for n-tests given by fuzzy projections pi ∈ [0, 1]X , satisfying p2 = pi.
Automatically, pipj = 0, for j /= i, since the pi add up to 1. It is not hard to see that these projections correspond to “Boolean” fuzzy tests, determined by indicator functions 1Ui : X → [0, 1] with 1Ui (x) = 1 if x ∈ Ui and 1Ui (x) = 0 otherwise, for disjoint subsets Ui ⊆ X with U1 ❽ ··· ❽ Un = 1. Thus we have a bijective correspondence like in (6):
Boolean n-tests U = (U1,..., Un) in	(X)
===============================================

n-tests of projections p = (p1,..., pn) in [0, 1]X with p2 = pi
===============================================
Eilenberg-Moore coalgebras X −→ Bn(X) in Kl(D)
(7)

The fuzzy predicates in [0, 1]X form not only an effect algebra but an effect module (see [13] for details): they come with scalar multiplication, with scalars r from [0, 1], via r · p = λx. r · p(x). In the subcategory EMod ‹→ EA of such effect modules maps preserve the scalar multiplication. In this setting there are alternative characterisations of n-tests in [0, 1]X , in the style of [10], which we express via bijective correspondences:
fuzzy n-tests p = (p1,..., pn) in [0, 1]X
==============================
effect module maps [0, 1]n 	/[0¸, 1]X

==============================
Kleisli maps X 	/n¸(1) in	l( )
=====================================
Kleisli maps X	f	/Bn¸(X) with outn ∗ f = id
(8)

where 1 = {∗} is the singleton set. The first correspondence is standard. An n-test p corresponds to a Kleisli map g : X → Bn(1) via g(x)=  i pi(x)κi∗, and to a map
f : X → Bn(X) via f = charp. Such a map f gives rise to an n-test with predicates
pi = λx. f (x)(κix).
Example 3.4 The distribution monad D is used in a categorical approach to dis- crete probability. For the continuous case one uses the Giry monad [8]. It is defined as monad G : Meas → Meas on the category of measurable spaces, where G(X) contains the probability measures ΣX → [0, 1], defined on the measurable subsets ΣX ⊆ P(X). We briefly illustrate how it carries a logical block structure, in line with [11]. We follow the constructions and notation used there.
The logic is given by a functor Pred : Kl(G) → EModop that sends a measurable space X to the homset Pred(X)= Meas(X, [0, 1]) of measurable maps to [0, 1], with pointwise effect module structure. For a Kleisli map f : X → G(Y ) and predicate
q : Y → [0, 1] one defines substitution by integration:
Pred(f )(q) = f−1(q) = λx. ∫ q df (x).
There is a (comonad) block structure Bn(X)= n· X defined via copowers on Kl(G),

with the in : X → G(n · X) and out : n · X → G(X) maps given by:
in(x) = λM ∈ Σn·X. 1 Σi 1M (κix)	out(κix) = λN ∈ ΣX. 1N (x).
The predicates Ωi : n·X → [0, 1] are defined, as in Example 3.3, as Ωi = 1κiX , i.e. as Ωi(κjx)=1 if i = j and Ωi(κjx) = 0 otherwise. And for an n-test p = (p1,..., pn)
of predicates pi ∈ Pred(X) with p1 ❽ ··· ❽ pn = 1, we can define a characteristic map charp : X → Bn(X) in Kl(G) by:
charp(x) = λM ∈ Σn·X. Σi pi(x) · 1M (κix).
Also in this case the n-tests pi : X → [0, 1] that consist of projections, i.e. that
satisfy p2 = pi, can be characterised as Eilenberg-Moore coalgebras, like in (7).
They also correspond to indicator functions 1Mi , for Mi ∈ ΣX pairwise disjoint. Since the measurable subsets ΣX form an effect algebra, with ❽ given by disjoint union, they form n-tests in ΣX . Thus we get bijective correspondences:
n-tests M = (M1,..., Mn) in ΣX
======================================================

n-tests of projections p = (p1,..., pn) in Meas(X, [0, 1]) with p2 = pi
======================================================
Eilenberg-Moore coalgebras X −→ Bn(X) in Kl(G)
(9)

Example 3.5 In the context of Hilbert spaces, several of the ingredients encoun- tered above are present, but we do not find a logical block structure, for the standard logic of effects. We briefly describe the situation, building on Example 2.5.
We start with the logic. We write Hilbisom ‹→ Hilb for the subcategory of Hilbert spaces with isometries between them. Such an isometry f is bounded linear function that is a “dagger mono”, i.e. satisfies f† ◦ f = id. There is an “effect” predicate functor Ef : Hilbisom → EModop that sends a Hilbert space H to the set of effects:
Ef (H) = {A : H → H | 0 ≤ A ≤ id}.
These effects are the quantum fuzzy/unsharp predicates, see e.g. [16,15,5]. An effect A❽ B is defined and equal to A+ B if A+ B ≤ id. The orthocomplement is given by A⊥ = id − A. Scalar multiplication rA, for r ∈ [0, 1] is done in a pointwise manner. Hence this Ef (H) is an effect module.
For a dagger monic map f : H > K one defines f−1 = Ef (f ) = f† ◦ (−) ◦ f : Ef (K) → Ef (H). This substitution functor f−1 preserves the effect module structure because f is a dagger mono.
Let Bn(H)= n · H = H ⊕· · · ⊕ H be the block structure on Hilb from Exam- ple 2.5. There is an n-test Ω = (Ω1,..., Ωn) of effects Ωi = κi ◦ πi ∈ Ef (Bn(H)). More explicitly, Ωi(x1,..., xn)= (0,..., 0, xi, 0,..., 0). These Ωi’s are stable under substitution.
For an n-test A = (A1,..., An) of effects Ai ∈ Ef (H) we can define a character- istic map charA : H → Bn(H) in Hilbisom as n-tuple of square roots of (positive)
maps:
charA = ⟨√A1,..., √An⟩ : H −→ H ⊕ ··· ⊕ H = Bn(H).

This characteristic map is a dagger mono, since, as shown in [10]:
"charA † ◦ charA = [√A1,..., √An] ◦ ⟨√A1,..., √An⟩ = A1 + ··· + An = id.
Clearly, we have:
(charA)−1(Ωi) = charA † ◦ Ωi ◦ charA
= [√A1,..., √An] ◦ κ1 ◦ πi ◦ ⟨√A1,..., √An⟩
= √Ai ◦ √Ai
= Ai.
The map in = √1 Δ: H → Bn(H) in (5) arises in this manner as characteristic
map of the n-test ( 1 id,..., 1 id). However, the corresponding “out” map in (5),
n	n
out = in† =	n∇, is not a morphism in the category Hilbisom, since it is not a
dagger mono (but a dagger epi). Thus this does not give us a logical block structure in Hilbisom.
Using ⊕ as coproduct we have a comonad structure (ε, δ) on Bn = n · (−), as in Lemma 2.1. Following [3] we call a map c : H → Bn(H) in Hilb self-adjoint if the following diagram commutes.
H 	c	/Bn¸(H)

η=Δ
B

J 	/¸
Bn(c†)

n(H)	δ=κ1⊕···⊕κn
Bn(Bn(H))

This means that each component ci = πi ◦ c : H → H is self-adjoint, i.e. satisfies
ci† = ci.
The subset of projections (or sharp predicates) Pr(H) ‹→ Ef (H) contains those p : H → H with p ◦ p = p = p†. An n-test A = (A1,..., An) in Ef (H) is called a von Neumann test if each Ai satisfies Ai ◦ Ai = Ai and Ai ◦ Aj = 0 for each j /= i. Such an Ai is then a projection. One of the main results of [3] (specifically: Thm. 16.6) says that there is a bijective correspondence:
von Neumann n-tests p = (p1,..., pn) in Ef (H)

=========================================
self-adjoint Eilenberg-Moore coalgebras H → Bn(H)
(10)

A test p  corresponds to its characteristic map charp  =  ⟨√p1,..., √pn⟩  =
⟨p1,..., pn⟩.
Copower block structure on C∗-algebras
In the present context all C∗-algebras have a unit. The maps f : A → B between C∗-algebras that we consider are linear functions which are unital (preserve the unit) and positive (preserve positive elements: for each x ∈ A there is an y ∈ B

with f (x∗x) = y∗y). We often refer to these morphisms as ‘PU-maps’. We shall write CstarPU for the category of C∗-algebras with such unital positive maps, and CCstarPU ‹→ CstarPU for the full subcategory of C∗-algebras with commutative multiplication. These categories of C∗-algebras are most naturally used in oppo- site form — as (CstarPU)op and (CCstarPU)op — just like the category cHA of complete Heyting algebras typically occurs in opposite form, as category of locales Loc = cHAop, see e.g. [14].
In the literature on C∗-algebras it is most common to use *-homomorphism as maps. These preserve multiplication (M), involution (I) and are unital (U). In [6] these *-homomorphisms are called MIU-maps, in order to distinguish them from the PU-maps which are used here. MIU-maps are very restrictive, which is useful for Gelfand duality. But the PU-maps are the appropriate notion in a probabilistic or quantum context.
Let’s write KlN(D) ‹→ Kl(D) for the full subcategory with natural numbers n ∈ N as objects, considered as n-element set. There is a full and faithful func- tor KlN(D) → (CCstarPU)op, which sends an object n to Cn = C × ··· × C, the n-fold power of the complex numbers C; it sends a Kleisli map f : n → m to the PU-map C  → C  given by v '→ λi ∈ n.  j∈m f (i)(j) · v(j). This functor re- stricts to an equivalence between KlN(D) and the subcategory of finite dimensional commutative C∗-algebras, see [6]. In fact, in [6] it is shown that there is an equiva- lence between (CCstarPU)op and the Kleisli category of the “Radon” monad on the compact Hausdorff spaces. The point we are trying to make is that the category (CCstarPU)op of commutative C∗-algebras is a natural universe for probabilistic (monadic) computation.
In general, the multiplication term ab, for two positive elements a, b in a C∗- algebra, need not be positive. The following easy observations will be useful.
Lemma 4.1 Let a be a positive element in an arbitrary C∗-algebra. Then:
x∗ax is positive, for each element x;
xax is positive, for each positive x;
Proof Write a = y∗y; then x∗ax = x∗y∗yx = (yx)∗(yx) is clearly positive. If x is positive itself, then x∗ = x, so the second point follows from the first one. 
For two C∗-algebras A, B we write A⊕B for the C∗-algebra with product A×B as underlying set, with componentwise operations, and with maximum of the norms. Together with the usual projection and pairing operations this ⊕ forms a product in CstarPU and CCstarPU, and thus a coproduct in their dual categories. By Lemma 2.1 the mapping
A '−→ Bn(A) d=ef n · A = A ⊕· · · ⊕ A
is a comonad on (CstarPU)op and (CCstarPU)op. We show that it extends to a block structure, both on (CstarPU)op and (CCstarPU)op, namely:
A 	inn	/Bn¸(A) 	outn	/A¸,	(11)

where outn is the diagonal (counit) map A → An given by outn(a) = (a,..., a). The map inn : An → A takes the average: inn(a1,..., an)= a1+···+an . Keeping the ‘opposite’ in mind we see that the required block structure equation holds:

"outn
inn
 (a) = inn
"outn
(a) = a + ··· + a
n

= a.

We further notice that inn is a PU-map, but outn is a MIU-map.
For a C∗-algebra A we write [0, 1]A = {x ∈ A | 0 ≤ x ≤ 1} for the “effects” in A, that is, for the positive elements below the unit. These form an effect algebra, with x ❽ y defined and equal to x + y if x + y ≤ 1. The orthocomplement of x ∈ [0, 1]A is 1 − x. In fact, [0, 1]A is not just an effect algebra but an effect module, since scalar multiplication rx, where r is in the unit interval [0, 1] ⊆ R and x ∈ [0, 1]A, yields an effect rx ∈ [0, 1]A. Each PU-map f : A → B restricts to a map of effect algebras [0, 1]A → [0, 1]B. In [6] it is shown that the mapping
A '→ [0, 1]A yields a full and faithful functor CstarPU → EMod. We shall use it as Pred : (CstarPU)op → EModop, where Pred(A) = [0, 1]A. The substitution functor Pred(f )= f−1 : [0, 1]B → [0, 1]A associated with f : A → B in (CstarPU)op is obtained simply by restriction.
In this situation, like in (8), tests can be characterised in various ways.
Lemma 4.2 For a C∗-algebra A, there are bijective correspondences between:


n-tests p = (p1,..., pn) in [0, 1]A
==============================
effect module maps [0, 1]n 	/[0¸, 1]A
==============================
maps A	/Bn¸(C) in (CstarPU)op

(12)

Proof Given an n-test e = (e1,..., en), define h : A → Bn(C) in (CstarPU)op, that is h : C   A in Cstar , by h(z ,..., z ) =  z e . This h is clearly positive, and unital since h(1,..., 1) =  i ei = 1.  Conversely, a PU-map f : Cn → A is determined by the values f (|i⟩), where | i⟩ is the standard base vector (0,..., 1,..., 0) ∈ Cn. Since 0 ≤ |i⟩≤ 1 one has f (|i⟩) ∈ [0, 1]A.	 
Proposition 4.3 Let −→ai = (a1,..., an) ∈ An = Bn(A) be an n-tuple in a C∗- algebra A.
If Σi ai∗ai =1 there is a PU-map:
B (A)meas(−→ai )/A¸ given by	−→b 	/Σ¸a∗b a
If ai∗ai =1 for each i, then there is a PU-map:

B (A) map(−→ai )= i ai∗(−)ai/B¸(A)	given by	−→b

	/(a¸∗b a ,..., a∗ b a )

Proof The conditions	a∗ai = 1 and	i. a∗ai = 1 ensure that the functions
meas(−→ai ) and map(−→ai ) are unital. Positivity is trivial, by Lemma 4.1.	 

Example 4.4 Let ψ = (z1,..., zn) ∈ Cn be a state, so that ψ  = 1. This means that ψ ψ =  z z =  z  = 1, where  is conjugation of complex numbers. Hence in each C∗-algebra A this ψ gives rise to an n-tuple zi1 with  i(zi1)∗(zi1) =
These elements zi1 ∈ A arise via the unique map C → A, using initiality of C
among C∗-algebras. The “measure” map from Proposition 4.3 then gives a PU-map
Bn(A) → A, namely
(b1,..., bn) '−→ Σi(zi1)∗bi(zi1) = Σi(zizi)bi = Σi |zi|2bi.

In the opposite category this operation forms a map A → Bn(A) which describes how a context is opened and initialised by the state ψ ∈ Cn, via a probabilistic mixture determined by |zi|2 ∈ [0, 1], corresponding to the Born rule.
It turns out that the “copower” definition Bn = n · (−) yields a logical block structure, also for C∗-algebras, with predicate logic given by their effects: Pred(A)= [0, 1]A. In the next section we show that there is another block structure.
Proposition 4.5 The assignment A '→ Bn(A)= A ⊕· · · ⊕ A, with maps (11), isa logical block structure, both on (CstarPU)op and on (CCstarPU)op.
The universal n-test Ω= (Ω1,..., Ωn) consists of Ωi ∈ [0, 1]B (A) = ([0, 1]A)n
given by the n-tuple of effects (0,..., 1,..., 0), with 1 only at the i-th position.
For an n-test e = (e1,..., en) one can deﬁne a characteristic maps chare : A → Bn(A) as:
chare(a1,..., an) = √e1a1√e1 + ··· + √enan√en.
If A is commutative, we get chare(a1,..., an)=	i eiai.
Proof It is clear that the predicates Ωi are stable under substitution. Further,
chare−1(Ωi)= chare(0,..., 1,..., 0) = √ei√ei = ei.	 
The following result gives a C∗-algebraic version of the correspondences (6), (7), and (10). It only applies in the commutative case.
Generalising Example 3.5 we call an n-test e = (e1,..., en) in a C∗-algebra a
von Neumann n-test if each ei is a projection, i.e. satisfies e2 = ei, and satisfies
eiej = 0 for each j /= i.
Theorem 4.6 In a C∗-algebra A there are bijective correspondences:


von Neumann n-tests e = (e1,..., en) in [0, 1]A
=====================================
maps A	/Bn¸(C) in (CstarMIU)op
============================================= (∗)
Eilenberg-Moore coalgebras A −→ Bn(A) in (CstarPU)op

(13)

where the second correspondence, marked with (∗), only works if the C∗-algebra A
is commutative.

Proof We first do the first correspondence. Given a von Neumann n-test e = (e1,..., en) we can define a MIU-map f : Cn → A as sum of scalar multiplications: f (z1,..., zn)= i ziei, as in the proof of Lemma 4.2. It now preserves multiplica- tion:


= Σi(zi · wi)ei = f ((−z−−· −w→)i).
In the other direction, given such a MIU-map f : Cn → A we obtain an n-test of effects ei = f (|i⟩), like before. Now we have:



eiej
= f ( i )f ( j ) = f ( i  j ) =	f (|i⟩)= ei	if i = j
f (0) = 0	otherwise.

Hence the ei form mutually orthogonal projections, and thus a von Neumann test. For the second correspondence, assume A is commutative. Let e = (e1,..., en)
be a von Neumann n-test. The corresponding characteristic PU-map Bn(A) → A from Proposition 4.5, is given by chare( a ) = i eiai ei = i eiai. The latter simple form, resulting from commutativity, is crucial for proving the ε-equation for
a coalgebra, in the opposite category (CstarPU)op.
ε ◦op chare (a) = chare ◦ out (a)
= chare(a,..., a)
= Σi eia

= 1a
= a.
Bn(chare) ◦op chare (−→ti ) = chare chare(t1),..., chare(tn)	for ti ∈ An

= Σi eitii
= "δ ◦op chare (−→ti ).
Finally, assuming a coalgebra f : A → Bn(A) in (CstarPU)op, we define effects
ei = f (|i⟩A), where | i⟩A = (0,..., 1,..., 0) ∈ ([0, 1]A)n = [0, 1]An  = [0, 1]B (A).
Clearly, e1 ❽ ··· ❽ e1 = f (1) = 1. The equation ε ◦op f = f ◦ out = id yields that
f is a “map of bimodules”:
b · f (a1,..., an) · c = f "out(b) · (a1,..., an) · out(c)	(14)

This follows from [22, Thm. 1], because ƒ is a PU-map and out a MIU-map, and will be used without further ado.
We can now prove that the ei are mutually orthogonal projections. Consider the “matrix” t = |j ⟩⟨ i|∈ Bn(Bn(A)), so that t(x)(y) is1 if x = i and y = j, and 0 otherwise. Then:


ei · ej = ƒ (|i⟩) · ej = ƒ "|i⟩· out(ej) 
by (14)


= ƒ ƒ (0),...,ƒ ( j ),...,ƒ (0)
= "Bn(ƒ ) ◦op ƒ (t)

= ƒ (λx. t(x)(x))
=	ƒ (|i⟩)= ei	if i = j ƒ (0) = 0	otherwise.

We conclude this section with some basic observations. First, the opening of a the block via inn : A → Bn(A) as in (11) can be described via the characteristic maps A → Bn(A), for the “uniform” n-test ( 1 1,..., 1 1). Alternatively, it may be
understood as initialisation like in Example 4.4, given by the state ( √1 ,..., √1 ) ∈
Cn.
Second, the functor KlN(D) → (CCstarPU)op preserves block structures, since for m ∈ KlN(D) we have:

Bn(Cm) = (Cm)n ∼= Cn×m = CBn(m).	(15)

An n-test p1,..., pn ∈ [0, 1]m for KlN(D) → EModop is at the same time an n- test for (CCstarPU)op → EModop, since the effects [0, 1]Cm = [0, 1]m of Cm ∈ (CCstarPU)op are the same as the effects on m ∈ KlN(D), so that the diagram on the left commutes.

E


KlN(D)
/(C¸CstarPU)op
C(−)
CBn(m)  ∼ (Cm)n    Bn(Cm)


The triangle on the right shows that the characteristic maps are also preserved via (15) in CCstarPU, where charp on the left is in KlN(D), see Example 3.3, and charp on the right is in the category of C∗-algebras, see Proposition 4.5, using that Cm is commutative.

Matrix block structure on C∗-algebras
For a C∗-algebra A and number n ∈ N let Mn(A)= An×n be the vector space of n× n-matrices with entries from A. It is again a C∗-algebra with matrix multiplication, unit and conjugate transpose (−)†. Clearly M1(A) ∼= A, but also Mk(Mn(A)) ∼= Mk×n(A). Hence these matrices behave like a block structure.
It turns out that Mn is not a functor CstarPU → CstarPU, since Mn(ƒ ) need not be positive when ƒ is positive. One therefore calls ƒ completely positive when Mn(ƒ ) is positive, for each n. We write CstarcPU ‹→ CstarPU for the (non-full) subcategory of C∗-algebras with completely positive maps between them.
Each MIU-map is completely positive. When ƒ : A → B is a PU-map, where either A or B is commutative, then ƒ is completely positive. One thus requires com- plete positivity only in the non-commutative PU-case, that is, in a proper quantum setting. The following is the analogue of Proposition 4.3 for matrices.
Proposition 5.1 Let −→ai = (a1,..., an) ∈ An be an n-tuple in a C∗-algebra A. The tuple can be used to form “measurement” and “map” functions.
If Σi ai∗ai =1 there is a completely positive map:

meas(−→ai ) /¸

  /¸∗
∗	 a.1 


If ai∗ai =1 for each i, then there is a completely positive map:
M (A) map(−→ai ) /M¸(A)	given by	M  /di¸ag(−→a∗)Mdiag(−→a )
n	n	i	i

−→	 a1 .0  0 
0  0 an
We present an example later on in Example 5.5.
Lemma 5.2 Taking n × n-matrices yields a functor Mn : CstarcPU → CstarcPU, for each n > 0. It forms a block structure via “in” and “out” natural transformations in a commuting triangle in (CstarcPU)op
A 	inn	/M¸n(A)
outn
J 
A
These natural transformations are given by:

1	1 Σ
	
  a .0. 0 

0 0 a
where In ∈ Mn(A) is the unit/identity matrix. Here, outn is a MIU-map.
Moreover, the diagonal map diag : Bn(A) → Mn(A) is a natural transformation that commutes with the in’s and out’s.

Proof By definition there is a functor Mn : CstarcPU → CstarPU. We have to prove that Mn(ƒ ) is completely positive, for a completely positive map ƒ . Hence for each k, the map Mk(Mn(ƒ )) must be positive. But the latter can also be described as Mk×n(ƒ ), via the isomorphism Mk ◦ Mn ∼= Mk×n, which is positive because ƒ is completely positive.
It is a basic fact that the trace map tr is completely positive. Hence so is inn = 1 tr. The map outn : A → Mn(A) preserves multiplication and is thus completely positive. Clearly,


"	op	"

  a .0 0 


1	 a .0 0	1


It is easy to see that diag is natural, i.e. that the equation Mn(ƒ ) ◦ diag = diag ◦ Bn(ƒ ) holds. Moreover, diag commutes with the B and M maps:

"	op
M  −→

M  a1 .0  0	1 Σ

B −→

"	B  op
0  0 an

  a .0 0	M


The next step is to show that matrices form a logical block structure.
Proposition 5.3 The matrix block structure Mn on (CstarcPU)op is logical, with:
the universal n-test consisting of positive matrices Ωi = | i⟩⟨ i | ∈ Mn(A), clearly with ❽i Ωi = In;
for an arbitrary n-test ei ∈ [0, 1]A a characteristic map chare : A → Mn(A) in
(CstarcPU)op given by:


  
chare(M ) = (  e1 ... 
  
en)M
√e1
. 
√en

The characteristic maps for the copower and matrix block structures Bn and Mn
are related via the diagonal: diag ◦op chareM = chareB .
Proof Clearly chare−1(Ωi)= chare(|i⟩⟨ i |)= √ei√ei = ei. And:

"	op	M 
M  a1 .0  0 



√	√	 a1 .0  0   √e1 
= √e1a1√e1 + ··· + √enan√en
= chareB (a1,..., an).	 
The following result collects some standard facts.

Proposition 5.4 Let L(H) be the set of bounded linear maps H → H, where H is a Hilbert space. The mapping H '→ L(H) forms a functor
Hilbisom 	L	/(C¸starcPU)op,	(16)
where Hilbisom is the category of Hilbert spaces with isometries (dagger monos) between them. Each such a dagger mono ƒ : H > K gives a completely positive map L(ƒ )= ƒ† ◦ (−) ◦ ƒ : L(K) → L(H). In this situation we have:
Mn(L(H)) ∼= L(Hn) ∼= L(H ⊗ Cn)	where	Hn = H ⊕· · · ⊕ H.

Thus L maps the copower block structure n · (−) on Hilb, from Example 2.5, to the matrix block structure Mn on (CstarPU)op. This functor L also preserves effects and characteristic maps.
Proof A matrix in Mn(L(H)) consists of n × n bounded maps H → H. Since direct sum ⊕ is a biproduct for Hilbert spaces, these maps correspond to a single map Hn → Hn, i.e. an element of L(Hn). Next we use that C is the tensor unit in Hilb and that ⊗ distributes over ⊕ in:
Hn = H ⊕· · · ⊕ H ∼= (H ⊗ C) ⊕ ··· ⊕ (H ⊗ C)
∼= H ⊗ (C ⊕· · · ⊕ C) = H ⊗ Cn.

For an isometry (dagger mono) ƒ : H > K in Hilb we have L(ƒ ) = ƒ† ◦ (−) ◦ ƒ : L(K) → L(H). We use Mn(B(H)) ∼= B(H ⊗ Cn), with the map corresponding to Mn(L(ƒ )) being:
L(K ⊗ Cn)	(f†⊗id)◦(−)◦(f⊗id)	/L(¸H ⊗ Cn).

We show that if g ∈ L(K⊗ Cn) is positive, then so is (ƒ† ⊗ id)g(ƒ ⊗ id) ∈ L(H ⊗ Cn). For a vector v ∈ H ⊗ Cn, write w = (ƒ ⊗ id)v; then, using that g is positive:
⟨ v |(ƒ† ⊗ id)g(ƒ ⊗ id)|v⟩ = ⟨ (ƒ ⊗ id)v |g| (ƒ ⊗ id)v⟩ = ⟨ w |g|w⟩ ≥ 0.

The effects associated with the C∗-algebra L(H) are the effects Eƒ (H) = [0, 1]L(H) described Example 3.5. Thus the triangle on the left below commutes.


E

L(charA)
L (H,),¸
charA



Hilbisom
/(C¸starPU)op
L
L(Bn(H)) 	∼	 Mn(H)

For an n-test A = (A1,..., An) in Eƒ (H), the triangle on the right also commutes in (CstarPU). The char map on the left is as in Example 3.5, and the one on the right

as in Proposition 5.3. As described above, a map ƒ : Bn(H) → Bn(H) corresponds to a matrix Mf . Then:

M	√	√
 π1◦f. ◦κ1 ··· π1◦f.◦κn   √.A1 

√  	√	
πn◦f◦κ1 ··· πn◦f◦κn	An

( )	√	√
= [ A1 ...	An] ◦ ƒ ◦ ⟨ A1 ...	An⟩
= ⟨√A1 ... √An⟩† ◦ ƒ ◦ ⟨√A1 ... √An⟩
= L(⟨√A1 ... √An⟩)(ƒ )
= L(charBA)(ƒ ).
( )
The marked equation = involves some elementary calculations with biproducts ⊕
in Hilb.	 
Example 5.5 Consider the “identity” and “negation” matrices I2 = ( 1 0 ) and X = ( 0 1 ) as elements I2,X ∈ L(C2). The “map” operation from Proposition 5.1 (ii) yields:
M (L(C2))  map(I2,X) /M¸(L(C2))	given by	M 	/" I¸2 0 M " I2 0 

Via the isomorphism M2(L(C2)) ∼= L(C4) this is the operation L(CNOT): L(C4) → L(C ), where CNOT is the “conditional negation” matrix:


CNOT =
1 0 0 0 
0 1 0 0 
= " I2
0 .

0 0 0 1	0 X
0 0 1 0 
Remark 5.6 The category CstarcPU also has monoidal structure. In fact, there is a “minimal” and a “maximal” tensor A ⊗ B, but as long as either A or B is finite-dimensional, they coincide (with C as tensor unit). Via these tensors we can see a closer analogy between the copower and matrix block structures B and M on C∗-algebras, namely:
Bn(A) = An ∼= Cn ⊗ A = Bn(C) ⊗ A	and	Mn(A) ∼= Mn(C) ⊗ A.
In particular, for a Hilbert space H tensors are preserved:
L(Cn ⊗ H) ∼= Mn(H) ∼= Mn(C) ⊗ L(H) = L(Cn) ⊗ L(H).
Examples and discussion
So far we have seen examples of block structures in a non-deterministic and proba- bilistic setting — in the Kleisli categories Kl(P) and Kl(D) — and also in a quantum setting, in the categories of Hilbert spaces and of C∗-algebras. In the latter set- ting we have seen two block structures, namely copower Bn(A)= n · A and matrix Mn(A). It seems that Bn is most appropriate in a commutative/probabilistic set- ting, and Mn in a quantum setting, because:

Bn is a comonad, involving a copying operation; Mn is not a comonad, since copying is impossible in a non-commutative setting, see e.g. [17].
The functor Kl(D) → (CCstarPU)op putting probabilistic transitions in a C∗- algebraic context commutes with Bn.
The functor Hilbisom → (CstarcPU)op from (16) commutes with Mn.
The issue of which block structure to use, in which situation, remains unclear and will be further explored in follow-up research. In the remainder of this section we briefly investigate how block structures can be used to describe familiar quantum protocols like superdense coding and teleportation as maps in the category of C∗- algebras. Such descriptions can be used to represent the protocols in computer algebra tools, for simulation and verification. The whole point that we are trying to suggest is that logical blocks may form a clean language construct in a future (quantum) programming language.
We start by recalling some basic material. The Bell basis of C4 is given by the vectors:

|b1 ⟩ =
|b3 ⟩ =
√1 (| 00 ⟩ + | 11 ⟩)	|b2 ⟩ =
√1 (| 00 ⟩− | 11 ⟩)	|b4 ⟩ =
√1 (| 01 ⟩ + | 10 ⟩)
√1 (| 01 ⟩− | 10 ⟩)

The associated projections ei = |bi ⟩⟨ bi |∈ Eƒ (C4) can be described by the matrices:


e1 = 1
1 0 0 1 
0 0 0 0 
0 0 0 0 
1 0 0 1 
e2 = 1
0 0 0 0 
0 1 1 0 
0 1 1 0 
0 0 0 0 
e3 = 1
1 0 0  1
0 0 0 0
0 0 0 0
−1 0 0 1
e4 = 1
0 0  0 0
0 1	1 0 
0  1 1 0
0 0  0 0

They satisfy e1 ❽ e2 ❽ e3 ❽ e4 = id and thus form a 4-test in Eƒ (C4) = [0, 1]L(C4). Since e = ei we have ei = ei. Further, because the Bell basis is orthogonal, we have eiej =0 for i /= j. We shall write charBell in (CstarcPU)op for the associated measurement operation L(C4) → M4(L(C4)).
Next we need the four Pauli matrices in L(C2):
σ1 = ( 1 0 )  σ2 = X = ( 0 1 )  σ3 = Z = " 1 0   σ4 = XZ = " 0 −1 .

They all satisfy σi†σi = I2, and may thus be used in “map” constructions, like in Propositions 4.3 and 5.1

Superdense coding
What the superdense coding algorithm of [2] achieves is sending two classical bits via one (entangled) qubit. Two parties, Alice and Bob each possess one qubit of a shared entangled (Bell) state. Alice applies one of 4 operations σi to her qubit — thus encoding one the four options i ∈ 4 given by 2 classical bits — and sends the result to Bob. Through the local operations, represented as σi ⊗ id ∈ L(C4), Alice affects the shared state. By performing a Bell measurement Bob can find out which of the four operations σi was applied by Alice, and thus which i ∈ 4 is transmitted.

Our block-based representation of the superdense coding protocol consists of the following four maps in the category (CstarPU)op.


L(C )
in4B
J 
B (L
4
,,
B4(out4M)
map(σ−−i⊗−→id) /B¸(L(C4))  B4(charBell) /B¸(M (L(C4)))

(17)

First a copower 4-block is opened to deal with the four classical options (correspond- ing to the two classical bits at hand). In each of these four options Alice performs one of the operations σi, only to her part of the shared state, via σi ⊗ id. These operations are combined in a single one via “map”. At this stage Alice transfers her qubit to Bob, and Bob owns the whole state. In each of the four block options he performs a Bell measurement. Then he closes the outer block. The outcome of these Bell measurements distinguishes the various block options and enables Bob to recognise these options.
The computation (17) in (CstarPU)op consists of a computation B4(L(C4)) → L(C ) that computes the weakest precondition. We shall compute it with the above Bell projections (e1, e2, e3, e4) as input to this computation going backwards:
4(out4M) op	4(charBell) op map(σ−−i −−→id) op in4B (e1, e2, e3, e4)
= in4B ◦ map(σ−−i −⊗−→id)	i √eie1√ei,	i √eie2√ei,	i √eie3√ei,	i √eie4√ei
= in4B ◦ map(σ−−i −⊗−→id) (e1, e2, e3, e4)
= in4B (σ1	id)†e1(σ1	id), (σ2	id)†e2(σ2	id),
(σ3 ⊗ id)†e3(σ3 ⊗ id)(σ4 ⊗ id)†e4(σ4 ⊗ id) 

= in4 (e1, e1, e1, e1)
= e1.

The equalities (σ† ⊗ id)e (σ ⊗





(∗)

reader.
i	i	i
id) = e1 used in marked equation = are left to the

This calculation for (17) can be interpreted as follows. In order to get as post- condition (e1, e2, e3, e4), one has to start the computation with precondition e1. This precondition e1 = |b1 ⟩⟨ b1 | for |b1 ⟩ = √1 (| 00 ⟩ + | 11 ⟩) is the shared Bell state that usually serves as starting point for super dense coding.
Teleportation
For the teleportation protocol (see e.g. [18]) we open a “matrix” block via initialisa- tion. The bell basis vector |b1 ⟩ = √1 (| 00 ⟩+| 11 ⟩) ∈ C4 gives rise to a (dagger monic)
map id ⊗ |b1 ⟩ : C2 > C2 ⊗ C4. By applying the functor L from Proposition 5.4 we obtain:
L(C2)	/L(¸C2 ⊗ C4) ∼= M4(L(C2))

This is the first map in the protocol below.
L(C2)


2
,,
out4B

M ( J  charBell /B¸(M (L(C2))) B4(out4M)/B¸(L(C2)) map(−→σi ) /B¸(L(C2))
In this case, after initialisation Alice does a measurement charBell giving a copower block B4 in order to transfer two bits of information to Bob. Here we consider the above matrices ei as matrices over L(C2). In each of the resulting 4 block options
Bob does an adjustment, with the Pauli matrices σi. It can be shown that the resulting map L(C2) → L(C2) is the identity.
Conclusions
This paper presents the first steps towards understanding the structure and role of blocks and predicates in non-deterministic / probabilistic / quantum programming. The opening of blocks via characteristic maps (measurements) induced by n-tests in effect algebras is common in these approaches. For the particular case of “von Neu- mann” n-tests of projections this can be described via Eilenberg-Moore coalgebras. In the general case there is much variation that requires further investigation.
Acknowledgements
Thanks to Robert Furber and Jorik Mandemaker for helpful discussions.

References
T. Altenkirch and J. Grattage. A functional quantum programming language. In Logic in Computer Science, pages 249–259. IEEE, Computer Science Press, 2005.
C. Bennett and S.J. Wiesner. Communication via one- and two-particle operators on Einstein-Podolsky- Rosen states. Phys. Review Letters, 69(20):2881–2884, 1992.
B. Coecke and D. Pavlovi´c. Quantum measurements without sums. In G. Chen, L. Kauffman, and
S. Lamonaco, editors, Mathematics of Quantum Computing and Technology, pages 559–596. Taylor and Francis, 2008.
A. Dvureˇcenskij and S. Pulmannov´a. New Trends in Quantum Structures. Kluwer Acad. Publ., Dordrecht, 2000.
D. J. Foulis and M.K. Bennett. Effect algebras and unsharp quantum logics. Found. Physics, 24(10):1331–1352, 1994.
R. Furber and B. Jacobs. From Kleisli categories to commutative C∗-algebras: Probabilistic Gelfand duality. See arxiv.org/abs/1303.1115, 2013.
S. Gay. Quantum programming languages: survey and bibliography. Math. Struct. in Comp. Sci., 16:581–600, 2006.
M. Giry. A categorical approach to probability theory. In B. Banaschewski, editor, Categorical Aspects of Topology and Analysis, number 915 in Lect. Notes Math., pages 68–85. Springer, Berlin, 1982.
T. Heinosaari and M. Ziman. The Mathematical Language of Quantum Theory. From Uncertainty to Entanglement. Cambridge Univ. Press, 2012.

B. Jacobs. New directions in categorical logic, for classical, probabilistic and quantum logic. See arxiv.org/abs/1205.3940, 2012.
B. Jacobs. Measurable spaces and their effect logic. In Logic in Computer Science. IEEE, Computer Science Press, 2013.
B. Jacobs and J. Mandemaker. Coreflections in algebraic quantum logic. Found. of Physics, 42(7):932– 958, 2012.
B. Jacobs and J. Mandemaker. Relating operator spaces via adjunctions. In J. Chubb Reimann,
V. Harizanov, and A. Eskandarian, editors, Logic and Algebraic Structures in Quantum Computing and Information, Lect. Notes in Logic. Cambridge Univ. Press, 2013. See arxiv.org/abs/1201.1272.
P. Johnstone. Stone Spaces. Number 3 in Cambridge Studies in Advanced Mathematics. Cambridge Univ. Press, 1982.
K. Kraus. States, Effects, and Operations. Springer Verlag, Berlin, 1983.
G. Ludwig. Foundations of Quantum Mechanics I. Springer Verlag, New York, 1983.
H. Maassen. Quantum probability and quantum information theory. In F. Benatti, M. Fannes,
R. Floreanini, and D. Petritis, editors, Quantum Information, Computation and Cryptography, number 808 in Lect. Notes Physics, pages 65–108. Springer, Berlin, 2010.
M. Nielsen and I. Chuang. Quantum Computation and Quantum Information. Cambridge Univ. Press, 2000.
P. Selinger. Towards a quantum programming language. Math. Struct. in Comp. Sci., 14(4):527–586, 2004.
P. Selinger and B. Valiron. A lambda calculus for quantum computation with classical control. Math. Struct. in Comp. Sci., 16(3):527–552, 2006.
P. Selinger and B. Valiron. Quantum lambda calculus. In S. Gay and I. Mackie, editors, Semantical Techniques in Quantum Computation, pages 135–172. Cambridge Univ. Press, 2010.
J. Tomiyama. On the projection of norm one in W∗-algebras. Proc. Japan Acad., 10:608–612, 1957.
