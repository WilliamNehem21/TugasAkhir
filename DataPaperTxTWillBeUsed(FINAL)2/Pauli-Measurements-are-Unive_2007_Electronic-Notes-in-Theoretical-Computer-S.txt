	Electronic Notes in Theoretical Computer Science 170 (2007) 95–100	
www.elsevier.com/locate/entcs

Pauli Measurements are Universal
Vincent Danos1
CNRS & Universit´e Paris 7
Elham Kashefi2
IQC & University of Waterloo

Abstract
We show that a variant of the one-way model where one only allows X and Y one qubit measure- ments is approximately universal.
Keywords: Quantum computing, measurements.


Introduction
While the one-way model [4,5,6] has been recognised since its inception as an important theoretical quantum computing model, it is only recently that some of its measurement patterns have been realised in the lab [7]. There are a number of different questions to be addressed before such implementations on physical substrates can be carried out on larger examples. One of these, which is the one we are particularly interested in in this note, is the efficient implementation of the feedforward mechanism by which the measurements angles are allowed to depend on the outcomes of past measurements. We show that a variant of the original one-way model, incorporating only Pauli measurements is approximately universal. Thus, when executing a particular pattern, the feedforward mechanism only has to deal with a choice of two

1 Email: Vincent.Danos@pps.jussieu.fr
2 Email: ekashefi@iqc.ca




1571-0661 © 2007 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.013

angles, 0 and π , and this constitutes a potentially useful simplification of the underlying hardware needed to realise the feedforward mechanism. We also show that this variant still admits a standardisation procedure, meaning that all measurement patterns can be rewritten in a way that entanglement is done first, by adapting the measurement calculus given for the original model [2].
Because our model is a variant, it is also interesting from the theoretical point of view, in that it helps in better charting out the fundamental properties one needs in a measurement-based model for it to be both universal and standardisable.

Measurement patterns
We use X, Z to denote the usual Pauli matrices, H for the Hadamard transfor- mation, Zα for the Z-rotation with angle α, and the following abbreviations: P = Z , Q = Z . Note that Q2 = P and P 2 = Zπ = Z.
The following notations will also be useful:
|+⟩ := H|0⟩, |−⟩ := H|1⟩ = Z|+⟩,
|+α⟩ = Zα(|+⟩), |−α⟩ = Zα(|−⟩)
A measurement pattern, or simply a pattern, is defined by the choice of
V a finite set of qubits, two subsets (actually two maps to be precise) I and O determining the pattern inputs and outputs (which we don’t suppose to have an empty intersection), and a finite sequence of any of the following instructions (i, j denote qubits in V where the instruction applies):
Measurements Mα with outcome written si;
sj i sj
Corrections Xi , Pi ;
Constant operations Eij and Qi;
Preparations |+⟩i.
Above, Eij is just a notation for ∧Zij (controlled-Z), also known as con- trolled phase, applied at qubit i and j. Since this operator is symmetric in i,
j, there is no need to say which of i, j is the control qubit, and which is the target. Note that constant operations, Qi and Eij (which are called constant since they never depend on any outcome) all commute together, so the spe- cific order in which they appear in a measurement pattern is irrelevant to the result of a computation.
i using the orthonormal basis |+α⟩, |−α⟩. One writes si for this measurement The instruction Mα stands for a one qubit measurement applied at qubit outcome, with the convention that si = 0 when the measurement behaves as
⟨+α|, and si =1 when it behaves as ⟨−α|.

A pattern is run by first preparing non inputs in the |+⟩ state, then by setting the input qubits to a given input value, and finally by executing each
instruction of the instruction sequence. With that in mind, it is natural to ask the following:
—(D0) no command depends on an outcome not yet measured;
—(D1) no command acts on a qubit already measured;
—(D2) a qubit i is measured if and only if i is not an output.
We see that the first condition simply ensures that by the time a correc- tion has to be done, one can actually compute its exponent from the extant outcomes. The second condition ensures that qubits are not reused. While reusing is legitimate to spare on the number of physical qubits, it disrupts the standardisation property (because, obviously if qubits are reused, then they also have to be re-entangled, and therefore the whole entanglement can no longer be done first), and is best left as an optional optimisation not taken into account in our pattern language. This condition also ensures that there is at most one measurement done on any given qubit, and therefore the notation si, standing for the outcome of the measurement done at qubit i is sensible. Finally, the third condition ensures that by the time all measurements have been done, the output qubits are no longer entangled with the rest, so that they can effectively be read out of the computation space.
Actions on measurements
In general, our set of corrections can be absorbed in measurements in the following way:
MαXs = M (−1)sα
i	i	i

MαPs
α−s π
= M	2

i	i	i
One readily sees that the subset of angles {0, π , π, − π } is closed under the
2	2
actions of the corrections. Therefore we may, and this is what we do now,
restrict to that particular subset. Also, starting with the same equations, one can compute the effect of a sequence of corrections on the actual angle of measurement. For instance:


MαXsPt

(−1)sα−t π
= M	2

i	i  i	i

MαPtXs
(−1)sα−(−1)st π
= M	2

i	i	i	i
Note that the obtained angles are different in case s = t = 1. In other words, P and X respective actions on measurements don’t commute. This makes the computation of angle dependencies a bit more complicated than in the original model where one considered only X and Z actions (which do commute).

Thereafter, a measurement preceded by a sequence of corrections on the same qubit will be called a dependent measurement. Note that, by the absorp- tion equations above, these indeed can be seen as measurements, where angles depend on the outcomes of some other measurements made beforehand. This is the feedforward mechanism mentioned in the introduction.



Standardisation

Standardisation is a procedure by which instructions in a pattern can be re- arranged in a specific order, where constant instructions are done first, then dependent measurements, then corrections on the outputs. Such patterns will be called standard.
The first needed ingredient for standardisation is given by the absorption laws, where a correction gets absorbed by a measurement as in the equations given above in the preceding section.
The second ingredient concerns the commutation of a constant instruction with a correction:
Eij Xs = XsPsPsEij
i	i  j  j
Eij Ps = PsEij
QiXs = PsXsQi
i	i	i
QiPs = PsQi

Essentially standard rewriting theory arguments show that by directing the absorption and commutation equations from left to right, and using free com- mutation equations (when instructions apply on different qubits) any sequence of instructions in a pattern satisfying (D1) can be rewritten in a standard form. Moreover the other conditions (D0) and (D2) are stable under rewriting, and the standard form is essentially unique.
Standardisation is particularly useful when a big pattern is given by com- posing (either sequentially or in parallel) smaller ones. It is also useful to reveal the intrinsic depth complexity in a pattern, where this depth is defined as that of the graph of dependencies of its standard form. Note that condition (D0) exactly amounts to saying that this dependency graph is acyclic, and thereby guarantees that the depth is finite (and then, smaller than the total number of qubits).

Universality

Define Jα := HZα. We know [3] that the family of Jαs together with ∧Z is universal. We also know that the set consisting of J0 (which is H), J π , and
∧Z is approximately universal.
To prove the approximate universality of our language of patterns, it is
therefore enough to exhibit a pattern for each of these three unitaries. Let us
begin with J0 and ∧Z which are computed by the following 2-qubit patterns:

ỹ := Xs1 M 0E
(1)

0	2	1	12
∧$ := E12	(2)
where the first pattern has inputs {1}, and outputs {2}, while the second one has {1, 2} both as inputs and outputs (note the overlapping).
Now to implement J π in the ordinary one-way model, one may use:

ỹπ := X
π
s1 M  4 E
(3)

4	2	1	12

= Xs1 M 0E  Q
(4)

2	1	12  1
with inputs {1} and outputs {2} as in our pattern for J0. We note that the an angle − π , but the second one does. It follows that any unitary can be first form doesn’t fit in the variant model, since it uses a measurement with obtained with an arbitrary precision, by a pattern obtained by tensoring and
composing our three basic patterns.
If we have a look back at our three generating patterns, it seems that only X corrections are needed, but this is not so. Indeed, from to the rules commuting constant instructions and corrections, ones sees that X corrections generate Z 2 corrections (first and third equations), so these are really needed, at least if one wants to work with standard patterns.

Conclusion
We have proved that a variant of the one-way model where only Pauli mea- surements are ever made is approximately universal. This is similar in spirit to a result known from the circuit model, where one proves that magical states
preparations, meaning Z 4 |+⟩, and Clifford operators are approximately uni-
versal [1]. However the proof given here is much simpler. From the standard-
isation procedure, we also see that restricting to standard patterns, where entanglement is done first, still results in an approximately universal model.
Therefore, during a computation, the physical device used to perform one qubit measurements needs only to be switched to an X or a Y measurement. The price to pay for this simplification is twofold. First, one needs to rotate some of the inputs using a Z-rotation with angle π . Note however, that

by standardisation, this phase may always be computed at the beginning, concurrently with the entanglement phase, and is done once and for all. It can also be disposed of altogether by using the teleportation pattern, but this will incur a cost of two extra qubits.
Second, since the X and Z 2 actions on measurement angles don’t com- mute, the arithmetic needed to compute at run-time whether one should do an X or a Y measurement is more complicated than it is in the usual model. As this arithmetic on the forwarded outcomes is purely classical, this doesn’t seem to be a problem.
As was suggested recently by Briegel, this model could also prove useful to deal with the important issue of fault-tolerance in measurement-based quan- tum computing. Indeed, since only X and Y measurements are ever used, the traditional error model, based on Z and X errors, will affect the computation in a particularly simple way, only swapping the outcomes of a measurement. Furthermore, from the absorption equations, one sees that X errors are either of no consequence (in the case the measurement angle is 0 or π), or equivalent
to a Z error (in the case the measurement angle is π or − π ). Since Z correc-
tions are known to be easy both to detect and to correct, by using repetition
codes, it seems this model could mesh well with error-correction techniques. To really see how fault-tolerant this model could be made, further work is needed however.

References
Bravyi, S. and A. Kitaev, Universal quantum computation with ideal Clifford gates and noisy ancillas (2004), arXiv:quant-ph/0403025.
Danos,  V.,  E.  Kashefi  and  P.  Panangaden,	The  measurement  calculus	(2004),
arXiv:quant-ph/0412135.
Danos, V., E. Kashefi and P. Panangaden, Robust and parsimonious realisations of unitaries in the one-way model (2004), arXiv:quant-ph/0411071.
Raussendorf, R. and H.-J. Briegel, A one-way quantum computer, Physical Review Letters 86
(2001).
Raussendorf, R. and H.-J. Briegel, Computational model underlying the one-way quantum computer, QIC 2 (2002).
Raussendorf, R., D. E. Browne and H.-J. Briegel, Measurement-based quantum computation on cluster states, Phys. Rev. A 68 (2003).
Walther, P., K. J. Resch, T. Rudolph, E. Schenck, H. Weinfurter, V. Vedral, M. Aspelmeyer and A. Zeilinger, Experimental one-way quantum computing, Nature 434 (2005), pp. 169–176.
