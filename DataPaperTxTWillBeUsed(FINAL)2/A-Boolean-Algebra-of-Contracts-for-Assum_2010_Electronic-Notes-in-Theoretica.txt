

Electronic Notes in Theoretical Computer Science 263 (2010) 111–127
www.elsevier.com/locate/entcs

A Boolean Algebra of Contracts for Assume-guarantee Reasoning
Yann Glouche1 Paul Le Guernic Jean-Pierre Talpin Thierry Gautier
INRIA, Centre de Recherche Rennes-Bretagne Atlantique Campus de Beaulieu, 35042 Rennes Cedex, France,

Abstract
Contract-based design is an expressive paradigm for a modular and compositional specification of programs. It is in turn becoming a fundamental concept in mainstream industrial computer-aided design tools for embedded system design. In this paper, we elaborate new foundations for contract-based embedded system design by proposing a general-purpose algebra of assume/guarantee contracts based on two simple concepts: first, the assumption or guarantee of a component is defined as a filter and, second, filters enjoy the structure of a Boolean algebra. This yields a structure of contracts that is a Heyting algebra.
Keywords: Contract-based design, specification, embedded system, Boolean algebra, Heyting algebra


Introduction
Common methodological guidelines for attacking the design of large embedded ar- chitectures advise the validation of specifications as early as possible and an iterative validation of each refinement or modification made to the initial specification, until the implementation of the system is finalized. Additionally, cooperative component- based development requires to use and to assemble components, which have been developed by different suppliers, in a safe and consistent way [10,15]. These com- ponents have to be provided with their conditions of use and guarantees that they have been validated when these conditions are satisfied. This represents a notion of contract. Contracts are now often required as a useful mechanism for valida- tion in robust software design. Design by Contract, as advocated in [26], is being made available for usual languages like C++ or Java. Assertion-based contracts ex- press program invariants, pre- and post-conditions, as Boolean type expressions that have to be true for the contract being validated. We adopt a different paradigm

1 Partially funded by the EADS Foundation.

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.05.007

of contract to define a component-based validation technique in the context of a synchronous modeling framework. In our model, a component is represented by an abstract view of its behaviors. It has a finite set of input/output variables to cooperate with its environment. Behaviors are viewed as multi-set traces on the variables of the component. The abstract model of a component is thus a process, defined as a set of such behaviors.
A contract is a pair (assumptions, guarantees). Assumptions describe properties expected by a component to be satisfied by the context (the environment) in which this component is used; on the opposite guarantees describe properties that are satisfied by the component itself when the context satisfies the assumptions. Such a contract may be documentary; however, when a suitable formal model exists, contracts can be subject to some formal verification tool. We want to provide designers with such a formal model allowing “simple” but powerful and efficient computation on contracts. Thus, we define a novel algebraic framework to enable formal reasoning on contracts. It is based on two simple concepts.
First, the assumptions and guarantees of a component are defined as process- ﬁlters: assumptions filter the processes (sets of behaviors) a component may accept and guarantees filter the processes a component provides. A process-ﬁlter is the set of processes, whatever their input and output variables are, that are compatible with some property (or constraint), expressed on the variables of the component. Second and foremost, we define a Boolean algebra to manipulate process-filters. This yields an algebraically rich structure which allows us to reason on contracts (to abstract, refine, combine and normalize them). This algebraic model is based on a minimalist model of execution traces, allowing one to adapt it easily to a particular design framework.
A characteristic of this model is that it allows one to precisely handle the vari- ables of components and their possible behaviors. This is a key point. Indeed, assumptions and guarantees are expressed, as usual, by properties constraining or relating the behaviors of some variables. What has to be considered very carefully is thus the “compatibility” of such constraints with the possible behaviors of other variables. This is the reason why we introduce partial order relations on processes and on process-filters. Moreover, having a Boolean algebra on process-filters allows one to formally, unambiguously and finitely express complementation within the algebra. This is, in turn, a real advantage compared to related formalisms and models.

Plan
The article is organized as follows. Section 2 introduces a suitably general alge- bra of processes which borrows its notations and concepts from domain theory [1]. A contract (A,G) is viewed as a pair of logical devices filtering processes: the as- sumption A filters processes to select (accept or conversely reject) those that are asserted (accepted or conversely rejected) by the guarantee G. Process-filters are defined in Section 3 and contracts in Section 4. Section 5 discusses application of our model to the synchronous Signal language. Related works are further discussed in

Section 6. Section 7 concludes the presentation. Detailed proofs of all properties presented in this article are available in a technical report [12].

An algebra of processes
We start with the definition of a suitable algebra for behaviors and processes. Usu- ally, a behavior describes the trace of a discrete process (a Mazurkiewicz trace [24] or a tuple of signals in Lee’s tagged signal model [18]). We deliberately choose a more abstract definition in order to encompass not only sequences of Boolean, integer, real variables but also behaviors of more complex systems such as hybrid systems or, on the contrary, simpler “behaviors” associating scalar values with variables, to represent execution cost, memory size, etc. In this paper we focus the presentation on usual process behaviors.
Definition 2.1 [Behavior] Let V be an infinite, countable set of variables, and D a set of values; for Y, a finite set of variables included in V (written Y ⊂ V), Y nonempty, a Y-behavior is a function b : Y → D.
The set of Y-behaviors is denoted by BY =Δ Y → D. Definition 2.1 is extended to the empty variable domain: B∅ =Δ ∅ (there is no behavior associated with the empty set of variables). For Y, a finite set of variables included in V, Y nonempty, c a Y-behavior, X a (possibly empty) subset of Y, c|X is the restriction of c on X, c|X =Δ {(x,c(x))|x ∈ X}, c|∅ =Δ ∅; then c|Y = c.
In Figure 1, the x, y-behaviors b1 and b2 are functions from the variables x, y to functions that denote signals. Behavior b1 is a discrete sampling mapping a domain of time represented by natural numbers to values. Behavior b2 associates x, y to continuous functions of time.

Figure 1. Examples of behaviors.

We define a process as a set of behaviors on a given set of variables.
Definition 2.2 [Process] For X, a finite set of variables (X ⊂ V), an X-process p
is a nonempty set of X-behaviors.
Thus, since B∅ = ∅, there is a unique ∅-process, designated by Ω =Δ {∅}; Ω has the empty behavior as unique behavior. The empty process is denoted by V =Δ ∅.
Since Ω does not have any variable, it has no effect when composed (intersected) with other processes. It can be seen as the universal process, for constraint conjunc- tion, in contrast with V, the empty set of behaviors, the use of which in constraint conjunction always results in the empty set. V can be seen as the null process.

For X, a finite set of variables (X ⊂ V), we denote by DX =Δ P(BX) \ {V} the set of X-processes (D∅ = {Ω}). D =Δ ∪(X ⊂ V) DX denotes the set of all processes. The domain of behaviors in an X-process p is denoted by var(p) =Δ X.
A process is a nonempty set of behaviors. Then we extend D to D٨ =Δ D ∪ {V} and ∀X ⊂ V, DX to D٨X =Δ DX ∪ {V}. Moreover, we extend the definition of var(p) to var(V) =Δ V.
The following operators will be used to define filters and contracts: the comple- mentary of a process p in DX is a process in D٨X; the restriction of a process p in DX to Y ⊆ X ⊂ V is the abstraction (projection) of p to Y; finally, the extension of p in DX to Y ⊂ V, Y finite, is the process on Y that has the same constraints as p.
Definition 2.3 [Complementary, restriction and extension] For X, a finite set of variables (X ⊂ V), the complementary p of a process p ∈ DX is defined by p =Δ (BX \ p). Also, BX = V. When X, Y are finite sets of variables such that X ⊆ Y ⊂ V, we define by q|X =Δ {c|X|c ∈ q} the restriction q|X ∈ DX of q ∈ DY and by p|Y =Δ {c ∈ BY|c|X ∈ p} the extension p|Y ∈ DY of p ∈ DX. Hence, we have q|∅ = Ω, q|var(q) = q, Ω|Y = BY and p|var(p) = p.

Figure 2. Complementary, restriction and extension of a process.
The complementary p of a process p defined on the variables x and y, Figure 2, consists of all behaviors defined on x, y not belonging to p. The restriction p|{x, y} of a process p defined on x, y, z, consists of its projection on the restricted domain; right, the extension p|{x, y, z} of a process p defined on x, y is the largest process defined on x, y, z whose restriction on x, y is equal to p.
The set D٨X, equipped with union, intersection and complementary, extended
with V˜ = BX, is a Boolean algebra with supremum D٨X and infimum V.  The
definition of restriction is extended to V, the null process, with V|X =Δ {c|X|c ∈ ∅}
= V. Since V is the set of all variables, the definition of extension is simply extended to V, with V|V =Δ V. The process extension operator induces a partial order ≤ , such that p ≤ q if q is an extension of p to variables of q; the relation ≤ , used to
define filters, is studied below.
Definition 2.4 [Process extension relation] The process extension relation ≤ is defined by: ( ∀ p ∈ D) ( ∀ q ∈ D) (p ≤ q) =Δ ((var(p) ⊆ var(q)) ∧ (p|var(q) = q))
Thus, if (p ≤ q), q is defined on more variables than p; on the variables of p, q
has the same constraints as p; its other variables are free. This relation extends to

D٨ with (V ≤ V).
Property 2.5 (D٨,≤) is a poset.


Checking  transitivity,   antisymmetry  and  reflexivity  is  immediate. In this poset, the upper set of a process p, called ex-
tension upper set, is the set of all its extensions; it is denoted by p↑≤ =Δ {q ∈ D|p ≤ q}. The extension upper set is illustrated in Figure 3.
To study properties of extension upper set s, we char- acterize the set of variables that are constrained by a given process: we write that a process q ∈ D controls some variable y, if y belongs to var(q) and q is not equal to the extension on var(q) of its projection on
(var(q)\{y}).	Figure 3. Extension upper set.


This is illustrated in Fig- ure 4, there is some be- havior b in q that has the same restriction on (var(q)\{y}) as some be- havior c in Bvar(q) such that c does not belong to q; thus q is strictly included in
(q|(var(q)\{y}))|var(q) .	Figure 4. Controlled (left) and non-controlled (right) variable y in a

Formally, a process q ∈ D controls a variable y, written (q D y), iff (y ∈ var(q)) and q /= ((q|(var(q)\{y}))|var(q) ). A process q ∈ D controls a variable set X, written (q D X), iff ( ∀ x ∈ X) (q D x).
Moreover, D is extended to D٨ with V D V. Note that if a process p controls X, this does not imply that, for all x ∈ X, y ∈ X, x /= y, (p|(X\{x})) controls y: it may be the case that x is constrained in p by y; then if x is “removed” (by the projection on other controlled variables), y may be free in this projection. We define a reduced process (the key concept to define filters) as being a process that controls all of its variables.
Definition 2.6 [Reduced process] A process p ∈ D٨ is reduced iff p D var(p).
For instance, Ω is reduced. On the contrary, BX is never reduced when X is not empty. Reduced processes are minimal in (D,≤). We denote by oq, called reduction of q, the (minimal) process such that oq ≤ q (p is reduced iff op = p). For all X, we
o
have BX = Ω.

Figure 5 illustrates the reduction oq of a process
q and a process p, in the extension upper set

oq↑
. Assuming that var(q) = ({x
1...n
}∪ {y
1...m})

and that q controls the variables {x1...n}, we have
o	o
var(q) = {x1...n}; the process p is such that p ∈ q↑≤
with var(p) ⊆ ({x1...n}∪ {y1...m}∪ {z1...l}); it con-
trols the variables {x1...n}, and {y1...m}∪ {z1...l} is
a set of free variables, such that oq = op.	Figure 5. Reduction of a process.
Property 2.7 The complementary p of a nonempty process p strictly included in Bvar(p) is reduced iff p is reduced; then p and p control the same set of variables var(p).

From the above, the extension upper set op↑
of the reduction of p is a (principal)

filtered set [1]: it is nonempty and each pair of elements has a lower bound. Then

op↑
is composed of all the sets of behaviors, defined on variable sets that include

the variables controlled by p, as maximal processes (for union of sets of behaviors) that have exactly the same constraints as p (variables that are not controlled by p
are also not controlled in the processes of op↑ ). We also observe that var(oq) is the
greatest subset of variables such that q D var(oq). For a process q ∈ D٨, we extend

the definition of var() to the extension upper set of its reduction by var(oq↑
) =Δ

var(q). Notice that V↑≤ = {V}.
We define the inclusion lower set of a set of processes to capture all the subsets of behaviors of these processes. Let R ⊆ D٨, R↓⊆ is the inclusion lower set of R for
⊆ defined by R↓⊆ =Δ {p ∈ D٨|( ∃ q ∈ R) (p ⊆ q)}. Hence, none of the processes but V belongs to the inclusion lower set of the extension upper set of V; on the contrary, all processes belong to the inclusion lower set of the extension upper set
o	o
of Ω: [V↑≤]↓⊆ = {V} and [Ω↑≤]↓⊆ = D٨.
An algebra of filters
In this section, we define a process-ﬁlter by the set of processes that satisfy a given property. We propose an order relation (±) on the set of process-filters Φ. We establish that (Φ,±) is a Boolean algebra. A process-ﬁlter R is a subset of D٨ that filters processes. It contains all the processes that are “equivalent” with respect to some constraint or property, so that all processes in R are accepted or all of them but V are rejected. A process-filter is built from a unique process generator by extending it to larger sets of variables and then by including subprocesses of these “maximal allowed behavior sets”.
Definition 3.1 [Process-filter] A set of processes R is a process-ﬁlter iff ( ∃ r ∈ D٨) ((r = or) ∧ (R = [r↑≤]↓⊆)). The process r is a generator of R (R is generated by r).
The process-filter generated by the reduction of a process p is denoted by p^

=	[op↑

]↓⊆
o
. The generator of a process-filter R is unique, we refer to it as R. Ω

generates the set of all processes (including V) and V belongs to all filters. Formally, ( ∀ p,r,s ∈ D٨), we have:
(p ∈ r^) =⇒ (var(or) ⊆ var(p))	r^ = s^ ⇐⇒ or = os	Ω ∈ r^ ⇐⇒ r^ = D٨
Figure 6 illustrates how a process-filter is generated from a process p (depicted by
the bold line) in two successive operations. The first operation consists of building the extension upper set of the process:
it takes all the processes that are compatible with p and that are defined on a larger set of variables. The second operation proceeds using the inclusion lower set of this set of processes: it takes all the processes that are defined by subsets of behaviors from processes in the extension upper set (in other words, those processes that remain compatible when adding constraints, since adding constraints removes behaviors).
Figure 6. Example of process-filter.
We denote by Φ the set of process-filters. We call strict process-ﬁlters the process- filters that are neither D٨ nor {V}. The filtered variable set of a process-filter R is
o
var(R) defined by var(R) =Δ var(R).
We define an order relation on process-filters, which we call relaxation, and write
R ± S to mean that R is less wide than S.
Definition 3.2 [Process-filter relaxation] For R and S, two process-filters, let Z
= var(R) ∪ var(S).	The relation S relaxes R, written R ± S, is defined by:

o |Z
{V} ± S	(R ± {V}) ⇐⇒ {V} = R	(R ± S ⇐⇒ R
o|Z
⊆ S  )

The relaxation relation defines the structure of process-filters, which is shown to be a lattice.
Lemma 3.3 (Φ,±) is a lattice of supremum D٨ and inﬁmum {V}. Let R and S be

o |V
two process-ﬁlters, V = var(R) ∪ var(S), RV = R
o|V
and SV = S
. Conjunction

R H S, disjunction R H S and complementary R are deﬁned by:
o	˜o
˜

{V} H R =Δ {V}	R H S =Δ [(RV ∩ SV)↑≤]↓⊆
o
{V} H R =Δ R	R H S =Δ [(RV ∪ SV)↑≤]↓⊆
{˜V} =Δ D٨
R =Δ [R↑≤]↓⊆
D˜٨ =Δ {V}

If R /= {V} then
var(R˜ ).
R˜ /= {V} and ˜o
= (B

var(R)
o
\ R) is reduced and var(R) =

Let us comment the definitions of these operators. Conjunction of two strict process-filters R and S, for instance, is obtained by first building the extension

o	o
of the generators R and S on the union of the sets of their controlled variables; then the intersection of these processes, which is also a process (set of behaviors) is considered; since this operation may result in some variables becoming free (not controlled), the reduction of this process is taken; and finally, the result is the process-filter generated by this reduction. The same mechanism, with union, is used to define disjunction. And the complementary of a strict process-filter R is
o
the process-filter generated by the complementary of its generator R.
The process-filter conjunction RHS of two strict process-filters R and S is the greatest process-filter T = RHS that accepts all processes that are accepted by R and by S.
Example 3.4 Let x, a variable taking values in {0,1,2,3} and u, y, v three variables taking values in {0,1}; let r ∈ D{u, x, y}, s ∈ D{x, y, v}, two reduced processes defined by
r = {b|b(u) ∈ {0, 1} ∧ b(x) ∈ {0, 1} ∧ b(y) ∈ {0, 1}}∪ {{(u, 1), (x, 2), (y, 0)}}
s = {b|b(x) ∈ {0, 1} ∧ b(y) ∈ {0, 1} ∧ b(v) ∈ {0, 1}}∪ {{(x, 3), (y, 1), (v, 0)}}
We observe that r D {u, x, y}; u and y are free in r when x is 0 or 1; v is free whatever the value of x is in r. We also have s D {x, y, v}; y and v are free in s when x is 0 or 1; thus u is free whatever the value of x is in s. From the above definitions, we have that p =Δ r ∩ s = {b|b(u) ∈ {0, 1} ∧ b(x) ∈ {0, 1} ∧ b(y) ∈ {0, 1} ∧ b(v) ∈ {0, 1}}
and op = {b|b(x) ∈ {0, 1}}.

The process-filter disjunction RHS of two strict process-filters R and S is the smallest process-filter T = RHS that accepts all processes that are accepted by R or by S.
Example 3.5 Let x, a variable taking values in {0,1,2,3} and u, y, v three variables taking values in {0,1}; let r ∈ D{u, x, y}, s ∈ D{x, y, v}, two reduced processes such that
r = {b|b(u) ∈ {0, 1} ∧ b(x) ∈ {0, 1} ∧ b(y) = 0}
s = {b|b(x) ∈ {0, 1} ∧ b(y) = 1 ∧ b(v) ∈ {0, 1}}
Hence, p =Δ r ∪ s = {b|b(u) ∈ {0, 1} ∧ b(x) ∈ {0, 1} ∧ b(y) ∈ {0, 1} ∧ b(v) ∈ {0, 1}} and op = {b|b(x) ∈ {0, 1}}.
Now we can state a first main result, which is that process-filters form a Boolean algebra.
Theorem 3.6 (Φ,±) is a Boolean algebra with D٨ as 1, {V} as 0 and the comple- mentary R.
Variable elimination operators are defined on process-filters.
Definition 3.7 [Variable elimination in process-filter] Let x be a variable, R a process-filter, and X =Δ var(R). The E-elimination of x in R, noted R|∃x, is the projection of R on controlled variables other than x. The generator of the U- elimination of x in R (U-elimination of x in R is noted R|∀x) contains the behaviors

o	o
of R restricted on X\{x} for which x is free in R.


R|∃x=Δ
o^
R)|X\{x}
, x ∈ X
R|∀x =Δ R˜ |∃x

⎪⎩ R,	otherwise
Notice that R|∀x ± R ± R|∃x.
Example 3.8 Let R, a process-filter generated by ((x > 0) ⇒ (y > 0)) ∧ ((y > 0) ⇒ (z > 0)). Then R|∃x is generated by ((y > 0) ⇒ (z > 0)) and R|∀x is generated by ((y > 0) ∧ (z > 0)).

An algebra of contracts
We define the notion of assume/guarantee contract and propose a refinement rela- tion on contracts.
Definition 4.1 [Contract] A contract C = (A,G) is a pair of process-filters. var(C), the variable set of C = (A,G), is defined by var(C) =Δ var(A) ∪ var(G). C =Δ Φ×Φ is the set of contracts.
Usually, an assumption A is an assertion on the be- havior of the environment (it is typically expressed on the inputs of a process) and thus defines the set of be- haviors that the process has to take into account. The guarantee G defines properties that should be guar- anteed by a process running in an environment where behaviors satisfy A.
Figure 7 depicts a process p satisfying the contract

(A,G) (p is the process-filter generated by the reduc- tion of p).
Figure 7. A process p satisfying a contract (A,G).

A process p satisﬁes a contract C = (A,G) if all its behaviors that are accepted by A (i.e., that are behaviors of some process in A), are also accepted by G; this is made more precise and formal by the following definition.
written    p   ▶   C,    iff  (p^  H   A)    ±   G. Definition 4.2 [Satisfaction] Let C = (A,G) a contract; a process p satisfies C,
Property 4.3 p ▶ C ⇐⇒ p^ ± (A˜ H G)
We define a preorder relation that allows to compare contracts. A contract (A1,G1) is ﬁner than a contract (A2,G2), written (A1,G1) ~(A2,G2), iff all pro- cesses that satisfy the contract (A1,G1) also satisfy the contract (A2,G2).
Definition 4.4 [Satisfaction preorder](A1,G1)~(A2,G2) iff( ∀ p ∈ D)((p ▶ (A1,G1))
=⇒ (p ▶ (A2,G2)))
The preorder on contracts satisfies the following property:

Property 4.5 (A1,G1) ~(A2,G2) iff (A1 H G1) ± (A2 H G2)
Definition 4.6 [Refinement of contracts] A contract C1 = (A1,G1) reﬁnes a con- tract C2 = (A2,G2), written C1 “ C2, iff (A1,G1) ~(A2,G2), (A2 ± A1) and G1
± (A1 H G2).
Reﬁnement of contracts amounts to relaxing assumptions and reinforcing promises under the initial assumptions. The intuitive meaning is that for any p that satisfies a contract C, if C refines D then p satisfies D. Our relation of refinement formalizes substitutability.




Figure 8. Refinement of contracts.
Figure 8 depicts a contract (A1,G1) that refines a contract (A2,G2). Among contracts that can be used to refine an existing contract (A2,G2), we choose those contracts (A1,G1) that “scan” more processes than (A2,G2) (A2 ± A1) and that guarantee less pro- cesses than those of A1HG2. But other choices could have been made.

By definition of the satisfaction pre-order, we can express the refinement relation in the algebra of process-filters as follows:
Property 4.7 (A1,G1) “ (A2,G2) iff A2 ± A1, (A2HG1) ± G2 and G1 ± (A1HG2).
The refinement relation (“) defines the poset of contracts, which is shown to be a lattice. In this lattice, the union or disjunction of contracts is defined by their least upper bound and the intersection or conjunction of contracts is defined by their greatest lower bound.
Lemma 4.8 (Composition of contracts) Two contracts C1 = (A1,G1) and C2
= (A2,G2) have a greatest lower bound C = (A,G) , written (C1 ↓ C2), deﬁned by:
A = A1HA2 and G = ((A1HA˜2HG1)H(A˜1HA2HG2)H(G1HG2))
and a least upper bound D = (B,H), written (C1 ⇑ C2), deﬁned by:
B = A1HA2 and H = (A˜1HG1)H(A˜2HG2)H(A1HG2)H(A2HG1)
A Heyting algebra H is a bounded lattice such that for all a and b in H there
is a greatest element x of H such that the greatest lower bound of a and x refines b [6]. For all contracts C1 = (A1,G1), C2 = (A2,G2), there is a greatest element X = (I,J) of C such that the greatest lower bound of C1 and X refines C2, with: I = (A1HA2)H(A1HA2HG1HG2)	J = G2H(A1HA2)H(A1HG1)H(A2HG1)
Then our contract algebra is a Heyting algebra. In particular, it is distributive.
Theorem 4.9 (C, “) is a Heyting algebra with supremum ({V},D٨) and inﬁmum (D٨,{V}).

Let x a variable, C = (A,G) a contract, the elimination of x in C is the contract
C\x defined by C\x =Δ (A|∀x,G|∃x).
Property 4.10 A contract C refines the elimination of a variable in C: C “ C\x


Application to the
Signal
language

In the synchronous multiclocked model of Signal [19], a process (noted p), consists of the synchronous composition (noted p| q) of equations on signals (noted x = yf z). A signal x consists of an infinite flow of values that is discretely sampled according to the pace of its clock. A set of tags t is to denote symbolic periods in time during which transitions take place. It samples a signal over a countable series of causally related tags. Then the events, signals, behaviors and processes are defined as follows:
- an event e is a pair consisting of a tag t and a value v,
- a signal s is a function from a chain of tags to a set of values,
- a behavior b is a function from a set of names to signals,
- a process p ∈ D is a set of behaviors that have the same domain.
Synchronous composition p| q consists of the simultaneous solution of the equa- tions in p and q at all times.
Definition 5.1 [Synchronous composition of processes] The synchronous compo- sition of two processes p,q ∈ D is defined by: p| q =Δ { b ∪ c | (b, c) ∈ p × q ∧ b|var(p) ∩ var(q) = c|var(p) ∩ var(q) }
In the context of component-based or contract-based engineering, refinement and substitutability are recognized as being fundamental requirements [9]. Refine- ment allows one to replace a component by a finer version of it. Substitutability allows one to implement every contract independently of its context of use. These properties are essential for considering an implementation as a succession of steps of refinement, until final implementation. As noticed in [27], other aspects might be considered in a design methodology. In particular, shared implementation for dif- ferent specifications, multiple viewpoints and conjunctive requirements for a given component.
Considering the synchronous compositon of Signal processes and the greatest lower bound as a composition operator for contracts, we have:
Property 5.2 Let two processes p,q ∈ D, and contracts C1, C2, C'1, C'2 ∈ C.
C1 G C2 =⇒ ((p ▶ C1) =⇒ (p ▶ C2))	(4) ((p ▶ C1) ∧ (q ▶ C2)) =⇒ ((p| q) ▶ (C1 ⇓ C2))
C1 ~C2 ⇐⇒ ((p ▶ C1) =⇒ (p ▶ C2))	(5) ((p ▶ C1) ∧ (p ▶ C2)) ⇐⇒ (p ▶ (C1 ⇓ C2))
((C'1 G C1) ∧ (C'2 G C2)) =⇒ (C'1 ⇓ C'2 G C1 ⇓ C2)

(1) and (2) relate to refinement and implementation; (3) and (4) allow for subti- tutability in composition; (5) addresses multiple viewpoints.
In [13], we develop a module system based on our paradigm of contract for the
Signal formalism, and applied it to the specification of a component-based design

process. This module system, embedding data-flow equations defined in Signal syntax, has been implemented in OCaml. It produces a proof tree that consists of 1/ an elaborated Signal program, that hierarchically renders the structure of the system described in the original module expressions, 2/ a static type assignment, that is sound and complete with respect to the module type inference system, 3/ a proof obligation consisting of refinement constraints, that are compiled as an observer or a temporal property in Signal.
The property is then tended to Signal’s model-checker, Sigali [21], which allows to prove or disprove that it is satisfied by the generated program. Satisfaction implies that the type assignment and produced Signal program are correct with the initially intended specification. The generated property may however be used for other purposes.  One is to use the controller synthesis services of Sigali [20]

to automatically generate a
Signal
program that enforces the property on the

generated program. Another, in the case of infinite state system (e.g. on numbers), would be to generate defensive simulation code in order to produce a trace if the property is violated.
We now illustrate the distinctive features of our contract algebra by considering the specification of a four-stroke engine and its translation into observers in the synchronous language Signal.



Figure 9. State machine of 4-stroke engine cycle.
Figure 9 represents a state ma- chine that denotes the successive operation modes of a 4-stroke en- gine: Intake, Compression, Com- bustion and Exhaust. They are driven by the camshaft whose po- sition is measured in degrees.

The angle of the camshaft defines a discrete timing reference, the clock cam, mea- sured in degrees CAM◦, of initial value 0. Transitions in the state machine are trig- gered by measures of the camshaft angle. The variables cam, Intake, Compression, Combustion, Exhaust model the behavior of the engine. We wish to define a con- tract to stipulate that intake always takes place in the first quarter on the camshaft revolution. To do this, we define the generator of a process-filter for the assumption. It should be a measure of the environmental variable cam. Namely cam should be in the first quarter. Under these assumptions, the state machine should be guar- anteed to be in the intake mode, hence the generator of the process-filter for the guarantee:
AIntake=Δ(cam mod 360 < 90)	GIntake=ΔIntake
The generic structure of processes in contracts finds a direct in- stance  and  compositional  translation  into  the  synchronous  multi-

clocked	model	of	computation	of
Signal.	Using
Signal
equations:

AIntake = true when(cam mod360 < 90)GIntake = true when intake default false
A subtlety of the Signal language is that the contract not only talks about the value, true or false, of the signals, but also about the status of the signal

names, present or absent.	Hence, the signal AIntake is present and true iff
cam is present and less than 90.  Hence, in Signal, the complementary of the

assumptions is simply defined by
˜
Intake
= false when A
Intake
default true

to mean that it is true iff cam is absent or bigger than 90.	Notice that, for a trace of the assumptions AIntake, the set of possible traces corresponding

˜
Intake
is infinite (and dense) since it is not defined on the same clock as A
Intake.

AIntake =1 0 1 0 1 0 1 0 1  and A˜
=0  0  0    0  0  or 0111011 01 10  101 ... 

It is also worth noticing that the clock of A˜
(its reference in time) need not be

explicitly related to or ordered with AIntake or GIntake: it implicitly and partially relates to the cam clock.
Notice that our model of contract is agnostic as to a particular model of com- putation and accepts a generic domain of behaviors. Had we instead considered executable specifications, such as synchronous observers [22], it would have been more difficult to compositionally define the complementary of a proposition with- out referring to a global reference of time in the environment (e.g., a clock for the camshaft), hence abstracting every assumption or guarantee with respect to that global clock. This does not need to be the case in the present example. Beside its Boolean structure, our algebra supports the capability to compositionally refine contracts (without altering or abstracting individual properties) and accepts both synchronous and asynchronous specifications.
For instance, consider a more precise model  of  the  4-stroke  engine  found in [3](Figure 10). To additionally require that, while in the intake mode, the engine should reach the EC state (Exhaust closes) between 5 and 20 degrees, one will simply

Figure 10. Model of 4-stroke engine cycle.
compose (greatest lower bound) the intake contract with the additional one:

AEC = true when(4 < cam mod 360 < 21) GEC = true when EC default false

Contracts can be used to express exclusion properties. For instance, when the engine is in the intake mode, one should not start compression.
Aexcl=ΔOTDC	Gexcl=Δ¬FBDC
In addition to the above safety properties, contracts can also be used to express liveness properties. For instance, consider the protocol for starting the engine. A battery is used to initiate its rotation. When the engine has successfully started, the battery can be turned off. We can specify a contract to guarantee that engine cycles are properly counted. We write cycle' for the next value of the variable cycle.
Acount=ΔExhaust	Gcount=Δcycle' = cycle +1 
Another contract is defined to specify that the starter battery (starter) will even- tually be turned off after a few cycles. We write F () for the future property of LTL.
Alive=Δ(cycle > 0)	Glive=ΔF (¬starter)

Related work

The use of contracts has been advocated for a long time in computer science [23,14] and, more recently, has been successfully applied in object-oriented software engi- neering [25]. In object-oriented programming, the basic idea of design-by-contract is to consider the services provided by a class as a contract between the class and its caller. The contract is composed of two parts: requirements made by the class upon its caller and promises made by the class to its caller.
In the context of software engineering, the notion of assertion-based contract has been adapted for a wide variety of languages and formalisms but the central notion of time and/or trace needed for reactive system design is not always taken into account. For instance, extensions of OCL with linear or branching-time temporal logics have been proposed in [28,11], focusing on the expressivity of the proposed constraint language (the way constraints may talk about the internals of classes and objects), and considering a fixed “sequence of states”. This is a serious limitation for concurrent system design, as this sequence becomes an interleaving of that of individual objects.
In the theory of interface automata [2], the notion of interface offers benefits similar to our notion of contracts and for the purpose of checking interface com- patibility between reactive modules. In that context, it is irrelevant to separate the assumptions from guarantees and only one contract needs to be and is associated with a module. Separation and multiple views become of importance in a more general-purpose software engineering context. Separation allows more flexibility in finding (contra-variant) compatibility relations between components. Multiple viewpoints allow better isolation between modules and hence favor compositional- ity. In our contract algebra as in interface automata, a contract can be expressed with only one filter. To this end, a filtering equivalence relation [12] (that defines the equivalence class of contracts that accept the same set of processes) may be used to express a contract with only one guarantee filter and with its hypothesis filter accepting all the processes (or, conversely, with only one hypothesis filter and a guarantee filter that accepts no process).
In [7], a system of assume-guarantee contracts with similar aims of genericity is proposed. By contrast to our domain-theoretical approach, the EC Speeds project considers an automata-based approach, which is indeed dual but makes notions such as the complementary of a contract more difficult to express from within the model. The proposed approach also leaves the role of variables in contracts unspecified, at the cost of some algebraic relations such as inclusion.
In [16], the authors show that the framework of interface automata may be em- bedded into that of modal I/O automata. [27] further develops this approach by considering modal specifications. This consists of labelling transitions that may be
fired and other that must. Modal specifications are equipped with a parallel com-
position operator and refinement order which induces a greatest lower bound. The GLB allows addressing multiple viewpoints and conjunctive requirements. With the experience of [7], the authors notice the difficulty in handling interfaces having

different alphabets. Thanks to modalities, they propose different alphabet equal- izations depending on whether parallel composition or conjunction is considered. Then they consider contracts as residuations G/A (the residuation is the adjoint of parallel composition), where assumptions A and guarantees G are both specified as modal specifications. The objectives of this approach are quite close to ours. Our model deals carefully alphabet equalization. Moreover, using synchronous compo- sition for processes and greatest lower bound for process-filters and for contracts, our model captures both substitutability and multiple viewpoints.
In [22], a notion of synchronous contracts is proposed for the programming language Lustre. In this approach, contracts are executable specifications (syn- chronous observers) timely paced by a clock (the clock of the environment). This yields an approach which is satisfactory to verify safety properties of individual modules (which have a clock) but can hardly scale to the modeling of globally asynchronous architectures (which have multiple clocks).
In [8], a compositonal notion of refinement is proposed for a simpler stream- processing data-flow language. By contrast to our algebra, which encompasses the expression of temporal properties, it is limited to reasoning on input-output types and input-output causality graph.
The system JASS [5] is somewhat closer to our motivations and solution. It proposes a notion of trace, and a language to talk about traces. However, it seems that it evolves mainly towards debugging and defensive code generation. For em-
bedded systems, we prefer to use contracts for validating composition and hope to use formal tools once we have a dedicated language for contracts. Like in JML [17], the notion of agent with inputs/outputs does not exist in JASS, the language is based on class invariants, and pre/post-conditions associated with methods.
Our main contribution is to define a complete domain theoretical framework for assume-guarantee reasoning. Starting from a domain-theoretical characterization of behaviors and processes, we build a Boolean algebra of process-filters and a Heyting algebra of contracts. This yields a rich structure which is: 1/ generic, in the way it can be implemented or instantiated to specific models of computation; 2/ flexible, in the way it can help structuring and normalizing expressions; 3/ complete, in the
sense that all combinations of propositions can be expressed within the model.
Finally, a temporal logic that is consistent with our model, such as for instance the ATL (Alternating-time Temporal Logic [4]) can directly be used to express assumptions about the context of a process and guarantees provided by that process.

Conclusion
Starting from the choice of an abstract characterization of behaviors as functions from variables to a domain of values (Booleans, integers, series, sets of tagged values, continuous functions), we introduced the notion of process-filters to formally characterize the logical device that filters behaviors from process much like the assumption and guarantee of a contract do. In our model, a process p fulfils its requirements (or satisfies) (A,G) if either it is rejected by A (it is then out of the

scope of the contract (A,G)), or it is accepted by G.
Our main results are that the structure of process-filters is a Boolean algebra and that the structure of contracts is a Heyting algebra, respectively. This rich structure allows for reasoning on contracts with great flexibility to abstract, refine and combine them. Moreover, contracts are not limited to expressing safety prop- erties, as is the case in most related frameworks, but encompass the expression of liveness properties. This is all again due to the central notion of process-filter.
In the aim of assessing the generality and scalability of our approach, we are

designing a module system based on the paradigm of contract for
Signal
and

applying it to the specification of a component-based design process. The paradigm we are putting forward is to regard a contract as the behavioral type of a module or component and to use it for the elaboration of the functional architecture of a system together with a proof obligation that validates the correctness of assumptions and guarantees made while constructing that architecture.

References
Abramsky S. and A. Jung, Domain theory. In Handbook of logic in computer science (vol. 3): semantic structures, pages 1–168. Oxford University Press, 1997.
Alfaro L. and T. A. Henzinger, Interface automata. In ESEC / SIGSOFT FSE, pp. 109–120, 2001.
Andr´e C., F. Mallet, and M.-A. Peraldi-Frati, A multi-form time approach to real-time system modeling. Research Report RR 2007-14-FR, I3S, 2007.
Alur R., T. Henzinger, and O. Kupferman, Alternating-time Temporal Logic. In Journal of the ACM,
v. 49, ACM Press, 2002.
Bartetzko D., C. Fischer, M. M¨oller, and H. Wehrheim, Jass - Java with assertions. In Havelund, K., Rosu, G. eds : Runtime Verification, Volume 55 of ENTCS(1):91–108, 2001.
Bell J. L. Boolean Algebras and Distributive Lattices Treated Constructively, Math. Logic Quarterly 45, 1999.
Benveniste A., B. Caillaud, and R. Passerone, A generic model of contracts for embedded systems.
Research report N◦6214, INRIA-IRISA, S4 Team, 2007.
Broy, M. Compositional refinement of interactive systems. Journal of the ACM, v. 44. ACM Press, 1997.
Doyen L., T. A. Henzinger, B. Jobstmann, and T. Petrov, Interface theories with component reuse, In Proceedings of the 8th ACM & IEEE International conference on Embedded software, EMSOFT’08, 2008, pp. 79-88.
Edwards S., L. Lavagno, E.A. Lee, and A. Sangiovanni-Vincentelli, Design of Embedded Systems: Formal Models, Validation, and Synthesis. In Proceedings of the IEEE, 85(3), pages 366–390, 1997.
Flake S. and W. Mueller, An ocl extension for realtime constraints. In Lecture Notes in Computer Science 2263, pp. 150–171, 2001.
Glouche Y., P. Le Guernic, J.-P. Talpin, and T. Gautier, A boolean algebra of contracts for logical assume-guarantee reasoning. Research Report RR 6570, INRIA, 2008.
Glouche Y., J.-P. Talpin, P. Le Guernic, and T. Gautier, A module language for typing by contracts. In the Proceedings of the First NASA Formal Methods Symposium, Springer, 2009.
Hoare C.A.R. An axiomatic basis for computer programming. In Communications of the ACM, pp. 576–583, 1969.
Kopetz H. Component-Based Design of Large Distributed Real-Time Systems. In Control Engineering Practice, 6(1), pages 53–60, 1997.
Larsen K.G., U. Nyman, and A. Wasowski, Modal I/O automata for interface and product line theories. In Programmming Languages and Systems, 16th European Symposium on Programming, ESOP’07, ser. Lecture Notes in Computer Science, vol. 4421. Springer, 2007, pp. 64-79.
Leavens G. T., A. L. Baker, and C. Ruby, JML: A notation for detailed design. In Kilov H., Rumpe B., and Simmonds I., editors, Behavioral Specifications of Businesses and Systems, pp. 175–188. Kluwer Academic Publishers, 1999.


Lee E.A., and A. Sangionanni-Vincentelli, A framework for comparing models of computation. In IEEE transaction on computer-aided design, v. 17, 1998.
Le Guernic P., J.-P. Talpin, and J.-C. Le Lann, Polychrony for system design. Journal for Circuits, Systems and Computers, Special Issue on Application Specific Hardware Design, 2003.
Marchand, H., P. Bournai, M. Le Borgne, and P. Le Guernic, Synthesis of Discrete-Event Controllers based on the Signal Environment, Discrete Event Dynamic System: Theory and Applications, v. 10(4), 2000.
Marchand, H., E. Rutten, M. Le Borgne, and M. Samaan, Formal Verification of programs specified with Signal: Application to a Power Transformer Station Controller. Science of Computer Programming, v.
41(1). Elsevier, 2001.
Maraninchi F. and L. Morel, Logical-time contracts for reactive embedded components. In In 30th EUROMICRO Conference on Component-Based Software Engineering Track, ECBSE’04, Rennes, France, 2004.
Martin A. and L. Lamport, Composing specifications. In ACM Trans. Program. Lang. Syst. 15, pp. 73–132, 1993.
Mazurkiewicz A. Basic notions of trace theory. In Lecture Notes In Computer Science, v. 354, pp. 285–363, 1989.
Meyer B. Object-Oriented Software Construction, Second Edition. ISE Inc., Santa Barbara, 1997.
Mitchell R. and J. McKim, Design by Contract, by Example, Addison-Wesley, 2002.
Raclet J.-B., E. Badouel, A. Benveniste, B. Caillaud, and R. Passerone, Why are modalites good for Interface Theories? In 9th International Conference on Application of Concurrency, 2009.
Ziemann P. and M. Gogolla, An extension of ocl with temporal logic. In Critical Systems Development with UML-Proceedings of the UML’02 workshop, Technische Universita¨t Mu¨nchen, Institut fu¨r Informatik, 2002.
