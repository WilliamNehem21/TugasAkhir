

Electronic Notes in Theoretical Computer Science 192 (2008) 3–22
www.elsevier.com/locate/entcs
A Parametric Calculus for Mobile Open Code
Davide Ancona2, Sonia Fagorzi3 and Elena Zucca4
DISI
University of Genova, Italy

Abstract
We present a simple parametric calculus of processes which exchange open mobile code, that is, code which may contain free variables to be bound by the receiver’s code.
Type safety is ensured by a combination of static and dynamic checks. That is, internal consistency of each process is statically verified, by relying on local type assumptions on missing code; then, when code is sent from a process to another, a runtime check based on a subtyping relation ensures that it can be successfully received, without requiring re-inspection of the code. In order to refuse communication in as few cases as possible, the runtime check accepts even mobile code which would be rejected if statically available, by automatically inserting coercions driven by the subtyping relation, as in the so-called Penn translation. The calculus is parametric in some ingredients which can vary depending on the specific language or system. Notably, we abstract away from the specific nature of the code to be exchanged, and of the static and dynamic checks. We formalize the notion of type safety in our general framework and provide sufficient conditions on the above ingredients which guarantee this property.
We illustrate our approach on a simple lambda-calculus with records, where type safe exchange of mobile code is made problematic by conflicts due to components which were not explicitly required. In particular, we show that the standard coercion semantics given in the literature, with other aims, for this calculus, allows to detect and eliminate conflicts due to inner components, thus solving a problem which was left open in previous work on type-safe exchange of mobile code.
Keywords: Process calculi, mobile code, rebinding, dynamic typing, subtyping


Introduction
In a previous paper [8], we have presented a parametric calculus of processes which exchange mobile code in a type-safe manner. This calculus, built on a simple coordi- nation mechanism with standard send/receive primitives, formalizes in a language- independent setting the ideas advocated in MoMi [3,4,2]:
Each process statically checks type safety of its local code, by relying on require- ments on missing code, formally expressed by types.

1 Partially supported by MIUR EOS DUE - Extensible Object Systems for Dynamic and Unpredictable Environments.
2 Email: davide@disi.unige.it
3 Email: fagorzi@disi.unige.it
4 Email: zucca@disi.unige.it

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.024

Mobile code exchanged among processes is equipped with its type, obtained by the previous phase.
Dynamic checks ensure that code sent from a process to another is accepted only if it satisfies receiver’s requirements.
Hence, whenever code is accepted, it can be safely composed with local code without being inspected again.
The calculus is parametric in some ingredients which can vary depending on the specific language or system. Notably, we abstract away from the specific nature of the code to be exchanged (modeled by a core calculus), and of the static and dynamic checks.
We consider two distinct subtyping relations in our framework: the static sub- typing relation simply models subtyping which could be possibly provided by the static type system, whereas dynamic checks are modeled by a dynamic subtyping relation, which is intuitively expected to be more liberal. Indeed, in order to refuse communication in as few cases as possible, the runtime check accepts even mobile code which would be rejected if statically available, by automatically inserting coer- cions driven by the dynamic subtyping relation. In this way, mobile code exchange is both safe, since after coercion code has a statically permitted type, and flexible, since more code can be accepted.
In this paper we extend this previous work in two respects.
First, and more importantly, we extend the above ideas to the case where mobile code is open, that is, may contain free variables to be rebound in receiver’s code. To this end, the send primitive explicitly specifies a set of unbinders, that is, which variables in sent code have to be remotely bound, possibly discarding their local definitions, if any; and the receive primitive, conversely, specifies a set of rebinders, that is, which variables are allowed to be free in code to be received, also providing corresponding local definitions. That is, the unbinding/rebinding mechanism is controlled by the programmer (no accidental captures may happen), analogously to what has been proposed, e.g., in [6].
Mobile code is now equipped with, besides its type, a type context specifying expected types for free variables. The runtime check becomes symmetric, since mobile code must satisfy receiver’s requirements, and conversely the receiver must provide appropriate definitions for the free variables. More interestingly, coercions are inserted in both directions as well.
Second, we realized that our approach for modeling flexible and type safe mobile code exchange, that is, by coercions driven by a subtyping relation, is the same which can be used, mainly with performance reasons, for compiling source code with subtyping in lower-level code without subtyping, see Sect.15.6 of [13]. In this context, the translation which inserts run-time coercions is often called the
Penn translation, after the group at the University of Penn that first studied it
[7]. Recognizing this coincidence leaded to a much cleaner presentation of our framework. Moreover, and more substantially, in one classical case-study, that is,

when mobile code to be exchanged has a record-based structure 5 , and type safe exchange of mobile code is made problematic by conflicts due to components which were not explicitly required, choosing a runtime check based on the Penn translation found in the literature allows to simply and nicely express detection and elimination of conflicts due to arbitrarily nested components, whereas in previous work on type safe exchange of mobile code [4,8] only top-level conflicts were considered.
The rest of the paper is organized as follows: we first present the untyped version of our calculus in Sect.1, then add static and dynamic checks in Sect.2. We formalize the notion of type safety in our parametric framework and provide
sufficient conditions on the ingredients to be provided as arguments which guarantee this property. In Sect.3 we formally define an instantiation which takes a simple lambda-calculus with records as core calculus, and coercions which delete, at any
nested level, components which were not explicitly required 6 . Finally, in Sect.4 we
summarize our contribution and briefly discuss related and further work.

1	The Untyped Calculus
The untyped calculus for exchange of mobile open code is defined in a parametric way on top of a core calculus providing the following ingredients:
variables x , y, z,... ∈ Var;
(core) expressions e ∈ Expc, with Var ⊆ Expc; a substitution ρ is a mapping from variables into (core) expressions, written xi i→∈I ei, ; 
free variables FV (e) of an expression e;
application of a substitution ρ to an expression e, written e{ρ};

(core) reduction relation e −→c
e'.

The syntax is given in Fig.1. Since the focus of our framework is on dynamic retrieval and typechecking of open code, we consider a very simple coordination mechanism based on standard synchronous send/receive primitives. In particular,
a process can be, besides a process variable, the null process nil, a parallel com-
position of processes, a sending or a receiving process. A process send([xi∈I ]E ).p sends open code E (which can be either core code or in turn a process) with free
variables (contained in) x i∈I . Conversely, a process receive(x [xi i→∈I Ei]).p receives open code, say E , and makes it close by binding free variables in E as specified by the substitution xi i→∈I Ei (a mapping from variables into expressions); the resulting
code is available in the subsequent process p via x . Note that we keep the language
as simple as possible, hence do not consider additional syntactic constructs (e.g., let-in) which could be useful in practice, but are not significant to our aim.
We will use the following notations for mappings (e.g., substitutions): ρ \ x is the map obtained from ρ by removing the association for x (if present); ρ1, ρ2 is the

5 For instance, when exchanging records, objects, classes, mixins: in this paper we will study the problem in the more foundational context of records for simplicity.
6 Corresponding, as explained above, to the Penn translation found in the literature.

p ∈ Proc ::= x | nil | p1p2 |	process
send([υ]E ).p | receive(x [ρ]).p


i






Fig. 1. Untyped calculus: syntax

union of substitutions ρ1 and ρ2 with disjoint domains. Moreover, we will use the following abbreviations:
send(E ).p for send([ ]E ).p, that is, when sent code is closed,
receive(x ).p for receive(x [ ]).p, that is, when received code must be closed,
receive(x [ρ, y ]).p for receive(x [ρ, y '→ y ]).p, that is, when a variable in received code is bound to an outer binder in local code (see below).

Reduction semantics of process terms is modeled by a labelled relation p −→λ
p' where

the label is either τ , denoting an internal step, or ![υ]E , ?[υ]E , denoting, respectively, sending and receiving an expression E with free variables υ. An internal step occurs
as effect of either a reduction step at the core level, or an exchange of code in a parallel composition of processes (see below).
We denote by λ the complement of λ, defined for λ /= τ in the usual way. Moreover, we will use on labels the same abbreviations used for processes and write
?E and !E when υ is empty.
Before giving the formal reduction rules, we illustrate how exchange of mobile code works by some examples.
First of all, consider the following parallel composition:
send([x ]x + 1).nil  receive(y [x '→ 2]).send(y).nil
The left-side process sends open code x + 1, whereas the right-side process is willing to receive code with a free variable x to be locally bound to 2. As a result of synchronization between the two processes, the right-side process replaces y by the code sent by the left-side process, where x has been in turn replaced by 2, hence 2 + 1 is then sent. Formally we have the following reduction sequence:
send([x ]x + 1).nil	receive(y [x '→ 2]).send(y).nil −→τ

nil	send(2+ 1).nil −!−2+−→1
nil	nil

Note that in the calculus there are three different kinds of binders: in a process
receive(x [xi i→∈I Ei]).p, x binds subsequent local code p, whereas the x i∈I will (re)bind
dynamically received code; in a process send([xi∈I ]E ).p, the x i∈I bind sent code E ,
i	i
in such a way that free occurrences of x i∈I are unbound from their local binders, if any. We will call these three kinds of binders local binders, rebinders, and unbinders, respectively. In the process p above, the first occurrence of x is an unbinder, the first occurrence of y is a local binder, and the third occurrence of x is a rebinder.
A local binder can also affect subsequent dynamically received code, when it binds free variables in a rebinding ρ, as shown by the following example:
receive(x ).receive(y [x ]).send(y + x ).nil −?→2 receive(y [x '→ 2]).send(y + 2).nil −−−−→ send(2 ∗ 3+ 2).nil
In this example, note the use of the abbreviation y [x ], which means that free variable x in received code will be bound to a definition which is still to be received as well. This abbreviation formally stands for y [x '→ x ]. It is also worth noting that, since the process send(y + x ).nil has no unbinders specified, both y and x must be locally
replaced before sending the code; compare with the following reduction sequence where x is unbound instead.
receive(x ).receive(y [x ]).send([x ]y + x ).nil −?→2 receive(y [x '→ 2]).send([x ]y + x ).nil −−−−→ send([x ]2 ∗ 3+ x ).nil
The following example illustrates the case where mobile code is in turn a process.
receive(x ).send( receive(y [x ]).send(y + x ).nil ).nil −?→1
send( receive(y [x '→ 1]).send(y + 1).nil ).nil
Finally, the following example shows that a local binder can affect not only dy- namically received code but also, in case process code is received, code dynamically received by this code, and so on.
receive(x ).receive(y [x ]).y −?→1
?[x ]send(x +2).receive(z [x ]).z
receive	'→	. −−−−−−−−−−−−−−−−−→
send(1+ 2).receive(z [x '→ 1]).z
Before formally defining the reduction relation, we extend, in Fig.2, the definitions of free variables and application of a substitution, provided as ingredients at the core level, to mobile code. We denote by ρc the subset of substitution ρ mapping
variables into core expressions. Conditions υ ∩ FV (ρ) = ∅ and x /∈ FV (ρ) avoid
unexpected captures of free variables in ρ.
Reduction rules are defined in Fig.3. Rules (core-send) and (core-rcv) allow reduc-

p x
nil
send([υ]E ).p
receive(x [ρ]).p
p1 p2

E
e x , x /∈ dom(ρ) x , x ∈ dom(ρ)
nil
p1 p2
send([υ]E').p,υ ∩ FV (ρ) = ∅
receive(x [ρ']).p, x /∈ FV (ρ)
FV (p)
{x }
∅
(FV (E ) \ υ) ∪ FV (p)
FV (ρ) ∪ (FV (p) \ {x })
FV (p1) ∪ FV (p2)
E {ρ}
e{ρc} x ρ(x ) nil
p1{ρ}p2{ρ}
send([υ]E'{ρ\υ}).p{ρ}
receive(x [ρ'{ρ}]).p{ρ\{x }}



Fig. 2. Untyped calculus: free variables and substitution




(core-send)
e −→c
send([υ]e).p −→τ
e'
send([υ]e').p

(send)

send([υ]E ).p −−−→ p

FV (E )⊆υ



(core-rcv)
e −→c
receive(x [ρ, y '→ e]).p −→τ
e'
receive(x [ρ, y '→ e']).p

(rcv)

receive(x [ρ]).p −−−→ p{x '→ E {ρ}}
υ⊆dom(ρ)


(par-left)
p1 −→λ	'


(par-right)
p2 −→λ	'


(sync)
p1 −→λ


'  p2 −→λ	'

p1p2 −→λ
'  p2
p1p2 −→λ
p1p'
p1p2 −→τ	'   '

Fig. 3. Untyped calculus: reduction rules
tion at the core level. Note that core code can be either sent or further reduced in a non deterministic way, and analogously for core code in a rebinding. This means that we do not care about where core mobile code is executed, either by the sender or the receiver, even though this will of course make a difference in practice, e.g., in case of non termination. Sending a process term, instead, intuitively means sending coordination code to be executed by the receiver.

In rule (send), mobile code can be sent only if it does not contain free variables apart from those specified by the unbinders. That is, unbinders are used by the programmer to specify whether a variable has to be bound locally or remotely, as illustrated by the second example above.
In rule (rcv), mobile code can be received only if all variables declared as free are explicitly rebound in receiver’s code. That is, rebinders are used by the programmer to control which free variables in mobile code can be accepted, thus preventing accidental captures. Rules (par-left), (par-right) and (sync), are straightforward.
The use of explicit unbinders and rebinders guarantees that exchange of open code does not introduce unbound variables (of course, provided that core reduction does neither), as stated below.

Assumption 1 (Core Free Variables) If e −→c
e', then FV (e') ⊆ FV (e).

Proposition 1.1 (Free Variables) Under Assumption 1:

If p −→τ
p', then FV (p') ⊆ FV (p).

We prove the above proposition as a case of the following, which takes into account communication steps with the outside world. Intuitively, when receiving code E , no unbound variables are introduced only if E has no more free variables than those it declares. Conversely, code sent to the external world has no more free variables than those it declares (this is inductively used to prove the property on internal steps).
Proposition 1.2 Under Assumption 1:

If p −→τ
p', then FV (p') ⊆ FV (p).

![υ]E


?[υ]E
−−−→
' and FV (E ) ⊆ υ, then FV (p') ⊆ FV (p).

Proof. By induction on reduction rules. We show the most interesting cases:

( core-send) We have that send([υ]e).p −→
follows by Assumption 1.
send([υ]e').p and e −→c
e'. Hence the thesis

( send) We have that send([υ]E ).p −−−→ p, with FV (E ) ⊆ υ. Hence the thesis trivially follows.
( rcv) We have that receive(x [ρ]).p −−−→ p{x '→ E {ρ}}, with υ ⊆ dom(ρ). Since, by hypothesis, FV (E ) ⊆ υ, we have FV (E ) ⊆ dom(ρ); hence, FV (E {ρ}) ⊆ FV (ρ) and the thesis trivially follows.
 
We conclude this section with two slight variants, expressed in our framework, of examples presented in [6] (Fig. 5) to show rebinding scenarios in distributed systems. We assume the core calculus to include expressions of string, unit and functional types (we write some type annotations as an help to the reader, but types are not relevant here), and we enrich the process syntax with the construct

let ρ in p, with the usual semantics.
Let us consider the process let print: string → unit '→ ... in (p1p2), where:
p1 = let here: string '→ “site 1” in
send(print here: unit).send([here]print here: unit).nil
p2 = receive(c[here '→ “site 2”]: unit).send(c: unit).nil This process reduces as follows:
−→τ  let print ... in (send(print “site 1”: unit).send([here]print here: unit).nil  p2)
!print “site 1”:unit
−−−−−−−−−−−→ let print ... in send here print here unit .nil	2

−→τ
!print “site 2”:unit
let print ... in nil send print site 2	unit .nil −−−−−−−−−−−→

Hence, in the left-hand side process, variable here is first sent to be printed with
its local definition, i.e. ,“site 1”, then is sent and rebound at a remote site to the label “site 2”.
Let us now consider a variant of the process above, able to perform a customized linking. This is obtained by changing the definition of p2 in the following way:
p2 = receive(c[here '→ e]: unit).send(c: unit).nil where e = if trusted() then “site 2” else “site 33”.
Here, p2 has two possible rebindings for the variable here: the real site name “site
2” for trusted programs and the fake name “site 33” for untrusted ones. Which rebinding to perform is determined by the hypothetical function trusted, which takes into account some security criteria, such as the origin of the message.
It is worth to note that in our framework the rebinding is obtained without any need of a lazy semantics for the substitution, as instead happens in [6], where a delayed instantiation is required.

2	The Typed Calculus
To define the typed calculus, we need the following additional core ingredients:
(core) types t ∈ Typec,
(core) type judgment Γ ▶c e : t , where Γ is a type context, that is, a mapping from variables into (core) types, written xi : t i∈I ,
static subtyping relation ▶ t ' ≤s t , required to be a preorder.
dynamic subtyping relation ▶ t ' ≤d t ~ T , where T is a partial mapping, called
coercion, T : Expc → Expc.
Dynamic subtyping is expected to accept more terms than static subtyping, and coercion consequently adapts the received code to the local context; indeed, mobile code exchange requires, besides dynamic checks guaranteeing type safety, also the ability of the system to dynamically modify code.
Intuitively, we expect static and dynamic subtyping to satisfy a number of prop- erties, such as:

if ▶ t ' ≤d t ~ T , then coercion T transforms expressions of (a static subtype of) type t ' to expressions of (a static subtype of) type t , and is undefined on other
expressions;
in ▶ t ' ≤d t ~ T , the pair t ', t uniquely determines T ,
≤d is a preorder as well,
▶ t ≤d t ~ id (the identity mapping),
if ▶ t ≤d t ' ~ T , ▶ t ' ≤d t '' ~ T ', ▶ t ' ≤d t '' ~= T ' ◦T 7
≤s is a subset of ≤d, and ▶ t ≤d t ' ~ id whenever ▶ t ≤s t '.
However, we do not formally assume here any of the above properties, since they are not necessary for our main result, that is, type safety (Theorem 2.4), which can be proved under somewhat weaker assumptions, see Assumption 3 and Assumption 5. We leave to further work the investigation of other significant requirements the framework should satisfy which will likely explicitly require some, if not all, of the assumptions as above.
As mentioned in the Introduction, coercions driven by a subtyping relation are also used, mainly with performance reasons, for compiling source code with subtyp- ing in lower-level code without subtyping, see Sect.15.6 of [13]. In this context, the
translation which inserts coercions is often called the Penn translation [7]. Apart
from the different context and aims, our presentation here differs for some other reasons.
First, our technical treatment is lighter, since, following the style of recent work where type-checking is generalized to compilation, as, e.g., [1], we pack relation between types and coercion in a unique “compilation” judgment, which we expect to be inductively defined in instantiations of the framework, as, for instance, we do in Sect.3.  In [13], on the contrary, the translation is modeled as a function
which takes derivations of subtyping judgments as arguments.  Another drastic
simplification is that we need to insert coercions only in a single situation, that is, when receiving code, whereas in the original Penn translation coercions must be inserted in a term everywhere there is a subterm of a certain type which appears in a context of a supertype. The technical counterpart of this simplification is that our coercion function can take just terms as arguments, instead of requiring to keep the typing judgment of the term as in [7].
Second, and more interestingly, since we handle open terms, subtyping is natu- rally extended to contexts and coercions are inserted in both directions. We believe this is a nice and important generalization of the coercions-driven-by-subtyping approach.
Finally, whereas the original approach is purely syntactic, that is, coercions are expressed as terms of the lower-level language (e.g., λ-abstractions), here, since our aim is to define an abstract framework where core language is not fixed, we take an extensional approach, where coercions are modeled as functions from terms into

7 These properties altogether amount to say that there is a functor from the category which has types as objects and ≤d as arrows to the subcategory of Set which has as objects the sets of expressions of (a static subtype of) a certain type.

p ∈ Proc	::= x | nil | p1p2 | send(Γ▶[υ]E : T ).p |	process
receive(Γ▶ x [ρ]: T ).p
Fig. 4. Typed calculus: syntax



▶ Ti ≤s T', i ∈ I'




I' ⊆ I (implicit)

▶⬦ ≤ ⬦	▶ x :T i∈I ≤
x :T 'i∈I'

s	i i
s  i  i
▶ Ti ≤d T' ~ Ti, i ∈ I'	'

T (p) = p	i	T (x i→∈I E ) = x i'→∈I T (E )



▶⬦ ≤d ⬦ ~ T

'	i	i	i	i	i
▶ xi:Tii∈I ≤ x :T 'i∈I ~ T

Fig. 5. Typed calculus: subtyping
terms. The fact that coercions could be internalized in the language or not will then depend on the specific instantiation of the framework: for instance, in the following section we will present an instantiation on a simple λ-calculus with records where coercions are expressed by λ-abstractions as in the original approach.
The syntax of the typed calculus is in Fig.4. The main novelty w.r.t. the untyped version is that mobile code is annotated with a type context Γ (mapping variables into types) and a type T . Types are either core types or the process type ⬦. As
well-formedness condition, in send and labels we assume υ = dom(Γ), and in receive
we assume dom(ρ) = dom(Γ). Hence, υ is redundant, but we keep it for uniformity with the untyped version.
We will use the following additional notations for mappings (e.g., type contexts): dom(Γ) is the domain of Γ; Γ[Γ'] is the mapping obtained by updating Γ with the associations in Γ'.
In Fig.5, we extend subtyping relations to the process type and to type contexts. The process type is in relation only with itself and the corresponding coercion is the identity. Subtyping relations on type contexts are defined in the natural pointwise way and the associated coercion transforms substitutions of the subtype context into substitutions of the supertype context (substitutions have contexts as types, see rule (t-subst) in Fig.7).
Reduction rules for the extended calculus are in Fig.6. They are a straightfor- ward extension to annotated mobile code of those seen for the untyped calculus,






(core-send)
e −→c
send(Γ▶[υ]e : t ).p −→τ
e'
send(Γ▶[υ]e' : t ).p

(send)

send(Γ▶[υ]E : T ).p −−−−−−→ p
FV (E ) ⊆ dom(Γ)


(core-rcv)



(rcv)
e −→c
receive(Γ▶ x [ρ, y '→ e]: T ).p −→τ
e'
receive(Γ▶ x [ρ, y '→ e']: T ).p
▶ T' ≤d T ~ T '

'	'
receive(Γ▶ x [ρ]: T ).p −−−−−−−→ p{x '→T '
(E {T (ρ)})}
▶Γ ≤d
Γ' ~ T


(par-left)
p1 −→λ	'

(par-right)
p2 −→λ	'

(sync)
p1 −→λ


'  p2 −→λ	'

p1p2 −→λ
'  p2
p1p2 −→λ
p1p'
p1p2 −→τ	'   '

Fig. 6. Typed calculus: reduction rules
except for (rcv), which is the key rule illustrating our approach. The side condition expresses the fact that incoming code E can be retrieved only if its type information Γ', T' is compliant with that specified by the receiver Γ, T , as formally expressed by the subtyping relation. In this case, appropriate coercions are inserted before combining E with local code, to bridge the gap between provided and required type information. 8
More precisely, all variables explicitly declared as free in the incoming code are rebound to local definitions via coercion from the provided type context Γ to the expected type context Γ'; then, the resulting (now closed since FV (E ) ⊆ υ =
dom(Γ') and dom(Γ') ⊆ dom(Γ)) expression is substituted in local code via coercion
from the declared type T' to the required type T .
Typing rules, given in Fig.7, are straightforward. In rule (t-core), we denote by Γc the subset of a context Γ which maps core variables into core types. Rule (t-send) allows sending of code which has a static subtype of that it declares, and conversely rule (t-rcv) allows the rebinding to have a static subtype of that declared. Recall also that by well-formedness conditions we have dom(Γ2) = υ in rule (t-send) and dom(Γ2) = dom(ρ) in rule (t-rcv).
We illustrate now how dynamic subtyping and coercion work by an example, where we consider the instantiation of the framework which will be formally detailed in the following section. That is, we assume that expressions of the core calculus include numbers and records with a sum (concatenation) operator denoted by + and standard record types. Consider the process:
receive(y : posint▶ x [y '→ 1] :{X : int,Y : int} ).send(x + {Z : 3}).nil

8 For simplicity, here communicating something of a wrong type corresponds to no reduction at all; a more realistic model should include reduction into a distinguished error term of either the receiver only or the communicating pair.


(t-subst)
Γ▶ Ei : Ti,i ∈ I
Γ▶ xi i→∈I Ei : xi:Tii∈I


(t-core)
Γc ▶c e : t Γ▶ e : t

(t-var-proc)
Γ▶ x : ⬦
Γ(x )= o
(t-nil)


Γ▶nil: ⬦


(t-par)
Γ▶ p1 : ⬦ Γ▶ p2 : ⬦
Γ▶ p1p2 : ⬦

(t-send)
Γ1[Γ2] ▶ E : T' Γ1 ▶ p : ⬦ ▶ T' ≤s T


Γ1 ▶send(Γ2 ▶[υ]E : T ).p : ⬦


(t-rcv)
Γ1[x:T ] ▶ p : ⬦	Γ1 ▶ ρ :Γ	▶Γ ≤s Γ2 Γ1 ▶receive(Γ2 ▶ x [ρ]: T ).p : ⬦
Fig. 7. Typed calculus: typing rules



and assume that code ?y : int ▶ [y ]{X : 0,Y : y, Z : 2} : {X : int,Y : int,Z : int} is received.
We ensure type safe exchange of mobile code by a runtime check analogous to that considered in [4] for mixin classes, to solve the classical problem of interference in record/object types. That is, dynamic subtyping corresponds to standard width subtyping on record types, together with a coercion function which removes addi- tional fields 9 . Then, the type declared by mobile code is a subtype of the expected type, hence communication can take place. Mobile code is adapted to the local code by the following steps. First, y is replaced in the received code via coercion from
posint to int, which is the identity, obtaining {X : 0,Y : 1,Z : 2}. Then, x is replaced in the local code via coercion from {X : int,Y : int,Z : int} to {X : int,Y : int}, obtaining a safe record extension in send({X : 0,Y : 1} + {Z : 3}).nil.
The combination of the static type system and the dynamic checks should ensure type safety, that is, that internal steps can never lead to ill-formed process terms (for steps of communication with the “external world” this requires to be confident
on the fact that received code complies with its accompanying type information, see below). 10
Definition 2.1 (Type Safety) Exchange of mobile code is type safe if the follow- ing (SR) property holds:

If Γ▶ p : ⬦ and p −→τ
p', then Γ▶ p' : ⬦.

We list now a number of assumptions the core calculus should satisfy in order to have type safety. They are mostly standard properties, plus Assumption 5, which states that, whenever the dynamic check on core mobile code succeeds (that is, its declared type is in the dynamic subtyping relation with the required type), this code

9 If objects rather than (non recursive) records are considered, additional fields must be frozen rather than just removed, see [8] for details.
10 Note that in distributed scenarios type safety, usually expressed by subject reduction (SR) and progress properties [9], reduces to SR (as in, e.g., [14,10]), since ensuring progress would require a sophisticated static analysis (deadlock detection).

can be safely incorporated with local code via the corresponding coercion function.

Assumption 2 If Γ ▶c e : t, x /∈ dom(Γ), then e{x '→ e' } = e.
Assumption 3 (Core Weakening) If Γ ▶c e : t and ▶ Γ' ≤s Γ, then Γ' ▶c e : t ', with
▶ t ' ≤s t. Moreover, if FV (e) ∩ dom(Γ') = ∅, then Γ[Γ'] ▶ e : t. 

Assumption 4 (Core SR) If Γ ▶c e : t and e −→c
e', then Γ ▶c e' : t ' for some ▶ t ' ≤s t. 

Assumption 5 (Core Coercion Substitution) If Γ[x:tx ] ▶c e : t, Γ ▶c e' : t '', ▶
t '' ≤s t ' , and ▶ t ' ≤d tx ~ T , then Γ ▶c e{x '→T (e')}: t ', for some ▶ t ' ≤s t. 
x	x	x

Here tx is the required type, t '
the type declared by the mobile code and t ''
its

actual type.
We now give some useful lemmas.
Lemma 2.2 (Weakening) If Assumption 3 holds, then if Γ▶ E : T and ▶Γ' ≤s Γ, then Γ' ▶ E : T', with ▶ T' ≤s T; moreover, if FV (E ) ∩ dom(Γ') = ∅, then Γ[Γ'] ▶ E : T. 
Lemma 2.3 (Coercion Substitution) Under assumption 5, if Γ[x:Tx ] ▶ E : T, 
Γ▶ E' : T '', ▶ T '' ≤s T' , and ▶ T' ≤d Tx ~ T , then Γ▶ E {x '→T (E')}: T', for some
x	x	x	x
▶ T' ≤s T. 
Proof. By induction on typing rules. We show the most interesting cases.
(t-var-proc) We have that Γ[x:Tx ] ▶ y : ⬦ and (Γ[x:Tx ]) (y ) = ⬦, and thus either x = y ,
hence Tx = T' = T '' = ⬦, E' is a process p', ▶⬦ ≤d ⬦ ~ id, y {y '→id(p')} = p'
and Γ▶ p' : ⬦ holds by hypothesis, or x /= y , and thus y {x '→T (E')} = y , Γ(y ) = ⬦, and Γ▶ y : ⬦ holds by applying typing rule (t-var-proc).
(t-nil) Trivial.
(t-send) We have that Γ[x:Tx ] ▶send(Γ2 ▶[υ]E : T ).p : ⬦ (1), and Γ[x:Tx ][Γ2] ▶ E : T',
(2) ▶ T' ≤s T , dom(Γ2) = υ and Γ[x:Tx ] ▶ p : ⬦ (3). By applying the inductive hypothesis to (3), we get Γ ▶ p{x '→T (E')} : ⬦ (4). There are two cases to be considered. If x ∈ dom(Γ2), we can conclude by applying the typing rule (t-send) to (1) and (4). Otherwise, for definition of substitution, dom(Γ2) ∩ FV (E') = ∅, hence, by applying Lemma 2.2 to the hypothesis Γ ▶ E' : T '', we get Γ[Γ2] ▶ E' : T ''. We can now apply the inductive hypothesis to (2) obtaining Γ[Γ2] ▶ E {x '→T (E')} : T '' (5), for some ▶ T '' ≤s T'. Then, since ≤s is a preorder, we have ▶ T '' ≤s T and we get the thesis by applying typing rule (t-send) to (4) and
(5).
(t-core) We have that Γ[x:Tx ] ▶ e : t . Moreover, if Tx = ⬦ then Γcore ▶c e : t , hence, by Assumption 2, we have e{x '→T (E')} = e and the thesis follows by applying rule (t-core). Otherwise, Tx is a core type tx, hence Γcore[x:tx ] ▶c e : t . Then, T'

must be a core type t '
as well, ▶ t '
≤d tx ~ T and E' a core expression e', and

by Assumption 5 we get Γcore ▶c e{x '→T (e')}: t ', for some ▶ t ' ≤s t . Hence, we get
the thesis by applying typing rule (t-core).
(t-rcv) We have that Γ[x:Tx ] ▶ receive(Γ2 ▶ y [ρ]: T ).p : ⬦ (1), and Γ[x:Tx ][y:T ] ▶ p : ⬦

(2), Γ[x:Tx ] ▶ ρ : Γ, and ▶ Γ ≤s Γ2 (3). We apply the inductive hypothesis to all y ∈ dom(ρ) in (3) obtaining Γ ▶ ρ{x '→T (E')} : Γ' (4) for some ▶ Γ' ≤s Γ. Hence, since ≤s is a preorder, ▶Γ' ≤s Γ2. There are two cases to be considered. If x = y , then the thesis follows by applying typing rule (t-rcv) to (2) and (4). Otherwise, for definition of substitution we know that y /∈ FV (E'), hence, by applying
Lemma 2.2 to the hypothesis Γ▶ E' : T '', we get Γ[y:T ] ▶ E' : T '' (5). We can now
x	x
apply the inductive hypothesis to (2) and (5) obtaining Γ[y:T ] ▶ p{x '→T (E')}: ⬦
(6), and conclude by applying typing rule (t-rcv) to (4) and (6).
(t-par) Trivially by inductive hypothesis.	 
Theorem 2.4 If assumption 5 holds, then exchange of mobile code is type safe.
We prove type safety as a case of the following generalized type safety which takes into account communication steps with the outside world. Intuitively, when receiving code E , safety is guaranteed only if E actually complies its accompanying type information Γ, T . We assume here to trust this type information to be correct: a more sophisticated approach would require a proof, as in [12]. Conversely, we can prove that code sent to the external world always complies the declared type information (this is inductively used to prove safety of internal steps).
Proposition 2.5 Under assumption 5:

If Γ▶ p : ⬦ and p −→τ
p', then Γ▶ p' : ⬦.

If Γ
▶ p : ⬦ and p !Γ2▶[υ]E :T
p', then Γ
▶ p' : ⬦, Γ [Γ ] ▶ E : T', for some ▶ T' ≤ T. 

1	−−−−−−→
1	1	2	s

If Γ
▶ p : ⬦, p ?Γ2▶[υ]E :T
p', and Γ [Γ ] ▶ E : T', with ▶ T' ≤
T, then Γ
▶ p' : ⬦.

−−−−−−−→	1	2	s	1
Proof. By induction on reduction rules. We show the most interesting cases.

(core) We have that send(Γ2 ▶ [υ]e : t ).p −→
send(Γ2 ▶ [υ]e' : t ).p, e −→c
e', and, since

we must have applied typing rules (t-send) and (t-core), Γ1 ▶send(Γ2 ▶[υ]e : t ).p : ⬦, (Γ1[Γ2])core ▶c e : t ', ▶ t ' ≤s t , dom(Γ2) = υ and Γ1 ▶ p : ⬦. Since SR holds for the core calculus (Assumption 4), we get that (Γ1[Γ2])core ▶c e' : t '', with ▶ t '' ≤s t ', and, since ≤s is a preorder, ▶ t '' ≤s t . Hence by applying typing rules (t-core) and (t-send) the thesis follows.
(send) We have that send(Γ2 ▶ [υ]E : T ).p −−−−−−→ p, with FV (E ) ⊆ dom(Γ2); moreover, we have Γ1 ▶ send(Γ2 ▶ [υ]E : T ).p : ⬦. To derive this last judgment, we must have applied typing rule (t-send), hence Γ1 ▶ p : ⬦ and Γ1[Γ2] ▶ E : T', with
▶ T' ≤s T .
(rcv) We have that


'	'
receive(Γ2 ▶ x [ρ]: T ).p −−−2 −−−−→ p
 x '→T 
 E T '(ρ)
} }

with▶ T' ≤d T ~ T and▶Γ2 ≤d Γ' ~ T ' (1); moreover, we have Γ1 ▶receive(Γ2 ▶
x [ρ]: T ).p : ⬦ (2) and Γ1[Γ' ] ▶ E : T '' (3), with ▶ T '' ≤s T' (4). To derive (2), we must have applied typing rule (t-rcv), hence Γ1[x:T ] ▶ p : ⬦ (5), Γ1 ▶ ρ : Γ,

▶ Γ ≤s Γ2 (6) and dom(ρ) = dom(Γ2) (7). We can apply Lemma 2.3 to (3) and all y in (6) (note that dom(ρ) = dom(Γ2) ⊆ dom(Γ' ) from (1) and (7)), with
▶ Γ2(y ) ≤d Γ' (y ) (from (1)), obtaining Γ1 ▶ E {T '(ρ)} : T ''' (8), with ▶ T ''' ≤s T ''
(9). Since ≤s is a preorder, from (9) and (4) we get ▶ T ''' ≤s T' (10). We can
now conclude by applying Lemma 2.3 to (5) and (8), with (1) and (10).

3	A case study: lambda calculus with records
A case-study in exchange of mobile code which has been extensively studied [4,3,2,8] is when code to be exchanged has a record-based structure (records, objects, classes, mixins), and type safety is made problematic by conflicts due to components which were not explicitly required. For instance, in MoMi [4,3,2] mobile code consists in mixin classes, and conflicts are avoided by a renaming mechanism which, essentially, hides unexpected components to receiver’s code. In [8], we have formalized this kind of solution (on mixin modules rather than classes) as one instantiation of our parametric framework for type safe exchange of mobile code.
However, in this previous work only top-level conflicts were detected and avoided, whereas at nested levels width subtyping was simply not allowed. For instance, given as expected type {X:{Y : int}}, the type {X:{Y : int} ,Z : int} was accepted (and Z
removed), while {X:{Y : int,Z : int}} was rejected.
In this section, we show that a runtime check based on the Penn translation found in the literature allows for simple and nice detection and elimination of conflicts due to arbitrarily nested components. For simplicity, we illustrate the approach on the more foundational example of records, but the same technique could be easily adapted to objects, classes or mixins: in these cases, to take into account mutual recursion, additional fields must be hidden rather than just removed, see [8] for details.
Formally, we present an instantiation of the framework introduced in the pre- vious sections which takes as core calculus a simple λ-calculus with records, as static subtyping depth subtyping, and as dynamic subtyping depth/width subtyping with a coercion function which removes additional fields. We call the instantiation MoRecdel (for “MObile RECords where unexpected fields are DELeted”).
The syntax of the core calculus is given in Fig.8. We assume, besides variables, an infinite set Field of ﬁeld names. Terms of the calculus are built by (unspecified) operators of basic types, standard operators of lambda calculus, and records with three operators: sum, delete and selection. A record is a map from field names to expressions.
The reduction relation is given in Fig.9, where we omit standard contextual closure.
Reduction rules are straightforward: rule (app) is standard application (we are not interested in fixing an evaluation strategy here), rule (sel) allows selection of an existing field, rule (sum) performs the union of two records if their sets of field names are disjoint, rule (del) removes a field from a record (if present).



X, Y, Z, ... ∈ Field	field name
x, y, z,... ∈ Var	variable
e ∈ Expc	::=	expression
...	basic operators
|	x | λx. e | e1e2 lambda calculus operators
|	{fs}	record
|	e1 + e2	sum
|	e \ X	delete
|	e.X	selection
fs	:= Xi i→∈I ei	fields
Fig. 8. MoRecdel: syntax



(app)
(λx. e1)e2 −→c
e1{x '→ e2}
(sel)
{fs} .X −→c
fs(X)



(sum)
{fs } + {fs } −→c {fs ,fs }
dom(fs1) ∩ dom(fs2)= ∅
(del)
{fs}\ X −→c
{fs\X}

1	2	1
2
Fig. 9. MoRecdel: reduction rules



The λ-calculus with records, with all required ingredients (variables, expressions, substitution application and reduction relation) can be used as a core calculus for the untyped parametric coordination calculus illustrated in Sect.1, since it satisfies the required assumption.
Theorem 3.1 Assumption 1 of Sect.1 is satisﬁed, that is:

If e −→c
e', then FV (e') ⊆ FV (e).

Proof. By induction on reduction rules.	 
We give now the static type system and the runtime check for MoRecdel. We assume that the syntax of Fig.8 is enriched with a type annotation for the lambda abstraction binder, as usual in the typed λ-calculus.
Typing rules are in Fig.10. Types include (unspecified) basic types and func- tional and record types. A record type consists of a signature Σ which is a map from field names into types.
In Fig.11 we define the subtyping relations. It is worth to note that, analogously to what happens in [13], in MoRecdel coercion can be internalized, hence we consider dynamic subtyping judgments having form ▶ t ' ≤d t ~ f, with f ∈ Expc (we use a different metavariable to stress that f will be an expression of a functional type).
Both static and dynamic subtyping are the usual subtyping on functional types (that is, contravariant in the input and covariant in the output) and both allow



t ∈ Typec ::=	type
...	basic types
|	t1 → t2	functional type
|	{Σ}	record type
Σ	:= Xi : ti i∈I  signature





(t-var)



(t-lambda)

Γ[x:t1] ▶c e : t2
Γ ▶c e1 : t2 → t
 Γ ▶c e2 : t '
(t-app)	▶ t ≤ t



Γ ▶c x : Γ(x )


Γ ▶c λx :t1. e : t1 → t2
Γ ▶c ei : ti, i ∈ I
Γ ▶c e1e2 : t
s 2

(t-record)
Γ ▶c
Xi i→∈I ei,:
 Xi : ti i∈I }


(t-sum)
Γ ▶c ei :{Σi} , i ∈ 1, 2 Γ ▶c e1 + e2 :{Σ1,Σ2}
Γ ▶c e :{Σ}

dom(Σ1) ∩ dom(Σ2)= ∅


Γ ▶c e :{Σ}

(t-del)
Γ ▶c e \ X :{Σ \ X}
(t-sel)


Γ ▶c e.X : Σ(X)

Fig. 10. MoRecdel: type system



basic
subtyping rules
▶ t ' ≤s t1
▶ t2 ≤s t '
▶ ti ≤s t ', i ∈ I

▶ t1 → t2 ≤s t ' → t '	▶ Xi : ti i∈I } ≤s  Xi : t ' i∈I }
...	1	2	i
▶ t ' ≤d t1 ~ f1	▶ t2 ≤d t ' ~ f2
1	2
▶ t1 → t2 ≤d t ' → t ' ~ λy :t1 → t2. λx :t ' . f2(y (f1x ))
1	2	1
▶ ti ≤d t ' ~ fi,i ∈ I'

▶ X : t i∈I } ≤
 X : t ' i∈I' , ~ λy : X : t i∈I } .  X
i∈I' f (y.X ),

Fig. 11. MoRecdel: subtyping relations

depth subtyping on record types. Moreover, dynamic subtyping also allows width subtyping on record types. For instance, assuming ▶posint ≤d int ~ λz :posint. z , if the expected type is {X:{Y : int}}, then {X:{Y : posint,Z : int} ,W: int} is accepted and the corresponding coercion is represented by the expression
λx :{X: {Y : posint,Z : int} ,W: int} . {X '→ (λy :{Y : posint,Z: int} . {Y '→ (λz :posint. z ) (y.Y )} ) (x .X)} .

Note that, as already mentioned, coercion hierarchically deletes all unexpected fields.
We can now show that MoRecdel, with all required ingredients (types, type judg-
ment, static and dynamic subtyping relations), can be used as a parameter for the typed parametric coordination framework illustrated in Sect.2, since it satisfies all required assumptions.
We first give some useful lemmas.
Lemma 3.2 (Subst) If Γ[x:t2] ▶c e1 : t1, Γ ▶c e2 : t2, then Γ ▶c e1{x '→ e2}: t1. Moreover,
if Γ[x:t2] ▶c e1 : t1, Γ▶ e2 : t ' , with t ' ≤s t2, then Γ▶ e1{x '→ e2}: t ' , with t ' ≤s t1.
2	2	1	1
Proof. The first part of the lemma is proved by induction on the structure of e1.
For the moreover part, we observe that if Γ[x:t2] ▶c e1 : t1, Γ ▶ e2 : t ' , with t ' ≤s t2,
2	2
then, for the weakening property (see point A3 below), Γ[x:t' ] ▶c e1 : t ' , with t ' ≤s t1,
2	1	1
and, for the first part of this lemma, we get Γ▶ e1{x '→ e2}: t ' .	 
Lemma 3.3 (Coercion type)  If ▶ t ' ≤d t ~ f, then ▶c e : t ' → t '' with ▶ t '' ≤s t. 
Proof. Induction on dynamic subtyping rules.	 
Theorem 3.4 All assumptions of Sect.2 are satisﬁed. In particular:
A2. If Γ ▶c e : t, x /∈ dom(Γ), then e{x '→ e' } = e.
A3. If Γ ▶c e : t and Γ' ≤s Γ, then Γ' ▶c e : t ', with t ' ≤s t. Moreover, if FV (e) ∩
dom(Γ') = ∅, then Γ[Γ'] ▶ e : t. 

A4. If Γ ▶c e : t and e −→c
e', then Γ ▶c e' : t ' for some ▶ t ' ≤s t. 

A5. If Γ[x:tx ] ▶c e : t, Γ ▶c e' : t '', ▶ t '' ≤s t ' , and ▶ t ' ≤d tx ~ f, then Γ ▶c e{x '→ f e' }: t ',

for some t ' ≤s t. 
Proof.
x	x	x	x

A2. Induction on the structure of e.
A3. The first part is proved by induction on typing rules. In the case (t-var), we have e = x , t = Γ(x ) and from Γ' ≤s Γ, we get Γ'(x ) ≤s Γ(x ). In cases (t-lambda), (t-del) and (t-sel), we apply the inductive hypothesis to the premise of the rule. In
cases (t-app) and (t-sum), we apply the inductive hypothesis to both the premises of the rule; moreover, in the case (t-app), we exploit the transitivity property of
≤s. In the case (t-record), we apply the inductive hypothesis to all premises of
the rules (that is, for all i ∈ I). The moreover part is proved by induction on typing rules.
A4. Induction on reduction rules.  In the case (app), we have (λx : t2. e1)e2 −→c e1{x '→ e2}, with Γ ▶c (λx : t2. e1)e2 : t . To derive this last judgment, we must have applied typing rule (t-app) and (t-lambda), hence, it must be Γ[x:t2] ▶c e1 : t ,
Γ ▶c e2 : t ' , with t ' ≤s t2. Thus, we can conclude by using Lemma 3.2.
2	2
A5. By applying Lemma 3.3 to the premise Γ ▶c e' : t '', with ▶ t '' ≤s t ' , and ▶ t ' ≤d
x	x	x	x
tx ~ f, we get Γ ▶ e''e' : tx , for some ▶ tx ≤s tx . Hence, we can apply Lemma 3.2

to this last judgment and the premise Γ[x:tx ] ▶c e : t , obtaining Γ ▶c e{x '→ e''e' }: t ', for some ▶ t ' ≤s t .

4	Conclusion
The contribution of the paper can be summarized as follows. First, we have extended previous work introducing an abstract framework for type-safe exchange of mobile code to the (non trivial) case of open code. The outcome is a parameterized process calculus which allows to express in a simple and clean way rebinding of code in a distributed environment. In this respect, some work which has directly influenced our approach is that on dynamic software updating in, e.g., [5,6,15]. However, here we consider arbitrary core calculi rather than lambda-calculi, and an explicit language for the process layer, whereas in [5,6,15] the basic primitive is an update primitive which when performed changes local code in a less controlled way.
Moreover, we have adapted to a different context and to different aims the coercion semantics of subtyping, also called Penn translation [7], showing that it can be used for dynamic retrieval of code and smoothly combined with a classical subset semantics for static subtyping; our work also illustrates how this approach can be generalized to open code.
Finally, we have defined an instantiation of the framework which shows how to use Penn translation to solve the classical problem of interference of names when mobile code has a record structure [3,4,2].
Besides the already mentioned work, an important source of inspiration for the idea of coercion driven by a subtyping relation has been [11].
We plan to investigate other properties besides type safety. For instance, we would like to formalize notions like how often code is rejected and whether the original language semantics is preserved.
On the more applicative side, we would like to develop more practical and re- alistic examples of the use of the framework, possibly together with a prototype implementation. We plan to propose master theses on this subject. Note that an implementation should likely introduce an explicit marshaling mechanism, for dis- tinguishing between “frozen” code to be exchanged among processes and ordinary code to be executed.

References
Ancona, D., F. Damiani, S. Drossopoulou and E. Zucca, Polymorphic bytecode: Compositional compilation for Java-like languages, in: ACM Symp. on Principles of Programming Languages 2005 (2005).
Bettini, L., V. Bono and S. Likavec, Safe and flexible objects with subtyping, Journ. of Object Technology
10 (2005), pp. 5–29, special Issue: OOPS Track at SAC 2005.
Bettini, L., V. Bono and B. Venneri, Subtyping-inheritance conflicts: The mobile mixin case, in: J.-J. L´evy, E. W. Mayr and J. C. Mitchell, editors, TCS’04 - 3rd IFIP Int. Conf. on Theoretical Computer Science 2004 (2004), pp. 451–464.

Bettini, L., B. Venneri and V. Bono, MOMI: a calculus for mobile mixins, Acta Informatica 42 (2005),
pp. 143–190.
Bierman, G., M. W. Hicks, P. Sewell and G. Stoyle, Formalizing dynamic software updating (extended abstract), in: USE’03 - the Second International Workshop on Unanticipated Software Evolution, 2003.
Bierman, G., M. W. Hicks, P. Sewell, G. Stoyle and K. Wansbrough, Dynamic rebinding for marshalling and update, with destruct-time λ, in: C. Runciman and O. Shivers, editors, Intl. Conf. on Functional Programming 2003 (2003), pp. 99–110.
Breazu-Tannen, V., T. Coquand, C. A. Gunter and A. Scedrov, Inheritance as implicit coercion, Information and Computation (1991), pp. 172–221.
Fagorzi, S. and E. Zucca, A framework for type safe exchange of mobile code, in: U. Montanari,
D. Sannella and R. Bruni, editors, TGC 2006 - 2nd International Symposium on Trustworthy Global Computing 2006, Lecture Notes in Computer Science 4661 (2007), pp. 319–338.
Felleisen, M. and D. P. Friedman, Control operators, the SECD-machine, and the lambda-calculus, in: 3rd Working Conference on the Formal Description of Programming Concepts, Ebberup, Denmark, 1986, pp. 193–219.
Kobayashi, N., B. C. Pierce and D. N. Turner, Linearity and the pi-calculus, in: ACM Symp. on Principles of Programming Languages 1996 (1996), pp. 358–371.
Meijer, E. and P. Drayton, Static typing where possible, dynamic typing when needed: The end of the cold war between programming languages, in: OOPSLA’04 Workshop on Revival of Dynamic Languages, 2004.
Necula, G. C., Proof-carrying code., in: ACM Symp. on Principles of Programming Languages 1997
(1997), pp. 106–119.
Pierce, B. C., “Types and Programming Languages,” The MIT Press, 2002.
Pierce, B. C. and D. Sangiorgi, Typing and subtyping for mobile processes, in: Proceedings 8th IEEE Logics in Computer Science, Montreal, Canada, 1993, pp. 376–385.
Stoyle, G., M. W. Hicks, G. Bierman, P. Sewell and I. Neamtiu, Mutatis mutandis: safe and predictable dynamic software updating, in: ACM Symp. on Principles of Programming Languages 2005 (2005),
pp. 183–194.
