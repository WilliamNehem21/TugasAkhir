	Electronic Notes in Theoretical Computer Science 138 (2005) 79–101	
www.elsevier.com/locate/entcs

A Proof Search Specification of the π-Calculus
Alwen Tiu1 ,3
INRIA Lorraine
Dale Miller2
INRIA-Futurs and E´cole polytechnique

Abstract
We present a meta-logic that contains a new quantifier ∇ (for encoding “generic judgments”) and inference rules for reasoning within fixed points of a given specification. We then specify the operational semantics and bisimulation relations for the finite π-calculus within this meta- logic. Since we restrict to the finite case, the ability of the meta-logic to reason within fixed points becomes a powerful and complete tool since simple proof search can compute this one fixed point. The ∇ quantifier helps with the delicate issues surrounding the scope of variables within π-calculus expressions and their executions (proofs). We shall illustrate several merits of the logical specifications we write: they are natural and declarative; they contain no side conditions concerning names of variables while maintaining a completely formal treatment of such variables; differences between late and open bisimulation relations are easy to see declaratively; and proof search involving the application of inference rules, unification, and backtracking can provide complete proof systems for both one-step transitions and for bisimulation.
Keywords: π-calculus, names, meta-logic, proof search, bisimulation.


Introduction
In order to treat abstractions within expressions and computation declara- tively, we shall work within a meta-logic which contains a well understood notion of abstraction: in particular, we shall work with a logic inspired by

1 Email: Alwen.Tiu@loria.fr
2 Email: dale.miller@inria.fr
3 This work was done when the author was at Pennsylvania State University and INRIA Futurs/E´cole polytechnique.



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.05.006

Church’s Simple Theory of Types [4], where terms are actually simply typed λ-terms. Just as it is common to use logic-level application to represent object- level application (for example, the encoding of P + Q is via the meta-level application of the encoding for plus to the encoding of its two arguments), we shall use logic-level abstractions (via λ-abstractions) to encode object-level abstractions. The λ-terms in our setting are thus simply typed and satisfy the usual rules for α, β, and η-conversion. This style of syntactic encoding has been called λ-tree syntax [24]. The term higher-order abstract syntax [34] was originally applied to this kind of encoding, but in more recent years, HOAS has come to encompass the use of arbitrary higher-order functions to encode abstractions in syntax. Whatever term one wishes to use to classify our approach here, it is important to understand that λ-abstractions are only intended to form abstractions over syntax and their functional interpretation is limited to providing object-level substitution via β-reduction.
We make use of the ∇-quantifier, first introduced in the logic FOλΔ∇ [26], to help encode the notion of “generic judgment” that occurs commonly when reasoning with λ-tree syntax. The ∇ quantifier is used to introduce new elements into a type within a given scope. In particular, a reading of the truth condition for ∇xγ.Bx is something like: if given a new element, say c, of type γ, then check the truth of Bc. Notice that this is hypothetical reasoning about the datatype γ and it does not require knowing whether or not this type actually contains any members. This is, of course, rather central to the notion of generic: something holds generically usually means that it holds for certain “internal” reasons (the structure of an argument, for example) and not for some accident concerning members of the domain. This is quite different from determining the truth of ∀xγ.Bx: check that Bt is true for all t in the type γ. If the type is empty, this condition is vacuously true and if the type is infinite, we have an infinite number of checks to make in principle.
It is useful to provide here a high-level comparison between the ∇-quantifier and the “new” quantifier of Gabbay and Pitts [10]. In their set theory foun- dations, a domain containing an infinite number of names is assumed given. To deal with notions of freshness, renaming of bound variables, substitution, etc, they provide a series of primitives between names and terms that can be used to guarantee that a name does not occur within a term, that one name can be swapped for another, etc. Based on these concepts, they can define a new quantifier that guarantees the selection of a “fresh” name for some specific context. In our approach here, there is no particular class of names: the ∇ quantifier will work at any type. (Later, when we discuss the π-calculus explicitly, we shall assume a type for names since this is required by this particular application.) Also, here types do not need to be infinite or even

non-empty. Instead, the meaning of ∇xγ.Bx is one of explicitly introducing a new object of type γ within a certain scope. Thus, the Gabbay-Pitts approach assumes that the type of names is fixed and closed, while the type used with
∇ is open, in the sense that new members of that type can be constructed by the meta-logic for use within a ∇-bound scope. More specifically, the set of theorems for these two quantifiers is quite different. For example, in the logic considered here, the formulas ∀x.Bx ⊃ ∇x.Bx and ∇x.Bx ⊃ ∃x.Bx are not theorems, but if ∇ is replaced with the Gabbay-Pitts quantifier, they do hold in their theory.
This distinction between having an open versus closed datatype is also a theme that highlights the differences between intuitionistic and classical logic. The meta-logic in this paper is based on intuitionistic logic, a weaker logic than classical logic. One of the principles missing from intuitionistic logic is that of the excluded middle: that is, A ∨ ¬A is not generally provable in intuitionistic logic. Consider, for example, the following formula concerning the variable w:
∀xγ [x = w ∨ x /= w].	(*)
In classical logic, this formula is a trivial theorem. If we think constructively, however, this formula is not trivial and might not be desirable in all cases. If the type of quantification γ is a conventional (closed) datatype, then we might expect to have a decision procedure for equality. For example, if γ is the type for lists, then it is a simple matter to construct a procedure that decides whether or not two members of γ are equal by considering the top constructor of the list and, in the event of comparing two non-empty lists, making recursive calls (assuming a decision procedure is available for the elements of the list). In fact, it is possible to prove in an intuitionistic logic augmented with induction (see, for example, [41]) the formula (∗) for such closed datatypes.
If the type γ is not given inductively, as is the usual case for names in intuitionistic formalizations of the π-calculus (see [6,8,16] and below), then the corresponding instance of (∗) is not provable. Thus, whether or not we allow instances of (∗) to be assumed can change the nature of a specification. In fact, we show in Section 5, that if we add to our specification of open bisimulation [37] assumptions corresponding to (∗), then we get a specification of late bisimulation. If we were working with a classical meta-logic, such a declarative presentation of these two bisimulations would not have been so easy to present. To see a similar use for an intuitionistic meta-logic and for open types, see [28], where an intuitionistic logic model allowing for open types is used to help establish completeness theorems for the simply typed λ-calculus.
The authors first presented the meta-logic used in this paper in [26] and

illustrated its usefulness with the π-calculus: in particular, the specifications of one-step transitions in Figure 2 and of open bisimulation in Figure 4 also appear in [26], but without proof. In this paper, we state the formal prop- erties of our specifications, provide a specification of late bisimulation and provide a novel comparison between open and late bisimulation. In partic- ular, we show that the difference between open and late bisimulation (apart from the difference that arises from the use of closed and open types discussed above) can be captured by the different quantification of free names using
∀ and ∇. The different treatment of free names, that is, whether some free names are instantiable or not, highlights the difference between late and open bisimulation, as noted in [38], where the notion of distinction among names is introduced to define the open bisimulation relation. We show in Section 5 that a natural class of distinctions can be captured by the alternation of ∀ and
∇ quantifiers, and in the case where we are interested only in checking open bisimilarity modulo empty distinction, the notion of distinction that arises in the process of checking bisimilarity is completely subsumed by quantifier alternation. In Section 6 we outline the automation of proof search based on these specifications, which provides us with symbolic bisimulation procedures. Since our focus in this paper is on names, scoping of names, dependency of names and distinction of names, we choose to focus on finite π-calculus. For related work on ∇ and infinite process behaviors, see first author’s PhD [41] and Section 7 of this paper. Since it does not contribute much to our overall
analysis, we only briefly consider early bisimulation in Appendix B.

Overview of the logic FOλΔ∇
The logic FOλΔ∇ (pronounced “fold-nabla”) is presented using a sequent calculus that is an extension of Gentzen’s system LJ [11] for first-order intu- itionistic logic. A sequent is an expression of the form B1,... , Bn ▶ B0 where Bi is a formula and the turnstile ▶ denotes logical entailment. To the left of the turnstile is a multiset: thus repeated occurrences of a formula are allowed. If the formulas B0,... , Bn contain free variables, they are considered univer- sally quantified outside the sequent, in the sense that if the above sequent is provable than every instance of it is also provable. In proof theoretical terms, such free variables are called eigenvariables.
A first attempt at using sequent calculus to capture judgments about the π-calculus could be to use eigenvariables to encode names in π-calculus, but this is certainly problematic. For example, if we have a proof for the sequent
▶ P xy, where x and y are different eigenvariables, then logic dictates that the sequent ▶ Pzz is also provable (given that the reading of eigenvariables is



Σ,σ ▶ t : γ	Σ; σ d B[t/x], Γ ▶C 


Σ; σ d ∀γ x.B, Γ ▶C	∀L
Σ,h ; Γ ▶ σ d B[(h σ)/x]


Σ; Γ ▶ σ d ∀x.B	∀R

Σ,h ; σ d B[(h σ)/x], Γ ▶C 


Σ; σ d ∃x.B, Γ ▶C	∃L
Σ; (σ, y) d B[y/x], Γ ▶C 


Σ; σ d ∇x B, Γ ▶C	∇L
Σ,σ ▶ t : γ	Σ; Γ ▶ σ d B[t/x]


Σ; Γ ▶ σ d ∃γx.B	∃R
Σ; Γ ▶ (σ, y) d B[y/x]


Σ; Γ ▶ σ d ∇x B	∇R



Fig. 1. The introduction rules for quantifiers of FOλΔ∇.
universal). If the judgment P is about, say, bisimulation, then it is not likely that a statement about bisimulation involving two different names x and y remains true if they are identified to the same name x.
To address this problem, the logic FΟλΔ∇ extends sequents with a new notion of “local scope” for proof-level bound variables (originally motivated in [26] to encode “generic judgments”). In particular, sequents in FΟλΔ∇ are of the form
Σ; σ1 d B1,... , σn d Bn ▶ σ0 d B0
where Σ is a global signature, i.e., the set of eigenvariables whose scope is over the whole sequent, and σi is a local signature, i.e., a list of variables scoped over Bi. We shall consider sequents to be binding structures in the sense that the signatures, both the global and local ones, are abstractions over their respective scopes. The variables in Σ and σi will admit α-conversion by systematically changing the names of variables in signatures as well as those in their scope, following the usual convention of the λ-calculus. The meaning of eigenvariables is as before, only that now instantiation of eigenvariables has to be capture-avoiding, with respect to the local signatures. The variables in local signatures act as locally scoped generic constants, that is, they do not vary in proofs since they will not be instantiated. The expression σ d B is called a generic judgment or simply a judgment. We use script letters A, У, etc. to denote judgments. We write simply B instead of σ d B if the signature σ is empty. We shall often write the list σ as a string of variables, e.g., a judgment (x1, x2, x3) d B will be written as x1x2x3 d B. If the list x1, x2, x3 is known from context we shall also abbreviate the judgment as x¯ d B.
The logical constants of FΟλΔ∇ are 6 (universal quantifier), E (existential quantifier), ∇, Λ (conjunction), V (disjunction), э (implication), T (true) and
⊥ (false). The inference rules for the quantifiers of FΟλΔ∇ are given in Fig- ure 1. The complete set of inference rules can be found in the appendix. Since we do not allow quantification over predicates, this logic is proof-theoretically similar to first-order logic (hence, the letters FO in FΟλΔ∇).
During the search for proofs (reading rules bottom up), inference rules for
6 and E quantifier place new eigenvariables into the global signature while

the inference rules for ∇ place them into the local signature. In the 6R and EL rules, raising [23] is used when moving the bound variable x, which can range over the variables in both the global signature and the local signature σ, with the variable h that can only range over variables in the global signature: so as not to miss substitution terms, the variable x is replaced by the term (h x1 ... xn), which we shall write simply as (h σ), where σ is the list x1,... , xn (h must not be free in the lower sequent of these rules). In 6L and ER, the term t can have free variables from both Σ and σ. This is presented in the rule by the typing judgment Σ,σ ▶ t : τ . The ∇L and ∇R rules have the proviso that y is not free in ∇x B.
The standard inference rules of logic express introduction rules for logical constants. The full logic FΟλΔ∇ additionally allows introduction of atomic judgments, that is, judgments which do not contain any occurrences of logical constants. To each atomic judgment, A, we associate a defining judgment, У, the deﬁnition of A. The introduction rule for the judgment A is in effect done by replacing A with У during proof search. This notion of definitions is an extension of work by Schroeder-Heister [39], Eriksson [7], Girard [12], St¨ark
[40] and McDowell and Miller [20]. These inference rules for definitions allow for modest reasoning about the fixed points of definitions.
Definition 2.1 A deﬁnition clause is written 6x¯[p t¯ Δ B], where p is a pred- icate constant, every free variable of the formula B is also free in at least one term in the list t¯ of terms, and all variables free in p t¯ are contained in the list x¯ of variables. The atomic formula p t¯ is called the head of the clause, and the
formula B is called the body. The symbol = is used simply to indicate a defi- nitional clause: it is not a logical connective. The predicate p occurs strictly positively in B, that is, it does not occur to the left of any э (implication).
Δ
Let 6τ1 x1 ... 6τn xn.H = B be a definition clause. Let y1,... , ym be a list
of variables of types α1,... , αm, respectively. The raised deﬁnition clause of
H with respect to the signature {y1 : α1,... , ym : αm} is defined as

Δ
6h1 ... 6hn.y¯ d Hθ = y¯ d Bθ
where θ is the substitution [(h1 y¯)/x1,... , (hn y¯)/xn] and hi, for every i ∈
{1,... , n}, is of type α1 → ... → αm → τi. A deﬁnition is a set of definition clauses together with their raised clauses.
To guarantee the consistency (and cut-elimination) of the logic FΟλΔ∇, we need some kind of stratification of definition that limits the definition of one predicate to depend negatively on another predicate (see [26] for the full details). All definitions considered in this paper are stratified appropriately

and cut-elimination will hold for the logic using them.
The introduction rules for a defined judgment are as follow. When apply- ing the introduction rules, we shall omit the outer quantifiers in a definition clause and assume implicitly that the free variables in the definition clause are distinct from other variables in the sequent.

Δ
{Σθ ; Bθ, Γθ ▶ Cθ | θ ∈ CSU (A, H) for some clause H = B}
Σ; A, Γ ▶ C	defL
Σ; Γ ▶ Bθ	Δ
Σ; Γ ▶ A defR,	where H = B is a definition clause and Hθ = A


In the above rules, we apply substitution to judgments. The result of applying a substitution θ to a generic judgment x1,... , xn d B, written as (x1,... , xn d B)θ, is y1,... , yn d B', if (λx1 ... λxn.B)θ is equal (modulo λ-conversion) to λy1 ... λyn.B'. If Γ is a multiset of generic judgments, then Γθ is the multiset
{Jθ | J ∈ Γ}. In the defL rule, we use the notion of complete set of uniﬁers
(CSU) [19]. We denote by CSU (A, H) the complete set of unifiers for the pair (A, H), that is, for any substitution θ such that Aθ = Hθ, there is a substitution ρ ∈ CSU (A, H) such that θ = ρ◦θ' for some substitution θ'. In all the applications of defL in this paper, the set CSU (A, H) is either empty (the two judgments are not unifiable) or contains a single substitution denoting the most general unifier. The signature Σθ in defL denotes a signature obtained from Σ by removing the variables in the domain of θ and adding the variables in the range of θ. In the defL rule, reading the rule bottom-up, eigenvariables can be instantiated in the premise, while in the defR rule, eigenvariables are not instantiated. The set that is the premise of the defL rule means that that rule instance has a premise for every member of that set: if that set is empty, then the premise is proved.
One might find the following analogy with logic programming helpful: if a definition is viewed as a logic program, then the defR rule captures backchain- ing and the defL rule corresponds to case analysis on all possible ways an atomic judgment could be proved. In the case where the program has only finitely many computation paths, we can effectively encode negation-as-failure using defL [13].

Some meta-theory of the meta-logic
We now illustrate how the structural properties of proofs can be used for meta-reasoning about the logical specifications mentioned previously. The general reasoning scheme makes use of the cut rule and the cut-elimination theorem. Cut-elimination says that any proof which makes use of the cut rule

can be transformed to a proof without it (a cut-free proof). Cut-elimination gives rise to surprisingly rich structural properties of cut-free proofs. One important structural property is that of the invertibility of inference rules. An inference rule of logic is invertible if the provability of the conclusion implies the provability of the premise(s) of the rule. The following rules in FΟλΔ∇ are invertible: ΛR, ΛL, VL, э R, 6R, EL, defL (see [41] for a proof). Knowing the invertibility of a rule can be useful in determining some structure of a proof. For example, if we know that a sequent A V B, Γ ▶ C is provable, then by the invertibility of VL, we know that it must be the case that A, Γ ▶ C and B, Γ ▶ C are provable.
Another important property of FΟλΔ∇ is that concerning the local signa- tures. Local signatures can be weakened without affecting provability.
Proposition 3.1 If B is provable and x is not free in B, then ∇xB is prov- able.
Proposition 3.2 If 6xB is provable then ∇xB is provable.
One might expect the implication 6τ xB э ∇τ xB to hold as well. Notice that if τ is empty this statement would not be expected to be true and, hence, we do not accept it in the core logic.
The converse of Proposition 3.2 is not true in general. However, it is true for a restricted class of formulas and definitions, called hc∀∇-formulas (for Horn clauses with 6 and ∇) and hc∀∇-deﬁnitions, respectively. A hc∀∇- formula is a formula which does not contain any occurrence of the logical constant э (implication). A hc∀∇-definition is a definition whose bodies are hc∀∇-formulas. One of the examples of hc∀∇-definitions is the definition for the one-step transition in Figure 2.
Proposition 3.3 Let D be a hc∀∇-deﬁnition and 6xG be a hc∀∇-formula. Then 6xG is provable if and only if ∇xG is provable.

Logical specification of one-step transition
We consider the late transition system for the finite π-calculus as defined in [27], that is, the fragment of π-calculus without recursion (or replication). The syntax of processes is defined as follows
P ::= 0 | x¯y.P | x(y).P | τ.P | (x)P | [x = y]P | P|Q | P + Q.
We use the notation P, Q, R, S and T to denote processes. Names are denoted by lower case letters, e.g., a, b, c, d, x, y, x. The occurrence of y in the process x(y).P and (y)P is a binding occurrence, with P as its scope. The set of free

names in P is denoted by fn(P), the set of bound names is denoted by bn(P). We write n(P) for the set fn(P) ∪ bn(P). We consider processes to be syntactically equivalent up to renaming of bound names.
α
One-step transition in the π-calculus is denoted by P −−→ Q, where P and
Q are processes and α is an action. The kinds of actions are the silent action τ , the free input action xy, the free output action x¯y, the bound input action x(y) and the bound output action x¯(y). The name y in x(y) and x¯(y) is a binding occurrence. Just like we did with processes, we use fn(α), bn(α) and n(α) to denote free names, bound names, and names in α. An action without binding occurrences of names is a free action, otherwise it is a bound action.
We encode the syntax of process expressions using higher-order syntax as follows. We shall require three primitive syntactic categories: n for names, p for processes, and a for actions, and the constructors corresponding to the operators in π-calculus. We do not assume any inhabitants of type n, therefore in our encoding a free name is translated to a variable of type n, which can later be either universally quantified or ∇-quantified, depending on whether we want to treat a certain name as instantiable or not. (Since the rest of this paper is about the π-calculus, the ∇ quantifier will from now on only be used at type n.) For instance, in encoding late bisimulation (Section 5) we treat free names as ∇-quantified variables, while in the encoding of open bisimulation they are universally quantified variables. To encode actions, we use τ : a (for the silent action), and the two constants ↓ and ↑, both of type n → n → a for building input and output actions. The free output action x¯y, is encoded as ↑ xy while the bound output action x¯(y) is encoded as λy (↑ xy) (or the η-equivalent term ↑ x). The free input action xy, is encoded as ↓ xy while the bound input action x(y) is encoded as λy (↓ xy) (or simply ↓ x). The process constructors are encoded using the following constants
0: p,	τ : p → p,	out : n → n → p → p,	in : n → (n → p) → p,
+: p → p → p,	| : p → p → p,	match : n → n → p → p,	ν : (n → p) → p.

We use two predicates to encode the one-step transition semantics for the
·
π-calculus. The predicate · −−→ · of type p → a → p → o encodes transitions
·
involving free values and the predicate · −−~ · of type p → (n → a) → (n →
p) → o encodes transitions involving bound values. The precise translation of
π-calculus syntax into simply typed λ-terms is given in the following definition.
Definition 4.1 The following function ⟨.⟩ translates from process expressions to βη-long normal terms of type p.
⟨0⟩ = 0, ⟨[x = y]P⟩ = match x y ⟨P⟩, ⟨x¯y.P⟩ = out x y ⟨P⟩, ⟨x(y).P⟩ = in x λy.⟨P⟩,
⟨P + Q⟩ = ⟨P⟩ + ⟨Q⟩, ⟨P|Q⟩ = ⟨P⟩| ⟨Q⟩, ⟨τ.P⟩ = τ ⟨P⟩, ⟨(x)P⟩ = νλx.⟨P⟩.
The one-step transition judgments are translated to atomic formulas as follows


τ	Δ	↓X	Δ	†xy	Δ
(tau:) τ P −−→ P = T.	(in:) in X M −−~ M = T.	(out:) out x y P −−→ P = T.
A	Δ	A	A	Δ	A
(match:) match x x P −−→ Q = P −−→ Q.	match x x P −−~ Q = P −−~ Q.
A	Δ	A	A	Δ	A
(sum:) P + Q −−→ R = P −−→ R.	P + Q −−→ R = Q −−→ R.
A	Δ	A	A	Δ	A
(sum:) P + Q −−~ R = P −−~ R.	P + Q −−~ R = Q −−~ R.

(par:)
A	'	Δ	A	'
A	' Δ	A	'

P | Q −−→ P | Q = P −−→ P .	P | Q −−→ P | Q = Q −−→ Q
A	Δ	A	A	Δ	A
(par:) P | Q −−~ λn(M n | Q) = P −−~ M.	P | Q −−~ λn(P | N n) = Q −−~ N.

(res:)
A	Δ	A
A	'	Δ	A	'

νn.Pn −−→ νn.Qn = ∇n(Pn −−→ Qn). νn.Pn −−~ λm νn.P nm = ∇n(Pn −−~ P n).

(open:)
†X	' Δ
†Xy
'

τ	Δ	↓X	†X
(close:) P | Q −−→ νy.(My | Ny) = ∃X.P −−~ M ∧ Q −−~ N 
τ	Δ	†X	↓X
(close:) P | Q −−→ νy.(My | Ny) = ∃X.P −−~ M ∧ Q −−~ N.

τ
(com:)
' Δ	↓X
†XY	'

(com:)
τ	'	Δ
†XY	↓X
'


Fig. 2. Definition clauses for the late transition system.
(we overload the symbol ⟨.⟩).

x¯y	†xy	τ	τ
⟨P −−→ Q⟩ = ⟨P⟩ −−→ ⟨Q⟩	⟨P −−→ Q⟩ = ⟨P⟩ −−→ ⟨Q⟩
x(y)	↓x	x¯(y)	†x
⟨P −−→ Q⟩ = ⟨P⟩ −−~ λy.⟨Q⟩ ⟨P −−→ Q⟩ = ⟨P⟩ −−~ λy.⟨Q⟩

We abbreviate νλx.P as simply νx.P . Notice that when τ is written as a prefix, it has type p → p, and when it is written as an action, it has type a.
The operational semantics of the late transition system for the finite π- calculus is given as a definition, called Dπ, in Figure 2. In this specification, free variables are schema variables that are assumed to be universally scoped over the definition clause in which they appear. These schema variables have primitive types such as a, n, and p as well as functional types such as n → a and n → p.
Notice that as a consequence of the use of HOAS in the encoding, the complicated side conditions in the original specifications of π-calculus [27] are no longer present. For example, the side condition that X /= y in the open rule is implicit, since X is outside the scope of y and therefore cannot be instantiated with y. The adequacy of our encoding is stated in the following lemma and proposition (their proofs can be found in [41]).
Lemma 4.2 The function ⟨.⟩ is a bijection.
Proposition 4.3 Let P and Q be processes and α an action. Let n¯ be a list of
α
free names containing the free names in P, Q and α. The transition P −−→ Q

α
is derivable in π-calculus if and only if the sequent . ; . ▶ ∇n¯.⟨P −−→ Q⟩ is
provable in FΟλΔ∇ with the deﬁnition Dπ.

Since the definition Dπ contains essentially Horn clauses, a consequence
α
Proposition 3.3 is that if any of the ∇-bound variables in ∇n¯.⟨P −−→ Q⟩ are
changed to be 6-bound variables, the resulting formula is still provable. The differences between ∇ and 6 are revealed more with non-Horn definitions, such as those for bisimulation.
Given the above adequacy results, we shall omit writing explicitly the function symbol ⟨.⟩ when referring to p-term obtained via the translation.
The restriction operator is interpreted at the meta-level as the ∇ quanti- fier. The use of ∇, instead of 6, allows to prove negative statements about the transitions, as illustrated in Example 4.4. When writing encoded process expressions, we shall use the syntax of π-calculus along with the usual abbre- viations: for example, when a name x is used as a prefix, it denotes the prefix x(w) where w is vacuous in its scope; when a name x¯ is used as a prefix it de- notes the output prefix x¯a for some fixed name a. We also abbreviate (y)x¯y.P as x¯(y).P and the process term 0 is omitted if it appears as the continuation of a prefix. We assume that the operators | and + associate the right, e.g., we write P + Q + R to denote P + (Q + R).

Example 4.4 Consider the process (y)([x = y]x¯x). This process cannot make any transition since the bound variable y denotes a name different from x. One can think of this process as a continuation of some other process which inputs x on some channel, e.g., a(x).(y)[x = y]x¯x. We would therefore expect that the following is provable.


α
6x6x6Q6α.[((y)[x = y](x¯x) −−→ Q) э ⊥]

This type of statement naturally occurs when one is asking whether two pro- cesses are bisimilar (see Section 5), where it is necessary to know what transi- tions a process can make and what it cannot. The scoping constraint between y and x is captured properly by the alternation of 6 and ∇. Notice that in the above specification, y is inside the scope of x, which means that whatever value we substitute for x cannot be equal to y (since substitution is capture- avoiding). The formal derivation of the above formula is (ignoring the terminal



uses of эR and 6R):

α	defL

{x, x, Q, α} ; y d ([x = y](x¯x.0) −−→ Q) ▶⊥ 


α
{x, x, Q, α} ; . d ∇y.([x = y](x¯x.0) −−→ Q) ▶⊥ 


α
{x, x, Q, α} ; . d ((y)[x = y](x¯x.0) −−→ Q) ▶⊥ 
∇L
defL

The success of the topmost instance of defL depends on the failure of the unification problem λy.x = λy.y. Notice that the scoping of object variables is maintained at the meta-level by the separation of (global) eigenvariables and (locally bound) generic variables. The “newness” of y is internalized as a λ-abstraction and, hence, it is not subject to instantiation.

Logical specifications of strong bisimilarity
We consider specifying two notions of bisimilarity, tied to the late transition system: the strong late bisimilarity and the strong open bisimilarity. As we shall see, the essential difference between the specification of late bisimulation and that of open bisimulation is in the presence (or the absence) of the ax- iom of excluded middle on names. The original definitions of late and open bisimilarity are given in [27,38]. Here we choose to make the side conditions explicit, instead of adopting the bound variable convention in [38].
Definition 5.1 Strong late bisimilarity is the largest symmetric relation, ∼l, such that whenever P ∼l Q,

if
α	α
' and α is a free action, then there is Q' such that	'

P −−→ P
and P' ∼l Q',
x(z)
Q −−→ Q

x(z)

if P −−→ P' and x /∈ n(P, Q) then there is Q' such that Q
−−→ Q' and

P'[y/x] ∼l Q'[y/x] for every name y,
x¯(z)

x¯(z)

if P −−→ P' and x /∈ n(P, Q) then there is Q' such that Q
−−→ Q' and

P' ∼l Q'.
Definition 5.2 A distinction D is a finite symmetric and irreflexive relation on names. A substitution θ respects a distinction D if (x, y) ∈ D implies xθ /= yθ. We refer to the substitution θ as a D-substitution. Given a distinction D and a D-substitution θ, the result of applying θ to all variables in D, written Dθ, is another distinction. We denote with fn(D) the set of free names occuring in D.


Δ	'	A	'	'	A	'	'  '
lbisim P Q = ∀A∀P [(P −−→ P ) ⊃ ∃Q .(Q −−→ Q ) ∧ lbisim P Q ] ∧
'	A	'	'	A	'	'  '
∀A∀Q [(Q −−→ Q ) ⊃ ∃P .(P −−→ P ) ∧ lbisim Q P ] ∧

'	↓X	'
'	↓X	'	'	'

∀X∀P
[(P −−~ P ) ⊃ ∃Q .(Q −−~ Q ) ∧ ∀w.E w ⊃ lbisim (P w) (Q w)] ∧

↓X	↓X
∀X∀Q' [(Q −−~ Q') ⊃ ∃P '.(P −−~ P ') ∧ ∀w.E w ⊃ lbisim (Q'w) (P 'w)] ∧
†X	†X
∀X∀P ' [(P −−~ P ') ⊃ ∃Q'.(Q −−~ Q') ∧ ∇w.lbisim (P 'w) (Q'w)] ∧
†X	†X
∀X∀Q' [(Q −−~ Q') ⊃ ∃P '.(P −−~ P ') ∧ ∇w.lbisim (Q'w) (P 'w)]

Fig. 3. Specification of late bisimulation. Here, E = λw 6z (w = z V w /= z).
Δ	'	A	'	'	A	'	'  '
obisim P Q = ∀A∀P [(P −−→ P ) ⊃ ∃Q .(Q −−→ Q ) ∧ obisim P Q ] ∧
'	A	'	'	A	'	'  '
∀A∀Q [(Q −−→ Q ) ⊃ ∃P .(P −−→ P ) ∧ obisim Q P ] ∧
↓X	↓X
∀X∀P ' [(P −−~ P ') ⊃ ∃Q'.(Q −−~ Q') ∧ ∀w.obisim (P 'w) (Q'w)] ∧

'	↓X	'
'	↓X	'	'	'

∀X∀Q [(Q −−~ Q ) ⊃ ∃P .(P −−~ P ) ∧ ∀w.obisim (Q w) (P w)] ∧
†X	†X
∀X∀P ' [(P −−~ P ') ⊃ ∃Q'.(Q −−~ Q') ∧ ∇w.obisim (P 'w) (Q'w)] ∧
†X	†X
∀X∀Q' [(Q −−~ Q') ⊃ ∃P '.(P −−~ P ') ∧ ∇w.obisim (Q'w) (P 'w)]

Fig. 4. Specification of open bisimulation.
Definition 5.3 Strong open bisimilarity {∼D| D a distinction } is the largest family of symmetric relations such that if P ∼D Q and θ respects D, then

if
α	α
' and α is a free action, then there is Q' such that	'

Pθ −−→ P
and P' ∼Dθ Q',
x(z)
Qθ −−→ Q

x(z)

if Pθ −−→ P' and x /∈ n(Pθ, Qθ) then there is Q' such that Qθ −−→ Q' and
P' ∼Dθ Q',
x¯(z)	x¯(z)
if Pθ −−→ P' and x /∈ n(Pθ, Qθ) then there is Q' such that Qθ −−→ Q' and
P' ∼D' Q' where D' = Dθ ∪ ({x}× fn(Pθ, Qθ)) ∪ ({x}× fn(Dθ)).
Note that we strengthen a bit the condition 3 in Definition 5.3 to include the distinction ({x}× fn(Dθ)). Strengthening the distinction this way does not change the open bisimilarity, as noted in [38], but in our encoding of open bisimulation, the distinction D is part of the specification and the modified definition above helps us account for names better.
The corresponding specifications for late and open bisimulation in FΟλΔ∇
are given in Figure 3 and Figure 4. The specifications make use of the syntactic
Δ
equality predicate, which is defined as the definition: X = X = T. Note
that the symbol = here is a predicate symbol written in infix notation. The inequality x /= y is an abbreviation for x = y э ⊥. Actually the specifications shown in the figures do not readily encode bisimulations, since they do not yet address the notion of distinction among names. The notion of distinction

will be addressed later. For the moment it is enough to note that when reasoning about the specification of late bisimulation, we encode free names as ∇-quantified variables whereas in the specification of open bisimulation we encode free names as 6-quantified variables. For example, the processes P xy = (x|y¯) and Qxy = (x.y¯ + y¯.x) are late bisimilar. The corresponding encoding in FΟλΔ∇ would be ∇x∇y.lbisim (P xy) (Qxy). The free names x and y should not be 6-quantified, for the obvious reason: in logic we have the implication 6x6y lbisim (P xy) (Qxy) э 6x lbisim (Pxx) (Qxx). That is, either 6x6y lbisim (P xy) (Qxy) is not provable, or it is provable and we have a proof of 6x lbisim (Pxx) (Qxx). In either case we lose the adequacy of the encoding.
Notice that in the specification of late bisimulation, we use the axiom of excluded middle on names while in the open case we do not. For example, the two processes (taken from [37]) x(u).(τ.τ + τ ) and x(u).(τ.τ + τ + τ.[u = x]τ ) are late bisimilar but not open bisimilar: late bisimulation makes use of a case analysis on names. Since the meta-logic FΟλΔ∇ is intuitionistic, this difference between late and open bisimulation is easily observed. This would not be the case if the meta-logic were classical.
The following theorem states the soundness and completeness of the lbisim specification with respect to the notion of late bisimilarity in π-calculus. By soundness we mean that, given a pair of processes P and Q, if the encoding of the late bisimilarity, ∇n¯.lbisim P Q, is provable in FΟλΔ∇ then the processes P and Q are late bisimilar. Completeness is the converse. The soundness and completeness of the open bisimilarity encoding is presented in at the end of this section, where we consider the encoding of the notion of distinction in π-calculus. Proofs of these results and their associated lemmas can be found in the appendices of an extended version of this paper on the authors’ web pages.
Theorem 5.4 Let P and Q be two processes and let n¯ be the free names in P
and Q. The formula ∇n¯.lbisim PQ is provable if and only if P ∼l Q.
It is well-known that the late bisimulation relation is not a congruence since it is not preserved by the input prefix. Part of the reason why the congruence property fails is that in the late bisimilarity there is no syntactic distinction made between instantiable names and non-instantiable names. This is one of the motivations behind the introduction of the notion of distinction and open bisimulation. The alternation of quantifiers in FΟλΔ∇ gives rise to a particular kind of distinction, the precise definition of which is given below.
Definition 5.5 A quantiﬁer preﬁx is a list Q1x1Q2x2 ... Qnxn for some n ≥
0, where Qi is either ∇ or 6.	Let Qx¯ be the above quantifier prefix.	A

Qx¯-distinction is the distinction
{(xi, xj), (xj, xi) | i /= j and Qi = Qj = ∇, or i < j and Qi = 6 and Qj = ∇}.
Notice that if Qx¯ consists only of universal quantifiers then the Qx¯-distinction is empty. Obviously, the alternation of quantifiers does not capture all pos- sible distinction, e.g., the distinction {(x, y), (y, x), (x, x), (x, x), (u, x), (x, u)} does not correspond to any quantifier prefix. However, we can encode the full notion of distinction by explicit encoding of the inequal pairs, as shown later.
Definition 5.6 Let D = {(x1, y1),... , (xn, yn)} be a distinction. We define a translation from a distinction D to a formula [D]] as follows [[D]] = x1 /= y1 Λ
... Λ xn /= yn. If n =0 then [D ] is the logical constant T (empty conjunction).
Theorem 5.7 Let P and Q be two processes, let D be a distinction and let Qx¯ be a quantiﬁer preﬁx, where x¯ contains the free names in P, Q and D. If the formula Qx¯.([[D]] э obisim P Q) is provable then P ∼D Q, where D' is the
union of D and the Qx¯-distinction.
Theorem 5.8 If P ∼D Q then the formula 6x¯.[[D]] э obisim P Q, where x¯ are the free names in P, Q and D, is provable.
To conclude this section, we should explicitly compare the two specifi- cations of late bisimulation in Definition 5.1 and in Figure 3, and the two specifications of late bisimulation in Definition 5.3 and in Figure 4. Notice that those specifications that rely on logic are written without the need for any explicit conditions on variable names or any need to mention distinctions explicitly. These various conditions are, of course, present in the detailed de- scription of the proof theory of our logic, but it seems to be very desirable to push the details of variable names, substitutions, equalities, etc into logic, where they have elegant and standard solutions. We do not address the early bisimulation [27] in this section, but it is not difficult to see that the anal- ysis on names in late bisimilarity carries over to early bisimilarity. In fact, the essential difference between late and early bisimilarity is that in the early bisimilarity the case analysis on names is carried out “one step ahead” of late bisimilarity. This amounts to enlarging the scope of quantified variable w (in the input prefix case). The specification of early bisimilarity is given in Appendix B.

Automation of proof search
The above specifications for one-step transitions and for late and open bisimu- lation are not only declarative and natural, an implementation of proof search

using them can provide effective and symbolic implementation of both one-step transitions and bisimulations. We outline here what is needed to implement the meta-logic presented above.

Unification.
Proof search requires unification in a couple of places: one in the imple- mentation of the defL inference rule and one to determine the appropriate terms necessary to instantiate the E quantifier in the ER inference rules. In the specifications presented here, unification is always within the Lλ or higher- order pattern unification [22] problem. This style of unification, which can be described as first-order unification extended to allow for bound variables and their mobility within terms and proofs, is known to have efficient and practical unification algorithms that compute most general unifiers whenever unifiers exist [32]. The Teyjus implementation [30,31] of λProlog provides an effective implementation of such unification, as does Isabelle [33] and Twelf [35].

Proof search for one-step transitions.
Computing one-step transitions can be done entirely using a conventional, higher-order logic programming language, such as λProlog: since the definition Dπ for one-step transitions is Horn, we can use Proposition 3.3 to show that for the purposes of computing one-step transitions, all occurrences of ∇ in Dπ can be changed to 6. The resulting definition is then a logic program for which λProlog provides an effective implementation. In particular, after

loading that definition, we would simply ask the query P
A
−−→ P
', where P

is the encoding of a particular π-calculus expression and A and P ' are (meta- level) free variables. Standard logic programming would then systematically bind these two variables to the actions and continuations that P can make.

A
Similarly, if the query was, instead, P −−~ P
', logic programming search

would systematically return all bound actions (here, A has type n → a) and corresponding bound continuations (here, P ' has type n → p).

Proof search for open bisimulation.
Proof search for bisimulation is not immediately implemented for bisim- ulation by, say, λProlog, since neither ∇ nor the case analysis of defL are implemented. None-the-less, the implementation of proof search for open bisimulation is easy to specify. The key steps in a direct implementation of open bisimulation are outlined as follows. (Sequents missing from this out- line are trivial to address.) In the following, we use the quantifier prefix Q to denote either 6x or ∇x or the empty quantifier prefix.



When searching for a proof of Σ ; ▶
introduction rules.
σ d Q.obisim P Q apply right-

If the sequent has a formula on its left-hand sides, then that formula is
A	'	'
σ d P −−→ P , where P denotes a particular closed term and A and P
are terms, possibly containing eigen-variables. In this case, select the
defL inference rule: the premises of this inference rule will then be either
(i) the empty-set of premises (which represents the only way that proof search terminates), or (ii) a set of premises that are all again of the form of one-step judgments, or (iii) the premise contains T instead of an atom on the left, in which case, we must consider the remaining case that follows (after using the weakening wL inference rule).

A
If the sequent has the form Σ ; ▶ σ d EQ'[	'
(P ', Q')], where

B(P ', Q') involves a recursive call to obisim and where P ' is a closed term, then we must instantiate the existential quantifier with an appropriate substitution. Standard logic programming techniques (as described in
A
step 1 above) can be used to find a substitution for Q' such that	'
Q −−→ Q
is provable (during this search, eigenvariables and locally scoped variables are treated as constants and P and A denote particular closed terms). There might be several ways to prove such a formula and, as a result, there might be several different substitutions for Q'. If one chooses the term T to instantiate Q', then one proceeds to prove the sequent Σ ; ▶

σ d Q.obisim P ' T . If the sequent has the form Σ ; ▶
Q' Λ B(P ', Q')], one proceeds in the same manner.
σ d EQ'[Q
A
−−~

Proof search for the first two cases is invertible (no backtracking is needed for those cases). On the other hand, the approach in the third case is not invertible, and backtracking on possibly all choices of substitution term T might be necessary to ensure completeness.

Proof search for late bisimulation.
The main difference between doing proof search for open bisimulation and late bisimulation is that in the latter, we need to instantiate the formula E x and explore the cases generated by the VL rule. First, consider a sequent of the form Σ,x ; E x, Γx ▶ Cx, where Γx ∪ {Cx} is a set of formulas which may have x free. One way to proceed with search for a proof would be to instantiate 6x(x = x V x /= x) with, say, a and with b. Thus, we need to consider proofs of the sequent is Σ,x ; x = a V x /= a, x = b V x /= b, Γx ▶ Cx. Using the VL rule twice, we are left with four sequents to prove:
Σ,x ; x = a, x = b, Γx ▶ Cx which is proved trivially since the equalities

are contradictory;
Σ,x ; x = a, x /= b, Γx ▶ Cx, which is equivalent to Σ ; Γa ▶ Ca;
Σ,x ; x /= a, x = b, Γx ▶ Cx, which is equivalent to Σ ; Γb ▶ Cb; and
Σ,x ; x /= a, x /= b, Γx ▶ Cx.
In this way, the excluded middle can be used with a set of n items to produce n+1 sequents: one for each member of the set and one extra sequent to handle all other cases (if there are any).
The main issue for implementing proof search with this specification of late bisimulation is to determine at what instances we should make instances of the excluded middle: answering this question would then reduce proof search to one similar to open bisimulation. There seems to be two extreme approaches to take: at one extreme, we can take instances for all possible names that are present in our process expressions: determining such instances is simple but might lead to many more cases to consider than is necessary. Another approach would be more lazy in that we would suggest an instance of the excluded middle only when there seems to be a need to consider that instance. The failure of a defY rule because of a mismatch (at the meta-level) between an eigenvariable and a constant would, for example, suggest that excluded middle should be invoked for that eigenvariable and that constant. The exact details of such schemes is left for future work.

Related and future work
There are many papers on topics related to the encoding of the operational semantics of the π-calculus into formal systems. In [6], Despeyroux presented an encoding of one-step transitions for the π-calculus using Coq but she did not consider the problem of computing bisimulation. Honsell, Miculan, and Scagnetto [18] encode the π-calculus in Coq and assume that there are an infi- nite number of global names. They then build formal mechanisms to support notions such as “freshness” within a scope, substitution of names, occurrences of names in expressions, etc. Gabbay [9] does something similar but uses a cer- tain kind of set theory [10] to help develop his formal mechanisms. Hirschkoff
[15] also used Coq but employed deBruijn numbers [5] instead of explicit names. In those paper that address bisimulation, formalizing names and their scopes, occurrences, freshness, and substitution is considerable work. In our approach, much of this same work is required, of course, but it is available in rather old technology, particularly, via Church’s Simple Theory of Types (where bindings and terms and formulas were put on a firm foundation via λ-terms), Gentzen’s sequent calculus and the central cut-elimination theorem,

Huet’s unification procedure for λ-terms, etc. More modern work on proof search in higher-order logics is also available to make our task easier and more declarative.
The encoding of late transition of π-calculus using HOAS and its related advantages have been studied in a number of previous works [17,25,6,18,36,26]. Our encoding, presented as a definition in Figure 2, has appeared in [26]. The material on proof automation in Section 6 clearly seems related to work on symbolic bisimulation (for example, see [3,14]) and work on using unification and logic programming techniques to compute symbolic bisimulations (see, for example, [1,2]). Since the technologies used to describe these other approaches is rather different than what is described here, a detailed comparison is left for future work.
It is, of course, interesting to consider the general π-calculus where infinite behaviors are allowed (by including ! or recursive definitions). In such cases, one might be able to still do many proofs involving bisimulation if the proof system included induction and co-induction inference rules. Inference rules for induction and co-induction appropriate for the sequent calculus have been presented in [29] and a version of these rules that also involves the ∇ quantifier has been presented in the first author’s PhD [41]. The encoding of π-calculus involving ! and a formalization of late bisimulation have been presented in [41]. Open bisimulation, however, has not been studied in this setting. We plan to investigate further how these stronger proof systems can be used establish properties about π-calculus expressions with infinite behaviors.
Specifications of operational semantics using a meta-logic should make it possible to formally prove properties concerning that operational semantics. This was the case, for example, with specifications of the evaluation and typ- ing of simple functional and imperative programming languages: a number of common theorems (determinacy of evaluation, subject-reduction, etc) can be naturally inferred using meta-logical specifications [21]. We plan to investigate using our meta-logic (also incorporating rules for induction and co-induction) for formally proving parts of the theory of the π-calculus. It seems, for exam- ple, rather transparent to prove that open bisimilarity is a congruence in our setting.



Acknowledgement

We are grateful to the reviewers of an earlier draft of this paper for their detailed and useful comments.

References
S. Basu, M. Mukund, C. R. Ramakrishnan, I. V. Ramakrishnan, and R. M. Verma. Local and symbolic bisimulation using tabled constraint logic programming. In Proc. of ICLP, volume 2237 of LNCS, pages 166–180. Springer, 2001.
M. Boreale. Symbolic trace analysis of cryptographic protocols. In Proceedings of ICALP 2001, volume 2076 of LNCS, pages 667 – 681. Springer-Verlag, 2001.
M. Boreale and R. D. Nicola. A symbolic semantics for the π-calculus. Information and Computation, 126(1):34–52, April 1996.
A. Church. A formulation of the simple theory of types. Journal of Symbolic Logic, 5:56–68, 1940.
N. de Bruijn. Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser Theorem. Indag. Math., 34(5):381–392, 1972.
J. Despeyroux. A higher-order specification of the π-calculus. In Proceedings of IFIP TCS 2000, Aug. 2000.
L.-H. Eriksson. A finitary version of the calculus of partial inductive definitions. In Proc. of the Second Int. Workshop on Extensions to Logic Programming, volume 596 of LNAI, pages 89–134. Springer-Verlag, 1991.
M. P. Fiore, G. D. Plotkin, and D. Turi. Abstract syntax and variable binding. In Proceedings of LICS 1999, pages 193–202. IEEE, 1999.
M. J. Gabbay. The π-calculus in FM. In F. Kamareddine, editor, Thirty-ﬁve years of Automath, volume IV, pages 80–149. Kluwer, 2003.
M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding.
Formal Aspects of Computing, 13:341–363, 2001.
G. Gentzen. Investigations into logical deductions. In M. E. Szabo, editor, The Collected Papers of Gerhard Gentzen, pages 68–131. North-Holland Publishing Co., Amsterdam, 1969.
J.-Y. Girard. A fixpoint theorem in linear logic. Email to the linear@cs.stanford.edu mailing list, February 1992.
L. Halln¨as and P. Schroeder-Heister. A proof-theoretic approach to logic programming. ii. Programs as definitions. Journal of Logic and Computation, 1(5):635–660, October 1991.
M. Hennessy and H. Lin. Symbolic bisimulations. Theoretical Computer Science, 138(2):353– 389, Feb. 1995.
D. Hirschkoff. A full formalization of pi-calculus theory in the Calculus of Constructions. In
Proc. of TPHOLs’97, number 1275 in LNCS, pages 153–169, 1997.
M. Hofmann. Semantical analysis of higher-order abstract syntax. In Proc. of LICS 1999, pages 204–213. IEEE Computer Society Press, 1999.
F. Honsell, M. Lenisa, U. Montanari, and M. Pistore. Final semantics for the π-calculus. In
Proc. of PROCOMET’98, 1998.
F. Honsell, M. Miculan, and I. Scagnetto. Pi-calculus in (co)inductive type theory. Theoretical Computer Science, 253(2):239–285, 2001.
G. Huet. A unification algorithm for typed λ-calculus. Theoretical Computer Science, 1:27–57, 1975.
R. McDowell and D. Miller.  Cut-elimination for a logic with definitions and induction.
Theoretical Computer Science, 232:91–119, 2000.


R. McDowell and D. Miller. Reasoning with higher-order abstract syntax in a logical framework. ACM Trans. on Computational Logic, 3(1):80–136, 2002.
D. Miller. A logic programming language with lambda-abstraction, function variables, and simple unification. J. of Logic and Comp., 1(4):497–536, 1991.
D. Miller. Unification under a mixed prefix. Journal of Symbolic Computation, 14:321–358, 1992.
D. Miller. Abstract syntax for variable binders: An overview. In J. Lloyd and et. al., editors,
Computational Logic - CL 2000, number 1861 in LNAI, pages 239–253. Springer, 2000.
D. Miller and C. Palamidessi. Foundational aspects of syntax. In P. Degano, R. Gorrieri,
A. Marchetti-Spaccamela, and P. Wegner, editors, ACM Computing Surveys Symposium on Theoretical Computer Science: A Perspective, volume 31. ACM, Sep 1999.
D. Miller and A. Tiu.  A proof theory for generic judgments: An extended abstract.  In
P. Kolaitis, editor, Proc. of LICS 2003, pages 118 – 127, July 2003.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, Part II. Information and Computation, pages 41–77, 1992.
J. C. Mitchell and E. Moggi. Kripke-style models for typed lambda calculus. Annals of Pure and Applied Logic, 51, 1991.
A. Momigliano and A. Tiu. Induction and co-induction in sequent calculus. In Proc. of TYPES 2003, volume 3085 of LNCS, pages 293 – 308. Springer, 2003.
G. Nadathur. A treatment of higher-order features in logic programming. Theory and Practice of Logic Programming, To appear.
G. Nadathur and D. J. Mitchell. System description: Teyjus—a compiler and abstract machine based implementation of Lambda Prolog. In Proc. of the 16th Int. Conference on Automated Deduction, pages 287–291. Springer, 1999.
T. Nipkow. Functional unification of higher-order patterns. In M. Vardi, editor, LICS93, pages 64–74. IEEE, June 1993.
L. C. Paulson. Isabelle: The next 700 theorem provers. In P. Odifreddi, editor, Logic and Computer Science, pages 361–386. Academic Press, 1990.
F. Pfenning and C. Elliott. Higher-order abstract syntax. In Proceedings of the ACM- SIGPLAN Conference on Programming Language Design and Implementation, pages 199–208. ACM Press, June 1988.
F. Pfenning and C. Schu¨rmann. System description: Twelf — A meta-logical framework for deductive systems. In H. Ganzinger, editor, Proc. of CADE-16, pages 202–206. Springer-Verlag LNAI 1632, 1999.
C. R¨ockl, D. Hirschkoff, and S. Berghofer. Higher-order abstract syntax with induction in Isabelle/HOL: Formalizing the pi-calculus and mechanizing the theory of contexts. In Proc. of FOSSACS’01, volume 2030 of LNCS, pages 364–378. Springer, 2001.
D. Sangiorgi. A theory of bisimulation for the π-calculus. Acta Informatica, 33(1):69–97, 1996.
D. Sangiorgi and D. Walker. π-Calculus: A Theory of Mobile Processes. Cambridge University Press, 2001.
P. Schroeder-Heister. Rules of definitional reflection. In M. Vardi, editor, Proc. of LICS’93, pages 222–232. IEEE, 1993.
R. F. St¨ark. Cut-property and negation as failure. International Journal of Foundations of Computer Science, 5(2):129–164, 1994.
A. Tiu. A Logical Framework for Reasoning about Logical Speciﬁcations. PhD thesis, Pennsylvania State University, May 2004.

Appendix A. Inference rules of FΟλΔ∇
The “core” inference rules for FΟλΔ∇ are given in Figure 5. Except for the rules for ∇, these are essentially the inference rules for intuitionistic logic given by Gentzen [11]. The only missing inference rules are those for introducing defined formulas: these are given in Section 2.
init	Σ; Δ ▶B	Σ; B, Γ ▶C cut

Σ; σ d B, Γ ▶ σ d B
Σ; σ d B, σ d C, Γ ▶D 


Σ; σ d B ∧ C, Γ ▶D  ∧L
Σ; Δ, Γ ▶C 
Σ; Γ ▶ σ d B	Σ; Γ ▶ σ d C


Σ; Γ ▶ σ d B ∧ C	∧R

Σ; σ d B, Γ ▶D	Σ; σ d C, Γ ▶D 


Σ; σ d B ∨ C, Γ ▶D	∨L
Σ; Γ ▶ σ d B


Σ; Γ ▶ σ d B ∨ C ∨R
Σ; Γ ▶ σ d C


Σ; Γ ▶ σ d B ∨ C ∨R

Σ; Γ ▶ σ d B	Σ; σ d C, Γ ▶D 


Σ; σ d B ⊃ C, Γ ▶D	⊃L 
Σ,σ ▶ t : g	Σ; σ d B[t/x], Γ ▶C 
Σ; σ d ∀γ x.B, Γ ▶C	∀L
Σ; σ d B, Γ ▶ σ d C


Σ; Γ ▶ σ d B ⊃ C  ⊃R 
Σ,h ; Γ ▶ σ d B[(h σ)/x]
Σ; Γ ▶ σ d ∀x.B	∀R

Σ,h ; σ d B[(h σ)/x], Γ ▶C 


Σ; σ d ∃x.B, Γ ▶C	∃L
Σ; (σ, y) d B[y/x], Γ ▶C 
∇L(∗)
Σ; σ d ∇x B, Γ ▶C 
Σ,σ ▶ t : g	Σ; Γ ▶ σ d B[t/x]


Σ; Γ ▶ σ d ∃γx.B	∃R
Σ; Γ ▶ (σ, y) d B[y/x]
∇R(∗)
Σ; Γ ▶ σ d ∇x B 

Σ; σ d ⊥, Γ ▶B ⊥L
Σ; Γ ▶ σ d T TR
Σ; B, B, Γ ▶C cL
Σ; B, Γ ▶C 
Σ; Γ ▶C  wL
Σ; B, Γ ▶C 

(*) provided that y is not free in λx B.
Fig. 5. The core rules of FOλΔ∇.


Appendix B. Specification of strong early bisimilarity
We take the notion of strong early bisimilarity as it is defined in [27] for late transition system. The corresponding specification is given in Figure 6. As noted in [27], the essential difference between late and early bisimulation is in the scope of (universal) quantification of names in the case of bound input transitions. This is reflected in the specification in Figure 6, where not only the scope of quantification is enlarged, but also the scope of the excluded middle axiom on names.



Δ	'	A	'	'	A	'	'  '
ebisim P Q = ∀A∀P [(P −−→ P ) ⊃ ∃Q .(Q −−→ Q ) ∧ ebisim P Q ] ∧
'	A	'	'	A	'	'  '
∀A∀Q [(Q −−→ Q ) ⊃ ∃P .(P −−→ P ) ∧ ebisim Q P ] ∧
↓X	↓X
∀X∀P '[ (P −−~ P ') ⊃ ∀w.E w ⊃ ∃Q'.(Q −−~ Q') ∧ ebisim (P 'w) (Q'w)] ∧
↓X	↓X
∀X∀Q'[ (Q −−~ Q') ⊃ ∀w.E w ⊃ ∃P '.(P −−~ P ') ∧ ebisim (Q'w) (P 'w)] ∧
†X	†X
∀X∀P ' [(P −−~ P ') ⊃ ∃Q'.(Q −−~ Q') ∧ ∇w.ebisim (P 'w) (Q'w)] ∧

'	†X	'
'	†X	'	'	'

∀X∀Q [(Q −−~ Q ) ⊃ ∃P .(P −−~ P ) ∧ ∇w.ebisim (Q w) (P w)] where E = λx ∀y(x = y) ∨ (x = y ⊃ ⊥).
Fig. 6. Specification of strong early bisimulation.
