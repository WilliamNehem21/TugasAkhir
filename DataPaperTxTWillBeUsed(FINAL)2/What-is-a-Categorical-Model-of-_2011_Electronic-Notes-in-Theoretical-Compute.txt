

Electronic Notes in Theoretical Computer Science 229 (5) (2011) 19–37
www.elsevier.com/locate/entcs
What is a Categorical Model of Arrows?
Robert Atkey1
Dept. of Computer and Information Sciences, University of Strathclyde, 26 Richmond Street, Glasgow G1 1XH, United Kingdom

Abstract
We investigate what the correct categorical formulation of Hughes’ Arrows should be. It has long been folklore that Arrows, a functional programming construct, and Freyd categories, a categorical notion due to Power, Robinson and Thielecke, are somehow equivalent.
In this paper, we show that the situation is more subtle. By considering Arrows wholly within the base category we derive two alternative formulations of Freyd category that are equivalent to Arrows—enriched Freyd categories and indexed Freyd categories. By imposing a further condition, we characterise those indexed Freyd categories that are isomorphic to Freyd categories. The key differentiating point is the number of inputs available to a computation and the structure available on them, where structured input is modelled using comonads.
Keywords: Hughes arrows, Freyd categories


Introduction
Ever since Hughes introduced Arrows [2] and Power, Robinson and Thielecke intro- duced Freyd categories [11,12] it has been folklore that the two definitions are in some way equivalent. The aim of this paper is to explore the connections between the two definitions. Our main result is that Arrows are in fact more general than Freyd categories. This is due to Arrows allowing two separate inputs to computa- tions, one of which may be structured, while Freyd categories only allow a single input to computations. Generalising further we get indexed Freyd categories that allow two inputs, both of which may be structured. Structure on input can be modelled using comonads.
Looking at the definitions of Arrows and Freyd categories it is certainly tempting to think that they are actually the same thing. In Haskell, Arrows are defined as members of the following type class (the actual type class in the Haskell libraries has extra members, but these are definable from the ones we have given):

1 Email: Robert.Atkey@cis.strath.ac.uk

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.02.014

class Arrow a where
arr	:: (x -> y) -> a x y
(>>>) :: a x y -> a y z -> a x z first :: a x y -> a (x,z) (y,z)
In our categorical definitions we write Ar(x, y) for a x y, arr for arr, >>> for >>>
and ﬁrst for first, and we use this notation from now on.
Thus a type operator Ar that takes two arguments is an Arrow if it has definitions for these functions which satisfy some equations (we give these equations in Section 2). A way to read these definitions is to see Ar(x, y) as the type of “arrows” from x to y. The arr function then takes normal functions to arrows and the >>> function composes two arrows. Thus it seems that each instance of Arrow defines a category within Haskell, whose objects are Haskell types and whose arrows are members of Ar(x, y), and a functor from the category of Haskell types and functions to this new category. The ﬁrst function demands some extra structure on the new category which is used when sequencing arrows.
The definition of Freyd category is beguiling similar. A Freyd category consists of a pair of categories C and K and an identity-on-objects functor J : C → K, where C has finite products, K is symmetric premonoidal and J maps the finite products to the symmetric premonoidal structure. We give the full definition of symmetric premonoidal in Section 3; for now, we just need that it has a functor
— u z : K(x, y) → K(x × z, y × z).
It appears that Freyd categories and Arrows are the same thing: the category C corresponds to the category of Haskell types and functions, the category K is the category described by Ar(x, y), the functor J is the function arr , composition in K is the function >>> and K’s premonoidal structure is the function ﬁrst .
This naive view misses a crucial point: Freyd categories are defined using or- dinary categories where there is a set of morphisms between objects; Arrows are defined so that there is a Haskell type of morphisms between objects. Therefore the correct way to see Arrows is as enriched Freyd categories; where the enrichment is over the base category. We recall the definitions of enriched category, functor and so on in Section A.2. We show that Arrows are directly equivalent to enriched Freyd categories in Section 3.2.
However, this view is not particularly enlightening; the assumption that Arrows and Freyd categories are equivalent has persisted for some time, so it seems clear that there must be some direct relationship between the two. Observe that a crucial difference between Freyd categories and Arrows is that a computation described by an Arrow is a morphism in C(w, Ar(x, y)), whereas a computation described by a Freyd category is a morphism in K(x, y). The Arrow computation has additional input w that the Freyd category does not have. To see that this additional input can be significant consider a Freyd category built from a comonad (W, ϵ, δ) so that K(x, y)= C(Wx, y); the analogous Arrow has C(w, Ar(x, y)) = C(w, [Wx → y]) ∼= C(w × Wx, y). Thus, the arrow computation has access to unstructured input w and structured input x, while the Freyd category computation only has access to structured input x.

To model this situation we generalise from Arrow computations of the form C(w, Ar(x, y)) to a C-indexed category H where Hw(x, y) denotes computations with unstructured input w, possibly structured input x and possibly structured output y. This forms the core of the definition of indexed Freyd category that we give in Section 4. Every Arrow gives an indexed Freyd category, but to go back again we must assume that the indexed Freyd category is closed, meaning that there is a representation for morphisms in H:
Hw(x, y) ∼= C(w, Ar(x, y)).
Indexed Freyd categories that are not closed have more flexibility when it comes to their input. For instance, Hw(x, y) = C(W (w × Wjx), y) and Hw(Ww × Wjw, y) both define indexed Freyd categories that are not closed for comonads W and Wj. Not every Arrow demands structure on its input. In particular, Arrows built from strong monads (T, η, μ, τ ) have computations as morphisms in C(w, [x → Ty]) ∼= C(w × x, Ty). In Section 4.2 we examine translations between Freyd cate- gories and indexed Freyd categories and arrive at a characterisation of indexed Freyd categories that are equivalent to Freyd categories, which are those that satisfy the
isomorphism:
Hw×x(y, z) ∼= Hw(x × y, z).
(where the direction Hw(x × y, z) → Hw×x(y, z) is always determined). In other words, indexed Freyd categories that do not distinguish between the two inputs. Examples include closed indexed Freyd categories derived from monads and non- closed indexed Freyd categories derived from comonads: Hw(x, y)= C(W (w×x), y). In Section 5, we translate this requirement back to Arrows, getting the isomorphism:
Ar(x × y, z) ∼= [x → Ar(y, z)].
(where, again, the direction [x → Ar(y, z)] → Ar(x × y, z) is always determined). Using the fact that closed Freyd categories are equivalent to strong monads [12], we can conclude that Arrows that satisfy this condition are equivalent to strong monads.
We summarise the relationships between the various definitions given in this pa- per in Figure 1. Each node of the diagram is the category of the named objects over a fixed category C and appropriate morphisms. Hooked arrows denote subcategory inclusions, which are all full here. Arrows marked with “ ” denote equivalences and those marked with “=” denote strict equalities. In the bottom left corner, the inclusion functor has a right adjoint which forgets about fibres Hw where w /= 1.
Related Work
Heunen, Jacobs and Hasuo [1,3] have previously investigated the categorical seman- tics of Arrows. They take the categorical definition of Arrow to be a monoid in the category of bifunctors Cop × C → V , where V is symmetric monoidal closed and C is V -enriched. In the case when V = Set, it was proved in [1] that under this definition, Arrows are exactly Freyd categories. This approach has the advantage is being more flexible about what is regarded as “inside” (the category C) the lan-

Freyd		
Closed

¸,
Categ,or,ies

 
IndeJxe d
Freyd
szFreyd
Categ,or,ies
 
Closed Indexed
¸, 
 St rong   M,,o,n¸ads

 
ArroJw s



z Enriched
Freyd

Categories
¸, sz
Freyd
¸ , +  i somorphism¸=,  C ategories

+isomorphism
 z,,
E

rz
Categories
+isomorphism
˛z

CloJsed 
˛z	+isomorphism
˛z


J 

Indexed
¸,	 zIndexed
¸,	  J ¸, =	 Enriched

Freyd Categories
s Freyd Categories
Arrows
 Freyd Categories

Fig. 1. Relationships between notions of computation in this paper
guage we are modelling and what is “outside” (the category V ). However, matters are complicated by size issues when V = C for cartesian closed C, since, in order to have the colimits necessary to talk about monoids in the category of bifunctors, C can only be a pre-order.
This work was originally inspired by Lindley, Wadler and Yallop’s work on the Arrow Calculus [6]. In this calculus there are two typing judgements
Γ ▶ e : A	Γ; Δ ▶ M ! A.
These correspond to the two categories in the definition of indexed Freyd category; in fact the Arrow calculus is the internal language of closed indexed Freyd categories.
Overview
In the next section we present the formal definition of Arrows in a cartesian closed category. We also present an alternative but equivalent definition that only requires finite products to be present on the base category. This will be more technically convenient for the rest of the development. In Section 3 we recall the definition of Freyd category and show that Arrows correspond directly to a natural definition of enriched Freyd category. In Section 4 we define indexed Freyd categories and investigate their relationship with normal Freyd categories. Section 5 returns to the connection between Freyd categories and Arrows and characterises those Arrows that are equivalent to closed Freyd categories and hence to strong monads. Section 6 concludes. Auxiliary definitions and notations are given in Appendix A.
Arrows
We give two definitions of an Arrow on a category. The first follows the Haskell definition closely, requiring that the base category be cartesian closed. The second definition only requires us to assume that the base category has finite products.

We will prove that these two definitions are equivalent, and in Sections 3 and 4 we will use the two alternatives to give two ways of interpreting the statement that “Arrows are Freyd categories”.

Arrows in Cartesian Closed Categories
Let C be a cartesian closed category.
Definition 2.1 An Arrow in C consists of a mapping of objects Ar : |C|×|C|→ |C|
and three families of morphisms:
arrxy : [x → y] → Ar(x, y)
>>>xyz : Ar(x, y) × Ar(y, z) → Ar(x, z)
ﬁrstxyz : Ar(x, y) → Ar(x × z, y × z)
These must satisfy the following nine arrow laws, where we interpret the meanings of these equations using the internal simply-typed λ-calculus of C:
arr (id ) >>> a = a
a >>> arr (id )= a
(a >>> b) >>> c = a >>> (b >>> c)
arr (f ; g)= arr (f ) >>> arr (g)
ﬁrst (a) >>> arr (π1)= arr (π1) >>> a 
ﬁrst (a) >>> arr (id × f )= arr (id × f ) >>> ﬁrst (a)
ﬁrst (a) >>> arr (α)= arr (α) >>> ﬁrst (ﬁrst (a))
ﬁrst (arr (f )) = arr (f × id )
ﬁrst (a >>> b)= ﬁrst (a) >>> ﬁrst (b)
We have followed a convention to use f and g for variables of function type in C’s internal language and a, b, c for variables of arrow type.
We now give four example classes of arrows derived from other structure on C.
Given a strong monad (T, η, μ, t) on C, we can define its Kleisli Arrow by Ar(x, y)= [x → Ty]. The three families of morphisms are defined as follows:
arrxy(f )= f ; ϵ
a >>>xyz b = a; T b; μ
ﬁrstxyz (a)= a × z; σT (y)z ; τ ; Tσzy
where σxy : x × y → y × x is the symmetry operation. This is the traditional definition for computational effects [9].
Given a comonad (W, ϵ, δ) on C, we can define its CoKleisli Arrow by Ar(x, y)= [Wx → y]. In this case, the three families of morphisms are defined as follows:
arrxy(f )= ϵ; f
a >>>xyz b = δ; Wa; b
ﬁrstxyz (a)= ⟨W π1, ϵ; π2⟩; a × z

Note that comonads have no need for a strength to define ﬁrst . Comonads have been used to give semantics to dataflow computations [13].
Given a comonad (W, ϵ, δ) and a strong monad (T, η, μ, t) that have a distribu- tive law λ : WT → TW , then we can define their BiKleisli Arrow Ar(x, y) = [Wx → Ty]. Uustalu and Vene use this construction to give a semantics to partial dataflow programs [13].
Given an applicative functor (I, pure, ②) [8] its Static Arrow is given by Ar(x, y)= 
I([x → y]). The three families of morphisms are defined as:
arrxy(f )= pure(f )
a >>>xyz b = pure(;j) ② a ② b
ﬁrstxyz (a)= pure(×idz) ② a
where (;j) is the curried version of the composition operator.
Lemma 2.2 Given an Arrow, we can deﬁne another transformation secondxyz : Ar(x, y) → Ar(z × x, z × y), that satisﬁes the following laws:
second (a)= arr (σ) >>> ﬁrst (a) >>> arr (σ)
second (a) >>> arr (π2)= arr (π2) >>> a 
second (a) >>> arr (f × id )= arr (f × id ) >>> second (a)
second (second (a)) >>> arr (α)= arr (α) >>> second (a)
second (arr (f )) = arr (id × f )
second (a >>> b)= second (a) >>> second (b)
Proof. Define second wxyz(a) = arr (σzx) >>> ﬁrst (a) >>> arr (σyz), where σxy :
x × y → y × x is the symmetry function; this automatically satisfies equation
(10). Equation (11) follows from arrow laws (4) and (5) and the fact that σ; π1 = π2 and vice versa. Likewise, equations (12), (13), (14) and (15) follow from the corresponding law for ﬁrst and the properties of the symmetric monoidal structure defined in terms of C’s internal language.	2

Arrows in Categories with Finite Products
We now give an alternative definition of Arrow, but this time only assuming that the base category C has (chosen) finite products. We will show that, when C is cartesian closed, this definition is equivalent to the previous one.
In order to state this definition, we make use of the indexed category C : Cop →
Cat, defined in Section A.3.
Definition 2.3 An Arrow on a category C with finite products is given by a map- ping of objects Ar : |C| × |C| → |C| and three transformations of homsets, all natural in w:
arrwxy : Cw(x, y) → C(w, Ar(x, y))
>>>wxyz : C(w, Ar(x, y)) × C(w, Ar(y, z)) → C(w, Ar(x, z))
ﬁrstwxyz : C(w, Ar(x, y)) → C(w, Ar(x × z, y × z))

These transformations must obey the same laws (1)-(9) as for arrows, where the equations are interpreted as equalities between C morphisms generated by the above transformations and the structure of C. In those equations we use f, g for morphisms in Cw(x, y) and a, b, c for morphisms in C(w, Ar(x, y).
Theorem 2.4 For a cartesian closed category, to give an Arrow as in Deﬁnition
2.1 is exactly to give one as in Deﬁnition 2.3.
Proof. Taking the three transformations in Definition 2.3 and using the isomor- phisms of homsets due to the cartesian closure, we see that they are in bijective correspondence with triples of transformations of the form

j
wxy
j
wxyz
j
wxyz
: C(w, [x → y]) → C(w, Ar(x, y))
: C(w, Ar(x, y) × Ar(y, z)) → C(w, Ar(x, z))
: C(w, Ar(x, y)) → C(w, Ar(x × z, y × z))

all natural in w. By Yoneda, these are in bijective correspondence with the three families of arrows required by Definition 2.1. It remains to check that the required equations hold in both directions. This involves straightforward diagram chasing for each equation. For example, for the associativity of Arrow composition, equation (3), the diagram is:


Ar(w, x)×
Ar(x, y)×
Ar(y, z)
—; >×id	 C  v, Ar(w, y)×
Ar(y, z)

Π−1;Π−1×id =Π−1;id×Π−1
z 
C(v, Ar(w, x))×




—;id× >
C(v, Ar(x, y))×
C(v, Ar(y, z))
id× >′
J 
>′×id C  ( v, Ar(w, y))×
C(v, Ar(y, z))


—; >





Π−1
J 
C(v, Ar(w, x))×	>′
C( v, Ar(x, z))
>′

C  v, Ar(x, y)× 	—; >	 z_zJz 
Ar(y, zj)
where Π : C(w, x) × C(w, y) ∼= C(w, x × y). The outer diagram is the associativity law for Definition 2.1 and the inner diagram is associativity for Definition 2.3. The four diagrams around the edge all commute by the naturality of Π—1 and the correspondence between >>> and >>>j. Hence the inner diagram commutes if the outer ones does, and vice versa.	2
The following lemma states that Definition 2.3 can also have an additional second transformation defined upon it. The proof is straightforward: one can either follow the proof of the previous theorem and translate the second transformation defined in the proof of Lemma 2.2, or one can directly follow the proof of Lemma 2.2 and

define second directly from the ﬁrst .
Lemma 2.5 Given an Arrow, we can deﬁne another transformation secondxyz : C(w, Ar(x, y)) → C(w, Ar(z × x, z × y)), that satisﬁes the laws (10) to (15) given above.

Arrows and Freyd Categories
In this section we examine the relationship between Arrows and Freyd categories. We first recall the definition of a (closed) Freyd category and the relationship with strong monads. We then investigate how the definition of Arrow in a CCC (Defini- tion 2.1) can be seen to be a Freyd category, where we arrive at a natural definition of an enriched Freyd category. In the next section we will show that enriched Freyd categories and Freyd categories are not the same thing.

Freyd Categories
We first recall the definition of ordinary Freyd categories, following [11,12].
Definition 3.1 Given a category K, a binoidal structure on K consists of two families of functors x  − : K → K and − u x : K → K, where x ∈ |K|, such that x  y = x u y, which we write as x ⊗ y.
A morphism f : x → xj of a binoidal category K is central if, for all g : y → yj, f u y; xj  g = x  g; f u yj and symmetrically.
Definition 3.2 Given a binoidal category K, symmetric premonoidal structure on K consists of an object I and four natural transformations α : (x ⊗ y) ⊗ z → x⊗ (y⊗z), λ : x⊗I → x, ρ : I ⊗x → x and σ : x⊗y → y⊗x, whose components are all central and who satisfy the usual coherence conditions for symmetric monoidal structure [7].
Note that any category with a choice of finite products and a terminal object (any indeed any symmetric monoidal category) is symmetric premonoidal.
Definition 3.3 A Freyd category consists of a category C with finite products, a symmetric premonoidal category K and an identity-on-objects functor that exactly preserves symmetric premonoidal structure and such that J(f ) is always central.
Definition 3.4 A closed Freyd category is a Freyd category with a right adjoint to J − ×y for every y:
Λ: K(x × y, z) ∼= C(x, [y ~ z])
We use the notation [x ~ y] to distinguish from the cartesian closed internal hom [x → y].
The equivalences we consider in the next section will only be up to isomorphism of Freyd categories, so we must define morphisms of Freyd categories.

Definition 3.5 Given two Freyd categories J1 : C → K1 and J2 : C → K2, a morphism between them is a functor F : K1 → K2 that strictly preserves symmetric premonoidal structure and satisfies F (J1(f )) = J2(f ). Freyd categories and their morphisms form a category Freyd(C). Closed Freyd categories form a category CFreyd(C).
The following proposition [5] establishes a link between closed Freyd categories and strong monads.
Proposition 3.6 For a cartesian closed category C, the category CFreyd(C) is equivalent to the category of strong monads and strong monad morphisms.
Enriched Freyd Categories
We start with a cartesian closed category C with an Arrow (Ar, arr, >>>, ﬁrst ) as in Definition 2.1, and work towards a suitable definition of Freyd category that matches. Intuitively, the ﬁrst transformations, and the derived second transforma- tions, should correspond to the required symmetric premonoidal structure, but on what category? And what corresponds to the functor J?
The answer can be seen by looking at the first two parts of Definition 2.1 and comparing them to the definition of enriched category (see Appendix A.2 or Kelly [4]). Given a category C with finite products, a C-enriched category D consists of a collection of objects |D|, a mapping D : |D|×|D|→ |C| (the hom-objects) and a pair

of transformations id D : 1 → D(x, x) and compD
: D(x, y) × D(y, z) → D(x, z)

x	xyz
which satisfy the evident equations for identities and associativity. It is standard
that if C is cartesian closed, then by taking the hom-objects to be [x → y] we can see C as being C-enriched.
Looking at Definition 2.1, there is another obvious choice for hom-objects with
C’s objects: take the hom-objects to be Ar(x, y) and use arr (id ) for identities and
>>> for composition. It is easy to see that Arrow laws (1), (2), (3) imply the laws for a C-enriched category and vice versa. Thus we have two C-categories with the same objects as C: C, enriched by [x → y]; and K, enriched by Ar(x, y).
A C-enriched functor is given by a mapping of objects F : |D| → |Dj| and a transformation of hom-objects D(x, y) → Dj(Fx, Fy) that preserves identities and composition. We can use the transformation arr to define a C-functor from C to K, which will do for our enriched analogue of J. The Arrow law (4) and our definition of identities as arr (id ) implies the laws for a C-functor and vice versa.
So we now have that the (Ar, arr, >>>) part of the definition of an Arrow on a category C is equivalent to having a pair of C-categories with the same objects as C and an identity-on-objects functor between them. It remains to devise a suitable analogue of symmetric premonoidal structure for C-categories, and to show that it corresponds exactly to the transformation ﬁrst .
The definition of binoidal structure carries over directly from the non-enriched case simply by replacing “functor” by “C-functor” everywhere. Binoidal structure on C is given directly by C’s finite products, and binoidal structure on K is given by f u x = ﬁrst (f ) and x  f = second (f ). By Arrow laws (8), (9), (14) and (15)

these give C-functors.
A slightly tricky point is the definition of centrality for C-enriched binoidal struc- ture because we cannot say “for all morphisms...”. We deal with this by requiring that all arrows produced by arr are central, in the following sense:
[x → xj] × Ar(y, yj) 	σ	 A r(y, yj) × [x → xj]

arr×id J 
Ar(x, xj) × Ar(y, yj)
(—uy)×(x′ —) J 
Ar(x × y, xj × y) × Ar(xj × y, xj × yj)
Jid × arr
Ar(y, yj) × Ar(x, xj)
(x —)×(—uy′) J 
Ar(x × y, x × yj) × Ar(x × yj, xj × yj)

J> 
Ar(x × y, xj × yj)
and symmetrically for the [x → y] component “on the bottom”.
It is easy to see that by Arrow laws (6), (8), (12) and (14) that Arrows sat- isfy these diagrams, and conversely. The final parts we need, that the symmetric monoidal structure isomorphisms are natural is covered by Arrow laws (5), (7) and (10).
In summary, we have proved:
Theorem 3.7 For a cartesian closed category C, to give an Arrow as in Deﬁnition
2.1 is to give a C-enriched Freyd category J : C → K.
An obvious step now would be to go on and define a notion of closure for C- enriched Freyd categories. We defer this step until Section 5.
Indexed Freyd Categories
We now start from an Arrow in a category with finite products (Definition 2.3) and examine how it can been seen to be analogous to the structure of a Freyd category. The structure that we finish up with, which we call indexed Freyd categories, will be more general than that of Arrows. We then investigate the relationship between in- dexed Freyd categories and Freyd categories and give an extra condition on indexed Freyd categories that makes them isomorphic to Freyd categories.

Indexed Freyd Categories
As in the previous section we seek a category on which we can find a premonoidal structure to use as our analogue of the codomain category of a Freyd category. The crucial step is to take the natural transformation arr : Cw(x, y) → C(w, Ar(x, y)) from Definition 2.3 and see it as a functor between C-indexed categories C and H, where |Hw| = |C| and Hw(x, y)= C(w, Ar(x, y)). H is a C indexed category with identities in the fibres given by arr (id ) and composition by >>>. By the Arrow laws (1), (2) and (3) the fibres are well-defined categories. Re-indexing is accomplished by


on-objects indexed functor J : C (4).
→ H by the naturality of arr and Arrow law

Each of the fibres Hw can be given premonoidal structure: we define a u x = ﬁrst (a) and x  a = second (a); by arrow laws (8), (9), (14) and (15), these are well-defined functors. By laws (8), (6), (14) and (12), every morphism of the form arr (f ) is central; hence, we can define the premonoidal structure transformations via arr by those in Cw. Laws (5), (7), (10), (11) and (13) ensure that these are natural. By the naturality of ﬁrst and second , the re-indexing functors Hf preserve the premonoidal structure.
Each fibre of C automatically has premonoidal structure derived from the chosen finite products and the indexed functor J defined above preserves the premonoidal structure by laws (8) and (14) and the sufficient condition for centrality in the fibres Hw given above.
We consolidate the structure we have induced into a definition:
Definition 4.1 Given a category C with finite products, an indexed Freyd category consists of an indexed category H : Cop → Cat and an identity-on-objects indexed functor J : C → H, such that:
Each Hw has symmetric premonoidal structure;
All re-indexing functors Hf : Hw′ → Hw are identity-on-objects and strict symmetric premonoidal;
The functors Jw : Cw → Hw are strict symmetric premonoidal and every Jw(f ) is central.
We have shown that it is possible to go from an Arrow on a category with finite products to an indexed Freyd category, but it is not yet possible to go back the other way: there is no way to obtain an object of C that represents the arrow! We fix this by providing a further definition:
Definition 4.2 A closed indexed Freyd category is an indexed Freyd category J : C → H equipped with, for every pair of objects x and y, an object [x ~ y] and an isomorphism


natural in w.
Λwxy : Hw(x, y) ∼= C(w, [x ~ y])

An example of a non-closed indexed Freyd category is given by a category C with finite products and two comonads (W, ϵ, δ) and (Wj, ϵj, δj). Define Hw(x, y)= C(Wjw × Wx, y). It is easy to see that this gives an indexed Freyd category that is not, in general, closed.
Proposition 4.3 Given a category C with ﬁnite products, every Arrow gives rise to a closed indexed Freyd category and vice versa.
Proof. In the forward direction it remains to show that indexed Freyd categories arising from Arrows are closed: define the objects [x ~ y]= Ar(x, y); the isomor- phism is trivial since Hw(x, y)= C(w, Ar(x, y)).
Conversely, we can take any indexed Freyd category and obtain an arrow on the base category C. Define Ar(x, y)= [x ~ y] and:

arr (f )= Λ(J(f ))
a >>> b = Λ(Λ—1(a); Λ—1(b))
ﬁrst (a)= Λ(Λ—1(a) u x)
The laws are now easy to check.	2

The previous proposition states that we have two well-defined translations: one from Arrows to closed indexed Freyd categories, and one in the opposite direction. We now show that these two translations are mutually inverse, up to isomorphism. To state exactly what we mean by isomorphisms here, we define morphisms between Arrows on a base category and morphisms between indexed Freyd categories on a base category.
Definition 4.4 Let (Ar1, arr 1, >>>1, ﬁrst 1) and (Ar2, arr 2, >>>2, ﬁrst 2) be two Ar- rows on C in the sense of Definition 2.3. A morphism between them consists of a family of morphisms Fxy : Ar1(x, y) → Ar2(x, y) such that:
arr 1(f ); F = arr 2(f )
(a >>>1 b); F = (a; F ) >>>2 (b; F )
ﬁrst 1(a); F = ﬁrst 2(a; F )
Arrows and Arrow morphisms form a category Arrows(C).
Definition 4.5 Let J1 : C → H1 and J2 : C → H2 be two indexed Freyd cate- gories. A morphism between them is an indexed functor F : H1 → H2 that strictly preserves symmetric premonoidal structure and satisfies Fw(J1 (f )) = J2 (f ).
w	w
Indexed Freyd categories and morphisms form a category IdxFreyd(C). Closed indexed Freyd categories and morphisms form a category CIdxFreyd(C).
Theorem 4.6 The categories Arrow(C) and CIdxFreyd(C) are equivalent.
Proof. We must first check that the two translations defined above can be extended to be functors. Given an Arrow morphism F : Ar1(x, y) → Ar2(x, y) we need an indexed Freyd category morphism that will map C(w, Ar1(x, y)) to C(w, Ar2(x, y)), which is easily given by composition. In the opposite direction, given an closed indexed Freyd category morphism F : H1 → H2, define an Arrow morphism via Yoneda on the composite:

C(w, [x ~1 y]) ∼= H1
Fw	2
∼= C(w, [x ~2 y]).

w (x, y) −→ Hw (x, y)
We now check that this is an equivalence. Starting from an Arrow, translating to an indexed Freyd category and then back again, it is easy to check that we end up exactly where we started. Starting from a closed indexed Freyd category (J, H) translating to an Arrow and back again we get a closed indexed Freyd category where Hj (x, y)= C(w, Ar(x, y)) and Jj(f )= Λ(Jf ). This is isomorphic to (J, H) by Λ.	2

Indexed Freyd Categories and Freyd Categories
We now examine the relationship between indexed Freyd categories and Freyd cat- egories. It turns out that Freyd categories are embedded co-reflectively in indexed Freyd categories. First, we set up the two translations.
Lemma 4.7 There is a functor M : IdxFreyd(C) → Freyd(C).
Proof. Given an indexed Freyd category J : C → H we obtain an ordinary Freyd category JK : C → K by setting K(x, y)= H1(x, y) and taking JK to be the com- posite of the isomorphism between C and C1 and the functor J1. This definition makes K symmetric premonoidal because H1 is, and JK preserves symmetric pre- monoidal structure because the two components it is built from do. Indexed Freyd category morphisms F : H1 → H2 give Freyd category morphisms by restriction to F1 : K1 = H1 → H2 = K2.	2
1	1
Lemma 4.8 There is a functor N : Freyd(C) → IdxFreyd(C).
Proof. Assume a Freyd category J : C → K. Following the construction of C from C given in Section A.3, we construct K from K by considering the comonads Ww = w  − induced by objects w. The counit and comultiplication are given by J(π2): Wwx → x and J(⟨π1, id ): Wwx → WwWwx respectively; these are exactly the counit and comultiplication of the comonad we defined in C, via J. Again, every morphism f : w → wj in C gives a comonad morphism Wf : Ww → Ww′ .
We use these to construct a C-indexed category K^ where each fibre K^w has the
same objects as C and homsets Kw(x, y) = K(Wwx, y) = K(w × x, y). Similar to the definition of a choice of finite product structure on the fibres of C, symmetric premonoidal structure is definable on each of the fibres of K^ : given f ∈ K^w (x, y)
define f u^ z = α	; f u z. The functor J : C → K straightforwardly induces an
indexed functor J^ : C^ → K^ which is easily checked to preserve the premonoidal
structure. Given a Freyd category morphism F : K1 → K2 we get an indexed
Freyd category morphism defined by H1 (x, y)= K1(w × x, y) −F→ K2(w × x, y)= 
H2 (x, y).	2
Lemma 4.9 The functor N is an embedding.
Proof. We must check that N is injective on objects and is faithful. Injectivity on objects is obvious: if K1 = K2, then K1 = K2. Faithfulness also follows.	2
One can immediately see that there is not much hope of getting an equivalence here: the translation from indexed Freyd category to Freyd category only makes use of the fibre H1, not any of the others. Nevertheless, we play through what happens by looking at the back and forth translations.
Starting from a Freyd category, applying N and then M to get back to a Freyd category we end up the following definitions: Kj(x, y) = K(1 × x, y) and Jj(f ) = J(π2; f ). It is clear that there are Freyd category morphisms making this isomorphic to the original Freyd category.

If we start from an indexed Freyd category, things are different. Given an indexed Freyd category J : C → H, going via Freyd categories gives us Hj (x, y)= H1(w×x, y) and Jw(f )= J1(π2; f ). It is not the case in general that Hj is going to be isomorphic to H: consider the indexed Freyd category constructed from a comonad (W, ϵ, δ) which has Hw(x, y)= C(w×Wx, y). Then Hj (x, y)= C(1 ×W (w×x), y).
These are clearly not isomorphic.
However, it is the case that there is a morphism from Hj → H given by mapping
a ∈ H1(w × x, y) to the following arrow in Hw:

J(i^d)
H!(a)

x −→ w × x −→ y
where ! : w → 1 is the unique morphism. Some straightforward checking ensures that this is a natural transformation ε : NM → Id in IdxFreyd(C).
Theorem 4.10 The category Freyd(C) co-reflectively embeds into IdxFreyd(C).
Proof. It remains to show that M is right adjoint to N . The unit η of the ad- junction is the isomorphism between MN and Id given above and the counit is the natural transformation ε : NM → Id given above. Some lengthy but tedious checking ensures that these obey the triangular identities for adjunctions.	2
Given the above counterexample to the counit of the adjunction being an iso- morphism, we can see the essential difference between Freyd categories and indexed Freyd categories. In a Freyd category, computations, represented by members of K(x, y) have one input, which may or may not be structured: in the case of a Freyd category built from a comonad (K(x, y)= C(Wx, y)), it is structured; in the case of a Freyd category built from a monad (K(x, y) = C(x, Ty)) it is unstruc- tured. Indexed Freyd categories on the other hand have two inputs: computations in Hw(x, y) have access to an input of type w and an input of type x, either of which may be structured. In the case of closed indexed Freyd categories, the w input must be unstructured.
In the case when the indexed Freyd category is built from a monad, so that Hw(x, y) = C(w × x, Ty), there is no distinction between the two kinds of input. We then have an inverse to the counit ε, giving an isomorphism:
ε : H1(w × x, y) ∼= Hw(x, y)
An equivalent, and nicer, formulation is to state this with an object in place of 1:
(16)	Hw(x × y, z) ∼= Hw×x(y, z)
where the Hw(x × y, z) → Hw×z(y, z) direction is given by a '→ J(π^2 × y); Hπ1 (a). We will show in the next section that closed indexed Freyd categories that satisfy this isomorphism are equivalent to strong monads.
Theorem 4.11 The subcategory of IdxFreyd(C) whose objects satisfy (16) is equiv- alent to Freyd(C).
Proof. We have exactly demanded the additional property required for the functors
M and N to be an equivalence.	2

We can extend this to an equivalence between closed indexed Freyd categories that satisfy (16) and closed Freyd categories:
Theorem 4.12 The subcategory of CIdxFreyd(C) whose objects satisfy (16) is equivalent to CFreyd(C).
Note that the translation M : IdxFreyd(C) → Freyd(C) does not extend to the categories with closure. For example, if we start from a closed indexed Freyd category derived from a CoKleisli arrow, then Hw(x, y) = C(w, [Wx → y]) and the derived Freyd category via M has K(x, y) = H1(x, y) = C(1, [Wx → y]) ∼= C(Wx, y). It is clear that this Freyd category is not in general closed. A higher- level view of this failure is that the required isomorphism for closed Freyd categories:
K(x × y, z) ∼= C(x, [y ~ z])
splits the input of the computation in an arbitrary place, meaning that any structure the input has must be very weak.
Arrows and Freyd Categories, Revisited
We know from Proposition 3.6 that there is an equivalence between closed Freyd categories and strong monads. Given the equivalence between closed Freyd cate- gories and closed indexed Freyd categories satisfying isomorphism (16), it is natural to ask what this means in terms of arrows.
Given an Arrow on a cartesian closed category C, such that the indexed Freyd category derived from it satisfies isomorphism (16), we can derive the following isomorphism:
C(w, Ar(x × y, z)) ∼= Hw(x × y, z)
∼= Hw×x(y, z)
∼= C(w × x, Ar(y, z))
∼= C(w, [x → Ar(y, z)])
natural in w. Thus, via Yoneda, we have an isomorphism
(17)	Ar(x × y, z) ∼= [x → Ar(y, z)]
where the Ar(x × y, z) → [x → Ar(y, z)] direction is a '→ λx.arr (λy.(x, y)) >>> a in C’s internal language.
Theorem 5.1 The subcategory of Arrow(C) given by Arrows that support isomor- phism (17) is equivalent to CFreyd(C).
Proof. Observe that Arrows that support isomorphism (17) are equivalent to closed indexed Freyd categories that support isomorphism (16) by a restriction of Theorem
4.6. Hence by Theorem 4.12 the theorem follows.	2
Corollary 5.2 The subcategory of Arrow(C) given by Arrows that support isomor- phism (17) is equivalent to the category of strong monads on C and strong monad morphisms.

We can now define closed C-enriched Freyd categories as those that support isomorphism (17).
Corollary 5.3 Closed C-enriched Freyd categories are equivalent to strong monads.
We can recover the monad associated with an Arrow that supports isomorphism
(17) by setting Tx = Ar(1, x). The isomorphism is essential in defining the mul- tiplication of the monad. Arrows that are really monads have been identified in Haskell [2] as those that are members of the ArrowApply class:
class Arrow a => ArrowApply a where app :: a (a b c, b) c
That is, there is an Arrow Ar(Ar(x, y) × x, y), performing internal evaluation of Arrows. This is derivable from isomorphism (17) by taking the identity [Ar(y, z) → Ar(y, z)] backwards across the isomorphism (this is the direction that is not always definable).

Conclusions
We have shown that there is more to the connection between Freyd categories and Arrows than initially meets the eye. The crucial observation is that Arrows are defined completely within a base category, and so have more flexibility than Freyd categories. Investigating the connection between Freyd categories and Arrows has led to the interesting definition of indexed Freyd category, and the notion of “first- order” arrows—indexed Freyd categories that are not closed.
In future work we wish to establish the connection between Arrows/indexed Freyd categories and other notions of computation such as comonads and applicative functors in the same way as we have for strong monads in this work. We also want to investigate additional structure on Arrows such as recursion (the ArrowLoop type class) and coproducts (the ArrowChoice type class) and see what happens to the related indexed Freyd categories. Also, it would be interesting to consider freely adding closure to indexed Freyd categories, following Power’s free addition of closure to Freyd categories [10]. The additional theory developed by Jacobs and Hasuo in [3], which relates the definition of Arrows as monoids in categories of bifunctors to Eilenberg-Moore and Kleisli constructions also suggests further work.

Acknowledgement
I wish to thank Sam Lindley, Philip Wadler and Jeremy Yallop for useful discussions and insights into Arrows and related notions. This work was funded by the Re- QueST grant (EP/C537068) from the Engineering and Physical Sciences Research Council.

References
Heunen, C. and B. Jacobs, Arrows, like monads, are monoids, Electron. Notes in Theor. Comput. Sci.
158 (2006), pp. 219–236.
Hughes, J., Generalising monads to arrows, Sci. of Comput. Program. 37(1–3) (2000), pp. 67–111.
Jacobs, B. and I. Hasuo, Freyd is Kleisli, for arrows, in: C. McBride and T. Uustalu, eds., “Proc. of Wksh. on Mathematically Structured Functional Programming, MSFP 2006 (Kuressaare, July 2006),” Electronic Workshops in Computing, BCS, 2006.
Kelly, G. M., “Basic Concepts of Enriched Category Theory,” London Mathematical Society Lecture Notes 64, Cambridge University Press, 1982. Reprinted as: Reprints in Theory and Appl. of Categories 10 (2005), pp. 1–136.
Levy, P. B., J. Power and H. Thielecke, Modelling environments in call-by-value programming languages, Inform. and Comput. 185(2) (2003), pp. 182–210.
Lindley, S., P. Wadler and J. Yallop, The arrow calculus, Technical Report EDI-INF-RR-1258, University of Edinburgh, 2008.
Mac Lane, S., “Categories for the Working Mathematician,” 2nd edition, Graduate Texts in Mathematics 5, Springer, 1998.
McBride, C. and R. Paterson, Applicative programming with effects, J. of Funct. Program. 18 (2008),
pp. 1–13.
Moggi, E., Notions of computation and monads, Inform. and Comput. 93(1) (1991), pp. 55–92.
Power, J., Generic models for computational effects, Theor. Comput. Sci. 364(2) (2006), pp. 254–269.
Power, J. and E. Robinson, Premonoidal categories and notions of computation, Math. Structures in Comput. Sci. 7(5) (1997), pp. 453–468.
Power, J. and H. Thielecke, Closed Freyd- and kappa-categories, in: J. Wiedermann, P. van Emde Boas and M. Nielsen, eds., “Proc. of 26th Int. Coll. on Automata, Languages and Programming, ICALP ’99 (Prague, July 1999),” Lecture Notes in Computer Science 1644, Springer, 1999, pp. 625–634..
Uustalu, T. and V. Vene, Signals and comonads, J. of Univ. Comput. Sci. 11 (2005), pp. 1310–1326.

Auxiliary Definitions and Notation
This appendix recalls several standard definitions and defines the notation we use.
Cartesian Closed Categories
The constructions of this paper are carried out over a base category C which we assume to have finite products, and sometimes assume to be cartesian closed. We work with a choice of finite product structure, and we use x× y to denote its action on objects and 1 for the terminal object or empty product. We use ⟨f, g⟩ to denote pairing, πi for projections and f × g to denote the induced functor action. For cartesian closed structure we use [x → y] to denote the internal hom.
We also make use of several defined constants in categories with finite products, which have the types:
id : x → x
α : (x × y) × z → x × (y × z) σ : x × y → y × x
−; − : [x → y] × [y → z] → [x → z]
We also use the same notation for the “internal” versions of these constants, which have type 1 → −.

Enriched Categories
Enriched categories generalise ordinary categories by instead of assuming a set of morphisms between objects, we require a hom-object of some base category C. The canonical reference for enriched categories is Kelly [4]. Formally, given a cartesian closed category C, a C-enriched category D consists of a collection of objects |D| and for every pair x, y ∈ |D| a C object D(x, y)—the hom-objects of D—and two families of C-morphisms idx :1 → D(x, x) and >>>xyz : D(x, y)×D(y, z) → D(x, z), satisfying the diagrams:

D(x, y) × 1 ¸,~=
id×id
D(x, y) × D(y, y)
D(x, y) 	~=	 1 ×  D(x, y)
  
id×id
J 
D(x, x) × D(x, y)

comp×id

D(w, x) × D(x, y) × D(y, z)
 D (w, y) × D(y, z)



J 
D(w, x) × D(x, z)
comp
D(w, z)

Given two C-categories D and Dj,a C-functor F : D → Dj is given by a mapping of D objects to Dj objects and a family of C-morphisms Fxy : D(x, y) → D(Fx, Fy), satisfying the diagrams:

1
id D
D(x



, Fy)

compD
D(x, y) × D(y, z)	 D (x, z)

F×F
J 

F
compD′	J 

Dj(Fx, Fy) × Dj(Fy, Fz) D j(Fx, Fz)
Given two C-functors F and G from D to Dj, a C-natural transformation be- tween them is a family of C-morphisms ζx :1 → Dj(Fx, Gx) satisfying the diagram:
D(x, y) × 1  F×ζy  D j(Fx, Fy) × Dj(Fy, Gy)
,,
~=

D(x, y)
~=
J 




 ζx×F  j



comp
j
zj _
D_(¸F x, Gy)

1 × D(x, y)	D (Fx, Gx) × D (Gx, Gy)
Indexed Categories
Given a category C, a C-indexed category is a functor H from Cop → Cat, where Cat is the category of all categories and functors between them. For an object w of C we use Hw to denote the category that H gives us. The contravariant action of H

turns every morphism f : w → wj in C into a re-indexing functor Hf : Hw′ → Hw. Given two C-indexed categories H and Hj, an identity-on-objects C-indexed functor
F between them is a family of functors Fw : Hw → Hj such that for all f : w → wj
in C, Hf (Fw′ x)= Fw(Hf x) on objects and Hf (Fw′ g)= Fw(Hf g) on morphisms.
Assuming C has finite products, we can construct an indexed category C using C’s finite products. Every object w of C gives a comonad by Wwy = w × x, with counit ϵ = π2 : Wwx → x and comultiplication δ = ⟨π1, id⟩ : Wwx → WwWwx. Given a morphism f : w → wj there is a morphism of comonads Wf : Ww → Ww′ given by f ×−. Each comonad has an associated co-Kleisli category, which we write
induce functors C^f : C^w′ → C^w via precomposition with the induced comonad
morphisms. Hence we have an C-indexed category C, where every fibre has exactly the same objects as C. Moreover, each fibre Cw of this indexed category has finite products, a choice of which can be defined in terms of our chosen finite products on
C. It is also easy to see that C = C^1.
