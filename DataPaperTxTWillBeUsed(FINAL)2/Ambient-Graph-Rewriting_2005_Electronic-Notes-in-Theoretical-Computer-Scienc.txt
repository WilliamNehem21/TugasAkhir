Electronic Notes in Theoretical Computer Science 117 (2005) 335–351 
www.elsevier.com/locate/entcs


Ambient Graph Rewriting
Pietro Cenciarelli, Ivano Talamo, and Alessandro Tiberi
Dipartimento di Informatica, University of Rome - “La Sapienza”, Italy

Abstract
We investigate synchronized hyperedge replacement (SHR) as general framework for distributed programming and system design. We propose a slender version of SHR which dramaticaly reduces the mathematical overhead of the original proposal [5] and use it to interpret the distributed CCS
[7] and the calculus of Mobile Ambients [1] in a uniform semantic framework. The encodings are bisimulations. A tool for supporting distributed system design and analysis is presented. The tool, which adopts the slender SHR as intermediate language, integrates model checking techniques within the framework of (distributed) program development.
Keywords: synchronized hyperedge replacement, graph rewriting, Mobile Ambients, distributed CCS, model checking.

Introduction
Synchronized hyperedge replacement, SHR [5], is a graph rewrite system for modelling process interaction in a network environment. In this framework, inspired by [4], hyperedges are to represent agents, or software components, while nodes are thought of as channels, synchronisation points or, more gen- erally, network communication infrastructure. In [5] SHR has been used to provide a labelled transition system semantics of the calculus of Mobile Am- bients [1].
The idea that hypergraphs may interact by synchronising action and co- action pairs at specific synchronisation points (the nodes) is quite intuitive, while the flexibility of the model in representing diverse network topologies and communication protocols makes SHR a reasonable candidate as common semantic framework for interpreting different calculi. Unfortunately, the ad- mittedly considerable mathematical overhead involved in the original proposal


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.017


tends to obscure the basic intuition and makes it hard to prove metatheoretical properties.
In the present paper we propose a slender version of SHR based on a single, rather intuitive rule of parallel composition. While drammatically reducing mathematical complexity we do not loose in expressive power. Two case stud- ies are presented where the mobile ambients and DCCS, the distributed CCS of [7], are encoded in the proposed version of SHR. In particular, both models adopt a common recursive graph architecture whose components we call am- bient graphs. Interpretation maps DCCS terms to flat ambient graphs, while mobile ambients are trees. Both encodings are proven to be bisimulations (thus improving the result obtained for ambients in [5]).
SHR is adopted as the intermediate language of the Synchronised Hyper- graph Environment (She), a tool for system design and software development supporting concurrent and distributed programming. The system, which is currently being developed by the authors, integrates the techniques of model checking (which is more ofted used for verifying fully developed systems) within the framework of (distributed) program development. In particular, She uses Murphi [3] to compute all possible state transitions of the user’s pro- gram, and checks that user specified invariants hold at all reachable states. Specific traces can be selected and the corresponding sequence of graph rewrit- ing can be visualised as an animation. The system provides counterexamples if states violating the invariants are reachable.

Synopsis.
In section 2 we describe our proposed version of SHR. The two case studies are developed in section 3 (DCCS) and section 4 (ambient). She is described in section 5.

Notation.
We write x for a finite sequence x1, x2,... xn. If f : A × B is a relation and a ∈ A, we write f (a) the set {b ∈ B | (a, b) ∈ f }. The domain of f is dom (f )= {x ∈ A | ∃ b ∈ B. (a, b) ∈ f }.

Synchronized Hyperedge Replacement
Let N and L be sets (which we consider fixed throughout) respectively of nodes and labels. A graph G = (E, λ, G) consists of a set E of hyperedges (or just edges), a labelling function λ : E → L and an attachment function

G : E → N ∗. When G(e) = x x ... x
we call n the arity of e and say that

1 2	n



.	
. y

Table 1
L(x, y, z) | M (z, z)

the i-th tentacle of e is attached to xi. The collection of nodes of a graph G
is written:
|G| = {x ∈N | ∃ e. G(e)= x1 ... xn and x = xi}.

When no confusion arises, we let L(x) denote an edge e of a graph G with label L ∈ L and such that G(e) = x. If G and H are graphs, we write G|H the graph whose set of edges is the disjoint union of the edges of G and H, and whose labelling and attachment functions are the obvious ones. We picture graphs by drawing labelled boxes for edges and bullets for nodes; tentacles are represented by lines connecting the former to the latter. Table 1 shows a graph of the form L(x, y, z) | M (z, z).
Let Act = {a, b,... }∪ {a, b,... } be a set of actions and co-actions (over- lined), and let a denote a. We write Act+ the set Act × N ∗. Given (a, x) in Act+, we call the components of x arguments of a. A pre-transition of a graph G to a graph H, written:
G −Λ→ H,
is a relation Λ ⊆ N × Act + such that dom (Λ) ⊆ |G|. We write (x, a, y) for an element (x, (a, y)) of Λ, and (x, a) when y is the empty sequence. Intuitively, (a, y) ∈ Λ(x) expresses the occurrence of action a at node x. In SHR the occurence of both (a, y) and (a, z) at x triggers a synchronisation between two agents (edges) of the graph, what is traditionally represented by a silent action τ . When such is the case the synchronising agents may exchange information. This is implemented in SHR by unifying the lists y and z of parameters, which are required to be of the same length. Only two agents at a time may synchronise at one node. Formally, let Λ ⊆N ×Act + be a relation, and let the expression υ(Λ) be either undefined or denote a node substitution, that is a partial function N ~ N . In particular, let υ(Λ) be defined if and only if, for all x ∈ N , the set Λ(x) has at most two elements and, when so, it is {(a, y), (a, z)}, where the lengths of vectors y and z coincide. When υ(Λ) is defined, the substitution it denotes is the most general unifier of the arguments of all synchronised actions in Λ:
υ(Λ) = mgu {y = z | ∃ x. Λ(x)= {(a, y), (a, z)}}.



A transition is a pre-transition G
−Λ→ H such that H = ρ(H), where

ρ = υ(Λ). We say that an action a is observed at node x during a transition Λ if Λ(x)= {(a, y)}.
The rule [sync] below inplements synchronisation in SHR. It is subject to

a non-interference condition: two transitions G
−Λ→ H and F
−Θ→ K can

be synchronised provided the nodes in Λ (the parameters) and in H which are new (do not appear) in G are also new in F , Θ and K; and vice-versa. Formally, let |Λ| be the set {y ∈ N | ∃ x. (a, y1 ... yn) ∈ Λ(x) and y = yi};

two transitions G −Λ→ H and F
only if:
−Θ→ K are said to be non-interfering if and

x ∈ |K|∪ |Θ| implies x ∈ |F | or x /∈ |G|∪ |Λ|∪ |H|, and
y ∈ |H|∪ |Λ| implies y ∈ |G| or y /∈ |F |∪ |Θ|∪ |K|. The rule for synchronisation is as follows:
G −Λ→ H	F −Θ→ K

[ sync] 
Λ∪Θ
G | F −−→ ρ(H|K)
(*)

(*) if ρ = υ(Λ ∪ Θ) and the premises do not interfere.
Given a set T of transitions, called axioms,a T -computation, or just com-

putation for short, is a sequence of transitions G0
−Λ→1
G  −Λ→2
... each of

which is derived from the axioms in T by zero or more applications of the rule [sync].



Example.
Non-interference ensures that no “accidental” attachment of hyperedges ever occurs as a result of applying [sync]. Intuitively, the condition forbids the new nodes appearing to the right hand side of a transition, but not to the left, to be used as links for connecting subgraphs, except if by explicit synchronisation. Violating non-interference, for example, we could put two
∅	∅
transitions P (x) −→ R(x, z) and Q(x) −→ S(x, z) in parallel and deduce the
∅
rewrite P (x)|Q(x) −→ R(x, z)|S(x, z), where S and T are attached by z with
no synchronisation occurring. If such a rewrite was meant, it could be ob-
(x,a,z)
tained by synchronising the non interfering transitions P (x) −−−→ R(x, z)

(x,a,y)
and Q(x) −−−→
S(x, y), which yields a rewrite P (x)|Q(x) −→Λ
R(x, z)|S(x, z),

where Λ = {(x, a, z), (x, a, y)}.


Productions.
It is often convenient to define the set T of SHR axioms of a specific compu- tational theory by means of a set of axiom schemes called productions. More precisely, a production is a pre-transition with metavariables, place holders ranging over N , in the place of nodes. In accordance with [5], we require that the left hand side of a production consist of a single edge. We use the same symbols x, y, z... for nodes and for their place holders: the context will clarify what is meant.
A faithful instance of a production is a pre-transition obtained by instanci- ating all metavariables with specific nodes in N , and such that, if two distinct metavariables are instanciated with the same node, then they must both ap- pear in the left side of the production. The axioms generated by a set P of
productions are all transitions L(x) −Λ→ H such that L(x) −Λ→ G is a faithful instance of a production in P and H = ρ(G), where ρ = υ(Λ). Thus shall we specify the axioms of the SHR theory of DCCS and Mobile Ambients.




Ambient Graphs.
In section 3 and section 4 we develop two case studies where SHR, in the version proposed above, is used to model DCCS, the distributed CCS of [7], and the calculus of Mobile Ambients. Both models adopt a common recursive graph architecture whose components we call ambient graphs. Interpretation maps DCCS terms to flat ambient graphs, while mobile ambients are trees.
Ambient graphs feature two kinds of edges: L(u, v, w, z), called location managers, and P (v, w) representing processes running at specific locations. We use the metavariables u, v, w and z = z1 ... zn consistently to denote nodes attached to specific hyperedge tentacles. Hence, u always denotes a node where the first tentacle of a location manager is attached, and so forth. Local processes and location managers are represented graphically by the following
icons.
. u
.	.

  . w
w .  /	\

z1 /	\.zn
An ambient graph A is composed of a location manager L, a subgraph P of local processes, and a subgraph S of subambients. This is expressed formally by the following grammar:


. u1
v1
, ,,z.z  L1
w1 /	\

//	/
u2 = z11 ./ v2
\
\ . u3 = z12
v3

		L2 w2
z .z 
w3
v4

. u4 = z31

, , ,..zz  L4
// w4

Table 2
A tree-like ambient graph


A(u) ::= L(u, v, w, z) | P(v, w) | S(z)
S(z) ::= A1(z1) | ... | An(zn)
P(v, w) ::= P1(v, w) | ... | Pm(v, w).

It is assumed that no distinct tentacles of a single edge are ever attached to the same node. A tree-like ambient graph is one in which, when two distinct location managers L(u, v, w, z) and L'(u', v', w', z') share nodes, it is either by
an equation u = z' or else by an equation u' = zj. An example of such a
structure is given in table 2. More general topologies, which we shall not in-
vestigate in the present paper, are obtained by allowing A(u) to share its node u with more than one location manager. In the language of mobile ambients this would correspond to different ambients sharing common subambients.
An ambient graph A(u) synchronises with its environment using the node u and with its subambients using the zi. The nodes v and w connect local processes to the location manager. This allows the latter to act not only as a router for net synchronisation, but also as a go-between in local communic- ation. We found this approach less expensive (in terms of graph complexity) than allowing direct communication of local processes. For example, in the calculus of mobile ambients (see section 4), local communication may un- leash new ambients, and this is bound to require the intervention of an agent (viz. the location manager) to “update” the net. Of course, attaching all local processes of an ambient to the same two nodes reduces local parallelism to



(Act)
l ∈ L


Ld l[α.p] −→α Ld l[p]



(Kill)
l ∈ L


Ld l[kill m.p] −→τ  L − {m} d l[p]


(Live)
l ∈ L	m ∈ L


Ld l[if (m, p, q)] −→τ  Ld l[p]



(Dead)
l ∈ L	m ∈/ L


Ld l[if (m, p, q)] −→τ  Ld l[q]



(Spawn)
l ∈ L


τ

Ld l[move k.p] −→ Ld k[p]


(Str)
P ≡ P '	Ld P −→α
LdP ' −→α
L' dQ	Q ≡ Q' L' d Q'

Ld P −→a  L' dP '	LdQ −→a
L' d Q'

(Comm)
Ld P |Q −→τ
LdP −→α
(Par)	α
Ld P |Q −→
Ld P '|Q'
L' dP '
L' dP '|Q

Table 3
The semantics of DCCS

interleaving, while different locations may perform independent actions in a single computational step.

A Model of Distributed CCS
In the above presentation of hyperedge replacement we got rid of much of the mathematical structure involved in [5], where SHR was proposed as a foundational framework for modelling global computing. Next we provide evidence that the slender SHR we propose still retains the expressive power of the original system: in the present section we present an encoding of the distributed CCS (DCCS) of [7] in SHR and prove it to be a bisimulation up to structural equivalence (theorem 1). The same is done for the calculus of Mobile Ambients in the next section.


The semantics of DCCS is given in table 3. DCCS processes run at specific locations, the set of which we denote by Loc. For example,
l [a.p|kill k.q] | k [a.r]	(1)
is a located process featuring two locations: l and k. Two basic processes,
a.p and kill k.q, run in parallel at location l, and one, a.r, at k. There is no nesting of locations (that is, a basic process cannot have a located process as subterm). Communication is binary as in CCS and basic processes located at different sites can synchronise just as when residing at the same location. The term (1), for example, can perform a τ transition to l [p|kill k.q] | k [r]. Processes may kill locations. If a process performs a kill k action, then k is immediately removed from the set of the locations that are currently alive (livesets). The semantics of DCCS is therefore a labelled transition system on conﬁgurations L D P , where L is a liveset and P a located process. For example, in the liveset {l, k} the term (1) has a transition


{l, k} D l [a.p|kill k.q] | k [a.r] →τ
{l} D l [a.p|q] | k [a.r]



Since the rule for prefixed processes allows L D k [a.p] →a
L D k [p] only if

k ∈ L, a process on a killed location can no longer move. Note that the action of killing is represented by a τ action. Basic processes can also move to different locations (move k.p) and check the liveset (if (k, p, q) reduces to p if k ∈ L, or otherwise to q). A basic process is called thread if it is not of the form p|q. When writing a basic process as p1 | ... | pn we implicitly assume that all pi are threads. For simplicity we do not consider summation, restriction and renaming (see [7] for further detail). Hence, a located process is always of the form

P = l1 [ p11 | ... | p1n1 ] | ... | lm[ pm1 | ... | pmnm ].

For simplicity we dismiss terms of the form l[ p] | l[q], which in DCCS is struc- turally equivalent to l[ p | q]. Without this restriction theorem 1 would still hold up to structural equivalence.
Let the location sort σ(P ) of a located process P be the set of locations which appear in it. For example, the sort of l [move k . ∅] is {l, k}. Let P be a process l1 [p1] | ... | ln[pn], let L D P be a configuration and let L ∪ σ(P ) be the set {l1,... ln, ln+1,... lm}. When i > n we call li implicit in L D P . We call dead a location in σ(P ) − L. The interpretation of the configuration L D P is

an ambient graph ALQP defined as follows:
ALQP (u) = LT(u, v, w, z) | S(z)
S(z) = A l1 [p1](z1) | ... | A ln[pn](zn) | A ln+1[](zn+1) | ... | A lm[](zm)
A l[pi](u) = Lli (u, v, w) | Ppi (v, w)	(if l is alive)
A l[pi](u) = Dli (u, v, w) | Ppi (v, w)	(if l is dead)
Ppi (v, w) = Ppi1 (v, w) | ... | Ppin (v, w).

The root of ALQP is an edge LT which manages net synchronisation. Since in DCCS all basic processes reside at some location, the v and w tentacles of LT are dangling. A hyperedge representing a thread p is labelled by Pp. The information on which location is dead and which is alive is encoded in the labels: the manager of a location l is labelled by Ll if l ∈ L and by Dl otherwise. The dead and the implicit locations of L D P are represented in
ALQP . This is because in DCCS processes can move to such locations. Hence, the graph S(z) includes as many ambient graphs as there are locations in L ∪ σ(P ). Note that implicit locations do not host processes. Indeed, by the above clauses, A l[](u) is a graph including a location manager with no local processes attached.
Table 4 shows the productions for modelling DCCS. We implicitly assume
$
that all transitions generated by identity productions L(x) −→ L(x) are im-
plicitly available. As usual we let α range over the set A = {τ, a, b... a, b ... } of CCS actions. An edge representing a process p = α.q synchronises with its location manager by issuing an action sα on the node v (or on w, see rule 3). The manager responds with an sα. Moreover, within the same transition, the
manager can either try to make p communicate locally by issuing an sα¯ on
w (or respectively on v, rule 15), or it can require the intervention of the net manager LT by issuing sα on its u node (rule 8). While synchronising with the location manager (by issuing an sα on the corresponding tentacle zi), LT may either echo α on its u node (rule 1), or it can broadcast sα through the net for remote communication (rule 2). Note that, be it local or global, successful communication always involves a τ action on the u node of LT.
Besides the actions for communication we use a set S of synchronisation
actions for spawning processes, killing locations and checking the liveset:
S =   {mv l, kill l, then l, else l}.
l∈Loc
As an example we show how processes move across locations. Note that



Table 4 Productions for DCCS


in DCCS it is possible to move to a dead location, or to kill one. Hence we must allow the edges representing such locations to respond to move and kill messages. Besides that, they must answer the question whether they are alive (the else action of rule 17). Note that a process is allowed to move to, as well as to kill, the same location where it resides (rules 13 and 9 respectively).

Example.
We derive the SHR transition simulating the following DCCS transition:
{l, k} d k[]|l[move k.a] −→τ  {l, k} d k[a]|l[], showing how basic processes move
across locations. Left and right hand side of the DCCS transition are inter- preted respectively as:
A1 = LT(u, v, w, z1, z2)|Lk(z1, v1, w1)|Ll(z2, v2, w2)|Pmove k.a(v2, w2) and
A2 = LT(u, v, w, z1, z2)|Lk(z1, v1, w1)|Ll(z2, v2, w2)|Pa(v1, w1).
To rewrite the former to the latter we first synchronise the root and the location manager of k:


LT(u, v, w, z ,z ) −→Λ LT(u, v, w, z ,z )	L (z ,v ,w ) −→Θ
L (z ,v ,w )

1	2	1	2
k  1	1	1
k  1	1	1

L (u, v, w, z ,z )|L (z ,v ,w ) Λ∪Θ
L (u, v, w, z ,z )|L (z ,v ,w )

T	1 2
k  1	1
−−→	T
1	2	k  1	1	1

where Λ = {(z1, mv k, x y), (z2, mv k, x y), (u, τ )} and Θ = {(z1, mv k, v1 w1)}. The two vectors xy and v1w1 are unified because two complementary actions are issued on z1. So: x '→ v1 and y '→ w1. Next we synchronise the manager of l and the migrating process:


L (z ,v ,w ) Λ'
L (z ,v ,w )	P
(v ,w ) Θ'
P (v', w' )

l  2	2
−→	l  2	2	2
move k.a  2
2 −→ a

L (z ,v ,w )|P
(v ,w ) Λ'∪Θ' L (z ,v ,w )|P (v', w' )

l  2	2	2
move k.a  2	2 −−−→	l  2	2	2	a



where Λ' = {(z2, mv k, x' y' ), (v2, mv k, x' y' )} and Θ' = {(v2, mv k, v' w')} and x' '→ v' and y' '→ w'. The non interference conditions assures that v' and w' are new nodes. A last application of rule [sync] to the two transitions just deduced gives us the transition:
Λ∪Θ∪Λ'∪Θ'
A1 −−−−−−−→ A2
In the last inference we chose a unifier mapping v' '→ v1 and w' '→ w1. The only effect of making a different choice would be to produce a graph identical


to A2 up to a renaming of nodes. The only observable action (see section 2) in the above transition is a τ action at u node of the root.	 
We write A1 ≡ A2 if A1 and A2 are identical up to a renaming of nodes. We write P ≡ Q if P and Q are structurally equivalent DCCS processes. Let A(u) be an ambient graph; we write A(u) −α→ A' if A(u) −Λ→ A' and the only
action observable in Λ is α on u. The following theorem is proven in [8].
α	α	'	'

Theorem 1 If L D P
−→ M D Q then ALQP −→ A , where A
≡ AMQQ' and

'	α	'	α	'	'
Q ≡ Q . If ALQP −→A then L D P −→ M D Q where A ≡ AMQQ' and Q ≡ Q .

A Model of Mobile Ambients
In this section we use ambient graphs to represent terms of the calculus of Mobile Ambients [1]. For simplicity we use a version of this calculus without name restriction. By convention we write Pγ for a term Pγ ≡ P1|··· Pn with Pi of the form M.Q or !Q. By Pα we denote a term of the form n[P1]|··· m[Pk]. We can use structural equivalence to write any term P as Pγ|Qα. A process n[Pγ|Qα] is represented by an ambient graph that has a location manager, a subgraph P that is the representation of Pγ and a subgraph S of subambients that is the representation of Qα. We define a function [|· |], mapping terms to ambient graphs, by means of three auxiliary functions [|· |]π, [|· |]α, and [|· |]γ.

[|Pγ |]γ = P(v, w)	[|Qα |]α = S(z)

[|P |Q
|]π = P(v, w)|S(z)	( with {v, w}∩ z = ∅)

[|P |]α = S1(x)	[|Q |]α = S2(y)
[|P |Q |]α = S (x)|S (y)	( with x ∩ y = ∅)
1	2
[|P |]π = P(v, w)|S(z)

[|n[P ] |]α = Ln
(with u fresh)
(u, v, w, z))|P(v, w)|S(z)

[|0 |]α = [|0 |]γ = nil
[|M.P |]γ = LM.P (v, w)
[|P |]γ = P1(v, w)	[|Q |]γ = P2(v, w)
[|P |Q |]γ = P1(v, w)|P2(v, w)
The ambient graph representing a process P ≡ Pγ|Qα is obtained by adding an artificial topmost ambient T. Hence: [|P |] = [|T[P ] |]α. We say that an
ambient graph G silently rewrites to G' (G −→τ  G ) if every node that is labelled
with an action a is also labelled with the corresponding coaction a except the


u-node of the root, uT, which must be labelled with τ . More formaly G —→τ G

if G
—→Λ
G with Λ(uT) = (τ, ⟨⟩) and, for all x /= uT, either Λ(x) = ∅ or

Λ(x)= {(a, y), (a, y)}.
The following productions implement rewritings triggered by capabilities. As with DCCS, we assume all identity productions. The metavariable M in the second scheme stands for any path (sequence of capabilities).

L	(v, w) ——(v—, —α,—z→) У(v, w)|£(z)	with α /= (x) and [|P |]π = У(v, w)|£(z)
L	(v, w) ——(w—, (—M—),—z→) У(v, w)|£(z)	with [|P [M/x] |]π = У(v, w)|£(z)
L (v, w) ——(v—, r—ep—,→z) L (v, w)|У(v, w)|£(z)	with [|P |]π = У(v, w)|£(z)
!P

We now give the productions for edges labelled with ambient names. These productions are grouped by the ambient calculus action they implement. In the following productions an ambient m issues an action called sinc to warn its father that something has happend inside m. This action is propagated until it reaches the root T. Since T can acknoweledge only one such action at a time we are sure that only one ambient action can be done during a transition. We give a full explanation of the production implementing in. The others are similar and are just listed in table 5. Consider the following transition:

m[in n.P |Q]|n[R] → n[m[P |Q]|R].

Our representation does not allow sibling ambients to communicate directly because they don’t share nodes. Their communication musts be mediated by their parent, so four edges are involved in this kind of action: an edge labelled with in n.P tells its parent ambient m to enter n; m says to its parent that it wishes to enter n and finally n tells his father that it allows m to enter.

(zj, n accept, y) (zi, enter n, y)
L(u, v, w, z) ——————————→ L(u, v, w, z1)	z1 = [z1,... , z1—1, z1+1,... , zk]
This transition is performed by the parent ambient. Node zi is shared with the entering ambient m , while node zj is the node shared with ambient n. Both nodes are labelled with the same fresh node y. When the actions on zi and zj are matched by their co-actions node y is unified with the nodes passed by m and n. Hence, these are unified as well. The node zi does not appear in z1, because m is no longer a child of this edge.




(v, in n, y)
(u, enter n, u)
Lm(u, v, w, z) ———————→ Lm(u, v, w, z, y)
A vector of new nodes y is created for the new ambients introduced by the reduction of in n.P . Node u is passed to m’s father so that it is unified with the new nodes created by n. It is by this unification that the edge moves to n.
Ln(u, v, w, z) ———————→ Ln(u, v, w, z, y)
This is the accepting ambient. A new node y is created and passed to n’s father so that it will be unified with the one passed by the entering ambient. Ambient n gains a tentacle attached to y becoming in this way m’s father.

Example.
We derive the SHR transition corresponding to the following reduction of Mobile Ambients: n[ ]|m[in n.o[ ]] → n[m[o[ ]]].
Let P = n[ ]|m[in n.o[ ]] and let Q = n[m[o[ ]]]. We derive a transition of the graph [|P |] = LT(u, v, w, z1, z2)|Ln(z2, v2, w2)|Lm(z1, v1, w1)|Lin n.o[](v1, w1)
to [|Q |] = LT(u, v, w, z2)|Ln(z2, v2, w2, z1)|Lm(z1, v1, w1, z3)|Lo(z3, v3, w3). We
first synchronise the root with the manager of n:


LT(u, v, w, z ,z ) —→Λ LT(u, v, w, z )	L
(z ,v ,w ) —→Θ
L (z ,v ,w , x)

1	2	1
n  2	2	2
n  2	2	2

L (u, v, w, z ,z )|L
(z ,v ,w ) Λ∪Θ
L (u, v, w, z )|L
(z ,v ,w , x)

T	1 2
n  2	2
2 ——→	T
2	n  2	2	2

where Λ =


(z2 , n accept, y) (z1 , enter n, y)
(u, τ, (⟩)
, Θ= 
(z2 , n accept, x) }.

Notice that nodes x and y must be unified because two actions are defined
on z2. Without loss of generality, we choose the unifier that maps y to x (see discussion in section 3). Now we apply [sync] to the entering ambient and to the process


'
L (z ,v ,w ) —Λ→ L
(z ,v ,w ,z )	L
'
(v ,w ) —Θ→ L (z, v ,w )

m  1	1	1
m  1	1
1	3
Λ' ∪Θ'
in n.o[]  1	1
o	3	3

Lm(z1, v1, w1|Lin n.o[](v1, w1) ———→ Lm(z1, v1, w1, z3)|Lo(z3, v3, w3)

'	 (v1 , in n, z3 )  }	'

 (v , in n,z) }

fied because of the actions defined on v1. We also underline that the non
interference conditions assures that v3, w3 are new nodes. Using the two trans- itions just derived as premises, a last application of [sync] yields the transition

[|P |]
Λ∪Θ∪Λ'∪Θ'
———————→
[|Q |]. Note that node x to the right has been replaced by z1.


Table 5
SHR Productions for Mobile Ambients
Table 5 shows the production for the open and out capabilities. Besides these there are productions for propagating a sinc action, for controlling com- munication between local processes and for letting a process replicate itself. The corresponding productions of the root location manager T are omitted because they are identical to the others except that its u node is labelled with τ rather than with sinc.
The following theorem is proven in [8].
Theorem 2 Let P be a process; if P → Q then [|P |] —τ→ [|Q' |] where Q ≡ Q'.
Let G = [|P |] be a graph; if G —→τ  G' then either G' = [|P ' |] and P ≡ P ' or
P → Q and G' = [|Q |] .
The Synchronised Hypergraph Environment
SHR is the intermediate language of the Synchronised Hypergraph Environ- ment (She), a tool for system design and software development supporting concurrent and distributed programming. The system, whose architecture is sketched in figure 1, is currently under development, but a prototype is avail- able at http://briantb.unixcab.org/she/. She is multilingual: the user can chose among different languages for which different editors are provided. Programs are translated into SHR specifications, that is hypergraphs and productions to be applied for rewriting graphs. Besides SHR itself, which the



Figure 1. She

user can choose for programming in a declarative style, the system currently supports DCCS and the calculus of Mobile Ambients, whose translations are described in sections 3 and 4. Note, however, that the system is open to the addition of new language modules.
Programs are compiled into the model checker Murphi [3]. Murphi is, in fact, both a state verifier and a language: The language is used to specify an initial state (viz. the representation of a hypergraph) and rules for state transition (representing the hypergraph rewritings). A set of conditions, called invariants may also be provided. The state verifier computes every possible transition and checks that all invariants hold at all reachable states. The State Generator module turns Murphi’s output into a graph representing the state space, which can then be explored by the Interactive Analytical System. Here the user is provided with visual tools. Specific execution traces can be selected and the hypergraphs representing each state can be visualised in an animation on the screen. It is also possible to animate the possible runs discovered by Murphi violating the invariants. The hypergraphs representing states gener-


ated by the system may be saved and manipulated by the Visual SHR Editor or, in some cases, translated back into the original calculus. Within the editor it is possible to write productions or design system architectures graphically. The visual editor feeds back to the Murphi rule generator thus closing the cycle from implementation to testing and back.
Other systems exist which support concurrent programming. Most not- ably, the Concurrency Workbench [2] performs analysis of Temporal CCS and provides a modal logic to check properties and verify observational equivalence on terms. Similarly, LTSA [6] verifies concurrent systems specified in process algebra notation. LTSA does not perform a complete state exploration but can perform an interactive simulation, both in textual and visual fascion. It can also check some simple predefined properties and, if a violation is found, it displays the shortest trace of moves. The novelty that She brings with re- spect to these and similar systems is its extendibility to different language frameworks, due to the simplicity and expressiveness of its intermediate lan- guage, SHR. The declarative nature of SHR allows an incremental approach to system design while graphical representation of computational states allows She to give visual account of complex network interaction occurring in global computing.

References
L. Cardelli and A.D. Gordon. Mobile Ambients. Theoretical Computer Science, 1(240):177– 213, 2000.
R. Cleaveland, J. Parrow, and B. Steffen. The Concurrency Workbench. Springer LNCS, 407:24–37, 1989.
Alan J. Hu David L. Dill, Andreas J. Drexler and C. Han Yang. Protocol verification as a hardware design aid. In IEEE Int.Conf. on Computer Design: VLSI in Computers and Processors, pages 522–525, 1992.
P. Degano and U. Montanari. A model of distributrd systems based on graph rewriting.
Journal of the ACM, 34:411–449, 1987.
G. Ferrari, U. Montanari, and E. Tuosto. A LTS semantics of ambients via graph synchronization with mobility. ITCS, 2001.
Labelled Transition System Analysis. http://www-dse.doc.ic.ac.uk/ concurrency/ ltsa/ LTSA.html.
J. Riely and M. Hennessy. Distributed Processes and Location Failures. Theoretical Computer Science, 266:693–735, 2001.
A. Tiberi. Distributed computation as hypergraph rewriting. Masters thesis - forthcoming, 2004.
