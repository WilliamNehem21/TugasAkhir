

Electronic Notes in Theoretical Computer Science 256 (2009) 19–31
www.elsevier.com/locate/entcs

How to Produce Information About a Given Entity Using Automated Deduction Methods

Robert Demolombe1	Luis Fariñas del Cerro2
Institut de Recherche en Informatique de Toulouse France

Abstract
The standard method to retrieve information can be formally defined as follows. To ask a query, one gives the properties of the entities to be retrieved, and the answer is the set of all the entities that satisfy the query. Another method, is to ask the overall information about a given entity, and the answer is the corresponding information. An example of the first kind of query is: "what are the drugs that contain a given molecule?", an example of the second kind is: "what are the properties of a given drug?".
This latter method has deserved very few researches though it has great potential practical applications. However, it raises many non trivial issues. The first one is to find a precise definition of the fact that a piece of information "is about" a given entity. We recall the formal definition that have been proposed in formal classical logic, and the main properties that follow from this definition. The second one is to adapt existing automated deduction methods to compute this new kind of answer, using either deduction or abduction techniques.
Finally, we present potential extensions to our definition and guidelines for automated deduction strategies.
Keywords: Resolution, Abduction, Information Retrieval.


Introduction
Since the beginning of the seventies many research works have been devoted to define theoretical foundations and to develop tools to retrieve data in the form of so called Relational Databases. In these databases the information is formally organized with a rather limited number of predicates whose extensions may be very large. This approach requires to define a priori the predicates and to store the information in this predefined form. This is not a constraint for applications in the field of management because the predicates are rarely changed. These predicates are known by users and they are used to express queries in formal languages like SQL. The retrieved information must satisfy exactly these formulas.

1 Email: robert.demolombe@orange.fr
2 Email: luis.farinas@irit.fr

1571-0661© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.11.003

Now, the information which can be accessed via Internet is not formally struc- tured in that way. Rather, in most cases, it is represented in natural languages and queries are no more expressed in a formal language but by keywords. These key- words, from a logical point of view, may be constant symbols or predicate symbols. Then, it is important to extend automated deduction methods to retrieve the overall information about one or several given entities.
The work presented in this paper tries to propose theoretical foundations and practical methods to design tools that allow to retrieve the overall information about a given entity. It is based on previous works by philosophers and logicians [13,16,8,1,15], and also on works about automated deduction [18,2,14,12,10,11]. Our main objective in defining these practical methods was to define a bridge between the theoretical definitions of relevant information and an automated resolution strategy which is as efficient as linear resolution. We are perfectly aware that more efficient strategies could be designed.
In the following section 2 we have classified the different approaches to store and retrieve information using examples. In section 3 are presented the theoretical foundations that allow to characterize the information which is about a given entity. The next section is devoted to the presentation of automated deduction methods to retrieve this information. Finally, in the last section is presented a set of open questions that deserve further researches.
Selecting information about a given entity: a new per- spective for information retrieval
The standard approach to retrieve information from a knowledge base (KB) is to request all the entities that satisfy given properties. If this approach is formalized in classical logic, KB is represented by a set of formulas (many of them represent atomic facts), and the properties are represented by a formula of the form F (x) 3 . The answer obtained by deduction is the set of entities a defined by: { a :	▶
KB → F (a)}.
For instance, in a knowledge base about car accidents we may have the infor- mation that: if someone is driving and is drunk then he may have an accident, if someone is driving and the road is icy then he may have an accident, Smith and Dupont are driving, and Smith may have an accident. This information is formally represented by:
KB	=	{∀x(drunk(x) ∧ driving(x) → accident(x)), ∀x(icy ∧ driving(x) →
accident(x)), driving(Smith), driving(Dupont), accident(Smith)}
Then, the query is represented by: F (x)	= driving(x) ∧ accident(x), and the answer is: {Smith}.
If we want to know whether Dupont may have an accident the query is repre- sented by: F	= accident(Dupont),

3 In general the formula may have zero or several free variables.

and the answer is: unknown, because from KB we cannot infer that this fact is true, and we cannot infer that it is false.
Now, if we want to know in which circumstances Dupont may have an accident we have to ask another kind of query that gives in the answer these circumstances. In formal terms this answer is obtained reasoning by abduction, that is by looking for the minimal assumptions that must be added to KB to derive the fact that Dupont may have an accident.
The general formalization of these answers is defined as follows. The query is represented by a formula of the form: F , and the answer is the set of formulas H which is minimal, in some formal sense like subsumption, such that:
{ H  :  ▶ KB → (H → F )}.
For instance, for the query: F  =  accident(Dupont),
the answer is: {drunk(Dupont), icy}, because, if these assumptions are added to
KB it is possible to derive F .
A new approach to retrieve information is to focus on the entities rather than on their properties. That leads to give the priority to the notion of aboutness.
According to this approach, a query is defined by the entity c we are interested in, and the answer is defined by the set of formulas F that are about this entity c and that can be derived by deduction from KB. That is:
{ F  :  ▶ KB → F  and About(F, c)},
where About(F, c) means that the formula F is about the entity represented by the constant c.
For instance, if the query is to know everything about Dupont that can be inferred from KB, the answer is:
{drunk(Dupont) → accident(Dupont), icy → accident(Dupont), driving(Dupont)}.
In the case of answers defined by abduction, the answer is defined in a similar way as in the standard approach, except that we only want to get the assumptions that are about a given entity c.
Then, the answer is formally defined by:
{ H : ▶ KB → (H → F ) and About(H, c)}, where H is minimal in the same sense as above.
For instance, if the query is: F  =  accident(Dupont),
the answer about Dupont is: {drunk(Dupont)}, and the answer icy has been re- moved because this fact is not about Dupont.
In another context, if KB contains information about patients and diseases, if we want to know the assumptions that are possible explanations for the fact that Dupont has a given disease, it could be interesting to focus on the explanations that are about a given drug.
To sum up, in the new approach, information that can be retrieved either by deduction or by abduction is focused on information about a given entity. Then, we need a clear definition of the fact that a piece of information is about a given entity.

Formal characterization of sentences that inform about a given entity
In [6] sentences that are about a given entity in the semantics have been defined. A first order predicate calculus language Lc is defined, where c is some given constant symbol. Neither function symbols 4 nor the equality predicate are allowed in the language. Terms are either variable symbols or constant symbols.
Definition 3.1 Syntactical definition of language Lc.
Lc is defined by the following rules.
If p is an n-ary predicate and t is an n-tuple of terms, then p(t) ∈ Lc.
If F ∈ Lc and G ∈ Lc, then (чF ) ∈ Lc and (F V G) ∈ Lc.
if F ∈ Lc, then (ExF ) ∈ Lc and (Ex /= c F ) ∈ Lc 5 .
All the sentences in Lc are defined by rules 1, 2 and 3.

As usual we adopt the following notations: p Λ q	def
ч((чp) V (чq)), p →

q d=ef
(чp) V q, p — q d=ef
(p → q) Λ (q → p) and 6x /= c F  d=ef
ч(Ex /= c чF ).

Quantifiers of the form 6x /= c and Ex /= c are called “restricted quantifiers”.
Definition 3.2 Interpretation.
Let’s consider a language Lc as defined in Definition 3.1. An interpretation M
of Lc is a tuple M =< D, i > such that
D is a non empty set of individuals,
i is a function that assigns
to each predicate symbol of arity n a subset of Dn,
to each variable symbol an element of D,
to each constant symbol an element of D,
In the following D will be called the domain of the interpretation, and i will be called the interpretation function, or, for short, the interpretation.
Notation: the domain of M will be denoted by DM and the interpretation func- tion of M will be denoted by iM .
Definition 3.3 Satisfiability conditions.
Let M be an interpretation of the language Lc. The fact that a formula F of Lc
is true in M is denoted by M |= F , and is inductively defined as follows.
If F is an atomic sentence of the form p(t), where t is a tuple of constant symbols or variable symbols, we have M |= F iff iM (t) ∈ iM (p).

4 The absence of function symbols is not a strong limitation of the expressive power of the language. Indeed, if there are function symbols in a language we can define another language where function symbols are replaced by predicates, and formulas of the former language can be easily translated into latter one. For instance, the formula: driving(father(Smith)), which means that Smith’s father is driving, can be translated into: Ex(driving(x) Λ father(x, Smith)), where father(x, y) is the predicate associated to the function symbol father(x).
5 Here x /= c is used as a notation to denote restricted quantifiers, it is not taken as a sentence with an occurrence of equality predicate.

M |= чF and M |= F V G are defined from M |= F and M |= G as usual.
M |= ExF iff there exists an interpretation Mx/d that only differs from M by the interpretation of variable symbol x, such that iMx/d (x) is the element d of DMx/d and Mx/d |= F .
M |= Ex /= c F iff there exists an interpretation Mx/d that only differs from M by the interpretation of variable symbol x, such that iMx/d (x) is the element d of DMx/d and iMx/d (c) is not d and Mx/d |= F .
A formula F is a valid formula iff for every interpretation M we have M |= F . This is denoted by |= F .
Definition 3.4 Variants of an interpretation with regard to an entity.
Let Lc be a language as defined in Definition 3.1. We call variants of M with regard to c the set Mc of interpretations M ' defined from M in the following way.
DM' = DM
iM' = iM for every variable symbol and constant symbol,
iM' is defined from iM for each predicate symbol as follows: if p is a predicate symbol of arity n
if t is an n-tuple of terms of language Lc that contain no occurrence of the constant symbol c, then iM' (t) ∈ iM' (p) iff iM (t) ∈ iM (p),
if an element < d1,... , dn > of Dn is such that, for every j in [1,n], dj /= iM (c), then < d1,... , dn >∈ iM' (p) iff < d1,... , dn >∈ iM (p).
Intuitively, a variant of a given interpretation for a given constant symbol differs only by the truth assignment of atomic formulas where this constant appears as an argument of the atomic formula.
The set of variants M ' of the interpretation M with regard to an entity named with the constant symbol c is denoted by Mc. Notice that M belongs to Mc, and that, if M ' belongs to Mc, M belongs to M 'c too.
Definition 3.5 Sentences that are not about an entity.
Let F be a sentence of language Lc. We say that F is not about an entity named by the constant symbol c iff for every interpretation M , we have M |= F iff for every interpretation M ' in Mc we have M ' |= F .
The fact that F is not about entity c is denoted by N About(F, c). In short we have:
N About(F, c) holds iff 6M (M |= F iff 6M ' ∈ Mc M ' |= F )
We say that a formula F is about the entity c, if it is not the case that
N About(F, c). This fact is denoted by About(F, c). In short terms we have:
About(F, c) holds iff EM (EM ' ∈ Mc(M |= F and M ' |= F ))
It can be checked that, according to Definition 3.5, sentence p(a) is not about the entity c, and that sentences p(c) and 6xp(x) are about entity c.
The most important properties about the notion of aboutness that have been proved in [6] are listed below.

|= F — G ⇒ (N About(F, c) ⇔ N About(G, c))
N About(F, c) ⇔ N About(чF, c)
N About(F, c) and N About(G, c) ⇒ N About(F V G, c)
N About(F, c) and N About(G, c) ⇒ N About(F Λ G, c)
|= F — G ⇒ (About(F, c) ⇔ About(G, c))
About(F V G, c) ⇒ About(F, c) or About(G, c)
About(F Λ G, c) ⇒ About(F, c) or About(G, c)
|= F → G /⇒ (N About(F, c) ⇒ N About(G, c))
|= F → G /⇒ (N About(G, c) ⇒ N About(F, c))
|= F → G /⇒ (About(F, c) ⇒ About(G, c))
|= F → G /⇒ (About(G, c) ⇒ About(F, c))
In [6] a syntactical characterization of a large subset of formulas that are not about c has been proposed.
Automated deduction methods to retrieve information about a given entity
To consider automated deduction tools to retrieve information we define automated deduction methods based on Resolution [17]. These methods require to formally represent sentences in clausal form. Clausal form restrict slightly the expressive power of the language but for a large number of real applications this is not a practical limitation. Then, in the following it will be assumed that the overall information is represented in clausal form.
In the next subsections we present first a classical abduction method, second a deduction method to retrieve information about a given entity, and in the third subsection we extend the classical abduction method to retrieve information about a given entity.
Classical abduction
Definition 4.1 Clause.
A clause is a first order formula of the form: L1 V L2 V ... V Ln, where each Li
is a literal.
A literal is an atomic formula or the negation of an atomic formula.
The free variables of a clause are implicitly universally quantified.
Many strategies have been defined to compute answers in the standard approach when the answers are obtained by deduction.
When the answers are obtained by abduction the number of strategies is rather limited. There is, for instance, the SOL-resolution defined by Inoue in [9,10,11], and the l-inference defined by Demolombe and Fariñas del Cerro in [5].
We briefly resume below what is the l-inference.
Definition 4.2 l-Clause.

A clause C is an l-clause iff there is an atomic formula in C with l as predicate symbol.
Definition 4.3 l-Inference.
A resolvent C from C1 and C2 by Resolution Principle is obtained by an l- inference iff C is an l-clause.
Remark. If C is an l-clause one of the parent clauses C1 or C2 is an l-clause.
Definition 4.4 l-Deduction. Let S be a set of clauses. An l-deduction of Cn from S is a finite sequence C0 ... Cn of clauses such that : each Ci is either a clause in S or there are Ci1 and Ci2 in the l-deduction such that i1 < i, i2 < i and Ci is the l-resolvent of Ci1 and Ci2 .
Definition 4.5 R-Deduction. An R-deduction of Cn from S is a finite sequence C0 ... Cn of clauses such that : each Ci is either in S or there are Ci1 and Ci2 in the R-deduction such that i1 < i, i2 < i and Ci is the resolvent by Resolution Principle of Ci1 and Ci2 .
Theorem 4.6 Let S be a set of clauses, if C is a clause derivable from S, there is a clause C’, subsuming C, such that C’ is derivable from S by an R-deduction.
The Theorem 4.6 has been proved by Lee in [14].
Theorem 4.7 Let S be a set of clauses and l a given predicate. If there is an R-deduction of the l-clause C, then there is an l-deduction of C.
The proof of Theorem 4.7 can be found in [5]. 6
Deduction restricted to an entity
We present now an automated deduction method to derive answers which are about a given entity.
This method should have good performances because it derives only clauses which are about a given entity represented by the constant c, and they are obtained by linear deductions.
Definition 4.8 c-Clause.
A c-Clause is a clause such that there is a literal in the clause and a term in this literal which is either a free variable or the constant symbol c.
In the following it is assumed that clauses are not tautologies. It can be easily checked that c-clauses are formulas about c.
Definition 4.9 c-Inference. An inference of C from C1 and C2 by Resolution Principle is a c-inference iff C is a c-clause.

6 The Theorem given in [5] is more general in the sense that the l-inference is defined as an hyperesolution. That gives a deduction method which is more eﬃcient.

Definition 4.10 c-Deduction. A c-deduction of Cn from S is a finite sequence of clauses C0 ... Cn such that each Ci is either a clause in S or there are Ci1 and Ci2 in the c-deduction, with i1 < i and i2 < i, such that Ci is obtained by a c-inference from Ci1 and Ci2 .
C0 is called the top clause.
Theorem 4.11 If C is obtained by a c-inference from C1 and C2, and C2 is a c- clause, and C1 is the resolvent by Resolution Principle of the two clauses E1and E2, then there exists a c-inference of E2 and C2 whose resolvent is F, and there exists a c-inference of E1 and F whose resolvent is C.
Proof schema. Let L2 be the literal in C2 which is resolved with a literal in C1. Without loss of generality we can assume that this literal in C1 is an instance of a literal in E2 which is called L' .
Let M2 be the literal in E2 which is resolved with some literal M1 in E1. Then,
E1 and E2 have the following form:
E1 = M1 V e1
E2 = M2 V L' V e2
Let σ1 be the mgu of M1 and M2, and σ2 be the mgu of L' σ1 and L2. then the

clauses C1, C2 and C have the form:
C1 = L' σ1 V e1σ1 V e2σ1
C2 = L2 V c2
C = e1σ1σ2 V e2σ1σ2 V c2σ2
Since L' σ1 and L2 can be unified there exists a mgu σ'




of L'




and L2. Let F be

1	1	1
the resolvent by Resolution Principle of E2 and C2. F has the form:
F = M2σ' V e2σ' V c2σ'
1	1	1
The literals M1 and M2σ' can be unified by the mgu σ' . Let C' be the resolvent
by Resolution Principle of E1 and F . Then, C' has the form:
C' = e1σ' V e2σ' σ' V c2σ' σ'
2	1 2	1 2
It can be proved that F and C' are c-clauses. Then, they are obtained by a c-inference.
It can also be proved that the clause C' is the same clause as C.	 
Theorem 4.12 If there is an R-deduction of C from S and the clause C2 such that C is a c-clause and C is the c-resolvent of the clauses C1 and C2, then there exists a c-deduction of C from S and C2, such that C2 is the top clause.
Proof. The proof is by induction on the length n of the R-deduction of C1.
Induction hypothesis. If there is an R-deduction of C from S and the clause C2 such that: C is a c-clause, C is the c-resolvent of the clauses C1 and C2 and the length of the R-deduction of C1 is ≤ n, then there exists a c-deduction of C from S and C2 such that C2 is the top clause.
For n =0 the induction hypothesis is true (trivial).
Assumption: there is an R-deduction of C from S and the clause C2 such that:
C is a c-clause, C is the c-resolvent of the clauses C1 and C2 and the length of the

R-deduction of C1 is n + 1.
Let E1 and E2 be the two clauses whose inference by Resolution principle is C1.
The length of their R-deductions is ≤ n.
From Theorem 4.11 the deduction of C1 from E1 and E2, and of C from C2 can be transformed into a deduction of F from E2 and C2 and of C from E1 and F , where C and F are obtained by c-inference.
From the induction hypothesis, there exists a c-deduction δ1 of F from S and C2. From the induction hypothesis we can also infer that there exists a c-inference δ2 of C from S and F .
Therefore the sequence δ1δ2 is a c-deduction of C from S and C2.	 
Theorem 4.13 If there is an R-deduction of C from S such that C is a c-clause, then there exists a c-deduction of C from S.
Proof. The proof is by induction on the length n of the R-deduction of C.
Induction hypothesis. If there is an R-deduction of length ≤ n of C from S such that C is a c-clause, then there exists a c-deduction of C from S.
Assumption. There is an R-deduction of length n +1 of C from S such that C
is a c-clause.
Let C1 and C2 be the clauses whose inference by Resolution principle is C. Therefore either C1 or C2 is a c-clause. Let C2 be that c-clause. Since the length of the R-deduction of C2 is ≤ n, by induction hypothesis there exists a c-deduction δ1 of C2 from S.
From Theorem 4.12 there exists a c-deduction of C δ2 from S and C2. Therefore the sequence δ1δ2 is a c-deduction of C from S.	 

Abduction restricted to an entity
To only retrieve answers that are assumptions about an entity we have to design an abduction methods which is more specific than the SOL-deduction 7 or the L- deduction.
Definition 4.14 lc-Clause. A clause is an lc-clause iff it is both an l-clause and a c-clause.
Definition 4.15 lc-Inference. An lc-inference is an inference which is both an l-inference and a c-inference.
It is worth noting that there are lc-clauses that are R-deductibles from a given set of clauses S, such that it does not exist an R-deduction in which each resolvent is an lc-clause. Let’s consider, for instance, the set of clauses: S = {чq Vt, q Vl, чtVp(c)} and the lc-clause: l V p(c).
Definition 4.16 lc-Deduction. An lc-deduction of Cn from S is a finite sequence of clauses C0 ... Cn such that there exists i, 0 < i < n, such that the sequence

7 The SOL-deduction [9] cannot be directly applied because the property of being a c-clause does not define a stable production field.

C0 ... Ci is an l-deduction, and the sequence Ci+1 ... Cn is a c-deduction, and Cn is an lc-clause.
Theorem 4.17 If C is obtained by an lc-inference from C1 and C2, and C1 is a c-clause and C2 is an l-clause, and C1 is the resolvent by Resolution Principle of the two clauses E1and E2, then there exists an l-inference of E2 and C2 whose resolvent is F, and there exists a c-inference of E1 and F whose resolvent is C.
Proof schema. The proof is very close to the proof of Theorem 4.11.	 
Theorem 4.18 If there is an R-deduction of C from S such that C is the resolvent of C1 and C2, and:
C is an lc-clause, C1 is a c-clause and C2 is an l-clause,
there exists a c-deduction of C1 from S,
there exists an l-deduction of C2 from S, then there exists an lc-deduction of C from S.
Proof schema. The proof is by induction on the length of the c-deduction of C1.
Induction hypothesis. If there is an R-deduction of C from S such that C is the resolvent of C1 and C2, and:
C is an lc-clause, C1 is a c-clause and C2 is an l-clause,
C1 is obtained by a c-deduction from S whose length is ≤ n,
there exists an l-deduction of C2 from S
then there exists an lc-deduction of C from S.
Assumption. There is an R-deduction of C from S such that C is the resolvent of C1 and C2, and:
C is an lc-clause, C1 is a c-clause and C2 is an l-clause,
C1 is obtained by a c-deduction from S whose length is n + 1,
there exists an l-deduction of C2 from S
Let E1 and E2 be the two clauses such that C1 is their resolvent by c-inference. Either E1 or E2 can be resolved with the clause C2 (see the proof of Theorem 4.17). Without lost of generality it can be assumed that this clause is E2.
From Theorem 4.17 the R-deduction of C can be transformed as follows: an l-inference infers the clause F from E2 and C2, and a c-inference infers the clause C from E1 and F . In this transformation the l-deduction of C2 and the R-deductions of E1 and E2 remain unchanged.
Since F is an l-clause, from Theorem 4.7 there exists an l-deduction δ1 of F from
S.
Since C is a c-clause, either E1 or F is a c-clause.
Case 1. F is a c-clause. From Theorem 4.12 (replacing C1 by E1, and C2 by F ), there exists a c-deduction δ2 from S and F whose top clause is F . Therefore the sequence δ1δ2 is an lc-deduction of C from S.

Case 2. E1 is a c-clause. Since C1 is obtained by a c-deduction of length n + 1, the c-deduction of E1 is of length n. Then, by induction hypothesis, there exists an lc-deduction of C from S.	 
Theorem 4.19 If there is an R-deduction of C from S such that C is an lc-clause, then there exists an lc-deduction of C from S.
Proof. The proof is by induction on the length of the c-deduction of C.
Induction hypothesis. If there is an R-deduction of C from S of length ≤ n such that C is an lc-clause, then there exists an lc-deduction of C from S.
Assumption. There is an R-deduction of C from S of length n +1 such that C
is an lc-clause.
Case 1. Either C1 or C2 is an lc clause.
Let’s assume that C2 is an lc -clause. The length of the R-deduction of C2 is n. Then by induction hypothesis there is an lc-deduction of C2 from S. Since C and C2 are c-clauses, from Theorem 4.12 there is a c-deduction of C from S whose top clause is C2. Therefore the lc-deduction of C2 and this deduction make an lc-deduction of C.
Case 2. Neither C1 nor C2 is an lc-clause.
Therefore C1 is a c-clause and C2 is an l-clause (or vice versa). Then, from Theorem 4.11 there is an l-deduction of C2 from S and from Theorem 4.13 there is a c-deduction of C1 from S. Therefore, from Theorem 4.18 there is an lc-deduction of C from S.	 
For most of the applications, as mentioned in section 2, we have to generate the set of clauses (l-clauses, c-clauses or lc-clauses) which are in the answer. The previous theorems could be applied to generate this set. In addition this set should be minimal with respect to redundancy. The design of algorithms to implement these methods deserves further researches.
Further works and conclusion
The lc-deduction which has been presented combines the benefits of traditional Re- lational Database methods and Internet information retrieval methods to retrieve information, and it does not have their drawbacks. In the former methods the ex- pressive power is too much limited, while in the latter it is not enough specific. For example, to retrieve information about Dupont and about accidents, we may get answers of the kind: "Smith has an accident, or Dupont’s birthdate is July 18th 1975.
From a technical point view there are still many problems to be solved. Some of them are listed below.
Semantic selection of c-Clauses. According to Definition 4.8 any clause which contains a free variable is a c-Clause whatever is c. For example, the clausal form of the formula: 6x(drunk(x)Λdriving(x) → accident(x)) is a c-Clause because the universal quantifier can be instantiated by any constant c. For example, it is

a clause about Dupont and there is no doubt that its instance: drunk(Dupont) Λ driving(Dupont) → accident(Dupont) is about Dupont. However, if we assume that Pussy intuitively denotes a cat, it is quite odd to say that the instance: drunk(P ussy) Λ driving(P ussy) → accident(P ussy), and when we want derive information about Pussy it is desirable not to derive this kind of formula. A possi- ble research direction to reach that goal could be to define a specific treatment for literals in clauses that characterizes the types of the variables. For instance, if we have in the knowledge base a formula which expresses that drivers are human being and another one that expresses that cats are not human being, from the fact that Pussy is a cat we could infer that the general sentence about drink drivers is useless when we are interested in Pussy. From works about Domain Independent formulas
[3] we know that the domains of universally quantified formulas must be explicit,
else we get formulas which have no intuitive meaning. Then, the identification of literals in a clause that characterize the domain could be used for this semantic treatment.
Complete syntactical characterization. The decidability of the class of formulas that are about a given entity is an open problem. In the case of a positive answer to this problem it would be interesting to find a complete characterization of this class.
These problems should be refined to the case where aboutness is analyzed in the context of a given theory (see [6]). Indeed, a sentence may be or not about an entity depending on the fact that it is considered or not in the context of a theory. For instance, the formula: accident(Smith) V accident(Dupont) is about Dupont in the absence of context. However, in the context of a theory where we have: accident(Smith), the same formula is not about Dupont, because in this context accident(Smith) V accident(Dupont) is always true.
Language extension to function symbols. If we accept function symbols in the language we have to extend the Definition 3.4 to functions. A possible extension to be investigated is to have a very similar treatment of predicate symbols and function symbols in this definition, that is: the interpretation of function symbols should remain unchanged if the arguments of the function are different of c or if their interpretations are not the same as the interpretation of c.
Specific problems related to Skolem functions. Skolem functions are intro- duced only to apply automated deduction methods and require a specific analysis. The reason is that they have a meaning which is defined by the formulas that have been transformed by skolemisation. For instance, the formula: Ex(driving(x) Λ father(x, Smith)) leads to the clauses: driving(α) and father(α, Smith). Since the formula Ex(driving(x) Λ father(x, Smith)) is about Smith, the skolem constant α implicitly refers to Smith because it refers to an entity who is Smith’s father. From this simple example we can see that skolem constants, or skolem functions, cannot bee freely interpreted and require specific treatment in the definition of aboutness. Language extension to equality. There are many applications where the background theory contains information about equality and the definition of about- ness has to be revised if equality is added to the language. For instance, if in the

theory Smith’s father is Dupont, in formal terms: Dupont = father(Smith), the sentence accident(f ather(Smith)) is clearly about Dupont.
Equality also raises difficult problems in designing efficient automated deduction methods. Indeed, a brute force application of paramodulation rule leads to extremely expensive computations. It is possible to find heuristics to reduce the problem, but there are few works in this direction. 8
Sentences about a given topic. It may be that the information about a given an entity is too large to be efficiently exploited. For instance, if one asks the overall information about a given drug the answer may be extremely large. In that case it can be more convenient to select the information about that drug which is about a given topic, like, for instance, toxicity. In [4] a logic has been proposed for reasoning about sentences that are about a given topic. The combination of this logic with the definition of sentences that are about a given entity should deserve further researches.
References
R. Carnap. The logical syntax of language. 1937.
C.L. Chang and R.C.T. Lee. Symbolic Logic and Mechanical Theorem Proving. Academic Press, 1973.
R. Demolombe. Syntactical Characterization of a Subset of Domain Independent Formulas. Journal of ACM, 39(1), 1982.
R. Demolombe and A.J.I. Jones. On sentences of the kind “sentence “p” is about topic “t”: some steps toward a formal-logical analysis. In H-J. Ohlbach and U. Reyle, editor, Logic, Language and Reasoning. Essays in Honor of Dov Gabbay. Kluwer Academic Press, 1999.
R. Demolombe and L. Fariñas del Cerro. An Inference Rule for Hypothesis Generation. In Proc. of International Joint Conference on Artiﬁcial Intelligence, Sydney, 1991.
R. Demolombe and L. Fariñas del Cerro. Towards a logical characterisation of sentences of the kind “sentence p is about object c”. In S. Holldobler, editor, Intellectics and Computational Logic. Papers in Honor of Wolfang Bibel. Kluwer Academic Press, 2000.
R. Demolombe and M. P. Pozos Parra. An extension of sol-resolution to theories with equality. In
Proceedings of the International Joint Conference on Automated Reasoning, 2001.
N. Goodman. About. Mind, LXX(277), 1961.
K. Inoue. Consequence-Finding Based on Oredered Linear Resolution. In Proc. of International Joint Conference on Artiﬁcial Intelligence, Sydney, 1991.
K. Inoue. Linear Resolution for Consequence Finding. Artiﬁcial intelligence, an International Journal, 56, 1992.
K. Inoue. Studies on Abductive and Nonmonotonic Reasoning. PhD thesis, Kyoto University, 1992.
R. Kowalski and D. Kuhner. Linear resolution with selection function. Artiﬁcial Intelligence, 2:227–260, 1971.
L. Fariñas del Cerro and V. Lugardon. Sequents for dependence logic. Logique et Analyse, 133-134, 1994.
R.C.T. Lee. A completeness theorem and a computer program for ﬁnding theorems derivable from given axioms. PhD thesis, Univ. of California at Berkley, 1967.
D. K. Lewis. Relevant implication. Theoria, LIV(3), 1988.
H. Putnam. Formalization of the concept “About” . Philosophy of Science, XXV:125–130, 1958.
J. A. Robinson. A machine-oriented logic based on the resolution principle. JACM, 12:23–41, 1965.
J. A. Robinson and A. Voronkov, editors. Handbook of Automated Reasoning. MIT Press, 2001.

8 See, for instance, [7] where SOL deduction has been extended to equality.
