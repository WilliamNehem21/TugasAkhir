Electronic Notes in Theoretical Computer Science 123 (2005) 213–228 
www.elsevier.com/locate/entcs


Abstract Conditions for the Confluence of Explicit Substitution Calculi
Amelia Rˆa¸stei
ULTRA group, School of Mathematical and Computational Sc., Heriot-Watt University, Edinburgh, UK, email: amelia@macs.hw.ac.uk

Abstract
The aim of this paper is to give abstract properties of some calculi with explicit substitution which will be sufficient to prove their confluence. We define a property that we call “implementing a good notion of substitution.” We show that calculi with explicit substitution having this property are confluent and their substitution reductions are also confluent. We test our theory with the well-known calculi of explicit substitution λs, λυ and λse. The latter is λs with open terms.
The property of implementing a good substitution is natural and characterizes a large number of calculi. Two conditions of this property are usually checked as an initial step in the proof for confluence. The third condition is new and is the key for our proofs of confluence.
Keywords: Lambda calculi, explicit substitution, β-reduction, confluence, good substitution

The common ground of calculi of explicit substitu- tions
In the last ten-fifteen years many calculi of explicit substitution have been proposed. Calculi of explicit substitution are based on the λ-calculus and aim at controlling the process of substitution. In the calculi of explicit substitution, the operation of substitution is performed in a stepwise way via, what we call here, substitution reduction steps. A fundamental property of these calculi is confluence: confluence of the substitution reduction and confluence of the β-reduction, the latter implying the former. Confluence is equivalent to saying that the interconvertibility of two terms can be checked by converting them to a common form. Confluence can be an involved property to prove for some calculi (see, for example, the proof for the confluence of λse in [12]). This


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.05.016


paper provides a natural approach for proving confluence for calculi which can be shown to have the so-called implementing a good substitution property. To build our approach, we start from the common ground of calculi with explicit substitution: the λ-calculus. There are two main styles of building calculi of explicit substitution from the λ-calculus: λσ-style [1,14] and λs-style [12]. Some relations between the two styles are given in [13]. For a calculus in either styles, the set of rules consists of one rule that starts the simulation of the β-reduction in the λ-calculus, which we call simply β- reduction, and a
number of substitution reduction rules.
A standard method for showing confluence of explicit substitution calculi is the interpretation method, that ’maps’ the calculus of explicit substitution into an interpretation calculus that is known to be confluent. For calculi without open terms, the interpretation calculus is λ-calculus, see, for example, the proofs for confluence of λs [11] and λυ [2]. For calculi with open terms, the interpretation calculus is a middle-calculus of substitution normal forms, this is the case, for example, for λse [12] and λws [7]. The method we give in this paper, however, uses λ-calculus as an interpretation calculus for λse. We do not treat in this paper the calculi λws and λσ and hope that our results can be generalized in the future to these calculi too. When dealing with the calculi we consider, two main properties of the interpretation calculus are necessary: confluence of the β-reduction and preservation of β-reduction by the operation of substitution. When the interpretation calculus is the λ- calculus, these properties are obtained for free, provided that the operation of substitution in that calculus is “good” or correctly defined. We explain briefly what we mean by this.
In the λ-calculus, the definition of the β-reduction is based on the no- tion of substitution. The confluence of the β-reduction means that the final chain of substitutions does not depend on the order in which substitutions are performed. This means that confluence of β-reduction depends on some “good” properties of substitution. Substitution is not simple replacement. Careful attention is needed when defining substitution because of the binding structure of the λ-calculus, generated by the binding operator denoted by λ. The operator λ binds a variable inside a term, so variables can occur free or bound in a term. The definition of free and bound occurrences of variables is as usual. In order to be correctly defined, substitution must preserve the status of the free and bound variables. This informal requirement is often called “avoiding clashes of variables” or “avoiding captures of variables” or “avoiding confusion of bound variables” and intuitively is well understood by those working with λ-calculus based systems. Some examples of notions of substitution that satisfy this requirement are Curry and Feys substitution [4],


the simultaneous substitution of Stoughton [17], the substitution for the λ- calculus with de Bruijn indices [8] and its variants, e.g., the two substitutions used in this paper. All these notions of substitution have in common not only the property of “avoiding clashes of variables”, but also properties like the Substitution Lemma, preservation of β-reduction. Moreover, the β-reduction defined with such a notion of substitution is confluent. We will call such substitutions “good substitutions”. The property of a substitution of being “good” does not depend on the particular encoding that is used for the syntax of the λ-calculus. Some of the examples of good substitutions we gave above are based on an encoding with variable names, some on an encoding with indices. The length of this paper does not allow us to give a precise definition and to develop a theory of good substitutions in the sense described above. We do this in an unpublished report 1 . In this paper we work with the λ- calculus encoded with de Bruijn indices and with two notions of substitutions that are already known to be “good” and often used in the literature. Our results would hold if one considers any encoding of the λ-calculus and any good notion of substitution.
Yet another approach to defining good substitutions and, in the same time, control the evaluation by β-reduction steps, is the one of calculi of explicit substitution [1,2,3,10,11,14,6,15,16]. We exploit, in this paper, the abstract rules by which they have been built from λ-calculus. We show that a calculus that “implements a good notion of substitution” is confluent.
We summarize the results of this papers as follows.
We show that a calculus of explicit substitution that “implements a good notion of substitution”, is confluent.
We show that λs, λυ and λse are confluent using our method.
We compare the difficult part and easy parts of the original proof for λse
and our proof.
We discuss the feasibility of applying our method to other calculi.
The structure of the rest of the paper is as follows. In Section 2 introduces the λ-calculus with de Bruijn indices as used in the literature, proofs of the meta-properties are not included in the article, but are found in the literature (see, for example, [12]). In Section 3 we develop our theory for testing explicit substitution calculi. The remaining sections will apply our method to λs and λυ and finally, to λs with open terms. In the end of the paper we conclude with a discussion on what has been achieved, the relevance of this work and directions for future work.

1 “Good substitutions in the λ-calculus”, http://www.macs.hw.ac.uk/~amelia/


The λ-calculus with de Bruijn indices
Let (ΛDB, −→β(S), EqS ) be the rewriting system of the λ-calculus with de Bruijn indices. The set of terms, ΛDB, the β-rule, −→β(S), parametrized with a sub- stitution S and the equations EqS for defining the substitution S are given below. We often do not mention the set of equations for defining substitution, and write (ΛDB, −→β(S)) instead of (ΛDB, −→β(S), EqS ). The set of terms ΛDB is defined by the grammar:
ΛDB ::= N | (ΛDBΛDB) | λΛDB
Let M, N, P range over ΛDB and N = {1, 2, 3,.. .}. The notion of substitution with global updating together with the operations for updating the indices are given below. Let S be a good notion of substitution, then the β-reduction rule is defined as follows (S ∈ {Sb, St}):
(λM)N →β(S) S(N, 1,M).
Definition 2.1 The equations of EqSb for defining the substitution with global updating of the λ-calculus with de Bruijn indices are:
Sb(N, k, M1 M2 )= Sb(N, k, M1 )Sb(N, k, M2 )  Uk(M1M2 )= Uk(M1)Uk(M2)
i	i	i
Sb(N, k, λM )= λSb(N, k + 1,M )	Uk(λM)= λUk  (M )


Sb(N, k, m)= 
m − 1 if m > k Uk(N ) if m = k
>: m	if m < k 
i

Uk(m)= 
i+1
m + k − 1 if m > i m	if m ≤ i

Definition 2.2 The equations of EqSt for defining the substitution with local updating in the λ-calculus with de Bruijn indices are:
St(N, k, M1 M2)= St(N, k, M1 )St(N, k, M2)	ui(M1M2 )= ui(M1 )ui(M2)
St(N, k, λM )= λSt(u0(N ),k + 1,M )	ui(λM)= λui+1(M )


St(N, k, m)= 
m − 1 if m > k N	if m = k
>: m	if m < k 

ui(m)= 
m +1 if m > i m	if m ≤ i

By orienting the equations of EqS with S ∈ {Sb, St}, from left to right, they can be treated as a rewriting system. We denote this orientation with the symbol
> instead of “=”. We use the notation EqS,> for the rewriting rules thus obtained and =EqS for the reflexive, symmetric, transitive closure of >. The rewriting system thus obtained is terminating and confluent. One can easily show termination, using the recursive path ordering method of Derschowitz or/and the lexicographic path ordering method of Kamin and L´evy (methods described in [5]). Since > is terminating and normal forms are unique we conclude that > is confluent.
The notion of substitutions Sb, St are good, i.e., avoid clashes of variables. Two properties are of special importance for our results: Theorem 2.3 and Theorem 2.4.

Theorem 2.3 Let S ∈ {Sb, St}. Then, S preserves −→β(S).
By preserving β-reduction we mean the following: Let S be any good notion of substitution and M −→β(S) N. Then, for any term Q and variable k we

have S(Q, k, M) −→β(S) S(Q, k, N ) and S(M, k, Q) −→∗
β(S) S(N, k, Q).

Theorem 2.4 The λ-calculus (ΛDB, −→β(S)), where S ∈ {Sb, St} is confluent.
The properties of substitution Sb and updating are expressed by the following lemmas (cf. [12]). Similar properties can be established for St. For the λ- calculus with no meta-variables over terms, the equalities of the lemma given below can be obtained from the equations (or rules) defining Sb. One says that, in this case, the equations below are “admissible”.
Lemma 2.5 Let X, Y, Z be a meta-variables ranging over terms. Then, the following equalities hold.
For k < n < k + i we have: Sb(X, n, Ui (Y )) = Ui−1 (Y ).
k	k
For l ≤ k < l + j we have: Ui (Uj(X)) = Uj+i−1(X).
k  l	l
For k + i ≤ n we have: Sb(Y, n, Ui (X)) = Ui (Sb(Y, n − i + 1,X)).
k	k
For i ≤ n we have:
Sb(Z, n, Sb(Y, i, X)) = Sb(Sb(Z, n − i + 1,Y ), i, Sb(Z, n + 1,X)).

For l + j ≤ k +1 we have: Ui (Uj(X)) = Uj(Ui
(X)).

k  l	l	k+1−j

For n ≤ k +1 we have: Ui (Sb(Y, n, X)) = Sb(Ui	(Y ), n,U i
(X)).

k	k−n+1	k+1
In the case of λ-terms extended with meta-variables, the equations of Lemma
2.5 are not admissible anymore. Therefore, we extend EqSb,> such that > ori- ents the equations of Lemma 2.5 from left to right. The extended > is weakly terminating: one can define an innermost terminating strategy by postponing the use of rules corresponding to meta-properties of Sb after all the possi- ble rules in EqSb are applied. Moreover, > is confluent: the normal forms are unique and > is weakly terminating. Confluence can also be established noticing that the oriented equations from left ro right of Lemma 2.5 are left
linear and with no critical pairs. When considering explicit substitution cal- culi with open terms (i.e., terms containing meta-variables) that implements a good substitution S, we extended the set EqS,> with oriented equalities corresponding to the meta-properties of S.

Criteria: implementing a good notion of substitution
Let (ΛES, −→Beta, RedS) be a general calculus of explicit substitution. The set ΛES contains pure terms and those containing substitutions, −→Beta is the β- reduction generating a term containing a substitution and RedS is the set of reduction rules that propagate and eliminate substitutions. Such calculus is


obtained from (ΛDB, −→β(S), EqS,>) by making substitution an explicit opera- tor. The β-reduction rule for the λ-calculus is now split into two reductions:
−→Beta, and the reduction rules of RedS. The subcalculus (ΛES, RedS) is called the substitution subcalculus. We introduce now our criteria and then we jus- tify it.
Definition 3.1 Assume (ΛDB, −→β(S), EqS,>), where S is a good substitution and > is a confluent and weakly-terminating ordering of equations in EqS . We say that (ΛES, −→Beta, RedS) implements S iff there ∃T : ΛES → ΛDB such that:
(BET) M →β(S) N iff ∃N ' such that M →Beta N ' and T(N ') =Eq	N,
M, N ∈ ΛDB and N ' ∈ ΛES.
(GS1) If A → B, then ∃k ≥ 1 finite such that T(A) >k T(B).
(GS2) If T(A) > T(B), then ∃k ≥ 1 finite such that A −→k  B, A, B ∈ ΛES.
The function T is a total function and is usually called the “interpretation function”. It is common to define and use an interpretation function for showing the confluence of the substitution subcalculus and of the whole ex- plicit calculus. This is the case of several calculi: λs, λt [12], λυ [2], λζ [10]. The novelty in the definition above is the condition (GS2). It is this condition that will help us simplify the proof for confluence of the explicit substitution calculi.
Before we go further we should ask ourselves whether the three conditions are legitimate, in the sense that they are desirable and characterize as many calculi as possible. The first condition, (BET), illustrates the splitting of a
−→β(S) step into a step −→Beta followed by some other reductions that must simulates the operation of substitution generated by the −→β(S) step. Con- ditions (GS1) and (GS2) describe a harmonious correspondence between a
>-step and a substitution reduction step −→. A substitution reduction step is formed in agreement with a >-step. (GS1) states the fact that no “new”
−→ steps are formed in the explicit substitution calculus, but all must cor- respond to some >-steps in the λ-calculus. (GS2) states that no >-step is “annihilated” in the explicit substitution calculus, but corresponds to a finite number of substitution reduction steps. Under the hypothesis of our criteria, both (GS1) and (GS2) are necessary to prove confluence of the substitution reduction.
Lemma 3.2 A calculus of explicit substitution that implements a good sub- stitution is weakly terminating.
Proof. The function T describes a strategy: applying a finite number of >
steps to a term T(M),M ∈ ΛES one obtains a term in ΛDB.  Since > is


weakly terminating and (GS2) holds, the substitution reduction is also weakly terminating.	 
Theorem 3.3 The substitution subcalculus of a calculus of explicit substitu- tion that implements a good notion of substitution is confluent.

Proof. Let M
−→∗
N and M
−→∗
P be any two sequences of reductions in

RedS. From (GS1) we have T(M) >∗ T(N) and T(M) >∗ T(P ). Also, > is confluent. Using now (GS2) we obtain the conclusion.	 
From the conditions (GS1) and (GS2) we cannot conclude that the substitu- tion subcalculus is terminating, but merely weak-terminating. Also, the condi- tion (BET) does not require strong termination of the substitution reduction, but weakly termination is necessary and sufficient. Strong normalization is quite difficult to show in many cases and known to be undecidable. Calculi known to be strong confluent are, for example, λσ, λs, λt, λυ, λζ.

Confluence
Usually, the proof of the confluence of the explicit substitution calculi is based on the interpretation method [9], where the termination of the substitution subcalculus is a requirement. We use the generalized method, called short GIM, of [12] that is suitable for showing the confluence of explicit substitution calculi when strong normalization cannot be established.
Theorem 3.4 Let R = R1 ∪ R2, where R1, R2 are arbitrary reductions on a set A. Let B be a set of R1-normal forms and let T : A → B be a function such that T(M) is a R1-normal form of M. If there exists a reduction R' on the set of R1-normal forms satisfying
R' ⊆ R∗
∀M, N : M →R1 N =⇒ T(M) −→R' T(N).
∀M, N : M →R2 N =⇒ T(M) −→R' T(N).
then R' is confluent iff R is confluent.
Note that R∗ is the reflexive, transitive closure of a relation R. We show that if a calculus with explicit substitution implements a good substitution, then the conditions of GIM hold, so the calculus is confluent.
Theorem 3.5 A calculus with explicit substitution that implements a good notion of substitution is confluent.
Proof. In Theorem 3.4 we take R' to be the β-reduction in the λ-calculus with de Bruijn indices, R1 to be the substitution reduction and R2 to be the β-reduction in the calculus of explicit substitution. The condition 1. of Theorem 3.4 is satisfied because of the conditions (BET) and Theorem 3.3.

From (BET) we know that if M −→β(S) N then there exists N ' such that
M −→Beta N ' and T(N ') =Eq N. Using (GS2) we can easily notice that there

exists k such that N ' ←−→k
N. Using now Theorem 3.3, we know that the

substitution reduction is confluent, hence Church-Rosser. So there exists l

such that N ' −→l
N, since N is a normal form with respect to the substitution

reduction. The condition 2. is also satisfied (see condition GS1). To show that 3. holds, we use the property of a good substitution of preserving β- reduction steps (Theorem 2.3). The case when M ∈ ΛDB is straightforward from (BET). We take now the remaining case. Assume that a substitution term is denoted by Mσ, where σ is a substitution, i.e. a function with a finite domain from the set of variables to the set of terms. The domains of Sb and St, for example, contain only one element. The term Mσ is translated into a term σ'(T(M)) where ∀i. σ'(i)= T(σ(i)). We use the fact that a good substitution σ preserves β-reduction steps. If M −→Beta M1 and/or σ −→Beta σ1 (i.e.,
∃i. σ(i) −→Beta σ1(i) and ∀j /= i. σ(j)= σ1(j)), then by induction hypothesis
we have that σ'(T(M)) −→∗ β(σ) σ' (T(M1)), where ∀i. σ' (i)= T(σ1(i)).	 
1	1
In the next sections we apply our criteria for showing confluence to diverse explicit substitution calculi: λs and λυ, the latter being in the λσ-style. We apply our method for the explicit substitution calculus λs extended with open terms.

Calculi with explicit substitution in λs-style
The calculus λs is an explicit substitution calculus with de Bruijn indices. The set of terms and rules is given below. The rules of the λs calculus are such that all operations of lifting of indices are postponed after the propagation of substitution operations. This postponement is sometimes called “global updating”. A similar calculus with λs is λt which has “local updating” because it allows steps of propagating substitutions to be interleaved with operation of lifting. The calculus λt is based on the substitution St.
The set of terms Λs of λs is given as follows.
Λs ::= N | (ΛsΛs) | (λΛs) | (ΛsσiΛs) | (ϕkΛs) where i, k ≥ 1,j ≥ 0.
Let M, N, P,... range over Λs. Figure 1 gives the rules of λs. All the rules except σ-generation, propagate substitutions to the variable level where they are finally performed. In fact, λs was obtained from the λ-calculus with de Bruijn indices via two steps: (1) the substitution operation Sb together with the updating operator U become the explicit operators σ and ϕ respectively, and terms built via these operators are added to the set of terms; (2) all the equations defining the substitution operation Sb become oriented reduction




rules. The sub-calculus obtained from λs by removing the rule σ-generation is called the substitution subcalculus.
Lemma 4.1 λs implements the good notion of substitution Sb.
Proof. The proof is by constructing the function T as follows.
−T(MN)= T(M )T(N )	−T(λM)= λT(M )	−T(n)= n
−T(MσkN )= Sb(T(N ), k, T(M ))	−T(ϕkN )= Uk(T(N ))
i	i
The set of reduction rules of the substitution calculus RedS contains all the
rules above except rule σ-generation. Recall the orientation > from left to right of the equations in EqSb . We have that T(M) > T(N) iff M −→ N ∈ RedS. By simple calculations one can check that indeed T satisfies the conditions (BET), (GS1) and (GS2).	 

As consequence of the lemma above, Theorem 3.3 and Theorem 3.5 we obtain the following two results.

Corollary 4.2
The substitution subcalculus of λs is confluent.
The calculus λs is confluent.

In a similar way, we one can show that both λt and λυ implements the good notion of substitution St. We give only the proof for λυ.



λυ implements a good notion of substitution
The following definitions for the terms and rules of the λυ-calculus are taken from [14]. The terms of the λυ are given by the grammar:
Terms	M ::= V(n) | MN | λM | M[s] Substitutions s ::= M/ |⇑ (s) |↑
Naturals	n  ::= S(n) | 1
Note that V(n) represents the variable corresponding to the number n and
S(n) is the successor of n. Here is an example of a reduction sequence in λυ:
(λλ124)(12) → (λ124)[(12)/] → λ((124)[⇑ (12/)]) → λ1((1[12/][↑])(3[12/][↑])) →
λ1((12)[↑])(2[↑]) → 1(23)3
We denote by u(k)(N) the term u0(u0(... (N) .. .)) where u0 is applied k times.
Lemma 5.1 λυ implements the good notion of substitution St.
Proof. We build the interpretation function T as below. The ordering > of the set EqSt is the one given by Definition 2.2, where the equalities are oriented from left to right.
−T(n)= n	−T(M[⇑k (↑)]) = uk(T(M))
−T(MN)= T(M)T(N)  −T(M[⇑k (N/)]) = St(u(k)(T(N)),k + 1, T(M))
−T(λM)= λT(M)
The proof that (BET) holds is direct using the definition of T. (GS1) holds as well. We give only the proof for (GS2). We take only the equations that perform substitution and updating on terms being variables, the cases for


terms being abstractions and application are direct by the definition of the rules of λυ.
Let S (u(k−1)(T(N)), k, m) > m − 1 with m > k, m, k positive natu-
t	0
ral numbers.	Then, from the definition of the translation T, we have
S (u(k−1)(T(N)), k, m) = T(m[⇑k−1 (N/)]). We have the valid sequence
t	0
of substitution reductions

m[⇑k−1 (N/)] −−k−−→1
(m − k + 1)[N/][↑]k−1 → (m − k)[↑]k−1 −−k−−→1
m − 1.

We conclude knowing that T(m − 1) = m − 1.
Let S (u(k−1)(T(N)), k, m) > m with m < k, m, k positive natural numbers.
t	0
Then, S (u(k−1)(T(N)), k, m)= T(m[⇑k−1 (N/)]), T(m)= m and
t	0
m[⇑k−1 (N/)] −m−−−→1  1[⇑k−m (N/)][↑]m−1 → 1[↑]m−1 −m−−−→1  m.
Let S (u(k−1)(T(N)), k, k) > u(k−1)(T(N)). Then, S (u(k−1)(T(N)), k, k) = 
t	0	0	t	0
T(k[⇑k−1 (N/)]). Also, u(k−1)(T(N)) = T(N[↑]k−1) and k[⇑k−1 (N/)] −−k−−→1
1[N/][↑]k−1 → N[↑]k−1.
Let ui(m) > m +1 with m > i, m, i positive natural numbers.

We have ui(m)= T(m[⇑i (↑)]) and m[⇑i (↑)] −→i
(m − i)[↑]i+1 −i−+→1
m + 1.

Let ui(m) > m with m ≤ i, m, i positive natural numbers. We have ui(m)= 
T(m[⇑i (↑)]) and m[⇑i (↑)] −m−−−→1 1[⇑i−m+1 (↑)][↑]m−1 → 1[↑]m−1 −m−−−→1 m.

We can now state the following results about λυ.
Corollary 5.2
The substitution subcalculus of λυ is confluent.
The calculus λυ is confluent.

Applying our criteria for calculi of explicit substitu- tions with open terms
We show that indeed our method remains valid even for calculi extended with open terms. The property (GS2) indicates exactly what rules need to be added to the explicit substitution calculus such that confluence on open terms is ob- tained. We can use λ-calculus as the interpretation calculus since λ-calculus extended with constants is confluent. We will simplify, using our method, the proof for λse.
The calculus λse. We extend the set of terms of λs with open terms as follows:


Λsop  ::=  V | N | (ΛsopΛsop) | (λΛsop) | (ΛsopσiΛsop) | (ϕj Λsop)
where i, j ≥ 1,k ≥ 0 and V is a set of meta-variables, over which X, Y, Z,... range. We do not modify at all the rules of λs. We ask the question: Is the calculus with the set of terms Λsop and the rules being exactly those of λs implementing Sb? It is obvious that (BET) and (GS1) hold since the only change we made to the syntax of λs was the set of meta-variables. The condition (GS2) does not hold. Take the example:
((λX)Y )σ11 −→ (Xσ1Y )σ11 and ((λX)Y )σ11 −→ ((λX)σ11)(Y σ11)
but the terms (Xσ1Y )σ11 and ((λX)σ11)(Y σ11) have no common reduct in
λs. Indeed, ((λX)σ11)(Y σ11) −→ (λ(Xσ21))(Y σ11) −→ (Xσ21)σ1(Y σ11).
But T((Xσ1Y )σ11) > T((Xσ21)σ1(Y σ11)) because of the Substitution Lemma for Sb. What is happening with the introduction of meta-variables is the “freezing” of the operation of substitution until all the meta-variables are substituted with terms containing no meta-variables. This is remarked in [12] too: “the solution of the problem seems at hand if one has in mind the prop- erties of meta-substitutions and updating functions of the λ-calculus with de Bruijn notation.” A similar observation is made also in [10, p. 7]. This is what causes the failure of (GS2) for λs with open terms.
Lemma 6.1 The calculus λs with open terms does not implement Sb.
Proof. Property (GS2) fails as explained above.	 
Because of the presence of meta-variables, the set EqSb ,> is extended with oriented equations corresponding to meta-properties of Sb as explained at the end of Section 2. To restore (GS2) one must add to the set of rules of λse those corresponding to the oriented equations representing the meta-properties of
Sb. The new obtained calculus λse has now in addition to the rules of λs the rules from the table below. For our example above, one should add the rule (MσiN)σjQ → (Mσj+1Q)σj(Nσj−i+1Q), where i ≤ j. In the same way, all the other necessary rules are added. The interpretation function remains defined in the same way as for λs. It is easy to show that λse implements the good notion of substitution Sb.
Lemma 6.2 λse implements the good notion of substitution Sb.
Proof. The properties (BET) and (GS1) hold for λse as they hold for λs. The property (GS2) is restored by the addition of the new rules.	 
Corollary 6.3
The substitution subcalculus of λse is confluent.
The calculus λse is confluent.



Proof. Use Lemma 6.2, Theorem 3.3 and Theorem 3.5.	 
Similar ideas for restoring (GS2) is applied for other calculi as well, e.g., λσ to obtain λσ⇑. A different idea is used to obtain λζ from λυ, where the reduction of a β-redex is performed before the propagation of substitutions via two kinds of application operators that both correspond to the application operator in the λ-calculus.
Comparing the two methods for showing confluence of λse. We present first the method of [12]. The proof for confluence of the substitution subcalculus has two steps: weak normalization of the substitution subcalculus and a step similar to our property (GS1), see Theorem 10 and Proposition 1 of the same source. The proof of the confluence of λse is based as well on GIM. The steps of the proof are:
Characterize the subset, NF, of normal forms of Λsop (Theorem 8). Note that NF /= ΛDB.
Show that the substitution subcalculus is weakly normalizing: for each term
M ∈ Λsop, s∗(M) is a normal form of M (Theorem 10), where s∗ : Λsop −→ NF.
e	e
Prove a similar property to (GS1) but take T = s∗ (Proposition 1).
Use 2. and 3. to show confluence of the substitution subcalculus (Theorem 11).
Define the β-reduction , −→Beta' on terms in NF such that:
∀M, N ∈ NF.M −→Beta' N iff M −→Beta N ' such that s∗(N ')= N
where N ' ∈ Λsop. Remark the similarity of this condition with (BET) of our method.
Show that −→Beta' is confluent using the standard method of parallel reduc- tion.
Show confluence of λse using GIM, where R' is −→Beta' .


Our method simplifies the proofs for λse in the following ways:
The middle level defined in the previous proof is not necessary in our proof. So the Steps 5 and 6 from above are not required.
The conditions (BET) and (GS1) are checked in both methods. In the first method, where (GS1) is checked at the middle level, the proofs are more involved (see Steps 1,2,3). We check (GS1) for an interpretation function to the λ-calculus. Step 2 is easily proved from (GS2).
In order to apply GIM method and obtain confluence, we must check in addition to (BET) and (GS1), the condition (GS2). This checking is simpler and shorter than the Step 6 above.

Applying our method for calculi with composition of substitution
In the calculi of explicit substitution with composition, terms and substitu- tions belong to two distinct sorts. A first step is, therefore, to extend the function T from our criteria to translate substitutions (or functions or envi- ronments) to corresponding substitutions in λ-calculus. This is possible to do: T(σ) = σ' such that ∀i σ'(i) = T(σ(i)), where σ is a substitution. We also need a notion of simultaneous substitution in the sense of [17], where Stoughton gives a notion of simultaneous substitution for the λ-calculus. The author works with variable names, but one can easily take his approach to de Bruijn indices. We define the simultaneous substitution σ applied to a term M, notation Mσ, as follows:
- kσ = σ(k)	- (MN)σ = (Mσ)(Nσ)	- (λM)σ = λ(Mσ')
where σ' = 1 · (σ◦ ↑) and the lift substitution, denoted by ↑, is defined as:
∀k. ↑ (k)= k + 1, and the cons substitution is defined as: (M · σ)(1) = M and
∀k > 1. (M · σ)(k)= σ(k − 1). The composition of two substitution is defined as follows: (σ ◦ τ )(k) = σ(k)τ . We define β-reduction with simultaneous substitution as the compatible closure of
(λM)N −→β Mσ where σ = N · ι,
where ι is the identity substitution. β-reduction is extended to substitutions such that σ1 −→β σ2 iff ∃i such that σ1(i) −→β σ2(i) and ∀j /= i we have σ1(j) = σ2(j). The simultaneous substitution as defined above is a good substitution. We have properties like closure of β-reduction under the simul-

taneous substitution, i.e., if M −→β M' and σ1 −→β σ2 then Mσ1
−→∗
β M'σ2.

We can prove also that β-reduction defined as above is confluent. Some meta- properties of the simultaneous substitution are given below.

(σ1 ◦ σ2) ◦ σ3 = σ1 ◦ (σ2 ◦ σ3)  (M · σ) ◦ τ = Mτ · (σ ◦ τ )  id ◦ σ = σ.
We believe that calculi in λσ-style, ΛCCL [6], the suspension calculus [16] can all be shown to implement such a simultaneous substitution. The advantages of this method is that calculi in λσ-style (see [14] for an overview of such cal- culi) can be interpreted into the common calculus of λ-calculus with a notion of simultaneous substitution as defined above, which is known to be confluent even extended with constants. However, we cannot reason about the extension of these calculi with meta-variables ranging over substitutions.

Conclusion and future work
In this paper, we gave a general method for the proof of confluence (ground and on open terms) for calculi of explicit substitution like λs and λυ. The key elements of our method are: the properties of a good substitution, in special preservation of β-reduction, and the existence of an interpretation from terms of the explicit substitution calculus to terms of the pure λ-calculus, satisfying three simple properties.
We plan to extend our study to λζ and also to λσ. We should also con- sider the weak calculi of explicit substitution, e.g., λσcw or λσw[9]. In weak calculi of explicit substitution calculi, β-reduction is forbidden under λ. We believe that our method can be extended in a natural way to other calculi, and so offers a simple proof method for the confluence of calculi of explicit substitution. We have briefly explained above how to apply our method for calculi with composition of substitutions. Another point we have to mention is that our method covers only calculi that are at least weakly-terminating. It can be argued that this is necessary since one of the main purposes of ex- plicit substitution calculi has been to perform the process of substitution in a step-by-step manner. It is reasonable to require that there must be at least one strategy that completes such process.
Acknowledgments. I wish to thank the referees, F. Kamareddine and J. B. Wells for their helpful remarks.

References
M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. L´evy. Explicit substitutions, J. Funct. Programming, 1(4):375–416, 1991.
Z.-El-Abidine Benaissa, D. Briaud, P. Lescanne, and J. Rouyer-Degli. λυ, a calculus of explicit substitutions which preserves strong normalisation. Journal of Functional Programming, 6(5):699–722, 1996.
P.-L. Curien and T. Hardin and J.-J. L´evy. Confluence properties of weak and strong calculi of explicit substitutions. Journal of the ACM”, 43(2):342–397, 1999.


H. B. Curry and R. Feys. Combinatory Logic, volume 1. North-Holland, 1958.
N. Dershowitz. Termination of rewriting. Journal of Symbolic Computation, 3:69–116, 1987.
J. Fields. On Laziness and Optimality in Lambda Interpreters: Tools for Specification and Analysis. Seventeenth Annual ACM Symposium on Principles of Programming Languages, pp. 1–15, ACM press, 1990.
R. David, B. Guillaume. A lambda-calculus with explicit weakening and explicit substitution. Math. Struct. in Comp. Science, 11:169–206, 2001.
N. G. de Bruijn. Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser Theorem. Indagationes Mathematicae, 34(5):381–392, 1972.
T. Hardin. Confluence Results for the Pure Strong Categorical Logic CCL: λ-calculi as Subsystems of CCL. Theoretical Computer Science, 65(2):291–342, 1989.
C. A. Mun˜oz Hurtado. Confluence and preservation of strong normalization in an explicit substitutions calculus. Rapport de recherche, 2762, INRIA, December, 1995.
F. Kamareddine and A. R´ıos. A λ-calculus a` la de Bruijn with explicit substitution. In 7th Int’l Symp. Prog. Lang.: Implem., Logics & Programs, PLILP ’95, volume 982 of LNCS, pages 45–62. Springer-Verlag, 1995.
F. Kamareddine and A. R´ıos. Extending a λ-calculus with explicit substitution which preserves strong normalization into a confluent calculus on open terms. Journal of Functional Programming, 7(4):395–420, July 1997.
F. Kamareddine and A. R´ıos. Relating the λσ- and λs-Styles of Explicit Substitutions. Journal of Logic and Computation, vol. 10, nr. 3,pp. 399-431, 2000.
P. Lescanne. From λσ to λυ a journey through calculi of explicit substitutions. In Proceedings of the 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pp. 60–69, Jan. 1994.
G. Nadathur, D. S. Wilson. A Representation of Lambda Terms Suitable for Operations on their Intensions. Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, pp. 341–348, ACM Press, 1990.
G. Nadathur, D. S. Wilson. A Notation for Lambda Terms: A Generalization of Environments.
Theoretical Computer Science, 198(1-2): 49–98, 1998.
A. Stoughton. Substitution revisited. Theoretical Computer Science, 59:317–325, 1988.
