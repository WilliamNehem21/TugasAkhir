

Electronic Notes in Theoretical Computer Science 238 (2010) 41–62
www.elsevier.com/locate/entcs
Reasoning about QoS Contracts
in the Probabilistic Duration Calculus
Dimitar P. Guelev2,3
Institute of Mathematics and Informatics Bulgarian Academy of Sciences
Sofia, Bulgaria
Dang Van Hung1,4
International Institute of Software Technology The United Nations University
Macau, P. R. China

Abstract
The notion of contract was introduced to component-based software development in order to facilitate the semantically correct composition of components. We extend the form of this notion which is based on designs to capture probabilistic requirements on execution time. We show how reasoning about such requirements can be done in an infinite-interval-based system of probabilistic duration calculus.
Keywords: components, contracts, quality of service, duration calculus


Introduction
Combining off-the-shelf and dedicated components has become an established ap- proach to achieving reuse, modularity, productivity and reliability. Contracts facili- tate the correct use of components. A contract is a collection of requirements which are written in terms of the component interface. Contract requirements should be satisfied by implementations of the component, provided that the items imported from other components also satisfy the requirements appearing in the contract for them. Four levels of contracts have been identified in [1]. These are the syntactical

1 This work has been partially supported by the research project No. 60603037 granted by the National Natural Science of Foundation of China
2 Work on this paper was done during the D. Guelev’s visit to UNU/IIST in August-September 2007.
3 Email: gelevdp@math.bas.bg
4 Email: dvh@iist.unu.edu

1571-0661 © 2010 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.06.004

level, the behavioural level, the synchronization level and the quality of service level. Quality of Service (QoS) is a collective term for non-functional requirements such as worst-case and average execution time, and the consumption of resources such as memory, power, bandwidth, etc.
Component models are built around appropriate formalisations of the notions of interface, contract, component composability, composition, etc. A contract theory for components based on the notion of design from [12] has been proposed in [13,14] and has become known as the rCOS model. Since designs capture input-output relations, this model is mostly about the functional requirements on components and leaves out the QoS level from [1]. In our previous work we extended the rCOS model to capture requirements on timing and resources [3,11]. We have considered hard requirements, where, e.g., missing a deadline is regarded as fatal. We used the Duration Calculus (DC ) as our notation. QoS is mainly concerned with soft requirements, where, e.g., missing a deadline by little and not too often is tolerable. Handling requirements on the QoS involves reasoning about probability.
In this paper we extend designs to capture probabilistic requirements on exe- cution time and develop a technique to reason about QoS of real-time embedded systems using an infinite-interval-based system of probabilistic DC (PDC ) which was proposed in [10] as an extension of a corresponding system of Probabilistic Interval Temporal Logic with infinite intervals (PITL). PDC with infinite inter- vals subsumes the systems of PDC from [17,5,9] and has a relatively complete proof system to support formal reasoning. The fitness of (non-probabilistic) DC for reasoning about real-time systems has been asserted by numerous case studies [25,4,21,2,16]. Since DC is interval-based, reasoning about the behaviour of whole method executions, including their execution time, is relatively straightforward in DC . By using a probabilistic extension of DC we are able to enjoy this advantage when reasoning about QoS requirements too.

Preliminaries

We consider only the extended set of the real numbers R = R ∪ {∞} as the flow of time in PITL and PDC . In order to facilitate the description of repetitive behaviour, we include a least-fixed-point operator for non-probabilistic formulas, which was introduced in [18] and studied in [8]. ITL with inﬁnite intervals [23,20,21,22] is the underlying non-probabilistic logic of PITL and PDC . It extends the syntax of predicate logic by a binary modality (.; .), known as chop. 5 Non-logical symbols are divided into rigid and flexible depending on whether their meaning is required to be the same at all reference intervals or not. Individual variables are rigid.
An interpretation of a vocabulary L is a function I on L which maps the symbols from L to members of R, functions and predicates on R, according to the type and arity of symbols. I(s) takes an interval from ˜I as an additional argument in case s


5 Many authors write chop as ϕ-ψ instead of (ϕ; ψ).

is flexible. We use the sets of intervals
Ifin = {[τ1, τ2] : τ1, τ2 ∈ R, τ1 ≤ τ2}, Iinf = {[τ, ∞] : τ ∈ R} and ˜I = Ifin ∪ Iinf .
Given σ1 ∈ Ifin and σ2 ∈ ˜I such that max σ1 = min σ2, σ1; σ2 stands for σ1 ∪ σ2. Given an interpretation I, the values Iσ(t) of terms t at intervals σ ∈ ˜I are defined in the usual way, with the reference interval being an additional argument for flexible symbols. Satisfaction |= is defined with respect to an interpretation and a reference interval. Flexible relation symbols are interpreted predicates which take the reference interval as an argument too. The clauses for ⊥, ⇒ and E are the usual ones. The clause for (.; .) is
I, σ |= (ϕ; ψ) iff I, σ1 |= ϕ and I, σ2 |= ψ for some σ1 ∈ Ifin and σ2 ∈ ˜I
such that σ1; σ2 = σ.
0, ∞, + and = are mandatory in ITL vocabularies and always have the usual interpretation. A mandatory flexible constant l always evaluates to the length of the reference interval. Inﬁx notation for + and = and T, Λ, ⇒, e and 6 are used in the usual way. ITL-specific abbreviations include
(ϕ1; ... ; ϕn−1; ϕn)   (ϕ1; ... (ϕn−1; ϕn) .. .)
 ϕ  (T; ϕ; T) V (T; ϕ),  ϕ  ч  чϕ.
  and  bind more tightly and (.; .) binds less tightly than the boolean connectives. A complete proof system for ITL with infinite intervals with respect to an ap-
propriate abstract domain of durations was presented in [22].
Vocabularies for DC with infinite intervals additionally include state variables P, Q,.. .; state expressions S are boolean combinations of state variables with the logical constants written as 0 and 1 and in turn appear as the argument of duration terms S, which are the DC -specific construct in the syntax of DC terms. Formulas in DC are as in ITL. State variables evaluate to piece-wise constant functions of type R → {0, 1}. The value Iτ (S) of state expression S at time τ is defined using I(P )(τ ) for the involved state variables P in the usual way. Values of duration terms are defined by the equality

Iσ(∫
S) = 
m∫ax σ
Iτ (S)dτ

min σ
(  ) can be  for   Iinf . The expression   abbreviates  = 0	= 0 and l can be viewed as an abbreviation for ∫ 1 in DC .
Axioms and rules for DC (with infinite intervals) which are complete relative to
validity in real-time ITL (with infinite intervals), have been presented in [15] (resp. [10].)
The least-ﬁxed-point operator If ϕ1,..., ϕn have no negative occurrences of the propositional variables X1,..., Xn and i ∈ {1,..., n}, then μiX1 ... Xn.ϕ1,..., ϕn is well-formed and I, σ |= μiX1 ... Xn.ϕ1,..., ϕn iff σ ∈ Ai, where A1,..., An are the smallest subsets of I˜ which satisfy the equalities
Ai = {σ ∈ ˜I : Iλσ.σ∈A1,...,λσ.σ∈An ,σ |= ϕi}, i = 1,..., n.

Iteration, also known as Kleene star, can be defined using μ by the equivalence
ϕ∗   μ1X.l = 0 V (ϕ; X). I, σ |= ϕ∗ can be defined independently by the condition:
min σ = max σ or σ = σ1; ... ; σn and I, σi |= ϕ, i = 1,..., n, for some n < ω, σ1,..., σn ∈ ˜I.
Axioms and rules for μ and ∗ in DC were proposed in [18,8,7].
Higher-order quantiﬁers We use E on flexible constants and state variables with the usual meaning, in order to describe the semantics of local variables. The de- ductive power of some axioms and rules for this usage has been studied in [24,8,7]. Probabilistic ITL and DC with inﬁnite intervals (PITL) extends the syntax of
ITL terms by probability terms of the form p(ϕ) where ϕ is a formula. Formula
syntax is as in ITL, with μ and higher-order quantifiers included. A PITL model is based on a collection of interpretations of a given vocabulary L. Each interpretation is meant to describe a possible behaviour of the modelled system. Consider a non- empty set W, a function I on W into the set of the ITL interpretations of L and a function P of type W × R × 2W → [0, 1]. Let Iw and Pw abbreviate I(w) and λτ, X.P (w, τ, X), respectively, for all w ∈ W. Iw and Pw, w ∈ W, are intended to represent the set of behaviours and the associated probability distributions for every τ ∈ R in the PITL models for L.

Definition 1.1 Let τ ∈ R. Then w ≡τ v iff
Iw(s) = Iv(s) for all rigid symbols s ∈ L, except possibly the individual vari- ables;
Iw(s)(σ, d1,..., d#s) = Iv(s)(σ, d1,..., d#s) for all flexible s ∈ L, all d1,..., d#s ∈
R and all σ ∈ ˜I such that max σ ≤ τ ;
Pw(τ',X) = Pv(τ',X) for all X ⊆ W and all τ' ≤ τ .

Clearly ≡τ is an equivalence relation on W for all τ ∈ R. Members of W which are τ -equivalent model the same behaviour up to time τ . If τ1 > τ2, then ≡τ1 ⊂≡τ2 and w ≡∞ v holds iff Pw = Pv and Iw and Iv agree on all symbols, except possibly some individual variables. [w]≡τ is the set of those v ∈ W which represent the probabilistic branching of w from time τ onwards.
Definition 1.2 A general PITL model for L is a tuple of the form ⟨W,I,P⟩ where
F , W, I and P are as above and satisfy the following requirements for every w ∈ W:
W is closed under variants of interpretations. If w ∈ W, x is an individual variable from L and a ∈ R, then there is a v ∈ W such that Pv = Pw and Iv = (Iw)a , where (Iw)a maps x to a and is the same as Iw on other symbols.
x	x
The functions Pw are probability measures. For every w ∈ W and τ ∈ R the function λX.Pw(τ, X) is a probability measure on the boolean algebra ⟨2W, ∩, ∪, ∅, W⟩.
Furthermore λX.Pw(τ, X) is required to be concentrated on [w]≡ : Pw(τ, X) =
Pw(τ, X ∩ [w]≡ ) for all X ⊆ W.


Informally, the probability for a behaviour in X ⊆ [w]≡τ
to be chosen is Pw(τ, X).

Satisfaction |= is defined in PITL with respect to a model M = ⟨W,I,P⟩, a w ∈ W,

and a σ ∈ ˜I. If ψ is a sentence, then
[[ψ]]M,w,σ = {v ∈ [w]≡max σ : M, v, [min σ, ∞] |= ψ}.
This means that [ψ]]M,w,σ consists of the interpretations v which are max σ-equivalent to w and satisfy ψ at the infinite interval starting at min σ. In case ψ has free vari- ables x1,..., xn, M, v, [min σ, ∞] |= ψ should be evaluated with Iw(x1),...,Iw(xn) as the values of x1,..., xn, in order to preserve the intended meaning. Then [ψ]]M,w,σ consists of those v ∈ [w]≡max σ which satisfy the condition
(6v' ∈ W )(Pv' = Pv Λ Iv' = (Iv)Iw (x1),...,Iw (xn) ⇒ M, v', [min σ, ∞] |= ψ).
Using this notation, term values wσ(t) of probability terms t can be defined by putting
wσ(p(ψ)) = Pw(max σ, [[ψ]]M,w,σ).
Values of terms of other forms are defined as in (non-probabilistic) ITL.
The probability functions λX.Pw(τ, X) for w ∈ W and τ ∈ T in general PITL models M = ⟨W,I,P⟩ are needed just as much as they provide values for prob- ability terms. That is why we accept structures of the form ⟨W, P,I⟩ with their probability functions λX.Pw(τ, X) be defined just on the (generally smaller) alge-
bras ⟨{[[ψ]]M,w,σ : ψ ∈ L,σ ∈ ˜I, max σ = τ}, ∩, ∪, ∅, [w]≡ ⟩ as general PITL models too.
PITL is a conservative extension of ITL. Axioms and a proof rule which extend
the proof system for ITL with infinite intervals to a system for PITL were shown in
[10] to be complete with respect to a generalisation of the R-based semantics, where R is replaced by an abstract domain and the probability measures are required to be only finitely aditive.
The probability functions λX.Pw(τ, X) need not be related to each other in general models for PITL, whereas applications typically lead to models with an

origin of time τ0 = min T and a distinguished w0 ∈ W such that [w0]≡τ
= W and

λX.Pw0 (τ0,X) can be regarded as the global probability function. Then, given an
arbitrary w ∈ W and τ ∈ R, the probability function λX.Pw(τ, X) should represent conditional probability, the condition being τ -equivalence with w. Hence we should have

(1)
Pw0 (τ, A) = 
w∈[w0]≡τ
Pw(τ', A)d(λX.P w0 (τ, X)).

The following rules enable approximating (1) with arbitrary precision in PITL
proofs:
(P )	ϕ ⇒ ч(ϕ; l /= 0)
l = 0 Λ p(ϕ Λ p(ψ) < x; T) = 0 ⇒ p((ϕ; T) Λ ψ) ≥ x.p(ϕ; T)
(P )	ϕ ⇒ ч(ϕ; l /= 0)
l = 0 Λ p(ϕ Λ p(ψ) > x; T) = 0 ⇒ p((ϕ; T) Λ ψ) ≤ x.p(ϕ; T)
The proof system for PITL from [10] is minimal. Using the abbreviations
ϕh  ϕ Λ l ≥ l Λ l ≤ h

and

[ETϕ ∈ [l, h]]x   l = 0 Λ p(ϕ; T) = 1 ⇒ p(ϕh; T) = x,

we can write the derived rule

(Seq )	α ⇒ ч(α; l = 0)/ , β ⇒ ч(β; l = 0)/ , [ETα ∈ [l1, h1]]x1 , [ETβ ∈ [l2, h2]]x2 ,
l = 0 Λ p(α; β; T) = 1 ⇒ p(αh1 ; βh2 ; T) = x1x2
l1	l2

which is particularly important to our examples.
The system of probabilistic DC (PDC ) with inﬁnite intervals which we use in this paper is obtained by adding state variables and duration terms to PITL in the way used to obtain (non-probabilistic) DC from ITL. The axioms and rules for DC with infinite intervals are complete for PDC relative to validity in PITL models based on R.






A toy concurrent programming language and its se- mantics in DC with infinite intervals

We propose a toy language to illustrate our approach. It is shaped after that from
[6] and has restricted form of method call, in order to set the stage for the use of components and contracts.
Programs consist of components, which import and/or export methods. Their
syntax is:

component ::= component name
{import method}∗
{export method}∗
end name

method ::= name(parameter list )[ code];

The part code is required only for exported methods. It has the syntax

code ::= stop |	(thread) termination statement
return[ e] |	return control and
possibly a value
X	continuation
(x := e; code) |	assignment
(delay r; code) |	delay by the specified amount of time
(call [x :=]name(parameter list ); code) |	call method and possibly
obtain a value
if b then code else code |	conditional statement letrec code where X : code; ... ; X : code | mutual recursion statement var x; code	local variable declaration
code  code	parallel composition
We do not allow var to occur in the scope of other control statements. Assign- ments are atomic. Parameters are passed by value. A mutual recursion statement can trigger an infinite computation. Components are passive. The active part of a program is just a piece of code, typically a collection of concurrently running inter- leaved threads. The syntax of control statements deliberately makes tail-recursion the only expressible form of repetitive behaviour. We give no details on the type system and tacitly assume an appropriately many-sorted system of DC .
The execution of code can be described in terms of the values of its signals, vari- ables and parameters as functions of time. The semantic function [. ] defined below maps every piece of code to a DC formula which defines the set of its observable behaviours. We model each program variable v by a corresponding pair of flexible constants v and v', which denote the value of v at the beginning and at the end of the reference interval and therefore satisfy the axiom 6xч(v' = x; v /= x) where x is a rigid individual variable. We model methods m which return a value by a corre- sponding flexible function symbol. A formula of the form v' = m(e1,..., en) means that the reference interval describes a complete invocation of m with e1,..., en as the input parameters and v' as the value. We use a flexible predicate symbol for methods which return no value. We use dedicated state variables R and W to indi- cate that the thread is currently running, or has terminated, respectively. Building on the work from [19,6], we use a state variable N to mark computation time, which, unlike the time consumed by the execution of delay statements, waiting for the reaction of the environment, etc., is regarded as Negligible, in order to simplify calculations. R, W and N satisfy the axioms

T(R, W )  [R ⇒ N|Λ [R ⇒ чW |Λ  ч([W|; [чW|),

which express that computation time is negligible, a process can never be both running and terminated, and, once terminated, is never re-activated. A dedicated pair of state variables R and W describes the status of each thread. N marks negligible time for all threads. The formulas
K(V )    x' = x and KR(V )  K(V ) Λ [R|.
x∈V

mean that the variables from V preserve their values. KR(V ) additionally means that the thread is active throughout the reference interval. The clauses below define [[.]]V , where V is the set of program variables which are in the scope in the given code.

[[stop]]V	  [W|
[[return e]]V  ([чR|; KR(V ) Λ r' = e) [[return]]V	  [чR|
[[X]]V	  X
[[(C1; C2)]]V	  ([[C1]]V ; [[C2]]V )
[[x := e]]V	  ([чR|; KR(V \ {x}) Λ x' = e)
[[delay r]]V	  [чR|Λ r = ∫ чN
[[if b then C1 else C2]]V	  ([чR|; (b Λ KR(V ); [C1]]V ) V (чb Λ KR(V ); [C2]]V ))
[[call v := m(e1,..., en)]]V   ([чR|; K(V \ {v}) Λ v' = m(e1,..., en))
[[call m(e1,..., en)]]V	  ([чR|; K(V ) Λ m(e1,..., en))
[[letrec C where X1 : C1; ... Xn : Cn]]V   μn+1X1 ... XnY.[[C1]]V ,..., [[Cn]]V , [[C]]V

[[var v; C]]V   EvEv'(  (([чR|⇒ v' = v) Λ 6xч(v' = x; v =/ x)) Λ Λ[[C]]V ∪{v}

⎛ [W e W1 Λ W2|Λ [R e R1 V R2|Λ ⎞


[[(C C )

]]   ER ER EW EW
⎜ [чR1 Λ R2|Λ	⎟

2 V
1	2	1
2
⎜ T(R ,W ) Λ [R /R, W /W ][[C ]] Λ ⎟

⎝ T(R2, W2) Λ [R2/R, W2/W ][[C2]]V	⎠
[[export m(p1,..., pn) code]]   6p1 ... 6pn6r'(r' = m(p1,..., pn) e [[code]]∅),

if m returns a value;
[[export m(p1,..., pn) code]]   6p1 ... 6pn(m(p1,..., pn) e [[code]]∅),

if m returns no value. The semantics of a component is the conjunction of the formulas [export m(p1,..., pn) code ] for its exported methods. Declarations of imported methods carry only typing information.

Reasoning about timed programs in PDC : pattern and examples
Let C be a piece of code. Then the formula [C]]V contains the flexible function and relation symbols for the methods with calls in C. Let m be such a method; let m return no value for the sake of simplicity. Let B be the body of m. By replacement of equivalents we can derive
[[export m(p1,..., pn) B]] Λ [[C]]V ⇒ [[[B]]∅/m][[C]]V ,
where the substitution [[[B]]∅/m] distributes over the boolean connectives, chop and quantifiers and [[[B]]∅/m]m(e1,..., en) is defined as [e1/p1,..., en/pn][[B]]∅. Assume that the satisfaction of a requirement Req C written in DC by C is expressed as the equivalence
[[C]]V ⇒ Req C
and, according to a contract, m is supposed to satisfy a requirement Reqm, that is,
[[B]]∅ ⇒ Reqm
is valid for every acceptable B. Then the formula
[Reqm/m][[C]]V ⇒ Req C
states that C would satisfy Req C, provided that the imported implementation of m
satisfies Req M .
This setting enables reasoning about the probability distribution of the execution time of code that calls imported methods too. Let C and m be as above. Then the probability for C to terminate within d time units can be expressed as the PDC term
p([[C]]V Λ ∫ чN ≤ d; T),
where we use чN to measure only non-negligible execution time spent on the execution of delay or by other processes. Now let Fm be a rigid function symbol such that Fm(x) denotes a lower bound for the probability for m to terminate within time x. Let Pm be the precondition for the successful execution of m. Let p abbreviate p1,..., pn. Then
6x(l = 0 ⇒ p(Pm(p) Λ m(p) Λ ∫ чN > x; T) < 1 — Fm(x)) ▶PITL
p([[C]]V Λ ∫ чN ≤ d; T) ≥ c
means that the probability for C to terminate within d time units is at least c. The correspondence between the assumption on the execution time of m and the derived estimate of the execution time of C can be expressed even more accurately, if we

make d and Fm parameters in an appropriate expression FC in place of c:
6x(l = 0 ⇒ p(Pm(p) Λ m(p) Λ ∫ чN > x; T) < 1 — Fm(x)) ▶PITL
p([[C]]V Λ ∫ чN > d; T) < 1 — FC(d, Fm).
In general FC represents a mapping from distributions to distributions, but if the form of Fm is known up to numerical parameters such as mean and variance, then FC can be defined as a mapping from their numerical domains instead of the space of distributions.
Example 3.1 Consider downloading e-mail, which consists of establishing a con- nection with a server, followed by the actual download. Let the code C for this call two imported methods, connect () and getMail ():
var ok; call ok := connect (); if ok then (call getMail (); stop) else stop
Let Fconnect (t) be the probability for connecting within time t. Let the amount of the e-mail be probabilistically distributed too and the probability for downloading it in time t be FgetMail (t). Then lower bounds FC for the distribution of the execution time of C satisfy the formula:
l = 0 ⇒ p([[call ok := connect ()]] Λ ∫ чN > t; T) < 1 — Fconnect (t), l = 0 ⇒ p(ok Λ [[call getMail ()]] Λ ∫ чN > t; T) < 1 — FgetMail (t)
▶PITL p([[C]] Λ ∫ чN > t; T) < 1 — FC(t).
Since the time for connecting and the quantity of e-mail to download can be assumed independent,

(2)
y
FC(t) =	Fconnect (y — t)dFgetMail (t).
0

FC can be derived in PITL only approximately, because PITL does not capture taking the limits involved in the definition of the integral in (2). This corresponds to the established use of numerical approximations for distributions. Except for some thoroughly studied distributions, cummulative probability functions seldom have a closed form. Using contracts makes it natural to work with lower bounds and not exact probabilities. The latter may as well not exist. This makes approximations satisfactory. To derive such approximations for (2) in PITL, we find a sequence Ak, k = 0, 1,.. ., of terms involving Fconnect , FgetMail and t such that
p([[C]] Λ ∫ чN > t; T) < 1 — Ak
for all k can be derived in PITL and, by the definition of , limk Ak = FC(t). Taking this limit briefly takes us outside PITL. The part of the derivation within PITL is a formalisation of a standard calculation. Let
(3)	ϕt2   ϕ Λ ∫ чN > t1 Λ ∫ чN ≤ t2
Every method call can terminate at most once. This implies the validity of the formulas connect ⇒ ч(connect ; l /= 0) and getMail ⇒ ч(getMail ; l /= 0) and enables an application of Seq to derive

l = 0 Λ p(connect; getMail; T) = 1 ⇒

(l+1)t

p(connectlt k
k
(m+1)t

; getMailmt k
k
; T) = 

(Fconnect ( (l+1)t ) — Fconnect ( lt ))(FgetMail ( (m+1)t ) — FgetMail ( mt ))
k	k	k	k
for all l, m ∈ {0,...,k — 1}. Now by a repeated application of the PITL axiom P+, and using that Fconnect (0) = 0, we obtain
p((connect; getMail) Λ ∫ чN ≤ t; T)

≤
l+m≤k−1
(l+1)t
p(connectlt k
k
(m+1)t
; getMailmt k
k
; T)+

(l+1)t
(	;
(m+1)t
;	)

p connectlt k	getMailmt k	T
l+m=k	k	k
=	Σ	Fconnect ( (k−m+1)t )(FgetMail ( (m+1)t ) — FgetMail ( mt )) +Bk
k	k	k
m≤k−1
`	˛¸	x
where Bk ≤ maxl≤k−1 Fconnect ( (l+1)t ) — Fconnect ( lt), and therefore limk Bk = 0. By
k	k
the definition of Stieltjes integral, we have limk Sk = FC(t). Hence we can take Ak
to be the expression on the right of ≤ above.
Note that Seq was formulated with ϕt2 standing for ϕ Λ l ≥ t1 Λ l ≤ t2, but it
applies to (3) as well.

Example 3.2 Consider attempting to download 5 files in quick succession. With a server which allows at most 4 files to be downloading simultaneously, the 5th request can be cancelled by the browser due to a timeout. We are interested in the probability of cancellation. Here follows an extremely simplified variant of the relevant browser code:
letrec X where	1
X : if userRequest then	2
(userRequest := false;	3
, call handle := requestDownload (url, timeout ); ⎞ 4

(4)
 . if handle! = null	. 5

X
then (call download (handle); stop)
else (call signalTimeout (url ); stop)
.⎠ 6



)	8
else X	9
A separate process is assumed to indicate the arrival of a new download request by setting the shared variable userRequest and placing the URL in the shared variable

url . Let

, ([чR|; KR(V ) Λ чuserRequest )∗;	⎞

α(R, T )  . [чR|; KR(V ) Λ userRequest ; [чR|;	. Λ ∫ чN = T



and
⎝ KR(V \ {userRequest}) Λ userRequest' = false ⎠


, [чR|;	⎞

. KR(V \ {handle}) Λ handle' = requestDownload (url, timeout ); .
β(R, W, T ) 
. [чR|; KR(V ) Λ handle! = null; [чR|;	.
⎝ KR(V ) Λ download (handle) Λ ∫ чN = T ; [W|	⎠
According to the semantics of (4), α(R, T ) describes the repeated execution of lines 2-3 and 9 until userRequest becomes true with T denoting the overall execution time, and β(R, W, T ) corresponds to the execution of lines 4-6, with R and W describing the status of the thread created in order to complete the requested download, and T denoting the download time. The scenario of launching the five downloads involves six threads: one for each download and one to keep the system ready for further requests. Let R1,..., R6, W1,..., W6 describe the status of the six threads. Then the scenario can be described by the formula



(5)
, [W
ER1 ... ER6EW1 ... EW6 .
6
e
i=1
Wi|Λ [R
6
e
i=1
Ri|Λ	⎞
.

[
1≤i<j≤6
ч(Ri
Λ Rj
)|Λ 6
i=1
T(Ri, Wi) Λ γ ⎠

where γ describes the concurrent execution of the six threads and is written using the additional abbreviations:
αi(T )   α(Ri+1 V ... V R6, Wi+1 Λ ... Λ W6,T ) and βi(T )   β(Ri, Wi,T ).
With these abbreviations γ can be written as

,	, β1(D1)Λ
.	. ,


, β2(D2)Λ
⎞⎞
⎞⎞ ..

.α(R, W, T0); . .	. ,	, β3(D3)Λ
⎞⎞ .. ..

.	. .α1(T1); . .α (T ); . ,
,	(	)
⎞⎞ .. .. ..

⎝	⎝ .⎝
β4 D4 Λ
⎝	⎝ ⎝α (T ); ⎝
⎠⎠ ⎠⎠ ⎠⎠ ⎠⎠


Here Ti denotes the time between launching the ith and the i + 1st download and Di denotes the duration of the ith download, i = 1,..., 5. The formulas ξ and η denote

([чR5|; KR5 (V \ {handle}) Λ handle' = requestDownload (url, timeout ) Λ ∫ чN = x; T))

and
(([чR6|; KR6 (V ) Λ чuserRequest )∗; T),
and correspond to the thread for the 5th download and the thread for subsequent user requests after the 5th download request. The occurrences of T in them mark future behaviour which is not specified in our scenario. The semantics of letrec implies (5); this can be established using the validity of μX.ϕ e [μX.ϕ/X]ϕ. As- suming that the rate of downloading is the limiting factor for the working of the entire system, which allows us to ignore time taken for dialog, computation and by requestDownload for the first four downloads, the 5th download becomes cancelled in case x exceeds timeout , which is equivalent to

Σ	4 ,
i−1	⎞

timeout +

j=1
Ti < min	Di +
i=1

j=1
Tj⎠ .

Let F (l, t) be a lower bound for the probability for download do complete a download of length l within time t. It can be assumed that F (al, at) = F (l, t) for all a > 0 and
that F (l, t) = 0 in case l exceeds the top transmission rate v. Let li be the length
of the ith download, i = 1,..., 5. Let li > v(T1 + T2 + T3 + T4) for i = 1,..., 4, that
is, none of the downloads can be over before all of them have been launched, for the sake of simplicity. Then the probability Pi for i ∈ {1,..., 4} to be the first download to complete, and to complete before the timeout for the pending 5th download is at least



{⟨q1,...,q4⟩:li−qi≤lj −qj ,j=1,...,4}
 ∂ F (q, t)(li — qi, timeout ).
4
k=1
F'(qk,
4
s=k
Ts)dq1 ... dq4,

The probability for the 5th download not to be cancelled is P1 + ... + P4. Ap- proximations of the above integral can be derived in PITL using Seq much like in Example 3.1.
Using a contract in which the execution time of download is approximated by a distribution depending just the amount of data to transmit is too crude. A more accurate calculation is possible by taking the amount of competing traffic in account, but the form of contract that we propose does not enable it.

Probabilistic timed designs
A design ⟨P, R⟩, usually written as P ▶ R, describes a computation by a precondition P , an input-output relation R. P constrains the initial values v of the variables, and R is a relation between v and the final values v' of the variables, which holds if v initially satisfy P . A probabilistic timed design ⟨P, R, F⟩ additionally includes an execution time distribution F . F (v, t) is a lower bound for the probability for the computation to terminate within time t, provided that P (v) holds. A hard bound d on execution time can be expressed by a F satisfying F (d') = 1 for all d' ≥ d.

Describing designs in PDC
The property of method m encoded by ⟨P, R, F⟩ can be written as the PITL for- mulas
m ⇒ (P (v) ⇒ R(v, v')) and l = 0 ⇒ p(P (v) Λ m Λ l > t; T) < 1 — F (v, t).
The first one is for the functional behaviour of m. The second one states that if P (v) holds, then m to takes more than t time units with probability less than 1 — F (v, t). F is just a lower bound, because an exact probability need not exist.

Reﬁnement of probabilistic timed designs
Design D1 = ⟨P1, R1, F1⟩ reﬁnes design D2 = ⟨P2, R2, F2⟩, written D1 ± D2, if
6x(P2(x) ⇒ P1(x)), 6x6x'(R1(x, x') ⇒ R2(x, x')), and 6x6t(F2(x, t) ≤ F1(x, t)).
This means that D1 has a weaker or equivalent precondition and a stronger or equivalent input-output relation, and on average terminates at least as fast as D2. Obviously if D1 ± D2, then
P1(v) Λ m ⇒ R1(v, v') and 6x(l = 0 ⇒ p(P1(v) Λ m Λ l > x; T) < 1 — F1(v, x)) entail
P2(v) Λ m ⇒ R2(v, v') and 6x(l = 0 ⇒ p(P2(v) Λ m Λ l > x; T) < 1 — F2(v, x)).

Probabilistic timed contracts
The execution time of a method depends on the execution times of the methods which have calls in its body.
Definition 5.1 [component declaration] A component declaration is a pair ⟨Mi, Me⟩ where Mi and Me are disjoint sets of declarations for imported and exported meth- ods, respectively.
Definition 5.2 [probabilistic timed contract] Let ⟨Mi, Me⟩ be a component dec- laration and Vm be the set of the valuations for the variables of declaration m, m ∈ Mi ∪ Me. The tuple C = ⟨Dm : m ∈ Mi ∪ Me⟩ is a contract for ⟨Mi, Me⟩, if Dm are of the form ⟨Pm, Rm, Fm⟩ where
⟨Pm, Rm⟩ is a (non-probabilistic) design for m, m ∈ Mi ∪ Me.
Fm is a variable of type Vm × R+ → [0, 1] for method declarations m ∈ Mi and is meant to denote a distribution of the execution time of implementations of m.
For declarations m ∈ Me, Fm an expression for the distibution of the ex- ecution time of an implementation of declaration m as in probabilistic designs in terms of Fn, n ∈ Mi.
We denote {n ∈ Mi : Fn occurs in Fm} by Ci,m. Semantically, if m ∈ Me, then

the type of Fm is
,


Vn × R+ → [0, 1]	→ (Vm × R+ → [0, 1]).

⎝n∈Ci,m	⎠
Syntactically we assume that Fm is an expression such as, e.g., (2). A contract C is meant to express that if the methods m ∈ Mi satisfy their corresponding designs Dm and the distribution variables Fm are assigned lower bounds for the distributions of their execution times, then the methods from Me satisfy their corresponding designs and the expressions Fm evaluate to lower bounds for the distributions of their execution times too. If Ci,m = 0 then ⟨Pm, Rm, Fm⟩ is essentially a probabilistic timed design.
Definition 5.3 [refinement of probabilistic timed contracts] Let C and C' be proba- bilistic timed contracts for ⟨Mi, Me⟩ and ⟨M',M'⟩, respectively. Let C = ⟨⟨Pm, Rm, Fm⟩ :
i	e
m ∈ Mi ∪Me⟩ and C' = ⟨⟨P ' , R' ,F' ⟩ : m ∈ M' ∪M'⟩. Then, C' refines C, written
m	m	m	i	e
C' ± C, if
M' ⊆ Mi, M' ⊇ Me;
i	e

⟨Pm, Rm⟩± ⟨P ' , R' ⟩ for m ∈ M', ⟨P ' , R'
⟩± ⟨Pm, Rm⟩ for m ∈ Me;

m	m	i	m	m
Fm(v, t) ≤ F' (v, t) for m ∈ Me,v ∈ Vm,t ∈ R+ regardless of the values of
Fn, n ∈ Mi.

Composing probabilistic timed contracts
Let Ak = ⟨Mk,Mk⟩ and Ck = ⟨⟨Pk , Rk ,Fk ⟩ : m ∈ Mk ∪ Mk⟩, k = 1, 2, be two
i	e	m	m	m	i	e
component declarations and probabilistic timed contracts for them, respectively. A1
and A2 are composable, if M 1 ∩ M 2 = ∅. C1 and C2 are composable, if A1 and A2
e	e
are composable, and Dk ± D2−k for m ∈ Mk ∩M 2−k, k = 1, 2. The composition of
m	m	e	i
C1 and C2, written C1 ∪ C2, is ⟨⟨Pm, Rm, Fm⟩ : m ∈ M 1 ∪ M 1 ∪ M 2 ∪ M 2⟩ where:
i	e	i	e
Pm(v)   P 1 (v) Λ P 2 (v), Rm(v, v')   R1 (v, v') Λ R2 (v, v') and Fm = F 1 =

m	m
F 2 for m ∈ M 1 ∩ M 2;
m	m	m

m	i	i
Pm = Pk and Rm = Rk
for m ∈ Mk ∪ (Mk \ M 2−k), k = 1, 2;

m	m	e	i	i
Fm = Fk for m ∈ Mk \ M 2−k, k = 1, 2.
m	i	i
To facilitate the understanding, we first define Fm, m ∈ M 1 ∪M 2, in case C1 and
e	e
C2 allow no circular dependency between the methods, that is, if there is no sequence
m0,..., m2s−1 such that mr ∈ M 1 ∩ M 2 for r = 1, 3,..., 2s — 1, Mr ∈ M 2 ∩ M 1
e	i	e	i
for r = 0, 2,..., 2s — 2 and mr ∈ C2−r mod 2	, r = 0,..., 2s — 1. Given that there
is no circular dependency, we can define dependency depth of m from C1 ∪ C2 as the length s of the longest sequence of the form m1,..., ms such that m1 ∈ Ci,m
and mr+1 ∈ Ck	, where k is such that mr ∈ Mk, for r = 1,...,s — 1, and we can
define Fm by induction on the dependency depth of m by the clauses:
Fm = Fk for m ∈ Mk of dependency depth 0;
Fm = [Fn/Fk : n ∈ Ck  ]Fk for m ∈ Mk of nonzero dependency depth.
n	i,m	m	e
Note that the substitution replaces Fk with the expression for it from C2−k, in case
n ∈ M 2−k. Otherwise Fk is not affected by this substitution.
e	n

If thereare circular dependencies between C1 and C2, then the Fms for the exported methods in C1 ∪ C2 should be a solution of the system of equations
Xm = [Xn/Fk : n ∈ Ci,m]Fk .
n	m

Solving it without restrictions on Fk
can be hard 6 , but if Fk
and monotonic, then

X	can be obtained as the limits of the sequences Xj , j < ω, where X0 ≡ 0 and
m	m	m
Xj+1 = [Xj /Fk : n ∈ Ck ]Fk for m ∈ Mk.
m	n	n	i,m	m	e

Observe that X0
≡ 0 implies that X1
would give non-zero termination probability

only to runs of m with no calls to other imported methods; X2 would give non-
zero probability for runs with calls to imported methods which themselves lead to
no further calls, etc.  Since Fk are meant to be under-approximations, and the

monotonicity of Fk
entails Xs
≤ Xs+1 ≤ limj
j for all s < ω, Xs
can be used as

Fm instead of limj	j for sufficiently large s, to achieve a crude, but less expensive
approximation.

Concluding remarks
Here we focused just on soft requirements on execution time, but we believe that the approach can be used to capture other QoS requirements involving probability as well. The notion of QoS originated from telecommunications. Our examples come from everyday use of the Internet and need no expertise to understand. However, we believe that our technique would work just as well in other areas such as embedded systems.

References
Antoine Beugnard, Jean-Marc J´ez´equel, No¨el Plouzeau, and Damien Watkins. Making Components Contract Aware. Computer, 32(7):38–45, 1999.
Dang Van Hung. Modelling and Verification of Biphase Mark Protocols in Duration Calculus Using PVS/DC−. In Proceedings of the 1998 International Conference on Application of Concurrency to System Design (CSD’98), pages 88–98. IEEE Computer Society Press, March 1998.
Dang Van Hung. Toward a formal model for component interfaces for real-time systems. In Tiziana Margaria and Mieke Massink, editors, Proceedings of the 10th international workshop on Formal methods for industrial critical systems, pages 106 – 114. ACM Press, 2005.
Dang Van Hung and Wang Ji. On The Design of Hybrid Control Systems Using Automata Models. In
Proceedings of FST TCS 1996, volume 1180 of LNCS, pages 156–167. Springer, 1996.
Dang Van Hung and Zhou Chaochen. Probabilistic Duration Calculus for Continuous Time. Formal Aspects of Computing, 11(1):21–44, 1999.
Dimitar P. Guelev and Dang Van Hung. Prefix and Projection onto State in Duration Calculus. In
Proceedings of TPTS’02, volume 65(6) of ENTCS. Elsevier Science, 2002.
Dimitar P. Guelev and Dang Van Hung. On the Completeness and Decidability of Duration Calculus with Iteration. Theoretical Computer Science, 337:278–304, 2005.
Dimitar P. Guelev. A Complete Fragment of Higher-order Duration μ-calculus. In Proceedings of FST TCS 2000, volume 1974 of LNCS, pages 264–276. Springer, 2000.

6 In practice Fk can be non-monotonic: increasing the execution time of an imported method may indeed shorten the execution time of code which would abort if an imported method misses a deadline.


Dimitar P. Guelev. Probabilistic Neighbourhood Logic. In Mathai Joseph, editor, Proceedings of FTRTFT 2000, volume 1926 of LNCS, pages 264–275. Springer, 2000. A proof-complete version is available as UNU/IIST Technical Report 196 from http://www.iist.unu.edu.

Dimitar P. Guelev. Probabilistic Interval Temporal Logic and Duration Calculus with Infinite Intervals: Complete Proof Systems. Logical Methods in Computer Science, 3(3), 2007. URL: http://www.lmcs-online.org/.

Hung Ledang and Dang Van Hung. Concurrency and Schedulability Analysis in Component-based Real-Time System Development. In Proceedings of the 1st IEEE & IFIP International Symposium on Theoretical Aspects of Software Engineering. IEEE Computer Society Press, 2007.
C.A.R. Hoare and He Jifeng. Unifying Theories of Programming. Prentice Hall, 1998.

He Jifeng, Li Xiaoshan, and Liu Zhiming. A Theory of Reactive Components. In Liu Zhiming and Luis Barbosa, editors, Proceedings of the International Workshop on Formal Aspects of Component Software (FACS 2005), volume 160 of ENTCS, pages 173–195. Elsevier, 2006.

He Jifeng, Xiaoshan Li, and Zhiming Liu. A refinement calculus of object systems. Theoretical Computer Science, 365(1-2):109–142, 2006.

Michael R. Hansen and Zhou Chaochen. Semantics and Completeness of Duration Calculus. In Real- Time: Theory and Practice, volume 600 of LNCS, pages 209–225. Springer, 1992.

Li Li and He Jifeng. A Denotational Semantics of Timed RSL using Duration Calculus. In Proceedings of RTCSA’99, pages 492–503. IEEE Computer Society Press, 1999.

Liu Zhiming, A. P. Ravn, E. V. Sørensen, and Zhou Chaochen. A Probabilistic Duration Calculus. In H. Kopetz and Y. Kakuda, editors, Dependable Computing and Fault-tolerant Systems Vol. 7: Responsive Computer Systems, pages 30–52. Springer, 1993.
Paritosh K. Pandya. Some extensions to Mean-Value Calculus: Expressiveness and Decidability. In
Proceedings of CSL’95, volume 1092 of LNCS, pages 434–451. Springer, 1995.

Paritosh K. Pandya and Dang Van Hung. Duration Calculus of Weakly Monotonic Time. In Proceedings of FTRTFT’98, volume 1486 of LNCS, pages 55–64. Springer, 1998.

Paritosh K. Pandya, Wang Hanping, and Xu Qiwen. Towards a Theory of Sequential Hybrid Programs. In D. Gries and W.-P. de Roever, editors, Proceedings of IFIP Working Conference PROCOMET’98, pages 336–384. Chapman & Hall, 1998.

Gerardo Schneider and Xu Qiwen. Towards a Formal Semantics of Verilog Using Duration Calculus. In Anders P. Ravn and Hans Rischel, editors, Proceedings of FTRTFT’98, volume 1486 of LNCS, pages 282–293. Springer, 1998.

Wang Hanpin and Xu Qiwen. Completeness of Temporal Logics over Infinite Intervals. Discrete Applied Mathematics, 136(1):87–103, 2004.

Zhou Chaochen, Dang Van Hung, and Li Xiaoshan. A Duration Calculus with Infinite Intervals. In Horst Reichel, editor, Fundamentals of Computation Theory, volume 965 of LNCS, pages 16–41. Springer, 1995.

Zhou Chaochen, Dimitar P. Guelev, and Zhan Naijun. A Higher-order Duration Calculus. In Millennial Perspectives in Computer Science, pages 407–416. Palgrave, 2000.

Zheng Yuhua and Zhou Chaochen. A Formal Proof of a Deadline Driven Scheduler. In Proceedings of FTRTFT’94, volume 863 of LNCS, pages 756–775. Springer, 1994.

Proof systems
Proof system for ITL with inﬁnite intervals
The following axioms and rules have been shown to form a complete proof system for ITL with infinite intervals when added to a Hilbert-style proof system for classical first-order predicate logic and appropriate axioms about an abstract domain of durations in [22]:

(A1)	(ϕ; ψ) л ч(χ; ψ) ⇒ (ϕ л чχ; ψ), (ϕ; ψ) л ч(ϕ; χ) ⇒ (ϕ; ψ л чχ) (A2)	((ϕ; ψ); χ) e (ϕ; (ψ; χ))
(R)	(ϕ; ψ) ⇒ ϕ, (ψ; ϕ) ⇒ ϕ if ϕ is rigid
(B)	(Exϕ; ψ) ⇒ Ex(ϕ; ψ) if x has no free occurrences in ψ
(ψ; Exϕ) ⇒ Ex(ψ; ϕ)
(L1)	(l = x; ϕ) ⇒ ч(l = x; чϕ), (ϕ; l = x л x /= ∞) ⇒ ч(чϕ; l = x) (L2)	l = x + y л x /= ∞e (l = x; l = y)
(L3)	ϕ ⇒ (l = 0; ϕ), ϕ л l /= ∞⇒ (ϕ; l = 0)
(S1)	(l = x л ϕ; ψ) ⇒ ч(l = x л чϕ; χ) (P 1)	ч(l = ∞; ϕ)
(P 2)	(ϕ; l = ∞) ⇒ l = ∞
(P 3)	(ϕ; l /= ∞) ⇒ l /= ∞

(N )	ϕ
ч(чϕ; ψ)
ϕ
,
ч(ψ; чϕ)



(Mono)	ϕ ⇒ ψ

(ϕ; χ) ⇒ (ψ; χ)
Using the first order logic axiom
ϕ ⇒ ψ
,
(χ; ϕ) ⇒ (χ; ψ)

(Er ) [t/x]ϕ ⇒ Exϕ.

is correct only if no variable in t becomes bound due to the substitution, and either t is rigid or (.; .) does not occur in ϕ.

Axioms and rules for DC with inﬁnite intervals
The axioms and rules below were proposed for DC with finite intervals and have been shown to be complete relative to validity in real-time ITL in [15].

(DC1)
(DC2)
0 =0 
R 1 = l

(DC3)   S ≥ 0
(DC4)  R S1 + R S2 = R (S1 V S2)+ R (S1 л S2)

(DC6) S1 = S2 if S1 and S2 are propositionally equivalent (IR1)  [l = 0/A]ϕ ϕ ⇒ [A V (A; [S| V [чS|)/A]ϕ
[T/A]ϕ
(IR2)  [l = 0/A]ϕ ϕ ⇒ [A V ([S| V [чS|; A)/A]ϕ
[T/A]ϕ
The completeness proof from [15] involves two theorems which can be derived using the rules IR1 and IR2, instead of the rules themselves. The second of these theorems does not hold for infinite intervals and therefore we modify it appropriately:
(T 1)  l =0 V ([S|; T) V ([чS|; T)
(T 2)  l =0 V l = ∞V (T; [S|) V (T; [чS|)
DC1-DC6, T 1 and the infinite-interval variant of T 2 form a relatively complete proof system for DC with infinite intervals.

Proof system for PITL
PITL is a conservative extension of ITL. Adding the axioms and a proof rule below to the proof system for
ITL leads to a system which is complete for PITL with respect to a generalisation of the R-based semantics,
where R is replaced by an abstract domain and the probability measures are required to be only finitely aditive.
Extensionality
(P;)	(l = x; p(ψ)= y) ⇒ p((l = x; ψ)) = y
(P∞)	l = ∞⇒ (ϕ e p(ϕ)= 1)
▶ (ϕ; l = ∞) ⇒ (ψ ⇒ χ)

(P≤)


▶ ϕ л l < ∞⇒ p(ψ) ≤ p(χ)

Arithmetics of probabilities

(P⊥)	p(⊥)=0 
(PT)	p(T)=1 
(P+)	p(ϕ)+ p(ψ)= p(ϕ V ψ)+ p(ϕ л ψ)


Useful theorems and derived rules for PITL
All the theorems and rules below except P' are valid in general PITL models. P' is valid in PITL models
;	;
with global probability.
(P∞)	(ϕ; l = ∞) V (ϕ л l = ∞) ⇒ (ψ ⇒ χ)


≤
(PITL1)
ϕ ⇒ ψ
ϕ ⇒ p(ψ) ≤ p(χ)
ϕ e ψ
,

p(ϕ) ≤ p(ψ)  p(ϕ)= p(ψ)
(PITL2)	p(ϕ)+ p(чϕ)=1 
(PITL3)	p(ϕ) < p(ψ) ⇒ p(ψ л чϕ) /=0 (PITL4)	p(ϕ)= p(ϕ л l = ∞)
(PITL5)	p(ϕ) ≤ 1

(PITL6)
ϕ	чϕ
,

p(ϕ)=1  p(ϕ)=0 
(PITL7)	(ϕ; T) ⇒ p(ϕ; T)=1 
(PITL8)	p(ϕ)=1 л p(ψ)= x ⇒ p(ϕ л ψ)= x (PITL9)	p(ϕ ⇒ ψ)=1 ⇒ (p(ϕ)=1 ⇒ p(ψ)= 1)
p(ϕ ⇒ ψ)=1 ⇒ (p(ψ)=0 ⇒ p(ϕ)= 0) (PITL10)	p(ϕ)+ p(ψ) > 1 ⇒ p(ϕ л ψ) > 0
(P')	ϕ ⇒ ч(ϕ; l /= 0)
;	(ϕ; p(ψ)= x) ⇒ p(ϕ; ψ)= x
Here follow the proofs of the above PITL theorems and derived rules. The purely ITL parts are skipped and marked “ITL” for the sake of brevity.
P∞:
(ϕ; l = ∞) ⇒ (ψ ⇒ χ)	assumption, ITL
ϕ л l < ∞⇒ p(ψ) ≤ p(χ)	1, P≤
l = ∞л ϕ ⇒ (p(ψ)=0 л p(χ) = 0) assumption, P∞, PITL2
V(p(ψ)=0 л p(χ)= 1)
V(p(ψ)=1 л p(χ)= 1)
ϕ л l = ∞⇒ p(ψ) ≤ p(χ)	3, ITL
l < ∞V l = ∞	ITL
ϕ ⇒ p(ψ) ≤ p(χ)	2, 4, 5
PITL1:
ϕ ⇒ ψ	assumption
(T; l = ∞) V (Tл l = ∞) ⇒ (ϕ ⇒ ψ) 1, ITL
p(ϕ) ≤ p(ψ)	2,P∞
The second rule PITL1 is proved by two applications the first.
PITL2:
ϕ л чϕ e⊥	ITL
p(ϕ л чϕ)= p(⊥)	1, PITL1
p(ϕ л чϕ)=0	2, P⊥
ϕ V чϕ eT	ITL
p(ϕ V чϕ)= p(T)	4, PITL1
p(ϕ л чϕ)=1	5, PT
p(ϕ)+ p(чϕ)= p(ϕ л чϕ)+ p(ϕ л чϕ) P+
p(ϕ)+ p(чϕ)=1	2, 6, 7, ITL PITL3:

p(ψ) ≤ p(ϕ V ψ)	P∞
p(ϕ)+ p(ψ л чϕ)= p(ϕ л ψ л чϕ)+ p(ϕ V ψ л чϕ) P+
p(ϕ)+ p(ψ л чϕ)= p(ϕ V ψ)	2, PITL1, P⊥
p(ϕ) < p(ψ) ⇒ p(ϕ) < p(ϕ V ψ)	1
p(ϕ) < p(ψ) ⇒ p(ψ л чϕ) /=0	3, 4
PITL4 is obtained by applying P∞ to the ITL theorems (T; l = ∞) V (Tл l = ∞) ⇒ (ϕ ⇒ ϕ л l = ∞)
and
(T; l = ∞) V (Tл l = ∞) ⇒ (l = ∞л ϕ ⇒ ϕ).
PITL5:
ϕ ⇒T	ITL
p(ϕ) ≤ p(T) 1, PITL1
p(ϕ) ≤ 1	2, PT
PITL6:

T⇒ ϕ	assumption
p(T) ≤ p(ϕ) 1, PITL1
1 ≤ p(ϕ)	2, PT
p(ϕ) ≤ 1	PITL5
p(ϕ)=1	3, 4
PITL7:
чϕ	assumption
p(чϕ)=1 1, PITL6
p(ϕ)=0  PITL2

1 (ϕ; T; l = ∞) V ((ϕ; T) л l = ∞) ⇒ (T⇒ (ϕ; T)) ITL
2 (ϕ; T) ⇒ p(ϕ; T)=1	P∞
PITL8:
1 p(ϕ)=1 л p(ψ)= x ⇒ p(ϕ л ψ)+ p(ϕ V ψ)=1 + x P+
ϕ ⇒ (ϕ V ψ)	ITL
p(ϕ) ≤ p(ϕ V ψ)	2, PITL1
p(ϕ)=1 ⇒ p(ϕ V ψ)=1	3, PITL5
p(ϕ)=1 л p(ψ)= x ⇒ p(ϕ л ψ)= x	1, 4
PITL9:
1 p(ϕ ⇒ ψ)=1 л p(ϕ)=1 ⇒ p((ϕ ⇒ ψ) л ψ)=1 PITL8
(ϕ ⇒ ψ) л ψ ⇒ ψ
p((ϕ ⇒ ψ) л ψ) ≤ p(ψ)	2, PITL1
p(ψ) ≤ 1	PITL5
p(ϕ ⇒ ψ)=1 ⇒ (p(ϕ)=1 ⇒ p(ψ)= 1) 1 —	4
p((ϕ ⇒ ψ) ⇒ (чψ ⇒ чϕ))=1	PITL6
p(ϕ ⇒ ψ)=1 ⇒ p(чψ ⇒ чϕ)=1	1, PITL9
p(чψ ⇒ чϕ)=1 ⇒ (p(чψ)=1 ⇒ p(чϕ)= 1) PITL9
p(чψ ⇒ чϕ)=1 ⇒ (p(чψ)=0 ⇒ p(чϕ)= 0) 3, PITL2
p(ϕ ⇒ ψ)=1 ⇒ (p(чψ)=0 ⇒ p(чϕ)= 0)	2, 4
PITL10:
1 p(ϕ)+ p(ψ) > 1 ⇒ p(ϕ л ψ)+ p(ϕ V ψ) > 1 P+
p(ϕ V ψ) ≤ 1	PITL5
p(ϕ)+ p(ψ) > 1 ⇒ p(ϕ л ψ) > 0	1, 2
P':
(ϕ; p(ψ)= x) ⇒ Et((ϕ л l = t; T) л (l = t; p(ψ)= x)) ITL
(ϕ л l = t; T) ⇒ p(ϕ л l = t; T)=1	PITL7
(l = t; p(ψ)= x) ⇒ p(l = t; ψ)= x	P;

p(ϕ л l = t; T)=1 л p(l = t; ψ)= x ⇒ p(ϕ л l = t; ψ)= x PITL8, PITL1, ITL
(ϕ л l = t; ψ) ⇒ (ϕ; ψ)	ITL
p(ϕ л l = t; ψ)= x ⇒ p(ϕ; ψ) ≥ x	5, PITL1
Et((ϕ л l = t; T) л (l = t; p(ψ)= x)) ⇒ Et(p(ϕ; ψ) ≥ x)	2 — 6, ITL
Et(p(ϕ; ψ) ≥ x) e p(ϕ; ψ) ≥ x	ITL
(ϕ; p(ψ)= x) ⇒ p(ϕ; ψ) ≥ x	1, 7, 8
(ϕ; p(ψ)= x) e (ϕ; p(чψ)=1 — x)	PITL2, ITL
(ϕ; p(чψ)=1 — x) ⇒ p(ϕ; чψ) ≥ 1 — x	like 1 — 9, but with чψ as ψ
(p(ϕ; ψ) > x л p(ϕ; чψ) ≥ 1 — x)V
(p(ϕ; ψ) ≥ x л p(ϕ; чψ) > 1 — x)
⇒ p((ϕ; ψ) л (ϕ; чψ)) > 0	PITL10
(ϕ; ψ) л (ϕ; чψ) л ч(ϕ л (ϕ; l /= 0); T) ⇒⊥	ITL
p((ϕ; ψ) л (ϕ; чψ) л ч(ϕ л (ϕ; l /= 0); T))=0	13, PITL6
p(ч(ϕ л (ϕ; l /= 0); T)) = 1	assumption, PITL6
p((ϕ; ψ) л (ϕ; чψ))=0	14, 15, PITL8
p(ϕ; чψ) ≥ 1 — x л p(ϕ; ψ) ≥ x
⇒ p(ϕ; ψ) ≤ x л p(ϕ; чψ) ≤ 1 — x	12, 16, ITL
(ϕ; p(ψ)= x) ⇒ p(ϕ; ψ)= x	9, 11, 17, ITL





The rule Seq
In the proof of the admissibility of Seq below ϕ л l ≥ l л l ≤ h is abbreviated by ϕh.
1 (l =0 л p(α; β; T)= 1; T) ⇒ p(p(α; β; T)=1 л l = 0; T)=1	PITL7
(α; p(β; T)= x л l = 0) ⇒ p(α; β; T)= x	P', assumptions
Ex((α; T) ⇒ (α; p(β; T)= x л l = 0; T))	ITL
(α; T) ⇒
p(α; β; T)= xл

p(α; β; T)=1 ⇒ Ex
@
2, 3, ITL
(α; p(β; T)= x л l = 0; T)л
p(α; β; T)= 1)

p(α; β; T)=1 ⇒ Ex((α; T) ⇒ (α; p(β; T)=1 л l = 0; T))	4, ITL
p(α; β; T)=1 л (α; T) ⇒ (α; p(β; T)=1 л l = 0; T)	5, ITL
p(p(α; β; T)=1 л (α; T) ⇒ (α; p(β; T)=1 л l = 0; T))=1	6, PITL6
p(p(α; β; T)= 1; T)=1 л p(α; T)=1 ⇒
p(α; p(β; T)=1 л l = 0; T)=1	7, PITL9
l =0 л p(α; β; T)=1 л p(α; T)=1 ⇒
p(α; p(β; T)=1 л l = 0; T)=1	1, 8
p(α; β; T)=1 ⇒ p(α; T)=1	PITL9
l =0 л p(α; β; T)=1 ⇒ p(α; p(β; T)=1 л l = 0; T)=1	9, 10
p(α; p(β; T)=1 л l = 0; T)=1 л p(α; p(β; T) /=1 л l = 0; T)= x ⇒
p((α; p(β; T)=1 л l = 0; T) л (α; p(β; T) /=1 л l = 0; T)) = x	PITL8
p((α; p(β; T)=1 л l = 0; T) л (α; p(β; T) /=1 л l = 0; T))=0	PITL6
p(α; p(β; T)=1 л l = 0; T)=1 ⇒ p(α; p(β; T) /=1 л l = 0; T)=0	12, 13
l =0 л p(α; β; T)=1 ⇒ p(α; p(β; T) /=1 л l = 0; T)=0	11, 14
l =0 ⇒ (p(βh2 ; T) /= x2 ⇒ p(β; T) /= 1)	[ETβ ∈ [l2, h2]]x2
αh1 ⇒ α	ITL
1
(αh1 ; p(βh2 ; T) /= x2 л l = 0; T) ⇒ (α; p(β; T) /=1 л l = 0; T)	16, 17, ITL
l1	l2
l =0 л p(α; β; T)=1 ⇒ p(αh1 ; p(βh2 ; T) /= x2 л l = 0; T)=0	15, 18, PITL6, PITL9
l1	l2
  (αh1 ; p(βh2 ; T) /= x2 л l = 0; T) e	!

l1	l2

p(ч(α л (α; l /= 0); T)) = 1	assumption, PITL6
p(αh1 ; p(βh2 ; T) /= x2 л l = 0; T)=0 e
l1	l2
p((αh1 ; T) л (α; p(βh2 ; T) /= x2 л l = 0; T))=0	20, 21, PITL9
l1	l2
α л p(α; βh2 ; T) /= x2 ⇒ ч(α; p(βh2 ; T)= x2 л l = 0)	P'
l2	l2	;
ч(α; p(βh2 ; T)= x2) л α ⇒ (α; p(βh2 ; T) /= x2 л l = 0)	ITL
l2	l2
α л p(α; βh2 ; T) /= x2 ⇒ (α; p(βh2 ; T) /= x2 л l = 0)	23, 24
l2	l2
p((αh1 ; T) л (α; p(βh2 ; T) /= x2 л l = 0; T))=0 ⇒
l1	l2
p((αh1 ; T) л (α л p(α; βh2 ; T) /= x2; T))=0	25, PITL9, PITL6
l1	l2
ч(α л (α; l /= 0); T) ⇒
((αh1 ; T) л (α л p(α; βh2 ; T) /= x2; T) e (αh1 л p(α; βh2 ; T) /= x2; T)) ITL
l1	l2	l1	l2
p((αh1 ; T) л (α л p(α; βh2 ; T) /= x2; T))=0 e
l1	l2
p(αh1 л p(α; βh2 ; T) /= x2; T)=0	21, 27, PITL9
l1	l2
l =0 л p(α; β; T)=1 ⇒ p(αh1 л p(α; βh2 ; T) /= x2; T)=0	19, 22, 26, 28
l1	l2
l =0 л p(αh1 л p(α; βh2 ; T) /= x2; T)=0 ⇒
l1	l2
p((αh1 ; T) л (α; βh2 ; T)) = x2.p(αh1 ; T)	P, P, assumptions
l1	l2	l1
ч(α л (α; l /= 0); T) ⇒ ((αh1 ; T) л (α; βh2 ; T) e (αh1 ; βh2 ; T)) ITL
l1	l2	l1	l2
(αh1 ; T) л (α; βh2 ; T) e (αh1 ; βh2 ; T)	assumption, 31
l1	l2	l1	l2
p((αh1 ; T) л (α; βh2 ; T)) = p(αh1 ; βh2 ; T)	32, PITL1
l1	l2	l1	l2
l =0 л p(α; T)=1 ⇒ p(αh1 ; T)= x1	[ETα ∈ [l1, h1]]x1
l =0 л p(α; β; T)=1 ⇒ p(αh1 ; βh2 ; T)= x2.x1	10, 29, 30, 33, 34
l1	l2
