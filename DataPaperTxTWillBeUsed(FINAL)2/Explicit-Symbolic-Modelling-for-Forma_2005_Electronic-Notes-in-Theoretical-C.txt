Electronic Notes in Theoretical Computer Science 130 (2005) 301–321 
www.elsevier.com/locate/entcs


Explicit-Symbolic Modelling for Formal Verification
Umberto Costa1 ,2	Sérgio Campos3	Newton Vieira5
Departamento de Ciência da Computação Universidade Federal de Minas Gerais Belo Horizonte, Brazil

David Déharbe4
Departamento de Informática e Matemática Aplicada Universidade Federal do Rio Grande do Norte
Natal, Brazil



Abstract
We propose a model that combines explicit and symbolic representations in an explicit-symbolic formal verification model. Both explicit and symbolic models have been successfully used in the verification of finite state concurrent systems, such as complex sequential circuits and communica- tion protocols. The proposed model aims to use explicit and symbolic techniques simultaneously to verify the same model and to make it possible to employ the most efficient technique to each aspect of the model. First, we formalize the explicit-symbolic model and show how it can be gen- erated from a labeled state-transition system. Then, we apply those ideas to systems described in the Verimag Intermediate Format and present the main algorithms for integrating the underlying models.
Keywords: model checking, explicit state, binary decision diagrams


1 Supported by a grant from CAPES, Brazil.
2 Email: umberto@dcc.ufmg.br
3 Email: scampos@dcc.ufmg.br
4 Email: david@dimap.ufrn.br
5 Email: nvieira@dcc.ufmg.br



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.03.016

Introduction
Due to the ever-growing complexity of computing applications, automatic tools have been used to help developers to find bugs in hardware and soft- ware systems. Two approaches that have been applied to achieve this goal are simulation and formal verification. The simulation approach consists of executing tests over given inputs and examining the results. This technique can easily evaluate both control and data aspects, but generally only part of the set of states is examined. In other words, simulation can state that specifications hold for some inputs, but it does not prove correctness over the whole set of states.
Formal Methods include mathematical based languages, techniques and tools for specifying and verifying hardware and software systems [12]. Com- plex systems and critical applications benefit from formal methods because they make systems more reliable. Different from simulations, formal verifi- cation techniques execute exhaustive searches over problem domains, proving conformity to specifications instead of only pointing errors for some input data.
Model checking is one well-known and successful formal technique for ver- ifying finite state concurrent systems. It has been successfully used to verify complex sequential circuits designs and communication protocols [11]. Model checking consists of representing a given system by means of a finite model to be exhaustively analyzed in order to determine its conformance to some properties. A model can be represented as a graph where each vertex is a state of the system and edges are valid transitions between states. States can be represented either explicitly or by means of some symbolic representation. Explicit models enumerate states individually, storing them in structures like hash tables. Explicit methods tend to present relatively more predictable efficiency and memory behaviors. On the other hand, symbolic models explore regularity in the state space aiming to produce more compact representations. Instead of exploring states individually as explicit model checking does, sym- bolic model checking uses efficient encoding of Boolean logical formulae to represent and to explore sets of states atomically. So, symbolic model check- ing usually allow us to verify systems with a much higher number of states when compared to explicit model checking [14]. In order to perform a sym- bolic model checking, sets of states and transitions are represented by charac- teristic functions. Computational representations of characteristic functions must be efficient and should provide essential operations, as conjunction, dis- junction, equality tests, existential quantification and substitution. Binary Decision Diagrams [6], known as BDDs, are a very efficient symbolic repre- sentation of propositional logical functions. Unfortunately, sometimes it is


difficult to express satisfactorily data information, like constraints on integer or real values, by means of simple Boolean expressions [17]. Generally, integers and arithmetic operations are not efficiently represented by means of simple Boolean expressions, due to the size of produced representations [8]. Also, systems with continuous variables ranging over non-countable domains, like real-time systems, are not suitable for symbolic model checking [16]. Usually, explicit methods are more efficient than symbolic methods when the state space presents a less regular structure.
In this paper, we propose a model for combining explicit and symbolic representations in an explicit-symbolic formal verification model. We intend to use explicit and symbolic techniques together to verify the same model and to make it possible to employ the most efficient technique to each aspect of the model. In the next section, we present related works and our main goals. After that, we develop the explicit-symbolic model and show how generate it from a labeled state-transition system. Then, we discuss how formal verification tools can use our model to verify systems given in the Verimag Intermediate Format [4]. The algorithms developed for the integration of underlying models are also shown. Finally, we present our next steps and some remarks.

Related Work
Our explicit-symbolic model integrates the underlying explicit and symbolic models. So, it has to do with explicit and symbolic verifiers and their tech- niques. Currently, SPIN [13] and JPF [5] are well-known and largely used explicit-state model checkers. On the other hand, SMV [15], NuSMV [9] and Verus [7] are representative and successful symbolic-state model checking tools. Existing algorithm optimizations from such tools, like the on-the-fly technique used by SPIN, should be considered for the implementation of un- derlying models in order to improve the model checking.
SLAM
The approach adopted in the SLAM project [3] is the one that more closely relates to our project, as it employs both explicit and symbolic models in- side a same environment. SLAM extracts abstract models from C code and statically checks temporal properties of software. Also, SLAM uses predicate abstractions, symbolic reasoning and iterative refinement. Bebop is the part of SLAM liable for performing reachability analysis of Boolean programs.
Boolean programs are abstraction of programs where the concrete states have been mapped to abstract states under evaluation of a finite set of pred- icates. The resulting program roughly corresponds to a C program with the


same control-flow constructs, but where all variables have Boolean type. Be- cause all variables have Boolean type, the state space of the program is fi- nite. Consequently, reachability and termination are decidable for Boolean programs. More information on the predicate abstraction algorithm and its corresponding implementation can be found on [1]. Given a Boolean program, Bebop performs an inter-procedural data-flow analysis in order to determine reachability information [2]. Bebop represents control flow explicitly and sets of states implicitly using BDDs. The explicit representation of control-flow features is justified due to the usage of compiler optimization techniques. On the other hand, BDDs are used to symbolically represent the input and output behavior of procedures. They are used to represent sets of reachable states at a program point. A state contains the program counter and values to all the variables visible at that point.
Comparing to our explicit-symbolic model, SLAM lacks flexibility because control-flow and data-flow information must have explicit and symbolic repre- sentations, respectively. The proposed model is more general because it allows us to move variables between explicit and symbolic spaces according to any policy. Thus, we can experiment with a variety of combinations and choose the one that best fits the system needs. See section 7 for more details about the flexibility of the proposed model.

The Explicit-Symbolic Modelling
Although an explicit-symbolic model can be directly generated from a labeled state-transition model, we decided to accomplish this task in two distinct steps. Initially, both explicit and symbolic models are generated as projections in- duced by the partitioning of variables of the original model. Next, the explicit and symbolic models are combined to compose the explicit-symbolic model. Such approach provides a more intuitive and clear procedure to understand the formalization of the model.
Decomposition of the Original Model
Let M = (S, R, L) be the model for a given system, where S represents the set of states, R ⊆ S × S represents the transition relation between states, L : S → 2AP represents the labeling function which assigns a set of atomic propositions to each state. Assume AP as the set of atomic propositions of M. Suppose that the set AP is decomposed into subsets of explicit and symbolic propositions APe and APs, respectively, where AP = APe ∪ APs and APe ∩ APs = ∅. Using this proposition partitioning, two equivalence relations are generated, ≈e and ≈s, such that


∀ s, s' ∈ S, s ≈e s' ←→ L(s)|AP = L(s')|AP
∀ s, s' ∈ S, s ≈s s' ←→ L(s)|AP = L(s')|AP
Each induced equivalence class [s]e is an explicit state and each equivalence class [s]s is a symbolic state. In other words, each state s ∈ S corresponds to an explicit state [s]e and a symbolic state [s]s. Consequently, the set of states S is projected into explicit and symbolic sets of states, Se and Ss, as defined below:
Se = {[s]e | s ∈ S}   Ss = {[s]s | s ∈ S}
The ≈e and ≈s relations define two labeling functions Le and Ls for ex- plicit and symbolic states, respectively. Labels for an explicit state [s]e and a symbolic state [s]s are shown below:
Le([s]e)= L(s)|APe	Ls([s]s)= L(s)|APs
Therefore, L(s)= Le([s]e) ∪ Ls([s]s) because L(s)= L(s)|APe ∪ L(s)|APs .
The projection of the original system requires the original transition rela- tion R to be split into a transition relation for the explicit and another for the symbolic part of the model, Re and Rs, respectively. In order to maintain the correspondence between explicit and symbolic transitions, the original transi- tions must be labeled. One explicit transition and one symbolic transition will be assigned the same label id ∈ N only if they come from the same original
transition (s, id, s'), where s, s' ∈ S. So, labels associate explicit and symbolic transitions, indicating which occur together on the models. Given one original transition relation R, the following two transition relations are obtained:

Re = {([s]e, id, [s']e) | (s, id, s') ∈ R}   Rs = {([s]s, id, [s']s) | (s, id, s') ∈ R}
that is, if (s, id, s') ∈ R then ([s]e, id, [s']e) ∈ Re and ([s]s, id, [s']s) ∈ Rs.
The original model can be restored using the explicit and symbolic models together. Each two transitions ([s]e, ide, [s']e) ∈ Re and ([s]s, ids, [s']s) ∈ Rs, where ide = ids, defines one original transition (s, id, s') ∈ R such that id = ide = ids, L(s)= Le([s]e) ∪ Ls([s]s) and L(s')= Le([s']e) ∪ Ls([s']s).

Composition of the Explicit-Symbolic Model
Given Me = (Se, Re, Le) and Ms = (Ss, Rs, Ls), we obtain the explicit-symbolic model Mh = (Sh, Rh, Lh) by the composition of such explicit and symbolic models. Each explicit-symbolic state sh ∈ Sh is given by a pair (se, ss), where se ∈ Se, ss ∈ Ss and there exist explicit and symbolic transitions

(se, ide, s' ) ∈ Re and (ss, ids, s' ) ∈ Rs such that ide = ids. For each sh ∈ Sh,
e	s
we have Lh(sh) = Lh(sh)|APe ∪ Lh(sh)|APs , where Lh(sh)|APe  = Le(se) and

Lh(sh)|AP
= Ls(ss). If (se, id, s' ) ∈ Re and (ss, id, s' ) ∈ Rs then (sh, id, s' ) ∈

s	e	s	h
Rh, where sh, s' ∈ Sh. Due to the definition of Rh, models Me and Ms must
be explored in an interleaved and synchronized fashion, based on transition
labels. Note that states of Sh are visited during the exploration of states in
Se and Ss.
Taking an explicit-symbolic model, we can restore the original explicit and symbolic models in a straightforward way. Given Mh = (Sh, Rh, Lh), we generate Me = (Se, Re, Le) such that Se = {se|(se, ss) ∈ Sh}, Re =
{(se, id, s' )|((se, ss), id, (s' , s' )) ∈ Rh} and Le(se) = Lh((se, ss))|AP .	The
e	e	s	e
model Ms can be analogously obtained.

Intermediate Format
The Intermediate Format [4], also called IF from now on in this paper, is a language that has been developed in order to model asynchronous commu- nicating real-time systems. It has been used as interchange format between a set of validation tools known as IF validation environment. IF models are composed from process instances, running in parallel and interacting asyn- chronously through shared variables and message-passing. Message-passing is accomplished by means of signals, instances of signal routes and FIFO com- munication buffers.
In this section, we apply the explicit-symbolic modelling to IF models. First, we describe the main components in the language and present some examples of its constructions. Next, we show how those components are em- ployed for generating both explicit and symbolic models. Finally, we combine explicit and symbolic models in order to emulate the behavior of the original model by means of the explicit-symbolic model.

The Modelling Language
System specifications consist of generic components, including dynamic ones such as processes, signal routes and signals, and static ones such as variables, data types, constant values and external procedures. Formally, a system is given as a tuple (D, S, P ), where D is the set of data types including Boolean, integer, clock, pid and user-defined ones, S is the set of typed signals and P is the set of process types. In figure 1, we show some of those elements composing an IF specification for the alternate bit protocol.



system bitalt;
type data = range 0..1; signal ack(boolean);
...
process transmitter(1);
...
endprocess;
...
endsystem;

(a)
process transmitter(1); var b boolean;
...
state start #start; task b := false;
nextstate idle; endstate;
...
endprocess;

(b)

Fig. 1. Intermediate Format system (a) and process (b) examples.
Processes are defined as extended finite-state machines. Each process in- stance has a unique identifier number and an input FIFO buffer storing all the incoming messages. Process specifications include the set of local variables, which correspond to the local memory, and the set of control states. Data types, constants and procedure definitions may also be included. Formally, each process is viewed as a tuple (Q, X, T, q0) ∈ P , where Q is the set of con- trol states, X is the set of typed variables, T is the set of transitions and q0 ∈ Q is the initial state. Note that X includes both local and global variables.
Control states define the behavior of a process by means of actions, tran- sitions to other states and, possibly, substates. There is not theoretical limit for the number of nested substates. State specifications include temporal con- straints and the set of deferred signals. The initial state is defined by the keyword #start during the state definition. Because model checkers need to keep track of the current state being visited, our explicit-symbolic model uses a variable for storing such information. From now on, we refer to such variable as the program counter.
Transitions between states are controlled by condition guards. So, transi- tions can be viewed as process reactions in response to stimuli. Transition can be triggered by the activation of some untimed guard, activation of some timed guard or the presence of some signal in the input buffer of the process instance. When a condition guard is satisfied, some actions may be required before pass- ing the control to another state. Actions include variable assignments, clock setting, clock and variable resetting, signal sending, procedure calls, creation and destruction of processes and signal routes. Transitions can also be used with a stop action, which means the destruction of the process instance. In a generic way, a condition guard g is defined as an expression over system variables, that is, g ∈ 2X. Untimed guards are implemented through provided clauses, composed of constants, variables and Boolean, arithmetic and rela- tional operators. Timed guards are implemented through when clauses, which control time constraints on clock variables. Finally, the presence of signals in the input buffer is implemented through input clauses. All signals share one queue per process instance and, therefore, an input clause gets blocked when



state q8;
...
provided c = b;
...
nextstate idle;
...
endstate;

(a)
state busy;
input ack(c); nextstate q8;
when t = 1;
...
nextstate busy; endstate;

(b)


Fig. 2. Condition guards.

the expected message is in the buffer but it is not the message in the head of the queue. In order to model queues, our explicit-symbolic model adds other variables to X, include those for controlling reading and writing posi- tions. Ultimately, reading and writing position are used to determine success or failure on input clauses. In figure 2, some guards and transitions are shown. The provided clause, figure 2(a), establishes the condition for the execution of the transition from state q8 to state idle. Similarly, the input and when clauses, figure 2(b), establish the conditions for the execution of transitions from state busy to states q8 and busy, respectively. Note that there can be some statements between the guard condition and the transition itself.
Because more than one transition can be enabled at some control state, and all the situations have to be considered at execution, process may have non-deterministic behavior. Execution of individual processes is interleaved.

Generation of Explicit and Symbolic Models
Let M = (D, S, P ) be a system specified in the Intermediate Format. Two independent models, Me = (D, S, Pe) and Ms = (D, S, Ps), must be generated according to the partitioning of M variables into explicit and symbolic par- titions, Xe and Xs, respectively. Considering each process (Q, X, T, q0) ∈ P , the variable partitioning induces the explicit process (Qe, Xe, Te, q0e) ∈ Pe and the symbolic process (Qs, Xs, Ts, q0s) ∈ Ps. Given each process (Q, X, T, q0) ∈ P , its control states and respective guards must be analyzed. Guards, actions and transitions performed over Xe variables are projected in the model Me,
g a 
while those over X  variables are projected in the model M . Let q	q' ∈ T
s	s	−−→
be a transition of (Q, X, T, q0) ∈ P , where q ∈ Q is the source state, g ∈ 2X is a Boolean guard, a is an action, q' ∈ Q is the target state. Such transition af- fects variables both in Xe and Xs, where those variables represent the program
counter, condition guards and actions. Because both models are affected, the original transition induces one explicit transition and one symbolic transition:

q ge ae	'
gs as  '

e−−−→ qe ∈ Te	and	qs−−−→qs ∈ Ts


such that ge = g|X , ae = a|X , qe and q' ∈ Qe, gs = g|X , as = a|X , qs e q' ∈
e	e	e	s	s	s
Qs, where Qe = Q|Xe , Qs = Q|Xs . The initial states in Me and Ms are those
projected by the original initial state q0, that is q0e = q0|Xe and q0s = q0|Xs . Remember that such explicit and symbolic transitions must be associated to each other.
The Explicit Transition Relation
The explicit transition relation should be represented as an array of linked lists where one array entry corresponds to one state and the linked list defines to which states the current state can transition to:
Te(Qe, Q' ) =(qe , L1), (qe , L2), ...
e	1	2

where Li = q'
'
ei2
'
ei3
, ... For example, this transition relation defines tran-

sitions between states (qe1
'
e11
), (qe1
'
e12
) and so on.

The Symbolic Transition Relation
The symbolic transition relation should be represented as a formula between propositions in the current and in the next state, Ts(Qs, Q' ), to be imple-
mented using BDDs.
Generation of the Combined Explicit-Symbolic Model
The partitioning of system variables induces the generation of distinct explicit and symbolic models. Each generated model covers just a subset of variables and investigates only part of the search space. Such models have to be ex- ecuted in an interleaved fashion in order to allow us to explore the whole search space and emulate the behavior of the original system. Due to effi- ciency questions, we propose a new way of associating transitions. Instead of using the transition labels defined in the modelling, the explicit and symbolic models are interleaved by associating symbolic transitions to explicit transi- tions. Given Me = (D, S, Pe) and Ms = (D, S, Ps), the explicit-symbolic model Mh = (D, S, Ph) is obtained as shown below. For each (Qh, Xh, Th, q0h) ∈ Ph, we combine explicit and symbolic representations by introducing a symbolic transition for each explicit transition:
Th(Qh, Q' ) =(qe , L1), (qe , L2), ...
h	1	2
where Li = (q' , Ts ), (q' , Ts ), (q' , Ts ), ... and Ts  = Ts (Qs, Q' ). Graph-

ei1	i1
ei2	i2
ei3	i3
ij	ij	s

ically each (qe , Li) ∈ Th(Qh, Q' ) can be represented as shown in figure 3. Ac-
i	h
cording to this explicit-symbolic model, first we explore states in the explicit
model and then states in the symbolic model. Intuitively Tsij  represents the



symbolic transition from qsi
'
sij
associated to the explicit transition from qei

to q' . Such transitions define the explicit-symbolic transition from (qe , qs )
eij	i	i

to (q'
'
sij
), both in Qh. So, Qh corresponds to the set of pairs (qe, qs) asso-

ciated by the explicit-symbolic transition relation Th, where qe ∈ Qe, qs ∈ Qs.
Consequently, Xh = Xe ∪ Xs and q0h = (q0e, q0s).



Fig. 3. Explicit-Symbolic Transitions
The explicit and symbolic models can be obtained from the explicit-symbolic model in a straightforward way. Because each qh ∈ Qh corresponds to one pair (qe, qs), where qe ∈ Qe and qs ∈ Qs, one explicit-symbolic state is associated to exactly one explicit and one symbolic state. Regarding the transition relation
Th(Qh, Q' ) = (qe , L1), (qe , L2), ..., (qe , Ln), each pair (qe , Li) corresponds
h	1	2	n	i
'
to explicit transitions from qei to every explicit state q	in the pairs of Li,
where Li = (q' , Ts ), (q' , Ts ), (q' , Ts ), ... as above. Similarly, the sym-
i1	i2	i3
'
bolic transition relation can be obtained by ∪Tsij , where (q	, Tsij ) ∈ Li.
Model-Checking Algorithms
Our algorithms assume the system properties are given in Computation Tree Logic, CTL for short. CTL is an important branching temporal logic with a discrete notion of time. CTL is sufficiently expressive for the formulation of an important set of system properties, allowing safety, liveness, fairness and deadlock freedom to be specified. For details regarding the semantics of CTL, please refer to [10].
Let Φ be a CTL specification over a model M. According to the definition, Φ is either given by an atomic proposition ap or it is composed of temporal- logical operators applied to CTL subformulae:
Φ ::= F alse | True | ap | (¬Φ) | (Φ ∧ Φ) | (Φ ∨ Φ) | (Φ → Φ) |
AXΦ | EXΦ | A[ΦU Φ] | E[ΦU Φ] | AGΦ | EGΦ | AF Φ | EF Φ


where the new connectives AX, EX, AU , EU , AG, EG, AF and EF are called temporal connectives. Assume that Φ is given in a structural represen- tation by means of a parsing tree. In such a parsing tree, the leaves stand for atomic propositions, represented either in the explicit model or in the symbolic model, while internal nodes stand for explicit-symbolic expressions, represented in the explicit-symbolic model. First, algorithms convert both explicit and symbolic states into corresponding explicit-symbolic states. After that, algorithms handle sets of input and output explicit-symbolic states.
Atomic Propositions
During the parsing of atomic propositions, we must consider two different situations. First, the atomic proposition ap can be explicit, being represented in an explicitly coded state. Second, ap can be symbolic, being represented by a BDD. Independently of the situation, inputs must produce a set of explicit- symbolic states S.
Explicit Propositions
Consider the proposition ap ∈ Xe. First, the algorithm determines the set of explicit states E where ap holds. Next, for each qei ∈ E it determines symbolic states, represented by qsi , that compose a valid explicit-symbolic state (qei, qsi ).
01 S ← ∅ 
E ← {qe ∈ Qe|qe |= ap}
for each qei ∈ E do
for each Tsij where (qei , Li) ∈ Th and (qej , Tsij ) ∈ Li do 05		add (qei , qsi ) to S where Tsij = qsi ∧ qsj

Symbolic Propositions
Consider the proposition ap ∈ Xs. First, the algorithm determines the BDD qsi that represents the set of symbolic states where ap holds. After that, it visits the explicit transition relation looking for symbolic transitions Tsij  =
'	'
qsi	, for some q	∈ Qs. For each Tsij found, the algorithm creates an
explicit-symbolic state (qei , qsi ), where (qei, qej ) is the explicit transition asso- ciated to Tsij .
01 S ← ∅ 
qsi ←Qs|ap
for each qei ∈ Qe do
for each Tsij where (qei , Li) ∈ Th and (qej , Tsij ) ∈ Li do 05		if (Tsij ∧ qsi ) /= false then
begin
add (qei ,qsi ) to S



break
end
Note that the algorithms above only include an explicit-symbolic state (qei, qsi ) into results if qei and qsi hold simultaneously in the explicit and symbolic models, respectively. Specifically, the inner loops ensure that states qei and qsi are associated to each other. Smaller sets of states require less memory and improve the performance of the search. Additionally, as many symbolic variables as possible must be explored before passing to the exploration of explicit variables in order to reduce the cost of combining the explicit and the symbolic models. In other words, we should explore each underlying model as much as possible before exploring the counterpart model.

Explicit-Symbolic Expressions
The following algorithms assume that initial expressions have been used to produce explicit-symbolic states. Each algorithm takes sets of input explicit- symbolic states I1 and I2 and produces another set of explicit-symbolic states
S. Because temporal-logical operators ¬, ∨, EX, EU and EG can be used to define the remaining CTL operators, we restrict our discussion to such basic operators.


Negation
Given an expression ϕ represented by the set of input states I1, the algorithm produces the set of output explicit-symbolic states S where ¬ϕ holds. For each explicit state qei ∈ Qe, if (qei, qsi ) is in I1 for some qsi ∈ Qs , the algo- rithm produces the complement for the symbolic state, ¬qsi , and checks if it composes a valid pair with the explicit state qei . If so, the pair (qei , ¬qsi ) is added into S. On the other hand, if (qei, qsi ) is not in I1 for some qsi ∈ Qs, the algorithm adds all the valid pairs (qei , qsi ) to S. In other words, the algorithm replaces the current set of valid explicit-symbolic states by its complement.
01 S ← $ 
for each qei ∈ Qe do
if (qei , qsi ) is in I1 for some qsi ∈ Qs then 04		begin
if (Tsij л чqsi ) /= false and (qei , чqsi ) ∈/ I1 then
add (qei , чqsi ) to S where (qei , Li) ∈ Th, (qej , Tsij ) ∈ Li
end
else
for each Tsij where (qei , Li) ∈ Th and (qej , Tsij ) ∈ Li do
10	add (qei , qsi ) to S where Tsij = qsi л qsj


Disjunction
Given that ψ and γ are represented by set of input explicit-symbolic states tables I1 and I2 respectively, the algorithm produces the set of output explicit- symbolic states S where ψ ∨ γ holds. First, the explicit-symbolic states in I1 are stored in S. Next, explicit-symbolic states in I2 are also copied to S. Explicit-symbolic states with shared explicit states are merged by performing the disjunction of their symbolic states.
01 S ← $ 
for each pair (qe, qs) of I1 do 03		add (qe, qs) to S
for each pair (qe, qsi ) of I2 do
if (qe, qsj ) ∈ S for some qsj ∈ Qs then
replace (qe, qsj ) with (qe, qsj ∨ qsi ) in S
else
add (qe, qsi ) to S



EX(ϕ)
Given that ϕ is represented by the set of input explicit-symbolic states I1, the algorithm produces the set of output explicit-symbolic states S where EX(ϕ) holds. For each explicit-symbolic state (qej , qsj ) in I1, first the algorithm computes the set of predecessors E for the explicit component qej . After that, for each qei ∈ E it computes the predecessor qsi for the symbolic state qsj , restricted to Tsij , and adds (qei, qsi ) to S.
01 S ← $ 
for each pair (qej , qsj ) of I1 do 03		begin
E ← {qe|∃(qe, qej ) ∈ Te}
for each qei ∈ E do 06		begin
qsi ← EXsymb (Tsij , qsj )
if (qsi /= false) then
begin
if (qei , qsk ) is in S for some qsk ∈ Qs then
replace (qei , qsk ) with (qei , qsk ∨ qsi ) in S
else
add (qei , qsi ) to S
end
end
end
Note that EXsymb(Tsij , qsj ) produces the predecessors of qsj over the symbolic transition Tsij , where Tsij is the symbolic transition associated to the explicit transition from qei to qej . This restriction guarantees that the explicit transi- tion (qei , qej ) and the symbolic transition (qsi , qsj ) occur simultaneously in the explicit and symbolic model, respectively.

E(ψU γ)
Given that ψ and γ are represented by sets of input explicit-symbolic states I1 and I2 respectively, the algorithm produces the set of output explicit-symbolic states S where E(ψU γ) holds. The algorithm computes E(ψU γ) determining states where γ holds and looking backwards for states where ψ holds, until converging to the greatest set where E(ψU γ) holds.
01 S ← $ 
for each pair (qe, qs) of I2 do 03		add (qe, qs) to S
do
continue ← false
Aux ← EX(S)
for each pair (qe, qs) of Aux do
if ((qe, qs) is not in S and (qe, qs) is in I1) do
begin
add (qe, qs) to S
continue ← true
end
while (continue)
Because E(ψU γ) holds in states where γ holds, first the algorithm adds states of I2 to S. After that, it computes the predecessors of states in S, named Aux, using the previously EX algorithm defined over explicit-symbolic states. States of Aux, included in I1 and not yet in S, are added to S. The procedure finishes when no state is included in S in the loop spanning lines 06-11.

EG(ϕ)
The explicit-symbolic algorithm for EG(ϕ) is adapted from the traditional al- gorithm for the explicit EG. The explicit EG(ϕ) is computed over a modified state graph where all states at which ϕ does not hold are deleted and the transition relation is restricted accordingly. After that, the explicit version of the algorithm is based on the computation of strongly connected compo- nents (SCCs). In the explicit-symbolic version, the original state graph must be modified so that the relevant states are those where both the explicit and the symbolic components of the state hold. Because formulas are given in a structural representation being computed from elementary sub-formulas to the more complex ones in bottom-up fashion, the set of relevant states for the computation of EG over the explicit-symbolic model corresponds to the set I1 of input explicit-states given by ϕ. So, initially we have to eliminate from the explicit-symbolic state graph all the states not found in I1. In the explicit- symbolic state graph, the information about symbolic states is recorded by means of the symbolic transitions associated with explicit transitions, so the determination of the symbolic states require additional computation to exis- tentially quantify out the next state variables from the symbolic transition.

The algorithm below is used for computing the set of output explicit-symbolic
'
states S where EG(ϕ) holds. Note that Xs stands for the set of next state
symbolic variables.
for each qe ∈ Qe do
'
if (qe, qs) ∈/ I1 for all qs ∈ ∃X (Ts), where (qe, L) ∈
'
Th,(qe, Ts) ∈ L
eliminate qe from the state graph
'
SCC ← {C|C is a nontrivial SCC of Th}

S ←
'
C∈SCC {(qe, qs)|(qe, L) ∈ Th, (qe, Ts) ∈ L, qs = ∃Xs(Ts)}

S ← ∅ 
'

while (S
begin
'
/= S) do

S ← S
'	'
for each (qe, qs) where (qe, L) ∈ Th,(qe, Ts) ∈ L,qs =
∃Xs(Ts) do
if (qe, qs) ∈/ S then
add (qe, qs) to S
end
The loop spanning lines 01 − 03 in the algorithm above is used to generate the
'
modified state graph where ϕ holds, Th. For each explicit state qe, the loop
looks for symbolic transitions Ts associated with some explicit transition where
qe is the current state. Line 02 computes the set of current symbolic states
'	'
where transitions of Ts come from, ∃Xs(Ts). If there exists some qs ∈ ∃Xs(Ts)
such that (qe, qs) belongs to I1, qe is maintained on the explicit-symbolic state graph. Otherwise, qe is eliminated from the state graph. After that, line 04 computes the nontrivial strongly connected components considering only the
'
explicit transitions of Th . Such a computation can be adapted from the algo-
rithm of Tarjan [18], for example. Next, line 05 adds all the explicit-symbolic states belonging to the strongly connected components into the solution S. Finally, lines from 06 to 13 are used for finding all of those states that lead to states in S.

The Microwave Oven Model
In this section, we present an example in order to clarify the generation of the explicit-symbolic model and the application of related techniques and algorithms. Although we have mentioned the alternate bit protocol in our previous discussion about the modelling language, for didactic reasons we il- lustrate the model checking on a small example that describes the behavior of a microwave oven, taken from [11].

Decomposition of the Microwave Oven Model
Assume that the behavior of the microwave oven is modeled by the process (Q, X, T, q0), given by the Kripke structure shown in figure 4, where the set of states Q is represented by ellipses, the set of variables X is represented by propositions shown within ellipses, that is X = {start, close, heat, error}, the transition relation T is represented by arcs and qo = S1. For clarity, each state is labeled with both the atomic propositions that are true in the state and the negations of the propositions that are false in the state. Labels on the arcs indicate the actions that cause transitions but are not part of the Kripke structure.

Fig. 4. The microwave oven model.

Suppose that the set X is decomposed into subsets of explicit and symbolic propositions Xe = {start, close} and Xs = {heat, error}, respectively. Now, consider the set of states under an special point of view where only explicit propositions matters. Because states with the same set of explicit propositions are not distinct under such explicit point of view, such states are considered the same and are projected as one explicit state. Figure 5 shows the grouping of states considering explicit propositions (a) and the corresponding explicit process (Qe, Xe, Te, q0e) generated (b). Note that we have another set of states, Qe, and another set of propositions composed only of explicit propositions, Xe. The arcs on figure 5(b) correspond to the explicit transition relation Te and have been labeled in order to reveal the original transitions they were projected from. Naturally, qoe = ES1.
The symbolic process (Qs, Xs, Ts, q0s) is generated in a similar manner, by considering the original model under the symbolic point of view. Figure 6



Fig. 5. Grouping of explicit states (a) and corresponding explicit model (b).
presents the grouping of symbolic states (a) and the corresponding symbolic process (Qs, Xs, Ts, q0s)(b).

Fig. 6. Grouping of symbolic states (a) and corresponding symbolic model (b).


Verification on the Explicit-Symbolic Microwave Oven Model
Given the explicit and symbolic models shown in figures 5(b) and 6(b), re- spectively, explicit and symbolic transitions with labels in common should be linked together in order to establish their interdependence during the model checking. This subsection explores the operation of such combined model for


checking CTL expressions. The expression EX(¬close ∨ error) is the expres- sion of interest, because it allow us to explore some of the more important CTL operators. According to the previous partitioning, close ∈ Xe and error ∈ Xs. Note that all the algorithms produce explicit-symbolic states as output.

Finding States Where close Holds
By using the algorithm for processing explicit atomic propositions, line 02, we generate the explicit states where close holds, E = {ES3, ES4}. The loop spanning lines 03-05 generates the set S of explicit-symbolic states where close holds, such that S = {(ES3, SS2), (ES3, SS3), (ES4, SS1), (ES4, SS2), (ES4, SS3)}.

Finding States Where ¬close Holds
By using the negation algorithm over the set of explicit-symbolic states where
close holds, specifically lines 04-07, we generate S = {(ES1, SS2), (ES2, SS1)}.

Finding States Where error Holds
By using the algorithm for processing symbolic atomic propositions, line 02, we have that qsi represents the set {SS1}. Lines 03-09 produce S = {(ES2, SS1), (ES4, SS1)}.

Finding States Where ¬close ∨ error Holds
By using the disjunction algorithm, lines 02-03, we add every state where
¬close holds into the output set. After that, lines 04-08 include states where error holds into the output set, producing S = {(ES1, SS2), (ES2, SS1), (ES4, SS1)}.

Finding States Where EX(¬close ∨ error) Holds
Given the input state set I1 = {(ES1, SS2), (ES2, SS1), (ES4, SS1)}, con- sider that it is processed in the order presented. Each iteration of the outer loop of the EX algorithm considers a specific input explicit-symbolic state. For the first state, (ES1, SS2), the algorithm initially computes the set of pre- decessors E1 for its explicit component, ES1, by using line 04. After that, the loop spanning lines 05-15 computes predecessors of the symbolic component, SS2, by considering only symbolic transitions associated to relevant explicit transitions. The relevant explicit transitions are those from states of E1 to


ES1. Each symbolic predecessor found and its corresponding explicit prede- cessor compose an explicit-symbolic state of S1. Below, we show results from the first to the third and last iteration of the outer loop of the EX algorithm. The set of explicit-symbolic states of the third iteration, S3, are those where EX(¬close ∨ error) holds. Such explicit-symbolic states correspond to the original states {S4, S3, S1, S5, S2}, as expected.

E1 = {ES3}
S1 = {(ES3, SS3), (ES3, SS2)}.

E2 = {ES1, ES4}
S2 = {(ES3, SS3), (ES3, SS2), (ES1, SS2), (ES4, SS1)}.

E3 = {ES2, ES3, ES4}
S3 = {(ES3, SS3), (ES3, SS2), (ES1, SS2), (ES4, SS1), (ES2, SS1)}.

The Explicit-Symbolic Model Flexibility
Our explicit-symbolic model has important differences with regard to the SLAM project. Instead of dealing with a fixed approach, where control-flow and data-flow information must have explicit and symbolic representations, respectively, our approach is more general. The explicit-symbolic model al- lows us to move variables between explicit and symbolic spaces according to any policy. Thus, we can experiment with a variety of combinations and choose the one that best fits the system needs. Consider, for example, systems with data dependent control, that is, systems where the control-flow depends on evaluations of symbolically represented variables. In such cases, we have the opportunity of improving the overall performance by moving those sym- bolic variables to the explicit model, reducing interaction between explicit and symbolic representations. Naturally there are other questions involved, as the dependence between those symbolic variables and the remaining ones, but the proposed explicit-symbolic model can support such configuration whenever it is advantageous. As another example of the generality of the flexibility achieved, our explicit-symbolic model also supports the partitioning of vari- ables accomplished by SLAM. Because the program counter and variables involved in control guards of IF systems determine control-flow information,


it suffices to move such variables to the explicit model in order to achieve a SLAM-like partitioning. Therefore, the explicit-symbolic model offers the possibility of using a more flexible environment to evaluate different represen- tations and choose the one that improves the model-checking procedure.

Final Remarks
In this paper, we proposed a model that combines explicit and symbolic rep- resentations. The conceived explicit-symbolic model considers that explicit and symbolic techniques should be used in an integrated and synchronized fashion, allowing us to have a better exploration of the search space of the modeled systems. Thus, our main contribution is the proposal of a flexible environment for the formal verification of systems. Currently, our efforts are driven to the computational implementation of the explicit-symbolic model and its algorithms, considering systems specified in the Intermediate Format. Such implementation will help us to improve the conceptual model and will make it possible to measure the impact that different representations have over the verification of control and data-flow intensive systems. According to the literature, it seems to be a good choice to represent control-flow explicitly and data-flow symbolically, as done in SLAM. Future experiments will make it possible to have more information to answer this question.

References
Thomas Ball, Rupak Majumdar, Todd D. Millstein, and Sriram K. Rajamani. Automatic Predicate Abstraction of C Programs. In SIGPLAN Conference on Programming Language Design and Implementation, pages 203–213, 2001.
Thomas Ball and Sriram K. Rajamani. Bebop: A Symbolic Model Checker for Boolean Programs. In SPIN, pages 113–130, 2000.
Thomas Ball and Sriram K. Rajamani. The SLAM Project: Debugging System Software via Static Analysis. In Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 1–3, 2002.
Marius Bozga, S. Graf, L. Ghirvu, L. Mounier, and J. Sifakis. The intermediate representation IF. VERIMAG Technical Report, 1998.
G. Brat, K. Havelund, S. Park, and W. Visser. Java Pathfinder - A second generation of a Java model checker. In Workshop on Advances in verification, July 2000.
R. E. Bryant. Graph-Based Algoritms for Boolean Function Manipulation. IEEE Trans. on Computers, pages 677–691, 1986.
Sérgio Vale Aguiar Campos. A Quantitative Approach to the Formal Verification of Real-Time Systems. PhD thesis, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA, USA, September 1996.
William Chan, Richard Anderson, Paul Beame, and David Notkin. Combining constraint solving and symbolic model checking for a class of a systems with non-linear constraints. In Computer Aided Verification, pages 316–327, 1997.


Alessandro Cimatti, Edmund M. Clarke, Fausto Giunchiglia, and Marco Roveri. NUSMV: A new symbolic model checker. International Journal on Software Tools for Technology Transfer, 2(4):410–425, 2000.
E. M. Clarke, E. A. Emerson, and A. P. Sistla.  Automatic Verification of Finite- State Concurrent Systems Using Temporal Logic Specifications. In ACM Transactions on Programming Languages and Systems, volume 8-2, pages 244–263, April 1986.
Edmund M. Clarke, Orna Grumberg, and Doron A. Peled. Model Checking. The MIT Press, 1999.
Edmund M. Clarke, Jeannette M. Wing, Rajeev Alur, Rance Cleaveland, David Dill, Allen Emerson, Stephen Garland, Steven German, John Guttag, Anthony Hall, Thomas Henzinger, Gerard Holzmann, Cliff Jones, Robert Kurshan, Nancy Leveson, Kenneth McMillan, J. Moore, Doron Peled, Amir Pnueli, John Rushby, Natarajan Shankar, Joseph Sifakis, Prasad Sistla, Bernhard Steffen, Pierre Wolper, Jim Woodcock, and Pamela Zave. Formal methods: state of the art and future directions. ACM Computing Surveys, 28(4):626–643, 1996.
Gerard J. Holzmann. The Model Checker Spin. In IEEE Transactions on Software Engineering, volume 23, pages 279–295, May 1997.
K. L. McMillan. Symbolic Model Checking: An Approach to the State Explosion Problem. Phd thesis, School of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania, USA, 1992.
K. L. McMillan. Symbolic Model Checking. Kluwer Academic Publ., 1993.
David Notkin. Symbolic Model Checking for Large Software Specifications. Department of Computer Science and Engineering, University of Washington, 2001.
R. Sebastiani.	Integrating SAT Solvers with Math Reasoners: Foundations and Basic Algorithms, 2001.
Robert Endre Tarjan. Depth-first search and linear graph algorithms. SIAM J. Comput., 1(2):146–160, 1972.
