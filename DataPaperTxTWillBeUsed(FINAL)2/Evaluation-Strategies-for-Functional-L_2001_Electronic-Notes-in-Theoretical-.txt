Electronic Notes in Theoretical Computer Science 57 (2001)
URL:  http://www.elsevier.nl/locate/entcs/volume57.html  16 pages



Evaluation Strategies for Functional Logic Programming



Sergio Antoy 1;2
Computer Science Department, Portland State University
P.O. Box 751, Portland, OR 97207, USA


Abstract
Recent advances in the foundations and the development of functional logic pro- gramming languages originate from far-reaching results on narrowing evaluation strategies. Narrowing is a computation similar to rewriting which yields substitu- tions in addition to normal forms. In functional logic programming, the classes of rewrite systems to which narrowing is applied are, for the most part, subclasses of the constructor-based, possibly conditional, rewrite systems. Many interesting narrowing strategies, particularly for the smallest subclasses of the constructor- based rewrite systems, are generalizations of well-known rewrite strategies. How- ever, some strategies for larger non-con uents subclasses have been developed just for functional logic computations. In this paper, I will discuss the elements that play a relevant role in evaluation strategies for functional logic programming, describe some important classes of rewrite systems that model functional logic programs, show examples of the di erences in expressiveness provided by these classes, and review the characteristics of narrowing strategies proposed for each class of rewrite systems.



1	Introduction

Functional logic programming studies programming languages that join in a single paradigm the features of functional programming and logic program- ming. For the most part, a functional logic program can be seen as a construc- tor-based conditional rewrite system (TRS). In the examples, I take several liberties with the notation.
Example 1.1 The following program solves the well-known N-queens prob- lem:
queens X -> Y :- Y=permute X, void(capture Y)

1 Supported in part by the NSF grants INT-9981317 and CCR-0110496.
2 Email: antoy@cs.pdx.edu
 c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


permute [] -> []
permute [X|Xs ] -> U++[X]++V :- U++V=permute Xs
capture Y :- -++[Y1 ]++K++[Y2 ]++-=Y, abs(Y1 -Y2 )=length K+1
TRSs are rst-order languages, but in this paper the notation for function and constructor application is curried as usual in functional programming. A conditional rewrite rule has the form:
l ! r :  t1 = u1; ::: ; tn = un
where l and r are the left- and right-hand sides, respectively, and the condition is a sequence of elementary equational constraints of the form ti = ui. The symbol \=" is interpreted as strict equality. The program adopts the familiar Prolog notation for lists and variables and uses common in x arithmetic oper- ators, but this is only syntactic sugar. Abs, which stands for integer absolute value, and ++ and length, which stand for list concatenation and length, are assumed to be library functions. Capture is a constraint, i.e., a function that, similar to a Prolog predicate, \succeeds" i its condition succeeds. Void is a primitive construct that succeeds i its argument is a constraint with no solution. A query of the form, e.g., queens [1,2,3,4] non-deterministically computes a solution of the 4-queens problem.
To understand the promise of functional logic programming languages, it is instructive to compare the above program with textbook examples of both functional and logic programs proposed for the same problem. All the pro- grams, including ours, are structured as a generate-and-test pattern. The generator generates a permutation of the rows of the chess-board. The n-th element of the permutation represents the placement on the chess-board of the queen in column n. An eÆcient solution should avoid, e.g., the complete gen- eration of (n 1)! permutations that start with an incorrect initial placement when a single test would suÆce.
The pure logic version [21, pages 132{135] is complicated by the need to generate potential solutions incrementally and test them before generating the next increment. This prevents the use of library predicates, e.g., to compute permutations, and makes the code of this program speci c to this problem and non-reusable. The pure functional version [10, pages 161{165] is complicated both by the presence of data structures, such as a list of lists that (lazily) holds the entire set of permutations, or a list of pairs that eases the test of the safety of a placement, and by the presence of functions that construct and take apart these structures.
The functional logic version is textually shorter and conceptually simpler. For example, generator and tester are functionally nested and lazily executed and there are no bookkeeping and control data structures. Key factors that contribute to this simplicity and are unavailable in either the functional or the logic program are: (1) non-determinism, e.g., operation permute computes one of the many permutations of its argument, (2) semantic uni cation, e.g., the variables in the constraint U++V=permute Xs  are instantiated, if possible, to


satisfy the equation, and (3) functional inversion, i.e., the possibility to com- pute a value for some argument(s) of a function from a result, e.g., the expres- sion -++[Y1 ]++K++[Y2 ]++- is used to extract, lazily and non-deterministically,
sublists from a list rather than to concatenate them.
The increased expressive power of functional logic programs pose heavier demands on their execution. These demands involve two speci c aspects of computations: (1) modern functional logic programs are mostly executed by narrowing, a computation that generalizes both ordinary functional evaluation and resolution and (2) the classes of TRSs modeling functional logic programs are more general than those modeling functional programs, e.g., our initial example includes non-deterministic operations, such as permute, and extra variables, such as U, V and K. In this paper, I discuss some classes of TRSs proposed for functional logic programming and suitable evaluation strategies for these classes. Section 2 reviews narrowing as the computation of functional logic programs. Section 3 de nes and compares various fundamental classes of TRSs proposed to model functional logic programs and, for each class, presents an evaluation strategy. Section 4 brie y discusses some extensions to the previous classes and related issues. Section 5 contains the conclusion.

2  Narrowing

This section brie y recalls basic notions of term rewriting [8,11,17] and func- tional logic programming [13].
A rewrite system is a pair, R = h ; Ri, where  is a signature and R is a set of rewrite rules. Signature  is many-sorted and is partitioned into a set C of constructor symbols and a set F of de ned operations or functions. Term( [ X ) is the set of terms constructed over  and a countably in nite set X of variables. Term(C [ X ) is the set of values, i.e., the set of terms constructed over C and X . Var(t) is the set of the variables occurring in a term t.
A pattern is a term of the form f (t1;::: ; tn), n > 0, where f 2 F and t1;::: ; tn are values. An unconditional rewrite rule is a pair l ! r, where l is a linear pattern and r is a term. Traditionally, it is required that
Var(r)   Var(l). This condition is not imposed here since it appears unnec-
essarily restrictive for functional logic computations. An unconditional TRS, R, de nes a rewrite relation !R on terms as follows: s !p;R t if there exists a position p in s, a rewrite rule R = l ! r with fresh variables and a sub- stitution  with sjp =  (l) and t = s[ (r)]p. The instantiated left-hand side
 (l) of a rewrite rule l ! r is called a redex (red ucible ex pression). Given

a relation !, !
and ! 
denote its transitive closure and its transitive and

re exive closure, respectively.
A conditional rewrite rule is of the form l ! r : c, where l and r are de ned as in the unconditional case and c is a sequence of elementary equa- tional constraints, i.e., pairs of terms of the form t = u. The de nition of the


rewrite relation for conditional TRSs is fairly more complicated than for un- conditional TRSs. The classic approach to conditional rewriting is discussed in [9].
A left-linear, conditional, constructor-based TRS is a good model for a functional or a logic program. Computations are (expressed by) operation- rooted terms ultimately applied to values.
Example 2.1 In programming languages, values are introduced by data type declarations such as:
data bool = true | false
data list a = [] | [a | list a]
and operations are de ned by rewrite rules such as those of Example	1.1.
Identi ers true and false are the familiar Boolean constants. [] (empty list) and [ | ] (non-empty list) are the constructors of the polymorphic type list. Identi er a is a type variable ranging over all types. A value or data term is a well-formed expression containing variables, constants and data constructors, e.g., [x,y] which stands for [x|[y|[]]].
The fundamental computation of functional logic languages is narrowing. A term s narrows to t with substitution , denoted s ; t, if is an idempotent constructor substitution such that (s) ! t. A term s such that (s) is a redex is called a narrex (narr owable ex pression). Traditionally, it is required that the substitution of a narrowing step is a most general uni er of a narrex and a rule's left-hand side. This condition is not imposed here since narrowing with most general uni ers can be suboptimal [6]. A computation or evaluation of a term s is a narrowing derivation s = t0 ; 1 ::: ; n tn = t, where t is a value. Substitution 1 Æ Æ n is called a computed answer and t is called a computed value of s. Computing narrowing steps, in particular narrexes and their substitutions, is the task of a strategy.
Example 2.2 The following rewrite rules de ne the concatenation and the strict equality of the type list. The in x operation \&" is the constraint con- junction. Identi er success denotes a solved constraint. It is explicitly repre- sented in this paper to de ne computations using only rewrite rules, but with an appropriate syntax it could be eliminated from programs. In practice, strict equality would be a built-in operation of a functional logic language run-time system.
[] ++ X -> X	R1
[X|Y] ++ Z -> [X | Y++Z]	R2
[] = [] -> success	R3
[X|Xs ] = [Y|Ys ] -> X=Y & Xs =Ys	R4
success & X -> X	R5
The execution of the program of Example 1.1 requires the solution of con- straints, such as U++V=[2,3,4], which are solved by narrowing. A free vari-


able may have di erent instantiations. Consequently, expressions containing free variables may be narrowed to di erent results. Below is the initial por- tion of one of several possible sequences of steps that solve the constraint, i.e., narrow it to success and in the process instantiates variables U and V. Both the rule and the substitution applied in a step are shown to the right of the reduct:
U++V=[2,3,4] ; [U1 |Us ++V]=[2,3,4]	R2; fU 7! [U1 |Us ]g
; U1=2 & Us++V=[3,4]	R4; fg
; success & Us ++V=[3,4]	Ri; fU1 7! 2g
; Us++V=[3,4]	R5; fg
.
where U1 and Us are fresh variables, and Ri denotes some rule, not shown here, of the strict equality of type integer. This solution instantiates variable U to a list with head 2.
A narrowing strategy is a crucial component of the foundations and the im- plementation of a functional logic programming language. Its task is the computation of the step, or steps, that must be applied to a term. In a constructor-based TRS, a narrowing step of a term t is identi ed by a non variable position p of t, a rewrite rule l ! r, and an idempotent constructor substitution such that t ;p;l!r; s i s = (t[r]p). Formally, a narrowing strategy is a mapping that takes a term t and yields a set of triples of the form hp; l ! r; i interpreted as narrowing steps as de ned earlier.
Example 2.3 Continuing Example 2.2, a good narrowing strategy applied to the constraint U++V=[2,3,4] computes the following two steps: h1; R1; fU 7! []gi and h1; R2; fU 7! [U1 |Us ]gi. The rst step yields a solution with answer U=[] and V=[2,3,4]. The second step was shown earlier.
A narrowing strategy useful for functional logic programming must be sound, complete, and eÆcient. In the next de nitions, t and u denote a term and a value, respectively, and all narrowing derivations are computed by the strategy
subject of the discussion. A strategy is sound i t	u implies  (t) !  u. A

strategy is complete i  (t) ! 
u implies the existence a substitution  6 

such that t	 
u0 with u0 6 u.	Intuitively, both the soundness and the

completeness of a strategy are best understood when the initial term of a derivation is an equational constraint containing occurrences of free variables. In this case, the soundness of a strategy guarantees that any instantiation of the variables computed by the strategy is a solution of the equation, and the completeness guarantees that for any solution of the equation, the strategy computes another solution which is at least as general.
EÆciency is a more elusive property. Two factors a ect the eÆciency of a strategy: (1) unnecessary steps should not be computed, and (2) steps should be computed without unnecessary resources. In both statements, the exact meaning of \unnecessary" is diÆcult to formalize at best. Factor (1) is more


related to the theory of a strategy, whereas factor (2) is more related to its implementation, although the boundaries of these relationships are blurred. The eÆciency of a strategy is somewhat at odds with its completeness. A naive way to ensure completeness is to compute all possible narrowing steps of a term, but in most cases this would be quite ineÆcient since many of these steps would be unnecessary.
Similar to rewriting, di erent narrowing strategies have been proposed for di erent classes of TRSs. Some eÆcient narrowing strategies are extensions of corresponding rewrite strategies, whereas other narrowing strategies have been developed speci cally for classes of TRSs of interest to functional logic programming and do not originate from previous rewrite strategies. Some of these classes and their strategies are the subject of the next section.


3	Classes of TRSs

A key decision in the design of functional logic languages is the class of TRSs chosen to model the programs. In principle, generality is very desirable since it contributes to the expressive power of a language. In practice, extreme power or the greatest generality are not always an advantage. The use of \un- structured" rewrite rules has two interrelated drawbacks: for the programmer it becomes harder to reason about the properties of a program; for the im- plementor it becomes harder to implement a language eÆciently. For these reasons, di erent classes of TRSs potentially suitable for functional logic com- putations have been extensively investigated. Figure 1 presents a containment diagram of some major classes. All the classes considered in the diagram are constructor-based. Rewrite rules de ning an operation with the constructor- discipline [20] implicitly de ne a corresponding function over algebraic data types such as those of Example 2.1. Most often, this is well-suited for pro- gramming, particularly when data types are abstract.
The discussion of this section is limited to rst-order computations al- though higher-order functions are essential in functional, and hence function logic, programming. The following section will relax this limitation. The discussion of this section is also limited to unconditional TRSs. Constructor- based TRSs can be transformed into unconditional TRSs by a transformation that preserves both values and computations without loss of either eÆciency or generality. This also will be addressed in the next section.

3.1	Inductively Sequential TRSs
The smallest class in the diagram of Figure 1 is the inductively sequential TRSs. These are the strongly sequential component of the constructor-based TRSs [14]. Optimal rewrite derivations for the strongly sequential TRSs are executed by the well-know call-by-need strategy [16]. Optimality, in this class, is the property that every step of a call-by-need derivation is needed in the




Fig. 1. Containment diagram of rewrite systems modeling functional logic programs. The outer area, labeled CB, represents the constructor-based rewrite systems. The smallest darkest area, labeled IS, represents the inductively-sequential rewrite sys- tems. These are the intersection of the weakly-orthogonal, labeled WO, and the overlapping inductively-sequential rewrite systems, labeled OIS.

sense that the value computed by the derivation, if it exists, cannot be reached unless the step is executed. Needed narrowing [6] is a conservative extensions of this strategy, i.e., rewrite derivations executed by needed narrowing are call- by-need derivations. In addition, needed narrowing o ers a second optimality result concerning computed answers. Narrowing is non-deterministic, thus a term may have several distinct derivations each computing a substitution and a value. The substitutions computed by these derivations are pair-wise disjoint [6, Def. 15]. This implies that every needed narrowing derivation computing a value is needed in the sense that the substitution computed by one derivation cannot be obtained by any other derivation.
The inductively sequential TRSs were initially characterized through the concept of de nitional tree [2]. Since de nitional trees are frequently used to de ne and implement narrowing strategies for several subclasses of the constructor-based TRSs, I recall this concept. A de nitional tree of an op- eration f is a nite, non-empty set T of linear patterns partially ordered by subsumption and having the following properties up to renaming of variables:
 [leaves property] The maximal elements, referred to as the leaves, of T are all and only variants of the left hand sides of the rules de ning f . Non- maximal elements are referred to as branches.
  [root property] The minimum element, referred to as the root, of T is f (X1;::: ; Xn), where X1;::: ; Xn are fresh, distinct variables.
  [parent property] If  is a pattern of T di erent from the root, there exists in T a unique pattern  0 strictly preceding   such that there exists no other


pattern strictly between  and  0.  0 is referred to as the parent of  and as a child of 0.
 [induction property] All the children of a same parent di er from each other only at the position, referred to as inductive, of a variable of their parent.
Example 3.1 Consider an operation, take, that returns a pre x of a list. For the purpose of this discussion, the natural numbers are represented in Peano notation.
data nat = 0 | s nat take 0 - -> []
take (s N) [] -> []
take (s N) [X|Xs ] -> [X | take N Xs ]
The de nitional trees of operation ++ de ned in Example 2.2 and operation take just de ned are shown below. Lines join patterns in the parent-child relation. The inductive variable of a parent is boxed. The leaves are variants of the rules' left-hand sides.

take	N	X




++ Y
,,,,


,,,
,,


,,,
take 0 X	take (s N1)


[] ++ Y	[X1 |Xs ] ++ Y


,,,,
,,,

take (s N1 ) []  take (s N1 ) [X1 |Xs ]
A TRS is inductively sequential i all its operations have a de nitional tree. Needed narrowing is de ned through de nitional trees that are used as nite state automata to compute narrowing steps. I give an informal account of this computation in an example. The formal de nition is in [6, Def. 13].
Example 3.2 Needed narrowing computes a step of a term t rooted by take, i.e., t = take n x, as follows. Let  be an element of the de nitional tree of take that uni es with t and let  be the uni er. If  is a leaf, then t is a narrex and  is the substitution of the step. If  is a branch and p is the position of its inductive variable, then tjp is rooted by some operation f . Using a de nitional tree of f , the strategy computes a needed step of (tjp), say hq; l ! r; i. Then, hp q; l ! r; Æ i is a needed step of t.
To make all this more concrete, suppose that t = take N ([1]++[2]), where N is a free variable. Term t uni es with both take 0 X, which is a leaf, and take (s N1 ) X, which is a branch. Therefore, needed narrowing computes the two steps shown below. Each steps is shown with its substitution.
take N ([1]++[2]) ;fN7!0g []
take N ([1]++[2]) ;fN7!(s N )g take (s N1 ) [1|[]++[2]]

Observe that the substitution of the second step is not most general. This


characteristic of needed narrowing is a major departure from previously pro- posed strategies. Unless N is instantiated to (s N1 ), the step could turn out to be useless, e.g., when followed by a step instantiating N to 0.

3.2	Weakly Orthogonal TRSs
The weakly orthogonal TRSs are a proper superclass of the inductively se- quential TRSs. Rewrite rules in this class can overlap, but only if their corre- sponding critical pairs are trivial (syntactically equal). Rules's left-hand are patterns and consequently they can overlap only at the root. Therefore weakly orthogonal constructor-based TRSs are almost orthogonal. Computations in this class are sometimes referred to as parallel, and so implemented, although this class admits sequential normalizing rewrite strategies, as well. Optimal rewrite derivations for the weakly orthogonal constructor-based TRSs are ex- ecuted by repeatedly contracting all the redexes of a necessary set [22]. This notion generalizes that of needex redex, which is unde ned in this class. Opti- mality, in this class, is the property that the value computed by a derivation, if it exists, cannot be reached unless one redex in a necessary set is contracted. In general, no eÆcient procedure is known to determine this redex.
Example 3.3 An emblematic non-inductively sequential operation in this class is the parallel-or de ned by the rules:
or true - -> true	R6
or - true -> true	R7
or false false -> false	R8
Term or (or true u) (or v true) has no needed redex regardless of terms u and v.
Weakly needed narrowing [5] is a conservative extension of the strategy de ned in [22]. This strategy is formulated by means of de nitional trees as well.
The rewrite rules de ning an operation in a weakly orthogonal TRSs can be partitioned into inductively sequential subsets, i.e., subsets for which there exists a de nitional tree. For the rules of Example 3.3, one such partition is fR6; R8g] fR7g. Then, a necessary set of redexes is obtained by computing a needed redex for each element of a partition. This rewrite strategy, formalized in [2], is equivalent to [22]. Its extension to narrowing is straightforward, but the properties of a necessary set of narrexes di er from those of a necessary set of redexes. The narrowing step computed by an element of the partition of the rewrite rules may have a substitution incompatible with that of another step and/or the position of a step may not be disjoint from that another step. Neither condition may occur for rewrite steps.
Several related narrowing strategies dealing with these conditions are dis- cussed in [5], but none claims the strong optimality results of [22]. However, all these strategies are optimal for rewrite derivations, since they compute the


same steps as [22].

3.3	Overlapping Inductively Sequential TRSs
The overlapping inductively sequential TRSs are a proper superclass of the in- ductively sequential TRSs. They are incomparable with the weakly orthogonal TRSs. Rewrite rules in overlapping inductively sequential TRSs can overlap, but only if their left-hand sides are equal modulo a renaming of variables. By contrast to the weakly orthogonal TRSs, no restriction is placed on the right-hand sides of overlapping rewrite rules. Computations in this class are sometimes referred to as non-deterministic.
Example 3.4 The following operations de ne an alphabet (of digits) and the (non-empty) regular expressions parameterized by a given alphabet. In this context, the (meta)symbol \|" de nes alternative right-hand sides of a same left-hand side.
digit -> "0" | "1" | ... | "9" regexp X ->	X
| "(" ++ regexp X ++ ")"
| regexp X ++ regexp	X
| regexp X ++ "*"
| regexp X ++ "|" ++ regexp	X
The de nition of operation regexp closely resembles the formal de nition of regular expression. Non-deterministic operations contribute to the expressive power of a language. For example, to recognize whether a string, say s, denotes a well-formed regular expression over the alphabet of digits it simply suÆces to evaluate (regex digit = s). For parsing purposes, a less ambiguous de nition that also accounts for the usual operator precedence would be preferable, but these aspects are irrelevant to the current discussion.
The evaluation strategy for overlapping inductively sequential TRSs is INS [3]. This strategy has been formulated for narrowing computations since its incep- tion, i.e., it does not originate from an earlier rewrite strategy. In this class, every term that can be narrowed to a value has a needed narrex. Since there may exist several rewrite rules with the same left-hand side, a narrex may have several replacements. Optimality, in this class, is the property that ev- ery step of an INS derivation is needed in the sense that the value computed by the derivation, if it exists, cannot be reached unless the narrex is con- tracted. However, not every replacement of a needed narrex is needed, hence INS makes needed steps modulo non-deterministic choices. In general, no eÆcient procedure is known to determine which choices of replacements are needed.
Non-deterministic operations require re-thinking some semantic aspects of both evaluation and strategies. For example, the meaning of the \=" operation is generalized to joinability, i.e., t = u means that t and u have a common value


| one out of possibly many. Another relevant issue is the step of a derivation in which a value is eventually bound to a variable. This is a subtle point, since the value bound to the variable needs not be computed at that step. Two practical examples clarify the issue.
Operation queens, de ned in the introduction, has a rule with three oc- currences of variable Y. Variable Y is initially bound to permute X, which may eventually be reduced to one of many values. Replacing each occurrence of Y with permute X and evaluating each occurrence independently would be clearly incorrect. The value of the occurrence returned by operation queens could di er from that tested for safety using operation capture. In this case, the intended behavior, called call-time choice semantics, is to bind the same value to all the occurrences of Y.
Operation regexp, de ned in this section, has rules with two occurrences of variable X. Variable X is initially bound to a term, e.g., digit, which may eventually be reduced to a one-character string of a given alphabet. In this case, however, the intended meaning is opposite. Unless the occurrences of X bound to digit are evaluated independently of each other, some regular expressions would not be generated. In this case, the intended behavior, called need-time choice semantics, is not to bind the same value to all the occurrences of X.
In each case, the intended behavior depends on the program. A functional logic language should allow the programmer to encode in a program the ap- propriate semantics. A strategy for non-deterministic computations should have useful properties, e.g., soundness and completeness, for both semantics.

3.4	Constructor-based TRSs
The constructor-based TRSs are the largest class that has been proposed for modeling functional logic programs. They are a proper superclass of all the other classes discussed previously. Overlapping of rules's left-hand sides is unrestricted, though in constructor-based TRSs it may occur only at the root. No speci c restrictions are imposed on the right-hand sides of overlapping rules.
Example 3.5 The following de nition of operation permute is an alternative to that proposed in the N-queens program. Operation insert does not belong to any of the previously discussed classes of TRSs.
permute [] -> []
permute [X|Xs ] -> insert X (permute Xs) insert X Ys -> [X|Ys ]
insert X [Y|Ys ] -> [Y|insert X Ys ]
An early narrowing strategy for this class is presented in [18]. That strategy is a generalization to narrowing of a rewrite strategy proposed in [1]. The completeness of both these strategies is unknown.


A potential diÆculty of a class as large as the constructor-based TRSs is that outermost rewrite strategies are not normalizing [4], hence outermost narrowing strategies are not complete. All the strategies discussed in the previous sections are outermost, a condition that simpli es reasoning about computations and consequently proving their properties, e.g, completeness and optimality.  For example, consider the evaluation of t = insert u v. One cannot tell whether position 2 of t is needed. In fact, one must evaluate subterm v to apply one rewrite rule of insert, but not apply the other rewrite rule. Both [1] and [18] are demand-driven, rather than needed, strategies which informally means the following. A subterm v of a term t is evaluated if there is a rule R potentially applicable to t that demands the evaluation of v. However, the application of R to t may not be necessary for the whole computation in which t occurs. Demand-driven strategies inspire con dence in their completeness since they try to create the conditions for the application of every possible rewrite rule to a term. They can also be quite ineÆcient when the application of a rule to a term and/or the evaluation of a subterm for the application of a rule are unnecessary.
Very recently, a transformational approach has been proposed [4] for func- tional logic computations in the constructor-based TRSs. This approach transforms a constructor-based TRS, R, into an overlapping inductively se- quential TRS, R0. Computations in R0 are executed by INS which sound, complete and eÆcient. The transformation itself is sound and complete in the following sense. The transformation adds new operation symbols, but no new constructors, to the signature of R0. The change in signature generally creates new steps and new normal forms. However, any term built over the signature of R is evaluated to the same set of values by the rules of both R and R0. Computations executed by INS are optimal with respect to the rewrite rules of R0, but not necessarily with respect to the rewrite rules of R.


4	Related issues

The previous sections have almost entirely neglected some important issues related to functional logic computations. I brie y address these issues in this section. The focus, as in the rest of this paper, is on strategies.
The classes of TRSs discussed earlier are all unconditional. The well-known outermost-fair rewrite strategy, which is normalizing for almost orthogonal TRSs [20], is also normalizing for conditional almost orthogonal TRSs [9]. For the constructor-based TRSs, the results presented earlier about evalua- tion strategies are extended to the conditional case with little e ort. The strategies discussed in Section 3 are based, either directly or indirectly, on de nitional trees. De nitional trees are concerned with the left-hand sides of rewrite rules only. Therefore, strategies de ned through de nitional trees are somewhat independent of whether TRSs are conditional. An approach that takes advantage of this consideration transforms an original conditional TRS


into a target unconditional one without altering the left-hand sides of rewrite rules. In this way, results proved for the target TRS are transferred to the original TRS. This transformational approach is formalized in [4]. In short, the condition of a conditional rewrite rule is moved into the right-hand side by introducing a conditional operation. More precisely, a conditional rewrite rule of the form:


is transformed into:
l ! r :  t1 = u1; ::: ; tn = un

l ! if t1 = u1; ::: ; tn = un then r

where, as expected, the if then binary operation returns its second argu- ment when its rst argument succeeds. The introduction of this new operation generally creates new steps and new normal forms, but not new values. The computations to a value with the transformed rewrite rules remain essentially the same.
A second relevant issue about functional logic programming concerns high- order computations, a cornerstone of functional programming. Higher-order functions, i.e., functions that take other functions as arguments, contribute to the expressive power of a language by parameterizing computations over other computations. A typical example is the function map, which applies some function to all the elements of list.
map - [] -> []
map F [X | Xs ] -> [F X | map F Xs ]
The di erence with respect to previous examples is that the rst argument of map does not evaluate to a value, but to an operation.
The theory of higher-order rewriting is not as advanced as that of ( rst- order) rewriting, thus not as much is known about rewrite strategies for higher- order TRSs. However, the well-known outermost-fair rewrite strategy, which is normalizing for almost-orthogonal TRSs [20], is normalizing also for weakly- orthogonal higher-order TRSs if an additional condition, full extension, is im- posed on higher-order rewrite rules [23]. The theory of higher-order narrowing is even less developed. Similar to the rst-order case, several classes of higher- order TRSs have been proposed for higher-order functional logic computations, e.g., SFL programs [12], applicative TRSs [19], and higher-order inductively sequential TRSs [15]. Di erent approaches have been adopted to prove prop- erties of functional logic computations in these classes. Computations in SFL programs are mapped to rst-order computations by a transformation that extends to narrowing a well-know transformation for higher-order logic com- putations [24]. Computations in applicative TRSs are executed by a calculus that makes inference steps of a granularity ner than narrowing steps. Com- putations in higher-order inductively sequential TRSs are executed using a generalization of de nitional trees.
A signi cant di erence between functional logic computations and func- tional computations is that narrowing is capable of synthesizing functions. In


many cases, functions of this kind would be the result of a top-level compu- tation. For example, solving the constraint:
map X [0,1,2] = [2,3,4]
would return, among other possibilities, the computed answer fX 7! s Æ sg, where s is the constructor de ned in Example 3.1. Most current implemen- tations of functional languages are not equipped to deal with this possibility. When the result of a computation is a function, functional languages report so, but do not identify in any expressive form which function. This design choice would seem to indicate that higher-order results are not particularly interesting, at least in functional programming. Narrowing considerably ex- pands the power of functional evaluations, but the feasibility and usefulness of computing higher-order results has not yet been clearly established.
As in other situations, and for the same reasons, transformational ap- proaches have been proposed for higher-order computations as well. In short, terms with partially applied symbols are transformed into terms built with new symbols introduced for this purpose. Every symbol in a transformed term is fully applied. The original idea [24] is formulated for functional evalu- ation in logic programming, [12] generalizes it to narrowing, and [7] re nes it by preserving type information which may dramatically reduce the size of the narrowing space. These approaches are interesting because they extend non- trivial results proved for rst-order strategies to the higher-order case with a modest conceptual e ort.


5	Conclusion

This paper contains an overview of evaluation strategies for functional logic programs. A program is (seen as) a constructor-based TRSs and an evalu- ation or computation is a rewriting or narrowing derivation to a value | a constructor normal form. Constructor-based TRSs are good models for pro- grams because they compute with functions de ned over algebraic data types. Non constructor-based TRSs are seldom used as programs.
I presented four subclasses of the constructor-based TRSs. Each subclass captures some interesting aspect of computing, such as parallelism or non-de- terminism. Computations in di erent classes are best accomplished by dif- ferent strategies. For each class, I presented a narrowing strategy and, in some cases, the rewrite strategy from which it originates. When presented, the rewrite strategy is normalizing, i.e., it computes the value, if it exists, of a term. In addition, the narrowing strategy is sound and complete, i.e., when used to solve an equation it computes only and all the equation's solutions. All these strategies are also, to varying degrees, theoretically eÆcient. Not surprisingly, as classes get bigger the claims about the eÆciency of strategies used for these classes get weaker.
Finally, I considered two extensions of the constructor-based TRSs which


are important for programming: conditional and higher-order rewrite rules. Evaluation strategies for these extensions are not as well developed as for the ordinary case. Transformations from extended TRSs to ordinary TRSs make it possible to use the strategies presented earlier while preserving many of their most desirable properties.

Acknowledgment

I would like to thank Bernhard Gramlich and Salvador Lucas Alba for inviting me to write this paper for the International Workshop on Reduction Strategies in Rewriting and Programming held in Utrecht, The Netherlands, in May 2001.

References

[1] S. Antoy.	Non-determinism and lazy evaluation in logic programming.	In
T. P. Clement and K.-K. Lau, editors, Logic Programming Synthesis and Transformation (LOPSTR'91), pages 318{331, Manchester, UK, July	1991.
Springer-Verlag.
[2] S. Antoy. De nitional trees. In Proc. of the 4th Intl. Conf. on Algebraic and Logic Programming, pages 143{157. Springer LNCS 632, 1992.
[3] S. Antoy. Optimal non-deterministic functional logic computations. In Proc. of the 6th International Conference on Algebraic and Logic Programming (ALP'97), pages 16{30. Springer LNCS 1298, 1997.
[4] S. Antoy. Constructor-based conditional narrowing. In Proc. of the 3rd International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming (PPDP'01), pages 199{205, Florence, Italy, Sept. 2001.
[5] S. Antoy, R. Echahed, and M. Hanus. Parallel evaluation strategies for functional logic languages. In Proc. of the 14th International Conference on Logic Programming (ICLP'97), pages 138{152. MIT Press, 1997.
[6] S. Antoy, R. Echahed, and M. Hanus. A needed narrowing strategy. Journal of the ACM, 47(4):776{822, July 2000.
[7] S. Antoy and A. Tolmach. Typed higher-order narrowing without higher- order strategies. In 4th Fuji International Symposium on Functional and Logic Programming (FLOPS'99), volume 1722, pages 335{350, Tsukuba, Japan,	11
1999. Springer LNCS.
[8] F. Baader and T. Nipkow. Term Rewriting and All That. Cambridge University Press, 1998.
[9] J. A. Bergstra and J. W. Klop. Conditional rewrite rules: Con uence and termination. Journal of Computer and System Sciences, 32(3):323{362,	1986.


[10] R. Bird and P. Wadler. Introduction to Functional Programming. Prentice Hall, New York, NY, 1988.
[11] N. Dershowitz and J. Jouannaud. Rewrite systems. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science B: Formal Methods and Semantics, chapter 6, pages 243{320. North Holland, Amsterdam, 1990.
[12] J. C. Gonzalez-Moreno. A correctness proof for Warren's HO into FO translation. In Proc. GULP' 93, pages 569{585, Gizzeria Lido, IT, Oct. 1993.
[13] M. Hanus. The Integration of Functions into Logic Programming: From Theory to Practice. The Journal of Logic Programming, 19&20:583{628,	1994.
[14] M. Hanus, S. Lucas, and A. Middeldorp. Strongly sequential and inductively sequential term rewriting systems. Information Processing Letters, 67(1):1{8, 1998.
[15] M. Hanus and C. Prehofer. Higher-order narrowing with de nitional trees. In Proc. 7th International Conference on Rewriting Techniques and Applications (RTA'96), pages 138{152. Springer LNCS 1103, 1996.
[16] G. Huet and J.-J. L evy. Computations in orthogonal term rewriting systems. In J.-L. Lassez and G. Plotkin, editors, Computational logic: essays in honour of Alan Robinson, pages 395{443. MIT Press, Cambridge, MA, 1991.
[17] J. W. Klop.	Term Rewriting Systems.	In S. Abramsky, D. Gabbay, and
T. Maibaum, editors, Handbook of Logic in Computer Science, Vol. II, pages 1{112. Oxford University Press, 1992.
[18] R. Loogen, F. L opez Fraguas, and M. Rodr guez Artalejo. A demand driven computation strategy for lazy narrowing. In Proc. 5th International Symposium on Programming Language Implementation and Logic Programming (PLILP'93), pages 184{200. Springer LNCS 714, 1993.
[19] K. Nakahara, A. Middeldorp, and T. Ida. A complete narrowing calculus for higher-order functional logic programming. In Proc. 7th International Symposium on Programming Languages, Implementations, Logics and Programs (PLILP'95), pages 97{114. Springer LNCS 982, 1995.
[20] M. J. O'Donnell. Computing in Systems Described by Equations. Springer LNCS 58, 1977.
[21] R. A. O'Keefe. The Craft of Prolog. The MIT Press, Cambridge, MA, 1990.
[22] R. C. Sekar and I. V. Ramakrishnan. Programming in equational logic: Beyond strong sequentiality. Information and Computation, 104(1):78{109,	1993.
[23] F. van Raamsdonk. Higher-order rewriting. In Proceedings of the 10th International Conference on Rewriting Techniques and Applications (RTA '99), pages 220{239. Springer LNCS 1631, 99.
[24] D. H. D. Warren. Higher-order extensions to PROLOG: are they needed? In Machine Intelligence 10, pages 441{454,	1982.
