Electronic Notes in Theoretical Computer Science 174 (2007) 75–95	
www.elsevier.com/locate/entcs

Transformation for Refining Unraveled Conditional Term Rewriting Systems
Naoki Nishida 1	Tomohiro Mizutani 2	Masahiko Sakai 3
Graduate School of Information Science Nagoya University
Nagoya, Japan

Abstract
Unravelings, transformations from conditional term rewriting systems (CTRSs, for short) into unconditional term rewriting systems, are valuable for analyzing properties of CTRSs. In order to completely simulate rewrite sequences of CTRSs, the restriction by a particular context-sensitive and membership condition that is determined by extra function symbols introduced due to the unravelings, must be imposed on the rewrite relations of the unraveled CTRSs. In this paper, in order to weaken the context-sensitive and membership condition, we propose a transformation applied to the unraveled CTRSs, that reduces the number of the extra symbols. In the transformation, updating the context-sensitive condition properly, we remove the extra symbols that satisfy a certain condition. If the transformation succeeds in removing all of the extra symbols, we obtain the TRSs that are computationally equivalent with the original CTRSs.
Keywords: unraveling, context-sensitive reduction, membership constraint, program transformation


Introduction
Unravelings are transformations from conditional term rewriting systems (CTRSs, for short) into unconditional term rewriting systems (TRSs, for short) [7]. They are useful for analyzing properties of CTRSs. For example, operational termination
[6] 4 is an important property of CTRSs and it can be guaranteed by termination of the unraveled CTRSs [6,7,13]. The first transformation from CTRSs into TRSs was investigated for normal CTRSs by J.A. Bergstra and J.W. Klop [3]. This concept was revisited as an unraveling by M. Marchiori who discussed its properties such as syntactic ones, termination, modularity, and so on [7]. He also proposed an

1 Email: nishida@is.nagoya-u.ac.jp
2 Email: mizutani@sakabe.i.is.nagoya-u.ac.jp
3 Email: sakai@is.nagoya-u.ac.jp
4 Intuitively, a terminating CTRS is operationally terminating if all reductions that are induced by con- ditional parts and that are needed for deciding whether given terms are reducible, also terminate. It was shown in [6] that operational termination is more practical and suitable notion for CTRS termination than “effective termination [7,13]”.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.048

ρ : l → r ⇐ s1 → t1 ∧ ··· ∧ sk → tk
⇓ U
⎧⎨ l → uρ(s1, x−→),	⎫⎬
⎩	···	uρ(tk, x−→) → r ⎭


unraveling for join CTRSs. E. Ohlebusch proposed an unraveling for deterministic 3-CTRSs to prove termination of logic programs [12]. A variant of Ohlebusch’s unraveling is used in several papers [4,9,10,11].
It is well-known that reductions of CTRSs are much more complicated than those of TRSs. One of the reasons is that the recursive reduction is necessary to evaluate instantiated conditional parts. Unravelings appear to be attractive in or- der to compute reduction sequences of CTRSs. However, in general, they do not maintain either of the two important properties, irreducibility of normal forms of CTRSs (invariance of normal forms) or simulation-completeness. Note that nor- mal forms of all CTRSs are not well-defined. Here, an unraveling is said to be simulation-complete for a CTRS over a signature if both reachability and unreach- ability of terms over the signature are preserved by the unraveling [9,10,11]. Note that simulation-completeness in this paper coincides with “soundness and complete- ness” in [15] but slightly different form computational equivalence [15]. Intuitively, computational equivalence can be considered as “simulation-completeness and in- variance of normal forms”. In general, unravelings are not simulation-complete for arbitrary target CTRSs because the unraveled CTRSs are over approximations of the original CTRSs [7,13]. However, it was shown that the restriction by a par- ticular context-sensitive and membership condition to the rewrite relations of the unraveled CTRSs makes the unraveling for deterministic CTRSs preserve unreach- ability of the original CTRSs, that is, simulation-completeness of the unraveling with respect to the particular context-sensitive and membership reduction [11].
Unravelings are generally done by decomposing each conditional rule to some unconditional rules that are supposed to be used in a fixed order (see Fig. 1). Let ρ be a conditional rewrite rule l → r ⇐ s1 → t1 ∧ ··· ∧ sk → tk in a CTRS R and σ a substitution. The reduction step from lσ to rσ by ρ is simulated by a reduction sequence constructed from the corresponding unconditional rules as follows:

lσ −→
uρ(s1, x−→)σ −→∗	uρ(t , x−→)σ

U(R)  1	1	U(R)  1  1	1

−→	uρ(s2, x−→)σ −→∗
··· 
−→∗
uρ(t , x−→)σ −→
rσ.

U(R)  2	2
U(R)
U(R)  k  k	k
U(R)

The sequence starts from lσ. In the sequence, each extra function symbol uρ, called a U symbol , sequentially checks reachability from siσ to tiσ (in other words,
uρ evaluates the condition si → ti with σ). The sequence ends at rσ after all
i	∗
conditions are evaluated successfully, that is, siσ −→R tiσ.
We are sure that unravelings preserve reachability on terms over the original sig- natures. On the other hand, as described above, the unravelings do not preserve

uρ
j
uρ(t1,... , tm) → r

∪ S, μi

T
=⇒	({ l → rδ }∪ S, μi+1)

where uρ is removable (satisfies the condition Rmc described in Subsection 4.2) and the context-sensitive condition μi is updated to μi+1 with respect to root(r).
Fig. 2. Outline for removing U symbols by the transformation T.

unreachability for all CTRSs because unexpected rewrite sequences are sometimes caused by disobeying the application order of rules whose left-hand sides are rooted with U symbols [7,13]. In order to avoid this, a restriction to the rewrite relations of the unraveled CTRSs is required, which prohibits reducing the following redexes:
(Context-Sensitive) ones that occur strictly below U symbols, except for the first arguments of the U symbols (for instance, redexes in x→iσ), or
(Membership) ones that contain a U symbol in their proper subterms.
In this way, the restriction by the above context-sensitive and membership condition is imposed on the rewrite relations of the unraveled CTRSs to maintain simulation- completeness [11].
In this paper, we try to construct unconditional TRSs (from the unraveled CTRSs) that are simulation-complete for the corresponding CTRSs without the context-sensitive and membership condition. We first improve the unraveling for deterministic CTRSs slightly so that the number of unraveled rules is less than those with the ordinary unraveling. This improvement is done by grouping as many conditions as possible, that can be evaluated in parallel. We then propose a trans- formation that is applied to the unraveled CTRSs, in order to remove as many U symbols as possible from the unraveled CTRSs. Although the improvement is not so a novelty, there are some cases where it helps the transformation to reduce the number of U symbols (see Section 4). Each step of the transformation we propose is based on the “composition” of two rules, and it folds two rules used successively in reduction sequences into one rule (see Fig. 2). We show a certain delicate condition (Rmc in Subsection 4.2) that U symbols to be removed should satisfy to maintain simulation-completeness, and we tighten it to keep an advantage of CTRSs asso- ciated with the let structure of functional programs (Rmc' in Section 6). The “composition” is a rather trivial procedure, but removing U symbols leads to the relaxation of the restriction by the context-sensitive and membership condition be- cause the condition depends on the existence of U symbols. We also show correct- ness of the transformation, and show that the composition of the unraveling and the transformation is also an unraveling. We also show that the transformation pre- serves confluence of CTRSs modulo the reduction strategy by the context-sensitive and membership conditions, on terms over the original signatures.
The transformation does not preserve non-“operational-termination” in all cases where non-“operational termination” means “non-termination or termination with- out operational termination”. This disadvantage makes it impossible to prove opera- tional termination of CTRSs by termination of the corresponding unraveled CTRSs. In order to remove this disadvantage, we need to use a tightened Rmc, that is, Rmc''

in Section 7.
Unfortunately, not all U symbols can be removed, that is, the transformation sometimes fails in removing all U symbols. Nevertheless, we have some advantages even if not all U symbols are removed.
The context-sensitive conditions are sometimes removed.
The transformation helps us to simplify conditional rules.
If we succeed in removing all U symbols, there are the following further advantages.
The context-sensitive and membership conditions disappear.
Confluence of CTRSs is preserved. Accordingly, in order to prove confluence of the CTRSs, we can use several techniques for proving confluence of TRSs.
Irreducibility of normal forms of CTRSs is preserved. This leads us to computa- tionally equivalent TRSs with the original CTRSs.
Thus, the transformation we propose is harmless with respect to simulation- completeness, operational termination and non-“operational-termination” of CTRSs whenever it is based on both Rmc' and Rmc''. The largest advantage of the transformation is that we obtain computationally equivalent TRSs with the original CTRSs if we succeed in removing all U symbols. Even when not all U symbols can be removed, we can obtain simplified CTRSs that are computationally equivalent with the original CTRSs.
The unraveling for deterministic CTRSs is used in the inversion compilers pro- posed in [10,11]. The compilers transform constructor TRSs into CTRSs that com- pute (partial) inverses of functions defined in the TRSs. The compilers then unravel the CTRSs into TRSs whose rules may have extra variables. Since terms represent- ing inverse computation of many-to-one functions may have several normal forms as solutions of the computation, the CTRSs that are intermediate results of the compilers are not always confluent. For this reason, this paper does not assume confluence for CTRSs. The transformation in this paper is sometimes useful for simplifying TRSs obtained by the compilers. We will show an example at the end of this paper.
As another approach to simulation-completeness, it was shown that the unravel- ing for normal CTRSs is simulation-complete for all left-linear normal CTRSs [7]. It was also shown that the unraveling for deterministic CTRSs is simulation-complete for CTRSs if the unraveled CTRSs are either left-linear or both right-linear and non-erasing [9]. The approach in [9] is not applicable to all deterministic CTRSs while that in [11] is so.
This paper is organized as follows. In Section 2, we give notations of term rewriting. In Section 3, we introduce a variant of Ohlebusch’s unraveling on which our approach is based, and we give a notion of simulation-completeness and context- sensitive and membership conditions to preserve simulation-completeness. We also improve slightly the unraveling. In Section 4, we propose a transformation that removes extra function symbols introduced due to the improved unraveling from the unraveled CTRSs. In Section 5, we discuss confluence of CTRSs and the unraveled

CTRSs. In Section 6, we tighten the condition for removing the extra function symbols. In Section 7, we offer some concluding remarks and related works.

Preliminaries
This paper follows the basic notions of term rewriting [2,13]. In this section, we outline the basic notations.
Through this paper, we use V as a countably infinite set of variables. The set of all terms over a signature F and V is denoted by T (F, V). The set of all variables appearing in either of terms t1,... , tn is represented by Var(t1,... , tn). The identity of terms s and t is denoted by s ≡ t. For a term t and a position p of t, the notation t|p represents the subterm of t at p. The function symbol at the root position ε of t is denoted by root(t). The notation C[t1,... , tn]p1,...,pn represents the term obtained by replacing  at position pi of an n-hole context C with term ti for 1 ≤ i ≤ n. The domain and range of a substitution σ are denoted by Dom(σ) and Ran(σ), respectively. The application σ(t) of σ to t is abbreviated to tσ. The composition σθ of substitutions σ and θ is defined as σθ(x) = θ(σ(x)).
An (oriented) conditional rewrite rule over a signature F is a triple (l, r, c), denoted by l → r ⇐ c, such that the left-hand side l is a non-variable term in T (F, V), the right-hand side r is a term in T (F, V), and the conditional part c is in form of s1 → t1 ∧ ··· ∧ sn → tn (n ≥ 0) of terms si and ti in T (F, V). In particular, the conditional rewrite rule l → r ⇐ c is said to be an (unconditional) rewrite rule if n = 0, and we may abbreviate it to l → r. We say that a binary relation ~ and a substitution σ satisfy the conditional part c, written by c(σ, ~), if siσ ~ tiσ for 1
≤ i ≤ n. We denote l → r ⇐ c with a unique label ρ by ρ : l → r ⇐ c. To simplify notations, we may write labels instead of the corresponding rules. For a conditional rewrite rule ρ : l → r ⇐ c, variables occurring not in l but in either r or c are called extra variables of ρ. The set of all extra variables of ρ is denoted by EVar(ρ).
Let R be a finite set of conditional rewrite rules over a signature F. The n-level
rewrite relation −→n R of R is defined inductively as follows: −→R = ∅, and −−−→R
0	n+1
= {(C[lσ]p,C[rσ]p) | ρ : l → r ⇐ c ∈ R, c(σ, −→∗	)}. The rewrite relation −→
R
of R is defined as −→R =  n≥0 −→n R. To specify the position p and the rule ρ, we
  
for short) over a signature F is an abstract reduction system (T (F, V), −→R) of
T (F, V) and the rewrite relation of a finite set R of conditional rewrite rules over
F. We use the set R of rules to denote the CTRS (T (F, V), −→R). A CTRS is called a term rewriting system with extra variables (EV-TRS , for short) if it contains only unconditional rewrite rules. Note that rewrite sequences of EV-TRSs can be simulated by narrowing if each extra variable is substituted with a normal form in the rewrite sequences [8]. Specifically, it is a term rewriting system (TRS , for short) if Var(l) ⊇ Var(r) for every rule l → r in it.
A CTRS R is called a 1-CTRS if every rule in R has no extra variable, a 2- CTRS if every rule in R has no extra variable in its right-hand side, a 3-CTRS if for every rule in R all extra variables of the rule appear in the conditional part,

and a 4-CTRS if no restriction is imposed. A conditional rewrite rule ρ : l → r ⇐
s1 → t1 ··· sk → tk is called deterministic if Var(si) ⊆ Var(l, t1,... , ti−1) for 1 ≤ i
≤ k. A CTRS is called normal if every of its rules l → r ⇐ s1 → t1 ∧ ··· ∧ sk → tk satisfies that t1,... , tk are ground normal forms of Ru = { l → r | l → r ⇐ c ∈ R }. We use the notion of context-sensitive reduction in [5]. Let F be a signature. A context-sensitive condition (replacement mapping) μ is a mapping from F to a set of natural numbers such that μ(f ) ⊆ {1,... , n} for n-ary symbols f in F. When μ(f ) is not defined explicitly, we assume that μ(f ) = {1,... , n}. The set Oμ(t) of replacing (active) positions of a term t is defined inductively as follows: Oμ(x)
= ∅ if x ∈ V, and Oμ(f (t1,... , tn)) = {ip | f ∈ F,i ∈ μ(f ),p ∈ Oμ(ti)}. The
context-sensitive reduction of an EV-TRS R with μ is defined as −→(R,μ) = {(s, t) |

s −→p
t, p ∈ Oμ(s)}. An abstract reduction system (T (F, V), −→
(R,μ)
), denoted by

(R, μ), is called a context-sensitive reduction system (CS-TRS ).
In this paper we use a simple variant of membership-conditional systems [16]. For an EV-TRS R, the membership-conditional reduction of −→R by a membership condition ∈ T (where T ⊆ T (F, V)) is defined as −−→R = {(C[lσ]p,C[rσ]p) | l → r ∈ R, Ran(σ) ⊆ T }. The membership-conditional reduction for −→(R,μ) is defined similarly as −−→(R,μ).
Unravelings for Deterministic CTRSs
In this section, we first introduce a variant UO of Ohlebusch’s unraveling [12] for deterministic CTRSs and give a notion of simulation-completeness [9,10,11]. Then, we give context-sensitive and membership conditions [11] to preserve simulation- completeness. Finally, we slightly improve the unraveling UO. This improvement is based on the unraveling UN for normal CTRSs [7] and effective in reducing the number of the unraveled rules by the transformation we will show in Section 4 (see an example at the end of Subsection 4.3).
A Variant of Ohlebusch’s Unraveling and Simulation-Completeness
We first define a variant of Ohlebusch’s unraveling [12], which is proposed in
−→
[4,9,10,11]. Here, given a finite set T of terms, we denote by T the sequence of
the elements in T (in some fixed order), and we denote  t∈T Var(t) by Var(T ).
Definition 3.1 Let R be a deterministic CTRS over a signature F. For every conditional rewrite rule ρ : l → r ⇐ s1 → t1 ∧ ··· ∧ sk → , let |ρ| denote the number of conditions in ρ (that is, |ρ| = k), and we need k “fresh” function symbols
uρ,... , uρ, called U symbols, in the transformation. Here, the word “fresh” means
1	ρ k
that ui /∈ F for 1 ≤ i ≤ k. We transform ρ intoa set UO(ρ) of k + 1 unconditional rewrite rules as follows:
UO(ρ)= { l → uρ(s1, −X→), uρ(t , −X→) → uρ(s , −X→), ··· , uρ(t , −X→) → r }.

1	1	1  1	1
2  2	2
k  k	k

where Xi = Var(l, t1,... , ti−1) ∩ Var(ti, si+1, ti+1,... , sk, tk, r) 5 for 1 ≤ i ≤ k.

5 Xi is the set of variables that appear in either l, t1,.. ., or ti−1 and also in either ti, si+1, ti+1,. .. , sk, tk

The system UO(R) =  ρ∈R UO(ρ) is an unconditional EV-TRS over the extended
	
Note that UO(R) is a TRS if R is a 3-CTRS. The revised point from the original definition is Xi.
Next, we give the notion of simulation-completeness that is based on complete- ness of ultra-properties proposed in [7].
Definition 3.2 Let U be a transformation from CTRSs to TRSs, and R be a CTRS over a signature F.

U is said to be R-reachability-preserving (−→∗
R-preserving , for short) for R if U
∗

preserves reachability of R, that is, for all terms s and t ∈ T (F, V), s
−→R t

implies s −→∗
U (R) t.

U is simulation-sound for R if U preserves unreachability of R, that is, for all s

and t ∈ T (F, V), s −→∗
t if s −→∗
U (R) t.

U is simulation-complete 6 for R if U is −→∗
∗
R-preserving and simulation-sound for
∗

R, that is, for all s and t ∈ T (F, V), s −→R t if and only if s −→U (R) t.
We similarly define these properties for the unraveled system U (R).

All proposed unravelings are
∗
−→∗
R-preserving for every target CTRS because

−→R-preserving is a necessary condition that transformations are “unraveling”s. On
the other hand, in general, they are not simulation-sound for all target CTRSs, and hence not simulation-complete. The cause is that the unraveled CTRSs are over approximations of the original CTRSs. In [7], we can find a counterexample against simulation-completeness of UN , UO and Ohlebusch’s unraveling.
A restriction to the rewrite relations of the unraveled CTRSs for avoiding this difficulty on non-“simulation-completeness” of UO was shown in [11], which is done by the following context-sensitive and membership condition:
the context-sensitive condition μ for ρ in Definition 3.1 such that μ(uρ)= {1} for
i
every uρ, and
the membership condition “∈ T (F, V)”.
Let the context-sensitive condition μR for R be defined as μR(uρ)= μρ(uρ). Then,
i	i
we denote the CS-TRS (UO(R), μR) by UOμ(R). We consider UOμ as an unraveling from CTRSs to CS-TRSs.
Theorem 3.3 ([11]) For every deterministic CTRS R over a signature F, UOμ is simulation-complete (with respect to the membership-condition “∈ T (F, V)”), that

is, for all s and t ∈ T (F, V), s −→∗
t if and only if s −−−−∗−−→	t.
∈T (F ,V)  Oμ(R)



−→	−−−−→ −−−−−→	−−−−−−→
or r. In the original definition by Ohlebusch, Xi is the variable sequence “V ar(l), V ar(t1),.. ., V ar(ti−1)”,
and there are a redundancy for computation of terms because all variables are remaining in the argument of uρ even if some of them are not used in the computation of si+1,. .., sk, r.
6 The definition of “simulation-completeness” in [9,10,11] is different from that in this paper, and it does not coincide with “completeness” of ultra-properties. More precisely, “simulation-completeness” in [9,10,11] corresponds to simulation-soundness in this paper. However, discussions on simulation-completeness in those
papers are essentially equivalent because −→∗  -preserving holds for all CTRSs.
R

In the rest of this paper, we assume that the membership condition “∈ T (F, V)” is imposed on reductions.

Improvement of the Unraveling
There is room for improving the unraveling UO. We first explain the intuitive idea of our improvement. The unraveling UO decomposes each conditional rewrite rule ρ having k conditions into k + 1 unconditional rewrite rules that are used to evaluate the conditions in left-to-right order, introducing U symbols (see Definition 3.1). For example, the conditional rewrite rule
ρ1 : f(x, y) → z ⇐ g(x) → w ∧ g(y) → z ∧ h(w, x) → z
is unraveled into the following four unconditional rewrite rules, introducing U sym- bols u1, u2 and u3:
U (ρ )=	f(x, y) → u1(g(x), x, y),	u1(w, x, y) → u2(g(y), w, x),
		
The application order of these rules in reduction sequences corresponds exactly to the order of evaluating the conditions. However, the order between u1 and u2 is not necessary because the first and second conditions g(x) → w and g(y) → z can be evaluated in parallel. The reason is that all the variables x, y used in the evaluation already appear in the left-hand side f(x, y) of the conditional rule ρ1. From this

fact, we can combine u1 and u2 into one symbol u'
as follows:

f(x, y) → u' (g(x), g(y), x)	and	u' (w, z, x) → u3(h(w, x), z).
1	1
Thus, in order to allow simultaneous evaluation of conditions that can be evaluated in parallel, we improve the ordinary unraveling UO so that some conditional rules are decomposed to less unconditional rules. This idea comes from the unraveling UN for normal CTRSs [7]. As shown in the proof of Theorem 3.7 later, this improvement is not so a novelty. However, it is sometimes effective for reducing the number of the unraveled rules by the transformation we will show in Section 4 (see an example at the end of Subsection 4.3).
The idea of the above improvement is formalized as follows.
Definition 3.4 Let R be a deterministic CTRS over a signature F. We consider a conditional rewrite rule

ρ : l → r ⇐  m1
s1,j → t1,j ∧ ··· ∧  mk

sk,j → tk,j 

in R such that Var(si,j) ⊆ Var({l} ∪ T1 ∪ ··· ∪ Ti−1) for all i and j, where Ti
= {ti,1,... , ti,mi }. Note that every deterministic conditional rewrite rule can be expressed like this. For every conditional rewrite rule ρ in the above form, let |ρ|
denote the number of groups of conditions in ρ (that is, |ρ| = k), we need k U symbols uρ,... , uρ. We transform ρ into a set U(ρ) of k + 1 unconditional rewrite
1	k

rules as follows:
⎧⎪

l → uρ(s1,1,... , s1,m  −→

⎪⎨ uρ(t1,1	, t1,m
−→ → uρ(s2,1,... , s2,m  −→

U(ρ)=	1
⎪⎩
1 , X1)	2
.
−→


2 , X2),


Xi = Var({l}∪ T1 ∪ ··· ∪ Ti−1) ∩ Var(Ti ∪ Si+1 ∪ Ti+1 ∪ ··· ∪ Sk ∪ Tk ∪ {r}) for 1 ≤ i ≤ k. The set U(R)=	ρ∈R U(ρ) is an EV-TRS over the extended signature
FU(R) = F ∪ {uρ | ρ ∈ R, 1 ≤ i ≤ |ρ|}.
The set Xi in the above definition plays the role of delivering values to the later conditions; these values are obtained via variables in either l, T1, ··· or Ti−1, and used in either r, Si+1,... , Sk or Ti,... , Tk.
In Definition 3.4, one can freely divide a conditional part into groups of condi- tions that satisfy the variable-occurrence condition. The set U(ρ) is equal to UO(ρ) upto some renaming of U symbols if mi = 1 for every i, and it is equal to UN (ρ) upto the renaming if k = 1. Thus, UO and UN are special cases of U. For the purpose of reducing the number of unconditional rules, this paper assumes that ρ in Definition 3.4 satisfies
Var(si,j) /⊆ Var(l) ∪ Var(T1 ∪ ··· ∪ Ti−2) for 1 < i ≤ k and 1 ≤ j ≤ mi.
Under this assumption, U(ρ) is determined uniquely.
Example 3.5 The conditional rule ρ1 is unraveled by U into
U(ρ )=  f(x, y) → u1,2(g(x), g(y), x),	u1,2(w, z, x) → u3(h(w, x), z),
The transformation U produces three rules while UO does four.
Finally, we show that U preserves simulation-completeness with respect to the context-sensitive membership reduction. Similarly to the case of UO, the context- sensitive condition μρ for ρ in Definition 3.4 becomes as follows:
μρ(uρ)= {1,... , mi} for every uρ.
i	i
Let the context-sensitive condition μR for R be defined as μR(uρ)= μρ(uρ). Then,
i	i
we denote the CS-TRSs (U(ρ), μρ) and (U(R), μR) and by Uμ(ρ) and Uμ(R), re- spectively. Similarly to UOμ, we can consider Uμ as an unraveling from CTRSs to CS-TRSs.
Example 3.6 For U(ρ1) in Example 3.5, the context-sensitive condition μρ1 is spec- ified as μρ1 (u1,2) = {1, 2} and μρ1 (u3)= {1}, and Uμ(ρ1) = (U(ρ1), μρ1 ).
Similarly to other unravelings, U is not simulation-complete for all CTRSs while
U is −→∗	-preserving (the example in [7] is also a counterexample against simulation-
R
completeness of U). However, Uμ is always simulation-complete for R with respect
to −−−−−−→U  (R).
∈T (F ,V)  μ

Theorem 3.7 Theorem 3.3 also holds for Uμ.
Proof. We construct the following rule from ρ in Definition 3.4:
ρ' : l → r ⇐  k	tpm (si,1,... , si,m ) → tpm (ti,1,... , ti,m )
where tpj is a fresh constructor not in F that represents the tuple of j terms
t1,... , tj.	It is clear that ρ' is deterministic and satisfies UO(ρ') = U(ρ') and
ρ'	'	'	'

μρ' (u ) = {1}, and hence UOμ(ρ ) = Uμ(ρ ).  Let R
be a CTRS obtained by

the above transformation of the rules in R. Then, it is clear that −→R = −→R' and
−−−−∗−−→U (R) = −−−−∗−−→U	on terms in T (F, V). It follows from Theorem 3.3
'

∈T (F ,V)  μ
∈T (F ,V)
Oμ(R )

that −→∗
= −−−−∗−−→
∈T (F ,V)  Oμ(R )
on terms in T (F, V). Therefore, we have −→∗
= −→∗

= −−−−∗−−→U
∈T (F ,V)
Oμ(R')
= −−−−∗−−→U  (R)
∈T (F ,V)  μ
on terms in T (F, V).	 

The transformation in the above proof is also adequate for reducing the number of U symbols. However, we proposed U in order to avoid introducing another extra symbols (such as tpj ), and to simply describe the transformation proposed later.
Theorem 3.3 and 3.7 say that UOμ and Uμ are simulation-complete unravelings from CTRSs to CS-TRSs.

Transformation to Remove U Symbols
In this section, maintaining simulation-completeness, we propose a transformation to relax the context-sensitive and membership condition of (U(R), μR). More pre- cisely, the transformation reduces the number of U symbols in U(R), updating the context-sensitive condition. This leads to the relaxation of the condition because the condition depends on the existence of U symbols. Simply speaking, each step of the transformation is based on the “composition” of two rules, and it folds two rules having the same U symbol into one rule, that is, the replacement of l → l'δ and l' → r with l → rδ where root(l') is a U symbol uρ (see Fig. 2 in Section 1). When all U symbols are removed from U(R), we can obtain an unconditional system that works equally for R without the context-sensitive and membership condition. There are some cases where the context-sensitive condition is not necessary even if U symbols are still remaining.

Examples of Removing U Symbols
We first give two examples showing our intuitive idea of the transformation process, that is, the “composition” appears to be attractive for removing U symbols.
Simply speaking, the transformation we will propose is based on the following “composition” of two rewrite rules:
Composition	  S ∪{ l1 → C[l2σ], l2 → r2 }	.
S ∪{ l1 → C[r2σ], l2 → r2 }
We apply it to two rules that are connected by a U symbol uρ (that is, C ≡ 
j
and root(l ) = uρ), and we remove the rule l
2	j	2 → r2 (see Fig. 2). The reason for

removing l2 → r2 is that uρ does not appear in S or l1 → C[r2σ] (no term over the
j	ρ
original signature is reachable to any term containing the U symbol u ) and then
l2 → r2 is no longer necessary.
Let us consider a conditional rewrite rule
ρ2 : f(x, y) → z ⇐ g(x) → w ∧ f(w, y) → z.
This is unraveled by Uμ to (U(ρ2), μρ2 ) where
U(ρ2)= { f(x, y) → u4(g(x), y),	u4(w, y) → u5(f(w, y)),	u5(z) → z }
and μρ2 (u4)= μρ2 (u5)= {1}. The first and second rules are used in order as follows:

f(x, y)σ1 −→ u4(g(x), y)σ1 −→∗
u4(w, y)σ2 −→ u5(f(w, y)σ2) −→∗
u5(z)σ3 −→ zσ3

where yσ1 ≡ yσ2 by the context-sensitive condition. This reduction sequence can be simulated by the rule f(x, y) → u5(f(g(x), y)) as follows:

··· −→∗
f(x, y)σ1 −→ u5(f(g(x), y)σ1) −→∗
u5(f(w, y)σ2) −→∗
u5(z)σ3 −→ zσ3.

From this observation, we can replace the first and second rules f(x, y) → u4(g(x), y) and u4(w, y) → u5(f(w, y)) with the rule f(x, y) → u5(f(g(x), y)), and hence we have
{ f(x, y) → u5(f(g(x), y)),	u5(z) → z }
In a similar fashion, we also remove u5 as follows:
{ f(x, y) → f(g(x), y) }.
The above set of rules contains no U symbol which means the context-sensitive and membership condition is not necessary.
Let us consider the more complicated case of the rule ρ1. This rule is unraveled to U(ρ1) in Example 3.5. Similarly to the previous example, the first and second rules in U(ρ1) are replaced with f(x, y) → u3(h(g(x), x), g(y)), and hence we have
{ f(x, y) → u3(h(g(x), x), g(y)),	u3(z, z) → z }.
At this time, possible reductions at position 2 of u1,2(g(x), g(y), x) must be done at position 2 of u3(h(g(x), x), g(y)). In order to allow these reductions, the context-

sensitive condition μρ1
must be updated as μ'
(u3) = {1, 2}. Since we have only

one U symbol u3, the context-sensitive condition μ'
is ineffective. Here, given an

EV-TRS R, we say that a context-sensitive condition μ is ineffective for R if μ(f )
= {1,... , n} for all n-ary symbols f that may be a U symbol. In this way, by using the above replacements, we succeeded in reducing the number of U symbols from U(R), removing U symbols and updating the context-sensitive conditions.
Fortunately, in the above two examples, folding rules and updating context- sensitive conditions do not entail problems, that is, simulation-completeness is pre- served although we did not concern about it. In the next subsection, we will show a sufficiency of a side condition, named Rmc, for the transformation to preserve simulation-completeness.
Removable U Symbols
In the previous subsection, all replacements preserve simulation-completeness. How- ever, such replacements do not preserve simulation-completeness in all cases. Con-

sider the CTRS R1 = {ρ3}∪ R2 where
ρ3 : f(x, x') → z ⇐ g(x) → y ∧ g(x') → z ∧ g(y) → w ∧ h(w, z) → z
and R2 = { g(a) → b, g(b) → c, h(g(x), g(a)) → b }. The CTRS R1 is unraveled by U and transformed by the “composition” into

R' = R2 ∪
f(x, x') → u6(g(g(x)), g(x')),	u6(w, z) → u7(h(w, z), z),
u7(z, z) → z,

and μ1(u7) = {1}. Moreover, the CS-TRS (R3, μ3) is obtained by applying the “composition” to (R' , μ1) where
R3 = R2 ∪{ f(x, x') → u7(h(g(g(x)), g(x')), g(x'))),	u7(z, z) → z }
and μ3(u7) = {1, 2}. This CS-TRS (R3, μ3) is not simulation-complete for Uμ(R1)

because we have f(a, a)
−→∗
(R3,μ3)
b but not f(a, a)
−→∗
Uμ(R1)
b. The variable z at

position 2 of the term u6(h(y, z), z) should be used only for delivering value. For this reason, this z should not be instantiated by the “composition” with any term
that does not finish being evaluated although z is used in the other position 1.2. This observation brings the following condition Rmc to the transformation as a side condition (see Fig. 2):
(Rmc) if root(r) isa U symbol u, then no variable in Dom(δ) is shared between terms at active and inactive positions (in μi(u) and not in μi(u)) 7 .
In summary, the “composition” preserves simulation-completeness if it is applied to two rewrite rules connected by a U symbol satisfying the above condition Rmc.
Concerning the upper case in Fig. 2, we say that a U symbol uρ is removable from
ρ	ρ	i
{ l → uj (t1δ,... , tmδ), uj (t1,... , tm) → r } ∪ S if Rmc is satisfied.
Transformation for Removing U Symbols
The transformation for removing U symbols is formalized as follows. Given context- sensitive conditions μ and μ', we write μ = μ' if μ(f ) = μ'(f ) for all f .
Definition 4.1 Let ρ be a deterministic conditional rewrite rule over a signature
F. We define pairs (Si, μi) recursively as follows.
(S0, μ0) := (U(ρ), μρ).
Select a removable U symbol uρ from
Si = { l → uρ(t1δ,... , tmδ),	uρ(t1,... , tm) → r }  S 8
j	j
where δ is a substitution, and then let
Si+1 := { l → rδ }∪ S	and	μi+1 := μi.
Moreover, if root(r) is a U symbol u, then update μi+1 as follows:
μi+1(u) := μi(u) ∪{ k | 1 ≤ k ≤ m, r|k ∈ Dom(δ) }.
7 That is, Dom(δ) ∩ “Sk∈μ (u) V ar(tk)” ∩ “Sk/∈μ (u) V ar(tk)” = ∅.
8 These two rules are the only rules in Si which contain uρ.

We define T(Uμ(ρ)) = (Si' , μi' ) where (Si' , μi' )= (Si'+1, μi'+1). For a deterministic CTRS R, we define T(U (R)) = (  R ,	μ ) where T(U (ρ)) = (R , μ ). Note that ρ∈R μρ is well-defined as a mapping because the domains of μρs are disjoint.
Proposition 4.2 At (ii) in Deﬁnition 4.1, both of the following hold:
if root(r) is a U symbol u, then r|p is a variable for all inactive positions p /∈
μi+1(u), and
tpδ ≡ tp ∈ V for all inactive positions p /∈ μi(uρ) 9 .
Proof (Sketch) It is clear that U(ρ) and μρ satisfy the first claim. By definition, all inactive positions p /∈ μi(u) are added to the set μi+1(u) of active positions if variables at the inactive positions are instantiated by δ. From this observation, the first claim holds for all (Si, μi)s.
It follows from the first claim that all terms at inactive positions are variables, that is, tpδ in uρ(t1δ,... , tmδ) is a variable if p /∈ μi(uρ). Therefore, the second
j	j
claim holds for all (Si, μi)s.	 
The above transformation T always terminates because the number of U symbols are finite and a U symbol is removed at every step, that is, i' is at most |ρ|.
Example 4.3 Uμ(ρ1) is transformed by T into T(Uμ(ρ1)) = (R4, μR4 ) where
R4 = { f(x, y) → u3(h(g(x), x), g(y)),	u3(z, z) → z }
and μR4 (u3) = {1, 2}. The membership condition is still necessary for the above system because of the existence of the U symbol u3. On the other hand, the above μR4 is ineffective for R4. Therefore, we succeed in removing the context-sensitive condition, while the membership condition is still necessary.
In general, we have finitely many results of T from an unraveled CTRS because there are possibly some removable U symbols at the second step in Definition 4.1 and then there are non-deterministic choices for selecting U symbols. For example, there are two results of T ◦ Uμ for the conditional rule ρ3. The results are unique if the fourth condition h(w, z) → z is replaced with h(w, z) → v:
' : f(x, x') → z ⇐ g(x) → y ∧ g(x') → z ∧ g(y) → w ∧ h(w, z) → v.
The same is said of T ◦ UOμ. In this way, the result of T is not always unique. We can see that the transformation T does not always succeed in removing all U symbols even if we search all possible results exhaustively. However, it is clear that the number of all possible results is finite. Therefore, one can select the most “favorite” in all results, for instance, one of the results whose number of rules is the least. In this paper, in order to determine T(Uμ(R)) uniquely, we select the uρ at every step of Si, whose index j is the greatest in all removable U symbols of ρ.




9 That is, Dom(δ|Yar(t ,...,t
)) ⊆ (Sk∈μ (uρ) V ar(tk)) \ (Sk/∈μ (uρ) V ar(tk))

Here we give an example showing that U helps T to decrease the number of U symbols more than UO. Consider the rule
ρ4 : f(x, x') → h(y, w) ⇐ g(x) → x ∧ g(g(x)) → y
∧g(x') → z ∧ h(y, z) → w ∧ g(y) → b.
There are two results of T(UOμ(ρ4)) where tree U symbols are remaining. On the other hand, the result of T(Uμ(ρ4)) is unique where two U symbol is remaining. This means that the improvement of UO in Section 3 is sometimes effective for reducing the number of U symbols and for obtaining the unique result of T .

Simulation-Completeness of Transformation
Finally, we show correctness of T, that is, simulation-completeness of T.
Lemma 4.4 Let ρ be a conditional rewrite rule in a deterministic CTRS R over a signature F, (Ri, μi) and (Ri+1, μi+1) (i ≥ 0) be the i-th and i + 1-th intermediate CS-TRSs of the transformation process for T(Uμ(ρ)), respectively, uρ be a remov- able symbol that is removed in the i-th step of the process, Uμ(R \ {ρ}) = (R', μ'),

and s and t be terms in T (F, V). Then s −−−−∗−−→
∈T (F ,V)	i	i
t if and only if s

∈T (F ,V) (Ri+1∪R',μi+1∪μ') t.
Proof (Sketch) Since proving the only-if part is not difficult, we only prove

the if part “s
∗
∈T (F ,V) (Ri+1∪R',μi+1∪μ')
t implies s
∗
∈T (F ,V) (Ri∪R',μi∪μ')
t ”,

by induction on the lexicographic products of the length of the reduction se-

quences
∗
∈T (F ,V) (Ri+1∪R',μi+1∪μ')
and term structure of s.  To simplify the pre-

sentation, we use underlines for active positions, and −−−−−−→(Ri∪R',μi∪μ') and
−−−−−−→(Ri+1 ∪R',μi+1∪μ') are denoted by −→i and −→i+1, respectively.
From the discussion in the proof of Theorem 3.7, we can assume without loss
of generality that uρ(t1δ,... , tmδ) in Definition 4.1 is uρ(t1δ, −X→). Variables in t1
j	j	j
are divided into those in the following three kinds: (i) ones instantiated by δ and
remaining at an active position in μi(u), (ii) ones not instantiated by δ and remaining at an active position in μi(u), and (iii) ones erased by the rule of uρ. From this
observation, we can assume without loss of generality the following:


Ri \ Ri+1 =
j

uρ(f (x, x, x', y), z) → u(s', x, y, z),	u(t', x, y, z) → r'
and

Ri+1 \ Ri = { l → u(s'δ, xδ, y, z),	u(t', x, y, z) → r' }.
	
where δ = {x '→ u, x' '→ u'}, μi(uρ) = μi(u) = {1}, and μi+1(u) = {1, 2}. It follows from Rmc that x /∈ Var(s'). We only show the most critical case. Suppose that
s −→∗ i+1 lσ1 −→i+1 u(s'δ, xδ, y, z)σ1 −→∗ i+1 u(t', x, y, z)σ2 −→i+1 r'σ2 −→∗ i+1 t.
It follows from the membership condition that σ1 and σ2 do not introduce any term having a U symbol, that is, Ran(σ1) ∪ Ran(σ2) ⊆ T (F, V). It follows from the context-sensitive condition that yσ1 ≡ yσ2 and zσ1 ≡ zσ2. By the induction

hypothesis, we have
s −→∗  lσ1,	s'δσ1 −→∗  t'σ2,	xδσ1 −→∗  xσ2,	and	r'σ2 −→∗  t.
Considering the corresponding reduction by −→i, we have to show that the reduction
uσ1 ≡ xδσ1 −→∗	xσ2 that appears in the second argument of u can be simulated

i+1	ρ
'	'	'

in the first argument of u . It follows from x /∈ Var(s ) that s δσ1 ≡ s σ1. Let θ =
{x '→ xσ2, x' '→ u'σ1,y '→ yσ2,z '→ zσ2}. Then, we have

s −→∗
i lσ1 −→i
uρ(f (u, u, u', y), z)σ1 −→∗
uρ(f (xσ2, xσ2, u'σ1, yσ1), zσ1)

≡ uρ(f (x, x, x', y), z)θ −→ u(s', x, y, z)θ ≡ u(s'σ1, xσ2, yσ2, zσ2)
j 		i

−→∗
i u(t'σ2, xσ2, yσ2, zσ2) −→i
r'σ2 −→∗
i t.

Similarly to the above case, we can prove the remaining case that r in Defini- tion 4.1 is not rooted with a U symbol.	 
Theorem 4.5 Let R be a deterministic CTRS over a signature F. For all s, t ∈
T (F, V), s −−−−∗−−→U	t if and only if s −−−−∗−−→	t.
∈T (F ,V)  μ	∈T (F ,V)	μ
From Lemma 4.4 and Theorems 4.5 and 3.7, the composition T ◦ Uμ of the un- raveling U and the transformation T can be considered as a simulation-complete unraveling from CTRSs to CS-TRSs.
Corollary 4.6 Theorem 3.3 also holds for T ◦ Uμ.
If all U symbols are removed, the reductions by R and T(Uμ(R)) are equivalent.
Corollary 4.7 Let R be a deterministic CTRS over a signature F, and (R', μ') = 

T(Uμ
(R)). Suppose that R' has no U symbol. Then, −→
(R' ,μ')
= −→R'
⊆ −→R
⊆ −→+

= −→+
(R',μ')
, and hence −→∗
= −→∗
(R' ,μ')
= −→∗
R' .

It follows from this corollary that the sets of all normal forms of R and of R' are equivalent, and hence R and R' are computationally equivalent.
Consequently, it can be said that in this case a CTRS R can be represented by

a computationally equivalent TRS R', that is, −→∗
= −→∗
R' .

On Confluence of CTRSs and the Unraveled CTRSs
In this section, we discuss relationships between confluence of CTRSs and the un- raveled CTRSs. For the case of UN , it was shown that confluence of left-linear normal CTRSs is preserved by UN [7]. Given an abstract reduction system (A, →) and a set T ⊆ T , we say that (A, →) is confluent on T if for all s, t1, t2 ∈ T , s −→∗
t1 and s −→∗ t2 implies a u ∈ T such that t1 −→∗ u and t2 −→∗ u.
In general, confluence of CTRSs is not preserved by unravelings with respect to the extended signatures. One of the reasons is that irreducibility of normal forms of CTRSs is not always preserved by the unravelings. Consider a normal form t of a confluent CTRS over a signature. The normal form t may be matched with the left-hand side of a conditional rule ρ : l → r ⇐ s1 → t1 whose conditional part is not

satisfied by the matching substitution σ where t ≡ lσ. In this case, however, t be- comes reducible on the unraveled CTRS and then t is reduced to uρ(s1, X→1)σ. Since
ρ	→	1
the condition s1 → t1 is not satisfied by σ, the term u (s1, X1)σ is not reachable
to rσ (or even any terms over the original signature), and hence all terms that are reachable from t on the unraveled CTRS contain a U symbol. When the number of normal forms in such terms is more than one, the unraveled CTRS is not confluent. More precisely, in order to cause such a situation, another rule whose left-hand-side is matched with l and whose conditional part is not satisfied by the matching sub- stitution is required. Thus, we can see that terms containing U symbols prevent the unravelings from preserving confluence of CTRSs. From this observation, as far as terms without U symbols are concerned, confluence of CTRSs is preserved by the unravelings if simulation-completeness is preserved. As described in the previous section, the unraveling Uμ and the transformation T preserve simulation- completeness, and T sometimes remove all U symbols. In such cases, confluence of the systems obtained by T ◦ Uμ coincides with that of the original CTRSs.
Corollary 5.1 Let R be a deterministic CTRS R over a signature F. Then, all of the following are equivalent:
R is confluent on T (F, V),
Uμ(R) is confluent on T (F, V), and
T(Uμ(R)) is confluent on T (F, V).
Let (R', μ')= T(Uμ(R))) and suppose that R' has no U symbol. Then, R is confluent on T (F, V) if and only if R' is.
As long as we know, there are no methods to show confluence of Uμ(R) and T(Uμ(R)) on T (F, V) if U symbols are still remaining. However, in order to decide confluence of R on T (F, V), we can use ordinary techniques for deciding confluence of T(U(μ(R))) on T (F, V) if T removes all U symbols.
Confluence of the unraveled CTRSs Uμ(R) on T (FU(R), V) cannot guarantee confluence of the original CTRSs R on T (F, V). Consider the CTRS
R5 = { f(x, y) → x ⇐ x → d,	g(x) → f(x, a),	g(x) → f(x, b) }.
This CTRS is not confluent on T (F, V) because g(a) is reducible to normal forms
f(a, a) and f(a, b). The CTRS R5 is unraveled to the TRS
U(R )=  f(x, y) → u8(x, x),	u8(d, x) → x,
g(x) → f(x, a),	g(x) → f(x, b).
The TRS U(R5) is terminating and f(a, a) and f(a, b) are joinable to u8(a, a) on
U(R5). Hence U(R5) is confluent on T (FU(R5 ), V).
The method in this paper appears to counter the other approaches to confluence, such as Bergstra and Klop’s method [3]. In fact, the unraveled CTRSs often lose confluence of the original CTRSs as described above. However, the transformation T recovers the confluence that is lost in the process of the unravelings if all U symbols are removed successfully. Therefore, the transformation T is sometimes effective for preserving confluence of CTRSs.

Revisiting the Condition for Removing U Symbols
It is probably impossible to relax the condition Rmc in Subsection 4.2 in maintain- ing simulation-completeness of the unraveled CTRSs. On the contrary, we should tighten Rmc for maintaining a feature of conditional rules associated with efficiency of reductions. Consider the following ML program.
fun twofib 0 = (0,1)
| twofib n = let
val m = twofib (n-1)
in
(#2 m, (#2 m) + (#1 m) )
end;
It is known that the function twofib efficiently computes pairs of two continuous Fibonacci numbers. Such efficiency comes from the let structure, and the first part of the let structure can be considered as a conditional part. From this observation,
the above program is regarded as the following CTRS:


R6 =
⎧⎪⎨
⎪⎩
twofib(0) → tp2(0, s(0)),
twofib(s(n)) → tp2(#2(m), add(#2(m), #1(m))) ⇐ twofib(n) → m,
.

where tp2(t1, t2) denotes the pair of two terms t1 and t2. The second rule is unraveled into the system (R7, μR7 ) where
R  =	twofib(s(n)) → u9(twofib(n)),
7	u (m) → tp (#2(m), add(#2(m), #1(m))),
9	2
and μR7 (u9)= {1}. Under the innermost reduction strategy, efficiency is still alive in (R7, μR7 ). Now, the system (R7, μR7 ) can be transformed by T as follows:
twofib(s(n)) → tp2(#2(twofib(n)), add(#2(twofib(n)), #1(twofib(n)))).
T succeeds in removing all U symbols from (R7, μR6 ). This corresponds to the following ML program.
fun twofib2 0 = (0,1)
| twofib2 n = ( (#1 (twofib2 (n-1))),
(#2 (twofib2 (n-1)))+(#1 (twofib2 (n-1))) );
However, the above ML program loses efficiency.
The let structure provides a facility that bundles the parallel evaluations of terms that are identical into one. For example, twofib2 (n-1) is evaluated once in the first ML program and three times in the second ML program. The advantage of coming from the let structure is lost in the process of T, by instantiating variable m in tp2(#2(m), add(#2(m), #1(m))), whose occurrence is non-linear, with twofib(n). In order to prevent such instantiation in these cases, we must tighten the condition Rmc as follows:
(Rmc') r is linear with respect to Dom(δ).

It is clear that Rmc' implies Rmc. The above condition Rmc' does not cause the target systems to lose the essential advantage of the original CTRSs, such as efficiency that comes from let structure. In order to keep the advantage of CTRSs relative to efficiency of reductions, T should be based not only on Rmc but also on Rmc' even when all U symbols can be removed by T based on Rmc.

Concluding Remarks and Related Works
We firstly show an application of our method. Consider the following rule that is one of the rules automatically generated by the inversion compiler in [11] from the TRS computing multiplication:
ρdiv : div(s(z), s(y)) → tp1(s(x)) ⇐ sub(z, y) → tp1(w) ∧ div(w, s(y)) → tp1(x)
where div and sub compute division and subtraction of natural numbers, respec- tively, and tpi(t1,... , ti) denotes the tuple of i terms t1,... , ti. If we can identify tp1(t) 10 with t, the above rule can be transformed into the following rule in the sense of computing division:

'
div
: div(s(z), s(y)) → s(x) ⇐ sub(z, y) → w ∧ div(w, s(y)) → x.

This rule is transformed by T ◦ Uμ into the following rule:
div(s(z), s(y)) → s(div(sub(z, y), y)).
Using T, we succeeded in removing all U symbols from U(ρ'


), and the above

rule coincides with the rewrite rule s(x) ÷ s(y) → s((x − y) ÷ s(y)) which is a
typical definition of division for natural numbers. This justifies the correctness of the program generated by the compiler relative to the handmade program. This example shows that in some cases, the transformation T may make it possible to obtain a smart unconditional rule that is simulation-complete for the original conditional rule.
Next, we discuss on non-“operational-termination” of CTRSs. Unfortunately, non-“operational-termination” of CTRSs is not always preserved by T while it is preserved by Uμ (we will show an example later in extra remarks). If so, we can prove “operational termination” of CTRSs by proving termination of the corresponding TRSs obtained by T. The reason is that redexes causative of non-“operational- termination” are sometimes erased in the process of T. In order to avoid this situation, we strengthen Rmc again as follows:
(Rmc'') Rmc is satisﬁed and any instantiated variable is not erased, that is, all
xs in Dom(δ) appear in r.
It is clear that Rmc'' implies Rmc. Note that Rmc'' and Rmc' are incomparable. In order to guarantee “operational termination” of R by termination of T(Uμ(R)), we use T based on Rmc''. When T(Uμ(R)) has no U symbols, termination of T(Uμ(R)) coincides with “operational termination” of R. Therefore, several methods of prov- ing termination of TRSs are applicable for proving “operational termination” of R.

10 This identification is natural but tp1(t) and t raise different behavior of reductions in some situations.

In summary, the transformation T is harmless for simulation-completeness (conflu- ence), termination (non-termination) and efficient reductions of CTRSs if it is based on both Rmc' and Rmc''. Therefore, properties of TRSs obtained by T ◦ Uμ based on both Rmc' and Rmc'' are useful in discussing those of the original CTRSs.
We offer some extra remarks.
The results for UO in [9] also hold for U and T ◦ U. More precisely, two syntactic conditions of CTRSs that are sufficient to preserve simulation-completeness with- out the context-sensitive and membership condition were shown in [9], and they are also sufficient conditions for U and T ◦ U to preserve simulation-completeness without context-sensitive and membership conditions. On the other hand, nei- ther of the two conditions are sufficient nor necessary for removing all U symbols successfully.
It is clear that each CS-TRS that appears in the process of T can be considered as the unraveled rules for some conditional rule that may be different from the original conditional rule. For example, the CS-TRS (R4, μR4 ) corresponds to the following conditional rule:
f(x, y) → z ⇐ g(y) → z ∧ h(g(x), x) → z.
It can be said that the CTRSs obtained by such reverse transformation for U are computationally equivalent with the corresponding original CTRSs. Therefore, the transformation T is useful in optimizing conditional rewrite rules.
For a conditional rule such that the recursive reduction of the conditional part is not (operationally-)terminating, the corresponding reduction in the resulting CS-TRS transformed by T ◦ Uμ sometimes becomes terminating while the whole system is still not terminating. For example, consider the following CTRS:
R8 = { f(x, y) → z ⇐ g(x) → z,	a → g(a) }.
This CTRS R8 is transformed by T ◦ Uμ into
' = { f(x, y) → g(x),	a → g(a) }.
When f(x, y) → z ⇐ g(x) → z is applied to f(a, a), the recursive reduction of the instantiated condition g(a) → z{z '→ t} does not effectively terminate (hence not operationally terminate) because the number of candidates for t is infinite. On the other hand, in the case of applying f(x, y) → g(x), the conditional part disappears and we have no reduction corresponding to the recursive reduction of

the condition g(x) → z. Note that R8 and R'
are not terminating.

In Section 6, we tightened Rmc to Rmc' to keep the feature of let structures that are often used in functional programming to obtain efficient computation. In order to test the effect of Rmc', we must implement a rewriting engine for unravelings with context-sensitive and membership conditions.
As another approach to remove conditional parts of conditional rules, P. Viry proposed a transformation from join CTRSs into TRSs, that is also applicable to normal CTRSs [17]. Unlike unravelings, his transformation does not introduce U symbols but extends the arity of defined symbols. Similarly to unravelings, his transformation is not simulation-complete for all CTRSs in general. The example

in [7] is also a counterexample against simulation-completeness of his transforma- tion. Note that Viry’s transformation is not applicable to deterministic 3-CTRSs.
S. Antoy, B. Brassel, and M. Hanus applied Viry’s transformation to conditional nar- rowing of constructor-based CTRSs that are restricted normal CTRSs [1]. G. Rosu proposed a transformation of join CTRSs for implementing an efficient conditional rewriting engine [14], that is based on Viry’s one. His transformation seems to produce unconditional systems that are simulation-complete. However, the main part to evaluate conditional parts is not defined by rewrite rules but implemented. Thus, his transformation is not suitable for analyzing ultra-properties of CTRSs. As a revised variant of Rosu’s transformation, T.-F. Serbanuta and Rosu enhanced Rosu’s transformation to become simulation-complete for deterministic 3-CTRSs that are transformed into either left-linear or ground-confluent TRSs [15]. In con- trast with unravelings, one of the important advantages of these transformations is that they preserve irreducibility of normal forms of CTRSs. From this advan- tage, these transformations (especially Serbanuta and Rosu’s one) are much suitable for normalizing computation than unravelings. On the other hand, rules obtained by these transformations are a bit more complicated than those by unravelings. From this observation, unravelings are more suitable for analyzing CTRS prop- erties or for optimizing conditional rules. Moreover, the conditions imposed on CTRSs to maintain computational equivalence appears to be tight for practical and complicated examples (those conditions are similar to conditions [9] for unravel- ings to preserve simulation-completeness without the strategy). We believe that the context-sensitive and membership conditions for unravelings makes the above transformations preserve computational equivalence. On the contrary, the homo- morphisms used in these transformations will makes Ohlebusch’s unraveling and its variants preserve computational equivalence if Xi in Definition 3.4 is defined as Var(l) ∪ (Var(∪T1 ∪ ··· ∪ Ti−1) ∩ Var(Ti ∪ Si+1 ∪ Ti+1 ∪ ··· ∪ Sk ∪ Tk ∪ {r})).
In summary, the transformation proposed in [15] is more suitable for normalizing computation but not for analyzing CTRS properties or optimizing conditional rules
than unravelings. The transformation T in this paper is usable for optimizing condi- tional rules because each set of unconditional rules obtained by it from a conditional rule has a corresponding simplified conditional rule. From this observation, using T as a preprocessor of the transformation in [15] is much more effective for those two transformations. Furthermore, Ohlebusch’s unraveling with the context-sensitive and membership conditions and Serbanuta and Rosu’s transformation should be combined as a method because they are very close now.

Acknowledgement
This work is partly supported by MEXT. KAKENHI #17700009 and #18500011. We thank Professor Yoshihito Toyama for pointing out some interesting issues about confluence. We would like to thank the anonymous referees for several comments that are useful to make the paper more precise. We are deeply grateful to Salvador Lucas for his valuable comments helping us to improve the final version of the paper.

References
Antoy, S., B. Brassel and M. Hanus, Conditional narrowing without conditions, in: Proceedings of the 5th International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming (2003), pp. 20–31.
Baader, F. and T. Nipkow, “Term Rewriting and All That,” Cambridge University Press, United Kingdom, 1998.
Bergstra, J. A. and J. W. Klop, Conditional rewrite rules: Confluence and termination., Journal of Computer and System Sciences 32 (1986), pp. 323–362.
Dur´an, F., S. Lucas, J. Meseguer, C. March´e and X. Urbain, Proving termination of membership equational programs, in: Proceedings of the 2004 ACM SIGPLAN Workshop on Partial Evaluation and Semantics-based Program Manipulation (2004), pp. 147–158.
Lucas, S., Context-sensitive computations in functional and functional logic programs, Journal of Functional and Logic Programming 1998 (1998).
Lucas, S., C. March´e and J. Meseguer, Operational termination of conditional term rewriting systems, Information Processing Letters 95 (2005), pp. 446–453.
Marchiori, M., Unravelings and ultra-properties, in: Proceedings of the 5th International Conference on Algebraic and Logic Programming, Lecture Notes in Computer Science 1139 (1996), pp. 107–121.
Nishida, N., M. Sakai and T. Sakabe, Narrowing-based simulation of term rewriting systems with extra variables and its termination proof, Electronic Notes in Theoretical Computer Science 86 (2003), issue 3, pp. 1–18.
Nishida, N., M. Sakai and T. Sakabe, On simulation-completeness of unraveling for conditional term rewriting systems, IEICE Technical Report SS2004-18, the Institute of Electronics, Information and Communication Engineers (2004), vol. 104, No. 243, pp. 25–30.
Nishida, N., M. Sakai and T. Sakabe, Generation of inverse computation programs of constructor term rewriting systems, The IEICE Transactions on Information and Systems J88-D-I (2005), pp. 1171–1183 (in Japanese).
Nishida, N., M. Sakai and T. Sakabe, Partial inversion of constructor term rewriting systems, in: Proceedings of the 16th International Conference on Rewriting Techniques and Applications, Lecture Notes in Computer Science 3467 (2005), pp. 264–278.
Ohlebusch, E., Termination of logic programs: Transformational methods revisited, Applicable Algebra in Engineering, Communication and Computing 12 (2001), pp. 73–116.
Ohlebusch, E., “Advanced Topics in Term Rewriting,” Springer, 2002.
Rosu, G., From conditional to unconditional rewriting, in: Revised selected papers of the 17th International Workshop on Recent Trends in Algebraic Development Techniques, Lecture Notes in Computer Science 3423 (2005), pp. 218–233.
Serbanuta, T.-F. and G. Rosu, Computationally equivalent elimination of conditions, in: Proceedings of the 17th International Conference on Rewriting Techniques and Applications, Lecture Notes in Computer Science 4098 (2006), pp. 19–34.
Toyama, Y., Confluent term rewriting systems with membership conditions, in: Proceedings of the 1st International Workshop on Conditional Term Rewriting Systems, Lecture Notes in Computer Science 308 (1987), pp. 228–241.
Viry, P., Elimination of conditions, Journal of Symbolic Computation 28 (1999), pp. 381–401.
