	Electronic Notes in Theoretical Computer Science 203 (2008) 109–129	
www.elsevier.com/locate/entcs
Coalgebraising Subsequential Transducers
Helle Hvid Hansen1,2
Section Theoretical Computer Science Vrije Universiteit Amsterdam Amsterdam, The Netherlands

Abstract
Subsequential transducers generalise both classic deterministic automata and Mealy/Moore type state ma- chines by combining (input) language recognition with transduction. In this paper we show that normal- isation and taking differentials of subsequential transducers and their underlying structures can be seen as coalgebraisation. More precisely, we show that the subclass of normalised subsequential structures is a
category of coalgebras which is reflective in the category of coaccessible subsequential structures, and which has a final object. This object is then also final for coaccessible structures. The existence and properties of the minimal subsequential transducer realising a partial word function f can be derived from this result. We also show that subsequential structures in which all states are accepting, can be seen as coalgebras by taking differentials. The coalgebraic representation obtained in this way gives rise to an alternative method of deciding transducer equivalence.
Keywords: Subsequential transducer, word function, coalgebra, normalisation, differential.


Introduction
Subsequential transducers generalise deterministic finite automata (DFA’s) as well as Mealy/Moore type state machines, by combining the notion of final state with output on transitions, and allowing for initial and terminal output. This combi- nation of language recognition and transduction makes subsequential transducers useful in areas such as lexical analysis, coding theory, and more recently, in speech and language processing (cf. [9]). The semantics of subsequential transducers is given in terms of partial word functions f : A∗ −−· B∗. Subsequential transducers were introduced (cf. [17]) as a generalisation of sequential transducers. Sequential transducers and sequential functions were studied as early as the 1950’s ([11]) and their theory is well established ([7]). Existing results on subsequential transduc- ers include a characterisation of the functions which can be realised by a finite

1 Supported by NWO grant 612.000.316.
2 Email:hhhansen@few.vu.nl

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.05.022

subsequential transducer ([5,4]), and algorithms for determinisation and minimisa- tion ([2,6]).
Automata have traditionally been studied from an algebraic perspective ([7]) with focus on the notions of structure, congruence and initiality. Coalgebra, on the other hand provides abstract notions of behaviour, bisimilarity and minimality arising from finality, and it has proved to be an equally suitable mathematical framework for modelling and studying the behaviour of state-based systems ([15]). In particular, classic deterministic automata and Mealy/Moore machines can all be described coalgebraically in such a way that their traditional semantics coincides with the final semantics (cf. [13,8]). The question naturally arises of whether the coalgebraic modelling generalises to subsequential transducers.
Our motivation is the following. Firstly, we hope to provide a deeper understand- ing of existing notions and constructions on subsequential transducers by showing that they are instances of more general mathematical notions. Secondly, if we can establish that subsequential transducers, or more precisely, the underlying struc- tures, can be seen as coalgebras, we obtain a range of results and techniques from the general theory of coalgebra which could be applied to them. We mention coal- gebraic modal logic (cf. [10,16,19]) for purposes of logic specification and reasoning, and the very recent regular expressions for polynomial functors ([3]) which provide a Kleene-style theorem and a generic synthesis procedure.
In this paper, we will see that, in general, subsequential structures cannot be regarded as coalgebras. The reason is that their semantics requires a more general notion of morphism than is provided by coalgebra. However, we show that the so- called normalised subsequential structures can correctly be seen as coalgebras, and that there exists a final normalised subsequential structure. With respect to finality, the restriction to normalised structures is no real loss, as it is well-known that every subsequential transducer/structure can be normalised. We investigate this result in the coalgebraic setting and show that normalised subsequential structures are full and reflective in the category of coaccessible subsequential structures (the class of subsequential structures in which all states have a well-defined behaviour). This result parallels the fact that minimal DFA’s form a reflective subcategory of all DFA’s, and is an argument for saying that the coalgebraic description is the right way of thinking about subsequential structures.
Moreover, we show that the class of subsequential transducers in which all states are accepting (step-by-step subsequential structures) can be viewed as coalgebras. This transformation is essentially obtained by taking the differential of a function f : A∗ −−· B∗. The practical interest of this coalgebraic representation is that it provides us with an alternative method for deciding transducer equivalence, which does not require normalisation. We illustrate with an example in section 4.3. Nor- malisation and taking differentials are both known existing constructions (cf. [4,6]) that transform a subsequential structure or function into a more manageable (com- putationally, conceptually) representation. The results of this paper show that these transformations are a form of coalgebraisation.
The paper is structured as follows. In section 2 we introduce relevant notions

on sets, words and functions, and give a brief overview of basic coalgebraic notions. In section 3 we review the definition of subsequential transducers and some known results. Finally in section 4, we carry out the coalgebraic modelling of normalised, sequential and step-by-step subsequential transducers.

Preliminaries
Sets, words, functions.
Let X and Y be sets. A (partial) function from X to Y is denoted by f : X −−· Y . We will write f : X → Y when f is a total function from X to Y . For a function f : X −−· Y , and subsets C ⊆ X and D ⊆ Y , the f -image of C is denoted f (C), the inverse f -image of D is f−1(D), and the restriction of f to C is fTC. The domain and range of f are denoted dom(f ) and ran(f ), respectively. As is standard, we can view a partial function f : X −−· Y as a total function f : X → Y ∪ { }, where
 is the undeﬁned value, by letting f (x) =  for all x /∈ dom(f ).
The free monoid over a set X is the monoid (X∗, ε, .) where X∗ is the set of all words over X, ε is the empty word, and u.w, or simply uw, denotes the concatenation of two words u, w ∈ X∗. If f, g : X → B∗, then f.g : X → B∗ is the function defined by (f.g)(x) = f (x).g(x). The free group over X is denoted by X(∗), and the formal inverse of x ∈ X is written x. For w ∈ X∗, the inverse of w = x1x2 ... xk is w = xk ... x2 x1, and ε = ε. We will apply concatenation and inverse to obtain prefixes and suffixes of words: If w = uv ∈ X∗, then u.w = v and
w.v = u. In the case u is not a prefix of w ∈ X∗, then u.w is read as an element of X(∗). For example, aaa.ab = aa.b. For all u, w ∈ X∗, we write u ≤ w if u is a prefix of w. A subset T ⊆ X∗ is called preﬁx-closed if u ≤ w ∈ T implies u ∈ T . A partial function f : A∗ −−· B∗ is preﬁx-preserving if dom(f ) is prefix-closed, and for all u, w ∈ dom(f ), if u ≤ w then f (u) ≤ f (w). For a set S ⊆ A∗ of words, we denote by lcp(S) the longest common prefix of words in S with the convention that lcp(∅) is undefined.
Let f : A∗ −−· B∗ be a partial function, and w ∈ A∗. The maximal output of f
on input w is given by

f [w] := lcp(f (wA∗)) = lcp({f (wu) | wu ∈ dom(f )}).

The derivative of f with respect to w is the partial function f·w : A∗ −−· B∗ defined for all u ∈ A∗ by
(f ·w)(u) = ⎧⎨ f [w].f (wu) if wu ∈ dom(f )
⎩	otherwise

The derivative of f is sometimes called the residual of f in the literature on subse- quential transducers.

Coalgebra and Automata
We now recall the basic coalgebraic definitions relevant for this paper, and fix nota- tion. Our coalgebras will be based on Set, the category of sets and (total) functions. Given a functor T : Set → Set, a T-coalgebra is a pair S = (S, σ) where S is a set and σ : S → T(S) is a function. A function f : S1 → S2 is a T-coalgebra morphism from (S1, σ1) to (S2, σ2) (written: f : (S1, σ1) → (S2, σ2)), if T(f ) ◦ σ1 = σ2 ◦ f . The category of T-coalgebras and T-coalgebra morphisms is denoted by Coalg(T). In this paper all functors considered are polynomial, i.e. they are constructed from constant sets, identity, product, coproduct and exponentiation.
A pointed T-coalgebra (S, σ, s0) consists of a T-coalgebra (S, σ) and an initial state s0 ∈ S. A morphism of pointed T-coalgebras from (S1, σ1, s1) to (S2, σ2, s2) is a T-coalgebra morphism f : (S1, σ1) → (S2, σ2) for which f (s1) = s2. Pointed T-coalgebras and their morphisms form a category PtCoalg(T). If (S, σ) is a T- coalgebra for a polynomial functor T, and S' ⊆ S, then (S', σTS' ) is a subcoalgebra of (S, σ) if the inclusion map i : S' → S is a T-coalgebra morphism. Given a point s in (S, σ), we denote by ⟨s⟩ the subcoalgebra generated by s in (S, σ) which is the least subcoalgebra (S', σ') (w.r.t. inclusion) that contains s. For polynomial functors such a least subcoalgebra always exists, and it can be obtained essentially by taking the transition closure of {s}.
We use the notion of T-bisimilarity of coalgebras (see e.g. [15]). Let two T- coalgebras S1 = (S1, σ1) and S2 = (S2, σ2) be given. A relation Z ⊆ S1 × S2 is a T-bisimulation between S1 and S2, if Z can be equipped with coalgebraic structure ζ : Z → T(Z) such that the projections πi : Z → Si, i ∈ {1, 2} are T-coalgebra morphisms. Two states s1 ∈ S1 and s2 ∈ S2 are T-bisimilar (notation: s1 ∼ s2) if there exists a T-bisimulation Z between S1 and S2 such that ⟨s1, s2⟩∈ Z.
A ﬁnal T-coalgebra (Φ, φ) is a final object in the category Coalg(T). This means that for every T-coalgebra (S, σ) there exists a unique T-coalgebra morphism h : (S, σ) → (Φ, φ). In general, a final T-coalgebra may not exist, but if it does, then the final map h assigns to a state s in a T-coalgebra (S, σ) its behaviour h(s). In a final T-coalgebra (Φ, φ), the principle of coinduction holds: For all s, t ∈ Φ: s ∼ t iff s = t.
Many known structures are identified as being coalgebras (see e.g. [15,16]). We mention in particular two types of automata which are special instances of sub- sequential transducers. The first is classic deterministic finite automata over an alphabet A (see e.g. [13]). These are coalgebras for the functor DFA(X) = 2 × XA, where the output function o : Q → 2 = {0, 1} defines whether a state q ∈ Q is accepting (o(q) = 1) or not (o(q) = 0); and the transition function d : Q → QA defines for each q ∈ Q, the next state d(q)(a) on input a. It is straightforward to show that DFA-coalgebra morphisms coincide with the well known morphisms of deterministic automata, the final DFA-coalgebra consists of the set of all languages P(A∗), and the final DFA-coalgebra morphism is the map that sends a state q to the set of words accepted from q. The second example is given by Mealy machines (cf. [8]). A Mealy machine with input in A and output in B is a coalgebra of the type t : Q → (B × Q)A. In this case, the final Mealy coalgebra has as its carrier the

set of causal stream functions, that is, functions f : Aω → Bω where for any stream
α ∈ Aω the n’th element of f (α) is determined by the first n elements of α.
Subsequential Transducers
In this section we fix notation, and review the basic definitions of subsequential transducers and their morphisms. These follow Choffrut [6] more or less, but the presentation here is slightly different in order to make the connection with coalgebra more clear.
Basic deﬁnitions
Definition 3.1 (subsequential structure & transducer) A subsequential struc- ture is a triple S = (Q, t, r) where Q is a set of states, and t, r are maps of the following type:

t : Q → (A −−· (B∗ × Q)) (transition structure)
r : Q −−· B∗	(terminal output function)

A subsequential transducer is a 5-tuple T = (Q, t, r, i, m) where (Q, t, r) is a subse- quential structure, i ∈ Q is the initial state, and m ∈ B∗ is the initial preﬁx. The set of ﬁnal (or accepting) states of T is F := dom(r). If q /∈ dom(r) then q is called an internal state.
Remark 3.2 (notation) For all states q ∈ Q, we will write supp(q) instead of dom(t(q)). The transition structure t will often be described in terms of an output function o : Q → (A −−· B∗) , and a next-state function d : Q → (A −−· Q) where we quietly assume that for all q ∈ Q, dom(o(q)) = dom(d(q)).
We extend the definition of o and d from letters to words in the usual man- ner. For a state q, a ∈ A and w ∈ A∗, we define d(q)(ε) = q and d(q)(wa) = d(d(q)(w))(a), similarly, o(q)(ε) = ε and o(q)(wa) = o(q)(w).o(d(q)(w))(a), with the proviso that the left-side is defined only if the right-side is.
The usual notion of path in subsequential structures applies. A path is called ﬁnal if it ends in a final state, and a state q coaccessible if there exists a final path starting in q. The set of coaccessible states of a subsequential structure S will be denoted by Coacc(S). In a subsequential transducer a final path is successful if it
starts in the initial state, and a state q is accessible if it is reachable from the initial state. A subsequential transducer is called trim if all states lie on a successful path.
Definition 3.3 (realisation, behaviour) Given a subsequential structure S = (Q, o, d, r) a state q ∈ Q realises a partial function [q]]S : A∗ −−· B∗ defined for all w ∈ A∗ by: [q]]S(w) = o(q)(w).r(d(q)(w)). We call [q]]S the behaviour of q (in S). Given two subsequential structures S and S', two states q in S and q' in S' are equivalent if [q]]S = [[q']]S' . A subsequential transducer T = (S, i, m) realises a partial function [T]] : A∗ −−· B∗ defined as follows for w ∈ A∗: [T]](w) = m.[[i]]S(w). We

refer to [T ] as the behaviour of T. Two subsequential transducers T1 and T2 are
equivalent if [T1]] = [[T2]].
For notational simplicity, we sometimes leave out the subscript when S is clear from the context, or we use some appropriate indexing, for example, [q]]1 instead of [q]]S1 etc. Before we give the definition of morphisms between subsequential transducers, we look at an example.
Example 3.4 Consider the subsequential transducers T and T' as illustrated be- low. The inital prefix in both transducers is the empty word, and the terminal output functions r and r' are indicated with double arrows. The states q2 and q'

are internal.

,ε,

,ra,xa

,br,a

T :   ε	 q0 
a|ab	 q1 
a|rac	 q2 
a|ada	 q3 



T' :   ε  q' 
cεz
a|abra	 q' 
cxza
a|ca	 q' 
a|dab	 q' 
craz

We see that dom([[T]]) = dom([[T']]) = {ε, a, aaa}, and the two transducers com- pute the same partial function f : {a}∗ −−· {a, b, c}∗: f (ε) = ε, f (a) = abraxa, f (aaa) = abracadabra.
Intuitively, we would like the state map α(q) = q',q ∈ Q, to be a morphism from T to T', since T' is just like T except that, internally, T' produces its output a bit faster than T. In other words, we could shift some of the output letters “upstream” in T and obtain an obviously isomorphic copy of T'.
The above example illustrates the idea behind the notion of subsequential mor- phism.
Definition 3.5 (subsequential morphism) Let Sj = (Qj, oj, dj, rj), j = 1, 2, be two subsequential structures. A partial function α : Q1 −−· Q2 is a subsequential morphism from S1 to S2, if there exists a function β : Q1 → B∗ such that the following conditions are satisfied for all q ∈ dom(α):
(supp)	supp(q) = supp(α(q)),
(next)	∀a ∈ supp(q) : α(d1(q)(a)) = d2(α(q))(a),
(out)	∀a ∈ supp(q) : β(q).o2(α(q))(a) = o1(q)(a).β(d1(q)(a)), (acc)	q ∈ dom(r1) ⇐⇒ α(q) ∈ dom(r2), i.e., α−1[F2] = F1,
(term-out) ∀q ∈ dom(r1) : β(q).r2(α(q)) = r1(q).
We will often use the notation (α, β) : S1 −−· S2 to say that α is a subsequential morphism from S1 to S2 with witnessing function β.
Given two subsequential transducers Tj = (Sj, ij, mj), j = 1, 2, and a subse- quential morphism (α, β) : S1 −−· S2, then (α, β) is a subsequential (transducer)

morphism from T1 to T2 if α and β satisfy: (init) α(i1) = i2,
(ε-in) m2 = m1.β(i1).
Stated informally, the map β : Q1 → B∗ in the above definition defines the speed-up in output which would synchronise T1 with T2 at all computation steps, including incomplete computations that have not yet reached a final state. We note that if we would allow β to be a function to the free group B(∗) (as in [6]), then β would allow not only the speeding up of output, but also delaying output. The reader can now verify that in Example 3.4 the map α(q) = q', q ∈ Q, is a subsequential morphism by taking β(q0) = ε, β(q1) = ra, β(q2) = a and β(q3) = b.
Looking closer at Definition 3.5 we note that a subsequential transducer mor- phism α : T1 −−· T2 must be defined on all accessible states due to the conditions (init) and (next). For subsequential structures (where the notion of accessibility does not apply), coaccessibility is the crucial property which makes a state inter- esting. The following lemma is well-known for deterministic transition structures.
Lemma 3.6 If α : S1 −−· S2 is a subsequential morphism and S1 = (Q1, o1, d1, r1) and S2 = (Q2, o2, d2, r2), then for all q ∈ dom(α) and all w ∈ A∗: d1(q)(w) ∈ F1 iff d2(α(q))(w) ∈ F2. In particular, for all q ∈ dom(α), q is coaccessible iff α(q) is coaccessible.
Proof. By induction on the length of w, details are left to the reader.	 
We observe that given α : Q1 −−· Q2, if a β : Q1 → B∗ exists which makes α a subsequential morphism, then there is only one possible definition of β on coaccessible states.
Lemma 3.7 If α : S1 −−· S2 is a subsequential morphism with β : Q1 → B∗ as witnessing function, then βTCoacc(S1) is uniquely deﬁned.
Proof. Let S1 = (Q1, o1, d1, r1) and S2 = (Q2, o2, d2, r2) be subsequential struc- tures. If q0 →a1 q1 →a2 ... →an qn, n ≥ 0, is a final path in S1, then qn ∈ F1 and β(qn) is determined by (term-out). Now for i = 0,...,n − 1, β(qi) is defined by β(qi+1) and (out):
β(qi) = o1(qi)(ai+1).β(qi+1).o2(α(qi))(ai+1).	(1) The (out)-condition ensures that o2(α(qi))(ai+1) is a suffix of o1(qi)(ai+1).β(qi+1), so β indeed takes values in B∗.		 
Subsequential morphisms do not preserve behaviour of states, i.e., (α, β) : S1 −−·
S2 does not imply that for all q in dom(α), [q]]1 = [[α(q)]]2. Instead we have:
Lemma 3.8 If (α, β) : S1 −−· S2, then for all q ∈ dom(α), [[q]]1 = β(q).[[α(q)]]2.
Proof. Let (α, β) : S1 −−· S2 be a subsequential morphism from S1 = (Q1, o1, d1, r1) to S2 = (Q2, o2, d2, r2). From Lemma 3.6 it follows immediately that dom([[q]]1) = dom([[α(q)]]2). Now let w = a1a2 ... an ∈ dom([[q]]1), and let q0, q1,..., qn be the

run on w in S1, i.e., q0 = q and for j = 0,...,n − 1, qj+1 = d1(qj)(aj+1). We then have:
[[q]]1(w) = o1(q0)(a1) ... o1(qn−1)(an).r1(qn)

(out), (term-out) = β(q0).o2(α(q0))(a1)β(q1).β(q1).o2(α(q1))(a2)β(q2). ... 

... β(qn−1).o2(α(qn−1))(an).β(qn).β(qn).r2(α(qn))
= β(q0).o2(α(q0))(a1)	o2(α(qn−1))(an).r2(α(qn))
(next) = β(q).[[α(q)]]2(w).	 
Proposition 3.9 If there exists a subsequential transducer morphism α : T1 −−·
T2, then [[T1]] = [[T2]].
Proof. Let T1 = (S1, i1, m2), T2 = (S2, i2, m2) and (α, β) : T1 −−· T2 be a subse- quential transducer morphism. By definition, for w ∈ A∗: [T1]](w) = m1.[[i1]]1(w). From Lemma 3.8 and (init), we get [T1]](w) = m1.β(i1).[[i2]]2(w), and finally from (ε-in), [T1]](w) = m2.[[i2]]2(w) = [[T2]](w).	 
Subsequential morphisms can be composed as described in the following lemma (the straightforward proof is omitted).
Lemma 3.10 If (α1, β1) : S1 −−· S2, and (α2, β2) : S2 −−· S3, are subsequential morphisms, then (α2 ◦ α1, β1.(β2 ◦ α1)) : S1 −−· S3.
It follows that subsequential structures and subsequential morphisms form a category SubSeq. Similarly, subsequential transducers and subsequential transducer morphisms form a category SubSeqTra.

Normalised Subsequential Transducers
Minimisation via quotienting with a suitable congruence is a standard automata- theoretic construction. A congruence is the kernel of a morphism, and for classical automata it is clear that morphisms preserve state behaviour. However, we also know that subsequential morphisms, in general, do not preserve state behaviour. The observation made by Choffrut [5] was that a subsequential transducer can be transformed into an equivalent one in which output is produced at maximal speed, and that in this normalised transducer, state equivalence can be determined much in the same way as for DFA’s (as also remarked in [6]). In terms of subsequential morphisms (α, β), normalisation can be seen as an optimisation with respect to β, and quotienting with state equivalence as an optimisation with respect to α. A minimal subsequential transducer is optimal with respect to both.
Definition 3.11 (normalised, minimal) Let S = (Q, o, d, r) be a subsequential structure, and q ∈ Q. We define a function βˆS : Q → 1 + B∗ by
βˆS(q) = [[q]]S[ε] = lcp({o(q)(w).r(d(q)(w)) | w ∈ A∗}).	(2) That is, βˆS(q) is the longest common prefix over all output words on final paths

starting in q. We say that a state q ∈ Q is normalised if βˆS(q) = ε. Note that q is coaccessible, iff βˆS(q) ∈ B∗. A subsequential structure S is normalised, if all states in S are normalised, and S is minimal, if it is normalised, and no two states are equivalent. A subsequential transducer T is normalised (minimal) if the underlying subsequential structure is normalised (minimal).
Again, we may leave out the subscript in βˆS when S is clear from the context. In [6] an algorithm is given to compute βˆS for finite S. A subsequential structure S can be normalised under the following transformation, which can be seen as the morphism (idTCoacc(S), βˆ), cf. Theorem 4.5.
Definition 3.12 (normalisation) Let T = (Q, o, d, r, i, m) be a subsequential transducer. Define N(T) = (Coacc(T), o', d, r', i, m') where for all q ∈ Q, and all a ∈ A:

m' = m.βˆ(i), o'(q)(a) = βˆ(q).o(q)(a).βˆ(d(q)(a)), r'(q) = βˆ(q).r(q)	(3)

N(T) is called the normalisation of T. Similarly, if S = (Q, o, d, r) is a subsequential structure, then the normalisation of S is N(S) = (Coacc(S), o', d, r'), where o' and r' are defined as in (3).
Finally we recall the construction of a minimal subsequential transducer from an arbitrary function f : A∗ −−· B∗ (cf. [6]).
Definition 3.13 (minimal realisation) Let f : A∗ −−· B∗ be given. We define the subsequential transducer Tf = (Δf , o, d, r, i, m) by taking:

Δf = {f ·w | w ∈ A∗},	o(f ·w)(a) = f [w].f [wa], i = f ·ε,	d(f ·w)(a) = f ·wa,
m = f [ε],	r(f ·w)	= f [w].f (w).

It is straightforward to check that Tf realises f , and Tf is minimal.

Coalgebraic Modelling
Our aim is to find out whether subsequential transducers can be seen as coalgebras. It is easy to see that a subsequential structure (Q, t, r) has the type of a coalgebra for the Set-functor S defined by:
S(X)	= (1 + B∗ × X)A × (1 + B∗),
S(f : X → Y ) = (1 + IdB∗ × f )IdA × (1 + IdB∗ ).
Instantiating the definitions of S-coalgebra and S-coalgebra morphism yields:
Definition 4.1 (Coalg(S)) An S-coalgebra consists of a carrier set Q and a map
⟨t, r⟩ : Q → S(Q), i.e.,

⟨t, r⟩  :  Q → (1 + B∗ × Q)A × (1 + B∗)
q '→	⟨	t(q)	,	r(q) ⟩
Again, we will describe t in terms of an output function and a next-state function (cf. Remark 3.2), and supp(q) := {a ∈ A | t(q)(a) /= }, for all q ∈ Q.
If Sj = (Qj, oj, dj, rj), j = 1, 2, are S-coalgebras, a function α : Q1 → Q2 is an
S-coalgebra morphism if for all q ∈ Q1:
(supp)	supp(q) = supp(α(q)),
(next)	∀a ∈ supp(q) : α(d1(q)(a)) = d2(α(q))(a),
(out)n	∀a ∈ supp(q) : o2(α(q))(a) = o1(q)(a), (acc)	q ∈ dom(r1) ⇐⇒ α(q) ∈ dom(r2), (term-out)n	∀q ∈ dom(r1) : r2(α(q)) = r1(q).
Lemma 4.2 Let Sj = (Qj, oj, dj, rj), j = 1, 2, and be S-coalgebras. A total function α : Q1 → Q2 is an S-coalgebra morphism if and only if (α, ε) is a subsequential morphism.
Proof. Follows almost immediately from Definitions 4.1 and 3.5.	 
In other words, S-coalgebra morphisms do not allow the shifting of output letters via some function β : Q → B∗. This means that, in general, subsequential structures can be seen as coalgebras only at the level of objects, but the coalgebraic notion of morphism is too strict with respect to the intended semantics of subsequential transducers. However, in the next section we show that normalisation is a natural transformation from subsequential structures to coalgebras.

Normalisation is Coalgebraisation
From now on we will restrict ourselves to coaccessible subsequential structures, that is, subsequential structures in which all states are coaccessible. In the literature on automata, (co)accessibility is often assumed (cf. [6]). From an algorithmic point of view this is justified by the fact that it is straightforward to make a finite automaton (co)accessible. Our motivation is mainly technical, since coaccessibility allows us to work with total maps as morphisms, and it ensures that all states have non-empty behaviour.
Let CSubSeq be the (non-full) subcategory of SubSeq consisting of coaccessi- ble subsequential structures and total subsequential morphisms between them. Let NSubSeq be the full subcategory of CSubSeq consisting of normalised subsequential structures and total subsequential morphisms. We will show that normalised sub- sequential structures are essentially coalgebras, and that NSubSeq is reflective in CSubSeq.
We recall the definition of a reflective subcategory (see e.g. [1]). Let C be a subcategory of D, and D and object in D. A C-reflection arrow for D is a D- morphism rD : D → CD to some C-object CD which has the following universal

property. For any C' ∈ C and any D-morphism f : D → C' there is a unique C-morphism f' : CD → C' such that f = f' ◦ rD. That is, the following diagram commutes:
D ¸ rD  CD 
¸¸¸¸
¸¸	f'
f	¸zJ 
C'
A subcategory C of D is reflective in D if every D-object has a C-reflection arrow. An equivalent formulation is the following: A subcategory C of D is reflective in D if the embedding functor E : C → D has a left adjoint R : D → C. This left adjoint R is called a reflector.
First we make some observations regarding subsequential morphisms. Note that from Lemma 3.8 it follows that for any subsequential morphism (α, β) : S1 −−· S2, and all states q in dom(α):

βˆ1(q) = β(q).βˆ2(α(q)).	(4)

Using (4) and Lemma 4.2 it is easy to show the following (proof is left to the reader).
Lemma 4.3	(i) If (α, β) : S1 → S2 is a CSubSeq-morphism, and S2 is normalised, then β = βˆ1.
If S1 and S2 are normalised and (α, β) : S1 → S2 is a total subsequential morphism, then β = ε.
NSubSeq is a full subcategory of Coalg(S).
Next we show that the normalisation operation N defined in Def. 3.12 can be extended to a functor from CSubSeq to NSubSeq.
Proposition 4.4 For α : S1 → S2 in CSubSeq deﬁne N(α) := α. The map N is a functor from CSubseq to NSubSeq.
Proof. Assume (α, β) : S1 → S2 in CSubSeq, and N(Sj) = (Sj, o' , dj, r' ), j = 1, 2.
j	j
We must prove that α : N(S1) → N(S2) in NSubSeq. By Lemma 4.3.(iii) this amounts to showing that α : N(S1) → N(S2) is a Coalg(S)-morphism. Conditions (supp), (next) and (acc) follow from the assumption that (α, β) : S1 → S2 is a
subsequential morphism. To see that o' (q)(a) = o' (α(q))(a) we have for q ∈ dom(α)
1	2
and a ∈ A using (out) and (next) for (α, β), and equation (4):

o' (q)(a)	=
βˆ1(q).o1(q)(a).βˆ1(d1(q)(a))

(=4)
βˆ (α(q)).β(q).o (q)(a).β(d (q)(a)).βˆ (α(d (q)(a)))

2	1	1	2	1

(o=ut)
βˆ (α(q)).o (α(q))(a).βˆ (α(d (q)(a)))

2	2	2	1
(n=ext) o' (α(q))(a).
Similarly, using (4) and (term-out) for (α, β) we have for q ∈ dom(α):


		
r' (q) = βˆ1(q).r1(q) = βˆ2(α(q)).β(q).r1(q) = βˆ2(α(q)).r2(α(q))
= r' (α(q)).	 
We now show that normalised subsequential structures form a reflective subcat- egory of CSubSeq.
Theorem 4.5 NSubSeq is a reflective subcategory of CSubSeq.
Proof. For a coaccessible S = (Q, o, d, r), the map id Q, is an NSubSeq-reflection arrow for S: It is straightforward to check that (id Q, βˆS) : S → N(S) is a surjective subsequential morphism, and that for any normalised S' ∈ NSubSeq, and CSubSeq- morphism (α, β) : S → S', the unique NSubSeq-morphism α' : N(S) → S' such that (α', ε) ◦ (id Q, βˆS) = (α, β) is just α' = α.	 
The above theorem easily extends from structures to transducers.
Corollary 4.6 Normalised subsequential transducers form a reflective subcategory of coaccessible subsequential tranducers.
From Definition 3.11 it is clear that if a function f : A∗ −−· B∗ is the behaviour of some state q in a normalised subsequential structure, then f [ε] = ε, and hence f · ε = f . We now show that the set Φ := {f : A∗ −−· B∗ | f [ε] = ε} of all such (normalised) functions carries a normalised subsequential structure, and that this object is final in NSubSeq with the behaviour map [ ] as the unique subsequential morphism into Φ. The subsequential structure on Φ is obtained as follows: We define τ : Φ → (1 + B∗ × Φ)A and ρ : Φ → 1 + B∗ by:


τ (f ) = ⟨f [a],f ·a⟩ if dom(f·a) /= ∅, otherwise τ (f ) = , ρ(f ) = f (ε).

(5)

Theorem 4.7 The subsequential structure Φ = (Φ, τ, ρ) is a ﬁnal object in the cat- egory NSubSeq of normalised subsequential structures and total subsequential mor- phisms.
Proof. We first show that derivatives are normalised. Let f : A∗ −−· B∗ and a ∈ A. By definition, (f ·a)[ε] = lcp({ f [a].f (aw) | aw ∈ dom(f )}) and f [a] = lcp({f (aw) | aw ∈ dom(f )}), hence (f ·a)[ε] = ε. It follows that τ is well-defined, and (Φ, τ, ρ) is a normalised subsequential structure.
In the rest of this proof we will denote the output and next-state components of τ by oτ and dτ , respectively. We show that if S = (Q, o, d, r) is a normalised sub- sequential structure, then the behaviour map h := [ ]]S : Q → Φ is a subsequential morphism, i.e., an S-coalgebra morphism. Recall that by definition of normalised structures, all states in S are coaccessible, hence [ ]]S is total.
Let q ∈ Q, and a ∈ A. We have: a ∈ supp(q) iff there exists a q' ∈ Q such that d(q)(a) = q'. By coaccessibility, this is equivalent with the existence of a w ∈ A∗ such that d(q)(aw) ∈ F , which in turn is equivalent with the existence of a w ∈ A∗ such that aw ∈ dom(h(q)), i.e., dom(h(q)·a) /= ∅, i.e., a ∈ supp(h(q)).

To see that oτ (h(q))(a) = o(q)(a), we note that, again by coaccessibility, o(q)(a) ≤ lcp([[q]](aA∗)) = h(q)[a], and since in particular d(q)(a) is normalised, we also have h(q)[a] ≤ o(q)(a), hence o(q)(a) = h(q)[a] = oτ (h(q))(a).
In order to show h(d(q)(a)) = h(q)·a, let w ∈ A∗, then

h(d(q)(a))(w) = o(d(q)(a))(w).r(d(d(q)(a))(w))

= o(q)(a).o(q)(aw).r(d(q)(aw))

= h(q)[a].h(q)(aw)
= (h(q)·a)(w).

Also ρ(h(q)) = h(q)(ε) = r(q). We leave it to the reader to verify that the map
h : (Q, o, d, r) → (Φ, oτ , dτ , ρ) is unique.	 
Remark 4.8 (final object in Coalg(S) and SubSeq) Note that Φ is not final in Coalg(S), since the behaviour map will not in general be an S-coalgebra morphism (cf. Lemma 4.3.(i)). However, Φ is also not final in SubSeq, where non-trivial β’s are allowed. The reason is that the behaviour map may fail to satisfy condition (supp) of Definition 3.5. For example, if a state q is coaccessible, but d(q)(a) is not, yet still present, then a ∈ supp(q) but a /∈ supp([[q]]). Adding a sink state (the empty map) to Φ will not solve this problem, since transitions between states with undefined behaviour cannot be matched (as required by (supp)) by transitions to/from the sink state.
Corollary 4.9 The normalised subsequential structure Φ = (Φ, τ, ρ) (as deﬁned in
(5)) is a ﬁnal object in CSubSeq.
Proof. This is a consequence of Theorems 4.5 and 4.7. There are several ways of formulating the proof, here is one: For any S ∈ CSubSeq, Theorem 4.5 tells us that there is a bijection of Hom-sets: CSubSeq(S, Φ) ∼= NSubSeq(N(S), Φ). Hence the unique morphism [ ]]N(S) : N(S) → Φ corresponds to a unique morphism hS : S → Φ.
Concretely, one can show that hS = ( [ ]]N(S), ε) ◦ (id Q, βˆS) = ( [ ]]N(S), βˆS) is the unique subsequential morphism from S to Φ.	 
Recall the minimal subsequential transducer Tf of a function f : A∗ → B∗ (cf. Definition 3.13). We now show that the existence and properties of Tf given in [6] are a consequence of Theorem 4.7. Recall the following notation. Given a function f : A∗ −−· B∗ in Φ, ⟨f⟩Φ denotes the subcoalgebra generated by f in (Φ, τ, ρ).
Corollary 4.10 (i) For any f : A∗ −−· B∗, Tf = (⟨f ·ε⟩Φ,f·ε, f [ε]).
For any trim subsequential transducer T = (S, i, m) and f = [[T]], the behaviour map [[ ]]N(S) is the unique subsequential transducer morphism (with witnessing function βˆS) from T onto the minimal subsequential transducer Tf .
Two subsequential transducers T1 and T2 are equivalent iff there exists a subse- quential transducer T and subsequential morphisms αj : Tj → T, for j ∈ {1, 2}.

Proof. Item (i): Almost immediate, left to the reader. Item (ii): The proof can be found in [6], but it follows essentially from (Φ, τ, ρ) being final in CSubSeq (Corol- lary 4.9) and item (i). Item (iii): The direction from right to left follows from the fact that subsequential transducer morphisms preserve behaviour (Proposition 3.9); the other direction follows from (ii).	 

Coalgebras for Sequential Transducers
A subsequential structure S = (Q, o, d, r) is sequential if dom(r) = Q and for all q ∈ Q : r(q) = ε. A sequential transducer T = (S, i) consists of a sequential structure S and an initial state i in S. Sequential transducers can thus be seen as the subsequential ones in which the initial prefix is the empty word ε, and all states are final with terminal output ε. We can therefore leave out m and r from the description of a sequential transducer, and simply write T = (Q, o, d, i). Moreover, from their definition it is immediate that a sequential structure is normalised, since for all states q, βˆ(q) = r(q) = ε.
Sequential transducers are treated in detail by Eilenberg [7] under the name generalised sequential machines. In particular, in Chapter XII of [7] the existence of a final sequential structure is proved, but without any mention of the words coal- gebra, finality and bisimulation. In this section, we give a coalgebraic formulation of Eilenberg’s [7] results, and relate them to the results of section 4.1.
First we look at the morphisms. By working out the details of Definition 3.5 we find that given two sequential structures S1 = (Q1, o1, d1) and S2 = (Q2, o2, d2), a function α : Q1 → Q2 is a subsequential morphism from S1 to S2 if for all q ∈ Q1:


(supp) supp(q) = supp(α(q)),
(next) ∀a ∈ supp(q) : α(d1(q)(a)) = d2(α(q))(a),
(out)n ∀a ∈ supp(q) : o1(q)(a) = o2(α(q))(a).


(6)

A subsequential morphism between sequential structures will simply be called a
sequential morphism.
Let the functor S0 : Set → Set be defined by: S0(X) = (1 + B∗ × X)A. It is easily seen that there is a 1-1 correspondence between sequential structures and S0-coalgebras by taking the transition structure t : Q → (1 + B∗ × Q)A as the coalgebra map (cf. Remark 3.2). Moreover, it follows almost immediately that a map α is a sequential morphism if and only if α is an S0-coalgebra morphism. Denote by Seq the category of sequential structures and sequential morphisms; and by SeqTra the category of sequential transducers and sequential transducer morphisms.
Proposition 4.11  (i) Seq is isomorphic to Coalg(S0),
(ii) SeqTra is isomorphic to PtCoalg(S0).
As a consequence we also have that, up to isomorphism, Coalg(S0) is a full subcategory of Coalg(S), and Seq is a full subcategory of NSubSeq. From now on we will use the words sequential structure and S0-coalgebra interchangeably.

Eilenberg [7] proves that the class of prefix-preserving functions carries a final se- quential structure. More precisely, he shows that for any sequential structure S and state q in S, the behaviour of q, [[q]]S : A∗ −−· B∗, is prefix-preserving, and [q]]S(ε) = ε. Let Ψ ⊆ Φ be the set Ψ = {f : A∗ −−· B∗ | f is prefix-preserving & f (ε) = ε}. It is straightforward to check that Ψ is closed under taking derivatives, hence it follows that Ψ = (Ψ, τTΨ, ρTΨ), (with τ and ρ are defined as in (5)) is a subcoalgebra of Φ. By definition, ρ(f ) = f (ε) = ε for all f ∈ Ψ, hence Ψ is a sequential structure.
Theorem 4.12 (Eilenberg [7]) The sequential structure Ψ is ﬁnal in Seq.
Proof. The proof can be found in Chapter XII of [7], but it also follows from the finality of Φ (Theorem 4.7). Let S be an arbitrary sequential structure. Viewing S as an object in NSubSeq, Theorem 4.7 tells us that the behaviour map [ ]] : S → Φ is the unique NSubSeq-morphism [ ]]S : S → Φ. Since the image of [ ]]S is contained in Ψ, it follows that [ ]]S : S → Ψ. Uniqueness in Seq follows from the uniqueness of [ ]]S in NSubSeq and the fact that Seq is fully embedded into NSubSeq.	 

Coalgebras for Differentials
The reason why subsequential structures, in general, cannot be seen as coalgebras essentially comes down to the fact that their semantics allows for asynchrony at internal computation steps, whereas the coalgebraic notion of equivalence requires synchrony at all steps. We have seen that normalisation is one way of eliminating internal asynchrony. In this section, we will see that for the class of subsequen- tial structures which have no internal states, and therefore also no proper internal computations, there is an alternative coalgebraic representation which can be com- puted locally. This should be seen in contrast with normalisation which requires the computation of βˆ. This computation is a global fixpoint computation involving all states of the structure ([6]). Call a subsequential structure S = (Q, t, r) step-by-step if dom(r) = Q (i.e. all states are final). A subsequential transducer (S, i, m) is step-by-step if S is step-by-step. Let Step denote the full subcategory of CSubSeq which has step-by-step subsequential structures as its objects.
Note that step-by-step subsequential transducers need not to be normalised, hence two step-by-step subsequential transducers can realise the same function without being in perfect synchrony. The differential (cf. [7,12,4]) captures this equivalence notion, for the behaviour of step-by-step subsequential transducers on nonempty words. Let f : A∗ −−· B∗ be a function with prefix-closed domain. The differential of f is the partial function Df : A+ −−· B(∗) defined on dom(f ) \ {ε} for all a ∈ A, w ∈ A∗ by

Df (wa) = f (w).f (wa).
Df describes f in a step by step manner, since for all w = a1a2 ... an ∈ dom(f ),
n ≥ 1, we have

f (w) = f (ε)Df (a1)Df (a1a2) ... Df (a1a2 ... an).	(7)

We also have

Df·w(a) = (f ·w)(ε).(f ·w)(a) = f [w]f (w).f [w]f (wa) = f (w).f (wa) = Df (wa) (8) from which it follows that for all w = a1a2 ... an ∈ dom(f ), n ≥ 1,
f (w) = f (ε) Df·ε(a1) Df·a1 (a2) Df·a1a2 (a3) ... Df·a1...an (an)	(9)
Proposition 4.13 A function f : A∗ −−· B∗ is realised by a step-by-step subse- quential transducer if and only if dom(f ) is preﬁx-closed.
Proof. Clearly, if f is realised by a step-by-step subsequential transducer, then dom(f ) is prefix-closed. To prove the other direction, it suffices to show that the minimal realisation ⟨f⟩Φ is step-by-step, that is, for all w ∈ A∗, if w ∈ dom(f ) then ε ∈ dom(f · w). But this is immediate from the definition of f · w, since (f ·w)(ε) = f [w].f (w).	 
We observe that for any step-by-step subsequential structure S = (Q, o, d, r) and q ∈ Q, the differential of the function [q]]S can be computed based on o, d and r. For all a ∈ A and w ∈ A∗, letting qw = d(q)(w), we have:

D[[q]]S (wa) = [[q]]S(w).[[q]]S(wa) = r(qw).o(qw)(a).r(qwa).	(10)

The above suggests that we can view step-by-step subsequential structures as coalgebras for the functor D : Set → Set defined by:


D(X)	= (1 + B(∗) × X)A
D(f : X → Y ) = (1 + IdB(∗) × f )IdA

(11)

Definition 4.14 (differential structure) Let S = (Q, o, d, r) be a step-by-step subsequential structure. We define for q ∈ Q and a ∈ A the function ∂S : Q → (A −−· B(∗)) by ∂S(q)(a) = r(q).o(q)(a).r(d(q)(a)). The differential structure of S is the D-coalgebra Dif(S) = (Q, δ), where δ : Q → (1 + B(∗) × Q)A is defined by
δ(q)(a) = ⎧⎨ ⟨∂S(q)(a), d(q)(a)⟩	if a ∈ supp(q),
⎩	otherwise.

For a step-by-step subsequential transducer T = (S, i, m) we define Dif(T) = (Dif(S), i), which we will also refer to as the differential automaton of the state i in S.
It should be clear that differential structures can be seen as sequential structures with output in B(∗). The notions of behaviour and realisation from Definition 3.3 therefore apply, with identity taken in B(∗) where appropriate. Also clear should be the fact that Seq and Coalg(S0) are full subcategories of Step and Coalg(D) respectively. We can extend Dif to a functor by letting Dif act as identity on morphisms.

Proposition 4.15 The map Dif( ) is a functor from Step to Coalg(D), and also from the category of step-by-step subsequential transducers to pointed D-coalgebras.
Proof. Let Sj = (Qj, oj, dj, rj), j = 1, 2, be step-by-step subsequential structures. We first claim that a function α : Q1 → Q2 is a subsequential morphism from S1 to S2 iff dom(α) = Q1 and for all q ∈ Q1 the following hold:

(supp)	supp(q) = supp(α(q)),
(next)	∀a ∈ supp(q) : α(d1(q)(a)) = d2(α(q))(a),
(out)s	∀a ∈ supp(q) : 

r1(q).o1(q)(a).r1(d1(q)(a)) = r2(α(q)).o2(α(q))(a).r2(d2(α(q))(a)),

(term-out)s r1(q).r2(α(q)) ∈ B∗.
To prove this claim, assume (α, β) : S1 → S2 is a subsequential morphism (cf. Def. 3.5). Since dom(r2) = Q2, the condition (acc) implies that α must be a total function. Furthermore, condition (term-out) implies that

β(q) = r1(q).r2(α(q)).	(12)
One can now easily verify that (out) reduces to (out)s. Conversely, for any total function α which satisfies the above requirements, we can define β : Q → B∗ using (12), since condition (term-out)s guarantees that β(q) ∈ B∗. It is now straightfor- ward to verify that (α, β) is a subsequential morphism. From the above characteri- sation, it clearly follows that α : S1 → S2 is a subsequential morphism if and only if α : Dif(S1) → Dif(S2) is a Coalg(D)-morphism.
Similarly, it is easy to see that α : S1 → S2 is a subsequential transducer mor- phism between step-by-step (S1, i1, m1) and (S2, i2, m2) if and only if
(init)  α(i1) = i2,
(ε-in)s m1.r1(i1) = m2.r2(i2).
In particular, α is a morphism of pointed D-coalgebras.	 
We note that Dif is not full. For step-by-step subsequential transducers this is clear, since the condition (ε-in)s is not guaranteed by PtCoalg(D)-morphisms. But also Dif : Step → Coalg(D) is not full. The following example shows this.
Example 4.16 Consider the following two simple step-by-step subsequential struc- tures.


,ab,
,ab,
,cb,
,b ,

S :	q1 	a|aa	 s1	S :	q2 	a|caa	 s2 
It is easy to see that Dif(S1) and Dif(S2) are both isomorphic to the following

D-coalgebra:


S :	q	a|baab	 s 

Hence if we define α(q1) = q2 and α(s1) = s2, then α : Dif(S1) → Dif(S2) is a Coalg(D)-morphism, however α is not a subsequential morphism between S1 and S2, since condition (term-out)s fails at q1.
Proposition 4.15 tells us that step-by-step subsequential structures can be prop- erly viewed as coalgebras without having to normalise. We now show that D- bisimilarity in the differential structure exactly captures equality of differentials, and hence equivalence of step-by-step transducers modulo the behaviour on ε. The definition of D-bisimulation amounts to the following. Let (Q1, ⟨∂1, d1⟩) and (Q2, ⟨∂2, d2⟩) be D-coalgebras. A relation R ⊆ Q1 × Q2 is a D-bisimulation if and only if for all ⟨q1, q2⟩∈ R, we have for all a ∈ A, ∂1(q1)(a) = ∂2(q2)(a) (in the free group B(∗)), and ⟨d1(q1)(a), d2(q2)(a)⟩∈ R.
Proposition 4.17 Let T1 = (S1, q1, m1) and T2 = (S2, q2, m2) be step-by-step sub- sequential transducers, where S1 = (Q1, t1, r1) and S2 = (Q2, t2, r2). We have:
D[[q1]]1 = D[[q2]]2  iff Dif(S1), q1 ∼ Dif(S2), q2.
[T1]] = [[T2]] iff m1.r1(q1) = m2.r2(q2) and Dif(S1), q1 ∼ Dif(S2), q2.
Proof. Item (i), sketch only: (⇒) Show that R = {⟨d1(q1)(w), d2(q2)(w)⟩| w ∈ A∗} is a D-bisimulation. (⇐) Use (10). Item (ii): By definition, for j = 1, 2 and all w = a1 ... an ∈ A∗ (i.e. n ≥ 0) we have:


[[T ]](w) = m .[[q ]]
(=7)
m .r (q ).D
(a ) ...D 
(a ...a ).

j	j	j j
j  j j
[[qj ]]j	1
[[qj ]]j	1	n

Item (ii) now follows easily from (i).	 
The main advantage of using the differential structures to decide equivalence is probably that in order to check D-bisimilarity it is not be necessary to store a representation of the differential structures, since for any step-by-step S, ∂S can be computed on the fly from a representation of S (cf. Def. 4.14). Checking S- bisimilarity of the normalisations, however, requires explicit computation of βˆ, and explicit storage of βˆ or the normalised structures themselves.
The final result of this section states that bisimilarity in the differential struc- tures coincides with bisimilarity in the normalised structures. We start with the following easy observation (the proof is obtained by writing out the details).
Lemma 4.18 For any step-by-step subsequential structure S, Dif(S) = Dif(N(S)).
Theorem 4.19 If S1, S2 are step-by-step subsequential structures, and q1, q2 are states in S1, respectively S2, then
N(S1), q1 ∼ N(S2), q2	iff	Dif(S1), q1 ∼ Dif(S2), q2.
Proof. Let S1 = (Q1, t1, r1) and S2 = (Q2, t2, r2) be step-by-step subsequential structures; q1 ∈ Q1, q2 ∈ Q2, and let u1 and u2 denote the terminal output of

q1 and q2 in N(S1) and N(S2), respectively. We have: N(S1), q1 ∼ N(S2), q2 iff (by Thm. 4.7) [[q1]]N(S1) = [[q2]]N(S2) iff [[(N(S1), q1, ε)]] = [[(N(S2), q2, ε)]] iff (Prop. 4.17.(ii)
and Lemma 4.18) u1 = u2  and  Dif(S1), q1 ∼ Dif(S2), q2.  It therefore suf-
fices to show that u1 = u2 follows from Dif(S1), q1 ∼ Dif(S2), q2. So assume Dif(S1), q1 ∼ Dif(S2), q2. If supp(q1) = supp(q2) = ∅. then βˆ1(q1) = r1(q1) and βˆ2(q2) = r2(q2), hence u1 = ε = u2. Now suppose a ∈ supp(q1) = supp(q2). We then have that r1(q1) = βˆ1(q1)u1, r2(q2) = βˆ2(q2)u2; and o1(q1)(a) = βˆ1(q1)w1, o2(q2)(a) = βˆ2(q2)w2 for some w1, w2 ∈ A∗. From Dif(S1), q1 ∼ Dif(S2), q2 it follows that ∂S (q1)(a) = ∂S (q2)(a), that is, u1w1r1(s1) = u2w2r2(s2). Since βˆ1(q1) and
1	2
βˆ2(q2) are maximal, it follows that u1 = u2.	 
Theorem 4.19 implies that we can obtain a minimal Coalg(D)-representation of a step-by-step T by quotienting Dif(T) with D-bisimilarity. This could be an interesting alternative to computing the minimal realisation of [T ] via normalisation and quotienting N(T) with S-bisimilarity. Of course, an actual implementation of a step-by-step T should be based on the minimal realisation of [T]], since the output produced by Dif(T) would have to be reduced in the free group in order to obtain the behaviour. The following example illustrates the difference between the two types of minimal realisations.
Example 4.20 (minimal realisations) Consider the following transition dia- gram of a step-by-step subsequential structure S = (Q, o, d, r), and its differential structure Dif(S):


,b ,
S :	J,˜¸0` z,¸


a|ab
,ba,
J, ˜¸1`  z,,¸b|ba


Dif(S) :	J,˜¸0` z,¸


a|babba


J, ˜¸1`  z,,¸b|ba



a|ab
,¸,¸¸¸¸
¸¸¸¸¸


a|bab
  


a|bb
,¸,¸¸¸¸
¸¸¸¸¸


a|bb
  

b|ab
J,˜¸3` z,¸,
¸J,z˜¸J` z, b|b
b|ba
J,˜¸3` z,¸,
¸J,z˜¸J` z, b|b

¸,
caz
a|abb
2 ,¸ cb z
¸, a|babba
2 ,¸

For i ∈ {0, 1, 2, 3}, let fi = [[i]]S. We then find that: f0(ε) = r(0) = b, f1(ε) = r(1) = ba, f2(ε) = r(2) = b, and f3(ε) = r(3) = a. It can easily be checked that the relation R = {⟨0, 2⟩; ⟨1, 3⟩; ⟨0, 0⟩; ⟨1, 1⟩; ⟨2, 2⟩; ⟨3, 3⟩} is the maximal D-bisimulation on Dif(S). This tells us that Df0 = Df2 and Df1 = Df3 . Furthermore, since f0(ε) = f2(ε), we can conclude that f0 = f2. We can obtain a minimal sequential transducer with output in B(∗) which realises f1 by quotienting Dif(S) with R and
initialising this structure with the macro state containing 1, and adding initial prefix
f1(ε) = ba. (Similarly for the functions f0, f2 and f3):


(Dif(S)/R, 1, ba) : 

a|babba
J,0˜¸,` 2\,  ¸ 
    
zJ,1˜¸ ` 3\, , ba

b|b	 ¸

a|bb

Alternatively, we could compute and minimise N(S). It can easily be verified that:

βˆ(0) = ε,
βˆ(1) = ba,
βˆ(2) = ε,
βˆ(3) = a. We now obtain a minimal realisa-

tion of f1 by quotienting N(S) with R, initialising with the macro state {1, 3} and adding the initial prefix βˆ(1) = ba. N(S) and (N(S)/R, 1, ba) are illustrated below:

,b ,
N(S) :	J,˜¸0` z,¸


a|abba
,ε ,
J, ˜¸1`  z,,¸b|ba

(N(S)/R, 1, ba) : 


a|b
,¸,¸¸
¸b¸|b

a|b

,,	,,	.

¸¸¸¸¸ J	 b
a|abba	
ε .....

b|ba
J,˜¸3` z,¸,	J,z˜¸2` z,
b|b
J,0˜¸,` 2\, ¸	
zJ,1˜¸, ` 3\,.,cba

 ¸,
cε z
a|abba
,¸ cb z
b|b  ¸


a|b


Summary and Discussion
In the diagram below right we provide an overview of the relationships between the various classes of subsequential structures and coalgebras that have been studied

in this paper. The inclusion arrows indicate embeddings of categories; a double-headed arrow indicates that the
SubSeq ¸,
,,
(not full!)
rzCoalg(S)
full	 ¸,,

embedding is surjective on objects; and
the labels ‘full’, ‘refl’ and ∼ indicate
,r	 N  
¸,....

CSubSeq ¸,  zNSubSeq
full

whether the embedding is full, reflective or an isomorphism, respectively. The functors N (normalisation) and Dif (dif-
,,,¸,refl
,,,
,,
r	,,
full
,r	,r

ferential) are also indicated.
We note that the coalgebraic mod-
full
,,,,
,,,
,
Seq
˛z
full
¸,∼
 C oalg(S0)
˛z
full

elling of normalised and step-by-step
subsequential structures does not cap- ture the initial prefix.	However, this
,¸tJ	J 
Step 	Dif	 C oalg(D)

does not cause any essential problems. For example, when deciding equivalence of step-by-step subsequential transducers, the initial prefix only requires one com- parison (constant time) in addition to the time to decide bisimilarity equivalence.
The presence of internal states in a non-normalised subsequential transducer is the main reason why the coalgebraic notions of morphism and bisimilarity are not appropriate in such structures. Rather than transforming the subsequential transducer, one could perhaps try to look for alternative equivalence notions along the lines of weak bisimilarity. Unfortunately, weak bisimilarity in coalgebras is not very well understood, although some results may be found in [14,18]. As another possible direction for future work, we mention applying the regular expressions for polynomial coalgebras of [3] to normalised and step-by-step structures. These regular expressions provide a formal language for reasoning about and specifying coalgebras for polynomial functors, which include both normalised and step-by-step subsequential structures. As the main application of [3], we would get a symbolic synthesis method which constructs from a regular expression (of the relevant type) a normalised or step-by-step subsequential transducer. Moreover, the normalisation

procedure of [3] could perhaps be refined to deal with associativity of the join such that transducer equivalence can be determined symbolically by comparing normal forms of regular expressions.

References
Ad´amek, J., H. Herrlich and G. Strecker, “Abstract and Concrete Categories: The Joy of Cats,” J. Wiley and Sons, 1990, online version: http://katmat.math.uni-bremen.de/acc.
B´eal, M.-P. and O. Carton, Determinization of transducers over finite and infinite words., Theoretical Computer Science 289 (2002), pp. 225–251.
Bonsangue, M. M., J. J. M. M. Rutten and A. M. Silva, Regular expressions for polynomial coalgebras, Technical Report SEN-E0703, Centrum voor Wiskunde en Informatica (CWI) (2007).
Bruy`ere, V. and C. Reutenauer, A proof of Choffrut’s theorem on subsequential functions, Theoretical Computer Science 215 (1999), pp. 329–335.
Choffrut, C., A generalisation of Ginsburg and Rose’s characterization of g-s-m mappings, in:
Proceedings ICALP 1979, LNCS 71 (1979), pp. 88–103.
Choffrut, C., Minimizing subsequential transducers: A survey, Theoretical Computer Science 292
(2003), pp. 131–143.
Eilenberg, S., “Automata, Languages and Machines (Vol. A),” Academic Press, 1974.
Hansen, H., D. Costa and J. Rutten, Synthesis of Mealy machines using derivatives, in: Proceedings of the 8th Workshop on Coalgebraic Methods in Computer Science (CMCS 2006), Vienna, Austria, ENTCS 164(1) (2006), pp. 27–45.
Mohri, M., Finite-state-transducers in language and speech processing, Computational Linguistics 23
(1997), pp. 269–311.
Pattinson, D., Coalgebraic modal logic: Soundness, completeness and decidability of local consequence, Theoretical Computer Science 309 (2003), pp. 177–193.
Raney, G., Sequential functions, Journal of the ACM 5 (1958), pp. 177–180.
Reutenauer, C., Subsequential functions: Characterizations, minimization, examples., in: IMYCS, LNCS 464, 1990, pp. 62–79.
Rutten, J., Automata and coinduction (an exercise in coalgebra), in: D. Sangiorgi and R. de Simone, editors, Proceedings CONCUR’98, LNCS 1466 (1998), pp. 194–218.
Rutten, J., A note on coinduction and weak bisimilarity for while programs, Technical Report SEN- R9826, Centrum voor Wiskunde en Informatica (CWI) (1998).
Rutten, J., Universal coalgebra: a theory of systems, Theoretical Computer Science 249 (2000), pp. 3– 80.
Schr¨oder, L. and D. Pattinson, Pspace bounds for rank-1 modal logics, in: Proceedings 21st Annual IEEE Symposium on Logic in Computer Science (LICS 2006), 2006, pp. 231–242, extended version to appear in ACM Transactions on Computational Logics.
Schu¨tzenberger, M., Sur un variante des fonctions sequentielles, Theoretical Computer Science 4
(1977), pp. 47–57.
Sokolova, A., E. de Vink and H. Woracek, Weak bisimulation for action-type coalgebras, in: Proceedings of Category Theory and Computer Science (CTCS’04), 2005, pp. 211–228.
Venema, Y., Automata and fixed point logic: a coalgebraic perspective, Information and Computation
204 (2006), pp. 637–678.
