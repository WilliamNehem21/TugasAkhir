Electronic Notes in Theoretical Computer Science 138 (2005) 43–60	
www.elsevier.com/locate/entcs

Synchronization Algebras with Mobility for Graph Transformations *
Ivan Lanese and Ugo Montanari1 ,2
Dipartimento di Informatica Universit`a di Pisa
Pisa, Italy

Abstract
We propose a generalization of synchronization algebras that allows to deal with mobility and local resource handling. We show how it can be used to model communication primitives for distributed and mobile computations, such as the ones used in the global computing area. We propose a graph transformation formalism in the Synchronized Hyperedge Replacement approach which is parametric w.r.t. the synchronization algebra and thus allows to model complex systems based on the chosen communication primitives. We thus unify different models described in the literature and we allow to easily define new ones. We present various examples and a case study on Fusion Calculus, showing how different semantics for it can be derived using different synchronization algebras.
Keywords: graph transformation, Synchronized Hyperedge Replacement, synchronization algebra, mobility, Fusion Calculus.


Introduction
Global computing (GC) deals with huge computational systems which are deployed on world-scale areas. In order to develop, analyze and manage such a complex kind of systems, where different issues like coordination, security and mobility interact, suitable formal tools are required.

  Research supported in part by EU-FET project AGILE IST-2001-32747.
1 Email: lanese@di.unipi.it
2 Email: ugo@di.unipi.it




1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.05.004

We argue that these systems must be analyzed at different levels of ab- straction. In particular, at the low level, protocols and algorithms must be developed to build an efficient and reliable middleware out of basic infrastruc- tures which are usually asynchronous and unreliable. At the higher level, the primitives that are defined in the middleware must be used to coordinate the evolution of the different subsystems. In the GC scenario we may have also complex synchronization primitives involving multiple computational entities, thus we need a suitable way to model them, and then we need a framework to describe large systems based on these primitives.
In order to make the implementation step easier, computation must be dis- tributed, and the coordination part must be clearly individuate. In particular, computations that require a strong knowledge on the topology of the whole system must be disallowed, since this knowledge is usually not available.
We choose graphs (or, more precisely, hypergraphs) as basic model, since they have a suggestive representation and they naturally model the topology of distributed systems. We associate to graphs the following computational interpretation: edges represent processes or subsystems, while nodes model channels or ports. Communication is performed via shared nodes.
Computation is modelled by graph transformations in the Synchronized Hyperedge Replacement (SHR) approach [2]. In this framework, context-free productions describe the local evolution of an edge. Such a kind of productions can easily be implemented since it involves just one component. In order to specify complex reconfigurations, we introduce a synchronization mechanism based on constraints imposed on shared nodes to decide which productions can be applied in a single step. We also want to model mobility directly, and we use name mobility in the Fusion Calculus [14] style to do that [7,4].
The approach based on local productions differentiates SHR from other graph transformation frameworks such as Double Pushout [3] and Bigraphs [5], where rules with arbitrarily complex left-hand side are used, and it allows a distributed implementation [2].
We propose a framework where the synchronization and the mobility pat- terns are specified by a suitable algebra, which extends synchronization alge- bras [15]. With respect to standard synchronization algebras our approach is also able to deal with mobility and local resource handling, which are two essential features of GC systems.
Synchronization algebras with mobility allow both to recover the synchro- nization models presented in the literature for SHR [4,12,9] and to easily define more complex ones. This is important since the models in the literature are quite low level, while complex high level primitives are useful for GC.
We present many examples to show both how synchronization algebras

with mobility can be used to specify synchronization primitives and how SHR can be used to model scenarios of interest for global and ubiquitous computing. As an interesting case study we present a mapping from Fusion Calculus
[14] (a process algebra that extends π-calculus [13] with the concept of fusion) into SHR. As proved in [11] an operational correspondence exists between Fusion Calculus and SHR with Milner synchronization. We show that using synchronization algebras different semantics can be provided for Fusion Cal- culus, thus allowing to apply it to systems based on different communication primitives.

Structure of the paper
The background on graphs, Synchronized Hyperedge Replacement and synchronization algebras is presented in §2. In §3 we present synchronization algebras with mobility while §4 contains the rules for parametric SHR. Some examples are shown in §5 and a case study on Fusion Calculus is discussed in
§6. Finally §7 presents conclusions and traces for future work.

Background
Graphs as syntactic judgements
We want to model systems using hypergraphs, which generalize graphs al- lowing (hyper)edges to be connected to any number of attachment nodes. In particular, we use (hyper)graphs with labelled edges, that is an edge is an atomic item with a label (from a ranked alphabet LE = {LEn}n=0,1,...) and with as many ordered tentacles as the rank rank(L) of its label L. A set of nodes, together with a set of such edges, forms a graph if each edge is con- nected, by its tentacles, to its attachment nodes. A graph is connected to its environment by an interface which is a subset of its nodes. Nodes in the interface are called free nodes, while other nodes are said bound. We con- sider graphs up to isomorphisms that preserve free nodes, labels of edges, and connections between edges and nodes.
We use a linear representation for graphs as (syntactic) judgements which is more suitable for defining transformations [8]. In this representation nodes correspond to names, free nodes to free names and edges to basic terms of the form L(x1,... , xn), where xi are arbitrary names and L ∈ LEn. We use a constant nil to represent the empty graph, a parallel composition operator
| to build large graphs from smaller ones and a ν operator to bind nodes.
Definition 2.1 (Graphs as judgements) Let N be a ﬁxed inﬁnite set of names and LE a ranked alphabet of labels. A judgement is of the form Γ ▶ G



Table 1
Structural congruence for graph terms.

where:
Γ ⊆N is a ﬁnite set of names (the free nodes of the graph);
G is a term generated by the grammar
G ::= L(x) | G|G | νy G | nil
where x is a vector of names, L is an edge label with rank(L)= |x| and
y is a name.
We deﬁne the restriction operator ν as a binder. We denote with fn the function that given a term G returns the set fn(G) of free names in G. We demand that fn(G) ⊆ Γ.
When defining the interfaces, we use the notation Γ,x to denote the set obtained by adding x to Γ, assuming x ∈/ Γ and Γ1, Γ2 to denote the union of Γ1 and Γ2, assuming Γ1 ∩ Γ2 = ∅.
Graph terms are considered up to the axioms of structural congruence in Table 1. As far as judgements are concerned, we define Γ ▶ G ≡ Γ' ▶ G' iff Γ= Γ' and G ≡ G'.
Axioms (AG1), (AG2) and (AG3) define respectively the associativity,
commutativity and identity over nil for operation |. Axioms (AG4) and (AG5) state that nodes of a graph can be hidden only once and in any order. Axiom (AG6) defines α-conversion of a graph w.r.t. its bound names. Axiom (AG7) defines the interaction between restriction and parallel composition.
Note that function fn is well-defined on equivalence classes.
Theorem 2.2 (Soundness of the representation [6]) Judgements up to structural congruence are isomorphic to graphs up to isomorphisms.

Synchronized Hyperedge Replacement
We introduce here Synchronized Hyperedge Replacement (SHR) [2,7,4], a graph transformation formalism where transitions are specified by synchro- nizing context-free productions which describe how single edges are rewritten. A production rewrites an edge into a graph with the same interface, and it exposes actions on the nodes of its interface. Actions are constraints, and a set of productions can be applied in one step if the constraints imposed on

shared nodes are compatible. Tuples of references to nodes are attached to actions, and represent names that are communicated during the synchroniza- tion. Furthermore productions can force merges among nodes in the interface via a suitable substitution.
We use a notation based on judgements also for transitions.
Definition 2.3 (SHR transition) Let Act be a set of actions, and given
a ∈ Act let ar(a) be its arity. A SHR transition is of the form:


Γ ▶ G −−→
Φ ▶ G'

where Γ ▶ G and Φ ▶ G' are judgements for graphs, Λ : Γ → (Act × N ∗) is a total function and π : Γ → Γ is an idempotent substitution. Function Λ assigns to each node x the action a ∈ Act and the vector y of node references exposed on x by the transition (in a more message-passing view, we say that
node references are sent to x). If Λ(x) = (a, y) then we deﬁne actΛ(x) = a
and nΛ(x)= y. We require that ar(actΛ(x)) = | nΛ(x)|.
We deﬁne:
n(Λ) = {z|∃x.z ∈ nΛ(x)}   set of exposed names;
ΓΛ = n(Λ) \ Γ  set of fresh names that are exposed.
Substitution π allows to merge nodes. Since π is idempotent, it maps every node into a standard representative of its equivalence class. We require that
∀x ∈ n(Λ).π(x) = x, i.e. only references to representatives can be exposed. Furthermore we require Φ = π(Γ) ∪ ΓΛ, namely free nodes are never erased (⊇) and new nodes are bound unless exposed (⊆).
Note that the set of free names Φ of the resulting graph is fully determined by Λ and π (since Γ = dom(Λ)).
When writing Λ as set of pairs we write the triple (x, a, y) for the pair (x, (a, y)).
SHR transitions are derived from basic production schemas using suitable sets of inference rules (see §4).
Definition 2.4 (Production schema)
A production schema is an SHR transition of the form:
x1,... , xn ▶ L(x1,... , xn) −−→ Φ ▶ G
where all xi, i = 1,... ,n are distinct.
We suppose to have for each edge label L of arity n a special idle pro-
Λc,id
duction schema x1,... , xn ▶ L(x1,... , xn) −−−→ x1,... , xn ▶ L(x1,... , xn)
where Λє(xi)= (ϵ, ⟨⟩) for each i (ϵ is a special “idle” action with ar(ϵ) = 0).
When we have a production schema we suppose to have also all the production

schemas obtainable through α-conversion of names in {x1,... , xn}∪ Φ.
Synchronization algebras
We present here synchronization algebras, which were proposed in [15] to deal with synchronizations among processes, as they are performed e.g. in CCS. We use here a slightly different presentation in order to be consistent with standard SHR notation.
In general, we consider a framework where processes can do actions, and actions may or may not synchronize. Suppose that two processes P and P ' can do respectively actions a and a'. If actions a and a' synchronize then their synchronized execution corresponds to just one action, otherwise they can not be executed together. Since an action can also be performed asynchronously, we must introduce also an action ϵ that denotes “no action”. Thus the syn- chronized execution of a and ϵ corresponds to the asynchronous execution of
a, while P ' stays idle.
Definition 2.5 (Synchronization algebra)
A synchronization algebra < Act, •,ϵ > consists of a binary, partial, associa- tive and commutative operator • on a set of actions Act, which includes a distinguished element ϵ. We require that ∀a, b ∈ Act.a • b = ϵ iff a = b = ϵ and that ϵ is not the only action in Act.
The binary operator • says how actions combine to form synchronized actions: if a • b is undefined then a and b can not synchronize, otherwise a • b is the composed action. The additional condition requires that actions never disappear, thus the result of synchronizing two non ϵ actions can never be ϵ.

Synchronization algebras with mobility
We present here a generalization of synchronization algebras [15] which can also deal with mobility and local resource handling. In particular, we are in- terested in name mobility in the Fusion Calculus [14] style, where the mobility of a process is modelled by merging channels controlled by the process with channels controlled by other processes, thus modelling their proximity.
We attach to each action a tuple of references to channels, and when ac- tions synchronize a pattern of fusions among channels must be specified. Ref- erences to the resulting channels are attached to the synchronized action. In our framework, a channel may be either public or shared among a group of processes (thus modelling a local resource). On local channels we can have only complete synchronizations, namely synchronizations that do not require any further action. On the other channels we may also have partial synchro-

nizations which will be completed by actions provided by the environment.
We present now the formal definition of synchronization algebra with mo- bility, which takes into account all these aspects.
As a notation, we use  to denote disjoint set union. In A  B we denote with [1, n] (resp. [2, n]) the element that corresponds to n ∈ A (resp. n ∈ B).
Definition 3.1 (Synchronization algebra with mobility)
A synchronization algebra with mobility < Act, •, ϵ, Mob, Init, F in > consists of a binary partial operator • on a set of actions Act which includes a distin- guished element ϵ of arity 0, a set of mobility patterns Mob and two subsets Init and F in of Act. Here Mob is a set indexed by pairs of actions, and the el- ement indexed by (a, b) is a partial function from {1,... , ar(a)} {1,... , ar(b)} to {1, 2,... }.
We require the following conditions to hold:
the • operator is associative and commutative;
∀a, a' ∈ Act.a • a' = ϵ iff a = a' = ϵ;
∃a ∈ Act.a /= ϵ;
ϵ ∈ Init, ϵ ∈ F in;
∀i ∈ Init, a ∈ Act either i • a is undeﬁned or i • a = a;
∀a ∈ Act.∃i ∈ Init.i • a = a;
∀a, b, c ∈ Act
∀x ∈ {1,... , ar(a)}. Moba•b,c([1, Moba,b([1, x])]) = Moba,b•c([1, x]),
∀x ∈ {1,... , ar(b)}. Moba•b,c([1, Moba,b([2, x])]) = Moba,b•c([2, Mobb,c([1, x])]),
∀x ∈ {1,... , ar(c)}. Moba•b,c([2, x]) = Moba,b•c([2, Mobb,c([2, x])]);
∀a, b ∈ Act, x ∈ {1,... , ar(a)}. Moba,b([1, x]) = Mobb,a([2, x]);
∀a, b ∈ Act.Moba,b is surjective on {1,... , ar(a • b)}.
With respect to standard synchronization algebras, now actions in Act have a specified arity, which corresponds to the number of references that are sent with them. A mobility pattern Moba,b specifies how to build the references attached to a • b starting from the references attached to a and b. The correspondence is just positional as in usual procedure calls, but many “parameters” can be assigned to just one position. In that case the parameters are merged and a representative is assigned to the chosen position.
Simple message passing is specified by a set of mobility patterns MP that merges corresponding references and assigns the result to the corre- sponding position. Formally, MPa1 ,a2 ([n, x]) = x for each n ∈ {1, 2}, x ∈
{1,... , ar(an)}.
F in is the set of complete synchronizations. Init is a set of “trivial” actions

which can be done on channels which are not connected to any process. This is required since we want to be able to merge channels, and we want to be always able to synchronize an action i done on an isolated channel with a generic action a without altering a, since no new connection is established when a channel is merged with an isolated channel.
Conditions i, ii, iii are already present in normal synchronization algebras. Condition iv assures that the “no action” is always allowed. Conditions v and vi guarantee respectively that trivial actions never influence synchroniza- tion and that given a generic action, there exists a trivial action that can be synchronized with it. Conditions vii and viii state that mobility patterns are associative and commutative. Finally, condition ix guarantees that each refer- ence attached to the composed action can be computed, that is it corresponds to a non empty set of references from component actions.
We present now some simple examples, some more complex ones are in §5. We just write the cases where • is defined. We skip cases that can be derived by commutativity. Furthermore, if not otherwise stated, Mob = MP .
Example 3.2 (Milner synchronization algebra)
Given a set of actions Act = {ai}i∈I ∪ {ai}i∈I ∪ {τ, ϵ} where ar(ai) = ar(ai)
and ar(τ )=0 we deﬁne the Milner synchronization algebra on Act as follows:
a • ϵ = a for each a ∈ Act,
a • a = τ for each a ∈ {ai}i∈I;
F in = {τ, ϵ}, Init = {ϵ}.
The Milner synchronization algebra models message passing, where actions
ai/ai are inputs/outputs and τ stands for a complete message exchange.
Example 3.3 (Hoare synchronization algebra)
Given a set of actions Act we deﬁne the Hoare synchronization algebra on Act
as follows:
a • a = a for each a ∈ Act;
F in = Act, Init = Act.
The Hoare synchronization algebra models an agreement among partici- pants on the action to be done, in the CSP style.
Example 3.4 (Broadcast synchronization algebra)

Given a set of actions Act = {ai}i∈I ∪ {ai}i∈I ∪ {ϵ} where ar(ai)= ar(ai) we deﬁne the broadcast synchronization algebra on Act as follows:

a • a = a for each a ∈ {ai}i∈I, a • a = a for each a ∈ {ai}i∈I, ϵ • ϵ = ϵ;

- F in = {ai}i∈I ∪ {ϵ}, Init = {ai}i∈I ∪ {ϵ}.
The broadcast synchronization algebra models secure broadcast, where one process performs an output and all the others perform input.

Parametric Synchronized Hyperedge Replacement
We present here a set of rules for deriving SHR transitions from productions, which is parametric on a synchronization algebra with mobility. Thus we can instantiate the rules for each synchronization model.
As already said, in our approach edges model processes, nodes model chan- nels and free nodes model public channels. It is worth noting that nodes are bound when they are created, since they are not known by the environment. A bound node becomes free (we say that it is extruded) when it is merged with a free node or when a reference to it is exposed on a free node.
As notation we use f |S (resp. f |\S) to denote the restriction of function f to the new domain S (resp. dom(f ) \ S). We also use v[n] to denote the nth element of vector v and Set(v) to denote the set of elements of v.
Definition 4.1 (Rules for parametric SHR)


(par)
Γ1 ▶ G1
Λ1,π1
Φ1 ▶ G'
Γ2 ▶ G2
Λ2,π2
Φ2 ▶ G'

Γ , Γ
▶ G |G
Λ1∪Λ2,π1∪π2
Φ , Φ
▶ G' |G'

1	2	1
2 −−−−−−−→	1	2	1	2



if (Γ1 ∪ n(Λ1)) ∩ (Γ2 ∪ n(Λ2)) = ∅.
Λ,π
Γ, x,y ▶ G −−→


Φ ▶ G'

(merge)


Γ,x ▶ Gσ Λ',π' Φ' ▶ νU G'σρ

where:
σ = {x/y};
Λ(x)= (a1, v1), Λ(y)= (a2, v2);
c = a1 • a2;
S1 = {vi1 [j1]= vi2 [j2]| Moba1 ,a2 ([i1, j1]) = Moba1 ,a2 ([i2, j2])};
S2 = {t = u|t, u ∈ Γ, x,y ∧ tπ = uπ};
ρ = mgu({(S1 ∪ S2)σ}) where we choose nodes in Γ,x as representatives whenever possible;
w[i]= (vj[k])σρ if Moba1 ,a2 ([j, k]) = i, i ≤ ar(c);

Λ'(z)= ⎧⎨ (c, w) if z = x
(actΛ(z), (nΛ(z))σρ) for each z ∈ Γ
π' = ρ|Γ,x;
U = Φσρ \ Φ'.

(res)
Γ,x ▶ G −−→ Φ ▶ G'

where:
Λ|\{x},π|\{x}
Γ ▶ νx G −−−−−−−→
Φ' ▶ νZ G'

(xπ = yπ ∧ x /= y) ⇒ xπ /= x;
actΛ(x) ∈ F in;
Z =Φ \ Φ'.
(new)





Λ,π
Γ ▶ G −−→




Φ ▶ G'

Λ∪{(x,i,y)},π
Γ,x ▶ G −−−−−−−→
Γ, x, Set(y) ▶ G'

for each i ∈ Init and each vector y of names such that Set(y) ∩ (Γ,x ∪
n(Λ)) = ∅ and ar(i)= |y|.
Rule (par) allows to perform the union of two transitions provided that they have disjoint sets of free names (accounting also for newly generated names).
Rule (merge) is the rule for synchronization. It allows to compute the ef- fect of merging two nodes x and y with synchronizations (a1, v1) and (a2, v2) respectively on them. The synchronization is allowed iff the composed action a1 • a2 is defined. In this case two sets of equations among names are com- puted. S1 accounts for merging names that are mapped to the same position by Mob (note that merges are performed even if the resulting representative is not attached to the final action), while S2 accounts for previous merges traced by π. We then compute ρ by applying the substitution σ to S1 and S2 and then choosing a representative for each equivalence class. If at least one of the members of the class is in Γ, x, then one of them must be chosen (otherwise unjustified renamings of nodes may happen). After that the new vector w is generated, by choosing for each position the representative of the corresponding equivalence class. We can then compute the new synchroniza- tion Λ', which takes into account the performed merges. Merges on nodes
in the interface are traced by π'. Finally, nodes which are no more extruded
(because the synchronization discarded them) are bound.
Rule (res) binds nodes. According to the first condition, the bound node must not be the representative of the equivalence class induced by π when

the class is not trivial. Furthermore a node can be bound only if a complete action takes place on it. Nodes that were extruded just on the bound node must be bound now, and thus they are in Z.
Rule (new) allows to add an isolated node to the interface, on which the trivial actions in Init can be exposed, with fresh names.
We show here that this framework can be instantiated in order to recover the SHR models in the literature.
Theorem 4.2 Let Γ ▶ J be a graph. With a ﬁxed set of productions, we can

Λ,π
derive a transition Γ ▶ J −−→
Φ ▶ J' using the inference rules in Deﬁnition

(excluded (new)) instantiated with the Milner synchronization model iff

Λ',π
we can derive, using the rules in [4], a transition Γ ▶ J −−→
Φ ▶ J' where

Λ'(x)= Λ(x) iff Λ(x) /= (ϵ, ⟨⟩) and Λ'(x) is undeﬁned otherwise.
The theorem states that the framework presented in [4] is an instance of ours with Milner synchronization, where undefined is used instead of (ϵ, ⟨⟩).
Theorem 4.3 Let Γ ▶ J and J' be graphs without restrictions. With a set

Λ,π
of productions S, we can derive a transition Γ ▶ J −−→
Φ' ▶ νX J' using the

inference rules in Deﬁnition 4.1 instantiated with the Hoare synchronization

Λ,π
model iff we can derive a transition Γ ▶ J −−→
Φ',X ▶ J' using the rules in

[12] (or [10]) and a set of productions obtained from S by removing all the
restrictions (after having chosen fresh names for bound names).
This theorem states that the framework in [12,10] is an instance of this one with Hoare synchronization, where restriction is not considered.


Examples
We show here some examples on how to use SHR and on how to define syn- chronization algebras with mobility. We start with a simple example that uses the Hoare synchronization model.
Example 5.1 (The replicating net) We deﬁne here a simple net that can evolve when the same action is exposed on all the nodes in its interface. If the used action has arity n then the net creates n copies of itself, attached to the nodes whose references were exposed on the interface.
We must have one production schema for each allowed action and each edge label. We show here just the production for an action a with ar(a) = 1







x (a,<r>)




y
(a,<s>)


 z (a,<t>)

y

x

z

s

r

t
y
(a,<s>)















x






(a)


y


w

x (a,<r>)
N	N

z (a,<t>)

w (a,<u>)



r

z s





t

(b)

u

Fig. 1. Production (a) and transition (b) of a replicating net.
and an edge labelled by N with rank(N)= 3.

{(x,a,⟨r⟩),(y,a,⟨s⟩),(z,a,⟨t⟩)},id
x, y, z ▶ N(x, y, z) −−−−−−−−−−−−−−−−−→
x, y, z, r, s, t ▶ N(x, y, z)|N(r, s, t)
A graphical presentation of the production is in Figure 1(a), while in Figure 1(b) we have a simple transition.
In order to derive this transition we must take two suitably renamed in- stances of the production schema, and then use rule (par) obtaining:
x, y, z, w, y1, z1 ▶ N(x, y, z)|N(w, y1, z1)
{(x,a,⟨r⟩),(y,a,⟨s⟩),(z,a,⟨t⟩)(w,a,⟨u⟩),(y1 ,a,⟨s1⟩),(z1,a,⟨t1⟩)},id
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
x, y, z, r, s, t, w, y1, z1, u, s1, t1 ▶ N(x, y, z)|N(r, s, t)|N(w, y1, z1)|N(u, s1, t1)
We can then apply two times rule (merge) with σ = {y/y1} and σ = {z/z1}
obtaining at the end:
x, y, z, w ▶ N(x, y, z)|N(w, y, z)
{(x,a,⟨r⟩),(y,a,⟨s⟩),(z,a,⟨t⟩)(w,a,⟨u⟩)},id
−−−−−−−−−−−−−−−−−−−−−−→
x, y, z, r, s, t, w, u ▶ N(x, y, z)|N(r, s, t)|N(w, y, z)|N(u, s, t)
as desired. Note that when the ﬁrst (merge) rule is applied we have S1 = {s =
s1} thus we can choose ρ = {s/s1}.
A realistic scenario that can be modelled by such a transformation is for instance a server process that accepts communications on a port, which can be modelled as a graph with just one free node, and that, when required from the client, spawns a copy of itself to manage further requests using another port.

Example 5.2 (The Game of Life) 3 The Game of Life [1] is a well-known cellular automaton, that is a grid of evolving cells. A cell can be empty or populated (alive). A living cell dies if it has one or no alive neighbours (loneli- ness) or if it has four or more alive neighbours (overpopulation) and survives otherwise. An empty cell becomes alive if it has exactly three alive neighbours. In order to model the Game of Life we use edges that represent cells, with labels A for alive and E for empty. Edges are connected to their eight neigh-
bours via shared nodes.
At each step edges must communicate their state on each link and, at the same time, receive the state of their neighbours. This can be done using four actions (e, e),(a, a),(e, a) and (a, e). The meaning of e.g. the last action is “I’m alive, you are empty”. We also introduce an action ok representing a successful synchronization. Since the network is static we have no mobility,
i.e. all actions have arity 0. We use the following synchronization algebra (with mobility):
Act = {(e, e), (a, a), (e, a), (a, e), ok, ϵ};
ϵ • a = a for each a ∈ Act,
(e, e) • (e, e)= ok, (e, a) • (a, e)= ok, (a, a) • (a, a)= ok;
F in = {ϵ, ok}, Init = {ϵ};
Mob contains just functions from ∅ ∅ to ∅.
In order to force complete synchronizations all internal nodes must be bound. We use for productions a simpliﬁed notation: we just write the la- bels of the edges and the sequence of actions. Here we have some productions:
(a,e),(a,a),(a,e),(a,e),(a,e),(a,e),(a,e),(a,e),(a,e)
loneliness A −−−−−−−−−−−−−−−−−−−−−−−−−−→ E
(a,e),(a,a),(a,e),(a,a),(a,e),(a,a),(a,e),(a,e),(a,e)
survive A −−−−−−−−−−−−−−−−−−−−−−−−−−→ A
(a,a),(a,a),(a,e),(a,a),(a,e),(a,a),(a,a),(a,a),(a,e)
overpopulation A −−−−−−−−−−−−−−−−−−−−−−−−−−−→ E
(e,a),(e,e),(e,e),(e,a),(e,e),(e,e),(e,e),(e,a),(e,e)
populate  E −−−−−−−−−−−−−−−−−−−−−−−−−−→ A
Example 5.3 (Threshold synchronization) We deﬁne here an algebra for threshold synchronization that allows a group of processes to get some infor- mation from a sender, but only if at least m of them agree.
The synchronization algebra with mobility is deﬁned as follows:
Act = {out, ϵ}∪ {(in, n)|n ∈ }∪ {(in∗, n)|n ∈ };
out and (in, n) have arity 1, (in∗, n) has arity 2 for n < m, 1 otherwise;
ϵ • a = a ∀a ∈ Act ,

3 We thanks Robin Milner, who suggested the example during Dagstuhl seminar 04241.

out • (in, n)= (in∗, n),
(in, n1) • (in, n2)= (in, n1 + n2),
(in, n1) • (in∗, n2)= (in∗, n1 + n2);
F in = {ϵ}∪ {(in∗, n)|n ∈ }, Init = {ϵ};
Mob always maps the parameter of (in, n) and the ﬁrst parameter of (in∗, n) to the ﬁrst parameter of the result, and the parameter of out and the second parameter of (in∗, n) (whenever deﬁned) to the second parameter of the resulting (in∗, n) if n < m, to the only one otherwise.
Suppose that processes can perform only the actions out and (in, 1), the others being auxiliary. During synchronization the inputs are merged, but until m of them have joined, the parameter of the output is kept separate. Thus in order for the processes doing input to get the piece of information in the output, at least m of them must participate to the synchronization. If they are not enough synchronization is performed but no data exchange occurs.

A case study on Fusion Calculus
In this section we briefly summarize Fusion Calculus, an important calculus for mobility that extends π-calculus with the concept of fusion, and we show an encoding from (a subset of) Fusion Calculus processes to graphs. An im- portant aspect of our encoding is that the topology of the graph does not correspond to the structure of the syntactic tree of the process, but it mod- els the structure of the connections among processes. We show that, using synchronization algebras, we can provide different concurrent semantics for Fusion Calculus, just by choosing different synchronization models.
For a full definition of Fusion Calculus see [14], and for a more detailed analysis of the relationships between Fusion Calculus and SHR see [11].
We consider agents with the following syntax.
Definition 6.1 The agents are deﬁned by:
S ::=	i αi.Pi | rec X.α.P | X	(Sequential agents)
P ::= 0 | S | P1|P2 | (x)P	(General agents)
where α are input/output actions ux / ux or fusion actions φ (equivalence relations on names).
Processes are agents considered up to standard structural axioms. For the definition of the operational semantics see [14]. We just remember that fusion
transitions are of the form P −→α  P ' where α is one of the actions seen above or
a bound communication action, that is an input/output action where names
in a set bn(α) are extruded.
Our mapping uses the following standard decomposition on processes.

Definition 6.2 The standard decomposition of a process P is deﬁned as P = PˆσP where σP is the standard substitution and Pˆ is the standard agent of P. No free name can occur twice in Pˆ. The decomposition satisﬁes P = Qσ ⇒ Pˆ = Qˆ ∧ σP = σQσ. We denote with fnarray(P ) the array of the free name occurrences in P. In particular σP = {fnarray(P )/ fnarray(Pˆ)}.
We present now the relationships between Fusion Calculus and SHR.
Definition 6.3 A substitutive effect of a fusion φ is an idempotent substitu- tion σ agreeing with φ (i.e. σ sends all members of each equivalence class of φ to one representative in the class).
Definition 6.4 The relation between actions of Fusion Calculus and SHR synchronizations is a function that we denote with −) in the case of commu- nication actions:
 (y)ux) = (u, inn, x), id where n = |x|
 (y)ux) = (u, outn, x), id where n = |x|
When not otherwise stated, we suppose to have on nodes the trivial syn- chronization (ϵ, ⟨⟩). We deﬁne inn and outn as complementary actions, i.e. inn = outn and outn = inn. A φ action corresponds to a substitutive effect π of φ.
Definition 6.5 We deﬁne now the translation on processes:
 0) = nil	 S) = LSˆ(fnarray(S))	 P1|P2) = P1)| P2)	 (x)P ) = νx  P )
As a last step we show the production schemas used for the SHR system.
Definition 6.6 We have production schemas only for standard sequential agents  i αi.Pi. Let Γ be fn(  i αi.Pi)). Productions are of the following forms:

Γ ▶ Σ
 αi)
α .P )
Γ ▶  P ) if α
is a communication action;

Γ ▶ Σ α .P ) −→π  Γπ ▶ P π) if α = φ and π is a substitutive effect of φ.
The correctness of the translation w.r.t. SHR with Milner synchronization is proved by the following theorem.
Theorem 6.7 (Correctness) Let us consider SHR with Milner synchroniza-
tion algebra. For each fusion process P and each Γ ⊇ fn( P )) if P −→α  P ' and
Γ ∩ bn(α)= ∅ then:

 α)
if α is a communication action then Γ ▶  P ) −−→
Γ, ΓE
▶  P ') where

ΓE = bn(α);
if α is a fusion action then Γ ▶  P ) −→π

Γπ ▶  P 'π) for each substitutive

effect π of α. We may or may not have also a τ action on the node in





w
x


x=z=w
 y



Fig. 2. A transition of Broadcast Fusion.
Γ on which the synchronization has been performed (if the node is bound then the τ action is not visible).
In general our graphs can perform more transitions than the corresponding Fusion Calculus processes. This happens because SHR is a concurrent model and thus many Fusion Calculus transitions can be executed in one SHR step.
Example 6.8 Let us consider the fusion process (xy)(yw.P |yx.Q|yz.R). We can have for instance the following transition:

(xy)(yw.P |yx.Q|yz.R) −→1
(y)((yw.P |Q|R){z/x})

Using the translation and the Milner synchronization algebra we can have in the SHR model the corresponding transition:
w, z ▶ νx, y L	(y, w)|L	(y, x)|L	(y, z) −→id
w, z ▶ νy (Lx1 x2.P (y, w)|LQ|LR){z/x}
One can use the same approach to analyze systems based on different com- munication primitives. Suppose that we have a system based on broadcast. We can derive a Broadcast Fusion Calculus by applying the translation and ani- mating the obtained graph using SHR with broadcast synchronization. Thus we can have for instance a transition of the form:

{z/w}
w, z ▶ νx, y Lx1 x2.P (y, w)|Lx1x2.Q(y, x)|Lx1x2 .R(y, z) −−−→
z ▶ νy (LP |LQ|LR){z/x, z/w}
The same transition is graphically represented in Figure 2 and can be writ- ten in the usual Fusion Calculus notation as:
{z/w}
(xy)(yw.P |yx.Q|yz.R) −−−→ (y)(P |Q|R){z/x}

Conclusions and future work
We have presented a general model for SHR, where the synchronization mech- anism and the mobility patterns are specified using a generalization of syn-

chronization algebras. We have presented some examples in order to prove that synchronization algebras with mobility are a suitable way to model the communication primitives provided by the middleware, and that SHR can be easily used to build models of systems at the high level of abstraction, as required for the huge systems that are met in the global computing area.
We have also presented a mapping from Fusion Calculus to SHR, showing that SHR is a good framework to execute fusion processes, since one can easily change the synchronization model, thus allowing to use the usual Fusion no- tation while modelling systems based on different communication primitives. As future work we want to define an abstract semantics for SHR, thus allowing a behavioural analysis of graph computations and allowing to prove
that different graphs are equivalent w.r.t. some concept of observation.
We plan to define a framework where each node is labelled with a syn- chronization algebra, thus allowing to model heterogeneous systems that use different communication primitives inside the same system, as often happens in the global computing scenario.
We also want to analyze expressiveness and properties of the different kinds of Fusion Calculi obtained through our mapping, first of all the broadcast one. Finally, we want to build an implementation of SHR which allows to draw graphs and productions and to animate them in order to analyze their possible
behaviours.

References
E. Berlekamp, J. Conway, and R. Guy. Winning Ways for your Mathematical Plays, volume 2. Academic Press, 1982.
P. Degano and U. Montanari. A model for distributed systems based on graph rewriting.
Journal of the ACM (JACM), 34(2):411–449, 1987.
H. Ehrig, M. Pfender, and H. J. Schneider. Graph grammars: an algebraic approach. In Proc. IEEE Conference on Automata and Switching Theory, pages 167–180, 1973.
G. Ferrari, U. Montanari, and E. Tuosto. A LTS semantics of ambients via graph synchronization with mobility. In Proc. of ICTCS’01, volume 2202 of LNCS, pages 1–16. Springer, October 2001.
O. H. Jensen and R. Milner. Bigraphs and transitions. SIGPLAN Not., 38(1):38–49, 2003.
D. Hirsch. Graph Transformation Models for Software Architecture Styles. PhD thesis, Departamento de Computacio´n, U.B.A., 2003.
D. Hirsch, P. Inverardi, and U. Montanari. Reconfiguration of software architecture styles with name mobility. In Proc. of Coordination 2000, volume 1906 of LNCS, February 2000.
D. Hirsch and U. Montanari. Synchronized hyperedge replacement with name mobility. In
Proc. of CONCUR’01, Springer, volume 2154 of LNCS, 2001.
I. Lanese. Process synchronization in distributed systems via Horn clauses. Master’s thesis, University of Pisa, Computer Science Department, 2002. Downloadable from http://www.di.unipi.it/~lanese/work/tesi.ps.


I. Lanese and U. Montanari. Software architectures, global computing and graph transformation via logic programming. In Proc SBES’2002, pages 11–35. Anais, 2002.
I. Lanese and U. Montanari. A graphical fusion calculus. In Proceedings of CoMeta Final Workshop, pages 199–215, volume 104 of ENTCS, 2004.
I. Lanese and U. Montanari. Mapping fusion and synchronized hyperedge replacement into logic programming. Theory and Practice of Logic Programming, Special Issue on Multiparadigm Languages and Constraint Programming, 2004. Submitted.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes. Inform. and Comput., 100:1–77, 1992.
J. Parrow and B. Victor. The fusion calculus: Expressiveness and symmetry in mobile processes. In Proc. of LICS ’98. IEEE, June 1998.
G. Winskel. Event structures. In Petri Nets: Applications and Relationships to Other Models of Concurrency, volume 255 of LNCS, pages 325–392. Springer, 1986.
