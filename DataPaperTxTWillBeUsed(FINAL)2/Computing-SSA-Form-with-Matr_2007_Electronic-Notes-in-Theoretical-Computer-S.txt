	Electronic Notes in Theoretical Computer Science 190 (2007) 121–132	
www.elsevier.com/locate/entcs

Computing SSA Form with Matrices
Quan Hoang Nguyen1
The School of Computer Science and Engineering The University of New South Wales
Sydney, Australia
Bernhard Scholz2
The School of Information and Technologies The University of Sydney
Sydney, Australia

Abstract
Static Single-Assignment (SSA) form is an efficient intermediate representation used in virtual machines and modern compilers. It provides data flow information that simplifies the implementation of standard program optimisations such as constant propagation, dead code elimination, and partial redundancy elimination. Constructing SSA form involves the computation of graph relations such as dominance, and non-iterated and iterated dominance frontier. Although there exist efficient graph algorithms for these relations, the al- gorithms are elaborate to implement. In this paper we introduce a new approach to compute the dominance relation, the dominance frontiers, and the iterated dominance frontiers based on Boolean matrix calculus. We implemented our approach in an optimising backend for LCC bytecode and compared its performance with the state-of-the-art approaches. We use the Spec95 benchmark suite for our experimental evaluation.
Keywords: SSA form, dominance relation, dominance frontier, Boolean matrices


Introduction
Static single-assignment (SSA) form [11] is a sparse intermediate representation that encodes data-flow information. It has been successfully employed as an intermediate representation in several commercial and open source projects such as LLVM [22], IBM’s research Java VM called Jikes RVM [17], Sun’s HotSpot Server VM [31], and many other projects. For each variable in SSA form there exists only a single assignment. Figure 1 illustrates an example of SSA form for some straight-line code.

1 Email:quanh@cse.unsw.edu.au
2 Email: scholz@it.usyd.edu.au

1571-0661 © 2007 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.02.064

X=X+Y; Y=X-Y;
X=X-Y;
X1=X0+Y0;
=⇒	Y1=X1-Y0; X2=X1-Y1;



(a) Input Program	(b) SSA Form
Fig. 1. SSA Example

Multiple definitions of a variable may reach a confluence point and a special assign- ment (aka. φ-function node) is inserted to make the variable use after a confluence point unique, i.e., vx = φ(vi1 , vi2 ,... , vik ) where vx is the merged value of variable definitions vi1 ,... , vik . The problem of computing the minimum number of insertion points for φ-function nodes was solved by Cytron et al. [10]. However, the insertion of φ-function nodes requires elaborate algorithms to compute
the dominance relation [27,23,6,2,14],
the dominance frontier, and
the iterated dominance frontier [30,25,15,8].
These algorithms are complex, time-consuming and error-prone to implement, and they require sophisticated data structures. To overcome this problem, several other approaches were introduced in the literature. Aycock and Horspool [4] proposed an algorithm for finding placements of φ-function nodes in two phases. The first phase is a crude placement strategy, placing φ-function nodes for all variables at confluence points as proposed in Appel’s textbook [3]. In the second phase un- necessary φ-function nodes are eliminated. In [4] it was proved that the approach places a minimal number of φ-function nodes for reducible flowgraphs 3 but not for irreducible graphs. Brandis and M¨ossenb¨ock [5] introduced an approach that generates SSA form for structured languages whose programs form a subclass of reducible flowgraphs. Sreedhar and Gao introduced a linear-time algorithm for φ- function node insertions [30] based on DJ-graphs. This algorithm transforms the input program to SSA form in time O(E × V ) where E is the number of edges, and
V is the number of variables.
In this paper we propose a new approach for the generation of SSA form that is based on Boolean matrix calculus. This new approach places a minimal number of φ- function nodes for arbitrary flowgraphs. In contrast to previous work our approach computes the graph relations in terms of simple matrix equations. Although solving the matrix equations have a higher worst-case complexity class than the state-of- the-art approach, our approach is useful for (1) rapid prototyping of a compiler and
(2) validating the result of the elaborated algorithms [27,23,6,2,14,30,25,15,8]. The contribution of this paper is as follows:
We compute the graph relations used to construct SSA form by solving simple matrix equations

3 A reducible flowgraph is a control flow graph whose loops have a single entry point.

We implemented the new approach and compared its performance to the state- of-the-art approaches.
The paper is organised as follows: In Section 2 we motivate our approach. In Section 3 we give the necessary background for our approach. In Section 4 we discuss the proofs of the matrix equation for dominance relation, dominance frontier, and iterated dominance frontier. In Section 5 we present the results of our experiments and in Section 6 we draw our conclusions.

Motivation
Transforming an input program to SSA form is performed in two steps: In the first step φ-function nodes are inserted at confluence points and in the second step vari- ables are renamed, i.e., subscripts are added to the definitions and uses of variables. Figure 2 shows an example for generating SSA form. The input program is depicted in Figure 2(a) as a flowgraph. In the program there are assignments for variable v in basic block B0 and in basic block B2. The confluence points of the program are basic blocks B1, B4, and B5. In all confluence points a φ-function node is required as shown in Figure 2(b), e.g., in basic block B1 the definition of basic block B0 and the definition of basic block B2 need to be merged. In the second step the definitions and the uses of variable v are renamed as depicted in Figure 2(c).


(a) Input Program	(b) Inserting φ-function nodes	(c) Renaming Variables
Fig. 2. An example of SSA form transformation

For inserting a minimal number of φ-function nodes Cytron et al. [10] introduced iterated dominance frontiers that compute the insertion points of φ-function nodes for a given set of definitions of a variable. More formally, they map a subset of nodes, i.e., the set of definitions of a variable, to a subset of nodes, i.e., the set of confluence points. In our approach, we use Boolean matrices to express this mapping. A Boolean matrix consists of 0 and 1 values and the underlying algebra is the “and” operation for the multiplication and the “or” operation for the addition.

A subset of nodes S is expressed as Boolean vector s ∈ {0, 1}n of size n where n is the number of nodes in the control flowgraph. Each vector element corresponds to a node and is set to 1 if the node is in the set; otherwise the vector element is set to zero. To compute the iterated dominance frontier for the definitions of a variable v we determine the result of following vector-matrix multiplication:
J +(Sv)= [sv.J]	(1)
where set Sv represents the nodes that contain definitions of variable v and sv the corresponding vector of S. Matrix J is determined by the topological structure of the control flow graph.
For example, to describe the set of definitions of the example in Figure 2 we use the vector (101000) that corresponds to the definition set Sv = {B0, B2}. To compute the insertion points for the φ-function nodes we compute the vector-matrix multiplication
0 0 0 0 0 0
0 0 0 0 0 1
0 1 0 0 1 1
v	= (101000) × ⎜0 1 0 0 1 1⎟ = (010011)
0 0 0 0 0 0 
resulting in the node set {B1, B4, B5} for placing φ-function nodes. The computa- tion of matrix J requires several simple matrix equations:
J = D+	(2)
D = (A.M − M)T	(3)
M = ¬f ∗(¬M0, A, ¬I),	(4)
where matrix A is the transposed adjacency matrix, matrix M0 is an initialisation matrix, and I is the identity matrix. The operation A+ denotes the transitive
closure of a matrix, i.e., A+ = Σ∞  (I + A)k. The extended transitive closure
function f ∗(S, A, C) is defined by the recurrence relation
X0 = S
Xi+1 = A.Xi ∩ C, ∀i ≥ 0.	(5)
The result of the extended transitive closure function is Xk for a k ≥ 0 such that
Xk is equal to Xk+1, i.e. a fix-point is reached.
Matrix D is the bit representation of the dominance frontier [10]. I.e., the vector- matrix multiplication svD computes the dominance frontier for subset Sv. Matrix M is the dominance relation represented as a matrix. If element mij in M is set to one, node j dominates node i; otherwise it is set to zero.
We employ the extended transitive closure function to compute matrix M for our example in Figure 2. The parameters for the extended transitive closure operator are the matrices A (that is the transposed adjacency matrix), the negated identity matrix, and matrix M0 that is a matrix whose elements are set to one except for

the first row. In the first row only the first element in the row is set to one. All other elements in the first row are set to zero. The matrices of the examples in Figure 2 are given below:

⎛0 0 0 0 0 0⎞
⎜1 0 0 0 1 0⎟
⎛1 0 0 0 0 0⎞
⎜1 1 1 1 1 1⎟
⎛1 0 0 0 0 0⎞
⎜1 1 0 0 0 0⎟




0 1 0 0 0 0
0 0 1 1 0 0 
1 0 0 0 1 0 
1 1 1 1 1 1
1 1 1 1 1 1 
1 1 1 1 1 1 
1 1 0 1 0 0
1 1 0 0 1 0 
1 0 0 0 0 1 

For computing the dominance frontier we use the equation (A.M − M)T resulting in the following matrix:

⎡⎛0 0 0 0 0 0⎞⎛1 0 0 0 0 0⎞
⎢⎜1 0 0 0 1 0⎟⎜1 1 0 0 0 0⎟
⎛1 0 0 0 0 0⎞⎤T
⎜1 1 0 0 0 0⎟⎥
⎛0 0 0 0 0 0⎞
⎜0 0 0 0 0 1⎟

0 1 0 0 0 0	1 1 1 0 0 0	1 1 1 0 0 0
⎢⎜
0 0 0 0 1 0

⎣⎝0 1 0 0 0 0⎟⎠⎜⎝1 1 0 1 0 0⎟⎠	⎜⎝1 1 0 1 0 0⎟⎠⎦⎥
⎜⎝0 0 0 0 1 0⎟⎠



In our new approach we compute iterated dominance frontiers based on matrix calculus. For an implementation a simple binary matrix calculator is needed that is able to compute transitive closures of binary matrices and extended transitive closures. The transitive closure operations can be implemented as simple recur- rences until the result stabilises. However, more advanced techniques exist in the literature.

Background
A flowgraph is a directed graph G = ⟨V, E, s⟩ where V is the set of nodes represent- ing basic blocks and E is the set of edges. node s is a distinguished start node. A path is a sequence of nodes ⟨v1,... , vk⟩ such that vi → vi+1 ∈ E for all 1 ≤ i < k. In a flowgraph all nodes are reachable, i.e. there is a path from s to every other node in V . For each flowgraph node x, the set of immediate predecessors and suc- cessors of x are defined as preds(x)= {n|(n, x) ∈ E} and succs(x)= {n|(x, n) ∈ E}, respectively.
A node x dominates a node y (written as x dom y) if every path from s to y includes x. The set of dominators dom(x) of a node x is the set of nodes which dominate x, i.e. dom(x) = {y|y dom x}. For the start node dom(s) = {s}. For remaining nodes in the flowgraph, the set of dominators is the solution to the following equation system:

dom(u)= {u}∪	 
p∈preds(u)
dom(p),	∀u ∈ V \ {s}	(6)

A node x strictly dominates y (written as x sdom y) if x is not equal to y
and x dominates y, and the strict dominators of a node are given as sdom(u) = 

dom(u) \ {u}.  The dominance relation has been extensively studied in the past [27,23,6,2,15,14].  There exist some linear-time algorithms in the litera- ture [6,2,15,14]. Although they are asymptotically linear, some of the approaches have high linear constants [2], and are not practical to implement.
The dominance frontier [10] of node x (written as DF(x)), is the set of all nodes y in the flowgraph such that x dominates an immediate predecessor of y but does not strictly dominate y. That is,
DF(x)= {y | ∃p ∈ preds(y): x dom p ∧ ¬(x sdom y)}	(7)
Given a set of flowgraph nodes S ⊆ V , the dominance frontier of a set S is defined as the union of the dominance frontiers of all nodes in S, i.e.,
DF(S)=   DF(x)	(8)
x∈S
The iterated dominance frontier of S is defined as:
J +(S) = lim DFi(S)	(9)
i→∞

where DF 1(S)= DF(S) and DFi+1(S)= DF(S ∪ DFi(S)).
Our approach requires some basic concepts of Boolean matrix calculus. The algebraic properties of Boolean algebras, Boolean vector and Boolean matrices are well-studied [20,21]. The principal idea is that sets are represented as Boolean vectors. Let U be the universal set with n elements and let’s assume that there is a fixed order among the elements. Then each set A ⊆ U has a corresponding n-bit vector a in which ai is set to one if ai ∈ A, otherwise ai is zero. Function [a] maps vector a to set A.
A Boolean matrix of size m × n is an m × n matrix over B. Let Bmn denote the set of all m × n Boolean matrices and let Bn denote the set of all n × n Boolean matrices. The n × n identity matrix I is matrix δij such that δij = 1 if i = j and δij =0 if i /= j. The m × n universal matrix 1 is the matrix all of whose entries are
1. Each row of an m × n Boolean matrix is a Boolean vector vi ∈ Vn. Component- wise matrix operations +, ∩, ¬, − are similar to those of Boolean vectors. Concepts such as transpose, symmetry, and idempotency are the same as in the case of scalar
matrices. The transpose of A ∈ Bn (denoted as AT ) is B ∈ Bn such that bij =
aji, ∀i, j ∈ {1 ... n}. Let A.B = C where cij = Σn	aik.bkj, ∀i, j ∈ {1 ... n}.

Ak	k
i=1
A if k > 0 and the identity matrix if k = 0. A(u) is row u of matrix A.



Lemma 3.1 Let A, B ∈ Bn,

A(u).B =	Σ
p∈[A(u)]

B(p).	(10)

The transitive closure of a Boolean matrix can be seen as a reachability problem

in a graph. The transitive closure of a graph G = (V, E) is a graph G∗ = (V, E∗) such that E∗ contains an edge (u, v) if there exists a path from u to v in G. In the literature, there are lots of studies on transitive closure of a directed graph [32,19,29,16,24,1,18,12,26]. Warshall’s algorithm [16] is simple to implement, but exhibits a worst-case runtime of O(n3). More sophisticated algorithms [26] and fastest matrix multiplication techniques [9] with a squaring technique reduces the asymptotic worst-complexity to O(n2.376 log n).

Unified Approach
Dominance Relation
In [27] the computation of dom(u) applies Equation 6 for following recurrences relation


dom0(s)= {s}
∀u ∈ V \ {s} : dom0(u)= V
∀u ∈ V : domi+1(u)= {u}∪	 
p∈preds(u)


domi(p)	(11)

where dom(u) = limk→∞ domk(u) (for all u ∈ V ). Note that after a finite number of steps the recurrence relation stabilises.


Lemma 4.1 M = ¬f ∗(¬M , A, ¬I) where M
⎛1 0 .. . 0⎞
= ⎜1	1⎟.

0	0	⎜⎝.
. ⎟⎠

1 .. . . .. 1
Proof. Let δu = [{u}]. Then, domi+1(u)= [Mi+1(u)] where
Mi+1(u)	= δu +  p∈[A(u)] Mi(p)	(cf. Eqn 11)
¬Mi+1(u) = ¬δu. Σp∈[A(u)] ¬Mi(p) (De’Morgan’s law)
= (A(u).¬Mi).¬δu	(Distributive Law and Equation 10)
Since δu is row u of identity matrix I, we obtain ¬Mi+1 = (A.¬Mi) ∩ ¬I which is the recurrence relation. By translating the boundary condition of fixed-point Equation 11 into matrix form, we represent the dominance relation by the extended fixed-point operation f ∗ as M = ¬f ∗(¬M0, A, ¬I).	 

Dominance Frontier
Let D and J be the matrices of the non-iterated and iterated dominance frontier relation, i.e. DF(u)= [D(u)] and J +(u)= [J(u)].
Lemma 4.2 D = (A.M − M)T .

Proof. By definition, the dominance frontier of a flowgraph node x is DF(x)= { y | (E p ∈ preds(y)) s.t. (x dom p and x ! sdom y) }, that is equivalent to S1 ∩ S2 where S1= { y | (E p ∈ preds(y)) s.t. x dom p} and S2= {y | x ! sdom y }. x ∈ dom(p) iff p ∈ MT (x). Therefore, S1 is rewritten in vector form as s1= { y | A(y).MT (x) /= 0 } = { y | MT (x).A(y) /= 0 } and s1 = MT (x).AT and s2 = чMT (x). Therefore, D(x)= (MT (x).AT ).чMT (x) that results in
D = (MT .AT ) ∩ чMT = (A.M — M)T .


Lemma 4.3 DF(S)= S.D

Proof. Let S be a Boolean vector representation of set S. Then,  x∈S DF(x) is rewritten as Σx∈S D(x)= S.D (cf. Equation 10).	 
Lemma 4.4 J +(S)= S.D+
Proof. The iterated dominance frontier of S is J +(S) = limi→∞ DFi(S) where
DF 1(S)= DF(S) and DFi+1(S)= DF(S ∪ DFi(S)), as given in Equation 9.
DF 1(S)= DF(S)	(12)
6i DFi+1(S)= DF(S ∪ DFi(S))	(13)
J +(S) = lim DFi(S)	(14)
i→∞
Equation 13 is rewritten as follows:
DFi+1(S)= DF(S ∪ DFi(S)) = (S + DFi(S)).D	(15)
The closed form of the recurrence relation is DFi(S) = (S + DFi−1(S)).D =

S	i
k=1
Dk and Equation 14 is transformed to J +(S) = limi→∞ DFi(S) =

limi→∞ S. Σi
Dk = [S.D+].	 


Extended Transitive Closure
In our unified approach for constructing SSA form we use the extended transitive closure function f ∗(A, B, C) (see Definition 5) which is an extension of a transitive closure of a graph. For the simple case, i.e. C is the one matrix 1, simple and fast algorithms are suitable such as Warshall’s algorithm [16], which exhibits a worst- case runtime of O(n3). More sophisticated algorithms such as Munro [26] and fastest matrix multiplication techniques [9] with a squaring technique reduces the asymptotic worst-complexity to O(n2.376 log n). For the more general case (i.e. C is not the one matrix) techniques introduced for computing data-flow analysis [28] can be used. This approach uses dynamic programming techniques to efficiently compute the extended transitive closure of a relation.



Fig. 3. Experiments:Dominance Relation




Experiments
Fig. 4. Experiments: Dominance Frontier

We implemented our new approach as part of an optimiser written in Java for a virtual machine [7]. The framework reads bytecode generated by LCC [13] and constructs SSA form. After performing machine independent optimisations the optimised bytecode is emitted.
The experiments for the new approach and the state-of-the-art approaches were conducted on a Linux platform with 1GB RAM and a 2.0GHz CPU, running Fedora Core 2. The experiments were compiled and run with Java SDK 1.5.0. As a benchmark suite we used the Spec95 integer benchmark programs.
As a yardstick for our new approach we implemented Purdom and Moore’s algorithm [27], and Lengauer and Tarjan (LT79) [23] to compute the dominance relation. For non-iterated and iterated dominance frontier we implemented the


Fig. 5. Experiments: Iterated Dominance Frontier



algorithms described in [25,8].
In Fig. 3 the performance values of the fast [23], simple [27], and of our approach are depicted. The time measurements are in nano seconds. The best-fit line of our new approach (“new”) shows cubic-time complexity whereas the other approaches have a linear or slight quadratic complexity to cubic time behaviour.
The performance of the dominance frontier is shown in Fig. 4. We compared the performance of the “fast” dominance frontier algorithm [8] with the “simple” dominance frontier algorithm [25] and our “new” approach. For each generated control-flow graph, we computed the dominance frontiers of all nodes and measured the execution time. The “fast” algorithm is almost linear. The “simple” algorithms shows a quadratic-time complexity; while our new approach is the slowest with cubic-time.
For the iterated dominance frontier, we compared our new approach with the standard recursive algorithm described in [25,8]. Fig. 5 shows the performance of the “fast” algorithm (recursive) and of our “new” approach. In our experiments, we first computed the dominance frontier DF for all nodes and generated a random vertex set S. J +(S) is then computed once for each approach and we measured the execution time. As shown in the figure, the “fast” algorithm runs. In our approach, the first computation of J +(S) requires a computation of transitive closure D+ and hence it has a cubic time complexity as depicted.
The experimental results indicate that our algorithms have a cubic time- complexity. However, this result goes in line with our theoretical considerations of our unified approach. A better algorithm for finding transitive closures (instead of performing a simple recursion) would improve the performance significantly. Note the implementation effort of our approach is minimal because only a simple binary matrix calculator needs to be implemented. Our approach has the smallest LOC( lines of code) in all three cases.

Conclusions
In this paper, we demonstrated a unified approach for computing graph relations used to compute SSA form. The state-of-the-art algorithms are elaborate to imple- ment. To overcome this problem we advised a unified approach using Boolean ma- trix operations that expresses dominance, and iterated and non-iterated dominance frontier as simple Boolean Matrix equations. A simple binary matrix calculator is sufficient to compute the relations. Our approach is useful for (1) rapid prototyping of compilers and virtual machines and (2) as a mean to validate more sophisticated algorithms.

Acknowledgement
We would like to thank Bernd Burgstaller for his useful comments and for proof- reading the manuscript. This work has been supported by the ARC Discovery Project Grant “Compilation Techniques for Embedded Systems” under Contract DP 0560190.

References
Agrawal, R., S. Dar and H. V. Jagadish, Direct transitive closure algorithms: design and performance evaluation, ACM Trans. Database Syst. 15 (1990), pp. 427–458.
Alstrup, S., D. Harel, P. W. Lauridsen and M. Thorup, Dominators in linear time, SIAM Journal on Computing 28 (1999), pp. 2117–2132.
Appel, A. W., “Modern compiler implementation in Java,” Cambridge University Press, 1998.
Aycock, J. and R. N. Horspool, Simple generation of static single-assignment form, in: Proceedings of the 9th Internation Conference on Compiler Construction, Lecture Notes in Computer Science 1781 (2000), pp. 110–124.
Brandis, M. M. and H. Moessenboeck, Single-pass generation of static single-assignment form for structured languages, ACM Transactions on Programming Languages and Systems 16 (1994), pp. 1684– 1698.
Buchsbaum, A. L., H. Kaplan, A. Rogers and J. R. Westbrook, A new, simpler linear-time dominators algorithm, ACM Transactions on Programming Languages and Systems 20 (1998), pp. 1265–1296.
Burgstaller, B., B. Scholz and M. A. Ertl, An embedded systems programming environment for c., in:
W. E. Nagel, W. V. Walter and W. Lehner, editors, Euro-Par, Lecture Notes in Computer Science
4128 (2006), pp. 1204–1216.
Cooper, K. D. and L. Torczon, “Engineering a Compiler,” Morgan Kaufmann, 2004.
Coppersmith, D. and S. Winograd, Matrix multiplication via arithmetic progressions, in: Proc. of Symposium on Theory of Computing, 1987, pp. 1–6.
Cytron, R., J. Ferrante, B. K. Rosen, M. N. Wegman and F. K. Zadeck, Efficiently computing static single assignment form and the control dependence graph, ACM Transactions on Programming Languages and Systems 13 (1991), pp. 451–490.
Cytron, R., J. Ferrante, B. K. Rosen, M. N. Wegman and K. Zadeck, An efficient method of computing static single assignment form, in: POPL89, 1989, pp. 25–35.
Fischer, M. J. and A. R. Meyer, Boolean matrix multiplication and transitive closure, in: Proceedings of the Twelfth Annual Symposium on Switching and Automata Theory (1971), pp. 129–131.
Fraser, C. W. and D. R. Hanson, A retargetable compiler for ANSI C, Technical Report CS–TR–303–91, Princeton University, Department of Computer Science, Princeton, N.J. (1991).

Georgiadis, L. and R. E. Tarjan, Finding dominators revisited: extended abstract, in: SODA ’04: Proceedings of the fifteenth annual ACM-SIAM symposium on Discrete algorithms (2004), pp. 869–878.
G.Ramalingam, On loops, dominators, and dominance frontiers, ACM Trans. Program. Lang. Syst. 24
(2002), pp. 455–490.
Henry S. Warren, J., A modification of warshall’s algorithm for the transitive closure of binary relations, Commun. ACM 18 (1975), pp. 218–220.
IBM Research, Jikes RVM Project. URL http://jikesrvm.sourceforge.net/

Ioannidis, Y. E., On the computation of the transitive closure of relational operators, in: VLDB ’86: Proceedings of the 12th International Conference on Very Large Data Bases (1986), pp. 403–411.
Ioannidis, Y. E. and R. Ramakrishnan, Efficient transitive closure algorithms, in: VLDB ’88: Proceedings of the 14th International Conference on Very Large Data Bases (1988), pp. 382–394.
Kim, K. H., “Boolean Matrix Theory and Applications,” Dekker, New York, 1982, 288 pp.
Koppelberg, S., “Handbook of Boolean Algebras,” Elsevier Science Ltd, 1989.
Lattner, C. and V. Adve, Llvm: A compilation framework for lifelong program analysis & transformation, in: CGO ’04: Proceedings of the international symposium on Code generation and optimization (2004), p. 75.
Lengauer, T. and R. E. Tarjan, A fast algorithm for finding dominators in a flowgraph, ACM Transactions on Programming Languages and Systems 1 (1979), pp. 121–141.
Matsunaga, Y., P. C. McGeer and R. K. Brayton, On computing the transitive closure of a state transition relation, in: DAC ’93: Proceedings of the 30th international conference on Design automation (1993), pp. 260–265.
Muchnick, S. S., “Advanced Compiler Design and Implementation,” Morgan Kaufmann Publishers, 1997.
Munro, J. I., Efficient determination of the transitive closure of a directed graph., Inf. Process. Lett. 1
(1971), pp. 56–58.
Purdom, P. W. and E. F. Moore, Immediate predominators in a direct graph, Communications of the ACM 15 (1972), pp. 777–778.
Reps, T., S. Horwitz and M. Sagiv, Precise interprocedural dataflow analysis via graph reachability, in: Conference Record of POPL ’95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, San Francisco, California, 1995, pp. 49–61.
Shyamasundar, R. K., A note on the transitive closure of a boolean matrix, SIGACT News 9 (1978),
pp. 18–21.
Sreedhar, V. C. and G. R. Gao, A linear time algorithm for placing &phgr;-nodes, in: POPL ’95: Proceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages (1995), pp. 62–73.
SUN Microsystems, The Java HotSpot Virtual Machine, v1.4.1, White Paper, Sun Microsystems
(2006).
Ullman, J. D. and M. Yannakakis, The input/output complexity of transitive closure, in: SIGMOD ’90: Proceedings of the 1990 ACM SIGMOD international conference on Management of data (1990), pp. 44–53.
