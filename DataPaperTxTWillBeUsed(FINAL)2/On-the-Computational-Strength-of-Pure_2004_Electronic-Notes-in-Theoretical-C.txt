	Electronic Notes in Theoretical Computer Science 96 (2004) 29–49	
www.elsevier.com/locate/entcs




On the Computational Strength of Pure Ambient Calculi
Sergio Maffeis and Iain Phillips1 ,2 ,3
Department of Computing Imperial College London

Abstract
Cardelli and Gordon’s calculus of Mobile Ambients has attracted widespread interest as a model of mobile computation. The standard calculus is quite rich, with a variety of operators, together with capabilities for entering, leaving and dissolving ambients. The question arises of what is a minimal Turing-complete set of constructs. Previous work has established that Turing completeness can be achieved without using communication or restriction. We show that it can be achieved merely using movement capabilities (and not dissolution). We also show that certain smaller sets of constructs are either terminating or have decidable termination.
Keywords: Ambient calculus, mobile ambients, Turing completeness, counter machines, termination, decidability.


Introduction
Since its introduction in 1998, Cardelli and Gordon’s calculus of Mobile Am- bients (MA) [5,6] has attracted widespread interest as a model of mobile com- putation. An ambient is a vessel containing running processes. Ambients can move, carrying their contents with them. The standard calculus is quite rich, with a variety of operators, together with capabilities for entering, leaving and dissolving ambients. Subsequent researchers have increased this variety

1 We wish to thank Cristiano Calcagno, Philippa Gardner, Maria Grazia Vigliotti and Nobuko Yoshida for helpful discussions and encouragement.
2 Email: {maffeis,iccp}@doc.imperial.ac.uk
3 Maffeis was supported by a grant from Microsoft Research, Cambridge.

1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.020

by proposing alternative movement capabilities. We may mention Mobile Safe Ambients (SA) [13,14], Robust Ambients (ROAM) [10], Safe Ambients with Passwords (SAP) [16], the Push and Pull Ambient Calculus (PAC) [20], Controlled Ambients (CA) [23], and the version of Boxed Ambients [2] with passwords (NBA) [3]. We shall use the term Ambient Calculus (AC) to refer to all of these variants.
The question arises of what is a minimal set of constructs which gives the computational power of Turing machines, i.e. is Turing complete. One way to tackle this is to encode into the Ambient Calculus some other process calculus which is known to be Turing complete. Cardelli and Gordon showed how to encode the asynchronous pi-calculus into Mobile Ambients [6]. The encoding makes use of the communication primitives in the Ambient Calculus. However Cardelli and Gordon also encoded Turing machines directly into the pure AC, where there is no communication. (Incidentally, Zimmer [24] subsequently encoded the synchronous pi-calculus into pure Mobile Safe Ambients [13,14].) Busi and Zavattaro [4] showed how to encode counter machines into pure Mobile Ambients without restriction. Independently, Hirschkoff, Lozes and Sangiorgi [11] encoded Turing machines into the same subcalculus. In this paper we follow up this work and investigate whether even smaller fragments of AC can be Turing complete. We concentrate entirely on pure AC. Our work is very much inspired by that of Busi and Zavattaro; we follow them in using
counter machines rather than Turing machines.
The major question left open by previous work is whether pure AC with- out the open capability which dissolves ambients can be Turing complete. This question is of particular interest in view of the decision which Bugliesi, Castagna and Crafa took to dispense with ambient opening when proposing their calculus of Boxed Ambients [2,17,3,7]. They advocate communication between ambients where one is contained in the other, rather than the same- ambient communication of Mobile Ambients. A similar model of communica- tion is employed in [19].
We give an encoding of counter machines into pure MA without restriction, and without the open capability (Theorem 3.6), showing that this fragment is Turing complete. The encoding also demonstrates that both termination and the observation of weak barbs are undecidable problems. As far as we are aware, Turing completeness has not previously been shown for any pure ambient calculus without the capability to dissolve ambients (although we note that an encoding of pi-calculus into Boxed Ambients with communication is given in [2]).
Two different kinds of ambient movement were identified by Cardelli and Gordon [6]: subjective and objective. Subjective movement is where an ambi-

ent moves itself; objective movement is where it is moved by another ambient. For instance, if m[ P ] (an ambient named m containing process P ) is to enter another ambient n[ Q ], then control can reside in P or in Q. The standard calculus MA opts for subjective movement, while objective movement (so- called “push and pull”) has been studied in [20]. We shall show that counter machines can be encoded into the pure push and pull calculus (PAC) without the open capability.
A number of calculi are hybrids between subjective and objective move- ment; when handling the entry of m[ P ] into n[ Q ], they require P and Q to synchronise. In Mobile Safe Ambients (SA) [13,14], an ambient must explicitly allow itself to be entered by means of a co-capability. It is straightforward to encode standard MA into SA by equipping each ambient with the necessary co-capabilities. Therefore Turing completeness results for MA, such as that mentioned above, will extend to SA, but not the other way round.
Robust Ambients (ROAM) [10] is another calculus where ambients must synchronise to perform an entry. For m[ P ] to enter n[ Q ], P must name n and Q must name m, which is a symmetrical blending of subjective and objective movement. Turing completeness results for either MA or PAC will extend to ROAM (since our encodings use only a finite set of names).
As remarked above, MA and PAC are less synchronised between ambients than SA or ROAM. Movement can be made less synchronous within ambients if we require that movement capabilities have no continuations, so that if m[ P ] enters n[ Q ] then neither P nor Q can rely on when this has happened in the rest of their code. This may be called asynchronous movement. We show that both subjective and objective calculi with asynchronous movement (and without restriction) are Turing complete—there is enough power in processes being able to synchronise on dissolving ambients.
We are interested in finding minimal Turing complete fragments of AC. This entails showing that smaller fragments are too weak to be Turing com- plete. Busi and Zavattaro have shown that in the fragment of MA with the open capability, but without movement capabilities or restriction, it is decid- able whether a given process has a non-terminating computation [4]. We show the same decidability property for fragments with capabilities allowing move- ment in one direction only (either entering or exiting). We also show that in certain smaller fragments (where replication is only allowed on capabilities) every computation terminates.
The paper is organised as follows. In Section 2 we recall various operators and capabilities of the Ambient Calculus, together with their associated no- tions of reduction. In Section 3 we discuss various Turing complete languages, with and without the open capability. In Section 4 we show that certain frag-

ments of AC with replication are in fact terminating. In Section 5 we show that certain other fragments of AC have decidable termination. Finally we draw some conclusions.

Related Work
Since carrying out this work, we have very recently become aware of an in- dependent paper by Boneva and Talbot [1]. They present an encoding of two-counter machines (a Turing-complete formalism) into pure Mobile Am- bients without restriction and without the open capability. The fragment of AC we consider in Theorem 3.6 is similar to theirs, but they allow replication on arbitrary processes, while we only allow replication on capabilities. They show that reachability and name convergence (the observation of weak barbs) are both undecidable problems. As their encoding can take “wrong turnings” and is divergent, they have left the Turing completeness of their fragment of MA as an open question.
The focus of our work is different from that of Boneva and Talbot, in that we concentrate on Turing completeness and termination, while they concen- trate on reachability and model-checking in the ambient logic.

Operators and Capabilities
We will investigate a variety of operators and capabilities of pure Mobile Ambi- ents [6] and variants thereof. We let P, Q,... range over processes and M,... over capabilities which can be exercised by ambients. We assume a set N of names, ranged over by m, n,.. ., and a set of process variables (used for recursion), ranged over by X,.. ..
First we state a “portmanteau” process language which contains all the
operators which we shall consider.
P ::= 0 | n[ P ] | P | Q | M.P | νn P | ! P | X | rec X.P
Here as usual 0 denotes the inactive process. We shall feel free to omit trailing 0s and write empty ambients as n[ ] rather than n[ 0 ]. The process n[ P ] is an ambient named n containing process P . The process P | Q is the parallel composition of P and Q. The process M.P performs capability M and then continues with P . The process νn P is process P with name n restricted. As usual, restriction is a variable-binding operator. We denote the set of free names of a process P by fn(P ). The process ! P is a replicated process which can spin off copies of P as required. The process rec X.P is a recursion in which X is a bound process variable. We shall only consider processes where all process variables are bound. Recursion is unboxed [21,4] if in rec X.P any

occurrence of X within P is not inside an ambient. We shall only require unboxed recursion. If recursion is available then ! P can be simulated by rec X.(X | P ), and so we shall never require both replication and recursion.
Here is the set of all capabilities we shall consider:
M ::= open n | in n | out n | in n | out n | push n | pull n
The first capability open n is used to dissolve an ambient named n. The remaining capabilities all relate to movement. We can distinguish between subjective and objective moves: The capabilities in n and out n enable an ambient to enter or leave an ambient named n. This is subjective movement. Sometimes we consider the “safe” versions [13] of the capabilities where the ambient being entered or left performs “co-capabilities” in n or out n. By contrast, objective movement is where ambients are moved by fellow ambients. We consider the so-called “push” and “pull” capabilities of [20]. An ambient containing another ambient named n can use the capability push n to push the other ambient out. Similarly pull n can be used to pull in an ambient named n. Structural congruence ≡ equates processes which are the same up to struc-
tural rearrangement. It is defined by the following rules:
0 | P ≡ P	νn 0 ≡ 0
P | Q ≡ Q | P	νm νn P ≡ νn νm P
(P | Q) | R ≡ P | (Q | R)	! P ≡ P | ! P
νn (P | Q) ≡ (νn P ) | Q if n ∈/ fn(Q)	rec X.P ≡ P {rec X.P/X}
νn m[ P ] ≡ m[ νn P ] if m /= n
The reduction relation → between processes describes how one process can evolve to another in a single step. We start by defining the reductions associated with the capabilities.
(Open)	open n.P | n[ Q ] → P | Q
(In)	n[ in m.P | Q ] | m[ R ] → m[ n[ P | Q ] | R ]
(Out)		 m[ n[ out m.P | Q ] | R ] → n[ P | Q ] | m[ R ] (SafeIn)	n[ in m.P | Q ] | m[ in m.R | S ] → m[ n[ P | Q ] | R | S ] (SafeOut) m[ n[ out m.P | Q ] | out m.R | S ] → n[ P | Q ] | m[ R | S ] (Pull)		n[ pull m.P | Q ] | m[ R ] → n[ P | Q | m[ R ]] 
(Push)	n[ m[ P ] | push m.Q | R ] → n[ Q | R ] | m[ P ]
We shall be considering languages which only possess a subset of the full



set of capabilities. When we consider languages with capability in, we shall always have capability in as well, and we shall adopt rule (SafeIn) and not rule (In). Clearly, if a language has capabilities in, in and replication on these capabilities, then the effect of rule (In) can be simulated; every ambient can be made perfectly receptive to entering processes by converting n[ P ] into n[ ! in n | P ]. Similar considerations apply to capabilities out and out.
The remaining rules for reduction are

P → P '

n[ P ] → n[ P ' ]
P → P '

νn P → νn P '
P → P '

P | Q → P ' | Q
P ≡ P '	P ' → Q'	Q' ≡ Q

P → Q

We write ⇒ for the reflexive and transitive closure of →.
A language is a pair (L, →) consisting of a set of processes L together with a reduction relation →. We shall write (L, →) as L for short. We let L,... range over languages. We shall define a language by giving the set of processes. The reduction relation (and structural congruence) for the language will be tacitly assumed to be given by the set of all the rules in this section which are applicable to the available operators and capabilities, except as noted above for the “safe” and standard versions of the in and out capabilities. A computation is a maximal sequence of reductions P0 → P1 → ·· ·.
The most basic observation that can be made of a process is the presence of top-level ambients (i.e. ambients which are not guarded by capabilities or contained in other ambients) [6]. We say that n is a strong barb of P (P ↓ n) iff P ≡ νm1,... mk (n[ Q ] | R) (where n /= m1,... mk), and n is a weak barb of P (P ⇓ n) iff P ⇒ P ' ↓ n.

Turing-complete Fragments of AC
A basic measure of the computational strength of a process language is whether Turing machines, or some other Turing-complete formalism, can be encoded in the language. Cardelli and Gordon [6] established that pure Mobile Ambients can encode Turing machines. Busi and Zavattaro [4] improved this result by showing that counter machines (CMs) can be encoded in pure MA without restriction. They also showed that the fragment of pure MA with no movement capabilities (but with restriction) can encode CMs.
We shall show that CMs can be encoded in pure MA without restriction and without open. We shall also encode CMs in a version of MA with asyn- chronous movement (i.e. no continuations after capabilities), but with the open capability.

A Counter Machine (CM) is a finite set of registers R0,... , Rb (b ∈ N). Each Rj contains a natural number. We write Rj(k) for Rj together with its contents k. Initially the registers hold the input values. The CM executes a numbered list of instructions I0,... , Ia (a ∈ N), where Ii is of two forms:
i : Inc(j) adds one to the contents of Rj, after which control moves to Ii+1.
i : DecJump(j, i') subtracts one from the contents of Rj, after which control moves to Ii+1, unless the contents are zero, in which case Rj is unchanged and the CM jumps to instruction i'.
The CM starts with instruction I0, and executes instructions in sequence in- definitely, until control moves to an invalid instruction number (which we can take to be a + 1), at which point the CM terminates, and the output is held in the first register.
CMs as defined above are basically the Unlimited Register Machines of [22]. They use a set of instructions which is minimal while retaining Turing completeness [18]. (In fact CMs with just two registers are already Turing complete.)

Criteria for Turing Completeness
It is best to make clear what criterion for Turing completeness we shall use in this paper. Let CM be a CM (program plus registers with their contents). Let [CM ]] be the encoding of CM in a target fragment of AC. We shall require the following:
Criterion 3.1 • If CM terminates then every computation of [[CM ]] com- pletes successfully, meaning that it signals completion in some manner, ob- tains the correct result and makes the result of the computation (i.e. the contents of the first register) available in usable form to potential subse- quent computations to be performed by other processes.
If CM does not terminate, then no computation of [[CM ]] signals comple- tion.
In our encodings, completion will be signalled by the appearance of a particular ambient at the top level. So we can deduce ¿From the undecidability of the halting problem for CMs that for the target fragment it is undecidable in general for a process P and name n whether P ⇓ n.
Furthermore, our encodings will actually satisfy both Criterion 3.1 and the following additional property:
Criterion 3.2 • If CM terminates then every computation of [[CM ]] termi- nates.

If CM does not terminate, then no computation of [[CM ]] terminates.
We can therefore deduce that it is undecidable whether a process has an infinite computation. (In fact, this can still be deduced if the second item is weakened to: if CM does not terminate, then [CM ] has an infinite computa- tion.)
However, since Criterion 3.2 is not required for Turing completeness, we cannot deduce that a language fails to be Turing complete simply because ter- mination is decidable. There could still be an encoding of CMs into the target language where all computations of encoded CMs are infinite. When the CM terminates, the encoded CM reports a result in a finite time before diverging. Nevertheless, one can achieve separation results by showing Criterion 3.2 for one fragment and decidability of termination for another fragment.
Many encodings satisfy the following one-step preservation property: if CM moves in one step to CM ' then [CM ]] ⇒ [[CM ' ]. While one-step preser- vation is useful, we contend that it is needlessly strong for Turing complete- ness. Consider for instance a Turing machine (TM) which is non-erasing in the following sense: at each step it copies the tape contents to the next un- used part of the tape and then makes the change required by the instruction. Such a machine is clearly as powerful as a normal TM. However we cannot encode TMs into non-erasing TMs and satisfy the one-step preservation prop- erty, since the non-erasing TM has extra information. (Note that reachability of configurations is decidable for non-erasing TMs, since the tape contents keep on increasing in size, so that Turing completeness does not imply that reachability is undecidable.)
This is relevant to our concerns, since in our encodings we accumulate inert garbage. Just as with non-erasing TMs, this is no barrier to Turing completeness.
Remark 3.3 Hirschkoff, Lozes and Sangiorgi [11] give an encoding of TMs into a fragment of AC which satisfies one-step preservation, but where the en- coding may take a “wrong turning”. Such wrong turnings are strictly limited, in that the process will halt immediately in a state which cannot be mis- taken for successful termination. This is sufficient for them to claim Turing completeness, but we shall require that computations cannot take unintended paths.
Existing Work
Busi and Zavattaro gave encodings of CMs into two fragments of the pure AC. The first fragment, which we shall call Lop, is defined by
P ::= 0 | n[ ] | P | Q | open n.P | νn P | X | rec X.P

It is striking that empty ambients with no movement capabilities are enough. There is an essential use of restriction to obtain the effect of mutual recursion. Nevertheless, this result shows the strength of the open capability. We wish to investigate whether we can achieve Turing completeness without open.
Busi and Zavattaro’s second encoding of CMs is into the following lan- guage, which we shall call Lop:
P ::= 0 | n[ P ] | P | Q | open n.P | in n.P | out n.P | ! P
Notice that Lop does not require restriction, and uses replication rather than recursion. Independently, Hirschkoff, Lozes and Sangiorgi [11] have encoded Turing machines into Lop, with the additional syntactic constraint that the continuation of a capability must be finite, that is, must not involve replication.
“Asynchronous” Languages with open
In this subsection we show that there are Turing-complete AC languages even when we don’t allow continuations after movement capabilities. We show this both for objective movement (Theorem 3.4) and for subjective movement (Theorem 3.5).

Let Lop
be the following language (a fragment of the Push and Pull Am-

bient Calculus [20]):
P ::= 0 | n[ P ] | P | Q | open n.P | push n.0 | pull n.0 | ! open n.P
Note that push and pull have no continuation. We might refer to this as
asynchronous movement. Also, replication is only used with open.

Theorem 3.4 Lop
is Turing complete.

Proof. (Sketch) We describe an encoding of CMs into Lop . A CM will be encoded as a system consisting of processes encoding the registers in parallel with processes for each instruction.
We consider a particular CM called CM , with instructions I0,... , Ia and registers R0,... , Rb. Let CM (i : k0,... , kb) represent CM when it is about to execute instruction i and storing kj in register j (j ≤ b). Let the (unique) finite or infinite computation of CM = CM0 be CM0, CM1,... , CMl,.. ., where CMl = CM (il : k0l,... , kbl).
First we describe the registers. Rj(k) is encoded as rj[ k ], where the nu- meral process k is defined by
0 =df z[ ]	k +1  =df s[ k ]
Thus registers are distinguished by their outermost ambient.
In describing the encoding of the instructions, we must take into account the fact that the decrement/jump instructions will accumulate garbage each

time they are used, as the code for either decrement or jump is left unused. We therefore parametrise our encoding by the index l of the stage we have reached in the computation. Let dec(i, l) (resp. jump(i, l)) be the number of decrements (resp. jumps) performed by instruction i during the computation of CM up to, but not including, stage l.
We denote the encoding of instruction Ii by [Ii]]l, defined as follows:

[[i : Inc(j)]] =df
! open sti.rj[ pull rj |
s[ pull rj | open rj.sti+1[ ] | push sti+1 ] | push sti+1 ]

[[i : DecJump(j, i')]] =df ! open st .c [ pull r | open r .(S  | Z  ' )] |
! open di | ! open d' | (ci[ Ziji' ])dec(i,l) | (ci[ Sij ])jump(i,l)
S  =df d [ pull s | r [ pull s | open s.(e [ ] | push e )] | push e | st	[ ] ] |
open ei.push di
Z  ' =df open z.(d' [ r [ 0 ] | st ' [ ] ] | push d')

iji
i	j	i	i

We use Pk to abbreviate k copies of P in parallel. Notice that the continua- tions of all occurrences of open are finite (the same condition as used in [11] and mentioned in the previous subsection).
We define:
[[CM (i : k ,... ,k )]] =df st [ ] | [[I ]] | ··· | [[I ]] | r [ k  ] | ··· | r [ k  ]
0	b  l	i	0 l	a l	0	0	b	b

The encoding of CM is [CM ]]
=df [[CM ]]
. The instructions start without any

garbage. The encoded CM will go through successive stages [CMl]]l. We show that for each non-terminal stage l, [[CMl]]l ⇒ [[CMl+1]]l+1, and that [CMl]]l is guaranteed to reach [CMl+1]]l+1.
An instruction process [Ii]]l is triggered by the presence of sti at the top level; the instruction starts by consuming sti. The execution of [Ii]]l finishes by unleashing the sti ambient corresponding to the next instruction. Throughout the computation, at most one sti ambient is present. The encoded machine terminates if and when the ambient sta+1 appears at the top level. There are various cases depending on the nature of the instruction Ii.
An instruction process of the form [i : Inc(j)]]l creates a new register rj[ s[ ] ], which already contains the successor ambient needed to perform the increment. The new register pulls the existing rj into its core, and strips off the outer casing. The instruction then signals completion by pushing out the trigger for the next instruction. Computation is entirely deterministic. We have:
... sti[ ] | [[i : Inc(j)]]l | rj[ k ] ... ⇒ ... sti+1[ ] | [[i : Inc(j)]]l+1 | rj[ k +1 ] ... 

An instruction process of the form [i : DecJump(j, i')]]l creates a new am- bient ci, pulls in register rj and strips off its outer layer, leaving the numeral. This numeral has outermost ambient either s or z depending on whether the numeral is zero or a successor.
If the numeral is a successor it is pulled inside ambient di and then inside a new register ambient rj where it is decremented. The ambient di, containing the new incremented register along with the trigger sti+1, is then pushed out of ci, and opened to unleash the trigger. We have:
... sti[ ] | [[i : DecJump(j, i')]]l | rj[ k +1 ] ... 
⇒ ... sti+1[ ] | [[i : DecJump(j, i')]]l | ci[ Ziji' ] | rj[ k ] ... 
≡ ... sti+1[ ] | [[i : DecJump(j, i')]]l+1 | rj[ k ] ... 
The execution of the decrement leaves ci[ Ziji' ] behind as garbage, which does not take any further part in the computation. Again, computation is entirely deterministic.
If the numeral is zero, this is detected by open z, and a new ambient di, containing rj[ 0 ] along with the trigger sti' , is then pushed out of ci, and opened to unleash the trigger. We have:
... sti[ ] | [[i : DecJump(j, i')]]l | rj[ 0 ] ... 
⇒ ... sti' [ ] | [[i : DecJump(j, i')]]l | ci[ Sij ] | rj[ 0 ] ... 
≡ ... sti' [ ] | [[i : DecJump(j, i')]]l+1 | rj[ 0 ] ... 
Again, computation is entirely deterministic.
Finally, we see that if CML is terminal (so iL = a + 1) then [CML]]L has no reductions. [CML]]L displays barb sta+1 to indicate termination. The result of the computation, stored in register 0, is usable by subsequent computations. On the other hand, if CM does not terminate, then neither does [CM ]], and the barb sta+1 will never appear. There are no “bad” computations, i.e. ones which halt in a non-final state, diverge, or produce unintended behaviour. We have a encoding which shows Turing completeness, and also undecidability of termination and of weak barbs.	 
We can achieve exactly the same asynchrony for subjective movement,

though the encoding is more elaborate. Let Lop
be the following language:

P ::= 0 | n[ P ] | P | Q | open n.P | in n.0 | out n.0 | ! open n.P


Theorem 3.5 Lop
is Turing complete. (Proof: see full version [15].)

Languages without open
So far, all the languages considered have possessed the open capability. We shall show that this is not essential for Turing completeness, by encoding CMs into a language with just the standard movement capabilities, namely in and out.
Let Lio be the following language:
P ::= 0 | n[ P ] | P | Q | in n.P | out n.P | ! in n.P | ! out n.P
Clearly Lio is a sublanguage of Lop as defined earlier. The major difference is that Lio does not have the open capability. Also, replication is only applied to the capabilities. We shall see in Sections 4 and 5 that the computational strength of a language can depend on whether replication is applied to capa- bilities or to ambients.
Theorem 3.6 Lio is Turing complete.
Proof. (Sketch) One problem we encountered was in dealing with instruc- tions. Since each instruction Ii has to be used indefinitely many times, one might encode it as ! pi[ Pi ], where each time the instruction is needed a new copy of pi[ Pi ] is spun off. But then the previously used copies may interfere with the current copy, so that for instance acknowledgements may get mis- directed to old pi’s still present. This issue does not arise if we can destroy unwanted ambients using the open capability.
Registers consist of a series of double skins s[ t[ ... ]] with z[ ] at the core. We use a double skin rather than the more obvious s[ s[ z[ ] ] ] style. This is to help with decrementing, which is done by stripping off the outermost s and then in a separate operation stripping off the t now exposed.
We follow Busi and Zavattaro in carrying out the increment of a register by adding a new s[ t[ ] ] immediately surrounding the central core z[ ]. This seems preferable to adding a new double skin on the outside, since it keeps the increment code and decrement code ¿From interfering with each other.
The basic idea is that each instruction Ii is triggered by entering a sti ambient.	All the other instructions and all the registers enter as well—a monitor process checks that this has happened before Ii is allowed to execute. So the computation goes down a level every time an instruction is executed. When an instruction finishes, it unleashes the sti ambient to trigger the next instruction. If and when the computation finishes, the first register is sent up to the top level, where it can serve as input for possible further computations. Therefore we have Turing completeness. Our encoding furthermore estab- lishes that the weak barb relation is undecidable, and that having a nonter-
minating computation is undecidable.

As the computation proceeds, inert garbage accumulates in both the in- structions and the registers. We handle this much as in the proof of Theo- rem 3.4, letting the encodings of the instructions and the registers be para- metrised with the current step in the computation.
The computation is largely deterministic; the exceptions are that between executions of instructions, the instructions and registers make their way down a level in an indeterminate order, and there is also some limited concurrency in the increment.
See the full version [15] for the details.	 
Remark 3.7 In independent work, Boneva and Talbot [1] have encoded two- counter machines into the following language:
P ::= 0 | n[ P ] | P | Q | in n.P | out n.P | ! P
(Notice that this language differs slightly from Lio, in that it allows repli- cation of arbitrary processes, including ambients.) However, their encoding can diverge and take wrong turnings into error states, which means that they do not claim Turing completeness. Nevertheless because they establish one- step preservation, they can show that it is undecidable whether one process is reachable from another, and also whether P ⇓ n for an arbitrary process P and name n.
It is an open question whether reachability for arbitrary processes in Lio is decidable. Even if reachability were decidable for Lio, this would not contradict Turing completeness (see Section 3.1).
We have just encoded CMs into language Lio with the standard subjective movement capabilities (and without open). We can also encode CMs in the following language Lpp with objective moves:
P ::= 0 | n[ P ] | P | Q | push n.P | pull n.P | ! P
Theorem 3.8 Lpp is Turing complete. (Proof: see full version [15].)

Terminating Fragments of AC
We would like to know whether the language Lio of Subsection 3.4 is a minimal Turing-complete language. As a partial answer to this question, we shall show in this section that if we remove one of the movement capabilities (either in or out) then the resulting language is in fact terminating, i.e. every computation terminates.
Definition 4.1 A language (L, →) is terminating if every computation is fi- nite.

Let Li¯i be the following language:
P ::= 0 | n[ P ] | P | Q | in n.P | in n.P | ! in n.P | ! in n.P | νn P
Notice that Li¯i is got from Lio by removing the out capability and (in order to sharpen the next theorem) adding the co-capability in [13] and restriction.
Theorem 4.2 Li¯i is terminating.
Proof. (Sketch) First observe that if a process P of Li¯i has an infinite com- putation, then if we identify all the names of P and remove all restrictions, we still have an infinite computation, as all existing reductions can still occur (as well as potentially some new ones). Similarly, we can replace all capabil- ities by replicated capabilities. Thus it suffices to show the theorem for the sublanguage
P ::= 0 | m[ P ] | P | Q | ! in m.P | ! in m.P
where m is a single fixed name.
We first define the replication nesting depth (rnd) of a process: rnd(0) =df 0	rnd(P | Q) =df max(rnd(P ), rnd(Q)) rnd(m[ P ]) =df rnd(P )	 rnd(! in m.P ) =df rnd(P )+ 1
rnd(! in m.P ) =df rnd(P )+ 1
We next define the replication degree (abbreviated to rd, or simply degree) of an ambient m[ P ]. This is the rnd of the capability component of P , defined as follows. Any process P is structurally congruent to

   ! in m.Pi |    ! in m.Pj |    m[ Pk ]
1≤i≤I	1≤j≤J	1≤k≤K
where I, J, K ≥ 0, and I = 0 indicates that the parallel composition is empty (similarly for J, K). The capability component of P is

Pcap =df
 

1≤i≤I
! in m.Pi
| 
1≤j≤J
! in m.Pj

and we let rd(m[ P ]) =df rnd(P cap). This is well-defined with respect to struc- tural congruence. Notice that the degree of an ambient is unchanged through- out a computation. It is unaffected by other ambients entering of whatever degree. Also, no capability can ever disappear.
During a computation an ambient can produce “children”. For instance m[ ! in m.m[ ] ] can produce a series of new m[ ] ambients as it enters other ambients. These children will have strictly lower replication degrees. For a given ambient m[ P ] there is a fixed finite bound on the number of children which can be produced by a single reaction.



We can assume that all ambients are equipped with both ! in and ! in capabilities. Thus all ambients have degree ≥ 1.
We sketch two proofs of termination; the first relies on assuming a minimal infinite computation and then showing that there must be a smaller one, while in the second proof we restrict attention to a “top-level” reduction strategy, assign multisets to the processes in a computation and show that they are decreasing in a particular well-founded ordering.
Method 1. Suppose that P0 → ··· is an infinite computation. Let D0 be the maximum of the degrees of the (unguarded) ambients in P0. During the computation new ambients are created as children of existing ambients. They will all have degree less than their parents, and < D0. Since the computation is infinite, infinitely many children must be created. Let D < D0 be the maximum degree at which infinitely many children are created. In the whole computation there are only finitely many ambients with degree > D. At least one of these must be infinitely productive, that is, produce infinitely many children. Now let c > 0 be the number of infinitely productive ambients of degree > D.
We have shown how to assign a pair (D, c) (D ≥ 1, c ≥ 1) to each infinite computation. Now let P0 → ··· → Pi → ... be an infinite computation with a minimal value of (D, c) in the lexicographic ordering
(D, c) < (D', c') iff D < D' or (D = D' and c < c') .
We shall obtain a contradiction by showing that there is another infinite com- putation with a smaller value of (D, c).
Choose any infinitely productive ambient of degree > D. We can assume that it is available at the start of the computation, by removing a finite initial segment of the computation if necessary (this does not change the values of D and c). Each process Pi of the computation is of the form Ci{m[ Qi ]}, where we display the outer context and inner contents of our chosen ambient. Reductions either involve the context alone, the contents alone, or else they involve the chosen ambient as a principal—either entering or being entered. Since the ambient is infinitely productive, there must be infinitely many of this third type of reduction.
Now let us alter the computation by making the chosen ambient totally unproductive—simply remove the continuations of the capabilities exercised by the ambient. We still have an infinite computation, which is less productive than before. If the value of D is not reduced, then the value of c must have been reduced by at least one. Hence our new computation is lower in the lexicographic ordering, which is a contradiction.
Method 2. Let →' be the modification of standard → reduction (Sec- tion 2) where reduction is forbidden inside an ambient. Let ⇒' be the reflexive

and transitive closure of →'.
Suppose there is an infinite computation starting from
P ≡ Pcap |    m[ Pk ]
1≤k≤K
Then we must have K ≥ 1 for P to have a reduction. If K = 1 we write P  P1. Clearly P1 has an infinite computation. If K > 1, one can show that there is an infinite computation of P which begins with one particular top- level ambient being entered by all the other top-level ambients. Thus P ⇒' P ' where P ' has a  reduction. Putting all this together, we see that if P has an infinite → computation then P has an infinite ⇒'  computation.
To show that infinite ⇒' computations are impossible, we assign mul- tisets to processes and define an ordering on these multisets which is well- founded and strictly decreasing with respect to ⇒' .
Let P0,... , Pi,... be an infinite ⇒'  computation. We assign to each Pi a multiset Si. Its elements will be ordered pairs consisting of a natural number and a multiset of natural numbers. These numbers are all degrees of (unguarded) ambients in Pi.
We create S0 as follows: For each unguarded ambient m[ P ' ] of degree d
contained in P0, we add the ordered pair (d, ∅) to S0.
In the computation there are two kinds of reductions: →' and  . Suppose that Pi →' Pi+1. A →' reduction consists of an ambient m[ Q ] of degree d entering an ambient m[ Q' ] of degree d'. To these ambients there correspond elements (d, T ) and (d',T ') in Si. (Since we are doing a top-level reduction the two ambients are represented in the first elements of the pairs of Si.) The →' reduction will produce children of m[ Q ] of degree < d; we add their degrees to T . The reduction will also produce children of m[ Q' ] of degree < d'; we add their degrees to T '. In this way we create Si+1.
Now suppose that Pi   Pi+1. A   reduction essentially discards a top-
level ambient, while keeping its contents. Suppose this ambient is of degree d and corresponds to the element (d, T ) of Si. We remove the (d, T ) from Si and for each d' ∈ T we add (d', ∅) to Si. Note that each d' < d. In this way we create Si+1.
One can define an ordering on multisets over a well-founded ordering, by which S > S' if S' is got from S by replacing any element of S by a finite set of smaller elements. This ordering is well-founded [8]. Now if we consider just the first members of the pairs in the multisets Si we see that a →' reduction leaves the set unchanged, while a  reduction removes one element and replaces it with a finite set of smaller elements. So each ⇒' reduction takes us down in the > ordering. By well-foundedness of > there is no infinite ⇒' computation, and thus no infinite → computation.	 

It is also the case that a language with out as its only capability is termi- nating. Let Lo be the following language:
P ::= 0 | n[ P ] | P | Q | out n.P | ! out n.P | νn P
Notice that Lo is got from Lio by removing the in capability and (in order to sharpen the next theorem) adding restriction.
Theorem 4.3 Lo is terminating. (Proof: see full version [15].)
Notice that this is not the case in the language where we add co-capability out to Lo, in view of the counterexample n[ n[ out n ] | ! out n.n[ out n ] ]. This is equally the case when the co-capability is located at the upper level [16]: n[ n[ out n ]] | ! out n.n[ n[ out n ] ]. With “push” as the only capability we can have infinite computations, e.g. n[ n[ ] | ! push n.n[ ] ].
Remark 4.4 If we combine replication with the open capability we can create non-terminating processes such as n[ ] | ! open n.n[ ]. Busi and Zavattaro [4] showed that termination is decidable for processes built with replication and open (see Theorem 5.2 in Section 5).

Fragments of AC with Decidable Termination

Definition 5.1 We shall say that termination is decidable in a language (L, →) if, given any process P of L, it is decidable whether P has an infi- nite computation.
Busi and Zavattaro showed that termination is decidable in a language without restriction, and with open but no movement capabilities. They are able to allow unboxed recursion rather than merely replication. Their proof relies on the facts that any process has only finitely many names (since re- striction is absent), and that there is a finite bound on the nesting depth of ambients. These properties remain true if we add the out and push capabilities, since these cannot increase nesting depth of ambients.
Let Lop be the following language:
P ::= 0 | n[ P ] | P | Q | open n.P | out n.P | out n.P | push n.P |
X | rec X.P
Recursion is unboxed in Lop.
Theorem 5.2 Termination is decidable for Lop.
Proof. (Sketch) Straightforward adaptation of the proof of Corollary 4.10 of [4]. Busi and Zavattaro’s method is to show that a multiset-style ordering on

processes, under which, for instance, P is below P | Q, is a well-quasi-ordering. They then use the theory of well-structured transition systems [9] to deduce that termination is decidable. We make appropriate changes to their ordering on processes to incorporate the added capabilities.	 
Remark 5.3 We know that termination is undecidable for Lio (see proof of Theorem 3.6). It follows from Theorem 5.2 that there can be no embedding [[−]] from Lio into Lop which respects termination, in the sense that for any process P of Lio, P has a nonterminating computation iff [P ] has a nontermi- nating computation.
Matters are different when it comes to the in capability and full replication (rather than replication on capabilities, as considered in Section 4). Even such a simple process as ! n[ in n ] can have a computation with unbounded ambient nesting depth. The proof method of Theorem 5.2 is therefore not available.
Let Lin be the following language:
P ::= 0 | n[ P ] | P | Q | in n.P | ! P
Theorem 5.4 Termination is decidable for Lin.
Proof. (Sketch) We first convert a process P of Lin into a process PN by removing any occurrence of replication except on ambients and capabilities using the following equations (sometimes included in ≡):
! 0 = 0  ! (P | Q) = ! P | ! Q  ! ! P =! P
One can show that P has an infinite computation iff PN has an infinite com- putation. So we may now assume that Lin only allows replication on ambients and capabilities.
To decide whether a process P of Lin has a non-terminating computation,

we shall translate P into a non-standard process language LD
which has a

reduction relation →D which traps non-termination finitely, so that every computation terminates.
Let LD be the following language:
P ::= 0 | DIV | n[ P ] | P | Q | in n.P | ![ P ] | ! in n.P
Here DIV represents divergence. We translate a process P of Lin intoa process

PD of LD
using a function which is homomorphic apart from the case of a

replicated ambient:
(1)

(! n[ P ])D =df n[ P 'D ] | ![ P ]

Here P ' is got from P by removing the capability component of P , i.e. any in or replicated in capabilities which n[ P ] can exercise. We replace all replicated ambients after unfolding them exactly once. The replacement ![ P ] is not an

ambient and has nonstandard reduction rules to be given shortly. The spun-off ambient n[ P 'D ] is immobile, but available to be entered by other ambients.

Structural congruence on LD
is defined as in Section 2. The reduction

relation →D on LD is defined as follows: We let →D have all applicable rules defining standard reduction → in Section 2. To these rules we add the follow- ing two rules which trap divergence caused by replicated ambients:
(InDiv)	![ in m.P | Q ] | m[ R ] →D DIV
P →D P '

(AmbDiv)


![ P ] →D DIV

Notice that ![ P ] can engage in at most one reduction, and that DIV has no reductions. Therefore we can adapt Theorem 4.2 to show that every compu- tation in LD terminates. Furthermore, every process has a finite computation tree which can be constructed effectively. Then a process P of Lin has a non- terminating computation iff there is any occurrence of DIV in the computation tree of PD.
It is clear that any occurrence of DIV reflects an infinite computation of P . Thus if the rule (InDiv) is used in the tree of PD, then P must be reducible to a process with a subterm having a divergent computation of the form
! n[ in m.P ' | Q ] | m[ R ] → ! n[ in m.P ' | Q ] | m[ n[ P ' | Q ] | R ] → ··· .
Also, if the rule (AmbDiv) is used in the tree of PD then P must be re- ducible to a process with a subterm having a divergent computation of the form ! n[ P ' ] → n[ P '' ] | ! n[ P ' ] → ··· where P ' → P ''.
In the other direction, we must show that we have not limited too much the scope of PD to diverge. Equation (1) limits replicated ambients in two ways:
Firstly, the spun-off ambient is immobilised. This is justified because if the spun-off ambient were ever in a position to enter another ambient, then rule (InDiv) would also apply.
Secondly, only one ambient is spun off to create PD, while in Lin we allow indefinitely many. But if an unbounded number of spun-off ambients each do at least one reduction, rule (AmbDiv) would apply. If an unbounded number of spun-off ambients get entered, then each of these entries can be simulated using the single spun-off ambient of PD. (Of course this cannot in fact happen

since LD
is terminating.) Finally we might have a divergent computation

emerge in one particular spun-off copy after various ambients have entered. But if all ambients enter the same spun-off ambient, this divergence can also emerge. We conclude that PD does indeed trap every possible divergence of P , as required.	 

Conclusions and Future Work
The main contribution of this paper is to show that the open capability is not needed to obtain Turing completeness for pure Ambient Calculi. This implies that pure Boxed Ambients is Turing complete.
We have sought to establish the minimality of the language Lio by show- ing that removing either in or out capabilities leads to a failure of Turing completeness in a rather dramatic fashion: every computation terminates.
We briefly mention some open questions/future work:
As far as the study of the computational strength of fragments of pure Ambient Calculi is concerned, the major open question is the strength of the fragment with in and open capabilities (but not out).
The present work leads us to ask what might be a set of minimal constructs of AC capable of encoding regular expressions or context-free grammars.
We have found interesting links between our Method 2 in the proof of The- orem 4.2 and the proof of Theorem 2 of [12]: exploring this relation might lead to the discovery of interesting links with proof theory and independence results for Peano Arithmetic.

References
Boneva, I. and J.-M. Talbot, When ambients cannot be opened, in: Proceedings of FoSSaCS 2003, Lecture Notes in Computer Science 2620 (2003), pp. 169–184.
Bugliesi, M., G. Castagna and S. Crafa, Boxed ambients, in: Proceedings of TACS’01, Lecture Notes in Computer Science 2215 (2001), pp. 38–63.
Bugliesi, M., S. Crafa, M. Merro and V. Sassone, Communication interference in mobile boxed ambients, in: Proceedings of FSTTCS’02, Lecture Notes in Computer Science 2556 (2002), pp. 71–84.
Busi, N. and G. Zavattaro, On the expressiveness of movement in pure mobile ambients, in: Proceedings of F-WAN: Workshop on Foundations of Wide-area Network Computing, Malaga, July 2002, Electronic Notes in Theoretical Computer Science 66 (2002).
Cardelli, L. and A. Gordon, Mobile ambients, in: Proceedings FoSSaCS’98, Lecture Notes in Computer Science 1378 (1998), pp. 140–155, full version appears as [6].
Cardelli, L. and A. Gordon, Mobile ambients, Theoretical Computer Science 240 (2000),
pp. 177–213.
Crafa, S., M. Bugliesi and G. Castagna, Information flow security in boxed ambients, in: Proceedings of F-WAN: Workshop on Foundations of Wide-area Network Computing, Malaga, July 2002, Electronic Notes in Theoretical Computer Science 66 (2002).
Dershowitz, N. and Z. Manna, Proving termination with multiset orderings, Communications of the Association for Computing Machinery 22 (1979), pp. 465–476.
Finkel, A. and P. Schnoebelen, Well-structured transition systems everywhere!, Theoretical Computer Science 256 (2001), pp. 63–92.


Guan, L., Y. Yang and J. You, Making ambients more robust, in: Proceedings of the International Conference on Software: Theory and Practice, Beijing, China, August 2000, 2000,
pp. 377–384.
Hirschkoff, D., E. Lozes and D. Sangiorgi, Separability, expresssiveness, and decidability in the ambient logic, in: Proceedings of the Seventeenth Annual IEEE Symposium on Logic in Computer Science, LICS 2002 (2002), pp. 423–432.
Kirby, L. and J. Paris, Accessible independence results for Peano arithmetic, Bulletin of the London Mathematical Society 14 (1982), pp. 285–293.
Levi, F. and D. Sangiorgi, Controlling interference in ambients, in: Proceedings of the 27th Annual Symposium on Principles of Programming Languages, POPL ’00, ACM, 2000, pp. 352–364.
Levi, F. and D. Sangiorgi, Mobile safe ambients, ACM Transactions on Programming Languages and Systems 25 (2003), pp. 1–69.
Maffeis, S. and I. Phillips, On the computational strength of pure ambient calculi, Technical Report 2003/10, Department of Computing, Imperial College, London (2003).
Merro, M. and M. Hennessy, Bisimulation congruences in safe ambients (extended abstract), in: Proceedings of the 29th Annual Symposium on Principles of Programming Languages, POPL’02, ACM, 2002, pp. 71–80.
Merro, M. and V. Sassone, Typing and subtyping mobility in boxed ambients, in: Proceedings of CONCUR’02, Lecture Notes in Computer Science 2421 (2002), pp. 304–320.
Minsky, M., “Computation: finite and infinite machines,” Prentice-Hall, 1967.
Phillips, A., S. Eisenbach and D. Lister, From process algebra to Java code, in: Proceedings of the ECOOP workshop on Formal Techniques for Java-like programs, Malaga, Spain, 2002, Technical Report NIII-R0204, Computing Science Department, University of Nijmegen.
Phillips, I. and M. Vigliotti, On reduction semantics for the push and pull ambient calculus, in: Proceedings of IFIP International Conference on Theoretical Computer Science (TCS 2002), IFIP 17th World Computer Congress, August 2002, Montreal (2002), pp. 550–562.
Sangiorgi, D., Extensionality and intensionality of the ambient logics, in: Proceedings of POPL’01, ACM, 2001, pp. 4–17.
Shepherdson, J. and J. Sturgis, Computability of recursive functions, Journal of the Association for Computing Machinery 10 (1963), pp. 217–255.
Teller, D., P. Zimmer and D. Hirschkoff, Using ambients to control resources, in: Proceedings of CONCUR 2002, Lecture Notes in Computer Science 2421 (2002), pp. 288–303.
Zimmer,   P.,   On   the   expressiveness   of   pure   mobile   ambients, in: Proceedings of Express’00, Electronic Notes in Theoretical Computer Science 39 (2001) URL: http://www.elsevier.nl/locate/entcs/volume39.html
