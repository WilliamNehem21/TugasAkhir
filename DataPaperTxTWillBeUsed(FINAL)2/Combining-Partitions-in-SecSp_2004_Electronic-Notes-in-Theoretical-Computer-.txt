	Electronic Notes in Theoretical Computer Science 99 (2004) 31–47	
www.elsevier.com/locate/entcs



Combining Partitions in SecSpaces
Mario Bravetti, Roberto Gorrieri, Roberto Lucchi and Gianluigi Zavattaro
Dipartimento di Scienze dell’Informazione, Universita` di Bologna, Mura Anteo Zamboni 7, I-40127 Bologna, Italy.
E-mail: {bravetti, gorrieri, lucchi, zavattar}@cs.unibo.it

Abstract
SecSpaces is a data-driven coordination model that supports a tuple-based coordination space extended with mechanisms for controlling and authenticating the access to entries. This is achieved exploiting the notion of (symmetric and asymmetric) abstract partitions inside the space. In this paper we consider one of the limitations of SecSpaces: it is not well suited for supporting the atomic access to more than one partition at once. In order to tackle this limitation we extend the SecSpaces model introducing an operator to combine partitions; output operations can use the new operator to make an entry visible in more than one partition, and data-retrieval operations can use it to access atomically more than one partition. We formally define, in terms of a process calculus, this notion and we demonstrate the flexibility of this new mechanism via examples.


Introduction
Coordination languages and models aim at providing mechanisms and lan- guages for developing distributed applications in which the description of the internal behaviour of the active components and the description of their inter- dependencies are distinct and separated. In order to support this separation, general interaction models have been developed; one of the main approaches consists of separating the computation from the interaction information, and locating the former inside the active components and the latter inside a so- called coordination infrastructure. This approach is called data-driven coordi- nation when the interaction information is stored inside a shared data space. Linda [3] and its dialects [8,10,7,6] are the most prominent representatives of this family of coordination languages.

1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.002

The Linda coordination model is based on a common repository where the interacting components introduce and retrieve the coordination information: the data inside the repository are tuples (ordered sequences of data) and they are retrieved using a pattern matching mechanism. Processes willing to collect tuples indicate with a template the structure of the tuples they are interested in: the template indicates the number of fields and the exact content for some of these fields. A tuple inside the repository satisfies the template if it has the requested number of fields and it contains, at least in the indicated fields, the requested data.
The native coordination model does not include any support for control- ling the access to the data. For example, any process able to access the repository is also able to introduce, retrieve and consume any of the tuples inside the repository itself. Recent distributed applications such as Web Ser- vices, applications for Mobile Ad Hoc Networks (MANETs), Peer to Peer Applications (P2P) are inherently open to processes, agents, components that are not known at design time. When the Linda coordination model is ex- ploited to program the coordination inside this class of applications (see e.g. WSSecSpaces [5] for Web Services, Lime [6] in the context of MANETs and PeerSpaces [11] for P2P applications) it is convenient to extend the native coordination model with mechanisms for controlling the access, for authenti- cating the producer/consumer of data, for ensuring the secrecy of information, and so on.
Some extensions have been already presented in the literature. The Klaim model [7] (Kernel Language for Agent Interaction and Mobility) exploits clas- sic access control policies to manage the access of processes to tuple spaces. Access permissions describe the operations that each process may perform on each of the available tuple spaces. In open systems, especially in those with a high level of dynamicity, the managing of these information may be a crit- ical task, mainly because the system should support a rapid and sometimes uncontrolled evolution of the agent community. More precisely, new agents may frequently enter the system, as well as old agents may rapidly exit, in an uncontrolled manner. Moreover, in some applications it could be useful to have a finer grained control, e.g., at the level of tuples and not at the level of spaces. For example, we may want to ensure that an agent cannot read tuples with a private content, but it can read all of the other tuples.
SecOS [9] follows a quite different approach. The access rights are not associated to the agents, but all control information are stored inside the data. More precisely, SecOS supports two forms of locks which are called symmetric and asymmetric. The former exploits the same key to protect and access the information, while the latter uses a pair of keys, one to protect and another

one to access. This two locking techniques can be applied to protect either one single field inside a tuple or the whole tuple. In the first case the used locks are called Field-locks, while in the second one, they are called Object-locks.
A more recent proposal, called SecSpaces [2], continues the approach initiated by SecOS by refining its access control policies. More precisely, SecSpaces refines the idea of object locks while field locks are not modeled. However, this is not a limitative approach because field locks can be easily encoded in our model. For example, in SecOS it is not possible to discrimi- nate between the non-destructive readers and the destructive consumers of a tuple, and there is neither the possibility to avoid a reader of a tuple to re- produce exactly that tuple. In SecSpaces, on the other hand, it is possible to associate to the tuples two different access control information, one to be used for non-destructive read and the other one for destructive input operations. Moreover, when a tuple is accessed in SecSpaces, the reading process receives only the coordination information inside the tuple and not the access control information; thus, it is unable to reproduce exactly that tuple.
SecSpaces essentially permits to associate to the tuples two pairs of infor- mation, that now we call entries. Each pair (p, k) contains a symmetric access information p (called symmetric partition) and an asymmetric access informa- tion k (called asymmetric partition). For both kind of access information a default value is defined, thus processes can also explicitly set only one or none of them. In order for a reader to access an information, it must demonstrate the knowledge of p as well as of k, the access information corresponding the asymmetric partition k. Two of these pairs (p, k) are used; the first one is considered in the case the reader is willing to perform a non-destructive read operation, and the second is considered for destructive input operations.
In this paper we investigate, in the context of SecSpaces, the problem of modifying during the lifetime of the application the access control policies. This is particularly useful in applications where the participants may become able to access new resources because, e.g., they pay for it, or in applications where processes may access the shared resources according to an associated level of trust, and this level may increase or decrease according to their run- time behaviour.
Tha native SecSpaces model is not particularly suited to support appli- cations with this dynamic aspects. For example, if two separated groups of users decide at run time to join in a unique group, it is necessary to explic- itly modify the access control information stored inside the entries currently used from both those groups of users. An alternative solution is to permit the users to exploit more expressive access rights indicating the intention to atomically access the data of both groups. Suppose, on the other hand, that

it is necessary to exclude at run time a user from a group because its level of trust is decreased. In this context, to exclude a user means that it should have no more access to the new entries exchanged among the users of the group. Also in this case, the native SecSpaces model requires to explicitly modify the access control information stored inside the entries of the group.
The solution that we present consists of extending SecSpaces with the possibility to: i) create, at run time, fresh symmetric partitions, ii) combine partitions. We can combine partitions by using the merge operator, denoted by “:”, whose meanings depends on the operation the process is performing:
when a process perform a data-retrieval operation by using the merge of partitions p and p', that is p : p', it implicitly access the partitions p and p';
when a process inserts an entry into the space by combining partitions p and p', that is p : p', that entry will be visible by processes that have access to one among the p and p' partitions.
In the paper we demonstrate that this simple extension of the SecSpaces coordination model is expressive enough to add a significant level of dynamic- ity. For example, in order to exclude users from a group that exchange entries using the partition p, it is sufficient to produce a new partition p', to distribute the knowledge of p' only to the users that remain inside the group, and to start using: i) the new partition p' to exchange new entries, and ii) the combination p : p' to access all the entries produced by the group (all the new and all those ones produced before the group restriction).
It is worth noting that these extensions involve only the symmetric parti- tions and not the asymmetric ones. This follows from the fact that the two kinds of partitions are intended to represent different kinds of information. The symmetric partitions are used to limit the access to entries, while the asymmetric partitions are used to authenticate the producer/consumer of an entry. To this aim, the asymmetric partitions are intended to be produced and distributed using off-line mechanisms (such as standard public key infrastruc- tures PKI) and not the mechanisms provided by the SecSpaces coordination model.
The remainder of the paper is structured as follows: in Section 2 we recall the SecSpaces coordination model which is defined in terms of a process cal- culus, in Section 3 we extend the process calculus introducing the possibility to create new partitions as well as combining partitions, in Section 4 and 5 we describe some applications that demonstrate the flexibility of the new ex- tensions in order to model several access control policies, and in Section 6 we report some conclusive remarks.

The SecSpaces coordination model
SecSpaces [2] is a coordination model that supports secure data-driven coor- dination in open environments. SecSpaces extends Linda [3] by introducing some forms of control of the accesses to the entries stored in the coordination space, that permit for example to authenticate/identify the producer of an entry or its reader/consumer.
The coordination primitives of SecSpaces are the classical ones of Linda: out(e), in(t) and rd(t). The output operator out(e) inserts an entry e in the space. Primitive in(t) is the blocking input operator: when an occurrence of an entry e matching with the template t is found in the space, it is removed and its content is returned. The read primitive rd(t) is similar to in(t), but in this case the entry e is not removed from the space.
In order to express access permissions on entries SecSpaces extends the Linda tuples by decorating them with special control fields, namely partition and asymmetric partition fields. The former ones logically partition the space, while the latter ones provide a mean to discriminate between the write and the read/remove access permissions on each entry.
Let Mess, ranged over by m, n, .. ., be an infinite set of messages, Partition, ranged over by c, ct, .. ., be the set of partitions and AP artition, ranged over by k, k', kt, .. ., be the set of asymmetric partitions. We also assume that Partition (resp. AP artition) contains a special default value, say # (resp.
?), used to allow any agent to access the space. Let “ · : AP artition → AP artition” be a function, defining the co-key relationship, such that ? = ? and if k = k' then k' = k.
Access permissions on entries are expressed by the control fields; in order to discriminate between the rd and the in access permission, entries have two occurrences of control fields, one associated to in operations and the other one to the rd operations. Differently from entries, templates have only one occurrence of control fields that is not associated to a specific operation: they are dynamically associated to the operation the agent is willing to perform (i.e., rd or in).
The set Entry of entries, ranged over by e, e', .. ., is defined as follows:
→ [c]rd[c']in
[k]rd[k ]in

where c, c' ∈ Partition, k, k' ∈ AP artition and the tuple of data d→ is a term of the following grammar:
d→ ::= d | d; d→,
d ::= m | c | k.
A data field d can be a message, a partition or an asymmetric partition.

We define ˜· as the function that, given an entry e, returns its tuple of
→ [c]rd[c']in	→
data, i.e., if e = ⟨d⟩[r]rd[r']in , e˜ = d.
The set T emplate of templates, ranged over by t, t', .. ., is defined as follows:
t = ⟨d→t⟩[ct]
t
where ct ∈ Partition, kt ∈ AP artition and d→t is a term of the grammar
d→t ::= dt | dt; d→t, dt ::= d | null.
With respect to entries, data fields used by templates can also be set to an additional value (null) that denotes the wildcard: the wildcard is used to match with all field values.
Definition 2.1 Matching rule and return value – Let e = ⟨d1; d2; ... ;

d ⟩[c]rd[c']in
be an entry, t = ⟨dt ; dt ; ... ; dt
⟩[ct]
be a template and op ∈

n [k]rd[k']in	1	2	m [kt]
{rd, in} be an operation. Let ce and ke be the control fields of e associated to
op, we say that e matchesop t if the following conditions hold:
m = n
dti = di or dti = null, 1 ≤ i ≤ n
ce = ct

ke = kt.
If a rd or in operation with template t is performed on a matching entry e, only the data fields (and no control field) are returned, i.e., the return value is e˜.
Conditions (i) and (ii) rephrase the classical Linda matching rule, that is test if e and t have the same arity and if each data field of e is equal to the cor- responding field of t or if this latter one is set to wildcard. Condition (iii) tests that the partition field of the entry –associated to the operation op– is equal to that of the template. Condition (iv) checks that the asymmetric partition field of the template corresponds to the co-key of the asymmetric partition field of the entry associated to the operation op. Finally, a comment about return value of the data-retrieval operations: it does not include the control fields of the matching entries but only the data stored inside the tuple of data fields. In this way, new access permissions can be acquired only by performing read/input operations of entries containing partition or asymmetric partition values inside the tuple of data.
Partition fields can be viewed as a special kind of data fields that do not accept wildcard in the matching evaluation. Partition fields logically partition- ate the space (each partition contains the entries having a specific partition

value as partition field that identifies the partition) and the access to a par- tition is restricted to only those processes that know the partition identifier. Indeed, in order to perform an operation on a partition, processes must know the partition field identifying that specific partition. However, in order to allow any process to interact with each other via SecSpaces primitives, a spe- cial default value # of the partition field, that every one can use, has been defined. Similarly, a default value known by any process has also been defined for asymmetric partition fields (denoted by “?”).
The asymmetric partition fields, differently from partitions, make it possi- ble to discriminate between the write and the read/remove permission of an entry, simply by exploiting the different needed knowledge to produce or to read/remove an entry. For instance, in order to read an entry having asymmet- ric partition field set to k the process must use k as asymmetric partition field of the template, that can be an unknown value for the producer of that entry (because in only k is needed). Therefore, following the same idea of partitions, properly distributing these values we can assign processes the permission to perform a subset of possible operations on that entry.

SecSpaces with combined partitions
In this section we propose an extension of SecSpaces supporting dynamic composition of partitions. More precisely, we introduce a new merge operator on partitions (denoted by “:”) that can be used to express in which partitions an entry should be accessible (when writing) or in which partitions to perform the search of a matching entry (when reading or consuming). The language we are going to presents extends [1] by introducing the merge operator on partitions and an operator for the generation of new names for partitions. In Section 3.1 we present the extended language and the new definition of the matching rule, while Section 3.2 introduces the corresponding semantics.
The language
In this section the extended language is presented. More precisely, we first describe how partitions are extended with the new merge operator and then we formalize system configurations, that are composed of: processes exploiting SecSpaces coordination primitives and the state of the shared tuple space.
Let CP artition, ranged over by p, p', .. ., be the set of possible combina- tions of partitions defined by the following grammar:
p ::= c | p : p.
The combination of partitions can be a partition value or the merge of par- titions: “c : c'” represents the merge of the partitions identified by c and c'.

We also define ps : CP artition −→ P(Partition) as the function that, given a combination of partitions, returns the set of partitions it contains, whose definition is the following: 1
ps(c)= {c},	ps(p1 : p2)= ps(p1) ∪ ps(p2).
Entry and template structure change in the symmetric partition fields that now contains, instead of a partition c ∈ Partition, a combination of partitions

p ∈ CP artition. An entry e = ⟨d→⟩[p]rd[p']in
rd	in
means that it is available (i.e. it

appears) in the partitions contained in ps(p) and in ps(p') for the rd and the
in primitives, respectively. On the other hand, a template t = ⟨d→⟩[pt] means
t
that the matching entry must be available in at least one partition in ps(pt). The definition of the matching rule between entries and templates follows.
Definition 3.1 Matching  rule  with  combined  partitions  –	Let e =

⟨d ; d ; ... ; d
⟩[p]rd[p']in
be an entry, t = ⟨dt ; dt ; ... ; dt
⟩[pt]
be a template

1	2	n [k]rd[k']in	1	2	m [kt]
and op ∈ {rd, in} be an operation. Let pe be the combined partition of e
associated to op, we say that e matchesop t if conditions (i), (ii) and (iv) of Definition 2.1 and the following condition hold:
(iii)’ ps(pe) ∩ ps(pt) /= φ.
Condition (iii)’ replaces (iii) of Definition 2.1 substantially checks that there is at least one partition in which e is available that is contained in the set of partitions indicated by the template.
When a matching entry is accessed from a removal operation, it is removed by any partition in which it appears. The idea is that a process can exploit the merge mechanism to produce an entry that must appear in more than one partition by performing just one out operation; if a process needs to produce more than one occurrence of the entry, it must perform an out operation for each occurrence it needs.
It is worth noting that the same mechanisms can be implemented by in- troducing, in the SecSpaces model, the non-blocking rdp and inp primitives corresponding to the rd and in, and a transaction mechanism. Non-blocking data-retrieval primitives have the same behaviour of the corresponding block- ing ones in the case a matching entry is available, while in the opposite case they immediately return with a failure value indicating the absence of a match- ing entry. When processes need to perform a data-retrieval primitive accessing more than one partition, say c and c' (the extension to a generic number is straightforward), they can exploit non-blocking primitives by alternatively

1 We assume that associative property for the merge operator holds, that is (c : c′): c′′ =
c : (c′ : c′′).

performing the access to partition c and to c' until a matching entry is found. On the other hand, in order to produce an entry that should appear in more than one partition, an occurrence of the entry can be introduced in each par- tition in which it should be available. Transactions are necessary because, in order to consume that entry, the in operations should perform atomically the removal of the matching entry from each partition in which it appears.
The entries stored in the TS are represented as members of parallel compo- sition as processes. Let V ar, ranged over by x, y, .. ., be the set of data vari- ables. In the following, we use →x, →y, .. ., to denote finite sequences x1; x2; ... ; xn of data variables.
System configurations, ranged over by A, B, .. ., and processes, ranged over by P , Q, .. ., are defined as follows:
A, B, ... ::=	systems
e	entries
P	processes
A | A	parallel composition
(ν c) A	restriction

P , Q, ... ::=	processes
0	null process
out e.P	output
rd t(→x).P	read
in t(→x).P	input
P | P	parallel composition
!P	replication
(ν c) P	restriction

A system can be an entry, a process or the parallel composition of entries and processes. (ν c) A means that the partition name c is bound in the system
A. A process can be a terminated program 0, a prefix form µ.P , the parallel composition of two programs, the replication of a program or it can contain a partition name whose scope is restricted to the process. The prefix µ can be one of the following classical Linda operations: i) out e, that writes the entry e in the TS; ii) rd t(→x), that given a template t reads a matching entry e in the TS and stores the return value in →x; iii) in t(→x), that given a template t consumes a matching entry e in the TS and stores the return value in →x. A process P | Q is the parallel composition of two processes P and Q behaves as two processes running in parallel. Recursive process are expressed by using the replication operator !P , whose meaning is the parallel composition of infinite

copies of P . Finally, processes can have bound names (partitions): (ν c) P means that the partition name c is bound in the process P , hence it is known only by P .
In the following, we use P [d/x] to denote the process that behaves as P in which all occurrences of x are replaced with d. We also use P [d→/→x] to denote the process obtained by replacing in P all occurrences of variables in
→x with the corresponding value in d→, that is P [d1; d2; ... ; dn/x1; x2; ... ; xn]= 
P [d1/x1][d2/x2] ... [dn/xn].
→ [c]rd[c']in
We say that a system is well formed if each rd/in ⟨dt⟩[k]rd[k']in (→x) operation
is such that the variables →x and the tuple of data d→t have the same arity. Let f n(A) and fv(A) be the functions that given a system A return the set of names that syntactically occur in A and the set of free variables in A, respectively. We say that a system is closed if it has no free variable. In the following, we consider only systems that are closed and well formed; we denote with System the set of such systems.

Semantics
In this section we present the semantics of systems by defining a structural congruence over systems and by mapping them on a reduction relation that describes how the system is reduced after one step of computation.
Table 1 describes a relation (structural congruence) indicating syntactic differences between systems that do not influence the behaviour of processes. More precisely, identity (i), reflexive (ii) and transitive (iii) relations hold, the order of the systems parallel composition is not relevant (iv), associative rela- tion holds (v), portions of system can be replaced with other ones structurally equivalent (vi), null processes have no influence on the behaviour of the system (vii), replication operator !P corresponds to an infinite parallel composition of P (viii), (ix), (x) and (xi) represent the scope laws and, finally, (xii) describes the alpha conversion (i.e. choice of bound names is irrelevant). The structural congruence over systems is defined as the smallest congruence satisfying rules (i), .. ., (xii).
Table 2 contains the system reduction rules. Rules (1), (2) and (3) describe the three prefix operators in, rd, and out, respectively. More precisely: (1) shows that the process in t(→x).P can perform the input if there exists an entry e currently available in the TS that matches the template t and, in this case, e is removed from the TS and the process behaves as P [e˜/→x]; (2) shows that the process rd t(→x).P can perform the read operation if there exists an entry e currently available in the TS that matches the template t and, in this case, the process behaves as P [e˜/→x], and (3) shows that out e.P produces in one



Table 1
Structural equivalence over systems

step a new occurrence of the entry e into the TS and then the process behaves as P . Rules (4), (5) and (6) describe the behaviour of processes running in parallel, that we can replace at any time a system with another one structurally congruent, and how the interaction is restricted to the processes within the scope operator, respectively. It is worth noting that rules (xi) and (xii) of Table 1 and rules (1) and (2) allow us to implement the scope extrusion of partition names as originally proposed in the π-calculus [?].

Group communication examples
The aim of this section is to describe scenarios where the extension of SecSpaces we propose can be exploited to manage important task.	In previous pa- pers [1,2] we have already proved that some security properties in the in- teraction among processes can be guaranteeted. In particular, we have shown that it is possible to guarantee data secrecy, producer and receiver authenti-



Table 2 Transition system


cation of an entry and data availability. Here we now recall recall the idea, that we have already introduced in those papers, to implement a secure group communication, where only entities of the group can access the entries used in the group communication. In that work, we have considered a simple so- lution in which the entities in the group share a secret partition, say c (that can be considered as a session partition) that is used to restrict the access to the exchanged entries: any communication is done by using entries and templates having c as partition field. In this way, no other process can read, remove or produce an entry used to realize the group communication be- cause c is not a public value, thus guaranteeing the privacy of the exchanged data. An example of secure group communication follows (for the sake of simplicity asymmetric partition fields, assumed that they are set to default value, are omitted): (ν c) rd ⟨null⟩[c](x).out(⟨x⟩[c]rd[c]in ) | out(⟨d⟩[c]rd[c]in ). A proposal of how to distribute the partition value c in a secure way (assuming that asymmetric partition fields are properly distributed as explained in the Introduction), to each process of the group, is described in Section 4.1.
While it is easy to manage the insertion of new entities in the group, because it can be done simply by transmitting (in a secure way) the secret partition of the group to the entity that is willing to enter (technically this is obtained by scope extrusion, see Section 3.2), it is more complicated to manage the removal of certain entities from the group communication, that is an usual function of group key management systems, because a new partition should be created and distributed to the processes in the group except the one to be removed. A more general problem is to restrict the access to certain entries to a subgroup of entities in the group. Section 4.1 explains how to manage

the group restriction by exploiting the merge operator. Finally, Section 4.2 describes how to combine partitions in order to manage, at run-time, the coordination among two (or more) independent groups of processes. More precisely, we intend to provide a support for those applications that need to publish some data and make them available to more than one group of users, or to control the flow of exchanged data among different groups.
Group restriction
Let G = {P1,... , Pn} be a group of processes that exploit a shared (and private to the group) partition c to communicate with each other in the group, and Gp = {Pi, Pi+1 ... , Ps} ⊆ G be a subset of the processes in G.
The problem we consider in this section is to:
provide a secure group communication for groups G and Gp, and
allow processes in Gp (that should be considered privileged processes of G) to perform data-retrieval operations that can atomically access entries available either at the whole group or to privileged processes.
The solution we propose is to define, besides c, a new partition c' that is a shared and private value of privileged processes that exploit it in order to restrict the communication at the level of group Gp. More formally, the system configuration we want to define is the following:
(ν c) (P | ... | P   | (ν c') (P | ... | P ) | ... | P ).
Statements i) and ii) hold because: 1) each process in G can communicate with each other in the group by using c as partition field of the entries/templates and, in addition, privileged processes can also restrict the communication to
'	'
the group Gp by inserting entries with a partition set to c', e.g., out(⟨d⟩[c ]rd[c ]in ;
2) privileged processes in one step can access the two partitions, simply by exploiting the merge operator, indicating c : c' in the partition field of the template, for instance rd ⟨null⟩[c:c'](x). A particular instance of this problem is the removal of some users from the group: in this case to combine the partition c with the new partition c' allow us to atomically access the new entries as well as to those ones produced before the removal of such users.
The following example describes a possible way to implement the secure distribution of c' to the processes in Gp.
Example 4.1 Given a process Pi that generates the new partition c', we con- sider a set of s − i asymmetric partitions kij with j such that j : i +1 ≤ j ≤ s. We assume that for every i +1 ≤ j ≤ s, kij is known only by the process Pi while kij is known only by Pj. The group restriction can be implemented by exploiting the following distribution protocol:



(ν c) (P
| ... | P	| P ' | ... | P ' | ... | P )



where
P ' = (ν c') out(⟨c'⟩[c]rd[c]in


).out(⟨c'⟩[c]rd[c]in


) ... 

i

.out(⟨c'⟩[c]rd[c]in
is rd  is in

P ' = in ⟨null⟩[c]
[ki(i+1)]rd[ki(i+1)]in

).Pi, and
(x).Pj, for i +1 ≤ j ≤ s.
[ki(i+2)]rd[ki(i+2)]in

j	[kij ]
P ' creates a new partition c' and then distributes it to the processes in Gp thus

reaching the configuration (ν c) (P1
| ... | P
i−1
| (ν c') (Pi
| ... | Ps) | ... | Pn).

It should be clear that the entry ⟨c'⟩[c]rd[c]in
ij rd  ij in
can be produced only by P ' and

that only P ' can access that entry, for any i +1 ≤ j ≤ s.

Group coordination
In this section we discuss how to exploit the merge operator in order to support the coordination among different groups, such as to distribute data to more than one group. The idea we follow is that a process (a new one or one elected among those in the groups) takes the role of coordinator ; it knows the partition associated to each group and, by merging all (or part of) group partitions, can insert entries that will be accessible to all (or part of) groups as well as read and remove all entries generated by all groups.
We consider the case where two groups have to be coordinated, the exten- sion to an arbitrary number of groups is straightforward. Let G = {P1,... , Pn} and G' = {P ',... ,P '} be two groups of processes that exploit a shared (and
1	k	'

private to the group) partition c and c
group, respectively.
to communicate with each other of the

We describe in the details the case in which the coordinator provides to groups a way to insert data that should be accessible in both groups (i.e. partitions c and c'). In order to avoid to give direct access to the partitions of the other groups, we assume that each group has an identifier and that knows the group identifiers of the other groups; we use g and g' for the group G and G', respectively. When a process of the group (e.g., G) is willing to produce an entry that should be available in other groups, it produces an entry in its space that contains, in the tuple of data fields, the identifiers of the group in which the entry should be available and the data d it is willing to publish (e.g., out(⟨g'g, d⟩[c]rd[c]rd )). The coordinator removes such entries, logs the request

and then publishes the entry. The coordinator process definition follows:
!(in ⟨null; null⟩[c:c'](x ; x ).LogReq(x ,x ).out(⟨x ⟩[P (x1)]rd[P (x1)]in )),
1	2	1	2	2
where LogReq registers the request and P (grp) returns the expression that merges the partitions identified in grp (e.g., P (g'g) = c : c'). The role of coordinator can also be extended by also managing access rights, i.e. checking if a group can write in a specified group. It is worth noting that the same approach can be used if, instead of c and c', we have to manage two combi- nations of partitions, in this case we distribute information that are already available in more than one partition.

A system with multi-level security
The flexibility and the expressiveness of the proposed extension is proved in this section by implementing a multilevel system where a process having access to a certain level l can also access to each level higher than l.
In order to be as general as possible, we consider that an hierarchical tree describes the security levels of the system, represented by nodes, and their (partial) ordering relation, that is: each node (level) is higher than each child. The model we intend to encode in SecSpaces allows, given a level l, to: i) produce a new datum at the specified level l, and ii) perform a data-retrieval operation that can access datum available either at the level l or at the levels higher than l. In other words, in this system, a datum produced by processes accessing level l are available in l and in all levels l' for which l is higher than l'. In this way, each leaf of the hierarchical tree can access each level in the path leaf-root and may be considered as the level with maximum privileges
among those in the path.
In order to encode the system we proceed in two steps: i) we introduce a new operator for sub-partition the partitions that will be exploited to en- code the system, and ii) we encode the introduced operator by exploiting the proposed merge one.
In order to introduce sub-partition operator we extend the syntax of par- titions:
p ::= c | p : p | p → p.
Given a partition p1, the sub-partition operator allow us to introduce new partitions (p1 → p, for any p) which are by definition sub-partitions of p1. In general, a partition is a sub-partition of another one if the name of the latter is a prefix of the former one (e.g., p1 → p2 → p3 is a sub-partition of p1 → p2 as well as of p1).
The idea we follow is that partitions represent the nodes (i.e. levels) of the

hierarchical tree and that the sub-partition operator allows us to express the relation between nodes and ancestors: each partition, say p1, is an ancestor of each sub-partition of p1, for instance p1 → p expresses that p1 is an ancestor of p1 → p (e.g., p → c has father p) and then p1 has a level higher than p1 → p. The definition of the function ps is extended with the following case:
ps(p1 → c)= {p1 → c}∪ ps(p1).

By using the merge and sub-partition operators to combine partitions, the matching rule (see Definition 3.1) allows to match entries that appear either in the partition specified by the template or in each partition with higher level. In order to encode the system, we assume that the knowledge of the se- curity levels identifiers (i.e. partitions which also represent hierarchical level relationship via the → operator) has been properly distributed to the pro- cesses; this phase can be done by exploiting asymmetric partition fields (for more details see [2]). The multilevel system provides the following primitives,
whose encoding is:
out(d→, p)= out(⟨d→⟩[p]rd[p]in ), that inserts the datum d→ in the level p,
rd(d→t, p)= rd⟨d→t⟩[p](→x), that reads a datum matching with d→t by using access level p, and
in(d→t, p)= in⟨d→t⟩[p](→x), that consumes a datum matching with d→t by using access level p.
It should be clear that the system so defined encodes the multi-level system described above. For instance, a process having access to the level p1 → p can read/consume any data available at a level in ps(p1 → p).
Finally, here we show how to encode the sub-partition operator by ex- ploiting only the merge operator. The only change regards the partition field value used by the SecSpaces primitives, that is: i) in the out primi- tive we keep the same partition p; in the case it contains the sub-partition operator, it will be considered as part of the partition name, and ii) in the rd/in primitive, p is encoded as the application of the merge operator to each partition determined with the extended definition of ps(p) consid- ered in this section. For instance, out(d→, (c1 : c2) → c3) is encoded with out(⟨d→⟩[(c1:c2)→c3]rd[(c1:c2)→c3]in ) that produces an entry in a partition that is to an higher level than the one used by rd(d→t, ((c1 : c2) → c3) → c4), encoded with rd⟨d→t⟩[(((c1:c2)→c3)→c4):((c1 :c2)→c3):(c1 :c2)](→x). It is worth noting that the knowledge necessary for the encoding can be derived (by using the extended definition of ps) from the datum stored in the primitives, therefore we do not need to modify the knowledge of the processes.

Conclusion and future work
In this paper we have introduced an extension of SecSpaces in order to pro- vide a solution for problems such as group communication management or interactions among processes with different levels of access permission. The flexibility of the proposed solution has been proved by describing several ex- amples in which it is necessary a support for run-time managing of the scope of entries.
Finally, as future work, we intend to compare the extended version of SecSpaces with some multilevel systems, such as [4] that is a multilevel system supporting one-way flow that has some similarities with the model described in Section 5.

References
Mario Bravetti, Roberto Gorrieri, and Roberto Lucchi. A formal approach for checking security properties in secspaces. In Riccardo Focardi and Gianluigi Zavattaro, editors, Electronic Notes in Theoretical Computer Science, volume 85. Elsevier, 2003.
Nadia Busi, Roberto Gorrieri, Roberto Lucchi, and Gianluigi Zavattaro. Secspaces: a data- driven coordination model for environments open to untrusted agents. In Antonio Brogi and Jean-Marie Jacquet, editors, Electronic Notes in Theoretical Computer Science, volume 68. Elsevier, 2003.
D. Gelernter. Generative Communication in Linda. ACM Transactions on Programming Languages and Systems, 7(1):80–112, 1985.
Myong H. Kang, Andrew P. Moore, and Ira S. Moskowitz. Design and Assurance Strategy for the NRL Pump. In Proc. IEEE High-Assuruance Systems Engineering Workshop (HASE97).
Roberto Lucchi and Gianluigi Zavattaro. WSSecSpaces: a Secure Data-Driven Coordination Service for Web Services Applications. In Proc. of ACM Symposium on Applied Computing (SAC’04). ACM Press, 2004.
A. Murphy, G. Picco, and G.-C. Roman. A middleware for physical and logical mobility. In
21st International Conference on Distributed Computing Systems, pages 524–533, 2001.
R. De Nicola, G. Ferrari, and R. Pugliese. KLAIM: A Kernel Language for Agents Interaction and Mobility. IEEE Transactions on Software Engineering, 24(5):315–330, May 1998. Special Issue: Mobility and Network Aware Computing.
Sun  Microsystems,  Inc.	JavaSpacesTM Service Specification, 2002. http://www.sun.com/jini/specs/.
Jan Vitek, Ciar´an Bryce, and Manuel Oriol. Coordinating Processes with Secure Spaces.
Science of Computer Programming, 46:163–193, 2003.
P. Wyckoff, S.W. McLaughry, and D.A. Ford. TSpaces. IBM System Journal, August 1998.
Gianluigi Zavattaro. PeerSpaces: Data-driven Coordination in Peer-to-Peer Networks. In Proc. of ACM Symposium on Applied Computing (SAC’03), pages 380–386. ACM Press, 2003.
