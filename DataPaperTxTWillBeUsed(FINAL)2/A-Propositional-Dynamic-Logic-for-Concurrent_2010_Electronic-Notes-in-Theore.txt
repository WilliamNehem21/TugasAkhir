

Electronic Notes in Theoretical Computer Science 262 (2010) 49–64
www.elsevier.com/locate/entcs

A Propositional Dynamic Logic for Concurrent Programs Based on the π-Calculus
Mario R. F. Benevides1,2
Computer Science Department and Systems and Computer Engineering Program, Federal University of Rio de Janeiro, Brazil
L. Menasch´e Schechter1,3
Systems and Computer Engineering Program, Federal University of Rio de Janeiro, Brazil

Abstract
This work presents a Propositional Dynamic Logic (πDL) in which the programs are described in a language based on the π-Calculus without replication. Our goal is to build a dynamic logic that is suitable for the description and verification of properties of communicating concurrent systems, in a similar way as PDL is used for the sequential case. We build a simple Kripke semantics for this logic, provide a complete axiomatization for it and show that it has the finite model property.
Keywords: Dynamic Logic, Concurrency, Kripke Semantics, Axiomatization, Completeness


Introduction
Propositional Dynamic Logic (PDL) [7] plays an important role in formal specifica- tion and reasoning about sequential programs and systems. PDL is a multi-modal logic with one modality P for each program P . The logic has a set of basic programs and a set of operators (sequential composition, iteration and nondeter- ministic choice) that can be used to build more complex programs from simpler ones. A Kripke semantics can be provided, with a frame  = (W, RP ), where W is a non-empty set of possible program states and, for each program P , RP is a

1 The authors were supported by grants from the Brazilian research agency CNPq.
2 Email: mario@cos.ufrj.br
3 Email: luis@cos.ufrj.br

1571-0661© 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.04.005

binary relation on W such that (s, t)  RP if and only if there is a computation of
P starting in s and terminating in t.
The π-Calculus is a well known process algebra, proposed by Milner, Parrow and Walker [11], for the specification of communicating concurrent systems. It is an extension of Milner’s CCS [10] that is able to describe not only non-determinism and concurrency, but also mobility of processes. It models the concurrency and interaction between processes through individual acts of communication. A pair of processes can communicate through a common channel and each act of commu- nication consists of a message (which, in the π-Calculus, is also a channel name) being sent at one end of the channel and immediately being received at the other. A π-Calculus specification is a description of the behaviour expected from a system, based on the communication events that may occur. As in PDL, the π-Calculus has a set of operators (action prefix, parallel composition, nondeterministic choice and restriction on acts of communication) that are used to inductively build process specifications from a set of basic actions.
This work presents a Propositional Dynamic Logic (πDL 4 ) in which the pro- grams are described in a language based on the π-Calculus without replication. There are, in the literature, some other logics that make use of CCS or the π- Calculus. However, they use these process algebras as a language for the descrip- tion of frames and models, while using standard modal logics for the description of properties (see, for example, [12] and [6]). The logic that we develop in the present work uses the π-Calculus in a distinct way. Its operators and constructions are added to a basic modal logic in order to create a dynamic logic where it is simple to describe and verify properties of communicating, concurrent, non-deterministic and mobile programs and systems, in a similar way as PDL is used for the sequential case. As such, this logic is an extension of the logics from our previous works [3] and [2], which develop propositional dynamic logics based on CCS.
It should be emphasized that the contribution of this work is on the field of dynamic logics and not on the field of process algebras. From process algebras, we just borrow a set of operators that are suitable for the description of communication and concurrency. We use these operators because they have a well-established theory behind them and we can use many of its concepts and results to help us build our logic.
Our logic is related to Concurrent PDL (CPDL) [15] and Channel-CPDL [14], but has advantages over both. The former can only describe properties of concurrent systems with no communication between the components and while the latter is able to describe interesting properties of communicating concurrent systems, it does not have a simple Kripke semantics (in fact, “a formal definition of the semantics of channel-CPDL is rather complicated” [14]) and its satisfiability problem can be
proved undecidable (Π1-hard), which also implies that it does not have a complete
axiomatization. On the other hand, due to the use of the π-Calculus mechanisms of communication and concurrency, our logic has a simple Kripke semantics, the finite

4 The pun here comes from the fact that the name of the letter π in Greek and the name of the letter P
in English are pronounced exactly the same way.

model property, a straightforward axiomatization and can also deal with mobility. Our logic can also be seen as an extension of PDL with Interleaving (iPDL) [9]. In iPDL, the parallel operator that is present in the logic is similar to the parallel operator of the π-Calculus, but it only allows interleaving of the actions in parallel programs, while the parallel operator of the π-Calculus (in conjunction with the restriction operator) also allows communication, synchronization and mobility.
The rest of this paper is organized as follows. In Section 2, we introduce the necessary background concepts: Propositional Dynamic Logic and the π-Calculus. Our logic (πDL), together with a couple of simple examples of its application and a complete axiomatic system, is presented in Section 3. Finally, in Section 4, we state our final remarks. We omit some of the proofs in the text, when they follow directly from previously stated results.
Background
This section presents two important subjects. First, we make a brief review of the syntax and semantics of PDL. Second, we present the π-Calculus together with some useful concepts, properties and results from its theory. We do not assume a familiarity with the π-Calculus, since process algebras are by no means a universally studied topic among (modal) logicians. We introduce here all that is necessary for our presentation in the next sections, trying to make this work as self-contained as possible.
Propositional Dynamic Logic
In this section, we present the syntax and semantics of PDL. For a more detailed account, [4] can be consulted.
Definition 2.1 The PDL language consists of a set Φ of countably many proposi- tion symbols, a set P of countably many basic programs, the boolean operators and	, the program constructors ;,	and ∗ and a modality P for every program
P . The formulas are defined as follows:
ϕ ::= p |Т| ¬ϕ | ϕ1 ∧ ϕ2 | ⟨P ⟩ϕ, with P ::= a | P1; P2 | P1 ∪ P2 | P∗,
where p ∈ Φ and a ∈ P.
In all the logics that appear in this paper, we use the standard abbreviations
⊥≡ ¬Т, ϕ ∨ φ ≡ ¬(¬ϕ ∧ ¬φ), ϕ → φ ≡ ¬(ϕ ∧ ¬φ) and [P ]ϕ ≡ ¬⟨P⟩¬ϕ.
Definition 2.2 A frame for PDL is a tuple  = (W, Ra a∈P) where W is a non- empty set of states and Ra is a binary relation for each basic program a. Besides that, we inductively build binary relations RP , for each non-basic program P , using

the rules RP1;P2 = RP1  RP2 , RP1∪P2 = RP1  RP2 and RP ∗ = RP∗ , where RP∗
the reflexive transitive closure of RP .
denotes

Definition 2.3 A model for PDL is a pair M = (F, V), where F is a PDL frame and V is a valuation function V : Φ '→ 2W .

Definition 2.4 Let  = ( , V) be a model. The semantical notion of satisfaction of a formula ϕ in a model   at a state w, notation  ,w H ϕ, is defined in PDL in the standard way for modal logics [4] for the atomic formulas and the boolean operators. The following rule takes care of the modalities: M,w H ⟨P⟩ϕ iff there is w' ∈ W such that wRP w' and M, w' H ϕ.

The π-Calculus
The π-Calculus is a well known process algebra, proposed by Milner, Parrow and Walker [11], for the specification of communicating concurrent systems. It is an extension of Milner’s CCS [10] that is able to describe not only non-determinism and concurrency, but also mobility of processes. A π-Calculus specification is a description of the behaviour expected from a system, based on the communication events that may occur. For a broad introduction to the π-Calculus, [13] can be consulted.
In the π-Calculus, a pair of processes can communicate through a common chan- nel and each act of communication consists of a message (which, in the π-Calculus, is also a channel name) being sent at one end of the channel and immediately being received at the other.
Let  = a, b, c, . . . be a set of names. Each channel in a π-Calculus specifi- cation is labelled by a name. The labels of the channels are also used to describe the communication actions (sending and receiving messages) performed by the pro- cesses, as is shown below. Besides these communication actions, the π-Calculus has only one other action: the silent action, denoted by τ , used to represent any internal action performed by any of the processes that does not involve an act of communication (e.g.: a memory update).
Definition 2.5 In our presentation of the π-Calculus, process specifications can be built using the following operations:
P ::= 0 | END | α.P | P1; P2 | P1 + P2 | P1|P2 | P∗ | (νa)P,


with

where a, x ∈ N .

	
α ::= a(x) | a⟨x⟩| a⟨νx⟩| τ,

Usually, the π-Calculus is presented with a replication operator (!), that denotes the ability of a process to generate multiple copies of itself, or with constants, that may be used to describe recursion. In [2], in the context of CCS, we present a dynamic logic that uses processes with constants. However, in order to keep the finite model property and a complete axiomatization, we had to restrict the interaction between constants and the operator in order to prevent potentially self-replicating processes. Besides that, with constants, the axiomatization and the theory behind its completeness proof became considerably more complex. On the other hand, the issue of whether it is possible to keep the finite model property and

a complete axiomatization in the presence of replication remains open and we defer it to a future work, as explained in Section 4.
Thus, at the present time, we restrict ourselves to the language without constants and the replication operator. However, as is also shown in [2], it is much simpler to deal with iteration (which is a restricted form of recursion) in the logic than with recursion in its more general form and the resulting axiomatization is more elegant. So, in order to express iterative behaviours, we add to our presentation of the π-Calculus the PDL-inspired operators ∗ and ;.
As it is explained in details in [2], the somewhat loose definition of the null process 0 in the π-Calculus, which fails to differentiate between a deadlock and a successful termination (unlike other process algebras, as ACP [8] for instance, in which the deadlocked process and the terminated process are different), can get in the way of a fully compositional semantics for a dynamic logic based on the π- Calculus. To solve this, we introduce an extra action, with a special meaning: the
ending action, denoted by END . All other actions are called running actions. A
process can only successfully finish after performing the action END and it always successfully finishes after performing such action. If a process cannot perform any running action and cannot successfully finish, it is called a deadlocked process.
0 is the null process. It is a deadlocked process, since it is incapable of performing any running action and of successfully finishing. END is a process that is incapable of performing any running action, but it is capable of successfully finishing. The preﬁx operator (.) denotes that the process will first perform the running action α and then behave as P . The sequential composition operator (;) denotes that the process will first behave as P1 and if and when P1 successfully terminates, it will proceed behaving as P2. The nondeterministic choice operator (+) denotes that the process will make a nondeterministic choice to behave as either P1 or P2. The parallel composition operator ( ) denotes that the processes P1 and P2 may proceed independently or may communicate through a common channel. The iteration operator (*) denotes that the process P is capable of being iterated zero or more times. Finally, the restriction operator (νa) denotes that the channel a is only accessible inside P (the scope of a is P ).
The action a(x), called input action, denotes that the process receives a name through the channel labelled by a and the name x marks, in P , the places where the received name should be put. The actions a x , called free output action, and a νx , called bound output action, both denote that the process sends the name x through the channel labelled by a. The difference between the two is that, in a νx , x is a restricted name, with this action working as an abbreviation for (νx)a x . Finally, τ denotes the silent action. We define the bound output action as a primitive action because, as is shown below, under certain circumstances, the only form of restriction that is needed is the one provided by bounded outputs.
We say that the actions a(x) and a νx and the restriction (νx) bind the name x, calling them binders. We say that a name is bound in P if it occurs inside the scope of an action or a restriction that binds it. Otherwise, we say that a name is free in P. We denote by f (P ) the set of free names in P and by b(P ) the set

of bound names in P . Similarly, we denote by f (α) and b(α) the free and bound names in an action α. In the actions a(x), a x and a νx , a is called the subject, denoted by s(α), where α is the action, and x is called the object, denoted by o(α). The τ action has neither subject nor object.
Definition 2.6 We say that a relation ∼= between processes is a congruence if it is an equivalence relation and it is preserved by all π-Calculus operators, that is, if P ∼= Q, then α.P ∼= α.Q, P + R ∼= Q + R and so on.
Definition 2.7 A syntactic substitution of a bound name by a fresh name (a name that does not occur in the process specification) in its binder and in every occurrence of the name in the scope of this binder is called an alpha-conversion.
Definition 2.8 Structural congruence, denoted by , is a relation between pro- cesses defined by the following set of axioms and rules:


It is a congruence;
It is closed under alpha-conver- sion;
Commutativity of + and |;

	
If a /= x, (νx)a⟨x⟩.P ≡ a⟨νx⟩.P ;
(νx)(νy)P ≡ (νy)(νx)P ;
If x /∈ f (P ), (νx)P ≡ P .

Definition 2.9 We say that a process P is clean if no name appears both free and bound in P and no name is bound by more than one binder. We say that a process is unrestricted if it has no occurrences of the ν operator. We say that a clean process is in ν-preﬁx form if it has the form (νx1) ... (νxn)P , n   0, where P is unrestricted. Finally, we say that a clean process is in ν-standard form if the only occurrences of the ν operator are inside bound output prefixes.
We write P → P' to express that the process P can perform the action α
and after that behave as P'. We write P END √ to express that the process P can perform the action END and successfully finish. In Table 1, we present the semantics
for the operators of the π-Calculus based on this notation. This semantics is called
late semantics. For more details on this and other semantics, [13] can be consulted.

Table 1
Transition Relations of the π-Calculus

From Table 1, we can see that we have a clear distinction between deadlock and termination. A specification of the form α.0 denotes that a process performs the

action α and then deadlocks, while a specification of the form α.END denotes that a process performs the action α and then successfully terminates.
Definition 2.10 Let P be the set of all possible process specifications. A late bisimulation is a symmetric binary relation Z ⊆P × P such that
If (P, Q) ∈ Z and P →α P', where b(α) is fresh in P and Q, then

If α = a(x), then there is Q' ∈ P such that Q →α
(P '{u/x}, Q'{u/x}) ∈ Z;
Q' and for all u ∈ N ,
α

If α is not an input action, then there is Q' ∈ P such that Q → Q' and (P ', Q') ∈ Z;
If (P, Q) ∈ Z and P E→ND √, then Q E→ND √.
The reason why the only running actions that need to be considered are the ones that satisfy the freshness condition above is explained in details in [13].
Definition 2.11 Two process specifications P and Q are late bisimilar (or simply
bisimilar ), denoted by P ∼. Q, if there is a late bisimulation Z such that (P, Q) ∈ Z.
In the π-Calculus, bisimilarity is an equivalence relation but is not a congruence.
Theorem 2.12 If P ≡ Q, then P ∼. Q.
It should be noticed that while 0 is the neutral element for the + operator, that
is, P + 0 ∼. P , END is the neutral element for the | operator, as P|END ∼. P 5 .
We now present a few particular bisimilarities that are going to be useful in the axiomatization of our logic. We start with the Expansion Law.
Theorem 2.13 (Expansion Law [13]) Let P = P1 | P2, where P is clean and unrestricted and | does not occur in P1 and P2. Then
P ∼.	Σ α.(P' | P2)+ Σ β.(P1 | P')+ Σ τ.R + EP ,
1	2

P1→α P'
P β P'
R∈Aτ



where A
1


= {(P'{u/x} | P') : P
2→ 2

a(x)

P' and P


a⟨u⟩

P', for some a ∈ N} ∪

a⟨u⟩
{(P' | P'{u/x}) : P	P' and P
a(x) P', for some a ∈ N} and E
= END, if

√	1 →√ 1
2 →	2	P

P1 E→ND
and P2 E→ND
or EP = 0, otherwise. We denote the right side of this

bisimilarity by Exp(P ).
Definition 2.14 ν-bisimilarity, denoted by P ∼ν Q, is a relation between processes
defined by the following set of axioms and rules, where x	α denotes that x is neither the subject nor the object of the action α:


If P ≡ Q, then P ∼ν Q;
(iv) If x /∈ α, (νx)α.P ∼ν
α.(νx)P ;

(νx)0 ∼ν 0;	(v) If x = s(α), (νx)α.P ∼ν 0;

(νx)END ∼ν
END ;
(νx)(P ; Q) ∼ν
(νx)P ; (νx)Q;



5 Notice that, according to table 1, P|0 can never successfully finish, so P|0 ∼/ . P in general.

(νx)(P + Q) ∼ν (νx)P + (νx)Q;
(P|Q);

If x / ∈ f (P ), P|(νx)Q ∼
(νx)
(νx)P∗ ∼ν
((νx)P )∗.

It follows from Table 1 and Definition 2.11 that items (ii)-(ix) are indeed bisimi- larities. Hence, the relation of ν-bisimilarity is a subset of the relation of bisimilarity. ν-bisimilarity is a convenient relation because it has a simple axiomatization and it is sufficient for all our needs in this work.
Theorem 2.15 Every process is structurally congruent to a clean process. Every clean process is ν-bisimilar to a process in ν-preﬁx form. Finally, every clean process with no occurrences of the | operator is ν-bisimilar to a process in ν-standard form.
πDL
In this section, we define a Propositional Dynamic Logic (πDL) in which the pro- grams are built in a language based on the π-Calculus without replication (Defini- tion 2.5). First, we introduce the key concept of ﬁnite possible runs of a process. We then proceed to describe, using this concept, the syntax and semantics of πDL and provide a couple of simple examples of its application. Finally, we present an axiomatization for πDL and prove its soundness and completeness.

Action Sequences and Possible Runs
Here, we introduce the concept of ﬁnite possible runs of a process.
Definition 3.1 We use the notation −→α to denote a potentially infinite sequence of actions α1.α2. .  .αn(. ) (the empty sequence is denoted by −→ε ). The empty sequence follows the rule −→α .−→ε = −→ε .−→α = −→α , for all −→α . We denote the i-th term of the sequence −→α by (−→α )i.
Definition 3.2 For a finite sequence of actions −→α , we write P −→α P' to express that
the process P may perform the sequence −→α and after that be⇒have as P'. Besides
that, we write P −→α √ to express that the process P may successfully finish after
performing the seq⇒uence −→α .
We can define notions of alpha-conversion of bound names in a sequence of actions and of a clean sequence of actions, in analogy with Definitions 2.7 and 2.9. We can also extend our notation and write b(−→γ ) and f (−→γ ) for the sets of bound and
free names in the sequence −→γ . If a sequence of actions −→γ can be alpha-converted
to a sequence −→σ , we write −→γ ≡  −→σ . It is not difficult to see that, if P −→γ √, then
α	⇒
−→ √
P ⇒σ	, where −→γ ≡α −→σ and −→σ is clean. Let S(P ) be the set of all such −→σ . Then,
it is also not difficult to see that, if we establish the convention that −→σ	α −→σ ,	α
is an equivalence relation for the elements of the set S(P ).
Definition 3.3 We define the set of finite possible runs of a process P , denoted by
−→f (P ), as the quotient set −→f (P ) = S(P )/	α. If −→γ	S(P ), then [−→γ ]	−→f (P )
denotes its equivalence class.

We want to define a semantics for our logic that only takes into account the ﬁnite possible runs of the processes, i.e., situations in which the processes successfully finish. So, we present some useful results about finite possible runs.
Definition 3.4 Let −→α and −→σ be two sequences of actions and let P and Q be two process specifications. If b(−→α ) is fresh in Q and b(−→σ ) is fresh in P , we write (−→α, −→σ ) da (P, Q).
Definition 3.5 Let T = −→f (P ) and U = −→f (Q) and let q(−→α ) = −→λ , where −→α =
−→λ .END . We can define the following operations on the sets T and U :
T ◦ U = {[q(−→α ).−→β ] : [−→α ] ∈ T, [−→β ] ∈ U and (−→α, −→β ) da (P, Q)};

T ∪ U = {[−→α ] : [−→α ] ∈ T or [−→α ] ∈ U};
R0 = {[−→ε ]}, Rn = R ◦ Rn−1(n ≥ 1) and R∗ =


  n∈N Rn.

Lemma 3.6 If P ∼. Q and b(−→α ) is fresh in P and Q, then P −→α √ iff Q −→α √.
Proof. We prove this by induction on the length n of −→α . If n = 0, then −→α = −→ε
and neither P nor Q may successfully finish without executing any action. If n = 1,

then −→α = END . Then, P −→α √
P E→ND
√.  By the hypothesis that P ∼ Q,

P E→ND √ ⇔ Q E→ND √
⇒ Q E⇔ND √ ⇔ Q −→α √.

. Finally,	→
⇒	−→

k. Let α be the first action of the sequence and let −→β be a sequence of length k − 1
such that −→α = α.−→β . Then, P −→α √ if and only if there is a process P' such that
α	'	' −→β √	⇒	'	.	'

α
P → P  and P  ⇒	. But if P → P and P ∼ Q, then there is a process Q
such

that Q →α Q' and P' ∼. Q'. Now, −→β is a sequence of length shorter than k, so by

−→β	−→β
the induction hypothesis, as P' ∼. Q' and P'	√, then Q'
√. This means that

Q −→α √	⇒	⇒
⇒	, proving the theorem.	 
Theorem 3.7 If P ∼. Q, then −R→f (P ) = R−→f (Q).
Proof. Suppose that [−→α ] ∈ −R→f (P ). Then, there is a clean sequence −→σ such that
[−→σ ] = [−→α ] (*) and b(−→σ ) is fresh in P and Q (**). By (*), P −→σ  √. As P ∼ Q,
this, together with (**) and Lemma 3.6, implies that Q −→σ √ ⇒

−→	−→	−→
−→	−→
⇒	, which means that

[ α ] = [ σ ]	f (Q). Thus,	f (P )	f (Q). The proof that −→f (Q)	−→f (P ) is
entirely analogous.	 
We present some equalities between sets of finite possible runs that are useful to the development of our axiomatization.
Theorem 3.8 The following set equalities are true:

−R→f (0) = ∅;
−R→f (END ) = {[END ]};
−R→f (α.P ) = {[α.END ]}◦ −R→f (P );
−R→f (P1; P2) = −R→f (P1) ◦ −R→f (P2);

−R→f (P1 + P2) = −R→f (P1) ∪ −R→f (P2);	(vi) −R→f (P∗) = (−R→f (P ))∗;
−R→f (P1|P2) =  {−R→f (−→α | −→β ) : [−→α ] ∈ −R→f (P1) and [−→β ] ∈ −R→f (P2)};
If −R→f (P ) = −R→f (Q), then −R→f ((νx)P ) = −R→f ((νx)Q);
If −R→f (P ) = −R→f (A) ◦ −R→f (P ) ∪ −R→f (B) and [END ] /∈ −R→f (A), then −R→f (P ) = (−R→f (A))∗ ◦ −R→f (B).
Proof. The proof of the first eight items is straightforward from Table 1 and The- orem 3.7. The ninth item is simply Arden’s Rule [1] applied in our context. This
application is sound, since the elements of −→f (P ), for any P , are classes of finite
strings.	 
Language and Semantics
In this section, we present the syntax and semantics of πDL.
Definition 3.9 The πDL language consists of a set Φ of countably many propo- sition symbols, a set  of countably many names, the silent action τ , the ending action END , the boolean connectives   and  , the π-Calculus operators ., ;, +,
, ∗ and ν, a pair of modalities a and a , for each a	, and a modality P for every process P , including the atomic processes 0 and END . The formulas are defined as follows:
ϕ ::= p |Т| ¬ϕ | ϕ1 ∧ ϕ2 | ⟨a⟩ϕ | ⟨a⟩ϕ | ⟨P ⟩ϕ,

where p ∈ Φ and P is built as in Definition 2.5.
Definition 3.10 A frame for πDL is a tuple  = (W, Ra, Ra a∈N , REND , Rτ ) where
W is a non-empty set of states;
Ra, Ra, for each a ∈ N , REND and Rτ are the basic binary relations, where
REND = {(w, w) : w ∈ W}.
Definition 3.11 A model for πDL is a pair M = (F, V), where F is a πDL frame and V is a valuation function V : Φ '→ 2W .
Definition 3.12 We define the core of an action α, denoted by c(α), in the follow- ing way: c(a(x)) = a, c(a⟨x⟩) = c(a⟨νx⟩) = a and c(α) = α, if α = τ or α = END .
We now define the semantical notion of satisfaction for πDL as follows:
Definition 3.13 Let  = ( , V) be a model. The notion of satisfaction of a formula ϕ in a model  at a state w, notation  ,w H ϕ, can be inductively defined as follows:
M,w H p iff w ∈ V(p);
M,w H Т always;

M,w H ¬ϕ iff M,w /H ϕ;
M,w H ϕ1 ∧ ϕ2 iff M,w H ϕ1 and M,w H ϕ2;
M,w H ⟨κ⟩ϕ iff there is w' ∈ W such that wRκw' and M, w' H ϕ, where κ = a

or κ = a, for some a ∈ N , or κ = τ ;
M,w H ⟨P⟩ϕ iff there is a finite path (v0, v1,..., vn), n ≥ 1, such that v0 = w, M, vn H ϕ and there is −→α such that [−→α ] ∈ Rf (P ), the length of −→α is n and (vi−1, vi)  Rκ if and only if c((−→α )i) = κ, for 1   i   n. We say that such −→α matches the path (v0,..., vn).
If  ,w H ϕ for every state w, we say that ϕ is globally satisﬁed in the model
, notation  H ϕ. If ϕ is globally satisfied in all models  of a frame  , we say that ϕ is valid in , notation  H ϕ. Finally, if ϕ is valid in all frames, we say that ϕ is valid, notation H ϕ. Two formulas ϕ and ψ are semantically equivalent if H ϕ ↔ ψ.
Theorem 3.14 −R→f (P ) = −R→f (Q) if and only if H ⟨P⟩p ↔ ⟨Q⟩p.
Proof. (⇒) Suppose that −R→f (P ) = −R→f (Q), but /H ⟨P⟩p ↔ ⟨Q⟩p. Then, we may assume, without loss of generality, that there is a model M and a state v0 in this model such that M, v0 H ⟨P⟩p (*), but M, v0 /H ⟨Q⟩p (**). By Definition 3.13, (*) implies that there is a path (v0, v1,..., vn), n ≥ 1, in M such that M, vn H p (***) and there is a sequence −→α , such that [−→α ] ∈ Rf (P ), that matches this path. But as −R→f (P ) = −R→f (Q), then [−→α ] ∈ −R→f (Q). This and (***) imply, by Definition 3.13,

that M, v0 H ⟨Q⟩p, contradicting (**).
−→	−→

( ) Suppose that H P p  Q p (*), but  f (P ) =  f (Q). Then, we may assume, without loss of generality, that there is a clean sequence −→α such that [−→α ] ∈ −R→f (P ), but [−→α ] /∈ −R→f (Q). Let us build a frame F that consists solely of a
path (v0,..., vn), n ≥ 1, such that Ra = {(vi−1, vi) : 1 ≤ i ≤ n and c(( α )i) = a}.
Let M = (F, V), such that vn ∈ V(p) and vi /∈ V(p), 0 ≤ i < n. Then, we have a path (v0,..., vn) such that M, vn H p and −→α matches this path. By Definition 3.13, M, v0 H ⟨P⟩p. However, [−→α ] /∈ −R→f (Q), so (v0,..., vn) is not matched by any sequence in −R→f (Q). Besides that, there is no other path (v0,..., vm), m ≥ 1, in M such that M, vm H p. Thus, by Definition 3.13, M, v0 /H ⟨Q⟩p, which contradicts
 

Corollary 3.15 If P ∼.

Examples
Q, then H ⟨P⟩p ↔ ⟨Q⟩p.

In this section, we present two simple examples of applications of πDL.
Example 3.16 Let  be a Kripke model representing the behaviour of a local network in a business office. Suppose that, in this network, there are three com- puters and two printers, managed by a common server. For a restricted analysis of  with respect only to the printing protocols, we may assume that all that the employees of the office do at the computers is to print documents.

Let s1 be the communication channel between the computers and the server and s2 be the communication channel between the server and the printers. Then, Ci = (νci)s1 ci .ci(p).p d .END describes a program that sends a document that can be retrieved through channel d to be printed, S = (s1(n).s2(p).n p .END )∗ describes a program that controls the server and distributes the printers following requests from the computers and Pj = (νpj)s2 pj .pj(d).τ.END describes a program that controls the printer and prints the document (the act of printing is represented by τ ) that can be retrieved through channel d.
We may want to verify if  allows for any computer to print a sequence of any number of documents at any time, no matter what state  is presently in. If we assume that each computer cannot simultaneously request the printing of more than one document, this is equivalent to checking whether the formula ⟨C1∗ | C2∗ | C3∗ S P1∗ P2∗ is globally satisfied in . We may also want to verify that the actions of one computer do not affect the actions of the others. For this, we could check, for instance, if ⟨Ci⟩Т — [(Cj | Ck)∗]⟨Ci⟩Т, i /= j /= k, is globally satisfied in ł.
Example 3.17 The parallel composition operator ( ) has a dual role in the π- Calculus. It represents both interleaving and synchronization of processes. In van Benthem’s paradigm of games-as-processes [16], this could be used to represent simultaneous games, where each player chooses his actions unaware of what are the actions taken by the other player. We consider a concrete example. Let  be a game board and the proposition symbols wi, i = 1, 2, denote that player i wins if the game reaches a state where wi is satisfied. Let a, b, c be the possible actions for player 1 and d, e, f the possible actions for player 2. Each player has to perform a sequence of three actions, completely unaware of which actions the other player performed or even how many of the three actions the other player performed so far. This means that the two sequences are interleaved in an arbitrary order. Then,
,w H a.b.b.END + a.b.c.END d.d.d.END w1 means that if the game starts in w, there is an interleaved sequence of a, b, b and d, d, d or a, b, c and d, d, d that leads to a victory of player 1. On the other hand,  ,w H [a.b.b.END d.d.d.END ]w1 means that, if the game starts in w, no matter in what order the six actions take place, if player 1 plays a, b, b and player 2 plays d, d, d, player 1 is guaranteed to win. This can also be generalized to games with more than two players.
The operator can also represent synchronization of processes. This allows us to model richer games, where we can get “rounds” of blind, simultaneous games separated by some exchange of information between the players. For instance, in the game described above, suppose now that the two players may select their actions from the same set a, b, c . To differentiate between the sequences of actions of each player, each sequence starts with pi, i = 1, 2. Besides that, each player will now perform the three actions in the following way: a player performs two actions, then informs the other player of one of them and performs the final action. Then we can express properties of this game using formulas of our logic, in an analogous way to the paragraph above. For instance, ł,w H [(νx)(νy)(p1.b.b.x⟨b⟩.y(w).w.END | p2.a.b.x(z).y⟨a⟩.b.END + p2.a.b.x(z).y⟨b⟩.b.END )]w1 means that if the game starts

in w, no matter in what order the four initial and the two final actions take place, if player 2 starts with a, b and finishes with b, then player 1 can always win by playing b, b and then finishing with the action informed by player 2.
This interplay between interleaving and synchronization can then be used to describe a fairly large group of games. A recent paper [17] also works with this idea that concurrency operators can be used to model simultaneous games. The authors use CPDL [15] as a stepping stone to build a concurrent dynamic game logic. However, since CPDL does not admit communication, their logic also has that limitation. As the generalization from CPDL to channel-CPDL has as drawbacks the loss of decidability and the loss of a complete axiomatization, our logic may be better suited for the generalization of the logic presented in [17] to deal with simultaneous games with communication, as we briefly illustrated.
Axiomatic System
We consider the following set of axioms and rules, where p and q are proposition symbols and ϕ and ψ are formulas.

(PL) Enough propositional logic tau- tologies
(K) ▶ [P ](p → q) → ([P ]p → [P ]q)
(Du) ▶ [P ]p — ¬⟨P⟩¬p
(0) ▶ ¬⟨0⟩p
(END) ▶ ⟨END⟩p — p
(SC) ▶ ⟨P1; P2⟩p — ⟨P1⟩⟨P2⟩p (NC) ▶ ⟨P1 + P2⟩p — ⟨P1⟩p ∨ ⟨P2⟩p (Rec) ▶ ⟨P∗⟩p — p ∨ ⟨P ⟩⟨P∗⟩p (FP) ▶ p ∧ [P∗](p → [P ]p) → [P∗]p
(MP) If ▶ ϕ and ▶ ϕ → ψ, then ▶ ψ
(Gen) If ▶ ϕ, then ▶ [P ]ϕ

(Pr) ▶ ⟨α.P⟩p — ⟨c(α)⟩⟨P ⟩p
(νBi) If P ∼ν Q, then ▶ ⟨P⟩p — ⟨Q⟩p

(Sub) If	ϕ, then	ϕσ, where σ uniformly substitutes proposition symbols by arbitrary formulas
(PCSub) If ▶ ⟨P⟩p — ⟨Q⟩p, then ▶ ⟨P|R⟩p — ⟨Q|R⟩p
(RSub) If ▶ ⟨P⟩p — ⟨Q⟩p, then ▶ ⟨(νx)P⟩p — ⟨(νx)Q⟩p
(Exp) If the Expansion Law can be applied to P , then ▶ ⟨P⟩p — ⟨Exp(P )⟩p
END √	∗
(Ard) If ▶ ⟨P⟩p — ⟨A; P + B⟩p and A /→	, then ▶ ⟨P⟩p — ⟨A ; B⟩p
The axioms (PL), (K) and (Du) and the rules (MP), (Gen) and (Sub) are standard in the modal logic literature. The soundness of the other axioms and rules follows directly from the set equalities in Theorem 3.8 (with the help of Theorem 3.14), Theorem 2.13, Corollary 3.15 and Definition 3.10.
Definition 3.18 We define the following relation between processes: P — Q iff
▶ ⟨P⟩p — ⟨Q⟩p.
Theorem 3.19 — is a congruence.
Definition 3.20 Let Ωk = {P1,..., Pk} be a set of processes such that Pi /≡ Pj, if
i /= j. Let E(Ωk) = {E1,..., Ek} such that Ei = (Pi, Ti), Pi — Ti, Ti = Σ Ai ; Qi

and, for all (i, j), Ai has no occurrence of |. We say that E(Ωk) is closed if, for all
(i, j), Qi ∈ Ωk.
Theorem 3.21 Let P = P1 | P2, where P is clean and unrestricted. Then there is
P such that P — P and P has no occurrence of the | operator.
Proof. The proof is by induction on the number n of occurrences of the  operator in P . If n = 0, then P = P and there is nothing to be done.
If n = 1 then the Expansion Law can be applied to P , so we can use (Exp) to build pairs (Pi, Ti) that satisfy Definition 3.20. Let P1 = P and Ωk be the smallest set such that P1 ∈ Ωk and E(Ωk) is closed. Such a set always exists, as otherwise there would be an infinite set of processes {Ai : i ∈ N} such that Ai /≡ Aj, if i /= j, and P →α0 A0 →α1 A1 .. ., which, by a careful inspection of Table 1, cannot happen.
Take the pair Ek. If there is no Qk = Pk (*), then we can substitute in the
processes Ti, 1 ≤ i < k, all the occurrences of Pk by Tk. Otherwise, we can use (Ard) to substitute the pair (Pk, Tk) by a pair (Pk, Tk' ) where (*) holds and then proceed as in the previous case. We then continue this process with the pair Ek−1 and so on, until we finally get a pair (P1, T1' ) such that no process in Ωk occurs in T1'. By the use of (Exp) to build the initial pairs and the fact that neither (Ard) nor the substitution process introduce new  operators, we have P = T1'.
This method, based on the solution of a “system of equations”, was inspired by Brzozowski’s algebraic method to obtain the regular expression that describes the language accepted by a finite automaton [5].
Suppose that the theorem is true for all n < k. Let P have k occurrences of |. As P = P1|P2, we can obtain P as P1|P2.	 

Two formulas φ and ψ are equi-consistent if	φ	ψ. By soundness, if φ and
ψ are equi-consistent, then they are also semantically equivalent.
Theorem 3.22 (Completeness) Every consistent formula is satisﬁable in a ﬁnite
πDL model.
Proof. Let ϕ be a consistent formula and let P(ϕ) be the set of processes that appear in ϕ. For all P P(ϕ), we can use (νBi), (RSub), (MP) and Theorems 2.15, 3.19 and 3.21 to get a sequence P  P'  P ''  P ''', where P' is clean and in ν-prefix form, P '' is also without any occurrence of the operator and P ''' is like P '' but is instead in ν-standard form. We can then obtain an equi-consistent formula ϕ' = ϕ[P '''/P, P  P(ϕ)] in which the only π-Calculus operators that appear are ., ;, + and ∗. All of these operators and its correspondent axioms are analogous to the operators and axioms in standard PDL. Thus, we can follow the completeness proof of standard PDL (the PDL axioms and its completeness proof are presented in details in [4]), treating the actions as basic PDL programs, to show that ϕ' is satisfiable in a finite model. As ϕ and ϕ' are equi-consistent, they are also semantically equivalent, which means that ϕ is also satisfied in that same finite model.	 

Final Remarks and Future Work
In this work, we present a Propositional Dynamic Logic for communicating con- current systems (πDL) in which the programs are described in a language based on the π-Calculus without replication. From the point of view of dynamic logics, this logic represents an improvement on the current scenario, as previous dynamic logics could not effectively deal with both concurrency and communication. CPDL
[15] dealt with concurrency, but there was no possibility of communication between the components of a concurrent system. Channel-CPDL [14] models concurrency and communication but it has a “rather complicated” [14] semantics, is undecidable and lacks a complete axiomatization. On the other hand, we are able to provide a simple Kripke semantics for our logic, based on the idea of finite possible runs of processes, build a complete axiomatization for it and show that it has the finite model property.
We also provide a method, in a language with iteration (∗) and sequential com- position (;) operators, to rewrite any process specification to a form without the parallel composition operator ( ) while preserving the set of finite possible runs of the process. This method is based on Brzozowski’s algorithm to find the regular expression that corresponds to a finite automaton [5]. We feel that this is an inter- esting and original application of Brzozowski’s idea and that it provides an elegant proof to a key result to the completeness of our axiomatization.
It should also be noticed that, while the operator can be written out of the specifications, in practice it can be very hard to describe a complex concurrent behaviour without it from the start. Besides that, even though both specifications, with and without |, may be equivalent, the one with | will be more succinct.
It would be interesting to study the complexities of the satisfiability and model- checking problems for this logic and the ones in [3] and [2]. It would also be inter- esting to develop an automatic model-checker for these logics, which would involve an efficient algorithmic method to deal with the expansion of parallel processes. We would also like to analyze the issue of self-replicating processes, which was left out of the present work. We would like to study what would change in the logic with the addition of the π-Calculus replication operator (!).
Finally, we would also like to study in more detail the possible connections between our logic and the ideas presented in [17] and analyze how to use our logic as a tool for the description of simultaneous games with communication.

References
Arden, D. N., Delayed logic and finite state machines, in: Theory of Computing Machine Design, University of Michigan Press, 1960 pp. 1–35.
Benevides, M. R. F. and L. M. Schechter, CCS-based dynamic logics for communicating concurrent programs, URL: http://arxiv.org/abs/0904.0034v1.
Benevides, M. R. F. and L. M. Schechter, A propositional dynamic logic for CCS programs, in: Proceedings of the XV Workshop on Logic, Language, Information and Computation (Wollic 2008), LNAI 5110 (2008), pp. 83–97.


Blackburn, P., M. de Rijke and Y. Venema, “Modal Logic,” Theoretical Tracts in Computer Science, Cambridge University Press, 2001.
Brzozowski, J. A., Derivatives of regular expressions, Journal of the ACM 11 (1964), pp. 481–494.
Dam, M., Model checking mobile processes, Information and Computation 129 (1996), pp. 35–51.
Fischer, M. J. and R. E. Ladner, Propositional dynamic logic of regular programs, Journal of Computer and System Sciences 18 (1979), pp. 194–211.
Fokkink, W. J., “Introduction to Process Algebra,” Texts in Theoretical Computer Science, Springer, 2000.
Mayer, A. J. and L. J. Stockmeyer, The complexity of PDL with interleaving, Theoretical Computer Science 161 (1996), pp. 109–122.
Milner, R., “Communication and Concurrency,” Prentice Hall, 1989.
Milner, R., J. Parrow and D. Walker, A calculus of mobile processes - part I and part II, Information and Computation 100 (1992), pp. 1–77.
Milner, R., J. Parrow and D. Walker, Modal logics for mobile processes, Theoretical Computer Science
114 (1993), pp. 149–171.
Parrow, J., An introduction to the π-calculus, in: J. A. Bergstra, A. Ponse and S. A. Smolka, editors,
Handbook of Process Algebra, Elsevier, 2001 pp. 479–543.
Peleg, D., Communication in concurrent dynamic logic, Journal of Computer and System Sciences 35
(1987), pp. 23–58.
Peleg, D., Concurrent dynamic logic, Journal of the Association for Computing Machinery 34 (1987),
pp. 450–479.
van Benthem, J., Extensive games as process models, Journal of Logic, Language and Information 11
(2002), pp. 289–313.
van Benthem, J., S. Ghosh and F. Liu, Modelling simultaneous games in dynamic logic, Synthese 165
(2008), pp. 247–268.
