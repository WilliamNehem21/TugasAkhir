Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 191–211
www.elsevier.com/locate/entcs
A System-Level Game Semantics
Dan R. Ghica
University of Birmingham
Nikos Tzevelekos
Queen Mary, University of London

Abstract
Game semantics is a trace-like denotational semantics for programming languages where the notion of legal observable behaviour of a term is defined combinatorially, by means of rules of a game between the term (the Proponent ) and its context (the Opponent ). In general, the richer the computational features a language has the less constrained the rules of the semantic game. In this paper we consider the consequences of taking this relaxation of rules to the limit, by granting the Opponent omnipotence, that is, permission to play
any move without combinatorial restrictions. However, we impose an epistemic restriction by not granting Opponent omniscience, so that Proponent can have undisclosed secret moves. We introduce a basic C-like programming language and we define such a semantic model for it. We argue that the resulting semantics is an appealingly simple combination of operational and game semantics and we show how certain traces explain system-level attacks, i.e. plausible attacks that are realisable outside of the programming language itself. We also show how allowing Proponent to have secrets ensures that some desirable equivalences in the programming language are preserved.
Keywords: Game semantics, omnipotent opponent, omniscient opponent

Introduction
Game semantics came to prominence by solving the long-standing open problem of full abstraction for PCF [2,7] and it consolidated its status as a successful approach to modelling programming languages by being used in the definition of numerous other fully abstract programming language models. The approach of game seman- tics is to model computation as a formal interaction, called a game, between a term and its context. Thus, a semantic game features two players: a Proponent (P), representing the term, and an Opponent (O), representing the context. The inter- action is formally described by sequences of game moves, called plays, and a term is modeled by a corresponding strategy, that is, the set of all its possible plays. To define a game semantics one needs to define what are the rules of the game and what are the abilities of the players.

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.013

For PCF games, the rules are particularly neat, corresponding to the so-called “principles of polite conversation”: moves are divided into questions and answers; players must take turns; no question can be asked unless it is made possible (enabled ) by an earlier relevant question; no answer can be given unless it is to the most recent unanswered question. The legality constraints for plays can be imposed as combinatorial conditions on sequences of moves.
Strategies also have combinatorial conditions which characterise the players rather than the game. They are uniformity conditions which stipulate that if in certain plays P makes a certain move, in other plays it will make an analogous move. The simplest condition is determinism, which stipulates that in any strategy if two plays are equal up to a certain P move, their subsequent P moves must also be the same. Relaxing some of the combinatorial constraints on plays and strate- gies elegantly leads from models of PCF to models of more expressive programming languages. For example, relaxing a condition called innocence leads to models of programming language with state [3], relaxing bracketing leads to models of pro- gramming languages with control [10], and in the absence of alternation we obtain languages for concurrency [6].




Contribution.
In this paper we consider the natural question of what happens if in a game semantics we remove combinatorial constraints from O’s behaviour. Unlike conven- tional game models, our construction is asymmetric: P behaves in a way determined by the programming language and its inherent limitations, whereas O can represent plausible behaviour which may not be, however, syntactically realizable neither in the language nor in some obvious extensions. We will see that such a model is, in a technical sense, well formed and that the notion of equivalence it induces is interesting and useful.
We study such a relaxed game model using an idealized type-free C-like language. The notion of available move is modeled using a notion of secret similar to that used in models of security protocols, formally represented using names. This leads to a notion of Opponent which is omnipotent but not omniscient: it can make any available move in any order, but some moves can be hidden from it. This is akin to the Dolev-Yao attacker model of security.
We show how inequivalences in this semantic model capture system-level attacks,
i.e. behaviours of the ambient system which, although not realizable in the language itself, can be nevertheless plausibly enacted within the system. Despite the ambi- ent system allowing suprising attacks, we note that many interesting equivalences still hold. This provides evidence that questions of semantic equivalence can be formulated outside the conventional framework of a syntactic context.
Technically, the model is expressed in an operationalised version of game seman- tics like Laird’s [12] and names are handled using nominal sets [5].

A system-level semantics
Syntax and operational semantics
We introduce a simple type-free C-like language which is just expressive enough to illustrate the basic concepts. A program is a list of modules, corresponding roughly to files in C. A module is a list of function or variable declarations. An exported variable or function name is globally visible, otherwise its scope is the module. In extended BNF-like notation we write:
Prog ::= Mod∗	Hdr ::= export x; import x;
Mod ::= Hdr Dcl	Dcl ::= decl x = n; Dcl | decl Func; Dcl | ϵ
The header Hdr is a list of names exported and imported by the program, with x an identifier (or list of identifiers x) taken from an infinite set N of names, and n ∈ Z.
As in C, functions are available only in global scope and in uncurried form:
Func ::= x(x){local x; Stm return Exp; }
A function has a name and a list of arguments. In the body of the function we have a list of local variable declarations followed by a list of statements terminated by a return statement. We define statements and expressions as follows (with n ∈ Z).
Stm ::= ϵ | if (Exp) then {Stm} else {Stm}; Stm | Exp=Exp; Stm
| Exp(Exp∗); Stm
Exp ::= Exp  Exp | ∗Exp | Exp(Exp∗) | (Exp, Exp) | new() | n | x
Statements are branching, assignment and function call. For simplicity, iteration is not included as we allow recursive calls. Expressions are arithmetic and logical operators, variable dereferencing (∗), pairing, variable allocation and integer and variable constants. A function call can be either an expression or a statement. Because the language is type-free the distinction between statement and expression is arbitrary and only used for convenience.
If decl f (x){e} is a declaration in module M we define f @ M = e[x], interpreted as “the definition of f in M is e, with arguments x.”
A frame is given by the grammar below, with op ∈ {=, , ;}, op∗ ∈ {∗, −}.
t ::= if (  ) then {e} else {e} |  op e | v op  | op∗   |  e | v 
| (  , e) | (v,  )
We denote the “hole” of the frame by  . We denote by Fs the set of lists of frames, the frame stacks. By v we denote values, defined below.
Our semantic setting is that of nominal sets [5] (see Appendix A), constructed over the multi-sorted set of names
N = Nλ  Nφ  Nκ

where each of the three components is a countably infinite set of location names, function names and function continuation names respectively. That is, our objects can involve finitely many elements of N , and they come with a canonical notion of applying name permutations to them. For an object x and a permutation π, the result of applying π to x is denoted by π · x. We range over names by a, b, etc. Specifically for function names we may use f , etc.; and for continuation names k, etc. For each set of names X we write λ(X ), φ(X ) and κ(X ) for its restriction to location, function and continuation names respectively. For any object x involving names, we write ν(x) for its support, i.e. the set of all the names occurring in it.
A store is defined as a pair of partial functions with finite domain:
s ∈ Sto = (Nλ ~fn (Z  Nλ  Nφ)) × (Nκ ~fn Fs × Nκ)
The first component of the store assigns integer values (data), other locations (point- ers) or function names (pointers to functions) to locations. The second stores con- tinuations, used by the system to resume a suspended function call.
We write λ(s), κ(s) for the two projections of a store s. By abuse of notation, we may write s(a) instead of λ(s)(a) or κ(s)(a). Since names are sorted, this is unambiguous. The support ν(s) of s is the set of names appearing in its domain or value set. For all stores s, s∗ and set of names X , we use the notations:
(restrict-to) the sub-store of s defined on X : s T X = {(a, y) ∈ s | a ∈ X};
(restrict-from) the sub-store of s not defined on X : s \X = s T (dom(s)\X );
(update) change the values in s: s[a '→ x]= {(a, x)}∪ (s \ {a}); and, more generally: s[s∗]= s∗ ∪ (s \ dom(s∗));

(extension)
s ± s∗ if dom(s) ⊆ dom(s∗);

(closure) Cl(s, X ) is the least set of names containing X and all names reachable
from X through s in a transitively closed manner, i.e. X ⊆ Cl(s, X ) and if (a, y) ∈ s with a ∈ Cl(s, X ) then ν(y) ∈ Cl(s, X ).
We define a value to be a name, an integer, or a tuple of values: v ::= () | a | n |
(v, v). The value () is the unit for the tuple operation. 1
We give a semantics for the language using a frame-stack abstract machine. It is convenient to take identiﬁers to be names, as it gives a simple way to handle pointers to functions in a way much like that of the C language. The Program conﬁgurations of the abstract machine are of the form:
⟨N | P ▶ s, t, e, k⟩ ∈ N × N × Sto × Fs × Exp × Nκ

N is a set of used names; P ⊆ N is the set of public names; s is the program state; t is a list of frames called the frame stack ; e is the expression being evaluated; and k is a continuation name, which for now will stay unchanged.

1 Tupling is associative and for simplicity we identify tuples up to associativity and unit isomorphisms, so (v, (v, v)) = ((v, v), v)= (v, v, v) and (v, ()) = v, etc.

Case e = v is a value.
⟨N | P ▶ s, t ◦ (if ( ) then {e1} else {e2}), v, k⟩ −→ ⟨N | P ▶ s, t, e1, k⟩, if v ∈ Z \ {0}
⟨N | P ▶ s, t ◦ (if ( ) then {e1} else {e2}), v, k⟩ −→ ⟨N | P ▶ s, t, e2, k⟩, if v =0 
⟨N | P ▶ s, t ◦ (  op e), v, k⟩ −→ ⟨N | P ▶ s, t ◦ (v op  ), e, k⟩ for op ∈ {=, ٨, ; }
⟨N | P ▶ s, t ◦ (v ٨  ), v′, k⟩ −→ ⟨N | P ▶ s, t, v′′, k⟩, and v′′ = v ٨ v′
⟨N | P ▶ s, t ◦ (v;  ), v′, k⟩ −→ ⟨N | P ▶ s, t, v′, k⟩
⟨N | P ▶ s, t ◦ (a =  ), v, k⟩ −→ ⟨N | P ▶ s[a '→ v], t, (), k⟩
⟨N | P ▶ s, t ◦ (∗ ), v, k⟩ −→ ⟨N | P ▶ s, t, s(v), k⟩
⟨N | P ▶ s, t ◦ ( ; e), local x, k⟩ −→ ⟨N ∪ {a}| P ▶ s[a '→ 0], t, e[a/x], k⟩, if a /∈ N
⟨N | P ▶ s, t ◦ ( (e)), v, k⟩ −→ ⟨N | P ▶ s, t ◦ (v( )), e, k⟩
⟨N | P ▶ s, t ◦ (( , e)), v, k⟩ −→ ⟨N | P ▶ s, t ◦ ((v,  )), e, k⟩
⟨N | P ▶ s, t ◦ ((v,  )),v′, k⟩ −→ ⟨N | P ▶ s, t, (v, v′), k⟩
⟨N | P ▶ s, t ◦ (f( )), v′, k⟩ −→ ⟨N | P ▶ s, t, e[v′/x], k⟩, if f @ M = e[x]	(F)
Case e is not a canonical form.
⟨N | P ▶ s, t, if (e) then {e1} else {e2}, k⟩ −→ ⟨N | P ▶ s, t ◦ (if ( ) then {e1} else {e2}), e, k⟩
⟨N | P ▶ s, t, e op e′, k⟩ −→ ⟨N | P ▶ s, t ◦ (  op e′), e, k⟩, if op ∈ {=, ٨, ; }
⟨N | P ▶ s, t, ∗e, k⟩ −→ ⟨N | P ▶ s, t ◦ (∗ ), e, k⟩
⟨N | P ▶ s, t, return(e), k⟩ −→ ⟨N | P ▶ s, t, e, k⟩
⟨N | P ▶ s, t, new(), k⟩ −→ ⟨N ∪ {a}| P ▶ s[a '→ 0], t, a, k⟩, if a ∈ Nλ \ N
⟨N | P ▶ s, t, e(e′), k⟩ −→ ⟨N | P ▶ s, t ◦ ( (e′)), e, k⟩
⟨N | P ▶ s, t, (e, e′), k⟩ −→ ⟨N | P ▶ s, t ◦ (( , e′)), e, k⟩

Fig. 1. Operational semantics
The transitions of the abstract machine are a relation on the set of configurations. They are defined by case analysis on the structure of e then t in a standard fashion, as in Fig. 1. Branching is as in C, identifying non-zero values with true and zero with false. Binary operators are evaluated left-to-right, also as in C. Arithmetic and logic operators ( ) have the obvious evaluation. Dereferencing is given the usual evaluation, with a note that in order for the rule to apply it is implied that v is a location and s(v) is defined. Local-variable allocation extends the domain of s with a fresh secret name. Local variables are created fresh, locally for the scope of a function body. The new() operator allocates a secret and fresh location name, initialises it to zero and returns its location. The return statement is used as a syntactic marker for an end of function but it has no semantic role.
Structural rules, such as function application and tuples are as usual in call- by-value languages, i.e. left-to-right. Function call also has a standard evaluation. The body of the function replaces the function call and its formal arguments x are substituted by the tuple of arguments v∗ in point-wise fashion. Finally, non- canonical forms also have standard left-to-right evaluations.
System semantics
The conventional function-call rule (F) is only applicable if there is a function definition in the module. If the name used for the call is not the name of a known function then the normal operational semantics rules no longer apply. We now extend our semantics so that calls and returns of locally undefined functions become a mechanism for interaction between the program and the ambient system. We call

the resulting semantics the System Level Semantics (SLS).
Given a module M we will write as JM ) the transition system defining its SLS. Its states are SJM ) = SysJM ) ∪ ProgJM ), where ProgJM ) is the set of abstract- machine configurations of the previous section and SysJM ) is the set of system configurations, which are of the form: ⟨⟨N | P ▶ s⟩⟩ ∈ N × N × Sto.
The SLS is defined at the level of modules, that is programs with missing func- tions, similarly to what is usually deemed a compilation unit in most programming languages. The transition relation δJM ) of the SLS operates on a set of labels L {ϵ} and is of the following type.
δJM )  ⊆ (ProgJM ) × {ϵ}× ProgJM )) ∪ (ProgJM ) ×L× SysJM ))
∪ (SysJM ) ×L× ProgJM ))
L = {(s, call f, v, k) | s ∈ Sto, κ(s)= ∅, f ∈ Nλ, k ∈ Nκ, v a value}
∪ {(s, ret v, k) | s ∈ Sto, κ(s)= ∅, k ∈ Nκ, v a value}

Thus, at the system level, program and system configurations may call and return functions in alternation, in very much the same way that P and O make moves in

game semantics. We write X −→α
s
X∗ for (X, (s, α),X∗) ∈ δJM ), and X → X∗ for

(X, ϵ, X∗) ∈ δJM ).
In transferring control between Program and System the continuation pointers ensure that upon return the right execution context can be recovered. We impose several hygiene conditions on how continuations can be used. We distinguish be- tween P- and S-continuation names. The former are created by the Program and stored for subsequent use, when a function returns. The latter are created by the System and are not stored. The reason for this distinction is both technical and intuitive. Technically it will simplify proving that composition is well-defined. Mix- ing S and P continuations would not create any interesting behaviour: if P receives a continuation it does not know then the abstract machine of P cannot evaluate it, which can be interpreted as a crash. But S always has ample opportunities to crash the execution, so allowing it seems uninteresting. However, this is in some sense a design decision and an alternative semantics, with slightly different properties, can be allowed to mix S and P continuations in a promiscuous way.
The first new rule, called Program-to-System call is:

When a non-local function is called, control is transferred to the system. In game semantics this corresponds to a Proponent question, and is an observable action. Following it, all the names that can be transitively reached from public names in the store also become public, so it gives both control and information to the System. Its observability is marked by a label on the transition arrow, which includes: a tag

call, indicating that a function is called, the name of the function (f ), its arguments
(v) and a fresh continuation (k∗), which stores the code pointer; the transition also marks that part of the store which is observable because it uses publicly known names.
The counterpart rule is the System-to-Program return, corresponding to a return from a non-local function.

This is akin to the game-semantic Opponent answer. Operationally it corresponds to S returning from a function. Note here that the only constraints on what S can do in this situation are epistemic, i.e. determined by what it knows:
it can return with any value v so long as it only contains public names or fresh names (but not private ones);
it can update any public location with any value;
it can return to any (public) continuation k∗.
However, the part of the store which is private (i.e. with domain in N \ P ) cannot be modified by S. So S has no restrictions over what it can do with known names and to known names, but it cannot guess private names. Therefore it cannot do anything with or to names it does not know. The restriction on the continuation are just hygienic, as explained earlier.
There are two converse transfer rules System-to-Program call and Program-to-System return, corresponding to the program returning and the system initiating a function call:


In the case of the S-P call it is S which calls a publicly-named function from the module. As in the case of the return, the only constraint is that the function f , arguments v and the state update s∗ only involve public or fresh names. The hygiene conditions on the continuations impose that no continuation names are stored, for reasons already explained. Finally, the P-S return represents the action of the program yielding a final result to the system following a function call. The names used in constructing the return value are disclosed and the public part of the store is observed. In analogy with game semantics the function return is a Proponent answer while the system call is an Opponent question.

The initial conﬁguration of the SLS for module M is S0 = ⟨⟨N0 | P0 ▶ s0⟩⟩. It
contains a store s0 where all variables are initialised to the value specified in the declaration. The set N0 contains all the exported and imported names, all declared variables and functions. The set P0 contains all exported and imported names.
When M is not clear from the context, we may write P 0 for P0, etc.

Compositionality
The SLS of a module M gives us an interpretation JM ) which is modular and effective (i.e. it can be executed) so no consideration of the context is required in formulating properties of modules based on their SLS. Technically, we can reason about SLS using standard tools for transition systems such as trace equivalence, bisimulation or Hennessy-Milner logic.
We first show that the SLS is consistent by proving a compositionality prop- erty. SLS interpretations of modules can be composed semantically in a way that is consistent with syntactic composition. Syntactic composition for modules is con- catenation with renaming of un-exported function and variable names to prevent clashes, which we will denote by using −· −. In particular, we show that we can define a semantic SLS composition ⊗ so that, for an appropriate notion of isomor- phism in the presence of τ -transitions (∼=τ ), the following holds.

We call this the principle of functional composition.
Let P range over program configurations, and S over system configurations.
Moreover, assume an extended set of continuation names N∗ = Nκ  Naux, where
Naux is a countably infinite set of fresh auxiliary names. We define semantic compo-
sition of modules inductively as in Fig. 2 (all rules have symmetric, omitted coun- terparts). We use an extra component Π containing those names which have been communicated between either module and the outside system, and we use an aux- iliary store s containing values of locations only. The latter records the last known values of location names that are not private to a single module. Continuation names in each Π are assigned Program/System polarities (we write k ∈ ΠP / k ∈ ΠS), thus specifying whether a continuation name was introduced by either of the modules or from the outside system. Cross calls and returns are assigned τ -labels and are marked by auxiliary continuation names. We also use the following notations for updates of Π when an interaction with the outside system is made, where we write Pr for the set of private names ν(S, S∗) \ Π.
(Π, s∗)P [v, k, s] = Cl(s∗[s], ν(v) ∪ Π) ∪ {k}, and assign P polarity to k;
(Π, s∗)S[v, k, s] = Π ∪ ν(v, s \ Pr ) ∪ {k}, and assign S polarity to k.
The notations apply also to the case when no continuation name k is included in the update (just disregard k). The semantic composition of modules M and M∗ is





thus given by:
Fig. 2. Rules for semantic composition

∗	s0∪s′	∗
JM ) ⊗ JM ) = JM ) ⊗Π0	JM )
0
where s0 is the store assigning initial values to all initial public locations of JM ), and similarly for s∗ , and Π0 contains all exported and imported names.
The rules of Fig. 2 feature side-conditions on choice of continuation names, 2 system stores 3 and name privacy. The latter originate from nominal game se- mantics [1,11] and they guarantee that the names introduced (freshly) by M and M∗ do not overlap (rule (i)), and that the names introduced by the system in the composite module do not overlap with any of the names introduced by M or M∗ (rules (vi)-(vii)). They safeguard against incorrect name flow during composition. Let us call the four participants in the composite SLS Program A, System A, Program B, System B. Whenever we use X, Y as Program or System names they can be either A or B, but different. Whenever we say Agent we mean Program or System. A state of the composite system is a pair (Agent X, Agent Y) noting that they cannot be both Programs. The composite transition rules reflect the following
intuitions.
Rule (i): If Program X makes an internal (operational) transition System Y is not affected.
Rules (ii)-(iii): If Program X makes a system transition to System X and

2 That is, auxiliary names are used precisely for cross calls and returns.
3 These stipulate (rules (vi)-(vii)) that the store produced in each outside system transition must: (a) be defined on all public names (i.e. names in Π), and (b) agree with the old one on all other names. The latter safeguards against the system breaking name privacy.

System Y can match the transition going to Program Y then the composite system makes an internal (τ ) transition. This is the most important rule and it is akin to game semantic composition via “synchronisation and hiding”. It signifies M making a call (or return) to (from) a function present in M∗.
Rules (iv)-(v): If Program X makes a system transition that cannot be matched by System Y then it is a system transition in the composite system, a non-local call or return.
Rules (vi)-(vii): From a composite system configuration (both entities are in a system configuration) either Program X or Program Y can become active via a call or return from the system.
We can now formalise and prove functional composition (proof in Appendix B).
Definition 3.1 Let G1, G2 be LTSs corresponding to a semantic composite SLS and an ordinary SLS respectively. A function R from states of G1 to configurations of G2 is called a τ-isomorphism if it maps the initial state of G1 to the initial configuration of G2 and, moreover, for all states X of G1 and l ∈ L,

if X −→z
X∗ then R(X)= R(X∗),

if X → X∗ then R(X) → R(X∗),

if R(X) −→ Y and X −/→z
then X −→ X∗ with R(X∗)= Y ,

if X −→l
X∗ then R(X) −→l
R(X∗),

if R(X) −→l
Y and X −/→z
then X −→l
X∗ with R(X∗)= Y .

We write G1 ∼=z G2 if there is a τ -isomoprhism R : G1 → G2.
Proposition 3.2 For all modules M, M∗, JM ) ⊗ JM∗) ∼=z JM · M∗).

Reasoning about SLS
The epistemically-constrained system-level semantics gives a security-flavoured se- mantics for the programming language which is reflected by its logical properties and by the notion of equivalence it gives rise to.
We will see that certain properties of traces in the SLS of a module correspond to “secrecy violations”, i.e. undesirable disclosures of names that are meant to stay secret. In such traces it is reasonable to refer to the System as an attacker and consider its actions an attack. We will see that although the attack cannot be realised within the given language it can be enacted in a realistic system by system- level actions.
We will also see that certain equivalences that are known to hold in conven- tional semantics still hold in a system-level model. This means that even in the presence of an omnipotent attacker, unconstrained by a prescribed set of language constructs, the epistemic restrictions can prevent certain observations, not only by the programming context but by any ambient computational system. This is a very powerful notion of equivalence which embodies tamper-resistance for a module.

Note that we chose these examples to illustrate the conceptual interest of the SLS-induced properties rather than as an illustration of the mathematical power of SLS-based reasoning techniques. For this reason, the examples are as simple and clear as possible.
A system-level attack: violating secrecy
This example is inspired by a flawed security protocol which is informally described as follows.
Consider a secret, a locally generated key and an item of data read from the environment. If the local key and the input data are equal then output the secret, otherwise output the local key.
In a conventional process-calculus syntax the protocol can be written as
νsνk.in(a).if k=a then out(s) else out(k).
It is true that the secret s is not leaked because the local k cannot be known as it is disclosed only at the very end. This can be proved using bisimulation-based techniques for anonymity. Let us consider an implementation of the protocol:
export prot; import read; decl prot( ) {
local s, k, x; s = new(); k = new(); x = read(); if (*x == *k) then *s else *k}
We have local variables s holding the “secret location” and k holding the “private location”. We use the non-local, system-provided, function read to obtain a name from the system, which cannot be that stored at s or k. A value is read into x using untrusted system call read(). Can the secrecy of s be violated by making the name stored into it public? Unlike in the process-calculus model, the answer is “yes”.
The initial configuration is ⟨⟨ prot, read | prot, read ▶ ∅ ⟩. We denote the body of prot by E. The transition corresponding to the secret being leaked is shown in Fig. 3. The labelled transitions are the interactions between the program and the system and are interpreted as follows:
system calls prot() giving continuation k
program calls read() giving fresh continuation k∗
system returns (from read) using k∗ and producing fresh name a2
program returns (from prot) leaking local name a1 stored in k
system uses k∗ to fake a second return from read, using the just-learned name
a1 as a return value
with a1 the program now returns the secret a0 stored in s to the environment. Values of a2 are omitted as they do not affect the transitions.


call prot (),k
⟨⟨N0 | P0 ▶ ∅ ⟩ −−−−−−−−−→ ⟨N0,k | P0,k ▶ ∅, −,E, k⟩
∅
−−−−−−−→∗⟨N1, k, a0, a1 | P0,k ▶ (s '→ a0,p '→ a1, x '→ 0),
( ; if(∗x == ∗p) then ∗ s else ∗ p) ◦ (x = ) ◦ (read( )), (), k⟩
call read (),k'	′	′
−−−−−−−−−→⟨⟨N1, k,k , a0, a1 | P1 ▶ (s '→ a0, k '→ a1, x '→ 0,k '→ (t, k))⟩⟩
∅
ret a2 ,k'	′
−−−−−−−−→⟨N2 | P1, a2 ▶ (s '→ a0, k '→ a1, x '→ 0,k '→ (t, k)), t, a2, k⟩
∅
−−−−−−−→∗⟨N2 | P1, a2 ▶ (s '→ a0, k '→ a1, x '→ a2, k′ '→ (t, k)), −, a1, k⟩
ret a1 ,k	′
−−−−−−−→⟨⟨N2 | P2, a2, a1 ▶ (s '→ a0, k '→ a1, x '→ a2,k '→ (t, k))⟩⟩
∅
ret a1 ,k'	′
−−−−−−−−→⟨N2 | P1, a2, a1 ▶ (s '→ a0, k '→ a1, x '→ a2,k '→ (t, k)), t, a1, k⟩
∅
−−−−−−−→∗⟨N2 | P1, a2, a1 ▶ (s '→ a0, k '→ a1, x '→ a1, k′ '→ (t, k)), −, a0, k⟩
ret a0 ,k	′
−−−−−−−→⟨⟨N2 | P2, a2, a1, a0 ▶ (s '→ a0, k '→ a1, x '→ a2,k '→ (t, k))⟩⟩.
∅
Above, t = ( ; if(∗x == ∗k ) then ∗ s else ∗ k ) ◦ (x = ), N0 = P0 = {prot, read}, N1 = N0 ∪ {s, k, x},
N2 = N1 ∪ {k, k′, a0, a1, a2} and P1 = P0 ∪ {k, k′}.
Fig. 3. Secret a0 leaks.
The critical step is (v), where the system is using a continuation in a presumably illegal, or at least unexpected, way. This attack can be implemented in several ways:
If the attacker has access to more expressive control commands such as callcc
then the continuation can simply be replayed.
If the attacker has low-level access to memory it can clone (copy and store) the continuation k∗, i.e. the memory pointed at by the name k∗. In order to execute the attack it is not required to have an understanding of the actual machine code or byte-code, as the continuation is treated as a black box. This means that the attack cannot be prevented by any techniques reliant on obfuscation of the instruction or address space, such as randomisation.
If the attacker has access to fork-like concurrency primitives then it can exploit them for the attack because such primitives duplicate the thread of execution, creating copies of all memory segments. Note that the behaviour of the con- ventional Unix fork is richer than what we consider in our system model, but it can be readily accommodated in our framework by a configuration-cloning system transition:
⟨⟨N | P ▶ s⟩⟩ → ⟨⟨N + N | P + P ▶ s[N/inl(N )] ∪ s[N/inr(N )]⟩⟩
The attacker’s ability to clone the configuration can lead to attacks which are purely systemic, for example executing the program into a virtual machine, pausing execution, cloning the state of the machine, then playing the two copies against each other.

Equivalence
Functional Compositionality gives an internal consistency check for the semantics. This already shows that our language is “well behaved” from a system-level point

of view. In this section we want to further emphasise this point. We can do that by proving that there are nontrivial equivalences which hold. There are many such equivalences we can show, but we will choose a simple but important one, because it embodies a principle of locality for state.
This deceptively simple example was first given in [13] and establishes the fact that a local variable cannot be interfered with by a non-local function. This was an interesting example because it highlighted a significant shortcoming of global state models of imperative programming. Although not pointed out at the time, functor- category models of state developed roughly at the same time gave a mathematically clean solution for this equivalence, which followed directly from the type structure of the programming language [15].
We compare SLSs be examining their traces. Formally, the set of traces of module M is given by:


T (M )= {(π · w) ∈ L∗ | S0
−→w→ X, ∀a ∈ P 0 . π(a)= a}


where note that we orbit through in order to factor out the choice of initial private names.
Definition 4.1 Let M1, M2 be modules with common public names. We say that
M1 and M2 are trace equivalent, written M1 ∼= M2, if T (JM1))= T (JM2)).

The above extends to modules with P 0
1
/= P 0
2
by explicitly filling in the missing

public names on each side. We next introduce a handy notion of bisimilarity which
precisely captures trace equivalence. For each configuration X, let us write P (X) for the set of public names of X.
Definition 4.2 Let R be a relation between configurations. R is a simulation if, whenever (X1, X2) ∈ R, we have P (X1)= P (X2) and also:
X1 → Xj implies (Xj , X2) ∈ R;

X1 −→l
Xj implies X2 −→ Xjj with (π · Xjj) −→l  Xj and (Xj ,Xj ) ∈ R, for some

1	2	2	2	1	2
name permutation π such that π(a)= a for all a ∈ P (X1).
R is a bisimulation if it and its inverse are simulations. Modules M1 and M2 are

bisimilar, written M1 ∼ M2, if there is a bisimulation R such that (S0
, S0
2
) ∈ R.

Lemma 4.3 Bisimilarity coincides with trace equivalence.
Proposition 4.4 Trace equivalence is a congruence for module composition −· −.
It is straightforward to check that the following three programs have bisimilar SLS transition systems:
export f; import g; decl f() {local x; g(); return *x;} export f; import g; decl x; decl f() {g(); return *x;} export f; import g; decl f() {g(); return 0;}
Intuitively, the reason is that in the first two programs f-local (module-local, re- spectively) variable x is never visible to non-local function g, and will keep its initial

value, which it 0. The bisimulation relation is straightforward as the three LTSs are equal modulo silent transitions and permutation of private names for x.
Other equivalences, for example in the style of parametricity [14] also hold, with simple proofs of equivalence via bisimulation:

export inc, get; decl x;
decl inc(){x=(*x+1)%3;} decl get() {return *x;}
export inc, get; decl x;
decl inc() {x=(*x-1)%3;} decl get() {return -*x;}


These two programs, or rather libraries, implement a modulo-3 counter as an ab- stract data structure, using private hidden state x. The environment can increment the counter (inc) or read its value (get) but nothing else. The first implementation counts up, and the second counts down.

Conclusion
In this paper we have developed a relaxed notion of game semantics in which the behaviour of the Opponent is defined by epistemic rather than combinatorial con- straints. This has led us to two conclusions which we considered important.
First, we want to re-emphasise the fact that operational semantics can be ex- tended in a relatively straightforward way from handling programs to handling terms, without relying on translation or interpretation. This is an idea already implicit in techniques such as trace semantics [8] or environmental bisimulation [9]. In the process, operational semantics becomes compositional. An LTS denotational interpretation of terms emerges automatically, without losing its effective presenta- tion. Unlike previous work, however, we do not treat this extension of the opera- tional semantics as a means to an end, e.g. studying contextual equivalence, but we treat it as important in its own right.
Secondly, and most importantly, we want to show that a meaningful and useful notion of context for the execution of terms can be constructed outside the syntax of the language. This has several advantages. The first one is modularity, as we can define the language and the environment in which its terms operate independently; the principle of functional composition is the consistency check that we need to satisfy for the two to be able to work together. The second one is realism, as real-life languages allow, through mechanisms such as separate compilation and foreign-function interface, programs which are syntactically heterogeneous so they cannot be characterised by the usual notion of context. The third one is simplicity, as we show how it is possible to formulate restrictions on the environment in a way which is not computational but epistemic, resembling the established Dolev-Yao characterisation of context in security. We believe this has the potential to offer a semantic foundation for the study of security properties of programs (such as information flow or tamper-proof compilation) in a way which is less dependent on the vagaries of syntax and more modular.
Relevant related work with similar aims but different philosophy has been car-

ried out in compositional compiler correctness [4]. Whereas our point of view is mainly analytic, being interested in characterising arbitrary (if not unrestricted) environments and examine operationally the behaviour of open terms in such en- vironments, compositional compiler correctness is a primarily a synthetic concern, aiming at defining constraints on machine code which allow safe composition be- tween code generated via compilation with code generated in arbitrary ways. We see these two approaches as two sides of the same problem and we believe a better understanding of the relation between them should be studied.

References
S. Abramsky, D. R. Ghica, A. S. Murawski, C.-H. L. Ong, and I. D. B. Stark. Nominal games and full abstraction for the nu-calculus. In LICS, pp 150–159, 2004.
S. Abramsky, R. Jagadeesan, and P. Malacaria. Full abstraction for PCF. Inf. Comput., 163(2), 2000.
S. Abramsky and G. McCusker. Linearity, sharing and state: a fully abstract game semantics for Idealized Algol with active expressions. Electr. Notes Theor. Comput. Sci., 3, 1996.
N. Benton and C.-K. Hur. Biorthogonality, step-indexing and compiler correctness. In ICFP, 2009.
M. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding. Formal Asp. Comput., 13(3-5):341–363, 2002.
D. R. Ghica and A. Murawski. Angelic semantics of fine-grained concurrency. Annals of Pure and Applied Logic, 151(2-3):89–114, 2008.
J. M. E. Hyland and C.-H. L. Ong. On full abstraction for PCF: I, II, and III. Inf. Comput., 163(2), 2000.
A. Jeffrey and J. Rathke. Java jr: Fully abstract trace semantics for a core java language. In ESOP, 2005.
V. Koutavas, P. B. Levy, and E. Sumii. From applicative to environmental bisimulation. Electr. Notes Theor. Comput. Sci., 276:215–235, 2011.
J. Laird. Full abstraction for functional languages with control. In LICS, pp 58–67, 1997.
J. Laird. A game semantics of local names and good variables. In FoSSaCS, pp 289–303, 2004.
J. Laird. A fully abstract trace semantics for general references. In ICALP, pp 667–679, 2007.
A. R. Meyer and K. Sieber. Towards fully abstract semantics for local variables. In POPL, 1988.
P. W. O’Hearn and R. D. Tennent. Parametricity and local variables. J. ACM, 42(3):658–709, 1995.
R. D. Tennent. Semantical analysis of specification logic. Inf. Comput., 85(2):135–162, 1990.

Nominal Sets
It is handy to introduce here some basic notions from the theory of nominal sets [5]. We call nominal structure any structure which may contain names, i.e. elements of N , and we denote by Perm the set of finite permutations on N which are sort- preserving (i.e. if a ∈ Nλ then π(a) ∈ Nλ, etc.). We range over permutations by π and variants. Finiteness means that each set {a ∈ N | π(a) /= a} is finite. For example, id = {(a, a) | a ∈ N} is the identity permutation. On the other hand, (a b) = {(a, b), (b, a)}∪ {(c, c) | c /= a, b} is the permutation which swaps a and b and fixes all other names, for all a, b of the same sort.

For each set X of nominal structures of interest, we define a function · : Perm × X → X such that π · (πj · x) = (π ◦ πj) · x and id · x = x, for all x ∈ X and π, πj ∈ Perm. X is called a nominal set if all its elements involve finitely many names, that is, for all x ∈ X there is a finite set S ⊆N such that π· x = x whenever
∀a ∈ S.π(a)= a. The minimal such set S is called the support of x and denoted by ν(x). For example, N is a nominal set with action π · a = π(a), and so is Pfn(N ) with action π · S = {π(a) | a ∈ S}.
Also, any set of non-nominal structures is a nominal set with trivial action π · x = x. More interestingly, if X, Y are nominal sets then so is X × Y with action π · (x, y)= (π · x, π · y). This extends to arbitrary products and to strings. Finally, if X, Y are nominal sets then so is the set X ~fn Y with action π · f =
{(π · x, π · y) | (x, y) ∈ f}.
Functional composition
We start with a lemma which stems from the definitions. We write κj(−) for the projection on Nj = Nκ  Naux, and κ(−) for the projection on Nκ.
Lemma B.1 Let X1 ⊗s X2 be a state in the transition graph of JM ) ⊗ JMj) that
is reachable from the initial state. Then, if each Xi includes the triple (Ni, Pi, si), the following conditions hold.
(N1 \ P1) ∩ N2 = N1 ∩ (N2 \ P2)= ∅, P1 \ Π = P2 \ Π, Π ⊆ ν(s) ∪ κ(P1 ∪ P2) ⊆
P1 ∪ P2 and dom(s)= λ(P1 ∪ P2).
dom(κj(s1)) ∩ dom(κj(s2)) = ∅, (dom(κj(s1)) ∪ dom(κj(s2))) ∩ ΠS = ∅ and
κj(P1 ∩ P2) \ ΠS = κj(P1 ∪ P2) \ Π ⊆ Naux.

If both X1, X2 are system conﬁgurations and X1 ⊗s
X2 is preceded by a state

Π
s′
of the form P ⊗Π′ S then s T P1 ⊆ s1 and s T (P2 \ P1) ⊆ s2, and dually if
preceded by	s′	. Thus, in both cases, s T (P \ (P ∩ P )) ⊆ s for i = 1, 2.

S ⊗Π′ P
i	1	2	i

Not both X1, X2 are program conﬁgurations. If Xi is a program conﬁguration then s T (P3−i \ Pi) ⊆ s3−i.
Semantic composition introduces a notion of private names: internal continua- tion names passed around between the two modules in order to synchronise their mutual function calls. As the previous lemma shows, these names remain private throughout the computation. Therefore, in checking bisimilarity for such reduc- tion systems, special care has to be taken so that these private names cannot be captured by external system transitions. This is achieved by selecting (only) these names from the auxiliary set Naux.
We define the following translation R from reachable states of JM ) ⊗ JMj) to configurations of JM · Mj).


⟨⟨N1 | P1 ▶ s1⟩⟩ ⊗s

⟨⟨N1 | P1 ▶ s1⟩⟩ ⊗s
⟨⟨N2 | P2 ▶ s2⟩⟩
'−→ ⟨⟨(N1 ∪ N2) \ Naux | Π ▶ (sˆ1[sj] ∪ sˆ2[sj]) \ Naux⟩⟩
⟨N2 | P2 ▶ s2, t, v, k⟩

'−→ ⟨(N1 ∪ N2) \ Naux | Π ▶ sˆ1[sˆ2] \ Naux, tj, v, kj⟩
⟨N1 | P1 ▶ s1, t, v, k⟩ ⊗s ⟨⟨N2 | P2 ▶ s2⟩⟩
Π
'−→ ⟨(N1 ∪ N2) \ Naux | Π ▶ sˆ2[sˆ1] \ Naux, tj, v, kj⟩
where sj = s T (P1 ∩ P2), sˆi = si[k '→ (s1, s2)↓(si(n))] for all k ∈ dom(κ(si)), and (tj, kj)= (s1, s2)↓(t, k). The function (s1, s2)↓ fetches the full external frame stack and the external continuation searching back from (t, k), that is:
(s ,s ) (t, k)= ((t, k)	if k ∈/ Naux
Thus, the translation merges names from the component configurations and deletes the names in Naux: these private names do not appear in JM · Mj), as there the corresponding function calls happen without using the call-return mechanism. Note that JM · Mj) is defined over the original N , so it cannot capture any k ∈ Naux. The translation also sets Π as the set of public names. Moreover, the total store is computed as follows. In system configurations we just take the union of the component stores and update them with the values of s, which contains the current values of all common public names. In program configurations we use the fact that the P-component contains more recent values than those of the S-component.

Proposition B.2 For R deﬁned as above and X1 ⊗s
X2 a reachable conﬁguration,

if X ⊗s X
−→z
Xj ⊗s′ Xj
then R(X ⊗s X )= R(Xj ⊗s′ Xj ),

1  Π  2
1  Π  2
1  Π  2
1  Π  2

if X1⊗s X2 → Xj ⊗s Xj then R(X1⊗s X2) → R(Xj ⊗s Xj ),
Π	1  Π  2	Π	1  Π  2

if R(X1 ⊗s X2) −→ Y and X1 ⊗s
X2 /−→z
then X1 ⊗s X2 −→ Xj ⊗s Xj with

Π
Y = R(Xj ⊗s
Π
Xj ),
Π	1	Π	2

if X
1	Π
1 ⊗s X2 −→α
s
2
j	s′′	j
1	Π′	2
then R(X
1 ⊗s X2) −→α
s
R(Xj ⊗s′′ Xj ),

if R(X
1 ⊗s X2) −→α
s
Y and X
1 ⊗s X2
/−→z
then X
1 ⊗s X2 −→α
s
j	s′′	j
1	Π′	2
with

Y = R(Xj ⊗s′′ Xj ).
1	Π′	2
Proof. For 1, let X1 = ⟨N1 | P1 ▶ s1,t ◦ f ( ), v, k⟩, X2 = ⟨⟨N2 | P2 ▶ s2⟩⟩ and the
τ -transition being due to an internal transition with label (si, call f, v, kj). Thus,

Xj = ⟨⟨N j | Pj ▶ sj ⟩⟩, Xj
= ⟨Nj | Pj ▶ sj ,f (  ), v, kj⟩, and so R(X1 ⊗s
X2) = 

1	1	1	1	2
2	′ 2	2	Π

⟨N0 | Π ▶ s0, t0, v, k0⟩ and R(Xj ⊗s Xj ) = ⟨Nj | Π ▶ sj , tj , v, kj ⟩. Note that
1	Π	2	0	0  0	0
kj ∈ Naux. Moreover, sj = s1[kj '→ (t, k)] and sj = s ∪ (s2 \ P2), so (tj , kj ) = 
1	2	0	0
(sj , sj )↓(f ( ), kj)= (sj , sj )↓(t◦f ( ), k)= (t0, k0). Moreover, N0 = (N1 ∪N2)\Naux
1	2	1	2
and Nj = (Nj ∪ Nj ) \ Naux = (N1 ∪ {kj}∪ N2 ∪ ν(v, si)) \ Naux. As ν(v, si) ⊆ N1
0	1	2
and kj ∈ Naux, we get N0 = Nj . Finally, s0 = sˆ2[sˆ1] \ Naux and sj = sˆj [sˆj ] \ Naux.
0	0	1  2
Thus, sj = sˆ1[sˆj ] \ Naux = sˆ1[sj ∪ (sˆ2 \ λ(P2))] \ Naux. Moreover, sj = s1 T λ(Pj)
0	2	1
so sj = sˆ1[sˆ2 \ λ(P2)] \ Naux. But now note that dom(s2 \ λ(P2)) ∩ dom(s1) = ∅:
by the previous lemma, dom(s1) and dom(s2) share no continuation names, and if
a is a location name in dom(s2) \ P2 then a ∈/ N1. Thus, s0 = sj . Similarly if the
τ -transition is due to an internal return.

Item 2 is straightforward. For 3, the only interesting issue is establishing that

if X1 ⊗s
X2 is in such a form that a τ -transition needs to take place then the

latter is possible. This follows directly from the definitions and the conditions of the previous lemma. In the following cases we consider call transitions; cases with return transitions are treated in a similar manner.
For 4, let X1 = ⟨⟨N1 | P1 ▶ s1⟩⟩, X2 = ⟨⟨N2 | P2 ▶ s2⟩⟩, α = (sj, call f, v, k) and suppose the transition is due to X1 reducing to Xj = ⟨Nj | Pj ▶ sj ,f (  ), v, k⟩
1	1	1	1
with label (si, call f, v, k). We have Πj = Π ∪ ν(v, k, si \ Pr ), Pr = (N1 ∪ N2) \ Π,

sj = si T Πj and ν(v, si \ Pr ) ∩ Pr = ∅. Let R(X1 ⊗s
X2) = ⟨⟨N0 | Π ▶ s0⟩⟩. As

k ∈/ dom(s1) and k ∈/ ν(X2) \ ΠS, by previous lemma we obtain k ∈/ dom(s0), so the
latter reduces to ⟨Nj | P ▶ sj ,f (  ), v, k⟩ with transition (sjjj, call f, v, k), for any
0	0
appropriate sjjj. In fact, if ν(v, sj) ∩ N0 ⊆ Π then we can choose sjjj = sj. Indeed, (ν(v, sj) ∩ N0) \ Π ⊆ ν(v, sj) ∩ (N0 \ Π) ⊆ ν(v, sj) ∩ Pr = ν(v, si T Πj) ∩ Pr =
ν(v, s \ Pr ) ∩ Pr = ∅. Let R(Xj ⊗s′′ X ) = ⟨⟨N jj | Πj ▶ sjj⟩⟩. We can see that
i	1	Π′	2	0	0
Nj = Njj. Also, P = Π∪{k}∪ν(v, sj) while Πj = Π∪ν(v, k, si\Pr )= Π∪ν(v, k, sj).
0	0
Moreover, sj = sj ∪ (s0 \ λ(Π)) = sj ∪ ((sˆ1[s12] ∪ sˆ2[s12]) \ (Naux ∪ λ(Π))) with
s12 = s T (P1 ∩P2), and sjj = sˆ2[sˆj ] \ Naux = sˆ2[si ∪ (sˆ1 \ λ(P1))] \ Naux. Moreover, sj
0	1	0
and sjj agree on the domain of sj and on continuation names. Also, if location name
a ∈ Nj \N0 then a ∈ ν(v, sj) and thus a ∈ dom(sj). Thus, we need to show that sj , sjj
0	0	0
agree on location names a from N0 \ Π. If a ∈ N1 \ P1 then sj (a)= s1(a)= sjj(a),
0	0
and similarly if in N2 \ P2 using the fact that (N2 \ P2) ∩ N1 = ∅.  Finally, if
a ∈ P1 \ Π = P2 \ Π then sj (a)= s(a)= si(a)= sjj(a), by restrictions on si.
0	0
Now let X1 = ⟨N1 | P1 ▶ s1, t◦f ( ), v, k⟩, X2 = ⟨⟨N2 | P2 ▶ s2⟩⟩, α = call f, v, kj

and suppose the transition is due to X1 reducing to Xj
= ⟨⟨N j
| Pj
▶ sj ⟩⟩ with

label (si, call f, v, kj). We have (Πj, sjj) = (Π, s)[v, si] and sj = sjj T Πj. We can assume, by definition, that (s1, s2)K(t ◦ f ( ), k) = (t0 ◦ f ( ), k0), so R(X1 ⊗s X2) = ⟨N0 | Π ▶ s0, t0 ◦ f ( ), v, k0⟩. As f is not defined in either of the modules
and kj is completely fresh, the latter reduces to ⟨⟨N j | P ▶ sj ⟩⟩ with transition

jjj	j
j	s′′
0	0
jj	j	jj

(s , call f, v, k ). Let R(X1 ⊗Π′ X2) = ⟨⟨N0 | Π  ▶ s0 ⟩⟩. It is easy to see that
Nj = Njj. Moreover, sj = s0[kj '→ (t0, k0)] and sjj = (sˆj [sjj ] ∪ sˆ2[sjj ]) \ Naux where
0	0	0	0	1  12	12
sjj = sjj T (P j ∩ P2). Note that sjj(kj) = sˆj (kj) = (sj , s2)↓(t, k) = (t0, k0). Also,
12	1	0	1	1
j and sjj agree on all other continuation names. Thus, in order to establish that
sj = sjj, it suffices to show that s2[s1] and s1[sjj ] ∪ s2[sjj ] agree on locations. From
0	0	12	12
the previous lemma, sjj agrees with s1 on locations in Pj and with s2 on locations in
P2 \ Pj, and so sjj ⊆ s2[s1]. Thus, λ(s1[sjj ] ∪ s2[sjj ]) = λ(s1 ∪ (s2 \ Pj)) = λ(s2[s1]).
1	12	12	1
For public names, we have P = Cl(s0,Π∪ν(v))∪{kj} = Cl(sj ,Π∪ν(v, kj)) while
Πj = Cl(sjj,Π ∪ν(v, kj)). As κ(P )= κ(Π) ∪ {kj} = κ(Πj), we can focus on location
names. We have sjj ⊆ sj and, moreover, dom(sjj) = λ(Pj ∪ P2) ⊇ λ(Π ∪ ν(v, kj)),
thus P = Πj. Finally, sj = sjjj follows from the fact that these are restrictions of the final stores to the final sets of public location names.

For 5, let X1 = ⟨⟨N1 | P1 ▶ s1⟩⟩, X2 = ⟨⟨N2 | P2 ▶ s2⟩⟩, R(X1 ⊗s
X2) = ⟨⟨N0 |

Π ▶ s0⟩⟩ and α = (sj, call f, v, k). We have that f is defined in M · Mj so WLOG
assume that it is defined in M . Then, X1 reduces to Xj = ⟨Nj | Pj ▶ sj ,f (  ), v, k⟩
1	1	1	1
with (si, call f, v, k), si = sj ∪ (s \ Π), if the relevant conditions for S-P calls are

satisfied.
If k ∈ dom(s1) then, by lemma, k ∈/

ΠS. By assumption, k ∈ Π so k ∈/

κ(P1 ∪ P2) \ Π and thus, by lemma, k ∈/ κ(P1 ∩ P2) \ ΠS so k ∈/ P2. But the latter would imply k ∈ dom(s0), which is disallowed by definition. Thus, k ∈/ dom(s1).
Moreover, if a ∈ ν(v, si)∩(N1\P1)= ν(v, sj)∩(N1\P1) then a ∈ ν(v, sj)∩(N0\P1) and a ∈/ P2, so a ∈ ν(v, sj) ∩ (N0 \ (P1 ∪P2)) ⊆ ν(v, sj) ∩ (N0 \ Π), thus contradicting the conditions for the transition α. We still need to check that s1 T λ(P1) ± si = sj ∪ (s \ Π). Given that s0 T λ(Π) = (s1[s12] ∪ s2[s12]) T λ(Π) ± sj, the condition
follows from the previous lemma. We therefore obtain a transition from X1 ⊗s X2
M
j	s′′
to X1 ⊗M′ X2; the relevant side-conditions are shown to be satisfied similarly as
above. Finally, working as in 4, we obtain R(Xj ⊗s′′ X )= Y and sj = sjjj.
1	M′	2
Now let X1 = ⟨N1 | P1 ▶ s1,t◦f ( ), v, k⟩, X2 = ⟨⟨N2 | P2 ▶ s2⟩⟩, R(X1 ⊗s X2)= 
⟨N0 | Π ▶ s0, t0 ◦ f ( ), v, k0⟩ and α = call f, v, kj. By hypothesis, kj is fresh

and therefore X1 reduces to Xj = ⟨⟨N j
| Pj ▶ sj ⟩⟩ with (si, call f, v, kj), and

s	j 1 s′′
1	1	1
jjj	j

thus X1 ⊗M X2 reduces to X1 ⊗M′ X2 with (s , call f, v, k ). Working as in 4,
R(Xj ⊗s′′ X )= Y and sj = sjjj.	2
1	M′	2
C  Equivalence
We first define a notion of accepted traces for arbitrary configurations by setting T (X)= {(π · w) ∈ L∗ | X −→w→ Xj, ∀a ∈ P (X). π(a)= a}, where P (X) is the set of public names of X. Note that w ∈ T (X) implies π · w ∈ T (X) for any π that fixes
l/є	π·l/є
all names in P (X) and, moreover, since X −−→ Xj =⇒ (π · X)	(π · Xj), that
T (X)= {w ∈ L∗ | (π · X) −→w→ Xj, ∀a ∈ P (X). π(a)= a}.
Lemma C.1 Let M1, M2 be modules with common initial public names. Then,
M1 ∼ M2 ⇐⇒ M1 ∼= M2.
Proof. (⇒) Let R be a bisimulation witnessing M1 ∼ M2. For each transition sequence

0	−→ X1 −l→1
Xj −→ X2 −l→2
Xj ··· −→ Xn −l→n
Xj ,

R yields a diagram as below,

S0 	/X¸  l1	/X¸j 	/X¸  l2	/X¸j 	/· ·¸·	/X¸	ln	/X¸j
M1	1	1	2	2	n	n
R
S0 	/Y ¸	R
M2	1
R
π1 · Y1   l1 /Y ¸j 	/Y ¸
1	2
R
π2 · Y2  l2 /Y ¸j 	/· ·¸· 
···	/Y ¸
πn · Yn   ln  /Y ¸j

and hence filling in the gaps we obtain:
πn·l1	πn·l2	l
πn · S0	−→ πn · Y1 −−2−→ πn · Y j −→ πn · Y2 −−3−→ πn · Y j ··· −→ πn · Yn −−→n  Y j

1	M2	1
2	1	2
3	2	n	n

where πn = πn ◦ · · · ◦ πi. By definition, each πi fixes all names in P (Xi) so, in
particular, πi · lj = lj for all j < i, thus πn · S0	−l−1−...−l→n→ Y j.
1	M2	n
Hence, w ∈ T (M1) implies w ∈ T (M2). The other inclusion is shown similarly.
Conversely, suppose T (M1)= T (M2) and let us define the relation:
R = {(X ,X ) | S0 −w→i  X , P (X )= P (X ), T (X )= T (X )}

2	Mi	i	1
2	1	2

We claim that R is a bisimulation. By symmetry, it suffices to show it is a sim- ulation. Observe that all related configurations have common public names and, moreover, that R is closed under ϵ-transitions (by determinacy of internal transi-

tions up to choice of fresh names). Now let (X1, X2) ∈ R with X1 −→l
Xj . Since

l ∈ T (X1) = T (X2), there is a configuration Xjj and a permutation π fixing all
elements of P = P (X1) = P (X2) = P (Xjj) such that π · X2 −→ Xjj −→l  Xj . Thus,
2	2	2
X2 −→ π−1· Xjj and π · (π−1· Xjj) −→l  Xj . Also, Pj = P (Xj )= P (Xj )= P ∪ ν(l).
j w	jj	2	2	1	2	jj

Take now any X1 −→ X1 . We have lw ∈ T (X1)= T (X2) so, for some π
fixing all

names in P , πjj · X2 −→ X˜jj −→l  X˜2 −→w→ X˜j . In particular, X2 −→ πjj−1 · X˜jj and hence,
2	2	2
since internal transitions are deterministic up to choice of fresh (private) names,
Xjj = π˜ · X˜jj for some π˜ fixing all names in P . We thus obtain:
2	2
Xjj −→l  Xj ,	Xjj −π˜−→·l π˜ · X˜2 .	(∗)
2	2	2
Suppose Xjj is a P configuration. Then, by determinacy, l = π˜ · l and Xj = π˜ · X˜2.
2	2
Recall that π˜ fixes all names in P . Moreover, the closure conditions on P-to-S
transitions stipulate that all names in Pj \ P are reachable from P ∪ ν(v) through the store s, where v, s the value and store components of l respectively. This implies
that π˜ fixes all names in Pj. Hence, from X˜2 −→w→ X˜j we obtain w ∈ T (Xj ).
On the other hand, if Xjj is an S configuration then let a1, ··· , aN be an enumeration
of ν(Xjj). We define permutations π0, π1, ..., πN by:
π0 = id ,	πi+1 = (ai+1 (πi ◦ π˜)(ai+1)) ◦ πi .
We claim that, for each 0 ≤ i ≤ N and 1 ≤ j ≤ i, we have
πi · π˜ · aj = aj ,	∀a ∈ ν(l)\P. πi · π˜ · a = π˜ · a,	∀a ∈ P. πi · a = a. 
We do induction on i; the case of i = 0 is clear. For the inductive step, if πi·π˜·ai+1 = ai+1 then πi+1 = πi, and πi+1 · π˜ · ai+1 = πi · π˜ · ai+1 = ai+1. Moreover, by IH, πi+1 · π˜ · aj = aj for all 1 ≤ j ≤ i, and πi+1 · π˜ · a = π˜ · a for all a ∈ ν(l) \ P ,

and πi+1 · a = a for all a ∈ P . If πi · π˜ · ai+1 = aj
/= ai+1 then, by construction,

πi+1·π˜·ai+1 = ai+1. Moreover, for each 1 ≤ j ≤ i, by IH, πi+1·π˜·aj = (ai+1 aj
)·aj,

and the latter equals aj since ai+1 /= aj implies aj
/= πi · π˜ · aj = aj. For any

a ∈ ν(l) \ P , πi+1 · π˜ · a = (ai+1 aj
) · πi · π˜ · a = (ai+1 aj
) · π˜ · a, by IH.

Now, a /= ai+1 since ν(l) ∩ ν(Xjj) ⊆ P , hence π˜ · a = πi · π˜ · a /= aj
. Moreover,

2	i+1
ν(π˜ · l) ∩ ν(Xjj) ⊆ P implies π˜ · a /= ai+1, so πi+1 · π˜ · a = π˜ · a. Finally, for any

a ∈ P we have πi+1 · a = (ai+1 aj
) · πi · a = (ai+1 aj
) · a. If a = ai+1 then

(ai+1 aj
) · a = aj
= πi · π˜ · a = πi · a = a, by IH and the fact that π˜ fixes all

a ∈ P . If a = aj
then (ai+1 aj
) · a = ai+1 = (πi ◦ π˜)−1 · a = a.

Setting πˆ = πN ◦ π˜, for each 1 ≤ j ≤ N we thus have
πˆ · aj = aj and
πˆ · l = π˜ · l. 

So, πˆ · Xjj = Xjj and therefore Xjj −πˆ−→·l  πˆ · Xj , that is, Xjj −π˜−→·l  πˆ · Xj . Hence, by (∗)
2	2	2	2	2	2
and determinacy, πˆ · Xj = π˜ · X˜2, so Xj = πˆ−1 · π˜ · X˜2. But observe that πˆ−1 ◦ π˜
fixes all names in Pj = P ∪ ν(l) and therefore w ∈ T (Xj ).
The above shows that T (Xj ) ⊆ T (Xj ) and similarly we show T (Xj ) ⊆ T (Xj ).
1	2	2	1
Hence, (Xj ,Xj )R and R is a simulation.	2
1	2
Proposition C.2 Trace equivalence is a congruence for module composition −· −.
Proof. Let M1, M2 be modules with common public names, and M a third module. By the previous lemma, it suffices to show that M1 ∼ M2 implies (M1 · M ) ∼ (M2 · M ). So let us assume M1 ∼ M2 with R a witnessing bisimulation and let Ri : JMi) ⊗ JM ) → JMi · M ) be a τ -isomorphism, for i = 1, 2. We define the following relation between configurations of JM1 · M ) and JM2 · M ).

Rj = {(R1(X1 ⊗s
Y ), R2(X2 ⊗s
Y )) | Xi ⊗s
Y reachable, (X1, X2) ∈ R}

Using Proposition B.2 we can show that Rj is a bisimulation.	2
