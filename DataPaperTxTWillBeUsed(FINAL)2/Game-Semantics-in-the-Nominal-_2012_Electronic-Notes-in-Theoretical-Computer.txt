Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 173–189
www.elsevier.com/locate/entcs
Game Semantics in the Nominal Model
Murdoch Gabbay
School of Mathematical and Computer Sciences Heriot-Watt University
Edinburgh, United Kingdom www.gabbay.org.uk
Dan Ghica
School of Computer Science University of Birmingham Birmingham, United Kingdom

Abstract
We present a model of games based on nominal sequences, which generalise sequences with atoms and a new notion of coabstraction. This gives a new, precise, and compositional mathematical treatment of justification pointers in game semantics.
Keywords: Game semantics, nominal sets, nominal abstraction and coabstraction, equivariance

Introduction
Game semantics is a successful collection of techniques for giving denotations to logic and computation. It came to particular prominence by solving the open problem of full abstraction for PCF [2,19] and is widely used from philosophy and logic, to model checking and synthesis of digital circuits [22,13].
The game metaphor is a dialogue between Proponent and Opponent : a play of a game records interactions between a term (the Proponent) and its context (the Opponent), and how they are scheduled.
One way to model a play is as a labelled acyclic graph called a pointer sequence. Each node in the graph is a Proponent or Opponent move and edges in the graph represent the justiﬁcation for that move. Thus, a pointer sequence records what moves were made and in what order, and also why.
We propose a model of games based on nominal sets, inspired by pointer sequences, with the difference that we model edges using atoms from nominal techniques (which we may also call names). Why this is useful will become clear in a moment.

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.012

Atoms are just a countably infinite set of distinct symbols: a, b, c,	A diagram
shows how these can model pointer sequences. The pointer sequence on the left corresponds to the nominal sequence on the right:
corresponds to	qc[a] qja[b] aa ajb ajjb

Questions and answers are written q and a, and atoms are used as pointers. The symbols [a] and [b] can be thought of as naming the questions q and qj and are binders into the ‘future’. So we see above that q justifies two moves: qj and a. Pointers (arrows, in the diagram above) are rendered as a pair of atoms. The tip of the arrow is represented by a coabstraction [b] which must be unique (this is formalised by the condition b /a∈toms(e) in Definition 2.8). The tail of the arrow, which need not be unique, is an occurrence of the name. This deals straightforwardly with dangling pointers, which are viewed just as free names; in the sequence above c is free.
Nominal sequences have the following good properties:
A sub-sequence of a nominal sequence is a nominal sequence. A sub-graph of a pointer sequence is not a pointer sequence, because it might have ‘dangling pointers’. In that sense, nominal sequences generalise pointer sequences and help talk easily about ‘open sequences’ (easy handling of open elements is a typical benefit of nominal techniques).
A concatenation of two nominal sequences is a nominal sequence; names link up and there are no reindexing isomorphisms. It is not so clear how to concatenate pointer sequences.
Nominal sequences are an inductive data-type and can be manipulated with standard tools (to fully benefit would require a mechanised nominal system [26] but we shall see our sequences simplify paper-and-pencil proofs too).
There is an important, specifically nominal advantage to using names in particular: it enables a particularly efficient management of renaming pointers to avoid ‘accidental clash’. It is important and useful that we use names to name moves and not e.g. numbers, because names are by definition symmetric (i.e. can be permuted); not only can we use permutations to α-convert, but taking names and their permutative symmetry as primitive saves effort since permutations propagate necessarily to the things we build using them, such as plays and strategies. 1 This style of name management is characteristic of nominal techniques and we shall see that it is effective here.
We formalise game models for PCF [19,23] and Concurrent Algol [14], at low

1 A general statement of this is the principle of equivariance (see [7, Subsection 4.2], [12, Lemma 4.7]). The principle of equivariance implies that, provided we permute names uniformly in all the parameters of our definitions and theorems, we then get another valid set of definitions and theorems. This is not true of numbers because our mathematical foundation equips numbers by construction with numerical properties such as less than or equal to ≤, which can be defined from first principles with no parameters.
So if we use numbers to model pointer sequences then we do not care about ≤ because we just needed a countable set of elements, but we repeatedly have to prove that we did not use an asymmetric property like
≤. In contrast, if we assume nominal foundations and use atoms, then we do not have to explicitly prove symmetry because we can just look at our mathematical foundation and note that it is naturally symmetric under permuting names; we reserve numbers for naturally asymmetric activities, such as counting.

overhead. The decoration of sequences by atoms is no more of an overhead than decoration by pointers, and equivariance is a very efficient way to manage renaming, so the overhead is low and the advantages in precision and conciseness appear to be significant.
We cannot replicate all definitions and proofs from these two large papers in this conference paper but we hope that it will be entirely obvious to the reader how this could be done. We do not claim to make the work above trivial. However, we do claim that using our formulation, game semantics can be carried out more quickly, more accurately, and more transparently.
This is important for more than good practice: we speculate that by our formu- lation, implementation and mechanisation of game semantics proofs are significantly easier. The reader can compare the definitions in this paper with the original versions [19,14] and judge which would be easier to work with, in a prover like Isabelle. Furthermore, game semantics can provide theoretical foundations for pro- gram verification and for hardware synthesis, where the pen-and-paper style of much previous work must be augmented by machine-checked proofs, because of scale, or for safety, or both. Here, the compositionality, computational, and symmetry properties enumerated and discussed above really count. Finally, game semantics can reconcile the compositionality of denotational semantics with the effectiveness of operational semantics via communicating abstract machines [16]; here, the con- ventional representation of pointers is arguably actively counterintuitive, whereas the use of names as tags for messages carries immediate computational intuitions.
Nominal game semantics
Nominal sequences
Definition 2.1 Fix disjoint countably infinite set of atoms A, and constants. a, b, c will range over distinct atoms (the permutative convention). f, g, h will range over constants, not necessarily distinct.
Define (nominal) sequences by
e ::= ε | ea | e f | e [a].
Remark 2.2 Call ε the empty list and write e ej for list concatenation. Call [a] a coabstraction. The reminds us of the atoms-abstraction of nominal techniques
[12]—but in e[a], a is bound ‘in the future’ in whatever ej we might concatenate after e[a]. We contrast the intended denotations of abstraction and coabstraction in the Conclusion.
Definition 2.3 Define coabstracted and free atoms ca(e) and fa(e) by:
ca(ε)= ∅	fa(ε)= ∅
ca(ea)= ca(e)	fa(ea)= fa(e)∪({a}\ca(e))
ca(ef)= ca(e)		fa(ef)= fa(e) ca(e[a])= ca(e)∪{a}	fa(e[a])= fa(e)
Define the atoms in an expression atoms(e) by atoms(e)= fa(e) ∪ ca(e).

Lemma 2.4 ca(e ej)= ca(e) ∪ ca(ej) and fa(e ej)= fa(e) ∪ (fa(ej) \ ca(e)).
Definition 2.5 A renaming ρ is a function from atoms to atoms such that
dom(ρ) = {a | ρ(a) =/ a} is finite. Write id for the identity renaming such
that id(a)= a and ρj ◦ ρ for composition such that (ρj ◦ ρ)(a)= ρj(ρ(a)).
Call bijective ρ permutations. Following [12] let π range over permutations (the application of renaming in a nominal context goes back to [11]).
Definition 2.6 Define a renaming action ρ·e on sequences by:
ρ·ε = ε
ρ·(ea)= (ρ·e)ρ(a)
ρ·(ef)= (ρ·e)f
ρ·(e[a]) = (ρ·e)[ρ(a)]
Nominal game semantics
A game is an arena (Definition 2.7) along with some set of legal plays which are lists of moves by a proponent or opponent —precisely what classes of plays are legal, determines the type of game they play.
Definition 2.7 An arena is a tuple A = (qstA, ansA, λA, ▶A, iniA) of:
Disjoint sets of questions q ∈ qstA and answers a ∈ ansA.
Write m ∈ mvsA = qstA  ansA for short and call this the set of moves.
A polarity function λA : mvsA → {O, P}. Write O∗ = P and P∗ = O.
An enabling relation ▶A ⊆mvsA × mvsA where m ▶A mj implies m ∈ qstA and
λA(m)=λA(mj)∗.
A set of initial questions iniA ⊆ qstA such that:
λA(i)= O for every initial i ∈ iniA.
If q ∈ qstA and i ∈ iniA then q /A▶i.
Definition 2.8 Define proto-plays e over an arena A inductively by:
e ::= ε | e ma[b]	(b /a∈toms(e))
Recall that m∈qstA ∪ ansA. Write pplyA for the set of all proto-plays of A.
Every proto-play is a sequence; not every sequence is a proto-play. It will always be clear what e ranges over.
Definition 2.9 Call ma[b] a (named) move; m will range over named moves.
Remark 2.10 • A proto-play consists of a sequence of named moves, each of which consists of a move m, a justifying name a and a coabstraction [b] which we call the name of m. This b ‘names’ its move, so that a later named move’s justifying name can point to m by its name b.
	The freshness condition b /a∈toms(e) makes b name its move uniquely in the sequence. This is inefficient—we cannot reuse names even if somehow we know we could—but we optimise for mathematical convenience.

In the games models of [19,23,14] only questions justify, so for the applications in this paper ▶A⊆ qstA×mvsA and we can drop the coabstractions naming answers in protoplays (so: qa[b] but just aa). However, this complicates definitions and loses generality, so we leave in (dummy) coabstractions and take ▶A⊆ mvsA×mvsA. An- swers justifying moves are used to construct ‘coproduct arenas’ in game semantics for call-by-value languages [3].
Definition 2.11 Suppose e and ej are sequences. Write ej ≤ e when ej ejj = e for some ejj; call ej a prefix of e. Write ej ⊆ e when ejjj ej ejj=e for some ejjj and ejj; call ej a segment of e.
Definition 2.12 Define enabled (e) the moves enabled by e ∈ pplyA by:
enabled (ε)= ∅
enabled (e ma[b]) = enabled (e) ∪ {mjb | m ▶A mj}
Lemma 2.13 enabled (e)=	{mb | mja[b] ⊆ e, mj ▶A m}.
Definition 2.14 Given e ∈ pplyA define its underlying sequence |e| by:
|ε| = ε
|ema[b]| = |e|m
Intuitions for Definition 2.15 are discussed in Remark 2.16:
Definition 2.15 Suppose A is an arena and A ⊆ A.
Call e ∈ pplyA justified when ej ma≤e and m/in∈iA implies ma∈enabled (ej).
Call e ∈ pplyA well-opened when ej ia[b] ≤ e implies ej = ε.
Call e ∈ pplyA strictly scoped when aa[b]ej ⊆ e implies a /f∈a(ej), for every
ej ∈ pplyA, a ∈ ansA, and atom a.
Call e ∈ pplyA strictly nested when qa[b] e2 qjb[c] e3 ab ⊆ e implies ajc ⊆ e3
for some answering move aj ∈ ansA. 2
Call e ∈ pplyA alternating when mmj ⊆ |e| implies λA(m) /=λA(mj).
Remark 2.16 Intuitively, Definition 2.15 means:
e is justiﬁed when every non-initial move responds to a preceding move.
e is well-opened when the initial move is unique and first in the sequence.
	e is strictly scoped 3 when a question can receive at most one answer. If we read games as processes, this means answering a question stops the process associated with that question.
e is strictly nested when questions are answered in (reverse) order. This forbids starting a process b, then c from inside b, then stopping b before c.
The intuition of e alternating seems clear but it does not have directly to do with names and binding, so we will not consider it further.
Definitions 2.17 and 2.18 follow [23, Sec. 2.1]:

2 What is important here is the atom c.
3 In [14, p. 7] ‘strictly scoped’ is called fork and ‘strictly nested’ is called join.

Definition 2.17 Given justified e ∈ pplyA define the proponent view pe’ and
opponent view ıeτ by: 4
pε’ = ε
pema[b]’ = pe’ma[b]	(λA(m)=P)
peia[b]’ = ia[b]
peqa[b]ejmb[c]’ = pe’qa[b]mb[c]	(λA(m)=O)
ıετ = ε
ıema[b]τ = ıeτma[b]	(λA(m)=O)
ıeqa[b]ejmb[c]τ = ıeτqa[b]mb[c]	(λA(m)=P)
Definition 2.18 We say that a justified proto-play e ∈ pplyA satisfies visibility
when ejqa[b]ejjqjb[c] ≤ e implies that:
if λA(q)= P then qa[b] ⊆ pejqa[b]ejj’, and
if λA(q)= O then qa[b] ⊆ ıejqa[b]ejjτ.
Compare this to the more informal definition of visibility in [23, Sec. 2.1]:
A well formed sequence s is legal, or is a legal position, if it also satisﬁes the following visibility condition:
if tm ± s where m is a P-move, then the justiﬁer of m occurs in pt’.
if tm ± s where m is a noninitial O-move, then the justiﬁer of m occurs in pt’.
The difficulty here is that the taking of the view removes moves from a play, and so requires a complex reindexing if pointers are formalised using integers. Finding the justifier of a move in a view is not straightforward.
Visibility is subtle, typical of languages that are pure or have only ground-type state. We have shown above how to formalise it in our framework, but proofs of properties involving visibility are non-trivial for reasons other than the handling of names and binding, so we will not consider this property further.
Remark 2.19 We can now characterise the plays of HO-games (the games from [19]) and GM-games (those from [14]). Suppose A is an arena and e ∈ pplyA is a proto-play. Then:
	In HO-games, e is a legal play when fa(e)= {a} for some a ∈ A and e is justified, well opened, alternating, strictly nested and satisfies visibility (see [19, Def. 4.2, Def. 4.4]).
	In GM-games, e is a legal play when fa(e) = {a} as above and e is justified, well-opened, strictly scoped, and strictly nested (see [14, Def. 1]).
The condition fa(e) = {a} implies e has one free atom a; one ‘dangling pointer’. With being well-opened, this ensures a names the initial question.
How do we choose a above? We do not. It is a non-evident design decision

4 The function e '→ ıeτ is not a total function because it is not defined on e of the form ia[b]e′ where
λA(i)= P. However, ıeτ is defined on all justified e, because ia[b]e′ where λA(i)= P is not justified.

that proto-plays do not have α-conversion on coabstracted atoms. This preserves compositionality: if [a]a equals [b]b then [a]ab equals [b]bb, which is nonsense. 5 In our framework α-conversion lives in strategies (sets of proto-plays), which are subject to an equivariance (symmetry) condition up to the choice of atoms in the proto-plays they contain. So α-equivalence does not live in the elements, it lives in the sets of elements. More on this in Remark 5.3.

Operations on plays
Deletion of moves from a play
We often want to delete moves from pointer sequences, reflecting ‘hiding’ of irrelevant parts of a computation (see e.g. Definition 5.2). But pointers into and out of deleted moves need to be updated. Definition 3.1 and Proposition 3.4 make this formal for our nominal framework. The culminating result of this subsection is Theorem 3.11, which uses Proposition 3.4 amongst other constructions to show that properties of proto-plays are preserved by deletion.
Definition 3.1 Suppose X ⊆ mvsA is some set of moves from an arena A, and e ∈ pplyA. Define deletion e]X inductively on e as follows, where we take inductively (f, ρ)= e]X :
ε]X = (ε, id)
(e ma[b])]X = (f mρ(a)[b], ρ)	(m /∈ )X 
(e ma[b])]X = (f, ρ[b:=ρ(a)])	(m ∈ X )
It will be convenient to write e]A for π1(e]mvsA), that is, for deletion of the set of moves of A. Here π1 is first projection.
Remark 3.2 Intuitively e]X is ‘e with the moves in X deleted’. Some reindexing has to take place when we do this: e.g. if qa[b] is deleted then any pointers to b are ‘reattached’ so that they point to whatever a points to:

]X =
In the diagram above the shaded nodes (circles) are in X and are deleted.
e]X inductively generates a ‘result’ f and a ‘reindexing renaming’ ρ. It is tempting to dismiss ρ as a by-product, but ρ may be the more important information since f can be calculated from ρ and X . This is Proposition 3.4, which is key to a nice proof of Theorem 3.11.
Definition 3.3 Suppose e∈pplyA and X⊆mvsA. We define naive deletion e-X as follows:

5 It is possible to reconcile α-conversion with proto-plays, by appending a ‘future permutation’, like so: [a]π . Then [a]ida equals [b](b a)b, not [b]idb. This is not needed here.

ε-F = ε
(e ma[b])-F = (e-F ) ma[b]	(m /∈ )F 
(e ma[b])-F = e-F	(m ∈ F )
Proposition 3.4 Suppose e ∈ pplyA and e]F = (ej, ρ). Then ej = (ρ·e)-F. 6
Proof By induction on e. We consider the interesting case (it changes ρ):
The case e ma[b] where m ∈ F.	Suppose e]F = (ej, ρ). Using the inductive hypothesis (e ma[b])]F = ((ρ·e)-F, ρ[b:=ρ(a)]).
Now (ρ·e)-F = (ρ·(e ma[b]))-F since m ∈ F . Also, ρ·e = (ρ[b:=ρ(a)])·e because by assumption in Definition 2.8 b /a∈toms(e) (Definition 2.3). 7	2
Lemma 3.5 enabled (ρ·e)= ρ·enabled (e).
As an immediate corollary, enabled (ρ·e)-F = (ρ·enabled (e))-F.
We now examine the impact deletion has on the legality conditions of Defini- tion 2.15. Legality is not preserved by arbitrary deletions, but deletion is usually used in a controlled way which ensures preservation. For instance deletion of moves forming an entire sub-tree in the arena, preserves legality properties. Other kinds of deletions can be dealt with similarly.
Lemma 3.6 Suppose F ⊆ mvsA and e ∈ pplyA. Write e]F = (f, ρ). Then fa(f ) ⊆
fa(e) and ca(f ) ⊆ ρ·ca(e).
Lemma 3.7 Suppose e ∈ pplyA. If ma ∈ enabled (e) then a ∈ atoms(e).
Proof By a routine induction on the proto-play e, using Definition 2.12.	2
Lemma 3.8 If ma[b] ⊆ e ∈ pplyA and mjb ∈ enabled (e) then m ▶A mj.
Proof By induction on e. We consider one case:
The case e ma[b]. Suppose mjb ∈ enabled (e ma[b]). By assumption in Defini- tion 2.8 b /∈atoms(e) and by Lemma 3.7 mjb /∈enabled (e). Unpacking Defini- tion 2.12 it follows that m ▶A mj.	2
Definition 3.9 Call F ⊆ mvsA closed under ▶A when m ∈F and m ▶A mj implies
mj ∈ F .
Lemma 3.10 Suppose F ⊆ mvsA is closed under ▶A. Suppose e]F = (ej, ρ). Then if ma ∈ enabled (e) and ma /∈ Fthen mρ(a) ∈ enabled (ej).
Proof By Lemma 3.5 it suffices to show that if ma ∈ enabled (e) then mρ(a) ∈
enabled ((ρ·e)-F ). We work by induction on e and consider one case:

6 ρ·e is a nominal sequence but it might not be a proto-play because coabstracted atoms need not be distinct. Also e-F need not be legal because naive deletion does not update links. Proposition 3.4 shows that Definition 3.1 calculates ρ and F such that if we do these two naive operations together, then we are all right.
7 This is the crux of the proof: because b is fresh, changing ρ to ρ[b:=ρ(a)] does not change whatever we have calculated so far.

The case of emaj[a].	Write e]F = (ej, ρ) and suppose mja ∈ enabled (emaj[a]) and
mj /∈ .FBy Lemma 3.8 m ▶A mj. Since mj /∈ Fit follows by closure of F under
▶A that m /∈ .FSo (ρ·(emaj[a]))-F = ((ρ·e)-F ) (mρ(aj)[ρ(a)]). By Definition 2.12,
mjρ(a) ∈ enabled (((ρ·e)-F ) (mρ(aj)[ρ(a)])).	2
Theorem 3.11 Suppose F ⊆ mvsA and e]F = (f, ρ).
If F ⊆ mvsA is closed under ▶A then if e is justiﬁed then so is f.
If iniA ∩F = ∅ then if e is well-opened then so is f.
If e is strictly scoped then so is f.
If F ⊆ mvsA is closed under ▶A then if e is strictly nested then so is f.
Proof
Suppose fjmρ(b) ≤ f where e]F = (f, ρ) and m /i∈niA. Using Proposition 3.4 fjmρ(b) = ((ρ·ej)-F )mρ(b) for some ej mb ≤ e, and also m /∈ .F Since e is justified, by Lemma 2.13 it must be that q ▶A m for some qa[b] ⊆ e. Since F is closed under ▶A we know q /∈ .F It follows by Proposition 3.4 that qρ(a)[ρ(b)] ⊆ fj and we are done.
By an easy argument using Proposition 3.4.
Suppose aρ(a)fj ⊆ f . Then aaej ⊆ e for some ej ∈ pplyA. Since e is strictly scoped we know that a /f∈a(ej). By Lemma 3.6 also a /f∈a(f j).
Much as the previous case.	2

Restriction to a hereditarily justiﬁed sub-play
The structure of this subsection resembles that of Subsection 3.1. We have a more complex operation than deletion; extracting the hereditarily justiﬁed sub-pointer sequence. In our framework the definition is absolutely routine; we just take a sub-sequence. This is Definition 3.12; then Proposition 3.14 shows how to quickly calculate the relevant sub-sequence using names, and Theorem 3.18 expresses how properties are preserved.
Definition 3.12 Suppose e ∈ pplyA and A ⊆ A. Define the hereditarily justified proto-play eTA ⊆ pplyA as follows, where we take (f, B) = eTA and a ∈ B and aj /B∈ :
εTA = (ε, A)
(e ma[b])TA = (f ma[b], B∪{b}) (e maj[b])TA = (f, B)
Definition 3.13 Suppose e∈pplyA and A⊆A. Define e@A as follows, where a∈A
and aj/A∈(the resemblance with atoms-concretion from [12] is deliberate):
ε@A = ε
(e ma[b])@A = (e@A)ma[b] (e maj[b])@A = e@A
Proposition 3.14 If eTA = (f, B) then e@B = f.

Corollary 3.15 Suppose eTA = (f, B). Then:
If fjma[b] ≤ f then ej exists such that ejma[b] ≤ e and (ejma[b])@B = fjma[b].
If aa[b]fj ⊆ f then ej exists such that aa[b]ej ⊆ e and (aa[b]ej)@B = aa[b]fj.
If qa[b]f2qjb[c]f3ab[d] ⊆ f then e2 and e3 exist such that
(qa[b]e2qjb[c]e3ab[d])@B = qa[b]f2qjb[c]f3ab[d].
Corollary 3.16 If eTA = (f, B) then {mb∈enabled (e) | b∈B} = enabled (f ).
Corollary 3.17 fa(e@B)= fa(e) ∩ B and ca(e@B)= ca(e) ∩ B.
Theorem 3.18 Suppose eTA = (f, B). Then if e is justiﬁed / well-opened / strictly scoped / strictly nested then so is f.
Proof We consider each property in turn:
Justiﬁed.	Using part 1 of Corollary 3.15 and Corollary 3.16.
Well-opened.	Using part 1 of Corollary 3.15.
Strictly scoped.	From part 2 of Corollary 3.15 and Corollary 3.17.
Strictly nested.	From part 3 of Corollary 3.15.	2

Combining arenas
Definition 4.1  (i) Suppose f is a function on a set X and g is a function on a disjoint Y . Write [f, g] for the co-pairing function on X ∪ Y such that [f, g](x)= f (x) and [f, g](y)= g(y) for x ∈ X and y ∈ Y respectively.
(ii) Suppose g is a function to {O, P}. Write g∗ for the function mapping x to g(x)∗
(Definition 2.7).
Definition 4.2 Define product A × B and arrow A ⇒ B of arenas by:
A × B = (qstA+qstB, ansA+ansB, [λA, λB], ▶A + ▶B, iniA+iniB)
A ⇒ B = (qstA+qstB, ansA+ansB, [λ∗ , λB], ▶A + ▶B +iniB × iniA, iniB)
Above, the symbol + denotes disjoint sets union (for convenience assume sets of moves of distinct arenas are distinct), and
iniB×iniA = {(ij, i) | ij∈iniB, i∈iniA}. So ▶A + ▶B +iniB×iniA is the disjoint union of the enabling relations of A and B, disjoint union iniB×iniA.
We show how from proto-plays in A ⇒ B we recover proto-plays in A and
B. This is Lemmas 4.3 and 4.5. These state that two important operations on proto-plays—deletion and unravelling—preserve certain well-formedness properties which define the notion of HO and GM legal plays. These operations are key to formulating composition of strategies, so preservation of legality is essential to show that composition of HO or GM strategies is well-defined.
Lemma 4.3 Suppose e ∈ pplyA⇒B and e]mvsA = (f, ρ). Then f ∈ pplyB. If e is justiﬁed, well-opened, strictly scoped, or strictly nested, then so is f.

Proof For the first part, by Proposition 3.4 f contains only moves in mvsB. The second part follows by Theorem 3.11 and we note that the enabling relation ▶A⇒B restricted to the moves mvsB, is just ▶B.	2
Definition 4.4 Define the unravelling of e ∈ pplyA by unravel (e)= {eT{a}| a ∈
fa(e)}.
Unravelling is key to constructing exponential games [23, Sec 2.4]. Intuitively, in a play in A ⇒ B we can recover one play in B, by deleting the moves of A. Removing the moves in B yields an interleaved set of plays of A. Unravelling separates these plays by following pointers, as illustrated:
T = { , }
It is easy to see that if e is justified then unravel (e) captures the idea of “the set of threads in e”, and if e is additionally well-opened then unravel (e)= {e}.
Lemma 4.5 If e∈pplyA⇒B then unravel (e]B)⊆pplyA. If e is justiﬁed / well-opened
/ strictly-scoped / strictly-nested then so is every f ∈ unravel (e]B).
Proof Directly from Lemma 4.3.	2

Strategies
Strategies and equivariance
Definition 5.1 Call σ ⊆ pplyA equivariant when e ∈ σ implies π·e ∈ σ for every permutation π. Write σ : A when σ is an equivariant subset of pplyA and call σ a strategy.
(The notion of strategy is usually subject to further constraints; these are discussed below.)
Recall deletion e]A from Definition 3.1. We follow [23, Section 2.2.3]:
Definition 5.2 Suppose A, B, and C are arenas on disjoint moves. Then for strategies σ : A ⇒ B and τ : B ⇒ C define their interaction and composition by:
σ||τ = {e ∈ pplyA×B×C | e]C ∈ σ ∧ e]A ∈ τ} σ; τ = {e]B | e ∈ σ||τ}
This is the linear version of strategy composition; exponential games are con- structed using the concept of unravelling introduced earlier (Definition 4.4). The use of proto-plays, which have almost no structure, simplifies the definition of interaction (−||−) compared to the usual definition (c.f. [23, Section 2.2.3]) which needs the auxiliary concept of interaction sequences.
Remark 5.3 Equivariance is symmetry under permuting atoms. Names fulfil the function that links fulfil in e.g. [19,23,14]. Permutative symmetry of strategies amounts to saying ‘we can α-rename’.

So proto-plays do not have α-equivalence in our framework but sets of proto- plays do (cf. [10]). Thus, Theorem 5.4 becomes a one-line argument by symme- try/equivariance. This avoids arguments about α-renaming, reindexing, or re-linking that would be needed if we used numbers or explicitly linked lists. So we have:
Theorem 5.4 Suppose A, B, and C are arenas and σ : A ⇒ B and τ : B ⇒ C are strategies. Then the set σ; τ is equivariant, and thus is a strategy in A ⇒ C.
Proof By Definition 5.1 a strategy is an equivariant set of protoplays, so σ and τ are equivariant. We note that the definitions involved in specifying σ; τ are all symmetric in atoms, and so by assumption are the inputs to those definitions σ and τ , therefore by the principle of equivariance also σ; τ are symmetric. (A formal discussion of equivariance is elsewhere [7, Subsection 4.2].)	2

Associativity of composition
We will prove Theorem 5.5, that composition of strategies is associative:
Theorem 5.5 Suppose A, B, C, and D are arenas on disjoint moves. Suppose
σ : A ⇒ B, τ : B ⇒ C, and μ : C ⇒ D are strategies. Then (σ; τ ); μ = σ; (τ ; μ).
This will follow immediately from Lemma 5.8. For us in this paper strategies are just sets of sequences of moves and names, and the proofs are just by routine induction and name-chasing, that is: unpacking definitions and noting that names end up in the same places on both sides of the equality (see the proof of Proposition 5.6).
Proposition 5.6 Suppose C is an arena and F, Y ⊆ mvsC are two disjoint sets of moves, and e ∈ pplyC. Suppose e]F = (ej, ρ) and ej]Y = (ejj, ρj) and e](F∪Y) = (f, ρjj).
Then f = ejj and ρjj = ρj◦ρ (where ◦ is functional composition, notation from Deﬁnition 2.5).
Proof By induction on e using Definition 3.1.
The case ε    is easy.
The case e ma[b] where m ∈ F. By Proposition 3.4 ej = ρ·e-F and ejj = ρj·ej-Y. It follows that ejj = (ρj◦ρ)·e-(F∪Y). Also by Proposition 3.4 f = ρjj·e-(F∪Y). By inductive hypothesis f = ejj and ρjj = ρj ◦ ρ.
By Definition 3.1 we have that ema[b]]F = (ej, ρ[b:=ρ(a)]) and it follows that π1(ema[b]]F )]Y = (ejj, ρj ◦ (ρ[b:=ρ(a)])). Also, it is a fact of functions that ρj ◦ (ρ[b:=ρ(a)]) = (ρj◦ρ)[b:=(ρj◦ρ)(a)].
Using Definition 3.1 we have that ema[b]](F∪Y)= (f, ρjj[b:=ρjj(a)]), and the result follows.
The case e ma[b] where m ∈ Y.  Similar to the previous case, but simpler.   2
Remark 5.7 Our notion of strategy is simple and it does not rely on a notion of legal play. So to study properties of composition, any strategy over an arena A ⇒ B is also a strategy over an arena A × B, as the two arenas have the same sets of moves—the polarities of the moves and the justification structure are different

between A ⇒ B and A × B, but this information is not used in the definition of composition.
Similarly for defining σ||τ for strategies σ : A ⇒ B and τ : B ⇒ C. An interaction can be viewed as a strategy in (A × B) ⇒ C or A ⇒ (B × C), as convenient. This is correct because interaction preserves equivariance and the sets of moves in these arenas are the same.
Thus we will obtain a particularly simple proof of associativity of interaction, given below.
Lemma 5.8 Suppose σ : A⇒B, τ : B⇒C, and μ : C⇒D are strategies. Then (σ||τ )||μ =
σ||(τ ||μ).
Proof We unpack Definition 5.2 repeatedly: e ∈ (σ||τ )||μ if and only if e]D ∈ σ||τ and e]A×B ∈ μ, if and only if (e]D)]C ∈ σ and (e]D)]A ∈ τ and e]A×B ∈ μ. Using Proposition 5.6 this is equivalent to e]D×C ∈ σ and e]D×A ∈ τ and e]A×B ∈ μ.
By similar reasoning, ej ∈ σ||(τ ||μ) is equivalent to ej]D×C ∈ σ and ej]D×A ∈ τ
and ej]A×B ∈ μ.
The result follows.	2
Preﬁx- and opponent-closed
Just as for proto-plays, GM and HO strategies are subject to constraints. In the rest of this section we sketch, sometimes in detail, how these can be expressed.
Two standard conditions on strategies are being preﬁx-closed and opponent- closed ; see [19, Section 5] (where opponent-closed is called contingent completeness) or [14, Definition 4]. These are straightforward to formalise:
Definition 5.9 Call σ ⊆ pplyA prefix-closed and opponent-closed respectively when:

e ma[b] ∈ σ
e ∈ σ
e ∈ σ	λA(m)=O	e ma[b] ∈ pplyA
e ma[b] ∈ σ

The asynchrony pre-order on proto-plays
In [14] the authors were interested in modelling asynchronous concurrency. Accord- ingly strategies must be saturated under certain move swapping [14, Subsection 2.5] (the idea goes back to [25]).
Definition 5.10 Call a relation ≤ on sequences compatible when e ≤ ej implies ef ≤ ejf and fe ≤ f ej. Define ≤ on pplyA to be the least compatible pre-order such that:

(b /f∈a(e), λA(m)=O)


ma[b] e ≤ e ma[b]
(bmX)
(b /f∈a(e), λA(m)=P)

e ma[b] ≤ ma[b] e
(bXm)

Call σ ⊆ pplyA ≤-saturated when e ∈ σ, ej ∈ pplyA and ej ≤ e imply ej ∈ σ.
Remark 5.11 It may be worth quoting the definition from [14] (text just before Definition 6) for comparison with Definition 5.10:

... we deﬁne a pre-order ≤ on play A for any arena A as the least reflexive and transitive relation satisfying sj ≤ s for all s, sj ∈ play A
sj = s0 · o · s1 · s2 and s = s0 · s1 · o · s2, or
sj = s0 · s1 · p · s2 and s = s0 · p · s1 · s2,
where o is any O move and p is any P move and the justiﬁcation pointers in s are “inherited” from sj ... 
Nominal sequences help make these intuitions formal.
In [14, Lemma 7] a small step version ≤j is given and the equality ≤j=≤ is claimed. With what we have so far, this is a routine inductive argument:
Definition 5.12 Give {O, P} a partial order such that O ≤ O, O ≤ P, and P ≤ P. Define a pre-order ≤j on closed sequences to be the least reflexive transitive relation such that:

(λA(m1) ≤ λA(m2))
m a [b ] m a [b ] ≤j m a [b ] m a [b ] (smm)
(λA(m1) ≤ λA(m2))	(smmj)
m1a[b1] m2a[b2] ≤j m2a[b2] m1a[b1]

Here is the asynchronous swapping rule (smm) interpreted for q1, q2:

a2	b1
a2	b	b1

c

Lemma 5.13 ≤j=≤.
Proof We show ≤j⊆≤ by induction on ≤j:
Rule (smm).	By (bmX) if λA(m1)=O and by (bXm) if λA(m1)=P=λA(m2).
Rule (smmj).	By (bmX) if λA(m1)=O and by (bXm) if λA(m1)=P=λA(m2).
In both cases the side-condition b2 /f∈a(a1a1) is valid. Next we show that ≤⊆≤j by induction on ≤ and the length of e:
Rule (bmX). We use (smm) and (smmj) to swap ma[b] with the leftmost move in
e. The condition b/fa∈(e) matches the distinctness condition b2/∈{a1, ,ab1}.
Rule (bXm). We use (smm) and (smmj) to swap ma[b] with the rightmost move	 in e.	2
Innocence
An important notion in HO games is innocence [19, Definition 5.2], which charac- terises side-effect-free sequential computation. For us this is Definition 5.14 and with the tools we have built so far, it is quite compact: 8
Definition 5.14 Suppose m and mj are named moves (Definition 2.9). Given HO- legal plays emmj, ejm in A, where |emmj| has even length, ca(mj) ∩ atoms(ej)= ∅
8 We use McCusker’s equivalent formulation [23, Subsection 2.2.4].

and pem’ = pejm’, there is a unique renaming ρ = (c '→ cj) with c ∈ fa(mj) and
cj ∈ ca(ej) such that pemmj’ = pejm(ρ·mj)’. Call σ : A innocent when
emmj, ej ∈ σ ∧ ejm HO-legal ∧ pem’ = pejm’ =⇒ ejm(ρ·mj) ∈ σ.
In [19, Definition 5.2] Hyland and Ong must write in English about the manipu- lation of pointers, and that this has to be done throughout their work (and this is typical of similar papers). We propose nominal techniques as a way to deal with this quickly and elegantly.
In HO games, moves can be repeated, which leads to a need to identify particular occurrences of moves in sequences. This goes away in our setting because every question or answer is uniquely identified by a name: the coabstracted name that it introduces. So implicit in our framework is a separation of ‘move’ versus ‘occurrence’, removing a significant source of ambiguity. In this paper we have been able to implicitly identify an occurrence of a move in a proto-play with the named move in which the occurrence appears, since coabstracted atoms in proto-plays are distinct (Definition 2.8).

Conclusions
We have seen how pointer sequences can be modelled as nominal sequences. Pointers are split into a coabstraction [b] corresponding to the head of the arrow, and a (free) atom b corresponding to its tail. Unlike pointers, a name carries its identity with it; b points to [b] wherever we put it.
Furthermore, unlike e.g. numbers, a name is permutatively symmetric, so reindexing / renaming can be expressed at a high level of abstraction. Because of this, nominal sequences are easy to break apart, compose, and reindex.
We have considered some non-trivial operations, like deletion and hereditarily justified sub-sequences; and some important definitions, like strategy composition, asynchronous reordering, and innocence. We have seen how these operations and definitions become straightforward and precise, if we choose the right machinery. This is attractive, but we also believe it will be almost a prerequisite for the kind of mechanised treatment of game semantics that is required for games to be applied in the second author’s research programme.
We have discussed pointer sequences [19,14,23]. In contrast, the Abramsky- Jagadeesan-Malacaria (AJM) games [2] rely on tags instead of pointers. These do not raise the problems of pointers and are fully formalised, but they are a more restricted formalism which was only used for PCF. For languages with effects the flexibility of pointers was required.
Another strategy is to become more abstract: so [5,17,24,21] revise the whole game semantic paradigm per se, in categorical terms. Some readers will instinctively believe that this categorical generalisation obsoletes any concrete realisation, but this is incorrect; there will always be a need for concrete models—especially if we want to implement or mechanise theorems. We seek convenient reformulations of the impressive collection of existing game models to make them more suitable for our

intended applications. The work cited above is complementary, but also orthogonal. Representations of pointer games [18] and games models of nominal languages [20] exist, including work by the second author with others on game semantics for nominal or nominal-related languages [15,1]. However, there has been no nominal representation of pointer sequences themselves. The closest the literature gets is in the Introduction to [24] where Melli`es discusses representing pointers using integer
indexes acted on by two group actions.
There is more to this paper than representing pointers. We use atoms in FM sets, which have structure that ZF sets do not. Functions, predicates, and subsets have symmetry (equivariance) properties and apartness (freshness) structure which make it relatively more convenient to handle distinctness conditions (like in Definition 2.8) or to deduce symmetry properties (as in Theorem 5.4), and so on (a very general treatment is in [6, Section 5]).
In this paper, coabstraction is a syntactic token in sequences. We give a deno- tational intuition how this differs from nominal atoms-abstraction: suppose X is a nominal set with an internal atoms-abstraction [A]X → X written [a]x (for definitions see [12,7]). Suppose R⊆ X × X is a relation on X. Then (briefly) R[A] is the least relation such that if x R y and a#x, R then x R [a]y, and R[a] is the least relation such that if x R y and a#x, R then x R [a]y. This is coabstraction. Nominal terms admit a similar generalisation; we would admit freshness a#X and cofreshness a%X conditions. More on this in a later paper.
We can read this paper as an exciting, if only partially articulated, commentary on semantics. The issue of dangling pointers and compositionality has not been properly addressed in the games literature and it remains to understand where the nominal model will take us. The nominal model of this paper exists in a larger context of nominal sets, substitution models, and some sophisticated logical and semantic theory [7,9], including abstract treatments of metavariables and renaming [8,11] and even e.g. trees with pointers [4]; the fruit of applying this theory, remains to be discovered.
Acknowledgement
The first author acknowledges the support of the Leverhulme trust.

References
	Samson Abramsky, Dan R. Ghica, Andrzej S. Murawski, C.-H. Luke Ong, and Ian D. B. Stark. Nominal games and full abstraction for the nu-calculus. In Proceedings of the 19th IEEE Symposium on Logic in Computer Science (LICS 2004), pages 150–159. IEEE Computer Society Press, 2004.
Samson Abramsky, Radha Jagadeesan, and Pasquale Malacaria. Full abstraction for PCF.
Information and Computation, 163(2):409–470, 2000.
	Samson Abramsky and Guy McCusker. Call-by-value games. In Proceedings of Computer Science Logic (CSL’97), volume 1414 of Lecture Notes in Computer Science, pages 1–17, 1998.
Luca Cardelli, Philippa Gardner, and Giorgio Ghelli. Manipulating trees with hidden labels. In Proceedings of the 6th international conference on Foundations of software science and computational structures (FoSSaCS 2003), pages 216–232, 2003.

	Vincent Danos and Russell Harmer. The anatomy of innocence. In Proceedings of the 10th EACSL Annual Conference on Computer Science Logic (CSL 2001), pages 188–202, 2001.
	Murdoch J. Gabbay. A General Mathematics of Names. Information and Computation, 205(7):982–1011, July 2007.
Murdoch J. Gabbay. Foundations of nominal techniques: logic and semantics of variables in abstract syntax. Bulletin of Symbolic Logic, 17(2):161–229, 2011.
Murdoch J. Gabbay. Meta-variables as infinite lists in nominal terms unification and rewriting.
Logic Journal of the IGPL, 2012.
Murdoch J. Gabbay. Nominal terms and nominal logics: from foundations to meta-mathematics. In Handbook of Philosophical Logic, volume 17. Kluwer, 2012.
	Murdoch J. Gabbay and Vincenzo Ciancia. Freshness and name-restriction in sets of traces with names. In Foundations of software science and computation structures, 14th International Conference (FOSSACS 2011), volume 6604 of Lecture Notes in Computer Science, pages 365–
380. Springer, 2011.
	Murdoch J. Gabbay and Martin Hofmann. Nominal renaming sets. In Proceedings of the 15th International Conference on Logic for Programming, Artiﬁcial Intelligence, and Reasoning (LPAR 2008), pages 158–173. Springer, November 2008.
	Murdoch J. Gabbay and Andrew M. Pitts. A New Approach to Abstract Syntax with Variable Binding. Formal Aspects of Computing, 13(3–5):341–363, July 2001.
	Dan R. Ghica. Applications of game semantics: From software analysis to hardware synthesis. In Proceedings of the 24th IEEE Symposium on Logic in Computer Science (LICS 2009), pages 17–26, 2009.
	Dan R. Ghica and Andrzej Murawski. Angelic semantics of fine-grained concurrency. Annals of Pure and Applied Logic, 151(2-3):89–114, 2008.
	Dan R. Ghica and Andrzej S. Murawski. Compositional model extraction for higher-order concurrent programs. In Tools and Algorithms for the Construction and Analysis of Systems (TACAS 2006), pages 303–317, 2006.
	Dan R. Ghica and Nikos Tzevelekos. A system-level semantics. Electronic Notes in Theoretical Computer Science (to appear). Mathematical Foundations of Computer Science XXVIII, Bath, UK, 2012.
	Russell Harmer, Martin Hyland, and Paul-Andr´e Melli`es. Categorical combinatorics for innocent strategies. In Proceedings of the 22nd IEEE Symposium on Logic in Computer Science (LICS 2007), pages 379–388. IEEE Computer Society, 2007.
	Martin Hyland and C.-H. Luke Ong. Pi-calculus, dialogue games and PCF. In FPCA, pages 96–107, 1995.
	Martin Hyland and C.-H. Luke Ong. On full abstraction for PCF: I, II, and III. Information and Computation, 163(2):285–408, 2000.
	Jim Laird. A game semantics of names and pointers. Annals of Pure and Applied Logic, 151(2- 3):151–169, February 2008. First Games for Logic and Programming Languages Workshop.
	Jim Laird, Giulio Manzonetto, and Guy McCusker. Constructing differential categories and deconstructing categories of games. In Luca Aceto, Monika Henzinger, and Jiri Sgall, editors, ICALP (2), volume 6756 of Lecture Notes in Computer Science, pages 186–197. Springer, 2011.
	Ondrej Majer, Ahti-Veikko Pietarinen, and Tero Tulenheimo. Games: Unifying Logic, Language, and Philosophy. Springer, 2009.
	Guy McCusker. Games and full abstraction for FPC. Information and Computation, 160(1- 2):1–61, 2000.
	Paul-Andr´e Melli`es. Asynchronous games 2: The true concurrency of innocence. In Proceedings of the 15th International Conference on Concurrency Theory (CONCUR 2004), pages 448–465, 2004.
	Jan Tijmen Udding. A formal model for defining and classifying delay-insensitive circuits and systems. Distributed Computing, 1(4):197–204, 1986.
	Christian Urban. Nominal reasoning techniques in Isabelle/HOL. Journal of Automatic Reasoning, 40(4):327–356, 2008.
