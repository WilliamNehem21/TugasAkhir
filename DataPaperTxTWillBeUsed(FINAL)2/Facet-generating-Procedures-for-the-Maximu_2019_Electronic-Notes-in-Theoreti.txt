Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 346 (2019) 199–208
www.elsevier.com/locate/entcs

Facet-generating Procedures for the Maximum-impact Coloring Polytope
Monica Bragaa,1 Javier Marencoa,2
a Sciences Institute
National University of General Sarmiento Buenos Aires, Argentina

Abstract
Given two graphs G = (V, EG) and H = (V, EH ) over the same set of vertices and given a set of colors C, the impact on H of a coloring c : V → C of G, denoted I(c), is the number of edges ij ∈ EH such that c(i) = c(j). In this setting, the maximum-impact coloring problem asks for a proper coloring c of G maximizing the impact I(c) on H. This problem naturally arises in the context of assigning classrooms to courses, where it is desirable –but not mandatory– to assign lectures from the same course to the same classroom. We are interested in an integer programming approach for this problem. In this work we present two procedures that construct valid inequalities from existing inequalities, based on extending individual colors to sets of colors and on extending edges of G to cliques, respectively. If the original inequality defines a facet and additional technical hypotheses are satisfied, then the obtained inequality also defines a facet. We present a generic separation algorithm based on these procedures, and report computational experiments showing that this approach is effective.
Keywords: coloring, integer programming, facet-generating procedures.


Introduction
A recurring problem in course scheduling consists in determining which classrooms are to be assigned to each lecture of each course, in such a way that overlapping lectures receive different classrooms [4], where the starting and ending times of each lecture are given as part of the input. This situation is usually modeled by an undi- rected graph G = (V, EG), whose vertices represent the lectures and whose edges join pairs of lectures that cannot receive the same classroom since the corresponding time intervals have nonempty intersection, and by a set C of classrooms. The graph G is usually referred to as the conflict graph associated with the lectures. This prob- lem corresponds to the classical graph vertex coloring problem, as any C-coloring

1 Email: mbraga@campus.ungs.edu.ar
2 Email: jmarenco@campus.ungs.edu.ar

https://doi.org/10.1016/j.entcs.2019.08.018
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

c (i.e., an assignment c : V → C such that c(i) /= c(j) whenever ij ∈ EG) corre- sponds to a feasible assignment of classrooms to lectures. Note that this problem is feasible if and only if |C| ≥ χ(G), where the chromatic number χ(G) represents the minimum number of colors in any feasible coloring of G.
A usual requirement in practical environments asks for all the lectures from the same course to be assigned to the same classroom. However, this requirement is not strict, and it can be violated if not enough classrooms are available. In order to take this requirement into account, the following combinatorial optimization problem was proposed in [1]. In addition to G, we have a second graph H = (V, EH ) defined over the same set of vertices, in such a way that ij ∈ EH if and only if i and j are lectures from the same course. We assume EG ∩ EH = ∅. If c is a coloring of G, we define the impact of c on H to be I(c) = |{ij ∈ EH : c(i) = c(j)}|, i.e., the number of edges from H whose endpoints receive the same color. Given two graphs G = (V, EG) and H = (V, EH ) with EG ∩ EH = ∅ and a set C of colors, the maximum-impact coloring problem (MICP) consists in finding a C-coloring of G maximizing the impact on H. MICP is NP-hard [5], even when restricting G to be an interval graph and H to be the union of disjoint cliques [1].
In the context of course timetabling, many real-life requirements and rules arise and particular constraints are imposed in order to obtain practical solutions. Several formulations and techniques for the classical vertex coloring problem were applied in a wide range of publications (see, e.g., [2,3,6,12]). Additionally, some of these applications have given place to scheduling software as in [7,8]. In [9,10] a method based on constraint branching is developed with the aim of reducing the problem size while attempting to retain the best solutions, and it is applied to real instances. In [11], the performance of SAT solvers is compared with standard integer program- ming techniques for a classroom assignment problem.
Since integer programming techniques have shown to be quite successful for the classical vertex coloring problem and for similar scheduling and timetabling prob- lems, in [1] we proposed to tackle MICP with such techniques. We presented a natural integer programming formulation for MICP and identified several families of facet-inducing inequalities that turned out to be successful at enhancing the per- formance of a branch and cut procedure. Many of these families of valid inequalities are based on similar ideas and, consequently, the corresponding proofs of facetness resort to similar arguments. Moreover, similar ideas are present in the separation procedures associated with each family. These observations suggest the existence of general results explaining the facetness properties of the identified inequalities, and the design of a unified separation framework for them.
In this work we explore these issues, by presenting two validity- and facetness- preserving procedures, that construct valid inequalities from existing inequalities, enlarging their supports in the process. We also introduce a generic separation algorithm based on these procedures, which starts from a set of inequalities with small supports and seeks to apply these procedures in order to obtain cuts with supports as large as possible. We present computational experiments suggesting that this approach may be competitive with respect to the application of individual

separation algorithms for each family of valid inequalities.
This paper is organized as follows. Section 2 presents the integer programming formulation for MICP. Section 3 presents the two procedures for constructing valid inequalities. Finally, Section 4 reports our computational experiments, and Sec- tion 5 includes concluding remarks and ideas for future work.
Integer programming formulation
The following integer programming formulation for MICP, introduced in [1], is based on the standard model for vertex coloring. For i ∈ V and c ∈ C, we define the binary assignment variable xic to be xic = 1 if the vertex i is assigned the color c, and xic = 0 otherwise. For every ij ∈ EH with i < j we define the binary impact variable yij to be yij = 0 if the vertices i and j are assigned different colors. For ij ∈ EH , i < j, we define yji = yij as a notational convenience. In this setting, MICP can be formulated as follows.

max	Σ
ij∈EH ,i<j
yij

(1) s.t.	Σ xic =1	∀i ∈ V

The objective function asks for the total impact to be maximized. Constraints
(1) and (2) ensure that the x-variables define a proper vertex coloring of G, whereas constraints (3) and (4) force yij =0 if i and j receive different colors (if, e.g., xjc =1 and xic′ = 1 for cj /= c, then (3) implies yij = 0). We do not impose constraints forcing yij to take value 1 if i and j get the same color, since in any optimal solution this situation is guaranteed, and this property makes the resulting polytope much easier to study. Finally, constraints (5) and (6) ask the variables to be binary.
Definition 2.1 [maximum-impact coloring polytope] Given two graphs G = (V, EG) and H = (V, EH ) with EG ∩ EH  = ∅ and a finite set C, we de- fine PMIC(G, H, C) ⊆ R|V ||C|+|EH| to be the convex hull of the points (x, y) ∈ R|V ||C|+|EH| satisfying constraints (1)-(6).
Facet-preserving procedures
We introduce in this section the two validity- and facetness-preserving procedures for PMIC(G, H, C). As mentioned before, several families of facet-inducing inequalities for PMIC(G, H, C) are based on similar ideas, and the following family provides an example of this situation.

Definition 3.1 [1] Let ij ∈ EH and let D be a proper nonempty subset of colors. We define
(7)	yij ≤ Σ xid + Σ xjd
d∈/D	d∈D
to be the partitioned inequality associated with ij and D.
Inequality (7) asserts that yij must take value 0 if i is assigned a color from D (hence the first summation in the RHS is null) and j is assigned a color from C\D (hence the second summation in the RHS is null). The partitioned inequalities are facet-defining if |C| ≥ χ(G) + 1, and provide a generalization of the model constraints yij ≤ 1 − xic + xjc, for ij ∈ EH and c ∈ C, by considering the set D of colors instead of a single color c. This construction appears in several families of facet-inducing inequalities found in [1], suggesting that it could be turned into a general procedure that generates a valid inequality from a previous inequality by replacing the x-variables associated with a color c by the x-variables associated with a set of colors D. Procedure 1 tackles this issue.
If (x, y) ∈ PMIC(G, H, C ∪ D) is a feasible solution, where C and D are two disjoint sets, we define xC to be the projection of x onto the variables associated with colors in C, i.e., xC = (xvc)v∈V,c∈C. We say that the colors in C are consecutive if there is a linear ordering among them. This is satisfied if, e.g., C = {1,..., |C|}.
Procedure 1 Let πx + μy ≤ π0 be a valid inequality for PMIC(G, H, C). Fix c ∈ C, let D be a nonempty set of consecutive colors such that C ∩ D = ∅, and deﬁne Cj = (C\{c}) ∪ D. Deﬁne A and B to be the sets A = {v ∈ V : πvc /= 0} and B = {v ∈ V : μvw /= 0 for some w ∈ V }. Finally, for any feasible solution (x, y) ∈ PMIC(G, H, C ∪ D), deﬁne I(x, y)= {i ∈ A ∪ B : yij =1 for some j ∈ B}. Assume that

for every (x, y) ∈ PMIC
(G, H, Cj) ∩ Z|V ||C′|+|EH|, I(x, y) induces a stable set in

G,
for every i ∈ A ∪ B, if there exist (x, y) ∈ PMIC
(G, H, Cj) ∩ Z|V ||C′|+|EH| and

a maximal independent set Ij in A ∪ B such that I(x, y) ⊆ Ij and i ∈/ Ij, then
πic ≤ 0, and
πxC + μy ≤ π0 is valid for PMIC(G, H, C ∪ D).
In this setting, the procedure generates the inequality

(8)
Σ Σ πicxid + Σ Σ πidxid + Σ
μijyij  ≤ π0,

i∈A d∈D
for the instance (G, H, Cj).
i∈V d/∈D
ij∈EH

The application of Procedure 1 to the model constraint yij ≤ 1 − xic + xjc, for ij ∈ EH and c ∈ C provides the partitioned inequality (7), when replacing c by the set D of colors and combining the obtained inequality with the model constraint
(1). In this case we have A = B = {i, j} with ij ∈ EH , hence the hypotheses (i) and (ii) of the procedure are trivially satisfied. Note that under the construction specified by Procedure 1, the inequality (7) is valid for an instance whose color set

includes D. The following results also imply that the obtained inequality (7) is valid and facet-inducing.
Theorem 3.2 If the hypotheses of Procedure 1 hold, then the inequality (8) is valid for PMIC(G, H, Cj).
The proof of Theorem 3.2 takes an arbitrary feasible solution of PMIC(G, H, Cj) and constructs an associated feasible solution in PMIC(G, H, C∪D) keeping the LHS of (8) either unchanged or at a smaller value. The validity of the original inequality is then applied in order to ensure that the new point satisfies (8).
Theorem 3.3 If the hypotheses of Procedure 1 hold, χ(G) < |C|, and πx + μy ≤ π0
induces a facet of PMIC(G, H, C), then (8) induces a facet of PMIC(G, H, Cj).
The proof of Theorem 3.3 consists in taking a set of affinely independent points showing that the face of P (G, H, C) induced by πx + μy ≤ π0 is indeed a facet, and constructs a suitable number of affinely independent points satisfying (8) with equality.
The second procedure generates valid inequalities from inequalities with smaller supports by replacing an edge of the graph by a clique. Specifically, if ij ∈ EG and c ∈ C, then we replace the variables xic and xjc by the variables {xkc}k∈K, where K is a clique including ij, and we perform a similar operation on the y-variables incident to i and j. This allows, e.g., to obtaing the following inequalities.
Definition 3.4 [1] Let K ⊆ V be a clique in G and let i ∈ V \K such that ik ∈ EH
for all k ∈ K. Let D ⊆ C such that |D|≤ |C|− |K|. We define
(9)	Σ yik ≤ Σ Σ xkd + Σ xid

k∈K
d∈D k∈K
d∈/D

to be the clique-partitioned inequality associated with the clique K, the vertex i, and the color set D.
Since K is a clique, at most one vertex from K can be assigned the same color as i, so at most one variable in {iik}k∈K can take value 1. The clique-partitioned inequality (9) asserts that yik = 0 for every k ∈ K if i is assigned a color from D (hence the second summation in the RHS of (9) is null) and every vertex in K is assigned a color from C\D (hence the first summation in the RHS is null). This inequality is valid, and is also facet-inducing under simple technical conditions [1]. We first provide some definitions. If i ∈ V , define NG(i)= {j ∈ V : ij ∈ EG} and NH (i)= {j ∈ V : ij ∈ EH}. For p ≥ 1, we define G[i, p]= (V ∪ {i1,..., ip}, Ej ) to be the graph obtained from G by adding p new vertices (i.e., i1,..., ip /∈ V ) in such

a way that the vertices i, i1,... ip are true twins. In other words, Ej
is obtained

by adding an edge between it and j, for every j ∈ NG(i) ∪ {i} and t = 1,...,p 
and between the new vertices, i.e., Ej  = EG ∪ {itj : j ∈ NG(i) ∪ {i} and t =
1,..., p}∪ {ijik : j, k ∈ {1,..., p}}. We also define H(i, p)= (V ∪ {i1,..., ip}, Ej ) to be the graph obtained from G by adding p new vertices (i.e., i1,..., ip /∈ V )
in such a way that the vertices i, i1,... ip are false twins. In other words, Ej  is

obtained by adding an edge between it and j, for every j ∈ NH (i) and t = 1,..., p,
i.e., Ej = EH ∪ {itj : j ∈ NH (i) and t = 1,..., p}.
Procedure 2 Let πx+μy ≤ π0 be a valid inequality for PMIC(G, H, C). Fix ij ∈ E such that i and j are true twins in G and such that NH (i)= NH (j)= {l}. Fix also c ∈ C. Assume that
πic = πjc /=0 and πid = πjd =0 for every d /= c,
μil = μjl, and
πxC + μy ≤ π0 is valid for PMIC(G, H, C ∪ D), where D = {d1,..., dp+1} and
D ∩ C = ∅.
Deﬁne K = {i, j}∪{i1,..., ip}. In this setting, the procedure generates the inequality


(10)
Σ πicxkc + Σ
Σ πtdxtd + Σ μklykl +	Σ


μuvyuv  ≤ π0,

k∈K
t∈V \K d∈C
k∈K
uv∈EH \{il,jl}

for the instance (G[i, p],H(i, p),C ∪ D).
Again, Procedure 2 preserves validity and facetness of the original inequality. The proofs of Theorem 3.5 and Theorem 3.6 follow similar lines as the corresponding statements for Procedure 1.
Theorem 3.5 If the hypotheses of Procedure 2 hold, then the inequality (10) is valid for the polytope PMIC(G[i, p],H(i, p),C ∪ D).
Theorem 3.6 If the hypotheses of Procedure 2 hold, χ(G) < |C|, and πx + μy ≤ π0 induces a facet of P (G, H, C), then the inequality (10) deﬁnes a facet of P (G[i, p],H(i, p),C ∪ D).
The clique-partitioned inequality (9) is obtained by applying Procedure 1 and Procedure 2 to the inequality xic + yij + yik ≤ 1+ xjc + xkc, for ij, ik ∈ EH and jk ∈ EG, which is valid and facet-inducing if |C| > χ(G) + 1. To this end, we first apply Procedure 2 in order to replace the edge jk by a clique K, thus obtaining
(11)	xic + Σ yit ≤ 1+ Σ xtc.
t∈K	t∈K
We next apply Procedure 1 to (11) in order to replace the color c by the set D of colors. By combining the obtained inequality with the model constraint (1), we get the clique-partitioned inequality (9), which is thus valid and facet-inducing for P (G[i, p],H(i, p),C ∪ D) if |C| + |D| > χ(G)+ p + 1.
Computational experiments
Procedure 1 and Procedure 2 provide tools for constructing valid inequalities with potentially large supports starting from inequalities with small supports, and also preserve facetness when the right hypotheses are satisfied. This suggests a simple heuristic for trying to find violated valid inequalities within a cutting plane environ- ment: start from a violated or “almost violated” small inequality, and then greedily

try to enlarge the support of the inequality by using the procedures presented in the previous section. If the resulting inequality is violated, then it can be added as a cut. In this section, we explore the design of a cut-generating computational procedure based on these ideas.
The separation procedure has a pool of generic valid inequalities for P (G, H, C), which we propose to call templates. In this setting, templates are very simple inequalities with small supports, that are used as starting points of the search for cuts. In our implementation, we resort to the following pool of templates:
the model constraint yij ≤ 1+ xic − xjc, for ij ∈ EH and c ∈ C,
the edge inequality xic + xjc ≤ 1, for ij ∈ EG and c ∈ C,
the vertex-clique inequality yij + yik ≤ 1 for i, j, k ∈ V such that jk ∈ EG and
ij, ik ∈ EH ,
the semi-triangle inequality yij ≤ 2+ (xjc − xic)+ (xid − xjd) − (xkc − xkd) for
i, j, k ∈ V such that ik, jk ∈ EG and ij ∈ EH , and for c, d ∈ C, c /= d,
the semi-diamond inequality yij +2yik ≤ 3+(xkc+xjc−xic)+(xid−xkd)+(xke− xie) − (xld + xle) for i, j, k, l ∈ V such that jk, jl, kl ∈ EG and ij, ik ∈ EH , and for c, d, e ∈ D, c /= d, c /= e, d /= e.
Given a fractional solution (x∗, y∗) ∈ P (G, H, C), the separation procedure first employs a backtracking algorithm in order to detect violated and “almost violated” instances of these templates. To this end, the vertices and the colors present in the template definition are matched against all possible vertices and colors satis- fying the template hypotheses, and all violated and “almost violated” inequalities are identified. Since the templates involve small supports, such a bracktracking procedure is not computationally expensive. An inequality πx + μy ≤ π0 is almost violated by (x∗, y∗) if π0 − ε ≤ πx∗ + μy∗ ≤ π0, for some small ε. We have used ε = 0.25 in our experiments.
Each valid inequality thus found is then subjected to Procedures 1 and 2. We greedily apply these procedures in order to enlarge the support of the obtained inequalities. The theoretical formulation of both procedures generates a valid in- equality for a modified instance of the problem, namely the instance with color set (C\{c}) ∪ D in Procedure 1 and the instance (G[i, p],H(i, p),C ∪ D) in Pro- cedure 2. However, in our implementation we keep the instance fixed and execute the procedures with properly-constructed sub-instances of the original instance as follows. When applying both procedures, we take C to be the set of colors present in the support of the inequality, and we take D to be the remaining set of colors. Furthermore, when applying Procedure 2 we take as the input graph the subgraph of G induced by the support of the inequality, and instead of enlarging an edge into a clique, we search for cliques (in the whole graph) including existing edges. This allows for a fast implementation with no need of modifying the graph and the variable set.
The resulting procedure can potentially generate cuts coming from the families of valid inequalities presented in [1] (although it is not guaranteed that cuts coming


Table 1
Time to optimality and nodes in the enumeration tree for Cplex as a black-box solver (columns labeled “Cplex 12.5”), for the branch and cut presented in [1] (columns labeled “Cplex + cuts [1]”), and for a branch and cut using the cut-generating procedure presented in this section (columns labeled “This work”), respectively. For the instance marked with “*”, Cplex reached the memory limit of 1GB. For the instance marked with “**”, Cplex reached the time limit of 1 hour.






from every such family will eventually be generated). In contrast, the branch and cut procedure presented in [1] resorts to a tailored separation procedure for each family of valid inequalities. We compared both approaches within the same imple- mentation, in order to assess the computational effectiveness of the single procedure proposed in this section.
Table 1 shows running times for a set of instances coming from a real setting. The implementation was performed within the Cplex 12.5 environment, and the experiments were carried out on a computer with an Intel Core 2 Duo CPU, with two T8100 cores running at 2 GHz, and 2 GB of RAM memory. We have kept all Cplex parameters at their default values. This table shows the improvement achieved when the separation procedures considered in [1] are employed, and also shows that the performance of the single procedure presented in this work is quite competitive with respect to these results. The branch and cut procedure employed in [1] is not able to solve the last two instances, due either to time limits or memory constraints.
Table 2 compares the number of cuts generated in each case. It is interesting to note that the procedure presented in this work finds a much smaller number of cuts, while obtaining a similar performance. This is due to the fact that the separation procedure for the semi-diamond inequalities used in [1] generates many inequalities. A better tuning of this procedure may generate a smaller number of cuts coming from this family, thus making the difference in the number of cuts less important. Nevertheless, it is not clear whether such a better tuning may be attained without resorting to the techniques presented in this work.


Table 2
Number of cuts found by Cplex (column labeled “Cplex 12.5”), found by individual separation procedures for each family of valid inequalities (column labeled “Cplex + cuts [1]”), and by the procedure presented in this section (column labeled “This work”), respectively.
Conclusions
From a theoretical point of view, it is interesting to provide a unified framework ex- plaining many families of facet-inducing inequalities. The facetness proofs provided in [1] contain similar ideas that are repeated many times and that are applied almost with no variations in different proofs, so the facet-preserving procedures presented in this work allow for more elegant proofs of these results. From a practical point of view, our computational experiments show that –at least for the instances consid- ered in this work– it is not necessary to resort to a particular separation procedure for each family of valid inequalities, and that a single cut-generating procedure based on the ideas presented in this work allows to obtain similar computational results instead. This is interesting when implementing a branch and cut procedure, since only one separation procedure must be implemented, and the templates considered in such a procedure can be easily configured. As future work, we plan to extend this experimentation to further instances of MICP.
The facet-generating procedures and the separation algorithm presented in this work can be applied to the standard formulation of the classical vertex coloring formulation. In this case, we must ignore the y-variables in the procedures. It would be interesting to explore whether these ideas can be further refined for the classical vertex coloring problem, in order to get more precise procedures and a more efficient (unified) separation heuristic. It would also be interesting to consider similar facet-preserving procedures for other problems, as these ideas may contribute to provide simpler explanations of existing facets and simpler implementations of cutting-plane-based procedures.

References
Braga, M., D. Delle Donne, R. Linfati, and J. Marenco, The maximum-impact coloring polytope, Intl. Trans. in Op. Res. 24 (2017), 303–324, URL: https://doi.org/10.1111/itor.12265.

Burke, E., J. Mareˇcek, A. Parkes, and H. Rudov´a, A branch-and-cut procedure for the Udine course timetabling problem, Annals of Operations Research 194 (2012), 71–87.
Daskalaki, S., T. Birbas, and E. Housos, An integer programming formulation for a case study in university timetabling, European Journal of Operational Research 153 (2004), 117–135.
De Werra, D., An introduction to timetabling, European Journal of Operational Research 19-2 (1985), 151–162.
Garey, M., and D. Johnson, “Computers and intractability: A guide to the theory of NP-completeness”,
W. H. Freeman, 1979.
Lach, G., and M. Lu¨bbecke, Curriculum based course timetabling: new solutions to Udine benchmark instances, Annals of Operations Research, vol. 194, pp. 255–272, 2012.
Miranda, J., eClasSkeduler: A course scheduling system for the Executive Education Unit at the Universidad de Chile, Interfaces 40-3 (2010), 196–207.
Mooney, E., R. Rardin, and W. Parmenter, Large-scale classroom scheduling, IIEE transactions 28-5
(1996), 369–378.
Phillips, A., D. Ryan, and M. Ehrgott, Solving the classroom assignment problem using integer programming, Proceedings of the 2013 Joint NZSA+ORSNZ Conference, 2013.
Phillips, A., H. Waterer, M. Ehrgott, and D. Ryan, Integer programming methods for large-scale practical classroom assignment problems, Computers & Operations Research 53 (2015), 42–53.
Wasfy, A., and F. Aloul, Solving the university class scheduling problem using advanced ILP techniques, Proceedings of the 4th IEEE GCC Conference, 2007.
Waterer, H., A zero-one integer programming model for room assignment at the University of Auckland, Proceedings of the 1995 ORSNZ Conference, 1995.
