	Electronic Notes in Theoretical Computer Science 210 (2008) 123–137	
www.elsevier.com/locate/entcs

On a Fully Abstract Model for a Quantum Linear Functional Language
(Extended Abstract)
Peter Selinger1 ,2
Dalhousie University, Halifax, Nova Scotia, Canada
Benoˆıt Valiron3
University of Ottawa, Ottawa, Ontario, Canada

Abstract
This paper studies the linear fragment of the programing language for quantum computation with classical control described in [4]. We sketch the language, and discuss equivalence of terms. We also describe a fully abstract denotational semantics based on completely positive maps.
Keywords: Quantum computing, functional programming, linear lambda calculus, higher order, semantics.


Introduction
This work studies a linear functional programming language for quantum compu- tation with classical control, derived from the language in [4].
The first denotational semantics of a quantum programming language was given by the first author in [3], for the quantum flowchart language QFC. The semantics given there was compositional and took place in a category of superoperators, which are special completely positive maps. However, the language lacked a crucial feature found in functional programming languages, namely, the notion of higher-order functions.

1 Research supported by NSERC.
2 Email: selinger@mathstat.dal.ca
3 Email: bvali087@uottawa.ca

1571-0661 © 2008 Peter Selinger. Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.022

In [4], we sought to address this omission by introducing a typed lambda cal- culus for quantum computation. This language resembles QFC in that it combines quantum and classical data types with classical control features, but it also includes lambda abstractions and therefore function closures. The problem of deciding the duplicability of data was solved syntactically, by giving a type system that distin- guishes duplicable and non-duplicable types. The quantum lambda calculus pos- sesses a reduction semantics, but no denotational semantics has been given for it so far.
In this paper, we study the restriction of the quantum lambda calculus to the purely linear case. This means we study the fragment of the language where each value, classical and quantum, must be used exactly once. The linear quantum lambda calculus differs from its nonlinear cousin in that it is less sensitive to the evaluation order of terms. We give a denotational semantics for this language in a category of completely positive maps, and we show that it is fully abstract with respect to the operational semantics.
The question of finding a denotational semantics for the full quantum lambda calculus is still open, but we hope that this work is a step in that direction.
The plan of the paper is as follows. First we briefly describe the language and the type system. Then we develop an operational semantics for it, and we define a notion of equivalence of terms. Finally we build a denotational semantics for the language, and we show the full abstraction result.

A linear lambda-calculus for quantum computation
In [4], we have defined an operational semantics for a lambda calculus for quantum computation with classical control. Here, we study the purely linear fragment of this language. We begin by re-adapting the definitions and results from this earlier paper for the linear setting.
Terms and Programs
Definition 2.1 The linear quantum lambda calculus has the following terms:
M, N, P ::= x | MN | λx.M | if M then N else P | 0 | 1 | new | meas | U |
∗ | ⟨M, N ⟩| let ⟨x, y⟩ = M in N | let ∗ = M in N | Ω.
Here 0 and 1 are the Booleans constants, new and meas are operations that create and measure a quantum bit, respectively, U ranges over a given family of unitary operations, and Ω is a non-terminating term. We follow Barendregt’s convention for identifying terms up to α-equivalence [1]. The set of free variables of a term M is written FV (M ). We also sometimes use the shorthand notation ⟨M1,... , Mn⟩ =
⟨M1, ⟨M2,... ⟩⟩. In the following, we often write c for an arbitrary constant of the language, i.e., 0, 1, meas , new , U , or ∗.
The set of types is defined by
A, B ::= bit | qbit | A  B |T| A ⊗ B.



x : A D x : A (ax 1)	D c : Ac (ax 2) Γ1 D P : bit	Γ2 D M : A	 Γ2 D N : A (if )
Γ1, Γ2 D if P then M else N : A
Γ1 D M : A  B	Γ2 D N : A (app)	Δ,x : A D M : B





(λ)

Γ1, Γ2 D MN : B
Γ1 D M1 : A1	Γ2 D M2 : A2
Δ D λx.M : A  B
(⊗.I)		 (T.I)

(Ω)

Γ1, Γ2 D ⟨M1, M2⟩ : A1 ⊗ A2
D ∗ : T
Δ D Ω: A

Γ1 D M : A1 ⊗ A2	Γ2, x1:A1, x2:A2 D N : A (⊗.E)
Γ1, Γ2 D let ⟨x1, x2⟩ = M in N : A
 Γ1 D M : T	Γ2 D N : A  (T.E)
Γ1, Γ2 D let ∗ = M in N : A

Table 1
Typing rules for the linear quantum lambda calculus
Note that, unlike the language of [4], there is no type constructor !A. We use the same shortcut for the product type as we did for the product term, to define A ⊗ ... ⊗ A. To each constant term c, we associate a fixed type Ac, namely meas : qbit  bit , 0, 1 : bit , new : bit  qbit , ∗ : T and U : qbit ⊗n  qbit ⊗n. A typing judgement is a triple Δ D M : A, where Δ is a list of distinct typed variables called a typing context, M is a term, and A is a type. We say that a typing judgement is valid if it follows from the typing rules given in Table 1.
Although this language is intended to manipulate quantum information, no con- stants of type qbit are provided in the definition of lambda-terms. Indeed, while it would be possible to allow constant qubit expressions such as α|0⟩ + β|1⟩, such a notation would not lend itself to expressing entangled states. Instead, we intro- duce the concept of a quantum array and a linking function to express terms with embedded quantum data.
Definition 2.2 A quantum closure is a triple [Q, L, M ] where Q is a normalized
vector in ⊗n  C2, for some n ≥ 0, L is a bijective function from a set |L| of term
variables to {0,... ,n − 1}, and M is a term. Q is called a quantum array, and L is called a linking function. We write |Q| = n. If L(xi)= i, we will sometimes write L as the ordered list |x1 ··· xn⟩. The idea is that the variable xi is bound in the term M to qubit number L(xi) of the state Q. We also call the pair (Q, L) a quantum context.
We extend the notion of α-equivalence to quantum closures: [Q, |x ··· y ··· z⟩,M ] =α [Q, |x ··· y' ··· z⟩,M [y'/y]]
if y' /∈ FV (M ) ∪ {x,... , y,... , z}.
Definition 2.3 A quantum closure [Q, L, M ] is well-typed (or valid ) of type A


[Q, L, Ω] →ω [Q, L, Ω]	[Q, L, (λx.M )V ] →β [Q, L, M [V /x]]
1	1
[Q, L, let ⟨x1, x2⟩ = ⟨V1, V2⟩ in N ] →let [Q, L, N [V1/x1, V2/x2]] [Q, L, let ∗ = ∗ inN ] →let∗ [Q, L, N ]
[Q, L, if 0 then M else N ] →if 0 [Q, L, N ]
[Q, L, if 1 then M else N ] →if 1 [Q, L, M ]

[Q, L, N ] →κ [Q', L',N ']

[Q, L, MN ] →κ [Q', L',MN ']
[Q, L, M1] →κ [Q', L',M ' ]
[Q, L, M ] →κ [Q', L',M ']

[Q, L, MV ] →κ [Q', L',M 'V ]
[Q, L, M2] →κ [Q', L',M ' ]

p	1	p	2
[Q, L, ⟨M1, M2⟩] →κ [Q', L', ⟨M ' , M2⟩]	[Q, L, ⟨V1, M2⟩] →κ [Q', L', ⟨V1,M ' ⟩]
p	1	p	2
[Q, L, P ] →κ [Q', L',P ']
[Q, L, if P then M else N ] →κ [Q', L', if P ' then M else N ] [Q, L, M ] →κ [Q', L',M ']
[Q, L, let ⟨x1, x2⟩ = M in N ] →κ [Q', L', let ⟨x1, x2⟩ = M ' in N ]
[Q, L, M ] →κ [Q', L',M ']

[Q, L, let ∗ = M in N ] →κ [Q', L', let ∗ = M ' in N ]
Table 2
Reduction rules for the quantum lambda calculus

in the typing context Γ, written Γ ▶ [Q, L, M ] : A, if |L| ∩ |Γ| = ∅, FV (M ) \
|Γ| ⊆ |L|, and Γ,x1:qbit,... , xk:qbit D M : A is a valid typing judgement, where
{x1,... , xk} = FV (M ) \ |Γ|.
A well-typed quantum closure is closed if |Γ| = ∅, and a closed well-typed quantum closure is also called a program.

Operational semantics
Small step semantics
The language contains a probabilistic operation: the measurement. This probabilis- tic operation forces us to choose a reduction strategy.
Definition 3.1 We define the call-by-value reduction strategy for the linear quan- tum lambda calculus by structural induction. For this purpose we need the notion of a value. We define a value term to be of the form V, W ::= x | c | λx.M | ⟨V, W ⟩. A value program is a program of the form [Q, L, V ], where V is a value term. The rules for the reduction are an adaptation of the ones found in [4].
We set the rules to be the “classical” ones found in Table 2, plus the following

“quantum” rules. In the first two rules, let Q = Σ Q0 ⊗ αj|0⟩⊗ Q˜0 + Σ
Q1 ⊗

j	j
β |1⟩⊗ Q˜1, where Qb ∈ C2i−1 and Q˜b ∈ C2n−i .
j	j	j

j	j	j	j

[Q, |x1 ··· xn⟩, meas xi] →m0 [Σ
Q0 ⊗ Q˜0, |x1 ··· xi−1xi+1 ··· xn⟩, 0],

[Q, |x1 ··· xn⟩, meas xi] →m1 [Σ
Q1 ⊗ Q˜1, |x1 ··· xi−1xi+1 ··· xn⟩, 1].

If w is a fresh term variable not yet in use:
[Q, |x1 ··· xn⟩, new 0] →n0 [Q ⊗ |0⟩, |x1 ··· xnw⟩, w],
[Q, |x1 ··· xn⟩, new 1] →n1 [Q ⊗ |1⟩, |x1 ··· xnw⟩, w].
If Q' is the result of applying U to the quantum bits L(x1),... , L(xn) in Q: [Q, L, U ⟨x1,... , xn⟩] →U [Q', L, ⟨x1,... , xn⟩].
Note that since we want a linear language, we modified the measurement rule from [4] by deleting the quantum bit measured from the quantum array.
Lemma 3.2 (Substitution) If Δ,x : A D M : B and if Γ D N : A then Δ, Γ D
M [N/x]: B is a valid typing judgement.
Note that, in the non-linear case, the Substitution Lemma only holds when N = V is a value. However, in the linear calculus considered here, it holds for general N .
Theorem 3.3 (Safety properties) If P is a valid program of type A, either it is a value or P →ρ P ', with P ' a valid program of type A.
Proof. The proof is an adaptation of the proof of Theorems 1 and 2 in [4].	HH The language being linear, the reduction has a strong relation on the length of
the terms.
Definition 3.4 Let l(M ) be the length of a term M , defined recursively as l(x)= 
l(c) = l(Ω) = 1, l(λx.M ) = l(M )+ 1, l(let ⟨x, y⟩ = M in N ) = l(M )+ l(N )+ 1,
l(if P then M else N ) = l(P )+ max (l(M ), l(N )), l(MN ) = l(⟨M, N ⟩) = l(M )+ 
l(N )+ 1.
Lemma 3.5 If x ∈ FV (M ), then l(M [N/x]) = l(M )+ l(N ) − 1.
Lemma 3.6 If [Q, L, M ] →x [Q', L',M '], then either x /= ω and l(M ') < l(M ) or
x = ω and l(M ')= l(M ). In the latter case, [Q, L, M ]= [Q', L',M '].
Definition 3.7 A program [Q, L, M ] that reduces with a ω-rule is called a ﬁxed point.
Theorem 3.8 (Strong Normalization) If P = [Q, L, M ] is a valid program, P
reduces to a value or to a ﬁxed point in at most l(M ) steps.
Proof. Follows from Lemma 3.6.	HH

Quantum context and reduction
When describing the reduction rules, we carefully separated the quantum context from the lambda-term. In this subsection we show that the precise order of quantum bits in the quantum array does not matter.
Definition 3.9 If σ is a permutation of {1,... , n}, we extend σ to N with σ(j)= 
j for j > n, and we define σ¯ to be the corresponding permutation of quantum
bits σ¯|x1 ··· xn ··· xn+k⟩ = |xσ(1) ··· xσ(n)xn+1 ··· xn+k⟩. We say that (Q1, L1) is σ-equivalent to (Q2, L2) if Q1 and Q2 have the same size, Q2 = σ¯(Q1) and L2 = σ−1 ◦ L1. We write (Q1, L1) =ασ (Q2, L2). We define an equivalence relation called alpha-equivalence on quantum contexts by (Q1, L1) =α (Q2, L2) if there exists a σ such that (Q1, L1) =ασ (Q2, L2).
The alpha-equivalence is sound with respect to the semantics:
Lemma 3.10 If [Q, L, M ] →p [Q', L',M '] then [σ¯Q, σL, M ] →p [σ¯Q', σL',M '].

Reduction to values
In the reduction process, what we are really seeking is the final result of the com- putation. In this section we explicate the relation of programs to values.
Definition 3.11 We informally recall a notion defined in [4]: If X is the set of closed valid programs and U the set of values, let probU : X × U → [0, 1] be the map probU (P, V ) that returns the total probability for a program P to end up on the value V in zero or more steps. This function is called the big-step reduction.
We also define the small-step reduction operation prob : X × X → [0, 1]: for closed programs P, P ', we define prob(P, P ')= p if there is a single-step probabilistic reduction P →p P ', prob(V, V )=1 if V is a value program, and prob(P, P ')= 0 in
all other cases. Note that for all well-typed P , ΣP '∈X prob(P, P ')= 1.
Definition 3.12 If P is a closed well-typed program of type bit , and b ∈ {0, 1},
we define (P ⇓ b)= ΣV ∈Ub prob (P, V ), where Ub is the set of valid programs with
'
term the value b. We say that P evaluates to b with probability P ⇓ b.
Definition 3.13 We define a formal probability distribution of quantum closures to be Γ ▶ Σi ρi[Qi, Li, Mi]: A, where each Γ ▶ [Qi, Li, Mi]: A is valid and Σ ρi ≤ 1. The distribution is said to be closed if |Γ| = ∅.
Lemma 3.14 Given a set Z, let CZ be the set of probability distributions over
it. The small-step reduction prob : X × X → [0, 1] can be curried to a map prob' : CX → CX: prob'(Σi αiPi) = Σi αi ΣP '∈X prob (Pi,P ')P '.  Simi-
larly, probU  : X × U → [0, 1] can be curried to a map prob'	: CX  → CU:
prob' (Σi αiPi) = Σi αiprobU (Pi,V )V . The deﬁnition of P ⇓ b can be extended
in the same way to probability distributions of programs.
Lemma 3.15 If ▶ P : A is valid, so is ▶ prob 'P : A and ▶ prob' P : A.

Due to the strong normalization theorem, applying the map prob'
is applying

the map prob' finitely many times.
Proposition 3.16 If [Q, L, M ] is a valid program, then the reduction satisﬁes
n	m
prob'l(M)[Q, L, M ]= Σ ρi[Qi, Li, Vi]+ Σ ρ' Pj,
i=1	j=1

with prob' [Q, L, M ]= Σn
ρi[Qi, Li, Vi], the Pj being ﬁxed points, Σ
ρi +Σ ρ' =

U	i=1
1, and n + m < 2l(M).
i	j  j

Denotational semantics
In [3] the notion of completely positive map is used to model the notion of quantum computation. We aim to show that the linear subset of the quantum lambda calculus has the category CPM as a fully abstract model. Note that the interpretation will not be “onto” all completely positive maps, but will only be “onto up to scalar multiplies”. In this section we set the definition of the denotational semantics.
The category CPM
We recall the definition of the category V [3].
The objects are signatures σ = n1,... , nk, i.e., finite tuples of positive integers,
the arrows σ → σ' are linear maps Vσ → Vσ' , where Vn ,...,n  = Cn1×n1 × ... ×
1	k
Cnk×nk .
There is a tensor product (n1,... , nk) ⊗ (m1,... , ml) = n1m1,... , n1ml, n2 m1,... , nkml and a canonical isomorphism Vσ⊗τ  Vσ ⊗ Vτ . Thus V has a structure of symmetric monoidal closed category. The unit element is the signature 1. From the vector spaces property, V(σ ⊗ τ, σ') =Φ V(σ, τ ⊗ σ'): If B(τ ) is a basis for Vτ , then from f ∈ V(σ ⊗ τ, σ') we construct g = Φ(f ) ∈ V(σ, τ ⊗ σ') by g(s) = 
Σb∈B(τ ) b ⊗ f (s ⊗ b). Conversely, given such a g, if g(s)= Σb∈B(τ ),u∈B(σ') αb,ub ⊗ u,
one constructs f = Φ−1(g) by f (s ⊗ t)= Σu∈B(σ') αt,uu. This makes V monoidal
closed.
The category CPM has the same objects as V and as arrows completely positive maps (see [3]).
Modeling the quantum lambda-calculus
We set the denotation of types to be [bit ]] = (1, 1), [A ⊗ B]] = [[A]] ⊗ [[B]], [[qbit ]] = 2, and [A  B]] = [[A]] ⊗ [[B ], and the denotation of contexts to be
[[x1 : A1,... , xn : An]] = [[A1]] ⊗ ··· ⊗ [[An]],	[[∅]] = 1.
The denotation of a typing judgment of the form Δ D M : A is a linear map [[Δ]] →
[[A ], defined inductively as in Table 3. Here, Φ : hom(A ⊗ B, C) → hom(A, B ⊗ C)


[[x : A D x : A]](v) = v	[[D 0: bit ]](x) = (x, 0)
[[D ∗ : T]](x) = x	[[D 1: bit ]](x) = (0, x)
[[Δ D Ω: A]] = 0 : [[Δ]] → [[A]]
[[D new : bit  qbit ]] = Φ(ι): 1 → [[bit ]] ⊗ [[qbit ]]
[[D meas : qbit  bit ]] = Φ(p): 1 → [[qbit ]] ⊗ [[bit ]] [[D U : qbit ⊗n  qbit ⊗n]] = Φ(U ): 1 → 22n
[[Δ,x : A D M : B]] =	f : [[Δ ] ⊗ [[A]] → [[B]]
[[Δ D λx.M : A  B]] = Φ(f ): [[Δ ] → [[A]] ⊗ [[B]]
[[Δ D M : A  B]] = Φ(g): [[Δ ] → [[A]] ⊗ [[B]] [[Γ D N : A]] = f : [[Γ ] → [[A]]
[[Δ, Γ D MN : B]] : x ⊗ y '→ g(x ⊗ (fy)) : [[Δ ] ⊗ [[Γ]] → [[B]]
[[Δ D P : bit ]] : x '→ (px, qx): [Δ ] → [[bit ]]
[[Γ D M : A]] = f : [[Γ ] → [[A]]
[[Γ D N : A]] = g : [[Γ ] → [[A]]
[[Δ, Γ D if P then M else N : A]] : x ⊗ y '→ (px)(fy)+ (qx)(gy)
[[Δ D M : A]] = f : [[Δ ] → [[A]]
[[Γ D N : B]] = g : [[Γ ] → [[B]]
[[Δ, Γ D ⟨M, N ⟩ : A ⊗ B]] : x ⊗ y '→ fx ⊗ gy : [[Δ ] ⊗ [[Γ]] → [[A]] ⊗ [[B]]
[[Δ D M : A ⊗ B]] = f : [[Δ ] → [[A]] ⊗ [[B]]
[[Γ,x : A, y : B D N : C]] = g : [[Γ ] ⊗ [[A]] ⊗ [[B]] → [[C]]
[[Δ, Γ D let ⟨x, y⟩ = M in N : C]] : u ⊗ v '→ g(v ⊗ (f u)) : [[Δ ] ⊗ [[Γ]] → [[C]]
[[Δ D M : T]] = f : [[Δ ] → 1 [[Γ D N : C]] = g : [[Γ ] → [[C]]
[[Δ, Γ D let ∗ = M in N : C]] : u ⊗ v '→ (f u)(gv): [Δ ] ⊗ [[Γ]] → [[C]]
Table 3
Denotational semantics for typing judgments.

is the bijection from the compact closed structure and ι and p are respectively the quantum bits creation and the measurement operation:

ι : 1, 1 →	2	p :	2	'→ 1, 1
(a, b) '→  a 0	 a b  '→ (a, d)
We also define the denotation of a quantum closure. Consider a valid quantum closure Δ ▶ [Q, L, M ] : A where L = |x1 ··· xny1 ··· ym⟩ and |Q| = n + m. The quantum context (Q, L) can be seen as a map g :1 → 2⊗n⊗2⊗m such that g(1) = Q.

Then if


[[Δ, x1 : qbit,... , xn : qbit D M : A]] = f : [[Δ ] ⊗ 2⊗n → [[A]],

one defines [Δ ▶ [Q, L, M ]: A ] as the composition


  id [[Δ]]⊗g		⊗n
⊗m	f ⊗2⊗m	 
⊗m	[[A]]⊗Tr	 

[[Δ]]
[[Δ]] ⊗ 2	⊗ 2
[[A]] ⊗ 2
[[A]].

One extends this definition to probabilistic distributions of quantum closures using linearity:
[[Δ ▶ Σ ρiPi : A]] = Σ ρi[[Δ ▶ Pi : A]].
i	i
Lemma 4.1 Denotations of terms and quantum closures are completely positive maps.
Lemma 4.2 (Substitution) If |Γ|∩ |Δ| = ∅ and [[Δ,x : A D M : B]] = G : [[Δ ] ⊗
[[A]] → [[B]], [[Γ D N : A]] = F : [Γ ] → [[A]], then [[Δ, Γ D M [N/x]: B]] = H :
[[Δ]] ⊗ [[Γ]] → [[B]], with H(d ⊗ g)= G(d ⊗ (Fg))
Lemma 4.3 Given a program P : A with prob 'P = Σi ρiPi then [[P : A]] = [[prob 'P : A]] = [[prob' P : A]].
Fullness of the semantics for the ﬁrst order fragment
Proposition 4.4 For any types A = U1 ⊗ ··· ⊗ Un and B = V1 ⊗ ··· ⊗ Vm, where each Ui and Vj is either bit or qbit, if F : [[A]] → [[B]] is any superoperator, then there exists a valid typing judgement x : A D M : B of denotation F.
Corollary 4.5 For every type A = U1 ⊗···⊗Un, where each Ui is either bit or qbit, and for every hermitian positive element v ∈ V[[A]] of trace at most 1, v = [[M : A]](1) for some closed valid term M.

Equivalence classes of terms
Being able to build terms, we need some tools to compare them. One can compare them through syntactic manipulations, or one can have a finer approach using the two semantics we have built: in the case of the operational semantics, the behavior of the terms is what defines the equivalence, and in the case of the denotational semantics, the equivalence is expressed by the denotation of the terms.
Axiomatic equivalence
A first notion of equality of terms can be defined by a set of syntactic rules. This is known as the axiomatic equivalence.
Definition 5.1 We define an equivalence relation ≈ax on typing judgement. We write the relation as Γ D M ≈ax N : A, and we define it to be the smallest relation

(β)	Γ D (λx.M )N	≈ax M [N/x]: A
(η)	Γ D λx.M x	≈ax M : A  B
(β⊗) Γ D let ⟨x, y⟩ = ⟨N, P ⟩ in M	≈ax M [N/x, P/y]: A (η⊗) Γ D let ⟨x, y⟩ = M in ⟨x, y⟩	≈ax M : A ⊗ B
(β∗) Γ D let ∗ = ∗ inM	≈ax M : A
(η∗) Γ D let ∗ = M in ∗	≈ax M : T
(β1 ) Γ D if 1 then M else N	≈ax M : A
(β0 ) Γ D if 0 then M else N	≈ax N : A
(Ω) Γ D M [Ω/x]	≈ax Ω: A
(ηif) Γ D if B then M [1/x] else M [0/x] ≈ax M [B/x]: A (id ) Γ D meas (new M )	≈ax M : qbit
Table 4 Axiomatic equivalence

satisfying the rules in Table 4, the alpha-equivalence and one congruence rule (ξ) per term constructor. This means for example:
Γ D M ≈ax M ' : A  B	Δ D N ≈ax N ' : A
(ξapp )
Γ, Δ D MN ≈ax M 'N ' : B
Γ,x : A D M ≈ax M ' : B
(ξλ)
Γ D λx.M ≈ax λx.M ' : A  B
We call it the axiomatic equivalence relation.
Lemma 5.2 The order of the arguments in an application does not matter. Simi- larly, one can apply the arguments as a pairing or sequentially. More precisely:
[Q, L, ((λxy.M )N )P ] ≈ax [Q, L, ((λyx.M )P )N ]
[Q, L, let ⟨x, y⟩ = ⟨N, P ⟩ in M ] ≈ax [Q, L, ((λxy.M )N )P ]
Operational context
To say that two arbitrary terms have the same behavior, we need a way to observe them. The only observable types at our disposal are the types bit and T. So the fact that two terms M and M ' have the same behavior can be understood as the fact that in whichever context C[−] we “use” them, if C[−]: bit , then C[M ] reduces to 0, respectively, 1, with the same probability as C[M ']. Such a term C[−] is called an operational context.
Definition 5.3 We define a formal operational context to be a formula defined by the following BNF:
C[−] ::= [−] | (C[−]M ) | (MC[−]) | λx.C[−] | ⟨C[−],M ⟩| ⟨M, C[−]⟩
| let ⟨x, y⟩ = C[−] in M | let ⟨x, y⟩ = M in C[−]
| if C[−] then M else N | if M then C[−] else C'[−].

We call [—] the hole of the context.
The notions of well-typed contexts and free variables in contexts are defined the same ways as for terms. Note that there exists a new notion: the notion of captured variables, which are the variables whose scope includes the hole. We can make this more precise by speaking of typed contexts:
Definition 5.4 A typed operational context is a typing tree with root Γ' D C[—]: B, considering the additional axiom Γ D [—]: A, i.e., a typing tree of the form
Γ D [—]: A
		.	 Γ' D C[—]: B.
We say that this context is of type B, with free variables Γ', a hole of type A, and captured variables Γ. We also use the notation Γ' D C[Γ D — : A]: B for a typed operational context.
Lemma 5.5 If
Γ D [—]: A
	.	
Γ' D C[—]: B.
is a valid typing derivation, then so is
Δ, Γ D [—]: A
	.	
Δ, Γ' D C[—]: B,
provided the variables that occur in Δ are fresh.
Operational equivalence
We define a notion of operational equivalence, based on the reduction rules and observations of type bit , as in [2]. (Equivalently, it would suffice to consider obser- vations of type T).
Definition 5.6 Let D C[Γ D — : A] : bit be a closed typed operational context of type bit , and let R = [Q, L, M ] be a well-typed quantum closure with typing judgement Γ ▶ [Q, L, M ] : A. In this case we define the substitution C[R] by [Q, L, C[M ]], where M is syntactically replacing [—] in C[—]. We linearly extend this definition to probabilistic distributions of quantum closures of the form Γ ▶
Σi ρiRi : A by setting C[Σi ρiRi]= Σi ρiC[Ri].
Lemma 5.7 In Deﬁnition 5.6, the substitution is well typed and a valid typing judgement for it is ▶ [Q, L, C[M ]] : bit.
Proof. A direct consequence of Lemma 5.5.	HH

Definition 5.8 Given two well-typed quantum closures Γ D R, R' : A, we say that R is operationally equivalent to R' with respect to Γ if for all closed typed operational contexts D C[Γ D — : A] : bit , C[R] ⇓ 0 = C[R'] ⇓ 0 and C[R] ⇓ 1 = C[R'] ⇓ 1. In this case, we write Γ D R ≈op R' : A. If M, M ' are terms, we say that Γ D M ≈op M ' : A if Γ ▶ [|⟩, |⟩,M ] ≈op [|⟩, |⟩,M ']: A.
Denotational equivalence
The last equivalence we can define is the denotational equivalence. This equivalence relation is simply stated:
Definition 5.9 We say that two typing judgments Γ D M, M ' : A are denotation- ally equivalent if [[Γ D M : A]] and [[Γ D M ' : A ] are the same map in CPM. In that case we write Γ D M ≈den M ' : A.
We extend this definition to quantum closures: Γ ▶ R ≈den R' : A is true if [[Γ ▶ R : A]] = [[Γ ▶ R' : A]].

Soundness of the axiomatic equivalence and full ab- straction of the denotational semantics
The three defined equivalence relations we have built have the expected behavior: The axiomatic equivalence is sound with respect to the operational equivalence and the denotational semantic is fully abstract with respect to the operational semantics:
Theorem 6.1 (Soundness) If Γ ▶ M ≈ax M ' : A then Γ ▶ M ≈op M ' : A.
Remark 6.2 An immediate consequence of soundness is that the quantum context is not a side-effect, i.e., the order of evaluation does not affect the outcome.
Γ D ((λxy.R)M )N ≈op ((λyx.R)N )M .
Theorem 6.3 (Full abstraction) The denotational semantics is fully abstract with respect to the operational equivalence of typing judgments, i.e.
[[Γ D M : A]] = [[Γ D M ' : A]] if and only if Γ D M ≈op M ' : A.
Remark 6.4 The presence of the non-terminating term Ω is necessary for full ab- straction to hold. Without it, every program terminates with probability 1, and there is only one definable map bit → T. Thus, although λf.(f 0) and λf.(f 1) of type (bit  T)  T have different denotations, no context will distinguish them.
Proof of the soundness theorem
Assume Theorem 6.3. It suffices to show that if Γ D M ≈ax M ' : A then Γ D M ≈den
M ' : A. We show this by structural induction on the proof of Γ D M ≈ax M ' : A. We detail the cases (β1 ) and (η).
For the (β1 ) case, let [[Γ D M, N : A]] = f, g : [Δ ] → [[A]] and [[D 1: bit ]] =
(p, q) : 1 → 1, 1. Then [Γ D if 1 then M else N : A]] : 1 ⊗ y '→ (p1)(fy)+ (q1)(gy) which is y '→ fy, namely [[Γ D M : A]].

The case (η) is done as follows. Consider the proof tree
Γ D M : A  B	x : A D x : A Γ,x : A D Mx : B
Γ D λx.(Mx): A  B


and set

[[x : A D x : A]] = Id A : [[a]] → [[A]]

[[Γ D M : A  B]] = Φ(g): [Δ ] → [[A]] ⊗ [[B]].	Then
[[Γ,x : A D Mx : B]] = f : [[Γ ] ⊗ [[A]] → [[B]]
with f (x ⊗ y)= g(x ⊗ Id A(y)) = g(x ⊗ y), and we are done.
Note that cases (β) and (let ) are done using Lemma 4.2.	HH

Full abstraction: preliminary lemmas
Lemma 6.5 For any two programs P, P ' of type bit, they have the same denotation if and only if for all b ∈ {0, 1}, P ↓ b = P ' ↓ b.
Proof. Consider two well-typed programs P, P ' : bit . Suppose they have the same denotation f . Then from Lemma 4.3, f is also the denotation of prob' P and of
prob' P '. But by definition, [prob ' P ]] = (p, q), where p = (prob' P ) ↓ 0= P ↓ 0 and
U	U	U
q = (prob ' P ) ↓ 1= P ↓ 1, and similarly for P '. Thus P ↓ b = P ' ↓ b. The argument being reversible, we get the other implication.	HH
Lemma 6.6 If [[Γ D M :A]] = [[Γ D M ':A]] and C[Γ D — : A]: bit is a valid context, then [[C[M ]: bit ]] = [[C[M ']: bit ]].
Proof. The proof uses Lemma 4.2.	HH
Definition 6.7 Given a type A, we define the canonical ﬁrst-order representation A of A by the following: bit = bit , qbit = qbit , T = T, A ⊗ B = A ⊗ B, A  B = A ⊗ B.
Lemma 6.8 For all types A, [[A]] = [[A]].

Lemma 6.9 For all types A, there exist two terms x : A D ΥA : A and x : A D
ΥA : A and constants λ, λ' > 0, such that [[ΥA]] = λid [[A]] and [[ΥA]] = λ'id [[A']].

Proof. The terms ΥA and ΥA are simultaneously constructed by structural induc- tion on A.	HH
Lemma 6.10 For all types A, let σ = [A]] and let m, m' be hermitian positive elements in Vσ, m /= m'. Then there exists a well-typed term x : A D M : bit such that [[M ]](m) /= [[M ]](m').
Proof. By Lemma 6.9, it suffices, without loss of generality, to consider the case where A = bit ⊗ ... ⊗ bit ⊗ qbit ⊗ ... ⊗ qbit . However, in this case, the claim follows easily from Proposition 4.4 on the fullness of the semantics in first order.	HH

Lemma 6.11 Given any type A and any hermitian positive v ∈ V[[A]], there exists a closed term M : A and λ > 0 such that [[M ]](1) = λv.
Proof. If v = 0, let M = Ω. Else, from Corollary 4.5, there exists a valid typing judgement D N : A such that v/Tr (v) = [N ](1). Then let M = ΥA[N/x] : A. From Lemma 6.9, [[M : A]](1) and v are collinear.	HH

Proof of the full abstraction theorem
If [Γ D M : A]] = [[Γ D M ' : A ], take any valid context C[Γ D — : A] : bit for those two terms. Then from Lemma 6.6, [[D C[M ]: bit ]] = [[D C[M ']: bit ]]. From Lemma 6.5, C[M ] ↓ b = C[M '] ↓ b, for b ∈ {0, 1}. Since this holds for arbitrary contexts, M and M ' are operationally equivalent.
The opposite implication follows from Lemma 6.10 and Lemma 6.11. Consider two typing judgments Γ D M, M ':A with denotations F =[[Γ D M : A]] and G = [[Γ D M ' : A ], such that F /= G.. Since the vector space V[[Γ]] is spanned by hermitian positive elements, there exists a hermitian positive v ∈ V[[Γ]] such that F (v) /= G(v). If Γ = x1:A1,... , xn:An, let B = A1 ⊗ ... ⊗ An. By Lemma 6.11, there exists a closed term R : B such that [R : B]](1) = λv, for some λ > 0. By Lemma 6.10, there exists a term x : A D S : bit such that [x : A D S : bit ]](F v) /= [[x : A D S : bit ]](Gv).
Now consider C[Γ D — : A]: bit defined by
let ⟨x1,... xn⟩ = R in let x = [—] in S.
Then [C[M ]]](1) /= [[C[M ']]](1), hence by Lemma 6.5, C[M ] ↓ b /= C[M '] ↓ b, for some

b ∈ {0, 1}. It follows that M ≈/
opM ', which completes the proof of full abstraction.
HH


Conclusion
In this paper we have restricted our study to the linear fragment of the program- ming language of [4]. We gave a syntactic notion of equivalence of terms and an operational one, together with a fully abstract model for the latter.
Several questions remain open. First, the exact image of the denotational se- mantics is still to be characterized as a subset of the completely positive maps. Then it would be interesting to explore the categorical semantics of the linear language. Finally, we may want to add weakening and duplication and find a denotational semantics for the full quantum lambda calculus.

References
Barendregt, H. P., “The Lambda-Calculus, its Syntax and Semantics,” Studies in Logic and the Foundation of Mathematics 103, North Holland, 1984, second edition.
Danos, V. and R. S. Harmer, Probabilistic game semantics, ACM Transactional on Computational Logic
3 (2002), pp. 359–382.

Selinger, P., Towards a quantum programming language, Mathematical Structures in Computer Science
14 (2004), pp. 527–586.
Selinger, P. and B. Valiron, A lambda calculus for quantum computation with classical control, in:
P. Urzyczyn, editor, Proceedings of the Seventh International Conference on Typed Lambda Calculi and Applications (TLCA 2005), Lecture Notes in Computer Science 3461 (2005), pp. 354–368.
