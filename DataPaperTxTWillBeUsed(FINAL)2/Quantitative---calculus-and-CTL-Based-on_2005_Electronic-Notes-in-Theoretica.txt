Electronic Notes in Theoretical Computer Science 112 (2005) 37–59  
www.elsevier.com/locate/entcs


Quantitative µ-calculus and CTL Based on Constraint Semirings 1
Alberto Lluch-Lafuente and Ugo Montanari
lafuente@di.unipi.it, ugo@di.unipi.it
Dipartimento di Informatica Universit`a di Pisa

Abstract
Model checking and temporal logics are boolean. The answer to the model checking question does a system satisfy a property? is either true or false, and properties expressed in temporal logics are defined over boolean propositions. While this classic approach is enough to specify and verify boolean temporal properties, it does not allow to reason about quantitative aspects of systems. Some quantitative extensions of temporal logics has been already proposed, especially in the context of probabilistic systems. They allow to answer questions like with which probability does a system satisfy a property?
We present a generalization of two well-known temporal logics: CTL and the µ-calculus. Both extensions are defined over c-semirings, an algebraic structure that captures many problems and that has been proposed as a general framework for soft constraint satisfaction problems (CSP). Basically, a c-semiring consists of a domain, an additive operation and a multiplicative operation, which satisfy some properties. We present the semantics of the extended logics over transition systems, where a formula is interpreted as a mapping from the set of states to the domain of the c-semiring, and show that the usual connection between CTL and µ-calculus does not hold in general. In addition, we reason about the feasibility of computing the logics and illustrate some applications of our framework, including boolean model checking.
Keywords: Constraint Semirings, Constraints, Temporal Logics, Quantitative Model Checking


Introduction
Model Checking [9] is a formal automated method for system verification con- sisting of three main steps: modeling the system, modeling the properties of the system and checking whether the properties hold in the system. Usually,

1 This work has been supported by the European Research Training Network SEGRAVIS.


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.063


systems are represented using formalisms such as automata, labeled transition systems and Kripke structures with a finite number of states, where boolean propositions are associated to states and transitions. On the other hand, tem- poral logics, which combine modal operators with boolean connectives and propositions, are often used for representing system properties. The verifi-
cation step returns a boolean answer: either yes (the system satisfies the specification) or false (the system violates the specification).


Motivation.
While this approach is sufficient to reason about qualitative aspects of sys- tems, it is clearly not sufficient to reason about quantitative aspects. Hence,
approaches have been proposed for the analysis and verification of quantita- tive systems. Among others, we cite durational systems [16], probabilistic systems [13,14] and timed systems [1]. Formalisms to represent systems and properties are equipped with quantitative aspects such as time, probabilities or costs. The verification question can be boolean, but it can be quantitative too. For example, when reasoning about probabilistic system one can ask if a property holds with a probability higher than p, or which is the probability that a property holds.
A similar situation exists in the domain of Constraint Satisfaction Prob- lems. There, classical problems consider boolean constraints only: either a constraint is present or it is not. Some CSP problems, however, cannot be properly formulated using this crisp interpretation of constraints. Several ap- proaches exist to remedy this, which basically associate non-boolean values to constraints, like probabilities, costs and sets. Such constraints are called soft constraints and the corresponding problems are soft CSP, like fuzzy CSP, probabilistic CSP, weighted CSP, among others.
A general framework for soft CSP has been proposed in [3,4,5]. The key of the approach is an algebraic structure called constraint semiring (c-semirings for short). A c-semiring consists of a domain and two operations, which are
called additive and multiplicative operations. The basic idea is that the do- main is used to represent the values associated to constraints (boolean, prob- abilities, etc.), the additive operation is used to project constraints and the multiplicative operation is used to combine constraints. The framework cap- tures most of the common soft CSP problems, such that the results stated for the framework can be applied to concrete instances. Such results can be often employed effectively on the particular instance or can be used, for example, as hints for the applicability of special solution methods for a concrete instance. More interestingly, c-semiring constraint methods have a unique advantage when problems with multiple criteria or multiple metrics must be tackled. In


fact, it turns out that Cartesian products, exponentials and power construc- tions of c-semirings are c-semirings. Thus the same concepts and algorithms can be applied again and again.

Goals.
The purpose of our research is to define a general framework for quanti- tative verification, based on c-semirings. In this paper we present our first step. We have extended two well-known temporal logics, µ-calculus and CTL, where boolean propositions and connectives are replaced by c-semiring val- ues and operations, while temporal operators are substituted by operators on sequences of c-semiring values. We present a first semantics over transition systems. While in boolean model checking the interpretation of a formula can be seen as a mapping from the set of states to the boolean domain, which implicitly represents the subset of states satisfying the formula, we interpret formulae as mappings from the set of system states to the domain of the c-semiring.
While we expect our framework to capture many problems, one of our main interests is to use it as a formalism to analyze Quality of Service (QoS) properties. QoS are measures of the non functional properties of services.
Bandwidth, delay and jitter are typical examples of network QoS properties, while application-level QoS includes, among others, price and access rights. In most cases, the implicit algebraic structure is a c-semiring. As a matter of fact, c-semirings has been used in Kaos [15], a calculus for programmable QoS, as a formalism for representing QoS properties of WAN applications.

Related work.
Our approach is not the first attempt to define a framework for quantita- tive verification. For instance, the algebraic µ-calculus [2] extends the classical µ−calculus with arithmetic expressions and functions. This approach is very general and embeds a wide range of problems, from graph theoretical problems to matrix operations. Quantitative verification of systems like, for example, probabilistic and durational systems can also be performed using this frame- work. Our work is also inspired by previous research on quantitative analysis and verification of probabilistic systems. In [13], for instance, a probabilistic extension of the µ-calculus is proposed. The semantics is defined over proba- bilistic transition systems, where three alternative probabilistic semantics for disjunction and conjunction are presented. Since fixpoint iteration is infeasi- ble, they propose an alternative approach to evaluate a significant fragment of their logic, which basically consists on reducing the problem of fixpoint computation to an (equivalent) optimization problem in linear programming.


The implicit algebraic structure they use is however not a c-semiring. On the other hand, the work described in [10] defines two quantitative extensions of the µ-calculus: a probabilistic one, where disjunction and conjunction of probabilities are given a fuzzy (min/max) interpretation, and a discounted one, where events are weighted according to their distance to the present. Their semantics is defined over games, a formalism that generalizes, among others, boolean and probabilistic transition systems. A discounted version of CTL is proposed in [11], where two semantics are given: the path and fixpoints semantics. While in boolean model checking both semantics are equivalent, allowing the use of fixpoint iterations as algorithms for CTL, they differ when discounted CTL is interpreted over probabilistic systems. Specific algorithms for each semantics are thus proposed.

Structure of the paper.
This paper is structured as follows. Section 2 gives the necessary back- ground on c-semirings and transition systems. The next section describes syntax and semantics of the extended logics, and presents some theoretical results. Section 4 is on the computation of our logics and Section 5 illustrates various applications of our framework. The last section concludes the paper and outlines current and future work. An appendix following the bibliography contains proofs of some lemmas and theorems.

Preliminaries
Our logics are defined over the domain of an algebraic structure called c- semiring, where “c” stands for “constraint”, meaning that they are the natural structures to be used when handling constraints. As already explained c- semirings have been proposed as a formalism for soft constraint solving and programming problems [3,4,5].
A c-semiring is a tuple ⟨A, +, ×, 0, 1⟩ such that:
A is a set;
0 and 1 are elements of A;
• + : 2A → A is defined over (possibly infinite) sets of elements of A as follows 2 : Σ{a} = a, Σ ∅ = 0, Σ A = 1 and Σ(  Ai) = Σ{Σ Ai}, for
Ai ⊆ A, i ≥ 0;
× : A × A → A is a binary associative, commutative operation that dis- tributes over +, has 1 is its unit element and 0 its absorbing element.

2 When + is applied to a set with two elemenΣts we use + as binary operator in infix


The fact that + is defined over sets of elements , automatically makes such an operation associative, commutative and idempotent. Moreover, one
can show that it has 0 as unit element and 1 as absorbing element [5]. Given

a sequence a0, a1 ... of elements of A we write Σ

i≥0
ai rather than Σ	.
  {a0 ,a1 ...}

Given a finite sequence a0,... , an we abbr eviate a0 × ... × an with


0≤i≤n ai.

too. Most of the c-semirings used in practice satisfy this.
To enhance readability, operation + is called additive operation, while × is called multiplicative operation. Note that we use a boldfaced + and symbol ×
to avoid confusion with the additive and multiplicative operations over reals (+ and ·).
Typical examples of c-semirings are ⟨{true, false}, ∨, ∧, false, true⟩ (logical c-semiring), ⟨R+, min, +, +∞, 0⟩ (optimization c-semiring), ⟨[0, 1], max, ·, 0, 1⟩ (probabilistic c-semiring) and ⟨[0, 1], max, min, 0, 1⟩ (fuzzy c-semiring). Note
that the intuition behind the operations of the c-semiring is that addition is used to represent selection of values, while multiplication represents combina- tion of values.
The additive operation of the c-semiring induces a partial order as follows: a ≤S b iff a + b = b. For example, in the optimization c-semiring, ≤S corre- sponds to arithmetic relation ≥. One can show that ≤S is indeed a partial order, that +, × are monotone over ≤S, 0 and 1 are respectively the minimum and maximum elements of ≤S, and ⟨A, ≤S⟩ is a complete lattice [5].
In some instances of a c-semiring, the multiplicative operation is idem- potent. This implies, among other things, that + distributed over × and
⟨A, ≤S⟩ is a distributive lattice [5]. The logical and fuzzy c-semirings are an example of this, since logical disjunction is idempotent, i.e. p ∧ p is p. To the contrary, the multiplicative operations of the optimization and probabilistic c-semirings, i.e. addition and multiplication of reals are not idempotent.
It is also common to have a negation operator - : A → A, which is a unary operator such that -a ∈ A and --(a) = a for all a ∈ A, and -  {A'} =  {-a |
a ∈ A'} for all A' ⊆ A, where . and . are the lowest upper bound and greatest
lower bound operators of the lattice ⟨A, ≤S⟩. The negation operator allows us to use the equivalence -0 = 1. Note that the duality -(a+b) = (-a)×(-b) holds exactly when × is idempotent. Examples where a negation can be defined
are the logical c-semiring, where logical negation is a negation operator, and probabilistic and fuzzy c-semirings where 1− is a negation operator. On the other hand, it is not possible to define a negation operator for the optimization c-semiring.
As already advanced in the first section, we give an interpretation of our logics over transition systems, defined as tuples ⟨S, T ⟩, where S is a set of


states and T ⊆ S × S is a set of transitions. We assume the transition system to be image-ﬁnite, i.e. that for any given s ∈ S we have that {s'|(s, s') ∈ T } is a finite set. We sometimes require T to be total, i.e. for every state s there
is at least one outgoing transition (s, s') ∈ T . This avoids end states in the system. Runs of a system are maximal paths in the underlying state transition graph, i.e. paths that are either infinite or end in an end state. A path is a sequence s0, s1, s2 .. ., such that for all i ≥ 0 we have si ∈ S and (si, si+1) ∈ T . We denote by |p| the length of a finite path p, by sp the i-th state of path p
and by γ(s) the set of runs starting at s.
In the rest of the paper, let M = ⟨S, T ⟩ and C = ⟨A, +, ×, 0, 1⟩ be the transition system and c-semiring under consideration.

Semiring Logics
In this section we first give the syntax and semantics of the µ-calculus exten- sion, which we call c-semiring µ-calculus (or c-Lµ for short). Later we describe the syntax of the CTL extension, called c-semiring CTL (or c-CTL for short), and give two semantics: the path and the fixpoint semantics, showing that
the equivalence between the two semantics does not hold in general.
As we shall see, we interpret a formula of the extended logics as a mapping v : S → A, i.e. a mapping from the set of system states S to the domain A of the c-semiring. We call such a mapping, a valuation. In the following let
V = AS be the set of all valuations.  Let us define an additive operation
⊕ : V × V → V such that (v ⊕ v')(s) = v(s)+v'(s) for all s ∈ S. Similarly, we define a multiplicative operation ⊗ : V × V → V as follows: (v ⊗ v')(s) = v(s) × v'(s) for all s ∈ S. Let 0 and 1 be the valuations that respectively assign 0 and 1 to every state. It can be easily shown that ⟨V, ⊕, ⊗, 0 , 1 ⟩ is a c-semiring. The partial order of the this c-semiring is denoted by ≤V . It is easy to see that for any two valuations v, v' ∈ V , v ≤V v' iff for all s ∈ S we have v(s) ≤S v(s'). Recall that, that ⟨V, ≤V ⟩ is a complete lattice [5]. The defined c-semiring inherits various of the properties of the c-semiring C. Hence, in the document we sometimes refer to original properties of + and × instead of referring to properties of ⊗ and ⊕. For example, if × is idempotent, so is ⊗.

C-semiring µ-calculus
Let Z be a set of valuation variables, F a set of functions, which range is A and which domain is Ai for some i > 0, and AV ⊆ V be a set of atomic valuations. Valuation variables are used inside fixpoint formulae as explained below.


Set F is used to represent additional functions over the domain of the concrete c-semiring being considered other than the additive and the multi- plicative operations. For example, if the c-semiring under consideration is the boolean one, then one can include boolean negation as a function of F in order to be able to define all possible boolean functions 3 . In an optimization c-semiring, one might want to include other arithmetic functions like arith- metic multiplication or division. In sum, the choice of F determines the set of all functions that can be represented.
Set AV generalizes the set of atomic propositions of boolean logics. Indeed, an atomic boolean proposition p can be interpreted as a valuation that assigns true to states where p holds and false otherwise. Let a ∈ A, v ∈ AV , z ∈ Z
and f ∈ F . The formulae of the c-Lµ are defined as follows:
φ ::= a | v | z | f (φ,... , φ) | φ+φ | φ × φ | κXφ | µz.φ | νz.φ κ ::= . | Σ | 
Operators µ and ν are used to express least and greatest fixpoints, respec- tively. Temporal operator X is used to refer to the evaluation of a formula in a next state. Since a state might have more than one immediate successor we use a quantifier κ preceding X. While boolean µ-calculus considers only two quantifiers, namely existential and universal quantification, we consider three possible cases:  ,  and  . As we shall see they respectively express the application of the greatest lower bound, additive and multiplicative op-
eΣrations of the lattice ⟨A, ≤S⟩. N.ote that in c-semirings,  coincides with
[5]. Hence, we do not include	as a quantifier, since it is redundant. On
the other hand, . coincides with  if × is idempotent [5].


Semantics.
We interpret a formula φ as a valuation φ e, where e : Z → V is an environment.
 a)e(s)	= a	 φ1 × φ2)e	= φ1)e ⊗ φ2)e
 v)e	= v	 κXφ)e(s)	= κ(s,s')∈T φ)e(s )
 z)e	= e(z)	 νz.φ)e	= FIX λz . φ)e[z'/z]
 φ1+φ2)e = φ1)e ⊕ φ2)e  µz.φ)e	= ﬁx λz . φ)e[z'/z]
 f (φ1,... , φn))e(s) = f ( φ1)e(s),... , φn)e(s)),

3 boolean negation, disjunction and conjunction are sufficient to define all boolean func- tions.

where s ∈ S, κ ∈ {., Σ, }, FIX abbreviates greatest ﬁxpoint and ﬁx, least ﬁxpoint, and e[v/z] is the same as e except that e[v/z](z) = v. A formula φ is closed if every variable is bound by a fixpoint operator. In such cases φ e does not depend on e and we just write  φ .  Functions λz'. φ e[z'/z] are operators on V (functions V → V ) that we will denote with τ . In the
rest of the paper we shall assume that functions of F are monotone. With this assumption, it is easy to see that every possible operator τ is monotone.
Hence, by Knaster-Tarski Theorem [17] the fixpoints are well-defined. More
precisely, µz.τ (z) = . {v | v ≤V τ (v)} (equivalently . {v | v = τ (v)}) and
νz.τ (z) = . {v | v ≤ V τ (v)} (equivalently . {v | v = V v)} 4 .
τ (
In addition, if τ is HV -continuous, then µz.τ (z) = . {τi(0)} and if it is

H	.	i
V
0	i+1

V -continuous, then νz.τ (z) =	V {τ (1)}, where τ (z) = z and τ	(z) = 
τ (τ i(z)) for i = 1, 2,.. .. In the rest of the paper we consider continuous
operators.	Note that, because τ is monotone, . {τi(0)} = τ ∞(0) and

V {τi(1)} = τ
V
∞(1).  Hence, fixpoint iteration can be applied to evaluate

a formula. Nevertheless this method is not always feasible as we shall see in
the next section.






C-Lµ with negation.
The existence of a negation operator as defined in Section 2, enables some equivalences between formulae, for instance -(	Xφ) =	X-φ and -(µz.φ) = νz.-(φ[-z/z]). Note that -(	Xφ) is equivalent to	X-φ if × is idempotent.
As in boolean µ-calculus, one has to impose syntax restrictions on the use of negations in order to guarantee monotony. More precisely, we shall require that each variable appears under an even number of negations, and for each function f ∈ F there is a (dual) function f ∈ F such that -f (φ1,... , φn) = f(-φ1,... , -φn). We have also to require the existence of a dual for ⊗. The idea is that with these dualities and the requirement on the use of negations one can push negations such that they appear applied to atomic propositions
only.




4 In this case, HV and HV respectively refer to the lowest upper bound and greatest lower bound operations of the lattice ⟨V, ≤V ⟩.


C-semiring CTL
Syntax.
The syntax of c-CTL is defined as follows:
φ ::= a | z | v | f (φ,... , φ) | φ+φ | φ × φ | κψ | κXφ κ ::= . | Σ | 
ψ ::= Fφ | Gφ | [φUφ] | [φRφ]
C-CTL formulae are state formulae generated by φ. Symbol κ is used to introduce quantifiers over path formulae, which are generated by ψ. Path formulae combine state formulae with temporal operators X (next time), F (eventually), G (globally), U (until) and R (release).



Semantics.
Again, we interpret a state formula as a mapping from the set of states S to the set of c-semiring values A. Path formulae, instead, assign c-semiring values to paths. The semantics of a, v, z, f (φ1,... , φn), φ1+φ2 and φ1 × φ2 is the same as in c-Lµ. The rest is defined as follows:

 κXφ)(s) = κ(s,s')∈T φ)(s')  Fφ)(p)	= Σi≥0
 κψ)(s)	= κp∈γ(s) ψ)(p)	 φ1Uφ2)(p) = Σ
 φ)(si )
( φ2)(sp) × 


 φ1)(s ))

 Gφ)(p) = 
 φ)(sp)	 φ1Rφ2)(p) = 
( φ2)(sp)+ Σ
 φ1)(s )),

where p is a path. It is easy to see that Fφ ≡ [1Uφ] and Gφ ≡ [0Rφ].
The previous semantics is called path semantics. In model checking, there is an alternative equivalent semantics which interprets CTL formulae as fix- points [9]. For example, CTL formula EFφ is interpreted as µz.φ ∨ EXz. This equivalence shows that boolean µ-calculus contains CTL, and allows to perform CTL model checking formulae by fixpoint iteration. This suggests to define the following fixpoint semantics to c-CTL formulae:


 κFφ)
f
=  µz.φ+κXz)	 κ[φ1Uφ2])f
f
= µz.φ2+(φ1 × κXz))

 κGφ)
=  νz.φ × κXz)  κ[φ1Rφ2])
= νz.φ2 × (φ1+κXz))

Unfortunately, we will see that the path and fixpoints semantics of c-CTL are not equivalent in general. In order show this we need to define a bounded version of the temporal operators F G, U and R. Intuitively, the idea is they


take into account the first k states of a path only:

 Gkφ)(p) = 
 φ)(sp)  [φ1Ukφ2])(p) = Σ
(φ2(sp) × 
φ1(sp))

 Fkφ)(p) = Σ	 φ)(sp)  [φ1Rkφ2])(p) =	(φ2(sp)+ Σ	φ1(sp))
Clearly, F∞ ≡ F, G∞ ≡ G, U∞ ≡ U and R∞ ≡ R
Theorem 3.1 If T is total, κ is idempotent 5 and + distributes over κ then
 κFφ) = µz.φ+κXz).
Proof. We use the bounded version of F and induction on k to prove that
k	∞
 κF ) = τ (0).  Recall that τ  (0) is the least fixpoint of the continuous

operator τ = λy. φ+κXy).
If k = 1 then κF1φ)(s) is κp∈γ(s) φ)(s), while τ

(0) is φ)(s)+ κ(s,s')∈T 0 =

 φ)(s) since we assume that T is total and hence {(s, s ) ∈ T } is not empty. If κ is idempotent, κp∈γ(s) φ)(s) equals φ)(s).
Assume for induction that κFjφ) = τj(0), then applying τ in both sides we get τ ( κFjφ)) = τ (τj(0)) = τj+1(0). But τ ( κFjφ))(s) = 
= φ + κX κFjφ))(s)	(By def. of τ )
=  φ)(s)+ κX κFjφ))(s)	(By def. of +))
j	'
= φ)(s)+ κ(s,s')∈T ( κF φ)(s ))	(By def. of κX))

=  φ)(s)+ κ(s,s')∈T (κp∈γ(s') Σ0≤i<j
 φ)(si ))	(By def. of κF))

= φ)(s)+ κp∈γ(s) Σ1≤i<j+1
 φ)(si )

= κp∈γ(s) Σ
 φ)(s )	(+ distr. over κ; s = s )

= κFj+1φ)(s)	(By def. of κFk), +)) Hence, κFφ) = κF∞φ) = τ ∞(0) = µz.φ+κXz).	 
With similar proofs one can show the following two theorems.
Theorem 3.2 If T is total, κ is idempotent and × distributes over κ then
 κGφ) = νz.φ × κXz).
Theorem 3.3 If T is total, κ is idempotent and + and × distribute over κ
then  κ[φ1Uφ2]) =  µz.φ2+(φ1 × κXz)).
Theorem 3.4 If T is total and × is idempotent  κ[φ1Rφ2]) =  νz.φ2 ×
(φ1+κXz)).

5 ΣProperties of quantifiers refer to properties of the corresponding binary functions, e.g.


Note that by definition, + and H are idempotent and both + and × distribute over +, but the rest of the distributions are not true in general. However, if × is idempotent, then × coincides with H and both + and × distribute over ×. Hence, if T is total and × is idempotent the path and fixpoint semantics are equivalent.
We now present an example that shows how both semantics differ. Assume that we are working with the optimization c-semiring ⟨R+, min, +, +∞, 0⟩. Clearly, min does not distribute over +. Suppose we have a transition system with three states s0, s1 and s2, where neither of s1, s2 has a transition and s0 has two transitions: one to s1 and one to s2. Let v be a valuation that maps
every state to 1. I t is easy to see that	Fv)(s0) = min(1, 1) + min(1, 1) = 2,
while µz.min(v,	Xz))(s0) = min(1, 1 + 1) = 1. The semantics of both
formulae differ even if we introduce self-transitions to s1 and s2 to avoid end states.

C-CTL with Negation.
As in c-Lµ, we can inΣcorporat e a negation oΣperator. If w e want to have
the usual equivalences -	Fφ ≡	G-φ and -	[φ1Uφ2] ≡	[-φ1R-φ2], we
need × to be idempotent.

On computing the semantics.
Devising algorithms for our logics is not trivial. First of all, using fixpoint iteration to compute c-Lµ is not always possible; continuous operators are required. Even when fixpoint iteration is possible, it becomes infeasible for
some formulae if the transition system or the c-semiring domain are infinite. For example, consider the evaluation of νz.a × Σ Xz in a transition sys-
tem with just one state s and a transition (s, s), where the c-semiring is the probabilistic one and 0 < a < 1. The value of the formula in s is clearly 0 but its computation requires infinitely many iterations.
While restricting to finite transition systems is reasonable, we cannot ne- glect infinite c-semiring domains.
On the other hand, the fact that when × is not idempotent, the path and fixpoints semantics of c-CTL are not equivalent, avoids the usual bypass of CTL algorithms as fixpoint iterations. Hence, c-CTL requires specific algo- rithms.
In the following lines we show that if we restrict to finite transitions systems and c-semirings where × is idempotent then computing any c-CTL formula can be done by fixpoint iteration where each fixpoint requires |S| iterations only.


Let us denote the concatenation of two paths p, q as pq, where we require
p to be finite and (sp	, sq) ∈ T , i.e. there is a transition from the last state
of p to the first state of q.
A cycle is a path p = qs, where s is equal to sp, the initial state of p. Let us denote with pi the cycle that results from repeating i times cycle p. More precisely, p0 = s and pi+1 = qpi.
We now define some helpful lemmas 6 .
Lemma 4.1  Fφ)(pq) = Fφ)(p)+ Fφ)(q) and Gφ)(pq) = Gφ)(p)× Gφ)(q).
Lemma 4.2 Let p be a cycle qs. Then Fφ)(pi) = Fφ)(p) = Fφ)(q) for any i ≥ 1. If × is idempotent Gφ)(pi) = Gφ)(p) = Gφ)(q) for any i ≥ 1.
Lemma 4.3  Σ Fφ) = Σ F|S|φ). If × is idempotent   Gφ) =   G|S|φ).
LΣemma 4.4ΣIf × is idempotent   Fφ) =   F|S|φ). If × is idempotent
Gφ) =	G  φ).
Proof. We will show by induction that  F|S|φ (s) =  Fiφ (s) for any state s ∈ S and i ≥ |S|. This holds trivially for i = |S|. Assume for induction that the lemma holds for i = n ≥ |S|.
Let p ∈ γ(s) be a path starting from state s.  By definition Fn+1 is
p	p
φ (s0)+ ... + φ (sn).  Now observe that, because the n + 1 > |S|, there
must be at least one state that appears more than once in the prefix sp,... , sp
0	n
of p. There are two cases.

If sp
appears twice in the prefix, i.e. sp
= sp
for at least one 0 ≤ j <

n then  Fn+1φ)(p) is  φ)(sp)+ ... + φ)(sp)+ ... + φ)(sp	)+ φ)(sp ).  Ap-
plying associativity and commutativity of + we have that Fn+1φ)(p) is
p	p	p	p
 φ)(s0)+ ... + φ)(sj )+ φ)(sn)+ ... + φ)(sn−1). Now, since + is idempotent
and φ)(sp) = φ)(sp ) we obtain φ)(sp)+ ... + φ)(sp)+ ... + φ)(sp	) which
is exactly Fnφ)(p).
The other case is when s appears only once in the prefix, i.e. only at the end. Since n + 1 > |S| there must be a cycle in the prefix before sp . Thus,
let us represent the prefix of p by qcq'sp where q,q' are finite paths and c is
a cycle. Consider the path p' = qcω. Clearly, p /= p' and since p ∈ γ(s) then
p' ∈ γ(s). In the rest of the proof we call this path the absorbing path of p.


6 Most of the proofs are in Appendix A. Proofs for lemmas concerning the temporal operator G are omitted since they are similar to the corresponding proofs concerning the temporal operator F, where the main difference is that in the former ones we require × to be idempotent.


Now, let us see the value of Fn+1φ)(p) × Fn+1φ)(p')=
' p
 Fφ)(qcq sn) × Fφ)(qc)	(Definition of F and 4.2)
( Fφ)(qc)+ Fφ)(q'sp )) ×  Fφ)(qc)	(Lemma 4.1)
 Fφ)(qc)	(Absorption law)
 F φ)(p')	(Definition of F and |qc|≤ n)
Absorption holds because × is idempotent 7 . Applying a similar reasoning one can see that Fnφ)(p) × Fnφ)(p') is Fnφ)(p') too.
We now apply induction on γ(s) to show that	 F φ)(p) equals


p∈γ(s)
 F	φ)(p).  The case γ(s) = ∅ is trivial.  Now assume for induc-

tion that the γ(s) = γ' ∪ {p'} and the statement to show holds for γ'. Since
× is associative and commutative	 Fn+1φ)(p) = (	' F	φ)(p)) ×
n+1	'	'
 F	φ)(p ). We distinguish the above discussed two cases for p . In the first
one (the n + 1-st state of p' appears in a previous state of p') we know that
n+1φ)(p') is  F φ)(p').  Applying induction and, again, associativity and
commutativity of × we obtain the desired result. In the second case (the n+1- st state of p' does not appear in a previous state of p') we apply associativity
and get	 Fn+1φ)(p) =	'	''  Fn+1φ)(p)×  '''	' ''  F	φ)(p )

p∈γ(s)
p∈(γ /{p })
p ∈{p ,p }

and
 F φ)(p) = 
'	''  F φ)(p) ×
'''
' '' F φ)(p ), where p

is the absorbing path of p. Using the above results (  '''	'  ''  F	φ)(p ) = 
 Fn+1φ)(p'')) and  '''	' '' F φ)(p ) = F φ)(p ), associativity of × and

the induction hypothesis we obtain 

p∈γ(s)
 Fnφ)(p) = 
 F	φ)(p).

Now applying the first induction hypothesis (  Fnφ =   F|S|φ ) we conclude that the lemma holds.	 
Lemma 4.5 If × is idempotent  κ[φ1Uφ2]) =  κ[φ1U|S|φ2]) and  κ[φ1Rφ2]) =
 κ[φ1R  φ2]).
Theorem 4.6 If × is idempotent, S is ﬁnite and T total, any c-CTL formula φ can be computed by using at most |S| iterations provided that any subformula of φ has been already computed.
Proof. We give the proof for c-CTL formulae κTφ. For the rest of the formu- lae the proof is similar. By Lemma 4.4 we know that κT|S|φ = κT|S|+1φ and by Theorem 3.1 we know that  κFkφ  = τk(0), where τ is λy. φ+κXy .
Hence, τ |S|(0) = τ |S|+1(0) which means that the fixpoint is achieved at least
1	1
in the |S|-th iteration.	 

7 Since × is idempotent it coincides with H. The greatest lower and least upper bound operator of a lattice satisfy the absorption law.


Observe that the fixpoint formula corresponding to any c-CTL formula φ, i.e. the one induced by the path semantics of c-CTL, is a formula in which no variable appears free under the scope of more than one fixpoint operator. In other words, in every such fixpoint formula µz.φ1+κXz, νz.φ1 × κXz, µz.φ2+(φ1 × κXz) or νz.φ2 × (φ1+κXz) subformulae φ1, φ2 are closed. This implies that we can compute the fixpoints inside a formula starting with the innermost ones and ending with the outtermost ones as sketched in the algorithm below.
Algorithm eval (φ)
Input: A c-Lµ formula φ corresponding to a c-CTL formula.
Output: A valuation.
switch φ do
case a,v return φ;
case φ1+φ2 return eval(φ1) ⊕ eval(φ1); case φ1 × φ2 return eval(φ1) ⊗ eval(φ1); case f (φ1,... , φn)
v0,... , vn := eval(φ1),... , eval(φn);
foreach s ∈ S do v(s) := f (v0(s),... , vn(s));
return v;
case κXφ1
v1 := eval(φ1);
foreach s ∈ S do v'(s) := κ(s,s')∈T v1(s');
return v ;
case µz.φ1+κXz
v := 0; v1 := eval(φ1);
repeat  v' := v;  v := eval(v1+κXv')  until v' = v;
return v;
case νz.φ1 × κXz
/* similar as above */
case µz.φ2+(φ1 × κXz)
v := 0; v1 := eval(φ1); v2 := eval(φ2);
repeat  v' := v;  v := eval(v1+(v2 × κXv'))  until v' = v;
return v;
case νz.φ2 × (φ1+κXz)
/* similar as above */
end
Let tf denote the highest time complexity among all functions f ∈ F and let t+, t× respectively denote the time complexity of + and ×.


The worst-case c-CTL formula is φ = κ[f (v0,... , vk, φ1)Uvk+1], where k is O(1) and φ1 has the same form or is an atomic valuation. The corresponding fixpoint formula is µ.vk+1+(f (v0,... , vk, φ1) × κX).
Observe that such a formula has O(|φ|) fixpoints, where |φ| denotes the length of φ. The time required for computing φ is the time required to compute φ1 plus the time required to compute f , which is |S|· tf plus |S| times the time required to perform an iteration which is |S|· (t+ + t×) (time to compute + and × for each state) plus |S| + |R|· tκ (time to compute κX for each state). The resulting time complexity is |φ|·(|S|·tf +|S|·(|S|·(t+ +t×)+|S|+|R|·tκ)).
Assuming tf ,t+ and t× to be O(1) the overall complexity of the algorithm is O(|φ| × |S|3). Nevertheless, the complexity of computing f , + and × depends on the concrete c-semiring. In common c-semirings (optimization, probabilistic, fuzzy, boolean, etc.) + and × can be computed in constant time. However, in some cases the problem seems unfeasible. Take for example, the power set of a c-semiring which domain is infinite. The result is a c-
semiring where elements of the domain are possibly infinite sets. Storing and manipulating such elements might be unfeasible.

Applications
Graph Problems.
Although our semantics is specially tailored for transition systems and hence, to reason about maximal paths of the underlying graph, there are still a lot of graph problems that can be expressed using our c-semiring logics. Reachability problems, for example, can be represented by using a set-based
c-semiring ⟨2N , ∪, ∩, ∅,N ⟩ and interpreting the graph (N, E) as a transition system. Formula equivalently Σ Fv is used to represent the set of nodes that
can be reached from each node, where v ∈ V assigns to each node u the set
{u}.
Path optimization problems, where the cost of a path is the sum of the (non-negative) costs associated to the nodes of the path can also be expressed. We show the simplest case: one optimization criteria and one goal. Consider a cost c-semiring C = ⟨R+, min, +, +∞, 0⟩. Let v2 ∈ AV be a valuation, such that v2(s) is the cost associated with s if s is a target node, and ∞ otherwise. Moreover, let v1 ∈ AV simply assignΣthe cost of a node to the corresponding
state. The reader should check that	(v1Uv2) represents the minimal cost to
reach a target node.
Representing multi-criteria optimization problems is also possible, but re- quires to use a c-semiring based on the Hoare power domain of the Cartesian product of the various optimization c-semirings as explained in [6].


Boolean Model Checking.
Our approach can be specialized to traditional model checking as follows. As c-semiring we use the boolean c-semiring ⟨{true, false}, V, Λ, false, true⟩ and as transition system a c-semiring transition system ⟨S, T ⟩, where S and T are the usual state and transition sets. For representing the set of atomic propositions we use valuations that assign true to states where the proposition
is defined and false to the rest.
Our framework captures other boolean approaches based on multi-valued logics. Multi-valued CTL [8] is defined over quasi-boolean algebra, which a finite distributive lattice with a negation operator. It can be shown that given a quasi boolean algebra ⟨A, H, H, ч⟩, the algebraic structure ⟨A, H, H, ⊥, T⟩ with ⊥ and T denoting the bottom and top elements of the lattice is a c- semiring where the multiplicative operation is idempotent.

Discounted model checking.
Roughly speaking, discounted model checking [10,11] weights events ac- cording to their distance to the present state, i.e. along a path s0, s1,... the evaluation of a formula in si is multiplied by ci, where c is the a discount- ing factor between 0 and 1. Discounted model checking of transition systems can be performed using c-semiring µ-calculus as follows. The c-semiring is
⟨[0, 1], max, min, 0, 1⟩, while a transition system is represented as previously
explained for model checking, where for each proposition r, we have a valua- tion vr. DCTL is a discounted version of CTL. In addition to min and max, it uses additional operators over [0, 1], namely —, ·, + and +c, which can be represented by functions in F . The temporal (discounted) operators of DCTL
are c, c, ∆c, respectively correspond to the application of min, max and av- erage to the discounted values of the states in a path. The semantics of DCTL for transition systems can be described with c-Lµ by using a direct tranΣslation
of the fixpoint semantics of DCTL. For instance, E  cφ ≡ µz.φ+(0 +c	Xz)
and 6 cφ ≡ µz.φ+(0 +c	Xz).

Model Checking with Resources.
Reasoning about resource constraints [7] is another potential field of ap- plication of our framework. Consider the simple case in which the system consumes a certain amount of energy in every state. We might be interested in knowing whether power consumption does not exceed a certain value. If we
use the c-semiring ⟨R+, min, max, ∞, 0⟩, and let v(s) denote the power con- sumption at state s, then formula Σ Gv evaluated in a state s0 represents the
maximal power consumption of optimal execution of the system starting at
s0.

Conclusions and Future Work
We have presented extensions of two well known temporal specification for- malism: CTL and the µ-calculus. While the original logics are defined over the boolean domain, our extensions are defined over the domain of a c-semiring, an algebraic structure that captures many problems.
We have defined syntax and semantics of our logics over transition systems, showing that the classical connection between CTL and the µ-calculus breaks when the multiplicative operation is not idempotent or there are end states in the system. The main consequences are two: the expressivenesses of our logics may be are incomparable and computing each logic requires different algorithms. We have shown that model checking c-CTL when the multiplica- tive operation is idempotent and restricting to finite-state transitions can be done by fixpoint iteration, where each fixpoint requires a number of iterations proportional to the number of states.
In current work we are devising solutions for cases for other fragments of our logics. Future avenues also include extending the semantics to more general formalisms, extending modal logics for WAN applications with QoS properties [12] and defining observational equivalences and preorders.

Acknowledgement
The authors wish to thank the anonymous referees for their fruitful criticism.

References
R. Alur, C. Courcoubetis, and D. Dill. Model-checking for real-time systems. In 5th Annual IEEE Symposium on Logic in Computer Science (LICS’90), pages 414–425. IEEE Computer Society Press, 1990.
C. Baier and E. Clarke. The algebraic mu-calculus and mtbdds. In Proc. 5th Workshop on Logic, Language, Information and Computation, (WoLLIC’98), pages 27–38, 1998.
S. Bistarelli, H. Fargier, U. Montanari, F. Rossi, T. Schiex, and G. Verfaille. Semiring-based CSPs and valued CSPs: Frameworks, properties, and comparison. CONSTRAINTS, pages 199–240, 1999.
S. Bistarelli, H. Fargier, U. Montanari, F. Rossi, T. Schiex, and G. Verfaille. Semiring-based constraint logic programming: Syntax and semantics. ACM Transactions on Programming Languages and Systems (TOPLAS), 23(1):1–29, January 2001.
S. Bistarelli, U. Montanari, and F. Rossi. Semiring-based constraint satisfaction and optimization. Journal of the ACM, 44(2):201–236, March 1997.
S. Bistarelli, U. Montanari, and F. Rossi. Soft constraint logic programming and generalized shortest path problems. Journal of Heuristics, 8(1):25–41, January 2002.
A. Chakrabati, L. de Alfaro, Th. A. Henzinger, and M. Stoenlinga. Resource interfaces. In Third International Conference on Embedded Software (EMSOFT’02), number 2855 in Lecture Notes in Computer Science, pages 117–133. Springer, 2003.


M. Chechik, S. Easterbrook, and A. Gurfinkel. Multi-valued symbolic model-checking. ACM Transactions on Software Engineering and Methodology, 2003. To appear.
E. M. Clarke, O. Grumberg, and D. A. Peled. Model Checking. MIT Press, 1999.
L. de Alfaro. Quantitative verification and control via the mu-calculus. In Proceedings of 14th International Conference on Concurrency Theory, volume 2761 of Lecture Notes in Computer Science, pages 102–126. Springer, 2003.
L. de Alfaro, M. Faella, Th. A. Henzinger, R. Majumdar, and M. Stoelinga. Model checking discounted temporal properties. In Tools and Algorithms for the Construction and Analysis of Systems (TACAS), volume 2988 of Lecture Notes in Computer Science, pages 77–92. Springer, 2004.
R. de Nicola and M. Loreti. A modal logic for mobile agents. ACM Transactions on Computational Logics, 2004. To appear.
M. Huth and M. Z. Kwiatkowska. Quantitative analysis and model checking. In Logic in Computer Science, pages 111–122, 1997.
A.L. McIver and C.C. Morgan. Games, probability and the quantitative µ-calculus. In Logic Programming, Artiﬁcial Intelligence, and Reasoning (LPAR’02), number 2514 in Lecture Notes in Computer Science, pages 292–310. Springer, 2002.
R. De Nicola, G. Ferrari, U. Montanari, R. Pugliese, and E. Tuosto. A formal basis for reasoning on programmable QoS. In Nachum Dershowitz, editor, International Symposium on Veriﬁcation (Theory and Practice), number 2772 in Lecture Notes in Computer Science, pages 436–479. Springer, 2003.
H. Seidl. A modal mu-calculus for durational transition systems. In LICS’96, pages 128–137, 1996.
A. Tarski. A lattice-theoretical fixpoint theorem and its applications. Paciﬁc Journal of Mathematics, 1955.

A  Proofs

Lemma A.1 If - is a negation operator then -0 = 1 and -1 = 0.
Proof. For all a ∈ A we have -a = -(0 H a) since 0 is the unit element of H. Applying the definition of - we know that -(0 H a) = -0 H -a. It is easy to see that for all a ∈ A we have -a = -0 H -a exactly when -0 is 1.
Using this result -1 is --0, which equals 0 by definition of -.	 Lemma A.2 - Σi ai =  i(-ai) for all sequences a0, a1,... where ai ∈ A exactly when × is idempotent.
Proof. Direction ⇐ holds trivially, since if × is idempotent, then coincides with . and the duality holds by definition of -.
Observe that -(a+b) = (-a) × (-b) implies -(a × b) = (-a)+(-b). Now if the lemma holds for every sequence it also holds for sequence a, a. This entails
-(a × a) = (-a)+(-a), which is -a, since + is idempotent. Applying - in both sides we get a × a = a for a ∈ A. In other words, × is idempotent.	 
Lemma A.3 ⟨V, ⊕, ⊗, 0), 1)⟩ is a c-semiring.


Proof. Observe that a valuation v can be seen as a vector (v1,... , v|S|) of |S| elements of A, where vi = v(si) and S = {s0, s1,.. .}. Hence, ⟨V, ⊕, ⊗, 0 , 1 ⟩ can be seen as C|S| and we know that the Cartesian product of two c-semirings is a c-semiring [5].	 
Lemma A.4 If × is idempotent then ⊗ is idempotent.
Proof. We need to show that for all v ∈ V , v ⊗ v is v. In more detail we need 6v ∈ V, 6s ∈ S : (v ⊗ v)(s) = v(s), but this is clear since (v ⊗ v)(s) is v(s) × v(s) by definition and, since × is idempotent, this equals v(s).	 
Lemma A.5 Every operator τ : V → V is monotone if every function f ∈ F
is monotone.
Proof. We have to show that v ≤V v' implies τ (v) ≤V τ (v'). Recall that τ is an abbreviation of λz'. φ)e[z'/z]. We use induction of the subformula of φ.
The lemma holds trivially if φ is a closed formula. It is also easy to see that if φ = z the lemma holds since τ (v) is simply v. If φ = z' /= z we know that the value of z' is fixed by e and does not depend on z since we consider closed formulas only.
If φ = φ1+φ2, where at least one of φ1, φ2 is not a closed formula we apply induction to obtain φ1 e[v/z] ≤V φ1 e[v'/z] and φ2 e[v/z] ≤V φ2 e[v'/z]. Since + is monotone we get φ1 e[v/z]+ φ2 e[v/z] ≤V φ1 e[v'/z]+ φ2 e[v'/z]. Hence, the lemma holds in this case. A similar proof can be done for φ = φ1 × φ2 or φ = f (φ1,... , φn), since × is also monotone and we assume every f ∈ F to be monotone.
We now consider the .case when φ = µz'.φ1. Let w0 be the least fixpoint
'
of  φ1)e[v/z], i.e.  w0 =	{v0 |  φ1)e[v/z][v /z'] ≤V v0} and let w  be the
'	V	'	.	0	0
least fixpoint of φ1)e[v /z], i.e. w0 =	V {v0 |  φ1)e[v'/z][v0/z'] ≤V v0}. Sup-
pose that the lemma does not hold, i.e. w0 /≤V w' . Let w'' be w0 HV w' .
0	0	0
Now, because w'' ≤V w0 and φ1 is monotone we have that φ1)e[v/z][w''/z'] ≤V

0
 φ1)e[v/z][w /z'] ≤V w0.  Similarly, since v ≤V v' and w''
≤V  w'
0
we obtain

 φ1)e[v/z][w''/z'] ≤V  φ1)e[v'/z][w''/z'] ≤V  φ1)e[v'/z][w' /z'] ≤V  w' .  The obtained
inequalities imply φ1)e[v/z][w''/z'] ≤V w0 HV w' = w''. Since we assumed that
w0 /≤V w' we know that w'' ≤ w0 and w0 /= w''. Thus w0 cannot be the least
0	0	0
fixpoint of φ1)e[v/z]. This contradicts our assumption.
The case φ = µz'.φ1 is similar.	 
Lemma A.6 If - is a negation operator -(Σ Xφ) ≡ . X-φ for any φ.
Proof. By definition -(Σ Xφ))(s) is - Σ(s,s')∈T φ)(s'). Applying the defini- tion of - we obtain .(s,s')∈T -φ)(s').	 


Lemma A.7 If - is a negation operator then -(µz.φ) ≡ νz.-(φ[-z/z]) for any
φ.

Proof. By definition of µ, -(µz.τ (z)) is - .

{v | v = τ (v)}. Applying the

definition of - we obtain . {-v|v = τ (v)} V
. {-v|-v =

V	.	, which is equal to	V
-τ (v)}. Now, if we let v' = -v we have	V {v'|v' = -τ (-v')} which by definition
of ν is νz.-τ (-z)).	 


Lemma A.8 Fφ ≡ [1Uφ] and Gφ ≡ [0Rφ].
Proof. This is trivial because [1Uφ] (p) is Σ	( φ)(sp) × 


 1)(s ))

Σ	p	i≥0	i
0≤j<i	j

=	i≥0 φ)(si ), which equals Fφ)(p). The proof for the other equivalence is
similar.	 
Lemma A.9 If × is idempotent then -(Σ Fφ) ≡  G-φ, -(Σ Gφ) ≡  F-φ),
-(Σ[φ1Uφ2]) ≡  [-φ1R-φ2]) and -(  [φ1Uφ2]) ≡ Σ[-φ1R-φ2]).
Proof. Recall that, by Lemma A.2 , if × is idempotent then × is the dual of +. We show the proof for dualities -(	Fφ) ≡	G-φ and -(	[φ1Uφ2]) ≡
[-φ1R-φ2]) . The rest of the proofs are similar.
By definition of F, G and -:  -(Σ Fφ)) = - Σ	Σ	 φ)(s ) = 

Σ	p	p
  p∈γ(s)  i≥0	i

p∈γ(s) -
i≥0
 φ)(si )= 
p∈γ(s)
Σi≥0
- φ)(si )= 
p∈γ(s )
i≥0
 -φ)(si )= 
G-φ.

Similarly, -(
[φ1Uφ2])) = -
p∈γ(s)
i≥0( φ2) ×
0≤i<j φ1)) = 

- Σ	( φ	×	φ  ) =		-( φ	×	φ  ) = 
  p∈γ(s)  i≥0( -φ2)+-  0≤i<j φ1)) =  p∈γ(s)  i≥0( -φ2)+ Σ0≤i<j -φ1)) = 

Lemma A.10 + distributes over × iff × is idempotent.
Proof. Direction ⇐ is shown in [5]. We show the opposite direction. Assume that + distributes over ×. Then, for all a ∈ A we have a+(a × a) = (a+a) × (a+a), which is a × a since + is idempotent. By definition of ≤S, this means that a ≤S a × a. On the other hand, a × a ≤! a because × is intensive. It follows that a equals a × a for all a ∈ A. Hence, × is idempotent.	 

Proof. (of Theorem 3.3)
Let τ be λy. φ2+(φ1 × κXz) . For k = 1 it is easy to see that κ[φ1Ukφ2] = τk(0). More precisely, κ[φ1U1φ2] (s) is κp∈γ(s) φ2 (s), while τ (0) is φ2 (s). Since κ is idempotent, the theorem holds for k = 1.
Assume for induction that κ[φ1Unφ2]) = τn(0), then applying τ to both


sides of the equality we get τ ( κ[φ1Unφ2])) = τn+1(0). But τ ( κ[φ1Unφ2])) = 
= φ2+(φ1 × κX κ[φ1Unφ2]))(s) (By def. of τ )

= φ2)(s)+( φ1)(s) × κp∈γ(s) Σ	( φ2(sp)) × 
 φ1)(s )))

1≤i<n+1	i
(Various def.)
= φ2)(s)+κp∈γ(s)( φ1)(s) × Σ	( φ2(sp)) × 
1≤j<i	j


 φ1)(s )))


(× distr. over κ)
1≤i<n+1	i
1≤j<i	j

= φ2)(s)+κp∈γ(s)(Σ
( φ1)(s) × φ2(sp)) ×	 φ1)(s )))


(× distr. over +)
1≤i<n+1
i	1≤j<i	j

= φ2)(s)+κp∈γ(s)(Σ
( φ2(sp)) × 
 φ1)(s )))


(× distr. over ×)
1≤i<n+1	i
0≤j<i	j

= κp∈γ(s)( φ2)(s)+ Σ	( φ2(sp)) × 
 φ1)(s )))

1≤i<n+1	i
(+ distr. over κ)
0≤j<i	j

= κp∈γ(s)( φ2)(s)+ Σ
( φ2(sp)) × 
 φ1)(s )))



0≤j<0
0≤i<n+1	i
 φ1)(sj ) = 1)
0≤j<i	j

=  κ[φ1Un+1φ2])
(Various def.)

Proof. (of Theorem 3.4)
The proof is similar to the previous one. Note that in the previous one we use the fact that × distributes over +. Since we have the symmetric case we need + to distribute over ×, but this is equivalent to requiring × to be idempotent.	 
Proof. (of Lemma 4.1)
p	p	q
 Fφ)(pq) is  φ)(s0)+ ... + φ)(s|p|−1)+ φ)(s0)+	Applying associativity of
+ and the definition of Fφ) we obtain Fφ)(p)+ Fφ)(q).	 
Proof. (of Lemma 4.2)
BΣy Lemma 4.1 and associativity of + we have that  Fφ)(pi) is equal to
(	1≤j≤i Fφ)(q))+ Fφ)(s). Since + is idempotent we obtain Fφ)(q)+ Fφ)(s).
Applying Lemma 4.1 again this equals Fφ)(p).
Since s coincides with the first state of p we have φ)(sp) = φ)(s) and +


is associative, commutative and idempotent one can easily see that Fφ)(p) equals Fφ)(q).	 
Proof. (of Lemma 4.3)
Let us denote with reach(s, k) the set of states that are reachable from s
through at most k transitions. Since + is idempotent, associative and com-
mutative then Fkφ)(p) = Σ '	p	p	 φ), i.e. the addition of φ)(s ) for
s ∈{s0 ,...,sk−1}
all distinct states s' in the prefix of length k of path p. Hence, it is easy to see
that  Σ Fkφ)(s) = Σ	Σ '	p	p	 φ) is Σ '	 φ)(s ), i.e. the
addition of φ (s') for all distinct states s' that are reachable from s in at most k transition. Since for any k > |S| we know that every state reachable from s is reachable in at most |S| transitions we have reach(s, k) = reach(s, |S|). Hence  Fφ) =  F|S|φ).	 
What follows is the proof of Lemma 4.5. We abbreviate (	 φ1)(si ))×
p	p	p
 φ2)(sj ) with tp(s0 ... sj ) in the following. We call it a term. Observe that
 φ1Ukφ2) is	tp(sp ... sp). We first define some helpful lemmas.
Lemma A.11 Let p be an inﬁnite path such that sp = sp for some 0 ≤ j < i.
i	j
Then [φ1Ui+1φ2])(p) = [φ1Uiφ2])(p).
Proof. Observe that  [φ1Ui+1φ2])(p) = [φ1Uiφ2])(p)+tp(sp ... sp). Because
sp is exactly one sp with j < i we have a term tp(sp ... sp) in [φ1Uiφ2])(p). By
absorption tp(sp ... sp)+tp(sp ... sp) is tp(sp ... sp). Hence, [φ1Ui+1φ2])(p) = 
 [φ1U φ2])(p).	 
Lemma A.12 Let p = p'cω be a path such that c = qs is a cycle. Then

 [φ1U φ2])(p) = [φ1U
|p'q|
φ2])(p) for every k ≥ |p'q|.

Proof. See that Lemma A.11 holds for every k ≥ |pq|.	 
Lemma A.13  Let p be an inﬁnite path such that sp = sp for some 0 ≤ i < j.
i	j

Let p' be a path sp ... sp  cω, where we c = sp ... sp. For every preﬁx p'
of p'

0	i−1	i	j	1
with |p'| < j, there is a preﬁx p1 of p such that tp(p' ) = tp(p1).
Proof. For every prefix of p' of length less than j there is an identical prefix of p since, up to the j-th state both paths are equal.	 
Proof. (of Lemma 4.5)
We give the proof for temporal operator U and path quantifier κ =	. The rest of the proofs a similar.
We proof by induction that  [φ1Ukφ2] =  [φ1U|S|φ2] for k ≥ |S|. This holds trivially for k = |S|. Assume for induction that it holds for k = n ≥ |S|. We shall see that it holds for k = n + 1.


Consider a path p ∈ γ(s) and its n + 1-st state. There are two cases: if it coincides with a state preceding it in p we know that  [φ1Un+1φ2])(p) = 
 [φ1U φ2])(p) by Lemma A.11.
The second case is when the n + 1-st state does not coincide with any proceeding state. Since n + 1 > |S|, path p contains at least one cycle and,

thus, we know that p = sp ... sp ... sp ... sp .. ., where sp = sp
for at least

0	i	j	n	i	j
two i, j such that 0 ≤ i < j < n. Let p' be the path sp ... sp  cω, where we

c = sp ... sp. Clearly, p' /= p and p' ∈ γ(s).
0	i−1

i	j
 [φ1U	φ2])(p ) × [φ1U	φ2])(p) = (by Lemma A.12.)
 [φ1U φ2])(p ) × [φ1U	φ2])(p) = 
(× idempotent implies + distributes over ×.)
( [φ1Ujφ2])(p') × [φ1Unφ2])(p))+( [φ1Ujφ2])(p') × tp(sp ... sp )) =


p	p	'
0	n
p'	p'

(δ = {tp(s0 ... sl ) | 0 ≤ l < n}, δ = {tp' (s0 ... sl ) | 0 ≤ l < j})
(Σ	t × Σ	t)+(Σ	t × t (sp ... sp )) =

t∈δ'
t∈δ
t'∈δ'
p  0	n

(By commutativity and associativity of +. Lemma A.13 where t0 = t' )

(Σ	'
t × Σ
t)+(Σ
' t × t (sp ... sp ))+

t∈(δ' /{t0 }
t∈(δ/{t0 })
t∈(δ' /{t0 }
p  0	n

((t' × t0)+(t' × tp(sp ... sp ))) =
0	0	0	n
( × is idempotent (thus t' × t0 = t' ) and absorption law. )

(Σ	'
t ' × Σ
0	0
t)+(Σ

'  t × t (sp ... sp ))+(t' × t ) = 

t∈(δ' /{t0 } p
t∈(δ/{t0 })
t'∈(δ' /{t0 }
p  0	n	0	0

(By commutativity and associativity of +.)

(Σ	t × Σ
t)+(Σ
'	t × t (sp ... sp ))

t∈δ'
t∈δ
t'∈(δ' /{t0 })
p  0	n

Since this holds for every t' ∈ δ' and δ' is finite, we can repeat this rea-
soning and conclude that ( [φ1Ujφ2])(p') × [φ1Unφ2])(p))+( [φ1Ujφ2])(p') ×
tp(sp ... sp )) is just  [φ1Ujφ2])(p') × [φ1Unφ2])(p).
Hence,  [φ1Un+1φ2])(p')× [φ1Un+1φ2])(p) =  [φ1Unφ2])(p')× [φ1Unφ2])(p).
Applying this results in an inductive reasoning on γ(s) as in proof of lemma 4.4 one can show that	[φ1Un+1φ2]) is	[φ1Unφ2]).
Finally applying the first induction hypothesis, namely	[φ1U φ2] =
|S|
[φ1U  φ2] we arrive to the desired result.	 
