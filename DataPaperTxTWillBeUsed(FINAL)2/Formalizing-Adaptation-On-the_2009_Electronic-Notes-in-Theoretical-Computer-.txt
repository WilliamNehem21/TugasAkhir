

Electronic Notes in Theoretical Computer Science 255 (2009) 23–44
www.elsevier.com/locate/entcs
Formalizing Adaptation On-the-Fly
S. Andova a, L.P.J. Groenewegen 1,b, J. Stafleu b & E.P. de Vink a
a Department of Mathematics and Computer Science, TU/e, Eindhoven, the Netherlands
b FaST Group, LIACS, Leiden University, The Netherlands

Abstract
Paradigm models specify coordination of collaborating components via constraint control. Component McPal allows for later addition of new constraints and new control in view of unforeseen adaptation. After addition McPal starts coordinating migration accordingly, adapting the system towards to-be collaboration. Once done, McPal removes obsolete control and constraints. All coordination remains ongoing while migrat- ing on-the-fly, being deflected without any quiescence. Through translation into process algebra, supporting formal analysis is arranged carefully, showing that as-is and to-be processes are proper abstractions of the migrating process. A canonical critical section problem illustrates the approach.

Introduction
Coordination language Paradigm [1] models the dynamics of collaborating com- ponents. Collaboration is specified by loosely coupling detailed local dynamics of participants to protocol dynamics via role dynamics. In a two-sided way, a role dynamically imposes a current constraint both on a participant’s next steps (phase) and on a protocol’s next steps (trap). Figure 1 gives such collaborations in UML 2.0 style as dashed ovals.

(a)







Fig. 1. Collaboration, protocol, roles, participants and conductors.
In Figure 1a, Collaboration presents the general structure of Paradigm collabora- tions. Participants contribute via Roles, in turn composed into a Protocol by syn- chronizing role steps. Conductors can be involved too, recognizable by a thin box across the protocol border. A Conductor conducts synchronization of role steps in a single step of the protocol. In UML 2.0 dynamic consistency is still problematic, see [14,12]. Particularly for general UML collaborations, dynamic consistency be- tween participants, roles and collaboration interaction is not clear. If, moreover,

1 Corresponding author, email luuk@liacs.nl.

1571-0661© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.023

such a collaboration has to change, dynamic consistency is even more problematic, particularly so during migration. For a similar reason, the notion of quiescence has been introduced [13] for adaptive systems: a system part, having to change while the system is ongoing, is isolated first from its environment, then it is changed, e.g. by replacing it, and finally, the part in its renewed form is reconnected. Thus, quies- cence circumvents dynamic consistency problems in ongoing collaborations during the actual change, by separating a part from what remains ongoing.
Paradigm models for collaborations are dynamically consistent [9,1]: so-called phase and trap constraints guarantee consistency between a Participant and any Role of it (vertical consistency); so-called consistency rules, defining a Protocol, guarantee consistency between the Roles and the Conductors (horizontal consis- tency). Interestingly, adaptation in Paradigm can be formulated as coordination of a once-only migration collaboration from ongoing as-is collaboration to to-be col- laboration aimed at. In particular, migration can be done without any quiescence, thus maintaining dynamical consistency before, during and after migration. Merely structurally, Figure 1b visualizes a schematic and simplified, far from general mi- gration example: both as-is and to-be collaboration, named Coll, are identical, with only one participant, one role, and one conductor. (Though not specified in the –merely structural– diagram, their as-is and to-be dynamics do differ.) In addition, a separate collaboration Evolution has every participant and every conductor of Coll as participant, via one separate role each. A special but generally applicable com- ponent McPal is involved too 1 , both as participant and as conductor of Evolution. Its specialty lies in its dynamics.
McPal’s dynamics and the interplay thereof with the larger Paradigm model are organized as follows. Initially, as long as a given as-is coordination situation re- mains stable, a Paradigm model specifies and performs as-is coordination between model components with their as-is dynamics ongoing. Nevertheless, special com- ponent McPal is in place in so-called hibernating form, not involved in the ongoing as-is coordination at all, but having the ability to extend the model with to-be coordination as well as with migration coordination from as-is to to-be. Only after such an extension has been specified well and subsequently installed, McPal awakes from hibernating to start adapting dynamics and coordination gradually, from as-is into to-be, as specified in terms of the migration coordination just added. Once done, McPal retires into hibernation, removing model specification parts no longer needed, while the to-be coordination situation remains stable until further notice, as the Paradigm model now specifies and performs to-be coordination between its components with their to-be dynamics ongoing. In fact, we have a form of quies- cence for McPal. However, activity of other components is not interrupted. Thus, the quiescence of McPal is mirrored, as McPal is active during migration only.
Process algebra (PA) provides a specification formalism for describing Paradigm models in a precise and structural way [1]. Collaborating components are repre- sented in PA by recursive specifications. Dynamic constraints and consistency rules are reflected in the synchronizing function of the parallel operator of the process

1 The name McPal is short for Managing Changing Processes Ad Libitum.

algebra we consider, defining how components communicate. Thus, a Paradigm model of an adapting system, including the special component McPal, is translated into PA. So, using a well established abstraction technique of PA, we can formally analyze the adaptation process. For instance, we can prove that as-is collabora- tion indeed migrates to to-be collaboration. In particular, the PA model makes the adaptation dynamics explicit. Therefore, for every migration trajectory, progress properties can be verified.
To clarify the above, the paper has four sections. Section 2 recapitulates Para- digm through a nondeterministic critical section solution, with McPal in place, going to migrate the example. In addition, the section addresses the suitability of the same McPal for general unforeseen migration of arbitrary Paradigm models. In Section 3, PA analysis of the adaptation is presented, for the example first and subsequently for the general case. Section 4 closes with comparing McPal to earlier versions, with variants of McPal in form and performance, with related work and with ideas for future work.

On-the-fly migration through coordination
In view of explaining McPal, this section first repeats Paradigm’s basic notions. Second, it presents a concrete as-is Paradigm model, with McPal in place in hiber- nating form. Third, it presents a concrete to-be model, with McPal returned to hibernating. Fourth, given the to-be goal, it presents migration coordination from as-is to to-be, conducted by McPal, only while not hibernating. Fifth, we abstract from the example by discussing general adaptation of Paradigm models through migration coordination conducted by McPal, with its hibernating form the same. Except for McPal we shall keep our explanation brief.
The following definitions present Paradigm’s basic notions: state-transition di- agram, phase, (connecting) trap, partition and global process, see also [1].
A state-transition diagram (STD ) is a triple ⟨ST, AC, TS⟩ with ST the set of states,
AC the set of actions and TS ⊆ ST × AC × ST the set of transitions or steps. A step
(x, a, x') ∈ TS, denoted by x →a x', is said to be from x to x'.
A phase of STD Z = ⟨ST, AC, TS⟩ is an STD S = ⟨st, ac, ts⟩ such that st ⊆ ST, ac ⊆ AC and ts ⊆{ (x, a, x') ∈ TS | x, x' ∈ st,a ∈ ac }.
A trap t of phase S = ⟨st, ac, ts⟩ of STD Z is a non-empty set of states t ⊆ st
such that x ∈ t and x →a x' ∈ ts imply x' ∈ t. If t = st, trap t is called trivial.
A trap t connects phase S of Z to another phase S' = ⟨st', ac', ts'⟩ of Z if t ⊆ st'.
Such connectivity is called a phase transfer, denoted by S →t S'.
A partition π = { (Si, Ti) | i ∈ I } of STD Z is a set of pairs (Si, Ti) of a phase Si
of Z and a set of traps Ti of Si. A role or global STD at the level of partition π
is an STD Z(π) = ⟨GST, GAC, GTS⟩ with GST ⊆ { Si | i ∈ I }, GAC ⊆	i∈I Ti and

GTS ⊆ { Si →t
Sj | i, j ∈ I, t ∈ GAC } a set of phase transfers. Z is called the

detailed STD underlying global STD Z(π), the π-role of Z.

A phase, when being current state of a role, is a dynamic constraint imposed on the detailed STD underlying the role, containing all transitions allowed by the role in that phase. Thus, a detailed transition can only be taken if admitted by each current phase of the various roles assigned. A connecting trap of a phase is a further dynamic constraint committed to by the detailed STD, serving as guard for a phase transfer, often to be carried out in combination with simultaneous phase transfers in other roles.

Fig. 2. Collaborations CSM and Evolution.

The as-is model we want to present, is a variant of the nondeterministic server solution for a critical section problem, with three Workers and with Scheduler serving them, see Figure 2. Each Workeri(CS) role is contributed to collaboration CSM by Workeri. Moreover, Scheduler is involved too, as the only conductor. (Collaboration Evolution is addressed separately below.)
Scheduler


(b)	(c)
Fig. 3. Participant dynamics: (a) Worker (b) Scheduler (c) McPal.
STDs for Workers and Scheduler, covering the as-is situation only, are given in Figure 3ab. Being in as well as going to and leaving state Crit, together constitute a Worker’s critical section activities. Therefore, Figure 4a presents phase NotHaving of a Worker as detailed STD fragment, reflecting a Worker’s allowed dynamics when not having the permission for doing its critical work 2 . Similarly, phase Having reflects a Worker’s dynamics when having that permission. Additional rectangles indicate a phase’ trap, containing the trap’s states: request is connecting to phase Having and done is connecting to NotHaving, paving the way for three roles Workeri(CS), see Figure 4b.


NotHaving
Having
Workeri(CS)


	
(a)	(b)
Fig. 4. CS constraints: (a) phases and traps (b) role for Workeri.

2 For reason of space, state and action names from Figure 3a are not repeated in Figure 4a, but the form of the original is kept in the fragments. Like-wise for later drawings of roles.

Phase1

triv
Phase1
Hibernating







		
Fig. 5. Evol constraints for single Workeri, Scheduler and McPal.
Note, starting states of Workers, of their roles and of Scheduler, pointed at by a dot- and-arrow in UML-style, are consistent. Starting state Free belongs to NotHaving, the ‘starting constraint’. Moreover, Scheduler is supposed to regulate each Worker’s critical section entrance. Thus, in its starting state Idle, with each Worker in NotHaving, it starts refusing permission to each Worker. The question then is, how their combined dynamics stay consistent once started. Informally, Scheduler is giv- ing the permission to Workeri only by going to Helpingi and it withdraws permission by returning to Idle.

Scheduler: Idle
granti
→  Helpingi ∗ Workeri(CS): NotHaving
request
→	Having

proceed
Scheduler: Helping
done

i	→	Idle ∗ Workeri(CS): Having
→ NotHaving

The above two consistency rules let Scheduler conduct the CS roles of the Workers. The roles, by imposing the current phase, in turn dynamically constrain the five detailed steps of each Worker. Some of these steps actually lead to entering a connecting trap. Via such a trap entered, detailed STDs dynamically constrain coordination steps of Scheduler. In general, a consistency rule synchronizes single steps from different STDs: zero or one detailed steps, zero or more role steps and a so-called change clause to update the consistency rules within a protocol. If present in one rule, the role steps together constitute one protocol step. If synchronized with a detailed step of an STD M , this M is referred to as the conductor of that protocol step.
So the first rule says, by its step to Helpingi, Scheduler conducts Workeri’s CS role step to phase Having, provided trap request has been entered within NotHaving. Similarly the second rule says, by returning to Idle, Scheduler conducts Workeri’s CS role to return to NotHaving, provided trap done has been entered within phase Having.

Workeri: Free
begin
→ NonCrit	Workeri: Pre
pickUp
→	Crit	Workeri: Post
finish
→ Free

Worker : NonCrit reserve Pre	Worker : Crit layDown Post
i	→	i	→
The second group has five, more simple rules. No marker ‘∗’ means, isolated detailed steps only, without any synchronization. But current phases do restrict the actual taking of a step. E.g., regarding the third rule, a Worker can do action pickUp only if its current phase is Having as the phase NotHaving does not allow this transition.
Until now we did not take the Evol roles into account. Figure 5bd specifies them in terms of one phase Phase1 each. Each Phase1 does not really restrict underlying

detailed dynamics, as it contains every detailed step, see Figure 5ac. As each role Workeri(Evol) and Scheduler(Evol) starts as well as remains residing in its only global state Phase1, as-is dynamics presented above are not influenced (yet). Moreover, each Phase1 has a trivial trap, intended to be connecting to a next phase unknown as yet, but at least allowing for future interruption at any moment. McPal is in place as conductor of the Evolution protocol, however. See Figure 2. According to Figures 3c and 5ef its detailed STD starts in Observing and its own Evol role starts in Hibernating. The phase Hibernating has trap prepared, intended to be connecting to a next phase unknown for a while, but known indeed when trap prepared, i.e. state StartMigr, is entered, in view of the change clause in the second consistency rule below.

McPal: Observing
wantChange
→	JITting

McPal: JITting
giveOut
→	StartMigr	∗ McPal: [Crs: =Crs + Crsmigr + CrstoBe]
clearUp

McPal: Content	→	Observing ∗ McPal: [Crs: =CrstoBe]
According to the above three consistency rules for McPal’s detailed steps, the first is without any conducting. When in state Observing, McPal can start private prepa- ration of still unknown migration at leisure. Preparation occurs when in JITting, through input –e.g. from a modeler– or through McPal’s own activity. It results in a new Paradigm model, covering a to-be situation, as well as migration trajectories towards it. Thus, the second rule too is without any conducting, but here the change clause couples McPal’s detailed step giveOut to an update of the consistency rules, extending Crs with new rules both for a to-be situation, collected in set CrstoBe, and for a migration situation from as-is to to-be, collected in set Crsmigr. The orig- inal content of Crs consists of the as-is situation as specified through the above ten rules. Thus, a Paradigm model with a hibernating McPal in place is reflective as the model contains its own specification. In addition, it extends its specification while keeping its dynamics unchanged, ongoing as before: McPal’s second rule. The third rule specifies, once migration has been done, by returning to Observing, all model specification fragments obsolete by then, are removed.
The to-be situation aimed at is a variant solution for CSM: pursuing a round robin strategy augmented with more efficient permission withdrawal, by asking for withdrawal sooner and by delaying the necessity to wait for it. Figure 2 remains the same, as collaborations and protocol structures do not change. But detailed STDs for Workers and Scheduler are different, see Figure 6. By spanning as-is, migration and to-be situations together, the figures get less clear however, missing a historical overview in the details. Figure 7abcd alleviates this via Evol phases, traps and roles. It shows in particular, the Workers suddenly get more dynamic freedom as more direct steps from Post towards Pre can be taken, whereas Scheduler exhibits special intermediate dynamics in phase NDetToRoRo before conducting in mere round robin fashion. Note, the round robin fashion emerges from Scheduler’s cycling through states Checkingi, possibly alternated with going to Helpingi if Workeri asks for it.
The CS role of Worker, see Figure 8, changes too: (i) New CS phases and traps must


Free


begin


NonCrit

Worker i

Scheduler
Checking1




pass


Checking2




pass

proceed
pass
Checking3

finish

Post
continue hurry
reserve


Pre
grant	grant	grant
proceed	proceed
Helping1	Helping2	Helping3
proceed	proceed	proceed

layDown

Crit
pickUp

(a)

(b)
switch
Idle
grant1	grant2
grant3

Fig. 6. Detailed STDs for Workers and Scheduler for migration in its entirety.
cover the newly added dynamics in Worker’s Evol phase Phase2. Thus, Without is the new version of NotHaving and With is the new version of Having. (ii) In view of the round robin approach, Interrupt is needed as interrupted form of Without, enabling discrimination between needing permission for critical work or not, on the basis of different traps entered.

Hibernating	ToPhase2
Fig. 7. Evol constraints and role for any participant’s entire migration.
The ten consistency rules below specify this, using cyclic indexing. They belong to the set CrstoBe. Note, some rules from Crs, originally specifying as-is dynamics, are still there.

Scheduler: Checkingi
grant
→ Helpingi  ∗ Workeri(CS): Interrupt
request
→	With

Scheduler: Helpingi
proceed
→	Checkingi+1 ∗
done

triv

Workeri(CS): With → Without, Workeri+1(CS): Without → Interrupt

Scheduler: Checkingi
pass
→ Checkingi+1  ∗

Worker (CS): Interrupt notYet Without, Worker
triv

i	→	i+1(CS): Without → Interrupt


Workeri: Free
begin
→ NonCrit	Workeri: Pre
pickUp
→	Crit	Workeri: Post
finish
→ Free

Worker : NonCrit reserve
layDown
continue

i	→  Pre	Workeri: Crit
→	Post	Workeri: Post
Workeri: Post
→	NonCrit
hurry
→ Pre

Also, the same three rules for McPal discussed above, belong to CrstoBe.
Suggested already in Figure 7e, the STD of McPal, covering migration in its entirety, is given in Figure 9. Apparently, for conducting the migration it has two originally unforeseen detailed steps, leading from StartMigr via StartRoRo to Content. In addition, separating these two unforeseen steps from the three fore- seen steps in Hibernating, role McPal(Evol) has to perform two steps, one swapping from Hibernating to ToPhase2, reflecting ‘awakening’, and the other swapping back, reflecting ‘retiring’, both global steps being unforeseen too as McPal(Evol)’s actual migration phase ToPhase2 was originally unknown. Swapping between McPal’s own Evol phases is specified through two choreography steps without a conductor instead of through orchestration steps having a conductor. According to the choreography, ‘awakening’ comes first, ‘retiring’ comes second. The notion of choreography for Paradigm has been adopted from [17].

∗ McPal(Evol): Hibernating
prepared
→	ToPhase2	∗ McPal(Evol): ToPhase2
migrDone
→	Hibernating



NotHaving


triv
Having
done

(a)

(b)

request
Having
done


done
Interrupt
notYet triv

request
With
done

Without
triv
Interrupt	With
triv
NotHaving triv
Without




notYet

request
Worker i(CS)

Fig. 8. CS constraints and role for any Worker’s entire migration.

Fig. 9. STD of McPal for the entire migration.
The two choreography rules above together with the six rules below constitute the set Crsmigr. Two rules with Scheduler conducting, address Scheduler’s first step to whatever Checking state, thereby synchronously and consistently transferring all Workers from their as-is CS phases to their to-be CS phases.
switch	triv

Scheduler: Idle
→ Checking1 ∗ Worker1 (CS): NotHaving → Interrupt,

triv	triv
Worker2(CS): NotHaving → Without, Worker3 (CS): NotHaving → Without

proceed
Scheduler: Helping	Checking
done

i	→
Worker
triv
i+1 ∗ Workeri(CS): Having
→ Without,
triv

i+1(CS): NotHaving → Interrupt, Workeri−1 (CS): NotHaving → Without
Four rules have McPal coordinating migration by conducting Evol phase transfers of all other participants. In the first rule, McPal starts Scheduler migrating and, simultaneously, it transfers the three Workers to their new full dynamics. As long as Scheduler has not transferred their as-is CS phases to to-be ones, such new dynamics will remain excluded, although allowed by McPal already. The remaining three rules transfer Scheduler from migrating to round robin scheduling only, depending

on whether Worker1 has arrived in whatever new CS phase; the other two Workers then must have arrived there too.
McPal: StartMigr kickOﬀ StartRoRo ∗
triv	triv
Scheduler(Evol): Phase1 → NDetToRoRo, Worker1(Evol): Phase1 → Phase2 ,
triv	triv
Worker2(Evol): Phase1 → Phase2 , Worker3 (Evol): Phase1 → Phase2
phaseOut

McPal: StartRoRo	→	Content ∗
ready

triv

Scheduler(Evol): NDetToRoRo → Phase2, Worker1(Evol): Without → Without
phaseOut

McPal: StartRoRo	→	Content ∗
ready

triv

Scheduler(Evol): NDetToRoRo → Phase2, Worker1(Evol): Interrupt → Interrupt
phaseOut

McPal: StartRoRo	→	Content ∗
ready

triv

Scheduler(Evol): NDetToRoRo → Phase2, Worker1(Evol): With → With
Please note, it is on the basis of the constraining character of phases and traps, the example of the critical section model with the above McPal succeeds in specifying a self-adapting model via migration coordination, even for unforeseen adaptation. No quiescence of components is necessary, as coordination remains ongoing although changing gradually. Once migration has finished, the original critical section model is working in a completely new way, but McPal, not unlike a catalyst, is still in place, having returned to its original appearance represented by its phase Hibernating only. So far, we have established unforeseen adaptation without quiescence for our nondeterministic critical section example only, migrating to the above round robin solution. We abstract from the example as follows. For the general situation, let an arbitrary, well-defined Paradigm model PM1 be given. Assume, at some later point in time, we prefer to have another well-defined Paradigm model PM2 instead of PM1. Moreover assume, once PM2 is known, another well-defined Paradigm model PM1to2 can be constructed, specifying how to migrate as smoothly as required from PM1 performance to PM2 performance. Then, Paradigm model PM1 extended with
(i) the above McPal in hibernating form and with (ii) trivially suitable Evol roles
for each component, can coordinate its own migration to the originally unforeseen model PM2 performance, with McPal in place afresh, in hibernating form again and with new but similar trivially suitable Evol roles for each component. This means in particular, after whatever migration done in this manner, McPal is still in place for yet another unforeseen adaptation via yet another migration coordination done in this manner.
So, in view of modeling unforeseen change, the special component McPal is included in all Paradigm models. During the original, stable collaboration stage of the executing Paradigm model, McPal is stand-by only, not influencing the rest of the model at all. This is McPal ’s hibernating form. But, by being there, McPal provides the means for preparing the migration as well as for conducting its coordination accordingly. To that aim, connections between McPal and the rest of the model are in place, realizing rudimentary interfacing for later purposes; in Paradigm terms, one Evol role per component without dynamics, as there is exactly one global state as nonrestrictive phase per Evol role. As soon as, via McPal, the new way of working

as well as the migration towards it have been developed, McPal takes step giveOut thereby installing the relevant extension to the original model. Trap prepared of phase Hibernating having been entered by then, a choreography step is taken as Evol protocol step, only now enabling McPal to conduct the various Evol roles from their once stable Phasem, for some m say, eventually to a next, until-further-notice stable Phasem+1. In this manner, McPal’s own migration begins through choreography, the migration of the others is started thereafter by McPal as conductor taking a kickOff- like step. Finishing migration is done in reversed order. The others are explicitly left to their new stable collaboration, restricting them to their Phasem+1 phases, by McPal, as conductor, taking a phaseOut-like step, thus reaching a migrDone- like trap. Thereupon McPal ceases to influence the others, as a choreography step transfers role McPal(Evol) back to phase Hibernating. As a last step, the first within phase Hibernating, McPal shrinks the recently extended model, by removing model fragments no longer needed, keeping the new model only, McPal really emerging as a catalyst amidst a completely renewed model.

Process algebra translation of McPal
In this section, McPal and the other example components from Section 2 are ex- pressed as PA processes, following the translation of [1]. Using the translation we formally prove that the system migrates indeed from the as-is to the to-be be- haviour. Moreover, the PA specification can directly be taken as an input for the mCRL2 modelchecker, to be used for further analysis of the migration model.
Recall that the system in migration originally has the as-is dynamics, to become the to-be behaviour once it has migrated. Thus, the Paradigm migration model comprises both, as-is and to-be behaviour, as well as the dynamicity of the migra- tion, McPal included. While the system behaves as as-is only or as to-be only, McPal is in its hibernating form. Hence in either case, the behaviour of each component is constrained by its trivial Evol phase. Thus, the rich complex dynamics of the mi- grating system is restricted, by McPal and the Evol roles, to relatively simple as-is behaviour (and similar for the to-be behaviour). We show that, indeed, the as-is behaviour, SysAsIs, is an abstracted version of the overall behaviour of the migrating system, cf. Theorem 3.1. Theorem 3.3 states the analogue for to-be behaviour with respect to the migrating system. Moreover, the process algebraic compositional mechanisms allow us to take another perspective on the as-is behaviour. Namely, the as-is behaviour (same for to-be) can be considered as a stand-alone system, SWSysAsIs, not “connected” to any McPal and without Evol roles per component, and thus, not in the context of any migration, only as an isolated interacting compo- sition of the relevant components. Nevertheless, we show that the presence of McPal and the Evol roles in the former SysAsIs as-is model does not add any behaviour. Namely we show, by establishing a relation between their PA specifications, that the two as-is models, SysAsIs as a part of the bigger migration model and SWSys as as-is system in isolation, essentially have the same behaviour (Theorem 3.2).
For a full translation, each STD from the Paradigm model is specified as a pro-

cess. Processes are composed into larger systems by means of parallel composition and synchronization. Here we only specify the Scheduler and McPal STDs of the mi- gration model, a Mig suffix in process names relating them to the migration model. The complete mCRL2 code of the migration, as-is and to-be models can be obtained from www.win.tue.nl/∼andova/research/mcrl2 experiments/.
The specification of Scheduler in the migration model is given below. The mi- gration Scheduler mimics both the as-is and the to-be Scheduler (see Fig. 6b). This is made explicit by naming the mimicking transitions nameAsIs and nameToBe, re- spectively. In addition, once conducted by McPal to NDetToRoRo –the right phase at the right time– Scheduler exhibits extended behaviour conducting other compo- nents towards their to-be behaviours. These transitions, typical for the migration model, have the extension Mig. Thus, the proceed transition is now represented by three different transitions: proceedAsIs, proceedMig and proceedToBe. This is essential, as each proceed action synchronizes differently in the three models. While in Paradigm this differentiation is implicit, in the process algebraic translation this has to be made clear. E.g., switch is a migration transition, hence it is denoted by switchMig. As described in [1], to capture vertical consistency, processes are augmented with the actions at?, at!, ok? and ok!. (Via the at communication, in- formation whether a phase transfer can take place is passed from the local to the global level of a process; via the ok communication, information whether a local step is allowed by a current phase is exchanged.) Horizontal consistency is captured by the communication function ‘|’ and process synchronization.
We introduce the following short-hand. For a component C, we use LAct(C) to denote the set of all names of local transitions of that component. For in- stance, LAct(Sch)= { grantAsIs1,... , passToBe3}. LAct(C)↓AsIs denotes the subset of names in LAct(C) tagged as AsIs actions. Thus, LAct(Sch)↓AsIs = {grantAsIsi, proceedAsIsi | i = 1, 2, 3}. Similar for other extensions, ToBe and Mig. Act(C) denotes the set of all actions names in the process algebraic specification of C.
The Scheduler of the migration model is specified as given below. Note, to em- phasize that, via action proceedAsIs, Scheduler conducts the CS roles of Workers (see consistency rules on page 27), we rather write man(proceedAsIs) instead of ok?(proceedAsIs). Similar for other cases of the man actions in the sequel.






SchedulerMig = IdleMig
IdleMig = P man(grantAsIsi) · HelpingMig
i

+ man(switchMig) · CheckingMig1

HelpingMigi = man(proceedAsIsi) · Idle + man(proceedToBei) · CheckingMigi+1 +
man(proceedMigi) · CheckingMigi+1 + at!(HelpingMigi) · HelpingMigi CheckingMigi = man(grantToBei) · HelpingMigi + man(passToBei) · CheckingMigi+1 +
at!(CheckingMigi) · CheckingMigi

The specification of Scheduler(Evol) is
SchedulerEvolMig = SchEvolPhase1TrivMig SchEvolPhase1TrivMig = P ok!(grantAsIsi) · SchEvolPhase1TrivMig +
P ok!(proceedAsIsi) · SchEvolPhase1TrivMig +
i
emp(Phase1, NDetToRoRo, trivMig) · SchEvolNDetToRoRoTrivMig
SchEvolNDetToRoRoTrivMig =	P	ok!(t) · SchEvolNDetToRoRoTrivMig +
t∈LAct(Sch)
P at?(HelpingMig ) · SchEvolNDetToRoRoReadyMig +
P at?(CheckingMig ) · SchEvolNDetToRoRoReadyMig

i
SchEvolNDetToRoRoReadyMig =	P
t∈LAct(Sch)\switchMig
ok!(t) · SchEvolNDetToRoRoReadyMig +

emp(NDetToRoRoReady, Phase2, readyMig) · SchEvolPhase2TrivMig

SchEvolPhase2TrivMig =	P
t∈LAct(Sch)↓ToBe
ok!(t) · SchEvolPhase2TrivMig

Translation of McPal and of McPal(Evol) is done similarly.
McPalMig = McPalObserving McPalObserving = ok?(wantChange) · McPalJITting
McPalJITting = ok?(giveOut) · McPalStartMigr
McPalStartMigr = ok?(kickOff) · McPalStartRoRo + at!(McPalStartMigr) · McPalStartMigr McPalStartRoRo = ok?(phaseOut) · McPalContent
McPalContent = ok?(cleanUp) · McPalObserving + at!(McPalContent) · McPalContent

McPalEvolMig = McPalEvolHibTriv
t∈{wantChange,giveOut,cleanUp}

ok!(ti) · McPalEvolHibTriv +

at?(StartMigr) · McPalEvolHibPrepared
McPalEvolHibPrepared = emp(Hib, Phase2, prepared) · McPalEvolToPhase2Triv McPalEvolToPhase2Triv = ok!(kickOff) · McPalEvolToPhase2Triv +
ok!(phaseOut) · McPalEvolToPhase2Triv + at?(Content) · McPalEvolToPhase2MigDone McPalEvolToPhase2MigDone = emp(Hib, Phase2, migrDone) · McPalEvolHibTriv
The communication function ‘|’ is derived from the consistency rules. As for the translation in general, we put at!(s) | at?(s)= at(s) and ok?(t) | ok!(t)= ok(t). We present further synchronization in three parts, following the consistency rules. The first two communications pertain to the migration process exhibiting as-is behaviour (corresponding to the first two consistency rules on page 27).
grantAsIsi =	man(grantAsIsi) |	ok!(grantAsIsi) | emp(NotHavingi, Havingi, requestAsIs) proceedAsIsi = man(proceedAsIsi) | ok!(proceedAsIsi) | emp(Havingi, NotHavingi, doneAsIs)
The next six clauses reflect what happens while Workers and Scheduler are migrating to their new behaviour. Note, migration of Workers from as-is to the to-be behaviour is clearly marked by moving from NotHaving and Having to Without, Interrupt or

With (corresponding to the last six consistency rules on page 31).
switchMig =	man(switchMig) | ok!(switchMig) | emp(NotHaving1, Interrupt1, trivMig) |
emp(NotHaving2, Without2, trivMig) | emp(NotHaving3, Without3, trivMig) proceedMigi = man(proceedMigi) | ok!(proceedMigi) | emp(Havingi, Withouti, doneMig) |
emp(NotHavingi+1, Interrupti+1, trivMig) | emp(NotHavingi−1, Withouti−1 , trivMig)
kickOff =	man(kickOff) | emp(Phase1, NDetToRoRo, triv) |
emp(Phase11 , Phase21 , triv1) | emp(Phase12 , Phase22 , triv2 ) | emp(Phase13 , Phase23 , triv3 ) phaseOut(Without) = man(phaseOut) | emp(NDetToRoRo, Phase2, ready) | emp(Without1 , Without1 , triv1) phaseOut(Interrupt) = man(phaseOut) | emp(NDetToRoRo, Phase2, ready) | emp(Interrupt1, Interrupt1, triv1 )
phaseOut(With) = man(phaseOut) | emp(NDetToRoRo, Phase2, ready) | emp(With1, With1, triv1 )
The last clauses of the communication function capture the synchronization in the to-be behaviour (corresponding to the first three consistency rules on page 29).
grantToBei =	man(grantToBei) |	ok!(grantToBei)	| emp(Interrupti, Withi, requestToBe) proceedToBei = man(proceedToBei) | ok!(proceedToBei) |
emp(Withi, Withouti, doneToBe) | emp(Withouti+1, Interrupti+1, trivToBe) passToBei =	man(passToBei) |	ok!(passToBei)	|
emp(Interrupti, Withouti, notYetToBe) | emp(Withouti+1, Interrupti+1, trivToBe)

Combining the processes to express their collaboration requires parallel composition only. Thus, the whole migration process conducted by McPal is then specified by
SysMig = ∂ H ( McPalMig  McPalEvolMig  SysMig' )
SysMig' =  i ( WorkerMigi  WorkerCSMigi  WorkerEvolMigi )  SchedulerMig  SchedulerEvolMig
where the encapsulation operator ∂ H enforces all communicating actions to synchro- nize (or yields deadlock otherwise). Similarly, using the translation of the proper STDs, we can derive both as-is behaviours of the service system: as-is in the presence of McPal in hibernation, SysAsIs, and as-is stand-alone service system, SWSysAsIs, of Workers and Scheduler. In the same manner we obtain such results for the to-be behaviours. We thus define
SysAsIs = ∂ H ( McPalAsIs  McPalEvolAsIs  SysAsIs' )
SysAsIs' =  i ( WorkerAsIsi  WorkerCSAsIsi  WorkerEvolAsIsi )  SchedulerAsIs  SchedulerEvolAsIs
and
SysToBe = ∂ H ( McPalToBe  McPalEvolToBe  SysToBe' )
SysToBe' =  i ( WorkerToBei  WorkerCSToBei  WorkerEvolToBei )  SchedulerToBe  SchedulerEvolToBe
For the stand-alone variants we have the following specifications: SWSysAsIs = ∂ H (  i ( WorkerAsIsi  WorkerCSAsIsi )  SchedulerAsIs ) and SWSysToBe = ∂ H (  i ( WorkerToBei  WorkerCSToBei )  SchedulerToBe )


Having formalized the separate components and the systems they compose, we are able to relate the models. See Theorem 3.1 to 3.3 below. The first result states, as long McPal(Evol) is not allowed to perform the choreography step prepared, meaning it cannot start migration, the larger migration system has the same be- haviour as the as-is system, up to branching bisimulation [7,1]. This is speci- fied first by blocking the action prepared and second by abstracting all actions McPal can perform in the Hibernating phase; thus all actions Act(McPalHib) =
{ok(wantChange), ok(giveOut), ok(cleanUp) } are renamed into the silent action τ by means of the abstraction operator τ Act(McPalHib). Note, blocking the phase trans- fer of McPal from Hibernating to ToPhase2, directly disables McPal to execute any action not allowed in the Hibernating phase. Thus, it is sufficient to abstract away only from Act(McPalHib) actions.
Theorem 3.1 SWSysAsIs is branching bisimilar to
τ Act(McPalHib) ◦ ∂ H ( McPalMig  ∂emp( , ,prepared) ( McPalEvolMig )  SWSysMig ).
The theorem is confirmed by the mCRL2 tool set. The second theorem states that both as-is models are equivalent, i.e. McPal in hibernation and the trivial Evol roles of Workers and Scheduler do not essentially change the as-is behaviour.
Theorem 3.2 SWSysAsIs is branching bisimilar to τ Act(McPalHib) ( SysAsIs ).
SWSysToBe is branching bisimilar to τ Act(McPalHib) ( SysToBe ).
Again, mCRL2 confirms the theorem. In view of the next theorem, a specification is interpreted as a labelled transition system (LTS). Every state in an LTS corresponds to a process variable specified. The state space of the parallel composition is the product of the component state spaces, restricted to the subset of the states reach- able from the initial state of the composition. In our example, every reachable state s˜ in the LTS of SWSysToBe is a tuple (s1, s2,... , s7), where si is a state in the LTS of the corresponding i-th component (2 states per Worker, 1 state for Scheduler). For s˜, we write SWSysToBe(s˜). Let S be the set of all (reachable) states of the LTS of SWSysToBe. Let Si ⊆ S, i = 1, 2, 3, contain all states in S having currently SchedulerToBe in state CheckingToBei, WorkerCSToBei in state InterruptTrivToBei, and for j /= i, WorkerCSToBej in state WithoutTrivToBej. Finally, let NoToBe, de- fined as Act(SysMig) \ Act(SysToBe), denote the set of actions from SysMig not in SysToBe.
Theorem 3.3, the last result, states that once the migration has been started,
i.e. after McPal has executed the kickOff step, the migration process will evolve into to-be behaviour, independent of what the process was executing before. This is specified by hiding all NoToBe actions, renaming them into τ . The theorem implicitly confirms the progress of the migration process (conducted by McPal): eventually to-be behaviour is reached.
Theorem 3.3 Processes τG(SysMig) is branching bisimilar to process

τ · kickOff · ( Σs˜∈S
τ · SWSysToBe(s˜)+ Σ3
Σs˜∈Si
τ · SWSysToBe(s˜)) 

where G = NoToBe \ {kickOff}.
Once more, the theorem is checked with the tool set. The four inner summands in the process description cover the four possible migration trajectories: the first one via switchMig migration step and the other three via proceedMigi, i = 1, 2, 3 migration steps. Intuitively, as long as kickOff is not executed, SysMig behaves as the as-is system (Theorem 3.1). Eventually kickOff is executed (under the fairness assumption), moving Scheduler into NDetToRoRo and Workers into Phase2. Between kickOff and either switchMig or proceedMigi, the system continues behaving as-is. However, in addition to behaving as-is, any reachable state in this phase can execute exactly one action out of switchMig and proceedMigi, i = 1, 2, 3. The current as- is state determines which is enabled. Thus, if in the current state s˜ of SysMig, SchedulerMig is in IdleMig state, namely s7 = IdleMig, then switchMig is enabled, but proceedMigi is not. By execution of any of these four actions, the system is migrated to to-be behaviour. Essential is, these transitions change the global states of Workers only, not their detailed states. The three sets Si reflect this, each one containing states differing only in Workers’ detailed states.
Migration as provided by the Paradigm migration model does not require any quiescence. This is reflected by the specification in Theorem 3.3. More specifically, components are continuously active. Furthermore, the system can be in any allowed state at the moment the kickOff action is executed. Next, instigated by the kickOff action, the components are silently moved to their to-be behaviour. Migration essentially occurs without changing any current local state and the system continues without any interruption towards executing to-be transitions. This implies smooth migration, with ongoing component dynamics indeed.
The theorems presented above for the critical section running example apply to Paradigm migration models with similar McPals. As explained already in Section 2, a Paradigm migration model consists of three models, as-is model PM1, to-be model PM2, and migration model PM1to2. Note, due to the specific role of McPal in the migration process, its specification in hibernating form remains the same for any migration model, as well as for as-is and to-be models. Thus, in a similar manner as for the example above, McPal and its Evol role, McPalEvol, are compo- nents in the three models. Therefore, PM1to2 = ∂H( McPalMig  McPalEvolMig  PMMig) where PMMig is the composition of the other system components. Similar, PM1 = ∂H1 ( McPalAsIs  McPalEvolAsIs  PMAsIs ), and PM2 = ∂H2 ( McPalToBe  McPalEvolToBe  PMToBe ). Subsequently, the result of Theorem 3.1 can be gener- alized: τAct(McPalHib)(PM1) is branching bisimilar to
τ Act(McPalHib) ◦ ∂ H ( McPalMig  ∂ emp( , ,prepared) ( McPalEvolMig )  PMMig ).
where H, as for H1 and H2 above, are properly chosen sets of actions to be forced to synchronize.
In a Paradigm migration model, the migration of the system components is un- leashed once McPal performs a kickOff-like action. Consequently, the components are silently moved to their to-be behaviour, possible via different trajectories. As-

suming that there are n different trajectories tk, k = 1,... , n. Assume that state sk is the first state on trajectory tk that is a state in the (LTS of the) to-be model PM2. And assume that the set I contains all actions occurring in PM1to2 but not in
PM2, except the kickOff-like action. Then the generalization of Theorem 3.3 states
branching bisimilarity of τI (SysMig) and the process τ · kickOff · Σ	τ · PM2(sk).

Variants, related and future work
The above McPal is reminiscent of two other McPal versions from earlier work [10,11]. Compared with [10], the above McPal is far more general, since the older one, lacking a McPal(Evol) role, has exactly two fixed migration steps between Crs extension and Crs reduction only. The older version does allow for quite some freedom in unforeseen migration, however, as both fixed migration steps can be adorned, lazily but just-in-time, with new conducting, even repeatedly so for later migrations. Nevertheless, more than two migration steps, alternative migration steps or iterated migration steps cannot be covered at once, which for the above McPal are no problem at all. The concrete migrations in [10] are also less comprising, more cautious than the above example combining change of all detailed and role dynamics within one migration cycle.
Compared with [11], the above McPal has a rather more elegant Hibernating phase: complete symmetry in initial model extension and final model reduction via actions giveOut and cleanUp, respectively. Moreover, the choreography steps coordi- nating McPal(Evol) steps are more simple than McPal’s self-conducting in [11]. The actual migration in [11] is completely different, however, in two respects. A round robin strategy as above serves as as-is situation and the to-be situation is a pipeline architecture, with four Units collaborating pair-wise in producer-consumer fashion. So, Workers and Scheduler as above gradually become a Unit, with different dynam- ics each, without quiescence. Moreover, McPal decides on-the-fly of the migration, which Worker becomes which Unit. Another difference is, the migration is specified at a suitable architectural level: suggestively clear but incomplete, thus being not amenable to PA analysis yet.
In addition to variants for migration coordination, the Hibernating phase of McPal is open to variation too. Although such variants should not influence mi- gration, being internal to Hibernating, they might unravel the preparation of the migration, by refining what could happen in state JITting. The following variant particularly illustrates how translating a Paradigm model into a PA model and analyzing it, fit into McPal’s life cycle, providing instant formal verification of a proposed migration trajectory. See Figure 10. State JITting is refined into cycling through four modeling-related states: from JITParadigmModeling to Modelchecking. At arrival in JITParadigmModeling the as-is Paradigm model is the only model known, specified as current value of Crs, comprising consistency rules and corre- sponding STD definitions. On leaving the state, generally two more Paradigm models are known, specified as current values of CrstoBe and of Crs∪Crsmigr ∪CrstoBe, respectively, allowing for analysis and improvement. Model analysis and checking



Modelchecking
improve
wantModelsChecked
PAAnalysing
improve
giveOut giveOut

StartMigr

kickOff







McPal
wantPAAnalysis
PATranslating
improve
wantPAmodel


wantChange
Observing	cleanUp
StartRoRo

phaseOut




Content









(a)









(b)
Hibernating ToPh









(c)




McPal(Evol)

Fig. 10. Revisiting McPal: a new way of Hibernating.

can be abandoned via step giveOut from two states, always leading to StartMigr and thereby into trap prepared, only then enabling awakening from Hibernating.
The broad variability of McPal in its details, both for specifying concrete migra- tion coordination and for unraveling migration support given by a concrete model engineering process, underlines McPal’s reusability potential, effectively providing a pattern for adaptation. It is via specific constraint control, McPal conducts the migration coordination, following five steps. (i) New constraint control is specified and added to the model, while keeping as-is collaboration ongoing. (ii) McPal’s own new conducting is started, while keeping as-is collaboration of the others ongoing.
(iii) McPal kicks off and conducts the others from as-is collaboration to to-be collab- oration, while keeping them ongoing. (iv) McPal out-phases obsolete dynamics of all others, while keeping to-be collaboration of the others ongoing. (v) McPal returns to hibernating by out-phasing its migration conducting dynamics and removing ob- solete constraint control, while keeping to-be collaboration ongoing and continuing to do so thereafter. The above five steps constitute the backbone of McPal, serving as architectural redesigner as well as redirector of ongoing collaboration for all kinds of Paradigm models.
The above observations lead to the following conclusions. Conclusion 1: McPal is a pattern, for adaptation. Conclusion 2: McPal’s adaptation is on-the-fly of ongoing local and interaction dynamics, so it is without quiescence. The importance thereof is underlined by findings from related work below. Conclusion 3: PA techniques and model checking support can be well-integrated with McPal.
There is much research addressing dynamic system adaptation. Generally, for- mal analysis of the migration trajectory is ignored. Exceptions to this are mainly found in the WCAT community. In the setting of component-based software engi- neering, process languages and mobile calculi are used to express run-time adaptor modification for coupled COTS components [4,5,6,16]. However, tool support to- wards formal analysis of run-time adaptation has not been addressed so far. More- over, whereas adaptors do change, components cannot, unless by replacement: they are from on-the-shelf.
Various studies, e.g. [19,2,8,18], rely on high-level flexibility in an architectural setting, allowing low-level variability of components only. This boils down to re- arranging existent or foreseen component behaviors. New behavior can only be achieved by replacing the existing component by a new version, requiring halting that component if not a larger part of the system. Even in case of adaptation at

a detailed level and towards originally unforeseen behaviour, similar halting of the component to be adapted is generally required. Thus, actual adaptation is achieved by quiescence. In this manner it is not addressed how to adapt component behavior gradually, i.e., how to modify in detail ongoing behavior in an originally unforeseen direction, really on-the-fly. Only a few mention such more detailed dynamic adapta- tion of component. In [3] a first idea is formulated, formally specified on a low level, in relative isolation. A wide perspective is discussed in [15], as yet without theory (or enough operational details) enabling formal trajectory analysis, but pointing out the relevance of five techniques: reflection, probes, decomposition, generation and reification. It is interesting to see these mirrored in Paradigm-McPal. Reflection is present through the consistency rules in Crs. Probes as feed forward and feedback stimuli are present through traps and phases. Generation is McPal’s conducting, fully dynamically woven into dynamical decomposition (gradually fading out before phasing out) as well as into dynamical reification (gradually fading in after kick off): reification on-the-fly of decomposition constituting generation, conducted by McPal.
For future research topics we see great opportunities in investigating patterns for all kinds of dynamic change, by modeling and analyzing them in tandem. Such changes occur naturally where management, improvement or flexibility is relevant: reconfiguration, requirements change, alignment, etc. Concerning McPal as intro- duced here, we plan to study extensions concerning consistent creation and deletion of STDs, detailed and global, and also multiple McPals together, hierarchically or- ganized or as a federation.

References
S. Andova, L.P.J. Groenewegen, and E.P. de Vink. Dynamic consistency in process algebra: From Paradigm to ACP. ENTCS, 229(2):3–20, 2009.
O. Barais, A. Le Meur, L. Duchien, and J. Lawall. Software architecture evolution. In T. Mens and
S. Demeyer, editors, Software Evolution, pages 233–262, 2008.
K. Biyani and S. Kulkarni. Mixed-mode adaptation in distributed systems: A case study. In Proc. SEAMS’07, Minneapolis, 26–27 May, 2007. IEEE Computer Society, 2007. 10pp.
A. Bracciali, A. Brogi, and C. Canal. A formal approach to component adaptation. Journal of Systems and Software, 74:45–54, 2005.
A. Brogi, J. C´amera, C. Canal, J. Cubo, and E. Pimentel. Dynamic contextual adaptation. ENTCS, 175:81–95, 2007.
J. C´amara, G. Saluau¨n, and C. Canal.	Run-time composition and adaptation of mismatching behavioural transactions. In Proc. SEFM, London, pages 381–390. IEEE, 2007.
R.J. van Glabbeek and P. Weijland. Branching time and abstraction in bisimulation semantics. Journal of the ACM, 43:555–600, 1996.
I. Gorton, Yan Liu, and N. Trivedi. An extensible and leightweight architecture for adaptive server applications. Software, Practice and Experience, 38:853–883, 2008.
L. Groenewegen, N. van Kampenhout, and E. de Vink. Delegation modeling with paradigm. In J.-M. Jacquet and G.P. Picco, editors, Proc. COORDINATION 2005, pages 94–108. LNCS 3454, 2005.
L. Groenewegen and E. de Vink. Evolution on-the-fly with Paradigm. In P. Ciancarini and H. Wiklicky, editors, Proc. COORDINATION 2006, pages 97–112. LNCS 4038, 2006.
L.P.J. Groenewegen and E.P. de Vink. Dynamic system adaptation by constraint orchestration. Technical Report CSR 08/29, Technische Universiteit Eindhoven, 2008. 20pp, arXiv:0811.3492v1.

J.F. Jacob. Domain Specific Modeling and Analysis. PhD thesis, University of Leiden, 2008.

J. Kramer and J. Magee. The evolving philosophers problem: dynamic change management. IEEE Transactions on Software Engineering, 16:1293–1306, 1990.

J. Ku¨ster. Consistency Management of Object-Oriented Behavioral Models. PhD thesis, University of Paderborn, 2004.

R. Morrison, D. Balasubramaniam, G. Kirby, K. Mickan, B. Warboys, R.M. Greenwood, I. Robertson, and B. Snowdon. A framework for supporting dynamic systems co-evolution. Automated Software Engineering, 14:261–292, 2007.

P. Poizat and G. Salau¨n. Adaptation of open component-based systems. In M.M. Bonsangue and E.B. Johnsen, editors, Proc. FMOODS 2007, pages 141–156. LNCS 4468, 2007.

A.W. Stam. Interaction Protocols in PARADIGM. PhD thesis.

D. Sykes, W. Heaven, J. Magee, and J. Kramer. From goals to components: A combined approach to self-management. In Proc. SEAMS’08, Leipzig, pages 1–8. IEEE, 2008.

J. Zhang and B.H.C. Cheng. Model-based development of dynamically adaptive software. In L.J. Osterweil, H.D. Rombach, and M.L. Soffa, editors, Proc. ICSE’06, pages 371–380. ACM, 2006.


Process algebraic specifications of other components in the migration model
The detailed behaviour of Workeri, i = 1, 2, 3, in the migration model:
WorkerMigi = Freei
Freei = at!(Freei) · Freei + ok?(begini) · NonCriti NonCriti = ok?(reservei) · Prei
Prei = at!(Prei) · Prei + ok?(pickUpi) · Criti Criti = ok?(layDowni) · Posti
Posti = ok?(finishi) · Freei + ok?(continuei) · NonCriti + ok?(hurryi) · Prei
The roles WorkerCSi and WorkerEvoli, i = 1, 2, 3, in the migration model:
WorkerCSMigi = WorkerCSNotHavingTrivMigi

WorkerCSNotHavingTrivMigi
t∈{begin,reserve}
ok!(ti) · WorkerCSNotHavingTrivMigi +

at?(PreMigi) · WorkerCSNotHavingRequestMigi +
emp(NotHavingi, Withouti, trivMig) · WorkerCSWithoutTrivMigi +
emp(NotHavingi, Interrupti, trivMig) · WorkerCSInterruptTrivMigi WorkerCSNotHavingRequestMigi = emp(NotHavingi, Havingi, requestAsIs) · WorkerCSHavingMigi +
emp(NotHavingi, Withouti, trivMig) · WorkerCSWithoutTrivMigi +
emp(NotHavingi, Interrupti, trivMig) · WorkerCSInterruptTrivMigi

WorkerCSHavingTrivMigi
t∈{pickUp,layDown,finish}
ok!(ti) · WorkerCSHavingTrivMigi +

at?(FreeMigi) · WorkerCSHavingDoneMigi
WorkerCSHavingDoneMigi  = emp(Havingi, NotHavingi, doneAsIs) · WorkerCSNotHavingMigi +
emp(Havingi, Withouti, doneMig) · WorkerCSWithoutTrivMigi

WorkerCSWithoutTrivMig = P	ok!(ti) · WorkerCSWithoutTrivMig + emp(Withouti, Interrupti, trivToBe) · WorkerCSInterruptTrivMig + emp(Withouti, Withouti, trivMig) · WorkerCSWithoutTrivMig

WorkerCSInterruptTrivMigi
t∈{finish,begin,continue}
ok!(ti) · WorkerCSInterruptTrivMigi +

s∈{Free,NonCrit,Post}
at?(si) · WorkerCSInterruptNotYetMigi +

at?(PreMigi) · WorkerCSInterruptRequestMigi +
emp(Interrupti, Interrupti, trivMig) · WorkerCSInterruptTrivMigi

WorkerCSInterruptNotYetMigi
t∈{finish,begin,continue}
ok!(ti) · WorkerCSInterruptNotYetMigi +

emp(Interrupti, Withouti, notYetToBe) · WorkerCSWithoutTrivMigi +
emp(Interrupti, Interrupti, trivMig) · WorkerCSInterruptTrivMigi WorkerCSInterruptRequestMigi = emp(Interrupti, Withi, requestToBe) · WorkerCSWithTrivMigi +
emp(Interrupti, Interrupti, trivMig) · WorkerCSInterruptTrivMigi

WorkerCSWithTrivMigi
t∈{finish,begin,continue,pickUp,layDown}
ok!(ti) · WorkerCSWithTrivMigi +

s∈{Free,NonCrit,Post}
at?(si) · WorkerCSWithDoneMigi +

emp(Withi, Withi, trivMig) · WorkerCSWithTrivMigi

WorkerCSWithDoneMigi
t∈{finish,begin,continue}
ok!(ti) · WorkerCSWithDoneMigi +

emp(Withi, Withouti, doneToBe) · WorkerCSWithoutTrivMigi +
emp(Withi, Withi, trivMig) · WorkerCSWithTrivMigi

WorkerEvolPhase1TrivMigi
t∈{finish,begin,reserve,pickUp,layDown}
ok!(ti) · WorkerEvolPhase1TrivMigi +

emp(Phase1, Phase2, trivMig) · WorkerEvolPhase2TrivMigi

WorkerEvolPhase2TrivMigi
t∈LAct(WorkerMigi )
ok!(ti) · WorkerEvolPhase2TrivMigi


Note, ternary synchronization ok?(t)|ok!(t)|ok!(t) = ok(t) corresponds to vertical consistency of Workers.





Process algebraic specifications of to-be model

Workeri and roles WorkerCSi, WorkerEvoli, i = 1, 2, 3, in the to-be model:

WorkerToBei = Freei
Freei = at!(Freei) · Freei + ok?(begini) · NonCriti NonCriti = at!(NonCriti) · NonCriti + ok?(reservei) · Prei
Prei = at!(Prei) · Prei + ok?(pickUpi) · Criti Criti = at!(Criti) · Criti + ok?(layDowni) · Posti Posti = at!(Posti) · Posti + ok?(finishi) · Freei +
ok?(continuei) · NonCriti + ok?(hurryi) · Prei



WorkerCSToBe1	= WorkerCSInterruptTrivToBe1
WorkerCSToBe2	= WorkerCSWithoutTrivToBe2
WorkerCSToBe3	= WorkerCSWithoutTrivToBe3
t∈{finish,begin,reserve,continue,hurry}



ok!(ti) · WorkerCSWithoutTrivToBei +

emp(Withouti, Interrupti, trivToBe) · WorkerCSInterruptTrivToBe

WorkerCSInterruptTrivToBei = P
ok!(ti) · WorkerCSInterruptTrivToBei +

s∈{Free,NonCrit,Post}
at?(si) · WorkerCSInterruptNotYetToBei +

at?(PreToBei) · WorkerCSInterruptRequestToBei
WorkerCSInterruptNotYetToBei  = P	ok!(ti) · WorkerCSInterruptNotYetToBei +
emp(Interrupti, Withouti, notYetToBe) · WorkerCSWithoutTrivToBei WorkerCSInterruptRequestToBei = emp(Interrupti, Withi, requestToBe) · WorkerCSWithTrivToBei

t∈{finish,begin,continue,pickUp,layDown}
ok!(ti) · WorkerCSWithTrivToBei +

s∈{Free,NonCrit,Post}
WorkerCSWithDoneToBei	= P
at?(si) · WorkerCSWithDoneToBei
ok!(ti) · WorkerCSWithDoneToBei +

t∈{finish,begin,continue}
emp(Withi, Withouti, doneToBe) · WorkerCSWithoutTrivToBei


WorkerEvolToBei	= WorkerEvolPhase2TrivToBei

WorkerEvolPhase2TrivToBei = P
i
ok!(ti) · WorkerEvolPhase2TrivToBei

Scheduler and role SchedulerEvol in the to-be model:
SchedulerToBe = Checking1ToBe
HelpingToBei = man(proceedToBei) · CheckingToBei+1
CheckingToBei = man(grantToBei) · HelpingToBei + man(passToBei) · CheckingToBei+1
SchedulerEvolToBe = SchEvolPhase2TrivToBe

SchEvolPhase2TrivToBe = P
ok!(t) · SchEvolPhase2TrivToBe

To express the collaboration of Scheduler and Workers in the to-be model in isolation, the relevant specifications from above are composed in parallel:
SWSysToBe = ∂ H (  i ( WorkerToBei  WorkerCSToBei )  SchedulerToBe )
with the synchronization defined as
grantToBei =	man(grantToBei) |	ok!(grantToBei)	| emp(Interrupti, Withi, requestToBe) proceedToBei = man(proceedToBei) | ok!(proceedToBei) |
emp(Withi, Withouti, doneToBe) | emp(Withouti+1, Interrupti+1, trivToBe) passToBei =	man(passToBei) |	ok!(passToBei)	|
emp(Interrupti, Withouti, notYetToBe) | emp(Withouti+1, Interrupti+1, trivToBe)
Note, McPal does not communicate with other components, which can be concluded from the definition of synchronization above. Indeed, once the migration is done and the to-be behaviour is reached, running as it should, McPal returns to Hibernating

and remains under this constraint till the next migration. Thus,
McPalToBe = McPalContent
McPalObserving = ok?(wantChange) · McPalJITting McPalJITting = ok?(giveOut) · δ
McPalContent = ok?(cleanUp) · McPalObserving
and incorporated as a component of the to-be behaviour SysToBe specified as
SysToBe = ∂ H ( McPalToBe  McPalEvolToBe  SysToBe' )
SysToBe' =  i ( WorkerToBei  WorkerCSToBei  WorkerEvolToBei )  SchedulerToBe  SchedulerEvolToBe
but it does not add any relevant behaviour. As usual ∂ H blocks all not syn- chronized communicating actions. Given the two specifications of McPalToBe and McPalEvolToBe, we can show that after renaming all McPal actions, Act(McPalToBe), into τ , SysToBe becomes branching bisimilar to SWSysToBe (Theorem 3.2).
