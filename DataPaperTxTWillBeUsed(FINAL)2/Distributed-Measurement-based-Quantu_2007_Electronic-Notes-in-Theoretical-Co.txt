Electronic Notes in Theoretical Computer Science 170 (2007) 73–94	
www.elsevier.com/locate/entcs

Distributed Measurement-based Quantum Computation
Vincent Danos1
Universit´e Paris 7 & CNRS
Ellie D’Hondt2
Vrije Universiteit Brussel
Elham Kashefi3
IQC - University of Waterloo
Prakash Panangaden4
McGill University


Abstract
We develop a formal model for distributed measurement-based quantum computations, adopting an agent-based view, such that computations are described locally where possible. Because the net- work quantum state is in general entangled, we need to model it as a global structure, reminiscent of global memory in classical agent systems. Local quantum computations are described as mea- surement patterns. Since measurement-based quantum computation is inherently distributed, this allows us to extend naturally several concepts of the measurement calculus [2], a formal model for such computations. Our goal is to define an assembly language, i.e. we assume that computations are well-defined and we do not concern ourselves with verification techniques. The operational semantics for systems of agents is given by a probabilistic transition system, and we define opera- tional equivalence in a way that it corresponds to the notion of bisimilarity. With this in place, we prove that teleportation is bisimilar to a direct quantum channel, and this also within the context of larger networks.
Keywords: Formal language, quantum communication, quantum computing, semantics.




1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.012

Measurement-based models provide an intriguing new framework for thinking about quantum computation. While quantum circuits are still widely consid- ered as a convenient formalism for describing algorithms, using measurements to steer quantum computation is considered a serious alternative. Due to their inherently probabilistic nature, measurements were long thought to be a disturbance to quantum computations – unavoidable though they are when wanting to read out the final output of a computation. That they can be an active component of a computation has been known for quite some time through the teleportation protocol. Only much later was it realized that in fault-tolerant constructions, measurements can be quite useful. Soon there- after, with the advent of models such as the one-way quantum computer [11] and the teleportation model [9,8], it was established that measurements could not only be a recurring component of a computation, but the actual driv- ing force behind it. Moreover, the measurement paradigm throws a whole new light on the strategies for actual physical implementations of a quantum computer [12].
However, measurements are not the only crucial ingredient of these mod- els: they are also inherently distributed. Indeed, it is the realization that a variation on the teleportation protocol not only transports but also transforms quantum information, which is the basis of the teleportation model. Likewise, the one-way quantum computer is all about transformation via measurement and transportation, this time by way of a generic entangled state, the graph state. One-qubit measurements on this state transform the logical qubits, i.e. the quantum inputs, while transporting them via a path of graph state qubits. Again, non-local correlations provided by particular entanglement properties, together with measurements, steer the computation. Of course quantum mea- surements remain intrinsically probabilistic, but this can be solved by ap- plying corrections dependent on previous measurement outcomes, rendering computations effectively deterministic. Note that measurement outcome de- pendencies are crucial in order to obtain universality of the model. As a result, the typically distributed notion of classical communication is also naturally present in these models. All of this is very nicely captured by the measurement calculus [2], a formal framework for one-way computations. Measurement pat- terns are defined essentially by sequences of commands allowed in the one-way model. From this one can define operational and denotational semantics and

1 Email: Vincent.Danos@pps.jussieu.fr
2 Email: Ellie.DHondt@vub.ac.be
3 Email: ekashefi@iqc.ca
4 Email: Prakash@cs.mcgill.ca


show their equivalence, and prove that notions of composition are well-defined. More importantly, there is an associated rewrite system which allows one to put any pattern into a standard form. The measurement calculus, which can be seen as an assembly language, proves to be a valuable tool for formal inves- tigations into all measurement-based models; for example, one can easily show how the teleportation model reduces to the one-way model, via a conversion between the associated calculi [3].
Because of the inherently distributed aspect, measurement-based mod- els for quantum computation are well-suited as a starting point for a formal model for distributed quantum computations. By this we mean macroscopi- cally distributed, i.e. we are talking about coordinated actions between differ- ent parties. Of these there are many examples in quantum computation [10]: teleportation, of course, but also entanglement swapping, logic gate telepor- tation, cryptographic protocols, and also quantum versions of classical dis- tributed applications such as leader election [5]. However, a formal language for distributed quantum computation is lacking. There have recently been interesting developments based on classical process calculi [7,6], which have focused mostly on the concurrency aspects. While the distributed nature of computations was introduced via types in Ref. [6], the aim there is to develop formal verification techniques. In this work, we take an assembly-language point of view, assuming that computations are well-defined. This results in a compact model, with which we can explore properties of distributed protocols, such as the coordination between agents.
We define an assembly language for distributed applications, directly built on the most basic distributed model of all: the one-way quantum computer. We adopt a local view and describe the system as a set of agents communicat- ing synchronously and operating on a globally entangled quantum state; this is explained in Sec. 2. In Sec. 2.1 we develop a formal semantics for systems of agents as probabilistic transition systems. Operational equivalence is de- fined in a way such that it corresponds to the notion of bisimilarity. We then prove that quantum teleportation is bisimilar to a direct quantum channel, and this also within the context of other, possibly entangled, agents, in Sec. 3. While the correctness of teleportation has been proved within other formal frameworks before [6,1], the bisimilarity approach, and specifically, taking into account larger contexts as well, is new. We conclude in Sec. 4.
Some familiarity with the measurement calculus model is assumed; for an in-depth exposition we refer to Ref. [2].

Networks of agents
The main concept in our model for distributed measurement-based quantum computations is that of an agent. Agents are localized processes which, exe- cuting concurrently, make up a distributed system. Formally, we define agents in the following way.
Definition 2.1 An agent A(i, o) : Q.E , with classical input i and output o, and sort given by a set of qubit references Q, is defined by a finite event sequence E composed of
patterns command sequences A, with input qubits in Q;
classical message reception c?x and sending c!y, where c is a classical channel, and x and y are names;
qubit reception qc?x and sending qc!q, where qc is a quantum channel and q a qubit reference.
An agent’s state is given by a classical environment Γ, which is a partial mapping from names, i.e. classical variables and qubit references, to values.
Notice that any pattern P(V, I, O, A) trivially corresponds to agent A :
I.A. In general the sort Q equals I  Is, where I is the local quantum input and Is are qubits of a shared entangled state supplied by the network – see Def. 2.3 below. The classical input i and output o allows us to model protocols such as superdense coding, in which an agent wishes to send classical values
to another agent with the help of a shared Bell state. The local state is used to store measurement outcomes resulting from local pattern executions, input from other agents over classical channels c, and classical input bindings from the local environment. Further bindings are added to the state as required; that is, for example, whenever a qubit is measured, only then the signal name si corresponding to the qubit reference qi is added to the domain of Γ and bound to the classical measurement outcome v, denoted Γ[si '→ v].  The
classical output set o determines which bindings in Γ have to be preserved for
the final output of a computation. We denote the local state restricted to the classical output by Γo.
Our interpretation of agents is different than the usual process approach, in that agents in our setting always correspond to actual parties in a distributed network, denoted by the label A. Therefore, an expression of the form A(i, o): 
Q.E should be read as: the agent with name A (Alice) runs the program E with qubits and in- and outputs as specified. An agents thus is a piece of code running on a particular processor. In this context, it only makes sense
to compose agents if the agent names are the same. We refer to this as agent composition, which is formally defined below. Note that, since we allow

subsequent agent programs to supply extra classical and quantum inputs as well as further process outputs from a previous program, some care is required in determining the classical type and quantum sort of the resulting agent. Other than that, agent composition is just straightforward concatenation of event sequences.
Definition 2.2 The composition of agents A(i1, o1) : Q1.E1 and A(i2, o2) : 
Q2.E2, which is only defined for agents with identical agent names, is denoted
A[(i2, o2): Q2.E2] ◦ [(i1, o1): Q1.E1]


and given by


A(i, o): Q.E2E1	with

⎧i = i1 ∪ (i2\o1)
o = o1 ∪ o2
⎪⎩Q = Q1 ∪ (Q2\Q' ),



(1)

where Q'
is the output sort of the first agent.

Note that output sorts can be determined by inspecting an agent’s event
sequence. The general idea is that o1 ⊆ i2 and Q' ⊆ Q2, so that subsequent
programs are defined at least on the outputs of previous ones. This can always
be arranged by assuming identity transformations for those names in o1 and
' not appearing in E2. In particular this means that Q' = Q' . Extra inputs
in subsequent programs are encountered for example when several qubits are
teleported one after each other. In this case, Alice needs to execute her side of the protocol several times in a row, supplying a new local quantum input every time she initiates the protocol. The same argument holds for classi- cal input when sequencing several dense coding protocols. Of course this is best understood within the context of network rather than agent composition, which is defined below.
A network of agents consist of several agents executing their event sequence concurrently, together with a global shared entangled state. As the network quantum state is inherently non-local, there is no other option than to regard it as some kind of global memory – even though we wish to adhere to a local view. This leads to the following definition.
Definition 2.3 A network of agents N is defined by a set of concurrently acting agents together with a shared quantum state, that is


N = A1(i1, o1): Q1.E1 | ... | Am(im, om): Qm.Em  σ
= |iAi(ii, oi): Qi.Ei  σ,
(2)

where σ ∈ D(H Is ), with Qi = Ii ∪ Is for all i.
i i	i
The network state σ in the definition is the initial entanglement resource which is distributed among agents. Local quantum inputs specified in Ii are added to the network state σ during initialization. In this way we can keep ini- tial shared entanglement as a first-class primitive in our model. In this paper, we do not describe the actual procedure for producing σ. Note that agents in a network need to have different names, since they correspond to different par- ties that make up the distributed system. In other words, concurrency comes only from distribution; we do not consider parallel composition of processes in the context of one party. Finally, individual agents A(i, o): Q.E trivially cor-
respond to a network A(i, o): Q.E 0. Therefore statements about networks
affect individual agents as well.
We define two different ways of composing networks of agents, namely se- quential and parallel composition. Because of our interpretation of agents as distributed processes, there are some constraints on these operations. Sequen- tial composition is only defined for networks containing the same agents; the idea is that agents carry out event sequences of both networks one after the other. Furthermore, agent composition must be defined as per Def. 2.2, that is, inputs and initial sorts of the second network must contain outputs and final sorts of the first. Formally, as follows.


Definition 2.4 The sequential composition of networks N1 = |m
Ai(i1,i, o1,i): 

Q1,i.E1,i  σ1 and N2 = |m  Ai(i2,i, o2,i): Q2,i.E2,i  σ2 is defined as


N2 ◦ N1 = |m
Ai[(i2,i, o2,i): Q2,i.E2,i] ◦ [(i1,i, o1,i): Q1,i.E1,i]  σ1 ⊗ σ2.	(3)

Note that we have overloaded the notation ◦ to denote both agent and network composition. As long as both networks have the same number of agents, one can always arrange for them two be sequentially composable by
renaming agents. In fact one can even compose networks with a different number of agents by adding null agents, i.e. just agent names, to the net- work with fewer agents. The preparations of both networks are assumed to be defined on disjoint Hilbert spaces; the composed network’s preparation is given by the tensor product of these. They are to be interpreted as different entanglement resources that are used by both networks. Parallel composition, which expresses that two networks are operating in parallel and independent of each other, is only defined for networks containing different agents. Again, one can always rename agents so that this is well-defined.


Definition 2.5 The composition of networks N1 = |m
Ai(i1,i, o1,i): Q1,i.E1,i

 σ1 and N2 = |n  Bi(i2,i, o2,i): Q2,i.E2,i  σ2 is defined as

N1 ⊗ N2 =|m
n i=1
Ai(i1,i, o1,i): Q1,i.E1,i
Bi(i2,i, o2,i): Q2,i.E2,i

(4)

 σ1 ⊗ σ2.
By combining sequential and parallel composition, one can express a broad range of network combinations. In Sec. 2.3 we show that the semantics of networks is preserved under these operations.
The definitions given in the above can be rendered concisely under the form of an abstract grammar. We use [] instead of | to separate choices for expressions, as the latter is already in use to denote parallel composition.


A ::= nil [] E [] M [] C [] A⊗ A [] A.A
E ::= c?x [] c!x [] qc?q [] qc!q [] A [] E .E
a ::= A(i, o): Q.E [] A[(i2, o2): Q2.E2] ◦ [(i1, o1): Q1.E1]
N ::= |iai  σ [] N ◦ N [] N ⊗ N

(5)

In the above E, M and C stand for any entanglement, measurement or correction commands, and nil is the null command. We refrain from giving a grammar for names; rather, we use conventions for these described below. Notice that both pattern command sequences and networks can be viewed as processes in the traditional process algebra sense, with a composition opera- tion transforming any two patterns, respectively networks, into a new pattern or network. The definition of event sequences, which can be composed se- quentially, is also common. Agents, however, have a less clear status in the process algebra framework. This is exactly because they are constructs that formalize distributed notions, and therefore there are constraints on how they may be composed. This is not a flaw of our model but rather a requirement if one wants to make distribution explicit.
There are several notational conventions we adhere to throughout this paper. When the context is clear, as is often the case, we do not explicitly mention inputs and outputs, but instead just write A : Q. Moreover, we do not write inputs, outputs, sorts, or preparations if there are none, sometimes writing − for empty input or output sets. For example, A(−, {x}).c?x is an
agent with no input and no qubits, while A(−, {x}).c?x | B({y}, −).c!y is a
network with no preparation in which a classical value is exchanged between
two agents. We write c?xy for c?xc?y and similarly for other communicating channels. In Def. 2.1 we have used pattern command sequences rather than full patterns for brevity, with the convention that the input of a pattern is

always given by those qubits in its computation space that belong to the agent’s sort at the moment when the pattern is executed. The output of the pattern is simply given by those qubits that are not measured. For example,
in the single-agent network A : {1, 2}.Xs1 M 0E14 qubit 1 is an input to the
4	1
pattern and 4 is an output; we also write this as A : {1, 2}.H(1, 4). Pattern qubits not in an agent’s sort are assumed to be computation qubits initialized
to |+⟩ as before, and need not be mentioned explicitly in an agent’s sort. On the other hand, agent qubits not mentioned in a pattern event, as qubit 2 above, are always assumed to be left alone. That is, we do not explicitly write the identity pattern I applied to A’s remaining qubit 2. We consider pattern command sequences rather than singular commands so that we can use the big-step semantics of patterns. As can be seen from these examples, we often refer to qubits via numbers; specifically we mostly refer to qubit qi as qubit i, and si instead of sqi for the corresponding signal variable. This has the advantage that patterns look just as they do in Ref. [2]. In what follows
below, we use specific letters for specific names, in particular we use qi or just i for qubit references, xi and yi for ordinary classical variables, vi for classical values, and si for classical signal variables.
We subject networks of agents to definiteness conditions, which ensure that the computation is well-defined.
(H0) an agent’s communication events operate only on qubits in its sort Q. Pattern events with computation space V have inputs in Q ∩ V ;
(H1) an agent’s events depend only on values in its state Γ;
(H2) each quantum and classical message reception event has a corresponding quantum, respectively classical message sending event;
(H3) all names, i.e. classical variables and quantum references, are unique.
Operational semantics
Before we provide concrete evaluation rules for distributed computations, we give some clarifying explanations and examples as to how execution proceeds in the local view. Throughout network evolution, each agent has access to the network state σ via the qubits it owns, transforming σ whenever a pattern event is executed. While these patterns are local, σ is not, and to preserve all information on the correlations we need to keep σ unreduced at all times. As an example, suppose that an agent A owns the first two qubits of the system’s state σ(1, 2, 3, 4, 5). Its next event is to execute the Hadamard pattern H(1, 6)
on its first qubit. As stated above, we do not explicitly write the identity
pattern I applied to A’s remaining qubit 2. More importantly, neither do we write explicit identity patterns for the qubits not belonging to A, in this case

3, 4 and 5. In full, this means that we have an evaluation step as follows

σ, A : {1, 2}.H(1, 6) =⇒ σ', A : {6, 2},	(6)

where σ' = H(1, 6) ⊗ I⊗4(2, 3, 4, 5))σ, that is, σ' = (H ⊗ I⊗4)σ(H ⊗ I⊗4). We denote the transition relation by =⇒. Execution of H occurs in a single transition step by relying on its big-step semantics. In this way we avoid getting into the actual details of pattern execution, which is not what this paper is about. Note especially that the sort of A has changed. This is because measurements are destructive, so that the input qubit 1 has disappeared, and the output 6 has taken its place. Because of this, we sometimes explicitly write
σ'(6, 2, 3, 4, 5) in the right-hand side of the above evaluation rule. The only remnant of 1 is its corresponding measurement outcome s1, which is recorded in the state Γ, via the added binding Γ[s1 '→ v], where v is the measurement outcome. A might subsequently send s1 to other agents by an event c!s1, so in general we cannot delete this entry from Γ. Essentially this means that
when new qubit references are generated by the execution of subsequent local patterns, or by quantum communications from other agents, these names need to be unique. Because we do not want to get into the actual details of this naming procedure, as we are considering our model to be at the level of an assembly language, i.e. at a stage where naming conflicts have been resolved, we have imposed this as a definiteness condition in the above.
A final point concerns an agent’s classical input and output, received from, respectively sent to, its own local system. In the local view, pattern events can depend also on classical inputs, rather than only on measurement out- comes. Because of the uniform structure of the local state Γ we can piggyback input dependencies onto the signal dependency structure of MC. This is, as mentioned before, one of the reasons why MC is such a good basis on which to built a framework for distributed quantum computations. With these concrete examples in mind, we are now ready to develop the operational semantics of the local view. As usual, we first define rules in terms of small-step transitions, after which we switch over to the big-step framework.
The small-step transitions for distributed computations essentially describe how agents, and the network with them, evolve over different time steps. We adopt a shorthand notation for agents, leaving out classical inputs and output,

which do not change with small-step reductions.


ai = Ai : Qi.Ei
ai.E = Ai : Qi.[Ei.E]
a−q = A : Q\{q}.E
a+q = A : Q  {q}.E[q/x],

(7)

where E is some event, and Ei and E' are event sequences. A conﬁguration is given by the system state σ together with a set of agent programs, and their states, specifically
σ, |iΓi, ai = σ, Γ1, a1 | Γ2, a2 | ... | Γm, am.	(8)
The small-step rules for configuration transitions, denoted =⇒, are specified below; we give some explanations afterwards. When the system state is not changed in an evaluation step, we stress this by preceding a rule by σ ▶.

σ, P(V, I, O, A) −→λ σ', Γ'
(9)
σ, Γ, A : I  R.[E .P] =⇒λ σ', Γ∪ Γ', A : O  R.E


		Γ2(y)= v	 σ ▶ (Γ1, a1.c?x | Γ2, a2.c!y =⇒ Γ1[x '→ v], a1 | Γ2, a2)
(10)

σ ▶ (Γ , a .qc?x | Γ , a .qc!q =⇒ Γ , a+q | Γ , a−q)	(11)

1	1	2	2
1	1	2	2



		L =⇒λ R	 L | L' =⇒λ R | L'
(12)

Here, ∪ denotes the union of outcome maps. Implicit in these rules is a se- quential composition rule, which ensures that all events in an agent’s event sequence are executed one after the other. The first rule is for local opera- tions; we have written the full pattern instead of only its command sequence here to make pattern input and output explicit. Because a pattern’s big-step semantics is given by a probabilistic transition system described by −→, we
pick up a probability λ here. Furthermore, an agent changes its sort depend-
ing on pattern’s output O, as explained in the examples above. The next rule is for classical rendez-vous and is straightforward. For quantum rendez-vous, we need to substitute q for x in the event sequence of the receiving agent, and furthermore adapt qubit sorts. The last rule is a meta-rule, which is required

to express that any of the other rules may fire in the context of a larger system. L and R stand for any of the possible left-, respectively right-hand sides of any of the previous rules, while L' is an arbitrary configuration. Note that we might need to rearrange terms in the parallel composition of agents in order to be able to apply the context rule. This can always be done since the order of agents in a configuration is arbitrary. In derivations of network execution, we often do not explicitly write reductions as specified by (12), but rather specify which in which order the other rules fire in the context of the network at hand. It is precisely in this last rule that introduces non-determinism at the network level, that is, several agent transitions may be possible within the context of a network at the same time.
Starting from the small-step rules above we can now define the big-step semantics of a system of agents. We first define computation paths, which run from initial to final configurations via small-step transitions. In the initial conﬁguration, all local states are given by the map containing the classical input bindings Γii , while the network state is determined by the entanglement resource together with local quantum inputs. A ﬁnal conﬁguration is one in which all agents have an empty command sequence, and in which all local states have been restricted to classical output bindings, Γi,oi. Because of the definiteness conditions we imposed each computation always ends with a final configuration. Supposing the initial quantum state of agent Ai is given by ρi ∈ Ii, paths are defined as follows.
Definition 2.6 Given a network of agents N = |iAi(ii, oi) : Qi.Ei  σ and quantum inputs ρi, a path γ is a maximal sequence of configurations {Cj =
σj, |i Γj, aj ,j = 1,... ,k − 1}, i.e.
i	i

C1 = σ ⊗m ρi, |i Γi , Ai : Qi.Ei
i

Cj =⇒λj Cj+1 Ck = σk, |i Γk

, Ai : Qk
(13)



We write C
of N .
1 =⇒λγ
Ck where λγ
k j=1
λj, and call Ck
a final configuration

Notice also that paths always terminate since event sequences are finite. One could straightforwardly define the operational semantics of a system
N to be the probabilistic transition system (PTS) defined by of all its paths. However, we choose to identify those paths leading to the same observable behavior of an agent network. Concretely, for particular inputs i and ρ ∈ I, we identify final configurations for which only internal bindings in the local state of agents are different, that is, bindings for names not in the classical

output set o. These bindings correspond either to outcomes of measurements appearing in pattern events, or result from classical rendez-vous events. As long as these are not part of the classical output, their actual values are unim- portant. We cannot trace out these measurement outcomes after each pattern event, since a subsequent event may depend on these values. Notice that the final sorts of agents do need to be identical, as well as, obviously, the final network quantum state. Identifying such paths, in the style of the measure- ment calculus, then gives us the semantics of a network of agents. However, because of the non-determinism in the order in which concurrent agents ex- ecute their event sequence, we have to define the operational semantics of a network with respect to a particular schedule. A schedule is precisely a par- ticular order in which agents execute events. For example, in the network
A : {1}.H(1, 2) | B : {3}.H(3, 4), possible schedules are AB and BA. If we do not take schedules into account, we would add probabilities of all paths and all schedules resulting in identical final configurations, which for the example above leads to a probability of 2 for computing H ⊗ H for arbitrary inputs, which is clearly not what we intend to say. We refrain from giving a formal definition for schedules, as we will find in Sec. 2.2 that the semantics of a network is independent of the schedule. Putting all this together, we obtain
the following definition.
Definition 2.7 The operational semantics of a network N = |iAi(ii, oi) : Qi.Ei  σ, with respect to a particular schedule, is a probabilistic transition system relating initial with final configurations,


 N )op :  iQi →  iQ' . ⊗i ρi, |iΓi
=⇒λ σ', |iΓo
(14)

with λ = Σγ λγ and the sum runs over all paths γ such that


σ ⊗ ρ , | (Γ
, A (i , o ): Q .E
⇒	σ', | (Γ
, A (i , o ): Q' ).	(15)

i  i  i	ii
i  i	i
i  i) = λγ
i	oi
i  i	i	i

We call  iQi →  iQ' the type of the network.
From now on, we denote I =  iIi for the set of input qubits and O =  iQ' for the set of output qubits, and call D(HI) and D(HO) the quantum input and output space respectively. The semantics of a network with respect to a schedule is thus that it relates quantum states in D(HI) plus classical input to quantum states in D(HO) and classical output with particular probabilities. Note that the type of the transition system is a mapping from initial to final sorts; this component is identical in the denotational semantics we develop in Sec. 2.2.
We say that two networks N1 and N2 are operationally equivalent if their operational semantics, given by a PTS, is identical, and write  N1)op ≡  N2)op.

In fact, we identify operational equivalence with the notion of bisimilarity. This is indeed sensible since, by identifying computation paths as in Def. 2.7, we actually impose a bisimilarity relation on final configurations. As we shall see in Sec. 3, it is by doing exactly this that we can show, among others, that teleportation is bisimilar to a direct quantum channel.

Denotational semantics
Because of its more abstract character, in many situations it is more adequate to work with the denotational semantics. This is why we develop this notion for networks of agents. As before, it is closely related to the operational seman- tics, as well as to the semantics of ordinary patterns. Indeed, upon inspection of Def. 2.7, we see that for any schedule, the PTS associated with a network of agents decomposes in several parts. First, there is a map from initial to final sorts, which determines how qubit ownership evolves for each of the agents from initial to final configurations. This is formalized as a type signature, exactly as we did for the operational semantics. The sort mapping is inde- pendent of the classical input: indeed, classical inputs appear only in classical communications, Pauli corrections and measurement angles, none of which af- fect qubit sorts. Furthermore, they can be read of statically from the network definition and are also schedule independent. The denotational semantics is then a mapping from classical inputs to classical outputs and a quantum op- eration, which in turn determines how quantum states evolve in the network. However, these two components are not independent of each other, since clas- sical outputs can be measurement outcomes, which occur with probabilities that depend on the quantum operation applied. For simplicity, let us first consider the case where there are no classical outputs. In this case, for each classical input i =  iii we have map L which describes how the network quan-
tum state evolves. This map is a multilocal quantum operation, because if
we throw away all distributed information, that is, sorts and communication events, we just have an ordinary pattern, i.e. a quantum operation. There is one caveat: since computation occurs asynchronously, there is usually some choice in the order in which different agents execute events in their program,
i.e. there are different possible schedules. However, since at each instance of the computation local events operate on disjoint sets of qubits, it does not ac- tually matter in which order these operations are applied, or, in fact, whether they are executed at the same time. This statement is proved formally in Sec. 2.4; we postpone the full proof until then since it has bearing on other situations that are covered below. Therefore, any schedule of the computa- tion leads to the same quantum operation. So to determine the operation elements of L, we choose a particular schedule, and then compose patterns in

the order in which they are executed, tensoring with identity patterns where necessary and ignoring communication commands. Each operation element Lj then corresponds to a sequential composition of actualizations for each of these patterns.
Suppose now that the network contains classical outputs o = ioi. We need to make a distinction between signal outputs, which are measurement outcomes, and external outputs, which are values that were originally input by some agent and sent around the network. By definition, the external out- puts oe =  ioi,e depend only on the classical input i; these constant values are sent around the network via classical channels. It is precisely the signal outputs os = ioi,s that depend on the quantum operation and vice versa. Indeed, when there are signal outputs particular measurement outcomes are
preserved, therefore excluding actualizations of L that do not correspond to that outcome. This essentially means that a different quantum operation is applied for each possible signal output. For example, suppose one of the sig- nal outputs, corresponding to a measurement on qubit 3 is equal to 1. Then
only those actualizations containing the operator ⟨−α|3 are compatible with
os
this output. We denote actualizations compatible with output os by	, and
the quantum operation with these operation elements by Los , and call these
restricted. Note, however, that this is a trace-decreasing operation, and that

Tr(L)os(ρ) is precisely the probability with which the output o
occurs. So,

whereas the operational semantics gives explicit probabilities for each path,
in the denotational semantics these are contained within the quantum op- erations. It is this abstraction, together with schedule-independence which makes the denotational framework advantageous. Indeed, classical inputs are the same for all schedules, and classical outputs, depending on classical inputs and measurement values, thus occur with the same probabilities for all sched- ules, since L is schedule-independent. Putting all of this together, we arrive
at the following definition.
Definition 2.8 The denotational semantics of a network of agents N  =
|iAi(ii, oi): Qi.Ei  σ is given by
 N )	:  Q →  Q' .i → {(o, Los), ∀o }	(16)

with
de	i  i	i  i	s

L : D(HI) → D(HO): ⊗iρi → Σ Lj(σ ⊗i ρi)L†,	(17)
j
where o = oe  os, ρi is the quantum input, Q' the final sort of agent Ai, and I and O are quantum input and output spaces respectively. In case there are no outputs, we have  N )de :  iQi →  iQ' .i → L, or just .L if there are no
inputs either.

Note that the oe part of o in each of the above tuples is identical. As an example, consider the pattern Xs2 M −α, which implements the bit-flip channel
1	2
[10]. It can be interpreted as a one-agent network A(−, −) : {1}.Xs2 M −α,
1	2
with has as denotational semantics the quantum operation L(ρ)= pρ + (1 −

p)XρX.  However, the one-agent network A(−, {s }) : {1}.Xs2 M −α
has a

different semantics, namely
2	1	2

{(0, pρ), (1, (1 − p)XρX)},	(18)
for all ρ, where p is a function of α. While this example may seem contrived, it is actually crucial that the semantics of these kind of networks are different, as they describe different states of knowledge of the output s2, and hence, of what actual computation path was taken.
In case the underlying quantum operation L is deterministic, all actual- izations lead to the same quantum output. However, even in that case we require the above formulation with different trace-decreasing quantum opera- tions Los , since these determine the probabilities of outputting o . A network is deterministic only if for any input i, the quantum operation L is determin- istic, i.e. it implements a unitary, and the classical output o is identical in all actualizations.
As before, two networks are called denotationally equivalent if they have the same denotational semantics. Note that equivalent networks may have dif- ferent preparation states, and also that agent names may be different, though the number of agents must be identical in both networks. With the above definitions in place, we can now prove the following result.
Proposition 2.9 There is a precise correspondence between the operational and the denotational semantics of networks of agents, that is to say
∀N1, N2 : N1 ≡op N2 ⇐⇒ N1 ≡de N2	(19)
Proof. Suppose N1)de = N2)de. This means that for all classical and quan- tum inputs, both the the type and classical external outputs are identical.
Since for all signal outputs Los = Los , we have that L  = L  and therefore
2
computation paths are also the same for both networks	[4]. Hence, both
networks are operationally equivalent. 
Since both semantics’ are equivalent, we can choose the operational or de- notational framework at out convenience. We usually derive the denotational semantics via operational computation paths, relying also on the fact that the semantics is schedule independent.

Compositionality
An important goal is to prove that the semantics of networks is conserved with respect to network composition as in Defs. 2.4 and 2.5. Knowing this, we can compose any two networks and be ensured that the resulting network carries out the intended computation. In other words, we need to prove Prop. 2.10 below – notice that a similar result exists for patterns [2], though the opera- tions are of course defined differently. However, in order to do this we require a proper definition for composing mathematical objects of the form of Def. 2.8. The reasonable way to this is to gather types, inputs and outputs, eliminating those that are fed from one network into the other in case of sequential com- position, exactly like we did for agents in Def. 2.2. Next, we need to combine quantum operations by tensoring with the identity map were necessary. As we shall see below, in this way we already recover most of Defs. 2.4 and 2.5 . In fact, we only need to be careful in checking whether the quantum operations combine in the correct way, but, for this we can rely on the above-mentioned Prop. 2.10.
Proposition 2.10 The semantics of networks is compositional, i.e.
 N2.N1) =  N2). N1)	(20)
 N1 ⊗ N2) =  N2) ⊗  N1)	(21)

Proof. Suppose we have two networks N1 = |iAi(i1,i, o1,i): Q1,i.E1,i  σ1 and
N2 = |iAi(i2,i, o2,i): Q2,i.E2,i  σ2 with semantics given by

 N ) :  Q
→  Q' .i → {(o , Los )}

i  1,i
i  1,i  1	1	1
(22)

 N ) :  Q
→  Q' .i → {(o , Los )},

with
i  2,i
i  2,i  2	2	2

L1 : D(HI ) → D(HO ) ⊗i ρ1,i → Σ L1,j(σ1 ⊗i ρ1,i)L†

1	1	1,j
L : D(H ) → D(H	) ⊗ ρ	→ Σ L	(σ ⊗ ρ )L†
(23)
.

2	I2
O2	i
2,i
2,j	2
j
i 2,i
2,j



We then find that
o2,s	o1,s
 N ). N ) :  Q →  Q' .i → {(o, L	.(L	⊗ I)), ∀o

, o	}	(24)

2	1	i  i	i  i	2	1
1,s
2,s

where type, classical input and output are found by pointwise application of the rules in Eq.(1), and I is the identity operation on I2\O2. Quantum

operations in the above map states of the form ⊗iρ1,i ⊗i ρ2,i in I = I1  (I2\O2) to states in O = O2, after tensoring them with σ1 ⊗ σ2; On the other hand, the semantics of N2 ◦ N1 is given by
 N ◦N ) :  Q →  Q' .i → {(o, [L .(L ⊗ I)]os ), ∀o },	(25)
2	1	i  i	i  i	2	1	s
where os = o1,s  o2,s, and the quantum operations operate on the same I and O as above. So we only need to check that first composing the quan- tum operations and then restricting them is the same as first restricting and then composing. However, this follows from the analogous result for ordinary patterns [2].
For parallel composition, consider N2 = |n  Bi(i2,i, o2,i) : Q2,i.E2,i  σ2 in-
stead, with semantics as above. We then find that

 N ) ⊗  N ) :  Q
→  Q' .i → {(o, Lo1,s

o2,s
), ∀o	, o
},	(26)

1	2	i  i	i i
1	⊗ L2
1,s
2,s

where types, inputs and outputs are found by taking the (disjoint) union of those of the composing networks. Again, via the analogous result for ordinary

patterns [2], we find that (L
⊗L )os = Lo1,s
o2,s
, and therefore it follows

1	2	1	⊗ L2
that the above expression equals  N1 ⊗ N2). 
Entanglement contexts
In the previous section, the networks N1 and N2 individually operate on tensor product states of the form ⊗iρi, in accordance with the fact that these are local inputs provided by each of the agents, as is made explicit in Def. 2.7. While this is sensible when considering a network operating in isolation – in which case entangled input states are specified as preparations – it is less so when a network is only one factor in a complex compositional structure.
Indeed, already for sequential composition the input state is in general no longer disentangled over agents, since it is fed in partly as output of a previous network computation, and there is no guarantee whatsoever that this output is a product state. Another subtle difference lies in the fact that input spaces of individual agents are combined when composing networks. Concretely, while each agent supplies local inputs ρ1 when N1 is run separately, and ρ2 when
N2 is run separately, inputs to the composed network N2 ◦ N1 are generally
not of the form ρ1 ⊗ ρ2. Yet another situation is that where agents have mixed state inputs because their inputs are entangled into a state on a larger system than that which the network operates on – in fact one view is that
this is the only way in which mixed states arise. These are of course all typical manifestations of entangled states, but we want to stress the different situations in the context of distributed networks in which these arise. The

point is, is entanglement preserved when applying operations to only part of the entangled state? We show below that it does, by proving the a quantum operation applied to the A-system of a state ρ existing on system AC does not touch the part of this state in C. Each of the aforementioned situations can be cast in this form, since A may be a system of several agents entangled with a group of other agents described by system C, as well as an input system of one agent only entangled with another input system C. The quantum operation itself is defined to map states on A to states on B, because we want to consider situations where a network’s output spaces is different than its input space.
Proposition 2.11 Suppose L is a quantum operation on system A to system
B such that
L : D(HA) −→ D(HB): ρA −→ ρB = Σ LkρAL† .	(27)
k

Then for all quantum states ρAC living on a system AC, applying L to one half of ρAC results in
ρBC = Σ(Lk ⊗ IC)ρAC(L† ⊗ IC)	(28)
k
Proof. Note first that any complex matrix can be written as a linear com- bination of Hermitian matrices, which in turn can be written as a sum of
density matrices. Then by the spectral decomposition and linearity, it fol-
lows thΣat for all complex matrices Z we have L(Z) = Σk LkZL . Writing
†


ρAC =
ijkl αijkl|i⟩A|j⟩C ⟨k|A⟨l|C , we find that
(N ⊗ IC)ρAC = Σ αijkl(N ⊗ IC)(|i⟩⟨k|A ⊗ |j⟩⟨l|C)
ijkl
=	αijkl(	(Lk|i⟩⟨k|AL† ) ⊗ |j⟩⟨l|C)




(29)

ijkl	k
= Σ(Lk ⊗ IC)ρAC(L† ⊗ IC),
k
which proves the theorem. 
The proof, while easy, is not trivial, and has several important conse- quences. First of all, it shows that our statement in Sec. 2.2 on the fact that networks are schedule-independent is true. Indeed, agents transform parts of a shared entangled state via local operations, and the above results shows that any order results in the same multilocal quantum operation. Next, while we

have proved compositionality in the previous section considering only product state, we are now ensured that it holds also for arbitrary input states. We rely on Prop. 2.11 also in the next section, when we discuss sequencing sev- eral teleportation networks to transfer an entangled state from one agent to another.


Teleportation vs. quantum channels
In this section we prove that the teleportation protocol, described within our framework of networks of agents, is bisimilar to a direct quantum communi- cation of the qubit to be teleported. We first give the network specification for direct quantum communication. Next, we give the network for the tele- portation protocol, re-deriving the correctness of the protocol by developing its semantics in the local view elaborated in Sec. 2, which gives us a handle on qubit locations. A second goal of this section is to prove that it is bisimilar to a direct quantum channel. That is, by comparing the semantics of a direct quantum channel and that of teleportation – evolved in the correctness proof – we conclude that they do indeed define identical PTS’s. By Prop. 2.11, this holds in arbitrary entanglement contexts. This is a nontrivial result because these agents may be entangled with the qubit to be teleported, and it is not a priori clear whether this entanglement is preserved throughout TP. This re- sult has several consequences that we mention below. While the correctness of teleportation has been proved within other formal frameworks for distributed systems before [6,1], the bisimilarity approach, and specifically, taking into account arbitrary contexts, is new.
Consider a network of two agents named A and B. A direct quantum communication of a qubit is implemented simply by the network

N = A : {1}.(qc!1) | B.(qc?1)  0,	(30)
where 0 is the null state. Note that B has an empty sort. The small-step semantics, given input |ψ⟩, is derived in one step, and leads to the operational semantics

 N ) : ({1}, −) → (−, {1}).|ψ⟩ =⇒ |ψ⟩,	(31)
which immediately is the denotational semantics as well.
Consider the following network definition, which, as we derive explicitly

below, implements the teleportation protocol.


a = A : {1, 2}.[(c!s2s1).M 0,0]
b = B : {3}.[Xx2 Zx1 .(c?x2x1)]
NTP = a | b  E23

(32)

To derive the semantics of the above network, note that for the first step there is only one possibility, namely that agent A executes the local Bell measurement M 0,0. The latter requires a local quantum input from A, namely the qubit |ψ⟩ that needs to be teleported. This is clearly the case since the
pattern applies to qubit 1, which is not part of the system state E23. So by
rule (9) we need to apply the pattern to the first two qubits of |ψ⟩ ⊗ E23. Using first rule (9)and writing Γa = ∅[s2s1 '→ j2j1], we derive
|ψ⟩ ⊗ E23,M 0,0 −→1/4 Xj2 Zj1 |ψ⟩ , Γa
	1	12	3	 ,	(33)
E23, ∅, a =⇒1/4 Xj2 Zj1 |ψ⟩3, Γa, A.(c!s2s1)
where for each of the values of j2j1 the transition occurs with the same prob- ability of 1/4. This reduction fires within the context of (12), which we do not write out explicitly. The next step is a classical rendez-vous between both agents (i.e. Alice calls Bob), as per rule (10). Defining Γb = ∅[x2x1 '→ j2j1],
we get


Xj2 Zj1 |ψ⟩
▶ (Γa, A.(c!s s ) | ∅, B : {3}.[Xx2 Zx1 .(c?x x )]

3	2 1
3	3	2 1
(34)

=⇒ Γa, A | Γb, B : {3}.Xx2 Zx1 ).
3	3
The last step of the computation is the execution of a local pattern by agent B, as follows.

Xj2 Zj1 |ψ⟩ , Γa, A | Γb, B : {3}.Xx2 Zx1 =⇒ |ψ⟩ , Γa, A | Γb, B : {3}	(35)
3	3	3	3
The only probabilistic transition is the first one, due to the Bell measure- ment. However, we see that the four branches lead to identical final system state and agents specifications. Furthermore, since there is no classical in- put or output, we can trace out the different local states. Thus, adding the probabilities as specified in Def. 2.7, we find that for any input |ψ⟩, we have
 N )TP : ({1, 2}, {3}) → (−, {3}).|ψ⟩ =⇒ |ψ⟩	(36)
In other words, we find that  NTP ) ≡  N ).

Note that by linearity, the above derivation also works for mixed states. We have shown that a direct quantum channel is operationally equiva-
lent to the teleportation protocol. Suppose however, that two agents wish to exchange a qubit whilst they are contained in a larger network of agents. Can we say anything about the equivalence of both procedures in this con- text? By Prop. 2.11, we know that the entanglement with the larger system is conserved. Indeed, since teleportation just implements an identity chan- nel, applying teleportation to one half of the mixed state ρAC results in the state ρBC. Furthermore, suppose agent A wants to send an n-qubit entangled state to B. Then by the same result, A can just apply the teleportation pro- tocol n times, and, since entanglement is conserved, the state is transferred unchanged. It remains to be seen whether the conservation of correlations between agents can also be employed in higher-level applications. Consider- ing the fact that shared entanglement provides much of the extra power in distributed quantum systems, this behavior seems a promising primitive.

Conclusion
In this paper, we develop a formal model for distributed measurement-based quantum computations. We adopt an agent-based view, such that computa- tions are described locally where possible. Because the network quantum state is in general entangled, we need to model it as a global structure, reminiscent of global memory in classical agent systems. Local quantum computations are described as measurement patterns. Since measurement-based quantum computation is inherently distributed, this allows us to extend naturally sev- eral concepts of the measurement calculus (MC) [2], a formal model for such computations. Just as in MC, we aim at defining an assembly language, i.e. we assume that computations are well-defined and do not concern ourselves with verification techniques. The operational semantics for systems of agents is given by a probabilistic transition system, and we define operational equiv- alence in a way that it corresponds to the notion of bisimilarity. The de- notational semantics is given by a set of quantum operations, together with type information which determines the localization of resources. Both forms of semantics are proved to be equivalent, and we define a notion of network composition such that the semantics is preserved with respect to this oper- ation. Moreover, we show that within the larger entanglement contexts, the semantics is also conserved. With this in place, we prove that teleportation is bisimilar to a direct quantum channel, and, by the above-mentioned result, this also holds within the context of a larger network. Though the proof is quite simple, it is important within the context of agent systems. Indeed, the

possibility of inheriting agent correlations via teleportation means that, for example, collaborating agents are not cut off from each other when part of the shared data is transferred. Rather, the correlations are preserved in an oblivious manner. That this is the case if qubits are transported physically is clear, but that this remains so even if a general protocol is employed is maybe more surprising. It remains to be investigated how this preservation of the entanglement context can be exploited in more general situations. Also, there are other interesting situations to be investigated, such as the so-called channel inequalities, and more elaborate communication protocols. This is the subject of current investigations.

References
Abramsky, S. and B. Coecke, A categorical semantics of quantum protocols, in: Proceedings of the 19th annual IEEE Symposium on Logic (LICS) in Computer Science (2004), available as arXiv:quant-ph/0402130.
Danos,  V.,  E.  Kashefi  and  P.  Panangaden,  The  measurement  calculus	(2004),
arXiv:quant-ph/0412135.
Danos, V., E. Kashefi and P. Panangaden, 1-qubit versus 2-qubit measurement-based quantum computation (2005).
D’Hondt, E., “Distributed quantum computation – A measurement-based approach,” Ph.D. thesis, Vrije Universiteit Brussel (2005).
D’Hondt, E. and P. Panangaden, Quantum weakest preconditions, Mathematical Structures in Computer Science 16 (2006), pp. 1–23, available as arXiv:quant-ph/0501157.
Gay, S. J. and R. Nagarajan, Communicating quantum processes, in: P. Selinger, editor, Proceedings of the 2nd Workshop on Quantum Programming Languages (QPL04), Turku Centre for Computer Science (2004), available as arXiv:quant-ph/0409052.
Lalire, M. and P. Jorrand, A process algebraic approach to concurrent and distributed quantum computation: operational semantics, in: P. Selinger, editor, Proceedings of the 2nd Workshop on Quantum Programming Languages (QPL04), Turku Centre for Computer Science (2004), available as arXiv:quant-ph/0407005.
Leung, D. W., Quantum computation by measurements, Int. J. of Quant. Comp. 2 (2004),
pp. 33–43, available as arXiv:quant-ph/0310189.
Nielsen, M. A., Universal quantum computation using only projective measurement, quantum memory, and preparation of the 0 state, Phys. Lett. A 2-3 (2003), pp. 96–100, available as arXiv:quant-ph/0108020.
Nielsen, M. A. and I. Chuang, “Quantum computation and quantum information,” Cambridge University Press, 2000.
Raussendorf, R., D. E. Browne and H. J. Briegel, Measurement-based quantum computation on cluster states, Phys. Rev. A 68 (2003), p. 022312, available as arXiv:quant-ph/0301052.
Walther, P., K. J. Resch, T. Rudolph, E. Schenck, H. Weinfurter, V. Vedral, M. Aspelmeyer and A. Zeilinger, Experimental one-way quantum computing, Nature 434 (2005), pp. 169–176, available as arXiv:quant-ph/0503126.
