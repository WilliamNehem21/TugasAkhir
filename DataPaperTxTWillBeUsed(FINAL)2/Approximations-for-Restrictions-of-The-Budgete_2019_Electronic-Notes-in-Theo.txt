Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 346 (2019) 667–676
www.elsevier.com/locate/entcs

Approximations for Restrictions of The Budgeted and Generalized Maximum Coverage Problems
Breno Piva1
Departamento de Computa¸c˜ao Universidade Federal de Sergipe S˜ao Crist´ov˜ao SE, Brasil


Abstract
In this paper we present approximation preserving reductions from the Budgeted and Generalized Maximum Coverage Problems to the Knapsack Problem with Conflict Graphs. The reductions are used to yield Polynomial Time Approximation Schemes for special classes of instances of these problems. Using these approximation schemes, the existence of pseudo-polynomial algorithms are proven and, in more particular cases, these algorithms are shown to have polynomial time complexity. Moreover, the characteristics of the instances that admit these algorithms are analyzed.
Keywords: Budgeted Maximum Coverage, Generalized Maximum Coverage, Knapsack with Conflict Graph, Approximation Algorithm, Pseudo-polynomial Algorithm


Introduction
The Budgeted Maximum Coverage Problem (bmc) [6] is a generalization of the clas- sical Maximum Coverage Problem where an additional knapsack constraint is given. Formally, an instance of bmc is given by a collection of sets S = {s1, s2, ..., sm} de- fined over a domain of elements X = {x1, x2, ..., xn}, a cost function δ : S → Z, a budget L and a weight function ω : X → Z. A solution is a collection Sj ⊆ S with total cost not greater than L and maximizing the total weight of the cov- ered elements. For clarity reasons we present below an integer programming (ip) formulation for bmc.

1 Email:brenopiva@dcomp.ufs.br
2 The author would like to thank the anonymous referees for their invaluable suggestions.

https://doi.org/10.1016/j.entcs.2019.08.058
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).



(bmc)	z = max Σ ω(x)px	(1)
x∈X
subject to	Σ δ(s)qs ≤ L	(2)
s∈S
px ≤  Σ  qs	6 x ∈ X	(3)
s∈S:x∈s
px, qs ∈ {0, 1}; x ∈ X, s ∈ S	(4)


In the ip model for bmc variables px are binary and indicate whether element x ∈ X is covered or not and variables qs, also binary, indicate if set s ∈ S is in the solution or not. The inequality (2) is a knapsack inequality and defines that the cost of the solution is no greater than the budget. Meanwhile, restrictions (3) relate the two kinds of variables, defining that an element can only be covered if a set containing it is in the solution.
This problem has important applications in several areas including: recovery from power outage [5], location of network monitors [10], automatic text summariza- tion [11], software test-case prioritization [12], recruitment for participatory sensing data collections [9] and news recommendation systems [7] just to mention a few.
The Generalized Maximum Coverage Problem (gmc) [3] generalizes bmc by giving different weights and costs to items depending on the set used to cover it. Formally the problem can be defined as: given a collection of sets S = {s1, s2, ..., sm} defined over a domain of elements X = {x1, x2, ..., xn}, a cost function δ : S → Z,a second cost function δ : X×S → Z, a budget L and a weight function ω : X×S → Z, find a triple (Sj,Xj,f ) where Sj ⊆ S, Xj ⊆ X and f is an assignment function from Xj to Sj where the sum of the costs of sets in Sj plus the sum of the costs of covering the elements is no greater than L and maximizing the weighted sum of elements coverage. An ip model for gmc is presented below.
(gmc)	z = max Σ Σ ω(x, s)pxs	(5)
s∈S x∈s
subject to	Σ δ(s)qs + Σ Σ δ(x, s)pxs ≤ L	(6)
s∈S	s∈S x∈s
pxs ≤ qs	6 s ∈ S, 6 x ∈ s,	(7)

Σ

s∈S:x∈s
pxs ≤ 1,	6x ∈ X	(8)

pxs, qs ∈ {0, 1}; x ∈ X, s ∈ S	(9)


Binary variables pxs in model (gmc) define whether an element x ∈ X is covered by a set s ∈ S. The variables qs are also binary and indicate if a set s ∈ S is in the solution. Inequality (6) enforces that the sum of costs of covering the elements plus the cost of the selected sets must fit in the budget. Restrictions (7) state that an element x ∈ X can only be covered by a set s ∈ S if s is in the solution. Finally, inequalities (8) define that at most one set in S can cover an element in X.
Besides being a generalization of bmc (since any instance of bmc can be viewed as an instance of gmc where the cost of any element been covered is zero and the

weight of an element is always the same regardless of the set covering it) and thus having all the applications bmc has, gmc has applications in finding overlapping communities in graphs and social networks [4], planning sightseeing tours [2], link- based sensor selection [1] etc.
The approximation threshold proved by [6] and the obvious reduction from the Maximum Coverage Problem prove that bmc is strongly NP-hard and does not admit a Polynomial Time Approximation Scheme (ptas) unless P= NP. Since gmc is a generalization of bmc these innaproximability results extend to it.
The existence of a ptas or pseudo-polynomial algorithms for the two mentioned problems is unlikely (unless P= NP). It is possible, however, that such algorithms exist for special cases of the problems. In the current work we are going to show that such group of instances do exist and give necessary and sufficient conditions to identify subsets of these instances.
In the next sections we are going to present the polynomial time approximation preserving reductions from bmc and gmc to the Knapsack Problem with Conflict Graphs (kcg) and prove that they yield approximation algorithms for restrictions of these problems (Section 2). In Section 3 the characteristics of subsets of the instances of bmc and gmc that satisfy the conditions of the algorithms are displayed. Section 4 describes exact algorithms obtained from the approximations for special cases. Finally, in Section 5 we present some conclusions and future directions of research.

Reductions and Approximations
There are several knapsack problems with side constraints, one of these problems is kcg. An instance of this problem is given by a graph G = (V, E) where its vertices correspond to the knapsack items and its edges correspond to conflicts between items, a budget B, a cost function δ : V → Z and a weight function ω : V → Z. The goal is to select a set of items V j ⊆ V with maximum weight and respecting the budget and conflict constraints. Another way of looking at this problem is as a maximum weight independent set problem with knapsack constraint.
Since kcg can be viewed as a generalization of the maximum weight independent set problem, it is strongly NP-hard and does not admit a ptas. However it was proven in [8] that kcg has an fptas for instances where the conflict graphs are weakly chordal or have bounded treewidth.
In this section we are going to describe a reduction R that given an instance I1 = (S, X, L, δ1, ω1) of bmc produces R(I1) = I2 = (G = (V, E), B, δ2, ω2), an instance of kcg. Our hope is that using this reduction it is possible to obtain an approximation algorithm for bmc.
Let the set of vertices of G be V = V1 ∪ V2 ∪ V3 where V1 = {us|s ∈ S}, that is, there is a vertex for each set in collection S representing the presence of that set in the solution. V2 = {ws|s ∈ S}, meaning there is also a vertex for each set in S representing the absence of that set in the solution. At last, V3 = {vxs|s ∈ S, x ∈ s}, i.e., for each element x of X there is a vertex for each set of s ∈ S where x ∈ s,

these vertices represent that x is covered by that set.
The set of edges is defined as E = E1∪E2∪E3 where E1 = {(us, ws)|us ∈ V1, ws ∈ V2 and s ∈ S}, that is, the vertices that represent the presence and the absence of the same set of S in the solution cannot be part of the solution simultaneously. E2 = {(ws, vxs)|ws ∈ V2, vxs ∈ V3,x ∈ X and s ∈ S} meaning that if a set in collection S is absent in the solution, it cannot be used to cover any element of X.
Finally, E3 = S	{(vxr, vxs)|vxr, vxs ∈ V3 and r, s ∈ S} meaning that at most one
of the sets in S having an element x ∈ X will count as covering X. The definition
of E3 also means that for each x ∈ X there is a clique in G with vertices in V3
representing the sets s ∈ S where x ∈ s.
The cost function is given by δ2(us)= δ1(s) if us ∈ V1 and δ2(v)=0 if v /∈ V1. Budget B is equal to L. Finally, the weight function is given by ω2(vxs)= ω1(x) if

vxs ∈ V3 and ω2(us)=1 + Σ
x∈s
ω1(x) if us ∈ V1 ∪ V2.

Figure 1
presents an instance of kcg obtained from reducing instance Υ =

(S, X, L, δ1, ω1) of bmc where S = {s1 = {x1}, s2 = {x1, x2, x3}, s3 = {x1, x2, x3}, s4 = {x1, x2, x4}}, X = {x1, x2, x3, x4}, L = 11, δ1 = {(s1, 2), (s2, 9), (s3, 6), (s4, 4)} and ω1 = {(x1, 2), (x2, 5), (x3, 6), (x4, 3)}.



Fig. 1. Instance of kcg obtained from reduction R applied to Υ. The pair of numbers in parentheses represent, respectively the weight and cost of the vertex. The vertices with over-lined labels are the vertices in set V2 (representing the absence of that set in the solution) and their neighbor with degree one are the vertices in set V1 (representing the presence of that set in the solution). The remaining vertices compose set V3. The dashed ellipses put in evidence the cliques representing the vertices covering each element of
X.

Proposition 2.1 An instance I1 of bmc has optimal solution with value OPT (I1) if and only if I2 = R(I1), instance of kcg, has optimal solution with value OPT (I2)= 

Γ+ OPT (I1) where Γ= |S| + Σ

x∈s
ω1(x).

Proof. Let ς1 ⊆ S be an optimal solution for I1 and let Ξ1 ⊂ X be the set of

elements covered by this optimal solution, thus OPT (I1)= Σ

x∈Ξ1
ω1(x). Consider

the following solution of kcg: take into the solution all the vertices of subset V1 cor-
responding to elements of ς1 and vertices of subset V2 corresponding to elements of

S\ς1. The sum of the weights of these vertices is equal to |S|+Σ

x∈s
ω1(x)= Γ.

Now, for each element x ∈ Ξ1 include in the solution a vertex from V3 corresponding
to an element of ς1 that covers x. Since all the vertices in V3 corresponding to sets

covering x have weight ω1(x), the total weight of the solution is Γ + Σ

x∈Ξ1
ω1(x).

Moreover, we must notice that there is no conflict between the chosen vertices since
only one vertex corresponding to a set covering each x was chosen (no violation of set E3), only the vertices in V2 corresponding to sets not in ς1 were included in the solution (no violation of set E2) and, finally, the set of vertices chosen from sets V1 and V2 have no intersection (no violation of set E1).
Now to show the converse, let ς2 ∈ V be an optimal solution for I2 = R(I1) with value OPT (I2). First we must notice that any optimal solution of I2 must contain exactly one element of each pair of vertices where one is in V1 and the other in V2, indicating the presence or absence of a set from S in the solution. The reason why exactly one of them must be in the solution is that they cannot be both in the solution (set E1) and each one of them weight more than all its neighbors combined (except its pair which weights the same). The presence of these vertices in any optimal solution contribute with Γ to the value of the solution. The remaining of the solution’s value comes from the weights of vertices in V3, let us denote this set of vertices by V j. Therefore, if OPT (I2) = Γ + OPT (I1), that means that
Σvxs∈V ′ ω2(v)= OPT (I1). Notice that from E3, two vertices representing sets in S
covering the same element of X cannot be in the solution at the same time. Hence,
each vertex in V j covers a different element of X. Thus, there is also a solution of
I1 covering the same set and thus having value OPT (I1).
2
A reduction from gmc to kcg can be obtained simply by altering the weight and cost functions in the reduction. In gmc there is a cost function δ1 : S → Z for each element of S but there is also a cost function δ1 : X × S → Z for an element x ∈ X been covered by an element of S. Likewise, the weight function ω1 : X × S → Z indicates the weight of an element x ∈ X been covered by an element of S. Define δ2(us) = δ1(s) if us ∈ V1 and δ2(vxs) = δ1(x, s) if vxs ∈ V3. δ2(v) = 0 otherwise.

The weight function is defined as ω2(us) = 1 + Σ
ω2(vxs)= ω1(x, s) if vxs ∈ V3.
x∈s
ω1(x, s) if us ∈ V1 ∪ V2 and

Next we show that the reduction R described above preserves approximation, thus yielding a polynomial time approximation algorithm for a subset of bmc’s instances.
Proposition 2.2 If there is a (1 −ε)-approximation polynomial time algorithm for kcg, then there is a polynomial time algorithm for bmc that for any given instance I1 produces a solution with value z1 ≥ (1 − ε)OPT (I1) − εΓ.
Proof. First of all, it is easy to notice that reduction R is a polynomial time

reduction. Then, from Proposition 2.1 we know that an instance I1 of bmc with optimal solution value OPT (I1) has a corresponding instance I2 = R(I1) of kcg with optimal solution value OPT (I2) = Γ + OPT (I1). Besides, any solution ς2 of I2 can be split in the vertices in ς2 that are in V3 and the vertices in ς2 that are in {V1 ∪ V2}. The vertices in {V1 ∪ V2} contribute with value at most Γ while the vertices in V3 correspond to a solution for I1 with value z1. Hence, any solution ς2 of I2 has a value z2 ≤ z1 + Γ. Therefore, if there is a (1 − ε)-approximation for I2, we have (1 − ε)OPT (I2) ≤ z2 ≤ OPT (I2), hence (1 − ε)(Γ + OPT (I1)) ≤ z2 ≤ z1 +Γ ≤ Γ+ OPT (I1) and then, (1 − ε)OPT (I1) − εΓ ≤ z1 ≤ OPT (I1).	2
Proposition 2.3 Let I1 be an instance of bmc and let I2 = R(I1) be an instance of kcg obtained from I1 using the reduction above. If the graph in I2 is weakly chordal or has bounded treewidth then there is a family of approximation algorithms for I1 with approximation guarantee (1 − ε)OPT (I1) − εΓ and running time that is polynomial in |I1| and 1 . Moreover, this family of approximation algorithms for I1
deﬁnes a ptas.
Proof. The existence of a family of approximation algorithms for I1 comes straight from the existence of an Fully Polynomial Time Approximation Scheme (fptas) for kcg when the conflict graph is weakly chordal or has bounded degree [8] and from Proposition 2.2. Since Γ ≤ (M − 1)OPT (I1) where M = 2|S|max(|s|)max(ω1(x)), we can define εj =  ε . Hence, there is a solution z1 of I1 satisfying (1−εj)OPT (I1)−
εjΓ ≤ z1 ≤ OPT (I1).  By replacing εj for  ε  we get (1 − ε)OPT (I1) ≤ z1 ≤
OPT (I1).	2
Similar results as the ones in Proposition 2.2 and Proposition 2.3 can be achieved for gmc using the same ideas and the reduction described above.
Characterization of bmc and gmc Instances
From Proposition 2.3 we know there is an approximation algorithm for bmc when- ever the corresponding kcg instance is weakly chordal or have bounded treewidth. However it would be far more useful to know the characteristics of bmc instances that have corresponding kcg instances of these classes. In the current section we define what a bmc instance should look like for having a corresponding instance of kcg with weakly chordal conflict graph.
Proposition 3.1 The graphs generated by reduction R cannot contain an anti-hole.
Proof. Let I2 = (G, B, δ, ω) be an instance of kcg obtained from R. First of all, notice that all the vertices in set V1 have degree one and, therefore, can not be in an anti-hole. Now, let us try to construct an anti-hole using the vertices in V2 and V3.
The first case we consider is that of an anti-hole composed only by vertices in V3. Notice that the vertices in V3 are grouped in cliques corresponding to the sets in S covering the same element of X and vertices from two different cliques are non- adjacent. Without loss of generality, let v1, v2 and v3, be an anti-path composed by

vertices in V3 and part of an anti-hole. We have that v1 and v3 must be in the same clique and v2 in a different one. Let v4 be a fourth vertex in the anti-hole, following v3 in the anti-cycle. Since it follows v3 it must be from a different clique but since it is not a successor nor a predecessor of v1, v4 and v1 must be adjacent and therefore, must be in the same clique, but v1 and v3 are in the same clique. Contradiction.
Now suppose the anti-hole have vertices from V2. If we take any three vertices of any anti-hole, there is at least one edge connecting them, moreover, V2 induces an independent set in G. Therefore, any anti-hole can have at most two vertices from V2 and if there are two vertices, they must be consecutive. Since an odd-hole must have at least five vertices, if there is an anti-hole in G it must have vertices from both V2 and V3. Also notice that any vertex in V3 has exactly one edge connecting it to vertices in V2. Suppose without loss of generality that v1, v2 and v3 compose an anti-path that is part of an anti-hole where v1 ∈ V2 and v2, v3 ∈ V3, therefore, v2 and v3 must be from different cliques and we must have v1 = wsk , v3 = vxisk and v2 = vxjsl for some xi, xj ∈ X, sk, sl ∈ S, xi /= xj and sk /= sl. Now, let v4 be a fourth vertex in the anti-hole, following v3 in the anti-cycle. We have v4 /∈ V2 since if there are two vertices from V2 they must be consecutive, hence v4 ∈ V3. Also, we must have v4 = vxjsk and thus, (v2, v4) ∈ E3 and (v1, v4) ∈ E2. Finally, let v5 be a fifth vertex in the anti-hole, following v4 in the anti-cycle. Suppose v5 ∈ V2 then if v5 = wsp , it must be true that v2 = vxjsp and v3 = vxisp , but since v3 = vxisk and v2 = vxjsl and sk /= sl this is not possible. Suppose then v5 ∈ V3, hence v2, v3 and v5 must be in the same clique which is also impossible. Contradiction.	2
Consider the following two conditions regarding an instance I1 = (S, X, L, δ, ω) of bmc and the existence of a hole in the conflict graph of an instance I2 = R(I1) of kcg.
∃ si, sj ∈ S where |si ∩ sj|≥ 2	(10)
∀ si, sj ∈ S, |si ∩ sj|≤ 1 and ∃ Sj ⊆ S, |Sj| > 2 where there is an order

sj , sj , ..., sj ′
of its elements and sj ∩ sj
/= ∅	(11)

0	1	(|S |—1)
l	(l+1)mod|S′|

∀ l ∈ {0, ..., (|Sj|− 1)}
Proposition 3.2 The conflict graph of an instance I2 of kcg obtained from R(I1)
contain a hole if and only if condition (10) or (12) is satisﬁed.
Proof. (⇒) Suppose I1 satisfies condition (10). Then, there are two sets si and sj in collection S such that |si ∩ sj| ≥ 2, let us say that xk, xl ∈ si ∩ sj. Therefore, in graph G of I2, the sequence of vertices vxksi , vxksj , wsj , vxlsj , vxlsi , wsi , vxksi , where vxksi , vxksj , vxlsj , vxlsi ∈ V3 and wsj , wsi ∈ V2, induces a hole.
Assume, on the other hand, that I1 satisfies condition (12). Denote by xij the unique element in si ∩ sj for some pair of consecutive sets si, sj in the ordering of

Sj. Then, the following sequence of vertices where ws′ , ws′ , ..., ws′
∈ V2 and

vx01s′ , vx01s′ , vx12s′ , vx12s′ , ..., vx(|S′|−1)0s′  ′
0	1
, vx(|S′|−1)0s′
(|S′|−1)
∈ V3 induces a hole in

0	1	1	2
(|S |−1)	0

G: vx(|S′|−1)0s′ , ws′ , vx01s′ , vx01s′ , ws′ , ..., ws′  ′
, vx(|S′|−1)0s′  ′
, vx(|S′|−1)0s′ .

0	0	0	1	1
(|S |−1)
(|S |−1)	0

(⇐) Let us first consider some facts about graph G in I2 : (1) all vertices

in V1 have degree one, therefore, no vertex in V1 can be in hole. (2) V3 can be partitioned in cliques; there is one clique partition for each x ∈ X and the vertices in a same clique correspond to the sets s ∈ S such that x ∈ s. (3) there is no edge (vxisk , vxjsl ) ∈ E where vxisk , vxjsl ∈ V3 and xi /= xj, i.e., there is no edge connecting vertices from different clique partitions. (4) V2 induces an independent set in G and if a vertex in V2 have two vertices in V3 as neighbors, then they must be in different clique partitions of V3, i.e, if (ws, vxis) ∈ E and (ws, vxjs) ∈ E, where ws ∈ V2 and vxis, vxjs ∈ V3, then xi /= xj. (5) any vertex in V3 has exactly one neighbor in V2.
(6) since any vertex u in a hole H has exactly two neighbors v, w and v and w are
not adjacent, H can have at most two vertices from the same clique partition of V3. (7) for the same reason as in fact (6) and from facts (5) and (6), any hole H containing vertices from a clique partition of V3 must contain exactly two vertices from that partition and they are consecutive. (8) from (4), if a hole H contain a vertex u ∈ V2 then it must be true that, its two neighbors, v, w ∈ V3. (9) from facts (3) and (7), if a hole H contain a pair of vertices u, v ∈ V3, the pair must be preceded and succeeded by vertices in V2. (10) from facts (7), (8) and (9) we know that any hole in G must have vertices from both V2 and V3. Moreover, the vertices in V3 can only be taken in pairs and each pair must be preceded and succeeded by vertices in V2 which in turn must have two vertices in V3 as its neighbors. Therefore, any hole in G is composed by a sequence of two vertices in V3 (from the same clique partition) and one in V2, thus having a number of vertices that is a multiple of 3.
Suppose graph G in I2 has a hole H.  We are going to consider two cases:
|H| ≤ 6 and |H| > 6. If |H| ≤ 6, then |H| = 6 since the number of vertices must be a multiple of 3, there must be a sequence of vertices vxksi , vxksj , wsj , vxlsj , vxlsi , wsi , vxksi , where vxksi , vxksj , vxlsj , vxlsi ∈ V3 and wsj , wsi ∈ V2, hence condition
(10) is satisfied.
If |H| > 6, since |H| must be a multiple of 3, |H|≥ 3k with k > 2 and since any hole in G is composed by a sequence of two vertices in V3 and one in V2, H must be
composed by a sequence of vertices vx(|S′|−1)0s′  ′	, vx(|S′|−1)0s′ , ws′ , vx01s′ , vx01s′ ,

(|S |−1)
0	0	0	1

ws′ , ..., ws′
, vx
s′	where k = |Sj| > 2, ws′ , ws′ , ..., ws′
∈ V2

1	(|S′|−1)
(|S′|−1)0 (|S′|−1)
0	1	(|S′|−1)

and vx01s′ , vx01s′ , vx12s′ , vx12s′ , ..., vx(|S′|−1)0s′ ′
, vx(|S′|−1)0s′
∈ V3. Therefore,

0	1	1	2
(|S |−1)	0

condition (12) is satisfied.
2





From Propositions 3.1 and 3.2 we can deduce that an instance I1 of bmc has a corresponding instance R(I1) of kcg that has weakly chordal conflict graph if and only if I1 does not satisfy condition (10) nor condition (12).
Notice that the generalization provided by gmc has no influence in the structure of the graph obtained from the reduction to kcg. Therefore, all the results for bmc regarding the characteristics of the instances also hold for gmc.

Exact Algorithms
The ptas obtained from the reduction in Section 2 can be used to produce a pseudo- polynomial time algorithm for a restriction of bmc, i.e. instances of bmc with corresponding kcg instances with graphs that are weakly chordal or have bounded treewidth. This fact is described by Proposition 4.1.
Proposition 4.1 The algorithm from Proposition 2.3 can be used to produce a pseudo-polynomial time algorithm for that restriction of bmc.
Proof. Let I2 = R(I1) be an instance of kcg obtained from the application of reduction R to an instance I1 of bmc. Let OPT (I1) be the value of an optimal solution for I1 and OPT (I2) be the value of an optimal solution for I2. From the

definition of R we know that Γ = |S| + Σ
v∈V1
ω2(v) ≥ OPT (I1). Thus we can

define a bound B > Γ ≥ OPT (I1) and we can define ε =  1
in the algorithm from

Proposition 2.3. Since the solution of the algorithm has value z1 ≥ (1−ε)OPT (I1)−
εΓ, we have z1 ≥ OPT (I1) −εOPT (I1) −εΓ > OPT (I1) −εB −εB = OPT (I1) − 1.
Therefore z1 must be equal to OPT (I1).
Since the complexity time of the algorithm is polynomial in |I1| and 1 , with ε =
 1 it is polynomial in the size of a unary encoding of I1 thus, pseudo-polynomial.2
A restriction of special interest is the one where the weights of the elements are
bounded by some constant k that is independent of the instance. If this restriction applies, then the algorithm is actually polynomial in |I1| as shown in Proposition 4.2. This case has application, for instance, in the time-aware test-case prioritization problem [12] where the weights are unitary.
Proposition 4.2 If the weights of the elements in a instance of bmc are bounded by some constant k that is independent on the instance, then the algorithm from Proposition 2.3 can be used to produce a polynomial time algorithm for that restric- tion of bmc.
Proof. If the weights of the elements are bounded by a constant k then Γ ≤
k|S||X| + |S| and in the pseudo-polynomial algorithm from Proposition 4.1 we can

define B = k|S||X| + |S| + 1 and then ε =  1
is polynomial in the size of a binary

encoding of I1.	2
The same results can be achieved for gmc by making the proper modifications in Proposition 4.1 and Proposition 4.2.
Conclusions and Future Work
In the present paper we presented polynomial time reductions from bmc and gmc to kcg. These reductions allowed us to use an existing fptas for a restriction of kcg namely instances with weakly chordal graphs or having graphs with bounded treewidth, to obtain polynomial time approximation scheme, pseudo-polynomial exact and polynomial exact algorithms for restrictions of bmc and gmc. We deter-

mine a characterization for the instances of bmc and gmc yielding an instance of
kcg with weakly chordal graphs.
As a future work we leave the characterization of instances of bmc and gmc that have a corresponding instance of kcg that have conflict graphs with bounded treewidth.

References
Charu C. Aggarwal, Amotz Bar-Noy, and Simon Shamoun. On sensor selection in linked information networks. Computer Networks, 126:100 – 113, 2017.
Igo Ramalho Brilhante, Jose Antonio Macedo, Franco Maria Nardini, Raffaele Perego, and Chiara Renso. On planning sightseeing tours with tripbuilder. Information Processing & Management, 51(2):1 – 15, 2015.
Reuven Cohen and Liran Katzir. The generalized maximum coverage problem. Information Processing Letters, 108(1):15 – 22, 2008.
Esther Galbrun, Aristides Gionis, and Nikolaj Tatti. Overlapping community detection in labeled graphs. Data Mining and Knowledge Discovery, 28(5):1586–1610, Sep 2014.
Sudipto Guha, Anna Moss, Joseph (Seffi) Naor, and Baruch Schieber. Efficient recovery from power outage (extended abstract). In Proceedings of the Thirty-first Annual ACM Symposium on Theory of Computing, STOC ’99, pages 574–582, New York, NY, USA, 1999. ACM.
Samir Khuller, Anna Moss, and Joseph (Seffi) Naor. The budgeted maximum coverage problem.
Information Processing Letters, 70(1):39 – 45, 1999.
Lei Li, Dingding Wang, Tao Li, Daniel Knox, and Balaji Padmanabhan. Scene: A scalable two-stage personalized news recommendation system. In Proceedings of the 34th International ACM SIGIR Conference on Research and Development in Information Retrieval, SIGIR ’11, pages 125–134, New York, NY, USA, 2011. ACM.
Ulrich Pferschy and Joachim Schauer. Approximation of knapsack problems with conflict and forcing graphs. Journal of Combinatorial Optimization, 33(4):1300–1323, May 2017.
Sasank Reddy, Deborah Estrin, and Mani Srivastava. Recruitment framework for participatory sensing data collections. In Patrik Flor´een, Antonio Kru¨ger, and Mirjana Spasojevic, editors, Pervasive Computing, pages 138–155, Berlin, Heidelberg, 2010. Springer Berlin Heidelberg.
Kyoungwon Suh, Yang Guo, Jim Kurose, and Don Towsley. Locating network monitors: Complexity, heuristics, and coverage. Computer Communications, 29(10):1564 – 1577, 2006. Monitoring and Measurements of IP Networks.
Hiroya Takamura and Manabu Okumura. Text summarization model based on maximum coverage problem and its variant. In Proceedings of the 12th Conference of the European Chapter of the Association for Computational Linguistics, EACL ’09, pages 781–789, Stroudsburg, PA, USA, 2009. Association for Computational Linguistics.
Lu Zhang, Shan-Shan Hou, Chao Guo, Tao Xie, and Hong Mei. Time-aware test-case prioritization using integer linear programming. In Proceedings of the Eighteenth International Symposium on Software Testing and Analysis, ISSTA ’09, pages 213–224, New York, NY, USA, 2009. ACM.
