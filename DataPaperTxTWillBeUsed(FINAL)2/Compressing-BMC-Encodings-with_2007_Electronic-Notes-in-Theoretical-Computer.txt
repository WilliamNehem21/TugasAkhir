Electronic Notes in Theoretical Computer Science 174 (2007) 45–56	
www.elsevier.com/locate/entcs

Compressing BMC Encodings with QBF
Toni Jussila1	Armin Biere2
Institute for Formal Models and Verification Johannes Kepler University, Linz, Austria

Abstract
Symbolic model checking is PSPACE complete. Since QBF is the standard PSPACE complete problem, it is most natural to encode symbolic model checking problems as QBF formulas and then use QBF decision procedures to solve them. We discuss alternative encodings for unbounded and bounded safety checking into SAT and QBF. One contribution is a linear encoding of simple path constraints, which usually are necessary to make k-induction complete. Our experimental results show that indeed a large reduction in the size of the generated formulas can be obtained. However, current QBF solvers seem not to be able to take advantage of these compact formulations. Despite these mostly negative results the availability of these benchmarks will help improve the state of the art of QBF solvers and make QBF based symbolic model checking a viable alternative.
Keywords: Bounded Model Checking, Encoding, QBF, SAT.


Introduction
Bounded Model Checking (BMC) [3] has the motivation to improve on BDD based symbolic model checking by using SAT procedures. Already in the original paper the use of QBF decisions procedures was suggested as a tool to make BMC complete without using BDDs. Completeness means that an LTL property can also be shown to hold as opposed to just being able to find counter examples. In this paper we focus on simple safety properties, for which we want to prove that a bad state is not reachable. More general properties can be handled for instance through techniques from [14].
The completeness result of [3] uses the fact that the diameter of the system, which is the length of the longest shortest path between two states, is an upper bound on the length of potential counter examples. The question is how the diame- ter can be calculated. In [3] a QBF formula is presented parameterized by d, which is satisfiable resp. true, iff d is an upper bound on the diameter. Nevertheless this

1 Email: toni.jussila@jku.at
2 Email: armin.biere@jku.at

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.022

formulation was not used in the experiments, since efficient QBF solvers did not exist at that time.
In graph theory the notion of diameter is also known as eccentricity. To deter- mine the eccentricity of the state transition graph of sequential circuits has been investigated in [10]. The authors used a dedicated QBF solver for quantifier elimi- nation. However, the examples that could be handled are tiny. An argument why DPLL style QBF solvers can not handle this kind of problems well is given in [17]: in essence DPLL style QBF solvers need to perform an explicit state space search to determine the diameter.
However, it is possible to generate a purely propositional SAT formula without quantifiers for almost the same problem [3]. If it is unsatisfiable, it constitutes an upper bound on the diameter. This formula is parameterized by r and is unsatis- fiable iff there is no cycle free path of length r. In graph terminology a cycle free path is also called simple path, while in [3] the maximal length of a simple path is called reoccurrence diameter.
These concepts can be refined in two ways [15]: first the diameter and the reoccurrence diameter can be initialized. The paths, both in the QBF and in the SAT case, can be forced to fulfill the additional constraint that exactly the first state is an initial state. Furthermore, instead of looking for maximal simple paths starting from an initial state in a forward manner, one can work backward from a bad state. In particular the maximal length of a simple path for which exactly its last state is a bad state is also an upper bound on the maximal length of counter examples that need to be searched. We call such paths terminal.
In the special case k = 1 this technique amounts to check that the good states are an inductive invariant of the transition relation. Therefore the technique is also known as k-induction [15]. It seems to be much more successful in practice than forward checking, since it can utilize locality of properties, even if it is just implicitly through the SAT solver, while a forward formulation will need to take all state bits into account.
However, simple paths can be exponentially larger than their corresponding diameters, both in forward and backward reasonings. Therefore the question still remains, whether an approach using QBF reasoning would not allow to terminate the search for counter examples much earlier. Also the state of the art in QBF solver technology improved considerably in recent years [11].
To our knowledge, there are no published results on using QBF for backward reasoning yet. Unfortunately our experimental results for backward reasoning pro- vide a strong indication that similar to the forward reasoning results of [10,17] QBF based fixpoint algorithms can not yet really compete with BDD based or other com- plete model checking algorithms using SAT as discussed for instance in [1]. Not a single instance was solved that could not be solved with k-induction as well.
On the positive side we provide new compact formulations of bounded model checking problems and also show that in certain cases QBF based reasoning can outperform SAT based reasoning. Our benchmarks will be made publicly available. They will help to improve the state of the art of QBF solvers and hopefully lead to



model-checkμ
(I, T , B)

C = false ; N = I;
while N /⇒C do
if B Λ N satisfiable then return “bad state reachable”;
C = N ;
N = C V Img (C);
done;
return “no bad state reachable”;
Fig. 1. On-the-fly forward model checking algorithm for safety properties.


efficient QBF based model checking algorithms.
Finally, we experimented with functional and relational unrollings of the next state logic. The experiments clearly show that a functional unrolling is much more compact. The generated CNF is much smaller when using syntactic substitution for next state functions instead of conjoining the transition relations. The run times of the SAT solver also decreases considerably.


Background
Quantified boolean formulas (QBF) form a propositional logic with quantifiers over boolean variables. The QBF solvers we use only accept QBF in conjunctive normal form (CNF) in prenex form. The standard algorithm [18] for producing CNF for SAT can also be used for QBF after pulling out the quantifiers. The additional variables will be existentially quantified in the innermost scope. In the rest of the paper we do not require prenex CNF.
Our system model is the standard relational model used in symbolic model checking. It is a flat boolean encoded Kripke structure K with initial state con- straint I(s), transition relation T (s, s'), bad state constraint B(s) and good state
constraints G(s) with G(s) ≡ чB(s). Evaluations σ ∈ 2n of state variable vectors s, s', ... act as states. A state variable vector, in the following just short state variable, is made up of n individual state bits, which are just boolean variables. Individual state bits and equalities over state variables serve as atomic propositions.
A valid path of length k in K is an evaluation of state variables s0,... sk that satisfies the path constraint T (s0, s1) Λ T (s1, s2) Λ ··· Λ T (sk−1, sk). An initialized path constraint requires in addition that I(s0) holds, while a terminal path constraint requires that B(sk) holds. A bad state is reachable iff there is a satisfiable path
constraint for some k, which at the same time is initial and terminal. In this paper we only consider the problem of checking, whether a bad state is reachable.

Fixpoints
The algorithm of Fig. 1 is the standard BFS algorithm for checking simple safety properties with BDDs. The sets C and N as well as the relations I, T , and B are represented symbolically. The algorithm implements a fixpoint computation starting from the initial states, adding the next states N reachable in one step, with Img (C)(s') ≡ ∃s[T (s, s') Λ C(s)], from the current states reached so far C
until either a bad state B is found or the loop terminates. The focus of BMC is the
former while in this paper we concentrate on checking the loop condition.
The loop condition is invalid initially, and the loop is not even entered, iff I = false , or equivalently if I(s) is unsatisfiable. This can be checked by a SAT solver. The validity of the loop condition, after the first iteration can also be checked by a
SAT solver, since it is equivalent to the satisfiability of ∃s, s'[I(s) Λ T (s, s') ΛчI(s')]. If this formula is unsatisfiable then I actually turns out to be an inductive invariant of the transition relation.
However, after the second iteration the loop condition is equivalent to the satis- fiability of
∃s0, s1, s2[ I(s0) Λ T (s0, s1) Λ T (s1, s2) Λ
∀t0, t1[I(t0) Λ T (t0, t1) → (s2 /=t0 Λ s2 /=t1)]]
which is a proper QBF formula with one alternation. 3 In general, the loop condition is fulfilled after k iterations iff the following formula is satisfiable:
∃s0, s1,... , sk[ I(s0) Λ T (s0, s1) Λ ··· Λ T (sk−1, sk) Λ
∀t0, t1,... , tk−1[ I(t0) Λ T (t0, t1) Λ ··· Λ T (tk−2, tk−1) →
(sk /=t0 Λ ··· Λ sk /=tk−1)]]
Variations of this formulation, were also used in [10,17]. Their practical usage is rather restricted. There was not a single instance in our experiments, where initialized diameter checking, was doable this way, if it involved any alternation of quantifiers. Clearly much stronger QBF solvers are required.
Initial experiments in using the reoccurrence diameter were also unsuccessful. The instances are solvable for small k, but the reoccurrence diameter turns out to be too large for these examples and the SAT instances also become intractable very soon. This is in contrast to the experience with simple path constraints in k-induction. Therefore we suggest to represent the termination check for symbolic backward fixpoint computation as QBF decision problem as well:
∃s0, s1,... , sk[ T (s0, s1) Λ ··· Λ T (sk−1, sk) Λ B(sk) Λ
∀t0, t1,... , tk−1[ T (t0, t1) Λ ··· Λ T (tk−2, tk−1) Λ B(tk−1) →
(s0 /=t0 Λ ··· Λ s0 /=tk−1)]]

3 Here we need the common assumption that the transition relation T is total, which we will assume for the rest of the paper.

In our experiments it turns out that in this case two instances for k = 2 could be solved, for which also k-induction determined termination easily. Nevertheless, this negative result still shows that even when using QBF, backward computation may be superior to forward computation as it is the case with checking reoccurrence diameters versus k-induction.
For backward fixpoint calculations we actually used a slightly different formu- lation, as also used in SAT based k-induction [15], where T is replaced by TG with TG(s, s') ≡ G(s) Λ T (s, s'). If the formula is unsatisfiable then k is a bound on the maximum length of paths that have to be searched in order find a path to a bad
state, which only traverses good states except for the last state. This optimization may reduce the bounds that have to be checked considerably.

Non-Copying Iterative Squaring
Following the classical proof of PSPACE hardness of QBF [13,16] we can use non- copying iterative squaring to compute symbolically the transitive closure of the transition relation as follows:
T 2·i(s, s') ≡ E m [ 6c [ E l, r [ (c → ( l = s Λ r = m)) Λ
(c → ( l = m Λ r = s')) Λ T i(l, r)]]]
The universal “choice variable” c just instantiates the formal parameters (l, r) of T i(l, r) with either the actual parameters (s, m) in the positive case or (m, s') in the negative case. This is simply a compact QBF reformulation of copying iterative squaring
T 2·i(s, s') ≡ E m [ T i(s, m) Λ T i(m, s')]
which doubles the size of the formula with every application, while the non-copying formulation just adds some state variable equalities each time.
A similar formulation was discussed in [12] and has also been used in [2] to perform bounded model checking of very simple counter circuits. In the latter paper it has been observed that current state-of-the-art QBF solvers can barely keep up with SAT based bounded model checking on these examples. However, the QBF formula is linear in the model and logarithmic in the number of steps, which gives an at most quadratic formula in the number of state bits. The worst case only occurs if the sequential depth, e.g. the initialized diameter, really turns out to be 2n.

Simple Path Constraints
In [3,15] the concept of simple path constraints was introduced
(1)	si /=sj
0≤i<j≤k
Note that the size of this formula is quadratic in k and each si /=sj involves the comparison of n state bits. By sorting the si symbolically as in [9] an 0(k · log (k))

size bound can be obtained. In practice, due to large constants, simpler sorting networks with size 0(k · (log (k))2) are preferred, such as bitonic sort or odd-even mergesort. In our experiments we used the latter, since it requires slightly less comparisons than the bitonic sorting network used in [9].
If these constraints are conjoined with path constraints, they allow to obtain a complete model checking procedure. If the path constraints are initialized and the result becomes unsatisfiable, then k is a bound on the reoccurrence diameter [3]. If no counter example up to this length exists, no bad state is reachable. Similarly, if the simple path constraints are conjoined with a terminal path constraint, as in k- induction [15], then the unsatisfiability of the result, again shows that k is an upper bound on the maximal length of counter examples that need to be considered. The formula that is checked in k-induction is the following:

(2)
k−1
T (si, si+1) Λ
k−1
G(si) Λ B(sk) Λ
si /=sj

i=0
i=0
0≤i<j<k

Note, that the last state sk as a “good state” can never be equal to one of the previous “bad states”. Therefore, from Eqn. 1 we can remove comparisons with the last state in k-induction. A similar argument could be used for computing the reoccurrence diameter.

5.1	Compact Simple Path Constraints in QBF
One of our contribution of this paper is a reformulation of the simple path con- straints of Eqn. 1 in QBF as follows:

(3)
6l0,... , lk [ Es [ | Σ li| =1 →
i=0


  (li — (s = si))]
i=0

The resulting formula needs one alternation of quantifiers and is linear in k as op- posed to quadratic complexity of the original formula. Note that the state variables of the corresponding path constraints are free variables of this formula and are quantified existentially in the outermost scope for our applications.
In order to obtain linear complexity the cardinality constraint |Σk  li|, which
simply states that exactly one of the li is true, has to be encoded with a linear sized
circuit. This is easily possible, since for instance the ROBDD for this cardinality constraint for any variable order has linear size in k.
The additional “bits” l0,... , lk provide a one-hot encoding of the index of a reference vector, which is saved in s and is enforced to be different from all the other state vectors, e.g. li saves si as s and forces s to be different from all other sj with i /=j. A binary encoding of the index of the reference vector is also possible
and requires only [log 2k| additional universal variables.
This example already shows some of the modelling power of QBF, which, we believe, is hardly used in practice yet. But we can go one step further by sharing the transition relation across time frames as in [6]. Our QBF reformulation following

[6] of path constraints is as follows:
6l0,... , lk [ Es, s' [ T (s, s') Λ

(4)
k i=0
li| =1 →

 k−1(li → (s = si Λ s' = si+1)))]]
Putting both together we obtain a compact reformulation of simple path constraints in QBF with transition relation sharing:
6l0,... , lk [ Es, s' [ T (s, s') Λ

(5)
k i=0
li| =1 →

 k−1(li → (s = si Λ s' = si+1)) Λ

k i=0
(li — (s = si)))]]

Initial respectively terminal constraints can be added as needed. In the context of k-induction practical experience shows that adding good state constraints to the current state of the transition relation, as in Eqn. 2, improves performance and particularly decreases the bound k considerably. We can achieve the same effect in the QBF formulation by just adding G(s) to the innermost existential scope, thus, actually sharing G across time frames as well. In the experiments we used the latter version.

Transition Functions and Relations
SMV [5] allows two ways to specify the transitions that a system can make. We refer to these as functional and relational part. In the functional part (inside an ASSIGN section of the SMV file) the value of a variable in the next state is defined as a boolean function of the variable values in the current state. The relational part is simply a boolean formula where the atomic formulas are current and next state variables and this formula (given in the TRANS section of the SMV file) has to hold between any two states. An SMV file can contain both a relational and functional part to describe the system’s transition relation.
A functional transition relation allows an optimization in the translation to SAT/QBF when the transition relation (or the simple path constraint) is unrolled. Namely, for a functional state variable, it is possible to substitute its next state function in any state after the initial state. Thereafter, the representation can be simplified by propagating information from the initial state to subsequent states. Consider for instance variables x0 and x1 and let the SMV file contain the definitions init(x0) := 0 and next(x1) := !x0. Then it is obviously possible to infer that the value of x1 after the transition relation is unrolled once is 1 etc. We refer to this optimization as functional substitution. Notice that this substitution is not possible if QBFs are used to share the transition relation and the simple state constraint. In our experiments, we compare this optimized translation to a translation where functional substitution is disabled (considering the model be purely relational). Our

experimental results show that in some cases the optimization that functionality allows plays an important role.

Experiments
We have implemented our approach in a tool called smv2qbf. It reads flat SMV specifications with simple safety properties as input and translates them to QBFs. The tool has several switches corresponding to different model checking problems. It is possible to perform standard BMC, compute diameter and reoccurrence diameter, compute fixpoint, and do k-induction proofs [8]. For most of these problems, there are two or more encodings, the standard propositional one and one using more compact QBFs.
We present two sets of results, first of problems where it is possible to prove that the safety property holds using k-induction (the induction step eventually becomes unsatisfiable). Second, we have examples where a counterexample is found using standard BMC.
For the experiments we used a cluster of Pentium IV 3.0 GHz PCs with 2GB of main memory running Debian Sarge Linux. The time limit was set to 1000 seconds and the memory limit to 1GB of main memory. The examples that we use are from the TIP tool by E´en and So¨rensson [8]. We use quantor (version 2.13) [2] as the QBF solver. quantor uses a SAT solver as a back end and for this purpose we use picosat (version 1.251). We also compare quantor to another state-of- the-art QBF solver, qube (version 1.3) [7]. For every instance we tried, quantor performed better.
The results for the examples where the property is proven are shown in Tables 1 and 2. The columns of the tables are as follows. In both tables, the two leftmost columns give the name of the example and the bound needed to prove the property. Thereafter are 6 columns of the form s(x) (Table 1) and t(x) (Table 2), where x is the type of encoding, s(x) stands for size and t(x) for time. We use the following encodings for k-induction step:
i is the standard fully propositional encoding (Eqn. 2),
ir is i without functional substitution (see Sect. 6),
is implements simple state constraints with sorting networks,
isr is is without functional substitution,
l is an encoding where the transition relation is unrolled but the simple path constraints are encoded as given in Eqn. 3,
lr is l without functional substitution,
L is an encoding using Eqn. 5 using a one-hot index encoding, and
B is a modification of Eqn. 5 with binary index encoding.
A column of the form s(x) gives the size in kilobytes of the (SAT/QBF) formula for encoding x and the bound given in column k. The running time given in column t(x) is the time required to solve the single instance of encoding x corresponding to

the depth given in the column k. If the entry is of the form N/A then the memory limit was exceeded (we experienced no time outs).

Table 1
k-induction sizes

Tables 3 and 4 follow the same conventions as Tables 1 and 2, however, this time k is the smallest depth needed to find a counterexample. The encodings are as follows:
b, the standard propositional BMC encoding,
br is b without functional substitution,
C, a compact BMC encoding with a single copy of the transition relation (see Eqn. 4), and
S, a BMC encoding with noncopying iterative squaring (see Sect. 4).
Tables 1–4 seem to warrant the following conclusions. Applying QBF represen- tations yields in many cases smaller formulas and the difference seems to grow with larger bounds. This is especially so when the model is fully relational. This conclu- sion is rather obvious, though, since the QBF grows linearly and in the propositional case a new copy of the transition relation is needed when the bound is incremented. A perhaps more interesting observation is that the running times of the op- timized version of the propositional encodings (columns t(i) and t(b)) are always lower than the encodings using more compact formulas. We identify two reasons for this. First, propositional encoding allows one to perform optimizations (prepro-


Table 2
k-induction running times

Table 3 BMC sizes

cessing steps), like functional substitution (see Sect. 6) but also bounded cone of influence [4] in an efficient manner. 4 Indeed, it should be noted that for some test cases (like the examples vis.prodcell.*), when the SMV model is made fully rela- tional and thus no functional substitutions are possible, QBF encodings sharing the transition relation (columns t(L) and t(B)) perform better than the SAT encoding (column t(ir)).
Second, the research community has invested much more effort to implement efficient SAT solvers than is the case for QBFs. We expect more efficient QBF

4 Notice that we always reduce the model by cone of influence reduction in every encoding, particularly for the transition relation and comparing state variables. In addition, we only compare state variables that occur in both current and next states [8].


Table 4
BMC running times
solvers in the future.

Conclusion
This paper on one hand again provides negative results on using QBF for unbounded model checking and less negative for bounded model checking. On the other hand we were able to show that in practice QBF formulations can be much more com- pact than SAT instances and sometimes solved faster for relational encodings. Our results clearly show that much more research in QBF is needed to be able to use QBF as alternative to SAT based model checking, even in the bounded case.
The tool smv2qbf and the benchmarks in DIMACS format are available at
http://fmv.jku.at/smv2qbf.	We are currently working on producing structural benchmarks as well, in the form of and-inverter-graphs (AIGs).

References
N. Amla, X. Du, A. Kuehlmann, R. P. Kurshan, and K. L. McMillan. An analysis of SAT-based model checking techniques in an industrial environment. In Proc. CHARME’05, volume 3725 of LNCS. Springer.
A. Biere. Resolve and expand. In Proc. SAT’04, volume 3542 of LNCS. Springer.
A. Biere, A. Cimatti, E. Clarke, and Y. Zhu.	Symbolic model checking without BDDs.	In
Proc. TACAS’99, volume 1579 of LNCS. Springer.
A. Biere, E. Clarke, R. Raimi, and Y. Zhu. Verifying safety properties of a PowerPC microprocessor using symbolic model checking without BDDs. In Proc. CAV’99, volume 1633 of LNCS.
A. Cimatti, E. M. Clarke, E. Giunchiglia, F. Giunchiglia, M. Pistore, M. Roveri, R. Sebastiani, and
A. Tacchella. NuSMV 2: An opensource tool for symbolic model checking. In Proc. CAV’02, volume 2404 of LNCS.
N. Dershowitz, Z. Hanna, and J. Katz. Bounded model checking with QBF. In Proc. SAT’05, volume 3569 of LNCS. Springer.
A. Tacchella E. Giunchiglia, M. Narizzano. System description: QuBE A system for deciding quantified boolean formulas satisfiability. In Proc IJCAR’01, volume 2083 of LNCS.
N. E´en and N. S¨orensson. Temporal induction by incremental SAT solving. In Proc. BMC’03, volume 89 of ENTCS. Elsevier.
D. Kr¨oning and O. Strichman. Efficient computation of recurrence diameters. In Proc. VMCAI’03, volume 2575 of LNCS. Springer.
M. Mneimneh and K. Sakallah. Computing vertex eccentricity in exponentially large graphs: QBF formulation and solution. In Proc. SAT’03, volume 2919 of LNCS. Springer.


M. Narizzano, L. Pulina, and A. Tacchella. Report of the third QBF solvers evaluation. Journal on Satisfiability, Boolean Modeling and Computation, 2, 2006.
J. Rintanen. Partial implicit unfolding in the Davis-Putnam procedure for quantified boolean formulae. In International Conference on Logic for Programming, Artificial Intelligence and Reasoning (LPAR’01), 2001.
W. J. Savitch. Relation between nondeterministic and deterministic tape complexity. Journal of Computer and System Sciences, 4, 1970.
Viktor Schuppan and Armin Biere. Efficient reduction of finite state model checking to reachability analysis. Software Tools for Technology Transfer (STTT), 5(1-2):185–204, March 2004.
M. Sheeran, S. Singh, and G. St˚almarck. Checking safety properties using induction and a SAT-solver. In Proc. FMCAD’00, volume 1954 of LNCS. Springer.
L. J. Stockmeyer and A. R. Meyer. Word problems requiring exponential time. In 5th Annual ACM Symposium on the Theory of Computing, 1973.
Daijue Tang, Yinlei Yu, Darsh Ranjan, and Sharad Malik. Analysis of search based algorithms for satisfiability of quantified boolean formulas arising from circuit state space diameter problems. In Proc. SAT’04, volume 3542 of LNCS. Springer.
G. S. Tseitin. On the Complexity of Derivation in Propositional Calculus. In Studies in Constructive Mathematics and Mathematical Logic, Part II, volume 8 of Seminars in Mathematics. V.A. Steklov Mathematical Institute, 1968.
