Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 336 (2018) 299–314
www.elsevier.com/locate/entcs

Non-deterministic Effects in a Realizability Model
Niels F.W. Voorneveld 1
Faculty of Mathematics and Physics University of Ljubljana
Ljubljana, Slovenia

Abstract
We model non-deterministic effects for Turing computability by working in the assemblies of Kleene’s first partial combinatory algebra. Two methods will be discussed, one using equivalence relations on trees and one using topological descriptions of powerdomains. We describe these models for a selection of non- deterministic paradigms: angelic, demonic, convex and probabilistic. Though the first approach has a connection to traditional non-deterministic computability, the second approach works better for combining non-determinism with recursion. We establish morphisms from the tree models to the powerdomain models, which are bijective at ground type and give isomorphisms for all but the demonic case. We also see that any of the powerdomain models can be interpreted as a sub-monad of a continuation monad.
Keywords: Non-determinism, realizability, computability, powerdomains

Introduction
There are many approaches to understanding computability for higher-order com- putation [10]. A prominent one uses the notion of assembly on Kleene’s first partial combinatory algebra K1. This type of computability represents data using numerical codes and models extensional transformations of data using computable realizers. The category of assemblies is cartesian closed and so models higher type computabil- ity, which can accommodate computer science features like recursion at higher type [9]. In this paper we study how to model non-deterministic computation in assem-
blies interpreted in its various forms; angelic, demonic, convex and probabilistic. We thus model computability for higher order non-deterministic computation.
An initial attempt to do something similar was made by Taylor and Phoa in unpublished work from 1990 [12]. A modern perspective on their approach would

1 Email: niels.voorneveld@fmf.uni-lj.si
Thanks to my PhD supervisor, Alex Simpson
This material is based upon work supported by the Air Force Office of Scientific Research, Air Force Materiel Command, USAF under Award No. FA9550-14-1-0096

https://doi.org/10.1016/j.entcs.2018.03.029
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

be to view it as an instance of Power and Plotkin’s theory of algebraic effects [14]. Non-determinism can be modelled via powerdomains which are abstractly given as free algebras with respect to equational or inequational theories. This approach combines readily with categories of modest sets which are small subcategories of assemblies that enjoy remarkable completeness properties [6,7]. Due to these com- pleteness properties, powerdomains as free algebras are guaranteed to exist. See [1] for a related line of development using realizability over Kleene’s second combina- tory algebra K2.
The disadvantage of such abstractly defined powerdomains is that one does not a
priori get an explicit description of the construction. In this paper we approach the problem from a different angle, we consider explicit constructions of a powerdomain assembly PX for any assembly X, such that we can interpret the function space X → PY as the non-deterministic functions from X to Y .
After some technical background and preliminary results, we start by defining
an assembly TX of trees over an assembly X. We add various equivalence relations that interpret the trees using the different flavours of non-determinism. We have a functor sending an assembly to the resulting collection of equivalence classes on trees which forms a strong monad. Moreover, a relationship with non-determinism can be established via a connection with non-deterministic Turing machines.
Sadly, these tree models appear not to combine well with general recursion. In order to model recursion, assemblies need to be complete, meaning that sequences of approximations have a unique limit [9,11]. But this property seems difficult to establish for such tree models. For this reason, we study alternative models of non- determinism, inspired by topological descriptions of the familiar domain theoretic powerdomains [13,16,8]. These overcome the problem with completeness.
Moreover, we establish a relationship between the models, consisting of an em- bedding in one direction that is bijective at base type. These bijections at base type give isomorphisms for all but the demonic paradigm. Lastly, we look at how each of these models arise as a sub-monad of the continuation monad via theorems that can be seen as representation results for the computable powerdomains.

Technical background
Kleene’s first partial algebra K1 can be defined as the set N together with the partial algebraic map N × N ~ N denoted (a, b) '→ ab, giving the result of applying the a-th Turing machine on input b and outputting the result. We write ab ↓ if this terminates with a value, and ab ↑ if the program fails to terminate. Repeated application uses left association, abc = (ab)c. On terms created from constants, variables and applications one has lambda abstraction with weak head reduction.
An assembly A on K1 is given by a set |A| together with a map ||−||A assigning to each element a of |A| a non-empty set of natural numbers called the realizers of a. A (computable) morphism f : A → B between assemblies is given by a map f : |A| → |B| such that there is an n ∈ N with the property that ∀a ∈ |A|,x ∈
||a||X : nx ↓ ∧nx ∈ ||f (a)||A. This gives a cartesian closed category of assemblies

Asm on K1, where the function object BA consists of the morphisms f : |A| → |B| whose representations are all possible n ∈ N satisfying the above property. This category has finite products and finite co-products (pairing and summation), and:
The terminal assembly 1, where |1| = {∗} and || ∗ ||1 = N.
The natural numbers object N with |N| = N and ||n||N = {n}.
Finite binary sequences 2∗, where ||α||2∗ = {Σ0≤i<length(α)(αi + 1)2−i} We look at a specific assembly Σ, coinciding with the dominance in [15].
Definition 2.1 We take Σ such that: |Σ| = {T, ⊥}, with ||T||Σ = {n ∈ N : n0 ↓}
and ||⊥||Σ = {n ∈ N : n0 ↑}
Because of the undecidability of the Halting problem, we do not have the switch morphism Σ → Σ sending T '→ ⊥ and ⊥ '→ T. We get that Σ imposes a preorder, which we call the Σ-order, on each assembly A where for each a, b ∈ A we have:
x ≤A y :⇔ ∀u ∈ ΣA, (u(x)= T ⇒ u(y)= T)
For example we have ⊥ ≤Σ T but not T ≤Σ ⊥. By composition of morphisms we also have that for any f ∈ BA and x ≤A y we get that f (x) ≤B f (y). So all morphisms preserve the Σ-order. We have the following morphisms:
∨ :Σ × Σ → Σ with t ∨ r = T ⇔ t = T or r = T.
∧ :Σ × Σ → Σ with t ∧ r = T ⇔ t = T and r = T.
: ΣN → Σ where  f = T ⇔ ∃n, f (n)= T.
We do however not have a map  : ΣN → Σ such that  f = T ⇔ ∀n : f (n)= 
T. Such a map would need to check for an infinite number of programs whether they terminate, which one can’t do in a finite amount of time. By imposing the primitive operations we have similar properties on ΣA for any assembly A. Hence ΣA has the structure of a computable lattice of opens on A as we can interpret a map f : A → Σ as the subset {a ∈ A|f (a)= T} of A. We call ΣA the Σ-topology on A, which differs from a classical topology because of its computable nature. Morphisms are automatically continuous with respect to these Σ-topologies.
Definition 2.2 Let (−)⊥ : Asm → Asm be the functor where |A⊥| = |A| ∪ {⊥}
(disjoint union), with realizers: ||a||A⊥ := {n|n0 ↓, n0 ∈ ||a||A} and ||⊥||A⊥ = ||⊥||Σ
This functor adds a bottom element to each assembly. We get that ∀a ∈ |A| :
⊥ ≤A⊥ a but not a ≤A⊥ ⊥. This functor forms a monad adding partiality; let
⊥ : A → A⊥ denote the appropriate natural transformation.  The morphisms
N → N⊥ are precisely the partial computable functions from N to N.
For an assembly A, the regular subobject given by B ⊂ |A| is the assembly B
where |B| = B and ||b||B = ||b||A for all b ∈ B.
Definition 2.3 Let ω be the regular subobject of ΣN consisting of the morphisms
f : N → Σ satisfying:
∀n, m ∈ N , (m > n ∧ f (n)= ⊥) ⇒ f (m)= ⊥

∃n ∈ N ,f (n)= ⊥
Let ω¯ be the regular subobject of ΣN of elements only satisfying condition (i).
The assemblies ω and ω are carriers respectively for the initial algebra and final co-algebra of the functor (−)⊥. For a ∈ N ∪ {∞}, we write a ∈ ΣN for the function given by a(n)= T ⇔ (n < a). We get that |ω| = {a|a ∈ N} and |ω| = |ω|∪ {∞}.
These assemblies can be seen as ascending chains in the Σ-order, since for a, b ∈ N∪{∞} we have a ≤ω b precisely when a ≤ b. The topology on ω also induces some interesting continuity properties, as for any f ∈ Σω,f (∞)= T ⇔ ∃a ∈ ω, f (a)= T. A map f : ω → A can be seen as an approximation of an element in A, where the sequence {f (n)}n∈N approximates the limit f (∞). Take Aiω : Aω → Aω to be the morphism composing maps with the inclusion from ω to ω. The following property of an assembly A implements the completeness property: that every sequence in A
has a unique limit.
Definition 2.4 An assembly A is complete if Aiω is an isomorphism.
So for any sequence f : ω → A on a complete assembly, we can compute its unique limit (Aiω )−1(f )(∞). Completeness is an important property, as it is used to derive computable fixed point operators. By [9] we know that the assemblies 1 and N are complete, and that completeness is preserved under (−)⊥. For any A, completeness is also preserved under (−)A, as we can take the completion pointwise: we consider F ∈ (XA)ω as a morphism A → Xω and use completeness of X.
We will investigate assemblies of the form ΣΣA later on in the paper, so we end
this chapter with some properties about them.
Lemma 2.5 For u, v ∈ ΣA we have ∀a ∈ A, u(a) ≤Σ v(a) if and only if u ≤ΣA v.
Proof. Assume ∀a ∈ A, u(a) ≤Σ v(a). Let c : Σ → ΣA be t '→ (a '→ (u(a) ∨ (t ∧ v(a)))), then c(⊥)= u and c(T)= v. For Q ∈ ΣΣA , we have a map t '→ Q(c(t)) : Σ → Σ. This map must preserve ≤Σ, so Q(u) ≤Σ Q(v). For the converse, we can
use for a ∈ A the evaluation map w '→ w(a) in ΣΣA to show that u(a) ≤ v(a). 2
We write χV ∈ ΣN for the membership test on V ⊂ N, so χV (n)= T ⇔ n ∈ V . These exist for all finite V ’s since we have decidable equality on N . The following result is essentially the Rice-Shapiro theorem from computability theory.
Lemma 2.6 For Q ∈ ΣΣN and u ∈ ΣN such that Q(u) = T, there is some ﬁnite set V ⊂ N such that ∀n ∈ V, u(n)= T and Q(χV )= T.
Proof. Consider the map t : ω → Σ given by aˆ '→ Q(u ∧ aˆ). We have that
t(∞ˆ )= Q(u ∧ ∞ˆ )= Q(u)= T. By continuity, there is an n ∈ N such that t(nˆ)= T.
So for the finite set V := {m ∈ N |m < n, u(m) = T} we have χV = u ∧ nˆ, and
Q(χV )= t(nˆ)= T. Hence V has the desired properties.	2
Corollary 2.7 With Q, R ∈ ΣΣN , if for all ﬁnite sets V ⊂ N we have Q(χ ) = 
N
R(χV ) then Q = R. So ΣΣ	is ‘characterised’ by these χ .

Monads of trees
We think of non-deterministic computations as a computation with a series of binary choices until it outputs a result or goes into a loop. We can represent this structure using binary trees. A tree on A is a binary tree whose leaves are labelled with elements from A⊥ and which may have infinite branches. Each node or leaf of a tree has a location, a binary sequence α ∈ 2∗ which describes a path to a node with a series of left and right instructions. We say a tree t on A is constructed by a morphism f : 2∗ → (A + 1)⊥ if for any sequence α ∈ 2∗ and any β ∈ 2∗ extending or equal to α (written as α ± β, α is a subsequence of β) we have:

If t has a node (not a leaf) at α, then f (α)= η⊥
(inr(∗))

If t has a leaf ⊥ at α, then f (β)= ⊥(A+1)
If t has a leaf a ∈ |A| at α, then f (β)= η⊥

(inl(a))

Note that a morphism constructing a computable tree is necessarily unique. Any tree which is constructed by some morphism is called computable. The assembly of trees on A, denoted T A, consists of computable trees on A which are represented by realizers of the unique morphism that constructs them. We can represent the algebraic operator or : T A× T A → T A that simply joins two trees t and r into a single tree, which has a base node which branches into both t and r. For a morphism m : A → B, let Tm : T A → T B be the morphism that replaces the leaves of a tree t ∈ T A with (m)⊥(t). So T (−) forms an endofunctor on Asm.
Lemma 3.1 The endofunctor T (−) on Asm forms a strong monad.

Proof. For each A we have a morphism ηT
sending x ∈ A to the trivial tree only

having a single leaf x. It is realised by the code for λab.a.
The morphism μT : TT A → T A is given by replacing leaves with the trees within
A
2∗	2∗
them. To see it is computable, consider that given a morphism f ∈ ((A+1)⊥ +1)⊥
and α ∈ 2∗ one can search for the smallest subsequence β ± α such that f (β) = 

η⊥(inl(g)) with g ∈ (A + 1)2∗
and then for the smallest sequence γ such that α

extends the concatenation βγ and g(γ) = η⊥(inl(a)) for some a ∈ A. We can construct a computation that returns η⊥(inr(a)) if it finds this a, returns ⊥ if it got into a loop and ∗ if either f (α) = η⊥(inr(∗)) or g(γ) = η⊥(inr(∗)) for all

checked γ in the procedure. The resulting computation represents μT
as a map

A
2∗	2∗	2∗
from ((A + 1)⊥ + 1)⊥ to (A + 1)⊥ , the morphisms constructing TT A and T A.
Strength can be established by defining for any two assemblies A and B, the

map tT
: A× T B → T (A× B) by sending (a, t) to the tree created by replacing

each leaf l of t with (a, l). This map is computable since it uses some elementary
morphisms like pairing and currying on the morphisms constructing the trees.	2
Lemma 3.2 T A is a carrier of the ﬁnal co-algebra of X '→ (X × X + A)⊥.
Proof. We have an isomorphism Φ : (T A × T A + A)⊥ → T A, sending ⊥ to the trivial ⊥-tree, η⊥(inr(a)) to ηT (a) and η⊥(inl(f, g)) to (f or g).
Let B be an assembly with a morphism Ψ : B → (T B×T B+B)⊥. We recursively

define a map m : (T B × T B + B)⊥ → T A where: m(⊥) = trivial tree with leaf
⊥, m(η⊥(inl(x, y))) = (m(Ψ(x)) or m(Ψ(y))) and m(η⊥(inr(a))) = trivial tree with leaf a. Hence m◦Ψ is a morphism from B to T A, so T A has the desired properties.2
The given definition has a connection with Turing machine models of non- deterministic computations. The morphisms N → T N correspond to a represen- tation of non-deterministic Turing machines which on an input n will make binary choices until it outputs a value or gets into a loop. Here, no equivalences are taken into account as (0 or 1) is different from (1 or 0). So this model is quite intensional. We derive equivalence relations on T A according to non-deterministic paradigms.
We use the assembly of observations ΣA which describe semi-decidable prop-
erties of leaves. For a ∈ A and u ∈ ΣA, we say that a satisﬁes u if u(a) = T. For any u ∈ ΣA we write u⊥ ∈ ΣA⊥ for the morphism with u⊥(⊥) = ⊥ and u⊥(η⊥(a)) = u(a) for any a ∈ A. Since leaves of trees from T A are elements of A⊥, they can be ‘tested’ by observations in ΣA⊥ .
Definition 3.3 We say that t, r ∈ T A are lower-equivalent (t ∼l r) when for any u ∈ ΣA, if either t or r has a leaf a for which u⊥(a) = T then both have a leaf satisfying u⊥.
This corresponds to what is called angelic non-determinism, as it looks at which properties may hold for some possible sequence of choices. Another type, demonic non-determinism checks which properties must hold whatever the choices are. To effectively check this in a finite amount of time, one must furthermore require that the trees are finite.
Definition 3.4 We say that f, g ∈ T A are upper-equivalent (f ∼u g) if for any u ∈ ΣA we have, f is finite and all its leaves satisfy u⊥ if and only if g is finite and all its leaves satisfy u⊥.
Definition 3.5 Two trees f and g are convex-equivalent (f ∼c g) if they are both lower and upper equivalent.
Interpreting the tree as a combination of 50-50 chances (coin-flips), we define a function ℘ : ΣA × T A → [0, 1] which for (t, u) gives the probability that t satisfies
u⊥. More concretely, let Lt be the set of locations α ∈ 2∗ at which t has a leaf
−length(α)

satisfying u⊥. Then we can define ℘(u, t) := Σα∈Lt 2
. Here length(α)

denotes the height of the leaf, so 2−length(α) is the probability to end up in that leaf.
Definition 3.6 The trees t, r ∈ T A are probabilistically-equivalent (t ∼p r) if for all u ∈ ΣA, ℘(t, u)= ℘(r, u).
Maps N → Tl(N ) correspond to non-deterministic Turing machines which, for any input n, exhibit corresponding non-deterministic computations. The equiva- lence relation implements an angelic equivalence by which, for example, the compu- tations 0 and (0 or 1) are considered equivalent. The maps N → Tu(N ) corresponds to demonic non-deterministic Turing machines where ⊥ is considered the same as (0 or ⊥). The convex non-deterministic and probabilistic Turing machines are rep- resented respectively by the morphisms N → Tc(N ) and N → Tp(N ). So each

of the tree models can be seen as modelling Turing computability for a particular non-deterministic paradigm.
So for any of the notions of equivalence i ∈ {l, u, c, p} we can define an endo- functor Ti(−) on Asm given by T (−)/ ≡i. The equivalences are preserved under Kleisli lifts (t ≡ r ⇒ f∗(t) ≡ f∗(r)) as will be illustrated later. They also preserve the algebraic operator or. However, we do not know how to find a cartesian closed subcategory closed under Ti that only contains complete objects.
Topologically derived powerdomains
In order to get a model that combines non-determinism with completeness, we look towards complete powerdomains in domain theory. There are many descriptions of powerdomains, each sensitive to the domain theoretical setting. We want to choose the description that suits our setting best.
In Asm, we have structures that can be used to synthetically define a form of computable topology. In particular, Σ has the structure of the Sierpin´ski space S, and ΣA is a computable analogue to the lattice of open sets on A, just like in topology opens of X can be given by continuous maps X → S.
Described in [16], the lower powerdomain on some preorder X is the set of
completely prime upwards closed opens on the lattice of open sets O(X). In [3] this space has been proven to be equivalent to the continuous maps O(X) → S which preserve top, bottom and binary joins. We can use morphisms ΣX → Σ, which are automatically continuous with respect to the Σ-topologies, to describe these maps. We define our computable lower powerdomain as follows:
Definition 4.1 The lower-powerdomain of A, written Pl(A), is the regular subob- ject of ΣΣA consisting of the top and bottom preserving morphisms Q satisfying the property, ∀u, v ∈ ΣA, Q(u ∨ v)= Q(u) ∨ Q(v)
The upper powerdomain on X from [16] can be seen as Scott-continuous filters on the lattice of open sets O(X). By [3] these can be described as top and bottom preserving continuous functions O(X) → S which preserve finite meets. We again use the assembly ΣΣA to describe these maps.
Definition 4.2 The upper-powerdomain of A, written Pu(A), is the regular sub- object of ΣΣA consisting of the top and bottom preserving elements Q such that
∀u, v ∈ ΣA, Q(u ∧ v)= Q(u) ∧ Q(v).
The convex powerdomain introduced in [13] is a construction defined on coherent continuous domains. It is the set of convex patch-compact subsets with the Egli- Milner order. An alternative description used in [3] combines the lower and upper powerdomain. This model uses the topological space A = {⊥,I, T} whose non- trivial opens are {I, T} and {T}. The powerdomain is then described as the space of continuous top and bottom preserving maps c : O(X) → A with the properties:
∀A, B ∈ O(X): c(A)= ⊥ ⇒ c(B)= c(A ∪ B) and c(A)= T ⇒ c(B)= c(A ∩ B).
To describe A in Asm, we use the assembly Φ := Σ⊥, renaming the elements

of |Φ| as {⊥,I, T} such that ⊥ ≤Φ
I ≤Φ
T. This way, the assembly ΦΣA describes

continuous maps O(A) → A.
Definition 4.3 The convex-powerdomain over A is the subobject P (A) of ΦΣA made of top and bottom preserving elements Q such that for all u, v ∈ ΣA:
Q(u)= ⊥ ⇒ Q(u ∨ v)= Q(v)
Q(u)= T ⇒ Q(u ∧ v)= Q(v)
The probabilistic powerdomain on a space X as described in [8] is represented using valuations. These are maps μ : O(X) → [0, 1] assigning to each open of X a non-negative value that denotes the probability of that set. They satisfy the properties that for any A, B ∈ O(X), μ(∅)= 0, μ(A)+ μ(B)= μ(A ∪ B)+ μ(A ∩ B) and A ⊂ B ⇒ μ(A) ≤ μ(B). The probabilistic powerdomain consists of those valuations for which μ(X) = 1, hence these μ are both top and bottom preserving.
In our setting, we use the left computably enumerable (c.e.) real numbers in the interval [0, 1] described in [4]. A real number x is as such if the set {(p, q) ∈
N 2| p < x} is semi-decidable. We define the assembly [0, 1] of left c.e. real numbers
q	p
realised by those r ∈ N such that r(pair p q) ↓ ⇔ q < x. For this assembly we have
a computable operation ⊕ : [0, 1] × [0, 1] → [0, 1] that sends (x, y) to (x + y)/2.
Definition 4.4 The probabilistic powerdomain Pp(A) on A is the regular subobject
ΣA
of [0, 1]  of top and bottom preserving Q satisfying for all u, v ∈ Σ ,
Q(u) ⊕ Q(v)= Q(u ∨ v) ⊕ Q(u ∧ v)
Proposition 4.5 For any assembly A, we have that Pl(A), Pu(A), Pc(A) and
Pp(A) are all complete.
Proof. We know that Σ and Φ = Σ⊥ are complete. For the assembly of left c.e. reals [0, 1], consider f : ω → [0, 1]. By continuity we must have that f (∞) > p/q if and only if there is an a ∈ ω such that f (a) > p/q. Also, if f (a) > p/q then
f (∞) > p/q. So f (∞) = lima→∞ f (a). Hence there is  only one completion of maps
g : ω → [0, 1] constructed by taking defining gj : ω → [0, 1] as gj(^a) > p/q precisely
when	n(aˆ(n) ∧ g(n^) > p/q) = T. So [0, 1] is complete, and hence by closure

properties so are ΣΣA
, ΦΣA
ΣA
and [0, 1]	.

For the algebraically defined regular sub-objects, we can use the following trick. With P (A) ⊂ ΣΣA , we consider the equaliser of the two maps Q '→ λuv.(Q(u) ∨ Q(v)) and Q '→ λuv.Q(u∨v) from ΣΣA to ΣΣA×ΣA . This assembly is complete since it is the equaliser on a complete assembly. Pl(A) is the regular sub-object of this equaliser, defined by the bottom preservation condition. However for f : ω → ΣΣA we have by continuity that f (∞)(λa.⊥)= ⊥ only if f (a)(λa.⊥)= ⊥ for all a ∈ ω, and f (∞)(λa.T) = T only if there is an a ∈ ω with f (a)(λa.T) = ⊥. So top and bottom preservation is conserved in the ω-limits, hence Pl(A) is complete.
Pu(A) and Pp(A) go similarly, as both are top and bottom preserving regular
sub-objects of algebraically defined equalisers on complete assemblies.

For the convex case we need to be more careful. For fj : ω → ΦΣA we can always find the unique completion f : ω → ΦΣA argument-wise. So we only need to check that if f (a) ∈ Pc(A) for all a ∈ ω, we have f (∞) ∈ Pc(A). Firstly, f (∞)(u)= ⊥ iff f (a)(u)= ⊥ for all a ∈ ω, hence f (a)(v)= f (a)(u ∨ v). So we have by continuity that f (∞)(v) = f (∞)(u ∨ v). For the other property, note that if f (∞)(u) = T,
then there is an a ∈ ω such that f (a)(u) = T. So f (b)(v) = f (b)(u ∧ v) for any ˆb ∈ ω with b ≥ a. Hence f (∞^)(v)= f (∞^)(u ∨ v). So Pc(A) is complete as well. 2
Interpreting the trees
We have given two descriptions for each of our considered paradigms of non- determinism, one by establishing equivalences between trees and one using topo- logical descriptions of power domains. In this section we will establish that we can computably interpret trees from the former description as elements in the latter. This will also allow us to computably test the equivalence classes on trees, such that we can lift a function f : A → TiB to the Kleisli lift f∗ : TiA → TiB.
The lower equivalence relation checks for which observations u ∈ ΣA there is a leaf a such that u⊥(a)= T. We want to package this information into a single top
and bottom preserving element of ΣΣA⊥ . We define ∃	: T (A) → ΣΣA⊥ :
∃A(t)(u)= T ⇔ (u(⊥)= T) or (t has a leaf a such that u(a))
We give an explanation as to why this map is a computable morphism. Let f : 2∗ → (A + 1)⊥ be the morphism constructing the tree t. We use the obvious morphism γ : A⊥ → (A + 1)⊥. Note that a ∈ A⊥ is a leaf of t at α if and only if f (β) = γ(a) for any β extending α. This means there is a 1-1 correspondence between leaves of t and the set ‘image(f ) ∩ image(γ)’. Let (−˚): ΣA⊥ → Σ(A+1)⊥ be such that ˚u(η⊥(inr(∗))) = ⊥ and ˚u(γ(a)) = u(a). To check the different leaves of a tree t, we use the enumeration e : N → 2∗ of binary sequences to enumerate the domain of f . So we can find a representation of ∃A using a morphism on the maps that construct the trees: f '→ λu : ΣA⊥ .u(⊥) ∨  (˚u ◦ f ◦ e): (A + 1)2∗ → ΣΣA⊥
As an immediate consequence of the definition of ∃A, we have that for any two
trees t, r ∈ T A: ∃A(t)= ∃A(r) if and only if t ≡l r, and ∃A(t or r)= ∃A(t) ∨ ∃A(r). The following establishes that ∃A maps into Pl(A⊥).
Lemma 5.1 For any t ∈ T A we have ∃A(t) ∈ Pl(A⊥)
Proof. For u ∈ ΣA⊥ the top element, ∃A(t)(u) ≥Σ u(⊥) = T. If u is the bottom element, then ∃A(t)(u)= ⊥∨  (λn.⊥)= ⊥. So top and bottom are preserved.
Taking u, v ∈ ΣA⊥ both not the top element, then u ∨ v is not the top element either. We have ∃A(f )(u ∨ v) = T if and only if there is a leaf a of t such that (u ∨ v)(a) = T. So either a is a leaf such that u⊥(a) = T or it is a leaf such that v⊥(a)= T. Such a leaf exists if and only if ∃A(t)(u) ∨ ∃A(t)(v)= T.	2
We can conclude that ∃A can be seen as an injective map from Tl(A) to Pl(A⊥),
meaning it can be factored through an injective morphism ∃j : Tl(A) → Pl(A⊥).

For the upper case, we define ∀ : T A → ΣΣA⊥ using the description of the upper-equivalence relation and adding top preservation:
∀A(t)(u)= T ⇔ (u(⊥)= T) or (t is finite and all leaves satisfy u)
In the category Asm, a binary tree is finite if and only if there is some maximal length to its branches. Our enumeration e : N → 2∗ can be defined such that it enumerates the sequences in order of length, so we can use  n 2n−1≤m<2n+1−1(˚u ◦
f ◦ e(m)) to check whether for f ∈ (A + 1)2∗ there is some n such for all binary
sequences α of length n we have ˚u(f (α)) = T. This is true for f precisely when the
tree it constructs is finite and all its leaves satisfy u. Note that	2n−1≤m<2n+1−1 uses a finite combination of ∧ operations, hence it is computable. So we can computably represent ∀A using this construction, making it a computable morphism for any A. We have by definition that ∀A(t)= ∀A(r) if and only if t ≡u r, and ∀A(t or r)= 
∀A(t) ∧ ∀A(r). Mimicking the proof of 5.1 we also get the following,
Lemma 5.2 For all t ∈ T A we have ∀A(t) ∈ Pu(A⊥)
So ∀A can also be seen as an injective map from Tu(A) to Pu(A).
For the convex case, we want to combine the upper and lower case. For this purpose we define the following map, ⬦ :Φ × Φ → Φ as:
⎧⎪⎨T	if a = b = T

a ⬦ b =
⊥	if a = b = ⊥
⎪⎩I	otherwise

Let φ :Σ → Φ be the map preserving top and bottom. Using these we simply define
A⊥
∃∀A := (φ ◦ EA) ⬦(φ ◦ 6A): T A → ΦΣ	. Note that ∀	≤ΣΣA⊥ ∃A, which intuitively
means: if all leaves satisfy u⊥ ∈ ΣA⊥ then certainly there is a leaf that satisfies u⊥. One can see that ∃∀A contains all the information of both ∃A and ∀A.
Since it uses a combination of ∃A and ∀A, we have that ∃∀A(t)= ∃∀A(r) if and only if t ≡l r and t ≡u r, which is precisely when t ≡c r. Moreover, ∃∀A(t or r)= 
∃∀A(t)⬦∃∀A(r). This map again has its image within the appropriate powerdomain.
Lemma 5.3 The image of ∃∀A is included in Pc(A⊥).
Proof. Top and bottom preservation properties are carried over from ∃A and
∀A.  Let t ∈ T A and take u, v ∈ ΣA⊥ two observations which are not λx.T. If ∃∀A(t)(u) = ⊥, then ∃A(f )(u) = ⊥ hence there is no leaf of t satisfying u. So any leaf satisfying (u ∨ v) must satisfy v, hence ∃A(t)(u ∨ v) = ∃A(t)(v) and
∀A(t)(u ∨ v)= ∀A(t)(v). If ∃∀A(t)(u)= T we have ∀A(t)(u)= T. This means t is
finite and all its leaves satisfy u. So for any leaf we get that it satisfies (u ∧ v) if and only if it satisfies v. So ∃A(t)(u ∧ v)= ∃A(t)(v) and ∀A(t)(u ∧ v)= ∀A(t)(v).2
We can conclude that ∃∀A can be seen as an injective map from Tc(A) to Pc(A⊥).

Like in the probabilistic equivalence relation, we can also interpret trees as a
ΣA⊥
series of 50-50 coin flips, and define the map ΘA : T A → [0, 1]	as
ΘA(t)(u⊥)= ℘(u, t) for any u ∈ ΣA	ΘA(t)(λx.T)=1 
Here ℘ is the same as the one used in 3.6, except here we consider its output to be in [0, 1]. Of course, not all reals are left computably enumerable. So we check whether this map forms a well-defined computable morphism. Let t be a computable tree and f be the unique morphism constructing that tree. We define the n-th approximation of ℘(u, t) as: ℘n(u, t) :=   t	2−length(α). Note
u
that for α with length(α) = m ≤ n, there are precisely 2n−m binary sequences of length n extending α. Since 2n−m ∗ 2−n = 2−m we have that with f constructing t,
℘n(u, t)= 2−n#{α ∈ 2∗|length(α)= n, ˚u(f (α))}. Hence ℘n(u, t) is left computably enumerable. We get that ℘(u, t) = limn→∞℘n(u, t) is left computably enumerable,

since given (p, q) ∈ N2 we can compute ℘(u, t) > p
by looking for an n such that

℘n(u, t) > p . Hence Θ
q
A is a well-defined and computable morphism.

We have by definition that ΘA(t)= ΘA(r) ⇔ t ≡c r. With the following lemma, we can conclude that ΘA can be seen as an injective map from Tp(A) to Pp(A⊥).
Lemma 5.4 For t ∈ T A we have that ΘA(t) ∈ Pp(A⊥)
Proof. Obviously ΘA(t) preserves top and bottom. For u, v ∈ ΣA, the real number ΘA(t)(u⊥)⊕ΘA(t)(v⊥) is given by two summations, one over the leaves satisfying u⊥ and one over the leaves satisfying v⊥. If a leaf is used in either of the summations, it satisfies u⊥ ∨ v⊥ = (u ∨ v)⊥, and if it is used in both summations it satisfies u⊥ ∧ v⊥ = (u ∧ v)⊥. So one can see that the summations used in ΘA(t)((u ∨ v)⊥) ⊕ ΘA(t)((u ∧ v)⊥) can be created by redistributing the elements of the summations used in ΘA(t)(u⊥) ⊕ ΘA(t)(v⊥). Hence they approach the same value.	2
Take f : A → Tl(B) and the Kleislie lift f∗ : T A → Tl(B) via T . Assume t ≡l r, and u ∈ ΣB such that ∃B(f∗(t))(u)= T. Then there is a leaf a of t such that there is a leaf of f (a) satisfying u. Hence ∃A(t)(a '→ ∃B(f (a))(u)) = T, so since t ≡l r and by injectivity we have ∃A(r)(a '→ ∃B(f (a))(u)) = T meaning ∃B(f∗(r))(u) = T. We can conclude that f∗(t) ≡l f∗(r). So f∗ can be seen as a map TlA → Tl(B). Similarly we have Kleisli lifts for the other non-deterministic paradgims, using the results of Section 7 for the convex and probabilistic case.
Base case bijections
We have seen by construction that the maps ∃A, ∀A, ∃∀A and ΘA can be seen as injective maps from the tree models Ti(A) to the powerdomain models Pi(A⊥). We

denote these specific injective maps as ∃j , ∀j , ∃∀j and Θj
respectively. In this

A	A	A	A
section we will establish that these maps are bijections in the case that A = N , and
form isomorphisms in most of the base cases.
Note that |ΣA⊥ | = {u⊥|u ∈ ΣA} ∪ {λx.T} since ⊥ ≤A	ηT(a) for any a ∈ A.
Since all elements of the computable powerdomains on A⊥ are defined as top pre-

serving maps on domain ΣA⊥ , we can conclude that these elements are completely determined by their output on observations of the form u⊥ with u ∈ ΣA.
Lemma 6.1 The map Ej  : Tl(N ) → Pl(N⊥) is bijective and has an inverse.
Proof. Take Q ∈ Pl(N⊥). By 2.7, Q is completely determined by its output on the lifts of finite membership tests (χV )⊥. Now, since χV =	n∈V χ{n} we have by
R ∈ Pl(N⊥) we have that if 6n, Q((χ{n})) = R((χ{n})) then Q = R.
Hence for any tree t in T N whose leaves are precisely those n such that Q((χ{n})⊥) = T, we have EN (t) = Q. We can define the inverse with a mor- phism Δ from ΣΣN⊥ to T N which for each n has a leaf at location α = 0n1 which
is n if Q((χ{n})⊥)= T, else ⊥. This gives a computable inverse of Ej .	2
Lemma 6.2 The morphism 6j  : Tu(N ) → Pu(N⊥) is bijective, but does not have
a computable inverse.
Proof. Let Q ∈ P (N ). By the characterisation of ΣΣN in 2.7 we know that Q is determined by the values it outputs on inputs (χV )⊥ for finite sets V c N. Now we have that Q((χV )⊥) Λ Q((χW )⊥)= Q((χV Λ χW )⊥)= Q((χV ∩W )⊥), hence there is a single finite set V such that Q((χV )⊥) = T and Q((χW )⊥) = T iff V c W . So with t ∈ T N some finite tree whose leaves are precisely the elements of V , we have

6N (t)= Q. Hence 6j
is bijective.

Let τ : Σ → Pu(N⊥) be defined as τ (s)(u⊥) := (u(0) Λ u(1)) V (u(0) Λ s) for any u ∈ ΣN , and τ (s)(λx.T) = T. Then τ (T)((χV )⊥) = T if and only if 0 ∈ V and τ (⊥)((χV )⊥)= T if and only if {0, 1} c V . We define a map ρ : Tu(N ) → Σ that checks for t ∈ T N whether it is finite and it has a leaf labelled 1. This is well defined since it is invariant under the upper-equivalence. If we have a computable inverse κ : Pu(N⊥) → Tu(N ), then we have a map ρ ◦ κ ◦ τ :Σ → Σ. This map sends T to ⊥ since the inverse of τ (T) is the equivalence class of finite trees with only leaves labelled 0 (no 1 leaves), and ⊥ is sent to T since the trees in the equivalence classes mapped to τ (⊥) are finite trees with 1-leaves. So we have the switch map, which is impossible. We must conclude that the inverse is not computable.   2
In the convex case, things work out more neatly, because we have more infor- mation. Let Q = E6N (t) and ter ∈ ΣN be the test (λx.T), then Q(ter⊥) = T if and only if t is finite and has no ⊥-leaves. For each m ∈ N we have the mutually exclusive tests; I ≤Φ Q(( n≥m χ{n})⊥) checking whether t has a leaf m ∈ N with m ≥ n, and Q((χV<m )⊥)= T with V<m := {n|n < m} checking whether t is finite and all its leaves are natural numbers below m. If Q(ter⊥)= T, meaning t is finite, one of these two tests must terminate, hence making a decidable test of whether

all leaves are below m. We also construct a map sm : ΦΣN → N 
that gives ⊥ if

Q(ter⊥) /= T, and otherwise finds the first n ∈ N for which the now decidable check
I ≤Φ Q((χ{n})⊥) holds (it is decidable since otherwise Q((χN−{n})⊥) = T holds). So if t is finite without ⊥-leaves, sm(Q) will give the smallest leaf of t. We createa morphism Λ : Pp(N⊥) → TcN as follows, where we define what leaf or node Λ(Q) has at certain locations if no leaves preceded that location:

Λ(Q) has leaf sm(Q) at 0n+1 if Q((χV
	<m


)⊥)= T holds, and a node ∗ if I ≤Φ

Λ(Q) has a leaf at 0n1 if no leaf preceded it.  The leaf will be n if I ≤Φ
Q((χ{n})⊥) holds, and sm(Q) if Q((χN—{n})⊥)= T. If neither it will be ⊥.
From this construction we can see that Λ(Q) gives a tree whose leaves are precisely the leaves of t, and is infinite or has a leaf ⊥ if t is infinite.
With this map we can retrieve from Q some tree Λ(Q) such that Λ(Q) ≡c t. The following lemma establishes that all Q ∈ Pc(N ) originate from T N via E6N .

Lemma 6.3 The morphism E6j
is bijective and hence Λ forms an inverse.

Proof. Let Q ∈ Pc(N⊥
) and for convenience of notation let Qj ∈ ΦΣN be defined

such that Qj(u) := Q(u⊥). We do a case distinction by value of Qj(ter). Since for
any u ∈ ΣN we have u ≤ΣN ter we get Qj(u) ≤Σ Qj(ter). So a Qj with Qj(ter)= ⊥ will always give ⊥ except for the top element. Hence Q is reached by trees whose only leaves are ⊥. Now for the other cases:
If Qj(ter)= I, we need a tree that is somewhere terminating but not everywhere.
We have that for u ∈ ΣN , Qj(u) ≤Σ Qj(ter) = I. So Qj only outputs I or ⊥. If Qj(u) = ⊥ we have Qj(u V v) = Qj(v) = Qj(u) V Qj(v) for all v ∈ ΣN . If Qj(u)= I = Qj(v), then by u ≤ΣN uVv we have Qj(uVv)= I = IVI = Qj(u)VQj(v). So Qj is now a lattice with Qj(uVv)= Qj(u)VQj(v), and so is Q. Taking m :Φ → Σ sending ⊥ '→ ⊥ and I '→ T, we get that m ◦ Q is now in the lower powerdomain Pl(N ). Take t := Δ(m ◦ Q) the infinite tree constructed in 6.1, then E6N (t)= Q.
If Qj(ter)= T, we know by continuity that there is a finite set V c N such that
Qj(χV ) = T. Looking at all such finite sets, we know we can find a smallest one (by property (ii) of the powerdomain). Let V be as such, we have Qj(u) = T ⇔ χV ≤ΣN u. Now if Qj(u)= ⊥, then there are elements x ∈ V such that u(x)= ⊥. Take W c V all those elements. So χW Λ u = λx.⊥ and χV ≤ΣN u V χW . Since Qj(u)= ⊥, T = Qj(uVχW )= Qj(χW ), so χV ≤ΣN χW which means W = V . Hence u Λ χV = λx.⊥. Conversely, if we assume u Λ χV = λx.⊥, then ⊥ = Qj(λx.⊥) = Qj(χV Λ u)= Qj(u). So Qj(u)= ⊥ ⇔ χV Λ u = λx.⊥ ⇔ 6x ∈ V, u(x)= ⊥. We can conclude that all values for Qj and Q are determined by this one finite set V . So the finite tree whose leaves are precisely those from V is mapped into Q by E6N .2
For the lower and convex case, the inverses are established by constructing a specific tree in T N . So the inverses factor through T N and don’t need the equiv- alence classes to be well defined. In the probabilistic case however, we will depend heavily on the specific realizers of elements in the powerdomain. We use the con- venient decidable test on specific codes, ab ↓n that checks whether the a-th Turing machine applied to b terminates in n steps. In constructing a tree from some code of a powerdomain element, you can be careful by only checking a finite amount of things, so your tests are always decidable and never get you into a ⊥-loop.

Lemma 6.4 The morphism Θj
is bijective and has an inverse.

Proof. Take Q ∈ Pp(N⊥). Let χV ∈ ΣN be some observation where V is a finite set.

Since χV =  n∈V χ{n} and χ{n} Λ χ{m} = λx.⊥ if n /= m, we have that Q((χV )⊥) is the sum of all Q((χ{n})⊥) over n ∈ V . Since any u ∈ ΣN is approached by these finite χV (see 2.6) we have that Q is completely determined by the values Q((χ{n})⊥). So we need to construct a computable tree such that the probability
of ending up at a leaf n is an := Q((χ{n})⊥) ∈ [0, 1].
Let rQ ∈ ||Q||Pp(N⊥), and xe a realiser of the map n '→ (χ{n})⊥. For each m, we give a lower approximation of the probabilities by checking for all 0 ≤ n < m, 0 ≤ b ≤ m and 0 < a < 2b whether rQ(xe n)(pair a 2b) ↓m. This term will yield true for some m precisely if an >  a . This gives us a decidable approximation of the probabilities given by an. Note that for higher m we always gain information, never lose it. Now we generate the tree by using the m-th approximation at height m in the tree and outputting leaves whenever one has sufficient enough information to do

so. E.g. when at m we know that an >  a
we can make sure that for a2m—b different

binary sequences there is a leaf n at some subsequence. Using such a procedure, we can construct a tree approximating the probabilities level by level. This will give us an inverse morphism Θ—1 : Pp(N⊥) → Tp(N ).	2
7	Representation theorems
In the upper and lower case, our powerdomains are subobjects of ΣΣA , which has the structure of a continuation type. The functor ΣΣ(−) forms a monad, with the natural
morphisms defined as ηΣ(a) := (u '→ u(a)) and μΣ (F ) := (u '→ F (Q '→ Q(u))).
A	A
The morphism ηΣ(a) preserves both V and Λ for any a, and if F preserves V and/or
Λ then so does μΣ (F ). Hence Pl(−) and Pu(−) form sub-monads of this monad.
We end this paper by constructing a similar sub-monad of a continuation monad in the convex and probabilistic case. For the first one, we define the following structure as in [3], using the assembly Φ := Σ⊥ with renamed elements {⊥,I, T}.
Definition 7.1 The continuation convex powerdomain of A, denoted Cc(A), is the regular subobject of ΦΦA of top and bottom preserving maps Q satisfying:
6u, v ∈ ΦA, Q(u ⬦ v)= Q(u) ⬦ Q(v)
6u, v ∈ ΦA, Q(u)= ⊥ ⇒ Q(u V v)= Q(v)
6u, v ∈ ΦA, Q(u)= T ⇒ Q(u Λ v)= Q(v)
Proposition 7.2 For each A there is an isomorphism between Pc(A) and Cc(A).
Proof. This is essentially a computable version of what is done in [3]. So here we will only give the definition of the isomorphism. Let π0, π1 : Φ → Σ be the morphisms given by π0(a)= T ⇔ a ≥ I and π1(a)= T ⇔ a > I. The isomorphism is given by the following two maps:
Q '→ λu : ΦA.π0(Q(π0 ◦ u)) ⬦ π1(Q(π1 ◦ u)) : Pc(A) → Cc(A) Q '→ λu : ΣA.Q(φ ◦ u) : Cc(A) → Pc(A)
2
Definition 7.3 The continuation probabilistic powerdomain of A, denoted Cp(A)

is the regular subobject of [0, 1]
A
[0,1]
of top and bottom preserving maps Q such

A
that for all u, v ∈ [0, 1]	we have Q(u ⊕ v)= Q(u) ⊕ Q(v).
The following is a computable version of the Riesz representation theorem.
Theorem 7.4 For any A there is an isomorphism between Pp(A) and Cp(A).

Proof. Let ρ :Σ → [0, 1] be the morphism such that ρ(⊥)=0 and ρ(Τ) = 1, the top and bottom elements of [0, 1]. We define:
Ω: Cp(A) → Pp(A),	Ω(W )(u)= W (ρ ◦ u)
We check that Ω is well defined: Ω(W )(u) ⊕ Ω(W )(v) = W (ρ ◦ u) ⊕ W (ρ ◦ v) = 
W (ρ ◦ u ⊕ ρ ◦ v)= W (ρ ◦ (u V v) ⊕ ρ ◦ (u Λ v)) = W (ρ ◦ (u V v)) ⊕ W (ρ ◦ (u Λ v)) =
Ω(W )(u V v) ⊕ Ω(W )(u Λ v).

Using ⊕ we can define 
Σ1≤i≤2m pi
p	:=	. Let Υ : P (A) → C (A) be:

Υ(V )(f ) = lim
n'→∞
 
0<m≤2n
m
V (λa : A.(f (a) > 2n ))

Which can be alternatively expressed as Υ(V )(f ) = limn→∞ Σ1≤m≤2n 2—nV (λa : A.(f (a) >  m )). Here the > is interpreted as the morphism [0, 1] ×N 2 → Σ send- ing (f (a), m, 2n) to Τ iff the inequality holds. The sequence of reals within the limit does not decrease as n gets higher, hence it gives a computable lower approx- imation of some real number. So Υ(V )(f ) is some lower computably enumerable real in [0, 1] computable from V and f . We can approximate Υ(V )(f ⊕ g) with limk→∞limn→∞  0<m≤2n V (  0≤l≤2k λa : A.(f (a) >  l , g(a) > (  m −  l ))). So us-
ing the main property of V dividing the area under the functions f , g and f ⊕ g up
into blocks, we get that Υ(V )(f ⊕ g) > p if and only if Υ(V )(f ) ⊕ Υ(V )(g) > p .
Hence Υ(V )(f ⊕ g)= Υ(V )(f ) ⊕Υ(V )(g). We can conclude that Υ is a well-defined
computable morphism into Cp(A).
Now to prove they are each other’s inverses. Take V ∈ Pp(A) and u ∈ ΣA. We
have Ω(ΥΣ(V ))(u)= Υ(V )(ρ ◦ u) = limn→∞ Σ1≤m≤2n 2—nV (λa : A.ρ(u(a)) >  m )= 

limn
1≤m≤2n 2—nV (λa : A.u(a) Λ (1 > m )). Now, V (λa : A.u(a) Λ (1 >  m ))

→∞	2n	2n
is V (u) for m < 2n and 0 for m = 2n. Hence the limit over n approximates V (u).
We can conclude that Ω(Υ(V ))(u)= V (u).
For W  ∈ Cp(A), Υ(Ω(W ))(f ) = limn→∞  m≤2n Ω(V )(λa : A.f (a) >  m ) = 

limn
m≤2n V (λa : A.ρ(f (a) >  m )) = lim	V (	m≤2n λa : A.ρ(f (a) >  m ))

→∞	2n	n→∞	2n
which is by continuity the same as V ( n  m≤2n λa : A.ρ(f (a) >  m )) = V (λa :
A. max{  m |(m, n) ∈ N 2,  m < f (a)})= V (λa : A.f (a)) = V (f ).
2n	2n
We can conclude that Ω and Υ form an isomoprhism.	2
A direct result of this theorem relates to affine maps between probability spaces.
Corollary 7.5 An isomorphism exists between A → Pp(B) and the space of com-

B
putable affine morphisms [0, 1]
−→
affine
A
[0, 1]

References
Ingo Battenfeld, “Topological Domain Theory”, PhD thesis, (2008)
Ingo Battenfeld, Observationally-induced Effects in Cartesian Closed Categories, Electronic Notes in Theoretical Computer Science, 286 (2012) pp. 43-56
I. Battenfeld, K. Keimel, T. Streicher, Observationally-induced Algebras in Domain Theory, Logical Methods in Computer Science 10(3:18) (2014), pp. 1-26
Rodney G. Downey and Denis R. Hirschfeldt, “Algorithmic Randomness and Complexity”, (2010)
Gerhard Gierz, Karl Heinrich Hofmann, Klaus Keimel, Jimmie Lawson, Michael Mislove, and Dana S. Scott. “Continuous Lattices and Domains”. Cambridge University Press, Cambridge, (2003)
J.M.E. Hyland, A Small Complete Category, Annals of Pure and Applied Logic, 40 (1988) pp. 135-165
J.M.E. Hyland, E.P. Robinson, G. Rosolini, The discrete objects in the effective topos, Journal Proceedings of the London mathematical society 3(1) (1990) pp. 1-36
Claire Jones, “Probabilistic Non-determinism”, PhD thesis. (1989)
J. R. Longley, “Realizability Toposes and Language Semantics”, PhD thesis, (1994).
John Longley, Dag Normann, “Higher-Order Computability” Springer-Verlag, (2005)
John Longley, Alex Simpson, A uniform approach to domain theory in realizability models Math. Struct. in Comp. Sci. 7(5) (1997) pp. 469-505
Wesley Phoa and Paul Taylor, The Synthetic Plotkin Powerdomain, Unpublished notes, (1990)
G. D. Plotkin, A Powerdomain Construction, Siam J. Comput. 5(3), (1976), pp. 452-487
Gordon Plotkin and John Power Algebraic Operations and Generic Effects, J. Applied Categorical Structures, 11 (2003) pp. 69-94
Giuseppe Rosolini, “Continuity and effectiveness in topoi”, PhD thesis (1989)
M. Smyth, Power domains, J. Comput. System Sci., 16 (1978), pp. 23-36
M. Smyth, Power domains and predicate transformers: a topological view, Proc. Internat. Colloquium on Automata, Languages and Programs, 154 (1983), pp. 662-676
