

Electronic Notes in Theoretical Computer Science 239 (2009) 167–178
www.elsevier.com/locate/entcs
Reachability in Timed Counter Systems 1
Florent Bouchy†, Alain Finkel† and Arnaud Sangnier†,‡
†LSV, ENS Cachan, CNRS ‡EDF R&D 61 avenue du Pr´esident Wilson
94230 Cachan, France
{bouchy,finkel,sangnier}@lsv.ens-cachan.fr


Abstract
We introduce Timed Counter Systems, a new class of systems mixing clocks and counters. Such systems have an infinite state space, and their reachability problems are generally undecidable. By abstracting clock values with a Region Graph, we show the Counter Reachability Problem to be decidable for three subclasses : Timed VASS, Bounded Timed Counter Systems, and Reversal-Bounded Timed Counter Systems.
Keywords: Counter Systems, Timed Automata, Verification, Reachability, Petri Nets, VASS, Reversal-Bounded


Introduction
Context. Formal verification of systems featuring temporal constraints or counting abilities has been largely studied. Indeed, clocks seem to be the most natural way to model time, and counters appear as the most used dataype in case studies. Usually, such systems are finite automata endowed with clocks or counters, whose values are determined by operations associated to automata transitions. In this paper, we follow this widespread approach and define Timed Counter Systems, based on two well-known models. Indeed, we express the same temporal requirements as timed automata [2], and we use counter systems extending Minsky machines [24] (more precisely, a combination of relational counter automata [11] and functional Presburger counter systems [16]). Timed Counter Systems have thus two different datatypes at the same time : continuous (i.e. real-valued, or dense) clocks, and discrete (i.e. integer-valued) counters.
Related work. A few classes of systems mixing clocks and counters have already been studied. Hybrid automata [1], a well-known extention of timed automata,

1 Work supported by the Agence Nationale de la Recherche, grant ANR-06-SETIN-001.

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.038

is a class able to encode Timed Counter Systems by simulating counters with the clocks’ differential trajectories ; however, it is so general that the reachability problem remains undecidable even for very restricted subclasses. Several timed versions of Petri Nets are well-known (e.g. time intervals [23] or aging tokens [10]), but neither of them is able to easily simulate our clocks ; even when they do, our counters are more expressive. Dense Counter Machines [25] are Minsky machines augmented with non-deterministic fractional value changes ; they are not comparable to Timed Counter Systems, because their dense datatype has a different behaviour than our clocks. The same authors also defined Real-counter Automata [14], but it is not clear that they may encode our clocks and counters. They also investigated variations of Pushdown Timed Automata [13], in which the stack could be viewed as a counter ; but their clocks are integer-valued, and thus can be simulated by our clocks. Finally, Parametric Timed Counter Systems are used in the TReX tool [3,4], but their expressivity is not comparable to the one of Timed Counter Systems (see [15] for a study thereof) ; indeed, their clocks are more expressive than ours, but their counters are less expressive than ours (excepted some arithmetical terms using multiplication, which is not possible with our counters). Nevertheless, the systems of TReX are highly undecidable for reachability matters, and have no decidable subclass which seems natural, to the best of our knowledge.
Our contributions. A major interest in verification is reachability ; in this paper, we address the Counter Reachability Problem for Timed Counter Systems, in which the exact clock values are left apart (as usually done with timed automata). We prove it to be decidable for subclasses of such systems, in which the Region Graph belongs to a class of counter systems for which this problem is decidable. We also identify three of these subclasses.

Timed Counter Systems
Preliminary deﬁnitions
In order to use a homogeneous model for systems mixing clocks and counters, let us first define the basis we will be using. The next two paragraphs explain our way to handle clocks and counters, so that they can be handled at the same level.

Clocks
Let X be a set of m real-valued variables, called clocks. A clock valuation over X is a vector x ∈ Rm. Given a clock valuation x and a duration τ ∈ R+, x + τ is the clock valuation defined by (x + τ )i = xi + τ for every i ∈ [1, m].
Let RX = GX × {0, 1}m be the set of operations on clocks, where :
GX denotes clock constraints (or guards), defined by the following grammar :
g ::= x − y da b | x da b | g ∧ g | ¬g, with da∈ {<, ≤, =, ≥, >}, x, y ∈ X, b ∈ N.
{0, 1}m intuitively denotes the clocks to be reset.

For a guard g ∈ GX and a clock valuation x ∈ Rm, we denote by x |= g the fact that the clock valuation x satisfies the guard g. By convention, when X = ∅, then RX = {∅}. Let x, x' ∈ Rm and (g, λ) ∈ RX . Then (x, x') |= (g, λ) is defined by :

x |= g and ∀i ∈ [1, m], λi = 0 =⇒ x'
= 0 and λi = 1 =⇒ x'
= xi (or, more

simply, x' = λixi).
From now on, for the sake of readability, we suppose that clock guards do not use atomic diagonal guards (i.e. guards of the form x−y da b), and this, w.l.o.g. : indeed,
[9] introduces a translation of timed automata into diagonal-free timed automata.

Counters
Let C be a set of n integer-valued variables, called counters. A counter valuation over C is a vector c ∈ Zn. Let RC ⊆ Zn × Zn be the set of relations which can be defined with a Presburger formula. Intuitively, such binary relations describe the effect of a transition on the counters ; that is, for some r ∈ RC, (c, c') ∈ r means that the valuation on counters is c before a transition labelled by r, and is c' after this transition. In fact, we encode the guards and operations on counters in a single formula r, whose solutions are (c, c'). By convention, when C = ∅, then RC = {∅}.
Syntax
Definition 2.1 A Timed Counter System (TCS for short) is a tuple ⟨Q, X, C, E⟩
where :
Q is a finite set of control states (also called locations)
E ⊆ Q × RX × RC × Q is a finite set of transitions (edges)
Notice that a TCS is in fact a combination of two well-known models : Timed Automata and Counter Systems. Let us define both of them with our notations :
Definition 2.2 A Timed Automaton (TA for short) is a TCS S where C = ∅. Similarly, a Counter System (CS for short) is a TCS S where X = ∅.

Semantics
In order to study the behaviour of a TCS, one can look in 3 directions, according to which kind of variables are interpreted. Indeed, a TCS can be unfolded along its clocks only, or along its counters only, or along both at the same time. We say that a TCS whose interpretation considers only clocks (resp. counters) is called a Timed (resp. Counting) Transition System ; if both clocks and counters are interpreted, then the full semantics of a TCS is given by a Transition System.
Timed Semantics
The timed behaviour of a TCS is described by a Timed Transition System (TTS) :
Definition 2.3 The timed semantics of a TCS S = ⟨Q, X, C, E⟩ is given by a tuple
TTS(S)= ⟨ST , →T ⟩, where :

ST = Q × Rm is the set of configurations
→T ⊆ ST ×(E ∪ R+) × ST is the transition relation composed of delays and steps :

⎧⎪	(delay, noted
→τ T )

(q, x) →T (q', x') ⇐⇒ ⎪⎨
q = q' and ∃τ ∈ R+ such that x' = x + τ

(step, noted →e T )
⎪⎩	∃e = (q, (g, λ), r, q') ∈ E such that (x, x') |= (g, λ)
Notice that if S is a TA, then TTS(S) gives the usual timed semantics of TA.
Counting Semantics
The counting behaviour of a TCS is described by a Counting Transition System (CTS) :
Definition 2.4 The counting semantics of a TCS S = ⟨Q, X, C, E⟩ is given by a tuple CTS(S)= ⟨SC, →C⟩, where :
SC = Q × Zn is the set of configurations
→C⊆ SC × E × SC is the transition relation defined by (q, c) →e C (q', c') ⇐⇒
∃(q, (g, λ), r, q') ∈ E such that (c, c') ∈ r
Notice that if S is a CS, then CTS(S) gives the usual semantics of CS.
Full Semantics
We give the complete (i.e. timed and counting) behaviour of a TCS by combining a TTS and a CTS as follows :
Definition 2.5 The full semantics of a TCS S = ⟨Q, X, C, E⟩ is given by a tuple
TS(S)= ⟨S, →⟩, where :
S = Q × Rm × Zn is the set of configurations
→⊆ S × (E ∪ R+) × S is the transition relation composed of delays and steps :
⎧⎪	(delay, noted →τ )



(q, x, c) → (q', x', c') ⇐⇒
⎪⎪⎨
q = q' and c = c' and ∃τ ∈ R+ such that :
x' = x + τ

(step, noted
→e  )

⎪⎪⎩
∃e = (q, (g, λ), r, q') ∈ E such that :
(c, c') ∈ r and (x, x') |= (g, λ)

Using the previous definitions, the next proposition gives the relation between the different semantics :

Proposition 2.6 Let S = ⟨Q, X, C, E⟩ be a TCS. Then, we have :
∀e ∈ E, (q, x, c) →e (q', x', c') iff (q, x) →e T (q', x') and (q, c) →e C (q', c').
∀τ ∈ R+, (q, x, c) →τ  (q, x', c) iff (q, x) →τ T (q, x').

An example of TCS
Figure 1 depicts an example of Timed Counter System, with two control lo- cations q1, q2, two counters c1, c2, and two clocks x1, x2. We consider the initial configuration in q1 with c1 = c2 = x1 = x2 = 0. Notice that x2 does not appear on transitions, but only stands as a universal clock.
This TCS represents a service offered on most digital televisions : the feature modelled here deals with the movies that the client can rent directly at home. This model mainly gives the following information : the total number of movies the client has rented so far (c2), the number of movies having been rented during the current day (c1), how long the client has been using this service (x2), and how much time has elapsed since the first daily movie (x1). The typical property this model aims at representing is ”A client can rent a maximum of 5 movies in a 24-hour period”. One could also model fares, and by using c2 and x2, offer a free movie every 30 rentals after a one-month membership. Other statistics can easily be derived from this model, such as the average number of movies a client uses to rent per hour.

' := 1 ∧ c' := c2 +1 

' := 0

c1 < 6 ∧ c'

:= c1 +1 ∧ c'
x1 < 24

:= c2 +1 

x1 ≥ 24
Fig. 1. An example of TCS

Reachability
A typical interesting problem in the field of verification is the reachability problem, which can roughly be defined as follows : ”Given two configurations s, s' of a system, is there an execution of the system going from s to s' ?”. In our case, we refine this problem : instead of checking if a full configuration is reachable, we will check if a pair (q, c), where q is a control state and c a counter valuation, is reachable from an initial given configuration. We now formalize this notion.
Let S be a TCS and TS(S) = ⟨S, →⟩ its associated full semantics. We denote
by →∗  the reflexive and transitive closure of →. Similarly we define →∗ C for the
counting semantics. We then define the reachability sets of S as follows :

Reach(S, s0)= {s ∈ S | s0 →∗
s}, for any s0 ∈ S

ReachC(S, s0)= {s ∈ SC | s0 →∗ C s}, for any s0 ∈ SC

In this paper, we are interested in the Counter Reachability Problem, which we define as follows :

Counter Reachability Problem :
Inputs : A TCS S, an initial configuration s0 of TS(S), and a configuration (q, c) of CTS(S).
Question : Is there a clock valuation x such that (q, x, c) ∈ Reach(S, s0)? 
This problem considers only counter valuations, and not the clock valuations. We chose to look at this problem, instead of the reachability problem with a whole configuration, because we believe that the clocks are only used to introduce temporal requirements in the behavior of the system, and consequently, that there is no need to keep track of their exact values for verification matters.
Notice that this Counter Reachability Problem is an extension of the classical reachability problem in CS : the only difference is that we existentially quantify on a clock valuation so that the configuration matches a full TS configuration, and not just a CTS configuration. Therefore, we will equivalently speak of the Counter Reachability Problem for TCS and for CS (as usually defined, ie. without quantifying on clock valuations).
The Counter Reachability Problem is obviously undecidable for TCS, because it is already undecidable in CS. In order to be able to analyze CS, some restrictions leading to decidability (e.g. flat [12], reversal-bounded [19], VASS [20], ...) have been proposed. As we will show in section 5, some of these restrictions can be lifted up to the level of TCS. The main idea we will develop in this paper uses the fact that the undecidability of TCS is caused by the presence of counters. Therefore, we try to benefit from known decidability results on TA (detailed in section 4) and on some subclasses of CS (detailed in section 5).

Analysis of TCS via clock abstraction
A typical analysis of a TCS would be to compute the set of its reachable configu- rations, in order to address e.g. verification problems. Unfortunately, since a TCS handles variables whose domains are unbounded, its set of configurations might be infinite. A classical method to analyse such infinite-state systems consists in find- ing a finite abstraction, using for instance equivalence classes over configurations, and then ensuring that the reachability problem can be solved by reasoning on the abstracted system. The approach chosen in this paper uses this idea ; however, instead of reasoning on equivalence classes for the whole set of configurations, we only abstract clock valuations. In order to do so, we use a Region Graph, as usually done with TA.
There might be a possible dual approach : to abstract counters first, instead of clocks. The two main reasons why we chose not to use counter abstraction are
(1) because counters evolve discretely through formulas on transitions, and not constantly in a dense space when staying in a control location, and (2) because the

region graph has been studied for a long time and proved efficient in several tools.
Region Graph Construction
Let S be a TCS defined over a set of m clocks. Let Mi be the largest constant to which each clock xi is ever compared in guards, for all i ∈ [1, m]. As defined in [2], we consider an equivalence relation on clock valuations. Two clock valuations
x and x' in Rm are said region-equivalent (written x ≈ x') whenever all of the
three following conditions hold (where [y♩ (resp. ıyτ) denotes the integer (resp. fractional) part of any y ∈ R): 
[xi♩ = [x'♩ or xi, x' > Mi for all i ∈ [1, m].
i	i
ıxiτ =0 iff ıx' τ =0 for all i ∈ [1, m] such that xi ≤ Mi.
ıxiτ ≤ ıxjτ iff ıx' τ ≤ ıx' τ, for all i, j ∈ [1, m] such that xi, xj ≤ Mi.
i	j
This equivalence relation can be extended to states of TTS(S), saying that (q, x) ≈ (q', x') iff q = q' and x ≈ x'. We use [x] to denote the equivalence class to which x belongs. A region ρ is an equivalence class of clock valuations ; the set of all regions is denoted by R, and is finite. We equivalently write x ∈ ρ and [x] = ρ. A nice known property of the equivalence relation ≈ is that it is compatible with clock constraints (denoted by (cc)) and time elapsing (denoted by (te)) :
'	 (cc)	∀g ∈ GX , x |= g ⇐⇒ x' |= g
This second point (te) enables us to define a successor function on R. For a region ρ ∈ R, we denote by Succ(ρ) the set of its time-successors, defined as follows : ρ' ∈ Succ(ρ) ⇐⇒ ∃x ∈ ρ ∃τ ∈ R+ s.t. x + τ ∈ ρ'. Then, we are able to define the region graph of S :
Definition 4.1 Let S = ⟨Q, X, C, E⟩ be a TCS ; its region graph is the tuple
RG(S)= S/≈ = ⟨Γ, →RG⟩ such that :
Γ= Q ×R is the set of states ; we sometimes write qx to denote the state (q, [x])
→RG⊆ Γ × E × Γ is the transition relation such that ∀e = (q, (g, λ), r, q') ∈ E,
(q, ρ) →e RG (q', ρ') iff ∃ρ'' ∈ Succ(ρ) s.t. ∀x'' ∈ ρ'', x'' |= g and x' ∈ ρ' and
∀i ∈ [1, m], x' = λixi.
Such a region graph is the same as the classical region graph defined for TA ; its particularity is that its transitions are labelled by relations on counters, which have not been taken into account so far. The next step is, of course, to use them in order to get closer to the full semantics of a TCS.

The Region Graph as a Counter System
In this section, we first show that the region graph of a TCS can be analyzed as a CS. Then, we prove that the reachability problem can be lifted up to the level of the region graph. The Region Graph enjoys the following property [2] : 

Proposition 4.2 Let S = ⟨Q, X, C, E⟩ be a TCS, TTS(S)= ⟨ST , →T ⟩ its Timed Transition System, and RG(S)= ⟨Γ, →RG⟩ its Region Graph. Then for any (q, x) ∈ ST , we have for all e ∈ E :

If ∃τ ∈ R+
and ∃(q', x') s.t. (q, x) →τ T
(q, x + τ ) →e T
(q', x') then qx →e
RG q' '

If ∃q' '
s.t. qx
→e RG
q' '
then ∃τ ∈ R+
and ∃x'' ∈ [x'] s.t. (q, x) →τ T
(q, x +

τ ) →e T (q', x'')
Note that this property is about transitions, and can be naturally extended to sequences of such transitions : then, we obtain the well-known time-abstract bisimulation between TTS(S) and RG(S), denoted by . Informally, TTS(S) RG(S) means that both TTS(S) and RG(S) can follow the exact same sequences of transitions ; the only difference with a regular bisimulation is that RG(S) does not keep track of clock valuations, but only their equivalence class.
Now, notice that since the Region Graph has a finite number of states and its transitions are labeled by relations on counters, we can view it like a classical counter system. Indeed, we can see RG(S) as a TCS S' = ⟨Q',X',C', E'⟩, where Q' = Q × R, X' = ∅, C' = C and E' = E (with RX' = {∅}, since X' = ∅). Thus, we will alternatively say, w.l.o.g., that RG(S) is a RG, a TCS, or a CS.
We are now ready to prove that we can analyze the TCS through the counting semantics of its region graph, yielding a system which is an exact (w.r.t. Counter Reachability) abstraction of its full semantics. Indeed, from Propositions 2.6 and 4.2, we deduce the following property :
Proposition 4.3 Let S be a TCS. Then, we have :
If (q', x', c') ∈ Reach S, (q, x, c) , then (q' ' , c') ∈ ReachC RG(S), (qx, c) 
If (q' ' , c') ∈ ReachC RG(S), (qx, c) , then there exists x'' ∈ Rm such that
x	+
(q', x'', c') ∈ Reach S, (q, x, c)  and x'' ∈ [x'].
The picture on Figure 2 exhibits the different ways to interpret a TCS, and the relations existing between them. It also illustrates Proposition 4.3.

TCS : S






RG(S)
Timed Semantics

TTS(S)



Full Semantics


Counting Semantics

CTS(RG(S))	TS(S)

Fig. 2. The links between different semantics of TCS

Let C be a class of TCS such that there is an algorithm solving the Counter Reachability Problem for RG(S), for any S ∈ C. From Proposition 4.3 and the fact that there is a finite number of regions, we deduce our main theorem :
Theorem 4.4 The Counter Reachability Problem is decidable for C.
Proof. Let (q, x, c) be an initial configuration of TS(S) and (q, c) a configuration of CTS(S). Then, from Proposition 4.3, we deduce that there exists a clock valuation x' such that (q, x', c') ∈ Reach(S, (q, x, c)) if and only if there exists a region ρ such that ((q, ρ), c') ∈ ReachC (RG(S), (qx, c)) and x' ∈ ρ. Since a given TCS yields a finite number of regions, if we suppose that the Counter Reachability Problem is decidable for the counter system RG(S), then the Counter Reachability Problem is decidable for S.	 
In the next part, we will use this theorem to show that many restrictions which lead to decidability when studying Counter Systems can be lifted up to the level of TCS in order to obtain the decidability of the counter reachability problem.

Subclasses of TCS
We can now address the Counting Reachability Problem for TCS, by making hy- potheses on the class of CS to which the TCS’s region graph belongs. Therefore, we introduce four subclasses of TCS.

Timed Counter Machines and Timed VASS
We introduce here the class of Timed Counter Machines, in which we restrict opera- tions on counters. First, we give the definition of the relations over the counters val- uations we allow in the Timed Counter Machines, extending the Counter Machines of [19] (which are a slight extension of Minsky machines [24]). We call a guarded translation (shortly, a translation) any function t : Nn → Nn such that there exist # ∈ {=, ≤}n, μ ∈ Nn, and δ ∈ Zn with 0 ≤ μ + δ and dom(t) = {c ∈ Nn | μ#c} and for all c ∈ Nn, t(c)= c + δ. Intuitively, μ is the guard and δ is the translation length. We will sometimes use the encoding (#, μ, δ) to represent a translation.
Note that a translation can be seen as a relation over Zn × Zn. Indeed, for a trans- lation t : Nn → Nn and two counter valuations c and c', we have (c, c') ∈ t iff
c ∈ dom(t) and c' = t(c). Thus, using the original formalism of TCS, a translation

is a relation of the form 

i∈[1..n]
μi#ici ∧ c' = ci + δi.

Definition 5.1 A Timed Counter Machine (TCM for short) is a TCS S =
⟨Q, X, C, E⟩ such that for all (q, (g, λ), r, q') ∈ E, r is a translation.
Note that even when considering TCM, the Counter Reachability Problem re- mains undecidable. Hence, if we want to obtain decidability, a solution is to restrict the translations, and in particular to forbid equality tests. This restriction comes down to using a timed version of Vector Addition Systems with States (VASS) [20],

or equivalently, Petri Nets. We hence recall the definition of Timed VASS, which is a model introduced in [18] 2 :
Definition 5.2 A Timed VASS (TVASS for short) is a TCM S = ⟨Q, X, C, E⟩ such that for all (q, (g, λ), r, q') ∈ E, r is a translation (#, μ, δ) such that # = (≤,... , ≤).

Properties of a TCS and its Region Graph
Different restrictions can be done on Counter Machines to obtain decidability for the Counter Reachability Problem. First, remark that the restrictions we just in- troduced are obviously still true when considering the related region graph :
Proposition 5.3 Let S be a TCS. If S is a TCM (resp. a TVASS), then the counter system RG(S) is a counter machine (resp. a VASS).
Since the counter reachability problem is decidable when considering VASS [21,22], from Theorem 4.4, we deduce that :
Theorem 5.4 The Counter Reachability Problem is decidable for TVASS.
The two definitions 5.1 and 5.2 are syntactical restrictions ; nonetheless, it is possible to restrict the behaviour of a TCS. We say that a pair (S, s0) is an intialized TCS (resp. intialized CS ), in which S is a TCS (resp. CS) and s0 is an initial configuration of TS(S) (resp. CTS(S)). Among the possible restrictions on its behaviour, we can consider bounded initialized TCS (resp. CS), for which there is a bound under which all the counter values stay, in all the possible executions. Then, from Theorem 4.4, we deduce that :
Proposition 5.5 If an initialized TCS (S, s0) is bounded, then the intialized

counter system (RG(S), s' ) is bounded, with s0 = (q, x, c) and s'
= (qx, c).

0	0
The Counter Reachability Problem is obviously decidable for bounded initialized CS, since there is a finite number of reachable configurations ; thus, we deduce that :
Theorem 5.6 The Counter Reachability Problem is decidable for bounded intialized TCS.
Finally, we consider another restriction on the behaviour, but this time, only for TCM. In [19], the class of reversal-bounded counter machines has been introduced, and has been extended in [17]. This extension mentions that an intialized Counter Machine (S, s0) is k-reversal-b-bounded for k, b ∈ N, if in all the executions of S starting from s0, each counter valuation alternates at most k times between non- increasing and non-decreasing modes over a bound b. We naturally extend this notion to TCM ; remark that an initialized TCM is reversal-bounded if it is k- reversal-b-bounded for some k, b ∈ N. Then, thanks to Proposition 4.3, we deduce that :

2 Actually, the emptiness problem of the language of a TVASS has been proved decidable in [18] and [8]

Proposition 5.7 If an initialized TCM (S, s0) is reversal-bounded, then the ini- tialized counter machine (RG(S), s' ) is reversal-bounded, with s0 = (q, x, c) and
' = (qx, c).
Since the Counter Reachability Problem is decidable for reversal-bounded
counter machines [17], we have :
Theorem 5.8 The Counter Reachability Problem is decidable for reversal-bounded initialized TCM.
The following table summarizes the decidability results we obtained here :

Notice that TVASS is a recursive class, which is very interesting for implementa- tion perspectives : hence, we propose an algorithm solving the Counter Reachability Problem for this class. However, it is impossible to decide if a system is reversal- bounded or bounded, in the general case.

Algorithm 1 : Solves the Counter Reachability Problem for TVASS. Input : a TVASS S, a configuration (q, c), and an initial state s0 Output : the answer to ”Is there a x such that (q, x, c) ∈ Reach(S, s0) ?”
build RG(S)= ⟨Γ, →RG⟩

for all q'
∈ Γ do

if q' = q then
if (qx, c) ∈ ReachC(RG(S), s0) then
return True
end if end if
end for
return False

Conclusion and Future work
We introduced a new model for systems mixing clocks and counters, and proved the Counter Reachability Problem to be decidable for three of its subclasses. Other subclasses might be interesting to study in order to broaden these results, such as flat TCS, following the approaches of [12] or [7]. Our ultimate goal is to extend the tool for counter systems Fast [5,6] so that it also handles clocks. Moreover, our main result, as stated in Theorem 4.4, can be extended to other dataypes than counters (e.g. pushdown stacks, lossy channels, etc...).

References
Alur, R., C. Courcoubetis, T. A. Henzinger and P.-H. Ho, Hybrid automata: An algorithmic approach to the specification and verification of hybrid systems, LNCS 736, 1992, pp. 209–229.
Alur, R. and D. L. Dill, A theory of timed automata, Theor. Comput. Sci. 126 (1994), pp. 183–235.
Annichini, A., E. Asarin and A. Bouajjani, Symbolic techniques for parametric reasoning about counter and clock systems, in: CAV, LNCS 1855 (2000), pp. 419–434.
Annichini, A., A. Bouajjani and M. Sighireanu, TReX: A tool for reachability analysis of complex systems, in: CAV, LNCS 2102 (2001), pp. 368–372.
Bardin, S., A. Finkel, J. Leroux and L. Petrucci, FAST: Fast Acceleration of Symbolic Transition systems., in: CAV, LNCS 2725 (2003), pp. 118–121.
Bardin, S., A. Finkel, J. Leroux and L. Petrucci, FAST: Acceleration from theory to practice, International Journal on Software Tools for Technology Transfer (STTT) (2008), to appear.
Bardin, S., A. Finkel, J. Leroux and P. Schnoebelen, Flat acceleration in symbolic model checking, in:
ATVA, LNCS 3707, 2005, pp. 474–488.
B´erard, B., Untiming timed languages, Inf. Process. Lett. 55 (1995), pp. 129–135.
B´erard, B., V. Diekert, P. Gastin and A. Petit, Characterization of the expressive power of silent transitions in timed automata, Fundamenta Informaticae 36 (1998), pp. 145–182.
Bolognesi, T., F. Lucidi and S. Trigila, From timed petri nets to timed lotos, in: PSTV (1990), pp. 395–408.
Comon, H. and Y. Jurski, Multiple counters automata, safety analysis and presburger arithmetic, in:
CAV, LNCS 1427, 1998, pp. 268–279.
Comon, H. and Y. Jurski, Timed automata and the theory of real numbers, in: CONCUR, LNCS 1664, 1999, pp. 242–257.
Dang, Z., O. H. Ibarra, T. Bultan, R. A. Kemmerer and J. Su, Binary reachability analysis of discrete pushdown timed automata, in: CAV, LNCS 1855, 2000, pp. 69–84.
Dang, Z., O. H. Ibarra, P. S. Pietro and G. Xie, Real-counter automata and their decision problems, in: FSTTCS, LNCS 3328, 2004, pp. 198–210.
Darlot, C., A. Finkel and L. van Begin, About FAST and TReX accelerations., Electronic Notes in Theoretical Computer Science 128 (2005), pp. 87–103.
Finkel, A. and J. Leroux, How to compose presburger-accelerations: Applications to broadcast protocols, in: FSTTCS, LNCS 2556 (2002), pp. 145–156.
Finkel, A. and A. Sangnier, Reversal-bounded counter machines revisited, in: MFCS, LNCS (2008), to appear.
Gorrieri, R. and G. Siliprandi, Real-time system verification using P/T nets, in: CAV, LNCS 818
(1994), pp. 14–26.
Ibarra, O. H., Reversal-bounded multicounter machines and their decision problems, J. ACM 25 (1978),
pp. 116–133.
Karp, R. M. and R. E. Miller, Parallel program schemata, J. Comput. Syst. Sci. 3 (1969), pp. 147–195.
Kosaraju, S. R., Decidability of reachability in vector addition systems (preliminary version), in: STOC
(1982), pp. 267–281.
Mayr, E. W., An algorithm for the general Petri net reachability problem, SIAM Journal on Computing
13 (1984), pp. 441–460.
Merlin, P., “A study of the recoverability of computing systems,” Ph.D. thesis, University of California, Irvine (1974).
Minsky, M., “Computation: finite and infinite machines,” Prentice-Hall, Inc., NJ, USA, 1967.
Xie, G., Z. Dang, O. H. Ibarra and P. S. Pietro, Dense counter machines and verification problems, in:
CAV, LNCS 2725, 2003, pp. 93–105.
