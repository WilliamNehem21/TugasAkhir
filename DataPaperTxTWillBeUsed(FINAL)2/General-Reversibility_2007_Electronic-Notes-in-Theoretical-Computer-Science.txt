Electronic Notes in Theoretical Computer Science 175 (2007) 75–86	
www.elsevier.com/locate/entcs
General Reversibility
Vincent Danos
CNRS & Universit´e Paris 7 

Jean Krivine
INRIA Rocquencourt & Universit´e Paris 6 

Pawe-l Sobocin´ski1
Computer Laboratory, University of Cambridge

Abstract
The first and the second author introduced reversible CCS (RCCS) in order to model concurrent computa- tions where certain actions are allowed to be reversed. Here we show that the core of the construction can be analysed at an abstract level, yielding a theorem of pure category theory which underlies the previous results. This opens the way to several new examples; in particular we demonstrate an application to Petri nets.
Keywords: Reversible computation, CCS, reversible calculus of communicating systems (RCCS), Petri net


Introduction
The reversible calculus of communicating systems (rccs) [1] is essentially Milner’s ccs [9] with the caveat that some observable actions in the standard labelled tran- sition system (lts) semantics are understood to be reversible. Technically, the the- oretical development involved the engineering of explicit syntax for keeping track of a computation history. Such a history, together with a ccs term, forms the configuration of a given process. Appropriate new structural operational seman- tics (sos) rules allowed the reversible components of a given state’s history to be undone. Phillips and Ulidowski [10] proposed a different approach to keeping the record of a computation’s history; instead of keeping an explicit representation of

1 Research partially supported by epsrc grant EP/D066565/1.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.07.036

history together with an unevaluated term, they keep the structure of terms essen- tially unaltered by making the sos rules static. Causality is kept track of by tagging actions with so-called communication keys.
In [2], it was argued that a calculus such as rccs (or ccsk of [10]) is suited for modelling transactions – ie computations where several agents interact in order to agree on a common irreversible action; see [3] for example. Indeed, it seems that guaranteeing the soundness of such transactions is easy enough since policies are normally specified by requiring the local states of the participants to satisfy certain criteria. On the other hand, completeness seems to be more difficult, since the existence of a possible computation leading to all of the agents having the required state does not guarantee that such a state will be reached – for instance, the agents may deadlock while racing to obtain the necessary shared resources. If we stipulate that the actions leading to transactions are reversible and enrich the participants with histories, meaning that the intermediate actions can be undone, the irreversible computations are “essentially” the transactions. More concretely, it was shown in [2] that the lts where the labels are taken to be the transactions and the lts of processes with histories and reversible actions, where the reversible actions are equated with τ s, are weakly bisimilar.
In this paper we show that the design of a calculus such as rccs involves an underlying abstract construction of the history category from a category of computa- tions. The fact that the computations agree essentially with the causal (irreversible) computations in the original category is captured by an equivalence of categories.
The main contributions of this paper are:
the observation that subcategories R of reversible and I of causal computa- tions form a factorisation system ⟨I, R⟩ on the category of computations C (cf §3);
given a factorisation system ⟨I, R⟩ on C, an explicit construction of the “cat- egory of histories” h٨(C, R) (cf Definition 4.3);
a proof that h٨(C, R) essentially follows from a free construction; concretely we prove that h٨(C, R) is equivalent to a certain category of fractions (cf Theorem 4.5);
an equivalence of categories h٨(C, R)  I (cf Theorem 4.4) – this is the main result of the paper and guarantees that in order to capture the causal computations it is enough to keep the reversible parts of a computation along as part of the state and allow these histories to be undone;
a direct application of Theorem 4.4 to the categories of computations induced by Petri nets;
an explanation of how Theorem 4.4 relates to the previous work [2] concerning rccs. In particular, a weak bisimulation that relates the lts of transactions to the lts of reversible histories where the reversible actions are treated as internal (cf Theorem 5.3).

Structure of the paper
In §2 we recall the basic concepts of categories of fractions and factorisation systems. In §3 we introduce several examples, including Petri nets, and show that the sets of causal and reversible computations form factorisation systems. The construction of the history category together with our main Theorem 4.4 is given in
§4. Finally, in §5 we explore the connections with labelled transition systems. The paper assumes a basic acquaintance with the categorical notions of adjunctions and symmetric monoidal (sm) categories.

Categories of fractions and factorisation systems
Categories of fractions
Given a category C and an arbitrary class of morphisms Σ, we denote by C[Σ—1] the category of fractions obtained by “freely” adding formal inverses to the arrows of Σ (see, for instance [5]).
The category of fractions is characterised by a universal

property: the existence of a functor Φ: C → C[Σ—1] which
sends each arrow in Σ to an isomorphism, and moreover,
C  Φ 
¸¸
¸
 C [Σ—1]

given a category D and a functor F : C → D which takes each arrow in Σ to an isomorphism, the existence of a unique
functor F' : C[Σ—1] → D such that F'Φ = F .

Factorisation systems
Given a category C and two arrows f, g ∈ C we shall write f ⊥ g if f and g satisfy the following property: given a commutative diagram with p, q arbitrary morphisms of C there exists a unique morphism h : C → B such that gh = q and hf = p, as illustrated. Notice that ⊥ is not symmetric. Given an arbitrary set X of arrows of C there are two closure operations which use ⊥:
F ¸¸¸	F '
¸zJ 
D




A   p	 B f	h		g
J	J 
C	q	D

X⊥ = { y in C | ∀x ∈ X.x ⊥ y } and XT = { y in C | ∀x ∈ X.y ⊥ x}.

If we let Iso(C) (Ar(C)) be the class of all isomorphisms (morphisms) of C then it’s immediate that Iso(C)⊥ = Ar(C) = Iso(C)T.
The following are standard properties enjoyed by the closure operations:
Proposition 2.1
X⊥T⊥ = X⊥;
XT⊥T = XT;
X ⊆ X' ⇒ X '⊥ ⊆ X⊥
X ⊆ X' ⇒ X 'T ⊆ XT.
Following [4], we define a prefactorisation system as follows:

Definition 2.2 [Prefactorisation system] A prefactorisation system for a category
C consists of two classes I, R of arrows of C such that I⊥ = R and RT = I.
By the first two parts of Proposition 2.1 it is immediate that for any class of arrows X of C, XT, X T⊥ and X ⊥T, X⊥ are prefactorisation systems.
The following are some of the well-known properties of prefactorisation sys- tems [4]:
Proposition 2.3 Suppose that ⟨I, R⟩ is a prefactorisation system on C. Then:
Iso(C) ⊆ I, Iso(C) ⊆R and I∩ R = Iso(C);
I and R are closed under composition.
The conclusion of Proposition 2.3 implies that I and R are actually subcategories of C since they contain the identities and are closed under composition. We shall take advantage of this by often confusing I and R with the subcategories they form the arrows of.
Definition 2.4 [Factorisation system] A prefactorisation system ⟨I, R⟩ on C is a factorisation system if every arrow p in C can be written p = g ◦ f for some f in I and g in R.
Example 2.5 Clearly ⟨C, Iso(C)⟩ and ⟨Iso(C), C⟩ are factorisation systems in any category. Probably the most well-known factorisation system is of course ⟨E, M⟩ in the category of sets Set, where E is the class of surjections and M is the class of injections.
The following is a well-known property of factorisation systems:
Lemma 2.6 ⟨I, R⟩-factorisation is unique up to isomorphism: if p : A → B in C can be factorised p = g1f1 and also p = g2f2 where fi : A → Ci is in I and gi : Ci → B is in R for i = 1, 2, then there exists a unique isomorphism h : C1 → C2 such that hf1 = f2 and g2h = g1
Reversibility
Following the theoretical exposition, we give a number of motivating examples of factorisation systems. We shall consider categories of computations which decom- pose into an underlying set of atomic actions, some of which are a priori specified as reversible. Given a computation which consists of both types of actions, it should be possible to break it up into a causal (non-reversible) component followed by a maximal reversible component. If we denote the causal computations by I and the reversible computations by R, it turns out that ⟨I, R⟩ usually forms a factorisation system on the category of computations.
Example 3.1 [Single-threaded reversibility] Consider an alphabet Σ = I + R for some sets I and R; we think of I as a set of irreversible atomic actions and R as a set of reversible atomic actions. Let Σ∗ denote the free monoid over Σ considered as a one-object category.

Let R = R∗ and let I = RT = Σ∗I + ϵ – the set of all strings which end with an irreversible action, together with the empty string. Then ⟨I, R⟩ is a factorisation system on Σ∗.
Example 3.2 [Multi-threaded reversibility] Let C be the free sm category on a graph G – ie one first forms the free category on G and then the free sm category on the resulting category. We think of the vertices of G as representing the states of a particular thread of computation, and the edges as possible actions. Then, following this intuition, the arrows of C represent multithreaded computations of finitely many non-communicating processes, with the tensor product ⊗ representing parallel composition.
Suppose that the edges of G are partitioned into two sets, I and R. Let GR denote the graph with the same nodes as G but with the edges restricted to the members of R.
Let R be the free sm category on GR. Clearly R is a subcategory of C in a canonical way. Let I = RT. It is easy to verify that I is the smallest subcategory of C which contains the isomorphisms of C, arrows of the form iα with i ∈ I and whose arrows are closed under ⊗. Then ⟨I, R⟩ is a factorisation system on C.
It is instructive to consider a more substantial example in order to illustrate the theory. Here we shall consider Petri nets as sm categories in the tradition of [8]. Note, however, that we do not deal with strict symmetric monoidal categories. We shall first need to recall the notion of a tensor scheme [6] and the associated notion of a free sm category on a tensor scheme; indeed, as we shall see, tensor schemes are very closely related to Petri nets. Note that tensor schemes can also be used in order to construct ordinary (ie non-symmetric) free monoidal categories.
Definition 3.3 [Tensor scheme]A tensor scheme S consists of a set V of vertices, a set E of edges, and functions s, t : E → V ∗, where V ∗ is the free monoid (the set of finite words) on V . Every tensor scheme leads to a free sm category C – see [6] for details. Intuitively, the objects of C can be seen as finite words (ie the product in V ∗ is interpreted as ⊗ in C) in V and the arrows of C are generated freely from the basic edges in E. Concretely, the arrows can be seen as certain equivalence classes or as certain string diagrams; see [11]. Notice that the procedure described in Example 3.2 can be seen as a special case of a tensor scheme (where all the edges have one letter words as sources and targets).
Definition 3.4 [Petri net] A Petri net N with a set of states S and set of transitions T is a graph s, t : T → S⊕ where S⊕ is the free commutative monoid on S. A Petri category CN is the free sm category on N , considered as a tensor scheme. 2
The Petri category CN can be thought of as the category with arrows the (truly) concurrent computations of a net N .
Example 3.5 [Petri net reversibility] Suppose that the set T of transitions N can be partitioned T = I + R, where the set I contains the transitions which are deemed

2 One fixes a particular ordering of places for the source and the target of each transition, the order is immaterial.



Fig. 1. A simple Petri net, the filled transitions are irreversible.


irreversible and R the transitions deemed reversible. We obtain a factorisation system ⟨I, R⟩ as in our previous examples.
Let R be the free sm category on NR, the Petri net with the same places as N and with R as its set of transitions, considered as a tensor scheme; it is clearly a subcategory of CN in a canonical way. Let I = RT – the arrows of I can be described roughly as in Example 3.2. The pair ⟨I, R⟩ forms a factorisation system on CN .

Consider the concrete example of a net illustrated in Figure 1, where precisely the unfilled transitions (g1 and g2) are taken to be reversible. Suppose that places x1 and x2 initially contain one token each; intuitively, we can consider places x1 and x2 as agents which each have an option of committing to two transactions: x1 can commit to either f1 or f2 while x2 can commit to f2 or f3. In terms of CN this amounts to the fact that there are arrows f1 : x1 → z1, f3 : x2 → z3 and f2.g1 ⊗ g2 : x1 ⊗ x2 → z2. Notice that if x1 chooses to perform g1 and x2 commits to f3 then the computation begun by x1 is stuck unless the g1 transition can be reversed and f1 chosen instead.
Consider the effect of adding new transitions g1٨ and g2٨ to act as the inverses of g1 and g2 respectively. If we deem that reversed computations are the same as doing nothing then the resulting Petri category is just CN [R—1]. However, this setting is clearly unsuitable to model the expected behaviour of the net: consider starting with a single token in x2 and performing the g2 transition. Since now g1٨ is enabled, we can perform g1٨ and then f1, thus arriving at a behaviour which is not in the specification – x2 being able to commit to action f1.


Histories
A key technical feature of rccs is that histories are kept as part of the state, which allows reversible moves to be backtracked correctly. Here we repeat the construction at a higher level of abstraction, assuming only the presence of a factorisation system.

Definition 4.1 [Category h(C, R) of histories] Suppose that ⟨I, R⟩ is a factorisa- tion system on C. Let h(C, R) be the category with:



objects: arrows g in R;
arrows: commutative diagrams, as illustrated, where f
is in C and f' ∈ I.
P	f ' P 
g1	g2
J	J 
Q1 f Q 2


Notice that given an object g1 : P1 → Q1 in h(C, R) and an arbitrary arrow f : Q1 → Q2, there exists a unique up-to-isomorphism object g2 of h(C, R) and arrow f' : P1 → P2 in I such that ⟨f, f'⟩ : g1 → g2 is in h(C, R) – here g2 ◦ f' is just the ⟨I, R⟩-factorisation of f ◦ g1. Notice that if f ∈ R, then using the fact that arrows of R compose and uniqueness of factorisation (Lemma 2.6), we have that f' ∈ Iso(C).
Recall from Proposition 2.3 that we can consider I to be a cat-

egory. There is an obvious functor M : h(C, R) → I which takes an object g1 : P1 → Q1 to P1 and the diagram above to the arrow f' : P1 → P2. Returning to our intuitions, this functor takes a com-
putation to its causal (non-reversible) component. Using the final remark of the previous paragraph, M sends arrows which have a lower component in R to isomorphisms.
P  f  P 
J  J 
P1 f P2 

There is also a (full and faithful) functor N : I → h(C, R), which takes an object P1 ∈ I to the identity on P1 (null history) and a morphism f : P1 → P2 to the illustrated diagram.
Proposition 4.2 N is left adjoint to M.


Proof. Given g1 : P1 → Q1 ∈ h(C, R), consider the illustrated mor- phism ϵg1 = ⟨g1, id⟩ : NM (g1) → g1. It is easy to verify that ϵ defines a natural transformation NM ⇒ idh(C,R) – it is the counit


P1 	 P1 
g1

of the adjunction. The unit is trivial as MN = idI, and the triangle identities are easily checked.	 
Recall that our intuition is that the objects of h(C, R) represent
J	J 
P1 g1 Q 1

(reversible) histories. We shall now extend h(C, R) with “reversed” computations with the effect that such histories can be undone.
Definition 4.3 [Category h٨(C, R) of reversible histories ] Suppose that ⟨I, R⟩ is a factorisation system. Let Φ: C → C[R—1] be the canonical functor to the category of fractions. Let h٨(C, R) denote the category with:


objects: arrows g in R;
P	f  P 

arrows: formal diagrams, as illustrated, with f ∈ I,
f٨ ∈ C[R—1], such that f٨Φ(g1) = Φ(g2f ) in C[R—1].
g1
J 
Q1 fs
g2
J 
Q 2


There is an evident functor Ψ: h(C, R) → h٨(C, R) which maps the lower com-

	Ψ	
˛ 

h(C, R)
,¸	M
E
h٨(C, R)
s
~

t z 
N	I ¸, Ms

Fig. 2. Histories and causal computations.
ponent of a history morphism from C to C[R—1] via Φ:


P	f ' P 
g1	g2

'−→
P	f ' P 
g1	g2

J	J	J	J 
Q1 f Q 2	Q1 Φf Q 2
Let M٨ : h٨(C, R) →I be the functor which takes an arrow of h٨(C, R) to its upper component. Clearly M٨Ψ = M .
Theorem 4.4 M٨ is an equivalence of categories.
Proof. Let N٨ = ΨN : I → h٨(C, R) (see Fig 2) – clearly M٨N٨ = idI, we shall show that there exists a natural isomorphism N٨M٨ ⇒ idhs(C,R).
Indeed, since Ψ is the identity on objects, we have N٨M٨g =

ΨNM Ψg = NMg, and thus it suffices to show that Φϵ is a natu- ral isomorphism, where ϵ is the counit of the adjunction N E M . We illustrate Ψϵg, clearly it is an invertible morphism of h٨(C, R). Naturality is straightforward.
P 	 P 
g
J 
P Φg Q 


Recall from Example 2.5 that ⟨C, Iso(C)⟩ and ⟨Iso(C), C⟩ are trivial factorisa- tion systems in any category C. The conclusion of Theorem 4.4 implies immediately that h∗(C, Iso(C))  C and h∗(C, C)  Iso(C).
We shall now show that h٨(C, R) essentially follows from a free construction. Let R' = { ⟨g, ϕ⟩∈ Ar(h(C, R)) | g ∈ R}, the set of those arrows of h(C, R) where the lower component is in R (cf paragraph following Definition 4.1).
Theorem 4.5 There is an equivalence of categories h٨(C, R)  h(C, R)[R'—1].
Proof. Let X = h(C, R)[R'—1]. Since we know that h٨(C, R) I, it is enough to show that also X I. Let Φ' : h(C, R) → X be the canonical quotienting functor. Since M : h(C, R) → I sends every member of R' to an isomorphism, we have a unique functor M' : X → I such that M'Φ' = M . Let N' = Φ'N : I → X. Then M'N' = M'Φ'N = MN = idI.
Let ϵ : NM → idh(C,R) be the counit of the adjunction N E M . Clearly Φ' sends each component of ϵ to an isomorphism in X. Since Φ' is the identity on objects, we have that for each object g ∈ X, Φ'ϵg : N'M'g → g is an isomorphism. It remains to check that Φ'ϵ defines a natural transformation N'M' → idX. To do this we need to check that the commutativity of an arbitrary square, as illustrated, where h is in X.

It is well-known that arrows in X are equivalence classes of zig-zags in h(C, R) where each of the reverse arrows is in R'. Using the functoriality of N'M' and the fact that ϵ is a natural transformation, we can “fill in” the diagram below at each point, and since h = (Φ'γn)—1Φ'αn ... (Φ'γ1)—1Φ'α1, naturality easily follows by a straightforward diagram chase.


'  ' Φ'NMα1 '  '
Φ'N,Mγ1
Φ'NM α2	...	Φ'NMαn   '
' Φ'N,Mγn '  ' '

N M g
Φ'єg
N M g1 ¸
Φ'єg
N M s1
Φ'єs
M N gn ¸
Φ'єgn
N M g
Φ'єg'

1	1
J	 J	J
J	J 

g
Φ'α1
 g1 ¸ ,	s1
Φ'γ1

Φ'α2
	... 

Φ'αn
 gn ¸,	g'
Φ γn



Considering Examples 3.1, 3.2 and 3.5, The- orem 4.4 states that to understand the struc- ture of causal computations it is enough to re-


N'M'g  N 'M 'h N 'M'g'

member the maximal reversible component of a
Φ'єg
Φ'єg'

J	 J'

given computation and allow these histories to be backtracked.
Returning to the discussion concerning the
g	 
h

net of Figure 1, the missing ingredient was clearly the explicit keeping track of the history of the current computation – ie instead of working in CN [R—1] we work in the history category h٨(CN , R).  (cf Definition 4.3).  Our main result,
Theorem 4.4, establishes that the categories h٨(CN , R) and I are equivalent, which confirms that the computations of nets with histories are essentially the same as the causal computations of the original net. Of course, the main result is clearly more general than this particular example, for instance it underlies the previous work on
rccs [1, 2].
Indeed, it is interesting to compare the concrete implementation of a reversible process algebra, like rccs, with the abstract construction we present in this paper. Roughly, the definition of rccs in [1] can be summed up as the development of a correct syntactic presentation of the category of reversible histories h٨(C, R), where C is the category of computations of ccs.
Free categories as transition systems
The categories of Examples 3.2 and 3.5 can be thought of as a transition systems as well as categories; indeed, since the categories are generated freely, their arrows can be seen as (equivalence classes of) traces in the transition systems. Here we shall elucidate the consequences of our main Theorem 4.4 for the underlying transition systems, obtaining a direct generalisation of the main result of [2]. Notice however that the results of §4 are more general, since the underlying categories are not assumed to be free; indeed, the only assumption is the presence of a factorisation system.
Let S = ⟨V, E⟩ be a tensor scheme with edges E partitioned into sets of irre- versible actions I and reversible actions R. Let C be a freely generated sm category

over S. Let R be the subcategory of C generated by SR = ⟨V, R⟩. Let I = RT. Then ⟨I, R⟩ is a factorisation system. 3
Definition 5.1 Let TS(C) be defined as follows:
states are isomorphism classes of objects of C;
transitions are labelled with elements of E and arise as follows


P1 ⊗ P
⊗
2 −−−→
P' ⊗ P2
in C,	α ∈ E



[P1 ⊗ P2] α ► [P ' ⊗ P2]
Using the fact that C is freely generated, any non-invertible arrow of C generates a finite set of traces in TS(C). We shall refer to each possible trace of an arbitrary morphism f in C as a serialisation of f .
A trace σ is said to be causal if it is a serialisation of an arrow f in I. A trace σ is an i-transaction if it is causal and contains precisely one action i ∈ I (and arbitrarily many actions from R). Let CTS(C) be the lts with the same states as TS(C), but with transitions
[P ] σ ► [P '] in TS(C),	σ an i-transaction [P ] i ► [P '] in CTS(C)
Thus CTS(C) is the lts of transactions. Correspondingly, we shall now define the history lts, where states are enriched with a history, and the transitions are those of TS(C) as well as new transitions which allow backtracking.
Definition 5.2 Let RTS(C) be defined as follows:
states: isomorphism classes of objects h(C, R) (structural isomorphisms);
transitions labelled with elements of E ∪ R∗ where R٨ = { r٨ | r ∈ R }. They are derived from morphisms in h٨(C, R), as illustrated below:


P	f	 P 
g1	g2
P1
,	α ∈ E	g1
f	 P 
g2

,	r ∈ R

Q	J  α⊗Q2   '  J 
J  r—1⊗Q2  '  J 

1 ⊗ Q2
Q1 ⊗ Q2
Q1 ⊗ Q2
Q1 ⊗ Q2

⎡	P1	⎤	⎡	P2	⎤
g1	α ►	g2
Q1 ⊗ Q2	Q'
⎡	P1	⎤	⎡	P2	⎤
g1	rs ►	g2
Q1 ⊗ Q2	Q'

1 ⊗ Q2	1 ⊗ Q2
It is clear from the construction of h٨(C, R) that any morphism in h٨(C, R) induces a set of serialisations (traces) in RTS(C).
Theorem 5.3 Consider a free sm category C generated from a tensor scheme S =
⟨V, E⟩ with E = I + R, together with an induced factorisation system ⟨I, R⟩ where

3 We leave it as future work to determine sufficient conditions on a subcategory which ensure that Y =
YT⊥.

R is the subcategory of C freely generated by SR = ⟨V, R⟩. Let CTS(C) be the lts of transactions (cf Deﬁnition 5.1) and RTS(C) be the reversible lts (cf Deﬁnition 5.2) where the reversible actions are considered to be silent. Then CTS(C) ≈ RTS(C).
Proof. We shall show that the (object part of the) functor M٨ : h٨(C, R) → I is actually a functional weak bisimulation.

Recall that M (P	g  Q) = P . Clearly M
is well-defined as

٨	−→	٨

a function from states of RTS(C) to states of CTS(C). Suppose that there is a transition
P 	f	 P '


g	 α 
'  g'	'
g	g'
J	J 

[P −→ Q]
[P
−→ Q ].
Q	α⊗X
 Q '

Then either α ∈ R, in which case the transition is silent – we have P' ∼= P so we can counter with the empty trace.
If α ∈/ R then we have the first diagram where f is in I. Since

P 	 P fi  P '
g J	(†) J 

Q	 J   '

we are in a free category, any serialisation of f must contain α as a unique action from I. Thus f leads to a trace in TS(C) which
g∗ P fi P

is an α-transaction – ie we have a labelled transition [P ] α ► [P '] in CTS(C).

Now consider an arbitrary transition [P ]  i ► [P ']. Let P	fi
P' be the cor-

responding arrow in I. Then in particular we have the square (†) in h∗(C, R), as illustrated in the second diagram. Let g∗ be the inverse to g in C[R—1]. Clearly i is the only irreversible action in any serialisation (in RTS(C)) of the combined second

diagram, so we have a weak transition [p  g
q]	► ∗ i ► [p' → p'].	 

Conclusion
The main contribution of this paper is the development of the underlying abstract concepts which become apparent when designing “reversed” versions of known for- malisms, such as Petri nets or ccs. In particular, we show that the problem reduces to developing the particular syntactic representations (such as the concrete syntac- tic representation of histories in rccs) of the reversible history category h∗(C, R). The fact that the resulting computations capture the intended causal behaviour can then be seen as a consequence of our Theorem 4.4, which is formalism independent. We hope that this conceptual clarification will be of use to designers of reversible formalisms.
Another contribution is the observation that breaking up a computation into irreversible-reversible components naturally leads to a factorisation system on the category of computations. As part of future work, we plan to study such factori- sation systems in more detail. We also plan to explore connections with previous work on factorisation systems in rewriting theory [7].

References
V. Danos and J. Krivine. Reversible communicating systems. In Proceedings of Concur’04, volume 3170 of LNCS, pages 292–307. Springer, 2004.


V. Danos and J. Krivine. Transactions in RCCS. In Proceedings of Concur’05, volume 3653 of LNCS, pages 398–412. Springer, 2005.
V. Danos, J. Krivine, and F. Tarissan. Self-assembling trees. In SOS’06, ENTCS. Elsevier, July 2006. To appear.
P. J. Freyd and G. M. Kelly. Categories of continuous functors, i. Journal of Pure and Applied Algebra, 2:169–191, 1972.
P. Gabriel and M. Zisman. Calculus of fractions and homotopy theory. Springer-Verlag, 1967.
A. Joyal and R. Street. The geometry of tensor calculus, i. Advances in Mathematics, 88:55–112, 1991.
P.-A. Melli`es. A factorisation theorem in rewriting theory. In Proceedings of CTCS ’97, volume 1290 of LNCS, pages 49–68. Springer, 1997.
J. Meseguer and U. Montanari. Petri nets are monoids. Information and computation, 88:105–155, 1990.
R. Milner. A Calculus of Communicating Systems, volume 92 of LNCS. Springer, 1980.
I. Phillips and I. Ulidowski. Reversing algebraic process calculi. In Proceedings of FoSSaCS ’06, volume 3921 of LNCS, pages 246–260. Springer, 2006.
R. Street. Higher categories, strings, cubes and simplex equations. Applied Categorical Structures, 3:29–77, 1995.
