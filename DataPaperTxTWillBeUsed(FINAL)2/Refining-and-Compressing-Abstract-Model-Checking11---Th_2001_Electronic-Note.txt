Electronic Notes in Theoretical Computer Science 48 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume48.html pp. 1 – 18



Refining and Compressing Abstract Model Checking 1

Agostino Dovier 2 Roberto Giacobazzi 3
Dipartimento di Informatica Universit`a di Verona Strada Le Grazie 15 37134 Verona (Italy)

Elisa Quintarelli 4
Dipartimento di Elettronica e Informazione Politecnico di Milano
Piazza Leonardo da Vinci 32 20133 Milano (Italy)


Abstract
For verifying systems involving a wide number or even an infinite number of states, standard model checking needs approximating techniques to be tractable. Abstract interpretation offers an appropriate framework to approximate models of reactive systems in order to obtain simpler models, where properties of interest can be effectively checked. In this work we study the impact of domain refinements in abstract interpretation based model checking. We consider the universal fragment of the branching time temporal logic CTL* and we characterize the structure of temporal formulae that are verified in new abstract models obtained by refining an abstract domain by means of reduced product and disjunctive completion, or by simplifying the domain by their inverse operations of complementation and least disjunctive bases.


Introduction
Model checking has emerged as a successful approach for automated verifi- cation of complex reactive systems where properties are typically expressed

1 The work is partially supported by MURST project: Certificazione automatica di pro- grammi mediante interpretazione astratta.
2 Email:dovier@sci.univr.it
3 Email:giaco@sci.univr.it
4 Email:quintare@elet.polimi.it
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


using temporal logic [11,18] (for instance, to establish the validity of security properties of protocols). However, it is well known that verifying a temporal logic formula against a model, in particular finding all the system states that verify the formula, is in general a hard problem. Recall that in the case of fi- nite states this problem is decidable both for CTL* and for the simpler case of CTL. The complexity of this problem is PSPACE complete for CTL* [11] and linear running time for CTL [1]. Model checking is usually applied to programs that consist of several concurrent processes; the number of states represent- ing the whole program behaviour may grow exponentially in the number of such processes. This problem (known as state explosion problem) and the huge complexity for verifying temporal formulae against a model, especially for CTL*, are limiting factors that have to be tackled for any practical use of this technique.
Abstract interpretation is a general theory for approximating the semantics of discrete dynamic systems [4]. This theory offers an appropriate framework
to approximate the model of a reactive system in order to obtain a simpler abstract model, over which the properties of interest can be checked for satis- faction. The idea here is that of verifying temporal properties in an abstract model which is systematically derived from the concrete semantics of the sys- tem we want to analyze, e.g., by abstracting the information contained in its states. Since the pioneering work on model checking and abstraction by Clarke et al. [2], a number of works have applied this idea to reduce the phenomenon of state explosion (e.g. [9]). However, Abstract Interpretation theory offers a number of methodologies that have not been applied yet in the field of abstract model checking. Many authors recognized in the possibil- ity of modifying abstract models by modifying abstractions a great potential for improving abstract model checking in precision and reducing complexity (e.g., Section 9 in [9]), but few applications of these techniques are known in abstract model checking. On the contrary, this practice is quite common in static program analysis by abstract interpretation. A number of operations have been studied, both in theory and in practice, to compose, decompose, refine and compress abstract domains and analyses (see [12,14] for a survey), providing advanced algebraic methodologies and techniques for tuning analy- ses in accuracy and costs.
In this work we study the impact of standard domain refinement opera- tions in abstract model checking. The problem is that when a chosen abstract domain turns out to provide a too rough abstract model for verifying a given temporal property of interest, this model can be refined by refining the cor- responding abstract domain. Conversely, any operation acting on domains which is devoted to their simplification (decomposition or compression) can play the dual roˆle of reducing the complexity of the verification of temporal formulae, provided that the formulae of interest are verified in both abstract and concrete models. In both these situations, the key problem is to study the structure of temporal formulae which are preserved or lost by changing


the abstract domain by means of domain refinement or simplification, and in particular the structure of those formulae that are verified in the new model and which were not verified in the former. We consider the universal frag- ment of the branching time temporal logic CTL∗ [11] and we characterize the structure of temporal formulae that are verified in a new abstract model ob- tained either by refining an abstract domain by means of standard operations for domain transformation introduced in [6] (reduced product and disjunctive completion) or by simplifying the domain by means of their inverse operations (complementation for domain decomposition [3] or least disjunctive bases for domain compression [15]). In particular we prove that relevant properties of systems can be checked compositionally by decomposing the abstract models by domain complementation and that disjunctive information is in some cases redundant in abstract model checking of our CTL* fragment. This may pro- vide sensible simplification algorithms for improving abstract model checking in complexity yet maintaining accuracy. We will describe an example of the application of our methods to demonstrate the practical impact of domain refinement operations in abstract model checking.

Preliminaries
Temporal Logic appears appropriate for describing the time-varying behaviour of reactive systems, e.g. universal properties (properties that have to hold along all executions of a program) and existential properties (properties that have to hold along some executions), as well as safety properties (nothing bad may happen) and liveness properties (something good has to happen) [18,19].

Temporal Logic and Model Checking
In this paper we consider the fragment known as ∀CTL* of the branching time temporal logic CTL* [2,11]: the formulae we deal with are the formulae of CTL* that do not use existential quantifiers. Of course, all the results apply to the universal fragment of the weaker language CTL, as well. In
∀CTL* universal properties are expressed through the path quantifier ∀ (“for all futures”) that quantifies over (infinite) execution sequences. The temporal operators G (Generally, always), F (Finally, sometime), X (neXt time), and
U (Until) express properties of a single execution sequence. Precisely, given a set Prop of propositions, the set Lit of literals is defined as Lit = Prop∪
{¬q | q ∈ Prop}∪ {true, false}. State formulae φ and Path formulae ψ are inductively defined by the following grammar, where p ∈ Lit:

state formulae:	φ ::= p | φ ∧ φ | φ ∨ φ | ∀ψ
path formulae:	ψ ::= φ | ψ ∧ ψ | ψ ∨ ψ | Gψ | Fψ | Xψ | U (ψ, ψ)
A transition system is a pair ⟨Σ, R⟩ consisting of a set Σ of states and a


transition relation R ⊆ Σ × Σ.
A Kripke structure is a tuple K = ⟨Σ, R, I,  ◦ ⟩ where ⟨Σ, R⟩ is a transition system, I ⊆ Σ is the set of initial states, and  ◦  : Lit −→ ℘(Σ) is the interpretation function such that  p = {s ∈ Σ | s |= p}. For ∀CTL∗ the notion of satisfaction of a state formula φ by a state s (s |= φ) is as usual in modal logic [9]. If K = ⟨Σ, R, I,  ◦  ⟩ is a Kripke structure, we say that K |= ϕ if and only if ∀s ∈ I : s |= ϕ. Given a temporal formula ϕ the satisfiability problem for ϕ is that of finding if there is a Kripke structure K such that K |= ϕ. In the case of CTL* (hence of ∀CTL∗) this problem is decidable [11]. For verification purposes, we are interested in the (global) model checking problem (MCP): given K = ⟨Σ, R, I,  ◦ ⟩ and a formula ϕ, check if K |= ϕ.

Abstract Interpretation
We assume basic notions of lattice theory [10]. The tuple ⟨C, ≤, ∨, ∧, T, ⊥⟩ denotes a complete lattice C, with ordering ≤, lub ∨, glb ∧, greatest element (top) T, and least element (bottom) ⊥ (i.e. C is a poset (C, ≤) such that any subset X of C has a least upper bound ∨X and a greatest lower bound ∧X). The downward closure of S ⊆ C is defined as ↓S = {x ∈ C | ∃y ∈ S. x ≤ y}.
↓ x is a shorthand for ↓ {x}, while the upward closure ↑ is dually defined.
We consider here Galois insertion/connection based abstract interpretation [5]. If A and C are posets, and α : C −m→A and γ : A−m→C are monotone functions such that ∀x ∈ C. x ≤ γ(α(x)) and ∀x ∈ A. α(γ(x)) ≤ x, then the quadruple (α, C, A, γ) is called a Galois Connection (GC for short) between C and A. The concrete and abstract domains, C and A, are assumed to be complete lattices and are related by abstraction and concretization maps forming a GC (α, C, A, γ). If in addition ∀a ∈ A. α(γ(a)) = a, then we call (α, C, A, γ) a Galois Insertion (GI) of A in C. When (α, C, A, γ) is a GI then each value of the abstract domain A is useful in representing C, because all the elements of A represent distinct members of C, being γ 1-1. Any
GC may be lifted to a GI identifying in an equivalence class those values of the abstract domain with the same concretization. This process is known as reduction of the abstract domain. Any abstract domain A in a GI (α, C, A, γ)
is isomorphic to a subset of the concrete domain C which is a Moore-family of C, i.e. X = M(X) d=ef {∧S | S ⊆ X} — where ∧∅ = T∈ M(X). It turns out that in general an abstract domain A corresponds to a complete meet (∧) subsemilattice of C, but, in general, it does not correspond to a complete sublattice of C, since the lub induced by A in C— namely γ(α(∨Y )) — might be different from that in C (i.e. ∨Y ). Indeed, the two lub's coincide whenever γ(α(C)) is a complete sublattice of C, which holds iff γ is additive. In this case we say that A is disjunctive. The lattice of all Moore families of C, also called the lattice of abstract interpretations of C [6], is denoted ⟨LC, ±, H, H, C, {T}⟩, with C being the bottom abstract domain (most concrete abstraction) and


{T} being the top abstract domain (most abstract abstraction) of C. In this case A ± B iff B ⊆ A as Moore families of C.

Abstract Model Checking
We abstract the transition systems with simpler (in any case finite) transition systems, following the lines of Abstract Interpretation. Work in this direction can be found in [2,9,8]. A (concrete) Kripke structure K = ⟨Σ, R, I,  ◦ ⟩ is abstracted by a Kripke structure Kα = ⟨A, Rα, Iα,  ◦ α⟩, where:
(α, ℘(Σ), A, γ) is a GI,
A is the set of abstract states,
Iα = {α(s) | s ∈ I}, and
Rα is defined as follows: for all a, b ∈ A,
Rα(a, b) iff b ∈ n α(Y )  Y ∈ min n Y '  R∃∃(γ(a),Y ') , ,

where R∃∃ d=ef n (X, Y )  ∃


x∈X

∃y∈Y
R(x, y) ,.

Observe that each abstract value represents a set of concrete values.
We say that p ∈ Lit is satisfied in an abstract state a whenever it is satisfied in all concrete states described by a:  p  α= {a ∈ A | γ(a) ⊆ p  }.

Fig. 1. The concrete and abstract Kripke structures C and A

The concrete transition system C of Fig. 1 represents a process that per- forms the actions wait, act1, and act2, whose interleaving is regulated by inspecting the value of a variable n ranging in Z. The set of states is the infinite set of pairs Σ = {wait, act1, act2}× Z, and I = {wait}× Z. Note that the labeled Kripke structure C represents an infinite transition system whose
transitions are not labeled. Consider in a compact way the approximating Kripke structure A in Fig. 1 given by A = {wait, act1, act2}× {∅, −, 0, +, Z} and Iα = {(wait, 0), (wait, −), (wait, +)}. In this way, we retain the basic
actions of the concrete domain and we abstract the infinite part relating to integer numbers by using the domain Sign (see Fig. 2). In all the figures we draw only the accessible states from the initial ones in Kripke structures.

Let K = ⟨Σ, R, I,  ◦ ⟩ be a Kripke structure. A path in K is an infinite sequence π = s0, s1, ··· of states in Σ such that s0 ∈ I and for every i ∈ N,





Z	Z	Z
•	•	•


−0 •/
Z
/•❧
•/= 0❧• 0+

ev //❅❅
//❅❅
//❅❅
❧/❧/

od
= 0 •
• +0
— •	• 0 • +
— •/❧•/0 ❧• +

❅•/
∅
❅•/
+
❅•/
∅
❧	/
❧•/
∅


Fig. 2. The domains Parity, Nneg, Sign, and Sign∨.
R(si, si+1); πi denotes si. We denote the set of paths of K by:
ΓK = {π | π0 ∈ I ∧ (∀n ∈ N)(πn ∈ Σ ∧ R(πn, πn+1))}.
Definition 3.1 Given two Kripke structures A = ⟨A, RA, IA,  ◦  A⟩ and B = ⟨B, RB, IB,  ◦  B⟩, we say that A is more precise than B (denoted as A≤ B) if ∀ϕ ∈ CTL*. B |= ϕ →A |= ϕ.
If A≤B and B≤ A, then we write A≡ B. A first key result on the impact of abstraction on the class of formulae satisfied by a model was proved in [9]. This result, that holds in particular for ϕ ∈ ∀CTL*, justifies the intuitive observation that by abstracting a model we loose precision.
Definition 3.2 Let C = ⟨Σ, R, I,  ◦  ⟩ and A = ⟨A, Rα, Iα,  ◦ α⟩ be the concrete and Abstract Kripke structures obtained by using a GI (α, ℘(Σ), A, γ). We say that A is an abstraction of C.
Theorem 3.3 ([9]) Let C = ⟨Σ, R, I,  ◦ ⟩ and A = ⟨A, Rα, Iα,  ◦ α⟩ be a concrete and an Abstract Kripke structures. Then C ≤ A.
It is well-known that GIs compose, namely if (α1, C, A1, γ1), (α2, A1, A2, γ2) are GIs then (α2◦α1, C, A2, γ1◦γ2) is a GI. The same holds for abstraction of Kripke structures.
Theorem 3.4 Let A, B, C be Kripke structures such that B is an abstraction of A and C is an abstraction of B, then C is an abstraction of A and A≤ C.
Refining abstract models
In this section we consider the two basic operations of domain refinement introduced in [6]: reduced product and disjunctive completion. A domain

refinement (see [14]) is any operation R : Ln
−→ LC such that for all domains

Xi ∈ LC, i = 1,..., n, R(X1,..., Xn) ± Xi. It is immediate by Theorems 3.3 and 3.4 that if R(A1,..., An) is the Kripke structure obtained by refining the domains in Ai, then R(A1,..., An) ≤ Ai.
Reduced product model checking
The reduced product operation is basically obtained starting from the cardinal product; the set of pairs is then ‘reduced’ to obtain a Galois insertion. Recall


that given a collection of domains {Ai}i∈∆, all abstracting a given domain C by Galois insertions (αi, C, Ai, γi)i∈∆, then (αH, C, P, γH) is the reduced product of Ai’s, denoted P = Hi∈∆Ai if P is isomorphic to the subset of C: M( i∈∆ γi(αi(C))) [6,7]. This operation corresponds to the glb operation H in the lattice of abstract interpretations LC.
Suppose that a system C has been abstracted in n different ways, by us- ing abstract interpretation. We assume that Ai = ⟨Ai, RAi, IAi,  ◦ Ai⟩ is an abstract Kripke structure, for each i ∈ {1,..., n}. The following definition formalizes the Kripke structure that can be obtained by combining the ab- stract state spaces Ai by reduced product. A transition from a to b is allowed in the product structure if a and b are obtained by the meet of states allowing a transition in each component.
Definition 4.1 Let ∆ = {1,..., n} and ∀i ∈ ∆, Ai = ⟨Ai, RAi, IAi,  ◦ Ai⟩ are abstractions of a Kripke structure C = ⟨Σ, R, I,  ◦ ⟩. The Product Kripke Structure is Hi∈∆Ai = (Hi∈∆Ai, RH, Hi∈∆IAi,  ◦  H), where RH(a, b) iff (∀i ∈ ∆)((∃ai, bi ∈ Ai)(RAi (ai, bi) ∧ αi(γH(a)) ≤ ai ∧ αi(γH(b)) ≤ bi)). a ∈ p  H iff γH(a) ⊆ p  .
The following result specifies that the reduced product of domains Ai pro- vides a more precise abstract model AH, where the conjunction of formulae which can be satisfied in some Ai, can be verified.
Theorem 4.2 Let ∆ = {1,..., n}. Suppose that C = ⟨Σ, R, I,  ◦  ⟩ is a Kripke Structure, ∀i ∈ ∆, Ai = ⟨Ai, RAi, IAi,  ◦ Ai⟩ are abstractions of C, and AH = ⟨Hi∈∆Ai, RH, IH,  ◦  H⟩ is the Product Kripke Structure. If
∀i ∈ ∆ : Ai |= Φi, then AH |=  i∈∆ Φi.

Proof. By contradiction, suppose that (∀i ∈ ∆)(Ai |= Φi) but AH |=	n
i.e. (∃j ∈ ∆)(AH |= Φj). By induction on the structure of the formula Φj:
Φi,

Φj = p, p ∈ Lit. AH |= p ←→ (∃i ∈ IH)(i |= p) −→ γH(i) /⊆ p  . For definition of Product Kripke structure i = i1∧· · ·∧ij ∧· · ·∧in −→ γH(i) = γH(i1 ∧· · · ∧ ij ∧ ··· ∧ in) ⊆ γj(ij) −→ γj(ij) /⊆ p  −→ ij /∈ p  Aj . A contradiction.
Φj = Xp. AH |= Φj ←→ (∃i ∈ IH)(∃s ∈ AH)(RH(i, s) ∧ s |= p). For def- inition of Product Kripke structure ∃j ∈ ∆ such that (∃ij ∈ IAj )(∃sj ∈ Aj)(RAj (ij, sj) ∧ αj(γH(s)) ≤ sj). For definition of GC and Reduced Product γH(s) ⊆ γj(αj(γH(s))). γH(s) /⊆ p  because s |= p −→ γj(αj(γH(s))) /⊆ p −→ αj(γH(s)) /∈ p Aj by definition of  ◦  Aj . sj |= p because sj ≥ αj(γH(s)). Thus, we obtain a contradiction.
Φj = φ1 ∧ φ2, Φj = φ1 ∨ φ2, Φj = ψ1 ∧ ψ2, Φj = ψ1 ∨ ψ2, Φj = Xψ or Φj = U (ψ1, ψ2), the proof is the same as the previous cases.
Φj = Gψ. AH |= Φj −→ (∃t ∈ ΓAH )((∃n ∈ N)(tn |= ψ)):
n = 0 : (∃i ∈ IH)(i |= ψ) −→ (∃ij ∈ IAj )(ij |= ψ) (the proof is the same
as the first case). We obtain a contradiction.

(Z, Z⟩
✏✏•zzzz
✏✏✏✏ / zzzzz
✏✏	//	z z zz
(—, T⟩ •zz(✏T,✏od⟩✏•	c(c+,cT⟩c• ✏✏•(T, ev⟩
/ ✏✏zz /	cc	✏✏ /❅
✏//✏✏	c/c/czczcz	✏✏✏	/	❅

(—, od⟩•zz
(+, od⟩ •
z•✏
(—, ev⟩
•/(+, ev⟩
/
❅✟•(0, ev⟩

zzz  ❅
// ✟✟✟
= (0, T⟩

z  ❅	/ ✟✟
zz❅	/ ✟
z❅z  /✟✟✟
❅z•
($, $⟩ = (0, od⟩

Fig. 3. The abstract domain Sign H Parity.
n > 0 : (∃t ∈ ΓA )((∃n ∈ N)(tn |= ψ)) −→ R(tn—1, tn) ∧ tn |= ψ −→
(∃j ∈ A)(∃s1, s2 ∈ Aj)(R(s1, s2) ∧s2 |= ψ) (the proof is the same as the
second case). We obtain a contradiction.
Φj = ∀ψ. AH |= Φj −→ (∃t ∈ ΓAH )(t |= ψ). The argument is the same as the previous cases: we find a trace in the Kripke structure Aj which does not satisfy ψ, a contradiction.
✷

Example 4.3 Consider the concrete Kripke structure C depicted in Fig. 4. It represents a process that performs the action:
act1, if the value of a variable n is greater than zero,
act2, if the value of the variable n is less than zero.
The value of the variable is modified by the process after the appropriate action is taken. The set of states is the infinite set of pairs Σ = {wait, act1, act2}× Z \ {0}, and I = {wait}× Z \ {0}. A possible approximation is the abstract Kripke Structure A1 whose set of abstract states is A1 = {wait, act1, act2}× 
{∅, −, +, Z}, and the set of initial states is Iα = {(wait, −), (wait, +)}. An- other approximation is the abstract Kripke Structure A2 whose set of ab- stract states is A2 = {wait, act1, act2}× {∅, ev, od, Z}, and the set of initial states is Iα = {(wait, ev), (wait, od)}. The reduced product Sign H Parity
is represented in Fig. 3 and provides the abstract Kripke structure in Fig. 4, where only maximal nodes, corresponding to states with maximal value in the product domain, are depicted (the label “?” reported in the figure means act1 ∨ act2). In this case it is easy to verify that A1 |= ∀G(¬n ≥ 0 ∨ Xn > 0),
A2 |= ∀G(¬even(n) ∨ XXodd(n)) and AH |= ∀G((¬n ≥ 0 ∨ Xn > 0) ∧ (¬even(n) ∨ XXodd(n))) where AH is the Product Kripke structure with do- main Sign H Parity.

Disjunctive model checking
Disjunctive completion was originally introduced to model multiple branches in static program analysis [6,17]. The idea is that a domain is disjunctive if no loss of precision is accumulated by approximating the join operation (e.g.














Fig. 4. Kripke structures A, A1, A2 and AH
set-union) in the abstract domain.
Definition 4.4 The disjunctive completion operator YC : LC −→ LC is de- fined for any X ∈ LC as follows:
YC(X) = H{A ∈ LC | A ± X ∧ A disjunctive}.
In this section we show that by refining the state space of a Kripke structure via disjunctive completion domain refinement we do not always obtain a more
precise model. Recall that if C is a complete lattice, then x ∈ C is join- irreducible if for any y, z ∈ C, if x = y ∨ z then x = y or x = z [10]. The set
of join-irreducibles of C is denoted by JI(C).
Theorem 4.5 Let A = ⟨A, RA, IA,   ◦  A⟩ and B = ⟨Y(A), Rg(A), Ig(A),  ◦ g(A)⟩ be Kripke structures abstracting C = ⟨Σ, R, I,  ◦ ⟩. If IA ⊆ JI(A) and (∀n ∈ N)(RA(sn, sn+1) → {sn, sn+1}⊆ JI(A)) then A≡ B.
Proof. JI(Y(A)) = JI(A) (Y(A) may be different from A only in the infor- mation about the join operation between elements of ℘(Σ)) and thus the most precise abstraction of ℘(Σ) in Y(A) is the same as the abstraction of ℘(Σ) in A.	✷
A characterization of those formulae that are not satisfied in non-disjunctive abstract models will be given later on in Section 5.2.
Example 4.6 By considering the example in Section 3 and by abstracting C with SignV we obtain the model A. On the contrary, if we consider the example 5.6 we note that the model computed with Sign is less precise than A because the Z element is not join irreducible.
Compressing abstract models
In this section we study the impact of two operations of domain simplifica- tions, namely complementation and least disjunctive bases, in abstract model checking. The idea here is that by reducing domains it is possible to reduce


the complexity of temporal models and thus the verification of temporal for-

mulae of interest. A domain simplification is any operation S : Ln
−→ LC

such that for all domains Xi ∈ LC, i = 1,..., n, Xi ± S(X1,..., Xn) [14]. It is immediate by Theorems 3.3 and 3.4 that if S(A1,..., An) is the Kripke structure obtained by simplifying the domains Ai, then Ai ≤ S(A1,..., An). A simplification is a compression if it returns the most abstract domain (when
it exists) from which the original domain can be fully reconstructed back by a corresponding refinement: S : LC −→ LC is a compressor for a refinement R : LC −→ LC if S(R(X)) = S(X) and R(S(X)) = R(X) [14].

Complementing model checking
Complementation is important for domain decomposition, in fact it simplifies verification problems for complex domains, by decomposing them into sim- pler problems. Domain complementation is the inverse operation of reduced product, and corresponds to find, for any domains A ± B, the most abstract domain X such that X H B = A, i.e. it is the compressor of the domain re- finement λX. X H B. The problem of domain decomposition has been solved in [3] providing a systematic method for decomposing abstract domains into simpler factors. Recall that if C is a complete lattice, then x ∈ C is meet- irreducible if for any y, z ∈ C, if x = y ∧ z then x = y or x = z. The set of meet-irreducibles of C is denoted by MI(C). We say that C is generated by MI(C) if C = M(MI(C)). The following result provides a characterization of domain complementation in terms of meet-irreducible elements.
Theorem 5.1 ([13]) Let C be a complete lattice generated by MI(C), and let (αA, C, A, γA) and (αD, C, D, γD) be such that A ± D. Then
A ∼ D = M(MI(A) \ D).
By applying complementation on the state space of a Kripke structure we obtain a simpler abstract structure which in general does not satisfy some temporal formulae of interest. We study under which conditions on the for- mulae we obtain a less precise abstract model by decomposing the abstract state space of a transition system.
The following result characterizes the predicates which are not preserved by complementing abstract Kripke structures. By a straightforward induction it is easy to characterize the structure of arbitrary temporal formulae that are not preserved by complementing abstract structures (see the example below).
Theorem 5.2 Let C = ⟨Σ, R, I,  ◦ ⟩ and A = ⟨A, RA, IA,  ◦ A⟩ be a con- crete and an abstract Kripke structure. Let p ∈ Lit. A∼ = ⟨A ∼ B, R∼, I∼,
 ◦ ∼⟩ /|= p iff
(∃s ∈ IA)(s |= p ∧ (∀x ⊆↑s ∩ M(MI(A) \ B))(x |= p) ∧ (∃x ∈↑ s)(x |= p)).


m	m	m
Proof. Let αA : ℘(Σ)−→A, γA : A−→℘(Σ), αA∼ : ℘(Σ)−→A ∼ B, γA∼ :
A ∼ B −m→℘(Σ) be the abstraction and concretization functions. Let sˆ ∈ I be an initial state such that sˆ |= p ∧ (∀x ⊆↑ sˆ∩ M(MI(A) \ B))(x |= p) ∧ (∃x ∈↑
sˆ)(x |= p)), this means that sˆ /∈ MI(A) \ B.	Let S be {s ∈ A | s ⊆↑
sˆ∩M(MI(A) \B)}. αA∼ (γA(sˆ)) ∈ S −→ αA∼ (γA(sˆ)) |= p −→ the abstraction of the initial state sˆ in A∼ does not satisfy p, and therefore A∼ |= p.	✷
Example 5.3 Consider the concrete Kripke structure C in Fig. 5, with Σ =
{wait, act}× N, and an approximated structure A with space states A =
{wait, act}×SignV. We observe that the variables cannot take negative values
and thus it is possible to abstract A in a new structure which does not contain strictly negative information. Note that SignV ∼ {Z, −0, −} = Nneg in Fig. 2. Nneg induces an abstract structure N which abstracts A, i.e. A≤ N . It is now easy to verify that A |= (n = 0 ∨ n > 0) (i.e. ∀i ∈ I, i |= (n = 0 ∨ n > 0)) instead, N /|= (n = 0 ∨ n > 0) because the value 0 is abstracted in
0+.


n=0 n++


n++

Fig. 5. Kripke structures C, A, and N


Compressing model checking
The relevance of compression with respect to disjunction relies upon Theo- rem 4.5 above. In this case it is natural to state the following question: Is it possible to minimize the disjunctive information in domains in such a way the abstract model be minimal with respect to this information? In the follow- ing we consider the notion of least disjunctive bases introduced in [15]. This
operation is well defined in most applications of abstract interpretation and returns the most abstract domain which induces, by disjunctive completion, a given disjunctive domain.
Definition 5.4 Given a complete lattice C, X ∈ LC is disjunctively optimiz- able if YC(H{A ∈ LC | YC(A) = YC(X)}) = YC(X).
If a domain A ∈ LC is disjunctively optimizable then its least disjunctive bases exists and it is denoted by ΩC(A) [15]. This is the case when C is a completely distributive lattice generated by its join irreducible elements, in particular when C = ℘(Σ). In particular, let C = ⟨Σ, R, I,  ◦ ⟩ be a Kripke structure, then Ω℘(Σ)(A) = M(JI(Y℘(Σ)(A))) for any A ∈ L℘(Σ) [15].
The following result characterizes precisely those predicates which are not preserved in the abstract Kripke structures obtained by the least disjunctive bases.


Theorem 5.5 Let C = ⟨Σ, R, I,  ◦  ⟩ and A = ⟨A, RA, IA,  ◦  A⟩ be a concrete and an abstract Kripke structure. Let p ∈ Lit.
Ω(A) = ⟨Ω(A), RΩ(A), IΩ(A),  ◦ Ω(A)⟩ /|= p iff
(Es ∈ IA)(s |= p Λ (6x ⊆† s ∩ ł(JI(A)))(x |= p) Λ (Ex ∈† s)(x |= p)).
Proof. Let αA : ℘(Σ)—m→A, γA : A—m→℘(Σ), α : ℘(Σ)—m→Ω(A), γ : Ω(A)—m→℘(Σ) be the abstraction and concretization functions. Let sˆ ∈ I be an initial state such that sˆ |= pΛ(6x ⊆† sˆ∩ł(JI(A)))(x |= p)Λ(Ex ∈† sˆ)(x |= p)), this means that sˆ /∈ JI(A). Let S be {s ∈ A | s ⊆† sˆ ∩ ł(JI(A))}. αΩ(A)(γA(sˆ)) ∈ S —→ αΩ(A)(γA(sˆ)) |= p —→ the abstraction of the initial state sˆ in Ω(A) does not satisfy p —→ Ω(A) |= p.	✷
As before, those formulae which are not satisfied in the least disjunctive bases structure can be characterized by a straightforward inductive argument from the predicates not preserved as given in Theorem 5.5.
Example 5.6 Consider the concrete Kripke structure C in Fig. 6. The set of states is the infinite set of pairs Σ = {wait, act}×Z, and I = {wait}×{0, = 0}. Actually, in C it is not important the integer value of n but the comparison
of its value with zero. Consider an approximating Kripke structure A with domain A = {wait, act}× SignV and a further abstraction У with domain B = {wait, act}× Sign. Note that the abstract Kripke structure У does not verify all the properties that hold in A. For example, if ϕ = 6G(n /= 0 VXn /= 0), A |= ϕ while У /|= ϕ because the value /= 0 is abstracted in Z.


n=0 n++


n++

Fig. 6. Kripke structures C, A, and У


An example
In this section we consider an example of the application of our methods to demonstrate the practical impact of domain refinement operations in abstract model checking.
The example is drawn from [2]: a concurrent algorithm for sorting an array of n cells containing integer numbers. Avoiding implementation details, the sorting algorithm works as follows: the n cells are numbered consecutively from right to left. The sort proceeds in cycles. During each cycle, exactly half the cells (either all of the odd-numbered cells or all of the even-numbered cells) will be compared with their right neighbour cell. If the value of a cell to be sorted is less than its right neighbour’s value then the two values are swapped


(for more details on the program see [2], where it is assumed that array cells contain only two values, zero and one). In Fig. 7 we show how the algorithm intuitively works when applied to an array of eight cells. The nodes with an entering arrow are the “active nodes” (i.e. the nodes that control the sort in the current cycle of execution of the program). Note that if in a cycle the odd-position nodes are active, during the next cycle the even-position nodes become active, and vice versa. The algorithm sorts the array in linear time.



first cycle



second cycle



third cycle



fourth cycle



fifth cycle

Fig. 7. An execution of the linear sorting array algorithm

This sorting algorithm can be formalized by using a Kripke structure over which it is possible to verify a temporal property that implies that the array is eventually sorted.
For example, in Fig. 8 we represent the Kripke structure for sorting two integer numbers in ascending order (here, as usual, entering arrows denote initial states). The system consists of two concurrent processes that cycle (mutually exclusively) through an infinite sequence of “active” (A) and “non- active” (NA) conditions. Each process swaps its cell with the right neighbour cell only if it is active and the values of the two cells are not in the right order. We want to verify that along every execution the following property holds:
eventually, the value of the ﬁrst cell is less than or equal to the value of the second cell.

Fig. 8. Kripke structure for linear sorting array program

The state space Σ of this program is the set {A, NA}2 × Z2, where the first and the second value in a tuple of Σ are the conditions active or non-active of the two processes, while the last two values are the cells to be sorted. The initial states are {⟨A, NA, n, m⟩, ⟨NA, A, n, m⟩ | n, m ∈ Z}. The transitions

Z
Z	•
•
[—m,+m]
Z
•
[—m,+m]
jj	JTTTT

??
j tt	J

?[—m,+m]
 ??
jjjjjttt	JJJ TTTTT

 ??
[—m,d) •?
• [d,+m] [—m,c] •Dj
•?t[c,m)[—m,d] •
[d,+m]

[—m,c) •
? [c,+m]
??	
DDD
???

zzz

?	•	? 
? ? 	•
DD	??[c,d]	zz
D	? 	z

	∅
DDD •	zzz

∅	DD zz
•
∅

Fig. 9. Abstract domains Intc, Intd, and Intc H Intd
between two nodes are depicted in Fig. 8: observe that in each state only one process is active.
In order to abstract the Kripke structure in Fig. 8 with an abstract Kripke structure Ac = ⟨Σc, Rc, Ic, lc⟩ (see Fig. 10) we introduce an abstract domain, which is defined by providing abstractions of the components that form the concrete domain. We choose to leave the components {N A, A} the same. Formally, this means that we take an abstract domain containing elements NA and A whose concretizations are {N A} and {A}, respectively. To abstract the integer values to be sorted, we can compute a partitioning with respect
to a parameter c (as in [2]). Given c ∈ Z we define a GI (α, ℘(Z), Intc, γ) between ℘(Z) and the abstract domain Intc in Fig. 9 (m ∈ N is a constant playing the roˆle of maxint ). The abstraction function is defined as follows: 6S ⊆ ℘(Z), α(S) = [—m, c) iff 6x ∈ S x < c; α(S) = [c, +m] iff 6x ∈ S x ≥ c; α(S) = [—m, +m] otherwise.


Fig. 10. Abstract Kripke structure Ac for linear sorting array program

The set Σc of abstract states is now defined as follows: Σα = {NA, A, T}2 × Int2. Its top element is ⟨T, T, Z, Z⟩, while the approximation relation ≤ is the extension of the orderings on each of the four components. It is im-
portant to note that the approximation order on the integer components (the Intc domain in Fig. 9) does not correspond to the obvious order rela- tion (≤) used by the algorithm to sort the integer values (i.e. [—m, c) ≤ [c, +m] but [—m, c) /≤ [c, +m]). The set of abstract initial states is: Ic =
{⟨A, NA, i1, i2⟩, ⟨N A, A, i1, i2⟩ | i1, i2 ∈ {[—m, c), [c, +m]}}.  The abstract
transition relations and the abstract interpretation of the concrete predicate ‘≤’ are computed accordingly to the definitions stated in Section 3.
It is easy to check that along every path of the abstract Kripke structure there is a continuation of the path that reaches only “sorted” states, i.e. if there is a value to be sorted that is less than c then it comes before the other value.


The temporal formula corresponding to the property is:
ϕc ≡ 6F 6G (x1 < c V x2 ≥ c)
where x1 and x2 are the two values to be sorted. ϕc is tautologically equivalent to:
6F 6G((x1 < c Λ x2 < c) V x2 ≥ c)
Note that if the cells to be sorted by the linear sorting array algorithm are n then the number of abstract states is 2n+1, while the number of concrete states is infinite or 2rn, considering a range r of integer number (e.g. r ' 2maxint).
In order to refine the abstract sorting algorithm, it is possible to abstract the original Kripke structure by using two different abstract states spaces, i.e. by partitioning the integer numbers with respect to two different parameters
(namely c and d). Consider for example the two domains Intc and Intd in Fig. 9 and suppose, without loss of generality, that c < d. By means of reduced product operation, we obtain the domain Intc H Intd (see Fig. 9)
which allow us to compute a more precise abstraction on integer values. In Fig. 11 it is reported a portion of the Product Kripke structure we obtain by taking into account the new domain Intc H Intd, and in particular by combining the state spaces Σc = {NA,A, T}2 × Int2 and Σd = {NA,A, T}2 ×
Int2 of two different abstract Kripke structures by means of reduced product (Ad = ⟨{NA,A, T}2 × Int2, Rd, Id, ld⟩ is obtained in the same way as Ac). We
illustrate the case where the two values to be sorted may not be in the right order by partitioning the integer numbers with the parameter c, while they are in the correct order if we partition the numbers by using d. This model satisfies the temporal formula ϕc Λ ϕd = 6F 6G((x1 < c Λ x2 < c) V x2 ≥
c) Λ 6F 6G((x1 < d Λ x2 < d) V x2 ≥ d), according to Theorem 4.2. Moreover, it satisfies the formula ϕc×d = 6F 6G((x1 < c Λ x2 < c) V (x1 < c Λ c ≤ x2 ≤ d) V (x1 < c Λ x2 > d) V (c ≤ x1 < d Λ x2 > d) V x2 > d), stating that the two values are ordered also with respect to the new partition of Z.

Fig. 11. A part of the Product Kripke structure Ac H Ad
Therefore, by using refinement operations, such as reduced product, it is possible to systematically refine abstract models, which approximate a given reactive system, and consequently obtain a new abstract reactive system that automatically verifies a combination (e.g the conjunction for the reduced prod- uct operation) of the formulae of interest. We conclude the subsection by giving some remarks on the complexity of the model checking problem that we have taken into account.


The algorithm for determining whether a CTL formula ϕ is true in the states of a Kripke structure ⟨S, R, P⟩ runs in time O(length(ϕ) · (| S | + | R |)), where length(ϕ) is the number of subformulae of ϕ (see [2]). Thus, since ϕc is a CTL formula and thus, the problem of checking it on the model Ac = ⟨Σc, Rc, Ic, lc⟩, has a linear complexity, more precisely the algorithm runs in time proportional to length(ϕc)·(| Σc | + | Rc |) ' 22·(2·22+2·22) = 4·22+2. Checking ϕd on Ad is the same problem.
In general, the length of a CTL formula ϕ which specifies that n integer values are eventually sorted, partitioning Z into k intervals, is length(ϕ) ' kn. The size of the abstract Kripke structure for this particular configuration of the problem is | Σ | + | R |' 2kn + 2kn (the n integers to be sorted may assume k abstract values and in the linear sorting algorithm the “even-cells” or the
“odd-cells” are alternatively considered. Moreover, each abstract state has an outgoing edge).
We have also demonstrated that by combining two different abstractions K1 and K2 of a given Kripke structure K, such that K1 |= ϕ1 and K2 |= ϕ2, we automatically obtain a new abstract Kripke structure K1 H K2 which verifies ϕ1 Λ ϕ2 (we do not have to check it!). Since K1 H K2 is more precise than K1 and K2 we are interested in checking the satisfaction of new temporal formulae on its states. The size of K1 H K2 is less than or equal to | K1 |·| K2 |, be-
cause of the reduction of abstract values with the same concretization (see [6]) (typically, the number is strictly lower: in the case of Fig. 9 we have 8 states instead of 25).
For the sorting problem we want to assure that the integers are eventually in the correct order with respect to the partition induced by the reduced product domain. In our example, we have to check on the model Ac H Ad
the satisfaction of the CTL formula ϕc×d = 6F 6G((x1 < c Λ x2 < c) V (x1 < c Λ c ≤ x2 ≤ d) V (x1 < c Λ x2 > d) V (c ≤ x1 < d Λ c ≤ x2 < d) V x2 > d).
In this case the model checking problem can be solved in time proportional to
length(ϕc·d) · (| Σc | + | Rc |) · (| Σd | + | Rd |).
To sum up, consider an abstract domain Σc1 H ··· H Σcj , j > 1, that is the reduced product of j domains each of them partitions Z in 2 intervals. On the abstract Kripke structure with state space Σc1 H · · ·H Σcj we can check the
2n
satisfaction of the CTL formula ϕc1×···×cj in time proportional to 4 · (j + 1)  ,
where n is the number of cells to sort. Moreover, the Theorem 4.2 assures that the Kripke structure satisfies the formula ϕc1 Λ · · ·Λ ϕcj . If we want to refine again the partition of the integer numbers we compute the abstract state space Σc1 H ··· H Σcj H Σcj+1 of a new Product Kripke structure, which automatically satisfies the formula ϕc1 Λ · · ·Λ ϕcj Λ ϕcj+1 . The complexity of the model checking problem for the formula ϕc1×···×cj×cj+1 increases with a ratio proportional to (1 + 1)2n and thus, at each step of the systematic refining
process it is possible to check the satisfaction of a more refined formula with a small increment of the complexity.


Future works
On the side of domain operations we plan to study the impact of Cousot’s reduced cardinal power operation [6] and Heyting completion [16] for con- structing relational abstract model checking. This operation, which does not admit a corresponding compressor, should upgrade domains, and therefore Kripke structures, with implicational information. On the side of Temporal Logic, we plan to generalize our results to arbitrary Temporal Logics. This
can be achieved by considering more general µ-calculus, as in [8]. All these results should lead to the definition of a transformer of temporal formulae as-
sociated with each abstract domain transformer, and appropriate algorithms for simplifying or refining abstract model checking.

References
Clarke, E. M., E. A. Emerson and A. P. Sistla, Automatic verification of finite- state concurrent system using temporal logic specification, ACM Transaction on Programming Languages and Systems 8 (1986), pp. 244–263.
Clarke, E. M., O. Grumberg and D. E. Long, Model checking and abstraction, ACM Transaction on Programming Languages and Systems 16 (1994),
pp. 1512–1542.
Cortesi, A., G. Fil´e, R. Giacobazzi, C. Palamidessi and F. Ranzato,
Complementation in Abstract Interpretation, toplas 19 (1997), pp. 7–47.
Cousot, P., Abstract Interpretation, ACM Computing Surveys 28 (1996),
pp. 324–328.
Cousot, P. and R. Cousot, Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints, in: Conference Record of the 4th ACM Symposioum on Principles of Programming Languages (POPL ’77 ) (1977), pp. 238–252.
Cousot, P. and R. Cousot, Systematic design of program analysis frameworks, in: Conference Record of the 6th ACM Symposioum on Principles of Programming Languages (POPL ’79 ) (1979), pp. 269–282.


Cousot, P. and R. Cousot, Inductive definitions, semantics and abstract interpretation, in: Conference Record of the 19th ACM Symposioum on Principles of Programming Languages (POPL ’92 ) (1992), pp. 83–94.
Cousot, P. and R. Cousot, Temporal abstract interpretation, in: Conference Record of the ACM Symposioum on Principles of Programming Languages (POPL ’2000 ) (2000), pp. 12–25.
Dams, D., R. Gerth and O. Grumberg, Abstract interpretation of reactive systems, ACM Transaction on Programming Languages and Systems 19 (1997),
pp. 253–291.
Davey, B. A. and H. A. Priestley, “Introduction to Lattices and Order,” Cambridge University Press, Cambridge, U.K., 1990.
Emerson, E. A., Temporal and modal logic, in: J. van Leeuwen, editor, Handbook of Theoretical Computer Science, B: Formal Models and Semantics, Elsevier, Amsterdam and The MIT Press, Cambridge, Mass., 1990 pp. 997–1071.
Fil´e, G., R. Giacobazzi and F. Ranzato, A unifying view of abstract domain design, ACM Computing Surveys 28 (1996), pp. 333–336.
Fil´e, G. and F. Ranzato, Complementation of abstract domains made easy, in:
M. Maher, editor, Proceedings of the 1996 Joint International Conference and Symposium on Logic Programming (JICSLP ’96 ) (1996), pp. 348–362.
Giacobazzi, R. and F. Ranzato, Refining and compressing abstract domains, in:
P. Degano, R. Gorrieri and A. Marchetti-Spaccamela, editors, Proceedings of the 24th International Colloqium on Automata, Languages and Programming (ICALP ’97 ), Lecture Notes in Computer Science 1256 (1997), pp. 771–781.
Giacobazzi, R. and F. Ranzato, Optimal domains for disjunctive abstract interpretation, Science of Computing Programming 32 (1998), pp. 177–210.
Giacobazzi, R. and F. Scozzari, A logical model for relational abstract domains, ACM Transaction on Programming Languages and Systems 20 (1998),
pp. 1067–1109.
Jensen, T., Disjunctive strictness analysis, in: Proceedings of the 7th IEEE Symposium on Logic in Computer Science (LICS ’92 ) (1992), pp. 174–185.
Manna, Z. and A. Pnueli, “The Temporal Logic of Reactive and Concurrent Systems,” Springer-Verlag, Berlin, 1992.
Mu¨ller-Olm, M., D. Schmidt and B. Steffen, Model-checking. A tutorial introduction, in: G. Fil´e, editor, Proceedings of the International Static Analysis Symposium (SAS ’99 ), Lecture Notes in Computer Science 1694 (1999), pp. 330–354.
