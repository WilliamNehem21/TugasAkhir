Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 103–119
www.elsevier.com/locate/entcs
Focused Linear Logic and the λ-calculus
Taus Brock-Nannestad1,3
INRIA Saclay & LIX, E´cole Polytechnique
Nicolas Guenot2,4
IT University of Copenhagen

Abstract
Linear logic enjoys strong symmetries inherited from classical logic while providing a constructive framework comparable to intuitionistic logic. However, the computational interpretation of sequent calculus presentations of linear logic remains problematic, mostly because of the many rule permutations allowed in the sequent calculus. We address this problem by providing a simple interpretation of focused proofs, a complete subclass of linear sequent proofs known to have a much stronger structure than the standard sequent calculus for linear logic. Despite the classical setting, the interpretation relates proofs to a refined linear λ-calculus, and we investigate its properties and relation to other calculi, such as the usual λ-calculus, the λμ-calculus, and their variants based on sequent calculi.
Keywords: Linear Logic, Focusing, Lambda-calculus, Curry-Howard Correspondence


Introduction
The idea of “proofs as programs” found in the original Curry-Howard correspondence between intuitionistic natural deduction and the simply-typed λ-calculus has proved to be a powerful narrative, leading to the development of functional programming, with its expressive type systems and strong guarantees on the behaviour of programs. A number of variants and extensions have been proposed, such as the λμ-calculus [20], based on classical logic. In the midst of many developments around the computational interpretation of logical systems, linear logic [11] has taken an important place in this field by providing a refined view of logics and their computational meaning. However, it is mostly seen as a tool, the instrument of a methodology [3,14], rather

1 Email: taus.brock-nannestad@inria.fr
2 Email: ngue@itu.dk
3 Supported by the ERC Advanced Grant ProofCert.
4 Supported by grant 10-092309 from the Danish Council for Strategic Research to the Demtech project.

http://dx.doi.org/10.1016/j.entcs.2015.12.008
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

than the object of a computational interpretation, at least in its standard form — its intuitionistic variant has been used to describe a linear λ-calculus [7]. The problem lies in the framework of the sequent calculus in which it is described, which has a structure too lax to be conveniently represented through any kind of λ-terms. This fundamental problem has been tackled from the beginning using the formalism of proof-nets, described as natural deduction for linear logic [11], but this is a radical departure from traditional proof syntaxes, implying a use of graphs as representation, one way or another, to write programs. Keeping the standard syntax of proof trees requires changing the kind of programs considered, and interpretations based on pattern-matching [22] or processes [1,6,23] have been proposed.
In another setting, focusing [4] has been developed to improve proof search in linear logic by identifying a complete subset of proofs endowed with a strong structure. As this normal form was studied in details, it became apparent that the notion of polarity and the associated permutability properties leading to focused systems was an essential aspect of linear proof theory [15]. However, the focused sequent calculus for linear logic, just as its unfocused variant, has not appeared as a framework of choice for a direct computational interpretation in the Curry-Howard tradition. In this paper, we propose a simple interpretation of the most standard focused presentation of MELL, showing how the structure of focused proofs can be described by refined linear λ-terms as found in an intuitionistic setting, despite the “classical” nature of this logic — and in particular, despite the presence of the O connective.
The key to this interpretation is the use of an explicitly polarised syntax, where the negative formulas type computations while positive formulas type values, as done in the call-by-push-value framework [17]. Moreover, we consider a strongly focused system, where inversion is performed maximally and in an ordered fashion, thus yielding normal forms where no two inference rule instances can be permuted, although entire focused phases can still be permuted. The extracted calculus, that we call λπ, has no explicit control operator, but its type system allows the encoding of calculi with control, such as λμ, through a relatively simple translation. We present in Section 2 our focused proof system for MELL along with a term assignment, and discuss its basic properties.
The two fundamental results, cut elimination and focalisation, are proved in Section 3, and we discuss the computational interpretation of these two theorems, when viewing their proofs as transformations of terms in the λπ-calculus. The reduction of cuts, done in big steps, corresponds to the expected notion of reduction, based on substitution and the decomposition of pairs. Focusing corresponds to a reorganisation of terms that simplifies the structure of a term by rearranging the position of its subterms, merging values previously kept separated by unrelated phases of computation.
Finally, we discuss in Section 4 the expressivity of the λπ-calculus by considering fragments and encodings of known calculi into these fragments. Of particular interest are the sequent calculus variants of the simply-typed λ-calculus and of the λμ-calculus, which are closely related to their originals stemming from natural

deduction. Note that λπ has a rich structure: it is a sequent-based variant of λμ with a notion of linearity, in which terms can be applied to trees rather than just lists of arguments. We conclude in Section 5 and discuss further investigations, from generalisations to richer logics to practical applicability.
Related work. As mentioned, the computational meaning of the standard system for “classical” linear logic has not been investigated as much as the interpretations given for intuitionistic logic or classical logic. A detailed description of focusing in intuitionistic logic, with proof terms, can for example be found in [21]. In the classical setting, the study of computation in the sequent calculus [9] has lead to a system called L providing a syntax extending the λμ-calculus in a symmetric way, and this system has been studied in the linear setting [19]. However, this system is not focused in general and cuts, performing the selection of a formula to focus on, cannot all be eliminated. Also related is the work on polarised linear logic [15], and in particular the encoding the λμ-calculus in polarised proof-nets [16]. We discuss this connection in Section 4.

Focused Proofs and Linear λ-terms
Focusing can be seen as a way of structuring proofs. Take for instance the standard rules of the multiplicative fragment of linear logic:


−−−−−−
▶ a, a
▶ Γ, A,B 
−−−−−−−−−−−−−
▶ Γ,A O B
▶ Γ,A	▶ Δ,B 
−−−−−−−−−−−−−−−−−−
▶ Γ, Δ,A ⊗ B

Proofs within this fragment have very little structure beyond that enforced by the subformula relation. Focusing allows us to enforce further structure in two ways. Firstly, the rule introducing the O connective is invertible (i.e. the conclusion implies the premise), hence we can assume that this inversion property is always applied maximally within a proof. In other words, no ⊗ is decomposed if there is a O in the remaining context. Secondly, and perhaps most importantly, the decomposition of ⊗ can be rearranged into maximal chains of ⊗-decompositions. Note that the ⊗ rule is not invertible, as it requires the linear context to be split into two parts, and this split may not be known beforehand. Thus, decomposing, say, A ⊗ (B ⊗ C) results in subderivations containing A and B ⊗ C respectively. In the focusing discipline, we would require that B ⊗ C was decomposed immediately as well.
We enforce the maximality of the inversion (or asynchronous) and chaining (or synchronous) phases by dividing the sequent into two parts. During inversion, we maintain a list of potentially invertible formulas, and always decompose the first element of this list. If the top connective is a O, we put both subformulas back into the list, otherwise we move the formula into the other part of the sequent. In this way, we ensure that every O formula in the context gets decomposed, if possible. During the chaining phase, we maintain a stoup containing a single formula, called the “focus”. When decomposing a ⊗, the two subformulas are put in this stoup in the premises, thus ensuring that these formulas are decomposed in turn, if possible. We consider the multiplicative-exponential fragment of linear logic [11] with the



Fig. 1. Inference rules for focused MELL with λπ-terms
purely linear connectives O and ⊗, the exponential modalities ? and ! as well as the explicit polarity shifts ↑ and ↓ — as linear mediation between positives and negatives [15]. We also assume given a countable set A of atoms partitioned such that any atom a has a uniquely defined negative counterpart a in A. The grammar of formulas in this polarised variant of MELL is divided in two classes:
P, Q ::= ↓a | ↓N | P ⊗ Q | !N	N, M ::= ↑a | ↑P | N O M | ?P

where P and N denote positive and negative formulas respectively. The notion of duality (·)⊥ extending the relation between a and a to all formulas is defined as usual in linear logic. Notice that in our syntax, atoms always appear immediately under a polarity shift: this is an explication of the bias, the choice of the polarity of a given atom. A polarised formula therefore contains all the required polarity information. In the following, we will write ↑A to denote either ↑a or ↑P , and ↓A for either ↓a or ↓N . The sequent calculus shown above in Figure 1 is the standard triadic form of the focused system [4] for MELL, made more precise by the use of polarity shifts. It operates on two kinds of sequents:
⎧⎨ ▶ Ψ; Γ ⇑ S	:	asynchronous sequent, where S is a sequence of negatives
⎩ ▶ Ψ; Γ ⇓ P	:	synchronous sequent, where P is a single positive
where Ψ and Γ are multisets containing named formulas, written x : ?P and x : ↑A respectively. As usual, we assume that the variables affixed to these formulas are distinct. The list S can be empty, and represents the part of the context treated in the inversion phase, while P in the other sequent is the positive decomposed in a focus phase — more details on this system can be found in [4]. Note that formulas in Ψ are subject to weakenings and contractions, since they are exponential.
The sequent calculus in Figure 1 comes with a term assignment: it is a variant of

the linear λ-calculus separating terms from values. This distinction is not surprising given the known impact of focusing on computation [10], but the direct typing of λ-terms by proofs of the “classical” flavour of linear logic is. Indeed, although intuitionistic linear logic has been interpreted through linear λ-terms [7], the standard linear logic using O in a sequent calculus has been connected to processes [6,23] or pattern-matching [22] only. This is an illustration of the ability of focalisation to shed light on the computational meaning of proofs in the sequent calculus.
We call the language used to represent focused MELL proofs the λπ-calculus: it can be viewed as a linear variation on the λ-calculus representing LJT proofs proposed by Herbelin [12]. However, it uses pairs and an unpairing operator π rather than lists of arguments. The grammar of terms and values is:
t, u ::= λx.t | x p | t p | π.t | λ!x.t | !x p   p, q ::= x | [t♩ | (p, q) | !t
where t and p denote a term and a value respectively. Beyond having constructs for abstraction and applications, the λπ-calculus features thunks [t♩ turning a term into a value, as found for example in call-by-push-value [17]. In addition, because the core language is linear, λπ has replicating variants of the abstraction, variable application, and thunk constructs. The relation between proofs and terms is tight: there is one-to-one correspondence in the fragment covered by MELL. This strong connection between the proofs of a highly symmetric logic and a relatively standard λ-calculus is made possible by the additional structure obtained through focusing. Identity expansion. As usual in linear logic, the more general form of the identity axiom applicable on a compound formula is admissible in this system. However, due to the polarised setting, this requires a precise definition of the expansion of a
negative formula N , denoted by N∗ and defined as follows:
(↑A)∗ = ↑A	(N O M )∗ = N ∗, M∗	(?P )∗ = ?P
so that we can relate any N to the pair of a persistent and a linear context (Ψ, Γ) through expansion. In the following, we write [Γ| for the set of formulas contained in Γ. We can now prove in a mutual induction the following two lemmas justifying the generalisation of the identity axiom.
Lemma 2.1 The sequents ▶ Ψ; x : ↑P ⇑ P⊥ and ▶ Ψ,x : ?P ; · ⇑ P⊥ are provable.
Proof. In the first case, we can decompose P⊥ eagerly until we obtain a premise of the shape ▶ Ψ, Ω; Γ,x : ↑P ⇑ · and focus on P , so that we conclude by Lemma 2.2. The other case is treated the same way, but uses the exponential focus rule.   2
Lemma 2.2 (Identity expansion) If N∗ = [Ψ, Γ| then we have ▶ Ψ, Ω; Γ ⇓ N⊥.
Proof. We proceed by induction on the formula N . In the base case, N is of the shape ↑a and we conclude using the axiom rule. In the general case, if N is of the shape M O L we apply the induction hypothesis on M and L separately and compose the proofs obtained using the ⊗ rule. If N is of the shape ↑P or ?P then we conclude using Lemma 2.1 on P⊥ and either the ↓ rule or the ! rule.	2
An immediate consequence of this last lemma is that the identity axiom can now

be generalised into the following two rules:

========================
x ▶ Ψ; x : ↑P ⇓ ↓P⊥
==========================
!x ▶ Ψ,x : ?P ; · ⇓ !P⊥
(1)

and if such rules are added, we can type terms that are essentially not η-long. Moreover, the proof of identity expansion provides us with a transformation of terms comparable to η-expansion, where a variable value is replaced with a thunk of a more complex term depending on its type in the unordered contexts. The rules are:


x →η [λz.(x z)♩	if x : ↑↓N
x →η [π.λy.λz.x (y, z)♩ if x : ↑(P ⊗ Q)
x →η [λ!z.(x !z)♩	if x : ↑!N

!x →η !λz.(!x z)	if x : ?↓N
!x →η !π.λy.λz.!x (y, z) if x : ?(P ⊗ Q)
!x →η !λ!z.(!x !z)	if x : ?!N

when decomposing the result of Lemma 2.2 into small steps. In the following, we will only consider terms in η-long normal form — that is, such that none of the rules above apply and therefore corresponding to a proof with atomic identity axioms.

Cut Elimination and Focusing as Transformations
We now turn to the dynamics of the system, by considering proof transformations and their effect on corresponding terms. As usual, cut elimination is interpreted as a rewrite system implementing computation, and in our system, the focalisation result is interpreted as well, corresponding to a reorganisation that simplifies λπ-terms.
Cut elimination in focused sequent calculi is usually presented as the admissibility of a collection of cut rules. A step of cut reduction consists in having the cut interact with the rules appearing directly above it, either permuting the cuts above said rules, or decomposing the cut into smaller instances. This presentation has several drawbacks, however. Firstly, the “commutative cuts” have no computational meaning, and serve only to permute inference rules around until the next step of computation can take place. Moreover, this small-step nature of the reduction almost invariably leads to a failure of strong normalisation for the associated system of reductions.
Since we are interested in the dynamics of cut elimination, we will opt for a very conservative view. We propose that there is only one relevant instance of the cut rule, the one shown in Figure 1:
▶ Ψ; Γ ⇑ N, S	▶ Ψ; Δ ⇓ N⊥
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
▶ Ψ; Γ, Δ ⇑ S
Note that because the calculus enforces maximal synchronous and asynchronous phases, the formulas N and N⊥ are both principal in the premises. In other words, this cut rule represents exactly the principal cases of the cut-elimination argument. To handle the cases where the principal formula is not decomposed, we see the derivation with the non-principal formula as the composition of a context and a subderivation that is again principal. For the sake of readability, we elide the proof terms for the time being: later in this section, we will show the set of reductions that

form the computational content of the following theorems. To ease the notation, we use ▶ Ψ; Γ 🅘 Σ as a shorthand for either ▶ Ψ; Γ ⇓ P or ▶ Ψ; Γ ⇑ S.
The first step is to prove a series of decomposition lemmas based on a case analysis of the structure of derivations. We omit the proof of the most basic lemma, concerning formulas of the shape ↑a.
Lemma 3.1 (Atomic decomposition) For any proof E :: ▶ Ψ; Γ,x : ↑a 🅘 Σ there exists an open derivation G from ▶ Ψ; x : ↑a ⇓ ↓a to ▶ Ψ; Γ,x : ↑a 🅘 Σ.
Lemma 3.2 (Linear decomposition) Any derivation E :: ▶ Ψ; Γ,x : ↑P 🅘 Σ can be decomposed into a derivation F :: ▶ Ψ, Ω; Δ ⇓ P and an open derivation G from
▶ Ψ, Ω; Δ ⇑ · to ▶ Ψ; Γ 🅘 Σ, and this open derivation does not contain an instance of the ! rule between the open hypothesis and the conclusion.
Proof. The proof proceeds by induction on the derivation E. If E ends with a rule that does not focus on x : ↑P in its premise, we place this rule on top of the open derivation G. If the rule focuses on x : ↑P , then this is the desired derivation F, and we are done. At no point do we encounter the ! rule in E, as this rule requires an empty linear context, which is impossible due to the presence of x : ↑P .	2
The requirement that G does not contain instances of the ! rule is important, as it justifies extending the linear context uniformly across the open derivation: If G is an open derivation from ▶ Ψ, Ω; Δ ⇑ · to ▶ Ψ; Γ 🅘 Σ satisfying the requirement, then it is also an open derivation from ▶ Ψ, Ω; Δ, Φ ⇑ · to ▶ Ψ; Γ, Φ 🅘 Σ.
When the formula is of the shape ?P and appears under the name x in the persistent context, we define the multiplicity |x|E of x in a derivation E as the number of times x : ?P is principal in a focus rule in E — how many focus phases are started on x. This requires considering proofs modulo the usual notion of α-equivalence.
Lemma 3.3 (Persistent decomposition) For any proof E :: ▶ Ψ,x : ?P ;Γ 🅘 Σ, either we have E :: ▶ Ψ; Γ 🅘 Σ or there exists a derivation F :: ▶ Ψ, Ω; Δ ⇓ P and an open derivation G from ▶ Ψ, Ω; Δ ⇑ · to ▶ Ψ,x : ?P ;Γ 🅘 Σ, such that |x|G < |x|E.
Proof. Again, we prove this by induction on the given derivation E. Intuitively, we pick a topmost focus rule using x : ?P , yielding the derivation F. The remaining derivation, in which x necessarily has a lower multiplicity, then becomes G.   2
On the basis of these decomposition lemmas, we can complete our cut elimination argument. We state it here simply as a weak normalisation argument, although we expect the calculus to admit a strong normalisation argument as well, given its similarity to the linear substitution calculus [2].
Theorem 3.4 (Cut elimination) The following two cut principles hold in focused
MELL, assuming the derivations D and E are cut-free:
if D :: ▶ Ψ; Γ ⇑ P⊥,S and E :: ▶ Ψ; Δ ⇓ P, there exists F :: ▶ Ψ; Γ, Δ ⇑ S,
if D :: ▶ Ψ,x : ?P ;Γ ⇑ S and E :: ▶ Ψ; · ⇑ P⊥, there exists F :: ▶ Ψ; Γ ⇑ S.
Proof. The first statement is established by induction on the structure of P . Note that by design, both P and P⊥ must be principal in the assumptions, hence the

structure of the formula also forces what the final rule must be in the D and E
derivations.
If P = Q ⊗ R:

D
▶ Ψ; Γ ⇑ Q⊥, R⊥,S 
E1
▶ Ψ; Δ1 ⇓ Q
E2
▶ Ψ; Δ2 ⇓ R

−−−−−−−−−−−−−−−−−−−−−−−−
▶ Ψ; Γ ⇑ Q⊥ O R⊥,S 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
▶ Ψ; Δ1, Δ2 ⇓ Q ⊗ R

we need to construct a derivation F :: ▶ Ψ; Γ, Δ1, Δ2 ⇑ S. We proceed by applying the induction hypothesis on D and E1 to obtain Dj :: ▶ Ψ; Γ, Δ1 ⇑ R⊥, S, and then apply the induction hypothesis again on Dj and E2 to produce the desired derivation for ▶ Ψ; Γ, Δ1, Δ2 ⇑ S.
If P = ↓a:

D
▶ Ψ; Γ,x : ↑a ⇑ S
−−−−−−−−−−−−−−−−−−−−−


−−−−−−−−−−−−−−−−−−

▶ Ψ; Γ ⇑ ↑a, S	E :: ▶ Ψ; y : ↑a ⇓ ↓a
where the second derivation is forced since the grammar disallows atoms without a polarity shift. We need to construct a derivation F :: ▶ Ψ; Γ,y : ↑a ⇑ S: if we were only interested in provability, we could simply reuse D. In order to get the term reductions to behave as expected, we instead reason as follows: by applying Lemma 3.1 on D we obtain an open derivation G from ▶ Ψ, Ω; x : ↑a ⇓ ↓a to ▶ Ψ; Γ,x : ↑a ⇑ S that we compose with E to produce the desired result.
If P = ↓Q⊥:

D
▶ Ψ; Γ,x : ↑Q ⇑ S
−−−−−−−−−−−−−−−−−−−−−−
▶ Ψ; Γ ⇑ ↑Q, S
E
▶ Ψ; Δ ⇑ Q⊥
−−−−−−−−−−−−−−−−
▶ Ψ; Δ ⇓ ↓Q⊥

we need to construct a derivation F :: ▶ Ψ; Γ, Δ ⇑ S. By applying Lemma 3.2 on D, we obtain a derivation Dj :: ▶ Ψ, Ω; Γj ⇓ Q and an open derivation G from ▶ Ψ, Ω; Γj ⇑ · to ▶ Ψ; Γ ⇑ S. Then by the induction hypothesis on Dj and E we produce a derivation of ▶ Ψ, Ω; Γj, Δ ⇑ · and compose it with G to obtain a derivation of ▶ Ψ; Γ, Δ ⇑ S. Notice that the linear context has changed from Γj to Γj, Δ, but this extension of the linear context is done uniformly across the open derivation, and hence is not a problem.
If P = !Q⊥:

D
▶ Ψ,x : ?Q;Γ ⇑ S
−−−−−−−−−−−−−−−−−−−−−−
▶ Ψ; Γ ⇑ ?Q, S
E
▶ Ψ; · ⇑ Q⊥
−−−−−−−−−−−−−−
▶ Ψ; · ⇓ !Q⊥

we can directly apply the second induction hypothesis on D and E.
For the second statement, we proceed by induction on the multiplicity |x|D of
x : ?P in D. Given the following two derivations:


D
▶ Ψ,x : ?Q;Γ ⇑ S
E
▶ Ψ; · ⇑ Q⊥

we need to construct a derivation F :: ▶ Ψ; Γ ⇑ S. By applying Lemma 3.3 on
D we can obtain a derivation Dj :: ▶ Ψ, Ω; Δ ⇓ Q and an open derivation G from
▶ Ψ, Ω; Δ ⇑ · to ▶ Ψ,x : ?Q;Γ ⇑ S. By the first induction hypothesis on Dj and E, we produce a derivation of ▶ Ψ, Ω; Δ ⇑ · and compose it with G to obtain a derivation of ▶ Ψ,x : ?Q;Γ ⇑ S in which x has a lower multiplicity, and finally by applying the second induction hypothesis, we get the desired derivation.	2
In order to describe the computational behaviour of the lemmas and of the procedure specified by the proof of cut elimination, within the language of λπ, we introduce the following notations for term contexts and value contexts respectively:
T ::= − | λx.T | x V | T p | t V | π.T | λ!x.T | !x V 
V ::= ∼ | [T ♩ | (V, q) | (q, V ) | !T

We use this definition to give two kinds of contexts, depending on whether the “hole” is − or ∼. We use T ⟨t⟩ and T [p] for the result of substituting t and p for − and ∼ respectively, where the difference in brackets indicates which kind of hole is intended. The decomposition lemmas can now be stated in terms of the contexts:
Corollary 3.5 (Term decomposition) Well-typed λπ-terms are such that:
a term t containing a free, linearly occurring variable x can be decomposed either into a context T ⟨−⟩ and a value p such that t = T ⟨x p⟩, or into a context T [∼], such that t = T [x].
for a term t and a free exponential variable x, either x does not occur in t or
t can be decomposed into a context T ⟨−⟩ and a value p such that t = T ⟨!x p⟩.
When reducing the term (λx.t) [u♩, we first decompose t into T ⟨x p⟩, then we create the inner cut (u p), and finally we plug it inside the context again, yielding T ⟨u p⟩ — note that this amounts to substituting u for x inside t. Written using contexts, the full set of reduction rules for λπ is thus:

where fv(t) denotes, as usual, the set of all free variables of t. The rewrite system obtained bears a striking resemblance to the linear substitution calculus defined by Accattoli et al. [2], which is itself based on ideas from linear logic and proof-nets. We leave the investigation of this connection as future work: for the purposes of this presentation, it suffices to note that the above reductions for λ and λ! implement the usual notion of capture-avoiding substitution. We can therefore summarise reduction in λπ using implicit substitution, which yields a system containing the following

four rules:

(2)

and we observe that the first two correspond to the basic polarised subsystem of MELL, while the two others match the multiplicative and exponential subsystems respectively. Note that we consider here the typed fragment of the language — in the untyped case, more terms would be accepted and a thunk [u♩ could be plugged inside a value.
Beyond cut elimination, a focused and explicitly polarised system such as ours can be given another form of dynamics, which does not represent computation as β-reduction does, but rather corresponds to a form of simplification of terms. Indeed, explicit polarity shifts can be used to introduce delays, compounds formed by a pair of opposite shifts, that can break a focusing phase or prevent maximal inversion. This can be interpreted as placing a piece of computation across a value, splitting this value in two: removing a delay therefore contributes to the production of a simpler, more compact term, with a different computational behaviour.
From the opposite viewpoint, it is clear that any unfocused proof can be mapped to a delayed, focused proof. With this, we can now restate the focalisation result in terms of the admissibility of delay elimination [8,24], rather than state it in terms of completeness with respect to an unfocused reference system. In stating the result, we use the notion of formula context, written ξ{−}. The formula ξ{P } should be interpreted as a formula (positive or negative) with a linear occurrence of the subformula P . The outer context ξ{−} then represents the path through ξ{P } on which this subformula appears.
Lemma 3.6 (Positive delay elimination) For any D :: ▶ Ψ; Γ,x : ↑ξ{↓↑P } ⇑ S
cut-free, there exists a derivation E :: ▶ Ψ; Γ,x : ↑ξ{P } ⇑ S.
Proof. Before we prove this statement, we will make some simplifying assumptions. First, note that the nature of the formula in the context ξ{−} only becomes relevant when the formula becomes focused. We will therefore assume that ξ{↓↑P } contains only positive formulas between the topmost connective and the location of the subformula ↓↑P . When ξ{↓↑P } is selected as the focus — which we may assume appears as final rule in D — we can thus decompose the derivation D into a subderivation Dj :: ▶ Ψ; Γj ⇓ ↓↑P and an open derivation G from ▶ Ψ; Γj ⇓ ↓↑P to
▶ Ψ; Γ, ↑ξ{↓↑P } ⇑ ·. Note that as G can only split the context, we must haveΓ = Γj, Δ for some context Δ. Furthermore, composing any proof ▶ Ψ; Γjj ⇓ Q with this open derivation will yield a proof of ▶ Ψ; Γjj, Δ ⇓ ξ{Q}.
By appealing to inversion twice on Dj, we get a derivation Djj :: ▶ Ψ; Γj, ↑P ⇑ · and by applying the linear decomposition lemma, this can be decomposed into a derivation F :: ▶ Ψ, Ψj; Γjj ⇓ P and an open derivation Gj from ▶ Ψ, Ψj; Γjj ⇑ · to ▶ Ψ, Ψj; Γj ⇑ · so that can now string together these derivations. From F and G, we get a derivation of ▶ Ψ, Ψj; Γjj, Δ ⇓ ξ{P }, and hence a derivation of ▶ Ψ, Ψj; Γjj, Δ, ↑ξ{P } ⇑ · that we

compose with Gj to get ▶ Ψ; Γ, ↑ξ{P } ⇑ ·, where we use the equality Γ = Γj, Δ.	2
Lemma 3.7 (Negative delay elimination) For any D :: ▶ Ψ; Γ ⇑ S1, ξ{↑↓N }, S2
cut-free, there exists a derivation E :: ▶ Ψ; Γ ⇑ S1, ξ{N }, S2.
Proof. The proof proceeds in a similar manner, and we only sketch the argument. First, we may assume that ξ{↑↓N } is the first formula in the inversion context, and that only negative formulas occur on the path to ↑↓N . Then we do a decomposition until ↑↓N is placed in the unordered context, and find the subderivation where it is focused again. This subderivation must immediately decompose N , and hence we can transport this decomposition down, and compose it with the context ξ{−} to get the desired proof.	2
The focalisation result is obtained by iterated application of the previous lemmas: in particular, removing negative delays forces O connectives to be decomposed eagerly, and removing positive delays groups instances of the ⊗ rule. On a computational level, the procedures specified by the proofs of these two lemmas correspond to some reorganisation of a λπ-term that removes an unnecessary intermediate name.
In order to precisely described the effect of delay elimination on terms, we need to refine our language of contexts to consider monopolar contexts, that can only contain one pole, which is a layer of contiguous negative or positive connectives:
A ::= − | (A, p) | (p, A)
B ::= − | λx.B | λ!x.B | π.B

Using these notions of contexts, we can precisely describe the effect of positive and negative delay elimination respectively:
y A⟨[λx.T ⟨x p⟩♩⟩	→	T ⟨y A⟨p⟩⟩ λx.T ⟨x [B⟨y p⟩♩⟩	→	B⟨T ⟨y p⟩⟩
embodied by rewrite rules that can apply anywhere inside a T context. Observe that in the basic case, where A is empty, the first rule is just y [λx.T ⟨x p⟩♩ → T ⟨y p⟩, which corresponds to the start of a focus phase immediately aborted.
Fragments of Linear Logic and their λ-calculi
We have seen in the previous section how the focused sequent calculus for polarised MELL corresponds to a refined linear λ-calculus. However, it may be easier to grasp the expressivity of the λπ-calculus by considering subcalculi generated by specific subsets of valid formulas and sequents, or restrictions on rules.
Purely linear fragment. The simplest fragment that can be considered is obtained by ignoring the exponentials and the persistent context. This yields a subset of λπ that can be related to the purely linear λ-calculus — that is, the fragment of the λ-calculus where variables must be used exactly once. More precisely, there is a relatively simple encoding of the linear version of the λ-calculus proposed by Herbelin as an interpretation of the LJT focused intuitionistic sequent calculus [12].

This calculus has lists of arguments in applications, and is based on the following syntax:
t, u ::= x k | λx.t | t k	k, m ::= ε | t :: k
where ε represents an empty list of arguments, needed to recover the simple variable x, encoded here as x ε, and :: is the list constructor. The type system for this calculus, in its linear form, is given by the linear variant of LJT that we call IMLLT, where two kinds of sequents are distinguished: we write Γ ▶ N for an unfocused sequent and Γ, [N ] ▶ a for a sequent focusing on the left on N , where the right-hand side is limited to an atom because we consider η-long terms. The encoding is based on a simple translation of unpolarised intuitionistic linear formulas, that we denote by A or B:    a) = ↑a	 A −◦ B) = ↑ A)⊥ O B)
which can be extended pointwise to contexts. The most important part of the
translation relates sequents of IMLLT to sequents of our system system where the persistent context is always empty and thus omitted:
Γ ▶ A  ~JT	▶ ↑ Γ)⊥ ⇑ A)	Γ, [B] ▶ a	~JT	▶ ↑ Γ)⊥,c : ↑a ⇓ B)⊥
where by convention we choose c as the name of the atomic right-hand side of any focused IMLLT sequent — this variable will represent the empty list. The translation of the typing derivations is then based on these translations, as follows:

−−−−−−−−−−−
[a] ▶ ε : a
~JT	−−−−−−−−−−−−−−−−


c ▶ c : ↑a ⇓ ↓a



Γ, [B] ▶ k : a
−−−−−−−−−−−−−−−−−−−
Γ,x : B ▶ x k : a


Γ,x : A ▶ t : B
−−−−−−−−−−−−−−−−−−−−
Γ ▶ λx.t : A −◦ B


Γ ▶ t : B	Δ, [C] ▶ k : a
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
Γ, Δ, [B −◦ C] ▶ t :: k : a


~JT




~JT




~JT
p ▶ ↑ Γ)⊥,c : ↑a ⇓ B)⊥
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
x p ▶ ↑ Γ)⊥,x : ↑ B)⊥,c : ↑a ⇑ · 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
λc.(x p) ▶ ↑ Γ)⊥,x : ↑ B)⊥ ⇑ ↑a
u ▶ ↑ Γ)⊥,x : ↑ A)⊥ ⇑ B)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
λx.u ▶ ↑ Γ)⊥ ⇑ ↑ A)⊥, B)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
π.λx.u ▶ ↑ Γ)⊥ ⇑ ↑ A)⊥ O B)
u ▶ ↑ Γ)⊥ ⇑ B)
−−−−−−−−−−−−−−−−−−−−−−−
[u♩ ▶ ↑ Γ)⊥ ⇓ ↓ B)	p ▶ ↑ Δ)⊥,c : ↑a ⇓ C)⊥
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
([u♩, p) ▶ ↑ Γ)⊥, ↑ Δ)⊥,c : ↑a ⇓ ↓ B) ⊗ C)⊥

where p is the translation of k, and u is the translation of t. The syntax ↑Γ denotes a context Γ where formulas are annotated with a negative shift. This translation turns lists of arguments into right-associated pairs of thunks, and translating abstractions requires the π operator. There is therefore a matching between these constructs, and we can compose such terms in the expected way with the cut rule, corresponding to the main head cut of LJT in its linear form:
u ▶ ↑ Γ)⊥ ⇑ N )	p ▶ ↑ Δ)⊥,c : ↑a ⇓ N )⊥

Γ ▶ t : N	Δ, [N ] ▶ k : a
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
Γ, Δ ▶ t k : a
~JT
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
u p ▶ ↑ Γ)⊥, ↑ Δ)⊥,c : ↑a ⇑ · 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
λc.(u p) ▶ ↑ Γ)⊥, ↑ Δ)⊥ ⇑ ↑a



so that reduction in this linear λ-calculus is simulated by reduction in our focused MELL system. More specifically, the reduction system →JT that we use for IMLLT is based on implicit substitution rather than the original explicit ones in LJT [12]:
(λx.t) (u :: k)	→JT	t{u/x} k

(λx.t) ε	→JT	t
(t k) m	→JT	t (k @ m)
(3)

where @ denotes the concatenation of lists. In the λπ-calculus, we consider reduction rules in their compact form, as shown in (2). As a result, we obtain the simple simulation of this linear λ-calculus in λπ described by the theorem below.
Theorem 4.1 If t ~JT u and t →JT v there is a w such that v ~JT w and u →∗ w.
Proof. We proceed by structural induction on the term t, extending the statement to handle the translation of lists as λπ-terms. In the base case, it is the empty list and none of the reduction rules apply, so we are done. In general, all cases except for the redex t k directly rely on the induction hypothesis. In this last case, we consider possible reductions, so that the compound reductions:
λc.((π.λx.t) ([u♩, q))	→∗	λc.(t{u/x} q) λc.((λx.t) c)	→∗	λc.t{c/x}
λc.((λd.u p) q)	→∗	λc.(u p{q/d})
are just the translations of the reduction rules shown in (3). The first reduction is simple and relies on the decomposition of the pair encoding the :: constructor, and a substitution. The second reduction just performs a substitution, but one should note that after reduction, c is no longer a right-hand side marker, but simply a renaming of x. Finally, the last reduction relies on the encoding of lists as right-associated pairs, so that p{q/d} is exactly the encoding of k @ m in λπ.	2
Notice that this encoding translates primitive constructs in λ into compound constructs of the λπ-calculus. Some terms in our calculus have no equivalent in the interpretation of IMLLT: we have captured here only an intuitionistic fragment of MLL. This can be seen quite clearly in our translation, as it corresponds to the presence of the single variable c with a type of the shape ↑a in the context, which represents the unique right-hand side of a sequent. We can capture a larger, more classical fragment of the calculus, but makes the embedding slightly more complex. Although we could study encodings of a linear variant of the λμ-calculus, we choose to use exponentials to represent the full sequent-based variant of λμ.
Exponential fragment. Beyond the purely linear fragment discussed above, an obvious subsystem of interest is the one where no polarity shifts appear, related to LLP [15], and one might want to push this further and try to eliminate the need for a linear context altogether. This is problematic since the axiom rule applies only when the linear context is not empty, but it is possible to work around this problem by considering the exponential axiom rule from (1) obtained from the identity expansion result:
========================
!x ▶ Ψ,x : ?P ⇓ !P⊥

However, it is not possible to avoid entirely polarity shifts in our system, since atoms are not handled without them. We consider the λμ-calculus of Herbelin [13], which is an interpretation of LKT, and can be obtained by adding the control rules from λμ into the LJT system and term assignment. Due to the polarised setting in MELL, we use an explicitly polarised version of this calculus, where the μ and naming rules are reflected on types by shifts — that we write ] and ² to distinguish them from the shifts of MELL. The translation of formulas is then defined as:
 a) = ?↓a	 P ⊃ N ) = ? P )⊥ O N )	 ]N ) = ! N )	 ²P ) = ? P )
The LKT system has two kinds of sequents, just as LJT, which are obtained by adding the context Δ of other right-hand sides. Since we used polarised formulas, the context Γ in the left-hand side always contains formulas of the shape ]N , just as Δ. Sequents are then encoded using the translation of formulas as follows:
Γ ▶ N | Δ	~KT	▶ Γ)⊥, ? Δ) ⇑ N )
Γ, [N ] ▶ a | Δ	~KT	▶ Γ)⊥, ? Δ),c : ?↓a ⇓ N )⊥
where focused MELL sequents are written without a linear context, since it will always be empty in this translation. Indeed, polarity shifts, needed to introduce formulas in the linear context, are used only on atoms and therefore they cannot be treated out of the axiom rule. The control rules of the calculus, concerning μ and naming, are translated as follows in our system:

Γ ▶ t | α : ]N, Δ
−−−−−−−−−−−−−−−−−−−−−
Γ ▶ μα.t : ²]N | Δ

~KT
u ▶ Γ)⊥, ? Δ),c : ?! N ) ⇑ · 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
λ!c.u ▶ Γ)⊥, ? Δ), ⇑ ?! N )




Γ ▶ t : N | α : ]N, Δ
−−−−−−−−−−−−−−−−−−−−−−−−
Γ ▶ [α] t | α : ]N, Δ


~KT
u ▶ Γ)⊥, ? Δ),c : ?! N ) ⇑ N )
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
!u ▶ Γ)⊥, ? Δ),c : ?! N ) ⇓ ! N )
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
!c !u ▶ Γ)⊥, ? Δ),c : ?! N ) ⇑ · 

where c is the name given to the marker labelled α in LKT, and u is the translation of t. The other rules are translated in a way very similar to the encoding for LJT, but they all have the generalised treatment of the right-hand side context Δ:


−−−−−−−−−−−−−−−−−−
Γ, [a] ▶ ε : a | Δ

Γ, [N ] ▶ k : a | Δ
~KT	=================================

!c ▶ Γ)⊥, ? Δ),c : ?↓a ⇓ !↑a
p ▶  Γ)⊥,x : ? N )⊥, ? Δ),c : ?↓a ⇓  N )⊥
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

−−−−−−−−−−−−−−−−−−−−−−−−−
Γ,x : ]N ▶ x k : a | Δ
~KT
!x p ▶  Γ)⊥,x : ? N )⊥, ? Δ),c : ?↓a ⇑ · 
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
λ!c.(!x p) ▶ Γ)⊥,x : ? N )⊥, ? Δ) ⇑ ?↓a



Γ,x : ]N ▶ t : M | Δ
−−−−−−−−−−−−−−−−−−−−−−−−−−
Γ ▶ λx.t : ]N ⊃ M | Δ


~KT
u ▶  Γ)⊥, ? Δ),x : ? N )⊥ ⇑  M )
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
λ!x.u ▶  Γ)⊥, ? Δ) ⇑ ? N )⊥, M )
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
π.λ!x.u ▶ Γ)⊥, ? Δ) ⇑ ? N )⊥ O M )

Γ ▶ t : N | Δ	Γ, [M ] ▶ k : a | Δ
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
Γ, []N ⊃ M ] ▶ t :: k : a | Δ

~KT

u ▶ Γ)⊥, ? Δ),c : ?↓a ⇑ N )
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
!u ▶ Γ)⊥, ? Δ),c : ?↓a ⇓ ! N )	p ▶ Γ)⊥, ? Δ),c : ?↓a ⇓ M )⊥
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
(!u, p) ▶ Γ)⊥, ? Δ),c : ?↓a ⇓ ! N ) ⊗ M )⊥

Observe that the left implication rule is compound in our presentation of this calculus, but so is the translation, in the same way. The key idea here is that more than a single right-hand side marker can be used in a single sequent, due to the classical setting. But in the λπ-calculus itself, control does not need to use these tools: it is the consequence of the shape of typing rules, and in particular of the continuation behaviour of the focus rule. Indeed, if a variable of type ↑P is available, it can be applied to a value typed by P itself in a focused phase. The continuation behaviour of variable application is well illustrated by the a special case of positive delay elimination:
y [λx.T ⟨x p⟩♩  →	T ⟨y p⟩
which can be read as y [λx.t♩ → t{y/x}, so that we see t using the name of the variable to which it was given as argument.
Finally, the question of simulating the reduction of the λμ-calculus using this encoding is more complex than in the purely linear case. Indeed, the reduction rule for μ is performing a relatively complex operation:
(μα.t) k	→KT	μα.t{[α](u k)/[α] u}
that can be observed in λπ if the proper cut and shift rules are introduced, but these yield problems concerning the preservation of types of different subterms during the reduction process.
Conclusion and Future Work
We presented a Curry-Howard interpretation of focused MELL, with a novel proof of cut elimination based on reducing cuts at a distance. The variant of the λ-calculus obtained is more similar to the usual λ-calculus than other calculi based on sequent calculi and it offers a simple syntax for MELL proofs. Moreover, this system has connections to some well-known variations of the λ-calculus, and its reduction simulates in one step the usual notion of β-reduction. The investigation of the computational meaning of a focused cut elimination is important, as it relates to the question of evaluation strategies and has a nice proof-theoretic behaviour.
As mentioned, the system of reductions we present bears a striking resemblance to that of the linear substitution calculus, which employs a similar notion of reduction at a distance. It would be interesting to observe how deep this similarity is, and whether the LSC can be generalised based on the proof-theoretic approach presented

here. In a similar vein, it would be interesting to have a computational interpretation of focused proofs in the presence of the remaining connectives of linear logic, in particular the additives, which are known to introduce a notion of case analysis. Richer logics could also be considered, such as μMALL [5], where induction and coinduction are supported directly in an elegant, proof-theoretic way. The use of fixpoints as alternative to persistent variables yields many questions, concerning for example the use of this system as a programming language. In terms of language it would also, of course, be interesting — and surely straightforward — to extend this interpretation to second-order quantifiers, reaching the expressivity of System F.
Finally, it is well-known that using delays, many other calculi can be represented as appropriately polarised fragments of a strongly focused sequent calculus. This is seen for example in [18] where LJT and LJQ are both shown to be representable as fragments of LJF. Given the generality of our calculus, it is possible that it could serve as a lingua franca for the large variety of classical λ-calculi found in the literature. Exploring such a possibility will pinpoint the general position of linear logic in the field, and highlight how it provides a crucial tool in the understanding of computational phenomena.
Acknowledgement
The authors would like to thank the anonymous reviewers for their helpful and thorough comments on a previous draft.

References
	Samson Abramsky. Computational interpretations of linear logic. Theoretical Computer Science, 111:3–57, 1993.
Beniamino Accattoli, Eduardo Bonelli, Delia Kesner, and Carlos Lombardi.	A nonstandard standardization theorem. In S. Jagannathan and P. Sewell, editors, POPL’14, pages 659–670, 2014.
Beniamino Accattoli and Ugo Dal Lago. Beta reduction is invariant, indeed. In T. Henzinger and
D. Miller, editors, CSL-LICS’14, 2014.
	Jean-Marc Andreoli. Logic programming with focusing proofs in linear logic. Journal of Logic and Computation, 2(3):297–347, 1992.
Dabid Baelde and Dale Miller. Least and greatest fixed points in linear logic. In N. Dershowitz and
A. Voronkov, editors, LPAR’07, volume 4790 of LNCS, pages 92–106, 2007.
	Gianluigi Bellin and Philip Scott. On the pi-calculus and linear logic. Theoretical Computer Science, 135:11–65, 1994.
Gavin Bierman. On Intuitionistic Linear Logic. PhD thesis, University of Cambridge, 1993.
Kaustuv Chaudhuri, Nicolas Guenot, and Lutz Straßburger. The focused calculus of structures. In
M. Bezem, editor, CSL’11, volume 12 of LIPIcs, pages 159–173, 2011.
Pierre-Louis Curien and Hugo Herbelin. The duality of computation. In ICFP’00: Proceedings of the fifth ACM SIGPLAN international conference on Functional programming, pages 233–243, 2000.
Roy Dyckhoff and St´ephane Lengrand. LJQ: a strongly focused calculus for intuitionistic logic. In
A. Beckmann, U. Berger, B. Lo¨we, and J. Tucker, editors, CiE’06, volume 3988 of LNCS, pages 173–185, 2006.
Jean-Yves Girard. Linear logic. Theoretical Computer Science, 50:1–102, 1987.

Hugo Herbelin. A λ-calculus structure isomorphic to Gentzen-style sequent calculus structure. In
L. Pacholski and J. Tiuryn, editors, CSL’94, volume 933 of LNCS, pages 61–75, 1994.
	Hugo Herbelin. S´equents qu’on calcule: de l’interpr´etation du calcul des s´equents comme calcul de lambda-termes et comme calcul de strat´egies gagnantes. PhD thesis, Universit´e Paris 7, 1995.
	Delia Kesner and St´ephane Lengrand. Resource operators for the λ-calculus. Information and Computation, 205(4):419–473, 2007.
	Olivier Laurent. E´tude de la polarisation en logique. Th`ese de doctorat, Universit´e Aix-Marseille II, 2002.
	Olivier Laurent. Polarized proof-nets and λμ-calculus. Theoretical Computer Science, 290(1):161–188, 2003.
	Paul Blain Levy. Call-by-push-value: Decomposing call-by-value and call-by-name. Higher-Order and Symbolic Computation, 19(4):377–414, 2006.
Chuck Liang and Dale Miller. Focusing and polarization in intuitionistic logic. In J. Duparc and T. A. Henzinger, editors, CSL’07, volume 4646 of LNCS, pages 451–465. Springer, 2007.
Guillaume Munch-Maccagnoni. Focalisation and classical realisability. In E. Gr¨adel and R. Kahle, editors, CSL’2009, volume 5771 of LNCS, pages 409–423, 2009.
	Michel Parigot. λμ-calculus: An algorithmic interpretation of classical natural deduction. In LPAR’92, volume 624 of LNCS, pages 190–201, 1992.
Robert J. Simmons. Structural focalization. ACM Trans. Comput. Log., 15(3):21:1–21:33, 2014.
Philip Wadler. A syntax for linear logic. In S. Brookes, M. Main, A. Melton, M. Mislove, and D. Schmidt, editors, MFPS’93, volume 802 of LNCS, pages 513–529, 1993.
Philip Wadler. Propositions as sessions. Journal of Functional Programming, 24(2-3):384–418, 2014.
	St´ephane Zimmermann. Vers une Ludique Diff´erentielle. Th`ese de doctorat, Universit´e Paris Diderot, 2013.
