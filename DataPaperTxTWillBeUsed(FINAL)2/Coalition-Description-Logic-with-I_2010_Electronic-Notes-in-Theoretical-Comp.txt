

Electronic Notes in Theoretical Computer Science 262 (2010) 231–248
www.elsevier.com/locate/entcs
Coalition Description Logic with Individuals
I˙nan¸c Seylan1
KRDB Research Centre, Free University of Bozen-Bolzano
Wojciech Jamroga2
Individual and Collective Reasoning Group, University of Luxembourg

Abstract
Coalitional Description Logic [17] is a product style combination of Coalition Logic and the description logic ALC. It enables reasoning about agents’ ability to influence first-order structures. In this paper, we extend the logic with nominals, i.e., names of individuals including those of agents to define more complex terms for coalitions. This extended language allows one to express surprisingly sophisticated properties because it provides a way to reason about how agents can influence themselves. After introducing the new logic formally, we show that its satisfiability problem is still decidable in NEXPTIME. We prove it constructively by proposing a tableau.
Keywords: strategic logic, description logic, multi-agent systems, tableau


Introduction
Coalition logic (CL) [14,15] formalizes the ability of groups of agents to achieve certain outcomes in strategic games. The central operator of the logic is [A], with [A]ϕ meaning that group of agents A has a strategy to achieve an outcome state where ϕ holds. On the other hand, description logics (DLs) are logical formalisms for representing the knowledge of an application domain in a structured way [2]. More precisely, DLs allow to describe classes, assign individuals to these classes, and define binary relations on individuals. The importance of DLs lies in the fact that they are decidable fragments of first-order logic and they have well developed practical decision procedures. Moreover, they comprise the formal basis of the Semantic Web ontology languages [10].

1 Email: seylan@inf.unibz.it
2 Email: wojtek.jamroga@uni.lu

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.04.017

In [17], we proposed a product style combination of the description logic ALC with coalition logic, that allowed for application of modal operators to both formulas and concepts. Still, the combination kept the agent and the concept layers pretty much separated; in particular, one could not use the first-order elements of DL to specify how agents and their groups can influence themselves. In this paper, we make the first step to overcome the drawback: we extend the language of concepts with names of individuals (including agents), and we allow for more complex terms to define coalitions. This simple extension allows to express surprisingly sophisticated properties, as the examples in Section 2.4 demonstrate. Furthermore, we extend the satisfiability procedure from [17] to handle the new language, and we establish complexity bounds for the satisfiability problem.
It is worth noting that we do not presuppose any general relationship between agents’ first-order properties and their temporal abilities in our logic. In particular, if a formula is satisfiable (resp. valid) then one can replace any occurrence of an agent name in the formula with any other agent name, and the resulting formula will be still satisfiable (resp. valid). Note that this symmetry of agents’ abilities with respect to the actual actor is a general feature of CL, and not specifically of our combination of CL and description logic. On the other hand, agents used in coalitions and agents used as individuals are semantically related: given a particular model (or a particular theory), we cannot shuffle agent names without changing the truth values of formulae anymore.




The Logic
In this section we define our logic formally. We begin by disentangling the syntax and semantics of coalitional expressions: in all the existing literature on strategic logics, no difference is made between sets of “real” agents and the descriptions that refer to them (cf. [15,1] and many others). Instead, it is assumed that the agents themselves occur in formulae of the logics. Such an abuse of formal notation seems acceptable when we refer to agents only in the scope of strategic operators (to name who is supposed to achieve the property in question). In our case, however, we want also to reason about agents (resp. coalitions) in the same way as about other individuals (resp. concepts). That is, we want to enjoy the benefits of first- order reasoning with respect to agents and their sets, and make sure that we do it correctly.
After defining the syntax of coalitional expressions (and formulas in which those can occur), we extend our semantics from [17] to handle the new, more sophisticated concepts and agent expressions. Finally, we present some intuitive examples, and show that every formula of CLALCO can be equivalently transformed to a more rigid form, which will prove convenient when defining our decision procedure in further sections.

Syntax
In order to specify properties of agents and coalitions, we assume the following sets of names: a countable set NC of concept names that includes at least Agt (the name for the “grand coalition” of agents), a countable set NR of role names, a finite nonempty set NI of individual names, and a finite nonempty set NA ⊆ NI of agent names. The set of concepts is the smallest set satisfying the following conditions:
T is a concept (top concept), and every concept name is a concept;
If i1,..., in, n ≥ 0, are individual names then {|i1,,... ,,in|} is a concept (enumer- ation of individuals);
If C is a concept and R is a role name then 6R.C and ER.C are concepts;
If C and D are concepts then C H D, C H D, and C\\D are also concepts;
If C is a concept and A is a coalitional term (defined further) then [A]C and ⟨A⟩C
are concepts.
A coalitional term is a concept that includes only names from NA∪{Agt}. Therefore, coalitional terms contain no concept names (except Agt), no role names, and no ’non-agent’ individual names.
Additionally, we define ⊥ ≡ {||} (bottom concept), and чC ≡ T\\C. Con- cept names, T, and concepts of type {|i1,,... ,,in|} form the set of atomic concepts. Also, for any individual names i1,..., in ∈ NI , we will use the following notation: enumterm({i1,..., in}) = {|i1,,... ,,in|}, and conversely, enumset ({|i1,,... ,,in|}) =
{i1,..., in}. When we give the semantics it will be clear that no matter how we choose to enumerate a given set of individual names by enumterm(), they will yield
equivalent interpretations.
Now we can define the set formulas of CLALCO as follows: if C, D are concepts then C ± D and C = D are (atomic) formulas; if ϕ, ψ are formulas then чϕ, ϕ Λ ψ, ϕ V ψ are formulas; if ϕ is a formula and A is a coalitional term then [A]ϕ, ⟨A⟩ϕ are also formulas. 3
Thus, CLALCO extends the description logic ALC0 with modal operators [A], ⟨A⟩ for reasoning about how agents can transform the world, but also with means to single out agents from concepts (agent names, special concept Agt), and with con- cepts [A]C, ⟨A⟩C that group objects depending on how they can be transformed. On the other hand, CLALCO extends coalition logic with elements of dyadic first-order logic, typical for description logics.

Models
A model for CLALCO is a quadruple of the form M = ⟨Agt, W, E, f⟩, where Agt is a finite nonempty set of agents, W is a nonempty set of possible worlds (states), and E, f associate a playable effectivity function Ew and an ALC0-interpretation f(w) with every world w ∈ W .
An effectivity function is defined as E  : 2Agt → 22W , i.e., a function that assigns

3	We will sometimes use [i1,..., in] (resp.	⟨i1,..., in⟩) as a shorthand for [{|i1 , ... ,in|}] (resp.
⟨{|i1 , ... ,in|}⟩), both in strategic operators and concept constructors.

a set of achievable outcomes V ⊆ W to each coalition A ⊆ Agt. The complement sets for outcomes and coalitions are defined as V = W \ V and A = Agt \ A, respectively. Ew is playable iff it satisfies the following conditions:
Semi-seriality : ∅ /∈ Ew(A), for all coalitions A /= Agt;
Semi-W-completeness: W ∈ Ew(A), for all coalitions A /= Agt;
Semi-outcome-monotonicity : for all V ⊆ U ⊆ W and for all A /= Agt, if
V ∈ Ew(A) then U ∈ Ew(A);
Semi-superadditivity : for all V , U , A1, and A2 such that A1 ∩ A2 = ∅ and
A1 ∪ A2 /= Agt, if V ∈ Ew(A1) and U ∈ Ew(A2) then V ∩ U ∈ Ew(A1 ∪ A2);
Agt-maximality: for all V , if V /∈ Ew(∅) then V ∈ Ew(Agt);
Regularity : for all V, A, if V ∈ Ew(A) then V /∈ Ew(A).
Additionally, we call an effectivity function semi-playable iff it satisfies conditions (i)-
Although the standard definition of playability does not make any exceptions for the grand coalition, we do not lose anything by the above definition of playability because semi-playability together with Agt-maximality and regularity is equivalent to (standard) playability [15].
An ALC0-interpretation f(w) = ⟨ΔI(w), ·I(w)⟩, includes a nonempty set ΔI(w)
called the domain of state w, and a mapping ·I(w) that assigns each concept name C with a subset CI(w) of ΔI(w), each role name R with a binary relation RI(w) on ΔI(w), and each individual name i with an element i = iI(w) in ΔI(w). We make the following semantic assumptions wrt ALC0-interpretations:
Constant domain: ΔI(w) = ΔI(v) for any w, v ∈ W ;
Global individual names: iI(w) = iI(v) for all i ∈ NI and w, v ∈ W ;
Unique individual names: iI(w) /= iI(w) for two distinct individual names i1, i2 ∈
1	2
NI and all w ∈ W ;
Correct interpretation of agent names: AgtI(w) = Agt and {i | i = aI(w) for some
a ∈ NA} = Agt for every w ∈ W .
As a consequence of our assumptions, agents are a part of domain in every state, and can be referred to like all other concepts and individuals. Moreover, the interpre- tation of coalitional terms does not change from state to state, and the cardinality of the set of agents Agt must be the same as the number of agent names given in NA. Note that we have chosen to make the unique individual names assumption because otherwise two different agent names inside modal operators might denote the same agent, leading to a peculiar effect.
In short, models of CLALCO combine information about possible states of reality (W ), and how they can be transformed (E), and by whom (Agt), with first-order structures that characterize each possible world separately.


Semantics
The interpretation f(w) defines the denotation of individual names and primitive concepts in state w. We extend it to concept descriptions in a similar way to [17]:

TI(w) = ΔI(w),
{|i1,,... ,,in|}I(w) = {iI(w),..., iI(w)},
1	n
(C H D)I(w) = CI(w) ∩ DI(w),
(C H D)I(w) = CI(w) ∪ DI(w),
(C\\D)I(w) = CI(w) \ DI(w),
(6R.C)I(w) = {δ ∈ ΔI(w) | 6δ' (⟨δ, δ'⟩∈ RI(w) → δ' ∈ CI(w))},
(ER.C)I(w) = {δ ∈ ΔI(w) | Eδ' (⟨δ, δ'⟩∈ RI(w) Λ δ' ∈ CI(w))},
([A]C)I(w) = {δ ∈ ΔI(w) | C  M ∈ Ew(AI(w))},
(⟨A⟩C)I(w) = {δ ∈ ΔI(w) | W \ C  M /∈ Ew(AI(w))},
where C  M = {w ∈ W | δ ∈ CI(w)} is the set of states that δ belongs to the interpretation of concept C.
Now we define the satisfaction relation |= for CLALCO as follows:


M,w |= C ± D iff CI(w) ⊆ DI(w), M,w |= C = D iff CI(w) = DI(w), M,w |= чϕ  iff M,w /|= ϕ,
M,w |= ϕ Λ ψ iff M,w |= ϕ and M,w |= ψ, M,w |= ϕ V ψ iff M,w |= ϕ or M,w |= ψ, M,w |= [A]ϕ	iff  ϕ  M ∈ Ew(AI(w)),
M,w |= ⟨A⟩ϕ	iff W \ ϕ  M /∈ Ew(AI(w)),


where  ϕ  M = {w ∈ W | M,w |= ϕ} is the set of states that satisfy ϕ in M. We observe that the possibility/necessity of ϕ being true in the next moment can be expressed with operators [Agt], [ ]: [Agt]ϕ can be read as “there is a possible next state for which ϕ holds”, while [ ]ϕ expresses that in every possible next state ϕ is the case.
A formula ϕ is satisﬁable if there exist a model M = ⟨W, E, f⟩ and a state w ∈ W such that M,w |= ϕ. A concept C is satisﬁable if there exist M = ⟨W, E, f⟩ and w ∈ W such that CI(w) /= ∅. Concept D subsumes concept C if CI(w) ⊆ DI(w) for all models M = ⟨W, E, f⟩ and all w ∈ W . Note that concept subsumption and concept satisfiability can be reduced to formula (un)satisfiability. Concept C is satisfiable iff formula ч(C ± ⊥) is satisfiable and concept D subsumes concept C iff formula ч(C ± D) is unsatisfiable. The formula C ± D is clearly equivalent to T ± чC H D, and C = D to T ± (чC H D) H (чD H C). In the remainder of this paper, we will assume without loss of generality that every atomic formula is of the form T± E and we will restrict our attention to satisfiability of formulas.

Examples, Properties, Remarks
In the examples, we will use a1, a2,... for agents’ names, and a1, a2,... for the agents that these names refer to.
Example 2.1 Formula [a]({|a|} ± Happy ) specifies that agent a can make himself happy. We can write similar specifications for coalitions: [a1, a2]({|a1,,a2|} ± Happy ) says that a1 and a2 can make themselves happy if they cooperate. Furthermore, [a1, a2](Agt ± Happy ) states that a1, a2 can make all the agents happy.
Consider formula (AgtH[a]Happy ) ± Happy . Clearly, it says that a cannot make anybody happier than now. Moreover, ⟨Agt\\{|a|}⟩ (AgtH[a]Happy ) ± Happy adds that all the other agents can do nothing to change this sad state of affairs.
Example 2.2 Let Perm stand for the set of permissions to be in a building, and In represent the set of agents that are currently inside. Formula a∈NA [admin]({|a|} ± Perm) Λ [admin]ч({|a|} ± Perm) specifies that the administrator can grant and deny the permission to any agent. Moreover,	a∈NA ч({|a|} ± In) → {|a|} ±
Perm ↔ [a]({|a|} ± In) says that an agent is able to enter the building if, and only
if, he has a permission to do so.
Note that the specifications refer only to the agents’ abilities in the current moment, while it would be rather more appropriate to specify them as invariants of the scenario. This is one of the drawbacks of coalition logic, and a reason why extending our logic with ATL operators [1] seems an interesting avenue for future research.
Example 2.3 Consider a system with a dynamic hierarchy of processes captured by the parent role name, and a dynamic configuration of active processes represented by the concept Active. Formula	a∈NA (Active H [a]чActive) = Eparent.{|a|} says that agents can deactivate exactly those processes they are parents of. Adding a requirement that an agent cannot activate a process without becoming its parent: a∈NA чActive H [a](Active H чEparent.{|a|}) = ⊥ makes for a viable specification
of a hierarchic multi-process system.
In the next sections we will present a procedure that constructs models for such specifications (provided they are satisfiable). Before we go on to presenting our satisfiability algorithm, however, we show that the input formula of the procedure can be given in a slightly simplified form without any loss of generality.
Lemma 2.4 Let A, B be coalitional terms. Every coalitional term in the form [A]B is equivalent to B, i.e., ([A]B)I(w) = BI(w) for every model M and state w. The same holds for ⟨A⟩B.
Proof. ([A]B)I(w) = {δ ∈ ΔI(w) | B  M ∈ Ew(AI(w))} where B  M = {w' ∈ W |

δ ∈ B
δ	δ
I(w')}. Since the interpretation of coalitional terms does not change from state

to state, we get that  B  M = W if δ ∈ BI(w) and ∅ otherwise. By playability of Ew, we have W ∈ Ew and ∅ ∈/ Ew, so ([A]B)I(w) = {δ ∈ ΔI(w) | δ ∈ BI(w)} = BI(w).
The proof for ⟨A⟩B is analogous.	 

A formula is singleton reduced iff every enumeration of individuals not appearing inside a modal operator is of the form {|i|}; difference free iff it does not contain \\; in negation normal form (NNF) iff negation signs appear only in front of atomic formulas, concept names, and enumeration of individuals; and coalitionally simple iff all the coalitional terms it includes are of the form {|a1,,... ,,ak|}, with a1,..., ak ∈ NA.
A formula can be transformed to an equivalent singleton reduced formula by the concept equivalences {|i1,,... ,,in|}≡ {|i1|} H... H {|in|} [2] and {||} ≡ ⊥; to a difference free formula by the equivalence C\\D ≡ CНчD; and to a formula in NNF by making use of de Morgan’s laws, the duality between value restrictions and full existential quantifications, and the duality between modal operators. We denote the NNF of

formula ϕ (resp. concept C) by ч˙ ϕ (resp. we use the following proposition.
ч˙ C). For coalitionally simple formulas,

Proposition 2.5 For every formula ϕ there is an equivalent coalitionally simple formula ϕ', i.e., such that M,w |= ϕ iff M,w |= ϕ' for every M, w. Moreover, ϕ' is at most linearly longer than ϕ, and can be obtained in linear time wrt the length of ϕ and the number of agent names in NA. More precisely, |ϕ'| = O(|ϕ|· |NA|), and it can be obtained in time O(|ϕ|· |NA|).
Proof. We use the following translation scheme:
tr1 replaces every occurrence of Agt in ϕ with enumterm(NA);
tr2 replaces every occurrence of [A]B and ⟨A⟩B with B (recursively, proceeding
from atomic concepts and subformulas to more complex ones);
tr3 replaces (recursively) every occurrence of {|a1,,... ,,an|}Н {|a' ,,... ,,a' |} (where
1	m

ai, a' ∈ NA) with enumterm({a1,..., an}∩ {a' ,..., a'
}), and analogously for

i	1	m
H, \\.
Then, ϕ' = tr3(tr2(tr1(ϕ))) is coalitionally simple and equivalent to ϕ (the proof is straightforward).	 
In fact, we will mainly consider coalitionally simple, singleton reduced, and difference free formulas in negation normal form.
Remark 2.6 We have chosen to interpret the set NA as including the names of existing rather than potential agents. It may seem somewhat restrictive when writ- ing specifications: after we have decided on a precise syntax (including the set of agent names NA), the number of agents is completely fixed in the models of our logic. Alternatively, we could assume a countable set of available agent names, and provide denotations for only a finite subset of those in each particular model. We are planning to explore the possibility in the future.

Hintikka Structures for CLALC0
Decision procedures based on semantic tableaux construct not a model of the given formula, but a structure closely resembling a model, called a Hintikka structure [16]. A Hintikka structure makes use of Hintikka sets [9] which are also called downward

saturated sets in the literature. Some authors prefer using alternative names such as model graph [7] or tableau [11] for referring to the same abstraction of a model. In this section, we specify Hintikka structures for CLALCO-formulas. The proofs showing their equivalence to CLALCO models are omitted for reasons of space but they combine results of [17,11].
For a CLALCO-formula ϕ, denote by
con(ϕ) the set of all CLALCO-concepts occurring in ϕ,
rol(ϕ) the set of all role names occurring in ϕ,
for(ϕ) the set of all subformulas of ϕ,
con¬˙ (ϕ) = con(ϕ) ∪ {ч˙ C | C ∈ con(ϕ)},
fcl(ϕ) = for(ϕ) ∪ {[ ]ϑ | ⟨enumterm(NA)⟩ϑ ∈ for(ϕ)},
ccl(ϕ) = con¬˙ (ϕ) ∪ {[ ]C | ⟨enumterm(NA)⟩C ∈ con¬˙ (ϕ)}∪ {{|i|} | i ∈ NI}.
Definition 3.1 If ϕ is a CLALCO formula, a basic Hintikka structure for ϕ is defined to be a hextuple H = ⟨Σ, Λ, S, L, E, J⟩ such that
Σ is a nonempty set of states,
Λ : Σ → 2fcl(ϕ) maps each state to a set of formulas which is a subset of fcl(ϕ),
S is a map associating with each w ∈ Σ a nonempty set of concept types,
L associates with each state w ∈ Σ a function
Lw : S(w) → 2ccl(ϕ)
that maps each concept type s in S(w) to a set of concepts which is a subset of
ccl(ϕ),
E associates with each state w ∈ Σ a function
Ew : rol(ϕ) → 2S(w)×S(w)
that maps each role R in rol(ϕ) to a set of pairs of concept types from S(w),
J associates with each state w ∈ Σ a function
Jw : NI → S(w)
that maps individual names to concept types in S(w) such that i /= j implies
Jw(i) /= Jw(j), and Jw(i) = Jv(i) for all v ∈ Σ,
there is some wϕ ∈ Σ such that ϕ ∈ Λ(wϕ).
Furthermore, for all w ∈ Σ, s, t ∈ S(w), ϑ, ϑ1, ϑ2 ∈ fcl(ϕ), C, C1, C2 ∈ ccl(ϕ),
R ∈ rol(ϕ), i ∈ NI , it holds that:
(P⊥) ⊥ /∈ Lw(s);
(P¬) if C ∈ Lw(s) then чC /∈ Lw(s), where C is a concept name or of the form {|i|}; (PH) if C1 H C2 ∈ Lw(s) then C1 ∈ Lw(s) and C2 ∈ Lw(s);
(PH) if C1 H C2 ∈ Lw(s) then C1 ∈ Lw(s) or C2 ∈ Lw(s); (P∀) if 6R.C ∈ Lw(s) and ⟨s, t⟩∈ Ew(R) then C ∈ Lw(t);
(P∃) if ER.C ∈ Lw(s) then there is some s' ∈ S such that ⟨s, s'⟩ ∈ Ew(R) and
C ∈ Lw(s');
(Pi) {|i|}∈ Lw(s) iff s = J (i);
(P±) if T± C ∈ Λ(w) then C ∈ Lw(s);
(P/±) if ч(T± C) ∈ Λ(w) then there is some s' ∈ S such that ч˙ C ∈ Lw(s');

(P∧) if ϑ1 Λ ϑ2 ∈ Λ(w) then ϑ1 ∈ Λ(w) and ϑ2 ∈ Λ(w); (P∨) if ϑ1 V ϑ2 ∈ Λ(w) then ϑ1 ∈ Λ(w) or ϑ2 ∈ Λ(w);
(PNA ) if ⟨enumterm(NA)⟩C ∈ Lw(s) then [ ]C ∈ Lw(s), and if ⟨enumterm(NA)⟩ϑ ∈ Λ(w) then [ ]ϑ ∈ Λ(w).
Modal operators, regardless of being in front of formulas or concepts, impose additional properties on basic Hintikka structures. To define these properties in a more uniform way, we will use a notational convenience.
Definition 3.2 Let ⟨Σ, Λ, S, L, S, J⟩ be a basic Hintikka structure for ϕ. For a state w ∈ Σ, the set Φw is defined as

Φw := Λ(w) ∪ {s : C | C ∈ Lw(s) and s ∈ S}.

α and β are placeholders for elements of Φw. qα is either equal to some qϑ or s : qC, where q ∈ {[A], ⟨A⟩} for some coalitional term A. If qα = qϑ then α = ϑ; and if qα = s : qC then α = s : C.
As the reader familiar with tableau would notice, the meanings of symbols α and β in our uniform notation are different than in Smullyan’s notation to classify formulas [4]. We are interested in certain set of modal expressions called modal saturations.
Definition 3.3 Ψ ⊆ Φw is called a modal saturation in a state w ∈ Σ of a basic Hintikka structure if and only if Ψ is equal to
(S[A]) {[A1]α1,..., [An]αn} such that a ∈ enumset (Ai) ∩enumset (Aj) implies i = j, (S[A⟩) {⟨A⟩α, [A1]α1,..., [An]αn} such that a ∈ enumset (Ai) ∩enumset (Aj) implies
i = j and  n	enumset (Ai) ⊆ enumset (A), or
(S⟨A⟩) {⟨A⟩α}.
The first tableau based decision procedure for CL is developed by Hansen [8]. Her formulation of modal saturations is simpler than ours because she instead chooses to have a separate property corresponding to superadditivity. However, such a property generates new conjunctions which are not subformulas of the origi- nal formula. In particular to our case where we also deal with concepts, this would require us to define a conjunction operator over qϑ and s : qC which we wished to avoid.
We are now in a position to define a Hintikka structure which is essentially equivalent to a CLALCO-model as far as the satisfiability of a CLALCO-formula is concerned.
Definition 3.4 Let H = ⟨Σ, Λ, S, L, S, J⟩ be a basic Hintikka structure for ϕ. H
is said to be a Hintikka structure for ϕ if and only if:
(PCD) S(w) = S(v), for all w, v ∈ Σ;
(PH ) for all w ∈ Σ, if {q1α1,..., qnαn} is a modal saturation in w then there is
some v ∈ Σ such that α1,..., αn ∈ Φv.

Lemma 3.5 A CLALCO-formula ϕ is satisﬁable iff there exists a Hintikka structure for ϕ.
Representing individuals 4 explicitly in tableau algorithms for expressive frag- ments of first-order modal logics with constant domains is problematic as far as termination is concerned. This observation is first made for modal description logics by Baader and Laux [3]. Later, quasimodels are proposed to show the decidability of various modal description logics [18]. Only after then it was possible to devise tableau based decision procedures for these logics [13,12] because the algorithms relied on the finite representation of individuals as offered by quasimodels. To this end, an individual (type) is defined as a function over the set of states.
Definition 3.6 Let H = ⟨Σ, Λ, S, L, S, J⟩ be a basic Hintikka structure. A run r
in H is a function associating with every w ∈ Σ a concept type r(w) in S(w).
A run r is defined over all states so that an individual (in the classical sense) corresponding to r is represented by some type in every state. This validates the constant domain assumption. However, one needs to impose several properties on runs in order for them to preserve satisfiability.
Definition 3.7 Let H = ⟨Σ, Λ, S, L, S, J⟩ be a basic Hintikka structure for ϕ. A Hintikka quasistructure for ϕ is a tuple Q = ⟨H, R⟩, where R is a set of runs in H. Furthermore, it holds that:
(Pi ) for every i in NI , the run ri defined by ri(w) = Jw(i), for all w ∈ Σ, is in R; (Ps) for every w ∈ Σ and every s in S(w) such that s /∈ codom(Jw), there exists a
run r in R such that r(w) = s;
(PQ) for every w ∈ Σ and every r ∈ R, if Ψ is a modal saturation in w then there
is some v in Σ such that r(w) : qC ∈ Ψ implies r(v) : C ∈ Φv and qϑ ∈ Ψ implies ϑ ∈ Φv.
Lemma 3.8 Let ϕ be a CLALCO-formula. There exists a Hintikka quasistructure for ϕ iff there exists a Hintikka structure for ϕ.
A more compact representation of a Hintikka quasistructure is possible by re- laxing the definition of a run so that it can associate more than a single type for a state. However, we won’t define these ’overloaded’ runs but dissolve their effect into a global property in the resulting structures.
Definition 3.9 A basic Hintikka structure ⟨Σ, Λ, S, L, S, J⟩ for ϕ is a compact Hintikka quasistructure for ϕ if and only if for every w ∈ Σ,
(PC) if Ψ is a modal saturation in w then there is some v in Σ such that
for every i in NI , Jw(i) : qC ∈ Ψ implies Jv(i) : C ∈ Φv;
s : qC ∈ Ψ and s /∈ codom(Jw) implies there exists a type t in S(v) such that {C | s : qC ∈ Ψ}⊆ Lw(t);
qϑ ∈ Ψ implies ϑ ∈ Φv.

4 types in the context of our Hintikka structures

Example 3.10 Consider the compact Hintikka quasistructure H = ⟨Σ, Λ, S, L, S, J⟩ 
for ϕ with Σ = {w, v} and Lw(s) = {[a]C, [b]D, [b, c]E}, Lv(s) = {C, D}, Lv(t) = 
{C, E} (it does not matter how ϕ actually looks like). H is not a Hintikka qua- sistructure for ϕ because there exists no run r in H with r(w) = s, and hence, (Ps) is violated. The proof is easy, if there were to be an r with r(w) = s, whatever choice we make for r(v), i.e., r(v) = s or r(v) = t, (PQ) would be violated. However, it is possible to modify H and convert it into a Hintikka quasistructure by duplicating the state v with all the necessary mappings.
The proof of the following Lemma generalizes the observation we made in our example.
Lemma 3.11 Let ϕ be a CLALCO-formula. There exists a compact Hintikka qua- sistructure for ϕ iff there exists a Hintikka quasistructure for ϕ.
Theorem 3.12 A CLALCO formula ϕ is satisﬁable iff there exists a compact Hint- tika quasistructure for ϕ.
Proof. Follows immediately from Lemmas 3.5, 3.8, and 3.11.	 

Tableau Algorithm for CLALC0
From Theorem 3.12, an algorithm which constructs a (finite) representation of a compact Hintikka quasistructure for a CLALCO-formula can be used as a decision procedure for the satisfiability of CLALCO-formulas. In this section, we describe such an algorithm, and we prove its termination, soundness, and completeness.

Deﬁnition of the Algorithm
Let NV be a set of countably infinite variables, and < be the well-order relation on NV . A term is either a variable or an individual name. Let ϕ be a CLALCO formula. A constraint for ϕ is (i) a formula in fcl(ϕ), (ii) an atom of the form x : C where x is a term and C ∈ ccl(ϕ), or (iii) an atom of the form (x, y) : R where x, y are terms and R ∈ rol(ϕ). A constraint system S for ϕ is a finite, nonempty set of constraints for ϕ. A completion set T for ϕ is a set of constraint systems for ϕ.
In order to avoid superfluous definitions, we will abuse the α, β uniform notation that we defined in Definition 3.2 for Hintikka structures. To this end, α and β are placeholders for constraints. qα is either equal to some qϑ or x : qC, where q ∈ {[A], ⟨A⟩} for some coalitional term A and x is a term. If qα = qϑ then α = ϑ; and if qα = x : qC then α = x : C. Constraints of type qα are also called modal constraints. More precisely, [A]α is referred to as a positive modal constraint and ⟨A⟩α as a negative modal constraint. Furthermore, a negative modal constraint
⟨A⟩α is called proper if enumset (A) /= NA.
A term x is in S if S contains a mention of x. A variable x is fresh for S if x is not in S and x > y for all variables y in S. We denote by S[x/i] the constraint system obtained from S by substituting every occurrence of the variable x with the



Fig. 1. Local expansion rules for CLQLCO.
individual name i. If (x, y) : R ∈ S for some role name R and terms x, y then y is called a R-successor of x in S, or just a successor when R is not important.
A variable x is blocked in S if there is some other variable y such that {C | x : C ∈ S}⊆ {D | y : D ∈ S} and y < x. In this case, we say that y blocks x in S. S (and therefore T if S ∈ T) is said to contain a clash if
x : ⊥∈ S for some term x,
{x : C, x : чC}⊆ S for some term x and some concept name C,
i : ч{|i|} ∈ S for some individual name i, or
i : {|j|} ∈ S for individiual names i, j.
The local expansion rules are given in Figure 1. The definition of the global expansion rule which adds new constraint systems into the completion set is more involved. In what follows, we will introduce this rule. We say that a rule, regardless of its type, is applicable to a constraint system S iff its condition is satisfied in S.
Let S be a constraint system. The equivalence relation ∼S on the set of variables occurring in S is defined by taking x ∼S y iff {C | x : C ∈ S} = {D | y : D ∈ S}. The equivalence class generated by x is denoted by [x]S. Finally, ∼(S) =
{min([x]S) : C | x : C ∈ S}∪ {ϑ | ϑ ∈ S}.

If S and S' are constraint systems then S' is called a variant of S, written S ≈ S', iff there is a bijective function f from the variables in S onto the variables in S' such that S' is obtained from S by replacing each variable x from S with f (x). Analogous to the modal saturations defined in Definition 3.3 for Hintikka struc-
tures, a subset S' of a constraint system S is called a modal saturation in S if and
only if S' is equal to
{[A1]α1,..., [An]αn} such that a ∈ enumset (Ai) ∩ enumset (Aj) implies i = j,
{⟨A⟩α, [A1]α1,..., [An]αn} such that a ∈ enumset (Ai) ∩ enumset (Aj) implies
i = j and  n	enumset (Ai) ⊆ enumset (A), or
{⟨A⟩α},
such that none of the modal constraints mention a blocked variable.
The global expansion rule R[A⟩ is similar to the one in [6] and defined as follows.
Condition: S is not marked as finished.
Action:
Order linearly all positive and proper negative modal constraints in S not men- tioning blocked variables in such a way that all the positive modal constraints precede all the proper negative ones. Suppose the result is the following list:
L = [A0]α0,..., [Am−1]αm−1, ⟨A' ⟩β0,..., ⟨A'	⟩βn−1.
0	n−1
Let |L| be the length of L, i.e., m+n. Denote by Θ(S) the set {0,..., |L|} NA . As in the relational model, we identify the components of a tuple τ in Θ(S) by names, more precisely agent names, so that τa corresponds to the component of τ identified by a.  Lastly, for every τ ∈ Θ(S), denote by pos(τ ) the set
{a | τa ≥ m}; and by neg(τ ) the number Σa∈pos(τ )(τa − m)	mod n.
res := {}, where res is a set of constraint systems.
Consider the elements of Θ(S) in the lexicographic order and for each τ ∈ Θ(S) do the following:
Create a constraint system
Sτ = {αi | [Ai]αi ∈ S and 6a ∈ enumset (Ai). τa = i}∪ 
{βj | ⟨A' ⟩βj ∈ S, neg(τ ) = j, and NA \ enumset (A' ) ⊆ pos(τ )}.
j	j
If Sτ = ∅ then continue with the next iteration.
Sτ := ∼(Sτ ∪ {a : {|a|} | a ∈ NI}∪ {x : T}), where x is fresh for S.
If Sτ /≈ S' , for all S' ∈ res, then res := res ∪ {Sτ }.
τ	τ
T := T ∪ {res}.
Mark S as finished.
Let ϕ be the CLALCO-formula to be tested for satisfiability. The tableau algo- rithm starts with the initial completion set T = {S0} for ϕ, where S0 = {ϕ}∪ {i :
{|i|} | i ∈ NI}∪ {x0 : T}, x0 being the first variable from NV . T is then expanded
by repeatedly applying the rules in such a way that the global expansion rule is applied only when none of the local expansion rules is applicable, and among local expansion rules R∃ or R/± is applicable only when none of the other local expansion

rules is applicable to a constraint system. The expansion continues until the result- ing completion set contains a clash or none of the rules is applicable to it. Such a completion set is called complete. If the expansion rules can be applied to T in such a way that they yield a complete and clash-free completion set then the algorithm returns “ϕ is satisfiable”, and “ϕ is unsatisfiable” otherwise. Note that the tableau algorithm is a nondeterministic algorithm due to RV and RH. Each of these rules chooses which disjunct to add for a disjunctive formula (concept).

Correctness and Termination
Theorem 4.1 (Termination) Let n = ccl(ϕ) + fcl(ϕ) + NI, where  denotes set cardinality. When started with the initial completion set T for ϕ, the tableau algorithm terminates after the number of steps exponential in n.
Proof. We first show that a local expansion rule can be applied at most once to the same constraint. If we didn’t have the rule Ri, this is obvious to see. In the presence of Ri, if Ri is applied to some x : {|i|} ∈ S then {i : C | x : C ∈ S}∪ {(y, i) : R | (y, x) : R ∈ S)} ⊆ S[x/i] 5 . For a term y of which x is a R-successor, this ensures that neither RE nor R6 will be applied again to some y : ER.C ∈ S or y : 6R.C ∈ S, respectively. If x : ч˙ C ∈ S and T /± C ∈ S then i : ч˙ C ∈ S[x/i] ensures that R/± will not be applied to T /± C ∈ S. For all the other local expansion rules, the same holds trivially.
There can be at most 2 ccl(ϕ) unblocked variables in S by the definition of block- ing. New variables can only be introduced to S by RE or R/±. Call these rules generating and all the other local expansion rules non-generating. If RE has been applied to a constraint x : ER.C or x : ч˙ C has been added to S by R/± then x will never be blocked in S because by the strategy of rule applications S was closed under the application of non-generating rules. Therefore, if a variable x is blocked then it is introduced by RE, x is the successor of some unblocked term y, and there is no successor of x. As a consequence, the number of blocked variables in S can not be more than 2 ccl(ϕ) which is the case when every unblocked variable blocks a variable and all blocked variables are pairwise disjoint.
Obviously, there may exist at most ccl(ϕ) constraints of the form x : C for each term x in S. All individual names in NI are in S. Hence ccl(ϕ) · ( NI + 2 ccl(ϕ)+1) is the upper bound on the number of constraints of the form x : C in S, where x is a term. A constraint of the form (x, y) : R is always introduced with a constraint x : C. Therefore, the number of constraints of the form (x, y) : R is limited by the number of constraints of the form x : C.
The number of constraints of the form ϑ in S can not exceed fcl(ϕ). Combining this with the upper bound on the number of constraints with terms, the cardinality of S is at most 2 · ccl(ϕ) · ( NI + 2 ccl(ϕ)+1)+ fcl(ϕ) ≤ 2n(n + 2n+1)+ n = 2n2 + n · 2n+2 + n = ϵ.
All local expansion rules except Ri strictly expand S and as we have shown a local expansion rule can be applied at most once to the same constraint. Thus, the

5 Notice that by the strategy of rule applications, x can never have a successor before Ri is applied

number of local expansion rule applications – not counting the ones for Ri – can be at most ϵ, i.e., the maximal cardinality of S. We need an upper bound on the number of applications of Ri. Observe that in every x : {|i|} that triggers Ri, x is a variable. This means Ri can not be applied more than the sum of the times that generating rules are applied. Therefore, it takes no more than 2 · ϵ steps to apply all local expansion rules to S.
Before we determine the number of steps it takes to apply all global completion rules, we need a few definitions. The modal depth md(ψ) of ψ is the length of the longest chain of nested modal operators in ψ (both in subformulas and subconcepts). The modal depth md(x : C) of a constraint x : C is defined analogously. The modal depth md(S) of a constraint system S is the maximal modal depth of constraints in S.
The depth of a tree is the number of edges in its longest branch; the outdegree
is the maximal number of immediate successors of nodes in the tree.
|L| ≤ S and thus, Θ(S) = ϵ Agt ≤ ϵn = ρ. This is also the upper bound on
 res. So R[A⟩ can add at most ρ new constraint systems to T at S. Let S' be one of these new constraint systems. Clearly, md(S') < md(S). Define a tree T from T in the following way.
The root of T is S0.
If S is a node in T then S' such that S' is generated by R[A⟩ from S is a successor of S.
From our discussion it follows immediately that the depth of this tree is md(ϕ) and the outdegree is ρ. md(ϕ) ≤ n, and thus, the number of nodes in T is at most ρ0 + ... + ρn = ζ. As R[A⟩ is the only rule that expands this tree, the total number of steps it takes to apply all global completion rules is bounded by the same number.
Since we know that there are ζ nodes in T and it takes 2 · ϵ steps to apply all local expansion rules per node, 2 · ϵ · ζ is the total number of applications of local expansion rules during the run of the algorithm. Thus, the sum 2 · ϵ · ζ + ζ is the total number of applications of all expansion rules which is exponential in n. 
Corollary 4.2 The tableau algorithm runs in NEXPTIME.
Remark 4.3 Pauly obtains the PSPACE lower bound of the satisfiability problem of CL by a polynomial reduction from the satisfiability problem of KD (the normal modal logic over serial frames) [15]. The formula satisfiability problem of KDALC is NEXPTIME-hard [5]. Therefore, we conjecture that the NEXPTIME-hardness of CLALC [17] (which is subsumed by CLALCO) could be shown by a similar reduction.
The following Lemma will be useful for establishing the soundness and complete- ness of the tableau algorithm. It says that R[A⟩ finds all and only modal saturations in the constraint system to which it is applied.
Lemma 4.4 Suppose S is a constraint system and that R[A⟩ has been applied to S. A subset qS' of S is a modal saturation in S if and only if there is some τ ∈ Θ(S) such that Sτ = S' /= ∅.

Proof. Denote by qS a constraint system containing only modal constraints and let S = {α | qα ∈ qS}. It is enough to consider subsets of S containing only modal constraints because those are the ones actually by R[A⟩. Thus, we look at all possible combinations of modal constraints.
Suppose qS' be a subset of S that consists only of positive modal constraints and let ind(qS') be the set of all indices i such that an element of qS' has the position i in L. Suppose qS' is a modal saturation in S. Then for all i, k ∈ ind(qS'), a ∈ enumset (Ai) ∩ enumset (Ak) implies i = k. For every i ∈ ind(qS') and every a ∈ enumset (Ai), set τa = i and for every a ∈ NA \  i∈ind(S') enumset (Ai), set τa = min(ind(qS')). By the definition of Θ(S), τ is in Θ(S); and Sτ = S'. Now suppose qS' is not a modal saturation in S. Then for some i, k ∈ ind(qS'), there is an a ∈ enumset (Ai) ∩ enumset (Ak). This means if there were to be a τ ∈ Θ(S) such that Sτ = S' then τa = i and τa = k. But this is not possible.
Let qS' = {⟨A⟩α}. Any such qS' is a modal saturation in S; therefore, it is enough to show that there is some τ ∈ Θ(S) such that Sτ = S' /= ∅. We consider two cases.
Case enumset (A) /= NA: Let k be the position of ⟨A⟩α in L. By definition, k ≥ m and by assumption, there exists a' ∈ NA \ enumset (A). Set τa' = k and set τa = m for every a ∈ NA \ {a'}. As a consequence, neg(τ ) = k — m and NA \ enumset (A) ⊆ pos(τ ) which means that {α} = Sτ .
Case enumset (A) = NA: By RNA , [ ]α is in S and moreover it is a modal saturation in S. But by Case 1, we know that there is some τ ∈ Θ(S) such that Sτ = {α}.
Let qS' be a subset of S that contains more than one negative modal constraint. qS' is not a modal saturation in S and there is no τ ∈ Θ(S) such that Sτ = S' because neg(τ ) allows us to choose at most one negative modal constraint.
Let qS' be a subset of S containing some positive modal constraints and one negative modal constraint. The proof is a combination of the proofs for Cases 1 and 2.	 

Corollary 4.5 Suppose T is a completion set with S ∈ T and that R[A⟩ has been applied to S. If S' is a modal saturation in S then there is some S'' in T such that
for every i in NI, i : qC ∈ S' implies i : C ∈ S'';
for a variable x, x : qC ∈ S' implies there exists a variable y in S'' such that
{C | x : qC ∈ S'}⊆ {D | y : D ∈ S''};
qϑ ∈ S' implies ϑ ∈ S''.

The proofs of following theorems are extensions of the respective ones in [17].

Theorem 4.6 (Soundness) If the tableau algorithm returns “ϕ is satisﬁable” for a CLALCO-formula ϕ then ϕ is satisﬁable.
Theorem 4.7 (Completeness) If a CLALCO-formula ϕ is satisﬁable then the tableau algorithm returns “ϕ is satisﬁable”.

Conclusions
In this paper, we extend Coalition Description Logic [17] with nominals for individ- uals, and we use these nominals to refer to coalitions. This might be considered as a relatively simple extension of CDL, but it is well-balanced between expressivity and difficulty of reasoning. Regarding expressive power, one can reason about agents’ ability to influence themselves and to the best of our knowledge this is the first such coalition logic. As for the difficulty of reasoning, we use only basic set operations to reason in the modal component of the logic. Allowing more concept constructors to define coalitions would require model-checking techniques from the DL component; it looks like an interesting research direction for the future.
This study offers also an interesting reflection on the methodological level. In our previous work [17], we proposed a general framework for combining strategic and descriptive elements of a multi-agent system. However, it turned out that a nontrivial semantic machinery does not guarantee exciting specifications. Here, we present a small extension of the framework (one may be even tempted to call it slight ) that allows to specify surprisingly sophisticated properties, as we hope to have demonstrated in Section 2.4. This shows that the practical usability of a language may very much depend on elements which seem minor from the theoretical point of view.

References
Alur, R., T. A. Henzinger and O. Kupferman, Alternating-time Temporal Logic, Journal of the ACM
49 (2002), pp. 672–713.
Baader, F., D. Calvanese, D. L. McGuinness, D. Nardi and P. F. Patel-Schneider, editors, “The Description Logic Handbook: Theory, Implementation, and Applications,” Cambridge University Press, 2003.
Baader, F. and A. Laux, Terminological logics with modal operators, in: C. Mellish, editor, 14th International Joint Conference on Artificial Intelligence (1995), pp. 808–814.
Fitting, M., “Proof Methods for Modal and Intuitionistic Logics,” Synthese Library 169, D. Reidel, Dordrecht, The Netherlands, 1983.
Gabbay, D., A. Kurucz, F. Wolter and M. Zakharyaschev, “Many-dimensional modal logics: theory and applications,” Studies in Logic, 148, Elsevier Science, 2003.
Goranko, V. and D. Shkatov, Tableau-based decision procedures for logics of strategic ability in multi- agent systems, CoRR abs/0803.2306 (2008).
Gor´e, R., Tableau methods for modal and temporal logics, in: M. D’Agostino, D. M. Gabbay, R. Hahnle and J. Posegga, editors, Handbook of Tableau Methods (1999), pp. 297–396.
Hansen, H. H., “Tableau Games for Coalition Logic and Alternating-time Temporal Logic,” Master’s thesis, Universiteit van Amsterdam (2004).
Hintikka, J., Form and content in quantification theory, Acta Philosophica Fennica 8 (1955), pp. 7–55.
Horrocks, I., P. F. Patel-Schneider and F. van Harmelen, From SHIQ and RDF to OWL: The making of a web ontology language, J. of Web Semantics 1 (2003), pp. 7–26.
URL download/2003/HoPH03a.pdf

Horrocks, I. and U. Sattler, A tableau decision procedure for SHOIQ, J. Autom. Reason. 39 (2007),
pp. 249–276.

Lutz, C., H. Sturm, F. Wolter and M. Zakharyaschev, Tableaux for temporal description logic with constant domains., in: R. Gor´e, A. Leitsch and T. Nipkow, editors, IJCAR, Lecture Notes in Computer Science 2083 (2001), pp. 121–136.
Lutz, C., H. Sturm, F. Wolter and M. Zakharyaschev, A tableau decision algorithm for modalized ALC
with constant domains, Studia Logica 72 (2002), pp. 199–232.
Pauly, M., “Logic for Social Software,” Ph.D. thesis, University of Amsterdam (2001).
Pauly, M., A modal logic for coalitional power in games, Journal of Logic and Computation 12 (2002),
pp. 149–166.
Schwendimann, S., A new one-pass tableau calculus for pltl, in: TABLEAUX ’98: Proceedings of the International Conference on Automated Reasoning with Analytic Tableaux and Related Methods (1998),
pp. 277–292.
Seylan, I. and W. Jamroga, Description logic for coalitions, in: Proceedings of AAMAS’09, 2009, pp. 425–432.
Wolter, F. and M. Zakharyaschev, Satisfiability problem in description logics with modal operators, in:
S. S. A.G. Cohn, L. Schubert, editor, Proceedings of the 6th International Conference on Principles of Knowledge Representation and Reasoning (KR’98) (1998), pp. 512–523.
