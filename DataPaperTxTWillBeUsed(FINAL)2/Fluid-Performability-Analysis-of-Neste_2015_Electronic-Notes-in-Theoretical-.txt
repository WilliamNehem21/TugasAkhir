Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 310 (2015) 27–47
www.elsevier.com/locate/entcs

Fluid Performability Analysis of Nested Automata Models
Luca Bortolussi
Department of Mathematics and Geosciences, University of Trieste, ISTI-CNR Pisa, luca@dmi.units.it
Jane Hillston
School of Informatics, University of Edinburgh, jane.hillston@ed.ac.uk
Mirco Tribastone
Electronics and Computer Science, University of Southampton, m.tribastone@soton.ac.uk

Abstract
In this paper we present a class of nested automata for the modelling of performance, availability, and reliability of software systems with hierarchical structure, which we call systems of systems. Quantitative modelling provides valuable insight into the dynamic behaviour of software systems, allowing non-functional properties such as performance, dependability and availability to be assessed. However, the complexity of many systems challenges the feasibility of this approach as the required mathematical models grow too large to afford computationally efficient solution. In recent years it has been found that in some cases a fluid, or mean field, approximation can provide very good estimates whilst dramatically reducing the computational cost.
The systems of systems which we propose are hierarchically arranged automata in which influence may be exerted between siblings, between parents and children, and even from children to parents, allowing a wide range of complex dynamics to be captured. We show that, under mild conditions, systems of systems can be equipped with fluid approximation models which are several orders of magnitude more efficient to run than explicit state representations, whilst providing excellent estimates of performability measures. This is a significant extension of previous fluid approximation results, with valuable applications for software performance modelling.
Keywords: Systems of systems, fluid approximation, software performance modelling.

Introduction
Modelling and analysis of nested (or hierarchical) structures occurs frequently in many domains, including for example, software systems and biological processes. For instance in the software context, a cloud environment may be thought of as a collection of many computers, each containing other components, such as processors and threads [10]. Thus there are three levels: processes and threads, computers and the cloud itself, and at each of these levels the behaviour of an individual

http://dx.doi.org/10.1016/j.entcs.2014.12.011
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-SA license (http://creativecommons.org/licenses/by-nc-sa/3.0/).

entity can be described by an automaton. Note that the hierarchical nesting in these systems is genuinely structural and not an abstraction used to hide detail as is done, for example, in UML state machines. The organisational complexity of these systems means that it is hard to predict their behaviour and it is imperative that performance and reliability characteristics are investigated prior to deployment. When formal reasoning about these systems is performed with reactive models based on a discrete state-space representation, the problem size grows extremely quickly with the population of components, making the analysis infeasible in practice.
In this paper, we present a Markov model of nested automata which we call system of systems. Automata are hierarchically organised in a tree (Fig.1 a)); the behaviour of an automaton can be affected by the state of its siblings (horizontal interaction; Fig.1 c)). Each automaton contains other automata, and the dynamics of a parent may have an impact on that of its children, and vice versa (vertical in- teraction; Fig.1 d)). Each node of the tree is assigned a multiplicity, which indicates how many copies of the stochastic automaton are present in the system of systems within each copy of its parent automaton (Fig.1 b)).
Nested Markov models have previously been proposed as a good model for hier- archically organised software systems, but limited progress has been made against the heavy computational costs due to layering and large multiplicities. Previously proposed techniques seek to exploit symmetries but still yield a Markov chain. For example, Buchholz exploits Kronecker algebra with hierarchical models that can express certain classes of stochastic Petri nets and queueing networks, but his work is limited to only two levels of nesting [4, 5]. Lanus and Trivedi consider a class of hierarchical Markov models where the states of automata of arbitrary size can be partitioned in such a way that a reduced model can be constructed which preserves steady-state reward measures of availability and performance [11]. However, the state space size of the CTMC is still dependent (exponentially in the worst case) on the number of so-reduced automata.
In this paper, we introduce a mean-field approximation based on a system of ordinary differential equations (ODEs) which initially associates an equation with each element of the CTMC state descriptor, estimating the expectation. Unfor- tunately, the state descriptor grows exponentially with the number of levels and polynomially with the branching level in the class tree, the number of automata in each class, and the number of states of each automata class. This clearly hinders even the applicability of fluid models for nested systems of moderate size. To ad- dress this issue, we exploit a property of symmetry between such equations which, informally, shows that two distinct equations for any two automata copies of the same kind (i.e., belonging to the same node in the tree) yield the same ODE solu- tion. Thus, a significant reduction of the ODE system size is possible by considering a representative set of equations for each node in the tree, independently from all the multiplicities involved.
The basic result of ODE symmetry is analogous to [15], which establishes a form of ODE lumpability in the context of the Markovian process algebra PEPA [9]. In this respect, this paper represents a significant improvement owing to its generality

and much wider scope of applicability. Specifically, in [15] horizontal interaction is restricted to the semantics of PEPA. This excludes, for instance, the possibility of studying nested systems with more general forms of interactions, such as the law of mass action used in certain networking models [16]. Instead, our results do not depend on the actual laws of interaction used, provided they yield an ODE system with a unique solution. With respect to vertical interaction, this paper relaxes the restrictions imposed by the choice of a specific synchronisation operator in process algebra. For instance, in PEPA (and in CSP-based calculi in general), vertical interaction can be modelled by considering a shared action, α, between a parent process P and its children, C1, . . . , Cn, in a composite process: P   {α} (C1  L
...  L Cn). In this case, if α ∈ L then the semantics enforces that an α-action is
witnessed only when all processes can perform it. On the other hand, if α /∈ L only one of the processes Ci will perform an action in synchronisation with its parent. In CCS and other process calculi based on complementary actions the situation is even more restrictive, even if transactions on binary interactions are introduced. In our modelling formalism, vertical interaction is obtained by introducing the notion of causal map. Using a causal map the modeller may specify, for instance, which states of the child automata are susceptible to an action performed by the parent, and with what probability a child changes its susceptible state when that action is witnessed. It can be shown that this level of expressiveness cannot be obtained by using PEPA or other available Markovian process algebra (e.g., [1, 8]).

Paper Overview
Section 2 presents our Markov model of systems of systems, helped by a simple running example that illustrates the main definitions. Section 3 discusses the fluid approximation and presents the result of ODE symmetry reduction. Section 4 uses a case study of a performability model for a hierarchical distributed computing system, for the purposes of an extensive numerical validation which considers the accuracy of the fluid approximation and its computational advantage over stochastic analysis. Finally, Section 5 concludes the paper.
Nested Automata
A system of systems is a hierarchical model consisting of Markov automata which contain other automata, with an arbitrary level of nesting. Here we are inter- ested in systems in which at any level of their hierarchical organisation consist of a population of interacting agents. Examples of this sort of systems are ubiqui- tous: In biology, tissues are composed of many cells, each containing many different biochemical molecules interacting together. Server farms contain many comput- ers, each running a potentially large number of processes. In this latter case, the Markov automata at the higher level may represent server farms, and they will contain Markov automata modelling the computers inside the farms, each of which contains a population of automata representing the running processes. This notion of hierarchical containment is illustrated by means of an example in Figure 1, using

T	T

a)	b)

T

T




Fα = λa1⟨1⟩a1⟨2⟩
c)

⟨1⟩1 → ⟨1⟩2 ⇒ ⟨1, 1⟩1 → ⟨1, 1⟩2 :: ! d)

Fig. 1. a) A system of systems A; b) an instance of a system of systems; c) horizontal interaction; d) vertical interaction.
the notation that will be introduced in the remainder of this section.
We now turn to describe the structure of a system of systems model. The idea is that we will describe at each level of the hierarchy a prototype agent for each type of agent populating that level. This is captured in the notion of agent class. Then, such classes will be instantiated, specifying how many agent instances there are for each class in the system.
Structure
Let A be the set of all automata classes of a model. We can think of each class as a type of element or agent within the system. So, for example, in a server farm, farms, computers and jobs, may all be distinct automata classes within the system description. A system of systems is specified by a tree with nodes A describing the hierarchical organisation of such classes. Thus in the server farm example, a computer will be the child of a farm and be parent to several jobs.
In order to talk about the different agent classes within the tree, we need some notation for their coordinates. For this, we assume a fixed and well-defined visit strategy (for instance, depth-first) and denote by D the tree depth. We let
⟨i1, i2,..., il⟩ ∈ A denote the automata class at level l of the tree which is reached by navigating the tree starting from the i1-th automata class below the root, then taking its i2-th child, and so on. Note that we do not require balanced trees and so, for instance, ⟨1, 1, 1⟩ may belong to the tree but ⟨2, 1⟩ may not. In the notation we sometimes abbreviate ⟨i1, i2,..., il⟩ to ⟨il⟩, where il is a vector of indices of length l, or similarly, to ⟨il−1, il⟩. We use c⟨il⟩ to denote the number of children of ⟨il⟩. These will be indexed by ⟨il, 1⟩, ⟨il, 2⟩,..., ⟨il, c⟨il⟩⟩.
Having established the hierarchical organisation of automata classes we now turn to describe automata classes themselves. Essentially, each automaton will be a finite state machine, which will change state probabilistically (at random times),

due to interactions with other automata specified by system level rules. We start by providing the description of the automata structure: An automata class ⟨il⟩ is defined by the tuple


where
⟨il⟩ = "Σ⟨il⟩, −→⟨il⟩, n⟨il⟩ ,

Σ⟨i ⟩ is the automaton’s state space, with states denoted by ⟨il⟩ j, with 1 ≤ j ≤
d⟨il⟩, where d⟨il⟩ = |Σ⟨il⟩|.
−→⟨il⟩ ⊆ Σ⟨il⟩ × Σ⟨il⟩ is the set of transitions between states. When the context is clear we abbreviate −→⟨il⟩ by −→. Furthermore, we use the typical notation
⟨i ⟩ j −→ ⟨i ⟩ j′ if "⟨i ⟩ j, ⟨i ⟩ j′ ∈ −→	.
n⟨il⟩ ∈ N is the population size, i.e. it specifies how many distinct copies of the automaton ⟨i1, i2,..., il⟩ are present within each copy of its automaton parent,
⟨i1, i2,..., il−1⟩. If l = 1, it simply indicates how many copies of ⟨i1⟩ are present in the system of systems.
The latter point deserves more explanation. Suppose we have a simple system of systems with only one path from ⟨1⟩ to ⟨1, 1⟩. Here, there are n⟨1⟩ automata of type ⟨1⟩, but each contains n⟨1, 1⟩ automata of type ⟨1, 1⟩. Therefore, there are in total n⟨1⟩ + n⟨1⟩· n⟨1, 1⟩ automata in this system of systems. For example, the system of systems representation of a server farm consisting of a single farm made up of 10 servers, each hosting 20 jobs, will have 211 automata.
In order to describe the state of a system of systems, we will use a boolean vector of the form
b := bj⟨il⟩[kl] , ∀⟨il⟩ : ⟨il⟩∈ A, 1 ≤ j ≤ d⟨il⟩,	(1)
where kl = (k1,..., kl) is such that 1 ≤ km ≤ n⟨i1,..., im⟩, for all 1 ≤ m ≤ l. Each element bj⟨il⟩[kl] equals either 1 or 0. Specifically, bj⟨il⟩[kl] = 1 if and only if j is the current local state of the automaton of type ⟨il⟩ reached by taking the k1-th copy of ⟨i1⟩, the k2-th copy of ⟨i1, i2⟩ and so on. Thus we record, for each copy of an automaton and for each local state of the automaton of type ⟨il⟩, whether this instance is in that state or not. The double indexing ⟨il⟩ and [kl] of the vector b is required because we need to identify a specific automata of a specific automata class. Hence ⟨il⟩ identifies the automata class in the system of systems tree, while kl specifies the actual element of the population. In order to do this, we also need to know which are the actual automata containing a given agent, hence the need of another vector of coordinates.
Example 1 We use the following running example to illustrate the deﬁnitions pre- sented in this section. Let us consider the system of systems illustrated in Fig- ure 1,with three automata classes, ⟨1⟩, ⟨1, 1⟩, and ⟨2⟩, with two local states each and with transitions
⟨1⟩1 → ⟨1⟩2,	⟨1⟩2 → ⟨1⟩1,
⟨2⟩1 → ⟨2⟩2,	⟨2⟩2 → ⟨2⟩1,
⟨1, 1⟩1 → ⟨1, 1⟩2,	⟨1, 1⟩2 → ⟨1, 1⟩1.

Let us set n⟨1⟩ = 2, n⟨2⟩ = 1, and n⟨1, 1⟩ = 2; that is, there are two copies of automaton ⟨1, 1⟩ within each of the two copies of automaton ⟨1⟩. Therefore, the state descriptor has the form:

b =  b1⟨1⟩[1], b2⟨1⟩[1], b1⟨1, 1⟩[1, 1], b2⟨1, 1⟩[1, 1], b1⟨1, 1⟩[1, 2], b2⟨1, 1⟩[1, 2],
b1⟨1⟩[2], b2⟨1⟩[2], b1⟨1, 1⟩[2, 1], b2⟨1, 1⟩[2, 1], b1⟨1, 1⟩[2, 2], b2⟨1, 1⟩[2, 2], b1⟨2⟩[1], b2⟨2⟩[1] ,
(2)
where the elements in the ﬁrst line denote the local states of the automata reachable from the ﬁrst copy of ⟨1⟩; all but the last two elements of the second line describe the local states of the automata reachable from the second copy of ⟨1⟩; the last two elements denote the state of the only automaton ⟨2⟩, which has no children.

Semantics
The dynamics of a system of systems are impacted by two kind of interactions between its components: horizontal interaction and vertical interaction. Horizontal interaction comes about through the mutual influence of the dynamics of entities at the same level of the hierarchy. For instance, in a server farm model this can be dynamics of processes and jobs within a single computer. However, these dynamics are not independent of the context, but can be affected by the state of the containing node and by the state of the automata contained in the interacting ones. This is termed vertical interaction. Again, in the server farm example, the speed of processes in a computer may depend on its energy state, e.g. whether it is in power saving mode or not. Furthermore, two computers in a server farm can exchange jobs, if one has many of them waiting to be processed while the other is idle. Another form of vertical interaction is caused because a state change at one level in the tree can propagate its effects to its descendent nodes: think about the effect of a computer losing power will have on the processes running within it. We will describe the first kind of interaction by events, which are specified by rules at system level, while the second kind of dynamics will be described by a causal map.
The main source of dynamics of a system of systems are the events E , which cause a change in the state descriptor (1). Each event η ∈ E defines horizontal interaction as a form of synchronisation between sibling automata in the system of systems tree. It is characterised by a synchronisation set Sη, specifying which class of automata and how many instances are involved in the event, and by a function Fη giving the rate of the interaction. Similarly to [12], this is a functional rate, in order to compactly describe the overall behaviour. We choose such rates to depend on the population levels only. This choice is based on the assumption that replicas of the same automaton are statistically equal to each other, but the state of each individual can be observed. However, the behaviour of an automaton can be dependent on the current state of its parent and of its siblings and children. Here such a relationship is expressed by the fact that functional rates may be dependent on the total populations of children and siblings. Formally, this may be achieved

by defining events E in the following form.
Definition 2.1 [Events] An event η ∈E is a pair η = (Sη,Fη), where:
Sη is the synchronisation set containing automata transitions denoted by ⟨i s⟩j −→
s j′	s1	s2
⟨il ⟩ , s = 1,..., sη, such that ⟨il−1⟩ = ⟨il−1⟩ for each s1, s2 = 1,..., sη (the
automata involved in the event have the same parent), where sη is the number of
automata involved in the event. For simplicity, we also require ⟨i s1 ⟩ /= ⟨i s2 ⟩, i.e.
l	l
the automata involved in the synchronisation are all distinct. 1
The function Fη gives the rate at which a specific tuple of automata in states
⟨i 1⟩j,..., ⟨i sη ⟩j performs the event. The function has parameters:
l	l

l	l	l	l
where
a⟨i s⟩ := "a1⟨i s⟩,..., ad⟨i s⟩⟨i s⟩  is the descriptor for the state space of ⟨i s⟩, for

a⟨il−1⟩ is the descriptor for the state space of the parent of ⟨i 1⟩,..., ⟨i sη ⟩;
l	l

Xs⟨il−1⟩ is the state descriptor for the population of the siblings of ⟨i 1⟩,..., ⟨i sη ⟩,
l	l
Xs⟨il−1⟩ := (X⟨il−1, 1⟩,..., X⟨il−1, c⟨il−1⟩⟩) ,
where
X⟨ml⟩ :=  X1⟨ml⟩,...,Xd⟨ml⟩⟨ml⟩  ,	for all ml : ⟨ml⟩∈A 
and Xj⟨ml⟩ is the count of the number of instances of ⟨ml⟩ in state j;

Xc⟨i s⟩ := (X⟨is, 1⟩,..., X⟨is, c⟨i s⟩⟩) is the state descriptor for the population
l	l	l	l
of children of ⟨i s⟩, for s = 1,..., sη.
Example 1 (continued) Consider again the example illustrated in Figure 1 and described earlier. Let α denote an action at the top level, involving automata in state ⟨1⟩1 and ⟨2⟩2. We would write
Sα = {⟨1⟩1 → ⟨1⟩2, ⟨2⟩1 → ⟨2⟩2}.
The associated function Fα has formal parameters
Fα a1⟨1⟩, a2⟨1⟩, a1⟨2⟩, a2⟨2⟩, X1⟨1⟩,X2⟨1⟩,X1⟨2⟩,X2⟨2⟩,
X1⟨1, 1⟩,X2⟨1, 1⟩}  ,

1 This condition can be easily dropped, at the price of enforcing a minimum number of automata per class in the CTMC and making Sη a multi-set.

where the ﬁrst line is related to the local states of two automata of kind ⟨1⟩ and
⟨2⟩; the second line describes the dependence on the population of the sibling’s local states, and the last line shows the dependence on the children’s local states. Setting
Fα = λαa1⟨1⟩a1⟨2⟩,	for λα > 0,

indicates that a synchronisation happens whenever the two automata are in their local state 1; when this occurs, the automata change their local state in 2, as ex- pressed in the synchronisation set Sα. The rate of the synchronisation is given by λα.
In the above example, for simplicity we have considered a function, Fα, which does not depend on the populations of the parent automata or of the children automata. Section 4 will study a somewhat more elaborate case study where such dependencies are instead present. Furthermore, let us notice that we purposely use formal parameters denoted by the letter a (e.g., a1⟨1⟩ and a1⟨2⟩) to indicate that this is a template function that may be applied to distinct the elements of the boolean state descriptor vector b in (2). Although this will be defined more precisely later via Definiton 2.3, here we anticipate that this function will induce two distinct transitions for b. More specifically, both will involve the same copy of automaton ⟨2⟩; however, the first transition will be concerned with its interaction with the first copy of ⟨1⟩, while the second transition will describe the interaction with the second copy of ⟨2⟩.
An event specifies which automata are affected by a synchronisation, and how fast this happens. However, it says nothing about what actually happens their child nodes. Let us recall that describing this behaviour can be useful to model situations where an event in a system affects the behaviour of its inner components, e.g., a power outage for a computer will abort all of its software processes. Such a form of vertical interaction is instead captured by the notion of causal map, which defines how the transition of a parent automaton impacts on its child automata.
Definition 2.2 [Causal map] A causal map C is a set of rules of the form
⟨il⟩j −→ ⟨il⟩k ⇒ ⟨il, r1⟩j1 −→ ⟨il, r1⟩k1 :: p1; ... ; ⟨il, rm⟩jm −→ ⟨il, rm⟩km :: pm
where pi is either a number in (0, 1], or the special symbol !.
The values pj attached to each automata event in the right hand side of a rule in the causal map specify either the probability with which the update happens (when p ∈ (0, 1]) or that exactly one child automaton changes state (if p = !).
A causal map is well-formed if each transition in the left hand side appears at most once in C, and there are never two events out of the same state in the right hand side of a rule, i.e. ⟨il, rs ⟩js1 /= ⟨il, rs ⟩js2 for s1 /= s2. In the following, we
1	2
assume all causal maps are well-formed and we will denote by rule(⟨il⟩i −→ ⟨il⟩j)
the right hand side of the rule in C, if any, having ⟨il⟩i −→ ⟨il⟩j as the left hand side.
Example 1 (continued) For the previously considered example, we can deﬁne the

casual map

⟨1⟩1 → ⟨1⟩2 ⇒ ⟨1, 1⟩1 → ⟨1, 1⟩2 :: !	(3)

This causal map says that, whenever the local state of one automaton ⟨1⟩ changes from 1 to 2, then exactly one child automaton ⟨1, 1⟩ will change from state 1 to state 2.
As discussed, the specification of events is given at the level of automata classes. Recall, however, that a system of systems is comprised of a number of instances of each automaton class. Thus, we may think of a population corresponding to each class of automata. In practice, each event will involve some elements of the population of the given automata class. Hence we need a mechanism to identify the actual elements or agents involved. Furthermore, we need to take all possible choices of automata into account, each of which provides an instance of the event. More specifically, consider an event η ∈ E , involving automata of classes ⟨i 1⟩,..., ⟨i sη ⟩.
l	l
We define the event rate of a specific set of automata in the system of systems
involved in η by an instance function Fη[k1,..., ksη ](b). As event η synchronises
l	l
automata at level l, we need to identify the parent automaton in which it operates.

This is indicated with ⟨i η ⟩. The coordinates k1,..., ksη
specify the actual au-

l−1	l	l
tomata involved in the event. Each kj = (kj,..., kj) is such that 1 ≤ kj  ≤ n⟨ij ⟩,
l	1	l	m	m
with 1 ≤ m ≤ l and j = 1 ... sη. Moreover, as the involved automata need to be
contained in the same parent, it holds that k i	= k j  . A tuple (k1,..., ksη ) that
l−1	l−1	l	l
satisfies these constraints is called an instance of the event η, and represents one
way in which the event may be manifest within the system of systems by choosing particular instances to take part in the event and undergo the updates. For any given event and given state of the system of systems there may be many different ways in which the event may be instantiated. The set of instances for η is denoted by Kη. Each function is associated with a jump or update vector that suitably changes the state descriptor, according to the synchronisation set Sη, i.e. each entry in b will be incremented or decremented by 1 to reflect the entry into and exit from local states within each instance of each automaton.
Example 1 (continued) Recall that α is an action at the top level of the example shown in Figure 1, involving automata in state ⟨1⟩1 and ⟨2⟩2. The tuples
1, 1	and	2, 1
form the set of instances for the event α. They indicate the possible interaction between either of the two copies of automaton ⟨1⟩ and the only copy of automaton
⟨2⟩.
Before we define the dynamics of the CTMC associated with a system of sys- tems, it will be useful to introduce some additional notation. The rich nature of the dynamics captured in systems of systems means that the rate, and indeed the existence of a transition, depend not only on the state of the automaton in which the transition occurs, but also potentially on the state of other automata at the same level (siblings), its enclosing automaton (parent) and the automata within it (children). But we do restrict that this dependence will only depend on siblings and

children through their population counts, based on the assumption that instances are indistinguishable.

We denote by b
j [kj] the vector of state entries of the form in equation (1),

⟨il ⟩	l
corresponding to instance kj:
b	[kj] :=  b1⟨i j⟩[kj],..., bd⟨i j⟩⟨i j⟩[kj] ,	j = 1 ...s .	(4)

As discussed above, the transition in the CTMC will depend on this detailed current state of the instances involved in the event, but may also be affected by the sibling and child automata through their aggregate state, in terms of their populations.
Thus we introduce notation to represent these populations, where S⟨il−1⟩[kl−1] is the vector of counts corresponding to all siblings. Essentially, for each automata class contained in the instance kl−1 of the parent automata class ⟨il−1⟩, we count

how many automata instances are in each local state. Sj
l−1
[kl−1], in particular, is

the vector of counts across states of the automata class ⟨il−1, j⟩.



S⟨il−1⟩
[kl−1] := S1	[kl−1],..., Sc⟨il−1⟩[kl−1]  ,	(5)


j
⟨il−1⟩
n⟨il−1,j⟩
[kl−1] :=
r=1

1
⟨il−1,j⟩
n⟨il−1,j⟩
[kl−1, r],..., 
r=1

bd⟨il−1,j⟩[kl−1, r]
l−1
,	(6)

Similarly we take into consideration the populations within the child automata,
C  j , [kj], which counts the states of automata contained in the automata kj:

⟨il ⟩	l
l

C j [kj] := S j [kj]	(7)

⟨il ⟩	l	⟨il ⟩	l

Example 1 (continued) For event α, we have that
b⟨1⟩[1] = "b1⟨1⟩[1], b2⟨1⟩[1] ,

b⟨2⟩[1] = b1⟨2⟩[1], b2⟨2⟩[1] .
The vector of the population of siblings is given by
 b1⟨1⟩[1] + b1⟨1⟩[2], b2⟨1⟩[1] + b2⟨1⟩[2], b1⟨2⟩[1], b2⟨2⟩[1] .
Similarly, the vector of the populations of children is
 b1⟨1, 1⟩[1, 1] + b1⟨1, 1⟩[1, 2], b2⟨1, 1⟩[1, 1] + b2⟨1, 1⟩[1, 2] .

We are now ready to provide the definition of the actual dynamics of the CTMC. What we need to do is to specify, for each instance of each event η, the rate (given by the instance function, where we substitute the correct population counts of siblings

and child nodes) and the update vector, specifying the net change in the CTMC state descriptor. Furthermore, each event propagates its effects downstream in the automata hierarchy, according to the causal rules associated with a state change in the automata involved in the transition. Hence, we also need to specify at what rate child automata perceive the event that happened at their parent level, and how their state is modified.
Definition 2.3 [CTMC Dynamics] Let A be a system of systems with events E . Let (1) define the CTMC state descriptor. Then, the transition functions for the CTMC are induced from the events η ∈E as follows:

Fη[k1,..., ksη ](b) :=
l	l
Fη b 1 [k1],..., b sη [k  ], b	[kl—1],

S	[kl—1], C  1 [k1],..., C
sη [ksη ] ,  (8)


for all (k1,..., ksη ) ∈ K , with kj = (kj,..., kj) such that 1 ≤ hj ≤ n⟨ij ⟩, with
l	l	η	l	1	l	m	m
1 ≤ m ≤ l and j = 1 ... s .
The associated jump vector, denoted by e η[k1,..., ksη ] :=  ej⟨ij⟩[hl] , ∀⟨ij⟩


l	l	l

⎧⎪⎨+1	if ⟨il	l	l	l


= r2,

ej⟨ij⟩[hl]=	−1	if ⟨il	l	l	l
= r1

⎪⎩0	otherwise.

Then, for each ⟨i r⟩r1 −→ ⟨i r⟩r2 ∈ Sη, such that there is a rule for it in C, say
l	l
R = rule(⟨i r⟩r1 −→ ⟨i r⟩r2 ), we define a transition function for each copy of the
l	l
automaton child m of type ⟨ir, rj⟩, contained in the automaton reachable by ⟨kl⟩, for all 1 ≤ m ≤ n⟨ir, rj⟩, as follows:

Fη ⟨ir, s⟩[kr,m | k1,..., ksη ](b) :=
+1 l	l	l	l
⎧⎪ Fη[k1,..., ksη ](b) · bd r	[kr, m]

l	l	⟨il ,s⟩	l
⎪

	

if ⟨ir, s⟩d −→ ⟨ir, s⟩f :: ! ∈ R,

⎪⎪⎩
[kl ,..., kl ] · p · b⟨ir,s⟩[kl , m]	if ⟨il , s⟩
−→ ⟨il , s⟩
:: p ∈ R,


and the corresponding jump vector

e η ⟨ir, s⟩[kl,m | k1,..., ksη ] :=  ej⟨ij⟩[hl] ,

with components



⎪⎩0	otherwise.
l	l	l

Equation (8) represents an instance of the transition function to describe the behaviour of a specific tuple of automata participating in the event. It depends on the local state of the automata involved, cf. (4), and on the state of its parent, which is reached by removing the last element of the position vector kl; the rate may also depend on the automaton’s siblings, cf. (5). Note that, by definition, the siblings are those that can be found within the automaton’s parent, i.e., within the specific copy where the automaton lives. As discussed, the dependence on the siblings’ state is through the total population of automata in a given local state, cf. (6). Finally, the rate may be dependent on the automata’s children in a similar manner. Equation (9) considers the impact on the children. If only one child in a given state is moved, then the rate is adjusted by dividing it by the total number of children. Hence, we are assuming that one child is selected uniformly at random to be updated (this is justified by the assumption of indistinguishability). If each child is selected to move with probability p, then each child sees a fraction p of the total rate.
Example 1 (continued) Let us apply the above deﬁnitions to our running exam- ple. It holds that
Fα[1, 1](b)= λαb1⟨1⟩[1]b1⟨2⟩[1],
Fα[2, 1](b)= λαb1⟨1⟩[2]b1⟨2⟩[1],
reflecting the possibility of the only copy of automaton ⟨2⟩ to interact with either of the two copies of automaton ⟨1⟩. Using the same ordering as in (2) for the state descriptor, these two functions give rise to jump vectors equal to
"−1, +1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, −1, +1 


and
respectively.
"0, 0, 0, 0, 0, 0, −1, +1, 0, 0, 0, 0, −1, +1 ,

Because of the casual map (3), α has an impact on the child automata ⟨1, 1⟩.
For instance, the functions

α	1	1
b1⟨1, 1⟩[1, 1]

F+1⟨1, 1⟩[1, 1 | 1, 1](b)= λαb ⟨1⟩[1]b ⟨2⟩[1] b1⟨1, 1⟩[1, 1] + b1⟨1, 1⟩[1, 2]

and
α
1	1	b1⟨1, 1⟩[1, 2]

F+1⟨1, 1⟩[1, 2 | 1, 1](b)= λαb ⟨1⟩[1]b ⟨2⟩[1] b1⟨1, 1⟩[1, 1] + b1⟨1, 2⟩[1, 2]

give the rate at which each copy of ⟨1, 1⟩ in the ﬁrst copy of automaton ⟨1⟩ sees an α-event. Analogous functions are deﬁned for the second copy of ⟨1⟩. The respective jump vectors are then



and
"0, 0, −1, +1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 

"0, 0, 0, 0, −1, +1, 0, 0, 0, 0, 0, 0, 0, 0 .

Fluid Equations
We now construct a set of differential equations providing a first order approxi- mation of the average evolution of the CTMC. We will define this set of ODEs approximating the expectation of the state variables b = bj⟨il⟩[kl] . These vari- ables, in fact, determine the population variables according to (6). As the state variables b take values in {0, 1}, approximating the expectation corresponds to ap-
proximating the probability of a (random) automaton being in a given state. This is similar to the spatial mean field for Markovian agents considered in [6], although here we provide a different derivation of the fluid approximation.
More specifically, the set of fluid ODEs is constructed, as customary [3], using the drift vector, which describes the instantaneous average variation of system variables in a given state. For an arbitrary system of systems, the drift is defined by
F (b) := Σ	Σ	 e η[k1,..., ksη ]Fη[k1,..., ksη ](b)

l	l
sη c⟨i r⟩ n⟨ir,c⟩



r=1 c=1

m=1


+1  l


l	l	+1 l	l	l

l
(10)

The summations in the drift equation take into account, for each transition η, all its possible instances at the level of interacting automata and all its possible impacts on their children.
Then, the fluid ODE equation is simply
db(t)
= F (b(t)).	(11)
dt
This equation can be seen as an approximate equation for the average of the CTMC. Indeed, the true equation for the average, as obtained from the Dynkin formula (see, for instance, [13]), is
dE[b(t)] = E[F (b(t))].
dt
Hence the fluid equation can be obtained by “pushing” the expectation inside the
(generally non-linear) function F . This operation corresponds to a first-order ap- proximation of the real equation [2,7]. Approximate fluid estimates of performability

measures can be expressed as appropriate deterministic functions (i.e., rewards) of the solutions of (11), as discussed, for example, in [14].
We stress here that this simple definition of the drift and of the fluid equation is possible because of the notation carefully introduced in the previous section.
Example 1 (continued) For the running example, let us assume that α is the only event deﬁned. Then the system of ODEs corresponding to the example, expressed in components, is: 2
b˙1⟨1⟩[1] = −λαb1⟨1⟩[1]b1⟨2⟩[1]
b˙2⟨1⟩[1] = +λαb1⟨1⟩[1]b1⟨2⟩[1]

˙1	1	1
b1⟨1, 1⟩[1, 1]

b ⟨1, 1⟩[1, 1] = −λαb ⟨1⟩[1]b ⟨2⟩[1] b1⟨1, 1⟩[1, 1] + b1⟨1, 1⟩[1, 2]

˙2	1	1
b1⟨1, 1⟩[1, 1]

b ⟨1, 1⟩[1, 1]= +λαb ⟨1⟩[1]b ⟨2⟩[1] b1⟨1, 1⟩[1, 1] + b1⟨1, 1⟩[1, 2]

˙1	1	1
b1⟨1, 1⟩[1, 2]

b ⟨1, 1⟩[1, 2] = −λαb ⟨1⟩[1]b ⟨2⟩[1] b1⟨1, 1⟩[1, 1] + b1⟨1, 1⟩[1, 2]

˙2	1	1
b1⟨1, 1⟩[1, 2]

b ⟨1, 1⟩[1, 2]= +λαb ⟨1⟩[1]b ⟨2⟩[1] b1⟨1, 1⟩[1, 1] + b1⟨1, 1⟩[1, 2]
b˙1⟨1⟩[2] = −λαb1⟨1⟩[2]b1⟨2⟩[1]
b˙2⟨1⟩[2] = +λαb1⟨1⟩[2]b1⟨2⟩[1]

˙1	1	1
b1⟨1, 1⟩[2, 1]

b ⟨1, 1⟩[2, 1] = −λαb ⟨1⟩[2]b ⟨2⟩[1] b1⟨1, 1⟩[2, 1] + b1⟨1, 1⟩[2, 2]

˙2	1	1
b1⟨1, 1⟩[2, 1]

b ⟨1, 1⟩[2, 1]= +λαb ⟨1⟩[2]b ⟨2⟩[1] b1⟨1, 1⟩[2, 1] + b1⟨1, 1⟩[2, 2]

˙1	1	1
b1⟨1, 1⟩[2, 2]

b ⟨1, 1⟩[2, 2] = −λαb ⟨1⟩[2]b ⟨2⟩[1] b1⟨1, 1⟩[2, 1] + b1⟨1, 1⟩[2, 2]

˙2	1	1
b1⟨1, 1⟩[2, 2]

b ⟨1, 1⟩[2, 2]= +λαb ⟨1⟩[2]b ⟨2⟩[1] b1⟨1, 1⟩[2, 1] + b1⟨1, 1⟩[2, 2]
b˙1⟨2⟩[1] = −λαb1⟨1⟩[1]b1⟨2⟩[1] − λαb1⟨1⟩[2]b1⟨2⟩[1] b˙2⟨2⟩[1] = +λαb1⟨1⟩[1]b1⟨2⟩[1] + λαb1⟨1⟩[2]b1⟨2⟩[1]
To show how to obtain a differential model with size (i.e. number of equations) independent of the number of instances of automata, let us compare, for instance, the equations b˙1⟨1⟩[1] and b˙1⟨1⟩[2]. Assuming that the initial conditions are such
that b1⟨1⟩[1](0) = b1⟨1⟩[1](0), it holds that the derivatives are equal at all future time points. By uniqueness of the solution, this implies that the two solutions are also equal. Thus it follows that one of the two equations can be removed. Moreover, this can be done systematically, by inspecting the definition of the drift
and of the instance functions Fη and Fη . We can easily see that, syntactically,
+1  1	sη
the equations are the same for each tuple (kl ,..., kl ) ∈ Kη. This readily implies

2 Where, for compactness, we use the notation b˙ for derivative.

that the equation for the drift is invariant under any permutation of agents that is consistent with the class structure. In particular, the fluid equations (i.e. the derived ODEs) for two agents of the same class are syntactically the same. This observation can be readily turned into the following.
Theorem 3.1 Assume that for all ⟨il⟩, b⟨il⟩[kl](0) = b⟨il⟩[kj](0) for any two kj
l	l
and kl, and that the solution of (11) exists and is unique in [0,T ]. Then, it holds that, for all t ∈ [0,T ]
b⟨il⟩[kl](t)= b⟨il⟩[kSl](t).
Proof. [Sketch] By invariance under permutation of agents of the same class, it follows that if b is class invariant, i.e. b⟨il⟩[kl]= b⟨il⟩[kj], for any ⟨il⟩, kl, kj, then
l	l
F⟨il⟩[kl](b)= F⟨il⟩[k′](b),
i.e. the vector field is also class invariant. It follows that, if b is class invariant, then so is b + hF (b). Fix h > 0 and let x(0) = b(0), and x((k +1)h)= x(kh)+ F (x(kh)). By an easy induction, we can establish that x(kh) is class invariant for any k. It follows that class invariance is preserved by the Euler integration scheme. Hence, by letting h → 0, it is also preserved by ODE solutions.	2	2
The simplified equations can be constructed directly by modifying the template

expressions, observing that Sj
l
[hl—1]= Sj⟨il—1⟩ = n⟨il⟩ˆbj⟨il⟩:

Fη⟨i j⟩(ˆb) :=	n⟨i r⟩Fη ˆb⟨i 1⟩,..., bˆ⟨i kη ⟩, ˆb⟨il—1⟩, S⟨il—1⟩, S⟨i 1⟩,..., S⟨i sη ⟩ .

l	l	l	l
r/=j,r=1
l	l
(12)

This new template equation is obtained summing over all possible siblings of an
agent of class ⟨i j⟩, using the assumption that agents involved in a synchronisation

l
all belong to different classes. The multiplicative factor
  sη
n⟨i r⟩
is the

η	1	sη
r/=j,r=1	l
η ˜1	˜sη

consequence of the fact that F [kl ,..., kl  ](b(t)) = F [kl ,..., kl  ](b(t)) for all
1	sη	˜1	˜sη	j
(kl ,..., kl ) /= (kl ,..., kl ) in Kη, and for each fixed agent of class ⟨il ⟩, there are

sη r/=j,r=1
n⟨i r⟩  instances of η.

Numerical Validation
In this section we present some numerical validation of the fluid approximation scheme presented in the previous section.
Model Description
To illustrate our framework, let us consider a performability model of a system of systems with four automata classes arranged as follows. There are two top-level two-state automata, ⟨1⟩ and ⟨2⟩, which represent the model of a computer and a



Symbol Meaning	Synchronisation set	Function

α1	Computer/user	Sα1 = ,⟨1⟩1 → ⟨1⟩1, ⟨2⟩1 → ⟨2⟩2, Fα1 = λα1 a1⟨1⟩a1⟨2⟩
α2	User delay	Sα2 = ,⟨2⟩2 → ⟨2⟩1,	Fα2 = λα2 a2⟨2⟩

α3	Thread/CPU	Sα3 = ,⟨1, 1⟩2 → ⟨1, 1⟩1	Fα3 = λ
 a2 (1,1⟩ a1 (1,2⟩
α3 X2 (1,1⟩ X1 (1,2⟩

⟨1, 2⟩1 → ⟨1, 2⟩1,	(where X = min(X2⟨1, 1⟩,X1⟨1, 2⟩))
Table 1
Model equations. The parameters λβ , for all symbols β are given positive reals.

user, respectively. Each computer has two automata children ⟨1, 1⟩ and ⟨1, 2⟩, which model software threads and CPUs respectively. Users interact with computers by issuing requests, interposing some think time between successive requests. When- ever a request arrives, a thread is acquired which is triggered to execute on a CPU. When execution is finished, the thread becomes idle again and ready to serve an- other request. Computers, threads, and CPUs may be subject to failure, which is intended to be a logical fault that can be recovered after some time. Formally, we describe the overall model with the automata given by

The events are specified in Table 1. Computer/user interaction is defined according to the law of mass action, which has been used to model connectivity by means of wireless networks [16]. The states labelled 1 in the automata ⟨1⟩ and ⟨2⟩ are therefore assumed to be the operational states where the interaction is possible. The causal map
⟨1⟩1 → ⟨1⟩1 ⇒ ⟨1, 1⟩1 → ⟨1, 1⟩2 :: !
models that, upon a computer/user interaction, one thread that is initially idle (state ⟨1, 1⟩1) starts processing on one CPU, by moving to state ⟨1, 1⟩2. After a user issues a request it moves into state ⟨2⟩2, where it stays with an average



b1⟨1⟩	b1⟨1, 1⟩	b2⟨1, 1⟩	b1⟨1, 2⟩	b1⟨2⟩
Min	Avg. Max	Min	Avg. Max	Min	Avg. Max	Min	Avg. Max	Min	Avg. Max

< 0.01 0.14 3.18 < 0.01 0.45 13.40 < 0.01 0.16 7.57 < 0.01 0.02 0.27 < 0.01 0.62 20.61

Table 2
Relative density errors between ODE solutions and simulation over 500 randomly generated models.

delay 1/λα2 . That is, we are modelling a closed workload of n⟨2⟩ users interpos- ing independent delays. Thread/CPU interaction, modelled by event α3, is re- lated by a dynamics consistent with a multi-server exponential queue with X2⟨1, 1⟩ jobs and X1⟨1, 2⟩ servers with individual service rate equal to λα . The fractions a2⟨1, 1⟩/X2⟨1, 1⟩ and a1⟨1, 2⟩/X1⟨1, 2⟩ indicate the probability that a specific pair of job/server a2⟨1, 1⟩/a1⟨1, 2⟩ are involved. Failure and repair events are assumed to be independent. Notice that, for simplicity, threads are assumed not to fail while they are executing on the CPU (state ⟨1, 1⟩2), but only when they are idle (state
⟨1, 1⟩1).
The aggregated ODE system, exploiting symmetries and multiplicities as in Equation (12), is
b˙1⟨1⟩ = −λα b1⟨1⟩b1⟨2⟩− λϕ	b1⟨1⟩ + λρ	b2⟨1⟩ b˙1⟨2⟩ = −λα b1⟨1⟩b1⟨2⟩ + λα b2⟨2⟩

b˙1⟨1, 1⟩ = − λα1
n⟨1, 1⟩
b1⟨1⟩b1⟨2⟩− λ


ϕ(1,1⟩
b1⟨1, 1⟩

+		λα3 n⟨1, 1⟩
min(b2⟨1, 1⟩n⟨1, 1⟩, b1⟨1, 2⟩n⟨1, 2⟩)+ λ

ρ(1,1⟩
b3⟨1, 1⟩

b˙2⟨1, 1⟩ = − λα3
n⟨1, 1⟩
min(b2⟨1, 1⟩n⟨1, 1⟩, b1⟨1, 2⟩n⟨1, 2⟩)+	λα1
n⟨1, 1⟩
b1⟨1⟩b1⟨2⟩

b˙1⟨1, 2⟩ = −λϕ	b1⟨1, 2⟩ + λρ	b2⟨1, 2⟩
with
b˙2⟨1⟩ = −b˙1⟨1⟩
b˙2⟨2⟩ = −b˙1⟨2⟩
b˙3⟨1, 1⟩ = −b˙1⟨1, 1⟩− b˙2⟨1, 1⟩
b˙2⟨1, 2⟩ = −b˙1⟨1, 2⟩.
These last equations hold because of conservation of mass.

Numerical Experiments
To assess the quality of the approximation, a numerical investigation was conducted on 500 model instances with randomly generated population sizes and rate param- eters. Specifically, n⟨1⟩, n⟨2⟩, n⟨1, 1⟩ were chosen randomly in the range 1,..., 10, whereas n⟨1, 2⟩ was chosen in the range 10,..., 50, in order to model situations



2000

1800

1600

1400

1200

1000

800

600

400

200

0
0	100	200	300	400	500	600


Fig. 2. Scatter plot of total population versus speed-up for the validation dataset. The red line is the linear regression.
where there are on average more threads than processors in a computer. The pa- rameter rates were drawn uniformly at random as follows:
λα1 , λα3 ∈ [0.01, 1],
λα2 , λϕ(1⟩ , λϕ(1,1⟩ , λϕ(1,2⟩ ∈ [0.001, 0.1],
λρ(1⟩ , λρ(1,1⟩ , λρ(1,2⟩ ∈ [0.01, 0.50].
Such a design of the parameter space ensured that the model was exercised under a variety of operating regimes, e.g., different workloads of users and different levels of utilisation of the CPUs and threads.
In these tests we focussed on the model’s steady-state behaviour. We analysed the approximation error by comparing the estimates obtained by stochastic simula- tion of the CTMC (the large state spaces prevented us from performing numerical solution) against ODE numerical integration. Stochastic simulation was conducted with the method of batch means with 5% confidence level at 95% confidence interval. The ODEs were solved using the well-known Runge-Kutta scheme as implemented in Matlab 7.9.0 through the function ode45. As an estimate of equilibrium, each ODE system was solved until a time point T at which the Euclidean norm of the derivative  db(T )/dt  was less than 1E-8. Let Oj⟨i⟩ (resp., Sj⟨i⟩) be the ODE (resp., simulation) estimate of the total population of automata of kind ⟨i⟩ in local state j in equilibrium. The approximation error is defined as
 Oj⟨i⟩− Sj⟨i⟩ 


The error statistics across all 500 models are reported in Table 2. As can be seen from the figures, the approximation is highly accurate in all cases, with a maximum error less than 20% and average errors less than 1%. We wish to point out that these results were obtained with relatively small population sizes, where mean-field approximations are known to perform less well. Even under these conditions, ODE



Original	New

Table 3
Approximation errors and speed-ups of the 4 worst-behaving randomly generated models (columns labelled Original ) against parameterisations with doubled automata populations (columns labelled New ).

analysis turned out to be significantly faster to run. To study this, we measured the wall-clock execution times of ODE analysis and simulation on a machine equipped with an Intel Core i7 2.66 GHz with 8 GB RAM. Figure 2 shows the speed-up versus the total population, exhibiting a linear trend that grows roughly as 1.8 of the population size. The minimum, average, and maximum speed-ups were found to be ca. 11, 422, and 2000, respectively.
In further experiments we tested the hypothesis that scaling up the population sizes leads to a decrease in the approximation errors, which would be consistent with the general behaviour of mean-field/fluid models. For this study, we considered those models with relative density errors greater than 10% (there were four such models amongst those considered in the original experiment) and repeated their analysis after doubling all the populations of all automata classes n⟨1⟩, n⟨1, 1⟩, n⟨1, 2⟩ and n⟨2⟩.
Table 3 shows the maximum errors and the simulation/ODE speed-ups in the original parameterisation against those measured after doubling the automata pop- ulations. In all cases, a substantial decrease of the maximum errors can be noted, thus confirming our hypothesis. As for the speed-up, we remark that the ODE system is the same (specifically, it has 8 equations) but increasing automata pop- ulations makes simulation more expensive. In these models, we registered runtime slowdown by a factor of over three.
In conclusion, these results suggest that the quality of our fluid approximation is generally satisfactory already with relatively small automata populations, with a tendency to improve significantly with larger populations, where it becomes in- creasingly more convenient than stochastic simulation.
Conclusions
In this paper we introduced an automata-based description of systems of systems, with automata contained in other automata. The dynamics of these automata is described by a set of Markovian transitions (in continuous time), with rates depending on the state of sibling automata, but also on the state of the parent

(downward influence) and of the child nodes (upward influence). Furthermore, causal maps allow us to specify how a transition at a given level can propagate its effect downwards in the containment hierarchy. We also provide a way to flatten a model, and construct a flattened CTMC. Then, we consider how to construct a fluid approximation of this flattened CTMC, and exploit the symmetry of the so-obtained ODEs to lump the fluid state space, reducing the number of equations from one equation per state of each different automata present in the model to one equation per state of each automata class. This reduction is polynomial in the population size and exponential in the nesting level and allows us to approximate efficiently the average of the process. We also discuss the quality of the approximation in a hierarchic model of a computer, showing a very good trade-off between accuracy and computational resources needed. Indeed, in the randomly generated models that we consider the lumped fluid analysis is at least an order of magnitude faster than a simulation based method, even for relatively small populations of computer and processes.
There are several directions for future work. An interesting area of applicability could be biological processes. but for this the model will need to be extended to ex- plicitly treat birth and death events, in order to describe and investigate systems in which the populations of automata are not static throughout the life of the system. Second, we will consider how lumpability can be extended to higher-order moment approximations. Finally, we would like to lift convergence results for Markov pop- ulation models to our setting of nested automata, for instance by studying which scaling of replica sizes leads to decrease in the approximation error.
Acknowledgement
This work has been partially supported by the EU project QUANTICOL, 600708, by DFG project FEMPA, and by the project FRA-UNITS. The authors thank Stephen Gilmore for his assistance in preparing the paper.

References
Bernardo, M. and R. Gorrieri, A tutorial on EMPA: A theory of concurrent processes with nondeterminism, priorities, probabilities and time, Theor. Comput. Sci. 202 (1998), pp. 1–54.
Bortolussi, L., On the approximation of stochastic concurrent constraint programming by master equation, ENTCS 220 (2008), pp. 163–180.
Bortolussi, L., J. Hillston, D. Latella and M. Massink, Continuous approximation of collective systems behaviour: a tutorial, Performance Evaluation 70 (2013), pp. 317–349.
Buchholz, P., A class of hierarchical queueing networks and their analysis, Queueing Systems 15 (1994),
pp. 59–80.
Buchholz, P., An adaptive aggregation/disaggregation algorithm for hierarchical Markovian models, European Journal of Operational Research 116 (1999), pp. 545–564.
Cerotti, D., M. Gribaudo, A. Bobbio, C. Calafate and P. Manzoni, A markovian agent model for fire propagation in outdoor environments, in: Computer Performance Engineering - 7th European Performance Engineering Workshop, EPEW 2010, Lecture Notes in Computer Science 6342 (2010),
pp. 131–146.

Hayden, R. A. and J. T. Bradley, A fluid analysis framework for a Markovian process algebra, Theor. Comput. Sci. 411 (2010), pp. 2260–2297.
Hermanns, H. and M. Rettelbach, Syntax, semantics, equivalences, and axioms for MTIPP, in:
Proceedings of PAPM, Erlangen, 1994, pp. 71–87.
Hillston, J., “A compositional approach to performance modelling,” Cambridge University Press, 1996.
Kim, D. S., F. Machida and K. S. Trivedi, Availability modeling and analysis of a virtualized system, in: PRDC, 2009, pp. 365–371.
Lanus, M., L. Yin and K. S. Trivedi, Hierarchical composition and aggregation of state-based availability and performability models, IEEE Transactions on Reliability 52 (2003), pp. 44–52.
Plateau, B. and K. Atif, Stochastic automata network for modeling parallel systems, IEEE Trans. Software Eng. 17 (1991), pp. 1093–1108.
Singh, A. and J. Hespanha, Lognormal moment closures for biochemical reactions, in: Proceedings of 45th IEEE Conference on Decision and Control, 2006.
Tribastone, M., J. Ding, S. Gilmore and J. Hillston, Fluid rewards for a stochastic process algebra, IEEE Trans. Software Eng. 38 (2012), pp. 861–874.
Tschaikowski, M. and M. Tribastone, Exact fluid lumpability for Markovian process algebra, in:
CONCUR, 2012, pp. 380–394.
Zhang, X., G. Neglia, J. Kurose and D. Towsley, Performance modeling of epidemic routing, Computer Networks 51 (2007), pp. 2867–2891.
