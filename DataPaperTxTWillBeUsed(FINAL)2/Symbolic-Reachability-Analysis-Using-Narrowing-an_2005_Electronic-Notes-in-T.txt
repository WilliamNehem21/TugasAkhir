Electronic Notes in Theoretical Computer Science 117 (2005) 153–182 
www.elsevier.com/locate/entcs


Symbolic Reachability Analysis Using Narrowing and its Application to Verification of Cryptographic Protocols *
Jos´e Meseguer and Prasanna Thati
Department of Computer Science, UIUC, Urbana-Champaign, USA

Abstract
Narrowing was introduced, and has traditionally been used, to solve equations in initial and free algebras modulo a set of equations E. This paper proposes a generalization of narrowing which can be used to solve reachability goals in initial and free models of a rewrite theory R. We show that narrowing is sound and weakly complete (i.e., complete for normalized solutions) under reasonable executability assumptions about R. We also show that in general narrowing is not strongly com- plete, that is, not complete when some solutions can be further rewritten by R. We then identify several large classes of rewrite theories, covering many practical applications, for which narrowing is strongly complete. Finally, we illustrate an application of narrowing to analysis of cryptographic protocols.
Keywords: Rewriting logic, narrowing, reachability, security protocols.


Introduction
This paper addresses the following technical question. Given a rewrite theory R satisfying reasonable assumptions, is there a general deductive procedure to solve reachability problems for R? By a “reachability problem” we mean
the obvious, that is, an existential formula
(∃−→x ) t →∗ t'
or, more generally, an existentially quantified conjunction of such reachability goals. Since R typically specifies either a concurrent system or an inference
  Research supported by ONR Grant N00014-02-1-0715 and NSF Grant CCR-0234524
1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.024


system, the meaning and interest of solving such goals is quite obvious. The terms t and t' denote sets of states in the initial model of R, and we want to know for what subset of the states denoted by t we can reach the set denoted by t'. Under finite state assumptions, questions of this kind can be answered by model checking techniques [9]. Our interest, however, is in general methods that do not require finiteness assumptions and can complement such model
checking techniques. In this paper, we generalize narrowing from a technique
for solving equality goals [16,21,23] to one for solving reachability goals; indeed equational narrowing goals can be viewed as a special case of reachability goals.
That narrowing in this more general sense should be developed as a method for analyzing concurrent systems and should fit within a wider spectrum of analysis capabilities, was first proposed in [12]. One can view narrowing as a new form of “symbolic model checking”, available also for infinite state systems, where the word “symbolic”, instead of having the more restricted sense of representing finite sets of states by Boolean propositions, is widened to mean the representation of possibly infinite sets of states by terms with logical variables. These methods could even have useful applications in the case of finite-state systems that are too large to analyze by standard model checking techniques.
There are indeed a number of techniques actively investigated to analyze infinite state systems, including model checking for suitable subclasses, e.g. [4,5,15,17], abstraction techniques, e.g. [10,26,19,25,40], tree-automata based reachability analyses, e.g. [18,35], and theorem proving, e.g. [37,36]. We think that narrowing is a promising additional technique to be further explored. In- deed, narrowing like techniques have already been shown useful in the analysis of cryptographic protocols [2,22,29].
We formally define narrowing for order-sorted unconditional rewrite the- ories of the form R = (Σ, E, R) where E = ∆ ∪ B, with ∆ confluent and
terminating modulo B. We prove soundness of solutions found for reachabil- ity problems using narrowing, and also show that the narrowing procedure is weakly complete in the following sense: if ρ is a solution of a given reacha- bility problem and ρ is normalized with respect to rewriting with the rules R
modulo E, then the narrowing procedure finds a solution η that subsumes ρ modulo E. This weak completeness result holds under reasonable executabil- ity assumptions about the given rewrite theory.
We also show that in general, narrowing is not complete in the following stronger sense: if ρ is a (not necessarily normalized) solution of a reachability goal, then the narrowing procedure finds a solution η that subsumes ρ modulo
E. Hence the “weakness” in completeness of narrowing. This does not hold in general, as we show by several examples. The point is that in equational


narrowing [23], confluence and termination are reasonable assumptions; by contrast, the rewrite rules R specifying a concurrent system are typically non- confluent and nonterminating; indeed, termination may often have the mean- ing of an undesirable deadlock. All this implies that in general rewriting may also happen in the substitutions themselves, making narrowing incomplete in the strong sense.
A key question to investigate is identifying interesting classes of rewrite theories for which narrowing is complete in the strong sense. We prove that several important classes covering many practical applications have strongly
complete solutions to reachability goals by narrowing. The first important such class is that of topmost rewrite theories, that is, theories in which terms can only be rewritten at the top.  We then show how other large classes
of rewrite theories, including, for example, most object-oriented distributed systems, a wide range of Petri net models, grammars, and many reflective distributed systems structured with a “Russian dolls” architecture [32] can be transformed into equivalent topmost rewrite theories with the same set of solutions for a given reachability problem. We furthermore establish a strong completeness result for the class of rewrite theories R = (Σ, ∆ ∪ B, R) such that equations in B are regular (LHS and RHS have the same set of variables) and linear (LHS and RHS are linear terms), ∆ is confluent and terminating modulo B, and R is right linear (RHS is linear).
As an example application, we show how narrowing can be used for analy- sis of security protocols. Many security protocol properties, such as the secrecy and authenticity, can be characterized as reachability problems. We show how the strong completeness results for topmost theories can be exploited to verify
the secrecy property of a protocol when the number of protocol sessions is bounded. This technique can also be adapted to verify other security proper- ties, including authenticity. A noteworthy feature of our analysis technique is that narrowing modulo equations provides a general procedure that can uni- formly handle analysis of security protocols that employ cryptographic prim- itives with visible algebraic properties that can be exploited by an intruder (such as in the case of xor encryption and Diffie-Hellman exponentiation) [7,8,11,34,39].

Background
An order-sorted signature Σ is defined by a set of sorts S, a partial or- der relation of subsort inclusion ≤ on S, and an S∗ × S-indexed family of
{Σw,s}(w,s)∈S∗×S of operations. We denote f ∈ Σw,s by f : w → s. We define a relation ≡ on S as the smallest equivalence relation that such that


s ≤ s' implies s ≡ s'. We assume that each equivalence class of sorts contains a top 1 sort that is a supersort of every other sort in the class. Formally, for every sort s we assume that there is a sort [s] such that s ≡ s' implies
s' ≤ [s]. Furthermore, for each f : s1 × ... × sn → s we assume there is also an f : [s1] × ... × [sn] → [s]. We require the signature Σ to be sensible, i.e., whenever we have f : w → s and f : w' → s' with w, w' of equal length then w ≡ w' implies s ≡ s'.
A Σ-algebra is defined by an S-indexed family of sets A = {As}s∈S such that s ≤ s' implies As ⊆ As' , and for each function f : w → s with w = s1 ×

.. .×sn a function fw,s : As ×.. .×As
→ As. Further, we require that subsort

overloaded operations agree, i.e., for each f : w → s and (a1,... , an) ∈ Aw we
require fw,s(a1,... , an) = f [w],[s](a1,... , an), where if w = s1 × ... × sn, then
A	A
[w] = [s1] × ... × [sn]. We assume a family X = {Xs}s∈S of infinite sets of
variables such that s /= s' implies Xs ∩ Xs' = ∅, and the variables in X are different from constant symbols in Σ. We denote the set of ground Σ-terms and Σ-terms of sort s by TΣ,s and TΣ(X)s respectively. We write TΣ for the Σ-algebra of ground terms over Σ, and TΣ(X) for the Σ-algebra of terms with variables from the set X.
We use a finite sequence of positive integers, called a position, to denote an access path in a term. We let ω range over positions. For t ∈ TΣ(X) let Var(t), Pos(t), FuPos(t) denote the set of variables, positions, and non-variable positions in t, respectively. The root of a term is at position ϵ. We denote the
subterm of t at position ω by t|ω.
A substitution is a mapping σ : X → TΣ(X) which maps variables to terms of the same sort, and which is different from the identity for a finite subset Dom(σ) of X. We denote the homomorphic extension of σ to TΣ(X) also by
σ. The set of variables introduced by σ is Ran(σ) = ∪x∈Dom(σ)Var(σ(x)). The restriction of a substitution σ to a set of variables V is defined as



σ|V
(x) = ⎧⎨ σ(x)	if x ∈ V
⎩ x	otherwise


We say that a substitution σ is away from a set of variables V if Ran(σ) ∩ V =
∅. For substitutions σ, ρ such that Dom(σ) ∩ Dom(ρ) = ∅ we define their union



1 Note that this top sort plays the role of an “error supersort”, or a kind in membership equational logic [31], although in some cases there may not be any real “error expressions” in this top sort because all terms in it happen to be well-defined.

as
σ(x)	if x ∈ Dom(σ) (σ ∪ ρ)(x) =	ρ(x)	if x ∈ Dom(ρ)
⎪⎪⎩ x	otherwise
A Σ-equation is an expression of the form t = t' where t, t' ∈ TΣ(X)[s] for
an appropriate [s]. Order-sorted equational logic has a sound and complete in-
ference system E ▶Σ (see [31]) inducing for any set of variables Y a congruence

relation =Y
on terms t, t' ∈ TΣ(Y ): t =Y
t' if and only if E ▶Σ (∀Y )t = t'.

For the sake of simplicity, we will assume that all sorts in Σ are non-empty, i.e., that for each sort there is a ground term of that sort. In that case, if
t, t' ∈ TΣ(X) ∩ TΣ(Y ) then t =X t' if and only if t =Y t'. Therefore, the super-
E	E
script notation =Y becomes unnecessary and we can just write =E. Because of our assumptions about the signature Σ it is the case that t =E t', t ∈ TΣ(X)s, and t' ∈ TΣ(X)s' implies s ≡ s'.
An equation t = t' is said to be (i) regular if Var(t) = Var(t'), (ii) sort preserving if for each substitution σ we have σ(t) ∈ TΣ(X)s if and only if σ(t') ∈ TΣ(X)s, (iii) sort-decreasing if for each substitution σ we have σ(t) ∈ TΣ(X)s implies σ(t') ∈ TΣ(X)s, (iv) left (or right) linear if t (resp. t') is linear (i.e., each variable occurs at a single position), and (v) linear if it is both left
and right linear. A set of equations E is said to be regular, or sort decreasing, or sort preserving, or (left or right) linear, if each equation in it is so.
The E-subsumption preorder  E on TΣ(X) is defined by t  E t' if there is a substitution σ such that σ(t) =E t'; such a substitution σ is said to be an E-match from t to t'. For substitutions σ, ρ and a set of variables V we define σ|V =E ρ|V if σ(x) =E ρ(x) for all x ∈ V , and σ|V   E ρ|V if there is a
substitution η such that ρ|V =E (η ◦ σ)|V . The following is a useful lemma.
Lemma 2.1 ([3]) For substitutions σ, ρ and sets of variables V ⊆ W let Dom(σ) ∩ W ⊆ V and Ran(σ) ∩ W = ∅. Then σ|V  E ρ|V implies σ|W  E ρ|W .	 
A system of equations F is an expression of the form t1 = t' ∧ ... ∧ tn = t' ,
1	n
'
An E-uniﬁer for F is a substitution σ such that σ(ti) =E σ(t') for 1 ≤ i ≤ n. For V = Var(F ) ⊆ W , a set of substitutions CSUE(F, W ) is said to be a complete set of unifiers of F away from W if
Each σ ∈ CSUE(F, W ) is an E-unifier of F .
For any E-unifier ρ of F there is a σ ∈ CSUE(F, W ) such that σ|V  E ρ|V .
For all σ ∈ CSUE(F, W ), Dom(σ) ⊆ V and Ran(σ) ∩ W = ∅.


An E-unification algorithm is complete if for any given system of equations it generates a complete set of E-unifiers. Note that this set need not be finite. A unification algorithm is said to be ﬁnite and complete if it terminates after generating a finite and complete set of solutions.
A rewrite rule is an expression of the form l → r where l, r ∈ TΣ(X)[s] for an appropriate [s]. An (unconditional) order-sorted rewrite theory is a triple R = (Σ, E, R) with Σ an order-sorted signature, E a set of Σ-equations, and R a set of rewrite rules. We only consider rewrite theories R where for each rule l → r in R we have Var(r) ⊆ Var(l). We define the one-step rewrite relation on TΣ(X) as follows: t →R t' if there is an ω ∈ Pos(t), a rule l → r in R, and a substitution σ such that t|ω = σ(l) and t' = t[ω ← σ(r)]. The reader
may check that because of our assumption about the signature Σ, it is the case that t' is always well-sorted, and t ∈ TΣ(X)[s] implies t' ∈ TΣ(X)[s]. Let →R/E
be the relation =E ◦ →R ◦ =E. A term t ∈ TΣ(X) is called R/E-irreducible if
there is no t' ∈ TΣ(X) such that t →R/E t'. Note that the reflexive transitive

closure relation →∗
defines the inferences of the rewrite theory R in the

order-sorted version of the usual sequent-style presentation [30]. That is, for
any t, t' ∈ TΣ(X)[s] we have t →∗	t' if and only if R ▶ [t]E → [t']E, where
[t]E denotes the equivalence class of t modulo E.
For substitutions σ, ρ and a set of variables V we define σ|V →R ρ|V if there is x ∈ V such that σ(x) →R ρ(x) and for all other y ∈ V we have σ(y) = ρ(y). The relation →R/E on substitutions is defined as =E ◦ →R ◦ =E. A substitution σ is called R/E-normalized if σ(x) is R/E-irreducible for all
x; note that this is a stronger condition than saying there is no substitution ρ
such that σ|X →R/E ρ|X (because rules in R need not be sort-decreasing).

Reachability Goals
Given an order-sorted rewrite theory R = (Σ, E, R), a reachability goal G is
a conjunction of the form t1 →∗ t' ∧ ... ∧ tn →∗ t' , where for 1 ≤ i ≤ n,
ti, t' ∈ TΣ(X)[s ] for appropriate [si]. We say that ti are the sources of the
i	i
substitution σ is an R-solution of G (or just a solution for short, when R is

clear from the context) if σ(ti) →∗
to be the system of equations t1 = t'
σ(t') for 1 ≤ i ≤ n. We define E(G)
∧ ... ∧ tn = t' . We say σ is a trivial

solution of G if it is an E-unifier for E(G). We say G is trivial if the identity
substitution id is a trivial solution of G. Thus, σ is a trivial solution of G if and only if σ(G) is trivial.
For goals G : t1 →∗ t2 ∧ ... ∧ t2n−1 →∗ t2n and G' : t' →∗ t' ∧ ... ∧ t'	→∗
1	2	2n−1
'	we say G =E G' if ti =E t' for all 1 ≤ i ≤ 2n. We say G →R G' if there


is an odd i such that ti →R t' and for all j /= i we have tj = t' . The relation
i	j
→R/E over goals is defined as =E ◦ →R ◦ =E.
Lemma 3.1 σ is a solution of a reachability goal G if and only if σ(G) →∗
G' for some trivial goal G'.	 
A set of substitutions Γ is said to be a complete set of R-solutions of G
if (i) every σ ∈ Γ is an R-solution of G, and (ii) for any R-solution ρ of
G there is a σ ∈ Γ such that σ|Var(G)  E ρ|Var(G). We are interested in finding a complete set of R-solutions for a given goal G and an order-sorted
(unconditional) rewrite theory R.
Since E-congruence classes can be infinite, →R/E-reducibility is undecid- able in general. One way to get around this problem is to “implement” R/E- rewriting by a combination of rewriting using oriented equations and rules. Such an approach was proposed, for instance, by Patrick Viry [42] (for the unsorted case). We adopt this approach in this paper.
We assume that E = ∆ ∪ B such that (i) B is regular and sort preserving,
(ii) B has a finite and complete unification algorithm (note that this implies that B-matching is decidable) and ∆ ∪ B has a complete (and not necessarily finite) unification algorithm 2 , (iii) for each t = t' in ∆ we have Var(t') ⊆
Var(t), and (iv) ∆ is sort-decreasing, and is confluent and terminating modulo
B.
We define the relation →∆,B on TΣ(X) as follows: t →∆,B t' if there is an ω ∈ Pos(t), l = r in ∆, and a substitution σ such that t|ω =B σ(l) and t' = t[ω ← σ(r)]. Note that, since B is sort-preserving and ∆ is sort-decreasing,
it is the case that t' is well-sorted, and t ∈ TΣ(X)s implies t' ∈ TΣ(X)s. The relation →R,B is similarly defined, and because of our assumption about the signature Σ, it is the case that t →R,B t' implies t' is well-sorted, and t ∈ TΣ(X)[s] implies t' ∈ TΣ(X)[s]. We define →R∪∆,B as →R,B ∪ →∆,B. Note that, since B-matching is decidable, →∆,B, →R,B, and →R∪∆,B are decidable. These three relations are lifted to goals and substitutions as expected. R ∪ ∆, B- normalized (and similarly R, B or ∆, B-normalized) substitutions are defined as expected.
The idea is to implement →R/E on (terms and goals) using →R∪∆,B. For this to work, we need the following additional assumptions.
We assume that →∆,B is coherent with B, i.e., ∀t1, t2, t3 we have t1 →+	t2

and t1 =B t3 implies ∃t4, t5 such that t2 →∗
t4, t3 →+
t5 and t4 =E t5



2 With certain additional assumptions such as B-coherence of ∆,B rewriting [23], it is the case that ∆ ∪ B has a complete unification algorithm by equational narrowing. But we also allow the possibility of special-purpose unification algorithms for ∆ ∪ B.



[23].


+
∆,B


∆,B  t4

||B	||E
t3	−→+	t5
We assume →R,B is E-consistent with B, i.e. ∀t1, t2, t3 we have t1 →R,B t2
and t1 =B t3 implies ∃t4 such that t3 →R,B t4 and t2 =E t4. We also assume
→R,B is E-consistent with →∆,B, i.e.  ∀t1, t2, t3 we have t1 →R,B t2 and

∗
∆,B
t3 implies ∃t4, t5 such that t3 →∗
t4 and t4 →R,B t5 and t5 =E t2.



t1 →R,B t2
t1	−→R,B	t2

||B	||E
t3 →R,B t4
*
∆,B
∗
∆,B
||E
→R,B t4

(a) E-consistency of →R,B with B	(b) E-consistency of →R,B with →∆,B
The following lemma links →R/E with →∆,B and →R,B. It was originally established by Patrick Viry for unsorted unconditional rewrite theories [42], but lifts to our order-sorted setting in a straightforward way.
Lemma 3.2 Let R = (Σ, ∆∪ B, R) be an order-sorted rewrite theory with all

the properties assumed above. Then t1 →R/E t2 if and only if t1 →∗
→R,B t3

for some t3 =E t2.	 

Thus t1 →∗
t2 if and only if t1 →∗
t3 for some t3 =E t2.  The

reader can check that this can be lifted to goals as G1 →∗
G2 if and only

∗
R∪∆,B
G3 for some G3 =E G2. All the assumptions about R listed

in this section, will apply to the rest of the paper, unless explicitly mentioned
otherwise.

Narrowing: Soundness and Weak Completeness
The R, B-narrowing relation on T (X) is defined as follows: t ~σ	t' if there is ω ∈ FuPos(t), a rule l → r in R, where we assume Var(t) ∩ Var(l) = ∅, and σ ∈ CSUE(t|ω = l, V ) for a set of variables V containing Var(t) and Var(l), such that t' = σ(t[ω ← r]). This is lifted to reachability goals as follows. Let

G : t1 →∗ t2 ∧ ... ∧ t2n−1 →∗ t2n and G' : t'
→∗ t' ∧ ... ∧ t'
→∗ t'
, and

1	2	2n−1	2n

suppose that Var(G) ⊆ V . We define G ~σ
R,B
G', if there is an odd i such

that t ~σ	t' for some σ that is away from Var(G), and for all j /= i we have
i	R,B  i
σ ∗

' = σ(tj). We write G ~
G' if either G = G' and σ = id, or there is a


sequence of derivations G ~σ1	... ~σn	G' such that σ = σ ◦ σ  ◦ ... ◦ σ . Similarly, ∆, B-narrowing and R ∪ ∆, B-narrowing relations are defined on terms and goals, as expected.
∆, B-narrowing is known to give a sound and complete procedure for ∆∪B- unification [23]. We show that R ∪ ∆, B-narrowing gives a sound but only weakly complete (in the sense made precise below) procedure for computing
the solutions of reachability goals.

Soundness
We first consider the soundness problem. Following the idea in [23], we asso- ciate with each R∪∆, B-narrowing derivation a R∪∆, B-rewriting derivation, and then appeal to Lemma 3.2 to complete the argument. First we consider one-step narrowing derivation on terms. The proof of the following lemma is the same as that for the correspondence between ∆, B-narrowing and ∆, B- rewriting, which can be found in [23].
Lemma 4.1 t ~σ	t' implies σ(t) →	t'.	 
This can be lifted to narrowing derivations on goals as follows.

Lemma 4.2 G ~σ ∗
G' implies σ(G) →∗
G'.

This gives us the following soundness theorem.

Theorem 4.3 (soundness) Let G ~σ ∗
G', and let η be a trivial solution

of G', then η ◦ σ is a solution of G.

Weak Completeness
The idea behind proving weak completeness is to associate with each R∪∆, B- rewriting derivation a R∪∆, B-narrowing derivation. It is possible to establish such a correspondence only under certain assumptions, and hence the weakness in completeness. First we consider one-step rewriting on terms.
Lemma 4.4 Let ρ be an R ∪ ∆, B-normalized substitution, and let V be a ﬁnite set of variables containing Var(t). Let ρ(t) →R∪∆,B t' using the rule l → r in R or the equation l = r in ∆. Then there are σ, t'',η such that:
t ~σ R∪∆,B t'' using the same rule or equation.
η is R ∪ ∆, B-normalized
η(t'') =B t', and
ρ|V =B (η ◦ σ)|V


Next, we associate to a one-step R/E-rewrite an R ∪ ∆, B-narrowing deriva- tion.
Lemma 4.5 Let ρ be an R ∪ ∆, B-normalized substitution, and let V be a ﬁnite set of variables containing Var(t). Then ρ(t) →R/E t' implies that there are σ1, σ2, t'',η such that:

t ~σ1 ∗
~σ2

R,B
t''

η is R ∪ ∆, B-normalized
η(t'') =E t', and
ρ|V =E (η ◦ σ2 ◦ σ1)|V
The above lemma can be lifted to narrowing derivations on goals as follows.
Lemma 4.6 Let ρ be an R∪∆, B-normalized substitution, V be a ﬁnite set of
variables containing Var(G), and let ρ(G) →∗	G'. Then, there are σ, G'',η 

such that:
~σ ∗
R∪∆,B


G''

η is R ∪ ∆, B-normalized
η(G'') =E G'.
ρ|V =E (η ◦ σ)|V
We are now ready to prove the weak completeness result.
Theorem 4.7 (weak completeness) Let ρ be an R/E-normalized solution of a reachability goal G, and let V be a ﬁnite set of variables containing Var(G). Then there are σ, G' such that:

~σ ∗
R∪∆,B
G' and G' has a trivial solution.

(ii) There is η ∈ CSUE(E(G'),V ∪ Ran(σ)) such that (η ◦ σ)|V  E ρ|V
We shall see later that Theorem 4.7 need not hold for substitutions ρ that are not R/E-normalized, and hence narrowing is only weakly complete.

A Weakly Complete Algorithm for Reachability Goals
Theorem 4.8 For a reachability goal G, let V be a ﬁnite set of variables containing Var(G), and let Γ be the set of all substitutions of the form η ◦ σ,
where G ~σ ∗	G' and η ∈ CSU (E(G'),V ∪ Ran(σ)). Then Γ is a complete
E
set of solutions of G with respect to R/E-normalized solutions.
Proof. From Theorems 4.3 and 4.7.	 


This theorem provides a general algorithm which builds a narrowing tree starting from G, to find all R/E-normalized solutions. Nodes in this tree correspond to goals, while edges correspond to one-step R ∪ ∆, B-narrowing derivations. Since there can be infinitely long narrowing derivations, the algo-
rithm has to expand the tree in a fair manner to cover each possible derivation.
Further, note that for each node in the tree, the algorithm invokes a ∆ ∪ B- unification algorithm, which is not required to be finitary, i.e., the unification algorithm can return an infinite set of unifiers. Therefore, the execution of this unification algorithm is to be interleaved in a fair manner with the expansion of the narrowing tree. Finally, we note that it is important to study appro-
priate strategies [3] that, while preserving completeness, make this narrowing
procedure as efficient as possible.

Incompleteness of Narrowing
Narrowing is complete only with respect to R/E-normalized solutions. It is incomplete in general, as shown by the following examples.
Example 4.9 Let R = (Σ, ∅, R), where the signature Σ has a single sort, and unary function symbols s, f, g, and R has the following two rules:

s(x) → s2(x)	f (s2(x)) → g(s(x))

The reachability goal G : f (x) →∗ g(x) has solutions σk = {sk(y)/x} for k ≥ 1 (none of which is R/E-normalized). But narrowing returns only σ2 as a solution, and it is not the case that σ2|{x}  ∅ σ1|{x}.
Example 4.10 Consider R = (Σ, ∅, R), where Σ has a single sort, and con- stants a, b, c, d, and a binary function symbol f , and R has the following three rules:
a → b	a → c	f (b, c) → d
The reachability goal G : f (x, x) →∗ d has σ = {a/x} as a solution. But G
has neither a trivial solution nor a narrowing derivation starting from it.

Some Strong Completeness Results
It is possible to obtain strong completeness results for useful classes of rewrite theories. We consider several such classes, including topmost rewrite theories, classes semantically equivalent to topmost rewrite theories, and linear rewrite theories.


Topmost Rewrite Theories
We say R = (Σ, E, R) is a topmost rewrite theory if in one of the equivalences classes of S/ ≡, there is a top sort State such that:
Each rule in R rewrites terms of sort State, i.e., for each l → r in R it is the case that l ∈ TΣ(X)State and r ∈ TΣ(X)State.
For each f : [s1] × ... × [sn] → s in Σ, it is the case that [si] /= State for
1 ≤ i ≤ n.
These two conditions force every rewrite to happen at the top of a term. More precisely, the relations →R/E and →R,E coincide, and if t →R,E t' then this rewrite happens at the position ϵ in t. Thus, R/E-reducibility is decidable if we have an E-matching algorithm, and therefore the assumptions about the rewrite theory R in Section 3 can be simplified as follows. We assume (in
this subsection only) that R = (Σ, E, R) has the following properties: (i) R is topmost, (ii) the equations in E do not have variables of sort State, and (iii) E has a complete unification algorithm. (In particular, the other assumptions
in Section 3 are not necessary.)
We show that R, E-narrowing provides a sound and strongly complete procedure for solving reachability goals in rewrite theories with the properties (i)–(iii) listed above. The argument for soundness is the same as in Section 4. For completeness, we first establish a stronger version of Lemma 4.5, in which the substitution ρ is no longer required to be normalized.
Lemma 5.1 Let t be a term that is not a variable, and let V be a set of variables containing Var(t). For some substitution ρ, let ρ(t) →R/E t' using

the rule l → r in R. Then there are σ, η, t'' such that t ~σ
R,E
t'' using the same

rule, t'' is not a variable, η(t'') =E t', and ρ|V =E (η ◦ σ)|V .
Using the above Lemma, by an argument similar to that in Section 4, we get the following theorem.

Theorem 5.2 (topmost strong completeness) Let G : t1 →∗ t'
∧ ... ∧

tn →∗ t'
be a reachability goal such that for 1 ≤ i ≤ n, ti is not a variable,
σ ∗

and let ρ be a solution of G. Then there are σ, G' such that G ~R,E G' and there is η ∈ CSUE(E(G'),V ∪ Ran(σ)) such that (η ◦ σ)|V  E ρ|V .	 
Thus for a goal G, none of whose sources is a variable, the set of all

substitutions η ◦ σ such that G ~σ
R,E
G' and η ∈ CSUE
(E(G'),V ∪ Ran(σ)),

where V is a finite set of variables containing Var(G), is a complete set of
solutions of G. As in Section 4, this gives us a general algorithm for computing a complete set of solutions, by building a narrowing tree starting from G. Note that since the E-unification algorithm can return an infinite set of unifiers,


the narrowing tree can be infinitely branching. Thus, to ensure completeness, it is essential to expand the narrowing tree in a fair manner.
In practice, we can often transform a given rewrite theory into a topmost rewrite theory which is in some sense equivalent to it, and then exploit the completeness result above. In the following, we consider several classes of theories for which this can be done.

Topmost modulo associativity, commutativity, and identity (ACU):
An order-sorted rewrite theory R = (Σ, E, R) is said to be topmost modulo ACU if in one of the equivalence classes of S/ ≡, there is a top sort Conﬁg such that:
Each l → r in R is such that l, r ∈ TΣ(X)Conﬁg.
There is only one operator whose arity includes a sort s such that [s] = Conﬁg, namely,	⊗	: Conﬁg × Conﬁg → Conﬁg.  The operator ⊗ is associative and commutative, and has identity null.
Many order-sorted rewrite theories specifying object-oriented systems are top- most modulo ACU, in particular, object-oriented systems involving flat con- figurations in which the distributed state is a multiset of objects and messages, are typically topmost modulo ACU. Another large class of examples is pro- vided by different styles of Petri nets [41].
A theory R that is topmost modulo ACU can be transformed into a corre- sponding topmost theory Rˆ = (Σˆ, E, Rˆ) as follows. The signature Σˆ extends Σ by adding a new top sort State, and a single new operator { } : Conﬁg → State. The set Rˆ contains for each rewrite rule l → r in R the rewrite rule
{l ⊗ C} → {r ⊗ C}, where C is a fresh variable of sort Conﬁg. This transfor-
mation satisfies the following equivalence.
Lemma 5.3 Let R be a rewrite theory that is topmost modulo ACU. Then, for any terms t, t' of sort Config we have t →R/E t' if and only if {t} →Rˆ/E {t'}. 
The above lemma implies that the set of R-solutions of G : t1 →∗ t' ∧ ... ∧
tn →∗ t' is the same as the set of Rˆ-solutions of Gˆ : {t1} →∗ {t' }∧.. .∧{tn} →∗
{t' }. Thus, to find a complete set of R-solutions of G, we can just find a complete set of Rˆ-solutions for the goal Gˆ.

Note that the above transformation R '→ Rˆ
can easily be generalized to

operators ⊗ satisfying the same assumptions, except that ⊗ satisfies only axioms of associativity and commutativity (AC ), or associativity and identity (AU ), or associativity alone (A). This makes these results available
also for many string-processing rewrite theories, such as grammars. In each of these cases, the transformation R '→ Rˆ has to add the appropriate “extension


rules”. For example, for AC we have to also add the rule {l} → {r}; for AU we just add {C ⊗ l ⊗ C'} → {C ⊗ r ⊗ C'}; and for A we must also add {C ⊗ l} → {C ⊗ r}, {l ⊗ C} → {r ⊗ C'}, and {l} → {r}. With these modifications, the results above also hold for the AC, AU, and A cases as well.

Russian Dolls of Non-increasing Depth:
Many distributed object-based systems are not flat configurations; they are instead structured configurations in which multisets of objects and mes- sages can themselves contain nested submultisets encapsulated by appropriate
boundary operators. Meseguer and Talcott [32] call such structured configura- tions Russian dolls, to emphasize their nested and recursive character. Since in a system of this kind rewrites can happen at any level of nesting, the results just developed for theories that are topmost modulo ACU do not directly ap- ply. However, under the reasonable assumptions that the equations do not change the depth of nesting, and the rewrite rules do not increase the depth, it is possible to extend the same idea to Russian dolls, so that narrowing
remains a strongly complete analysis method for appropriate goals. A theory R = (Σ, E, R) of Russian dolls has the following form.
The signature Σ includes sorts FlatConﬁg and Conﬁg, with FlatConﬁg <
Conﬁg, Conﬁg a top sort in S/ ≡, and s < Conﬁg implies s ≤ FlatConﬁg.
The only function symbols 3 in Σ whose arity includes a sort s such that [s] = Conﬁg are:

⊗  : FlatConﬁg × FlatConﬁg → FlatConﬁg
⊗ : Conﬁg × Conﬁg → Conﬁg
[ ] : Conﬁg → Conﬁg
where ⊗ is associative and commutative, and has identity null. Further, if f : w → Conﬁg, then f is either ⊗ or [ ]. We say a term t is of bounded nesting if for all x ∈ Var(t), x ∈ TΣ(X)Conﬁg implies x ∈ TΣ(X)FlatConﬁg. For terms of bounded nesting, we define the (nesting) depth of t as follows:
depth(t) = 0 if t ∈/ TΣ(X)Conﬁg or t ∈ TΣ(X)FlatConﬁg,
depth(t1 ⊗ t2) = max{depth(t1), depth(t2)},
depth([t]) = depth(t)+ 1.

3 To simplify the exposition, we assume a very simple operator [ ] : Conﬁg → Conﬁg to structure configurations in a nested way as Russian dolls. In general, however, such a structuring operator may have additional sorts as arguments. Our method can be easily extended to those more general structuring operators.

For each equation t = t' in E and substitution σ, it is the case that σ(t) is of bounded nesting if and only if σ(t') is, and further if σ(t) and σ(t') are of bounded nesting, then depth(σ(t)) = depth(σ(t')). In short, equations do not change the depth of terms.
For each rule l → r in R we have l, r ∈ TΣ(X)Conﬁg, and for each substi- tution σ such that σ(l) and σ(r) are of bounded nesting, it is the case that depth(σ(l)) ≥ depth(σ(r)), i.e. rewrites do not increase the depth of terms.
Note that for a term t of bounded nesting, σ(t) is of bounded nesting for any substitution σ, t =E t' implies t' is of bounded nesting and depth(t) = depth(t'), and t →R/E t' implies t' is of bounded nesting and depth(t) ≥ depth(t'). The reader is refered to [32] for examples of Russian doll theories.
Given a rewrite theory R = (Σ, E, R) such as above, and a natural number n, we can transform R into a topmost rewrite theory Rˆn = (Σˆn, E, Rˆn) as follows. The signature Σˆn extends Σ with a new top sort State and a new operator { } : Conﬁg → State. The set Rˆn contains for each rule l → r in R
and 0 ≤ k ≤ n, the rule
{C0 ⊗ [C1 ⊗ [C2 ⊗ [... [Ck ⊗ l] .. .]]]} → {C0 ⊗ [C1 ⊗ [C2 ⊗ [... [Ck ⊗ r] .. .]]]}
where C1,..., Ck are fresh variables of sort Conﬁg.
Lemma 5.4 Let R = (Σ, E, R) be a Russian doll rewrite theory. Let t be a term of bounded nesting and of sort Config, and let depth(t) = n, then t →R/E t' if and only if {t} →Rˆ /E {t'}.	 
We say a goal G : t1 →∗ t2 ∧...∧t2n−1 →∗ t2n is of bounded nesting if the ti are of bounded nesting for all 1 ≤ i ≤ 2n. For a goal G of bounded nesting, we define depth(G) = max{depth(t1),... , depth(t2n)}. The above lemma implies that the set of R-solutions of a goal G : t1 →∗ t2 ∧ ... ∧ t2n−1 →∗ t2n of
depth k, is the same as the set of Rˆk -solutions of the goal Gˆ : {t1} →∗
{t2} ∧ ... ∧ {t2n−1} →∗ {t2n}. Thus, to find a complete set of R-solutions of
G, we can just find a complete set of Rˆk -solutions of Gˆ.

Linear Rewrite Theories
In this section we consider linear rewrite theories R = (Σ, ∆ ∪ B, R) which, in addition to the assumptions in Section 3, also satisfy the property that B is linear, and each rule in R is sort-decreasing and right linear. We say that a
goal G : t1 →∗ t' ∧ ... ∧ tn →∗ t' is linear if for all 1 ≤ i, j ≤ n (i) ti is linear,
1	n
(ii) Var(ti) ∩ Var(tj) = ∅ for i /= j, and (iii) Var(ti) ∩ Var(t' ) = ∅. Note that
t' need not be linear, and it may happen that Var(t') ∩ Var(t' ) /= ∅ for some
i	i	j
i /= j. We say that a substitution σ is linear on a set of variables V if (i) σ(x) is


linear for all x ∈ V , and (ii) for all x, y ∈ V , we have Var(σ(x))∩Var(σ(y)) = ∅
for x /= y.
The main reason for incompleteness of narrowing in Section 4 was that, if the rewrite in ρ(t) →R/E t' happens “within” the substitution ρ, then it is not possible to associate with it a narrowing derivation; this is the reason why we required ρ to be R/E-normalized. But for the case of a linear rewrite theory R = (Σ, E, R) and a linear reachability goal G, we can overcome this limitation to some extent, so that if ρ is an R-solution of G, then narrowing is guaranteed to find another R-solution η such that for some θ we have

ρ|Var(G)
∗
R/E
θ|Var(G)
and η|
Var(G)
  E θ|
Var(G).

Lemma 5.5 Let t, t' be terms such that t' is linear and Var(t) ∩ Var(t') = ∅. Let V be a ﬁnite set of variables containing Var(t) and Var(t'). Let B be a linear and regular set of equations. Then, there is a complete set of B-uniﬁers of t = t' away from V , namely Γ, such that every σ ∈ Γ is linear on Var(t).
Following are the analogues of Lemmas 4.4, 4.5 and 4.6.
Lemma 5.6 Given R = (Σ, ∆ ∪ B, R), let t be a linear term, and let V be a ﬁnite set of variables containing Var(t). Further, for some substitution ρ, let ρ(t) →R∪∆,B t' using the rule l → r in R or the equation l = r in ∆. Then one of the following is true:
t' = η(t) for some η such that ρ|V →R∪∆,B η|V using the same rule or equation.
There are σ, η, t'' such that t ~σ	t'' using the same rule or equation,
t'' is linear, η(t'') =B t', and ρ|V =B (η ◦ σ)|V .
Lemma 5.7 Let t be a linear term, V be a ﬁnite set of variables containing Var(t), and for some substitution ρ, let ρ(t) →R/E t', then there is a linear t'', and a substitution η such that η(t'') =E t', and one of the following is true

There is σ such that t ~σ ∗
t'' and ρ|V
∗
R/E
(η ◦ σ)|V

There are σ ,σ such that t ~σ1 ∗
~σ2
t'' and ρ|
=  (η ◦ σ ◦ σ )| .

1	2	∆,B
R,B
V	E	2	1  V

Lemma 5.8 Let G be a linear goal, V be a ﬁnite set of variables containing
Var(G), and for some substitution ρ let ρ(G) →∗	G', then there are σ, G'',η 

such that
~σ ∗
R∪∆,B

G'' for some G'' that is linear

η(G'') =E G', and
Either ρ|V →∗	(η ◦ σ)|V or ρ|V =E (η ◦ σ)|V
We are now ready to state the strong completeness result for linear rewrite


theories and goals.
Theorem 5.9 (linear strong completeness) Let G be a linear goal, V be a ﬁnite set of variables containing Var(G), and ρ be a solution of G, then there are σ, G' such that:

σ ∗
G ~R∪∆,B
G' and G' has a trivial solution.

There is η ∈ CSUE(E(G'),V ∪ Ran(σ)) such that, for some substitution θ,
we have ρ|V →∗	θ|V and (η ◦ σ)|V  E θ|V .

Example: Bounded-Process Security Protocol Anal- ysis
Verification of many security protocol properties can be formulated as reach- ability problems. For instance, verifying the secrecy property of a protocol amounts to checking if the protocol can reach a state where an intruder has
discovered a data item that was meant to be a secret. In this section, we will exploit the strong completeness result in Section 5.1 to show how narrowing provides a generic and complete procedure for the analysis of such security properties.
In the general case, the reachability problem for security protocols is known to be undecidable [14]. An important decidable subcase is where the num- ber of protocol sessions, i.e., where the number of principals instantiating the protocol roles, is bounded. Even this restricted scenario has an infinite state space, since the intruder can interfere with the protocol execution by forging arbitrary messages. Several authors have proposed decision procedures for the reachability problem in this subcase [20,1,33,38]. An important limita- tion of all these works is that their analyses do not account for the algebraic properties of the underlying cryptographic primitives. This simplification is not valid for a variety of cryptographic primitives used in practice, such as xor, products, and Diffie-Hellman exponentiation. The attacker can exploit algebraic properties of these primitives, such as commutativity, associativity, and cancellation, to find attacks that are otherwise not possible [39].
Recently, extensions to the original decision procedures for the reachability problem, that also account for the algebraic properties of cryptographic prim- itives, have been proposed [11,34,8,7]. However, these extensions are adhoc and not generic. Specifically, each cryptographic primitive with a different set of algebraic properties has been dealt with by an essentially different exten- sion. We show that narrowing modulo equations provides a generic procedure that can account for a wide class of primitives with algebraic properties. Al- though narrowing is complete in that it will discover an attack if one exists,






(Axiom) K, M ▶ M	(Pair)
K ▶ M1	K ▶ M2 K ▶ (M1, M2)

K ▶ (M1, M2)
(Project)
K ▶ Mi
K ▶ M	K ▶ k
i = 1, 2	(Encrypt)
K ▶ {M}k


K ▶ {M}k	K ▶ k−1
(Decrypt)
K ▶ M


Table 1
The Dolev-Yao inference rules for intruder capabilities
it is only a semidecision procedure in that it need not terminate. However, it may be possible to identify several cases where the narrowing procedure for reachability goals is guaranteed to terminate. This is beyond the scope of this paper, and is an important problem for future research.
We now briefly describe how narrowing can be used for security analysis, and illustrate it with a few examples. A protocol can be described as a list of actions, called a role, for each honest principal [14]. An action is a pair of terms u, v with variables, which is interpreted as: upon receiving a message
matching u, send the corresponding message v. For the sake of concreteness let us consider the case where terms have the following grammar
M ::= Var | Atoms | (M1, M2) | {M}k
where Atoms contains the set Names of principal names, the set Keys of public and private keys of principals, and the set Nonce of nonces, (M1, M2) is a pair containing M1 and M2, and {M}k is the public key encryption of M with key k. We assume functions pb(·), pv(·) : Names → Keys which map principal names to the corresponding public and private keys respectively. For a public
key k, we denote its private key by k−1. We can consider richer signatures such as those including symmetric key encryption with possibly non-atomic keys and hashing functions, and the discussion below applies to them as well. But we restrict ourselves to this limited signature in the interest of simplicity. Later in this section, to illustrate the fact that narrowing is a general analysis technique that can handle cryptographic primitives with algebraic properties, we will also consider xor-encryption.
A protocol instance is a collection of principals, each instantiating a role; we are interested only in finite collections. An intruder can try to compromise


the execution of a protocol by replacing an instance of u that was sent by an honest principal with another message that it can build. Typically one assumes that every message exchanged between the honest principals is mediated by the intruder, and the intruder can use the messages that it has observed so far to build fake messages. The most widely used model for the intruder’s
capability to build messages from the ones it knows, is the Dolev-Yao model
[13], which is shown in Table 1. The judgment K ▶ M is read as: an attacker that knows all the messages in the set K can construct the message M.
Verifying if the secrecy property is violated amounts to checking if there is a total ordering of actions (u1, v1),... , (un, vn) of all the principals, that is consistent with the ordering at each principal, and there is a substitution σ such that
K0, σ(v1),... , σ(vi) ▶ σ(ui+1)	and	K0, σ(v1),..., σ(vn) ▶ s
where K0 is the initial knowledge of the intruder, and s is the data item that is to be kept secret. K0, for instance, may contain the name of all the principals, and their public keys. Thus, the protocol is insecure if and only if there is
an ordering such that the corresponding set of constraints that it generates,
have a solution; a solution, if it exists, essentially describes an attack. Note that, since the number of principals is finite, there are only a finite number of total orderings of actions. Such a formalization of the secrecy problem can be found, for instance, in [1,33], to which the reader is referred for further details. We can represent the constraint system above as a rewrite theory R =
(Σ, E, R) that is topmost modulo ACU, and use narrowing to find a complete
set of solutions for a given finite set of constraints. The signature Σ has sorts Keys < Atoms < Msg < MsgSet, and Constraint. The following are constructors for the sort Msg.

( , ) : Msg × Msg → Msg	{ }	: Msg × Keys → Msg
The sort MsgSet has a single operator , : MsgSet × MsgSet → MsgSet, which is associative and commutative, and has identity null. The sort Constraint has operators

true : Constraint
▶	:  MsgSet × Msg → Constraint
∧	: Constraint × Constraint → Constraint
The operator ∧ is associative, commutative, and has true as identity. The


rules in R model the inference system of Table 1. An inference rule

K ▶ M1	K ▶ M2 K ▶ M3
is modeled as the rewrite rule K ▶ M3 → K ▶ M1 ∧ K ▶ M2 that rewrites multisets of judgments. The idea is that rewriting with these rules, starting
from the conclusion, corresponds to searching for a proof of the conclusion in the inference system. To satisfy the condition that Var(r) ⊆ Var(l) for each rule l → r in R, we consider the following alternate version of the rules (Project) and (Decrypt).

K, M1, M2 ▶ M
(Project’)
K, (M1, M2) ▶ M

K, {M1}k ▶ k−1	K, {M1}k, M1 ▶ M2
(Decrypt’)
K, {M1}k ▶ M2
Replacing the rules (Project) and (Decrypt) in Table 1 with the rules above gives us an equivalent inference system, which can be modeled by the following rules.
(Axiom)	K, M ▶ M  →  true
(Pair)	K ▶ (M1, M2) →  K ▶ M1 ∧ K ▶ M2
(Project’)	K, (M1, M2) ▶ M  →  K, M1, M2 ▶ M
(Encrypt)	K ▶ {M}k  → K ▶ M ∧ K ▶ k
(Decrypt’)	K, {M1}k ▶ M2  →  K, {M1}k ▶ k−1 ∧ K, {M1}k, M1 ▶ M2

Lemma 6.1 K ▶ M according to the Dolev-Yao inference rules if and only

if K ▶ M →∗
true.	 

From this lemma, it follows that σ is a solution of K1 ▶ M1 ∧ ... ∧ Kn ▶

Mn if and only if σ(Ki) ▶ σ(Mi) →∗
true for 1 ≤ i ≤ n.  Now, note

that R is topmost modulo ACU, and hence it can be transformed into a
topmost theory, as described in Section 5.1. The resulting topmost theory also satisfies the additional assumptions in Section 5.1, namely, E has a complete unification algorithm, and none of the equations in E have a variable of (the


newly introduced) sort State. Thus, we can use narrowing to find a complete

set of solutions of the goal K1 ▶ M1 →∗
true ∧ ... ∧ Kn ▶ Mn →∗
true.


Example 6.2 Consider the following simplified variant of the Needham-Schroeder public key protocol.


1. A → B : {(NA, A)}pb(B)	3. A → B : {NB}pb(B)
2. B → A : {(NA, NB)}pb(A)

A, B denote names of the principals and NA, NB denote nonces. In our pro- tocol model, this is represented by two roles Initiator (A, B, NA) and Respon- der (A, B, NB) as follows.


Initiator (A, B, NA):

(I1)	⇒ {(NA, A)}pb(B)
(I2) {(NA, X2)}pb(A) ⇒ {X2}pb(B)
Responder (A, B, NB):

(R1) {(X1, A)}pb(B) ⇒ {(X1, NB)}pb(A)
(R2) {NB}pb(B) ⇒


Now, consider an instance with three principals a, b, c, where a plays the role Initiator (a, c, na) (i.e. intends to initiate the protocol with c), b plays the role Responder (a, b, nb) (i.e., b expects an initiation from a), and c is a dishonest principal (i.e. the intruder). The data item nb is to be kept secret from the
intruder c.
The initial knowledge K0 of the intruder c includes a, pb(a), b, pb(b), c, pb(c), and pv(c). Consider the following ordering of actions of the honest principals a and b: I1, R1, I2, R2. This generates the following constraints.


K0, {(na, a)}pb(c) ▶ {(X1, a)}pb(b)
K0, {(na, a)}pb(c), {(X1, nb)}pb(a) ▶ {(na, X2)}pb(a)
K0, {(na, a)}pb(c), {(X1, nb)}pb(a), {X2}pb(c) ▶ {nb}pb(b)
K0, {(na, a)}pb(c), {(X1, nb)}pb(a), {X2}pb(c) ▶ nb

The narrowing procedure finds the solution σ = {na/X1, nb/X2}, which cor-


responds to the following well-known attack discovered by Lowe [27]:

a → c	: {(na, a)}pb(c)	4. c → a : {(na, nb)}pb(a)
c(a) → b : {(na, a)}pb(b)	5. a → c : {nb}pb(c)
b → c(a) : {(na, nb)}pb(a)
As mentioned earlier, narrowing modulo equations provides a generic anal- ysis technique that can also handle cases where the underlying cryptographic primitives have algebraic properties that can be exploited by the intruder. We illustrate this with the xor encryption primitive. The signature Σ is extended with the following operators
0 : Msg	⊕ : Msg × Msg → Msg
The constant 0 is the identity for the ⊕ operator. Note that in xor-encryption, it is possible to use non-atomic keys, i.e., a term of sort Msg rather than just a term of sort Keys. The set of equations E now also includes the following set of equations XOR for the ⊕ operator:

(Assoc)	(M1 ⊕ M2) ⊕ M3 = M1 ⊕ (M2 ⊕ M3) (Comm)		M1 ⊕ M2 = M2 ⊕ M1
(Ident)	0 ⊕ M  = M
(Inv)	M ⊕ M  =  0
This equational theory is known to have a complete unification algorithm. The inference system of Table 1 is extended with the following inference rules.



(Equality)
K ▶ M1 K ▶ M2
if M1 =XOR M2	(Xor)
K ▶ M1	K ▶ M2 K ▶ M1 ⊕ M2

Note that the (Equality) rule captures the intruder’s ability to exploit the algebraic properties of xor. The set of rules R is extended with the following rule.
(Xor)	K ▶ M1 ⊕ M2 → K ▶ M1 ∧ K ▶ M2
Since rewrites happen modulo the equations E, the rule (Equality) is implicit. The resulting rewrite theory is again topmost modulo ACU. As before, we can transform it into a topmost theory, and use narrowing to find a complete set of solutions.


Now, consider the following variant of the Needham-Schroeder public key protocol with Lowe’s fix [27]. This variant was presented in [8].

1. A → B : {(NA, A)}pb(B)	3. A → B : {NB}pb(B)
2. B → A : {(NA ⊕ B, NB)}pb(A)

In this variant, ⊕ is used in step 2, instead of pairing as in Lowe’s fix. This is represented in our protocol model as follows.


FixedInitiator (A, B, NA):

(I1)	⇒ {(NA, A)}pb(B)
FixedResponder (A, B, NB):

(R1) {(X1, A)}pb(B) ⇒ {(X1 ⊕ B, NB)}pb(A)

(I2) {(NA ⊕ B, X2)}pb(A) ⇒ {X2}pb(B)  (R2) {NB}pb(B) ⇒

Consider the instance with three participants a, b, c as before, with a play- ing the role FixedInitiator (a, c, na), b playing the role FixedResponder (a, b, nb), and c a dishonest principal. As usual, nb is to be kept secret from c. The se- quence of actions I1, R1, I2, R2 generates the constraints

K0, {(na, a)}pb(c) ▶ {(X1, a)}pb(b)
K0, {(na, a)}pb(c), {(X1 ⊕ b, nb)}pb(a) ▶ {(na ⊕ c, X2)}pb(a)
K0, {(na, a)}pb(c), {(X1 ⊕ b, nb)}pb(a), {X2}pb(c) ▶ {nb}pb(b)
K0, {(na, a)}pb(c), {(X1 ⊕ b, nb)}pb(a), {X2}pb(c) ▶ nb

The narrowing procedure finds the solution σ = {na ⊕ b ⊕ c/X1, nb/X2}, which corresponds to the following attack that critically makes use of the equality na ⊕ b ⊕ c ⊕ b = na ⊕ c.

a → c	: {(na, a)}pb(c)	4. c → a : {(na ⊕ b ⊕ c ⊕ b, nb)}pb(a)
c(a) → b : {(na ⊕ b ⊕ c, a)}pb(b)	5. a → c : {nb}pb(c)
b → c(a) : {(na ⊕ b ⊕ c ⊕ b, nb)}pb(a)

Finally, we note that other security properties such as authenticity can be analyzed using similar techniques.

Concluding Remarks
We have proposed narrowing as a general deductive method to solve reacha- bility problems for a system axiomatized as a rewrite theory. We have proved its soundness and a weak completeness result, have shown that in full gener- ality is incomplete in the strong sense, and have identified important classes of rewrite theories, covering many applications, for which narrowing is indeed strongly complete.
Much more work remains ahead in several directions, including the follow- ing:
Extending the present results to broader classes of rewrite theories.
Developing narrowing strategies, to be as efficient as possible and to avoid combinatorial explosions; in particular, the use of constraints and of how to best combine narrowing with equations (to solve equalities) and with rules should be investigated; also “smart” strategies that can detect looping
situations would be very useful [24].
Building a prototype implementation based on such strategies, that would allow experimentation and supporting unification modulo different equa- tional axioms.
Investigating termination conditions for the narrowing procedure.
Studying relationship with other methods that can be used to approxi- mate reachability problems, such as procedures based on tree-automata techniques [18,35].
Developing applications and case studies, particularly to analyze distributed systems and security protocols.
Integrating narrowing with other theorem proving methods, for example deductive methods for temporal logic properties [28,6] of rewrite theories.

Acknowledgements
The authors would like to thank Jean-Pierre Jouannaud for insightful discus- sions on narrowing.

References
R. Amadio and D. Lugiez. On the reachability problem in cryptographic primitives. In 11th International conference on concurrency theory (CONCUR ’00), volume 1877 of Lecture Notes in Computer Science, pages 380–394. Springer, 2000.
David Basin, Sebastian Modersheim, and Luca Vigano. Constraint differentiation: A new


reduction technique for constraint-based analysis of security protocols. Technical Report TR- 405, Swiss Federal Insititute of Technology, Zurich, May 2003.
Alexander Bockmayr, Stefan Krischer, and Andreas Werner. An optimal narrowing strategy
rd
for general canonical systems. In M. Rusinowitch and J.L. R´emy, editors, 3	International
Workshop on Conditional Term Rewrite systems, volume 656 of Lecture Notes in Computer Science, pages 483–497. Springer, 1992.
Ahmed Bouajjani and Richard Mayr. Model checking lossy vector addition systems. In STACS, pages 323–333, 1999.
O. Burkart, D. Caucal, F. Moller, and B. Steffen. Verification over Infinite States. In Handbook of Process Algebra, pages 545–623. Elsevier Publishing, 2001.
K.M. Chandy and J. Misra. Parallel programming design - A foundation. Addison Wesley Publishing Company, 1988.
Yannick Chevalier, Ralf Kusters, Michael Rusinowitch, and Mathieu Turuani. Deciding the
rd
security of protocols with Diffie-Hellman exponentiation and products in exponents. In 23
Conference on Foundations Software Technology and Theoretical Computer Science, Lecture Notes in Computer Science, 2003. to appear.
Yannick Chevalier, Ralf Kusters, Michael Rusinowitch, and Mathieu Turuani. An NP decisoin
th
procedure for protocol insecurity with XOR. In 18	Annual IEEE Symposium on Logic in Computer Science (LICS ’03), 2003.
E. M. Clarke, O. Grumberg, and D. A. Peled. Model Checking. MIT Press, 1999.
Edmund M. Clarke, Orna Grumberg, and David E. Long. Model checking and abstraction. ACM Transactions on Programming Languages and Systems, 16(5):1512–1542, September 1994.
H. Comon-Lundh and V. Shmatikov. Intruder deductions, constraint solving and insecurity
th
decision in presence of exclusive or. In 18	Annual IEEE Symposium on Logic in Computer Science (LICS ’03), pages 271–280, 2003.
Grit Denker, Jos´e Meseguer, and Carolyn L. Talcott.  Protocol specification and analysis in Maude.  In N. Heintze and J. Wing, editors, Proceedings of Workshop on Formal Methods and Security Protocols, June 25, 1998, Indianapolis, Indiana, 1998. http://www.cs.bell-labs.com/who/nch/fmsp/index.html .
D. Dolev and A. Yao. On the security of public key protocols. IEEE Transaction on Information Theory, 29(2):198–208, 1983.
N. Durgin, P. Lincoln, J. Mitchell, and A. Scedrov. Undecidability of bounded security protocols. In Workshop on formal methods and security protocols, 1999. FLOC.
A. Emerson and K. Namjoshi. On model checking for nondeterministic infinite state systems. In IEEE Symposium on Logic in Computer Science, 1998.
M. Fay. First order unification in equational theories. In W. Bibel and R. Kowalski, editors,
th
4	Conference on Automated Deduction, volume 87 of Lecture Notes in Computer Science,
pages 161–167. Springer, 1979.
Alain Finkel and Ph. Schnoebelen. Well-structured transition systems everywhere! Theoretical Computer Science, 256(1):63–92, 2001.
Thomas Genet and Val´erie Viet Triem Tong. Reachability analysis of term rewriting systems
th
with Timbuk. In 8	International Conference on Logic for Programming, volume 2250 of
Lecture Notes in Computer Science, 2001.
Susanne Graf and Hassen Saidi. Construction of abstract state graphs with PVS. In Orna Grumberg, editor, Computer Aided Veriﬁcation. 9th International Conference, CAV’97, Haifa, Israel, June 22-25, 1997, Proceedings, volume 1254 of Lecture Notes in Computer Science, pages 72–83. Springer-Verlag, 1997.


A. Huima. Efficient infinite state analysis of security protocols. In Workshop on formal methods and security protocols, 1999. FLOC.
J.M. Hullot. Canonical forms and unification. In W. Bibel and R. Kowalski, editors, 5th Conference on Automated Deduction, volume 87 of Lecture Notes in Computer Science, pages 318–334. Springer, 1980.
Florent Jacquemard, Micha¨el Rusinowitch, and Laurent Vigneron. Compiling and verifying security protocols. In Logic Programming and Automated Reasoning, pages 131–160, 2000.
Jean-Pierre Jouannaud, Claude Kirchner, and Helene Kirchner. Incremental construction of
th
unification algorithms in equational theories. In 10	International Colloquium on Automata,
Languages and Programming, volume 154 of Lecture Notes in Computer Science, pages 361–
373. Springer, 1983.
Y. Kaji, T. Fujiwara, and T. Kasami. Solving a unification problem under constrained substitutions using tree automata. Journal of Symbolic Computation, 23(1):79–118, 1997.
Yonit Kesten and Amir Pnueli. Control and data abstraction: The cornerstones of practical formal verification. International Journal on Software Tools for Technology Transfer, 4(2):328– 342, 2000.
C. Loiseaux, S. Graf, J. Sifakis, A. Bouajjani, and S. Bensalem. Property preserving abstractions for the verification of concurrent systems. Formal Methods in System Design, 6:1–36, 1995.
G. Lowe. Breaking and fixing the Needham-Schroeder public-key protocol using fdr. In Tools and algorithms for construction and analysis of systems (TACAS ’96), volume 1055 of Lecture Notes in Computer Science, pages 147–166. Springer, 1996.
Zohar Manna and Amir Pnueli. Completing the temporal picture. Theoretical Computer Science, 83:97–130, 1991.
Catherine Meadows. The NRL protocol analyzer: An overview. Journal of logic programming, 26(2):113–131, 1996.
Jos´e Meseguer. Conditional rewriting logic as a unified model of concurrency. Theoretical Computer Science, 96(1):73–155, 1992.
Jos´e Meseguer. Membership algebra as a logical framework for equational specification. In
F. Parisi-Presicce, editor, Proc. WADT’97, pages 18–61. Springer LNCS 1376, 1998.
Jos´e Meseguer and Carolyn Talcott. Semantic models for distributed object reflection. In
th
16	European Conference on Object-Oriented Programming, volume 2374 of Lecture Notes in
Computer Science, pages 1–36. Springer, 2002.
J. Millen and V. Shmatikov. Constraint solving for bounded-process cryptographic protocol analysis. In 8th ACM Conference on Computer and Communications Security (CCS ’01), pages 166–175, 2001.
J. Millen and V. Shmatikov. Symbolic protocol analysis with products and Diffie-Hellman exponentiation. In 16th IEEE Computer Security Foundations Workshop (CSFW-16), pages 47–61, 2003.
Hitoshi Ohsaki, Hiroyuki Seki, and Toshinori Takai.  Recognizing boolean closed A-tree
th
languages with membership conditional mechanism.  In 14	International Conference on
Rewriting Techniques and Applications, volume 2706 of Lecture notes in computer science, pages 483–498. Springer Verlag, 2003.
S. Owre, N. Shankar, J. Rushby, and D. Stringer-Calvert. PVS system guide, PVS language reference, and PVS prover guide version 2.4. Computer Science Laboratory, SRI International, 2001.
Larry Paulson. Isabelle: A Generic Theorem Prover, volume 828 of Lecture Notes in Computer Science. Springer Verlag, 1994.


Michael Rusinowitch and Mathieu Turuani. Protocol insecurity with a finite number of sessions and composed keys is NP-complete. In 14th IEEE Computer Security Foundations Workshop, pages 174–190, 2001.
P. Ryan and S. Schneider. An attack on a recursive authentication protocol. Information Processing Letters, 65, 1998.
Hassen Sa¨ıdi and Natarajan Shankar. Abstract and model check while you prove. In Nicolas Halbwachs and Doron Peled, editors, Computer Aided Veriﬁcation. 11th International Conference, CAV’99, Trento, Italy, July 6-10, 1999, Proceedings, volume 1633 of Lecture Notes in Computer Science, pages 443–454. Springer-Verlag, 1999.
Mark-Oliver Stehr, Jos´e Meseguer, and Peter Csaba O¨ lveczky. Rewriting logic as a unifying framework for Petri nets. In H. Ehrig, G. Juhas, J. Padberg, and G. Rozenberg, editors, Unifying Petri Nets, Lecture Notes in Computer Science. Springer-Verlag, 2001.
P. Viry.  Rewriting: An effective model of concurrency.  In C. Halatsis, D. Maritsas,
G. Philokyprou, and S. Theodoridis, editors, PARLE’94 Parallel Architectures and Languages Europe, 6th International PARLE Conference, Athens, Greece, July 4–8, 1994, Proceedings, volume 817 of Lecture Notes in Computer Science, pages 648–660. Springer-Verlag, 1994.

A	Appendix
Proof of Lemma 4.2: Lemma 4.1 can be lifted to goals as G ~η	G'
implies η(G) →R∪∆,B G'. Then the result follows by a simple induction on the
number of narrowing steps in G ~σ ∗	G', using the fact that rewrites are
stable under substitution.	 
Proof of Theorem 4.3: By Lemma 4.2, we have σ(G) →∗	G', and using
Lemma 3.2, we have σ(G) →∗	G'. Then, since rewrites are stable under
substitutions, we have η ◦ σ(G) →∗	η(G'). Now, since η(G') is trivial, from
Lemma 3.1 we conclude that η ◦ σ is a solution of G.	 
Proof of Lemma 4.4: Without loss of generality we may assume that Dom(ρ) ⊆ V , otherwise we can consider V ∪ Dom(ρ) instead of V . We may also assume V ∩ Var(l) = ∅. Now, since ρ is R ∪ ∆, B-normalized, the rewrite ρ(t) →R∪∆,B t' occurs at some position ω ∈ FuPos(t). Then there is ρ' such that Dom(ρ') ⊆ Var(l), ρ(t)|ω = ρ(t|ω) =B ρ'(l), and t' = ρ(t)[ω ← ρ'(r)]. Let W = Var(t|ω) ∪ Var(l). Then there is some σ ∈ CSUB(t|ω = l, V ∪ Var(l))
such that σ|W  B (ρ ∪ ρ')|W . Since σ(t|ω) =B σ(l), and B is regular, we have Var(σ(t|ω)) = Var(σ(l)). But since V ∩ Var(l) = ∅, σ is away from V ∪ Var(l), and Dom(σ) ⊆ W , we deduce Dom(σ) = W . Let η' be such that

(ρ∪ρ')|W =B (η'◦σ)|W , and η = η'|Ran
∪ρ|V . Then we have ρ|V =B (η◦σ)|V ,

and ρ'|Var
=B (η ◦ σ)|
Var(l)
(note that Dom(σ) = W ⊇ Var(l)). Then for

t'' = σ(t[ω ← r]), we have t ~σ
R∪∆,B
t'', and further, since Var(r) ⊆ Var(l),

we have η(t'') =B t'. Now, we prove by contradiction that η is R ∪ ∆, B- normalized. Suppose it is not. Then since Dom(η) ⊆ Ran(σ) ∪ V , η|V = ρ|V , and ρ is R∪∆, B-normalized it follows that there is x ∈ Ran(σ) such that η(x)


is not R∪∆, B-normalized. Since Var(σ(t|ω)) = Var(σ(l)), and Dom(σ) = W , we have Ran(σ) = Ran(σ|Var(t|ω )). Then it follows that there is x ∈ V such that η ◦ σ(x) is not R ∪ ∆, B-normalized. But since ρ(x) =B η ◦ σ(x), →∆,B is coherent with B, and →R,B is E-consistent with B, it follows that ρ(x) is not R ∪ ∆, B-normalized, a contradiction.	 

Proof of Lemma 4.5: By Lemma 3.2, since ρ(t) →R/E t' we have ρ(t) →∗
→R,B

s for some s =E t'. Now, we exploit the fact that ∆ is terminating modulo B and prove the lemma by noetheranian induction on the relation →∆,B ◦ =B. For the base case, we have ρ(t) →R,B s, and the result follows by a direct application of Lemma 4.4. For the induction step we have the following dia- gram.

ρ(t) →∆,B s' →∗
→R,B  s

||
ρ
t	~σ
||B
η'
''  σ' ∗	σ2
||E
η
''

∆,B  s
~∆,B~R,B t

We have ρ(t) →∆,B s' →∗	→R,B s for some s'. By Lemma 4.4, there are

σ, s'', η' such that t ~σ
∆,B
s'', η' is R ∪ ∆, B-normalized, η'(s'') =B
s', and

ρ|V =B (η' ◦ σ)|V . Now, let W be a finite set of variables containing V and Ran(σ). Note that since B is regular and the rules in R do not introduce new variables, W contains Var(s''). Now, we have η'(s'') →R/E s. Then by

'	''
'' σ' ∗	σ2	''

the induction hypothesis, there are σ , σ2,t ,η such that s
~
∆,B
~R,B t , η is

R ∪ ∆, B-normalized, η(t'') =E s, and η'|W =E (η ◦ σ2 ◦ σ')|W . Let σ1 = σ' ◦ σ. Then we have ρ|V =E (η ◦ σ2 ◦ σ1)|V . We have thus proved the result.	 
Proof of Lemma 4.6: By induction on the number of derivation steps in

ρ(G) →∗
G', using the fact that Lemma 4.5 can be lifted to goals.	 

Proof of Theorem 4.7: Since ρ is a solution of G, by Lemma 3.1 we have
ρ(G) →∗	G'' for some trivial G''. Recall that, since B is sort-preserving
and ∆ is sort-decreasing, it is the case that t →∆,B t' and t ∈ TΣ(X)s implies
t' ∈ TΣ(X)s. Therefore, ρ =E ρ' for some ∆, B-normalized substitution ρ'.
Then ρ'(G) →∗	G''. Further, since ρ is R/E-normalized it follows that ρ' is
R ∪ ∆, B-normalized. By Lemma 4.6, there are σ, G', η' such that G ~σ ∗
G', η'(G') = G'', and ρ'|V =E (η' ◦ σ)|V .  Since G'' is trivial, η' is an E- unifier of E(G'), and hence there is η ∈ CSUE(E(G'),V ∪ Ran(σ)) such that

η|Var '
  E η'|
' . Note that since B is regular and the rules in R

(G )
Var(G )

do not introduce new variables, we have Var(G') ⊆ V ∪ Ran(σ). Then, by
Lemma 2.1, we have η|V ∪Ran(σ)  E η'|V ∪Ran(σ). From this and the fact that


ρ'|V =E (η' ◦ σ)|V we conclude that (η ◦ σ)|V  E ρ'|V =E ρ|V .	 
Proof of Lemma 5.1: Without loss of generality we may assume that Dom(ρ) ⊆ V , otherwise we can consider V ∪ Dom(ρ) instead of V . We may also assume V ∩ Var(l) = ∅. Now, since R is topmost and t is not a vari- able, the rewrite occurs at position ϵ ∈ FuPos(t). Then there is ρ' such that Dom(ρ') ⊆ Var(l), ρ(t) =E ρ'(l), and t' = ρ'(r). Let W = Var(t) ∪ Var(l). Then there is some σ ∈ CSUE(t = l, V ∪ Var(l)) such that σ|W  E (ρ ∪ ρ')|W .

Let η' be such that (ρ ∪ ρ')|W =E (η' ◦ σ)|W , and η = η'|Ran(σ)∪Var
∪ ρ|V .

Then we have ρ|V =E (η ◦ σ)|V , and ρ'|Var
=E (η ◦ σ)|
Var(l)
.  Then for

t'' = σ(r), we have t ~σ
R,E
t'', and further, since Var(r) ⊆ Var(l), we have

η(t'') =E t'. Now, we prove by contradiction that t'' is not a variable. Suppose t'' = x for some variable x. Since t'' = σ(r) and r is of sort State, we have that x is of sort State, r is a variable, and σ maps r to x. Since Var(r) ⊆ Var(l) and l does not contain a variable of sort State unless it is itself a variable, it
follows that l = r. Then, from σ(t) =E σ(l), we have that σ(t) =E x.  But this is impossible, because neither t (and hence σ(t)) nor any of the equations in E contains a variable of sort State.	 
Proof of Lemma 5.5: Consider some Γ' that is a complete set of B-unifiers of t = t' away from V , and let W = Var(t) ∪ Var(t'). We are done if we show that for each σ' ∈ Γ' there is a σ such that σ is a B-unifier of t = t', σ|W  B σ'|W , and σ is away from V and is linear on Var(t). Now, let σ' ∈ Γ',

and let ρ' = σ'|Var
and η' = σ'|
Var ' . Then, ρ'(t) =B η'(t'). Now, we can

write ρ' = (θ ◦ ρ)|Var
(t)
for some θ, ρ such that ρ is linear on Var(t) and away

from V , Dom(ρ) ⊆ Var(t), and θ maps variables to variables. Now, since B is
linear and regular, t' is linear, and Var(t) ∩ Var(t') = ∅, from ρ'(t) =B η'(t')
it follows that ρ(t) =B η(t') for some η such that η' = (θ ◦ η)|Var ' , η is
(t )
away from V , and Dom(η) ⊆ Var(t'). Since Var(t) ∩ Var(t') = ∅, we can take σ = ρ ∪ η.  Note that σ is a B-unifier of t = t'.  We have σ'|W =

ρ' ∪ η' = (θ ◦ ρ)|Var
(t)
∪ (θ ◦ η)|
Var(t')
= (θ ◦ (ρ ∪ η))|W = (θ ◦ σ)|W , and hence

σ|W  B σ'|W . Further, since ρ is linear on Var(t) so is σ. Finally, since ρ and
η are away from V , so is σ.	 
Proof of Lemma 5.6: There are two cases, depending on the position ω ∈ Pos(ρ(t)) at which the rewrite ρ(t) →R∪∆,B t' happens. The first case is when ω /∈ FuPos(t). Then the rewrite happens within the substitution ρ, and since B is sort-preserving, and ∆ and R are sort-decreasing, there is a
substitution η such that ρ|V →R∪∆,B η|V . Further, since t is linear, we have t' = η(t). The second case is when ω ∈ FuPos(t). Then the proof is the same as that of Lemma 4.4, with the following additional argument for linearity


of t'' = σ(t[ω ← r]). Since t is linear, Dom(σ) ⊆ Var(t|ω) ∪ Var(l), and Var(l) ∩ V = ∅, we have t'' = t[ω ← σ(r)]. Now, by Lemma 5.5, we can choose CSUB(t|ω = l, V ∪ Var(l)) so that σ is linear on Var(l). Since Var(r) ⊆ Var(l), we have that σ is also linear on Var(r). Furthermore, since σ is away from V ∪ Var(l), and r is linear, we conclude that t'' is linear.	 
Proof of Lemma 5.7: The proof uses Lemma 5.6 and is similar to the proof of Lemma 4.5. The following observations are useful in the proof. For any substitutions θ1, θ2, θ3, θ4 and sets of variables W, W ', we have: (a) θ1|W →∆,B
θ2|W implies θ1|W =E θ2|W , and (b) θ1|W =E (θ3 ◦ θ2)|W and θ3|W ' →∗	θ4|W '
for some W ' containing W ∪ Ran(θ2) implies θ1|W →∗	(θ4 ◦ θ2)|W .	 
Proof of Lemma 5.8: By induction on the number of derivation steps in

ρ(G) →∗
G', using the fact that Lemma 5.7 can be lifted to linear goals. 

Proof of Theorem 5.9: The proof uses Lemma 5.8, and is similar to the proof of Theorem 4.7.	 
