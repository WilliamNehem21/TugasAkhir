Electronic Notes in Theoretical Computer Science 123 (2005) 19–33  
www.elsevier.com/locate/entcs


A Modal Logic for π-Calculus and Model Checking Algorithm 1
Taolue Chen 2
State Key Laboratory of Novel Software Technology Nanjing University, Nanjing, P.R.China
Tingting Han
State Key Laboratory of Novel Software Technology Nanjing University, Nanjing, P.R.China
Jian Lu
State Key Laboratory of Novel Software Technology Nanjing University, Nanjing, P.R.China

Abstract
The π-calculus is one of the most important mobile process calculi and has been well studied in the literatures. Temporal logic is thought as a good compromise between description convenience and abstraction and can support useful computational applications, such as model-checking. In this paper, we use symbolic transition graph inherited from π-calculus to model concurrent systems. A wide class of processes, that is, the finite-control processes can be represented as finite symbolic transition graph. A new version π-µ-Logic is introduced as an appropriate temporal logic for the π- calculus. Since we make a distinction between proposition and predicate, the possible interactions between recursion and first-order quantification can be solved. A concise semantics interpretation for our modal logic is given. Based on the above work, we provide a model checking algorithm for the logic, which follows the well-known Winskel’s tag set method to deal with fixpoint operator. As for the problem of name instantiating, our algorithm follows the ’on-the-fly’ style, and systematically employs schematic names. The correctness of the algorithm is shown.
Keywords: π-calculus, Symbolic Transition Graph, π-µ-logic, Model Checking Algorithm.


1 Supported by 973 Program of China (2002CB312002), NNSFC (60273034, 60233010), JSFC (BK2002203, BK2002409)
2 Email: ctl@ics.nju.edu.cn


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.043

Introduction
Over the last decades, various calculi of mobile processes, notably the π- calculus [13], have been the focus of research in concurrency theory. Because of the deficiency of using algebra method to model and describe related properties of systems, e.g. mobility, safety, a lot of research has focused on modal logic of calculus. Modal logic (temporal logic especially) is thought as a good compromise between description convenience and abstraction. In addition, many modal logics support useful computational applications, such as model- checking. As a powerful language to describe mobile and dynamic process networks, the problem of verifying general temporal and functional properties, cast in terms of the π-calculus, has been investigated in-depth. Some modal logic systems for π-calculus have been provided in the literatures. The original work, as far as we know, belongs to Milner et al. In [14], they provided a cluster of extensions for Hennessy-Milner Logic [8], and proved that two of them characterize the two bisimulation equivalences, that is, the strong late and early bisimulation. However, their extension is rather simple. This may be owned to their motivation to characterize bisimulaiton relation. In [1][4] and more recently [6], Amadio and Dam introduced recursion into the modal logic via fixpoints, as in the propositional µ-calculus, thus has the ability to express properties for processes with infinite behaviors. These logic systems may be referred as π-µ-calculus. The main concern of these two papers is to formulate proof systems for deriving statements asserting whether a process satisfies a formula. What’s more, from our point of view, although the composition proof systems in the two papers are subtle, they are a little tedious, especially the completeness proof. We think it is rooted in the lacking of adequate ’symbolic’ information. The start point is to remedy this deficiency in some sense. It is well-known that symbolic technique has been widely used for name- passing calculi, especially providing the complete proof system for bisimulation equivalence and devising efficient bisimulation checking algorithm, e.g. [10][9]. In this paper, we borrow the ideas from this technique and adapt it to devising model checking algorithms.
We present our main idea in brief. In this paper, first, we use symbolic transition graph to model concurrent systems. A wide class of processes, that is, the finite-control processes can be represented as a finite symbolic transition graph. And the transition from process terms to symbolic transition graph is direct and rather simple. Second, we introduce a new version π-µ-Logic, an extension of the modal µ-calculus with boolean expressions over names, and primitives for name input and output as an appropriate temporal logic for the π-calculus. Note that in our π-µ-logic, the ’bound output’ modality is worth paying attention to. The fresh name quantification due to Pitts which is


used in spatial logic [2] is subsumed implicitly, thus we must face the problem of possible interactions between recursion and first-order quantification. To solve this problem, we make a distinction between proposition and predicate in the syntax of logic system, thus a concise semantics interpretation for our modal logic can be given while the notion of ’property sets’ is not needed. We defer more details to Section 4. The main contribution of our work lies in the model checking algorithm for the logic introduced in this paper. We follow the well-known Winskel’s tag set method to deal with fixpoint operator since we prefer the local algorithm. As for the problem of name instantiating, our algorithm follows the ’on-the-fly’ style, and systematically employs the so called schematic names, that is, the fresh name set of current node and logical formula with one new name. The correctness of the algorithm is shown.
The rest of the paper is organized as follows: some background material for π-calculus, especially the symbolic transition graph is reviewed in the following section. In Section 3, the π-µ-logic is introduced and the semantics is given, some useful properties are also discussed in this section. The model checking algorithm is presented and its correctness is shown in Section 4. The paper is concluded with Section 5 where related work is also discussed. Note that in this extended abstract, due to space restriction, most of the detailed proofs are omitted. We refer the interested readers to the full version of the paper.

π-calculus and Symbolic Transition Graph
In this section, we review some background knowledge on π-calculus and in- troduce the notion of symbolic transition graph.


Boolean Expressions and Substitution
The basic entities of the π-calculus are names, i.e. identifiers for commu- nication channels. Let U , ranged over by a, b, m,n... be a countably infinite set of names. Vectors of names will be denoted by a˜, ˜b, m˜ , n˜ ... .
Boolean Expressions, ranged over by φ, ψ, are defined by BNF as follows:
φ ::= true | x = y | чφ | φ Λ φ

We will write BExp for the set of boolean expressions and we use f alse, x /= y and φ V ψ to denote чtrue, ч(x = y) and ч(чφ Λ чψ).
The evaluation of a boolean formula Ev is a function Ev : BExp →


{true, f alse}, and is defined as follows:
Ev(x = x)= true	Ev(x = y)= f alse if x /≡ y Ev(чφ)= чEv(φ)	Ev(φ Λ ψ)= Ev(φ) Λ Ev(ψ)
Substitutions, ranged over by σ, δ, etc, are partial mappings from U to U . If σ = [y˜/x˜], where the length of x˜ equals to that of y˜, then dom(σ) = {x˜}, cod(σ) = {y˜} and n(σ) = {x˜}∪ {y˜}. If f n(φ) ⊆ V , we say φ is a boolean expression on V . Note that σ maps x onto y for x ∈ dom(σ) and x onto itself for x ∈/ dom(σ). In the sequel, we will use ∅ to denote empty substitution, σδ to denote the composition of σ and δ. The substitution σ[x '→ z] is the same as σ except that it maps x to z instead of xσ. The restriction of σ on V ⊆ U , written σ†V is defined as if x ∈ V then return xσ else return x itself.
For each name x, the function νx is defined in a stardand way in literature.
We refer the reader to [10] for details.
A substitution σ satisfies φ, written σ |= φ, if Ev(φσ) = true. We write φ ⇒ ψ to mean that σ |= φ implies σ |= ψ for any substitution σ, and φ = ψ to mean φ ⇒ ψ and ψ ⇒ φ. φ is consistent if there are no x, y ∈ U s.t. φ ⇒ [x = y] and φ ⇒ [x /= y] at the same time. Otherwise it is inconsistent. It is easy to see that φ is consistent iff there exists a substitution σ, s.t. σ |= φ. φ is valid, if Ev(φ) = true. Note for a valid boolean expression φ, we have σ |= φ for any substitution σ, thus it can be denoted by true.
Substitutions that just interchange a pair of names, which is called trans- positions and ranged by θ, will play a special role in the following techni- cal developments. More precisely, the transposition of n and m, written as
{m ↔ n}, denotes the substitution σ : {m, n} → {n, m}. It turns out that transposition is a useful tool in proving properties concerning fresh names.

Symbolic Transition Graph
Since π-calculus and related notions is well-known, we will omit the de- tailed presentation on its syntax in order to save space. Readers who are not familiar with it can refer to some standard literature, e.g. [13]. We only point out that in this paper, we disallow the parallel composition operator | to appear in the bodies of recursive definitions, and call this restricted lan- guage ’finite-control’ π-calculus [5]. By confining the process expression to ﬁnite control processes, which is the syntactic counterpart of CCS finite state processes, the symbolic transition graph in the below is finite thus we obtain a decidable model checking problem.
Now, we introduce the notion of Symbolic Transition Graph (STG for short) as a new model for π-calculus process terms. In the sequel, let SAct =


{τ }∪ {a(b), a¯b, a¯(b) | a, b ∈ U } denote the set of symbolic actions. For a set of names V ⊂fin U , function new(V ) returns the least name in U \V .
Definition 2.1 (Symbolic Transition Graph) A symbolic transition graph (STG for short) is a rooted directed graph where each node n has an associated finite set of free names f n(n) and each edge is labelled by a tuple (φ, α) where φ is the boolean expression φ ∈ BExp and α ∈ SAct is a symbolic action. A STG is well-formed if where (φ, α) is the label of an edge from n to m, written
n '→ m, then f n(φ) ⊆ f n(m) and f n(n) ⊆ f n(m) ∪ bn(α).


true,α
We write m	'→
n as m →α
n for simplicity.  Given a process t in π-

calculus, the corresponding STG can be generated by some systematic rules. Due to space restriction, we omit the details.
It is worth pointing out that for finite-control process t, by which the symbolic transition graph is generated is finite. Instead of giving the operation semantics for π-calculus terms, we give the concrete operational semantics for the STGs. First, we introduce some notations. Given a STG, a state nσ is a pair consisting of a node n together with a substitution σ associated with it. The set of free names f n(nσ) is defined as f n(n)σ and it is understood that σ is restricted to f n(n).
The late (concrete) operational semantics is defined as the least relation over states generated by the rules as follows:


φ,τ
m '→ n
φ,a¯b
m '→ n



m  →τ n
σ |= φ
m a¯→σbσ n
σ |= φ

φ,a(b)
m '→ n

σ |= φΛc ∈/ f n(mσ)
φ,a¯(b)
m '→ n

σ |= φΛc ∈/ f n(mσ)

aσ(c)
mσ → nσ[b'→c]
a¯σ(c)
mσ → nσ[b'→c]

An important property of label transition is the so called monotonicity property. It is well known when mismatch is included in the calculus, the com- mon presentation of this property (using substitution) does not hold. However, when transposition is used, we have:
Lemma 2.2 Given STG G, s, s' are nodes of G, θ is a transposition, the following properties hold:

If s →α
If sθ →α
s', then sθ →αθ s'θ.
s', then there exists α', s'', such that s α'

s'', α'θ ≡ α and s''θ ≡ s.

Proof. By structure induction on transition.	 

π-µ-Logic
Syntax
We assume a countably infinite set V of name variables ranged over by x, y,z ... , such that V∩ U = ∅. And we assume a countably infinite set X of predicate variables, ranged over by X, Y, Z,... . Each predicate variable has been assigned an arity n ∈ ω, written X : n. The syntax of the formula is defined by BNF as follows:
α ::= τ | u?(x) | u?v | u!v | u!(x) φ ::= true | u = v
A, B ::= φ | Λ(u˜) | чA | A Λ B | ∀x.A | ⟨α⟩A
Λ ::= X | (x˜)A | νX.Λ

where, u, v ∈ U ∪ V. The syntax is divided into two categories: propositions and predicates. Semantically, propositions denote sets of nodes in a STG (i.e. process terms), while predicates denote functions from sets of names to sets of nodes. For propositions, the operators are rather standard since it is adapted from well-known Hennessy-Milner Logic [8]. A predicate is either a predicate variable X, or an abstraction (x˜)A, or a greatest fixpoint νX.Λ. When forming an abstraction (x˜)A, as our notation indicates, it is required that x˜ be a vector of distinct name variables. Then the arity of a predicate Λ is defined as: the arity of X if Λ has the form X or νX.Λ, or the length of x˜ if Λ has the form (x˜)A. In abstractions and applications we always require arities to be matched properly. In formulas of the form ∀x.A, ⟨u?(x)⟩.A, ⟨u!(x)⟩.A, (x˜)A and νX.Λ, the distinguished occurrences of x and X are binding, with the scope of the propositions A or predicate Λ. These introduce the notions of bound and free name variables as well as bound and free predicate variables in the usual way. The set of free names , free name variables and free predicate variables of a formula A are denoted by f n(A), f nv(A) and f pv(A) respectively. Formulas that do not have free name variables are name-closed. Formulas that do not have free predicate variables are predicate-closed. A formula is closed if it is both name-closed and predicate-closed.
We defined on formulas the relation ≡α of α-congruence in the standard way, that is, as the least congruence identifying formulas modulo renaming of bound (name and predicate) variables. We will consider formulas always modulo α-congruence. Note that for formula, the notion of name substitution is extended to function from U ∪ V to U , i.e. we allow the name variables to be replaced by names. Note that for convenience, we identify β-equivalence formulas, that is, ((x˜)A)(u˜) and A[u˜/x˜].
The unary operator ч is negative. An occurrence of a predicate variable


is positive if it is under an even number of negative operators. X occurs pos- itively in a formula A if every occurrence of X in A is positive. Otherwise we say X occurs negatively in A. A fixpoint predicate νX.Λ is well-formed if f n(Λ) = f nv(Λ) = ∅ and X occurs positively in Λ. Note that we require that predicate Λ has no free name, thus n(Λ(u˜)) and fv(Λ(u˜)) are totally determined by the actual parameter u˜, which is very important to the sound- ness of semantics. A formula is well-formed if every fixpoint subformula in it is well-formed. In the sequel, we only consider well-formed formulas. Note that as usual, in our π-µ-logic system, we can define some standard derived connectives. In this paper, we choose an economical way to present our logical system.

Semantics
Given STG G, by the concrete operational semantics rules, we can get a concrete graph denoted by G. The semantics of formula is defined by assigning to each formula A a node set of G, i.e. A), namely all the nodes of G that satisfy the property denoted by A. For convenience, we denote nσ by s and for
any s ≡ nσ, s[c/b] ≡ nσ[b'→c]. Since formulas may contain free name variables and free predicate variables, to interpret them we need name valuations and predicate valuations. A name valuation ρ is an extended version of substi-
tution, which is a total mapping from U ∪ V → U with identity on U . A predicate valuation ξ assigns to every predicate variable X of arity k a function ξ(X) : U k → ℘(G). As usual, the relation ⊆ can be extended point-wise to functional space as follows: for each k, two functions f (k), g(k) : U k → ℘(G), define f (k) ± g(k) iff f (n˜) ⊆ g(n˜) for any n˜ ∈ U k. Thus, the functional space U k → ℘(G) forms a complete lattice w.r.t. ±. The denotation of formulas is defined inductively in Fig.1.
If A is name-closed then A)ρ;ξ does not depend on ρ and will be written
 A)ξ. Furthermore, if A is name-closed and predicate-closed, then A)ρ;ξ de- pends on neither ρ nor ξ and it will be written as A). We will write s |= A to denote s ∈ A).
As in the case of first-order logic, the following lemma which relates sub- stitutions with valuations is common, and will be used implicitly.
Lemma 3.1 The following properties hold:
A[b/x])ρ;ξ= A)ρ[x'→b];ξ.
Λ[F/X])ρ;ξ = Λ)ρ;ξ[X'→ξ(F )].
Proof. By mutual induction on the structure of A and Λ.	 
It is routine to show that for any formula A and B with A ≡α B, A)ρ,ξ =



Fig. 1. Interpretation of Formula

 B)ρ,ξ for any ρ and ξ, which justifies our decision to identify α-equivalent formulas. Also, we can easily show the monotonicity of the semantics function
Λ, since it is required that X occur positive in Λ. Thus, λf. A)ρ,ξ[X'→f] is a monotone functional over the complete lattice ({f : U k → ℘(G)}, ±). By Knaster-Tarski Theorem, we can draw the conclusion that νX.Λ is the greatest
fixpoint of λf. A)ρ,ξ[X'→f]. The soundness of semantics can be obtained.
Now, we do some remarks on the choice of modality for the logical system.
Generally speaking, there are two styles of syntax for the ’Hennessy-Milner logic’ like systems for π-calculus. One is used by [14], the other is used by [4][6]. We follow the style of the former since from our point of view, it is clearer. However, the semantics is dramatically different. First, [14] lacks a modality for bound output, although the syntax ⟨a¯(x)⟩A exists in the logic system. It is not difficult to see that the semantics for ⟨a¯(x)⟩A does not coincide with the intuition very much. Second, the input modality in this paper coincides with the ⟨a¯(x)⟩L in [14]. We don’t introduce the corresponding modality for the other two ’input’ modality because they can be rendered in our framework as



follows:

⟨a(b)⟩A def ∃x.⟨a?x⟩A	⟨a(b)⟩EA def ∀x.⟨a?x⟩A

The bound output modality needs more remarks. Note that our semantics for this modality coincides with Dam’s though the syntax is different. To make this modality clearer, we consult to the fresh name quantification  and Dam’s syntax a little. In fact,
⟨a!(x)⟩A = ⟨a⟩ x.x ← A
We think reader who is familiar with can easily understand this. We refer the reader to [2][3] for details. It is worth pointing out that as we men- tioned in Section 1, such a quantification conveys difficulties when giving an interpretation though it is only implicit in our logic. The similar problems have been considered in [2]. As a remedy, [2] introduces the notion of PSets (Property sets). However, such a semantic device makes the semantics defini- tion rather complex. Our solution is to make distinction between proposition and predicate, thus the possible interactions between recursion and first-order quantification can be solved. The advantage of our system lies in that the semantics of our logic is clearer and more concise. What’s more, it is more favorable for model checking purpose. Also, it is worth pointing out that we need not introduce ⟨a!(b)⟩-like modality, since by the semantics, the choice of concrete name as the content of output action is immaterial, therefore, we use a variable instead of name.
Now, we set to establish some important results concerning the properties of logical formula, which is important for the model checking algorithm. Fol- lowing [2], we use transposition as a useful tool to give some concise proof of properties concerning fresh names. Due to space restriction, most of detailed proofs are omitted. We refer the reader to the full version of this paper for more details. The following definition extends the notion of transposition to predicate.
Definition 3.2 Let θ be a transition. A function f : U → ℘(G) is θ- preserving if (f (n))θ = f (nθ) for any n. A valuation ξ is θ-preserving if ξ(X) is θ-preserving for any X.
Lemma 3.3 Given a transposition θ and a function f : U → ℘(G), deﬁne fθ : U → ℘(G) as fθ(n) = f (n) ∪ (f (nθ))θ for any n, then the following properties hold:
fθ is θ-preserving.
If f ± g and g is θ-preserving, then fθ ± g.

Proof. By the definition of transposition and θ-preserving, the proof is easy. 
Lemma 3.4 Suppose ξ is θ-preserving, then the following properties hold:
( A)ρ;ξ)θ = Aθ)ρ;ξ.
Λ)ρ;ξ is θ-preserving.
Proof. By mutual induction on the structure of A and Λ.
 
According to the semantics of ∀x.A and ⟨a?(x)⟩A , to check if P ∈ ∀x.A) requires to instantiate x with every name. However, as the following lemma demonstrates, it is sufficient to consider only the free names of A plus one fresh name. This finite characterization will be exploited in the model checking algorithm.
Lemma 3.5 Suppose c ∈/ f n(s, A), then the following properties hold:
s ∈ ∀x.A)ρ;ξ iff s ∈  k∈fn(A)∪{c} A)ρ[x'→k];ξ.

s ∈ ⟨u?(x)⟩A)

ρ;ξ
iff there exists s' s.t. s ρ(u)(b) s' and s'[k/b] ∈  A)

ρ[x'→k];ξ

for k ∈ f n(A) ∪ f n(s) ∪ {c}.
The semantics definition of the ⟨a!(x)⟩A is stated in ’existential’ style, i.e.
s |= ⟨a!(x)⟩A if there is some fresh name c and s', such that s a(b) s' and s'[c/b] |= A[c/x]. We give such a definition because from our point of view, it may coincide with our intuition of bound output and restriction operator
better. However, since c is not free in either s or A, this particular choice of c should not matter. That is, any other name d with d ∈/ f n(s, A) should equally do. Thus indeed the semantics can also be characterized ’universally’.

Lemma 3.6 s ∈  ⟨a!(x)⟩A)


ρ;ξ
iff there exists s' s.t. s a¯(b) s' and s'[c/b] ∈

 A)ρ[x'→c];ξ for every c ∈/ f n(s, A).
Model Checking Algorithm
In this section, we devote to providing a model checking algorithm for our π-µ-logic. Based on the results in the last section, now the most challenging problem is to deal with the fixpoint operator. For propositional µ-calculus, many researchers have provided a lot of methods to solve this problem. We choose the so called local model checking algorithm since the global algorithm requires a prior construction of state space, which is impossible in our setting. One of the notable features of such an algorithm is the mechanism used to keep track of unfolding fixpoint formula. There are two common, equivalent,

approaches to this problem: one is to introduce constants in which the name of fixpoints occurrences and to use a global rule of inference to detect pre- vious unwinding, the other is to introduce tags into fixpoint formula, which remembers exactly the points of the model that have been visited before. As in [15], we adopt the latter of the methods and follow the framework due to Winskel [16], sometimes referred as tag set method. However, differing from [15], we lift it to the predicate case and in our algorithm, the tag sets will contain pairs (n˜, s) of name vector and the node of STG. Formally, let
T = {(b˜1, s1),... , (b˜n, sn)}, where, n˜i (1 ≤ i ≤ n) are vectors of the same
length, say k and for 6i, j, i /= j, we have ˜bi /= ˜bj. For any tag set T , we use
λT to denote a function U k → ℘(G) defined as follows:


(λT )(˜b)= 
⎩
  i{si}	if (˜b, si) ∈ T
∅	if o.w.

Now, the fixpoint predicate νX.Λ can be generalized to νX.[T ]Λ, note that the X must have the same arity as T and the usage of T lies in recording what points of the model have been visited before thus is only a bookkeeping device. The definitions of n(νX.[T ]Λ), fv(νX.[T ]Λ) and f pv(νX.[T ]Λ) are the same as the corresponding definition for νX.Λ. Obviously, νX.Λ can be covered as νX.[]Λ.
The denotation of νX.[T ]Λ is a simple extension for νX.Λ)ρ;ξ as follows:
 νX.[T ]Λ)ρ;ξ = H{F : U k → ℘(G)|F ± Λ)ρ;ξ[X'→F ] H λT }
There now follows a technical lemma which is a generalization of the so called Reduction Lemma of [16], the essence of the tag set method.
Lemma 4.1 (Reduction Lemma) Let L = U k → ℘(G) be a complete lattice and let φ be a monotone functional. Then for any f ∈ L,
f ± νg.φ(g)	iff	f ± φ(νg.(φ(g) H f ))
Proof. Straightforward generalization of the proof in [16].	 
Since X occurs positive in Λ, λf. Λ)ρ;ξ[X'→f] H λT is a monotonic functional over U k → ℘(G), and νX.[T ]Λ)ρ;ξ is its greatest fixpoint. So, using Lemma 4.1, the following lemma can be easily proved.
Lemma 4.2 If s ∈/ λT (˜b), then
s ∈ νX.[T ]Λ)ρ;ξ(˜b)  iff  s ∈ Λ[νX.[T ∪ {(˜b, s)}]Λ/X])ρ;ξ(˜b)



def
check(mσ, φ) = Ev(φσ);
def
check(mσ,  A) =	check(mσ, A);
def
check(mσ,A	B) = check(mσ, A)	check(mσ, B);

check(mσ
, 6x.A
def
) =

b∈fn(mσ,A)
check(mσ
, A[b/x])Λ

check(mσ, A[new(f n(mσ, A))/x]);

check(m
, ⟨τ ⟩A
def 
Ev(φσ) Λ check(n
, A);

σ

check(m
) =
, ⟨a?(x)⟩A
φ,τ
m '→n
def 
σ

Ev(φσ Λ [bσ = a])

σ	) =
Λ 
φ,b(c)
m '→n
check(n
, A[d/x]);

check(m
, ⟨a!c⟩A
def 
Ev(φσ Λ [a = bσ] Λ [c = dσ]) Λ check(n
, A);

check(m
, ⟨a?b⟩A

def 
Ev(φσ Λ[a = cσ]) Λ check(n
, A);

check(m
, ⟨a!(x)⟩A

def 
Ev(φσ Λ [b = aσ])

Λcheck(nσ[c'→new(fn(mσ,A))], A[new(f n(mσ, A))/x]);
check(mσ, (νX.[T ]Λ)(˜b))

= ⎧⎨
⎩
true	if (˜b, mσ) ∈ T
check(mσ, (Λ[νX.[T ∪ {(˜b, mσ)}]Λ/X])(˜b))	o.w.
Fig. 2. Local Model Checking Algorithm


Now, we present our algorithm as follows. The algorithm inputs a STG with the root n and substitution σ and a closed formula A. As usual, we denote mσ as s. The algorithm returns true if s = mσ satisfies A, otherwise, it returns false. The pseudo-codes of the algorithm is presented in Fig.2. Recall that for a set of names V ⊂fin U , function new(V ) returns the least name in U \V .
Now, we devote to proving the correctness of our algorithm. To establish the termination property of the algorithm, we need to bound on the number of names for model checking process, just as in [15] to bound on the free variables. First, we should point out that according to the rule for transferring process terms to STG, all bound names in a STG are different. And since we adopt the α-equivalence for formula, we can assume the bound name variables in a formula are also different. Now, we write NG for the number of names


(including free and bound names) contained in the nodes of G and NA for the number of names and name variables contained in A. Note that names in tag set of the formula does not be included, since it only contributes as a bookkeeping. The following lemma is important, by which we can conclude that provided that each term only appears once in each tag set (just as in our algorithm), the size of tag set is bounded since the STG we consider is finite.
Lemma 4.3 For each recursive call of check, with caller parameter (s, A) and the callee parameter (s’,A’), Ns' + NA' ≤ Ns + NA
Proof. By case analysis for each recursive call, the proof is routine.	 
We now use this fact to give a well-founded ordering to formula. We write
A G A' iff A' is not a fixpoint formula and A is a proper sub-formula of A', otherwise A is the form (Λ[νX.[T ∪ {˜b, s}]Λ/X])(˜b) and A' is (νX.[T ]Λ)(˜b) where (˜b, s) ∈/ T and T contains only nodes from G. We aim to show that the
transitive closure  + of this relation is a well-founded order whenever G is
finite.
Lemma 4.4 If G is ﬁnite, then  + is a well-founded order.
Proof. Similar to [15], Proposition 4.	 
Theorem 4.5 For any STG with root r and closed formula A, the following properties hold:
check(r, A) terminates;
check(r, A)= true iff r ∈ A).
Proof. (Sketch)
Apply well-founded induction on  G, the termination is guaranteed.
Most cases follow closely the interpretation of formula. The cases for φ, чA and A Λ B, ⟨a?b⟩A and ⟨a!u⟩A are trivial. The correctness of case for 6x.A follows from Lemma 3.5(i). The case of ⟨a?(x)⟩A follows Lemma 3.5(ii).
The case of ⟨a!(x)⟩A follows Lemma 3.6. For the fixpoint (νX.[T ]Λ)(˜b),
Lemma 4.2 applies.
The proof is completed.	 

Conclusion
In this section, we conclude our work and discuss the related work. This paper deals with modal logic for mobile concurrent system and related model- checking algorithm. In this paper, we use symbolic transition graph to model


concurrent systems. A wide class of π calculus processes, that is, the finite- control processes can be represented as finite symbolic transition graph and such translation is rather simple.Thus our model has strong expressing power. A new version π-µ-Logic, an extension of the modal µ-calculus with boolean expressions over names, and primitives for name input and output is intro- duced as an appropriate modal logic for the π-calculus. Also our logical system can be seen as the extension for the modal logic in [14]. We give a concise semantics interpretation for our modal logic by making a distinction between proposition and predicate, thus the possible interactions between recursion and first-order quantification can be solved. Based on the above work, a local model checking algorithm for the logic is presented in this paper. We follow the well-known Winskel’s tag set method to deal with fixpoint operator. As for the problem of name instantiating, our algorithm follows the ’on-the-fly’ style, and systematically employs schematic names. The correctness of the algorithm is shown.
There is a sea of publications on model checking, but only a few address name-passing processes. The most related work on this paper may be [4][6], we have discussed his work in Introduction. There are also some work on value- passing process, e.g. [15] extends modal logic in [7] with fixpoints. The main concern of these papers is to formulate proof systems for deriving statements asserting whether a process satisfies a formula. Algorithm for model checking processes against such modal logics, was not payed much attention to. On the other direction, [11] deals with model checking value-passing CCS processes, by which some ideas of this paper is inspired. However, comparing the work on value-passing process, the modality of bound output conveys difficulties to both the semantics interpretation and model-checking algorithm, which is one of the main challenges on our work. We also should mention [2][3], the fresh name quantification concerning the bound output modality is studied there. We have compared our work with theirs in details in Section 3. We think our method, at least, is more favorable for model checking purpose. However, some useful tools, such as transposition, come from [2].
There are several directions for further research. How to improve efficiency of our algorithm, is an interesting problem. Also, we are investigating how to generate information diagnosis messages which will be useful in debugging a system when the answer returned by the algorithm is ’no’. Maybe we should apply symbolic technique in more depth.

References
R.M.Amadio, M.Dam. Toward a Modal Theory of Types for the π Calculus. Proc. Formal Techniques in Real Time and Fault Tolerant Systems 96, Uppsala. LNCS 1135, Springer, 1996.


L.Caires, L.Cardelli. A Spatical Logic for Concurrency (Part I). TACS’2001, Lecture Notes in Computer Science 2215, pp.1-30, Springer, 2001.
L.Caires, L.Cardelli. A Spatical Logic for Concurrency (Part II). Proc. CONCUR’02, LNCS 2421, pp.209-225, Springer, 2002.
M.Dam. Model Checking Mobile Processes. Information and Computation 129: 25-51, 1996.
M.Dam. On the Decidability of Process Equivalences for the pi-Calculus. Theoretical Computer Science 183, pp. 215-228, 1997.
M.Dam. Proof systems for π-Calculus Logics. To appear de Queiroz (ed.), ”Logic for Concurrency and Synchronisation”, Studies in Logic and Computation, Oxford Univ Press, 2003.
M.Hennessy, X.Liu. A Modal Logic for Message Passing Processes. Acta Informatics, 32:375- 393, 1995.
M.Hennessy, R.Milner. Algebraic Laws for Non-determinism and Concurrency, Journal of ACM, Vol 32, pp. 137-161, 1985.
Z.Li, H.Chen. Checking Strong/weak Bisimulation Equivalence and Observation Congruence for the π-calculus. In ICALP’98, Lecture Notes in Computer Science 1443, pp.707-718, Springer, 1998.
H.Lin. Complete Inference Systems for Weak Bisimulation Equivalences in the π-calculus, TAPSOFT’95, Lecture Notes in Computer Science 915, pp.187-201, Springer, 1995.
H.Lin. Model Checking Value-passing Processes. Proceedings of the 8th Asia-Pacific Software Engineering conference. Macau: IEEE Press, 2001, 3-10.
R.Milner. Communication and Concurrency, Prentice Hall, 1989.
R.Milner, J.Parrow, D.Walker. A Calculus of Mobile Process, part I/II. Journal of Information and Computation, 100:1-77, Sept.1992.
R.Milner, J.Parrow, D.Walker. Modal Logics for Mobile Process. Theoretical Computer Science, 114:149-171, 1993.
J.Rathke, M.Hennessy. Local Model Checking for Value-passing Process. Proceeding of the 9th International Conference on Theoretical Aspect of Computer Software, 1997.
G.Winskel. A Note on Model Checking the Modal µ-calculus. Theoretical Computer Science 83:157-167, 1991.
