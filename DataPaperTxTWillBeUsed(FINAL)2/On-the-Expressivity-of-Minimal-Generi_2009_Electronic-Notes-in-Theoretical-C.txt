

Electronic Notes in Theoretical Computer Science 228 (2009) 3–19
www.elsevier.com/locate/entcs

On the Expressivity of Minimal Generic Quantification
David Baelde
INRIA Saclay - ˆIle-de-France & LIX / E´cole Polytechnique Palaiseau, France

Abstract
We come back to the initial design of the ∇ quantifier by Miller and Tiu, which we call minimal generic quantification. In the absence of fixed points, it is equivalent to seemingly stronger designs. However, several expected theorems about (co)inductive specifications can not be derived in that setting. We present a refinement of minimal generic quantification that brings the expected expressivity while keeping the minimal semantic, which we claim is useful to get natural adequate specifications. We build on the idea that generic quantification is not a logical connective but one that is defined, like negation in classical logics. This allows us to use the standard (co)induction rule, but obtain much more expressivity than before. We show classes of theorems that can now be derived in the logic, and present a few practical examples.
Keywords: Proof theory, generic quantification, fixed points, higher-order abstract syntax.

Introduction
A logic is a system that can represent objects, but also provides means to analyze them, reason about the relationships between these objects. Different logics allow more or less natural encodings of different object systems. The notion of generic quantiﬁcation has been introduced in proof theory in order to obtain logics in which one can naturally specify systems involving variable bindings, such as programming languages, type systems or logics. Before detailing more that aspect, let us re- call how algebraic specifications can be logically supported, for three increasingly demanding tasks: computing, model-checking and reasoning — from the proof-as- programs viewpoint, representing objects, then finite and finally infinite behaviour functions on those objects.
The purpose of logical frameworks is to allow declarative and adequate repre- sentations of various object systems. The classic example is that natural numbers are in bijection with normal intuitionistic proofs of N ⊃ (N ⊃ N ) ⊃ N . Prolog built on that idea: the search for objects satisfying the specification is reduced to the search of some normal forms of proofs. Proof search in the framework provides a mean to compute according to the specification.

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.113

A logic should also provide some means to reason about its judgments, and hence about encoded objects. This is the role of elimination rules. The least is to support case-analysis, which turns proof-search into model-checking, that is inspecting finite behaviours. This is obtained by moving to the notion of fixed points. In that setting, nat is defined as μ(λX.λn.n = 0 ∨ ∃p.n = (s p) ∧ Xn), or simply μ(λX.T∨ X) if one regards proofs as programs. And the logic is equipped with the following case- analysis and back-chaining rules:

Γ, B(μB)t ▶ G


Γ, μBt ▶ G
Γ ▶ B(μB)t


Γ ▶ μBt

One does not need more for analyzing ﬁnite behaviours. Using the left unfolding rule, one can for example deduce that any natural number is either zero or a succes- sor. It is interesting to notice that when hypothesis can be exhaustively analyzed in a finite number of steps, the initial rule (also called axiom rule) becomes useless: after the exhaustive case analysis, the goal can be built explictly from its fixed point definition. For example, the Bedwyr [2] system works under that assumption.
In order to reason about inﬁnite behaviours or infinite collections of objects such
as natural numbers, the initial rule becomes necessary. This raises the question of the identity of judgments, which is negligible in many cases but crucial for generic judgments. More expressivity is often needed, coming with the distinction of two dual kinds of fixed points and their associated deduction principles: least fixed points are represented by inductive specifications μB and analyzed by induction; greatest fixed points are represented by coinductive specifications νB and are built by coinduction. All this is well-established proof theory:

Γ, St ▶ G	BSx ▶ Sx


Γ, μBt ▶ G
Γ ▶ St	Sx ▶ BSx

Γ ▶ νBt

It is important to notice that the addition of more introspective abilities to the logic did not make it miss the initial target, that is adequate representations. Proofs of nat are still exactly natural numbers, and proofs of nat ⊃ nat can still be seen as functions from natural numbers to natural numbers, computed via cut elimination. We shall now contrast that with the incomplete picture corresponding to the state of the art regarding the specification of systems involving variable binding.
The higher-order abstract syntax approach [12,6] pioneered by Twelf [14] and
λProlog [9] provides an elegant way to represent systems involving variable bind- ing, encoding the object-level binding by the notion of binding already present in the logic.  In the proof-as-program approach, one uses the abstraction of proofs
terms. In the λ-tree approach, term-level abstractions are used, e.g., encoding the
introduction of a generic variable by an universal quantification:
∀f. (∀x. term x ⊃ term (f x)) ⊃ term (abs (λx. fx))
The α-conversion of the logic is then inherited by the represented system. Of course, this technique only provides elegant encodings when the notions of scope and bind- ing of the encoded system match those of the encoding logic.
However, the universal quantification only acts as a generic quantification when it occurs positively. On the left hand-side of a sequent, its “for all” semantic makes

a difference: instead of introducing a generic variable, it is expecting a term to substitute for the variable. In spirit, generic quantification should not require to deal with terms inhabiting the types of generic variables. This mismatch required new proof-theoretic designs in order to obtain a satisfying support of case analysis. Several solutions [19,13,5] have been developped, revolving around an essential idea: keeping the generic variables in a context local to the formula. We shall focus on the earliest design, which is also the simplest incarnation of this idea: the ∇ quantifier [10,11]. It extends sequents with generic contexts σ surrounding formulas, denoted by σ D Pσ — we write Pσ to indicate that the generic variables can occur in the formula, also implicitly assuming that they don’t occur free in P anymore. We call this early design “minimal generic quantification” because of the absence of any structural rule for generic contexts. Despite its minimality, it is fully satisfying for reasoning about finite behaviours, where the identity of judgments does not matter. Notably, Miller and Tiu have shown that this core support of generic quantification, combined with least and greatest fixed points in the logic LINC [17], is enough for providing a fully declarative specification of finite π-calculus and its bisimulation [18]. Again, the ability to adequately represent objects has not been affected, since ∇ and ∀ are identical when restricted to positive occurences. When representing objects in the logic, we are actually only moving object-level binders to the formula-level generic context, which keeps an exact track of the scope.
Things get significantly more complicated with infinite behaviours. In LINC, the initial rule requires an exact match (modulo α-conversion) of the generic contexts:

σ D Pσ ▶ σ D Pσ 
Without any structural rule on the generic context, this often seems too restric- tive. The design of the induction rule also turns out to be problematic. In the end, the interplay of minimal generic quantification and fixed points in LINC lacks in expressivity. Theorems which should intuitively hold are underivable, e.g.,
∀x. (∇y. nat x) ⊃ nat x. This has lead to the development of radically different notions of generic quantification. It is typically made stronger, in order to always have ∀x. Px ⊃ ∇x. Px and ∇x. Px ⊃ ∃x. Px, which implies P ≡ ∇x. P when x does not occur free in P . In our opinion, this is not a satisfying solution: this stronger semantic of generic quantification does not match the needs of some speci- fications. Consider for example the specification of provability in some object logic. The natural fixed-point clause for universal quantification is:
prove Γ (∀ˆ(λx. Px)) := ∇x. prove Γ (P x)
With minimal generic quantification, the generic context exactly represents the sig- nature of the object sequent. With a stronger generic quantification this is no longer true. Indeed, we could derive immediately that prove Γ (∀ˆ(λx. P )) ⊃ prove Γ P . This is not wanted in all cases. In particular, in presence of a cut rule, one would expect that a proof of such a statement provides a way to eliminate cuts for which the cut-formula contains an occurence of the (seemingly) vacuous ∀ˆ. This inade- quacy can be seen as analogous to the impossibility to represent directly a linear logic in an intuitionistic framework.

In this paper, we come back to the design of minimal generic quantification. In Section 2 we propose the logic μLJ∇ as an alternative that brings the expected expressivity. The key is a better interaction of fixed point constructions and generic quantificaton, which is not treated as a logical connective anymore. Structural rules on the generic context will still not be admitted in general, allowing adequate representations of systems following a strict management of variables. In Section 3 we study the meta-theory of μLJ∇, notably exhibiting a large syntactic class of formulas for which structural rules can in fact be derived. Finally, we illustrate how the logic can be practically used on a few significant examples in Section 4.

Definitions
We shall work on two logics: μLJ∇0 which incarnates the initial design of minimal generic quantification, and its corrected version μLJ∇ where ∇ is no more a logical connective. In both systems, we are not going to consider atoms, that is predicate constants. By essence, atoms have an undefined behaviour, unlike fixed points. If one wants to obtain ∇x. p ⊃ p for an atom p, there is no other option than adding it as a rule in the logic, whereas with a fixed point the theorem could be obtained by (co)induction. Not considering atoms is motivated practically, because users of a logic usually work on defined notions, but also theoretically, as we find important for the logician to study what can be derived from the simplest definition before playing the game of choosing which axioms to force uniformly.
In the following, the type of formulas is o, and γ denotes a term type, that is any simple type in which o does not occur. Terms are denoted by u, v, t; formulas by P, Q, S; term variables by x, y, z; and predicate variables by p, q. We write vectors t , and sometimes (ti)i for readability. In all systems considered in this paper,
formulas are of the following forms:
P ::= P ∧ P | P ∨ P | P ⊃ P |T|⊥ 
γ	γ	−→	−→
|  ∃γx.Px | ∀γx.Px | ∇γx.Px | s = t | s /= t | μγ1...γn B t | νγ1...γn B t
The quantifiers have type (γ → o) → o and the equality and inequality have type γ → γ → o. The connectives μ and ν have type (τ → τ ) → τ where τ is γ1 → · · ·→ γn → o for some arity n ≥ 0. Formulas with top-level connective μ or ν are called fixed point expressions and can be arbitrarily nested. The first argument of a fixed point expression, denoted by B, is called its body. For consistency, it is required to be monotonic: negative occurences of the bound predicate variable are forbidden.
Figure 1 defines μLJ=, the basic system on top of which are built logics support- ing generic quantification. It consists in first-order propositional intuitionistic logic extended with fixed points and equality. For background and details about defini- tions, fixed points and the treatment of equality, we refer the reader to [16,7,17,2].
Generic contexts are lists of typed term variables, denoted by σ or ζ. If σ is a generic context (x1 : γ1,..., xn : γn) we denote by σ → γ the type γ1 → ... → γn → γ, and call it γ lifted over σ. Analogously, we talk of lifted variables when they have a lifted type. We also use a generic context as a list of terms, writing

Propositional intuitionistic logic Γ,P ▶ P	Γ, ⊥▶ P	Γ ▶T 

Γ, P,P' ▶ Q


Γ,P ∧ P' ▶ Q
Γ ▶ P	Γ ▶ Q


Γ ▶ P ∧ Q

Γ,P ▶ Q	Γ,P' ▶ Q


Γ,P ∨ P' ▶ Q
Γ ▶ P

Γ ▶ P ∨ P'
Γ ▶ P'

Γ ▶ P ∨ P'

Γ ▶ P	Γ,P' ▶ Q


Γ,P ⊃ P' ▶ Q
Γ,P ▶ Q


Γ ▶ P ⊃ Q

First-order structure

Γ,Ph ▶ Q


Γ, ∃x.Px ▶ Q
Γ,Pt ▶ Q

Γ, ∀x.Px ▶ Q
{(Γ ▶ Q)θ : tθ =.
Γ ▶ Pt 

Γ ▶ ∃x.Px
Γ ▶ Ph 
Γ ▶ ∀x.Px t'θ}

 
Γ,t = t' ▶ Q	Γ ▶ t = t
Fixed points

Γ, St ▶ P	BSx ▶ Sx


Γ, μBt ▶ P
Γ ▶ B(μB)t


Γ ▶ μBt

Γ, B(νB)t ▶ P
Γ, νBt ▶ P
Γ ▶ St	Sx ▶ BSx
Γ ▶ νBt


Fig. 1. Inference rules for μLJ= and μLJ∇. The eigenvariable h does not occur free in the conclusion sequent of ∀-R and ∃-L, and S is closed in μ-L and ν-R.
(Fσ) for ((F x1) ... xn). Similarly, f (xi)i stands for ((f x1) ... xn).
Type annotations are omitted for conciseness most of the time, but can be recovered from the context. In order to make type inference easier, we use the convention of naming x' a lifted version of x. Finally, we use the convention that when we write (λa.t), the variable a does not occur free in t.
The logic μLJ∇0
The logic μLJ∇0 is essentially the same as LINC [17]. The only difference lies in the use of fixed points rather than definitions. This slight shift of point of view brings more expressivity, but most importantly gives more flexibility when working on the logic.
The system is obtained from μLJ= by enriching the sequent structure, sur-
rounding each formula by a local generic context which binds generic variables in the formula. A formula surrounded by its generic context forms a generic judgment, denoted by G. Variables are introduced in the new context by generic quantification:

Γ, (σ, x) D Pσx ▶ G


Γ,σ D ∇x.Pσx ▶ G
Γ ▶ (σ, x) D Pσx


Γ ▶ σ D ∇x.Pσx

Propositional deduction rules are adapted in an orthogonal fashion.  Under the

generic context, the reasoning takes place as before, for example:



σ D Pσ ▶ σ D Pσ 
Γ ▶ σ D Pσ	Γ,σ D Qσ ▶ G


Γ,σ D Pσ ⊃ Qσ ▶ G
Γ,σ D Pσ ▶ σ D Qσ


Γ ▶ σ D Pσ ⊃ Qσ

The first-order rules interact with the generic context, causing a lifting of terms and term variables. In the rules for universal quantification, if x has type γ then t and the eigenvariable h have type σ → γ:

Σ; Γ,σ D Pσ(tσ) ▶ G


Σ; Γ,σ D ∀x.Pσx ▶ G
Σ, h;Γ ▶ σ D Pσ(hσ) Σ; Γ ▶ σ D ∀x.Pσx

{(Γ ▶ G)θ : tθ =.
t'θ}


 
Γ,σ D tσ = t'σ ▶ G	Γ ▶ σ D tσ = tσ
At this point, we have described how the logic treats ﬁnite behaviour formulas, those that do not involve fixed points. In that setting, the deduction rules can be read as equivalences, for example ∇x. Px ∧ Qx ≡ (∇x. Px) ∧ (∇x. Qx), which allow to eliminate ∇ by pushing it down through logical connectives, eventually disappearing, for example thanks to (∇x. ux = vx) ≡ u = v. A similar observation is that any proof of a finite behaviour can be η-expanded until it does not use the initial rule anymore, but where the only leafs are the rules for T, ⊥ and equality. Both observations imply that there is no need to ever compare two generic contexts, and hence no need to consider structural rules for them. Note, however that the dynamic aspect of the second one makes it stronger; for example it extends to fixed points, giving rise to the Bedwyr system.
The fixed point rules are adapted as follows:

Γ,σ D S(tσ) ▶ P	BSx ▶ Sx


Γ,σ D μB(tσ) ▶ P
Γ ▶ σ D B(μB)(tσ) Γ ▶ σ D μB(tσ)

The extended unfolding rule states that liftings of a fixed point unfold just like the original version. The induction rule seems less natural, essentially stating that liftings of the invariants of a fixed point are invariants of its liftings. Tiu noticed [17] that it was too weak, since it does not allow any modification of the generic context σ when inducting under it. As a consequence, it is impossible to prove things like
∀x. (∇a. nat x) ⊃ nat x. This seems unfortunate because nat, defined as a fixed point, clearly does not rely on the generic context.

μLJ∇: treating ∇ as a non-logical connective
The self-duality of generic quantification, as well as its ability to commute with almost all connectives of μLJ∇0 , suggests that it might not be a logical connective but rather a deﬁned one, like negation in classical logics. Indeed, we shall define a formula transformation φ that transforms a formula into one where the ∇ quantifiers only occur above bound predicate variables inside fixed point constructions. This is in slight contrast with the classical negation which can be eliminated statically even inside fixed points, because of the monotonicity constraint. The important point remains: since ∇ does not occur anymore at toplevel in a sequent, it loses its logical role.

The logic μLJ∇ has the same rules as μLJ=, cf. Figure 1. Unlike μLJ∇0 , it has no extra sequent structure. The rules for fixed points are written the same way, but the implicit elimination of toplevel ∇ quantifiers which might occur in BS will play a critical role.

Γ, St ▶ P	BSx ▶ Sx


Γ, μBt ▶ P
Γ ▶ B(μB)t


Γ ▶ μBt

We define the connective ∇ by identifying a formula F at toplevel in a se- quent with φ(F ) where ∇ does not occur anymore except inside fixed point bodies. The transformation is parametrized by two contexts initially empty, and written φΓ(P|Γ|σ). Here, σ is a generic context, i.e., a list of term variables. The context Γ contains associations of the form ⟨p, σ, p'⟩ where p is a predicate variable of type γ, σ = x1 : γ1,..., xn : γn is a generic context and p' is an other predicate variable of type γ1 → ... → γn → γ. The support of Γ, written |Γ|, is the variables p. As indi- cated by the notation in P|Γ|σ, the predicate variables of |Γ| and the term variables of σ may occur in the original formula. These occurences are bound by the two contexts. In the transformed formula only the p' will be found. Finally, the order does not matter in Γ unlike in σ. The inductive definition of the transformation is given on Figure 2.
That full definition can be reduced to the definition of the behaviour of φ on term and predicate abstractions and variables, extended in an orthogonal way to the full language of formulas. For doing so, one should carefully separate the binding and logical aspects of ∀, ∃,μ and ν. Along these lines, we shall write φ applied not only to formulas but also to formulas abstracted over terms such as in φσ(μB), or formulas and terms such as in μφσ(B).
φΓ(∇x. P|Γ|σx) ≡ φΓ (P|Γ|σx)
σ	σ,x
φΓ(∀x. P|Γ|σx) ≡ ∀x'. φΓ(P|Γ|σ(x'σ))	φΓ(∃x. P|Γ|σx) ≡ ∃x'. φΓ(P|Γ|σ(x'σ))
σ	σ	σ	σ
φΓ(μ(λpλ−→x. B|Γ|pσ−→x )(−−→)) ≡ μ(λp'λ−→y . φΓ,⟨p,σ,p'⟩(B|Γ|pσ(−−→)))−→
σ	tσ	σ	yσ	t
φΓ(ν(λpλ−→x. B|Γ|pσ−→x )(−−→)) ≡ ν(λp'λ−→y . φΓ,⟨p,σ,p'⟩(B|Γ|pσ(−−→)))−→
σ	tσ	σ	yσ	t
φΓ(a(tσ)) ≡ ∇σ. a(tσ)	φΓ,⟨p,σ,p'⟩(p(tσσ')) ≡ ∇σ'. p'(λσ. tσσ')
σ	σσ'
φΓ(uσ = vσ) ≡ u = v	φΓ(T) ≡T	φΓ(T) ≡T 
σ	σ	σ
φΓ(P|Γ|σ ∧ Q|Γ|σ) ≡ φΓ(P|Γ|σ) ∧ φΓ(Q|Γ|σ)
σ	σ	σ
φΓ(P|Γ|σ ∨ Q|Γ|σ) ≡ φΓ(P|Γ|σ) ∨ φΓ(Q|Γ|σ)
σ	σ	σ
φΓ(P|Γ|σ ⊃ Q|Γ|σ) ≡ φΓ(P|Γ|σ) ⊃ φΓ(Q|Γ|σ)
σ	σ	σ
Fig. 2. The transformation φ defining ∇


Example 2.1 The elimination of ∇ on finite-behaviour formulas described for μLJ∇0 in Section 2.1 is now an identity. In μLJ∇ the two following formulas are identified:
∇x.∀y.∇z.y = z ⊃⊥	≡	∀y'.(λxz.y'x) = (λxz.z) ⊃⊥ 

Example 2.2 We define the well-formedness of terms in a purely abstractive lan- guage, assuming constants nil :: lst, cons :: α → lst → lst and abs :: (α → tm) → tm, as follows:
mem = μ(λMλxλΓ. ∃hd∃tl. Γ = (cons hd tl) ∧ (x = hd ∨ M x tl))
term = μ(λTλΓλt. mem t Γ ∨ ∃f. t = abs f ∧ ∇αx. T (cons x Γ) (f x))
It does not look very different from μLJ∇0 . But the ∇ inside the body of the fixed point term should be read as a suspensed lifting, waiting for the instantiation of T . In a sense, the fixed point does not only define a predicate, but rather a family of liftings. Let us now consider the lifting of the definitions of mem and term. For readability we lift over an other type than α:
def
φ(y:β)(mem) =
μ(λM'λx'λΓ'. ∃hd'∃tl'. Γ' = (λβy. cons (hd' y) (tl' y)) ∧ (x' = hd' ∨ M' x' tl'))

φ(y:β)
(term) d=ef μ(λT'λΓ'λt'. φ 
(mem) t' Γ' ∨

∃f'. t' = (λβy.abs (f'y)) ∧ ∇x. T ' (λβy. cons x (Γ'y)) (λβy. f'yx))
In other words, the induction on φ(y:β)(term) corresponds to the following principle, where S is the tentative invariant:
(∀Γ'∀x'. φ(y:β)(mem) x' Γ' ⊃ S Γ' x')
⊃ (∀Γ'∀f'. φ(x:α)(S) (λxλy. cons x (Γ'y)) (λxλy. f'yx) ⊃ S Γ' (λy. abs (f'y)))
⊃ (∀Γ'∀t'. φ(y:β)(term) Γ' t' ⊃ S Γ' t') For example it can be used with the invariant:
S := λΓ'λx'.∀Γ∀x. (Γ' = (λy.Γ) ∧ x' = (λy.x)) ⊃ term Γ x
After a similar sub-induction on φ(y:β)(mem) one will have obtained a derivation of:
∀Γ∀x. (∇y. term Γ x) ⊃ term Γ x

The theory of μLJ∇
The lifting transformation behaves nicely with respect to first-order abstraction, i.e., φσ(Fσ(tσ)) ≡ ((λx'. φσ(Fσ(x'σ)))t). Unfortunately, the same does not hold for second-order abstraction: φσ(B)φσ(S) is not necessarily the same as φσ(BS). Consider an abstraction B := (λp . . . ∇σ'(...p.. .)). In φσ(BS) the occurence of p will become φσσ' (S) whereas in φσ(B)φσ(S) it becomes φσ' (φσ(S)).
This is technically complicating the metatheory, but our attempts to change the definition and avoid that have been unsuccessful. In fact, this permutation of names can be understood as inherent to the identifaction of ∇σ. μB and μφσ(B). Indeed, these two fixed points reveal two different prefixes of generic quantifiers after n unfoldings, respectively σ(σ')n and (σ')nσ.

We shall establish, however, that the permutation of names does not affect provability. This can be derived in the logic itself, not only at the meta level. It will provide a way to bridge the gap between φσ(BS) and φσ(B)φσ(S) by translating all permuted instances.
Proposition 3.1 For any formula P, and any two generic contexts σ and σ∗ per- mutations of each other, it is provable that (∇σ. Pσ) ⊃ (∇σ∗. Pσ).
The proof basically builds a corrected η-expansion, carrying the permutability from elementary formulas (equality, T and ⊥) through all connectives including μ and ν. In a sense, there is nothing clever in it: at any point there is only one choice that keeps things well-typed. That said, it is a good test for the logic to check that everything goes as expected. The details of this proof, as for other propositions of this section, can be found in [1].
Corollary 3.2 Proposition 3.1 actually provides a mean to transform a deriva- tion into another one establishing the same sequent where some instances of φσ(F ) have been replaced by some permutation φσ∗ (F ): this is done by cutting against η-expansions of the derivations provided by the proposition. In particular, it allows to compensate the difference between φσ(B)φσ(S) and φσ(BS).
Definition 3.3 We extend the notion of lifting to sequents:
φσ(x1,..., xn; P1(xi)i,..., Pm(xi)i ▶ Q(xi)i) :=
x' ,..., x' ; φσ(P1(x' σ)i),..., φσ(Pm(x' σ)i) ▶ φσ(Q(x' σ)i)
1	n	i	i	i
Proposition 3.4 (Lifting derivations) For any σ, the provability of Σ; Γ ▶ P
implies that of φσ(Σ; Γ ▶ P ) 1 .
This allows one to read a proof of (∀t. (∇a. p t) ⊃ p t) as not only establishing that the provability of p in the context of one unused generic variable entails that of p in the empty context, but more generally that the provability is stable by removal of an unused variable from any context. This is what makes our system expressive without any need for concrete manipulations of the context and other complex devices such as quantifications over all generic contexts.
Proposition 3.5 (Conservativity & expressivity) We call 0-provability the provability without any use of the (co)induction rules. Let P be a formula, pos- sibly involving ∇ quantiﬁcations.
The 0-provability of P in μLJ∇0 is equivalent to its 0-provability in μLJ∇.
Moreover, the provability of P in μLJ∇0 implies its provability in μLJ∇,
but the converse is false.
Proof. Each direction of (i) is done by induction on the 0-derivation. Both are straightforward proof transformation similar to those detailed before, including cor- rective cuts (cf. Corollary 3.2) as in Proposition 3.4. For (ii) we add the translation

1 We do not follow the notational conventions here: of course, the variables of Σ can occur in Γ and P , unlike those of σ.

of an induction in μLJ∇0 to μLJ∇, which amounts to lift the invariant and the invariance proof. Finally, (iii) shall be seen later, with the ability to weaken the generic context in some cases in μLJ∇, which is impossible in μLJ∇0 .	 

Cut-elimination
We adapt the proof reductions involved in cut-elimination, and argue that the ter- mination is not affected, leaving a detailed proof of that for future work. The only novelty is the transformation φ. It only affects second-order instantiations in fixed point unfoldings, induction and coinduction. It does not affect several important properties of the system: proofs can be instantiated, the signature can be enriched, etc. The non-trivial part is adapting the reduction for eliminating a cut on a fixed point. We only show the case of the least fixed point, the greatest being similar.
The essential reduction for least fixed point is the following:

	ΠS	
BS−→x ▶ S−→x
Π'


−→
,S t ▶ P

Π'	fold(Π, ΠS)

−→
, μB t ▶ P
−→
▶ μB t
Γ ▶ P	−→
−→
,S t ▶ P
Γ ▶ P
−→
▶ S t

Where the fold(Π, ΠS) transformation replaces in Π all unfoldings of μB by a cut against ΠS. More precisely, since the unfoldings might be lifted, occurences of φσ(μB) = μ(φσ(B)) are replaced by φσ(S):

	.			.	

Γ ▶ φσ(B)(μ(φσ(B)))−→
φσ(B)φσ(S)−→
σ(S)−→
Γ ▶ φσ(B)φσ(S)−→


Γ ▶ μ(φσ
t
(B))−→	μR −→
t ▶ φ
Γ ▶ φσ
t
(S)−→
t
cut

To complete this, one must build from ΠS, for a given σ and −→, a proof of
φσ(B)φσ(S)−→	σ (S)−→. Using Proposition 3.4 on ΠS we get a derivation of
φσ(BS−→x ) ▶ φσ(S−→x ). Then, Corallary 3.2 gives a proof of φσ(B)φσ(S)−→x ▶ φσ(S)−→x
where −→x can finally be instantiated by −→.
We leave the termination of the reduction for further work. Strictly speaking, cut-elimination has not been established even for μLJ∇0 , which does not have the stratification constraints on which is built the proof for LINC [17]. However, based on earlier work on μMALL= [3], we believe that it holds under the simple constraint of monotonicity. But even with the stratification constraint on fixed points, the termination of cut-elimination for LINC does not carry easily to μLJ∇, because of the extra cuts inserted in the above reduction for translating between φ(BS) and φ(B)φ(S).

Structural rules on the generic context
Minimal generic quantification in μLJ∇0 did not assume an infinity of undistin- guishable generic variables, hence the absence of an immediate way of obtaining strengthening or exchange on generic contexts. This has not been changed with

μLJ∇. For example, (∇γx. T) э (Eγx. T) still can not be derived without as- suming the non-vacuity of γ, which would make even (Eγx. T) alone derivable. Symmetrically, 6 does not imply ∇ in general. And vacuous generic quantifications can not a priori be added or removed.
We show, however, that the missing generic strengthening and weakening are actually derivable for a reasonable class of formulas. On such formulas, the mini- mality does not make generic quantification weaker than other approaches, just as in the finite behaviour case. The essential idea for obtaining generic strengthening, that is (∇x. P ) э P , is to forbid positive occurences of existential quantification, unless they are guarded by a formula that ensures that the existential variable does not depend on the extra generic variable x.
Definition 3.6 A guard is a formula G such that for any σ:
6y'. φxσ(Gσ(y'xσ)) э Ey. y' = (λx. y) Λ φσ(Gσ(yσ))
A typical guard would be an equality (λσλy. uσy = vσy) such that all unifiers of (λxσ. uσ(y'xσ) = vσ(y'xσ)) set y' := λxλσ.yσ for some y.  This holds for the equalities found in most fixed point definitions, which fully define the newly introduced existential variable as a compound or a sub-term of the pre-existing terms.
Definition 3.7 The fragments У and £ (respectively standing for Уeakening and
£trengthening) are mutually defined by the following grammar, where G denotes a guard:
У ::= У Λ У | У V У | T | ⊥ | u = v | ∇x.У | μУ | νУ
| £ эУ | Ex. W | 6x. Gx эУ 
£ ::= £ Λ £ | £ V £ | T | ⊥ | u = v | ∇x.£ | μ£ | ν£
| У э£ | 6x. £ | Ex. Gx Λ£ 
Proposition 3.8 For any formula W ∈ У (resp. S ∈ £) it is provable that W э
∇x. W (resp. ∇x. S э S).
An other way to put it, for example, is that the following rules are admissible in μLJ∇:

Γ, σ, σ' D Sσσ' ▶ G


Γ, σ, x, σ' D Sσσ' ▶ G
Γ ▶ σ, σ' D Wσσ'


Γ ▶ σ, x, σ' D Wσσ'

Proposition 3.8 is very useful in pratice. Indeed, most common fixed points (nat, mem, append, term, typeof . . . ) are both in £ and У: they do not involve any universal quantification and the existential quantifications are guarded by equalities. Most of the time, the existentials are actually very weak in that they do not even require any invention, such as in Ey. x = s y Λ .. ..
Example 3.9 Coming back to the introductory discussion about adequacy, the typical example of a fixed point that does not fall in £ is provability in an object

logic with a cut rule. Indeed, the cut rule involves an existential quantification that is not guarded at all, and can notably range over variables present in the object-level signature (that is the generic context) even though not anywhere else in the object sequent (that is the parameters of our fixed point). Thus, deriving prove Γ (6ˆ(λx. P )) э prove Γ P necessarily involves the description of at least a limited form of cut-elimination that removes the cut-formulas involving the allegedly useless generic variable x. It seems reasonable that such a non-trivial property of the encoded logic is not given for free by the logical framework but has to be worked out the user.

Another example of guard would be nat itself, as it forces its parameter to be fully defined in terms of the constants zero and successor. We let the reader check that the following can be derived in μLJ∇: (∇x. nat(y'x) э Еy. y' = (λx.y) Λnat y. More interestingly, it should be possible to characterize a fragment of valid guards, which could build on top of guards like our У and £ did, such that from a basic guard (e.g., λy. x = s y) one could derive an other (e.g., nat), and an other (e.g., natlist), etc.


Practical use of μLJ∇
We describe here a few significant examples of what can be done with μLJ∇. These examples have been checked 2 using the interactive theorem prover Taci [15], an unreleased tool from the Slimmer project. Taci is a simple generic tactic-based interactive theorem prover, in which a logician can plug his own logic as an OCaml module. Starting with the initial specification of μLJ=, we added support for the transformation φ, obtaining a convenient implementation of μLJ∇. Formulas are not always manipulated in φ-normal form, but generic variables can occur in an explicit generic context. The elimination of toplevel generic quantifications and contexts is triggered by the tactic abstract, usually before applying the induction rule.
It currently provides little automation, incarnated by the tactic prove which performs a focused proof-search. It treats fixed points as described in [3] but is still not able to infer invariants, and is thus limited to unfoldings. Ongoing work in that direction promises much more automation in these simple developments. In particular, instances of all properties proved in this paper would actually be established automatically by simple heuristics: in our proofs, when we build a derivation using the induction rule, the invariant can be infered from the conclusion. Bureaucratic lemmas such as strengthening of generic quantification, but also more subtle things, detailed in the next example, would not be a burden for the user anymore: the cost of having a minimal generic quantification would vanish.


2 However, the code shown in this section is often not valid for Taci, but has been simplified for readability.

The copy program
In that example we shall work on a representation of untyped λ-terms. We assume a signature with a type tm and two constants: app of type tm → tm → tm and abs of type (tm → tm) → tm. Notice that since these are term-level constants and not fixed point definitions, there is nothing wrong with negative occurence of tm in the type of abs. The copy program is defined as follows in λProlog:
copy (app M N) (app P Q) := copy M P, copy N Q. copy (abs M) (abs P) :=
pi x\ pi y\ copy x y -> copy (M x) (N y).
It can be used for example to substitute a term into another: copy A B -> copy M N requires that N is M where some (but not necessarily all) occurences of A are changed into B.
There are mainly two approaches for encoding such a program in our logic. The first one is essentially the two-level approach [8] taken for example in the Abella system [4]. It consists in specifying λProlog proof-search as an object logic, and reasoning about its behaviour on the copy program. Given the initial formulation of the problem, this is best from an adequacy point of view, but it is heavy and notably does not allow direct inductions on the structure of copy. Instead, we encode the program directly. We argue that this preserves most essential points, and is adequate.
The encoding of the universal quantification in the abstraction clause is a ∇ quantification, reflecting the introduction of a generic variable. In order to encode in a monotonic way the implication in that abs clause, we introduce a context parameter representing the copy atoms present in the λProlog context. In the encoding, a new clause appears, stating that if copy M N is found in the context, then it holds.

copy := μ copy. λΓMN.
⟨M, N⟩∈ Γ
V (EM1M2N1N2. M = (app M1 M2) Λ N = (app N1 N2) Λ
copy Γ M1 N1 Λ copy Γ M2 N2)
V (EM1N1. M = (abs M1) Λ N = (abs N1) Λ
∇xy. copy (⟨x, y⟩ :: Γ) (M1x) (N1y))
We shall prove an useful fact about that inductive definition:
6MN. copy [] M N э M = N

This property should be proved by induction over copy. A naive invariant would be that the context contains only pairs (m, m). It does not hold: when going under an abstraction, two generic variables are introduced, marked equal in the context Γ. Since they are generic, it does not break the result, but does make the invariant more complex.

In fact, we proceed by proving that copy implies eq, where eq is defined as a least fixed point mostly like copy except for its abstraction clause:
eq (abs M ) (abs N ) := ∇x. eq (⟨x, x⟩ :: Γ) (M x) (N x)
For eq, it is now easy to show that if the context contains only pairs (m, m), it will remain true and hence eq implies equality. It remains to show that copy implies eq, which actually holds for any Γ. This is done by induction over copy, the interesting case being that of abstraction:
6ΓMN.  (∇ab. eq ((a, b) :: Γ) (M a) (N b))
э   (∇a . eq ((a, a) :: Γ) (M a) (N a))
This goal really expresses the heart of our problem with the shape of the context. It requires an induction under two generic quantifications. Basically, the invariant should state that two generic variables can be merged. After having lifted eq over the generic quantifications on a and b, this can actually be written elegantly as a simple invariant, and the proof of invariance is straightforward:
λΓ''M''N''. ∇a. eq (Γ'' a a) (M'' a a) (N'' a a)
We do not know of any other system where it is possible to obtain the name merging principle from the induction rule in such a direct way. The proofs cited above can however be carried out in other logics, for example in LG [19] as pointed out by Gacek, thanks to the strengthening on names. Since strengthening and exchange are also admissible in μLJ∇ for copy and eq, that gives alternate, less direct proofs in our system.
λ-calculus
We now discuss the specification of simply typed λ-calculus `a la Church, and the proofs of subject reduction and determinacy of typing. The signature for terms will consist of two types: ty for simple types and tm for λ-terms; two constants for terms: app :: tm → tm → tm and lambda :: ty → (tm → tm) → tm; the constant arrow :: ty → ty → ty for types, as well as some arbitrary base types.
We shall not detail the definition of a predicate bind such that when Γ is a list of pairs representing bindings, bind Γ k v expresses that ⟨k, v⟩∈ Γ. We define a least fixed point typeof such that the typing judgement (Γ ▶Λ→ m : t) is represented by (typeof Γ m t):
inductive typeof G M T := (bind G M T) ;
(sigma t\m1\m2\
M = (app m1 m2), typeof G m1 (arrow t T), typeof G m2 a) ; (sigma t\t’\f\
M = lambda t f, T = arrow t t’,
nabla x\ typeof (cons (pair x t) G) (f x) t’).
Along these lines, we also specify one-step β-reduction as a least fixed point called one, and prove subject reduction as well as determinacy of typing. However,

the statement of the theorems required particular care. In this style of specification, a variable is nothing but a placeholder for a term. Note for example that in the typing relation, nothing forbids the typing context Γ to contain constructed terms, instead of only variables as usual. This seems interesting, but certainly differs from the informal practice. One can try to stick to the usual notion of context; for example we established subject reduction under the assumption that the context does not contain constructed terms:
theorem subject_reduction : pi m\n\ one m n =>
pi G\
(pi t\a\t’\ bind G (lambda t a) t’ => false) => (pi a\b\t’\ bind G (app a b) t’ => false) =>
pi t\ typeof G m t => typeof G n t.
For typed determinacy, we used an alternative definition of the notion of context. Instead of assuming that keys are unique and not constructed, we assumed that each binding satisfied type determinacy:
context G := pi x\t\ bind G x t => pi t’\ typeof G x t’ => t=t’. theorem type_determinacy :
pi g\x\t\ typeof g x t => context g => pi t’\ typeof g x t’ => t=t’.
This formulation implies new branches compared to the usual proof. However they are trivially treated, and overall the proof is not more complex than with more traditional notions of contexts. Moreover, the resulting theorem is also slightly stronger than the usual one, as it allows richer contexts.
We also explored a named style of specification, which involves the addition of
a type n for free variables and a constructor var :: n → tm. The typing relation can then be written as follows:
inductive typeof G M T :=
(sigma v\ M = var v, bind G v T) ; (sigma t\m1\m2\
M = app m1 m2, typeof G m1 (arrow t T), typeof G m2 t) ; (sigma t\t’\f\
M = lambda t f, T = arrow t t’,
nabla x\ typeof (cons (pair x t) G) (f (var x)) t’).
With that specification, typing contexts now contain only variables, which are objects of a different kind than terms. This lead to a significantly shorter proof of type determinacy, requiring less bureaucracy.
With both styles of specification, the μLJ∇ proof of subject reduction could not be completly built within Taci, because our tool currently only strictly sup- ports higher-order patterns. With the first specification, only a small gap was left because of that. However, the named style of specification was very inconvenient to work with, producing much more unifications outside of the fragment, for ex- ample (x\var x) = (x\m (var x)).  In any case, this is only a problem of the

implementation, not of the logic.

Conclusion
Thanks to a reformulation of the ∇ quantifier as a defined connective, we have re- vealed the expressivity of minimal generic quantification in presence of fixed points. This resulted in the logic μLJ∇, which is a good candidate for adequately repre- senting objects, and reasoning in an expressive way about them.
We have notably exhibited classes of formulas for which generic weakening and strengthening could be derived. It should be possible to build other classes cor- responding to other common logical principles, such as (∇x. Px) э (6x. Px), or maybe even more exotic ones like (∇xy. Pxy) э (∇x. Pxx). More importantly, these results should be integrated in mechanized theorem provers to simplify their use. In fact, we claim that simple inductive theorem proving heuristics should be able to achieve this goal, since the derivations do not involve clever invariants. Re- garding automated theorem proving, an other strength of μLJ∇ is that its rules are standard ones, the only novelty being in the quotienting of the formulas modulo the lifting φ. Thus, results and heuristics for μLJ= should immediately extend to μLJ∇.
From a theoretical point of view, we expect that the essential ideas behind the design of μLJ∇ could be put to work in other settings if needed. For example, adding structural rules to μLJ∇0 , i.e., working in LG, brings enough expressivity for many non-trivial examples, but it is still unknown if that approach is strictly more expressive. It might not be, as some trivial theorems of μLJ∇ do not seem to be provable in LG, such as 6lx'. (∇n. mem (x' n) l) э Еx. x' = (λn. x).
Our system seems closely related in spirit to [13] which also manages contexts in a strict way. But it is difficult to clearly relate the two approaches, since ours is based on first-order logic while Pientka’s is purely computational but higher-order. Extending our system to higher-order logic would be challenging but interesting, and should allow for a better comparison with systems based on the proof-as-program viewpoint.


Acknowledgement
I am grateful to Andrew Gacek, Dale Miller, Gopalan Nadathur and Alwen Tiu for many insightful discussions on this topic.

References
David Baelde. On the expressivity of minimal generic quantification: Extended version. Technical report, 2008. Available from http://hal.inria.fr/inria-00284186.
David Baelde, Andrew Gacek, Dale Miller, Gopalan Nadathur, and Alwen Tiu. The Bedwyr system for model checking over syntactic expressions. In Frank Pfenning, editor, 21th Conference on Automated Deduction (CADE), number 4603 in LNAI, pages 391–397. Springer, 2007.

David Baelde and Dale Miller. Least and greatest fixed points in linear logic. In N. Dershowitz and
A. Voronkov, editors, International Conference on Logic for Programming and Automated Reasoning (LPAR), volume 4790 of LNCS, pages 92–106, 2007.
Andrew Gacek. The Abella interactive theorem prover (system description). Available from http://arxiv.org/abs/0803.2305. To appear in IJCAR’08, 2008.
Daniel R. Licata, Noam Zeilberger, and Robert Harper. Focusing on binding and computation. Technical Report CMU-CS-08-101, Department of Computer Science, Carnegie Mellon University, 2008.
Dale Miller. Abstract syntax for variable binders: An overview. In John Lloyd and et. al., editors,
Computational Logic - CL 2000, number 1861 in LNAI, pages 239–253. Springer, 2000.
Raymond McDowell and Dale Miller. A logic for reasoning with higher-order abstract syntax. In Glynn Winskel, editor, 12th Symp. on Logic in Computer Science, pages 434–445, Warsaw, Poland, July 1997. IEEE Computer Society Press.
Raymond McDowell and Dale Miller. Reasoning with higher-order abstract syntax in a logical framework. ACM Trans. on Computational Logic, 3(1):80–136, 2002.
Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. Uniform proofs as a foundation for logic programming. Annals of Pure and Applied Logic, 51:125–157, 1991.
Dale Miller and Alwen Tiu. A proof theory for generic judgments: An extended abstract. In 18th Symp. on Logic in Computer Science, pages 118–127. IEEE, June 2003.
Dale Miller and Alwen Tiu. A proof theory for generic judgments. ACM Trans. on Computational Logic, 6(4):749–783, October 2005.
Frank Pfenning and Conal Elliott. Higher-order abstract syntax. In Proceedings of the ACM-SIGPLAN Conference on Programming Language Design and Implementation, pages 199–208. ACM Press, June 1988.
Brigitte Pientka. A type-theoretic foundation for programming with higher-order abstract syntax and first-class substitutions. In 35th Annual ACM Symposium on Principles of Programming Languages (POPL’08), pages 371–382. ACM, 2008.
Frank Pfenning and Carsten Schu¨rmann. System description: Twelf — A meta-logical framework for deductive systems. In H. Ganzinger, editor, 16th Conference on Automated Deduction (CADE), number 1632 in LNAI, pages 202–206, Trento, 1999. Springer.
Zach Snow, David Baelde, and Dale Miller. Taci: an interactive theorem proving framework. 2007.
Peter Schroeder-Heister. Rules of definitional reflection. In M. Vardi, editor, Eighth Annual Symposium on Logic in Computer Science, pages 222–232. IEEE Computer Society Press, IEEE, June 1993.
Alwen Tiu. A Logical Framework for Reasoning about Logical Specifications. PhD thesis, Pennsylvania State University, May 2004.
Alwen Tiu. Model checking for π-calculus using proof search. In Mart´ın Abadi and Luca de Alfaro, editors, CONCUR, volume 3653 of LNCS, pages 36–50. Springer, 2005.
Alwen Tiu. A logic for reasoning about generic judgments. In A. Momigliano and B. Pientka, editors,
Int. Workshop on Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP’06), 2006.
