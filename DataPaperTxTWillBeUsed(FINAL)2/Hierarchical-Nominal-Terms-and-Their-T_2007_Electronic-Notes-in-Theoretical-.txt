Electronic Notes in Theoretical Computer Science 174 (2007) 37–52	
www.elsevier.com/locate/entcs

Hierarchical Nominal Terms and Their Theory of Rewriting
Murdoch J. Gabbay1
Computer Science Department Heriot-Watt University, Riccarton Edinburgh EH14 4AS
Great Britain
murdoch.gabbay@gmail.com


Abstract
Nominal rewriting introduced a novel method of specifying rewriting on syntax-with-binding. We extend this treatment of rewriting with hierarchy of variables representing increasingly ‘meta-level’ variables, e.g. in hierarchical nominal term rewriting the meta-level unknowns (representing unknown terms) in a rewrite rule can be ‘folded into’ the syntax itself (and rewritten). To the extent that rewriting is a mathematical meta- framework for logic and computation, and nominal rewriting is a framework with native support for binders, hierarchical nominal term rewriting is a meta-to-the-omega level framework for logic and computation with binders.
Keywords: Nominal rewriting, meta-theory of logic and programming, nominal techniques.


Introduction
Fix a set of atoms (or object-level variable symbols) a, b, c,... ∈ A for the rest of this paper. The syntax of the λ-calculus is inductively generated by the grammar
s ::= a | ss | λa.s.

Consider the λ-term ‘λa.s’. Here s is a meta-level variable ranging over terms; s is not itself a λ-term.
Mathematical writing is full of this kind of language. Nominal terms model it closely. A relevant subset of nominal terms is inductively generated by the following grammar:
u ::= a | [a]u | f(u,... , u) | X

1 Thanks to Aad Mathijssen, Alberto Momigliano, and anonymous referees for help and suggestions. We acknowledge the support of EPSRC grant number EP/C013573/1.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.01.017

Here X is one of a countably infinite collection of unknowns symbols X, Y, Z,.. .; a represents object-level variable symbols; [a]u represents abstraction; f is a term- former, for example λ.
X here corresponds to s above. λ[a]X (the term-former λ syntactically acting on the abstraction of X with a) represents λa.s.
Instantiation of X is direct textual replacement and does not avoid capture by abstractors, so (λ[a]X)[a/X] is equal to λ[a]a (here [a/X] means ‘instantiate X to a’). This is exactly what happens when we say ‘take s to be a in λa.s’; we expect to obtain λa.a and not λa'.a, as a capture-avoiding notion of substitution delivers.
Nominal terms have a well-developed meta-theory [19,5,4]. A table presents the encoding of mathematical discourse into nominal terms:
Meta-variable φ or s '−→ Unknown X	Binding '−→ Abstraction But we used u as a meta-variable to range over nominal terms!
So we have not eliminated the meta-level, though we have internalised it. Does a language exist which is a fixed point of this process, in some sense? What if we iterate by allowing abstraction by unknowns [X]u, then internalise u as a ‘stronger’ unknown, and repeat this again, and again, and infinitely often? Taking the limit we obtain hierarchical nominal terms, in which infinitely many levels of meta-level discourse can be represented. What is the mathematics of this new language?
We give a theory of rewriting and a critical pairs result; there turn out to be unexpected differences with respect to nominal terms, which only have one level of atoms. We give example rewriting theories of substitution, scope and scope- extrusion, a λ-calculus, and a treatment of α-equivalence. This is arguably a com- prehensive range of applications with which we lay groundwork for more advanced investigations.

Hierarchical nominal terms
Fix a set of term-formers f.
For each number i ≥ 1 fix disjoint countably infinite sets of atoms ai, bi, ci,.. ..
Say that ai has level i.
The syntax of hierarchical nominal terms is inductively defined by
t, u, v ::= ai | X | [ai]t | f(t,... , t).
We may call ai an ‘atom of level i’. The intuition here is of a ‘hole’ which behaves like a variable towards weaker atoms, and like a constant symbol towards stronger atoms. Intuitively, weaker atoms have no access to stronger atoms; they must wait for those stronger atoms to ‘become’ terms; stronger atoms on the other hand have full access to weaker atoms, including to their names.
As for the rest of the syntax, [ai]t is an abstraction and f(t1,... , tn) is a term- former applied to some terms. Subscripts on t, u, and v are for identification only and have nothing to do with levels. We shall see examples later; for now it suffices

to mention that λ and ∀ are example term-formers, but also + and 2, and λ[a2]c1, λ[a2]b3, 2 + 2, and a1 + 2, are valid hierarchical nominal terms.
Unknowns X are variable symbols representing unknown terms. They behave like atoms of level ω. We still need unknowns because something has to represent unknown terms so that we can define rewrite rules and do rewriting!
For the rest of this paper we adhere to a convention that i, j, k vary over nonzero natural numbers and ai, bi, ci range permutatively over atoms of level i. That is, ai and bi represent two distinct atoms of the same level so ai /= bj holds necessarily because we called on atom ai and the other bj. If we write ai and ck and i = k then by our convention we assume that ai and ck are distinct. Typically it will be the case that k ≤ i < j, though not always; we shall always be clear about what we assume, when we assume it.
Call a pair of an atom and a term ai#t a freshness assertion. The intuition is ‘ai does not occur in t’. For example we expect a2#a1 to hold, because a1 is ‘far too weak and puny’ to ever have a hole as big as a2. We do not expect a1#a2 to hold, necessarily.
Inductively define a notion of entailment on freshness assertions as follows:



ai#ck
(#diff )

[ai#bj]
·
ai#t1 ... ai#tn
(k ≤ i)	(#f)
ai#f(t1,... , tn)

a #t



a #[a ]t
(#abs=)	·
i
(i < j)
(#abs≥) (i ≥ k)

i	i	ai#t
(#abs<)
ai#[bj]t
ai#[ck]t

(#diff ): This implements our intuition that a strong atom ‘looks like’ an un- known to weaker atoms but not conversely (since it may contain them, but not conversely). Between atoms of the same level, # encodes distinctness.
(#abs=), (#abs<), and (#abs≥): ai is abstracted in [ai]t. Intuitively, we can prove that ai is abstracted in [bj]t when we can prove it is abstracted in t, where we are allowed to assume that ai is abstracted in the hole in t called bj. In (#abs<) [ai#bj] denotes discharge in the natural deduction sense [2]; in sequent style (#abs<) would be
Φ, ai#bj ▶ ai#t

Φ ▶ ai#[bj]t

This is a surprising twist not present in normal nominal terms and their fresh- ness [19,5]. So we are able to derive ai#[bj]bj always even if j > i because of the extra freshness assumption. This issue does not arise when proving ai#[ck]u for k ≤ i, because then we can deduce ai#ck with (#diff ). In particular this issue cannot arise if there is only one level, as is the case for nominal terms. 2

2 This insight derives partly from work with Giulio Manzonetto during his visit to Universit´e Paris VII in

(#f): An atom is fresh for f(t1,... , tn) when it is fresh for all the t1 up to tn.
There is no rule for deriving ai#X; the only way to know this, is to assume it beforehand. In this sense X is like an atom of level ω.
Call ai#bj for j > i or ai#X primitive freshness assertions. Call a possibly infinite set Δ of freshness assertions a freshness context. Call Δ primitive when all the assertions it contains are primitive.
We say ai#t is entailed by Δ and write Δ ▶ ai#t, when ai#t can be derived from Δ using these rules. If Δ is empty write Δ ▶ ai#t just as ▶ ai#t. If Δ' is another freshness context write Δ ▶ Δ' when Δ ▶ ai#t for every ai#t ∈ Δ'.
We now develop the primitive notion of substitution for unknowns, and in the next section we treat unification and finally rewriting.
A substitution σ is a map from unknowns to hierarchical nominal terms. Write [X:=t] for the substitution mapping X to t and Y to Y . We extend the action of substitutions to all hierarchical nominal terms by
aiσ = ai	Xσ = σ(X)	([ai]t)σ = [ai](tσ)	f(t1,... , tn)σ = f(t1σ,... , tnσ).

Extend the substitution action point-wise to things mentioning terms, such as sets of terms and freshness assertions, and sets thereof. For example, if Δ is a freshness context then Δσ = {ai#(tσ) | ai#t ∈ Δ}.
The rules above are highly syntax-directed and have a computational content by which we can calculate for each ai#t a minimal (in a suitable sense) set of assumptions necessary to entail it:

bj#ai, Δ =⇒ Δ	(j > i)	ai#bi, Δ =⇒ Δ
ai#f(t1,... , tn), Δ =⇒ ai#t1,... , ai#tn, Δ	ai#[ai]t, Δ =⇒ Δ
ai#t, Δ =⇒ Δ' ∪ S
(i<j, S⊆{ai#bj})	ai#[ck]t, Δ =⇒ ai#t, Δ	(k≤i)
a #[b ]t, Δ =⇒ Δ'
i	j

Here we omit singleton set brackets, e.g. writing ai#bj for {ai#bj}. On the left of the arrow =⇒ comma indicates disjoint set union. On the right of the arrow comma indicates possibly non-disjoint set union.
The following results are easy to prove:
Lemma 2.1 • If Δ is ﬁnite and Δ =⇒ Δ' then Δ' is ﬁnite.
• =⇒ is terminating as a rewrite relation on ﬁnite freshness contexts.
• =⇒ is confluent on possibly inﬁnite freshness contexts.
Proof. The first part is easy.

2004, while I was supported by LIX and the E´cole Polytechnique.

For the second part assign a numerical measure |t| to terms by: |ai| = 1,
f(t1,... , tn)= Σ1≤i≤n|ti| + 1, |[ai]t| = |t| + 1. Extend the measure to Δ by taking
|Δ| to be a function on numbers n > 0 given by: |Δ|(n) is the number of freshness assertions ai#t in Δ such that |t| = n. For a suitable ordering on such functions (essentially a lexicographic ordering) it is very easy to show that =⇒ makes the measure strictly decrease.
For the third part, we must show that if Δ =⇒ Δ1 and Δ =⇒ Δ2, then there is some Δ' such that Δ1 =⇒ Δ' and Δ2 =⇒ Δ'. We can prove this by considering all possible cases for both reductions; this is long but routine.	 
Write ⟨Δ⟩nf for the unique =⇒ normal form of Δ. It is not hard to check that ⟨Δ⟩nf is of the form Δ' ∪ Δ'' where Δ' is a primitive freshness context and Δ'' contains only problems of the form ai#ai. If Δ'' is empty call Δ consistent, otherwise call Δ inconsistent. Intuitively, Δ is ‘satisfiable’ if and only if it is consistent. Obviously, Δ is consistent if and only if ⟨Δ⟩nf is consistent.
Lemma 2.2 Suppose that Δ is a primitive freshness context and suppose that
{ai#t} is consistent. Then Δ ▶ ai#t if and only if Δ ▶ ⟨ai#t⟩nf .
Proof. By an easy induction on the derivation of Δ ▶ ai#t.	 
Lemma 2.3 If Δ and Δσ are consistent and Δ ▶ ai#t then ⟨Δσ⟩nf ▶ ai#(tσ).
Proof. By induction on the derivation of Δ ▶ ai#t. We consider two cases:
Suppose our derivation of Δ ▶ ai#[bj]u concludes with (#abs<). Then we have a derivation of Δ, ai#bj ▶ ai#u. Note that ai#(bjσ) equals ai#bj. By inductive hypothesis ⟨Δσ⟩nf , ai#bj ▶ ai#uσ is derivable. The result follows.
Suppose Δ ▶ ai#X holds because ai#X ∈ Δ. By Lemma 2.2 we can deduce that
⟨ai#σ(X)⟩nf ▶ ai#σ(X) and by some easy calculations the result follows.

Unification
An equality assertion is a pair of terms t = u. We say that ‘t = u holds’ when t and u are syntactically identical, we may abbreviate this just to ‘t = u’, and we may shorten ‘t = u does not hold’ to t /= u.
A unification problem is a set of freshness or equality assertions Φ. We define a noninstantiating reduction relation on these unification problems as follows:
ai#t =⇒ ⟨ai#t⟩nf	ai = ai, Φ =⇒ Φ	X = X, Φ =⇒ Φ [ai]t = [ai]u, Φ =⇒ t = u, Φ
f(t1,... , tn)= f(u1,... , un), Φ =⇒ t1 = u1,... , tn = un, Φ
Here we omit singleton set brackets, e.g. writing t = u for {t = u}. On the left of the arrow =⇒, comma indicates disjoint set union. On the right of the arrow comma indicates possibly non-disjoint set union.

Lemma 3.1 The noninstantiating reductions on uniﬁcation problems are terminat- ing and confluent.
Recall that [X:=t] is the substitution mapping X to t. We may extend the reduction relation with instantiating rules as follows:

X:=u	X:=t
X = u, Φ =⇒ Φ[X:=u]	t = X, Φ =⇒ Φ[X:=t]

Here we extend the substitution action point-wise to the terms in the freshness or equality assertions in Φ.
Call the following equality assertions reduced:
ai = bj.
X = t and X occurs in t.
f(t1,... , tm)= g(u1,... , un) (where f and g are different term-formers).
ai = g(u1,... , un), or ai = [bj]u, or ai = [ai]u, or f(t1,... , tn) = [bj]u, or sym- metric versions such as [ai]t = ai.
We may call reduced equality assertions inconsistent.
A solution to a unification problem Φ is a pair (Γ, σ) of a consistent hierarchical nominal freshness context Γ and a substitution σ such that
For every t = u ∈ Φ it is the case that tσ = uσ.
For every ai#t ∈ Φ it is the case that Γ ▶ ai#tσ.
For every X it is the case that X does not occur in Xσ (or equivalently, Xσσ =
Xσ).
Lemma 3.2 If Φ =⇒ Φ' then (Γ, σ) solves Φ if and only if (Γ, σ) solves Φ'.

X:=t
Lemma 3.3 If Φ =⇒ Φ
then (Γ, σ) solves Φ if and only if (Γ, σ) solves Φ'.

Define a partial ordering on solutions to a hierarchical nominal unification prob- lem by: (Γ', σ') < (Γ, σ) when for some σ'' it is the case that Γ' ▶ Γσ'' and Xσ' = Xσσ'' for all X.
Say a solution to a problem is principal when it is a least element in the instantiation ordering amongst solutions to the problem.
Theorem 3.4 The non-instantiating and instantiating rules are terminating. Write
⟨Φ⟩nf for some arbitrary but ﬁxed choice of normal form. Then ⟨Φ⟩nf is a least element in the set of solutions to Φ, and ⟨Φ⟩nf is principal.

Proof. By a standard proof-method similar to that used to prove Lemma 36 in [5] and using the previous two lemmas; the hierarchy causes no difficulties since we are only acting on unknowns.	 

So unification of hierarchical nominal terms is decidable and has principal solutions.

Hierarchical nominal rewrite rules
To ‘do’ rewriting we need to be able to address some position within a term (at which to do the rewrite!).
Say a term has a position when it mentions a distinguished unknown, we usually write it -, precisely once (which identifies the position in the term at which that unknown occurs). Let L, C, P vary over terms with a position. Write C[s] for C[-'→s] and write [-] when the term is its (unique) unknown. Since C is only of interest inasmuch as - may be substituted for a term, we tend to silently assume
- is fresh, and we may say ‘C is a position’ when we mean ‘C is a term with a distinguished position’.
For example, [a1](a1, -) is position and (-, -) is not.
We can now get down to defining rewriting and proving some of its properties.
A hierarchical nominal rewrite rule is a triple

∇ ▶ l −→ r

where ∇ is a primitive freshness context (primitive freshness contexts are necessarily consistent) and l and r are terms, such that r and ∇ mention only unknowns in l.
If (R) = ∇ ▶ l −→ r and Δ ▶ t is a hierarchical nominal term-in-context, write
(R)
Δ ▶ t −→ u and say ‘Δ ▶ t rewrites with (R) to u’ when
There is a position C and substitution σ such that
Δ ▶ ∇σ and
C[lσ]= t, and C[rσ]= u.
Write −→∗ for the reflexive transitive closure of −→. So Δ ▶ t −→∗ u holds when t = u or when there is some sequence of −→-reductions from t to u. If Δ is irrelevant or known we may write Δ ▶ t −→∗ u as just t −→∗ u.
Call a possibly infinite set of hierarchical nominal rewrite rules a hierarchical nominal (term) rewrite system.
Call a hierarchical nominal rewrite system confluent when if Δ ▶ t −→∗ u and Δ ▶ t −→∗ u', then v exists such that Δ ▶ u −→∗ v and Δ ▶ u' −→∗ v.
Confluence is an important property because it ensures uniqueness of normal forms, a form of determinism. Local confluence is a weaker property, it is defined as ‘joinability of peaks’. More precisely:
Call a pair of rewrites of the form Δ ▶ t −→ u1 and Δ ▶ t −→ u2 a peak. Call a hierarchical nominal rewrite system locally confluent when if Δ ▶ t −→ u1 and Δ ▶ t −→ u2, then a v exists such that Δ ▶ u1 −→∗ v and Δ ▶ u2 −→∗ v. We may call such a peak joinable.
Suppose:
Ri = ∇i ▶ li −→ ri for i = 1, 2 are two rules mentioning disjoint unknowns,

l1 = L[l' ] such that ∇1, ∇2, l'
= l2 has a principal solution (Γ, θ), so that

1	1
l' θ = l2θ and Γ ▶ ∇1θ, ∇2θ.

Then call the pair of terms-in-context


Γ ▶ (r1θ, Lθ[r2θ])
a critical pair. If L = [-] and R1, R2 are copies of the same rule, or if l'


is an

unknown, then we call the critical pair trivial. 3
Call a rewrite rule R = ∇ ▶ l −→ r uniform when if Δ ▶ t
Δ, ⟨ai#t⟩nf ▶ ai#u for any ai such that ⟨ai#t⟩nf is consistent.
Checking uniformity looks hard. In fact it is not:

R
−→ u then

Lemma 4.1 R = ∇ ▶ l −→ r is uniform if and only if ∇, ⟨ai#l⟩nf ▶ ai#r for all
ai occurring in the syntax of R, and for one atom a which does not.
Proof. See [5].	 
Uniformity ensures freshness properties are not destroyed by rewriting:
RLemma 4.2 If R is uniform and Δ ▶ t	u and Δ ▶ ai#t, then Δ ▶ ai#u.
Proof. Suppose Δ ▶ ai#t. By uniformity Δ, ⟨ai#t⟩nf ▶ ai#u. By elementary properties of natural deduction style proofs, Δ ▶ ai#u.	 
Theorem 4.3 In a uniform rewrite system, peaks which are instances of trivial critical pairs are joinable.
Proof. Suppose two rules Ri = ∇i ▶ li → ri for i = 1, 2 have a critical pair
Γ ▶ (r1θ, Lθ[r2θ])
Then l1 = L[l' ], and (Γ, θ) is such that l' θ = l2θ, and Γ ▶ ∇1θ, ∇2θ. Recall also
1	1
that we call the critical pair trivial when L = [-] and R1, R2 are copies of the same

rule, or l'
is a unknown.

If R1 and R2 are identical, then their rewrites are identical. If R1 and R2 differ

and l'
is a unknown, then the only way we might not be able to apply R1 in Lθ[r2θ]

or its instances, is if some freshness condition on l'
in ∇1 is unsatisfiable after R2,

which was satisfiable before R2. For uniform rules Lemma 4.2 guarantees that this cannot happen.	 

Rewrites for substitution
Our idea when designing hierarchical nominal rewriting is that it should be able to represent meta-levels and instantiation. We used atoms to represent variable symbols. Our first task is therefore to use the framework of rewriting to give some framework by which atoms may be instantiated to terms.

3 We assume that unknowns in rules may be renamed. This is standard both in first-order and nominal rewriting [5].

Introduce a binary term-former sub and sugar sub([a]u, t) to u[a'→t]. Rewrites for sub are:
(suba)	ai[ai'→X] −→ X
(sub#)	ai#Z ▶ Z[ai'→X] −→ Z
(subaa)	Z[ai'→ai] −→ Z
(subf)	f(Z1,... , Zn)[ai'→X] −→ f(Z1[ai'→X],... , Zn[ai'→X])
(subabs>)	([ck]Z)[ai'→X] −→ [ck](Z[ai'→X])	(i > k)
(subabs≤)	bj#X ▶ ([bj]Z)[ai'→X] −→ [bj](Z[ai'→X])	(i ≤ j)
These are axiom-schemes for all i and j and every n, and for every term-former f (if we like). We could avoid having such schemes by enriching the syntax of rewrite rules, but it does not seem worth the trouble here. We always assume at least an axiom (subsub).
Even without term-formers aside from sub, these rules have very interesting structure. The following rewrites are derivable, where here j > i and k ≤ i:
Z[ai'→X][bj'→Y ] −→∗ Z[bj'→Y ][ai'→X[bj '→Y ]]
ai#Y ▶ Z[ai'→X][ck'→Y ] −→∗ Z[ck'→Y ][ai'→X[ck'→Y ]]	(1) Rewrites for the first case are:

Z[ai'→X][bj '→Y ]
(subf)
−→∗ sub(([ai]Z)[bj'→Y ],X[bj '→Y ])

(subabs>)
−→∗	sub([ai](Z[bj'→Y ]),X[bj '→Y ]) = Z[bj'→Y ][ai'→X[bj'→Y ]].
The second case is similar, but we have to use (subabs≤) and to do that we must prove ai#Y .
Thus strong substitution distributes over weak substitution without avoiding capture whereas weak substitution distributes over strong substitution but only subject to a capture-avoidance condition bj#X. Thus a2[a1'→2][a2'→a1] −→∗ 2 arguably models exactly what we mean when we say ‘let t be a in t with a replaced by 2’ (where 2 is some term-former; any term would do as well).
Since rewriting is more general than a particular calculus or logic, this example is meant to exhibit capture-avoiding substitution, and non-capture-avoiding instan- tiation, as two sides of a single unified theory of sub.
Recall that uniform rewrite rules satisfy Theorem 4.3.
Theorem 5.1 The rewrite rules for sub are all uniform. Nontrivial critical pairs may be joined. The rules above are locally confluent.
Proof. By Lemma 4.1 we need only check a finite number of properties such as
⟨ai#ai[ai'→X]⟩nf ▶ ai#X. They are all routine. It is detailed but routine to check the nontrivial critical pairs. The third part follows by standard reasoning using Theorem 4.3.	 

We believe that our rewrite system is confluent but proving this is nontrivial even in the two-level case. The problem is (1) above, which is non-directed and makes terms syntactically larger. These problems have been investigated and overcome (see [7] and see the brief discussion in Section 7) but investigating them here is outside the scope of this paper.

Scope extrusion of
Introduce a term-former . Sugar [ai]t to ai.t. Read this as ‘generate a fresh name ai in t’.
Our framework can express scope-extrusion rules consistent with this intuition, similar to the behaviour of the π-calculus restriction operator ν [13]. Assume the term-formers and rewrites of substitution above. Introduce rewrites:

The effect of ( sub) is handled by (subabs>) when j ≤ i, so the following rewrite is always valid:
bj#Y ▶	(([bj ]Z)[ai'→Y ]) −→	bj.(Z[ai'→Y ])
This beautifully implements that the abstracted atom really is private in the scope of . There is no rewrite
( ⊥)	bj#Z ▶ Z[ai'→  bj.Y ] −→	bj.(Z[ai'→Y ])
because substitution might copy bj.Y and each copy should have a private copy of the fresh atom. For example assume a term-former f and consider scope-extrusion rewrite rules
bj#Y ▶ f( bj.X, Y ) −→	bj.f(X, Y )	bj#X ▶ f(X,  bj.Y ) −→	bj.f(X, Y ).
Then we may reduce


▶ (f(ai, ai))[ai'→ bj.bj]
(subf),(suba)
−→∗	f( bj.bj,  bj.bj).

In the presence of ( ⊥) there is a second reduction path:


( ⊥)
▶ (f(ai, ai))[ai'→  bj.bj] −→	bj.(f(ai, ai)[ai'→bj])
(subf),(suba)
−→∗	bj.(bj, bj)

This is not desired behaviour so we rule out ( ⊥).
Theorem 6.1 ( #) and ( sub) are uniform (and so we can apply tools such as Theorem 4.3 to rewrite systems making use of	).

Proof. We must show that:
bj#Z, ⟨ai# bj.Z⟩nf ▶ ai#Z	bj#Z, ⟨bj# bj.Z⟩nf ▶ bj#Z bj#Z, ⟨ck#[ai] bj.Z⟩nf ▶ ck# bj.[ai]Z
bj#Z, ⟨ai#[ai] bj.Z⟩nf ▶ ai# bj.[ai]Z bj#Z, ⟨bj#[ai] bj.Z⟩nf ▶ bj# bj.[ai]Z.
We consider a few cases, they are very easy:
⟨ai# bj.Z⟩nf = {ai#Z}. The result follows.
bj#Z ∈ {bj#Z}. The result follows.
⟨cj#[ai] bj.Z⟩nf = cj#Z. The result follows using the derivation rules for fresh- ness assertions.
▶ ai# bj.[ai]Z and ▶ bj# bj.[ai]Z are easy to derive using the derivation rules for freshness assertions. The result follows.

A hierarchical λ-calculus
Assume term-formers sub,  , λ and app. Sugar app(t, u) to tu. Sugar λ([ai]t) to
λai.t. Rewrites of a hierarchical λ-calculus are given by rewrites:
(β)	(λai.Z)X −→ Z[ai'→X]	(σ#)	ai#Z ▶ Z[ai'→X] −→ Z
(σa)	ai[ai'→X] −→ X
(σp)	(aiZ1 ... Zn)[bj'→Y ] −→ (ai[bj'→Y ]) ... (Zn[bj'→Y ])
(σp')	(aiZ1 ... Zn)[ai'→X] −→ (ai[ai'→X]) ... (Zn[ai'→X])
(σσ)	Z[ai'→X][bj '→Y ] −→ Z[bj'→Y ][ai'→X[bj'→Y ]]	(j>i)
(σλ)	ai#X ▶ (λai.Z)[ck'→X] −→ λai.(Z[ck'→X])	(k≤i)
(σλ')	(λai.Z)[bj'→Y ] −→ λai.(Z[bj'→Y ])	(j>i)
(σtr)		Z[ai'→ai] −→ Z	( p)	bj#Y ▶ ( bj.X)Y −→	bj.(XY ) ( λ)	λai. bj.Z −→	bj.λai.Z		( #)	bj#Z ▶	bj.Z −→ Z
( σ)	bj#X ▶ ( bj.Z)[ai'→X] −→	bj.(Z[ai'→X])
This system is discussed in detail elsewhere [6], though we since simplified the presentation. Note the weaker treatment of substitution compared to Section 5,
e.g. (σp) and (σp') and a closely connected lack of a rule (σσ') corresponding to
(1). This is what is needed to avoid (1) while retaining confluence.
Theorem 7.1 Rewrites in the system above are confluent.
Proof. For local confluence it suffices by Theorem 4.3 along with some standard further calculations, to check that nontrivial critical pairs may be joined. This is detailed work but essentially routine. For confluence we use Theorem 7.2 below taking R1 to be the system with just (β), and R2 to be the system with all the other rules.	 

Call two hierarchical nominal term rewrite systems R1 and R2 when there is no nontrivial critical pair between a pair of rules one in R1 and the other in R2.
Theorem 7.2 If R1 and R2 are left-linear, confluent, and orthogonal, then their union is confluent.
The proof is identical to one the literature [18, Thm 5.10.5].
Call a term which does not mention unknowns and which mentions only atoms of level 1 a value. We briefly indicate how to translate the untyped λ-calculus to values: a translates to a1 (assume some arbitrary injection of untyped λ-calculus variable symbols to atoms of level 1), tu translates to t'u' if t and u translate to t' and u' respectively, and λa.t translates to ai.([ai]t') if t translates to t'. This translation is correct in a natural sense and preserves strong normalisation.

α-equivalence
We can use substitution to recover α-equivalence:
(α)	bi#X ▶ ([ai]X) −→ [bi](X[ai'→bi])
(α')	bi#Z ▶ Z[ai'→bi][bi'→Y ] −→ Z[ai'→Y ]

Lemma 8.1 In the presence of (α) and (α') and the rules for sub except for
(subaa), the rewrite Z[ai'→ai] −→ Z is valid.
Proof. We use (α) (recall that Z[ai'→ai]= sub([ai]Z, ai)), (α'), and (sub#). 
(α),(suba)
The rewrite [ai]ai	−→∗	[bi]bi is valid.
This is all very well for terms not mentioning unknowns or atoms that are too strong, but if we have [ai]X or [ai]bj for j > i, and want to rename ai to some bi such that bi#X or bi#bj. Where do we find this guaranteed-fresh bi?
Say Δ has sufficient freshnesses when for every finite set S of atoms and/or unknowns, and for every level i, there is an atom ai /∈ S such that ai#bj ∈ Δ for every bj ∈ S, and ai#X ∈ Δ for every X in Δ. It is not hard to prove the existence of contexts with sufficient freshnesses by an inductive construction. If Δ has sufficient freshnesses then it is infinite.
This achieves the effect of dynamic creation of names, since any syntax we rewrite is finite and we obtain the desired effect of ‘always having a fresh atom’, which we can always rename within its scope using α-equivalence.
In short, if the freshness context is sufficiently rich then (some fragment) of α-equivalence becomes accessible. The downside is of course that extra rules may mean extra critical pairs if we want to use Theorem 4.3.
So assuming sufficient freshnesses, how do these axioms behave? Write (ai bi)ci · t for the term ci.t[ai'→ci][bi'→ai][ci'→bi].
Lemma 8.2 Suppose we are rewriting in a context with sufficient freshnesses and

suppose ci#X and di#X. Then the following rewrites are valid:
(ai bi)ci · X −→∗ (ai bi)d · X	(ai bi)ci · X −→∗ (bi ai)ci · X
(ai bi)ci · (ai bi)ci · X −→∗ X.
Proof. We just sketch the first reduction, the others are no harder:

(α)
(ai bi)ci · X −→ di.(X[ai'→ci][bi'→ai][ci'→ai][ci'→di])
(α)
−→  di.(X[ai'→ci][bi'→ai][ci'→di][di'→ai][ci'→di])
−→∗ di.(X[ai'→di][bi'→ai][di'→ai])


In view of the lemma above we may write just (ai bi) · t for (ai bi)ci · t. It is now not hard to prove that:
(ai bi) · (ci di) · X −→∗ (ci di) · (ai bi) · X
(ai bi) · (ai di) · X −→∗ (ai di) · (di bi) · X	(ai ai) · X −→∗ X.
This suffices to verify that we have implemented a permutation action in terms of atom-for-atom substitution. Furthermore:
(ai bi) · f(t1,... , tn) −→∗ f((ai bi) · t1,... , (ai bi) · tn) (ai bi) · ai −→∗ bi	ai#X, bi#X ▶ (ai bi) · X −→∗ X
(ai bi) · [ai]X −→∗ [bi](ai bi) · X	(ai bi) · [bi]X −→∗ [ai](ai bi) · X
(ai bi) · [ci]X −→∗ [ci](ai bi) · X.
These are characteristic properties of the permutation action on nominal terms. More research on this is needed; in particular a detailed examination of how these axioms make atoms of different levels interact, might give useful information about an appropriate built-in permutation action on hierarchical nominal terms.

Concluding comments and future work
Many systems formalise aspects of meta-level logic and programming. Examples are first- and higher-order logic [2,20], rewriting [18,12], logical frameworks [1,10,15], and many more including of course nominal-based systems [19,5,4,17,8]. This work differs from others in several ways:
We investigated a hierarchy of levels modelling increasingly ‘meta’ treatments of an object-level theory (in the framework of rewriting). Our hierarchy of atoms can accurately capture our intuitions about how meta-level variables should be instantiated. For example the rewrite a2[a1'→2][a2'→a1] −→∗ 2 discussed in Section 5 is supposed to model what we mean when we say ‘let t be a in t with a replaced by 2’.

As with all nominal-based systems we implement abstraction and freshness as an explicit and logical property of terms (e.g. recall the logical derivation rules for freshness from Section 2). But there are twists; the hierarchy demanded changes in derivation rules for freshness assertions, notably (#abs<). We also omit α- equivalence as primitive, which simplified the framework at the cost of having a weaker theory of equality of terms.
Recall that we have given rewrites for substitution, π-calculus style restric- tion [13], α-equivalence, and a computationally powerful λ-calculus inspired from previous work [6] for which we exploited the meta-level results about hierarchi- cal nominal term rewrite systems presented here to indicate a particularly concise method of proof for confluence. We have sketched some indication of how the infinite hierarchy can give ‘meta-levels within the rewrite system’.
We have heard the following reasoning: If the intuition of u[a1'→t] is to replace any a1-shaped holes in u with t in a capture-avoiding manner, then surely it should be forbidden that t mention any atom stronger than 1, since then we are trying to replace a ‘big hole’ with a ‘smaller hole’ ? This is not so. Informally we may write ‘re- place x by t in λy.x where y is not free in t; we obtain λy.t’. Here t is a meta-variable. We may later say ‘now actually t is 2; we obtain λy.2’. This corresponds to a series of rewrites on b1#X2 ▶ (λ[b1]a1)[a1'→X2][X2'→2]. Now ▶ (λ[b1]a1)[a1'→X2][X2'→2] is a legal term. However the side-conditions on (subabs≤) prevent us from dis- tributing [a1'→X2] under the abstraction because we cannot prove b1#X2. If we wish we may add fresh atoms to the context and use α-equivalence to rename b1.
We have also heard the following reasoning: Hierarchical nominal terms are sup- posed to internalise meta-level variables, so why do they include explicit unknowns X, Y , Z as well as atoms ai? This is a matter of taste and presentation only. For our notion of rewriting to work, we do need access to atoms stronger than any other atoms in a rule to play the roˆle of meta-variables. The easiest way to guarantee this is to add atoms of level ω, that is, our unknowns. We could alternatively leave atoms only with finite levels, let nominal rewriting automatically identify which are the strongest atoms in a rewrite rule, and phrase our rewrite rules accordingly. For example (sub#) becomes ai#bi+1 ▶ bi+1[ai'→bi+1] → bi+1. To us it seemed a cleaner presentation to add unknowns.
But note: the meta-level will always be with us no matter how strong or how weak our object-level. The issue is how much of our meta-level intuitions we inter- nalise in a formal system, and how we do that. Hierarchical nominal rewriting does not and cannot ‘make the meta-level go away’. We can only model it and use that model to learn.
An existing formalisation of the meta-level with an infinite hierarchy is the Russelian type hierarchy [16]. Since its inception a century ago this has sired higher- order logic [20], the polymorphic λ-calculus [9], dependent type systems [14], and higher-order rewriting [12] to name a few. We can see these systems as having a ‘hierarchy of meta-levels’ in the sense that objects of functional type ‘talk about’ the types they are functions on. Yet this forces a particular notion of meta-level because substitution is capture-avoiding, a syntactic identity and freshness is not directly

expressed. Some work discusses a λ-calculus with explicit substitution [3,11] but this is designed to calculate computational cost; the substitution is is still capture- avoiding, meta-variables and freshness are not explicit, and the underlying semantics remains unchanged. Our hierarchy of atoms with freshness contexts gives a us a different slant; it remains to relate nominal techniques to higher-order techniques in general, and in the specific case that we have a hierarchy of atoms.
Future work includes a more profound analysis of the NEW calculus of contexts, a λ-calculus based on the same ideas [6], restoring permutations as built-in, and fur- ther analyses of substitution and α-equivalence. We see logics based on hierarchical nominal terms which can internalise aspects of the meta-level using the hierarchy to avoid inconsistencies. We also see logics exploring the properties of freshness, of which we have caught interesting glimpses in our derivation system for #. Seman- tics are a very important tool and should be thoroughly investigated. We anticipate many interesting insights into the mathematical content of naming unknowns and the meta-level.

References
A. Avron, F. A. Honsell, I. A. Mason, R. Pollack. Using typed lambda calculus to implement formal systems on a machine. Journal of Automated Reasoning, 9(3), 1992.
J. Barwise. An introduction to first-order logic. In J. Barwise, ed., Handbook of Mathematical Logic. North Holland, 1977.
R. Bloo. Preservation of Termination for Explicit Substitution. PhD thesis, Eindhoven University of Technology, Eindhoven, 1997.
J. Cheney, C. Urban. Alpha-prolog: A logic programming language with names, binding and alpha- equivalence. In B. Demoen, V. Lifschitz, eds., Proceedings of the 20th International Conference on Logic Programming (ICLP 2004), number 3132 in LNCS. Springer-Verlag, 2004.
M. Fern´andez, M. J. Gabbay. Nominal rewriting. Information and Computation, 2005. Accepted for publication.
M. J. Gabbay. A new calculus of contexts. In Proc. 7th Int. ACM SIGPLAN Conf. on Principles and Practice of Declarative Programming (PPDP’2005). ACM, 2005.
M. J. Gabbay, A. Mathijssen. Capture-avoiding substitution as a nominal algebra. In ICTAC’2006, 2006.
M. J. Gabbay, A. Mathijssen. Nominal algebra. Submitted STACS’07, 2006.
J. R. Hindley. Basic Simple Type Theory. Number 42 in Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 1997.
Huet, Kahn, Paulin-Mohring. The COQ tutorial. http://pauillac.inria.fr/coq/doc/tutorial.html. LogiCal Project.
P. Lescanne. From lambda-sigma to lambda-upsilon a journey through calculi of explicit substitutions. In POPL ’94: Proc. 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM Press, 1994.
R. Mayr, T. Nipkow. Higher-order rewrite systems and their confluence. Theoretical Computer Science, 192, 1998.
R. Milner, J. Parrow, D. Walker. A calculus of mobile processes, II. Information and Computation, 100(1), 1992.
B. Nordstrom, K. Petersson, J. M. Smith. Programming in Martin-Lof’s Type Theory, vol. 7 of International Series of Monographs on Computer Science. Clarendon Press, Oxford, 1990. Also online at http://www.cs.chalmers.se/Cs/Research/Logic/book/.

L. Paulson. The Isabelle reference manual. Cambridge University Computer Laboratory, 2001.
B. Russell, A. Whitehead. Principia Mathematica. Cambidge University Press, 1910, 1912, 1913. 3 vols.
M. Shinwell, A. Pitts. Fresh objective caml user manual. Technical Report UCAM-CL-TR-621, University of Cambridge, 2005.
Terese. Term Rewriting Systems. Number 55 in Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 2003.
C. Urban, A. M. Pitts, M. J. Gabbay. Nominal unification. Theoretical Computer Science, 323(1–3), 2004.
J. van Benthem. Higher-order logic. In D. Gabbay, F. Guenthner, eds., Handbook of Philosophical Logic, 2nd Edition, vol. 1. Kluwer, 2001.
