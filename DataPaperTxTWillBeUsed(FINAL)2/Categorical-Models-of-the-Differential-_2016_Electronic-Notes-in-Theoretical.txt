Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 325 (2016) 63–83
www.elsevier.com/locate/entcs
Categorical Models of the Differential
λ-Calculus Revisited
J.R.B. Cockett 1,2 J.D. Gallagher3
Department of Computer Science University of Calgary
Calgary, Canada

Abstract
The paper shows that the Scott-Koymans theorem for the untyped λ-calculus extends to the differential λ-calculus. The main result is that every model of the untyped differential λ-calculus may be viewed as a differential reflexive object in a Cartesian closed differential category. This extension of the Scott-Koymans theorem depends critically on unravelling the somewhat subtle issue of which idempotents can be split so that differential structure lifts to the idempotent splitting.
The paper uses (total) Turing categories with “canonical codes” as the basic categorical semantics for the λ-calculus. It shows how the main result may be developed in a modular fashion by first adding left- additive structure to a Turing category, and then – on top of that – differential structure. For both levels of structure it is necessary to identify how “canonical codes” behave with respect to the added structure and, furthermore, how “universal objects” behave. The latter is closely tied to the question – which is the crux of the paper – of which idempotents can be split in these more structured settings.
Keywords: Scott-Koymans, Differential Lambda Calculus, Categorical Models


Introduction
In [12], Ehrhard and Regnier introduced the differential λ-calculus to give a syntactic counterpart for the models of linear logic which Ehrhard had introduced in [10,11]. In these models proofs were interpreted as differentiable maps with the linear maps, in the sense of linear logic, becoming rather elegantly the maps which were linear in the differential sense. The differential λ-calculus, introduced a new aspect because, as described in [12], it was an untyped system with a confluent rewriting system and, thus provided a model of computability. Furthermore, it was immediately apparent that this calculus was very closely related to the resource λ-calculus [6,5,7]. This

1 partially supported by NSERC
2 Email: robin@cpsc.ucalgary.ca
3 Email: jdgallag@ucalgary.ca

http://dx.doi.org/10.1016/j.entcs.2016.09.032 1571-0661/© 2016 Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

confluence of developments, thus, initiated the study of models of computability in which the computable functions admit a differentiation.
The categorical semantics for these settings was developed in series of papers. Initially the tensorial (or linear logic) side of the story was developed in [2]: this closely followed the path of Ehrhard’s more model driven development. Tensor differential categories (also written ⊗-differential categories) came equipped with a comonad (an exponential modality) 4 and it was understood that the differential λ-calculus would then be interpreted in the coKlesili category for this comonad.
Of course, this rather indirect approach did not facilitate the exploration of these coKleisli categories which rapidly become the main focus of attention. The next step – motivated not least by desire to understand the axiomatic behaviour of dif- ferentiation in classical calculus – was, therefore, to develop a direct axiomatization for these categories. Toward this end Cartesian differential categories (also written
×-differential categories) were introduced [3]. Importantly, these were more general than simply being an axiomatization of the coKleisli category for a ⊗-differential category. While it is certainly the case that coKleisli categories of ⊗-differential categories are ×-differential categories 5 , the converse is certainly not true.
The next step in this development involved ×-differential categories which were – in the appropriate sense – Cartesian closed. In [8] a sound and complete inter- pretation of the simply typed differential λ-calculus into Cartesian closed differ- ential categories was provided. Furthermore, the connection between the resource λ-calculus and the differential λ-calculus was then implicitly determined by tying both to the same categorical semantics. To complete the story it thus only remained to provide a precise account of the semantics of the untyped differential λ-calculus. At this stage, it was abundantly clear that the interpretation of the untyped dif- ferential calculus should be into some sort of reflexive object in a Cartesian closed differential category and, thus, there should be an analogue of the Scott-Koymans 6 theorem [14,18] which says that all model arise from such a situation.
In [17], Manzonetto initiated the investigation of models of the untyped differ- ential λ-calculus. He showed that linear reflexive objects in a Cartesian differential category soundly interpret the untyped differential λ-calculus. Furthermore, he gave a completeness theorem, for the differential λ-calculus, however, with two additional equations:
λx.(Ds · t)x = Ds · t	and	a + a = a.
Thus, he did not manage to provide a general completeness theorem which paralleled the Scott-Koymans result. In this paper we revisit this problem and we show that

4 In fact, ⊗-differential categories come with different strengths of axiomatizations. In [2] an effort was made to obtain the weakest possible axiomatization. Of note, however, is the stronger notion which was introduced by Marcello Fiore in [13].
5 A precise characterization of when a Cartesian differential category is the coKleisli category of a ⊗- differential category is described in [4].
6 At the time of the development of this theorem, Koymans was a PhD. student, Dana Scott was widely publicizing his results, and also Jim Lambek with Phil Scott were in the process of writing their book, [15], and, indeed, were circulating chapters for comment. Their book, in particular, has a section on C-monoids which provide the semantics for the untyped λ-calculus with both η- and β-equality. In addition, they intro- duced the notion of a “weak” C-monoid in the exercises and noted that these provide the semantics of the λ-calculus with just β-equality. The notion of “weak” there is exactly our notion of having canonical codes. Note that, in this paper, we use “weak” to mean that the choice does not necessarily admit substitution.

by subtly changing the requirements on the idempotents which one splits one can indeed obtain a complete analogue of the Scott-Koymans result. In Manzonetto’s work it was assumed – very reasonably – that the idempotents one should split had to be linear. Unfortunately, this meant that, as Curry’s pairing combinator, (a, b) '→ λp.p a b, is not linear one is forced to look for an alternative idempotent which can encode pairing. Manzonetto actually found such a combinator: it was the more complicated (a, b) '→ λy.(a+Dy·b). However, in order to make this combinator behave correctly, he had to restrict to the case where addition was idempotent.
To access the more general situation, which is the subject of this paper, it is necessary to understand more fully the behaviour of idempotents in a Cartesian differential category. To achieve this one not only has to understand their behaviour with respect to differentiation but also with respect to the left-additive structure. We shall, therefore, redevelop this program by describing the categorical semantics not only of models of the differential λ-calculus but also of models of the “additive” λ-calculus. This is because moving directly from a Cartesian closed differential setting to a model of the differential λ-calculus, without this intermediate step, tends to obscure the subtle behaviour required of the idempotents which must be split. In fact, in this paper we shall start the development even further back: we actually redevelop the Scott-Koymans theorem itself from the more modern and unifying perspective of Turing categories [9]. One justification for this is that, in the theory of Turing categories, idempotents and idempotent completions play a very central role. This predisposes one to take the behaviour of idempotents very seriously as one begins to add structure.
Because our aim is to model the λ-calculus, we shall exclusively focus on Turing categories all of whose maps are total: these were introduced by Longo and Moggi
[16] – albeit under a different name – and their realizability theory was developed by Birkedal [1]. Such a Turing category is a weakly Cartesian closed category with an object, T , called a Turing object which is universal. An object in a category is universal in case all objects are a retracts of it. In order to model the untyped λ-calculus, with β-equality, we shall employ the notion of a Turing category with canonical codes. This allows us to interpret the term calculus of the untyped λ- calculus very directly into these categorial models. In particular, this step does not involve consideration of idempotents. This approach, in fact, closely parallels the approach Koymans followed in [14], and allows a convenient separation of concerns which is useful later. To recapture the Scott-Koymans theorem one observes that splitting idempotents yields a Cartesian closed category in which the Turing object is still universal: this immediately makes that the Turing object a reflexive object. This is the approach that we then follow, in a modular fashion, as we successively add structure. First we add left-additive structure and develop the categorical semantics of the untyped additive λ-calculus, and then, following the same pattern, arrive at the categorical semantics of the untyped differential λ-calculus. At each stage we must appropriately strengthen both the notion of being weakly cartesian closed (with canonical codes) and of being a universal object – where the notion of a universal object, as one adds structure, crucially depends on understanding which

idempotents can be split.
The payoff of this reconstruction is that it allows a general analogue for the Scott-Koymans theorem for untyped differential λ-models.
The λ-Calculus
The classical notion of a categorical model of the untyped λ-calculus is as a reflexive object in a cartesian closed category. This is an object U which has as a retract its object of endomorphisms, [U, U ] s U . 7 One way to approach the Scott-Koymans completeness result is to interpret the λ-calculus across this retraction: this is rather messy as one must repeatedly use the section and retraction to interpret terms. An alternative approach, which parallels the approach of Koymans, is to interpret the λ-calculus into a Turing category with canonical codes and then show that splitting the idempotents results in a Cartesian closed category in which the Turing object is still universal. This approach gives an elegant separation of the two concerns (interpretation and idempotent splitting) and, furthermore, allows the introduction of a more direct categorical counterpart to the untyped λ-calculus: namely Turing categories with canonical codes.
Syntax of the λ-calculus
The syntax of the λ-calculus may be described as “unityped” terms in context. The term formation rules consist of term formation rules for a Cartesian theory, see table 1, and the special terms for the “unityped” λ-calculus see Table 2.
In the term formation rules for a Cartesian theory we insist that the variables of a context are distinct. We shall only allow variables for atomic types and allow the formation of variable patterns corresponding to composite Cartesian products of objects. This allows a smooth transition to the categorical semantics as we can turn any sequent into a map, a sequent with one premise:
p : X ▶ t : T
by simply collecting the context, using the pattern rules, into one type. When substituting for a pattern one then has to match the term being substituted to the pattern: thus, for example, the substitution [(t, s)/(x, y)] becomes, equivalently, [t/x, s/y]. The type system ensures that term and pattern in a substitution have exactly the same form.
As usual we allow α-conversion of bound variables and β-equality λx.m ≡α λy.(m[y/x])   (λx.m)n ≡β m[n/x]
and generate the theory Λβ by forming the smallest congruence on terms that contains the above equations. There is an associated category of this theory, C(Λβ),

7 Here [U, U ] is the internal hom sometimes written UU or U ⇒ U . The notation [U, U ] Qs U means [U, U ] is a retract of U with s : [U, U ] −→ U the section and r : U −→ [U, U ] the retraction so sr = 1[U,U ].



Table 1
Term formation rules for a Cartesian theory

Table 2
Term formation rules for the λ-calculus

called the classifying category of Λβ:
Objects:	Words in U, ×, 1.
Arrows:	A map T −→ S corresponds to a sequent with one type on the left hand side
p : T ▶ m : S
under the term equivalence of Λβ.
Composition:	Composition is substituition:
p : X ▶ m : Y	pj : Y ▶ n : Z p : X ▶ n[m/pj]: Z
We note, rather modestly, that this is a Cartesian category:
Proposition 2.1 C(Λβ) is a Cartesian category.

The rest of this section develops the properties of this category.

Total Turing categories with canonical codes
A (total) Turing category X is a Cartesian category with:
BC
[T.1] An object T and for each pair of objects B, C a map T × B −−−−→ C;
f	cf
[T.2] For each map A × B −−→ C a map A −−→ C such that
T × B•BC  / C¸,
cf ×1
f
A × B
A Turing category has canonical codes when there is a function

λ( )
X(A × B, C) −−−→ X(A, T )


such that

T¸,,,

T × B•BC  / C¸,

λ[(g×1)f )]

D
λ[f ] g	/A¸

λ[f ]×1
f
A × B

commute. This means that this function, λ[ ], for forming codes has a substitutional
property, namely that λ[(g × 1)f ] = gλ[f ] and that λ[f ] is indeed a code for f in the sense that (λ(f ) × 1)•BC = f .
Observe first that the property of having canonical codes can be simplified:
Lemma 2.2 A Turing category X has canonical codes if and only if there is a code λ[•BC] for each •BC : T ×B −→ C such that whenever (c1 ×1)•BC = f = (c2 ×1)•BC that is c1 and c2 are codes for f, then c1λ[•BC]= c2λ[•BC].
Proof. The proof follows from considering the following diagram





λ(f )×1
T ×,B,
λ(•)×1

T ×,B,
ci×1

A × B
/¸ C¸ ,



f



The following is an economical “recognition” theorem for Turing categories with canonical codes:

Lemma 2.3 To have a Turing category with canonical codes is to have a Cartesian
category with a universal object T and a “Turing” map T × T −−•→ T which has canonical codes for all maps maps T × T −→ T .
Proof. For the universality of the Turing object, in a Turing category, obtain the
π
section as a code for A×1 −−→ A. To extract a Turing structure from a universality
of T and a Turing map, derive a universal application for arbitrary objects by


1 × sB
rC

T × B −−−−−→ T × T −−→ T −−−→ C.
The canonical code for f is λ[f ] := sAλ[(rA × rB)fsC].	 
We use this to show:
Theorem 2.4 C(Λβ) is a Turing category with canonical codes.
Proof. The universal map is U × U −−•→ U ; (m, n) ▶ mn. By lemma 2.3, it suffices to show that • has canonical codes for terms U × U −→ U ; (x, y) ▶ t. Define λ[(x, y) ▶ t] := x ▶ λy.t. It is easy to see that this is a canonical code.
1 is a retract of U . To see that U × U is a retract of U use Curry’s pairing and projection combinators: the section is (a, b) ▶ λp.p a b, and for the retraction take a ▶ (a (λxy.x), a(λxy.y)).	 
From a logical perspective this theorem proves the completeness of the untyped λ-calculus with respect to models which are Turing categories with canonical codes. With some more work (some of which is developed below) one can exhibit this as part of an adjunction between λ-theories and Turing categories with canonical codes. As this is off the path of our development we shall leave it for a fuller exposition.

Interpreting the λ-calculus
We now show that Turing categories with canonical codes are sound models for the
X which
untyped λ-calculus by showing there is a a canonical functor J ) : C(Λβ) −→
carries the universal object onto the Turing object and application onto the Turing morphism • : T × T −→ T . At this stage we should make an important remark: a Turing category may have more than one possible Turing object and more than one Turing morphism as one only needs the existence of such structure to be a Turing category. Thus, in this development, we need to strengthen the notion of a Turing category to specify, as part of being a Turing category, the intended Turing structure. In particular, for a Turing category with canonical codes the function which supplies the canonical codes will be part of this structure.
With this understanding, let X be a Turing category with canonical codes, whose Turing object is T and universal map is T × T −−•→ T . We define the interpretation
X, as follows:
of the untyped λ-calculus, J ) : C(Λβ) −→
Objects: On objects define X  to be X[T/U ].
Maps: On arrows:

p : X ▶ () : 1 = !JX)
Jp : X ▶ (m, n): Y × Z) = ⟨Jp : X ▶ m : Y ), Jp : X ▶ n : Z)⟩

(p1, p2): X1 × X2 ▶ x : U  = πi pi : Xi ▶ x : U	where x ∈ pi
p : X ▶ mn : U = ⟨ p : X ▶ m : U , p : X ▶ n : U ⟩• 
p : X ▶ λz.m : U = λ[ (p, z): X × U ▶ m : U ] We then have:
Theorem 2.5 If X is a Turing category with canonical codes,
: C(Λ) −→ X
is a Cartesian functor which preserves the Turing object, the Turing map, and the canonical codes.
The proof is standard.

Reflexive objects
An important observation for Turing categories is that the idempotent splitting of a Turing category X, Split(X), is again a Turing category (see [9]), furthermore, the Turing object and the Turing morphism are preserved in this splitting. Our next objective is to show that splitting the idempotents of a Turing category which has canonical codes results not just in a Turing category with canonical codes but in a Cartesian closed Turing category. As the Turing object is still universal in the idempotent splitting, this, in particular, means that it is a reflexive object. This allows us to conclude that all models of the untyped λ-calculus arise from a reflexive object [T, T ] s T in a Cartesian closed Turing category, and this is how we interpret the Scott-Koymans theorem.
Theorem 2.6 When X is a Turing category with canonical codes then Split(X) is a cartesian closed Turing category.
The proof is that of Koymans [14].
Note that [1T , 1T ]= λ[•] is an idempotent which in Split(X) witnesses that the Turing object in the splitting is a reflexive object.

The additive λ-calculus
The previous section sets the broad outline for this and the next section. In these sections we will follow our program of adding structure step by step to the untyped λ-calculus. The first step in this program is to consider left-additive structure: it is required in order to discuss differential structure.
A left-additive category X is a category in which each homset X(A, B) is a 



Table 3
Term formation rules addition in the additive λ-calculus

commutative monoid, and where
f (g + h)= fg + fh	f 0= 0.

A map f in a left additive category is additive when (g + h)f = gf + hf and 0f = 0.
A Cartesian left additive category is a left additive category with finite products such that
(f + g) × (h + k)= (f × h)+ (g × k)	0 × 0=0 
and where Δ : A −→ A × A and all projections πi are additive. An important characterization of Cartesian left-additive categories is:
Proposition 3.1 (Proposition 1.2.2 [3]) To have a Cartesian left additive cat- egory is to have a Cartesian category in which each object, X, has a canonical
+X	0X
commutative monoid structure, X × X −−−→ X →−−− 1, that satisﬁes the following
coherence:


+	ex
+A × +B

A×B := (A × B) × (A × B) −−→ (A × A) × (B × B) −−−−−−−→ A × B.

Syntax of the additive λ-calculus
The syntax of the untyped additive λ-calculus is again defined by unityped terms in context. The term formation rules use the usual Cartesian rules Table 1, the formation rules for the λ-calculus Table 2, and the additive rules of Table 3.
The equations for β-equality and α-conversion hold together with equations to make (U, +, 0) into a commutative monoid, and
λx.(m + n)= λx.m + λx.n	and	λx.0=0 
(m + n) a = ma + na	and	0 a = 0.
These equations generate the theory Λβ+.
As before there is an associated category, C(Λβ+), called the classifying of the additive λ-calculus. The objects are words in U, ×, 1 and the arrows are sequents with one premise on the left of the turnstile. Composition is, again, substitution. We state modestly:

Proposition 3.2 C(Λβ+) is a Cartesian category in which U is a commutative monoid.
Our next task is to develop the categorical semantics of the additive λ-calculus, and thus, the properties of this category. To do this we must address two related issues: namely what it means to be an additive universal object and what it means to have additive canonical codes.
Additive universal objects
The idea behind a universal object in a category is that the entire category is determined by the monoid of endomorphisms of that object. For plain categories this just means that every object is a retract of U . However, in a Cartesian left additive category a universal object must have a stronger property as it must also induce the additive structure on each object. An object U in a left-additive category X is an additive universal object in case every object, A, is a retract of U in such a manner that the retraction rA, in A sA U , is an additive map. This requirement ensures that the additive structure on A is determined by that of U :
Lemma 3.3 In any left-additive Cartesian category with a retract A  sA U which

has rA additive:
+A

sA × sA

+	rA

A × A −−−→ A = A × A −−−−−−→ U × U −−→ U −−−→ A  and 0A = 0rA;
eA = rAsA satisﬁes +U eA = (eA × eA) +U eA.
Note that (i) implies that (fe + ge)r = (f + g)r. When an idempotent e : U
−→ U satisfies part (ii), that is +U e = (e × e) +U e, we will say e is a retractively additive idempotent.
The following – completely general – lemma lets us define additive structure on objects using additive retractions:
Lemma 3.4 If (U, +U , 0U ) is a commutative monoid in a Cartesian category, X, and A sA U with eA = rAsA retractively additive – that is (eA ×eA) +U eA = +U eA – then there is a unique commutative monoid structure on A which makes rA a homomorphism.
This means, when U is a universal object, which is a commutative monoid, we may, using Lemma 3.4, induce additive structure on any retract A of U , whose induced idempotent is retractively additive: this will automatically make the retract additive. In order, to create left-additive structure on the whole category from the additive structure on U , we must select a particular way in which each object is an additive retract so that we may induce a unique additive structure on each object. Furthermore, to ensure the result is a Cartesian left-additive category, it is also necessary for these induced additions to be compatible with the product: this means we must demand that the additive structure on the product A×B be defined componentwise.
A universal structure, U , for U ∈ X consists of, for each A ∈ X, a way in which A is a retract of U , U (A)= A  sA U . Clearly if U has a universal structure

it must be a universal object. A Cartesian category, X, has chosen products in case there are chosen functors × : X × X −→ X and 1 : K −→ X right adjoint to the diagonal and final functors respectively. In a Cartesian category with chosen products, if (U, +U , 0U ) is a commutative monoid, then a universal structure U for U is said to be additively coherent in case:
[UAC.1] U (U )= U  1U U ;
U
[UAC.2] The retraction, rU×U , of U (U × U ) satisfies:
U × U 	+U	/U¸


rU×U ×rU×U


	/¸		

rU×U
  

(U × U ) × (U × U ) ex
(U × U ) × (U × U )+U
×+/U¸× U

[UAC.3] Each idempotent eA = rAsA, of U (A) is retractively U -additive;
[UAC.4] U (A × B) has sA×B = (sC × sB)sU×U and rA×B = rU×U (rA × rB).
In a left-additive Cartesian category with an additive universal object, there is no guarantee that one has an additively coherent universal structure. However, given an additive universal structure one can generate a left-additive category:
Proposition 3.5 If X is a category with chosen products and a commutative monoid (U, +u, 0U ) which has an additively coherent universal structure, U, then there is a unique left additive structure on X making each retraction in U additive.
The proof uses the fact that the retractions are homomorphisms of the commu- tative monoid structure on objects.
Left-additive Turing categories
A left-additive Turing category is a Turing category which is Cartesian left- additive and has each universal application •BC : T × B −→ C additive in its first argument:
⟨h + k, g⟩• = ⟨h, g⟩• + ⟨k, g⟩•	and	⟨0, g⟩• =0 
A left-additive Turing category X has additive canonical codes when, as a Turing category, X has canonical codes such that, in addition, λ[f + g] = λ[f ]+ λ[g] and λ[0] = 0.
We have the following recognition theorem for left-additive Turing categories:
Proposition 3.6 X is a left-additive Turing category if and only if X is Cartesian left-additive, with an additively universal object T which has a Turing map • : T ×T
−→ T which is additive in its ﬁrst argument.
Furthermore, the Turing category has additively canonical codes if and only if the Turing map has additively canonical codes.
That objects have additive retractions from T uses the retraction from Propo- sition 2.3.

To see that we can construct canonical codes for A×B −→ C from canonical codes for T × T −→ T does require a bit of care concerning the definition of the addition on the maps: as only T has additive structure, f + g : A −→ B should be thought of as (fs + gs)r, where B  r T . The canonical code is sAλ[(rA × rB)(fsC + gsC)].
We are now ready to state:
Theorem 3.7 C(Λβ+) is a left-additive Turing category with additively canonical codes.
The proof of this theorem relies heavily on the fact that Curry’s retraction U
−→ U × U is additive, and this is enough to show that U has an additive universal structure. The rest of the proof follows easily.

Interpreting the additive λ-calculus
Our next objective is to show, that for any left-additive Turing category, X, with additively canonical codes, there is a left-additive functor C(Λβ+) −→ X. From a logical perspective this says that left-additive Turing categories with additively canonical codes are sound models of the additive λ-calculus.
Let X be a left-additive Turing category with additive canonical codes with Turing object T and Turing map is • : T × T −→ T . The functor   : C(Λβ+)
−→ X is defined in the same way as before on variables, application, abstraction, and tuples: all we have to describe is the interpretation of the additive structure:
p : X ▶ 0: U  =0: X  −→ T
p : X ▶ m + n : U  = p : X ▶ m : U  + p : X ▶ n : U  : X  −→ T
Proposition 3.8 When X is a left-additive Turing category with additive canonical codes
X

J ) : C(Λβ+) −→
is a Cartesian left-additive functor which preserve the Turing object, the Turing map, and its canonical codes.
The proof is by calculation and is relatively standard.
Again with more work this interpretation can be turned into an adjunction be- tween additive λ-theories and left-additive Turing categories with additive canonical codes.

Additive reflexive objects
We now wish to split the idempotents of a left-additive Turing category with additive canonical codes. However, it is clear that we cannot split any old idempotent if we want to be able to induce an additive structure on the splitting. So clearly we should split the retractively additive idempotents. However, when we restrict the idempotents we split we have to ensure that all the structure we require, namely the Cartesian left additive structure, is still present.

Clearly all identity maps are additively retractive idempotents. Note that the product of retractively additive idempotents is retractively additive, and the require- ments of being retractively additive on an idempotent is exactly what is required to obtain additive structure on each idempotent in the splitting.
Finally, note that the internal homsets of 2.6, [u, v] = λ[(1 × u) •AB v], are additively retractive.
A Cartesian closed left-additive category is a Cartesian left additive cat- egory which is closed and has every evaluation map additive in its first argument. As a Cartesian closed category always has canonical codes, this may equivalently be stated as the requirement that it has additive canonical codes. This gives:
Theorem 3.9 If X is a left-additive Turing category with additive canonical codes then splitting the additively retractive idempotents, Split+(X) yields a Cartesian closed left-additive Turing category.
By construction all the additively retractive idempotents split with additive retractions; hence, the retraction T −→ [T, T ] is additive. This immediately means that every model of the additive λ-calculus can be seen to arise as an additive reflexive object in a Cartesian closed left-additive category.
The Differential λ-calculus
A Cartesian differential category X is a Cartesian left additive category with a combinator

f
A −−→ B	
A × A −−−−→ B
D[f ]
that satisfies seven axioms:
[CD.1] D[0] = 0 and D[f + g]= D[f ]+ D[g]
[CD.2] ⟨0, g⟩ D[f ]=0 and ⟨h + k, g⟩ D[f ]= ⟨h, g⟩ D[f ]+ ⟨k, g⟩ D[f ]
[CD.3] D[1] = π0, D[π0]= π0π0, and D[π1]= π0π1
[CD.4] D[⟨f, g⟩]= ⟨D[f ], D[g]⟩
[CD.5] D[fg]= ⟨D[f ], π1f⟩ D[g]
[CD.6] ⟨⟨g, 0⟩ , ⟨h, k⟩⟩ D[D[f ]] = ⟨g, k⟩ D[f ]
[CD.7] ⟨⟨p, h⟩ , ⟨g, k⟩⟩ D[D[f ]] = ⟨⟨p, g⟩ , ⟨h, k⟩⟩ D[D[f ]]
In a Cartesian differential category a map f is linear when D[f ]= π0f . Intu- itively this means

df (x)
dx
(x) · v = f (v)

The following is corollary 2.2.3 in [3]
Proposition 4.1 If a map is linear, then it is additive. Moreover, the class of linear maps form a commutative monoid enriched category with biproducts.



Table 4
Term formation rules for the differential λ-calculus
The following lemma is quite useful in many calculations
Lemma 4.2 Let h and k be linear and f any map, then
D[hfk]= (h × h)D[f ]k.

In a Cartesian differential category, if f : A×B −→ C, we may define the partial derivative of f with respect to A as
⟨1, 0⟩× 1	D[f ]
D×,0 := A × (A × B) −−−−−−→ (A × B) × (A × B) −−−−→ C
One may obtain the partial derivative of f with respect to B by
⟨0, 1⟩× 1	D[f ]
D×,1 := B × (A × B) −−−−−−→ (A × B) × (A × B) −−−−→ C
We will also make use of maps that are linear in the first argument. This means

(v, (x, y)) '→
df (x, y)
dx
(x) · v = f (v, y)

i.e. that the partial derivative in the first argument is linear.
The following is useful in many calculations:
Lemma 4.3 Suppose h : A × B −→ C is linear in its ﬁrst argument. Then (1 × g)h
is linear in its ﬁrst argument for any g.
Intuitively this is so because g does not “touch” the first argument of h.
Syntax of the differential λ-calculus
The syntax of the untyped differential λ-calculus is again defined by unityped terms in context. Term formation uses the rules of Cartesian theories Table 1, the rules for the λ-calculus Table 2, the rules for the additive λ-calculus, Table 3, and a single new rule for the differential λ-calculus, Table 4. Note that the syntax we use here is slightly different from (but equivalent to) the syntax used by Ehrhard and Regnier in [12] 8 .
We have the following equations on terms

8  In Ehrhard and Regnier’s syntax, D(m) · v := λa. dmz (a) · v.

[Dt.1] dm1+m2 (a) · v = dm1 (a) · v + dm2 (a) · v d0 (a) · v =0 
dp	dp	dp	dp
[Dt.2] dm (a) · (v1 + v2)= dm (a) · v1 + dm (a) · v2 dm (a) · 0=0 

dx	dx
[Dt.3] • dx (a) · v = v,
dx	dx

 dt  ((a, aj)) · (v, vj)= dt[a×/p× ] (a) · v + dt[a/p] (aj) · vj
d(p,p× )	dp	dp×
[Dt.4] dm[t/q] (a) · v = dm (t[a/p]) ·  dt (a) · v
dp	dq	dp


[Dt.5]
Note in the above, by the context-formation rules, p /∈ fv(m).
d dm (a)·q
  dp	 (b) · v = dm (a) · v

dq
d  dm (a1)·v1
dp
d  dm (a2)·v2

[Dt.6]
 dp1	 (a2) · v2 =  dp2	 (a1) · v1

dp2	dp1
[Dt.7] dλy.m (a) · v = λy. dm (a) · v
dp	dp
By the context formation rules, x /∈ (a, v)
[Dt.8] dλz.y z (a) · v = λz.v z
Note that when we write  dt (a) · v in [Dt.4] the t could be a tuple of terms. However, this is only a notation for distributing the derivative down onto term of type U as only these have derivatives. This means d() (a) · v = () and d(t1,t2) (a) · v =

( dt1 (a) · v, dt2 (a) · v).
dp	dp

dp	dp
Lemma 4.4 In Λβ∂:
If y /∈ fv(m) then dm (a) · v = 0;
 dm  ((a, aj)) · (v, 0) = dm[a×/p× ] (a) · v;

d(p,p× )	dp
 dm  ((s, sj)) · (0, vj)= dm[a/p] (aj) · vj;
d(p,p× )	dp×
If y /∈ fv(m) then dym  (a) · v = vm;
dmn  (a) · v =  dm (a) · v (n[a/x]) + d(m[a/x]) z1 (n[a/x]) · dn (a) · v.
The proof is straightfoward; the first three are from [3]. There is an associated category C(Λβ∂). We have
Proposition 4.5 C(Λβ∂) is a Cartesian category in which (U, +U , 0U ) is a com- mutative monoid.
Differential universal objects
In subsection 3.2, we introduced the notion of an additive universal object that induces an additive structure on each object. In a Cartesian differential category, we must again strengthen the notion of universal object, so that the derivative on maps U −→ U induces a derivative on all maps. An object U in a Cartesian differential category X is a differential universal object in case every object A is a retract of U , A  sA U , and the retraction is linear.
Lemma 4.6 In any Cartesian differential category with a retract A sA U in which
rA is linear

f
For any A −−→ B, D[f ]= (sA × sA)D[rAfsB]rB;
eA = rAsA satisﬁes (eA × eA)D[eA]= D[eA] and D[eA]eA = π0eA
The proof makes repeated use of 4.2.
When an idempotent satisfies part (ii) of the above and is retractively addtive, we will say that it is a retractively linear idempotent.
We now extend the extend the notion of additively coherent universal structure. In a Cartesian category with chosen products, where (U, +U , 0U ) is a commutative monoid, a universal structure U for U is differentially coherent if it is additively coherent and additionally:
[UDC.1] There is a differential operator for U ; i.e.
f
U −−→ U	
U × U −−−−→ U
D[f ]
that satisfies [CD.1,2,3,5].
[UDC.2] Each idempotent eA = rAsA of U (A) is retractively U -linear in the sense that
(eA × eA)D[eA]= D[eA]	and	D[eA]eA = π0eA
[UDC.3] For U (U × U )= U × U sU×U , we have that
(sU×U × sU×U )D[rU×U π0]= π0π0 (sU×U × sU×U )D[rU×U π1]= π0π1
And that for any f, g : U −→ U :
D[⟨f, g⟩ sU×U ]rU×U = ⟨D[f ], D[g]⟩

f
[UDC.4] Let U −−→ U . The map


2	sU×U × sU×U
D[rU×U D[f ]]

D [f ] := (U × U ) × (U × U ) −−−−−−−−−−→ U × U −−−−−−−−−→ U
satisfies
⟨⟨g, 0⟩ , ⟨h, k⟩⟩ D2[f ]= ⟨g, k⟩ D[f ]
⟨⟨0, h⟩ , ⟨g, k⟩⟩ D2[f ]= ⟨⟨0, g⟩ , ⟨h, k⟩⟩ D2[f ] ((eA × eA) × (eA × eA))D2[f ]= D2[f ]
Given a differentially coherent universal structure on a category, one can gener- ate a Cartesian differential category.
Proposition 4.7 If X is a category with chosen products and a commutative monoid (U, +U , 0U ) which has a differentially coherent universal structure, U, then there is a Cartesian differential structure on X that makes each retraction in U linear.

We first show that X has a Cartesian differential structure. Note the following facts about U idempotents.
f
For all U −−→ U , D[f eB]rB = D[f ]rB
f
For all A −−→ B, (eA × eA)D[rAfsB]= D[rAfsB]
The differential operator D[ ] is defined on maps A −→ B:

f
A −−→ B	
f	U −−→ A −−→ B −−−→ U

  A −−→ B	
rA	f	sB

A × A −−−−→	=
D[f ]


U × U −−−−−−−→ U
D[rAfsB]


A × A −−−−−−→ U × U −−−−−−−→ U −−−→ B

sA × sA
D[rAfsB]	rB

Differential Turing categories
A differential Turing category is a Turing category which is also a Cartesian
•
differential catgory and where additionally each universal application T ×B −−−−→ C
is linear in its first argument.
The above definition has the property that if cf is a code for f , then
df (x, y) (a) · v = dcf (x) y (a) · v =  dcf (x) (a) · v  y

so that the derivative of f in it’s first argument is given by the derivative of cf .
A differential Turing category X has differential canonical codes when X has additive canonical codes λ( ) that satisfy in addition:
D[λ(f )] = λ(⟨π0 × 0, π1 × 1⟩ D[f ])
The following is a recognition theorem for differential Turing categories.
Proposition 4.8 A Cartesian differential category X is a differential Turing cate- gory if and only if
X has a differentially universal object T ;
There is a map T × T −−•→ T that is universal for maps T × T −→ T and that is linear in its ﬁrst argument.
Furthermore, X is a differential Turing category with differential canonical codes if and only if (i) and(ii) hold and T × T −−•→ T has differential canonical codes.
Proof. The usual retraction is linear; this follows as T × 1 −−•→ T is linear in its first argument, and ignores its second.
To show that we can construct differentially canonical codes for A × B −→ C from canonical codes for T × T  −→ T , consider the diagram that codes
⟨π0 × 0, π1 × 1⟩ D[f ] and use that r is linear, so that one takes the canonical code for (r × r) ⟨π0 × 0, π1 × 1⟩ (s × s)D[rfs].	 

For completeness we show that C(Λβ∂) is a differential Turing category with dif- ferentially canonical codes. We will first show that C(Λβ∂) is a Cartesian differential category in which U is a differentially universal object using proposition 4.7.
The differential structure on C(Λβ∂) is defined as follows:


D[p : S ▶ m : 1] := ()
D[p : S ▶ m : U ] := (v, p): S × S ▶

dm
(p) · v : U
dp

D[p : S ▶ (m1, m2): R × T ] := ⟨D[p : S ▶ m1 : R], D[p : S ▶ m2 : T ]⟩
Proposition 4.9 C(Λβ∂) is a Cartesian differential category in which U is a dif- ferentially universal object.
This proposition uses the fact that Curry’s retraction is linear, and that this is enough to determine a differential universal structure on U .
This leads to:
Theorem 4.10 C(Λβ∂) is a differential Turing category with differentially canoni- cal codes.
The proof involves a relatively straightforward sequence of calculations which show that codes are differentially canonical.
Interpreting the differential λ-calculus
Let X be a differential Turing category with differential canonical codes. We will show that there is a functor C(Λβ∂) −→ X that preserves all the differential structure
X is
and the canonical differential Turing structure. The functor J ) : C(Λβ∂) −→
defined in the same way as before for variables, applications, abstractions, sums, 0, and tuples of terms. For the differentials:
 q ▶ dm (a) · v  := ⟨⟨Jq ▶ u), 0⟩ , ⟨Jq ▶ a), 1⟩⟩ D[J(p, q) ▶ t)] To show that J ) is a functor a crucial step is to establish:
X where X is a differ-
Lemma 4.11 (Substitution lemma) For J ) : C(Λβ∂) −→
ential Turing category with differential canonical codes,
Jp ▶ m[n/q]) = Jp ▶ n)Jq ▶ m)
This then allows:
Proposition 4.12 When X is a differential Turing category with differentially canonical codes, then

is a Cartesian differential functorJ.)
: C(Λβ∂
) −→ X

Differential reflexive objects
To obtain the analog of the Scott-Koymans theorem we split the retractively linear idempotents in a differential Turing category with differential canonical codes to obtain a closed differential Turing category. As a first step, note:
Lemma 4.13 In any Cartesian differential category, the class E of retractively lin- ear idempotents is closed to identities and products. Furthermore, retractively linear idempotents are retractively additive.
The above lemma ensures that Split£ (X) is a Cartesian left additive category. The following proposition shows that if we split retractively linear idempotents, we can lift the differential structure from a Cartesian differential category to this idempotent splitting.
Proposition 4.14 Let X be a Cartesian differential category, and E the class of retractively linear idempotents. Then there is a unique differential structure on Split£ (X) in which all e ∈ E split with linear retraction and for which the inclusion X ‹→ Split£ (X) is a Cartesian differential functor.
Proof. From 3.9, we know that as E is a product closed of retractively additive idempotents that contains the identities, that Split£ (X) is a Cartesian left additive category.
In order for X ‹→ Split£ (X) to be a Cartesian differential functor, the differential on maps between identities f : 1A −→ 1B is forced to be the differential from X.
If each idempotent is to split with a linear retraction, the derivative must satisfy (sA × sA)D[rAfsB]rB = D[f ].

This means the derivative for a e −−→ ej
is:

D[f ] := (eA × eA)D[eAfeB]eB = (eA × eA)D[f ]eB = D[f ]eB
The details of the proof that this does indeed give a differential structure on Split£ (X) are relatively straightfoward; the proof will be somewhat similar to the proof of proposition 4.7.	 
Next, we show that differential Turing structure lifts to the idempotent splitting.
Proposition 4.15 When X is a differential Turing category (with Turing object
T ), then so is Split£ (X) where E is the class of retractively linear idempotents.
Proof. We have already seen that Split£ (X) is both a Cartesian differential category and a Turing category with Turing object 1T .
Each idempotent e is also a retract of the Turing object 1T .
Hence, using Proposition 4.8, it suffices to show that the Turing morphism 1T × 1T −−•→ 1T
is linear in its first argument, which is immediate.	 

Finally, we show that if E is the collection of retractively linear idempotents in a differential Turing category with canonical codes, then Split£ (X) is a Cartesian closed differential Turing category. We do not get for free that Split£ (X) is still a Cartesian closed category: we must show that E is closed to forming internal homs. Once we have established this, we will have that Split£ (X) is a Cartesian closed category that is also a differential Turing category. Moreover, it is then immediate that the coherence for Cartesian closed differential categories
D[λ(f )] = λ(⟨π0 × 0, π1 × 1⟩ D[f ])
holds because λ(f ) in Split£ (X) is the canonical code λ(f ) from X. Thus, the proof of the following theorem requires only that we show retractively linear maps are closed to forming internal homs.
We make use of lemma 4.3. Also, recall that if h is linear in its first argument, then
⟨π0 × 0, π1 × 1⟩ D[h]= a×(⟨1, 0⟩× 1)D[h]= a×(1 × π1)h = (π0 × 1)h
A few long calculations provide the proof of:
Theorem 4.16 When E is the collection of retractively linear idempotents in a dif- ferential Turing category with canonical codes, then Split£ (X) is a Cartesian closed differential Turing category.
This allows us to conclude the Scott-Koymans theorem for the differential λ- calculus.
Corollary 4.17 When E is the class of retractively linear maps of a differential Turing category with canonical codes, the Turing object 1T is a reflexive object in Split£ (X) and the retraction is 1T −→ [1T , 1T ] is a linear map.
Thus, every model of the differential λ-calculus may be seen to arise as a differ- ential reflexive object in a Cartesian closed differential category.

References
Birkedal, L., “Developing Theories of Types via Computability and Realizability,” Ph.D. thesis, Carnegie Mellon University (1999).
Blute, R., J. Cockett and R. Seely, Differential categories, in: Mathematical Structures in Computer Science, 2006.
Blute, R., J. Cockett and R. Seely, Cartesian Differential Categories, Theory and Application of Categories 22 (2009), pp. 622–672.
Blute, R., J. Cockett and R. Seely, Cartesian differential storage categories, Theory and Application of Categories (2015).
Boudol, G., The Lambda-Calculus with Multiplicities, in: CONCUR ’93 Proceedings of the 4th International Conference on Concurrency Theory, 1993.
Boudol, G., P. Curien and C. Lavatelli, A semantics for lambda calculi with resource, Mathematical Structures in Computer Science (1999).

Boudol, G. and C. Laneve, Lambda-Calculus, Multiplicities, and the pi-Calculus, Technical report, Institut National de Recherche en Informatique et en Automatique (1995).
Bucciarelli, A., T. Ehrhard and G. Manzonetto, Categorical Models for Simply Typed Resource Calculi, Electronic Notes in Theoretical Computer Science 265 (2010), pp. 213–230.
Cockett, J. and P. Hofstra, Introduction to Turing Categories., Annals of Pure and Applied Logic. 156.
(2008.), pp. 183–209.
Ehrhard, T., On K¨othe Sequence Spaces and Linear Logic, in: Mathematical Structures in Computer Science, 2002.
Ehrhard, T., Finiteness spaces, Mathematical Structures in Computer Science (2005).
Ehrhard, T. and L. Regnier, The Differential Lambda Calculus, Theoretical Computer Science 309
(2003), pp. 1–41.
Fiore, M., Differential structure in models of multiplicative biadditive intuitionistic linear logic, TLCA (2007).
Koymans, C., Models of lambda calculus, Information and Control (1982).
Lambek, J. and P. Scott, “An introduction to higher order categorical logic,” Cambridge University Press, 1986.
Longo, G. and E. Moggi, A category theoretic characterization of functional completeness, Theoretical Computer Science (1990).
Manzonetto, G., What is a Categorical Model of the Differential and the Resource Lambda Calculi?, Mathematical Structures in Computer Science 22 (2012), pp. 451–520.
Scott, D., Relating theories of the λ-calculus, Essays on Combinatory Logic, Lambda Calculus, and Formalism (1980).
