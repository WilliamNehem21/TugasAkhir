	Electronic Notes in Theoretical Computer Science 212 (2008) 225–239	
www.elsevier.com/locate/entcs

Building Certified Static Analysers by Modular Construction of Well-founded Lattices
David Pichardie
INRIA Rennes - Bretagne Atlantique, France

Abstract
This paper presents fixpoint calculations on lattice structures as example of highly modular programming in a dependently typed functional language. We propose a library of Coq module functors for constructing complex lattices using efficient data structures. The lattice signature contains a well-foundedness proof obligation which ensures termination of generic fixpoint iteration algorithms. With this library, complex well-foundedness proofs can hence be constructed in a functorial fashion. This paper demonstrates the ability of the recent Coq module system in manipulating algebraic structures and extracting efficient Ocaml implementations from them. The second contribution of this work is a generic result, based on the con- structive notion of accessibility predicate, about preservation of accessibility properties when combining relations.
Keywords: Proof assistant, Constructive proofs, Static analysis.

Introduction
Static program analyses rely on fixpoint computations on lattice structures to solve data flows equations. The basic algorithms are relatively simple, but lattice struc- tures can be complex when dealing with realistic programming languages. Termi- nation of these computations relies on specific properties of the lattice structures, as for example the condition that all ascending chains are eventually stationary. In this work, we aim at increasing confidence in static analysers by using the proof- as-programs paradigm: from a machine-checked correctness proof of an analysis, we extract a certified analyser. We use the extraction mechanism of the Coq proof assistant to extract Ocaml programs from constructive proofs. In earlier work, we presented a lattice library which allows the construction of complex lattices in a modular fashion [4]. It was shown how this library was used to construct large termination proofs based on the ascending chain condition. This paper presents a new version of this library, based now on the more general termination criteria of widening.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.064

We first present in Section 2 the module signature that models the kind of lattice we want to build. In Section 3 we motivate this library with a challenging example of lattice to be built in Coq. Sections 4 and 5 then present various lattice functors proposed in the library. Section 4 discusses binary functors, in particular the product functor. Section 5 deals with a functor of functions with various possible implementations. Conclusions are given in Section 6.
We expect the reader to be familiar with the ML module system. The whole
Coq development is available on-line 1 .

Related work
This paper is a descendent of the work of Jones [10] where a modular construction of finite lattices was proposed in the Haskell programming language using type classes. Our lattice signatures are not restricted to ML function types but they are also equipped with a specification. This is a consequence of the expressiveness gap existing between the Haskell and the Coq type systems.
In earlier work, we already introduced the lattice library [4]. However, we mainly discussed the semantic proofs required for certiﬁed analyses. Only ascending chain conditions proofs were studied and few details were given about their constructions. The current paper proposes several improvements:
Mechanical proofs about fixpoint iteration using widenings has never been re- ported before. Other existing works only deal with ascending chain condition [11,2,5,3]. Widening operators require more complex termination proofs.
In particular, new theoretical results about accessibility predicates are necessary to handle product of widening operators in the constructive logic of Coq.
We propose a modular notion of functions (see Section 5) which allows to con- struct termination proofs without relying on the actual implementation chosen. Previous proofs were specific to one implementation, and as a consequence it was very difficult to adapt them to new function implementations.
The technical contribution of this paper deals with the modular construction of large proof terminations in a proof assistant. Proving termination of static analysers is sometimes considered as useless because we only need to check the result of the analyser, if it terminates. Nevertheless, bugs concerning termination of fixpoint iteration are difficult to debug: when do you stop the analyser ? Because of their non-monotonous nature, widening operators break human intuition and sometimes leads to invalid termination proofs (as noticed by Antoine Min´e [13] as regards [16]). Few detailed constructive proofs about accessibility properties have been pub- lished. The reference in this field is the work of Paulson [15] where general rules to preserve accessibility properties are given. Many of our proofs depend on these rules, however the notion of widening operator required further extensions. As far
as we know the result proved in Theorem 4.6 is new.

1 http://www.irisa.fr/lande/pichardie/lattice/

Module signatures for lattices
This work is based on two algebraic structures: partially ordered sets (posets) and lattices (see [8] for standard definitions). To be precise we consider a more general notion that posets because the posets (A, ≡, ±) we consider in this paper are in fact composed of a set A and a pre-order ±. ≡ is the associated equivalence relation.
In Coq, the corresponding definitions are given as module signatures (see Fig- ure 1). The Poset signature reads as follow: a module of type (or signature) Poset must at least contain a type t (to model elements in the posets) and two relations eq and order. It must also contain proofs that eq (resp order) is an equivalence relation (resp. a partial order). These required proofs are represented with the keyword Axiom. At last, the two relations eq and order must come with a computable test function eq_dec and order_dec. The type of the operator eq_dec is a dependent type that expresses the following: for any x and y of type t, the function must return a boolean such that, if the boolean is true, x and y are equivalent, otherwise if it is false, they are not.
The Lattice signature includes all elements of the Poset signature with the com- mand Include Poset 2 . A first consequence of these signature definitions is that the statement “every lattice is a poset” is free in Coq: a module satisfying the Lattice signature, satisfies the Poset signature too.
We will need a further property to be able to compute over-approximation of fixpoints in such structures. In our previous work [4] we considered the ascending chain condition but in this work we are interested in more general criterion: the existence of a widening operator.
The standard fixpoint iteration `a la Kleene may require an important number of iterations before convergence. Moreover, some lattices used in static analysis do not respect the ascending chain condition (like the lattice of intervals used in Sec- tion 3). The solution proposed by Cousot and Cousot [7] is a fixpoint approximation by a post fixpoint. Such a post fixpoint is computed with an algorithm of the form x0 = ⊥, and ∀n, xn+1 = xnof (xn) with o a binary operator on A which ”extrap- olates” its two arguments. The computed sequence should be increasing (property ensured if o satisfies ∀x, y ∈ A, x ± xoy) and should over-approximate the classical iteration: fn(⊥) ± xn (property ensured if o satisfies ∀x, y ∈ A, y ± xoy). A last condition ensures the computation convergence: after a finite number of steps, we must reach a post fixpoint. The criterion proposed in the literature is generally “ for all increasing chains x0 ± x1 ± ··· ± xn ± ··· , the chain y0 = x0, yn+1 = ynoxn+1 eventually reaches a rank k with yk ≡ yk+1”.
In order to implement this algorithm in Coq, we will work with a definition which is better adapted to constructive proofs. This definition will be based on the notion of accessibility and of noetherian 3 relation [1].
Definition 2.1 (Accessibility) Given a relation ≺ on a set A, the set Acc≺ of

2 This command is not currently available in the Coq system. It should be replaced by the complete list of elements found in the module.
3 The Coq library uses the inappropriate name of well-founded relation.


Module Type Poset.
Parameter t : Set.
Parameter eq : t → t → Prop. Axiom eq_refl : ∀ x : t, eq x x.
Axiom eq_sym : ∀ x y : t, eq x y → eq y x.
Axiom eq_trans : ∀ x y z : t, eq x y → eq y z → eq x z.
Parameter eq_dec : ∀ x y : t, {eq x y}+{¬ eq x y}.
Parameter order : t → t → Prop.
Axiom order_refl : ∀ x y : t, eq x y → order x y.
Axiom order_antisym : ∀ x y : t, order x y → order y x → eq x y. Axiom order_trans : ∀ x y z : t, order x y → order y z → order x z. Parameter order_dec : ∀ x y : t, {order x y}+{¬ order x y}.
End Poset.
Module Type Lattice.
Include Poset.
Parameter join : t → t → t.
Axiom join_bound1 : ∀ x y : t, order x (join x y). Axiom join_bound2 : ∀ x y : t, order y (join x y). Axiom join_least_upper_bound :
∀ x y z : t, order x z → order y z → order (join x y) z.
Parameter meet : t → t → t.
Axiom meet_bound1 : ∀ x y : t, order (meet x y) x. Axiom meet_bound2 : ∀ x y : t, order (meet x y) y. Axiom meet_greatest_lower_bound :
∀ x y z : t, order z x → order z y → order z (meet x y).
Parameter bottom : t.
Axiom bottom_is_bottom : ∀ x : t, order bottom x.
End Lattice.


Fig. 1. The lattice signature
accessibles elements with respect to ≺ are inductively defined as
∀y ∈ A, y ≺ x ⇒ y ∈ Acc≺
x ∈ Acc≺
Definition 2.2 (Noetherian relation) A relation ≺ on a set A is noetherian if all elements in A is accessible with respect to ≺.
Intuitively, an element is accessible with respect to a relation ≺ if it is not the starting point of any infinite ≺-decreasing chain. A trivial example of accessible element is an element without predecessor.
In order to express this widening criterion with the accessibility notion, we need to define a relation where infinite chains will be prohibited. Such a relation is defined by (x1, y1) ≺o (x2, y2) iff x2 ± x1 ∧ y1 ≡ y2ox1 ∧ y1 /≡ y2. Then, the following equivalence holds


there exists a chain x0 ± ··· ± xn+1 ± · · · with y0 = x0, and ∀n, yn+1 = ynoxn satisfying ∀k, yk /≡ yk+1
there exists a sequence ((xk, yk))k∈N
⇐⇒	satisfying x0 = y0
and ∀k, (xk+1, yk+1) ≺o (xk, yk)

The classical criterion found in the literature can hence be formulated under the form
∀x ∈ A, (x, x) ∈ Acc≺o

Note that we do not require all elements to be accessible, only those of the form (x, x) because they are potential starting points for iteration with widening.
Finally, these properties are collected in the PosetWiden interface given in Fig- ure 2. The properties widen_eq1 and widen_eq2 ensure that o respects the equivalence
≡ taken on A. The definition of the signature LatticeWiden (lattice with a widening operator) is expressed in a similar way.
Figure 3 gives the construction of the associated generic post fixpoint solver. This module is a functor that takes in argument a module of type LatticeWiden and build an operator pfp_widen that computes post fixpoints. It is expressed in the type of the operator as follow: given a function f, if f is monotone then the function returns an element x in the lattice that is a post fixpoint.

Fig. 2. The module signature for poset with a widening operator

Fig. 3. Postfixpoint computation

A challenging example
When formalizing analyses for realistic programming language, the underlying lat- tice may be complex, even for analyses of middle precision. We give here an example of such lattice in order to motivate and illustrate our lattice library.
The aim of this lattice is to abstract the memory of a Java virtual machine with a context-sensitive interval abstraction for numerical values and context-sensitive class abstraction for references. Because in Java, values are numerics or references it is natural to abstract them with a sum of lattice, here the sum of the set of class name and the interval domain [7].
Val = ℘(ClassName) + Interval

The global structure of the lattice is then of the form:
St = L × H
with L and H some function domains of the form:
L = Context → ((Val)٨ × (Var → Val))	H = ClassName → (FieldName → Val)
Var, ClassName, FieldName, MethodName and ProgPoint represent here the (fi- nite) sets of variable name, class name, field name, method name and program points. All this set are encoded with integers on 32 bits. The set Context is com- posed of list of couples in MethodName × ProgPoint. These lists have at most k elements and represent the last k call sites.
Context = (MethodName × ProgPoint)∗≤k
L is the flow-sensitive local abstraction of operand stack and local variables. H is the flow-insensitive abstraction of the heap.
The global domain St admit a lattice structure with a widening operator. Thanks to our lattice library it can be simply built by composition of functors. The construction is presented in Figure 4. For Val we use a functor SumLiftLatticeWiden that builds the disjoint sum of two lattices. We build H with the function functor presented in Section 5. The MapLatticeWiden functor allows to build function with a complex codomain (here Context). Its utilisation (corresponding to line 8 to 11) will be explained in Section 5. The final lattice is built with the product functor ProdLatticeWiden presented in the next section.

1
2
3
4
5
6
7
8
9
10
11
12
13

Fig. 4. Construction of the global lattice in Coq
We will now present some of the functors introduced during this example. We will generally focus on the poset part (with widening) of the modules because the operators that are specific to lattice do not require any technical details.
Lattice functors
We propose three basic binary functors in our library: the product, the disjoint sum and the lifted sum. Due to lack of space, we will restrict our explanations in this paper to the product.

Poset product
Lemma 4.1 (Poset product) Given two posets (A, ≡A, ±A) and (B, ≡B, ±B), the triplet (A × B, ≡A×B, ±A×B) deﬁned by ≡A×B= {((a1, b1), (a2, b2)) | a1 ≡A a2 ∧ b1 ≡B b2} and ±A×B= {((a1, b1), (a2, b2)) | a1 ±A a2 ∧ b1 ±B b2} is a poset, called poset product.
In Coq, Lemma 4.1 corresponds to a functor which takes two modules of sig- nature Poset and returns a module respecting the Poset signature for the product structure.

The poset-with-widening product

Fig. 5. The poset-with-widening product functor

The construction of the poset-with-widening product functor is given in Figure 5. The interactive definition of this functor is made in three steps. We first give the functor signature with its base type t, its equivalence relation eq, its order relation order and the considered widening operator using the with notation. In a second step, we construct the definitions dealing with the poset part using the poset product functor ProdPoset. Note that in the expression ProdPoset(P1)(P2), modules P1 and P2 are used as module of type Poset. The signature inclusion of Poset into PosetWiden allows this use without requiring any proof of coercion. This is a convenient feature when manipulating nested algebraic structures.
The last step concerns the new part of this functor: the proof that the widening operator satisfies its termination criterion. In our previous work [4] the termination criterion for the product of noetherian poset (i.e. that satisfy the ascending chain condition) was proved using a classical result about lexicographic products, but it is not possible for widening operators. Indeed, the key lemma to be established is:

Lemma 4.2 Given two posets (A, ≡A, ±A) and (B, ≡B, ±B), two binary operators oA and oB on A and B, if ∀a ∈ A, (a, a) ∈ Acc≺oA and ∀b ∈ B, (b, b) ∈ Acc≺oB then the operator oA×B deﬁned by
(a1, b1) oA×B (a2, b2)= (a1oA a2, b1oB b2)
satisﬁes ∀c ∈ A × B, (c, c) ∈ Acc≺oA×B .
This result in standard when proved in classical logic [7]. In constructive logic, it has never been proved before (as far as we know). It requires a technical proof to be directly established (because by example, it relies on pairs of pairs). We can make a more general proof and express the current problem as a particular case. The idea consists in expressing ≺oA×B as a lexicographic product between ≺oA and
≺oB . We then have to prove a result of the form
∀a ∈ Acc¢ , ∀b ∈ Acc¢ , (a, b) ∈ Acc lex
A×B

with DA playing the role of ≺oA and DB the one of ≺oB . However if Dlex
denotes

the standard lexicographic product of the two relations, the result is generally false:

Lemma 4.3 Given two relations DA and DB on sets A and B, if a ∈ Acc¢A and
b ∈ Acc¢B , if there exist b' ∈ B such that b' /∈ Acc¢B and a' ∈ A such that a'DAa
then (a, b) /∈ Acc lex .
A×B

Proof. Let us suppose that (a, b) ∈ Acc lex
A×B
and show that b' ∈ Acc¢B then holds.

Because (a', b')Dlex
(a, b), we have (a', b') ∈ Acc lex
A×B
. But it implies b' ∈ Acc¢B .

Indeed, if we consider the function f : B → (A × B) defined by f (x)= (a', x), we
have

∀b1, b2 ∈ B, b1DBb2 ⇒ f (b1)Dlex
f (b2)

so we can apply the Lemma A.3 with f (b')= (a', b') to conclude.	 
The problem here is that we can take any element b' to obtain a predecessor

(a', b') of (a, b). The case a1DAa2 in the definition of Dlex
is hence too weak. We

have to make restrictions on b1 and b2. To this purpose, we introduce a relation (B
and propose a new product of the form
(a1, b1)Dlex(a2, b2) ⇐⇒ (a1DAa2 and b1(Bb2) or (a1 = a2 and b1DBb2)
adding a constraint between DB and (B to prevent having any b' as previously: if b2(Bb1 and b1 ∈ Acc¢B then b2 should stay in Acc¢B . We will take a simpler sufficient condition (requiring no accessibility):
∀b1, b2, b3 ∈ B, b1DBb2 and b2(Bb3 implies b1D+b3
We can even propose a symmetric definition and encompass the case of ±A×B (where a1 = a2 was replaced by a1 ≡A a2) by introducing a relation (A satisfying a similar property than (B.

Definition 4.4 (Extended lexicographic product) Given two pairs of relations DA and (A on a set A, DB and (B on B. The extended lexicographic product is the relation D(lex(¢A,¢B,{A,{B ) defined on A × B by
(a1, b1)D(lex(¢A,¢B ,{A,{B )(a2, b2) ⇐⇒
(a1DAa2 and b1(Bb2) or (a1(Aa2 and b1DBb2)
with the following conditions
∀a1, a2, a3 ∈ A, a1DAa2 and a2(Aa3 implies a1D+a3	(1)
∀b1, b2, b3 ∈ B, b1DBb2 and b2(Bb3 implies b1D+b3	(2)
When the context will allow us to do it without ambiguity, we will use D( to denote this relation.
Example 4.5 The standard lexicographic product is a special case of D(.
(a1, b1) NA×B (a2, b2) ⇐⇒ (a1 NA a2 and b1 ± b2) or (a1 ≡A a2 and b1 N b2) and we have
∀a1, a2, a3 ∈ A, a1 NA a2 and a2 ≡A a3 implies a1 NA a3


and
∀b1, b2, b3 ∈ B, b1 NB b2 and b2 ±B b3 implies b1 N+ b3

Then  NA×B = D(lex(+A,+B,≡A,±B).
Theorem 4.6 If DA, DB, (A and (B satisfy the hypotheses of the previous deﬁ- nition, then for all a ∈ Acc¢A and b ∈ Acc¢B , (a, b) ∈ Acc¢{.
Proof. The form of this statement encourages to use a noetherian induction on the property
∀a ∈ A, P(a) := ”∀b ∈ Acc¢B , (a, b) ∈ Acc¢{”
But the generated induction principle will be too weak because only usable for an element b ∈ Acc¢B .
We hence take a stronger goal by proving


∀a ∈ Acc
+ , ∀b1 ∈ Acc¢ , ∀b2 ∈ B, b2(∗ b1, ⇒ (a, b2) ∈ Acc¢{	(3)

¢A	B	B
with (∗  the reflexive transitive closure of (B.	This result is sufficient to es-

tablish our theorem because (∗
is reflexive and because Acc¢A = Acc
+ (using
A

Lemma A.4).  To prove (3), we use a noetherian induction on a and D+.  We
consider an element a1 ∈ Acc¢+ such that


∀a2 ∈ A, a2D+a1 ⇒
∀b1 ∈ Acc¢B , ∀b2 ∈ B, b2(∗ b1, ⇒ (a2, b2) ∈ Acc¢{
(4)

and try to prove ∀b1 ∈ Acc¢B , ∀b2 ∈ B, b2(∗ b1, ⇒ (a1, b2) ∈ Acc¢. Once time again a direct proof by induction on b1 will be unsuccessful without reinforcing first the current goal. We prove instead:


∀b1 ∈ Acc¢+ ,
∀b2 ∈ B, b2(∗ b1, ⇒
∀a3 ∈ A, a3(∗ a1 ⇒ (a3, b2) ∈ Acc¢{

(5)



This is a sufficient result because Acc¢B = Acc
+ and (∗
B
is reflexive. We prove

(5) by noetherian induction on b1. Hence we take an element b1 ∈ Acc¢+ such that

∀b1 ∈ Acc + , ∀b3 ∈ B, b3D+b1 ⇒

¢B	B
∀b2 ∈ B, b2(∗ b3, ⇒
(6)

∀a3 ∈ A, a3(∗ a1 ⇒ (a3, b2) ∈ Acc¢{

and we look for a proof of
∀b2 ∈ B, b2(∗ b1, ⇒ ∀a3 ∈ A, a3(∗ a1 ⇒ (a3, b2) ∈ Acc¢{
B	A
Let us suppose


b1 ∈ Acc¢+
(7)

b2(∗ b1	(8)
a3(∗ a1	(9)
and prove (a3, b2) ∈ Acc¢{. We have to consider a predecessor (a4, b4)
(a4, b4)D((a3, b2)	(10)
and we have to prove (a4, b4) ∈ Acc¢{. Using the definition of D(, two cases results from hypothesis (10).
Case 1 :
a4DAa3	(11)
b4(Bb2	(12)
We can use the induction hypothesis (4). Three conditions must be satisfied
a4DAa1 : true using hypotheses (1), (9) and (11).
b1 ∈ Acc¢B : true using (7) and the general result Acc¢+ = Acc¢B
b4(∗ b1 : true because of (12) and (8)

Case 2 :
a4(Aa3	(13)
b4DBb2	(14)
This time, we can use the induction hypothesis (6). Three conditions must be satisfied
b4D+b1 : true because of the hypotheses (2), (8) and (14)
b4(∗ b4 : true by reflexivity of (∗
B	B
a4(∗ a1 : true using hypotheses (9) and (13)
Hence the main result is established.	 
To prove Lemma 4.2, we only have to use a measure function (see Lemma A.3) f : (A × B) × (A × B) → (A × A) × (B × B) defined by f ((a1, b1) , (a2, b2)) = ((a1, a2) , (b1, b2)) and considering the relation ≺oA×B  on (A × B) × (A × B) and

D(lex(≺oA ,≺oB , oA ,GoB ) on (A × A) × (B × B) where  o
and “oB
are defined by

(x1, y1) oA (x2, y2) ⇐⇒ x2 ±A x1 ∧ y1 ≡ y2 and (x1, y1) “oB (x2, y2) ⇐⇒
x2 ±B x1 ∧ y1 ≡B y2oB x1. It is not difficult to verify that hypotheses of Theo- rem 4.6 are fulfilled and then conclude.

Lattices of functions
Another important functor concerns functions. Static analyses make heavy use of functions during their computations. Efficiency of the underlying data structures is hence crucial. However proof of termination properties on complex data structures can be hard. This section proposes an abstract notion of function implementation for which we prove termination properties. These proof can then be used for several efficient implementations. We now describe the functor which builds a poset with widening for functions.
First, we remark that implementing functions with the native functions of the chosen functional programming language is not a reasonable solution. It is better to use encoding as association lists, balanced trees, ... We will then prove the termination criterion of widening ”for all function implementations”.
Function implementation
The notion of function implementation is given in Figure 6. This signature handles
a module 4 A with a signature FiniteSet (associated with the function domain). The FiniteSet signature is given in Figure 7. It represents set in bijection with parts 0, cardinal − 1) of Z. Our library proposes finite set functors (product, list of bounded length) and a base finite set module (binary number on 32 bits).
a poset module B associated with codomain.

4 Modules can handles modules.	The corresponding signature element is then introduced by
Declare Module.



Fig. 6. Function implementation signature
an abstract type t used to represent functions.
a function get where (get F a) gives the image of a:A.t for the function associated with the element F:t.
fixed equivalence (eq) and order (order) relation definitions with their test imple- mentations (eq_dec and order_dec).
the property eq_refl ensures that get is compatible with the equivalence relation
A.eq taken on A.t.

Fig. 7. FiniteSet signature


A widening operator on functions
Now for any function implementation we build a poset with a standard widening operator. For functions in A → B this operator is defined as
∀f1, f2 ∈ A → B, ∀a ∈ A, (f1of2)(a)= f1(a)oAf2(a)
The proof of the termination criterion relies on the Theorem 4.6 and the finiteness of the codomain.

Two efficient implementations
We propose two function implementations in our library. The first is a specific im- plementation for functions whose domain is a bounded binary integer (each integer denotes a position in a tree [14]). This kind of efficient implementation is heavily used in Leroy’s certified compiler [12]. The second implementation is based on an abstract implementation of Ocaml maps. We have adapted the Ocaml signature to Coq and proven that any map fulfils the Func_FiniteSet_PosetWiden signature. We currently propose a sorted list implementation and plan an implementation with balanced tree, both based on the previous formalisation done in [9] 5 . Maps can by built on any finite set. Finite sets can be constructed with the previously enumer- ated functors.
To conclude this section, we finish by commenting the example presented in Figure 4. Context is a module of type FiniteSet that is built with the functor ListFiniteSet. N5 is a module that encapsulate the natural number 5. We hence bound our lists with at most 5 elements. MapLatticeWiden is a functor that take as argument a finite set (here Context), a map implementation (here Map built with sorted list) and a lattice with a widening operator. It builds the expected lattice and its widening operator.

Conclusion
We have presented a framework for programming fixpoint computations on lat- tice structures in a dependently typed functional language. In order to construct complex lattices, we propose a library of Coq module functors. We focused our ex- planations on the product and the function functor, but other functors are available in our Coq development.
The main contribution of this work deals with constructive proofs of termination properties. The termination criteria used with widening operators has required extensions of previousy known results about accessibility predicates. Termination proofs are often very difficult to do in a proof assistant. This library shows the benefit of modular reasoning to handle such complex proofs. By composing the various functors that we propose, it is now possible to easily construct termination proofs for deep structures with efficient extracted data structures in Ocaml.
We have more recently extend our library to handle narrowing operators [7]. Again the technical difficulty relies in the functor product. It is interesting to notice that termination criterion of the narrowing operator is proved with the Theorem 4.6. It confirms that this theoretical result was a cornerstone for our work.
We imagine two extension for our library. The first one concerns the construction of base lattices, those which are used to instantiate lattice functors and construct bigger lattices. Some automation could be proposed to quickly construct finite lattices with their correctness proofs starting from a text description of their Hasse diagram. The second one concerns Galois connexion that could be constructed in

5 Balanced trees are a keystone of the industrial-task Astre static analyser [6].

the same modular way.

References
Peter Aczel. An introduction to inductive definitions. In J. Barwise, editor, Handbook of Mathematical Logic, pages 739–. North-Holland Publishing Company, 1977.
Gilles Barthe and Guillaume Dufay. A tool-assisted framework for certified bytecode verification. In Proc. of the 7th International Conference on Fundamental Approaches to Software Engineering, (FASE’04), volume 2984 of LNCS, pages 99–113. Springer, 2004.
Yves Bertot, Benjamin Gr´egoire, and Xavier Leroy. A structured approach to proving compiler optimizations based on dataflow analysis. In Proc. of the International Workshop on Types for Proofs and Programs (TYPES’04), volume 3839 of LNCS, pages 66–81. Springer, 2004.
David Cachera, Thomas Jensen, David Pichardie, and Vlad Rusu. Extracting a Data Flow Analyser in Constructive Logic. Theoretical Computer Science, 342(1):56–78, September 2005.
Solange Coupet-Grimal and William Delobel. A uniform and certified approach for two static analyses. In Proc. of the International Workshop on Types for Proofs and Programs (TYPES’04), volume 3839 of LNCS, pages 115–137. Springer, 2004.
P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min´e, D. Monniaux, and X. Rival. The ASTRE´E Analyser. In Proc. of the 14th European Symposium on Programming Languages and Systems (ESOP’05), volume 3444 of LNCS, pages 21–30. Springer, 2005.
Patrick Cousot and Radhia Cousot. Systematic design of program analysis frameworks. In Proceedings of the 6th Symposium on Principles of Programming Languages (POPL’79), pages 269–282. ACM Press, New York, 1979.
B.A. Davey and H.A. Priestley. Introduction to Lattices and Order. Cambridge University Press, 1990.
Jean-Christophe Filliˆatre and Pierre Letouzey. Functors for Proofs and Programs. In Proc. of the 13th European Symposium on Programming Languages and Systems (ESOP’04), number 2986 in LNCS, pages 370–384. Springer-Verlag, 2004.
Mark P. Jones. Computing with lattices: An application of type classes. Journal of Functional Programming, 2(4):475–503, October 1992.
Gerwin Klein and Tobias Nipkow. Verified Bytecode Verifiers. Theoretical Computer Science, 298(3):583–626, 2002.
Xavier Leroy. Formal certification of a compiler back-end, or: programming a compiler with a proof assistant. In Proc. of 33th ACM Symposium on Principles of Programming Languages (POPL’06), pages 42–54. ACM Press, 2006.
Antoine Min´e. The octagon abstract domain. In AST 2001 in WCRE 2001, IEEE, pages 310–319. IEEE CS Press, October 2001.
Chris Okasaki and Andrew Gill. Fast mergeable integer maps. In Proc. of the ACM SIGPLAN Workshop on ML, pages 77–86, 1998.
Lawrence C. Paulson. Constructing recursion operators in intuitionistic type theory. Journal of Symbolic Computation, 2(4):325–355, December 1986.
Ran Shaham, Elliot K. Kolodner, and Shmuel Sagiv. Automatic removal of array memory leaks in java. In Proc. of the 9th International Conference on Compiler Construction (CC’00), LNCS, pages 50–66. Springer, 2000.

A	General results about accessibility predicats
The following results are proved by Paulson in [15] and belong to the Coq standard library.
Lemma A.1 For all relations R1, R2 on a set A, if R1 ⊆ R2 then AccR2 ⊆ AccR1 .

Lemma A.2 For all relation RB on a set B, for all function f : A → B with A a set, the relation RA deﬁned on A by RA = {(a1, a2) | (f (a1),f (a2)) ∈ RB} satisﬁes
∀a ∈ A, f (a) ∈ AccRB ⇒ a ∈ AccRA.
These two lemmas can be summarised in the following result
Lemma A.3 For all relations RA on a set A, RB on a set B, for all function f : A → B satisfying ∀(a1, a2) ∈ RA, (f (a1),f (a2)) ∈ RB, we have ∀a ∈ A, f (a) ∈ AccRB ⇒ a ∈ AccRA.
f is often called a measure function.
Lemma A.4 For all relation R on a set A, AccR = AccR+ with R+ the transitive closure of R.
