

Electronic Notes in Theoretical Computer Science 246 (2009) 27–38
www.elsevier.com/locate/entcs
Order-Sorted Generalization 5
Mar´ıa Alpuente a,1 Santiago Escobar a,2 Jos´e Meseguer b,3
Pedro Ojeda a,4
a Dpto. de Sistemas Informa´ticos y Computacio´n, Universidad Polit´ecnica de Valencia, Spain
b Department of Computer Science, University of Illinois at Urbana-Champaign, USA.

Abstract
Generalization, also called anti-unification, is the dual of unification. Given terms t and t', a generalization is a term t'' of which t and t' are substitution instances. The dual of a most general unifier (mgu) is that of least general generalization (lgg). In this work, we extend the known untyped generalization algorithm to an order-sorted typed setting with sorts, subsorts, and subtype polymorphism. Unlike the untyped case, there is in general no single lgg. Instead, there is a finite, minimal set of lggs, so that any other generalization has at least one of them as an instance. Our generalization algorithm is expressed by means of an inference system for which we give a proof of correctness. This opens up new applications to partial evaluation, program synthesis, and theorem proving for typed reasoning systems and typed rule-based languages such as ASF+SDF, Elan, OBJ, Cafe-OBJ, and Maude.
Keywords: least general generalization, partial evaluation, order–sorted reasoning


Introduction
Generalization, also called anti-unification, is the dual of unification. Given terms t and t', a generalization of t and t' is a term t'' of which t and t' are substitution instances. The dual of a most general unifier (mgu) is that of least general gener- alization (lgg), that is, a generalization that is a substitution instance of any other one. Generalization is a formal reasoning component of many program analysis and transformation methods, including theorem provers, and program analysis and transformation tools (see, e.g., [12,22,8,24]).

1 Email: alpuente@dsic.upv.es
2 Email: sescobar@dsic.upv.es
3 Email: meseguer@cs.uiuc.edu
4 Email: pojeda@dsic.upv.es
5 This work has been partially supported by the EU (FEDER) and the Spanish MEC TIN2007-68093-C02- 02 project, UPV PAID-06-07 project, and Generalitat Valenciana GV06/285 and BFPI/2007/076 grants.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.013

Although generalization goes back to work of Plotkin [25], Reynolds [27], and Huet [14] and has been studied in detail by other authors (see for example the survey [17]), to the best of our knowledge, all generalization algorithms, with the exception of the works of Pfenning on generalization in the higher-order setting of the calculus of constructions [24], assume an untyped setting. However, many applications, for example to partial evaluation, theorem proving, and program learning, for typed rule-based languages such as ASF+SDF [6], Elan [7], OBJ [13], CafeOBJ [11], and Maude [9], require a first-order typed version of generalization which does not seem to be available: we are not aware of any existing algorithm. Moreover, several of the above-mentioned languages have an expressive order-sorted typed setting with sorts, subsorts (where subsort inclusions form a partial order and are interpreted semantically as set-theoretic inclusions of the corresponding data sets), and subsort- overloaded function symbols (a feature also known as subtype polymorphism), so that a symbol, for example +, can simultaneously exist for various sorts in the same subsort hierarchy, such as + for natural, integers, and rationals, and its semantic interpretations agree on common data items.
In a way similar to the dual case of order-sorted unification, a case which, in contrast, has indeed been studied in detail (see, e.g. [28,21,30]), the extension of the generalization algorithm to the order-sorted setting is nontrivial. In particular, the existence and uniqueness of generalizations is typically lost. That is, first of all there is no lgg at all if two terms are unrelated in the sort ordering; and if they are related (their sorts are both in the same connected component of the partial order of sorts), then there is in general no single lgg associated to a pair of terms. Instead, there is a finite and minimal set of least general generalizations, so that any other generalization has at least one of those as an instance. Such a set of lggs is the dual analogue of a minimal and complete set of unifiers for non-unitary unification algorithms, such as those for order-sorted unification, e.g., [28,21,30], and for equational unification (see, e.g., [5,29]). Note that this situation is quite different from the higher-order typed generalization algorithm of Pfenning [24], where for any two higher-order patterns, either there is no lgg (because the types are incomparable), or there is a unique lgg. A related definition of generalization is given in [1] for feature terms, an extended notion of terms that is also based on ordered sorts.
As it is usual in current treatments of different formal deduction mechanisms, and has become standard for the dual case of unification algorithms since Martelli and Montanari (see, e.g., [18,15]), we specify the generalization process by means of an inference system rather than by an imperative-style algorithm. Even for the known untyped generalization case, which we present as a special case to motivate its order-sorted extension, this has several expository and conceptual advantages, and we give an inference system that to the best of our knowledge is new. After this, we show how our unsorted calculus naturally extends to the new order-sorted generalization algorithm. We illustrate the use of the inference rules with several examples. Finally, we give a proof of correctness of our inference system.
As already mentioned, this opens up new applications to partial evaluation,

program synthesis, and inductive theorem proving for first-order typed rule-based languages such as ASF+SDF, Elan, OBJ, CafeOBJ, and Maude, and to theorem proving tools, program learning tools, and partial evaluators for such languages. In our own work, we plan to use the above order-sorted generalization algorithm as a key component of a narrowing-based partial evaluator (PE) for programs in order- sorted rule-based languages such as OBJ, CafeOBJ, and Maude. This will make available for such languages useful narrowing based PE techniques developed for the untyped setting in, e.g., [3,4]. We are also considering adding this generalization mechanism to an inductive theorem prover such a Maude’s ITP [10] to support automatic conjecture of lemmata. This will provide a typed analogue of similar automatic lemma conjecture mechanisms in untyped first-order inductive theorem provers such as Nqthm [8] and its ACL2 successor [16].

Related work
Plotkin [25] and Reynolds [27] gave an imperative–style algorithm for general- ization, which are both essentially the same. Huet’s generalization algorithm [14], formulated as a pair of recursive equations, cannot be understood as an automated calculus. A deterministic reconstruction of Huet’s algorithm is given in [23] which does not consider types either. An operational definition of the least general gen- eralization of clauses based on (order–sorted) feature terms is given in [1]. Finally, the algorithm for generalization in the calculus of constructions of [24] cannot be used for order-sorted theories.

Preliminaries
We follow the classical notation and terminology from [31] for term rewriting and from [19,20] for rewriting logic and order-sorted notions. We assume an order- sorted signature Σ with a finite poset of sorts (S, ≤) and a finite number of function symbols. We furthermore assume that: (i) each connected component in the poset ordering has a top sort, and for each s ∈ S we denote by [s] the top sort in the component of s; and (ii) for each operator declaration f : s1 × ... × sn → s in Σ, there is also a declaration f : [s1]×.. .×[sn] → [s]. Throughout this paper, we assume that Σ has no ad-hoc operator overloading, i.e., any two operator declarations for the same symbol f with equal number of arguments, f : s1 × ... × sn → s and
f : s' × ... × s' → s', must necessarily have [s1] = [s' ],..., [sn] = [s' ], [s] = [s'].
1	n	1	n
We assume an S-sorted family X = {Xs}s∈S of disjoint variable sets with each Xs countably infinite. A fresh variable is a variable that appears nowhere else. TΣ(X )s is the set of terms of sort s, and TΣ,s is the set of ground terms of sort s. We write T (Σ, X ) and T (Σ) for the corresponding term algebras. We assume that TΣ,s /= ∅ for every sort s.
For a term t, we write Var (t) for the set of all variables in t. Term positions are
represented as strings of natural numbers and are endowed with the prefix ordering
≤ on strings. The set of positions of a term t is written Pos(t), and the set of non-variable positions PosΣ(t). The root position of a term is Λ. The subterm of t

at position p is t|p and t[u]p is the term t where t|p is replaced by u. By root(t) we denote the symbol occurring at the root position of t.
A substitution σ is a sorted mapping from a finite subset of X , written Dom(σ), to T (Σ, X ). The set of variables introduced by σ is Ran(σ). The identity substitu- tion is id. Substitutions are homomorphically extended to T (Σ, X ). The application of a substitution σ to a term t is denoted by tσ. The restriction of σ to a set of vari-
ables V is σ|V . Composition of two substitutions is denoted by juxtaposition, i.e., σσ'. We call a substitution σ a renaming if there is another substitution σ−1 such that σσ−1|Dom(σ) = id. Substitutions are sort–preserving, i.e., for any substitution σ, if x ∈ Xs, then xσ ∈ TΣ(X )s.
We write the sort associated to a variable explicitly with a colon and the sort,
i.e. x :Nat. We assume pre-regularity of the signature Σ, ensuring that every term t has a unique least sort, denoted by LS(t). Therefore, the top sort in the connected component of LS(t) is denoted by [LS(t)]. Since the poset (S, ≤) is finite and each connected component has a top sort, given any two sorts s and s' in the same connected component, the set of least upper bound sorts of s and s', although not necessarily a singleton set, always exists and is denoted by LUBS(s, s').

Untyped Least General Generalization
We revisit untyped generalization, going back to Plotkin [25], Reynolds [27], and Huet [14], giving a new inference system that will be useful in our subsequent ex- tension of this algorithm to the order–sorted setting given in Section 4. Throughout this section, we assume terms t ∈ TΣ(Σ, X ) for Σ an unsorted signature (i.e., there is only one sort).
Let ≤ be the standard instantiation quasi–ordering on terms given by the relation of being “more general”, i.e. t is more general than s (i.e. s is an instance of t), written t ≤ s, iff there exists θ such that tθ = s. The most general unifier of a (unifiable) set M is the least upper bound (most general instance) of M under ≤. The less general generalization corresponds to the greatest lower bound. Given a non–empty set M of terms, the term w is a generalization of M if, for all s ∈ M , w ≤ s. A term w is the least general generalization of M if w is a generalization of M and, for each other generalization u of M , u ≤ w.
The non-deterministic generalization algorithm λ of Huet [14] (also treated in detail in [17]) is as follows. Let Φ be any bijection between T (Σ, X ) ×T (Σ, X ) and a set of variables V . The recursive function λ on T (Σ, X ) ×T (Σ, X ) that computes the lgg of two terms is given by:
λ(f (s1,..., sm),f (t1,..., tm)) = f (λ(s1, t1),..., λ(sm, tm)), for f ∈ Σ
λ(s, t) = Φ(s, t), otherwise.
Central to this algorithm is the global function Φ that is used to guarantee that the same disagreements are replaced by the same variable in both terms.
In the following, we provide a novel set of inference rules for computing the
least generalization (lgg) of two terms, avoiding implicit assumptions by using a

store of already solved generalization sub-problems. This algorithm can also be used (thanks to associativity and commutativity of lgg) to compute the lgg of an arbitrary set of terms by successively computing the lgg of two elements of the set in the obvious way.
In our reformulation, we represent a generalization problem between terms s and
x
t as a constraint s  t, where x is a fresh variable that stands for a (most general)
generalization of s and t. By means of this representation, any generalization w of
s and t is given by a substitution θ such that xθ = w.
We compute the least general generalization of s and t by means of a transi- tion system (Conf, →) [26] where Conf is a set of conﬁgurations and the transition relation → is given by a set of inference rules. Besides the constraint component,
xi
i.e., a set of constraints of the form ti   ti' , and the substitution component, i.e.,
the partial substitution computed so far, configurations also include an extra com- ponent, called the store. This store 6 plays the role of the function Φ of Huet’s
generalization algorithm, with the difference that our stores are local to the system configurations, whereas Φ can instead be understood as a global repository. We note that the non–globality of the store will be the key for computing a minimal and complete set of solutions for the order–sorted case.
Definition 3.1 A configuration, written as ⟨C | S | θ⟩, consists of three compo- nents:

x1
the constraint component C, i.e., a conjuntion s1   t1 ∧ ... ∧ sn
sents the set of unsolved constraints
xn
  tn that repre-

the store component S, that records the set of already solved constraints, and
the substitution component θ, that consists of bindings for some of the variables
xi
x1,..., xn present in constraints si   ti of C and S.

x
Starting from the initial configuration ⟨t  t' |∅| id⟩, configurations are transformed
until a terminal configuration ⟨∅ | S | θ⟩ is reached. Then, the lgg of t and t' is given by xθ. As we will see, θ is unique up to renaming.
The transition relation → is given by the smallest relation satisfying the rules in Figure 1. In this paper, variables of terms t and s in a generalization problem
x
t  s are considered as constants, since they are never instantiated. The meaning
of the rules is as follows.
The rule Decompose is the syntactic decomposition generating new constraints to be solved.
x
The rule Recover checks if a constraint t  s ∈ C with root(t) /≡ root(s), is
y
already solved, i.e., there is already a constraint t  s ∈ S for the same conflict pair
(t, s), with variable y. This is needed when the input terms of the generalization

6 Our notion of store appears to be comparable to the history set Hist of [1], though we came up with the idea of store independently.

Decompose	f ∈ (Σ ∪X )
⟨f (t1,..., tn)  f (t' ,..., t' ) ∧ C | S | θ⟩→ 
1	n
x1	xn
⟨t1   t' ∧ ... ∧ tn   t' ∧ C | S | θσ⟩
where σ = {x '→ f (x1,..., xn)}, x1,..., xn are fresh variables, and n ≥ 0

y
Solve	root(t) /≡ root(t') ∧ ∄y : t  t' ∈ S

x	x
⟨t  t' ∧ C | S | θ⟩→ ⟨C | S ∧ t  t' | θ⟩

Recover	root(t) /≡ root(t')
x	y	y


where σ = {x '→ y}
⟨t  t' ∧ C | S ∧ t  t' | θ⟩→ ⟨C | S ∧ t  t' | θσ⟩


Figure 1. Rules for least general generalization
problem contain the same conflict pair more than once, e.g., the lgg of f (a, a, a) and f (b, b, a) is f (y, y, a).
x
The rule Solve checks that a constraint t  s ∈ C with root(t) /≡ root(s), is not
x
already solved. If not already there, the solved constraint t  s is added to the
store S.
Note that the inference rules of Figure 1 are non–deterministic (i.e., they depend on the chosen constraint of the set C). However, they are confluent up to variable renaming (i.e., the chosen transition is irrelevant for computation of terminal config- urations). This justifies that the least general generalization of two terms is unique up to variable renaming [17].
Example 3.2 Let t = f (g(a), g(y), a) and s = f (g(b), g(y), b) be two terms. We apply the inference rules of Figure 1 and the substitution obtained by the lgg al- gorithm is θ = {x '→ f (g(x4), g(y), x4), x1 '→ g(x4), x2 '→ g(y), x5 '→ y, x3 '→ x4}, where the lgg is xθ = f (g(x4), g(y), x4). Note that variable x4 is repeated, to ensure the least general generalization. The execution trace is showed in Figure 2.
Termination and confluence (up to variable renaming) of the transition system (Conf, →) are straightforward.
x
Theorem 3.3 Every derivation stemming from an initial conﬁguration ⟨t  s | ∅ | 
id⟩ terminates.
Proof Let |u| be the number of symbol occurrences in a term u. Since the minimum of |t| and |s| is an upper bound to the number of times that the inference rules can be applied, then the derivation terminates.	 
Before proving soundness and completeness of the above inference rules, we need the auxiliary concepts of a conflict position and of conflict pairs, and three auxiliary

lgg(f (g(a), g(y), a),f (g(b), g(y), b))
↓ Initial Configuration
x
⟨f (g(a), g(y), a)  f (g(b), g(y), b) |∅| id⟩
↓ Decompose
x1	x2	x3
⟨g(a)  g(b) ∧ g(y)  g(y) ∧ a  b |∅| {x '→ f (x1, x2, x3)}⟩
↓ Decompose
x4	x2	x3
⟨a  b ∧ g(y)  g(y) ∧ a  b |∅| {x '→ f (g(x4), x2, x3), x1 '→ g(x4)}⟩
↓ Solve
x2	x3	x4
⟨g(y)  g(y) ∧ a  b | a  b | {x '→ f (g(x4), x2, x3), x1 '→ g(x4)}⟩
↓ Decompose
x5	x3	x4
⟨y  y ∧ a   b | a   b | {x '→ f (g(x4), g(x5), x3), x1 '→ g(x4), x2 '→ g(x5)}⟩
↓ Decompose
x3	x4
⟨a  b | a  b | {x '→ f (g(x4), g(y), x3), x1 '→ g(x4), x2 '→ g(y), x5 '→ y}⟩
↓ Recover
x4
⟨∅ | a  b | {x '→ f (g(x4), g(y), x4), x1 '→ g(x4), x2 '→ g(y), x5 '→ y, x3 '→ x4}⟩

Figure 2. Computation trace for unsorted generalization of terms f (g(a), g(y), a) and f (g(b), g(y), b)
lemmas. Given terms t and t', a position p ∈ Pos(t) ∩ Pos(t') is called a conflict position of t and t' if root(t|p) /≡ root(t'|p) and for all q < p, root(t|q) ≡ root(t'|q), and the pair (t|p, t'|p) is then called a conflict pair of t and t'. Also, note that given
x
a constraint t  t', x is always a (most general) generalization of t and t'.
x
Lemma 3.4 Given terms t and t' and a fresh variable x such that ⟨t  t' | ∅ |
y
id⟩ →∗ ⟨∅ | S | θ⟩, a constraint u  v is in S iff there exists a conflict position p of
t and t' such that t|p = u and t'|p = v.
x
Lemma 3.5 Given terms t and t' and a fresh variable x such that ⟨t  t' | ∅ |
id⟩ →∗ ⟨C | S | θ⟩, then xθ is a generalization of t and t'.
x
Lemma 3.6 Given terms t and t' and a fresh variable x such that ⟨t  t' | ∅ |
y
id⟩ →∗ ⟨∅ | S | θ⟩, then {y ∈X | ∃u  v ∈ S}⊆ Ran(θ), and Ran(θ) = Var (xθ).
Soundness and completeness is proved as follows.
Theorem 3.7 Given terms t and t' and a fresh variable x, u is the lgg of t and t'
x
if and only if ⟨t  t' |∅| id⟩ →∗ ⟨∅ | S | θ⟩ and there is a renaming ρ s.t. uρ = xθ.
Proof We rely on the already known existence and uniqueness of the lgg of t and t' and reason by contradiction. By Lemma 3.5, xθ is a generalization of t and t'. If xθ is not the lgg of t and t', then there is a term u which is the lgg of t and t' and a substitution ρ such that is not a variable renaming and xθρ = u. Since, by Lemma 3.6, Ran(θ) = Var (xθ), we can always choose ρ with Dom(ρ) = Var (xθ). If ρ is not a variable renaming, either:
there are variables y, y' ∈ Var (xθ) and a variable z such that yρ = y'ρ = z, or
there is a variable y ∈ Var (xθ) and a non-variable term v such that yρ = v.

In case (i), there are two conflict positions p, p' for t and t' such that u|p = z = u|p' and xθ|p = y and xθ|p' = y'. In particular, this means that t|p = t|p' and t'|p = t'|p' . But this is impossible by Lemmas 3.4 and 3.6. In case (ii), there is a position p such that xθ|p = y and p is neither a conflict position of t and t' nor it is under a conflict position of t and t'. But this is impossible by Lemmas 3.4 and 3.6.	 
Order–sorted Least General Generalizations
In this section, we generalize to the order-sorted setting the unsorted generalization algorithm presented in Section 3.
We consider two terms t and t' having the same top sort, otherwise they are incomparable and no generalization exists. Starting from the initial configuration
x:[s]
⟨t    t' | ∅ | id⟩ where [s] = [LS(t)] = [LS(t')], configurations are transformed until
a terminal configuration ⟨∅ | S | θ⟩ is reached. In the order–sorted setting the lgg in general, is not unique. Each terminal configuration ⟨∅ | S | θ⟩ provides an lgg of t and t' given by (x:[s])θ.
The transition relation → is given by the smallest relation satisfying the rules in Figure 3. The meaning of these rules is as follows.
The rule Decompose is the syntactic decomposition generating new constraints to be solved. Fresh variables are initially assigned a top sort, which will be appropriately “downgraded” when necessary.
The rule Recover is similar to the corresponding rule of Figure 1.
y
The rule Solve checks that a constraint t  t' ∈ C, with root(s) /≡ root(t), is not
y
already solved. Then the solved constraint t  t' is added to the store S, and
the substitution {x '→ z} is composed with the substitution part, where z is a fresh variable with sort in the LUBS of the least sorts of both terms. Note that this is the only additional source of non-determinism (besides the choice of the
constraint to work on) in our inference rules, in contrast to Figure 1. This extra non–determinism causes our rules to be non–confluent in general.
Example 4.1 Let t = f (x:A) and s = f (y:B) be two terms where x and y are variables of sorts A and B respectively, and the sort hierarchy is shown in Figure 5.
The typed definition of f is f : E → E. Starting from the initial configuration
z:E
⟨f (x:A)  f (y:B) | ∅ | id ⟩, we apply the inference rules of Figure 3 and the sub-
stitutions obtained by the lgg algorithm are θ1 = {z:E '→ f (z2:C), z1:E '→ z2:C} and θ2 = {z:E '→ f (z3:D), z1:E '→ z3:D}, where the lgg is either (z:E)θ1 = f (z2:C) or (z:E)θ2 = f (z3:D). Note that θ1 and θ2 are incomparable, so that we have two
posible lggs. The computation of both solutions is shown in Figure 4.
Before proving the correctness of the above inference system, we give an ab- stract characterization of the set of lggs of two terms t and t' such that [LS(t)] =
[LS(t')]. To simplify our notation, in what follows, we write t[s]p ,...,p  instead of
1	n
((t[s]p1 ) ··· )[s]pn .

Decompose		f ∈ (Σ ∪X ) ∧ f : [s1] × ... × [sn] → [s]	
x:[s]
⟨f (t1,..., tn)    f (s1,..., sn) ∧ C | S | θ⟩→ 
x1:[s1]	xn:[sn]

⟨t1
	s1 ∧ ... ∧ tn
	sn ∧ C | S | θσ⟩

where σ = {x:[s] '→ f (x1:[s1],..., xn:[sn])}, x1:[s1],..., xn:[sn] are fresh variables, and n ≥ 0


Solve
root(t) /≡ root(t') ∧ s' ∈ LUBS(LS(t), LS(t')) ∧ ∄y ∄s'' : t
y:s''
  t' ∈ S

x:[s]
⟨t    t' ∧ C | S | θ⟩→ ⟨C | S ∧ t
z:s'
  t' | θσ⟩

where σ = {x:[s] '→ z:s'} and z:s' is a fresh variable.
Recover	root(t) /≡ root(t')

x:[s]	y:s'
⟨t    t' ∧ C | S ∧ t   t' | θ⟩→ ⟨C | S ∧ t
y:s'
  t' | θσ⟩

where σ = {x:[s] '→ y:s'}
Figure 3. Rules for order–sorted least general generalizations.


lgg(f (x:A),f (y:B))
↓ Initial Configuration
z:E
⟨f (x:A)   f (y:B) |∅| id⟩
↓ Decompose




z2 :C
⟨x:A
z1 :E
  y:B |∅| {z:E '→ f (z1:E)}⟩
( Solve 
z3 :D

⟨∅ | x:A
   y:B | {z:E '→ f (z2:C), z1:E '→ z2:C}⟩ ⟨∅ | x:A
   y:B | {z:E '→ f (z3:D), z1:E '→ z3:D}⟩



Figure 4. Computation trace for order–sorted generalization of terms f (x) and f (y)

Figure 5. Sort hierarchy

Definition 4.2 Given terms t and t' such that [LS(t)] = [LS(t')], let (u1, v1),..., 
(uk, vk) be the conflict pairs of t and t', and for each such conflict pair (ui, vi),
let pi ,..., pi	be the corresponding conflict positions, and let [si] = [LS(ui)] =
1	ni
[LS(vi)].	We define the term lgg•(t, t') = ((t[x1:[s1]]p1,...,p1 ) ··· )[xk:[sk]]pk,...,pk ,
1	n1	1	nk
where x1:[s1],..., xk:[sk] are fresh variables. Furthermore, we define


Spec(t, t')= {ρ | Dom(ρ)= {x1:[s1],..., xk:[sk]}∧∀1 ≤ i ≤ k, ρ(xi:[si]) = xi:s' ∧ s' ∈ LUBS(LS(ui), LS(vi))}
i	i
where all the xi:s' are fresh variables, and, finally, lgg(t, t') = {lgg•(t, t')ρ | ρ ∈
Spec(t, t')}.
Lemma 4.3 Given terms t and t' such that [LS(t)] = [LS(t')], lgg•(t, t') is a gen- eralization of t and t' and lgg(t, t') provides a complete minimal set of lggs.
We provide some auxiliary notions and lemmas.
Lemma 4.4 Given terms t and t' such that [s] = [LS(t)] = [LS(t')], and a fresh
x:[s]	z
variable x:[s] such that ⟨t   t' | ∅ | id⟩ →∗ ⟨∅ | S | θ⟩, a constraint u  v is in S iff
there exists a conflict position p of t and t' such that t|p = u and t'|p = v, and there exist a variable name y and a sort s ∈ LUBS(LS(u), LS(v)) such that z = y:s.
A substitution δ is called downgrading if each binding is of the form x:s '→ x':s', where x and x' are variables and s' ≤ s.
Lemma 4.5 Given terms t and t' such that [s] = [LS(t)] = [LS(t')], and let
x:[s]
lgg•(t, t'). Then, for all S and θ such that ⟨t    t' | ∅ | id⟩ →∗ ⟨∅ | S | θ⟩, there
exists a downgrading substitution δ such that lgg•(t, t')δ = (x:[s])θ.
Theorem 4.6 Given terms t and t' such that [s] = [LS(t)] = [LS(t')], and a fresh
x:[s]
variable x:[s], u ∈ lgg(t, t') is a lgg of t and t' if and only if ⟨t    t' |∅| id⟩ →∗ ⟨∅ |
S | θ⟩ for some S and θ and there is a renaming ρ s.t. uρ = (x:[s])θ.
Proof We reason by contradiction. Both cases if and only if are similar and we provide only the proof for the if case.
Let us assume some S and θ such that there are no u ∈ lgg(t, t') and renaming ρ s.t. uρ = (x:[s])θ. For all u ∈ lgg(t, t'), by Definition 4.2, lgg•(t, t') ≤ u with a downgrading substitution. By Lemma 4.5, lgg•(t, t') ≤ (x:[s])θ with a downgrading substitution. Let δ be the downgrading substitution such that lgg•(t, t')δ = (x:[s])θ. For all u ∈ lgg(t, t'), let δu be the downgrading substitution such that lgg•(t, t')δu =
u. Since there is no renaming between (x:[s])θ and u and both have a downgrading substitution with lgg•(t, t'), there must be a binding x:s '→ x':s' in δ and a binding x:s '→ x'':s'' in δu s.t. either s' < s'', s'' < s', or [s'] /= [s'']. But the three possibilities are impossible by definition, since s' < s'' contradicts the idea that u is a lgg, s'' < s' contradicts Lemma 4.4, and [s'] /= [s''] contradicts both that u is a lgg and Lemma
4.4.	 

Conclusions and Future Work
We have presented an order–sorted generalization algorithm that computes a mini- mal and complete set of least general generalizations for two terms. Our algorithm is directly applicable to any many-sorted, and order-sorted declarative language

and reasoning system (and also, a fortiori, to untyped languages and systems which have only one sort). However, several such languages – such as ASF+SDF, OBJ, Cafe-OBJ, Elan, and Maude –, as well as various theorem proving systems, also support built–in reasoning modulo frequently occurring equational axioms such as associativivty, commutativity and identity. It would therefore be highly desirable to support order–sorted generalization modulo such equational theories. In [2], we have developed a modular algorithm for a parametric family of commonly occurring equa- tional theories, namely, for all theories (Σ, E) such that each binary function symbol f ∈ Σ can have any combination of associativity, commutativity, and identity ax- ioms. It would be very useful to combine the order–sorted and the E–generalization inference systems into a single generalization calculus supporting both types and equational axioms. However, this combination seems to us non–trivial and is left for future work.
In our own work, we plan to extend the current order-sorted, syntactic general- ization algorithm presented here to an order–sorted, equational one as a key com- ponent of a narrowing-based partial evaluator (PE) for programs in order-sorted rule-based languages such as OBJ, Cafe-OBJ, and Maude. This will make avail- able for such languages useful narrowing–driven PE techniques developed for the syntactic setting in, e.g., [3,4]. We are also considering adding this generalization mechanism to an inductive theorem prover such a Maude’s ITP [10] to support automatic conjecture of lemmas. This will provide a first–order typed analogue of similar automatic lemma conjecture mechanisms in first–order untyped inductive theorem provers such as Nqthm [8] and its ACL2 successor [16].

References
H. A¨ıt-Kaci and Y. Sasaki, An Axiomatic Approach to Feature Term Generalization. Proc. 12th European Conf. on Machine Learning, EMCL ’01, pages 1–12. Springer-Verlag, 2001.
M. Alpuente, S. Escobar, J. Meseguer, and P. Ojeda. A Modular Equational Generalization Algorithm. Proc. 18th Int’l Symp. on Logic-Based Program Synthesis and Transformation, LOPSTR 2008, pages 151–165, 2008.
M. Alpuente, M. Falaschi, and G. Vidal. Partial evaluation of functional logic programs. ACM Trans. Program. Lang. Syst., 20(4):768–844, 1998.
M. Alpuente, S. Lucas, M. Hanus, and G. Vidal. Specialization of functional logic programs based on needed narrowing. TPLP, 5(3):273–303, 2005.
F. Baader and W. Snyder. Unification theory. In Handbook of Automated Reasoning. Elsevier, 1999.
J.A. Bergstra, J. Heering, and P. Klint. Algebraic Specification. ACM Press, 1989.
P. Borovansky´, C. Kirchner, H. Kirchner, and P.-E. Moreau. ELAN from a rewriting logic point of view. Theor. Comput. Sci., 285:155–185, 2002.
R. Boyer and J. Moore. A Computational Logic. Academic Press, 1980.
M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and C. Talcott. All About Maude
- A High-Performance Logical Framework. Springer-Verlag New York, Inc., Secaucus, NJ, USA, 2007.
M. Clavel and M. Palomino. The ITP tool’s manual. Universidad Complutense, Madrid, April 2005,
http://maude.sip.ucm.es/itp/.
R. Diaconescu and K. Futatsugi. CafeOBJ Report, volume 6 of AMAST Series in Computing. World Scientific, AMAST Series, 1998.


J. P. Gallagher. Tutorial on specialisation of logic programs. In Proc. 1993 ACM SIGPLAN Symp. on Partial evaluation and Semantics-based Program Manipulation, PEPM ’93, pages 88–98, New York, NY, USA, 1993. ACM.
J. Goguen, T. Winkler, J. Meseguer, K. Futatsugi, and J.-P. Jouannaud. Introducing OBJ. In Software Engineering with OBJ: Algebraic Specification in Action, pages 3–167. Kluwer, 2000.
G. Huet. Resolution d’Equations dans des Langages d’Order 1, 2,. . . ,ω. PhD thesis, Univ. Paris VII, 1976.
J.-P. Jouannaud and C. Kirchner. Solving equations in abstract algebras: A rule-based Survey of Unification. In Computational Logic - Essays in Honor of Alan Robinson, pages 257–321. MIT Press, 1991.
M. Kaufmann, P. Manolios, and J.S Moore. Computer-Aided Reasoning: An Approach. Kluwer, 2000.
J.-L. Lassez, M. J. Maher, and K. Marriott. Unification Revisited. In J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 587–625. Morgan Kaufmann, Los Altos, Ca., 1988.
A. Martelli and U. Montanari. An efficient unification algorithm. Transactions on Programming Languages and Systems, 4(2):258–282, 1982.
J. Meseguer. Conditioned rewriting logic as a united model of concurrency. Theor. Comput. Sci., 96(1):73–155, 1992.
J. Meseguer. Membership algebra as a logical framework for equational specification. In Proc. WADT’97, pages 18–61, 1997.
J. Meseguer, J. Goguen, and G. Smolka. Order-sorted unification. J. Symbolic Computation, 8:383–413, 1989.
S. Muggleton. Inductive Logic Programming: Issues, Results and the Challenge of Learning Language in Logic. Artif. Intell., 114(1-2):283–296, 1999.
B. Østvold. A functional reconstruction of anti-unification. Technical Report DART/04/04, Norwegian Computing Center, 2004. Available at http://publications.nr.no/nr-notat-dart-04-04.pdf.
F. Pfenning. Unification and anti-unification in the calculus of constructions. In Proceedings, Sixth Annual IEEE Symposium on Logic in Computer Science, 15-18 July, 1991, Amsterdam, The Netherlands, pages 74–85. IEEE Computer Society, 1991.
G.D. Plotkin. A note on inductive generalization. In Machine Intelligence, volume 5, pages 153–163. Edinburgh University Press, 1970.
G.D. Plotkin. A structural approach to operational semantics. J. Log. Algebr. Program., 60-61:17–139, 2004.
J. Reynolds. Transformational systems and the algebraic structure of atomic formulas. Machine Intelligence, 5:135–151, 1970.
M. Schmidt-Schauss. Unification in many-sorted equational theories. Proc. 8th Int’l Conf. on Automated Deduction. Springer LNCS 230: 538–552, 1986.
J.H. Siekmann. Unification Theory. Journal of Symbolic Computation, 7:207–274, 1989.
G. Smolka, W. Nutt, J. Goguen, and J. Meseguer. Order-sorted equational computation. In Maurice Nivat and Hassan A¨ıt-Kaci, editors, Resolution of Equations in Algebraic Structures, volume 2, pages 297–367. Academic Press, 1989.
TeReSe, editor. Term Rewriting Systems. Cambridge University Press, Cambridge, 2003.
