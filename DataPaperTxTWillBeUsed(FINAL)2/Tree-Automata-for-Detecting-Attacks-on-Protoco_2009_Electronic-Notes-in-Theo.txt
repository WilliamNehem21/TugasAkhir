

Electronic Notes in Theoretical Computer Science 239 (2009) 57–72
www.elsevier.com/locate/entcs

Tree Automata for Detecting Attacks on Protocols with Algebraic Cryptographic Primitives

Yohan Boichut1
Laboratoire d’Informatique Fondamentale d’Orléans Université d’Orléans
France

Pierre-Cyrille Héam2
LSV CNRS / INRIA / ENS Cachan Cachan, France

Olga Kouchnarenko3
INRIA-CASSIS LIFC
Besançon, France


Abstract
This paper extends a rewriting approximations-based theoretical framework in which the security problem – secrecy preservation against an active intruder – may be semi-decided through a reachability analysis. In a recent paper, we have shown how to semi-decide whether a security protocol using algebraic properties of cryptographic primitives is safe. In this paper, we investigate the dual - insecurity - problem: we explain how to semi-decide whether a protocol using cryptographic primitive algebraic properties is unsafe. This improvement offers us to draw automatically a complete diagnostic of a security protocol with an unbounded number of sessions. Furthermore, our approach is supported by the tool TA4SP successfully applied for analysing the NSPK-xor protocol and the Diﬃe-Hellman protocol.
Keywords: Security protocol, algebraic properties, automatic approximation. a a This work is supported by the french project ACI SATIN.



1 Email: yohan.boichut@univ-orleans.fr
2 Email: pcheam@lsv.ens-cachan.fr
3 Email: Olga.Kouchnarenko@lifc.univ-fcomte.fr

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.030

Introduction




Security protocols are part of systems for which the security problem is in general undecidable. Approximations and abstractions represent a well-suited alternative for verifying them in practice. A lot of investigations have been carried out on this topic [2,13,8,19,21,24,20,23].
An often encountered difficulty is about encoding with non-atomic keys. A non- atomic key is a key established in several steps from several data. This topic comes close to the handling of operators with algebraic properties. On a strongly typed model (model in which the structure of a compound key is clearly specified), most of the developed methods are able to perform a protocol analysis. Unfortunately a secure strongly typed model is not a secure model because of type confusing attacks.
That is why our previous contribution [6] has extended the verification method in [5] in order to verify – without typing – security protocols bringing into play operators with algebraic properties. This improvement has made the computation of sound over-approximations of the intruder knowledge possible. Consequently, the safety, i.e., the secrecy preservation on protocols using algebraic properties of the exclusive or (xor) operator or the exponential (exp) operator can be established automatically. However, there is a lack of the attack detection, i.e. of showing that a protocol is unsafe.
This paper extends an expert-human guided approximation technique introduced in [18] for left-linear term-rewriting systems. We show how this approach may be extended to a suitable sub-class of non-left-linear term-rewriting systems. The main contribution of this paper consists of showing the feasibility of the automatic unsafety verification for protocols when 1) the number of sessions is unbounded, and 2) the cryptographic primitives use algebraic operators properties. We propose sufficient conditions on term rewriting systems (TRSs for short), under which attack detection on such protocols becomes possible.
To illustrate the contributions, experiments on the detection of attacks against protocols with the primitives using xor or exp (xored and exped protocols, for short), are reported. Moreover, to illustrate used notions, many explicit examples have been introduced.
Structure of the paper The paper is organised as follows. After giving prelim- inary notions on tree automata and TRSs, we introduce in Section 2 a substitution depending on rules of a TRS, and a notion of compatibility between such substitu- tions and finite tree automata, both suitable for reachability analysis in rewriting with non left-linear TRSs. In Section 3, we present the extension of [6] dealing with under-approximations. Finally, before concluding, we give in Section 4 a brief overview of related works, and we explain how to apply the obtained new results to analyse xored or exped protocols.

Background and Notation
In this section basic notions on finite tree automata, term rewriting systems and approximations are recalled. The reader is referred to [10] for more detail.

Notation
Given the set N of natural integers, N∗ denotes the finite strings over N. Let F be a finite set of symbols with their arities. The set of symbols of F of arity i is denoted Fi. Let X be a finite set whose elements are variables. We assume that X ∩ F = ∅. A finite ordered tree t over a set of labels (F, X ) is a function from a prefix-closed set Pos(t) ⊆ N∗ to F ∪ X . A term t over F ∪ X is a labeled tree whose domain Pos(t) satisfies the following properties: Pos(t) is non-empty and prefix closed, for each p ∈ Pos(t), if t(p) ∈ Fn (with n /= 0), then {i | p.i ∈ Pos(t)} = {1,... , n} and, for each p ∈ Pos(t), if t(p) ∈ X or t(p) ∈ F0, then {i | p.i ∈ Pos(t)} = ∅. Each element of Pos(t) is called a position of t. For each subset K of X ∪ F and each term t we denote by PosK(t) the subset of positions p’s of t such that t(p) ∈ K. Each position p of t such that t(p) ∈ F, is called a functional position. The set of terms over (F, X ) is denoted T (F, X ). A ground term is a term t such that Pos(t)= PosF (t) (i.e. such that PosX (t)= ∅). The set of ground terms is denoted T (F). A subterm t|p of t ∈ T (F, X ) at position p is defined by: Pos(t|p)= {i | p.i ∈ Pos(t)} and, For all j ∈ Pos(t|p), t|p(j)= t(p.j). We denote by t[s]p the term obtained by replacing in t the subterm t|p by s.
Example 2.1 Let f, g, a ∈ F be functional symbols such that f ∈ F2, g ∈ F1 and a ∈ F0. Let x ∈ X be a variable. Let t be a term of T (F, X ) such that t = f (a, g(x)), thus Pos(t) = {ϵ, 1, 2, 2.1}, PosF (t) = {ϵ, 1, 2}, t(1) = a, t(2) = g,
t(ϵ)= f , t|1 = a, t|2 = g(x), t|2.1 = x, Pos{x}(t)= {2.1} and t[a]2 = f (a, a).
For all sets A and B, we denote by Σ(A, B) the set of functions from A to B. If σ ∈ Σ(X , B), then for each term t ∈ T (F, X ), we denote by tσ the term obtained from t by replacing for each x ∈ X , the variable x by σ(x). A term rewriting system R over T (F, X ) is a finite set of pairs (l, r) from T (F, X ) ×T (F, X ), denoted l→r, such that the set of variables occurring in r is included in the set of variables of l. A TRS is left-linear if for each rule l→r, every variable occurs at most once in l. For
'
each ground term t, we denote by R(t) the set of ground terms t such that there
exist a rule l → r of R, a function μ ∈ Σ(X , T (F)) and a position p of t satisfying

'
t|p = lμ and t
= t[rμ]p. The relation {(t, t ) | t
∈ R(t)} is classically denoted →R.

If t→Rt' for t, t' ∈ T (F), then t is a rewriting predecessor of t' and t' is rewriting successor of t. For each set of ground terms B we denote by R∗(B) the set of ground terms related to an element of B modulo the reflexive-transitive closure of →R.
A tree automaton A is a tuple (Q, Δ,F ), where Q is the set of states, Δ the set of transitions, and F the set of final states. Transitions are rewriting rules of the form f (q1,... , qk)→q, where f ∈ Fk and the qi’s are in Q. A term t ∈ T (F) is accepted or recognised by A if there exists q ∈ F such that t→∗ q (we also write t→∗ q). The set of terms accepted by A is denoted L(A). For each state q ∈ Q, we

write L(A, q) for the tree language L((Q, Δ, {q})). A tree automaton is finite if its set of transitions is finite (see Example 2.2).
Example 2.2 Let A = (Q, Δ,F ) be a tree automaton such that F = {f, g, a}
with f  ∈ F2, g  ∈ F1 and a ∈ F0, Q = {qf , q1}, F  = {qf } and Δ =
{f (q1, q1)→qf , a→q1, g(q1)→q1}. Then, L(A, q1)= {g∗(a)} and L(A, qf )= L(A)= 
{f (g∗(a), g∗(a))}.
In [6], a new kind of substitution has been introduced. We recall this definition below. Notice that the domain of these substitutions is not the set of variables anymore, but a set of positions. Thus, given a variable, this allows a symbolic representation of its values.
Definition 2.3 Let R be a term rewriting system, Q a set of states and l → r ∈ R. An (l → r)-substitution is a function from PosX (l) into Q.
We then adapt this kind of substitution to the rewriting framework in the follow- ing way. Let l→r ∈ R and σ be an (l → r)-substitution. We denote by lσ the term of T (F, Q) such that Pos(lσ) = Pos(l), and for each p ∈ Pos(l), if p ∈ PosX (l) then lσ(p) = σ(p), otherwise lσ(p) = l(p). Similarly, we denote by rσ the term of T (F, Q) defined by: Pos(rσ) = Pos(r) and, for each p ∈ Pos(r), if p ∈/ PosX (r)

'	'
then rσ(p)= r(p) and rσ(p)= σ(p ) otherwise, where p
= min Posr(p)(l) (positions

are lexicographically ordered). For a given tree automaton, a particular class of
(l → r)-substitutions can be drawn.
Definition 2.4 Let A be a finite tree automaton.	We say that an (l → r)- substitution σ is A-compatible if for each x ∈ Var(l),

 

p∈Pos{x}(l)
L(A, σ(p)) /= ∅.

Example 2.5 Let Aexe = ({q0, qf }, Δexe, {qf }) with the set of transitions Δexe =
{A→q0, A→qf ,f (qf , q0)→qf , h(q0, q0)→q0}. Let Rexe = {f (x, h(x, y))→h(A, x)}. The automaton Aexe recognizes the set of trees such that every path from the root to a leaf is of the form f ∗h∗A. Let us consider the substitution σexe defined by σexe(1) = qf , σexe(2.1) = q0 and σexe(2.2) = q0. The tree t = A can be reduced to qf and belongs to L(A, σexe(1)). Furthermore t→q0, so t ∈ L(A, σexe(2.1)). Therefore σexe is A-compatible.
Finally, the last notion we introduce is the definition of an approximation func- tion.
Definition 2.6 Let A be a finite tree automaton. An approximation function (for A) is a function associating with each tuple (l → r, σ, q), where l → r ∈ R, σ is an A-compatible (l → r)-substitution and q a state of A, a mapping from Pos(r) to Q.
Example 2.7 Consider the automaton Aexe, the term rewriting system Rexe and the substitution σexe defined in Example 2.5. For σexe, an approximation function

γexe may be defined by:
γexe(l→r, σexe, qf )(ε)= q1,  γexe(l→r, σexe, qf )(1) = q0,  γexe(l→r, σexe, qf )(2) = q1.
To totally define γexe, the other (finitely many) Aexe-compatible substitutions should be considered too.
This notion is very useful for reachability analysis in rewriting with non left-linear TRSs as shown in the following section.

Reachability Analysis in Rewriting with non Left-linear TRSs
This section recalls the approximation-based framework we have been developing, and explains our objectives from a formal point of view.
Given a tree automaton A and a TRS R (for several classes of automata and TRSs), the tree automata completion [19,18] algorithm computes a tree automaton Ak such that L(Ak)= R∗(L(A)) when it is possible (for the classes of TRSs covered by this algorithm see [18]), and such that L(Ak) ⊇ R∗(L(A)) otherwise.
The tree automata completion works as follows. From A = A0 completion builds a sequence A0, A1,... , Ak of automata such that if s ∈ L(Ai) and s→Rt then t ∈ L(Ai+1). If there is a fix-point automaton Ak such that R∗(L(Ak)) = L(Ak), then one has L(Ak)= R∗(L(A0)) (or L(Ak) ⊇ R∗(L(A)) if R is not in one class of [18]). In particular, for non left-linear TRSs, the completion is not sound. Indeed, if the completion converges towards a fix-point automaton Ak, L(Ak) is not necessarily either R∗(L(A)) or a super set of R∗(L(A)).
In [6], the completion procedure has been improved so that the method is sound for non left-linear TRSs. This technique is introduced below. As mentioned previ- ously, the completion builds a sequence A0, A1,... , Ak of tree automata such that the set of terms reachable in one step of rewriting from L(Ai) are in L(Ai+1). To build Ai+1 from Ai, we achieve a completion step which consists of finding critical pairs between →R and →Ai . Formally, for an approximation function γ, a rule l→r ∈ R and an Ai-compatible (l → r)-substitution σ, a critical pair is an instance

lσ of l such that there exists q ∈ Q satisfying lσ→∗
i
q and rσ / →∗
i
q. For every

critical pair, such that lσ→∗
i
q and rσ / →∗
i
q, detected between R and Ai, Ai+1 is

built by adding new transitions to Ai, so that it recognizes rσ in q, i.e. rσ→Ai+1 q.

Before giving a definition of a completion step (Def. 2.9), we introduce a normalisa- tion step described in Definition 2.8. Note that the transition rσ→q is not necessarily a transition of the form f (q1,... , qn)→q' and so has to be normalized first. For ex- ample, to normalize a transition of the form f (g(a), h(q'))→q, we need to find some states q1, q2, q3 and replace the previous transition by a set of normalized transitions:
{a→q1, g(q1)→q2, h(q')→q3,f (q2, q3)→q}. The states used in a normalization step

do not grow on trees and it is of the approximation function γ concern to deliver them at each completion step. Formally,
Definition 2.8 Let A = (Q0, Δ, F0) be a finite tree automaton, γ be an approxima- tion function for A, l → r be a rule of R, σ be an A-compatible (l → r)-substitution, and q be a state of A. We denote by Normγ(l → r, σ, q) the following set of transi- tions, called normalization of (l → r, σ, q):
'
{f (q1,... , qk)→q |p ∈ PosF (r), r(p)= f,
'	'
q = q if p = ε otherwise q = γ(l → r, σ, q)(p)
qi = γ(l → r, σ, q)(p.i) if p.i ∈/ PosX (r),
'	'
qi = σ(min{p ∈ PosX (l) | l(p )= r(p.i)})otherwise}
The min is computed for the lexical order.
Notice that the set {p ∈ PosX (l) | l(p ) = r(p.i)} used in the above definition is not empty. Indeed, in a TRS, variables occurring in the right-hand side must, by definition, occur in the left-hand side too.
Definition 2.9 Let R be a TRS. Let A0 = (Q0, Δ0, F0) be a finite tree automaton and γ an approximation function for A0. The automaton Cγ(A0)= (Q1, Δ1, F1) is
defined by:
Δ1 = Δ0 ∪  Normγ(l → r, σ, q)
where the union involves all rules l → r ∈ R, all states q ∈ Q0, all A0-compatible

(l → r)-substitutions σ such that lσ→∗
q and rσ / →∗
q, F1 = F0	and Q1 =

Q0 ∪ Q2, where Q2 denotes the set of states occurring in left/right-hand sides of transitions of Δ1.
See Example 2.10 for an example of a completion step.
Example 2.10 [A completion step] Following Example 2.7, ε and 1 are the func-
'
tional positions of r = h(A, y). We set q of the definition to be equal to qf . Thus
Normγexe (l → r, σexe, qf ) is of the form {A→q?, h(q?, q??)→qf }. Since for r, the position 1 is a functional position and 2 is in PosX (r), we use the last line of the definition to compute q?? and q? is defined by the approximation function γexe. Finally we obtain:
Normγexe (l → r, σexe, qf ) = {r(1)→γexe(1), r(ε)(γexe(1), σexe(1))→qf }
= {A→q0, h(q0, qf )→qf }.
Consequently, the tree automaton resulting from a completion step on Aexe with
γexe and Rexe is Cγ(Aexe)= ({q0, qf }, Δexe ∪ {A→q0, h(q0, qf )→qf }, {qf }).
Notice that a new completion step could be performed on Cγ(Aexe). However, no transition would be added since no new critical pair would be detected. So, Cγ(Aexe) is the fix-point automaton. According to Theorem 2.11, every term reachable by rewriting from L(Aexe) are in the language of the fix-point automaton.
Following theorem was proved in [6].

Theorem 2.11 Let (An) and (γn) be respectively a sequence of finite tree automata and a sequence of approximation functions such that for each integer n, γn is an approximation function for An and An+1 = Cγn (An). If there exists a positive integer N, such that for every n ≥ N, An = AN , then R∗(L(A0)) ⊆ L(AN ).
From a verification point of view, this technique is very helpful. Indeed, for a system Σ whose transition relation is Δ, one specifies the initial configuration of Σ by a tree language E, and Δ by a TRS R. With a well-suited approximation function γ, an over-approximation of reachable configurations of Σ, denoted Eγ , can be computed. Finally, a set of bad configurations, denoted EBad, can be encoded with a tree language and if Eγ ∩ EBad is empty, then no bad configuration is reachable. In particular, in [6], we have used this technique for verifying security protocols bringing into play the xor operator (⊕). Note that the nilpotence property of ⊕ is specified with a non left-linear rule, i.e., x ⊕ x→0. The tree languages specify the intruder knowledge and the configurations of the network. The TRS specifies the protocol and the intruder abilities for decoding, coding, depairing messages. Thus, if a secret term t does not belong to an over-approximation of the knowledge that
the intruder might have, then t is actually secret.

Under-Approximations for non Left-linear TRSs
The over-approximation results in [6] do not provide a way to prove that a particular term is reachable: the method is not complete. This section adapts the means and extends the results in [6] to under-approximations computations. In the security protocol framework, computing under-approximations allows an under-estimation of the intruder knowledge, and thus secrecy flaws detection. Indeed, if a secret datum is in the intruder knowledge under-estimation, then the intruder actually knows this secret. The main idea (and problem) behind the under-approximations is that one wants the languages of computed tree automata to be in the set of terms reachable by rewriting . Having some conditions on the TRS makes it possible to control the completion, and proving that a term is actually reachable is then possible.
We define here γ to be an injective approximation function from R × (N∗ '→ Q) × N∗ ×Q into Q. Theorem 3.2 shows that with such an approximation function, an under-approximation of the set of reachable terms is possible. Before, Lemma
3.1 presents an intermediary result useful for proving Theorem 3.2: this result re- veals some features of terms recognised by Cγ(A) for which there exists a rewriting predecessor recognised by A. In the following, we introduce the notation NLV (t) which for a term t of T (F, X ), denotes the set of non-linear variables of t, i.e., the set of variables occurring at least twice within t.
Lemma 3.1 Let R be a right-linear TRS for which NLV (l) ∩ Var(r) = ∅ for all l→r ∈ R. Let A be the current tree automaton and Cγ(A) be the tree automaton obtained after one completion step with R and γ. If there exist a ground term t over F, a state q of A and a function τ from Pos(t) to Q such that t ∈ L(Cγ(A), q), t /∈ L(A, q) and τ satisfies the following conditions: (i) τ (ε)= q; (ii) for all p ∈ Pos(t),

t|p ∈ L(Cγ(A),τ (p)) and, (iii) for all p ∈ Pos(t) \ {ε}, if τ (p) is a state of A, then
t|p ∈ L(A,τ (p)). Then there exists t0 ∈ T (F) such that t0 ∈ L(A, q) and t0→Rt.
Proof To simplify the notation we denote by Δ1 the set of transitions of the au- tomaton Cγ(A), Δ0 the set of transitions of A and Q0 the set of states of A.
The proof consists of 1) the construction of a term s1 ∈ T (F, Q) such that

Δ1 s1→Normγ (l→r,σ,q)q,	(1)
the construction, by iterating a backward process, of a term s ∈ T (F, Q) such that



the proof that
∗	∗
Δ1	Normγ (l→r,σ,q)
q, and	(2)

∗	∗
Δ0	Normγ (l→r,σ,q)
q.	(3)

First, using (ii) at the position ε gives
t|ε→∗

τ (ε).

Since t = t|ε and since τ (ε)= q (by (i)), one has
∗
Δ1


Since t ∈ T (F) one has t /= q, and every derivation t→∗
q has the length one,

at least. Consequently, there exists s1 ∈ T (F, Q) such that
Δ1 s1→Δ1 q.
We now show by contradiction that the transition s1→q ∈/ Δ0. Suppose that

s1→q is a transition of Δ0. Then s1 ∈ T (F, Q0). Thus, using (iii), t→∗
s1→Δ0 q,

a contradiction ( t / →∗
q).

Therefore, the transition s1→q is in Δ1 \ Δ0. By definition of Δ1 (see Defini-

tion 2.9), there exist q , σ : PosX
Normγ(l→r, σ, q ) and
(l)∗ '→ Q and l→r ∈ R such that s1→
Cγ (A)q ∈

lσ→∗	'
(4)

Δ0 q .
'
Now by definitions of Normγ(l→r, σ, q ) and γ, each source state or target state of
'	'
a transition in Normγ(l→r, σ, q ) is either Q\Q0, or is equal to q . Since s1→Cγ (A)q ∈
'	'	'

Normγ(l→r, σ, q ), either q ∈ Q \ Q0, or q = q . Because q ∈ Q0, one has q = q
and


Δ1 s1→Normγ (l→r,σ,q)q.


We are done for (1). We now perform an iterative construction. If s1 ∈/ T (F, Q0), then there exists a position p of s1 such that s1(p) ∈ Q \ Q0. Thus s1(p) is of the

form s1(p)= γ(l→r, σ, q)(p). Since γ is injective, the only transition of Δ1 leading to s1(p) is
r(p)(γ(l→r, σ, q)(p.1),... , γ(l→r, σ, q)(p.l))→s1(p).
Consequently, the derivation t→∗ s1 has to conclude by
∗ s2→s1


where
So, one has
s2 = s1[r(p)(γ(l→r, σ, q)(p.1),... , γ(l→r, σ, q)(p.l))]p.

t→∗
s2→Norm (l→r,σ,q)s1→Norm (l→r,σ,q)q.

Δ1	γ	γ
Now, if s2 ∈/ T (F, Q0), the same construction can be iteratively applied to s2 and so on. Consequently, one can build a term s ∈ T (F, Q0) such that Pos(s)= Pos(r) and

∗	∗
Δ1	Normγ (l→r,σ,q)
q,	(5)

and for each position p of s such that s(p) ∈/ Q,
s(p)= r(p).	(6)
We are done for (2).
We can begin the last part of the proof. Let q1,... , qn be the states occurring in s by reading s from the left to the right. Let p1,... , pn be respectively the positions in s of states q1,... , qn. Notice that the backward construction of s is deterministic. Indeed every derivation from t to q can be split up to

Δ1	Normγ (l→r,σ,q)q.
It implies that for each qi, with i = 1,... , n, one has
qi = τ (pi).	(7)
At this stage, s is of the form rσ since γ is defined for every position of r. Now using (7) and the hypothesis iii), one has
t→Δ rσ→∗	q.
0	Normγ (l→r,σ,q)
The TRS R being right-linear with NLV (l) ∩ Var(r) = ∅ for each rule l→r of
R, one can built a substitution μ : PosX (l) '→ T (F) such that:
For p ∈ PosV ar(r)(l), one can set μ(p) = t' and t' = t|p' with p' ∈ Pos{l| }(r).

Moreover, since l|p ∈/ NLV (l), one obtains μ(p)= t'→∗
σ(p).

For p ∈ PosVar(l)\Var(r)(l), one can proceed in the following way:
if l(p) ∈ NLV (l) then one can set μ(p' ),... , μ(p' ) to t' where t' ∈ L(A0, σ(p' ))∩
1	1	1
... ∩ L(A0, σ(p' )) with {p' ,... , p' } = Pos{l(p)}(l).
n	1	n

Otherwise, one can set μ(p) toa term t' ∈ L(A0, σ(p)).
By this way, there exists t0 = lμ ∈ T (F) such that t0→∗

q and t0→Rt, proving

the lemma.	 

The following result shows that each term of the language Cγ(A0) is reachable by rewriting from A0 and using R.
Theorem 3.2 Let A0 = (Q0, Δ0, F0) be a finite tree automaton. Let R be a right- linear TRS. Given the approximation function γ defined at the beginning of Section 3, if for all l→r ∈ R, Var(r) ∩ NLV (l)= ∅ then L(Cγ(A0)) ⊆ R∗(L(A0)).
Proof Let Pn be the following proposition:
For all t ∈ L(Cγ(A0)), if there exists a function τ from Pos(t) to Q such that
τ (ε)= qf and for all p ∈ Pos(t),


∗
Cγ (A0)
τ (p)	and	t[τ (p)]p→∗	qf



and such that

|{p ∈ Pos(t) | τ (p) ∈ Q0 ∧ t|p / →∗

τ (p)}| = n,

then t ∈ R∗(L(A0)).
We prove that Pn is true for all n ≥ 0 by induction on n. To simplify notations,

let
NR(t, τ )= {p ∈ Pos(t) | τ (p) ∈ Q0 and t|p / →∗
τ (p)}.

[P0 :] Assume that t and τ satisfy the hypothesis on P0. We have |NR(t, τ )| = 0. In particular, ε /∈ NR(t, τ ). So, t = t|ε→A0 τ (ε)= qf . Since A0 and Cγ(A0) have the same set of final states, t ∈ L(A0).
[Pn =⇒ Pn+1:] Assume that Pn is true for n ≥ 0 and that t and τ satisfy the hypothesis on Pn+1. Since NR(t, τ ) is non-empty, let p be a maximal element of NR(t, τ ) (for the lexicographical order). Then, by maximality of p, one can

apply Lemma 3.1 to t|p. Thus, there exists t0 ∈ T (F) such that t0→∗
τ (p) and

t0→Rtp. Therefore, there exists a function τ1 from Pos(t0) into Q0 such that
'	∗	'	'	∗
for all p , t0→A0 τ1(p ), t[τ1(p )]p' →Cγ (A0 )τ (p). We define the function τ2 from
Pos(t[t0]p) to Q as follows.
'	'	'
If p is not a prefix of p , then τ2(p )= τ (p ),
'	'
Otherwise, if p is of the form p.u, then τ2(p )= τ1(u).
By construction, t[t0]p→Rt and |NR(t[t0]p, τ2)| = n − 1.  Thus, by induction,
t ∈ R∗(L(A0)).
 
Let C(n)(A ) be the tree automaton obtained after n completion steps performed
γ	0
from A0 by using the TRS R and the approximation function γ. Finally, Proposition
3.3 shows that the approximation function γ provides a sound under-approximation of reachable terms.
Proposition 3.3 If R is right-linear and for all l→r ∈ R, NLV (l) ∩ Var(r) = ∅
then for all n ≤ 0, L(C(n)(A )) ⊆ R∗(L(A )), L(C(n)(A )) ⊆ L(C(n+1)(A )) and
γ	0	0	γ	0	γ	0
L(C(n)(A )) = R∗(L(A )).

Proof By definition C(n+1)(A ) = g (C(n)(A ))). Consequently, the set of transi-
γ	0	γ	γ	0
tions of C(n)(A ) is included in the transitions set of C(n+1)(A ). Thus L(C(n)(A )) ⊆
γ	0	γ	0	γ	0
L(C(n+1)(A )).
γ	0
Now, usinga Lemma 2 of [6] leading to Theorem 2.11, one has for all n ≥ 1,
R(L(C(n)(A0))) ⊆ L(C(n+1)(A0)).
γ	γ
Consequently, by a direct induction,
R≤n(L(A0)) ⊆ L(C(n+1)(A0)).


It implies that
R∗(L(A0)) ⊆   L(C(n)(A0)).

n≥0
One can prove that for all n ∈ N, L(C(n)(A )) ⊆ R∗(L(A )) by a direct induction
γ	0	0
on n using Theorem 3.2, and we are done.	 
At this point, we have developed theoretical frameworks which lead either to over-approximations of the set of reachable terms in general, or to its under- approximations under additional conditions on TRSs. The obtained results allow us to apply the approximation-based methods to system verification as presented in the next section.

Experiments and Related Works
With the extension brought for the under-approximations computation, we are now able to detect whether a protocol using algebraic properties of cryptographic prim- itives is flawed or not. Actually, while the protocol is flawed in the rewriting model for any number of sessions, in general, it turns out to be a real attack against the protocol when an attack concerns a long term secret between two honnest agents. We consider a long term secret to be a secret which is never revealed, even in fu- ture sessions. In this section, we present some experimental results obtained on two protocols, well-known to be flawed, which are NSPK-xor and the key establish- ment à la Diffie-Helmann protocol. The technique presented in this paper has been implemented in the tool TA4SP.
TA4SP for Attack Detection
This section details two protocols, well-known to be flawed, which are NSPK-xor and the key establishment à la Diffie-Helmann protocol in its simplest form. The notations used are the following: X -> Y: Z specifies that X sends the message Z to Y, X.Y is the concatenation of data X and Y, and {X}Y (or {X}_Y) is the encoding of the message X by the message Y. Moreover, data Na, Nb, ni(Na) and ni(Nb) with i being an integer, are fresh random numbers, also called a nonces. Finally, the last concept to know concerns the keys, which can be public, private or symmetric. To

a public key Pka is associated a private key Prka. A message encoded by one can be decoded by the other: {{M}Pka}Prka = {{M}Prka}Pka = M. A symmetric key K can decode a message encoded by itself: {{M}K}K = M.
The NSPK-xor Protocol is composed of three steps so that each participant can authenticate the other. First, the agent A sends the message {Na.A}KB to the agent B. Second, B sends {Nb.Na ⊕ B}KA to A. Finally, A sends {Nb}KB to B as a confirmation. Using TA4SP, we obtain in 71.03 seconds that the protocol does not preserve the secrecy of the data Nb against an intruder. Thanks to the AVISPA toolset, one can use one of three other tools (in this case CL-AtSe [25]) for exhibiting the following attack trace.
i -> (a,6):  start
(a,6) -> i:  {n9(Na).a}_ki

i -> (a,3):  start
(a,3) -> i:  {n1(Na).a}_kb

i -> (b,4):  {xor(i,xor(b,n9(Na))).a}_kb
(b,4) -> i:  {n5(Nb).xor(i,n9(Na))}_ka

i -> (a,6):  {n5(Nb).xor(i,n9(Na))}_ka
(a,6) -> i:  {n5(Nb)}_ki

At steps 1. and 2. of the attack, the agent a initiates a session with the intruder by sending the message {n9(Na).a}_ki to the intruder where n9(Na) is a nonce generated by a and ki is the public key of the intruder. At steps 3. and 4., the agent a initiates a session with the agent b. The intruder composes at step 5. the message xor(i,xor(b,n9(Na))).a and sends it to b after having encoded it with the public key of the agent b. The agent b deduces at step 6. that this message comes from the agent a thanks to the identity occurring in the received message. Moreover, b considers the message xor(i,xor(b,n9(Na)))’ as the nonce generated by a. Consequently, b performs the second step of the protocol. At step
6. of the attack trace, b composes n5(Nb).xor(b,xor(i,xor(b,n9(Na)))) which is equivalent to n5(Nb).xor(i,n9(Na)) after considering the algebraic properties of
⊕ (xor operator). Then, he sends it to a after having encoded it with the public key of a. The agent b declares also the nonce n5(Nb) as a secret shared between himself and the agent a. But, according to the point of view of the agent a, the message {n5(Nb).xor(i,n9(Na))}_ka should come from i (the intruder) because n5(Nb) identifies the agent i for a. According to his deduction, the agent a sends
{n5(Nb)}_ki to the intruder. Finally, the latter can deduce n5(Nb) which is a secret supposed to be shared between b and a.
The Diffie-Helmann Protocol is a key establishment protocol between two agents A and B. The simplest version of this protocol is composed of three steps. At step 1, A generates the nonce Na and computes exp(G, Na) (standing for GNa) where G is a number known by every agents. Thus A sends the message exp(G, Na) to the agent B. At step 2, the agent B generates also a number Nb and computes on the one hand exp(G, Nb) and on the other hand K = exp(X, Nb) where X is the message received i.e. exp(G, Na). The former is sent to A and the latter stands for the symmetric key shared between A and B. As soon as B receives the message

exp(G, Nb) from A, (s)he then computes exp(exp(G, Nb),Na) and thus considers it as the symmetric key shared with A. Indeed, according to the algebraic properties of the exponentiation, K = exp(exp(G, Na),Nb) = exp(exp(G, Nb),Na). Finally, the message {secret}K is sent by A to B in which secret is a datum initially known uniquely by A and B. Using TA4SP this protocol has been shown as being flawed in
24.73 seconds. For this protocol, a MIM (Man in the Middle) attack is known and is detailed below with the attack trace outputted with the AVISPA tool-set.
i -> (a,3):  start
(a,3) -> i:  exp(g,n1(Na))

i -> (b,4):  g
(b,4) -> i:  exp(g,n5(Nb))

i -> (a,3):  g
(a,3) -> i:  {secab}_(exp(g,n1(Na)))

i -> (b,4):  {secab}_(exp(g,n5(Nb)))
(b,4) -> i:  ()
Roughly, the intruder establishes two keys: exp(exp(g,n1(Na)),g) with a at steps 2 and 5 and exp(exp(g,n5(Nb)),g) with b at steps 3 and 4. At step 6, the agent a sends the secret data to b with the key unfortunately shared with the intruder. The intruder then extracts the secret data and forwards it to b with the other key. Finally, b is persuaded that this message comes from a.

Related Work
In [12], the authors study the IBM 4758 CCA (Common Cryptographic Architecture) API which has been shown as flawed in [7]. In response to this flaw, IBM then has proposed three recommendations designed to prevent it. The formalisation of these recommendations leads Cortier et al. to draw up a particular class of security protocols using the operator ⊕ for which the secrecy problem is decidable with an unbounded number of sessions. They have then shown that any one of the three recommendations is sufficient to secure the API against a Dolev-Yao intruder [16].
In the recent survey [11], the authors give an overview of the existing methods in formal approaches to analyse cryptographic protocols. In the same work, a list of some relevant algebraic properties of cryptographic operators is established, and for each of them, the authors provide examples of protocols or attacks using these properties. This survey lists two drawbacks with the recent results aiming at the analysis of protocols with algebraic properties. First, in most of the papers a partic- ular decision procedure is proposed for a particular property. Second, the authors emphasise the fact that the results remain theoretical, and very few implementations automatically verify protocols with algebraic properties.
In [22] it has been shown that using equational tree automata under associativity and/or commutativity is relevant for security problems of cryptographic protocols with an equational property. For protocols modeled by associative-commutative TRSs, the authors announce the possibility for the analysis to be done automatically thanks to the tool ACTAS manipulating associative-commutative tree automata and using approximation algorithms. However, the engine has still room to be modified and optimised to support an automated verification.

The Proverif tool [2] allows an unbounded number of sessions but – like in our models – abstractions are performed on fresh data and thus false attacks can be de- tected. Moreover, in [3], the authors note that their technique does have limitations, and in particular, it does not apply to some equational theories.
The recent Scyther tool [14] can verify protocols with an unbounded number of sessions and nonces. It can handle verification of complex authentication properties, handle non-atomic keys, and generate correct attacks. A performance comparison between Scyther and a number of other tools has been detailed in [15]. Notice that
[15] reports on a set of protocols that excludes protocols using algebraic properties.
One of the new features of the Maude-NPA tool is that it allows to equation- ally reason about security when facing attempted attacks on low-level algebraic properties of the functions used in a protocol such as, for example, associativity- commutativity, Boolean theory, and some forms of modular exponentiation [17]. The Maude-NPA tool follows an approach similar to that of OFMC since the au- thors consider depth parameters for unification problems in some equational theories. However, the Maude-NPA tool needs the help of expert users.


Conclusion
The main purpose of this paper is to show that the symbolic approximation-based approach we have been developing is well-adapted for detecting attacks on protocols using algebraic properties while considering an unbounded number of sessions. In- deed, the automatically generated symbolic under-approximation function enables us 1) an automated normalisation of transitions, and 2) an automated completion procedure within the set of reachable terms.
With this extension our approximation-based framework proposes verification methods using either over-approximations of the set of reachable terms in general, or its under-approximations under additional conditions on TRSs. The contributions of the paper have been integrated into the push-button tool TA4SP [1] successfully applied for analysing the NSPK-xor protocol and the Diffie-Hellman protocol. Let us remark that TA4SP is used for protocols specified in the standard High Level Protocol Specification Language (HLPSL) [9]. This language is known to be suitable for industrial users.
Future development concerns implementation optimisation. We intend to in- vestigate further algebraic properties that can be handled in practice. In this di- rection, we project to develop a theoretical framework in order to compute under- approximations without the right-linearity condition required Theorem 3.2. A so- lution could be close to the one we have proposed in [4] in order to relax the left- linearity condition for a significant class of TRSs.
This may for example provide an approximation-based approach for detecting attacks on security protocols with cryptographic primitives using the homomorphism property [11].

References
A. Armando, D. Basin, Y. Boichut, Y. Chevalier, L. Compagna, J. Cuellar, P. Hankes Drielsma, P.-C. Héam, O. Kouchnarenko, J. Mantovani, S. Mödersheim, D. von Oheimb, M. Rusinowitch,
J. Santos Santiago, M. Turuani, L. Viganò, and L. Vigneron. The AVISPA Tool for the automated validation of internet security protocols and applications. In 17th International Conference on Computer Aided Veriﬁcation, CAV 2005, Proceedings, volume 3576 of LNCS, pages 281–285. Springer, 2005.
B. Blanchet. An eﬃcient cryptographic protocol verifier based on prolog rules. In the 14th IEEE Computer Security Foundations Workshop, CSFW 2001, Proceedings, pages 82–96. IEEE Computer Society Press, 2001.
Bruno Blanchet, Martín Abadi, and Cédric Fournet. Automated verification of selected equivalences for security protocols. Journal of Logic and Algebraic Programming, 75(1):3–51, February–March 2008.
Y. Boichut, R. Courbis, P. C. Héam, and O. Kouchnarenko. Handling left-quadratic rules when completing tree automata. Electronic Notes in Theoretical Computer Science, 223:61–70, 2008.
Y. Boichut, P.-C. Héam, and O. Kouchnarenko. Automatic Verification of Security Protocols Using Approximations. Technical Report RR-5727, INRIA, 2005.
Y. Boichut, P.-C. Héam, and O. Kouchnarenko. Handling algebraic properties in automatic analysis of security protocols. In Int. Col. on Theorical Aspects of Computing , ICTAC-06, volume 4281 of LNCS, pages 153–167. Springer Berlin/Heidelberg, 2006.
M. Bond. Attacks on cryptoprocessor transaction sets. In the International Workshop on Cryptographic Hardware and Embedded Systems, CHES 2001, Proceedings, Lecture Notes on Computer Science, pages 220–234. Springer Verlag, 2001.
L. Bozga, Y. Lakhnech, and M. Perin. Pattern-based abstraction for verifying secrecy in protocols. In 9th International Conference on Tools and Algorithms for the Construction and Analysis of Systems,TACAS 2003, Proceedings, volume 2619 of LNCS. Springer-Verlag, 2003.
Y. Chevalier, L. Compagna, J. Cuellar, P. Hankes Drielsma, J. Mantovani, S. Mödersheim, and
L. Vigneron. A high level protocol specification language for industrial security-sensitive protocols. In Workshop on Speciﬁcation and Automated Processing of Security Requirements, SAPS 2004, Proceedings, 2004.
H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi. Tree Automata Techniques and Applications, 2002.
V. Cortier, S. Delaune, and P. Lafourcade. A survey of algebraic properties used in cryptographic protocols. Journal of Computer Security, 14:1–43, 2006.
V. Cortier, G. Keighren, and G. Steel. Automatic analysis of the security of xor-based key management schemes. In the 13 th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS 2007, Proceedings, 2007. To be published in Lecture Notes on Computer Science.
V. Cortier, J. K. Millen, and H. Rueß. Proving secrecy is easy enough. In 14th IEEE Computer Security Foundations Workshop, CSFW 2001, Proceedings, pages 97–110. IEEE, June 2001.
C.J.F. Cremers. Scyther - Semantics and Veriﬁcation of Security Protocols. Ph.D. dissertation, Eindhoven University of Technology, 2006.
C.J.F. Cremers and P. Lafourcade. Comparing state spaces in security protocol analysis. In In Proc. of AVoCS’07, ENTCS, 2007. To appear.
D. Dolev and A. Yao. On the Security of Public-Key Protocols. IEEE Transactions on Information Theory, 2(29), 1983.
S. Escobar, C. Meadows, and J. Meseguer. Equational cryptographic reasoning in the maude-NRL protocol analyzer. Electr. Notes Theor. Comput. Sci., 171(4):23–36, 2007.
G. Feuillade, Th. Genet, and V. VietTriemTong. Reachability analysis over term rewriting systems.
Journal of Automated Reasonning, 33 (3-4), 2004.
Th. Genet and F. Klay. Rewriting for Cryptographic Protocol Verification. In proceedings of CADE, volume 1831 of LNCS, pages 271–290. Springer-Verlag, 2000.
C. Meadows. The NRL protocol analyser: An overview. Journal of Logic Programming, 1994.
D. Monniaux. Abstracting cryptographic protocols with tree automata. In proceedings of SAS, volume 1694 of LNCS. Springer-Verlag, 1999.

H. Ohsaki and T. Takai. ACTAS: A system design for associative and commutative tree automata theory. Electr. Notes Theor. Comput. Sci, 124(1):97–111, 2005.
L. C. Paulson. The inductive approach to verifying cryptographic protocols. Journal of Computer Security, 6(1):85–128, 1998.
D. Song. Athena: A new eﬃcient automatic checker for security protocol analysis. In the 12th IEEE Computer Security Foundations Workshop, CSFW 1999, Proceedings, pages 192–202. IEEE Computer Society Press, 1999.
M. Turuani. The cl-atse protocol analyser. In 17 th International Conference on Rewriting Techniques and Applications, RTA 2006, Proceedings, volume 4098 of LNCS, pages 277–286. Springer-Verlag, 2006.
