Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 276 (2011) 191–213
www.elsevier.com/locate/entcs
Capsules and Closures
Jean-Baptiste Jeannin1
Department of Computer Science Cornell University
Ithaca, New York 14853-7501, USA

Abstract
Capsules are a clean representation of the state of a computation in higher-order programming languages with effects. Their intent is to simplify and replace the notion of closure. They naturally provide support for functional and imperative features, including recursion and mutable bindings, and ensure lexical scoping without the use of closures, heaps, stacks or combinators. We present a comparison of the use of closures and capsules in the semantics of higher-order programming languages with effects. In proving soundness of one to the other, we give a precise account of how capsule environments and closure environments relate to each other.
Keywords: Capsule, Closure, Functional Programming, Imperative Programming, State of Computation, Higher-Order Functions, Mutable Variables, Scoping, Programming Language Semantics.


Introduction
This paper compares Capsules and Closures. Capsules are a representation of the state of a computation for higher-order functional and imperative languages with effects, and were introduced in [1]. Many authors have studied the state of a com- putation, for example [2–14]. However, capsules are intended to be as simple as possible, and they correctly capture lexical scoping and handle variable assignment and recursion without any combinators, stacks or heaps, and while keeping every- thing typable with simple types.
Closures were first introduced by Peter J. Landin along with the SECD machine [13], and first implemented in the programming language Scheme [15]. The early ver- sions of Lisp implemented dynamic scoping, which did not follow the semantics of the λ-calculus based on β-reduction. By keeping with each λ-abstraction the envi- ronment in which it was declared, thus forming a closure, closures were successful at implementing static scoping efficiently.

1 Email: jeannin@cs.cornell.edu

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.09.022

In [1], capsules are shown to be essentially finite coalgebraic representations of regular closed λ-coterms. Because of recursion and therefore of possible cycles in the environment, the state of computation should be able to represent all finite λ- terms and a subset of the infinite λ-terms, also called λ-coterms. Capsules represent all the regular λ-coterms, and that is enough to model every computation in the language. λ-coterms allow to represent recursive functions directly, without the need for the Y-combinator or recursive types.
The language we introduce is both functional and imperative: it has higher-order functions, but every variable is mutable. This leads to interesting interactions and allows to go further than just enforcing lexical scoping. In particular, what do we expect the result of an expression like (let x =1 in let f = λy.x in x := 2; f 0) to be? Scheme (using set! for :=) and OCaml (using references) answer 2. Capsules give a rigorous mathematical definition that agrees and conservatively extends the scoping rules of the λ-calculus. Our semantics of closures also agrees with this definition, but this requires introducing a level of indirection, with both an environment and a store, a` la ML. Finally, recursive definitions are often implemented using some sort of backpatching; this construction is known as “Landin’s knot”. We build this directly into the definition of the language by defining let rec x = d in e as a syntactic sugar for let x = a in x := d; e, where a is any expression of the appropriate type.
There is much previous work on reasoning about references and local state; see [16– 19]. State is typically modeled by some form of heap from which storage locations can be allocated and deallocated [9–12]. Others have used game semantics to reason about local state [20–22]. Mason and Talcott [2–4] and Felleisen and Hieb [5] present a semantics based on a heap and storage locations. A key difference is that Felleisen and Hieb’s semantics is based on continuations. Finally, Moggi [8] proposed monads, which can be used to model state and are implemented in Haskell.
This paper is organized as follows. In section 2, we formally introduce a program- ming language based on the λ-calculus containing both functional and imperative features. In section 3, we describe two semantics for this language, one based on capsules and the other on closures. In section 4, we show a very strong correspon- dence (Theorem 4.5) between the two semantics, showing that every computation in the semantics of capsules is bisimilar to a computation in the semantics of closures, and vice-versa. In section 5, we show (Propositions 5.1–5.4) that closure semantics retains some unnecessary information that capsule semantics omits, attesting of the simplicity of capsules. We finish with a discussion in section 6.

Syntax
Expressions
Expressions Exp = {d, e, a, b, . . .} contain both functional and imperative features. There is an unlimited supply of variables x, y, z, . . . of all (simple) types, as well as

constants f, c, ... for primitive values. () is the only constant of type unit, and true and false are the only two constants of type bool. In addition, there are functional features
λ-abstraction	λx.e
application	(d e), imperative features
assignment	x := e
composition	d; e
conditional	if b then d else e
while loop	while b do e, and syntactic sugars
let x = d in e	(λx.e) d
let rec x = d in e	let x = a in x := d; e
where a is any expression of the appropriate type.
Let Var be the set of variables, Const the set of constants, and λ-Abs the set of
λ-abstractions. Given an expression e, let FV(e) denote the set of free variables of
e. Given a partial function h : Var ~ Var such that FV(e) ⊆ dom h, let h(e) be the expression e where every instance of a free variable x ∈ FV(e) has been replaced by the variable h(x). As usual, given two partial functions g and h, g ◦ h denotes their composition such that for all x, g ◦ h(x) = g(h(x)). Given a function h, we write h[x/v] the function such that h[x/v](y)= h(y) for y /= x and h[x/v](x)= v. Given an expression e, we write e[x/y] the expression e where all free occurrences of x have been replaced by y.
Throughout the paper, we focus on the features directly involving variables: variable calls x, λ-abstractions λx.e, applications (d e) where d reduces to a λ-abstraction, and assignment x := e. Most differences between capsules and closures arise using these features.

Types
Types α, β, . . . are built inductively from an unspecified family of base types, in- cluding at least unit and bool, and a type constructor → such that functions with input type α and return type β have type α → β. All constants c of the language have a type type(c); by convention, we use c for a constant of a base type and f for a constant of a functional type. We follow [23] in assuming that each variable x is associated with a unique type type(x), that could for example be built into the variable name. Γ is a type environment, a partial function Var ~ Type. As is

standard, we write Γ,x : α for the typing environment Γ where x has been bound or rebound to α. The typing rules are standard:


Γ ▶ c : α if type(c)= α	Γ,x : α ▶ x : α
type(x)= α	Γ,x : α ▶ e : β


Γ ▶ λx.e : α → β

Γ ▶ d : α → β	Γ ▶ e : α
Γ ▶ (d e): β
Γ ▶ x : α	Γ ▶ e : α


Γ ▶ x := e : unit
Γ ▶ d : unit	Γ ▶ e : α


Γ ▶ d; e : α

Γ ▶ b : bool	Γ ▶ d : α	Γ ▶ e : α


Γ ▶ if b then d else e : α
Γ ▶ b : bool	Γ ▶ e : unit


Γ ▶ while b do e : unit

Semantics
We present two different semantics that have a strong correspondence:
The semantics on capsules is a simplified version of the semantics on closure structures introduced in [24]. It has previously been described in [1];
The semantics on closures is the semantics usually used and taught for func- tional languages. A level of indirection for variables has been added to support imperative features, `a la ML.
All the expressions we consider in this section are supposed well-typed with the rules of section 2.2.

Capsules
Deﬁnitions
An irreducible term is either a constant or a λ-abstraction. A capsule environment
is a partial function from variables to irreducible terms.
Let i, j, k,... denote irreducible terms and γ, δ, ζ, η, . . . capsule environments. Let
Irred = Const + λ-Abs be the set of irreducible terms. Thus we have:
γ : Var ~ Irred	Irred = Const + λ-Abs

A capsule environment γ is valid if and only if
∀x ∈ dom γ, FV(γ(x)) ⊆ dom γ

Semantics
A capsule is a pair ⟨e, γ⟩. A capsule is valid if and only if FV(e) ⊆ dom γ and γ is valid. We only consider valid capsule environments and valid capsules.

An irreducible capsule is a capsule ⟨i, γ⟩ where i ∈ Irred. Let us define a big step semantics where the operator ⇓ca relates capsules to irreducible capsules. The semantics of features directly involving variables is given by:


⟨x, γ⟩⇓ca
⟨γ(x), γ⟩	⟨λx.e, γ⟩⇓ca
⟨λx.e, γ⟩	⟨e, γ⟩⇓ca⟨j, ζ⟩
⟨x := e, γ⟩⇓ca⟨(), ζ[x/j]⟩

⟨d, γ⟩⇓ca⟨λx.a, ζ⟩	⟨e, ζ⟩⇓ca⟨j, η⟩	⟨a[x/y], η[y/j]⟩⇓ca⟨i, δ⟩ (y fresh)
⟨d e, γ⟩⇓ca⟨i, δ⟩
and the remaining semantics is:


⟨c, γ⟩⇓ca
⟨c, γ⟩	⟨d, γ⟩⇓ca⟨f, ζ⟩	⟨e, ζ⟩⇓ca⟨c, δ⟩
⟨d e, γ⟩⇓ca⟨f (c), δ⟩
⟨d, γ⟩⇓ca⟨(), ζ⟩	⟨e, ζ⟩⇓ca⟨i, δ⟩


⟨d; e, γ⟩⇓ca⟨i, δ⟩



⟨b, γ⟩⇓ca⟨true, ζ⟩	⟨d, ζ⟩⇓ca⟨i, δ⟩
⟨if b then d else e, γ⟩⇓ca⟨i, δ⟩
⟨b, γ⟩⇓ca⟨false, ζ⟩	⟨e, ζ⟩⇓ca⟨i, δ⟩


⟨if b then d else e, γ⟩⇓ca⟨i, δ⟩

⟨b, γi⟩⇓ca⟨true, δi⟩	⟨e, δi⟩⇓ca⟨(), γi+1⟩, 0 ≤ i < n, n ≥ 0
⟨b, γn⟩⇓ca⟨false, δn⟩
⟨while b do e, γ0⟩⇓ca⟨(), δn⟩

Examples
The following examples show that lexical scoping and recursion are handled.
Example 3.1 (let x =1 in let f = λy.x in let x =2 in f 0)⇓ca1

Proof. For simplicity, we just show the different capsules of the computation.
let x =1 in let f = λy.x in let x =2 in f 0		[ ] let f = λy.xj in let x =2 in f 0			[xj = 1] let x =2 in f 0		[xj = 1, f = λy.xj] f 0	[xj = 1, f = λy.xj, xjj = 2]
(λy.xj) 0	[xj = 1, f = λy.xj, xjj = 2]
xj	[xj = 1, f = λy.xj, xjj = 2, yj = 0]
1	[xj = 1, f = λy.xj, xjj = 2, yj = 0]
2
Example 3.2 (let x =1 in let f = λy.x in x := 2; f 0)⇓ca2

Proof.


let x =1 in let f = λy.x in x := 2; f 0		[ ] let f = λy.xj in xj := 2; f 0		[xj = 1] xj := 2; f 0	[xj = 1, f = λy.xj]
f 0	[xj = 2, f = λy.xj]
(λy.xj) 0		[xj = 2, f = λy.xj] xj	[xj = 2, f = λy.xj, yj = 0]
2	[xj = 2, f = λy.xj, yj = 0]


2



Example 3.3 (let x =1 in let f = λy.x in let x =2 in f := λy.x; f 0)⇓ca2




Proof.


let x =1 in let f = λy.x in let x =2 in f := λy.x; f 0		[ ] let f = λy.x in let x =2 in f := λy.x; f 0		[xj = 1] let x =2 in f := λy.x; f 0		[xj = 1, f = λy.xj] f := λy.xjj; f 0	[xj = 1, f = λy.xj, xjj = 2]
f 0	[xj = 1, f = λy.xjj, xjj = 2]
(λy.xjj) 0	[xj = 1, f = λy.xjj, xjj = 2]
xjj	[xj = 1, f = λy.xjj, xjj = 2, yj = 0]
2	[xj = 1, f = λy.xjj, xjj = 2, yj = 0]


2



Example 3.4 (let rec f = λn.if n =0 then 1 else f (n − 1) × n in f 3)⇓ca6

Proof. In this example e stands for λn.if n =0 then 1 else f (n − 1) × n.

let rec f = λn.if n =0 then 1 else f (n − 1) × n in f 3	[ ] f 3	[f = λn.if n =0 then 1 else f (n − 1) × n] if n1 =0 then 1 else f (n1 − 1) × n1	[f = e, n1 = 3]
(f 2) × n1	[f = e, n1 = 3]
(if n2 =0 then 1 else n2 × f (n2 − 1)) × n1  [f = e, n1 = 3, n2 = 2] (f 1) × n2 × n1	[f = e, n1 = 3, n2 = 2]
(if n3 =0 then 1 else n3 × f (n3 − 1)) × n2 × n1
[f = e, n1 = 3, n2 = 2, n3 = 1]
(f 0) × n3 × n2 × n1	[f = e, n1 = 3, n2 = 2, n3 = 3]
(if n4 =0 then 1 else n4 × f (n4 − 1)) × n3 × n2 × n1
[f = e, n1 = 3, n2 = 2, n3 = 1, n4 = 0] 1 × n3 × n2 × n1	[f = e, n1 = 3, n2 = 2, n3 = 1, n4 = 0]
6	[f = e, n1 = 3, n2 = 2, n3 = 1, n4 = 0]


2



Closures

Deﬁnitions
Closures were introduced in the language Scheme [15]. We present a version of them using a level of indirection, allowing us to handle mutable variables.
There is an unlimited number of locations l, l1, l2 .. .; locations can be thought of as addresses in memory. An environment is a partial function from variables to locations. A closure is defined as a pair {λx.e, σ} such that FV(λx.e) ⊆ dom σ, where λx.e is a λ-abstraction and σ is an environment that is used to interpret the free variables of λx.e. A value is either a constant or a closure. Values for closures play the same role as irreducible terms for capsules. A store (or memory ) is a partial function from locations to values.
Let u, v, w, . . . denote values, σ, τ, ... environments and μ, ν, ξ, χ, . . . stores. Let Val be the set of values, Loc the set of locations and Cl the set of closures. Thus we have:

σ : Var ~ Loc	μ : Loc ~ Val	Val = Const + Cl

Semantics
A state is a triple ⟨e, σ, μ⟩. A state is valid if and only if
FV(e) ⊆ dom σ	codom σ ⊆ dom μ
∀{λx.a, τ}∈ codom μ, FV(λx.a) ⊆ dom τ ∧ codom τ ⊆ dom μ
A result is a pair (v, μ). A result is valid if and only if either v ∈ Const, or v = {λx.a, τ}∈ Cl and the triple ⟨λx.a, τ, μ⟩ is valid. We only consider valid states and results. Let us define a big step semantics where the operator ⇓cl relates valid states to valid results. The semantics of features directly involving variables is given by:
⟨x, σ, μ⟩⇓cl(μ(σ(x)), μ)	⟨λx.e, σ, μ⟩⇓cl({λx.e, σ}, μ)
⟨e, σ, μ⟩⇓cl(v, ξ)
⟨x := e, σ, μ⟩⇓cl((), ξ[σ(x)/v])
⟨d, σ, μ⟩⇓cl({λx.a, τ}, ξ)	⟨e, σ, ξ⟩⇓cl(v, χ)
⟨a, τ [x/l], χ[l/v]⟩⇓cl(u, ν)	(l fresh)
⟨d e, σ, μ⟩⇓cl(u, ν)
and the remaining semantics is:


⟨c, σ, μ⟩⇓cl
(c, μ)	⟨d, σ, μ⟩⇓cl(f, ξ)	⟨e, σ, ξ⟩⇓cl(c, ν)
⟨d e, σ, μ⟩⇓cl(f (c), ν)
⟨d, σ, μ⟩⇓cl((), ξ)	⟨e, σ, ξ⟩⇓cl(u, ν)


⟨d; e, σ, μ⟩⇓cl(u, ν)
⟨b, σ, μ⟩⇓cl(true, ξ)	⟨d, σ, ξ⟩⇓cl(u, ν)


⟨if b then d else e, σ, μ⟩⇓cl(u, ν)
⟨b, σ, μ⟩⇓cl(false, ξ)	⟨e, σ, ξ⟩⇓cl(u, ν)


⟨if b then d else e, σ, μ⟩⇓cl(u, ν)

⟨b, σ, μi⟩⇓cl(true, νi)	⟨e, σ, νi⟩⇓cl((), μi+1), 0 ≤ i < n, n ≥ 0
⟨b, σ, μn⟩⇓cl(false, νn)
⟨while b do e, σ, μ0⟩⇓cl((), νn)

Examples
Example 3.5 (let x =1 in let f = λy.x in let x =2 in f 0)⇓cl1
Example 3.6 (let x =1 in let f = λy.x in x := 2; f 0)⇓cl2
Example 3.7 (let x =1 in let f = λy.x in let x =2 in f := λy.x; f 0)⇓cl2
Example 3.8 (let rec f = λn.if n =0 then 1 else n × f (n − 1) in f 3)⇓cl6

Equivalence of the semantics
Deﬁnitions

There is a very strong correspondence between the semantics of closures and cap- sules. To give a precise account of this correspondence, we introduce an injective partial function h : Loc ~ Var with which we define four relations. Each relation is between an element of the semantics of closures and an element of the semantics of capsules that play similar roles:

v →h

μ →h
i between values and irreducible terms;
γ between stores and capsule environments;

⟨d, σ, μ⟩ ∼h ⟨e, γ⟩ between states and capsules;
(v, μ) ∼h ⟨i, γ⟩ between results and irreducible capsules.
One thing to notice is that nothing in the semantics of capsules plays the same role as the environment σ in the semantics of closures: capsule environments γ relate to memories μ, and environments σ have been simplified. Let us now give precise definitions of those relations.
Definition 4.1 Given a value v and an irreducible term i, we say that h transforms

v into i, where h is an injective map h : Loc ~ Var, and we write v →h
if:
v = i when v ∈ Const, or
codom τ ⊆ dom h and (h ◦ τ )(λx.a)= i when v = {λx.a, τ}∈ Cl
i, if and only

Definition 4.2 Given a store μ and a capsule environment γ, we say that h trans-

forms μ into γ, where h is an injective map h : Loc ~ Var, and we write μ →h
and only if:
dom h = dom μ	h(dom μ)= dom γ
γ, if

∀l ∈ dom μ, μ(l) →h
γ(h(l))

Definition 4.3 Given a state ⟨d, σ, μ⟩ and a capsule ⟨e, γ⟩, both valid, we say that they are bisimilar under h, where h is an injective map h : Loc ~ Var, and we write
⟨d, σ, μ⟩ ∼h ⟨e, γ⟩, if and only if
(h ◦ σ)(d)= e	μ →h  γ
Definition 4.4 Given a result (v, μ) and an irreducible capsule ⟨i, γ⟩, both valid, we say that they are bisimilar under h, where h is an injective map h : Loc ~ Var,

and we write (v, μ) ∼h ⟨i, γ⟩ if and only if:
v →h i	μ →h γ

Soundness of Capsules with respect to Closures
Now that we know how to relate each element of both semantics, theorem 4.5 shows that any derivation using capsules mirrors a derivation using closures, and vice- versa:
Theorem 4.5 If ⟨d, σ, μ⟩ ∼h ⟨e, γ⟩ then ⟨d, σ, μ⟩⇓ (u, ν) for some u, ν if and only if ⟨e, γ⟩⇓ca⟨i, δ⟩ for some i, δ, and in that case we have
g
(u, ν) ∼ ⟨i, δ⟩
where g is an extension of h, i.e., dom h ⊆ dom g and h and g agree on dom h.
Proof. We show the direct implication by induction on the big-step derivation of ⟨d, σ, μ⟩⇓cl(u, ν) and the converse by induction on the big-step derivation of
⟨e, γ⟩⇓ca⟨i, δ⟩.
In the interest of space, we only show the most interesting cases of the induction in the main text: variable call x, λ-abstraction λx.e, function application of a λ- abstraction d e where d reduces to a λ-abstraction, and variable assignment x := e. In all these cases, both implications are very similar proofs, therefore we only show the direct implication (⇒). The other cases, constant c, function application of a constant function de where d reduces to a constant f , composition d; e, if conditional if b then d else e and while loop while b do e, are detailed in the appendix.

Variable call
If d = x for some variable x then e = (h ◦ σ)(d)= y with y the variable such that
y = (h ◦ σ)(x).
(⇒) By definition of ⇓cl, (u, ν) = (μ(σ(x)), μ), and by definition of ⇓ca, ⟨e, γ⟩ =

⟨y, γ⟩⇓ca
⟨γ(y), γ⟩.	Moreover μ →h
γ, therefore by definition of
→h , μ(σ(x)) →h
g

γ(h(σ(x))) = γ(y).  Therefore, with g = h, (u, ν) = (μ(σ(x)), μ)
which completes this case.
~ ⟨γ(y), γ⟩


λ-Abstraction
If d = λx.a, then e = (h ◦ σ)(λx.a) which is a term α-equivalent to d, so e = λx.b for some b. Indeed, the variable x does not change from d to e since only the free variables of d are affected by h ◦ σ.

(⇒) By definition of ⇓cl, (u, ν)= ({λx.a, σ}, μ), and by definition of ⇓ca, ⟨e, γ⟩ =
⟨λx.b, γ⟩⇓ca⟨λx.b, γ⟩.	But codom σ ⊆ dom h and λx.b = (h ◦ σ)(λx.a), there-
fore {λx.a, σ} →h  λx.b.	Moreover we know μ →h  γ and with g = h, we get
g
({λx.a, σ}, μ) ∼ ⟨λx.b, γ⟩ which completes this case.

Function application of a λ-abstraction
If d = d1 d2, then let e1 = (h◦σ)(d1) and e2 = (h◦σ)(d2). Since e = (h◦σ)(d) means that e is α-equivalent to d, e = e1 e2, and we can easily check that ⟨d1, σ, μ⟩ ∼h
⟨e1, γ⟩ and ⟨d2, σ, μ⟩ ∼h ⟨e2, γ⟩.
(⇒) If ⟨d1 d2, σ, μ⟩⇓cl(u, ν) because
⟨d1, σ, μ⟩⇓cl({λx.a, τ}, ξ)	⟨d2, σ, ξ⟩⇓cl(v, χ)	⟨a, τ [x/l], χ[l/v]⟩⇓cl(u, ν) with l fresh, then by induction hypothesis on the derivation of d1, there exist k, ζ
and h1 an extension of h such that


⟨e1, γ⟩⇓ca
⟨k, ζ⟩
h
({λx.a, τ}, ξ) ∼ ⟨k, ζ⟩

The second condition implies that k = λx.b = (h1 ◦ τ )(λx.a) for some expression b,
h1	h1	h	h1
and that ξ → ζ. Moreover d2 → e2 since d2 → e2, therefore ⟨d2, σ, ξ⟩ ∼ ⟨e2, ζ⟩. By
induction hypothesis on the derivation of d2, there exist j, η and h2 an extension of
h1 such that


⟨e2, ζ⟩⇓ca
⟨j, η⟩
h
(v, χ) ∼ ⟨j, η⟩

As l is the fresh location chosen in the derivation of ⇓cl for d, let y be a fresh variable for the derivation of ⇓ca for e. Let h3 : Loc ~ Var such that:
h3 : dom h2 ∪ {l}→ codom h2 ∪ {y}
l2 ∈ dom h2 '→ h2(l2)
l '→ y

h
Lemma 4.6 ⟨a, τ [x/l], χ[l/v]⟩ ∼ (b[x/y], η[y/j])
Proof. First of all, λx.b = (h1 ◦ τ )(λx.a), h3 is an extension of h1 and FV(λx.a) ⊆ dom h1, therefore λx.b = (h3 ◦ τ )(λx.a). Now b[x/y] = ((h3 ◦ τ )[x/y])(λx.a) = (h3 ◦ τ [x/l])(λx.a) since h3(l)= y.
h
We further need to argue that χ[l/v] → η[y/j]. We already know that dom h3 =
dom h2 ∪ {l} = dom χ ∪ {l} = dom χ[l/v], and h3(dom χ[l/v]) = codom h2 ∪
h
{y} = dom η[y/j]. Let l3 ∈ dom χ[l/v]. If l3 ∈ dom	3	3
χ, then χ[l/v](l ) = χ(l ) →
h
η(h3(l3)) = η[y/j](h3(l3)) by injectivity of h3, therefore χ[l/v](l3) → η[y/j](h3(l3)).

h
Otherwise, l3 = l and then χ[l/v](l)= v → j = η[y/j](y)= η[y/j](h3(l)), therefore
h
since h3 is an extension of h2, χ[l/v](l) → η[y/j](h3(l)). This completes the proof
of the lemma.	2
Using lemma 4.6 and by induction hypothesis on the derivation of a, there exist i, δ
and g an extension of h3 such that
g
⟨b[x/y], η[y/j]⟩⇓ca⟨i, δ⟩	(u, ν) ∼ ⟨i, δ⟩

g
Therefore, by definition of ⇓cl, ⟨e1 e2, γ⟩⇓ca⟨i, δ⟩ and (u, ν) ∼ ⟨i, δ⟩, which com-
pletes this case.

Variable assignment
If d = (x := d1) for some variable x and expression d1, then e = (h ◦ σ)(x := d1)= (y := e1) with y a variable such that y = (h ◦ σ)(x) and e1 = (h ◦ σ)(d1). Therefore
⟨d1, σ, μ⟩ ∼h ⟨e1, γ⟩.
(⇒) The derivation of ⇓cl for d shows that (u, ν) = ((), ξ[σ(x)/v]) for some v, ξ
such that
⟨e1, σ, μ⟩⇓cl(v, ξ)
By induction hypothesis on the derivation of ⇓cl for d1, there exist j, ζ and g an extension of h such that
g
⟨e1, γ⟩⇓ca⟨j, ζ⟩	(v, ξ) ∼ ⟨j, ζ⟩



g
Lemma 4.7 ((), ξ[σ(x)/v]) ∼ ⟨(), ζ[y/j]⟩

g
Proof. The domain conditions are fulfilled since (v, ξ) ∼ ⟨j, ζ⟩, dom ξ = dom ξ[σ(x)/v]
and dom ζ = dom ζ[y/j].	Let l ∈ dom ξ[σ(x)/v] = dom ξ.	If l = σ(x) then
g
ξ[σ(x)/v](l)= v ∼ j = ζ[y/j](y)= ζ[y/j](g(l)) since g(l)= (g◦σ)(x)= (h◦σ)(x)= 
g
y. Otherwise ξ[σ(x)/v](l)= ξ(l) ∼ ζ(h(l)) = ζ[y/j](g(l)) using that h is injective
g
and g is an extension of h. Finally () → (), which completes the proof of the
lemma.	2

Using lemma 4.7 and by definition of ⇓ca, ⟨x := e1, γ⟩⇓ca⟨(), ζ[y/j]⟩ and ⟨u, ν⟩ =
g
((), ξ[σ(x)/v]) ∼ ⟨(), ζ[y/j]⟩, which completes this case.
The other cases are proved in the appendix.
2

Capsules encode less information
When evaluating an expression using capsules, less information is kept than when evaluating the same expression using closures. Intuitively, when using closures, the state of the computation keeps track of exactly what variables of a λ-abstraction are in scope, even if those variables do not appear in the λ-abstraction itself and will therefore never be used. When using capsules however, the capsule only keeps track of the variables that are both in scope and appear in the λ-abstraction.
For example, let us evaluate the expressions d = (let x =1 in let y = λy.0 in y) and e = (let y = λy.0 in let x = 1 in y). Using the definitions of ⇓cl and ⇓ca, we can prove that:
d⇓cl({λy.0, [x = l1]}, [l1 = 1, l2 = {λy.0, [x = 1]}])
e⇓cl({λy.0, [ ]}, [l1 = 1, l2 = {λy.0, [ ]}])
d⇓ca⟨λy.0, [xj = 1, yj = λy.0]⟩ e⇓ca⟨λy.0, [xj = 1, yj = λy.0]⟩


On this example, the result of evaluating d and e with ⇓cl keeps track of whether x is in scope or not, but evaluating d and e with ⇓ca does not. This information is completely superfluous for the rest of the computation and suppressing it with capsules avoids some overhead. Propositions 5.1 to 5.4 give a more precise account of what is happening.

Proposition 5.1 If v →h
converse is not true.
i then given h, i can be uniquely determined from v; the



Proof. If v →h
i1 and v →h
i2 then either:

v ∈ Const and then v = i1 and v = i2 thus i1 = i2;
v = {λx.a, τ}∈ Cl and then i1 = (h◦τ )(λx.a) and i2 = (h◦τ )(λx.a) thus i1 = i2.

However, {λy.0, [ ]} →h
(λy.0) and {λy.0, [x = l]} →h
(λy.0).	2

Proposition 5.2 If μ →h
converse is not true.
γ then given h, γ can be uniquely determined from μ; the

Proof. If μ →h
γ1 and μ →h
γ2 then dom γ1 = h(dom μ) = dom γ2. Moreover, for

all l ∈ dom mu, μ(l) →h
γ1(h(l)) and μ(l) →h
γ2(h(l)) therefore using proposition

, γ1(h(l)) = γ2(h(l)). This covers all the domain of γ1 and γ2 since dom γ1 =
dom γ2 = h(dom μ).

However, with h transforming l in z, [l = {λy.0, [ ]}] →h
[z = λy.0] and [l =

{λy.0, [x = l]}] →h
[z = λy.0]	2

Proposition 5.3 If ⟨d, σ, μ⟩ ∼h
⟨e, γ⟩ then given h, ⟨e, γ⟩ can be uniquely deter-

mined from ⟨d, σ, μ⟩; the converse is not true.

Proof. If ⟨d, σ, μ⟩ ∼h
⟨e1, γ1⟩ and ⟨d, σ, μ⟩ ∼h
⟨e2, γ2⟩, then (h ◦ σ(d)) = e1 and

(h ◦ σ(d)) = e2 therefore e1 = e2. Moreover μ →h
proposition 5.2, γ1 = γ2.
However, with h transforming l in z,
γ1 and μ →h
γ2 therefore using

⟨x, [x = l], [l = {λy.0, [ ]}]⟩ ∼h ⟨z, [z = λy.0]⟩
⟨x, [x = l], [l = {λy.0, [x = l]}]⟩ ∼h ⟨z, [z = λy.0]⟩

2
Proposition 5.4 If (v, μ) ∼h ⟨i, γ⟩ then given h, ⟨i, γ⟩ can be uniquely determined from (v, μ); the converse is not true.

Proof. The unicity of ⟨i, γ⟩ is a direct consequence of propositions 5.1 and 5.2. However,
({λy.0, [ ]}, [ ]) ∼h ⟨λy.0, [ ]⟩
({λy.0, [x = l]}, [l = 1]) ∼h ⟨λy.0, [ ]⟩

2

The idea behind those propositions is that for every capsule, there are several bisim- ilar states corresponding to different computations, and each keeping track of a dif- ferent set of superfluous information. Similarly, for every irreducible capsules, there are several bisimilar results keeping track of superfluous information. Capsules thus offer a much cleaner representation of the state of computation.

Discussion
Capsules and Closures: a strong correspondence

Theorem 4.5 shows that capsules and closures are very strongly related. Not only is there a derivation based on capsules for every derivation based on closures, but these two derivations mirror each other. This is because each rule of the definition of ⇓ca mirrors a rule of the definition of ⇓cl, and because the proof of the theorem is a direct structural induction on the definitions of ⇓cl and ⇓ca. Thus the computations are completely bisimilar, even though definining computations for capsules is simpler.

Capsules allow to suppress the environment σ

When using closures, a state is a triple ⟨d, σ, μ⟩ whereas when using capsules, it is just a capsule ⟨e, γ⟩. It they are bisimilar under h, it means that (h ◦ σ)(d)= e and

μ →h
γ. Really, capsules eliminate the need for the environment σ and thus suppress

the indirection in closures that was needed to handle imperative features. Moreover, the initial idea between the capsule environment γ was that it would replace the (closure) environment σ. However, it is remarkable that γ is much closer to the store μ, while at the same time eliminates the need for the (closure) environment σ.

A simple small-step semantics for capsules
When establishing theorem 4.5, we tried to build a small-step semantics for closures and capsules. We only present here what happens on the rule for the application (d e) when d has already been reduced to a λ-term and e to a value, as all the other rules are reasonably straightforward.
Using closures, we are trying to take the next small step in the state
⟨{λx.a, τ} v, σ, μ⟩. We would like to write something like:
⟨{λx.a, τ} v, σ, μ⟩ →cl ⟨a, τ [x/l], μ[l/v]⟩	(l fresh)
This rule is wrong: it drops the environment σ, but when this evaluation is in context, σ has to come back once we finish evaluating a. One solution is to write a rule involving several small steps, which is really a big step rule. Another solution is to keep track of the whole stack of environments to come back to the previous environment each time we get out of a scope (see [24]).
Using capsules however, the following rule comes very naturally:
⟨(λx.a) i, γ⟩ →ca ⟨a[x/y], γ[y/i]⟩	(y fresh)
Along with the other small-step rules, this shows that the capsule semantics is fully relational and does not need any stack or auxiliary data structure.

References
J.-B. Jeannin and D. Kozen, “Computing with capsules,” Computing and Information Science, Cornell University, Tech. Rep. http://hdl.handle.net/1813/22082, January 2011.
I. Mason and C. Talcott, “Equivalence in functional languages with effects,” 1991.
——, “Programming, transforming, and proving with function abstractions and memories.”
——, “Axiomatizing operational equivalence in the presence of side effects,” in Fourth Annual Symposium on Logic in Computer Science. IEEE. IEEE Computer Society Press, 1989, pp. 284– 293.

M. Felleisen and R. Hieb, “The revised report on the syntactic theories of sequential control and state,”
Theoretical Computer Science, vol. 103, pp. 235–271, 1992.
K. Aboul-Hosn, “Programming with private state,” Honors Thesis, The Pennsylvania State University,
December 2001. [Online]. Available: http://www.cs.cornell.edu/%7Ekamal/thesis.pdf
K. Aboul-Hosn and D. Kozen, “Relational semantics of local variable scoping,” Cornell University,
Tech. Rep. 2005-2000, 2005. [Online]. Available: http://www.cs.cornell.edu/%7Ekamal/local.pdf
E. Moggi, “Notions of computation and monads,” Information and Computation, vol. 93, no. 1, 1991.
R. Milne and C. Strachey, A Theory of Programming Language Semantics.	New York, NY, USA: Halsted Press, 1977.
D. Scott, “Mathematical concepts in programmng language semantics,” in Proc. 1972 Spring Joint Computer Conferences. Montvale, NJ: AFIPS Press, 1972, pp. 225–34.
J. E. Stoy, Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. Cambridge, MA, USA: MIT Press, 1981.
J. Y. Halpern, A. R. Meyer, and B. A. Trakhtenbrot, “The semantics of local storage, or what makes the free-list free?” in Proc. 11th ACM Symp. Principles of Programming Languages (POPL’84), New York, NY, USA, 1984, pp. 245–257.
P. J. Landin, “The mechanical evaluation of expressions,” Computer Journal, vol. 6, no. 5, pp. 308–320, 1964.
——, “The next 700 programming languages,” Commun. ACM, vol. 9, pp. 157–166, March 1966. [Online]. Available: http://doi.acm.org/10.1145/365230.365257
G. J. Sussman and G. L. Steele, “Scheme: A interpreter for extended lambda calculus,” Higher-Order and Symbolic Computation, vol. 11, pp. 405–439, 1998, 10.1023/A:1010035624696. [Online]. Available: http://dx.doi.org/10.1023/A:1010035624696
I. A. Mason and C. L. Talcott, “References, local variables and operational reasoning,” in Seventh Annual Symposium on Logic in Computer Science. IEEE, 1992, pp. 186–197. [Online]. Available: http://www-formal.stanford.edu/MT/92lics.ps.Z
A. M. Pitts and I. D. B. Stark, “Observable properties of higher order functions that dynamically create local names, or what’s new?” in MFCS, ser. Lecture Notes in Computer Science, A. M. Borzyszkowski and S. Sokolowski, Eds., vol. 711. Springer, 1993, pp. 122–141.
A. M. Pitts, “Operationally-based theories of program equivalence,” in Semantics and Logics of Computation, ser. Publications of the Newton Institute, P. Dybjer and A. M. Pitts, Eds. Cambridge University Press, 1997, pp. 241–298. [Online]. Available: http://www.cs.tau.ac.il/∼nachumd/formal/ exam/pitts.pdf
A. M. Pitts and I. D. B. Stark, “Operational reasoning in functions with local state,” in Higher Order Operational Techniques in Semantics, A. D. Gordon and A. M. Pitts, Eds. Cambridge University Press, 1998, pp. 227–273. [Online]. Available: http://homepages.inf.ed.ac.uk/stark/operfl.pdf
S. Abramsky, K. Honda, and G. McCusker, “A fully abstract game semantics for general references,” in LICS ’98: Proceedings of the 13th Annual IEEE Symposium on Logic in Computer Science. Washington, DC, USA: IEEE Computer Society, 1998, pp. 334–344.
J. Laird, “A game semantics of local names and good variables.” in FoSSaCS, ser. Lecture Notes in Computer Science, I. Walukiewicz, Ed., vol. 2987. Springer, 2004, pp. 289–303.
S. Abramsky and G. McCusker, “Linearity, sharing and state: a fully abstract game semantics for idealized ALGOL with active expressions.” Electr. Notes Theor. Comput. Sci., vol. 3, 1996.
G. Winskel, The Formal Semantics of Programming Languages. MIT Press, 1993.
K. Aboul-Hosn and D. Kozen, “Relational semantics for higher-order programs,” in Proc. 8th Int. Conf. Mathematics of Program Construction (MPC’06), ser. Lecture Notes in Computer Science, T. Uustalu, Ed., vol. 4014. Springer, July 2006, pp. 29–48.

A	Appendix: Proof of theorem 4.5
We include here the cases we have not included in the main text.

Variable call
(⇐) The converse is similar.	By definition of ⇓ca, ⟨i, δ⟩ = ⟨γ(y), γ⟩, and by

definition of ⇓cl
, ⟨d, σ, μ⟩ = ⟨x, σ, μ⟩⇓cl
(μ(σ(x)), μ). Moreover μ →h
γ, there-

fore by definition of →h , μ(σ(x)) →h  γ(h(σ(x))) = γ(y). Therefore, with g = h,
g
(μ(σ(x)), μ) ∼ ⟨γ(y), γ⟩ = ⟨i, δ⟩ which completes this case.

λ-Abstraction
(⇐) The converse is similar. By definition of ⇓ca, ⟨i, δ⟩ = ⟨λx.b, γ⟩, and by defi- nition of ⇓cl, ⟨d, σ, μ⟩ = ⟨λx.a, σ, μ⟩⇓cl({λx.a, σ}, μ). But codom σ ⊆ dom h and
λx.b = (h ◦ σ)(λx.a), therefore {λx.a, σ} →h λx.b. Moreover we know μ →h γ and
g
with g = h, we get ({λx.a, σ}, μ) ∼ ⟨λx.b, γ⟩ which completes this case.

Function application of a λ-abstraction
(⇐) The converse is similar. If ⟨e1 e2, γ⟩⇓cl⟨i, δ⟩ because
⟨e1, γ⟩⇓ca⟨λx.b, ζ⟩	⟨e2, ζ⟩⇓ca⟨j, η⟩	⟨b[x/y], η[y/j]⟩⇓ca⟨i, δ⟩
with y fresh, then by induction hypothesis on the derivation of e1, there exist w, ξ
and h1 an extension of h such that


⟨d1, σ, μ⟩⇓ca
(w, ξ)	(w, ξ) h1 ⟨λx.b, ζ⟩

The second condition implies that w = {λx.a, τ} for some a, τ such that (h1 ◦
τ )(λx.a) = λx.b, and that ξ h  ζ. Moreover d2 h  e2 since d2 →h  e2, therefore
→	→
h1
⟨d2, σ, ξ⟩ ∼ ⟨e2, ζ⟩. By induction hypothesis on the derivation of e2, there exist
v, χ and h2 an extension of h1 such that


⟨d2, σ, ξ⟩⇓ca
(v, χ)
h
(j, η) ∼ (v, χ)

As y is the fresh variable chosen in the derivation of ⇓ca for e, let l be a fresh location for the derivation of ⇓cl for d. Let h3 : Loc ~ Var such that:
h3 : dom h2 ∪ {l}→ codom h2 ∪ {y}
l2 ∈ dom h2 '→ h2(l2)
l '→ y

h
Lemma A.1 ⟨a, τ [x/l], χ[l/v]⟩ ∼ (b[x/y], η[y/j])
Proof. This is the same as lemma 4.6, and the same proof holds.	2

Using lemma A.1 and by induction hypothesis on the derivation of b[x/y], there exist u, ν and g an extension of h3 such that
g
⟨a, τ [x/l], χ[l/v]⟩⇓cl(u, ν)	(u, ν) ∼ ⟨i, δ⟩
Therefore, by definition of ⇓cl,
g
⟨d1 d2, σ, μ⟩⇓cl(u, ν)	(u, ν) ∼ ⟨i, δ⟩
which completes this case.

Variable assignment
(⇐) The converse is similar.	The derivation of ⇓ca for e shows that ⟨i, δ⟩ =
⟨(), ζ[x/j]⟩ for some j, ζ such that
⟨e1, σ, μ⟩⇓cl(v, ξ)
By induction hypothesis on the derivation of ⇓ca for e1, there exists v, ξ and g an extension of h such that
g
⟨d1, σ, μ⟩⇓ca⟨v, ξ⟩	(v, ξ) ∼ ⟨j, ζ⟩
g
Lemma A.2 ((), ξ[σ(x)/v]) ∼ ⟨(), ζ[y/j]⟩
Proof. This is the same as lemma 4.7, and the same proof holds.	2
Using lemma A.2 and by definition of ⇓ca,
g
⟨x := d1, σ, μ⟩⇓cl((), ξ[σ(x)/v])	((), ξ[σ(x)/v]) ∼ ⟨(), ζ[y/j]⟩ = ⟨i, δ⟩
which completes this case.

Constant
If d = c then e = (h ◦ σ)(d)= c as well.
(⇒) The derivation of ⇓cl shows that (u, ν)= (c, μ), and the derivation of ⇓ca shows
h	g
that ⟨e, γ⟩ = ⟨c, γ⟩⇓ca⟨c, γ⟩. Moreover μ → γ, therefore with g = h, (c, μ) ∼ ⟨c, γ⟩
which completes this case.
(⇐) The derivation of ⇓ca shows that ⟨i, δ⟩ = ⟨c, γ⟩, and the derivation of ⇓ca

h
shows that ⟨d, σ, μ⟩ = ⟨c, σ, μ⟩⇓cl(c, μ). Moreover μ →
γ, therefore with g = h,

g
(c, μ) ∼ ⟨c, γ⟩ which completes this case.

Function application of a constant function
(⇒) If ⟨d1 d2, σ, μ⟩⇓cl(u, ν) because
⟨d1, σ, μ⟩⇓cl(f, ξ)	⟨d2, σ, ξ⟩⇓cl(c, ν)	u = f (c)


then, recalling that ⟨d1, σ, μ⟩ ∼h
(e1, γ), by induction hypothesis on the derivation

of d1, there exist j, ζ and h1 an extension of h such that


⟨e1, γ⟩⇓ca
⟨j, ζ⟩	(f, ξ) h1 ⟨j, ζ⟩


h1	h1	h
The second condition implies j = f and ξ → ζ. Moreover d2 → e2 since d2 → e2,
h
therefore ⟨d2, σ, ξ⟩ ∼ ⟨e2, ζ⟩. By induction hypothesis on the derivation of d2, there
exist k, δ and g an extension of h1 such that
g
⟨e2, ζ⟩⇓ca⟨k, δ⟩	(c, ν) ∼ ⟨k, δ⟩

g
The second condition implies k = c and ν → δ. Therefore, by definition of ⇓ca,
g
⟨e1 e2, γ⟩⇓ca⟨f (c), δ⟩	(f (c), ν) ∼ ⟨f (c), δ⟩
which completes this case.
(⇐) If ⟨e1 e2, γ⟩⇓ca⟨i, δ⟩ because
⟨e1, γ⟩⇓cl⟨f, ζ⟩	⟨e2, ζ⟩⇓cl⟨c, δ⟩	u = f (c)


then, recalling that ⟨d1, σ, μ⟩ ∼h
(e1, γ), by induction hypothesis on the derivation

of e1, there exist v, ξ and h1 an extension of h such that


⟨d1, σ, μ⟩⇓cl
(v, ξ)	(v, ξ) h1 ⟨f, ζ⟩


h1	h1	h
The second condition implies v = f and ξ → ζ. Moreover d2 → e2 since d2 → e2,
h
therefore ⟨d2, σ, ξ⟩ ∼ ⟨e2, ζ⟩. By induction hypothesis on the derivation of e2, there
exist w, ν and g an extension of h1 such that
g
⟨d2, σ, ξ⟩⇓ca(w, ν)	(w, ν) ∼ ⟨c, δ⟩

g
The second condition implies w = c and ν → δ. Therefore, by definition of ⇓ca,
g
⟨d1 d2, σ, μ⟩⇓ca⟨f (c), δ⟩	(f (c), ν) ∼ ⟨f (c), δ⟩
which completes this case.

Composition
If d = (d1; d2), then e = (e1; e2) for e1 = (h ◦ σ)(d1) and e2 = (h ◦ σ)(d2), therefore
⟨d1, σ, μ⟩ ∼h ⟨e1, γ⟩ and ⟨d2, σ, μ⟩ ∼h ⟨e2, γ⟩. (⇐) The derivation of ⇓cl for d shows that
⟨d1, σ, μ⟩⇓cl((), ξ)	⟨d2, σ, ξ⟩⇓cl(u, ν)
for some ξ. By induction hypothesis on the derivation of d1, there exist j, ζ and h1
an extension of h such that


⟨e1, γ⟩⇓ca
⟨j, ζ⟩	((), ξ) h1 ⟨j, ζ⟩


h1	h1	h
The second condition implies j = () and ξ → ζ. Moreover d2 → e2 since d2 → e2,
h
therefore ⟨d2, σ, ξ⟩ ∼ ⟨e2, ζ⟩. By induction hypothesis on the derivation of d2, there
exist i, δ and g an extension of h1 such that
g
⟨e2, ζ⟩⇓ca⟨i, δ⟩	(u, ν) ∼ ⟨i, δ⟩
Therefore, by definition of ⇓ca,
g
⟨e1; e2, γ⟩⇓ca⟨i, δ⟩	(u, ν) ∼ ⟨i, δ⟩
which completes this case.
(⇒) The derivation of ⇓ca for e shows that
⟨e1, γ⟩⇓ca⟨(), ζ⟩	⟨e2, ζ⟩⇓ca⟨i, δ⟩
for some ζ. By induction hypothesis on the derivation of e1, there exist v, ξ and h1
an extension of h such that


⟨d1, σ, μ⟩⇓cl
(v, ξ)	(v, ξ) h1 ⟨j, ζ⟩


h1	h1	h
The second condition implies v = () and ξ → ζ. Moreover d2 → e2 since d2 → e2,
h
therefore ⟨d2, σ, ξ⟩ ∼ ⟨e2, ζ⟩. By induction hypothesis on the derivation of e2, there
exist u, ν and g an extension of h1 such that
g
⟨d2, σ, ξ⟩⇓cl(u, ν)	(u, ν) ∼ ⟨i, δ⟩
Therefore, by definition of ⇓cl,
g
⟨d1; d2, σ⟩μ⇓ca(u, ν)	(u, ν) ∼ ⟨i, δ⟩
which completes this case.

if conditional
If d = (if a then d1 else d2), then e = (if b then e1 else e2) for b = (h ◦ σ)(a), e1 = (h◦σ)(d1) and e2 = (h◦σ)(d2), therefore ⟨a, σ, μ⟩ ∼h ⟨b, γ⟩, ⟨d1, σ, μ⟩ ∼h ⟨e1, γ⟩ and ⟨d2, σ, μ⟩ ∼h ⟨e2, γ⟩.
(⇐) The derivation of ⇓cl for d shows that either
⟨a, σ, μ⟩⇓cl(true, ξ)	⟨d1, σ, ξ⟩⇓cl(u, ν)
or
⟨a, σ, μ⟩⇓cl(false, ξ)	⟨d2, σ, ξ⟩⇓cl(u, ν)
For some ξ. Let us consider the case where ⟨a, σ, μ⟩⇓cl(true, ξ); the other case has a very similar proof. By induction hypothesis on the derivation of a, there exist j, ζ and h1 an extension of h such that
⟨b, γ⟩⇓ ⟨j, ζ⟩	(true	h1

ca

The second condition implies j = true
, ξ) ∼ ⟨j, ζ⟩

h1	h1	h
1	1	1	1

and ξ → ζ. Moreover d → e  since d → e ,
h1
therefore ⟨d1, σ, ξ⟩ ∼ ⟨e1, ζ⟩. By induction hypothesis on the derivation of d1, there
exist i, δ and g an extension of h1 such that
g
⟨e1, ζ⟩⇓ca⟨i, δ⟩	(u, ν) ∼ ⟨i, δ⟩
Therefore, by definition of ⇓ca,
g
⟨if b then e1 else e2, γ⟩⇓ca⟨i, δ⟩	(u, ν) ∼ ⟨i, δ⟩
which completes this case.
(⇒) The derivation of ⇓ca for e shows that either
⟨b, γ⟩⇓ca⟨true, ζ⟩	⟨e1, ζ⟩⇓ca⟨i, δ⟩
or
⟨b, γ⟩⇓ca⟨false, ζ⟩	⟨e2, ζ⟩⇓ca⟨i, δ⟩
For some ζ. Let us consider the case where ⟨b, γ⟩⇓ca⟨true, ζ⟩; the other case has a very similar proof. By induction hypothesis on the derivation of b, there exist v, ξ and h1 an extension of h such that


⟨a, σ, μ⟩⇓cl
(v, ξ)
h
(v, ξ) ∼ ⟨j, ζ⟩

The second condition implies v = true	h1
h1	h
1	1	1	1

and ξ → ζ. Moreover d → e  since d → e ,
h1
therefore ⟨d1, σ, ξ⟩ ∼ ⟨e1, ζ⟩. By induction hypothesis on the derivation of e1, there
exist u, ν and g an extension of h1 such that
g
⟨d1, σ, ξ⟩⇓cl(u, ν)	(u, ν) ∼ ⟨i, δ⟩
Therefore, by definition of ⇓cl,
g
⟨if a then d1 else d2, σ, μ⟩⇓cl(u, ν)	(u, ν) ∼ ⟨i, δ⟩
which completes this case.

while loop
If d = (while a do d1), then e = (while b do e1) for b = (h◦σ)(a) and e1 = (h◦σ)(d1), therefore ⟨a, σ, μ⟩ ∼h ⟨b, γ⟩ and ⟨d1, σ, μ⟩ ∼h ⟨e1, γ⟩. Let μ0 = μ, γ0 = γ and h0 = h.
(⇒) Let νn = ν. The derivation of ⇓cl for d shows that
⟨a, σ, μi⟩⇓cl(true, νi)	⟨d1, σ, νi⟩⇓cl((), μi+1), 0 ≤ i < n 
⟨a, σ, μn⟩⇓cl(false, νn)	u = ()
for some n ≥ 0, μ1,..., μn, ν0,..., νn−1. Let us prove by recurrence on 0 ≤ i < n 
hi	hi
that there exists hi, γi such that ⟨a, σ, μi⟩ ∼ ⟨b, γi⟩ and ⟨d1, σ, μi⟩ ∼ ⟨e1, γi⟩. The
result is already true for i = 0, let us suppose it is true for 0 ≤ i < n. By induction hypothesis on the derivation ⟨a, σ, μi⟩⇓cl(true, νi), there exist ji, δi and gi an extension of hi such that


⟨b, γi⟩⇓
h
⟨ji, δi⟩	(true	i	i	i

ca

The second condition implies j

= true
, ν ) ∼ ⟨j , δ ⟩
gi	gi

i
hi	gi
and νi
→ δi. Moreover d1 → e1 since

d1 → e1, therefore ⟨d1, σ, νi⟩ ∼ ⟨e1, δi⟩. By induction hypothesis on the derivation
⟨d1, σ, νi⟩⇓cl((), μi+1), there exist ki, γi+1 and hi+1 an extension of gi such that


⟨e1, δi⟩⇓ca⟨ki, γi+1⟩	((), μi+1)
hi+1
~ ⟨ki, γi+1⟩



The second condition implies ki = () and μi+1
hi+1
→  γi+1.	Moreover a
hi+1
→  b

since a
h
→ b and d1
hi+1
hi+1
→ e1 since d1
gi
→ e1, therefore ⟨a, σ, μi+1⟩
hi+1
~  ⟨b, γi+1⟩

and ⟨d1, σ, μi+1⟩  ∼  ⟨e1, γi+1⟩.  This completes the recurrence.  In particular,
hn
for i = n − 1, ⟨a, σ, μn⟩ ∼ ⟨b, γn⟩. By induction hypothesis on the derivation
⟨a, σ, μn⟩⇓cl(false, νn), there exist jn, δn and g an extension of hn such that
g
⟨b, γn⟩⇓ca⟨jn, δn⟩	(false, νn) ∼ ⟨jn, δn⟩

The second condition implies jn = false, therefore by definition of ⇓ca,
g
⟨while b do e1, γ0⟩⇓ca⟨(), δn⟩	(u, ν)= ((), νn) ∼ ⟨(), δn⟩
which completes this case.
(⇐) Let δn = δ. The derivation of ⇓ca for e shows that
⟨b, γi⟩⇓ca⟨true, δi⟩	⟨e1, δi⟩⇓ca⟨ki, γi+1⟩, 0 ≤ i < n 
⟨b, γn⟩⇓ca⟨false, δn⟩	i = ()
for some n ≥ 0, γ1,..., γn, δ0,..., δn−1. Let us prove by recurrence on 0 ≤ i < n 
hi	hi
that there exists hi, μi such that ⟨a, σ, μi⟩ ∼ ⟨b, γi⟩ and ⟨d1, σ⟩μi ∼ ⟨e1, γi⟩. The
result is already true for i = 0, let us suppose it is true for 0 ≤ i < n. By induction hypothesis on the derivation ⟨b, γi⟩⇓ca⟨true, δi⟩, there exist vi, νi and gi an extension of hi such that


⟨a, σ, μi⟩⇓ (vi, νi)
h
i	i	true, δi⟩

cl

The second condition implies vi

= true

and νi
(v , ν ) ∼ ⟨ 
gi
→ δi. Moreover d1


gi
→ e1 since

hi	gi
d1 → e1, therefore ⟨d1, σ, νi⟩ ∼ ⟨e1, δi⟩. By induction hypothesis on the derivation
⟨e1, δi⟩⇓cl((), γi+1), there exist wi, μi+1 and hi+1 an extension of gi such that


⟨d1, σ, νi⟩⇓cl(wi, μi+1)	(wi, μi+1)
hi+1
~ ⟨(), γi+1⟩



The second condition implies wi = () and μi+1
hi+1
→  γi+1.	Moreover a
hi+1
→  b

since a
h
→ b and d1
hi+1
hi+1
→ e1 since d1
gi
→ e1, therefore ⟨a, σ, μi+1⟩
hi+1
~  ⟨b, γi+1⟩

and ⟨d1, σ, μi+1⟩  ∼  ⟨e1, γi+1⟩.  This completes the recurrence.  In particular,
hn
for i = n − 1, ⟨a, σ, μn⟩ ∼ ⟨b, γn⟩. By induction hypothesis on the derivation
⟨b, γn⟩⇓ca(false, νn), there exist vn, δn and g an extension of hn such that
g
⟨a, σ, μn⟩⇓cl(vn, νn)	(vn, νn) ∼ ⟨false, δn⟩
The second condition implies vn = false, therefore by definition of ⇓cl,
g
⟨while a do d1, σ, μ0⟩⇓ca((), νn)	((), νn) ∼ ⟨(), δn⟩ = ⟨i, δ⟩
which completes this case and the proof.	2
