Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 335 (2018) 67–90
www.elsevier.com/locate/entcs
Unfolding of Parametric Boolean Networks
Juraj Kolˇc´aka,b David Sˇafra´nekb,1 Stefan Haara Lo¨ıc Paulev´ec
a Inria and LSV
E´cole Normale Sup´erieure de Cachan and CNRS Cachan, France
b Systems Biology Laboratory (Sybila) Masaryk University
Brno, Czech Republic
c LRI UMR CNRS 8623
Univ. Paris-Sud – CNRS, Universit´e Paris-Saclay Orsay, France

Abstract
In systems biology, models of cellular regulatory processes such as gene regulatory networks or signalling pathways are crucial to understanding the behaviour of living cells. Available biological data are however often insufficient for full model specification. In this paper, we focus on partially specified models where the missing information is abstracted in the form of parameters. We introduce a novel approach to analysis of parametric logical regulatory networks addressing both sources of combinatoric explosion native to the model. First, we introduce a new compact representation of admissible parameters using Boolean lattices. Then, we define the unfolding of parametric Boolean networks. The resulting structure provides a partial- order reduction of concurrent transitions, and factorises the common transitions among the concrete models. A comparison is performed against state-of-the-art approaches to parametric model analysis.
Keywords: Boolean networks, parameters identification, asynchronous systems, concurrency, systems biology

Introduction
One of the main problems studied in computational systems biology is understand- ing of intracellular molecular interactions, often represented as networks. Two par- ticular classes of processes are predominantly modelled, gene expression regulation (gene regulatory networks) and cell signalling [13].
The prime interests of gene regulatory networks are gene-protein and gene-gene interactions, the latter are generally facilitated by the proteins they encode. Cell sig- nalling models usually consist of one or several signalling pathways. In simple terms chains of proteins provide information flow by means of sequential phosphorylation until some cellular process (such as gene expression) is influenced.

1 This work has been partially supported by the Czech Science Foundation grant No. GA15-11089S.

https://doi.org/10.1016/j.entcs.2018.03.009
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Although both of the described processes are quantitative in their nature, it is often the case that precise kinetic parameters of the reactions are unknown in biological context. As such, it is common to model genetic regulatory networks and signalling pathways by discrete models (logical regulatory networks) [1,6,15,18,19]. In the context of gene regulatory networks and signalling pathways it is often the case that one-to-one influences between species are known from in vitro experiments. The results of combinations of those influences are, however, largely unknown. In other words, it may be known that two species have both positive influence on the activity/population of a third species. However, it is rarely known if both of the activators must be present to activate the target or if just one is sufficient. In general, an arbitrary logical function may govern the joint influences. To cope with the problem technically, the individual target values of a species in possible
combinations of their regulators activity are considered as unknown parameters.
The analysis of parametric regulatory networks (PRNs) is hindered by dual com- binatorial explosion. Not only is the state space exponential in size of the networks, but the number of parametrisations is in the worst case doubly exponential in num- ber of species. Combination of those factors often leads to the fact that analysis techniques of PRNs do not scale to larger networks.
Our Contribution. We introduce a new analysis framework for parametric lo- gical regulatory networks addressing combinatorial explosion on two levels. First, we propose a novel encoding of parametrisations using the inner structure of pa- rametrisations. The encoding is applied to mitigate the combinatorial explosion induced by parametrisations. Accompanying methods are provided allowing for ef- ficient use of the encoding. Second, we extend Petri net unfoldings to accommodate for the parametric setting. The unfoldings are coupled with the encoding method for parametrisations to allow for compact representation of state space of the PRNs thanks to their ability to exploit concurrency. Finally, a prototype implementa- tion is provided to compute the introduced unfoldings. Experiments are conducted comparing the results of our methods against state-of-the-art methods in parametric regulatory network analysis.
Related Work. The analysis of logical regulatory networks under parameter un- certainty is a field not yet largely explored. Recently, it is gaining popularity thanks to the importance and great promise to the field of systems biology. Computational Tree Logic (CTL) [2] has been used to enumerate all possible temporal properties (parametrisations) of Thomas networks, by Bernot et al. [4]. Methods based on LTL model checking [2] have also been introduced for Thomas networks [14,10]. In [14] the method called coloured model checking first introduced in [3] is used to capitalise on many parametrisations sharing some parts of their behaviour. The parametrisations are represented by colours (bits) in a binary vector and the model checking is extended to binary vector operations to keep track of the satisfying behaviours.
The approach in [10] explores the state space represented symbolically in form of execution trees. This approach is closest to our work since the symbolical represent- ation of state space employed in [10] is acyclic, similar to unfoldings. Furthermore,

encoding of parametrisations is also performed in [10] using logical formulas. Con- trary to our fixed-size encoding, however, the formula used in [10] continues to expand during the exploration as more detailed encoding of parametrisations is required.
Work was also done using constraint logic programming for parameter identific- ation [5,9], again using Thomas networks. The approach in [5] encodes all available biological knowledge into logical constraints on the behaviour of the network while in [9] the constraint logic programming is used to pre-process the initial set of be- haviours to filter out those in conflict with the constraints. Model checking is used on the smaller (filtered) set afterwards.
Ostrowski et al. [17] also introduce a method for restricting the initial set of possible behaviours for Boolean networks. Logical constraints are derived from time series data and answer set programming (ASP) is applied to compute a set of transient dynamics (parametrisations) best fitted to the measurements.
Paper Structure. In Section 2 we introduce the parametric regulatory networks including their semantics and parametrisation. Section 3 further expands the model by labels on the influences used to incorporate prior knowledge into the model. In Section 4 we address the potentially double exponential number of parametrisations by introducing a new encoding of parametrisations. This encoding is subsequently applied for unfoldings of parametric regulatory networks in Section 5. Section 6 fea- tures experimental results using the parametric unfoldings and comparison against methods relying on execution trees [10] is provided.

Parametric Regulatory Networks
In this section, we introduce parametric regulatory networks (PRN). Informally one can consider PRN as a standard regulatory network with unknown dynamics, namely transition relation. We can therefore capture the topology of a PRN using a directed graph, so-called Influence Graph, G = (V, I) where V is the set of n vertices (components) and I ⊆ V ×V is the set of directed edges (influences). We denote the set of all in-neighbours (regulators) of some v ∈ V as n−(v)= {u ∈ V | (u, v) ∈ I} and the set of all out-neighbours (targets) as n+(v) = {u ∈ V | (v, u) ∈ I}. The influence graph of our running example can be seen in Figure 1.

Figure 1. The influence graph of a simple three node regulatory network. We will further use this influence graph for our running example.


		
Table 1
The truth tables for the nodes of the running example influence graph depicted in Figure 1. Truth tables for all three nodes: a,b and c are listed left to right.

Generally, every component v ∈ V is considered as a variable with a finite discrete domain (multivalued). In the scope of this article we limit ourselves to Boolean settings. Extension to multivalued variables is considered as further work. In the case that every variable v ∈ V is Boolean we denote the PRN as a parametric Boolean network (PBN).
Viewing the components of the interaction graph as variables allows for a natural definition of a state of the PBN. By a state X of G = (V, I) we mean any subset of
V (X ⊆ V ). We say that any component v ∈ V is active (has value 1) in state X if v ∈ X and, respectively, v is inactive (has value 0) if v ∈/ X. We denote the set of all possible states as X = 2V .
The nature of the interactions depends on the activity levels of the components in a given state. However, it is often the case in biology that exact effects of regulators on their targets are unknown. We therefore abstract these values by means of parameters.
A parameter represents a value of the target assigned to a given combination of active and inactive regulators as determined in the particular state. Naturally, there exists a parameter for any such combination of regulators. We denote such a combination as regulatory context (RC). Formal definition follows.
Definition 2.1 A regulatory context ω of component v ∈ V is an arbitrary subset of the regulators of v. Formally, ω ⊆ n−(v). Just as with the states of PBN we say that all components u ∈ ω are active and all components u ∈ n−(v) \ ω are inactive. The set of all combinatorially possible regulatory contexts of v will be further

denoted as Ωv
= 2n−(v).

In that way, RCs correspond to the rows of the truth table for each component. The truth tables with the RCs and parameters for our running example can be seen in Table 1.
Every parameter (RC) can be assigned a target value 0 or 1. We denote such an assignment for all RCs as parametrisation.
Definition 2.2 A parametrisation P ⊆ Ω, with Ω = Sv∈V ({v}× Ωv), associates regulatory contexts to each component. We say that the target value of RC ω of component v under parametrisation P is 1 iff (v, ω) ∈ P . We write ω ∈ P instead of (v, ω) ∈ P whenever the target v is known from the context.

We denote the set of all possible parametrisations of an influence graph G = (V, I) as PG = 2Ω.
A PBN B is thus an influence graph G equipped with possible parametrisations:

Definition 2.3 A Parametric Boolean Network (PBN) B is a couple (G, P) where G is an influence graph, and P ⊆ PG with P /= ∅ is a non-empty set of possible parametrisations of G.
If P = PG, then we say that B is fully parametric. On the other hand, if |P| = 1, then B is a simple Boolean network.
Finally, we can define the dynamics of the PBN. As we already mentioned, the dynamics of a PBN equipped with a single parametrisation is identical to stand- ard Boolean networks. There are, however, several ways to define dynamics of a Boolean network from the synchrony perspective. In the biological setting the indi- vidual reactions are often temporally independent from each other and no explicit synchrony exists. In the scope of this paper, we consider the usual asynchronous semantics of Boolean networks, where at most one component gets updated at a time.
The asynchronous dynamics are generally non-deterministic, however, it can be easily captured by means of the so-called state transition graph (STG) S = (X, δ) where δ ⊆ X × X is the state transition relation given by target values of RCs. Intuitively, the STG of a PBN B = (G, P) can be considered a natural composition (union on transitions) of STGs of Boolean networks (G, {P}) for every P ∈ P. More formally, due to the asynchrony we only consider transitions between states that differ in exactly one element. Let X1, X2 ∈ X be two states that differ in a single element v ∈ V (X1 \ X2 = {v}, respectively X2 \ X1 = {v}). The transition (X1, X2) belongs to δ only if at least one parametrisation exists that can reproduce it. More formally, for the case where v is assigned activity value 0 (X1 \ X2 = {v}) we require ∃P ∈ P : (n−(v) ∩ X1) ∈/ P . For the case where v is assigned activity value 1 (X2 \ X1 = {v}) we require ∃P ∈P : (n−(v) ∩ X1) ∈ P .

Labels on Edges of Influence Graphs
In the previous section, we introduced PBNs and mentioned that the cause of para- meter uncertainty comes from the lack of information on biological interaction. The information is, however, often partially available. Part of the biological knowledge can be compiled into two types of conditions on the edges of the influence graph: monotonicity and observability.
Monotonicity comes in two forms, either as plus-monotonicity or the dual minus- monotonicity. An edge (u, v) ∈ I is plus-monotone under parametrisation P iff
∀ω ∈ Ωv : u ∈ ω ⇒ (ω ∈ P ∨ ω \ {u} ∈/ P ). Analogically, an edge (u, v) ∈ I is minus-monotone under P iff ∀ω ∈ Ωv : u ∈ ω ⇒ (ω ∈/ P ∨ ω \ {u} ∈ P ). In other words, an edge is plus-monotone if the increase in the activity of the source cannot

o-	o-
Figure 2. An example of a labelled influence graph (LIG) obtained by introducing a labelling function
γ = {((a, a), {−, o}), ((b, b), {−, o}), ((a, c), {+, o}), ((b, c), {+, o})}. The labelling strictly determines the Boolean function governing the self-regulation of a and b. In fact, from the initial 28 = 256 parametrisations
of the running example, only two parametrisations are possible with the labelling. Also notice that with the labelling γ every interaction of the running example is both observable and monotone. We refer to such labelling function as full labelling and to LIG with full labelling as fully labelled.

cause a decrease in the activity of the target and minus-monotone if the increase in the activity of source cannot cause an increase in the target activity.
On the other hand, an edge (u, v) ∈ I is observable under parametrisation P if
∃ω ∈ Ωv : |{ω \ {u},ω ∪ {u}} ∩ P| = 1. In other words, an edge is observable if there exists a combination of regulators such that the change in the activity of the source causes a change in the activity of the target.
Naturally, monotonicity and observability may be used to restrict possible pa- rametrisations. We therefore equip the influence graph with a labelling function γ : I → 2{+,−,o} specifying the conditions imposed on every edge. A Labelled Influ- ence Graph (LIG) is thusa tuple G = (V, I, γ). The set of possible parametrisations of G is {P ∈ P(V,I) | ∀i ∈ I : P satisfies the conditions imposed by γ(i)}. An example of a labelling function and a LIG is given in Figure 2 using the running example as the original influence graph.
Parametrisation Encoding
In previous sections, we introduced the concept of parametrisation of Boolean net- works and natural constraints to implement partial knowledge about the model. In practice, however, known methods are not scalable when applied to PBNs as intro- duced due to combinatorial explosion. In fact, the combinatorial explosion occurs for PBNs in two instances. First the state space is exponential in the number of components (note X = 2V ). The state space explosion affects as well standard Boo- lean networks and equivalent models (this is addressed more closely in Section 5). Second, the number of possible parametrisations is also exponential with the RCs (PG = 2Ω). In this section, we dedicate ourselves to the second cause of combinator- ial explosion, the number of parametrisations. Here we introduce a novel approach to encode some special sets of parametrisations relevant for our application.
The need to encode parametrisations is required especially for generating pro- cesses (possible behaviours) of the PBN. Although processes may be infinite, any reachable state is reachable by at least one finite process. We therefore only require

finite processes to be reachability-complete. A formal definition follows.
Definition 4.1 Let (G, P) bea PBN with STG (X, δ). A process of length k ∈ N is a sequence of states π = (X1,..., Xk) ∈ Xk where ∀i ∈ {1,...,k − 1} : (Xi, Xi+1) ∈ δ.
Let π = (X1,..., Xk) be a process and X ∈X be a state such that (Xk,X) ∈ δ.
Then πj = π · X is a process of length k +1 and we say πj is an extension of π.
PBNs represent several different model possibilities introduced by individual parametrisations. Whereas the individual parametrisations should be exclusive, the dynamics of a PBN (given by its STG) do not distinguish them. It is therefore possible to have processes in the PBN which mix different parametrisations. These processes may not correspond to a process of any individual parametrisation. In order to avoid exploring such incoherent processes we assign to every process (viewed either as a sequence of transitions, or as a partially ordered multi-set of transitions) a set of admissible parametrisations.
Let (G, PG) be a PBN and (X1, X2) ∈ δ a transition of the respective STG such that X1 \ X2 = {v} for some v ∈ V . We call such a transition the inhibition of v. Every parametrisation that allows the inhibition of v in state X1 must necessarily assign the target value of X1 ∩n—(v) to 0. Furthermore, it is sufficient for the target value of X1 ∩ n—(v) to be fixed to 0 for the parametrisation to allow transition (X1, X2). We apply a similar reasoning to activations (X2 \ X1 = {v} for some v ∈ V ). An activation requires the associated RC X1 ∩n—(v) to have target value 1. As such, we can define an associated regulatory context of a transition d = (X, Xj) ∈ δ as ωd = n—(v) ∩ X where {v} = X Δ Xj (by Δ we mean symmetric difference).
Any transition changes the value of exactly one component. Thus any transition is either exclusively an activation or an inhibition of some component. An arbitrary set of transitions D ⊆ δ is therefore uniquely given as the union of set of inhibitions DI and set of activations DA (D = DA ∪ DI ). We now formalise the notion of feasible parametrisations of any set of transitions under the notion of parameter context (PC).
Definition 4.2 Let (G, P) be a PBN with STG (X, δ). We define a function p : 2δ → 2r that assigns to every set of transitions the set of parametrisations that allow all of the transitions. Formally, given any D ⊆ δ, we set p(D)= {P ∈ P|∀d ∈ DA : (ωd ∈ P ) ∧ ∀d ∈ DI : (ωd ∈/ P )} where DA and DI are sets of activations and inhibitions (respectively) such that DA ∪ DI = D. We call p(D) the parameter

context of D for any D ⊆ δ. One can remark that p(D)= 

d∈D
p({d}).

We extend the definition to processes in a natural fashion. Let π = (X1,..., Xk)
be a process. By PC of π we mean p(π)= p({(Xi, Xi+1)|i ∈ {1,...,k − 1}}).
A naive approach to computing the PC as defined above could be to enumerate all exponentially many parametrisations. It is, however, precisely thanks to PG = 2Ω that by introducing the set-inclusion order to parametrisations, we obtain a Boolean lattice (PG, ⊆). We now provide intuition behind the use of lattices for PC encoding. Let us consider a fully parametric PBN (G, PG). As was mentioned above, the


	
(A)	(B)

Figure 3. Hasse diagrams of the lattices representing parameter contexts for the regulation of component c in the unlabelled running example. (A) The PC of transition ({c}, ∅), i.e., p({({c}, ∅)}). (B) The restricted PC after transition ({b, c}, {b}) is included (p({({c}, ∅), ({b, c}, {b})})).

PC of arbitrary single transition d only contains parametrisations that set target value of ωd to the same value. If d is an inhibition of some v ∈ V , then we know ∀P ∈ p({d}) : ωd ∈/ P . Keeping the set-inclusion order in mind the largest parametrisation in p({d}) is Ω \ {(v, ωd)}. In fact, p({d}) is a prime ideal of the lattice (PG, ⊆) with sole principal (maximal) element Ω \ {(v, ωd)} (an ideal I of lattice L is prime if it is proper and for any a, b ∈ L such that a ∧ b ∈ I either a ∈ I or b ∈ I holds). Analogously, if d is an activation of some v ∈ V , then the PC p({d})= {P ∈ PG|ωd ∈ P} is a prime filter of (PG, ⊆) with sole principal (minimal) element {(v, ωd)} (a filter is prime under the same conditions as an ideal but instead of infimum (∧), supremum is used (∨)).
Since p(D ∪ Dj) = p(D) ∩ p(Dj) (Def. 4.2), one can remark that the PC of any set DI ⊆ δ such that ∀d ∈ DI : d is an inhibition is an ideal of (PG, ⊆). Respectively, the PC of any set of activations DA ⊆ δ is a filter. It is well known that the intersection of an arbitrary ideal and arbitrary filter is either empty or a convex sub-lattice. Moreover, any convex sub-lattice can be uniquely represented by intersection of an ideal and a filter [12]. This allows us to represent any convex sub-lattice of (PG, ⊆) by only the maximal element (ideal) and minimal element (filter). As any set of transitions can be split into a set of inhibitions and a set of activations, it is clear that any PC can be encoded by minimal and maximal elements. An example of the PCs represented as convex sub-lattices is visualised in Figure 3.
The results we have provided hold for fully parametric PBN (G, PG). In case of a LIG G, however, the lattice (PG , ⊆) is not guaranteed to exists. This is as there may exist two parametrisations in PG such that their infimum (supremum) does not belong to PG . For illustration consider the running example with one observable interaction, e.g. labelling γ = {((a, c), {o})}. The interaction (a, c) is observable under parametrisations {(c, ∅)} and {(c, a)} and thus both {(c, ∅)}, {(c, a)} ∈ PG . No interaction is observable under the intersection (infimum) ∅ = {(c, ∅)}∩ {(c, a)} and namely (a, c) is not observable meaning ∅ ∈/ PG .
To address this issue we propose an over-approximation of a PBN B = (G, PG ) constructed as Bj = (G, [PG ]) where we use [P] to denote the smallest convex sub-

lattice such that P ⊆ [P]. On a similar note, we introduce an over-approximative PC pj : 2δ → 2rG such that pj(D) = [p(D)] or pj(D) = ∅ if p(D) = ∅. The labelling function γ introduces dependencies between target values of individual RCs and therefore computing pj(D) ∩ pj(Dj) may not be sufficient to obtain the correct pj(D ∪ Dj) contrary to p. However, we can resolve this issue with the following method.
Our method relies on knowledge of pj(π) for some process π = (X1,..., Xk) to compute the PC of an arbitrary extension π · X where X ∈X is a compatible state. Since we know that p(π · X) ⊆ p(π) and in conjecture pj(π · X) ⊆ pj(π) the PC of the extension can only be smaller than the PC of π. The method thus continuously removes elements from pj(π) until [p(π·X)] is reached. The elements are removed by successively applying restrictions. A restriction is the combination of a regulatory context ω ∈ Ωv for some v ∈ V and a value i ∈ {0, 1}. A restricted PC is then a PC P such that ∀P ∈ P : ω ∈ P if i = 1 and ω ∈/ P if i = 0. In other words, a restriction ensures all parametrisations in the restricted PC to have the same target value for a given RC.
The method recognises two causes of restriction. First, the extension itself re- quires the transition (Xk,X) to be allowed. Second, the edge labels introduce dependencies between target values of individual RCs. The method detects these dependencies and restricts the PC accordingly. For a more detailed explanation of the method see Appendix A.1.
One of the most important properties of the method is the preservation of reachability. Since the method guarantees that pj(π · X) = [p(π · X)] and namely pj(π · X) = ∅ if p(π · X) = ∅, any process π such that pj(π) /= ∅ is guaranteed to also have p(π) /= ∅ and vice versa. This property becomes important in Section 5 where we construct a compact representation of reachable state space. Thanks to the reachability being preserved any state reached by the over-approximation pj is guaranteed to be also reachable by p and vice versa. This allows us to compute the reachable states within the over-approximation pj. Reachability is, however, only guaranteed to be preserved if the input pj(π) of the method is correct. Cases exist where the initial [PG ] /= PG. A pre-computation is therefore necessary to determine [PG ]. The pre-computation itself is detailed in Appendix A.2.

Parametric Unfolding
Previously, we introduced an encoding of parametrisations to alleviate the com- binatorial explosion induced by all possible combinations of RCs. In this section we address the combinatorial explosion of the state space of PBNs and standard Boolean networks accordingly. Biological networks are often considerably sparse in nature and contain a high amount of concurrent interactions. Partial order reduc- tion approaches are therefore meaningful for dealing with the state space explosion in case of standard networks. Petri net unfoldings are a prime example of a struc- ture exploiting the concurrency of transitions. This section is therefore dedicated to application of unfoldings to PBNs and parametric setting in general.

We will now introduce unfoldings for PBNs using the PCs given by pj. Intuitively, the unfolding is an acyclic (tree-like) representation of all the processes of the PBN starting in a given initial state. Although an equivalent Petri net can be constructed for any PBN, we do not require this Petri net explicitly to be able to unfold the PBN. We define the (parametric) unfolding of a PBN as an event structure. Hence, our construction is similar to Petri net unfoldings [8,7]. The only difference is the source of the events, in our case the PBN versus a Petri net. Thus, PBN unfolding and Petri net unfolding are structurally identical. A special treatment was required for construction of complete finite prefixes of the PBN unfoldings when determining which branches can be cut-off without loss of reachability.
In general, an event structure is a triplet E = (E, ≤, #) where E is the set of events, ≤⊆ E × E is a partial order relation on E called causality relation and # ⊆ E×E is an antisymmetric, irreflexive relation called conflict relation satisfying:
∀e ∈ E : {ej ∈ E | ej ≤ e} is finite.
∀e, ej, ejj ∈ E : (e#ej ∧ ej ≤ ejj) ⇒ e#ejj.
For our purposes we extend the event structure by a set of conditions B (we adopt the Petri net unfolding notation) to provide better intuition behind causality and conflict relations in our setting. First let us define the set of all events E and conditions B possible for a given PBN. As the definitions of events and conditions are interdependent, we define a hierarchy of sets Ei and Bi. First let B0 = {(⊥, v, j) |

v ∈ V ∧ j ∈ {0, 1}}. We then define Ei = {(β, v) | v ∈ V ∧ β ⊆ S
j∈{0,...,i—1}
Bj ∧

β ∩ Bi—1 /= ∅} and Bi = {(e, v, j) | v ∈ V ∧ j ∈ {0, 1}∧ e ∈ Ei} for all i ∈ N. The

desired E = S
Ei and B = S

i∈N0
Bi thus become the infinite unions.

Every condition b ∈ B is of the form b = (e, v, i), where e ∈ E ∪ {⊥} is a predecessor (parent) event of b if it exists, or ⊥; otherwise, v ∈ V is the component of PBN represented by condition b and i ∈ {0, 1} is the value of v in b. Intuitively, a condition represents the possibility of a process reaching a state where component v has value i by following event e. Analogically, every event e ∈ E is of the form e = (β, v) where β ⊆ B is the set of predecessors (preset ) of e and v ∈ V is the component whose value changes by firing e. Intuitively, an event e represents the possibility of component v changing value under influence of regulators in β.
Events closely resemble the transitions of the STG (δ). In fact, if the event
e = (β, v) is well-formed (satisfies n—(v) ∪ {v} = {u | (ej, u, i) ∈ β} and |n—(v) ∪
{v}| = |β|) we can define an associated RC ωe = {u ∈ n—(v) | ∃(ej, u, i) ∈ β : i = 1} much like for transitions. We can also make a distinction between activations and inhibitions between the events. We say that an event e = (β, v) is an activation of v if ∃(ej, v, 0) ∈ β and analogously, e is an inhibition of v if ∃(ej, v, 1) ∈ β. Any well-formed event is exclusively either activation or inhibition. This allows us to extend the PC function p and in turn also pj to well-formed events in the natural fashion. Formally, let E ⊆ E be a set of well-formed events. Then p(E)= {P ∈P |
∀e ∈ EA : (ωe ∈ P ) ∧ ∀e ∈ EI : (ωe ∈/ P )} where EA is a set of activations and EI
is a set of inhibitions such that E = EA ∪ EI .
We can now define causality and conflict relations. Let e, ej ∈ E be arbitrary.

We say that event e = (β, v) is causally dependent on event ej = (βj, u) (ej ≤ e) if e = ej or there exists b = (ejj, w, i) ∈ β such that ej ≤ ejj. In other words, e is causally dependent on ej if there exists a directed path from e to ej defined by the parents and presets of conditions and events. If ¬(e ≤ ej) and ¬(ej ≤ e) we say that e and ej are causally independent. Similarly, e is in conflict with ej (e#ej) if there exist events (β, v), (βj, u) ∈ E such that (β, v) /= (βj, u), (β, v) ≤ e, (βj, u) ≤ ej and β ∩ βj /= ∅. In other words, two events are in conflict if they (or their causal predecessors) use the same condition by two different events.
We can also naturally extend the relations of causality and conflict to conditions simply by setting ∀(β, v) ∈ E : ∀b ∈ β : b < (β, v) and ∀(e, v, i) ∈ B : e < (e, v, i) and computing the reflexive and transitive closure. The conflict relation is adjusted extending its domain to E ∪ B. Additionally, let x, y ∈ E ∪ B such that x and y are causally independent and not in conflict. We then say x and y are concurrent.
One can notice that (B, E, ≤, #) may not be an extended event structure as it is not guaranteed to satisfy the constraints on the causality and conflict relations. We therefore construct the unfolding using subsets of B ⊆ B and E ⊆ E on which the relations ≤ and # satisfy the desired properties. Let (G, PG ) be a PBN with STG (X, δ) and X0 ∈ X an initial state. Then the unfolding U = (B, E, ≤, #) of (G, [PG ]) in state X0 is constructed as follows.
Start with empty B = ∅ and E = ∅.
For every v ∈ V add a condition (⊥, v, i) to B such that i = 1 if v ∈ X0 and
i = 0 otherwise.
For every v ∈ V find all sets C ⊆ B of concurrent conditions (cosets) such that
{u | (e, u, i) ∈ C} = n—(v) ∪ {v} and |C| = |n—(v) ∪ {v}|. For every such C create an event e = (C, v). If e ∈/ E then compute pj(e) using the algorithm in Appendix A.1. If pj(e) /= ∅ add e to the set E and for every (ej, u, i) ∈ C add new condition b = (e, u, j) to B where j = i if u /= v and j = (1 − i) for u = v. If at least one event was added to E repeat step (iii).

Although B and E are subsets of B and E it is apparent from the construction of the unfolding that they are infinite in the general case. We have mentioned in Section 4 that any reachable state is reachable by a finite process. As the unfolding is a representation of all the processes of the network and the number of states is finite, there exist finite prefixes of the unfolding from which all the reachable states can be recovered. We refer to such a prefix as a complete ﬁnite preﬁx (CFP), and show below a possible construction. First, we define an equivalent of a process within the unfolding traditionally referred to as configuration.

Definition 5.1 A set C ⊆ E is a configuration if it is conflict free (∄e, ej ∈ C : e#ej) and causally closed ∀ : e ∈ C, ej ∈ E : ej ≤ e ⇒ ej ∈ C.
By [e] we denote a special configuration called local configuration of e, [e] = 
{ej ∈ E | ej ≤ e}.
Any configuration C corresponds to at least one process of the PBN given by completing the partial order on the transitions equivalent to events in C. We can

therefore assign to every finite configuration a terminal (final) state XC = X0 Δ
{v1} Δ ··· Δ {vk} where C = {e1 = (β1, v1),..., ek = (βk, vk)} and k ∈ N0.
Let C be a configuration and F ⊆ E such that C ∩ F = ∅. We say that F is an extension of C if C ∪ F is a configuration. Let us now consider all possible extensions of C. Any extension of C corresponds to a process in the original PBN starting in state XC and every such process is represented by an extension. As such, we can see that all extensions of C define an unfolding of the PBN in state XC and initial parametrisation pj(C). Furthermore, any extension possible in P ⊆ pj(C) is also possible under pj(C).
Let us now consider two configurations C, Cj ⊆ E such that XC = XC′ and pj(C) ⊆ pj(Cj) and an extension F ⊆ E of C. Since F is an extension of C it surely belongs to the unfolding of the PBN in state XC with pj(C) and namely





Figure 4. The complete finite prefix obtained by unfolding the running example equipped with full la- belling function as illustrated in Figure 2. The complete finite prefix is visualised as a Petri net. The conditions, labelled by the component they represent and the value of the component (vi for (e, v, i)), are represented by circles. The events, labelled by numbering (ei for the i-th event), are represented by rect-
angles. Cut-off events are additionally marked with dashed borders. Notice that the order of concurrent activation/inhibition of species a and b is abstracted.

it also belongs to the unfolding in XC with pj(Cj). Unfolding of a PBN is given uniquely by an initial state and set of feasible parametrisations. The unfolding in XC with pj(Cj) must therefore be isomorphic to the unfolding in XC′ with pj(Cj). And especially, there must be an extension Fj ⊆ E of Cj isomorphic to F . This holds for any extension of C meaning any information captured by the extensions of C is already covered by extensions of Cj and is redundant from the reachability point of view.
This result is interesting especially for local configurations. Let e, ej ∈ E be such that X[e] = X[e′] and pj([e]) ⊆ pj([ej]). As there is no need to explore extensions of
[e] we omit them from the CFP. We formalise this by the notion of cut-off events.
Once an event e is marked cut-off, no other event ej ∈ E such that e < ej is added to the CFP. Esparza et al. [8] show for Petri net unfoldings that a specific order on the configurations called adequate order is required to guarantee that no reachability is lost by cut-offs. As our unfolding notion is equivalent to Petri net unfoldings we have the same requirement on the order. By ≺ we will further understand the total adequate order as defined in [8] adjusted for our definition of unfolding (see Appendix B for a definition). A formal definition of a cut-off event follows.
Definition 5.2 An event e ∈ E is considered a cut-off event if there exists a dif- ferent event ej ∈ E such that X[e] = X[e′], [ej] ≺ [e] and pj([e]) ⊆ pj([ej]).
The total adequate order ≺, however, does not correlate with inclusion order over PCs. In other words, C ≺ Cj does not guarantee p(Cj) ⊆ p(C) and vice versa. As such a situation may occur where local configurations of two events e, ej ∈ E lead to the same state X[e] = X[e′] and p([e]) ⊆ p([ej]) also holds. Ideally, in such a situation, the extensions of e should not be explored as they are all redundant with some extensions of ej. However, due to [e] ≺ [ej], e will not be designed as cut-off (as ej does not exist yet) and some extensions of e may have been explored before ej. In our algorithm, when ej is added to the CFP, e is marked as cut-off, and we remove its (unnecessarily explored) extensions.
Standard complete finite prefixes of Petri nets computed using a total adequate order for extensions have a number of non-cut-off events which does not exceed the size of the marking graph (state space) of the Petri net [8]. This claim does not hold in our setting, because several events with the same marking can exist in our CFP of PBNs (the cut-offs depend also on the PC). However, because of the resulting partial ordering of transitions in the CFP, one can easily argue that the number of processes in the CFP is smaller than the number of traces in the STG.
The CFP computed for the fully labelled version of the running example is shown in Figure 4.

Experiments
In this section we present some initial results on biological models and compare with the symbolic representation employed in [10]. The results have been obtained

by a prototype implementation in Python of a parametric unfolder named Pawn. 2 The comparison is done regarding the size of the structure representing all the possible traces. We therefore compare the size of the unfolding – typically represen- ted as the number of non-cut-off events with the number of states in the complete symbolic execution tree, obtained with the tool SPuTNIk [10]. Therefore, the differ- ence accounts for the partial-order reduction implicitly achieved by the unfolding,
in the scope of Parametric Biological Regulatory Networks.
The experiments were conducted for two different biological models. First we use a boolean model of the gene regulatory network underlying mammalian cortical area development [11]. The model is depicted in Figure 5 (A). The reachable state space has been explored with respect to two defferent initial states. First, all species has been considered inactive. Second, all species has been considered inactive with the only exception of Fgf8.

(A)	(B)

Figure 5. (A) A genetic regulatory network controlling the cortical area development. The state marked in blue has been set to initial value 1 in one of the experiments. (B) Model of signalling pathway of EGF-TNFα. The only two states that start with initial value 1 are marked in blue.

The second model is a signalling pathway, EGF-TNFα, as studied in [16,17] (Figure 5 (B)). In this case the initial state was for every specie inactive save for the two input species, tnfa and egf , which were active (X = {tnfa, egf }). The results are summarised in Table 2. The execution times for Pawn were less than a second (∼ 0.4s) and around 8.5 seconds for the bacteriophage λ (both variants) and EGF-TNFα respectively. SPuTNIk on the other hand took ∼ 1 min and ∼ 10 min for the bacteriophage λ with and without Min/Max respectively, and ∼ 30 min for EGF-TNFα.
Although no theoretical estimate on the size of the parametric unfolding can be given, it is apparent from the results that exploiting the concurrency allows for considerably smaller representations of the parametric state space in practice. The difference in size is derived mainly from the capability of the unfoldings to

2 Pawn is available online: https://github.com/GeorgeKolcak/Pawn


Table 2
Comparison of the size of the obtained structures between unfolding and the symbolic representation for different models.

exploit concurrency. Therefore, if there are n different concurrent transitions firing, unfolding does not distinguish the order in which they are fired and only explores one possibility. The symbolic execution on the other hand explores all n! possible firing sequences only to obtain the same result each time. This is especially apparent in sparse networks that contain a high number of concurrent transitions.
In case of the two initial conditions experimented in the cortical development model, the same state space is reachable. However, different sizes of unfoldings in the two cases show that our technique is sensitive with respect to the concrete initial state determining the construction of the unfolding.
Conclusion
We offer a new platform for parameter identification of logical regulatory networks based on Petri net unfoldings. Our contribution addresses several issues. First, we introduce a novel approach to encoding parametrisations allowing for efficient analysis of parametric Boolean networks. We employ the encoding in practice for computing feasible parametrisations for all possible behaviours of the system. Ac- companying methods are also presented for efficiently computing the feasible para- metrisations of extensions of behaviours within the encoding. This set of parame- trisations can be efficiently constrained by monotonous and observability criteria. Future work may also consider taking into account other constraints, such as the existence of particular fixed points. Although only an over-approximation of the set of feasible parametrisations is given in the general case, reachability preservation is guaranteed by our method. The refinement of the over-approximation is considered for future work.
Next we analyse the possibility of using Petri net unfoldings to exploit con- currency in parametric models of biological networks. We present a modification to allow for unfolding of parametric Boolean networks and couple the unfoldings with the encoding of parametrisations to neutralise both sources of combinatorial explosion in parametric regulatory networks.
In this article, the presentation of the framework is focused on Boolean networks. The formalization of an extension of our parameter space encoding and unfolding to parametric multivalued regulatory networks is currently under investigation.
Last but not least, we provide a prototype implementation of the introduced methods and compare with existing methods on relevant biological examples. The comparison proves our methods capable of representing the reachable state space of parametric regulatory networks in much smaller structures than previous ap- proaches. This compression opens the possibilities of efficient further analysis of

parametric networks via the parametric unfoldings.

References
Albert, R. and H. G. Othmer, The topology of the regulatory interactions predicts the expression pattern of the segment polarity genes in Drosophila melanogaster, Journal of Theoretical Biology 223 (2003),
pp. 1 – 18.
Baier, C. and J. Katoen, “Principles of Model Checking,” MIT Press, 2008.
Barnat, J., L. Brim, A. Krejci, A. Streck, D. Safranek, M. Vejnar and T. Vejpustek, On parameter synthesis by parallel model checking, IEEE/ACM Transactions on Computational Biology and Bioinformatics 9 (2012), pp. 693–705.
Bernot, G., J.-P. Comet, A. Richard and J. Guespin, Application of formal methods to biological regulatory networks: extending Thomas’ asynchronous logical approach with temporal logic, Journal of Theoretical Biology 229 (2004), pp. 339 – 347.
Corblin, F., E. Fanchon and L. Trilling, Applications of a formal approach to decipher discrete genetic networks, BMC Bioinformatics 11 (2010), pp. 1–21.
de Jong, H., Modeling and simulation of genetic regulatory systems: A literature review, Journal of Computational Biology 9 (2002), pp. 67–103.
Esparza, J. and K. Heljanko, “Unfoldings: A Partial-Order Approach to Model Checking,” Monographs in Theoretical Computer Science. An EATCS Series, Springer Berlin Heidelberg, 2010.
Esparza, J., S. R¨omer and W. Vogler, An improvement of McMillan’s unfolding algorithm, Formal Methods in System Design 20 (2002), pp. 285–310.
Fromentin, J., J. P. Comet, P. L. Gall and O. Roux, Analysing gene regulatory networks by both constraint programming and model-checking, in: 2007 29th Annual International Conference of the IEEE Engineering in Medicine and Biology Society, 2007, pp. 4595–4598.
Gallet, E., M. Manceny, P. Le Gall and P. Ballarini, “Formal Methods and Software Engineering: 16th International Conference on Formal Engineering Methods, ICFEM 2014, Luxembourg, Luxembourg, November 3-5, 2014. Proceedings,” Springer International Publishing, Cham, 2014 pp. 155–170.
Giacomantonio, C. E. and G. J. Goodhill, A boolean model of the gene regulatory network underlying mammalian cortical area development, PLOS Computational Biology 6 (2010), pp. 1–13.
Gr¨atzer, G., “Lattice Theory: Foundation,” SpringerLink : Bu¨cher, Springer Basel, 2011.
Kitano, H., Computational systems biology, Nature 420 (2002), pp. 206–210.
Klarner, H., A. Streck, D. Sˇafr´anek, J. Kolˇc´ak and H. Siebert, “Computational Methods in Systems Biology: 10th International Conference, CMSB 2012, London, UK, October 3-5, 2012. Proceedings,” Springer Berlin Heidelberg, Berlin, Heidelberg, 2012 pp. 207–226.
Laubenbacher, R. and B. Stigler, A computational algebra approach to the reverse engineering of gene regulatory networks, Journal of Theoretical Biology 229 (2004), pp. 523 – 537.
MacNamara, A., C. Terfve, D. Henriques, B. P. Bernab´e and J. Saez-Rodriguez, State–time spectrum of signal transduction logic models, Physical Biology 9 (2012), p. 045003.
Ostrowski, M., L. Paulev´e, T. Schaub, A. Siegel and C. Guziolowski, “Computational Methods in Systems Biology: 13th International Conference, CMSB 2015, Nantes, France, September 16-18, 2015, Proceedings,” Springer International Publishing, Cham, 2015 pp. 170–181.
Thomas, R., Boolean formalization of genetic control circuits, Journal of Theoretical Biology 42 (1973),
pp. 563 – 585.
Wang, R.-S., A. Saadatpour and R. Albert, Boolean modeling in systems biology: an overview of methodology and applications, Physical Biology 9 (2012), p. 055001.

Appendices
Parameter Context of Extensions
Here we present in detail the method to compute the overapproximation PC pj of process extensions expanding on the intuition given in Section 4.
Method for Parameter Context Restriction
Let us first fix a notation for minimum and maximum of the PCs. For [P] we denote
the minimum as 0r =	P and the maximum as 1r = S	P . Next we define
restriction formally and denote some special relationships between PCs and RCs.
Definition A.1 A restriction is a tuple r = (v, ω, i) where ω ∈ Ωv is RC of v ∈ V
and i ∈ {0, 1} is the new target value of ω.
Let P be a PC (convex lattice). P can be restricted by restriction r = (v, ω, i) to obtain a restricted PC Pj = {P ∈P | ω ∈ P if i =1 or ω ∈/ P if i = 0}
Using the notation with minimal and maximal element a restriction (v, ω, 0)
results in ω ∈/ 1r′ and (v, ω, 1) leads to ω ∈ 0r′ . As long as 0r′ ⊆ 1r′ holds
(Pj /= ∅) the above constraints enforce ω ∈/ 0r′ Δ 1r′ .
Definition A.2 Let ω ∈ Ωv be RC of some v ∈ V and let u ∈ n—(v) be an arbitrary regulator of v. We say that ωj ∈ Ωv such that ωj = ω Δ {u} is a u-pair regulatory context (u-pair) of ω. In other words, two RCs of v are reciprocal u-pairs of each other if they differ only in activity of regulator u. We will denote the u-pair of ω as ωu.
Let [P] be some PC. We say that ω is restricted under [P] iff ω ∈/ 0r Δ 1r . In other words, ω is said to be restricted under [P] if all parametrisations in P assign ω the same target value. In such case we say [P] fixes the target value of ω. On the other hand, if the target values for ω differ, then we say ω is free under [P].
Additionally, if both ω and the u-pair of ω are restricted under some [P] we say that ω and the u-pair are u-restricted under [P].
As mentioned in Section 4, the method works with two causes of restrictions. In fact, the first cause – the transition itself is always the first restriction to happen. Let π = (X1,..., Xk) be a process and transition (Xk,X) an inhibition of v. If there is indeed no restriction necessary for all parametrisations to allow the transition,

then we know that Xk ∩ n—(v) ∈/
1p′(π) and thus especially Xk ∩ n—(v) ∈/
1p(π).

Surely then p((Xk,X)) ⊆ p(π) must hold leading to p(π · X)= p(π). We may even
extend this reasoning as it can be shown that any edge label based restriction is a result of a prior restriction and dependency introduced by labelling function.
Let us first consider a case when a restriction occurs due to monotonocity. Let (u, v) ∈ I be an interaction such that + ∈ γ((u, v)). (Once again we assume plus-monotonocity without loss of generality as the reasoning is analogously for minus-monotonocity.) We now define necessary and sufficient conditions for the monotonocity of interaction (u, v) to introduce a restriction (v, ω, 1): u ∈ ω and

ωu ∈ 0p(π·X). Clearly these conditions are sufficient as using the definition of mo- notonocity we have u ∈ ω ⇒ (ω ∈ P ∨ ωu ∈/ P ) thus obviously ω ∈ P . In fact, the given conditions are not necessary strictly speaking. However, under the assump- tion that it was indeed the monotonocity of the (u, v) interaction that requires the restriction (v, ω, 1), it becomes easy to see that they are indeed necessary. In other words, those are the necessary conditions for a plus-monotonocity criterion to in- troduce a new restriction. Let us therefore assume restriction (v, ω, 1) was required. As we are working with plus-monotonocity, the only way to enforce restriction on ω is when u ∈ ω. Moreover, the restriction with value 1 can only be imposed if ωu ∈ P for all P giving us ωu ∈ 0p(π·X). Clearly then restriction (v, ω, 1) enforced by plus-monotonocity requires a prior restriction (v, ωu, 1) to occur.
Similarly we may consider a restriction enforced by observability. Let (u, v) ∈ I be an interaction such that o ∈ γ((u, v)). Just as in the monotonocity case we define necessary and sufficient conditions for the observability of interaction (u, v) to introduce restriction (v, ω, 1): ∀ωj ∈ Ωv \ {ω, ωu} : (ωj ∈ 0p(π·X) ∧ωju ∈ 0p(π·X)) ∨

(ωj ∈/
1p(π·X) ∧ ωju ∈/
1p(π·X)) and ωu ∈/
1p(π·X).  Although the conditions are

more complex to formalise compared to monotonocity, they are fundamentally very
straightforward, the first condition requires any u-pair of regulatory contexts other than ω to be u-restricted to the same value in p(π · X) while the second condition simply requires the u-pair of ω to have target value fixed to 0. Again we show that the given conditions are sufficient. As any ωj ∈ Ωv except ω and ωu has target value equal to the u-pair ωju it is apparent that to satisfy the existential condition in the definition of observability we need target values of ω and ωu to differ. Thus ω ∈ 0p(π·X) as the value of ωu is fixed to 0 and the desired restriction happened. The conditions again, are not necessary in the general sense, however it can be shown they are necessary if the restriction (v, ω, 1) is imposed by the observability of (u, v). Let therefore ω ∈ 0p(π·X) be enforced by observability of (u, v). For ω and the u-pair of ω to be able to satisfy observability is is clearly necessary that their target values differ and as ω is fixed to 1 we get ωu ∈/ 1p(π·Xk+1). Moreover for observability to strictly determine the target value of ω it must hold for all the other
u-pairs that they do not satisfy observability of (u, v) giving us the first criterion (∀ωj ∈ Ωv \ {ω, ωu} : (ωj ∈ 0p(π·X) ∧ ωju ∈ 0p(π·X)) ∨ (ωj ∈/ 1p(π·X) ∧ ωju ∈/ 1p(π·X))) as if any of those u-pairs differed in target value the observability would be satisfied with arbitrary target value of ω. Again we can draw the conclusion that there must have been a prior restriction that allowed the sufficient and necessary conditions to become true before the restriction (v, ω, 1) was enforced by observability.
We can conduct analogical reasoning for restrictions with target values 0. As any restriction with the exception of the first one imposed by the transition itself has one prior restriction acting as a cause, we can define a causal partial order on the restrictions. It is easy to see that such a partial order defines a tree topology on the restrictions. We will now proceed with the definition of the method itself. Let π = (X0,..., Xk) be a process and X ∈ X a state such that (Xk,X) ∈ δ. The following method computes pj(π · X) using pj(π).
Set 0p(π·X) = 0p(π) and 1p(π·X) = 1p(π) and initialise an empty FIFO queue of

restrictions.
Push (v, Xk ∩ n—(v), i) where i = 0 if (Xk,X) is inhibition of v or i = 1 if (Xk,X) is activation of v to the queue of restrictions.
While the queue of restrictions is not empty, pop (v, ω, i) from the queue and execute the following:
If i = 0 set 1p(π·X) = 1p(π·X) \ {ω} else 0p(π·X) = 0p(π·X) ∪ {ω}. If no change occurred by the previous operation, then skip to next element in the queue of restrictions.
For every monotone influence (u, v) ∈ I push (v, ωu, i) where ωu is the
u-pair of ω to the queue of restrictions if one of the following is true:
i = 0, + ∈ γ((u, v)) and u ∈ ω.
i = 1, + ∈ γ((u, v)) and u ∈/ ω.
i = 0, −∈ γ((u, v)) and u ∈/ ω.
i = 1, −∈ γ((u, v)) and u ∈ ω.
If there exists only one regulatory context ωj ∈ Ωv such that ωj is open under pj(π · X) as defined by 0π·X and 1π·X then for every observable influence (u, v) ∈ I such that there does not exist an u-closed pair of regulatory contexts with different target values push (v, ωj, 1 − j) where j is the fixed target value of u-pair of ωj to the queue of restrictions.
Output 0π·X and 1π·X as minimum and maximum of pj(π · X) respectively. If 0π·X ≤ 1π·X does not hold we consider the result to be empty (pj(π · X)= ∅) in accordance with the definition as intersection of ideal and filter.
In simpler terms, the aforementioned method traverses the tree of restrictions with a breadth-first search while constructing it on the run. Monotonocity (point (iii)(b)) is enforced straightforwardly as the universal quantifier in the definition requires every u-pair to satisfy the condition. Observability (point (iii)(c)) definition contains an existential quantifier and is therefore enforced only if no other u-pair can satisfy the condition. The method always terminates and has a polynomial complexity of O(Ω2) in the worst case as every RC can have it’s value restricted at most twice.
Assuming that the input is correct (pj(π)= [p(π)]) the method computes correct pj(π· X)= [p(π· X)] (p(π· X)= ∅⇒ pj(π· X)= ∅). Let us first assume p(π· X) /= ∅. As [p(π · X)] is by definition the smallest convex sub-lattice containing p(π · X) it is enough to prove p(π · X) ⊆ pj(π · X) ⊆ [p(π · X)].
Let us first show p(π · X) ⊆ pj(π · X). Let (v, ω, i) be an arbitrary restriction that gets added to the restriction queue during the algorithm. If the restriction does not change 0p′(π·X) and 1p′(π·X) within the algorithm then pj(π · X)= pj(π) and the condition is trivially satisfied since we know p(π · X) ⊆ p(π) ⊆ [p(π)] = pj(π). Let us therefore expect that the restriction (v, ω, i) had an effect on pj(π· X). Thanks to the self-duality of the Boolean matrix, the duality of plus-/minus-monotonocity and symmetry of observability it is enough to consider i = 1 without loss of generality. Thus we get that 0p(π·X) gets extended by ω by the restriction. Let us now discussion the cause of this restriction.

The restriction (v, ω, 1) is added to the queue due to transition (Xk,X) such that {v} = X \ Xk and n—(v) ∩ Xk = ω. By definition p((Xk,X)) = {P ∈ PG | ω ∈ P} and p(π · X)= p(π) ∩ p((Xk,X)) it thus follows that ∀P ∈ p(π · X): ω ∈ P and therefore ω ∈ 0p(π·X).
The restriction (v, ω, 1) is enforced by some prior restriction r and monotono- city of (u, v) ∈ I (plus-monotonocity without loss of generality). If we apply this reasoning to restriction in the partial order given by the restriction tree we can assume r does not break the desired p(π · X) ⊆ pj(π · X) (0p′(π·X) ⊆ 0p(π·X) is enough to consider for the case i = 1). We can now use the sufficient and necessary conditions for restriction (v, ω, 1) to happen. Thus we get u ∈ ω and ωu ∈ 0p′(π·X) (by extension ωu ∈ 0p(π·X)). Since p(π · X) ⊆ PG the monoto- nocity restrictions must hold for every P ∈ p(π · X). Thus namely for any P ∈ p(π · X) such that ωu ∈ P is must also hold ω ∈ P giving us the desired ω ∈ 0p(π·X).
The restriction (v, ω, 1) is enforced by some prior restriction r and observability of (u, v) ∈ I. Just as in the previous case we can assume r does not break the desired 0p′(π·X) ⊆ 0p(π·X). Again, we use the sufficient and necessary conditions for (v, ω, 1) giving us ∀ωj ∈ Ωv \ {ω, ωu} : (ωj ∈ 0p(π·X) ∧ ωju ∈ 0p(π·X)) ∨ (ωj ∈/ 1p(π·X) ∧ ωju ∈/ 1p(π·X)) and ωu ∈/ 1p(π·X). Applying the same reasoning and p(π · X) ⊆ PG we know the target value of ω must be different from ωu for every parametrisation in p(π · X).
We will now show pj(π · X) ⊆ [p(π · X)]. If [p(π)] = [p(π · X)], then we know pj(π · X) ⊆ pj(π)= [p(π)] = [p(π · X)] and the result is trivial. Let us thus assume [p(π · X)] ⊆ [p(π)]. This clearly means there exists at least one regulatory context ω such that ω ∈ 0p(π·X)\0p(π) or ω ∈ 1p(π) \ 1p(π·X). Just as in the previous case
we can assume ω ∈ 0p(π·X) \ 0p(π) without loss of generality thanks to the duality
and symmetry properties. We will now show that for any such ω the algorithm definitely adds restriction (v, ω, 1) to the restriction queue where v ∈ V is such that ω ∈ Ωv. Analogically to the above discussion on the restriction we do a discussion on the nature of ω. Since we know that any parametrisation with target value of ω equal to 0 does not belong to p(π · X) despite belonging to p(π) there are only few possible explanations of this occurrence (we once again use the sufficient and necessary conditions for monotonocity and observability enforcement).
ω = Xk ∩ n—(v) is the regulatory context used by the activation (Xk,X). The corresponding restriction (v, ω, 1) is always added to the restriction queue. Thus pj(π · X) is restricted appropriately thus retaining the desired 0p(π·X) ⊆ 0p′(π·X).
u ∈ ω and ωu also belongs to 0p(π·X) \ 0p(π) and (u, v) ∈ I is plus-monotone (without loss of generality). We may assume that restriction (v, ωu, 1) is in the queue by conducting this discussion on ωu. By restriction tree we are guaranteed to eventually have Xk ∩ n—(v) as the cause RC. Since (v, ωu, 1) is in the restriction queue it will eventually be handled by the algorithm. Since ωu ∈/ 0p′(π) the restriction will make a difference leading to monotonocity and

observability check. By the plus-monotonocity of (u, v) the restriction (v, ω, 1) will be enqueued.
There exists some ωj ∈ 0p(π·X) ⊆ 0p′(π·X) (without loss of generality although it could also belong to 1p(π) \ 1p(π·X)) such that ω /= ωj and ωj ∈ Ωv and (u, v) ∈ I is observable. In this case we have two different possibilities for how the sufficient and necessary conditions are satisfied.
ωj = ωu. In this case we get ∀ωjj ∈ Ωv \ {ω, ωu} : (ωjj ∈ 0p(π·X) ∧ ωjju ∈ 0p(π·X)) ∨ (ωjj ∈/ 1p(π·X) ∧ ωjju ∈/ 1p(π·X)) and ωu ∈/ 1p(π·X). We can thus assume (v, ωu, 0) to be in the restriction queue. From the first condition we know that every RC is u-restricted under pj(π · X) by the time restriction (v, ωu, 0) is handled and the observability of (u, v) is yet to be satisfied. As such ω is left as the last free context by restriction of ωu and to ensure observability the algorithm adds (v, ω, 1) to the restriction queue.
Otherwise we get ∀ωjj ∈ Ωv \ {ω, ωu, ωj, ωju} : (ωjj ∈ 0p(π·X) ∧ ωjju ∈ 0p(π·X)) ∨ (ωjj ∈/ 1p(π·X) ∧ ωjju ∈/ 1p(π·X)), ωju ∈/ 1p(π·X) and ωu ∈/ 1p(π·X). And our assumption becomes existence of restriction (v, ωj, 1) in the restric- tion queue. As we know ωj ∈/ 0p(π) the restriction will make a difference and as it leaves behind ω as the last free RC and (u, v) with still unful- filled observability requirement the (v, ω, 1) restriction must be added to the restriction queue.
Finally, let us assume p(π · X)= ∅ (and p(π) /= ∅). We now show that in such a case the algorithm computes ¬(0p′(π·X) ⊆ 1p′(π·X)) we interpret as pj(π · X)= ∅. It is easy to see, as 0p′(π·X) is only extended and 1p′(π·X) only reduced that the method cannot recover from such a malformed state.
Let us again assume (Xk,X) to be activation of some v ∈ V without loss of generality. We know p(π · X)= p(π) ∩ p((Xk,X)) = ∅. Since p((Xk,X)) contains all parametrisations P ∈ PG such that Xk ∩ n—(v) ∈ P and p(π) ⊆ PG it must hold that ∀P ∈ p(π): Xk ∩n—(v) ∈/ P and by extension Xk ∩n—(v) ∈/ 1p(π). pj(π)= [p(π)] further gives us ∀P ∈ pj(π) : Xk ∩ n—(v) ∈/ P . By the structure for the algorithm 1p′(π·X) ⊆ 1p′(π) and therefore Xk ∩n—(v) ∈/ 1p′(π·X). Furthermore the algorithm will for sure handle restriction (v, Xk ∩ n—(v), 1) due to the transition (Xk,X) resulting in Xk ∩ n—(v) ∈ 0p′(π·X) giving us ¬(0p′(π·X)⊆1   ).

The Initial Parameter Context Overapproximation
As the method relies on the knowledge of pj(π) to compute p(π · X) it is necessary to be able to compute the initial pj(∅) = [PG ]. Although [PG ] = PG often holds, there are some cases when a restriction is viable.
As regulations of individual components are independent (note that both mo- notonocity and observability only speak about RCs of the same component) it is enough to consider restrictions for regulation of each component separately. Let thus v ∈ V be an arbitrary component. Let A = {u ∈ n—(v) | + ∈ γ((u, v))} be the set of all regulators of v with plus-monotone interaction and I = {u ∈ n—(v) | − ∈ γ((u, v))} be the set of all regulators of v with minus-monotone interaction. We

now consider two parametrisations Ps = Ω \ {I} and Pi = {A}. We can show easily that any monotonocity criterion on interaction with v is satisfied by both Ps and Pi. Monotonocity for (u, v) is satisfied by default if both ω and u-pair of ω have the same target value. As such only the context I has to be analysed. Let u ∈ A be ar- bitrary. We get u ∈ Iu by definition and I ∈/ Ps as well as I ∈/ Pi thus monotonocity of (u, v) is satisfied by both Ps and Pi. Now let u ∈ I be arbitrary. By definition u ∈ I and thus by I ∈/ Ps and I ∈/ Pi we again satisfy monotonocity of (u, v) for both Ps and Pi. Let us now discuss observability. For any u ∈ A observability is trivially satisfied under both Ps and Pi as I ∈/ Ps and I ∪ {u}∈ Ps and similarly A ∈ Pi and A \ {u} ∈/ Pi. Similarly let u ∈ I be arbitrary then I ∈/ Ps and I \ {u} ∈ Ps make (u, v) observable under Ps and A ∈ Pi and A∪{u} ∈/ Pi makes (u, v) observable also under Pi. Finally, observability is also satisfied for any other u ∈ (n—(v) \ A) \ I as I ∈/ Ps and I ∪{u}∈ Ps and A ∈ Pi and A∪{u} ∈/ Pi. It thus becomes clear that Ps and Pi satisfy both monotonocity and observability for arbitrary labelling function γ. As such, edge labelling cannot reduce the initial lattice beyond the maximum Ps and minimum Pi for each v ∈ V (∀v ∈ V : [{Ps, Pi}] ⊆ [PG ∩ ({v}× Ωv)]).
Let us now consider a set of regulators N ⊆ n—(v) such that N ∩ A = ∅ and N ∩ I = ∅ and parametrisations Pns = Ω \ {N ∪ I} and Pni = {A ∪ N}. It is easy to see that both Pns and Pni have the same properties as Ps and Pi and thus satisfy arbitrary γ. In fact, if N = ∅, then we trivially get Pns = Ps and Pni = Pi. Let us now consider N /= ∅. Then clearly both Ps and Pns are valid parametrisations. Moreover the supremum of Pns and Ps according to the set inclusion order is Pns ∪ Ps = Ω. Similarly both Pi and Pni are also valid and their infimum Pni ∩ Pi = ∅. Thus, if there exists any interaction (u, v) such that

+ ∈/
γ((u, v)) and − ∈/
γ((u, v)) then the initial lattice of parametrisations for

regulations of v will be equal to the fully parametrised case ([PG ∩ ({v}× Ωv)] = PG ∩ ({v}× Ωv)). And we can safely conclude that for [PG ] ⊂ PG there must exist at least one v ∈ V such that ∀u ∈ n—(v):+ ∈ γ((u, v)) ∨− ∈ γ((u, v)).
Since the parametrisations Ω and ∅ are both plus-monotone and minus-mono- tonous for all interactions, it is obvious that just monotonocity is not enough for [PG ] ⊂ PG. In fact, Ω and ∅ are not observable for any interaction (an interac- tion that is both plus and minus-monotone is anti-observable) and thus a single observable interaction (u, v) is sufficient to remove Ω and ∅ from the set of feas- ible parametrisation. In fact, if every interaction (u, v) ∈ I is monotone for some v ∈ V and at least one of them also observable, the initial PC can be restricted to maximum Ps and minimum Pi ([PG ∩ ({v}× Ωv)]= [Ps, Pi]). To prove this let us consider any parametrisation P such that I ∈ P . Since (u, v) is minus-monotone for every u ∈ I every RC of the form I \ {u} must also belong to P and by iterative application of the minus-monotonocity condition ∀J ⊆ I : J ∈ P . Similarly (u, v) is plus-monotone for any other u ∈ A. As such, for any J ⊆ I we get J ∪ {u} ∈ P and by iterative application P = Ω and the observability is not satisfied. Thus we may conclude that no parametrisation P such that I ∈ P is feasible. An analogical construction can be conducted for P such that A ∈/ P reaching P = ∅.
The construction of the initial PC pj(∅)= [PG ] can thus be done algorithmically

as follows.
Start with [PG ]= PG.
Find all components v ∈ V such that ∀u ∈ n—(v):+ ∈ γ((u, v))∨− ∈ γ((u, v)) and ∃u ∈ n—(v): o ∈ γ((u, v)).
For every such v construct the sets A = {u ∈ n—(v) | + ∈ γ((u, v))} and I = {u ∈ n—(v) |−∈ γ((u, v))} and restrict the minimum by (v, A) ∈ 0r and the maximum by (v, I) ∈/ 1rG .
The computation of the initial PC is similar in the general case of multivalued PRNs. The only difference is the target value limitation for I for every suitable component v ∈ V (target value of A is still set to be at least 1). Instead of setting target value of I to 0, in general the value is limited to be at most kv − 1 where kv ∈ N is the maximum value of component v.

Total Adequate Order
Here we extend the total adequate order ≺F introduced in [8] to our formalism of unfoldings as introduced in section 5. Let U = (B, E, ≤, #) be an unfolding of some PRN and let C1, C2 ⊆ E be two finite configurations of U .
Let  be an arbitrary total order on all RCs (v, ω) ∈ Ω. We can always find such an order as Ω is finite. Then we define a function ϕ such that for every finite configuration C, ϕ(C)= (ωe1 ,..., ωek ) is a vector of regulatory contexts such that C = {e1,..., ek} ordered by . ϕ(C) is thus a variant of a Parikh vector of associated RCs of C. We extend the order  to ordered vectors as a lexicographical order. Essentially the same construction has been used for Petri net unfoldings in [8] using transitions of the original Petri net instead of RCs.
Furthermore let us define the Foata normal form of configuration C, FC(C) as follows.
FC1(C)= ϕ({e ∈ C | ∀ej ∈ C : ¬(ej < e)}) is the ϕ of all events in C minimal with respect to the causality relation.

For 1 < i ∈ N : FCi(C)= ϕ({e ∈ C | ∀ej ∈ C : ej < e ⇒ ej ∈ S

j<i—1
FCj(C)})

is the ϕ of all events in C without all the previous F Cj(C) minimal in respect
to the causality relation.
FC(C) = (FC1(C),...,FCk(C)) where k ∈ N is the largest natural number such that F Ck(C) /= ∅. Such k is guaranteed to exist as C is finite.
Intuitively, the Foata normal form FC(C) is a layered representation of C in respect to causality relation and represents steps in which events of C can fire if all concurrent events fire synchronously. We again extend  to the Foata normal forms as a lexicographical order on the vectors of FC(C). The construction is again equivalent to the one proposed in [8] for Petri net unfoldings. Finally, the order ≺ as used in Section 5 is defined as follows.
Definition B.1 Let U = (B, E, ≤, #) be an unfolding of some PRN and C1, C2 ⊆

E two finite configurations of U . We say that C1 ≺ C2 if one of the following conditions holds.
– |C1| < |C2|
– |C1| = |C2|∧ ϕ(C1)   ϕ(C2)
– |C1| = |C2|∧ ϕ(C1)= ϕ(C2) ∧ FC(C1)   FC(C2)
