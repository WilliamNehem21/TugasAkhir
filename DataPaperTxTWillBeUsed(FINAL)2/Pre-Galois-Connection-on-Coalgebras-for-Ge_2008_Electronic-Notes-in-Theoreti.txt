	Electronic Notes in Theoretical Computer Science 207 (2008) 203–217	
www.elsevier.com/locate/entcs

Pre-Galois Connection on Coalgebras for Generic Component Refinement
Sun Meng1
CWI, Kruislaan 413, Amsterdam, The Netherlands

Abstract
The technique of Galois connections has been applied successfully in many areas of computer science. By employing coalgebras as models for software components, we claim that different forms of behavior model and types of state transitions for components are instances of a single form of coalgebra in a Kleisli category. Based on the Kleisli category, the results on forward/backward morphisms and refinement of components in Set are still satisfied in this more generic framework. We propose a notion of pre-Galois connection in the context of coalgebras for refinement of state-based software components which takes into consideration not only the refinement ordering but also the dynamics of the components, and we study its properties in the Kleisli category. This notion is a powerful tool for relating a component to its refinement and for relating a component to its abstraction. Thus it provides a basis for reasoning about state-based software designs and reverse engineering.

Keywords: Component, Refinement, Coalgebra, Pre-Galois Connection


Introduction
In the past decade or so, the notion of component based software development [17] emerged as a promising paradigm to deal with the ever increasing complexity in software design, evolution and reuse. A component is a modular, deployable, and replaceable part of a system that encapsulates implementation and exposes a public interface. In component based software development, a component must be specified and then implemented before it can be analyzed and used. The development step from specification to implementation is called refinement.
Based on a coalgebraic model for component based systems [2,3,5] in which components are modelled as coalgebras and can be aggregated through a number of combinators to build hierarchical models of complex systems, [13] introduces the notion of refinement for generic components, including a soundness result. Later
[12] investigates architectural reﬁnement and proved a completeness result. By

1 Email: M.Sun@cwi.nl

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.094

using the pointfree binary relation calculus, [4] addresses the refinement for partial components in the coalgebra context.
Galois connection is a concept introduced by Oystein Ore in [15], and has been widely used in many areas of computer science to ensure the correctness of imple- mentation with respect to the specification [6,8,11]. In this paper, we approach the notion of pre-Galois connection between coalgebras as a formal relationship between one component and its refinement. As in our previous work [13,12], we consider components as coalgebras. The difference between previous work and this paper is that the coalgebra model for components in this paper goes one step higher on the “generic” ladder, because it unifies the behavior model and transition types into one functor over the Kleisli category instead of using one monad and one func- tor for representing them respectively. By using the coalgebra framework we can take refinement (or, abstraction on the other direction) as transformation from one coalgebraic structure to another.
The concept of pre-Galois connection we study in this paper is similar to Galois connection in a coalgebraic context, based on the notion of ordering on a functor proposed in [10]. The difference between this and a Galois connection is that it is a notion for two dimensions: not only the refinement ordering but also the dynamics of the components are considered here. Furthermore, the refinement order considered in this paper is not a partial order, but a preorder. Therefore, for some properties that are satisfied by the classical Galois connection, the corresponding parts in pre- Galois connection are not exactly the same. Especially, the equality for many results in Galois connection is replaced by the two-way similarity relationship in the context of pre-Galois connection. We also show how pre-Galois connections can be used in reasoning about refinement of components. A pre-Galois connection is a pair of arrows on the carrier sets U and V of two K (T)-coalgebras in the Kleisli category. By using the familiar “lifting” technique [9,10], it can be transformed into a Galois connection between K (T)U and K (T)V , which are equipped with the refinement preorder. We explain in what formal sense a pre-Galois connection establishes that one component refines another, and show how pre-Galois connections help to prove existence of simulations between components.
The structure of this paper goes as follows: The underlying coalgebraic model for components is briefly discussed in Section 2. Section 3 introduces forward and backward morphisms as refinement “witnesses”. Section 4 contains an introduction on refinement and simulation of components. Section 5 gives the definition of pre- Galois connection and provides a family of properties that a pre-Galois connection should satisfy. Section 6 discusses the possibilities of applying pre-Galois connec- tions in refinement of state-based components. Concluding remarks, together with some prospects for future work, are presented in Section 7.

Components as Coalgebras
In [2,3] software components have been characterized as dynamical systems with a public interface and a private, encapsulated state. In this paper, we adopt the

coalgebraic model for software components which follows closely the “components as coalgebras” approach proposed in [2,3]. This approach provides an observational semantics for software components and an assembly calculus. For more details the reader is referred to [1,2]. However, we make one step further by using the Kleisli category instead of Set as the base category and thus unifying the behavior model and transition type aspects into one functor over the Kleisli category.
In this approach, components are specified in a generic way, where “generic” means that the underlying behavior model is taken as a specification parameter, and abstracted to a monad B. Some useful possibilities are as follows:
Identity, B = Id, which retrieves the simple total and deterministic behavior.
Partiality, B = Id + 1, i.e., the maybe monad, capturing the partial behavior which describes the possibility of deadlock or failure.
Non-determinism, B = P, modeling the non-deterministic branching behavior.
Probabilistic non-determinism, B = D which models the probabilistic branching behavior. Here for a set X, DX = {ξ : X → [0, 1] |  x∈X ξ(x) ≤ 1}, and ξ is called a probability subdistribution over X.
General “metric” non-determinism, supported on a notion of a bag monad based on commutative monoids (M, ⊕, ⊗) where ⊗ distributes over ⊕. This monads captures situations in which, among the possible future evolutions of the compo- nent, some are more likely (or cheaper, more secure, etc.) than others.
Moreover, the type of state transitions of the component is described by a functor
T. For example, if we take I and O be sets acting as component input and output interfaces, then T can be defined as the Set endofunctor T = (Id × O)I . More possibilities of the functor T can be found in [1]. Therefore, a state-based component can be modeled as a pointed coalgebra (u ∈ U, α : U → BTU ) in Set with B a monad, T a functor, and a distributive law TB ⇒ BT implicit, where the point u is taken as the “initial” or “seed” state. The distributive law describes the way how B’s effect is distributed over the transition type represented by T. In this paper, we only consider T as a polynomial functor.
For each monad B on Set, the Kleisli category for B, denoted by K (B), can be constructed as follows:
Objects in K (B) are the same as in Set. They are just sets.
An arrow U → V in K (B) is a function U → BV in Set.
Composition of arrows in K (B) is defined using multiplication μU : BBU → BU .
Identity arrow id : U → U in K (B) is the unit ηU : U → BU in Set.
This category K (B) will be our base category in the following sections. Note that when we write an arrow U → V in K (B), the effects of monad B is implicit because it is a function U → BV in Set. As an example, we consider the category K (P) for the powerset monad P. It is in fact isomorphic to the category Rel of sets and relations. That is, an arrow U → V in K (P) is exactly a relation between U and V via the correspondence: given a function f : U → PV in Set

we can obtain a relation Rf = {(u, v) | v ∈ f (u)}. Furthermore, the composition of arrows and identity arrow in K (P) are the relational composition and diagonal relation respectively.
In [7], it has been shown that via the distributive law, the functor T can be lifted to a functor K (T) on the Kleisli category K (B), and the base category can be moved from Set to K (B). Thus, considering the component model in [1,2,13], a component is just a pointed coalgebra (u ∈ U, α : U → K (T)U ) in the Kleisli category K (B). In the following sections we may omit the seed state for simplifying notations.
Note that the notion of behavior models captured by the monad B can naturally come with notions of order on BU .
Definition 2.1 For a Kleisli category K (B) and any functor T, an order ≤K (T) on K (T) is defined as a collection of preorders ≤BTU ⊆ BTU × BTU , for each set U , such that the following diagram commutes:


≤K,(,T,),,P re¸Ord
(BTU, ≤BTU )
,,,	¸

,,	J 
,,,,	J 

K (B) K (T) K (B)	concretely	U 	 BT U
and for any f : U → V , K (T)f preserves the order, i.e.,
u1 ≤U u2 ⇒ K (T)f (u1) ≤BTV K (T)f (u2) We can consider some possible examples of ≤K (T):
The first example is as follows:
x ⊆Id y iff x = y
x ⊆P y iff ∀e∈x∃e'∈y .e ⊆Id e'
The order ⊆P captures the classical notion of nondeterministic reduction.
The order ⊆P can be turned into more specific cases. For example, the failure forcing variant ⊆E , where E stands for emptyset, guarantees that the first com- ponent fails no more than the second one. It is defined by replacing the clause for ⊆P by
x ⊆E y iff (x = ∅⇒ y = ∅) ∧ ∀e∈x∃e'∈y .e ⊆Id e'
Consider the partiality monad B = Id + 1. The set BU carry the familiar “flat” order:
x ⊆B y iff x /= ∗⇒ x = y ∧ x = ∗⇒ y = ∗
In the following sections, sometimes we may drop the subscripts in ≤BU , e.g., ≤ instead of ≤BU , when it is clear from context for notation economy. Moreover, we denote the lifting of the order ≤ to the arrows as:
f ≤ g iff ∀x .f (x) ≤ g(x)	(1)

Forward and Backward Morphisms
The dynamics of a component is captured by the functor K (T). Thus, a possible (and intuitive) way of considering component p as a refinement of another com- ponent q is to consider that p-transitions are simply preserved in q. For example, for non-deterministic components this means set inclusion. To make precise such a “definition”, the transitions are generalized as follows: Recall that a component morphism from p to q is a seed preserving function h : Up → Uq such that
K (T)h · αp = αq · h	(2)
In fact, just as transition systems can be coded back as coalgebras, any T- coalgebra also specifies a T-shaped transition structure over the carrier U :
u → u' ≡ u' ∈T α(u)
where ∈T can be defined by induction on the structure of T:
x ∈Id y iff x = y x ∈K y iff false
x ∈T1×T2 y iff x ∈T1 π1y ∨ x ∈T2 π2y


x ∈T +T
y iff
 y = ι1y'	⇒ x ∈T y'

y = ι2y'	⇒ x ∈T y'
x ∈TK y iff ∃k∈K .x ∈T yk x ∈P(T) y iff ∃y'∈y.x ∈T y'
In terms of transitions, equation (2) can be translated into the following two requirements by a straightforward generalization of an argument in [16]:
u → u' ⇒ h(u) → h(u')
h(u) → v' ⇒ ∃u' ∈ U .u → u' ∧ v' = h(u')
which jointly states that not only p dynamics as represented by the induced tran- sition relation, is preserved by h, but also the q dynamics is reflected back over the same h. Note that in the study of refinement, both preservation and reflection of behavior are useful, because we need the abstract model for both validating desired properties and analyzing for the presence of undesirable properties.
The classic tool for relating two coalgebras is the homomorphism which can be defined by (2). However, from such homomorphisms we can only derive bisimula- tions [16]. Thus, in order to build a witness for refinement relations, we separate the preservation and reflection aspects in homomorphism and get the following def- inition:
Definition 3.1 For a Kleisli category K (B) and two coalgebras p = (U, α : U →
K (T)U ) and q = (V, β : V → K (T)V ). A forward morphism h : p → q with

respect to an order ≤ on K (T) is an arrow h : U → V such that
K (T)h · α ≤ β · h
Dually, h is called a backward morphism if the following conditions are satisfied:
β · h ≤ K (T)h · α
Although the base category has been changed from Set to Kleisli category, some results similar to those in Set can still be easily proved. For example,
Lemma 3.2 For a Kleisli category K (B) and a Set functor T, pointed K (T)
coalgebras and forward (backward, respectively) morphisms form a category.
Proof. In both cases, identities are the identities on the carrier and composition is inherited from K (B). What remains to be shown is that the composition of for- ward (backward respectively) morphisms yields a forward (backward respectively) morphism. So, for K (T) coalgebras p = (U, α), q = (V, β) and r = (W, γ), let h : p → q and k : q → r be two forward (backward respectively) morphisms, then

(forward case)
K (T)(k · h) · α
= {K (T) functor}
K (T)k · (K (T)h · α)
≤ {h forward and (2.1)}
K (T)k · (β · h)
= {· associate} (K (T)k · β) · h
≤ {k forward} (γ · k) · h
= {· associate}
γ · (k · h)
(backward case)
γ · (k · h)
= {· associate} (γ · k) · h
≤ {k backward} (K (T)k · β) · h
= {· associate}
K (T)k · (β · h)
≤ {h backward and (2.1)}
K (T)k · K (T)h · α
= {K (T) functor}
K (T)(k · h) · α


Refinement and Simulation of Components
The existence of a forward (backward) morphism connecting two components p and q witnesses a refinement situation whose symmetric closure coincides, as expected, with bisimulation. In the sequel we will restrict ourselves to forward refinement 2 and define behavior reﬁnement as the existence of a forward morphism up to bisim- ulation ∼. Formally,
Definition 4.1 Component p is a behavior refinement of q, written p ±B q, if there exist components r and s such that p ∼ r, q ∼ s and a (seed preserving) forward morphism from r to s.

2 A similar study can be made about backward refinement.

The exact meaning of a refinement assertion p ±B q depends, of course, on the concrete refinement preorder ≤ adopted. Behavior refinement has a number of pleasant properties. For example,
p ±B p
p ±B q ∧ q ±B r ⇒ p ±B r
Example 4.2 As an example of behaviour refinement, we consider the lossy buffer LBuff component, which is a buffered channel that occasionally loses messages, as represented below:
I = M + 1

put :	M −→ 1
pick :	1 −→ M

O = 1 + M
The put and pick operations are regarded as ‘buttons’ or ‘ports’, whose signatures are grouped together in the diagram (M stands for a message parameter type, 1 for the nullary datatype and + for ‘datatype sum’). One might capture LBuff dynamics by a function aLBuff : U × I → P(U × O) where U denotes the space state. This describes how LBuff reacts to input stimuli, produces output data (if any) and changes state. It can also be written in a curried form as a coalgebra of signature U −→ K (T)U in the Kleisli category K (P) where functor T captures the transition ‘shape’:
T = (Id × O)I

As a refinement we consider a deterministic buffered channel Buff specified as a coalgebra M ∗ −→ (M ∗ × (1 + M ))M+1 with nil as the initial state, and dynamics given by standard operations on lists. Other possible behavior refinements of LBuff would arise by choosing different strategies for delivering elements from the buffer. Here are some possibilities, each of them is witnessed by a forward morphism:
the queuing strategy, leading to the specification Buff;
the stack strategy (LIFO deliver);
the priority strategy (in which elements carry some probability information);
the lift strategy (a linear order on the elements is served in alternating increasing and decreasing order).
In the priority strategy, for example, elements are labelled with a ‘show-up’ prob- ability, introducing an elementary form of probabilistic nondeterminism. As detailed in [3], the corresponding behavior monad is generated by a monoid ⟨[0, 1], min, ×⟩
with the additional requirement that for each m ∈ M , Σ(Pπ2)m = 1. ‘Probabilis-

tic’ components can be embedded into the space of ‘plain nondeterministic’ ones where behaviour refinement, wrt the corresponding refinement order, is discussed.
A forward morphism is a “behavior preserving” mapping, but lying inside it is a more fundamental concept: to relate two coalgebras, one must show that all the transitions in one coalgebra are “mimicked” by the other. Such an intuition is formalized by the notion of simulation. In [13,12] we have proved that behavior refinement, as characterized above, can be established by a simulation relation R ⊆ Up × Uq on the state spaces of the ‘concrete’ (p) and the ‘abstract’ (q) components. The generic definition of simulation is due to Jacobs and Hughes in [10]:
Definition 4.3 For a given Kleisli category K (B), a functor T and a refinement preorder ≤, a lax relation lifting is an operation Rel≤(K (T)) mapping relation R to ≤ ·Rel(K (T))(R)· ≤, where Rel(K (T))(R) is the lifting of R to K (T) defined, as usual, as the K (T)-image of inclusion ⟨r1, r2⟩ : R → U × V :
⟨K (T)r1, K (T)r2⟩ : K (T)R → K (T)U × K (T)V
Given K (T)-coalgebras (U, α) and (V, β), a simulation is a Rel≤(K (T))-coalgebra over α and β, i.e., a relation R such that, for all u ∈ U, v ∈ V ,
(u, v) ∈ R ⇒ (α u, β v) ∈ Rel≤(K (T))(R)
The following diagram in K (B) for K (T) coalgebras, captures simulations:


U ¸,	π1 α
J ¸≤,
R 	π2	 V 
β
J	≤   J 

K (T)U
K (T)π1
Rel(K (T))(R) K (T)π
K (T)V

The union of all simulations is still a simulation, which is called similarity and denoted by  . The two-way similarity is defined as ∼ =  ∩  op, i.e., for two states u and v,
u∼v iff u  v ∧ v  u
Note that bisimilarity implies two-way similarity, but the converse is not always satisfied. The condition under which two-way similarity implies bisimilarity can be found in [10]. For two arrows f, g : U → V , we write f ∼g iff for all u ∈ U , f (u)∼g(u).
The soundness and completeness results of simulation for behavior refinement in the category Set has been proved in [13,12], and also holds in the Kleisli category. It is given in the following lemma:
Lemma 4.4 For two coalgebras p and q,
To prove p ±B q it is sufficient to exhibit a simulation R relating p and q.
If p ±B q and h is the witness forward morphism, then ∼ ·Graph(h)· ∼ is a simulation between p and q.

It is easy to extract the simulation embedded within a forward morphism: for h : U → V , we define (u, v) ∈ R iff h(u) ≤BV v. Note that h(u) ≤BV v is stated rather than h(u) = v as in Set, to take into account the order upon V . It is straightforward to prove that R is a simulation.
Simulations prove to be a useful foundation for reasoning about refinement of components, and we can synthesize a simulation from scratch for two finite-state components. In next section, we consider another powerful tool: pre-Galois con- nection.



Pre-Galois Connection

In the previous section we have seen how components are related by for- ward/backward morphisms and simulations to witness the refinement relationship. However, in practice, because forward/backward morphisms are functions, they only give incomplete insight about how one determines the states of the abstract component that correspond to a set of states of the concrete component. To solve these problems, we make a generalization of forward/backward morphism and define pre-Galois connection on coalgebras as follows:

Definition 5.1 For a Kleisli category K (B) and functor T, let ≤ be an order on B, a pre-Galois connection between two K (T)-coalgebras (U, α) and (V, β) isa pair of arrows f : U → V and g : V → U , such that for all u ∈ U and v ∈ V ,

α(u) ≤K (T)U K (T)g · β(v) iff K (T)f · α(u) ≤K (T)V β(v)

We say that f is the lower adjoint and g is the upper adjoint of the pre-Galois connection.

The following lemmas show the basic results that pre-Galois connected functions can be composed to form new pre-Galois connections, and identity arrow can always be used to build pre-Galois connection.

Lemma 5.2 If (f, g) is a pre-Galois connection between two coalgebras (U, α : U → K (T)U ) and (V, β : V → K (T)V ), and (h, k) is a pre-Galois connection between two coalgebras (V, β : V → K (T)V ) and (W, γ : W → K (T)W ), then (h · f, g · k) is a pre-Galois connection between (U, α : U → K (T)U ) and (W, γ : W → K (T)W ).

Proof. We have, for all u ∈ U and w ∈ W ,
α(u) ≤K (T)U K (T)(g · k) · γ(w)
≡ {K (T)is a functor}
α(u) ≤K (T)U K (T)g · K (T)k · γ(w)
≡ {(f, g)is a pre-Galois connection}
K (T)f · α(u) ≤K (T)V K (T)k · γ(w)
≡ {(h, k)is a pre-Galois connection}
K (T)h · K (T)f · α(u) ≤K (T)W γ(w)
≡ {K (T)is a functor}
K (T)(h · f ) · α(u) ≤K (T)W γ(w)


Lemma 5.3 (id, id) where id denotes the identity function on U is a pre-Galois connection between a coalgebra (U, α : U → K (T)U ) and itself.
Proof. Obvious.	 
If we introduce an order «U on U for (U, α : U → K (T)U ) as follows:
u «U u' iff α(u) ≤K (T)U α(u')	(3)
i.e., we assume that « reflects the transition structure →. In other words, the functor K (T) is order-preserving, and then the cancellation results similar to those in Galois connections can be inferred.
Lemma 5.4 If (f, g) is a pre-Galois connection between two coalgebras (U, α : U →
K (T)U ) and (V, β : V → K (T)V ), then we have
f · g «V idV and idU «U g · f
Proof. It suffices to show that f · g «V idV . The proof for idU «U g · f is similar.
f · g «V idV
≡ {the definition of order « in(3)}
K (T)f · K (T)g · β(v) ≤K (T)V β(v)
≡ {(f, g)is a pre-Galois connection}
K (T)g · β(v) ≤K (T)U K (T)g · β(v)

Additionally, we can get the following result:
Lemma 5.5 If (f, g) is a pre-Galois connection between two coalgebras (U, α : U → K (T)U ) and (V, β : V → K (T)V ), then f and g are both monotonic with respect to «U and «V .

Proof. Suppose (f, g) is a pre-Galois connection. We only need to show that f is monotonic:
f (u) «V f (u')
≡{the definition of order « in(3)}
β(f (u)) ≤K (T)V β(f (u'))
⇐{(2.1)}
α(u) ≤K (T)U α(u')
≡{the definition of order « in(3)}
u «U u'


Furthermore, we have the result that a pre-Galois connection is also a Galois connection w.r.t. the order infered by (3).
Theorem 5.6 If (f, g) is a pre-Galois connection between two coalgebras (U, α : U → K (T)U ) and (V, β : V → K (T)V ), for the orders on U and V deﬁned by (3), (f, g) is a Galois connection.
Proof. The result is immmediate from Lemma 5.4 and 5.5.	 
Proposition 5.7 If (f, g) is a pre-Galois connection between two coalgebras (U, α :
U → K (T)U ) and (V, β : V → K (T)V ), then f · g · f ∼f and g · f · g∼g.
Proof. We only need to prove g · f · g∼g. The proof for f · g · f ∼f is similar. From Lemma 5.4, we know that f · g «V idV . Thus for any v ∈ V , we have
β(f · g(v)) ≤K (T)V β(v)
Since the order is preserved by K g, we get α(g·f ·g(v)) ≤K (T)U α(g(v)). Let relation R ⊆ U × U be defined as R = {(g · f · g(v), g(v)) | v ∈ V }, then from Definition 4.3, we know that R is a simulation. Similarly we can prove that g(v) g · f · g(v). Therefore, g · f · g∼g.	 
The adjoints in a pre-Galois connection uniquely determine each other when the order ≤ is a partial order and K (T) is a faithful functor.
Proposition 5.8 If the order ≤ is a partial order, and (f, g) and (f, h) are pre- Galois connections between two coalgebras (U, α : U → K (T)U ) and (V, β : V → K (T)V ) where K (T) is faithful, then g = h (similarly for the dual case).
Proof. Since (f, g) and (f, h) are pre-Galois connections, we have that for any
u ∈ U and v ∈ V ,
α(u) ≤K (T)U K (T)g · β(v)
≡ K (T)f · α(u) ≤K (T)V β(v)
≡ α(u) ≤K (T)U K (T)h · β(v)

Thus K (T)g · β(v) ≤K (T)U K (T)h · β(v) and K (T)h · β(v) ≤K (T)U K (T)g · β(v). Since ≤ is a partial order, we have K (T)g = K (T)h. Therefore, g = h.	 
¿From the proof of Proposition 5.8, we can easily derive the following result:
Corollary 5.9 If ≤ is a preorder, and (f, g) and (f, h) are pre-Galois connections between two coalgebras (U, α : U → K (T)U ) and (V, β : V → K (T)V ) where K (T) is faithful, then g∼h (similarly for the dual case).
Similar like the results for Galois connection between partially ordered sets, we have the following proposition for the adjoints in a pre-Galois connection.
Proposition 5.10 If the order ≤ is a partial order, and (f, g) is a pre-Galois con- nection between two coalgebras (U, α : U → K (T)U ) and (V, β : V → K (T)V ) where K (T) is faithful, then
f is monic iff g is epic iff g · f = idU ;
g is monic iff f is epic iff f · g = idV .
Proof. We only need to prove the first item. Suppose (f, h) is another pre-Galois connection between (U, α : U → K (T)U ) and (V, β : V → K (T)V ). First, we assume that g · f = idU . Therefore, if f · g = f · h, then g · f · g = g · f · h, i.e., g = h. On the other hand, if h · g = k · g, then h · g · f = k · g · f , i.e., h = k.
Suppose f is monic, i.e., for any arrows g, h, f · g = f · h ⇒ g = h. Since (f, g) is a pre-Galois connection, from Lemma 5.4, for any u ∈ U and v ∈ V , we have α(u) ≤K (T)U α(g · f (u)) and β(f · g(v)) ≤K (T)V β(v). Thus we can get
α(u) ≤K (T)U K (T)g · K (T)f · α(u) and K (T)f · K (T)g · β(v) ≤K (T)V β(v) In other words,
idK (T)U ≤K (T)U K (T)g · K (T)f and K (T)f · K (T)g ≤K (T)V idK (T)V
Since the order is preserved by K (T)f , we have
K (T)f
= K (T)f · idK (T)U
≤K (T)V K (T)f · K (T)g · K (T)f
≤K (T)V idK (T)V · K (T)f
= K (T)f
Therefore, we have K (T)f · K (T)g · K (T)f = K Tf . Because K (T) is faithful,
f · (g · f )= f = f · idU . Thus g · f = idU .
Similarly, if g is epic, we can also derive the result that g · f = idU .	 
Corollary 5.11 If ≤ is a preorder, and (f, g) is a pre-Galois connection between two coalgebras (U, α : U → K (T)U ) and (V, β : V → K (T)V ) where K (T) is faithful, then

f is monic ⇒ g · f ∼ idU ;
g is monic ⇒ f · g ∼ idV ;
f is epic ⇒ f · g ∼ idV ;
g is epic ⇒ g · f ∼ idU .
Proof. Similar to the proof for Proposition 5.10.	 
Suppose that we have two coalgebras p = (U, α : U → K (T)U ) and q = (V, β :
V → K (T)V ), the obvious way of using a pre-Galois connection to relate them is by constructing the order ≤K (T)U and ≤K (T)V , and formulating f and g. If we use p and q for the concrete and abstract components respectively, then we say that f : U → V is the abstraction map and g : V → U is the concretization map. Note that the arrow does map a state not to a single state, but to a B effect on states. So for every concrete state u, f (u) is its abstract counterpart, and dually, for every abstract state v, g(v) denotes the concrete states that v represents. In other words, g(v) defines the potential refinements of v. In the following section, we show how pre-Galois connections are used in reasoning about refinement of components.

Linking Pre-Galois Connection with Refinement
Since simulation is both sound and complete for proving refinement between com- ponents, we hope to construct a simulation relationship between components p and q as coalgebras p = (U, α : U → K (T)U ) and q = (V, β : V → K (T)V ). Given a pre-Galois connection (f : U → V, g : V → U ), we can extract the relation R(f,g) ⊆ U × V as follows:
R(f,g) = {(u, v) | K (T)f · α(u) ≤K (T)V β(v)}


or equivalently

R(f,g) = {(u, v) | α(u) ≤K (T)U K (T)g · β(v)}

The intuition behind the relation R(f,g) is that if (u, v) ∈ R(f,g), then u is a possible refinement of v. Now we are left with the task of proving that R(f,g) can be used as one candidate for proving a simulation between p and q.
Theorem 6.1 The relation R(f,g) is a simulation.
Proof. Suppose (u, v) ∈ R(f,g), let x = α(u) and y = K (T)f · α(u), then we have
α(u) ≤K (T)U x and y ≤K (T)V β(v). Since y = K (T)f · x, we have
K (T)f · x ≤Rel(K (T))(R(f,g) ) y
Therefore, (x, y) ∈ Rel(K (T))(R(f,g)). So
(α(u), β(v)) ∈≤K (T)U ·Rel(K (T))(R(f,g) )· ≤K (T)V

and thus R(f,g) is a simulation.	 
Corollary 6.2 If the preorder ≤ be equality =, then R(f,g) is a bisimulation.
Proof. Similar to the proof of Theorem 6.1.	 
An elegant approach to prove a simulation with a pre-Galois connection is to use a forward (backward) morphism as an intermediary. For given components p = (U, α) and q = (V, β), if h : U → V is proved to be a forward morphism between them, then p is a behavior refinement of q, witnessed by h. We can lift h into a pre-Galois connection (f, g) as follows:
f (u)= h(u) and g(v)= U where for every u ∈B U , β(h(u)) ≤K (T)V β(v).
By this lifting technique, once an arrow h is defined and proved to be a forward
morphism, then it is lifted automatically into a pre-Galois connection. And we can easily recover the forward morphism h from a pre-Galois connection (f, g), by defining h = f .

Conclusion
In this paper the notion of pre-Galois connection between coalgebras in the Kleisli category has been introduced. We rebuild the coalgebraic model for state-based components in [2,13] in the Kleisli category, which goes one step higher on the “generic” ladder, because it unifies the behavior model and transition types into one functor over the Kleisli category instead of using one monad and one functor for representing them as in [2,13] respectively. The refinement theory for generic state- based components in [13,14] is re-examined for coalgebras in the Kleisli category. We defined the notion of pre-Galois connection based on the refinement preorder over the functors, and proved a series of properties for pre-Galois connection. This concept provides a powerful tool in witnessing refinement relation between state- based component.
In terms of future work, what we would like to do in the next step is to apply pre-Galois connection to some refinement examples. Another challange to this work is to go deeper into the concept itself. For example, one issue we intend to study is to establish the theorems that predict the existence of the adjoints in a pre- Galois connection, another interesting problem is the completeness of pre-Galois connections for refinement, i.e., if we can build a pre-Galois connection for every refinement relation.

Acknowledgement
The work reported in this paper is supported by the National Natural Science Foundation of China under Grant No. 60473056, and a grant from the GLANCE funding program of the Dutch National Organization for Scientific Research (NWO),

through project CooPer (600.643.000.05N12). It is a pleasure to acknowledge Luis
S. Barbosa for motivating discussions. The author is also indebted to Prof. Jan Rutten, Clemens Kupke and Helle H. Hansen for helpful suggestions.

References
Lu´ıs Soares Barbosa. Components as Coalgebras. PhD thesis, Universidade do Minho, Braga, Portugal, 2001.
Lu´ıs Soares Barbosa. Towards a Calculus of State-based Software Components. Journal of Universal Computer Science, 9(8):891–909, August 2003.
Lu´ıs Soares Barbosa and Jos`e Nuno Fonseca de Oliveira. State-based components made generic. In
H. Peter Gumm, editor, Elect. Notes in Theor. Comp. Sci. (CMCS’03 - Workshop on Coalgebraic Methods in Computer Science), volume 82.1, Warsaw, April 2003.
Lu´ıs Soares Barbosa and Jos`e Nuno Fonseca de Oliveira. Transposing Partial Coalgebras: An exercise on coalgebraic refinement. Theoretical Computer Science, 365(1-2):2–22, 2006.
Lu´ıs Soares Barbosa, Sun Meng, Bernhard K. Aichernig, and Nuno Rodrigues. On the semantics of componentware: a coalgebraic perspective. In Jifeng He and Zhiming Liu, editors, Mathematical Frameworks for Component Software.- Models for Analysis and Synthesis, chapter 3. World Scientific, 2006.
P. Cousot and R. Cousot. Abstract interpretation: a unified lattice model for static analysis of programs. In Proceedings of 4th ACM Symp. on Principles of Programming Languages, pages 238–252. ACM Press, 1977.
Ichiro Hasuo. Generic Forward and Backward Simulations. In C. Baier and H. Hermanns, editors,
CONCUR 2006, volume 4137 of LNCS, pages 406–420. Springer, 2006.
Charles Antony Richard Hoare and Jifeng He. Unifying Theories of Programming. Prentice Hall International, 1998.
Bart Jacobs. Exercises in coalgebraic specification. In R. Backhouse, R. Crole, and J. Gibbons, editors, Algebraic and Coalgebraic Methods in the Mathematics of Program Construction, volume 2297 of LNCS, pages 237–280. Springer, 2002.
Bart Jacobs and Jesse Hughes. Simulations in coalgebra. In H. Peter Gumm, editor, Elect. Notes in Theor. Comp. Sci. (CMCS’03 - Workshop on Coalgebraic Methods in Computer Science), volume 82, pages 245–263, Warsaw, April 2003.
A. Melton, D. A. Schmidt, and G. E. Strecker. Galois connections and computer science applications. In Category Theory and Computer Programming, volume 240 of LNCS, pages 299–312. Springer-Verlag, 1985.
Sun Meng, Lu´ıs S. Barbosa, and Zhang Naixiao. On Refinement of Software Architectures. In
Proceedings of ICTAC’05, volume 3722 of LNCS, pages 482–497. Springer, 2005.
Sun Meng and Lu´ıs Soares Barbosa. On Refinement of Generic State-based Software Components. In
C. Rattray, S. Maharaj, and C. Shankland, editors, Algebraic Methodology And Software Technology, 10th International Conference, AMAST’04, Proceedings, volume 3116 of LNCS, pages 506–520. Springer, 2004.
Sun Meng and Lu´ıs Soares Barbosa. Components as Coalgebras: the Refinement Dimension. Theoretical Computer Science, 351(2):276–294, 2006.
Oystein Ore. Galois connexions. Trans. Amer. Math. Soc., 55:493–513, 1944.
Jan Rutten. Universal coalgebra: a theory of systems. Theoretical Computer Science, 249:3–80, 2000.
Clemens Szyperski, Dominik Gruntz, and Stephan Murer. Component Software – Beyond Object- Oriented Programming, Second Edition. Publishing House of Electronics Industry, 2003.
