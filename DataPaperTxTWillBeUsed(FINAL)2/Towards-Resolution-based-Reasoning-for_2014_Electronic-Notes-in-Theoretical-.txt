Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 305 (2014) 85–102
www.elsevier.com/locate/entcs

Towards Resolution-based Reasoning for Connected Logics
Claudia Nalon1,2
Department of Computer Science University of Bras´ılia, Brazil

Oliver Kutz3
Institute of Knowledge and Language Engineering Otto-von-Guericke University Magdeburg, Germany


Abstract
The method of connecting logics has gained a lot of attention in the knowledge representation and ontology communities because of its intuitive semantics and natural support for modular KR, its generality, and its robustness concerning decidability preservation. However, so far no dedicated automated reasoning solutions have been developed, and the only reasoning available was via translation into sufficiently expressive logics. In this paper, we present a simple modalised version of basic E -connections, and develop a sound, complete, and terminating resolution-based reasoning procedure. The approach is modular and can be extended to more expressive versions of E -connections.
Keywords: E -connections, normal modal logics, theorem-proving, resolution method, bridge principles.


Introduction
Modal and other non-classical logics have been developed in a great variety to address various modelling requirements, be it spatial, temporal, deontic, etc. How- ever, special purpose formalisms are often difficult to extend, and methodologies for combining logics into many dimensional formalisms have therefore been studied

1 Cl´audia Nalon was supported by CAPES Foundation BEX 8712/11-5. The work of Oliver Kutz was sup- ported by the DFG funded Research Center on Spatial Cognition SFB/TR 8, and the COINVENT project funded through the Future and Emerging Technologies (FET) programme within the Seventh Framework Programme for Research of the European Commission, under FET-Open Grant number: 611553.
2 Email: nalon@unb.br
3 Email: okutz@iws.cs.ovgu.de

http://dx.doi.org/10.1016/j.entcs.2014.06.007 1571-0661/© 2014 Published by Elsevier B.V.

extensively, in particular techniques such as products [8], fusions [12], or fibrings [5], as well as structuring techniques for heterogeneous logical theories [16].
The method of connecting, or E-connecting logics, in particular, has gained a lot of attention in the knowledge representation and ontology communities because of its intuitive semantics (being closely related to counterpart theory [11]) and natural support for modular KR [7], its generality, and its robustness concerning decidability preservation [1,14]. However, so far no dedicated automated reasoning solutions have been developed, and the only reasoning available was via translation into sufficiently expressive logics [6,16]. The E -connection method is closely related to Distributed Description Logics (DDLs) [4], for which a method of distributed tableaux has been developed [23]. Nevertheless, the standard DDL language is strictly less expressive than E -connections, as shown in [14]. The main difference, in a nutshell, is that whilst DDLs only provide atomic formulae for linking two logics, E -connections allow to build new ‘complex concepts’ in the components, using DL terminology. In modal logic terms, it means they allow to construct new formulae using modalities from foreign logics along bridge modalities. Here, bridge modalities belong to neither of the component logics, but are interpreted with the help of new accessibility relations that are two-sorted in nature, i.e. go across respective models interpreting the component languages. This also explains the generality of the approach compared to DDLs, as the logic of these bridge modalities can be freely varied.
Compared to other combination methodologies, an interesting aspect of E -con- nections is that, unlike products, no so-called bridge principles are introduced by the combination method itself. An example would be 2-commutativity or Church- Rosser properties automatically being validated in products, see [5]. This is avoided in E -connections because the languages are kept disjoint, and are being connected only via the bridge modalities—bridge principles therefore only arise explicitly when added as new axioms.
In this paper, we present a simple modalised version of basic E -connections and a sound, complete, and terminating resolution-based reasoning procedure for deal- ing with this kind of combination. We note that E -connections have been widely applied to combining Description Logics [13,7] and that experimental evaluation shows that resolution performs well for such logics [10,20]. The reasoning proce- dure we introduce here is very simple in its structure, keeping the calculi for the component logics disjoint, and introducing a set of resolution-based inference rules that extend the method in [19] to solve the satisfiability problem in logics connect- ing K-components via K-bridge modalities. The approach is modular and can be extended to more expressive versions of E -connections.
The paper is structured as follows. In Section 2, we present the syntax and semantics of the multi-modal logic K(n). In Section 3, a basic modalised version of E -connections is defined. Section 4 introduces the resolution method for connected logics, together with examples, and Section 5 sketches the correctness proofs. Re- sults and related work are discussed in Section 6.

The Normal Modal Logic K(n)
The weakest of the normal modal systems, known as K(n), is an extension of the
classical propositional logic with the operators	, 1 ≤ a ≤ n, where the axioms

Ka, that is,
(ϕ → ψ) → (
ϕ →
ψ), hold. There is no restriction on the

accessibility relation over worlds. As the subscript in K(n) indicates, we consider the multi-agent version, that is, the fusion of several copies of K(1).
Formulae are constructed from a denumerable set of propositional symbols (or variables), P = {p, q, pj, qj, p1, q1,.. .}. The finite set of agents is defined as A = {1,..., n}, n ∈ N. Besides the propositional connectives (true, ¬, ∧), we

introduce a set of unary modal operators M = {
,..., 
}, where
ϕ is read

as “agent a considers ϕ necessary”. When n = 1, we may omit the index, that is,

 ϕ =
ϕ. The fact that agent a considers ϕ possible is denoted by
ϕ. The

language L of K(n) is given by L = P∪ M ∪ {true, ¬, ∧}. Next, we define the set of well-formed formulae of K(n):
Definition 2.1 The set of well-formed formulae, F(K(n)), is given by:
the propositional symbols are in F(K(n));
true is in F(K(n));

if ϕ and ψ are in F(K(n)), then so are ¬ϕ, (ϕ ∧ ψ), and
ϕ (for all a ∈ A).

A literal is either a proposition or its negation. Let Lit be the set of all literals. A

modal literal is either
l or ¬
l, where l ∈ Lit and a ∈ A.

Semantics of K(n) is given, as usual, in terms of a Kripke structure.
Definition 2.2 A Kripke structure M for n agents over P is a tuple M =
⟨W, w0, π, R1,..., Rn⟩, where W is a set of possible worlds (or states) with a dis- tinguished world w0 ; the function π(w): P → {true, false}, w ∈ W, is an interpre- tation that associates with each state in W a truth assignment to propositions; and each Ra ⊆W × W is a binary relation on W.
The binary relation Ra captures the possibility relation according to agent a: a pair (w, wj) is in Ra if agent a considers world wj possible, given her information in world w. We write (M, w) |= ϕ to say that ϕ is true at world w in the Kripke structure M.
Definition 2.3 Truth of a formula is given as follows:
(M, w) |= true
(M, w) |= p if, and only if, π(w)(p)= true, where p ∈P 
(M, w) |= ¬ϕ if, and only if, (M, w) |= ϕ
(M, w) |= (ϕ ∧ ψ) if, and only if, (M, w) |= ϕ and (M, w) |= ψ

(M, w) |=
ϕ if, and only if, for all wj, such that (w, wj) ∈ Ra, (M, wj) |= ϕ.

The formulae false, (ϕ ∨ ψ), (ϕ → ψ), and	ϕ are introduced as the usual ab-
breviations for ¬true, ¬(¬ϕ ∧ ¬ψ), (¬ϕ ∨ ψ), and ¬	¬ϕ, respectively. Formulae

are interpreted with respect to the distinguished world w0. Intuitively, w0 is the world from which we start reasoning. Let M = ⟨W, w0, π, R1,..., Rn⟩ be a Kripke structure with a distinguished world w0. Thus, a formula ϕ is said to be satisfiable in M if (M, w0) |= ϕ; ϕ is said to be satisfiable if there is a model M such that (M, w0) |= ϕ; and ϕ is said to be valid if for all models M then (M, w0) |= ϕ. Satisfiability of sets is defined as usual. A finite set Γ ⊂ F(K(n)) is satisfiable at the state w in M, denoted by (M, w) |= Γ, if (M, w) |= γ0 ∧ ... ∧ γn, for all γi ∈ Γ, 0 ≤ i ≤ n;Γ is satisfiable in a model M, denoted by M |= Γ, if (M, w0) |= Γ; and Γ is satisfiable, if there is a model M such that M |= Γ.

Modalising Connections
In this section, we present a basic modalised version of E -connections. For the purpose of illustrating our resolution-based calculus, it will suffice to introduce connections of normal modal operators with K-like bridge operators.
E -connections were originally conceived as a versatile and well-behaved technique for combining logics [14], but have been quickly adopted as a framework for the integration of ontologies and modular reasoning in the Semantic Web [7]. The general idea behind this combination method is that the interpretation domains of the connected logics are interpreted by disjoint vocabulary and interconnected by means of link relations. The language of the E -connection is then the union of the original languages enriched with operators capable of talking about the link relations.
The most important feature of E -connections is that they offer an appealing compromise between expressive power and computational complexity: although powerful enough to express many interesting concepts, the coupling between the combined logics is sufficiently loose for proving general results about the transfer of decidability. Such transfer results state that if the connected logics are decidable, then their connection (under certain restrictions) will also be decidable.
The generality of the transfer results for E -connections obtained in [14] is due to the fact that E -connections are defined and investigated using the framework of so- called abstract description systems (ADSs), a common generalisation of description logics, modal logics, logics of time and space, and many other logical formalisms [2]. Thus, we can connect not only DLs with DLs, but also, say, description logics with spatial logics (and in the general case n ADSs for any n ∈ N). A natural interpretation of link relations in this context would then be, for instance, to describe the spatial extension of abstract (DL) objects. Indeed, the idea of E -connections was first described for this scenario in [17], and the ‘E ’ in E -connections stems from the concept of ‘spatial Extension’. Several extensions to the basic E -connection language have been studied in [14], including Booleans on links, number restrictions on links, link operators on object names, and first-order link constraints.
Let L1 and L2 be two normal multi-modal logics that are to be connected. We assume that the languages L1 and L2, i.e., the propositional variables and modal operators of L1 and L2, are pairwise disjoint; however, for simplicity of presentation

we here identify the (classical) Boolean operators of L1 and L2. Note that separat- ing propositional connectives only becomes relevant when connecting logics with a non-classical propositional base logic, e.g. when combining intuitionistic logic with classical or relevant logic, a topic which we intend to follow up on in future work.
To define the language of a modal connection, we need to fix additionally the sets of bridge modalities given by


M = M1 ∪ M2, with M1 = {
1 | j ∈ I1},	M2 = {
2 | k ∈ I2}

where both I1, I2 are countable, non-empty index sets.
A similar language was sketched in [6], called one-way E -connections, presenting a formulation of E -connections in DL syntax and removing the build-in inverse relations of [14] in order to allow for a better comparison to DDLs [4].
The set of formulae of the basic modal connection language CM(L1, L2) is a two-sorted language partitioned into a set of 1-formulae and a set of 2-formulae. In the following, we set 1=2 and 2 = 1 and denote by |S| the cardinality of a set
S. Intuitively, i-formulae are the formulae of Li enriched with new modalities for talking about i-formulae accessed via linking accessibility relations. We often refer to a connection CM(L1, L2) simply as CM once the Li have been fixed.
Definition 3.1 [Modal Connection Language] The sets of 1-formulae  and
2-formulae of CM(L1, L2) are defined by simultaneous induction, for i ∈ {1, 2}:
every propositional variable of Li is an i-formula;
i-formulae are closed under Boolean operators and the modalities of Li;

(3.1) if ϕ is a 1-formula and k ∈ I2, then
(3.2) if ψ is a 2-formula and j ∈ I1, then
2ϕ is a 2-formula.
1ψ is a 1-formula.

The set of i-formulae of CM is denoted by F(CM)i, i = 1, 2. The set of formulae of CM is F(CM)1 ∪ F(CM)2. A theory in CM is a pair Γ = ⟨Γ1, Γ2⟩, where Γi, i = 1, 2, are finite sets of i-formulae. CM is called finitely linked if |I1|, |I2|∈ N, and unarily linked if |I1| = |I2| = 1.
Example 3.2 [Well-formed expressions] To illustrate the language just defined, we give a number of well-formed expressions. Let ϕ1, ϕ2 be formulae of L1, and ψ1, ψ2 formulae of L2. The following are well-formed


h 1¬
2ϕ1 →¬ 
ψ1	ϕ1 ∧¬ h  (ψ1 ∨ ψ2 ∨
2ϕ2)

In contrast, the following expressions are ill-formed:


h 1¬
2ϕ1 →¬ 
ϕ1	ϕ1 ∧¬ h  ϕ1

because, in the first case, we are forming a Boolean combination of a 1-formula with a 2-formula, which is undefined, and in the second case, we apply a 1-modality to a 1-formula, which is undefined.

Given the language of a connection CM(L1, L2), a connected Kripke model for a modal connection CM(L1, L2) consists of a Kripke model for L1, a Kripke model for L2, and an interpretation of a set E of link relations associated with the bridge modalities. The details of the semantics are as follows:
Definition 3.3 [Connected Kripke Models] A structure


M = ⟨W1, W2, (E1)
j∈I1
, (E2)
k∈I2 ⟩

where Wi = ⟨Wi, wi , πi, Ri ,..., Ri ⟩ (as defined in Def. 2.2) is a Kripke model of
0	1	n
Li for i ∈ {1, 2}, and E1 ⊆ W1 × W2 for each j ∈ I1 and E2 ⊆ W2 × W1 for each
j	k
k ∈ I2, is called a connected Kripke model for CM(L1, L2). The members of the set
E = E1 ∪ E2, with E1 = {E1 | j ∈ I1},	E2 = {E2 | k ∈ I2}
j	k
are called link relations.
Satisfaction of an i-formula χ at a world w of Li is defined by simultaneous induction. The Booleans and local modalities of logic Li are defined in the standard way (as given earlier). The remaining cases are as follows. Let ϕ be a 1-formula, and ψ be a 2-formula, w1 a world in W1, w2 a world in W2:

(M, w1) |=
(M, w2) |=
1ψ ⇐⇒ ∃w2 ∈ W2 such that w1E1w2 and (M, w2) |= ψ
2ϕ ⇐⇒ ∃w1 ∈ W1 such that w2E2w1 and (M, w1) |= ϕ


Example 3.4 [Normality and Bridge Logic] Define bridge boxes by setting:


1 := ¬
1¬
2 := ¬	2¬

Then, for any connected Kripke model M and any worlds w1, w2, we have

(M, w1) |=
(M, w2) |=
1(ϕ → ψ) → (
2(χ → τ ) → (
1ϕ →
2χ →
1ψ)
2τ )

The proof is given in Example 4.2. Moreover, it is easy to see that bridge modalities satisfy the rule of Necessitation. Indeed, this already gives a complete axiomatisa- tion of the basic bridge modalities introduced in Def. 3.3 (as hinted at already in [1]) and shows that they are K-modalities, illustrating that the connection method does not, by itself, introduce additional bridge principles.
Example 3.5 [Inverse Relations] In general connected Kripke structures, the re- lations in E1 and E2 are completely independent. In DLs, inverse (or converse) relations are of great importance in modelling, and they were natively built into the (semantically given) standard definition of E -connections. Here, E1 is the in- verse of E2 if for all x, y we have: ⟨x, y⟩ ∈ E1 ⇐⇒ ⟨y, x⟩ ∈ E2. However, this is unnecessary: it is folklore in temporal logic that inverse modalities can be easily axiomatised (see [9]).

Consider the following theory T in CM(L1, L2), where the Li denote two arbitrary propositional modal logics, and p is a 1-variable, j ∈ I1, and q is a 2-variable, k ∈ I2.


T = {p →
1
2p,	q →
2
1q}

We claim that T is valid in CM(L1, L2) if, and only if, E1 is the inverse of E2.
j	k
A proof is obtained by mimicking the proof for monomodal logic given in [22,
Theorem 1]. A sketch is as follows: (i) the validity of T is immediate if we assume that E1 is the inverse of E2; (ii) conversely, assume that T is valid in CM(L1, L2).
j	k
Assume ⟨w1, w2⟩ ∈ E1 for a model where w1 |= p and p is false everywhere else in

W1. Since w1 |= p →
1
2p, it follows that w2 |=
2p, i.e. there is a w3 ∈ W1

such that ⟨w2, w3⟩∈ E2 and w3 |= p. But, by the definition of the model, it follows
that w1 = w3, which means that E1 ⊆ (E2)−1. The other inclusion is obtained in
j	k
a similar way using the second axiom.
The Bridge Calculus
In this section we present the resolution-based calculus for CM, RESE. The approach is clausal: a formula to be tested for (un)satisfiability is firstly translated into a normal form, given in Section 4.1, and then the inference rules given in Section 4.2 are applied until either a contradiction is found or no new clauses can be generated. The calculus incorporates inference rules to deal with each of the component logics, which are syntactical variants of the inference rules given in [19], and also inference rules to deal with the connections between these components.
In the following, let L1 and L2 be two normal multi-modal logics, where the set of propositional symbols and modal operators in L1 and L2 are pairwise disjoint.

Let {
i | a ∈ Ai}, with Ai = {1,..., ni}, i = 1, 2, ni ∈ N, be the set of modalities

in the language of Li. Let CM be the language of the connection between L1 and L2,
where the set of connecting modalities is given by M = M1 ∪M2 with M1 = {	1 |
2
j ∈ I1} and M2 = {	| k ∈ I2}, where both I1, I2 are countable, non-empty

index sets. Let M = ⟨W1, W2, (E1)
j∈I1
, (E2)
k∈I2
⟩ be the connected Kripke model

for CM(L1, L2), where Wi = ⟨Wi, wi , πi, Ri ,..., Ri
⟩ is the underlying model for Li

and wi
0	1	ni
is the distinguished world in Wi.


The Normal Form for Connected Logics
Formulae in the language of CM can be transformed into a normal form called Separated Normal Form for Connected Logics, SNFE. A formula to be tested for satisfiability is firstly translated into a CM-problem, given by C = ⟨C1, C2⟩ where each Ci, i = 1, 2, is a tuple Ci = ⟨Si, Gi, Ki⟩, where M |= Ci if and only if (M, wi ) |= Si and (M, w) |= Gi ∪ Ki, for all w ∈ Wi. Also, M |= C if and only if M |= Ci, i = 1, 2. Each Ci of a CM-problem is called a Ci-problem. Intuitively, a Ci-problem contains formulae which are in F(CM)i. As before, we set 1 = 2 and 2 = 1. Thus, in the following, C1 (resp. C2) stands for C2 (resp. C1).

Recall that the semantics in each component of the connected logic is given with respect to a pointed-model, that is, satisfiability is defined in terms of the distin-

guished world wi
within each component logic. Therefore, in order to represent

the world from which we start reasoning, we introduce the new constants starti,
i = 1, 2, where (M, w) |= starti if, and only if, w = wi .
In order to apply the resolution method to a problem, we further require that the formulae in Si are initial clauses; the formulae in Gi are literal clauses; and the formulae in Ki are modal clauses. That is, they have the following syntactic form, for each component logic Li:
b=1 lb Literal clause true → r lb Positive a-clause   lj → a il
Negative a-clause lj → ¬		 il Positive Ek-clause lj →	il Negative Ek-clause lj → ¬		il
where l, lj, and lb are literals; a ∈ Ai; and k ∈ Ii. Positive and negative a-clauses (resp. positive and negative Ek-clauses) are together known as modal a-clauses (resp. modal Ek-clauses); the index may be omitted if it is clear from the context. Modal a-clauses and Ek-clauses are referred as modal clauses.
The translation into the SNFE uses the renaming technique [21], where complex subformulae are replaced by new propositional symbols and the truth of these new symbols is linked to the formulae that they replaced in all states within the model corresponding to the component language we are dealing with. Classical operators are removed by rewriting.
Assume that a given formula ϕ to be tested for (un)satisfiability is an i-formula in Negated Normal Form (NNF), that is, a formula where implications are removed by classical rewriting and negations are applied to propositional symbols only. The transformation into the SNFE, starts by taking the Cn-problem ⟨C1, C2⟩, where Ci = ⟨{starti → t}, {t → ϕ}, ∅⟩ and Ci = ⟨∅, ∅, ∅⟩ where t is a new propositional symbol in Li. The transformation proceeds by applying the following rewrite rules together with the usual simplification rules for classical logic (where ϕ1 and ϕ2 are formulae in F(Cn)i, t is a literal, t1 is a new propositional symbol in the language of Li, and Ci = ⟨Si, Gi, Ki⟩):



⟨Si, Gi ∪ {t → ϕ1 ∧ ϕ2}, Ki⟩ −→ ⟨Si, Gi ∪ {t → ϕ1,t → ϕ2}, Ki⟩
⟨Si, Gi ∪ {t → ϕ1 ∨ ϕ2}, Ki⟩ −→ ⟨Si, Gi ∪ {t → ϕ1 ∨ t1, t1 → ϕ2}, Ki⟩
where ϕ2 is not a disjunction of literals
⟨Si, Gi ∪ {t → ϕ1}, Ki⟩ −→ ⟨Si, Gi ∪ {true → ¬t ∨ ϕ1}, Ki⟩
where ϕ1 is a disjunction of literals or a constant

⟨Si, Gi, Ki ∪ {t →
iϕ1}⟩ −→ ⟨Si, Gi, Ki ∪ {t →¬ 
i¬ϕ1}⟩

The next rule moves modal clauses to the appropriate set, where ϕ1 is either of the

form
iψ, ¬
iψ,
iψ, ¬
iψ, with a ∈ Ai and k ∈ Ii:

⟨Si, Gi ∪ {t → ϕ1}, Ki⟩ −→ ⟨Si, Gi, Ki ∪ {t → ϕ1}⟩
We rename complex subformulae enclosed in a modal operator as follows, where t1
is a new propositional symbol in Li and ϕ1 ∈ F(Cn)i is not a literal.


⟨Si, Gi, Ki ∪ {t →
iϕ1}⟩ −→ ⟨Si, Gi ∪ {t1 → ϕ1}, Ki ∪ {t →
it1}⟩

⟨Si, Gi, Ki ∪ {t →¬ 
iϕ1}⟩ −→ ⟨Si, Gi ∪ {t1 → ¬ϕ1}, Ki ∪ {t →¬ 
i¬t1}⟩

We also rename complex subformulae enclosed in a connecting operator as follows, where t1 is a new propositional symbol in the language of Li and ϕ1 ∈ F(Cn)i.



τ1 :
  ⟨Si, Gi, Ki ∪ {t →
iϕ1}⟩
−→

  ⟨Si, Gi, Ki ∪ {t →
it1}⟩ 

⟨Si, Gi, Ki⟩	⟨Si, Gi ∪ {t1 → ϕ1}, Ki⟩



τ2 :
  ⟨Si, Gi, Ki ∪ {t →¬ 
iϕ1}⟩
−→

  ⟨Si, Gi, Ki ∪ {t →¬ 
i¬t1}⟩ 

⟨Si, Gi, Ki⟩	⟨Si, Gi ∪ {t1 → ¬ϕ1}, Ki⟩

Some care needs to be taken when applying the preceding rewrite rules in order to ensure that the translation is terminating. This can be easily done by keeping track of which clauses have already been rewritten and, as so, preventing the procedure of applying these rules twice to any Ek-clauses. The proof that ϕ, the original formula, is satisfiable if, and only if, the problem C resulting from applying the rewrite rules above is satisfiable is similar to that in [19] and sketched in Section 5. Note that, at the end of the translation, each a-modal clause and each Ek-modal clause contains only one modal literal. As so, the different contexts belonging to different agents and to different connecting modalities are already separated at the end of the translation. Separating such contexts helps in the design and implementation of the resolution calculus given in Section 4.2.

Example 4.1 [Transformation] Consider the following 1-formula:
ϕ =  1  2(p → q) ∧  1  2p ∧ 1 2¬q
where {p, q} is in L1. We start the transformation by taking C1 = ⟨{start1 → t0}, {t0 → ϕ}, ∅⟩ and C2 = ⟨∅, ∅, ∅⟩. As ϕ is a conjunction, we apply the transfor- mation to formulae in G1, obtaining:

G1 = {t0 →  1	2(p → q), t0 →  1  2p, t0 → 1 2¬q}
where the underlined formula is a 2-formula. Complex subformulae in the scope of modal operators are not allowed by the normal form. We introduce the propositional symbol t1 and replace  2(p → q) in the scope of  1. That is, we have the set G1 rewritten as

G1 = {t0 →  1t1, t0 →  1  2p, t0 → 1 2¬q}
and the set G2 is now given by:

G2 = {t1 →  2(p → q)}.
As this is a modal formula, C2 is rewritten as:
G2 = ∅ and K2 = {t1 →  2(p → q)}.
The underlined formula is a 1-formula, therefore a new propositional symbol t2 is introduced and linked to the formula p → q. That is, the set of modal formulae in C2 is rewritten as:
K2 = {t1 →  2t2}
and the corresponding 1-formula is added to C1, that is, G1 is rewritten as:
G1 = {t0 →  1t1, t0 →	1	2p, t0 →	1	2¬q, t2 → (p → q)}

Similar steps are taken to transform the underlined formulae above. After classical rewriting, the resulting problem is given by ⟨C1, C2⟩, where:

C1 = ⟨S1 = {start1 → t0},
G1 = {true → ¬t2 ∨ ¬p ∨ q, true → ¬t4 ∨ p, true → ¬t6 ∨ ¬q},
K1 = {t0 →  1t1, t0 →  1t3, t0 →¬  1¬t5}⟩

and




C2 = ⟨S2 = {},
G2 = {},
K2 = {t1 →  2t2, t3 →  2t4, t5 →¬  2¬t6}⟩






Inference Rules

The resolution-based calculus for the connected logics Cn, RESE, is applied to a Cn- problem until either a contradiction is found or no new clauses can be generated. Given a Cn-problem C = ⟨C1 = ⟨S1, G1, K1⟩, C2 = ⟨S2, G2, K2⟩⟩, a contradiction is given by starti → false ∈ Si or true → false ∈ Gi, for any i = 1, 2.
The (sets of) inference rules deal with the different contexts within each compo- nent logic. Therefore, there is a set of inference rules to deal with the propositional part of each component language; a set of inference rules to deal with the multi- modal part within each language; and a set of inference rules to deal with the connection between the two languages. The first two set of rules, related to literal and modal resolution, are a syntactic variation of the calculus presented in [19].
In the following, l, lj, lb, lj ∈ Lit (b ∈ N) and D, Dj are disjunctions of literals. The first set of inference rules correspond to classical resolution. Literal res- olution (LRES) is classical resolution applied to the propositional portion of the multi-modal logic within each component logic. Also, an initial clause may be re- solved with either a literal clause or an initial clause (IRES1 and IRES2). For those rules, both the parent clauses and the resolvent are in sets of the same Ci- problem.  Because clauses are in a specific form, all three rules are needed for
completeness.


[IRES1] true → D ∨ l
start → Dj ∨ ¬l


start → D ∨ Dj
[IRES2] start → D ∨ l
start → Dj ∨ ¬l


start → D ∨ Dj
[LRES] true → D ∨ l
true → Dj ∨ ¬l


true → D ∨ Dj

The modal resolution rules are applied between clauses which refer to the same context, that is, they must refer to the same agent, within the same component

logic. For instance, we can resolve two or more
1-clauses (MRES and GEN2);

or several
i-clauses and a literal clause in Gi (GEN1 and GEN3). The modal

inference rules are:



[MRES]	l1 →	il
l2 →¬	il
[GEN2]	lj1 →
lj2 →
il1 i¬l1

true → ¬l1 ∨ ¬l2
lj3 →¬ 
i¬l2


true → ¬lj1 ∨ ¬lj2 ∨ ¬lj3

[GEN1]	lj1 →
.
ljm →
lj →¬ 
i¬l1


i¬lm i¬l
[GEN3]	lj1 →
.
ljm →
lj →¬ 
i¬l1


i¬lm i¬l

true → l1 ∨ ... ∨ lm ∨ ¬l
true → ¬lj1 ∨ ... ∨ ¬ljm ∨ ¬lj
true → l1 ∨ ... ∨ lm


true → ¬lj1 ∨ ... ∨ ¬ljm ∨ ¬lj

The inference rule MRES is a syntactic variation of classical resolution, as a formula and its negation cannot be true at the same state. The rule GEN1 corresponds to generalisation and several applications of classical resolution in a particular state: as clauses in Gi are true at every state, the literal clause in the premises implies

true →
i(l1 ∨ ... ∨ lm ∨ ¬l); by propositional reasoning and by the axiom K, we

have true → ¬ 
i¬l1 ∨ ... ∨¬ 
¬lm ∨
¬l; the modal literals in this formula

can then be resolved with their complements in the other parent clauses. GEN2 is a special case of GEN1, as the parent clauses can be resolved with tautologies as true → l1 ∨ ¬l1 ∨ ¬l2. GEN3 is similar to GEN1 but the contradiction occurs between the right-hand side of the positive a-clauses and the literal clause. The resolvents in the inference rules GEN1, GEN2, and GEN3 impose that the literals on the left-hand side of the modal clauses in the premises are not all satisfied whenever their conjunction leads to a contradiction in a successor state. Given the syntactic forms of clauses, the three rules are needed for completeness [19].
The bridge resolution rules that deal with the connecting operators, that is,	i

and ¬
i, a ∈ Ii, are similar to the modal inference rules given above. The inference

rules E -MRES and E -GEN2 are, in fact, just syntactic variants of MRES and GEN2: reasoning can be applied in the component language Li even if there is no information about the other component, Li. However, the inference rules E -GEN1 and E -GEN3 are different, in the sense that they implement the reasoning between the two different languages. Note that the modal clauses in the premises of these inference rules are in Ci, but the literal clauses are in the other component, Ci, as
the literals in the scope of the	i and ¬	i operators are in the language of Li.
Therefore, we use the propositional language of Li to pass enough information from
Li to Li, in order to apply the reasoning mechanism in the context of Li.



[E -MRES]	l1 →	il
l2 →¬	il
[E -GEN2]	lj1 →
lj2 →
il1 i¬l1

true → ¬l1 ∨ ¬l2
lj3 →¬ 
i¬l2


true → ¬lj1 ∨ ¬lj2 ∨ ¬lj3

[E -GEN1]	lj1 →
.
ljm →
lj →¬ 
i¬l1


i¬lm i¬l
[E -GEN3]	lj1 →
.
ljm →
lj →¬ 
i¬l1


i¬lm i¬l

true → l1 ∨ ... ∨ lm ∨ ¬l
true → ¬lj1 ∨ ... ∨ ¬ljm ∨ ¬lj
true → l1 ∨ ... ∨ lm


true → ¬lj1 ∨ ... ∨ ¬ljm ∨ ¬lj

The justification for the bridge inference rules are similar to the justification for the modal inference rules. We sketch the soundness proof for some of the bridge inference rules in Section 5. Completeness is sketched in the same section.
Simplification. We assume standard simplification from classical logic to keep the clauses as simple as possible. For example, D ∨ l ∨ l on the right-hand side of an initial or literal clause would be rewritten as D ∨ l.
Example 4.2 The schemata given in Example 3.4 is a valid formula in Cn. The following formula is a negated instance of such schema

ϕ =  1  2(p → q) ∧  1  2p ∧¬  1  2q
and we show that ϕ is, in fact, unsatisfiable. The problem resulting from trans- forming ϕ into the SNFE was given in Example 4.1. Clauses 1-10 are resulting from the transformation of ϕ into its normal form.

start1 → t0	[S1]
t0 →  1t1	[K1]
t1 →  2t2	[K2]
true → ¬t2 ∨ ¬p ∨ q [G1]
t0 →  1t3	[K1]
t3 →  2t4	[K2]
true → ¬t4 ∨ p	[G1]
t0 → ¬	1¬t5 [K1]
t5 → ¬	2¬t6 [K2]
true → ¬t6 ∨ ¬q [G1]

The refutation proceeds as follows. Clauses 11 and 12 are obtained by applications of classical resolution. Clause 13 is resulting from an application of E -GEN1 to 2-clauses in C2 and a literal clause in C1. Clause 14 is also resulting from an application of E -GEN1, but to 1-clauses in C1 and a literal clause in C2. As a contradiction was found, given by clause 15, which is obtained by an application of classical resolution, the Cn-problem is unsatisfiable and so is ϕ.

true → ¬t2 ∨ ¬p ∨ ¬t6 [G1, LRES, 10, 4]
true → ¬t2 ∨ ¬t4 ∨ ¬t6 [G1, LRES, 11, 7]
true → ¬t1 ∨ ¬t3 ∨ ¬t5 [G2, E -GEN1, 12, 9, 6, 3]
true → ¬t0	[G1, E -GEN1, 13, 8, 5, 2]
start → false	[S1, IRES2, 14, 1]


Correctness Results
In this section, we sketch the correctness results related to the resolution-based cal- culus for connected logics, RESE, that is, soundness, termination, and completeness results for the method. The soundness proof shows that the transformation into SNFE as well as the application of the inference rules are satisfiability preserving. Termination is ensured by the fact that a given set of clauses contains only finitely many propositional symbols, from which only finitely many SNFE clauses can be constructed and therefore only finitely many new SNFE clauses can be derived. Completeness is proved by showing that if a given set of clauses is unsatisfiable, there is a refutation produced by RESE.
The proof that transformation of a formula ϕ ∈ F(Cn) into its normal form is satisfiability preserving can be obtained as in [19]. We have added to the transforma- tion rules presented in [19] two new rewrite rules, which deal with the connecting modalities. For the first introduced rewrite rule, τ1, assume ⟨⟨Si, Gi, Ki ∪ {t → iϕ}⟩, ⟨Si, Gi, Ki⟩⟩ is satisfiable in a model M. Construct Mj exactly as M but where π2(w2)(t1)= true if, and only if, (M, w2) |= ϕ. It follows from the semantics of implication, the semantics of the connecting modality, and the semantics of Cn-
problems that Mj |= ⟨⟨Si, Gi, Ki∪{t →	it1}⟩, ⟨Si, Gi∪{t1 → ϕ}, Ki⟩⟩. For the only
if part, it is also easy to check that if Mj |= ⟨⟨Si, Gi, Ki∪{t →	it1}⟩, ⟨Si, Gi∪{t1 →
ϕ}, Ki⟩⟩, then Mj |= ⟨⟨Si, Gi, Ki ∪ {t →	iϕ}⟩, ⟨Si, Gi, Ki⟩⟩. The proof that the
rewrite rule τ2 is satisfiability preserving is similar.
Soundness proofs for the new inference rules can also be obtained as in [19]. For
E -MRES, if both left-hand side of the premises, l1 and l2, are satisfied at a world
wi of a model Wi, then both the right-hand sides would also be satisfied. As	il

and ¬
il are contradictory, the resolvent imposes that we cannot satisfy both l1

and l2 at any state wi ∈ Wi, that is, we have true → ¬l1 ∨ ¬l2 added to Ci. For
E -GEN1, assume there is a state wi ∈ Wi, such that (M, wi) |= lj ∧... ∧lj ∧lj. By
1	m
the semantics of implication and by the semantics of the connecting operators	i

and ¬
i¬, we have that there is a state wi ∈ Wi that satisfies all right-hand sides

of those modal clauses in Ci, i.e. we have that (M, wi) |= l ∧ ¬l1 ∧ ... ∧ ¬lm. As the
premise true → l1 ∨ ... ∨ lm ∨ ¬l holds in every state in Wi, by applying classical resolution at wi, we obtain a contradiction. Thus, the resolvent of E -GEN1 requires that no state in Wi satisfies all the left-hand sides of the modal premises. Similar

reasoning applies to E -GEN2 and E -GEN3.
Completeness can be proven similarly to the completeness of the resolution method given in [19], as all modalities in a Cn-problem, including the connecting modalities, behave like K-modalities. The proof, only sketched here, is based on a behaviour graph, which is essentially a structure that represents all possible models that can be associated with the combined logics. A behaviour graph G = ⟨N, B⟩ contains a set N of nodes, which are maximally consistent sets of literals and modal literals, and a set B of edges, which are labelled by the indexes of modalities in a given logic, that is, they represent the accessibility relation of agents within that logic. For the E -connected logics, given a Cn-problem C = ⟨C1, C2⟩ the behaviour graph is given by G = ⟨N 1, B1, N 2, B2, B⟩, that is, we have one (sub)behaviour graph Gi = ⟨Ni, Bi⟩ associated with the formulae in Ci, for each i, and a set B of edges labelled by the connecting relations. The completeness proof consists in showing that the applications of the inference rules of RESE correspond to deletions of either edges and nodes in the behaviour graph G related to a Cn-problem. That is, we show that G is empty if, and only if, the corresponding problem is unsatisfi- able and, in this case, that there is a proof by the set of inference rules in RESE. As the calculus for L1 and L2 are both complete, the correspondence between deletions in Gi and the set of inference rules for Li is ensured by the results in [19]. For bridge resolution, during the construction of the behaviour graph, we try to add as many edges related to the connecting modalities as possible. In order to satisfy the clauses in C, some edges and nodes are immediately deleted. After that, some nodes and edges are deleted because the modal clauses are no longer satisfied; thus they must also be deleted from the graph. We consider only the case when ¬lj in

a clause such as l → ¬ 
ilj, the literals in the scope of the connecting modality

on the right-hand side of the positive modal E -clauses and the literal clauses all contribute to the contradiction. If there is a node wi that satisfies l and there is no node wi ∈ Ni, ⟨wi, wi⟩ ∈ B, and wi satisfies ¬lj, by applying E -GEN1 to the relevant clauses deletes wi as required. We can show that all deletions in the graph correspond to (some) applications of the inference rules for RESE. The introduction of the resolvents of the inference rules for the connected modalities in the compo- nent Ci deletes nodes in the reduced behaviour graph related to the language of
Li as this corresponds to the fact that a modal literal in the form of ¬	i¬l (with
k ∈ Ii), where l is a literal, is not satisfied in the structure. By induction on the
number of nodes, we can show that the behaviour graph for a Cn-problem C is empty if, and only if, C is unsatisfiable.
Termination is ensured by the fact that no new literals are added to a Cn- problem by any of the inference rules in RESE. Thus, as there is only a finite number of clauses that can be obtained by the method (modulo simplification), at some point either a contradiction is found or no new clauses can be generated.

Outlook

In this paper, we have presented a modalised version of E -connections, which for- malises a simple combination of K logics via a K-bridge logic. As shown in Section 3, the method does not introduce new bridge principles and, therefore, the interaction that arises can be completely controlled by inspecting newly introduced bridge ax- ioms connecting the various modalities.
We have also presented a sound, complete, and terminating resolution-based method for dealing with such combinations. Transformation into the normal form separates the different dimensions where reasoning is carried out. Thus, different sets of specialised inference rules are applied to the different portions of the language and the calculi for the component logics remain independent. Information between the different modalities within each component logic is made available through the propositional language that those modalities share. The resolution calculus for connected logics also introduces a set of inference rules to deal with the bridge modalities. Those rules are applied to clauses containing connecting modalities in one logic and literal clauses in the other logic. Therefore, when a set of connecting modalities in one logic cannot be satisfied in the model of the other logic, some restrictions are imposed via the propositional language in the first one.
The simplicity of the resolution method for connected logics is due to the fact that the dimensions for reasoning are kept separated. Implementation can be ob- tained in a quite straightforward way: the provers for the independent logics can be kept separated and the implementation of the bridge inference rules can be kept local, whenever a suitable communication channel between the provers is imple- mented. Therefore, the method presented here can be easily parallelised and/or distributed. Moreover, as the normal form is independent of the particular proof method we developed here, the transformed problems can be used to feed other theorem provers, after translation (if needed), providing a general approach for reasoning about connected logics.
We strongly believe that the method presented here can be extended to deal with more powerful varieties of connections between logics. For stronger connecting theories, we should be able to establish completeness whenever the bridge inference rules mimic (complete) resolution procedures for logics with corresponding (com- plete) frame properties introduced by the connecting modalities. This idea is not only applicable to the combination of standard, classical normal modal logics, but, importantly, also to other non-classical logics such as intuitionistic, relevant, or paraconsistent logic.
In this respect, future work will include studying generalisations of the resolution method introduced here, and a detailed comparison to the more algebraic-driven techniques of [1], which also provide general decidability preservation results.
Dedicated reasoning procedures for E -connections will be very relevant in par- ticular for the Distributed Ontology Language DOL [18], currently under standard- isation in the ontoiop.org working group. DOL is a metalanguage for combining specifications written in various ontology languages, and includes as linking con-

structs, besides alignments and theory interpretations, also the method of E -con- nection. As examples, recent application areas of DOL and E -connections include blending in computational creativity [15], architectural design [3], and the Semantic Web [7].
The work presented in this paper, therefore, is a first step towards establishing the connection method as a viable tool for modular knowledge representation with generic proof support. Given the generality of the method, this could significantly contribute to more usable methods to deal with combined logics in a large variety of applications.

References
Baader, F. and S. Ghilardi, Connecting Many-Sorted Theories, The Journal of Symbolic Logic 72
(2007), pp. 535–583.
Baader, F., C. Lutz, H. Sturm and F. Wolter, Fusions of description logics and abstract description systems, Journal of Artificial Intelligence Research (JAIR) 16 (2002), pp. 1–58.
Bhatt, M., J. Hois and O. Kutz, Ontological modelling of form and function in architectural design, Applied Ontology 7 (2012), pp. 233–267.
Borgida, A. and L. Serafini, Distributed Description Logics: Assimilating Information from Peer Sources, Journal of Data Semantics 1 (2003), pp. 153–184.
Carnielli, W., M. Coniglio, D. Gabbay, M. Gouveia and C. Sernadas, “Analysis and Synthesis of Logics
- How To Cut And Paste Reasoning Systems,” Springer, 2008.
Cuenca-Grau, B. and O. Kutz, Modular Ontology Languages Revisited, in: Proc. of the IJCAI’07 Workshop on Semantic Web for Collaborative Knowledge Acquisition (SWeCKa), Hyderabad, India, January 2007, 2007, pp. 22–31.
Cuenca-Grau, B., B. Parsia and E. Sirin, Combining OWL Ontologies Using E-Connections, Journal of Web Semantics 4 (2006), pp. 40–59.
Gabbay, D., A. Kurucz, F. Wolter and M. Zakharyaschev, “Many-Dimensional Modal Logics: Theory and Applications,” Number 148 in Studies in Logic, Elsevier, Amsterdam, 2003.
Goldblatt, R., “Logics of Time and Computation,” Number 7 in CSLI Lecture Notes, Stanford, CSLI, 1987.
Hustadt, U. and R. A. Schmidt, On evaluating decision procedures for modal logic, in: Proceedings of the Fifteenth International Joint Conference on Artificial Intelligence (IJCAI’97) (1997), pp. 202–207.
Kracht, M. and O. Kutz, Logically Possible Worlds and Counterpart Semantics for Modal Logic, in: D. Jacquette, editor, Philosophy of Logic, Handbook of the Philosophy of Science 5, Elsevier, Amsterdam, 2007 pp. 943–996.
Kracht, M. and F. Wolter, Properties of independently axiomatizable bimodal logics, The Journal of Symbolic Logic 56 (Dec. 1991), pp. 1469–1485.
Kutz, O., C. Lutz, F. Wolter and M. Zakharyaschev, E-connections of Description Logics, in: Proc. of DL, Rome, 2003, pp. 178–187.
Kutz, O., C. Lutz, F. Wolter and M. Zakharyaschev, E-connections of Abstract Description Systems, Artificial Intelligence 156 (2004), pp. 1–73.
Kutz, O., T. Mossakowski, J. Hois, M. Bhatt and J. Bateman, Ontological Blending in DOL, in:
T. Besold, K.-U. Kuehnberger, M. Schorlemmer and A. Smaill, editors, Computational Creativity, Concept Invention, and General Intelligence, Proc. of the 1st Int. Workshop C3GI@ECAI, Publications of the Institute of Cognitive Science, Osnabru¨ck 01-2012, Montpellier, France, 2012, pp. 33–40.
Kutz, O., T. Mossakowski and D. Lu¨cke, Carnap, Goguen, and the Hyperontologies: Logical Pluralism and Heterogeneous Structuring in Ontology Design, Logica Universalis 4 (2010), pp. 255–333, Special Issue on ‘Is Logic Universal?’.

Kutz, O., F. Wolter and M. Zakharyaschev, A note on concepts and distances, in: Proceedings of the International Workshop on Description Logics (DL-2001), Stanford, 2001, pp. 113–121.
Mossakowski, T., C. Lange and O. Kutz, Three Semantics for the Core of the Distributed Ontology Language, in: M. Donnelly and G. Guizzardi, editors, 7th International Conference on Formal Ontology in Information Systems (FOIS), Frontiers in Artificial Intelligence and Applications 239 (2012), pp. 337–352, FOIS Best Paper Award.
Nalon, C. and C. Dixon, Clausal resolution for normal modal logics, J. Algorithms 62 (2007), pp. 117– 134.
URL http://dl.acm.org/citation.cfm?id=1316091.1316347

Paramasivam, M. and D. A. Plaisted, Automated deduction techniques for classification in description logic systems, Journal of Automated Reasoning 3 (1998), pp. 337–364.
Plaisted, D. A. and S. A. Greenbaum, A Structure-Preserving Clause Form Translation, Journal of Logic and Computation 2 (1986), pp. 293–304.
Ryan, M. and P.-Y. Schobbens, Counterfactuals and Updates as Inverse Modalities, Journal of Logic, Language and Information 6 (1997), pp. 123–146.
URL http://dx.doi.org/10.1023/A%3A1008218502162

Serafini, L. and A. Tamilin, DRAGO: Distributed Reasoning Architecture for the Semantic Web, in: In Proceedings of the Second European Semantic Web Conference (ESWC’05) (2005), pp. 361–376.
