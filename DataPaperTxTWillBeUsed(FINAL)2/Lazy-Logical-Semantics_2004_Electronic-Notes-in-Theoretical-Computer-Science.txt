Electronic Notes in Theoretical Computer Science 104 (2004) 235–251 
www.elsevier.com/locate/entcs


Lazy Logical Semantics

Luca Paolini and Simona Ronchi Della Rocca1
Universit`a di Torino Dipartimento di Informatica paolini,ronchi@di.unito.it

Abstract
The lazy evaluation of the λ-calculus, both in call-by-name and in call-by-value setting, is studied. Starting from a logical descriptions of two topological models of such calculi, a pre-order relation on terms, stratified by types, is defined, which grasps exactly the two operational semantics we want to model. Such a relation can be used for building two fully abstract models.
Keywords: Lazy evaluation, λ-calculus, full abstraction.


Introduction
The lazy evaluation of the λ-calculus has been introduced by Plotkin in [13], in both the call-by-name and the call-by-value setting, for capturing the be- haviour of the functional languages, where a function is only evaluated when parameters are supplied. In the λ-calculus setting, this means that the eval- uation of a program (i.e., a closed term) stops when an abstraction term is reached.
The lazy call-by-name evaluation is modelled through the standard λβ- calculus, the call-by-value is modelled using the λβv-calculus, which has been introduced with this aim in [13]. In both cases the lazy evaluation is performed by choosing at every step the outermost redex (respectively the β-redex and the βv-redex) not under the scope of a λ-abstraction. The lazy operational se- mantics, induced by this evaluation strategy, can be defined, following Plotkin

1 paper partially supported by MURST-Cofin’01 COMETA Project, IST-2001-33477 DART Project, MIUR-Cofin’02 PROTOCOLLO Project


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.10.003


[13], as a pre-order relation between λ-terms, saying that M is operationally less than N if and only if, for all context C[.] such that C[M ], C[N ] are closed, C[M ] reduces to an abstraction implies C[N ] reduces to an abstraction.
The lazy denotational semantics of the λ-calculus has been first studied by Abramsky and Ong [2], in the call-by-name setting, and by Egidi, Honsell and Ronchi Della Rocca [8] in the call-by-value setting. Both models are built in the category of the topological spaces, and are based on the lifting operation on domains. Namely the model cbn, for the call-by-name case, is the initial solution of the domain equation

X = [X → X]⊥
where [. → .]⊥ is the lifted space of Scott’s continuous functions. In the call-by-value case, the model Mcbv is the initial solution of the domain

X = [X →⊥ X]⊥.
where [. →⊥ .]⊥ is the lifted space of Scott’s strict continuous functions.
Both models turned out to be correct but not complete with respect to the operational semantics they want to model.  Let us recall that a model is correct when the denotational semantics implies the operational one, it is complete if the inverse implication holds. Moreover a model is fully abstract with respect to an operational semantics if and only if it is both correct and complete with respect to it. It has been proved, respectively in [8] and [2], that there is not a topological model which is fully abstract with respect to the lazy operational semantics, both in the call-by-value and call-by-name case. Both proofs are inspired to the incompleteness result proved in [10]. In
[8] a fully abstract model has been built, through a collapse on  cbv, based on a notion of applicative bisimulation on terms. This technique cannot be applied to the model cbn, since it requires that the projections used in the construction of the model be λ-definable, and in this case this is not true. Further incompleteness results for the class of lazy call-by-name models based on stable functions have been proved in [4].
In this paper we consider a logical description of both the previous recalled models, based on an intersection type assignment system, and we define a pre- order relation between closed terms, stratified by types, that, when specialized by the type system describing one or the other of the two models, turns out to be equivalent to the operational semantics the model describes. So this pre-order relation is used for building, in a completely uniform way, two fully abstract models, for the call-by-name and the call-by-value case. First the pre- order on terms is extended to a pre-order on filters which are interpretations of


closed terms, and then the fully abstract models is obtained by collapsing all filters belonging to the same equivalence class, with respect to the equivalence induced by the given pre-order.
A further fully abstract model for the lazy call-by-name operational se- mantics, based on a variant of the game semantics, has been built in [7].
A general investigation on the properties of the models for the call-by-name lazy-λ-calculus, in different settings, can be found in [5].
The paper is organized as follows. In Section 2 we introduce the parametric λ-calculus, which will allow us to speak, in an uniform way, about the call-by- name and the call-by-value version of the λ-calculus. In Section 3 the two lazy operational semantics are introduced. In Sections 4 and 5 the basic notions of model and filter model are respectively recalled. Section 6 contains the two pre-orders on terms and the proof that they grasp exactly the operational semantics. In Section 6 we sketch how to use this pre-order for building a fully abstract model.

A Parametric Language
In order to deal with two different calculi in an uniform way, we will use the notion of parametric calculus, defined first in [12]. The λ∆-calculus is the language Λ equipped with a set ∆ ⊆ Λ of input values, satisfying some closure conditions. Informally, input values represent partially evaluated terms, that can be passed as parameters.
Definition 2.1 Let ∆ ⊆ Λ.
The set Λ of terms of λ-calculus is defined inductively by the following grammar: M ::= x λx.M  MM where x  V ar, and V ar is a countable set of variables.
The ∆-reduction (→∆) is the contextual closure of the following rule: (λx.M )N → M [N/x] if and only if N ∈ ∆.
(λx.M )N is called a ∆-redex (or simply redex).
→∗∆ and =∆ are respectively the reflexive and transitive closure of →∆ and the symmetric, reflexive and transitive closure of →∆.
A set ∆	Λ is a set of input values, when the following conditions are satisfied:
Var ⊆ ∆	(Var-closure);
P, Q ∈ ∆ implies P [Q/x] ∈ ∆, for each x ∈ Var	(substitution closure);
M ∈ ∆ and M →∆ N imply N ∈ ∆	(reduction closure).


A term is in ∆-normal form (∆-nf) if it has not ∆-redexes.
Theorem 2.2 [12] The λ∆-calculus enjoys the Church-Rosser property, for every choice of the set of input values ∆.
In this paper we will study two particular instances of input values, namely
∆ = Λ and ∆ = Γ, where Γ = V ar  λx.M  M  Λ . It is easy to check that both Λ and Γ are sets of input values. In particular the λΛ-calculus is the usual λβ-calculus and the λΓ-calculus is the λβv-calculus, defined by Plotkin [13].
For every Σ ⊆ Λ, Σ0 denotes the restriction of Σ to closed terms. M denotes a sequence of terms M1, ..., Mn, for n ≥ 0 (if n = 0 the sequence is empty).  M  denotes the lenght of the sequence M .

Operational Semantics
The two operational semantics defined below characterize the set of closed terms reducing to an abstraction, respectively in the call-by-name and call- by-value setting. Let W ⊆ Λ be the set of λ-abstractions.
Definition 3.1 i) ⇓L is the formal system proving judgments of the shape
M ⇓L N where M ∈ Λ  and N ∈ W . It consists of the following rules:



(lazy)
 P [Q/x]M1.. .Mm ⇓L N 

λx.M ⇓L λx.M
(head)
(λx.P )QM .. .M	⇓  N

M ⇓L denotes that there is a proof of the judgment M ⇓L N , for some
N , while M ⇑L denotes that there is not such a proof.
The lazy operational semantics L is defined as the following preorder:
M ≤L N if and only if, for all context C[.] such that C[M ], C[N ] ∈ Λ0,
C[M ] ⇓L implies C[N ] ⇓L. The strict preorder will be denoted by ≺L.
M ≈L N if and only if M ≤L N and N ≤L M .
The formal system described before corresponds to the lazy call-by-name evaluation machine introduced by Plotkin [13].
Theorem 3.2 Let M ∈ Λ0.
M ⇓L N implies N is an abstraction and M →∗Λ N;
M ⇓L if and only if M Λ-reduces to an abstraction.
In the next definition the lazy call-by-value operational semantics is given.


Definition 3.3 i) ⇓V is the formal system proving judgments of the shape
M ⇓V N where M ∈ Λ0 and N ∈ W 0. It consists of the following rules:



(lazy)
Q ⇓V Q'	P [Q'/x]M1.. .Mm ⇓V N

λx.M ⇓V λx.M
(λx.P )QM .. .M	⇓	N
(head)

M ⇓V denotes that there is a proof of the judgment M ⇓V N , for some
N , while M ⇑V denotes that there is not such a proof.
M ≤V N if and only if, for all context C[.] such that C[M ], C[N ] ∈ Λ0,
C[M ] ⇓V implies C[N ] ⇓V.
M ≈V N if and only if M ≤V N and N ≤V M .
The formal system described before corresponds to the lazy call-by-value evaluation machine introduced by Plotkin [13].
Theorem 3.4 Let M ∈ Λ0.
M ⇓V N implies N is an abstraction and M →∗Γ N;
M ⇓V if and only if M Γ-reduces to an abstraction.

λ∆-models
In this section the definition of λ∆-model and the notion of correctness and completeness are recalled.
Definition 4.1 A λ∆-model is a quadruple < D, I, , [[.]] >, where:
D is a set,  is a map from D2 in D and I  D. Moreover, if E is the collection of functions (environments) from Var to I, ranged over by ρ, ρ', .., then the interpretation function [[.]] : Λ × E → D satisfies the following conditions:
[x]]ρ = ρ(x);
[MN ]]ρ = [[M ]]ρ ◦ [[N ]]ρ;
[λx.M ]]ρ ◦ d = [[M ]]ρ[d/x] if d ∈ I;
if [M ]]ρ[d/x] = [[M ']]ρ'[d/y] for each d ∈ I, then [[λx.M ]]ρ = [[λy.M ']]ρ' ;
M ∈ ∆ implies ∀ρ.[[M ]]ρ ∈ I.
where ρ[d/x](y) = if y ≡ x then d else ρ(y).
I is the semantic counterpart of the set of input values; posing I = D, the previous definition is equivalent to the classical definition of λ-model given in [9]. A λ∆-model induces an equivalence relation between terms defined as:
M ∼M N if and only if [M ]]ρM = [[N ]]ρM, for all environments ρ.


Let ≈O be an equivalence relation between terms induced by an operational semantics O. The denotational equivalence ∼M is correct with respect to the operational equivalence ≈O if M ∼M N implies M ≈O N , for all M and N , while it is complete if M ≈O N implies M ∼M N , for all M and N . M is fully abstract if it is both correct and complete.

Filter Models
In this section we will introduce the notion of ﬁlter models, a class of λ∆- models based on intersection types and intersection type assignment systems. The use of intersection type assignment systems for a logical description of domains has been extensively studied in [6], [3], [1].
Definition 5.1 i) Let C be a non empty countable set of type-constants, containing at least the constant ω (the universal type). The set T (C) of types is inductively defined as follows: σ ::= α | (σ → σ) | (σ ∧ σ) where α ∈ C.
An intersection relation	is a preorder relation on T (C), closed under the following rules:



σ ≤ ω

(a)


σ ≤ σ ∧ σ

(b)


σ ∧ τ ≤ σ

(c)


σ ∧ τ ≤ τ

(c')



(σ → τ ) ∧ (σ → π) ≤ σ → (τ ∧ π)


(d)
σ	σ', τ	τ '
(e)
σ ∧ τ ≤ σ' ∧ τ '

σ' ≤ σ, τ ≤ τ '


σ → τ ≤ σ' → τ '


(f )


σ → ω ≤ ω → ω

(g)


σ ≤ σ

(r)
σ ≤ ρ, ρ ≤ τ σ ≤ ρ

(t)

Let ≤ be a intersection relation on T (C).
≤ induce a type theory  : σ  τ if and only if σ ≤ τ and τ ≤ σ.
A type system ∇ is a triple < C, ≤∇,I(C) >, where C is a set of type constants, ≤∇ is an intersection relation on T (C) and I(C) ⊆ T (C) is a set of input types with respect to ≤∇, namely it is not empty and it is closed under the following conditions:
σ ∈ I(C) and σ  ∇ τ imply τ ∈ I(C);
σ ∈ I(C) and τ /∈ I(C) imply σ ≤∇ τ .
Given a type system  , the corresponding type assignment system  ∇ is a formal system proving statements of the shape:
B ▶∇ M : σ
where M is a term, σ  T (C) and B is a basis i.e., a function from Var to
I(C). B[σ/x] denotes the basis such that:
B[σ/x](y) = if y ≡ x then σ else B(y).


The type assignment system consists of the following rules:



B[σ/x] ▶∇ x : σ

 B[σ/x] ▶∇ M : τ 

(var)
B ▶∇ M : ω σ ∈ I(C) B ▶∇ M : σ → τ B ▶∇ N : σ

(ω)

B ▶∇
λx.M : σ → τ (→I)
B ▶∇
MN : τ
(→E)

B ▶∇ M : σ	B ▶∇ M : τ	B ▶∇ M : σ	σ ≤∇ τ

B ▶∇
M : σ ∧ τ
(∧I)
B ▶∇
M : τ
(≤∇)

B ▶∇ M : σ ∧ τ	B ▶∇ M : σ ∧ τ

B ▶∇
M : σ
(∧El)
B ▶∇
M : τ
(∧Er )

Note that rules (∧El) and (∧Er) are redundant, since the rule (≤∇).
I(C) is the collection of types that can be assigned to input values. This is reflected by the facts that I(C) (and not the whole T (C)) is the codomain of the basis, and the rule (  E) requires the argument of the application has a type belonging to I(C).
Let ∇ be the type system < C, ≤∇,I(C) >. If π ∈ I(C) and σ ≤∇ π then σ ∈ I(C). If σ ∈ I(C) then σ ∧ τ ∈ I(C), for all τ ∈ T (C). If π /∈ I(C) and π ≤∇ σthen σ /∈ I(C).
In order to decrease the number of parenthesis in types, we will use the following precedence rules between connectives: ∧ binds stronger than →, moreover → associates to the right. We will use σ ∧ τ ∧ ρ for denoting both σ ∧ (τ ∧ ρ) and σ ∧ (τ ∧ ρ).
The notion of legal type theory, given in the next definition, is a key one,
since we will prove that to be legal is a necessary condition for a type theory to induce a λ∆-model.
Definition 5.2 Let ∇ be the type system < C, ≤∇,I(C) >.
∇ is legal if and only if for all σ ∈ I(C) and τ / ∇ ω:
(σ1 → τ1) ∧ ... ∧ (σn → τn) ≤∇ σ → τ (1 ≤ n) implies
∃{i1, ..., ik} ⊆ {1, ..., n} s.t. (σi1 ∧ ... ∧ σik ) ≥∇ σ and (τi1 ∧ ... ∧ τik ) ≤∇ τ .
Let ∇ be a type system < C, ≤∇,I(C) > such that I(C) = T (C) and ≤∇
is the least inclusion relation: ∇ is legal.
Now we are ready to introduce the basic ingredients for defining a filter model.
Definition 5.3 Let ∇ be the type system < C, ≤∇,I(C) >.
A filter f on ∇ is any set containing ω and closed under ∧ and ≤∇, namely:
· µ, ν ∈ f implies µ ∧ ν ∈ f ;


· µ ∈ f and µ ≤∇ τ imply τ ∈ f .
Let F(∇) be the set of all filters on ∇ and let I(∇) be the set of filters containing at least one type belonging to I(C).
Let S be a set of types; ↑ S is the filter obtained from S by closing it under
∧ and ≤∇, i.e the least filter containing S.
Let ◦∇ be the binary operation defined on F(∇) in the following way:
f1 ◦∇ f2 =↑ {ω}∪ {τ | σ → τ ∈ f1 and σ ∈ f2 and σ ∈ I(C)}.
Note that f ∈ I(∇) and σ /∈ I(C) imply σ ∈ f , by the conditions on the set of input types. The interpretation function associates to every term all the types that can be assigned to it.
Let ∇ =< C, ≤∇,I(C) >.  [.]]F(∇) : Λ × (Var → I(∇)) → F(∇) is the
interpretation function, defined as follows:
[[M ]]Fρ (∇) = {σ ∈ T (C) | ∃B ∝ ρ such that B ▶∇ M : σ}
where B ∝ ρ means that ∀z ∈ Var B(z) ∈ ρ(z).
Theorem 5.4 Let ∇ =< C, ≤∇,I(C) > be a legal type system, and let M ∈
∆ imply [[M ]]ρ ∈ I(∇), for all environment ρ.
Then < F(∇), I(∇), ◦∇, [[.]]F(∇) > is a λ∆-model.
Proof. It is easy to see that [M ]]Fρ (∇) is a filter, for all term M . The proof can be carried out by verifying the conditions of Definition 4.1.	 
The partial order between terms induced by a filter λ∆-model  is defined as follows:
M ±F N	if and only if	∀ρ, [[M ]]ρF ⊆ [[N ]]ρF
i.e., {σ|∃B ∝ ρ such that B ▶∇ M : σ} ⊆ {σ|∃B ∝ ρ such that B ▶∇ N : σ}. M иF N will denote the proper inclusion.
We can refine both the notion of correctness and completeness of a model with respect to a given operational semantics, by taking into account the preorder relation instead of the equivalence one.
Definition 5.5 Let F be a filter model.
F is correct with respect to the O-operational semantics if and only if M ±F N implies M ≤O N , for all M, N ∈ Λ. F is complete with respect to the O-operational semantics if and only if the inverse implication holds.
Moreover  is fully abstract with respect to O, in case it is both correct and complete with respect to O.

Two Lazy Models
We present two filter models, which are correct but not complete with respect to the L-operational semantics and the V-operational semantics, respectively.
Definition 6.1 Let C∠ = {ω}. ∠ is the type system < C∠, ≤∠,I(C∠) >, where ≤∠ is the least intersection relation of Definition 5.1.ii) and I(C∠) = T (C∠). Let L be the filter model < F(∠), F(∠), ◦∠, [[.]]F(∠) >.
is isomorphic to the topological λ-model obtained as initial solution of the domain equation:
X = [X → X]⊥
where [. → .]⊥ is the lifted space of Scott’s continuous functions (see [2]).
Theorem 6.2 i) [2] L is correct with respect to the L-operational semantics.
ii) [2] L is not complete with respect to the L- operational semantics.
Now let us define the next model.
Definition 6.3 √ is the type system < C√, ≤√,I(C√) > where C√ = {ω},
I(C√) = {σ0 ∧ ... ∧ σn | ∃k ≤ n ∃σ, τ ∈ T (C√) σk ≡ σ → τ }
and	√ is the intersection relation induced by adding to the Definition 5.1.ii) the rule



(ω → ω) → τ ≤√ ω → τ
V is the λΓ-model < F(√), I(√), ◦√, [[.]]F(√) >.
(v)

It is easy to check that σ ∈ I(C√) if and only if σ / √ ω.
The filter Γ-model V can be proved isomorphic to that one defined in [8], where types are built starting from a constant ν which plays the role of the type ω  ω. So it follows that  is isomorphic to the topological λ-model obtained as initial solution of the domain equation:
X = [X →⊥ X]⊥.
where [. →⊥ .]⊥ is the lifted space of Scott’s strict continuous functions.
Theorem 6.4 i) [8] V is correct with respect to the V-operational semantics.
ii) [8] V is not complete with respect to the V- operational semantics.
Both models characterize convergent terms by the type ω → ω.
Property 6.5 Let M ∈ Λ0.

B ▶∠ M : ω → ω if and only if M ⇓L.
B ▶√ M : ω → ω if and only if M ⇓V.
Some structural properties of types will be useful.
Property 6.6 Let ∇ ∈ {∠, √}.
If σ / ∇ ω then σ  ∇ σ0 ∧ ... ∧ σn such that ∀i ≤ n,
σi  ∇ τ i → ... → τ i  → ω → ω, for some n, mi ∈ N.

1
σ  ∇ ω if and only if σ ≡ ω` ∧ .˛..¸.. ∧ ωx
n
mi
(n ≥ 1).

(ω → ω) → τ  √ ω → τ, for all τ ∈ T (C√).

Applicative Operational Preorders
Two preorder relations on closed λ-terms will be defined, stratified by types respectively of T (C∠) and T (C√). These relations will turn out to correspond respectively to the two operational preorders ≤L and ≤V.
Let ∆ be a set of input values: a term M is ∆-valuable if and only if it ∆- reduces to a term in ∆. Clearly the notion of Λ-valuable term is meaningless. Definition 7.1 Let either (∆ = Λ and ∇ = ∠) or (∆ = Γ and ∇ = √).
Ð∆ is a relation on Λ0 defined as follows:
M Ðω N is true;
M Ðσ→τ N where τ  ∇ ω, if and only if
B ▶∇ M : ω → ω implies B ▶∇ N : ω → ω, for all basis B;
M Ðσ→τ N where τ / ∇ ω, if and only if
P closed and ∆-valuable, and B ▶∇ P : σ imply MP Ð∆ NP ;
∆	∆	∆
M Ðσ∧τ N if and only if both M Ðσ N and M Ðτ  N ;
M Ð∆ N if and only if M Ð∆ N , for all σ.
The next property will be useful in order to better understand the previous definition.
Property 7.2 For every type σ and basis B,
there is a closed term P such that B ▶∠ P : σ;
there is a closed term P such that B ▶√ P : σ.
Proof. It is easy to prove that for each σ there is n such that both B ▶∠: λx1...xn.DD : σ and B  √: λx1...xn.DD : σ, where D  λx.xx. Both proofs can be done by induction on σ	 



Note that, although λx.DD /ÐΛ	DD, λx.DD ÐΛ
DD; in fact for

0	ω→ω	Λ ω→ω→ω
each P ∈ Λ , B ▶∠ P : ω, and so (λx.DD)P Ðω→ω (DD)P is true, by
definition of ÐΛ. Hence M ÐΛ N and σ ≤∠ τ does not imply M ÐΛ N .
σ	τ
Property 7.3 Let M, N ∈ Λ0.
Ð∆ is reflexive.
Ð∆ is transitive.
Proof. Both points can be proved by an easy induction on σ.	 
Property 7.4 Let M, N ∈ Λ0.
M ±L N implies M ÐΛ N;
M ±V N implies M ÐΓ N.
Proof.
We will prove that M /ÐΛ N implies M /±L N . By definition M /ÐΛ N means that there is σ such that M /ÐΛ N . The proof is given by induction on σ. Clearly σ / ∠ ω, since by definition M ÐΛ N is true. If σ ≡ µ → ν where ν  ∠ ω, then B ▶∠ M : ω → ω and B /▶∠ N : ω → ω by definition of ÐΛ, so the proof is immediate. If σ ≡ µ → ν where ν / ∠ ω, then there is P ∈ Λ0 such that MP /ÐΛ NP , by definition of ÐΛ. Hence, MP /±L NP by induction, so M /±L N . If σ ≡ µ Λ ν then the proof follows by induction.
Similar to the previous point.
 
Now we will prove that, for closed terms, the preorders	L and	V coincide respectively with ÐΛ and ÐΓ.
Lemma 7.5 Let M, N ∈ Λ0 and, let either (∆ = Λ and ∇ = ∠) or (∆ = Γ 
and ∇ = √). M Ð∆ N if and only if MP Ð∆	NP , for each sequence P
of closed ∆-valuable terms.
Proof. ⇐ We will prove that M /Ð∆ N implies that there is a sequence of
closed ∆-valuable terms P such that MP /Ð∆	NP . By hypothesis there is
∆	ω→ω

a type σ such that M /Ðσ N , so the proof is done by induction on σ.
If σ  ∇ ω then σ  ∇ ω` Λ .˛..¸.. Λ ωx (n ≥ 1); but, since M Ð∆

N by

n
definition, this is not possible. Thus let σ / ∇ ω. If σ ≡ µ → ν where ν  ∇ ω,
then the proof is vacuous. If σ ≡ µ → ν where ν / ∇ ω, then there is P ∈ ∆0 such that MP   NP , so the proof follows by induction. If σ  µ  ν then the proof follows by induction.
⇒ We will prove that, if there is a sequence of closed ∆-valuable P and
a type τ / ∇ ω such that MP /Ð∆ NP then M /Ð∆ N , by induction on


the length of P . If P  = 0 then the proof is trivial, so let P  ≥ 1 and
P ≡ QQ'.
B ▶∠ Q' : ω by rule (ω) implies MQ /ÐΛ	NQ by definition of ÐΛ; so the

proof follows by induction.
B	√ Q' : ω	ω, since Q' is Γ- valuable, implies MQ ÐΓ
(ω→ω)→τ

NQ by

definition of ÐΓ; so the proof follows by induction.

Lemma 7.6 Let M, N ∈ Λ0.

M	N if and only if MP ÐΛ
ω→ω
NP , for each sequence of closed terms P.

Proof. Remember that, for every term Q, Q L if and only if B	∠ Q : ω ω, by Property 6.5.i.
⇒ Let P be a sequence of closed terms and let B be a basis. If M ≤L N then MP ⇓L implies NP ⇓L; thus, B ▶∠ MP : ω → ω implies B ▶∠ NP : ω → ω, by Property 6.5.i. Hence, by definition of Ðω→ω the proof is done.
⇐ Let MP Ðω→ω NP , for each sequence of closed terms P . We will prove that, if C[M ], C[N ] ∈ Λ0 and C[M ] ⇓L, then C[N ] ⇓L, for all context C[.]. The proof is done by induction on the size of the derivation proving C[M ] ⇓L. If the last applied rule is (lazy) then either C[.]	[.] or C[.]	λx.C0[.], so the proof is immediate. If the last applied rule is (head) then there are two
cases, according to the possible shape of C[.].
C[.] ≡ [.]C1[.]...Cm[.] (m ∈ N).
If m = 0 then M ⇓L implies B ▶∠ M : ω → ω, so B ▶∠ N : ω → ω by definition of Ðω→ω and the proof follows by Property 6.5.i.
Now let m ≥ 1. Define D[.] ≡ MC1[.]...Cm[.], so D[M ] ≡ C[M ]. If M ≡
(λz.M0)M then D[.] ≡ (λz.M0)MC1[.]...Cm[.] (m ∈ N).
If M = 0 then let D∗[.] ≡ M0[C1[.]/z]C2[.]...Cm[.], otherwise let D∗[.] ≡ M0[M1/z]RC1[.]...Cm[.] where M ≡ M1R. In all cases D∗[M ] ⇓L and by in- duction D∗[N ] ⇓L, so D[N ] ⇓L by rule (head). But MC1[N ]...Cm[N ] ⇓L im- plies B ▶∠ MC1[N ]...Cm[N ] : ω → ω, so by hypothesis B ▶∠ NC1[N ]...Cm[N ] : ω → ω. Hence, NC1[N ]...Cm[N ] ⇓L by Property 6.5.i.
C[.]	(λy.C0[.])C1[.]...Cm[.] (m	N).
The case m = 0 is not possible, otherwise the proof follows by induction on the derivation proving C0[M ][C1[M ]/y]C2[M ]...Cm[M ] ⇓L.

Theorem 7.7 For all M, N ∈ Λ0, M ÐΛ N if and only if M ≤L N.
Proof. By Lemmas 7.5 and 7.6.	 


The proof of the   implication of the property corresponding to 7.6, for the λΓ-calculus cannot be done by induction on the size of the derivation. We need to define a more refined induction measure, that has been introduced in [11], for reasoning about the V-operational semantics.
Definition 7.8
The weight ⟨ ⟩ : Λ0 −→ N is the partial function, defined as follows:
⟨λx.M '⟩ = 0 
⟨(λx.M0)M1.. .Mm⟩ = 1 + ⟨M1⟩ + ⟨M0[M1/x]M2.. .Mm⟩
Property 7.9 Let M ∈ Λ0.
⟨M ⟩ is deﬁned if and only if M ⇓V;
Let M →∗Γ N . If ⟨M ⟩ is deﬁned then ⟨N ⟩ is deﬁned and ⟨M ⟩ ≥ ⟨N ⟩.
Informally, the weight of a Γ-valuable term M is an upper bound of the lenghts of two reduction sequences, starting from M and reaching an abstrac- tion, one performing at every step the outermost Γ-redex, the other performing at every step the innermost Λ-redex not under the scope of an abstraction.
The following property holds.
Lemma 7.10 Let M, N	Λ0. M	V N if and only if MP Ðω→ω NP , for each sequence of closed Γ-valuable terms P.
Proof. Let Q be a closed Γ-valuable term. Then Q ⇓V if and only if B ▶√
Q : ω → ω, by Property 6.5.ii.
⇒ Let P be a sequence of closed Γ-valuable terms. If M ≤V N then, MP ⇓V implies NP ⇓V; thus, B ▶√ MP : ω → ω implies B ▶√ NP : ω → ω, by Property 6.5.ii. So the proof is done, by definition of Ðω→ω.
⇐ Let MP Ðω→ω NP , for each sequence of closed Γ-valuable terms P . We will prove that, if ⟨C[M ]⟩ defined implies ⟨C[N ]⟩ defined, for all context C[.] such that C[M ], C[N ]  Λ . Then the result follows from Property 7.9.i. The proof will be given by induction on C[M ] . There are two cases, according to the possible shape of C[.].
C[.] ≡ [.]C1[.]...Cm[.] (m ∈ N).
If m = 0 then ⟨M ⟩ defined and M ⇓V, so B ▶√ M : ω → ω.	But
B ▶√ N : ω → ω by definition of Ðω→ω and the proof follows by Property
7.9.i. Let m ≥ 1 and let M ≡ (λx.M0)M1...Mp. Pose D[.] ≡ MC1[.]...Cm[.], so D[M ] ≡ C[M ].
· If p > 0 then D∗[.] ≡ M0[M1/x]M2...MpC1[.]...Cm[.], so ⟨D∗[M ]⟩ and ⟨M1⟩
are defined, since ⟨C[M ]⟩ is defined.
· Otherwise D∗[.] ≡ M0[C1[.]/x]C2[.]...Cm[.], so ⟨D∗[M ]⟩ and ⟨C1[M ]⟩ are


defined, since ⟨C[M ]⟩ is defined.
In both cases, ⟨D[N ]⟩ is defined by induction. Hence D[N ] ⇓V, thus B ▶√ MC1[N ]....Cm[N ] : ω → ω, therefore by hypothesis B ▶√ NC1[N ]...Cm[N ] : ω → ω. So NC1[N ]...Cm[N ] ⇓V by Property 6.5.ii and the proof follows.
C[.] ≡ (λy.C0[.])C1[.]...Cm[.] (m ∈ N).
The case m = 0 is trivial, otherwise the proof follows by induction on the weight of C0[M ][C1[M ]/y]C2[M ]...Cm[M ] and C1[M ].

Theorem 7.11 For all M, N ∈ Λ0, M ÐΓ N if and only if M ≤V N.
Proof. By Lemmas 7.5 and 7.10.	 

Two fully abstract models
By using the results of the previous section, we can build two fully abstract models, with respect to the L and V operational semantics respectively . Since the construction is completely uniform in the two cases, we will sketch just the case of V.
ÐΓ induces a preorder on F 0(√), the set of filters of F(√) which are
interpretations of closed terms.
Definition 8.1 Let f, g   0(√) and let ρ be an environment.
f ÐΓ g if and only if M, N  Λ0 such that [M ]]Fρ (√) = f and [N ]]Fρ (√) = g
imply M ÐΓ N . Moreover, f  g if and only if f ÐΓ g and g ÐΓ f .
Note that if M is closed then [M ]]ρV = [[M ]]ρV' , for all ρ, ρ'; moreover, if M, N
are closed then [M ]]ρV = [[N ]]ρV' implies M ÐΓ N and N ÐΓ M , by Property
7.4.ii. Remark that ÐΓ is overloaded, since it denotes both a relation on Λ0 and a relation on F 0(√).
Now we can define the new λΓ-model.
Definition 8.2 Let f, g ∈ F 0(√).
[f ] is the equivalence class of f with respect to the equivalence relation

 , while F 0
is the set of of equivalence classes induced from  on	0(√).
√

Moreover, let I0 = {[f ] ∈ F0 | ∃M ∈ Γ0 s.t. [M ]]Fρ ( ) = f }.
◦  : F 0 × F0 → F0 is defined as [f ] ◦  [g] = [f ◦√ g], for all [f ], [g] ∈ F 0 .
The interpretation function [.]]VV : Λ × (Var → I0 ) → F0 is defined as:
√
[[M ]]VV = [ [M ]]ρF( )], where ρ is such that ρ(x) ∈ ζ(x) for all x ∈ Var.
Let VV be the quadruple: < F 0 , I0 , ◦, [[.]]VV >.


Note that the interpretation is defined for open terms too.
Property 8.3 Let M, N, P, Q	Λ0.
If M ÐΓ N and P ÐΓ Q then MP ÐΓ N Q.
Proof. By Theorem 7.11.	 
is well defined, by using the previous property. Furthermore, it is easy
to see that [f ] ∈ I0 and f ' ∈ [f ] imply that f ' ∈ I(√).
Lemma 8.4 VV is a λΓ-model.
Proof. We check that VV satisfies the conditions of definition 4.1.
If ζ ∈ (Var → I0 ) then let ρ be such that ρ(x) ∈ ζ(x) for all x ∈ Var.
[x]]VV = [ [x]]ρF(√)] = [ρ(x)] = ζ(x).

[MN ]]VV = [ [MN ]]ρF(√)] = [ [M ]]Fρ (√)◦√[[N ]]ρF(√)] = [ [M ]]ρF(√)]◦
[[M ]]ζVV ◦ [[N ]]ζVV .
[[[N ]]ρF(√)] = 

(√)
[λx.M ]]ζVV ◦ [d] = [ [λx.M ]]ρF	]◦
[d] = [ [λx.M ]]Fρ (√) ◦√ d] = [ [M ]]F(√) ] = 

[[M ]]ζV[V[d]/x], for all d ∈ I0(√).

Let [M ]]ζV[V[d]/x]
√
= [N ]]ζV'V[[d']/x']
, where d, d' ∈ I0(√); thus [[[M ]]F(√) ] =

[[[N ]]F( )
], hence [ [λx.M ]]
] = [ [λx'.N ]] ' ] so [λx.M ]]VV = [[λx'.N ]]VV .

ρ[d' /x']
Trivial.
ρ	ρ	ζ	ζ'

Since ÐΓ is a preorder on F 0(√) then it induces a partial order on F 0 .
Definition 8.5
Let M ±VV N denote [M ]]ζVV ÐΓ [[N ]]ζVV , for all ζ ∈ (Var → I0 ).
Moreover, let M ∼VV N denote M ±VV N and N ±VV M .
Consequently the model VV induces a partial order on the interpretation of terms (not only closed terms).
Lemma 8.6 Let M, N ∈ Λ0. M ±VV N if and only if M ÐΓ N.
Proof. Let ζ ∈ (Var → I0 ) and let ρ be such that ρ(x) ∈ ζ(x) for all x ∈ Var.
√	√
M ±VV N if and only if [M ]]VV ÐΓ [[N ]]VV if and only if [[[M ]]Fρ ( )] ÐΓ [[[N ]]Fρ ( )]
√	ζ	√	ζ
if and only if [M ]]ρF( ) ÐΓ [[N ]]ρF( ) if and only if M ÐΓ N .	 
The correctness is easy.
Theorem 8.7 VV is correct with respect to the V-operational semantics.


Proof. We will prove that M ±VV N implies M ≤V N , by definition of correctness.  M ±VV N implies C[M ] ±VV C[N ], for each closing context
C[.].  Thus C[M ] ÐΓ C[N ], by Lemma 8.6; hence C[M ] ÐΓ	C[N ], thus

B ▶√
C[M ] : ω → ω implies B ▶√
ω→ω
C[N ] : ω → ω, for all basis B.  So,

Property 6.5.ii, C[M ] ↓V implies C[N ] ↓V, and so M ≤V N .	 
The following theorem implies the full abstraction of	with respect to the V-operational semantics.
Theorem 8.8 VV is complete with respect to the V-operational semantics.
Proof. We will prove /±VV implies /≤V.
M /±VV N means [M ]]ζVV /ÐΓ [[N ]]ζVV , for some ζ ∈ (Var → f0 ). Since the
codomain of ζ is f0 , if FV(M ) ∪ FV(N ) = {x1, ..., xm} then there are Pi ∈ Γ0
√
such that ζ(xi) = [ [Pi]]ρF( )]. Thus, let s be such that s(xi) = Pi (1 ≤ i ≤ m),
hence s(M ), s(N ) ∈ Λ0. Thus [s(M )]]ζV'V /ÐΓ [[s(N )]]ζV'V , for all ζ' ∈ (Var → f0 ),
so in particular s(M ) /±VV s(N ).
By Lemma 8.6, s(M ) /ÐΓ s(N ), thus there is a sequence of closed Γ-valuable
terms Q such that s(M )Q /ÐΓ	s(N )Q, by Theorem 7.5.
Let C[.] ≡ (λx1...xm.[.])s(x1)...s(xm)Q; clearly C[M ], C[N ] ∈ Λ0 and moreover C[M ] ↓V and C[N ] ⇑V, so M /≤V N .	 
So we can state the following theorem.
Theorem 8.9 The model	is fully abstract with respect to the call-by-value operational semantics.
The construction of the fully abstract model for the L-operational seman- tics is similar but simpler.

References
Abramsky S., “Domain Theory in Logical Form”, APAL, 51, 1991, pp. 1-77.
Abramsky S., Ong L.C., “Full abstraction in the Lazy Lambda Calculus”, I&C, 105, 1993, pp. 159-267.
Alessi F.,“Strutture di Tipi, Teorie dei Domini e Modelli del Lambda Calcolo”, Tesi di dottorato di Ricerca in Informatica, Milano-Torino, 1990.
Bastonero O., Gouy X., “Strong Stability and the Incompleteness of Stable Models for lambda- Calculus”, APAL, 100(1-3), 1999, pp. 247-277.
Bastonero O., Pravato A., Ronchi Della Rocca S., “Structures for Lazy Semantics”, Programming Concepts and Methods, Gries and de Roever ed.s, Chaptman & Hall, 1998, pp.30- 48.
Coppo M., Dezani-Ciancaglini M., Honsell F., Longo G., “Extended Type Structures and Filter Lambda Models”, Logic Colloquium ’82, Lolli, Longo, Marcja ed.s, North Holland, 1983, pp. 241-262.


Digianantonio Pietro, “Game semantics for the pure lazy lambda-calculus, LNCS, 2044, pp 106-120.
Egidi L., Honsell F., Ronchi Della Rocca S., “Operational, Denotational and Logical Description: a case study”, Fundamenta Informaticae, 16, 2, (1992), pp. 149-170.
Hindley R., Longo G., “Lambda Calculus Models and Extensionality”, Z. Math. Logik Grundlag. Math., 26, 1980, pp. 289-310.
Honsell F., Ronchi Della Rocca S., “An Approximation Theorem for Topological Lambda Models and the Topological Incompleteness of Lambda Calculus”, Journal of Computer and Systems Science, 45, 1992, pp.49-75.
Paolini L., Ronchi Della Rocca S., “Call By Value Solvability”, Theoretical Informatics and Applications, 33, 1999, pp.507-534.
Paolini L., Ronchi Della Rocca S., “The Parametric Parameter Passing λ-calculus”, I&C, to appear.
G.Plotkin., ”Call by value, call by name and the λ-calculus” Theoretical Computer Science, 1975, pp. 125-159.
