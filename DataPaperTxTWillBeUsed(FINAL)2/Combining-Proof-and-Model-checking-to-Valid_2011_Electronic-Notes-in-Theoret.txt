Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 279 (2) (2011) 43–57
www.elsevier.com/locate/entcs

Combining Proof and Model-checking to Validate Reconfigurable Architectures
Arnaud Lanoix1
LINA, Nantes University, Nantes, France
Julien Dormoy2 Olga Kouchnarenko2
LIFC, University of Franche-Comt´e, Besan¸con, France

Abstract
This paper deals with the formal specification and verification of dynamic reconfigurations of component- based systems. To validate such complex systems, there is a need to check model consistency and also to ensure that dynamic reconfigurations satisfy architectural and integrity constraints, invariants, and also temporal constraints over (re)configuration sequences. As architectural constraints involve first-order for- mulae, and a behavioural semantics of reconfigurations gives rise to infinite state systems, we propose to associate proof and model-checking within the well-established B method, to support the modelling of such systems and the (partial-)validation of their dynamic reconfigurations. The objective of the paper is twofold. First, given a hierarchical B model of component-based architectures, we validate it by proving its consistency. Second, given linear temporal logic formulae expressing the desirable dynamic behaviour of the system, we validate reconfigurable system architectures by using bounded model-checking tools supporting the B method. The main contributions are illustrated on the example of a HTTP server architecture.
Keywords: Component, Architecture, Reconfiguration, Proof, Model-checking, B method


Introduction
This article is dedicated to an automatic checking of dynamic reconfigurations of component-based systems whose development provides significant advantages like portability, adaptability, re-usability, etc. Dynamic reconfiguration of distributed applications is an active research topic [2,3,17] motivated by practical distributed applications like, e.g., those modelled in Fractal [9]. In many recent works, the idea of using temporal logics to specify dynamic reconfigurations and to manage applications at runtime has been explored [7,15,12].

1 Email: arnaud.lanoix@univ-nantes.fr
2 Email: {jdormoy,okouchnarenko}@lifc.univ-fcomte.fr

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.11.011

In [12], a formal semantics of component-based systems architectures with re- configurations together with a linear time temporal logic over (re)configuration se- quences have been proposed. This logic, called FTPL, is based on architectural con- straints and on event properties. To validate such complex systems, there is a need to check model consistency and also to ensure that dynamic reconfigurations satisfy architectural and integrity constraints, invariants, and also FTPL constraints. As these constraints involve first-order formulae, and a behavioural semantics of re- configurations gives rise to infinite state systems, we propose to combine proof and model-checking techniques within the well-established B method [1].

Fig. 1. Principle and contributions
Let us explain our current B-based validation approach and contributions on Fig. 1. First of all, we propose to model components and basic dynamic reconfigura- tions using the B formal framework. It allows us to define and to validate a generic B model for component architectures. We use the AtelierB tool to interactively prove the architectural constraints consistency (1). Then this generic architecture is instantiated to represent an architecture under consideration (2); The dynamic architectural reconfigurations are specified by using the previously defined primi- tive B operations (3). Note that we do not take into consideration specification of the controller which would use these dynamic reconfigurations (through adaptation policies as instance). Consequently, the validation of the instantiated architectural model cannot be done using interactive proof. Nevertheless, we perform a partial validation of these dynamic reconfigurations through animations of samples of the running model, thanks to the ProB model-checker features (4). In addition, tempo- ral properties over configuration sequences expressed in FTPL are translated into LTL (5). These properties can be checked with the ProB model-checker (6).
The remainder of the paper is organised as follows. After giving a motivating example in Sect. 2, the B method and its tools supports are introduced in Sect. 3. We formally define a generic B model of component architectures in Sect. 4. This model is then instantiated to validate a particular architecture in Sect. 5. To automatically verify temporal properties, Section 6 introduces FTPL and gives its translation into LTL. Finally, Section 7 concludes before discussing related work.
Motivating Example
To motivate and to illustrate our approach, let us consider an example of an HTTP server from [10]. The architecture of this server is displayed in Fig. 2.

The RequestReceiver component reads HTTP requests from the network and transmits them to the RequestHandler component. In order to keep the response time as short as possible, RequestHandler can either use a cache (with the com- ponent CacheHandler) or directly transmit the request to the RequestDispatcher component. The number of requests (load) and the percentage of similar requests (deviation) are two parameters defined for the RequestHandler component:
The CacheHandler component is used only if the number of similar HTTP re- quests is high.
The memorySize for the CacheHandler component must depend on the overall
load of the server.
The validityDuration of data in the cache must also depend on the overall load of the server.
The number of used file servers (like the FileServer1 and FileServer2 components) used by RequestDispatcher depends on the overall load of the server.

Fig. 2. HTTP Server architecture
We consider that the HTTP server can be reconfigured during the execution by the following reconfiguration operations:
AddCacheHandler and RemoveCacheHandler which are respectively used to add and remove the CacheHandler component when the deviation value in- creased/decreased around 50;
AddFileServer and removeFileServer which are respectively used to add and re- move the FileServer2 component;
MemorySizeUp and MemorySizeDown which are respectively used to increase and to decrease the MemorySize value;
DurationValidityUp and DurationValidityDown to respectively increase and de- crease the ValidityDuration value.
As an illustration, we specify the AddCacheHandler reconfiguration expressed in the FScript language [11]. When the deviation value exceeds 50, the reconfigura- tion consists in instantiating a CacheHandler component. Then, the component is integrated into the architecture, and the binding with the required interface of RequestHandler is established. Finally, the component CacheHandler is started.





Proof-based Approach: the B Method
B is a formal software development method used to model systems and to reason about their development [1]. When building a B model, the principle is to express system properties which are always true after each evolution step of the model, the evolution being specified by the B operations. The verification of a model correctness is thus akin to verifying the preservation of these properties, no matter which step of evolution the system takes.
The B method is based on set theory, relations and first-order logic. Constraints are specified in the INVARIANT clause of the model, and its evolution is specified by the operations in the OPERATIONS clause. Let us assume here that the initialisation is a special kind of operation. In this setting, the verification of a B model consists in verifying that each operation—assuming its precondition and the invariant hold— satisfies the INVARIANT, i.e. the model is consistent. A strength of the B method is its stepwise refinement feature: each refinement makes a model more deterministic and also more precise by introducing programming language-like features.
Tool supports, such as B4free or AtelierB 3 , automatically generate proof obli- gations (POs) to ensure the consistency in sense of B [1]. Some of them are obvious POs whereas the other POs have to be proved interactively if it was not done fully automatically by the different provers embedded into AtelierB. Another tool, called ProB 4 , allows the user to animate B specifications for their debugging and test- ing. On the verification side, ProB contains a constraint-based checker and a LTL bounded model-checker with particular features; Both can be used to detect various errors in B specifications [18,19].

Specifying a General Architectural Model with B
In [12], we have defined a configuration to be a set of architectural elements (com- ponents, interfaces and parameters) together with a relation to structure and to link them, through a graph-based representation. The model we have proposed was inspired by the model in [16,17] given for Fractal. Unlike [16,17], in our model only the basic and generic concepts are considered to allow their application to vari- ous hierarchical component models: components as runtime entities, required and provided interfaces as interaction points between components, bindings to link com- ponent interfaces. Components are either primitive or composite components. Only primitive components can have some attributes used as configuration parameters.
Component-based models must provide mechanisms for systems to be dynami- cally adapted—through their reconfigurations—to their environments during their

3 http://www.b4free.com / http://www.atelierb.eu
4  http://www.stups.uni-duesseldorf.de/ProB

lifetime. These dynamic reconfigurations may happen because of architectural mod- ifications specified in primitive operations. Notice that reconfigurations are not the only manner to make an architecture evolve. The normal running of different com- ponents also changes the architecture by modifying parameter values or stopping components, for instance.
In this paper, we give a B specification of the generic model for component ar- chitectures in [12]. Firstly, we express all the architectural constraints between the architectural elements as B properties and invariants; secondly, we model the prim- itive reconfiguration operations as B operations; thirdly, we prove the consistency of this architectural B model.

Specifying the Architectural Conﬁgurations with B
The architectural elements we consider are the core entities of a component-based system: COMPONENTS, INTERFACES, INTERFACE TYPE, and the component PARAMETERS; and relations over them to express various links between these architectural ele- ments. Some of these relations do not evolve during the system reconfigurations. They are then defined as B CONSTANTS, and architectural constraints over them are expressed in the PROPERTIES clause.

The ProvidedInterfaces and RequiredInterfaces are defined to be subsets of INTERFACES. Their union is disjunctive. InterfaceType is a total function that associates a type with each required and provided interface. Provider is a total surjective function which gives the component having at least a provided interface, whereas Requirer is only a total function. Contingency is a total function which indicates for each required interface if it is mandatory or optional. Definer is a total function which gives the component of a considered parameter.
The other architectural relations we consider may evolve. They are defined as B
VARIABLES, and architectural constraints over them are expressed in the INVARIANT
clause.


InstantiatedComponents is a subset of COMPONENTS. Parent is partial function linking sub-components to the corresponding composite component. Composite compo- nents have no parameter, and a sub-component must not be a composite including its parent component, and so on.

Binding is a partial function which connects together a provided interface and a required one: a provided interface can be linked to only one required interface, whereas a required interface can be the target of more than one provided interface. Moreover, two linked interfaces do not belong to the same component, but their corresponding instantiated components are sub-components of the same composite component. The considered interfaces must have the same interface type, and they have not yet been involved in a delegation.

ProvDelegate and ReqDelegate express delegation links and are similarly defined. They are both partial bijections that associate a provided (resp. required) interface of a sub-component with a provided (resp. required) interface of its composite: the parent of the component which provides (resp. requires) isub must be the provider (res. requirer) of isuper. Finally, both interfaces must have the same type, and they have not yet been involved in a binding.

State is a total function which associates a value from { started , stopped} with each instantiated component: a component can be started only if all its mandatory required interfaces are bound or delegated. Last, Value is a total function which gives the current value of a considered parameter.

Modelling the Dynamic Reconﬁgurations with B

Once a configuration-based model is given, the primitive reconﬁguration operations can be specified as B operations of this B model. Namely, we specify:
instantiate (newComponent) and delete (component) to instantiate/destroy a component;
add(subComponent,composite) and remove(subComponent) to add/remove sub-components to/from a composite;
bind( iprov , ireq ) and unbind( iprov) to bind/unbind component interfaces;
delegate( isub , isuper ) and undelegate( isub) to delegate/undelegate component interfaces;
start (component) and stop(component) to start/stop components;
set(parameter, newValue) to set a new parameter value.
Let us detail some of these B operations. The example below defines in B the primitive reconfiguration operation adding a subcomponent to a composite compo- nent:

The add(subComponent,composite) operation must establish that the both components are instantiated components, composite is a composite component (i.e. a component without parameters). Moreover, subComponent is not a sub-component of another composite nor is already used: none of its interfaces is bound or delegated. Finally, the modification does not introduce a cycle into Parent.
The  binding  of  component
interfaces is expressed by bind( iprov , ireq ): this operation must establish that the con- sidered interfaces are correct,
i.e. they are provided (resp. required) interfaces of instan- tiated components, they are not bound nor delegated, and their types are compatible. Furthermore, the binding has not been done yet.

The unbinding primitive opera- tion is specified as follows: this operation expresses as precon- dition that the considered inter- face is provided by an instanti- ated component. This provider must be stopped. Moreover, a re- quired interface bound with the considered interface, must exist. Then, the considered interface is removed from Binding.

When considering a started component, applying stop(component) changes to stopped the state of the considered component and the states of all its sub-components, if they exist; and so on.
Once these primitive reconfiguration operations are specified, more complex re- configuration operations can be written, as explained in Sect. 2.



Validating the Architectural B Model
We use AtelierB to validate the consistency of our generic B model for component architectures. The tool generates proof obligations (POs) to check the consistency of all the architectural constraints expressed in the INVARIANT and the fact that each B reconfiguration operation respects these architectural constraints.

The AtelierB generates 139 POs. No- tice that the work on POs is in progress: at this time, 114 of them are automat- ically or interactively discharged. The proof of 25 POs remains to be done.

That does not mean that they are false, but that the AtelierB provers simply don’t succeed in demonstrating the rule: it may be due to the fact that some B operators are not handled in an efficient manner by the provers (like closure1 (), for 11 unproved POs), or due to the fact that the heuristics used for the proof are not efficient enough in this case. An effort remains to be done to manually demonstrate the unproved POs.

Validating a Specific Architecture
As summarized in Fig. 1, our approach consists in instantiating the generic ar- chitectural B model to specify and to verify a particular architecture. Primitive reconfiguration operations are used to give the complex reconfiguration operations corresponding to the running example.
As explained in Section 1, the instanciation of the general model cannot be checked with the proof approach. Indeed, we don’t consider any specification of the controller to manage the dynamic reconfigurations. Nevertheless, to partially validate the model, we apply bounded model-checking to validate the instantiated model.

Instantiating a Running Architecture
To instantiate a specific architecture using the generic B model, we just give values to all the previously defined sets, constants and variables in Subsect. 4.1, to make them represent the running architecture.
Let us now specify the different manipulated basic architectural elements corre- sponding to the HTTP server example:

The PROPERTIES clause is extended to state values of the architectural relations:

Finally, we initialise the remaining architectural relations as follows:


Modelling the Running Reconﬁgurations with B


After having specified the primitive reconfigurations in Subsect. 4.2, we can write more complex reconfiguration operations calling the primitive ones, by composing them sequentially and by using SELECT, IF and/or WHILE statements.
The AddCacheHandler reconfiguration from Sec. 2 can be expressed using the B reconfigu- ration primitives as depicted here. All the re- configurations of the running example can be expressed by B operations in a similar man- ner.
In addition, the normal running of different components could also change the
architecture by modifying, for example, parameter values. To handle this behaviour, a solution would be to define an abstraction of the running of the system as a (set of) B operation(s). For our example, a B operation, called RUN, is added: basically, it changes the values of the (load) and (deviation) parameters of the RequestHandler component.









Validating the Running Architectural B Model


Addressing the validation of the instantiated B model using a proof process is not possible at this step of the work. Indeed, we have not taken into consideration a specification of the necessary associated controller to manage dynamic recon- figurations (by the mean of adaptation policies, as instance). Then, there is no information about the context where the reconfiguration operations are called. The AtelierB cannot be used to verify the instantiated model because its provers have no hypothesis to help them to prove that the reconfigurations preserve the architectural invariant.
Nevertheless, in order to (partially) validate the instantiated B model, ProB can be used to check the consistency of samples of the instantiated B model: at each reconfiguration step, ProB checks the architectural constraints to find an ex- ample violating the invariant. It is therefore possible to produce traces containing sequences of running and reconfiguration operations.



For example, it is easy to reproduce this short scenario (the right- side figure depicts the corresponding trace generated by ProB):
The initial configuration of the HTTP server is without the
CacheHandler and FileServer2 components;
Next configuration is obtained by running the architecture and changing the load and deviation values;
At this stage, we add CacheHandler to the global architec- ture, following the AddCacheHandler reconfiguration opera- tion;
After that the FileServer2 component is added to the archi- tecture, through the AddFileServer reconfiguration;
The architecture is running;
By applying the RemoveCacheHandler reconfiguration, the component CacheHandler is deleted from the global archi- tecture.
Automatic random explorations allow us to check the instantiated B model in a more general manner. As example, ProB model- checks 1000 nodes into 5301 milliseconds: neither invariant viola- tion nor deadlock was found, and all the operations were covered.








AddCacheHandler

AddFileServer


RemoveCacheHandler


155:



Checking Temporal Formulae over Reconfigurations
In this section, we exploit the linear temporal logic for dynamic reconfigurations introduced in [12] and called FTPL. It allows us to characterise the correct be- haviour of reconfiguration-based systems by using architectural invariants and lin- ear temporal logic patterns. FTPL has been inspired by proposals in [13], and their temporal extensions for JML [21,8,14]. In this work, we propose to translate the FTPL patterns into LTL formulae in order to check FTPL properties with the ProB model-checker.


FTPL Syntax and Semantics
Let us consider the subset of FTPL in the figure below. It is based on trace prop- erties, each of them being a temporal constraint on (a part of) the execution of the dynamic reconfiguration model. The configuration properties, called conf , are first order logic formulae over sets and relational operations on the primitive sets and over relations defined in Sect. 4.1. Further, for a reconfiguration operation ope, its ending is considered as an event.

The trace properties specify the constraints to ensure on a sequence of reconfigurations. We mainly specify the always and eventu- ally constraints which respectively describe that a property has to be satisfied by every configuration of the sequence, or by at least one configuration of the sequence.
Every temporal formula concerns a part of the execution trace on which the
property should hold: it is specified with special keywords, like e.g., after/before
a particular event has happened, or between two particular events.
Let us now illustrate the FTPL language by expressing some properties on the example of the HTTP server from Sect. 2.
Example 1 The following property expresses an architectural constraint saying that always there is at least one ﬁle server. In other words, always there is at least one provided interface connected to the required interface getServer of RequestDis- patcher:
always ∃ iprov ∈ ProvidedInterfaces. Binding(iprov) = getServer
Example 2 The reconﬁguration AddCacheHandler (resp. RemoveCacheHandler) adds (resp. removes) CacheHandler when the deviation value is greater (resp. less) than 50. The following property speciﬁes that the deviation value eventually becomes less than 50 between the considered reconﬁgurations:
between AddCacheHandler terminates
RemoveCacheHandler terminates eventually deviation < 50
These examples show that FTPL is more expressive than the proposals in [11], which only handle architectural invariants. Indeed, FTPL allows expressing event properties and temporal properties involving different kinds of temporal patterns which have been shown useful for practical applications [13].


From FTPL to LTL
We adapt the results in [21] and [8] and propose a translation of FTPL patterns into the LTL dialect considered by ProB, called LTL[e] [19]. The translation procedure, denoted LTL(x), is inductively defined on the structure of the FTPL formula.
Let conf be a configuration prop-
erty, B(conf ) a rewriting proce- dure giving the B predicate corre- sponding to conf , and ope a recon- figuration.
Let trace, trace1 and trace2 be trace properties, event an event property, and
temp a temporal property. Remark that a trace property is translated into LTL according to the temporal context in which the property is used, that is why we define an auxiliary functions LTLB.


The FTPL property presented in Example 1 has been translated into the LTL formula below. This formula has been partially checked with ProB in 126 millisec- onds. The model checker generates 2002 atoms and 16064 transitions when the maximum number of new states is 1000.

Applying the above translation to the property in Example 2 results in the LTL property below, checked in 1802 milliseconds. The model checker generates 16048 atoms and 129704 transitions when the maximum number of new states is 1000.

More sophisticated temporal properties involving architectural constraints can be written thanks to FTPL [12]. Then, thanks to our translation procedure, their verification can be investigated with ProB. Note that this verification is size- bounded and partial because of ProB features.

Conclusion
The different proposals presented in this paper concern the verification of dy- namic reconfigurations of concurrent component-based systems. Dynamic archi- tectural constraints could be expressed with a linear time temporal logic over (re)configuration sequences, as FTPL [12]. As architectural constraints involve first- order formulae, and a behavioural semantics of reconfigurations gives rise to infinite state systems, we have proposed an approach combining proof and model-checking to support the modelling of such systems and the validation of their dynamic re- configurations, as depicted Fig. 1. We first have proposed a generic B model for component architectures and we have proved the consistency of the model archi- tectural constraints. Then, we have instantiated the general model to address a particular architecture validation: its consistency and some temporal properties over (re-)configuration sequences—expressed in FTPL and translated into LTL— have been model-checked.
Our contributions for temporal properties specification and verification— including static and dynamic analysis—allow monitoring instrumentation and man- aging applications at runtime, thanks to available tools to animate specifications.
Related work. In the context of dynamic reconfigurations, ArchJava [4] gives means to reconfigure Java architectures, and the ArchJava language guarantees communication integrity at run-time. Barringer et al. give a temporal logic based framework to reason about the evolution of systems [6]. In [5], a temporal logic is

proposed to specify and verify properties on graph transformation systems.
In the Fractal-based framework, the work in [17] has defined integrity constraints on a graph-based representation of Fractal, to specify the reliability of component- based systems. Unlike [17], our model lays down only general architectural con- straints, thus providing an operational semantics to other component-based systems. On the integrity constraints side, the FTPL logic allows specifying architectural constraints more complex than architectural invariants in [11].
To enforce software robustness while adding adaptive behaviour, the work in [20] proposes a formal framework for the Fractal component model, named FracL. Like our B-based proposal, the FracL static approach allows verifying the consistency of the application architecture. However, our proposal allows checking the model consistency and monitoring temporal properties, both fully automatically.
Among other applications, our proposals aim at a monitoring of component- based systems. In [7], Basin et.al have shown the feasibility of monitoring temporal safety properties (and, more recently, security properties) using a runtime moni- toring approach for metric First-order temporal logic (MFOTL). Like the model in [7], our model is a first-order structure, but instead of considering a sequence of time stamps, we focus on reconfiguration operations. In [15], knowledge-based con- trollability is studied for constructing distributed controllers. The problem there is somewhat different than ours: the goal is to make the system behave exactly accord- ing to a given knowledge-based priority property, while here the reconfigurations must satisfy some given architectural and temporal constraints.

References
Abrial, J.-R., “The B Book - Assigning Programs to Meanings,” Cambridge University Press, 1996.
Aguilar Cornejo, M., H. Garavel, R. Mateescu and N. De Palma, Specification and Verification of a Dynamic Reconfiguration Protocol for Agent-Based Applications, Research Report RR-4222, INRIA (2001).
Aguirre, N. and T. Maibaum, A temporal logic approach to the specification of reconfigurable component-based systems, Automated Software Engineering (2002).
Aldric, J., Using types to enforce architectural structure, in: In WICSA’08, February 2008, 2008, pp. 23–34.
Baldan, P., A. Corradini, B. K¨onig and A. L. Lafuente, A temporal graph logic for verification of graph transformation systems, in: WADT’06: Proceedings of the 18th Int. Conf. on Recent trends in algebraic development techniques (2007), pp. 1–20.
Barringer, H., D. M. Gabbay and D. E. Rydeheard, From runtime verification to evolvable systems, in:
RV, LNCS 4839 (2007), pp. 97–110.
Basin, D. A., F. Klaedtke, S. Mu¨ller and B. Pfitzmann, Runtime monitoring of metric first-order temporal properties, in: IARCS, FSTTCS 2008, India, LIPIcs 2 (2008), pp. 49–60.
Bellegarde, F., J. Groslambert, M. Huisman, J. Julliand and O. Kouchnarenko, Verification of liveness properties with JML, Technical report RR-5331, INRIA (2004).
Bruneton, E., T. Coupaye, M. Leclercq, V. Qu´ema and J.-B. Stefani, The fractal component model and its support in java, Softw., Pract. Exper. 36 (2006), pp. 1257–1284.
Chauvel, F., O. Barais, N. Plouzeau, I. Borne and J.-M. J´ez´equel, Composition et expression qualitative de politiques d’adaptation pour les composants Fractal, in: GDR GPL 2009, Toulouse, France, 2009.


David, P.-C., T. Ledoux, M. L´eger and T. Coupaye, FPath and FScript: Language support for navigation and reliable reconfiguration of Fractal architectures, Annales des T´el´ecommunications 64 (2009), pp. 45–63.
Dormoy, J., O. Kouchnarenko and A. Lanoix, Using temporal logic for dynamic reconfigurations of components, in: 7th Int. Ws. on Formal Aspects of Component Software (FACS 2010), LNCS (2010), to appear.
Dwyer, M. B., G. S. Avrunin and J. C. Corbett, Patterns in property specifications for finite-state verification, in: ICSE, 1999, pp. 411–420.
Giorgetti, A., J. Groslambert, J. Julliand and O. Kouchnarenko, Verification of class liveness properties with Java modelling language, IET Software (2008).
Graf, S., D. Peled and S. Quinton, Achieving distributed control through model checking, in: Proc. of the 22nd Int. Conf. CAV 2010, LNCS 6174 (2010), pp. 396–409.
L´eger, M., “Fiabilit´e des Reconfigurations Dynamiques dans les Architectures a` Composant,” Ph.D. thesis, Ecole Nationale Sup´erieure des Mines de Paris (2009).
L´eger, M., T. Ledoux and T. Coupaye, Reliable dynamic reconfigurations in a reflective component model, in: CBSE 2010, LNCS 6092 (2010), pp. 74–92.
Leuschel, M. and M. J. Butler, ProB: A model checker for B, in: Int. Symp. of Formal Methods Europe FME’03, LNCS 2805 (2003), pp. 855–874.
Leuschel, M. and D. Plagge, Seven at one stroke: Ltl model checking for high-level specifications in b, z, csp, and more, in: ISoLA’07, Revue des Nouvelles Technologies de l’Information RNTI-SM-1, 2007, pp. 73–84.
Simonot, M. and M. Aponte, Une approche formelle de la reconfiguration dynamique., L’OBJET 14
(2008), pp. 73–102.
Trentelman, K. and M. Huisman, Extending jml specifications with temporal logic, in: AMAST 2002, LNCS 2422, 2002, pp. 334–348.
