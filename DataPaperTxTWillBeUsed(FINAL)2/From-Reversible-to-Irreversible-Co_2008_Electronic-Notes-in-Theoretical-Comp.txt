Electronic Notes in Theoretical Computer Science 210 (2008) 65–74	
www.elsevier.com/locate/entcs

From Reversible to Irreversible Computations
Alexander S. Green1 and Thorsten Altenkirch2
Computer Science and IT The University of Nottingham Nottingham, UK

Abstract
In this paper we study the relation between reversible and irreversible computation applicable to different models of computation — here we are considering classical and quantum computation. We develop an equational theory of reversible computations and an associated theory of irreversible computations which is obtained by marking some inputs as preinitialised heap and some outputs as garbage to be thrown away at the end of the computation. We present three laws which apply to irreversible classical and quantum computations and show that von Neumann’s measurement postulate is derivable from them. We discuss the question whether these laws are complete for irreversible quantum computations.
Keywords: Reversible computation, irreversible computation, quantum computation, categorical models.


Introduction
Abstract models of computation like λ-calculus, or even more abstractly Cartesian closed categories, are based on irreversible processes; indeed Cartesian products in- troduce projections which are irreversible. In contrast, in Physics the more funda- mental notions describe processes in closed systems where every action is reversible,
e.g. Newtonian Mechanics, Maxwellian electrodynamics and quantum mechanics fit into this pattern. Open systems, which allow irreversible processes, are a derived notion — they can be considered as a subsystem of a closed system. Indeed, an irreversible process can be understood in terms of a reversible one with a partic- ular assignment of boundary conditions, e.g. Feynman’s and Wheeler’s theory of absorbers [11].
Our plan is to follow the physical idea that reversibility is the fundamental notion, and irreversibility is a derived notion to model computation. Reversibility has been investigated by Bennett in his classical paper [3], where he shows that reversible computation has the same power as irreversible computation. It has

1 Email: asg@cs.nott.ac.uk
2 Email: txa@cs.nott.ac.uk

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.018

also since been shown that, in terms of complexity, reversible space is the same as deterministic space [6]. Recently, Abramsky investigated the notion of reversible computation from a structural perspective [1].
This research builds on previous work of the second author with Jonathan Grattage on compiling QML [2,5]. QML’s design is based on an analogy between classical and quantum computation. To make this precise we introduce two mod- els of computation: FCC for Finite Classical Computation and FQC for Finite Quantum Computation. Both are based on a notion of reversible computation (bi- jections vs. unitary operators) and introduce irreversible computations as a derived notion; by marking certain inputs as preinitialised heap, and certain outputs as garbage which is thrown away (i.e. measured, in the quantum case) at the end of the computation. We also introduce the notion of extensional equivalence of two irreversible computations which are given by the associated functions on finite sets in the classical case, and by an embedding into the category of superoperators on finite dimensional Hilbert spaces in the quantum case. While the choice of ex- tensional equality in the two examples is very natural, it is not parametric in the notion of reversible computation. We would like to obtain the notion of irreversible computation as a consequence of our choice of reversible computation.
The goal is approached by introducing three laws which state which algebraic properties a notion of irreversible computation derived from reversible computation must satisfy. Both FCC and FQC satisfy these laws, and it is shown that they are sufficient to derive von Neumann’s measurement postulate, which in this setting corresponds to the statement that measuring twice is the same as measuring once. A natural question which arises is whether our laws are sufficient to characterise the equivalence of quantum circuits, at least for definable circuits (i.e. classical circuits viewed as quantum circuits).
Our work here is related to other, more sophisticated, categorical models of quantum computing such as Coecke’s Kindergarten Quantum mechanics [4] and Selinger’s dagger-complete categories [9].

Acknowledgements
We would like to thank Jonathan Grattage for his help and discussions on this paper, and also the referee who suggested a number of simplifications of our laws and whose comments were very interesting and useful.

Reversible computation
We model reversible computations by a groupoid FxC , that is for every morphism ψ ∈ FxC (a, b) there is an inverse ψ−1 ∈ FxC (b, a) such that ψ, ψ−1 are an isomorphism. We assume that the groupoid is strict, i.e. that any isomorphic objects are equal. This entails that FxC (a, b) is empty, if a /= b, consequently we denote homsets by FxC a = FxC (a, a). We also assume that FxC has a strict monoidal structure I, ⊗ which corresponds to parallel composition of computations

and a special object of Booleans,denoted by N2. Since we are only interested in objects which can be generated from I, N2, ⊗ we can use natural numbers a ∈ N to denote the object 2a. Hence we have that I = 0, N2 = 1 and a ⊗ b = a + b. We write [a]= {i ∈ N | i < a} for the initial segment of N.
We characterise the morphisms, i.e. circuits, in FxC a inductively and also give the inverses:
wires Given a bijection on initial segments φ : [a]  [a] we write wires φ ∈ FxC a
for the associated rewiring. For example, the rewiring denoted schematically as
x0	x1
x1	x2
x2	x0
would have φ(0) = 2, φ(1) = 0, and φ(2) = 1. The existence of wires follows from the strict monoidal structure, with the identity (ida) being a special case of wires.
sequential composition combines two circuits of equal size (i.e. with the same number of wires) in sequence. That is, given ψ, φ ∈ FxC a we construct φ ◦ ψ ∈ FxC a.

we can construct the inverse using φ−1 and ψ−1 to give ψ−1 ◦ φ−1.

parallel composition combines any two circuits in parallel, and can be thought of as the tensor product. The size of the new circuit constructed is equal to the sum of the sizes of the original two circuits. That is, given ψ ∈ FxC a and φ ∈ FxC b we can construct ψ ⊗ φ ∈ FxC (a ⊗ b).


again we can construct the inverse using ψ−1 and φ−1, this time to give ψ−1 ⊗φ−1.


rotations count as any 1 “bit” operations. That is a rotation is any element of FxC 1, and in the case of classical reversible circuits the only rotation available is the Not operation. So we have ¬ ∈ FxC 1 with ¬−1 = ¬. In the quantum case this would be any single qubit rotation.(i.e. a unitary operation in U (2))

conditionals use a control wire to decide whether a computation should be per- formed. That is, given φ ∈ FxC a we can construct ida | φ ∈ FxC (N2 ⊗ a).

the inverse is again constructed using φ−1 giving ida | φ−1.

For ease of notation we shall also introduce the conditional that acts when the control wire is set to true. This conditional can be constructed from the condi- tional already given, and the Not operation (or rotation) as follows:
≡


which for φ ∈ FxC a can be denoted φ | ida ∈ FxC (N2 ⊗ a). This naturally leads us to a choice operator, such that given two computations of the same size, the value of the control wire is used to govern which computation is done. That is, given ψ, φ ∈ FxC a we can construct ψ | φ ∈ FxC (N2 ⊗ a), as follow:

the inverse is once again given by ψ−1 and φ−1, and constructed as ψ−1 | φ−1:

The laws governing wires, sequential composition and parallel composition follow from the categorical infrastructure. Additionally, we assume that the following equalities hold for conditionals:
Firstly, we have for f, g, h ∈ FxC a that (f | g) ◦ (N2 ⊗ h) = f ◦ h | g ◦ h
schematically this can be shown as:
=


Secondly, we have for f, g, h ∈ FxC a that (N2 ⊗ h) ◦ (f | g) = h ◦ f | h ◦ g

schematically this can be shown as:
=


and thirdly, we have that for f, f ', g, g' ∈ FxC a that (f | g) ◦ (f ' | g')= (f ◦ f ') |
(g ◦ g') again the schematic representation for this would be:
=


We also have distributivity over ⊗ and |, such that given f, g ∈ FxC a and h ∈ FxC b we have that (f | g) ⊗ h = (f ⊗ h) | (g ⊗ h). This can again be given schematically.
=


using this last axiom it is possible to simplify the first two to just be that (h | h)= (id1 ⊗ h) or schematically:
=

The next axiom that we introduce is that ida | ida = idN2 ⊗a, and can be given (in it’s most simple form) schematically as:
=

Moreover, we have for f, g ∈ FxC a that (¬⊗ ida) ◦ (f | g)= (g | f ) ◦ (¬⊗ ida), or schematically that would be:
=


Examples of FxC  categories
There are two obvious computational examples of FxC categories: firstly there is the FCC category of classical reversible circuits, and secondly there is the FQC of quantum circuits. The difference mainly being in the rotations that are available. The extensional equality is given by interpreting circuits as permutations

on [a] in the classical case and as unitary operators on a-dimensional Hilbert spaces in the quantum case. Note that FCC ‹→ FQC and this embedding preserves extensional equality, because the unitary operators which can be obtained from definable circuits contain only 0 and 1 and hence can be obtained by embedding the corresponding permutation.

Bipermutative categories
A symmetric bimonoidal category (C, Z, ⊕,I, ⊗) is a category with two symmetric monoidal structures (Z, ⊕) and (I, ⊗) and distributivity isomorphisms d ∈ A ⊗(B ⊕ C)  A ⊗ B ⊕ A ⊗ C and d' ∈ (A ⊕ B) ⊗ C)  A ⊗ C ⊕ B ⊗ C subject to a number of coherence laws [7]. A bipermutative category is a symmetric bimonoidal category where all isomorphisms apart from c⊕ ∈ A ⊕ B  B ⊕ A and c⊗ ∈ A ⊗ B  B ⊗ A are identities. There are still a number of coherence laws to be satisfied such as:

The models for FCC  and FQC  give rise to bipermutative categories, where N2 = I ⊕ I and all the laws stated above hold in all bipermutative categories. Hence, this development could be stated more abstractly in terms of bipermutative categories.

Irreversible computation
A notion of irreversible computations is derived from the given notion of reversible computation by defining the category FxC, where every morphism of the category represents an irreversible computation, but is in fact of the form ψ' = (h, g, ψ) where h is a set of heap inputs, g is a set of garbage outputs, and ψ is the underlying reversible computation. So a morphism in FxC(a, b) can be given as a morphism in FxC ((a⊗h), (b⊗g)) with the requirement that (a⊗h)= (b⊗g). Schematically, an irreversible computation (h, g, ψ) can be represented as the reversible computation ψ, where heap and garbage are marked explicitly:
a	b
h	g
It is also the case that for any ψ ∈ FxC a, there is an equivalent circuit ψ^ ∈

FxC(a, a); this precisely is given by the following predicate:
ψ ∈ FxC a ψ^ ∈ FxC(a, a)
such that ψ^ = (0, 0, ψ), i.e. there is no heap or garbage.
Sequential composition for irreversible computations can be defined: given α = (hα, gα, φα) ∈ FxC(a, b) and β = (hβ, gβ, φβ) ∈ FxC(b, c) we define β ◦ α ∈ FxC(a, c), as
a	c
h	gβ

α
hβ	gα
The identity can be obtained by lifting the reversible identity idFxC


^FxC  .

a	= ida
It is straightforward to verify that FxC thus constructed is a category by using the monoidal identities in the underlying category of reversible computations. Moreover, FxC inherits the monoidal structure from FxC , e.g. given α = (hα, gα, φα) ∈ FxC(a, b) and β = (hβ, gβ, φβ) ∈ FxC(c, d), we obtain α ⊗ β ∈ FxC(a ⊗ c, b ⊗ d) as:
a	b
c	d
hα	gα
hβ	gβ
The neutral element of the tensor, the empty circuit, can be obtained by lifting

IFxC
^FxC 
= I	.


Examples of FxC categories
The two example FxC  categories can now be extended to FxC categories: FCC, for the category of finite classical computations; and FQC, for finite quantum computations. The extensional equality in the classical case is given by interpreting morphisms as functions on finite sets: (h, g, φ) ∈ FCC(a, b) is interpreted as πg ◦
 φ) ◦ (0h, −) ∈ [a] → [b], where φ) ∈ [a ⊗ h] → [b ⊗ g] is the associated permutation, (0h, −) ∈ [a] → [a ⊗ h] initialises the heap and πg ∈ [b ⊗ g] → b projects out the garbage.
In the quantum case circuits are interpreted as superoperators (see [8], [10], or [5] for an implementation in Haskell). Superoperators are morphisms on density opera- tors, which are positive operators on the a-dimensional Hilbert space. A superoper- ator f ∈ Super(a, b) is a linear function mapping density operators on a to density operators on b, which preserve the trace and are stable under ⊗. Analogously to the classical case, we interpret (h, g, φ) ∈ FQC(a, b) as trg ◦ φ) ◦ 0h ⊗− ∈ Super(a, b), where φ) ∈ Super(h ⊗ a, g ⊗ b) is the superoperator associated to the unitary operator given by interpreting the reversible circuit φ. 0h ⊗− ∈ Super(a, a ⊗ h) initialises the heap and trg ∈ Super(g ⊗ b, b) is a partial trace which traces out the garbage.

Equivalence
In the reversible case the equality of definable circuits is the same in the classical case and in the quantum case, but this doesn’t hold for irreversible computations. For example, in the classical case the following two circuits would be equivalent:
≡


However, this equivalence does not hold when we move into the category of finite quantum computations FQC. This is because in quantum computation the control wire (or qubit) can become entangled with the target wire (qubit). However there is another similar equivalence that holds in FQC:
≡




This is akin to von Neumann’s measurement postulate. So, how now can we char- acterise the equivalences which should always hold?
We have developed three laws to try and characterise these equivalences, that hold in both FCC and FQC. The first law is that of garbage collection. It states that if a circuit can be reduced into two smaller circuits such that one part of the circuit only acts on heap inputs and on garbage outputs, then that part of the circuit can be removed.


A H
B	≡	A	B G

The second law is of the uselessness of garbage processing. This states that if a circuit can be reduced into two smaller circuits such that one part of the circuit only has an effect on garbage outputs, then that part can be removed.
A	B	≡	A	B

H
G	H	G

this can be alternately stated as saying that if the only outputs of (part of) a circuit are garbage outputs, then this is equivalent to just having garbage.
≡
and similarly we can now simplify the first law to state that a wire that simply connects the heap to the garbage is equivalent to having nothing.
≡	•

The third law is of the uselessness of heap preprocessing. This states that if a circuit can be reduced into two smaller circuits such that one part of the circuit only has effect on heap inputs, and the effect on the zero vector is the identity, then that part can be removed.
if  h0 = 0 then

A	B	≡	A	B

H
G	H	G

An alternate notation for this would again be to state that if (part of) a circuit only has heap inputs, and its effect on the zero vector is the identity, then this is equivalent to just having a heap.
if  h0 = 0 then
≡	
We can already use these laws to give a proof of the measurement postulate.
The first step is to show the equivalence of
≡



This is simple as you will notice there is no heap or garbage, so we know that the circuits are in FQC , and in fact only use the elements from FCC . Thus equivalence can be shown by looking at the truth tables, which are the same.
The third controlled not is eliminated using the second law:
≡




The controlled Not operations preserve the zero vector, so we can eliminate the first one using the third law:
≡


Finally the bottom wire can be removed by use of the first law:
≡

Conclusions and further work
The first steps toward a theory of irreversible computation based on reversible computation have been outlined, and it has been shown that the laws presented here for irreversible computations are sufficient to derive von Neumann’s measurement postulate. Apart from this, there are currently more questions than answers. One question is are there equalities between definable irreversible quantum circuits which are not derivable from our laws? It has been proposed that this question may be answered by translating our formalism into Selinger’s dagger-complete categories [9]. Recent work by Coecke shows that this category is not equationally definable in terms of initialisations and measurements, however it is not clear at the moment whether such a counterexample is definable in our sense.
We are investigating whether we could state the whole development more ab- stractly using only symmetric, strictly bimonoidal, categories as the base for the notion of reversible computations. Currently, it is not clear how to state abstractly the precondition required by the third law; that a circuit is 0-preserving. An alter- native would be to drop this condition and to assume that a computation can be carried out, provided a correct initialisation. Interestingly, our laws would then be symmetric.
Finally, we would like to answer the question whether our laws are complete for quantum computation, that is whether we can characterise the equality of definable quantum circuits just by the three laws presented here.

References
Abramsky, S., A structural approach to reversible computation., Theor. Comput. Sci. 347 (2005),
pp. 441–464.
Altenkirch, T. and J. J. Grattage, A functional quantum programming language, in: Proceedings of the 20th Annual IEEE Symposium on Logic in Computer Science, LICS 2005, IEEE Computer Society Press, 2005, pp. 249–258.
Bennett, C. H., Logical reversibility of computation, IBM Journal of Research and Development 17
(1973), pp. 525–532.
Coecke, B., Kindergarten quantum mechanics, quant-ph/0510032 (2005).
Grattage, J. J., “QML: A functional quantum programming language,” Ph.D. thesis, The University of Nottingham (2006).
Lange, K.-J., P. McKenzie and A. Tapp, Reversible space equals deterministic space, in: IEEE Conference on Computational Complexity, 1997, pp. 45–50.
Laplaza, M., Coherence for distributivity, Lecture Notes in Mathematics 281 (1972), pp. 29–72.
Selinger, P., Towards a quantum programming language, Mathematical. Structures in Comp. Sci. 14
(2004), pp. 527–586.
Selinger, P., Dagger compact closed categories and completely positive maps, in: P. Selinger, editor, Proceedings of the 3rd International Workshop on Quantum Programming Languages (QPL 2005), Electronic Notes in Theoretical Computer Science 170 (2007), pp. 139–163.
Vizzotto, J. K., T. Altenkirch and A. Sabry, Structuring quantum effects: Superoperators as arrows, Mathematical Structures in Computer Science, special issue on Quantum Programming Languages 16 (2006), pp. 453–468.
Wheeler, J. A. and R. P. Feynman, Interaction with the absorber as the mechanism of radiation, Rev. Mod. Phys. 17 (1945), pp. 157–181.
