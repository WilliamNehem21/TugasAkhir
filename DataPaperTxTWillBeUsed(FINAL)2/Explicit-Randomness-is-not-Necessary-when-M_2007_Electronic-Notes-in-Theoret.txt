Electronic Notes in Theoretical Computer Science 186 (2007) 49–65	
www.elsevier.com/locate/entcs

Explicit Randomness is not Necessary when Modeling Probabilistic Encryption 1
V´eronique Cortier Heinrich H¨ordegen Bogdan Warinschi
Loria/CNRS UMR 7503 & INRIA Lorraine projet Cassis & Universit´e Henri-Poincar´e & INPL Lorraine, France
{cortier, hordegen, warinsch}@loria.fr

Abstract
One of the most popular abstraction used in security analysis uses abstract, symbolic terms to model the bit strings sent over the network. However, the high level of abstraction blurs the significance of proofs carried out in such models with respect to real executions. In particular, although good encryption functions are randomized, most existing symbolic models for security do not capture explicitly the randomization of ciphertexts.
On the other hand, recent results relating symbolic models with cryptographic models require symbolic models where the randomization of ciphertexts is captured explicitly (through the use of labels attached
to symbolic ciphertexts). Since little to no tool support exists for the resulting label-based models it may seem necessary to extend the decision procedures and the implementation of existing tools from the simpler models to the models that use labels.
In this paper we put forth a more practical alternative. We show that for a large class of security properties (that includes rather standard formulations of secrecy and authenticity), security of protocols with respect to the simpler model implies security in the model that uses labels. Combined with the computational soundness result of [4], our theorem enables the translation of security results obtained in symbolic mod- els that do not use labels to standard computational security. Based on these results, we have recently implemented an AVISPA module for verifying security properties in a standard cryptographic model.
Keywords: Probabilistic encryption, security models, protocol verification, secrecy, authentication.


Introduction
Designers of mathematical models for computational systems need to find appropri- ate trade-offs between two seemingly contradictory requirements. Automatic veri- fication (and thus usability) typically requires a high level of abstraction whereas prediction accuracy requires a high level of details. From this perspective, the use of symbolic models for security analysis is particularly delicate since it seems that the inherent high level of abstraction at which such models operate is not able to capture all aspects that are relevant to security. This paper is concerned with

1 Work partially supported by the ACI Jeunes chercheurs and the ARA SSIA FormaCrypt.

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.11.044

one particular such aspect, namely the use of randomization in the construction of cryptosystems [5].
A central feature of the computational, complexity-based models is the ability to capture and reason explicitly about the use of randomness. Moreover, randomness is essential to achieve any meaningful notion of security for encryption. In contrast, symbolic models rarely represent randomness directly. For example, a typical rep- resentation for the encryption of message m under the public key of entity B is the term {m}ek(B). Notice that the symbolic representation does not capture the dependency on the randomness used to generate this ciphertext. While this ab- straction may be sufficiently accurate in certain settings [11], in some other settings it is not sufficient.
Consider the following flow in some toy protocol:
A → B : {m}ek(B), {{m}ek(B)}ek(B)

To implement this flow, each occurrence of {m}ek(B) is mapped to a ciphertext. No- tice however that the pictorial description does not specify if the two occurrences of
{m}ek(B) are equal (created with identical randomness) or different (created with different randomness). In rich enough protocol specification languages disambiguat- ing constructs as above can be easily done. For instance, in a language that has explicit assignments, the two different interpretation for the first message of the protocol can be obtained as
x := {m}ek(B); send(x, {x}ek(B))  and  send({m}ek(B), {{m}ek(B)}ek(B)).
Here, each distinct occurrence of {m}ek(B) is interpreted with different randomness. Other approaches adopt a more direct solution and represent the randomness used

for encryption explicitly [6, 1, 10, 4]. If we write {m}l
for the encryption of m

under the public key of B with randomness l, the two different interpretations of the flow are:


send({m}l1
l1
ek(B)
l2
ek(B)
) and send({m}l1
l2
ek(B)
l3
ek(B)

A model that employs labels to capture the randomness used in ciphertexts (and signatures) has recently been used to establish soundness of symbolic analysis with respect to computational models [4]. Their results are based on an emulation lemma: for protocol executions, every computational trace can be mapped to a valid sym- bolic trace. The mapping is then used to translate security properties that hold in the symbolic model to computational analogues. Note that the use of labels is necessary even when there is no explicit repetition of cyphertexts to distinguish for example the encrypted messages generated by the agents from those generated by the adversary.
The next step towards making the soundness result relevant to practice is to carry out the security proofs using some (semi-)automated tools for the symbolic model. However, to the best of our knowledge, none of the popular tools (ProVerif [3],

CASPER [8], Athena [13], AVISPA [2]), offers capabilities for automatically reason- ing in models that use labels. There are at least two solutions to this problem. One possibility is to enhance the symbolic models that underlie existing tools. Unfor- tunately such a modification would probably require significant effort that involves adapting existing decision procedures, proving their correctness, and verifying and modifying thousands of lines of code.
In this paper we put forth and clarify an alternative solution, used implicitly in [4]. The idea is to keep existing tools unchanged, use their underlying (unla- beled) model to prove security properties, and then show that the results are in fact meaningful for the model with labels. The main result of this paper is to prove that for a large class of security properties the approach that we propose is indeed feasible.

Results.
We consider the protocol specification language and the execution model de- veloped in [4]. The language is for protocols that use random nonces, public key encryption and digital signatures, and uses labels to model the randomness used by these primitives. To each protocol Π with labels, we naturally associate a protocol Π obtained by erasing all labels, and extend the transformation to execution traces. To each trace tr of Π we associate a trace tr obtained by erasing labels and we extend this mapping to sets of traces. The first contribution of this paper is a proof that the transformation is sound. More precisely we prove that if tr is a valid trace of Π (obtained by Dolev-Yao operations) then tr is a valid trace of Π. Importantly, this result relies on the fact that the specification language that we consider does not allow equality tests between ciphertexts. We believe that a similar result holds for most (if not all) protocol specification languages that satisfy the above condi- tion. The language for specifying protocols (with and without labels) as well as the relation between their associated execution models are in Section 2.
In Section 3 we give two logics, Ll and L1, that we use to express security prop-
erties for protocols with and without labels, respectively. Informally, the formulas of L1 are obtained by removing the labels from formulas of Ll . Both logics are quite expressive. For example, it can be used to express standard formulations for secrecy and authenticity properties.
Next we focus our attention on translating security properties between the two models. First, notice that the mapping between the model with and that without labels is not faithful since it looses information regarding inequality of ciphertexts. To formalize this intuition we give a protocol Π and a formula φ such that Π satisfies φ (the formula that corresponds to φ in the model without labels), but for which Π does not satisfy φ. Anticipating, our example indicates that the source of problems is that φ may contain equality tests between ciphertexts, and such tests may not be translated faithfully. The counterexample is in Section 4.
The main result of the paper is a soundness theorem. We show that for a large class of security properties it is possible to carry out the proof in the model without labels and infer security properties in the model with labels. More precisely, we

identify Ll
and L2, fragments of Ll
and L1 respectively, such that the following

theorem holds.
Consider an arbitrary protocol Π and formula φ in Ll . Let φ be a formula in
L2 obtained by erasing the labels that occur in φ. Then, it holds that:

	


The logics Ll
Π |= φ =⇒ Π |= φ
and L2 are still expressive enough to contain the secrecy and authen-

tication formulas. The theorem and its proof are in Section 4.
Based on our result, we implemented an AVISPA module [2] that is used to obtain computationally sound automatic proofs and used it to validate the protocols in the AVISPA library. The results of our experiments are described in Section 5.

Protocol
In this section we provide the syntax of protocols with labels. The presentation is adapted from [4]. The specification language is similar to the one of Casrul [12]; it allows parties to exchange messages built from identities and randomly generated nonces using public key encryption and digital signatures. Protocols that do not use labels are obtained straightforwardly.
Syntax
Consider an algebraic signature Σ with the following sorts. A sort ID for agent identities, sorts SKey, VKey, EKey, DKey containing keys for signing, verifying, en- cryption, and decryption respectively. The algebraic signature also contains sorts Nonce, Label, Ciphertext, Signature and Pair for nonces, labels, ciphertexts, signa- tures and pair, respectively. The sort Label is used in encryption and signatures to distinguish between different encryption/signature of the same plaintext. The sort Term is a supersort containing all other sorts, except SKey and DKey. There are nine operations: the four operations ek, dk, sk, vk are defined on the sort ID and return the encryption key, decryption key, signing key, and verification key associ- ated to the input identity. The two operations ag and adv are defined on natural numbers and return labels. As explained in the introduction, the labels are used to differentiate between different encryptions (and signatures) of the same plaintext, created by the honest agents or the adversary. We distinguish between labels for agents and for the adversary since they do not use the same randomness. The other operations that we consider are pairing, public key encryption, and signing.
We also consider sets of sorted variables X = X.n∪X.a∪X.c∪X.s and Xl = X∪X.l. Here, X.n, X.a, X.c, X.s, X.l are sets of variables of sort nonce, agent, ciphertext, signature and labels, respectively. The sets of variables X.a and X.n are as follows. If k ∈ N is some fixed constant representing the number of protocol participants,
w.l.o.g. we fix the set of agent variables to be X.a = {A1, A2,... , Ak}, and partition the set of nonce variables, by the party that generates them. Formally: X.n =

∪A∈X.aXn(A) and Xn(A)= {Xj
| j ∈ N}. This partition avoids to specify later, for

each role, which variables stand for generated nonces and which variables stand for expected nonces.
Labeled messages that are sent by participants are specified using terms in T l

L ::= X.l | ag(i) | adv(i)
T l ::= X | a | ek(a) | dk(a) | sk(a) | vk(a) | n(a, j, s)

| ⟨T l ,T l⟩| {T l}L
l L
sk(a)

where i, j, s ∈ N and a ∈ ID.
Unlabeled messages are specified similarly as terms in the algebra T defined by
T ::= X | a | ek(a) | dk(a) | sk(a) | vk(a)
| n(a, j, s) | ⟨T , T ⟩ | {T }ek(a) | [T ]sk(a)
where j, s ∈ N and a ∈ ID.
A mapping · : T l → T from labeled to unlabeled terms is defined by removing

the labels: {k}l
= {k}m, [k]l
= [k]m, f (t1,... , tn)= f (t1,... , tn) otherwise. The

mapping function is extended to sets of terms as expected.
The individual behavior of each protocol participant is defined by a role that describes a sequence of message receptions/transmissions. A k-party protocol is given by k such roles.
Definition 2.1 [Labeled roles and protocols] The set Rolesl of roles for labeled protocol participants is defined by Rolesl = (({init}∪ T l) × (T l ∪ {stop}))∗. A k- party labeled protocol is a mapping Π : [k] → Rolesl, where [k] denotes the set
{1, 2,... , k}.
Unlabeled roles and protocols are defined very similarly. The mapping function is extended from labeled protocols to unlabeled protocols as expected.
We assume that a protocol specification is such that Π(j)= ((lj , rj), (lj, rj), .. .),
1	1	2  2
the j’th role in the definition of the protocol being executed by player Aj. Each
sequence ((l1, r1), (l2, r2),.. .) ∈ Rolesl specifies the messages to be sent/received by the party executing the role: at step i, the party expects to receive a message
conforming to li and returns message ri. We wish to emphasize that terms lj, rj are
i	i
not actual messages, but specify how the message that is received and the message
that is output should look like.
Example 2.2 The Needham-Schroeder-Lowe protocol [7] is specified as follows: there are two roles Π(1) and Π(2) corresponding to the sender’s and receiver’s role.
A → B : {Na, A}ek(B)
B → A : {Na, Nb, B}ek(A)
A → B : {Nb}ek(B)



Π(1) = (init, {X1
ag(1)
ek(A2)
), ({X1	1
L
ek(A1)
, {X1
ag(1)
ek(A2)

Π(2) = ({X1
L1
ek(A2)
, {X1	1
ag(1)
ek(A1)
), ({X1
L2
ek(A2)
, stop)


Clearly, not all protocols written using the syntax above are meaningful. In particular, some protocols might be not executable. This is actually not relevant for our result (our theorem also holds for non executable protocols).


Execution Model
We define the execution model only for labeled protocols. The definition of the execution model for unlabeled protocols is then straightforward.
If A is a variable or constant of sort agent, we define its knowledge by kn(A)= 
{dk(A), sk(A)}∪X.n(A), i.e. an agent knows its secret decryption and signing key as well as the nonces it generates during the execution. The formal execution model is a state transition system. A global state of the system is given by (SId, f,H) where H is a set of terms of T l representing the messages sent on the network and f maintains the local states of all session ids SId. We represent session ids as tuples of the form (n, j, (a1, a2,... , ak)) ∈ (N × N × IDk), where n ∈ N identifies the session, a1, a2,... , ak are the identities of the parties that are involved in the session and j is the index of the role that is executed in this session. Mathematically, f is a function f : SId → ([X → T l] × N × N), where f (sid) = (σ, i, p) is the local state of session sid. The function σ is a partial instantiation of the variables occurring in role Π(i) and p ∈ N is the control point of the program. Three transitions are allowed.
corrupt(a ,...,a )
−−−−−−−−−−−→ (SId, f, ∪1≤j≤lkn(aj) ∪ H). The adversary corrupts
parties by outputting a set of identities. He receives in return the secret keys corresponding to the identities. It happens only once at the beginning of the execution. We focus on static corruption because the soundness result using explicit labels in [4] only considers this kind of corruption. However, in our formal context, our reduction result should be easily extended to the case of adaptive corruption (when agents are corrupted at any time during the execution) since we can map traces with dynamic corruption to traces where all corrupted agents are so at the beginning.

The adversary can initiate new sessions: (SId, f,H) new(i,a1 ,...,ak )
(SId',f ',H')

where H', f ' and SId' are defined as follows. Let s = |SId| + 1, be the session identifier of the new session, where |SId| denotes the cardinality of SId. H' is defined by H' = H and SId' = SId ∪ {(s, i, (a1,... , ak))}. The function f ' is defined as follows.
· f '(sid)= f (sid) for every sid ∈ SId.



S ▶l m m ∈ S

S ▶l m1	S ▶l m2
S ▶l b, ek(b), vk(b) b ∈ X.a

S ▶l ⟨m1 , m2⟩
Initial knowledge

Pairing and un-

S ▶l ⟨m1
, m2⟩
S ▶l mi
i ∈ {1, 2}
pairing



S ▶l ek(b)	S ▶l m
adv(i)
i ∈ N
l	l
ek(b)
S ▶l dk(b)
Encryption and

l
ek(b)
S ▶l sk(b)	S ▶l m
S ▶l m
S ▶l [m]l
decryption

l	adv(i) sk(b)
i ∈ N
sk(b)

S ▶l m
Signature

Fig. 1. Deduction rules.

· f '(s, i, (a1,... , ak)) = (σ, i, 1) where σ is a partial function σ : X → T l and:
⎧⎨ σ(Aj)	= aj	1 ≤ j ≤ k
⎩ σ(Xj ) = n(ai, j, s)	j ∈ N
We recall that the principal executing the role Π(i) is represented by Ai thus, in

that role, every variable of the form Xj
i
represents a nonce generated by Ai.

send(sid,m)
The adversary can send messages: (SId, f,H) −−−−−−−→
(SId,f ',H') where sid ∈

SId, m ∈ T l, H', and f ' are defined as follows. We define f '(sid') = f (sid') for
every sid' /= sid. We denote Π(j) = ((lj, rj),... , (lj , rj )). f (sid) = (σ, j, p) for

1  1
some σ, j, p. There are two cases.
kj	kj

Either there exists a most general unifier θ of m and ljσ. Then f '(sid) =
(σ ∪ θ, j, p + 1) and H' = H ∪ {rjσθ}.
Or we define f '(sid)= f (sid) and H' = H (the state remains unchanged).
If we denote by SID = N × N × IDk the set of all sessions ids, the set of symbolic exe-

cution traces is SymbTrl = (SID×(SID → ([X → T l]×N×N))×
2T l
)∗. The set of corre-

sponding unlabeled symbolic execution traces is denoted by SymbTr. The mapping function · is extended as follows: if tr = (SId0, f0, H0), ... , (SIdn, fn, Hn) isa trace of SymbTrl, tr = (SId0, f0, H0),... , (SIdn, fn, Hn) ∈ SymbTr where SIdi simply equal SIdi and fi : SID→ ([X → T ]×N×N)) with fi(sid)= (σ, i, p) if fi(sid)= (σ, i, p) and σ(X)= σ(X).
The adversary intercepts messages between honest participants and computes new messages using the deduction relation ▶l defined in Figure 1. Intuitively, S ▶l m means that the adversary is able to compute the message m from the set of messages
S. All deduction rules are rather standard with the exception of the last one: The last rule states that the adversary can recover the corresponding message out of a given signature. This rule reflects capabilities that do not contradict the standard computational security definition of digital signatures, may potentially be available

to computational adversaries and are important for the soundness result of [4].
Next, we sketch the execution model for unlabeled protocols. As above, the execution is based on a deduction relation ▶ that captures adversarial capabilities. The deduction rules that define ▶ are obtained from those of ▶l (Figure 1) as follows. The sets of rules Initial knowledge and Pairing and unpairing in are kept unchanged (replacing ▶l by ▶, of course). For encryption and signatures we suppress the labels adv(i) and l in the encryption function { } and the signature function [ ] for rules Encryption and decryption and rules Signature. That is, the rules for encryption are:

S ▶ ek(b)	S ▶ m

S ▶ {m}ek(b)
and those for signatures are:
S ▶ {m}ek(b)	S ▶ dk(b)

S ▶ m



S ▶ sk(b)	S ▶ m S ▶ [m]sk(b)
S ▶ [m]sk(b)


S ▶ m

We use the deduction relations to characterize the set of valid execution traces. We say that the trace (SId1, f1, H1),... , (SIdn, fn, Hn) is valid if the messages sent by the adversary can be computed by Dolev-Yao operations. More precisely, we
send(s,m)
require that in a valid trace whenever (SIdi, fi, Hi) −−−−−−→ (SIdi+1, fi+1, Hi+1),
we have Hi ▶l m. Given a protocol Π, the set of valid symbolic execution traces is denoted by Exec(Π). The set Exec(Π) of execution traces in the model without labels is defined similarly. We thus require that every sent message m' satisfies Hi ▶ m'.
Example 2.3 Playing with the Needham-Schroeder-Lowe protocol described in Example 2.2, an adversary can corrupt an agent a3, start a new session for the

second role with players a1, a2 and send the message {n(a3, 1, 1), a1}adv(1)
to the

player of the second role. The corresponding valid trace execution is:

corrupt(a3)	new(2,a1,a2)
(∅, f1, ∅) −−−−−−−−→ (∅, f1, kn(a3)) −−−−−−−−→
send(sid1,{n3,a1}adv(1) )

({sid },f , kn(a ))
ek(a2 )

1	2	3
−−−−−−−−−−−−−−−→
 {sid1}, f3, kn(a3) ∪ {{n3, n2, a2}ag(1) } ,


where sid1 = (1, 2, (a1, a2)), n2 = n(a2, 1, 1), n3 = n(a3, 1, 1), and f2, f3 are defined as follows: f2(sid1)= (σ1, 2, 1), f3(sid1)= (σ2, 2, 2) where σ1(A1)= a1, σ1(A2)= a2,

σ1(X1
)= n2, and σ2 extends σ1 by σ2(X1
)= n3 and σ2(L1)= adv(1).

Relating the labeled and unlabeled execution models
The following lemma (which can be easily proved by structural induction) states that, whenever a message is deducible, the corresponding unlabeled message is also deducible.



Lemma 2.4  S ▶l m ⇒ S ▶ m
Based on the above property we show that whenever a trace corresponds to an execution of a protocol, the corresponding unlabeled trace corresponds also to an execution of the corresponding unlabeled protocol.
Lemma 2.5  tr ∈ Exec(Π) ⇒ tr ∈ Exec(Π).
Proof  The key argument is that only pattern matching is performed in protocols and when a term with labels matches some pattern, the unlabeled term matches the corresponding unlabeled pattern. The proof is done by induction on the length of the trace. Full details are provided in Appendix A.	 


A logic for security properties
In this section we define a logic for specifying security properties. We then show that the logic is quite expressive and, in particular, it can be used to specify rather standard secrecy and authenticity properties.

Preliminary deﬁnitions
We define the set of local states LSi,p(tr) of a trace tr for role i at step p by
LSi,p((SIdk, fk, Hk)1≤k≤n)= {(σ, i, p) | ∃s ∈ SIdk, s.t. fk(s)= (σ, i, p), 1 ≤ k ≤ n}.

We assume an infinite set Sub of meta-variables for substitutions. Our logic contains tests between terms with variables substituted by variable substitutions.

More formally, let T l
be the algebra defined by:


L	::= ς(xl) | ag(i) | adv(j)

l
Sub
::= ς(x) | a | ek(a) | dk(a) | sk(a) | vk(a) | n(a, j, s)

| ⟨T l
,T l
⟩ | {T l	}L
| [T l	]L

Sub
Sub
Sub ek(a)
Sub sk(a)

where xl ∈ X.l, ς ∈ Sub, i, j ∈ N, x ∈ X, a ∈ ID. The unlabeled algebra TSub is defined accordingly. The mapping function between the two algebras is defined by:

ς(x)= ς(x), {k}l
= {k}m, [k]l
= [k]m, f (t1,... , tn)= f (t1,... , tn) otherwise.


Security Logic
In this section we describe a logic for security properties. Besides standard propo- sitional connectors, the logic has a predicate to specify honest agents, equality tests between terms, and existential and universal quantifiers over the local states of agents.



[[NC(tr, t)]] = ⎪⎨
⎪
rupt action,  i.e.	tr	=	e1, e2, ..., en  and
∀a ,... , a , s.t. e  corrupt(a1 ,...,ak ) e ,t /= a ,



[[∀LSi,p(tr).ς F (tr)]] =
⎩ 0 otherwise
1 if ∀(θ, i, p) ∈ LS
[[F (tr)[θ/ς]]] = 1,
⎪⎩ 0 otherwise.



i,p


(tr), we have


[[∃LS


i,p
(tr).ς F (tr)]] = ⎧⎨ 1 if ∃(θ, i, p) ∈ LSi,p(tr), s.t. [F (tr)[θ/ς]]] = 1,
⎩ 0 otherwise.
Fig. 2. Interpretation.





Definition 3.1  The formulas of the logic Ll
are defined by induction as follows:


F (tr) ::= NC(tr, t1) | (t1 = t2) | ¬F (tr) | F (tr) ∧ F (tr) | F (tr) ∨ F (tr)
| ∀LSi,p(tr).ς F (tr) | ∃LSi,p(tr).ς F (tr)
where tr is a parameter of the formula, i, p ∈ N, ς ∈ Sub, t1 and t2 are terms of

l
Sub
. Note that formulas are parametrized by a trace tr. As usual, we may use

φ1 → φ2 as a shortcut for ¬φ1 ∨ φ2.
We similarly define the corresponding unlabeled logic L1: the tests (t1 = t2) are between unlabeled terms t1, t2 over Tsub. The mapping function · is extended as ex- pected. In particular NC(tr, t)= NC(tr, t), (t1 = t2)= (t1 = t2), ∀LSi,p(tr).ς F (tr)
= ∀LSi,p(tr).ς F (tr) and ∃LSi,p(tr).ς F (tr)= ∃LSi,p(tr).ς F (tr).
Here the predicate NC(tr, t) of arity 2 is used to specify non corrupted agents. The quantifications ∀LSi,p(tr).ς and ∃LSi,p(tr).ς are over local states of agent i at step p in trace tr. The semantics of our logic is defined for closed formula as follows: standard propositional connectors and negation are interpreted as usual. Equality is syntactic equality. The interpretation of quantifiers and the predicate NC is shown in Figure 2.
Next we define when a protocol Π satisfies a formula φ ∈ Ll . The definition for the unlabeled execution model is obtained straightforwardly. Informally, a protocol Π satisfies φ(tr) if φ(tr) is true for all traces of Π. Formally:
Definition 3.2  Let φ(tr) be a formula and Π be a protocol. We say that Π satisfies security property φ, and write Π |= φ if for any trace tr ∈ Exec(Π), [φ(tr)]] = 1.
Abusing notation, we occasionally write φ for the set {tr | [[φ(tr)]] = 1}. Then, Π |= φ precisely when Exec(Π) ⊆ φ.

Examples of security properties
In this section we exemplify the use of the logic by specifying secrecy and authen- ticity properties.
A secrecy property
Let Π(1) and Π(2) be the sender’s and receiver’s role of a two-party protocol. To specify our secrecy property we use a standard encoding. Namely, we add a third

role to the protocol, Π(3) = (X1
3
, stop), which can be seen as some sort of witness.

Informally, the definition of the secrecy property Ps states that, for two non
corrupted agents a1 and a2, where a1 plays role Π(1) and a2 plays role Π(2), a third

agent playing role Π(3) cannot gain any knowledge on nonce X1
1
sent by role Π(1)

(played by A1), when A1 is honest and is talking with an honest agent A2.
φs(tr)= ∀LS1,1(tr).ς ∀LS3,2(tr).ς'

[NC(tr, ς(A1)) ∧ NC(tr, ς(A2)) → ¬(ς'(X1
)= ς(X1
))]

An authentication property
Consider a two role protocol, such that role 1 finishes its execution after n steps and role 2 finishes its execution after p steps. For this kind of protocols we give a variant of the week agreement property [9]. Informally, this property states that whenever an instantiation of role 2 finishes, there exists an instantiation of role 1 that has finished and they agree on some value for some variable and they have
indeed talked to each other. In our example we choose this variable to be X1 .
1
Note that we capture that some agent has finished its execution by quantifying
appropriately over the local states of that agent. More precisely, we quantify only over the states where it indeed has finished its execution.
φa(tr)= ∀LS2,p(tr).ς ∃LS1,n(tr).ς' [NC(tr, ς(A1)) ∧ NC(tr, ς'(A2)) →

(ς(X1
)= ς'(X1
)) ∧ (ς(A2)= ς'(A2)) ∧ (ς(A1)= ς'(A1))]

Notice that although in its current version our logic is not powerful enough to specify stronger versions of agreement (like injective or bijective agreement), it could be appropriately extended to deal with this more complex forms of authentication.

Main Result

Recall that our goal is to prove that Π |= φ ⇒ Π |= φ. However, as explained in the introduction this property does not hold in general. The following example sheds some light on the reasons that cause the desired implication to fail.
Example 4.1  Consider the first step of some protocol where A sends a message to B where some part is intended for some third agent.
A → B : {Na, {Na}ek(C), {Na}ek(C)}ek(B)

The specification of the roles of A and B that corresponds to this first step is as

follows (in the definition below C1
2
and C2
2
are variables of sort ciphertext).



Π(1) = (init, {⟨X1
1
, ⟨{X1
1
ag(1)
ek(A3)
, {X1
1
ag(2)
ek(A3)
ag(3)
ek(A2)

Π(2) = ({⟨X1
1
, ⟨C1
2
,C2
2
L
ek(A2)
, stop)

We assume that A generates twice the message {Na}ek(C). Notice that we stop the execution of B after it receives the first message since this is sufficient for our purpose, but its execution might be continued to form a more realistic example.
Consider the security property φ1 that states that if A and B agree on the nonce
1 then B should have received twice the same ciphertext.
1
φ1(tr)= ∀LS1,2(tr).ς ∀LS2,2(tr).ς'
NC(tr, ς(A1)) ∧ NC(tr, ς(A2))∧

(ς(X1
)= ς'(X1
)) → (ς'(C1
)= ς'(C2 ))

This property clearly does not hold for any normal execution of the labeled protocol since A always sends ciphertexts with distinct labels. Thus Π /|= φ1.
On the other hand, one can show that we have Π |= φ1 in the unlabeled execution model. Intuitively, this holds because if A and B are honest agents and agree on
1 , then the message received by B has been emitted by A and thus should contain
1
identical ciphertexts (after having removed their labels).
Logic Ll
The counterexample above relies on the fact that two ciphertexts that are equal in the model without labels may have been derived from distinct ciphertexts in the model with labels. Hence, it may be the case that although t1 /= t2 ⇒ t1 /= t2, the contra-positive implication t1 = t2 ⇒ t1 = t2 does not hold, which in turn entails that formulas that contain equality tests between ciphertexts may be true in the model without labels, but false in the model with labels. In this section we identify

a fragment of Ll , which we call Ll
where such tests are prohibited. Formally, we

1	2
avoid equality tests between arbitrary terms by forbidding arbitrary negation over
formulas and allowing equality tests only between simple terms.
Definition 4.2  A term t is said simple if t = ς(x) where x ∈ X.a∪X.n and ς ∈ Sub, or t = a for some a ∈ ID or t = n(a, j, s) for some a ∈ ID, j, s ∈ N.
An important observation is that for any simple term t it holds that t = t.

Definition 4.3  The formulas of the logic Ll
are defined as follows:


F (tr) ::= NC(tr, t1) | ¬NC(tr, t1) | F (tr) ∧ F (tr) | F (tr) ∨ F (tr) | (t1 /= t2)
| (u1 = u2) | ∀LSi,p(tr).ς F (tr) | ∃LSi,p(tr).ς F (tr),

where tr ∈ SymbTr is a parameter, i, p ∈ N, t1, t2 ∈ T l
and u1, u2 are simple

terms.
Since simple terms also belong to T l

, both equality and inequality tests are

allowed between simple terms.
The corresponding unlabeled logic L2 is defined as expected. Note that Ll

⊂ Ll

and L2 ⊂ L1.
Theorem
Informally, our main theorem says that to verify if a protocol satisfies some security formula φ in logic Ll , it is sufficient to verify that the unlabeled version of the
protocol satisfies φ.

Theorem 4.4  Let Π be a protocol and φ ∈ Ll , then Π |= φ ⇒ Π |= φ.
	
Proof  Assume Π |= φ. We have to show that for any trace tr ∈ Exec(Π), [[φ(tr)]] = 1. From Lemma 2.5 it follows that tr ∈ Exec(Π), thus [φ(tr)]] = 1, since Π |= φ. Thus, it is sufficient to show that [φ(tr)]] = 1 ⇒ [[φ(tr) ] = 1. The following lemma offers the desired property.	 

Lemma 4.5  Let φ(tr) ∈ Ll
for some tr ∈ SymbTr, [[φ(tr)]] = 1 implies [[φ(tr)]] =

1.
Proof	The proof of the lemma is by induction on the structure of φ(tr). Full details are provided in Appendix B.	 

Implementation and Experiments
The AVISPA project [2] provides a platform for automatic verification of security protocols. The platform includes a specification language called HLPSL that can be used for specifying both protocols and security properties. Protocols specified in this language can be verified with four different tools. Three of them, OFMC, ATSE, and SATMC, use symbolic models where the number of sessions that can be executed in parallel is bounded. The fourth tool, TA4SP, provides verification abilities for an unbounded number of sessions. The tools can be used to verify three security properties: secrecy, weak authentication, and replay protection.
Based on the results of [4] and this paper, we implemented a module for the AVISPA with the purpose of obtaining computationally sound security guarantees. The module works as follows. First, the module verifies that the protocol (speci- fied in HLPSL) can be translated in our formalism. In particular, it verifies that the protocol uses only asymmetric encryption in its pure form (that is: we do not consider protocols that model digital signatures via decryption-with-the-private key approach.) Notice that although we forbid protocols that encrypt messages using symmetric keys, such keys can still be sent around. Next, the module checks whether the security property that is verified can be translated in our L2 logic. In partic- ular, weak authentication should only be done on atomic messages like agents and


Fig. 3. Summary of our experiments.
nonces. Finally, if the verification succeeds the logical formula that states the secu- rity property is printed out, together with a messages that states that the protocol satisfies the security property computationally.
We executed the module on the protocols in the library of the AVISPA plat- form. The results are summarized in Figure 3. Of the 13 public-key encryption based protocols in the library of the AVISPA platform the tool concludes that 9 are symbolically secure, and all 9 pass our syntactic validation tests. We conclude that all these 9 protocols are computationally secure.
The new module will be included in the next version of the AVISPA tool.

Discussion
We conclude with a brief discussion of two interesting aspects of our result. First, as mentioned in the introduction our main theorem should hold for all execution models for which the underlying deduction systems satisfy the condition in Lemma 2.4, that is S ▶l m ⇒ S ▶ m. For example, it should hold for the deduction systems obtained after removing the rule
l	l
sk(b)
S ▶l m
and its corresponding unlabeled variant. In fact, an interesting result would be to prove a more abstract and modular version of our theorem.
Secondly, one may ask if the converse of our main theorem holds. We argue that this is not the case. More precisely, we show that there exists a protocol Π and a property φ such that Π |= φ but Π /|= φ. Let Π be the protocol defined in Example 4.1. Consider a security property φ2 that states on the contrary that

whenever A and B agree on the nonce X1
1
then B should have received two distinct

ciphertexts. Formally:
φ2(tr)= 6L£1,2(tr).ς 6L£2,2(tr).ς'
NC(tr, ς(A1)) Λ NC(tr, ς(A2))Λ

(ς(X1
)= ς'(X1
)) → (ς'(C1
) /= ς'(C2 ))



where C1
2
and C2
2
are variables of sort ciphertext.

This property clearly does not hold for any honest execution of the unlabeled
protocol since A always sends twice the same ciphertext, and thus Π /|= φ2. On the other hand however, one can show that this property holds for labeled protocols

since, if A and B are honest agents and agree on X1
1
, it means that the message

received by B has been emitted by A and thus contains two distinct ciphertexts.
Thus, Π |= φ2. We conclude that, in general, Π |= φ does not imply Π |= φ.

References
Abadi, M. and Ju¨rjens, J. (2001). Formal eavesdropping and its computational interpretation. In Proc. of Theoretical Aspects of Computer Software (TACS 2001), volume 2215 of LNCS, pages 82–94. Springer- Verlag.
Armando, A., Basin, D., Boichut, Y., Chevalier, Y., Compagna, L., Cuellar, J., Hankes Drielsma, P., H´eam, P.-C., Kouchnarenko, O., Mantovani, J., M¨odersheim, S., von Oheimb, D., Rusinowitch, M., Santiago, J., Turuani, M., Vigan`o, L., and Vigneron, L. (2005). The AVISPA Tool for the automated validation of internet security protocols and applications. In 17th International Conference on Computer Aided Verification, CAV’2005, volume 3576 of LNCS, pages 281–285. Springer.
Blanchet, B. (2001). An efficient cryptographic protocol verifier based on prolog rules. In Proc. of the 14th Computer Security Foundations Workshop (CSFW’01).
Cortier, V. and Warinschi, B. (2005). Computationally Sound, Automated Proofs for Security Protocols. In Proc. 14th European Symposium on Programming (ESOP’05), volume 3444 of Lecture Notes in Computer Science, pages 157–171. Springer.
Goldwasser, S. and Micali, S. (1984). Probabilistic encryption. J. of Computer and System Sciences, 28:270–299.
Herzog, J. C. (2004). Computational Soundness for Standard Asumptions of Formal Cryptography. PhD thesis, Massachusetts Institute of Technology.
Lowe, G. (1996). Breaking and fixing the Needham-Schroeder public-key protocol using FDR. In Proc. of Tools and algoritms for the construction and analysis fof systems (TACAS’96), volume 1055 of LNCS, pages 147–166. Springer-Verlag.
Lowe, G. (1997a). Casper: A compiler for the analysis of security protocols. In Proc. of 10th Computer Security Foundations Workshop (CSFW’97). IEEE Computer Society Press.
Lowe, G. (1997b). A hierarchy of authentication specifications. In Proc. of the 10th Computer Security Foundations Workshop (CSFW’97). IEEE Computer Society Press.
Lowe, G. (2004). Analysing protocols subject to guessing attacks. Journal of Computer Security, 12(1).
Micciancio, D. and Warinschi, B. (2004). Soundness of formal encryption in the presence of active adversaries. In Theory of Cryptography Conference (TCC 2004), pages 133–151. Springer-Verlag.
Rusinowitch, M. and Turuani, M. (2001). Protocol insecurity with finite number of sessions is NP- complete. In Proc. of the 14th Computer Security Foundations Workshop (CSFW’01), pages 174–190. IEEE Computer Society Press.
Song, D. X. (1999). Athena: A new efficient automatic checker for security protocol analysis. In Proc. of the 12th Computer Security Foundations Workshop (CSFW’99). IEEE Computer Society Press.

Proof of Lemma 2.5
Lemma 2.5 tr ∈ Exec(Π) ⇒ tr ∈ Exec(Π).
Proof  The key argument is that only pattern matching is performed in protocols and when a term with labels matches some pattern, the unlabeled term matches the corresponding unlabeled pattern.
Let tr = (SId0, f0, H0), where SId0 and H0 are empty sets. We have H0 = H0. f0
is defined nowhere, and so is f0. Clearly, tr = (SId0, f0, H0) is in Exec(Π).
Let tr ∈ Exec(Π), tr = e0, ..., en = (SId0, f0, H0), ..., (SIdn, fn, Hn), such that tr ∈ Exec(Π). We have to show that if tr' = tr, (SIdn+1, fn+1, Hn+1) ∈ Exec(Π), then we have tr' ∈ Exec(Π). There are three possible operations.
corrupt(a1, ..., ak). It means that tr = (SId0, f0, H0), (SId1, f1, H1). In this case, we have SId1 = SId0 = ∅, f1 = f0 and H1 = H0 ∪ 1≤i≤k kn(ai). We can conclude that tr = (SId0, f0, H0), (SId1, f1, H1) is in Exec(Π), because there are no labels in H1 and f1 is still not defined.

new(i, a1, ..., ak). No labels are involved in this operation. The extension made to fn is the same as is made to fn. Neither Hn nor Hn are modified. tr' = tr, (SIdn+1, fn+1, Hn+1) is a valid trace.
send(s, m).
First, we have to be sure that if m can be deduced from Hn, then m can be deduced from Hn. This is Lemma 2.4.
Note that SIdn = SIdn+1 thus SIdn = SIdn+1. Let fn(s) = (σ, i, p) and Π(i)= (..., (lp, rp), ...). We have two cases.
Either there is a substitution θ with m = lpσθ. Then fn+1(s)= (σ ∪ θ, i, p + 1). Thus fn(s)= (σ, i, p) and fn+1(s)= (σ ∪ θ, i, p + 1). By induction hypothesis, tr is a valid trace. From m = lpσθ follows m = lpσθ. We conclude that tr, (SIdn+1, fn+1, Hn+1)= tr' is a valid trace, thus a member of Exec(Π).
Or no substitution θ with m = lpσθ exists. Then tr' = e0, ..., en, en+1 with en = en+1. We must show that it is always possible to construct a message m' ∈ T , such that there exists no substitution θ' with m' = lpσθ'. Then, from the validity of tr' and tr we can deduce the validity of tr', because en = en+1.
Either there exists no substitution θ' such that m = lpσθ'. In that case, we choose m' = m.
Or let θ' be a substitution such that m = lpσθ'. Then the matching for m
fails because of labels. This can be shown by contradiction. Assume m contain

no label, i. e. m does not contain subterms of the form {t}l
i
sk(ai),

t ∈ T . In that case, we have m = m by definition. From m = lpσθ', we deduce that m = lpσθ', contradiction.
We deduce that m contains some subterm of the form {t}ek(ai) or [t]sk(ai). The fact m = lpσθ' implies that lp has to contain one of the following subterms:
{t'}ek(A ), [t']sk(A ) with t' ∈ T or, a variable of sort ciphertext or signature.
i	i
Then, we choose m' = a for some agent identity a ∈ X.a. The term a is de-
ducible from Hn. Now, the matching of m' with lp always fails, either because of the encryption or signature occurring in lp or because of type mismatch for a variable of type ciphertext or signature in lp.	 


Proof of Lemma 4.5


Lemma 4.5 Let φ(tr) ∈ Ll
for some tr ∈ SymbTr, [[φ(tr)]] implies [[φ(tr)]].

Proof
φ(tr)= NC(tr, t) or φ(tr)= ¬NC(tr, t). [NC(tr, t)]] = 1, if and only if t ∈ ID and t does not occur in a corrupt event for the trace tr. This is equivalent to t ∈ ID and t does not occur in a corrupt event for the trace tr. Thus [NC(tr, t)]] = 1 if and only if [NC(tr, t)]] = [NC(tr, t)]] = 1.

φ(tr)= (t1 /= t2). We have that φ(tr)= (t1 /= t2) holds. Assume by contradiction that φ(tr) does not hold, i.e t1 = t2. This implies t1 = t2, contradiction.
φ(tr) = (u1 = u2) with u1, u2 simple terms. We have that φ(tr) = (u1 = u2)

holds. Since u1 and u2 are simple terms, we have ui = ui, thus u1 = u2. We conclude that φ(tr) holds.
The cases φ(tr)= φ1(tr) ∨ φ2(tr) and φ(tr)= φ1(tr) Λ φ2(tr) are straightforward.

φ(tr) = 6L£i,p(tr).ς F (tr). If φ(tr) holds, this means that for all (θ, i, p) ∈ L£i,p(tr), [F (tr)[θ/ς]]] = 1.
Let (θ', i, p) ∈ L£i,p(tr). We consider [F (tr)[θ'/ς]]]. Since tr ∈ Exec(Π) implies tr ∈ Exec(Π) (Lemma 2.5), we have (θ', i, p) ∈ L£i,p(tr). By induction hypothesis, [[F (tr)[θ'/ς]]] = 1 implies that [F (tr)[θ'/ς]]] = 1. It follows that
6(θ', i, p) ∈ L£i,p(tr) [[F (tr)[θ'/ς]]] = 1.
Thus, φ(tr) holds.

φ(tr)= ∃L£i,p(tr).ς F (tr). If φ(tr) holds, this means that there exists (θ, i, p) ∈ L£i,p(tr), such that [F (tr)[θ/ς]]] = 1.
By definition of the mapping function, there exists (θ', i, p) ∈ L£i,p(tr) such that θ' = θ. By induction hypothesis, [F (tr)[θ'/ς]]] = 1. Thus there exists θ', such that [F (tr)[θ'/ς]]] = 1. Thus, φ(tr) holds.	 
