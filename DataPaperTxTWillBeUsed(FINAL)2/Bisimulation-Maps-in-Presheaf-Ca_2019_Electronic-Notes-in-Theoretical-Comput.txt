Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 347 (2019) 5–24
www.elsevier.com/locate/entcs
Bisimulation Maps in Presheaf Categories
Harsh Beohar1
Universit¨at Duisburg-Essen Duisburg, Germany
Sebastian Ku¨pper2
FernUniversit¨at in Hagen Hagen, Germany

Abstract
The category of presheaves on a (small) category is a suitable semantic universe to study behaviour of various dynamical systems. In particular, presheaves can be used to record the executions of a system and their morphisms correspond to simulation maps for various kinds of state-based systems. In this paper, we introduce a notion of bisimulation maps between presheaves (or executions) to capture well known behavioural equivalences in an abstract way. We demonstrate the versatility of this framework by working out the characterisations for standard bisimulation, ∀-fair bisimulation, and branching bisimulation.
Keywords: Presheaves, ∀-fair bisimulation, Branching bisimulation.


Introduction
The importance of formal semantics should not be underestimated, especially when aimning to design reliable dynamical systems in heterogeneous environments. There- fore, a variety of state based modelling frameworks at different levels of abstraction have been proposed; to quote Goguen [16]: one person’s syntax is another person’s semantics. Diversity in algorithms can be desirable; however, as argued in [1,16,34], the proliferation of semantic theories indicates our scattered understanding of con- current systems. Thus, we seek a framework that provides semantic structure de- scribing the behaviour of a dynamical system and its refinement independently of syntax.
This goal is shared to an extent by the theory of coalgebras [29]. In [6], we abandoned state-based modelling in favour of describing behaviour as the set of

1 Email: harsh.beohar@uni-due.de
2 Email: sebastian.kuepper@feu.de

https://doi.org/10.1016/j.entcs.2019.09.002
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

executions (inspired by [10, 28]) because the branching structure of a state in the presence of invisible actions is described by the set of executions (not states). This situation further escalates when one is interested in infinite executions (e.g. fairness properties [17, 25]) or dense executions which are omnipresent in hybrid systems (e.g. [12]). The point is not that executions are inexpressible in a coalgebra, but rather that we need a semantic framework where they are treated as first-class citizens just as states are in a coalgebraic framework. Thus, our hypothesis is that behaviour of a system is given solely by its executions.
We anticipate presheaves to be the “right” semantic structure to study execu- tions without fixing a kind of dynamical system. Note that we are not the first in proposing presheaves as the mathematical universe to studying behaviour. Winskel and his colleagues [8, 15, 19, 23, 34] have already employed presheaves (among other things) by giving a denotational semantics of process-algebraic terms supported by characterisations of strong bisimulation and weak bisimulation relations us- ing open maps in the context of transition systems. For a more modern treat- ment, Hirschowitz and his colleagues [13, 14, 20] advocated game semantics using (pre)sheaves.
The novelty of our work lies in refining the notion of open maps (which we christened bisimulation maps) in a presheaf category and using it to characterise
∀-fair bisimulation [18, 24] and branching bisimulation [33] relations. In addition, the prospect of having to specify notions of time and observation (which was absent in the earlier works on presheaf semantics) leads to a clearer modelling, so explicitly highlighting these two dimensions of system modelling is at the core of our contri- bution (cf. Section 2). This distinction was in turn essential to capture branching bisimulation in the presence of invisible actions τ .
Interestingly, unlike open maps, bisimulation maps are always retracts in the category of presheaves (in turn, they are surjective at the level of executions). As a slogan, presheaf maps are refinement maps, while bisimulation maps (which are special presheaf maps) are complete refinement maps (Section 3). By moving to a finer notion, we are still able to capture functional bisimulations without fairness. However, in the context of fairness, we can show (Theorem 4.7) that the behavioural equivalence induced by a bisimulation map coincides with ∀-fair bisimulation rela- tion. Note that our ∀-fair bisimulations are equivalence relations by definition in contrast to the existing definition [18, 24] (see the dicussion after Theorem 4.7 on Page 10). This is an improvement with respect to the previous characterisation of
∃-fair bisimulation [18, 24] (called extended bisimulation in [17]) obtained by Hilde- brandt [19] using open maps, since any ∀-fair bisimulation relation is strictly finer than an ∃-fair bisimulation relation [18] and our correspondence does not impose any restrictions on the fairness predicates. These restrictions, originally from [17], asserted that fairness predicates on infinite executions are closed under the removal and the addition of finite prefixes.
Another practical aspect of the theory of presheaves is that it guides us in finding the right semantic categories once a notion of time and observation is fixed. Moreover, we can apply concepts (like, e.g., essential geometric morphism [27]) that

transform a dynamical system from one observation space O to another space Oj. This way we can transform (see Section 5) a presheaf of executions (induced by a given transition system) into a presheaf of minimal executions (i.e., executions in which trailing τ -transitions are chopped off). This property is specific to branching bisimulation, which may be the reason why this construction was not discussed in [15] (their objective was to capture weak bisimulation).

Organisation of the paper.
In Section 2, we introduce our mathematical framework to model behaviour of a dynamical system with a special focus on the aspects of time and observation. Then, we introduce the notion of bisimulation maps in presheaves on an arbitrary (small) category in Section 3. Turning our attention towards the first major example, we characterise ∀-fair bisimulation relations in Section 4. The case of invisible actions in Section 5 is based on a change of observation space. We first outline an obvious (but ultimately failed) attempt to capture branching bisimulation, before giving the correct (yet intuitive) construction that characterises branching bisimulation.

Our universe of discourse
The objective of this section is to describe our semantic framework in which one can model behaviour of a dynamical system. By behaviour of a dynamical system, we understand some phenomena that evolve over time. Our aim is to formalise this intuition. We begin by modelling time as a small category T, whose objects are points in time and arrows describe passing of time.
Notation 2.1 An object C (an arrow f) of a category C will be denoted by the predicate C ∈ C (f ∈ C). Moreover, the codomain and domain of an arrow f ∈ C are denoted as cod(f ) and dom(f ), respectively.
Invariably, dynamical systems come with a notion of observation. For instance, a letter from a fixed alphabet may denote the assignment of model variables in a computer program/controller. We assume that a system under study has a dis- play unit together with the existence of a hypothetical ‘observer’ O who is watch- ing/measuring behaviour of the system using this display unit over time. In addi- tion, our observer O can remember its observations over time, i.e., earlier observa- tions can be deduced from the later observations. Mathematically, this amounts to saying that O is a contravariant functor T  ) Set.
Proposition 2.2 Let C be a small category. Then, the collection of functors of type Cop  ) Set (i.e., presheaves on a category C) and natural transformations between them form a category PSh(C).
Notation 2.3 Given a presheaf F ∈ PSh(C), we follow [27] in writing x · f to denote the restriction of x ∈ FC along Cj  f) C, i.e., Ff (x)= x · f. In case C is a poset (viewed asa category) C, we write x· Cj to denote the restriction of x ∈ FC 

along Cj ≤ C. Note that we use calligraphic letters for speciﬁc presheaves, whereas arbitrary ones are denoted by capital letters as above.
Example 2.4 In this example, we fix the notion of time T and observation O associated with a (labelled) transition system. For time T we take the set of natural numbers N viewed as a category (arrows are the less-than-equal-to relations). For the given alphabet A, we now define a presheaf A∈ PSh(N):
A(n)= {σ ∈ A٨ | |σ| = n}	(for every n ∈ N),
together with the action on A given by σ · n = σ|n (for every σ ∈ A(nj) and n ≤ nj). In other words, A(n) is the set of those finite words σ ∈ A٨ whose length is n (denoted by |σ| = n), while the action · n simply maps a word σ of length nj to its unique prefix of length n (denoted by σ|n). Note that A(0) is a singleton set containing the empty word which we denote by ε.
Remark 2.5 In modelling some dynamical systems, like, e.g., those arising from control theory [28], O may have even more structure in that global observations can be constructed by gluing the local observations (smaller neighbourhoods). In such situations, the category of sheaves Sh(C,J) equipped with a Grothendieck topology J on C is more suitable (cf. [30]) for semantic purposes. Moreover, sheaves equipped with discrete Grothendieck topology are exactly presheaves (cf. [27]), so our math- ematical universe is actually the category of sheaves (rather than presheaves). But due to the discrete nature of dynamical systems considered in this paper, we restrict ourselves to presheaves. Nevertheless, we will state our definitions so that they are applicable on sheaves (see, e.g., Remark 3.2).
Once a notion of time T and an observation O ∈ PSh(T) is fixed, then a sys- tem essentially describes the runs (also known as trajectories or executions) of the system and the observation associated with each run. To answer both, we envisage that a dynamical system is nothing but an object in the slice category PSh(C)/O. In other words, a dynamical system corresponds to a presheaf F modelling the runs of the system and a natural transformation F α) O modelling the observation associated with each run of the system. More importantly, a system homomorphism ϕ between two systems (F, α) and (G, β), denoted (F, α) ϕ) (G, β), is a natural transformation F  ϕ) G preserving the observations, i.e., β ◦ ϕ = α. Intuitively, a system homomorphism (F, α) ϕ) (G, β) says that the system (F, α) isa reﬁne- ment of (G, β) (i.e., every observable behaviour of F is also part of the observable behaviour of G).

Reﬁning our framework by unifying time and observation
Although the slice category PSh(T)/O is close to our system theoretic intuition, its presentation can be further simplified. Recall the category of elements of a presheaf F ∈ PSh(C), denoted EC(F ) (we drop the subscript C whenever clear

from the context), has as objects the tuples (x, C) with C ∈ C,x ∈ FC and as arrows (x, C) f) (xj, Cj) the morphism C  f) Cj ∈ C such that xj · f = x.
Theorem 2.6 ([27, Exercise III.8(a)]) For a presheaf F over a small category
C, there is an equivalence of categories PSh(C)/F ∼= PSh(E(F )).
Note that a similar result also holds in the setting of sheaves (cf. [27, Exercise III.8(b)]).
In other words, time can be made inherent with observation and, thus, we can work in a simpler setting without worrying about the bookkeeping associated with slice categories. To see this, recall Example 2.4 and the poset of finite words A٨ (a.k.a. free monoid) generated by a set A, which is ordered by the prefix relation
≤ ⊆ A٨ × A٨. Notice that the categories E(A) and A٨ are isomorphic: since the length of a word is redundant in the objects of E(A) dropping the length results in the elements of A٨. Thus, we obtain
Corollary 2.7 There is an equivalence of categories PSh(N)/A ∼= PSh(A٨).
As a result, the category of presheaves on A٨ can serve as the semantic universe to study behaviour of a transition system (cf. Example 2.8). More generally, by giving the semantics to a ‘syntactic’ category of a computational model M, we mean identifying the notion of time T and observation O ∈ PSh(T) together with a

faithful functor M  J ))
PSh(ET(O)), called the semantics functor. By interpreting

an arrow M f) Mj in M as M is an implementation of Mj witnessed by f , then faithfulness of J ) asserts: if an implementation is witnessed by two semantically same morphisms Jf ) = Jg), then f = g must be the same syntactically.
Example 2.8 Consider a transition system (X, A, →) where X is the set of states, A is the set of actions, and →⊆ X × A × X is the transition relation 3 . Then the collection of transition systems together with simulation functions form a category denoted LTS. Note that a simulation function is a function X  f) Y satisfying:
a	j	a	j

∀x,x′∈X,a∈A x −→ x
=⇒ f (x) −→ f (x ).	(1)

As usual, we write x −→a
xj to denote (x, a, xj) ∈→. Let ↓ σ = {σj ∈ A٨ | σj ≤ σ}

be the prefixes of σ. Next, define a presheaf JX) ∈ PSh(A٨) which records all the executions whose trace is σ at JX)(σ):
JX)(σ)= n↓ σ	p) X |∀ ′	 σja ≤ σ =⇒ p(σj) −→a p(σja) , ,

p · σj = p↓σ′	 for any σj ≤ σ and p ∈ JX)(σ) .
Moreover, any function X	f) Y induces a family of maps Jf )


(p) = f ◦ p (for

each σ ∈ A٨).
Thus, we obtain the following result; wherein, the result that presheaf maps encode simulation maps is well known from the early work of Joyal et al. in [23].

3 Transition systems without initial states are standard in process algebraic literature (see [3]).

Proposition 2.9 The map J ) deﬁned in Example 2.8 is a faithful functor. More- over,
if Jf ) is a presheaf map for any f ∈ LTS, then f is a simulation function.
if a function f between the underlying state spaces induces a presheaf map Jf ), then f is a simulation map.
As a result, the category of transition systems LTS has presheaf semantics on A٨. In the subsequent sections, we will show the applicability of our semantic framework by giving presheaf semantics to different computational models; namely, transition systems with fairness predicates and invisible transitions.
Bisimulation maps: towards complete refinement
Consider a category of computational models M together with its semantics over a

presheaf category PSh(C), i.e., M  J ))
PSh(C). As mentioned earlier, an arrow

between any two images of the semantics functor as a refinement map from the
modelling point of view. In particular, we interpret JM ) Jf)) JM ) (induced by an
arrow M  f) Mj ∈ M) as the information that JM ) is an implementation of JMj) witnessed by the refinement map Jf ). Note that this is a straightforward generali- sation of Proposition 2.9 since simulation maps encode the refinement of behaviour in the case of labelled transition systems. Therefore, to study bisimulation maps at the level of presheaves (executions), we will restrict ourselves to those presheaf morphisms that represent ‘complete’ refinement of behaviour in the following sense. Theorem 3.3 expresses this in a more formal manner.
Every observable behaviour in JMj) is also observable in JM ) (thus, JM ) is a refinement of JMj)).
Moreover, every observable behaviour in JM ) can be retracted onto an observable behaviour in JMj).
One possibility is to use the open maps of Joyal et al. [23], which gave a unified definition of functional bisimulations over the range of computational models. In particular, when invoked in a presheaf category, open maps correspond to natu- ral transformations whose naturality squares are the weak-pullback squares in Set (see [8, Proposition 2.3]). Nevertheless, an open map falls short in capturing the complete refinement point of view since an arbitrary open map may not even be a surjective map at the level of executions; i.e., our implementation may not even implement or cover all the behaviour present in the specification.
In [5], open maps [23] were refined to embedding-open maps in the setting of concrete categories. An important difference to the classical definition of open maps is that the parametric notion of path extensions can be replaced by embeddings (see [2, Definition 8.6(2)] for a formal definition). Moreover, embedding-open maps are always retracts under some mild restrictions on concrete categories (cf. [5]). Now, if a category is concrete over itself, then an embedding corresponds to simply a monomorphism. Consequently, we propose the following definition of an embedding-

open map, which we simply call a bisimulation map.
Definition 3.1 A map F f) G ∈ PSh(C) is a bisimulation if, and only if, for every commutative square depicted in (2) witha mono P ⊂ g) Q and maps m, n in PSh(C), there is a map Q k) F ∈ PSh(C) such that the two triangles commute, i.e., k ◦ g = m and f ◦ k = n.
Q	n	) G


g

∪
P 	) F
m
(2)

Intuitively, (2) states that every extension of behaviour observable in G can be reflected as an extension observable in F through the witnesser f .
Remark 3.2 It is interesting to note that a similar definition for sheaves can be derived from the definition of embedding-open maps as given in [5]. First, note that Sh(C,J) is concrete over PSh(C) due to the forgetful functor i, which is fully faithful. Moreover, embeddings in this concrete category are actually monomor- phisms. This is because any mono is a regular mono in Sh(C,J) and the faithful functor i preserves regular monos (since i is right adjoint to the associated sheaf functor a [27]). Lastly, every regular mono is an embedding whenever the faithful functor preserves regular monos [2, Proposition 8.7.3]. Thus, we have the exact same definition of bisimulation maps in Sh(C,J).
Theorem 3.3 Every bisimulation map in a (pre)sheaf category is a retract.
We end this section by capturing functional bisimulations in terms of bisimu- lation maps whose proof can be extracted from the proof of Theorem 4.3. Note that a similar theorem was proven earlier in the seminal paper [23] for functional bisimulation; however, the difference is that we use bisimulation maps (not open maps) in our characterisation.
Theorem 3.4 Given a simulation function X f) Y , then Jf ) is a bisimulation map in PSh(A ) if, and only if, the function f is a surjection satisfying:

∀x∈X,y∈Y  f (x) −→a
y =⇒ ∃x′∈X
(x −→a
xj ∧ f (xj)= y) .	(3)

The case of fairness
When considering infinite, rather than finite, behaviour of systems, it is common to take fairness into account. There are various notions of fairness [18] but the general idea for fair (bi)simulation is to demand that fair executions are matched by fair executions, in addition to classical (bi)simulation properties. In this section, we give

a presheaf semantics to fair transition systems and outline how ∀-fair bisimulation can be captured via bisimulation maps.
Let Aω = {σ | N  σ) A} be the set of infinite words generated from A and fix A∞ = A٨ ∪ Aω, which is ordered by the prefix relation ≤. The object of study are fair transition systems (X, A, →, FairX), where (X, A, →) is a transition system and FairX is a fairness predicate on infinite executions. An inﬁnite execution is a function ↓ σ  p) X ∪ {Ω} whose domain is the history of an infinite word σ ∈ Aω
j	j	a	j
such that p(σ) = Ω and ∀σ′,a (σ a ≺ σ  =⇒  p(σ ) −→ p(σ a)). Here, Ω is the
chaos state which the system enters once it has executed an infinite execution. Let FExec(X)= FairX ∪ Exec(X) be the set of all fair executions ordered by the prefix relation ≤, i.e., p ≤ pj ⇐⇒ pj|dom(p) = p (for p, pj ∈ FExec(X)). The set of (finite) executions Exec(X) is defined as earlier, i.e., Exec(X)= {↓ σ  p) X | σ ∈
٨	j	a	j
A ∧ ∀σ′a∈↓σ p(σ ) −→ p(σ a)}.
Definition 4.1 A chaos preserving extension X ∪ {Ω} fΩ) Y ∪ {Ω} (i.e., f (x)= f (x) for x ∈ X and f (Ω) = Ω) of a function X  f) Y is a fair simulation between (X, A, →, FairX), (Y, A, →, FairY ) if, and only if, f satisfies (1) and ∀p∈FairX fΩ ◦p ∈ FairY . Henceforth, we do not distinguish between fΩ and f .
Note that an infinite, but fair, execution can be seen as the limit of a mono- tonically increasing sequence of finite executions in FExec(X). Since this limiting sequence is part of behaviour, we should reflect it. Thus, we say a fair bisimula- tion X ∪ {Ω} f) Y ∪ {Ω} is a surjective fair simulation f satisfying (3) and the following condition for any increasing sequence of finite executions (pi)i∈N in X:
. f ◦ pi ≈ f ◦ . pi.	(4)

Here, ≈ is the Kleene equality used to equate the partially defined terms above.
To the best of our knowledge, the above notion of fair bisimulation is novel; how- ever, below we will establish its connection with the literature after characterising it in terms of presheaf morphisms. So let FTS be the category of fair transition systems and fair simulation between them. In addition,
Time: Since infinite executions are allowed in a fair transition system, we take T = N ∪ {∞} to be the category of natural numbers extended by a number representing infinity (i.e., ∀n∈N n ≤ ∞).
Observation: Using the definition of A in Example 2.4, we define: O(∞) = Aω and O(n)= A(n) (for n ∈ N).
Clearly, the categories E(O) and A∞ are isomorphic and by applying Theorem 2.6 we obtain PSh(E(O)) ∼= PSh(A∞). So, we take the category PSh(A∞) as the semantic universe to study fair transition systems. Just as in Example 2.8, for a given fair transition system (X, A, →, FairX), we define a presheaf
JX)(σ)= {p ∈ FExec(X) | max dom(p)= σ}	(for each σ ∈ A∞),

and the action is given by restricting the domain of an execution. Moreover, for any fair simulation function f , we let Jf )σ = f ◦ (for each σ ∈ A∞); thus, resulting in a presheaf semantics to fair transition systems.

Proposition 4.2 The above map FTS  J ))
PSh(A∞) is a faithful functor.

Invoking the bisimulation map definition between any two presheaves generated by fair transition systems results in the characterisation of fair bisimulation.
Theorem 4.3 A fair simulation function f is a fair bisimulation if, and only if, the underlying map Jf ) is a bisimulation map in PSh(A∞).
Remark 4.4. It should be noted that fair bisimulation maps are stronger than the open maps studied by Hildebrandt [19] in PSh(A∞) to characterise the extended bisimulation of Hennessy and Stirling [17] for pointed systems, i.e. systems with explicitly initial states. To demonstrate this, recall that an Inf⊥-open map of Hilde- brandt [19, Proposition 25] is a fair simulation function (not necessarily surjective) X ∪ {Ω} f) Y ∪ {Ω} satisfying (3) and the property:
∀x∈X,q∈FExec(Y ) q(ε)= f (x) =⇒ ∃p∈FExec(X) (p(ε)= x ∧ f ◦ p = q) .	(5)
Consider the two systems drawn on the right with a function f between the states depicted by dashed lines.



a  x
a
y  a



In the left system, the infinite executions visiting xj infinitely often are considered fair, whereas the only infinite execution in the right system is fair. Clearly, f is a fair simulation satisfying (5). But f is not a fair bisimulation because the sequence of finite executions (pi)i∈N formed by unfolding the self-loop on x has a fair execution
i∈N f ◦ pi (looping on y) as the limit in the right system. Yet, (pi)i∈N has no limit, thus, violating (4).
Remark 4.5 In [19], (separated) presheaves with sup topology are used because an increasing sequence of finite executions induced by a fair transition system has at most one limit point. Unlike [19], we are not interested in one-to-one semantic representation of our syntactical models, so we work with arbitrary presheaves. This is because the choice whether the semantic universe should be (separated) presheaves or sheaves depends on observations, i.e., how O is modelled. This is also why we do not require our semantic functor J ) to be full.
Next, we relate fair bisimulation maps with ∀-fair bisimulation relations.
Definition 4.6 A ∀-fair bisimulation on (X, A, →, FairX) is an equivalence relation
R⊆ X × X satisfying the following transfer properties:

∀

x,y,x′,a
 (x −→a
x ∧ xRy) =⇒ ∃y′ (y −→
yj ∧ xjRyj) , and

∀p,q  (p =Y q ∧ p ∈ FairX) =⇒ q ∈ FairX .
Here, p =Y q is an abbreviation for dom(q)= dom(p) ∧ ∀σ∈dom(p)∩As p(σ)Rq(σ).
Theorem 4.7 Two states x and xj are related by a ∀-fair bisimulation relation if, and only if, there is a fair bisimulation function f such that f (x)= f (xj).
The requirement of equivalence relations in the above definition may look super- fluous at first glance. This is because, traditionally (i.e., when fairness predicates are empty sets), a strong bisimulation relation by definition is not necessarily an equivalence relation on the set of states. Moreover, bisimilarity which is defined as the union of all strong bisimulation relations turns out to be both an equivalence relation and a strong bisimulation relation. However, such closure results do not hold in general for ∀-fair bisimulation relations. ∀-fair bisimulation relations are not closed under union and the relational composition (even if we relax Definition 4.6 by replacing ‘an equivalence relation’ for ‘a symmetric relation’) 4 . Thus, ∀-fair bisimilarity may, in general, neither be an equivalence relation nor a ∀-fair bisim- ulation; in other words, ∀-fair bisimilarity is not a coinductive definition (like how strong bisimilarity is). Nevertheless, we deemed all ∀-fair bisimulation relations to be equivalences because: first, the main use of a ∀-fair bisimulation relation is to equate two systems that have the same behaviour sensitive to fair executions; sec- ond, the mathematics tells us that the kernel of a (fair bisimulation) function is an equivalence relation.
The case of invisible actions
The behaviour of a specification and its implementation is often spread over different levels of abstraction. The standard process algebraic way to relate the behaviour of an implementation with its specification is by delineating the effect of actions in lower levels of abstraction as invisible. For instance, removing a message from a buffer is considered unobservable in a rendezvous between communicating processes. This is made formal by reinterpreting the notion of (bi)simulation functions in the presence of the invisible action τ .

Branching bisimulation
Notation 5.1 Henceforth, τ /∈ A will denote the invisible action and Aτ = A∪{τ}. Furthermore, Exec(X, σ) is the set of executions p having trace σ, i.e., max dom(p)= σ and −→ ⊆ X × A٨ × X is the weak reachability relation on (X, Aτ , →) given as the smallest relation satisfying the following conditions:


x −→τ  xj
ε	j	j ε	jj
σ	j	j a	jj

x −→ x ∧ x
ε	ε	ε
−→ x
x −→ x ∧ x
σa
−→ x
.

x −→ x
x −→ xj
x −→ xjj
x −→ xjj



4 This is how 6-fair bisimulation relations are defined in [24] on the states of Kripke structures. In regards to the above closure properties, we are only aware of [21] who showed that 6-fair simulation relations are not closed under union.

Definition 5.2 A branching simulation function f between systems (X, Aτ , →) and (Y, A , →) is a function X	f) Y satisfying the following properties:

Simulation of observable transitions, i.e., ∀x,x′∈X,a∈A x −→ xj f (xj), and
=⇒ f (x) −→a

(Possible) simulation of invisible transitions, i.e., ∀

x,x′∈X
x −→τ
xj =⇒  f (x)= 

f (xj) ∨ f (x) −→τ  f (xj) .

ε	ε

A branching bisimulation f is a branching simulation surjection f satisfying the ‘weak’ reflection of transitions, i.e., for any x ∈ X, y ∈ Y , and a ∈ Aτ we have
a	ε	j a	jj	j	jj
f (x) −→ y =⇒ ∃x′,x′′∈X (x −→ x −→ x ∧ f (x )= f (x) ∧ f (x )= y).	(7)
Definition 5.3 Given a labelled transition system (X, Aτ , →), then a symmetric relation R ⊆ X × X is a branching bisimulation [33] if, and only if, the following transfer property is satisfied

∀x ,x ,y ,a∈A
 (x1 −→a
x2 ∧ x1Ry1) =⇒

ε	a
(a = τ ∧ x Ry) ∨∃ 
  .

Two states x, xj ∈ X are branching bisimilar if there exists a branching bisimulation
R such that xRxj.
We work with branching bisimulation functions (not relations) because of the fol- lowing result (Theorem 5.4), which is similar in spirit to Lemma 2.7 proved by Caucal in [9]. The difference is that Caucal’s branching bisimulation functions (which he calls reduction in [9]) do not respect the stuttering of invisible steps
(6). Nevertheless, we are still able to obtain the following correspondence since the largest branching bisimulation relation satisfies the so-called stuttering lemma of [33]. In particular, any reduction X f) Y in the sense of Caucal can be ex- tended to a branching bisimulation function by composing it with the quotient map Y  q) Y/R, where R ⊆ Y × Y is the largest branching bisimulation relation on Y .
Theorem 5.4 Two states x, xj ∈ X of a transition system (X, Aτ , →) are branch- ing bisimilar if, and only if, there are a transition system (Y, Aτ , →) and a branching bisimulation function X  f) Y such that fx = f xj.
The setup
Our first step towards the characterisation of branching bisimulation is the presheaf representation of executions induced by a transition system with invisible actions. Since a transition system evolves in a step-based manner, it is sufficient to model the

time by the set of natural numbers N. The only difference, when compared to the strong case (cf. Example 2.4), is in the notion of observation. Instead of recording words from A٨, our hypothetical ‘observer’ now records words from A٨. So, consider a presheaf Nop Aτ) Set in the spirit of A as defined in Example 2.4. Recall that the slice category PSh(N)/Aτ is equivalent to the category of presheaves on the category of elements E(Aτ ), which is isomorphic to the category A٨. Thus, for a given transition system (X, Aτ , →), we define a presheaf FX ∈ PSh(A٨) as follows:
FX(σ)= Exec(X, σ),  (for every σ ∈ A٨).	(8) The action on FX is given by the restriction of the domain of an execution.
Incidentally, a branching simulation function X  f ) Y between (X, A , →) and (Y, Aτ , →) does not induce a system homomorphism between the underlying dynamical systems (presheaves) FX and FY because a branching simulation function does not necessarily preserve the length of the executions. For example, a sequence
of transitions • −→τ  • −→a • may get mapped to a transition • −→a  •.
Thus, we need a procedure that transforms a given presheaf on A٨ to a presheaf on A٨. It turns out that there already is a general result in category theory for this purpose, which we explain next. In particular, recall the cocompletion of a category C through the Yoneda embedding C YC) PSh(C).
Theorem 5.5 (see [27]) For any functor C	h) D, when C is small and D is
cocomplete, there is a colimit preserving functor PSh(C)	Lh) D satisfying L ◦
YC ∼= h. Moreover, Lh has a right adjoint Rh given by: RhD(C)= D(hC, D), for each C ∈ C,D ∈ D.
Using the language of Kan extensions, Lh is the left Kan extension of h along the Yoneda embedding YC. Moreover, using the notion of a coend [26], we have:
~ ∫ C∈C


where D S⊙) D is the copower functor given by S ⊙ D = 

s∈S
D (taking S

disjoint copies of D). If we replace C  h) D in the above diagram by a map
C h) D YD) PSh(D), then we obtain the so-called essential geometric mor- phism [27] between PSh(C)  ) PSh(D). In full, this means that the composi- tion functor h∗ not only has a right adjoint Πh, but also a left adjoint Σh (see, for instance, [27] for a formal definition of a geometric morphism). Below, the compo- sition functor h∗, its left adjoint Σh, and its right adjoint Πh are given by (up to isomorphism) RYDh, LYDh, and Rh∗ YD , respectively.
Corollary 5.6 (see [27]) Given a functor C h) D between small categories,

then the inverse image functor PSh(D)
h∗)


PSh(C) given by h∗G = G ◦ hop
(for

each G ∈ PSh(D)) has both left and right adjoints:
Σh E h∗ E Πh.
So, in principle, there are two ways to land in PSh(A٨) from PSh(A٨) whenever there is a functor between A٨  ) A٨. Nevertheless, since our aim is to characterise branching bisimulation functions, we will choose the left adjoint (over the right adjoint) of the composition functor for this task. This is because to reflect (recall
(7)) an observable transition – say, of the form • −→a  • –, we only need minimal
executions which are of the form • −→ • −→a  • (cf. Definition 5.9). In particular,
we will show (cf. Theorem 5.11) that the left adjoint Σh (induced by a suitable h) transforms a presheaf of executions into a presheaf of minimal executions (or those executions in which trailing τ -transitions are chopped off).
An obvious, but failed attempt

There is an evident functor A٨
h) A٨ which treats the letter τ as an empty word.

It is then natural to investigate whether the bisimulation maps in PSh(A٨) between any two induced presheaves ΣhFX , ΣhFY characterise the branching bisimulation map. Unfortunately, the answer is no! We explain this extensively, as this lays the formal foundation for the desired characterisation given in the next subsection.
So, consider the hiding function A	h) A٨ which treats τ as the unit of A٨
(i.e., h(τ )= ε) and treats an action a ∈ A as observable (i.e., h(a)= a when a ∈ A).

This lifts to an order-preserving function A٨
h) A٨ (denoted again as h by abuse

of notation). Thus, we have a functor A٨
h) A٨.

Proposition 5.7 The categories A٨, A٨ have binary products.
Remark 5.8 It is worthwhile noting that h does not generally preserve finite limits (or infimum H in this case). Consider the words aτb, ab ∈ A٨. Then, h(aτb H ab)= 
h(a)= a; however, h(aτb) H h(ab)= ab H ab = ab.
Furthermore, S⊙X ∼= S×X (for any two sets S, X) and the (co)limit in any presheaf category is computed point-wise. Thus, using these observations, we calculate ΣhF (for F ∈ PSh(A٨)) at Q ∈ A٨ as follows:


ΣhF (Q) ∼=
∫ σ∈As

F (σ) × YAs (h(σ))(Q) ∼=	lim
σ∈As op,ę≤h(σ)

F (σ).	(9)

Note that the reason for the last isomorphism is that every colimit can be encoded as a coend (see [26, p. 224–225] for a dual statement). In addition, (9) is the colimit
of A٨op	F) Set when Q = ε. Notice that A٨op is directed; thus, the colimit of the
τ	τ
filtered diagram is	ε≤h(σ) Fσ/∼, where ∼ ⊆	ε≤h(σ) F (σ) ×	ε≤h(σ) F (σ) is the
equivalence relation defined as follows:
(σ, p) ∼ (σj, pj) ⇐⇒ ∃σ′′  σjj ≤ σ ∧ σjj ≤ σj ∧ p · σjj = pj · σjj .	(10)

It turns out that from a system theoretic viewpoint, the set limε≤h(σ) FX(σ) is nothing but the set of minimal executions whose observable trace is an empty ob- servation. Theorem 5.11 states this result in full generality.
Definition 5.9 Given a transition system (X, Aτ , →) and a word Q ∈ A٨, we say an execution p has an observable trace Q if h(max dom(p)) = Q. Furthermore, MExec(X, Q) is the set of all minimal executions w.r.t. the prefix order ≤ on execu- tions whose observable trace is Q. Formally, p ≤ pj ⇐⇒ pj|dom(p) = p and
MExec(X, Q)= np | ↓ p ∩ {q ∈ Exec(X) | h(max dom(q)) = Q} = {p},.

Before we prove Theorem 5.11, we need a category theoretic result (which is probably folklore; see [26, Exercise IV.2.7] for a dual statement), namely, that the colimit of a diagram can be decomposed into the coproducts of the colimits of diagrams with smaller shapes under certain restrictions.
Lemma 5.10 Given a set J and a small category C =  j∈J Cj with injections

lim
−→Cj
F ◦ ιj.
−→C

Theorem 5.11 For a given transition system (X, Aτ , →) and Q ∈ A٨, we have
ΣhFX(Q) ∼= MExec(X, Q).
Next, we explore the action of the presheaf ΣhFX from a system theoretic view- point. Firstly, it is defined by the universal property of the colimit. Let Qj ≤ Q
and let σ be a minimal word such that h(σ) = Q. Then, there is a unique min- imal word σę′ = .{σj ≤ σ | h(σj) = Qj}. Note that this infimum exists since

the history of a word in A٨
is a finite totally ordered set of words. Therefore,

the family of arrows depicted by the dotted arrows in (11) forms a cone, where
A٨	= {σ ∈ A٨ | Q ≤ h(σ)} is a sub-forest of A٨. Thus, the universal property of
τ,ę	τ	τ
the colimit gives a map ΣhFX Q   ) ΣhFY Qj, which we denote by Σh(Q, Qj).


FX σ	)..
FX σę′
.
.
.
ΣhFX Q 	 ∼=  ) MExec(X, Q)

(11)	.
.
v	.v
Σh(Q, Qj)
v
(12)
mpast(Q, Qj)
v

lim
−→
z,q
FX ιęσ
)	lim
−→s
σ∈Az,q′
FX ιę′ σ
ΣhFX Qj 	 ∼=) MExec(X, Qj)

Secondly, for any Qj ≤ Q with Q, Qj ∈ A٨, we define a map:
mpast(ę,ę′)
MExec(X, Q)	MExec(X, Q )	given by	p '→ p|↓σq′ ,
where σ = max dom(p). Now we can establish that the isomorphism in Theo- rem 5.11 is natural in Q ∈ A٨.
Theorem 5.12 For any Q, Qj ∈ A٨ with Qj ≤ Q, the square in (12) commutes.

Now that we know what Σh does to a presheaf, we use the category PSh(A٨) as our semantic universe to handle invisible actions. Thus, for a given (X, Aτ , →),
f)
we let JX) = ΣhFX. In addition, for a branching simulation function X	Y ,
we use the isomorphic view of minimal executions and let Jf )ę(p) = pf (for each
Q ∈ A ), where pf is an execution defined inductively using the following rules.
If dom(p)= ε then dom(pf )= ε and pf (ε)= f (p(ε)).

If p −→a
pj, pf −→a
q, last(q)= f (last(pj)), and a ∈ A then pj
= q.

If p −→τ
pj and f (last(p)) = f (last(pj)) then pj
= pf .

If p −→τ
pj, f (last(p)) /= f (last(pj)), pf −→τ
q, last(q)= f (last(pj)) then pj
= q.

Here, p −→a
pj ⇐⇒ dom(pj)= dom(p)a ∧ p ≺ pj; the function last(p) returns the

last visited state by the execution p, i.e., last(p)= p(max dom(p)).
Lemma 5.13 For a given branching simulation function X	f) Y and a minimal execution p ∈ MExec(X, Q), we have pf ∈ MExec(Y, Q).
Next let LTSτ be the category of transition systems with possible invisible steps, which comprises of transition systems as objects and morphisms are the collection of identity functions and branching simulation functions. Thus, we can now give a presheaf semantics for the category LTSτ .

Theorem 5.14 The mapping LTS	J ))
PSh(A٨) is a faithful functor.

Finally, we can invoke the bisimulation maps in PSh(A٨) but the characteri- sation of branching bisimulation functions fails to hold. The mismatch is in the reflection (7) of invisible steps (not with the reflection of observable transitions), which we explain next in the following example.
Example 5.15 Consider the two transition systems and the branching simulation f depicted below with dashed lines. Note that f is not a branching bisimulation function (even though it is surjective) because it fails to reflect the transition y1 −→τ y3.

x1
a 
x2	x3
y1


y2	y3


Yet Jf ) is a bisimulation map in PSh(A٨). For this consider a given commutative square (2) in PSh(A ). The crucial case in defining the functions kę is when Q ∈
{ε, a}.
Let q ∈ Q(ε). If nε(q)= εyi then we let kε(q)= εxi (for i ∈ {1, 2, 3}).

Let q ∈ Q(a). Then, na(q) is the minimal execution witnessing y1 −→a
y2 since

there are no other minimal executions in MExec(Y, a). Thus, we let ka(q) to be
the minimal execution witnessing the transition x1 −→a  x2.

Characterisation of branching bisimulation
Unfortunately, all the information related to silent transitions is lost by transforming a presheaf using the functor Σh because all the executions with empty observations get fused into their corresponding empty (minimal) executions. In retrospect, the problem lies in our specification of observation since our hypothetical ‘observer’ O is unable to differentiate between empty observation due to no system move and empty observation due to zero or more system moves. Therefore, to model this latter observation, we introduce a constant τ¯ which can be observed anytime after
0. So for this section, we define O in the next page as follows:

O(0) = Aτ (0)	and	O(n)= Aτ (n) ∪ {τ¯}	(for every n > 0);


σ · m =
σ|m,	if σ /= τ¯ 
ε,	if m =0 ∧ σ = τ¯ 
⎪⎩τ¯,	if m > 0 ∧ σ = τ¯. 

 for any m ≤ n and σ ∈ O(n) .

Put differently, τ¯ is ‘really’ a constant observation over time except at 0. The
introduction of τ¯ is new and inspired from the constant η [4] which can be viewed as an empty observation due to at least one system move.
Proposition 5.16 The above mapping Nop  &) Set is a presheaf.
Moreover, the categories PSh(N)/O and PSh(E(O)) are equivalent (Theorem 2.6). So, consider the category of elements E(O) whose objects are tuples (n, σ) (for n ∈ N,σ ∈ O(n)) and whose arrows are given by the rule:
(n, σ) −→ (nj, σj) ⇐⇒ n ≤ nj ∧ σj · n = σ.
Just as the category E(Aτ ) has a simpler description in terms of A٨, we simplify
E(O) by defining a set A٨ = A٨ ∪ {(n, τ¯) | n > 0} ordered by the smallest relation

٨ τ τ¯
٨ τ τ¯
satisfying the following rules:

(|σ|, σ) −→ (|σj|, σj) ∈ E(Aτ )

σ ≤ σj
(m, τ¯) −→ (n, τ¯) ∈ E(O)


(m, τ¯) ≤ (n, τ¯)
n > 0
.
ε ≤ (n, τ¯)

Note that the leftmost rule is concerned with the elements of A٨. Thus, the slice

category PSh(N)/O is equivalent to the category PSh(A٨
) since E(O) ∼= A٨ .

Using the presheaf FX (cf. (8)) induced by a given transition system (X, Aτ , →),

define a presheaf F¯X ∈ PSh(A٨
) as follows:

¯	 FX(σ),	if σ ∈ A٨

τ 0 = {ε}

FX(σ)= 

n∈N
τ
FX(τ n),	otherwise
, where
τ n+1 = τ n ∪ 

n+1
.
{τ}

The executions based on invisible steps are seen stretchable in time by O, i.e., a system may perform invisible executions of length independent of time instants.

This is encoded in the second clause of F¯X . To complete the definition of F¯X as a
presheaf, we define, for any p ∈ F¯X (σ) and σj ≤ σ in A٨ , the action of F¯X as:
⎧⎪⎨p|↓σ′ ,	if σ ∈ A٨ ∧ σj ∈ A٨
⎪⎩p,	if σ /∈ A٨ ∧ σj /∈ A٨.
Notice how the above formulation closely follows the three defining clauses of O.
Proposition 5.17 The mapping F¯X deﬁned above is a contravariant functor.
To characterise branching bisimulation, define a structure A٨ similar to A٨ and

a structure preserving map A٨
	)	٨ τ¯
similar to h (Section 5.3). To this end,

our semantic category for branching bisimulation will be A٨ = A٨ ∪ {τ¯} ordered by
the relation ≤⊆ A٨ × A٨ consisting of prefix relation and the pairs (ε, τ¯), (τ¯, τ¯). We

consider A٨
τ¯
h¯)	٨
τ¯
τ¯
given by:
h¯(σ) = h(σ), if σ ∈ A٨; and h¯(n, τ¯) = τ¯ (for all

n ∈ N).
Next, we aim to compute the presheaf Σ¯F¯X at Q ∈ A٨. At this stage, we
h	τ¯
can take the advantage of similarity between the structures A٨, A٨  and A٨, A٨ to
τ	τ τ¯	τ¯
compute the colimits, similar to (9) where A٨op is replaced by A٨ op as the indexing

τ
category. In lieu of Theorems 5.11 and 5.12, we obtain
τ τ¯

Theorem 5.18 For a given transition system (X, Aτ , →), we ﬁnd that Σh¯ F¯X (τ¯) ∼= n∈N Exec(X, τ n) and Σh¯ F¯X (Q) ∼= MExec(X, Q) (for any Q /= τ¯). Moreover, the above isomorphisms are natural in Q ∈ A٨. I.e., for any Qj ≤ Q with Q, Qj ∈ A٨, the
square in (12) and the following square commute.
Σh¯ FX(τ¯) 	 ∼=  )	Exec(X, τ n)
n∈N
Σh¯ (τ¯, ε)	|ε
v	v
ΣhFX(ε) 	 ∼=   ) MExec(X, ε)
Note that the definition of the maps Σh¯ (Qj, Q) (for Qj ≤ Q) is similar to the maps Σh(Qj, Q) defined by the universal property of colimits (see (11)). Just like in the previous subsection, we utilise the isomorphic view of minimal executions to define

our semantic map LTSτ
J ))
PSh(A٨):

For a given transition system, we let JX) = Σh¯ F¯X .
For a given branching simulation function X	f) Y , we let Jf ) (p)= p .
Lemma 5.19 The above mapping J ) is a faithful functor.
Finally, we have obtained the desired result of this section.
Theorem 5.20 A branching simulation function f is a branching bisimulation function iff Jf ) is a bisimulation map in PSh(A٨).

Related work and Conclusion

The core idea of Goguen’s sheaf semantics [16] is: systems are diagrams of sheaves, behaviour (interconnection) of systems is their limit (colimit). In retro- spect, Goguen gave a sheaf semantics of nondeterministic automata by constructing presheaves on the Alexandroff topology induced by the downward closed subsets of A٨ (in contrast to presheaves over A٨). However, it is well known that the category of sheaves on Alexandroff spaces induced by a poset (X, ≤) is equivalent to the category of presheaves on X (a consequence of the so-called comparison lemma in topos theory; see [27, Corollary 3 on Page 590]). In short, we use simpler structures to represent executions and focused on defining bisimulations abstractly which were absent in [16].
Relational presheaves [31] generalise transition systems that are labelled by words from the free monoid A٨. The idea was to accommodate the earlier presheaf approaches [23, 34] with algebraic structure on labels. The most insightful observa- tion of [31] was the well-known ‘saturation’ construction on transition systems can be captured using a 2-adjunction induced by a homomorphism between A٨, A٨. Un- like [31], our left adjoint Σh records the minimal executions induced by a transition system with silent steps. We expect this to be relevant for probabilistic systems, where minimal executions are used to define a probability measure (cf. [6]).
Open maps between presheaves as defined in [23] are instances of the open maps in a topos as introduced in [22]. This is because open maps between presheaves (as in [23]) are natural transformations whose naturality square is a weak pullback in Set (cf. [22, Example 1.1]). We discarded the open maps between presheaves because they are incapable of establishing complete refinement between an implementation and its specficiation; though it is still interesting to assert whether the bisimulation maps (Def. 3.1) satisfy the axioms given in [22].
Prefix orders are generalisations of trees proposed in [10] to study executions of dynamical systems in an order theoretic manner. In [5], the authors defined functional bisimulation between prefix orders by reinterpreting the definition of open maps in concrete categories. Our bisimulation maps are an instance of this general definition (Section 3). It is unclear, though, how to enrich prefix orders with observations so that we can model labelled executions in a uniformly. This question lead us to model observations as presheaves.
To sum up, bisimulation maps between presheaves are versatile enough to cap- ture different notions of behavioural equivalence. We demonstrated this by charac- terising ∀-fair bisimulation and branching bisimulation, two notions that are notori- ously difficult to capture with a coalgebraic approach. The clear distinction between time and observation proved fruitful in dealing with silent actions, but we also ex- pect our framework to lend itself well to modelling hybrid systems. For instance, sheaves over the translation-invariant interval domain IR/D were introduced in [30] to model hybrid systems. It will be interesting to explore whether bisimulation maps between such sheaves (Remark 3.2) coincides with stateless bisimulation [7, 11, 32].

Acknowledgement
We thank the anonymous reviewers of FOSSACS’19 for their feedback on an earlier draft that greatly improved this manuscript. In particular, Reviewer 1 not only identified a mistake in our earlier characterisation of branching bisimulation, but also provided a detailed feedback including the proofs for which we are grateful. We thank Barbara K¨onig and Christina Mika for valuable comments on earlier drafts of this paper. We also thank Pieter Cuijpers for asking us about the importance of presheaf categories in system modelling, which formed the basis of Section 2. Moreover, we are grateful to Alex Simpson for discussing early ideas and in partic- ular, for guiding our attention from sheaves on Alexandroff spaces induced by the poset A٨ to just presheaves on A٨. Finally, we acknowledge Paul Taylor’s diagram package for commutative diagrams.

References
Abramsky, S., What are the fundamental structures of concurrency?: We still don’t know!, Electronic Notes in Theoretical Computer Science 162 (2006), pp. 37 – 41, essays on Algebraic Process Calculi.
Ad´amek, J., H. Herrlich and G. E. Strecker, “Abstract and Concrete Categories,” Wiley-Interscience, New York, NY, USA, 1990.
Baeten, J. C. M., T. Basten and M. A. Reniers, “Process Algebra: Equational Theories of Communicating Processes,” Cambridge Tracts in Theoretical Computer Science, Cambridge University Press, 2009.
Baeten, J. C. M. and R. J. van Glabbeek, Another look at abstraction in process algebra, in: T. Ottmann, editor, Automata, Languages and Programming (1987), pp. 84–94.
Beohar, H. and P. J. L. Cuijpers, Open maps in concrete categories and branching bisimulation for prefix orders, Electronic Notes in Theoretical Computer Science 319 (2015), pp. 51 – 66, the 31st Conference on the Mathematical Foundations of Programming Semantics (MFPS XXXI).
Beohar, H. and S. Ku¨pper, On path-based coalgebras and weak notions of bisimulation, in: F. Bonchi and B. K¨onig, editors, 7th Conference on Algebra and Coalgebra in Computer Science (CALCO 2017), Leibniz International Proceedings in Informatics (LIPIcs) 72 (2017), pp. 6:1–6:17.
Beohar, H., D. E. Nadales Agut, D. A. van Beek and P. J. L. Cuijpers, Hierarchical states in the compositional interchange format, in: Proceedings Seventh Workshop on Structural Operational Semantics, SOS, 2010, pp. 42–56.
Cattani, G. L. and G. Winskel, Profunctors, open maps and bisimulation, Mathematical Structures in Computer Science 15 (2005), p. 553–614.
Caucal, D., Branching bisimulation for context-free processes, in: R. K. Shyamasundar, editor, FSTTCS
(1992), pp. 316–327.
Cuijpers, P. J. L., Prefix orders as a general model of dynamics, in: I. Mackie, M. Ayala-Rinco´n and
E. Bonelli, editors, Proc. of Developments in Computation Models, DCM’13, Buenos Aires, Argentina, 2013, pp. 25–29.
Cuijpers, P. J. L. and M. A. Reniers, Hybrid process algebra, The Journal of Logic and Algebraic Programming 62 (2005), pp. 191 – 245.
Cuijpers, P. J. L. and M. A. Reniers, Lost in translation: Hybrid-time flows vs. real-time transitions, in:
M. Egerstedt and B. Mishra, editors, Hybrid Systems: Computation and Control (2008), pp. 116–129.
Eberhart, C. and T. Hirschowitz, What’s in a game?: A theory of game models, in: Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS ’18 (2018), pp. 374–383. URL http://doi.acm.org/10.1145/3209108.3209114


Eberhart, C., T. Hirschowitz and T. Seiller, An intensionally fully-abstract sheaf model for π (expanded version), Logical Methods in Computer Science Volume 13, Issue 4 (2017).
URL https://lmcs.episciences.org/4069

Fiore, M., G. L. Cattani and G. Winskel, Weak bisimulation and open maps, in: Proc. 14th Symposium on Logic in Computer Science, 1999, pp. 67–76.
Goguen, J. A., Sheaf semantics for concurrent interacting objects, in: Mathematical Structures in Computer Science, 1992, pp. 159–191.
Hennessy, M. C. B. and C. P. Stirling, The power of the future perfect in program logics, Information and Control 67 (1985), pp. 23 – 52.
Henzinger, T. A., O. Kupferman and S. K. Rajamani, Fair simulation, Inf. Comput. 173 (2002),
pp. 64–81.
Hildebrandt, T. T., Towards categorical models for fairness: fully abstract presheaf semantics of SCCS with finite delay, Theoretical Computer Science 294 (2003), pp. 151 – 181.
Hirschowitz, T. and D. Pous, Innocent strategies as presheaves and interactive equivalences for ccs, Scientific Annals of Computer Science 22 (2013), pp. 147–199.
Hojati, R., “A BDD-Based Environment for Formal Verification of Hardware Systems,” Ph.D. thesis, EECS Department, University of California, Berkeley (1996).
URL http://www2.eecs.berkeley.edu/Pubs/TechRpts/1996/3052.html
Joyal, A. and I. Moerdijk, A completeness theorem for open maps, Annals of Pure and Applied Logic
70 (1994), pp. 51 – 86.
Joyal, A., M. Nielsen and G. Winskel, Bisimulation from open maps, Information and Computation
127 (1996), pp. 164 – 185.
Kupferman, O., N. Piterman and M. Y. Vardi, “Fair Equivalence Relations,” Springer, Berlin, Heidelberg, 2003 pp. 702–732.
Kwiatkowska, M., Survey of fairness notions, Information and Software Technology 31 (1989), pp. 371 – 386.
Mac Lane, S., “Categories for the Working Mathematician,” Number 5 in Graduate texts in Mathematics, Springer, NY, 1998, second edition.
Mac Lane, S. and I. Moerdijk, “Sheaves in geometry and logic: a first introduction to topos theory,” Universitext, Springer, 1992.
Polderman, J. W. and J. C. Willems, “Introduction to Mathematical Systems Theory: A Behavioral Approach,” Texts in Applied Mathematics 26, Springer-Verlag, New York, 1998, 1 edition.
Rutten, J. J. M. M., Universal coalgebra: a theory of systems, Theoretical Computer Science 249
(2000), pp. 3 – 80.
Schultz, P. and D. I. Spivak, Temporal Type Theory: A topos-theoretic approach to systems and behavior
(2017).
URL https://arxiv.org/abs/1710.10258

Sobocin´ski, P., Relational presheaves, change of base and weak simulation, Journal of Computer and System Sciences 81 (2015), pp. 901 – 910, 11th International Workshop on Coalgebraic Methods in Computer Science, CMCS 2012 (Selected Papers).
van Beek, D. A., K. L. Man, R. M. A., J. E. Rooda and R. R. H. Schiffelers, Syntax and consistent equation semantics of hybrid Chi, The Journal of Logic and Algebraic Programming 68 (2006), pp. 129 – 210.
van Glabbeek, R. J. and W. P. Weijland, Branching time and abstraction in bisimulation semantics,
J. ACM 43 (1996), pp. 555–600.
Winskel, G. and M. Nielsen, Presheaves as transition systems, in: Proceedings of the DIMACS Workshop on Partial Order Methods in Verification, POMIV ’96 (1997), pp. 129–140.
