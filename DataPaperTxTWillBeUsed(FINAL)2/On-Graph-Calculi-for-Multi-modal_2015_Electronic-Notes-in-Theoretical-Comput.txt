Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 312 (2015) 231–252
www.elsevier.com/locate/entcs
On Graph Calculi for Multi-modal Logics 1
Paulo A. S. Veloso2 Sheila R. M. Veloso3 Mario R. F. Benevides4
Computing and System Enginneering Progr., COPPE,
Federal University of Rio de Janeiro (UFRJ), Rio de Janeiro, RJ, Brazil

Abstract
We introduce a method, based on graphical representation, for formulating sound and complete calculi for multi-modal logics. This approach provides uniform tools for expressing and manipulating modal formulas. We illustrate the method by constructing, in a natural manner, correct graph calculi for some multi-modal logics, which may include the global and difference modalities, and may have some special properties.
Keywords: Modal logics, graph calculi, semantics, method, refutation, special modalities, decidability.


Introduction
Considering multi-modal logics [3], we introduce a method, based on graphical rep- resentation, for formulating correct (sound and complete) calculi, yielding decision procedures (when possible) for them. The formulas of the calculi are diagrams and their rules transform diagrams to diagrams. These rules capture graphically the semantical properties of the modal operators, so their formulation is very natural and their application is quite intuitive, since they mirror reasoning at the semantical level. This flexible approach provides uniform tools for expressing and manipulat- ing modal formulas: it gives elegant and simple ways for representing and reasoning about modalities, which contrast sharply with those using unorthodox rules [1].
Modal logics and graphs are closely related. Kripke semantics is often presented by means of labeled graphs for the accessibility relation associated to each modal- ity [1]. Using drawings for relations is a natural idea: represent the fact that a is

1 Research partly sponsored by the Brazilian agencies CNPq and FAPERJ.
2 Email: pasveloso@gmail.com
3 Email: sheila.murgel.bridge@gmail.com
4 Email: mario@cos.ufrj.br

http://dx.doi.org/10.1016/j.entcs.2015.04.014
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

related to b via relation r by an arrow a r
b. Graph representations and manipu-

lations, provided with precise syntax and semantics, give proof methods [10,11,12].
Our approach here is as follows. We associate a graphical representation to a modal formula and transform it to a graph, which will have empty extension if the formula is unsatisfiable, otherwise one can read a model from it (much as in tableaux [12]). Comparing with tableaux [6], we may point out some main differences. Our approach caters more to intuition, whereas tableaux tend to be implementation-oriented, and we can formulate properties of (accessibility) relations that cannot be expressed by modal formulas, which enhances the applicability of the method. We also have visualization: one can read from our diagrams a Kripke model for a satisfiable formula, in a manner that is much more direct and user friendly than in the case of tableaux.
The structure of this paper is as follows. Section 2 introduces our graph approach to modalities. Section 3 reviews some concepts and results about graphs. Section 4 introduces a basic graph calculus for modalities, which we indicate how to extend to some special cases in Section 5. We formulate our method and analyze it in Section 6. Section 7 presents some comments on our graph approach to modalities.

Graph Approach to Modalities
An interesting feature of the graph approach is its 2-dimensional notation provid- ing pictorial representations that support manipulations. We now introduce this approach: some basic ideas (in 2.1) and a graph approach to refutation (in 2.2).

Graphs for Modalities: basic ideas
We will use a denumerably infinite set of nodes; the ﬁrst 2 nodes being x and y.
A graph will be a finite set of (alternative) slices. A slice S will consist of an underlying draft S together with a distinguished node (marked, e. g. z). 5 A draft will be a finite sketch. A sketch will consist of sets of nodes and arcs. Slices and graphs will represent sets of states, while sketches will represent restrictions on sets of states (see also Section 4: Basic Graph Calculus for Modalities).
Arcs may be binary or unary. A binary arc stands for accessibility among states; we represent that node v is accessible from node u by the relation of α by a solid
arrow labelled α from u to v: u  α  v (abbreviated u α v). A unary arc is meant to
capture the fact that a formula holds at a state; we represent that formula ϕ holds at node w by a dashed line from w to ϕ: w 	 ϕ (abbreviated w|ϕ).
 	 
We can represent a formula ϕ by a slice Slw[ϕ]: the single-node slice w^	ϕ .
We will have rules for manipulating these representations (see also Section 4).
(∧) We can eliminate conjunction by splitting a dashed line into two, as follows:

ψ ∧ θ 	 w
(∧)
~
ψ 	 w
	 θ



5 We often identify a singleton graph { S } with its slice S.

(⟨α⟩) We can eliminate modality ⟨α⟩, by adding a new node, as follows:

⟨α⟩ ϕ 	 u
(⟨α⟩)
~
u  α /v¸	 ϕ

The above drawings are graphical representations of drafts. The skeleton of a draft consists of its nodes and binary arcs, which describes a finite frame (see Section 4).
We now examine our representation for negation.
The extension of a formula is the set of states satisfying it. Thus, the extension of the negated formula ¬ ϕ is the complement of the extension of the formula ϕ. So, negation can be represented by an overbar (for complement).
We thus have a large syntactical category representing sets of states: the ex- pressions, encompassing formulas, slices, graphs and their complements. Also, if a formula ϕ converts to a slice S, then ¬ ϕ converts to S, where we can enclose the slice within a box for better readability.
We can represent formulas ⟨α⟩¬ ϕ and ¬ ⟨α⟩ ϕ respectively by the expressions:
^u   α /v¸	 ϕ	^u  α /v¸	 ϕ

So, we can represent [α]ϕ by its equivalent ¬⟨α⟩¬ϕ, i. e. by
u^  α /v¸	 ϕ .

Also, we can use expressions as labels for unary arcs. Expressions provide more
flexible representations for formulas. We can represent formula ϕ by a slice Slv[ϕ].
 	 
So, we can represent ¬ ϕ by the expression Slv[ϕ] or by a slice like u^	Slv[ϕ]. 
Example 2.1 (Slices and formulas) We will be able to convert every modal for-
mula to a graph. Consider, however, the slices Sj and Sjj respectively as follows:
 u ,	 p


^x
_q	_r
z  γ	/¸
^x


z   γ
z	 
 ,

v	w	v
Slice Sj can be seen to represent the modal formula ⟨α⟩p ∧ ⟨β⟩(q ∧ ⟨γ⟩r), but one does not have a modal formula corresponding to slice Sjj. So, slices and graphs will turn out to be more expressive than modal formulas. We will only need some graphs
(with tree-like slices) to represent modal formulas (see Section 4).	q

Graph Approach to Refutation: basic ideas
We now introduce our graph approach to refutation of modal formulas.
Example 2.2 (Unsatisfiable formula) Consider formula ⟨α⟩ (ψ ∧¬ ψ). Its slice
Slx[⟨α⟩ (ψ ∧ ¬ ψ)] converts to a slice S as follows:

⟨α⟩ (ψ ∧ ¬ψ)
_
^x


(⟨α⟩)
~
ψ ∧_ ¬ψ
^x 	α	/y¸



(Λ)
~
, ψ
^x  α	/y¸	 ¬ψ

This slice S has a conflicting situation. For, on node y, we have two contradictory unary arcs: a positive arc (labelled ψ) and a negative arc (labelled ¬ψ). So, the underlying draft S cannot be satisﬁed, nor can formula ⟨α⟩(ψ ∧ ¬ψ).	q
This example shows that ⟨α⟩(ψ ∧ ¬ψ) is unsatisfiable because so is ψ ∧ ¬ψ.
In general lines, our graph approach to refutation will be as follows. We represent a formula ϕ by its slice Sl[ϕ] := x    ϕ and transform it to a graph G. If we can find conflict nodes within all slices of G, then ϕ is unsatisfiable. We can reduce consequence to unsatisfiability: ψ |= θ iff ψ ∧ ¬θ |= ⊥. So, we can also use this approach for consequence. Modularity of conversion is quite convenient.
Example 2.3 (Consequence via slices) To show that ⟨α⟩(ψ ∧ θ) |= ⟨α⟩ψ, it suffices to show that ⟨α⟩(ψ ∧ θ) ∧ ¬⟨α⟩ψ |= ⊥.
We can convert slice Sl[⟨α⟩(ψ ∧ θ) ∧ ¬⟨α⟩ψ] to a slice S0 as follows:

⟨α⟩(ψ ∧ θ)_ ∧ ¬⟨α⟩ψ
¬⟨α⟩ψ	⟨α,⟩(ψ ∧ θ)

(Λ)
^x	^x
We now handle the sub-formulas ⟨α⟩ (ψ ∧ θ) and ¬ ⟨α⟩ ψ.
We can convert slice Sl[⟨α⟩ (ψ ∧ θ)] to a slice S1 as follows:

⟨α⟩ (ψ_ ∧ θ)
^x


(⟨α⟩)
~
ψ ∧_ θ
^x 	α	/y¸



(Λ)
~
ψ c	¸θ
^x  α /y¸

We can convert slice Sl[¬ ⟨α⟩ ψ] to a slice S2 as follows:

^x
_
¬ ⟨α⟩ψ



(¬)
~
^x
  _ 
⟨α⟩ ψ


(⟨α⟩)
^x

So, slice S0 converts to the following slice S (obtained from S1, S2 and S0):
, θ
	 x   α	/y¸
ı ψ
Now, node x of draft S has a conflict, for we have 2 contradictory paths:
(+) path x   α /y¸	 ψ (corresponding to ⟨α⟩ψ), and

(−) path x 	 T , where T := x  α /y¸	 ψ (corresponding to ¬ ⟨α⟩ψ). So, to satisfy S, one must satisfy ⟨α⟩ψ and ¬ ⟨α⟩ψ, which is impossible.	q

Graph Approach to Special Modalities: basic ideas
We will be able to adapt these ideas to some other cases (see also 5.2 and 5.3).

Example 2.4 (Transitive consequence) If the relation of τ is transitive, then
⟨τ⟩⟨τ⟩ ϕ follows from ⟨τ⟩⟨τ⟩⟨τ⟩ ϕ. To establish this, we proceed much as above.
We can convert Sl[⟨τ⟩⟨τ⟩⟨τ⟩ϕ ∧ ¬⟨τ⟩⟨τ⟩ϕ] toa slice S with the following aspect:


	 u^
 z ¸	 ϕ

This slice S has no conflict. But, within S, we have the 3 consecutive nodes

u  τ /v¸ τ /w¸, so (by transitivity) we can also have u
Thus, we can expand slice S to the following slice Sj:


	 u
τ
_w¸.
τ
 z ,	 ϕ

Now, within this slice Sj, we have a copy of slice T := x  τ /y¸ τ /z ¸  ϕ under complement (the node mapping x '→ u, y '→ w, z '→ z preserves arcs) as well as the positive path u  τ /w¸ τ /z ¸  ϕ . So, node u has a conflict and one cannot satisfy draft Sj in any model.
Thus, in a τ-transitive model one cannot satisfy S (or ⟨τ⟩⟨τ⟩⟨τ⟩ϕ ∧ ¬⟨τ⟩⟨τ⟩ϕ).	q
This Example 2.4 deserves two comments. First, we have not expanded the slice
T under complement. Second, we have other options for using transitivity. 6
Example 2.5 (Reflexive model) Let us show how we can obtain a ρ-reflexive model for formula ¬p ∧ ⟨ρ⟩p. We begin with its slice Sl[¬p ∧ ⟨ρ⟩p].
We can convert Sl[¬p ∧ ⟨ρ⟩p] to the slice S := p 	 ^x   ρ /y¸	 p .
Now, whenever we have a node w, we can also have the binary arc w ,7ρ (by reflexivity). Thus, we can expand slice S to the following slice Sρ:
p_	p_

ρ	z   ρ	/¸,7ρ
^x	y
From this slice Sρ, we can read a natural model N with the following aspect:



6 We could expand S to a slice S′′ with the following aspect:



	 ^u
τ
z z _,	 ϕ


This slice S′′ has a copy of slice T (with the mapping x '→ u, y '→ v, z '→ z), giving a conflict at node u.

p_

ρ zx  ρ	/y¸,7ρ
N is ρ-reflexive; state x satisﬁes ⟨ρ⟩p but not p, so x satisﬁes ¬p ∧ ⟨ρ⟩p.	q

Graphs and Modalities: Concepts and Results
We now review some concepts and results about graphs. 7 We will consider a modal language L with set PL of propositional letters and modalities ⟨α⟩ for α ∈ Ξ. The formulas of L are generated by the grammar ϕ ::= ⊥| p | ¬ϕ | ϕj ∧ϕjj | ϕj ∨ϕj | ⟨α⟩ϕ. We regard T, →, ↔ and [α] as defined as usual.
Syntax is recursively defined. An expression is a formula of L, E (where E is an expression), a slice or a graph. Given a set N of nodes: a unary arc over N is a pair w|E (short for w    E ), where w ∈ N and E is an expression (its label ),
and a binary arc over N is a triple u α v (short for u	α	v), where u, v ∈ N and
α ∈ Ξ. A sketch consists of 2 sets: N of nodes and A of arcs over N. A draft is a sketch with finite sets N and A. A slice S consists of its underlying draft S and a distinguished node. A graph is a finite set of slices.
Semantics is also recursively defined. Consider a model M with universe M , underlying frame F (with αF ⊆ M × M , for α ∈ Ξ) and valuation V (cf. [1]).
(E) For an expression E, its extension [E]]M is defined as follows. For a formula ϕ, [ϕ]M is the set of states s ∈ M satisfying ϕ. For E, [E]]M is the complement M \ [E]]M of [[E]]M. If E is slice or graph, then we set [[E]M := [[E ]M (see below).
(g) Given a set N of nodes and an assignment g :N → M we define satisfaction.
(a) For a 1-ary arc w|E over N, g satisfies w|E iff wg ∈ [E]]M. For a 2-ary arc u α v over N, g satisfies u α v iff (ug, vg) ∈ αF.
(Σ) Assignment g satisfies sketch Σ iff g satisfies every arc of Σ.
(S) For a slice S with distinguished node z (noted S = (S : z)), its extension is the set [S]]M consisting of the values zg ∈ M for the assignments g satisfying S.
(G) For a graph G, its extension is [G]]M :=  S∈G [[S]]M.
Expressions E and F are equivalent (noted E ≡ F) iff they have the same exten- sion in every model. An expression is null iff it is equivalent to ⊥. 8 A sketch is satisﬁable iff some assignment satisfies it; slice S is satisﬁable iff S is satisfiable.
We wish to compare the structures of sketches and slices. For sketches Δ and Σ, a morphism from Δ to Σ is a function μ from the nodes of Δ to those of Σ that preserves arcs. 9 For slices T and S,a homomorphism from T to S is a morphism η of underlying drafts η : T −−· S that preserves distinguished nodes. 10 Morphisms

7 For more details on graphs, see e. g. [10,11,12] or [13].
8 For instance, ϕ ≡ Sl[ϕ], for a formula ϕ, S ≡ {S}, for a slice S, and the empty graph { } is null: { } ≡ ⊥.
9 With μ(w|E) := wμ|E and μ(u α v) := uμ α vμ: μ(a) is an arc of Σ, for every arc a of Δ.
10 In Example 2.4 (Transitive consequence), the mapping given by x '→ y, y '→ w, z '→ z is a homomorphism.

transfer satisfying assignments by composition: for μ : Δ −−· Σ, if g satisfies Σ, then g · μ satisfies Δ. Thus, if there exists a homomorphism η : T → S, then [[T]]M ⊇ [[S]]M, for every model M.
We will consider two kinds of conflict at a node w of a sketch Σ: when Σ has 2 unary arcs w|E and w|E (we then call E an expression witness), and when Σ has a unary arc w|T and there exists a morphism μ : T −−· Σ with μ(zT)=w (we then call T a slice witness). A sketch is zero iff it has some conflict node. A slice S is zero iff its underlying draft S is zero. A graph is zero iff all its slices are zero. 11 One can efectively decide whether a draft, a slice or a graph is zero (by finiteness). Clearly, a zero sketch is not satisfiable; so zero slices and graphs are null.
Given nodes u and v, we use [v/u] for renaming v to u. For a slice S = (S : z), we set S[v/u] := (S[v/u] : z[v/u]), which gives a homomorphism from S onto S[v/u]. Thus, [[S]]M ⊇ [[S[v/u]]]M, for every model M, and S[v/u] zero whenever S is zero.
We will use ‘+’ for adding sets of nodes or arcs. Given a slice T, with distin- guished node z, we glue T onto a node w of a slice S to obtain the glued slice SwT, which can be constructed by adding to S a copy T[z/w] of T having w as the only node in common with S. Note that we have the equivalence S + w|T ≡ SwT.
Consider a sketch Σ. For each expression E, its natural set EΣ consists of the nodes w of Σ such that w|E is a 1-ary arc of Σ. For each α ∈ Ξ, its natural relation αΣ consists of the pairs (u, v) of nodes of Σ such that u α v is a 2-ary arc of Σ. Now, if Σ has a non-empty set of nodes N /= ∅, then its natural frame F[Σ] has universe N and, for each α ∈ Ξ, αF[Σ] := αΣ; and its natural model N[Σ] has underlying frame F[Σ] and valuation VΣ with VΣ(p) := pΣ, for each propositional letter p ∈ PL. 12
It is easy to determine whether an assignment satisfies a 2-ary arc. For a 1- ary arc w   E , we need [E]] , The extension of an expression may be easy to determine. The nice expressions are p, for p ∈ PL, as well as E and Slw[E], for a nice expression E. A 1-ary arc w|E is nice iff its label E is nice; every 2-ary arc is nice. A sketch is nice iff all its arcs are nice. A slice S is nice iff its underlying draft S is nice. For a sketch Σ, its nice part Nc(Σ) consists of the nodes and nice arcs of Σ; for a slice S = (S : zS), we set Nc(S) := (Nc(S) :: zS).
Clearly, a nice sketch is zero iff it has some expression witness that is nice. For a non-zero nice sketch, the identity assignment satisfies it in its natural model (cf. Example 2.5: Reflexive model). Hence, a nice slice is null iff it is zero.
Basic Graph Calculus for Modalities
We now introduce our basic graph calculus. We consider a modal language L as in Section 3: with propositional letters p ∈ PL and modalities ⟨α⟩ for α ∈ Ξ. 13
We first introduce conversion for simplifying expressions. We wish to eliminate logical symbols from a formula converting its slice to an equivalent graph (in tree- like form). The 11 conversion rules come from equivalent expressions; they are of

11 In Example 2.3 (Consequence via slices), draft S and slice S are zero.
12 Example 2.5 (Reflexive model) shows the natural model N[Sρ].

13 Recall that the first 2 nodes are x and y (cf. 2.1: Graph for Modalities: basic ideas).

three kinds: 5 formula rules, 4 complementation rules and 2 structural rules.
The formula rules eliminate logical symbols; some of them have already been introduced: rules for ∧ and ⟨α⟩ (in 2.1) and for ¬ (in 2.2). The 5 formula rules are as follows. For ∧: ψ ∧ θ ∼ ψ     x    θ . For ⟨α⟩: ⟨α⟩ϕ ∼ x  α /y¸  ϕ . For ¬: ¬ϕ ∼ ϕ. The rule for ⊥ converts it to the empty graph {} and the rule for
∨ converts ψ ∨ θ to the graph with slices x    ψ and x    θ .

We have 4 complementation rules. One eliminates double complement: E ∼ E. The other three are versions of De Morgan’s rules, moving complement inside. Rule
(∪) converts a complemented graph H to the slice with arcs ^x|T, for T ∈ H. Rules

(T) and (∩) handle intersection slices: w^
(T)
{ } and S + zS|E
(∩)		
{ ^zS|S, ^zS|E }.

The 2 structural rules are as follows. Rule (Gr→) replaces addition of a graph-arc
by a graph with alternative glued slices (cf. Section 3): S + w|H ∼ {SwT / T ∈ H}.
Rule (↑) converts expression E to its slice Sl[E] = ^x 	 E . For instance, we have:
S + w|{T} (Gr→) {SwT}, S + w|{ } (Gr→) { } and p (↑) ^x	 p .
We have slice-replacing derived rules (↑) and (∩→): (↑) replaces S + w|E by slice
S + w|E and (∩→) replaces S + w|PzP Q by the graph { S + w|P, S + w|Q }. 14
We now introduce shifting for shortening complemented arcs. 15
The key idea comes from the representation of [α] ϕ as ¬ ⟨α⟩¬ ϕ, i. e. by an
expression like ^z  α /w¸	 E , where E represents ϕ (cf. 2.1). Consider a slice
S with 1-ary arc u 	 ^z   α /w¸	 E . For each 2-ary arc u	α	v of S, we
can add to S a 1-ary arc v 	 E∗ , where E∗ ≡ E, since S ≡ S + v 	 E∗ .
The next two examples illustrate how shifting is used.
Example 4.1 (Shifting and conflict) Formula ¬⟨α⟩ϕ ∧ ⟨α⟩T ∧ [α]ϕ is not sat- isﬁable. We can establish this fact as follows.
Slice Sl[¬⟨α⟩ϕ ∧ ⟨α⟩T ∧ [α]ϕ] converts to a slice S with the following aspect:
u
,,
α
	 ^x 	  ^x   α /v¸	 ϕ
This slice S has no conflict, but we can shift it as follows:







14 We can see that { S + w|P, S + w|Q } is a zero graph whenever S + w|PzP Q is a zero slice.
15 Shifting corresponds to transfer rules for [α] (as in [4,6,8]).

S	∼	Sj	∼	Sjj







^x  α /u¸
, ϕ
^x  α /u¸
, ϕ
x  α /u¸
s ϕ

    		    		    	





In slice Sjj, node u has a conflict (with expression witness ϕ); so slices Sjj, Sj and S
are not satisﬁable. Hence, formula ¬⟨α⟩ϕ ∧ ⟨α⟩T ∧ [α]ϕ is unsatisﬁable.	q
Example 4.2 (Shifting to letters) Consider the modal formula
⟨γ⟩ ( ⟨β⟩ r ∧ ⟨α⟩¬ ⟨β⟩ p ∧ ¬ ⟨α⟩¬ ⟨β⟩ q ).

Its slice converts to a 4-node slice S0 with the following aspect:








x  γ /u¸
α
β
r 	 zJ 
 β /¸	
Slice S0 has 2 arcs with complements: v 	 T (with T := u^	z	 p ) and
  β /¸	
u 	 T0 (where T0 := ^z  α /w¸	 T , with T := ^u	v	 q ).
Since S0 has the 2-ary arc u  α /v¸, we can shift T1 to node v. We glue slice
T1 = u^  β /v¸	 q to node v of S0, thus obtaining the (5-node) slice S1:









x  γ /u¸
α
β
r 	 zJ 
v∗z	 q
Now, slice S has a 2-ary arc v  β /v∗¸. Since it also has the unary arc v   T (with T := u  β /z ¸  p ), we can shift p to node v∗. We add to S1 the 1-ary arc v∗    p , and obtain the following (5-node) slice S2:








x  γ /u¸
α
β
r 	 zJ	,p
v	ı q
Thus, S0 ~ S1 ~ S2 and each new arc with complement added has shorter label than the originating one. Also, note that slice S2 is closed: shifting will not produce any new arc. We now examine these slices, considering 2 cases.
(=) If p = q, then T1 = u  β /v¸  p . So, the 3 slices have conflicts: node u has a conflict in the 3 slices (with witness T0), node v has a conflict in S1 and S2 (with witness T1) and node v∗ has a conflict in S2 (with witness p).
(/=) If p /= q, then the 3 slices are non-zero. We can see that they are satisﬁable as follows. Consider the closed slice S2, form its nice part Nc(S2) and let N be the natural model of its underlying draft D (cf. Section 3). Slice Nc(S2)

and model N have the following aspects:
^x	x
z	z

s r	vv∗˛
vv∗˛
q ,

Now, consider the identity assignment 1. We know that 1 satisﬁes draft D (cf. Section 3). It also satisﬁes the 1-ary arc v∗    p . We can see that 1 also satisﬁes the 1-ary arc v    T (otherwise, S2 would have some node

β
z with arcs v —→
z and z 	 p , which is impossible, as S2
is closed).



Similarly, we can see that 1 also satisﬁes the 1-ary arc u 	 T0 . Hence,
1 satisﬁes S2. Thus, [[S2]]N /= ∅, i. e. S2 is non-null and so are S1 and S0. q
We now formulate the shift rule. Consider a slice T of the form PwQ. Given a slice S with 1-ary arc u    T and a morphism μ : P −−· S with μ(zT)= u, we can expand S to the slice S + wμ    Q (cf. Examples 4.1 and 4.2).
Shifting may introduce 1-ary arcs whose expressions are complemented inter- section slices, but this may arranged by the derived rule (∩→). By applying the basic rules to Sl[ϕ] (cf. 2.2), we can “surface” the letters of a formula ϕ, obtaining a graph ϕss and ϕ is satisfiable iff ϕss is non-zero (which we can decide, cf. Section 3). Thus, we have a complete calculus for deciding satisfability of modal formulas.
We now introduce two transformation rules: zero erasure (for convenience) and alternative expansion (which is quite flexible and will be useful in 5.2 and 5.3).
A slice Z with a conflict (noted Z ∈ Z) is null (cf. Section 3), so we can erase

it: G ∪ {Z}
(Zr)
~ G. Thus, if G ⊆ Z, then G ~ { }.

Example 2.2 (Unsatisfiable formula) indicates how our graph approach handles the necessitation rule (it shows that formula ⟨α⟩(ψ Λ чψ) is unsatisfiable because so is formula ψ Λ чψ). If ϕ is valid, then чϕ is unsatisfiable and we can transform its slice Sl[чϕ] to the empty graph { }; thus, we can transform Sl[[α]ϕ] to { }, which converts to the arcless slice x (which represents T).
A motivation for alternative expansion comes from ⟨α⟩ elimination. We do have a derived rule (+⟨α⟩) replacing S + u   ⟨α⟩ϕ by S + u  α /v¸   ϕ , where v is a new node. Now, the corresponding natural frame includes the relationship u α /v ,¸with u /= v. Notice that one might be able to satisfy ⟨α⟩ ϕ by a state s of a model M with s ,7α . This is the purpose of the alternative expansion rule
(u | v): it allows expanding a slice S with nodes u and v to a graph with 2 alternative
slices: S= := S[v/u] (a renamed version, cf. Section 3) and S itself.
Example 4.3 (Small model) Consider the slice S := p 	 ^x  α /y¸	 p .

16 For instance, in Example 2.2 (Unsatisfiable formula), we have {Slx[¬ϕ Λ ϕ]} ∼∗ {S}
(Zr)
~ { }.

The natural model N[S] has the aspect p 
x	α /y¸
 p . Note that S /∈Z 

represents the formula p Λ ⟨α⟩p, which can be satisﬁed in a single-state model.
Rule (x | y) allows expanding slice S to the graph G := {S=, S}.
Slice S= := S[y/x] and natural model N[S=] are as follows:
p 	 ^x ,¸	 p	p	 p
α	α
As before, the identity assignment satisﬁes S= in N[S=]; so [[S=]]N[S=] /= ∅. Thus, [[S]]N[S=] ≥ [[S=]]N[S=] /= ∅ and N[S=] is a single-state model for p Λ ⟨α⟩p.  q
This example illustrates the usefulness of alternative expansion. Similarly, given a slice S and a 1-ary arc w|ψ V θ, any assignment g satisfying draft S + w|ψ V θ in a model M will also satisfy one of the drafts S + w|ψ and S + w|θ.
Graph Calculi for Special Modalities
We now indicate how to extend our basic graph calculus to some special cases: two particular modalities (in 5.1) and modalities with special properties (in 5.2 and 5.3).

Graph Rules for Particular Modalities
We now indicate how we can handle modalities like the global one and difference. These two modalities are interesting cases [1]: M,s H Eϕ iff, for some t ∈ M ,
M,t H ϕ and M,s H Dϕ iff, for some t ∈ M \ {s}, M,t H ϕ. We handle them by considering special relations square ∞ and diversity /= as logical, in the sense that t is always ∞-reachable from s and t is /=-reachable from s iff s /= t. We can see that this achieves the desired effect: modality ⟨∞⟩ behaves as global E and modality ⟨/=⟩ behaves as difference D. It remains to provide rules for manipulating ∞ and /=.
We first consider the square relation ∞. It imposes no restriction. So, we can

  ∞ /
(∞)

eliminate a ∞-arc by erasing it, i. e. by the ∞-rule: u
v¸ D	u	v .

Example 5.1 (Square) To show that ϕ |= ⟨∞⟩ ϕ, we show that ϕ Λ ч⟨∞⟩ϕ |= ⊥.
(∞)
Slice Sl[ϕ Λ ч⟨∞⟩ϕ] converts to slice S and S D S∞, with S and S∞ as follows:
^x	^x
c	
Slice S∞ is zero (x, y '→ x is a homomorphism from ^x	y 	 ϕ to S∞).	q
We can also easily show graphically that p does not follow from ⟨∞⟩ p:

Sl[⟨∞⟩p Λ чp] ~∗ S (∞) S
, and S∞
gives model x	y  p for ⟨∞
⟩p Λ чp.

/=
We now consider diversity. We cannot eliminate →, but we do have rules for
manipulating it. We have the following (expansion and contraction) rules for /=:

(/=†)
S
[v/u]	/=
/=	(/=↓)	17

  { S
, S + u → v } (for nodes u, v of S) and G ∪ {S +w → w}
D G.

Example 5.2 (Difference) We wish to show that чϕ Λ ⟨α⟩ϕ |= ⟨/=⟩ϕ.
Slice Sl[чϕ Λ ⟨α⟩ϕ Λ ч⟨/=⟩ϕ] converts to a (2-node) slice S with the aspect:
ϕ 	 ^x 	α	/u ¸	 ϕ
 	


We can expand S on (x, u). So S
α
 	  j	 ϕ
(/=†)
  { S=, S/= }, with S= and S/= as follows:
 		α	 ϕ

ϕ	^x	ϕ
 	



Both slices S= and S/= are zero, whence graph {S=, S/=} is zero.	q
We can also show that чp |= ⟨/=⟩ p: we obtain the natural model x.
(/=†)
Notice that an application of the expansion rule   introduces no new nodes.

So, we can always close a graph under applications of the /=-rules
(/=†)
  and
(/=↓)
D .

Our graph calculus can also establish some properties of these special modalities, like the validity of ϕ → [/=]⟨/=⟩ϕ and of ⟨∞⟩ϕ x (ϕ V ⟨/=⟩ϕ).

Graph Rules for Modalities with Simple Properties
We now examine modalities with simple properties, like reflexivity, transitivity, etc. The idea for reflexivity has been introduced in Example 2.5 (Reflexive model).
We can use the suggested (expansion) rule, namely Rf[ρ]: w   w,7ρ .
Example 5.3 (Reflexive consequence) We expect ⟨ρ⟩ ϕ to follow from ϕ if the relation of ρ is reflexive. To establish this, we proceed much as before. We convert Sl[ϕ Λ ч⟨ρ⟩ϕ] toa slice S and expand S to Srf, with S and Srf respectively as follows:


17 Note that s = s and either s = t or s /= t. Notation S[v/u] for renaming has been introduced in Section 3.



	 ϕ
ρ	zz	 ϕ



¸



Node x of Srf has a conflict, its witness being the slice T under complement (x, y '→ x
gives a homomorphism from T to Srf.) Note that we have not expanded T.	q
Example 2.5 shows graphically that p is not a ρ-reflexive consequence of ⟨ρ⟩p. The case of symmetry is similar. It suffices to consider an analogous expansion

rule: u	σ  zv˛(Sm[σ])
σ z˛

	u ¸¸
σ
v . Then, we can show that [σ]⟨σ⟩ ϕ is a σ-symmetric

consequence of ϕ and p is not a σ-symmetric consequence of [σ]⟨σ⟩ p.
An Euclidean ε has the natural rule Ec[ε]: add v	ε	w whenever we have the
pattern v	ε	ε	w. We can then show that ⟨ε⟩ p is not a ε-Euclidean conse-
quence of ⟨ε⟩⟨ε⟩ p, but ⟨τ⟩ ϕ follows from ⟨τ⟩⟨τ⟩ ϕ if τ is Euclidean and symmetric.
For a deterministic δ, we use a (contraction) rule Dt[δ] renaming nodes: vjj to
vj in S (noted S[v′′/v′]), whenever we have the pattern vj	δ	δ	vjj within S.
Example 5.4 (Deterministic consequence) For a deterministic δ, we expect that ⟨δ⟩ ϕ |= [δ] ϕ. We can show that ⟨δ⟩ ϕ Λ ч [δ] ϕ |= ⊥ as follows:


⎡ ⟨δ⟩ϕ ⎤
¸yj	 ϕ	, ϕ

Sl ⎢	Λ	⎥	~∗	^x
(Dt[δ])
D
^x  δ /yj¸

⎣ ч[δ]ϕ ⎦
zj j	 

y	ϕ


Hence, formula ⟨δ⟩ϕ Λ ч [δ]ϕ is not satisﬁable in a δ-deterministic model.	q
We can also show that ⟨δ⟩ p is not a δ-deterministic consequence of [δ] p. For
Sl[[δ]p Λ ч ⟨δ⟩p], we obtain a natural model x (with empty relation for δ).
The idea for transitivity has been introduced in Example 2.4 (Transitive con- sequence). For a transitive τ , we can use the suggested (expansion) rule Tr[τ ]:


(Tr[τ ])
zz
zz.

u	w	u
˛w 
τ

Example 2.4 shows that ⟨τ⟩⟨τ⟩ ϕ is a τ -transitive consequence of ⟨τ⟩⟨τ⟩⟨τ⟩ ϕ.
We can show that ⟨τ⟩⟨τ⟩ p is not a τ -transitive consequence of ⟨τ⟩ p much as before.
Example 5.5 (Transitive model) Consider the following slice S:






^u 	τ	/v ¸
Notice that slice S represents the formula [τ ]⟨τ⟩p Λ ⟨τ⟩T.
By applying shift and conversions, we obtain slice Sj with the following aspect:







^u	zv ˛	,p
Notice that this slice Sj represents the formula [τ ]⟨τ⟩p Λ ⟨τ⟩⟨τ⟩p.
Now, rule Tr[τ ] expands Sj to the following slice T:









,p



Rule (v | y) allows expanding T to the graph G := {T=, T}, with T= as follows:





u   τ	/z ¸
¸
,p
z   τ	/y ¸
,



¸p

u	τ
zv, ¸τ
The nice part Nc(T=) and natural model N[Nc(T=)] are as follows:

_p
u   τ	/v¸,¸τ
_p
u	τ	/v¸,¸τ

Notice that draft Nc(T=) is not zero and frame F[Nc(T=)] is τ-transitive.
As in Example 4.2, we see that the identity assignment 1 satisﬁes T= in N[S=].
Hence, N[S=] is a τ-transitive model for the underlying draft S.	q
This example indicates how the alternative expansion rule can be employed to simulate the effect of a blocking rule (as in [6,8]).
The cases examined above are relatively simple: the rules do not add new nodes.
For other cases, however, the natural rules may add some new nodes.

Graph Rules for Modalities with Other Properties
We now examine modalities with properties, like seriality, density and confluence.
Example 5.6 (Serial consequence) We expect ⟨λ⟩ ϕ to follow from [λ] ϕ if the relation corresponding to λ is serial. We can establish this fact much as before.
We can convert Sl[[λ]ϕ Λ ч⟨λ⟩ϕ] to a slice S0 with the following aspect:
	 ^x 	  ^x   λ	/y ¸	 ϕ
This slice S0 is neither zero nor shiftable. But, within S0 node x has no λ-
successor. So (by seriality) we can add a new node v and a 2-ary arc x	λ	v.
Thus, we can expand slice S0 to the following slice S1:
	 ^x 	  ^x   λ	/y ¸	 ϕ
v 
This slice S1 is still non-zero but it is shiftable.

By applying shifts and conversions, we obtain the following slice S2:
	 x 	  ^x   λ	/y ¸	 ϕ λ
ϕ 	 v    ϕ
Now, this slice S2 is zero. So, one cannot satisfy draft S2 in any model.
Hence, in a λ-serial model one cannot satisfy S0 (or formula ⟨λ⟩ϕ Λ ч[λ]ϕ).	q
Example 5.6 suggests a natural (expansion) rule for serial λ: if node w has no

(Sr[λ])
λ-successor in slice S, then S	 
S + w	λ
w∗, where w∗ is a new node.

Such rules, adding new nodes, are to be used with care to avoid endless appli- cations. 18 The next example illustrates how one can employ (Sr[λ]) judiciously.
Example 5.7 (Serial model) To show that [λ]p is not a λ-serial consequence of
⟨λ⟩ p, we start with ⟨λ⟩p Λ ч [λ]p. We can proceed as follows.
We can convert Sl[⟨λ⟩p Λ ч[λ]p] to a slice Sj with the following aspect:
p 	 u ¸,λ	 x   λ	/v¸	 p
We now apply (Sr[λ]) to nodes u and v of Sj, and obtain a slice Sjj as follows:
p 	 u ¸,λ	 ^x   λ	/v¸	 p
λ	λ
רz	%r
u	v
By rule (u | u∗), we can expand slice Sjj to the following graph G1:

⎧⎪
⎪⎨
⎪⎪⎪⎩
p_
u ,¸,λ	^x
λ
p_

λ	/v¸
λ
v∗%r
⎫⎪
,	Sjj	⎪⎬
⎪⎭

By rule (v | v∗), we can expand graph G1 to the following graph G2:

⎧⎪
⎪⎨
⎪⎪⎪⎩
p_
u ,¸,λ	^x
λ
p_

λ	/v,¸¸, λ
p_
u ,¸,λ	^x
λ
p_

λ	/v¸
λ
v∗%r




,	Sjj
⎫⎪
⎪⎬
⎪⎪⎪⎭

Consider the 3-node slice S of graph G2. Draft S and model N[S] are as follows:

18 Here, the alternative expansion rule will turn out to be quite helpful.

p_	p_	p_


u ¸,λ	 x   λ	/v¸
x	λ	/v,¸¸

λ	λ	λ	λ
Notice that draft S is not zero and the natural frame F[S] is λ-serial.
As before, the identity assignment satisﬁes S in N[S]; so [[G2]]N[S] ≥ [[S]]N[S] /= ∅.
Therefore, N[S] is a λ-serial model for formula ⟨λ⟩p Λ ч [λ]p.	q
The cases of density and confluence are similar to seriality, with analogous caveats. Natural expansion rules (where z∗ is a new node) are as follows:

ν	z˛ (Dn[ν])
ν
z_
˛v 
˛v! κ

u	v		u

zz∗&
¸v ,
ν
u

zw&
(Cf[κ])
	u
z∗ z

Example 5.8 (Dense consequence) We expect ⟨ν⟩⟨ν⟩ ϕ to follow from ⟨ν⟩ ϕ if the relation corresponding to ν is dense. We can establish this fact much as before. We obtain Sl[⟨ν⟩ϕ Λ ч⟨ν⟩⟨ν⟩ϕ] ~∗ S (Dn[ν]) Sj, with S and Sj respectively as follows:
^x	^x
ν	ν	ν

ϕ 	 u 
ϕ 	 u	(z
ν

In slice Sj, node x has a conflict (consider x '→ x, y '→ z∗, z '→ u). So, Sj is not satisﬁable. Thus, in a ν-dense model one cannot satisfy S (or ⟨ν⟩⟨ν⟩ϕ Λ ч⟨ν⟩ϕ). q
Example 5.9 (Dense model) To show that ⟨ν⟩ p is not a ν-dense consequence of
⟨ν⟩⟨ν⟩ p, we consider ⟨ν⟩⟨ν⟩p Λ ч ⟨ν⟩p. We can proceed much as before.
We can convert Sl[⟨ν⟩⟨ν⟩p Λ ч⟨ν⟩p] to a slice S with the following aspect:
	 x 	ν	/u¸ ν	/v¸	 p
Note that S is non-zero but shiftable. We shift S to a slice Sj as follows:
p_
	 ^x 	ν	/u¸ ν	/v¸	 p
We now apply (Dn[ν]) twice to Sj, and obtain a slice Sjj as follows:

p_
	 ^x 	ν	/u,¸, ν	/v,¸,	 p
ν	ν	ν
z	z 
u	v
Henceforth, we use T for the slice x  ν /y¸	 p (under complement).
By rule (v∗ | v), we can expand slice Sjj to the following graph G1:
⎧⎪	T_	p_	p_	⎫⎪
⎪					,7	⎪

⎨	^x
ν	/u,¸ ν	/v¸ ν
,	Sjj	⎬

⎪⎪⎪⎩
,
ν
zu∗˛
⎪⎪⎪⎭

By rule (u∗ | u), we can expand graph G1 to the following graph G2:
⎧⎪	T_	p_	p_	T_	p_	p_	⎫⎪
⎪					,7					,7	⎪

⎨	^x
ν	/u¸, ν	/v¸ ν ,
^x	ν  /u,¸ ν	/v¸ ν
, Sjj	⎬

⎪⎪⎪⎩
¸
ν
,
ν
vu∗˛
⎪⎪⎪⎭

Consider the 3-node slice S of graph G2. Draft S and model N[S] are as follows:

T_	p_	p_	p_

x 	ν	/u¸, ν	/v¸,7ν
ν
x
ν
/v¸,7ν

Notice that draft S is not zero and frame F[S] is ν-dense.
Much as in Example 5.7 (Serial model), we can see that [[G2]]N[S] ≥ [[S]]N[S] /= ∅.
Therefore, N[S] is a ν-dense model for formula ⟨ν⟩⟨ν⟩p Λ ч⟨ν⟩p.	q


Graph Calculi for Multi-modal Logics
We now formulate our method for constructing graph calculi and analyze it.
We can also allow some connections as well as some operations on relations (much as in [5]). For instance, we can express inclusion of relations by a rule [αj ⊆ αjj]

adding u
αjj
—→ v whenever we have u
αj
—→ v and intersection of relations by a rule

α1	z˛	 α ∩ α	

[α1∩α2] adding u
 v whenever we have u	1
α2
2 /v¸. We can also express

composition (by consecutive arrows), transposal (by arrow reversal) and identity (by
node identification via renaming) as well as union and empty relation. [10]
Example 6.1 (Constrained relations) Consider relation symbols α, β, γ and τ, subject to the constraints: “α ⊆ β ∩ γ, β ⊆ τ, γ ⊆ τ and τ is transitive”. We construct the corresponding graph calculus by adding to the basic rules in Section 4 the set Δ consisting of the rules [α ⊆ β ∩ γ], [β ⊆ τ ], [γ ⊆ τ ], [α ∩ β] and Tr[τ ].
(+) We can show that ⟨τ⟩ ϕ is a Δ-consequence of ⟨α⟩⟨γ⟩ ϕ, much as in Example 2.4, by transforming Sl[⟨α⟩⟨γ⟩ ϕ Λ ч⟨τ⟩ ϕ] to the following slice:
α	z/v .¸	, ϕ
β	¸,,,	γ
γ	τ	z(˛z
τ	1,
τ
Thus, formula ⟨α⟩⟨γ⟩ϕ Λ ч ⟨τ⟩ ϕ is not Δ-satisﬁable.
(−) We can obtain a Δ-model for [τ ]⟨τ⟩p Λ ⟨β⟩⟨γ⟩p, much as in Example 5.5. We transform Sl[[τ ]⟨τ⟩p Λ ⟨β⟩⟨γ⟩p] to a slice S, which gives a model N, as follows:
S	N








, p

u
τ


Thus, [β][γ] чp is not a Δ-consequence of [τ ]⟨τ⟩ p.	q
Consider a modal language L as in Section 3: with modalities ⟨α⟩ for α ∈ Ξ. Given a set of constraints on the symbols of Ξ, we wish to determine whether formula ϕ of L is satisfiable in some model whose relations obey the constraints.
The method for constructing a graph calculus is as follows. Add to the basic rules in Section 4, the set Δ consisting of the constraint rules among the relation symbols in Ξ, as well as the rule for ∞ and the 2 rules for /= (cf. 5.1). Notice that we formulate the calculus by keeping decoupled the basic rules and those for constraints; they will interact when using the calculus (cf. Example 6.1).

We use such a graph calculus as follows. We begin with Sl[ϕ] (cf. 2.2) and apply transformations trying to obtain the empty graph { }. The calculus is sound: if we do obtain { }, then ϕ is not satisfiable. It is also complete: if Sl[ϕ] cannot be transformed to a zero graph, then we have a discriminating set D of slices giving a model where ϕ is satisfiable, since we can obtain a sequence D of slices connected by homomorphisms, whose co-limit sketch Σ has natural model N[Σ] where Sl[ϕ] has non-empty extension (see [12,13]). Moreover, if the set Δ is sufficiently simple, then we can obtain a finite discriminating set D; in such cases (cf. Examples 5.5, 5.7 and 5.9), we have a decision procedure.
Concluding Remarks
We now present some comments on our graph approach to modalities.
We have introduced and illustrated a flexible method, based on graphical rep- resentation, for directly formulating calculi, which are not only correct but also natural and intuitive to use, for (some) multi-modal logics.
Using graphs in connection with proofs is not so novel (see e. g. [2,7]). Also, inference systems internalizating Kripke semantics have become common recently (see [9] and references therein). We have already introduced correct graph calculi for some modal logics [13] and for PDL [14]. Their graphical rules mirror the semantical properties of the modal operators, so their formulation and application are quite intuitive; correctness indicates that the rules do capture the intended meanings.
Our approach here presents an interesting novelty: we propose a method for con- structing calculi, which is modular and natural, in that we can express graphically connections among accessibility relations. We have illustrated how this method can be uniformly applied to handle particular modalities, like the global one and differ- ence, as well as modalities with some special properties like reflexivity, transitivity, density, etc., yielding decision procedures. Our approach is similar to the one in [4], but our method can handle modal operators and properties that are not modally expressible, e. g. ⟨α∩ β⟩ (cf. Example 6.1); see also Example 2.1 (Slices and formu- las). We can represent graphically properties of accessibility relations and reason directly about them without having to concoct modal axioms or ad-hoc rules.

References
P. Blackburn, M. de Rijke and Y. Venema, Modal Logic, Cambridge University Press, 2001.
A. Carbone, A new Mapping between Combinatorial Proofs and Sequent Calculus Proofs read out from Logical Flow Graphs, Information and Computation 208, pp. 500–509, 2010.
W. Carnielli and C. Pizzi, Modalities and Multimodalities, Springer-Verlag, 2008.
M. A. Castilho, L. F. del Cerro, O. Gasquet and A. Herzig, Modal Tableaux with Propagation Rules and Structural Rules, Fundamenta Informaticæ XX, pp. 1–17, 1998.
R. Catach, Normal Modal Logics, In: Proc. AAAI-88, pp. 491–495, 1988.
M. Fitting, Proof Methods for Modal and Intuitionistic Logics, D. Reidel, 1983.

H. Geuvers and I. Loeb, Natural Deduction via Graphs: Formal Definition and Computation Rules,
Mathematical Structures in Computer Science 17(03), pp. 485-526, 2007.
I. Horrocks, U. Hustadt, U. Sattler and R. Schmidt, Computational Modal Logic, In: P. Blackburn, J. van Benthem and F. Wolter (eds), Handbook of Modal Logic, pp. 207–225, Elsevier, 2007.
S. Negri, Proof Analysis in Modal Logic, Journal of Philosophical Logic 34, pp. 507–544, 2005.
R. Freitas, P. A. S. Veloso, S. R. M. Veloso and P. Viana, On Graph Reasoning, Information and Computation 207, pp. 1000–1014, 2009.
R. Freitas, P. A. S. Veloso, S. R. M. Veloso and P. Viana, A Calculus for Graphs with Complement, In: Goel, A. K., Jamnik, M., Narayanan, N. H. (eds.) Diagrams 2010, LNCS 6170, pp. 84–98, 2010.
P. A. S. Veloso and S. R. M. Veloso, On Graph Refutation for Relational Inclusions, In: S. R. D. Rocca and E. Pimentel (eds.), LSFA 2011, EPTCS 81, pp. 47–62, 2011.
P. A. S. Veloso, S. R. M. Veloso and M. R. F Benevides, On a Graph Approach to Modal Logics, In:
LSFA 2013, 2013.
P. A. S. Veloso, S. R. M. Veloso and M. R. F Benevides, PDL for Structured Data: a Graph-Calculus Approach, Logic Journal of the IGPL, doi 10.1093/jigpal/jzu011, 2014.
