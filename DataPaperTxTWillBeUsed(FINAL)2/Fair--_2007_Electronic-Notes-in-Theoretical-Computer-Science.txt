Electronic Notes in Theoretical Computer Science 175 (2007) 3–26	
www.elsevier.com/locate/entcs

Fair Π *
Diletta Cacciagrano1 , Flavio Corradini2
Dipartimento di Matematica e Informatica Universita` degli Studi di Camerino, Italy

Catuscia Palamidessi3
INRIA Futurs, LIX E´cole Polytechnique, France

Abstract
In this paper, we define fair computations in the π-calculus [18]. We follow Costa and Stirling’s approach for CCS-like languages [9,10] but exploit a more natural labeling method of process actions to filter out unfair process executions. The new labeling allows us to prove all the significant properties of the original one, such as unicity, persistence and disappearance of labels. It also turns out that the labeled π-calculus
is a conservative extension of the standard one. We contrast the existing fair testing [3,19] with those that naturally arise by imposing weak and strong fairness as defined by Costa and Stirling. This comparison provides the expressiveness of the various fair testing-based semantics and emphasizes the discriminating power of the one already proposed in the literature.

Key words: Pi-Calculus, Testing Semantics, Strong Fairness, Weak Fairness.


Introduction
In the theory and practice of parallel systems, fairness plays an important role when describing the system dynamics. Several notions have been proposed in the litera- ture, as in [9,10], where Costa and Stirling distinguish between fairness of actions in [9] (for a CCS-like language without restriction), and fairness of components in [10]. In both cases they distinguish between weak fairness and strong fairness. Weak fairness requires that if an action (a component, resp.) can almost always proceed,

٨ This work was supported by the Investment Funds for Basic Research (MIUR-FIRB) project Laboratory of Interdisciplinary Technologies in Bioinformatics (LITBIO) and by Halley Informatica.
1 Email: diletta.cacciagrano@unicam.it
2 Email: flavio.corradini@unicam.it
3 Email: catuscia@lix.polytechnique.fr

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.051

then it must eventually do so, while strong fairness requires that if an action (a com- ponent, resp.) can proceed inﬁnitely often, then it must proceed infinitely often. The main ingredients of the theory of fairness in [9] and [10] are:
A labeling method for process terms. This allows to detect the action performed during a transition and the component responsible for it. Labels are strings in {0, 1}∗, associated systematically with operators and basic actions inside a process. Along a computation, labels are unique and, once a label disappears, it does not reappear in the system anymore (unicity, persistence and disappearance properties).
Live actions (components, resp.). An action (a component, resp.) of a process term is live if it can currently be performed (perform an action, resp.). In a term like (νz)(x(y).z¯w.0 | z(u).0), only an input action on x can be performed while no action on z can, momentarily.
In this paper, we adapt to the π-calculus [18] the approach to fairness which has been proposed in [9,10] for CCS-like languages [17]. A difference with [9,10] is that our labels are pairs ⟨w, n⟩ ∈ ({0, 1}∗ × N). The first element, w, represents the position of the component (in the term structure) and depends only on the static operators (parallel and restriction). This element ensures the unicity of a label. The second element, n, provides information about the dynamics of the component, more precisely, it indicates how many actions that component has already executed since the beginning of the computation, and it depends only on the dynamic operator (prefix). This second element serves to ensure the disappearence property of a label. So, we have the unicity and disappearence properties of labels like in [9,10] but, differently from the latter, we keep separated the information about the static and dynamic operators. We believe that this new labeling method represents more faithfully the structure of a process and makes more intuitive the role of the label in the notion of fairness.
The proposed labeling technique allows to define weak and strong fair compu- tations. At the top of them we introduce must testing semantics [1], to obtain the so-called weak-fair must semantics and strong-fair must semantics. These two fair testing semantics are compared with an existing one in the literature - the fair testing [3,19] - that does not need any labeling of actions. We present a compar- ison between fair testing and weak and strong-fair must semantics as well as with standard must testing. This comparison emphasizes the expressiveness of the dif- ferent fair testing semantics, especially for what it concerns fair testing. We show interesting side-effects when the must testing is imposed over weak and strong-fair computations. In particular, any strong-fair computation is weak-fair too, while it turns out that the weak-fair must semantics is strictly finer than the strong-fair must one.
The rest of the paper is organized as follows. Section 2 presents the π-calculus. Section 3 defines must testing [1] and fair testing semantics [3,19]. Section 4 shows the labeling method and its main properties. Weak and strong-fair must semantics are defined in Section 5 and compared in Section 6. Finally, in Section 7 we in-

vestigate why strong and weak fairness notions are not enough to characterize fair testing semantics. As usual, Section 8 gathers several related work and Section 9 contains a few concluding remarks and further work. All of the proofs omitted in the body of the paper are in the appendixes.

The π-calculus
We now briefly recall the basic notions about the (choiceless) π-calculus. Let N (ranged over by x, y, z,.. .) be a set of names. The set P (ranged over by P, Q, R,.. .) of processes is generated by the following grammar:


P ::= 0
x(y).P
τ.P
x¯y.P
P | P
(νx)P
!x(y).P


The input prefix y(x).P , and the restriction (νx)P , act as name binders for the name x in P . The free names fn(P ) and the bound names bn(P ) of P are defined as usual. The set of names of P is defined as n(P ) = fn(P ) ∪ bn(P ). Only input guarded terms can be in the scope of the bang operator, but this is not a real shortcoming, since this kind of replicator is as expressive as the full bang operator [14].
The operational semantics of processes is given via a labeled transition system, whose states are the process themselves. The labels (ranged over by μ, γ,.. .) “cor- respond” to prefixes, input xy, output x¯y and tau τ , and to the bound output x¯(y) (which models scope extrusion). If μ = xy or μ = x¯y or μ = x¯(y) we define sub(μ)= x and obj(μ)= y. The functions fn, bn and n are extended to cope with labels as follows:


The transition relation is given in Table 1. We omit symmetric rules of Par, Com and Close for lake of space. We also assume alpha-conversion to avoid collision of free and bound names.
Definition 2.1 (Weak transitions) Let P and Q be P processes. Then:
ε	τ	τ
- P =⇒ Q iff ∃ P0, ..., Pn ∈ P, n ≥ 0, s.t. P = P0 −→ ... −→ Pn = Q ;
μ	ε	μ	ε
- P =⇒ Q iff ∃ P1, P2 ∈P s.t. P =⇒ P1 −→ P2 =⇒ Q. 
Notation 2.1 For convenience, we write x(y) and x¯y instead of x(y).0 and x¯y.0,
μ	μ
respectively. Furthermore, we write P −→ (respectively P =⇒) to mean that there
exists P ' such that P	μ	'	μ	'	ε	μ	to

mean that there are P '
and Q such that P =⇒ε  P '
and P
μ
−→ Q.



Table 1
Early operational semantics for P terms.

Testing semantics
In this section we briefly summarize the basic definitions behind the testing ma- chinery for the π-calculus.
Definition 3.1 (Observers)
Let N ' = N ∪ {ω} be the set of names, assuming ω /∈ N. By convention
fn(ω)= bn(ω)= ∅. ω is used to report success.
The set O (ranged over by o, o', o'',.. .) of observers is defined like P, where the grammar is extended with the production P ::= ω.P .
The operational semantics of P is extended to O by adding ω.P −ω→ P . 
Definition 3.2 (Experiments) E denotes the set
{ (P | o) | P ∈P and o ∈ O}
of experiments in P.

Definition 3.3 (Maximal Computations) Given P ∈ P and o ∈ O, a maximal computation from P | o is either an infinite sequence of the form
P | o = T −τ→ T −τ→ T −τ→ ... 
or a finite sequence of the form
P | o = T −τ→ T −τ→ ... −τ→ T /−τ→ .
We are now ready to define must and fair testing semantics.
Definition 3.4 (Must and Fair Testing Semantics) Given a process P ∈P and an observer o ∈ O, define:
P must o if and only if for every maximal computation from P | o
P | o = T0 −τ→ T1 −τ→ ... Ti [−τ→ .. .] there exists i ≥ 0 such that Ti −ω→;
P fair o if and only if for every maximal computation from P | o
P | o = T −τ→ T −τ→ ... T [−τ→ .. .] Ti =⇒, for every i ≥ 0.
A labeled version of the π-calculus
Fairness imposes that concurrent subprocesses always eventually proceed unless they are deadlock processes or have terminated. Such a constraint will affect the behavior of processes. Consider the process P | P , where
P = (νa)(!a.a¯ | a¯) and the following maximal computation
P | P −τ→ P | P −τ→ P | P −τ→ ..

We can not know whether the computation is fair or not, since we do not know which component (either on the right hand or on the left one of |), performs a synchronization at each step: we need to distinguish unambiguously actions of a concurrent system and to monitor them along its computations.
For this purpose, we extend to the π-calculus the label-based approach proposed in [10]. As explained in the introduction, however, we depart from [10] in the way we define the labels. In our case, labels are pairs whose first and second elements represent, respectively, the position of the component in the term and the number of actions already executed.

We proceed by defining L(B), as the language generated by the grammar


B ::= 0
μ⟨s,n⟩.B
(νx)B
B | B
!⟨s,n⟩x(y).P


where s ∈ {0, 1}∗, n ∈ N, P ∈P and μ ∈ {x(y), x¯y, τ }.
Then we define a binary relation ঩ over sets of labels and two functions, top and lab, allowing to obtain all labels appearing at the top of a labeled term and the whole labels set, respectively.
Definition 4.1 Let L1, L2 ⊆ ({0, 1}∗ × N).  We define L1 ঩ L2 if and only if
∀⟨s1, n1⟩ ∈ L1, ∀⟨s2, n2⟩ ∈ L2, s1 /≤ s2 and s2 /≤ s1, where ≤ is the usual prefix relation between strings.
Definition 4.2 Let E ∈ L(B). top(E) and lab(E) are defined by structural induc- tion as follows:
E = 0 :	top(E)= ∅	lab(E)= ∅
E = μ⟨s,n⟩.E' :   top(E)= {⟨s, n⟩}	lab(E)= {⟨s, n⟩} ∪ lab(E')
E = (νx)E' :	top(E)= top(E')	lab(E)= lab(E')
E = E1|E2 :	top(E)= top(E1) ∪ top(E2)	lab(E)= lab(E1) ∪ lab(E2) E =!⟨s,n⟩x(y).P : top(E)= {⟨s, n⟩}	lab(E)= {⟨s, n⟩}
Hence, we define a specific labeling function.
Definition 4.3 Let P ∈ P. Define L⟨s,n⟩(P ), where s ∈ {0, 1}∗ and n ∈ N, induc- tively as follows:

L⟨s,n⟩(!x(y).P ) =	!⟨s,n⟩x(y).P

Now, we are ready to define Pe, the set of labeled π-calculus terms.
Definition 4.4 The labeled π-calculus, denoted by Pe, is the set
{E ∈ L(B) | wf (E)}

where wf (E) is defined in Table 2.



Table 2
Well formed terms.
Some properties of the labeled π-calculus
The operational semantics of Pe is similar to the one in Table 1; we simply ignore labels in order to derive a transition. As expected, the only rule that needs attention regards bang processes, because the unfolding generates new components and we must ensure unicity of labels. Since the unfolding puts two components in parallel, we exploit a proper dynamic labeling of the parallel components (Table 3). The intuition behind this rule follows by viewing !⟨s,n⟩x(y).P as L⟨s,n⟩(x(y).(P |!x(y).P )).

Table 3 Bang rules.
To give some more intuition, consider S = x(y).(z(k).0 | z¯h).0 | f.0 and its
labeled version S' = x(y)⟨0,0⟩.(z(k)⟨00,1⟩ .0 | z¯h⟨01,1⟩).0 | f⟨1,0⟩.0 4 .
Prefixes x(y) and f in S are both top level prefixes. For this reason, they get labels of length 1; though the one on the left hand side of the parallel composition has been labeled 0, while the one on the right hand side has been labeled 1, just to distinguish the two prefixes. On the other hand, z(k) and z¯h within the scope of

4 According to Costa and Stirling, we have: S'=x(y)0.(z(k)010.00101|01z¯h011.00111)|ε f1.011.

x(y) are both second level prefixes composed in parallel, so that they get 00 and 01 as different parallel subcomponents, respectively. However, as second action of the source component, they have the same index (i.e. 1). The significance of the second element of the labels is, of course, more evident when we consider more sequential processes.
It is possible to verify that ∀E ∈ Pe, top(E) ⊆ lab(E). Pe enjoys closure properties under any renamings σ, since σ does not change labels. Hence, it is closed under the execution of basic actions. Furthermore, no label occurs more than once in a labeled term (unicity of labels) and once a label disappears (it happens when the action related to such a label is performed) along a computation, it does not appear in the system anymore (persistence and disappearance of labels).
Lemma 4.5 Let E ∈ Pe. Then:
No label ⟨s, n⟩ occurs more than once in E;

μ
If E −→
E' then ∃⟨s, n⟩∈ lab(E): ⟨s, n⟩ /∈ lab(E');

μ1	μ2
∀k ≥ 1 : E	E	E
μ3	... μk
E , if ⟨s, n⟩ ∈ lab(E) ∩ lab(E
) then

−→	1 −→
2 −→
−→	k	k

⟨s, n⟩∈ 
lab(Ei), where i ∈ [1..(k − 1)].

As expected, the labeled language is also a conservative extension of the unla- beled one. To prove the statement, we have to formally define the π-calculus process obtained by deleting all the labels appearing within a labeled term.
Definition 4.6 Let E ∈ Pe. Define Unl(E) as the P process obtained by removing all the labels in E. It can be defined by induction as follows:

Unl(!⟨s,n⟩x(y).P ) =	!x(y).P
Then, we can prove the result, stated in the following lemma.
Lemma 4.7 Let E ∈ Pe. Then:

μ
E −→
E' implies Unl(E)  μ
Unl(E');

μ
Unl(E) −→
P ' implies ∃E' ∈ Pe such that E  μ
E' and Unl(E')= P '.

Strong and weak fairness
The labeling method proposed in the previous section can be extended in a natural way over experiments, adding B ::= ω.B in the grammar of L(B), ω.o −ω→ o in the operational semantics and extending the functions L⟨s,n⟩, top, lab, Unl and the predicate wf as shown in Table 4.






Table 4
Labeling method extension over experiments.

The definition of live label is crucial in every fairness notion. Given a labeled experiment S ∈ Ee, a live label is a label associated to a top-level action which can immediately be performed, i.e. either a τ prefix or a input/output prefix able to synchronize. Table 5 defines live labels for a labeled experiment S ∈ Ee, according to the labeling method proposed in Section 4. Since ω is a special action without
complementary version (i.e. ω¯ is not defined), it is correct to assume that ω is not
live. Furthemore, ω occurrences do not need to be observed: consequently, no label is associated to them.
Given a labeled experiment S, its set of live labels is denoted by Lp(S). Notice that, by definition of liveness, if S can not perform any reduction (either an explicit τ action or a synchronization) then Lp(S)= ∅.
Definition 5.1 Let S ∈ Ee, let ⟨s, n⟩∈ ({0, 1}∗ × N).
Lp(S)= {⟨s, n⟩∈ ({0, 1}∗ × N) | live(⟨s, n⟩, τ, S)}
is the set of live labels associated to initial τ actions.
Since top(S) is defined as the set of any labels appearing at the top of S, Lp(S) ⊆
top(S) follows immediately by the definition of live actions.
In the following, labels will be denoted by v, v1, v2, .. ∈ ({0, 1}∗ × N) for con- venience. Oe (ranged over by ρ, ρ', ..) denotes the set of observers and Ee denotes the set of labeled experiments in Pe, as expected. Now, we can formally define two well-known notions of fairness.
Definition 5.2 (Weak-fair Computations) Given S ∈ Ee, a weak-fair computation
from S is a maximal computation,
S = S0 −τ→ S1 −τ→ S2 −τ→ ... −τ→ Si [−τ→ .. .] where ∀v ∈ ({0, 1}∗ × N), ∀i ≥ 0, ∃j ≥ i such that v /∈ Lp(Sj).
Definition 5.3 (Strong-fair Computations) Given S ∈ Ee, a strong-fair computa-
tion from S is a maximal computation,
S = S0 −τ→ S1 −τ→ S2 −τ→ ... −τ→ Si [−τ→ .. .] where ∀v ∈ ({0, 1}∗ × N), ∃i ≥ 0 such that ∀j ≥ i, v /∈ Lp(Sj).



Table 5 Live labels.

A weak-fair computation is a maximal computation such that no label becomes live and then keeps on being live forever.
A strong fair computation is a maximal computation such that no label is live infinitely often, i.e. no label can become live, lose its liveness, become live again, etc. forever. Formally, strong fairness imposes that for every label there is some point beyond which it never becomes live. Any finite computation is strong fair because all the actions, corresponding to live labels, are performed, and the computation stops when there is no reduction at all. Some useful results follow:
Theorem 5.4 For every labeled experiment S ∈ Ee, then
every strong-fair computation from S is weak-fair, but not the vice versa;
there always is a strong-fair computation out of S.

Proof. (Sketch of:) Consider item (1). To prove the positive result it suffices to notice that a strong-fair computation is a special case of weak-fair computation. To prove the negative result, let S :=!v1 a | (νb)(¯bv2 | !v3 b.(a¯ | ¯b)) | av4 .ω be an experiment: it is not difficult to check that there exists a maximal computation from S, along which av4 is never performed. It is weak-fair but not strong-fair.
Now consider item (2). It suffices to prove that ∀S ∈ Ee,


Lp(S) is a finite set;
S /−τ→ implies Lp(S)= ∅;
v ∈ Lp(S) implies ∃S' ∈ Ee such that S  μ  S'



and for any S''



such that S




' =ε⇒ S'',

v /∈ Lp(S'');
∃S' ∈ Ee such that S =⇒ S', Lp(S) ∩ Lp(S') = ∅ and for any S'' such that
S' =⇒ε  S'', Lp(S) ∩ Lp(S'')= ∅.

Comparing fair semantics
In this section we provide a comparison among two different notions of fairness and the must semantics. It is easy to prove that ∀P ∈ P, ∀o ∈ O, P musto implies P fairo, but not the vice versa: it suffices to consider the process P ::= (νa)(a¯ | !a.a¯) | ¯b and the observer o ::= b.ω.
Now, we try to add fairness in the must testing semantics and investigate the resulting semantic relations.
Definition 6.1 (Strong/Weak-fair Must Semantics) Let E ∈ Pe and ρ ∈ Oe. De- fine E sfmust ρ (E wfmust ρ) if and only if for every strong (weak)- fair computation from (E | ρ)
E | ρ = S −τ→ S −τ→ ... −τ→ S [−τ→ .. .]
∃i ≥ 0 such that Si −ω→.

Weak fairness and strong fairness in a must testing scenario
The following proposition states a very interesting result regarding weak and strong- fair must semantics. Notice that the positive implication follows by the fact that an unsuccessful strong-fair computation from an experiment S = E | ρ is weak-fair too. This result seems to go against a well-established notion stating strong fairness a special case of weak fairness. More in details, it is well-known that strong fairness implies weak fairness, in the sense that a strong-fair computation is obviously weak- fair too. However, this implication is reversed when the must testing semantics is embedded in this fairness scenario: in the case that every weak-fair computation from an experiment is successful, then every strong-fair computation from the same experiment is successful.

Theorem 6.2 For every E ∈ Pe and ρ ∈ Oe, then E wfmust ρ implies E sfmust ρ, but not the vice versa.
Must semantics imposes the success on any computation from a given experi- ment; that being so, any action leading to success in a weak-fair computation, can alternatively be live and lose its liveness only a finite number of steps, since its execution is surely forced to reach the success. It follows that a successful weak- fair computation collapses in a successful strong-fair computation. To prove the
negative result, consider E :=!v1 a | (νb)(¯bv2 | !v3 b.(a¯ | ¯b)) and ρ := av4 .ω.
From E | ρ there exists a maximal computation along which every live label different from v4 is performed, while v4 becomes live, loses its liveness, becomes live again, etc., without being performed: this computation is weak-fair by defini- tion and unsuccessful. Notice that v4 should be always performed in a strong-fair computation, determining the success of it.
Theorem 6.3 shows some interesting results by comparing weak/strong-fair must and must semantics.
Theorem 6.3 For every E ∈ Pe and ρ ∈ Oe, then
Unl(E) must Unl(ρ) implies E wfmust ρ, but not the vice versa.
Unl(E) must Unl(ρ) implies E sfmust ρ, but not the vice versa.
Proof. (Sketch of:) Consider item (1): the positive result is trivial, since a suc- cessful weak-fair computation is a successful maximal computation. To prove the negative result, consider E := (νa)(a¯v1 | !v2 a.a¯) | ¯bv3 and ρ := bv4 .ω.
It is easy to check that Unl(E) must Unl(ρ). E wfmust ρ holds since, given a weak-fair computation from E | ρ, there has to exist a term performing ω, being v4 already live since the beginning of the computation and having to lose its liveness at least once, by definition of weak fairness. In this case, losing liveness implies that bv4 is performed. Item (2) is just a corollary of item (1) and Theorem 6.2. 
Weak and strong fairness vs fair testing semantics
Since weak-fair must semantics is strictly finer than strong-fair must one, the latter would look suitable to express fair testing semantics. However, Theorem 6.4 shows that not only the former but also the latter does not suffice to characterize fair testing semantics.
Theorem 6.4 For every E ∈ Pe and ρ ∈ Oe, then
E wfmust ρ implies Unl(E) fair Unl(ρ), but not the vice versa.
E sfmust ρ implies Unl(E) fair Unl(ρ), but not the vice versa.
Proof. (Sketch of:) Consider item (2). Regarding the positive result, it is crucial

to show that, given S, S' ∈ Ee
such that S' =⇒
S, and a strong-fair computation

C from S, then the computation obtained by prefixing C
with S' =⇒
S keeps on

being strong-fair. Regarding the negative result of item (2), it is enough to consider
E := c¯v1 |!v2 c.(νa)(a¯|a.c¯|a.¯b) and ρ := bv3 .ω. It easy to check that Unl(E)fairUnl(ρ),

but there exists a strong-fair computation where v3 never becomes live. Since v3 prefixes the only ω occurrence along the given computation, the success will never be reached. Item (1) is just a corollary of item (2) and Theorem 6.2.	 

Strong fairness and fair testing semantics
A more detailed interpretation of live action in the strong and weak fairness scenar- ios is crucial for both the negative results of Theorem 6.4. An action corresponding to a live label is not required to be performed to lose its liveness. Of course, when such an action is performed, then its label disappears forever. However, the label of an action may be present but no longer be live if, for example, a complementary action, which determines its liveness, is consumed in another synchronization.
We sketch why strong-fair must semantics (and, consequently, weak-fair must semantics) fails in attempt to characterize fair testing. For convenience, we say that a state performing ω is successful. P fair o means that, from every state in any maximal computation from P | o, a successful state can always be reached after finitely many interactions of live actions. It follows that, whenever there is a maximal computation from P | o where a state Ti cannot lead to success at all (Pfa/ iro), any fair scheduling policy will always fail in attempt to obtain a successful state from Ti.
Indeed, there also exist experiments that satisfy the fair testing predicate and can perform some maximal unsuccessful computations. Consider, for instance, P := c¯ | !c.(νa)(a¯ | a.c¯ | a.¯b) and o := b.ω. Denote Q2 := (νa)(a¯ | a.c¯ | a.¯b). In the following
(infinite) unsuccessful computation

P | o =
c¯ | !c.Q2 | ρ
−τ→ Q2 | !c.Q2 | ρ
−τ→ (νa)(a.¯b) | c¯ | !c.Q2 | ρ
−τ→ ... 

−τ→ (νa)(a.¯b) | ... | (νa)(a.¯b) | c¯ | !c.Q −τ→ ... 
ω is always prefixed and its prefix will never be performed, since any occurrence of
¯b is prefixed in a deadlock term (νa)(a.¯b). Notice that this computation is strong-
fair, since strong fairness imposes that, after finitely many interactions, any action has to be either performed or disabled forever. Since the prefix b in b.ω is initially disabled, and keeps on being disabled forever, the computation is also unsuccessful, even if every state could perform ω after finitely many interactions. So, strong fairness gives to each live action only a finite number of chance to be performed and strong-fair must semantics does not admit unsuccessful maximal computations, while fair testing also admits unfair and unsuccessful maximal computations.
The following result emphasizes the reason behind the impossibility of char- acterizing strong-fair and weak-fair must semantics in terms of a fair testing-like semantics on the basis of the transition tree only.
Theorem 7.1 It is not possible to characterize sfmust and wfmust in terms of a fair testing-like semantics on the basis of the transition tree only.
Proof. Given
P := (νc)(c¯ | !c.(c¯ | a¯)) | (νc)(c¯ | !c.c¯)

and

Q := (νx)(x¯a | (νb)(¯b | x¯b) | !x(y).(y¯ | x¯y)) | (νc)(c¯ | !c.c¯),

fairness assumptions distinguish P and Q: in fact, every strong (weak)-fair com- putation from P forces the execution of a¯, sooner or later. This is not the case of some strong (weak)-fair computations from Q: occurrences of x¯a and x¯b compete
to be performed infinitely often and, denoting by ¯bi (i ≥ 1) the parallel composition
of i occurrences of ¯b, (νb)(¯bi+1| x¯b) is generated instead of (a¯ | x¯a) whenever one occurrence of x¯b in (νb)(¯bi|x¯b) is performed. That is the fairness constraint has not effect anymore. It follows that P and Q are neither sfmust nor wfmust equivalent,
i.e. there exists some observer o that distinguishes P and Q w.r.t. both sfmust and wfmust . However, if we only consider transitions out of the terms P and Q, they are even strong bisimilar. It follows that (P | o) e (Q | o) are strong bisimilar, for every observer o. We conclude that a fair testing definition can not distinguish P and Q.	 

Related work
Fairness is a key concept in systems modeling and verification. Different kinds of fairness have been proposed in process algebras (see, for instance, [12]). In this paper we adopt the definitions of weak and strong fairness proposed for CCS-like languages by Costa and Stirling in [9,10], to the π-calculus. An important result stated in [9,10] characterizes fair computations as the concatenation of certain finite sequences, called LP-steps that permits to think of fairness in terms of a ‘localizable property’ and not as a property of complete maximal executions. Almost simulta- neously, two groups of authors [19], [3] have come up with the so-called fair testing. They proposed two equivalent testing semantics with the property of abstracting from ‘certain’ divergences in contrast to the classical must testing. The idea is to modify the classical definition of must testing in such a way that the success can always be reached after finitely many steps. Both groups of authors present alter- native characterizations of the new fair testing semantics. In [4], the framework described in [3] is extended to consider a set of sound axioms for fair testing and with more examples showing the usefulness of the new semantics. Another interest- ing paper is [8], where the authors generate a natural hierarchy of equivalences for asynchronous name-passing process calculi based on variations of Milner and San- giorgi’s weak barbed bisimulation. The considered calculi (based on π-calculus and join calculus) are asynchronous in the sense of [13]. After defining a particular class of contexts, called evaluation contexts - contexts with only one hole and unguarded
- they prove that barbed congruence coincides with Honda and Yoshida’s reduction
equivalence and, when the calculus includes name matching, with asynchronous labeled bisimulation. They also show that barbed congruence is coarser than reduc- tion equivalence when only one barb is tested. By combining simulation coupling and barbed properties, they prove that every coupled barbed equivalence strictly implies fair testing equivalence. They show that both relations coincide in the join calculus and on a restricted version of the π-calculus where reception occurs only

on names bound by a restriction (not on free names and not on received names). In [15], Koomen explains fairness with probabilistic arguments: Fair Abstraction Rule says that no matter how small the probability of success, if you try often enough you will eventually succeed. The probabilistic intuitions motivating this rule are formalized in [20], where the authors define a probabilistic testing semantics which can be used to alternatively characterize fair testing. The key idea is to define this new semantics in such a way that two non-probabilistic processes are fair-equivalent if and only if any probabilistic version of both processes are equivalent in the prob- abilistic testing semantics. In order to get this result, the authors define a simple probabilistic must semantics, by saying that a probabilistic process must satisfy a test if and only if the probability with which the process satisfies the test equals
1. The subject of fairness in probabilistic systems has been widely discussed in the literature; Pnueli [21] introduces the notion of extreme fairness and α-fairness, to
abstract from the precise values of probabilities.
Conclusion and future work
In this paper, we define a labeled version of the π-calculus [18], importing techniques in [9,10] for CCS-like languages. We compare weak and strong fairness and prove that both notions of fairness are not enough to characterize fair testing semantics and we state the main reason of this failure. The results scale to the asynchronous π-calculus [2] and do not depend on the proposed labeling method. As a future work, we plan to investigate on the existence of alternative characterizations of the investigated fairness notions, allowing simple and finite representations of fair computations such as the use of regular expressions as in [6,7]. It is also interesting to investigate on the impact that these different notions of fairness have on the encodings from the π-calculus into the asynchronous π-calculus [5].

References
Boreale, M. & De Nicola, R., Testing Equivalence for Mobile Processes, Information and Computation,
120 (1995), 279-303.
Boudol, G., “Asynchrony and the π-calculus”, Technical Report 1702, INRIA, Sophia-Antipolis (1992).
Brinksma, E., Rensink, A. & Vogler, W., Fair Testing, Proc. of CONCUR’95, LNCS, 962 (1995), 313- 327.
Brinksma. E., Rensink, A. & Vogler, W., “Applications of Fair Testing”, In “Protocols Specification, Testing and Verification” (XVI), Chapman & Hall (1996), 145-160.
Cacciagrano, D., Corradini, F. & Palamidessi, C., Separation of Synchronous and Asynchronous Communication Via Testing, Proc. of EXPRESS’05, ENTCS, 154(3)(2006), 95-108. To appear in Theoretical Computer Science.
Corradini, F., Di Berardini, M.R. & Vogler, W., Relating Fairness and Timing in Process Algebra, Proc. of Concur’03, LNCS, 2761 (2003), 438-452.
Corradini, F., Di Berardini, M.R. & Vogler, W., Fairness of Components in System Computations, ENTCS, 128(2) (2005), 35-52.
Fournet, C. & Gonthier, G., A Hierarchy of Equivalences for Asynchronous Calculi, Proc. of ICALP’98 (1998), 844-855.


Costa, G. & Stirling, C., A Fair Calculus of Communicating Systems, Acta Informatica, 21 (1984), 417-441.
Costa, G. & Stirling, C., Weak and Strong Fairness in CCS, Information and Computation, 73 (1987), 207-244.
Francez, N., “Fairness”, Springer-Verlag (1986).
Hennessy, M., An Algebraic Theory of Fair Asynchronous Communicating Processes, Theoretical Computer Science, 49 (1987), 121-143.
Honda, K.& Tokoro, M., An Object calculus for Asynchronous Communication, Proc. of ECOOP ’91, LNCS, 512 (1991), 133-147.
Honda, K. & Yoshida, N., Replication in Concurrent Combinators, Proc. of TACS ’94, LNCS, 789
(1994).
Koomen, C., Albegraic Specification and Verification of Communications protocols, Science of Computer Programming, 5 (1985), 1-36.
Lehmann, D., Pnueli, A. & Stavi, J., Impartiality, justice and Fairness:the Ethics of Concurrent Termination, Proc. of 8th Int. Colloq. Aut. Lang. Prog., LNCS, 115 (1981), 264-277.
Milner, R., “Communication and Concurrency”, Prentice-Hall International (1989).
Milner, R., Parrow, J. & Walker, D., A Calculus of Mobile Processes, Part I and II, Information and Computation, 100 (1992), 1-78.

Natarajan, V. & Cleaveland, R., Divergence and Fair Testing, Proc. of ICALP ’95, LNCS, 944 (1995), 648-659.
Nu´n˜ez, M. & Rup´erez, D., Fair testing through probabilistic testing, Acta Informatica, 19 (1983), 195- 210 . Protocol Specification, Testing, and Verification, 19 (1999), Kluwer Academic Publishers, 135-150.
Pnueli, A., On the Extremely Fair Treatment of Probabilistic Algorithms, Proc. of ACM Symph. Theory of Comp. (1983), 278-290 .
Queille, J.P. & Sifakis, J., Fairness and Related Properties in Transition Systems-A Temporal Logic to Deal with Fairness, Acta Informatica, 19 (1983), 195-210.

Appendix A: a labeled version of the π-calculus
This appendix section contains intermediate results and proofs of the statements omitted in Section 4. Several proofs follow the same lines as the corresponding results in [10].
Lemma 9.1 Let E ∈ Pe. Then top(E) ⊆ lab(E).
Proof. By induction on the structure of E.
- E = 0: top(0) = ∅ and lab(0) = ∅;
- E = L⟨s,n⟩(μ.P ): top(E)= {⟨s, n⟩} and lab(E)= {⟨s, n⟩} ∪ lab(L⟨s,n+1⟩(P ));
E = (E1 | E2): then top(E1 | E2) = top(E1) ∪ top(E2) and lab(E1 | E2) = lab(E1) ∪ lab(E2). By induction top(E1) ⊆ lab(E1) and top(E2) ⊆ lab(E2). Hence top(E1 | E2) ⊆ lab(E1 | E2);
- E =!⟨s,n⟩x(y).P : then top(E)= {⟨s, n⟩} = lab(E);
Case E = (νx)E' can be proven similarly.
 

Lemma 9.2 Let E = L⟨r,m⟩(P ), for some P ∈ P . Then ∀⟨s, n⟩ ∈ lab(E), r ≤ s
and m ≤ n.
Proof. By induction on the structure of P .
- E = 0: then lab(0) = ∅;
- E = L⟨r,m⟩(μ.P ): then lab(E)= {⟨r, m⟩} ∪ lab(L⟨r,m+1⟩(P ));
- E = L⟨r,m⟩(P1 | P2): lab(L⟨r,m⟩(P1 | P2)) = lab(L⟨r0,m⟩(P1)) ∪ lab(L⟨r1,m⟩(P2)). By induction, ∀⟨s1, n1⟩ ∈ lab(L⟨r0,m⟩(P1)), r ≤ r0 ≤ s1 and m ≤ n1. Analogously,
∀⟨s2, n2⟩∈ lab(L⟨r1,m⟩(P2)), r ≤ r1 ≤ s2 and m ≤ n2.
- E =!⟨r,m⟩x(y).P : then lab(E)= {⟨r, m⟩};
Case E = L⟨r,m⟩((νx)P ) can be proven similarly.

Lemma 9.3 ∀P ∈ P, ∀r ∈ {0, 1}∗ and ∀n ∈ N, wf (L⟨r,m⟩(P )).
Proof. By induction on the structure of P .
P = 0, μ.P ', !x(y).P ': these cases are trivial;
- P = P0 | P1: then L⟨r,m⟩(P0 | P1) = L⟨r0,m⟩(P0) | L⟨r1,m⟩(P1) and by Lemma 9.2 on top(L⟨ri,m⟩(Pi)) we have that ∀⟨si, ni⟩ ∈ top(L⟨ri,m⟩(Pi)), ri ≤ si and m ≤ ni (i ∈ {0, 1}). Hence top(L⟨r0,m⟩(P0)) ঩ top(L⟨r1,m⟩(P1));
P  = (νx)P ': then L⟨r,m⟩(P ) = (νx)L⟨r,m⟩(P '), where wf (L⟨r,m⟩(P ')).  Hence
wf (L⟨r,m⟩(P )).
 
Lemma 9.4 Let E ∈ Pe. Then ∀⟨s, n⟩∈ lab(E), ∃⟨r, m⟩∈ top(E) such that r ≤ s
and m ≤ n.
Proof. By induction on the structure of E.
- E = 0: top(0) = ∅ and lab(0) = ∅;
E = L⟨s,n⟩(μ.P '): then top(E)= {⟨s, n⟩}. It is enough to apply Lemma 9.2;
E = (E1 | E2): then top(E1 | E2)= top(E1) ∪ top(E2) and lab(E1 | E2)= lab(E1) ∪ lab(E2). By induction, ∀⟨s1, n1⟩ ∈ lab(E1), ∃⟨r1, m1⟩ ∈ top(E1) s.t. r1 ≤ s1 and m1 ≤ n1; analogously ∀⟨s2, n2⟩ ∈ lab(E2), ∃⟨r2, m2⟩ ∈ top(E2) s.t r2 ≤ s2 and m2 ≤ n2;
Case E = (νx)E' can be proven similarly;
- E =!⟨s,n⟩x(y).P : then top(E)= {⟨s, n⟩} = lab(E).


Lemma 9.5 Let E ∈ Pe such that E  μ
E'. Then:

∀⟨r', m'⟩∈ top(E'), ∃⟨r, m⟩∈ top(E) such that r ≤ r' and m < m';
∀⟨s', n'⟩∈ lab(E'), ∃⟨s, n⟩∈ lab(E) such that s ≤ s' and n < n'.
E' ∈ Pe;

Proof.
μ
By induction on the depth of E −→

E'.

Rule Input/Output/Tau: E = L

⟨s,n⟩
(μ.P ') μ
E'' = L

⟨s,n+1⟩
(P '') (either P '' =

P ' or P '' = P '{z/y}). It suffices to notice that top(L⟨s,n⟩(μ.P ')) = {⟨s, n⟩} and
to apply Lemma 9.2 on top(E'');

Rule Par: E = (E
μ
| E )
(E'
| E ), where bn(μ) ∩ fn(E ) = ∅.  Since

1	2	−→	1	2	2

wf (E
| E ), then wf (E ), wf (E ) and top(E )঩top(E ), then E
μ  E'
and,

1	2	1	2
1	2	1 −→	1

by induction, ∀⟨r' , m' ⟩ ∈ top(E' ), ∃⟨r1, m1⟩ ∈ top(E1) such that r1 ≤ r'
and

1	1	1	1
m1 < m' . Since top(E' | E2)= top(E' ) ∪ top(E2), then ∀⟨r'', m''⟩∈ top(E' | E2),
1	1	1	1
∃⟨r˜, m˜ ⟩∈ top(E) such that r˜ ≤ r'' and m˜ < m'';
Rule Open/Res/Com/Close: These cases can be proven similarly.

Rule Bang: !⟨s,n⟩
x(y)P ' −x→z
L⟨s0,n+1⟩
(P '{z/y}) | !⟨s1,n+1⟩
x(y).P '. Then we have

top(!⟨s,n⟩x(y).P ')= {⟨s, n⟩} and top(L⟨s0,n+1⟩(P '{z/y})|!⟨s1,n+1⟩x(y).P ')= {⟨s1, n+
1⟩}∪top(L⟨s0,n+1⟩(P '{z/y})). It suffices to apply Lemma 9.2 on top(L⟨s0,n+1⟩(P '{z/y})).
∀⟨r', m'⟩ ∈ top(E'), ∃⟨s, n⟩ ∈ top(E) such that s ≤ r' and n < m'; since top(E') ⊆ lab(E') and ∀⟨s', n'⟩ ∈ lab(E'), ∃⟨r', m'⟩ ∈ top(E') such that r' ≤ s' and m' < n' (Lemma 9.4), it follows that ∀⟨s', n'⟩∈ lab(E'), ∃⟨s, n⟩∈ top(E) such that s ≤ s' and n < n'. Hence, ∀⟨s', n'⟩ ∈ lab(E') ∃⟨s, n⟩ ∈ lab(E) such that s ≤ s' and n < n'.

We prove that wf (E') holds, by induction on the depth of E  μ
E'.

Rule Input/Output/Tau: E = L

⟨s,n⟩
(μ.P ') μ
E'' = L

⟨s,n+1⟩
(P '') (either P '' =

P ' or P '' = P '{z/y}). By Lemma 9.3, wf (L⟨s,n+1⟩(P ''));

Rule Par: E = (E
μ
| E )
(E'
| E ), where bn(μ) ∩ fn(E ) = ∅.  Since

1	2	−→	1	2	2

wf (E
μ
| E ), then top(E )঩top(E ). Then E	E' and, by induction, wf (E' );

1	2	1	2
1 −→	1	1

by (i), ∀⟨r' , m' ⟩ ∈ top(E' ), ∃⟨r1, m1⟩∈ top(E1) such that r1 ≤ r' and m1 ≤ m' .
1	1	1	1	1
Since ∀⟨r1, m1⟩∈ top(E1), ∀⟨r2, m2⟩∈ top(E2) we have r1 /≤ r2 and r2 /≤ r1, then
∀⟨r' , m' ⟩ ∈ top(E' ), ∀⟨r2, m2⟩ ∈ top(E2) we have r' /≤ r2 and r2 /≤ r' , that is
1	1	1	1	1
top(E' ) ঩ top(E2). Hence wf (E' | E2);
1	1
Rule Open/Res/Com/Close: These cases can be proven similarly.
Rule Bang: it suffices to recall that top(L⟨s0,n+1⟩(P '{z/y})|!⟨s1,n+1⟩x(y).P ') =
{⟨s1,n + 1⟩} ∪ top(L⟨s0,n+1⟩(P '{z/y})).



Lemma 4.5 Let E ∈ Pe. Then:
No label ⟨s, n⟩ occurs more than once in E;

μ
If E −→
E' then ∃⟨s, n⟩∈ lab(E): ⟨s, n⟩ /∈ lab(E');

μ1	μ2
∀k ≥ 1 : E	E	E
μ3	... μk
E , if ⟨s, n⟩ ∈ lab(E) ∩ lab(E
) then

−→	1 −→
2 −→
−→	k	k

⟨s, n⟩∈ 
lab(Ei), where i ∈ [1..(k − 1)].

Proof.
By induction on the structure of E.
- E = 0: then lab(0) = ∅;
E = L⟨s,n⟩(μ.P '): then lab(E) = {⟨s, n⟩} ∪ lab(L⟨s,n+1⟩(P ')).	By induction
∀⟨s', n'⟩∈ lab(L⟨s,n+1⟩(P ')), ⟨s', n'⟩ does not occur more than once in lab(L⟨s,n+1⟩(P ')). Moreover, by Lemma 9.2 ∀⟨s', n'⟩∈ lab(L⟨s,n+1⟩(P ')), s ≤ s' and n+1 ≤ n'. Hence
⟨s, n⟩ /∈ lab(L⟨s,n+1⟩(P '));
E = (E1|E2): then lab(E)= lab(E1)∪lab(E2). By induction, ∀i ∈ {⟨1, 2⟩}∀⟨si, ni⟩∈ lab(Ei), ⟨si, ni⟩ does not occur more than once in lab(Ei). Since ∀i ∈ {⟨1, 2⟩}, ∀⟨si, ni⟩∈ lab(Ei), ∃⟨ri, mi⟩∈ top(Ei) such that ri ≤ si and mi ≤ ni and top(E1) ঩ top(E2),
then ∀⟨s1, n1⟩ ∈ lab(E1), ∀⟨s2, n2⟩ ∈ lab(E2), ⟨s1, n1⟩ /= ⟨s2, n2⟩.  Hence ∀i ∈
{⟨1, 2⟩}, ∀⟨si, ni⟩∈ lab(Ei), ⟨si, ni⟩ does not occur more than once in lab(E);
Cases E = (νx)E' and E =!⟨s,n⟩x(y).P ' can be proven similarly.

μ
It suffices to prove that E −→
E' implies ∃⟨s, n⟩∈ top(E) s.t. ⟨s, n⟩ /∈ top(E').

μ
By induction on the depth of E −→
Rule Input/Output/Tau: E = L
E'.
(μ.P ') μ

E'' = L

(P '') (either P '' =

⟨s,n⟩	−→
⟨s,n+1⟩

P ' or P '' = P '{z/y}). Since top(L⟨s,n⟩(μ.P ')) = {⟨s, n⟩} and, by Lemma 9.2,
∀⟨s', n'⟩ ∈ top(L⟨s,n+1⟩(P '')), s ≤ s' and n +1 ≤ n', we have that ⟨s, n⟩ /∈
top(L⟨s,n+1⟩(P ''));

Rule Par: E = (E
μ
| E )
(E'
| E ), where bn(μ) ∩ fn(E ) = ∅.  Then

E	μ	'
1	2	−→	1	2	2
'

1 −→ E1 and, by induction, ∃⟨r1, m1⟩ ∈ top(E1) : ⟨r1, m1⟩ /∈ top(E1). Since
⟨r1, m1⟩ /∈ top(E2), then ⟨r1, m1⟩ /∈ top(E' | E2);
Rule Open/Res/Com/Close/Bang: These cases can be proven similarly.
The statement can be proven by induction on k. If k = 1, the statement holds by definition. If k = 2, the proof proceeds by induction on the depth of the derivation
μ2	μ2
E1 −→ E2, applying item (2) of Lemma 9.5 on E1 −→ E2, and applying item (2)
μ1
of the current lemma on E −→ E1.
Appendix B: comparing testing semantics and fairness policies
This appendix section contains intermediate results and proofs of the statements omitted in Section 5.
Weak fairness and strong fairness
Proposition 9.6 For every labeled experiment S ∈ Ee, every strong-fair computa- tion from S is weak-fair, but not the vice versa.
Proof. The positive result is trivial, since strong fairness is a special case of weak
fairness. To prove the negative result, consider E =!v0 a | (νb)(¯b 0 | ! 0 b.(a¯ | ¯b)),
1	v2	v3

ρ = a 0 .ω and the maximal computation (we omit 0 term by convenience)
4
C ::= E | ρ = S0 −τ→ S1 −τ→ S2 −τ→ ... −τ→ Si −τ→

where ∀j ≥ 0, Q2(vj
) := (νb)(¯b j | ! j b.( a¯ | ¯b)) and

2,3
v2	v3

S0 =!v0 a | Q2(v0 ) | av0 .ω	... 
1	2,3	4
S1 =!v0 a | a¯v1 | Q2(v1 ) | av0 .ω	Si =!vi a | Q2(vi−1) | av0 .ω
1	5	2,3	4	1	2,3	4
S2 =!v2 a | Q2(v1 ) | av0 .ω	Si+1 =!vi a | a¯ i+1 | Q2(vi+1) | av0 .ω

1	2,3	4
1	v5
2,3	4

S3 =!v2 a | a¯v3 | Q2(v3 ) | av0 .ω	Si+2 =! i+2 a | Q2(vi+1) | av0 .ω
1	5	2,3	4	v1	2,3	4
S4 =!v4 a | Q2(v3 ) | a 0 .ω	... 
1	2,3	v4

Notice that, in C, we have v0
/∈ Lp(S0), v0
∈ Lp(S1), v0
/∈ Lp(S2), v0
∈ Lp(S3),

... , v0
/∈ Lp(Si), v0
∈ Lp(Si+1), v0
/∈ Lp(Si+2),... and so on.  Moreover ∀v ∈

Lp(Sj), where v /= v0, there exists k > j such that v /∈ Lp(Sk). It follows that C is weak-fair but it is not strong-fair.	 
Proposition 9.7 For any labeled experiment S there is a strong-fair computation out of S.
Proof. It suffices to prove that ∀S ∈ Ee
Lp(S) is a finite set;

S −
τ→ implies Lp(S)= ∅;

v ∈ Lp(S) implies ∃S' ∈ Ee such that S  μ  S'
and for any S''
such that S
' =ε⇒ S'',

v /∈ Lp(S'');
∃S' ∈ Ee

ε⇒ S', Lp(S) ∩ Lp(S')= ∅ and ∀ ''

'	⇒ε

S'',

such that S =
Lp(S) ∩ Lp(S'')= ∅.
S  such that S =

We recall that ∀S ∈ Ee, Lp(S) ⊆ top(S) ⊆ lab(S). Items (a) and (b) are trivial. Consider Item (c). S' is the term obtained from S by performing the action labeled
by v: by Lemma 4.5 , v /∈ lab(S') and ∀S'' such that S' =ε⇒ S'', v /∈ lab(S''). Hence
v /∈ Lp(S') and ∀S'' such that S' =ε⇒ S'', v /∈ Lp(S'').
To prove item (d) it suffices to apply the previous item, where μ = τ . S' is the term obtained from S by performing any v ∈ Lp(S) and such that ∀v ∈ Lp(S), ∀S'' :
S' =ε⇒ S'' either v /∈ lab(S') (following that v /∈ lab(S'')) or v /∈ Lp(S'') and
v ∈ lab(S'). In both cases, Lp(S) ∩ Lp(S') = ∅ and Lp(S) ∩ Lp(S'') = ∅. Since
Lp(S) is finite, such S' exists.

Now, we can prove the main statement. If S −
τ→, then the empty computation

is strong-fair, since Lp(S)= ∅. Otherwise, there exists a maximal computation C

S = S
−τ→ S1 −τ→ .. −τ→ Sn0 −τ→ S [−τ→ S1 −τ→ .. −τ→ Sn1 −τ→ S
−τ→ .. .]

0	0	0	1	1	1	2
where ∀i ≥ 0, Lp(Si) ∩ Lp(Si+1)= ∅ and ∀j ≥ i, Lp(Si) ∩ Lp(Sj)= ∅. Suppose, by contradiction, that C is not strong-fair: then there exists a label v such that ∀i ≥ 0,
∃j ≥ i : v ∈ Lp(S˜), where either S˜ = Sj or S˜ = Sk, contradicting the hypothesis on

C.	 

Must and fair testing semantics
Proposition 9.8 Let P ∈У and o ∈ 0. Then P must o implies P fair o.
Proof. By contradiction, suppose Pfa/ iro, that is there exists a maximal computation from P | o
C ::= P | o = T —τ→ T —τ→ ... —τ→ T [—τ→ .. .]
such that Ti /=ω⇒ for some i ≥ 0, i.e. 6T ' : Ti =ε⇒ T ' it holds that T ' /—ω→. It
follows that Ti /—ω→, 6j ∈ [0..(i — 1)], Tj /—ω→ and 6h ≥ i, Th /—ω→, by hypothesis on Ti. In fact, since ω does not appear in a choice operator and can not synchronize, it does not disappear once it is at the top level of a term. It follows that the above computation C is such that 6j ≥ 0, Tj /—ω→, i.e. P must o.	 
Proposition 9.9 There exist P ∈У and o ∈0 s.t. P fair o but P must o.
Proof. Consider P ::= (νa)(a¯ | !a.a¯) | ¯b and o ::= b.ω. Since (νa)(a¯ | !a.a¯) —τ→ (νa)(a¯ | !a.a¯) —τ→ ... (we omit 0 term by convenience), there is an unsuccessful max computation from P |o, i.e. Pmusto. However, P fairo, since every max computation from P | o
C ::= P | o = T —τ→ T —τ→ ... —τ→ T —τ→ ... 
is such that either 6i ≥ 0, Ti = (νa)(a¯ | !a.a¯) | ¯b | b.ω or Ej ≥ 1 such that Tj =
(νa)(a¯ | !a.a¯) | ω —ω→ and 6i ∈ [0..(j — 1)], Ti = (νa)(a¯ | !a.a¯) | ¯b |	i  ε⇒ Tj. 

Weak-fair must and strong-fair must testing semantics

Theorem 6.2 For every E ∈ Уe and ρ ∈ 0e, then
E wfmust ρ implies E sfmust ρ, but
there is E ∈ Уe and ρ ∈ 0e, such that E sfmust ρ and E wf/ must ρ.
Proof. Consider the first item. Suppose, by contradiction, that there exists a strong-fair computation
C ::= E | ρ = S0 —τ→ S1 —τ→ ... —τ→ Si [—τ→ .. .]
such that 6i ≥ 0, Si /—ω→. Since a strong-fair computation is weak-fair too, then C
is weak-fair. It follows that E wf/ must ρ, contradicting the hypothesis.

Consider the second item. Consider again E =!v0 a | Q2(v0
) and ρ = av0 .ω, where

Q2(vj
) := (νb)(¯b j |! j b.(a¯ | ¯b)).
1	2,3	4

2,3
v2  v3

Notice that the computation where v0 /∈ Lp(S0), v0 ∈ Lp(S1), v0 /∈ Lp(S2), v0 ∈
4	4	4	4
Lp(S3), .., v0 /∈ Lp(Si), v0 ∈ Lp(Si+1), v0 /∈ Lp(Si+2), .. and so on, is unsuccessful,
4	4	4
0	ω
since v4 loses its liveness without being performed: in such a case 6i ≥ 0, Si /—→. It
follows that E wf/ must ρ.

To prove E sfmust ρ, it suffices to notice that 6vi	∈ ({0, 1}∗ × N),

Q (vi
) —τ→
a¯ i+1 | Q (vi+1); that is Q (vi
) can perform infinite sequences of

2  2,3
v5	2
2,3
2  2,3

τ steps, becoming itself (equipped by new labels) in parallel with a component
a¯ i+1 ;
5

Q2(vi
) can not synchronize with any parallel component;

for every maximal computation from E | ρ
C' ::= E | ρ = S0 —τ→ S1 —τ→ ... —τ→ Si [—τ→ .. .]
there always exists S1 =!v0 a | a¯v1 | Q2(v1 ) | av0 .ω;
1	5	2,3	4
v0 /∈ Lp(S0), v0 ∈ Lp(S1) and v0 ∈ Lp(Si) for every Si in C where there exists a

4
a¯ i
5
4	4
component in parallel.

By Q2(vi
) properties, there exist infinite indexes i, j,... such that an output a¯ k
5

is available in Si, Sj,.. .; it follows that v0 can be live infinitely often. But this is
not possible if C' is a strong-fair computation: in fact, by definition, v0 will lose its liveness forever, i.e. v0 will be performed. In such a case there will be j ≥ 0 in C'
ω	4
such that Sj —→.	 

Weak-fair must, strong-fair must and must testing semantics
The following propositions prove item (i) of Theorem 6.3.
Proposition 9.10 Let E ∈ Уe, ρ ∈ 0e. Then Unl(E)mustU nl(ρ) implies Ewfmustρ.
Proof. By contradiction, suppose there is a weak-fair computation from E | ρ
C ::= E | ρ = S0 —τ→ S1 —τ→ ... —τ→ Si [—τ→ .. .]
such that 6i ≥ 0, Si /—ω→. Then there exists the following maximal computation
C' ::= Unl(E | ρ)= Unl(S ) —τ→ Unl(S ) —τ→ ... —τ→ Unl(S ) [—τ→ .. .]
where 6i ≥ 0,Unl(Si) /—ω→, i.e. Unl(E)must Unl(ρ).	 
Proposition 9.11 There exist E ∈ Уe and ρ ∈ 0e such that E wfmust ρ but
Unl(E) must Unl(ρ).
Proof. Consider E ::= (νa)(a¯v0 | !v0 a.a¯) | ¯b 0 and ρ ::= bv0 .ω. We omit 0 terms
1	2	v3	4
by convenience. Notice that E wfmust ρ, since in every weak-fair computation from
E | ρ
C ::= E | ρ = S0 —τ→ S1 —τ→ ... —τ→ Si —τ→ ... 
there has to exist j ≥ 1 such that Sj = (νa)(a¯ j | ! j a.a¯) | ω —ω→ and 6i ∈ [0..(j —
v1	v2
1)], Si = (νa)(a¯ i | ! i a.a¯) |¯b i | bv0 .ω. It follows by the fact that 6i ∈ [0..(j — 1)], v0 ∈
v1  v2	v3	4	4
Lp(Si) and there has to exist j ≥ i such that v0 /∈ Lp(Sj). It is possible only in
the case bv0 .ω synchronizes with ¯b j−1 in Sj−1. However, Unl(E) must Unl(ρ) (see
4	v3
Proposition 9.9).	 
The following corollary proves item (ii) of Theorem 6.3.

Corollary 9.12 Let E ∈ Уe, ρ ∈ 0e. Then Unl(E) must Unl(ρ) implies E sfmust ρ, but not the viceversa.
Proof. The positive result follows by Proposition 9.10 and by Theorem 6.2. The negative result follows by Proposition 9.11 and by Theorem 6.2	 

Weak-fair must, strong-fair must and fair testing semantics
The following propositions prove item (ii) of Theorem 6.4. We give a preliminary lemma for proving Proposition 9.14.
Lemma 9.13 Let S ∈ Ee and S = S —τ→ S —τ→ ... —τ→ S [—τ→ .. .] be a strong-
fair computation from S. If ES' , S' , S' ,... , S' ∈ Ee such that
0	1	2	n

S' = S' —τ→ S' —τ→ ... —τ→ S'
= S, then

0	1	n

S' —τ→ S' —τ→ ... —τ→ S' —τ→ S —τ→ ... —τ→ S
[—τ→ .. .]

1	n	1	i
is a strong-fair computation from S'.

Proof. Consider C ::= S' —τ→ S'
—τ→ ... —τ→ S'
τ	'
n+1
—τ→ ... —τ→ S'
[—τ→

.. .], where 6j ≥ 0, S'	::= Sj. Obviously C is a maximal computation from S'. To
prove that C is also strong-fair, it suffices to prove that 6⟨s, n⟩∈ ({0, 1}∗ ×N) Eh ≥ 0
such that 6k ≥ h, ⟨s, n⟩ /∈ Lp(S' ). Since S' —τ→ S'	—τ→ ... —τ→ S'	[—τ→ .. .] is
k	n	n+1	n+i
a strong fair computation from S' , then 6⟨s, n⟩ ∈ ({0, 1}∗ × N) Eh ≥ n such that 6k ≥ h, ⟨s, n⟩ /∈ Lp(S' ). Since n ≥ 0, 6⟨s, n⟩ ∈ ({0, 1}∗ × N) Eh ≥ 0 such that 6k ≥ h, ⟨s, n⟩ /∈ Lp(S' ). It follows that C is a strong-fair computation from S'. 
Proposition 9.14 Let E  ∈  Уe and ρ  ∈  0e.  Then E  sfmust ρ  implies
Unl(E) fair Unl(ρ).
Proof. By contradiction, suppose there exists a maximal computation from Unl(E)|Unl(ρ)
C ::= Unl(E) | Unl(ρ)= T —τ→ T —τ→ ... —τ→ T [—τ→ .. .]

and there exists i ≥ 0 such that Ti /=ω⇒, i.e. 6T ' such that Ti =⇒
T ', we have

T ' /—ω→. It follows that for every maximal computation from Ti
Ti = T ' —τ→ T ' —τ→ ... —τ→ T ' [—τ→ .. .]
0	1	j
' /—ω→ for every j. Moreover, by ω’s properties, 6j ∈ [0..(i — 1)], Tj /—ω→. Now,

consider

Ce ::= E | ρ = S0 —τ→ S1 —τ→ ... —τ→ Si [—τ→ .. .]

where 6k ≥ 0 we have Tk = Unl(Sk). Then there exists i ≥ 0 such that Si /=ω⇒,
i.e. 6S' such that Si =⇒ S', we have S' /—ω→. It follows that for every maximal
computation from Si
Si = S' —τ→ S' —τ→ ... —τ→ S' [—τ→ .. .]
0	1	j
' /—ω→ for every j. Hence for every strong-fair computation from Si, that always
exists and it is trivially a maximal computation from Si,
Si = S' —τ→ S' —τ→ ... —τ→ S' [—τ→ .. .]
0	1	j

S' /—ω→ for every j. It follows that, given a strong-fair computation from Si
Si = S'' —τ→ S'' —τ→ ... —τ→ S'' [—τ→ .. .]
0	1	j
where S'' /—ω→ for every j, by Lemma 9.13

E | ρ = S
—τ→ S —τ→ ... —τ→ S = S' —τ→ S'' —τ→ ... —τ→ S'' [—τ→ .. .]

0	1	i	0	1	j
is a strong fair computation from E | ρ, and both 6k ∈ [0..(i — 1)], Sk /—ω→ and
6j ≥ 0, S'' /—ω→. It follows that E sfmust ρ, contradicting the hypothesis.	 
Proposition 9.15 There exist E ∈ Уe, ρ ∈ 0e such that Unl(E) fair Unl(ρ) but
E sfmust ρ.
Proof. By simplicity, we consider the unlabeled terms obtained from E = c¯v0 |!v0 c.Q2
1	2
and ρ = bv0 .ω, where Q2 denotes (νa)(a¯ | a.c¯ | a.¯b). Then we have
Unl(E) fair Unl(ρ), but there exists the following maximal computation
Unl(E | ρ)= c¯ | !c.Q | ρ —τ→ Q | !c.Q | ρ —τ→ (νa)(a.¯b) | c¯ | !c Q | ρ —τ→ ... 
—τ→ (νa)(a.¯b) | ... | (νa)(a.¯b) | c¯ | !c.Q2 —τ→ ... 
where every term does not perform ω: ω is always prefixed in ρ and its prefix will never be consumed, since every occurrence of ¯b is prefixed in a deadlock term (νa)(a.¯b). Notice that this computation is strong fair: the prefix of omega is not performed because it is always disabled.	 
The following corollary proves item (i) of Theorem 6.4.
Corollary 9.16 Let E ∈ Уe and ρ ∈ 0e. Then E wfmust ρ implies
Unl(E) fair Unl(ρ) but not the vice versa.
Proof. The positive result follows by Theorem 6.2 and by Proposition 9.14. The negative result follows by Proposition 9.15 and by Theorem 6.2.	 
