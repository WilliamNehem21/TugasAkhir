Electronic Notes in Theoretical Computer Science 200 (2008) 25–41	
www.elsevier.com/locate/entcs

Reduction Semantics and Formal Analysis of Orc Programs
Musab AlTurki 1 Jos´e Meseguer 2
Department of Computer Science University of Illinois at Urbana-Champaign Urbana, IL 61801, USA

Abstract
Orc is a language for orchestration of web services developed by J. Misra that offers simple, yet powerful and elegant, constructs to program sophisticated web orchestration applications. The formal semantics of Orc poses interesting challenges, because of its real-time nature and the different priorities of external and internal actions. In this paper, building upon our previous SOS semantics of Orc in rewriting logic, we present a much more efficient reduction semantics of Orc, which is provably equivalent to the SOS semantics thanks to a strong bisimulation. We view this reduction semantics as a key intermediate stage towards a future, provably correct distributed implementation of Orc, and show how it can naturally be extended to a distributed actor-like semantics. We show experiments demonstrating the much better performance of the reduction semantics when compared to the SOS semantics. Using the Maude rewriting logic language, we also illustrate how the reduction semantics can be used to endow Orc with useful formal analysis capabilities, including an LTL model checker. We illustrate these formal analysis features by means of an online auction system, which is modeled as a distributed system of actors that perform Orc computations.
Keywords: Orc, rewriting logic, formal verification, real-time semantics, web services


Introduction
At present, the reliability of web-related software is poor, to say the least; and formal analysis is one of the most effective ways to increase the quality, reliability, and security of webware. For example, formal specification and model checking analysis of Internet Explorer has uncovered many, previously unknown, types of address-bar and status bar spoofing attacks [8]. There is however, a substantial gap between the level of the formal specifications readily amenable to analysis, and the low level implementations of webware in conventional languages. This gap can be narrowed by the use of model checkers for conventional languages such as Java or C, which may be a reasonably practical way, though hard to scale up, to verify legacy

1 Email: alturki@cs.uiuc.edu
2 Email: meseguer@cs.uiuc.edu

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.091

systems. But such a conventional approach to the design of webware is not, by any means, the best way to design and verify future web-based systems.
This work is part of a longer-term research effort to explore a new webware design and implementation approach based on two main ideas: (i) the systematic use of formal executable specifications in rewriting logic to precisely capture the intended semantics and to verify relevant properties; and (ii) the stepwise refinement of such specifications into a provably correct distributed implementation. It helps of course very much to begin with a type of webware that is mathematically elegant, simple, novel, and promising in its practical applications. We have focused on J. Misra’s Orc language, a simple and elegant language to orchestrate complex web services [21,22,14]. In spite of its inherent simplicity, the formal semantics of Orc presents interesting challenges. These challenges center around two main aspects of the Orc semantics: (i) the inherent priority that internal actions should have over external communication events; and (ii) the real-time nature of the language. In particular, a standard SOS semantics is insufficient to capture the intended Orc semantics [22,1]. In a previous paper [1], we have used rewriting logic to capture the intended semantics of Orc at the highest level possible, presenting an SOS-like rewriting se- mantics that does justice to Orc’s real-time features. In this work we take two steps towards the refinement of Orc specifications into a distributed implementa- tion.  Our first and most crucial step is the refinement of our original SOS-like
Orc semantics into a much more concurrent reduction semantics, which takes full
advantage of rewriting logic’s concurrent semantics, fully exploits rewriting logic’s crucial distinction between equations and rewrite rules. Our three main contribu- tions for this first step are: (i) showing how the real-time synchronous semantics of Orc can be faithfully captured in the reduction semantics; (ii) establishing the semantic equivalence between the reduction semantics and the SOS-like semantics; and (iii) providing experimental evidence for the claim that the reduction semantics is much more efficient than the SOS-like semantics.
The second refinement step is a simple, yet important extension of the first. The Orc semantics as such focuses on the, possibly concurrent, evaluation of a single Orc expression, abstracting away its interactions with external sites as “black boxes” in an external environment. It is however very natural to view both Orc expressions and sites as distributed objects, which interact with each other through message passing. Therefore, in this second refinement step we encapsulate both Orc expressions and sites as distributed objects, essentially reusing the already given reduction semantics in the semantic specification of Orc expression objects. All this can be done easily and naturally by using rewriting logic’s approach to distributed objects [17]. Although still a specification, this distributed object semantics brings the Orc refinement quite close to a future distributed implementation. Our work also shows how nontrivial formal analyses of relevant Orc applications can be carried out with good efficiency, even after these two steps of refinement. Specifically, we show how Maude’s LTL model checker can be used to verify the requirements of an online Orc auction system realized as a distributed collection of Orc expression and site objects.

The paper is organized as follows. Section 2 discusses related work and presents preliminaries on Orc, rewriting logic, and Maude. The reduction semantics is then presented in Section 3. Its further refinement into a distributed object-based se- mantics and the verification of an online auction case study are covered in Section
4. Conclusions and future work are discussed in Section 5.

Related Work and Preliminaries
Several Orc semantics have already been given. A precise but informal operational semantics for Orc was given by Misra in [21]; we consider this as the standard against which the success of any formal operational semantics should be measured. A formal SOS asynchronous operational semantics has been given by Misra and Cook in [22]; but since this asynchronous semantics allows some undesirable be- haviors, a refinement of the asynchronous semantics into a synchronous semantics, distinguishing between internal and external actions was also given in [22]. Differ- ent denotational semantics of Orc for reasoning about identities and algebraic laws about the language [13,14], and for formally analyzing dependencies in program execution [25] were also proposed. Moreover, encodings of Orc in Petri nets and the join calculus that reveal some of the subtleties of the semantics of the language were given in [5]. Most recently, Ian Wehrman et al. [27] proposed a relative-time operational semantics of Orc by extending the asynchronous SOS relation of [22] to timed events and time-shifted expressions.
Our work, along with some of the operational approaches cited above, has sim- ilarities with the various SOS semantics that have been given for different timed process calculi, such as ATP [23] and TLP [12], and real-time extensions to various process calculi, such as extensions of ACP [3,4], CCS [7], and CSP [26].

The Orc Programming Model
Orc is a theory of orchestration, proposed by J. Misra [21], to model the smooth integration of web services. The Orc model is fairly minimal, yet powerful enough to express a wide range of computations [22]. Orc is based on the abstract notion of sites and the composition of the services they provide. A site is a basic service that provides a computation of some kind. For instance, CNN (d) and BBC (d) are sites that return the news for the given date d, and add (x, y) is one that returns the sum of its arguments. Sites are assumed to exist, and the computations they provide constitute the data processed by Orc expressions. A site, when called, produces at most one value. When a site responds to a call with a value v, the site is said to publish the value v. Moreover, site calls are strict, in the sense that a site call cannot be initiated before its parameters are bound to concrete values.
There are six fundamental sites that are available to any Orc program. These sites and the services they provide are shown in Figure 1, assuming t is a non- negative integer, b is a boolean, and x and y are values of arbitrary types.
The extended Orc syntax we use here is given in Figure 2. An Orc program
consists of an optional list of declarations followed by an Orc expression. A dec-

let (x, y,... )	returns a tuple consisting of its argument values.
clock	returns the current time as a non-negative integer.
atimer (t)	returns a signal at time t.
rtimer (t)	returns a signal after t time units.
signal	returns a signal immediately.
if (b)	returns a signal if b is true; otherwise it remains silent.
Fig. 1. Fundamental sites in Orc


Fig. 2. Extended syntax of Orc



laration consists of a name, a (possibly empty) list of formal parameters, and an expression representing its body. An expression can be either: (1) the silent site (0), which is a site that never responds; (2) a site or an expression call having an optional list of actual parameters; (3) the publishing of a value or a variable; (4) a placeholder for an unfinished site call; or (5) the composition of two expressions by one of the three composition operators. Two expressions may be composed either sequentially with the sequencing operator > x >, or in parallel. Parallel com- position comes in two flavors: (1) symmetric composition, using |, where multiple threads execute concurrently returning a (possibly empty) stream of values; and (2) asymmetric composition, using the where statement, in which the left expression executes concurrently with possibly many threads of the right expression, choosing the first result published by any one of them.
A formal description of the (untimed) asynchronous semantics of Orc was given as an SOS specification in [22], and is shown here in Figure 3. The reader is referred to [22], for a detailed discussion of the specification. Here, only a few subtleties are emphasized. We first note that symmetric parallel composition f | g in Orc is similar to that of a process calculus in which both expressions f and g can evolve concurrently without any restriction. However, in asymmetric parallel composition g where x :∈ f , once f publishes its first value (the Asym1V rule), the remaining computations of f are discarded and the published value is bound to x in
g. Therefore, it is possible for some computations of g to be blocked waiting for a value for x. We also note that in sequential composition f > x > g, a new instance of g is created for every value published by f (the Seq1V rule), which generalizes the usual notion of sequential composition in sequential programming languages. For example, consider the following program, which can be found, among many


h fresh
M(c,h⟩

(SiteCall)
!c
f ‹→ f
τ	'

(Seq1V)

M (c)	‹→  ?h
h?c
f > x > g ‹→ (f
l
> x > g) | g{c/x}
'

?h ‹→ !c	(SiteRet)
‹→ f
l /= !c
(Seq1N)

!c
!c ‹→ 0
E(Q) =def f ∈ D
(Pub)
f > x > g ‹→ f'
!c	'
> x > g 

τ	(Def)
f ‹→ f
τ
(Asym1V)

E(P ) ‹→ f{P/Q}
g where x :∈ f ‹→ g{c/x}

f ‹→ f'
l	'
(Sym1)
f ‹→ f'	l /= !c
l

(Asym1N)

f | g ‹→ f | g
g where x :∈ f ‹→ g where x :∈ f'

‹→ g'


l	'
(Sym2)
g ‹→ g'
l

(Asym2)

f | g ‹→ f | g
g where x :∈ f ‹→ g' where x :∈ f



other examples, in [21,22].
Fig. 3. Asynchronous semantics of Orc


DelayedN =def (rtimer(1) > x > let(u)) where u :∈ N ;
let(x) where x :∈ (M | DelayedN)

The program implements a prioritized site call. Site M is given priority over site N , in that a response from M , if received within one time unit, would be the value published by the expression. Otherwise, either value published by M or N is published.

Rewriting Logic and Maude
Rewriting logic [16] is a general semantic framework that unifies in a natural way a wide range of models of concurrency. In particular, it is well suited to both give formal semantic definitions of programming languages, including concurrent ones (see [15,20] and references there), and to model real-time systems [24]. Furthermore, with the availability of high-performance rewriting logic implementations, such as Maude [10], language specifications can both be executed and model checked.
A rewrite theory is a formal description of a concurrent system, including its static state structure and its dynamic behavior. In its most general form, a rewrite theory is a 4-tuple R = (Σ, E, R, φ) with:
(Σ, E) a membership equational logic (MEL) theory [18], with Σ a MEL signature having a set of kinds, a family of sets of operators, and a family of disjoint sets of sorts, and E a set of Σ-sentences, which are universally quantified Horn clauses with atoms that are equations (t = t') and memberships (t : s), with t, t' terms and s a sort,
R a set of universally quantified labeled conditional rewrite rules of the form:

(∀X) r : t → t' if   pi = qi ∧  rj : sj ∧  wl → w'
i	j	l

where r is a label, t, t', pi, qi, rj, wl and w' are terms, and sj are sorts.
φ : Σ → P(N) a function that assigns to each operator symbol f in Σ of arity n > 0 a set of positive integers φ(f ) ⊆ {1,..., n} representing frozen argument positions where rewrites are forbidden.
A rule in R gives a general pattern for a possible change or transition in the state of a concurrent system. Changes are deduced according to the set of inference rules of rewriting logic, which are described in detail in [6]. Using these inference rules, a rewrite theory R proves a statement of the form (∀X) t → t', written as R ▶ (∀X) t → t', meaning that, in R, the state term t can transition to the state term t' in a finite number of steps. A detailed discussion of rewriting logic as a unified model of concurrency and its inference system can be found in [16]. [6] gives a precise account of the most general form of rewrite theories and their models.
Maude is a high-performance implementation of rewriting logic and its under- lying MEL sublogic, with syntax that is almost identical to the mathematical no- tation. A basic unit of specification in Maude can either be a functional module, corresponding to a MEL theory (Σ, E), or a system module, representing a rewrite theory (Σ, E, R, φ). Besides the ability to execute a system module’s specification (using the rewrite command) and to systematically search its state space (using the breadth-first search command), Maude provides an LTL model checker to ver- ify complex LTL safety and liveness properties about finite state systems. For a complete description of Maude and its features, the reader is referred to [9].

Reduction Semantics of Orc
In previous work [1], we have developed a formal semantics of Orc in rewriting logic based on the SOS specifications of Figure 3. The semantics was in some sense
a direct translation of the SOS specifications into a rewrite theory Rsos  using a
semantics-preserving MSOS-to-rewriting logic transformation [19]. Therefore, the
rewriting semantics given by Rsos is readily understandable and its correctness is
an immediate result of the correctness of the transformation used. However, Rsos makes extensive use of conditional rewrite rules (corresponding to the rules in the SOS specifications) which cannot be converted into equations without destroying the correctness of the semantics. Moreover, most of these rewrite rules, besides being conditional, have rewrites in their conditions, which is typical of the SOS specification style. In practice, this means that their execution, which uses breadth- first search to satisfy the rewrite conditions, is quite expensive and inefficient. In
addition, all the rules in Rsos are system-wide rules defined at the configuration
(state) level, forcing an interleaving semantics and not exploiting rewriting logic’s features to express concurrent computations.
In this section we develop a rewriting semantics specification of Orc that, unlike Rsos , is not based on the structural operational semantic rules of Figure 3, but is instead based on the inherently distributed semantics of rewriting logic. This
rewriting semantics is in the style of what is usually called reduction semantics, but
has the added advantage of using both equations and rules, thus achieving a simpler,

more flexible semantics and a smaller state space, since only transitions caused by rules create new states in the state space. The proposed specification, which we will henceforth call Rred , is still operational, in that it describes in detail how Orc programs are evaluated, and is, in fact, semantically equivalent to Rsos , in the sense that, given any Orc program P , the state transition systems of the semantics

of P given by Rsos
and Rred
are strongly bisimilar. However, by minimizing the

number of rewrite rules and reducing their complexity, we achieve a simpler and indeed superior semantic specification that can be executed and analyzed much more efficiently. Before discussing the rewriting semantics specifications, we briefly describe the semantics infrastructure required (see [2] for a detailed description).

Semantic Infrastructure
A state in the evolution of an Orc program is represented with an Orc configuration. A conﬁguration is a pair ⟨f, r⟩ with f an Orc program and r a record, which is a set of fields (built with an associative-commutative set union operator | ) repre- senting the different semantic entities required to correctly capture the semantics of f , such as environments and stores. By abstracting such semantic entities with the notion of fields, we obtain generality and modularity in the specification of lan- guage semantics, as explained in [19]. In particular, there are five fields in an Orc configuration, which are briefly described below.
Messages: The messages field is of the form (msg : ρ), where ρ is a pool (multiset) of messages in transit, modeling site calls generated by the expression component f of the configuration, and incoming site returns from the environment.
Context: The context field (con : σ) is an environment mapping expression names to expression definitions. An expression definition in σ may refer to names in the environment allowing definitions of (mutually) recursive Orc programs.
Handle: The handle field (hdl : hn) maintains the next available handle name hn, with n a natural number. By the SiteCall rule of Figure 3, fresh handle names need to be generated when site calls take place. Handle names serve as identifiers for pending site calls; a handle identifies which message in the message pool ρ belongs to a given unfinished site call in the Orc program f .
Trace: The trace field (tr : t) records a list of events t representing the transitions undergone by the Orc program 3 . The four event types are site calls, site returns, publishing of values, and the unobservable event τ .
Clock: The clock field (clk : cm) maintains a discrete time global clock modeled using the domain of natural numbers (m is a natural number). We shall see later in Section 3.4 how the clock field is used to give the timed semantics of Orc.
Therefore, based on the description given above, the general form of an Orc configuration is ⟨f, msg : ρ | con : σ | tr : t | hdl : hn | clk : cm⟩.

3 Unlike the SOS-based rewriting semantics of [1], the trace field is entirely optional for the semantics described in this paper. However, in order to preserve equivalence with the aforementioned semantics, we opt to keep this field in the specifications discussed in this section (see Section 3.5).

Rewrite Rules and Equations
We now specify the rewrite theory Rred


= (Σ, E, R, φ) using the above semantic

infrastructure. Rred captures four actions an Orc configuration can take: (1) calling
a site, (2) calling an expression, (3) publishing a value, and (4) returning a value from a site. In this section, we list and discuss all the rules R and some of the equations of E. A complete discussion of all the equations can be found in [2].
A common characteristic of the specifications of the actions mentioned above is the need to propagate information back and forth between a subterm of an Orc expression and the configuration it is contained within. This propagation of in- formation is specified using auxiliary functions that are defined inductively on the structure of an expression. In the following paragraphs, we describe these actions and auxiliary functions in some detail.
Site Call. A site call is modeled by the following two rewrite rules.
SiteCall : ⟨f, r⟩→ ⟨sc↑(f', M,C), r⟩ if f → sc↑(f', M,C)
SiteCall* : M (C) → sc↑(γ, M, C)
with γ a constant expression representing a temporary place holder expression. A site call subterm of an expression f rewrites to an operator (sc↑) that propagates the call to the root of f using, among others 4 , the following equations,
sc↑(f1, M,C) | f2 = sc↑(f1 | f2, M,C) if f2 /= 0,
sc↑(f1, M,C) > x > f2 = sc↑(f1 > x > f2, M,C),
sc↑(f1, M,C) where x :∈ f2 = sc↑(f1 where x :∈ f2, M,C), f2 where x :∈ sc↑(f1, M,C)= sc↑(f2 where x :∈ f1, M,C).
Once the root of the expression is reached, the effect of the call is reflected in the containing configuration, using the following equation,

⟨sc↑(f, M, C), tr : t | msg : ρ | hdl : hn | clk : cm | r⟩
= ⟨sc↓(f, hn), tr : t.M⟨C, hn | m⟩| msg : ρ[M, C, hn] | hdl : hn+1|clk : cm|r⟩

The effect comprises: (i) the emission of a message [M, C, hn] to the message pool; (ii) recording of a site call event M⟨C, hn|m⟩ in the trace (where m is the time at which the event occurs); (iii) updating the handle counter for the next site call; and (iv) replacing the original expression sc↑(f, M, C) by the expression sc↓(f, hn). Since the handle hn needs to propagate back to the subterm where the site call was made (which was temporarily substituted by the expression γ), sc↑(f, M, C) does not rewrite immediately to f , but rather to an operator, sc↓, that traverses down the expression tree until it reaches the appropriate subterm


4 Concurrent execution of site calls, expression calls and publishing of values is avoided by equations that will introduce an error expression in such cases, see [2].

where the handle is inserted.
sc↓(f1 | f2, h) = sc↓(f1, h) | sc↓(f2, h) if f1 /= 0 ∧ f2 /= 0,
sc↓(f1 > x > f2, h) = sc↓(f1, h) > x > f2
sc↓(f1 where x :∈ f2, h) = sc↓(f1, h) where x :∈ sc↓(f2, h),
sc↓(M (P ), h) = M (P ),	sc↓(0, h) = 0,	sc↓(!x, h) = !x,	sc↓(!c, h) = !c,
sc↓(E(P ), h) = E(P ),	sc↓(?h', h) = ?h',	sc↓(γ, h) = ?h.
Expression Call. The specification of an expression call is similar to a site call, in that two operators ec↑ and ec↓ are defined to propagate the call and its effect to and from the enclosing configuration (see [2] for their defining equations). First, an expression call is modeled with the following rewrite rules.
Def : ⟨f, r⟩→ ⟨ec↑(f', E,P ), r⟩ if f → ec↑(f', E,P )
Def* : E(P ) → ec↑(γ, E, P )
Then, by means of ec↑, the call is propagated up the expression tree to the enclos- ing configuration, where the effect of the call (appending a τ event to the trace) is recorded and the required declaration is accessed. Using call-by-name semantics, the call is replaced with an instance of the body of the corresponding defining equation. The resulting expression is then propagated back to the appropriate subterm, using the ec↓ operator.
Publishing a Value. Publishing a value is modeled by the following rewrite rules.
Pub : ⟨f, r⟩→ ⟨pub(f ', c), r⟩ if f → pub(f', c) Pubτ : ⟨f, r⟩→ ⟨pubτ (f'), r⟩ if f → pubτ (f') Pub* : !c → pub(0, c)
The publishing expression rewrites to an operator pub that replaces it with the zero expression 0 and then initiates the process of propagating the published value c up the expression tree (see the equations in [2]). If c is not bound in the expression, the value is propagated all the way to the top and a publish event is recorded in the enclosing configuration. Otherwise, if the value published is bound by a sequential composition expression or an asymmetric parallel composition expression, then one of the following equations applies:
pub(f, c) > x > g = pubτ (f > x > g | g{c/x}) g where x :∈ pub(f, c)= pubτ (g{c/x})

The equations reflect the semantics specified by the SOS rules
Seq1V
and

Asym1V of Figure 3. They also transfer the propagation task to another op-
erator pubτ , which ultimately causes a τ event to be recorded in the trace field of the configuration.
Site Return. Although, the environment in the SOS specifications of Figure 3 is treated as a “black box” with unpredictable responses from remote sites, we need to simulate environment responses in order to arrive at an executable specifica- tion. This is achieved in the following way. Once a message [M, C, hn] is emitted

into the message pool as a result of a site call, it is converted into the message [self , app(M, C, rand ), hn], which represents a potential response back to self , a reference to the current expression. The operator app(M, C, rand ), whose defini- tion depends on the site M , associates a pseudo-random delay to responses from remote sites. Once a response from M is returned, the site return rule may fire.
SiteRet : ⟨f, tr : t | msg : ρ [self, c, h] | clk : cm | r⟩→ 
⟨sr (f, c, h), tr : (t.h?c|m) | msg : ρ | clk : cm | r⟩ if h ∈ handles(f )
Application of the site return rule is subjected to the condition that the handle name of the message to be consumed is referenced in f . This is to avoid useless transitions that could take place when a thread, having an unfinished site call, is pruned using the where statement. If the condition is satisfied, the incoming message is consumed, a site return event h?c|m is generated, and the expression f is replaced with an operator sr (f, c, h) that propagates the return value down the expression tree to the appropriate pending call (see the equations in [2]).

Asynchronous versus Synchronous Execution Strategies
The rewrite theory described above does not enforce any execution strategy among instantaneous transitions of an Orc configuration as it allows internal transitions within an Orc expression (site calls, expression calls, and publishing of values) and the external transition of interacting with sites (site returns) to be interleaved asynchronously in any order. It reflects the exact behavior of the SOS semantics specification of Figure 3, which is in some sense too loose. In particular, site returns may take place in an expression while site calls that are ready to be made are waiting. For example, in the expression DelayedN | M , the call to M may be delayed, thus defeating the purpose of prioritizing the call to M . This issue was discussed in [22], where a synchronous semantics is proposed by placing further constraints on the application of SOS semantic rules of Figure 3. The synchronous semantics is arrived at by distinguishing between internal and external events, and
splitting the SOS transition relation ‹→ into two subrelations ‹→R, and ‹→A, and characterizing set-theoretically, the complementary subsets of expressions (quiescent vs. non-quiescent ) to which they are respectively applied.
In the context of rewriting logic, we showed in [1] how this restriction can be captured precisely in the SOS-based rewriting semantics using two alternative ap- proaches: (1) strategy expressions [11]; and (2) equationally deﬁned predicates. Al- though these two approaches are readily applicable to the rewrite theory developed here, we focus our attention in this paper on the latter approach, because strategy expressions are, as of this writing, not yet fully supported in Maude. We obtain a synchronous reduction semantics of Orc by means of a more precise version of Rred that gives the site return rule the lowest priority among the instantaneous actions. We first introduce the notion of an active expression.
Definition 3.1 The set of active expressions factive in Rred  is the smallest set
generated by the following rules.

M (C), E(P ), and !c are all in factive.
f | g ∈ factive if f ∈ factive or g ∈ factive.
f > x > g ∈ factive if f ∈ factive.
g where x :∈ f ∈ factive if f ∈ factive or g ∈ factive.
Note that our notion of an active expression exactly corresponds to the non- quiescent expression in [22]. This notion can be easily equationally captured by a predicate active : Expr → [Bool] [frozen] (see [2] for its defining equations), which is then used to limit the application of the SiteRet rules, as follows
SiteRet : ⟨f, tr : t | msg : ρ[self, c, hn] | clk : cm | r⟩→ 
⟨sr(f, c, hn), tr : (t.hn?c|m) | msg : ρ | clk : cm | r⟩
if hn ∈ handles(f ) ∧ active(f ) /= true
Timed Semantics
An important aspect of Orc is that of time elapse. Transitions of an Orc program, such as DelaydN , may occur at different times. Moreover, responses from non-local sites, such as CNN and BBC , may experience unpredictable delays and communica- tion failures, which are inherent in Orc’s computation model. This is in contrast to local sites, such as atimer and rtimer , for which Orc provides strong temporal guar- antees. In order to be able to reason about real-time guarantees of Orc programs, time elapse needs to be modeled explicitly. For this purpose, as usual for rewriting logic semantic definitions of real-time systems [24], we use a (discrete) time domain (maintained by the clock field in a configuration), and an additional rewrite rule, the “tick” rule, to advance time: ⟨f, clk : cm | r⟩ → ⟨f, clk : cm+1 | δ(r)⟩, where δ is a function that updates the record r in the state of the configuration to reflect the elapse of one time unit. However, as explained in [1], the addition of the tick rule may introduce uninteresting or undesirable behaviors. For instance, an Orc configuration that could make an instantaneous transition might instead choose to keep advancing time indefinitely without making any real progress. This should be avoided by giving time-elapsing rewrites the lowest possible priority. That is, we need to define a time-synchronous execution semantics, in which a configuration is not allowed to advance its time unless it reaches a state where no internal or external action, other than a time tick, can be taken 5 . Therefore, the theory Rred specifying the synchronous semantics of Orc is further extended in the following way. We first define an eager configuration as one that can make an instantaneous action.
Definition 3.2 An Orc configuration C in Rred is eager if C is of one of the following forms: (i) ⟨f, r⟩ with f ∈ factive; or (ii) ⟨f, msg : ρ [self, c, hn] | r⟩ if h ∈ handles(f ).
This notion of eager configurations can be easily captured by a predicate eager :
Conf → [Bool] [frozen], which evaluates to true if and only if it is applied to a

5 This time-synchronous strategy has a limitation, for a discussion of which the reader is referred to [1].

configuration that can make an instantaneous action (see [2] for the equations of eager ). To capture the desired time-synchronous semantics in Rred , we restrict the application of the tick rule by the condition that the configuration is not eager.
Tick : ⟨f, clk : cm | r⟩→ ⟨f, clk : cm+1 | δ(r)⟩ if eager(⟨f, clk : cm | r⟩) /= true
Correctness of the Semantics
In order for the rewriting semantics specifications described above to capture the intended semantics of Orc, it must somehow correspond to the SOS specifications of Figure 3. In this section, we present an equivalence theorem of which a detailed discussion and a complete proof are given in [2].  The theorem entails that the
rewriting semantics of Orc given by Rred and the SOS-based rewriting semantics

sos
Orc
developed in [1] are semantically equivalent, in the sense that an Orc program

behaves in exactly the same way in both semantic models. The correctness of Rred
against the synchronous SOS semantics of [22] then follows immediately from that

sos
Orc
with respect to the same SOS semantics, which was studied in [1].

Definition 3.3 In a conﬁguration ⟨f, (con : σ) | r⟩, an occurrence of an expression name E is bound in f if there exists a declaration for E in the context σ. Otherwise, E is said to be free in f. Likewise, an occurrence of E is bound in σ if there exists a declaration for E in σ, and is free in σ otherwise.
Definition 3.4 An Orc conﬁguration ⟨f, r⟩ is well-formed if: (1) f does not con- tain any of the auxiliary function symbols introduced in Section 3.2, such as sc↑, pub, and γ; and (2) r contains at least the ﬁve ﬁelds listed in Section 3.1. Moreover, a closed conﬁguration is a well-formed conﬁguration in which no expression name appears free in f or σ, the context component of r.
Theorem 3.5 [2] For any closed conﬁgurations C and C', the following equivalence holds: C →Rsos C' ⇐⇒ C →Rred C'.

Orc
Orc

Therefore, for any Orc program P , the state transition systems defined by Rsos
and Rred are strongly bisimilar.


Performance Comparison
Although the two theories Rsos


and Rred are semantically equivalent, Rred is much

Orc
Orc
Orc

more efficiently executable and analyzable. To validate this claim, both theories were implemented in Maude and a number of experiments were conducted using some Orc programs that originally appeared in [22]. In all experiments, perfor- mance was measured in terms of the time taken to perform a particular task. The tasks were: (1) simulating four Orc programs using Maude’s rewrite command; (2) exploring the state space of these four programs using Maude’s breadth-first search command; and (3) model checking three instances of the dining philosophers prob-
lem using Maude’s LTL model checker 6 .  The results of these experiments are

6 For the first two tasks, the clock was limited to ten clock ticks, and pseudo-random delays were assumed. Since the model checking task did not require external communication, time in this case was limited to a


Table 1
A performance comparison of the rewriting semantics of Orc. A number in the table represents the CPU time in milliseconds, as reported by Maude, to finish the corresponding task.

summarized in Table 1, which clearly shows that the reduction semantics can be executed and analyzed much more efficiently than the SOS-based semantics.

Distributed Object-based Rewriting Orc Semantics
Many orchestration applications, especially relatively large ones, can be thought of as consisting of multiple Orc subexpressions independently orchestrating different but related tasks. For instance, in the dining philosophers implementation in Orc
[22] with n philosophers, there are n subexpressions running in parallel, one for each philosopher. In more practical applications, such subexpressions normally run on physically distributed autonomous agents spread across the web. Furthermore, sites, whose responses were only simulated in the rewriting semantics developed in the previous section to arrive at an executable specification, normally maintain local states to support the services they provide, such as counter sites and channel
(buffer) sites. Therefore, it is natural to think of Orc expressions and sites as objects
in a distributed configuration. Expression objects are active objects (or actors in the actor model) having a state and one or more threads of control, and are capable of initiating (asynchronous) message exchange. Site objects are reactive objects having internal states and are capable only of responding to incoming requests. They can be thought of as actors that have a passive-reactive behavior.
The reduction semantics described in Section 3 is a key step towards the specifi- cation of the object-based semantics of the Orc’s orchestration model. In addition, within the Maude framework, the object-based semantics lends itself nicely to a future (physically) distributed deployment using Maude’s socket programming ca- pabilities. This leads to a formal analysis and verification environment that is faithful to the distributed nature of Orc’s wide-area computations.

Distributed Orc Semantics
A distributed Orc conﬁguration is modeled by a multiset of objects and messages. There are three classes of objects, namely, expression, site, and clock objects. a clock object is a simple object of class Clock, which maintains a single field, called clk, representing the current clock time. An expression object is an object of class Expr having three attributes: (i) exp, which holds an Orc expression to be computed;

single clock tick with no delays. All experiments were run on a 3.2GHz dual-core machine with 2GB of memory using Maude 2.3.

(ii) con, which is the context where expression name declarations appear; and (iii) hdl, which maintains a set of handle names that are currently being used by the expression. A site object is one of class Site with the following attributes:
name: the name of the site, such as if, rtimer, CNN, BBC, . . . etc.
op: the current operation being performed by the site. This attribute indicates whether the site object is currently blocking or accepting incoming messages. It also serves as a means to modularly specify a particular site definition.
state: the processing state of a site object. This field is abstractly defined as a list of items whose concrete meaning depends on the particular site being specified. Fundamental sites, such as if and rtimer, and other basic sites, such as arithmetic functions, are stateless and thus make no use of this field. However, more complex sites may require this attribute to maintain their state.
A message is either a site call message of the form M ← sc(O, C, h, m), with M the name of the site being called, and O the object identifier of the caller expression object, or a site return message of the form O ← sr (c, h, m), with O the identifier of the expression object receiving the published value c.
The distributed semantics of an Orc expression object is essentially that of the reduction semantics specification of Section 3, with the exception that messages are now managed by the distributed Orc configuration. This distributed semantics generalizes the reduction semantics to multiple Orc expressions, and provides an explicit treatment of message exchange between expression and site objects. A detailed discussion of this distributed semantics and its implementation in Maude can be found in [2]. We illustrate through an application how Maude’s LTL model checker can be used to verify properties of distributed Orc systems.

A Case Study: Managing an Online Auction
The distributed Orc auction program auction presented here was inspired by the Orc auction example given in [22]. The program uses a few expression declarations that we briefly describe first (a detailed discussion of the program and the following analysis can be found in [2]). The two main declarations are PostingDecl and BiddingDecl. PostingDecl defines an expression Posting(S) that gets items that are available to be advertised from the seller site list S, which is given below 7 .

Posting(S) =def if (empty (S))   let (0) | if (¬empty (S)) 
(S0(PostNext ) > item > auction(post, item)   rtimer (item1 + 1)
   Posting(tail (S)))
An item is a tuple (id, t, m), with id the item’s identifier, t the duration of the auction, and m the minimum bid. Once an item is posted, the expression waits for

7 Subscripts are used to denote zero-based indexing of elements in a list. For example, S0 is the first element in S and item1 is the second element in item. Furthermore, the notation  is used for sequential composition when no value passing occurs.

the auction to end before proceeding to the next item. The declaration BiddingDecl defines the bidding expression that manages the bidding process and announces winning bidders.

Bidding(B) =def auction(getNext ) > item > Bids(item0, item1, item2, B, 0) > w >
(if (w1 = 0)   Bidding(B) | if (w1 /= 0)   w1(won, item0, w0))
B is a list of bidders and Bids is an expression, declared by BidsDecl shown below, which, if successful, returns a pair (wbid, wbidder ) consisting of the winning bid and the winning bidder name.

Bids(id, duration, bid, B, winner ) =def if (duration = 0)    let (bid, winner )
| if (duration /= 0)   Collect (nextBid, B, id, bid ) > bidList >
MaxBid (bidList ) > m > rtimer (1)   Bids(id, duration − 1, m0, B, m1)

The Bids expression collects bids in rounds, each lasting for one time unit. In each round, the maximum bid is computed and published by the site MaxBid , and then used as the minimum bid for the next round. The Collect expression (declared by CollectDecl shown below) returns a list of bidding pairs of the form (bid, bidder ).

Collect (m, B, id, minBid ) =def if (empty (B))   let (nil ) | if (¬empty (B)) 
(append (x, xs) where x :∈ B0(m, id, minBid )
where xs :∈ Collect (m, tail (B), id, minBid ))

Beside the clock object and the fundamental site objects, the initial configura- tion of auction used in this section contains two expression objects: the posting expression object and the bidding expression object,
⟨o1 : Expr | exp : Posting(seller 0), con : PostingDecl, hdl : ∅⟩
⟨o2 : Expr|exp : Bidding(b0, b1, b2), con : BiddingDecl, BidsDecl, CollectDecl, hdl : ∅⟩
along with six site objects: (1) a seller site object whose name is seller 0; (2) three bidder site objects (named b0, b1, and b2); (3) a site object for the auction site, which manages the bidding process; and (4) a site object for the MaxBid site. In auction, we assume that seller 0 has two items t1 and t2 for sale and that bidders follow different bidding strategies. For simplicity, we assume no communication delays, and allow enough clock ticks for program completion.
We can specify some correctness properties of auction, and then verify them using Maude’s LTL Model Checker. Four atomic predicates, which are parametric to items, are used. hasbid (t) and sold (t) are self-explanatory. max (t) is true in a state where t is sold to the highest bidder, while conflict (t) is true whenever t has two or more winning bidders.

An item with at least one bid is eventually sold:   i(hasbid (ti) →  sold (ti))
Maude> red modelCheck(init, commitAll) .
rewrites: 33366205 in 59315ms cpu (59332ms real) (562516 rewrites/second) result Bool: true
An item is always sold at the maximum bid to the highest bidder:
   i(sold (ti) → max (ti))
Maude> red modelCheck(init, winAll) .
rewrites: 33739349 in 61027ms cpu (61024ms real) (552852 rewrites/second) result Bool: true
An item cannot have two winners: ¬   i conflict (ti )
Maude> red modelCheck(init, uniqueWinnerAll) .
rewrites: 33290882 in 59742ms cpu (59739ms real) (557235 rewrites/second) result Bool: true


Conclusion and Future Work
We have presented an efficient reduction semantics for Orc, shown how it captures Orc’s synchronous real-time semantics, and established its semantic equivalence with a previous SOS-like semantics. We have also further refined the reduction semantics into a distributed object semantics and have shown how LTL properties of Orc programs can be model checked using the distributed semantics. A natural future extension of this work is the development of a provably correct distributed implementation of Orc. The key idea is to shift the emphasis in the use of rewrit- ing logic from executable speciﬁcation to declarative distributed programming. In particular, we expect to make heavy use of Maude’s support for sockets as external objects [9] to develop such a distributed implementation.

Acknowledgement
Partially supported by ONR Grant N00014-02-1-0715, and by NSF Grants CNS- 05-24516 and CNS-07-16638.

References
Musab AlTurki and Jos´e Meseguer. Real-time rewriting semantics of Orc. In PPDP ’07: Proceedings of the 9th ACM SIGPLAN international symposium on Principles and practice of declarative programming, pages 131–142, New York, NY, USA, 2007. ACM Press.
Musab AlTurki and Jos´e Meseguer. Rewriting logic semantics of Orc. Technical Report UIUCDCS-R- 2007-2918, University of Illinois at Urbana Champaign, November 2007.
J. C. M. Baeten and J. A. Bergstra. Real time process algebra. Formal Aspects of Computing, 3(2):142– 188, 1991.
J. C. M. Baeten and Cornelis A. Middelburg. Process algebra with timing; Monographs in theoretical computer science. Springer, Berlin; New York, 2002.
Roberto Bruni, Hern´an Melgratti, and Emilio Tuosto. Translating Orc features into petri nets and the join calculus. In Mario Bravetti, Manuel Nu´n˜ez, and Gianluigi Zavattaro, editors, Web Services and Formal Methods, volume 4184 of Lecture Notes in Computer Science, pages 123–137. Springer, 2006.
Roberto Bruni and Jos´e Meseguer. Semantic foundations for generalized rewrite theories. Theor. Comput. Sci., 360(1-3):386–414, 2006.


Liang Chen. An interleaving model for real-time systems. In TVER ’92: Proceedings of the Second International Symposium on Logical Foundations of Computer Science, pages 81–92, London, UK, 1992. Springer-Verlag.
Shuo Chen, Jos´e Meseguer, Ralf Sasse, Helen J. Wang, and Yi-Min Wang. A systematic approach to uncover security flaws in GUI logic. In IEEE Symposium on Security and Privacy, pages 71–85. IEEE Computer Society, 2007.
Manuel Clavel, Francisco Dur´an, Steven Eker, Patrick Lincoln, Narciso Mart´ı-Oliet, Jos´e Meseguer, and Carolyn Talcott. All About Maude - A High-Performance Logical Framework: How to Specify, Program, and Verify Systems in Rewriting Logic (Lecture Notes in Computer Science). Springer- Verlag New York, Inc., Secaucus, NJ, USA, 2007.
Manuel Clavel, Francisco Dur´an, Steven Eker, Patrick Lincoln, Narciso Mart´ı-Oliet, Jos´e Meseguer, and Carolyn Talcott. Maude manual (version 2.3). January 2007. http://maude.cs.uiuc.edu/ maude2-manual/maude-manual.pdf.
Steven Eker, Narciso Mart´ı-Oliet, Jos´e Meseguer, and Alberto Verdejo. Deduction, strategies, and rewriting. Electron. Notes Theor. Comput. Sci., 174(11):3–25, 2007.
Matthew Hennessy and Tim Regan. A process algebra for timed systems. Inf. Comput., 117(2):221– 239, 1995.
Tony Hoare, Galen Menzel, and Jayadev Misra. A tree semantics of an orchestration language. In Proceedings of the NATO Advanced Study Institute on Engineering, Theories of Software Intensive Systems, Marktoberdorf, Germany, August 2004.
David Kitchin, William R. Cook, and Jayadev Misra. A language for task orchestration and its semantic properties. CONCUR 2006 –Concurrency Theory, pages 477–491, 2006.
J. Meseguer and G. Ro¸su. Rewriting logic semantics: From language specifications to formal analysis tools. In Proc. Intl. Joint Conf. on Automated Reasoning IJCAR’04, Cork, Ireland, July 2004, pages 1–44. Springer LNAI 3097, 2004.
Jos´e Meseguer. Conditional rewriting logic as a unified model of concurrency. Theor. Comput. Sci., 96(1):73–155, 1992.
Jos´e Meseguer. A logical theory of concurrent objects and its realization in the Maude language. In Gul Agha, Peter Wegner, and Akinori Yonezawa, editors, Research Directions in Concurrent Object- Oriented Programming, pages 314–390. MIT Press, 1993.
Jos´e Meseguer. Membership algebra as a logical framework for equational specification. In F. Parisi- Presicce, editor, Proc. WADT’97, pages 18–61. Springer LNCS 1376, 1998.
Jos´e Meseguer and Christiano Braga.	Modular rewriting semantics of programming languages.
Algebraic Methodology and Software Technology, pages 364–378, 2004.
Jos´e Meseguer and Grigore Rosu. The rewriting logic semantics project. Theor. Comput. Sci., 373(3):213–237, 2007.
Jayadev Misra. Computation orchestration: A basis for wide-area computing. In Manfred Broy, editor, Proc. of the NATO Advanced Study Institute, Engineering Theories of Software Intensive Systems, NATO ASI Series, Marktoberdorf, Germany, 2004.
Jayadev Misra and William R. Cook. Computation orchestration: A basis for wide-area computing.
Journal of Software and Systems Modeling, May 2006.
X. Nicollin and J. Sifakis. The algebra of timed processes ATP: Theory and application. Information and Computation, 114(1):131–178, 1994.
Peter Csaba O¨ lveczky and Jos´e Meseguer. Specification of real-time and hybrid systems in rewriting logic. Theoretical Computer Science, 285:359–405, 2002.
Sidney Rosario, David Kitchin, Albert Benveniste, William Cook, Stefan Haar, and Claude Jard. Event structure semantics of Orc. In 4th International Workshop on Web Services and Formal Methods (WS- FM 2007), Brisbane, Australia, October 2007.
Steve Schneider, Jim Davies, D. M. Jackson, George M. Reed, Joy N. Reed, and A. W. Roscoe. Timed CSP: Theory and practice. In Proceedings of the Real-Time: Theory in Practice, REX Workshop, pages 640–675, London, UK, 1992. Springer-Verlag.
Ian Wehrman, David Kitchin, William R. Cook, and Jayadev Misra. A timed semantics of Orc. Theoretical Computer Science, July 2007. To appear (preliminary version in http://www.cs.utexas. edu/users/wcook/Drafts/2007/TimedSemanticsDRAFT.pdf).
