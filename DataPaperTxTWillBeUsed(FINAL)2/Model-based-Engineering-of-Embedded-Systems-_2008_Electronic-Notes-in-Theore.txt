Electronic Notes in Theoretical Computer Science 209 (2008) 21–53	
www.elsevier.com/locate/entcs

Model-based Engineering of Embedded Systems Using the Hybrid Process Algebra Chi
J.C.M. Baeten, D.A. van Beek, P.J.L. Cuijpers, M.A. Reniers
J.E. Rooda, R.R.H. Schiffelers, R.J.M. Theunissen1
Department of Mechanical Engineering and Department of Mathematics and Computer Science Eindhoven University of Technology (TU/e) Eindhoven, The Netherlands

Abstract
Hybrid Chi is a process algebra for the modeling and analysis of hybrid systems. It enables modular specification of hybrid systems by means of a large set of atomic statements and operators for combining these. For the efficient implementation of simulators and the verification of properties of hybrid systems it is convenient to have a model that uses a more restricted part of the syntax of hybrid Chi. To that purpose the linearization of a reasonably expressive, relevant subset of the Chi language is discussed. A linearization algorithm that transforms any specification from this subset into a so-called normal form is presented. The algorithm is applied to a bottle-filling line example to demonstrate tool-based verification of Chi models.
Keywords: hybrid systems, process algebra, hybrid automata, modeling, linearization, simulation, verification.


Introduction
The χ (Chi) formalism [5,20] 2 is a hybrid process algebra. The intended use of χ is for modeling, simulation, verification, and real-time control of discrete-event, continuous or combined, so-called hybrid systems. Its application domain ranges from physical phenomena, such as dry friction, to large and complex manufacturing systems, such as integrated circuit manufacturing plants, breweries, and process industry plants [8,18,2]. These plants consist of many independently operating entities such as machines, buffers, liquid storage tanks and reactors. The entities interact with each other in a discrete fashion, for example, the exchange of products

1 Email:	josb@win.tue.nl,	D.A.v.beek@tue.nl,	P.J.L.Cuijpers@tue.nl ,	M.A.Reniers@tue.nl, J.E.Rooda@tue.nl, R.R.H.Schiffelers@tue.nl , R.J.M.Theunissen@tue.nl
2 The χ language as defined in [20] has small corrections w.r.t. the version defined in [5]

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.003

or information, or in a continuous fashion, for example, sharing a liquid flow. The χ formalism has been designed to model interacting parallel entities representing both discrete and continuous behavior in an easy and intuitive way. This is ensured by strong support for modular composition by allowing unrestricted combination of operators such as sequential and parallel composition, by providing statements for scoping, by providing process definition and instantiation mechanisms, and by pro- viding different interaction mechanisms, namely synchronous communication and shared variables. The fact that the χ process algebra is such a rich language poten- tially complicates the development of tools for χ, since the implementations have to deal with all possible combinations of the χ atomic statements and the operators that are defined on them. This is where the process algebraic approach of equational reasoning, that allows rewriting models to a simpler form, is essential.
To illustrate the required implementation efforts, consider the following imple- mentations that have been developed:
a Python simulator implementation for rapid prototyping [6];
a C simulator implementation for fast model execution;
an implementation based on the MATLAB Simulink S-functions [22] enabling co-simulation [3];
an implementation for real-time control [15].
In [7] it has been shown that different (timed) model checkers each have their own strengths and weaknesses. Therefore, for verification, translations to several tools are defined:
For hybrid models a translation from χ to the hybrid I/O automaton based model checker PHAVer [12] is defined in [4], which has been proven correct.
For timed models the following translations are defined (see [7]):
a translation to the action-based process algebra μCRL [13], used as input language for the verification tool CADP [11];
a translation to PROMELA, a state-based, imperative language, used as input language for the verification tool SPIN [16];
a translation to the timed automaton based input language of the UPPAAL [19] verification tool.
Instead of defining the implementations mentioned above on the full χ language as defined in [5,20], the process algebraic approach of equational reasoning makes it possible to transform χ models into a normal form, which consists of less operators allowed only in very restricted combinations, and to define the implementations on this normal form. The original χ model and its normal form are (stateless) bisimilar [5,20], which ensures that model properties are preserved.
An advantage of operating on normal forms is that generally it is much easier to define a simulator for process terms that are in normal form than for arbitrary process terms and therefore it is also much easier to generate a (hybrid) transition system from normal forms. For many types of model properties there are reason- ably efficient means available for verification on process terms without complex

mechanisms such as parallel composition and hierarchy. For example, one can con- sider translations from (the subset used of) χ to other formalisms such as hybrid automata [20].
In general, one may say that the use of process models in normal form simplifies further analysis and makes the implementation of tools easier and more efficient. In this paper, an algorithm for the automatic generation of the normal form of a χ model is described, and the correctness of this algorithm is proven. The ap- proach followed is comparable to the approach of [24,10]. However, there are some differences that reduce the complexity of the algorithm considerably. Instead of linearizing the full χ language, a relevant subset of the χ language has been chosen.
First, recursion is allowed only in a well structured form:
by assuming tail-recursion in the input specification, the complex stacking of recursion variables in [24,10] has been avoided;
all recursion variables that are used within a recursion scope are assumed to be also defined within that scope, i.e. recursion scopes are complete.
Second, the signal emission operator, variables scope operator, channel scope oper- ator and urgent communication operator as defined in [5,20] are omitted from the linearization algorithm, since these operators in general occur only at the top level of χ models.
The outline of this paper is as follows. In Section 2 the input language for the linearization algorithm is defined. The normal form that is the output of the lin- earization algorithm is defined in Section 3, and Section 4 contains the linearization algorithm itself. In Section 5, the linearization algorithm is illustrated by means of a case study. Concluding remarks and future work are discussed in Section 6.

Syntax and informal semantics of a subset of χ
In this section, a concise definition of the syntax and informal semantics of a subset of χ is defined. The complete χ syntax and semantics are defined in [5,20].

Syntax
A χ model has the following form 3 :
model id (Dm)= |[ D :: pt ]|
Dm ::= val S {, S}∗  | Dm, Dm	model parameter declaration
S	::= id {, id }∗ : t	declaration without initialization

3 The notation introduced here is an abbreviation of a triple ⟨p, σ, E⟩, where p denotes the process term, σ denotes the valuation, and E denotes an environment. A valuation is a partial function from variables to values. An environment E is a tuple (C, J, L, H, R), where C denotes the set of continuous variables, J denotes the set of jumping variables, L denotes the set of algebraic variables, H denotes the set of channels, and R denotes a recursion definition. A recursion definition is a partial function from recursion variables to process terms.

where id is an identifier that represents the name of the model, and Dm denotes the model parameters. The model parameter declaration may be also be empty. The body of a χ model consists of a declaration part D, in which channels, variables and modes can be declared, and the process term pt. The syntax of the declaration D is:
D ::= chan S {, S}∗	channel declaration
| (var | cont | alg ) IS {, IS }∗	variable declaration
| mode	X = p {,X = p}∗	mode declaration
| D, D
IS ::= id {, id }∗ : t = e | S	declaration with initialization
Here, t denotes the type of a variable or channel, e denotes an initialization expres- sion, and id denotes an identifier. The following items can be declared in D:
Channels, such as in chan h : real, close : void. This declares a communication channel h, that communicates values of type real, and a synchronization channel close (no data exchange).
Discrete variables, such as in var k, n : int, vset : real = 1.0. This declares two uninitialized variables k, n of type int (integer), and a variable vset that has an initial value 1.0.
Continuous variables, such as in cont x : real = 1.0. Continuous variables are the only variables for which dotted variables (derivatives) can be used. Therefore, the declaration cont x : real = 1.0 implies that x and its dotted version x˙, can both be used.
Algebraic variables, such as in alg y, z : real.
Modes, such as mode filling = (V ≥ 10 → n := 0; emptying).
Besides the variables defined above, the existence of the predefined reserved global variable time which denotes the current time, the value of which is initially zero, is assumed. This variable cannot be declared. It can only be used in expressions occurring in the process terms. Using a BNF-like notation (Backus Naur Form), the subset of χ process terms that can be linearized is defined by the following grammar for the process terms pt ∈ Pt:



pt ::=	|[ D :: ps ]|



where D denotes declarations as already defined. The syntax of the process terms

ps defines the set of all process terms Ps:

where b denotes a predicate over variables and dotted continuous variables, and A ⊆ A is a set of action labels. The set of all possible actions A is defined as A = Alabel ∪ Acom, with Alabel ∩ Acom = ∅. The set of communication actions Acom is defined as Acom = {isa(h, cs), ira(h, cs, W ), ca(h, cs) | h ∈ H, cs ∈ Λ∗,W ⊆ V}, where isa, ira and ca denote action labels for the internal send action, the internal receive action, and the communication action respectively. The sets H, Λ∗ and V denote the sets of all possible channels, all possible lists of values, and all possible variables respectively.
We assume that action encapsulation is based on channel names and not on the values sent or received, this restricts the set A as follows:

∀h∈H,x,y∈Λ∗ isa(h, x) ∈ A =⇒ isa(h, y) ∈ A,
∀h∈H,x,y∈Λ∗,v1,v2 ⊆V ira(h, x, v1) ∈ A =⇒ ira(h, y, v2) ∈ Aand
∀h∈H,x,y∈Λ∗ ca(h, x) ∈ A =⇒ ca(h, y) ∈ A.


The operators are listed in descending order of their binding strengths as follows
→ , ; , { , ▢ }. The operators inside the braces have equal binding strength. In addition, operators of equal binding strength associate to the right, and parentheses may be used to group expressions. For example, p; q ; r means p; (q ; r).
The syntax of the atomic process terms patom defines the set of all atomic process terms Patom:

patom ::=	pact	action process terms
|	u	delay predicate process term
where u is a predicate over variables and dotted continuous variables.

The syntax of the action process terms pact defines the set Pact:
pact ::=	W : r  la	action predicate process term
|	h !! en	send process term
|	h ?? xn	receive process term
|	h !? xn := en	communication process term
Here, W ⊆V is a set of variables, and r is a predicate over variables, dotted con- tinuous variables, and ’ ’ superscripted variables (including the dotted variables). Furthermore, la ∈ Alabel is an action label, h ∈H is a channel, en denotes the ex- pressions e1, ... , en, and  n denotes the variables x1, ... , xn. For n = 0, h !! n, h ?? xn and h !? xn := en can be written as h !!, h ?? and h !?, respectively.
Note that the communication process term h !? xn := en is not part of the ‘core’ elements of the χ formalism as defined in [5]. It is, however, defined in [20]. Par- allel composition allows the synchronization of matching send and receive actions. The result of the synchronization is a communication action. The syntax of the communication is given in terms of other language elements (send process term, receive process term, parallel composition, and action encapsulation). In normal forms parallel composition is eliminated; therefore the communication process term h !? xn := en is introduced to represent the communication action as a single atomic process term. The following property holds:
h !? xn := en ↔ ∂{isa(h,cs),ira(h,cs,v)|cs∈Λ∗,v⊆V}(h !! en  h ?? xn), where ↔ denotes stateless bisimilarity.
The recursion scope operator pR is restricted to tail-recursion only. Its syntax is defined as:
pR ::=  |[R R :: X ]|  satisfying the condition: X ∈ dom(R)
|  |[R R :: p ]|  satisfying the condition: rvar(p) ⊆ dom(R),
where X ∈X denotes a recursion variable (X is the set of all recursion variables), and R is a recursion definition. The syntax of process terms p defines the set of all process terms P:
p ::=  ps | b → p | ps; X | ps; p | p ▢ p
The function rvar : P → X extracts the recursion variables used in process terms from P. It is defined as:
rvar(ps)	= ∅ rvar(b → p) = rvar(p) rvar(ps; X) = {X} rvar(ps; p)	= rvar(p)
rvar(p ▢ q) = rvar(p) ∪ rvar(q)

where ps ∈ Ps and p, q ∈ P. Sometimes, this function is lifted to recursive definitions by defining: rvar(R)=  X∈dom(R) rvar(R(X)).
An additional restriction is that the recursion definition used in a recursion scope
operator process term must be complete, in the sense that all recursion variables used in the recursion definition must be defined in the same recursion definition. For- mally, rvar(R) ⊆ dom(R). In the sequel, recursion scope will be used as a shorthand for recursion scope operator process term, and a recursion scope with a complete recursion definition is called a complete recursion scope.
For many of the core process terms introduced before, there is additional, more user-friendly syntax available (see [5,20] for a complete overview.) Trivially, the user-friendly syntax that is defined in terms of process terms that belong to the input language of the linearization algorithm as defined above, can be used as input as well. A list of these additional process terms that are used in the bottle filling line example in Section 5 is given below.
δ  ∅ : false  τ
skip  ∅ : true  τ
xn := en  {xn} : x1 = e− ∧ ··· ∧ xn = e−   τ , where e− denotes the result of
replacing all variables xi in e by their ‘−’superscripted version x−.
|[ mode X1 = p1,... , mode Xn = pn :: q ]|  |[R {X1 '→ p1,... , Xn '→ pn} :: q ]|

Informal semantics
The behavior of χ processes is defined in terms of actions and delays 4 . Actions define instantaneous changes, where time does not change, to the values of variables. Delays involve the passing of time, where for all variables their trajectory as a function of time is defined. The valuation σ and the environment E, together define the variables that exist in the χ process and the variable classes to which they belong.
The variables are grouped into different classes with respect to the delay behavior and action behavior. With respect to the delay behavior, the variables are divided into the following classes:
The discrete variables, the values of which remain constant while delaying.
The continuous variables, the values of which change according to an absolutely continuous function 5 of time while delaying. The values of continuous variables are further restricted by delay predicates, that are usually in the form of differ- ential algebraic equations.
The dotted continuous variables, the values of which change according to an

4 Formally, the behavior of χ processes is defined in terms of action transitions and time transitions. Informally, we use the term actions to refer to action transitions, and the term delays to refer to time transitions.
5 A function f (x) is continuous at x ∈ X provided that for all ε > 0, there exists δ > 0 so that |x − y| ≤ δ implies |f (x) − f (y)| ≤ ε. Roughly speaking, for single-valued functions this means that we can draw the graph of the function without taking the pencil of the paper. The class of absolutely continuous functions consists of continuous functions which are differentiable almost everywhere in Lebesgue sense. This class includes the differentiable functions.

integrable, possibly discontinuous function of time while delaying.
The algebraic variables, that behave in a similar way as continuous variables. The differences with continuous variables are that algebraic variables may change according to a discontinuous function of time, and that algebraic variables are not allowed to occur as dotted variables.
The predefined variable ‘time’, that denotes the current time.
In χ, there are several means to change the value of a variable, depending on the class of variable. The main means for changing the value of a variable are the action predicate, for instantaneous changes, and the delay predicate, for the changes of variables over time.

Action predicates
An instantaneous change of the value of a discrete or continuous variable in χ is always connected to the execution of an action. In action predicates, the action is represented by a label. Other types of action are related to communication, which is treated below in the paragraph on parallelism. Action predicate W : r  la denotes instantaneous changes to the variables from set W , by means of an action labeled la, such that predicate r is satisfied. The predefined global variable time cannot be assigned. The non-jumping variables that are not mentioned in W remain unchanged, and the jumping variables, dotted continuous variables, and algebraic variables may obtain ‘arbitrary’ values, provided that the predicate r is satisfied and the process remains consistent.
A ‘−’ superscripted occurrence of a variable refers to the value of the variable in the extended valuation 6 prior to execution of the action predicate, and a normal (non-superscripted) occurrence of a variable refers to the value of that variable in the extended valuation that results from the execution of the action predicate. A predicate r is satisfied if evaluating the ‘−’ superscripted variables in the original extended valuation and evaluating the normal occurrences of the variables in the obtained extended valuation means that the predicate is true. The reason to use an extended valuation for evaluating action predicate r is that in such predicates also algebraic and dotted continuous variables may be used. Note that it can be the case that different instantaneous changes satisfy the predicate, this may result in non-determinism.
Note that the (multi-)assignment is not a primitive in χ, in contrast to for exam- ple in [9]. This is because action predicates are more expressive than assignments. Consider for example the action predicate {x} : x ∈ [0, 1]  τ , that changes the value of x to a value in the interval [0, 1]. Also, the predicate of an action pred- icate may consist of a conjunction of implicit equations, e.g. {x} : f1(x−, x) = 0 ∧ ... ∧ fn(x−, x)= 0  τ . The solution of such a system of equations, if present, need not always be expressible in an explicit form. The system may also have multiple solutions.

6 An extended valuation contains in addition to the values of the discrete and continuous variables and the variable time also the values of the dotted variables and the algebraic variables.

Delay predicates
In principle, continuous and algebraic variables change arbitrarily over time when delaying, although, depending on the class of the variable, they may have to respect some continuity requirements (see [20,5] for more details). A delay predicate u, usually in the form of a differential algebraic equation, restricts the allowed behavior of the continuous and algebraic variables in such a way that the value of the predicate remains true over time. Delay predicates of the form x ≥ e, where x is a variable, e an expression, and where instead of ≥, also ≤, >, < can be used, are comparable to invariants in hybrid automata.
Any delay operator
Besides the specification of delay by means of delay predicates, arbitrary delay can be described by means of the any delay operator [p]. The resulting behavior is such that arbitrary delays are allowed. When [p] delays, p remains unchanged and its delay behavior is ignored. The action behavior of p remains unchanged in [p].
Sequential composition
The sequential composition of two process terms p; q behaves as process term p until
p terminates, and then continues to behave as process term q.
Conditional
The guarded process term b → p can do whatever actions p can do under the condi- tion that the guard b evaluates to true using the current extended valuation. The guarded process term can delay according to p under the condition that for the intermediate extended valuations during the delay, the guard b holds. The guarded process term can perform arbitrary delays under the condition that for the inter- mediate valuations during the delay, possibly excluding the first and last valuation, the guard b does not hold.
Choice
The alternative composition operator ▢ allows a non-deterministic choice between different actions of a process. With respect to time behavior, the participants in the alternative composition have to synchronize. This means that the trajectories of the variables have to be agreed upon by both participants. This means that ▢ is a strong time-deterministic [21] choice operator.
Parallelism
Parallelism can be specified by means of the parallel composition operator  . Parallel processes interact by means of shared variables or by means of synchronous point-to- point communication/synchronization via a channel. Channels are denoted as labels (identifiers). The parallel composition p  q synchronizes the time behavior of p and q, interleaves the action behavior (including the instantaneous changes of variables) of p and q, and synchronizes matching send and receive actions. The synchronization of time behavior means that only the time behaviors that are allowed by both p

and q are allowed by their parallel composition. The consistent equation semantics of χ enforces that actions by p (or q) are allowed only if the values of the variables before and after the actions are consistent with the other process term q (or p). This means, among others, that the ‘active’ delay predicates of q must hold before and after execution of an action by p and vice-versa.
By means of the send process term h !! e1,. . ., en, for n ≥ 1, the values of ex- pressions e1, ... , en (evaluated w.r.t. the extended valuation) are sent via channel h. For n = 0, this reduces to h !! and nothing is sent via the channel. By means of the receive process term h ?? x1,. . ., xn, for n	1, values for x1,. . ., xn are received from channel h. We assume that all variables in the sequence xn are syntactically differ- ent: xi ≡ xj =⇒ i = j. For n = 0, this reduces to h ??, and nothing is received via the channel. Communication in χ is the sending of values by one parallel process via a channel to another parallel process, where the received values (if any) are stored in variables. For communication, the acts of sending and receiving (values) have to take place in different parallel processes at the same moment in time. The case that no values are sent and received is called synchronization instead of communication. In order to be able to model open systems (i.e. systems that interface with the environment), it is necessary not to enforce communication via the external channels of the model (e.g. the channels that send or receive from the environment). For communication via internal channels, however, the communication of matching send and receive actions, often is not only an option, but an obligation. In such models, the separate occurrence of the send action and the receive action via an internal channel is undesired. The encapsulation operator ∂A, where A ⊆A \ {τ } is a set of actions (A is the set of all possible actions and τ is the predefined internal action), is introduced to block the actions from the set A. In order to assure that, for internal channels, only the synchronous execution of matching send and receive actions takes place, one can simply put all send and receive actions via internal
channels in the set A.
In principle the channels in χ are non-urgent. This means that communication does not necessarily take place as soon as possible. In order to describe also urgent channels, the urgent communication operator υH (p), where H ⊆H is a set of channel labels, ensures that p can only delay in case no communication or synchronization of send and receive actions via a channel from H is possible.
Note that a different kind of urgency can be achieved by means of undelayable process terms. The χ semantics ensures that actions of undelayable process terms have priority over delays. For example in x˙ =1  x := 1 and x˙ =1 ▢ x := 1, the assignment cannot delay. Therefore, it must be executed before a delay is possible.
Also in h !! x˙ = 1, or h !! h ??, or h !! [h ??], the parallel composition cannot delay
because h !! cannot delay. Therefore, a send action must be executed before a delay may be possible. Process term [h !!]  [h ??], however, can do a communication action (or send or receive action), but it can also delay. To enforce the synchronization, the encapsulation operator is used; to enforce this as soon as possible, the urgent communication operator is used: υ{h}([h !!]  [h ??]).

Recursive deﬁnitions
Process term X denotes a recursion variable (identifier) that is defined either in the environment of the process, or in a recursion scope operator process term |[R ... :: p ]|, see subsubsection 2.2.9. Among others, it is used to model repetition. Recursion variable X can do whatever the process term of its definition can do.

Hierarchical modeling
To support the hierarchical modeling of systems, it is convenient to allow local declarations of variables. For this purpose, the variable scope operator process term
|[ D :: p ]| is introduced, where D denotes declarations of local channels, local variables and local modes. It is allowed that the local variables have been declared on a more global level also. Any occurrence of a variable in process term p that is declared in D refers to the local variable and not to any more global declaration of the same variable name.
For similar purposes, local recursive definitions can be declared by means of a recursion scope process term |[R R :: p ]|. The recursion scope process term |[R R :: p ]| is used to declare local recursion definitions R ⊆ R.

Transitions
In [5,20] the formal semantics of χ is defined. The state of a χ process is defined as a tuple ⟨p, σ, E⟩ consisting of a process term p, a valuation σ of all data variables, and an environment E that contains, amongst others, definitions for all unbound recursion variables in p. The semantics then defines which changes in the state are

ξ,a,ξ'
'	'	'

possible, denoted by three kinds of arrows. The first kind, ⟨p, σ, E⟩ −−−→ ⟨p ,σ ,E ⟩
ξ,a,ξ'	√	'	'
or ⟨p, σ, E⟩ −−−→⟨ ,σ ,E ⟩, denote a state change due to an action a, were ξ and
ξ' show the change in the data resulting in a new process term or in termination
(√). The second, ⟨p, σ, E	t,ρ	p', σ', E'⟩, represents the passage of time t, where
⟩ '−→ ⟨
ρ is a function representing the flow of the data variables. Finally, the third arrow
⟨p, σ, E⟩ ~, denotes that an observation ξ on the data is consistent with the state
⟨p, σ, E⟩, without changing that state.

Syntax of the normal form of χ
The syntax of the normal form of the χ language is defined in terms of a recursion scope, nested in a scope operator by the following grammar for process terms pNt ∈ PNt:
pNt ::=	|[ D :: pN ]|
The syntax for the process terms pN defines the set of process terms PN:
pN ::=	|[R Rn :: X ]|	satisfying the condition: X ∈ dom(Rn),
where Rn is a recursion definition of the form Rn : X → Pn. The set of all recursion

definitions of the form Rn is denoted as Rn. Note that the subscript ‘n’ of process terms pn... refers to syntax definitions that are part of the normal form.
The syntax for the process terms pn, png, defines the respective sets Pn, Png of all such process terms:
pn ::=	png | pn ▢ pn
png ::=	u | pact | [pact] | pact ; X  | [pact]; X  | b → png
It can be shown that PN ⊂ Ps. Note that nested guards are allowed in normal forms,
e.g. b → b' → h !! en. One might expect that nested guards such as b → b' → p can be replaced by a single guard as follows b → b' → p ↔ b ∧ b' → p. As shown in [20] this is not the case. Therefore nested guards are necessary in normal forms.
In the remainder of this paper, the following notations are used: B denotes all boolean expressions, and pt ∈ Pt, p, q ∈ P, ps ∈ Ps, pNt ∈ PNt, pn, qn ∈ Pn, R, S ∈ R, Rn, Sn ∈ Rn, and X, Y, Z ∈X . Furthermore, the union on partial functions is defined as follows, if f and g are functions with dom(f ) ∩ dom(g)= ∅, then f ∪ g denotes the unique function h with dom(h)= dom(f ) ∪ dom(g) satisfying the condition: for each c ∈ dom(h), if c ∈ dom(f ) then h(c)= f (c), and h(c)= g(c) otherwise.

Linearization algorithm
The normal form of a process term:

pt = |[ D :: ps ]|

is defined as the process term:

pNt = |[ D :: N (ps) ]|

where N : P→ PN. The linearization function N will be defined for all process terms p ∈ P, because the syntax Ps refers to process terms with syntax P (in recursion definitions), and Ps ⊂ P. Note, however, that N (p) returns a complete scope when p ∈ Ps, but may return an incomplete recursion scope when p /∈ Ps. This is especially important for the bisimilarity proofs of sequential composition, parallel composition and encapsulation (which only operate on ps).
The definition of N (p) is recursive over the structure of p, and to each element of this structure one subsection is dedicated. This section then contains a definition for N (p), as well as an inductive argument proving that the function N is well-defined, that N (p) is in normal form (i.e. N (p) ∈ Pn), and that N (p) is stateless bisimilar [5,20] to p (denoted N (p) ↔ p).
Apart from some specific properties for certain operators that are introduced locally in the subsections, the following properties on recursion scopes are used to

prove bisimilarity of N (p) and p.

S1	p ↔ |[R ∅ :: p ]|
S2	|[R R :: p ]| ↔ |[R S ∪ R :: p ]|	for dom(R) ∩ dom(S)= ∅,
rvar(p) ∩ dom(S)= ∅, and rvar(R) ∩ dom(S)= ∅.
S3	|[R R :: p ]| ↔ |[R R :: p[R(X)/X] ]| for X ∈ dom(R)
S4 |[R R :: |[R S :: p ]|]| ↔ |[R R ∪ S :: p ]|	for dom(R) ∩ dom(S)= ∅, and
rvar(R) ∩ dom(S)= ∅.

In the bisimilarity proofs for sequential and parallel composition, the following the- orem regarding the semantics of χ is used.
Theorem 4.1 For a process pn ∈ Pn, a recursive speciﬁcation Rn ∈ Rn in normal form, and recursion variable X ∈ dom(Rn), we ﬁnd

⟨p
, σ,E 
t,ρ
p', σ', E'⟩ implies p
= p',

n
⟨|[ R
⟩ '−→ ⟨
:: X ]|, σ,E 

t,ρ
n
p, σ', E'⟩ implies p = |[

R :: R

(X) ]|,

ξ,a,ξ'
'	'	'	'	'	'

⟨pn, σ, E⟩ −−−→ ⟨p ,σ ,E ⟩ implies p = X for some X ∈ rvar(pn), and
ξ,a,ξ'	'	'	'	'

⟨|[R Rn :: X ]|, σ, E⟩ −−−→ ⟨p, σ ,E ⟩ implies p = |[R Rn :: X
rvar(Rn(X)).
]| for some X ∈

Proof. Straightforward from the semantics of χ, with induction on the structure of normal forms.	 

Atomic process terms
The normal form of an atomic process term is a recursion scope with a recursion definition that only defines a mapping from a recursion variable to the atomic process term. The normal form of a delayable atomic process term is similar, except for the delayable delay predicate, which uses the property [u] ↔ true (see [5,20]).
N (patom)= |[R {X '→ patom} :: X ]|
N ([u]) = |[R {X '→ true} :: X ]|
N ([pact]) = |[R {X '→ [pact]} :: X ]|

Well-definedness is guaranteed since there is no mention of recursion for the atomic process terms. Furthermore, righthand sides are all in normal form, so N (patom), N ([u]), N ([pact]) ∈ Pn. Bisimilarity of these terms is trivial, using the properties mentioned in the beginning of this section, as an example we will treat

N ([u]). Note, that to use S2, we need (and trivially have) X /∈ rvar(true).

N ([u]) = |[R {X '→ true} :: X ]|	by definition
|[R {X '→ true} :: true ]| using S3
|[R ∅ :: true ]|	using S2
true	using S1
[u]	using the property above


Guard operator
The recursion definition in the normal form of a process term p guarded by guard b is the union of the recursion definition of the normal form of p, and a new recursion definition that defines the process term Rn(Y ) guarded by guard b. Note, that the guard b is distributed over the alternative composition operators occurring in Rn(Y ) by means of function Tg : B× Pn → Pn.

N (b → p)= |[R Rn ∪ {X '→ Tg(b, Rn(Y ))} :: X ]| where N (p)= |[R Rn :: Y ]|, X ∈/ dom(Rn)
Tg(b, png) = b → png	Tg(b, pn ▢ qn) = Tg(b, pn) ▢ Tg(b, qn)

Since p is a strict subterm of b → p, well-definedness of N (b → p) depends only on well-definedness of Tg, which follows by observing that the recursion in its righthand side only makes use of strict subterms of the lefthand side. Clearly, N (b → p) ∈ Pn if Tg(b, pn) ∈ Pn, which follows by induction on the structure of pn. Bisimilarity of b → p and N (b → p) follows inductively from the properties in the beginning of this section, and in addition the distribution of guards over the recursion scope:

DGS	|[R R :: b → p ]| ↔ b → |[R R :: p ]| and the following lemma.
Lemma 4.2 Tg(b, p) ↔ b → p

Proof. From [20] we have the property b → (p ▢ q) ↔ b → p ▢ b → q. The rest follows with induction on the structure of p.



N (b → p) = |[R Rn ∪ {X '→ Tg(b, Rn(Y ))} :: X ]|	by definition
|[R Rn ∪ {X '→ Tg(b, Rn(Y ))} :: Tg(b, Rn(Y )) ]| using S3
|[R Rn :: Tg(b, Rn(Y )) ]|	using S2
|[R Rn :: b → Rn(Y ) ]|	using Lemma 4.2
b → |[R Rn :: Rn(Y ) ]|	using DGS
= b → N (p)	by assumption
b → p	by induction

Sequential composition
This section defines the normal form of ps sequentially followed by q. The recursion variable that defines the normal form of q is sequentially appended to all terminating process terms in the recursion definition of the normal form of ps by means of function ap : Pn ×X → Pn. Terminating process terms are process terms that can do an action transition that results in the termination of the process; i.e. in normal form the terminating process terms are the pact and [pact] terms that are not sequentially followed by a recursion variable. This results in a new (incomplete) recursion definition with the same domain as the recursion definition of the normal form of ps, only the range is different.
This new recursion definition joined with the recursion definition of the normal form of q result in the (complete) recursion definition of the normal form of the sequential composition of the process terms ps and q.
N (ps; q)= |[R {Z '→ ap(Rn(Z),Y ) | Z ∈ dom(Rn)}∪ Sn :: X ]|
where N (ps)= |[R Rn :: X ]|, N (q)= |[R Sn :: Y ]|, dom(Rn) ∩ dom(Sn)= ∅

The case where the second process term is a recursion variable is treated separately, as q ∈ P and X ∈/ P. The recursion variable Y is appended to all terminating process terms in the recursion definition of the normal form of ps. Note that in this

case the recursion definition of the normal form is incomplete, as Y
∈/ dom(Rn).

N (ps; Y )= |[R {Z '→ ap(Rn(Z),Y ) | Z ∈ dom(Rn)} :: X ]|
where N (ps)= |[R Rn :: X ]|, Y ∈/ dom(Rn)
For each righthand side in a recursion definition, the recursion variable Y is ap- pended to the terminating process terms defining it, by means of function ap. If a definition is non-terminating, i.e. a process term sequentially composed with a recursion variable X, it is returned unchanged. This behavior is correct as only tail-recursion is allowed; the recursion variable Y is appended to all terminating

process terms in the definition of X.

ap([pact]; X, Y ) = [pact]; X	ap(b → png,Y ) = b → ap(png,Y ) ap(pn ▢ qn,Y ) = ap(pn,Y ) ▢ ap(qn,Y )
The definition of N (ps; q) makes recursive use of N (ps) and N (q), the definition of N (ps; Y ) makes only use of N (ps). Observe that ps and q are strict subterms of ps; q, and ps is a strict subterm of ps; Y . Therefore, well-definedness of N is reduced to well-definedness of ap, which follows using the observation that recur- sion in the righthand sides only makes use of strict subterms of lefthand sides. Furthermore, N (ps; q) ∈ Pn if {Z '→ ap(Rn(Z),Y ) | Z ∈ dom(Rn)} ∈ Rn. The latter follows if ap(pn,Y ) ∈ Pn, which is proven by induction on the structure of pn. The bisimilarity N (ps; q) ↔ ps; q is hard to prove using properties. But, by induction, we find that it is sufficient to give a witnessing bisimulation relation D for N (ps); N (q) ↔ N (ps; q) instead. That the relation D given below is indeed a bisimulation relation is straightforward but tedious to verify. Note, that we relied on Theorem 4.1 and on completeness of Rn (but not of Sn!), while constructing and proving this bisimulation relation.
D = {(|[R Rn :: X ]| ; |[R Sn :: Y ]|
, |[R {Z '→ ap(Rn(Z),Y ) | Z ∈ dom(Rn)}∪ Sn :: X ]|)
| Rn, Sn ∈ Rn, dom(Sn) ∩ dom(Rn)= ∅,X ∈ dom(Rn),Y ∈ dom(Sn)}
∪ {(|[R Rn :: Rn(X) ]| ; |[R Sn :: Y ]|
, |[R {Z '→ ap(Rn(Z),Y ) | Z ∈ dom(Rn)}∪ Sn :: ap(Rn(X),Y ) ]|)
| Rn, Sn ∈ Rn, dom(Sn) ∩ dom(Rn)= ∅,X ∈ dom(Rn),Y ∈ dom(Sn)}
∪ {(|[R Sn :: x ]|
, |[R {Z '→ ap(Rn(Z),Y ) | Z ∈ dom(Rn)}∪ Sn :: x ]|)
| Rn, Sn ∈ Rn, dom(Sn) ∩ dom(Rn)= ∅, rvar(p) ∩ dom(Rn)= ∅}

Alternative composition
The normal form of the alternative composition of the process terms p and q is a recursion scope containing the union of the recursion definitions of the normal forms of p and q, and a new recursion definition that defines the alternative composition of Y and Z. Since we only allow tail-recursion we cannot introduce the equation X '→ Y ▢ Z, therefore we use X '→ Rn(Y ) ▢ Rn(Z).
N (p ▢ q)= |[R Rn ∪ Sn ∪ {X '→ Rn(Y ) ▢ Sn(X)} :: X ]|,
where N (p)= |[R Rn :: Y ]|, N (q)= |[R Sn :: Z ]|, dom(Rn) ∩ dom(Sn)= ∅, X ∈/ dom(Rn ∪ Sn)

The observation that p and q are strict subterms of p ▢ q is sufficient to guarantee well-definedness of N (p ▢ q). By induction on the structure of p and q, we may conclude that the righthand side of the definition of N (p ▢ q) is indeed in normal form. Finally, bisimilarity of p ▢ q and N (p ▢ q) follows from the properties given in the beginning of this section, and in addition the distribution of alternative composition of recursion scopes.
DAS |[R R :: p ▢ q ]| ↔ |[R R :: p ]|▢ |[R R :: q ]|

Parallel composition
The normal form of the parallel composition of ps and qs is a recursion scope con- taining the union of the recursion definitions of the normal forms of ps and qs, and a new recursion definition that defines the parallel composition of each definition in the normal form of ps with each definition in the normal form of qs by means of function μ : Rn × Rn → Rn.
N (ps  qs)= |[R Rn ∪ Sn ∪ μ(Rn, Sn) :: XY ]|
where N (ps)= |[R Rn :: X ]|, N (qs)= |[R Sn :: Y ]|, dom(Rn) ∩ dom(Sn)= ∅
∀X∈dom(Rn ),Y ∈dom(Sn) XY ∈/ dom(Rn ∪ Sn)
Here, XY ∈ X denotes the recursion variable that is obtained by the syntactical concatenation of the recursion variables represented by X and Y , meaning the parallel composition of the definitions of X and Y , |[R Rn ∪ Sn ∪ μ(Rn, Sn) :: XY ]|
— |[R Rn :: X ]| |[R Sn :: Y ]|.
By means of function μ the parallel composition of all definitions in the recursion definitions Rn and Sn is created. This creates all possible parallel compositions of definitions Rn(X) and Sn(Y ). As parallel composition is not part of the syntax of the normal form, it needs to be eliminated. It is eliminated by replacing parallel process terms with process terms that model the behavior of the parallel composition.
The behavior of the parallel composition operator is defined as: the behavior with respect to action transitions of the parallel composition of process terms p and q is the interleaving of the behaviors with respect to action transitions of p and q. The parallel composition allows the synchronization of matching send and receive actions, which results in a communication action. This can be denoted by the communication process term. The time transitions of the parallel composition of process terms p and q have to synchronize. The behavior with respect to time transitions is the same as that of alternative composition. Therefore, the parallel composition of pn and qn can be rewritten as the alternative composition of the process terms in pn and qn, see functions αl : Pn ×X → Pn and αr : X × Pn → Pn, and the synchronization of send and receive process terms in pn and qn, see function γ : Pn × Pn → Pn.
μ(Rn, Sn)= {XY '→ αl(Rn(X),Y ) ▢ αr(X, Sn(Y )) ▢ γ(Rn(X), Sn(Y ))
| X ∈ dom(Rn),Y ∈ dom(Sn) }

Function αl returns a process term which models the allowed time transitions of the left process term, and the action transitions of the parallel composition if the left process term is executed first. Delay predicates are returned unmodified. Ter- minating process terms, pact and [pact], continue with the process term of the right side, defined by Y . Non-terminating process terms, pact; X and [pact]; X, continue as the parallel composition of the process term defined by X, and the process term of the right side, defined by Y ; syntactically denoted as XY . Function αl distributes over the guard operator and alternative composition operator. Note that the re- cursion definition for recursion variable XY is also created (for complete recursion definitions), see function μ.
αl(u, Y )	= u
αl(pact,Y )	= pact; Y αl([pact],Y )	= [pact]; Y αl(pact; X, Y ) = pact; XY αl([pact]; X, Y ) = [pact]; XY
αl(b → png,Y )  = b → αl(png,Y ) αl(pn ▢ qn,Y )	= αl(pn,Y ) ▢ αl(qn,Y )
Function αr returns a process term which models the allowed time transitions
of the right process term, and the action transitions of the parallel composition if the right process term is executed first. The function αr follows the same schema as function αl, delay predicates are returned unmodified, terminating process terms continue as X, and non-terminating process terms as XY .
αr(X, u)	= u
αr(X, pact)	= pact; X αr(X, [pact])	= [pact]; X αr(X, pact; Y ) = pact; XY αr(X, [pact]; Y ) = [pact]; XY
αr(X, b → png) = b → αr(X, png)
αr(X, pn ▢ qn)	= αr(X, pn) ▢ αr(X, qn)
Parallel send and receive process terms with matching channels synchronize. This behavior is represented in normal forms by the communication process term h !? xn := en. Note that the behavior of the parallel composition operator with respect to time transitions is completely modeled by the alternative composition of the process terms returned by αl and αr. The communication process terms may not influence time transitions, therefore the any delay operator is applied to all generated communication process terms. The transformation from parallel send

and receive process terms to a delayable communication process term is defined by means of function γ. Before function γ is further specified, first some notations are introduced. The syntax for the process terms pns, pnr, pngs, pngr defines the respective sets Pns, Pnr, Pngs, Pngr as follows:
pns ::= h !! en | [h !! en] | h !! en; X | [h !! en]; X
pnr ::= h ?? xn | [h ?? xn] | h ?? xn; X | [h ?? xn]; X pngs ::= pns | b → pngs
pngr ::= pnr | b → pngr
Function ch : Pngr ∪ Pngs →H is introduced to extract the channel from (guarded) send and receive process terms:






ch(h !! en)= ch([h !! en]) = ch(h !! en; X)= ch([h !! en]; X)= h
ch(h ?? xn)= ch([h ?? xn]) = ch(h ?? xn; X)= ch([h ?? xn]; X)= h ch(b → pngs)= ch(pngs)
ch(b → pngr)= ch(pngr)






Now function γ is further specified. Matching send and receive process terms result in a delayable communication process term:
γ(h !! en,h ?? xn) = γ([h !! en],h ?? xn)= γ(h !! en, [h ?? xn)])
= γ([h !! en], [h ?? xn)]) = [h !? xn := en]
γ(h ?? xn,h !! en) = γ([h ?? xn],h !! en)= γ(h ?? xn, [h !! en)])
= γ([h ?? xn], [h !! en)]) = [h !? xn := en]
If one of the matching send or receive process terms is non-terminating, then the communication process term continues with the process term defined by X or Y (depending on left or right process terms). If the matching send and receive process terms are both non-terminating, then the communication process terms continues as the parallel composition of the process term defined by X, and the process term defined by Y , syntactically denoted as XY .



γ(pns; X, qnr)	= γ(pns, qnr); X
γ(qnr; X, pns)	= γ(qnr, pns); X
γ(pns; X, qnr; Y ) = γ(pns, qnr); XY
γ(qnr, pns; Y )	= γ(qnr, pns); Y
γ(pns, qnr; Y )	= γ(pns, qnr); Y
γ(qnr; X, pns; Y ) = γ(qnr, pns); XY
where ch(pns)= ch(qnr)
If one of the matching send or receive process terms is guarded by b, then the communication process term is also guarded by b. If the matching send and receive process term are both guarded, then the communication process term is guarded by the conjunction of the guards:

γ(b → pngs, qnr)= b → γ(pngs, qnr) γ(qnr, b' → pngs)= b' → γ(qnr, pngs) where ch(pngs)= ch(qnr)
γ(pns, b' → qngr)= b' → γ(pns, qngr) γ(b → qngr, pns)= b → γ(qngr, pns) where ch(pns)= ch(qngr)
γ(b → pngs, b' → qngr)= b ∧ b' → γ(pngs, qngr)
γ(b → qngr, b → pngs)= b ∧ b → γ(qngr, pngs) where ch(pngs)= ch(qngr),

In all other cases no communication action is possible, therefore a delay predicate ‘true’ is returned. Note that we have: p ▢ true ↔ p. The first case is (guarded) send and receive process terms with non-matching channels:
γ(pngs, qngr)= γ(qngr, pngs)= true where ch(pngs) /= ch(qngr)
The second case is not to have a combination of a send and a receive process term:
γ(png, qng)= true
where ¬(png ∈ Pngs ∧ qng ∈ Pngr) ∧ ¬(png ∈ Pngr ∧ qng ∈ Pngs)

Communication can only be determined for pairs of (guarded) process terms. There- fore alternative process terms are expanded until only pairs of (guarded) process terms remain.
γ(pn ▢ p' , qn)= γ(pn, qn) ▢ γ(p' , qn)
n	n
γ(pn, qn ▢ q' )= γ(pn, qn) ▢ γ(pn, q' )
n	n
The definition of N (ps  qs) makes recursive use of N (ps) and N (qs). Observe that ps and qs are strict subterms of ps  qs, so well-definedness of N is reduced to well-definedness of the function μ, which in turn reduces to well-definedness of αl, αr and γ. Well-definedness of the latter three functions is easily verified by observing that what appears in the recursions on the righthand sides are strict subterms of the lefthand side. Furthermore, N (ps  qs) ∈ Pn follows if μ(Rn, Sn) ∈ Rn. The latter follows if αl(pn,Y ), αr(X, qn), γ(pn, qn) ∈ Pn, which is proven by induction on the structure of pn and qn.
Bisimilarity N (ps  qs) ↔ ps  qs is hard to prove using properties, so we give the witnessing bisimulation relation D. That this is indeed a bisimulation relation is straightforward to verify. Note, that we used Theorem 4.1 and the completeness of Rn and Sn (which follows from ps, qs ∈ Ps) while constructing and proving this bisimulation relation.
D = {(|[R Rn :: X ]| |[R Sn :: Y ]| , |[R Rn ∪ Sn ∪ μ(Rn, Sn) :: XY ]|)
| Rn, Sn ∈ Rn, dom(Rn) ∩ dom(Sn)= ∅,X ∈ dom(Rn),Y ∈ dom(Sn)}
∪ {(|[R Rn :: Rn(X) ]| |[R Sn :: Sn(Y ) ]|
, |[R Rn ∪Sn ∪ μ(Rn, Sn) :: αl(Rn(X),Y ) ▢ αr(X, Sn(Y )) ▢ γ(Rn(X), Sn(Y )) ]|)
| Rn, Sn ∈ Rn, dom(Rn) ∩ dom(Sn)= ∅,X ∈ dom(Rn),Y ∈ dom(Sn)}
∪ {(|[R Rn :: X ]| |[R Sn :: Sn(Y ) ]|, |[R Rn ∪ Sn ∪ μ(Rn, Sn) :: XY ]|)
| Rn, Sn ∈ Rn, dom(Rn) ∩ dom(Sn)= ∅,X ∈ dom(Rn),Y ∈ dom(Sn)}
∪ {(|[R Rn :: Rn(X) ]| |[R Sn :: Y ]|, |[R Rn ∪ Sn ∪ μ(Rn, Sn) :: XY ]|)
| Rn, Sn ∈ Rn, dom(Rn) ∩ dom(Sn)= ∅,X ∈ dom(Rn),Y ∈ dom(Sn)}
∪ {(|[R Un :: Z ]| , |[R Un ∪ V :: Z ]|)
| Un ∈ Rn,V ∈ R, dom(Un) ∩ dom(V )= ∅,Z ∈ dom(Un)}
∪ {(|[R Un :: Un(Z) ]| , |[R Un ∪ V :: Un(Z) ]|) | Un ∈ Rn,
V ∈ R, dom(Un) ∩ dom(V )= ∅, rvar(Un(Z)) ∩ dom(V )= ∅,Z ∈ dom(Un)}

Recursion scope
The normal form of the recursion scope operator process term is defined in terms of linearization of the righthand sides of the recursion definition by means of function NR : R→ Rn.
N (|[R R :: X ]|)= |[R NR(R) :: X ]|

In the second form |[R R :: p ]| of the recursion scope operator, the recursion definition of the normal form of p is joined with the linearized recursion definitions:


N (|[R R :: p ]|)= |[R NR(R) ∪ Sn :: X ]|
where N (p)= |[R Sn :: X ]|, dom(NR(R)) ∩ dom(Sn)= ∅



The normal form of a recursion definition is the union of the recursion definition of the normal form of p with a recursion definition that defines a mapping from the original recursion variable X to the recursion variable that defines the normal form of p. Since we only allow tail-recursion we cannot use the equation X '→ Y , therefore we use X '→ Rn(Y ).


NR(∅)= ∅
NR({X '→ p})= Rn ∪ {X '→ Rn(Y )}
where N (p)= |[ Rn :: Y ]|, X ∈/ dom(Rn)

NR(R ∪ S)= NR(R) ∪ NR(S)
where dom(NR(R)) ∩ dom(NR(S)) = ∅



Note that the intermediate normal from can be an incomplete recursion scope. However the normal form of the whole recursion scope operator process term is complete.
Clearly, N (|[R R :: X ]|) and N (|[R R :: p ]|) are well-defined if NR is well defined, in turn well-definedness of NR may be concluded from the observation that all recursive calls of N are made on righthand sides from R. Furthermore, N (|[R R :: X ]|) ∈ Pn if NR(R) ∈ Rn, which follows by induction on the structure of R. Bisimilarity of terms is proven using induction and the properties in the beginning of this section, and additionally:


S5	|[R {Y '→ |[R S :: X ]|} :: p ]| ↔ |[R S ∪ {Y '→ S(X)} :: p ]|


for rvar(p) ∩ dom(S)= ∅.
Let N (p)= |[R Sn :: Z ]|, R = {Xi '→ pi | i ∈ I}, and N (pi)= |[R Ri :: Yi ]|. Then,

N (|[R R :: p ]|)
= |[R	(Ri ∪ {Xi '→ Ri (Yi)}) ∪ Sn :: Z ]|	definition
|[R	(Ri ∪ {Xi '→ Ri (Yi)}) :: |[R Sn :: Z ]|]|	using S4
|[R	(Ri ∪ {Xi '→ Ri (Yi)}) :: N (p) ]|	definition
|[R	(Ri ∪ {Xi '→ Ri (Yi)}) :: p ]|	induction
i∈I	n	n
j
|[	(Ri ∪ {X '→ Ri (Y )}) :: |[ R ∪ {X '→ R (Y )} :: p ]|]| using S4

|[
(Ri ∪ {X
'→ Ri (Y )}) :: |[
{X '→ |[
Rj :: Y
]|} :: p ]|]| using S5

|[
(Ri ∪ {X
'→ Ri (Y )}) ∪ {X
'→ |[
Rj :: Y
]|} :: p ]|	using S4

and repeating the last three steps over all j ∈ I
|[R {Xi '→ |[R Ri :: Yi ]|| i ∈ I} :: p ]|
|[R {Xi '→ N (pi) | i ∈ I} :: p ]|	definition
|[R {Xi '→ pi | i ∈ I} :: p ]|	induction
|[R R :: p ]|	definition

Encapsulation
The normal form of a process term ps encapsulated with the action labels A is the encapsulation distributed over the recursion definition of the normal form of ps, by means of function Te : Pn ×A → Pn.
N (∂A(ps)) = |[R {Y '→ Te(Rn(Y ), A) | Y ∈ dom(Rn)} :: X ]| where N (ps)= |[R Rn :: X ]|

An action process term is replaced by the deadlock process term δ, if the action label is in the set of action labels to encapsulate, otherwise an action process term is left unchanged. It is assumed that action encapsulation is based on channel names and not on the values sent or received; the notations isa(h, ∗), ira(h, ∗, ∗), ca(h, ∗) mean the respective action labels for all possible values.



Te(W : r 
l , A)= ⎧⎪⎨ δ	if la ∈ A
⎧ ⎪⎩ W : r  la if la ∈/ A

Te(h !! en
, A)= ⎪⎨ δ	if isa(h, ∗) ∈ A
⎪⎩ h !! en if isa(h, ∗) ∈/ A

T (h ?? x , A)= ⎧⎪⎨ δ	if ira(h, ∗, ∗) ∈ A
⎪⎩ h ?? xn if ira(h, ∗, ∗) ∈/ A
T (h !? x  := e , A)= ⎧⎪⎨ δ	if ca(h, ∗) ∈ A
⎪⎩ h !? xn := en if ca(h, ∗) ∈/ A
Te(u, A)	= u	Te([pact], A)	= [Te(pact, A)] Te(pact; X, A) = Te(pact, A); X	Te([pact]; X, A) = [Te(pact, A)]; X
Te(b → png, A) = b → Te(png, A) Te(pn ▢ qn, A)  = Te(pn, A) ▢ Te(qn, A)

Since ps is a strict subterm of ∂A(ps), well-definedness of N (∂A(ps)) depends only on well-definedness of Te. Well-definedness of Te can be verified by observing that what occurs in recursions on the righthand side is a strict subterm of the lefthand side. Furthermore, N (∂A(ps)) ∈ Pn if {Y '→ Te(Rn(Y ), A) | Y ∈ dom(Rn)}∈ Rn, which follows from Te(pn, A) ∈ Pn. The latter is verified by induction on the structure of pn. Bisimilarity of ∂A(ps) and N (∂A(ps)), rather surprisingly, turned out to be hard to prove using properties. However, with induction it suffices to give a bisimulation relation D witnessing N (∂A(ps)) ↔ ∂A(N (ps)). As before, we use Theorem 4.1 and completeness of Rn (following from ps ∈ Ps) to construct and prove this (rather trivial) bisimulation relation.
D = {(|[R {Y '→ Te(Rn(Y ), A) | Y ∈ dom(Rn)} :: X ]|, ∂A(|[R Rn :: X ]|))
| Rn ∈ Rn,X ∈ dom(Rn)}
∪ {(|[R {Y '→ Te(Rn(Y ), A) | Y ∈ dom(Rn)} :: Rn(X) ]|, ∂A(|[R Rn :: Rn(X) ]|))
| Rn ∈ Rn,X ∈dom(Rn)}


Bottle filling line example
Figure 1 shows a bottle filling line, based on [1], consisting of a storage tank that is continuously filled with a flow Qin, a conveyor belt that supplies empty bottles, and a valve that is opened when an empty bottle is below the filling nozzle, and is closed when the bottle is full. When a bottle has been filled, the conveyor starts moving to put the next bottle under the filling nozzle, which takes one unit of time. When the storage tank is not empty, the bottle filling flow Q equals Qset. When the storage tank is empty, the bottle filling flow equals the flow Qin. The system should operate in such a way that overflow of the tank does not occur. We assume Qin < Qset.
Figure 2 shows an iconic representation of the model of the filling line. It consists of the processes Tank and Conveyor that interact by means of the channels open and close , and shared variable Q. The model is defined below. It has two parameters:


Qin



Fig. 1. Filling Line.






open
close









Fig. 2. Iconic model of the filling line.

the initial volume VT0 of the storage tank, and the value Qin of the flow that is used to fill the storage tank. The constants Qset, VTmax, and VBmax define the maximum value of the bottle filling flow Q, the maximum volume of the storage tank, and the filling volume of the bottles, respectively. The model FillingLine consists of the algebraic variable Q, the channels open and close , and the parallel composition of the process instantiations for the tank and the conveyor.
const Qset : real =3 
, VTmax : real = 20
, VBmax : real = 10
model FillingLine(val VT0, Qin : real)= 
|[ alg Q : real
, chan open, close : void
:: Tank (Q, open , close , VT0, Qin)

 Conveyor (Q, open , close)
]|
The Tank process has a local continuous variable VT that is initialized to VT0. Its process body is a recursion scope consisting of three modes: closed, opened, and openedempty that correspond to the valve being closed, the valve being open, and the valve being open while the storage tank is empty. In the mode opened, the storage tank is usually not empty. When the storage tank is empty in mode opened, the delayable skip statement [skip] may be executed causing the next mode to be openedempty. Due to the consistent equation semantics, the skip statement can be executed only if the delay predicate in the next mode, i.e. openedempty, holds. This means, among others, that VT = 0 must hold. Therefore, the transition to mode openedempty can be taken only when the storage tank is empty. Note that

the comma in delay predicates denotes conjunction. E.g.
V˙T = Qin ∧ Q = 0.
V˙T = Qin, Q =0 means

proc Tank (alg Q : real, chan open ?, close ?: void, val VT0, Qin : real)= 
|[ cont VT : real = VT0
:: |[ mode closed =
( V˙T = Qin, Q = 0, VT ≤ VTmax ▢ open ?; opened )
, mode opened =
( V˙T = Qin − Q, Q = Qset , 0 ≤ VT ≤ VTmax
▢ [skip]; openedempty
▢ close ?; closed
)
, mode openedempty =
( VT = 0,Q = Qin ▢ close ?; closed )
:: closed
]|
]|
Process Conveyor supplies an empty bottle in 1 unit of time (VB,t := 0, 1; t˙ =
−1 ▢ t ≤ 0 → skip). Then it synchronizes with the storage tank process by means of the send statement open !!, and it proceeds in mode filling. When the bottle is filled in mode filling (VB ≥ VBmax), the process synchronizes with the storage tank to close the valve and returns to mode moving. The initial mode is moving.
proc Conveyor (alg Q : real, chan open !, close !: void)= 
|[ cont VB : real = 0,t : real
:: |[ mode moving= ( VB,t := 0, 1; t˙ = −1 ▢ t ≤ 0 → skip; open !!; filling )
, mode filling = ( VB ≥ VBmax → close !!; moving )
:: moving
]|
 V˙B = Q

]|
Figure 3 shows the results of the first 12 time units of a simulation run of the model FillingLine(5, 1.5), that is with model parameters VT0 =5 and Qin = 1.5. The graph shows that the first bottle is filled from time point 1 until time point 1 + 10/3 ≈
4.33. Filling of the second bottle starts 1 time unit later, and somewhat after 7 time units, the storage tank becomes empty, so that filling continues at the reduced flow rate.
14
12
10
8
6
4
2
0
0	2	4	6	8	10	12
time

Fig. 3. Simulation results of model FillingLine.


Elimination of process instantiation
Elimination of the process instantiations for the Tank and Conveyor processes by replacing the process instantiations by their definitions, as defined in [5,20], leads to the following model:
model FillingLine(val VT0, Qin : real)= 
|[ alg Q : real, chan open, close : void
:: |[ var V L : real = VT0 , QL : real = Qin
:: |[ cont VT : real = V L
:: |[ mode closed =
( V˙T = QL , Q = 0, VT ≤ VTmax ▢ open ?; opened )
, mode opened =
( V˙T = QL − Q, Q = Qset, 0 ≤ VT ≤ VTmax
▢ [skip]; openedempty
▢ close?; closed
)
, mode openedempty =

( VT = 0,Q = QL
▢ close?; closed )

:: closed
]| ]|

]|
|[ cont VB : real = 0,t : real
:: |[ mode moving= ( VB,t := 0, 1; t˙ = −1 ▢ t ≤ 0 → skip; open !!; filling )
, mode filling = ( VB ≥ VBmax → close !!; moving )
:: moving
]|
V˙B = Q
]|
]|
To avoid naming conflicts between the formal parameters VT0 and Qin declared in the process definition for process Tank , and the actual arguments VT0 and Qin in the process instantiation Tank (Q, open , close, VT0, Qin), the newly defined local discrete variables that are used to hold the values of the last two parameters of the process
instantiation, are renamed to V L and QL .
Without changing the semantics, two nested variables scope operators can be combined resulting in one variable scope operator iff both variable scope operators declare different local variables 7 . For example, |[ var x : real =0 :: |[ var y : real =1 :: p ]|]| ↔ |[ var x : real = 0,y : real =1 :: p ]|.
Similarly, the parallel composition of two variable scope operators can be com- bined resulting in one variable scope operator applied on a process term that consists of the parallel composition of the original process terms of the variable scopes. For example, |[ var x : real =0 :: p ]| |[ var y : real =1 :: q ]| ↔ |[ var x : real = 0,y : real = 1 :: p q ]|.

Elimination of parallel composition
The combination of the variable scopes, elimination of parallel composition and translation to the normal form as discussed in Section 3 leads to the model:
model FillingLine(val VT0, Qin : real)= 
|[ alg Q : real, chan open, close : void
:: |[ cont VT : real = V L , VB : real =0 
, cont t : real, var V L : real = VT0 , QL : real = Qin
:: |[ moving closed =
( V˙T = QL , Q = 0, VT ≤ VTmax , V˙B = Q
▢ VB,t := 0, 1; moving0 closed
)
, moving0 closed =
( V˙T = QL , Q = 0, VT ≤ VTmax , V˙B = Q, t˙ = −1
▢ t ≤ 0 → skip; moving1 closed
)
, moving1 closed =

7 This may require renaming of local variables.

( V˙T = QL , Q = 0, VT ≤ VTmax , V˙B = Q
▢ open !?; filling opened
)
, filling opened =
( V˙T = QL − Q, Q = Qset , 0 ≤ VT ≤ VTmax , V˙B = Q
▢ [skip]; filling openedempty
▢ VB ≥ VBmax → close !?; moving closed
)
, filling openedempty =
( VT = 0, Q = QL , V˙B = Q
▢ VB ≥ VBmax → close !?; moving closed
)
:: moving closed
]|
]|
]|

Substitution of constants and additional elimination
The model below is the result of substitution of the globally defined constants by
their values. Furthermore, the discrete variables QL and V L , that were introduced
by elimination of the process instantiations, are eliminated. Also, the presence of the undelayable statements VB,t := 0, 1 and open !? in modes moving closed and moving1 closed, respectively, allows elimination of the differential equations in these modes.
Most hybrid automaton based model checkers, such as PHAver [12] and HyTech [14], do not (yet) have urgent transitions that can be combined with guards. There- fore, the urgency in the guarded statements is removed by making the statements that are guarded delayable, and adding the closed negation of the guard as an ad- ditional delay predicate (invariant). E.g. t ≤ 0 → skip is rewritten as t ≥ 0 ▢ t ≤ 0 → [skip].
model FillingLine(val VT0, Qin : real)= 
|[ alg Q : real, chan open, close : void
:: |[ cont VT : real = VT0 , VB : real = 0, t : real
:: |[ moving closed =
( VT ≤ 20, Q =0 
▢ VB,t := 0, 1; moving0 closed
)
, moving0 closed =
( V˙T = Qin, Q = 0, VT ≤ 20, V˙B = 0, t˙ = −1, t ≥ 0
▢ t ≤ 0 → [skip]; moving1 closed
)
, moving1 closed =
( VT ≤ 20, Q =0 

▢ open !?; filling opened
)
, filling opened =
( V˙T = Qin − 3, Q = 3, 0 ≤ VT ≤ 20, V˙B = 3, VB ≤ 10
▢ [skip]; filling openedempty
▢ VB ≥ 10 → [close !?]; moving closed
)
, filling openedempty =
( VT = 0, Q = Qin, V˙B = Q, VB ≤ 10
▢ VB ≥ 10 → [close !?]; moving closed
)
:: moving closed
]|
]|
]|
Figure 4 shows a graphical representation of the model. By means of straight- forward mathematical analysis of the model, it can be shown that overflow never occurs if Qin ≤ 30/13.

























Fig. 4. Graphical representation of the linearized χ model.

Tool based veriﬁcation
As a final step, for the purpose of tool-based verification, the model is translated to the input language of the hybrid IO automaton based tool PHAVer [12]. Since

most hybrid automata, including PHAVer, do not know the concept of an algebraic variable, first the algebraic variables are eliminated from the χ model. Because of the consistent equation semantics of χ, each occurrence of an algebraic variable in the model can simply be replaced by the right hand side of its defining equation. The urgency due to unguarded undelayable statements is in principle translated by defining the corresponding flow clause as false. The resulting PHAVer model follows below. Note that an additional variable x is introduced and the derivatives of Vb and Vt need to be defined in all locations, because of the current inability of PHAVer to define false as flow clause.
automaton filling_line state_var: Vt,Vb,t,x; parameter: Vt0,Qin; synclabs : open,close,tau; loc moving_closed:
while Vt <= 20 & x==0 wait {x’==1 & Vb’==0 & Vt’==0}; when true sync tau do {Vt’==Vt & Vb’==0 & t’==1 & x’==0}
goto moving0_closed; loc moving0_closed:
while Vt <= 20 & t >= 0 wait {Vb’==0 & t’==-1 & Vt==30/13}; when t <= 0 sync tau do {Vt’==Vt & Vb’==Vb & t’==t & x’==0}
goto moving1_closed; loc moving1_closed:
while Vt <= 20 & x==0 wait {x’==1 & Vb’==0 & Vt’==0}; when true sync open do {Vt’==Vt & Vb’==Vb & t’==t}
goto filling_opened; loc filling_opened:
while Vt >= 0 & Vt <= 20 & Vb <= 10 wait {Vb’==3 & Vt’==30/13-3}; when Vt==0 sync tau do {Vt’==Vt & Vb’==Vb & t’==t}
goto filling_openedempty;
when Vb >= 10 sync close do {Vt’==Vt & Vb’==Vb & t’==t & x’==0} goto moving_closed;
loc filling_openedempty:
while Vt == 0 & Vb <= 10 wait {Vb’==30/13};
when Vb >= 10 sync close do {Vt’==Vt & Vb’==Vb & t’==t & x’==0} goto moving_closed;
initially moving_closed & Vt == Vt0 & Vb==0 & x==0; end
The following properties were derived: if Qin = 30/13 and 0 ≤ VT0 ≤ VTmax − 30/13, overflow does not occur, and the storage tank does not become empty when filling a bottle. The volume of the storage tank then remains in the region VT0 ≤ VT ≤ VT0 + 30/13. If Qin > 30/13, eventually overflow occurs. If Qin < 30/13, eventually the container becomes empty every time a bottle is filled. In this small example, these properties can also be derived by means of straightforward mathe- matical analysis of the χ models of Section 5.2 or 5.3.

Conclusions and future work
The χ language is a hybrid process algebra, with a formal syntax and semantics, and is connected to a number of tools that can help in the design and analysis of hybrid systems. It has been applied in a number of case studies thereby showing its usefulness.
In this paper, we investigated equational reasoning in the χ language. A specifi- cation can be rewritten to a normal form, in a restricted syntax, so that translations to other languages and tools become easier. In particular, in this way the parallel composition operator can be eliminated, which is called linearization. We define the linearization of a reasonably expressive subset of χ. The correctness of this linearization has been proved, and an implementation of the algorithm is described in [23].
In our linearization algorithm, the number of recursion variables is linear in the number of variables of a process term, except in the case of parallel composition. In that case, the number of recursion variables can grow exponentially. We expect that this situation can be improved, some progress is reported in [17].
For the future, we plan to work on extending the applicability of the algorithm by considering a larger subset of χ and by performing case studies. Furthermore, building tools for simulation, transition system generation, and translation to the input format of other powerful verification tools can be considered.

References
Baeten, J. C. M. and C. A. Middelburg, “Process Algebra with Timing,” EACTS Monographs in Theoretical Computer Science, Springer-Verlag, 2002.
Beek, D. A. v., A. v. d. Ham and J. E. Rooda, Modelling and control of process industry batch production systems, in: E. Camacho, L. Basanez and J. de la Puente, editors, 15th Triennial World Congress of the International Federation of Automatic Control, Barcelona, 2002, CD-ROM.
Beek, D. A. v., K. Man, M. A. Reniers, J. E. Rooda and R. R. H. Schiffelers, Deriving simulators for hybrid Chi models, in: IEEE International Symposium on Computer-Aided Control Systems Design (2006), pp. 42–49.
Beek, D. A. v., K. Man, M. A. Reniers, J. E. Rooda and R. R. H. Schiffelers, Formal verification of hybrid Chi models using PHAVer, in: Proceedings of the conference on Mathematical Modelling 2006, Vienna, Austria, 2006.
Beek, D. A. v., K. L. Man, M. A. Reniers, J. E. Rooda and R. R. H. Schiffelers, Syntax and consistent equation semantics of hybrid Chi, Journal of Logic and Algebraic Programming 68 (2006), pp. 129–210.
Beek, D. A. v., R. R. H. Schiffelers, M. Kvasnica and M. A. P. Remelhe, Specification of the simulation interface, Technical Report D 3.4.1, HYCON NoE (2005).
Bortnik, E. M., N. Trˇcka, A. J. Wijs, B. Luttik, J. M. v. d. Mortel-Fronczak, J. C. M. Baeten, W. J. Fokkink and J. E. Rooda, Analyzing a Chi model of a turntable system using Spin, CADP and Uppaal, Journal of Logic and Algebraic Programming 65 (2005), pp. 51–104.
Bos, V. and J. J. T. Kleijn, Automatic verification of a manufacturing system, Robotics and Computer Integrated Manufacturing 17 (2000), pp. 185–198.
Bos, V. and J. J. T. Kleijn, “Formal Specification and Analysis of Industrial Systems,” Ph.D. thesis, Eindhoven University of Technology (2002).
Brand, P. v. d., , M. A. Reniers and P. J. L. Cuijpers, Linearization of hybrid processes, Journal of Logic and Algebraic Programming 68 (2006), pp. 54–104.


Fernandez, J.-C., H. Garavel, A. Kerbrat, L. Mounier, R. Mateescu and M. Sighireanu, CADP: a protocol validation and verification toolbox, in: Rajeev Alur and Thomas A. Henzinger, editors, Eighth International Conference on Computer Aided Verification CAV, Lecture Notes in Computer Science 1102 (1996), pp. 437–440.
Frehse, G., PHAVer: Algorithmic verification of hybrid systems past HyTech, in: M. Morari and
L. Thiele, editors, Hybrid Systems: Computation and Control, 8th International Workshop, Lecture Notes in Computer Science 3414, Springer-Verlag, 2005 pp. 258–273.
Groote, J. F. and M. A. Reniers, Algebraic process verification, in: J. A. Bergstra, A. Ponse and S. A. Smolka, editors, Handbook of Process Algebra, Elsevier, 2001 pp. 1151–1208.
Henzinger, T. A., P.-H. Ho and H. Wong-Toi, A user guide to HyTech, in: E. Brinksma, R. Cleaveland,
K. G. Larsen, T. Margaria and B. Steffen, editors, Tools and Algorithms for Construction and Analysis of Systems, First International Workshop, Lecture Notes in Computer Science 1019 (1995), pp. 41–71.
Hofkamp, A. T., “Reactive machine control, a simulation approach using χ,” Ph.D. thesis, Eindhoven University of Technology (2001).
Holzmann, G. J., “The SPIN Model Checker: Primer and Reference Manual,” Addison Wesley Professional, Boston, 2003.
Khadim, U., D. A. v. Beek and P. Cuijpers, Linearization of hybrid chi using program counters, Technical Report CS-Report 07-18, Eindhoven University of Technology, Department of Computer Science, The Netherlands (2007).
Kleijn, J. J. T., M. A. Reniers and J. E. Rooda, Analysis of an industrial system, Formal Methods in System Design 22 (2003), pp. 249–282.
Larsen, K. G., P. Pettersson and W. Yi, Uppaal in a Nutshell, International Journal on Software Tools for Technology Transfer 1 (1997), pp. 134–152.
Man, K. L. and R. R. H. Schiffelers, “Formal Specification and Analysis of Hybrid Systems,” Ph.D. thesis, Eindhoven University of Technology (2006).
Nicollin, X. and J. Sifakis, The algebra of timed processes, ATP: Theory and application, Information and Computation 114 (1994), pp. 131–178.
The MathWorks, Inc, “Writing S-functions, version 6,” http://www.mathworks.com (2005).
Theunissen, R., “Process algebraic linearization of hybrid Chi,” Master’s thesis, Eindhoven University of Technology (2006).
Usenko, Y. S., “Linearization in μCRL,” Ph.D. thesis, Eindhoven University of Technology (2002).
