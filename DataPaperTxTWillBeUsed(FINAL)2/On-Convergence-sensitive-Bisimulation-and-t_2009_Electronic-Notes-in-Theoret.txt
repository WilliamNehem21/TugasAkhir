

Electronic Notes in Theoretical Computer Science 242 (2009) 3–17
www.elsevier.com/locate/entcs

On Convergence-sensitive Bisimulation and the Embedding of CCS in Timed CCS
Roberto M. Amadio1 ,2
Universit´e Paris Diderot

Abstract
We propose a notion of convergence-sensitive bisimulation that is built just over the notions of (internal) reduction and of (static) context. In the framework of timed CCS, we characterise this notion of ‘contextual’ bisimulation via the usual labelled transition system. We also remark that it provides a suitable semantic framework for a fully abstract embedding of untimed processes into timed ones. Finally, we show that the notion can be refined to include sensitivity to divergence.
Keywords: Bisimulation, convergence, timed CCS.


Introduction
The main motivation for this work is to build a notion of convergence-sensitive bisim- ulation from first principles, namely from the notions of internal reduction and of (static) context. A secondary motivation is to understand how asynchronous/untimed behaviours can be embedded fully abstractly into synchronous/timed ones. Because the notion of convergence is very much connected to the notion of time, it seems that a convergence-sensitive bisimulation should find a natural application in a synchronous/timed context. Thus, in a nutshell, we are looking for an ‘intuitive’ se- mantic framework that spans both untimed/asynchronous and timed/synchronous models.
For the sake of simplicity we will place our discussion in the well-known frame- work of (timed) CCS. We assume the reader is familiar with CCS [10]. Timed CCS (TCCS) is a ‘timed’ version of CCS whose basic principle is that time passes ex- actly when no internal computation is possible. This notion of ‘time’ is inspired by

1 PPS, UMR-7126. Work partially supported by ANR-06-SETI-010-02.
2 Email: amadio@pps.jussieu.fr

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.010

early work on the Esterel synchronous language [3], and it has been formalised in various dialects of CCS [14,12,6]. Here we shall follow the formalisation in [6].
As in CCS, one models the internal computation with an action τ while the pas- sage of (discrete) time is represented by an action tick that implicitly synchronizes all the processes and moves the computation to the next instant. 3
In this framework, the basic principle we mentioned is formalised as follows:
tick	τ
P −−→ · iff P −/→ · 

where we write P
μ
−→ · if P can perform an action μ. TCCS is designed so that if

P is a process built with the usual CCS operators and P cannot perform τ actions
tick
then P −−→ P . In other terms, CCS processes are time insensitive. To compensate
for this property, one introduces a new binary operator P d Q, called else next, that tries to run P in the current instant and, if it fails, runs Q in the following instant. We assume countably many names a, b,... For each name a there is a commu- nication action a and a co-action a. We denote with α, β,... the usual CCS actions which are composed of either an internal action τ or of a communication action
a, a,.. .. We denote with μ, μ',... either an action α or the distinct action tick.
The TCCS processes P, Q,... are specified by the following grammar
P ::= 0 | a.P | P + P | P | P | νa P | A(a) | P d P .
We denote with fn(P ) the names free in P . We adopt the usual convention that for each thread identifier A there is a unique defining equation A(b)= P where the parameters b include the names in fn(P ). The related labelled transition system is specified in table 1.
Say that a process is a CCS process if it does not contain the else next operator.
The reader can easily verify that:
tick	τ
P −−→ · if and only if P /−→ ·.
tick
If P −−→ Qi for i = 1, 2 then Q1 = Q2. One says that the passage of time is

deterministic.
If P is a CCS process and P
closed under labelled transitions.

tick
−−→ Q then P = Q. Hence CCS processes are

It will be convenient to write τ.P for νa (a.P | a.0) where a ∈/ fn(P ), tick.P for
0 dP , and Ω for the diverging process τ.τ... ..
Remark 1.1 (1) In the labelled transition system in table 1, the definition of the tick action relies on the τ action and the latter relies on the communication actions a, a',.. .. There is a well known method to give a direct definition of the τ action that does not refer to the communication actions. Namely, one defines (internal) reduction rules such as (a.P + Q | a.P ' + Q') → (P | P ') which are applied modulo a suitable structural equivalence.

3 There seems to be no standard terminology for this action. It is called є in [14], χ in [12], σ in [6], and sometimes ‘next’ in ‘synchronous’ languages `a la Esterel [2].



−→ P '	−→ Q'

a.P −→a  P
(P | Q) −→τ
(P ' | Q')


−→ P '	−→ P '

(P | Q) −→α
(P ' | Q)


P + Q −→α P '


A(a)= P

−α P '

A(b) τ
[b/a]P
P d Q −→α P '




tick	tick
0 −−→ 0	a.P −−→ a.P



τ
P /−→ · 
(P1 | P2) −/ →τ · 
tick

tick
P d Q −−→ Q
Pi −−→ Qi i = 1, 2

tick
(P1 | P2) −−→ (Q1 | Q2)



tick
Pi −−→ Qi i = 1, 2
tick
P1 + P2 −−→ Q1 + Q2
μ
P −→ Q a, a /= μ
μ
νa P −→ νa Q


Table 1
Labelled transition system

(2) The labelled transition system in table 1 relies on negative conditions of the shape P —/→τ . These conditions can be replaced by a condition E L P ↓ L, where L is a finite set of communication actions. The predicate ‘↓’ can be defined as follows:




0 ↓ ∅	a.P ↓ {a}
Pi ↓ Li,  i = 1, 2 (P1 + P2) ↓ L1 ∪ L2




P ↓ L
P d Q ↓ L
P ↓ L
(νa P ) ↓ L\{a, a}
Pi ↓ Li,  i = 1, 2 L1 ∩ L2 = ∅
(P1 | P2) ↓ L1 ∪ L2


Signals and a deterministic fragment
As already mentioned, the TCCS model has been inspired by the notion of time available in the Esterel model [4] and its relatives such as SL [5]. These models rely on signals as the basic communication mechanism. Unlike a channel, a signal persists within the instant and disappears at the end of it. It turns out that a signal can be defined recursively in TCCS as:
emit(a)= a.emit(a) d 0

The ‘present’ statement of SL that either reads a signal and continues the compu- tation in the current instant or reacts to the absence of the signal in the following instant can be coded as follows:
present a do P else Q = a.P d Q

Modulo these encodings, the resulting fragment of TCCS is specified as follows:
P ::= 0 | emit(a) | present a do P else P | (P | P ) | νa P | A(a) .
Notice that, unlike in (T)CCS, communication actions have an input or output polarity. The most important property of this fragment is that its processes are deterministic [5,1].
The usual labelled bisimulation
As usual, one can define a notion of weak transition as follows:
⎧⎨ (—→τ )∗	if μ = τ
μ
⇒=	τ	μ	τ
⎩ (—→)∗◦ —→ ◦(—→)∗ otherwise
where the notation X∗ stands for the reflexive and transitive closure of a binary
relation X. When focusing just on internal reduction, we shall write → for —→τ  and
⇒ for ⇒. We write P → · if E P ' (P → P '), otherwise we say that P has converged
and write P ↓. We write P ⇓ if E Q (P ⇒ Q and Q ↓). Thus P ⇓ means that P
may converge, i.e., there is a reduction sequence to a process that has converged.

tick
Because P ↓ iff P ——→ ·, we have that P ⇓ iff P
tick
⇒ ·.

With respect to the notion of weak transition, one can define the usual notion of bisimulation as the largest symmetric relation R such that if (P, Q) ∈ R and
μ	'	'	μ	'	'	'	u

P ⇒ P  then for some Q , Q ⇒ Q and (P ,Q ) ∈ R. We denote with ≈
the

largest labelled bisimulation (u for usual). When looking at CCS processes, one may focus on CCS actions (thus excluding the tick action). We denote with ≈u
the resulting labelled bisimulation.
CCS vs. TCCS
As we already noticed, TCCS has been designed so that CCS can be regarded as a transition closed subset of TCCS. A natural question is whether two CCS processes which are equivalent with respect to an untimed environment are still equivalent in a timed one. For instance, Milner [9] discusses a similar question when comparing CCS to SCCS. 4
Testing semantics
In the context of TCCS and of a testing semantics, the question has been answered negatively by Hennessy and Regan [6]. For instance, they notice that the processes P = a.(b + c.b)+ a.(d + c.d) and Q = a.(b + c.d)+ a.(d + c.b) are ‘untimed’ testing equivalent but ‘timed’ testing inequivalent. The relevant test is the one that checks that if an action b cannot follow an action a in the current instant then an action b

4 The notion of instant in SCCS is quite different from the one considered in TCCS/Esterel. In the former one declares explicitly what each thread does at each instant while in the latter the duration of an instant is the result of an arbitrarily complex interaction among the different threads.

will happen in the following instant just after an action c (process P will not pass this test while process Q does). This remark motivated the authors to develop a notion of ‘timed’ testing semantics.
Bisimulation semantics
What is the situation with the usual labelled bisimulation semantics recalled in section 1.2? Things are fine for reactive processes which are defined as follows.
μ1	μn
Definition 1.2 A process P is reactive if whenever P ⇒ ··· ⇒ Q, for n ≥ 0, we
have the property that all sequences of τ reductions starting from Q terminate.
Proposition 1.3 Suppose P, Q are CCS reactive processes. Then P ≈u Q if and
only if P ≈u  Q.

Proof. Clearly, ≈u is a CCS bisimulation, hence P ≈u Q implies P ≈u
ccs
Q. To

show the converse, we prove that ≈u is a timed bisimulation. So suppose P ≈u Q
tick	'	τ	tick	τ	'	τ
and P ⇒ P . This means P ⇒ P1 ——→ P1 ⇒ P . Then for some Q1, Q ⇒ Q1 and

u ccs
Q1. Further, because Q1 is reactive there is a Q2 such that Q1 ⇒τ
Q2 and

Q2 ↓. By definition of bisimulation and the fact that P1 ↓, we have that P1 ≈u
Q2.

'	τ	'
'	u	'
ccs
'

So for some Q , Q2 ⇒ Q
and P
≈ccs Q . Thus we have shown that there is a Q

tick	'
'	u	'

such that Q ⇒ Q
and P
≈ccs Q .	 


Proposition 1.3 fails when we look at non-reactive processes. For instance, 0 and Ω are regarded as untimed equivalent but they are obviously timed inequivalent since the second process does not allow time to pass. This example suggests that if we want to extend proposition 1.3 to non-reactive processes, then the notion of bisimulation has to be convergence sensitive.
One possibility could be to adopt the usual bisimulation ≈u on CCS processes.

We already noticed that if P is a CCS process and P
—t—ic→k
Q then P = Q. Thus

in the bisimulation game between CCS processes, the condition ‘P
tick
⇒ P '
implies

tick	'
Q ⇒ Q ’ can be replaced by ‘P ⇓ implies Q ⇓’. The resulting equivalence on
CCS processes is not new, for instance it appears in [8] as the so called stable weak bisimulation. One may notice that this equivalence has reasonably good congruence properties.
Proposition 1.4 Suppose P1 ≈u P2 and Q1 ≈u Q2. Then
(P1 | R) ≈u (P2 | R).
If P1, P2 ↓ then P1 d Q1 ≈u P2 d Q2.
Proof. First note that we can work with an asymmetric definition of bisimulation where a strong transition is matched by a weak one.
tick	'	'
We just check the condition for the tick action. Suppose (P1 | R) ——→ (P1 | R ).

tick	'
tick	'
τ	''	''
u	''

This entails P1 ——→ P1 and R ——→ R . Then P2 ⇒ P2 , P2 ↓, and P1 ≈  P1 . Also

P '' tick	'
'	u	''	''

2 ⇒ P2 and P1 ≈  P2 . Finally, we have that (P2 | R) ↓ because if they could
synchronise on a name a then so could (P1 | R).

tick	tick
There are two cases to consider. If P1 d Q1 ——→ Q1 then P2 d Q2 ——→ Q2. If
P1 d Q1 —→a P ' because P1 —→a P ' then P2 ⇒a P ' and P ' ≈u P '.	 
1	1	2	1	2
Remark 1.5 The else next operator suffers from the same compositionality prob- lems as the sum operator.  For instance, 0 ≈u τ.0 but 0 d Q = tick.Q while τ.0 dQ ≈u 0. As for the sum operator, one may remark that in practice we are inter- ested in a guarded form of the else next operator. Namely, the else next operator is only introduced as an alternative to a communication action (the present operator discussed in section 1.1 is such an example). Proposition 1.4(2) entails that in this form, the else next operator preserves bisimulation equivalence.


An alternative path
The reader might have noticed that on CCS processes ≈u reﬁnes ≈u

by adding

may convergence as an observable along with the usual labelled transitions. This is actually the case of all convergence/divergence sensitive bisimulations we are aware of (see, e.g., [15,8]). The question we wish to investigate is: what happens if we just take may convergence as an observable without assuming the observability of the labelled transitions? The question can be motivated by both pragmatic and mathematical considerations. On the pragmatic side, one may argue that the normal operation of a timed/synchronous program is to receive inputs at the beginning of each instant and to produce outputs at the end of each instant. Thus, unless the instant terminates, no observation is possible. For instance, the process (a | Ω) could be regarded as equivalent to Ω, while they are distinguished by the usual bisimulation ≈u on the ground that the labelled transition a is supposed to be directly observable.
On the mathematical side, it has been remarked by many authors that the notion of labelled transition system is not necessarily compelling. Specifically, one would like to define a notion of bisimulation without an a priori commitment to a notion of label. To cope with this problem, a well-known approach started in [11] and elab- orated in [7] is to look at ‘internal’ reductions and at a basic notion of ‘barb’ and then to close under contexts thus producing a notion of ‘contextual’ bisimulation. However, even the notion ‘barb’ is not always easy to define and justify (an attempt based on the concept of bi-orthogonality is described in [13]). It seems to us that a natural approach which applies to a wide variety of formalisms is to regard conver- gence (may-termination) as the ‘intrinsic’ basic observable automatically provided by the internal reduction relation.
Contribution
Following these preliminary considerations, we are now in a position to describe our contribution.
We introduce a notion of contextual bisimulation for CCS whose basic observ- able (or barb) is the may-termination predicate (section 2).
We provide various characterisations of this equivalence culminating in one based on a suitable ‘convergence-sensitive’ labelled bisimulation (section 3).

We derive from this characterisation that (section 4):
the embedding of CCS in TCCS is fully abstract (even for non-reactive processes).
the proposed equivalence coincides with the usual one on reactive processes.
on non-reactive processes it identifies more processes than the usual timed labelled bisimulation ≈u.
on non-reactive CCS processes it is incomparable with the usual labelled
CCS bisimulation ≈u  .
We refine the proposed notion of contextual bisimulation by making it sensitive to divergence and show that the characterisation results mentioned above can be extended to this case (section 5).
The development will take place in the context of so called weak bisimulation
[10] which is more interesting and challenging than strong bisimulation.

Convergence sensitive bisimulation
We denote with C, D,... one hole static contexts specified by the following grammar:
C ::= [ ] | C | P | νaC
We require that the notion of bisimulation we consider is preserved by the static contexts in the sense of [7].
Definition 2.1 [bisimulation] A symmetric relation R on processes is a bisimula- tion if P RQ implies:
cxt for any static context C, C[P ]RC[Q].
μ	'	'	μ	'	'	'
red P ⇒ P , μ ∈ {τ, tick} implies E Q  (Q ⇒ Q and P RQ ).
We denote with ≈ the largest bisimulation.
Remark 2.2 (1) In view of remark 1.1(1), the definition 2.1 of bisimulation does not assume the labels a, a',... which correspond to the communication action. Not only the labels are not considered in the bisimulation game, but they are not even required in the definition of the τ action. This means that the definition can be directly transferred to more complex process calculi where the definition of commu- nication action is at best unclear.
tick
(2) For CCS processes, if P ——→ Q then P = Q. It follows that in the definition
above, the condition [red] when μ = tick can be replaced by P ⇓ implies Q ⇓. This is obviously false for processes including the else next operator; in this case one needs the tick action to observe the behaviour of processes after the first instant, e.g., to distinguish tick.a from tick.b.
In view of the previous remark, the definition of bisimulation is specialised to CCS processes by simply restricting the condition [cxt] to CCS static contexts. We denote with ≈ccs the resulting largest bisimulation.

Next we remark that the observability of a ‘stable commitment (or barb)’ is entailed by the observation of convergence.
Definition 2.3 We say that P (stably) commits on a, and write P ⇓a, if P ⇒ P ',
P ' ↓, and P ' —→a ·. 5

Proposition 2.4 If P ≈ Q and P ⇓a then Q ⇓a.
Proof. Suppose P ⇓a and P ≈ Q. Then P ⇒ P ', P ' ↓, and P ' —→a


·. By definition

of bisimulation, Q ⇒ Q'' and P ' ≈ Q''. Moreover, Q'' ⇒ Q', Q' ↓, Q' ≈ P ' ≈ Q''.
' a		'
To show that Q —→ ·, consider the context C = ([ ] | a.Ω). Then we have C[P ] /⇓,
while C[Q'] ⇓ if and only if Q' /—→a  ·.	 

Another interesting notion is that of contextual convergence.
Definition 2.5 We say that a process P is contextual convergent, and write P ⇓C, if E C (C[P ] ⇓).
Clearly, P ⇓ implies P ⇓C but the converse fails taking, for instance, (a+b) | a.Ω. Contextual convergence, can be characterised as follows.
Proposition 2.6 The following conditions are equivalent:

α1
P —→
··· —α—→n
P ' and P ' ↓.

There is a CCS process Q such that (P | Q) ⇓.
P ⇓C.

Proof. (1 ⇒ 2) Suppose P —α→1
α
P1 ··· ——→
Pn and Pn ↓. We build the process Q

in (2) by induction on n. If n =0 we can take Q = 0. Otherwise, suppose n > 0. By inductive hypothesis, there is Q1 such that (P1 | Q1) ⇓. We proceed by case analysis on the first action α1. If α1 = τ take Q = Q1 and if α1 = a take Q = a.Q1.
(2 ⇒ 3) Taking the static context C =[ ] | Q.

(3 ⇒ 1)	First, check by induction on a static context C that P
—→τ
· implies

τ	α
C[P ] —→ ·. Hence C[P ] ↓ implies P ↓. Second, show that C[P ] —→ Q implies that

'	'	'
'	α'	'

Q = C [P ] where C
τ
is a static context and either P = P
τ
or P —→ P . Third,

suppose C[P ] —→ Q1 ··· —→ Qn with Qn ↓. Show by induction on n that P can make
a series of labelled transitions and reach a process which has converged.	 

Remark 2.7 As shown by the characterisation above, the notion of contextual convergence is unchanged if we restrict our attention to contexts composed of CCS processes.
We notice that a bisimulation never identifies a process which is contextual con- vergent with one which is not while identifying all processes which are not contextual convergent.

5 Note that in this definition the process ‘commits’ on action a only when it has converged.

Proposition 2.8 (1) If P ≈ Q and P ↓C then Q ↓C.
(2) If P /↓C and Q /↓C then P ≈ Q.
Proof. (1) If P ↓C then for some context C, C[P ] ↓. By condition [cxt], we have that C[P ] ≈ C[Q], and by condition [red] we derive that C[Q] ↓. Hence Q ↓C.
(2) We notice that the relation S = {(P, Q) | P, Q /↓C} is a bisimulation. Indeed:
(i) if P /↓C then C[P ] /↓C, (ii) if P ⇒ P ' and P /↓C then P ' /↓C, and (iii) if P /↓C
tick
then P / ⇒ ·.
Characterisation
We characterise the (contextual and convergence sensitive) bisimulation introduced in definition 2.1 by means of a labelled bisimulation. The latter is obtained from the former by replacing condition [cxt] with a suitable condition [lab] on labelled transitions as defined in table 1.
Definition 3.1 [labelled bisimulation] A symmetric relation Y on processes is a labelled bisimulation if P YQ implies:

lab if P ↓C
P ' ↓C.
and P ⇒ P '
then Q ⇒ Q'
and P 'YQ'
where α ∈ {a, τ } and α = a if

μ	'	'	μ	'	'	'
red if P ⇒ P , μ ∈ {τ, tick} then E Q  (Q ⇒ Q and P YQ ).
We denote with ≈l the largest labelled bisimulation.
Remark 3.2 (1) By remark 2.2, on CCS processes the condition [red] when μ = tick is equivalent to: ‘P ↓ implies Q ↓’. By remark 2.7, the notion of contextual convergence is unaffected if we restrict our attention to CCS processes. This means that, by definition, the (timed) labelled bisimulation restricted to CCS processes is the same as the labelled bisimulation on (untimed) CCS processes.
The predicate of contextual convergence ↓C plays an important role in the con- dition [lab]. To see why, suppose we replace it with the predicate ↓ and assume we denote with ≈l⇓ the resulting largest labelled bisimulation. The following example shows that ≈l⇓ is not preserved by parallel composition. Consider:
P1 = a.(b + c),	P2 = a.b + a.c,	Q = a.(d + Ω) .

Then (P1 | Q) ≈l⇓ (P2 | Q) because both processes fail to converge. On the other hand, (P1 | Q) | d /≈l⇓ (P2 | Q) | d because the first may converge to (b + c) which cannot be matched by the second process.
One may consider an asymmetric and equivalent definition of labelled bisim- ulation where strong transitions are matched by weak transitions. To check the
equivalence, it is useful to note that P /↓C and P —→ P ' implies P ' /↓C.
We provide a rather standard proof that bisimulation and labelled bisimulation coincide.

Proposition 3.3 If P ≈ Q then P ≈l Q.
Proof. We show that the bisimulation ≈ is a labelled bisimulation. We denote with
P ⊕ Q the internal choice between P and Q which is definable, e.g., as τ.P + τ.Q.
Suppose P ↓C	'
and P ⇒ P . We consider a context C =[ ] | T where T = a.((b ⊕
0) ⊕ c) and b, c are ‘fresh names’ (not occurring in P, Q). We know C[P ] ≈ C[Q]

and C[P ] ⇒ (P ' | (b ⊕ 0)). Thus C[Q] ⇒ (Q' | T ') where either Q ⇒a
or Q ⇒ Q' and T = T '.
Q' and T ⇒a T '

Suppose P ' /↓C. Then (P ' | (b ⊕ 0)) /↓C and, by proposition 2.8, (Q' | T ') /↓C. The latter implies that Q' /↓C. By contradiction, suppose Q' ↓C, that is (Q' | R) ↓. Then (Q' | T ') | R | T ' ↓ (contradiction!), where we take T ' = a if T ' = T and T ' = 0 otherwise. Hence, P ' ≈ Q' as required.

Suppose P ' ↓C. If Q ⇒a
Q' and T ⇒a
T ' then we show that it must be that

T ' = (b ⊕ 0). This is because if P ' ↓C then P ' | (b ⊕ 0) ↓C which in turn implies that for some R (not containing the names b or c), (P ' | (b ⊕ 0) | R) ↓b. By proposition 2.4, we must have Q'' = (Q' | T ') | R ↓b. Thus T ' cannot be 0 and it cannot be (b ⊕ 0) ⊕ c, for otherwise Q'' ↓c which cannot be matched by (P ' | (b ⊕ 0) | R).
Further, we have P ' | (b ⊕ 0) —→r  P ' | 0 (= P '). So (Q' | (b ⊕ 0)) ⇒r  (Q' | T '') and
P ' ≈ (Q' | T ''). The latter entails that T '' = 0.

On the other hand, we show that Q ⇒r
Q' and T = T ' is impossible. Reasoning

as above, we have (P ' | (b ⊕ 0) | R) ↓b. But then if (Q' | T ) | R ↓b we shall also have (Q' | T ) | R ↓c.	 

The following lemma relates contextual convergence to labelled bisimulation (cf. the similar proposition 2.8).
Lemma 3.4 (1) If P ≈l Q and P ↓C then Q ↓C.
(2) If P /↓C and Q /↓C then P ≈l Q.

Proof. (1) By proposition 2.6, if P ↓
α1	αn	'	'

C then P
—→ ··· ——→ P and P
↓. By

α1	αn	'
'	l	'

definition of labelled bisimulation we should have Q ⇒ ··· ⇒ Q
and P
≈  Q .

Then P
tick
⇒ · entails Q
tick
⇒, and therefore Q ↓C.

(2) By proposition 2.8, P, Q /↓C implies P ≈ Q, and by proposition 3.3 we conclude that P ≈l Q.	 
Proposition 3.5 If P ≈l Q then P ≈ Q.
Proof. We show that labelled bisimulation is preserved by static contexts. In view of remark 3.2(3), we shall work with an asymmetric definition of bisimulation. With respect to this definition, we show that the following relations are labelled bisimulations:
{(νa P, νa Q) | P ≈l Q}∪ ≈l ,	{(P | R, Q | R) | P ≈l Q}∪ ≈l .
The case for restriction is a routine verification so we focus on parallel composition.

μ
Suppose (P | R) —→ ·. We proceed by case analysis.
α	'	α	'	α	'
(P | R) —→ (P | R ) because R —→ R . Then (Q | R) —→ (Q | R ).

tick	'	'
tick	'
tick	'
tick

(P | R) ——→ (P
| R ) because P
——→ P
and R ——→ R . Then Q ⇒ Q1 ——→

Q2 ⇒ Q' and P ' ≈l Q'. Notice that P ≈l Q1 with P, Q1 ↓, and therefore (Q1 |
tick	'	tick	'	'
R) ——→ (Q2 | R ). Hence (Q | R) ⇒ (Q | R ).
Suppose (P | R) ↓C and (P | R) —→a  (P ' | R) because P —→a  P '. Then P ↓C and
α	'	'	l	'	'	'

therefore Q ⇒ Q , α ∈ {a, τ }, and P  ≈ Q . If (P  | R) ↓C then P
entails α = a.
↓C and this

r	'	r	'
r	'	'	l	'

Suppose (P | R) —→ (P
| R) because P —→ P . Then Q ⇒ Q
and P
≈ Q .

Suppose (P | R) —→r
(P ' | R') because P —→a  P ' and R —→a
R'. If P, P ' ↓C then

a	'	'	l	'
'	α	'
'	l	'

Q ⇒ Q and P ≈ Q . If P ↓C and P
/↓C then Q ⇒ Q , α ∈ {a, τ }, and P
≈ Q .

But then (P ' | R), (Q' | R) /↓C, and we apply lemma 3.4. If P /↓C then Q /↓C and therefore (Q | R) /↓C, and we apply again lemma 3.4.	 

As a first application of the characterisation we check that bisimulation is pre- served by the else next operator in the sense of proposition 1.4(2).
Corollary 3.6 Suppose P1 ≈ P2, P1, P2 ↓, and Q1 ≈ Q2. Then P1 d Q1 ≈ P2 d Q2.

Proof. There are two cases to consider. If P1
d Q1
tick
——→
Q1 then P2
d Q2
tick
——→
Q2.

If P1 d Q1 —→a
P ' because P1 —→a  P ' then P2 ⇒α P ', P ' ≈l P ', and α ∈ {τ, a}. We note

1	1	2	1	2
that it must be that α = a. Indeed, if α = τ then since P2 ↓ we must have P ' = P2
and P ' ↓C. The latter forces α = a which is a contradiction.	 

Embedding CCS in TCCS
In this section we collect some easy corollaries of the characterisation. First, we re- mark that two CCS processes are bisimilar when observed in an untimed/asynchronous environment if and only if they are bisimilar in a timed/synchronous environment.
Proposition 4.1 Suppose P, Q are CCS processes. Then P ≈ Q if and only if
P ≈ccs Q.
Proof. By propositions 3.3 and 3.5 we know that ≈=≈l. By remark 3.2(1), the labelled bisimulation on untimed processes coincides with the restriction to CCS processes of the timed labelled bisimulation.	 

Second, we compare the notion of convergence-sensitive bisimulation we have introduced with the usual one we have recalled in the section 1.2. All the notions collapse on reactive processes.
Proposition 4.2 Suppose P, Q are reactive processes. Then P ≈ Q if and only if
P ≈u Q.

Proof. We know that ≈=≈l. Reactive processes are closed under labelled tran- sitions and on reactive processes the conditions that define labelled bisimulation coincide with the ones for the usual bisimulation.	 

The situation on non-reactive processes is summarised as follows where all im- plications are strict.
Proposition 4.3 Suppose P, Q are processes.
If P ≈u Q then P ≈ Q.
If moreover P and Q are CCS processes then P ≈u Q implies both P ≈u	Q
and P ≈ Q.
Proof. (1) The clauses in the definition of ≈u imply directly those in the definition of the labelled bisimulation that characterises ≈ (definition 3.1). To see that the converse fails note that (a | Ω) ≈ Ω while (a | Ω) /≈u Ω.
(2) Use (1) and the fact that the clauses in the definition of ≈u imply directly those

in the definition of ≈u
. To see that the converse fails use the counter-example in

(1) and the fact that 0 ≈u  Ω while 0 /≈u Ω.	 
Divergence sensitive bisimulation
We refine the notion of bisimulation to make it sensitive to divergence and show that the characterisation presented in section 3 can be adapted to this case.
We say that a process P may diverge and write P ⇑ if there is an infinite reduc- tion sequence of τ actions that starts from P . We refine the notion of bisimulation by making it sensitive to divergence.
Definition 5.1 [⇑-bisimulation] A symmetric relation Y on processes is a diver- gence sensitive bisimulation (⇑-bisimulation, for short) if it is a bisimulation ac- cording to definition 2.1 and if P YQ and P ⇑ implies Q ⇑. We denote with ≈⇑ the largest ⇑-bisimulation.
Remark 5.2 Say that a process P is strongly normalising if all reduction sequences of τ -actions that start from P terminate. A process is strongly normalising if and only if it may not diverge. It follows that one can give an equivalent formula- tion of ⇑-bisimulation by replacing the may divergence predicate with the strong normalisation predicate.
We notice the following properties whose proof is direct.
Proposition 5.3 (1) If P ≈⇑ Q then P ≈ Q.
If P ≈⇑ Q and P ↓a then Q ↓a.
If P ≈⇑ Q and P ↓C then Q ↓C.
If P /↓C then P ⇑.
If P /↓C and Q /↓C then P ≈⇑ Q.

Proof. (1) A ⇑-bisimulation is also a bisimulation.
We apply (1) and proposition 2.4.
We apply (1) and proposition 2.8(1).
Immediate, by definition.
If P /↓C and Q /↓C then P ⇑ and Q ⇑.	 

It follows that ⇑-bisimulation coincides with bisimulation on the processes that are not contextual convergent. On the other hand, on those that are contextual convergent, it is a strictly finer notion as, e.g., it distinguishes 0 from A = τ.A + τ.0. The characterisation of ⇑-bisimulation turns out to be straightforward: it is enough to make the labelled bisimulation we have introduced in definition 3.1 sen-
sitive to divergence.
Definition 5.4 [⇑-labelled bisimulation] A symmetric relation Y on processes is a divergence sensitive labelled bisimulation (or ⇑-labelled bisimulation) if it is a labelled bisimulation and if P YQ and P ⇑ implies that Q ⇑. We denote with ≈l
the largest ⇑-labelled bisimulation.
Because of the properties stated in proposition 5.3, one can repeat the proofs in section 3 while adding specific arguments to take the sensitivity to divergence into account.
Proposition 5.5 If P ≈⇑ Q then P ≈l Q.
Proof. We show that ≈⇑ is a ⇑-labelled bisimulation by repeating the proof schema in proposition 3.3. Note that the condition that refers to divergence is the same for
⇑-bisimulation and for ⇑-labelled bisimulation.	 
Lemma 5.6 (1) If P ≈l Q and P ↓C then Q ↓C.
(2) If P /↓C and Q /↓C then P ≈l Q.


Proof. (1) Note that P ≈l
⇑
Q implies P ≈l Q and apply lemma 3.4(1).

(2) By proposition 5.3(5), P /↓C and Q /↓C implies P ≈⇑ Q and by proposition 5.5
the latter implies P ≈l Q.	 
Proposition 5.7 If P ≈l Q then P ≈⇑ Q.


Proof. As in proposition 3.5, we have to verify that ≈l
⇑
is preserved by name

generation and parallel composition. For the former we note that νa P ⇑ if and
only if P ⇑. For the latter, we can repeat the proof in proposition 3.5. Moreover,

we have to consider the case where P ≈l
Q and (P | R) ⇑. The process (P | R)

diverges because: either P and R may engage in a finite number of synchronisations after which one of the two diverges or P and R may engage in an infinite number of synchronisations. Suppose the finite or infinite number of synchronisations between

P and R correspond to the transitions P

a1
⇒ P1
a1
a2
⇒ ··· and R
a2
a1
⇒ R1
l

a2
⇒ ··· If

P, P1, ··· are all contextually convergent then Q ⇒ Q1 ⇒ ··· and Pi ≈⇑ Qi. Hence
(Q | R) ⇑. If P /↓C then Q /↓C implies (Q | R) /↓C which implies (Q | R) ⇑. Finally,
a1	ai−1	αi
suppose Pi is the least i such that Pi /↓C. Then Q ⇒ ··· ⇒ Qi−1 ⇒ Qi with Qi /↓C
r	'
and αi ∈ {ai,τ }. If αi = ai then (Q | R) ⇑ because (Q | R) ⇒ (Qi | R ) and Qi ⇑.
If αi = τ then (Q | R) ⇑ because (Q | R) ⇒ (Qi | Ri−1) and Qi ⇑.	 

Conclusion
We have presented a natural notion of contextual and convergence sensitive bisim- ulation and we have shown that it can be characterised by a variant of the usual notion of labelled bisimulation relying on the concept of contextual convergence. As a direct corollary of this characterisation, we have shown that (untimed) CCS processes are embedded fully abstractly into timed ones. Finally, we have refined the notion of bisimulation to make it divergence-sensitive.
We believe that our main contribution, if any, is of a methodological nature. The notion of bisimulation we have introduced just requires the notions of reduc- tion and static context as opposed to previous approaches that build on the notion of ‘labelled’ transition or on the notion of ‘barb’. It would be interesting to apply the proposed approach to other situations where the notion of equivalence is un- clear. For instance, we expect that our results can be extended to a TCCS with ‘asynchronous’ communication or with ‘signal-based’ communication.

References
R. Amadio. The SL synchronous language, revisited. Journal of Logic and Algebraic Programming, 70:121-150, 2007.
R. Amadio. A synchronous π-calculus. Information and Computation, 205(9):1470–1490, 2007.
G. Berry, L. Cosserat. The Esterel synchronous programming language and its mathematical semantics. INRIA technical report 842, Sophia-Antipolis, 1988.
G. Berry and G. Gonthier. The Esterel synchronous programming language. Science of computer programming, 19(2):87–152, 1992.
F. Boussinot and R. De Simone. The SL synchronous language. IEEE Trans. on Software Engineering, 22(4):256–266, 1996.
M. Hennessy, T. Regan. A process algebra of timed systems. Information and Computation, 117(2):221- 239, 1995.
K. Honda and N. Yoshida. On reduction-based process semantics. Theoretical Computer Science, 151(2):437-486, 1995.
M. Lohrey, P. D’Argenio, and H. Hermanns: Axiomatising divergence. In Proc. ICALP, SLNCS 2380:585-596, 2002.
R. Milner. Calculi for synchrony and asynchrony. Theoretical Computer Science, 25(3):267–310, 1983.
R. Milner. Communication and Concurrency. Prentice-Hall, 1989.
R. Milner and D. Sangiorgi. Barbed bisimulation. In Proc. ICALP, SLNCS 623:685–695, 1992.
X. Nicolin, J. Sifakis. The algebra of timed processes (ATP): theory and application. Information and Computation, 114(1):131-178, 1994.


J. Rathke, V. Sassone and P. Sobocinski. Semantic barbs and biorthogonality. In Proc. FoSSaCS 2007, SLNCS 4423:302-316, 2007.
W. Yi. A calculus of real time systems. PhD thesis. Chalmers University, 1991.
D. Walker. Bisimulation and divergence. Information and Computation, 85:202-241, 1990.
