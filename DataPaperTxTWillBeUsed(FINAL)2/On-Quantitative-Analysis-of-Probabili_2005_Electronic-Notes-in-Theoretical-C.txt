Electronic Notes in Theoretical Computer Science 112 (2005) 131–148 
www.elsevier.com/locate/entcs


On Quantitative Analysis of Probabilistic Protocols
Alessandro Aldini1
Istituto STI, Universita` Carlo Bo, Urbino, Italy
Alessandra Di Pierro2
Dipartimento di Informatica, Universita` di Pisa, Italy

Abstract
We advocate the use of approximate noninterference for the security analysis of probabilistic proto- cols. Our approach relies on a formalisation of the protocol in the setting of a probabilistic process algebra and a notion of process similarity based on weak probabilistic bisimulation. We illustrate this approach by presenting the analysis of a probabilistic nonrepudiation protocol which allows us to quantitatively estimate its fairness degree.
Keywords: Approximate Noninterference, Case Study, Process Equivalence, Probabilistic Process Algebra


Introduction
Security services such as authentication, confidentiality, non-repudiation, etc. are nowadays crucial to many applications given the growing importance of open networks. Thus the study of security protocols that guarantee such services is equally crucial to systems developers and has recently gained a primary importance in the research activities in computer science. The recent literature has shown that the consideration of probabilistic elements in such a study is essential for a more realistic formalisation and analysis of the security

1 Email: aldini@sti.uniurb.it
2 Email: dipierro@di.unipi.it



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.01.019


problem. Most notably, various approaches [16,17,9,4,13] have been proposed which rely on probabilistic variations of noninterference [12].
In this paper we investigate possible applications of the noninterference model of security to the analysis of probabilistic protocols. In particular, we show how an approximate formulation of a probabilistic noninterference property [3,4] can be used to conduct a quantitative analysis of protocols which aim at ensuring that property. To this aim we follow an approach introduced in [1] which is based on the approximate noninterference model of [8]. The basic idea behind such an approach is to express the security requirement of the application at hand as an equivalence problem between two appropriately defined systems (see, e.g., [10,4]). Then the analysis consists essentially of an equivalence check and an evaluation of the similarity degree between the two systems in case of non-equivalence.
Formally, the approach we propose is defined in the framework of a prob- abilistic calculus [4] and a weak probabilistic bisimulation equivalence seman- tics [5]. In this setting, the noninterference based security property we con- sider is a probabilistic extension of the Strong Nondeterministic Noninter- ference property [10], which we simply call Probabilistic Noninterference [3] (PNI ). Intuitively, PNI compares, from an external observer standpoint, the view of the system in the absence of adversary interferences and the view of the system when the adversary interacts with the system. If the equivalence check is satisfied, then an external observer that sees the result of the pro- tocol run cannot infer whether or not the behaviour of the system has been altered by the adversary. Otherwise, we estimate the effectiveness of the ad- versary strategy (i.e., we provide a quantitative estimation of its capability of revealing its presence to the external observer) by means of a technique intro- duced in [1] and corresponding to measuring the maximal “distance” between two non-equivalent processes. This distance is defined in terms of transition probabilities and gives an estimate of the behavioural difference of the two processes. The meaning we attribute to the resulting measure is related to the number of tests an external observer needs to perform in order to infer whether or not the behaviour of the system has been altered by the adversary. A justification for this statistical interpretation was given in [3] following the model introduced in [8].
As a case study, we apply this technique to the analysis of a probabilistic nonrepudiation protocol [14], which has been previously modeled and analysed in [2] through the same process algebraic setting considered in this paper. The novel analysis methodology we propose allows us to calculate a number which gives an estimate of the fairness of the protocol, i.e. of its security degree. We also suggest possible variations of the basic approach which may lead to


finer analyses from which a more precise upper bound can be deduced for the security degree of the protocol. With respect to [2], we formally provide a measure of the effectiveness of the most powerful adversary that is able to violate the security property of interest.
In the following we formally introduce the process algebraic framework and the approximate noninterference approach to security (Section 2), by de- scribing the syntax and the semantics of the probabilistic calculus, the weak probabilistic bisimulation equivalence, the PNI property rephrased in such a setting, and an approximate version of PNI . Then, we illustrate the case study (Section 3), by describing the probabilistic nonrepudiation protocol [14] together with the process algebraic model of an implementation of such a pro- tocol, on which we quantitatively estimate the security property of interest. We finally outline directions for further work in Section 4.

Noninterference and Probabilistic Adversary
We base our approach on a notion of approximate noninterference [8] in the setting of a calculus used in [4] to define a probabilistic extension of nonde- terministic noninterference [10]. In this section, we briefly describe such a calculus, and present definition of probabilistic noninterference parameterised by a class A of probabilistic adversaries [3,1] as well as a quantitative approach to the evaluation of the maximal interference caused by A [1].
Probabilistic Process Algebra
The probabilistic calculus we consider derives from a simple nondeterministic process algebra where actions are syntactically divided into input actions and output actions. Formally, for each visible action type a, we distinguish the output action a and the input action a∗. Process terms synchronously commu- nicate with the environment through their inputs and outputs, and perform internal computations through unobservable actions, termed τ actions.
Probabilities are introduced by adding probabilistic information to the algebraic operators. The probabilistic model we adopt [7] is a mixture of the generative and reactive approaches of [11]. In particular, we assume the internal and output actions behaving as generative actions, i.e. the system autonomously decides, on the basis of a probability distribution, which inter- nal/output action will be executed and how to behave after such an event. On the other hand, we assume the input actions behaving as reactive actions,
i.e. the system reacts internally to the action type, say a, chosen by the envi- ronment. Then, the choice of the reactive action of type a to be executed is performed on the basis of a probability distribution associated with the reac-


tive actions of type a the system can perform. In practice, we see the input actions as underspecified, since their execution is guided by the environment behaviour. The mixed generative-reactive model allows for a representation of both probabilistic behaviours guided by probability distributions decided by the system and nondeterministic behaviours due to the possible interactions of the system with the environment (see, e.g., [6] for more details).
The syntax of the probabilistic process calculus is as follows:
P ::= 0 | π.P | P +p P | P  p P | P \L | P/p | A.
S	a
We use 0 to represent the terminated process (we usually omit it). Action π is drawn from set Act and can be an internal action τ , an output action a, or an input action a∗, where a belongs to the set of visible action types AType. π.P performs the action π with probability 1 and then behaves like P .
The alternative choice operator P +p Q, with p ∈ (0, 1), performs a mixed probabilistic/nondeterministic choice among the actions of P and Q. More precisely, P +p Q executes a generative (reactive of type a) action of P with probability p and a generative (reactive of type a) action of Q with proba- bility 1 − p. If one process P or Q cannot execute generative (reactive of type a) actions, P +p Q chooses a generative (reactive of type a) action of the other process with probability 1. The choice among generative and reactive actions and among reactive actions of different types is purely nondeterminis- tic. Hence, the parameter that probabilistically guides the choices comes into play if and only if a probabilistic choice is really to be performed.
The parallel composition operator P  p Q, with p ∈ (0, 1) and S ⊆ AType, asynchronously performs all the actions of P and Q that do not belong to the synchronisation set S. Instead, all the actions belonging to S are constrained to synchronise. In particular, a synchronisation between two actions can occur if either they are both input actions of the same type a (and the result is an input action of type a), or one of them is an output action of type a and the other one is an input action of type a (and the result is an output action of type a). The probabilistic choice mechanism among the actions of P and Q is the same as that described for the choice operator. We just point out that the execution of some actions of P may be prevented in P  p Q because of the synchronisation rule. Such a restriction imposes a careful calculation of the probability distribution of the actions of P  p Q that follow the generative model of probabilities [11]. In order to obtain a probability distribution, we normalise the probabilities of executing the generative actions of P executable by P  p Q (similarly for Q). Such an approach is commonly applied when restricting actions in the generative model of probabilities [11].
The restriction operator P \L prevents the execution of the actions of type in L ⊆ AType. We omit further discussions about it as P \L can be expressed


in terms of the parallel operator. Indeed, it is easy to see that P \L corresponds to process P  p 0, for any choice of parameter p.
The hiding operator P/p turns actions of type a into actions τ . In particu- lar, we recall that the reactive actions a∗ of P are governed by their own prob- ability distribution, while the actions τ of P are governed by the probability distribution associated with the generative actions enabled by P . Therefore, when turning actions a∗ into actions τ we must pay attention to the computa- tion of the probability distribution of the generative actions enabled by P/p. To this aim, we use parameter p to express the probability that generative ac- tions τ obtained by hiding reactive actions a∗ of P are executed with respect to the generative actions previously enabled by P . In practice, when turn- ing reactive actions a∗ into actions τ , parameter p probabilistically resolves the nondeterminism among the reactive actions of type a and the generative actions. As an example, consider process a∗ +q b (note that the choice is non- deterministic, i.e. q is not meaningful), and hide the action a∗. The semantics of process (a∗ +q b)/p is the probabilistic choice τ +p b, guided by parameter p, between τ , obtained by hiding a∗, and b. Parameter p of the hiding operator is not used when hiding generative actions, because in such a case no nondeter- minism must be resolved. Intuitively, we turn reactive actions into generative internal actions in order to obtain closed (fully generative) systems from open systems (i.e. systems enabling reactive choices). To this purpose, the nonde- terministic choices due to the potential interactions with the environment are probabilistically resolved by employing parameter p of the hiding operator.
Constants A are used to specify recursive systems. In general, when defin- ing a process term, we assume a set of constants defining equations of the
def
form A = P (with P a guarded term [15]) to be given.
In the rest of the paper, we denote by G the set of finite state, guarded, and closed terms [15], called processes, generated by the syntax above. Moreover, we assume p = 1 in the case parameter p of a probabilistic operator is omitted. Now, we briefly introduce the semantics of the calculus [4]. To this pur- pose, we introduce the following notation: RAct and GAct denote the sets of input actions and of output and internal actions, respectively; we use the ab-

breviations
π
P −−−→
to stand for ∃p ∈]0, 1],P ' :
π, p
P −−−→ P
', denoting that P

can execute action π with probability p and then behave as P ', and
a
G
P −−−→ ,

with G ⊆ GAct , to stand for ∃a ∈ G : P −−−→ , that means P can execute a
generative action a ∈ G.
The operational semantics of the probabilistic process algebra is given by the labeled transition system (G, Act ,T ), whose states are process terms and the transition relation T is the least multiset satisfying the operational rules


reported in Table 1 and in Table 2. As far as the rules for P +p Q and P  p Q are concerned, in addition to the reported rules, which refer to the local moves of the left-hand process P , we also consider the symmetric rules taking into account the local moves of the right-hand process Q. Such symmetric rules are obtained by exchanging the roles of terms P and Q in the premises and by replacing p with 1 − p in the label of the derived transitions.
The semantics rules reflect the informal presentation of the syntax of the operators. Here, we describe in detail the restriction mechanism adopted by the parallel operator, which, as we have seen, uses a normalisation factor in order to obtain a probability distribution to be associated with the generative actions enabled by P  p Q. To this purpose, we employ the following notation:
a∗
Set GS,Q = {a ∈ AType ∪ {τ }| a /∈ S ∨ (a ∈ S ∧ Q −−−→ )} contains the
action types not belonging to set S and the action types belonging to S for which an input action of Q can be performed. In practice, GS,Q determines which actions can be executed by a process in the context  p Q. Function νP (GS,Q): P(AType ∪ {τ }) −→]0, 1] computes the sum of the probabilities of the generative transitions of P with type in GS,Q. Hence, the value νP (GS,Q) is used to normalise the probabilities of the generative transitions of P that are enabled by P  p Q.
To conclude the presentation of the semantics of the calculus, we introduce a notion of process equivalence based on which we compare the observable be- haviours of different systems. To this aim we need an equivalence relation that takes into account the observational power of an external observer, i.e. is able to abstract away from unobservable internal details. In particular, we consider a probabilistic variant of the weak bisimulation semantics (borrowed from [5], where fully probabilistic processes are considered). Such a relation, termed ≈PB, extends the weak bisimulation (≈B) of [15] by replacing the clas- sical weak transitions of ≈B by the probability of reaching classes of equivalent states. More precisely, we use a function Prob, such that Prob(P, π, C) de- notes the aggregate probability of going from P to a term in the class (of equivalent terms) C by executing an action π, and Prob(P, τ ∗a, C) expresses the aggregate probability of going from P to a term in the equivalence class C via sequences of the form τ ∗a (if a /= τ ) or τ ∗ (if a = τ ).
Lemma 2.1 The value of Prob(P, τ ∗a, C) is the minimal non-negative solu- tion to the equation system
,
,⎨ ΣQ∈G Prob(P, τ, Q) · Prob(Q, τ ∗, C)	if a = τ ∧ P /∈ C
,,, ΣQ∈G Prob(P, τ, Q) · Prob(Q, τ ∗a, C)+ Prob(P, a, C) if a /= τ


Table 1 Operational semantics (part I)

As shown in [4], the equation system above has a least solution. We now are ready to define the weak probabilistic bisimulation equivalence.
Definition 2.2 An equivalence relation R ⊆ G × G is a weak probabilistic bisimulation if and only if, whenever (P, Q) ∈ R, then for all C ∈ G/R:
Prob(P, τ ∗a, C)= Prob(Q, τ ∗a, C) ∀a ∈ GAct
Prob(P, a∗, C)= Prob(Q, a∗, C) ∀a∗ ∈ RAct .
Two terms P, Q ∈ G are weakly probabilistically bisimulation equivalent, de- noted P ≈PB Q, if there exists a weak probabilistic bisimulation R including the pair (P, Q).

Approximate Probabilistic Noninterference
A high-level user (High, for short) interferes with a low-level user (Low, for short) if what High can do is reflected on what Low can observe [12]. High can perform high-level activities only and observe all the interactions between


Table 2 Operational semantics (part II)


the system and the environment. Low can perform low-level activities only and is not allowed to directly observe the occurrence of high-level events. In our setting, what Low can see is not only the logical low-level behaviour of the system, but also the probability distribution of each low-level activity. Despite of the absence of a direct communication channel from High to Low, High may succeed in altering the low-level view of the system, thus passing information to Low, by interacting with the high-level interface of the system. In the following we describe a formalisation of noninterference, where High is considered to be an adversary that tries to maximise the information leakage from High to Low.
Roughly, the noninterference approach can be described as follows. First, we derive two models from the considered system, corresponding to two dif- ferent low-level views of the system, and then we verify the ≈PB based equiva- lence between such derived models. The choice of the models to be compared depends on the definition of the security property. Here, we consider a proba- bilistic extension [4] of the Strong Nondeterministic Noninterference property of [10], which we simply call Probabilistic Noninterference [3] (PNI ). Such a property compares the low-level view of the system without high-level in- terferences and the low-level view of the system in the presence of high-level interactions. If such models turn out to be equivalent, then a low-level ob-


server cannot deduce the behaviour of the high-level user by interacting with the low-level interface of the system.
Formally, we divide actions into high-level actions and low-level actions, denoted High and Low , respectively, depending on the nature of the activities they represent. High and Low are disjoint and form a covering of AType.

Given a process P , we denote with h¯P = hP ,... , hP
the sequence (in alpha-

1	n
betic order) of types of the high-level actions that syntactically occur in the
action prefix operators within P . Then, the application of the security check to P is as follows. The view of P without high-level operations is modeled by P \High. The low-level view of P in the presence of high-level interactions
is expressed by the family of processes P/p1 ... /pn , p1,... , pn ∈ (0, 1), where
P	P
1	n
p¯ = p1,... , pn is the sequence of parameters modelling the probability distri-
bution (chosen by High) of the hidden high-level input actions enabled by the
system. We use the abbreviation P/p¯ to stand for P/p1 ... /pn . Finally, the
¯P	P	P
1	n
PNI property can be formalised as follows.

Definition 2.3 P ∈ PNI ⇔ P \High ≈PB P/p1 ... /pn
∀p1,... , pn ∈ (0, 1).

P	P
1	n
Parameters p1,... , pn express the probabilistic adversary that interacts with the system and tries to maximise the information leakage from High to Low. The universal quantification over all possible sequences p1,... , pn ∈ (0, 1) means that the equivalence check must hold for an infinite number of adver- saries. In particular, as also shown in [3], the class A of adversaries expressed by PNI contains active and memoryless high-level users. On the one hand, they are active as the probabilistic low-level behaviour of the system can be al- tered when the reactive high-level actions are hidden. On the other hand, they are memoryless as they cannot alter their strategy depending on the previous history. Indeed, the probability distribution of the hidden high-level inputs, modeled by parameters p1,... , pn, is chosen a priori and does not change dur- ing the system execution. If the condition of Definition 2.3 holds, then the system does not leak any information from an adversary in A to Low.
We now show how to calculate a quantitative estimate of the maximal amount of information leakage caused by A in the case the equivalence check is not satisfied. In the following we restrict ourselves to systems that are fully specified from the viewpoint of Low. Hence, we assume that the only reactive actions enabled by the system are high-level actions [1].
The probability of observing an information flow from High to Low can be estimated by relaxing the behavioural equivalence relation expressed by
≈PB. As we have seen, an information leakage occurs in P whenever, for a given sequence p¯ chosen by High, for each equivalence relation R ⊆ G × G

including the pair (P \High,P/p¯
), there exist C ∈ G/R, a ∈ GAct , and


a pair (P ',P '') ∈ R, such that Prob(P ',τ ∗a, C) /= Prob(P '',τ ∗a, C). The difference between these two probabilities can be used to give an estimate of the amount of information leakage. More precisely, for every equivalence

relation R including the pair (P \High,P/p¯
), we consider the pair of states (of

a class in G/R) where the weak transition probabilities are maximally different and calculate the difference. We can then define a measure of the security of P as the minimal of these differences over all equivalence relations.
Formally, we define the quantity δR(P ) (or simply δR when it is clear from
p¯	p¯
the context), which expresses the behavioural distance between P \High and

p¯ h¯P
with respect to a relation R ⊆ G × G including the pair (P \High,P/p¯ )

and a sequence of parameters p¯ = p1,... , pn governing the interactions be-
tween the high-level input actions of P and High. By using this quantity we then define a measure εp¯ for the security degree of a system P against the adversary modeled by p¯.
Definition 2.4 Let P be a process, R ⊆ G × G an equivalence relation in-

cluding the pair (P \High,P/p¯
), and p¯ = p1,... , pn a sequence of parameters

such that pi ∈ (0, 1), 1 ≤ i ≤ n. We define

δR = sup

and then

(P ',P '') ∈ R,
a ∈ GAct , C ∈ G/R
| Prob(P ',τ ∗a, C) − Prob(P '',τ ∗a, C) |

εp¯ = inf R δR.
Chosen a relation R, δR expresses the maximal difference between the low- level view of the system without high-level actions and the one modelling the interactions of the system with the high-level user probabilistically modeled by sequence p¯. Then, the relation that is the best approximation of a weak probabilistic bisimulation is obtained by computing the minimum (εp¯) over all the possible δR. That means, εp¯ expresses how similar are the two low-level views of the system to be compared [1]. Note that this quantity depends on parameters p1,... , pn forming the sequence p¯, which models an adversary of the family A defined by PNI . The measure εp¯ can also be interpreted as the effectiveness of such an adversary [8]. In fact, it determines how easy it is for a low-level user to obtain some information, in terms of the number of tests (system executions) Low needs to perform in order to distinguish with success the behaviours with and without the adversary interferences. The maximal εp¯ obtained by varying p¯, i.e. by changing the adversary strategy, determines the effectiveness of the most powerful adversary in A. In the following, we will show that the problem of finding such an adversary corresponds to solving a (non-linear) optimisation problem with as many variables as the number of

parameters contained in the sequence p¯ [1].

A Case Study: Probabilistic Nonrepudiation
As an example of application of the methodology surveyed above, in this section we present a case study: a probabilistic nonrepudiation protocol [14]. Here, we show how the maximal information leakage, expressed in terms of the maximum probability of violating a fairness property during system execution, can be estimated.

An Overview of the Protocol
Repudiation consists of the denial by one of the entities involved in a message exchange protocol of having participated in all or part of the protocol itself: nonrepudiation of origin is intended to prevent the originator of a message from denying having sent the message, and nonrepudiation of receipt is in- tended to prevent the recipient of a message from denying having received the message. Especially in e-commerce, nonrepudiation is needed to protect a transaction against any attempt to repudiate either the payment for the service or the delivery of the service. Here, we consider a protocol that of- fers a nonrepudiation service, guaranteed with a certain probability, without resorting to a trusted third party [14]. Such a protocol offers a fair exchange of a message, sent by the originator O, which offers a service, for an acknowl- edgment, sent by the recipient R, which is expected to confirm the received service. The probabilistic protocol is ε-fair, i.e. at each step of the protocol run, either both parties receive their expected information, or the probability that a cheating party gains any valuable information, while the other party gains nothing, is less than ε.
In the following we suppose that the protocol is preceded by a secure authentication phase, during which the involved parties exchange their public keys of a public key cryptosystem. Moreover, we denote by SignE (M ) the message M encrypted with the private key of the entity E, by k a secret key chosen by O to encrypt a message M with a symmetric encryption algorithm, and by t a timestamp which each message is enriched with. Finally, R → O : Msg expresses a message Msg sent by R and received by O.
We now describe an implementation of the protocol illustrated in [14]. The recipient R starts the protocol by sending a signed, timestamped request for a service to the originator O, which in turn sends the first signed, timestamped message containing M encrypted with k. Upon receiving the first message from O, R sends a related signed, timestamped acknowledgment message con-

taining ack1 = (1, R, O, t):
1. R → O : SignR(request, R, O, t)
2. O → R : SignO({M }k, O, R, t)
3. R → O : SignR(ack1).
Then, at each protocol step i, O probabilistically decides whether to continue the protocol (with probability 1 − p), by sending a key k' different from k, or to terminate the protocol (with probability p), by sending the key k needed to obtain the plaintext M . On the other hand, for each received message, R transmits the related ack message acki = (i, R, O, t):
2i.	O → R : [p]SignO(k, O, R, t) + [1 − p]SignO(k', O, R, t) 2i + 1. R → O : SignR(acki).
Since R does not know the result of the probabilistic choice, it cannot deter- mine when the protocol will end and, as a consequence, when it will receive the final message. Upon the reception of the ack related to the last message containing k, O correctly terminates the protocol. Note that an end of proto- col message sent by O is not mandatory. Indeed, after not receiving further messages, R is aware of the protocol state and is able to compute M .
As far as the security guarantees are concerned, each message conveys a timestamp, which is used to determine the freshness of the message and to protect the parties against replication attacks. The nonrepudiation of origin is guaranteed by the messages Sign O ({M }k, O, R, t) and SignO(k, O, R, t), and the nonrepudiation of receipt is given by the last message Sign R(ackn). If the protocol terminates after the delivery of Sign R(ackn), both parties obtain their expected information and the protocol is fair. If the protocol terminates before the transmission of SignO (k, O, R, t), then neither O nor R obtain any valuable information, so that the fairness is preserved. However, at each step R could try to verify whether M can be obtained by employing the last key received from O and, once the correct key k is received, violate the fairness of the protocol by blocking the transmission of the last ack. Hence, key to success of the protocol is the immediacy in sending back the ack. Under such a condition, if the transmission of an ack is delayed by R, then O can detect this unfair strategy and prematurely stop the protocol. To this aim, the choice of the encryption algorithm must be in such a way that the decryption of the ciphertext takes more time than the transmission of an ack. Hence, O decides a deadline for the reception of each ack, after which, if the ack is not received, the protocol is stopped. Finally, we observe that such a protocol is exposed to the attack of a malicious recipient that tries to randomly guess the number of protocol steps and block the final ack. In fact, as we will see, this is the kind

of attack that we formally analyse in the next sections.
Modelling the Protocol
The protocol described in Section 3.1 guarantees nonrepudiation of origin with probability 1 and nonrepudiation of recipient with a probability less than 1. Hence, our goal is to estimate the probability of violating the nonrepudiation of recipient. In order to determine the effectiveness of the most powerful adversary strategy against the originator, we model and analyse the behaviour of the originator and we consider the recipient as a potential adversary.
In our model, we abstract from the cryptosystem used within the protocol and we simply describe the packet exchange between the two involved parties. We also abstract from the channel and the transmission delays, by assuming that a message which is delayed (not sent) by a participant is not delivered to the other participant. The specification of the originator is as follows:
def
O = receive request ∗.snd msg.receive ack ∗.O

def
= snd msg.O +
O '' def
snd msg.O
'''

= receive ack ∗.0 + receive stop∗.unfair .0

def
= receive ack ∗.O
+ receive stop∗.0

At the first round of the protocol (term O ), the originator is ready to accept an incoming request, send the first message containing {M }k, and then receive the related ack message. Afterward, at the beginning of each new step (term O '), the originator probabilistically decides whether to send with probability p the last message containing k, thus reaching term O '', or to send with probability 1 − p a garbage message, thus reaching term O '''. In term O ''', the originator waits for the ack before starting another step. The expiration of the timeout is abstracted through the reception of a message of type receive stop, that means the protocol is stopped. Note that in this case the protocol execution is fair, because the final message containing k has not been sent yet. In term O '', the originator waits for the last ack. Upon receiving such an ack, the protocol correctly terminates in a fair way. Otherwise, the protocol terminates in an unfair way from the viewpoint of the originator. This is signaled by executing the action of type unfair .
Measuring the Security of the Protocol
As far as the security analysis is concerned, we make the following assump- tions. Since the recipient is a potential adversary, we consider all the commu- nications between the involved parties as high-level actions. Hence, the only


low-level action is unfair , which reveals to a low-level observer the violation of the fairness condition.
In Figure 1 we show the labelled transition system associated with the model of the originator and the two low-level models that, according to the PNI definition, must be compared through equivalence checking. In particu- lar, the former low-level model is obtained by hiding all the high-level actions,

i.e. O/receive ack /receive request /q
/snd msg . Note that the parameter of the


hiding operator is not meaningful where we omitted it. Intuitively, by vary-
ing parameter q in the range (0, 1), we model all the possible recipients that execute the protocol and decide the probability distribution of each message sent to the originator. The latter low-level model is obtained by restricting the high-level actions, i.e. O\High. Intuitively, such a model expresses the absence of the recipient, that means nothing (potentially insecure) happens. We point out that the class A of adversaries considered by PNI is adequate to reveal the security degree of the protocol. In particular, a history-dependent strategy followed by a malicious recipient would not be useful to gain an advantage as each protocol step does not depend on the previous ones.
If we limit ourselves to an exact verification of the security property, we obtain that PNI does not hold as the condition

O\High ≈PB O/receive ack /receive request /q
/snd msg ∀q ∈ (0, 1)


is not satisfied. The reason is that in the presence of a (potentially malicious) recipient the action unfair can be observed with a certain probability.
In order to quantitatively estimate the effectiveness of the most powerful adversary we resort to an approximate analysis. To this aim, we take the low- level views of the protocol considered by PNI (see Figure 1) and we calculate the difference between them for each possible relation R and for each value of q chosen by the recipient.
We start by considering relation R1 = {{1, 1', 2, 3, 5}, {4}}, for which we obtain the following results:
| Prob(1,τ ∗, [4]) − Prob(1',τ ∗, [4]) | = p · q · Σ∞ ((1 − p) · (1 − q))i
= 	p·q	 =   p·q	 ,

1−(1−p)·(1−q)
| Prob(2,τ ∗, [4]) − Prob(1',τ ∗, [4]) | = (1−q)·p·q ,
| Prob(3,τ ∗, [4]) − Prob(1',τ ∗, [4]) | = q,
p+q−p·q

| Prob(2,τ ∗, [4]) − Prob(1,τ ∗, [4]) | =	p·q2  ,
| Prob(3,τ ∗, [4]) − Prob(1,τ ∗, [4]) | = q2 −p·q2 ,
| Prob(3,τ ∗, [4]) − Prob(2,τ ∗, [4]) | =	q2	.



Fig. 1. Nonrepudiation protocol specification and models to be compared through equivalence checking.
The same results follow if we consider the sequence τ ∗unfair leading to class [5]. In order to compute δR1 , we first point out that 	p	 cannot be greater
q	p+q−p·q
than 1 (note that such a quantity corresponds to the probability of reaching
state 3 from state 1 through a sequence τ ∗). Similarly, we have that 	q	 ≤
1. Therefore, it can be easily verified that δR1 = q. Note that in the limiting

scenario q = 0 we obtain δR1
= 0, which, obviously, represents the worst

case from the viewpoint of the adversary. Intuitively, in such a case we have that state 4 is not reachable and the protocol cannot terminate in an unfair way for the originator. Instead, as q tends to 1 we have that δR1 tends to 1, because of the difference between states 1' (which cannot reach state 4) and 3 (which reaches state 4 with probability q). On the basis of such considerations, we consider relation R2 = {{1, 1', 2, 5}, {3}, {4}}, for which we obtain δR2 =
	p	 = | Prob(1,τ ∗, [3]) − Prob(1',τ ∗, [3]) |.
We summarise the analysis of further relations as follows. For each relation R including the pair (1', 4) it follows δR = 1. Indeed, from state 1' it is not pos- sible to reach class [5], while state 4 reaches state 5 with probability 1 through the action unfair . We can argue similarly if (2, 3) ∈ R, since from state 1 we reach class [2] with probability 1, while from state 1' we cannot reach class [2]. In the case (2, 4) ∈ R, we have that Prob(4,τ ∗, [5]) = 0, while Prob(2,τ ∗, [5]) >
q, hence δR > q. In the case C = {3, 4} is a class in G/R, then δR ≥ 	p	 ,
q	q	p+q−p·q


since Prob(1,τ ∗, C)= 	p	 and Prob(1',τ ∗, C) = 0. We can argue similarly for R = {{1, 1', 5}, {2}, {3}, {4}}. For R = {{1, 1', 3, 5}, {2}, {4}} we have
δR ≥ q, since Prob(3,τ ∗, [4]) = q and Prob(1',τ ∗, [4]) = 0. Finally, for each R
such that {1, 1'} is a class in G/R we can argue as in the previous cases.
Hence, we can conclude that εq = min{δR1 , δR2 } = min{q, 	p	 }. In

particular, we have that εq
q q2
1−q+q2
q
, otherwise εq
p+q−p·q
p+q−p·q if

q2
1−q+q2
. The value of εq
expresses how similar can be the process that

does nothing (which, by definition, is secure) and the process that executes the
protocol with a recipient probabilistically modeled by parameter q. Obviously, the smaller εq is, the higher the security degree of the protocol. By varying parameter q, a malicious recipient can try to maximise the difference between the two low-level views of the system. Formally, the maximum value of εq obtained by varying parameter q can be calculated by solving a non-linear optimisation problem. As shown above, the value of εq strictly depends on the value of p. Since p is a parameter under the control of the originator, it can be verified that the maximal difference between the two low-level views of the system can be kept as small as desired by decreasing p. Obviously, the smaller p is chosen, the longer the duration of the protocol is. Therefore, a real implementation of the protocol becomes impractical if the participants require a very small tolerance to violations of the security property.
We now discuss an alternative estimation that is less coarse than that provided so far. In our approach to probabilistic protocol analysis, high-level actions model the protocol communication events, while low-level actions are extra signals that are observed by Low in order to infer the behaviour of the protocol run. Hence, Low distinguishes between two different protocol runs on the basis of such observations (i.e. the extra signals it can consume) rather than directly interacting with the protocol entities. That means the distance between pairs of states depends on the difference between the probabilities of the weak transitions of the form τ ∗l, where l is a visible action observed by Low, i.e. one of the extra signals emitted during the protocol run. Based on these considerations, we now employ a variant of Definition 2.4 that replaces the condition a ∈ GAct by the condition a ∈ GAct − {τ }. For R1, we have δR1 = q = | Prob(3,τ ∗unfair, [5]) − Prob(1',τ ∗unfair, [5]) |. For R2, it follows

R2	 p·q	
q	p+q−p·q
= | Prob(1,τ ∗unfair, [5]) − Prob(1',τ ∗unfair, [5]) |.  Therefore,

δR2 < δR1 . For each other relation R, δR is greater than (equal to) δR2 .
q	q	q	q
Therefore, εq =  p·q  , i.e. εq tends to the limiting value p as q tends to the limiting value 1. Again, the value of p determines, from the viewpoint of an external low-level observer, the difference between the system modelling the protocol and a secure system. In particular, p represents the maximal


probability of observing an unfair execution, obtained when the adversary sets q = 1, i.e. the protocol is stopped after the execution of the first step.



Conclusion

We have applied a formal approach to estimating the security of a system to a case study, namely a probabilistic nonrepudiation protocol. This approach allows us to measure the amount of information leakage caused by the prob- abilistic adversaries of a class A defined by a probabilistic noninterference property. The quantitative analysis is based on a notion of process similarity corresponding to an approximate version of the weak probabilistic bisimula- tion semantics [5]. Such an approximation provides an upper bound ε for the probability of observing a security violation caused by the most powerful adversary in A. For a comparison with related work, the reader is referred to [1].
As we have discussed in Section 3.3, the cost for estimating ε can be re- duced by considering a restricted set of interesting relations and by discarding those that cannot contribute to find ε. We intend to investigate the effective- ness of such a strategy since the number of potential relations to be checked factorially increases as the number of states increases (note that we have to take all the possible disjoint subsets of states that form a covering of the state space).
We have discussed an alternative definition of the quantity ε resulting from an analysis which takes into account the actual observational power of a low-level user in our specific case study. This yields a finer estimation of the protocol security. We are investigating other alternative definitions aiming at more precise estimations of the information leakage. In particular, when computing the distance between a pair of reachable states it could be useful for the analysis to take into account also the probability of reaching such states. For instance, the similarity between the initial states of two processes to be compared should not have the same weight as the similarity between two states that are reachable with a negligible probability. Thus, we believe that including such weights in the calculation of ε will increase the precision of the resulting estimation.
Finally, as a future work, we intend to apply the approach presented in this paper to other properties in order to extend the class of probabilistic adversaries that are considered. Indeed, more powerful adversaries are needed to reveal a larger spectrum of security problems of probabilistic protocols.

References
Aldini, A., and A. Di Pierro, A Quantitative Approach to Noninterference for Probabilistic Systems, in ENTCS – Selected Papers from MIUR project MEFISTO “Formal Methods for Security” – to appear.
http://mefisto.web.cs.unibo.it

Aldini, A., and R. Gorrieri, Security Analysis of a Probabilistic Non-repudiation Protocol, in Proc. of 2nd Workshop on Process Algebra and Performance Modelling, Probabilistic Methods in Veriﬁcation (PAPM-ProbMiV’02), Springer LNCS 2399:17–36, 2002.
Aldini, A., M. Bravetti, A. Di Pierro, R. Gorrieri, C. Hankin, and H. Wiklicky, Two Formal Approaches for Approximating Noninterference Properties, Foundations of Security Analysis and Design II – Tutorial Lectures, Springer LNCS 2946:1–43, 2004.
Aldini, A., M. Bravetti, and R. Gorrieri, A Process-algebraic Approach for the Analysis of Probabilistic Noninterference, Journal of Computer Security 12(2), 2004.
Baier, C., and H. Hermanns, Weak Bisimulation for Fully Probabilistic Processes, in Proc. of
9th Int. Conf. on Computer Aided Veriﬁcation, Springer LNCS 1254:119–130, 1997.
Bravetti, M., and A. Aldini, Discrete Time Generative-reactive Probabilistic Processes with Different Advancing Speeds, Theoretical Computer Science 290(1):355–406, 2003.
Bravetti, M., and M. Bernardo. Compositional Asymmetric Cooperations for Process Algebras with Probabilities, Priorities, and Time, in Proc. of 1st Workshop on Models for Time-Critical Systems, ENTCS 39(3), 2000.
Di Pierro, A., C. Hankin, and H. Wiklicky, Approximate Non-Interference, Journal of Computer Security, 12(1):37–81, 2004.
Di Pierro, A., C. Hankin, and H. Wiklicky, Probabilistic Conﬁnement in a Declarative Framework, in Declarative Programming – Selected Papers from AGP 2000 – ENTCS 48, 1–23, 2001.
Focardi, R., and R. Gorrieri, A Classiﬁcation of Security Properties, Journal of Computer Security 3(1):5–33, 1995.
Glabbeek, R. J. van, S. A. Smolka, and B. Steffen. Reactive, Generative and Stratiﬁed Models of Probabilistic Processes, Information and Computation 121:59–80, 1995.
Goguen, J. A., and J. Meseguer, Security Policy and Security Models, in Proc. of IEEE Symposium on Security and Privacy, pp. 11–20, 1982.
Gray III, J.W., Probabilistic Interference, in Proc. of IEEE Symposium on Security and Privacy, pp. 170–179, 1990.
Markowitch, O., and Y. Roggeman, Probabilistic Non-Repudiation without Trusted Third Party. 2nd Conf. on Security in Comm. Networks, 1999.
Milner, R., “Communication and Concurrency”, Prentice Hall, 1989.
Sabelfeld, A., and D. Sands, Probabilistic Noninterference for Multi-threaded Programs, in Proc. 13th IEEE Computer Security Foundations Workshop (CSFW’00), pp. 200–214, 2000.
Volpano, D., and G. Smith, Probabilistic Noninterference in a Concurrent Language, in Proc. of 11th IEEE Computer Security Foundations Workshop (CSFW’98), pp. 34–43, 1998.
