Electronic Notes in Theoretical Computer Science 195 (2008) 41–55	
www.elsevier.com/locate/entcs

A Calculus for Team Automata 
Maurice H. ter Beek1
Istituto di Scienza e Tecnologie dell’Informazione, CNR via G. Moruzzi 1, 56124 Pisa, Italy
Fabio Gadducci2
Dipartimento di Informatica, Universita` di Pisa via Buonarroti 2, 56125 Pisa, Italy
Dirk Janssens3
Department of Mathematics and Computer Science, University of Antwerp Middelheimlaan 1, 2020 Antwerpen, Belgium

Abstract
Team automata are a formalism for the component-based specification of reactive, distributed systems. Their main feature is a flexible technique for specifying coordination patterns among systems, thus extending I/O automata. Furthermore, for some patterns the language recognized by a team automaton can be specified via those languages recognized by its components.
We introduce a process calculus tailored over team automata. Each automaton is described by a process, such that its associated (fragment of a) labeled transition system is bisimilar to the original automaton. The mapping is moreover denotational, since the operators defined on processes are in a bijective correspondence with a chosen family of coordination patterns and that correspondence is preserved by the mapping.
We thus extend to team automata a few classical results on I/O automata and their representation by process calculi. Moreover, besides providing a language for expressing team automata, we widen the family of coordination patterns for which an equational characterization of the language associated to a composite automaton can be provided. The latter result is obtained by providing a set of axioms, in ACP-style, for capturing bisimilarity in our calculus.
Keywords: Team automata, process calculi


Introduction
Team automata have originally been introduced in the context of Computer Sup- ported Cooperative Work (CSCW for short) to formalize the conceptual and archi-

٨ Research partially supported by the EU FP6-IST IP 16004 SEnSOria (Software Engineering for Service- Oriented Overlay Computers).
1 Email: maurice.terbeek@isti.cnr.it
2 Email: gadducci@di.unipi.it
3 Email: dirk.janssens@ua.ac.be

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.08.022

tectural levels of groupware systems [3,11,14]. As shown in [5], they represent an extension of I/O automata [15,16], and since their introduction they have proved their usefulness in various application fields [2,6,7]. Team automata form a mathe- matical framework enabling the recast of notions like communication, coordination and cooperation in reactive, distributed systems. The model allows to separately specify the components of a system, to describe their interactions and to reuse the system as a component of a higher-level automaton, thus supporting a modular approach to system design. Its main feature is a flexible technique for specifying coordination patterns among distributed systems, extending classical I/O automata. During the stepwise development of a system, it is desirable to have the possi- bility to decompose an abstract high-level specification of a large, complex design into a more concrete low-level specification. In order to guarantee that the decom- position is correct, it is necessary to prove that the chosen model is compositional, i.e., that the specification of a large system can be obtained from specifications of its components [13]. Unfortunately, as we show in Proposition 2.8 of this paper, for some of the coordination patterns employed so far it is not possible to capture the behavior of a (finite!) team automaton (intended as the language it recognizes) in terms of its components, by resorting only to set-theoretic operations on languages. In order to overcome this difficulty, we introduce a calculus for team automata.
Our proposal recalls those calculi that have been defined for (probabilistic) I/O au- tomata [10,19,20], and the aim is to transfer the technology involving the equational characterization of behavioral equivalences on processes to team automata, in order to obtain a characterization of the relevant coordination patterns. The main idea underlying process algebras like the acp [8], the ccs [17] and the csp [12] frame- works is to use a set of operators, each one representing an architectural feature, for the inductive presentation of a complex system. Our calculus for team automata is essentially an enrichment of csp, and its behavioral semantics is axiomatized by suitably adapted operators from acp. Each team automaton is described by a process, in such a way that its associated (fragment of a) labeled transition sys- tem is behaviorally equivalent (namely, bisimilar [17]) to the original automaton. Furthermore, the mapping is denotational, since the operators on processes are in a bijective correspondence with a chosen family of coordination patterns, and that correspondence is preserved by the mapping.
One of our results is thus the extension to team automata of some classical re- sults on I/O automata and their representation by process calculi. Another result concerns the compositionality of team automata. In [2,4] it was shown that certain team automata that are defined by a coordination pattern are compositional, in the sense that their languages can be obtained from the languages of their constituting automata. Besides proving that this characterization does not hold for all coordi- nation patterns devised so far (even in the presence of acyclic automata: See the already mentioned Proposition 2.8), we use our calculus to provide some preliminary results on how to nevertheless obtain the language of a team automaton defined by a coordination pattern directly from its components. Hence, a compositionality result does exist, even if the manipulation of the languages of the components does

not suffice. By providing a set of axioms, in ACP-style, to capture bisimilarity in our calculus, we thus enlarge the family of coordination patterns for which an equational characterization of the language associated to a team automaton can be provided. This axiomatization is sound and complete for finite processes only (i.e., equivalently, for acyclic automata) as is typical for all the calculi for describ- ing automata that we are aware of (compare, e.g., the situation for (probabilistic) I/O automata, as reported in [10,19]). The search for a set of axioms for possibly recursive processes is currently under development.
The paper is organized as follows. Section 2 recalls the main definitions concern- ing team automata. Then, the syntax and the operational semantics of our calculus for team automata, as well as an equational theory for bisimulation over finite pro- cesses, are given in Section 3. Section 4 presents an encoding from team automata to processes that preserves bisimulation equivalence, while Section 5 offers an ax- iomatic characterization for language equivalence, thus partly solving (since the encoding preserves the composition patterns on automata) our modularity issues. Finally, Section 6 concludes the paper, hinting at possible future work.

A quick look at team automata
Roughly speaking, a team automaton consists of component automata — ordinary automata without final states and with a distinction of their sets of actions into in- put, output and internal actions — combined in such a way that they can perform shared actions. During each clock tick the components within a team can simulta- neously participate in one instantaneous action (i.e., synchronize on this action) or remain idle. Component automata can thus be combined in a loose or more tight fashion, depending on which actions are to be synchronized and when.
Notations and terminology used in this article are initially fixed, after which team automata are introduced, slightly adapting the usual definition of team au- tomata [3]. First, each automaton is assumed to have a unique initial state: This is not a real limitation, but it eases some constructions. Second, the usual distinction between input, output and internal actions in component and team automata is discarded. In [10,19,20] the distinction of the set of actions of I/O automata into input, output and internal actions is taken into account. For team automata, how- ever, this distinction is much less important since — contrary to I/O automata — team automata are not required to be input enabling and synchronizations between output actions are not prohibited [3,5]. Hence in team automata the consideration of input and output actions does not have any syntactic significance. As a result, taking these actions into account would not affect our calculus. Moreover, it would not be easy to extend our calculus in order to deal with internal actions.
Some notation
We start by saying that for the sake of readability we often denote the set {1,... , n} by [n]; thus [0] is the empty set. For j ∈ [n], the (cartesian) product of sets V is denoted either by  i∈[n] Vi or by V1 × ··· × Vn, while the projection projj :

i∈[n] Vi → Vj is defined by projj ((a1,... , an)) = aj. The set difference of sets V
and W is denoted by V \ W and, if V is finite, its cardinality is denoted by #V .
Let f : A → A' and g : B → B' be two functions. Then f × g : A × B → A' × B'
is defined as (f × g)(a, b)= (f (a), g(b)), and f [2] is a shorthand for f × f .
Definition 2.1 A labeled transition system (lts) is a triple (Q, Σ, δ), for a set Q of
states,a set Σ of actions (with Q ∩ Σ= ∅) and a set δ ⊆ Q × Σ × Q of transitions.
The set δa of a-transitions of A is defined as δa = { (q, q') | (q, a, q') ∈ δ } and an a-transition (q, a, q') ∈ δ may also be written as q −a→ q'. Action a is said to be enabled in A at state q ∈ Q, denoted by a enA q, if there exists q' ∈ Q such that (q, q') ∈ δa. An a-transition (q, q) ∈ δa is called a loop (on a).

Synchronizations and team automata
Definition 2.2 A (component) automaton C is a ﬁnite, rooted lts, i.e., a quadruple (Q, Σ, δ, q0), where (Q, Σ, δ) is an lts with finite Q and Σ and an initial state q0 ∈ Q. The set C(C) of computations of C is defined as C(C)= { q0a1q1a2 ··· anqn | n ≥
0 and (qi−1, ai, qi) ∈ δ for all i ∈ [n] }.
The language L(C) of C is the set of sequences of symbols in Σ obtained by the obvious restriction (discarding the symbols in Q) of the computations in C(C).
In the sequel, we let S = { C | i ∈ [n] } be an arbitrary but fixed set of automata, with n ≥ 0 and each Ci specified as Ci = (Qi, Σi, δi, q0i), and we let Σ =  i∈[n] Σi.
A team automaton over S has the cartesian product of the state spaces of its
components as its state space and its actions are those of its components. Its transition relation, however, is not fixed by those of its components: It is defined by choosing certain synchronizations of actions, while excluding others.
Definition 2.3 Let a ∈ Σ. The set Δ (S) of synchronizations of a is defined as Δa(S)= { (q, q') ∈ i∈[n] Qi ×  i∈[n] Qi | [∃ j ∈ [n]: projj [2](q, q') ∈ δj,a] ∧ [∀ i ∈
[n] : [proji[2](q, q') ∈ δi,a] ∨ [proji(q)= proji(q')] ] }.
The set Δa(S) contains all possible combinations of a-transitions of the com- ponents constituting S, with all non-participating components remaining idle. It is explicitly required that in every synchronization at least one component partic- ipates. The state change of a team automaton over S is thus defined by the local state changes of the components constituting S that participate in the action of the team being executed. Hence, when defining a team automaton over S, a spe- cific subset of Δa(S) must be chosen for each action a. This defines an explicit communication pattern between those components constituting the team.
Definition 2.4 A team automaton T over S is a quadruple (Q, Σ, δ, q0), with Q =
Q , Σ =	Σ , δ ⊆ Q × Σ × Q such that δ = { (q, q') | (q, a, q') ∈ δ } ⊆ 
Δa(S) for all a ∈ Σ and q0 =  i∈[n] q0i.

Coordination patterns
In [3] several coordination patterns for the synchronizations of a team automaton were defined, each leading to a uniquely defined team automaton. These patterns fix the synchronizations of a team by defining — per action a — certain conditions on the a-transitions to be chosen from Δa(S), thus determining a unique subset of Δa(S) as the set of a-transitions of the team. Once such subsets have been chosen for all actions, the team automaton they define is unique.
Definition 2.5 Let Ra(S) ⊆ Δa(S), for all a ∈ Σ, and let RΣ = { Ra(S) | a ∈ Σ }. Then (Q, Σ, δ, q0) is the RΣ-team automaton over S if δa = Ra(S) for all a ∈ Σ.
In this notation we usually discard Σ if no confusion can arise. Here we consider three coordination patterns, based on those actions of a team automaton T that are free, ai or si. An action a is free in T if none of its a-transitions is brought about by a synchronization of a by two or more components from S, action a is action-indispensable (ai for short) in T if all its a-transitions are brought about by a synchronization of all components from S sharing a and action a is state- indispensable (si for short) in T if all its a-transitions are brought about by a synchronization of all components from S in which a is currently enabled.
Definition 2.6 Let a ∈ Σ. Then we define the sets
Rno(S)= Δa(S);

Rfree (S)= { (q, q') ∈ Δ (S) | #{ i ∈ [n] | a ∈ Σ ∧ proj [2](q, q') ∈ δ
} = 1 };

a	a	i	i
i,a

Rai (S)= { (q, q') ∈ Δa(S) | ∀ i ∈ [n]: a ∈ Σi ⇒ proji[2](q, q') ∈ δi,a };
Rsi (S)= { (q, q') ∈ Δa(S) | ∀ i ∈ [n]: [a ∈ Σi ∧ a enC q] ⇒ proji[2](q, q') ∈ δi,a }.
a	i
Each of these subsets of Δa(S) thus defines, for a given action a ∈ Σ, all tran- sitions from Δa(S) that satisfy a certain type of synchronization. In the case of no constraints, this means that all a-transitions are allowed since nothing is required, and hence no transition is forbidden. In the other three cases, all and only those a-transitions are included that respect the specified property of a.
Before presenting an example to illustrate the notions defined so far, we provide shorthand notations for three specific types of team automata that we will use in the sequel. Let n = 2 (i.e., we consider S = {C1, C2}) and let Γ ⊆ Σ. Then
C1 |||f C2 defines the Rno ∪ Rfree -team automaton over S;
Γ	Σ\Γ	Γ
C1 |||ai C2 defines the Rno ∪ Rai -team automaton over S;
Γ	Σ\Γ	Γ
C1 |||si C2 defines the Rno ∪ Rsi -team automaton over S.
Γ	Σ\Γ	Γ
Example 2.7 Consider the component automata C1 = ({p, p'}, {b}, {(p, b, p')}, p) and C2 = ({q, q'}, {a, b}, {(q, b, q), (q, a, q' )}, q). They are depicted in Figure 1.

In Figure 2 we have depicted C1 |||f
C2, C1 |||ai
C2 and C1 |||si
C2. Note that

C1 |||f	C2 has no b-transition from (p, q) to (p', q). In fact, this team automaton
is different from the Rno -team automaton over {C1, C2} due to the loop on b in C2


	zp  , b	zp' ,
b
	zrq  ,˛ a	zq' ,


Fig. 1. From left to right: component automata C1 and C2.
(and this fact is going to be further explored in Section 3).
b	b
b



a

b


Fig. 2. Clockwise from top: team automata C1 |||f
C2, C1 |||si
C2 and C1 |||ai
C2.


A negative result
A team automaton over S is said to satisfy compositionality if its behavior (i.e., its language) can be described in terms of that of its constituting component automata: There exists a set-theoretic operation that when applied to the languages of the automata in S, the language of a particular team over S results. In [2,4] it was shown that the construction of team automata according to certain patterns of synchronization, e.g., the ones leading to Rfree - and Rai -team automata, guarantees compositionality. In [2] it is moreover claimed that a similar result for the case of Rsi -team automata “seems impossible due to the simple fact that the behavior of component automata is stripped from all state information”. This is proved below.
Proposition 2.8 Let C1 and C2 be two component automata. Then there exists no set-theoretic operation ||| on languages such that L(C1 |||si C2)= L(C1) ||| L(C2).
The proof is by counterexample. Consider the component automata in Figure 3.
Then L(D2)= L(D3), while L(D1 |||si D2)= L(D1 |||si D3) ∪ {abc}.
Σ	Σ
	zp  , a	zq  , b	zr ,
	zp , a	zq  , b	zp , a	zq , b

˛rc	r 
a	z, c	zr, 


Fig. 3. Clockwise from top: component automata D1, D2 and D3.
In Section 5 we show that the calculus for team automata that we are going to introduce does provide a recipe to obtain the language of an acyclic Rsi -team automaton without actually constructing the team automaton from its constituting components: Translate the component automata to processes, perform the so-called

eager parallel composition operation defined below, derive the normal form of the resulting process term and its associated regular language is the desired language.

A CSP-like process calculus
In this section we first introduce a simple process calculus: It is essentially an en- richment of Hoare’s csp [12]. We later present the associated operational semantics, also providing a set of axioms for recasting bisimilarity.
The syntax
We discuss now the syntax of our calculus. It is based on the process algebra paradigm: Each operator represents a basic feature of a possibly distributed system, and each system is thus defined inductively by composing the operators.
Definition 3.1 Let A be a countable set of actions, ranged over by a, b,.. ., and let X be a countable set of agent variables, ranged over by x, y,.. ., with ℘f (A) — the finite subsets of A — ranged over by L. Agents and processes are thus terms built from actions and variables according to the syntax
M ::= nil | a.x | a.P | a.M | M + M | recx.M
P ::= Mc | P f P | P ai P | P si P
L	L	L
As usual, a variable x is free if it does not occur inside the scope of a recx operator. The set of (sequential) agents is ranged over by M, N,... , and for its subset of closed agents (i.e., containing no free variables) the subscript c is added. The set of processes is denoted by P and ranged over by P, Q,... , and a process is ﬁnite if it contains no occurrence of a recursion operator.
The constant nil represents the terminated process. The action preﬁx a.P can perform an atomic action a and then evolve to P . Summation + denotes non- deterministic choice: M +N behaves either as M or as N , the choice being triggered by the execution of an action. The intended meaning of the recursion operator recx.M is the process defined by the equation x = M , with the further restriction implicitly ensured by the syntax, namely that only closed terms may be inserted into a parallel composition operator: This assumption corresponds to what are usually called size-bounded processes, and it is formalized by Proposition 3.3 below.
There are three different notions of parallel composition. Basically, P	ai Q
means that processes P and Q must evolve synchronously with respect to all actions in L, while they may evolve independently of each other with respect to actions a ∈/ L, i.e., the actions in L are synchronized according to the ai type of synchronization. Similarly for its eager version: Also in P  si Q both processes must synchronize on the actions in L, but now a process may in any case evolve with any action that is not offered at the moment by the other process, i.e., the actions in L are

synchronized according to the si type of synchronization. Finally, in P	f
Q the

two processes may synchronize on actions a ∈/ L, but both processes must evolve independently of each other for all actions in L, in which case a further restriction

Table 1
The operational semantics for P.


—	a	'
recx.M	a

act :	a
sum :
M −→ M
a
M [
rec :
'
/x] −→ N
a

a.P −→ P
M + N −→ M
recx.M −→ N


a	'	a	'	a	'

parf :
P −→ P , Q −→ Q
a ∈/ L	asynf :
P −→ P
a ∈/ L



a	'	a	'	a	'

parai :
P −→ P , Q −→ Q
asynai :
P −→ P
a ∈/ L



a	'	a	'	a	'

parsi :
P −→ P , Q −→ Q
asynsi :
P −→ P
a ∈/ L



a	'	a	a	'	a

f	P −→ P , Q /−→ Q
asynL :
P −→ P , Q /−→
a ∈ L	asynsi :
a ∈ L


is imposed in case one of the processes may loop: In order to faithfully mimic the free type of synchronization for all actions in L, a process may independently evolve with an action a ∈ L only if the other process cannot evolve with a loop on a. This condition seems peculiar in the context of process calculi, but it is a consequence of the lack of explicit information on loops in team automata, i.e., in general it is impossible to distinguish whether or not a component with a loop on a in its current local state participates in the synchronization of the team on a. In [3] this led to the adoption of the maximal interpretation of the components’ participation: Given a team transition (q, a, q') it is assumed that the jth component participates in this transition by executing (projj (q), a, projj (q')) whenever proj[2](q, q') ∈ δj,a, whereas otherwise no transition takes place in the jth component (see Example 2.7).

The operational semantics
The operational semantics of the calculus is described by the lts (У, A, →), where →⊆ У × A ×У is defined in the so-called sos style [18] as the least relation that satisfies the set of axioms and inference rules of Table 1 (where we omitted the symmetric rules for the choice operator and for the three parallel composition operators). Note also the negative premises occurring in the last two rules, namely
asynf and asynsi: Q —a→ means that from Q there is no outgoing transition labeled
with a and Q /—a→ Q means that from Q there is no outgoing transition labeled with a that results in a cycle. Due to the restricted structure of the processes, and since the inference rules increase the size of a process, the least transition relation is well-defined. The semantics of a process P ∈ У, denoted by LTS (P ), is defined as the rooted lts LTS (P )= (У, A, →,P ).
Example 3.2 Consider the simple sequential agents M = b.nil and N = recx(b.x +
a.nil). Their associated rooted lts’s are depicted in Figure 4.
Let L = {b}. Then, the lts’s resulting from the application of the three parallel composition operators to M and N are depicted in Figure 5.



	zM,  b	znil,
 b
	zr,˛ a	z,


Fig. 4. From left to right: LTS (M ), M = b.nil, and LTS (N ), N = recx(b.x + a.nil).

b
	
 b	

b


Fig. 5. Clockwise from top: the LTS’s for M  f
ai
{b}
N and M  si  N .

The next section focuses on an equational presentation for bisimulation equiv- alence, equating those processes exhibiting the same (non-deterministic) observa- tional behavior. The result below states a property of our operational semantics, making precise the previous remark on size-bounded processes.
Proposition 3.3 Let P be a process. Then, the rooted lts LTS (P ) is ﬁnite.
In other words, no syntactic explosion of a process during its evolution may oc- cur, because only closed terms may be inserted into parallel composition operators.

Axioms for bisimulation
The aim of this section is to introduce a finite equational theory for bisimulation, which will later form the basis for the characterization of the language associated to a process (hence, to an automaton). First we define the notion of bisimulation.
Definition 3.4 Let (QA, ΣA, δA) and (QB, ΣB, δB) be lts’s. A relation R ⊆ QA ×
QB is a bisimulation if, whenever (p, q) ∈ R, then for any a ∈ ΣA ∪ ΣB holds
if p —a→ p', then q —a→ q' for some q' ∈ QB such that (p', q') ∈ R;
a	'	a	'	'	'	'
if q —→ q , then p —→ p for some p ∈ QA such that (p ,q ) ∈ R.
Two states q ∈ QA and q' ∈ QB are said to be bisimilar, denoted by q  q', if there exists a bisimulation R such that (q, q') ∈ R. Two rooted lts’s (Q1, Σ1, δ1, q1) and (Q2, Σ2, δ2, q2) are said to be bisimilar if q1  q2. Two processes P and Q are said to be bisimilar if LTS (P ) and LTS (Q) are.
It often occurs that bisimilarity (the largest bisimulation) is not a congruence with respect to the operators of the calculus, whenever there are rules containing negative premises. In fact, two of the sos rules of Table 1 have negative premises, and the set of rules of our calculus does not fit the general ntyft/ntyxt format [9].

Table 2
Axioms for the choice operator.

M + M = M	M + N = N + M

(M + N )+ O = M + (N + O)	M + nil = M

Table 3
Axioms for the parallel composition operators.

P L Q = P  L Q + Q  L P + P |L Q	(P + Q) |L R = P |L R + Q |L R

(P + Q) L R = P  L R + Q  L R	R |L (P + Q)= R |L P + R |L Q

a.P  f Q = a.(P f Q)	nil L P = nil
L	L
f	( a.(P f Q) if a /∈ L
ai	( a.(P ai Q) if a /∈ L


si	( a.(P si Q) if a /∈ L ∩ En(Q)

{ai,si}

{ai,si}



The main problem is the asynf
rule, since it contains an explicit hypothesis on

the target state of the negative premise. It is in fact easy to see that the process

P  = recx.a.x  and its unfolding Q = a.recx.a.x  are bisimilar, while P  f
R and

f
{a}
R are not, for R = a.b.nil. However, the problem disappears whenever we

restrict our attention to finite processes, since the negative premise of the rule is
always void. Thus, in the remaining of the section we consider finite processes only. Our starting point for a finite equational theory for bisimulation is the solution routinely adopted in the acp framework [8], i.e., to use suitable auxiliary operators (usually  and |) to split the parallel composition operator (  ) into its possible behaviors: Either an asynchronous evolution (  ) or a forced synchronization (|). For our calculus of finite processes this leads to the axioms concerning the choice and parallel composition operators reported in Tables 2 and 3, respectively. Concerning parallel composition, the lack of a superscript (either f , ai or si) means that the law holds for each of the three operators. Furthermore, given a process P ∈ У, the
predicate En(P ) is defined as En(P )= { a ∈ A | ∃ Q ∈У : P —a→ Q }.
Proposition 3.5 Let P, Q be ﬁnite processes. Then P and Q are bisimilar if and only if they are equated by the axioms of Tables 2 and 3.
Since the set of sos rules of our calculus of finite processes can be transformed into a set of so-called smooth gsos rules, we could as well have used the general procedure described in [1] to automatically generate a complete axiomatization for bisimulation. We however chose to provide a direct, intuitive set of axioms.
Note that the equations of Tables 2 and 3 can be oriented from left to right,

so that they induce a rewriting system, modulo the so-called AC (associativity and commutativity) axioms for the choice operator +. So, two finite processes are bisimilar if they have the same (modulo AC) normal form (i.e., a process obtained from the original one and such that no further rewrite can be performed from it).

From automata to processes
The aim of this section is to present an encoding from automata to processes such that bisimulation equivalence is preserved. To this end, we now extend the usual definition of automata by assigning a specific set of states to be considered as entry points for the recursion operator.
Definition 4.1 Let X be a set of state variables. Then an automaton over X is a pair ⟨A,f ⟩, where A = (Q, Σ, δ, q0) is an automaton and f : X → Q is an injective (possibly partial) function.
So, for the rest of this section we assume that for each automaton a set of its states is uniquely labeled by an element in X.
It is now possible to define our encoding from automata to processes.
Definition 4.2 Let ⟨A,f ⟩ be an automaton A = (Q, Σ, δ, q0) over XA. Then the algorithm obtained by repeatedly applying the three steps below inductively defines an essentially unique — up to the choice of variables — process Exp(⟨A,f ⟩).
If q0 has no outgoing transitions, then
Exp(⟨A,f ⟩)= ,⎨ x	if f (x)= q0, for some x ∈ XA, and
, nil otherwise;
If q0 has n > 0 outgoing transitions (q0, ai, qi) and no incoming ones, then

Exp(⟨A,f ⟩)=	Σ
i∈{1,...,n}
ai.Exp(⟨Ai,f ⟩)

for automata Ai = (Q \ {q0}, Σ,δ \{ (q0, a, q) | a ∈ Σ,q ∈ Q }, qi) over XA;
If q0 has n > 0 outgoing transitions (q0, ai, qi) and some incoming ones, then


Exp(⟨A,f ⟩)= recx.
Σ	ai.Exp(⟨Ai, fx⟩)

⎝ i∈{1,...,n}	⎠
for a new variable x, automata Ai = (Q, Σ,δ \{ (q0, a, q) | a ∈ Σ,q ∈ Q }, qi) over
XA ∪ {x} and function fx extending f such that fx(x)= q0.
Note that we have implicitly used the fact that the operator + is commutative and associative, up to bisimulation (see the equations in Table 2). Note also that

the second rule we introduced would actually not be needed: We added it just to associate a finite process to an acyclic automaton.
Proposition 4.3 Let ⟨A,f ⟩ be an automaton over XA and let Exp(⟨A,f ⟩) be its essentially unique process. Then A is bisimilar to LTS (Exp(⟨A,f ⟩)).
The proof can be given by coinductive arguments, by associating to the root of A the state Exp(⟨A,f ⟩), and to each state qi all the processes Exp(⟨Ai, g⟩) arising during the translation, and such that qi is the root of Ai.
Example 4.4 Consider component automata C1 = ({p, p'}, {b}, {(p, b, p')}, {p})
and C2 = ({q, q'}, {a, b}, {(q, b, q), (q, a, q')}, {q}) from Example 2.7 as automata over the sets of state variables XC1 and XC2 , respectively.
By Definition 4.2 we obtain that Exp(⟨C' , f1⟩) = nil and that Exp(⟨C1, f1⟩) = 
b.Exp(⟨C' , f1⟩), with C' = ({p'}, {b}, ∅, p'); thus Exp(⟨C1, f1⟩)= b.nil. Moreover, C1
1	1
trivially is bisimilar to LTS (b.nil).
Again by Definition 4.2, Exp(⟨C2, f2⟩)= recx.( b.x + a.Exp(⟨C' ,f ' ⟩) ), with C' =
2	2	2
({q, q'}, {a, b}, ∅, q') and f ' (x) = q, and Exp(⟨C' ,f ' ⟩) = nil; thus Exp(⟨C2, f2⟩) = 
2	2	2
recx.(b.x + a.nil). Finally, C2 trivially is bisimilar to LTS (recx.(b.x + a.nil)).
It is worth noting that the encoding presented in Definition 4.2 is compositional: The parallel composition of two automata, according to any of the coordinaton pat- terns, is mapped into a process that is bisimilar to the parallel composition, accord- ing to the corresponding operator, of the encoding of the underlying automata.
Proposition 4.5 Let A and B be automata, with alphabet ΣA and ΣB, respectively; let ⟨A, ∅⟩ and ⟨B, ∅⟩ be the associated automata over an empty set of state vari- ables; and let A' = LTS (Exp(⟨A, ∅⟩)) and B' = LTS (Exp(⟨B, ∅⟩)) be the automata resulting from the encoding of the process expressions. Then, A {f,si} B is bisimilar

to A'   {f,si} B' and A  ai B is bisimilar to A'   ai
B' for any set of names L.

L	L	L∩ΣA∩ΣB
The further restriction for the action-indispensable coordination pattern is due to the loss of distinction between alphabets in the labeled transition system associated to the calculus. Indeed, the alphabet a component automaton is defined over is relevant only for the ai -coordination pattern, while for the other two patterns only the actions that actually occur in each automaton are relevant. Consider, e.g., the component automata C1 and C2 in Figure 1, and check the difference between the

automaton C1 |||ai
C2, according to the choice of either {b} or {a, b} for Σ1.

Equations for (finite) languages
Consider the equational presentation for bisimulation offered in Section 3. In partic- ular, note how the normal form of a finite process corresponds to a regular expres- sion, obtained by using the set of actions of the calculus as the alphabet and action prefixing and non-deterministic choice as operations. This intuition can be exploited to obtain an equational presentation for the language of a team automaton.

The correspondence between regular expressions and languages is a staple of theoretical computer science, so we do not repeat it here. We simply let LP denote the language of a process P , which is easily derived from its normal form. Moreover, we let L^ denote the prefix-closed extension of a language L over Σ, i.e.,
L^ = { α ∈ Σ∗ | ∃ β ∈ Σ∗ : αβ ∈ L }.
As a direct corollary of Proposition 4.3 we thus obtain the following result.
Proposition 5.1 Let A be an automaton. Then L(A)= L^Exp(⟨A,∅⟩).
This result suggests that our calculus can be used to derive the language of a team automaton. This is not surprising, since bisimulation is always finer than language equivalence: This property is just considered in an environment that is slightly more complex than usual, since our calculus contains three different op- erators for parallel composition. The previous result moreover suggests the use of equational laws to distill a normal form that is simpler than the original automaton.
Proposition 5.2 Let P, Q be ﬁnite processes. Then LP = LQ if and only if the normal forms of P and Q are equated by the axioms of + (Table 2) and the axiom
a.M + a.N = a.(M + N ).
Also this equation can be interpreted as a left-to-right rewriting rule, allowing the further reduction of the normal form of a process. However, it is important to realize that this axiom could not simply have been added to Tables 2 and 3, since critical pairs would have arisen due to this axiom’s incompatibility with the distributivity axioms of eager parallel composition.
Example 5.3 Consider the three automata D1, D2 and D3 used in the counterex- ample concerning Proposition 2.8, as shown in Figure 3. Ignoring the above axiom, then clearly their associated processes D1, D2 and D3 have the normal forms a.b.nil, a.b.nil + a.c.nil and a.(b.nil + c.nil), respectively. Should the above axiom have been added to the set of equations in Tables 2 and 3, then clearly D2 would be equated to D3 and thus D1 si D2 would have the same normal form (hence recognize the same language) as D1 si D3, which is not the case: Instead, the normal form for a.b.nil  si a.b.nil + a.c.nil is a.b.nil + a.b.c.nil + a.c.b.nil, reduced to a.(b.c.nil + c.b.nil); while the normal form for a.b.nil si a.(b.nil + c.nil) is a.b.nil + a.c.b.nil, reduced to a.(b.nil + c.b.nil). The associated languages are easily derived.
The situation so far is thus quite satisfactory for finite processes (i.e., equiv- alently, for acyclic automata): In order to prove the equivalence of two team au- tomata with respect to the language they recognize, it is sufficient to consider the associated processes and analyze their normal forms. Moreover, it is relevant that the mapping from team automata to processes preserves, up to bisimulation, the three composition patterns that were considered in this paper: This result ensures that the procedure devised so far for obtaining the normal form is modular.

Conclusions and future work
In this paper we introduced a process calculus for team automata, extending some classical results on I/O automata. As a side-effect, we widened the family of team automata that guarantee a degree of compositionality by providing a way to obtain the language of a (finite) Rsi -team automaton from its components. While this language cannot be obtained through a direct manipulation of the languages of the component automata, the resulting degree of modularity favors the use of team automata in component-based system design.
Future work in this direction should lead to compositionality results also for other types of team automata. A first step in this direction could be to extend our calculus with parallel composition operators that mimic the various peer-to- peer and master-slave patterns of synchronization for team automata as introduced in [3], as well as mixtures of the synchronizations defined for team automata. As a matter of fact, [2,4] contain compositionality results not only for Rfree - and Rai - team automata, but also for team automata constructed according to a mixture of the free and ai synchronizations. It is important to recall, however, that the various peer-to-peer and master-slave patterns of synchronization make use of the distinction of the set of actions of team automata into input, output and internal actions. This means that in order to tackle the above issues, our calculus should first be extended to take this distinction into account.
Our correspondence results between automata and processes (as summed up by the two propositions in Section 4) relate the behavior of possibly cyclic automata and possibly recursive processes. We restrained however from tackling the axioma- tization of recursive processes in our paper. It would be relatively easy to come up with a complete set of equational laws for those recursive processes not containing the parallel operators, since they basically boil down to regular expressions equipped with a Kleene star operator. On the other hand, the lack of a complete set of axioms for recursive processes is a common trait for all the calculi proposed for automata that we are aware of: Compare, e.g., the situation for (possibly probabilistic) I/O automata, as reported in [10,19]. We hope that our syntactical restriction will suf- fice to obtain a relatively small set of equations which is complete, but we leave this topic as the subject of future work.
Lastly, in order to be really useful in practical applications of team automata, it would be worthwhile to study the complexity of the algorithms introduced in this paper, e.g., what is the cost of checking the bimisimilarity between two automata, or of obtaining the language of a team automaton via its translation into a process.


Acknowledgement
We are grateful to Jetty Kleijn and to the anonymous referees for their useful comments on a preliminary version of this paper.

References
Aceto, L., B. Bloom and F. W. Vaandrager, Turning SOS rules into equations, Information and Computation 111 (1994), pp. 1–52.
ter Beek, M. H., “Team Automata—A Formal Approach to the Modeling of Collaboration Between System Components,” Ph.D. thesis, Leiden University (2003).
ter Beek, M. H., C. A. Ellis, J. Kleijn and G. Rozenberg, Synchronizations in team automata for groupware systems, Computer Supported Cooperative Work 12 (2003), pp. 21–69.
ter Beek, M. H. and J. Kleijn, Team automata satisfying compositionality, in: K. Araki, S. Gnesi and
D. Mandrioli, editors, International Symposium of Formal Methods Europe, Lect. Notes in Comp. Sci.
2805 (2003), pp. 381–400.
ter Beek, M. H. and J. Kleijn, Modularity for teams of I/O automata, Information Processing Letters
95 (2005), pp. 487–495.
ter Beek, M. H., G. Lenzini and M. Petrocchi, Team automata for security: A survey, in: F. R. and
G. Zavattaro, editors, International Workshop on Security Issues in Coordination Models, Languages, and Systems, Electr. Notes in Theor. Comp. Sci. 128 (2005), pp. 105–119.
ter Beek, M. H., G. Lenzini and M. Petrocchi, A team automaton scenario for the analysis of security properties of communication protocols, Journal of Automata, Languages and Combinatorics (2006), to appear.
Bergstra, J. A. and J. W. Klop, Process Algebra for Synchronous Communication, Information and Control 60 (1984), pp. 109–137.
Bol, R. N. and J. F. Groote, The meaning of negative premises in transition system specifications, Journal of the ACM 43 (1996), pp. 863–914.
De Nicola, R. and R. Segala, A process algebraic view of input/output automata, Theoretical Computer Science 138 (1995), pp. 391–423.
Ellis, C. A., Team automata for groupware systems, in: International Conference on Supporting Group Work (1997), pp. 415–424.
Hoare, C. A. R., “Communicating Sequential Processes,” Prentice Hall, 1985.
Jonsson, B., Compositional specification and verification of distributed systems, ACM Transactions on Programming Languages and Systems 16 (1994), pp. 259–303.
Kleijn, J., Team automata for CSCW: A survey, in: Petri Net Technology for Communication-Based Systems, Lect. Notes in Comp. Sci. 2472, Springer, 2003 pp. 295–320.
Lynch, N. A., “Distributed Algorithms,” Morgan Kaufmann, 1996.
Lynch, N. A. and M. R. Tuttle, An introduction to input/output automata, CWI Quarterly 2 (1989),
pp. 219–246.
Milner, R., “A Calculus of Communicating Systems,” Lect. Notes in Comp. Sci. 92, Springer, 1980.
Plotkin, G., A structural approach to operational semantics, Technical Report DAIMI FN-19, Computer Science Department, Aarhus University (1981).
Stark, E. W., R. Cleaveland and S. A. Smolka, A process-algebraic language for probabilistic I/O automata, in: R. Amadio and D. Lugiez, editors, International Conference on Concurrency Theory, Lect. Notes in Comp. Sci. 2761 (2003), pp. 193–207.
Vaandrager, F. W., On the relationship between process algebra and input/output automata (extended abstract), in: Symposium on Logic in Computer Science (1991), pp. 387–398.
