

Electronic Notes in Theoretical Computer Science 220 (2008) 61–77
www.elsevier.com/locate/entcs

Model Checking Quantitative Linear Time Logic
Marco Faella
Universita` di Napoli “Federico II”, Italy
Axel Legay
University of Li`ege, Belgium
Mari¨elle Stoelinga
University of Twente, The Netherlands

Abstract
This paper considers QLtl, a quantitative analagon of Ltl and presents algorithms for model checking
QLtl over quantitative versions of Kripke structures and Markov chains.
Keywords: Linear temporal logic, Quantitative verification, Automata.

Introduction
Quantitative properties, such as real-time and resource consumption, are essential in embedded system design. Hence, a wide variety of verification frameworks have been developed for the verification and validation of quantitative system aspects; we mention timed automata [3], probabilistic CTL [18], hybrid bisimilarity [19].
However, the analysis within these frameworks is still Boolean: either a timed automaton satisfies a property or not; two hybrid automata are either bisimilar or they are not. A Boolean approach to quantitative system analysis suffers from the drawback of being fragile: small perturbations in the values within the system description may lead to opposite truth values for the satisfaction of a property. This is problematic, since the system values are usually only known approximately, because they are often obtained by measurement, learning or educated guesses.
To circumvent this problem, quantitative methods for quantitative system anal- ysis have been proposed [5,6,8,14]. These approaches are based on quantitative

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.11.019

logics and quantitative system relations: whereas Boolean logics indicate whether a property holds for a system or not, quantitative logics express to what extend a property hold for a system; whereas (Boolean) bisimulations indicate whether or not two systems are equivalent, quantitative system relations (or distances) measure how similar two systems are. More specifically, [6] introduces QCtl, a quantita- tive analogon of Ctl, together with model checking procedures for it. [5] considers QLtl, a quantitative analogon of Ltl, and a quantitative μ-calculus and character- izes these by quantitative versions of trace equivalence and bisimilarity, respectively. This paper continues the quest for quantitative verification and provides model checking procedures for QLtl over quantitative transition systems (QTSs) and quantitative Markov chains (QMCs). QTSs and QMCs are resp. Kripke structures and Markov chains whose atomic propositions have values in [0, 1], rather than in {0, 1}. We also extend QLtl with a quantitative until operator, which is not present in [5]. Our logic is a particular instance of the general logic χLtl of [9], except that QLtl allows atomic propositions to be interpreted over an infinite and uncountable domain. Our model checking algorithm, although similar to the one of [9], is more direct, does not involve the complementation of the formula and exploits the separatedness of the automaton corresponding to the formula. Finally, our treatment of stochastic systems and the discussion on possible extensions to the
logic are novel.
Our model checking procedure generalizes the classical Ltl model checking al- gorithms and constructs a Bu¨chi automaton Aϕ for each QLtl formula ϕ. Our construction of Aϕ bears many similarities to the Ltl case: Recall that, for Ltl, each state q in Aϕ is a subset of the closure of ϕ, which, roughly speaking, contains all subformulas of ϕ. In our case, each state q in Aϕ assigns a value γ(ψ) (from a finite subset of [0, 1]) to each formula ψ in the closure of ϕ. The correctness of this construction heavily relies on the fact that the Bu¨chi conditions for the Boolean until operator immediately generalize to the quantitative case: for each formula ψ1 U ψ2 in the closure of ϕ, we require that a trace accepted by Aϕ hits infinitely many times a state where γ(ψ1 U ψ2) = γ(ψ2). On the other hand, there are also several striking differences in the model checking algorithms for Ltl and QLtl. As an example, when model checking ϕ over a QTS S, we consider S× Aϕ, rather than S × A¬ϕ, hence avoiding any complementation operation. Indeed, contrary to the LTL case, we do not test whether all the executions satisfy the property, but rather compute the minimal value for which the property is satisfied. The latter can be done by combining the automaton and the system, looking for the minimal among all the accepting executions.
We show that for Markov chains, the model checking problem for QLtl reduces to the one for the Ltl case, and that it has no additional cost. One interesting aspect of our approach is that the automaton Aϕ we build is separated, i.e. all states accept disjoint languages. Following [12], this allows us to avoid the use of Rabin automata, matching the well-known single exponential complexity bound proposed in [13].
Finally, we conclude the paper with several open problems and extensions. First,

we state that the model checking procedure for QLtl over quantitative Markov decision processes is still partially open. Indeed, as for Markov chains, we show that this problem can be reduced to the model checking problem for Ltl over Markov decision process. However, contrary to the Markov chain case, this reduction has an exponential cost. We also consider three extensions of QLtl. First, we deal with the logic QCtl∗, which is obtained by adding path quantifiers ∃ and ∀ to QLtl. By interpreting the path quantifiers as in [6], we obtain that, on QMCs, model checking QCtl∗ is directly equivalent to model checking QLtl, while on QTSs it can be reduced to model checking QLtl. Further extensions include one where temporal operators are equipped with discount factors, and the another one featuring a long-run average operator. Model checking procedures for those two extensions is open, and the paper clearly states where the difficulties are.
Organization of the paper. In Section 2, we briefly recall some theory on au- tomata over infinite words. Section 3 introduces QTS and QMC models, Section 4 presents the logic QLtl, while Section 5 treats our model checking algorithms. Then, we present in Section 6 several extensions to the theory and in Section 7 some conclusions.

Background on Infinite-Word Automata
We suppose the reader familiar with the theory of finite-word automata. We recall basic notions and definitions concerning infinite words and infinite-word automata. An inﬁnite word (or ω-word ) w over an alphabet Σ is a mapping w : N → Σ. The set of infinite words over Σ is denoted Σω.
We consider sets of infinite words that can be represented by automata. For- mally, an inﬁnite-word automaton is a tuple A = (Σ, Q, Q0, ρ,F ), where Σ is a finite alphabet, Q is a finite set of states, Q0 ⊆ Q is a non-empty set of initial states, ρ : Q × Σ → 2Q is a nondeterministic transition function, and F is an acceptance condition. The automaton A is said to be deterministic iff |ρ(q, a)| = 1 for each q ∈ Q and a ∈ Σ. A run π of A on an infinite word w is a mapping π : N → Q, with π0 ∈ Q0, and for all i ≥ 0, πi+1 ∈ ρ(πi, wi).
Acceptance of a run π is defined in terms of the set inf (π) of states that occur infinitely often in π, defined by inf (π) = {a ∈ Σ | ∀i > 0 . ∃j > i . πj = a}. We consider the following types of acceptance conditions.
A Bu¨chi condition is a set F ⊆ Q of accepting states. A set T ⊆ Q is accepting for the Bu¨chi condition if T ∩ F /= ∅.
A generalized Bu¨chi condition is a subset F of 2Q. A set T ⊆ Q is accepting for the generalized Bu¨chi condition iff for each Fi ∈ F , T ∩ Fi /= ∅.
A Rabin condition is a subset F of 2Q×2Q, i.e., it is a collection of pairs of sets of states, written [(L1, U1).. .(Ln, Un)]. A set T ⊆ Q is accepting for the Rabin condition if T ∩ Li /= ∅ and T ∩ Ui = ∅ for some i.
A Bu¨chi (resp. generalized Bu¨chi, Rabin) automaton A is an automaton on infi-

nite words with a Bu¨chi (resp. a generalized Bu¨chi, a Rabin) acceptance condition. A word w is accepted by A if there exists a run π on w such that the set inf (π) is accepting with respect to the Bu¨chi (resp. generalized Bu¨chi, Rabin) condition. The set of infinite words accepted by A is called the language of A and is denoted by L(A). For Q' ⊆ Q, we write LQ' (A) for the language accepted by A if Q' is the set of initial states. We write Lq(A) for L{q}(A). The automaton A is separated if each word is accepted from at most one state; that is if Lq(A) ∩ Lq' (A)= ∅ for all q, q' ∈ Q with q /= q'.
A Bu¨chi condition is a special case of both the generalized Bu¨chi and Rabin conditions. Hence, Bu¨chi automata are not more expressive than generalized Bu¨chi and Rabin automata. The opposite direction also holds. Moreover, unlike finite- word automata, infinite-word automata are not always closed under determiniza- tion: Bu¨chi and generalized Bu¨chi automata are not, while Rabin automata are closed under determinization. These facts yield the following result, which plays a significant role in many automata-based model checking algorithms.
Theorem 2.1 Given a Bu¨chi automaton A, there is a deterministic Rabin automa- ton A' such that L(A)= L(A').
Theorem 2.1 was first stated in [22], where a doubly exponential construction was provided. This construction was improved in [24], where a singly exponential, with an almost linear exponent, construction was provided: if A has n states, then A' has 2O(n log n) states and O(n) pairs in its acceptance condition.

Quantitative Transition Systems and Markov Chains
Basic Deﬁnitions
For two real numbers u1 and u2, we write u1 H u2 for max{u1, u2} , and u1 H u2 for min{u1, u2}. Given a set E and a sequence π = e0e1e2 ··· ∈ Eω, we write πi for the i—th element ei of π, and we write πi = eiei+1ei+2 ... for the (infinite) suffix of π starting from πi. Let Σ be a finite set and X ⊆ [0, 1], we denote by vals(Σ,X) the set of all functions from Σ to X. All elements of vals(Σ,X) are called Σ-valuations; elements of vals(Σ, {0, 1}) are called boolean Σ-valuations. We denote by trac(Σ,X) the set of infinite sequences of valuations from vals(Σ,X). All elements of trac(Σ,X) are called Σ-traces. The boolean traces are the elements of trac(Σ, {0, 1}).

Quantitative Transition Systems
A quantitative transition system (QTS for short) is an LTS whose atomic propo- sitions, rather than being true of false, take values in [0, 1].  Formally, a QTS
£ = (Σ, S, δ, [·]) consists of a set Σ of atomic propositions, a finite set S of states, a transition relation δ ⊆ S × S, and a function [·]: S → (Σ → [0, 1]) which assigns to each state s ∈ S and proposition r ∈ Σ a real value [s](r). A QTS is boolean if, for all s, [s] is boolean. The size of £ is given by its number of transitions, i.e.

|£| = |δ|.
A path in £ is an infinite sequence π = s0s1s2 ... of states such that (si, si+1) ∈ δ
for all i ∈ N. Given a state s, we write pts (s) for the set of all paths starting in
s. Every path π in £ induces the Σ-trace [π] = [π0][π1][π2] ... . With an abuse of notation, we write trac(s) = {[π] | π ∈ pts (s)} for the set of Σ-traces from s ∈ S. Notice that trac(s) ⊆ trac(Σ, [0, 1]).

Quantitative Markov Chains
Given a finite set S,a probability distribution on S is a function μ : S → [0, 1] such that Σs∈S μ(s) = 1. We denote by D(S) the set of all probability distributions on
S.
A quantitative Markov chain (QMC for short) is a Markov chain whose propo- sitions take values in [0, 1]. Thus, in each state of a QMC, the successor state is choosen probabilistically. Formally, a QMC £ = (Σ, S, Δ, [·]) consists of a set Σ of atomic propositions, a finite set S of states, a transition relation Δ : S → D(S), and a function [·]: S → (Σ → [0, 1]). The size of £ is given by |S|2. A QMC (Σ, S, Δ, [·]) induces a QTS (Σ, S, δ, [·]), where δ = {(s, t) ∈ S2 | Δ(s)(t) > 0}. Definitions for paths and traces in a QMC are identical to those for the corresponding QTS.
A quantitative Markov chain together with an initial state s gives rise to a probability space (trac(s), B, Prs), where B is the set of measurable subsets of trac(s), and Prs is the uniquely induced probability measure (see [11] for an introduction). Given a random variable X over this probability space, we denote its expected value by Es[X].
When discussing the complexity of algorithms taking a QMC as input, we assume that transition probabilities are encoded as fixed-precision numbers, and therefore that arithmetic operations and comparisons take constant time.

Quantitative LTL
In this section we introduce Quantitative Linear Temporal Logic (QLtl for short), a quantitative version of the Linear Temporal Logic (Ltl for short) introduced in [23].

Syntax
Let Σ be a set of atomic propositions. The QLtl formulas over Σ are generated by the following grammar:
ϕ ::= r | t | f | ϕ ∨ ϕ | ϕ ∧ ϕ | ¬ϕ | ϕ U ϕ | ϕ U˜ϕ | 。ϕ |  ϕ |  ϕ


where r ∈ Σ. The operators U,
U˜,  , and  are the temporal operators. The

syntax of QLtl is therefore the same as the one of Ltl.

Semantics
Here r ∈ Σ is an atomic proposition. A QLtl formula ϕ over Σ assigns a real value [[ϕ]](σ) ∈ [0, 1] to each Σ—trace σ as follows.


[[ϕ C ψ]](σ) = supi≥0 [[ϕ]](σ0) H ··· H [[ϕ]](σi−1) H [[ψ]](σi) 
[[ϕ C˜ψ]](σ) = infi≥0 [[ϕ]](σ0) H ··· H [[ϕ]](σi−1) H [[ψ]](σi) .

The semantics of C can be understood as follows. In the Boolean case, ϕ C ψ holds on the boolean trace σ there exists an i such that [ϕ]](σ0) Λ ... [[ϕ]](σi−1) Λ [[ψ]](σi). In the quantitative case, Λ corresponds to H and the existential quantifi-

cation of i corresponds to the supremum over all i. The semantics of in a similar way.
C˜ is obtained

The following result is an immediate consequence of the fact that each finite set has a minimum.
Lemma 4.1 Let ϕ, ψ be QLtl formulas, let σ ∈ trac(Σ,X) where X is a ﬁnite set. Then
[[ϕ C ψ]](σ) = maxi≥0 [[ϕ]](σ0) H ··· H [[ϕ]](σi−1) H [[ψ]](σi) 
[[ϕ C˜ψ]](σ) = mini≥0 [[ϕ]](σ0) H ··· H [[ϕ]](σi−1) H [[ψ]](σi) .

Evaluation over quantitative transition systems. A QLtl formula ϕ assigns a real value [[ϕ]](s) ∈ [0, 1] to each state s of a given QTS, according to the rule [[ϕ]](s) = inf{[[ϕ]](σ) | σ ∈ trac(s)}. Taking the infimum over all σ corresponds to the fact that an Ltl formula holds in a state if it hold for all traces from that state.
Evaluation over quantitative Markov chains. Given a QMC £,a state s, and a QLtl formula ϕ, the function [ϕ ], which assigns a real value to each Σ-trace, is a random variable over the probability space (trac(s), У, Prs). Accordingly, we define the value of ϕ on state s to be [ϕ]](s)= Es[[[ϕ]]].

Properties of QLtl
Extension of Ltl. The semantics of QLtl is a proper extension of the one of Ltl: for Boolean traces σ, we have that [ϕ]](σ) = 1 if σ |= ϕ and [ϕ]](σ)=0 otherwise. Here, |= is the classical LTL satisfaction relation.
Equivalences and positive normal forms. Two QLtl formulas ϕ and ψ are equivalent, notation ϕ ≡ ψ, if they assign the same value to each trace. Formally,

we have ϕ ≡ ψ iff [ϕ]](σ)= [ψ]](σ) for all traces σ. Obviously, if two formalas agree on all traces, they will also agree on all QLTSs and QMCs.
As for Ltl, each QLtl formula can be transformed an equivalent formula in pos- itive normal form where negations only appear in front of the atomic propositions. This transformation relies on the following equivalences.
ч(ϕ1 C ϕ2) ≡ (чϕ1) C˜(чϕ2) ч(ϕ1 C˜ϕ2) ≡ (чϕ1) C(чϕ2)
ч( 。ϕ) ≡ 。(чϕ).

Moreover, the following classical equivalences also hold for QLtl:
 ϕ ≡ f C˜ϕ	 ϕ ≡ t C ϕ.

From now on, we only consider formulas in positive normal form without occurence of  and  . Notice that we cannot remove both t and f from the logic, since p V чp /≡ t (i.e. the Law of the Excluded Middle does not hold) and p Λ чp /≡ f.

Evaluating QLtl
In this section, we extend the automata-based technique by [28,29] to determine the valuation of a QLtl formula on a QTS or a QMC. First, we prove that if along a trace all atomic propositions only take a finite number of different values, any QLtl formula assigns to that trace either one of the values occurring in the trace, or 1 — x, where x is a value occurring in the trace. The formula can also directly assign values 0 and 1 using constants t and f. As a corollary, when evaluated on a QTS £, a QLtl formula can only assume value in V(£).
Theorem 5.1 Let V be a ﬁnite subset of [0, 1] and let σ ∈ trac(Σ, V). Then, for all QLtl formulas ϕ, we have [[ϕ]](σ) ∈ {0, 1} ∪ V ∪ {1 — x | x ∈ V}.
Proof. By induction on ϕ, using Lemma 4.1.	 

Corollary 5.2 Given a QTS £, a state s ∈ S, and a QLtl formula ϕ, we have
[[ϕ]](s) ∈ V(£).

Closure labeling
Next,we consider the two following definitions.
Definition 5.3 The closure of a QLtl formula ϕ is the smallest set clos(ϕ) of

QLtl formulas such that:
ϕ ∈ clos(ϕ)
ψ1 V ψ2 ∈ clos(ϕ) =⇒ ψ1, ψ2 ∈ clos(ϕ)
ψ1 Λ ψ2 ∈ clos(ϕ) =⇒ ψ1, ψ2 ∈ clos(ϕ)
。ψ1 ∈ clos(ϕ) =⇒ ψ1 ∈ clos(ϕ)
ψ1 C ψ2 ∈ clos(ϕ) =⇒ ψ1, ψ2 ∈ clos(ϕ)
ψ1 C˜ψ2 ∈ clos(ϕ) =⇒ ψ1, ψ2 ∈ clos(ϕ).

We denote by |ϕ| the number of temporal operators, Boolean connectives and propositions found in the formula ϕ. Notice that |clos(ϕ)| = O(|ϕ|).
Definition 5.4 A closure-valuation for a QLtl formula ϕ is a function v :
clos(ϕ) → [0, 1]. A closure-valuation is consistent if the following conditions hold.
If t ∈ clos(ϕ), then v(t)= 1.
If f ∈ clos(ϕ), then v(f)= 0.
If ψ1 V ψ2 ∈ clos(ϕ), then v(ψ1 V ψ2)= v(ψ1) H v(ψ2).
If ψ1 Λ ψ2 ∈ clos(ϕ), then v(ψ1 Λ ψ2)= v(ψ1) H v(ψ2).
If both r and чr belong to clos(ϕ), then v(чr)=1 — v(r).
A closure-trace is an infinite sequence of consistent closure-valuations.
To determine the value of a QLtl formula on a Σ-trace one can proceed by building a closure-trace in a way that is compatible with QLtl semantics. Con- sider a closure-trace γ for a formula ϕ defined over a set of atomic propositions Σ. For a Σ-trace σ, we say that γ is valid for σ if, for each i≥0, it satisfies the rules
- (vi) below. (adapted from [29]):
For each r ∈ Σ, if r ∈ clos(ϕ) then γi(r) = σi(r), and if чr ∈ clos(ϕ) then
γi(чr)= 1 — σi(r).
If γi( 。ψ1)= u then γi+1(ψ1)= u.

For the C and
C˜ operators, the semantics rules refer to a possibly infinite set of

points of the sequence. The solution is first to notice that the following identities hold for each i≥0:
[[ψ1 C ψ2]](σi)= [ψ2]](σi) H ([[ψ1]](σi) H [[ 。(ψ1 C ψ2)]](σi))
[[ψ1 C˜ψ2]](σi)= [ψ2]](σi) H ([[ψ1]](σi) H [[ 。(ψ1 C ψ2)]](σi)).

These identities suggest the following labeling rules for each i ≥ 0:
If γi(ψ1 C ψ2)= u, then u = γi(ψ2) H (γi(ψ1) H γi+1(ψ1 C ψ2)).
If γi(ψ1 C˜ψ2)= u, then u = γi(ψ2) H (γi(ψ1) H γi+1(ψ1 C˜ψ2)).

The acceptance conditions
However, as is illustrated by the following example, those conditions are not suffi- cient for the closure-trace to be valid.
Example 5.5 Consider the QLtl formula p C q with p, q ∈ Σ. We have clos(ϕ)= 
{p C q, p, q}. Consider now a closure-trace that constantly assigns values 0.6, 0.7, and 0.3 to p C q, p, and q, respectively. This trace is valid for any Σ-trace that always assigns the value 0.7 to p and 0.3 to q. However the evaluation of p C q on such a trace would be 0.3, and thus not 0.6 as it is suggested by the closure-trace.
The problem in the example above is that when only considering rules (iii) and (iv), the evaluation of p C q can always be postponed to the next element in the sequence. The solution is to observe that since the systems on which QLtl formulas are evaluated are finite-state systems, we can restrict ourselves to a finite subset of [0, 1]. In this setting, we obtain the following result.
Theorem 5.6 Consider a QLtl formula of the form ϕ1 C ϕ2 (resp. ϕ1 C˜ϕ2). Let V be a ﬁnite subset of [0, 1] and let σ ∈ trac(Σ, V). For all i≥0 there exists j≥i such that [[ϕ1 C ϕ2]](σj )= [ϕ2]](σj) (resp. [[ϕ1 C˜ϕ2]](σj )= [ϕ2]](σj )).
Proof. Let i ∈ N. Let j = argmaxk>i[[ϕ2]](σk), that is, j is an index where a maximum ϕ2 value is attained, i.e. j is such that [ϕ2]](σj )= maxk>i[[ϕ2]](σk). Such an index j exists because V is finite and therefore so is the set of possible values of ϕ2. We claim that [ϕ1 C ϕ2]](σj)= [[ϕ2]](σj ). On the one hand
[[ϕ C ψ]](σj ) = supk≥0 [[ϕ]](σj ) H ··· H [[ϕ]](σj+k−1) H [[ψ]](σj+k)  ≥ [[ψ]](σj ).
On the other hand, using Lemma 4.1, there is a k such that
[[ϕ C ψ]](σj ) = [ϕ]](σj ) H ··· H [[ϕ]](σj+k−1) H [[ψ]](σj+k)
≤ [[ψ]](σj+k)
≤ [[ψ]](σj ).


The
C˜ case is proved similarly.	 

As a consequence of Theorem 5.6, we add the following labeling rules, which only have sense when considering V to be a finite subset of [0, 1] :
For each i≥0, there exists j≥i such that γj(ψ1 C ψ2)= γj(ψ2).
For each i≥0, there exists j≥i such that γj(ψ1 C˜ψ2)= γj(ψ2).
The following result states that the six labeling rules (i)-(vi) completely char- acterize the semantics of a QLtl formula. Its proof is an easy induction on the structure of the subformulas of ϕ.
Theorem 5.7 Consider a QLtl formula ϕ, a ﬁnite set V ⊆ [0, 1] and a Σ-trace σ ∈ trac(Σ, V). Then γ is a valid closure-trace for σ if and only if [[ψ]](σi)= γi(ψ) for all ψ ∈ clos(ϕ) and i ≥ 0.

Corollary 5.8 Consider a QLtl formula ϕ, a ﬁnite set V ⊆ [0, 1] and a Σ-trace σ ∈ trac(Σ, V). We have that [[ϕ]](σ)= u if and only if there exists a valid closure- trace γ for σ such that γ0(ϕ)= u.

The Bu¨chi automaton for QLtl model checking
Given a QLtl formula ϕ, we now build a generalized Bu¨chi automaton that de- scribes a possibly infinite set of Σ-traces and whose states are consistent closure- valuations of ϕ. More precisely, the automaton is built in such a way that for each formula ψ1 in the closure of ϕ, for each state q, and for each accepting Σ-trace σ from s, the valuation [ψ1]](σ) is given by q(ψ1).
Definition 5.9 Let Σ be a set of atomic propositions and let V be a finite subset of [0, 1] such that, for all x ∈ V, 1 — x ∈ V. We define the QLtl-automaton for ϕ and V as the tuple AV = (vals(Σ, V), Q, Q0, ρ,F ), where:
The alphabet of the automaton is vals (Σ, V).
The set of states Q is the set of closure-valuations in vals(clos (ϕ), V) which are consistent.
We choose Q0 = Q.
The transition function is such that for each q, q' ∈ Q and a ∈ vals(Σ, V), we have
q' ∈ ρ(q, a) iff
For all r ∈ Σ, if r ∈ clos(ϕ) (resp. чr ∈ clos(ϕ)), then q(r) = a(r) (resp.
q(чr)= 1 — a(r)).
If 。ψ1 ∈ clos(ϕ), then q( 。ψ1)= q'(ψ1).
If ψ1 C ψ2 ∈ clos(ϕ), then q(ψ1 C ψ2)= q(ψ2) H (q(ψ1) H q'(ψ1 C ψ2)).
If ψ1 C˜ψ2 ∈ clos(ϕ), then q(ψ1 C˜ψ2)= q(ψ2) H (q(ψ1) H q'(ψ1 C ψ2)).

If clos(ϕ) contains no formula with C and
C˜ operators, then F = {Q}. Other-

wise, for each formula of the form ψ1 C ψ2 (resp. ψ1 C˜ψ2) in clos(ϕ), F contains
the set Qψ1 U ψ2 (resp. Qψ1 U˜ψ2 ), where q ∈ Qψ1 U ψ2 iff q(ψ1 C ψ2) = q(ψ2) (resp.
q(ψ1 C˜ψ2)= q(ψ2)).
Observe that the number of states of AV is bounded by |V||clos(ϕ)|. In practice the bound is not reached since one only considers consistent closures. The set of initial states is defined arbitrarily and will be discussed in the next section. Corollary
5.11 states the correctness of the construction of AV . The key to this correctness
property is given by Theorem 5.10.
Theorem 5.10 Let ϕ be a QLtl formula and let V be a ﬁnite subset of [0, 1] such that if x ∈ V, then also 1 — x ∈ V. Furthermore, let π : N → Q be an inﬁnite sequence of states in AV . Then π is an accepting run from state q in AV if and only
ϕ	ϕ
if the following conditions hold.
π is a valid closure-trace for σ, which is given by σi(r)= π(r) for all r ∈ Σ.
π(ψ)= q(ψ) for all ψ ∈ clos(ϕ).

Corollary 5.11 Let ϕ be a QLtl formula and let V be a ﬁnite subset of [0, 1] such that if x ∈ V, then also 1 — x ∈ V. Furthermore, let σ ∈ vals(Σ, V) be an Σ-trace.
Then
σ ∈ Lq(AV ) if an only if [[ψ]](σ)= q(ψ) for all ϕ ∈ clos(ϕ);
for all v ∈ V and all ψ in the closure of ϕ we have

 
q∈Q,q(ψ)=v
Lq(AV )= {σ ∈ vals(Σ, V) | [[ψ]](σ)= v}.

The automaton AV also satisfies the following property, which will be of particular interest for the results that will be presented in Section 5.5.
Theorem 5.12 The automaton AV is separated.
Proof. For each q, q' ∈ Q with q /= q', there exists ϕ1 ∈ clos(ϕ) such that q(ϕ1) /=
q'(ϕ1). Since it is not possible that a Σ-trace assigns two different values to the same formula ϕ1, we have Lq(AV ) ∩ Lq' (AV )= ∅.	 
ϕ	ϕ
Evaluating QLtl on Quantitative Transition Systems
Consider a quantitative transition system £ = (Σ, S, δ, [·]) and a QLtl formula ϕ. We aim at computing [ϕ]](s) for a state s ∈ S. We first propose the following definition.
Definition 5.13 Consider a QTS £ = (Σ, S, δ, [·]) and a QLtl formula ϕ. Let
Aϕ = (vals (Σ, V(£)), Q, Q0, ρ,F ) be the QLtl-automaton for ϕ and V(£). For

a state
s¯ ∈ S, the
s¯-product of £ and Aϕ, denoted £ × Aϕ, is the automaton

({∅}, Q', Q' , ρ',F '), where:
The alphabet contains only the symbol ∅.
The set of states Q' contains all pairs (s, q) ∈ S × Q which are synchronized w.r.t. the value of the atomic propositions. Formally, for all r ∈ clos (ϕ), [s](r)= q(r).
The set of initial states is given by Q' = ({s¯}× Q0) ∩ Q'.
The set of final states is given by F ' = (S × F ) ∩ Q'.
We have (s', q') ∈ ρ'((s, q), ∅) iff (s, s') ∈ δ.
Our approach to computing [ϕ]](s¯) consists in the following three steps:
We first build the s¯-product £ × Aϕ between the system £ and the QLtl- automaton for ϕ and V(£).
We then compute the set of states Q'' = {(s¯, q) ∈ Q' | L{(s¯,q)}(£ × Aϕ) /= ∅}.
Finally, [ϕ]](s¯)= min(s¯,q)∈Q'' q(ϕ).
As far as the complexity of the above procedure is concerned, it is easy to see that step (ii) dominates the others. Such step consists in determining the set Q'' of states of the product automaton which, used as initial states, give rise to a non- empty language. The classical algorithm for the emptiness of a generalized Bu¨chi

automaton can be easily adapted to compute the set Q'' in time linear in the size of the product (precisely, in the number of edges in the product). We thus obtain the following theorem which states that the model checking procedure for QLtl is not more expensive than the one for model checking Ltl.
Theorem 5.14 Given a QLtl-formula ϕ, a QTS £ = (Σ, S, δ, [·]), and a state
s ∈ S, the value [[ϕ]](s) can be computed in time O(|δ|· |V(£)||clos(ϕ)|).
Notice that, unlike the Ltl case, our evaluation procedure does not need to complement a Bu¨chi automaton or a QLtl formula.
Evaluating QLtl on Quantitative Markov Chains
In this section, we consider the model checking problem for QLtl over quantitative Markov chains. We will show that this problem can be reduced to the model checking problem for Ltl over Markov chains.
Consider a QMC £ = (Σ, S, Δ, [·]) and a QLtl formula ϕ on Σ. We aim at computing Es[[[ϕ ]] for a state s ∈ S. Assuming that V(£)= {b1, b2,... , bn}, recall that we denote by Prs[[[ϕ]] = bi] the probability for the value of the random variable [[ϕ]] to be bi on the probability space generated by the traces starting at s. We have
[[ϕ]](s)= Es[[[ϕ]]] = Σ bi · Prs[[[ϕ]] = bi].
i=1
Consequently, to compute [ϕ]](s), it is sufficient to compute for each value bi ∈ V(£) the probability for the value of the random variable to be bi. More precisely, given the set of Σ-traces Tbi = {σ ∈ trac(£) | [[ϕ]](σ) = bi} and the probability space (trac(s), У, Prs) given by £ and s, we aim at computing Prs(Tbi ). For this, we recall the following theorem (see [11] for a proof).
Theorem 5.15 Consider a QMC £ = (Σ, S, Δ, [·]), a state s ∈ S, and the prob- ability space (trac(s), У, Prs) given by £ and s. Let T be a set of Σ-traces. If T can be represented by a deterministic Rabin automaton with n states, then one can compute Prs(T ) in time polynomial in |S|· n.
We thus need to provide a deterministic Rabin automaton Aϕ=bi accepting Tbi , for each bi. Working with a deterministic Rabin automaton is needed not to break the deterministic behavior of Markov chain (see [11]). The automaton Aϕ=bi can easily be obtained from the automaton Aϕ. Indeed, it suffices to remove from the set of initial states of Aϕ all the states that do not assign the value bi to ϕ. We obtain a generalized Bu¨chi automaton, which can be turned into a deterministic Rabin one whose size is exponentially larger (see Theorem 2.1).
The result above involves a double exponential, which is due to the fact that we build a generalized Bu¨chi automaton for the formula (whose size is exponential in the size of the formula), and then turn it into a deterministic Rabin one (whose size is again exponential in the size of the Bu¨chi). However, in [12], it is showed that one can avoid the exponential blow-up needed to compute the deterministic

Rabin automaton, when the generalized Bu¨chi automaton representing the formula is separated. Observe that since the automaton Aϕ is separated, any automaton Aϕ=bi will also be separated. We can thus use the result from [12] to avoid one exponential blow-up. The resulting algorithm is polynomial in the size of the QMC and singly exponential w.r.t. the formula.
Remark 5.16 The result in [12] additionally requires automata to be unambigu- ous. An automaton is unambiguous if two transitions that start in the same state and have the same label reach different destinations. This property is satisfied by our automata by definition. In conclusion, the automaton Aϕ is separated and unambiguous. Moreover, this property does not depend on the set of initial states.

Extensions and Open Problems
This section discusses several extensions of QLtl model checking. First, we de- scribe how our QLtl model checking algorithm can be extended to an algorithm for QCtl∗. Then, we present a partial solution to the model checking problem for a discounted version of QLtl. Finally, model checking the long-run average operator and quantitative Markov decision processes remain completely open.

From QLtl to QCtl∗
Having considered the branching logic DCtl in [6] and the linear logic QLtl in this paper, it is natural to consider logic QCtl∗, which extends QLtl with path quantifiers ∃ and ∀. The syntax of QCtl∗ is the same as the one of Ctl∗. The semantics of a QCtl∗ formula is defined with respect to the system on which it is evaluated. Consider a QCtl∗ formula ϕ.
If the formula is evaluated for a state s of a quantitative transition system £, then the operators ∀ and ∃ represent the inf-evaluation-over-all and the sup-evaluation- over-all traces, respectively. Formally, [∀ϕ]](s) = inf{[[ϕ]](σ) | σ ∈ trac(s)}, and [[∃ϕ]](s)= sup{[[ϕ]](σ) | σ ∈ trac(s)}. Observe also that [∃ϕ]](s)=1 — [[∀чϕ]](s).
When considering quantitative Markov chains, following [6], we interpret both ∀ and ∃ as the expected value operator. Therefore, on QMCs, QCtl∗ essentially coincides with QLtl.
Evaluating QCtl∗ formulas with only one path quantifier is immediate. Indeed, the automata-based algorithm presented in Section 5.4 allows us to immediately evaluate formulas of the form ∃ϕ. Observing that [∃ϕ]](s)= 1 — [[∀чϕ]](s), we get the result. When considering formulas with several path quantifiers, one recursively replaces each quantified subformula with a new atomic proposition that represents its value (using again the automata-based algorithm). We thus have the following complexity result.
Theorem 6.1 Consider a QTS £ = (Σ, S, δ, [·]), a state s ∈ S, and a QCtl∗- formula ϕ. The value [[ϕ]](s) can be computed in time O(|ϕ|· |£|· |V(£)||clos(ϕ)|).

Recall from Theorem 5 of [6] that a formula ϕ from the logic DCtl can be
evaluated on a QTS £ in time O(|S|2 · |ϕ|). It follows that QLtl formulas which do not contain nesting of linear operators can be evaluated in the same time. As a side note, it should be noted that DCtl does not feature an until operator. However, it is our belief that its addition would not increase the complexity of model checking the logic. We therefore observe, as expected, that ad-hoc algorithms for dealing directly with  and  operators are definitely more efficient than the present automata- based algorithms, which on the other hand is capable of treating arbitrary nesting of temporal operators.

Discounting
The logics in [6] use discounting, meaning that values in the near future weigh more than values in the far future. Given a discount factor α ∈ [0, 1], discounted versions
。α,  α, and  α of the next, eventually, and always operator are defined below.
There is a second next operator ^。α, which is the dual of 。α
[[ 。αϕ]](σ)= α[[ϕ]](σ1)	[  αϕ]](σ)= supi≥0 αi[[ϕ]](σi)
[[ ^。αϕ]](σ)= 1 — α + α[[ϕ]](σ1)	[  αϕ]](σ)= infi≥0 1 — αi(1 — [[ϕ]](σi)).
Just as for the next operator, one should consider two discounted variants Cα and

C^ α of C (and also two for
[[ϕ Cαψ]](σ) = [ψ]](σ) H
C˜)

supi>0 α0[[ϕ]](σ0) H α1[[ϕ]](σ1) H ··· H αi−1[[ϕ]](σi−1) H αi[[ψ]](σi)
[[ϕ C^ αψ]](σ) = [ψ]](σ) H supi>0 1 — α0(1 — [[ϕ]](σ0)) H 1 — α1(1 — [[ϕ]](σ1)) H ... 
H 1 — αi−1(1 — [[ϕ]](σi−1)) H 1 — αi(1 — [[ψ]](σi)).

For ψ1 Cαψ2, we have [ψ1 Cαψ2]](σi)= [ψ2]](σi) H ([[ψ1]](σi) H [[ 。α(ψ1 Cαψ2)]](σi)) and thus the following labeling rule.
γi(ψ2) H (γi(ψ1) H α · γi+1(ψ1 C ψ2)).

The other until operators can be treated similarly. It is important to realize that no Bu¨chi conditions are needed for α < 1: in the undiscounted case, the recursive characterization ψ1 C ψ2 ≡ ψ2 V (ψ1 Λ 。(ψ1 C ψ2)) for C has two fixed points and one needs the smallest. If α < 1, then the underlying operators are contractions and have unique fixed points.
The analogon of Theorem 5.1 does not hold in the case of discounting. Simple examples show that, given a QTS £, the set of values Vα(£)= {[[ϕ]](£) | ϕ is a QLtl formula with discount factor α} is in general infinite. However, by performing the construction of Definition 5.9 with V being an inﬁnite subset of [0, 1], one can build an infinite-state Bu¨chi automaton with the property of Theorem 5.11. In other words, the Bu¨chi construction works for discounting, but we cannot use it

for model checking, since it yields an infinite-state automaton. Alternative model- checking methods should therefore be investigated, e.g. based on approximation.
Long-run Average Operator
The branching logic DCtl of [6] also contains the path operator Δ (“triangle”). This operator stands for the long-run average of a quantitative proposition and is defined by:


[[Δϕ]](σ) = lim
n→∞
[[ϕ]](σ0)+ [[ϕ]](σ1)+ ··· + [[ϕ]](σn−1)
.
n

Such operator does not fit well with the finite automata-based approach, since the value of a Δp formula in general does not coincide with the value of the proposition p in any state of the system: for instance, any number in [0, 1] can be obtained as the long run average of a sequence whose propositional values are {0, 0.1, 0.2 ... 0.9}.
Thus, it remains open whether the Δ operator can be evaluated on a system by automata-theoretic means.
Model checking QLtl over Quantitative Markov Decision Processes
A Quantitative Markov Decision Process (QMDP) is a Markov decision process (MDP) with quantitative values in the states. Thus, a QMDP can be viewed as a QMC combined with nondeterminism, i.e. each QMDP state enables one or more transitions whose target state is determined probabilistically. Formally, a QMDP
£ = (Σ, S, Δ, [·]) contains the same ingredients as a QMC, except that the transition relation is a function Δ : S → 2D(S) such that Δ(s) /= ∅ for each s ∈ S. Each QMDP induces a QTS (Σ, S, δ, [·]), where δ = {(s, t) ∈ S2 | Eμ ∈ Δ(s) . μ(t) > 0}. Definitions for paths and traces in a QMDP are identical to those for the corresponding QTS.
A scheduler for £ resolves the non-deterministic choices in £. Schedulers can be (1) history-dependent, i.e. they may base their decisions on the history of the system, and (2) randomized, i.e. they may make a probabilistic choice over the outgoing transitions in each state. More precisely, a scheduler for £ in a state s0 is a function π : pts (s0) → Ð(Ð(S)) such that if π(s0s1 ... sn)(μ) > 0, then μ ∈ Δ(sn). We denote the set of all schedulers in s0 by Sched (s0). Each scheduler π in state
s defines a probability space over Уπ = (tracπ(s), Уπ, Prπ), where Уπ is the set of
s	s
measurable subsets of tracπ(s), and Prπ is the uniquely induced probability measure
over Уπ. We denote the expected value of a random variable X over Уπ by Eπ[X].
s	s
We interpret QLtl over QMDPs by taking the minimum expected value over all schedulers, i.e. we set [ϕ]](s)= infπ∈Sched (s) Eπ[[[ϕ]]].
Unfortunately, contrary to the case of Markov chains, we cannot directly ex-
tend the algorithm for Ltl model checking over MDPs [1,2,25]: we could, for
each value bi run an Ltl-inspired algorithm that finds the minimum probability minπ∈Sched Prπ[[[ϕ]] = bi] with which the value bi is attained. However, the QMDP

model checking problem asks for the global minimum, i.e. minπ∈Sched Σn	bi ·
Prπ[[[ϕ]] = bi], which cannot be found by solving the model checking problem for the bi’s separately 1 . We did not find a way to solve this global minimization prob- lem based on Ltl model checking. Thus, the QLtl model checking problem over QMDPs is open.
Conclusion and Future Work
In this paper, we extended the work done in [6], by presenting a quantitative linear temporal logic and showing how such logic can be model-checked (i.e., evaluated) over non-deterministic or probabilistic systems, by using a classical automata-based approach. We have provided partial solutions to the model checking problem for QCtl∗, and over quantitative Markov decision processes. Model checking of the long run average operator and the discounted version of QLtl is open.
Apart from the directions mentioned in Section 6, it is also worthwhile to inves- tigate an extension of the results presented in this paper (and in [6]) to continuous time or interval Markov chains. Another promising research direction consists in extending the abstract probabilistic frameworks of [16,20] to quantitative logics. We could also investigate whether the alternating automata based construction of [21] extends to the case of QCtl∗. Finally, it would also be of interest to see whether one can reduce the size of the automata we construct following techniques similar to those proposed in [17].

References
L. de Alfaro, Formal Verification of Probabilistic Systems, Phd Thesis, Stanford University, 1997.
L. de Alfaro and A. Bianco. Model Checking of Probabilistic and Nondeterministic Systems, Proc. Int. Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS), Lecture Notes in Computer Science, Volume 1026, 1995, pages 499–513.
R. Alur and D. L. Dill, A theory of timed automata, Theoretical Computer Science, 126(2):183–235, 1994.
L. de Alfaro and T. A. Henzinger and R. Majumdar, Discounting the future in Systems Theory, Proc of ICALP, Lecture Notes in Computer Science, Volume 2719, 2003, pages 1022–1037.
L. de Alfaro and M. Faella and M. Stoelinga, Linear and Branching Metrics for Quantitative Transition Systems, ”Proc. Int. Colloquium on Automata, Languages and Programming (ICALP), Lecture Notes in Computer Science, Volume 3142, 2004, pages 97–109.
L. de Alfaro and M. Faella and T. A. Henzinger and R. Majumdar and M. Stoelinga, Model checking discounted temporal properties, Theoretical Computer Science, volume 345, number 1, 2005, pages 139–170.
L. de Alfaro and R. Majumdar and V. Raman and M. Stoelinga, Game Relations and Metrics, Proc. IEEE Symposium on Logic in Computer Science (LICS), IEEE, 2007, pages 99–108.
F. van Breugel and J. Worrel, Towards quantitative verification of probabilistic systems, Proc. 28th Int. Colloq. Aut. Lang. Prog., volume 2076 of Lect. Notes in Comp. Sci., pages 421–432. Springer-Verlag, 2001.
M. Chechik and B. Devereux and A. Gurfinkel, Model-Checking Infinite State-Space Systems with Fine-Grained Abstractions Using SPIN, Proc. of SPIN Workshop on Model-Checking Software, 2001.

1 Indeed, since the minimal probability for each of the bi’s could be computed with a different scheduler, the sum of all the probabilities could be greater than 1, which breaks the definition of the expected value.


F. Ciesinski and C. Baier, LiQuor: A tool for Qualitative and Quantitative Linear Time analysis of Reactive Systems, Proc. Int. Conference on the Quantitative Evaluaiton of Systems (QEST), IEEE, 2006, pages 131–132.
F. Ciesinski and M. Gr¨oßer, On Probabilistic Computation Tree Logic, Validation of Stochastic Systems
- A guide to Current Research, Lecture Notes in Computer Science, volume 2925, 2004, pages 147–188.
J-M. Couvreur and N. Saheb and G. Sutre, An Optimal Automata Approach to LTL Model Checking of Probabilistic Systems, Proc. Int. Conference on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR), LNAI, Volume 2850, 2003, pages 361–375.
C. Courcoubetis and M. Yannakakis, The Complexity of Probabilistic Verification, Journal of the ACM, Volume 42(4), 1995, pages 857–907.
J. Desharnais, V. Gupta, R. Jagadeesan, and P. Panangaden, Approximating labelled markov processes, Information and Computation, 2002.
J. Esparza and A. Kucera and R. Mayr, Model Checking Probabilistic Pushdown Automata, Proc. 5th Symposium on Logic in Computer Science (LICS), IEEE, 2004, pages 12–21.
H. Fesher and M. Leucker and V. Wolf. Don’t know in Probabilistic Systems, Proc. Int. Spin Workshp, Lecture Notes in Computer Science, Volume 3925, 2006.
R. Gerth and D. Peled and M. Y. Vardi and P. Wolper, Simple on-the-fly automatic verification of linear temporal logic, Proc. Int. Symposium on Protocol Specification, Testing and Verification, IFIP Conference Proceedings, Volume 38, 1995, pages 3–18.
H. Hansson and B. Jonsson, A logic for reasoning about time and reliability, Formal Aspects of Computing, 6(5):512–535, 1994.
T. A. Henzinger, The theory of hybrid automata, Proc. IEEE Symposium on Logic in Computer Science (LICS), New Brunswick, New Jersey, 1996.
M.Z. Kwiatkowska and G. Norman and D. Parker, Game-based Abstraction for Markov Decision Processes, Proc. Int. Conference on the Quantitative Evaluaiton of Systems (QEST), IEEE, 2006, pages 157–166.
O. Kupferman and M. Y. Vardi and P. Wolper, An automata-theoretic approach to branching-time model checking, Journal of the ACM, volume 47, number 2, 2000, pages 312–360.
R. McNaughton, Testing and Generating infinite sequences by a finite automaton, Information and control, 1966, pages 521–530.
A. Pnueli, The Temporal Logic of Programs, Proc. Annual Symposium on Foundations of Computer Science (FOCS), 1977, pages 46–57.
S. Safra, Complexity of Automata on Infinite Objects, Phd Thesis, Weizmann Institute of Science, 1989.
M. Y. Vardi, Automatic Verification of Probabilistic Concurrent Finite-State Programs, Proc of FOCS, IEEE, 1985, pages 327–338.
M. Y. Vardi, Probabilistic Linear-Time Model Checking: An Overview of the Automata-Theoretic Approach, Proc of Int. AMAST Workshop, Lecture Notes in Computer Science, Volume 1601, 1999, pages 265–276.
M. Y. Vardi, The Bu¨chi Complementation Saga, Proc. Int. Annual Symposium on Theoretical Aspects of Computer Science, Lecture Notes in Computer Science, Volume 4393, 2007, pages 12-22.
M. Y. Vardi and P. Wolper, An Automata-Theoretic Approach to Automatic Program Verification (Preliminary Report), Proc. IEEE Symposium on Logic in Computer Science (LICS), IEEE, 1986, pages 332–344.
P. Wolper, Constructing Automata from Temporal Logic Formulas: A Tutorial, Proc of European Educational Forum: School on Formal Methods and Performance Analysis, Lecture Notes in Computer Science, Volume 2090, 2000, pages 261–277.
