Electronic Notes in Theoretical Computer Science 44 No. 4 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume44.html 23 pages


Representation and Execution of Petri Nets Using Rewriting Logic
as a Unifying Framework


Mark-Oliver Stehr, Jos´e Meseguer, and Peter Csaba
O¨ lveczky

Computer Science Laboratory, SRI International, Menlo Park, CA 94025, USA


Abstract
We give a high-level overview of our recent results which extend and unify the lines of research initiated by Meseguer and Montanari under the motto “Petri nets are monoids”, and by Marti-Oliet, Meseguer and other authors in their linear logic ax- iomization of Petri nets. In particular, we investigate the use of rewriting logic, which was partially inspired by the two aforementioned approaches, as a unify- ing semantic framework for different Petri net models. To this end, we equip place/transition nets with a rewriting semantics which is sound and complete in the strong categorical sense of a natural isomorphism between the Best-Devillers process semantics and the semantics obtained via rewriting logic. In addition to place/transition nets we consider algebraic net specifications which subsume col- ored Petri nets and we show how a corresponding sound and complete rewriting semantics can be established at this level. Furthermore, we discuss how rewriting logic can be used to represent other important extensions of the basic Petri net model such as place/transition nets with test arcs and timed Petri nets. Apart from the conceptual unification of different models in a field which has to cope with increasing diversity, this work has interesting practical applications ranging from the execution and analysis of Petri net models, using a rewriting engine such as Maude, to formal verification taking advantage of the logical side rather than the operational side of rewriting logic.

Introduction
In this paper we give a high-level overview of our recent results [51] which at- tempt to contribute to the general goal of unifying Petri net models by study- ing in detail the unification of a wide range of such models within rewriting logic [42]. Using rewriting logic as a logical and semantic framework, we show how place/transition nets, nets with test arcs, algebraic net specifications, col- ored Petri nets, and timed Petri nets can all be naturally represented. Our work extends in substantial ways previous work on the rewriting logic repre- sentation of place/transition nets [42], nets with test arcs [43], algebraic net specifications [62], and timed Petri nets [56].
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


The representations in question associate a rewrite specification to each net in a given class of Petri net models in such a way that concurrent computations in the original net naturally coincide with concurrent computations in the associated rewrite specification. That is, we exhibit appropriate bijections between Petri net computations and rewriting logic computations, viewed as equivalence classes of proofs, that is, as elements of the free model associated to the corresponding rewrite specification [42].
Furthermore, for certain classes of nets, namely place/transition nets and a general form of algebraic net specifications, which subsume the well-known class of colored Petri nets, we show that the representation maps into rewriting logic are functorial; that is, that they map in a functorial way net morphisms to rewrite specification morphisms. In addition, such functorial representations can be further extended to the level of semantic models, yielding semantic equivalence theorems (in the form of natural isomorphisms of functors) be- tween well-known semantic models for the given class of Petri nets and the free models of the corresponding rewrite theories or, more precisely, models obtained from such free models by forgetting some structure.
As we further explain in the body of the paper, this work, including the above-mentioned functorial semantics and the semantic equivalences, gener- alizes in some ways, and complements in others, a substantial body of work initiated by the second author in joint work with Ugo Montanari under the motto “Petri nets are monoids” [46,39,40,49,18,47,48,50,10,11], in which cate- gorical models are naturally associated as semantic models to Petri nets, and are shown to be equivalent to well-known “true concurrency” models. Our work is also related to linear logic representations of Petri nets [39,40,3,9,8,22]. All this is not surprising, since, as explained in [42], both the categorical place/transition net models of [46] and the linear logic representations of place/transition nets inspired rewriting logic as a generalization of both for- malisms. But, as shown in this paper, the extra algebraic expressiveness of rewriting logic is very useful to model in a simple and natural way not only place/transition nets, but also high-level nets, such as algebraic net specifica- tions, colored Petri nets, and timed Petri nets.
Our proposed unification of Petri net models is not only of conceptual interest. Given that, under reasonable assumptions, rewrite theories can be executed, the representation maps that we propose provide a uniform opera- tional semantics in terms of efficient logical deduction. Furthermore, using a rewriting logic language implementation such as Maude [17,16], or the Real- Time Maude tool in the timed case [55,54], it is possible to use the results of this paper to create execution environments for different classes of Petri nets. In addition, because of Maude’s reflective capabilities [15], the Petri nets thus represented cannot only be executed, but they can also be formally analyzed and model checked by means of rewriting strategies that explore and ana- lyze at the metalevel the different rewriting computations of a given rewrite specification.

The purpose of this paper is to introduce the main ideas, concepts and results of our work in a somewhat informal style and with no proofs. For a much more detailed presentation we refer the reader to [51].


Preliminaries
Membership Equational Logic
Membership equational logic (MEL) [7,44] is a many-sorted logic with subsorts and overloading of function symbols. It can express partiality very directly by defining membership in a sort by means of membership equational conditions. In accordance with the terminology introduced in the references above we refer to the types in the logic as kinds, and we view the sorts for each kind as unary predicates. The atomic sentences are equalities M = N for terms M ,N of the same kind, and memberships M : s for M a term and s a sort, both of the same kind. Sentences of MEL are universally quantified Horn clauses on the atoms. In contrast to an entirely loose or entirely initial semantics of member- ship equational theories, in practice a mixed specification style is used, where certain subtheories are intended to be equipped with initial interpretations, or they are interpreted freely over their parameter specifications. To make such restrictions on the models explicit in the specification we enrich a member- ship equational theory by initiality and freeness constraints [20,30], and refer to this enriched theory as a membership equational logic specification (MES). MESs together with their morphisms form a category MES. Given a MES S we also have the category of S-algebras Mod(S). Each MES morphism H : S → S' induces an obvious forgetful functor Mod(H ): Mod(S') → Mod(S) that we also write as UH . In fact, we have a contravariant functor Mod : MES → Catop.
Given a MES S, the operational semantics [7], that can be used to effi- ciently execute a specification under certain assumptions, is explained using a refinement of S, namely by viewing ES as being composed of a set ES of struc-
tural axioms and a set EC of computational axioms, i.e., E = ES  EC . The
S	S	S

equations in EC
can be seen as reduction rules that operate modulo the equa-

tional theory induced by ES . In order for a MES to be efficiently executable we impose certain restrictions concerning variables as well as confluence, ter- mination, sort-deceasingness and regularity [7].

Rewriting Logic
In the simplified setting of [42] a rewrite specification R consists of a single- sorted signature ΩR,a set ER of equations over ΩR, and a set RR of labelled
rewrite rules of the form ∀ X . l : M → N if φ¯1 ∧ ... ∧ φ¯n , where l is a

label, M and N are ΩR-terms, and φ¯1 ∧ ... ∧ φ¯n is a ΩR-condition 1 over the variable set X . The rewrite rules in RR are applied modulo the equations ER. Rewriting logic (RWL) has rules of deduction to infer all rewrites, i.e., those sentences of the form P : M → N that are valid in a given rewrite specification [42]. A rewrite P : M → N means that the term M rewrites to the term N modulo ER, and this rewrite is witnessed by the proof term P . Apart from general (concurrent) rewrites P : M → N that are generated from identity and atomic rewrites by parallel and sequential composition, rewriting logic classifies its most basic rewrites as follows: a one-step (concurrent) rewrite is generated by parallel composition from identity and atomic rewrites and contains at least one atomic rewrite, and a one-step sequential rewrite is a one-step rewrite containing exactly one atomic rewrite.
From a more general point of view, rewriting logic is parameterized by the choice of its underlying equational logic, which can be single-sorted, many- sorted, order-sorted and so on. In the design of the Maude language [17,16], membership equational logic has been chosen as the underlying equational logic. To introduce rewriting logic over membership equational logic, abbre- viated as RWLMEL or just RWL, we assume an underlying MES SR with a distinguished data subspecification S D . The data subspecification specifies the static data part of the system, whereas the remaining part of SR specifies the state space by introducing the rewrite kinds, i.e., kinds not already contained

in SD
whose terms correspond to states and therefore can be rewritten, to-

gether with their algebraic structure, which characterizes the possibilities of parallel composition. In the context of this paper the state space is always specified in a purely equational way. More precisely, a rewrite specification (RWS) R consists of a MES SR with a distinguished data subspecification SD , a set of labels LR, and a set of rules RR of the form ∀ X . l : M →
N if φ¯1 ∧ ... ∧ φ¯n where l ∈ LR, φ¯1 ∧ ... ∧ φ¯n is a SR-condition over X
and M , N ∈ TR(X )k in SR for a rewrite kind k . To simplify the exposition
we identify either ER-equivalent or ES -equivalent terms in the context of a RWS R whenever we are concerned with the algebraic semantics or the oper- ational semantics, respecively. A RWS morphism H : R → R' consists of a MES morphism HS : SR → SR' and a function HL : LR → LR' such that HS has a restriction HD : SD → SD' to the data subspecification and for each rule
R	R
r ∈ RR there is a rule in RR' that is ER' -equivalent to H (r ) up to a renam-
ing of the variables, where H is lifted to rules in the obvious homomorphic way. RWSs together with their morphisms form a category that is denoted by RWS.
The algebraic semantics of rewriting logic is defined as follows. A model of a rewrite specification (RWS) R is a model A of the underlying MES SR together with an enriched categorical structure for each set [k ]]A, where k is a rewrite kind. The interpretation of  :  → , which can be regarded

1 Rewriting logic as presented in [42] admits rewrites in conditions of rules, but we do not exploit this possibility in the present paper.


as a ternary predicate, is given by the arrows of the category. Sequential composition of rewrite proofs is interpreted by arrow composition, and par- allel composition operators are interpreted by enriching the category with an algebraic structure as it has been specified for the rewrite kinds in SR. In order to be a model, the category has to satisfy a number of natural require- ments, namely, functoriality w.r.t. the algebraic structure that is relevant for the rewrite kinds, the equations in SR that are relevant for the rewrite kinds lifted to arrows, and for each rule of R the so-called exchange and decom- position laws. For a detailed description of these requirements we refer to [42]. The models of a RWS we consider in this paper are freely generated over
models of the data subspecification S D . In the important case where SD is
R	R
interpreted initially, we obtain precisely the initial model described in [42].
The operational semantics of RWSs extends the operational semantics of
MESs by applying both the equations EC and rewrite rules RR modulo the
structural equations ES . In order for a rewrite specification to be efficiently executable we require that the underlying MES is executable and we impose a coherence requirement between equations and rules as explained in [51,68]. In fact, rewrite specifications satisfying this requirement can be executed using Maude.

Place/Transition Nets
We now give formal definitions of basic nets and define a PTN as a particular form of an inscribed net. Instead of just finite nets we admit infinite nets, but we restrict our attention to nets with transitions that can affect only a finite part of the marking (locality principle) so that each transition can be represented in a finitary way.
A net N consists of a set of places PN ,a set of transitions TN disjoint from PN , and a flow relation FN ⊆ (PN × TN ) ∪ (TN × PN ) such that •t = {p | p FN t } and t • = {p | p FN t } are finite for each t ∈ TN (local finiteness). A net is finite iff the sets PN and TN are finite. Given nets N and N ', a net morphism H : N → N ' consists of functions HP : PN → PN ' and HT : TN → TN ' such that HP (•t )= •HT (t ) and HP (t •)= HT (t )•. Nets together with their morphisms form a category Net. A place/transition net (PTN) N consists of: (1) a net NN and (2) an arc inscription WN : FN →  . WN is extended to WN : (PN × TN ) ∪ (TN × PN ) → in such a way that (x , y ) ∈/ FN implies WN (x , y ) = 0. Given PTNs N and N ', a PTN morphism H : N → N ' is a net morphism H : NN → NN ' such that WN ' (p', t ') = WN (p1, t )+ ... + WN (pn, t ) holds for all p' ∈ PN ' , t ' ∈ TN ' , t ∈ H −1(t '), and {p1,..., pn} = H −1(p') ∩ •t with distinct pi , and the obvious similar condition also holds for WN ' (t ', p'). PTNs together with their morphisms form a category PTN.
The notion of net morphism we use here is more restrictive than the (topo- logical) net morphisms used in [57] and close to, but slightly stronger than, the (algebraic) net morphisms used in [46]. The justification for our definition

is that net morphisms should be morphisms in the sense of [57], and should preserve the behaviour in the strongest reasonable sense possible.
Let N be a PTN.A marking is a multiset of places. A (concurrent) step is a nonempty finite multiset of transitions. The set of markings and the set of steps of N are denoted by MN and ST N , respectively. We define preset and postset functions ∂0, ∂1 : TN → MN by ∂0(t )(p) = W (p, t ) and ∂1(t )(p) = W (t, p), respectively. The (concurrent) step semantics of a place/transition net N is given by the labelled transition system which has MN as its set of states, ST N as its set of labels and a transition relation → ⊆ MN × ST N ×
e
MN defined by m1 →− m2 iff there is a marking m such that, for all p ∈ PN ,
m1(p)= m(p)+∂0(e)(p) and m2(p)= m(p)+∂1(e)(p). Writing the occurrence rule in the way given above makes it evident that the occurrence of an action replaces its preset by its postset, whereas the remainder of the marking, here denoted by m, is not involved in this process. This is an important fact that is made formally explicit in the classical process semantics and in the more abstract Best-Devillers process semantics [6]. The latter is the semantics that we use in this paper since it reflects the collective token philosophy [10] according to which all our equivalence results are stated.
A (strict) monoidal category (MC) C is a category equipped with a monoidal operation	⊗C	and an identity object id C such that	⊗C	is an associative bifunctor with left and right identity id C. A monidal category morphism h : C → C is a functor that preserves	⊗		and id , i.e., h(u ⊗C v ) = h(u) ⊗C' h(v ) and h(id C)= id C' . If in addition	⊗	is commutative, then we have a (strictly) symmetric (strict) monoidal category (SMC).The category of SMCs is denoted by SMC. The Best-Devillers process semantics BDP(N ) of a PTN N is given by an SMC that has markings as objects and Best-Devillers processes as arrows. Arrow composition is given by sequential composition, the monoidal operation is given by parallel composition, and the identity for an object m is given by the Best-Devillers process without transitions with origin m and destination m. BDP is extended to a functor BDP : PTN → SMC [12].

Rewriting Semantics
Rewriting logic can provide a direct semantics of PTNs following the motto “Petri nets are monoids” advocated in [46]. In fact, the categorical semantics presented in that work and also the relation between PTNs and linear logic explained in [40] inspired the development of rewriting logic.
As an example consider the PTN modeling an instance of the well-known banker’s problem depicted in Fig. 1, which models the situation of a bank loaning money to (in this case two) clients. This PTN can be represented by the following RWS given in Maude syntax [17,16], which consists of a MES specification and a set of rewrite rules. As usual in Maude, the rewrite kind [Marking] is implicitly introduced by introducing a sort Marking of this kind.


BANK 3
2
3


GRANT-1
RETURN-1
GRANT-2	RETURN-2



3	2
3	2

3	2


CREDIT-1	CLAIM-1
CREDIT-2
CLAIM-2

Fig. 1. Banker’s problem with two clients

sort Marking .

op empty : -> Marking .
op   : Marking Marking -> Marking [assoc comm id: empty] . ops BANK CREDIT-1 CREDIT-2 CLAIM-1 CLAIM-2 : -> Marking . rl [GRANT-1]	: BANK CLAIM-1 => CREDIT-1 .
rl [RETURN-1] : CREDIT-1 CREDIT-1 CREDIT-1 =>
BANK BANK BANK CLAIM-1 CLAIM-1 CLAIM-1 . rl [GRANT-2]	: BANK CLAIM-2 => CREDIT-2 .
rl [RETURN-2] : CREDIT-2 CREDIT-2 =>
BANK BANK CLAIM-2 CLAIM-2 .

Here we have applied the translation of PTNs into rewriting logic suggested in [42], which is closely related to the translation of PTNs into linear logic [40]. A marking is represented as an element of the finite multiset sort Marking. The constant empty represents the empty marking and    is the corresponding multiset union operator. Associativity, commutativity and identity laws are specified as structural equations by the operator attributes in square brackets. For each place p there is a constant p, called token constructor, representing a single token residing in that place. In fact, under the initial semantics Marking is a multiset sort over tokens generated by these token constructors. For each transition t there is a rule, called transition rule, labelled by t and stating that its preset marking may be replaced by its postset marking.
In order to control the execution of a RWS the user can specify a strat- egy which successively selects rewrite rules and initiates rewriting steps. For

instance, in the case of the banker’s example it is possible to define an exe- cution strategy that avoids states which are necessarily leading to a deadlock such that the banker stays always in the “safe” part of the state space. In applications such as net execution and analysis the choice of a strategy will be guided by the need to explore the behaviour of the system under certain conditions. Strategies are well-supported by the Maude engine via reflection [17,16], i.e. the capability to represent rewrite specifications as objects and control their execution at the meta-level, which makes Maude a suitable tool not only for executing Petri nets but also for analyzing such nets using strate- gies for (partial) state-space exploration and model checking.
In general, the rewriting semantics for place/transition nets can be con- ceived as a functor from the category PTN to the category SMRWS of symmetric monoidal RWSs (SMRWSs) that will be introduced next. The characteristic feature of SMRWSs is that their underlying specification has a single rewrite kind [Marking] that is specified to be a free commutative monoid over a set of constants. A RWS R is a symmetric monoidal RWS
(SMRWS) iff the following conditions are satisfied: (1) S D is empty. (2) SR
contains precisely the following: (a) a kind [Marking] together with operator symbols empty : → [Marking],  : [Marking] [Marking] → [Marking]; (b) any number of operator symbols of the general form p : → [Marking]; (c) structural axioms stating that  is associative, commutative and has empty as the identity. (3) Rules in RR do not have conditions and do not con- tain any variables. A SMRWS morphism is a RWS morphism that preserves [Marking], empty and . SMRWSs together with their morphisms form a subcategory of RWS denoted SMRWS.
The rewriting semantics of PTNs is then defined as follows: Given a PTN N the rewriting semantics of N is the smallest SMRWS R(N ) such that: (1) SR(N ) contains a token constructor p : → [Marking] for each place p ∈ PN ;
(2) R(N ) has a label t anda rule calleda transition rule, namely,


t : p1 ... p1
... pm ... pm → p1 ... p1
... pm ... pm

` ˛¸ x
W (p1,t )
`  ˛¸  x	` ˛¸ x
W (pm ,t )	W (t ,p1)
`  ˛¸  x
W (t ,pm )

for each transition t ∈ TN assuming PN = {p1,..., pm } with distinct pi . R can be extended to a functor R : PTN → SMRWS that maps each PTN morphism H : N → N ' to the unique SMRWS morphism G : R(N ) → R(N ') with GL(t )= H (t ) for each t ∈ TN and GS (p)= H (p) for each p ∈ PN .
The main result in this section states that for a PTN N the Best-Devillers process semantics BDP(N ) coincides with the initial semantics of R(N ) in the strongest possible categorical sense of a natural isomorphism. This theorem is closely related to Corollary 33 in [18], which states that the presentation of an SMC denoted by T (N ) provides a complete and sound axiomatization of Best- Devillers processes. T (N ) is given by a direct inductive equational definition, whereas here we use a rewriting logic as a formal specification language to express the same category. Below we use a functor V ◦ ΣI : SMRWS →


SMC, where ΣI sends an SMRWS to its initial model, and V forgets the algebraic structure that is beyond a SMC.
Theorem 3.1 There is a natural isomorphism τ^ : BDP → V◦ΣI◦R between the functors BDP : PTN → SMC and V ◦ ΣI ◦ R : PTN → SMC.
Corollary 3.2 The rewrite specification R(N ) provides a sound and complete axiomatization of the Best-Devillers processes of the PTN N .

Petri Nets with Test Arcs
In this section we illustrate how the techniques for giving a rewriting logic semantics to place/transition nets can be extended to deal with the important class of place/transition nets with test arcs [14,52,69,13]. Petri nets have been equipped with test arcs (also called read arcs, or positive contexts in contextual nets [52]) to naturally model cases where a certain resource may be read without being consumed by a transition.
Formally, a place/transition net with test arcs N is a place/transition net together with a set of test arcs TAN ⊆ PN × TN . We define the context function ∂TA : T ⊕ →M on finite multisets e of transitions by ∂TA(e)(p)=1 if there is a transition t ∈ e with (p, t ) ∈ TAN , and by ∂TA(e)(p) = 0 otherwise. The step semantics of a place/transition net with test arcs is defined as for
place/transition nets (see Section 3) with the modification that for m1 → m2
to hold we require additionally that, for each place p ∈ PN , ∂TA(e)(p) ≤
m(p).
We propose a rewriting semantics for a place/transition net with test arcs, defined in terms of a rewrite specification R(N ) similar to the one in Sec- tion 3.1, but specifying tokens by means of a kind [Place] and two operators [ ], ⟨ ⟩ : [Place] → [Marking], so that a token residing at place p is repre- sented by the term [p]. An occurrence of [p] may not be shared by more than one rewrite at the same time; to allow simultaneous rewrites with read- only access to a token at place p, we consider a token [p] to be equivalent to an arbitrary number of read-only tokens of the form ⟨p⟩. This can be ac- complished, using a technique described in [43], by adding to our specification R(N ) an operator { | } : [Marking] [Nat] → [Marking] and two “copying” axioms 2 [p] = {p |0} and {p |n} = {p |n +1}⟨p⟩, where p and n are variables ranging, respectively, over [Place] and [Nat].
A transition t which consumes the tokens a1,..., an , produces the tokens
b1,..., bm, and “reads” the tokens c1,..., ck , is modeled by a rewrite rule
t : [a1] ... [an] ⟨c1⟩ ... ⟨ck ⟩ −→ [b1] ... [bm] ⟨c1⟩ ... ⟨ck ⟩.

2 The counting of the read-only copies and their read-only use guarantee that all the copies must have been “folded back together” in order for the original token to be engaged in a transition that consumes the token.


The resulting categorical semantics of such rewrite specifications is closely related to the one proposed by Bruni and Sassone in [13].

High-Level Petri Nets
We use the term high-level Petri nets to refer to a range of extensions of PTNs by individual tokens, a line of research that has been initiated by the introduction of predicate/transition nets in [28,29,27]. High-level Petri nets make use of an underlying formalism, such as first-order logic in the case of predicate/transition nets, to describe the information that is associated with each token and its transformation. Colored nets 3 introduced in [33] are another quite general model of this kind with a more set-theoretic flavour. They generalize PTNs in such a way that tokens can be arbitrary set-theoretic objects. Quite different from, but closely related to, colored nets are high- level Petri nets that use an algebraic specification language as an underlying formalism [66,5,67,60,58,59,19,4]. In this paper we subsume such approaches under the general notion of algebraic net specifications, parameterized over an underlying equational specification language. The main feature that algebraic net specifications have in common with predicate/transition nets is that an algebraic net specification does not necessarily specify a single colored net, but instead denotes a class of colored nets that satisfy the specification. In the following we first define colored nets, and then we introduce algebraic net specifications over MEL, a straightforward generalization of algebraic net specifications over many-sorted equational-logic (MSA). Both, algebraic net specifications and rewriting logic are specification formalisms that admit a variety of models. From an even more general point of view that is only briefly sketched in this paper, one can define colored net specifications parameterized over an underlying logic. In fact, predicate/transition nets can essentially be regarded as colored net specifications over first-order logic. From this more general point of view we restrict our attention in this paper to the particular class of colored net specifications over MEL, that we also call algebraic net specifications (over MEL), to establish a systematic connection to rewriting logic (over MEL).

Colored Nets and Colored Net Specifications
Algebraic net specifications will be introduced later as a formal specification language for colored nets. In the following we define the most general set- theoretic version of colored nets [33].
Colored nets are nets with places, transitions, and arcs inscribed with additional information given by functions C and W . The color set C (p) of

3 In fact, the nets introduced in [33] are called colored Petri nets (CPNs), but this name has later been used for the more syntactic version introduced in [34], which is also the sense for which we would like to reserve this term (see below).


a place p is the set of possible objects p can carry. The color set C (t ) of a transition t can be seen as a set of modes in which t may occur.	The arc inscription W defines a multiset of objects (“colored” tokens) that are transported by an arc when the associated transition occurs. In fact, this multiset may depend on the mode in which the transition occurs, which is why W (p, t ) and W (t, p) take the form of functions in the definition below. A colored net (CN) N consists of: (1) a finite net NN ; (2) a set of color sets CS N ; (3) a color function CN : PN ∪ TN → CS N ; and (4) an arc inscription WN on FN such that WN (p, t ) : CN (t ) → CN (p)⊕ and WN (t, p) : CN (t ) → CN (p)⊕. WN is extended to a function on (PN × TN ) ∪ (TN × PN ) in such

a way that (p, t ) ∈/
FN implies WN (p, t )(b) = ∅, and (t, p) ∈/
FN implies

WN (t, p)(b)= ∅ for each b ∈ CN (t ). CNs together with suitable morphisms form a category denoted by CN.
Although CNs can be seen as a generalization of PTNs, there is a more fundamental justification for introducing CNs, namely, that a CN is just a convenient abbreviation for a typically rather complex PTN [34,27]. Indeed, this connection can be exploited to lift low-level concepts such as mark- ings, safe processes, and Best-Devillers processes to the higher level. This is achieved by the following flattening functor ( )b : CN → PTN which as- sociates to each CN the PTN obtained by “spatial unfolding.” Given a CN N , we define the flattening N b of N as the unique PTN that satisfies: (1) PN b = {(p, c) | p ∈ PN , c ∈ CN (p)}; (2) TN b = {(t, b) | t ∈ TN , b ∈ CN (t )}; (3) WN b ((p, c), (t, b)) = WN (p, t )(b)(c); and (4) WN b ((t , b), (p, c)) =
WN (t, p)(b)(c) for p ∈ PN , c ∈ CN (p), t ∈ TN , b ∈ CN (t ).
Colored Petri nets, a more syntactic, finitary version of colored nets based on an underlying programming language, are proposed in [34]. A point worth remarking is that this definition leaves open the particular choice of the un- derlying programming language. We use CPNL to abbreviate the class of colored Petri nets over a programming language L.
As a useful concept, we informally introduce colored net specifications (CNS) which capture the essential idea shared by predicate/transition nets and algebraic net specifications, namely, that they denote an entire class of colored nets instead of just a single one. In fact, there is a general concept of CNSs that is parameterized by an underlying logic. A logic has a deductive system and a model-theoretic semantics, a concept that can be formalized by general logics [41] which contain institutions [30] as the model-theoretic com- ponent. We denote by CNSL the class of colored net specifications over the underlying logic L. Possible candidates for L include equational logics such as many-sorted equational logic (MSA), order-sorted equational logic (OSA), or membership equational logic (MEL). We refer to CNSs over such equational logics also as algebraic net specifications (ANS), and we denote by ANSL the class of algebraic net specifications over L. Obviously, there are other possible choices for the underlying logic, such as full first-order logic (as in predicate/transition nets), a version of higher-order logic, or a higher-order

algebraic specification language (as in [32]).

Algebraic Net Specifications
In the following we use the term algebraic net specification (ANS) to specif- ically refer to ANSs over MEL, since MEL is sufficiently expressive to cover other commonly used algebraic specification languages such as MSA and OSA [44]. The use of MEL is particularly attractive, because it is weak enough to admit initial models. Indeed, under the initial semantics (which can be inter- nally specified using constraints in the data subspecification) an ANS denotes a unique CN. Another benefit of the use of membership equational logic is that, under the restrictions mentioned in Section 2.1, it comes with a natural operational semantics (which is actually implemented in the Maude engine) so that it can be used directly as a programming language or, more generally, as a metalanguage to specify the logical and operational semantics of other specification or programming languages. As a consequence, colored Petri nets in CPNL which use L as a programming language can be seen as a special case of algebraic net specifications in ANSMEL if the semantics of L can be specified in MEL.
Due to the fact that MEL generalizes MSA in an obvious way, ANSs over MEL are a straightforward generalization of ANSs over MSA, i.e., many-sorted algebraic net specifications. Disregarding the issue of the underlying specifica- tion language, the definition we give below is equivalent to the one in [36,37], generalizing [58] by so-called flexible arcs, which transport variable multisets of tokens in the sense that the number of tokens transported by an arc is not fixed but can depend on the mode in which the associated transition occurs. An ANS presupposes an underlying specification that has a multiset kind for each place domain. A MES of finite multisets over a kind k consists of:
(1) kinds k and [FMSk ] with operator symbols emptyk : [FMSk ], single : k → [FMSk ],  : [FMSk ] [FMSk ] → [FMSk ]; (2) equational axioms stating that  is associative, commutative and has emptyk as identity; and (3) a constraint stating that this theory is free over k .
The subsequent definition of algebraic net specifications should be regarded as an instance of CNSs over a logic L choosing MEL for L. In fact, the only requirements that L has to meet is that it has a notion of type and that it is expressive enough to axiomatize multisets.
An algebraic net specification (ANS) N consists of: (1) a MES SN ; (2) a finite net NN ; (3) a place declaration, i.e., a function DN : PN → KSN assigning a kind DN (p) to each place p ∈ PN such that SN includes a MES of finite multisets over DN (p); (4) a variable declaration, i.e., a function VN on TN associating to each transition t ∈ TN a kinded variable set VN (t ); (5) an arc inscription, i.e., a function WN on FN such that for p ∈ PN , t ∈ TN , (a)
(p, t ) ∈ FN implies WN (p, t ) ∈ TSN (VN (t ))[FMSD (p)] and (b) (t, p) ∈ FN
implies WN (t, p) ∈ TSN (VN (t ))[FMSD (p)]; and (6) a guard definition, i.e., a 

function GN on TN with GN (t ) being an SN -condition over VN (t ). WN is extended to a function on (PN ×TN )∪(TN ×PN ) such that (p, t ) ∈/ FN implies
WN (p, t ) = emptyDN (p) and (t, p) ∈/ FN implies WN (t, p) = emptyDN (p).
ANSs together with suitable morphisms form a category ANS. An interpreted
ANS IN = (N , A) consists of a ANS N and a SN -algebra A. Interpreted ANSs together with suitable morphisms form a category IANS.
Interpreted ANSs are considerably richer than CNs, since they contain their specification together with a model equipped with a corresponding alge- braic structure. In this sense they are similar to concrete predicate/transition nets [28,29,27] and algebraic high-level nets [21]. In fact, interpreted ANS, concrete predicate/transition nets [26] and algebraic-high-level nets [21] can be regarded as instances of a general notion of interpreted CNSs. 4 The tran- sition from interpreted ANSs to CNs can be described by a forgetful functor as follows.
Given an interpreted ANS (N , A), the CN semantics of (N , A) is given by the CN CN(N , A) defined as follows: (1) the underlying net NCN(N ,A) is precisely NN ; (2) the color function CCN(N ,A) is defined by CCN(N ,A)(p) = [[DN (p)]]A for p ∈ PN and CCN(N ,A)(t )= BN ,A(t ) for t ∈ TN , where BN ,A(t ) is the set of valid bindings, i.e., the set of assignments β : VN (t ) → A satis- fying GN (t ); (3) the set of color sets CS CN(N ,A) is the smallest set that con- tains all CCN(N ,A)(x ) for x ∈ PN ∪ TN ; and (4) the arc inscription WCN(N ,A) is defined by WCN(N ,A)(p, t )(β) = [WN (p, t )]]A,β and WCN(N ,A)(t, p)(β) = [[WN (t, p)]]A,β for p ∈ PN and t ∈ TN . CN is extended to a functor CN : IANS → CN.
We can lift the flattening functor ( )b : CN → PTN to interpreted ANSs, denoting also by ( )b : IANS → PTN the composition ( )b ◦ CN. Using this flattening functor we furthermore can lift BDP : PTN → SMC by defining BDP : IANS → SMC as BDP ◦ ( )b.
Rewriting Semantics
We now define for an arbitrary ANS its associated rewriting semantics and ex- plain in which sense the rewriting semantics is equivalent to the Best-Devillers process semantics of ANSs, which we have defined by lifting the Best-Devillers process semantics of PTNs to ANSs via the flattening construction. First we generalize symmetric monoidal RWSs (SMRWSs) to extended symmetric monoidal RWSs (ESMRWSs) which will serve as a suitable domain for the rewriting semantics. Notice that in ESMRWSs the data subspecification is not required to be empty. A second difference w.r.t. SMRWSs is that token constructors are extended to multisets and place linearity equations are added to reflect the distributed nature of places.
A RWS R is an extended symmetric monoidal RWS (ESMRWS) iff the

4 To be precise, arc inscriptions have to be restricted, since flexible arcs are not available in predicate/transition nets and algebraic high-level nets.



following conditions are satisfied: (1) SR extends SD
by: (a) a new kind

[Marking] and new operator symbols empty : [Marking],  : [Marking] [Marking] → [Marking]; (b) any number of new operator symbols of the

general form p : [FMSk ] → [Marking], where k is a kind in S D
such that

D includes a MES of finite multisets over k ; (c) equational axioms stating
that  is associative, commutative and has identity empty; and (d) the place linearity equations p(emptyk ) = empty, ∀ a, b : [FMSk ] . p(a b) = p(a) p(b) for each operator p : [FMSk ] → [Marking] introduced above. (2) Rules in RR
contain only variables with kinds in S D and have SD -conditions. ESMRWSs
together with suitable morphisms, which preserve [Marking], empty and , form a subcategory of RWS that is denoted by ESMRWS.
An interpreted ESMRWS (R, A) consists of an ESMRWS R and a S D - model A. Interpreted ESMRWSs together with suitable morphisms form a category IESMRWS.
Given an ANS N , the rewriting semantics of N is the smallest ESMRWS
R(N ) with an underlying data specification S D	= SN such that: (1) SR(N )
contains a token constructor p : [FMSDN (p)] → [Marking] for each place p ∈
PN ; and (2) R(N ) has a rule called transition rule, namely,
∀ VN (t ) . t : (p1(WN (p1, t )) ... pm(WN (pm, t ))) →
(p1(WN (t, p1)) ... pm(WN (t, pm ))) if GN (t )
for each transition t ∈ TN , assuming PN = {p1,..., pm} with distinct pi . R can be extended to a functor R : ANS → ESMRWS, which in turn is naturally extended to a functor R : IANS → IESMRWS sending each interpreted ANS (N , A) to the interpreted ESMRWS (R(N ), A).
The theorem and the corollary below are stated in complete analogy to the corresponding results for PTNs. We use a functor V ◦ ΣF : IESMRWS → SMC, where ΣF sends an interpreted ESMRWS (R, A) to its free model over A, and V forgets the algebraic structure that is beyond a SMC.
Theorem 4.1 There is a natural isomorphism τ˜ : BDP → V ◦ ΣF ◦ R
between the functors BDP : IANS → SMC and V ◦ ΣF ◦ R : IANS →
SMC (with R : IANS → IESMRWS and V ◦ ΣF : IESMRWS → SMC).
Corollary 4.2 The interpreted RWS R(N , A) provides a sound and complete axiomatization of the Best-Devillers processes of the interpreted ANS (N , A).

Timed Petri Nets
This section illustrates how an important class of timed Petri nets (see e.g. [1,53,31]), namely interval timed Petri nets (ITPNs), can be given a rewrit- ing logic semantics. We define ITPNs similarly to the interval timed colored Petri nets (ITCPNs) proposed by van der Aalst [1]. ITCPNs appear in the context of colored nets, but to simplify the exposition and focus on real-time

features, we abstract from the colors of the tokens and instead use atomic tokens (with timestamps). In addition, ITPNs have a notion of concurrent firing of transitions.
An ITPN is a PTN where the outgoing arcs are inscribed by time intervals denoting the range of possible firing delays of the produced tokens. The set TI of all time intervals, in a time domain Time, is the set TI = { [r1, r2] | r1, r2 ∈ Time ∧r1 ≤ r2}. An ITPN N is a tuple (PN , TN , FN , WN , DN ), where (PN , TN , FN , WN ) is a PTN, and the function DN : FN ∩ (TN × PN ) → TI ⊕, with |DN (t, p)| = WN (t, p), is a delay inscription.
In the ITPN model, as in the ITCPN model, we attach to each token a timestamp, which indicates the time when a token becomes available. The set MN of markings of an ITPN N is, therefore, the set (PN ×Time)⊕ of all finite multisets of pairs (p, r ) representing the presence of a token at place p with timestamp r . The enabling time of a transition is the maximum timestamp of the tokens to be consumed. Transitions are eager to fire (i.e., they fire as soon as possible). Therefore the transition with the smallest enabling time will fire first. Firing is an atomic action, producing tokens with a timestamp equal to the firing time plus some firing delay specified by the delay inscription. A finite multiset of transitions, firing at the same time constitutes a (concurrent) step. The formal definition of the step semantics of an ITPN is given in [56,51]. 
We have proposed in [56] a framework for modeling real-time and hybrid systems in rewriting logic by means of real-time rewrite theories, and have shown that a number of well-known models of real-time and hybrid systems can naturally be specified as such theories. A real-time rewrite theory is a rewrite theory including a sort Time, and an operator { } which encloses the global state of the system and is used to ensure that time advances uniformly in all parts of the system. In addition to ordinary rewrite rules modeling instantaneous change in a system, a real-time rewrite theory may contain tick
rules of the form l : {t } −τ→l	{t '} if C , which model times elapse in a system,
and where the term τl of sort Time denotes the duration of the rule. The total time elapse τ (α) of a rewrite proof α : {u} −→ {u '} is defined as the sum of the time elapsed in each tick rule application in α. Even though it is useful to highlight the real-time aspects of a system using real-time rewrite theories, we have shown in [56] that, by adding an explicit clock, such theories are reducible to ordinary rewrite theories in a way that preserves all their expected properties.
In real-time systems, some actions are eager, that is, their application should take precedence over the application of time-advancing tick rules. We divide the rules of a real-time rewrite theory into eager and lazy rules, and define the admissible rewrites [56] to be the subset of all rewrites satisfying the additional requirement that a lazy rule may only be applied when no eager rule is applicable. The Real-Time Maude language and tool [54,55] supports the specification and analysis of real-time rewrite theories, including the possibility to define eager and lazy rules.

The rewrite semantics of interval timed Petri nets generalizes the rewrite semantics of (untimed) place/transition nets given in Section 3.1. For the sake of simplicity of the rewriting logic representation of ITPNs, we choose not to carry the timestamps in the tokens. Instead, a term [p] of sort VisibleMarking represents a occurrence of a token at place p that is “visible”, i.e., available for consumption. A token that will be visible at place p in time r is represented by the term dly(p, r ), which has the sort DelayedMarking whenever r /= 0. 5 The sort Marking is a supersort of the sorts VisibleMarking and DelayedMarking, and denotes multisets of these two forms of tokens, where multiset union is represented by juxtaposition. The function mte takes a term of sort DelayedMarking and returns the time elapse until the next delayed token becomes visible. The function delta models the effect of the passage of time on delayed tokens by decreasing their delays according to the time elapsed.
The rewrite semantics of an ITPN N = (PN , TN , FN , WN , DN ) is a real- time rewrite theory R(N ) whose signature Ω and axioms E define the sort Marking and the functions delta and mte. The set of rules of R(N ) consists of a lazy tick rule modeling time elapse and, for each transition t in TN , an eager rule
¸  W (p1,t )	¸	W (pn ,t )	˛
t : [p1] ... [p1] ... [pn] ... [pn] −→
dly(p1, x1,1) ... dly(p1, x1,W (t,p1)) ... dly(pn, xn,1) ... dly(pn, xn,W (t,pn ))

`	˛¸	x
W (t ,p1)
`	˛¸	x
W (t ,pn )

if (l1,1 ≤ x1,1 ≤ u1,1) ∧ ... ∧ (l1,W (t ,p1) ≤ x1,W (t ,p1) ≤ u1,W (t ,p1)) ∧ ... 
∧(ln,1 ≤ xn,1 ≤ un,1) ∧ ... ∧ (ln,W (t ,pn ) ≤ xn,W (t ,pn ) ≤ un,W (t ,pn ))
where PN = {p1,..., pn}, with pi distinct, D (t, pi ) is the multiset {[li,1, ui,1],
..., [li,W (t,pi ), ui,W (t,pi )]} for each pi ∈ PN , and xi,j are distinct variables of sort Time. For example, a transition t which consumes two tokens from place a, and one token from place b, and produces one token at each of the places c and d, with respective delay intervals [lc, uc] and [ld , ud ], is represented by the following eager rewrite rule:
t : [a] [a] [b] −→ dly(c, X) dly(d, Y) if lc ≤ X ≤ uc ∧ ld ≤ Y ≤ ud .
The following lazy tick rule, where VM is a variable of sort VisibleMarking and DM is a variable of sort DelayedMarking, advances time until the first delayed token becomes visible:


tick : {VM DM} mte(DM)
{VM delta(DM, mte(DM)} if mte(DM) /= ∞.



5 No interesting information about time is lost by this simplification, since the time when a firing of a transition occurs can always be extracted from the proof term which represents the entire computation.


The tick rule computes the time until the next delayed token becomes visible, and advances time by that amount. After such a tick, the tick rule is again enabled but, due to its being lazy, it will not be applied if the new visible token(s) enable some transition(s) (whose firing in turn could immediately trigger further instantaneous transitions).
We have shown in [56,51] a correspondence between step sequences in N and admissible rewrites in R(N ), namely that each (concurrent) step in N can be represented by a one-step concurrent rewrite in R(N ), taking place at the same time and performing the same multiset of transitions, and, conversely, that each one-step (concurrent) rewrite in R(N ) is either an application of the tick rule advancing time, or corresponds to a step in N , taking place at the same time.

Conclusions
In this paper we have given a high-level overview of how rewriting logic can be used as a semantic framework in which a wide range of Petri net models can be naturally unified. Specifically, we have explored how place/transition nets, nets with test arcs, algebraic net specifications, colored Petri nets, and timed Petri nets can all be naturally expressed in rewriting logic, and how well-known semantic models often coincide with (in the sense of being natu- rally isomorphic to) the natural semantic models associated to the rewriting logic representations of the given nets. The general way of representing Petri nets within rewriting logic that we propose is by no means limited to the net classes explicitly discussed in this paper. Although a careful study still has to be carried out, we briefly discuss in [51] some ideas about how similar repre- sentations could be defined for other Petri net classes, such as colored Petri nets based on higher-order programming languages [34], colored net speci- fications over higher-order logics, nets with macroplaces [2], nets with FIFO places [35,25,23], object-oriented variants of Petri nets [61,38], and object nets [63,64,24,65], where nets are viewed as token objects.
In our view, the unification of Petri net models within the rewriting logic framework is useful not only for conceptual reasons, but also for purposes of execution, formal analysis, and formal reasoning about Petri net specifications. Using the reflective and metalanguage capabilities of Maude, it is possible to build execution environments for Petri net specifications where the language description provided by the user and the user interaction could all take place at the Petri net level with which the user is familiar. Similarly, the Real-Time Maude tool [55] could offer corresponding capabilities for executing and ana- lyzing timed Petri net models. Indeed, there is already a substantial body of experience and case studies on the Maude executable specification and for- mal analysis of consurrent and distributed systems in general (see [45]) and of Petri nets in particular [62,56], suggesting that the Maude-based develop- ment of execution and formal analysis environments for Petri nets is a clear

and promising practical application of the conceptual unification of Petri net models suggested in this paper.

Acknowledgement
Support by DARPA through Rome Laboratories Contract F30602-C-0312 and NASA through Contract NAS2-98073, by Office of Naval Research Contract N00014-99-C-0198, and by National Science Foundation Grant CCR-9900334 is gratefully acknowledged. Part of this work is based on earlier work con- ducted by the first author at University of Hamburg, Germany and in the scope of the European Community project MATCH (CHRX-CT94-0452). Further- more, we would like to thank Roberto Bruni, Narciso Mart´ı-Oliet, Ru¨diger Valk and the referees for their constructive criticism and many helpful sug- gestions.

References

W. M. P. van der Aalst. Interval timed coloured Petri nets and their analysis. In M. A. Marsan, editor, Application and Theory of Petri Nets 1993, volume 691 of Lecture Notes in Computer Science, pages 453–472. Springer-Verlag, 1993.
N. A. Anisimov, K. Kishinski, A. Miloslavski, and P. A. Postupalski. Macroplaces in high level Petri nets: Application for design inbound call center. In Proceedings of the Int. Conference on Information System Analysis and Synthesis (ISAS’96), Orlando, FL, USA, pages 153–160, July 1996.
A. Asperti. A logic for concurrency. unpublished manuscript, November 1987.
E. Battiston, F. De Cindio, and G. Mauri. OBJSA nets: a class of high-level nets having objects as domains. In G. Rozenberg, editor, Advances in Petri Nets, volume 340 of Lecture Notes in Computer Science. Springer-Verlag, 1988.
B.  Berthomieu,  N.  Choquet,  C.  Colin,  B.  Loyer,  J.  M.  Martin,  and
A. Mauboussin. Abstract data nets: Combining Petri nets and abstract data types for high level specifications of distributed systems. In Proc. of the Seventh Workshop on Applications and Theory of Petri Nets, Oxford, UK, pages 25–48, 1986.
E. Best and R. Devillers. Sequential and concurrent behaviour in Petri net theory. Theoretical Computer Science, 55:87–136, 1987.
A. Bouhoula, J.-P. Jouannaud, and J. Meseguer. Specification and proof in membership equational logic. Theoretical Computer Science, 236:35–132, 2000.
C. Brown. Relating Petri nets to formulae of linear logic. Technical Report ECS-LFCS-89-87, Laboratory of Foundations of Computer Science, University of Edinburgh, June 1989.


C. Brown and D. Gurr. A categorical linear framework for Petri nets. In Proc. Fifth Annual IEEE Symposium on Logic in Computer Science, pages 208–218, June 1990.
R. Bruni, J. Meseguer, U. Montanari, and V. Sassone. A comparison of Petri net semantics under the collective token philosophy. In J. Hsiang and A. Ohori, editors, Proceedings of ASIAN’98, 4th Asian Computing Science Conference, volume 1538 of Lecture Notes in Computer Science, pages 225–244. Springer- Verlag, 1998.
R. Bruni, J. Meseguer, U. Montanari, and V. Sassone. Functorial semantics for Petri nets under the individual token philosophy. In Proc. Category Theory and Computer Science, Edinburgh, Scottland, September 1999, volume 29 of Electronic Notes in Theoretical Computer Science. Elsevier, 1999. http:// www.elsevier.nl/locate/entcs/volume29.html.
R. Bruni, J. Meseguer, U. Montanari, and V. Sassone. Functorial semantics for petri nets. Information and Computation, 2001. To appear.
R. Bruni and V. Sassone.	Algebraic models for contextual nets.	In
U. Montanari, J. D. P. Rolim, and E. Welzl, editors, Automata, Languages and Programming. Proceedings 2000., volume 1853. Springer-Verlag, 2000.
S. Christensen and N. D. Hansen. Coloured Petri nets extended with place capacities, test arcs and inhibitor arcs. In M. A. Marsan, editor, Application and Theory of Petri Nets 1993, volume 691 of Lecture Notes in Computer Science, 1993.
M. Clavel. Reflection in general logics and in rewriting logic, with applications to the Maude language. Ph.D. Thesis, University of Navarre, 1998.
M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and
J. Quesada. A tutorial on Maude. SRI International, March 2000, http:// maude.csl.sri.com.
M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and
J. Quesada.	Maude: Specification and Programming in Rewriting Logic. Computer Science Laboratory, SRI International, Menlo Park, 1999. http:
//maude.csl.sri.com.
P. Degano, J. Meseguer, and U. Montanari. Axiomizing the algebra of net computations and processes. Acta Informatica, 33:641–667, 1996.
C. Dimitrovici, U. Hummert, and L. Petrucci. Semantics, composition and net properties of algebraic high-level nets. In G. Rozenberg, editor, Advances in Petri Nets 1991, volume 524 of Lecture Notes in Computer Science. Springer- Verlag, 1991.
F. Dur´an and J. Meseguer.	Structured theories and institutions.	In
M. Hofmann, G. Rosolini, and D. Pavlovi´c, editors, Proceedings of CTCS’99, 8th Conference on Category Theory and Computer Science, Edinburgh, Scotland, U.K., September 10-12, 1999, volume 29, pages 71–90. Elsevier, 1999. http:
//www.elsevier.nl/locate/entcs/volume29.html.


H. Ehrig, J. Padberg, and L. Ribeiro. Algebraic high-level nets: Petri nets revisited. In Recent Trends in Data Type Specification, volume 785 of Springer- Verlag, pages 188–206, 1994.
U. Engberg and G. Winskel. Petri nets as models of linear logic. In A. Arnold, editor, CAAP’90, volume 431 of Lecture Notes in Computer Science, pages 147–161. Springer-Verlag, 1990.
J. Fanchon. FIFO-net models for processes with asynchronous communication. In G. Rozenberg, editor, Advances in Petri Nets 1992, volume 609 of Lecture Notes in Computer Science, pages 152–178. Springer-Verlag, 1992.
B. Farwer. A linear logic view of object Petri nets. Fundamenta Informaticae, 37(3):225–246, 1999.
A. Finkel and A. Choquet. FIFO nets without order deadlock. Acta Informatica, 25(1):15–36, 1988.
H. J. Genrich. Equivalence transformation of PrT-nets. In G. Rozenberg, editor, Advances in Petri Nets 1989, volume 424, pages 179–208. Springer- Verlag, 1990.
H. J. Genrich. Predicate/transition nets. In High-Level Petri Nets: Theory and Practice, pages 3–43. Springer-Verlag, 1991.
H. J. Genrich and K. Lautenbach. The analysis of distributed systems by means of predicate/transition-nets. In G. Kahn, editor, Semantics of Concurrent Computation, volume 70 of Lecture Notes in Computer Science, pages 123–146, Berlin, 1979. Springer-Verlag.
H. J. Genrich and K. Lautenbach. System modelling with high-level Petri nets.
Theoretical Computer Science, 13:109–136, 1981.
J. Goguen and R. Burstall. Institutions: Abstract model theory for specification and programming. Journal of the ACM, 39(1):95–146, 1992.
H. M. Hanisch. Analysis of place/transition nets with timed arcs and its application to batch process control. In M. A. Marsan, editor, Application and Theory of Petri Nets 1993, volume 691 of Lecture Notes in Computer Science, pages 282–299. Springer-Verlag, 1993.
K. Hoffmann. Run time modification of algebraic high level nets and algebraic higher order nets using folding and unfolding construction. In G. Hommel, editor, Communication-Based Systems, Proceedings of the 3rd International Workshop held at the TU Berlin, Germany, 31 March – 1 April 2000, pages 55–72. Kluwer Academic Publishers, 2000.
K. Jensen. Coloured Petri nets and the invariant-method. Theoretical Computer Science, pages 317–336, 1981.
K. Jensen. Coloured Petri Nets, Basic Concepts, Analysis Methods and Practical Use., volume 1 of EATCS monographs on theoretical computer science. Springer-Verlag, 1992.


E. Kettunen, E. Montonen, and T. Tuuliniemi. Comparison of Pr-net based channel models. In Proc. of the 12th IMACS World Conf., volume 3, pages 479–482, 1988.
E. Kindler and W. Reisig. Algebraic system nets for modelling distributed algorithms. Petri Net Newsletter, (51):16–31, December 1996.
E. Kindler and H. Vo¨lzer.  Flexibility in algebraic nets.  In J. Desel and
M. Silva, editors, Application and Theory of Petri Nets 1998, 19th International Conference, ICATPN’98, Lisbon, Portugal, June 1998, Proceedings, volume 1420 of Lecture Notes in Computer Science, pages 345–384. Springer-Verlag, 1998.
C. A. Lakos.  From coloured Petri nets to object Petri nets.  In M. Diaz
G. De Michelis, editor, Application and Theory of Petri Nets, volume 935 of Lecture Notes in Computer Science, pages 278–297, Berlin, 1995. Springer- Verlag.
N. Mart´ı-Oliet and J. Meseguer. From Petri nets to linear logic. Mathematical Structures in Computer Science, 1:69–101, 1991.
N. Mart´ı-Oliet and J. Meseguer. From Petri nets to linear logic through categories: A survey. International Journal of Foundations of Computer Science, 2(4):297–399, 1991.
J. Meseguer. General logics. In H.-D. Ebbinghaus et al., editors, Proceedings, Logic Colloquium, 1987, pages 275–329. North-Holland, 1989.
J. Meseguer. Conditional rewriting logic as a unified model of concurrency.
Theoretical Computer Science, 96:73–155, 1992.
J. Meseguer. Rewriting logic as a semantic framework for concurrency: a progress report. In U. Montanari and V. Sassone, editors, Proc. Concur’96, volume 1119 of Lecture Notes in Computer Science, pages 331–372. Springer- Verlag, 1996.
J. Meseguer. Membership algebra as a logical framework for equational specification. In F. Parisi-Presicce, editor, Recent Trends in Algebraic Development Techniques, 12th International Workshop, WADT ’97, Tarquinia, Italy, June 3-7, 1997, Selected Papers, volume 1376 of Lecture Notes in Computer Science, pages 18 – 61. Springer-Verlag, 1998.
J. Meseguer. Rewriting logic and Maude: a wide-spectrum semantic framework for object-based distributed systems. In S. Smith and C.L. Talcott, editors, Formal Methods for Open Object-based Distributed Systems, FMOODS 2000, pages 89–117. Kluwer, 2000.
J. Meseguer and U. Montanari. Petri nets are monoids. Information and Computation, 88(2):105–155, October 1990.
J. Meseguer, U. Montanari, and V. Sassone. On the semantics of Petri nets. In W.R. Cleaveland, editor, Proceedings of the Concur’92 Conference, Stony


Brook, New York, August 1992, volume 630 of Lecture Notes in Computer Science, pages 286–301. Springer-Verlag, 1992.
J. Meseguer, U. Montanari, and V. Sassone. On the model of computation of place/transition Petri nets. In Proceedings 15th International Conference on Application and Theory of Petri Nets, volume 815 of Lecture Notes in Computer Science, pages 16–38. Springer-Verlag, 1994.
J. Meseguer, U. Montanari, and V. Sassone. Process versus unfolding semantics for place/transition Petri nets. Theoretical Computer Science, 153(1–2):171– 210, 1996.
J. Meseguer, U. Montanari, and V. Sassone. Representation theorems for Petri nets. In C. Freska, M. Jantzen, and R. Valk, editors, Foundations of Computer Science: Potential, Theory, Cognition, volume 1337 of Lecture Notes in Computer Science, pages 239–249. Springer-Verlag, 1997.
J. Meseguer, P. C. O¨ lveczky, and M.-O. Stehr. Rewriting logic as a unifying framework for Petri nets. In H. Ehrig, G. Juhas, J. Padberg, and G. Rozenberg, editors, Unifying Petri Nets, Lecture Notes in Computer Science (Advances in Petri Nets). Springer-Verlag, December 2001. To appear.
U. Montanari and F. Rossi. Contextual nets. Acta Informatica, 32:545–596, 1995.
S. Morasca, M. Pezz`e, and M. Trubian. Timed high-level nets. The Journal of Real-Time Systems, 3:165–189, 1991.
P. C. O¨ lveczky. Specification and Analysis of Real-Time and Hybrid Systems in Rewriting Logic. PhD thesis, University of Bergen, 2000. Available at http:
//maude.csl.sri.com/papers.
P. C. O¨ lveczky and J. Meseguer. Real-Time Maude: A tool for simulating and analyzing real-time and hybrid systems. In Third International Workshop on Rewriting Logic and its Applications, 2000. To appear in Electronic Notes in Theoretical Computer Science.
P. C. O¨ lveczky and J. Meseguer. Specification of real-time and hybrid systems in rewriting logic. To appear in Theoretical Computer Science. Available at http://maude.csl.sri.com/papers, September 2000.
C. A. Petri. Nets, time and space. Theoretical Computer Science, 153(1–2):3– 48, 1996.
W. Reisig. Petri nets and algebraic specifications. Theoretical Computer Science, 80:1–34, 1991.
W. Reisig. Elements of Distributed Algorithms: Modeling and Analysis with Petri Nets. Springer-Verlag, 1998.
W. Reisig and J. Vautherin. An algebraic approach to high level Petri nets. In Proceedings of the Eighth European Workshop on Application and Theory of Petri Nets, pages 51–72. Universidad de Zaragoza (Spain), 1987.


C. Sibertin-Blanc. Cooperative nets. In R. Valette, editor, Application and Theory of Petri Nets, volume 815 of Lecture Notes in Computer Science, pages 471–490, Berlin, 1994. Springer-Verlag.
M.-O. Stehr.	A rewriting semantics for algebraic nets.	In C. Girault and
R. Valk, editors, Petri Nets for Systems Engineering – A Guide to Modelling, Verification, and Applications. Springer-Verlag, 2001. To appear.
R. Valk. Petri nets as dynamical objects. In Workshop Proc. 16th International Conf. on Application and Theory of Petri Nets, Torino, Italy, June 1995.
R. Valk. Petri nets as token objects: An introduction to elementary object nets. In J. Desel and M. Silva, editors, Proceedings of the 19th International Conference on Application and Theory of Petri Nets, Lissabon, June 22-26, 1998, volume 1420 of Lecture Notes in Computer Science, pages 1 – 25. Springer- Verlag, 1998.
R. Valk. Relating Different Semantics for Object Petri Nets. Technical report, FBI-HH-B-266/00, Fachbereich Informatik, Universita¨t Hamburg, 2000.
J. Vautherin. Un Modele Algebrique, Base sur les Reseaux de Petri, pour l’Etude des Systemes Paralleles. These de Docteur Ingenieur, Univ. de Paris- Sud, Centre d’Orsay, June 1985.
J. Vautherin. Parallel systems specifications with coloured Petri nets and algebraic specifications. Lecture Notes in Computer Science: Advances in Petri Nets 1987, 266:293–308, 1987.
P. Viry.	Rewriting: An effective model of concurrency.	In C. Halatsis,
D. Maritsas, G. Philokyprou, and S. Theodoridis, editors, PARLE’94 – Parallel Architectures and Languages Europe, 6th Int. PARLE Conf. Athes, Greece, July 1994, Proceedings., volume 817 of Lecture Notes in Computer Science, pages 648–660. Springer-Verlag, 1994.
W. Vogler. Partial order semantics and test arcs. In Proc. MFCS’97, volume 1295 of Lecture Notes in Computer Science. Springer-Verlag, 1997.
