

Electronic Notes in Theoretical Computer Science 253 (2009) 91–111
www.elsevier.com/locate/entcs

Strong Joinability Analysis for Graph Transformation Systems in CHR
Frank Raiser1 Thom Fru¨hwirth2
Institute for Software Engineering and Compiler Construction Ulm University

Abstract
The notion of confluence is prevalent in graph transformation systems (GTS) as well as constraint handling rules (CHR). This work presents a generalized embedding of GTS in CHR that allows to consider strong derivations in confluence analyses. Confluence of a terminating CHR program is decidable, whereas con- fluence of a terminating GTS is undecidable. We show that observable confluence in CHR coincides with
a sufficient criterion for confluence of the embedded GTS. For this purpose the automatic confluence check for CHR can be reused.
Keywords: Graph Transformation Systems, Constraint Handling Rules, Confluence


Introduction
Constraint handling rules (CHR) [6] allow for rapid prototyping and efficient im- plementation of constraint-based algorithms. Besides constraint reasoning, CHR have been used for various tasks including theorem proving, parsing, and multiset rewriting [6].
Graph transformation systems (GTS) are used to describe complex structures and systems in a concise, readable, and easily understandable way. They have applications ranging from implementations of programming languages over model transformations to graph-based models of computation [3,5].
In this work we present an embedding of graph transformation systems in CHR allowing us to perform strong derivations on partially defined graphs. This behavior provides the basis for the analysis of strong joinability of critical pairs presented in this work. Deciding strong joinability of critical pairs comes for free as a result of the observable confluence check of the corresponding CHR program containing

1 frank.raiser@uni-ulm.de
2 thom.fruehwirth@uni-ulm.de

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.10.019

the embedded GTS. This work is a revised and extended version of [10]. Its main improvements are a more succinct encoding of GTS in CHR and a stronger corre- spondence between strong joinability in GTS and confluence in CHR.
We begin with the introduction of the necessary notions of graph transformation systems and CHR in Sect. 2. Section 3 then presents our proposed encoding of a GTS in CHR, for which Sect. 4 proves soundness and completeness. Finally, Sect. 5 introduces observable confluence and its application as a sufficient criterion for confluence of an embedded GTS, before we conclude in Sect. 6.

Preliminaries
In this section we introduce the required formalisms for graph transformation sys- tems and constraint handling rules.

Graph Transformation System (GTS)
The following definitions for graphs and graph transformation systems have been adapted from [5].
A graph G = (V, E, src, tgt) consists of a set V of nodes, a set E of edges and two
morphisms src, tgt : E → V specifying source and target of an edge, respectively. A type graph TG is a graph with unique labels for all nodes and edges.
For the purpose of simplicity, we avoid an additional label morphism in fa- vor of identifying variable names with labels. For multiple graphs we refer to the node set V of a graph G as VG and analogously for edge sets and the src, tgt mor- phisms. We further define the degree of a node as deg : V → N,v '→ #{e ∈ E | src(e) = v} + #{e ∈ E | tgt(e) = v}. As there are often multiple graphs containing the same node due to inclusion morphisms we use degG(v) to specify the degree of a node v with respect to the graph G. When the context graph is clear the subscript is omitted.
A typed graph G is a tuple (V, E, src, tgt, type,T G) where (V, E, src, tgt) is a
graph, TG a type graph, and type a morphism with type = (typeV , typeE) and typeV : V → TGV , typeE : E → TGE. The type morphism is a graph mor- phism, therefore, it has to satisfy the following condition: ∀e ∈ E : typeV (src(e)) = srcTG(typeE(e)) ∧ typeV (tgt(e)) = tgtTG(typeE(e))
A Graph Transformation System (GTS) is a tuple consisting of a type graph and a set of graph production rules. A graph production rule – also simply called

rule if the context is clear – is a tuple p = (L ←l
K →r
R) of typed graphs L, K, and

R with inclusion morphisms l : K → L and r : K → R.
We distinguish two kinds of typed graphs: rule graphs and host graphs. Rule graphs are the graphs L, K, R of a graph production rule p and host graphs are graphs to which the graph production rules can be applied. We, furthermore, make use of graph transformations based on the double-pushout approach (DPO) as de- fined in [5]. Most notably, we require a so-called match morphism m : L → G to apply a rule p to a typed host graph G. The transformation yielding the typed

L ¸,l	 K   r	 R 
m	(1) k	(2) n
J c	J c'	J 
G ¸, D	 H 
Fig. 1. Double-pushout approach
unlink:

twoloop:


Fig. 2. Graph transformation system for recognizing cyclic lists

graph H is written as G =p,m
H. H is given mathematically by constructing D as

shown in Figure 1, such that (1) and (2) are pushouts. Intuitively, the graph L on the left-hand side is matched as a subgraph of G and its occurrence in G is then replaced by the right-hand side graph R. The intermediate graph K is the context graph containing those items in L that are preserved by the rule.
A graph production rule p can only be applied to a host graph G if the following gluing condition is satisfied. The gluing condition [5] is based on the set of gluing points GP = l(K), the set of identification points IP = {v ∈ VL | ∃w ∈ VL,w /= v : m(v) = m(w)}∪ {e ∈ EL | ∃f ∈ EL,e /= f : m(e) = m(f )}, and the set of dangling
points DP = {v ∈ VL | ∃e ∈ EG \ m(EL) : srcG(e) = m(v) ∨ tgtG(e) = m(v)} and it is defined as IP ∪ DP ⊆ GP .
Example 2.1 Figure 2 shows two graph production rules which make up a graph transformation system for detecting cyclic lists. The basic idea of the unlink rule is to remove intermediate nodes of the list, while the twoloop rule replaces the cyclic list consisting of two nodes by a single node with a loop. To detect if a host graph is a cyclic list the GTS is applied to the host graph until exhaustion. The host graph then is a cyclic list if and only if the final graph consists of a single node with a loop [3].
Note that the example makes use of the type graph consisting only of a single node with a loop. Furthermore, we use a shorthand notation that only shows the morphisms l and r implicitly by the labels of the nodes which are mapped onto each other. Nodes and edges which are removed or added in the graphs L or R are not labeled, as there is no node or edge in K which is mapped to them.
In general, the DPO approach allows for the match morphism m to be non- injective. For injective match morphisms the set IP of identification points is guar- anteed to be ∅. For the remainder of this work we only consider injective match morphisms, as non-injective ones can be simulated as follows: given a rule p = (L ←l
K →r R) and a non-injective match morphism m it holds ∀v, w ∈ VL,v /= w with
m(v) = m(w) that the rule is only applicable, if v, w ∈ l(VK), i.e. only nodes which

are not removed by the rule application are allowed to be matched non-injectively – otherwise IP /⊆ GP . Therefore, it is possible to add another rule p' which is derived from p by merging the nodes v and w into a node vw in all three graphs of the rule. Thus, the non-injective matching with m(v) = m(w) can be simulated by injectively matching vw to m(vw) where m(vw) is the same node in G as m(v). The same argumentation holds for edges, analogously. Therefore, we can restrict our- selves to injective match morphisms by extending the set of rules with new rules for all possible merges of nodes and edges in the graph K. This simplifies the generic gluing condition to DP ⊆ GP .
In Sect. 5 we also require the following definition of a track morphism. Intu- itively, the track morphism is defined for a node or edge, if it is not removed by the rule application.
Definition 2.2 [Track Morphism] Given G =⇒ H the track morphism trG⇒H :
G → H is the partial graph morphism defined by


tr	(
) =  c'(c−1(x)) if x ∈ c(D),

Here c : D → G and c' : D → H are the morphisms in the lower row of Fig. 1 and
c−1 : c(D) → D maps each item c(x) to x.
The track morphism of a derivation Δ : G0 ⇒∗ Gn is defined by trΔ = idG  if
n = 0 and trΔ = trG1⇒∗Gn ◦ trG0⇒G1 otherwise, where idG0 is the identity morphism on G0.

Constraint Handling Rules (CHR)
This section presents the syntax and operational semantics of constraint handling rules [6]. Constraints are first-order predicates which we separate into built-in con- straints and user-deﬁned constraints. Built-in constraints are provided by the con- straint solver while user-defined constraints are defined by a CHR program. In this work we consider a subset of CHR where Simpliﬁcation rules are of the form
Rulename @ H1,..., Hi ⇔ B1,..., Bk
where Rulename is an optional unique identifier of a rule, the head H = H1,..., Hi is a non-empty conjunction of user-defined constraints, and the body B = B1,..., Bk is a conjunction of built-in and user-defined constraints. Note that we make sloppy use of the terms conjunction, sequence, and multiset with respect to H1,..., Hi and B1,..., Bk.
The operational semantics is based on an underlying constraint theory CT for the built-in constraints and a state, which is a tuple ⟨G, C, V⟩ where G is a goal store,
i.e. a multiset of user-defined constraints, C is a conjunction of built-in constraints, and V is the set of global variables-of-interest [6].
A simplification rule of the form r @ H ⇔ B is applicable to a state ⟨E∧G, C, V⟩ if CT |= ∀(C → ∃x(H = E)) where x are the variables in H and = is syntactic equality. We then define the following state transition for its application: ⟨E ∧ G, C, V⟩ '→r ⟨Bu ∧ G, (H = E) ∧ C ∧ Bb, V⟩ where B = Bu ∪ Bb with Bu being user-defined and Bb being built-in constraints. We use '→ when the applied rule is

not of interest, and as usual, '→∗ denotes the reflexive-transitive closure of the '→
relation.
Given a simplification rule p @ H ⇔ B and a state S = ⟨E ∪ G, C, V⟩ such that
p is applicable to S we define for the involved match η(p, S) = (E, C ∧ (H = E)).
When comparing different states for confluence we make use of an equivalence relation ≡ on CHR states [6]. This equivalence accounts for different syntactical representations, including renaming of local variables, equality substitutions, and logically equivalent built-in stores.

Example 2.3 The following two rules are part of a CHR handler for the boolean and constraint. The and constraint is ternary here with the implicit meaning that and(X, Y, Z) holds iff X ∧ Y = Z.
r1 @ and(X, X, Z)	⇔	Z = X
r2 @ and(X, Y, 1)	⇔	X = 1,Y = 1 
For a CHR program consisting of these two rules we can consider an initial state ⟨and(0, 0,N ) ∪ and(A, B, C),C = 1, {N, A, B, C}⟩ as input, resulting in the following computation. The underlined constraints are matched to one of the rule heads and removed by the rule application.
⟨and(0, 0,N ) ∪ and(A, B, C),C = 1, {N, A, B, C}⟩
'→r1 ⟨and(A, B, C),C = 1 ∧ (X = 0 ∧ Z = N ∧ Z = X), {N, A, B, C}⟩
'→r2 ⟨∅,C = 1 ∧ (X = 0 ∧ Z = N ∧ Z = X) ∧ (X' = A ∧ Y ' = B ∧ C = 1 ∧ X' = 1 ∧ Y ' = 1), {N, A, B, C}⟩
As this example shows the built-in store can include redundant information when the above transition definition is applied directly. CHR implementations simplify the built-in store with respect to the variables of interest using the built-in solver for the constraint theory CT . This yields the following simplification of the final state above: ⟨∅,N = 0 ∧ A = 1 ∧ B = 1 ∧ C = 1, {N, A, B, C}⟩. This state is equivalent to the final state above, i.e. the two states are contained in the ≡ relation.

Example 2.4 An important property of the equivalence relation ≡ between CHR states is equivalence modulo renaming of local variables. In this work we make use of this property to deal with graph isomorphism in CHR. Without going into details on the encoding of graphs in CHR yet, consider the following states σ1, σ2, and σ3:
σ1 = ⟨node(N, 1) ∪ node(M, 1) ∪ edge(E, N, M ), T, {N}⟩
σ2 = ⟨node(N, 1) ∪ node(M', 1) ∪ edge(E', N,M'), T, {N}⟩
σ3 = ⟨node(N', 1) ∪ node(N, 1) ∪ edge(Eˆ, N',N ), T, {N}⟩
The variable N is a global variable in all these states and the remaining variables are local. Therefore, σ1 ≡ σ2 as they differ only by renaming of local variables. This is similar to considering isomorphism between two graphs, each consisting of two nodes connected by an edge. However, in CHR we can also consider these graphs in a different way, as it holds that σ3 /≡ σ1 although the graph described by σ3 is an isomorphic graph. This is due to the global variable N occurring as a source of the edge in σ1, but as a target in σ3. This distinction is the basis of our strong joinability analysis.

Representation of Graphs in CHR
In order to embed a GTS in CHR, we have to encode its graph production rules as CHR rules and provide a conjunction of goal constraints corresponding to the host graph. To this end, we provide a correspondence between graphs and their representation by CHR constraints given by the constructions in Sect. 3.1. Sec- tion 3.2 presents the encoding of the rules of the GTS for recognizing cyclic lists and a complete example derivation.

CHR Encoding of a GTS
For encoding a GTS in CHR we first determine the constraints needed for encoding the rules and host graph. At this point we require the GTS to be typed, so we can directly infer the necessary constraints from the corresponding type graph as explained in Def. 3.1. Note that this is not a restriction though, as every untyped graph can be typed over the type graph consisting of a single node with a loop.
Definition 3.1 [Type Graph Encoding] For a type graph TG we define the set C of required constraints to encode graphs typed over TG as the smallest set including v/2 ∈C for v ∈ VTG and e/3 ∈C for e ∈ ETG.
We assume all nodes and edges of the type graph TG to be uniquely labeled such that the introduced constraints have unique names as well. Note that when annotating host graphs with these labels they can occur multiple times, i.e. their uniqueness is restricted to the type graph only.
Definition 3.2 [Typed Graph Encoding] For a typed graph G based on a type graph TG the set of constraints encoding G is defined differently for host and rule graphs. We define the following mappings for the encoding for an infinite set of variables VARS:
[typeG(x)] denotes the corresponding constraint name for encoding a node or edge of the given type.
var : G → VARS,x '→ Xx such that Xx is a unique variable associated to x, i.e. var is injective for the set of all graph nodes and edges.
dvar : VG → VARS,x '→ Xx such that Xx is a unique variable associated to x,
i.e. dvar is injective for the set of all graph nodes and edges. Using these mappings we define the following encoding of graphs:

chrG(τ, x) = ⎧⎨
[typeG(x)](var(x), degG(x))	 if x ∈ VG ∧ τ = host [typeG(x)](var(x), dvar(x))	if x ∈ VG ∧ τ = keep

⎩[typeG(x)](var(x), var(src(x)), var(tgt(x)))	if x ∈ EG

We use the notations chr(host, G) = {chrG(host, x) | x ∈ G} and chr(keep, G)
= {chrG(keep, x) | x ∈ G}. Furthermore, we omit the index G if the context is clear. For a node v encoded with chr(keep, v) we call dvar(v) its degree variable.

Section 4 discusses the importance of degree variables with respect to the en- coded GTS. Intuitively, nodes using these cannot be removed by a rule application. These nodes prove to be vital for the strong joinability analysis presented in Sect. 5.
Example 3.3 [cont] For our example of the GTS for recognizing cyclic lists every node in the typed graph has the same type, just like every edge has the same type. Based on this we need the following constraints: node /2, edge /3
The host graph G with a cyclic list consisting of exactly two nodes is encoded in chr(host, G) as node(N1, 2), node(N2, 2), edge(E1, N1, N2), edge(E2, N2, N1).
The same graph G occurring as a rule graph is encoded in chr(keep, G) as follows: node(N1, D1), node(N2, D2), edge(E1, N1, N2), edge(E2, N2, N1).
We can now encode a complete graph production rule based on these definitions:

Definition 3.4 [GTS Rule in CHR] For a graph production rule p = (L ←l
R) from a GTS we define ρ(p) = (CL, CR) with
CL = {chr(keep, x) | x ∈ K}∪ {chr(host, x) | x ∈ L \ K}
CR = {chr(host, x) | x ∈ R \ K} ∪{chr( , e) | e ∈ EK}
K →r

∪{chr(keep, v'), var(v) = var(v'), dvar(v') = dvar(v)− degL(v)+ degR(v) | v ∈
VK}
The rule p is then encoded in CHR using ρ(p) = (CL, CR) and in abuse of notation we use ρ(p) for the CHR rule p @ CL ⇔ CR as well as for the tuple (CL, CR).

Example Computation
Soundness and completeness of the above encoding is shown in Sect. 4, however, to ease the understanding, we present a complete computation here for our cyclic list example. The following two rules are the CHR encoding of the rules from Fig. 2:
unlink @   node(N1, D1), node(N, 2), node(N2, D2),
edge(E1, N1,N ), edge(E2, N, N2)
⇔
node(N' , D' ),N' = N1, D' = D1+1−1,
1	1	1	1
node(N' , D' ),N' = N2, D' = D2+1−1, edge(E, N1, N2)
2	2	2	2
twoloop @	node(N1, D1), node(N, 2), edge(E1, N1,N ), edge(E2, N, N1)
⇔
node(N' , D' ),N' = N1, D' = D1+2−2, edge(E, N1, N1)
1	1	1	1
The following state S is the encoding of a simple cycle consisting of three nodes. To demonstrate strong computations the degree of the third node is left uninstan- tiated:
S = ⟨node(N1, 2) ∪ node(N2, 2) ∪ node(N3, D3) ∪ edge(E1, N1, N2)
∪ edge(E2, N2, N3) ∪ edge(E3, N3, N1), T, {N1, N2, N3, E1, E2, E3, D3}⟩
Rule unlink can then be applied to the state S resulting in the following state S':
S' = ⟨node(N1, 2) ∪ node(N3, D' ) ∪ edge(E, N1, N3) ∪ edge(E3, N3, N1),
' = D3+1−1, {N1, N2, N3, E1, E2, E3, D3}⟩

Finally, rule twoloop can be applied to S' to remove node N1, resulting in the following final state S'':
S'' = ⟨node(N3, D'') ∪ edge(E', N3, N3), D' = D3+1−1
3	3
∧ D'' = D' +2−2, {N1, N2, N3, E1, E2, E3, D3}⟩
3	3
As can be seen from the state S'' the built-in store contains a chain of degree adjustments for nodes with initially uninstantiated degree and the node N3 remains
throughout the whole computation. These properties are investigated more thor- oughly in the following section.

Soundness and Completeness
In this section we show soundness and completeness of our encoding. Whereas in [9] we showed soundness and completeness only for an encoding corresponding to chr(host, G) we generalize these results in this work for an encoding based on chr(keep, G). The following definitions specify these strictly more generic host graph encodings, as well as some properties of our encoding used throughout the remainder of this section.
We then discuss in Sect. 4.1 that CHR rule application respects the gluing condition, before Sect. 4.2 shows that rule applicability of GTS and CHR coincide. Finally, Sect. 4.3 combines these results to prove soundness and completeness.
In Sect. 3.2 the example shows that during the CHR computations we may encounter states which are not a direct encoding of a host graph. Nevertheless, these states represent a graph G without explicitly specifying node degrees. In order to uniformly argue on all of these states we introduce an invariant on states which, intuitively, is satisfied when a state is an encoding of a graph.
Definition 4.1 [Invariant] An invariant I(S) is a property such that for all S0 and
S1, we have that if S0 → S1 (or S0 ≡ S1) and I(S0) holds then I(S1) holds.
Definition 4.2 [Graph Invariant] The graph invariant G(S) with S = ⟨E, C, V⟩ holds iff there exist a graph G and a conjunction C' of constraints that are of the form dvar(v) = degG(v), such that ⟨E, C ∧ C', ∅⟩ ≡ ⟨chr(host, G), T, ∅⟩. For a state S for which G(S) holds with a graph G we say S is a G-state based on G.
The fact, that G is an invariant is shown in Cor. 4.12 using other results from this section which only make use of the definition of G, but do not require it to be an invariant. The following definition allows us to argue directly on those nodes of a G-state based on G for which the state has uninstantiated degree variables:
Definition 4.3 [Strong Nodes] For a CHR state S = ⟨chr(keep, G), C, V⟩ which is a G-state based on G we define the set of strong nodes as S(S) = {v ∈ VG | dvar(v) = degG(v) /∈ C}.
An important feature of strong nodes is that they cannot be removed by any rule, because the uninstantiated degree variable cannot match the constant degree used in rule heads for nodes that are deleted. This property is used in Sect. 5 where

overlaps of rules are investigated and strong nodes are responsible for enforcing strong joinability.
Next we show how a matching in one formalism can be transferred to the other formalism:
Definition 4.4 [GTS Match Implies CHR Match] Let G be a host graph, p = (L ←l
K →r R) a GTS rule, and m a match morphism such that G =p,m G'. Furthermore,
let S = ⟨chr(keep, G), C, V⟩ be a G-state based on G and ρ(p) = (CL, CR).
Then m implies the CHR match η(ρ(p), S) = (G˜, Eq) with
G˜ = {chr(keep, x) | x ∈ m(L)}
Eq = C ∧ {var(v) = var(m(v)) | v ∈ VL}∧ {var(e) = var(m(e)) | e ∈ EL}
∧{dvar(v) = dvar(m(v)) | v ∈ VK}.
Definition 4.5 [CHR Match Implies GTS Match] Let S = ⟨chr(keep, G), C, V⟩ be

a G-state based on G, ρ(p) be the CHR rule for p = (L ←l
using rule ρ(p) with match η(p, S) = (G˜, Eq).
K →r
R) , and S '→ S'

Then η(p, S) implies the injective GTS match morphism m : L → G with
v '→ v' with var(v) = var(v') ∈ Eq ∧ [typeL(v)](var(v'), ) ∈ G˜
e '→ e' with var(e) = var(e') ∈ Eq ∧ [typeL(e)](var(e'), , ) ∈ G˜.
Note that the implied CHR match from Def. 4.4 matches all constraints in the head of the corresponding CHR rule and the implied match m from Def. 4.5 always corresponds to an injective total graph morphism.

Gluing Condition
As applicability of GTS rules is tied to satisfaction of the gluing condition we first ensure that our encoding given in Sect. 3 adheres to this restriction as well. It follows from the definition of a dangling edge, that one exists if and only if DP /⊆ GP .

Lemma 4.6 (Dangling Edges) If the application of rule p = (L ←l
K →r
R) to

G using match m violates the gluing condition, such that DP /⊆ GP , then the corresponding CHR rule ρ(p) = (CL, CR) is not applicable to a G-state based on G using the match implied by Def. 4.4.
Proof.  As DP /⊆ GP there exists a dangling edge. Let e ∈ EG be a dangling edge which is adjacent to vG ∈ VG, such that for a v ∈ VL \ VK : m(v) = vG. Due to Definition 3.4, [typeL(v)](var(v), k) ∈ CL with k = degL(v). This means that there are k edges adjacent to the node v in the rule graph L. When matching this rule graph injectively to the host graph G we need to identify each of these edges with an edge in EG adjacent to m(v) = vG. By the definition of a dangling edge, the edge e is not among those k edges as e ∈ EG \ m(EL). Therefore, we have degG(vG) = l > k.
The constraint corresponding to vG in the goal is [typeG(vG)](var(vG), l), or [typeG(vG)](var(vG), dvar(vG)) depending on whether the degree variable is instan- tiated in C or not. In the first case a match is impossible due to l /= k and in the

latter case a match is impossible, as a variable cannot be matched to a constant in CHR. Therefore, the rule is not applicable as the gluing condition is violated. 

Applicability
Next we show that applicability of GTS rules and the corresponding rules encoded in CHR coincides. The following two lemmata show that the implied matchings are sufficient for the corresponding rule applicability:
Lemma 4.7 (GTS Rule Applicability) Let ρ(p) = (CL, CR) be applicable to a

G-state based on G then p = (L ←l
match morphism m from Def. 4.5.
K →r
R) is applicable to G using the implied

Proof.  Let m be the match implied by Def. 4.5. For p to be applicable to G the gluing condition has to be satisfied. As m is injective this is equivalent to showing the non-existence of a dangling edge. However, if the application of p to G using match m violates the gluing condition, Lemma 4.6 states that ρ(p) will not be applicable using this match, which is a contradiction. Therefore, the gluing condition is satisfied, no dangling edge exists, and p is applicable to G.	 

Lemma 4.8 (Graph Rule Applicability) Let p = (L ←l
and let S = ⟨chr(keep, G), C, V⟩ be a G-state based on G.
K →r
R) , G =⇒
G',

If m(VL \ VK) ∩ S(S) = ∅, then ρ(p) = (CL, CR) is applicable to S using the implied match η(p, S) = (G˜, Eq) from Def. 4.4.
Proof.	For the CHR rule to be applicable we have to show that C implies a possible match. We show this individually for nodes and edges:
Consider a node v ∈ VK. Then there is a constraint [typeL(v)](var(v), dvar(v)) ∈
CL.  As m is a graph morphism it holds that typeL(v) = typeG(m(v)).  We also
have [typeG(m(v))](var(m(v)), dvar(m(v))) ∈ G˜, var(v) = var(m(v)) ∈ Eq, and
dvar(v) = dvar(m(v)) ∈ Eq. The node identifier variables var(v) and var(m(v)) can always be matched as requested by Eq. If dvar(m(v)) = degG(m(v)) ∈ C a match is possible with dvar(v) = degG(m(v)). Otherwise, the match only requires dvar(v) = dvar(m(v)) which is also possible.
Next consider a node v ∈ VL \ VK. Then there is a constraint [typeL(v)](var(v), degL(v)) ∈ CL. Again typeL(v) = typeG(m(v)) holds and we have [typeG(m(v))](var(m(v)), dvar(m(v))) ∈ G˜. As the applicability of m ensures the gluing condition is satsified we know that degL(v) = degG(m(v)) and due to dvar(m(v)) = degG(m(v)) ∈ C the match is possible by identifying the node iden- tifier variables var(v) and var(m(v)).
For an edge e ∈ EL we have [typeL(srcL(e))](var(srcL(e)), ), [typeL(tgtL(e))](var(tgtL(e)), ), [typeL(e)](var(e), var(src(e)), var(tgt(e))) ∈ CL. Due to m being a graph morphism, there exist constraints [typeL(srcL(e))](var(m(srcL(e))), ) ∈ G˜ and [typeL(tgtL(e))](var(m(tgtL(e))), ) ∈ G˜. The matchings var(src(e)) = var(m(src(e))) and var(tgt(e)) = var(m(tgt(e))) are possible by the previous argumentation on nodes.

There further exists an edge m(e) ∈ G with
srcG(m(e)) = m(srcL(e)), tgtG(m(e)) = m(tgtL(e)) that is represented by [typeL(e)](var(m(e)), var(m(src(e))), var(m(tgt(e)))) ∈ G˜ which can be matched to the corresponding constraint in CL with var(e) = var(m(e)).	 
With the above lemmata it can be shown that applicability directly coincides with respect to states that fully encode a host graph:
Theorem 4.9 (Applicability For Host Graphs) A graph production rule p =

(L ←l
K →r
R) is applicable to a typed host graph G if and only if ρ(p) is applicable

to S = ⟨chr(host, G), T, V⟩.

Soundness and Completeness
In order to argue on the relationship between computations in CHR and the corre- sponding GTS derivations w.r.t. a defined track morphism we define strong deriva- tions:
Definition 4.10 [Strong Derivation] A GTS derivation G =p,m G' using p = (L ←l
K →r  R) is strong with respect to S ⊂ VG if m(L \ K) ∩ S = ∅.
Def. 4.10 implies that the track morphism is defined ∀v ∈ S. Together with the soundness result below this allows us to consider strong derivations. The basic notion behind these is that the initial state S contains only partial instantiations of degree variables. Then all rule applications correspond to strong derivations with respect to S(S), and hence, the track morphism is defined ∀v ∈ S(S) over all the involved rule applications, because the final state still contains all constraints corresponding to nodes in S(S).
Theorem 4.11 (Soundness) Let ρ(p) = (CL, CR) be applicable to a state S =
⟨chr(keep, G), C, V⟩ where G(S) holds with η(p, S) = (G˜, Eq), such that S '→ S'.

Then p = (L ←l
K →r
R) is applicable to G using the implied match mor-

phism m from Def. 4.5 such that G =p,m
G' is strong w.r.t. S(S). Furthermore,

S' ≡ ⟨chr(keep, G'), C', V⟩ and G(S') holds.
Proof. We have to show that G(S') holds, i.e. that S' ≡ ⟨chr(keep, G'), C', V⟩ for the graph G' with G =p,m G' using the implied match m from Def. 4.5.
To show that S' is the encoding of the graph G' we show that its construction is analogous to the GTS construction of G':
First the nodes and edges in m(L) get deleted from G, but nodes and edges in m(K) are kept. For a node v ∈ VK we have chr(keep, v) ∈ CL and chr(keep, v'), var(v) = var(v') ∈ CR. Hence, the node constraint corresponding to m(v) is removed and a variant of it introduced by the rule application. For a node v ∈ VL \ VK instead chr(host, v) ∈ CL and no variant of it is in CR which results in the removal of that node. Analogously, edges in m(L) \ m(K) are removed, while edges in m(K) are kept.

Next for the GTS transformation we add nodes and edges in R\ K. As for every x ∈ R \ K we have chr(host, x) ∈ CR the corresponding constraints are also added to S', taking into account the matching Eq. As the nodes and edges not matched to L remain unchanged in both systems all nodes and edges of G' are also represented in S'. Furthermore, no additional constraints are in S', as all constraints in CR are directly modeling nodes or edges from R.
It is now shown, that S' contains the constraints in chr(keep, G'). For G(S') to hold we require a graph G' and equality constraints C'', with ⟨chr(keep, G'), C' ∧ C'', ∅⟩≡ ⟨chr(host, G'), T, ∅⟩. The corresponding graph is cleary the graph G' from the GTS rule application, so it remains to investigate if C' can be extended with equality constraints C'' such that G(S') holds.
As all node degrees are instantiated to constants in chr(host, G') there are two cases: either the corresponding degree variable is instantiated in S' as well, or it can easily be instantiated to the correct degree through an equality constraint in C''. There are three cases for how the degree variable can be instantiated in S' depending on whether the node corresponds to a node v ∈ K, v ∈ R \ K, or v /∈ R. For the last case the node was unaffected by the transformation and as G(S) holds its degree can be instantiated correctly via C''. If v ∈ R\ K then chr(host, v) ∈ CR,
i.e. the corresponding node constraint in S' contains the correct degree degR(v) in
C. Finally, if v ∈ K, then dvar(v) = dvar(v') − n + m ∈ CR with v' ∈ VG. Before the application of p there are n + c edges adjacent to v' and after its application m + c edges, hence, the degree of v' changes by m + c − (n + c) = m − n which is correctly represented in dvar(v). Therefore, the instantiation needs to instantiate dvar(v') = degG(v') which is possible, as G(S) holds.
To prove the strongness consider a v ∈ S(S) with v ∈ VG. If v /∈ m(L) the node is unaffected by the transformation, hence, we assume v ∈ m(L). Let v ∈ m(L)\m(K), then there exists a node v' ∈ VL \ VK with m(v') = v with var(v) = var(v') ∈ Eq and [typeL(v')](var(v'), degL(v')) ∈ CL. However, as dvar(v) = degG(v) /∈ C this is a contradiction to the CHR rule application using this match. Therefore, v ∈ m(K) or v /∈ m(L).	 
From this soundness result it follows directly that G is indeed an invariant:
Corollary 4.12 (G is an Invariant) For CHR programs consisting of rules en- coding a GTS the graph invariant G is an invariant according to Deﬁnition 4.1.
As uninstantiated degree variables inhibit the application of rules that remove the corresponding nodes we can only have completeness if the removed elements are not among the set of strong nodes. When considering a chr(host, G) encoding, un- restricted soundness and completeness is given as the following strongness condition is always satisfied.

Theorem 4.13 (Completeness) Let p = (L ←l
S = ⟨chr(keep, G), C, V⟩ be a G-state based on G.
K →r
R) , G =⇒
G', and let

If m(VL \ VK) ∩ S(S) = ∅, then ρ(p) = (CL, CR) is applicable to S using the implied match η(p, S) from Def. 4.4. Furthermore, for S '→ S' using this match

S' ≡ ⟨chr(keep, G'), C', V⟩ and G(S') holds.
Proof. The applicability of ρ(p) = (CL, CR) to S using the implied match η(p, S) from Def. 4.4 follows from Lemma 4.8.
Therefore, it remains to be shown that the result of applying ρ(p) to S is equiva- lent to ⟨chr(keep, G'), C', V⟩. This is done analogously to the proof of Thm. 4.11 by comparing the GTS construction of G' and the operational semantics of the CHR rule application. Similarly, C' = C ∧ C'' where C'' consists of equality constraints grounding the corresponding degree variables. Note that we assume that the result- ing graph G' uses the same nodes as the graph G for nodes which have not been removed instead of explicitly dealing with an isomorphic graph and performing an additional variable renaming.
Finally, the satisfaction of G(S') follows from Cor. 4.12.	 

Confluence
Both graph transformation systems and constraint handling rules provide the notion of a confluence property. This property guarantees that any derivation made for an initial state results in the same final state no matter which applicable rules are applied. This section introduces the necessary definitions used for GTS and CHR confluence before comparing the two notions. It is shown how automatic observable confluence checking in CHR can be reused to yield a decidable sufficient criterion for confluence of a GTS encoded in CHR.
Note that for the remainder of this section a CHR program always assumes a program consisting only of rules encoding a GTS as explained above. Furthermore, all CHR programs, and therefore graph transformation systems, are assumed to be terminating.
Preliminaries
Definition 5.1 [GTS Confluence]A GTS is called confluent if, for all typed graph
transformations G =∗  H  and G =∗  H , there is a typed graph X together with
2
∗	∗
typed graph transformations H1	X and H	X. Local confluence means
that this property holds for all pairs of direct typed graph transformations G ⇒ H1
and G ⇒ H2 [5].
Newman’s general result for rewriting systems implies that it is sufficient to consider local confluence for terminating graph transformation systems. To verify local confluence we particularly need to study critical pairs and their joinability, according to the following definition based on [5,8].

Definition 5.2 [Joinability of Critical GTS Pair] Let r1 = (L1 ←l
K1 →r
R1), r2 =

(L ←l  K →r R ) be two GTS rules. A pair P
r1,m=1 G r=2,m2 P
of direct typed graph

2	2	2
1 ⇐	⇒	2

transformations is called a critical GTS pair if it is parallel dependent, and minimal
in the sense that the pair (m1, m2) of matches m1 : L1 → G and m2 : L2 → G is jointly surjective.

A pair P
r1,m=1 G r=2,m2 P
of direct typed graph transformations is called parallel

1 ⇐	⇒	2
independent if m1(L1) ∩ m2(L2) ⊆ m1(K1) ∩ m2(K2), otherwise it is called parallel dependent.

A critical GTS pair P
r1,m=1 G r=2,m2 P
is called joinable if there exists a typed

1 ⇐	⇒	2
graph X together with typed graph transformations P =∗  X   X	∗= P . It is
1	⇒	1	2 ⇐	2
strongly joinable if there is an isomorphism f : X1 → X2 such that for each node v,
for which trG⇒P1 (v) and trG⇒P2 (v) are defined, the following holds:
trG⇒P1⇒X1 (v) and trG⇒P2⇒X2 (v) are defined and
fV (trG⇒P1⇒X1 (v)) = trG⇒P2⇒X2 (v)
A similar notion of confluence has been developed for CHR [6]:
Definition 5.3 [CHR Confluence] A CHR program is called confluent if for all states S, S1, and S2: If S '→∗ S1 and S '→∗ S2, then S1 and S2 are joinable. Two states S1 and S2 are called joinable if there exist states T1 ≡ T2 such that S1 '→∗ T1 and S2 '→∗ T2.

Analogous to a GTS, the confluence property for terminating CHR programs is determined by local confluence which can be checked through critical pairs:
Definition 5.4 [Joinability of Critical CHR Pair] Let r1 be a simplification rule and r2 be a (not necessarily different) rule whose variables have been renamed apart. Let Hi Ai be the head, Gi be the guard, and Bi be the body of rule ri(i = 1, 2), then an overlap σCP of r1 and r2 is σCP = ⟨H1 ∪A1 ∪H2, (A1 = A2)∧G1 ∧G2, V⟩, provided A1 and A2 are non-empty conjunctions, V = vars(H1 ∪ A1 ∪ H2 ∪ A2 ∪ G1 ∪ G2) and CT |= ∃((A1 = A2) ∧ G1 ∧ G2).
Let S1 = ⟨B1 ∪ H2, (A1 = A2) ∧ G1 ∧ G2, V⟩ and S2 = ⟨B2 ∪ H1, (A1 = A2) ∧
G1 ∧ G2, V⟩. Then the tuple CP = (S1, S2) is a critical CHR pair of r1 and r2. A critical CHR pair (S1, S2) is joinable if S1 and S2 are joinable.

Critical Pair Properties
After defining the different notions of confluence we now further investigate the difference between critical GTS pairs and critical CHR pairs for CHR programs encoding a GTS. The following lemma shows that there exists a corresponding CHR overlap for each critical GTS pair. Therefore, by examining the overlaps and using the previous soundness result we can transfer joinability results to the critical GTS pair.

Lemma 5.5 (Overlap for Critical GTS Pair) If P
r1,m=1 G r=2,m2 P
is a crit-

1 ⇐	⇒	2
ical GTS pair, then there exists an overlap σCP of ρ(r1) = (C1 , C1 ) and ρ(r2) = 
L	R
(C2 , C2 ) which is a G-state based on G and a critical CHR pair (S1, S2) such that
L	R
S1 is a G-state based on P1 and S2 is a G-state based on P2.
Proof.  Let M = m1(L1)∩m2(L2). We then define the following sets of constraints

with k(x) = chr(keep, x):
H1 =  {k(x) | x ∈ L1 ∧ m1(x) /∈ M},   H2 = {k(x) | x ∈ L2 ∧ m2(x) /∈ M} A1 =   {k(x) | x ∈ L1 ∧ m1(x) ∈ M},   A2 = {k(x) | x ∈ L2 ∧ m2(x) ∈ M} C1 = {dvar(v) = degL1 (v) | v ∈ VL1 \ VK1 }
C2 = {dvar(v) = degL2 (v) | v ∈ VL2 \ VK2 }
Let V = vars(H1 ∪ H2 ∪ A1 ∪ A2). By combining H1 and C1 to a state S =
⟨H1, C1, V⟩ we know that S ≡ S' = ⟨{chr(keep, x) | x ∈ K1 ∧ m1(x) /∈ M}∪ 
{chr(host, x) | x ∈ L1 \ K1 ∧m1(x) /∈ M}, T, V⟩ = ⟨H' , T, V⟩. Similarly, ⟨A1, C1, V⟩
≡ ⟨{chr(keep, x) | x ∈ K1 ∧ m1(x) ∈ M}∪ {chr(host, x) | x ∈ L1 \ K1 ∧ m1(x) ∈
M}, T, V⟩ = ⟨A' , T, V⟩. Analogously, we define H' and A' .
1	2	2
It follows from the definition of CL, that H' ∪ A' matches C1 and analogously,
1	1	L
H' ∪ A' matches C2 .  As M /= ∅ A' and A' are non-empty.  To investigate if
2	2	L	1	2
CT |= ∃(A' = A' ) we take a closer look at the equality constraints imposed by
' = A' :
(A' = A' )	= {var(v1) = var(v2) | v1 ∈ VL ∧ v2 ∈ VL , m1(v1) = m2(v2)}
1	2	1	2
∪	{dvar(v1) = dvar(v2) | v1 ∈ VK1 ∧ v2 ∈ VK2 ∧ m1(v1) = m2(v2)}
∪	{dvar(v1) = degL2 (v2) | v1 ∈ VK1 ∧ v2 ∈ VL2 \ VK2 ∧ m1(v1) = m2(v2)}
∪	{dvar(v2) = degL1 (v1) | v1 ∈ VL1 \ VK1 ∧ v2 ∈ VK2 ∧ m1(v1) = m2(v2)}
∪	{var(e1) = var(e2) | e1 ∈ EK1 ∧ e2 ∈ EK2 ∧ m1(e1) = m2(e2)}
The above equality constraints can easily be satisfied and hence the only re- maining problematic case is when two node constraints with constant degrees are overlapped. However, the degree of m1(v1) = m2(v2) equals the degree of v1 and the degree of v2 due to the gluing condition being satisfied, such that this case can only occur with equal constant degrees.
Hence, σCP = ⟨H' ∪ A' ∪ H' , A' = A' , V⟩ is an overlap of ρ(r1) and ρ(r2) with
1	1	2	1	2
the critical CHR pair (⟨C1 ∪ H' , A' = A' , V⟩, ⟨C2 ∪ H' , A' = A' , V⟩.	 
R	2	1	2	R	1	1	2
If we try to directly transfer the confluence property of a GTS to the corre- sponding CHR program, we cannot succeed however, as in general there are too many critical CHR pairs that could cause the CHR program to be non-confluent. The following example provides a rule, which only has one critical GTS pair, but for which the corresponding CHR rule has three critical CHR pairs.
Example 5.6 Consider a graph production rule for removing a loop from a node and its corresponding CHR rule:
R@ node(N, D), edge(E, N, N ) ⇔ node(N, D'), D' = D − 2
For investigating confluence one must overlap this rule with itself which yields the following three CHR overlap states:
⟨node(N, D) ∪ edge(E, N, N ) ∪ edge(E',N',N'),N = N', V⟩
⟨node(N, D) ∪ node(N', D') ∪ edge(E, N, N ),N = N', V⟩
⟨node(N, D) ∪ edge(E, N, N ), T, V⟩

State (i) is not critical, because the corresponding pair of graph transformations is parallel independent, and hence, directly joinable by applying the rule again. State (ii) is an invalid state as it has multiple encodings of the same node and state (iii) is the encoding of the corresponding critical pair for the graph production rule.
As we want to rule out invalid states, we use the following notion of observable confluence presented in [4]. It is based on restricting confluence investigations to states that satisfy an invariant. Based on these invariants, observable confluence (or I-confluence) is defined as follows:
Definition 5.7 [Observable Confluence] A CHR program P is I-confluent with respect to invariant I if the following holds for all states S0, S1, and S2 where I(S0) holds: If S0 →∗ S1 and S0 →∗ S2 then S1 and S2 are joinable.
In order to use the graph invariant G for the notion of observable confluence, we have to investigate the properties of this invariant. We introduce the following definitions from [4]. As overlap states themselves may not satisfy the invariant we have to examine all possible extensions that satisfy it [4].
Definition 5.8 [Extension, Valid Extension] A state σ = ⟨G, B, V⟩ can be extended by another state σe = ⟨Ge, Be, Ve⟩ as follows: σ  σe = ⟨G  Ge,B ∧ Be, Ve⟩. We say that σe is an extension of σ. A valid extension σe = ⟨Ge, Be, Ve⟩ of a state σ =
⟨G, B, V⟩ is an extension such that v ∈ vars(G∪B)∧v /∈V ⇒ v /∈ vars(Ge∪Be∪Ve).
In the following we discuss states that do not satisfy an invariant I and exten- sions of those states, such that the result satisfies the invariant I. In this context, we refer to ΣI (σ) as the set of all extensions σe of the state σ such that I(σ  σe)
holds.
To reduce the number of extensions that have to be investigated only minimal extensions w.r.t. a partial order ≺σ on extensions [4] are considered. MI(σ) denotes the set of these minimal extensions of a state σ and is used in the following decision criterion of I-local-confluence.
Lemma 5.9 (Deciding I-Local-Confluence [4]) Let ≺σCP be well-founded for all overlaps σCP , then: P is I-local-confluent iff for all critical pairs CP = (σ1, σ2) with overlap σCP , and for all σe ∈ MI(σCP ), we have that (σ1  σe, σ2  σe) is
joinable.
Although, in our programs built-in constraints + and − occur, we can consider
≺σCP well-founded, as σ∅ is always smaller than any other extension. The following
discussion shows that either MG (σCP ) = {σ∅} or ΣG (σCP ) = MG (σCP ) = ∅. This
e	e	e
means, that for all elements σe ∈ ΣG (σCP ) we have σ∅ ≤σ	σe, and hence, ≺σ	is
CP
well-founded. Whether σ∅ is the minimal element depends solely on G(σCP ) holding as the following lemma shows.
Lemma 5.10 (No Minimal Elements) If G(σCP ) is violated for an overlap σCP
then no extension σe exists such that G(σCP  σe) is satisﬁed, i.e. ΣG (σCP ) =
MG (σCP ) = ∅.

Proof. We proof this by a structural analysis of the overlap which gives the different possibilities for G(σCP ) to be violated. W.l.o.g. the overlap stems from the two rules ρ(r1) = (C1 , C1 ) and ρ(r2) = (C2 , C2 ) with the corresponding rule
L	R	L	R
graphs L1, L2, K1, K2, R1, and R2.
First consider a node being overlapped. Let [typeL (v1)](var(v1), D1) ∈ C1 and
1	L
[typeL (v2)](var(v2), D2) ∈ C2 be overlapped with typeL (v1) = typeL (v2).  The
2	L	1	2
equality constraint var(v1) = var(v2) ∈ σCP resembles the merging of the two graph nodes v1 and v2. However, for the degree equalities different possibilities exist:
D1 and D2 are constants: Then D1 = D2 = degL1 (v1) = degL2 (v2) = k, as the overlap is impossible otherwise. Then σCP contains only one constraint [typeL1 (v1)](var(v1), degL1 (v1)). As in L1 and L2 the nodes each have k adja- cent edges, all constraints corresponding to adjacent edges in both rule graphs
have to be contained in the overlap as well. If at least one such constraint is not part of the overlap then σCP contains more than k constraints corresponding to edges adjacent to v1 = v2. As the degree for the node is a constant it cannot be
changed by any extension and the additional edge constraints cannot be removed either. Therefore, no extension can correct the degree inconsistency in such a case.
D1 and D2 are variable: In this case the overlap is possible without any problems. Depending on the number of overlapped adjacent edge constraints the degree variables can always be instantiated with the correct degree, thus satisfying the invariant G.
w.l.o.g. D1 = k and D2 is a variable: this means D2 = k ∈ σCP , therefore, all
edge constraints of C2 of edges adjacent to v2 have to be overlapped with edge
constraints of C1 corresponding to edges adjacent to v1. If there is such an edge constraint from C2 which is not contained in the overlap, then σCP contains more than k edge constraints corresponding to edges adjacent to v1. Again the degree of v1 is specified as the constant k in σCP , and thus, an extension cannot correct
this degree inconsistency. If however, all these edge constraints are contained in the overlap G is satisified again, as there are exactly k such edge constraints coming from C1 .
Finally, consider an edge being overlapped:
Let [typeL ](var(e1), var(src(e1)), var(tgt(e1))) ∈ C1 and
1	L
[typeL ](var(e2), var(src(e2)), var(tgt(e2))) ∈ C2 , then
2	L
var(e1) = var(e2) ∧ var(src(e1)) = var(src(e2)) ∧ var(tgt(e1)) = var(tgt(e2)) ∈

σCP .  By Def. 3.4 we have constraints [typeL (src(e1))](var(src(e1)), ) ∈ C1
and

1	L
[typeL (src(e2))](var(src(e2)), ) ∈ C2 . If these two constraints are not part of the
2	L
overlap the corresponding equality constraint in σCP results in a single graph node being represented by two constraints. This is a violation of G, as chr(host, G) con- tains exactly one constraint for each node. This violation cannot be fixed by an extension, as the conflicting additional node constraint cannot be removed. Anal-
ogously, the two node constraints corresponding to tgt(e1) and tgt(e2) have to be
contained in the overlap.

Therefore, an overlap σCP which violates the invariant G has to violate it due to one of the above reasons for which it cannot be extended by an extension σe such that G(σCP  σe) is satisfied.	 
Combining these two results yields the criterion in Cor. 5.11 for deciding G- local-confluence. Note that this decision criterion is essentially the same criterion as used for traditional local confluence, except that the invariant G restricts the set of investigated overlaps.
Corollary 5.11 (Deciding G-Local-Confluence) P is G-local-confluent if and only if for all critical pairs CP = (σ1, σ2) with overlap σCP , for which G(σCP ) holds, CP is joinable.
Next we transfer joinability of critical CHR pairs to strong joinability in GTS:
Lemma 5.12 (G-Confluence Implies Strong Joinability) Given a CHR pro- gram for a terminating GTS that is G-confluent, then all critical GTS pairs are strongly joinable.

Proof.	Let P
r1,m=1 G r=2,m2 P
be a critical GTS pair. Let r
= (L ← K → R )

1 ⇐	⇒	2
i	i	i	i

and ρ(ri) = (Ci , Ci ) for i = 1, 2.
L	R
By Lemma 5.5 there exists an overlap σCP which is a G-state based on G. As the critical pair (S1, S2) created by the overlap σCP is joinable we have the computations σCP '→ S1 '→∗ T1 and σCP '→ S2 '→∗ T2 with T1 ≡ T2. From Thm. 4.11 we know
that there exist corresponding GTS transformations G r=1,m1 P =⇒∗ X  X ∗ ⇐=
1	2
P2 ⇐= G. The isomorphism between X1 and X2 follows from T1 ≡ T2. Hence, the
critical GTS pair is joinable.
To see that it is strongly joinable consider the set S(σCP ). Every node v for which trG⇒P1 (v) and trG⇒P2 (v) are defined is a node which is not deleted by either r1 or r2. As m1 and m2 are jointly surjective w.l.o.g. there exists a node v' ∈ VL of rule r1 with m(v') = v. As the node is not removed we know v' ∈ VK , and therefore, [typeK (v')](var(v'), dvar(v')) ∈ C1 . Either the node is not part of the
1	L
overlap, or if it is overlapped with a node v'' ∈ VL such that m(v') = m(v''), then we
also know that v'' ∈ VK  due to the defined track morphism. Therefore, we always
have the node constraint [typeK (v')](var(v), dvar(v)) ∈ σCP and v ∈ S(σCP ). As this node cannot be removed during the transformation a variant of this constraint with adjusted degree is also present in T1 and T2. These two variant constraints are
uniquely determined, as var(v) ∈ V by Def. 5.4, and hence, they both have to use var(v) for the node identifier variable. This means we still have to show for such a node v that the two conditions from Def. 5.2 are satisfied:
trG⇒P1⇒X1 (v) and trG⇒P2⇒X2 (v) are defined:
By Thm. 4.11 we know that the GTS transformations are strong w.r.t. S(σCP ).
As v ∈ S(σCP ) this implies v ∈ m(K) ∨ v /∈ m(L) for each of the applied rules,
i.e. the node remains during the transformation and hence the track morphisms are defined as in Def. 2.2.
fV (trG⇒P1⇒X1 (v)) = trG⇒P2⇒X2 (v):

An isomorphism f' between T1 and T2 exists, because T1 ≡ T2. Consider the constraints in T1 and T2 which are the encoding of node v in σCP and let them use the degree variables dvar(v1) and dvar(v2) (with the corresponding chain of constraints dvar(vi) = dvar(v') − n' + m' = ... = dvar(v) − n + m for i = 1, 2 that have been accumulated during the computation). Then there exist corresponding nodes trG⇒P1⇒X1 (v) = v1 ∈ VX1 and trG⇒P2⇒X2 (v) = v2 ∈ VX2
and the isomorphism f' between T1 and T2, which equalizes var(v1) and var(v2),
implies an isomorphism f with fV (v1) = v2.



The reverse direction holds as well, i.e. strong joinability of critical GTS pairs implies that the corresponding CHR-GTS program is G-confluent.

Lemma 5.13 (Strong Joinability Implies G-Confluence) If all critical GTS pairs of a terminating GTS are strongly joinable, then the corresponding CHR pro- gram is G-confluent.

Proof. Consider an overlap σCP for the critical CHR pair (σ1, σ2). W.l.o.g. G(σCP ) holds according to Cor. 5.11. Therefore, σCP is a G-state based on G and σ1, σ2

correspond to graphs G ,G . Consider now G
r1,m=1 G r=2,m2 G .

1	2	1 ⇐	⇒	2
We now show, that either the critical CHR pair is easily joinable, or it corre- sponds to a critical GTS pair and can thus be joined, because all critical GTS pairs are strongly joinable.
First, we want to point out that G is minimal by the definition of the CHR overlap, i.e. every occuring node and edge is part of a match, hence, m1 and m2 are jointly surjective.

Next, we distinguish two cases: First, let G
r1,m=1 G r=2,m2 G
be parallel inde-

1 ⇐	⇒	2
pendent. Therefore, the second rule can be applied after the first, because none of the required nodes or edges has been removed. The following diagram depicts this situation:
 G ¸¸

r1 
, 
G1¸¸
¸¸r2
¸¸ z 
G2

¸¸¸¸r¸2
¸
r1 
z , 
X

By Thm. 4.11 we can apply the corresponding rules to σCP in order to join the critical CHR pair, because S(σCP ) contains only nodes and edges not deleted by r1 and r2.

Secondly, let G
r1,m=1 G r=2,m2 G
be parallel dependent. It follows that m(L ) ∩

1 ⇐	⇒	2	1
m(L2) /⊆ m(K1) ∩ m(K2). However, this is now a critical GTS pair, and hence,
strongly joinable as depicted on the left of the following diagram:



ssG ¸¸¸¸
σCP¸¸

r1sssssssss
sssssssss
¸¸¸¸¸¸¸¸r¸2
¸¸¸z˛
r1 
σ , 
¸¸¸¸r2
¸¸¸¸z 

G1 ¸¸¸
(GT S)
  G2
1 ¸¸¸	(CHR)
  σ2

¸¸¸¸∗¸¸
 ∗ 
¸¸¸∗¸	∗ 

¸¸¸
       
¸¸z , 

X1  X2	σ' ≡ σ'
1	2
The right part of the diagram shows the situation for the critical CHR pair which is joinable by Thm. 4.13. This is possible, because ∀v ∈ S(σCP ) we know that trG⇒G1 (v) and trG⇒G2 (v) are defined, thus by Def. 5.2, v is never removed
and still present in X1 and X2. Finally, the morphism implied by X1  X2 gives
us σ' ≡ σ' .
1	2
Therefore, for all overlaps σCP with G(σCP ) holding we know that the corre- sponding critical CHR pair is joinable, and hence, by Cor. 5.11 that the CHR program is G-local-confluent. As it is terminating it is G-confluent as well.	 
Theorem 5.14 (Strong Joinability iff G-Confluence) For a terminating GTS all critical GTS pairs are strongly joinable if and only if the corresponding CHR program is G-confluent.
In practical terms Theorem 5.14 effectively means that the automatic confluence check for terminating CHR programs [2,6] can be reused to prove confluence of a terminating GTS encoded as a CHR program. Due to the earlier results presented in this section we can apply the standard confluence checker only to those overlaps satisfying the invariant G. The possible causes for an overlap to not satisfy G are duplicate node constraints or inconsistent degrees which can easily be checked. If all critical CHR pairs stemming from these overlaps are joinable we know by Cor. 5.11 that the CHR program is G-confluent, and hence by Theorem 5.14, that the GTS is confluent. As no modification is needed for the confluence checker itself this means that by a restriction of inputs to the confluence checker we can decide G-confluence and in turn get a sufficient criterion for GTS confluence for free.
Conclusion
In [9] we have shown that constraint handling rules (CHR) provide an elegant way for embedding graph transformation systems (GTS). The resulting rules are concise and directly related to the corresponding graph production rules. We presented a generalization of this encoding. It allows to model strong derivations that are used to analyze strong joinability.
The combination of our work with the research on observable confluence [4] resulted in a direct application of the CHR confluence check to decide G-confluence. Invalid overlaps introduced by the CHR encoding of a GTS can elegantly be handled by considering G-confluence which reduces the confluence analysis to the essential overlaps that yield strong joinability of critical GTS pairs.
The connection between CHR and GTS provides room for further research. This work only considers typed graphs, but could be extendend to support typed

attributed graphs as well. As our generalized encoding allows computations on partially defined graphs this allows considering derivations as being applicable to the corresponding set of fully defined graphs.
Furthermore, it seems possible to transfer other results from CHR to GTS and vice versa.  The approaches used for termination analysis of CHR [7] and GTS
[5] seem to be distinct, such that both may profit from applying the approaches from the other formalism. Similarly, CHR provides a strong result on operational equivalence [1] that may provide a decidable criterion for equivalence of embedded graph transformation systems.
Finally, the notion of graphs with interfaces appears to be similar to the notion of global variables in CHR. It might, therefore, be possible to identify a subset of GTS that uses graphs with interfaces in which confluence of a terminating GTS is decidable.

References
Abdennadher, S. and T. Fru¨hwirth, Operational equivalence of CHR programs and constraints, in:
J. Jaffar, editor, Principles and Practice of Constraint Programming, CP 1999, Lecture Notes in Computer Science 1713 (1999), pp. 43–57.
Abdennadher, S., T. Fru¨hwirth and H. Meuss, Confluence and semantics of constraint simplification rules, Constraints 4 (1999), pp. 133–165.
Bakewell, A., D. Plump and C. Runciman, Specifying pointer structures by graph reduction., in:
J. L. Pfaltz, M. Nagl and B. B¨ohlen, editors, Applications of Graph Transformations with Industrial Relevance, Second International Workshop, AGTIVE 2003, Revised Selected and Invited Papers, Lecture Notes in Computer Science 3062 (2003), pp. 30–44.
Duck, G. J., P. J. Stuckey and M. Sulzmann, Observable confluence for constraint handling rules, in: V. Dahl and I. Niemel¨a, editors, Logic Programming, 23rd International Conference, ICLP 2007, Lecture Notes in Computer Science 4670 (2007), pp. 224–239.
Ehrig, H., K. Ehrig, U. Prange and G. Taentzer, “Fundamentals of Algebraic Graph Transformation,” Springer-Verlag, 2006.
Fru¨hwirth, T., “Constraint Handling Rules,” Cambridge University Press, 2009, to appear.
Pilozzi, P. and D. De Schreye, Termination analysis of CHR revisited, in: T. Schrijvers, F. Raiser and T. Fru¨hwirth, editors, Constraint Handling Rules, 5th Workshop, CHR 2008, Hagenberg, Austria, 2008, pp. 35–50.
Plump, D., Confluence of graph transformation revisited, in: A. Middeldorp, V. van Oostrom, F. van Raamsdonk and R. C. de Vrijer, editors, Processes, Terms and Cycles, Lecture Notes in Computer Science 3838 (2005), pp. 280–308.
Raiser, F., Graph Transformation Systems in CHR, in: V. Dahl and I. Niemel¨a, editors, Logic Programming, 23rd International Conference, ICLP 2007, Lecture Notes in Computer Science 4670 (2007), pp. 240–254.
Raiser, F. and T. Fru¨hwirth, Strong joinability analysis for graph transformation systems in CHR, in: 5th International Workshop on Computing with Terms and Graphs, TERMGRAPH’09, Pre- Proceedings, 2009.
