Electronic Notes in Theoretical Computer Science 205 (2008) 67–87	
www.elsevier.com/locate/entcs

Soft Linear Logic and Polynomial Complexity Classes
Marco Gaboardi1
Dipartimento di Informatica, Universita` degli studi di Torino Corso Svizzera 185, 10149 Torino, Italy
Jean-Yves Marion2
Nancy-University, ENSMN-INPL, Loria
B.P. 239, 54506 Vandoeuvre-l`es-Nancy, France
Simona Ronchi Della Rocca3
Dipartimento di Informatica, Universita` degli studi di Torino Corso Svizzera 185, 10149 Torino, Italy

Abstract
We describe some results inspired to Lafont’s Soft Linear Logic (SLL) which is a subsystem of second-order linear logic with restricted rules for exponentials, correct and complete for polynomial time computations. SLL is the basis for the design of type assignment systems for lambda-calculus, characterizing the complexity classes PTIME, PSPACE and NPTIME. PTIME is characterized by a type assignments system where types are a proper subset of SLL formulae. The characterization consists in the fact that a well typed term can be reduced to normal form by a number of beta-reductions polynomial in its lenght, and moreover all polynomial time functions can be computed by well typed terms. PSPACE is characterized by a type assignment system obtained from the previous one, by extending the set of types by a type for booleans, and the lambda-calculus by two boolean constants and a conditional constructor. The system assigns types to terms in such a way that the evaluation of programs (closed terms of type boolean) can be performed carefully in polynomial space. Moreover all polynomial space decision problems can be computed by terms typable in this system. In order to characterize NPTIME we extend the lambda-calculus by a nondeterministic choice operator, and the system by a rule for dealing with this new term constructor.
Keywords: Implicit computational complexity, linear logic, polynomial space, type assignment.

Introduction
A recent research field in Theoretical Computer Science is the design of program- ming languages with bounded computational complexity. In fact, guaranteeing and

1 Email: gaboardi@di.unito.it
2 Email: Jean-Yves.Marion@loria.fr
3 Email: ronchi@di.unito.it

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.066

certifying a limited resources usage is of central importance for various aspects of computer science. A typical example is the one of a network constituted of small and mobile devices with bounded computational resources that receive programs to be executed from the network itself.
One of the more promising approaches to the design of programming languages with bounded complexity is based on the use of λ-calculus as paradigmatic programming language, and on the design of type assignment systems for λ-terms, where types guarantee, besides the functional correctness, also the desired complexity bound. So the complexity can be checked statically at compilation time, in ML style.
Useful tools for this aim are the so called light logics, derived from Girard’s Lin- ear Logic [3], where cut elimination is bounded in time by the size of the proof. In these logics a complete characterization of different complexity classes has been given, considering proofs as programs and the cut-elimination as computational mechanism. The idea is to exploit the Curry-Howard isomorphism, and so to use formulae of light logics as types for (extensions of) the λ-calculus, in such a way that well typed terms inherit the good properties of their types, with respect to the complexity bound.
Here we will describe some results inspired by Lafont’s Soft Linear Logic (SLL) [7], which is a subsystem of second-order linear logic with restricted rules for exponen- tials, correct and complete for polynomial time computations. SLL has been the starting point for the characterization of PTIME and PSPACE through type assign- ment systems, presented respectively in [5] and [4]. Here we use a similar approach to characterize the complexity class NPTIME. But, in order to give a complete description of our methodology, in this paper we will present all the three results, in an incremental way. First we will present STA [5], a type assignments system for λ-calculus, where types are a proper subset of SLL formulae. This restriction is necessary to obtain the property of subject reduction, which is essential for making statically both type assignment and type checking. A term which can be typed in STA can be reduced to normal form in a number of β-reductions polynomial in its lenght. Moreover all polynomial time functions can be computed by terms typable in this system. So STA is correct and complete for (F)PTIME.
STA admits polynomial iterations, so we will use it as starting point for the char- acterization of polynomial space, through STAB [4], a type assignment system ob- tained from STA by increasing the set of types by a type B for booleans, and the λ-calculus by two boolean constants and a conditional constructor. STAB assigns types to terms in such a way that the evaluation of programs (closed terms of type B) can be performed carefully in polynomial space. Moreover all polynomial space decision problems can be computed by programs of this system. So STAB is correct and complete for PSPACE.
The characterization of the complexity class NPTIME is made through the type assignment system STA+. The λ-calculus is extended by a non-deterministic choice operator +, and STA+ is just STA plus by a rule for dealing with this new term constructor. The typing of the + operator is inspired by the logical rule proposed by Maurel in order to deal with non determinism inside Light Affine Logic (LAL) [10]. Obviously the obtained language is no more confluent, but it preserves both

the properties of subject reduction and strong normalization, when the definition of strong normalization is revised taking into account that a term can have more than one normal form. If a term can be typed in STA+, then each one of its normal forms can be reached in a number of reduction steps which is polynomial in the size of the term, if the reduction is performed carefully. Moreover we show that every non deterministic polynomial time decision problem can be simulated by a term typable in STA+. Then STA+ is correct and complete for NPTIME.
The soundness and completeness proofs for the three systems are based on the same methodology, in particular the completeness is proved, in all cases, by coding all Turing machines characterizing the different computational classes by terms typable in the corresponding type assignment system.
The paper is organized as follows. In Section 2 the Soft Linear Logic is recalled. In Section 3 the type assignments STA is presented, and the technical problems to be solved in order to derive it from SLL are briefly discussed. Section 4 contains the
type assignment system STAB. Moreover the two Sections 3 and 4 contain a sketch
of the proof methodology used for proving the correctness and completeness of the two systems with respect to (F)PTIME and PSPACE respectively. In Section 5 the type assignment system STA+ is presented, and its correctness and completeness
with respect to NPTIME are proved.

Soft Linear Logic
Soft Linear Logic (SLL) has been introduced by Lafont [7], in order to capture the polynomial time complexity class PTIME. Here we will consider just the intuition- istic fragment with the connectives  , ∀ and the modality !, being it sufficient for our aims.
Definition 2.1
The set of formulae of SLL is defined by the following grammar:

U, V, Z ::= α | U   U | ∀α.U |!U

where α ranges over a countable set of variables.
A SLL context is a multiset of SLL formulae. Contexts are ranged over by Γ, Δ.
The set of SLL rules prove judgements of the shape:

Γ ▶ U

where Γ is a context and U is a formula. The rules are given in Table 1.
SLL is a restriction of Girard’s Linear Logic (LL) [3], obtained in two steps.
First, by replacing the rules of LL dealing with the modality !:


!Γ ▶ U
!Γ ▶!U
(!R)	 Γ, V ▶ U
Γ, !V ▶ U

(!L)



Table 1
Soft Linear Logic


and the structural rules of weakening and contraction:
 Γ ▶ U  (W )	Γ, !V, !V ▶ U


(C)

Γ, !V ▶ U	Γ, !V ▶ U

by the three rules of multiplexor, soft promotion and digging:


n times
Γ, U¸ , .x.`., U˛ ▶ Z


Γ, !U ▶ Z

(mpx)	 Γ ▶ U
!Γ ▶!U

(sp)	Γ, !!V ▶ U
Γ, !V ▶ U


(digging)

Note that the (mpx) rule is parametric in the number n, which is its rank. The resulting system is equivalent to LL. The weakening rule is a particular case of multiplexor, with n = 0. The contraction rule can be obtained by (mpx) followed by (digging).
The second step is to erase the rule (digging): the result is that there isn’t anymore the linear correspondence
!U  !!U.
As consequence, the modality ! can be used for counting the number of duplications of (sub)proofs.
In order to give the complexity properties of SLL, we need to recall some impor- tant notions. First of all, we assume that the reader knows the notion of proof-nets, a representation of proofs as graphs. Let π be a SLL proof-net: its size is the num- ber of its nodes, its rank is the maximum rank of a multiplexor in it, and its degree is the maximum number of nested applications of rule (sp) in it. The cut elimina- tion procedure applied on a proof-net π takes a number of steps ≤ |π|× kd, where
|π| is the size of π, and k and d are its rank and degree, respectively. So, assuming the proof-nets as computational model, and the cut-elimination as computational rule, SLL is correct for polynomial time computations, once the degree is fixed. The

completeness is achieved through a coding of the polynomial time decision prob- lems computed by a Turing Machines as SLL proof-nets and it is based on the fact that data (Church numerals and boolean strings, which are used for representing respectively iterators and input) can be coded as proof-nets with degree 0. So the following theorem holds.
Theorem 2.2 ([7]) SLL is correct and complete for PTIME.
A type assignment for (F)PTIME
A standard decoration of SLL proofs by λ-terms does not work for our purposes, since it has two main problems. First, subject reduction does not hold for it, since there is not a direct correspondence between cut-elimination in proofs and β-reduction. The problem is not typical of SLL, but it arises for all the decorations of light logics proofs by λ-terms made in the standard way. For a discussion about this problem, the reader can refer to [1], where it is discussed for the Light Affine Logic, and [5], where the problem for Soft Linear Logic is presented.
Very roughly speaking, SLL proof-nets have the property that only boxes can be duplicated. In the decorated calculus, a box corresponds to a λ-term typed by a modal type starting from all modal assumptions. So the property of substitution does not work in general, but it depends not only on types but also on the shape of the context. The unpleasant consequence is that the subject reduction does not hold. Moreover a type assignment for λ-calculus designed as decoration of a sequent calculus is not easy to deal with, since terms are built through substitutions, and so it is not possible to carry out proofs by induction on the structure of terms.
In this section we present STA, a type assignment system in natural deduction, based on SLL, which enjoys the subject reduction property, and which inherits from SLL the good computational properties. In order to obtain subject reduction, terms are built in a linear way, and possible duplications of subterms are obtained through the rules dealing with the modality, namely soft promotion and multiplexor. This is possible thanks to a restriction of the SLL formulae, given in the next definition.

Definition 3.1
Terms of λ-calculus are defined by the following grammar:

M, N, Q ::= x | MM | λx.M

where x ranges over a countable set of variables.
The reduction relation →β is the contextual closure of the following rule:

(λx.M)N →β M[N/x]

where, as usual, M[N/x] is the capture free substitution of all the free occurrences of x in M by N . →∗ is the reflexive and transitive closure of →β.



Table 2
The Soft Type Assignment system STA

The set T of soft types is defined as follows:
A, B, C ::= α | σ   A | ∀α.A	(Linear Types)
σ, τ, ρ, μ, ν ::= A |!σ
where α ranges over a countable set of type variables.
A context is a set of assumptions of the shape x : σ, where x is a variable and σ is a soft type. Variables in a context are all distinct. By abuse of notation, contexts are ranged over by Γ, Δ, Θ.
The Soft Type Assignment System (STA) proves statements of the shape:

Γ ▶ M : σ

where Γ is a context, M is a term of λ-calculus, and σ is a soft type. The rules are given in Table 2.
FV(M) denotes the set of free variables of the term M, while FTV(σ) denotes the set of free variables of the type σ. Let Γ, Δ be contexts, then dom(Γ) = {x | ∃x : σ ∈ Γ}, FTV(Γ) = {FTV(σ) | ∃x : σ ∈ Γ}, !Γ = {x :!σ | ∃x : σ ∈ Γ} and Γ#Δ means dom(Γ) ∩ dom(Δ) = ∅.
σ[A/α] denotes the capture free substitution of all occurrences of the type variable α by the linear type A: note that this kind of substitution preserves the correct syntax of types.
Proofs in STA are denoted by Π, Σ, Φ, Ψ. The statement Π D Γ ▶ M : σ denotes a proof Π with conclusion Γ ▶ M : σ. As usual ▶ M : σ is a short for ∅▶ M : σ.
Some comments follow. STA is not a true natural deduction system, since rule (m) performs a substitution in the subject, but it replaces variables by variables, so the

size of the term is preserved, and induction on it can be used. Note that rule (Ax) and (w) introduce variables with linear type, rule (  I) introduces the binding λ on a term with a linear type and rule (  E) builds a term with a linear type. So, the only way of duplicating a subterm is by using the rule (sp).
Property 1 Π D Γ ▶ M :!σ implies Π can be transformed (commuting some rules) in a derivation of the shape:

Γ' ▶ M : σ
!Γ' ▶ M :!σ
(sp)

followed by a sequence of rules (w) and (m), working on variables not occurring in
M, that transforms the context !Γ' in Γ.
The consequence of the previous property is that a term with a modal type corre- sponds always to a box (but some rules with no computational meaning). So the following fundamental results hold:
Theorem 3.2
(Subject reduction) Γ ▶ M : σ and M →β N imply Γ ▶ N : σ.
(Strong Normalization) Γ ▶ M : σ, for some Γ and σ, implies M is strongly normalizing.
As far as the complexity results are concerned, we will prove that STA is correct and complete for (F)PTIME. Namely every term typable in STA reduces to normal form in a number of β-reduction steps which is polynomial in the size of the term, and moreover every polynomial time Turing machine can be coded by a λ-term typable in STA.
Deterministic polynomial time soundness
In order to prove the complexity results, we need to define some measures both of the terms and of the type derivations. The formal definition of measures is in the Appendix. Roughly speaking, |M| and |Π| are the size of the term M and of the derivation Π respectively, i.e., the number of symbols of M and the number of rules of Π. The rank of a multiplexor is the number of variables xi in it, such that xi ∈ FV(M) (using the notation of Table 2). rk(Π), the rank of the derivation Π, is the maximum rank of a multiplexor rule in Π. The weight of Π with respect to r, W(Π, r), is a static upper bound of the size of all the proofs obtained during the normalization process of Π, in case every box is duplicated at most r times. Notice that, since the linear construction of terms by the system, the number of possible duplications is limited by the degree of Π, d(Π), which is the maximum nesting of applications of rule (sp) in it.
It is important to notice that the trasformation of proofs defined in the text of Property 1 never increases the measures of a derivation. The relations between these measures are shown in the next lemma.
Lemma 3.3 Let Π D Γ ▶ M : σ. Then:
rk(Π) ≤ |M|≤ |Π|.

W(Π, 1) ≤ |M|.
W(Π, r) ≤ rd(Π)W(Π, 1)
x :!q A ∈ Γ implies no(x, M) ≤ (rk(Π))q, where no(x, M) denotes the number of free occurrences of x in M.
The weight of a proof decreases when a β-reduction is performed.
Lemma 3.4 Let Π D Γ ▶ M : σ and M →β M'. There is a derivation Π' D Γ ▶ M' : σ, with rk(Π) ≥ rk(Π'), such that if r ≥ rk(Π') then W(Π', r) < W(Π, r).
As consequence, the following theorem holds.
Theorem 3.5 (Deterministic Polynomial Time Soundness) Let Π D Γ ▶ M : σ, then M can be evaluated to normal form in a number of β-reduction steps ∈ O(|M|(d(Π)+1)).
So every typing of M is an upper bound of its reduction complexity. Since every β-reduction step can be carried out on a Turing machine in a number of steps polynomial in the size of the term, we have the soundness with respect to PTIME.

Deterministic polynomial time completeness
The completeness is proved by showing that every deterministic Turing machine (DTM) working in polynomial time can be programmed by terms typable in STA.
Let ◦ denote composition. In particular M ◦ N stands for λz.M(Nz) and M1 ◦ M2 ◦
··· ◦ Mn stands for λz.M1(M2(··· (Mnz))). Tensor product is definable as σ ⊗ τ =.
∀α.(σ   τ   α)   α. In particular ⟨M, N⟩ stands for λx.xMN. Note that projec- tors are definable as usual since STA is an affine system. n-ary tensor product can be easily defined through the binary one and we use σn to denote σ⊗· · ·⊗σ n-times.


Natural numbers are represented by Church numerals, i.e. n =.
λs.λz.sn(z).

Terms defining successor, addition and multiplication are typable by indexed types

Ni =.
∀α.!i(α  α)  α  α, where !iσ is short for !...! σ. We write N to mean
`˛i¸x

N1. In particular the following holds for STA:
Lemma 3.6 Let P be a polynomial and deg(P ) be its degree. Then there is a term
P deﬁning P typable as:
▶ P :!deg(P )N   N2deg(P )+1
As usual, booleans are represented by the terms: 0 =. λxy.x, 1 =. λxy.y and
if x then M else N =. xMN, where 0 and 1 denotes true and false respectively. The
usual boolean functions are typable using the type B =. ∀α.α  α  α.
Note that, for fresh x, we can conclude Γ, Δ, x : B ▶ if x then M else N : σ from Γ ▶ M : σ and Δ ▶ N : σ only if Γ#Δ. (Here, the multiplicative context management

is crucial, and this differs from the systems Λ+ and STAB that we shall study in short while.) In particular the following holds for STA:
Lemma 3.7 Each boolean total function f : Bn → Bm, where n, m ≥ 1, can be
λ-deﬁned by a term f typable in STA as ▶ f : Bn   Bm.
Strings of boolean are represented by terms of the shape λcz.cb0(··· (cbnz) ··· )
where bi ∈ {0, 1}. Such terms are typable by the indexed type Si =. ∀α.!i(B 
α   α)   α   α. Again, we write S to mean S1. Moreover there is a term len
typable as ▶ len : Si  Ni that given a string of boolean returns its length. Note that the data types defined above can be typed in STA by derivations with degree
0. In what follows we will refer to the next definition.
Definition 3.8 A decision problem D : {0, 1}∗ → {0, 1} is definable in STA by a term M typable as ▶ M :!nSm  B for some m, n ∈ N if and only if for each input string s ∈ {0, 1}∗ definable by s:
D(s) = 0 ⇐⇒ Ms →∗ 0.
DTM configurations can be encoded by terms of the shape:
λc.⟨cbl ◦· · · ◦ cbl , cbr ◦· · · ◦ cbr , Q⟩
0	n	0	m

where cbl ◦ ... ◦ cbl and cbr ◦ ... ◦ cbr
are respectively the left and right hand-side

0	n	0	n
words of the DTM tape and Q is a tuple of length q encoding the state. Such terms can be typed using the indexed type:

TMi =.
∀α.!i(B   α   α)   ((α   α)2 ⊗ Bq)

We can define terms dealing with DTM configurations. In particular for every polynomial R we have a term: ▶ InitR :!deg(R)+1Si  TM2deg(R)+1 that given an input string s, returns a DTM configuration in the initial state q0 with the tape of lenght R(|s|) filled by s. Moreover we have a term: ▶ Tr : TMi  TMi defining the transition function and a term: ▶ Ext : TMi  B that returns either 0 or 1 if the given configuration is accepting or rejecting respectively.
So we can build terms of the shape:

DTMP =.
λs.Ext(P (len s) Tr (InitP s))

defining problems decidable by DTM working in polynomial time P .
Theorem 3.9 (PTIME Completeness) A decision problem D decidable by a
DTM M in polynomial time P is λ-deﬁnable by a term DTMP typable in STA as:
▶ DTMP :!deg(P )+2S   B

Analogously, we can define a term ▶ ExtF : TMi  Si extracting a string from a configuration, so we can build terms of the shape:

DTMF =.
λs.ExtF(P (len s) Tr (InitP s))



Table 3
The Soft Type Assignment system with Booleans
defining functions computable by DTM working in polynomial time P . So the completeness for FPTIME can also be achieved.
A type assignment for PSPACE
We present STAB, a type assignment for polynomial space decision problem, which is built on the top of STA. For this, we add a type B for Booleans and we extend the language with a conditional construction if M then N0 else N1 with an additive typing rule.
Definition 4.1
The set ΛB of terms is defined by the following grammar:
M, N, P, V ::= x | 0 | 1 | λx.M | MM | if M then M else M

where x ranges over a countable set of variables and 0 and 1 are booleans.
The set TB of B types is defined as follows:
A ::= B | α | σ   A | ∀α.A	(Linear Types)
σ ::= A |!σ
where α ranges over a countable set of type variables and B is the only ground
type.
The typing rules of STAB are the ones of STA with the typing rules for Boolean, which are written in Table 3.
The computational meaning of the λ-abstraction and of the conditional is con- veyed by the reduction rule →βδ.
Definition 4.2 The reduction relation →βδ⊆ ΛB × ΛB is the contextual closure of the following rules:
(λx.M)N →β M[N/x]
if 0 then M else N →δ M if 1 then M else N →δ N
∗  denotes the reflexive and transitive closure of →βδ.

The other notions are very similar to the ones presented in the previous sections and we refer to them in this section.
Theorem 4.3
(Subject reduction) Let Γ ▶ M : σ and M →βδ N. Then Γ ▶ N : σ.
(Strong Normalization) Let Γ ▶ M : σ then M is strongly normalizing with respect to the reduction relation →βδ.
Polynomial space soundness
Because of the additive rule (BE), there is an exponential length derivation in STAB. Indeed, consider the following term

(λf.λz.fn(z))(λx. if x then x else x)0

A call by value strategy provides an exponential derivation length in n. How- ever, a leftmost outermost computation with a careful bookkeeping evaluates the above term in polynomial time. This observation leads us to define an abstract machine KC , which evaluates programs, i.e., closed terms of type B. The machine is reminiscent of Krivine’s one [6], and is described in Table 4. There are two kinds of context. The first one is the m-context which is noted A. It is used to store variable assignments which come from β-reductions, see the rules (β) of Table 4. So, a variable substitution is performed only if it is necessary, see the rule (h). The second kind of context is a B-context. The machine pushes nested conditionals in the B-context in order to be able to jump to the right conditional branch, avoiding thus useless and costly computation, see both rules ( if 0) and ( if 1). The two contexts are formally defined in the next definition.
Definition 4.4
An m-context A is a sequence of variable assignments of the shape xi := Mi
where all variables xi are distinct (1 ≤ i ≤ n), and its size, |A|, is Σ	|Mi|+
i.
Let ◦ be a distinguished symbol. A B-contexts is defined by the following grammar:
C[◦] ::= ◦ | ( if C[◦] then M else N )V1 ··· Vn
and its size |C[◦]| is the size of the term obtained by replacing the symbol ◦ by a variable.
A computation of the abstract machine is abbreviated by ∇ :: C, A |= M ⇓ b where ∇ is a derivation tree, in which each node is a configuration of the shape C', A' |= N ⇓ b'. In particular, the conclusion of the derivation is the initial con- figuration. |= M ⇓ b is a short for [◦],ε |= M ⇓ b. The machine computes the →βδ reduction, as proved by the next lemma, where, if A = [x1 := N1,..., xn : Nn], (M)A is M[Nn/xn][Nn−1/xn−1] ··· [N1/x1]. In particular the machine follows the leftmost outermost reduction strategy.



Table 4
The Abstract Machine KC

Lemma 4.5 i) Let ΠD ▶ M : B and ∇ ::|= M ⇓ b. For each C, A |= N ⇓ b' ∈∇ 

∗ (C[N])A →∗ b

Let M be a program, i.e., ▶ M : B. Then |= M ⇓ b.
The size of a configuration C, A |= M ⇓ b is the sum |C| + |A| + |M|. We define the space used by the abstract machine during the evaluation ∇ of a program to be the maximal size of a configuration in ∇. This space usage is clearly related to Turing machines. The next lemma gives a bound on the dimensions of all the components of a machine configuration, namely the term, the m-context and the B-context.
Lemma 4.6 Let M be a closed term, ΠD ▶ M : B where d(Π) = d, and ∇ :: |= M ⇓ b. Then for each intermediate machine conﬁguration C, A |= N ⇓ b':
|A| ≤ 2|M|d+2
|N|≤ 2|M|2d+2
|C| ≤ 2|M|3d+3
The previous lemma is based on the observation that each term occurring in A is an instance of a subterm of M. Since, by Lemma 4.5, for each configuration C, A |= N ⇓ b', (C[N])A is a reduct of M and d is an upper bound on the number of subterms duplications during the reduction of M, the lemma follows. So we obtain

the following result.
Theorem 4.7 (Polynomial Space Soundness) Let ΠD ▶ M : B. Then M can be evaluated to normal form in space bounded by O(|M|O(d(Π))).
Polynomial space completeness
In what follows we use the fact that a polynomial space decision problem is com- putable by a polynomial time Alternating Turing Machine (ATM) and vice-versa [11,2]. We simulate a polynomial time ATM computation, following the line of [8] and [9], by a recursion with substitution of parameters encoded using higher type recursion. We consider the same representation of data types as in STA, in partic- ular data types are typable through derivations with degree 0. It is worth noting that due to the presence of the (BE) rule it is possible to define the usual boolean connectives with an additive management of contexts.
An ATM configuration can be viewed as a DTM configuration with an extra infor- mation about the state. There are four kinds of state: accepting (A), rejecting (R), universal (∧), existential (∨) . We can represent such information by tensor pairs of
booleans. A configuration is accepting, rejecting, universal or existential depending on the kind of its state. We can encode ATM configurations by terms of the shape:
λc.⟨cbl ◦ ··· ◦ cbl , cbr ◦· · · ◦ cbr , ⟨Q, k⟩⟩
0	n	0	m
where, as in the case of a DTM, cbl ◦... ◦ cbl and cbr ◦... ◦ cbr are respectively the
0	n	0	n
left and right hand-side words on the ATM tape, Q is a tuple of length q encoding the state and k is the tensor pair encoding the kind of state. Such terms can be typed using the following indexed type:

ATMi =.
∀α.!i(B   α   α)   ((α   α)2 ⊗ Bq+2)


It is easy to adapt the terms dealing with DTM to the case of ATM. In particular:
▶InitR :!deg(R)+1Si   ATM2deg(R)+1	Initial configuration
▶Tr1, Tr2 : ATMi   ATMi	Transition functions
▶Ext : TMi   B	Result State Extraction

Moreover we have a term: Kind typable as ▶ Kind : ATMi  B2 which takes a configuration and return its kind.
Given an ATM M working in polynomial time we define, a recursive evaluation
procedure evalP , working in polynomial time P , which takes a string s and returns
0 or 1 if the initial configuration (with the tape filled with s) leads to an accepting or rejecting configuration respectively. Without loss of generality we consider ATMs with transition relation of degree two (at each step we consider two transitions).
Using the conditional it is easy to define a function α such that: α(A, M1, M2) = A,
α(R, M1, M2) = R, α(∧, M1, M2) = M1 ∧ M2 and α(∨, M1, M2) = M1 ∨ M2.
We would now define evalP  as an iteration of an higher order StepM function over

a Base case.


Base =.


λc.(Kind c)

StepM =.
λh.λc.α((Kind c), (h(Tr1
c)), (h(Tr2
c)))


It is easy to verify that such terms are typable as: ▶ Base : TMi   B2 and
▶ StepM : (TMi   B2)   TMi   B2 respectively.  Hence, the evaluation function of an ATM M working in polynomial time P is definable as:


evalP
=. λs.Ext((P (len s) StepM Base)(InitP s))


From the well known result of [2] we can conclude.
Theorem 4.8 (PSPACE Completeness) A decision problem D decidable by a
DTM M in polynomial space P is deﬁnable by a term evalP  typable in STAB as:


▶ evalP
:!deg(P )+2S   B


The characterization of FPSPACE could be reached by enriching the calculus with strings of booleans and the type assignment system by a new type and rule for dealing with them. Moreover the machine could be extended to deal with closed terms typed by the type of the boolean strings. The extension does not present any particular problem, but it would be technically very boring.

A type assignment for NP
We here present STA+, a type assignment system characterizing non deterministic polynomial time computations, which is built on the top of STA. We need to extend the language by a non deterministic construction M + N, and to deal carefully with the corresponding reduction rules, while the set of types remains unchanged.
Definition 5.1
The set Λ+ of terms is defined by the following grammar:

M, N, P, V ::= x | MM | λx.M | M + M

where x ranges over a countable set of variables.
The Non Deterministic Soft Type Assignment System (STA+) proves statements of the shape:
Γ ▶ M : σ
where Γ is a context, M is a term, and σ is a soft type. STA+ is obtained by adding to the rules of STA the (sum) rule pictured in Table 5.
The following property still holds for STA+.



Table 5 The (sum) rule.

Property 2 Π D Γ ▶ M :!σ implies Π can be transformed (commuting some rules) in a derivation of the shape:

Γ' ▶ M : σ
!Γ' ▶ M :!σ
(sp)

followed by rules (w) and (m) working on variables not occurring in M.
The operational behaviour of Λ+ is described in the following definition.
Definition 5.2 The reduction relation →βγ⊆ Λ+ × Λ+ is the contextual closure of the following rules:
(λx.M)N →β M[N/x] M + N →γ M
M + N →γ N
∗  denotes the reflexive and transitive closure of →βγ.
The calculus Λ+ equipped with the reduction βγ is non confluent. In particular a term M can have more than one normal form. But we can extend to it in a natural way the notion of strong normalization. A term M is βγ-strongly normalizing if every reduction sequence starting from it stops. Then we can prove that the system enjoys the desired key properties.
Property 3
(Subject reduction) Let Γ ▶ M : σ and M →βγ N. Then Γ ▶ N : σ.
(Strong Normalization) Let Γ ▶ M : σ then M is strongly normalizing with respect to the reduction relation →βγ.
The subject reduction property can be immediately derived by the corresponding property of STA, since the definition of γ-reduction.

Non deterministic polynomial time soundness
We are now interested in proving the soundness of STA+ with respect to non deter- ministic computations. In order to prove it, we need to proceed in a similar way as for PSPACE, and refer to a particular evaluation of terms. In fact, some βγ reduc- tion sequence can use both time and space exponential in the size of the initial term, as showed by the following example. Let M ≡ n((λx.zx + zx)I), where n is a Church numeral. If we first β-reduce M according to an innermost strategy, after n + 2 steps we obtain a term with a number of γ-redexes which is exponential in n. In order to obtain the desired result, we need both to perform the reduction in an outermost



Table 6
The ND Abstract Machine KNDC

way, and moreover to perform the substitutions, arised by the β-reduction, only when necessary. The abstract reduction machine KNDC defined in Table 6 does the required job. In fact every substitution is made, by the rule (h), only on the head occurrence of a variable, thanks to the m-context A. Moreover, thanks to the rules
(L) and (R) a γ-reduction cannot be postponed, but it is immediately performed when it appears in head position. As far as the space of an evaluation is concerned, this can be measured thanks to the context C, which is defined by the following grammar:
C ::= [◦] | λx.C[◦] | xM1...Mi[◦]Mi+1...Mn   (1 ≤ i ≤ n)
Note that, while in the PSPACE case we used a machine reducing only well typed terms, this new machine works on all Λ+, and so it can run forever, in some cases. The strong normalization of terms in STA+ assures us that for a well typed term the machine always stops. An example of a running of the machine is given in Table
7. The following lemma is the key tool for the soundness proof. We will freely use the notions and notations introduced in the previous section.
Lemma 5.3

∇ :: [◦],ϵ |= M ⇓ N and C, A |= M' ⇓ N' ∈∇ imply M →∗
(C[M'])A →∗
(C[N'])A →∗

N where N is a normal form of M.
∇ :: [◦],ϵ |= M ⇓ N and C, A |= M' ⇓ N' ∈ ∇ imply (M')A →∗

N' where N' is a

normal form.
Proof. Easy, by inspecting the rules of the machine.	 
The above lemma can be further refined.

Lemma 5.4 ∇ :: [◦],ϵ |= M ⇓ N implies M →∗	N where N is a normal form of M.
The computation can be carried out in a number of βγ-reduction equal to number of applications of rules (β), (L) and (R) in ∇.
Proof. Easy, by inspecting the rules of the machine.	 
The analogous of Lemma 3.3 holds, thanks to a careful definition of the weight.

Lemma 5.5 Let Π D Γ ▶ M : σ. Then:
rk(Π) ≤ |M|≤ |Π|.
W(Π, 1) ≤ |M|.
W(Π, r) ≤ rd(Π)W(Π, 1).
M ∈ Λ implies that for every r ≥ 1: |M|≤ W(Π, r).
The following lemma relates the measures on type derivation and the dimension of the computation in the machine.
Lemma 5.6 Π D Γ ▶ M : σ and ∇ :: [◦],ϵ |= M ⇓ N imply that the number of rules applications in ∇ (but the rule (h)) is bounded by W(Π, r) for every r ≥ rk(Π).
Proof. In every rule but (h) the weight of the conclusion is strictly grater than the weight of the premises.	 
The above lemma leads to the following.
Lemma 5.7 Let Π D Γ ▶ M : σ. Then M can be evaluated to every one of its normal form in a number of βγ-reduction steps ∈ O(|M|(d(Π)+1)).
In order to extend the above lemma to a polytime result we need to consider also the space used in the computation. This is one of the reasons why we have introduced the machine KNDC .
The non deterministic behaviour of +, together with the outermost reduction, imply that some occurrences of variables will be never replaced during the evaluation. E.g.,
in the term (λx.x + x)M only one occurrence of x will be replaced by M. The notion of effective occurrence gives an upper bound on the number of variables which could be replaced.
Definition 5.8 The number of effective occurrences neo(x, M) of the variable x oc- curring free in M is defined as:
neo(x, x) = 1,	neo(x, y) = 0,	neo(x, M + N) = max{neo(x, M), neo(x, N)}
neo(x, MN) = neo(x, M)+ neo(x, N),  neo(x, λy.M) = neo(x, M),
A type derivation gives us some informations about the number of effective occurrences of a free variable x in its subject M.
Lemma 5.9 Let Π D Γ, x :!nA D M : σ then neo(x, M) ≤ rk(Π)n.



Table 7
An example of computation in KNDC .

The above lemma, by giving a bound on the number of effective occurrence is useful to give a bound on the number of applications of the (h) rule in every computation.
The size of a configuration C, A |= M ⇓ N is the sum |C| + |A| + |M| + |N|. We define the space of the abstract machine to be the maximal size of a configuration in a computation.
Lemma 5.10 Let M be a closed term, ΠD ▶ M : B where d(Π) = d, and ∇ :: [◦],ϵ |=
M ⇓ N. Then for each intermediate machine conﬁguration C, A |= M' ⇓ N':
|A| ≤ 2|M|d+2
|M'|≤ 2|M|2d+2
|N'|≤ |M|d+1
|C| ≤ 2|M|4d+4
Proof. Note that analogously to the machine KC of the previous section also for
KNDC each term occurring in A is an instance of a subterm of M.
It follows directly by the above observation and by Lemma 5.6.
It follows from the previous point and the fact that Lemma 5.9 gives a bound on the number of applications of the (h) rule on every variable in A.
It follows from the fact that N' is a normal form so it is a term in Λ and we can apply Lemma 5.5.4.
It follows from the fact that the only rules that make the context C grow are the rules (λ) and (h1). The case of (λ) rule is simple while the previous point can be used in the case of rule (h1).

As consequence, the following lemma holds.
Lemma 5.11 Let Π D Γ ▶ M : σ, Then M can be evaluated to normal form in space

bounded by O(|M|O(d(Π))).
From the above lemma and Lemma 5.7 we can conclude the following.
Theorem 5.12 (Non Deterministic Polynomial Time Soundness) Let Π D Γ ▶ M : σ, then M can be evaluated to every one of its normal forms by a non deterministic Turing machine in time ∈ O(|M|O(d(Π))).

Non deterministic polynomial time completeness
We consider the same representation of data types as in STA, in particular data types are typable through derivations with degree 0. The following is the adaptation to the case of STA+ of Definition 3.8.
Definition 5.13 A decision problem D : {0, 1}∗ → {0, 1} is definable in STA+ by a term M typable as ▶ M :!nSm  B for some m, n ∈ N if and only if for each input string s ∈ {0, 1}∗ definable by s:
D(s) = 0 ⇐⇒ there exists a βγ-normal form of M equal to 0.
A configuration of a non-deterministic Turing machine (NDTM) is identical to a configuration of a deterministic Turing machine. So we can encode NDTM configurations by terms of the shape:
λc.⟨cbl ◦· · · ◦ cbl , cbr ◦· · · ◦ cbr , Q⟩
0	n	0	m
which can be typed again using the indexed type:

TMi =.
∀α.!i(B   α   α)   ((α   α)2 ⊗ Bq)


Analogously to the case of a DTM, we have terms for dealing with NDTM config- urations. In particular we have the following terms introduced in Section 3.1.
▶InitR :!deg(R)+1Si   TM2deg(R)+1	Initial configuration
▶Ext : TMi   B	Result State Extraction
▶ExtF : TMi   Si	Result Tape Extraction
In fact, what distinguish a NDTM by a DTM is that the behaviour of a NDTM is determined by a transition relation while the behaviour of a DTM is determined by a transition function. We have seen that every transition function is definable by a term typable as ▶ Tr : TMi  TMi. Hence, we can define a transition relation by a term NDTr defined as:
NDTr =. Tr1 + ··· + Trn
Obviously the case n = 1 coincide with the case of a transition function. The term
NDTr is typable using the (sum) rule as:

▶ NDTr : TMi   TMi

So we can build terms of the shape:

NDTMP =.

λs.Ext(P (len s) NDTr (InitP s))


defining problems decidable by NDTM working in polynomial time P .
Theorem 5.14 (NPTIME Completeness) A decision problem D decidable by a NDTM M in polynomial time P is deﬁnable by a term NDTMP typable in STA+ as:
▶ NDTMP :!deg(P )+2S   B

References
P. Baillot and K. Terui. Light types for polynomial time computation in lambda-calculus. In Proceedings of the Nineteenth Annual IEEE Symposium on Logic in Computer Science (LICS ’04), pages 266–275. IEEE Computer Society, 2004.
A. K. Chandra, D. C. Kozen, and L. J. Stockmeyer. Alternation. Journal of the ACM, 28(1):114–133, 1981.
J.-Y. Girard. Linear logic. Theoretical Computer Science, 50:1–102, 1987.

M. Gaboardi, J.-Y. Marion, and S. Ronchi Della Rocca. A logical account of PSPACE. In 35th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages POPL 2008, San Francisco, January 10-12, 2008, Proceedings, 2008. to appear.
M. Gaboardi and S. Ronchi Della Rocca. A soft type assignment system for λ-calculus. In Jacques Duparc and Thomas A. Henzinger, editors, Proceedings of the 21st International Workshop on Computer Science Logic (CSL ’07), volume 4646 of Lecture Notes in Computer Science, pages 253–267. Springer, 2007.
J.-L. Krivine. A call-by-name lambda calculus machine. Higher Order and Symbolic Computation, 2007. To appear.
Y. Lafont. Soft linear logic and polynomial time. Theoretical Computer Science, 318(1-2):163–180, 2004.
D. Leivant and J-Y. Marion. Ramified recurrence and computational complexity II: Substitution and poly-space. In Proceedings of the 8th International Workshop on Computer Science Logic (CSL ’94), volume 933 of Lecture Notes in Computer Science, pages 486–500. Springer, 1994.
D. Leivant and J.-Y. Marion. Predicative functional recurrence and poly-space. In TAPSOFT ’97: Theory and Practice of Software Development, volume 1214 of Lecture Notes in Computer Science, pages 369–380. Springer-Verlag, 1997.
F. Maurel. Nondeterministic light logics and NP-time. In Martin Hofmann, editor, Proceedings of the 6th International Conference on Typed Lambda-Calculi and Applications (TLCA ’03), volume 2701 of Lecture Notes in Computer Science, pages 241–255. Springer, 2003.
W. J. Savitch. Relationship between nondeterministic and deterministic tape classes. Journal of Computer and System Sciences, 4:177–192, 1970.

A	Measures definition
Definition A.1
The size |M| of a term M is defined as |x| = 1, |λx.M| = |M| + 1, |MN| = |M + N| =
|M| + |N| + 1, | if M then N0 else N1 | = |M| + |N0| + |N1| + 1.
The size |Π| of a proof Π is the number of rules in Π.

The rank of a rule (m), as defined in Table 2,
  Γ, x1 : τ, ..., xn : τ ▶ M : σ  (m)
Γ, x :!τ ▶ M[x/x1, ..., x/xn] : σ

is the number k ≤ n of variables xi such that xi ∈ FV(M) (1 ≤ i ≤ n ). Let r be the the maximum rank of a rule (m) in Π. The rank rk(Π) of Π is the maximum between 1 and r.
The degree d(Π) of Π is the maximum nesting of applications of rule (sp) in Π.
Let r be a natural number. The weight W(Π, r) of Π with respect to r is defined inductively as follows.
If the last applied rule is (Ax), (B0I), (B1I) then W(Π, r) = 1.
If the last applied rule is:
Σ D Γ, x : σ ▶ M : A (  I)
Γ ▶ λx.M : σ   A


then W(Π, r) = W(Σ, r)+ 1.
If the last applied rule is:


then W(Π, r) = rW(Σ, r).
If the last applied rule is:


Σ D Γ ▶ M : σ
!Γ ▶ M :!σ


(sp)

Σ D Γ ▶ M : μ   A	Θ D Δ ▶ N : μ (  E)
Γ, Δ ▶ MN : A

then W(Π, r) = W(Σ, r)+ W(Θ, r)+ 1.
If the last applied rule is:
Σ D Γ ▶ M : B	Θ0 D Γ ▶ N0 : A	Θ1 D Γ ▶ N1 : A
Γ ▶ if M then N0 else N1 : A
then W(Π, r) = max{W(Σ, r), W(Θ0, r), W(Θ1, r)} +1 
If the last applied rule is:
Σ D Γ ▶ N0 : A	Θ D Γ ▶ N1 : A Γ ▶ N0 + N1 : A
then W(Π, r) = max{W(Σ, r), W(Θ1, r)} +1 
In every other case W(Π, r) = W(Σ, r) where Σ is the unique premise derivation.
