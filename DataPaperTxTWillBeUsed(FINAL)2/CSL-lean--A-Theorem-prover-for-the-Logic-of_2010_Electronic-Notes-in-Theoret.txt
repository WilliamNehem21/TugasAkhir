

Electronic Notes in Theoretical Computer Science 262 (2010) 3–16
www.elsevier.com/locate/entcs

CSL-lean: A Theorem-prover for the Logic of Comparative Concept Similarity
Régis Alenda1  Nicola Olivetti2
LSIS - UMR CNRS 6168
Université Paul Cézanne (Aix-Marseille 3), Domaine Universitaire de Saint-Jérôme Avenue Escadrille Normandie-Niemen, 13397 Marseille Cedex 20, France

Gian Luca Pozzato4,3
Dipartimento di Informatica Università degli Studi di Torino
c.so Svizzera 185 10149 Torino, Italy

Abstract
The logic CSL of the comparative concept similarity has been introduced by Sheremet, Tishkovsky, Wolter and Zakharyaschev to capture a form of qualitative similarity comparison between concepts and/or objects. In this logic we can formulate assertions of the form “objects A are more similar to B than to C”. This kind of assertions can be added to an ontology to express qualitative comparisons between concepts. In this work we present CSL-lean, the first theorem-prover for this logic. It is a direct Prolog implementation of a tableaux-based decision procedure recently proposed for this logic. The Prolog program is inspired by the lean-methodology. CSL-lean also contains a graphical interface written in Java and it is available for free download at http://www.di.unito.it/~pozzato/csllean/.
Keywords: Comparative concept similarity, Tableaux Calculi, Logic Programming, lean methodology.


Introduction
The logics of comparative concept similarity CSL have been introduced in [15] to capture a form of qualitative comparison between concept instances. In these logics we can express assertions of the form: “Renault Clio is more similar to Peugeot 207 than to VW Golf”, “Marseilles is more similar to Barcelona than to Naples”. These logics may find an application in ontology languages, whose logical base is

1 Email: regis.alenda@lsis.org
2 Email: nicola.olivetti@univ-cezanne.fr
3 Email: pozzato@di.unito.it
4 The author has been partially supported by Regione Piemonte, Project “ICT4Law - ICT Converging on Law: Next Generation Services for Citizens, Enterprises, Public Administration and Policymakers”.

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.04.002

provided by Description Logics (DL), allowing concept definitions based on prox- imity/similarity measures. For instance ([15]), the color “Reddish” may be defined as a color which is more similar to a prototypical “Red” than to any other color (in some color model as RGB). The aim is to develop a language in which logical classification provided by standard DL is integrated with classification mechanisms based on calculation of proximity measures. The latter is typical for instance of domains like bio-informatics or linguistics.
The logic CSL contains formulas (or concepts) defined by boolean operators and a single binary modal connective ⇔ expressing comparative similarity 5 . In this language the above examples can be encoded (using nominals as needed) as follows:
reddish ≡ {red } ⇔ {green,..., black} ,
Clio ± (Peugeot207 ⇔ Golf ),
({barcelona} ⇔ {naples})(marseilles),

The semantics of CSL is defined in terms of distance spaces, that is to say structures equipped with a distance function d, whose properties may vary according to the logic under consideration. In this setting, the evaluation of A ⇔ B can be informally stated as follows: x satisfies A ⇔ B iff d(x, A) < d(x, B) meaning that the object x is an instance of the concept A ⇔ B (i.e. it belongs to things that are more similar to A than to B) if x is strictly closer to A-objects than to B-objects according to distance function d, where the distance of an object to a set of objects is defined as the infimum of the distances to each object in the set. In [15,17,8,16], the authors have investigated the logic CSL with respect to different classes of distance mod- els, see [17] for a survey of results about decidability, complexity, expressivity, and axiomatisation. Remarkably it is shown that CSL is undecidable over subspaces of the reals.
A particular dialect of CSL has been investigated in great detail [15,1]: namely the case in which the semantics is restricted to minspaces, the latter being spaces where the infimum of a set of distances is actually their minimum. The minspace property entails the restriction to spaces where the distance function is discrete. This requirement does not seem incompatible with the purpose of representing qualitative similarity comparisons. We consider here CSL under the minspace semantics.
As shown in [1], the semantics based on minspace can be formulated equivalently in terms of preferential structures, that is to say Kripke models equipped with a family of strict partial (pre)-orders y ≺x z indexed on objects x [10,18], whose intended meaning is that x is more similar to y than to z.
A decision procedure for this logic in the form of tableaux calculus is presented in [1]. Termination is obtained by adopting a standard strategy (controlling the ap- plication order of the rules) and by suitable blocking conditions. In [2], the tableaux procedure is extended to a simple description logic language containing also ABOX and nominals.

5 In a more general setting, the language might contain several ⇔Feature where each Feature corresponds to a specific distance function dFeature measuring the similarity of objects with respect to one Feature (size, price, power, taste, color...).

In this paper we present CSL-lean, the first theorem prover for CSL logic. It is a (relatively small) Prolog program inspired by the “lean” methodology: in a few words, the program implements just a “prove” predicate, each clause of its definition corresponds to a tableau rule and the search mechanism is given for free by the Prolog search engine. The preliminary version we present here does not make use of any sophisticated data structure or optimization technique. It only uses basic Prolog predicates and implements directly the blocking conditions to obtain termi- nation. Performances are nonetheless encouraging. Some improvements and further extensions are discussed in the conclusions.

The Logic CSL
The language LCSL of CSL is generated from a (countable) set of propositional variables V1, V2,... ∈ Vp by ordinary propositional connectives plus ⇔:
A, B ::= ⊥ | Vi | ¬A | A H B | A ⇔ B (where Vi ∈ Vp).
The semantics of CSL is defined in terms of models based on distance spaces. A distance space is a pair (Δ, d) where Δ is a non-empty set, and d : Δ × Δ → R≥0 is a distance function satisfying the following condition 6
∀x, y ∈ Δ, d(x, y) = 0 iff x = y .	(ID) The distance between an object w and a non-empty subset X of Δ is defined by
d(w, X) = inf{d(w, x) | x ∈ X}. If X = ∅, then d(w, X) = ∞. If for every object w
and for every (non-empty) subset X we have the following property
inf {d(w, x) | x ∈ X} = min {d(w, x) | x ∈ X} ,	(MIN) we say that (Δ, d) is a minspace.
We next define CSL-distance models as Kripke models based on distance spaces:

Definition 2.1 [CSL-distance model]
A CSL-distance model is a triple M = (Δ, d, .M) where:
Δ is a non-empty set of objects.
d is a distance on Δ (so that (Δ, d) is a distance space).
.M : Vp → 2Δ is the evaluation function which assigns to each propositional variable Vi a set V M ⊆ Δ. We further stipulate:
⊥M = ∅ ,	(¬C)M = Δ − CM ,	(C H D)M = CM ∩ DM ,
(C ⇔ D)M =  w ∈ Δ d(w, CM) < d(w, DM)} .
If (Δ, d) is a minspace, M is called a CSL-minspace model. We say that a formula A is valid in a model M if AM = Δ. We say that a formula A is valid if A is valid in every CSL-distance model (CSL-minspace model).

6 Two well-known properties of symmetry and triangle inequality may be additionally considered; for a discussion we refer to [1].

From now on we restrict our consideration to minspace models, thus we write model instead of minspace model.
C£L is a logic of pure qualitative comparisons, this motivates an alternative semantics where the distance function is replaced by a family of comparison relations, one for each object. This semantics is called preferential semantics, similarly to the
semantics of conditional logics [11,10]. Preferential structures are equipped with a family of strict pre-orders indexed on objects: for three objects, x <w y may be interpreted as w is more similar to x than to y. We assume the following conditions on x <w y:
(modularity) 6x, y, z ∈ Δ, (x <w y) → (z <w y V x <w z) .
(centering) 6x ∈ Δ, x = w V w <w x .
(Limit Assumption) 6X ⊆ Δ, X /= ∅ → min≺w (X) /= ∅, where min≺w (X) = 
{y ∈ X | 6z(z <w y → z ∈/ X)} .
Definition 2.2 [C£L-preferential model] A C£L-preferential model is a triple ł = (Δ, (<w)w∈Δ, .M) where:
Δ is a non-empty set of objects (or possible worlds).
(<w)w∈Δ is a family of preferential relation satisfying the above conditions (i), (ii), and (iii).
.M is the evaluation function defined as in definition 2.1, except for ⇔:
(A ⇔ B)M =  w ∈ Δ Ex ∈ AM such that 6y ∈ BM, x <w y} .

Validity is defined in the same way as in Definition 2.1.
Distance models and preferential models provide an equivalent semantics of C£L (see [1]) in the sense that for each C£L-distance minspace model there is an equivalent C£L-preferential model and vice versa.
A sound and complete axiomatization of C£L is provided in [1] and it comprises the following axioms and rules:

(1)	ч(A ⇔ B) Н ч(B ⇔ A)	(2)	(A ⇔ B) → (A ⇔ C) Н (C ⇔ B)


(3)	A Н чB → (A ⇔ B)	(4)	(A ⇔ B) → чB


(5)	(A ⇔ B) Н (A ⇔ C) → (A ⇔ (B Н C))	(6)	(A ⇔ ⊥) → ч(ч(A ⇔ ⊥) ⇔ ⊥)

▶ (A → B)
(Mon) ▶ (A ⇔ C) → (B ⇔ C)	(Taut) Classical tautologies and rules.

A Tableaux Calculus for C£L
In [1] it is presented a tableau calculus for C£L that we recall here. A tableau is identified with a set of sets of formulas Γ1,..., Γn. Each Γi is called a tableau set. The calculus is called TC£L and it makes use of labels to represent objects of the domain. To understand the treatment of ⇔, let us consider formulas (A ⇔ B) and ч(A ⇔ B) under preferential semantics. We have:

w ∈ (A ⇔ B)M iff Ex(x ∈ AM ∧ 6z(z ∈ BM → x <w z)) .

But in minspace models, the right part is equivalent to:

w ∈ (A ⇔ B)M iff Eu ∈ AM and 6y(y ∈ BM → Ex(x ∈ AM ∧ x <w y)) .

We can hence introduce a pseudo-modality  w indexed on objects:

x ∈ ( wA)M iff 6y(y <w x → y ∈ AM) .

Thus we get the equivalence:
w ∈ (A ⇔ B)M iff AM /= ∅ and 6y(y ∈/ BM or y ∈ (ч wчA)M) .
This equivalence allows us to decompose ⇔-formulas in an analytic way. The tableau rules make also use of a universal modality (and its negation). The lan- guage of tableaux comprises the following kind of formulas: x : A, x : (ч) чA, x : (ч) yчA, x <y z, where x, y, z are labels and A is a C£L-formula. The meaning of x : A is the obvious one: x ∈ AM. The reading of the rules is the following: we apply a rule
Γ[E1,..., Ek]
Γ1 | ... | Γn
to a tableau set Γ if each formula Ei (1 ≤ i ≤ k) is in Γ. We then replace Γ with any tableau set Γ1,..., Γn. As usual, we let Γ,A stand for Γ ∪ {A}, where A is a tableau formula. The tableaux rules are shown in Figure 1, we refer to [1] 7 for a detailed explanation of the rules.
In [1] it is shown that the calculus TC£L is sound and complete with respect to the preferential semantics, whence with respect to minspace models.
Theorem 3.1 A formula A ∈ LCSL is satisfiable with respect to preferential seman- tics iﬀ it is contained in an open saturated tableau set.
The calculus TC£L presented above can lead to non-terminating computations due to the interplay between the dynamic rules (namely (F 2 ⇔), (F ) and (F 2 x)) and the static rules. It can be made terminating by defining a systematic proce- dure for applying the rules and by introducing appropriate blocking conditions. The

7 In the formulation of the rules for (F 1 ⇔) and (F 2 ⇔) given in [1] the formula x : ¬ ¬A in the consequent of (F 1 ⇔) and in the premise of (F 2 ⇔) was erroneously omitted. The formulation given here is the correct one.




(TH)
Γ[x : A H B]

Γ, x : A, x : B	(FH)
Γ[x : ч(A H B)]


Γ, x : чA | Γ, x : чB




(T ⇔)(∗)
Γ[x : A ⇔ B]


Γ,x : ч чA, y : чB | Γ,y : B, y : ч xчA	(NEG)
Γ[x : ччA] Γ,x : A




(F 1 ⇔)
Γ[x : ч(A ⇔ B)]


Γ,x :  чA | Γ,x : B | Γ,x : чA, x : чB, x : ч чA




(F 2 ⇔)(∗∗)
Γ[x : ч(A ⇔ B), x : чA, x : чB, x : ч чA]
Γ, y : B, y :  чA	(F 1 x)
Γ[z : ч xчA] Γ,x : чA | Γ,x : A



Γ[z :  xчA, y <x z]
(T  )( )
(F 2  )(∗∗)	Γ[z : ч xчA, x : чA]

x  ∗	Γ, y : чA, y : xчA


x	Γ, y <x z, y : A, y : xчA




(T )(∗)
Γ[x :  чA]


Γ, y : чA, y :  чA	(F )(∗∗)
Γ[x : ч чA] Γ, y : A



Γ[z <x u]
(Mod)(∗)
(	)(	)	Γ



Γ,z <x y | Γ,y <x u
Cent
∗∗∗ 


Γ,x <x y | Γ[x/y]



(*) y is a label occurring in Γ. (**) y is a new label not occurring in Γ. (***) x and
y are two distinct labels occurring in Γ.
Fig. 1. The tableau calculus TCSL.
systematic procedure simply prescribes to apply the static rules as far as possible be- fore the applying dynamic rules. To prevent the generation of an infinite tableau set however some restrictions on the application of the rules are needed. The non-trivial restrictions are those ones on (F 2 ⇔) and (F 2 x), they are called as usual blocking conditions and prevent the generation of infinitely many labels by performing a kind of loop-checking.
In order to define the blocking restrictions, we first define a total ordering и on the labels of a tableau set such that x и y for all labels x that are already in the tableau set when y is introduced. If x и y, we will say that x is older than
y. We further define Box+	= { xчA | y :  xчA ∈ Γ} and ΠΓ(x) = {A | A ∈
LCSL and x : A ∈ Γ}. The restrictions on rules application and the strategy are summarised in the next definition.
Definition 3.2 • (Static and dynamic rules) We call dynamic the following rules:
(F 2 ⇔), (F 2  x) and (F  ). We call static all the other rules.
(Rules restrictions)
Do not apply a static rule to Γ if at least one of the consequences is already in it.

Do not apply the rule (F 2 Σ) to a x : ч(A Σ B),x : чA, x : чB
if there exists some label y in Γ such that y : B and y :  xчA are in Γ.
if there exists some label u such that u и x and ΠΓ(x) ⊆ ΠΓ(u).
Do not apply the rule (F 2 x) to a z : ч xчA, x : чA
if there exists some label y in Γ such that y <x z, y : A and y :  xчA are in Γ.
if there exists some label u in Γ such that u и x and ΠΓ(x) ⊆ ΠΓ(u).
if there exists some label v in Γ such that v и z and v : ч xчA ∈ Γ and

+
Γ,x,z
Γ,x,v .

Do not apply the rule (F ) to a x : ч чA in Γ if there exists some label y such that y : A is in Γ.
(Systematic procedure) (1) Apply static rules as far as possible. (2) Apply a (non blocked) dynamic rule to some formula labelled x only if no dynamic rule is applicable to a formula labelled y, such that y и x.
It can be shown (see [1], Theorems 13 and 14) that (i) a tableau initialized with a C£L-formula and expanded according to Definition 3.2 always terminates and (ii) the restrictions preserve the completeness of the calculus. Thus the calculus provides a decision procedure for the logic, running in NEXPTIME. It follows that our tableaux calculus is not worst case optimal because C£L over minspaces is ExpTime-complete [15].

The theorem-prover CSL-lean
In this section we present CSL-lean, an implementation of the tableau calculus TC£L
of Figure 1 above. It is a Prolog program inspired by the “lean” methodology origi- nally introduced by leanTAP ([3,4]). The program CSL-lean implements a predicate
csl_lean_aux. Each clause of this predicate represents a tableau rule or axiom. Proof search is provided for free by the mere depth-first search mechanism of Pro- log, without any meta-level algorithm of search strategy. In this way, the philosophy underlaying the “lean” methodology is “to achieve maximal efficiency from minimal means” [3], that is to say to write short programs and exploit the power of Prolog’s engine as much as possible. It is worth noticing that CSL-lean is only inspired to the “lean” methodology, but it does not fit its style in a rigorous manner.

The main predicate
The tableau calculus TC£L is implemented by the predicate:
csl_lean_aux(Gamma, Labels, UsedBox, UsedIBOX, UsedCCS, UsedNIBOX, UsedNCCS, UsedNBOX, PrefRel, ProofTree).
which succeeds if and only if Γ is unsatisifable, where the set of formulas Γ is partitioned into the Prolog lists Gamma and PrefRel. Gamma is a list containing, for each label x occurring in a tableau set, a pair [X,Formulas] where Formulas is the list of all formulas F such that x : F ∈ Γ. In other words, formulas of each node are grouped by the labels. The list PrefRel contains lists [x,y,z], representing

formulas of the form x <y z. For instance, the set of formulas x :  чA, y : B, x :
C, x <x y, y :  xчB is represented by the list Gamma
[[x,[box (neg a),c]],[y,[b,ibox(x,neg a)]]]
plus the following list PrefRel
[[x,x,y]]
Labels are represented by Prolog’s constants. The argument Labels is the list of labels introduced in the current tableau set. It is to be noted that this list is sorted (by construction) in anti-chronological order. The predicate NewLabel is called by the dynamic rules to create a new label, which will be added on the head of the list. So the list Labels is also used to represent the chronological order и on the labels: we have x и y (that is to say x is older than y) if x appears after y in Labels.
As an example, to prove whether ч( P ) V (P Σ P ) is unsatisfiable or not, one queries CSL-lean with the goal
csl_lean_aux([[x,neg (box p) or (p < <- p)]], [x], [], [],
[], [], [], [], [], ProofTree).
ProofTree is the only output parameter. When the initial set of formulas Γ is unsatisfiable, then ProofTree matches with a Prolog functor tree representing a closed tableau for Γ.


Preventing redundant applications of the rules
In order to ensure the termination of the calculus, the prover CSL-lean implements the rule restrictions and the strategy of Definition 3.2. The application of the rules dealing with classical connectives is controlled in a standard way, namely by allowing their application only if the current set of formulas does not contain the formula(s) introduced by the rules in their conclusion(s). For instance, (NEG) is applicable to Γ[x : ччA] only if [x, A] does not belong to Gamma. For the rules (F 2 Σ), (F 2 x) and (F ), Prolog lists UsedNIBOX, UsedNCCS, and UsedNBOX are used. They contain the list of labelled formulas to which the corresponding rule has already been applied in the current tableau set. For instance, if (F 2 x) has already been applied to Γ[z : ч xчA, x : чA], then the list UsedNIBOX contains [z,neg ibox (x, neg a)], and the clause implementing the rule is no longer applicable to that formula in that tableau set. UsedBox, UsedIBox, and UsedCCS are lists of pairs of the kind [Formula,ListOfLabels], where ListOfLabels keeps track of the labels already used to apply, in the current tableau set, the rule associated to the top-level connective in Formula. These lists are also used in order to ensure the termination of the proof search, by restricting the choice of the label to those not belonging to ListOfLabels. For instance, UsedBox is a list of pairs of the form [box (neg A), ListOfLabels]. The rule (T ) is then applied to a formula x :  чA by introducing y : чA and y :  чA in the conclusion by choosing a label y only if y does not belong to ListOfLabels.

Handling the universal rules
The “universal 8 ” rules (T ), (T x), and (T Σ) are split in two clauses: the first one represents the first application of the rule to a formula x :  чA, y :  xчA or x : A Σ B (respectively), i.e when these formulas are not in UsedBox, UsedIBOX or UsedCCS (respectively). The rule is applied once to the formula, and then added to the corresponding “used formulas” list. The second clause selects a used formula from one of these lists, looks for a label to which the corresponding rule has not been applied, applies the rule to it, and mark this label as used for the corresponding formula. It is to be noted that the first clause implementing the application of the rule (T Σ) to a formula x : A Σ B applies it first to the original label x, and thus does not branch: only the branch with the tableau set Γ,x : чB, x : ч чA is generated, as the other would be trivially closed due to the presence of the formula x : ч xчA in the new tableau set.

Handling the dynamic rules
The clauses for the dynamic rules implements the restrictions (ii)(b), (iii)(b), (iii)(c) and (iv) of definition 3.2. The restriction (iv) is easy: before applying the rule (F ) to a formula x : ч чA, we check whether there is no label z such that z : A is in the current tableau set. This is done by the predicate exist_formula(A,Gamma): if this predicate succeeds, the rule is not applied.
For the other restrictions, two predicates are used: is_blocked_2b3b(X, Gamma, Labels) which succeeds if there is a label u older than x such that ΠΓ(x) ⊆ ΠΓ(u), and is_blocked_3c(Z, neg ibox(X, neg A), Gamma, Labels) which suc-
ceeds if there is a label u older than z such that u : ч xчA ∈ Γ and Box+ ⊆

+
x,u
. As mentioned before, the ordering of labels is directly encoded by the list

Labels. ΠΓ(x) is computed by the predicate extract_CSL_formulas(XFormulas,
PiX), where XFormulas) is the list of formulas labelled by x, and Box+ is computed
by extract_box_X(X, UFormulas, UBox).
Once a non-blocked dynamic rule has been applied to a formula x : ч чA, x : ч(A Σ B) or z : ч xчA, this formula is added to the list UsedNBOX, UsedNCCS or UsedNIBOX (respectively), to prevent multiple applications of these rules to the same formula. Therefore, an application of a dynamic rule may lead to create at most one new label.
To give an example, the clause implementing the rule (F  x2) is:
csl_lean_aux(Gamma, Labels, UsedBox, UsedIBOX, UsedCCS, UsedNIBOX, UsedNCCS, UsedNBOX, PrefRel,
tree(fibox2,[Z,neg ibox (X,neg A)],SubTree)):- member([Z,Formulas],Gamma),
member(neg ibox(X, neg A),Formulas),
\+memberchk([Z,neg ibox(X, neg A)], UsedNIBOX), memberchk([X, XFormulas],Gamma),

8 We call them universal because they contain a kind of implicit universal quantification.

memberchk(neg A, XFormulas),
\+is_blocked_2b3b(X, Gamma, Labels),
\+is_blocked_3c(Z, neg ibox(X, neg A), Gamma, Labels),!, newLabel(Labels,Y),
csl_lean_aux([[Y, [A,ibox(X, neg A)]]|Gamma],[Y|Labels],UsedBox, UsedIBOX, UsedCCS, [[Z, neg ibox(X, neg A)]|UsedNIBOX], UsedNCCS, UsedNBOX, [[Y,X,Z]|PrefRel], SubTree).
The first two predicates seek for a formula z : ч xчA. If one is found, then the third predicate checks whether the rule has already been applied to it or not. If not, we test the other precondition of the rule: is there a formula x : чA in Γ (predicates 4 and 5)? Then we check the blocking conditions: the sixth predicate tests the restriction (iii)(b), and the seventh the restriction (iii)(c). If the formula is not blocked, then we proceed with the application of the rule.




Search strategy and further improvements

To search a closed tableau for a set of formulas Γ, CSL-lean proceeds as follows. First of all, if Γ is an axiom, the goal will succeed immediately by using the clauses for the axioms. If it is not, then the first applicable rule will be chosen, e.g. if Gamma contains a formula [X,neg neg A], then the clause for (NEG) rule will be used, invoking csl_lean_aux on its unique conclusion. CSL-lean proceeds in a similar way for the other rules. The ordering of the rules is such that it implements the systematic procedure (static rules first, dynamic ones last, as seen in Definition 3.2.), together with some efficiency improvements. Experiments have shown that some small change in the rules application’s order can have a significant impact on the performances. Static rules can be divided in two groups: non-branching ones, and branching ones. Branching rules may strongly affect the performances. Thus we first saturate Γ with static non-branching rules, then non-branching ones, and finally we apply dynamic rules. Thus the ordering of clauses that seems to work better and that we have adopted in the current version is the following: (NEG), (TH), (T  ), (T Σ), (T  x), (F Σ 1), (F  x1), (TН), (Cent), (Mod), (F Σ 2),
(F  x2) and finally (F  ).
We further notice that the rule (F ) is the last one to be applied since the applications of the two other dynamic rules can create the label and the formula that fulfills (F ), making its application redundant (blocking condition (iv)). We need to control tightly the creation of new labels, in particular, because they may provoke a combinatory explosion due to the rules (Cent) and (Mod).
The rules of (Cent) and (Mod) have also a heavy impact on performances. Con- cerning these rules, a small optimisation is used: a preferential relation <x is gener- ated only if a formula y : xчA is in Γ (as the preferential relation is only needed for propagating x formulas).

Statistics and Performances
The performance of CSL-lean are promising. We have tested it running SICStus Prolog 4.0.2 on an Apple MacBook Pro 3.06 GHz Intel Core 2 Duo machine (4GB RAM), obtaining the results presented in the following tables.
First, we have tested CSL-lean by randomly generating generic formulas (valid, unsatisfiable and satisfiable). The test samples have been generated by fixing two parameters:
the number of propositional variables involved in the generated formulas;
the depth of connectives, i.e. the maximum level of nesting of connectives in the generated formulas.
The table below shows the number of proofs successfully completed (with either a positive or a negative answer) with respect to a fixed time limit. The first column shows the two parameters taken into account in generating test formulas mentioned above, namely the number of propositional variables and the depth of the formulas. For each row, we have considered 1000 test samples.


We have also tested CSL-lean over some unsatisfiable formulas, most of them ob- tained from negated instances of some axioms of C£L 9 . The following table shows the number of successes (with respect to 34 unsatisfiable formulas) within a fixed time limit:


As an example, CSL-lean answer in less than 1 millisecond on the following unsat- isfiable formula:

(P Σ (Q Σ Q)) Σ (P Σ (Q Σ Q))

9 The set of unsatisfiable formulas of CSL used to test CSL-lean is available at http://www.di.unito.it/
~pozzato/csllean/benchmark.txt.

Finally, although the logics are different, we have compared the performances of CSL-lean with two other theorem provers recently introduced, namely CondLean [14,12,13], a theorem prover for Conditional Logics, and KLMLean [5], a theorem prover for Kraus, Lehmann, and Magidor (KLM) Preferential logics [7,9]. The table shows the number of answers given by each theorem prover on a set of 90 formulas within 2 seconds. Those formulas are group by their depth:


The experimental results listed above show that the performances of CSL-lean are as good as those ones of other similar “lean” provers (for the respective logics) and can be considered promising. However, we intend to improve the performances of CSL-lean by experimenting standard optimization techniques.

Conclusions
In this paper we have described CSL-lean. To the best of our knowledge it is the first theorem prover for C£L Logics. To this concern, in [6] a tableau algorithm and a theorem prover is proposed for a logic of metric spaces comprising several kinds of distance quantifiers, although this logic is related to C£L, it cannot encode the Σ operator. Our prover is based on the tableau calculus presented in [1] and
implemented following the simple “lean” methodology of leanTAP ([3,4]). CSL-lean
is only inspired to the “lean” methodology, but it does not fit this style in a rigorous manner. The main differences between our implementation and a “ really-lean” one are the following:
CSL-lean makes use of some auxiliary predicates, such as is_blocked, newLabel, and member, whereas leanTAP only relies on Prolog’s clause indexing scheme and
backtracking;
the first argument of the predicate prove in leanTAP is the next formula to be
processed, which is always the leftmost formula in a single-sided sequent; this al- lows it to use the first-argument indexing refinements available in SICStus Prolog. CSL-lean does not present this characteristic, so it cannot take advantage of this refinement.
CSL-lean is also inspired by CondLean [14,12,13], a theorem prover for Conditional Logics, and KLMLean [5], a theorem prover for Kraus, Lehmann, and Magidor (KLM) nonmonotonic logics [7,9]. CSL-lean also contains a graphical interface writ-

ten in Java and it is available for free download at
http://www.di.unito.it/~pozzato/csllean/
Even if there is not a set of benchmarks of reference, the tests show that the perfor- mances of CSL-lean are encouraging.
In further research we intend to explore several directions. First of all the prover could be made more efficient. Of course many ad-hoc optimisations are possible. But as we have recalled the tableau calculus TC£L itself on which CSL-lean is based is not optimal. A theoretical study is then required about how to obtain an optimal prover. This could be the base of a substantially more efficient version. In order to improve efficiency some form of caching is needed to avoid the repeated generation of the same node and to early detect open and closed saturated nodes.
Another direction of research is the extension of the prover to a richer language of description logic family, first of all with nominals and then with quantified role restrictions. Preliminary results in [2] show that it is possible to extend the tableau method with nominals (ABOX and enumerative concepts).
Finally we can think of developing a similar prover for other C£L logics, notably for the one corresponding to symmetric minspaces. To this aim we should first find a suitable tableau calculus for it, what we are currently investigating.

References
Alenda, R., N. Olivetti and C. Schwind, Comparative concept similarity over minspaces: Axiomatisation and tableaux calculus, in: M. Giese and A. Waaler, editors, Proceedings of TABLEAUX 2009 (18th International Conference on Automated Reasoning with Analytic Tableaux and Related Methods), LNAI 5607 (2009), pp. 17–31.
Alenda,  R.,  N.  Olivetti  and  C.  Schwind,  Reasoning  about  concept similarity in ontologies: a ﬁrst step, Journées Nationales de l’IA Fondamentale (2009), available at www.lsis.org/olivetti/TR09/JIAF09-Alenda-Olivetti-Schwind.pdf.
Beckert, B. and J. Posegga, leantap: Lean tableau-based deduction, Journal of Automated Reasoning
15 (1995), pp. 339–358.
Fitting, M., leantap revisited, Journal of Logic and Computation 8 (1998), pp. 33–47.
Giordano, L., V. Gliozzi and G. L. Pozzato, KLMLean 2.0: A Theorem Prover for KLM Logics of Nonmonotonic Reasoning, in: N. Olivetti, editor, Proceedings of TABLEAUX 2007 (16th International Conference on Automated Reasoning with Analytic Tableaux and Related Methods), LNAI 4548 (2007),
pp. 238–244.
Hustadt, U., D. Tishkovsky, F. Wolter and M. Zakharyaschev, Automated reasoning about metric and topology., in: JELIA’06, LNAI 4160 (2006), pp. 490–493.
Kraus, S., D. Lehmann and M. Magidor, Nonmonotonic reasoning, preferential models and cumulative logics, Artificial Intelligence 44 (1990), pp. 167–207.
Kurucz, A., F. Wolter and M. Zakharyaschev, Modal logics for metric spaces: Open problems., in: S. N. Artëmov, H. Barringer, A. S. d’Avila Garcez, L. C. Lamb and J. Woods, editors, We Will Show Them!
(2) (2005), pp. 193–108.
Lehmann, D. and M. Magidor, What does a conditional knowledge base entail?, Artificial Intelligence
55 (1992), pp. 1–60.
Lewis, D., “Counterfactuals,” Basil Blackwell Ltd, 1973.
Nute, D., “Topics in Conditional Logic,” Reidel Publishing Company, Dordrecht, 1980.

Olivetti, N. and G. L. Pozzato, CondLean: A Theorem Prover for Conditional Logics, in:
M. Cialdea Meyer and F. Pirri, editors, Proceedings of TABLEAUX 2003 (Automated Reasoning with Analytic Tableaux and Related Methods), LNAI 2796 (2003), pp. 264–270.
Olivetti, N. and G. L. Pozzato, CondLean 3.0: Improving Condlean for Stronger Conditional Logics, in: B. Beckert, editor, Proceedings of TABLEAUX 2005 (Automated Reasoning with Analytic Tableaux and Related Methods), LNAI 3702 (2005), pp. 328–332.
Olivetti, N. and G. L. Pozzato, Theorem Proving for Conditional Logics: CondLean and GoalDuck, Journal of Applied Non-Classical Logics (JANCL) 18 (2008), pp. 427–473.
Sheremet, M., D. Tishkovsky, F. Wolter and M. Zakharyaschev, Comparative similarity, tree automata, and diophantine equations, in: G. Sutcliffe and A. Voronkov, editors, LPAR 2005, Lecture Notes in Computer Science 3835 (2005), pp. 651–665.
Sheremet, M., D. Tishkovsky, F. Wolter and M. Zakharyaschev, A logic for concepts and similarity, J. Log. Comput. 17 (2007), pp. 415–452.
Sheremet, M., F. Wolter and M. Zakharyaschev, A modal logic framework for reasoning about comparative distances and topology (2009), to appear in Annals of Pure and Applied Logic, 2009.
Stalnaker, R., A theory of conditionals, In N. Rescher (ed.), Studies in Logical Theory, American Philosophical Quarterly, Monograph Series no.2, Blackwell, Oxford (1968), pp. 98–112.
