Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 322 (2016) 19–34
www.elsevier.com/locate/entcs

Incremental Rebinding with Name Polymorphism 1
Davide Anconaa,2 Paola Gianninib,3 Elena Zuccaa,4
a DIBRIS, Universit`a di Genova, Italy
b CS Institute, DISIT, Universit`a del Piemonte Orientale, Alessandria, Italy

Abstract
We propose an extension with name variables of a calculus for incremental rebinding of code introduced in previous work. Names, which can be either constants or variables, are used as interface of fragments of code with free variables. Open code can be dynamically rebound by applying a rebinding, which is an association from names to terms. Rebinding is incremental, since rebindings can contain free variables as well, and can be manipulated by operators such as overriding and renaming. By using name variables, it is possible to write terms which are parametric in their nominal interface and/or in the way it is adapted, greatly enhancing expressivity. The type system is correspondingly extended by constrained name-polymorphic types, where simple inequality constraints prevent conflicts among parametric name interfaces.
Keywords: open code, incremental rebinding, name polymorphism, metaprogramming


Introduction
Our previous work [1,2] smoothly integrates static binding of the simply-typed lambda-calculus with a mechanism for dynamic and incremental rebinding of code. Fragments of open code to be dynamically rebound are values. Rebinding is done on a nominal basis, that is, free variables in open code are associated with names which do not obey α-equivalence. Moreover, rebinding is incremental, since rebind- ings, which are associations between names and terms, can in turn contain free variables to be rebound. Rebindings are first class values, and can be manipulated by operators such as overriding and renaming.
In this paper, we propose an extension of this previous work which supports, besides name constants, name variables, making it possible to write terms which are parametric in their nominal interface and/or the way it is adapted. For instance,

1 This work has been partially funded by “Progetto MIUR PRIN CINA Prot. 2010LHT4KM”.
2 Email: davide.ancona@unige.it
3 Email: giannini@di.unipmn.it
4 Email: elena.zucca@unige.it

http://dx.doi.org/10.1016/j.entcs.2016.03.003
1571-0661/© 2016 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

it is possible to write a term which corresponds to the selection of an arbitrary component of a module. We summarize here below the language features.
Unbound terms, of shape ⟨x1 '→ X1,..., xm '→ Xm | t⟩ are values representing “open code”. That is, t may contain free occurrences of variables x1,..., xm to be dynamically bound through the global nominal interface X1,..., Xm. To be used, open code should be combined with a rebinding X1 '→ t1,..., Xm '→ tm.
Rebinding application is incremental, that is, an unbound term can be par- tially rebound, and a rebinding can be open in turn. For instance, the term
⟨x'→X , y'→Y | x +y⟩ can be combined with the rebinding ⟨y'→Y | X '→y, Z '→y⟩, getting ⟨y '→ Y , yj '→ Y | yj+y⟩. This makes possible code specialization, simi- larly to what partial application achieves for positional binding.
Rebindings are first-class values as well, and can be manipulated by operators such as overriding and renaming.
A name X can be either a name constant N or a name variable α, and name abstraction Λα.t and name application t X can be used analogously to lambda- abstraction and application to define and instantiate name-parametric terms.
The type system in [2], supporting both open (non-exact ) and closed (exact ) types for rebindings, is correspondingly extended to handle name variables. Notably, types are extended with constrained name-polymorphic types of shape ∀α:c.T , where c is a set of inequality constraints X /=Y among names. Such constraints are necessary to guarantee that for each possible instantiation of α we get well-formed terms and types. For instance, the term Λα:α /= N .⟨ | N :int '→ 0, α:int '→ 1⟩ is a rebinding parametric in the name of one of its two components, which, however, must be different from the constant name N of the other component.
In the rest of this paper, we first provide the formal definition of an untyped version of the calculus (Section 2), followed by some examples showing its expressive power (Section 3). We then define a typed version of the calculus (Section 4), for which we state a soundness result. We show typing examples in Section 5, and finally in the Conclusion we discuss related and future work.

Untyped calculus
The syntax and reduction rules of the untyped calculus are given in Figure 1, where we leave unspecified constructs of primitive types such as integers, which we will use in the examples. We assume infinite sets of variables x , name constants N and name variables α. We use X , Y to range over names which are either name constants or name variables.
We use various kinds of sequences which represent finite maps: unbinding maps u from variables to names, rebinding maps r from names to terms, renamings σ from names to names, and substitutions s from variables to terms. We assume that order and repetitions are immaterial in such sequences. Moreover, in a term t which is well-formed, written ▶ t , they actually represent maps, e.g., in X1 '→ t1,..., Xm '→ tm, if Xi = Xj then ti = tj. Hence, we can use the following notations: dom and rng for the domain and range, respectively, u1 ◦ u2 for map composition, assuming rng (u2) ⊆ dom(u1), (u1, u2) for the union of two maps with disjoint

domains, and u1[u2] for the map coinciding with u2 wherever the latter is defined, with u1 elsewhere.

:: = ... | v | x	term
| t1 t2	application
| t X	name application
| t1>t2	rebinding operator
|!t	run
| t1  t2	overriding
| σ1nt uσ2	renaming operator
:: = x1 '→ X1,..., xm '→ Xm	unbinding map
:: = X1 '→ t1,..., Xm '→ tm	rebinding map
σ	:: = X1 '→ Y1,..., Xm '→ Ym	renaming
X , Y :: = N | α	names
:: = ... | λx.t | ⟨u | t⟩ | ⟨u | r⟩ | Λα.t	value
E	:: = [ ] | ... | E t | v E | E X | E >t | v >E |!E | E t evaluation context
| v  E | σ1nE uσ2
:: = x1 '→ t1,..., xm '→ tm	substitution


t −→ t j
(Ctx) E [t ] −→ E [t j]

(App)
(λx.t ) v −→ t{x '→ v}


(Name-App)	▶ t{α '→ N }
(Λα.t ) N −→ t{α '→ N }

(Reb-App)	rng (u2)∩dom(r )= $
⟨u|r⟩>⟨u1, u2|t⟩ −→ ⟨u, u2|t{x '→ r (u1(x ))|x∈dom(u1)}⟩

(Run)	(Over)
!⟨ | t⟩ −→ t	⟨u1 | r1⟩  ⟨u2 | r2⟩ −→ ⟨u1, u2 | r1[r2]⟩


(Rename)
σ1n⟨u | r⟩uσ2 −→ ⟨σ1 ◦ u | r ◦ σ2⟩

Fig. 1: Untyped calculus: syntax and reduction rules
Besides lambda-abstractions and values of primitive types, there are three new kinds of values in the calculus: unbound terms ⟨u | t⟩, rebindings ⟨u | r⟩ and name abstractions Λα.t .

An unbound term, e.g., ⟨x '→ N | x +1⟩, represents code which is not directly used but, rather, “boxed”, as the brackets suggest. This boxed code is possibly open, and can be dynamically rebound through a nominal interface.
Conversely, a rebinding represents code which can be used to dynamically rebind open code. A rebinding can be unbound as well, that is, its code can be open, as in ⟨x '→ N | N1 '→ 0, N2 '→ 1+x⟩. According to the sequence notation, an unbound term with an empty unbinding map is simply written ⟨ | t⟩, and analogously for a rebinding.
Name abstractions can be used to write terms which are parametric w.r.t. the nominal interface, e.g., Λα.⟨x '→ α | x +1⟩ is the parametric version of the above unbound term. Note that, differently from, e.g., [11], we take a stratified approach where names are not terms, to keep separate the conventional language, which is here lambda-calculus for simplicity, from the meta-level constructs, whose semantics is in principle independent. Hence, we have ad-hoc constructs for name abstraction and name application.
Besides values and variables, terms include compound terms constructed by the following operators: application, name application, rebinding, run, overriding, and renaming. They are illustrated together with reduction rules given in Figure 1.
Rule (Ctx) is the usual contextual closure.
Rule (App) is standard. The application of a substitution to a term, t{s}, is defined in the standard way. Note that a variable occurrence in the domain of an unbinding map behaves like a λ-binder. Hence, the variables in dom(u) are not free in ⟨u | t⟩, and not subject to substitution.
In a name application t X , t and X are expected to reduce to a name abstraction, and a name constant, respectively. The name abstraction is applied to the name constant, as modeled by rule (Name-App). The name substitution, t{α '→ N }, that is, substitution of a name variable with a name constant, is defined in the standard way. In particular, the only construct that introduces binders is name abstraction, whereas name substitution has to be propagated also to unbinding maps, rebinding maps, and renamings. Note that, by name substitution, we could obtain ill-formed terms, e.g., ⟨ | α '→ 0, N '→ 1⟩{α '→ N } gives ⟨ | ⟨ | N '→ 0, N '→ 1⟩⟩. In this case, the rule cannot be applied, as formally denoted by the side condition ▶ t{α '→ N }.
In a term t1>t2, the arguments of the rebinding operator t1 and t2 are expected to reduce to a rebinding and to an unbound term, respectively. When the rebinding is applied to the unbound term, rule (Reb-App), all the variables associated with
names provided by the rebinding (side condition rng (u2) ∩dom(r )= ∅) are replaced by the corresponding terms, and are therefore removed from the unbinding map of the unbound term. However, the unbinding map of the resulting unbound term is augmented with the unbinding map of the rebinding term. The condition dom(u) ∩ dom(u2) = ∅, implicitly required for the well-formedness of u, u2, can be always satisfied by applying a suitable α-renaming to one of the two terms. We also tacitly assume that the rule is applicable only when r (u1(x )) is defined for all x ∈ dom(u1), that is, rng (u1) ⊆ dom(r ). For instance,
⟨y '→ N2 | N1 '→ y +2, N3 '→ y⟩>⟨x '→ N1, y '→ N2 | x +y⟩
reduces to ⟨y '→ N2, yj '→ N2 | (y +2)+yj⟩.
In a term !t , the argument of the run operator is expected to reduce to an

unbound term with no names to be rebound, which can be unboxed, rule (Run). For instance, !⟨ | 0+1⟩ reduces to 0+1, which can then be evaluated. Unbound terms can be “unboxed” and executed through the run operator only after their open code has been completed through one or more applications of rebindings so that they do not contain unbound variables; for instance, the unbound term ⟨x '→ N | x +1⟩ can be made self-contained with the rebinding ⟨ | N '→ 0, N j '→ 1⟩.
In a term t1 t2, the arguments of the overriding operator are expected to reduce to two rebindings. Rule (Over) allows one to merge the two rebindings giving preference to the right one in case of conflict. Unbinding maps u1 and u2 are simply merged together (hence, names are shared). As it happens for rule (Reb-App), the implicit condition dom(u1) ∩ dom(u2)= ∅ can be always satisfied by applying a suitable α-renaming to one of the two terms. For instance,
⟨x '→ N1 | N2 '→ x 1, N3 '→ 1⟩ ⟨x '→ N1 | N3 '→ 2, N4 '→ x 2⟩ reduces to ⟨x '→ N1, x j '→ N1 | N2 '→ x 1, N3 '→ 2, N4 '→ x j 2⟩.
In a term σ1nt uσ2, the argument of the rebinding operator is expected to reduce
to a rebinding ⟨u | r⟩; we use the more coincise notation σ1nt and t uσ2 when σ2 and σ1 are the identity renamings, respectively. The renaming operator is used for adapting the nominal interfaces of the unbinding and rebinding map u and r , respectively, rule (Rename). With the renaming σ1 it is possible to merge names, while with σ2 one can duplicate and remove terms; for instance
(N1 '→ N2, N2 '→ N2)n⟨x '→ N1, y '→ N2 | N1 '→ 0, N3 '→ 1⟩u(N1 '→ N1, N2 '→ N1)
reduces to ⟨x '→ N2, y '→ N2 | N1 '→ 0, N2 '→ 0⟩. As for rule (Reb-App), we tac- itly assume that rule (Rename) is applicable only when rng (u) ⊆ dom(σ1) and rng (σ) ⊆ dom(r2) respectively hold.
Renamings are essential for adapting unbound terms and rebindings; renamings and name abstractions favor dynamic software adaptation and reuse. For instance the term
t = Λα1.Λα2.λxr .(xr u(N1 '→ α1, N2 '→ α2))>⟨x1 '→ N1, x2 '→ N2 | x1 x2⟩
is expected to take a rebinding xr with generic shape ⟨| α1 '→ t1, α2 '→ t2,.. .⟩, adapt it by renaming and then apply it to the unbound term ⟨x1 '→ N1, x2 '→ N2 | x1 x2⟩; as an example, t N3 N4 ⟨ | N3 '→ λx.x +1, N4 '→ 1⟩ reduces (in some steps) to 2.
Examples of use of name abstraction
In previous work [2] we have already analyzed the expressive power of the constructs for building unbound terms and rebindings, for overriding and renaming of rebind- ings, and for rebinding application to unbound terms. Such constructs support several programming notions, as dynamic scoping, rebinding, meta-programming and component-based programming. For instance, if we assume to extend the cal- culus with the let rec construct to define recursive functions, then the following declarations define a function pow supporting program specialization via generative programming:
let rec aux_pow = lambda n.
if n >0 then <x '→ X, y '→ Y | Y '→ x*y> > aux_pow (n -1) else <y '→ Y | y>


let pow = lambda n.
let f = < | Y '→ 1> > ( aux_pow n) in lambda x. !( < | X '→ x> > f) 
For instance, pow 3 evaluates to
lambda x. !( < | X'→x> > <x1 '→ X, x2 '→ X, x3 '→ X | x3*x2*x1 *1 >).

Therefore, pow 3 2 rewrites to !(< | X'→2> > <x1 '→ X, x2 '→ X, x3 '→ X | x3*x2*x1*1>), which rewrites to ! < | 2*2*2*1>, which rewrites to 2*2*2*1, and, finally, to 8.
Here we focus on the expressive power of the newly introduced constructs for name manipulation, and show how they favor generic and meta-programming.


Module/component selection
Rebinding terms directly support the notion of module/component. We have already shown [2] how member selection of closed (that is, where all dependencies have been resolved) modules/components can be encoded. For instance, the fol- lowing term encodes an operator which selects the Y member of a (closed) module represented by a rebinding:
ts =lambda x. !( x > < y '→ Y | y >)

For instance the term ts < | X'→0, Y'→42> evaluates to 42. However, in this way selection can be encoded only for a single fixed name constant (Y in this specific case).
With the newly introduced construct of name abstraction, a generic definition of the selection operator can be provided by a single term of the calculus.
t′ =Lambda α. lambda x. !( x > < y '→ α | y >)
In this way, the same term t′ can be used for selecting members associated with

arbitrary names. For instance, if t =< | F'→lambda n.n+1, N'→ 41>, then (t′
F t) (t′
N t)

evaluates to 42.
In mainstream object-oriented languages such meta-programming facilities are supported either by specific libraries for reflection, or by more flexible constructs, as the JavaScript bracket notation. In all cases, no static checking is performed to ensure that the selected names will be always defined at runtime.
For instance, with the use of the bracket notation in JavaScript 5 it is possible to define the following function:
function select ( name , object ){ return object [ name ]}

The notation e1[e2] allows programmers to access properties of the object denoted by e1 whose name is defined by the arbitrary expression e2. So, select ("val",{val:42}) returns 42, whereas select ("foo",{val:42}) is undefined.
As we will see in Section 5, the term t′ =Lambda α. lambda x. !(x > < y '→ α | y >)
can be typed statically, to ensure that only defined members are selected.

5 All examples presented here are compliant with the ECMAScript 5 syntax, although some of them could be written in a slightly more concise way by using the new features and shorthands introduced with the recently released specification of ECMAScript 6.

Dynamic adaptation of mixins
Mixin classes [3] and mixin modules [4] are notions commonly employed in generic programming to support software reuse.
Among statically typed mainstream object-oriented programming languages, mixins are only supported by C++, with templates, see [14]. The following class template defines class CheckedMixin which is parametric in its base class, represented by the template parameter B.
template <class B>
class CheckedMixin : public B { public :
static int checked_op ( int value ) { if( B:: in_bounds ( value ))
return B:: op( value ); else
throw std :: logic_error (" Illegal  argument ");
}
};
The mixin adds the static method checked_op, and can be instantiated with classes defining op(int) and in_bounds(int), as in the following code fragment:
class Sqrt { public :
static int op( int value ) { return sqrt ( value ); } static bool in_bounds ( int value ){ return value >= 0; }
};
class Checked_sqrt : public CheckedMixin <Sqrt > { }; int main () {
assert  (  Checked_sqrt  ::  checked_op  (4)==2)       ; assert  (  Checked_sqrt  ::  op  (  -4)!=2)         ; assert ( Checked_sqrt :: checked_op ( -4)!=2) ; // throws logic_error 
}

Thanks to the generic code defined by CheckedMixin, class Sqrt is extended with the static method checked_op with checks whether the argument is non negative, before applying the static method op which, in turn, applies the library function 6 sqrt.
The main limitation of mixins implemented with C++ class templates is their inability to be adapted to classes where their methods do not match the name con- vention imposed by the mixin; in the case of CheckedMixin, the parametric base class must provide the static methods op(int) and in_bounds(int). Furthermore, typecheck- ing of C++ templates is not compositional, therefore such constraints are checked every time the template is instantiated.
Dynamic languages, as JavaScript [9], allow dynamic adaptation of mixins.
In this case the mixin is defined by a function 7 taking three arguments that are expected to contain strings: op denotes the name of the operation that has to be checked, in_bounds denotes the name of the operation that performs the check, and new_op denotes the name of the newly added operation corresponding to the checked version of op.
function CheckedMixin ( op , in_bounds , new_op ){ this [ new_op ] = function ( x){

6 Function sqrt does not perform any check, unless math_errhandling has the constant MATH_ERREXCEPT
set.
7 We recall that JavaScript is a prototype-based language where objects are dynamically created through functions, although recently an equivalent class-based notation has been introduced in ECMAScript 6.


if (! this [ in_bounds ]( x)) throw " Illegal argument "
return this [ op ]( x)
}
}
Thanks to the bracket notation the programmer can pass to the CheckedMixin function the proper strings to adapt the instances of CheckedMixin.
sqrt ={ // a new object with two properties 
sqrt  :  Math  .  sqrt   , check_arg : function ( x){ return x >=0} 
}
CheckedMixin . prototype = sqrt
// all instances of CheckedMixin will have sqrt as prototype chk_sqrt = new CheckedMixin (" sqrt "," check_arg "," checked_sqrt ") chk_sqrt . sqrt ( -4)    //   evaluates   to   NaN chk_sqrt . checked_sqrt (4)   //  evaluates  to  2 chk_sqrt . checked_sqrt ( -4) // throws " Illegal argument "
The same function CheckedMixin can be used to extend an object which computes the
log function.
log ={ // a new object with two properties 
log  :  Math  .  log10   , check_arg : function ( x){ return x >=0} 
}
CheckedMixin . prototype = log
// all instances of CheckedMixin will have log as prototype chk_log = new CheckedMixin (" log "," check_arg "," safe_log ") chk_log . log ( -10) // evaluates to NaN
chk_log . safe_log (10) // evaluates to 1
chk_log . safe_log ( -10) // throws " Illegal argument "
Thanks to the support for name manipulation, mixin adaptation and application can be expressed in our calculus; furthermore, as shown in Section 4, compositional typechecking ensures the type correctness of mixin adaptation and application. The JavaScript example given above can be recast 8 in our calculus as follows:
tm =Lambda αop . Lambda αin b . Lambda αn op . lambda r. let n op =
!( r > < op '→ αop , in b '→ αin b | lambda x. if ( not in b ( x)) -1 else op (x) >) in r Q < | αn op '→ n op >

As in the previous example, the mixin takes three names αop, αin b, and αn op, corresponding to the name of the operation that has to be checked, the name of the operation that performs the check, and the name of the newly added operation which is the checked version of the operation αop. Then it takes a rebinding r, which is expected to provide a definition for the operations αop, and αin b, and that is applied to an unbound term which defines the new operation in terms of the operations αop, and αin b provided by the rebinding. The result of the application of the rebinding is run to get the value corresponding to the new operations, and, finally, the rebinding (which plays the role of a module) is extended with the new component by means of the overriding operator.




8 Since the calculus does not support exceptions, in case the bounds are not verified the function simply returns the conventional value -1.

Typed calculus
Figure 2 shows the syntax of the typed calculus, which is extended by annotating variables and names with types, and name variables with constraints, as explained in detail below.

Fig. 2: Typed calculus: syntax
Constraints are of shape X /= Y . A set of constraints c is consistent under name variables A, written A ▶ c, if variables occurring in c belong to A, and, moreover, X /=X /∈ c for all X . We say that X could be equal to Y under c, written c |= X =? Y , if X /= Y /∈ c.
Types include function types, constrained name-polymorphic types, unbound types ⟨Δ | T⟩, and rebinding types ⟨Δ1 | Δ2⟩ν. For simplicity we omit basic types for primitive values such as integers or booleans. In the explanations in the follow- ing, we illustrate in more detail the new feature of the type system represented by constrained name-polymorphic types. The reader can refer to our previous work for more explanations and examples on unbound types and open/closed rebinding types.
A type T is well-formed under the set of name variables A and constraints c if the judgment A; c |= T OK is derivable by the rules of Figure 3. We write A ▶ X to indicate that X belongs to A, if it is a name variable.

Fig. 3: Well-formed types, rebinding maps, and renamings
Function types correspond to lambda abstractions, where the variable is now

annotated with a type.
Constrained name-polymorphic types correspond to name abstractions, where the name variable is now annotated with constraints. Constraints are necessary to guarantee that for each possible instantiation of α we get well-formed terms and types. For instance, the term Λα:α /= N .⟨ | N :int '→ 0, α:int '→ 1⟩ is a rebinding parametric in the name of one of its two components, which, however, must be different from the constant name N of the other component.
Unbound types ⟨Δ | T⟩ correspond to open code: Δ is a sequence X1:T1, .., Xm:Tm called name context. The type specifies that the open code needs the rebinding of the names Xi to terms of type Ti (1 ≤ i ≤ m) in order to correctly produce a term of type T . An unbound type is well-formed under name variables A and constraints c only if types occurring in the sequence are well-formed, name variables occurring in the sequence belong to A, and names which could be equal under c are mapped in the same type, as modeled by rules (WF-unb-type) and (WF-name-ctx) in Figure 3.
Rebinding types ⟨Δ1 | Δ2⟩ν correspond to rebindings; the name context Δ1 specifies the names which the rebinding depends on, while the name context Δ2 = X1:T1,..., Xm:Tm specifies that the rebinding map associates each name Xi with a term of type Ti (1 ≤ i ≤ m). If the type is annotated with ν = +, then we say that the type is open (or non-exact ), and the rebinding map is allowed to contain more associations than those specified in the name context. The annotation ν = ◦ is used for closed (or exact ) types, to enforce that the domain of the rebinding map exactly coincides with the domain of Δ2. In the typing rules we will use the binary operator H over annotations, defined by ◦H ν = ν H◦ = ν, and + H + = +. A rebinding type is well-formed under name variables A and constraints c only if types occurring in the sequences Δ1 and Δ2 are well-formed, name variables occurring in the sequences belong to A, and names which could be equal under c are mapped in the same type, analogously to what is required for an unbound term, as modeled by rules (WF-reb-type) and (WF-name-ctx) in Figure 3.
Renamings, as well as values, evaluation contexts, substitutions, and name sub- stitutions are defined as for the untyped language.	Figure 3 also defines well- formedness of rebinding maps under constraints c, and of renamings under name variables A and constraints c. (Untyped) rebinding maps are well-formed if names which could be equal under c are mapped in the same term, as modeled by rule (WF-reb-map). Note that well-formedness of type annotations is separately checked by rule (WF-name-ctx). Well-formedness of renamings requires that name vari- ables belong to A, and names which could be equal under c are mapped in the same name, as modeled by rule (WF-ren).
The subtyping relation is defined in Figure 4.
Subtyping between function types is standard. A constrained polymorphic type can be made more specific by adding more constraints or making more specific the type obtained by instantiation.
Subtyping between unbound types obeys a rule similar to that for function types: the relation is contravariant in the name context, and covariant in the type returned after rebinding. Subtyping between name contexts is defined by the usual rule for record subtyping: both width and depth subtyping are allowed. Width and depth










Fig. 4: Typed calculus: subtyping rules
subtyping are also allowed between rebinding types, in case the right-hand-side (rhs for short) type in the relation is open, because a closed type can always be considered as an open type, but not the other way around. This is a consequence of the fact that closed types express more restrictive constraints on rebinding maps. For instance, the rebinding ⟨| X :TX '→ tx , Y :TY '→ ty ⟩ has, for any Δ, type ⟨Δ | X :TX, Y :TY ⟩ν for both ν = + and ν = ◦, whereas it has type ⟨Δ | X :TX⟩ν only for ν = +; note also that the most precise type for this term is ⟨ | X :TX, Y :TY ⟩◦. When the rhs type in the subtyping relation is a closed rebinding type, then the lhs type must be closed as well, and, therefore, it must define the same set of names; in this case only depth subtyping is allowed.
Finally, rule (Sub-constr) models subtyping under name variables and con- straints.
The typing judgment has shape A; c;Γ ▶ t : T , meaning that the term t has type T under the name variables A, constraints c, and context Γ providing types for the free variables. The typing rules are given in Figure 5.
The type system supports subsumption, rule (T-Sub). Note that the second premise implies both types to be well-formed.
Rule (T-Abs) for lambda abstractions is standard.
In rule (T-Name-Abs), the term Λα:cj.t is well-typed if the introduced con- straints cj are consistent under the current name variables augmented by α, and t is well-typed taking the union of the constraints.
In rule (T-Unb), the term ⟨u | t⟩ is well-typed if the name context extracted from u by the auxiliary function name ctx , say, X1:T1,..., Xm:Tm , is well-formed under the current name variables and constraints, that is, Xi belongs to A if it is a name variable, and, if Xi could be equal to Xj under c, then they are mapped in the same type. The resulting type T is obtained by typing t in the context updated by that extracted from u by the auxiliary function ctx . Both auxiliary functions are defined at the bottom of Figure 5.
In rule (T-Reb), the term ⟨u | r⟩ is well-typed if the name contexts extracted from u and r are well-formed under the current name variables and constraints. Moreover, r must be well-formed under the current constraints, that is, names which could be equal are mapped in the same term. Finally, for each name in the domain of r , annotated with type, say, T , the associated term must have type T in the context updated by that extracted from u by the auxiliary function ctx . Note





























Fig. 5: Typed calculus: typing rules that an exact type can be always deduced.
Rules (T-Var) and (T-App) are standard.
In rule (T-Name-App), the term t X is well-typed if X belongs to A if it is a name variable, t has a constrained polymorphic type 6α:cj.T , and by replacing α by X in the constraints cj we do not get inequalities of shape Y /=Y . In this case, the resulting type is obtained by replacing α by X in T . The obvious definitions of replacing a name variable by a name in constraints and types are omitted.
In rule (T-Over), overriding t1 t2 is well-typed only if t1 and t2 have rebinding types; the name context of the type of t1 is deterministically split in two parts.
The part Δj corresponds to names which are also defined in t2, as expressed by
the side condition dom(Δj ) ⊆ dom(Δ2), hence are overridden, whereas the part Δ1 corresponds to names which are not defined in t2. If Δ1 = ∅, then t1 is fully

overridden, hence the name context of the result is that of t2; in this particular case the type of t2 is allowed to be open, whereas if Δ1 /= ∅, then t2 is required to have a closed type, otherwise it would not be possible to correctly identify Δ1.
The previously defined operator H combines the two annotations ν1 and ν2 so that the resulting type is closed if and only if both types of t1 and t2 are closed.
Note that, due to the presence of name variables, besides names which are neces- sarily overridden, there are names which could be overridden in some instantiation. For instance, in the term Λα:α /= N1.⟨ | N1:T1 '→ t1, N2:T2 '→ t2⟩ ⟨ | α:int '→ 1⟩, the name N1 is never overridden, whereas the name N2 could be overridden for α = N2. The name context which is assigned to the overriding term is that cor- responding to the case of no overriding, that is, N1:T1, N2:T2, α:int in this case. However, since this name context must be well-formed under the constraints α /= N1, the type N2 must necessarily be int, so that we get a well-formed type even for the instantiation α = N2.
Rule (T-Run) states that a term of unbound type can be safely run only if its name context is empty, that is, all variables have been already properly bound in the code.
The typing rule (T-Reb-App) for rebinding application t1>t2 is similar to the typing rule for overriding: to correctly identify the names in t1 that are not neces- sarily bound, denoted by Δ1, the rule requires an exact type for t2, except when
Δ1 = ∅ (that is, all names are bound) for which an open type is allowed as well. This is due to the fact that the bound names of t1 must have the same type of the corresponding names in t2, while additional names in t2 not specified in the open type of t2 might be used for binding names of t1 with incompatible types. Note that by applying subsumption, it is always possible to bind a name with a term whose type is a subtype of the expected type.
Finally, in rule (T-Rename) for renaming, the two renamings must be well- formed under current name variables and constraints, that is, the newly introduced names must exist, and names which could be equal are mapped in the same name. The name contexts of the resulting type are propagated from the original ones by the auxiliary operators σ ◦ Δ and Δ ◦ σ, both partial, defined at the bottom of Figure 5. Note that if two names X and Y are mapped by σ1 in two names which could be equal, then X and Y must have the same type, as formally expressed by requiring the well-formedness of the name context σ1 ◦ Δ1.
Soundness of the type system w.r.t. the operational semantics states that well- typed terms do not get stuck. This is derived from the subject reduction and progress properties that follows.
Theorem 4.1 (Subject Reduction) Let t be such that, for some Σ and T we have Σ ▶ t : T. If t −→ t j, then Σ ▶ t j : T. 
Theorem 4.2 (Progress) Let t be such that, for some T we have ∅; ∅; ∅ ▶ t : T. Then either t is a value or for some t j, we have that t −→ t j.

Examples of typing
In this section we consider the typed version of the examples in Section 3.

Module/component selection
We can define the typed version of the term which corresponds to generic selec- tion of closed modules in the following way:
t′′ =Lambda α:$. lambda x:⟨ | α:T⟩+ . !( x > < y:T '→ α | y >)

The parameter x must be a rebinder without dependencies, otherwise the run oper- ator ! could not be safely applied; its type is open, because additional components are allowed to be present; the only component that is required to be defined must have the name denoted by the name variable α, otherwise the rebinder application x > < y '→ α | y > would not return an unbound term without dependencies, and the application of the run operator would be unsafe. The type T associated with α is arbitrary, but must be fixed once and for all; a more generic definition could be given if the calculus could support standard parametric polymorphism, besides name polymorphism. We leave for further investigation an extension of the calculus and its type system towards this direction.
No constraints have to be imposed on α, since no name conflicts can ever arise in this case.
According to the rule (T-Name-Abs), ∅; ∅; ∅ ▶ tjj : 6α:∅.⟨ | α:T⟩+ → T , be-
cause
{α}; ∅; ∅▶ λx:⟨ | α:T⟩+.!(x>⟨y:T '→ α | y⟩): ⟨ | α:T⟩+ → T
{α}; ∅; x:⟨ | α:T⟩+ ▶!(x>⟨y:T '→ α | y⟩): T
{α}; ∅; x:⟨ | α:T⟩+ ▶ x>⟨y:T '→ α | y⟩ : ⟨ | T⟩
{α}; ∅; x:⟨ | α:T⟩+ ▶ x : ⟨ | α:T⟩+
{α}; ∅; x:⟨ | α:T⟩+ ▶ ⟨y:T '→ α | y⟩ : ⟨α:T | T⟩
In particular, the judgment (iii) is derivable by instantiation of rule (T-Reb- App) where Δj, Δ1, and Δ2 are empty, and Δ = α:T .


Dynamic adaptation of mixins
The example of dynamic mixin adaptation shown in Section 3 can be annotated with types in the following way, where T1 = int → int, T2 = int → bool:
tm =Lambda αop :$. Lambda αin b :αin b /=αop . Lambda αn op :αn op /=αop , αn op /=αin b . lambda r: ⟨ | αop :T1, αin b :T2⟩+ .
let n op:T1 =
!( r > <op:T1 '→ αop , in b:T2 '→ αin b | lambda x:int. if( not in b ( x)) -1 else op (x) >) in r Q < | αn op :T1 '→ n op >

The constraints αin b/=αop, and αn op/=αin b are necessary to ensure that the term tm is well-typed, since the type T1 associated with αop, and αn op is different from the type T2 associated with αin b. On the other hand, the constraint αn op/=αop is not strictly required to ensure type safety, since both name variables are associated with the same type T1. However, it guarantees that the mixin defined by tm is additive, in the sense that the component αop required to be provided from r will not be overridden by the addition of the component αn op; if the constraint αn op/=αop is removed, then the mixin can be applied in a more permissive way, since the user is free to decide whether to override or not component αop with αn op.

The typing judgment
∅; ∅; ∅▶ tm : 6αop:∅.6αin b:c1.6αn op:c2.
⟨ | αop:T1, αin b:T2⟩+ →⟨ | αop:T1, αin b:T2, αn op:T1⟩+
can be derived for the term tm, with c1=αin b/=αop, and c2=αn op/=αop, αn op/=αin b.
In particular, by rule (T-Reb) it is possible to derive
A; c1, c2; n op:T1 ▶⟨ | αn op:T1 '→ n op⟩ : ⟨ | αn op:T1⟩○
where A = {αop, αin b, αn op}, and, by rule (T-Over) is possible to derive
A; c1, c2; n op:T1 ▶ r ⟨ | αn op:T1 '→ n op⟩ : ⟨ | αop:T1, αin b:T2, αn op:T1⟩+
by instantiating the rule with Δ and Δj empty, Δ1 = αop:T1, αin b:T2, and Δ2 =
αn op:T1. The rule is applicable because the judgment A; c1, c2 |= Δ1, Δ2 OK is derivable from rule (WF-name-ctx), thanks to the two constraints αin b/=αop, and αn op/=αin b in c1, c2.

Conclusion
We proposed a calculus which integrates standard static binding with incremental rebinding of code based on a parametric nominal interface. That is, names, which can be either constants or variables, are used as interface of fragments of code with free variables, which can be passed around and rebound. By using name variables, it is possible to write terms which are parametric in their nominal interface and/or in the way it is adapted, greatly enhancing expressivity. The type system is based on constrained name-polymorphic types, where simple inequalities constraints prevent conflicts among parametric name interfaces. We have shown how to express type- safe dynamic adaptation of code, in particular, we showed how to express mixins. Similar results can be achieved in dynamically typed languages, such as JavaScript or through the use of reflection. However, in these settings we loose the possibility of expressing type constraints that can be statically checked. In C++ with multiple inheritance and templates we can define mixins, but we have to know the names of the methods that will be mixed in.
This work continues a stream of research on foundations of binding mechanisms, started with [8,7]. The goal was to provide a unifying foundation for dynamic scoping, rebinding of marshalled computations, meta-programming features, and operators present in calculi for modules. Classical (ad-hoc) models for dynamic scoping are [10] and [6], whereas the λmarsh calculus of [5] supports rebinding w.r.t. named contexts (not individual variables). The meta-programming features of our calculus are orthogonal to the one of MetaML [15], since, on one side, we do not have the analogous of the escape annotation of MetaML forcing evaluation inside boxed code, but on the other, our rebinding construct avoids the problem of unwanted variable capturing. Module calculi are described, e.g., in [4].
In future work we plan to add polymorphic types, so that name polymorphism can be more effectively used and also explore the relations between our name ab- straction and the one provided by languages of the family of FreshML [13,12], where

it is possible to compute with syntactical data structures involving names and name binding in a statically typed setting.
Acknowledgment
We are grateful to the anonymous reviewers for their useful suggestions and remarks.

References
D. Ancona, P. Giannini, and E. Zucca. Reconciling positional and nominal binding. In S. Graham- Lengrand and L. Paolini, editors, ITRS’12 - Intersection types and Related Systems, 2013.
D. Ancona, P. Giannini, and E. Zucca. Type safe incremental rebinding. Mathematical Structures in Computer Science, FirstView:1–29, 2015.
D. Ancona, G. Lagorio, and E. Zucca. Jam–designing a Java extension with mixins. ACM Transactions on Programming Languages and Systems, 25(5):641–712, 2003.
D. Ancona and E. Zucca. A calculus of module systems. Journal of Functional Programming, 12(2):91– 132, 2002.
G. Bierman, M. W. Hicks, P. Sewell, G. Stoyle, and K. Wansbrough. Dynamic rebinding for marshalling and update, with destruct-time λ. In ICFP 2003, pages 99–110. ACM Press, 2003.
L. Dami. A lambda-calculus for dynamic binding. Theoretical Computer Science, 192(2):201–231, 1997.
M. Dezani-Ciancaglini, P. Giannini, and E. Zucca. Intersection types for unbind and rebind. In
E. Pimentel, B. Venneri, and J. Wells, editors, ITRS’10, vol.45 of EPTCS, pages 45–58, 2010.
M. Dezani-Ciancaglini, P. Giannini, and E. Zucca. Extending the lambda-calculus with unbind and rebind. RAIRO - Theoretical Informatics and Applications, 45(1):143–162, 2011.
D. Flanagan. JavaScript: The Definitive Guide. O’Reilly Media, fourth edition edition, 2011.
L. Moreau. A syntactic theory of dynamic binding. Higher-Order and Symbolic Computation, 11(3):233–279, 1998.
A. Nanevski. From dynamic binding to state via modal possibility. In PPDP’03, pages 207–218. ACM, 2003.
A. M. Pitts and M. R. Shinwell. Generative unbinding of names. Logical Methods in Computer Science, 4(1), 2008.
M. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: programming with binders made simple.
SIGPLAN Notices, 38(9):263–274, 2003.
B. Stroustrup. The C++ Programming Language. Addison-Wesley Professional, fourth edition edition, 2013.
W. Taha and T. Sheard. MetaML and multi-stage programming with explicit annotations. Theoretical Computer Science, 248(1-2):211–242, 2000.
