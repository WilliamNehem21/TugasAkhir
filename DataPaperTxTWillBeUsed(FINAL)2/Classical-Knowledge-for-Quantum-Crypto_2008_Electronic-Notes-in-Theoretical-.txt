

Electronic Notes in Theoretical Computer Science 192 (2008) 39–58
www.elsevier.com/locate/entcs

Classical Knowledge for Quantum Cryptographic Reasoning
Vincent Danos 1
University of Edinburgh, U.K.
Ellie D’Hondt2
Vrije Universiteit Brussel & FWO, Belgium

Abstract
We prove that quantum key distribution is secure against several types of attacks within the framework of classical knowledge knowledge for quantum systems, a formal model which was developed in [8]. In particular we rephrase security as a logical property and use meta-logic reasoning on the finite state machine corresponding to the quantum key distribution protocol. While these security issues have been studied before, it is the logical-based approach that is original here.
Keywords: Quantum cryptography, security, formal verification, meta-logic reasoning.


Introduction
Quantum computation proved to be very influential in the area of quantum cryp- tography, with two of the earliest and best-known applications in this area: Shor’s algorithm for factoring prime numbers [23] and quantum key distribution (QKD) [2]. In this paper we initiate the investigation of quantum cryptography through for- mal methods. In particular we exhibit a preliminary analysis of the security of QKD against several types of attacks through meta-logic reasoning. This type of cryptanalysis is much needed since, similar to the situation with classical security protocols, there have been quantum protocols designed and proved to be safe in theory, only for their attacks to be found and their security proofs violated later, ei- ther by further theoretical analysis or by taking implementation issues into account. The problem is that while cryptography provides precise mathematical definitions

1 Email: vdanos@ inf.ed.ac.uk
2 Email: Ellie.DHondt@vub.ac.be

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.026

of particular protocols and their security, these definitions are usually at a low level of abstraction. This makes it hard to analyse different protocols systematically and see how properties evolve when protocols are combined. Also, it is difficult to gauge how well these definitions capture the realities of an actual implementation. Formal methods, on the other hand, are based on well-defined protocol languages which support a systematic presentation of protocols and properties. Most importantly, they provide tool support for automated proof techniques. Such tools are particu- larly useful for analysis of distributed protocols (and thus cryptography), for which proofs are particularly tedious and error-prone if done by hand.
Formal analysis is a necessity still for QKD, even though the quantum commu- nity considers its security analysis as a solved problem. This is because a mathe- matical proof on the theoretical security of QKD does not guarantee actual security in a practical setting. Hardware issues are not captured in theoretical proofs, and these are important in security, as they can result in backdoors for breaking the system (an example is the so-called timing attack for RSA). Formal methods are more flexibly adapted to these situations and hence can cover a range of different situations.
Concretely we rely on a two-level approach. At the base level the protocol to be analysed is specified in the language of quantum networks [4], a protocol speci- fication language for distributed quantum computations with evaluation rules and a formal semantics. On top of this we have a epistemic-temporal logical framework suitable for meta-logic analysis of the protocol under consideration, first developed in [8]. The idea of developing formal models to reason about knowledge has proved to be very useful for distributed systems [16,15,12]. Epistemic logic provides a nat- ural framework for expressing the knowledge of agents in a network, allowing one to make quite complex statements about what agents know, what they know that other agents know, and so on. Moreover, combining epistemic with temporal logic, one can investigate how knowledge evolves over time in distributed protocols, which is useful both for program analysis as well as formal verification. Whereas the afore- mentioned earlier developments were defined independent of cryptographic issues, an important realisation is that cryptographic properties can be recast in terms of knowledge. Indeed in cryptography many issues, such as security and identification, are all about knowledge. For example, can an agent learn about the presence of an eavesdropper, or can an agent be sure the protocol’s goal has been achieved? Reasoning about knowledge is a platform from which one can investigate these and other cryptographic issues in an intuitive yet systematic way.
Research into formal methods for distributed quantum computation is relatively recent and hence not very prolific. Several formal languages for protocol specifica- tion were developed, either in the flavour of classical process calculi [17,13,4] or in terms of dynamic logic [1]. Some of these frameworks have been augmented with logical tools for protocol analysis: both [14] and [8] use meta-logic reasoning to assert correctness properties on top of non-logical base language, though only the latter defines epistemic operators. In fact knowledge for quantum distributed sys- tems was defined earlier in [24] independently of a protocol specification language.

However, as we explain in more detail in Sec. 3, a more suitable notion of knowledge, which is essentially classical, is the one developed in [8]. Epistemic extensions of models based on dynamic logic are evidently more natural: here there is the work in [21,22], which mostly concerns the analysis of classical security protocols but has been applied to quantum systems as well. Note however that this algebraic 1-level approach is very different from the 2-level model-checking techniques for protocol analysis mentioned above. While any model that allows protocol analysis can in principle be applied in a cryptographic setting, none of the works mentioned above proposes an applicable formal framework for automatic cryptanalysis of quantum protocols.
The structure of this paper is as follows. In Sec. 2, the protocol of quantum key distribution is explained. This is at the same time a leading example to familiarise the reader with distributed quantum networks, a specification language with for- mal semantics for distributed quantum computations which we use throughout this paper. Next, we discuss the logical framework operating on top of this, including modal operators for time and knowledge, in Sec. 3. We note that though we define knowledge in terms of quantum networks, our definition holds more generally in any agent-based system for describing distributed quantum computations. In Sec. 4 we analyse QKD and its security through meta-logic reasoning, covering several types of attacks. Finally, we conclude in Sec. 5. This paper assumes some familiarity with quantum computation and reasoning about knowledge – for the reader not familiar with these domains, we refer to the excellent [19] and [12]. The present paper is a continuation of earlier work by the authors [4,7,8]. We present only the basics of this earlier work here, and refer the reader to the references cited above for more detailed explanations.

Quantum key distribution
The goal of quantum key distribution is to establish a shared secret key between two parties, traditionally called Alice and Bob. There are three versions of the standard QKD protocol, all of which are equivalent [2,10,3]. We will adhere to Ekert’s incarnation of the QKD protocol [10] throughout this paper.

The protocol.
QKD is a private key distribution protocol that is secure against eavesdrop- pers [18]. It relies crucially on the properties of the Bell state |Φ⟩ given by
|0A0B⟩ + |1A1B⟩
|ΦAB⟩ =	√2	,	(1)
and distributed among agents A (Alice) and B (Bob) as indicated by the indices. The Bell state has the property that when measured in arbitrary but identical bases by Alice and Bob, both of them are guaranteed to obtain identical measurement outcomes. For the rectangular basis {|0⟩, |1⟩} this follows from the expression above.

In QKD in particular we also measure in the diagonal basis {|+⟩, |−⟩}. When expressing |Φ⟩ with respect to this basis we obtain
| +A +B⟩ + | −A −B⟩
|ΦAB⟩ =	√2	,	(2)
from which follows that also in this basis Alice and Bob will obtain identical mea- surement outcomes. QKD is based on this property, along with the fact that no-one
— including Alice and Bob — can predict which of both measurement outcomes, 0 (when collapsing to |0⟩ or |+⟩) or 1 (when collapsing to |1⟩ or |−⟩) they will obtain. While the above explanation suffices quantum-mechanically, we need a more formal notation to investigate the protocol computationally. In our case we denote
the full specification of one step of the protocol as follows.


QKD =A(a) : {1}.[(c!a)(c?b).M1Ha]
|B(b) : {2}.[(c?a)(c!b).M2Hb]

(3)

 E12 .
We call such a specification a network. The concept of distributed quantum net- works, as well as the accompanying syntax and semantics, was defined in [4,6]. The syntax for networks is a mix of classical process calculi syntax, the measure- ment calculus (an assembly language for one-way quantum computations [5]), and newly defined syntax for notions particular to the setting of distributed quantum computations. For classical process calculi concepts we use familiar notation: con- currency  and classical message receiving c! and sending c?. Note that agents in a network need to have different names, since they correspond to different parties that make up the distributed system. In other words, concurrency comes only from distribution; we do not consider parallel composition of processes in the context of one party. The measurement calculus is used for local quantum operations: in the above, measurement of the i-th qubit Mi, Hadamard operation on the i-th qubit Hi; note that operations are read right to left. We overload that notation slightly here by writing Ha, which means that execution of the Hadamard gate is conditioned on the value of a Boolean variable a (if a = 0, do nothing, otherwise apply H). This is also reflected in the name of the agents, for example A(a) means that A is parameterised by this Boolean variable a. Finally, we need to add syntax for shared quantum resources such as the Bell state in the above. These resources are supposed to be available to each agent at the start of the computation, and because of entanglement cannot be incorporated in each agent’s specification. The notation we use is  E12, which should be read as given the Bell state over qubits 1 and 2. Furthermore, our agents are typed. Agent types, denoted in curly braces, specify how quantum resources are distributed amongst agents. In the above, the fact that Alice owns the first qubit of the Bell state is denoted by A(a) : 1 , likewise Bob owns the second as specified by B(b) : 2 . So to summarise, one can read the net- work QKD as follows. At the network level, we have two agents A and B, acting in parallel on a shared quantum state given by E12. At the agent level, agent A

(B) is parameterised by a Boolean variable a (b) and owns qubit 1 (2) , to which it applies the local quantum operation M1Ha (M2Hb). After this A and B exchange
1	2
the values of a and b by classical message passing.
A further part to the protocol, which is at the moment not captured in our net- work definition above, is that Alice and Bob only keep their measurement outcomes after checking that a = b. Only in this case it is guaranteed that Alice’s measure- ment outcome, which we denote s1, equals that of Bob, denoted s2. These values are then kept as part of a secret key shared between Alice and Bob. A secret key of adequate length is established by iterating this protocol many times. We note that we could easily express these extra parts of the protocol in our framework; however, we chose conciseness over completeness, as it is the core functionality of one step of the protocol which we wish to analyse in this work.




Formal semantics.
A formal semantics for quantum networks — small-step, operational and de- notational — was worked out in [4,7]. It is only the small-step semantics that is of concern to us here. The small-step transitions for distributed computations essentially describe how agents, and the network with them, evolve over different time steps. It is specified by a set of rules that apply consistently to any network definition. An arbitrary network N is of the following form,

N = A1 : Q1.E1 | A2 : Q2.E2 ... | Am : Qm.Em  σ ,	(4)

where each event sequence is a composition of measurement patterns and com- munication primitives c!, c?, qc! and qc?(classical and quantum). As a network is executed agents carry out local operations and send out messages, affecting the network quantum state as well as each agent’s local state Γi, which is a classical memory recording measurement outcomes and classical variable bindings. The state of the complete network at a particular point in its execution is captured in a con- ﬁguration C, which is given by a quantum state σ together with a set of agent programs and their states, specifically

C = σ  Γ1, A1 : Q1.E1 | Γ2, A2 : Q2.E2 | ... | ΓmAm : Qm.Em .	(5)

Note that the the quantum and classical states σ and Γi, qubit types Qi and event sequences i in the above are generally not equal to those in the network definition (4), as it is precisely these elements that change during execution. The initial configuration, however, is in fact almost identical to the network definition, differing only in the instantiation of empty local states ∅ for each agent.
To state the rules of the semantics we adopt a shorthand notation for agents, as

follows,


ai = Ai : Qi.Ei
ai.E = Ai : Qi.[Ei.E]
a−q = A : Q\{q}.E
a+q = A : Q  {q}.E [q/x] , 




(6)

where E is any event, and i and ' are event sequences. The small-step rules for configuration transitions, denoted = , are specified below; we give some explana- tions afterwards.


(7)


	Γ2(y) = v	 σ  Γ1, a1.c?x | Γ2, a2.c!y =⇒ σ  Γ1[x '→ v], a1 | Γ2, a2
(8)


(9)



	L =⇒λ R	 L | L' =⇒λ R | L'

(10)

Here ∪ denotes the union of outcome maps. Implicit in these rules is a sequential composition rule, which ensures that all events in an agent’s event sequence are executed one after the other. The first rule is for local operations, which are speci- fied by patterns in the measurement calculus [5]. We have written the full pattern instead of only its command sequence here to make pattern input and output ex- plicit. Because a pattern’s big-step semantics is given by a probabilistic transition system described by  , we pick up a probability λ here. The full specification of the small-step rules for patterns can be found in the appendix. Note that an agent changes its sort depending on the pattern’s output O. The next rule is for classical rendezvous and is straightforward. For quantum rendezvous, we need to substitute q for x in the event sequence of the receiving agent, and furthermore adapt qubit sorts. The last rule is a metarule, which is required to express that any of the other rules may fire in the context of a larger system. L and R stand for any of the pos- sible left-, respectively right-hand sides of any of the previous rules, while L' is an arbitrary configuration. Note that we might need to rearrange terms in the parallel composition of agents in order to be able to apply the context rule. This can always be done since the order of agents in a configuration is arbitrary. In derivations of network execution, we often do not explicitly write reductions as specified by (10), but rather specify in which order the other rules fire in the context of the network at hand. It is precisely in this last rule that introduces nondeterminism at the net- work level, that is, several agent transitions may be possible within the context of

a network at the same time.

Execution of QKD.
Let us now apply the formal semantics for networks to the particular case of QKD. This is done by applying the rules of the semantics to the network definition given in (3). By going through the protocol step by step one constructs all configu- rations that potentially occur during the execution of QKD; it is this configuration space, denoted CN for a network N , that we reason upon for cryptanalysis.
The initial configuration for QKD is simply
C0(a, b) = E12  ∅, A(a) : {1}.[(c!a)(c?b).M1Ha] | ∅, B(b) : {2}.[(c?a)(c!b).M2Hb]
Here ∅ denotes the empty local state, i.e. no variables or measurement outcomes are stored initially. Note that configurations are parameterised by the values of a and b. 3 Jumping to the configuration where both agents have carried out their local quantum operation and obtained measurement outcomes j1 and j2, we have
C1(a, b) = 0  [s1 '→ j1], A(a).[(c!a)(c?b)] | [s2 '→ j2], B(b).[(c?a)(c!b)] .
The network quantum state is now the null state 0 and types have disappeared because measurements in patterns are destructive. Obviously we have branching due to varying measurement outcomes, and this with specific probabilities. In the final step of the computation agents have added the values of b, respectively a in their local states; the associated configuration C2(a, b) is given by

C2(a, b) = 0  [s1 '→ j1, b '→ b], A(a) | [s2 '→ j2, a '→ a], B(b) , 

where a and b are variable names. Schematically we have two possible structures of configuration trees for QKD, two of each type. These are represented in Fig. 3 (ignore the boxes for now) for a = b or a = b respectively. Here we have not written the dependency of each configuration on a and b explicitly to avoid cluttering the picture. Our configuration trees are slightly cruder than the ones taking all steps of the protocol into account because we allow the quantum operations to be carried out in parallel by Alice and Bob. This is because we are interested in the value of the secret key and how an eavesdropper can learn this value, and hence, since the order in which local quantum operations are carried out does not matter, 4 we can make this simplification.

Reasoning about knowledge
In this section we explain the notion of knowledge for distributed quantum systems, which was defined earlier in [8]. Our results are phrased in the context of quantum

3 We could have modelled setting up the values of a and b within our protocol as well; again, we have chosen not to do so for simplicity.
4 This just follows from the mathematical identity L1 ⊗ L2 = (I ⊗ L2)(L1 ⊗ I)= (L1 ⊗ I)(I ⊗ L2), where
L1 and L2 are local operations.

networks, but in fact our notion of knowledge is model-independent. That is to say, any agent-based model for distributed quantum computation would benefit from knowledge as defined below, or slight adaptations thereof.


Facts.
Before we can actually define modal operators for knowledge or time, we need to clarify what the propositions are that these act upon. It is not our intention to define a full-fledged language for primitive propositions; rather, we define these abstractly, and specify the usual rules for combining them with standard logical connectives. We do give some examples of the kinds of properties that we are interested in later on.
Each network  determines a set of configurations N that can potentially occur during execution of  . An interpretation of  is a truth-value assignment to all configurations in N for some basic set of primitive propositions θ. Writing I(C, θ) for the interpretation of fact θ in configuration C, we then have a first logical statement,
C, N ▶ θ ⇐⇒ I(C, θ) = true .	(11)
The primitive propositions considered usually depend on the network under study, and are currently specified individually for each application. Typical primitive propositions encountered are the following, where we use slightly ad-hoc logical notation,


C, N ▶ (x = v) ⇐⇒ ∃i.Γi(x) = v	(12)
C, N ▶ (x = y) ⇐⇒ ∃i, j.Γi(x) = Γj(y)	(13)
C, N ▶ (Ai has q) ⇐⇒ q ∈ Qi	(14)
C, N ▶ (q1 ... qn = σ) ⇐⇒ q1 ... qn = σ	(15)
C, N ▶ (qi = qj) ⇐⇒ ∃σ.qi = qj = σ .	(16)

The first two lines concern classical variable value and variable equality. The third line is about qubit ownership. The last two lines are genuine quantum statements, and need to be used with care, in that they only make sense when pertaining to known quantum states. That is, σ should be seen as a preparation or a state that has just been measured, not as an unknown quantum input such as that appearing in teleportation. The last primitive proposition is especially tailored to unknown quantum states: it states that two qubits named qi and qj are equal, though the actual state they are in may be unspecified; this is something we need to be able to express for the teleportation protocol, for example. We also allow functions init and ﬁn for taking the initial and final values of a variable or quantum state. These formulas are currently defined in an ad-hoc manner.
Composite formulas can be constructed from primitive propositions and the

usual logical connectives ∧, ∨ and ¬. Concretely, we have the following rules.
C, N ▶ θ1 ∧ θ2 ⇐⇒ C ▶ θ1 ∧ C ▶ θ2	(17)
C, N ▶ θ1 ∨ θ2 ⇐⇒ C ▶ θ1 ∨ C ▶ θ2	(18)
C, N ▶ ¬θ ⇐⇒ C $ θ .	(19)
Hence the syntax for facts F is as follows,

F ::= θ | F ∧ F' | F ∨ F' | ¬F .	(20)

Knowledge.
The standard approach to knowledge representation in multi-agent systems is based on the possible worlds model [16,15,12]. The idea is that there exists a set of worlds such that an agent may consider several of these to be possible. An agent knows a fact if it is true in all the worlds it considers possible; this is expressed by epistemic modal operators acting on some basic set of propositions. The flexibility of this approach lies in the fact that there are many ways in which one can specify possibility relations. In a distributed system, worlds correspond to global configu- rations occurring in a particular protocol, and possible worlds are determined by an equivalence relation over these configurations. Typically, global network configura- tions are considered equivalent by an agent if its local view on these configurations is identical.
A first attempt to define knowledge for quantum distributed systems is found in [24]. Therein, two different notions of knowledge are defined. First, an agent i can classically know a formula θ to hold, denoted Kcθ; in this case the possibility relation is based on equality of local classical states. Second, an agent can quantumly know a formula to hold, denoted Kqθ. For the latter, the possibility relation is based
i	q
on equality of reduced density matrices for that agent. The authors argue that Ki
is an information-theoretic idealisation of knowledge, in that the reduced density matrix embodies what an agent, in principle, could determine from its local quantum state. However, there are two main problems with this approach. The first is that one cannot assume that the reduced density matrix is always known, because in quantum mechanics, observing a state alters it irreversibly. So, knowledge does not consist of possession of a quantum state: it is not because an agent has a qubit in its lab that the agent knows anything about it. Indeed, consider the situation where a qubit has just been sent from A to B. Then B knows nothing about its newly acquired qubit – it is possible, even, that A knows more about it than B does. The second problem with the above approach is that one loses information on correlations between agents by considering only the reduced density matrix, a crucial ingredient in distributed quantum primitives.
What we need is a proper notion of knowledge, which captures the information an agent can obtain about its quantum state. This includes the following ingre- dients: first, an agent knows states that it has prepared; second, an agent knows a state when it has just measured it; and third, an agent may obtain knowledge

by classical communication of one of the above. While knowledge of preparation states is automatically contained in the description of the protocol, our notion of equivalence precisely captures the latter two items. As we shall see below, in doing this we find a similar notion as Kcθ. Our main argument, then, is that there is no such thing as quantum knowledge in the sense of Kqθ; rather knowledge is about classically knowing facts about quantum systems. To stress this we refer to our notion in full as classical knowledge for quantum systems. 5
Hence in order to define knowledge, we need to define an equivalence relation on configurations for each of the agents, embodying what an agent knows about the global configuration from its own information only. We deliberately do not say local information here, as, via the network preparation, an agent may also have non-local information under the form of correlations at its disposal. Each agent’s equivalence relation has to reflect what an agent knows about the network state, the execution of the protocol and the results of measurements. All classical information an agent has is stored in its local state Γ; this includes measurement outcomes and classical values passed on by other agents. Just like in classical distributed systems, an agent can certainly differentiate configurations for which the local state is different. As for quantum information, an agent knows which qubits it owns, what local operations it applies on these qubits, and, moreover, what (non-local) preparation state it starts out with, i.e. what entanglement it shares with other agents initially. All of the above information is in fact captured by an agent’s event sequence in a particular configuration, together with its local state. Therefore, we obtain the following definition.

Definition 3.1 Given a network N and configurations C = σ  |iΓi, Ai : Qi.Ei and
C' = σ'  |iΓ', Ai : Q' .E' in CN , we say that agent Ai considers C and C' to be
equivalent, denoted C ∼i C', if Γi = Γ' and Ei = E'. For each agent Ai the relation
∼i is an equivalence relation on CN , called the possibility relation of Ai.

Via possibility relations we can now define what it means for an agent Ai to know a fact θ in a configuration C in the usual way,

C, N ▶ Kiθ ⇐⇒ ∀C' ∼i C : C' ▶ θ .	(21)

Our choice of equivalence embodies that agents cannot distinguish configurations if they only differ in that other agents have applied local operations to their qubits; neither can they if other agents have exchanged messages with each other. This situation is represented schematically in Fig. 1. While the global network state does change as a result of local operations, an agent not executing these has no knowledge of this, and no way of obtaining it. This is precisely what we capture with the relation ∼i.


5 Note that is different from the terminology used in [8], where we talk about quantum knowledge.






Time.
Fig. 1. A schematic event diagram with equivalence classes.

One typically also wants to investigate how knowledge evolves during a compu- tation, for example due to communication between agents. We use the approach of computational tree logic (CTL) [11] to formalise time-related logical statements, providing state as well as path modal operators. The reason for this is that, due to the fact that quantum networks typically have a branching structure, we need to be able to express statements concerning all paths as well as those pertaining to some paths. Concretely, we introduce the traditional temporal state operators □ (“always”) and (“eventually”) into our model, and combine these with the path operators A (“for all paths”) and E (“there exists a path”), as follows 6


C, N ▶ A□θ ⇐⇒ ∀γ, ∀C' with C =γ C, N ▶ E□θ ⇐⇒ ∃γ, ∀C' with C =γ C, N ▶ A θ ⇐⇒ ∀γ, ∃C' with C =γ C, N ▶ E θ ⇐⇒ ∃γ, ∃C' with C =γ
C' : C' ▶ θ	(22)
C' : C' ▶ θ	(23)
C' : C' ▶ θ	(24)
C' : C' ▶ θ .	(25)

Obviously, we have that any formula with A implies the corresponding one with E, and likewise any formula with □ implies the corresponding one with  .

Properties.
The properties we wish to express about protocols are constructed from the in- gredients above: facts, logical connectives, and modal operators of time and knowl- edge. Concretely, a property P is generated from the following syntax
P ::= F | KiP | A□P | E□P | A P | E P ,	(26) where the syntax for facts is given in (20).
When investigating knowledge issues in a distributed system, one naturally ar- rives at situations where one needs to describe formally how knowledge evolves as the computation proceeds. This can be done adequately by combining knowledge operators Ki with the temporal operators defined above. As usual, one needs to

6  γ	γ	'
=⇒ is the closure of the small-step transition relation =⇒ defined in [8]. That is, we have C =⇒ C if
C' can be reached form C by a series of consecutive small-step transitions, specified by the path γ.

proceed with caution when doing this, since it is not always intuitively clear what the meaning of each of these different combinations is. For example, it is generally not the case that the formula A□Kiθ is equivalent to KiA□θ. Typically, we want to prove things that are always known by an agent, no matter what branch the protocol follows; this is embodied by the former, and represented schematically in Fig. 2. In the figure the arrows represent the equivalence relation i and the circled points are those for which θ should hold.

Fig. 2. A schematic representation of C, N ▶ A□Kiθ.


Security issues for QKD
With epistemic and temporal notions for quantum networks in place, we are ready to evaluate quantum key distribution and its security from a knowledge-based per- spective.
Fig. 3 pictures the equivalence classes of configurations for Alice (dotted boxes) and Bob (boxes) respectively. Equivalence across both trees holds for Alice for a fixed, and for Bob for b fixed. Vertically, each level is discerned by each agent because a local event has occurred, while horizontally, different measurement out- comes ensure the non-equivalence of configurations. Note that at each time step
all configurations in which say, Alice, has a particular measurement outcome are

Fig. 3. Configuration trees and equivalence classes.

equivalent, i.e. this works across all configuration trees with the same value for a. More formally, we have the following two equivalence classes of configurations for Alice at level 1, one for each value of s1,
[Cs1 (a)]A = {∀b, s2 : Cs1s2 (a, b)} .	(27)
At the final level Alice and Bob have interchanged the values of a and b and so they can tell the difference between a number of configurations that were equivalent at the previous level. Concretely we move to a set of equivalence classes for Alice as follows,
[Cs1 (a, b)]A = {∀s2 : Cs1s2 (a, b)} .	(28)
Bob has analogous equivalence classes [Cs2 (b)]B and [Cs2 (a, b)]B, which are defined
1	2
as the above but with the roles of a and b and of s1 and s2 interchanged.
When a = b Alice and Bob have identical single-configuration equivalence classes at the final stage of the computation. This means that each agent’s knowledge is identical at that point, and that we can prove formally that in this case one bit of a secret key has been established,
a = b ⇒ C0(a, b), QKD ▶ A  (KA(s1 = s2) ∧ KB(s1 = s2))	(29)

In this section we prove that QKD is secure against several types of attacks within our logical framework of knowledge and time. While these security issues have been studied before, it is the logical-based approach that is original here. We head off by showing that eavesdroppers listening in on classical communication channels cannot derive the key. This is of course the core property in making QKD so valuable as an alternative to classical private symmetric secret key establishment protocols.

Listening in on classic channels.
Suppose we have a third agent Eve, who eavesdrops on classical communication between Alice and Bob. Formally, we can model this by adding a third agent E, acting in parallel with A and B, to the QKD network given in (3), as follows,
.	(30)



QKD =A(a) : {1}.[(c!a)(c?b).M1Ha]
|B(b) : {2}.[(c?a)(c!b).M2Hb]


(31)

|E.[(c!a, b)(c?a, b)]
 E12 .

Note that Eve has no type since she has no qubits. The idea is that Eve intercepts the messages sent by Alice and Bob, reads them, and sends them along so that the other agents cannot detect her presence. However, neither can she derive any



Fig. 4. Eve’s equivalence classes when a = b.

information about the key. This we know already from straightforward quantum mechanics, but let us prove this now in our framework. By including Eve an extra level is inserted in our configuration trees, between level 1 and 2. Calling this level 1’, we thus obtain a number of new configurations C1' that our agents can reason upon. A representation of the a = b case is given in Fig. 4.
The crucial point is that, since the values of s1 and s2 remain local throughout the protocol, 7 configurations with different values for these parameters are equiv- alent for Eve. In particular for i = 1', 2 we find the following equivalence classes

[Ci(a, b)]E = {∀s1, s2 : Cs1s2 (a, b)}.	(32)
In other words, Eve can never derive the values of the secret key, since within one equivalence class there will always be configurations corresponding to different measurement outcomes. More formally,
a = b ⇒ C0(a, b), QKD ▶ A□¬KE(s1 = s2 = v)	(33)
where v is a value. Note, however, that Eve can derive that in this case measurement outcomes for Alice and Bob are identical.

Measuring the Bell state.
A second possible attack is that Eve intercepts the Bell state before it is dis- tributed among Alice and Bob, measuring it and resending it to Alice and Bob in collapsed form. For simplicity, we assume that Eve always measures in the ordinary basis. This situation would involve changing the specification of the QKD network given in (3), as follows,
QKD =A(a).[(c!a)(c?b).M1Ha(qc?1)]

|B(b).[(c?a)(c!b).M2Hb(qc?2)]
(34)

|E.[(qc!1)(qc!2).M12]
 E12 .

7 Local in the sense that they are not sent around directly.

Note that Alice and Bob now have an empty type, as they receive their qubits at the start of the computation from Eve (whom they assume to be a safe quantum channel). The interesting case again is where a = b, and in particular a = b = 1 since Eve always uses the ordinary basis. In this case Alice and Bob may obtain different measurement outcomes even though they measure in the same basis. 8 Hence they can figure out that an attack has been attempted, and thus that their network is not secure.
In our framework, again we have an extra level of configurations, this time right after C0(a, b), where Eve measures and sends qubits 1 and 2. However, let us move straight to the final stage of the computation. Now we have the following final equivalence classes for Alice
[Cs1 (1, 1)]A = {∀s0, s2 : Cs0s1s2 },	(35)
where s0 is Eve’s measurement outcome. Indeed, since Eve’s and Bob’s measure- ment outcomes are now uncorrelated with Alice’s, and they have not communicated these values to Alice, she has no way of discerning between configurations where her outcome s1 is fixed but theirs is arbitrary. Thus the following statement holds:
C0(1, 1), QKD ▶ A  ¬KA(s1 = s2) .	(36)
While in this case Alice and Bob cannot derive whether or not their protocol was safely executed, they can do so when they exchange their measurement outcomes s1 and s2. In this case we have
C0(1, 1), QKD ▶ E  KA(s1 /= s2) ,	(37)
and hence they know without doubt that the security of their network was compro- mised.

Entangling with the Bell state.
A third possibility is that Eve entangles herself with the Bell state shared by Alice and Bob and operates on her qubit only. This is described by the following network specification, where A and B are defined as before, O is an arbitrary quantum operation (i.e. a completely positive map), and ψ123 is an arbitrary 3-qubit state which behaves like the Bell state on the first two qubits 9
QKD = A ... |B ... |E : {3}.O3  |ψ123⟩ .	(38)

Suppose O implements some unitary U acting on qubit 3 only. Since measurement statistics for Alice and Bob are unchanged, in the interesting case where a = b we again have a situation as in Fig. 4, and hence (33) holds: Eve cannot derive the secret key. Next, suppose O implements a measurement of some sort. Only if qubit

8 This is because we have |00⟩ = 1 (| + +⟩ + | + −⟩ + |− +⟩ + |− −⟩), and a similar expression for |11⟩.
9 That is, the reduced density matrix of |ψ123⟩ on the Hilbert space corresponding to the first two qubits equals the density matrix of the Bell state.



Fig. 5. Eve’s equivalence classes when measuring her disentangled qubit.



3 is disentangled from the other two are the measurement statistics for Alice and Bob unaltered. Supposing Eve measures in the last step of the computation, then in this case with a = b, a final level of configurations is added to the configuration tree at the left of Fig. 3, as pictured in Fig. 5. Since configurations with different values for the key are equivalent to Eve, again she cannot derive its value. Finally, if Eve carries out a measurement but her qubit is entangled with qubits 1 and 2, the measurement statistics are altered much in the way of Sec. 7 (only the probabilities are different). As we do not reason about probabilities, the analysis of that section applies here as well.



Conclusion
We have applied the framework of classical knowledge for quantum systems [8] to analyse the security of quantum key distribution with respect to several types of attacks. Our main point was to show that such developments provide a suitably sys- tematic yet transparent way of investigating cryptographic issues. Of course more work needs to be done. In particular we would like to move to a more abstract level in which we can investigate all types of attacks at once, parameterising over arbi- trary adversary behaviour. This would entail reasoning about infinite configuration spaces. In particular, it would be interesting to redo Mayers’ proof of unconditional security for quantum key distribution [18], to identify prime logical concepts and how they correspond to information-theoretic arguments used in the proof as is. Note that this would require reasoning about multiple runs and probabilities, some- thing for which we currently have no machinery. Surely the model needs to be put further to the test, by investigating other cryptographic primitives and protocols.
In ongoing work [9] we are upgrading our model by merging two previous ap- proaches to reasoning about knowledge in quantum security protocols: the model checking approach exhibited here and the algebraic axiomatics of [22]. These two approaches complement each other: while the latter enjoys a semiautomatic proof search procedure, the former is equipped with a small-step operational semantics for quantum computations. We are currently looking into what combination of both models gets the best of both worlds.

References
Baltag, A. and S. Smets, LQP: the dynamic logic of quantum information, Mathematical Structures in Computer Science 16 (2006), pp. 491–525.
URL  http://www.vub.ac.be/CLWF/SS/LICS-workshop.pdf

Bennett, C. H. and G. Brassard, Quantum cryptography: public key distribution and coin tossing, in: Proceedings of IEEE international Conference on Computers, Systems and Signal Processing, Bangalore, India (1984), p. 175.
Bennett, C. H., G. Brassard and N. D. Mermin, Quantum cryptography without Bell’s theorem, Phys. Rev. Lett. 68 (1992), p. 557.
Danos, V., E. D’Hondt, E. Kashefi and P. Panangaden, Distributed measurement-based quantum computation, in: P. Selinger, editor, Proceedings of the 3rd International Workshop on Quantum Programming Languages (QPL 2005), ENTCS 170, 2005, pp. 73–94, quant-ph/0506070.
URL http://arxiv.org/abs/quant-ph/0506070

Danos, V., E. Kashefi and P. Panangaden, The measurement calculus, Journal of the ACM 54 (2007), quant-ph/0704.1263v1.
URL http://arxiv.org/abs/quant-ph/0704.1263v1

D’Hondt, E., “Distributed quantum computation – A measurement-based approach,” Ph.D. thesis, Vrije Universiteit Brussel (2005).
D’Hondt, E. and P. Panangaden, The computational power of the W and GHZ states, Journal on Quantum Information & Computation 6 (2005), pp. 173–183, quant-ph/0412177.
URL http://arxiv.org/abs/quant-ph/0412177

D’Hondt, E. and P. Panangaden, Reasoning about quantum knowledge, in: Proceedings of the 25th Conference on Foundations of Software Technology and Theoretical Computer Science, LNCS 3821, 2005, p. 0544c (to appear), quant-ph/0507176.
D’Hondt, E. and M. Sadrzadeh, Classical knowledge for quantum security (2008), accepted at QPL08.
Ekert, A. K., Quantum cryptography based on Bell’s theorem, Phys. Rev. Lett. 67 (1991), pp. 661–663.
Emerson, E. A., Temporal and modal logic, in: J. van Leeuwen, editor, Handbook of Theoretical Computer Science, Volume B: Formal Models and Sematics (B), MIT Press, 1990 pp. 995–1072.
Fagin, R., J. Y. Halpern, Y. Moses and M. Y. Vardi, “Reasoning about knowledge,” MIT Press, 1995.
Gay, S. J. and R. Nagarajan, Communicating quantum processes, in: P. Selinger, editor, Proceedings of the 2nd Workshop on Quantum Programming Languages (QPL04), Turku Centre for Computer Science (2004).
URL http://arxiv.org/abs/quant-ph/0409052
Gay, S. J., R. Nagarajan and N. Papanikolaou, Probabilistic model-checking of quantum protocols
(2005).
URL http://arxiv.org/abs/quant-ph/0504007
Halpern, J. Y., Reasoning about knowledge: a survey, , 4 (1995), pp. 1–34.
URL http://www.cs.cornell.edu/home/halpern/papers

Hintikka, J., “Knowledge and belief - An introduction to the logic of the two notions,” Cornell University Press, Ithaca, N.Y., 1962.
Lalire, M. and P. Jorrand, A process algebraic approach to concurrent and distributed quantum computation: operational semantics, in: P. Selinger, editor, Proceedings of the 2nd Workshop on Quantum Programming Languages (QPL04), Turku Centre for Computer Science (2004).
URL http://arxiv.org/abs/quant-ph/0407005

Mayers, D., Unconditional security in quantum cryptography, Journal of the ACM 48 (2001), pp. 351– 406.
Nielsen, M. A. and I. Chuang, “Quantum computation and quantum information,” Cambridge university press, 2000.
Raussendorf, R., D. E. Browne and H. J. Briegel, Measurement-based quantum computation on cluster states, Phys. Rev. A 68 (2003), p. 022312.
URL http://arxiv.org/abs/quant-ph/0301052


Sadrzadeh, M., “Actions and Resources in Epistemic Logic,” Ph.D. thesis, University of Quebec at Montreal (2005).
Sadrzadeh, M., High-level quantum structures in linguistics and multi-agent systems, in: Proceedings of AAAI Spring Symposium on Quantum Interaction (2007).
Shor, P. W., Algorithms for quantum computation: Discrete logarithms and factoring, in: IEEE Symposium on Foundations of Computer Science, 1994, pp. 124–134.
van der Meyden, R. and M. Patra, Knowledge in quantum systems, in: Proceedings of the 9th conference on Theoretical aspects of rationality and knowledge, Bloomington, Indiana, 2003, pp. 104–117.
URL http://www.cse.unsw.edu.au/~meyden/research/kqs.pdf


Appendix: The small-step semantics for measurement patterns.
For completeness we state the small-step operational semantics of measurement patterns here [5,6]. A pattern is defined as follows.
Definition 5.1 A pattern P is given by a computation space V , pattern inputs I and outputs O, finite sets with associated Hilbert spaces HV , HI and HO respec- tively, and a finite sequence of commands A = Ak ... A1, and is denoted
P(V, I, O.A) . 
Commands are either entanglements Eij, measurements t[Mα]s or corrections Xs
i	i
or Zs, where i, j ∈ V , α ∈ [0, 2π] and s, t ∈ Z2.
The small-step semantics for patterns is in one-to-one correspondence with the different commands of which a pattern command sequence is composed. Before we can give the specific rules for E, M and C commands however, we have to specify the semantics of their component objects, signals and angles. For this we need an extra structure in which we can store and look up measurement outcomes. We call this classical component the outcome map Γ. Formally it is a function from the computation space V O (recall that output qubits are never measured) to the outcome space Z2, initialised to the empty map, denoted ∅. The idea is that when qubit i is measured the result si is filled into the outcome map such that Γ(i) = si. The resulting outcome map is denoted as Γ[si/i], which is the outcome map Γ with an additional signal value si filled in for qubit i. Signals, which are sums of measurement outcomes, are then evaluated by looking up the signal terms in Γ. The outcome map is the equivalent of the information flow vector from [20]. Together with the quantum state ρ ∈ D(HV ) the outcome map forms the total state of a computation. The computation state space S is therefore defined as
S :=   D(HV ) × ZW ,	(39)
V,O

where W ⊆ (V \O) can be any finite set of qubits.
Each of our commands acts on a pair (ρ, Γ) in the state space  . The semantics of a signal s however, can be defined solely with respect to the outcome map. We find the following evaluation rules for signals.



Γ ▶ 0 ↓ 0	and	Γ ▶ 1 ↓ 1	(40)

Γ ▶ si
(41)
↓ Γ(i)

Γ[v/s ] ▶ s
and
↓ v	Γ[v/s ] ▶ s
↓ Γ(j)	if i /= j	(42)



Here ⊕ denotes addition in Z2.
Γ ▶ s ↓ v	Γ ▶ t ↓ u
Γ ▶ s + t ↓ v ⊕ u
(43)

Angles, which can have signal dependencies percolated through via dependent measurements, are also purely classical. Values of signals are looked up in Γ via the rule set for signals in order to determine the actual value of a measurement angle. This procedure is summarised in the following rules.


Γ ▶ α ↓ α	(44)

  Γ ▶ s ↓ v	Γ ▶ t ↓ u	
Γ ▶ t[α]s ↓ (−1)v.α + u.π
and
(45)
(46)

Γ ▶ [α]s ↓ 0[α]s	Γ ▶ t[α] ↓ t[α]0
Having defined how signals and angles are evaluated, we can now move on to the operational semantics of the basic commands. All of these commands operate on the quantum state.




ρ, Γ, Eij −→ ∧Zijρ ∧Zij, Γ
	Γ ▶ s ↓ v	 ρ, Γ,Xs −→ XvρXv, Γ
(47)

(48)

	Γ ▶ s ↓ v	
ρ, Γ, Zs −→ ZvρZv, Γ
(49)

i
Γ ▶ t[α]s ↓ β
i	i
,	= tr(|+β⟩⟨+β|i ρ)

(50)

ρ, Γ, t[Mα]s −→λ
⟨+β|i
ρ |+β
⟩i, Γ[0/i]

trρ

Γ ▶ t[α]s ↓ β
,	= tr(|−β⟩⟨−β|i ρ)
(51)

ρ, Γ, t[Mα]s −→
⟨− |
ρ |−
⟩ , Γ[1/i]

trρ

The first three commands are purely quantum and straightforward. The measure- ment commands are the only commands that affect the quantum state as well as the output map. First, the measurement angle has to be evaluated, which in turn requires evaluating the X- and Z-signals by the previous sets of rules. Measurement commands are also the only nondeterministic commands, as the measured qubit is projected onto either +α or  α with transition probabilities as stated. Usually, the convention is to renormalise the state after measurement, but we do not adhere

to it here, as in this way the probability of reaching a given state can be read off its norm, and moreover the overall treatment is simpler. We have presented these rules here for density matrices; in pure state derivations we often use state transitions for brevity. Specifically, for a pure state we have ρ = |ψ⟩⟨ψ|, which is mapped to L|ψ⟩⟨ψ|L†, with L any of the entanglement, Pauli or projection operators above. A pure state transition can then be alternatively specified as mapping |ψ⟩ to L|ψ⟩.
Finally, we need an evaluation rule for a composition of commands, as follows.


ρ, Γ, C1 −→λ ρ', Γ'


ρ, Γ, C2C1 −→λ ρ', Γ', C2
(52)
