	Electronic Notes in Theoretical Computer Science 199 (2008) 129–147	
www.elsevier.com/locate/entcs

A Meta Linear Logical Framework
Andrew McCreight and Carsten Schu¨rmann1 ,2
Yale University New Haven, CT, USA


Abstract
Logical frameworks serve as meta languages to represent deductive systems, sometimes requiring special
purpose meta logics to reason about the representations. In this work, we describe L+, a meta logic for the linear logical framework LLF [6] and illustrate its use via a proof of the admissibility of cut in the
sequent calculus for the tensor fragment of linear logic. L+ is first-order, intuitionistic, and not linear. The
soundness of L+ is shown.
Keywords: Logical framework, meta language, meta logic, L+, linear logical framework


Introduction
Logical frameworks are meta languages designed for representing various formal systems prevalent in programming language semantics, logics, and protocol design. By design, a logical framework is foundationally uncommitted, meaning that it is primarily concerned with the way formal systems are represented and not with rea- soning about their properties. Logical frameworks have, in this spirit, undergone significant extensions, leaving the design of meta logics far behind. Modern logi- cal frameworks incorporate linear types to model resource awareness (useful when designing programming languages with effects), ordered types (to model formal systems that access resources in a particular order), and even monadic types that capture concurrency.
By separating meta languages from meta logics, we get a quite substantial design space for special purpose meta logics. Each meta logic is tailored toward a particular

1 This research is based on work supported in part by DARPA OASIS grant F30602-99-1-0519 and NSF grant CCR-0325808. Any opinions, findings, and conclusions contained in this document are those of the authors and do not reflect the views of these agencies.
2 Email:{aem,carsten}@cs.yale.edu

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.11.016

logical framework, responding to its requirements, expressiveness and idiosyncrasies, with the sole purpose of formalizing meta theoretic arguments about encodings in the logical framework. A logical framework together with a meta logic defines a meta logical framework. One example of a meta logic is ł+ [17], designed specifically for the logical framework LF [10]. Conversely, McDowell and Miller [11], have chosen a fixed meta logic and to study how to encode and reason about various meta languages in their system. However, their design is also not immune to change. Non-standard extensions of their first-order meta logic with definitions and natural number induction have become necessary to facilitate reasoning about terms with open parameters [7].
The absence of well-understood meta logics has often been interpreted as a severe impediment to the deployment and acceptance of the technology among researchers and scientists as well as developers and industry. Consequently, the prevalent use of logical framework technology is as a representation language for one particu- lar logic that is then used to describe and reason about the object systems in question. Higher-order logic is a popular candidate used in Isabelle/HOL [13] and Twelf/HOL [1] which have been instrumental in the formal study of programming languages, such as Java [12], hardware verification [9], and protocol verification [14], among other things. Higher-order logic is well-understood, clean, expressive, and when enriched with induction principles a good choice for many applications. How- ever, it limits the ways in which deductive systems can be encoded, and therefore cannot take advantage of the advanced representation technology provided by mod- ern logical frameworks.
In this work, we propose a special purpose meta logic for the linear logical frame- work LLF [6] which plays the role of a linear meta logical framework. LLF’s distin- guishing feature over LF is a set of linear operators capable of handling depletable resources. LLF has been successfully employed in representing and experimenting with a variety of security and authentication protocols [3]. Although the theory be- hind LLF is well-understood, our work is to our knowledge the first research towards a sound meta logic for LLF.

+ extends the meta logic ł+
for LF developed by the second author [17]

into the LLF setting. L+ is first-order, intuitionistic, and not linear. Aside from T, it does not define any logical constant symbols. It does however inherit proofs by induction over arbitrary higher-order types without the restrictive positivity condition, including those that take advantage of both linear and intuitionistic as- sumptions. Furthermore, it supports quantification over LLF contexts. L+ can be used to reason about meta properties of languages encoded in LLF. For instance, it should be possible to show type soundness of a simple programming language with references or cut elimination for a linear logic. L+ must be dependently typed to
state these sorts of properties.
The paper is organized in the following way: in Section 2 we review the linear logical framework LLF and illustrate its representational expressiveness in terms of a sequent calculus for the tensor fragment of linear logic. In Section 3, we present a formal meta logic L+ that serves as the formalization of theorems as well as meta

(Kinds)	K	::= type | Πu : A. K
(Types)	A, B  ::= a | A M | Πu : A. B | A −◦ B | A & B | T 
(Objects)	M, N ::= c | u | λu : A. M | M N | λˆu : A. M | MˆN
| ⟨M, N ⟩ | π1M | π2M | ⟨⟩
(Signatures) Σ	::= · | Σ,a : K | Σ,c : A (Contexts)	Γ, Δ ::= · | Γ,u : A (Substitution) ρ	::= · | ρ, M/u
Fig. 1. LLF syntax

theoretic proofs. We start by describing the interface between the meta logic and the logic, first by giving extensions to LLF, before describing the meta logic proper and its proof theory. Next, in Section 4, we use as an example the proof of the theorem that cuts are admissible in the previously defined sequent calculus encoding. Then L+’s soundness is shown in Section 5, before we conclude in Section 6 and assess results.

The Linear Logical Framework LLF
The linear logical framework LLF [6] extends the the logical framework LF [10] with linear resources that may be created, used, or modified. Its feature set supersedes that of LF, supporting dependent types. Every term in LLF reduces to a canon- ical form. LLF has established itself as an elegant tool for adequate encodings of judgments as types, derivations as objects, and hypothetical judgments as (linear) functions including an elegant treatment of depletable resources.
For example, the well-known derivability judgment for linear classical logic of the form A1,... , An =⇒ B1,... , Bn can be represented in LLF as a function of the form
neg A1 ... −◦ neg An −◦ pos B1 ... −◦ pos Bm → #.
neg and pos are families of types, representing assumptions to the left and right of the =⇒ symbol, respectively, while # is a type that stands for the empty se- quent. Encoding lists of assumptions as linear functions instead of making them explicit as lists has several advantages, namely that lookup, consumption, and sub- stitution are directly supported by LLF through variable names, linear application, and β-reduction, which renders encodings of resource oriented formal systems brief, concise, and readable.
LLF borrows its linear operators from linear logic [8] and uses βη as the under- lying notion of definitional equality [5]. Furthermore, it conservatively extends LF. LLF does not provide a dependent linear function space. The syntax for standard LLF [6] is given in Figure 1.
Kinds can either be the kind for types or a dependent product. Types can either


		
Ψ; Γ; · Dc : Σ(c)	Ψ; Γ; · Du : Γ(u)	Ψ; Γ; u : AD u : A


Ψ; Γ,u : A;Δ DM : B


Ψ; Γ; Δ D λu : A. M : Πu : A. B
Ψ; Γ; Δ DM : Πu : A. B	Ψ; Γ; · DN : A


Ψ; Γ; Δ DM N : [idΓ;Δ, N/u]B



Ψ; Γ; Δ,u : AD M : B


Ψ; Γ; Δ D λˆu : A. M : A −◦ B
Ψ; Γ; Δ1 DM : A −◦ B	Ψ; Γ; Δ2 DN : A


Ψ; Γ; Δ1, Δ2 D MˆN : B


Ψ; Γ; Δ DM : A	Ψ; Γ; Δ DN : B
Ψ; Γ; Δ D ⟨M, N ⟩ : A & B


Ψ; Γ; Δ DM : A & B
Ψ; Γ; Δ D π1M : A
Ψ; Γ; Δ DM : A & B
Ψ; Γ; Δ D π2M : B	Ψ; Γ; Δ D ⟨⟩ : T


Fig. 2. Typing rules of LLF.


ax
A =⇒ A
Γ1 =⇒ C, Δ1	Γ2,C =⇒ Δ2 cut
Γ1, Γ2 =⇒ Δ1, Δ2



Γ, A,B =⇒ Δ
⊗L
Γ,A ⊗ B =⇒ Δ
Γ1 =⇒ A, Δ1	Γ2 =⇒ B, Δ2 ⊗R
Γ1, Γ2 =⇒ A ⊗ B, Δ1, Δ2


Fig. 3. Tensor fragment of linear logic

be a type constant, an application, a dependent function type, the linear function type, the additive product type, or the additive unit. Objects can either be an object constant, a variable, an intuitionistic function or application, a linear function or application, a linear additive pair or projection, or the constructor for the additive unit. A signature binds type and object constants. An LLF context is either empty, or a smaller context extended with an object binding.
We write LLF judgments using D to separate assumptions from the rest of the judgment. The meta context Ψ, yet unused, holds meta level assumptions, which we will discuss in Section 3. The form for the object typing judgment is Ψ; Γ; ΔDM : A, which states that under the meta assumptions in Ψ, the intuitionistic assumptions in Γ and the linear assumptions in Δ, the object M has type A. Figure 2 defines the static semantics of LLF. Kinds and types must be linearly closed, and thus the judgments that define their validity (Ψ; Γ DK : kind and Ψ; Γ DA : K) are declared without a linear context.
Throughout the paper we use simultaneous substitutions ρ that are defined simultaneously on the intuitionistic and linear variables. Out of notational conve- nience, we write idΓ;Δ for the identity substitution on Γ; Δ.
As an example, consider the representation of the tensor fragment of classical

ax	: neg A −◦ pos A −◦ #.
cut	: (pos C −◦ #) −◦ (neg C −◦ #) −◦ #.
tensorL : (neg A −◦ neg B −◦ #) −◦ (neg (A ⊗ B) −◦ #). tensorR : (pos A −◦ #) −◦ (pos B −◦ #) −◦ (pos (A ⊗ B) −◦ #).
Fig. 4. Encoding of Figure 3 in LLF


(Objects)	M, N ::= ... | n[ρ] | πpm
(M odules)	m	::= α | πmm
(Contexts)	Γ, Δ ::= ... | Γ, πpm : A | Γ,γ ∈ Φ (Substitution) ρ	::= ... | ρ, M/πpm
Fig. 5. LLF extensions


linear logic depicted in Figure 3. The rules cut and ⊗R illustrate how resources on either side of the sequent symbol are distributed as resources to either of the two premisses. A derivation can only then be closed by ax if the left and the right context contain a single formula A. Each inference rule is represented as a constant in LLF as shown in Figure 4. As usual, we omit the leading Π-quantifiers for inferable types. LLF’s meta theory guarantees the existence of β-normal, η-long canonical forms [19] used in order to establish the adequacy of this encoding.

The Meta Logic L+


The meta logic L+
provides the syntactic and proof-theoretic means to express

properties about encodings in LLF and their respective proofs, should they exist. Following the general philosophy underlying this and other meta logical frame- works [17,2], the elegance and scalability of our approach emerges from the clear distinction between the language of representation and the language for reasoning. The meta logic L+’s noteworthy properties include that it is first-order, i.e. only a universal and an existential quantifier are available, minimal, i.e. no other proposi- tional constants but truth can be defined, and non-linear, i.e. L+ is an intuitionistic

logic designed to reason about linearity.
We first present extensions to LLF that allow our meta logic L+
to express

properties about LLF objects in Section 3.1. Next, we describe how the meta level deals with LLF contexts, and how the interface there works. The necessary vocabulary having been built, we then discuss the meta logic proper, starting with its syntax and semantics, then moving to the proof theory. The running example will be continued to illustrate the concepts in question.

Extensions to LLF
In a meta logic, we wish to reason abstractly about the existence and form of hypothetical LLF objects. LLF must be extended to allow the inclusion of these objects bound at the meta level. In a closed meta level context, any LLF objects will be standard, as described in the previous section. Figure 5 gives an exact account of these extensions, which are discussed in detail in the following paragraphs. All of LLF’s fundamental properties, including conservative extension over LF, type soundness, and the existence of canonical forms remain unchanged under these extensions.

Meta variables
LLF objects may refer to other hypothetical LLF objects whose existence is postulated by the meta logic, usually in form of a universally quantified variable. Those meta variables, denoted by n, are bound on the meta level and visible from within LLF terms.
Since meta variables are bound outside of any LLF context, they are given an explicit fixed context (of linear and intuitionistic variables). Consequently, each occurrence of a meta variable n requires an explicit mediating substitution ρ that casts an occurrence of n into the appropriate ambient context. This combination of meta variable and explicit substitution is written as n[ρ]. 3

Context variables
To control the flow of resources inside a meta theoretic proof, the meta level has to communicate to LLF how many resources are available, how many are to be consumed, and which hypothetical objects are consuming which resources. Context variables γ that are declared as part of LLF contexts in Figure 5 communicate this information and stand for slices of LLF contexts (including the intuitionistic and linear part). Within LLF, context variables are virtually invisible. For example, they can neither be consumed, substituted into, nor can they occur inside LLF objects or types. In fact, the only places where they may occur are in the contexts of other hypothetical objects, characterized by the previously described meta variables. Context variables are declared in the context Ψ that is part of the LLF typing judgment described in Figure 2.

Module variables
Meta variables and context variables form the basic interface between LLF and the meta level. This would be sufficient if we only wanted to reason about closed LLF terms. But the goal of the paper is significantly more ambitious than this, i.e. to reason about all higher-order LLF encodings, including those that may very well be open. The meta theoretic view of openness inevitably impacts the LLF level. For reasons that have not been discussed so far (but will be in the next section),

3 Our extension of LLF with meta variables is similar to a system developed for a different purpose [16], from which we take the syntax for meta variable binders.

(M odule Kinds)	k ::= sig | Πu : A. k
(M odule Sigs)	s ::= ϵ | ∃u : A. s | λu : A.s
(W orlds)	Φ ::= s | Φ∗ | Φ1 + Φ2
(M odule Contexts) χ ::= · | χ1, χ2 | γ ∈Φ | α : s
(Meta Contexts)	Ψ ::= · | Ψ,n :: (χDA) | Ψ,γ ∈(χDΦ) | Ψ,α :: (χD s)
Fig. 6. Module context syntax

[[·♩♩	= ·
[[χ, χ'♩♩	= [[χ♩♩, [[χ'♩♩
[[γ ∈Φ♩♩	= γ ∈Φ
[[m : ϵ♩♩	= ·
[[m : ∃u : A. s♩♩	= πpm : A, [[πmm : [πpm/u]s♩♩

Fig. 7. Flattening

the open parameters are grouped into modules, made visible to LLF in the form of module projections (such as πp(α), πp(πm(α)), and πp(πm(πm(α)))) of module variables α. These projections behave like any other LLF variables, and are thus subject to declaration in an LLF context and to instantiation by a substitution, as described in Figure 5.

Module contexts and worlds
We have thus far discussed the required extensions to LLF from the point of view of LLF. For the remainder of this section, we switch our point of view to that of the meta level. In the full generality of higher-order encodings, inductive arguments often require reasoning under λ-binders, which is tantamount to reasoning about open objects. The argument often calls for more than one hypothesis that seem unrelated at first glance. It is the simultaneous presence of these hypotheses that make a base case go through, or justify the application of a previously proved lemma. Thus, instead of dealing with individual parameters, the meta level deals with collections of related LF parameters called modules. Modules are classified by mod- ule signatures s. A module is either empty (classified by the signature ϵ) or a pair, where the first element is an LLF parameter and the second element is another module (classified by the signature ∃u : A. s). The final possible classification, λu : A.s, denotes a module of signature s parameterized by an LLF object of type
A. Module kinds k are used to keep track of whether a module is fully instantiated (sig) or parameterized (Πu : A. k).
Modules themselves remain abstract, so no concrete module constructors are needed. Instead, a module can consist of a variable (α), or the second element of



[·♩P
= ·
⎧⎨ [Γ♩P ,u : B if P (B, A)

[Γ,u : B♩P
A
=
⎩ [Γ♩P

otherwise


[Γ,π m : B♩P
⎧⎨ [Γ♩P , πpm : B if P (B, A)

p	A

[Γ,γ ∈ Φ♩P
⎩ [Γ♩P
= [Γ♩P ,γ ∈ [Φ♩P
otherwise

A	A	A
[ϵ♩P	= ϵ

[∃u : B. s♩P
= ∃u : B. [s♩P
if P (B, A)

[∃u : B. s♩P
= [s♩P
if not P (B, A)

[λu : A.w♩P
[Φ∗♩P
[Φ1 + Φ2♩P
= λu : A.[w♩P
= ([Φ♩P )∗
= [Φ1♩P + [Φ2♩P


Fig. 8. Filtering modulo P

some other module m (πmm), with the m subscript indicating this is the module subcomponent. The typing rules for modules are standard, as they are simply an instance of dot notation [4].
The meta logic’s view of LLF (intuitionistic and linear) contexts Γ; Δ is called a module context, defined in Figure 6 by the syntactic category χ. Informally, the meta level does not distinguish between the intuitionistic and linear contexts, it merely stipulates the existence of particular modules α (of module signature s), or slices γ whose linear part is known to be consumed by a quantified LLF object (expressed as a meta variable).
Module contexts χ must not be thought of as a collection of meta level bindings of γ and α variables, but rather as an abstract description of LLF level bindings. The actual meta level binding takes place in meta contexts Ψ (Figure 6), that we have already used (however not defined) in Figure 2. Meta variables, context variables, and module variables are declared in Ψ, and each declaration is indexed by a module context (denoted by the leading χ D) describing its free variables.
The colorful collection of α’s and γ’s fully describes a hypothetical pair of valid LLF contexts. The precise relation between the two is discussed in the next sub- section. It is important to note, however, that the particular order of declarations in χ is irrelevant and does not reflect the order or declarations within Γ; Δ. For example, the module context γ, γ' stands for an arbitrary valid interleaving of two valid contexts Γ; Δ and Γ'; Δ'.
The type of a module context is defined by world Φ, that, intuitively speaking, describes the shape of a context in the form of a regular expression built from module

signatures, repetition and alternation. Worlds have been extensively studied in prior work by the second author [18]. Module contexts may contain only modules valid in Φ. We write Ψ; χ' ▶ χ : Φ for the judgment that decides when (χ', χ) is a valid module context, and χ is in world Φ. For space reasons, the definition is omitted here.

Context conversion
Module contexts χ, while useful at the meta level, cannot directly be used by LLF. For instance, the aggregation of parameters into modules complicates the splitting of contexts required to type linear application (M ˆN ). Additionally, we want to be able to relate the intuitionistic and linear LLF contexts, so we must derive them both from a single χ.
A module context χ is converted to an LLF context Γ in a two step process. First, χ is flattened into an LLF context [[χ♩♩, as defined in Figure 7. This process simply breaks apart each module m in χ into its individual parameters.
Flattening keeps all parameters, which leads to unwanted parameter duplication if used to produce both the Γ and the Δ from a single χ. Furthermore, in the case of the linear context, we must cull extra variables that may occur in χ that simply cannot occur in an LLF object of a certain type.
We solve both of these problems by ﬁltering. Filtering, given by [Γ♩P , elimi- nates from an LLF context any variables of type B that do not match the binary predicate P (B, A). It is defined in Figure 8. Similarly, in the case of context vari-

ables, we apply filtering to the world annotation [Φ♩P
and remove all references to

module projections that do not match the predicate, creating a narrower view of γ. Our notion of filtering is very general because we permit two seemingly unrelated predicates to transform χ into the intuitionistic and linear context. We require that the resulting Γ; Δ always forms a valid LLF context.
A good choice for each P is one based on the subordination relation [20]. In LLF, all types must be linearly closed. Therefore for the linear context, we use the

predicate A ≺ˆ
B, which holds when objects of type A can occur in objects of type

B, but not at the type level. For the intuitionistic context, we use the predicate A ≺: B, which holds if some object of type A can occur in an object of type B, possibly at the type level. This pair of predicates makes as many things as possible linear. If instead the predicate used for the intuitionistic context holds for all pairs of LLF types and the predicate for the linear context holds for none, L+ reduces to
a meta logic of the logical framework LF [10].
We write the composition of filtering with flattening as [[χ♩♩P . This composition is used any time we are transitioning from the meta logic level to the logic level.

LLF typing rules revisited
The additional typing rules of our extension to LLF in Figure 9 can now be explained in detail. The two bottom rules for the intuitionistic and linear use of module parameters follow the axiom rule of LLF. The top rule in that figure is the typing rule

Ψ(n)= (χD A)	Ψ; Γ;Δ Dρ : [[χ♩♩≺:; [[χ♩♩≺ˆ
A	A
Ψ; Γ; Δ D n[ρ]: [ρ]A


Ψ; Γ; · D πpm : Γ(πpm)	Ψ; Γ; πpm : AD πpm : A
Fig. 9. Typing rules of extended LLF.



(F ormulas)	F ::= ∀n :: (χDA). F | ∀γ ∈(χDΦ). F | ∃n :: (χDA). F | T
(Programs)	P ::= Λn :: (χDA). P | Λγ ∈(χDΦ). P | P M | P χ
| ⟨⟨χDM ; P ⟩⟩ | ⟨⟨⟩⟩ | x | case Ω | μ x ∈ F. P
| ν α :: (χD s). P 
(Cases)	Ω ::= · | Ω, (Ψ ▶ σ '→ P ) (Meta Contexts) Ψ ::= ... | Ψ,x ∈ F
(Substitutions)	σ ::= · | σ, M/n | σ, χ/γ | σ, P/x | σ, α/α

Fig. 10. L+ syntax



for meta variables n of type A in context χ declared in Ψ. The judgment Ψ; Γ'; Δ'Dρ : Γ; Δ, which we omit the definition of, ensures that the substitution ρ will, when applied to an object well-typed under Ψ; Γ; Δ, produce an object well-typed under Ψ; Γ'; Δ'. The second premiss of the typing rule for meta variables therefore checks that the substitution associated with the meta variable will correctly map an object substituted for n into the ambient context.


Formulas and their semantics
L+ itself is a first-order meta logic custom designed for LLF. Similar to ł+ [17] its
ω	ω
syntactic categories consist of formulas, programs, and cases, given in Figure 10.
The universal quantifiers of L+ range over meta variables n and context variables γ, where χ is the aforementioned module context that describes all free variables of the term in question. There are no quantifiers for module variables α. We do not include existential quantification over module contexts because it does not seem to serve any useful purpose, as opposed to universal quantification, which is required for induction. T stands for the only propositional constant truth expressible in L+.

The semantic entailment for L+
is written in terms of |=, a relation that is

defined as follows (in terms of the flattening and filtering operation [[χ♩♩P described

in Section 3.3):
|= ∀γ ∈(χDΦ). F iff |= [χ'/γ]F for all · ; χ ▶ χ' :Φ 
|= ∀n :: (χDA). F iff |= [M/x]F for all ·; [[χ♩♩≺:; [[χ♩♩≺ˆ DM : A
A	A
|= ∃n :: (χDA). F iff |= [M/x]F for some ·; [[χ♩♩≺:; [[χ♩♩≺ˆ DM : A
A	A
|= T
The existential is the dual to the universal quantifier, and true is always valid.
Programs
The semantics of L+ portrays its intended use as a meta logic to reason about LLF encodings. Any proof within this meta logic should convince a critical observer of the validity of the statement, lemma, or theorem. It is almost certainly possible to give a categorical or model theoretic explanation of proof. We have instead chosen to view proofs as total programs via a realizability interpretation. A proof hence acts as a transformation in between LLF encodings. Its input/output behavior is fixed by the formula, its type.
Figure 10 describes the syntactic category for programs. Λn :: (χDA). P and Λγ ∈(χDΦ). P are the two binding constructs of L+ for LLF objects n and module contexts γ, respectively. Symmetrically, two forms of application P M and P χ serve as the respective elimination forms. ⟨⟨χD M ; P ⟩⟩ is a proof term for an existential formula, pairing an LLF term with a program. Next, the Figure shows the familiar unit ⟨⟨⟩⟩ and program variables x and three more constructs that we will explain next: the case construct with cases Ω, the recursion operator μ, and finally the new operator ν.
Case and recursion are necessary to express inductive proofs as programs. The formulation of case (case Ω), the elimination form for LLF objects, looks peculiar, but is in fact quite natural. There is no explicit case subject, because implicitly, case matches against the ambient context in which a “case” may occur. This choice will prove useful in the meta theoretic investigation in Section 5, because dependencies render matching a non-local operation. Each individual case in Ω, (Ψ ▶ σ '→ P ), consists of a substitution σ that serves as the pattern for that particular case. Each free variable that occurs in a pattern must be declared in Ψ and the body P may not refer to any other variables other than the ones declared in Ψ. The fixed point operator μ x ∈ F. P provides the most general form of the induction hypotheses.
Unbounded recursion and case with an empty Ω illustrate that without further

side condition L+
programs may be partial and hence non-total. The following

three side conditions to case Ω and μ x ∈ F. P , respectively, remedy that problem and enforce totality.
Strictness. Each x ∈ Ψ must have at least one occurrence in the pattern that leads to an unambiguous solution of the higher-order matching algorithm to be used.
Coverage. For all patterns σ within Ω, and or all ambient environments η, there exists a new ambient environment η', such that [η']σ = η.

Ψ; ·▶ χ :Φ	Ψ; [[χ♩♩≺: DA : type	Ψ,n :: (χDA) ▶ P ∈ F
Ψ ▶ Λn :: (χDA). P ∈ ∀n :: (χDA). F 

Ψ ▶ P ∈ ∀n :: (χDA). F	Ψ; [[χ♩♩≺:; [[χ♩♩≺ˆ DM : A
A	A
Ψ ▶ P M ∈ [idΨ, M/n]F


Ψ; ·▶ χ :Φ	Ψ,γ ∈ (χD Φ) ▶ P ∈ F


Ψ ▶ Λγ ∈(χDΦ). P ∈ ∀γ ∈(χDΦ). F 
Ψ ▶ P ∈ ∀γ ∈(χDΦ). F	Ψ; χ ▶ χ' :Φ Ψ ▶ P χ' ∈ [idΨ, χ'/γ]F


Ψ; ·▶ χ :Φ	Ψ ▶ P ∈ [idΨ, M/n]F	Ψ; [[χ♩♩≺:; [[χ♩♩≺ˆ DM : A
A	A
Ψ ▶ ⟨⟨χDM ; P ⟩⟩∈ ∃n :: (χDA). F 




Ψ ▶ ⟨⟨⟩⟩ ∈ T
  Ψ ▶ Ω ∈ F			
Ψ ▶ case Ω ∈ F	Ψ ▶ x ∈ Ψ(x)
Ψ,x ∈ F ▶ P ∈ F
Ψ ▶ μ x ∈ F. P ∈ F
(∗∗)


Ψ; ·▶ χ :Φ	Ψ; [[χ♩♩ Ds : sig	Ψ,α :: (χD s) ▶ P ∈ F	Ψ ▶ F ok Ψ ▶ ν α :: (χD s). P ∈ F
................................................... ........................... 
Ψ ▶ Ω ∈ F	Ψ' Dσ :Ψ	Ψ' ▶ P ∈ [σ]F

Ψ ▶·∈ F
Ψ ▶ Ω, (Ψ' ▶ σ '→ P ) ∈ F	(∗)


Fig. 11. Derivability in L+
Termination. For all arguments M1 ... Mn to P it holds that for all x that occur in P and arguments N1 ... Nn to x, it holds that (N1 ... Nn) < (M1 ... Mn) with respect to some well-founded order <.
Finally, ν α :: (χDs). P introduces a new module variable during runtime. Often, for proofs about higher-order encodings the corresponding program has to recurse under an LLF λ binder, be it linear or intuitionistic. Afterwards modules can always be discharged via the mediating substitutions attached to meta variables. There are no other elimination forms for modules.
Proof theory for L+
L+’s design is based on the realizability interpretation of total programs as proof. The type system for programs that is described in this section plays the role of a meta logic, whose soundness is shown in Section 5. Our approach to developing the meta logic follows closely [17] and differs significantly from [7], who show the soundness of their design by a cut-elimination argument.
L+’s type theory is defined in Figure 11 in terms of two mutually dependent typing judgments: Ψ ▶ P ∈ F for programs and Ψ ▶ Ω ∈ F for cases, using three

Ψ' Dσ :Ψ	Ψ'; [[[σ]χ♩♩≺:
; [[[σ]χ♩♩≺ˆ
DM : [σ]A



Ψ' D (σ, M/n): (Ψ,n :: (χDA))




Ψ D · : ·
Ψ' Dσ :Ψ	Ψ'; [σ]χ ▶ χ' :Φ 

Ψ' D (σ, χ'/ц): (Ψ,ц ∈ (χD Φ))



Ψ' Dσ :Ψ	Ψ' ▶ P ∈ [σ]F
Ψ' D (σ, P/x): Ψ,x ∈ F
Ψ' Dσ :Ψ	α ∈ Ψ' Ψ' D (σ, α/α): Ψ,α 


Fig. 12. Typing rules for patterns
auxiliary judgments. Two of those judgments Ψ; Γ D s : sig and Ψ ▶ F : ok ensure the respective validity of module signatures and formulas but do not contribute much to the understanding of the rules. The other judgment Ψ' D σ :Ψ ensures the validity of the substitutions that play the role of patterns. Patterns are important for the understanding L+ and given in Figure 12. The first rule exhibits the need for flattening and filtering when instantiating meta variables.
All of the rules in Figure 11 lend themselves to two complementary interpre- tations. Type-theoretically speaking, the first four rules account for well-typed abstractions and applications, and logically speaking, they are merely introduction and elimination rules for the universal quantifiers, albeit ones using the flattening

and filtering operation [[χ♩♩P
described in Section 3.3. The fifth rule is the typing

rule for pairs, and simultaneously an introduction rule for the existential quantifier. The corresponding elimination rule is subsumed by the case rules defined in below the dotted line [18], and thus need not be considered separately. The typing rule for unit is standard. Ω, the argument to case, is a list of all of the cases (which must all have the same type). The type of a variable x can be inferred from the meta context, and recursion is standard. The rule for ν extends Ψ by a new mod- ule constant. The typing rule ensures that α does not escape during evaluation by requiring that the type of the body not contain α.
Example
We have considered a few examples from programming language and logic design to exercise and experiment with the meta logic L+ for LLF. Our case studies include stateful computations (we managed to represent all meta theoretic proofs about Mini-ML with references in the original LLF paper [6]), linear lambda calculi and of linear logic itself. We found that the proof of the admissibility of cut for the tensor fragment of linear logic (see Figure 3), illustrates L+’s unique characteristics the best. Of course, there is a certain risk of confusing the reader with two conceptually different yet linear logics.
Theorem 4.1 (Admissibility of cut) If P :: Γ1 =⇒ C, Δ1 and Q :: Γ2,C =⇒ Δ2 then Γ1, Γ2 =⇒ Δ1, Δ2.

Proof. By lexicographic structural induction on the subformula A and simultane- ously on P and Q [15]. We show only the essential case between ⊗R and ⊗L.

P :: Γ' , Γ'' =⇒ A ⊗ B, Δ' , Δ''
(by assumption)

1
P1 :: Γ'
1	1	1
=⇒ A, Δ'
(by assumption)

P2 :: Γ'' =⇒ B, Δ''
(by assumption)

1	1
Q :: Γ2,A ⊗ B =⇒ Δ2	(by assumption)
Q1 :: Γ2, A,B =⇒ Δ2	(by assumption)
R1 :: Γ' , Γ2,B =⇒ Δ' , Δ2	(by ind. hyp. on P1, Q1)
1	1
R :: Γ' , Γ'', Γ2 =⇒ Δ' , Δ'', Δ2	(by ind. hyp. on P2, R1)
1	1	1	1

Theorem 4.1 corresponds to the following formula in L+.
∀ц1 ∈ (· D Φ). ∀ц2 ∈ (ц1 D Φ). ∀C : (· D o).
∀P : (ц1 D pos C → #). ∀Q : (ц2 D neg C → #).
∃R : (ц1, ц2 D #). T
where
Φ= ((λA : o. ∃n : neg A. ϵ)
+(λA : o. ∃p : pos A. ϵ))∗.
The first two quantifiers in (1) range over module contexts ц1 (valid in the empty context ·) and ц2 (valid in ц1). ц1 represents the list of hypotheses of both Γ1 and Δ1, while ц2 represents Γ2 and Δ2. Φ is the world of these contexts, ensuring that ц1 and ц2 only contain assumptions of the form “pos A” and “neg A”. For example,
p1 : pos A1, p2 : pos A2, n3 : neg A3 ∈ Φ.
In (1), C ranges over closed formulas, P over sequent derivations in ц1 with formula C on the left, and Q over sequent derivations in ц2 with formula C on the right. R stands for the result derivation, necessarily valid in the union of ц1 and ц2.
The proof Formula (1), on the other hand is a total program that maps contexts Δ1, Δ2, and LLF objects C, P and Q such that ·; ·▶ C : o, ·; Δ1 ▶ P : pos C → #, and ·; Δ2 ▶ Q : neg C → # into an LLF object R such that ·; Δ1, Δ2 ▶ R : #. In the interest of clarity, the surface language used in Figure 13 that depicts only the essential case of the proof above, making use of a significant amount of syntactic sugar.
fun defines the recursive program “ca” by cases. “ca” expects five arguments, including two contexts, all in the form of patterns. Γ' , Γ'', Γ2, A, B, P1, P2 and Q2
1	1
occur free in the pattern and in the body of that case. Thus fun is a shorthand
for a leading μ, followed by several Λ binders and a case expression. For uniformity reasons, we write new.. . in ... end for ν α :: (χ D s). P . And finally, the let ... in
.. . end is the standard local binding construct that can be directly expressed using
L+ programs by combining nested program application with implicit case analysis.

Figure 13 illustrates the novel and distinct features of L+
including pattern-

matching against linear patterns, hypothetical reasoning, and context splitting. We describe the program in greater detail in the rest of this section, in the context of

fun ca (Γ' , Γ'') Γ2 (A ⊗ B)
1	1
(ˆλp :pos (A ⊗ B). tensorRˆ(Γ' D P1)ˆ(Γ'' D P2)ˆp)
1	1
(ˆλn : neg (A ⊗ B). tensorLˆ
(Γ2 D (ˆλn1 : neg A. ˆλn2 : neg B. Q1ˆn1ˆn2))ˆn)= 
new α :: (Γ' , Γ2 D ∃n : neg B. ϵ) in

let
val ⟨R1, ⟨⟩⟩ = ca Γ'

(Γ2,α : ∃n : neg B. ϵ) A P1

(ˆλn1 : neg A. Q1ˆn1ˆπp(α)])
val ⟨R, ⟨⟩⟩ = ca Γ'' (Γ' , Γ2) B P2 (ˆλn : neg B. R1[n/πp(α)])
1	1
in
⟨R, ⟨⟩⟩
end end
Fig. 13. Admissibility of cut, essential case

an analysis of ca’s properties regarding strictness, coverage, and termination.


Strictness.
Upon application, matching will always instantiate all free variables in the pat- tern of “ca”. The claim follows directly for Γ2, A, B, P1, P2, and Q1, which leaves
' and Γ'' to be explained. In L+, every object carries its own context, which
means that any instantiation of P1 and P2 decides the instantiations for Γ' and Γ'',
respective, rendering matching a deterministic operation.


Coverage.
The first two arguments to “ca” are the context patterns (ц' , ц'') and ц2. How
1	1
the context is split into ц' and ц'' is determined by how the two contexts are used.
This is fixed by ascribing context information to the two variables P1 and P2 bound
in the fourth argument to “ca”: (ˆλp :pos (A ⊗ B). tensorRˆ(ц' D P1)ˆ(ц'' D P2)ˆp).
1	1
Context and type ascription are features of the syntax we have chosen to present
proofs in L+ in, with counterparts in the formal development of L+ in Section 3.
ω	ω
The challenge is to verify that “ca” covers all cases. Canonical forms are patterns and in the interest of completeness, two additional cases related to “tensorR” must be considered, depending on if p is consumed in P1 or P2.

Termination.
“ca” must be total in order to be considered a proof. Therefore any evaluation of “ca”, independent of what arguments are applied, must terminate. Consider the body of “ca” in Figure 13. The two recursive calls to “ca” correspond to appeals to the induction hypothesis in the proof of Theorem 4.1, yielding result objects R1 and R, respectively.
The first instruction is the new instruction that introduces a new hypotheses of type neg B. Recall from the proof of Theorem 4.1 that R1 is the result of the induction hypothesis applied to P1 and Q1, which is parametric in B. Since hypo- thetical arguments are encoded via higher-order functions, “ca” can only execute a recursive call after traversing the binder (ˆλn2 : neg B). In general one can only do this by applying it to a new parameter n2 : neg B, in form of the module declaration

α :: (ц' , ц2 D ∃n : neg B. ϵ).
α is a new variable, that ranges over groups of new parameters, and is similar to x in [18]. Intuitively, one can think of a module as a temporary list of new constant symbols that act as placeholders within the body of new. The ц' , ц2 resolve all ambiguities related to the naming of α. We write πp to project the head of the list, and πm for the tail. πp(α), for example, is a new name for the newly introduced parameter, and should be used instead of n2.
The first recursive call cuts P1 and Q1 with cut-formula A. Eventually, the computation will finish and the resulting derivation R1 will use all resources of the set ц' , ц2,α : ∃n : neg B. ϵ, which corresponds directly to the informal proof. Recall

that ц'
represents assumption lists Γ'
and Δ' , ц2 the assumption lists Γ2 and Δ2,

and α to the additional hypothesis B that occurs to the left of the sequence arrow.
The other recursive call for cutting P2 and R1 is similar to the first except that this time the cut formula is B. R1 is parametric in πp(α), which is subsequently replaced by a linear variable n before the second recursive call is invoked. Replace- ments of this kind are supported in L+, expressed by substituting n for πp(α). The
resulting R is valid in ц' , ц'', ц2, and does therefore not depend on α. Hence, it can
1	1
safely escape the scope of new.
“ca” terminates because the arguments that correspond to derivations P and Q are smaller with respect to a well-founded lexicographical order on the cut formula and simultaneously on P and Q. In this work, we consider only lexicographic and simultaneous extensions of the subterm ordering. In particular the first recursive call terminates because A and B are subterms of A ⊗ B.
Meta Theory of L+
The totality of every program in L+ is a sufficient and necessary condition for the soundness of L+. The argument relies on a small-step operational semantics which we omit here. We define a evaluation meta context E to be a meta context Ψ binding only module variables α. For the purposes of the operational semantics, we extend the set of programs with a closure {σ; P }, in which σ is a substitution

that maps P from whatever meta context it is well-typed under into the outer meta context. The evaluation judgment E ▶ P → P ' relates a program P to the outcome of a single evaluation step P '. For a sequence of zero or more evaluation steps, we write E ▶ P →∗ P '. The set of values is V .
V ::= Λn :: (χDA). P | Λц ∈(χDΦ). P | ⟨⟨χDM ; V ⟩⟩ | ⟨⟨⟩⟩
For functions, applications, existentials and fixed points, evaluation proceeds in the standard fashion. The evaluation of a closure {σ; P } is essentially carrying out a single step of lazily applying the substitution σ to P . This is done because eager substitution is not sound in the presence of case. Evaluation of (case Ω, (Ψ ▶ σ' '→ P )) in a closure proceeds by attempting to generate a substitution σ'' that, when composed with σ', is equivalent to the σ of the closure. If one is found, then evaluation of P continues in a closure under σ''. The evaluation of ν α :: (χD s). P proceeds by evaluating P until it becomes a value. When it finally becomes a value, the ν binding is pushed into any non-values (as occur in a function) that may exist in the value. In addition to the usual weakening and exchange lemmas, the following properties hold:
Lemma 5.1 (LLF module variable strengthening) If Ψ; · ▶ χ :Φ and Ψ,α :: (χ' D s); [[χ♩♩≺:; [[χ♩♩≺ˆ DM : A then Ψ; [[χ♩♩≺:; [[χ♩♩≺ˆ DM : A.
A	A	A	A
Proof. If χ does not contain α, then the LLF context produced by flattening and filtering χ cannot contain any projections from α, and thus neither can M . 
Theorem 5.2 (Type preservation) If E ▶ P ∈ F and E ▶ P → P ' then E ▶
P ' ∈ F.
Proof. By induction on the structure of the evaluation relation. The cases for ν rely on the fact that the type of the body of the ν must not use the bound module variable, and on Lemma 5.1. This allows the ν to be pushed inward while preserving the type. The substitution cases rely on the soundness of the substitution of σ into χ, A, M and x.		 
Theorem 5.3 (Progress) If E ▶ P ∈ F then either P is a value or E ▶ P → P '.
Proof. By induction on the structure of the typing derivation. The progress proof uses the fact that E binds only module variables, and on the usual canonical forms lemma. It also relies on the coverage condition holding, which ensures that the program (case ·) is never evaluated.		 
Theorem 5.4 (Termination) If E ▶ P ∈ F then E ▶ P →∗ V .
Proof. By induction on the typing derivation, keeping track of the instantiations of the values bound by reductions of μ, using the termination condition. 
Theorem 5.5 (Soundness) If ·▶ P ∈ F then |= F.
Proof. By induction on F , using Theorems 5.2, 5.3 and 5.4.		 

Conclusion
We have described the meta logic L+ for the linear logical framework LLF. LLF is useful for the representation of formal systems that rely on a notion of deletable resource. Surprisingly, many such systems can be represented in LLF, among them programming languages with effects, state transition systems, such as the infamous blocks world often used in AI, and of course resource oriented logics such as linear logic itself.
The meta logic L+ is custom-made for LLF, which means that it incorporates knowledge about linear assumptions, how they are consumed, split in the multi- plicative, and duplicated in the additive fragment. It enables the formalization of meta theoretic properties, the mechanization of reasoning about LLF encodings, and leads to relatively short proof terms. The soundness of L+ follows from a real- izability argument that shows that every function in L+ is total, i.e. it terminates
and covers all cases.
In future work, we plan to implement a proof checker and an automated theorem prover for L+, and consider extensions to the ordered logical framework and the concurrent logical framework.

References
Andrew W. Appel. Foundational proof-carrying code. In 16th Annual IEEE Symposium on Logic in Computer Science (LICS ’01), pages 247–258, Boston, USA, June 2001.
David Basin, Manuel Clavel, and Jos Meseguer. Rewriting logic as a metalogical framework. In Foundations of Software Technology and Theoretical Computer Science (FSTTCS), pages 55–80. Springer-Verlag LNCS 1974, 2000.
Iliano Cervesato, Nancy Durgin, Patrick D. Lincoln, John C. Mitchell, and Andre Scedrov. A Meta- Notation for Protocol Analysis. In 12th Computer Security Foundations Workshop — CSFW-12, pages 55–69, Mordano, Italy, 28–30 June 1999. IEEE Computer Society Press.
Luca Cardelli and Xavier Leroy. Abstract types and the dot notation. In Proc. Programming Concepts and Methods, pages 479–504. North Holland, 1990.
Thierry Coquand. An algorithm for testing conversion in type theory. In G´erard Huet and Gordon Plotkin, editors, Logical Frameworks, pages 255–279. Cambridge University Press, 1991.
Iliano Cervesato and Frank Pfenning. A linear logical framework. In E. Clarke, editor, Proceedings of the Eleventh Annual Symposium on Logic in Computer Science, pages 264–275, New Brunswick, New Jersey, July 1996. IEEE Computer Society Press.
Alwen Fernanto Tiu Dale Miller. A proof theory for generic judgments. In Proceedings of 18th IEEE Symposium on Logic in Computer Science (LICS 2003), pages 118–227, Ottawa, Canada, 2003. IEEE Computer Society.
J.-Y. Girard. Linear logic. Theoretical Computer Science, 50:1–102, 1987.
John Harrison. Floating point verification in HOL Light: The exponential function. Technical Report 428, University of Cambridge Computer Laboratory, 1997.
Robert Harper, Furio Honsell, and Gordon Plotkin. A framework for defining logics. Journal of the Association for Computing Machinery, 40(1):143–184, January 1993.
Raymond McDowell and Dale Miller. A logic for reasoning with higher-order abstract syntax: An extended abstract. In Glynn Winskel, editor, Proceedings of the Twelfth Annual Symposium on Logic in Computer Science, pages 434–445, Warsaw, Poland, June 1997.
Tobias Nipkow and David von Oheimb. Java-light is type-safe — definitely. In L. Cardelli, editor, Conference Record of the 25th Symposium on Principles of Programming Languages (POPL’98), pages 161–170, San Diego, California, January 1998. ACM Press.

Lawrence C. Paulson. Isabelle: A Generic Theorem Prover. Springer-Verlag LNCS 828, 1994.
Lawrence C. Paulson. Proving properties of security protocols by induction. In Proceedings of the 10th Computer Security Foundations Workshop, pages 70–83. IEEE Computer Society Press, June 1997.
Frank Pfenning. A structural proof of cut elimination and its representation in a logical framework. Technical Report CMU-CS-94-218, Department of Computer Science, Carnegie Mellon University, November 1994.
Brigitte Pientka and Frank Pfenning. Optimizing higher-order pattern unification. In CADE-19, pages 473–487, Miami Beach, Florida, July 2003.
Carsten Schu¨rmann. Automating the Meta-Theory of Deductive Systems. PhD thesis, Carnegie Mellon University, 2000. CMU-CS-00-146.
Carsten Schu¨rmann. Recursion for higher-order encodings. In Laurent Fribourg, editor, Proceedings of the Conference on Computer Science Logic (CSL 2001), pages 585–599, Paris, France, August 2001. Springer Verlag LNCS 2142.
Joseph C. Vanderwaart and Karl Crary. A simplified account of the metatheory of linear lf. Electronic Notes in Theoretical Computer Science, 70(2), 2002.
Roberto Virga. Higher-Order Rewriting with Dependent Types. PhD thesis, Department of Mathematical Sciences, Carnegie Mellon University, 1999. Forthcoming.
