	Electronic Notes in Theoretical Computer Science 141 (2005) 115–133	
www.elsevier.com/locate/entcs

Actors and Logical Analysis of Interactive Systems

Ian A. Mason1 ,2
School of Mathematics, Statistics, and Computer Science University of New England
Armidale, NSW 2351, Australia

Carolyn L. Talcott3
Computer Science Laboratory SRI International
Menlo Park, CA 94025, USA


Abstract
Formalization in a logical theory can contribute to the foundational understanding of interactive systems in two ways. One is to provide language and principles for specification of and reasoning about such systems. The other is to better understand the distinction between sequential (turing equivalent) computation and interactive computation using techniques and results from recursion theory and proof theory. In this paper we briefly review the notion of interaction semantics for actor systems, and report on work in progress to formalize this interaction model. In particular we have shown that the set theoretic models of the formal interaction theory have greater recursion theoretic complexity than analogous models of theories of sequential computation, using a well-known result from recursion theory.
Keywords: Actors, interaction semantics, Feferman theories, recursion theory.



1 The authors wish to thank Michael Beeson for helpful discussions, and the anonymous reviewers for helpful criticisms. The work was partially supported by NSF grant CCR- 023446.
2 Email: iam@turing.une.edu.au
3 Email: clt@cs.stanford.edu




1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.05.019

Introduction
An important challenge for foundations of interactive computation is to pro- vide a basis for specification and reasoning about interactive systems, even- tually leading to principled methods for design, implementation, and deploy- ment of such systems. A foundation should identify primitives for specification that in combination with appropriate logical constructs lead to specification languages and logics for reasoning about the behavior of specified systems, and means of checking (statically or dynamically) that a given system meets its specification. Another challenge is to better understand the distinction between interactive computation and computability in the sense of Turing machines or lambda calculus. Intuitively it seems clear that interactive com- putation is not equivalent to Turing computation. The question is how to make this intuition more precise.
Traditionally, notions of computability are strongly tied to complexity of fragments of first-order and other logics. We propose that one way to begin to understand the distinction between sequential (Turing equivalent) compu- tation and interactive computation is to understand the power of the logics needed to formally represent models of interactive computation. To explore this idea in more depth, we examine a formalization, currently being devel- oped, of the interaction semantics of actor systems. To be clear, we are not proposing a new model of interactive computation, but rather analyzing the expressive power of an existing model in comparison to sequential computa- tion.
To set context, in Section 2 we briefly review some of our work on ac- tor semantics that lead to this notion of interaction semantics. In Section 3 we briefly summarize our work on formal theories for sequential computation based on Feferman’s theories for formalizing constructive mathematics, and then describe a Feferman style formal theory of interaction semantics. The theories of sequential computation formalize and reason about input/output relations and their properties. These theories have natural, term generated, recursively enumerable models that capture the intended semantics. For ex- ample, Feferman’s theories such as IOCΛ and IOCλ [10] all have natural recursion theoretic models where the space of total functions Nat → Nat is interpreted as the total recursive functions, and the corresponding partial function space as the partial recursive functions. In contrast, theories of inter- active computation must formalize the interactions a system may have with its environment, where nothing is known about the behavior of entities in the environment. In Section 4 we show that recursively enumerable models are not adequate to capture the intended interaction semantics of actor systems using a well-known result from recursion theory.

Actor semantics

The actor model [13,12,2,3] is a model of distributed computation based on the notion of independent computational agents, called actors, that interact solely via message passing. An actor can create other actors; send and receive messages; and modify its own local state. An actor can only affect the local state of other actors by sending them messages, and it can only send messages to its acquaintances—either actors whose names it was given upon creation, or names it received in a message or names of actors it created. Actor seman- tics admits only fair computations, which in the simplest case means reliable message delivery.



Traditional actor semantics
The central concepts of traditional actor semantics [5] are the partial order of events (an event being a message receipt), acquaintance laws (who can come to know whom), and fairness of computations. The essential properties are captured in the notion of event diagram [11,6] characterizing the possible computations of an actor system.
In the following, we will use the much overworked Ticker actor to illustrate concepts. A Ticker actor, t, has its own integral notion of time n, and responds to two types of messages: a tick request, and a time request. A Ticker processes requests as follows:
upon receiving a tick message (ta tick) a Ticker increments n, and sends itself a new tick message.
upon receiving a time request from an actor c (ta time @ c) a Ticker sends
c a message reply(n) where n is its current notion of time.
Figure 1 shows the event diagram for a possible Ticker computation, where the Ticker t interacts with some external actor c.
What might we say and/or prove about a Ticker?
Every time request ta time @ c gets a reply ca reply(n) for some number
n.
If there is always another time request, then for any n there is a reply
ca reply(n') with n < n' among the messages sent.
Not much else can be said without imposing some additional causality con- straints on the events.



Actor Theories, Components and Interaction Semantics
Although concerned with who could receive messages and when, the early work on actor semantics did not provide a notion of interface, or a mechanism for abstracting a group of actors as an interacting component. A theory of program equivalence for actors was developed in [4] using a lambda calculus based programming language. To define the semantics, a notion of actor sys- tem interface was introduced. An interface consists of two finite sets of actor names: receptionists (system actors whose names are known externally, and thus can receive messages from the environment), and externals (environment actors whose names are known by some system actor, and thus can be sent messages from a system actor). An actor system configuration is then a col- lection of actors and messages encapsulated by an interface. The operational semantics for the language is defined by a transition system on actor system configurations. A transition is either a computation step by a system actor processing a message, or input of a message to a receptionist from the environ- ment, or output of a message to an external actor. A notion of observational equivalence was defined in the usual way as indistinguishability in all con- texts [7]. In this setting, a context is a closed configuration with a hole to be filled by the program. The observation to be made is whether or not a specific message is emitted by the context. Equivalence of configurations is defined similarly. A number of techniques were developed to prove equational laws for programs and equivalence of configurations. These techniques allowed one to

focus on messages sent and received by a configuration under consideration, to treat computations (transition sequences) modulo an equivalence relation corresponding to equating different linearizations of the same event partial order, and to collapse multiple steps of an actor into one.
Generalization of these reasoning techniques lead to two new ideas pre- sented in [25,28]. One is the notion of interaction semantics of an actor system configuration as the set of possible interaction paths (sequences of input/output interactions) that could result from interaction of the system with an arbitrary environment. The other is the notion of actor theory as a rewriting logic based specification of the behavior of actors. Rewriting logic provides an operational semantics of actor system configurations in the form of derivations viewed as computations. These derivations satisfy the equations used in [4], and contain sufficient information to also derive the interaction semantics.
In [27] an actor component algebra is defined to study the composition- ality of the different forms of specification and semantics of actor systems. The algebra makes minimal assumptions about what is being composed, lim- iting the operations to interface restriction, parallel composition, renaming, and an identity component. In particular the ability to prefix an action to a component behavior is not assumed. Using morphisms between the dif- ferent syntactic and semantic structures, compositionality of computational and interaction semantics was shown, thus justifying thinking of interaction semantics as a denotational semantics (without need for CPOs and limits!).
Two observations about interaction paths are in order. Firstly, while event diagrams give a true concurrency model, they talk about internal events. In- teraction paths correspond to what can be observed from the outside, from an arbitrary point of view. Thus all orderings of independent events will be possible, but in general it will not be possible to infer causality beyond what is implied by local observations. Secondly, although only fair computations are used to define the set of interaction paths for a given actor configuration, there are no explicit fairness constraints on what interaction sequences can form an interaction path. The only constraints are that actor acquaintance laws are obeyed. For example, a message cannot be input to an actor that is not a receptionist, and an external actor is only known if it was known initially or introduced in an incoming message.
Specifying interaction paths
Actor theories are one way to specify the possible interactions of a compo- nent. Some advantages of such specifications are that they are executable and composible. On the other hand an actor theory specifies how a system works,

not what it should do. For example, one might want to express that certain requests (incoming messages) are alway answered with a reply meeting given constraints, or the results of processing particular messages in a specific order (thus giving a stronger guarantee for a requestor that always waits for a reply before sending the next request). We have explored two alternative methods for specifying the interaction semantics of a component; specification diagrams (SD) [22,23,29], and mathematical specifications.
SD is a language with both textual and graphical representations. SDs can express interaction patterns of sequencing, choice and concurrency, (similar to regular expressions over interactions). SD can also express requirements on the environment—messages that must/must not be sent, and internal states that should or should not be reached. A restricted subset of SDs correspond to executable specifications in the spirit of actor theories. In general a SD may be partial (specifying behavior only for inputs of interest) and may not be realizable, for example requiring behavior to depend on the future, not just the past! Partial specifications are appealing as they allow one to concentrate on interactions with the intended environment. However, compositionality is not guaranteed, since a component may meet the specified constraints but exhibit behavior that leads other partially specified components to go wrong when subjected to situations not provided for. A detailed comparison of SDs and interaction semantics with other formalisms for concurrent, interactive computation can be found in [23].
Mathematical specifications specify a set of interaction paths by mathe- matical formulas with variables ranging over paths, messages, and other rel- evant entities. They are informal but rigorous and written in a stylized way. Notation and principles have been developed for using event diagram con- cepts to constrain interaction paths to those compatible with a set of event diagrams. That is, we can specify a system by saying it is indistinguishable from one whose event diagram semantics obeys the event diagram constraints. This is analogous to specifying a system by requiring it to be ‘equivalent’ to some simply defined system.
In the next section we describe a formal theory of interaction paths in which mathematical specifications can be represented as logical formulae. This is illustrated by TickerMS , a mathematical specification of a Ticker.

Variable Type Theories for Actors
When developing a formal theory the first question to ask is: What do we want to represent? Here we focus on formalization of semantic notions and their properties, a meta-logic, as a stepping stone to a logic of interaction. Thus we

need to represent: actor system descriptions (behaviors, interfaces, configura- tions); operational semantics (transitions and fair computations); interaction semantics; and the satisfaction relation between a system description and a property of interaction paths
iC |=Φ ⇔ [[iC ]] ⊆ [[Φ]].
Here iC is an actor configuration, with an explicit interface, and Φ is a sentence in our formal theory. The semantics [iC ], or meaning, of the configuration iC is a set of interaction paths, each interaction path distilling the observable interactions from the actions that take place in a particular computation path. Analogously the semantics [[Φ ], or meaning, of the formula Φ is the set of those interaction paths that satisfy it.
We continue our approach of using logical theories developed by Feferman to formalize constructive mathematics. These are 2-sorted classical theories called variable type theories in which both functions and data are objects of discourse in a first order setting, as are collections of such things (called clas- sifications). Classifications provide a balance between expressive power and complexity, allowing one to represent inductively and co-inductively defined sets, computable function spaces and other sets of interest, all in a first-order setting.
In the spirit of Landin [16], the languages we have studied consist of lambda expressions augmented with operations for computational primitives of inter- est: control abstractions, memory allocation and access, actor creation and messaging, and so on. The sequential languages all have a transition system semantics with strong uniformity properties [26] and are called Landinesque languages. Earlier work on formal theories for sequential languages includes IOCC, VTLoE, and FLL. IOCC [24] is an adaptation of Feferman’s IOCλ
[10] that formalizes continuations and control primitives such as Scheme’s call-cc, providing axioms for reasoning about computations with contin- uations. VTLoE [15] was developed to reason about functional programs with effects, such as ML, Scheme, or Lisp. VTLoE was generalized to a logic, FLL, (Feferman-Landin Logic) [18] for reasoning about Landinesque languages. Adapting constructions of [8,9], it was shown in [24] that IOCC has term-based, recursively enumerable models.

Formalizing Interaction Semantics
The formalization uses Feferman’s IOCλ as a starting point. This formal sys- tem provides quantification over individuals and classifications. Individuals include lambda terms, and numbers. Classifications (briefly classes) are col-

lections of individuals defined by comprehension K = {x	ψ(x)}. Constants,
operations, axioms and rules for actor specific entities are then added, includ- ing: the Actor Communication Basis (ACB) that provides a basis for both the semantic and behavioral descriptions of actor configurations; interfaces; interaction paths, the elements of interaction semantics; configurations, speci- fied by describing their constituent actor’s behaviors; and computation paths, corresponding to single executions of a configuration.
Notationwise, Pω(X) is the set of finite subsets of X, while Mω(X) is the set of finite multisets from X, and ∅ is the empty set. Following logical tradition, the axioms are presented informally, with the understanding that it is not problematic to fill in details needed to be completely formal.

Actor Communication Basis.
The actor communication basis, ACB, is a direct translation of the rewrit- ing logic formalization of actor theory [28]. It defines the basic language needed to talk about actor interactions. The basic sorts are actor names, a ∈ A, mes- sage contents, M ∈ Msg, and message packets, a a M ∈ MP =∼ A × Msg. The components of a message packet are call the target (an actor name) and the message contents which can be extracted by the two operations target : MP → A, and message : MP → Msg. We let mp range over MP.

Interfaces.
Interfaces are used to encapsulate configurations, and interaction sequences. They consist of two finite sets of actor names, (ρ, χ) ∈ Iface, the reception- ists, ρ, and the externals, χ. In other words Iface ∼= Pω(A) × Pω(A). Recall that the receptionists are those internal actors (internal to a configuration) known externally, while the externals, are those external actors (external to a configuration) known internally.

Interaction paths.
Interaction paths are formalized by introducing a class constant ISeq of interaction sequences. ISeq is subject to axiomatic constraints, but is not defined by comprehension. Thus interaction sequences are not necessarily λ definable. In fact we will see below that they cannot all be λ definable. Mathematically, an interaction path, ip ∈ IP, is a sequence of interactions annotated by an initial interface. An interaction, io ∈ IO, is either the input or the output of a message packet: IO ∼= in(MP) ∪ out(MP). Sequences of interactions, ϑ ∈ ISeq, are just functions from natural numbers into in- teractions, enriched with a silent tau transition: ISeq ∼= (Nat → IO ∪ {τ }).

Interaction paths are constructed from interfaces and interaction sequences via ( ) : Iface × ISeq → IP. We write IP(ρ, χ) for the set of interaction paths of the form (ρ, χ)ϑ.


Actors and Configurations.
An actor has the form a : B where a ∈ A is the actor’s name and B is the actors behavior. A behavior is a lambda term of the form λ(a, M , ν)e, that takes a message packet, decomposed into target a, and contents M , and a function ν : Nat → A. The function ν is to be used to generate fresh names for any actors created: ν(0), ν(1),... are guaranteed to be fresh names. The body e must evaluate to a new behavior lambda together with a configuration consisting of any created actors and messages to be sent. A conﬁguration, C ∈ Conf, is a multiset of actors and messages. An interfaced configuration, C ∈ Conf , is a configuration encapsulated by an interface. The operator ( ) is overloaded to map an interface and a configuration to an interfaced configuration.


Computations.
Computations, like interaction paths are formalized by introducing a class constant CP of computation paths that is constrained by axioms but not defined by comprehension. To define computations, individual transitions are

axiomatized as triples of the form iC =⇒
iC'. Then a computation path is

formalized as a sequence of transitions meeting certain semantic constraints.
We write CP(iC ) for the set of computation paths starting from the interfaced configuration iC .
To spare the reader more formalities we illustrate the formalization of the actor behaviors and operational semantics by some simple examples. that will be useful later on. The simplest actor behaviour is perhaps the sink. A sink simply accepts any message sent it, doing absolutely nothing in response.
We represent the behavior of the sink by the term Sink . Where
Sink = λ(a, M , ν)(Sink, ∅)
Thus after accepting a message, with contents M , the actor’s behavior remains unchanged, and no actors or messages are created in response.
Only slightly more challenging is the term describing the Ticker behavior.

Ticker (n) is a ticker actor behavior with local time n where
Ticker = λn.λ(a, M , ν)
if(M = tick)
then(Ticker (n + 1), a a tick)
else if(M = time @ c)
then (Ticker (n), c a reply(n))
else (Ticker (n), ∅)
In the cases of the Sink and the Ticker behaviors, no new actors are created, so the argument ν is not used in the body. To illustrate actor creation we define a TickerFactory behavior, that takes a message new(c), requesting creation of a new ticker, where the name of the new ticker is to be sent to actor c.
TickerFactory = λ(a, M , ν)
if(M = new(c))
then let{t := ν(0)}
(TickerFactory,t : Ticker (0),c a reply(t))
else (TickerFactory, ∅)
We can further elaborate on the Ticker example, by providing computation and interaction paths corresponding to the Ticker event diagram of Figure 1.
The following is a computation of an interfaced configuration consisting of a ticker actor (t : Ticker (0)) and a message ta tick. Input/output transitions add/remove messages from the internal configuration. A delivery transition d(mp) applies the behavior of the target actor to the message packet, and a name generating function, to obtain the new behavior of that actor and any additions to the configuration. The resulting expression is evaluated by sequential steps (not shown), interleaved with other transitions, thus a non-terminating behavior does not bring the whole system to a halt.
(t, ∅)(t : Ticker (0), t a tick)
in(tatime@c)
=⇒	(t, c)(t : Ticker (0), t a tick, t a time @ c)
d(tatick)
=⇒	(t, c)(t : Ticker (1), t a tick, t a time @ c)
d(tatime@c)
=⇒	(t, c)(t : Ticker (1), t a tick, c a reply(1))
d(tatick)
=⇒	(t, c)(t : Ticker (2), t a tick, c a reply(1))
in(tatime@c)
=⇒	(t, c)(t : Ticker (2), t a tick, t a time @ c, c a reply(1))

out(careply(1))
=⇒	(t, c)(t : Ticker (2), t a tick, t a time @ c)
... 


The corresponding interaction path is
(t, ∅)((0, in(ta time @ c)), (4, out(ca reply(1))),,.. .)
where an interaction sequence, ϑ is represented as sets of time stamped interactions (n, io) such that ϑ(n) = io, omitting silent interactions (io = τ ).
Speciﬁcation
We now have enough of the formalization to illustrate mathematical specifica- tions and discuss the structure of models of the theory. We first make precise our notion of satisfaction. As discussed above, an actor system specification is a predicate on interaction paths. An actor system satisfies a specification just if the predicate holds for each of its interaction paths.

Definition of Satisfaction.
For Φ a predicate on IP and iC ∈ IConf


iC |=Φ ⇔ (∀p ∈ CP(iC ))Φ(cp2ip(p))
⇔ cp2ip(CP(iC )) ⊆ {ip ∈ IP

Φ(ip)}

To illustrate how properties might be formalized in this theory we develop notation for expressing properties using event diagram notions, and show how this can be used to specify Ticker interactions.

Event Diagram Notation.
As above, we represent events as time stamped interactions (n, io). The input events (InE (ip)) and output events (OutE (ip)) of an interaction path ip = (ρ, χ)ϑ, are then defined by
InE (ip)= {(n, in(mp))	n ∈ Nat ∧ mp ∈ MP ∧ ϑ(n)= in(mp)}
OutE (ip)= {(n, out(mp))	n ∈ Nat ∧ mp ∈ MP ∧ ϑ(n)= out(mp)}
An event diagram is given by two ordering relations: the arrival order— that determines for each actor, the order in which messages are received; and

the activation order— the causal relation between message sending (as a result of a receive) and receipt by the target. For input events D (for delivered) and
ao
actor name a an arrival order, −→  ∈ Arro(D, a), is a total order on the
events in D with target a. The arrival order is a postulated order in which the messages are delivered to a during the computation, and may be different from the order in which they are input to the system. An activation order for D and output events O, <ao∈ Acto(D), is a binary relation between events in D and events in O. This models the causal relation between sending and delivery as a relation between the input of the delivered message resulting in the send and the output of message which must happen before it can be delivered. A theorem of Clinger [6] states that for any event diagram there is at least one total ordering of the events compatible with the combined partial order (the transitive closure of the arrival and activation orders). We call this a global time. The formula

GT(ip, −a→o
, <ao)

expresses the property that an interaction path ip (specifically, its interaction
ao
sequence) is a global time for the event diagram with arrival order −→ and
activation order <ao.
We now use these ordering and global time notations to formalize the properties of the ticker discussed in Section 2.1.


TickerMS (a)(ip) ⇔
ip ∈ IP(a, ∅) ∧
letting D = {e ∈ InE (ip)
ao


msg(e) ∈ time @ Cust (ip)}

(∃ −→ ∈ Arro(D, a) ∧ <ao∈ Bij(D)(OutE (ip)))
s.t.
GT(ip, −→, <ao) ∧
(∀e ∈ D, o ∈ OutE (ip))(e <ao o ⇒
(∃n ∈ Nat)(mp(o)= msgCust (e) a reply(n)) ∧
(∀e' ∈ D, o' ∈ OutE (ip))(e' <	o' ∧ e −a→o e'
⇒ msgArgs(o) ≤ msgArgs(o'))) ∧
|D| = ω ⇒ (∀n ∈ Nat)(∃o ∈ OutE (ip))msgArgs(o) ≥ n
Line 1 says that the interaction path has the right interface. Line 2 defines the set of input events D. The function msg extracts the message content of an event: msg((n, in(a a M ))) = M , and the function Cust (ip) is the set of names actors that are not receptionists at any stage of ip. In the case of

the Ticker, this will be any name other than a. Line 3 postulates the arrival and activation orderings of an underlying event diagram, requiring that <ao be a bijection between D and OutE (ip). The restriction of D to requests from external customers, Cust (ip), is necessary, because replies to requests with customer a will not appear as output, since they are not addressed to an external actor, and thus violate the bijection requirement. Line 4 requires that ip be a global time for the postulated event diagram. Line 5 expresses the requirement that the reply contain a number and be addressed to the request customer, and line 6 says that the sequence of numbers in replies to time requests is non-decreasing. (The function msgCust extracts the customer, the name following @: msgCust ((n, in(a a M @ c))) = c, and msgArgs extracts the value from a reply message: msgArgs((n, out(ca reply(n)))) = n.) Line 7 says that if there are infinitely many requests then there will be a reply with time bigger than any given number.


Claim:
(t, ∅)Ticker (0) |= TickerMS (t)


Proof Sketch:
We must show that if ip ∈ [[(t, ∅)Ticker (0)]] then TickerMS (t)(ip). (Recall that [_ ] is the denotation function mapping a configuration to its set of inter- action paths.) By (the omitted) definition, ip is the interaction path derived from some Ticker computation π, a sequence of delivery, input, and output transitions where the result of a delivery transition is given by the Ticker behavior lambda. Thus we may take D to be the time request inputs, with

customer other than t,
−a→o
to be the order of their delivery in π, and <ao to

be such that (n, in(ta time @ c)) <ao (n', out(mp)) where mp is generated by the transition delivering the input message. Clearly GT(ip, −→ , <ao) and by definition of Ticker behavior and fairness, <ao is a bijection. Furthermore, if
e −a→o  e', then the counter held by the ticker at e' is at least as large as that at
e (transitions do not decrement the counter). There is always a tick message
present, and no matter how many requests arrive, fairness insures that each tick eventually gets delivered. Thus with an unbounded number of requests, there will always eventually be a reply bigger than any given number.
One of the motivations for defining the Ticker actor originally was as a simple example of unbounded non-determinism. Not only is the environment unpredictable, but also the system can have an unbounded number of possible behaviors. The unbounded non-determinism of a Ticker can be formalized as

follows.
(∀n, k ∈ Nat)(∃(t, ∅)ϑ ∈ IP, j, n' ∈ Nat)
j ≤ k ∧ n ≤ n' ∧ TickerMSpec(t)((t, ∅)ϑ) ∧ msg(ϑ(j)) = reply(n')
This says that no matter how few requests there are, or how big n is, it is always possible that the reply to a request is larger than n. It is fairly easy to this see that property is a consequence of TickerMSpec.

Models of the Formal Theory
Without further axioms, some models of our formal theory will correspond to small models, where computation/interaction paths are lambda definable se- quences as for the theories of sequential computation. The intended models of interest (large models) include paths with input/output interaction sequences that are not defined by computable functions. The question is, how does this affect the adequacy of our formal theory. For example we might ask
Is there an actor system iC and property Φ such that in small models
iC |= Φ and in some large model iC |= Φ or conversely?
To answer this question (positively) we describe a configuration (∅, {o})C with one external observer actor o such that in every small (i.e. recursively enumer- able) model, the property Φ is satisfied, where Φ says that every interaction path for (∅, {o})C contains at least one out(oa OK ) interaction event. But, in some larger models Φ is not satisfied, because they include interaction paths that contain no such events.
From classic recursion theory: a set of natural numbers A is said to be simple if A is recursively enumerable, the complement of A is infinite, and no infinite subset of the complement of A is recursively enumerable. Emil Post constructed the first simple set [20] in order to show that not all non-recursive, recursively enumerable sets, were creative. Choose A simple. By definition, let f be a partial recursive function such that
f (y)=1 if y ∈ A
f (y) is undefined otherwise.
The configuration, C , will consist of, initially, two actors. A ticker, t, and a spawner, s, a tick message to t, and a time message from s addressed to t, ta time @ s.

(∅, {o})(t : Ticker (0), t a tick, t a time @ s, s : Spawner (f, t, o))

Spawner (f, t, o) does the following ad infinitum: It sends a time message to t, then waits for the reply. Upon receipt of a reply(n) from t, it spawns off a new Compute(f, n, o) actor, and sends that actor a param(n) message.
Spawner = λ(f, t, o).λ(a, M , ν)
if(M = reply(n)@ t)
then let{c := ν(0)}
(Spawner (f, t, o),
c : Compute(f, o), ca param(n),
ta time @ s)
else (Spawner (f, t, o), ∅)
Compute(f, o) does the following: Upon receipt of a param(n) message it computes f (n) sequentially, if that terminates, it sends o the OK message, and becomes a sink. Any other message is simply discarded.
Compute = λ(f, o).λ(a, M , ν)
if(M = param(n)) then let{b := f (n)}
(Sink,o a OK )
else (Compute(f, o), ∅)
A computation path starting from our configuration in state
(∅, {o})(t : Ticker (n), t a tick, t a time @ s, s : Spawner (f, t, o)) will be an infinite number of segments, all of the form
(∅, {o})(t : Ticker (n), t a tick, t a time @ s, s : Spawner (f, t, o))
d(tatick)m
=⇒
(∅, {o})(t : Ticker (n + m), t a tick, t a time @ s, s : Spawner (f, t, o))

d(tatime@c)
=⇒
d(tatick)m1
=⇒

(∅, {o})(t : Ticker (n + m + m1), t a tick,
s : Spawner (f, t, o), s a reply(n + m)@ t)

d(sareply(n+m)@t)
=⇒
d(tatick)m2
=⇒

(∅, {o})(t : Ticker (n + m + m1 + m2), t a tick, t a time @ s, s : Spawner (f, t, o),
c : Compute(f, o), c a param(n + m))

d(caparam(n+m))
=⇒
d(tatick)m3
=⇒

(∅, {o})(t : Ticker (n + m + m1 + m2 + m3), t a tick, t a time @ s, s : Spawner (f, t, o),
c : Compute(f, o)(c, param(n + m), ν))


for various values of n, m, m1, m2, and m3. Where the notation
d(tatick)m
=⇒	is

an abbreviation for the delivery of m tick messages to the ticker actor t:


d(tatick)m
d(tatick)
d(tatick)
d(tatick)

=⇒	abbreviates
 =⇒	=⇒  .. .	=⇒ 
˛¸	x
m times

Note that we are using fairness in assuming that the system does not ignore pending messages. Each message sent to an actor is eventually processed. Without such an assumption we would be forced to consider paths where the only events that ever took place are, for example, the ticker processing it’s tick message, and no replies to the spawner’s time messages are ever sent.
Thus from an observational view point an infinite computation will boil down to computing
ci : Compute(f, o)(ci, param(ni), ν))

or more explicitly:
ci : let{b := f (ni)}(Sink,o a OK )
for an increasing sequence {ni}i∈Nat. Now in a small model, this sequence will be a recursively enumerable set of increasing integers (hence actually recursive). Hence it cannot be a subset of the complement of A. Thus it must intersect A, so for some ticker response, ni, ni will be in A, and hence f (ni)
will terminate, and an out(oa OK ) event will be generated.
On the other hand, in a large model, take a ticker path {ni}i∈Nat that enumerates an infinite subset of the complement of A (e.g. the complement of A itself will do). In such a path no OK message will ever get sent. Thus small models satisfy Φ while large models do not.

Conclusions and Future Directions
We have described work in progress to formalize the interaction semantics model of actor computation in a logical theory. This work has two objectives: to study the logical and recursion theoretic properties of interactive compu- tation; and to develop principles and techniques for specifying and reasoning about interactive systems.
We have analyzed a particular formalism for interactive computation based on the actor model. There are many other models / formal systems for which a similar analysis could be carried out: Communicating Sequential Processes [14,21], Pi calculus [19], IO Automata [17], Game semantics [1].
Our example system distinguishing small and large models relied on fair- ness. It would be interesting to determine if fairness is essential to make the distinction or if an example can be found that doesn’t require fairness. Work in the theory of computable functions has show the equivalence of many for- mal systems for computation (Turing machines, Lambda calculus, and so on) in the sense that they all define the same set of computable functions on the natural numbers, namely the partial recursive functions. An interesting topic for future work is to determine whether different formalisms for interactive computation are equivalent, for example in the sense of definable sets of inter- action paths. Another possible direction is to use alternative logics to carry out formal analyses, for example temporal logics.
There are several additional directions for future work. One is formalizing the component algebra operations to help modularize specification and rea- soning, and looking for a set of reasoning principles, including for example principles for reasoning about coordination abstractions. Another is working out a more detailed proof-theoretic analysis of interactive computation mod- els. Finally, we intend to explore variants of the actor model that incorporate notions of time and uncertainty.

References
S. Abramsky. Sequentiality vs. concurrency in games and logic. Mathematical Structures in Computer Science, 13:531–565, 2003.
G. Agha. Actors: A Model of Concurrent Computation in Distributed Systems. MIT Press, Cambridge, MA, 1986.
G. Agha. Concurrent object-oriented programming. Communications of the ACM, 33(9):125– 141, September 1990.
G. Agha, I. A. Mason, S. F. Smith, and C. L. Talcott. A foundation for actor computation.
Journal of Functional Programming, 7:1–72, 1997.
Henry G. Baker and Carl Hewitt. Laws for communicating parallel processes. In IFIP Congress, pages 987–992. IFIP, August 1977.


W. D. Clinger. Foundations of actor semantics. AI-TR- 633, MIT Artificial Intelligence Laboratory, May 1981.
R. de Nicola and M. C. B. Hennessy. Testing equivalences for processes. Theoretical Computer Science, 34:83–133, 1984.
S. Feferman. A language and axioms for explicit mathematics. In Algebra and Logic, volume 450 of Springer Lecture Notes in Mathematics, pages 87–139. Springer Verlag, 1975.
S. Feferman. Constructive theories of functions and classes. In Logic Colloquium ’78, pages 159–224. North-Holland, 1979.
S. Feferman. Polymorphic typed lambda-calculi in a type-free axiomatic framework. In Logic and Computation, volume 106 of Contemporary Mathematics, pages 101–136. A.M.S., Providence R. I., 1990.
I. Greif. Semantics of communicating parallel processes. Technical Report 154, MIT, Project MAC, 1975.
C. Hewitt. Viewing control structures as patterns of passing messages. Journal of Artiﬁcial Intelligence, 8(3):323–364, 1977.
C. Hewitt, P. Bishop, and R. Steiger. A universal modular actor formalism for artificial intelligence. In Proceedings of 1973 International Joint Conference on Artiﬁcial Intelligence, pages 235–245, August 1973.
C. A. R. Hoare. Communicating Sequential Processes. Prentice-Hall, 1985.
F. Honsell, I. A. Mason, S. F. Smith, and C. L. Talcott. A variable typed logic of effects.
Information and Computation, 119(1):55–90, 1995.
P. J. Landin. The next 700 programming languages. Comm. ACM, 9:157–166, 1966.
N. A. Lynch and M. R. Tuttle. An introduction to input/output automata. Technical Report MIT/LCS/TM-373, MIT Laboratory for Computer Science, 1988.
I. A. Mason and C. L. Talcott. Feferman–Landin Logic. In W. Sieg, R. Sommer, and C.L. Talcott, editors, Reflections on the Foundations of Mathematics: Essays in honor of Solomon Feferman, Lecture Notes in Logic, pages 299–344. Association of Symbolic Logic, 2002.
R. Milner. Communication and Concurrency. Prentice Hall, 1989.
Emil L. Post. Recursively enumerable sets of positive integers and their decision problems.
Bulletin of the American Mathematical Society, 50:284–316, 1944.
W. Roscoe. Theory and Practice of Concurrency. Prentice Hall, 1998.
S. F. Smith and C. L. Talcott.  Modular reasoning for actor specification diagrams.  In
P. Ciancariani, A. Fantechi, and R. Gorrieri, editors, Formal Methods for Open Object-based Distributed Systems, pages 313–330. Kluwer, 1999.
S. F. Smith and C. L. Talcott. Specification diagrams for actor systems. Higer-Order and Symbolic Computation, 15(4):301–348, 2002.
C. L. Talcott. A theory for program and data specification. Theoretical Computer Science, 104:129–159, 1993.
C. L. Talcott. Interaction semantics for components of distributed systems. In E. Najm and J-B. Stefani, editors, 1st IFIP Workshop on Formal Methods for Open Object-based Distributed Systems, FMOODS’96, 1996. proceedings published in 1997 by Chapman & Hall.
C. L. Talcott. Reasoning about functions with effects. In Higher Order Operational Techniques in Semantics. Cambridge University Press, 1996.
C. L. Talcott. Composable semantic models for actor theories. Higher-Order and Symbolic Computation, 11(3):281–343, 1998.

C. L. Talcott. Actor theories in rewriting logic. Theoretical Computer Science, 285(2), 2002.
Prasanna Thati, Carolyn Talcott, and Gul Agha. Techniques for executing and reasoning about specification diagrams. In 10th International Conference on Algebraic Methodology and Software Technology AMAST2004, 2004.
