

Electronic Notes in Theoretical Computer Science 234 (2009) 19–36
www.elsevier.com/locate/entcs

Action Control by Term Rewriting 
Steve Barkera	Clara Bertolissia,b	Maribel Ferna´ndez a,1
a Dept. Computer Science, King’s College London, Strand, WC2R 2LS, U.K
b LIF and Universit´e de Provence, Marseille, France

Abstract
We address the problem of defining access control policies that may be used in the evaluation of requests made by client actors, in the course of e-trading, to perform actions on the resources maintained by an e- collective. An e-collective is a group of agents that may act individually or in conjunction with other agents to satisfy a client’s request to act. Our principal contribution to this key problem is to define formally an access control model in terms of which policies may be specified for helping to ensure that only legitimate forms of client actions are performed in the course of engaging in e-trading. We call this model the action control model. In action control, the notion of intentional, empowered, authorized actions, that may be performed individually or jointly with other agents and in a manner that is consistent with a group ethos, is the basis for specifying a set of permissives. A permissive is a generalization of the notion of permission (as the latter term is usually interpreted in access control). We define our action control model as a term rewrite system and we give examples of access policy representation.
Keywords: Access Control, Security, Term Rewriting.


Introduction
For many applications, existing access control models are sufficient for the limited forms of actions that are required on simple object types (e.g., read and write actions on files), which apply in the context of the restricted forms of organizations and systems that are often assumed (cf. the Bell-LaPadula model [6]). Nevertheless, there are organizational structures, emerging applications, new types of computer systems, as well as complex forms of actions, that require that existing access control models be extended and that novel access control models be developed to address access control policy requirements adequately.
In this paper, we address the issue of formally defining an access control model for use for secure e-trading where (pre-authenticated) client agents make requests for an action to be performed by a type of virtual organization that we call an

٨ Research partially funded by the EU project Implementing access control mechanisms using rewriting techniques, Marie Curie Intra European Fellowships Programme.
1 Email: {Steve.Barker,Clara.Bertolissi,Maribel.Fernandez}@kcl.ac.uk

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.02.070

e-collective. Informally, an e-collective is a collection of server agents that may act individually to satisfy a client’s request that some action be performed or a subset of the agents in the e-collective may act jointly in order to satisfy the client’s request. For example, given a client request to buy 1000 green widgets, members of the e-collective may offer to service the client’s request in full or different subsets of the server agents of the e-collective may offer to satisfy part of the client’s request. This paper addresses the problem of formally specifying which client actions can be performed by which server agents and in what ways.
For e-trading via e-collectives, a number of requirements exist. The client agents and server agents will generally be widely distributed, the e-trading environment will typically be highly dynamic (with trading conditions and policy requirements changing frequently), server agents will maintain individual policies that need to be combined to make collective decisions on access requests, and changes to policies will usually need to be performed autonomously. Traditional access control models often assume a single, monolithic policy specification, that is managed by human security administrators, that applies to a static, centralized organization with a well-defined set of users that request that simple forms of actions be performed on simple forms of objects. Such assumptions, and the access control models on which they are based, are inappropriate in the e-collective scenario.
For client request evaluation by e-collectives, server agent intentions and em- powerments need to be considered, as well as authorizations. Put (very) simply, an intention is a will to act; an empowerment is a capacity to act. In the case of e-collectives, not all server agents will necessarily have the intention of satisfying all client requests for all actions to be performed on every resource at all times and, clearly, it will not be the case that all server agents will necessarily have the same capability of satisfying a client’s request. More importantly, intentions, empower- ments and authorizations are fundamentally and mutually dependent on whether the server agents act individually or collectively to satisfy a client agent’s request. For instance, e-collective server agents might not be empowered to act individually to satisfy a client’s request but may be empowered to act jointly with other servers to satisfy the request, not every server agent will necessarily have the intention of acting individually or engaging jointly to satisfy every client’s request that some action be performed, and what a server agent authorizes may depend on whether it acts with other server agents or not. The importance of combining intentions, empowerments and authorizations for request evaluation for e-collectives has not hitherto been adequately considered in the literature on access control models. In addressing this shortcoming, we propose a new type of access control model, which we call the action control model.
For the formal definition of the action control model, we use term rewrit- ing [1,12,19]. Term rewriting has a number of specific attractions for representing access control policies, as described in [5,8,29]. In particular, standard rewriting techniques and modularity results for rewriting systems can be used to show that access control policies satisfy essential properties (such as consistency and total- ity), and programming languages and tools such as ELAN [10,18], MAUDE [11],

Haskell [16] and ML [26], can be used to test, compare and experiment with eval- uation strategies, to automate equational reasoning, and for the rapid prototyping of policies. As we will see, action control generalizes access control. The extra complexities involved in specifying action control polices demand that high-level, declarative languages be used for policy specification, languages like those based on term rewriting. Moreover, recursive rule definition is particularly important in client request evaluation. For action control for e-collectives, the distributed term rewriting systems that we use are especially well-suited.
For the actions of relevance in e-trading (e.g., acts of buying, supplying, ... ), we argue that action control requires that intentions and empowerments to act need to be considered as well as authorizations to act. The authorization of a requested action by the client agent becomes meaningful if and only if an intention to perform the action and an empowerment to so act exist for a server agent. Intentions and empowerments may be interpreted as preconditions for authorization. In the existing access control literature, a permission is a pair (a, r), where a is an action and r is a resource, and an authorization is a permission assigned to a client user. In contrast, in action control, a generalization of a permission is used, which we call a permissive. A permissive represents an optional, authorized, intentional, empowered action.
Permissives are, as we have said, fundamentally related to the mode in which a server agent acts, individually or collectively. When a server agent of an e-collective acts individually to satisfy a client’s request then we say that the server agent acts in I-mode; when an server agent must collaborate with other server agents in the e-collective to satisfy a client’s request (with each server agent contributing to the satisfaction of the request) then we say that the server agent acts in C-mode. 2 The distinction between I-mode and C-mode motivates the need for a shared meta- policy that determines how server agents may act individually or collectively to service client agent requests and to what extent. For that, the notion of a group ethos is used in action control. In the C-mode case, a request by a client agent for an action to be performed may be satisfied by the server agents of the e-collective subdividing the request and satisfying part of the original request. In order for a permissive to hold in I-mode or C-mode the permissive must be consistent with the group ethos.
Despite being thus far relatively neglected, it is important for researchers to consider the range of access control issues that relate to e-collectives used for e- trading. For a number of reasons, if adequate access controls can be provided, e- collectives will become routinely used in, for example, grid computing, as a form of virtual organization, and in the context of Internet and Semantic Web technologies. As an e-collective, a group of server agents may be able to pool their resources to compete for a contract that none of them could individually satisfy, they may choose to subcontract a client’s request for business reasons, and collections of server agents may decide to collaborate in order to combine their individual strengths and specializations.

2 Our use of I-mode and C-mode actions is based on Tuomela’s theory of cooperation [32].

The remainder of the paper is organized in the following way. Section 2 describes some formal preliminaries. In Section 3, we define our action control model as a term rewriting system and we give examples of policy usage and secure request evaluation. Section 4 discusses how some properties of action control policies, such as consistency, can be obtained using term rewriting techniques. In Section 5, we discuss the related literature more fully. In Section 6, conclusions are drawn and further work is suggested.

Preliminaries
In this section, we recall some basic notions and notations for term rewriting that we will use in the rest of the paper. We refer the reader to [1] for additional information. A signature F is a finite set of function symbols together with their (fixed) arity.
X denotes a denumerable set of variables X1, X2,.. ., and T (F, X ) denotes the set of terms built up from F and X . Terms are identified with finite labeled trees. The symbol at the root of t is denoted by root(t). Positions are strings of positive integers. The subterm of t at position p is denoted by t|p and the result of replacing t|p with u at position p in t is denoted by t[u]p.
V(t) denotes the set of variables occurring in t. A term is linear if variables in V(t) occur at most once in t. A term is ground if V(t) = ∅. Substitutions are written as in {X1 '→ t1,... , Xn '→ tn} where ti is assumed to be different from the variable Xi. We use Greek letters for substitutions and postfix notation for their application. We say that two terms unify if there is some substitution that makes them equal. Such a substitution is called a uniﬁer. The most general uniﬁer (mgu) is the unifier that will yield instances in the most general form.
Given a signature F, a term rewriting system on F is a set of rewrite rules R = {li → ri}i∈I , where li, ri ∈ T (F, X ), li /∈ X , and V(ri) ⊆ V(li). A term t rewrites to a term u at position p with the rule l → r and the substitution σ, written t →l→r u, or simply t →R u, if t|p = lσ and u = t[rσ]p. Such a term t is called reducible. Irreducible terms are said to be in normal form.
We denote by →+ (resp. →∗ ) the transitive (resp. transitive and reflexive) clo-
R	R
sure of the rewrite relation →R. The subindex R will be omitted when it is clear
from the context.
Example 2.1 Consider a signature for lists of natural numbers, with function sym- bols:
z (with arity 0) and s (with arity 1, denoting the successor function) to build numbers;
nil (with arity 0, to denote an empty list), cons (with arity 2, to construct non- empty lists), and length (with arity 1, to compute the length of a list).
The list containing the numbers 0 and 1 is written: cons(z, cons(s(z), nil)), or simply [z, s(z)] for short. We can specify the function length with rewrite rules as follows:
length(nil) → z	length(cons(X, L)) → s(length(L))

Then we have a reduction sequence:
length(cons(z, cons(s(z), nil))) → s(length(cons(s(z), nil)) → s(s(length(nil))) → s(s(z))
Example 2.2 Boolean operators, such as disjunction and conjunction, can be spec- ified using a signature that includes two constants, true and false.
or(true,X) → true	and(true,X) → X
or(false,X) → X	and(false,X) → false
In the sequel we use the notation t1 and ... and tn as syntactic sugar for the term
and(... and(and(t1, t2), t3) .. .), and similarly for the or operator.
Let l → r and s → t be two rewrite rules (we assume that the variables of s → t were renamed so that there is no common variable with l → r), p the position of a non-variable subterm of s, and μ a most general unifier of s|p and l. Then (tμ, sμ[rμ]p) is a critical pair formed from those rules. Note that s → t may be a renamed version of l → r. In this case a superposition at the root position is not considered a critical pair. A term rewriting system R is:
confluent if for all terms t, u, v: t →∗ u and t →∗ v implies u →∗ s and v →∗ s, for some s;
terminating (or strongly normalizing) if all reduction sequences are finite;
left-linear if all left-hand sides of rules in R are linear;
non-overlapping if there are no critical pairs;
orthogonal if R is left-linear and non-overlapping;
For example, the rewrite system in Example 2.1 is left-linear and non-overlapping (therefore orthogonal), confluent and terminating.
Action control policies are applicable in distributed computing contexts. For that, we will use distributed term rewriting systems (DTRSs); DTRSs are term rewriting systems where rules are partitioned into modules, each associated with a site, and function symbols are annotated with site identifiers. DTRSs were intro- duced in [8] to specify access control policies in a dynamic, distributed environment. We assume that each site has a unique identifier (we use Greek letters μ, ν,... 
to denote site identifiers). We say that a rule f (t1,... , tn) → r defines f . There may be several rules defining f ; we write fν to refer to the definition of the function symbol f stored in the site ν. If a symbol is used in a rule without a site annotation then we assume the function is defined locally. For example, in a DTRS used in a bank scenario, we may have a local function account such that account(u) returns u’s bank account number, and rules computing the average balance of a user’s account, stored in a site ν. Then we could define the category of a user u by using a rule of the form
category(U ) → if averagebalanceν(account(U )) ≥ 10000
then VIP else NORMALCLIENT

We use the notation if b then s else t as syntactic sugar for the term if-then-else(b, s, t), with the rewrite rules:
if-then-else(true, X,Y ) → X	if-then-else(false, X,Y ) → Y

In this paper, we assume that the site where each function is defined is known and therefore the annotations used in function symbols are just constants. More general versions (where, for instance, variables can be used as annotations when sites are not known in advance), may also be used.

The Action Control Model by Term Rewriting
In this section, we formally define the action control model. We consider some basic syntactic issues, we then give and justify the inclusion of the core set of rewrite rules that define the action control model, we give examples of policy specification, in terms of the model, and we consider client request evaluation.
On syntax, we first note the key sets of constants in the signature that we use in the formulation of the action control model and policies. Specifically, we require:
A countable set C of client identifiers, c0, c1, ... 
A countable set M of identifiers, m0, m1,... of server agents that are members of an e-collective.
A countable set A of named actions (represented by strings that denote actions in a world of interest e.g., buy, sell, supply, hire, ... ).
A countable set R of resource identiﬁers, r, r1, ... 
A countable set T of time points, t, t1, ... 
Here, we have that C ∩ M = ∅ holds for a particular instance of an e-collective. We include times with our specifications of action control policies because intentions, empowerments, and authorizations will inevitably change, and often in a highly dynamic manner. We adopt a one-dimensional, linear, discrete view of time, with a beginning and no end point, i.e., a total ordering of time points that is isomorphic to the natural numbers. In the ensuing discussion, we represent times as encoded natural numbers in YY YY MMDD format. We assume the existence of a function that extracts the current time from the system clock.
Recall that we are proposing an interpretation of access control in which in- tentions, empowerments and authorizations are necessary in order for a permissive to hold. It follows that an action control theory is a 4-tuple consisting of a set of permissives and three subtheories, in terms of which the set of permissives is defined,
(PER, INT , EMP, AUT H).
Here, PER is the set of rules that is used to define the set of permissives, INT is a theory of intentions that individual agents within the e-collective have to act (in I-mode and C-mode), EMP is a theory that specifies whether an agent in the e- collective is empowered to act according to the group ethos (in I-mode or C-mode),

and AUT H is a theory that defines the actions that members of the e-collective authorize client agents to perform on resources (in I-mode or C-mode) that are maintained by the e-collective.
The examples of action control policy formulation that we will give, later in this section, relate to a simple e-commerce application. Specifically, we assume an e-collective with four members that are identified by m1, m2, m3 and m4. We make the simplifying assumptions that the only resource of interest to client agents is a set of parts and the only action of interest is an act of buying. Each member of an e-collective that has an intention of satisfying a client’s request to buy some part will maintain its own information about the set of parts at its local site. We assume each part is identified by a name (widget, bauble, etc) and that client requests are to buy a quantity of a specified part. The binary constructor part is used to specify a part p and its quantity q.
Given an action control policy specification, a client c0 may make a request of the form:
permissive(c0, buy, part(widget, 1300), m1 ).
That is, c0’s request is to know whether it is permitted to buy 1300 units worth of the widget part from the agent m1. On receiving c0’s request, the agent m1 will evaluate the request with respect to its own declarations of permissives and may request other e-collective members to cooperate with it to jointly satisfy c0’s request.
Our examples will also involve considering application-specific information about the stock levels of various parts held by the e-collective agents m1, m2, m3 and m4 and stored in sites identified by υ1, υ2, υ3 and υ4, respectively, viz:
 stockυ1 (widget) → 200, stockυ1 (bauble) → 300,... 

 stockυ2 (widget) → 100, stockυ2 (bauble) → 300,... 
 stockυ3 (widget) → 800, stockυ3 (bauble) → 100,... stockυ4 (widget) → 150, stockυ4 (bauble) → 200,... 
Here, stockυi (r) → q iff the e-collective member mi (1 ≤ i ≤ 4) has the quantity
q of the item of type r available in stock. 3
PER Theory
The PER sub-theory consists of the following rules, which define permissives for each member m of the e-collective using a 4-ary function permissive. To specify the function permissive we use the functions i permissiveν and c permissiveμ, where ν, μ are the sites that store the action control policy for m, expressed in individual and collective mode, respectively.  We define i permissiveν, c permissiveμ and

3 We assume that the stock information used by different e-collective members is of the same format, but this need not, of course, be the case.

permissive for each agent in the e-collective. These core rules are defined in the following way:

permissive(C, A, R, m) → i permissiveν(C, A, R) or c permissiveμ(C, A, R) i permissiveν(C, A, R) → F (i empoweredν(C, A, R),i intentν(C, A, R),
i authorizedν(C, A, R))
c permissiveμ(C, A, R) → G(c empoweredμ(C, A, R),c intentμ(C, A, R),
c authorizedμ(C, A, R))
According to the rules above, when a client c requests a member m of the e-collective to perform the action a on resource r, the agent m has the option to act in I-mode or C-mode to satisfy the request. In the rules above, i permissiveν, i intentν and i authorizedν are functions returning boolean values. The functions F and G are parameters of the specification. They may simply be a conjunction operator, or we may have additional conditions that need to be verified in order to define i permissiveν and c permissiveμ. If we assume that F and G are simply computing a conjunction, then the rule defining i permissive specifies that client c’s request to perform the a action on resource r is satisfied by the e-collective agent m acting in I-mode if m has the intention of performing the action a on the resource r, in I- mode, m is empowered, in I-mode, to perform the action a on r, and m authorizes the client c to perform the action a in I-mode. Thus, we might have, for example, the following reduction:

i permissiveν(c, a, r) → and(i empoweredν (c, a, r),i intentν(c, a, r),
i authorizedν(c, a, r))
→ and(true, true, true) → true

Similarly, the c permissive rule specifies that client c’s request to perform the a action on resource r is satisfied by the e-collective agent m acting in C-mode if m has the intention of performing the action a on the resource r, in C-mode, m is empowered, in C-mode, to perform the action a on r, and m authorizes c, in C- mode, c’s requested action. We consider the representation of theories of intentions, empowerments and authorizations next.

INT Theory
Each server agent of the e-collective will maintain its own intention theory INT . INT is a set of rules that define agent m’s intentions in terms of an action a that m is willing to engage in on resource r, in I-mode, on client c’s behalf (the i intent rules), and m’s intentions in terms of an action a that m is willing to engage in on

resource r, in C-mode, on c’s behalf (the c intent rules):
i intent(C, A, R) → C1 and ... and Cn c intent(C, A, R) → C1 and ... and Ck

The rules above (where site annotations have been omitted) specify that the e- collective agent m has an intention to perform an action a on resource r in I-mode (C-mode) on behalf of client c if the conditions, C1σ,... , Cnσ (C1σ,... , Ckσ) hold, where σ = {C '→ c, A '→ a, R '→ r}. The example that follows next illustrates what is involved in specifying server agent intentions as a term rewriting systems.
Example 3.1 Consider the following set of intention theories INTm1 , INTm2 ,
INTm3 , and INTm4 , for the e-collective members m1, m2, m3 and m4:


INTm1
:=	i intentν((C, buy, part(X, Z)) → true
c intentμ((C, buy, part(X, Z)) → Z > 1000



INTm2
:=	i intentα(C, buy, part(widget, Z)) → Z ≤ 1000
c intentτ (C, buy, part(bauble, Z)) → Z ≥ 50



INT
INTm3 :=  i intentπ(C, A, R) → preferred(C)
:= i intentγ(C, A, R) → current time ≥ 20080601

c intentδ(C, A, R) → current time ≥ 20081001
Here, INTm1 is a specification of the intentions that the e-collective member m1 has of satisfying any client’s request to perform an act of buying in I-mode or in C-mode provided that the total size of the order (in the latter case) is greater than 1000 units. INTm2 expresses m2’s intention to act individually to satisfy a request from any client to buy if the request is for less than 1000 widgets; m2 is also willing to act in C-mode to satisfy requests for sales of more than 50 units worth of baubles. INTm3 expresses that m3 is willing to satisfy any action on any resource without restriction, but only in I-mode and only for the clients that it identifies as preferred. Finally, INTm4 specifies that m4 is willing to satisfy any action requested by any client on any resource in I-mode as soon as m4 starts trading on 1st June 2008 and will act in C-mode four months after starting to trade.
EMP Theory
In addition to its intentions, each server member of the e-collective will maintain its own EMP theory, a specification of its empowerments. An EMP theory, is a set of rules of the form:
i empowered(C, A, R) → C1 and ... and Cn c empowered(C, A, R) → C1 and ... and Ck


Each i empowered (c empowered) rule specifies that an agent m is empowered to perform the a action on resource r for client c in f-mode (C-mode) if the conjunction of conditions C1,... , Cn (C1,... , Ck) hold. In the case of C-mode evaluation, at least one Ci (1 ≤ i ≤ k) should be expressed in terms of c permissive. The reason for this should be noted: in the case of C-mode evaluation, the evaluation of c empowered(C, A, R) involves a member m of the e-collective requesting the collaboration of other agents in the e-collective in satisfying the request that an a action be performed in relation to resource r on behalf of the client c. Hence, a c permissive condition in a c empowered rule is a recursive call that will trigger the evaluation of a request by a set of members of the e-collective, that will collaborate with m to satisfy the request by c to perform the action a on r. For example, we might have a reduction:
c empoweredμ(c, a, r) → c1(a) and c permissiveτ (c, a, r) → true and true → true
Hence, when m acts in C-mode according to the policy specified in site μ, then m acts jointly with other e-collective members if and only if there is some e-collective agent m' /= m (whose action control policy is stored in site τ ) that has an intention and is empowered and authorized to act with m to satisfy a client’s request.
To treat adequately the concept of empowerment in action control for e- collectives, the notion of a group ethos is required. The group ethos determines what powers member agents can exercise in the context of the e-collective. To aid the reader’s understanding of this key issue, we describe a simple form of group ethos such that an e-collective member m acts to satisfy a request from a client c in full by m operating alone whenever that is consistent with m’s specifications of intentions, empowerments and authorizations. If m has an intention to act but is not empowered to act then m will request other agents of the e-collective to help in satisfying c’s request. Hence, each member of the e-collective will act in f-mode if possible and in C-mode otherwise. Despite its simplicity, this group ethos is consistent with the concept of prospective rationality that is defined within the framework of Rational Choice [22]. Henceforth, we will call the shared ethos such that e-collective members act to their maximum intended, empowered and autho- rized extent to satisfy a client’s request in f-mode, whenever that is possible, the Principle of Maximal Individualistic Satisfaction, to wit:
If an e-collective member m intends and can fully satisfy a request of a client c for an action to be performed that m authorizes for c then m will act in an f-mode capacity (i.e., privately, selﬁshly) subject to any constraints on f-mode action (conversely, m has the minimal commitment to act collectively). Otherwise, m determines the maximal extent to which it can satisfy the request by c, and will request help from other members of the e-collective on how to satisfy the remainder of c’s request. In this case, the C-mode case, m invites members of the e-collective to engage in joint activity to satisfy c’s request.
Acting as a member agent entails respecting the Principle of Maximal Individ-

ualistic Satisfaction, the shared group ethos. Other forms of group ethos are, of course, possible (e.g., to allow for group competitiveness, altruism, etc); these alter- natives are the basis for different e-collective meta-policies that can, nevertheless, be naturally represented in our framework.
The next example illustrates how empowerment theories may be represented as a TRS.
Example 3.2 Consider the following empowerment theories EMPm1 , EMPm2 , EMPm3 , and EMPm4 , for the e-collective members m1, m2, m3 and m4, respec- tively. The empowerment theories assume that the Principle of Maximal Satisfac- tion is to be implemented.
⎧⎪⎨i empoweredν (C, buy, part(X, Z)) → stockυ1 (X) ≥ Z

⎪⎩	c permissiveτ (C, buy, part(X, Z − stockυ1 (X)))
⎧⎪i empoweredα(C, buy, part(X, Z)) →

c empowered (C, buy, part(X, Z)) → Z ≥ 500 and
c permissiveδ(C, buy, part(X, Z − stockυ2 (X)))
EMPm3 :=  i empoweredπ(c0, buy, part(X, Z)) → stockυ3 (X) ≥ Z



EMPm4 :=
c empoweredδ(C, buy, part(X, Z)) → stockυ4 (X) < Z and
⎪⎩	c permissiveμ(C, buy, part(X, Z − stockυ4 (X)))

Here, the agent m1 will act in f-mode for any client c if m1 is empowered to so act by having enough stock, as recorded in υ1, to satisfy c’s request to perform an act of buying. Alternatively, if m1 cannot satisfy the request itself then m1 will attempt to act in C-mode, with another member of the e-collective, to service c’s request. That is, m1 will adhere to the Principle of Maximal Individualistic Satisfaction and satisfy whatever it can of c’s request and then ask for assistance with the remainder. In contrast, m2 is only empowered to act in f-mode if it has enough stock as recorded in υ2, subject to certain temporal constraints being satisfied, and for orders of less than 500 units. In the case where a request is to buy more than 500 units, m2 will act in C-mode but by requesting help from δ, to which m2 subcontracts “large” orders. Furthermore, while m2 is willing to supply any client, m3 is only empowered to supply c0 and in f-mode. Similarly to m1, m4 is only empowered to act in f-mode if it has enough stock, otherwise it will act in C-mode and ask for the collaboration of another member of the e-collective for satisfying the client’s request.

AUT H Theory
In addition to an fNT theory and an EMP theory, each agent m in the e-collective will define an AUT H theory. An AUT H theory is a set of rules for specifying whether m authorizes a client c to perform an action a on a resource r when m is acting in f-mode or C-mode. The specification of the authorization policy may follow any of the standard access control models. For instance, we may specify a role-based authorization policy. We omit the details of the access control model (see for instance [5] for a rewrite-based specification of the RBAC model) and just show the general form of the rules:

i authorized(C, A, R) → ρi c authorized(C, A, R) → ρc

where ρi and ρc are suitable right-hand sides (depending on the policy to be mod- eled). Therefore, the term i authorized(c, a, r) (or c authorized(c, a, r)) is evalu- ated using the rewrite rules defining the chosen access control policy and gives as a result a permission or a denial, denoted by true and false respectively, for client agent c’s request to perform an action a on resource r.
An example of an AUT H subtheory, represented as a TRS, follows next.
Example 3.3 For the authorization subtheory that is used in our running example, we make the simplifying assumption that all members of the e-collective use the same RBAC authorization theory, which includes the following definitions:


i authorized(C, A, R) → check(member((A, R), privileges(roles(C)))) c authorized(C, A, R) → check(member((A, R), privileges(roles(C))))

roles(c0) → [r01,... , r1i]	...    roles(cn) → [rn1,... , rnk]
priv(r0) → [(a01, o11),... , (a1i, o1i)]  ...    priv(rn) → [(an1, on1),... , (ank, onk)]

privileges(nil) → nil
privileges(cons(R, L)) → priv(R) ∪ privileges(L)
In this example, a client agent C is authorized by an e-collective member to perform the A action on resource R, in f-mode or C-mode, if C is assigned to a role R' and the A privilege on R is assigned to R'. For example, given the rules
roles(c0) → [specialClient]
priv(specialClient) → [(buy, part(widget, 1300)),...]

we have
i authorized(c0, buy, part(widget, 1300)) →
check(member((buy, part(widget, 1300)), privileges(roles(c0)))) →
check(member((buy, part(widget, 1300)), privileges([specialClient]))) →∗ true
Any number of authorization theories can, of course, be defined (for the f-mode and the C-mode cases), but the simple authorization theory above is sufficient for understanding what is involved in specifying AUT H subtheories in action control.
Client Request Evaluation
We show next an evaluation example, using the setting and the theories presented in Examples 3.1, 3.2, and 3.3.
Example 3.4 Let us consider the request permissive(c0, buy, part(widget, 1300), m1 ). From the previous discussion and using the examples of policy formulation that we have developed, we have the reduction
permissive(c0, buy, part(widget, 1300), m1) →
i permissiveν(c0, buy, part(widget, 1300)) or c permissiveμ(c0, buy, part(widget, 1300))
The first term in the disjunction, corresponding to an action performed in f-mode, leads to the result
and(i empoweredν(c0, buy, part(widget, 1300)),i intentν(c0, buy, part(widget, 1300)), i authorizedν(c0, buy, part(widget, 1300))) →∗ and(false, true, true) → false
since the stock provision (200 widgets) associated with member m1 is not sufficient to satisfy the client’s request.
The second term in the disjunction, corresponding to an action performed in
C-mode, leads instead to the result
and(c empoweredμ(c0, buy, part(widget, 1300)),c intentμ(c0, buy, part(widget, 1300)), c authorizedμ(c0, buy, part(widget, 1300))) →∗ and(true, true, true) → true
assuming c permissiveτ (c0, buy, part(widget, 1100)) holds, i.e., another member at site τ is able to provide the remaining 1100 widgets. Therefore
permissive(c0, buy, part(widget, 300), m1) → true
In conclusion, the client’s demand cannot be treated by member m1 in isolation, but can be satisfied if other members of the e-collective collaborate with member m1, in a way allowed by the action control policy.

Properties of Action Control Policies
As in the case of access control, action control policies should satisfy certain criteria in order to be “acceptable”. For instance, it may be necessary to ensure that an action control policy formulation does not specify that any client is granted and denied the same request to the same agent at the same moment in time (i.e., that the policy is consistent). More precisely, we are interested in the following properties of action control policies:
Totality: Each request from a valid client c to a valid agent in the e-collective to perform a valid action a on the resource r receives as answer. Answers can be: a permission, a denial, or undeterminate (i.e., any result that is neither true nor false will be interpreted as undeterminate).
Consistency: For any c ∈ C, a ∈ A, r ∈ R, and m ∈ M it is not possible to derive more than one result for a request from c to m to perform the action a on
r. In other words, at most one of the results true, false or undeterminate is possible for each request.
Totality and consistency can be ensured, for policies defined as term rewriting systems, by checking that the rewrite relation is confluent and terminating. Ter- mination ensures that all requests produce a result (their evaluation cannot get “stuck”) and confluence ensures that results are unique.
A stronger version of totality, requiring that the policy always produces an answer which is true or false (i.e., no undeterminate results) is desirable for some applications. In order to prove that a policy is total in this sense, a characterisation of normal forms is needed. Sufficient completeness is a useful property in this case (see [29]).
Termination and confluence of term rewriting systems are undecidable properties in general, but there is an extensive body of work aimed at providing decidable suf- ficient conditions for confluence and termination (see, for example, [20,25,24,3,2,9]). In particular, orthogonal systems are confluent, and systems that define recursive functions using a primitive recursive scheme are terminating. These conditions have been used in [5] to derive sufficient conditions for totality and confluence of access control policies, and the same techniques can be used for action control policies.
For example, it is easy to show that the rewrite system defined by the rules given in the examples in the previous section is confluent (even if some of the rules are not completely specified) because all left-hand sides are left-linear and non-overlapping (i.e., the rewrite system is orthogonal [20]). As a consequence:
Proposition 4.1 The action control policy for the e-commerce application speciﬁed by the rewrite rules in Section 3 is consistent.

Related Work
Access control requirements for e-trading via e-collectives are not well served by existing models. Traditional access control models, like access control matrices [21], are only suitable as authorization models for actions performed by individual agents

within the context of static systems; they are not appropriate in the case of dynamic, e-trading via e-collectives.
In [27], an approach for controlled collaboration via the editing of data struc- tures is proposed. The work is based on notions from RBAC and a collection of “collaboration rights”. In contrast, the action control model focuses on arbitrary actions and a conception of collaboration that is very different from that described in [27]. In [33], some primitive concepts that relate to the authorization of joint actions are discussed and are of relevance to the notion of cooperative action that we have considered. However, the work in [33] is based on a different conception of collective action than the one that we adopt and, unlike action control, there is no discussion of any formal aspects of joint action and no formal security model is proposed.
In principle, standard RBAC models [14] do, permit requested actions on re- sources to be of arbitrary complexity, but the support for arbitrariness is facilitated by RBAC’s (generally) restricted notion of authorization. In the standard defini- tion of authorization in RBAC (omitting considerations of sessions), an action a is allowed on resource r iff a client c is assigned to a role to which the permission (a, r) has been assigned. In RBAC, a can be of arbitrary complexity and so the definitions of authorizations can be used to evaluate “Can I perform action a?” requests where a “yes” answer is rendered if c is authorized to perform a. However, for actions like buying, a “yes” response requires more than simply an authorization; a “yes” response for an act of buying only makes sense if there is a seller that has the inten- tion of allowing c to buy and the power to sell to c. In action control, permissives are a generalization of the concept of authorization.
Work on Context-TBAC (C-TBAC) [15] is related to our action control model, it being concerned with access control in collaborative environments and the context in which access control requirements are defined. However, in the action control model, unlike C-TBAC, intention policies and empowerment policies are fundamentally important and are used as standard types of contexts. Work on TeaM-based Access Control [30] is also related to ours in the sense that collaborative activity may be engaged in by a “team” of agents to satisfy some goal (i.e., C-mode action). However, the work on TMAC has been largely based on integrating TMAC with RBAC. More recently, a locale-based access control (LBAC) model [31] has been described that exhibits similarities to action control. However, LBAC is concerned with an specific enhancement of RBAC to take into account the context in which roles may be activated. None of C-TBAC, TMAC and LBAC make the distinction between f-mode and C-mode evaluation, identify the importance of a group ethos or use permissives for the rich forms of access control policies that are required in e-trading via e-collectives.
On the issue of context in access control, we also note that there are several con- tributions to the literature on representing contexts via rule-based specifications of conditional access control requirements (see, for example, [7], [17] and [4]). More- over, XACML [23] may be used to express some quite general requirements for access control. In contrast to these approaches, the action control model is very

specific about the types of rules that are to be admitted for defining permissives; ad hoc rules for specifying intentions, empowerments and authorizations are not sim- ply to be included in policy specifications (for e-collectives) as “side-conditions”. Moreover, it is the emphasis on individual and collective acting in e-collectives that makes intentions, empowerments and a group ethos important, as well as autho- rizations, for action control. Rule-based approaches have thus far been not applied in cases where these notions emerge as being important to treat.
On access control by term rewriting, we note that [5,28,8] use term rewrite rules to represent access control policies. Our work differs from this literature in the sense that we have used term rewriting to define a new type of access control model, the action control model, which is intended for use for access control for a type of organization (e-collectives) to which standard assumptions do not apply (e.g., the assumption of centralized organizations to which static forms of access policies relate to simple forms of actions on simple types of objects). The work on “policy composition” by term rewriting by Dougherty et al [13] bears some similarity to ours. In Dougherty et al.’s work, the problem of resolving conflicts when combining access control policies is addressed. In contrast, our concern is with combining action control policies that define intentions, empowerments and authorizations and thus permissives that are used to define allowed forms of action requests.

Conclusions and Further Work
We have addressed the (open) problem of defining permitted forms of complex, requested actions (like buying) that are used by agents acting individually or col- laboratively as part of an e-collective to evaluate client user requests. On that, our principal contribution has been to formally define an action control model in terms of which permissives may be specified: intentional, empowered authorized actions that may be performed individually (in f-mode) or jointly (in C-mode) and that are consistent with the shared ethos of an e-collective. To the best of our knowledge, no access control model has thus far been proposed that combines these concepts, that grounds them in an adequate theory of cooperation (cf. our use of [32]), and that is formally well-defined (cf. our use of term rewriting). For the formal specification, we have defined our action control model as a term rewrite system. Represented as a TRS, the action control model: enables changes to access control policies to be effected dynamically and autonomously; makes it possible to treat individual- istic and joint actions and the combining of multiple e-collectives in a completely uniform manner (in both cases, by exploiting the recursion, which TRSs provide); and permits properties of policies to be defined and proven for assurance purposes. Moreover, despite the complexities involved in formulation, action control policies can be straightforwardly specified as a TRS.
To simplify the discussion in this paper, we have described the action control model in terms of a basic form of group ethos and we have used simple intention, empowerment and authorization theories in our examples. It must be noted, how-

ever, that many forms of ethos and more complex forms of action control policies can be naturally accommodated in the action control model and can be represented as term rewrite systems. In future work, we plan to consider other forms of group ethos and their representation as TRSs; we also intend to consider an enhanced form of the action control model on which constraints may be expressed to capture higher-level access control policy requirements.

References
Franz Baader and Tobias Nipkow. Term rewriting and all that. Cambridge University Press, Great Britain, 1998.
S. van Bakel and M. Fern´andez. Normalization results for typeable rewrite systems. Information and Computation, 133(2):73–116, 1997.
F. Barbanera and M. Fern´andez. Intersection type assignment systems with higher-order algebraic rewriting. Theoretical Computer Science, 170:173–207, 1996.
S. Barker and P. Stuckey. Flexible access control policy specification with constraint logic programming.
ACM Trans. on Information and System Security, 6(4):501–546, 2003.
Steve Barker and Maribel Fern´andez. Term rewriting for access control. In DBSec, pages 179–193, 2006.
D. Elliot Bell and Leonard J. LaPadula. Secure computer system: Unified exposition and multics interpretation. MITRE-2997, 1976.
Elisa Bertino, Barbara Catania, Elena Ferrari, and Paolo Perlasca. A logical framework for reasoning about access control models. In SACMAT, pages 41–52, 2001.
Clara Bertolissi, Maribel Fern´andez, and Steve Barker. Dynamic event-based access control as term rewriting. In DBSec, pages 195–210, 2007.
F. Blanqui, J.-P. Jouannaud, and M. Okada. Inductive data type systems. Theoretical Computer Science, 272(1-2):41–68, 2002.
P. Borovansky, C. Kirchner, H. Kirchner, and P-E. Moreau. ELAN from a rewriting logic point of view.
Theoretical Computer Science, 285:155–185, 2002.
M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and C. Talcott. The Maude
2.0 system. In Rewriting Techniques and Applications (RTA 2003), number 2706 in Lecture Notes in Computer Science, pages 76–87. Springer-Verlag, 2003.
N. Dershowitz and J.-P. Jouannaud. Rewrite Systems. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science: Formal Methods and Semantics, volume B. North-Holland, 1989.
Daniel J. Dougherty, Claude Kirchner, H´el`ene Kirchner, and Anderson Santana de Oliveira. Modular access control via strategic rewriting. In ESORICS, pages 578–593, 2007.
David F. Ferraiolo, Ravi S. Sandhu, Serban I. Gavrila, D. Richard Kuhn, and Ramaswamy Chandramouli. Proposed nist standard for role-based access control. ACM Trans. Inf. Syst. Secur., 4(3):224–274, 2001.
Christos K. Georgiadis, Ioannis Mavridis, George Pangalos, and Roshan K. Thomas. Flexible team- based access control using contexts. In SACMAT, pages 21–27, 2001.
Paul Hudak, John Peterson, and Joseph Fasel. A gentle introduction to Haskell 98. http://www.haskell.org/tutorial/, 1999.
S. Jajodia, P. Samarati, M. Sapino, and V.S. Subrahmaninan. Flexible support for multiple access control policies. ACM TODS, 26(2):214–260, 2001.
C. Kirchner, H. Kirchner, and M. Vittek. ELAN user manual. Nancy (France), 1995. Technical Report 95-R-342, CRIN.
J.-W. Klop. Term Rewriting Systems. In S. Abramsky, Dov.M. Gabbay, and T.S.E. Maibaum, editors,
Handbook of Logic in Computer Science, volume 2. Oxford University Press, 1992.


J.-W. Klop, V. van Oostrom, and F. van Raamsdonk. Combinatory reduction systems, introduction and survey. Theoretical Computer Science, 121:279–308, 1993.
Butler W. Lampson. Protection. SIGOPS Oper. Syst. Rev., 8(1):18–24, 1974.
Tadao Miyakawa. The Science of Public Policy. Routledge, 1999.
OASIS. eXtensible Access Control Markup language (XACML), 2003. http://www.oasis- open.org/xacml/docs/.
V. vanOostrom. Confluence for Abstract Higher-Order Rewriting. Free University of Amsterdam, 1994.
Femke van Raamsdonk. Confluence and Normalisation for Higher-Order Rewriting, Free University of Amsterdam, 1996.
D. Sannella S. Kahrs and A. Tarlecki.  The definition of Extended ML: A gentle introduction.
Theoretical Computer Science, 173(2):445–484, 1997.
HongHai Shen and Prasun Dewan. Access control for collaborative environments. In Proc ACM Conf. Computer-Supported Cooperative Work CSCW, pages 51–58, 1992.
A. Santana de Oliveira. Rewriting-based access control policies. Proc. of SECRET’06, ENTCS, 2006.
A. Santana de Oliveira. Rewriting and modularity of security policies. PhD Thesis, University Henri Poincar´e, Nancy, 2008.
Roshan Thomas. Team-based access control (TMAC): a primitive for applying role-based access controls in collaborative environments. In ACM Workshop on Role-Based Access Control, pages 13–19, 1997.
W. Tolone, R. Gandhi, and G. Ahn. Locale-based access control: placing collaborative authorization decisions in context. In Proc IEEE Conf. Systems, Man and Cybernetics, 2003.
R. Tuomela. Cooperation. Kluwer, 1999.
Vijay Varadharajan and Phillip Allen. Support for joint action based security policies. In ACISP, pages 207–218, 1996.
