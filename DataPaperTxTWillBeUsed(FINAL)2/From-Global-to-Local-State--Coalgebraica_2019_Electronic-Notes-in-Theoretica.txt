Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 347 (2019) 203–222
www.elsevier.com/locate/entcs

From Global to Local State, Coalgebraically and Compositionally
Jim Laird
University of Bath, UK

Abstract
We describe a type theory or metalanguage for constructing and reasoning about higher-order programs with global and local state, and its categorical model. This provides an encapsulation primitive for abstracting global state and making it local to an object, so that it is passed only between its invocations. Our calculus and its semantics extend the interpretation of lambda-terms in a Cartesian closed category with a monoidal action on a category of evaluation contexts — the sequoid — which is dual to the action of the function type. This gives an interpretation of a new type constructor which allows the representation of both global state — via “state-passing-style” interpretation which uses it to represent output states — and local state, via encapsulation, which corresponds to the unique map into a final coalgebra for the sequoid. This provides the equational theory of our calculus with a coinduction rule for proving equivalence between objects with local state. We show that this theory is sound and complete with respect to the categorical semantics by constructing a term model and we show that it is consistent by giving a concrete example based on a category of games and strategies previously used to interpret general references.

Introduction
This paper describes a methodology for constructing higher-order, stateful programs
— in particular, by making state local to a function or object — and for establish- ing equivalence between them. By restricting where and how changes to the state can occur, locality simplifies the modular construction and verification of stateful programs — e.g. it is no longer necessary to keep track of an ever-increasing col- lection of global variables to avoid undesirable state changes. However, reasoning about local state can be subtle, as changes to the state are implicit in interaction with the objects which interface with it. Because it has a formal, categorical model, our operation for making state local comes with a sound and complete theory of program equivalence.
It is based on a powerful and well-established principle for abstracting the state from a computational system which can be represented as a coalgebra for a functor, by taking the unique map into its ﬁnal coalgebra [20]. For example, if we have a (deterministic) system which at each step takes in an input state s from a set S to an output state sj ∈ S and produces an observable value v ∈ V , this may be

https://doi.org/10.1016/j.entcs.2019.09.011
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

represented as a function f : S → V × S — i.e. a coalgebra for the functor V × on the category of sets. The final coalgebra for this functor is given by the set of infinite sequences (streams) of values in V and the function taking such a stream v1v2v3 ... to (v1, v2, v3 .. .). The unique coalgebra morphism from f is the function which takes an initial state s and returns the corresponding stream of observable values π1f (s)π1f (π2f (s))π1f (π2f (π2f (s))) .. .. This characterizes exactly the observable behaviour of the system, while hiding the internal passing of state from one step to the next. It also comes with coinductive principles for reasoning about infinite streams based on the coalgebras which generate them [21].
Coalgebraic principles have been used to describe the semantics of stateful pro- gramming languages such as Java [6] in this way. The novelty and technical chal- lenge of our approach is to describe such a construction inside a metalanguage itself, in a setting which soundly captures higher-order functions with shared access to our stateful objects, allowing them to be combined compositionally. To capture this shared access requires a new coalgebraic representation of global state which is not available in the category of sets: our model is motivated and underpinned by game semantics. It has developed from investigation of the game semantics of local state, in particular higher-order references [2]. This seminal model elegantly distils stateful behaviour into the interpretation of local variable declaration as a strategy behaving as a reference cell, so that composition with this cell yields a class of strategies for which the whole history of play can act as an internal state. The combinatorial definition of the cell — and thus the denotations of programs it generates — lacks a direct relationship to the abstract notion of state; in [10,5] it was shown that it may be interpreted coalgebraically, using the final coalgebra for a new kind of functor, the sequoid.
The work reported here abstracts these techniques from the technical setting of game semantics into a general metalanguage for reasoning about state. Specifically, we describe a conservative extension of the simply-typed λ-calculus to a typing sys- tem with a new constructor for output states — for which an object with global state may be represented as a coalgebra — and an encapsulation operator corresponding to a unique map into its final coalgebra. The uniqueness property of the latter provides us with a new coinductive principle for proving equivalence between pro- grams with local state, based on their local reductions. This is part of a sound and complete equational theory for our metalanguage, which could be used as the basis for new programming languages, or for analyzing existing ones via translations.

Overview and Related Work
We first present the part of our calculus in which we may represent objects with global state. This is based on adding explicit definitions for variables to the λ- calculus, as in the λσ-calculus of explicit substitutions [1]. A key feature is that variables may be invoked outside the lexical scope of their definition. Accordingly, we introduce two further binding operations: variable hiding with scope extrusion in the style of the π-calculus [14], and an operation abstracting the capability to define a variable in our model (similar to to the notion of σ-abstraction of the capacity to

write to a global reference described in [4]) which is typed with a new constructor,
 .
In Section 3 we describe additional structure on a model of the λ-calculus (Carte- sian closed category) which may be used to interpret these constructs: a sequoidal CCC. This is based on interpreting the basic operation of adding a variable definition to a term via its monoidal action on a category of linear morphisms corresponding to evaluation contexts. The use of a monoidal action to describe state-passing style semantically has been explored by Møgelberg and Staton [15], who have also demon- strated a precise correspondence with continuation-passing-style which relates to a further property of our model: a duality between the sequoid and the internal hom from the CCC. This induces a form of trace operator [9] with which variable hid- ing is interpreted (cf. models of the π-calculus such as [7]). Our soundness and completeness result with respect to the equational theory of our calculus is proved by constructing a term model, showing that it is an internal language for sequoidal CCCs, extending (for example) the original result for the simply-typed λ-calculus [11].
Examples of sequoidal CCCs arise from any (pre)monoidal adjunction between a CCC and a compact closed category — e.g. the categories of sets and functions, and sets and relations. However, there are instances which do not arise in this way. We give an example based on the Hyland-Ong style games used to give a denotational semantics of higher-order references [2]. Another example of a sequoidal CCC was introduced in [10]: this is built from a model of intuitionistic linear logic in which the exponential !A is the ﬁnal coalgebra for the sequoidal functor A . As discussed in [5], this gives a recipe for defining strategies by taking the anamorphism for a coalgebra σ : S → A S (which, as we have noted, corresponds to an object with global state in S), leading to coalgebra morphism from S to !A in which the state is hidden. A similar operation was proposed by Longley [13]. A contribution of the current work is to reframe this recipe for models which do not have a linear decomposition.
In Section 4, we extend our calculus with a corresponding syntactic encapsula- tion operation which binds a variable to a term in which the globally visible state (e.g. derived by state-passing style interpretation) has been made local by using hidden variables to share it between between successive invocations of the variable. This is a characterization of the abstraction operation of [17], in which anti-frame rules are introduced to reason about it in an axiomatic semantics setting. Here, we describe a coinductive rule for proving equivalence between definitions of objects with encapsulated state and apply it to some simple examples including a reference cell. In Section 5, we extend our categorical model and its soundness and complete- ness results for the equational theory to the encapsulation operator, by developing a new category of coalgebras and “sequoidal natural transformations” on sequoidal categories.

A Calculus for Global State
In this section we describe the basis for our representation of higher-order state, in the form of a novel type theory in which terms may contain explicit definitions of variables (as terms) and the capability to make such definitions may be abstracted. It is a direct extension of the (call-by-name) simply-typed λ-calculus with finite products — although this does not directly reflect the semantics of a typical “real- life” stateful higher-order programming language particularly closely, its models (Cartesian closed categories) are the simplest setting in which we can introduce our key ideas, and can be readily extended to effect calculi, used for CPS translation, or otherwise extended with more expressive types and features.
Raw terms are generated by the following grammar:

t := x | λx.t | tt | t{x := t} | νx.t | λx.t | t x | t.i | ⟨t1,..., tn−1
— i.e. by extending the λ-calculus with the following operations:
Deﬁnition — s{x := t} adds a definition of the variable x as t to s.
Declaration (hiding) — νx.t hides the variable x in t.
Co-abstraction — λx.t abstracts the ability to define the variable x — and
Co-application — t y assigns to y the definition abstracted in t.
Types are given by the grammar: S, T := B | Πi<nSi | S → T | S  T — i.e. from a set of ground types B by the finite product and function type constructors of the simply-typed λ-calculus extended with a notion of “output type” S T , which is introduced by co-abstraction and eliminated by co-application: when supplied with a variable of type T ,a term of type S  T defines it and returns a result of type s. We will assume that subterms may be annotated with their types where necessary but in general omit these annotations.
The rules for typing judgments are given in Table 1. They generate terms-in- context of the form Γ ▶ t : T ; Δ, where Γ and Δ are sets of typed variables (non- repeating sequences, considered up to permutation). Γ (the input context) contains free variables which t may invoke, and Δ (the output context) free variables which it has defined. If a name occurs in Γ it may or may not appear in Δ, and vice-versa.
Definitions may be recursive: e.g. we may define the fixed-point combinator
YT : (T → T ) → T =df λf.νx.x{x := f x}.
Inputs are treated non-linearly whereas outputs are treated linearly (a variable is defined exactly once but may be invoked as many times as required). These constraints entail that terms represent sequential and deterministic programs, although they may be relaxed.
Although application and co-application are not symmetric, since a term may be co-applied only to a variable but applied to any term, we may regain symmetry between these operations by replacing the application ts with νx.t x{x := s}.
To give an equational theory concisely, we introduce head contexts, which have



Γ,x:T▶x:T ;
Γ,x:S▶t:T ;Δ,x:S
Γ▶νx.t:T ;Δ
Γ▶s:S;Δ	Γ▶t:T ; Γ▶s{x:=t}:SΔ,x:T


 Γ,x:S▶t:T ;Δ  x /∈ Δ	 Γ▶t:T ;Δ,x:S x /∈ Γ	Γ▶ti:Ti;Δ	i<n


Γ▶λx.t:S→T ;Δ
Γ▶λx.t:T  S;Δ
Γ▶⟨t1,...,tn−1⟩:Πi<nTi;Δ



Γ▶t:S→T ;Δ	Γ▶s:S; Γ▶t s:T ;Δ
Γ▶s:S T ;Δ	 Γ▶s x:S;Δ,x:T
Table 1 Typing Rules
Γ▶t:Πi<nTi;Δ i < n 
Γ▶t.i:Ti;Δ


holes exactly at their head positions (which are encountered exactly once during evaluation).
Definition 2.1 Head contexts are given by the grammar:
L ::=	[ ] | λx.L | ⟨L1,..., Ln⟩ | L{x := t} | νx.L | Lt | L.i
We assume that head contexts only bind variables if the binders are made explicit
— e.g. L[t] is assumed to not bind variables in t, but νx.L[t] may bind occurences of x in t. The equational theory =T is the least congruence containing the axioms in Table 2, which extend the βη-equality of the λ-calculus (with finite products) with axioms asserting that:
Definition and hiding commute with head contexts, providing no variables are captured (so, in particular, they commute with each other).
Bound input variables may be replaced with their definitions; if a variable is never invoked then its definition may be garbage-collected; a bound output variable aliased to another variable may be replaced by it.
(λx.t) s =T t[s/x]	λx.(t x) =T t (x /∈ FV (t)

(λx.t) y =T t[y/x]	λx.(t x) =T t (x /∈ FV (t))
⟨t1,..., tn⟩.i =T ti	⟨t.1,..., t.n⟩ =T t
νx.L[t] =T L[νx.t] (x /∈ FV (L[ ])	L[t{x := s}] =T L[t]{x := s}
νx.t{x := s} =T νx.t[s/x]{x := s}	νx.t{y := x} =T t[y/x] (x /∈ FV (t)) νx.t{x := s} =T t (x /∈ FV (t))
Table 2 Equational Theory


Sequoidal Categories
We now define a notion of categorical model for our type theory which conservatively extends the interpretation of the λ-calculus in a cartesian closed category [11] with

structure for interpreting variable definitions and output types, based on the notion of sequoidal category introduced in [10].
An action of a symmetric monoidal category C is given by a category L and a strong monoidal functor from C into LL (the monoidal category of endofunctors on L with composition). In other words, a functor : L×C → L with isomorphisms λX,B,C : X (B ⊗ C) ∼= (X B) C and κX : X I ∼= X satisfying the coherence equations for a strong monoidal functor [8]. We write (C, ⊗) for the canonical action of C on itself.
By a weak morphism between the C-actions (L,  ) and (Lj,  j) we mean a functor
J : L→ Lj with a natural transformation ωX,A : JX  j B → J(X  A) such that:

JX  j (A ⊗ B) 	ωX,A⊗B	/J(¸X  (A ⊗ B))
¸¸¸¸¸
JX  j I
¸¸¸
ωX,I	/J(¸X  I)
′

′
JX,A,B
J¸(¸λX,A,B )
¸¸¸¸¸
¸¸κ¸JX 
¸¸¸¸
J(κX )

   j	(ωX,A ′B) /¸
j	ωX❾A,B/¸z˛
¸z˛ 

(JX  A)  B
J(X  A)  B
J((X  A)  B)	JX 

It is strong if ω is an isomorphism, and strict if it is the identity.
Definition 3.1 A sequoidal category is a tuple (C, L, ,J) given by a symmetric monoidal category (C,I, ⊗), a C-action (L, ) and a weak morphism of C-actions (J, ω) from (L, ) to (C, ⊗).
It is cartesian if the symmetric monoidal structure on C is cartesian, and the image under J of a specified finite product structure on L “on the nose” (i.e. J(X × Y )= JX × JY ).
We will use the sequoid to interpret the explicit definition operation: given terms s and t denoting morphisms f : A → JX and g : A → JY in a cartesian sequoidal category, s{x := t} denotes the morphism ⟨f, g⟩; ωX,JY : A → J(X  JY ).
Examples of sequoidal categories may be derived from premonoidal adjunctions [18]. For any symmetric monoidal category (C, ⊗,I) and premonoidal category (L, ⊙,I), a premonoidal functor J : L → C with a premonoidal left adjoint G : C → L yields a sequoidal category (C, L, ⊙G ,J): G is necessarily strong monoidal into the centre of L (morphisms for which ⊙ is always bifunctorial) and hence X  A = X ⊗L GA is a C-action on L, with a natural transformation ωX,B : JX ⊗C B → J(X ⊗L GB) making (J, ω) a weak morphism of C-actions from  to
⊗. However, some of the sequoidal categories that we are particularly interested in do not arise from premonoidal adjunctions in this way: in particular the sequoidal categories of games described below (and in [10,3,5]).
Sequoidal Closed Categories
λ-abstraction and function application in our calculus are interpreted in standard fashion by requiring that the symmetric monoidal category is closed — i.e. has an internal hom functor: we can then interpret all of the other rules by requiring that the sequoid is dual to this, in a sense in which we now explain.
Definition 3.2 A dual for a C-action (L, ) is a Cop-action ( on L such that for each A in C,  A is dual to A ( in the monoidal category LL — i.e. both right

and left adjoint to the endofunctor   A.
Observe that dual actions commute — i.e. there is a natural isomorphism θA,B,X : A ( (X  B) ∼= (A ( X)  B, since for any functions F E▶ G and Fj E▶ Gj such that F commutes with Fj and G with Gj, we may construct a natural isomorphism:


j FG′η	j	∼
j	єG′F	j

FG −→ FG FG = FGG F −→ G F
Definition 3.3 A sequoidal closed category is given by a tuple (C, L,  ,J) where
C is a symmetric monoidal closed category.
(L,  ) is a C-action with a dual, (L, ().
J is a strong morphism of Cop actions from (L, () to (C, ().
A sequoidal CCC is a sequoidal category which is cartesian, and closed.
To justify the terminology, observe that by uncurrying J(ηX,B) : JX → B ( J(X B) (where η is the unit of the adjunction B ( E  B) the above data determine a natural transformation ωX,B : (JX ⊗ B) → J(X  B) making (J, ω) a lax morphism of C-actions from (L, ) to (C, ⊗). So we can equivalently say that a sequoidal category is closed if it arises in this way. For adjunction models, sequoidal closure corresponds to compact closure of the image of the functor G : C → L.
Proposition 3.4 An adjunction model (C, L, J, G) is sequoidal closed if and only if C is symmetric monoidal closed and every object GA has a dual in the premonoidal category L.
Proof. If L has duals of every object GA then the Cop-action  ⊗ (G )∗ is dual to  ⊗ G by definition, and for any objects A in C and B in L, J(B ⊗ (!A)∗) is an exponential in C, and so J is a strong functor of Cop actions. Conversely, if (C, L, J, G) is sequoidal closed, then for any A, GA ( I is a dual for GA in L.  □
A simple example of a sequoidal CCC is thus given by the monoidal adjunction between the Cartesian closed category C of sets and functions and the compact closed category L of sets and relations — i.e. J : L → C is the powerset functor and  is the action sending sets A, X to A × X. This is self-dual and satisfies J(A ( X)= P(A × X) ∼= P(X)A = A ( JX.
Every compact closed category (C, ⊗,I) admits a canonical trace operator [9] on C: sequoidal closed structure on (C, L, J, ) induces similar operators on both C and L, which we use to interpret variable hiding.
Definition 3.5 Given f : A⊗B → J(X  B) in C, define trB	(f )= Λ(f ); J(ϵB,X ),
where ϵB,X : B ( (X B) → X is the co-unit of the adjunction B ⇒ E  B. The corresponding operation on L sends f : X  B → Y  B to Λ (f ); ϵB,Y : X → Y . 1

1 In an adjunction model, this corresponds directly to the trace operator induced by the compact closed structure.

These operators satisfy axioms analogous to the corresponding properties of a traced monoidal category (we refer to [9] for diagrammatic representation) i.e.

Naturality in A and X: trB
(f ); J(g)= trB
(f ; J(g  B)) for g : X → Y and

h; trB
(f ) = trB
((h ⊗ B); f for h : C → A.

Dinaturality in B: trC
(f ; J(X  g)) = trB
((A⊗g); f ) for f : A⊗C → J(X B)

and g : B → C.
Vanishing: trI

(f ) = f and trB

C
A×B,J(X  B)

(f )) = trB⊗C(f ; J(λX,B,C)).

Superposition: trB
(f ){g} = trB
((A ⊗ γB,C); f{g}; J(X  γC,B)), where

γ is the symmetry isomorphism of (C, ⊗,I).
Yanking: tr(γJX,JX ; ωJX,JX )= idJX .
A Sequoidal CCC of Games
We now briefly describe a sequoidal closed category, and related sequoidal CCC of “Hyland-Ong-style” two-player games and strategies, by adding sequoidal structure to the categories of games used by Abramsky, Honda and McCusker to give a semantics of higher-order references [2], to which we refer for further details. It will serve as a more concrete example of the definitions already introduced (establishing their consistency) and provide motivations and intuitions for extending our type theory and categorical model to capture its coalgebraic properties.
Definition 3.6 An arena ⟨MA,MI , ▶A, λA⟩ is a directed, acyclic graph —- a set of nodes (moves) MA with an edge-relation ▶A⊆ MA × MA (enabling) and a set of
specified source nodes MI ⊆ MA (initial moves) — with a labelling λA : MA →
{O, P} of each move as a Player or Opponent move such that every initial move is an Opponent move.
Apart from dropping the labelling of moves as questions and answers (as we shall not make use of it), the only change from [2] is that we do not require that non-initial O moves are enabled by P -moves and vice-versa.
Definition 3.7 A legal sequence on the arena A is a finite O/P alternating sequence of moves equipped with an explicit justiﬁcation pointer from each non-initial move to a preceding, enabling move. (Note that O-moves may point to O-moves, and P -moves to P -moves.)
A (deterministic) strategy σ on A is a non-empty, even-prefix-closed set of even- length legal sequences on A such that sa, sb ∈ σ implies a = b.
The category of games G has games as objects: morphisms from A to B are strategies on the game A ⇒ B   (MA + MB, inr(MI ), ▶A + ▶B ∪(inr(MI ) ×
B	B
inl(MI ), [λA, λB]). The identity on A is the set of “copycat sequences” on A ⇒ A
(every even prefix has equal projections to both copies of A) and the composition of morphisms is their “parallel composition with hiding” — i.e. given strategies σ : A → B and τ : B → C, σ; τ consists of the legal sequences which are restrictions to A ⇒ C of sequences t in MA + MB + MC such that tTA, B is in σ and tTB, C

is in τ . We may define symmetric monoidal (closed) structure on G, with A ⊗ B 
(MA + MB,MI + MI , ▶A + ▶B, [λA, λB]). We now define sequoidal closed structure
A	B
on G:
Definition 3.8 A strategy on A ⇒ B is linear if:
every sequence s ∈ σ contains at most one initial move from A and B, respectively.

for every initial move b ∈ MI
there exists a ∈ MI
such that ba ∈ σ.

Games and linear strategies form a category Gl, with an identity-on-objects functor J : Gl → G which sends the linear morphism σ : A ⇒ B to the strategy σ† consisting of legal sequences on A ⇒ B which are the interleaving of some s1,..., sn ∈ σ.
The internal hom functor ⇒ : Gop ×G → G restricts to linear morphisms, giving an action of Gop on Gl such that J is a strict map of Gop actions. Moreover
⇒ has a dual:
Definition 3.9 Given arenas A and B, the sequoid A  B is defined:
(MA + MB, inl(MI ), ▶A + ▶B ∪(inl(MI ) × inl(MI ), [λA, λB])
A	A	B

i.e. A B is defined as for B ⇒ A except that Player/Opponent labelling is not swapped in A. Thus there are evident natural isomorphisms:

Gl(A B,C)
Gl(A,B⇒C)
Gl(B⇒A,C)
Gl(A,C  B)

making (G, Gl, J, ) a sequoidal closed category. This is not a sequoidal CCC be- cause ⊗ is not a cartesian product on G. However, we may obtain a sequoidal CCC by restricting to well-opened strategies — essentially the same step as in [2].
Definition 3.10 A legal sequence is well-opened if it contains at most one initial move. A strategy is well-opened if it consists of well-opened legal sequences, and the category Gw of arenas and well-opened strategies has as morphisms from A to B, the well-opened strategies on A ⇒ B, with the composition of σ : A → B with τ : B → C being the parallel composition with hiding of σ† with τ .
Gw is cartesian closed (with product ⊗) with the inclusion functor J : Gl → Gw being a strict morphism of actions which preserves products Gl. Thus (Gw, Gl, J,  ( )†) is a sequoidal CCC.
We now explain why our sequoidal categories of games cannot arise from a premonoidal adjunction. Observe that in any sequoidal closed category, if J : L→C has a left adjoint G : C → L, then G is isomorphic to the functor GI  , since we have L(GA, B) ∼= C(A, JB) ∼= C(I, A ( JB) ∼= L(GI, A ⇒ B) ∼= L(GI  A, B).
There can be no such functor from G into Gl: it is straightforward to show that if
there is a surjective map from strategies on A to linear strategies on A ( A, then A is either the empty game (terminal object) or has a single playable move: in neither case is A  left adjoint to the inclusion J : Gl → G.

Thus the sequoidal structure in our games does not arise from an adjunction. In fact, more can be said: we can describe a CPS-style construction which recovers all premonoidal adjunction models which embed in a given sequoidal closed category and show that there is no such embedding into our category of games — i.e. we cannot apply constraints to strategies to carve out a non-trivial adjunction model.
Definition 3.11 An embedding of sequoidal categories from (C, Lj,  j,Jj) to (C, L,  ,J) is a strong functor of C-actions H : (Lj, j) → (L, ) which is fully faithful and such that Jj = HJ.
For any sequoidal closed category, (C, L,  ,J), and object X in L, let LX be the category in which objects are pairs (A+, A—) of objects of C, and morphisms from (A+, A—) to (B+, B—) are morphisms from A— ( X  A+ to B— ( X  B+ in L. Thus we may define the sequoidal category (C, LX, X, JX ) in which (A+, A—) X
B  (A+ ⊗ B, A—) and JX (A+, A—)  J(A— ( X  A+). This is sequoidal closed:
 X has a dual, B (X (A+, A—)  (A+, A— ⊗B) such that JX (B (X (A+, A—)) ∼= B ( J(A+, A—).
(C, LX, X, JX ) embeds in (C, L, ,J): there is a fully faithful (identity on morphisms), strong functor of C-actions HX : LX →L sending (A+, A—) to A— ( X  A+, such that JX = JHX
We may also define (symmetric) premonoidal structure on LX — (A+, A—) ⊙X (B+, B—)= (A+ ⊗ B+, A— ⊗ B—), with unit (I, I) — and a functor GX : C → LX sending A to (A, I) and f : A → B to X f : (A, I) → (B, I). We note the following facts:
If GX : C → LX is premonoidal left adjoint to JX : LX →C then (C, LX, JX, GX ) is a premonoidal adjunction model embedding in L.
If Lj is a premonoidal adjunction model with an embedding H : Lj → L into (C, L, J, ) then Lj is equivalent to LHI , and so GHI is premonoidal left adjoint to JHI .
As argued above, if LX is a premonoidal adjunction model then L(X, X) ≡ C(1,X), which is impossible in our sequoidal category of games — thus by (ii), the latter cannot contain (by embedding) a premonoidal adjunction model.
Denotational Semantics
We can now define the interpretation of our type theory in a sequoidal CCC, (C, L, ,J). We interpret types as objects of L — by fixing a denotation for the ground type(s) and letting [S → T ]] = J[[S]] ( [[T ]], [[S  T ]] = [[S]]  J[[T ] and
[[Πi<nTi]] = Πi<n[[T ]]. Terms x1 : R1,..., xm : Rn ▶ t : T ; y1 : S1,..., yn : Sn are
interpreted as morphisms from J[[R1]] × ...J[[Rm]] to J([[T ]]  J[[S1]] × ... × J[[Sn]]) in C.
The interpretation of variable invocation, abstraction, application, tupling and projection is based on the standard model of the simply-typed λ-calculus with prod- ucts in a Cartesian closed category, together with isomorphisms θA,B,X : A ( J(X  B) ∼= J((A ( X)  B) and ζX,Y,A : J(X × Y  A) ∼= J(X  A) × J(Y  A)

derived from duality (  A and A ( preserve limits). Co-abstraction and co- application derive from the strength isomorphism λ : X (B × C) ∼= (X B) C, and (as proposed above) deﬁnition from the sequoidal structure and hiding from the trace structure.
To prove that our equational theory is sound with respect to this interpretation
— i.e. if Γ ▶ t =f tj : T ;Δ then [Γ ▶ t : T ; Δ ] = [Γ ▶ tj : T ; Δ ] — we first extend our semantics to interpret typed head contexts as morphisms in the category L.
Definition 3.12 We write Γ; S ▶ L : T ;Δ if Γ, • : S ▶ L[•]: T ; Δ — i.e. the type on the left of the turnstile represents the type of the holes in the head context.
We may substitute either terms or head contexts into the holes in a head context: such substitution is assumed to be non-capturing unless indicated otherwise, and agrees with the typing rules — i.e. if Γ ▶ t : S; Δj and Γ; S ▶ L : T ;Δ then Γ; S ▶ L[t]: T ; Δ, Δj. Moreover, we may interpret head contexts Γ; S ▶ L : T ;Δ as morphisms from [T ]]  [Γ]] to [S]]  [[Δ ] in L such that for any term Γ ▶ t; Δj:
[[L[t]]]C = δΓ; ( [t]]C{Γ}); J([[L]]L  Δj)
We now prove soundness based on the properties of a sequoidal CCC:
The βη equivalences for →, × are standard for a CCC, and for follow from interpretation of co-abstraction and co-application as natural isomorphisms.
[[L[νx.t]]] = [[νx.L[t]]] and [L[s{x := t}]]] = [[L[s]{x := t} ] follow from naturality of the trace operator and definition operation, respectively.
[[νx.s{x := t}]]= [[s]] (where x is not free in s) follows from the vanishing property of the trace and νx.t{x := s} = νx.t[s/x]{x := s} and [νx.t{y := x}]] = [[t[y/x]] (where x is not free in t) follow from the dinaturality of the trace.
Proposition 3.13 (Soundness) If Γ ▶ s =f t;Δ then [[Γ ▶ s; Δ]]= [[Γ ▶ t; Δ ] in every sequoidal CCC.
To prove that our equational theory is complete — i.e. if [[Γ ▶ s : T ; Δ ] = [Γ ▶ t : T ; Δ]] in every sequoidal CCC then s =f t — we will construct a term model: a sequoidal CCC (Lf , Cf , Jf , f ). The Cartesian closed category Cf has types as objects: morphisms from S to T are T -equivalence classes of closed terms of type S → T : the composition of s : R → S and t : S → T is λx.t (s x) and the identity on T is λx.x. This defines a CCC [11].
The category Lf has types as objects: morphisms from S to T in Lf are T - equivalence classes of (closed) head contexts ; S ▶ L : T ; (composition of L : R → S with Lj : S → T is Lj[L]: R → T and the identity on each object S is the context S ▶ [ ]: S). The product of types is a Cartesian product in Lf .
The (identity-on-objects) functor J : Lf → Cf sends the head context L : S → T to the term λx.L[x]. This preserves products, and is a strict morphism of actions into the internal hom action on Cf from the Cop-action (Lf , →) which sends S, T to S → T , and the morphisms t : S → Sj,L : T → T j to λx.L[ (t x)] : (Sj → T ) → (S → T j).

Lemma 3.14	→  : Cop × Lf → Lf has a dual action.
Proof. For any T , the functor T →	has a left and right adjoint, the functor
  T : Lf → Lf sending L : S → Sj to λx.L[ x] : S  T → Sj  T . The counits and units of the duality are:
(νx.[( x) x], λx.λy.[ ]{y := x}): T →  E   T
(νx.[( x) x], λx.λy.[ ]{x := y}):   T E T →
□
Thus we have defined a sequoidal CCC, yielding an interpretation of each term- in-context x1 : R1,..., xm : Rm ▶ t : T ; y1 : S1,..., yn : Sn as a closed term [[t]]f : R1 × ... ×→ Rm → T  S1 × ... × Sn, which we may prove (by induction) is equivalent to t (up to uncurrying) in the equational theory:
Lemma 3.15 t =f νz.([[t]]f ⟨x1,..., xn⟩) z{y1 := z.1} ... {yn := z.n}.
So if [s]]f = [[t]]f then s =f t, and we have established that our equational theory is complete with respect to interpretation in a sequoidal CCC.
Theorem 3.16 (Completeness) If [[Γ ▶ t1 : T ; Δ ] = [Γ ▶ t2 : T ; Δ ] holds in every sequoidal CCC, then t1 =f t2 : T.
From Global To Local State
In a sequoidal CCC (C, L, J,  ), we represent an object of type T with global state of type S — i.e. taking an input state and producing an output state of type S — asa morphism into (S ( T  S). For any object S of C, the adjunction between S ( and  S resolves the monad §S = S ( (  S) on L (isomorphic to (S → )  S). Moreover, we have a natural transformation S ( ωS,A : S → (JX × A) → S ( J(X  A) ∼= J(S ( X  A) making (J, S ( ωS) a lax morphism of monads from
§S to the usual state monad S ( ( × S) for C. In other words, we can construct
objects using the state monad and convert to a sequoidal representation of state: in our calculus, this operation corresponds to the term λf.λx.λy.(f x).1{y := (f x).2} : (S → T × S) → S → T  S.
However, §S allows operations on the state not available to the state monad: it satisfies isomorphisms including §S§T A ∼= §S×T A, §S(A × B) ∼= §S(A) × §S(B), and
§S(A ( B) ∼= A ( §SB. The last of these allows values to be passed out of static scope, which is key to straightforward manipulation of higher-order states. Our
calculus provides a convenient language to express this by representing objects with global state of type S as terms Γ,x : S ▶ t : T ; y : S: the function which discards its input state, writes its argument to the output state and returns the identity is x : S ▶ λz.λa.a{y := z} : S → B → B; y : S, while x : S ▶ x{y := x} : S; y : S, returns one copy of the output state and passes on another.
Last but not least, a morphism to S ( T S corresponds to a coalgebra for the sequoid, allowing its global state to be made local by encapsulation, as we now explain.

Final Coalgebras for the Sequoid
The sequoidal CCCs of games in [10,3,5] are based on a construction of !A — the cofree commutative comonoid on A — from a final coalgebra for the sequoid in those categories.
Definition 4.1 Given a functor F : C → C, a ﬁnal coalgebra for F is a terminal object in the category of F -coalgebras. In other words, an F -coalgebra — a pair (A, α) of an object A of C and a morphism α : A → FA — such that for any F - coalgebra (B, β : B → FB) there is a unique morphism of F -coalgebras from (B, β) to (A, α) — that is, a unique morphism ([β]) : B → A in C (the “anamorphism” of β) for which the following diagram commutes:
B	/F¸B 
β

([β])
  
F ([β])
  

A 	α /F¸A 
Given a cartesian sequoidal category with such a final coalgebra for the functor J(A  ) : C → C for each A, we can define a morphism m :!A⊗!B →!(A × B) by taking the anamorphism of the coalgebra:
⟨α⊗!B,!A⊗β⟩
!A⊗!B	−→	(J(A  !A)⊗!B) × (J(B  !B)⊗!A

ω−×→ω
(A  !A)  !B) × ((B  !B)  !A ∼= (A × B)  (!A⊗!B)

In [5] it was shown that in a cartesian sequoidal category where this map, and the terminal morphism t : I → 1 are isomorphisms, the comonoid (!A, !δ; m—1 :!A →
!A⊗!A, t!A :!A → I) is the cofree commutative comonoid on JA. Which is to say that there is a morphism derA :!A → A = α; J( tA) giving a natural equivalence between morphisms into A and comonoid morphisms into (!A, !δ; m—1, t!A). From a sequoidal closed cartesian category (C, L, J, ) we may thus define a sequoidal CCC (C!, L, !, ! ), where C! consist of objects of L, with morphisms from A to B being comonoid morphisms from !A to !B.
As discussed in [5], in addition to a model of linear logic, this sequoidal expo- nential gives a recipe for interpreting imperative objects with local state:
Take a morphism σ : S → J(A S) in C representing an object with access to global state
(!S, σ) is a J(A  )-coalgebra in C and therefore has a unique anamorphism ([σ]) : S →!A taking an initial state to the cofree commutative comonoid on A: the comonoid structure characterizes shared access to ([σ]), which passes hidden state between successive invocations.
However, this recipe depends on the decomposition of our sequoidal CCC into a model of linear logic. To reflect this decomposition in our calculus would represent a substantial syntactic overhead. Moreover, it does not correspond to the structure of our sequoidal CCC of Hyland-Ong games (nor the interpretation of higher-order store within it). Here, we show that we may give a coalgebraic interpretation of

higher-order store without a linear decomposition by considering terminal objects in a category in which objects are still J(A  )-coalgebras, but morphisms between them are certain natural transformations.
First, we give the syntactic/operational account by extending the calculus de- fined in Section 2 with an encapsulated deﬁnition operation which abstracts the global state of an object by binding it to a variable and passing the state between successive invocations of the variable while hiding it from the outside world. We will show that this may be interpreted as the “anamorphism” operation in our category of J(A  )-coalgebras.
Definition 4.2 We extend the grammar of raw terms of our calculus to allow expressions of the form r{x := ε(s, t)} (the definition of x in r as the encapsulation of t with initial state s). This has the typing rule:
Γ▶r:R;Δ	Γ▶s:S;	Γ,▶t:S→T S; Γ▶r{x:=ε(s,t)}:R;Δ,x:T
Each invocation of x fetches a copy of t, passes in either the initial state s (on first invocation) or (subsequently) the state from the previous invocation and uses a fresh name to pass the output state generated by t to the next invocation. Thus encapsulated definition satisfies the unfolding rule:

νx.L[x{x := ε(s, t)}] =f + νx.νb.L[(t s) b{x := ε(b, t)}]
Representing Local Variables
Given terms t1,... tn such that Γ,y : S ▶ ti : Ti; z : S, the encapsulated definition
{x := ε(s, λy.λz.⟨t1,..., tn⟩)} binds x to an object which acts as an interface to a hidden local state of type S, shared between the methods t1,..., tn — i.e. the only operations on the state are those specified by selecting a method by projection and applying it to some arguments. Our key example is the higher-order reference cell storing values of type S, which (as proposed in [19]) may be represented as a product of its two methods — writing and reading to global state of type S — giving a term cellS : S → (var[S]) S  λy.λz⟨λa.λb.b{z := a}, y{z := y}⟩, where var[S]  (S → B → B) × S. By encapsulating this, we define a new variable declaration refS : S → (var[S] → T ) → T , which applies its second argument to a new cell initialized with its first argument:
refS   λu.λf.νc.(f c){c := ε(u, cell)}

Using the unfolding rule, we can prove within the equational theory that this has the expected read-write behaviour. Writing set(a) and get(a) for a.1 and a.2: refS s λa.L[set(a) s] =f + νc.L[c.1 t]{c := ε(s, cell)}
=f + νc.νb.E[((cell s) b).1 t]{c := ε(b, cell)}
=f + νc.νb.L[(λx.λz.z{b := x}) t]{c := ε(b, cell)}
=f + νc.νb.L[λz.z{b := t}]{c := ε(b, cell)}
=f + νc.L[λz.z]{c := ε(t, cell)} =f + refS t λa.L[λz.z]

refS t λa.L[get(a)] =f + νc.L[c.2]{c := ε(t, cell)}
=f + νc.νb.L[((cell t) b).2]{c := ε(b, cell)}
=f + νc.νb.L[t{b := t}]{c := ε(b, cell)}
=f + νc.L[t]{c := ε(t, cell)} = refS t λa.L[t].
Coinduction
As illustrated in the example of the reference cell above, the unfolding rule describes the finitary behaviour of encapsulated objects. However, it is typically insufficient to prove equivalences between such objects which involve infinite (or unbounded) behaviour. To fill this gap we extend our theory with a rule which will enable us to give coinductive proofs of such equivalences. Essentially, this rule says that any environment which contains a definition of a variable x is equivalent to an encapsulated definition for x which has the same unfolding behaviour.
Definition 4.3 The environment contexts are given by the grammar:
E := [ ] | E{x := t} | E{x := ε(y, t)} | νx.E

That is, an environment is a context consisting of a single hole followed by a sequence of (immutable and encapsulated) definitions, inside a sequence of name hidings. An environment context is a head context such that if Γ; S ▶E : S;Δ then Γ; T ▶E : T ;Δ for any type T , so we may type E with the judgment Γ ▶ E ; Δ.
We may now define the coinduction rule, which necessarily takes a different form from the axiomatic presentation of the rest of the equational theory.
Definition 4.4 The equational theory of our calculus (=f + ) is the least congruence which contains the axioms of Table 2 and the unfolding rule, and is is closed under the following coinduction rule.
For any term Γ ▶ t : S → (T S) and environment Γ,u : S ▶ E ; x : T: if Γ ▶ νx.E [x{y := x}] =f + νv.E [y/x, v/u][(t u) v] then
E =f + {x := ε(u, t)}.
Examples
As a simple application of the coinduction rule, we show that encapsulated definition of an object which discards its state is equivalent to immutable definition.

Lemma 4.5 If x, y /∈ FV (t) then {x := ε(s, λa.λb.t{b := a})} =f +  {x := t}.
Proof. νx.x{y := x}{x := t} =f + t{y := t} =f + νv.t{v := u}{y := t}
=f + νv.((λa.λb.t{b := a}{y := t}) u) v{y := t} and so this follows directly from the coinduction rule.	□
As a slightly more involved example, we may show that a cell storing objects of product type can be macro-expressed using two cells to store each component of the product. Let y : T1 × T2 ▶ C[ ]; x : var[T1 × T2] be the environment:

νc1.νc2. {x := ⟨λa.(set(c1) a.1); (set(c2) a.2), ⟨get(c1), get(c2)⟩}{c1 := ε(y.1, cellT1 )}{c2 := ε(y.2, cellT2 )}


Proposition 4.6 C[ ] =f +  {x := ε(y, cellT1×T2 )}
Proof. We show that νx.C[x{y := x}.1 v] =f + C[y/x, v/u][λz.z] and νx.C[x{y :=
x}.2 v] =f + C[y/x, v/u][u], and may therefore apply the coinduction rule.	□
We may use state encapsulation to implement any stateful objects, not just reference cells. Typically, there may be a variety of ways to represent the internal state of such objects — e.g. a queue might be implemented using two stacks, or using an array with pointers — but hiding this state can make these implementations observably equivalent. A useful principle for proving such equivalences is to identify a term s : S → Sj which relates the input state of one definition to the output state of the other in the following sense.
Definition 4.7 Given terms t : S → T  S, t : Sj → T  Sj, and s : S → Sj, define
tR(s)tj if:

tj (s a) c =f + νb.(t a) b{c := s b}
Proposition 4.8 If tR(s)tj then {x := ε(y, t)} =f + {x := ε(s y, tj)}
Proof. νx.x{x := ε(s y, tj)}
=f + νx.νc.(tj (s y)) c{x := ε(c, tj)}
=f + νx.νc.νb.(t y) b{c := s b}{x := ε(c, tj)}
=tl νx.νb.(t y) b{x := ε(s b, tj)}.
So by the coinduction rule, {x := ε(y, t)} =f + {x := ε(s y, tj)} as required.	□

Coalgebraic Sequoidal Categories
In this section, we axiomatize the properties of a sequoidal CCC which allow us to interpret encapsulated definition in such a way that the equational theory is sound and complete. These are motivated by the construction of sequoidal CCCs of games using the final coalgebra for the sequoid, but reformulated in a way which makes sense in a sequoidal CCC without an explicit decomposition into a model of linear logic — as in the case of HO-style games. As suggested in the previous section, we will do this by taking morphisms between J(A  ) coalgebras on B and C to be certain natural transformations from   B to   C.
Definition 5.1 A sequoidal transformation σ between (objects) A and B in a se- quoidal closed category is a natural transformation σ :  A →  B such that the following diagrams commute (for each C):

C ( (  A)
C(σ
θA,C /(C¸( )  A
σ(C( )
(  A)  C
σ C
γA,C /( ¸ C)  A
σ(  C)

C (	 θB,C /(C¸( 
 γB,C /¸
	

In any sequoidal CCC we can compose a sequoidal transformation σ :  A →
 B with a morphism f ∈ C(B, JC) using the the trace operator: we define Φ(σ, f ) ∈ C(A, JC) to be the trace of:


A ⊗ B ∼ B ⊗ A f⊗A
ωC,A
J(σC )

=	−→ JC ⊗ A −→ J(C  A) −→ J(C  B)
Definition 5.2 A J(A  )-coalgebra transformation between coalgebras (B, β :
B → J(A  B)) and (C, γ : C → J(A  C)) is a sequoidal transformation σ :
  B →   C such that Φ(σ, γ)= β; J(σA): B → J(A  C).
Observe that Φ(σ1; σ2,f )= Φ(σ1, Φ(σ2,f )) and Φ(I, f )= f , and thus the J(A 
)-coalgebras and their transformations form a category. We can now define the property required for a sequoidal CCC to interpret encapsulated definition.
Definition 5.3 A sequoidal CCC is coalgebraic if, for each L-object A, the coal- gebra (JA, δ; ωA,JA : JA → J(A  JA)) is a terminal object in the category of J(A  )-coalgebras and sequoidal transformations.
In other words, for any morphism f : S → J(A  S) there is a unique sequoidal natural transformation ([f ]) from S to JA such that
Φ(([f ]), δ; ωA,JA)= f ; J([f ])A : S → J(A  JA)
The key to showing that our sequoidal CCC of games is sequoidal coalgebraic is the following observation.
Lemma 5.4 The monoidal functor  from G to GGl is fully faithful.
Proof. This follows from the observations:
The map o  : G(A, B) → Gl(o A, o B), where o is the game with a single Opponent move, is a bijection (since o  just adds a single initial move to each arena, and a pair of opening moves to each sequence in a strategy).
For any distinct linear strategies σ, σj : C A → C B there exists a (linear) strategy ρ : C → o such that σ; (ρ B) /= σj; (ρ B). (We find a minimal sequence in σ but not σj (w.lo.g.), project its odd prefixes onto C, and obtain a linear strategy ρ : C → o by adding an opening move in o.)
□
In other words, sequoidal transformations from A to B just correspond to (not generally well-opened) strategies on A ⇒ B. Moreover, for any morphisms σ : A → B and τ : B → C Φ((  σ),τ ) is the parallel composition plus hiding of σ with τ .
Proposition 5.5 The sequoidal CCC of games, (Gw, Gl, J,   ( )†) is coalgebraic.
Proof. It suffices to show that for each J(A  )-coalgebra f : S → J(A S) in Gw, there exists a unique morphism ([f ]) : S → A in G such that ([f ]); δ; ωA,JA = f ; (J(A  ([f ])).

Observe that composition with δ; ωA,JA : A → A A is a natural isomorphism φ : G( , A) → Gw( ,A A). Thus we may define ([f ]) as the ⊆-least fixed point (minimal invariant) of the map sending g : S → A to φ—1(f ; J(A  g)).	□
We now give a formal semantics of encapsulated definition in a coalgebraic se- quoidal CCC and show that it is sound and complete. Given a term Γ ▶ t : S → T  S, the morphism [[Γ ▶ t]]‡  ⟨Λ—1[[t]], πl⟩; ω[[T ]] [[S]],[[Γ]] : (J[[S]] × [[Γ ]) → [[T ]] (J[[S]] × [[Γ]]) is a coalgebra for the functor J([[T ]]  ), and therefore we may take {x := ε(y, t)} to denote the unique J([[T ]]  )-coalgebra transformation from it into δ[[T ]]; ω[[T ]],[[T ]] : J[[T ]] → J([[T ]] J[[T ]]) = [[x : T ▶ λy.{y := x}]]. Soundness of the unfolding rule follows directly from this definition.
To show that the coinduction rule is sound, we observe that we may interpret each typed environment Γ ▶ E ; Δ as a sequoidal transformation from   J [Γ]] to   J[[Δ]] (since the trace, immutable and encapsulated definition operations are all natural and commute with  and (). In particular, this agrees with the interpretation of E as a head context — i.e. [[Γ ▶ E ; Δ ][[T ]] = [[Γ; T ▶ E : T ; Δ ] at each type T .
Thus an environment Γ ▶ E ; x : T with [νx.E [x{y := x}]]] = νb.E [y/x, v/u][(t u) b] denotes a J([[T ]]  )-coalgebra transformation from [[Γ ▶ t :]]‡ to [[Γ ▶ x{y := x}]]‡ and is therefore equal to [[Γ ▶ {x := ε(u, t)}; x : T ] by the uniqueness of the terminal map. So we have shown that our equational theory is sound:
Proposition 5.6 If Γ ▶ s =f + t : T ;Δ then Γ ▶ [[Γ ▶ s : T ; Δ ] = [Γ ▶ t : T ; Δ ].
Completeness
We prove completeness of the equational theory by extending the term model defined in Section 3 with encapsulated definition, and showing that this yields a coalgebraic sequoidal CCC and thus a model of our calculus in which every term is equivalent to its denotation.
We need to show that in our term model over the extended calculus, for each type T the coalgebra λx : S.λy.x{y := x} : T → T  T is terminal in the category of J(T  )-coalgebras and their transformations. Given a J(T  )-coalgebra in Cf
— a term t : S → T  S — the family of head contexts λx.νy.[ y]{x := ε(y, t)} :
R  S → R  T is a sequoidal natural transformation.
This is a J(T  )-coalgebra transformation from t into λx : S.λy.x{y := x} by the unfolding rule: it remains to establish that this is the unique such. Any J(T )- coalgebra transformation from t into λx : S.λy.x{y := x} which is the denotation of an environment context E satisfies νx.E [x{y := x}] =f νb.E [b/a][y/x][(t a) b] by definition and is therefore equal to {x := ε(a, t)} by the coinduction rule. It therefore suffices to show that in fact every sequoidal natural transformation on our term model is the denotation of an environment context.
Lemma 5.7 For any sequoidal transformation σ : S → T there exists an environment x : S ▶E : y : T such that σR = λy.νx.E [ x : S] for each R.
Proof. By strong normalization for the simply-typed λ-calculus, x : S; R ▶ (σR[λz.

{z := x}] y): R; y : T is equivalent to a β-normal form: observe that if R is a ground type then this normal form must be an environment context x : S ▶ E ; y : T .
We now show that σR = λy.νx.E [ x : S] for every R by structural induction on
R. (Since e.g. σR1→R2 [ ] =f + λa.σR1→R2 [ ] a =f + λa.σR2 [ a] by the commutativity property of σ with →).	□
Thus we have shown that the encapsulation of a coalgebra morphism is unique up to the equational theory and hence that:
Proposition 5.8 The term model is a coalgebraic sequoidal CCC.
It is straightforward to show that Proposition 3.15 extends to terms with en- capsulated definition and hence that the equational theory of the calculus is sound and complete with respect to interpretation in a coalgebraic sequoidal CCC.
Theorem 5.9 s =f + t if and only if [[Γ ▶ s : T ; Δ]] = [[Γ ▶ t : T ; Δ ] in every coalgebraic sequoidal CCC.

References
Martin Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques L`evy. Explicit substitutions. In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, San Francisco, California, pages 31–46. ACM, 1990.
S. Abramsky, K. Honda and G. McCusker. A fully abstract games semantics for general references. In
Proceedings of LICS ’98. IEEE Press, 1998.
M. Churchill, J. Laird, and G. McCusker. Imperative programs as proofs via game semantics. In
Proceedings of twenty-sixth Symosium on Logic in Computer Science (LICS) ’11. IEEE press, 2011.
Matthias Felleisen, Daniel P. Friedman, Eugene E. Kohlbecker, and Bruce Duba. A syntactic theory of sequential control. Theoretical Computer Science, 52:205 – 207, 1987.
W. J. Gowers and J. Laird. Sequoidal categories and transfinite games: A coalgebraic approach to stateful objects in game semantics. 2017.
Bart Jacobs and Erik Poll. Coalgebras and monads in the semantics of java. Theoretical Computer Science, 291:329 –349, 2003.
L. J. Jagadeesan and R. Jagadeesan. Causality and true concurrency: A data-flow analysis of the pi-calculus. In Proceedings of AMAST ’95, 1995.
G. Janelidze and G. M. Kelly. A note on actions of a monoidal category. Theory and Applications of Categories, 9(4):61 – 91, 2001.
A. Joyal, R. Street, and D. Verity. Traced monoidal categories. Math. Proc. Camb. Phil. Soc., 119:447 – 468, 1996.
J. Laird. A categorical semantics of higher-order store. In Proceedings of CTCS ’02, number 69 in ENTCS. Elsevier, 2002.
J. Lambek and P. J. Scott. Introduction to Higher Order Categorical Logic. Number 7 in Cambridge Studies in Advanced Mathematics. Cambridge University Press, 1986.
P. B. Levy. Call-By-Push-Value. Semantic Structures in Computation. Kluwer, 2004.
J. Longley. Some programming languages suggested by game models. In Proceedings of MFPS XXV. ENTCS, 2009.
Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile processes, part i. I AND II. INFORMATION AND COMPUTATION, 100, 1989.
R. E. Møgelberg and S. Staton. Linearly-used state in models of call-by-value. In Proceedings of Fourth International Conference on Algebra and Coalgebra in Computer Science (CALCO 2011), number 6859 in Lecture Notes in Comput. Sci., pages 293–313, 2011.


E. Moggi. Computational lambda-calculus and monads. Technical Report ECS-LFCS-88-66, University of Edinburgh Department of Computer Science, 1988.
Francois Pottier. Hiding local state in direct style: a higher-order anti-frame rule. In Twenty-Third Annual IEEE Symposium on Logic In Computer Science (LICS’08), pages 331–340, June 2008.
J. Power and E. Robinson. Premonoidal categories and notions of computation. Mathematical Structures in Computer Science, 11, 1993.
J. C. Reynolds. Syntactic Control of Interference. In Conf. Record 5th ACM Symposium on Principles of Programming Languages, pages 39–46, 1978.
J. J. M. M. Rutten. Universal coalgebra: a theory of systems. Theoretical Computer Science, 249:3 – 80, 2000.
J. J. M. M. Rutten. A coinductive calculus of streams. Math. Struct. in Comp. Science, 15:93 – 147, 2005.
