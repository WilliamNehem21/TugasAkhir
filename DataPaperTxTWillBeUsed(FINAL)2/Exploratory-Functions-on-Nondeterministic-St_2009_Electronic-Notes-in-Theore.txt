

Electronic Notes in Theoretical Computer Science 249 (2009) 357–375
www.elsevier.com/locate/entcs

Exploratory Functions on Nondeterministic Strategies, up to Lower Bisimilarity 
Paul Blain Levy1 Kidane Yemane Weldemariam2
University of Birmingham, Birmingham, B15 2TT, UK


Abstract
We consider a typed lambda-calculus with no function types, only alternating sum and product types, so that closed terms represent strategies. We add nondeterminism and consider strategies up to lower (i.e. divergence-insensitive) bisimilarity. We investigate the question: when is a function on strategies definable by an open term (with sufficiently large nondeterminism)?
The answer is: when it is “exploratory”. This is a kind of iterated continuity property, coinductively defined, that is decidable in the case of a function between finite types.
In particular, any exploratory function between countably nondeterministic strategies is definable by a continuum nondeterministic term.
Keywords: strategy, lambda calculus, exploratory, nondeterminism, bisimilarity


Introduction
Functions between strategies
We consider games in which play alternates between two players, Opponent and Proponent. Such a game may be represented as a countable forest. Two examples are A, in which Opponent starts:

what¸¸
¸¸¸
¸¸
true	false

٨ supported by EPSRC grants EP/C536827/1 and EP/E056091/1
1 Email: pbl@cs.bham.ac.uk
2 Email: kidane.yemane@gmail.com

1571-0661 Crown Copyright © 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.098

and B, in which Proponent starts:
go

what¸¸
¸¸¸
¸¸
true	false
A deterministic strategy for a game is a rule telling Proponent how to play, no matter how Opponent plays. Proponent always has the option of simply diverging, and play may continue forever (we are not considering any notion of winning). The set of deterministic strategies for a game form a domain. For example, writing B d=ef {true, false}, the domains for A and B are B⊥ and (B⊥)⊥ respectively.
Suppose that f is a function from deterministic strategies for one game to those for another. Under what conditions is f definable by a program? To answer this question, we need a programming language that converts strategies into strategies. To simplify our question, we shall ignore first-order computability, i.e. we assume that each function N −→ N, even if non-computable, is provided as a constant in the language.
If the language provides parallel-or and parallel-exists operators [8], then f is definable iff it is continuous. This follows from the “universality” result of [8,9].
If the language is purely sequential, then f is definable iff it is Kahn-Plotkin sequential [3].
Let us consider next nondeterministic strategies for a game. The first problem here is that it is debatable when two nondeterministic strategies should be deemed equal. For example, under may-testing equivalence, a nondeterministic strategy can be represented as a set of finite traces. In that case, a function f is definable iff it is continuous. Another possibility is infinite trace equivalence [5].
In this paper, we equate two nondeterministic strategies when they are bisimilar; more specifically, when they are lower bisimilar, meaning that (as in may-testing
equivalence) we ignore the possibility of divergence. Under this equivalence, the set of strategies for A is PB and the set of strategies for B is PPB.
We again want to know: if f is a function mapping strategies to strategies, when is it definable by a program? For example, the following table describes a function PB  f  P PB that maps a strategy for A to a strategy for B.
{} '→ {{}}
{true} '→ {{true}}
{false} '→ {{false}}
{true, false} '→ {{true}, {false}}
We are going to argue that f is not definable by a program. Suppose it is definable by a term M , with a free identifier x representing the argument. Each of the four argument can be represented by an appropriate term:

diverge represents {} true represents {true} false represents {false}
true or false represents {true, false}
Now M [diverge/x] may, by making certain choices, return ⟨go,W⟩. So for any argument P , the term M [P/x] may make the same choices and return ⟨go, WP ⟩. We know that Wtrue in response to what may return true. So Wtrue or false in response to what may return true—and, by the same argument, may return false. This contradicts the last line of the table.
Is there some mathematical condition that every function defined by a nondeter- ministic program must satisfy, that f fails? The answer cannot be a monotonicity requirement, because any set of three lines of our table can be realized by a pro- gram 3 . And it is unlikely to be a continuity condition, because the sets in this example are finite.
In this paper, we show that (provided the defining program may use nondeter- minism of unrestricted cardinality) a function f on strategies is definable iff it is exploratory. This is a kind of iterated continuity condition, defined coinductively. If f applied to x plays a move and then continues as a strategy y, then that move must be obtained by exploring x to a finite degree—that much is continuity—but there must be another function g that gives y, and so forth. When the games in question are finite, as in our example, exploratoriness is a decidable property.

Outline of Paper
In Sect. 2, we define a calculus for programs that manipulate strategies; this enables us to precisely formulate the definability problem. In Sect. 3 we give a result about operational semantics, the syntactic exploration theorem, and convert this into a condition on functions, solving our problem. In Sect. 4, we modify our calculus to make it affine, in the style of [7], and adapt our results accordingly. Finally in Sect. 5 we discuss some possible future directions.
Note on cardinals We distinguish between sets and classes. If A is a class, then
P(A) is the class of subsets and P≤ℵ0 (A) the class of subsets of size ≤ ℵ0.
Acknowledgements We thank Andreas Blass and Stefan Milius for their help with cardinality questions.

3 Writing x for the argument, here are the four programs, listed in order of the omitted line.
Apply x to what. If you get a boolean b, play go and then, if asked what, play b.
Nondeterministic choice between the following.
Play go. Then, if asked what, play what on x. If you get true, then diverge, and if you get false, then play false.
Play what on x. If you get true, then play go, and then, if asked what, play true. If you get false, then diverge.
The same as (ii), but with true and false exchanged.
Play go. Then, if asked what, play what on x. If you get a boolean b, play b.



Γ ▶v V : A
Γ ▶c M : Σ	Ai	Γ, x : Ai ▶c Ni : B (∀i ∈ I)

	ˆı	 ˆı ∈ I
Γ ▶c ⟨ˆı, V ⟩ :	i∈I Ai

Γ ▶c Mi : Bi (∀i ∈ I)
	i∈I	
Γ ▶c pm M as {⟨i, x⟩.Ni}i∈I : B

Γ ▶v V :  i∈I Bi

Γ ▶v λ{i.M }
:	B
Γ ▶c V ˆı : Bˆ
ˆı ∈ I


Γ ▶c Mj : B	(∀j < α)

Γ ▶v
x : A
(x : A) ∈ Γ
Γ ▶c choose

j<αMj
(α a cardinal > 0)
: B


Fig. 1. Syntax of intuitionistic strategy calculus, with unrestricted nondeterministm
Strategy Calculus—The Intuitionistic Version
Deﬁning the Calculus
The strategy calculus is essentially a fragment of typed λ-calculus with countable sum and countable product types. This fragment does not contain function types. The sum and product constructors alternate, so there are two kinds of type: value type (representing an Opponent-first game) and computation type (representing a Proponent-first game). They are defined coinductively, so the type syntax is non- well-founded. The definition is as follows (we underline computation types):
value type A ::=  i∈I Bi
computation type B ::= Σi∈I Ai
where each set I of tags is countable (let us say: a subset of N).
A typing context Γ is a finite set of identifiers, each given a value type. We write Γ ▶v V : A to say that V is a value, and Γ ▶c M : B to say that M is a computation. The syntax is given in Fig. 1; this too is a coinductive definition, so the term syntax is non-well-founded. We write pm for pattern-match.
This calculus is intuitionistic, in the sense that weakening and contraction are admissible. In Sect. 4 we consider an affine variant, where contraction is excluded.
Because terms may include nondeterminism of arbitrary cardinality, they form a class but not a set. A term M is countably branching when all the nondeterminism cardinals appearing in M are ≤ ℵ0.
A terminal computation is one of the form ⟨ˆı, V ⟩. We inductively define a con- vergence relation M ⇓ T where M is a closed computation and T a terminal com- putation of the same type. This is presented in Fig. 2. We could also define a divergence predicate M ⇑, but this paper ignores divergence.
Proposition 2.1 Let ▶c M : B be countably branching. Then {T | M ⇓ T} is countable.
Proof. For each n ∈ N, the set of T such that M ⇓ T has a proof of height < n is countable. This is proved by induction on n. The result follows.	 




⟨ˆı, V ⟩⇓ ⟨ˆı, V ⟩

M ⇓ ⟨ˆı, V ⟩	Nˆı[V /x] ⇓ T
pm M as {⟨i, x⟩.Ni}i∈I ⇓ T
Mˆı ⇓ T λ{i.Mi}ˆı ⇓ T

Mjˆ ⇓ T

choosej<αMj ⇓ T





jˆ < α 


Fig. 2. Big-step semantics of strategy calculus
We write Γ ▶c diverge : B for some computation that does not converge to anything. Given a family of computations Γ ▶c Mi : B indexed by i ∈ I, we define Γ ▶c choosediv{Mi}i∈I : B to be to be diverge if I is empty, and otherwise to be choose {Mi(j)}j<|I|, where i is some bijection from the cardinals < |I| to I.
The closed terms of our calculus form the nodes of a labelled transition system, with transitions given by M  ˆı  V , whenever M ⇓ ⟨ˆı, V ⟩, and V  ˆı  V ˆı . We therefore use “syntactic node” as a synonym for “closed term”.
Definition 2.2 For any type A, we write Syn(A) for the class of syntactic nodes of type A, and Syn≤ℵ0 (A) for the set of countably branching syntactic nodes. We define functions 4

Syn(Σ
A ) α(Σi∈I Ai) PΣ
Syn(A )

M	'−→	{(i, V ) | M ⇓ ⟨i, V ⟩}



Syn( 

B ) α( i∈I Bi) 

Syn(B )

V	'−→	i '→ Vi 
These restrict to functions

Syn
(Σ	A ) α≤ℵ0 (Σi∈I Ai) P
Σ	Syn
(A )


Syn
(	B ) α≤ℵ0 (  i∈I Bi) 

Syn

(B )


Bisimilarity
We have seen that the syntactic nodes form a transition system. This gives a notion of similarity and bisimilarity, which we now describe in detail.
Definition 2.3 Let R be a type-indexed relation, i.e. a binary relation between the closed terms of each type. It is a lower simulation when
V R V ' : i∈I Bi and ˆı ∈ I implies V ˆı R V 'ˆı : Bˆı
M R M' :	i∈I Ai and M ⇓ ⟨ˆı, V ⟩ implies that M' ⇓ ⟨ˆı, V '⟩ and V R V ' : Aˆı for some V '.

4 In the second line below, we use () for pairing to avoid confusion with the object language.

It is a lower bisimulation when both R and Rop are lower simulations. The greatest lower simulation is called lower similarity ( ), and the greatest lower bisimulation is called lower bisimilarity ( ).
Definition 2.4	(i) For a closed term M of type A, we write b(M ) for its equiva- lence class modulo lower bisimilarity.
We write [A ] for the class of semantic nodes i.e. equivalence classes of closed terms.
We write [A]]≤ℵ0 for the set of countably branching semantic nodes, i.e. equiv- alence classes that contain a countably branching term.
Remark 2.5 An equivalence class contains a countably branching term iff it con- tains a ﬁnitely branching term (one in which all the nondeterminism cardinals are finite), because choosen∈NMn can be expanded as M0 or (M1 or (··· )) up to lower bisimilarity.
The reason we use the [− ] notation is that [A ] is compositional in A. We have isomorphisms

[[Σ
A ]] β(Σi∈I Ai) PΣ

[[A ]]

b(M )	'−→	{(i, b(V )) | M ⇓ ⟨i, V ⟩}



[[ 
B ]] β( i∈I Bi) 

[[B ]]

b(V )	'−→	i '→ b(V i)
These restrict to isomorphisms

[[Σ


i∈I

Ai]]≤ℵ0
β≤ℵ0 (Σi∈I Ai) PΣ


i∈I

[[Ai]]≤ℵ0


[[ 



i∈I


Bi]]≤ℵ0

β≤ℵ0 (  i∈I Bi) 




i∈I

[[Bi]]≤ℵ0

We therefore obtain [A]] and [[A]]≤ℵ0 compositionally (up to isomorphism) in the case that A is well-founded. This extends to non-well-founded types, as we now explain.
Write types for the set of all types, and define the endofunctor F on Classtypes
by
(F Q)Σi∈I Ai = PΣi∈I QAi
(F Q) i∈I Bi =  i∈I QBi
Then (Syn(−), α) is a coalgebra for F , and ([[−]], β) is a final coalgebra. The map M '→ b(M ) on closed terms is the anamorphism, i.e. unique coalgebra morphism to the final coalgebra.

Similarly, we define the endofunctor F≤ℵ0
(F≤ℵ0 Q)Σi∈I Ai = P≤ℵ0 Σi∈I QAi
(F≤ℵ0 Q) i∈I Bi = i∈I QBi
on Settypes by

Then (Syn≤ℵ0 (−), α≤ℵ0 ) is a coalgebra for F , and ([[−]]≤ℵ0 , β≤ℵ0 ) is a final coal- gebra. The map M '→ b(M ) on countably branching closed terms is again the anamorphism.
We use the same notation for semantic nodes as for syntactic nodes.
For M ∈ [[   A ] and ˆı ∈ I and V ∈ [[A ]], we write M ⇓ ⟨ˆı, V ⟩ when (ˆı, V ) ∈
β(Σi∈I Ai)M .

For V ∈ [[ 

i∈I
B ] and ˆı ∈ I, we write V ˆı d=ef (β( 

i∈I
Bi)V )ˆı.

Lemma 2.6 There exists a function mapping each semantic node V ∈ [[A]] to a syntactic node a(V ) ∈ Syn(A), in such a way that
V ˆı ⇓ ⟨jˆ, W⟩ implies a(V )ˆı ⇓ ⟨jˆ, a(W )⟩
if V is countably branching then a(V ) is countably branching. Hence, by bisimulation, b(a(V )) = V .
Proof. Here is one such function,  defined by guarded recursion:	if V	∈
[[  i∈IΣj∈Ji Aij ] then
a(V ) = λ{i.choosediv{⟨j, a(W )⟩}V i⇓⟨j,W ⟩}


We fix such a function for the rest of the paper.

Open Terms
In order to define the operational meaning of an open term, we must first adapt our existing concepts from nodes to environments.
Definition 2.7 Let Γ be a typing context.
A syntactic environment (resp. semantic environment ) ρ maps each (x : A) ∈ Γ to a syntactic node (resp. semantic node) of type A.
We say that a syntactic or semantic environment ρ for Γ is countably branching
when ρ(x) is countably branching for each (x : A) ∈ Γ.
We write Syn(Γ) (resp. [[Γ]], Syn≤ℵ0 (Γ), [Γ]]≤ℵ0 ) for the set of syntactic (resp. semantic, countably branching syntactic, countably branching semantic) envi- ronments for Γ.
If ρ is a syntactic environment for Γ, we write b(ρ) for the semantic environment
x '→ b(ρ(x)).
Let Γ ▶ M : A be a term and ρ a syntactic environment for Γ.  We write
▶ M [ρ] : A for the closed term obtained by substituting ρ in M .
Proposition 2.8 For any term Γ ▶ M : A, the function Syn(Γ)   Sy n(A) map- ping ρ '→ M [ρ] preserves lower similarity and preserves lower bisimilarity.
Prop. 2.8 is a consequence of the following.

Lemma 2.9 For a type-indexed relation R, let id[R] be the type-indexed relation given at A by
{(M [ρ],M [ρ']) | Γ ▶ M : A, ρ, ρ' ∈ Syn(Γ) | ∀(x : A) ∈ Γ. ρ(x) R ρ'(x)}
If R is a lower simulation, then id[R] is a lower simulation.
It is easy to prove Lemma 2.9 by induction on ⇓, but it is more intuitive to deduce it from Prop. 3.8 below.
We can now speak of the meaning of an open term.
Definition 2.10 Let Γ ▶ M : A be a term.
We define the function [[Γ]] m(M) [[A ] to map b(ρ) to b(M [ρ]). This is well defined by Prop. 2.8.

We write [[Γ]] m≤ℵ0 (M ) [[A ] for the restriction of m(M ) to [[Γ]]
. Clearly, if

≤ℵ0
M is countably branching, then we have [[Γ]]

m ≤ℵ0 (M [[) ]]
≤ℵ0
.

≤ℵ0
A ≤ℵ0

Remark 2.11 Two open terms Γ ▶ M, M' : A are said to be lower applicatively bisimilar [1] when m(M ) = m(M'). Lower applicative bisimilarity is in fact a congruence, though the proof is nontrivial [2,4]. We do not use that result in this paper, but it does tell us that m(−) is a “reasonable” notion of meaning.
Remark 2.12 We can construct an isomorphism

  Σ Aij ∼= 
Σ	Aij	(1)

i∈I j∈Ji

by means of the following terms
⟨⟩∈1 ⟨i,j⟩∈Pi∈I Ji

x : LHS ▶v λ⟨⟩. choosedivi ∈ I. pm x i as ⟨j, z⟩. ⟨⟨i, j⟩, z⟩ : RHS

y : RHS ▶v	λi. pm y⟨⟩ as ,⎨ ⟨⟨i, j⟩, w⟩.	⟨j, y⟩
, ⟨⟨i' /= i, j⟩, w⟩. diverge


: LHS

which are inverse up to lower applicative bisimilarity, and hence up to may-testing, cf. [7]. However, up to divergence-sensitive equivalences, such as must testing or convex applicative bisimilarity, (1) is not valid. Moreover, it is invalid in the deter- ministic setting.
Our goal is to solve the following:
f	 
Problem 2.13 Characterize those functions [[Γ]]≤ℵ0	[[A]] that are definable
i.e. such that f = m≤ℵ0 (M ) for some term Γ ▶ M : A.
Note that M may use unrestricted nondeterminism. The following task is also interesting, but remains unsolved:

Problem 2.14 Characterize those functions [[Γ]]≤ℵ0
by a countably branching term.
f [[A ]]≤ℵ
that are deﬁnable

Although “characterize” is not precisely defined, there is one concrete require- ment we impose. If we restrict Problems 2.13–2.14 to the case where A and all the types in Γ are finite, then the two problems coincide (this will be proved later—see end of Sect. 3.4). In this case, we require a decision procedure for the definability of f , and in the case that f is definable, an algorithm that yields a (finitely branching) defining term.
Exploration
Developed Contexts
To solve Problem 2.13, it is helpful to generalize the notion of typing context to include information about how bindings were made. Here is an example of such a “developed” context:

.... x ¸¸¸¸¸ '

i→j.. i→j'
...	J 
i →j
¸¸¸¸¸
i''→j'''
J 

y . s	z	zw	v

The context contains identifiers x, y, z, u, v, and any environment ρ for this context is required to satisfy ρ(x)i ⇓ ⟨j, ρ(y)⟩ etc.
Definition 3.1	(i) An edge over a typing context Γ0 is a quadruple ⟨x, i, j, y⟩
where (x :  i∈IΣj∈Ji Aij) ∈ Γ0 and i ∈ I and j ∈ Ji and (y : Aij) ∈ Γ0.
A developed context Γ consists of a typing context Γ0 equipped with a set R of edges over Γ0 that is forest-structured, i.e.
for each y ∈ Γ0 there is at most x, i,j such that ⟨x, i, j, y⟩ ∈ R—if there is none, y is a root
(acyclicity) there is no sequence
x0, i0, j0,..., xn−1, in−1, jn−1, xn = x0
such that n > 0 and ⟨xr, i, j, yr+1⟩∈ R for each r < n.
A syntactic environment (resp. semantic environment) ρ for a developed con- text Γ maps each identifier (x : A) ∈ Γ to a syntactic node (resp. semantic node) of type A in such a way that ρ(x)i ⇓ ⟨j, ρ(y)⟩ for each edge ⟨x, i, j, y⟩ of Γ. Def. 2.7 (ii)–(iv) can be applied to developed contexts.
A renaming Γ  θ  Γ' of developed contexts maps each identifier in Γ to an identifier of the same type in Γ' such that roots are mapped to roots and edges to edges. If ρ is a (syntactic or semantic) environment for Γ', we write θ◦ρ for the environment for Γ given by x '→ ρ(θ(x)).
An ordinary typing context can be seen as a developed context where all the identifiers are roots. Conversely, we can obtain a typing context Γ0 from a developed context Γ by ignoring the edges, and we write Γ ▶ M : A as shorthand for Γ0 ▶ M : A.

We note that, if ρ is a semantic environment for a developed context Γ, then a(ρ), defined as x '→ a(ρ(x)), is a syntactic environment for Γ and b(a(ρ)) = ρ. Furthermore a(ρ) is countably branching if ρ is.
We can generalize Problem 2.13 to the case that Γ is a developed function. The following terminology is useful.
Definition 3.2 A developed function into a type A is a developed context Γ to- gether with a function [[Γ]]≤ℵ f  [[A ]] .
Thus our task is to identify when a developed function ⟨Γ,f⟩ into A is definable by some term Γ ▶ M : A.

Exploration of a Syntactic Environment
Suppose we have a term Γ ▶ M : A and a syntactic environment ρ for Γ. Any evaluation M [ρ] ⇓ ⟨ˆı, V ⟩ must “explore” ρ to a certain finite extent, and our aim is to make this precise (Prop. 3.8 below). The exploration of each value ρ(x) is tracked as follows.
Definition 3.3 Let V be a (syntactic or semantic) node of value type A.
A node trace s from V is a finite sequence of tags and nodes
i0, j0, V1,..., in−1, jn−1, Vn where V0i0 ⇓ ⟨j0, V1⟩··· Vn−1in−1 ⇓ ⟨jn−1, Vn⟩
writing V0 d=ef V . The end-node of s is Vn and the end-type is the type of Vn.
An exploration tree from V is a finite set of node traces that is prefix-closed and contains ε (the empty sequence).
Definition 3.4 Let ρ be a (syntactic or semantic) environment for a developed context Γ.
An exploration T of ρ associates to each (x : A) ∈ Γ an exploration tree T (x) for ρ(x).
Given an exploration T , we define ΓT to be the developed context consisting of identifiers yx,s for each x ∈ Γ and s ∈ T (x). The type of yx,s is the end-type of s. The edges are as follows.
yx,ε is a root of ΓT , for each root x of Γ
⟨yx,ε, i, j, yx',ε⟩ is an edge for ΓT , for each edge ⟨x, i, j, x'⟩ of Γ
⟨yx,s, i, j, yx,s+(i,j,n)⟩ is an edge for ΓT , for each x ∈ Γ and s + (i, j, n) ∈ T (x)
We define the renaming Γ  ψT  Γ  mapping x to yx,ε.
If ζ is a syntactic (resp. semantic) environment for Γ then a T-descendant of
ζ is a syntactic (resp. semantic) environment ξ of ΓT such that ψ◦ ξ = ζ.
The principal T -descendant ηT of ρ maps yx,s to the end-node of s. We see that countability is preserved by descent.

Lemma 3.5 Let T be an exploration of a (syntactic or semantic) environment ρ
for a developed context Γ.
If ζ is a countably branching (syntactic or semantic) environment for Γ, then every T-descendant of ζ is countably branching.
If ξ is a countably branching (syntactic or semantic) environment for ΓT , then
ξ is a T-descendant of some countably branching environment ζ for Γ.
Proof.
For each yx,s ∈ ΓT , we prove that ζyx,s is countably branching, by induction on s.
Take ζ d=ef ψ◦ ξ.
 
Remark 3.6 Although Lemma 3.5(ii), which is used in the proof of Lemma 3.15, is trivial, we state it explicitly for the sake of Sect. 4, where the analogous result is harder to prove.
We introduce some notation for explorations, which we shall use in the proof of Prop. 3.8 below.
Definition 3.7 Let Γ be a developed context. Let ρ be a (syntactic or semantic) environment for Γ.
We write ερ for the exploration of ρ that maps (x : A) ∈ Γ to {ε}.
Let T be an exploration of ρ and T ' an exploration of ηT (as an environment for ΓT ).  We define T + T ' to be the exploration of ρ mapping (x : A) ∈

'	'	'
φT,T' 

Γ to {s + s | s ∈ T (x),s ∈ T (yx,s)}. Then we write ΓT	ΓT +T '  for the
θT,T' 
inclusion renaming, and (ΓT )T '	ΓT +T ' for the renaming yyx,s,s' '→ yx,s+s' .

So we have a commutative diagram of renamings

Γ 	ψT	 Γ 


ρ ¸,	 ηT

sss
,,	 ,,,

ψT +T'
sss
J ,cφsT,T '
ψT'
J 
   
_ ,	_

ΓT +T ' ¸,  (ΓT )T '
T,T
ηT +T ' 	 ηT '

These act on the special environments as shown on the right.
If T is an exploration of ρ, and (x : A) ∈ Γ, and s is a node-trace of T (x) with end-node V and Vi ⇓ ⟨j, W⟩, then we define T (x,s + (i, j, W )) to be the exploration on ρ given by
,⎨ x '→ T (x) ∪ {s + (i, j, W )}
, y '→ T (y)	if y /= x

We now give the key operational result.


Γ; M ; ρ ↓ ˆı; T0; W	ΓT ; N [ψT , W/x]; ηT ↓ jˆ; T '; W'
ˆı	1
Γ; ⟨ˆı, V ⟩; ρ ↓ ˆı; ϵρ; V [ψєρ ]	Γ; pm M as {⟨i, x⟩. Ni}i∈I; ρ ↓ jˆ; T0 + T ; W [θT,T ' ]
'	'
Γ; Mˆı; ρ ↓ jˆ; T ; W		 ρ(x)ˆı ⇓ ⟨jˆ, V ⟩

Γ; λ{i. Mi}i∈I ˆı; ρ ↓ jˆ; T ; W
Γ; x ˆı; ρ ↓ jˆ; ερ(x, (ˆı, jˆ, V )); yx,(jˆ,ˆı,V )

Γ; Mjˆ; ρ ↓ jˆ; T ; W
Γ; choose j<α Mj; ρ ↓ jˆ; T ; W
jˆ < α 



Fig. 3. Inductive definition of “causal convergence” relation ↓, used in proof of Prop. 3.8

Proposition 3.8 (Syntactic exploration) Let Γ be a developed 5 context, let Γ ▶c M :  i∈I Ai be a term and let ρ be a syntactic environment for Γ. If M [ρ] ⇓ ⟨ˆı, V ⟩ then there exists
an exploration T of ρ
a value ΓT ▶v W : Aˆı
such that
V = W [ηT ]
for each syntactic environment ζ of Γ and each T-descendant ξ of ζ, we have
M [ζ] ⇓ ⟨ˆı, W [ξ]⟩.
If M and ρ are countably branching, then so is W.
Proof. We define a predicate Γ; M ; ρ ↓ ˆı; T ; W where
Γ ▶c M : Σi∈I Ai and ρ is a syntactic environment for Γ
ˆı ∈ I and T is an exploration of ρ and ΓT ▶v W : Aˆı
This is called “causal convergence” because it indicates the exploration that caused a convergence to happen. It is defined inductively in Fig. 3. Note that if Γ; M ; ρ ↓ ˆı; T ; W , and M and ρ are both countably branching, then so is W .
We prove by induction that if Γ ▶c M :  i∈I Ai and ρ is a syntactic environment for Γ and M [ρ] ⇓ ⟨ˆı, V ⟩ then there exists an exploration T of ρ and a value ΓT ▶v
W : Aˆı such that Γ; M ; ρ ↓ ˆı; T ; W and W [ηT ] = V . The inductive step depends on the form of M —we omit details.
Next, we prove by induction that if Γ; M ; ρ ↓ ˆı; T ; W , then, for any syntactic environment ζ of Γ and any T -descendant ξ of ζ, we have M [ζ] ⇓ ⟨ˆı, W [ξ]⟩—this will complete our proof. The inductive step depends on the form of M —we omit details.	 

5 The result is no weaker if we say that Γ is a typing context, but the “developed” formulation is more convenient for the sequel.

Exploration of a Semantic Environment
In Prop. 3.10 below, we present properties of developed functions that are definable, both into a value type and into a computation type. Each of these requires a definition, formulated as follows.
Definition 3.9  (i) Let ⟨Γ,f⟩ be a developed function into  i∈I Bi. For ˆı ∈ I, we

write [[Γ]]

≤ℵ0
fˆı	 B ˆ to be ρ '→ f (ρ)ˆı.

Let p = ⟨Γ,f⟩ be a developed function into	i∈I Ai.
A convergence datum q = ⟨ρ, ˆı, V ⟩ for p consists of a semantic environment
ρ ∈ [[Γ]]≤ℵ0 , a tag ˆı ∈ I and an element V ∈ [[Aˆı ] such that f (ρ) ⇓ ⟨ˆı, V ⟩.
A cause of a convergence datum q = ⟨ρ, ˆı, V ⟩ for p consists of an exploration

T of ρ and a function [[ΓT ]]≤ℵ0
g(ηT ) = b
g [[A ˆı]] such that

for any ζ ∈ [[Γ]]≤ℵ0 and any T -descendant ξ of ζ, we have f (ζ) ⇓ ⟨ˆı, g(ξ)⟩.
Proposition 3.10	(i) Let ⟨Γ,f⟩ be a developed function into  i∈I Bi that is de- ﬁnable. Then for every ˆı ∈ I the developed function ⟨Γ, fˆı⟩ into Bˆı is deﬁnable.
(ii) Let p = ⟨Γ,f⟩ be a developed function into i∈I Ai that is deﬁnable. Then every convergence datum q = ⟨ρ, ˆı, V ⟩ of p has a cause ⟨T, g⟩ such that the developed function ⟨ΓT , g⟩ into Aˆı is deﬁnable.
Proof.
If ⟨Γ,f⟩ is defined by M , then ⟨Γ, fˆı⟩ is defined by Mˆı.
Let p be defined by M , and let q = ⟨ρ, ˆı, V ⟩ be a convergence datum of p. Then

b(M [a(ρ)]) = m(M )b(a(ρ)) = m(M )ρ ⇓ ⟨ˆı, V ⟩
so there is a syntactic node U ∈ Syn(Aˆı) such that b(U ) = V and M [a(ρ)] ⇓
⟨ˆı, U⟩.
We then obtain T and W following Prop. 3.8. We obtain an exploration
b(T ) of ρ mapping x '→ {b(s) | s ∈ T}. Here b(s) is defined by replacing each

syntactic node V in s with b(V ). We define a renaming ΓT
  γT  Γb (T ) mapping

yx,s '→ yx,b(s), giving a commutative diagram of renamings


Γ ¸ ψT  Γ 

ρ ¸,¸¸, b(ηT )

¸¸¸
¸¸	γT
¸¸¸	,,
¸¸

ψb(T )
¸zJ 
¸c _

Γb(T )	ηb(T )

These act on the special environments as shown on the right. Let g be the composite

[[Γb(T )]]≤ℵ0
◦
T	 [[Γ T ]]≤ℵ
 m(W ) [[A ˆı]]≤ℵ

It is then easily checked that ⟨b(T ), g⟩ is a cause of q.



Prop. 3.10 indicate the following coinductive concept.
Definition 3.11 Let E be a predicate on developed functions. We define another predicate ΦE on developed functions as follows.
p = ⟨Γ,f⟩ into i∈I Bi satisfies ΦE when ⟨Γ, fˆı⟩ into Bˆı satisfies E for each ˆı ∈ I.
p = ⟨Γ,f⟩ into Σi∈I Ai satisfies ΦE when each convergence datum q = ⟨ρ, ˆı, V ⟩
of p has a cause ⟨T, g⟩ such that ⟨ΓT , g⟩ into Aˆı satisfies E.
A postfixed point of Φ is called an exploration predicate, and the largest one is called
exploratoriness.
Proposition 3.12 Let p = ⟨Γ,f⟩ be a developed function into A. If p is deﬁnable, then it is exploratory.
Proof. By Prop. 3.10, definability is an exploration predicate.	 

As usual, the coinductive definition can be formulated in terms of a two-player (Proponent/Opponent) game, with Opponent moving first. Whenever it is Oppo- nent’s turn to play, there is a developed function into some type on the table.
If p = ⟨Γ,f⟩ into i∈I Bi is on the table, then Opponent chooses some ˆı ∈ I. Proponent replies “continue”, and the game continues with ⟨Γ, fˆı⟩ into Bˆı on the table.
If p = ⟨Γ,f⟩ into  i∈I Ai is on the table, then Opponent chooses some convergence datum q = ⟨ρ, ˆı, V ⟩ for p. Proponent replies by choosing a cause ⟨T, g⟩ of q, and the game continues with ⟨ΓT , g⟩ into Aˆı on the table.
We call this the “exploration game”. A developed function p into A is exploratory iff, beginning the game with p on the table, there exists a strategy for Proponent. (That is, a strategy enabling Proponent to keep playing forever, no matter how Opponent plays.)
The fact that exploratoriness is a fixed point of Φ means that, for well-founded types A, exploratoriness can be given by induction on A. In particular, for de- veloped functions into finite type, we immediately obtain a decision procedure for exploratoriness.

Exploratoriness Implies Deﬁnability
We next see that the converse to Prop. 3.12 is true, by exploiting the unrestricted nondeterminism in the language.
Proposition 3.13 Let p = ⟨Γ,f⟩ be a developed function into A.	If p is ex- ploratory, then it is deﬁnable.
Proof. Firstly, given an exploration T of ρ ∈ [[Γ]] and a computation ΓT ▶c M : B,

we define a computation Γ ▶c T∗M : B such that


m(T∗M ) : ζ '→	 
ξ∈Trav(T,ζ)
ξ	for any ζ ∈ [[Γ]]	(2)

where Trav(T, ζ) is the set of T -descendants of ζ. We define T∗M by induction on
T (using some choice).
def
If T = ερ, then ψT is a bijection and we define T∗M = M [ψ−1].
Otherwise T = T '(x, s(i, j, V )) where T ' is smaller than T , and we define T∗M
to be

'∗ ,
T	⎝pm yx,s'ˆı as
,⎨ ⟨jˆ, yx,s⟩.	M	⎞
, ⟨j /= jˆ, y⟩. diverge ⎠

which satisfies (2) by

m(T∗M )ζ =	 


m(M )(ξ, yx,s '→ c) =	 


m(M )ξ'

ξ∈Trav(T ',ζ) ⟨jˆ,c⟩∈(ζ(y
x,s' ))ˆı
ξ'∈Trav(T,ζ)


Secondly, by the axiom of choice, there is a function mapping each convergence datum q = ⟨ρ, ˆı, a⟩ of each exploratory developed function p = ⟨Γ,f⟩ into Σi∈I Ai
to a cause ⟨Tq, gq⟩ of q such that ⟨ΓTq , gq⟩ into Aˆı is exploratory. We then have, for
each exploratory developed function p = ⟨Γ,f⟩ into	i∈I Ai and each ζ ∈ [[Γ]]≤ℵ0 ,
f (ζ) = {⟨i, gq(ξ)⟩| q = ⟨ρ, i, a⟩∈ c(p),ξ ∈ Trav(Tq,ζ)}	(3) To prove (3), we see that ⊇ is immediate from the definition of “cause”. For ⊆, if

def
def
def
def

⟨ˆı, b⟩∈ LHS, then ⟨ˆı, b⟩∈ RHS putting ρ = ζ, i = ˆı, a = b and ξ = ηTq .
For each exploratory developed function p = ⟨Γ,f⟩ into type A, we define Γ ▶
tAp : A by guarded recursion as follows:

t i∈I Bi
def
i
⟨Γ, fi⟩

tΣ	⟨Γ,f⟩ d=ef choosediv{T∗⟨i, t ⟨Γ ,g ⟩⟩}
where c(p) is the set of convergence data of p.
We have (omitting the β isomorphisms)
m(t  i∈I Bi ⟨Γ,f⟩)ρ = λi ∈ I.m(tBi ⟨Γ, fi⟩)ρ	(4)

m(tΣi∈I Ai ⟨Γ,f⟩)ζ =	 
{⟨i, m(tAi ⟨ΓTq , gq⟩)ξ⟩}

q=⟨ρ,i,a⟩∈c(⟨Γ,f ⟩) ξ∈Trav(Tq ,ζ)
= {⟨i, m(tAi ⟨ΓTq , gq⟩)ξ⟩| q = ⟨ρ, i, a⟩∈ c(⟨Γ,f⟩),ξ ∈ Trav(Tq,ζ)}
Let R be the type-indexed relation that relates m(tA⟨Γ,f⟩)ρ to f (ρ) at type A, for each exploratory developed function p = ⟨Γ,f⟩ into A and each ρ ∈ [[Γ]]≤ℵ0 . We show that R is a bisimulation, so that it is included in the identity i.e. m(tAp)ρ = f (ρ).

Suppose x R y :  i∈I Bi.  Then x = m(t 
B p)ρ and y = f (ρ) for some

exploratory developed function	=  Γ
i∈I i
, and some
[[Γ]]	.

Then for each ˆı ∈ I equation (4) gives us

x ˆı = m(tBˆı⟨Γ, fˆı⟩)ρ R fˆı(ρ) = y ˆı

Suppose x R y : Σi∈I Ai.  Then x = m(tΣ
Ai p)ρ and y = f (ρ) for some

exploratory developed function p = ⟨Γ,f⟩ into iΣ∈I

i∈I
Ai, and some ρ ∈ [[Γ]]
≤ℵ0 .

· If x ⇓ ⟨ˆı, x'⟩, then by (5) x' = m(tA ⟨ΓT , gq⟩)ξ for some q = ⟨ρ, i, a⟩∈ c(⟨Γ,f⟩)
i	q
and ξ ∈ Trav(T ,ζ). Put y' d=ef g (ξ) giving x' R y' and by (3) y ⇓ ⟨ˆı, y'⟩.
q	q
· If y ⇓ ⟨ˆı, y'⟩ then by (3) y' = gq(ξ) for some q = ⟨ρ, i, a⟩ ∈ c(⟨Γ,f⟩) and
ξ ∈ Trav(Tq,ζ). Put x' = m(tA ⟨ΓT , gq⟩)ξ giving x' R y' and by (5) x ⇓ ⟨ˆı, x'⟩.
i	q

We are particularly interested in the following functions.
Definition 3.14 A developed function ⟨Γ,f⟩ into A is countably branching when the range of f is contained in [A]]≤ℵ . We thus have [[Γ]]≤ℵ  f [[A ]]≤ℵ .
The definition of exploratoriness is not changed if we restrict to countably branching functions, because the countable branching property is an invariant of the exploration game, in the following sense.
Lemma 3.15  (i) If p = ⟨Γ,f⟩ into  i∈I Bi is countably branching, then so is
⟨Γ, fˆı⟩ into Bˆı for each ˆı ∈ I.
(ii) If p = ⟨Γ,f⟩ into	i∈I Ai is countably branching, then so is ⟨ΓT , g⟩ into Aˆı, for each cause ⟨T, g⟩ of a convergence datum q = ⟨ρ, ˆı, V ⟩ of p.
Proof. (i) is trivial. For (ii), for ξ ∈ [[Γ]]≤ℵ0 , Lemma 3.5(ii) gives us ζ ∈ [[Γ]]≤ℵ0 such that ξ is a T -descendant of some ζ. So f (ζ) ⇓ ⟨ˆı, g(ξ)⟩, and because f (ζ) is countably branching, g(ξ) is too.	 
Let p = ⟨Γ,f⟩ be a developed function into A. We know that if p definable by a countably branching term, then p is countably branching and exploratory. One might conjecture that if p is countably branching and exploratory, then it is definable by a countably branching term. But that is not so.
Proposition 3.16 Let Γ be the context x :  {∗.	{}}, and let B be the type
Σ{∗.  {∗.Σ{∗.  {}}}}.
There are only 2ℵ0 countably branching terms Γ ▶ M : B.

There are 22ℵ0 countably branching developed functions [[Γ]]
f  [[ B ]]≤ℵ

that are exploratory.
Proof. (i) is obvious.
For (ii), we first show that the set Q of upper subsets of PN has size 22ℵ0 . Let Q' be the set of P ⊆ PN that are antichains i.e. such that A, B ∈ P and

A ⊆ B implies A = B. The upper-closure function Q'  f  Q mapping P to
{B | ∃A ∈ P.A ⊆ B} is a bijection; its inverse maps P ∈ Q to the set of minimal elements of f (P ). Finally, we define an injection PPN g  Q ' mapping P to the set {{2n | n ∈ A}∪ {2n +1 | n /∈ A}| A ∈ P}. This gives 22ℵ0 ≤ |Q'| ≤ |Q|.
For each upper set P ⊆ PN, we define a term
Γ ▶c M d=ef choose A ∈ P. ⟨∗, λ{∗.choose n ∈ A. pm (x∗) as ⟨n, y⟩. ⟨∗, λ{}⟩}⟩ : B
We note that {⟨∗, {}⟩} ∈ m(MP )(x '→ B) iff there exists A ∈ P that is disjoint from
B, i.e. (since P is upper) iff N \ B ∈ P . So we can recover P from m(MP ) via
P = {C ⊆ N | {⟨∗, {}⟩} ∈ m(MP )(x '→ N \ C)}
So P /= P' implies m(MP ) /= m(MP ' ), and the set {m(MP ) | P ∈ Q} of exploratory functions has cardinality 22ℵ0 .	 
So if p = ⟨Γ,f⟩ is a developed function into A that is countably branching and exploratory, how much nondeterminism do we require in the language to ensure that p is definable? It turns out that 2ℵ0 is a sufficient cardinal.
Definition 3.17 A term M is continuum branching when every nondeterminism cardinal in M is ≤ 2ℵ0 .
Proposition 3.18 Let p = ⟨Γ,f⟩ be a countably branching developed function into
A. If p is exploratory, then it is deﬁnable by a continuum branching term.
Proof. We note firstly that for any type A, the set [A]]≤ℵ0 has cardinality ≤ 2 ,
ℵ0

because there are 2ℵ0 countably branching terms.  Hence [[Γ]]≤ℵ
≤ 2ℵ0 , for any developed context Γ.
has cardinality

Using this fact, and Lemma 3.15, we associate to each exploratory, countably branching developed function p = ⟨Γ,f⟩ into type A a continuum branching term Γ ▶ tAp : A. This is done by guarded recursion as in the proof of Prop. 3.13, and the rest of the proof is the same.	 
It is easy to see that, if Γ and A are finite types, then the defining terms exhibited in the proof of Prop. 3.13 are well-founded and finitely branching; and the definition tells us how to obtain the term effectively from an exploratory function.
Affine Strategy Calculus
The affine strategy calculus is the same as the intuitionistic version, except that the
pm rule in Fig. 1 is replaced by the following.
Γ ▶c M : Σi∈I Ai	Γ', x : Ai ▶c Ni : B (∀i ∈ I) Γ, Γ' ▶c pm M as {⟨i, x⟩.Mi}i∈I : B
In the affine calculus, if we pattern-match x i, obtaining ⟨j, y⟩, then we can pattern- match y k but not x i'. Conceptually, the argument is a black box which we access

by playing against, and y is its current state. We cannot rewind to the earlier state
x. This understanding of affineness, closely related to process calculus, follows [7].
We now consider Problem 2.13 in the affine setting. We do not use developed contexts, as new identifiers simply replace old ones. A function into a type A is a
pair ⟨Γ,f⟩, where Γ is a typing context and [[Γ]]≤ℵ f	 A .
To describe exploration of an environment, we do not need an exploration tree for each identifier, just a single node-trace. So we replace Def. 3.4 with the following.

Definition 4.1 (cf. Def. 3.4) Let ρ be a (syntactic or semantic) environment for a typing context Γ.
An affine exploration T of ρ associates to each (x : A) ∈ Γ a node-trace from
ρ(x).
Given an affine exploration T , we define the typing context ΓT to have the same identifiers as Γ. The type of x is the end-type of T (x).
If ζ is a syntactic (resp. semantic) environment for Γ then a T-descendant of ζ is a syntactic (resp. semantic) environment ξ of ΓT such that, for each (x : A) ∈ Γ, there is some node-trace from ζ(x) to ξ(x) with the same node-erasure as T (x).
The principal T -descendant ηT of ρ maps x to the end-node of T (x). We replace Def. 3.7 with the following.
Definition 4.2 Let Γ be a typing context. Let ρ be a (syntactic or semantic) environment for Γ.
We write ερ for the affine exploration of ρ that maps (x : A) ∈ Γ to {ε}.
Let T be an affine exploration of ρ and T ' an affine exploration of ηT (as an environment for ΓT ). We define T +T' to be the affine exploration of ρ mapping (x : A) ∈ Γ to the node-trace T (x)+ T '(x). So we have a commutative diagram of renamings


Γ 	ψT	 Γ 
ρ ¸,	 ηT



ψT +T'
J 
T
ψT'
J 
,,	,,

_	_

ΓT +T '	= (ΓT )T '	ηT +T '  =
ηT '

These act on the special environments as shown on the right.
We define fˆı and convergence datum and affine cause as in Def. 3.9, replacing “developed function” with “function” and “exploration” with “affine exploration”. A predicate E on functions into types is an affine exploration predicate when it satisfies the conditions of Def. 3.11, replacing “cause” with “affine cause”. Affine exploratoriness is the greatest affine exploration predicate.
All the results of Sect. 2–3 go through with these changes. The proofs are similar, with the exception of Lemma 3.5(ii), which becomes more difficult. In the syntactic case, it suffices to prove that, for any node-trace s from V ∈ Syn(A) with end-type

B, and any W ∈ Syn≤ℵ0 (B), there is a U ∈ Syn≤ℵ0 (A) and a node-trace t from U to W with the same node-erasure as s. This is by induction on s. The semantic case is similar.

Further Work
There are several directions in which this work can be developed.
We can consider convex bisimilarity, where divergence is taken into account. In this setting, the intuitionistic calculus takes several forms, depending on whether parallel operators or McCarthy’s amb are to be included.
We can incorporate function types. Is lower applicative bisimilarity then decidable at finite type? In the deterministic setting, the answer is yes if the language is parallel, since the domain model is fully abstract [8,9], and no if the language is sequential [6]. In the nondeterministic setting, the question is open.
We can try to formulate a denotational model that equates two terms precisely when they are lower applicatively bisimilar. This requires a fixpoint theory for recursion. Our result provides a useful first step, by identifying which functions need to be included in the model.

References
Abramsky, S., The lazy λ-calculus, in: Research topics in Functional Programming, Addison Wesley, 1990 pp. 65–117.
Howe, D. J., Proving congruence of bisimulation in functional programming languages, Inf. and Comp.
124 (1996).
Kahn, G. and G. D. Plotkin, Concrete domains, Theoretical Comp. Sci. 121 (1993).
Levy, P. B., Infinitary Howe’s method, in: Proc., 8th Intl. Workshop on Coalgebraic Methods in Comp. Sci., Vienna, ENTCS 164(1), 2006.
Levy, P. B., Infinite trace equivalence, Annals of Pure & Applied Logic 151 (2008).
Loader, R., Finitary PCF is not decidable, TCS 266 (2001), pp. 341–364.
Nygaard, M. and G. Winskel, Domain theory for concurrency, TCS 316 (2004).
Plotkin, G. D., LCF considered as a programming language, Theoretical Computer Science 5 (1977),
pp. 223–255.
Streicher, T., A universality theorem for PCF with recursive types, parallel-or and exists, Mathematical Structures in Computer Science 4 (1994), pp. 111–115.
