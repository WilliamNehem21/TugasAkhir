Electronic Notes in Theoretical Computer Science 125 (2005) 103–116 
www.elsevier.com/locate/entcs


Bounded Model Generation for Isabelle/HOL

Tjark Weber1 ,2
Institut fu¨r Informatik, Technische Universita¨t Mu¨nchen Boltzmannstr. 3, D-85748 Garching b. Mu¨nchen, Germany

Abstract
A translation from higher-order logic (on top of the simply typed λ-calculus) to propositional logic is presented, such that the resulting propositional formula is satisfiable iff the HOL formula has a model of a given finite size. A standard SAT solver can then be used to search for a satisfying assignment, and such an assignment can be transformed back into a model for the HOL formula. The algorithm has been implemented in the interactive theorem prover Isabelle/HOL, where it is used to automatically generate countermodels for non-theorems.
Keywords: Higher-Order Logic, Finite Model Generation, Interactive Theorem Proving


Introduction
Interactive theorem provers have been enhanced with numerous automatic proof procedures for different application domains. However, when an auto- matic proof attempt fails, the user usually gets little information about the reasons. It may be that an additional lemma needs to be proved, that an induction hypothesis needs to be generalized, or that the formula one is try- ing to prove is not valid. In such cases an automatic tool that can refute non-theorems would be useful.
This paper presents a translation from higher-order logic to propositional logic (quantifier-free Boolean formulae) such that the propositional formula is satisfiable if and only if the HOL formula has a model of a given finite size,

1 This work was supported by the PhD program Logic in Computer Science of the German Research Foundation.
2 Email: webertj@in.tum.de



1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.10.027


i.e. involving no more than a given number of elements. A standard SAT solver can then be used to search for a satisfying assignment, and if such an assignment is found, it can easily be transformed back into a model for the HOL formula.
An algorithm that uses this translation to generate (counter-)models for HOL formulae has been implemented in the interactive theorem prover Is- abelle/HOL [15]. This algorithm is not a (semi-)decision procedure: if a for- mula does not have a model of a given size, it may still have larger or infinite models. The algorithm’s applicability is also limited by its complexity, which is non-elementary for higher-order logic. Nevertheless, formulae that occur in practice often have small models, and the usefulness of an approach similar to the one described in this paper has been confirmed in [10].
Section 2 introduces the syntax and semantics of the logic considered in this paper, a version of higher-order logic on top of the simply typed λ-calculus. The model generation algorithm, and in particular the translation into propo- sitional logic are described in Section 3. We conclude with some final remarks in Section 4.


The HOL Logic
Our translation can handle a large fragment of the logic that is underlying the HOL [9] and Isabelle/HOL theorem provers. The logic is originally based on Church’s simple theory of types [3]. In this section we present the syntax and set-theoretic semantics of the relevant fragment. A complete account of the HOL logic, including a proof system, can be found in [8].
We distinguish types and terms, intended to denote certain sets and ele- ments of sets respectively. Types σ are given by the following grammar, where α ranges over a countably infinite set TV of type variables:

σ ::= o | α | σ → σ.

Type variables stand for arbitrary non-empty sets. The type o denotes a distinguished two-element set {T, ⊥}. If σ1 and σ2 are types, then σ1 → σ2 is the function type with domain σ1 and range σ2. It denotes the set of all total functions from the set denoted by its domain to the set denoted by its range. As usual, → associates to the right, i.e. σ1 → σ2 → σ3 is short for σ1 → (σ2 → σ3).
We assume a countably infinite set V of variables.  A term tσ of type
σ is either an (explicitly typed) variable, logical constant, application, or λ-


abstraction. Hence terms are given by the following grammar:

tσ ::= xσ | cσ | (tσ'→σ tσ' )σ | (λxσ1 . tσ2 )σ1 →σ2 ,
where xσ ranges over variables, and cσ is either =⇒ o→o→o (implication) or =σ' →σ'→o (equality on σ ), usually written in infix notation. Other logical constants, including ∨o→o→o, ∧o→o→o, ¬o→o, and quantifiers of arbitrary order, can be defined as λ-terms [1]. Terms of type o are called formulae.
We now define the semantics of terms. Let tσ be a term of type σ, and let tv(tσ) ⊆ TV be the set of all type variables that occur in tσ. tv can be defined inductively with the help of an auxiliary function tv' that collects the type variables occuring in a type:
tv'(o)= ∅, tv'(α)= {α},
tv'(σ1 → σ2)= tv'(σ1) ∪ tv'(σ2),
and
tv(xσ)= tv'(σ),
tv(cσ)= tv'(σ),
'	'
tv((tσ' →σ tσ' )σ)= tv(tσ' →σ) ∪ tv(tσ' ),
tv((λxσ . tσ )σ →σ )= tv'(σ1) ∪ tv(tσ ).
Note that tv(tσ) is not necessarily contained in tv'(σ). Types σ with tv'(σ) /= ∅
and terms tσ with tv(tσ) /= ∅ are called polymorphic.
Furthermore, let fv(tσ) ⊆ V be the set of all free variables that occur in
tσ, defined as usual:
fv(xσ)= {xσ}, fv(cσ)= ∅,
'	'
fv((tσ' →σ tσ' )σ)= fv(tσ' →σ) ∪ fv(tσ' ),
fv((λxσ1 . tσ2 )σ1 →σ2 )= fv(tσ2 ) \ {xσ1 }.
It is obvious that tv(tσ) and fv(tσ) are finite.
An environment D for tσ is a function that assigns to each type variable α ∈ tv(tσ) a non-empty set D(α). The semantics of types w.r.t. this environment is formally given by
[[o]]D = {T, ⊥},
[[α]]D = D(α),
[[σ1 → σ2]]D = [[σ2]]D[[σ1 ]]D .
A variable assignment A for tσ w.r.t. an environment D maps each variable
xσ' ∈ fv(tσ) to an element A(xσ' ) of the set denoted by the type σ'. Given a


variable assignment A, a variable xσ' ∈ V , and an element d of the set denoted by σ , let A[xσ' '→ d] be the assignment that maps xσ' to d, and v /= xσ' to
A(v). Now the semantics of terms w.r.t. an environment D and an assignment
A is given by
[[xσ]]A = A(xσ),





[[ =⇒




o→o→o]]A is the function that sends


A
⎧ T, T to T T, ⊥ to ⊥ ,
⊥, T to T
⎪⎪⎩ ⊥, ⊥ to T

[[ =σ' →σ' →o ]]D is the function that sends x, y ∈ [[σ ]]D
to ⎧ T if x = y	,
⎩ ⊥ otherwise
[[(tσ' →σ tσ' )σ]]D = [[tσ' →σ]]D([[tσ' ]]D) (function application), [[(λxσ . tσ )σ →σ ]]A is the function that sends each d ∈ [[σ1]]

1	2  1	2 D
to [tσ2
D
]]A[xσ1 '→d].

Hence the semantics of a term tσ is an element of the set denoted by the type
σ, i.e. [tσ]]A ∈ [[σ]] .


Bounded Model Generation
The model generation for a HOL formula φ = to proceeds in several steps. We first fix the size of the model by choosing an environment D for φ that
contains only finite sets. Note that environments are determined uniquely up to isomorphism by the size of the sets that they assign to type variables; the names of elements are irrelevant. With a fixed finite size for every set denoted by a type variable, every type then denotes a finite set: clearly |o| = 2, and
|σ1 → σ2| = |σ2||σ1|. Our task now is to find a variable assignment A with
[[φ]]A = T. (To generate a countermodel, we can either consider чφ, or –

equivalently – search for a variable assignment A with [φ]]A
= ⊥.) At this

point one can already view bounded model generation as a generalization of satisfiability checking, where the search tree is not necessarily binary, but still finite.


Translation into Propositional Logic
The input formula φ is translated into a propositional formula that is satisfi- able if and only if such a variable assignment exists. Propositional formulae are given by the following grammar:

ϕ ::= True | False | p | чϕ | ϕ ∨ ϕ | ϕ ∧ ϕ,

where p ranges over a countably infinite set of Boolean variables. The trans- lation is by induction over terms. Although our aim is to translate a term of type o into a single propositional formula, a more complex intermediate data structure is needed to translate subterms (which may be of arbitrary type): we use trees whose leafs are labelled with propositional formulae. The con- struction of these trees is described in detail in the remainder of this section. A tree of height 1 and width m corresponds to a term whose type is a type variable (denoting a set of size m) or o (for m = 2), while an n-ary function or predicate is given by a tree of height n + 1. We will show how application and λ-abstraction can be “lifted” from the term level to this intermediate data structure.
To define the translation more precisely, several auxiliary functions are needed. The create function is invoked once for each free variable in φ, and returns a tree whose leafs are labelled with Boolean variables. (p) is a place- holder for a fresh Boolean variable, i.e. different occurrences of (p) are replaced by different Boolean variables. The height and width of the tree only depend on the type of the free variable in φ. Multiple occurrences of a free variable in φ are replaced by identical trees.
create(o)= [(p), (p)],
create(α)= [(p),... , (p)] of length |α|,
create(σ1 → σ2)= [create(σ2),... , create(σ2)] of length |σ1|.
As can be seen from these rules, we use Boolean variables in a unary, rather than in a binary fashion. This means that we need n variables to represent an element of a type of size n, rather than [log2 n| variables. However, exactly one of these variables must later be set to True (which keeps the search space for the SAT solver small due to unit propagation [21]), and our encoding allows for a relatively simple translation of application. To ensure that exactly one of the Boolean variables p1,..., pn is set to True, a propositional formula



wf[p1,...,pn] =
n
pi
i=1
n
∧
i,j=1 i/=j

(чpi ∨ чpj)


is constructed for each tree of the form [p1,... , pn] that is returned by a call to create(o) or create(α). This formula is later conjoined with the result of the translation.
TT and FF are trees corresponding to T and ⊥, respectively. TT = [True, False],
FF = [False, True].
The k-th unit vector of length n with entries True and False is given by uvn, and likewise UVn is the k-th unit vector of length n with entries TT and

k
FF.
k
δn = ⎧⎨ True if n = k	,

False otherwise
uvn = [δk,... , δk],
k	1	n
∆n = ⎧⎨ TT if n = k	,
FF otherwise
UVn = [∆k,... , ∆k ].
k	1	n
These unit vectors are used to build trees whose leafs are labelled with propositional constants (True/False) only, representing specific (i.e. the first, second, ...) elements of the domains under consideration. Also note that
TT = uv2, and FF = uv2.
1	2
consts(σ) returns a list of length |σ|, containing one representing tree for every element in [σ]]D. pick([x1,... , xn]) – where each xi is again a list – is an auxiliary function that returns a list containing all possible choices of one element from each list xi. For the special case x1 = ... = xn, this corresponds to all functions from an n-element set to elements of x1.
consts(o)= [TT, FF], consts(α)= [uv|α|,... , uv|α|],
1	|α|
consts(σ1 → σ2) = pick([consts(σ2),... , consts(σ2)]).
|σ1 |
The functions described so far are sufficient to define the translation for terms without application. The translation of application, however, requires further helper functions. all returns the conjunction of a list of propositional formulae. map(f, l) applies the unary function f to every element in a list
l. Likewise, treemap(f, t) applies f to every leaf in a tree t. merge(g, t1, t2) merges two trees t1 and t2 by applying a binary function g to corresponding leafs in t1 and t2. Both trees must have the same “structure”, i.e. differ at


most in the formulae that they contain (but not in their height or width).

all([ϕ1,... , ϕn]) = ϕ1 ∧ ... ∧ ϕn,
map(f, [ϕ1,... , ϕn]) = [f (ϕ1),... ,f (ϕn)],
treemap(f, [ϕ1,... , ϕn]) = [f (ϕ1),... ,f (ϕn)],
treemap(f, [t1,... , tn]) = [treemap(f, t1),... , treemap(f, tn)],
merge(g, [ϕ1,... , ϕ1 ], [ϕ2,... , ϕ2 ]) = [g(ϕ1, ϕ2),... , g(ϕ1 , ϕ2 )],
1	n	1	n	1	1	n	n
merge(g, [t1,... , t1 ], [t2,... , t2 ]) = [merge(g, t1, t2),... , merge(g, t1 , t2 )].
1	n	1	n	1  1	n  n

enum(t), for t a tree representing an element of [σ]]D, computes a list of propositional formulae [ϕ1,..., ϕ|σ|] expressing that t represents the first, ..., 
|σ|-th element of [σ]]D.

enum([ϕ1,... , ϕn]) = [ϕ1,... , ϕn],
enum([t1,... , tn]) = map(all, pick([enum(t1),... , enum(tn)])).

Functions are represented by trees of height greater than 1. Intuitively, when a function is applied to the i-th element of its domain, the result is given by the i-th subtree of the tree representing the function. apply(t, [ϕ1,... , ϕn]), where t is a tree representing a function, and ϕi is true iff the function’s argument is equal to the i-th element of the function’s domain, builds a tree whose leafs are labelled with propositional formulae that simulate the selection of the correct subtree of t.

apply([t1], [ϕ1]) = treemap((λϕ. ϕ ∧ ϕ1), t1),
apply([t1, t2,... , tn], [ϕ1, ϕ2,... , ϕn]) = merge((λϕ ϕ'.ϕ ∨ ϕ'),
apply([t1], [ϕ1]), apply([t2,... , tn], [ϕ2,... , ϕn])).

Above λ is a meta-symbol used to denote a function (as opposed to the λ that is part of the term syntax), while ∨ and ∧ are constructors of propositional formulae.
We are now ready to define the translation TD from terms to trees of propo- sitional formulae. The translation is parameterized by a partial assignment B of trees to bound variables. Initially this partial assignment is empty, and it is extended whenever the translation descends into the body of a λ-abstraction. The translation is given by the following rules:



T B(x
)= ⎧⎨ B(xσ)	if xσ ∈ dom B ,

D	σ
create(σ) otherwise




B	|σ' |
|σ' |

TD (=σ' →σ' →o)= [UV1 ,... , UV|σ' |],
B	'	B	B  '
TD ((tσ' →σ tσ' )σ) = apply(TD (tσ' →σ ), enum(TD (tσ' ))),

T B((λx
.t )
)= [T B[xσ1 '→d1](t
),... , T B[xσ1 '→d|σ1|](t
)],

D	σ1
σ2 σ1 →σ2	D
σ2	D	σ2

where [d1,... , d|σ1|] = consts(σ1).
Since φ is a term of type o, the result T ∅(φ) of the translation must be a tree of the form [T ∅(φ)T, T ∅(φ)⊥] for some propositional formulae T ∅(φ)T, T ∅(φ)⊥.
D	D	D	D
Proposition 3.1 Soundness, Completeness. Let ∗ ∈ {T, ⊥}, and let WF be the conjunction of all wf-formulae constructed during the translation. Then
[[φ]]A = ∗ for some variable assignment A if and only if WF ∧ T ∅(φ)∗ is
satisﬁable.
The theorem can be proved by generalization from formulae to terms of arbitrary type, followed by induction over the term. We omit the details.

Finding a Satisfying Assignment
Satisfiability can be tested with an off-the-shelf SAT solver. To this end trans- lations into DIMACS SAT and DIMACS CNF format [6] have been imple- mented. The translation into SAT format is trivial, whereas CNF format (supported by zChaff [14], BerkMin [7] and other state-of-the-art solvers) re- quires the Boolean formula to be in conjunctive normal form. We translate into definitional CNF [19] to avoid an exponential blowup at this stage, in- troducing auxiliary Boolean variables where necessary. A more sophisticated CNF conversion might further enhance the performance of our approach [11]. Isabelle/HOL runs on a number of different platforms, and installation should be as simple as possible. Therefore we have also implemented a naive DPLL-based [5,21] SAT solver in Isabelle. This solver is not meant to replace the external solver for serious applications, but it has proved to be efficient enough for small examples. Hence it allows users to experiment with the countermodel generation without them having to worry about the installation
of an additional tool.
If the SAT solver cannot find a satisfying assignment, the translation is repeated for a larger environment. The user can specify several termination conditions: a maximal size for sets in the environment, a limit on the number of Boolean variables to be used, a runtime limit.  The order in which we


enumerate environments guarantees that if the SAT solver is complete, a model will be found that is minimal w.r.t. the total size of its domains. Of course this is not necessarily true for incomplete (e.g. stochastic) SAT solvers.

Example Translation
Consider the formula φ = ((λxα. xα)α→α =(α→α)→(α→α)→o yα→α)o. Its only type variable is α, and its only free variable is yα→α. In an environment D with |α| = 2 (and hence |α → α| = 22 = 4), the subterms of φ are translated into the following trees:
T ∅((λxα. xα)α→α) = [[True, False], [False, True]],
T ∅(=(α→α)→(α→α)→o)= [UV4, UV4, UV4, UV4],
D	1	2	3	4
T ∅(yα→α)= [[y0, y1], [y2, y3]]
with four Boolean variables y0, y1, y2, y3. Additionally two wf-formulae are constructed, namely
wf[y0,y1] = (y0 ∨ y1) ∧ (чy0 ∨ чy1)
and
wf[y2,y3] = (y2 ∨ y3) ∧ (чy2 ∨ чy3).
Using the translation rule for application, we then obtain (Boolean formulae equivalent to)


and
T ∅(φ)T = y0 ∧ y3

T ∅(φ)⊥ = (y0 ∧ y2) ∨ (y1 ∧ y2) ∨ (y1 ∧ y3).

Hence a possible satisfying assignment for T ∅(φ)⊥∧wf[y0,y1]∧wf[y2,y3] is given by
{y0 '→ True, y1 '→ False, y2 '→ True, y3 '→ False}. Assuming [α]]D = {a0, a1}, this assignment corresponds to an interpretation of yα→α as the function that maps both a0 and a1 to a0.

Some Extensions: Sets, Hilbert’s Choice, and Datatypes
Several extensions to the logic described in Section 2 can straightforwardly be integrated into our framework. The type σ set of sets with elements from σ is isomorphic to σ → o. Set membership x ∈ P becomes predicate application P x, and set comprehension {x. P } can be translated simply as P .
Hilbert’s choice operator, ϵ, is a polymorphic constant of type (σ → o) →
σ, satisfying the axiom

φє :	(∃x. P x) =⇒ P (ϵP ).


Similarly, The, also a constant of type (σ → o) → σ, satisfies
φThe :	(The x. x = a) = a,
and arbitrary is a completely unspecified polymorphic constant. For the pur- pose of our translation TD, we can treat these logical constants just like free variables, and introduce Boolean variables that determine their interpretation. For ϵ and The, we then translate the conjunction of the original formula φ
with the relevant axiom (i.e. φє ∧ φ or φThe ∧ φ, respectively, or φє ∧ φThe ∧ φ if both ϵ and The occur in φ). Type variables in φє (or φThe ) are instantiated to match the type of ϵ (or The) in φ.
Isabelle/HOL allows the definition of inductive datatypes [2]. In general, inductive datatypes with free constructors require an infinite model. We treat these datatypes by only considering a finite fragment (e.g. natural numbers up to an upper bound, or lists up to a certain length). A detailed description of the translation of inductive datatypes will be given elsewhere. We remark that if the inductive datatype occurs only positively in the input formula, then a model found for a fragment can always be extended to an infinite model for the full datatype.
However, many important datatypes are non-recursive, and for these, the situation is simpler. Examples are the type σ option, which augments a given type σ by a new element, product types σ1 × σ2, and sum types σ1 + σ2. The general syntax of a non-recursive datatype definition is given by
(α1,... , αn)σ ::= C1 σ1 ... σ1  | ... | Ck σk ... σk  ,
1	m1	1	mk

where the Ci are the datatype’s constructors, the σi
specify their argument

types, and all σi
only refer to previously defined types and type variables

from α1,... , αn. Such a datatype can be interpreted in a finite model; its size

is equal to S := Σk
mi j=1
|σi|. Hence an element of this datatype can be

represented by a tree of height 1 and width S, and a datatype constructor Ci
is a function of type σi → ... → σi	→ (α1,... , αn)σ, representable by a tree
1	mi
of height mi + 1.

Some Optimizations
We briefly describe some optimizations in the implementation of the transla- tion TD. None of them affect soundness or completeness of the algorithm.
The Boolean formulae that are constructed during the translation process are simplified on the fly, using basic algebraic laws of ч, ∨, ∧, True and False.
Closed HOL formulae simply become True or False. The SAT solver is used only to search for an interpretation of free variables.


Variables of a type with size 1 can be represented by [True], using no Boolean variable at all (instead of one Boolean variable x together with a wf[x]-formula x). While this has little effect at the SAT solver level due to unit propagation, it allows a more extensive simplification of the constructed Boolean formulae. Similarly variables of a type with size 2, including variables of type o, can be represented by a tree of the form [x, чx], rather than by a tree [x0, x1] and a wf[x0,x1]-formula (x0 ∨ x1) ∧ (чx0 ∨ чx1).
More importantly, we avoid unfolding the definition of logical constants
(i.e. Trueo, Falseo, чo→o, ∧o→o→o, ∨o→o→o, ∀(σ→o)→o, ∃(σ→o)→o) as λ-terms as far as possible. Instead these constants are replaced directly by their counter- parts in propositional logic. Since every type is finite, quantifiers of arbitrary order can be replaced by a finite conjunction or disjunction.
The latter leads to a more general optimization technique, applicable also to other functions and predicates (including e.g. equality): namely special- ization of the rule for function application to particular functions. While any given function can be represented by a tree, it is often more efficient to implement a particular function’s action on its arguments, assuming these ar- guments are given as trees already, than to use the general translation rule
and apply it to the tree representing the function. For =σ→σ→o this avoids creating a tree whose size is proportional to |σ|2, and instead uses a function that operates on trees representing elements of [σ]]D, their size proportional to |σ| (or possibly to log |σ|) only.

Examples
Table 1 shows some examples of formulae for which our algorithm can auto- matically find a countermodel. Type annotations are suppressed, and func- tions in the countermodel are given by their graphs. “∃!” denotes unique existence, defined as usual:
∃!x. P x ≡ ∃x. P x ∧ (∀y. P y =⇒ y = x).

The countermodels are rather small, and were all found within a few mil- liseconds. The main purpose of these examples is to illustrate the expressive power of the underlying logic.

Conclusions and Future Work
We have presented a translation from higher-order logic to propositional for- mulae, such that the resulting propositional formula is satisfiable if and only if the HOL formula has a model of a given finite size. A working implementation


Table 1 Examples


of this translation, consisting of roughly 2,800 lines of code written in Stan- dard ML [13], is available in the Isabelle/HOL theorem prover. A standard SAT solver can be used to search for a satisfying assignment for the proposi- tional formula, and if such an assignment is found, it can be transformed into a model for the HOL formula. This allows for the automatic generation of finite countermodels for non-theorems in Isabelle/HOL. A similar translation has been discussed before [10]; the main contributions of this paper are its extension to higher-order logic and the seamless integration with a popular interactive theorem prover.
So far we have applied the technique only to relatively small examples. The applicability of the algorithm is limited by its non-elementary complexity. We believe that the algorithm can still be useful for practical purposes, since many formulae have small models. To substantiate this claim, and to further eval- uate the performance of our approach, we plan to carry out some larger case studies, possibly from the area of cryptographic protocol verification [16,17].
We also plan to incorporate further optimizations [4,18], and to extend the translation to other Isabelle/HOL constructs: most notably the full language of HOL, including type operators [8], but also axiomatic type classes [20], inductively defined sets, and recursive functions.
An orthogonal approach that would be interesting to evaluate, both in terms of performance and feasibility, is the use of an external (first-order) model generator. The necessary translation from HOL to first-order logic could be based on recent work by Meng and Paulson [12].


Acknowledgement
The author would like to thank Martin Strecker, Tobias Nipkow and the anonymous referees for their valuable comments.

References
Peter B. Andrews. An Introduction to Mathematical Logic and Type Theory: To Truth Through Proof, volume 27 of Applied Logic Series. Kluwer Academic Publishers, second edition, July 2002.
Stefan Berghofer and Markus Wenzel. Inductive datatypes in HOL - lessons learned in formal- logic engineering. In Y. Bertot, G. Dowek, A. Hirschowitz, C. Paulin, and L. Th´ery, editors, Theorem Proving in Higher Order Logics, 12th International Conference, TPHOLs’99, volume 1690 of Lecture Notes in Computer Science, pages 19–36. Springer, 1999.
Alonzo Church. A formulation of the simple theory of types. Journal of Symbolic Logic, 5:56–68, 1940.
Koen Claessen and Niklas S¨orensson. New techniques that improve MACE-style finite model finding. In CADE-19, Workshop W4, Model Computation – Principles, Algorithms, Applications, 2003.
M. Davis, G. Logemann, and D. Loveland.	A machine program for theorem proving.
Communications of the ACM, 5:394–397, 1962.
DIMACS  satisfiability  suggested  format,  1993.	Available from ftp://dimacs.rutgers.edu/pub/challenge/satisfiability/doc.
E. Goldberg and Y. Novikov. BerkMin: A fast and robust SAT solver. In Design Automation and Test in Europe (DATE), pages 142–149, 2002.
M. J. C. Gordon and T. F. Melham, editors. Introduction to HOL: a theorem proving environment for higher order logic. Cambridge University Press, 1993.
M. J. C. Gordon and A. M. Pitts. The HOL logic and system. In J. Bowen, editor, Towards Veriﬁed Systems, volume 2 of Real-Time Safety Critical Systems Series, pages 49–70. Elsevier, 1994.
Daniel Jackson. Automating first-order relational logic. In Proc. ACM SIGSOFT Conf. Foundations of Software Engineering, pages 130–139, San Diego, November 2000.
Paul Jackson and Daniel Sheridan. The optimality of a fast CNF conversion and its use with SAT. Technical Report APES-82-2004, APES Research Group, March 2004.
Jia Meng and Lawrence C. Paulson. Experiments on supporting interactive proof using resolution. In David Basin and Michael Rusinowitch, editors, Automated Reasoning – Second International Joint Conference, IJCAR 2004, volume 3097 of Lecture Notes in Artiﬁcial Intelligence, pages 372–384. Springer, 2004.
Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. The Deﬁnition of Standard ML - Revised. MIT Press, May 1997.
M. Moskewicz, C. Madigan, Y. Zhao, L. Zhang, and S. Malik. Chaff: Engineering an efficient SAT solver. In Proc. of the 38th Design Automation Conference, Las Vegas, June 2001.
Tobias Nipkow, Lawrence C. Paulson, and Markus Wenzel. Isabelle/HOL – A Proof Assistant for Higher-Order Logic, volume 2283 of Lecture Notes in Computer Science. Springer, 2002.
Lawrence C. Paulson. The inductive approach to verifying cryptographic protocols. Journal of Computer Security, 6:85–128, 1998.
Graham Steel, Alan Bundy, and Ewen Denney. Finding counterexamples to inductive conjectures and discovering security protocol attacks. AISB Journal, 1(2), 2002.
Tanel Tammet. Finite model building: improvements and comparisons. In CADE-19, Workshop W4, Model Computation – Principles, Algorithms, Applications, 2003.
G. Tseitin. On the complexity of derivation in propositional calculus. In A. Slisenko, editor,
Studies in Constructive Mathematics and Mathematical Logic, Part 2, pages 115–125, 1970.


Markus Wenzel. Type classes and overloading in higher-order logic. In Elsa L. Gunter and Amy P. Felty, editors, Theorem Proving in Higher Order Logics, 10th International Conference, TPHOLs’97, volume 1275 of Lecture Notes in Computer Science, pages 307–322. Springer, 1997.
L. Zhang and S. Malik. The quest for efficient boolean satisfiability solvers. In Andrei Voronkov, editor, Proceedings of the 8th International Conference on Computer Aided Deduction (CADE 2002), volume 2392 of Lecture Notes in Computer Science. Springer, 2002.
