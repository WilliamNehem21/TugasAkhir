Electronic Notes in Theoretical Computer Science 82 No. 2 (2003)
URL: http://www.elsevier.nl/locate/entcs/volume82.html 15 pages


On the Recognition of Algorithm Templates

Christophe Alias 1
PRiSM
U. of Versailles Saint-Quentin Versailles, France
Denis Barthou 2
PRiSM
U. of Versailles Saint-Quentin Versailles, France


Abstract
This paper deals with the problem of deciding whether a System of Affine Recurrent Equations (SARE) is an instantiation of a SARE template. A solution to this problem would be a step toward algorithm template recognition and open new perspectives in program analysis, optimization and parallelization. The problem is known to be undecidable and we show that there exists a semi-decision procedure, in which the key ingredient is the computation of transitive closures of affine relations. This is a non-effective process which has been extensively studied. We then describe the limitations of our algorithm and point to unsolved problems.
Keywords: algorithm recognition, SARE, templates, unification, preliminary ap- proach.


Introduction
Algorithm recognition is an old problem in computer science. Basically, one would like to submit a piece of code to an analyzer, and get answers like “Lines 10to 23 are an implementation of Gaussian elimination”. Such a facility would enable many important techniques:
Program optimization: if we have the necessary items in our library, we may replace lines 10to 23 by a hand optimized version, or by a sparse version, or a parallel version. If we are bold enough, we may even replace the relevant

1 Email: Christophe.Alias@prism.uvsq.fr Fax: +33/0 139 25 40 57
2 Email: Denis.Barthou@prism.uvsq.fr
◯c 2003 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


part of the code by a completely different implementation, as for instance an iterative solver.
Program comprehension and reverse engineering.
Program verification: if we know that the program specification asks for Gaussian elimination and the analyzer does not find it, we may suspect an error.
Hardware-software codesign: if we recognize in the source program a piece of code for which we have a hardware implementation (e.g. as a coprocessor or an Intellectual Property) we can remove the code and replace it by an activation of the hardware.
Simple cases of algorithm recognition have already been solved, mostly us- ing pattern matching as the basic technique. An example is reduction recog- nition, which is included in many parallelizing compilers. A reduction is the application of an associative commutative operator to a data set. It can be detected by normalizing the input program, then matching it with a set of patterns which should include the most common associative operators (addi- tion, multiplication, and, or, max, min ...). See [13] and its references. This approach has been recently extended to more complicated patterns by sev- eral researchers (see the recent book by Metzger [12] and its references). In contrast, the starting point of the algorithm recognition procedure proposed by [3,4] and [15] are systems of affine recurrences. From this normal form the method described in [4] is able to find the equivalence of two programs, modulo transformations such as variable hoisting, data expansion/shrinking, affine transformations of the iteration domain, or common sub-expression op- timizations.
All these methods recognize only algorithms that have exactly the same semantics as the code they match. Many algorithms however are better de- scribed in generic terms, abstracting away the details of implementation. For instance, Gaussian elimination is one instance of the well-known algebraic path problem (APP), as the Warshall’s transitive closure algorithm and Floyd’s shortest path algorithm are also instances of this same APP. The only dif- ference is the underlying algebraic structure. The only way to handle them by the previous methods is to consider one different pattern for each instan- tiation. Such generic algorithms are called algorithm templates and many efficient implementations of templates have been proposed. See [16] for ma- trix manipulations, [11] for graph algorithms or [17] for the APP, to name a few. Compilation of an instantiated pattern consists in compiling the code tailored by the programmer with the optimized code of the template.
The aim of this paper is to propose a method in order to perform some algorithm template recognition and to find out how the instantiation is per- formed. This important issue have never been tackled before in the framework of algorithm recognition. This preliminary work is based on the framework presented in [3]. As in most algorithm recognition methods, the first step is

to normalize the given program as much as possible. One candidate for such a normalization is conversion to a System of Affine Recurrence Equations (SARE). It has been shown that static control programs [6] can be automat- ically converted to SAREs, and such a conversion already was the first step in [13]. The next step is to design an equivalence test between SAREs and SARE templates. This is the main theme of this paper.
Section 2 introduces some essential definitions about SAREs and provides the necessary background on rewriting systems. Section 4 defines the rules in order to match a SARE template with a SARE and Section 5 build the semi-algorithm performing this unification and we conclude in Section 6.

Preliminaries
We assume the reader is familiar with term rewriting systems [2]. These preliminaries give the definitions of linearly indexed terms and of SAREs and templates used in the rest of this paper.

Terms
A signature is a set Σ of function symbols. The set T (Σ, V) of terms built from a signature Σ and a set of variables V is the smallest set containing V such that f (t1,... , tn) ∈ T (Σ, V) whenever t1,... , tn are in T (Σ, V). A substitution is a map between V and T (Σ, V). If σ is a substitution and t a term then tσ denotes the result of applying σ to t. We note Dom(σ) the set of variables substituted by σ. If two substitutions σ, σ' provide two different values to the same variable then σ ◦ σ' is equal to the error substitution, denoted ⊥. Composition with the error substitution gives the error substitution.
We consider a signature Σ consisting of functions F , of arrays A and of the Presburger arithmetic signature (Z, +). Arrays are constants indexed by affine expressions. We assume that F ∩ A = ∅. The set of affine expressions is a set of terms T ((Z, +), C) with C a set of index variables. We use an array notation X[→c] to represent the array X indexed by the vector of expressions c and small letters will denote functions of F . Terms with arrays have been introduced by [8] (called primal terms) in order to finitely represent an infinite number of terms, as it arises in divergent rewriting term systems. Although we are not concerned with divergent rewriting systems, we use them to define systems of affine recurrent equations.
In order to represent templates, we consider a set Φ of function variables, and a set Ψ of array variables, indexed by affine expressions. The set of all variables V is therefore Φ × Ψ × C. We make a difference between index vari- ables and the other variables, and ground terms denote terms from T (Σ, C). Symbols from Ψ and Φ are chosen among Greek letters.

Systems of Aﬃne Recurrence Equations
Systems of affine recurrence equations (SARE) are a convenient way to repre- sent algorithms: they can be obtained from imperative programs by reaching definition analysis [6] and already eliminate some syntactic aspects of the programs since they represent the computations with explicit dataflow infor- mation. The basic reference on SAREs is [5]. We present here the SAREs as systems of equations between ground terms and for SARE templates, equa- tions between terms.
Definition 2.1 A System of Aﬃne Recurrence Equations is a set of ground equations of T (Σ, V), called clauses, of the form:
(1)	∀i ∈ Dk : X[i]= fk(... Y [uY k(i)] .. .).
where i is a vector of C, Dk a domain of integer vectors, X, Y ∈ A, fk ∈ F and uYk is a function of C. We introduce the following definitions: free index variables in the equations are called parameters of the SARE and all arrays appearing in the SARE are called SARE variables; Domains are assumed to be union of Z-polyhedra. They can be finite sets, parametrically bounded (the domains are finite but their sizes depend on unbounded parameters), or infinite; DX denotes the union of all the sets Dk, for all k, defining the clauses of X; Functions uYk are called dependence functions and are affine w.r.t. index variables. SARE variables that do not appear in the left-hand side (lhs) of any clause are called the inputs of the SARE. The outputs are special SARE variables defined in a lhs of some clauses. Note that there can be several output variables in a SARE.
Moreover a SARE must satisfy the single assignment property, i.e. each value of X is defined uniquely, and we assume that all values of arrays which are not inputs are defined in the SARE.
The example of Fig. 1 illustrates the transformation from a program to a SARE. The output, O is set to the last element of the recurrence in Fig. 1.(b), the input is the array A and the variable s has been expanded into a one dimensional array S.



s=0;
for (i=1; i<=n; i++) s = s+a[i]*a[i];
(a)
O = S[n]
i = 0 :	S[i] = A[i] ∗ A[i],
1 ≤ i ≤ n : S[i] = S[i − 1] + A[i] ∗ A[i],
(b)

Fig. 1. (a). Sum of the squares (b). Corresponding SARE
A SARE does not describe a computation by itself. One possibility is to build a schedule, i.e. a function giving the date θ(X, i) at which each SARE variable X[i] must be evaluated. A schedule must satisfy the following causal- ity constraint, stating that X[i] cannot be computed before the computation


O = T [n],
i =0:	T [i]= ψ[i],
1 ≤ i ≤ n : T [i]= ϕ(T [i − 1], ψ[i]),
Fig. 2. Template of a reduction
of the array variables appearing in the rhs:
∀i ∈ Dk : θ(X, i) ≥ θ(Y, uYk(i)) + 1
for all dependences in the SARE. If the domains are bounded, a schedule exists iff the given SARE has no dependence cycle. The scheduling problem for parametrically bounded SAREs is undecidable [14]. However, the existence of affine schedules for SAREs is decidable [7]. Note that in general, these schedules have a parametric latency. We only consider in this paper SAREs with a schedule.
A SARE template has the same definition as a SARE, except that in the definition of the clauses, fk is in F ∪ Φ and Y is in A∪ Ψ.
We can assume, without loss of generality, that equations contains at most
one functional variable.
Matching Problem
Consider two scheduled SAREs S and S', with S a template. Suppose that we are given a bijection between the output variables of the two SAREs and a mapping between input variables. These pairings must have the property that corresponding variables have the same domain.
We define the matching problem between S and S' as follows:
Definition 3.1 The template S matches the SARE S' w.r.t. a pair of output variables if there exists a substitution of the variables of S such that the outputs evaluate to the same values provided the inputs are equal.
For example, the template of Figure 2 matches the SARE of Figure 1 with the substitution: [ϕ '→ λxy.x + y, ψi '→ A[i] ∗ A[i] (0 ≤ i ≤ n)] , when n ≥ 1. This problem depends clearly on the underlying algebra associated to Σ.
It is clear, however, that equivalence in the Herbrand universe implies equiv- alence in all conforming algebras. We only consider in this paper equivalence in the initial algebra. The word problem between two SAREs has been proved undecidable in [4], therefore the matching problem, which is at least as difficult as the equivalence problem, is also undecidable.
Matching procedure
This matching procedure provides the rules in order to match a template with a SARE. This boils down to a simultaneous computation of both SARE

and template outputs, finding out the substitutions for the variables. We will show that this procedure is correct and complete. However, it may take a parametric number of steps to terminate. The next section proposes to address this termination problem by the construction of an automaton.
Matching clauses
We call context a boolean expression, conjunction of affine relations on index variables.
Consider a SARE on terms of 7 (Σ) and a template 7 (Σ, V).
Definition 4.1 A matching clause is either:

a triplet σ, R : t =?
t' where σ is a substitution, R a context and t =?
t' an

equation between terms of 7 (Σ, V) and 7 (Σ);
⊥, the failure matching clause;
or TC, the success matching clause, where C is a set of couples (σ, R) of substitutions σ with their context R.
⊥ and TC are called solved forms. ⊥ means that the SARE and template are not equivalent and have no unifier. TC means that the SARE and template have the set of unifiers given in C, provided their context is true. A solved form is said unreachable when its context is false.
We define the following operations on solved forms:
T{(σ,R)} V T{(σ',R')} = T{(σ,R),(σ' ,R')} T{(σ,R)} V⊥ = T{(σ,R)}
T{(σ,R)} H T{(σ',R')} = T{(σ,R),(σ' ,R')}	T{(σ,R)} H⊥ = ⊥
T{(σ,R)} Λ T{(σ',R')} = T{(σ◦σ',R∧R')}	T{(σ,R)} Λ⊥ = ⊥
Moreover, these rules extend element-wise to matching clauses with sets of unifiers and contexts. For any context R, T{(⊥,R)} = ⊥, meaning that an error substitution leads to non unifiable terms.
Let S and S' be two SAREs with outputs respectively O[→ı] and O'[→ı],
6→ı ∈ D. The initial clause associated to the SARE matching problem S =? S'
is:
Id, (→ı ∈ D): O[→ı] =? O'[→ı]

We say that two clauses σ ,R : t =? t' and σ ,R : t =? t'
are equivalent

1	1	1	1	2	2	2	2

(σ ,R : t =? t' ) ≡ (σ ,R : t =? t' ) if σ = σ
and there exists a renaming of

1	1	1	1	2	2	2	2	1	2
function variables σ : V → V such that σ(t1) =syntactic t2 and σ(t' ) =syntactic t' .
1	2
We describe here a matching procedure that takes as input the initial clause
and compute its value according to the solved forms.
Description of the rules
The matching procedure presented here is a combination of the Huet’s algo- rithm to perform syntactic term unification [9] with the algorithm in [4] to test

the equivalence of two SAREs. It solves a SARE matching problem S =? S'
by beginning with its initial clause and by repeatedly applying the following rules.

If an expression E in matching clauses is obtained from σ, R : t =?
t' by

application of one of the transition rules, we denote it by σ, R : t =?
t' ▶ E.

The subscript Q in ▶Q indicates the explicit use of the transition rule Q in the deduction step. By ▶∗ we denote the reflexive and transitive closure of ▶.
Rules Decompose, Delete and Conflict are the usual rules of unification and cope with rigid-rigid pairs.
Rules Generalize, Compute, Input Failure and Input Success are specific to the computation of the arrays with the SAREs. Rule Generalize rewrites an index expression into a new index variable, which is necessary to apply rule Compute. Rule Compute unfolds the arrays according to their definition in the SAREs, into as many values as there are clauses defining the array. Due to the property of single assignment, note that at most one of the derived contexts is true; We consider that the mapping between inputs of the SARE and the template is the identity (inputs are equal if their indices are the same).

Decompose:
σ, R : f (→t) =? f (t→')

(σ, R : t1 =? t' ) Λ ... Λ (σ, R : tn =?
t' )



Delete:
σ, R : t =? t


T{(σ,R)}



Conflict:
σ, R : f (→t) =?
⊥
g(→t')

if f /= g and R = true



Generalize:
σ, R : S[u(→ı)] =? t'
σ, R Λ (→ı' = u(→ı)) : S[→ı'] =?


t'
where →ı' is a new vector of index variables



Compute:


n k=1
σ, R : S[→ı] =?
σ, R Λ (→ı ∈ Dk
t'
) : tk = t'

if →ı is vector of index variables, and : S[→ı] = tk (→ı ∈ Dk)



Empty:
σ, false : t =? t'


T{(σ,false)}



Substitute:
σ ◦ [ϕ '→ u],R : t =? t'

if ϕ occurs in t

σ ◦ [ϕ '→ u],R : t[ϕ/u] =? t'




Project/Imitate:


n k=1
σ, R : ϕ(→t) =? f (t→')
σ ◦ [ϕ '→ λ→x.xk],R : tk =?

f (→t')

if ϕ	/∈	Ðom(σ) and no clause e ≡ σ, R :

  σ ◦ [ϕ '→ λ→x.f (H →x, ..., H →x)],R :
ϕ(→t) =? f (t→') has been

1	p
f (H1→t, ..., Hp→t) =? f (t→')
previously computed



Project 1:


n k=1
σ, R : ϕ(→t) =? f (t→')
σ ◦ [ϕ '→ λ→x.xk],R : tk =?

f (→t')

if ϕ	/∈	Ðom(σ) and a clause e  ≡  σ, R  :

ϕ(→t) =? f (→t') has been
previously computed


Project 2:
σ, R : ϕ(→t) =? I[ı'→ ]

if ϕ /∈ Ðom(σ)

n k=1
σ ◦ [ϕ '→ λ→x.xk],R : tk =?
I[→ı']


σ, R : ψ =? t'

Input Variable:
	→ı	
T{(σ◦[(ψ→ı'→t',R)],R)}



Input Success:
σ, R : I[→ı] =?
T{(σ,R)}
I[→ı']
if R Λ (→ı = →ı') = true



Input Failure:
σ, R : I[→ı] =?
⊥
I[→ı']
if R Λ (→ı /= →ı') = true


Rules Project/Imitate, Project, and Substitute are the same as in Huet’s algorithm and find unifiers. To prevent from infinite branches, Imitation is not applied if this would lead to a matching clause equivalent to a matching clause previously computed (in this case, we apply Project1). Rule Project 2 performs projection, since inputs cannot be computed nor imitated.

Soundness and Completeness
Consider a SARE S and a template S'. Then the following theorem proves the soundness and completeness of the procedure.
Theorem 4.2 The instantiation of S' with substitution σ is equivalent to S

iff Id, i ∈ D : O[i] =?
O'[i] ▶∗ TC with (σ, true) ∈ C.

Proof. Only if part: This part corresponds to the soundness of the procedure.

We show by induction on the length of derivation n that σ, R : t =?
t' ▶n TC


implies that for any σ in C, t and t' have the same value in the context R
with substitution σ. All rules producing directly a solved form are clearly

correct. For Compute, suppose that σ, R ∩ Dk
: tk =
t' ▶n−1 TC
and that

for any σk ∈ Ck, tk has the same value as t' in the context R ∩ Dk with the
substitution σk; as S[→ı] = tk when i ∈ Dk, then S[→ı] is equal to t' with the substitution σk and in the context R ∩ Dk. According to the computation on

solved forms, this implies that the hypothesis is true for σ, R : S[→ı] =?
t' and

the rule is correct. Likewise, Decompose and Generalize are correct. Moreover, the correction of Project/Imitate, Project1, Project2 and Substitute have been shown by Huet [9]. Therefore, for any n, if σ, R : t = t' ▶n TC, then t and t' are equal with any substitution σ in C. The conclusion follows by applying this result to the initial clause.
If part: This part corresponds to the completeness of the procedure. As- sume an instantiation of the template with the substitution σ is equivalent to the SARE. Rules Decompose, Delete, Conflict and Empty are complete for the same reasons as in a usual unification setting. Compute corresponds to a rewrite step for S and is complete and Generalize is just an index variable renaming (the value of the rhs does not change for these two rules). The completeness of the rules modifying the substitution are complete as well, due to Huet’s algorithm, provided that rule Project1 is never applied. Indeed, this corresponds to the possible substitutions that are not found by Rule Imitate. If the same equation appears in a previous step of the rewriting, modulo a

renaming of the variables, then one of the H'
of a previous application of the

rule is applied to a term containing f and Hk, which is defined likewise. Thus
f is a symbol repeated in the final substitution.	✷

Semi-algorithm for matching SARE templates
The matching procedure unfolds the recurrences defined by the SARE, thus may take a parametric number of steps. The idea of this semi-algorithm, following the approach of [4], is to implement the procedure with an automaton and analyze the automaton, without executing it, in order to construct the set of unifiers. The automaton, a Memory State Automaton (MSA) is described below.

Memory State Automata
Deﬁnition
The state of an MSA has two parts: an element of a finite set and a vector of integers. The vector associated to state p is denoted vp and the full state is
⟨p, vp⟩. The dimension of vp is determined by p and is noted np.
A transition in an MSA has three elements: a start state, p, an arrival state q, and a firing relation Fpq in Nnp × Nnq . A transition from ⟨p, vp⟩ to
⟨q, vq⟩ can occur only if ⟨vp, vq⟩∈ Fpq. There is an edge from p to q in an MSA

iff Fpq /= ∅.
Let ⟨p0, vp0 ⟩ be the initial state of the automaton. A state ⟨p, vp⟩ is reach- able iff there exists a finite sequence of transitions from the initial state to
⟨p, vp⟩:
∃p1,... , pn, vp1 ,... , vpn : (pn = p Λ ⟨vpi−1 , vpi⟩∈ Fpi−1,pi ).
The reachable set of p, noted Ap, is the set of vectors vp such that ⟨p, vp⟩
is reachable from the initial state.

Computing the Reachability Relation
One method for computing the reachability relation consists of characteriz- ing all possible paths in the MSA, then computing the relation associated to each path and “summing” the results. This can be done by associating a letter from a new alphabet to each edge of the MSA. This results in a finite state automaton on the given alphabet. Familiar algorithms [1] allow one to associate to each state a regular expression representing all paths from the initial state to the current state. To obtain the reachability relation from such a regular expression, replace each letter by the corresponding firing relation, concatenation by relation composition, alternation by union and Kleene star by transitive closure. The reachable set is obtained by composing the result with the reachable set of the initial state.


Construction of the matching MSA
Let us consider a SARE matching problem S =?

S'. We assume the index

variables of the left SARE will be denoted →ı, of the right →ı'.


States
Each state of our matching MSA has two part: a clause σ : t =?
t' with σ a

substitution, and a vector of integers vp, which is the concatenation of →ı and
→ı'.
The initial state is Id : O[→ı] =? O'[→ı'], where O and O' are corresponding
outputs of S and S'. Its reachable set is {⟨→ı, →ı'⟩|→ı = →ı'}.
The ﬁnal states are either:
T{(σ,E)}, where σ is a substitution, and E is a context i.e. conditions on parameters for which σ is valid ;
⊥.

Transitions
In order to make the correspondence between automaton and rewriting rules, the firing relations will correspond to the relations between the index variables defined by the contexts.



We describe thereafter the main transitions:
Decompose From a state with label σ : f (→t(→ı)) =?

f (→t'(→ı')) starts a transition

to each state σ : tk
(→ı) =?
t' (→ı'), with the firing relation Id : {→ı → →ı, →ı' → →ı'}.

All these transitions constitute an and -branching.
Generalize From a state with label σ : X[u(→ı)] =?

t' starts a transition to

state σ : X[→ı] =? t', with the firing relation: {→ı → u(→ı), →ı' → →ı'}, as seen in

section 4. There is a similar rule for the rhs.
Compute From a state with label σ : X[→ı] =?
t' starts an transition to each

state σ : t (→ı) =? t', with the firing relation: {→ı → →ı, →ı' → →ı', →ı ∈ D }. All
k
these transitions constitute an H-branching. There is a similar rule for the rhs.
Huet’s rules produce an or -branching between each Project and Imitate. The firing relation is Id since they do not modify the index variables.
Input Variable From a state with label: σ : ψ→ı = t' starts a transition to
T{(σ◦[(ψ→ı '→t',E)],E)}. Firing relation is Id. E will be computed during the MSA analysis.
Input Failure/Input Success From a state with label: σ : I[→ı] =? I[→ı'] starts
a transition to T{(σ,E)} with the firing relation {→ı → →ı, →ı' → →ı',→ı = →ı'}, and
a transition to ⊥ with firing relation {→ı → →ı, →ı' → →ı',→ı /= →ı'}. E will be computed during the MSA analysis.
Let us prove that the MSA defined has a finite number of states:



Proposition 5.1 Let S =?
S' be a SARE matching problem, with S a template

and S' a SARE and A be its corresponding MSA. The number of states of A
is ﬁnite.



Proof. States of the automaton are of the form σ : t =?
t'. t' is one of the pos-

sible subterms of S', which are in finite number. t is either a subterm of S, or a function variable which takes subterms of S as arguments, or an array variable which has index variables as arguments. The number of function variables ap- pearing in the template is finite. Assume there exists a parametric number of new function variables. Then Imitate is applied a parametric number of times. Because Imitate modifies the current substitution σ, these applications can
only appear in a parametric length branch. Let ϕ (→t ) =? t', 1 ≤ i ≤ p denote
i  i	i
them. The restriction of Imitate rule ensures that ϕ (→t ) =? t' /≡ ϕ (→t ) =? t' ,
i  i	i	j  j	j

if i /= j. This entails that →ti /= →tj, or t'
/= t' . Consequently, we can find a

parametric number of distinct sub-terms of S (or S'). This would lead to a contradiction. Thus, function variables are in finite number.	✷

Analysis of the matching MSA
We have now to analyze the matching MSA in order to decide whether the SARE is an instantiation of the template, and to find out the set of unifiers. This can be done by the following algorithm:
Algorithm 1 Match

IN	: A SARE matching problem S =?
S'.

OUT	: A set {(σ ,c ),... , (σ ,c )} where σ
is an uniﬁer of S =?
S',

1	1	n	n	i
and ci is a constraint on parameters for which σi is valid.

Compute the MSA associate to S =? S' by the method describe above ;
Compute reachability set E of each node, then ﬁx Input Variable and Input Success nodes ;
For each Input Variable node : If E(→ı, →ı'1), (→ı, →ı'2) ∈ E with →ı'1 /= →ı'2 then replace node by ⊥ ;
Delete unaccessible nodes i.e. nodes whose reachability set is empty ;
Collapse cycles into one node ;
Transform the obtained DAG into a tree by duplicating all nodes x such that Eu, v, w nodes verifying u →∗ v →∗ x and u →∗ w →∗ x, v /= w. We have now a Λ,V,H-tree, where each leaf is either T{(σ,E)} or ⊥ ;
Compute the set of uniﬁers by recursively applying rules on Λ, V and H
described in section 4, up to the root of the tree ; 
If we obtain TRes then return Res, else return ∅.
Step (ii) is correct because the reachability set gives us all possible values for →ı and →ı' in a state, corresponding to the values satisfying the context in the matching procedure. Step (iii) eliminates ambiguity in the Input Variable definition. Step (iv) corresponds to the application of the Empty rule. Step
(v) can be applied, because reachability sets were already computed. One can notice that the MSA has the same transitions than the matching procedure, with the same context in firing relations. So it computes the same set of unifiers, which is correct (see correction proof in section 4). This justifies steps (vii) and (viii).
It may seem at first glance that the algorithm completely solves the match- ing problem. This is not the case, because the construction of the transitive closure of a relation is not an effective procedure [10]. So the algorithm works only when transitive closures are computable.

An Example
Let us apply our algorithm to the example of reduction presented in prelimi- naries. We obtain the following MSA :






O = O'




i =0 
?
T [n] = S[n]
i = n i' = n


i /=0 

?	'

i' =0 
T [i] = S[i ]





ϕ'→λxy.x





ϕ'→λxy.y
?
ϕ(T [i − 1], ψi) =
+(S[i' − 1], A[i'] ∗ A[i'])
ϕ'→λxy.+(H1 xy,H2 xy)

?	?	'
+(H1 (T [i − 1], ψi),

T [i − 1] =
+(S[i' − 1], A[i'] ∗ A[i' ])
ψi = +(S[i − 1],
A[i'] ∗ A[i'])
?
H2 (T [i − 1], ψi)) =
+(S[i' − 1], A[i'] ∗ A[i'])

i'→i−1
?
T [i] =
subst. ϕ

?
ϕ(T [i − 1], ψi) =

?
H1 (T [i − 1], ψi) =

?
H2 (T [i − 1], ψi) =

+(S[i' − 1], A[i'] ∗ A[i' ]) i/=0 +(S[i' − 1], A[i' ] ∗ A[i'])
S[i' − 1]
'  '
A[i'] ∗ A[i' ]

i '→i −1
?
H1 (T [i − 1], ψi) =
S[i']
H2 '→λxy.x

⊥


?
i'/=0
?


H1 '→λxy.x
H1 (T [i − 1], ψi) =
A[i'] ∗ A[i']
H1 '→λxy.y
H1 (T [i − 1], ψi) =
+(S[i' − 1], A[i'] ∗ A[i'])
H1 '→λxy.x

T [i − 1] ? A[i' ] ∗ A[i']
i'→i−1
?
T [i − 1] =
+(S[i' − 1], A[i'] ∗ A[i'])
 i'→i−1
?

?	'	' 	i/=0	 unreachable	T [i] =
  i=0   unreachable

T [i] = A[i ] ∗ A[i ]








i =0 


i /=0 
+(S[i' − 1], A[i'] ∗ A[i'])
 i/=0
?
ϕ(T [i − 1], ψi) =
+(S[i' − 1], A[i'] ∗ A[i'])
 subst. ϕ
?	?

?	'	+(T [i − 1], H2 (T [i − 1], ψi)) =
H2 (T [i − 1], ψi) =

T [i] = S[i ]
+(S[i' − 1], A[i'] ∗ A[i'])


i '→ i − 1	?	'


i' '→ i' − 1
T [i − 1] = S[i − 1]

Final states are surrounded by rectangles. For sake of clarity, arcs are

labeled by shortened notations. Starting from state T [i] =?
S[i'], label i /=

0, i' /= 0 represents relation {(i, i') → (i, i')|i /= 0, i' /= 0}. Label ϕ '→ λxy.x indicates the addition of ϕ '→ λxy.x to the current substitution. The reaching set of the final state tagged with (*) is:

8> . → i
9> 8> i → i
9> 0
8	91∗	8	9

>>< . → i' >>= >>< i' → i' >>= B8< i → i − 1 =9 <> i → i
>=C
8< i → i − 1 =9 >< i → i
>=>

.
i = n	i /=0 
.
>	: i' → i'
.
; >:
i' → i'
>;CA
.
: i' → i'
.
; >:
i' → i'
>;

>: i' = n >; >: i' /=0 >;
i /=0 
i =0 

Which boils down to: {. → i, . → i',i = 0, i' = n, n ≥ 1}. And the substitution obtained is:
([ϕ '→ λxy.x, ψ0 '→ +(S[n — 1], A[n] ∗ A[n])],n ≥ 1)
There remains to apply the same method to the other final states, and to combine unifiers by applying the rules of Λ, V and H. The final set of all

possible solutions is:
 ([ψ0 '→ A[0] ∗ A[0]],n = 0)	
 ([ϕ '→ λxy.x, ψ0 '→ S[n — 1] + A[n] ∗ A[n]],n ≥ 1)	
([ϕ '→ λxy.y, ψ0 '→ S[n — 1] + A[n] ∗ A[n]],n ≥ 1)
	
 ([ϕ '→ λxy.x + y, ψi = A[i] ∗ A[i](0 ≤ i ≤ n)],n ≥ 1) 
Each solution is defined by a substitution and the condition on the parame- ters for which it is valid. Note that only the last solution corresponds to a reduction, since in the others, ϕ is either not defined or not associative.

Conclusions
Algorithm templates represent programming models that convey genericity, portability, can be easily customized by the programmer to suit its need and at the same time have efficient implementations. Algorithm template recogni- tion thus appears as a promising tool for code comprehension, validation and optimization. In this paper, we have presented a preliminary approach that provides such recognition for templates described by systems of affine recur- rent equations. As a consequence, our analysis is able to recognize algorithms obtained by composition of other algorithms, since templates can be composed with other templates. While other analyses [18] could recognize an algorithm made of several known algorithms, ours works also for unknown algorithms.
In future work, we will investigate the feasibility of the approach on bench- mark applications, with respect to the assumptions that have been made and by extending the existing prototype developed for the equivalence of SAREs. We would also like to address the recognition of templates parameterized by constructed types (such as matrices) so that the methods to be instantiated can be defined by the operations on the elementary types. Finally, the SARE templates have still some non variable definition domains and non variable dependence functions. Breaking these constraints would lead to possibly non- affine systems of recurrence equations and the applicability of our approach in this case need to be studied.

References
Autebert, J.-M., J. Berstel and L. Boasson, Context-free languages and push- down automata, in: Handbook of Formal Languages, Springer Verlag, 1997 .
Baader, F. and T. Nipkow, “Term Rewriting and all that,” Cambridge University Press, 1998.
Barthou, D., P. Feautrier and X. Redon, On the equivalence of two systems of affine recurrence equations, Technical Report RR-4285, INRIA (2001).


Barthou, D., P. Feautrier and X. Redon, On the equivalence of two systems of affine recurrence equations, in: 8th International Euro-Par Conference (2002), p. 309. 
Darte, A., Y. Robert and F. Vivien, “Scheduling and automatic Parallelization,” Birkha¨user, 2000.
Feautrier, P., Dataflow analysis of scalar and array references, Int. J. of Parallel Programming 20 (1991), pp. 23–53. 
Feautrier, P., Some efficient solutions to the affine scheduling problem, II, multidimensional time, Int. J. of Parallel Programming 21 (1992), pp. 389–420. 
Hermann, M. and R. Galbavy´, Uniﬁcation of inﬁnite sets of terms schematized by primal grammars, Theoretical Computer Science 176 (1997), pp. 111–158. 
Huet, G., A uniﬁcation algorithm for typed λ-calculus, Theoretical Computer Science 1 (1975), pp. 27–57. 
Kelly, W., W. Pugh, E. Rosser and T. Shpeisman, Transitive closure of inﬁnite graphs and its applications, Int. J. of Parallel Programming 24 (1996), pp. 579– 598.
Lee, L.-Q., J. G. Siek and A. Lumsdaine, The generic graph component library, in: Proceedings of the Conference on Object-Oriented Programming, Systems, Languages, and Applications, 1999, pp. 399–414. 
Metzger, R. and Z. Wen, “Automatic Algorithm Recognition: A New Approach to Program Optimization,” MIT Press, 2000.
Redon, X. and P. Feautrier, Detection of scans in the polytope model, Parallel Algorithms and Applications 15 (2000), pp. 229–263. 
Saouter, Y. and P. Quinton, Computability of recurrence equations, TCS 116
(1993), pp. 317–337. 
Shashidhar, K., M. Bruynooghe, F. Catthoor and G.Janssens, Geometric model checking: An automatic veriﬁcation technique for loop and data reuse transformations, in: International Workshop on Compilers Optimization Meets Compiler Veriﬁcation, ENTCS 65 (2002).
Siek, J. G. and A. Lumsdaine, The matrix template library: A generic programming approach to high performance numerical linear algebra, in: ISCOPE, 1998, pp. 59–70. 
TayouDjameni, C., P. Quinton, S. Rajopadhye and T. Risset, Derivation of systolic algorithm path problem by recurrence transformations, in: Parallel Computing, 2000.
Wills, L. M., Using Attributed Flow Graph Parsing to Recognize Clich´es in Programs, in: Proc. 5th Int. Workshop on Graph Grammars and their Application to Computer Science, LNCS 1073 (1996), pp. 170–184. 
