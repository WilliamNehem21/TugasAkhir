

Electronic Notes in Theoretical Computer Science 267 (2010) 115–126
www.elsevier.com/locate/entcs

A Note on the Inversion Join for Polyhedral Analysis
Axel Simon1,2
Lehrstuhl 2 fu¨r Informatik, Technical University Munich, 85478 Garching, Germany

Abstract
Linear invariants are essential in many optimization and verification tasks. The domain of convex polyhedra (sets of linear inequalities) has the potential to infer all linear relationships. Yet, it is rarely applied to larger problems due to the join operation whose most precise result is given by the convex hull of two polyhedra which, in turn, may be of exponential size. Recently, Sankaranarayanan et al. proposed an operation called inversion join to efficiently approximate the convex hull. While their proposal has an ad-hoc flavour, we show that it is quite principled and, indeed, complete for planar polyhedra and, for general polyhedra, complete on over 70% of our benchmarks.
Keywords: Abstract interpretation, polyhedra analysis, convex full.


Introduction
More than three decades ago, Cousot and Halbwachs proposed the lattice of con- vex polyhedra to infer linear relationships between program variables [4]. While approximating assignments and tests can straightforwardly be implemented using simple manipulations of inequality sets, the join of two abstract states cannot. In- deed, the most precise join operation is the convex hull of the two input polyhedra which might result in an output polyhedron whose inequality set is exponentially larger than the two inputs. In the past, many so-called weakly-relational domains have been suggested that restrict inequalities to a certain form for which more efficient join operations exist. Examples include the octagon domain [9], the two- variable-per-inequality (TVPI) domain [16] or, more recently, the logahedra domain [5]. However, many practical tasks require that weakly-relational domains are com- bined with other domains to achieve the required precision. For instance, the oc- tagon domain was augmented with a domain tracking symbolic expressions [10] to

1 This work was supported by the Emmy Noether Programme SI 1579/1 and the INRIA project “Abstrac- tion” of jointly funded by CNRS and ENS.
2 Email: Axel.Simon@in.tum.de


1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.09.010

achieve more precision. In contrast, general polyhedra subsume affine constraints of the form a · x = c where a ∈ Rn, c ∈ R, enabling them to symbolically track any linear expression assigned to a variable. Furthermore, when the variables x are known to be integral, congruences can be recovered by observing equalities such as 4x = y; a constraint that is not expressible in the octagon domain. When fur- thermore using simple integer tightening methods, disjunctive information can be stored using binary variables [14] which can otherwise only be expressed by tracking several states per program location [8]. Since polyhedra can subsume many of these simpler domains, they are attractive as a one-stop solution.
The original join H for polyhedra proposed in [4] calculates (the topological clo- sure of) the convex hull P1 Y P2 of two polyhedra P1, P2 which is equivalent to the smallest polyhedron that contains P1 and P2. When considering the join operation

as just another transfer function that the static analyzer evaluates, setting H ≡ Y means that the join operation H is a complete transfer function [3] in that it always returns the most precise polyhedron. Approximating the join operation has already been proposed in [15] which re-formulates the convex hull problem as a projection problem which can be approximated when the output inequality set becomes too large. In [12], Sankaranarayanan et al. propose a so-called inversion join that ap- proximates the join by linear combinations of k inequalities taken from conjoined inequalities of the two input systems. The authors only give an implementation for k = 2, resulting in a cubic number of output constraints from which redundant inequalities have to be removed. While the algorithm seems to be ad-hoc, it per- forms surprisingly well in terms of precision. We show that it is complete for planar polyhedra. Furthermore, we present an empirical evaluation which shows that the output of their algorithm coincides with the convex hull in 73% of all cases. In the remaining cases, the output is slightly larger than the convex hull. Thus the algorithm avoids exponentially-sized outputs at the cost of some precision.
In summary, this paper presents the following, previously unappreciated prop- erties of the inversion join, namely:
we show that the inversion join corresponds to the convex hull for planar polyhe- dra;
we demonstrate that, in the application of program analysis, it is complete in over 70% of all cases;
we show that many of the produced redundancies can be avoided in practice.
Section 2 introduces required notation before Section 3 presents the inversion join and the completeness result for planar polyhedra. Section 4 presents measurements before Section 5 concludes.

Preliminaries
Let the analyzer express numeric constraints over a set of variables X and let x denote the vector of all variables in X . Let Linn denote the set of linear expressions of the form a · x where a ∈ Zn and n = |X |. Let Ineqn denote the set of linear


y	❷






1	2	3	4 x

1	2	3	4

5	6	7	8	9
10 x

Fig. 1. Choosing two inequalities from T = {a1,... a4, b1,... b4}.
inequalities a · x ≤ c where c ∈ Q. For simplicity, let e.g. 3 ≤ x2 ≤ 4 abbreviate the two inequalities x2 ≤ 4 and x2 ≥ 3, the latter being an abbreviation of −x2 ≤ −3. Each inequality a · x ≤ c ∈ Ineqn induces a half-space [a · x ≤ c]] = {x ∈ Qn |

a · x ≤ c}. Let [I]] = T

ι∈I
[[ι ] and Polyn
= {[[I]] | I ⊆ Ineqn
∧ |I| ∈ N} the set

of (finitely generated) convex polyhedra. Polyhedra form a lattice ⟨Polyn, ⊆, Y , ∩⟩
where P1 Y P2 is the (topological closure of) the convex hull of P1 and P2 [4] which can be defined as P1 Y P2 = cl ({x ∈ Qn | x = (1 − λ)x1 + λx2 ∧ 0 ≤ λ ≤ 1 ∧ x1 ∈ P1 ∧ x2 ∈ P2}) where cl (·) denotes the closure. An actual analyzer uses the lattice of sets of inequalities ⟨P(Ineqn), ±, H, H⟩. Here I1 ± I2 iff [I1]] ⊆ [[ι ] for all ι ∈ I2 which can be tested as follows: let c = maxExp(a · x,I) be the result of a linear program where c ∈ Q is the maximum that the expression a · x ∈ Linn can take in the polyhedron [I ] and set c = ∞ if no such maximum exists. Then [[I1]] ⊆ [[a · x ≤ c]] iff c' = maxExp(a · x, I1) /= ∞ and c' ≤ c. The meet is defined as I1 H I2 = Remove-Redundant(I1 ∪ I2) where Remove-Redundant(I) removes
redundant inequalities, that is, inequalities ι ∈ I for which I \ {ι} ± I holds. This reduces to testing if I \ {ι}± {ι} using maxExp.

The Inversion Join
The inversion join originated in the template method [13] that was proposed to infer a constant vector c to a matrix A such that Axtr ≤ ctr where xtr denotes a column vector corresponding to the row vector x. The disadvantage of the template method is that A is fixed and has to be given by the user who employs the analysis. The inversion join was meant to calculate new rows that could constitute useful invariants. However, since it infers new inequalities from two (possibly different) template systems, it is suitable to calculate a join of two arbitrary inequality sys- tems. The result is, however, only an approximation to the convex hull of the state represented by the two inequality systems since not all inequalities will be found.
The original presentation of the inversion join is cast in terms of conjoining the inequalities of the two input systems A and B into one set T = A∪B and calculating the minimal constant c' of each inequality ι ≡ a · x ≤ c ∈ T such that A ± {ι'}
and B ± {ι'} where ι' ≡ a · x ≤ c'. Note that the constant c' can be inferred by calculating c' = max(maxExp(a · x, A), maxExp(a · x, B)) iff both maximums exist. The inversion join is then defined as a special case of a so-called restricted join that



4

3

2

1


1	2	3	4 x
Fig. 2. Maximizing ai in [B ] and vice-versa.
calculates the convex hull on subsets ψ1, ψ2 ⊆ T of at most size k. Specifically, the inversion join picks exactly two inequalities ai · x ≤ ci, aj · x ≤ cj ∈ T such that ψ1, ψ2 take on the following form:
ψ1 = {ai · x ≤ cA, aj · x ≤ cA}
i	j
ψ2 = {ai · x ≤ cB, aj · x ≤ cB}
i	j
Here, the constants cA, cA, cB, cB are chosen such that A ± ψ1 and B ± ψ2,
i	j	i	j
that is, cA = maxExp(ai · x, A) and analogously for cA, cB, cB. An inversion exists
i	j	i	j
if the coefficients ai and aj are linearly independent and cA < cA ∧ cB > cB or
i	j	i	j
cA > cA ∧ cB < cB. Two of the possible configurations that satisfy these conditions
i	j	i	j
are depicted in Fig. 1 which shows two polyhedra defined by A = {a1,... a4} and
B = {b1,... b4}. In Diagram ❶, the inequalities a2, b2 ∈ A∪B = T are chosen. The
relaxed inequality a' ≡ a2 · x ≤ c' is inferred from a2 ≡ a2 · x ≤ c by calculating
c' = maxExp(a2 · x, B) and analogously for b' . We combine one inequality from
each input polyhedron, thus ψ1 = {a2, b' } and ψ2 = {a' , b2}.  The spaces [ψ1]]
2	2
and [ψ2 ] are depicted as two areas that extend towards infinity. The idea of the
inversion join is to calculate a new inequality that connects the two tips (vertices)
of these areas. Diagram ❷ shows two similar areas, except that these are defined by
ψ1 = {b' , b' } and ψ2 = {b2, b3}, that is, both relaxed inequalities reside in ψ1 while
2  3
the original inequalities reside in ψ2. In particular, the combined inequalities are
both taken from one input set, here B. A symmetric example can be constructed in which both inequalities are taken from A. Thus, the inversion join combines inequalities in two principle modes: the bilateral mode, in which an inequality form
A is combined with an inequality from B; and the unilateral mode, in which the
inequalities that are combined both stem from either A or B. For each of these modes, we now discuss how a new inequality is calculated that connects the vertex of the area [ψ1 ] with the vertex of [ψ2]].

3.0.1	Calculating a New Inequality
We commence by presenting a problem that only requires bilateral combinations, that is, the combination of an inequality in A with one in B. The input polyhedra A = {a1,... a4} and B = {b1,... b4} where ai ≡ ai · x ≤ cA and bi ≡ bi · x ≤ cB are
i	i
shown in ❶ of Fig. 2. Using linear programming we infer c'A = maxExp(ai · x, B) and c'B = maxExp(bi · x, A). Diagram ❷ of Fig. 2 shows the resulting inequalities




4

3

2

1



Fig. 3. Calculating weighted combinations.


4	4

3	3

2	2

1	1



Fig. 4. Combining inequalities from just one polyhedron.

a' ,... a' and b' ,... b'
as dotted lines.

1	4	1	4
In order to check if the inequality sets ψ1 = {ai, b' } and ψ2 = {a', bj} form an
j	i
inversion, we calculate the amount an inequality ai and bi was shifted, by calculating
δa := cA − c'A and δb := cB − c'B for i = 1,... 4. Fig. 3 shows how this information
i	i	i	i	i	i
can be used to calculate inequalities that describe the convex hull of [A]] and [[B]]:

Consider the relaxed inequalities a'
and b'
that are depicted in diagram ❶. The task

is to find an inequality that connects the two shown vertices va and vb. Diagram ❷
1	1
shows that these two vertices lie on opposite corners of the parallelogram spanned
by a4, a' and b4, b' . The diagonal is the sum of its two sides (that is, inequalities)
whose length is given by δa and δb. In order to obtain an inequality that pivots in
2	2
the upper right corner of this parallelogram, we calculate a linear combination of
a' and b4. Given that both δa > 0 and δb > 0, the following weighted combination
4	4	2
of a4 and b' includes both [A]] and [[B ] and is saturated by va and vb:
4	1	1
(δbai + δabj) · x ≤ (δbcA + δac'B).	(1)
j	i	j i	i  j
A proof of this claim is straightforward and can be found in [12]. In general, δa and δb may be negative as, for example, in the case of a2 and b2. In this case, the following generalized inequality holds:
(|δb|ai + |δa|bj) · x ≤ (|δb|cA + |δa|c'B)	(2)
j	i	j  i	i	j
Note that this inequality subsumes the previous one. The resulting inequalities
δ1 and δ2 are shown in Diagram ❷ of Fig. 3.
An example for a unilateral combination is shown in Fig. 4. Here, diagram ❶
depicts two systems in which b2, b3 ∈ B chosen from T = A∪B. Thus, ψ1 = {b' , b' }
2  3
and ψ2 = {b2, b3}. Again, we use an inequality similar to (1) to calculate a weighted,
linear combination, this time from b' and b3:

(|δb|bi + |δb|bj) · x ≤ (|δb|cB + |δb|c'B)	(3)
j	i	j  i	i	j
The resulting new inequality is dubbed δ1 in Diagram ❷. We now specify how to calculate the inversion join in the general case which leads us to a comment on
how to reduce the number of inequality pairs that are considered.

Notes on the Implementation
The algorithm for the inversion join can be specified as follows:
For each ι ∈ A ∪ B, calculate ι' and δι using Simplex.
Define the set of stable constraints as S = {ι ∈ A ∪ B | δι ≤ 0}.
For each ai ≡ ai · x ≤ ci ∈ A ∪ B and for each aj ≡ aj · x ≤ cj ∈ A ∪ B check that ai is linearly independent from aj. Add the weighted combination (|δj|ai + |δi|aj) · x ≤ (|δj|ci + |δi|c' ) to the result set R if
δiδj < 0 and {ai, aj}⊆ A or {ai, aj}⊆ B or
δiδj > 0 and ai ∈ A ∧ aj ∈ B.
Calculate the weak join W = {ι' | ι ∈ A ∪ B ∧ δι > 0}, see [12].
Return Remove-Redundant(S ∪ R ∪ W ).
In step (iii), the inversion join considers O(|A||B|) weighted combinations. Many of these are redundant and have to be removed using Remove-Redundant. Many combinations produce duplicate inequalities that can be identified as redundant by storing inequalities appropriately. During the analysis of loops, many inequalities remain unchanged which can be exploited to reduce the number of Simplex runs. Let IC = A ∩ B denote the common inequalities of A and B. Obviously, for each inequality a · x ≤ c ∈ A ∪ B it holds that maxExp(a · x, A) = maxExp(a · x, B) = c and hence the displacement δ is zero. No sensible combination can be calculated using this inequality since the result is always the inequality itself. Indeed, a facet that is present in both input polyhedra is also present in the output. Thus, it is prudent to identify IC and avoid calculating maxExp for these. The set IC can be maximised by putting each polyhedron into a normal form which can be obtained by factoring out all equalities from the inequality systems [6].

Completeness of the Inversion Join for Planar Polyhedra
We now show that the inversion join that combines two inequalities from the input system A ∪ B is complete in the two dimensional case, that is, it delivers a result that is as precise as possible or, equivalently, that corresponds to the convex hull of the two input polyhedra. We commence by assuming that both input systems specify bounded polyhedra, that is, each polyhedron can be represented by a set of vertices without rays nor lines.
Suppose A, B ⊆ Ineqn be non-redundant inputs to the inversion join and set
I = S ∪ R as defined in steps (ii) and (iii) of the algorithm. For the sake of a contradiction, assume there exists an inequality ι such that P = [[A]] Y [[B]] ⊆ [[ι]] but A H B /± {ι}. Since P is bounded and planar, ι connects two vertices (extreme

points) v1, v2 of P . These vertices must have been vertices in [A]] or [[B]]. Suppose that both, v1 and v2, are vertices in [A]]. Since A is non-redundant, there exists an inequality a ∈ A that connects these vertices. In this case B ± {a} as otherwise the convex hull P would not include [B]]. Thus, [[a]] = [[ι ] and δa = 0. Therefore ι ∈ S.
We can thus suppose that, without loss of generality, v1 is a vertex in [A ] and v2 is a vertex in [B]]. For each vertex v in a planar polyhedron, there exist two inequalities that define it. Let a1, a2 ∈ A define v1 and let b1, b2 ∈ B define v2. We assume that a1 (b1) can be rotated clockwise around v1 (v2) until it coincides with a2 (b2). Then there exists a clockwise ordering of {a1, b1}, followed by ι, followed by {a2, b2}. We consider the different cases:
a1, b1, ι, a2, b2: Since b1 lies angle-wise between a1 and ι, v1 saturates b' . Since a2 lies angle-wise between ι and b2, v2 saturates a' . Thus, the weighted bilateral combination of b1 and a2 would connect v1 with v2 and coincide with ι which is a contradiction.
a1, b1, ι, b2, a2: As above, except that a unilateral combination is created using

b1 and b'
(or b'
and b2).

b1, a1, ι, b2, a2: Analogous to case (i).
b1, a1, ι, a2, b2: Analogous to case (ii).
Thus, for bounded polyhedra, P = [S ∪ R]]. For unbounded polyhedra the inequalities ι' do occasionally not exist, namely when linear programming returns infinity. In this case, one or both polyhedra contain at least one inequality that defines a ray or a line. In case of a ray, the inequality ai ≡ ai·x ≤ ci ∈ A is saturated by one one vertex in [A]], in case of a line a is saturated by no vertex. In case of a ray, the correct set of inequalities are generated to connect the vertex with the remaining vertices, as per the argument above. What remains to add to the output is an inequality that defines the ray. If a' exists, that is, if maxExp(ai · x, B) /= ∞, then a' itself is such an inequality. Indeed, these inequalities are added through the calculation of W , the so-called weak join. The inequality set W ∪ S ∪ R therefore defines the convex hull of the two planar input polyhedra A and B.
As a consequence for the implementation, if in step (i) of the algorithm each inequality ι has a corresponding ι' then the inclusion of W in the final result is not necessary as they do not restrict the output space any further. Note that this is only true for the two-dimensional case.

Incompleteness of the Inversion Join for General Polyhedra
While the algorithm above is complete for planar polyhedra, it remains an approx- imation to the convex hull of polyhedra of higher dimensions. In order to illustrate this, consider the task of joining the two polyhedra in Fig. 5. Figs. 6 and 7 show how the inversion join finds two facets of the actual convex hull. In both figures,
we use a' to denote the inequality ai in which the constant has to be modified to
the maximum in the polyhedron B and vice-versa for b', bi, and polyhedron A.
In order to illustrate how the inversion misses inequalities that are required to




b
1 vb
❷ va	3	va







a 0






b 6

z


x
Fig. 5. Polyhedron A, depicted as dark rectangle, is to be joined with pyramid B.

❶	vb vb



b4'


va
1  7
a'5



a5

1  a
0
b4



y

Fig. 6. The relaxed constraints a' and b' are combined to the constraint δ.
5	4




vb vb	vb vb
❶	1  7	❷	1  7



a5
3
a4	a4
a	a
1	1



b1'


b1
b 2
a' vb

6
b	z	b
3	2
vb	x


b1


a' vb

4 0	6	y	4 0

Fig. 7. A weighted combination of inequalities a4 and b1.

define the exact convex hull of the input polyhedra, consider Fig. 8. Formally, the task of calculating the convex hull of two polyhedra amounts to finding facets that connect a single vertex v of one polyhedron with a so-called horizon ridge of the other polyhedron. A ridge is the intersection of two adjacent facets, which, in turn, can be seen as the intersection of the boundaries of two inequalities ([[a·x = ca]]∩[[b·x = cb]] for inequalities a·x ≤ ca and b·x ≤ cb). A horizon ridge is formed by two inequalities of which one is “visible” from the vertex v while the other one is obscured, that is, a · v /≤ ca indicates that the first facet is visible while b · v ≤ cb indicates

vb  vb

vb  vb

❶	7	1	❷	7	1

6	6
2	1

a5

3	a3	a
b3	b1
z
x	y


Fig. 8. The weighted combinations of a5, b1 and a5, b3 do not form a facet of the convex hull. The facet w
would be the most precise constraint but cannot be found by combining two inequalities.

that the second is obscured. The challenge in calculating the convex hull lies in finding ridges of a polyhedron. The inversion join combines two inequalities and optimistically assumes that the result touches a ridge in one of the polyhedra. In the
case of b1 in ❶ of Fig. 8, this assumption is wrong: In the diagram, the inequalities
a5 and b1 are combined. While b1 forms a ridge with b3, b4 and b6; and a5 forms a
ridge with a0,... a3, the resulting inequality δ1 touches none of these ridges. Indeed, it connects a vertex to a vertex and is therefore redundant in the actual convex hull. On the contrary, the inversion join will miss opportunities to connect certain ridges in a polyhedron to a vertex in the other polyhedron. This is illustrated in Diagram
❷ of Fig. 8. Here, the ridge formed by a3, a5 could be connected to the vertex vb.
However, since a' touches the vertex vb rather than vertex vb, this opportunity is
3	2	1
missed.
We now present our prototype implementation and its evaluation.

Evaluation
The major challenge in implementing the inversion join in a sound way is the use of the Simplex solver. Since off-the-shelf solvers use floating-point arithmetic, the result is not always correct. Thus, given c = maxExp(a·x,I), we discard the floating point optimum c and query which inequalities IB ⊆ I the Simplex solver used as a basis when observing the maximum. We then find a vector λ of multipliers such that λA = a where IB ≡ Ax ≤ c. If c /= ∞ and no λ exists then the floating-point solver is wrong and we re-run the linear program using exact arithmetic which is about 70 times slower.
We applied our implementation of the inversion join to a benchmark suite that was gathered in the context of the PIPS project [1] which pursued advanced opti- mizations and parallelization of Fortran code. The benchmarks [11] contain every 100th input to the convex hull algorithm of the analyser while analyzing the Per- fect Club and Spec 95 Fortran benchmarks. The data in the benchmark consist of pairs of polyhedra that were joined during the analysis. Thus, the benchmarks only contain few examples that are exponential as the analyzer would not have progressed after encountering a hard problem. Hence, there are no instance where our algorithm delivers a result while the exact convex hull algorithm times out. We


Table 1
Performance of the join algorithm on a 2.4GHz Core 2 Linux computer.

generated a C++ program that calculates the convex hull of each test case using the Parma Polyhedra Library [2] and a Haskell program that implements the inversion join, using the GNU Linear Programming Toolkit as solver [7]. The test programs record the results to disk which we used to count the number of inequalities that the inversion join lacks from the exact solution of the convex hull. The test results in Table 1 are partitioned by the number of dimensions (variables) in the output polyhedron except for the last row which shows the results for running all 3492 tests. Next to the dimension we show the number of test cases and then three dou- ble columns that state how many of these test cases do not match the convex hull; those that lack at most one inequality and those that lack at most two. In each double column the number of incomplete cases is given together with the percentage of the total. From the last row, it can be seen that the algorithm is exact in 73% of all cases and misses less than two inequalities in 83% of all cases. Note that the number of incomplete joins rises with the dimension which is to be expected as the convex hull problem is exponential in the dimension.
Conclusion and Discussion
We assessed the precision of the inversion join in a qualitative and quantitative way. In particular, we argue that the inversion join with k = 2 is complete for planar polyhedra. This begs the question if similar results are obtainable for k > 2. The completeness in two dimensions implies that a TVPI system of inequalities can be joined using the inversion join in a way that the result is more precise than that of the TVPI domain. However, the result of applying the inversion join to a TVPI

system is not necessarily a TVPI system since inequalities may have more than two variables per inequality. Furthermore, widening, a process necessary to ensure termination, is non-monotonic. Widening could therefore render an analysis using the inversion join less precise than that of the TVPI system. Further empirical studies that compare the precision of the two domains would thus be of interest.
On general polyhedra, our observation is that the inversion join produces very good approximations to the precise convex hull algorithm while avoiding the ex- ponentially sized output cases. The inversion join therefore presents a sweetpoint between precision and efficiency and we would argue for the inclusion of this algo- rithm into the common off-the-shelf polyhedra libraries.
The author wishes to thank Duong Nguyen Que for making the benchmark suite available and also Liqian Chen for useful discussions. The author would also like to thank Antoine Min´e for his diligent work as editor.

References
Ancourt, C., F. Coelho, F. Irigoin and R. Keryell, A Linear Algebra Framework for Static High Performance Fortran Code Distribution, Scientific Programming 6 (1997), pp. 3–27.
Bagnara, R., P. M. Hill and E. Zaffanella, Not Necessarily Closed Convex Polyhedra and the Double Description Method, Formal Aspects of Computing 17 (2005), pp. 222–257.
Cousot, P. and R. Cousot, Abstract Interpretation and Application to Logic Programs, Journal of Logic Programming 13 (1992), pp. 103–179.
Cousot, P. and N. Halbwachs, Automatic Discovery of Linear Constraints among Variables of a Program, in: Principles of Programming Languages (1978), pp. 84–97.
Howe, J. M. and A. King, Logahedra: a New Weakly Relational Domain, in: Z. Lu and A. P. Ravn, editors, Automated Technology for Verification and Analysis, LNCS (2009).
Lassez, J.-L. and K. McAloon, A Canonical Form for Generalized Linear Constraints, Journal of Symbolic Computation 13 (1993), pp. 1–24.
Makhorin, A., GLPK (GNU Linear Programming Kit) (2008), version 4.32.
URL http://www.gnu.org/software/glpk/
Mauborgne, L. and X. Rival, Trace Partitioning in Abstract Interpretation Based Static Analyzers, in:
M. Sagiv, editor, European Symposium on Programming, LNCS 3444 (2005), pp. 5–20.
Min´e, A., The Octagon Abstract Domain, Higher-Order and Symbolic Computation 19 (2006), pp. 31– 100.
Min´e, A., Symbolic Methods to Enhance the Precision of Numerical Abstract Domains, in: E. A. Emerson and K. S. Namjoshi, editors, Verification, Model Checking and Abstract Interpretation, LNCS 3855 (2006), pp. 348–363.
Nguyen-Que, D., Polybench (2006).
URL http://www.cri.ensmp.fr/people/duong/polybench

Sankaranarayanan, S., M. Col´on, H. B. Sipma and Z. Manna, Efficient Strongly Relational Polyhedral Analysis., in: E. A. Emerson and K. S. Namjoshi, editors, Verification, Model Checking and Abstract Interpretation, LNCS 3855 (2006), pp. 111–125.
Sankaranarayanan, S., H. B. Sipma and Z. Manna, Scalable Analysis of Linear Systems Using Mathematical Programming, in: R. Cousot, editor, Verification, Model Checking, and Abstract Interpretation, LNCS 3385 (2005), pp. 25–41.
Simon, A., Splitting the Control Flow with Boolean Flags, in: M. Alpuente and G. Vidal, editors, Static Analysis Symposium, LNCS 5079 (2008), pp. 315–331.

Simon, A. and A. King, Exploiting Sparsity in Polyhedral Analysis, in: C. Hankin and I. Siveroni, editors, Static Analysis Symposium, LNCS 3672 (2005), pp. 336–351.
Simon, A., A. King and J. M. Howe, Two Variables per Linear Inequality as an Abstract Domain, in: M. Leuschel, editor, Logic-Based Program Synthesis and Transformation, LNCS 2664 (2003), pp. 71–89.
