Electronic Notes in Theoretical Computer Science 216 (2008) 31–44	
www.elsevier.com/locate/entcs

Computational Origami Construction as Constraint Solving and Rewriting
Tetsuo Ida1,2, Mircea Marin1,2, Hidekazu Takahashi1,2 and Fadoua Ghoura1,2
Department of Computer Science, University of Tsukuba, Tsukuba 305-8357, Japan

Abstract
Computational origami is the computer assisted study of mathematical and computational aspects of origami. An origami is constructed by a finite sequence of fold steps, each consisting in folding along a fold line. We base the fold methods on Huzita’s axiomatization, and show how folding an origami can be formulated by a conditional rewrite system. A rewriting sequence of origami structures is viewed as an abstraction of origami construction. We also explain how the basic concepts of constraint and functional and logic programming are related to this computational construction. Our approach is not only useful for computational construction of an origami, but it leads us to automated theorem proving of the correctness of the origami construction.
Keywords: computational origami, constraint solving, rewriting, functional logic programming, automated theorem proving


Introduction
We are interested in programming support for computational origami, the computer assisted study of origami. An origami is constructed by a finite sequence of fold steps, each consisting in folding along a fold line. We use several admitted fold operations to find a fold line and then we fold an origami along the fold line.
As Euclidean postulates are the basis of Euclidean geometry, origami can be based on a formal system. Huzita in 1989 proposed an axiomatization of origami [5]. Since then, his axiomatization has been studied extensively [1,3,4]. We base our study of origami on Huzita’s axiomatization. We will formulate Huzita’s axiomati- zation first in the language of first-order predicate logic and then as a conditional rewrite system. A rewriting sequence of origami structures is seen as an abstraction

1 Emails:{ida, mmarin, hidekazu, ghourabi}@score.cs.tsukuba.ac.jp
2 This research is supported by the JSPS Grants-in-Aid for Scientific Research (B) No. 17300004 and for Exploratory Research No. 19650001.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.06.032

of the origami construction. In so doing, we will be able to turn the declarative statements about the origami foldability to computing statements, i.e. program.
We use an origami construction of Morley’s triangle as an illustrative example of our study. We also explain how the basic concepts of constraint and rewrite- based programming are related to this computational construction. Our approach is not only useful for computational construction of origami, but it leads to auto- mated theorem proving of correctness of the construction. The rest of the paper is organized as follows. Section 2 gives the basic notions and notations used in our modeling of origami. In Sect. 3, we formalize the basic fold operations that Huzita proposed. Then in Sect. 4, we formalize the fold. In Sect. 5, we give the construc- tion of Morley’s triangle. In Sect. 6, we briefly describe the current programming
and computational capabilities of our computational origami environment Eos, and
discuss desirable new features. In Sect. 7, we summarize our work and indicate a direction of further research.
Basics of origami modeling
We give the notions about the geometric objects of our study and notations used in this paper. Thorough descriptions of geometric notions in plane geometry are treated in standard textbooks [11,13].
A point is the basic object we use without definition. We denote points by P1,..., Pn. By Pi,j, where i ≤ j, we denote the sequence Pi, ..., Pj of points. When i = 1, we omit i and write Pj.
By ⟨Pn⟩, we denote several geometric objects that are the ingredients of origami. A ray, i.e. a directed line segment, is represented by a structure ⟨P1, P2 ⟩, where P1
−−−→
and P2 are the points that the line passes through. A ray is also denoted by	.
An n(n ≥ 3)-gon, i.e. a simple n-edge polygon (polygon consisting of n edges none of which intersect), is represented by a structure ⟨P1,..., Pn⟩ made of a se- quence of vertices P1,..., Pn, with the following property: ⟨P1,..., Pn⟩ and its cyclic permutation ⟨P1+k,..., Pn+k ⟩ for arbitrary k ≥ 1 are the same 3 .
The degenerate cases of P1 = P2 of the ray, and of Pi = Pi+1 for some i of the n-gon are not specifically treated as this kind of rigor is not what we pursue in this paper. It is assumed that the duplication of the same points in the those structures are automatically removed when they are used.
Definition 2.1 (Face) A face is a convex n-gon.
A face f = ⟨Pn⟩ is up if the vertices P1,..., Pn are arranged counter-clockwise, otherwise down. Because of the convexity of the n-gon, we can easily determine whether the vertices Pn are arranged clockwise or counter-clockwise.
Definition 2.2 (Face division) Let f be ⟨Pn⟩. Suppose that points X and Y lie

on the ray −−−−→
−−−−→

PiPi+1 and PjPj+1, respectively, where i < j. The division of the face f
by the ray XY , written as δ−−→(f ), is deﬁned as follows:

3 The index addition is performed in modulo the number of elements of the sequence.

Case 1:
XY does not overlap with one of the edges of f
δ−−→(f ) = ⟨f1, f2⟩
where f1 = ⟨Y, X, Pi+1,j ⟩ and f2 = ⟨X, Y, Pj+1,n+i⟩.

Note that ⟨Y, X, Pi+1,j ⟩ and/or ⟨X, Y, Pj+1,n+i⟩ would become degenerate cases if the points X and/or Y are the vertices of the n-gon to be divided.
−−→
Case 2:	XY overlaps with one of the edges of f
δ−−→(f ) = ⟨f, ⟨X, Y ⟩⟩ or ⟨⟨Y, X⟩,f⟩ .

The division of the front side of the face is illustrated in Fig. 1.


Pj


Pi+1
Pn
P1	l


Fig. 1. Face division.
The application of δ−−→ to up face f is a pair consisting of geometric objects f1

and
XY	−−→
−−→

f2, and f1 is to the right of XY and f2 to the left of XY .
Definition 2.3 (Face rotation) For a point P, ρθ(P ) is the rotation of P by an angle θ along a ray r. ρθ is extended to a face. Namely, if f = ⟨P1,..., Pn⟩ then ρθ(f ) = ⟨ρθ(P1),..., ρθ(Pn)⟩.
r	r	r
In origami folds, faces are divided before rotation. Namely, each face f subjected to fold is first divided into f1 and f2, i.e. δr(f ) = ⟨f1, f2⟩, and then f1 is rotated along r by applying ρθ to f1.
Definition 2.4 (Abstract Origami) An abstract origami is a structure (Π, >, ~
), where Π is the set of faces, > is an overlay relation on Π and ~ is an adjacency relation on Π. We hereafter call the abstract origami simply an origami.
Regarding the overlay and adjacency relations, we do not details them as we dis- cussed elsewhere [7]. We use O to denote a set of origami’s. When we make a fold, we specify which faces we will fold. The set of faces that we are interested in folding is called the set of the faces of concern.
Definition 2.5 (Single-step fold) Let O1, O2 ∈ O where O1 = (Π1, >1, ~1). An origami single-step fold from O1 to O2 is deﬁned as a relation:
O1 RF,r,θ O2
where F ⊆ Π1 is the set of faces of concern, r is a fold ray, and θ is the angle of rotation.

V(O) denotes the set of points in O. When the number of divided faces is k, and r XY , we have:
V(O2) = V(O1) ∪ {Xk, Yk},
where the points Xk, Yk are created in this fold 4 .
Definition 2.6 (Origami construction) Let O1,..., On ∈ O. A fold sequence

O1 RF1,r1,θ1 O2 RF2,r2,θ2 ··· RFn−1,rn−1,θn−1 On

is called an origami construction from O1 to On. We may also write O1 R∗ On.

Huzita’s axiomatization of origami construction
Huzita’s basic folds in brief
Huzita proposed the following operations as the basic folds:
(O1) We can make a fold along a line that passes through given points P and Q. (O2) We can make a fold along the line that superposes given points P and Q. (O3) We can make a fold along a line that superposes two given lines m and n. (O4) We can make a fold along a line that is perpendicular to a given line m, and
passes through a given point P .
(O5) We can make a fold along a line that passes through a given point Q and superposes a given point P on a given line m.
(O6) We can make a fold along a line that superposes a given point P on a given line m and a given point Q on a given line n.
Remark 3.1
When we say that we are given n points, those n points are distinct and they are all on the origami. Likewise, when we are given n lines, those n lines are distinct and they pass through two distinct points on the origami.
In the case of (O3), there exists one or two fold lines.
In the cases of (O5) and (O6), there may be multiple fold lines or none. It is decidable whether a fold line satisfying the properties exists or not.
The statements (O1)∼(O6) are often called Huzita’s axioms in the literature. The statements (O5) and (O6) are not axioms in mathematical sense since we have situations where a fold is impossible to satisfy the properties. To be rigorous, we have to understand the statements (O5) and (O6) together with the above remark (iii) in order to call them axioms.

4 We let X1 = X and Y1 = Y .

Huzita’s axioms in ﬁrst-order language
Let P and Q denote points, and l, m and n denote lines. Corresponding to the statements (O1) ∼ (O6) in the previous subsection, we have the following formulas.


(A1)
(A2)
(A3)
(A4)


(A5)
(A6)
∀P, Q ∃ l OnLine(P, l) ∧ OnLine(Q, l).
∀P, Q ∃ l reflection(P, l) = Q.
∀m, n ∃ l ∀P OnLine(P, m) ⇒ OnLine(reflection(P, l), n).
∀P, m ∃ l ∀Q OnLine(P, l) ∧ (OnLine(Q, m) ⇒
OnLine(reflection(Q, l), m)).
∀P, Q, m ∃ l OnLine(Q, l) ∧ OnLine(reflection(P, l), m).
∀P, Q, m, n ∃ l OnLine(reflection(P, l), m) ∧ OnLine(reflection(Q, l), n).


All the predicates and functions have to be given precise meaning in the proper semantic domain. A rigorous treatment of the semantics of Huzita’s axioms is given in [4]. We give informal meaning to those symbols based on the geometrical intuition, as we go along.
We first fix the domain of interpretation to be the domain of algebraic numbers. We will see shortly that if we represent a line as a term line(a, b, c) that passes through two given points defining the line, we are always able to find the values of a, b and c in formulas (A1) ∼ (A6). However, the values may be complex numbers. In such cases, we can not give geometric meaning in the Euclidean plane. This observation supplements Remark (iii) in Subsection 3.1.
Formula (A1) states that for any points P and Q, there exists a line l such that P is on l and Q is on l. In formula (A2), the predicate reflection(P, l) = Q states that the reflection of a point P in a line l is the point Q.

Huzita’s axioms in rewrite rules
To reason about the computation implicit in the Huzita’s axioms, the description in first-order predicate logic is not ideal. When we prove the correctness of an existentially quantified formula, often we are not only interested in the satisfiability of the formula, but in the substitution made to the existential variables. Obtaining the values instantiated in the existential variables is the intended purpose of the proving, often called solving rather than proving, however.
A rewrite rule clearly serves better for this intention, if we are more inter- ested in computation rather than declarative statements. Let us consider basic fold operation (O1) to begin with. The basic idea in transcribing a first-order formula to a rewrite rule is to define a new relation R(P, Q, l), which is true if OnLine(P, l) ∧ OnLine(Q, l) holds. Namely, we state
∀P, Q, l (R(P, Q, l) ⇐ OnLine(P, l) ∧ OnLine(Q, l)).

This means that for any combinations of values of P , Q and l, if OnLine(P, l) ∧

OnLine(Q, l) holds, then R(P, Q, l) holds. In particular if for any combinations of values of P , Q and l for which formula (A1) holds, then R(P, Q, l) holds. This can be written as a 3-CTRS (type 3 Conditional Term Rewrite System)[10].

foldTh(P, Q) → l ⇐ OnLine(P, l) ∧ OnLine(Q, l).

Here, we have introduced a new function symbol foldTh, and replaced the relation
R(P, Q, l) by the rewrite relation foldTh(P, Q) → l.
We then want to define OnLine as a rewrite rule. At this point we need to commit ourselves to a certain representation of points and lines. In this paper, we use the Cartesian coordinate system to represent points and a linear equation to represent a line. We use constructor symbols point and line to represent them in term structures.
OnLine(point(x, y), line(a, b, c)) → true ⇐ ax + by + c = 0 

To make the equation ax + by + c = 0 always represent a line, we need to impose a constraint on the coefficients a, b, and c. This constraint is stated in the predicate Coeff(line(a, b, c)). One possible definition of Coeff(line(a, b, c)) is the following:

(−1+ b)b = 0 ∧ (−1+ a)(−1+ b) = 0.

A slightly complicated re-reasoning of the above rewrite rule leads to the following rewrite rule.

foldTh(P, Q) → l ⇐ OnLine(P, l) ∧ OnLine(Q, l) ∧ Coeff(l). (O2) is easily transcribed to the following rewrite rule:

	foldBr(P, Q) → l ⇐ reflection(P, l) = Q ∧ Coeff(l), where reflection(P, l) is written as a rewrite rule:

reflection(point(x, y), line(a, b, c))
2  + 2	2 ( +	)
→ point	,
a2 + b2

−2b(c + ax)+ a2y − b2y

a2 + b2	.

Since (O3) is already a formula of implication, transcribing (O3) needs a bit of algebraic manipulation. Let P , l, m, n be point(x, y), line(a, b, c), line(a1, b1, c1), line(a2, b2, c2), respectively. Then the algebraic interpretation of the right-hand side (of ⇒) in formula (A3) is


c2 +
b2(−2b(c + ax)+ a2y − b2y) +
a2 + b2
a (−a2x + b2x − 2a(c + by))
a2 + b2	,

which is equivalent to the formula a'x + b'y + c' = 0, where
a' = −a2a2 + a2b2 − 2abb2
b' = −2aa2b + a2b2 − b2b2
c' = −2aa2c − 2bb2c + a2c2 + b2c2
Let l' be the line line(a', b', c'). Then it is easy to see that
(a', b', c') = −k · (a1, b1, c1) for some k.

From the above formula, we can obtain the following rewrite rules:

foldBrLine(line(a1, b1, c1), line(a2, b2, c2)) → l ⇐ l = line(a, b, c)
∧− a2a2 + a2b2 − 2abb2 + ka1 = 0 ∧ −2aa2b + a2b2 − b2b2 + kb1 = 0 
∧− 2aa2c − 2bb2c + a2c2 + b2c2 + kc1 = 0 ∧ Coeff(l).

Note that the algebraic expressions in the above formula are square-root free. In general, solving the conditional part of this rewrite rule yields two solutions for a, b, c and k, which shows that there are two fold lines that superpose lines m and n.
Similarly, we can obtain the following rewrite rules that correspond to the axioms (O4) ∼ (O6), respectively.
foldPerTh(P, m) → l ⇐
OnLine(P, l) ∧ (OnLine(Q, m) ⇒ OnLine(reflection(Q, l), m)) ∧ Coeff(l). foldThBr(P, Q, m) → l ⇐ OnLine(Q, l) ∧ OnLine(reflection(P, l), m) ∧ Coeff(l). foldBrBr(P, Q, m, n) → l ⇐
OnLine(reflection(P, l), m) ∧ OnLine(reflection(Q, l), n) ∧Coeff(l).
The conditional part of the rewrite rules will become the conjunction of equations when the rules are applied. In order to perform rewriting of the left-hand side to the righthand side of the rewrite rules, we need to solve the system of equations. This can be done either statically or dynamically. By statically, we mean that we can transform the rewrite rule to a new rewrite rule that does not require constraint solving at run time. This will be detailed in the next subsection.
The conditional rewrite system that describes Huzita’s axioms can rewrite the same ground term in more than one way. This behavior indicates that some single- step folds can be performed in more than one way. It can be shown that every ground term can be transformed in at most 3 ways. When the rewriting is non- deterministic, it is desirable to allow the user to view the alternatives and to choose one to proceed to the next fold step of the construction.

Transformation of rewrite rules
In this subsection we will show an example of static transformation of rewrite rules. Rewriting of the term foldBr(P, Q) by the rewrite rule (1) for (O2) requires con-

straint solving of the set of equations
{(−1+ a)(−1+ b) = 0, (−1+ b)b = 0,
−2b (c + ax1)+ a2y1 − b2y1 =



a2 + b2
−a2x1 + b2x1 − 2a (c + by1) =
a2 + b2
y2,

x2 }

for a, b, and c. The solution of the above system is
 a → 1,b → 0,c → −x1 − x2 


if y1 = y2, and


x1 − x2

−x2 + x2 − y2 + y2 



y1 − y2
2 (y1 − y2)

if y1 /= y2. Therefore, the rewrite rule (1) is reduced to
foldBr(point(x , y), point(x , y)) → line(1, 0, −x1 − x2 )

1	2

x1 − x2
2
−x2 + x2 − y2 + y2

foldBr(point(x1, y1), point(x2, y2)) → line(
y1 − y2
, 1, 	1	2	1	2 )
2 (y1 − y2)

If rewriting is performed in a symbolic computation environment such as of Math- ematica [14], the above transformation can be done semi-automatically. So on one
hand it is possible to reduce the run time computing cost by static transformation. We need not solve the same constraints repeatedly.
On the other hand, for theorem proving, we need to maintain the set of equations symbolically. Origami construction is interactive. As our experiences with Eos [8]
show, constraint solving is not prohibitively expensive, even when we use usual laptop computers. Therefore solving constraints dynamically is also feasible.
Formalizing Fold
Now let us consider formalization of the essential part of origami, i.e. fold. Each fold requires the following parameters: the set F of faces of concern, the rotation angle θ (either π or −π in this paper) and the basic fold operation to apply together with appropriate parameters of lines and points given to the operation.
A fold operation can be decomposed into seven computational steps: (F-1) Choose a basic fold operation from among (O1)∼(O6).
(F-2) Find a fold line l according to the fold method.
(F-3) Specify the set F of the faces of concern and the ray r obtained from l. (F-4) Compute the set G of all the faces that are affected by the fold.
(F-5) Divide the faces by l and classify all the obtained faces into “to be moved” and “to be non-moved”.

(F-6) Compute the overlay and adjacency relations.
(F-7) Rotate the “to be moved” faces along r by the angle θ.
In this paper we consider an origami construction where each fold operation is followed by an unfold, so that we always make a fold on a square piece of origami paper. This is the case of the construction of Morley’s triangle. The modeling of the folds in general cases requires the analysis of overlay and adjacency relations on the faces at step (F-4). Then the faces are divided and classified at step (F-5). At step (F-6) the overlay and adjacency relations are computed using the relations computed in the previous origami construction step. Finally, at step (F-7), the “to be moved” faces are rotated. The resulting origami forms layers of faces and exhibits an artistic shape.

Construction of Morley’s triangle
In this section we will show how to formalize the origami construction of Morley’s triangle [2]. Given an arbitrary triangle, Morley’s triangle is the triangle inside the given triangle, formed by the three intersections of neighboring trisectors of the angles of the given triangle. The Morley’s triangle is always equilateral. This is an interesting example of a construction that can be realized with only a piece of origami paper by following simple constructive steps [6]. Since angle trisection cannot be realized by means of a compass and a ruler, it is a surprising result, which shows that an origami construction exceeds the capabilities of the Euclidean construction by the compass and ruler.

Overview of the construction
Figure 2 illustrates the construction of Morley’s triangle. We need 28 fold steps to obtain Morley’s triangle. The first four steps are preparation of the construction. Morley’s triangle is clearly marked in thick solid line (red if colored) in O29. Suppose we are given an initial origami ABCD with a point E. The thin solid line segments (light brown if colored) EA and EB in Fig. 2 are shown for the convenience of readers, and are not part of the construction. Let this origami be O5. The construction proceeds by trisecting the internal angles of ΔABE. The points B1, C1 and S are the intersections of the neighboring trisectors. Morley’s theorem states that ΔB1C1S is equilateral.
The construction is described as follows:


O5 R
−→ O6 R
−→ O7 R
−→ O8 R	−→

{ABCD},FG 
{GFAB},GF
{GFAB},HI
{IHDA},IH


O9 R	−→ O10 R	−→
{FGAB},AL	{ABL},LA


O11 R
−−→ O12 R
−−→ O13 R ··· R O29

{ABL},AM	{ABM},MA 
Here we omit θ since θ is always π. J is specified by the set of the names of the














Fig. 2. Origami construction of Morley’s triangle

faces of concern. Here, the name of ⟨Pi,..., Pj ⟩ is Pi ··· Pj.

Trisection of an angle


{−1+ η3, (−1+ b8)b8, (−1+ a8)(−1+ b8), (−1+ b9)b9, (−1+ a9)(−1+ b9), c9 + a9x1 + b9y1,
2a9c9 + (a92 + b92)x6, c9 + a9x2 + b9y2, y2,
c8 + a8x3 + b8y3, b92(x3 − x8) − a9(2c9 + a9(x3 + x8)+ 2b9y3), c8 + a8x4 + b8y4,
— 1+ x4, 2b9c9(x3 − x4) − 2a9c9(y3 − y4)+ (a92 + b92)(−x4y3 + x3y4),
— 1+ x5, a92y6 − b9(2c9 + 2a9x6 + b9y6), 2b9c9 + (a92 + b92)y6,
b92x6 − a9(2c9 + a9x6 + 2b9y6), −1+ x7, x7y6 − x6y7, a92(y3 − y8) − b9(2c9 + 2a9x3 + b9(y3 + y8)), x8y5 − x5y8,
a8, −1+ y1, x3, b8 + 2c8, −b9(b9 + 2c9)x13 + a9(a9x13 + 2(b9 + c9)y13)}
We have A(0, 0), B(1, 0), C(1, 1), D(0,1), E(x13, y13), M(x5, y5), L(x7, y7), G(x4,
y4), F(x8, y8), H(x1, y1), I(x2, y2). Lines GF, IH are represented by line(a8, b8, c8), line(a9, b9, c9), respectively.
Fig. 3. Premise equations for the proof of the trisection of ∠EAB

The steps from O5 to O13 correspond to the construction of the trisector of
∠EAB. The rest is for constructing the other two trisectors. Let us see in more detail how the computation proceeds. The rewrite rules applied in the steps from O5 to O13 is foldBr, unfold, foldBrBr, unfold, foldTh, unfold, foldTh and unfold.
During the construction, the system solved the constraints numerically, and at the same time it saved the constraints in symbolic expression. Therefore, at the step where O13 is obtained, we can generate the set C of the equations, and can prove
that we indeed have constructed the trisector. The set C is given in Fig. 3. We abuse the notation of a set of polynomials and identify it with the system of equations.
The conclusion of the proposition that we want to verify must then be formu- lated. For the proof based on the Gro¨bner bases method, we need the statement about the trisection in terms of polynomials. We use the square of sin of concerned angles that is defined by Spread in rational trigonometry [13]. Then the conclusion is formulated as follows:


Spread(∠
LAB) =	y72
x7 + y7

Spread(∠
MAL) =	(x7y5 − x5y7)2
(x	+ y  ) (x	+ y  )

5	5	7	7

Spread( EAM) =	(x5y13 − x13y5)2
13	13	5	5
, and

Spread(∠LAB) = Spread(∠MAL) = Spread(∠EAM)

From the above, we obtain D given in Fig. 4.
We want to prove
C ⇒ D.
Let C = {c1,..., cn} and D = {d1,..., dm}. The proof of proposition (2) is by contradiction using the theory of Gro¨bner bases. We compute the Gr¨obner basis of the set of polynomials
{c1,..., cn, (κ1d1 − 1) ··· (κmdm − 1)} where κ1,..., κm are newly introduced slack variables.
{−y5(x72y5 − 2x5x7y7 − y5y72),
— (x7y13 − x13y7)
(x52(x7y13 + x13y7) − y52(x7y13 + x13y7)+ x5(−2x13x7y5 + 2y13y5y7))}

Fig. 4. Conclusion equations for the proof of the trisection of ∠EAB
We consider the set of the polynomials (3) as the system of equations. The non-existence of its solution implies the correctness of the proposition. Namely, if the reduced Gr¨obner basis of (3) is {1}, the proposition is proved.
Eos has an interface to assist computational origamists to perform the proofs.
To compute the reduced Gro¨bner basis of (3), it took 0.33 seconds for the proof of the trisector of ∠EAB on a Pentium 1.2 GHz laptop computer equipped with 1 GB memory running under Windows XP.
After trisecting the angles and proving the correctness of the construction of the trisectors, we can go on to prove that the triangle ΔB1C1S is equilateral. The triangles formed by the three intersections of neighboring trisectors of the angles are not necessary inside the given triangle. Out of the 27 possible triangles, 18 of them are equilateral. Origami experiments are reported in [6] and thorough geometrical investigations are given in [15,12]. For this paper we only give the timing of the proof for particular origami construction when E lies at some point inside the origami. It took 84.49 seconds of computation by the same laptop computer mentioned above.
Programming language supports for origami
We have seen the model of computation for computational origami. The model comes with a formal language to reason about the model. However, the formal language is not sufficient for end-users, i.e. origamists, to explore the possibilities of computational origami. The computational origami environment Eos developed by us assists the user to perform origami construction and reason about geomet- ric properties. The programming and computational capabilities described in this paper are an abstraction of what have been implemented so far. We need more programming supports for computational origami.

In this section we briefly discuss what we already have and the desiderata for further development. Eos provides primitives for the following operations:
Simulation of the origami construction: The realization of the single-step fold O1 RF,r,θ O2 is achieved by one of the Huzita’s axioms, together with appropriate parameters and the additional information needed in the formalization of the fold. For example, the fold using (O1) is realized by a call HFold[A, Along → {P, Q}] and the fold using (O2) is realized by HFold[P, Q]. In the latter case, point P is brought to point Q. In this way, the origamists do not have to know the faces of concern. In the former case the origamists must give point A as the first parameter, such that the system can identify the face of concern. The system processes the input specification, and computes G and r, and constructs the data structure O2 for the origami produced by the single-step fold.
Visualization of the origami O2 produced by single-step folds O1 RF,r,θ O2.
Maintaining an algebraic representation of the origami construction, that can be used for proving geometric theorems about origami.
Providing a set of functions that enable origamists to compute and reason about the geometric objects used in origami.
The implementation of these capabilities requires the support for conditional term rewriting, capabilities of symbolic computation such as Gro¨bner basis computation and manipulation of polynomials, and graphics processing. Eos is implemented in Mathematica, since Mathematica is based on higher-order term rewriting with functionalities that we described above.
As our experiences grow with many examples of origami’s, more functionalities have become needed. From programming point of view, typing and object orienta- tion are highly desirable. However, typing of geometrical objects is non-trivial since the type may change as the shape of an object gets degenerated; for instance a polygon becomes a line when the number of vertices becomes 2. Features proposed by Liang and Wang [9] would have to be taken into account. For computational origami the desired functionalities are also for producing high-quality art pieces of origami. We expect to have better human friendly interface which can be obtained by integrating off-the-shelf software components.

Conclusion
We have shown how the origami construction can be modeled by a sequence of fold steps. At each fold step, an origami structure is transformed to a new structure. The fold line along which the fold is made is computed by a 3-CTRS. The rewrite rules of 3-CTRS are derived from Huzita’s axioms. The application of the rewrite rules requires constraints solving in order to satisfy the conditions of the rewrite rules.
The numerical solutions are used to simulate the construction of origami, and to visualize the origami shapes at each step. The accumulated constraints are used for proving the geometric properties of the constructed origami.

We argued for the usefulness of the modeling of the construction as a rewrite sequence, and discussed the language features that are essential in the geometrical modeling of origami.
The formalization of origami is an important step towards the study of reverse problems of origami (e.g., finding a shape from the fully unfolded origami with creases), exploration of new construction methods of origami pieces and the study of foldability beyond the power of Huzita’s axiomatization.

References
R. C. Alperin and R. J. Lang. One-, two, and multi-fold origami axioms. In Proceedings of 4th International Conference on Origami, Science, Mathematics and Education (4OSME), 2006.
A. Bogomolny. Morley’s Miracle. 1996. http://www.cut-the-knot.org/triangle/Morley, ⃝c 1996-2005.
R Geretschl¨ager. Geometric Constructions in Origami. Morikita Publishing Co., 2002. In Japanese, translation by Hidetoshi Fukagawa.
F. Ghourabi, T. Ida, H. Takahashi, M. Marin, and A. Kasem. Logical and Algebraic View of Huzita’s Origami Axioms with Applications to Computational Origami. In Proceedings of the 22nd ACM Symposium on Applied Computing, pages 767–772. ACM Press, March 2007.
H. Huzita. Axiomatic Development of Origami Geometry. In H. Huzita, editor, Proceedings of the First International Meeting of Origami Science and Technology, pages 143–158, 1989.
T. Ida, M. Marin, and H. Takahashi. Computational Origami of a Morley’s Triangle. In M. Kohlhase, editor, Proceedings of 4th International Conference on Mathematical Knowledge Management (MKM 2005), volume 3863 of LNCS, page 267. Springer.
T. Ida, H. Takahashi, M. Marin, and F. Ghourabi. Modelling origami for computational construction and beyond. In O. Gervasi and M. Gavrilova, editors, International Conference on Computational Science and Its Applications 2007 (ICCSA 2007), volume 4151 of Lecture Notes in Computer Sciences, pages 653 – 665. Springer-Verlag Berlin Heidelberg.
T. Ida, H. Takahashi, M. Marin, A. Kasem, and F. Ghourabi. Computational Origami System Eos. In Proceedings of 4th International Conference on Origami, Science, Mathematics and Education (4OSME), page 69, 2006.
T. Liang and D. Wang. Towards a Geometric-Object-Oriented Language. In Automated Deduction in Geometry, volume 3763 of Lecture Notes in Computer Science, pages 130–155, 2006.
A. Middeldorp and E. Hamoen. Completeness results for basic narrowing. Applicable Algebra in Engineering, Communication and Computing, 5:213 – 253, 1994.
F. P. Preparata and M. I. Shamos. Computational Geometry: An Introduction. Texts and Monographs in Computer Science. Springer-Verlag, 1985.
D. Wang. Elimination Practice: Software Tools and Applications. Imperial College Press London, 2004.
N. J. Wildberger. Divine Proportions. Wild Egg Pty Ltd, 2005.
S. Wolfram. The Mathematica Book. Wolfram Media, 5th edition, 2003.
W.T. Wu. Basic principles of mechanical theorem proving in elementary geometry. Journal of Automated Reasoning, 2:221–252, 1986.
