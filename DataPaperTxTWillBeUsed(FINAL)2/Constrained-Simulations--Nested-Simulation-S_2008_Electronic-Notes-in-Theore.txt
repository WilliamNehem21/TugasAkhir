Electronic Notes in Theoretical Computer Science 206 (2008) 41–58	
www.elsevier.com/locate/entcs

Constrained Simulations, Nested Simulation Semantics and Counting Bisimulations
David de Frutos Escrig1 ,3
Departamento de Sistemas Informa´ticos y Computacio´n Universidad Complutense de Madrid
Madrid, Spain
Carlos Gregorio Rodr´ıguez 2 ,4
Departamento de Sistemas Informa´ticos y Computacio´n Universidad Complutense de Madrid
Madrid, Spain

Abstract
Nested simulations define an interesting hierarchy of semantic preorders and equivalences in which every semantics refines the previous one and it is refined by the following. This nested nature provides a fruitful framework for the study of the formal meaning and the properties of concurrent processes. In this paper we present the notion of constrained simulation that, although rather simple, allows us to find general results for a wide family of semantics. In particular, we provide an axiomatization for both the preorder and the equivalence induced by any constrained simulation. Nested simulations are constrained simulations and therefore our results can be instantiated directly to them. Besides, constrained simulations suggest the definition of a new family of semantics, generalised nested simulation semantics, constructed over the base of any order relation, instead of plain simulation. Finally, we conclude the study of the (generalised) nested semantics defining a generalisation of bisimulation relations, counting bisimulation, that allows us to define a characterisation of nested semantics in terms of a bisimulation-like game.
Keywords: Process Preorders and Equivalences, Bisimulations, Nested Simulations, Constrained Simulations, Axiomatization of Semantics.


Introduction
The behaviour of concurrent processes is usually described by means of labelled transition systems (lts) and a number of different semantics have been defined in

1 Partially supported by the MCyT project DESAFIOS TIN2006-15660-C02-02 and the project PROMESAS-CAM S-0505/TIC/0407.
2 Partially supported by the MCyT project WEST TIN2006-15578-C02.
3 Email: defrutos@sip.ucm.es
4 Email:cgr@sip.ucm.es

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.074

the literature in order to assign the formal meaning of processes. Every seman- tics determines which aspects of the behaviour of processes are of importance and which are not. Mainly because of the generality and diversity of the applications of process algebras, there is no prevailing semantics notion but rather there are a number of different proposals that have arisen from diverse approaches, contexts and applications.
We consider that this variety of process semantics is a good sign of the applica- bility of process algebras, just proving the healthiness of the formalism. However, the diversity of semantics makes difficult to choose the one that suits a given appli- cation better and therefore, the comparative study of semantics is an essential field of study.
In [10] many semantics were presented in a uniform way and compared with each other according to their distinction power. The result is the well known linear time- branching time spectrum. Furthermore, for most of the semantics also a complete axiomatization for a basic language of processes was provided.
One of the semantics in the linear time-branching time spectrum spectrum is the nested simulation semantics, that was introduced in [11]. That paper was devoted to the study of a format of rules in Plotkin style to define structured operational semantics, that was called tyft/tyxt. All the operators defined within this format preserve the strong bisimulation equivalence and thus bisimulation is a congruence with respect to them. The 2-nested simulation semantics was proved to be a char- acterisation of the complete trace congruence induced by the operators in pure tyft/tyxt format. Besides, the nested simulations define an interesting hierarchy of

nested semantic preorders and equivalences. Any of the preorders ⊂
i
induces an

equivalence, =i, and the preorder ⊂
i+1
is defined only over processes that are =i-

equivalent. That is, we could decide to work in a given semantics level (say i) which
would define the set of classes of equivalent processes. Then, in order to compare

the processes within these classes we could use the next semantic level, ⊂
i+1
, as an

order relation that induces a new equivalence relation =i+1. Therefore, by means
of nested semantics we get a whole family of finer and finer semantics defined in a common framework.
In order to capture the common properties of all the nested simulation semantics we introduce the notion of constrained simulations, which are just plain simulations to whom we impose the additional constraint of being related by a given relation
C. Although this notion is rather general it has been a surprise for us not to find it anywere at the available literature. We have proved an interesting collection of results valid for any constrained simulation semantics which open the door for a nice algebraic theory. In particular, we have obtained a simple axiomatization for both the preorder and the equivalence induced by any constraint.
Nested simulations turn out to be constrained simulations and therefore all the results mentioned above apply to them. Moreover, the study of constrained simu- lations suggests a natural generalisation of the classical definition of nested simu- lations. As we will see, we have defined a new family of semantics, the generalised

nested simulation semantics, which have similar properties and can be studied all together. This family extends the possibilities of choosing the right semantics for a given model or application while keeping in the framework of the constrained simulations.
Calling back Van Glabbeek’s linear time-branching time spectrum, one of the most important of all the semantics there is the bisimulation semantics. Bisimula- tion is a mathematically elegant concept which is the basis of coalgebraic theories. Bisimulation is the strongest of the semantics in the spectrum, thus whenever two processes are bisimilar they are also related under any of the other semantics. But for the same reason, it can be considered too strong in many occasions. One of the main virtues of bisimulation is that there are efficient algorithms [18,15] to de- cide bisimulation equivalence and several tools that can effectively check process bisimilarity [5]. In order to understand bisimulation semantics, its game theory presentation is rather useful, see for instance [19]. The idea is to present the pairs of transitions of the compared processes as the plays of two players. The first player (the attacker) has to try to find a transition that cannot be replied by the other (the defender). Then we have that the defender has an strategy to win the game if and only if the given processes are indeed bisimilar.
Part of our recent research has focused on the search of a general framework based on bisimulation in which to define weaker equivalences preserving, at the same time, the coinductive flavour of bisimulation. This brings us new possibilities both from the theoretical and the practical point of view: On the one side, we can use coinductive methods that have proved to be mathematically powerful and elegant; on the other side, the possibility of using the tools to decide bisimilarity for other semantics (see for instance, [4]). In [6,8] we defined global bisimulations in which the players could modify somehow the transition system of the processes, by means of what we called global transitions. In a more algebraic setting, by using bisimulations up-to, in [7] we presented a systematic way to characterise every semantics in the linear time-branching time spectrum coarser than the ready simulation as a bisimulation-like game.
In this paper, devoted to the study of the nested semantics, we conclude by pro- viding a framework, the counting bisimulation, that can be used to get a coinductive, bisimulation like characterisation, for the family of generalised nested simulation se- mantics.
The rest of the paper is structured as follows. In Section 2, the preliminar- ies, notation, and basic definitions are presented. In Section 3, we introduce our constrained simulations that allow us to prove some general results, as the exis- tence of a conditional axiomatisation for any member of the family of semantics. These results are particularised in Section 4 for the classic nested simulation se- mantics. Constrained simulations also suggest a generalisation of nested simula- tions semantics, that is studied in Section 5. Section 6 is devoted to the definition of a bisimulation-like game for the (generalised) nested simulations semantics, the counting bisimulation game. We sum up our conclusions in Section 7, where we also discuss some lines for future work on the subject.

Preliminaries
Although some of the results in this paper can be extended to infinite processes, we will mainly concentrate on finite processes represented by trees, which just corre- spond to those in the class BCCSP.
Definition 2.1 [10] Given a set of actions Act, the set of BCCSP processes is defined by the following BNF-expression:
p ::= 0 | ap | p + q
where a ∈ Act. 0 represents the process that can perform no action. For every action in Act, there is a prefix operator that defines the sequential execution of actions. Finally, + is called the choice operator and denotes the election between two processes.
The operational semantics for BCCSP terms is defined by a labelled transition system (lts) and is given by the rules in Figure 1. Each BCCSP processes has as semantics an acyclic lts that can be unfolded to get a finite tree. Then, the depth of a process is the depth of the corresponding tree.
It is true that if we simply consider the transitions, then the obtained lts is a directed acyclic graph, but where each process appears only once, so that it is possible to have several arcs (transitions) reaching the same node (process). But since the graph is acyclic, by unfolding it we get an equivalent tree where each node appears as many times as ways we have to reach it by a proved computation, where we distinguish two transitions that have been generated in a different way using the SOS rules. It is easy to prove that this tree is also equivalent to the syntactic tree of p, once we consider that + operator is commutative and associative.
Along the paper some usual notations for lts are used. We write p −→ if there
exists a process q such that p −a→ q and, on the opposite, we write p −a→ if there
exists no process q such that p −a→ q. For a string of actions σ = a a ··· a ,
1 2	n

ai ∈ Act, p −σ→ q means that there exist processes q
... q
n−1
, such that p  a→1

a2	a3	an
q1 −→ q2 −→ ··· qn−1 −→ q. The function I calculates the set of initial actions of
a process, I (p)= {a | a ∈ Act and p −a→}.


ap −a→ p
p −a→ p'
p + q −a→ p'
q −a→ q'
p + q −a→ q'


Fig. 1. Operational Semantics for BCCSP Terms
As usual, trailing occurrences of the constant 0 are omitted, we write a instead of a0. By using	as a shorthand for multiple choice (which is commutative and
associative) we can define any process as Σi Σj aipij. A process aq' is a summand of
the process q if and only if q −a→ q'. Given a ∈ Act we define p|a as the (sub)process we get by adding all the a-summands of p. That is, if p =	a p , then
p|ai = Σj aipij.

An important part of the classic behavioural semantics that were thoroughly classified in [10] are based on the simple concept of simulation. Besides, simulation is also in the core of the definition of nested semantics.
Definition 2.2 A binary relation S over processes is a simulation, if pSq implies that:
For every a, if p −a→ p' there exists q', q −a→ q' and p'Sq'.
We say that process p is simulated by process q, or that q simulates p, written
p ±S q, whenever there exists a simulation, S, such that pSq.
Bisimilarity is a capital notion in process theory and it is the cornerstone for one of the targets of our work: providing coinductive characterisations of process semantics.
Definition 2.3 [17] A binary relation R is a (strong) bisimulation if for all p, q
processes such that p R q, and for all a ∈ Act, the following properties are satisfied:
Whenever p −a→ p' there exists some q' such that q −a→ q' and p' R q'.
Whenever q −a→ q' there exists some p' such that p −a→ p' and p' R q'.
Two processes p and q are bisimilar, written p =B q, if there exists a bisimulation containing the pair ⟨p, q⟩.
As it is well known, bisimularity admits multiple characterisations. In the rest of the paper we will make an extensive use of its axiomatisation, that is given in Figure 2.
(B1)	x + y = y + x
(B2) (x + y)+ z = x + (y + z) (B3)	x + x = x
(B4)	x + 0 = x

Fig. 2. Axiomatisation for the (Strong) Bisimulation Equivalence
We are interested in semantic preorders for processes and some of the essential properties are gathered under the name of behaviour preorder.
Definition 2.4 A preorder relation ± over processes is a behaviour preorder when it is weaker than the bisimulation equivalence and it is a precongruence with respect to the prefix and choice operators, i.e. if p ± q then ap ± aq; and if p ± q then p + r ± q + r.
This definition is quite natural and all the preorders in the linear time-branching time spectrum are indeed behaviour preorders. For the sake of simplicity, we often use the symbol ± to represent the preorder relation ±−1.
In [7] we introduced the concept of bisimulation up-to a given relation, in order to get coinductive characterisations of equivalence relations.

Definition 2.5 Let ± be a behaviour preorder, we say that a binary relation S
over processes is a bisimulation up-to ±, if pSq implies that:
For every a, p −a→ p' , there exist q' and q' , q ± q' −a→ q' and p' Sq' ;
a	a	a	a	a
For every a, q −a→ q' , there exist p' and p' , p ± p' −a→ p' and p' Sq' .
a	a	a	a	a
Two processes are bisimilar up-to ±, written p ± q, if there exists a bisimulation up-to ±, S, such that pSq.
In [7] we have proved that every semantics in the linear time-branching time spectrum under the ready simulation can be characterised in terms of the adequate bisimulations up-to. These characterisations are based on the preorder defining the corresponding equivalence and the axioms defining such a preorder can be used as rules that generate the global transitions that weaken the bisimulation game as required.
We also proved in [7] that other semantics can be characterised with bisimula- tions up-to, as it is the case for the n-nested simulation semantics. However, given that there exists no finite unconditional axiomatization for the n-nested simulation semantics, we cannot take advantage of their axioms. We overcome this problem in Section 6, where we get a coinductive characterisation of the nested simulation semantics based on counting bisimulations and bisimulations up-to.

Constrained Simulations
C-constrained simulations are just plain simulations to which we impose that their pairs should also be related by the constraint C.
Definition 3.1 Given a relation C over BCCSP processes, a relation SC is a C- constrained simulation, if pSCq implies:
For every a, if p −a→ p' there exists q', q −a→ q' and p'SCq', and
pCq.
We say that process p is C-simulated by process q, or that q C-simulates p, written
p и C q, whenever there exists a C-constrained simulation SC, such that pSCq.
Since we want to characterise behaviour preorders by using C-simulations it is reasonable to impose on these simulations the condition of being themselves be- haviour preorders, that is guaranteed whenever the constraints are also behaviour preorders. Given that the operators in our basic algebra BCCSP are those gener- ating finite trees, this condition is quite natural and the results we will prove based on it are indeed rather general.
Example 3.2 Let us briefly present several examples of constrained simulations, all of them corresponding to relations being behaviour preorders.
Ordinary simulation is a constrained simulation taking as C the universal relation,
xCy for every x and y.
Ready simulation is just the I-constrained simulation, where pIq ⇔ I (p)= I (q).

Ready simulation is perhaps the most important C-constrained simulation but we can also achieve a greater discriminatory power. Let us consider, for instance,
±S to be the simulation preorder and C =±−1; then 2-nested simulations [11] are just the corresponding class of C-constrained simulations.
For finite processes 5 C-similarity can be inductively defined by applying the following characterisation:
Proposition 3.3 Let p, q be BCCSP terms, then p и C q iff
for all p −a→ p' there exists q' such that q −a→ q' with p' и C q', and
pCq.
Proof. The left to right implication is trivial by definition. For the other direction we take as S the relation defined by the right hand side of the statement. Then S is a simulation since we have just proved that p и C q implies pSq. Moreover, by definition, S is C-constrained.	 
C-constrained similarity, и C , can be conditionally axiomatized in a simple way.
For any constraint C we just need to consider the axiom
(PC )	xCy ⇒ x ± x + y

We define the axiomatization PC as the set of axioms obtained by adding the axiom PC to the set of axioms that characterises bisimulation equivalence (Figure 2), PC = {B1, B2, B3, B4, PC }. As usual, we write PC ▶ p ± q when the relation p ± q is provable from PC using the rules of inequational logic. We next prove that PC is sound and complete with respect to и C .
Theorem 3.4 For every constraint C being a behaviour preorder, we have that
PC ▶ p ± q ⇔ p и C q

Proof. Soundness. Bisimilarity axioms are sound for both the relation C and for the C-constrained simulation preorder. Therefore, we only need to prove that axiom (PC ) is also sound. Process p + q can obviously simulate p, and since we have pCq and C is a congruence with respect to choice, we also have pC(q+p) and we conclude that p и C p + q.
Completeness. By induction on the depth of processes. If p = 0 then 0Cq
and, applying (PC), (B1) and (B4), PC ▶ 0 ± q. Let us consider now the general case p = Σ aipi. On the one hand, if p и C q then pCq and we can use (PC ) to
ai	ai
prove that PC ▶ p ± p + q. On the other hand, whenever p −→ pi then q −→ qji
with pi и C qj ; by induction hypothesis we have PC ▶ pi ± qj , therefore we have
→	i	i

5 In fact the proposition itself is valid for arbitrary processes, but in the case of infinite processes it cannot be turned into an inductive definition.

PC ▶ q +	aipi ± q +	aiqji , or equivalently PC ▶ q + p ± q. Combining both results we get PC ▶ p ± q + p ± q.	 
We next study the axiomatization of the equivalence relation associated to the
→C	и C	N C
C-constrained simulation, ← =→	∩ ← . We propose the following axiom for
each constraint C:
(EC)	xCy ⇒ a(x + y)= a(x + y)+ ay
Adding the axiom EC to the set of axioms that characterises bisimulation equiva- lence (Figure 2), we get the set EC = {B1, B2, B3, B4, EC }. We write EC ▶ p = q when the equation p = q is provable from EC.
C
We next prove that EC is sound and complete with respect to ← . However, in
this case, in order to prove these results, the constraint relation has to be symmetric, that is, it has to be a behaviour equivalence.
Theorem 3.5 For every constraint C being a behaviour equivalence, we have that
C
EC ▶ p = q ⇔ p ←  q
Proof. Soundness. Let us just prove that (EC ) is sound. Whenever pCq we also have EC ▶ a(p + q)= a(p + q)+ aq. We have to prove that a(p + q) и C a(p + q)+ aq
and a(p + q)+ aq и C a(p + q). Both sides can trivially simulate each other and using that C is a behaviour preorder, from pCq we derive a(p + q) C a(p + q)+ aq and we immediately conclude that the first one is a C-simulation. In the second,
case to have a C-simulation we need to prove both a(p + q)+ aq C a(p + q) and qC(p + q). As before, from pCq we derive a(p + q) C a(p + q)+ aq and, since C is symmetric, we conclude a(p + q)+ aq C a(p + q). For the later, since C is symmetric we have qCp and then qC(p + q). Thus both simulations are indeed C-constrained. Completeness. The proof of the completeness of the axiomatization of the simu- lation equivalence in [10] (Section 17.2) can be transferred without any changes just checking the additional proof obligations imposed by the condition in the axiom (EC ).	 
It is interesting to note that the cases in which C is not symmetric are not completely excluded from the result above.
Definition 3.6 We say that two constraints C1 and C2 are cs-equivalent, what we denote by C1 ∼ C2, iff they define the same C-constrained similarity relation, that
is и C1 =и C2 .
→	→
Next proposition is just a snapshot of a nice algebraic theory that can be devel- oped around constrained simulations and cs-equivalence.
Proposition 3.7 For any behaviour preorders C, C1 and C2 we have:
C1 ∼ C2 ⇒ (C1 ∩ C2) ∼ C1.

C ∼и C and и C is the smallest C-simulation that is cs-equivalent to C.
→	→
If C1 ∼ C2 and C1 ⊇ C ⊇ C2, then C ∼ C1.
For the simulation preorder ±S we have that C ∼ (C ∩ ±S).
Example 3.8 Next we present some illustrative examples of cs-equivalent con- straints.
Let us consider the classical simulation preorder, ±S. As we saw in Example 3.2,
±S=и U , where U is the universal relation, xUy for every x and y. On the
other hand, if we use ±S as constraint, it is immediate to see that ±S=и±S and
therefore U ∼±S, but while U is symmetric, ±S is not.
Taking the constraint I⊇ given by pI⊇q ⇔ I (p) ⊇ I (q), we have that ready simulation was originally defined in [3] as и I⊇ , but it is well known that it also
coincides with и I , see for instance [10]. Again, I is symmetric, I⊇ is not, and
I ∼ I⊇.
In a similar way, we can define the 2-nested simulation as a simulation constrained using either ±−1 or the equivalence relation ±−1 ∩ ±S.
S	S
From the examples above, one could guess that any constraint might be cs- equivalent to some other symmetric constraint. This is indeed the case for any “interesting” constraint we have found, but in general it is not true, as the following counterexample shows.
Example 3.9 If we consider the behaviour preorder ± defined by the axioms of bisimulation equivalence (Figure 2) together with the axiom x ± x + aa, where a represents any arbitrary action in Act, we can check that there is no symmetric constraint cs-equivalent to ±.

Nested Simulation Semantics
Nested semantics were originally defined by Groote and Vaandrager in [11], for arbitrary labelled transition systems. But since we are considering BCCSP terms we will use instead the following definition:

Definition 4.1 [2] For n ≥ 0, we define the relation ⊂
n
inductively over BCCSP

terms thus:

p ⊂
0
p ⊂
q for all p, q,
q iff pRq for some simulation R with R−1 included in ⊂

→n+1
Let us note that ⊂
1
→n
is in fact the simulation preorder, that we usually denote by

±S. Besides, from the results in [11] we can give an alternative definition of nested
simulation semantics.

Definition 4.2 For n ≥ 1, we define the relation ⊂
n
inductively over BCCSP

terms as follows:

p ⊂
1
p ⊂
q iff p ±S q,
q iff pRq for some simulation R included in «n

→n+1
As we have already commented on Example 3.2, simulations are constrained simulations under the universal relation U , given by xUy for every x and y, that is,
⊂ =и U . Then 2-nested simulations are also constrained simulations, so that we
1

have ⊂ = и( ⊂
2
)−1
= и  1 , and in general, for the n + 1 nested simulation pre-

order we have ⊂	= и( ⊂
n+1
)−1
= и n . Therefore, all the results in Section 3 are

applicable for these semantics. In particular, we have a conditional axiomatisation
for the n-nested simulation semantics given by the axiom
(Ans)	y ±n x ⇒ x ±n+1 x + y
together with the axioms defining bisimulation equivalence (see Figure 2). As a matter of fact, this is the same axiomatisation already proved to be complete for the case of 2-nested simulation preorder in [1]. There, they also enunciate the generalisation for the case of n-nested simulation, although the proof was omitted. Although this is a subtle point, the interested reader can check that our proof (see Theorem 3.5) although being more general is in fact simpler, since we do not need to use any particular property of the nested simulations ordering, but just the fact that it is a constrained simulation.
If we consider n as a parameter in axiom (Ans), we see that we need a single axiom to characterise all the nested simulation preorders in a common framework. To complete the axiomatisation we can add the following unconditional axiom char- acterising the simulation preorder,
(As)	x ±1 x + y
but if we prefer a more symmetrical treatment of these relations we can also take
U =±0 as the foundation of our construction, and then we only need
(Au)	x ±0 y
The same is true for the n-nested simulation equivalences, that can be axioma- tised by means of a single axiom
(Ens)  x =n y ⇒ a(x + y) =n+1 a(x + y)+ ax based on the inconditional axiom (EU ) x =0 y.
As we have seen, our results on constrained simulations are quite general and can be applied to many simulation preorders (see Example 3.2) from plain simulation to any of the n-nested simulations. However, for simulation, complete simulation,

and ready simulation preorders there exist non-conditional axiomatisations (see, for instance, [10]). Instead for the n-nested simulations it is impossible for any n ≥ 2 to find such a non-conditional axiomatisation [2]. We consider that it could be interesting to investigate in which cases such a non-conditional axiomatisation exists and when they could be systematically generated from the conditional ones obtained as instantiations of our general axiomatization for constrained simulations.


Generalised Nested Simulation Semantics
After the results presented in Section 3, showing the regularity of the constrained simulations, Definition 4.2 of nested simulations can be naturally generalised. The new definition we propose, while keeping the nesting of simulations, is parameterised in its first floor by any behaviour preorder R.

Definition 5.1 Given a behaviour preorder R, for n ≥ 1, we inductively define the
n-nested R-simulation relation, denoted by ⊂ R, as follows:
n
p ⊂ R q ⇔ pRq
1

p ⊂ R
n+1
q ⇔ pSq for some simulation S included in «R


We denote by «R the equivalence relation induced by the preorder ⊂ R, that is,
n	→n
«R = ⊂ R ∩ ( ⊂ R)−1.
n	→n	→n
The next proposition proves the preservation of the properties of nesting seman-
tics for the generalised n-nested R-simulation semantics. In fact, this proposition also justifies that our Definition 5.1 is indeed a generalisation of Definition 4.2. In general we would not get always these pleasant properties generalising Definition 4.1, although it would be enough to impose to R the condition of being an equivalence relation in order to satisfy the properties stated in Proposition 5.2, starting from a generalisation of Definition 4.1.

Proposition 5.2 For any behaviour preorder R and for all n ≥ 1 we have:

⊂ R
→n+1
⊂ R
→n+1
⊂ R
→n
⊆ ( ⊂ R)−1
n

«R n+1
⊂ R
→n+1
⊆ «R
⊂ R


⊂(R∩R−1)

for all n ≥ 2 we have	=
n	n

These results allow us to define a translation from n-nested R-simulations into

constrained simulations that will be useful:
Nested	Constrained	Nested	Constrained

⊂ R	⇔	R
1
⊂ R	и  R
«R	⇔	R ∩ R−1
«R	«  R

1
→2	→	2
.	.
R	 R	R

⊂
→n+1
и n	«R
→	n+1
⇔	«  n

Clearly, any n-nested R-simulation relation is a constrained simulation. Taking as R the simulation relation we get the classical nested simulation semantics, that we denote ⊂ S . But we can define many other semantics. For instance, if we take as
n
R the trace preorder, then we get a completely new hierarchy of nested semantics,
⊂ T , the n-nested trace simulation semantics.
n
As an illustrative example, let us briefly study the relationships between the two
families of nested semantics ⊂ S and ⊂ T . First we give a very simple proposition
→n	→n
that holds for any pair of constrained simulations.
Proposition 5.3 Let R and S be behaviour preorders, whenever R ⊆ S we have also и R⊆ и S.
→	→
Then we can state the following result that relates the members of the two families of semantics introduced above.
Proposition 5.4 For all n ≥ 1 we have
⊂ S ⊆ ⊂ T ,

→n
⊂ T
n+1
→n

⊆ ⊂ S. n

Proof. We prove only the first statement, since the proof of the second is rather similar. We proceed by induction on n. For n = 1 we have to prove that S ⊆ T , what is well known. In the general case, by induction hypothesis, we have

⊂ S ⊆ ⊂ T , and therefore «S
⊆ «T ; to prove that ⊂ S
⊆	⊂ T
we use the

→n	→n
n	n	→n+1
⊂ S	и  S
→n+1
⊂ T

и  T

translation into constrained simulations:
→n+1⇔ →
n and →
⇔
n+1
n , and

applying Proposition 5.3 we conclude the proof.	 
Once again we have shown how by working on the general framework of con- strained simulations we get a simple and general proof. As an immediate corollary of propositions 5.4 and 5.2 we get the nice diagram in Figure 3.
In the same way as we have defined the brand new family of nested trace simu- lation semantics we could lift any of the preorders in the linear time-branching time spectrum to the corresponding family of nested semantics. A trivial generalisation of the first statement of Proposition 5.4 tells us that the inclusion relation defined



⊂ S ←− ⊂ S
1	2
←− ⊂ S
3
←− · · · ←− ⊂ S
n
←− ··· 

↓	s	↓	s	↓	s	↓

⊂ T ←− ⊂ T
1	2
←− ⊂ T
3
←− · · · ←− ⊂ T
n
←− ··· 

Fig. 3. Inclusion relations of two different families of generalised nested simulations semantics


in the linear time-branching time spectrum is naturally preserved at any level of nesting. Other relations between levels, as the one stated in the second statement of Proposition 5.4, deserve further study.


Counting Bisimulation
In [8,7] we have used global bisimulations and bisimulations up-to to characterise all the semantics in Van Glabbeek’s spectrum in a coinductive way. This charac- terisation also provides a bisimulation-like game defining each of the semantics in the spectrum. But, when they have not a finite axiomatisation we have not a sim- ple way to generate the global transitions that are needed to weaken the (original) bisimulation game to capture the desired semantics.
In this section we define a bisimulation-like game, the counting bisimulation game, that characterises the nested simulation semantics. Let us briefly explain how we obtained this new game. Since each nested simulation is a constrained simulation, in order to check it, we can use the simulation game where the attacker

has always to play in the p-side of the board (when proving p ⊂
n+1
q). But the

imposed constraint q ⊂
n
p should also be checked continuing with the game but,

since we are comparing q with p, turning the board. In this way we get a nearly
symmetric condition, so that nested simulations become nearly bisimulations. But of course the symmetry is not total: the index has been decremented, so that it must be taken into account in order to differentiate the level of the nesting. In particular, when n becomes one, the bisimulation part of the game has terminated and the game reduces to checking the basic relation in the nested semantics. In particular, for classic nested simulation semantics the base game is plain simulation.
As we will justify below, instead of checking this relation we can check mutual similarity, what can be made playing a bisimulation up-to game [7]. This way we will be playing a bisimulation-like game all the time: first the counting bisimulation and, at the end, the bisimulation up-to simulation.
Let us precisely define the counting bisimulation for the nested simulation se- mantics. Let ±1, ±1 and =1 denote the simulation preorder, their inverse and the mutual simulation equivalence, respectively. As stated in [2], the nested simulation semantics can be characterised as follows:

Proposition 6.1 Let p, q be BCCSP terms, and n ≥ 0



p ⊂	q ⇔
for all p −a→ p' there is q −a→ q' with p' ⊂
→n+1
q', and

→n+1
⊂ p.
n

where ⊂
0
is the total relation that relates any pair of processes.

When n ≥ 1 we propose the following unfold:



p ⊂ cb
q ⇔ ⎧⎨

for all p −a→ p' there is q −a→ q' with p' ⊂ cb
n+1
q', and

→n+1
for all q −a→ q' there is p −a→ p' with q' ⊂ cb p'.
n

We have introduced the superscript cb (counting bisimulation) because we cannot

directly simply write ⊂
n+1
, since the complete unfold of q ⊂
n
p would have added

also the condition p ⊂
n−1
q, which we have removed. However, in the following we

will prove that in fact both definitions are equivalent.
Using the characterisation given by Definition 4.2 for the case of the 2-nested simulation semantics, we have


p ⊂ q ⇔
for all p −a→ p' there is q −a→ q' with p' ⊂
2
q', and

→2
q =1 p.
Using our bisimulation up-to characterisation of =1 (see [7])

⎧
p =1 q ⇔

for all p −a→ p' there is q ±
a

q' −a→ q'
a

with p' =1
q' , and

⎩ for all q −→ q' there is p ±1 p' −→ p'
with q' =1 p' .



We unfold the characterisation of ⊂
2
to obtain:



p ⊂ cb q ⇔
for all p −a→ p' there is q −a→ q' with p' ⊂ cb q', and
2

2	⎩ for all q −a→ q' there is p ±
p' −a→ p'
with q' =1
p' .


Putting together the counting bisimulation relations ⊂ cb and the bisimulation up-to
k
characterisation for the mutual simulation equivalence, that in the following we will
also write as =cb, we get the following counting bisimulation game:
Definition 6.2 Given n > 1 and p, q two BCCSP process, the counting bisimu- lation game CBisi(p, q, n) is that governed by the following rules:
Initialisation Assign to counter c the value n.
Attack and Defence

Moves of the attacker:
Either he executes some transition p −a→ p',
Or he turns the board and executes q −a→ q', but in this case if the counter c
has a value greater than one, then c is decremented by one.
Moves of the defender:
He always move in the opposite side where the attacker has made his last move. To simplify, we note that process by r. Then, if the counter c has a value greater than one, the defender has to do an ordinary move r −a→ r'; on the contrary, if the counter c is just one, then the defender can perform an
a
up-to move, r ±1 r' −→ r' .
Winner
If the attacker cannot move (p = 0 = q) then the game is over and the defender wins.
If the defender cannot reply to the last move of the attacker (r −a→ ), then the attacker has won the game.
In plain words, any play of a counting bisimulation game has two parts: the first one, while the counter is greater than one, the game is governed by the bisimulation rules; the second one, when the counter becomes one, the rules are those of the corresponding bisimulation up-to game that characterises the base equivalence =1 . Note that we have not defined the counting bisimulation game for n = 1. There are two reasons for that: first, we do not need it, because counting bisimulation games are introduced in order to characterise the nested semantics; degenerated 1-nested semantics is just the plain simulation semantics that needs no coinductive characterisation, since it is directly coinductive by itself. Besides, if we would start our game with n = 1 we would obtain a symmetric definition, that could never
correspond to the asymmetric simulation preorder.
Theorem 6.3 For any n ≥ 2, the defender player has a winning strategy to win
any play of the game CBisi(p, q, n) iff p ⊂ q.
n
Proof. It is immediate to check that the defender has a winning strategy for the

game CBisi(p, q, n) iff p ⊂ cb
n
q. Then, let us prove by induction on k ≥ 2 that

⊂ q iff p ⊂ cb q.
n	n

For k = 2, since
⎧⎨


for all p −a→ p' there is q ±


q' −a→ q'


with p' =

q' , and

p =1 q ⇔	a
1	a	1  a
a

⎩ for all q −→ q' there is p ±1 p' −→ p'
with q' =1 p' .



it is clear that p ⊂
2
q ⇒ p ⊂ cb q. For the opposite we just need to prove that
2

p ⊂ cb q implies p =1 q, what is immediate since ⊂ cb is a simulation and p' =1 q' ⇒
→2	→2
p' ±S q'.

For k +1 > 2, if we complete the unfolding we did to generate ⊂
k+1
we obtain

⎧⎪⎪⎨
for all p −a→ p' there is q −a→ q' with p' ⊂
k+1
q', and

→k+1 q ⇔
⎪
for all q −a→ q' there is p −a→ p with q' ⊂
k

 
p', and

Then we prove the equivalence between both relations by induction on depth(p).

Since depth(p') < depth(p) we can assume p' ⊂
k+1
q' ⇔ p' ⊂ cb
k+1
q' and, by

induction on k, p' ⊂	q' ⇔ p' ⊂ cb q'. So that, p ⊂
q ⇒ p ⊂ cb
q. For the

→k	→k
→k+1
→k+1

opposite we need to check that p ⊂ cb
k+1
q ⇒ p ⊂ cb
→k−1
q, which is an immediate

consequence of the fact p ⊂ cb
k+1
q ⇒ p ⊂ cb q, which is obvious from the definition
k

of ⊂ cb  .	 
k+1
We have two reasons for the current presentation of our counting bisimulation game for the nested simulation relations: First, because it can be immediately gen- eralised to characterise any nested simulation based on any behaviour equivalence characterisable via bisimulations up-to; we just need to make use of the correspond- ing bisimulation up-to in the last part of the game. Second, because we looked for a presentation of the game as close to the original bisimulation game as possible. In particular, the attacker can always turn the board, as in the bisimulation game, although once n − 1 turns have been made the defender can use up-to movements when playing.
However, in the particular case of the classical nested simulation relations an- other nice approach is possible that emanates from the smooth and compact Def- inition 4.1: we can define plain counting bisimulations as those governed by the rules of plain bisimulation, but removing the possibility of turning the board when n becomes 1, or equivalently, stopping the game, taking the defender as winner, if n becomes 0. Note that even if we are now playing with completely symmetric rules, the initial configuration makes a difference and therefore the game still characterises a preorder and not an equivalence.
Theorem 6.4 The plain counting bisimulation game deﬁned above also charac-

terises the nested simulation p ⊂
n
q, in this case for any n ≥ 0.

Let us note that in this case the result is also valid for n = 1 since CBisi(p, q, 1)

is just the simulation game, while for n = 0 we always obtain p ⊂
0
q as stated in

Definition 4.1

Conclusions and Future Work
In this paper we have presented several results that shed some light into the nature of nested simulation semantics. In particular, we have characterised them by means

of counting bisimulations that are simply defined by incorporating a counter which limits the number of times that the attacker can turn the board during a play of the bisimulation game.
The main tool we have used to develop most of the results in the paper is the notion of constrained simulations. This notion is a generalisation of the ready simulation, which has been a recurrent topic in our recent research [7,8]. We have proved in this paper several results for constrained simulations, as the existence of a conditional axiomatisation, which can be applied in a very general setting.
Since classic nested simulation semantics are constrained simulations the results above apply to them. Besides, the characterisation of classic nested simulations as constrained simulations suggests a general definition of nested simulations: it is possible to define a nested simulation over any relation. In particular, any of the semantics in the Van Glabbeek’s spectrum could be nested simulated. We il- lustrate this generalised definition by constructing the n-nested trace simulation preorders and comparing them with the classic nested simulation preorders. We plan to further investigate the power of constrained simulations. In particular, some of the constrained simulations have a non-conditional finite axiomatisation (simulation, complete simulation, ready simulation), but others, as the 2-nested simulation, have not. This opens the question of whether it is possible to charac- terise the constrained simulation preorders that can be finitely axiomatised and, even to try to systematically generate the non-conditional axiomatisation in those cases.
Continuing with the study in [8,7], we have next addressed the problem of find- ing a coinductive characterisation for the nested semantics. For this purpose we have introduced the counting bisimulation game that, used in conjunction with the bisimulation up-to technique previously developed, allows to characterise the (generalised) nested simulation semantics. Counting bisimulation seems to be an interesting generalisation of the notion of bisimulation filling the gap between sim- ulation and bisimulation semantics. In the paper we only provide a proof of the characterisation of nested semantics by means of counting bisimulations for finite BCCSP processes, but we have also a more involved coinductive proof covering arbitrary processes.
We plan to further extend the results in this paper transferring them to the framework of nested trace semantics [13,2]. We hope in this way to achive a coin- ductive characterisation for every sematics in the linear time-branching time spec- trum. This is a much more elaborate work mainly because nested trace semantics are defined in a rather less elegant way than nested simulations, since traces in- stead of single actions are used in the transitions appearing in their definition. In particular, nested trace semantics do not coincide with the nested trace simulation semantics defined in Section 5.
Finally, let us conclude noticing that our notion of counting bisimulation is a particular case of a general notion of vectorial bisimulation in which we are working. It would also include as other particular cases the recent notions of bisimulation on speed [16] and amortised bisimulations [14], and it is based on the idea of using

coalgebraic techniques to study not just a single relation but a (nearly arbitrary) family of them defined in a mutual recursive (coalgebraic) way. In [9] we have used the general concept of categorical simulation in [12] to start to formalize these ideas, and other interesting bisimulation semantics for distributed systems.

References
Luca Aceto, Wan Fokkink, and Anna Ing´olfsd´ottir. 2-nested simulation is not finitely equationally axiomatizable. In STACS 2001, volume 2010 of Lecture Notes in Computer Science, pages 39–50. Springer, 2001.
Luca Aceto, Rob van Glabbeek, Wan Fokkink, and Anna Ingo´lfsd´ottir. Nested semantics over finite tree are equationally hard. Information and Computation, 191(2):203–232, 2004.
Bard Bloom, Sorin Istrail, and Albert R. Meyer. Bisimulation can’t be traced. Journal of the ACM, 42(1):232–268, 1995.
Rance Cleaveland and Matthew Hennessy. Testing equivalence as a bisimulation equivalence. Formal Aspects of Computing, 3:1–21, 1992.
Rance Cleaveland, Joachim Parrow, and Bernhard Steffen. The concurrency workbench: a semantics- based tool for the verification of concurrent systems. ACM Trans. Program. Lang. Syst., 15(1):36–72, 1993.
David de Frutos-Escrig and Carlos Gregorio-Rodr´ıguez. Semantics equivalences defined with global bisimulations. Annual meeting of the IFIP Working Group 2.2, Bertinoro, Italy, September 2004.
David de Frutos-Escrig and Carlos Gregorio-Rodr´ıguez. Bisimulations up-to for the linear time- branching time spectrum. In CONCUR 2005 - Concurrency Theory, 16th International Conference, volume 3653 of Lecture Notes in Computer Science, pages 278–292. Springer, 2005.
David de Frutos-Escrig and Carlos Gregorio-Rodr´ıguez. Process equivalences as global bisimulations.
Journal of Universal Computer Science, 12(11):1521–1550, 2006.
David de Frutos-Escrig, Fernando Rosa-Velardo, and Carlos Gregorio-Rodr´ıguez. New bisimulation semantics for distributed systems. In FORTE 2007, volume to appear of Lecture Notes in Computer Science. Springer, 2007.
Rob J. van Glabbeek. Handbook of Process Algebra, chapter The Linear Time – Branching Time Spectrum I: The Semantics of Concrete, Sequential Processes, pages 3–99. Elsevier, 2001.
Jan Friso Groote and Frits Willem Vaandrager. Structured operational semantics and bisimulations as a congruence. Information and Computation, 100(2):202–260, 1992.
Jesse Hughes and Bart Jacobs. Simulations in coalgebra. Theoretical Computer Science, 327(1–2):71– 108, 2004.
Matthew Hennessy and Robin Milner. Algebraic laws for nondeterminism and concurrency. J.ACM, 32:137–161, 1985.
Astrid Kiehn and A. Arun-Kumar. Amortised bisimulations. In Formal Techniques for Networked and Distributed Systems-FORTE 2005, volume 3235 of Lecture Notes in Computer Science, pages 320–334. Springer, 2005.
Paris C. Kanellakis and Scott A. Smolka. CCS expressions, finite state processes, and three problems of equivalence. Information and Computation, 86(1):43–68, 1990.
Gerald Lu¨ttgen and Walter Vogler. Bisimulation on speed: A unified approach. In FOSSACS 2005, volume 3341 of Lecture Notes in Computer Science, pages 79–94. Springer, 2005.
Robin Milner. Communication and Concurrency. Prentice Hall, 1989.
Robert Paige and Robert E. Tarjan. Three partition refinement algorithms. SIAM Journal of Computing, 16(6):973–989, 1987.
Colin Stirling. The joys of bisimulation. In MFCS’98, volume 1450 of Lecture Notes in Computer Science, pages 142–151. Springer-Verlag, 1998.
