Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 338 (2018) 147–166
www.elsevier.com/locate/entcs


Formalization of Universal Algebra in Agda
Emmanuel Gunther1  Alejandro Gadea2  Miguel Pagano3
FaMAF, UNC – Córdoba, Argentina

Abstract
In this work we present a novel formalization of universal algebra in Agda. We show that heterogeneous signatures can be elegantly modelled in type-theory using sets indexed by arities to represent operations. We prove elementary results of heterogeneous algebras, including the proof that the term algebra is initial and the proofs of the three isomorphism theorems. We further formalize equational theory and prove soundness and completeness. At the end, we define (derived) signature morphisms, from which we get the contra- variant functor between algebras; moreover, we also proved that, under some restrictions, the translation of a theory induces a contra-variant functor between models.
Keywords: universal algebra, formalization of mathematics, equational logic


Introduction
Universal algebra [2] is the study of different types of algebraic structures at an abstract level, thus revealing common results which are valid for all of them and also allowing for a unified definition of constructions (for example, products, sub- algebra, congruences). Universal algebra has played a relevant role in computer science since its earliest days, in particular Birkhoff’s seminal paper [4] features regular languages as a prominent example; shortly before, Burstall [6] had proved properties of programs using structural induction, by conceiving the language as an initial algebra. The ADJ group [14] promoted multi-sorted algebras as a key theoretical tool for specifying data types [19], semantics [20], and compilers [33]. More recently, institutions [15], a generalization of universal algebra, have been used as a foundation of methodologies and frameworks for software specification and development [30].
In spite of the rich mathematical theory of heterogeneous algebras (mostly in- herited from the monosorted setting, but not always [32]), there are few publicly

1 Email:gunther@famaf.unc.edu.ar Partially supported by a CONICET scholarship.
2 Email:gadea@famaf.unc.edu.ar Partially supported by a CONICET scholarship.
3 Email:pagano@famaf.unc.edu.ar

https://doi.org/10.1016/j.entcs.2018.10.010
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

available formalizations in type theory (which we discuss in the conclusion). This situation is to be contrasted with impressive advances in mechanization of particular algebraic structures as witnessed, for example, by the proof of the Feit-Thompson theorem in Coq by Gonthier and his team [21].
In this work we present an Agda library of multi-sorted universal algebra aiming both a reader with a background in the area of algebraic specifications and also the community of type theory. For the former, we try to explain enough Agda in order to keep the paper self-contained; we will recall the most important definitions of universal algebra. The main contributions of this paper are: (i) the first formaliza- tion of basic universal algebra in Agda; (ii) the first, to our knowledge, formalization in type theory of derived signature morphisms and the reduct algebras induced by them; (iii) a novel representation of heterogeneous signatures in type theory, where operations are modelled using sets indexed by arities; and (iv) an independent li- brary of heterogeneous vectors. We formalized the proof that the term algebra is initial and also the proofs of the three isomorphism theorems; moreover we also define a deduction system for conditional equational logic and prove its soundness and completeness with respect to Goguen and Meseguer’s semantics [17]. We also showed that the translations of theories arising from derived signature morphisms in- duces a contra-variant functor between models. In the complete development, which is available at https://github.com/manugunther/agda-universal-algebra.git, we include several examples featuring both the use of equational reasoning and the preservation of models by signature morphisms.
Outline. In Sec. 2 we introduce the basic concepts of Universal Algebra: sig- nature, algebras and homomorphisms, congruences, quotients and subalgebras, the proofs of three isomorphisms theorems, and the proof of the initiality of the term al- gebra. In Sec. 3 we define an equational calculus, introducing concepts of equations, theories, satisfiability and provability, ending with Birkhoff’s proofs of soundness and completeness. In Sec. 4 we introduce a new representation of (derived) signature morphisms and reduct algebras (and homomorphisms), and we explore translation and implication of theories. Finally, we conclude in Sec. 5, discussing the work done, and pointing out possible future directions.




Universal Algebra

In this section we present our formalization in Agda of the core concepts of heteroge- neous universal algebra; in the next two sections we focus respectively on equational logic and signature morphisms. Meinke’ and Tucker’s chapter [25] is our reference for heterogeneous universal algebra; we will recall some definitions and state all the results we formalized. Bove et al. [5] offer a gentle introduction to Agda; we expect the reader to be familiar with Haskell or some other functional language.

Signature, algebra, and homomorphism
Signature
A signature is a pair of sets (S, F ), called sorts and operations (or function symbols) respectively; each operation is a triple (f, [s1,..., sn], s) consisting of a name, its arity, and the target sort (we also use the notation f : [s1, ..., sn] ⇒ s).
In Agda we use dependent records to represent signatures; in dependent records the type of some field may depend on the value of a previous one or parameters of the record. Type-theoretically one can take operations (of a signature) as a family of sets indexed by the arity and target sort (an indexed family of sets can also be thought as predicates over the index set, an index satisfies the predicate if its family is inhabited):
record Signature : Set1 where field
sorts : Set
ops	: List sorts × sorts → Set
A × B corresponds to the non-dependent cartesian product of A and B.
In order to declare a concrete signature one first declares the set of sorts and the set of operations, which are then bundled together in a record. For example, the mono-sorted signature of monoids has a unique sort, so we use the unit type T with its sole constructor tt. We define a family indexed on List T x T, with two constructors, corresponding with the operations: a 0-ary operation e, and a binary operation • (note that constructors can start with a lower-case letter or any symbol):
data monoid-op : List T×T→ Set where
e : monoid-op ([ ] , tt)
: monoid-op ([ tt , tt ] , tt) monoid-sig : Signature
monoid-sig = record {sorts = T; ops = monoid-op}
The signature of monoid actions has two sorts, one for the monoid and the other for the set on which the monoid acts.
data actMons : Set where
mon : actMons set : actMons
data actMono : List actMons × actMons → Set where
e : actMono ([ ] , mon)
* : actMono ([ mon , mon ] , mon)
: actMono ([ mon , set ] , set) actMon-sig : Signature
actMon-sig = record {sorts = actMons; ops = actMono }
Defining operations as a family indexed by arities and target sorts carries some

benefits in the use of the library: as in the above examples, the names of operations are constructors of a family of datatypes and so it is possible to perform pattern matching on them. Notice also that infinitary signatures can be represented in our setting; in fact, all the results are valid for any signature, be it finite or infinite.
We show two examples of signatures with infinite operations, the first might be more appealing to computer scientists and the second is more mathematical. The abstract syntax of a language for arithmetic expressions may have one sort, a constant operation for each natural number and a binary operation representing the addition of two expressions.
data Sortse : Set where E : Sortse
data Opse : List Sortse × Sortse → Set where
val	: (n : N) → Opse ([] , E)
plus : Opse (E :: [ E ] , E)
Vector spaces over a field can be seen as a heterogeneous signature with two sorts [4] or as homogeneous signature over the field [3, p. 132]; this latter approach can be easily specified in our library, even if the field is infinite:
data Sorts-v Set where V : Sorts-v
data Ops-v (F : Set) : Set where
_+_ : Ops-v (V :: [ V ] , V)	-- vector addition
ν : (f : F) → Ops-v ([ V ] , V)	-- scalar multiplication
vspace-sig : (F : Set) → Signature
vspace-sig F = record {sorts = Sorts-v; ops = Ops-v F }


Algebra
An algebra A for the signature Σ consists of a family of sets indexed by the sorts of Σ and a family of functions indexed by the operations of Σ. We use As for the interpretation or the carrier of the sort s; given an operation f : [s1, ..., sn] ⇒ s, the interpretation of f is a total function fA : As1 × ... × Asn → As. We formalize the product As1 × ... × Asn as heterogeneous vectors. The type of heterogeneous vectors is parameterized by a set I and a family of sets indexed by I; and is indexed over a list of I:
data HVec {I : Set} (A : I → Set) : List I → Set where
⟨⟩	: HVec A []
_D_ : ∀ {i is}→ A i → HVec A is → HVec A (i :: is)
The first parameter I is implicit (written in braces), which means that Agda will infer it by unification; notices that the constructor _D_ also takes two implicit arguments (we use the notation ∀ to skip their types). Let Σ be a signature and A : sorts Σ → Set, then the product As1 ×...×Asn is formalized as HVec A [s1,. . . ,sn]. We need one more ingredient to give the formal notion of algebras: the math- ematical definition of carriers assumes an underlying notion of equality. In type

theory one makes it apparent by using setoids (i.e. sets paired with an equivalence relation), which were thoroughly studied by Barthe et al. [1]. Setoids are defined in the standard library [9] of Agda 4 as a record with three fields.
record Setoid : Set1 where field
Carrier : Set
_≈_	: Carrier → Carrier → Set isEquivalence : IsEquivalence _≈_

The relation is given as a family of types indexed over a pair of elements of the carrier (a b : Carrier are related if the type a ≈ b is inhabited); IsEquivalence _≈_ is again a record whose fields correspond to the proofs of reflexivity, symmetry, and transitivity.
The finest equivalence relation over any set is given by the propositional equality which only equates each element with itself, thus we can endow any set with a setoid structure with the function setoid : Set → Setoid of the standard library; vice versa, there is a forgetful functor _  : Setoid → Set which returns the carrier.
Setoid morphisms are functions which preserve the equality:


record _ ≈
_ (A B : Setoid) : Set where

field
_⟨$⟩_ :  A  → B 
cong : ∀ {a a’}→ _≈_ A a a’ → _≈_ B (_⟨$⟩ a) (_⟨$⟩ a’)
Notice that _ ≈ _ is a record parameterized on two setoids. The first field is the

function, by declaring it mixfix one can write f ⟨$⟩ a when f : A ≈
B and a :  A ;

the second field is given by a function mapping equivalence proofs on the source setoid to equivalence proofs on the target. Setoid morphisms will be used to give the interpretation of operations.
Let A : I → Set be a family of sets and P : {i : I} → A i → Set a family of predicates, we let P * : ∀ {is} → HVec A is → Set be the point-wise extension of P over heterogeneous vectors. We also use the point-wise extension to define the setoid of heterogeneous vectors given a family of setoids A : I → Setoid and write A ∗ is for the setoid of heterogeneous vectors with index is. Algebras are formalized as records parameterized on the signature.
record Algebra (Σ : Signature) : Set1 where field
_J_)s : sorts Σ → Setoid

_J_)o
: ∀ {ar s }→ (f : ops Σ (ar , s)) → _J_)s
∗ ar ≈
_J_)s s

If A is an algebra for the signature monoid-sig, then A J tt )s is the carrier, A J e )o

4 Our formalization is based on several concepts defined in the standard library.

and A J • )o are the interpretations of the operations. We invite the interested reader to browse the examples to see algebras for the signatures we have shown.

Homomorphism
Let Σ be a signature and let A and B be algebras for Σ. A homomorphism h from A to B is a family of functions indexed by the sorts hs : As → Bs, such that for each operation f : [s1, ..., sn] ⇒ s, the following holds:
hs(fA(a1, ..., an)) = f5(hs1 a1, ..., hsn an)	(1) Notice that this is a condition over the family of functions.
In order to formalize homomorphisms we first introduce a notation for families of setoid morphisms indexed over sorts:
_~_ : ∀ {Σ}→ Algebra Σ → Algebra Σ → Set
_~_ {Σ} A B = (s : sorts Σ) → A J s )s −→ B J s )s
We make explicit the implicit parameter Σ because otherwise sorts Σ does not make sense. 5 To enforce (1) we also define a predicate over families of setoids morphisms:
homCond : ∀ {Σ} {A B}→ A ~ B → Set
homCond {Σ} {A} {B} h = ∀ {ar s } (f : ops Σ (ar , s)) (as :  A J_)s ∗ ar ) →
h s ⟨$⟩ (A J f )o ⟨$⟩ as) ≈s B J f )o ⟨$⟩ map h as
where _≈s_ is the equivalence relation of the setoid B J s )s and map h is the obvious extension of h over vectors. A homomorphism is a record parameterized by the source and target algebras
record Homo {Σ} (A B : Algebra Σ) : Set where field
j_j : A ~ B
cond : homCond j_j
As expected, we have the identity homomorphism Idh A : Homo A A and the composition G ◦h F : Homo A C of homomorphisms F : Homo A B and G : Homo B C. It is also expected that F ◦h Idh A and F are equal in some sense. Since Agda is based on an intensional type theory, we cannot take the definitional equality (which distinguishes id from λ n → n + 0 as functions on naturals); instead, we equate setoid morphisms whenever their function parts are extensionally equal:

_ ≈ext
_ : (f g : A ≈
B) → Set

f ≈ext g = ∀ (a :  A ) → (f ⟨$⟩ a) ≈B (g ⟨$⟩ a)
Two homomorphisms are equal when their corresponding setoid morphisms are ex- tensionally equal:

5 In the library we use modules in order to avoid the repetition of the parameters Σ, A, and B.

_≈h_ : ∀ {Σ} {A B}→ Homo A B → Homo A B → Set F ≈h F’ = (s : sorts Σ) → j F j s ≈ext j F’ j s
With respect to this equality, it is straightforward to prove the associativity of the composition _◦h_ and that Idh is the identity for the composition.
Quotient and subalgebras
In order to prove the more basic results of universal algebra, we need to formalize subalgebras, congruence relations, and quotients.

Subalgebra
A subalgebra B of an algebra A consists of a family of subsets Bs ⊆ As, that are closed under the interpretation of operations; that is, for every f : [s1,..., sn] ⇒ s the following condition holds
(a1,..., an) ∈ Bs1 ×· · ·× Bsn implies fA(a1,..., an) ∈ Bs .	(2)
As shown by Salvesen and Smith [29], subsets cannot be added as a construction in intensional type theory because they lack desirable properties. If A : Set and P : A → Set is a predicate over A, then one can represent the subset containing the elements on A that satisfy P as the dependent sum 6 Σ[ a ∈ A ] P whose inhabitants are pairs (a , p) where a : A and p : P a. Let us consider a setoid A and a predicate on its carrier P :  A  → Set; first notice that we can lift the subset construction to setoids, defining the equivalence relation (a , q) ≈ (a’ , q’) iff a ≈ a’. Moreover, we might assume that P is well-defined, which means that a ≈A a’ and P a imply P a’.
WellDef : (A : Setoid) → (P :  A  → Set) → Set WellDef A P = ∀ {a a’}→ a ≈A a’ → P a → P a’
A family of well-defined predicates will induce a subalgebra; but we still need to formalize the condition (2). Let Σ be a signature and A be an algebra for Σ.
opClosed : (P : (s : sorts Σ) → A J s )s  → Set) → Set
opClosed P = ∀ {ar s} (f : ops Σ (ar , s)) → (P * ⟨→⟩ P s) (A J f )o ⟨$⟩_)
(Q ⟨→⟩ R) f can be read as the pre-condition Q implies post-condition R after applying f; so opClosed P f asserts that if a vector a* satisfies the predicate P, then the application of the interpretation A J f )o to a* satisfies P, according to Eq. (2). In summary, given an algebra A for the signature Σ and a family P of predicates, such that P s is well-defined for every sort s and P is opClosed, we can define the SubAlgebra A P
SubAlgebra : ∀ {Σ} A P → WellDef P → opClosed P → Algebra Σ

6 Do not confuse the syntax Σ[_∈_]_ of dependent sum, with a variable Σ : Signature

In the subalgebra, an operation f is interpreted by applying the interpretation of f in A to the first components of the argument (and use the fact that P is op-closed to show that the resulting value satisfies the predicate of the target sort).

Congruence and Quotients
A congruence on a Σ-algebra A is a family Q of equivalence relations indexed by sorts, and each of them is closed under the operations of the algebra. This condition is called substitutivity and can be formalized using the point-wise extension of Q over vectors: for every operation f : [s1,..., sn] ⇒ s

(a, b) ∈ Qs1 × ··· × Qsn implies (fA(a), fA(b)) ∈ Qs	(3)
As with predicates, we say that a binary relation over a setoid is well-defined if it is preserved by the setoid equality; this notion can be extended over families of relations in the obvious way. In our formalization, a congruence on an algebra A is a family Q of well-defined, equivalence relations. The substitutivity condition (3) is aptly captured by the generalized containment operator _=[_]⇒_ of the standard library, where P =[ f ]⇒ Q if, for all a,b ∈ A, (a,b) ∈ P implies (f a, f b) ∈ Q.
record Congruence (A : Algebra Σ) : Set where field
rel : (s : sorts Σ) → (  A J s )s  → A J s )s  → Set)
welldef : (s : sorts Σ) → WellDefBin (rel s) cequiv : (s : sorts Σ) → IsEquivalence (rel s)
csubst : ∀ {ar s}→ (f : ops Σ (ar , s)) → rel * =[ A J f )o ⟨$⟩_ ]⇒ rel s

Given a congruence Q over the algebra A, we can obtain a new algebra, the quotient algebra, by interpreting the sort s as the set of equivalence classes As/Q; the condition (3) ensures that the operation f : [s1,..., sn] ⇒ s can be interpreted as the function mapping the vector ([a1],..., [an]) of equivalence classes into the class [fA(a1,..., an)]. In Agda, we take the same carriers from A and use Q s as the equivalence relation over  A J s )s  ; operations are interpreted just as in A and the congruence proof is given by csubst Q.

Isomorphism Theorems
The definitions of subalgebras, quotients, and epimorphisms (surjective homo- morphisms) are related by the three isomorphism theorems. Although there is some small overhead by the coding of subalgebras, the proofs follow very close what one would do in paper. For proving these results we also defined the kernel and the homomorphic image of homomorphisms.
Theorem 2.1 (First isomorphism theorem) If h : A → B is an epimorphism, then A/ker h  B.

Remember that the quotient A/ker h has the same carrier as A, so h counts as the underlying function and it respects the equivalence relation ker h by definition. Clearly h is surjective and its injectivity is obvious.
Theorem 2.2 (Second isomorphism theorem) If φ, ψ are congruences over A, such that ψ ⊆ φ, then (A/φ)  (A/ψ)/(φ/ψ).
In order to prove this theorem, we first prove that φ/ψ is a congruence over A/ψ: it suffices to prove the well-definedness of φ/ψ, i.e. that (a, c) ∈ ψ, (b, d) ∈ ψ, and (a, b) ∈ φ imply (c, d) ∈ φ; an obvious consequence of ψ ⊆ φ. Notice that the underlying carriers are the same in both cases: those of A, so the identity function is the mediating isomorphism and the proof that it satisfies the homomorphism condition is trivial.
Theorem 2.3 (Third isomorphism theorem) Let B be a subalgebra of A and φ be a congruence over A. Let [B]φ = {K ∈ A/φ : K ∩ B /= ∅} and let φB be the restriction of φ to B, then (i) φB is a congruence over B;(ii) [B]φ is a subalgebra of A; and,(iii) [B]φ  B/φB.
First we define the trace of the congruence φ on the subalgebra B as the restriction of φ on B; proving that it is a congruence over B involves some bureaucracy (remember that an element of a subalgebra is a pair (a, p) such that a ∈ A and p is the proof that a satisfies the predicate defining B). For the second item, we model [B]φ as a predicate over A; it is satisfied by a ∈ A if there is some b ∈ B such that (a, b) ∈ φ. The well-definedness of this predicate is easy (assuming (a, aj) ∈ φ and b ∈ B with (a, b) ∈ φ, one can easily prove that (aj, b) ∈ φ, thus b is also the witness for proving that aj satisfies the predicate). To prove that the predicate is closed under the operations we take a vector of triples (as, bs, ps) consisting of a vector of elements in A, a vector of elements in B, and the proofs ps proving that (asi, bsi) ∈ φ. Let f be an operation, since B is closed we know f (b1,..., bn) ∈ B and because φ is also closed we deduce (f (a1,..., an),f (b1,..., bn)) ∈ φ. Finally, the underlying function witnessing the isomorphism [B]φ B/φB is given by composing the second projection with the first projection, thus getting an element in B.

The Term Algebra is initial
A Σ-algebra A is called initial if for any Σ-algebra B there exists exactly one homo- morphism from A to B. We give an abstract definition of this universal property, existence of a unique element, for any set A and any relation R

hasUnique {A} _≈_ = A × (∀ a a’ → a ≈ a’)
and initiality can be formalized directly:
Initial : ∀ {Σ}→ Algebra Σ → Set
Initial {Σ} A = ∀ (B : Algebra Σ) → hasUnique (_≈h_ A B)

Given a signature Σ we can define the term algebra T , whose carriers are sets of well-typed words built up from the function symbols. Sometimes this universe is called the Herbrand Universe and is inductively defined:

t1 ∈ Ts1	···	tn ∈ Tsn  f : [s , ..., s

] ⇒ s

f (t1, ..., tn) ∈ Ts	1	n
This inductive definition can be written directly in Agda:
data HU {Σ : Signature} : (s : sorts Σ) → Set where
term : ∀ {ar s }→ (f : ops Σ (ar '→ s)) → HVec HU ar → HU s
We use propositional equality to turn each HUs into a setoid, thus completing the interpretation of sorts. To interpret an operation f : [s1,..., sn] ⇒ s we map the vector ⟨t1,. . . ,tn⟩ : HVec HU [s1,. . . ,sn] to term f ⟨t1,. . . ,tn⟩; we omit the proof of cong, which is too long and tedious to be shown.
|T| : (Σ : Signature) → Algebra Σ
|T| Σ = record {_J_)s = setoid ◦ (HU {Σ}); _J_)o = |_|o }
where | f |o = record {_⟨$⟩_ = term f; cong = ...}
Terms can be interpreted in any algebra A, yielding an homomorphism hA : T → A
hA(f (t1,..., tn)) = fA (hA t1, ..., hA tn) .
We cannot translate this definition directly in Agda, instead we have to mutually define |h| and its extension over vectors |h*|
|h| : ∀ {Σ}→ (A : Algebra Σ) → {s : sorts Σ}→ HU s → A J s )s 
|h| A (term f ts) = A J f )o ⟨$⟩ (|h*| ts)
It is straightforward to prove that |h| preserves propositional equality and satisfies the homomorphism condition by construction. To finish the proof that |T| Σ is initial, we prove, by recursion on the structure of terms, that any pair of homomor- phisms are extensionally equal.

Equational Logic
In this section we introduce the notion of (conditional) equational theories and the corresponding notion of satisfiability of theories by algebras. Moreover we formalize (conditional) equational logic as presented by Goguen and Lin [16] and prove that the deduction system is sound and complete.
Free algebra with variables
The term algebra we have just defined contained only ground terms, i.e. terms with- out variables. Given a signature Σ and X : sorts Σ → Set a family of variables, we

define a new signature extending Σ with X by taking the variables as new constants (i.e. , operations with arity []).
_Q_¢ : (Σ : Signature) → (X : sorts Σ → Set) → Signature
Σ Q X ¢ = record {sorts = sorts Σ; ops = ops’}
where ops’ ([] , s) = ops Σ ([] , s)  X s ops’ (ar , s) = ops Σ (ar , s)
Note that it is easy to refer to constant operations and extend them, because we indexed the set of operations on their arity and target sort.
It is easy to turn the term algebra of the extended signature into an algebra for the original signature:
|T|_Q_¢ : (Σ : Signature) → (X : sorts Σ → Set) → Algebra Σ
|T| Σ Q X ¢ = record {_J_)s = |T| (Σ Q X ¢) J_)s , _J_)o = io}
where io {[]} f = |T| (Σ Q X ¢) J inj1 f )o
io {ar } f = |T| (Σ Q X ¢) J f )o
The only difference with the algebra of ground terms is that we inject constants from Σ to distinguish them from variables. In order to interpret terms with variables we need environments to give meaning to variables.
Let Env X A = ∀ {s} → X s →  A J s )s  be the set of environments from X to A. The free algebra |T| Σ Q X ¢ has the universal freeness property: given A : Algebra Σ and an environment θ : Env X A, there exists an unique homomorphism J_)θ : Homo (|T| Σ Q X ¢) A such that J x )θ = θ (x) for x ∈ X.
Satisfiability and provability
Equations
In the mono-sorted setting an equation is a pair of terms where all the variables are assumed to be universally quantified and an equational theory is a (finite) set of equations. In a multi-sorted setting both sides of an equation should be terms of the same sort. Moreover we allow quasi-identities which we write as conditional equations:
t = tj if t1 = tj ,..., tn = tj .
1	n
Let Σ be a signature and X : sorts Σ → Set be a family of variables for Σ. An identity e : Eq Σ X s is a pair of (open) terms with sort s. A conditional equation is modelled as record with fields for the conclusion and the conditions, modelled as
an heterogeneous vector of sorted identities. We declare a constructor to use the lighter notation V eq if (ar , eqs) instead of record {eq = e; cond = (ar , eqs)}.
record Equation (Σ : Signature) (X : sorts Σ → Set) (s : sorts Σ) : Set where
constructor V_if_
field
eq	: Eq Σ X s 
cond : Σ[ ar ∈ List (sorts Σ) ] (HVec (Eq Σ X) ar)

A theory over the signature Σ is given by a vector of conditional equations.
Theory : (Σ : Signature) → (X : sorts Σ → Set) → (ar : List (sorts Σ)) → Set Theory Σ X ar = HVec (Equation Σ X) ar
We deviate from Goguen’s and Lin’s in that we assume that all the equations of a theory share the same set of variables, while they assume that each equation has its own set of quantified variables. Clearly, this simplification is harmless; if we have a theory where each equation has its own set of variables, we can take the union of those sets as the common set. As stressed by Goguen and Meseguer [18], quantifying equations is essential:
[. . . ] the naive unsorted rules of deduction for equational logic (namely, reflexivity, symmetry, transitivity and substitutivity) are not sound when extended to the many-sorted case in the obvious way; [. . . ] adding variable declarations to these rules yields a rule set that is sound.

Satisfiability
Let Σ be a signature and A be an algebra for Σ. We say that a conditional
equation t = tj if t1 = tj ,..., tn = tj is satisfied by A if for any environment
1	n
θ : X → A, Jt)θ = Jtj)θ, whenever Jti)θ = Jtj)θ for 1 ≤ i ≤ n. In order to formalize
satisfiability we first define when an environment models an equation.
_|=e_ : ∀ {Σ X A}→ (θ : Env X A) → {s : sorts Σ}→ Eq Σ X s → Set
_|=e_ θ {s} (t , t’) = _≈_ (A J s )s) (J t ) θ) (J t’ ) θ)
Using the point-wise extension of this relation we can write directly the notion of satisfiability.
_|=_ : ∀ {Σ X} (A : Algebra Σ) → {s : sorts Σ}→ Equation Σ X s → Set A |= (V eq if ( , eqs)) = ∀ θ → ((θ |=e_) * eqs) → θ |=e eq
We say that A is a model of the theory E if it satisfies each equation in E. As usual an equation is a logical consequence of a theory, if every model of the theory satisfies the equation.
_|=m_ : ∀ {Σ X ar}→ (A : Algebra Σ) → (E : Theory Σ X ar) → Set A |=m E = (A |=_) * E 
_ |=Σ _ : ∀ {Σ X ar s}→ (E : Theory Σ X ar) → (e : Equation Σ X s) → Set
_ |=Σ _ {Σ} E e = (A : Algebra Σ) → A |=m E → A |= e


Provability
As noticed by Huet and Oppen [22], the definition of a sound deduction system for multi-sorted equality logic is more subtle than expected. We formalize the system presented in [16], shown in Fig. 1. The first three rules are reflexivity, symmetry and


E ▶ ∀X, t = t
 E ▶ ∀X, t0 = t1 
E ▶ ∀X, t1 = t0
 E ▶ ∀X, t0 = t1	E ▶ ∀X, t1 = t2 
E ▶ ∀X, t0 = t2

∀Y, t = tj if t1 = tj ,..., tn = tj ∈ E	E ▶ ∀X, σ(ti)= σ(tj)

1	n
E ▶ ∀X, σ(t)= σ(tj)
i	σ : Y → TΣ(X)

E ▶ ∀X, t1 = tj	···	E ▶ ∀X, tn = tj
	1	n  f : [s1, ..., sn] ⇒Σ s
E ▶ ∀X, f (t1,..., tn)= f (tj ,..., tj )
1	n
Fig. 1. Deduction system
transitivity; the fourth rule, called substitution, allows to instantiate an axiom with a substitution σ, provided one has proofs for every condition of the axiom; 7 finally, the last rule internalizes Leibniz rule, for replacing equals by equals in subterms. Notice that we can only prove identities and not quasi-identities. We define the relation of provability as an inductive type, parameterized in the theory E, and indexed by the conclusion of the proof. For conciseness, we only show the constructor for transitivity:
data _▶_ {Σ X ar} (E : Theory Σ X ar) : ∀ {s}→ Eq Σ X s → Set where
ptrans : ∀ {s} {t0 t1 t2 }→ 
E ▶ (t0 , t1) → E ▶ (t1 , t2) → E ▶ (t0 , t2)
Let E be a theory over a signature Σ. It is straightforward to define a setoid over
|T| Σ Q X ¢ by letting t1 ≈ t2 if E ▶ t1 ≈ t2; this equivalence relation (thanks to the first three rules) is a congruence (because of the last rule) over the term algebra. We can also use the facility provided by the standard library to write proofs with several transitive steps more nicely, as can be seen in the next example.
Soundness and completeness are proved as in the mono-sorted case. For sound- ness one proceeds by induction on the derivations; completeness is a consequence of the fact that the quotient of the term algebra by provable equality is a model.
Theorem 3.1 (Soundness and Completeness) E ▶ t ≈ tj iﬀ E |=Σ t ≈ tj.
Let us remark that completeness does not imply that there is a decidability algorithm for every theory; i.e. this result gives no decision procedure at all.
Let E and Ej be two theories over the signature Σ. We say that E is stronger than Ej if every axiom e ∈ Ej can be deduced from E, written E ▶T Ej. Obviously if E is stronger than Ej, then any equation that can be deduced from Ej can also be deduced from E and any model of E is also a model of Ej.
A theory for Boolean Algebras
In this section we outline how to formalize an equational theory and illustrate each step by showing snippets of the formalization of a Boolean Theory presented by Rocha and Meseguer [28]. 8

7 In our formalization this rule is slightly less general because we assume all the equations are quantified over the same set of variables.
8 The full code is available in the file Examples/EqBool.agda of the repository.

Define the signature describing the language, and choose a family of sets for the variables. It helps if one also introduce an abbreviation for terms over the signature extended with variables.
data bool-ops : List T×T→ Set where
f t : bool-ops ([] '→ tt)
neg : bool-ops ([ tt ] '→ tt)
and or : bool-ops (([ tt , tt ]) '→ tt)
bool-sig : Signature
bool-sig = record {sorts = T; ops = bool-ops} vars : sorts bool-sig → Set
vars tt = N
Form : Set
Form = HU bool-sig Q vars ¢

Introduce smart-constructors for terms of the extended signature with variables to ease writing the axioms and proving theorems. Usually one has a smart- constructor for each operation and one per variable that is used in the axioms or the theorems.
true false : Form
true = term (inj1 t) ⟨⟩
false = term (inj1 f) ⟨⟩
p q : Form
p = term (inj2 0) ⟨⟩
q = term (inj2 1) ⟨⟩
_∧_ : Form → Form → Form
φ ∧ ψ = term and ⟨ φ , ψ ⟩
¬ : Form → Form
¬ φ = term neg ⟨ φ⟩

Define the equational theory by specifying one equation for each axiom and col- lect them in a theory; here one can appreciate the convenience of the smart- constructors. Here we only show two of the twelve axioms of the theory bool-theory. If one will prove theorems of the theory, then it is also convenient to define pattern-synonyms for the proofs that each axiom is in the theory.
commAnd leastDef : Equation bool-sig vars tt commAnd = V (p ∧ q) ≈ (q ∧ p) if ([] , ⟨⟩) leastDef = V (p ∧ (¬ p)) ≈ false if ([] , ⟨⟩)
bool-theory : Theory bool-sig vars [ tt , tt , . . . ]
bool-theory = ⟨ commAnd , leastDef , . . . ⟩
pattern commAndAx = here pattern leastDefAx = there here

Prove theorems using the axioms of the theory just defined. If a proof uses tran- sitivity, one can use the equational reasoning idiom provided by the standard library of Agda:
p1 : bool-theory ▶ (V ч p Λ p ≈ false) p1 = begin
ч p Λ p
≈⟨ psubst commAndAx σ1 ~⟨⟩ ⟩
p Λч p
≈⟨ psubst leastDefAx idSubst ~⟨⟩ ⟩
false
□
In the justification steps of this proof we use the substitution rule. The relevant actions of the substitution σ1 are σ1 p = ч p and σ1 q = p.

Morphisms between signatures
In this section we explain our formalization of morphisms between signatures; this notion is interesting because it provides a conceptual understanding of syntactic translations. After pointing to some related works, we motivate the usefulness of this notion by showing a relatively simple example: how to interpret the Boolean theory of the previous section in the propositional calculus of Dijkstra and Scholten. 9
The concept of morphism between signatures is related with the interpretability of similarity types in universal algebra (cf. [13]), and has an extensive literature: Fuji- wara [12] introduced this notion as mappings between algebraic systems, Janssen [23], following the ADJ group, called it a polynomial derivor and Mossakowski et al. [26] referred to it as a derived signature morphism, a generalization of the more restricted signature morphisms in the theory of institutions [15].
Let us analyze how to translate the Boolean theory of the previous section to the propositional calculus of Dijkstra and Scholten [10], whose only non-constant operations are equivalence and disjunction.
data bool-ops’ : List T×T→ Set where
f’ t’ : bool-ops’ ([] '→ tt)
equiv’ or’ : bool-ops’ ([ tt , tt ] '→ tt)
bool-sig’ : Signature
bool-sig’ = record {sorts = T , ops = bool-ops’}
It is clear that one can translate recursively any term over bool-sig to a term in bool-sig’ preserving its semantics. An alternative and more general way is to specify how to translate each operation in bool-sig using operations in bool-sig’. In this way, any bool-sig’-algebra can be seen as a bool-sig-algebra: a bool-sig-operation f

9 Rocha and Meseguer [27] study more thoroughly Boolean theories and their morphisms.


[s1,..., sn] HΣ i : si

(prj)
f : [s1, ..., sn] ⇒Σ s ar HΣt1 : s1 ··· ar HΣtn : sn (op)
ar HΣf (t1, ..., tn): s

Fig. 2. Type system for formal terms
is interpreted as the semantics of the translation of f. In particular, the translation of formulas is recovered as the initial homomorphism between |T| bool-sig and the transformation of |T| bool-sig’. In this section we formalize the concepts of derived signature morphism and reduct algebra as introduced, for example, by Sanella et al. [30].
Derived signature morphism
Although the disjunction from bool-sig can be directly mapped to its namesake in bool-sig’, there is no unary operation in bool-sig’ to translate the negation. In fact, we should be able to translate an operation as a combination of operations in bool-sig’ and also refer to the arguments of the original operation.
We introduce the notion of formal terms which are formal composition of pro- jections and operations. We introduce a type system, shown in Fig. 2, ensuring the well-formedness of these terms: the contexts are arities, i.e. lists of sorts, and identifiers are pointers (like de Bruijn indices). It can be formalized as an inductive family parameterized by arities and indexed by sorts.
data _H_ (ar’ : Arity Σ) : (sorts Σ) → Set where
#_ : (n : Fin (length ar’)) → ar’ H (ar’ !! n)
_|$|_ : ∀ {ar s}→ ops Σ (ar ⇒ s) → HVec (ar’ H_) ar → ar’ H s
A formal term specifies how to interpret an operation from the source signature in the target signature. The arity ar’ specifies the sort of each argument of the original operation. For example, since the operation neg is unary, we can use one identifier when defining its translation. Notice that bool-sig and bool-sig’ share the sorts; in general, one also considers a mapping between sorts.
A derived signature morphism consists of a mapping between sorts and a mapping from operations to formal terms:
record _‹→_ (Σs Σt : Signature) : Set where field
‹→s : sorts Σs → sorts Σt
‹→o : ∀ {ar s}→ ops Σs (ar , s) → (map ‹→s ar) H (‹→s s)
We show the action of the morphism on the operations neg and and
ops‹→ : ∀ {ar s }→ (f : bool-ops (ar '→ s)) → map id ar H s ops‹→ neg = equiv’ |$| ⟨ p , f’ ⟩
ops‹→ and = equiv’ |$| ⟨ equiv’ |$| ⟨ p , q ⟩ , or’ |$| ⟨ p , q ⟩⟩ 
where p = # zero and q = # (suc zero).

Transformation of Algebras
A signature morphism m : Σs ‹→ Σt induces a functor from Σt-algebras to Σs- algebras. Given a Σt-algebra A, we denote with ⟨A⟩ the corresponding Σs-algebra, which is known as the reduct algebra with respect to the morphism m. Let us sketch the construction of the functor on algebras: the interpretation of a Σs-sort s is given by ⟨A⟩s = A(m s) and for interpreting an operation f in the reduct algebra ⟨A⟩ we use the interpretation of the formal term mf , which is recursively defined by

J_)t : ∀ {ar s}→ ar H s → A J ar )s*  → A J s )s  J # n )t as = as !!v n 
J f |$| ts )t as = A J f )o ⟨$⟩ J ts )t* as

Identifiers denote projections and the application of the operation f to formal terms ts is interpreted as the interpretation of f applied to the denotation of each term in ts, the function J_)t* extends J_)t to vectors.
We can formalize the reduct algebra in a direct way, however the interpretation of operations is a little more complicated, since we need to convince Agda that any vector vs : HVec (A J_)s ◦ ‹→s) is has also the type HVec A (map ‹→s is), which is accomplished by reindex-ing the vector (we omit the proof of cong):

module ReductAlg (m : Σs ‹→ Σt) (A : Algebra Σt) where
⟨_⟩s : → (s : sorts Σs) → Setoid
⟨ s ⟩s = A J ‹→s m s )s

⟨_⟩
: ∀ {ar s}→ ops Σ (ar ⇒ s) → (⟨_⟩ ) ∗ ar ≈	s ⟩

o	s	s
−→⟨	s

⟨ f ⟩o = record {_⟨$⟩_ = J ‹→o m f )t ◦ reindex (‹→s m); cong = ...}
_⟨_⟩ : Algebra Σs
_⟨_⟩ = record {_J_)s  = ⟨_⟩s , _J_)o  = ⟨_⟩o }

The action of the functor on homomorphisms is also straightforward.
A more interesting example of signature morphisms and reduct algebras is the definition of a compiler as presented in [33]. One defines a signature for the source language and another one for the target language; these languages are the term algebras over their respective signatures. A compiler is specified by a signature morphism from the source signature to the target signature: indeed the compiler is obtained as the unique homomorphism from the source algebra to the reduct algebra of the target algebra. Moreover, one can obtain a correct compiler by providing semantics of each language as algebras and a morphism between the source semantics and the reduct of the target semantics. 10


10 We explored this idea by defining a correct compiler for an arithmetic language targeting a stack-based language; it can be found at the repository in Examples/CompilerArith.agda.

Translation of theories
From a signature morphism m : Σs ‹→ Σt one gets the translation of ground Σs terms as the initial homomorphism from |T| Σs to ⟨ |T| Σt ⟩. With an appropriate extension to variables, this translation applied to a theory Es over Σs yields the theory E˜s over Σt. Moreover if At |= E˜s, one would think that the reduct ⟨At⟩ is a model of the original theory, i.e. ⟨At⟩ |= Es. Even better, if Et is a stronger theory than the translated theory E˜s and if At is a model for Et, we would like that the reduct algebra models Es. In Agda such a result would be realized as a function
|=‹→ with the following type (where ‹→* Es is the translation of Es):
|=‹→ : ∀ At Et Es → At |=m Et → (Et ▶T ‹→* Es) →⟨ At ⟩ |=m Es

With the morphism m : Σs ‹→ Σt, one can define the translation of open terms from |T| Σs Q Xs ¢ to |T| Σt Q Xt ¢ using initiality if we also have a renaming function ‹→v : {s : sorts Σs } → Xs s → Xt (m ‹→s s). In general, however, we cannot prove the satisfaction property: if a Σt-algebra models the translation of an equation, then its reduct models the original equation. The technical issue is the impossibility of defining a Σt-environment from a Σs-environment. There is a well-known solution which consists on restricting the set of variable of the target signature by letting Xt =	Xs. Under this restriction, we can prove the satisfaction property and furthermore define the function |=‹→. Such a restriction over the set of variables seems to us as an impediment, which can be alleviated if the original variables of Et are included in the calculated set of variables.

Conclusions
As far as we know, heterogeneous universal algebra has not attracted a great interest in the academic community of type theory. In this paper, we have developed in Agda a library with the main concepts of heterogeneous universal algebra, up to the proof of the three isomorphisms theorems and the freeness of the term algebra over a set of variables. In order to define the term algebra we have introduced heterogeneous vectors, which later turned out to be very useful in other parts of the library, for example as the set of axioms of finite theories and as premises of deduction rules. We further introduced a formal system for conditional equational logic and proved its soundness and completeness with respect to Goguen and Meseguer semantics (we refer the reader to [34] for a deeper explanation of this result recasting it on a categorical setting). Finally, we defined a novel representation for (derived) signature morphisms and its associated contra-variant functor on algebras. We also showed that, under some restrictions, this functor also preserves models.
Related Work. Let us contrast our work with other formalizations covering some aspects of universal algebra. As far as we know, since Capretta’s [7] first mechaniza- tion of universal algebra and its further extension to equational logic in his thesis, the closest new works are Kahl’s [24] formalization of allegories and the development of the algebraic hierarchy lead by Spitters [31]. Capretta considered only finitary

signatures and his work does not encompass signature morphisms. Spitters and his co-workers developed some very preliminary definitions of universal algebra, because their goal is to use the notion of variety to define the algebraic hierarchy up to the construction of the reals; in particular they use Coq’s typeclasses to have a cleaner representation of algebraic structures.
Future Work. We think that this development opened the path to several further work, in particular: (i) a natural step is to formalize institutions;(ii) consider algebras of binding structures as proposed by Fiore [11], Capretta’s and Felty’s formalization
[8] of higher-order algebras might be an interesting starting point;(iii) introduce mul- ti-sorted rewriting;(iv) formalize more of the mathematical theory behind universal algebra, for example Birkhoff’s (quasi)-variety characterization; and(v) explore the idea of using completeness and soundness for automating the proof of identities in algebraic structures.
Acknowledgement
We are grateful to the anonymous referees for their careful reading and suggestions.

References
Barthe, G., V. Capretta and O. Pons, Setoids in type theory, J. Funct. Program. 13 (2003), pp. 261–293.
Birkhoff, G., On the structure of abstract algebras, Mathematical Proceedings of the Cambridge Philosophical Society 31 (1935), p. 433–454.
Birkhoff, G., “Lattice Theory,” Colloquium Publications 25, American Mathematical Society, 1940.
Birkhoff, G. and J. D. Lipson, Heterogeneous algebras, J. of Combinatorial Theory 8 (1970), pp. 115– 133.
Bove, A., P. Dybjer and U. Norell, A brief overview of agda - A functional language with dependent types, in: TPHOLs, Lecture Notes in Computer Science 5674 (2009), pp. 73–78.
Burstall, R. M., Proving Properties of Programs by Structural Induction, The Computer Journal 12
(1969), pp. 41–48.
URL http://dx.doi.org/10.1093/comjnl/12.1.41

Capretta, V., Universal algebra in type theory, in: International Conference on Theorem Proving in Higher Order Logics, Springer, 1999, pp. 131–148.
Capretta, V. and A. Felty, Higher-order abstract syntax in type theory, in: S. B. Cooper, H. Geuvers,
A. Pillay and J. Väänänen, editors, Logic Colloquium 2006, Lecture Notes in Logic 32 (2009), pp. 65–90.
Danielsson, N. A. and The Agda Team, The agda standard library, version 0.12, https://github.com/ agda/agda-stdlib (2015).
Dijkstra, E. W. and C. S. Scholten, “ Predicate Calculus and Program Semantics,” Springer New York, New York, NY, 1990.
URL  http://dx.doi.org/10.1007/978-1-4612-3228-5

Fiore, M. and O. Mahmoud, Second-order algebraic theories, in: International Symposium on Mathematical Foundations of Computer Science, Springer, 2010, pp. 368–380.
Fujiwara, T., On mappings between algebraic systems, Osaka Math. J. 11 (1959), pp. 153–172.
URL http://projecteuclid.org/euclid.ojm/1200689635
García, O. C. and W. Taylor, The lattice of interpretability types of varieties, Mem. Amer. Math. Soc.
50 (1984), pp. v+125.
URL http://dx.doi.org/10.1090/memo/0305


Goguen, J. A., Memories of ADJ, Bulletin of the EATCS 39 (1989), pp. 96–102.
Goguen, J. A. and R. M. Burstall, Institutions: Abstract model theory for speciﬁcation and programming, J. ACM 39 (1992), pp. 95–146.
URL http://doi.acm.org/10.1145/147508.147524

Goguen, J. A. and K. Lin, Specifying, programming and verifying with equational logic., in: We Will Show Them! Essays in Honour of Dov Gabbay, Volume Two (2005), pp. 1–38.
Goguen, J. A. and J. Meseguer, Completeness of many-sorted equational logic, SIGPLAN Notices 17
(1982), pp. 9–17.
URL http://doi.acm.org/10.1145/947886.947887

Goguen, J. A. and J. Meseguer, Remarks on remarks on many-sorted equational logic, SIGPLAN Notices 22 (1987), pp. 41–48.
Goguen, J. A., J. W. Thatcher, E. G. Wagner and J. B. Wright, Abstract data types as initial algebras and the correctness of data representations, in: Conference on Computer Graphics, Pattern Recognition, & Data Structure, UCLA (1975), pp. 89–93.
Goguen, J. A., J. W. Thatcher, E. G. Wagner and J. B. Wright, Initial algebra semantics and continuous algebras, J. ACM 24 (1977), pp. 68–95.
Gonthier, G., A. Asperti, J. Avigad, Y. Bertot, C. Cohen, F. Garillot, S. L. Roux, A. Mahboubi,
R. O’Connor, S. O. Biha, I. Pasca, L. Rideau, A. Solovyev, E. Tassi and L. Théry, A machine-checked proof of the odd order theorem, in: ITP, Lecture Notes in Computer Science 7998 (2013), pp. 163–179.
Huet, G. and D. C. Oppen, Equations and rewrite rules: a survey, Technical Report STAN//CS-TR- 80-785, Stanford University, Department of Computer Science (1980).
Janssen, T. M., Algebraic translations, correctness and algebraic compiler construction, Theoretical Computer Science 199 (1998), pp. 25–56.
Kahl, W., Dependently-typed formalisation of relation-algebraic abstractions, in: RAMICS, Lecture Notes in Computer Science 6663 (2011), pp. 230–247.
Meinke, K. and J. V. Tucker, Universal algebra, in: S. Abramsky and T. S. E. Maibaum, editors, Handbook of Logic in Computer Science (Vol. 1), Oxford University Press, Inc., New York, NY, USA, 1992 pp. 189–368.
Mossakowski, T., U. Krumnack and T. Maibaum, What is a derived signature morphism?, in: Revised Selected Papers of the 22Nd International Workshop on Recent Trends in Algebraic Development Techniques - Volume 9463, WADT 2014 (2015), pp. 90–109.
Rocha, C. and J. Meseguer, Five isomorphic boolean theories and four equational decision procedures, Technical report, University of Illinois at Urbana-Champaign (2007).
Rocha, C. and J. Meseguer, Theorem proving modulo based on boolean equational procedures, in:
RelMiCS, Lecture Notes in Computer Science 4988 (2008), pp. 337–351.
Salvesen, A. and J. M. Smith, The strength of the subset type in Martin-Löf’s type theory, in: Proceedings of the Third Annual Symposium on Logic in Computer Science (LICS ’88), Edinburgh, Scotland, UK, July 5-8, 1988 (1988), pp. 384–391.
URL https://doi.org/10.1109/LICS.1988.5135

Sannella, D. and A. Tarlecki, “Foundations of algebraic specification and formal software development,” Springer Science & Business Media, 2012.
Spitters, B. and E. van der Weegen, Type classes for mathematics in type theory, Mathematical Structures in Computer Science 21 (2011), pp. 795–825.
Tarlecki, A., Some nuances of many-sorted universal algebra: A review, Bulletin of the EATCS 104
(2011), pp. 89–111.
URL http://albcom.lsi.upc.edu/ojs/index.php/beatcs/article/view/79

Thatcher, J. W., E. G. Wagner and J. B. Wright, More on advice on structuring compilers and proving them correct, Theoretical Computer Science 15 (1981), pp. 223–249.
Vidal, J. C. and J. S. Tur, On the completeness theorem of many-sorted equational logic and the equivalence between Hall Algebras and Bénabou theories, Reports on Mathematical Logic 40 (2006),
pp. 127–158.
URL  http://www.iphils.uj.edu.pl/rml/rml-40/06-climent.pdf
