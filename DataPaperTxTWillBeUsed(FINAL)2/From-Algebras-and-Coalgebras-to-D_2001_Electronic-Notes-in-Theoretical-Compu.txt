Electronic Notes in Theoretical Computer Science 44 No. 1 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume44.html 19 pages


From Algebras and Coalgebras to Dialgebras

Erik Poll and Jan Zwanenburg
University of Nijmegen
Toernooiveld 1, 6525 ED Nijmegen, The Netherlands


Abstract
This paper investigates the notion of dialgebra, which generalises the notions of alge- bra and coalgebra. We show that many (co)algebraic notions and results can be gen- eralised to dialgebras, and investigate the essential differences between (co)algebras and arbitrary dialgebras.


Introduction
An algebra is a set X together with some functions that can be used to con- struct elements of X, i.e. functions fi that have X as output type,
fi : INi(X) → X,
with INi a polynomial functor. Algebras are widely used in (theoretical) computer science. E.g. think of algebraic datatypes such as lists and trees, or algebraic specifications.
A coalgebra is a set X together with some functions that can be used to
observe elements of X, i.e. functions fi that have X as input type,
fi : X → OUTi(X),
with OUTi a polynomial functor. Coalgebras can be used to describe various kinds of ‘dynamical systems’, e.g. automata, processes, or (labelled) transition systems [21]. Moreover, elements of coalgebras can viewed as objects in the sense of object-oriented (OO) programming [17], in which case the operations are viewed as methods.
For an introduction to – and a comparison between – algebras and coal- gebras we refer to [11]. Algebras and coalgebras are dual notions, and are in some intuitive sense ‘opposites’. However, this does not mean that algebra and coalgebra do not have certain things in common. Indeed, the standard example of an algebraic specification, stacks, also occurs in the literature as an example of a coalgebraic specification!

1 Email: {erikpoll,janz}@cs.kun.nl
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


This paper investigates the notion of dialgebra, a straightforward general- isation of (co)algebra: a dialgebra is a set X together with some functions
fi : INi(X) → OUTi(X)
with INi and OUTi polynomial functors. The name ‘dialgebra’ is taken from [4]. Clearly all algebras and coalgebras are dialgebras.
An example of a dialgebra that is neither an algebra nor a coalgebra is a type Set of sets of natural numbers with operations
empty :	Set
add : Set × Nat → Set elem : Set × Nat → bool union : Set × Set → Set
min :	Set → 1+ Nat split : Set × Nat → Set × Set
Here min could for instance return the minimum of a set, if the set is non- empty, and an element of a unit type 1 if the set is empty, and split(s,n) could split the set s in a pair of sets, one containing the elements of s smaller than n and the other containing the rest. This is not an algebra, because for instance split and min are not ‘algebraic’, nor is it a coalgebra, because for instance empty and the binary operation union are not ‘coalgebraic’.
Many interesting examples of dialgebras that are not (co)algebras can be obtained simply by extending a coalgebra with an operation init :1 → X that yields some initial state. Including such an operation is a very natural thing to do for many examples of coalgebras. In particular, this is very natural when considering objects in the sense of OO: here using dialgebras rather than coalgebras makes it possible to account for the constructors as well as the methods of a class. In addition it becomes possible to account for so-called binary methods.
We will show that most (co)algebraic notions can be defined for the more general dialgebraic case, and investigate in how far properties of (co)algebras – in particular properties of invariants and bisimulations – can be generalised to arbitrary dialgebras, to get a better understanding of what the essential differences between algebras, coalgebras, and dialgebras are.

Mathematical Preliminaries
Throughout this paper, types will just be sets. Signatures are mappings from types to types, written as type expressions containing a type variable X.
Definition 2.1 A signature Σ(X) is a type expression, possibly containing the type variable X, of the form
Σ(X) ::= X | C | Σ1(X)+ Σ2(X) | Σ1(X) × Σ2(X) | Σ1(X) → Σ2(X),


where C comes from a collection of base types. Here A × B is the Cartesian product, with projections π1 : A × B → A and π2 : A × B → B, and A + B the disjoint sum, with injections inl : A → A + B and inr : B → A + B. The functions [f1, f2]: A1 + A2 → B for fi : Ai → B, and ⟨g1, g2⟩ : A → B1 × B2 for gi : A → Bi are defined as usual.
A polynomial signature is a signature of the form
F (X) ::= X | C | F1(X)+ F2(X) | F1(X) × F2(X).
N.B. We deliberately exclude constant exponents of the form C → F (X) as polynomial functors, because we have not been able to prove our most interesting result, Theorem 3.20, if we include these.
Polynomial signatures are functors, and F (f ) : F (A) → F (B) is defined in the usual way for f : A → B. The notions of predicate and relation lifting can be defined not just for polynomial signature but for all signatures: we can define predicate and relation lifting for arbitrary signatures.
Definition 2.2 For predicates P and Q we define the predicates
(P ×pred Q)(x) ⇐⇒ P (π1(x)) ∧ Q(π2(x))
(P +pred Q)(x) ⇐⇒ (x = inl(x') ∧ P (x')) ∨ (x = inr(x') ∧ Q(x'))
(P →pred Q)(f ) ⇐⇒ ∀x ∈ A. P (x) ⇒ Q(f (x)), with A the domain of P .
Definition 2.3 For relations R and S we define the relations
R +rel S = {(inl(x), inl(y)) | (x, y) ∈ R}∪ {(inr(x), inr(y)) | (x, y) ∈ S}
R ×rel S = {(x, y) | (π1(x), π1(y)) ∈ R ∧ (π2(x), π2(y)) ∈ S}
R →rel S = {(f, g) | ∀(x, y) ∈ R. (f (x), g(y)) ∈ S}
Definition 2.4 Let Σ(X) be an arbitrary signature. For a predicate P on X and a relation ∼ ⊆ X × Y , the predicate Σpred(P ) on Σ(X) and the relation Σrel(∼) ⊆ Σ(X) × Σ(Y ) are defined, by induction on the structure of Σ(X), as
if Σ(X)= X then Σpred(P )= P and Σrel(∼)= ∼,
if Σ(X) = C then Σpred(P ) = TrueC, the constant predicate ‘true’ on C, and Σrel(∼)= IdC, the identity relation on C,
if Σ(X)= Σ1(X)+ Σ2(X) then Σpred(P )= Σ1(P ) +pred Σ2(P ) and Σrel(∼)= Σ1(∼) +rel Σ2(∼),
if Σ(X)= Σ1(X) × Σ2(X) then Σpred(P )= Σ1(P ) ×pred Σ2(P ) and Σrel(∼)= Σ1(∼) ×rel Σ2(∼),
if Σ(X)= Σ1(X) → Σ2(X) then Σpred(P )= Σ1(P ) →pred Σ2(P ) and Σrel(∼)= Σ1(∼) →rel Σ2(∼).
Of course, if we identify predicates with subsets, then there is no difference between Σ and Σpred. The notion of relation lifting is not just used in the coalgebraic literature (e.g. [10]), but is much more widely used, notably for

logical relations in the semantics of typed lambda calculus (see [12] for a comprehensive overview) and to formalise the notion of parametricity (e.g. see [14]).
Lemma 2.5 Let Σ(X) be an arbitrary signature. Then
Σpred(TrueX)= TrueΣ(X)
Σrel(IdX)= IdΣ(X)
Proof. Induction on the structure of Σ(X).	✷
For polynomial signatures, there is a close connection between relation and function lifting:
Lemma 2.6 For any polynomial signature F (X)
graph(F (f )) = Frel(graph(f ))
where graph(f ) ⊆ A × B is the function f : A → B viewed as a relation.
Proof. Induction on the structure of F (X).	✷
Lemma 2.7 Let F (X) be a polynomial signature, and let i range over I.
Then
P ⊆ Q ⇒ Fpred(P ) ⊆ Fpred(Q)
R ⊆ S ⇒ Frel(R) ⊆ Frel(S)
i Fpred(Pi)= Fpred(  i Pi)
i Frel(Ri)= Frel(  i Ri) if I is not empty.
i Fpred(Pi) ⊆ Fpred(  i Pi)
i Frel(Ri) ⊆ Frel(  i Ri)
Frel(R; S)= Frel(R); Frel(S)
Proof. All these can be proved by induction on the structure of F (X). Prop- erties 3. and 4. are also easy consequences of 1. and 2., respectively.    ✷
None of the properties in Lemma 2.7 hold for arbitrary signatures. Note that we have stronger properties for intersection, (iii) and (iv), than for union,
(v) a nd (vi). The properties	i Fpred(Pi) = Fpred(  i Pi) and	i Frel(Ri) = 
ples, take F (X)= X × X), but do hold for some polynomial signatures:
Lemma 2.8 Let F (X) be a polynomial signature with at most one occurrence of X. Then
i Fpred(Pi)= Fpred(  i Pi)
i Frel(Ri)= Frel(  i Ri)
Proof. Induction on the structure of F (X). Of course, for F (X) with no occurrence of X – i.e. F (X) a constant – the property is trivial.	✷

Dialgebras
Definition 3.1 A dialgebraic signature is a signature of the form
Σ(X)= Σ1(X) × ... × Σn(X),
with each Σi(X) of the form
Σi(X)= INi(X) → OUTi(X),
with INi(X) and OUTi(X) polynomial signatures. Σ(X) is called algebraic
iff OUTi(X)= X for all i, and coalgebraic iff INi(X)= X for all i.
Throughout the remainder of this paper, Σ will be a dialgebraic signature of the form
Σ(X)=   Σi =   INi(X) → OUTi(X).
i∈I	i∈I
In examples Σ(X) will usually be a labelled product rather than unlabelled one; this is just syntactic sugar.
Definition 3.2 A Σ-dialgebra is a pair (A, f ) consisting of a set A and a func- tion f ∈ Σ(A), i.e. f = (f1,..., fn) with fi ∈ Σi(A)= INi(A) → OUTi(A).
For (co)algebraic signatures, this is just the definition of Σ-(co)algebra. An important difference between dialgebras and (co)algebras is that whereas an algebra with n operations fi : Fi(X) → X can be turned into a algebra with the single operation, namely [f1,..., fn] : F1(X)+ ... + Fn(X) → X, and, similarly, a coalgebra with n operations fi : X → Fi(X) can be turned into a coalgebra with just one operation ⟨f1,..., fn⟩, we can not do something similar for dialgebras. A practical consequence is that most definitions and proofs for dialgebras have to be ‘point-wise’, quantifying over i.
Definition 3.3 Let (A, f ) and (B, g) be Σ-dialgebras. A Σ-homomorphism h : (A, f ) → (B, g) is a function from A to B that preserves the operations, i.e.
OUTi(h) ◦ fi = gi ◦ INi(h)
for all i.
For dialgebras that are (co)algebras, this is the standard notion of (co)algebraic homomorphism.
Lemma 3.4	(i) The identity idA is a homomorphism from (A, f ) to itself.
(ii) Homomorphisms are closed under composition, i.e. if h : (A, f ) → (A',f')
and h' : (A',f') → (A'',f'') then h' ◦ h : (A, f ) → (A'',f'').
Proof. Easy.	✷
Lemma 2.7 listed some properties for polynomial signatures that do not hold for arbitrary signatures. For dialgebraic signatures, we can salvage some of the properties mentioned in Lemma 2.7:

Lemma 3.5 Let Σ(X) be a dialgebraic signature, and let i range over I. Then
i Σpred(Pi) ⊆ Σpred( i Pi)
i Σrel(Ri) ⊆ Σrel(  i Ri) if I is not empty.
Σrel(R); Σrel(S) ⊆ Σrel(R; S)
Proof. The proofs are quite straightforward, using Lemma 2.7. We just give the proof of (i) for binary intersection; the others are similar.
f ∈ Σ(P ∩ Q)
⇐⇒ ∀j. fj ∈ Σj(P ∩ Q)
⇐⇒ ∀j. fj ∈ INj(P ∩ Q) → OUTj(P ∩ Q)
⇐⇒ ∀j. ∀x ∈ INj(P ∩ Q). fj(x) ∈ OUTj(P ∩ Q)
⇐⇒ ∀j. ∀x ∈ INj(P ) ∩ INj(Q). fj(x) ∈ OUTj(P ) ∩ OUTj(Q) by Lemma 2.7(iii) (twice)
⇐	∀j. (∀x ∈ INj(P ). fj(x) ∈ OUTj(P ))
∧(∀x ∈ INj(Q). fj(x) ∈ OUTj(Q))
⇐⇒ ∀j. fj ∈ INj(P ) → OUTj(P ) ∧ fj ∈ INj(Q) → OUTj(Q)
⇐⇒ ∀j. fj ∈ Σj(P ) ∩ Σj(Q)
⇐⇒ f ∈ Σ(P ) ∩ Σ(Q)
✷

Invariants and sub-dialgebras
The notion of invariant is used in the literature both for algebras and for coalgebras. Intuitively, a predicate is an invariant if all the operations preserve it:
Definition 3.6 A predicate P on A is an invariant for a Σ-dialgebra (A, f ) iff f ∈ Σpred(P ).
For dialgebras that are (co)algebras, this is the standard notion of (co)algebraic invariant. Given an invariant we can construct a sub-dialgebra:
Definition 3.7 A sub-dialgebra of a Σ-dialgebra (A, f ) is another Σ-dialgebra (A',f) with A' ⊆ A.
For dialgebras that are (co)algebras, this is the standard notion of sub-(co)algebra. For (A',f) to be a sub-dialgebra of (A, f ) all the functions in f have to be ‘closed’ under the subset A' of A.
Lemma 3.8 Invariants are closed under intersection.
Proof. Follows immediately from Lemma 3.5: if f ∈ Σ(P ) and f ∈ Σ(Q) then f ∈ Σ(P ) ∩ Σ(Q) ⊆ Σ(P ∩ Q) by Lemma 3.5.	✷
As a consequence of this lemma, we can define the smallest invariant of a di- algebra as the intersection of all invariants. This strongest invariant expresses

exactly the property of being ‘reachable’ by the dialgebra operations.
Invariants of dialgebras are not always closed under union:
Example 3.9 Let T (X) = X × X → X and consider the T -(di)algebra (Z, +). The predicates N eg(x) = x < 0 and P os(x) = x > 0 on Z are both invariants, but clearly their union is not, because the sum of a positive and a negative number may be 0.
For coalgebras, however, we do have this property (e.g. see [21,11]):
Lemma 3.10 For coalgebras, invariants are closed under union.
A useful consequence of this lemma is that, for a coalgebra, given any property Φ there exist a largest invariant Φ ⊆ Φ, namely the union of all invariants that are subsets of Φ. We can slightly generalise Lemma 3.10. For this we first define
Definition 3.11 Σ(X) has no binary methods if none of the INi(X) has more than one occurrence of X.
Clearly all coalgebras are dialgebras without binary methods. Many inter- esting examples of dialgebras without binary methods that are not coalgebras can be obtained in the way mentioned earlier, simply by extending a coalgebra with an operation that yields some initial state.
Note that (counter)Example 3.9 involves a binary method. Binary methods are already notorious in the theoretical computer science literature on object oriented (OO) programming; see [2]. Some properties of coalgebras, that do not hold for all dialgebras, do hold for all dialgebras without binary methods, including:
Lemma 3.12 For dialgebras without binary methods, invariants are closed under union.
Proof. Let Σ be a signature without binary methods. It suffices to prove that i Σpred(Pi) ⊆ Σpred( i Pi). The crucial property of dialgebraic signature without binary methods needed to prove this is that, since there is at most one occurrence of X in the INi(X),  i Fpred(INi)= Fpred(  i INi) by Lemma 2.8:
f ∈ Σ(P ) ∪ Σ(Q)
⇐⇒ ∀j. fj ∈ Σj(P ) ∪ Σj(Q)
⇐⇒ ∀j. fj ∈ INj(P ) → OUTj(P ) ∨ fj ∈ INj(Q) → OUTj(Q)
⇐⇒ ∀j. (∀x ∈ INj(P ). fj(x) ∈ OUTj(P ))
∨(∀x ∈ INj(Q). fj(x) ∈ OUTj(Q))
⇒	∀j. ∀x ∈ INj(P ) ∪ INj(Q). fj(x) ∈ OUTj(P ) ∪ OUTj(Q)
⇐⇒ ∀j. ∀x ∈ INj(P ∪ Q). fj(x) ∈ OUTj(P ) ∪ OUTj(Q) since INj(P ∪ Q)= INj(P ) ∪ INj(Q) by Lemma 2.8
⇒	∀j. ∀x ∈ INj(P ∪ Q). fj(x) ∈ OUTj(P ∪ Q)
since OUTj(P ) ∪ OUTj(Q) ⊆ OUTj(P ∪ Q) by Lemma 2.7

⇐⇒ ∀j. fj ∈ INj(P ∪ Q) → OUTj(P ∪ Q)
⇐⇒ ∀j. fj ∈ Σj(P ∪ Q)
⇐⇒ f ∈ Σ(P ∪ Q)
✷

Bisimulations, (partial) congruences, and quotient-dialgebras
The notion of bisimulation plays an important role in the literature on coalge- bras, as does the closely related notion of (partial) congruence in the literature on algebras.
Definition 3.13 A relation ∼ ⊆ A × B is a bisimulation between two Σ- dialgebras (A, f ) and (B, g) iff (f, g) ∈ Σrel(∼). Dialgebras (A, f ) and (B, g) are bisimilar if there exists a bisimulation between (A, f ) and (B, g).
For (co)algebras one has the property that (co)algebra homomorphisms are just functional bisimulations. This property also holds for dialgebras:
Lemma 3.14 Let (A, f ) and (B, g) be Σ-dialgebras and h be a function from A to B. Then h : A → B is a homomorphism iff graph(h) ⊆ A × B is a bisimulation.
Proof. Straightforward, using Lemma 2.6.	✷ Lemma 3.15 Bisimulations are closed under intersection and composition. Proof. Follows immediately from Lemma 3.5.	✷
Bisimulations between dialgebras are not always closed under union.	For coalgebras this is a basic property (e.g. see [21,11]):
Lemma 3.16 For coalgebras, bisimulations are closed under union.
An important consequence of this property of coalgebras is that between any two coalgebras there exists a largest bisimulation, namely the union of all bisimulations. For arbitrary dialgebras we do not have this property.
Lemma 3.17 For dialgebras without binary methods, bisimulations are closed under union.
Proof. Similar to Lemma 3.12.	✷
Of special interest are bisimulations between a dialgebra and itself:
Definition 3.18 A relation ∼⊆ A×A is a (partial) congruence on a dialgebra (A, f ) iff it is a bisimulation between (A, f ) and itself, – i.e. (f, f ) ∈ Σ(∼) – and it is a (partial) equivalence relation.
In [21], for coalgebras, what we call a congruence here is called a bisimula- tion equivalence. Given a (partial) congruence we can construct a quotient- dialgebra:

Definition 3.19 Let ∼ be a (partial) congruence on (A, f ). Then the quotient- dialgebra ([S]∼, [f ]∼) is the Σ-dialgebra ([S]∼, [f ]∼), where [S]∼ is the collection of ∼-equivalence classes, and [f ]∼ is the family of functions on ∼-equivalence classes induced by f .
As mentioned above, bisimulations are not closed under union. Congruences, however, are, in the following sense:
Theorem 3.20 Let Rj be congruences on the Σ-dialgebra (A, f ), for j ∈ J,
J /= ∅. Then ( j Rj) is also a congruence relation for (A, f ).
∗
Proof. See the appendix.	✷
So, for any dialgebra there exists a largest congruence relation, namely (the transitive closure of) the union of all congruences. Intuitively, this is the notion of observational equality for that dialgebra. In Section 3.3 below, we discuss this difference between dialgebras and coalgebras – the existence of largest congruences vs largest bisimulations – in more detail.
The property above does not hold for partial congruences: 2
Example 3.21 Let T (X) = X × X → Z and consider the T -(di)algebra (Z,f) where f is the function
f (x, y)= if y < 0 then x else 23
The relations R = N × N and IdZ on Z are both bisimulations, i.e. (x, x') ∈ R ∧ (y, y') ∈ R =⇒ f (x, y)= f (x', y')
(x, x') ∈ Id ∧ (y, y') ∈ Id =⇒ f (x, y)= f (x', y')
However, neither R ∪ Id nor (R ∪ Id)∗ is a bisimulation, since for instance (4, 5) ∈ R ∪ Id and (−1, −1) ∈ R ∪ Id, but f (4, −1) /= f (5, −1).
Coalgebras vs dialgebras: the problem with binary methods
Moving from coalgebras to dialgebras we gain something, notably the possi- bility of having binary methods. The price for this is that some properties are lost, namely
the existence of final coalgebras,
the existence of unique largest bisimulation between any two coalgebras.
These two properties are intimately connected, as the largest bisimulation relates precisely those elements that have the same image under the unique homomorphisms to the final coalgebra. The properties are useful because they provide a canonical notion of observational equality between elements of different coalgebras. Two different coalgebras (A, f ) and (B, g) with the

2 The property does hold for partial congruences if these all have the same domain; instead of the transitive and reflexive closure ( j Rj )∗ one then has to consider the transitive closure ( j Rj )+.


same signature Σ can be regarded as different implementations for classes with the same interface. The properties above then provide a canonical notion of equality between objects from these two classes: an object with an internal state a ∈ A – using implementation (A, f ) – is observationally equal to an object with an internal state b ∈ B – using implementation (B, g)– iff a  b, where a  b is the greatest bisimulation between (A, f ) and (B, g).
Below a simple (counter)example to illustrate the fundamental problem with the union of bisimulations caused by a binary method:
Example 3.22 Consider Σ(X) = (X × X → X) × (X → N) and the Σ- dialgebras Z = (Z, (+, abs)) and L = (List, (++, length)) with List the set of lists over some type, ++ the concatenation operation, and abs : Z → N the function returning the absolute value.
The relations ∼1 and ∼2,
∼1 = {(z, l) | z = length(l)}	∼2 = {(z, l) | z = −length(l)}
are bisimulations between Z and L. However, ∼1 ∪ ∼2 is not a bisimulation between Z and L; for example, if l is some list with three elements, then
−3(∼1 ∪ ∼2)l ∧ 3(∼1 ∪ ∼2)l /⇒ −3+3 (∼1 ∪ ∼2) l++l . 
The problem is that when the binary method (+ or ++) is used to observe an individual element (of Z or List, respectively), the operation + of Z offers different – more – observations than the operation ++ of L.
Binary methods are notorious in the literature on the theoretical foun- dations of object-oriented programming: in the presence of binary methods defining a satisfactory notion of subtyping becomes a problem [2]. This prob- lem is closely related to the fact that there is no canonical notion of ‘observa- tional equivalence’ in the presence of binary methods. Indeed, the coalgebraic definition of subtyping (see [15]) crucially depends on the existence of final coalgebras, or the existence of unique largest bisimulation between any two coalgebras.

Dialgebraic Specification
Just like algebras provide the basis for algebraic specification, coalgebras have been used as the basis for coalgebraic specification, notably in the experimental specification language CCSL [8,20]. We now consider a notion of dialgebraic specification, defined in exactly the same way. Because of lack of space, we have to omit many details of definitions and proofs.
For example, an equational dialgebraic specification for the dialgebraic signature of Set mentioned in the introduction could include
union(s,empty) = s union(s,t) = union(t,s)
elem(add(s,n),m) = (n=m or elem(s,m))


elem(union(s,t),n) = elem(s,n) or elem(t,n) elem(empty,n) = false
min(s) = inl(x) ⇐⇒ s = empty min(s) = inr(m) ⇒ elem(s,m) = true
min(s) = inr(m) ∧ elem(s,n) = true ⇒	m ≤ n union(split(s,m)) = s
.
A model of this dialgebraic specification would be a dialgebra providing an implementation of all the operations for which these equations hold. However, instead of insisting that models satisfy the equations above, one could also only require that they satisfy the equations above up to some congruence relation. This weaker notion of model makes sense because intuitively a congruence relation provides a notion of ‘observational equivalence’.
For example, consider a simple implementation of the specification above using lists, in which union is implemented as concatenation ++, i.e. some dialgebra L = (ListNat, (..., ++,.. .). This implementation does not satisfy
union(s,t) = union (t,s)
as concatenation is not commutative, but it does satisfy
union(s,t) ∼perm union (t,s)
where ∼perm is the relation on lists that relates permutations. If ∼perm is a congruence for L, then L can be regarded as a correct implementation of the specification.
To formally introduce a notion of equational specification for dialgebras, we need to introduce some syntax. We fix a dialgebraic signature Σ(X) = i∈I INi(X) → OUTi(X) and use names opi for the operations of the dialge-
bra:
Definition 4.1 The type expressions are given by
E ::= X | C | E1 + E2 | E1 × E2 | E1 → E2
where X stands for the carrier of the dialgebra, and C ranges over some collection of base types.
The term expressions is given by
e ::= opi | xE | cE | λxE.e | e(e) | inlE+E(e) | inrE+E(e) | π1(e) | π2(e) where xE is a variable of type E, and cE a constant of type E not containing
X. We assume an infinite number of variables for every type E. The collection
of well-typed terms is defined in the obvious way.
The propositions are given by
Φ ::= ¬Φ | Φ1 ∧ Φ2 | e1 =E e2 | ∀xE. Φ
where E is some type expression possibly containing X, and e1 and e2 are well-formed expressions of type E.

A dialgebraic speciﬁcation Φ is simply a closed proposition.
Note that the definition above allows more propositions than usually allowed in algebraic specification; for example, it allows universal quantifications over the type X → X.
Definition 4.2 The interpretation of a type E, term e, and proposition Φ in the dialgebra (A, f ), [ E ]]A,f , [[ e ]]A,f , and [ Φ ]A,f , are defined in the obvious way, by induction on the structure, interpreting X as A and opi : Σi(X) as fi : Σi(A).
Because terms and propositions can contain free variables, we have to define the interpretation of terms and propositions wrt. an environment η,

[[ e ]]η
and [ Φ ]η
, where the environment η assigns to every free variable xE

an interpretation in E(A).
Definition 4.3 A dialgebra (A, f ) satisﬁes specification Φ, written (A, f ) |= Φ, iff [ Φ ]A,f is true.
Now that we have a syntax, we can define a notion of observational equiv- alence:
Definition 4.4 Two Σ-dialgebras (A, f ) and (B, g) are observationally equiv- alent iff for all closed expressions e of some closed type E (i.e. a type E not containing X) the interpretation of e in (A, f ) is equal to its interpretation in (B, g).
As one would expect, bisimilar dialgebras are observationally equivalent:
Theorem 4.5 Let (A, f ) and (B, g) be Σ-dialgebras. If (A, f ) and (B, g) are bisimilar then they are observationally equivalent.
Proof. Let ∼ a bisimulation between (A, f ) and (B, g). For environments η
and ξ we write η ∼ ξ if (ρ(xE), ξ(xE)) ∈ Erel(∼) for all xE in their domains.

Then we can prove that ([[ e ]]η
, [[ e ]]ξ
) ∈ Erel(∼) for all e : E and for all

η ∼ ξ, by induction on the derivation of e.	✷

Behavioural Satisfaction
We now consider a weaker notion of behavioural satisfaction of dialgebras satisfying specifications ‘up to some congruence relation’. First we define [[ Φ ]A,f, , the interpretation of Φ in the dialgebra (A, f ) wrt. a congruence  :
Definition 4.6 For   a congruence 3 on the dialgebra (A, f ), [ Φ ]η	is

defined as [ Φ ]η  , except that equality is interpreted as follows:
A,f, 

[[ e1 =E e1 ]]η
= ( [ e1 ]]η
, [[ e2 ]]η
) ∈ Erel(  )



3 One could also take a partial congruence, but then the semantics of types would have to be changed with [ X ]] = dom( ).


Note that if X does not occur in E, this simply reduces to

[[ e1 =E e1 ]]η
= ( [ e1 ]]η
= [[ e2 ]]η	)

A notion of behavioural satisfaction can now be defined as follows:
Definition 4.7 Let (A, f ) be a Σ-dialgebra and  a congruence relation for it. Then (A, f ) satisﬁes Φ with respect to , written (A, f ) |= Φ, iff [ Φ ]A,f, is true.
Theorem 4.8 (A, f ) |= Φ iff (A, f )/  |=Φ 
Proof. By induction on the structure of Φ we can prove that [ Φ ]A,f,  = [[ Φ ](A,f )/ . To prove this we must first prove relations between [ E ]]A,f and [[ E ]](A,f )/ , and [ e ]]A,f and [ e ]](A,f )/ , namely [ E ]]A,f /  = [[ E ]](A,f )/  and [[[ e ]]A,f ]E( ) = [[ e ]](A,f )/ .	✷
Definitions and results similar to the ones above can be found in the litera- ture for algebraic specifications, e.g. in [1,9,19]. We do not know of any similar definitions or results in the literature on coalgebras or coalgebraic specifica- tions. However, given that the notion of ‘observability’ plays a much more central role in the coalgebraic setting than in the algebraic setting, we believe that a notion of behavioural satisfaction makes even more sense for coalgebraic specifications than for algebraic ones.
More work would be needed to really exploit the opportunities offered by the notion of behavioural satisfaction when reasoning about specifications. In particular, one would want to establish that any consequences of a specification – in a particular logic – are not just valid for models satisfying the specification, but also for models behaviourally satisfying the specification. For algebras and algebraic specifications this idea is pursued in [1,9,19]. In a type-theoretic setting, this idea is illustrated in [16] and further investigated in [23]; the abstract data types considered here are more general than dialgebras.
Related Work
Several ways to combine algebras with coalgebras have been investigated over the past few years.
One way of combining algebra with coalgebra is to consider pairs consisting of an algebra and a coalgebra, sometimes called bi-algebras. This is done in
[7] and [3]. Dialgebras are clearly more general than algebra-coalgebra pairs. Using a algebra-coalgebra pair rules out operations f : IN (X) → OUT (X) where both INi(X) /= X and OUTi(X) /= X, for example a ‘partial’ binary operation f : X × X → 1+ X.
In [22] Tews introduces extended polynomial functors and coalgebras for these extended polynomial functors. This setting allows operations that are not possible in our dialgebra-setting, because a (restricted) use of → is possible in output types.  For example, g : X → (C1 → X)+ C2 is a coalgebra

for some extended polynomial functor, but cannot be an operation of any dialgebra. However, whereas our notion of dialgebras subsumes algebras, the setting of [22] does not; this setting is still strictly coalgebraic and does not allow algebraic operations, not even one as simple as g : C → X. In OO terminology, the setting of [22] allows binary methods but not constructors.
As for our dialgebras, for the coalgebras in [22] bisimulations turn out to be closed under intersection and composition, but not under union. It would be interesting to see if a result similar to Theorem 3.20, i.e. closure under union for congruences, could be proved for extended polynomial functors.
Dialgebras and dialgebraic specifications can be regarded as special cases of the abstract data types and the specifications for abstract data types con- sidered in a type-theoretic setting in [16,23]. Such a type-theoretic setting is also used in [5,6]. The crucial observation to link dialgebras with type theory is that dialgebras – and hence algebras and coalgebras – can be regarded as abstract datatypes. Abstract datatypes can be elegantly described in type theory using so-called existential types [13], and the logic for the notion of parametricity described in [14] then offers the expected proof rule for these existential types, namely that two implementations of an abstract datatype are equal if there exists a bisimulation between them.
This type-theoretic setting allows much wilder signatures than the dial- gebraic signatures considered in this paper. This suggests further generalisa- tions, for example with
operations with higher-order types, e.g.
map : SetNat × (N at → N at) → SetNat, or
polymorphic operations, i.e. operations with type parameters, e.g.
polymorphicMap : SetNat → ∀α.(N at → α) → Setα .
Finally, one of the referees drew our attention to [18], which introduces a notion of ‘nested sketches’ that support operations with arbitrarily structured in- and output types and seem more general than our dialgebras.

Conclusions
We have shown that the notion of dialgebra is a well-behaved generalisation of the notions of algebra and coalgebra. Dialgebras are more general than both algebras and coalgebras. The coalgebraic setting does for instance not allow ‘binary methods’, i.e. operations of type f : X × X → X, or operations returning an initial state i.e. operations of type f : 1 → X. The algebraic setting does not allow operations with complicated return types, e.g. ‘partial’ operations f : X → 1+ X.
We have shown that many notions used in the fields of algebra and coalge- bra are essentially identical, and can already be defined for the more general dialgebraic case: the (co)algebraic notions of homomorphism, invariant, bisim-

ulation, and (partial) congruence can all be extended to dialgebras, preserving many of the essential properties.
We have also shown that dialgebraic specification provide a generalisation of (co)algebraic specification, and indicated how the notion of behavioural satisfaction, used in the field algebraic specification, can be extended to dial- gebraic specifications (and hence also to coalgebraic specifications).
Given that (co)algebras are special cases of dialgebras, it is to be expected that some properties are lost when moving from algebras or coalgebras to dialgebras.
Most obviously, we no longer have the existence of initial c.q. final mod- els. However, as far as dialgebraic specifications are concerned losing these properties maybe is not too bad, given that one is usually interested in loose semantics anyway.
In addition to this, useful properties of coalgebras that do not hold for arbitrary dialgebras are closure under union for invariants and bisimulations (Lemmas 3.10 and 3.16). The fact that we do not have these closure properties can be traced back to so-called binary methods, which are already notorious in the literature on object-oriented programming because of the problems they cause with subtyping (see [2]). For dialgebras without binary methods we do still have the properties that invariants and bisimulations are closed under union.
For a given functor there exists a canonical notion of ‘observational equal- ity’ between elements of different coalgebras for that functor. An important consequence of the fact that for arbitrary dialgebras bisimulations are not closed under union, is that for a dialgebraic signature such a notion may not exist, as discussed in Section 3.3. However, in the dialgebraic setting we do still have a canonical notion of equality between elements of a single dialgebra, thanks to Theorem 3.20.
Future Work
Given the duality between algebras and coalgebras it is surprising that, whereas we did come across properties of coalgebras that do not hold for arbitrary di- algebras (namely closure properties for union, Lemmas 3.10 and 3.16), we did not come across (dual) properties of algebras that do not hold for arbi- trary dialgebras. Carefully dualising Lemmas 3.10 and 3.16 might reveal such properties.
Another direction for future work is to further investigate which notions and results from the fields of algebra and coalgebra – notably the well-developed field of algebraic specifications – could be generalised to dialgebras.
Finally, the notion of dialgebra we have introduced is fairly ad-hoc and very syntactic. The motivation behind the definition of dialgebra was that it is the natural ‘unification’ of the definitions of algebra and coalgebra. It would be interesting to investigate more semantical characterisations of some

notion of dialgebra, and to investigate in how far the restriction to polynomial functors could be relaxed, e.g. allowing the extended polynomial functors of [22].

Acknowledgments
We would like to thank Bart Jacobs and Hendrik Tews for comments on earlier versions of this paper.


Appendix: Proof of Theorem 3.20
Lemma 7.1 Basic properties of the operations + and × on relations are:
(R + S); (R' + S')= (R; R')+ (S; S')
(R × S); (R' × S')= (R; R') × (S; S')
R+ + S+ = (R + S)+
R+ × S+ = (R × S)+ if R and S are partially reflexive.
Here R+ denotes the transitive closure of R, and R is partially reflexive iff
∀(x, y) ∈ R. (x, x) ∈ R ∧ (y, y) ∈ R.

Proof. Easy.	✷

Lemma 7.2 Let F be a polynomial signature. Then F (R+)= F (R)+ if R is partially reflexive.

Proof. Induction on the structure of F , using Lemmas 7.1(iii) and 7.1(iv).✷

Lemma 7.3 Let i and j range over I and J, respectively.
i Ri +  j Sj =  i,j Ri + Sj if I and J are not empty.
i Ri ×  j Sj =  i,j Ri × Sj

Lemma 7.4 Let F be a polynomial signature. Let Rj be a equivalence relation

on A, for all j ∈ J, J /= ∅. Then F   j
Rj  ⊆   j
F (R ) +.


Proof. Induction on the structure of F .
F (X)= C or F (X)= X: trivial.

F (X)= F1(X)+ F2(X):
F1(Ri) + F2(Rj)
= F1(Ri; IdA) + F2(IdA; Rj)
= (F1(Ri); F1(IdA)) + (F2(IdA); F2(Rj))	by Lemma 2.7
= (F1(Ri)+ F2(IdA)) ; (F1(IdA)+ F2(Rj)) by Lemma 7.1(i)
⊆ (F1(Ri)+ F2(Ri)) ; (F1(Rj)+ F2(Rj))
since IdA ⊆ Ri, so Fk(IdA) ⊆ Fk(Ri)
= F (Ri); F (Rj)
so
F   j Rj  = F1   j Rj  + F2   j Rj 
⊆    F (R ) + +    F (R ) + by IH
=    F (R ) +   F (R ) +	by Lemma 7.1(iii)

= 
F (R ) + F (R ) +	by Lemma 7.3(i)

⊆ 
F (R ); F (R ) +	by the result above

i,j
=	( 
i
F (R )) ; ( 
j
F (R )) +	by Lemma 7.1(i)

⊆  (  j
F (R )) +	by definition of +.

F (X)= F1(X) × F2(X): Analogous.
✷
Lemma 7.5 (Closure of congruences under union)
Let Rj be congruences on the Σ-dialgebra (A, f ), for all j ∈ J, J /= ∅. Then
R  + is a congruence on (A, f ).
Proof. We just do the proof for binary union.
Let R and S be congruences on (A, f ), i.e. R and S are equivalence re- lations, (f, f ) ∈ Σ(R), and (f, f ) ∈ Σ(S). To prove: (f, f ) ∈ Σ((R ∪ S)+), i.e.
(fi, fi) ∈ Σi((R ∪ S)+)= INi  (R ∪ S)+  → OUTi  (R ∪ S)+ 
for all i.
Let (x, x') ∈ INi ((R ∪ S)+). To prove (fi(x), fi(x')) ∈ OUTi ((R ∪ S)+).
INi ((R ∪ S)+) = (INi(R ∪ S))+	by Lemma 7.2
⊆  (IN (R) ∪ IN (S))+ +	by Lemma 7.4
= (INi(R) ∪ INi(S))+	by definition of +.

So (x, x') ∈ (INi(R) ∪ INi(S))+, ie. there exist x1 ..., xn such that (x, x1), (x1, x2), . . . , (xn, x') ∈ INi(R) ∪ INi(S) .
Since R and S are bisimulations it then follows that
(fi(x), fi(x1)), (fi(x1), fi(x2)), . . . , (fi(xn), fi(x'))
∈ OUTi(R) ∪ OUTi(S)
⊆ OUTi(R ∪ S) by Lemma 2.7
and hence
(fi(x), fi(x')) ∈ (OUTi(R ∪ S))+
= OUTi ((R ∪ S)+) by Lemma 7.2
✷

References
M. Bidoit, R. Hennicker, and M. Wirsing. Behavioral and abstractor specifications. Science of Computer Programming, 25:149–186, 1995.
K.B. Bruce, L. Cardelli, G. Castagna, the Hopkins Objects Group (J .Eifrig, S. Smith, V. Trifonov), G.T. Leavens, and B.C. Pierce. On Binary Methods. Theory and Practice of Object Systems, 1(3):221–242, 1996.
C. Cˆırstea.	An algebra-coalgebra framework for system specification.	In
H. Reichel, editor, Coalgebraic Methods in Computer Science (CMCS’2000), number 19 in ENTCS, pages 81–112. Elsevier, Amsterdam, 2000.
T. Hagino. A categorical programming language. PhD thesis, University of Edinburgh, 1987.
J. Hannay.	Specification Refinement with System F.	In J. Flum and
M. Rodriguez-Artalejo, editors, Computer Science Logic (CSL’99), volume 1683 of LNCS, pages 530–545. Springer-Verlag, September 1999.
J. Hannay.	A Higher Order Simulation Relation for System F.	In
FOSSACS’2000, volume 1784 of LNCS, pages 130–145. Springer-Verlag, 2000.
R. Hennicker and A. Kurz. (Ω, Ξ)-logic: On the algebraic extension of coalgebraic specifications. In B. Jacobs and J. Rutten, editors, Coalgebraic Methods in Computer Science, number 19 in ENTCS, pages 195–212. Elsevier, Amsterdam, 1999.
U. Hensel, M. Huisman, B. Jacobs, and H. Tews. Reasoning about classes in object-oriented languages: Logical models and tools. In Ch. Hankin, editor, European Symposium on Programming (ESOP), number 1381 in Lecture Notes in Computer Science, pages 105–121. Springer, 1998.
M. Hofmann and D. Sannella. On behavioural abstraction and behavioural satisfaction in higher-order logic. Theoretical Computer Science, 167:3–45, 1996.


B. Jacobs. Invariants, bisimulations and the correctness of coalgebraic refinements. In M. Johnson, editor, Algebraic Methodology and Software Technology (AMAST’97), LNCS, pages 276–291. Springer, 1997.
B. Jacobs and J. Rutten. A tutorial on (co)algebras and (co)induction. EATCS Bulletin, 62:222–259, June 1997.
J.C. Mitchell. Foundations of Programming Languages. MIT Press, 1996.
J.C. Mitchell and G.D. Plotkin. Abstract types have existential type. ACM Trans. on Prog. Lang. and Syst., 10(3):470–502, 1988.
G.D. Plotkin and M. Abadi. A logic for parametric polymorphism. In Typed Lambda Calculi and Applications, volume 664 of Lecture Notes in Computer Science, pages 361–375, 1993.
E. Poll. A coalgebraic semantics of subtyping. In H. Reichel, editor, Coalgebraic Methods in Computer Science (CMCS’2000), number 33 in ENTCS, pages 281–
299. Elsevier, 2000.
E. Poll and J. Zwanenburg. A logic for abstract data types as existential types. In J.-Y. Girard, editor, Typed Lambda Calculi and Applications (TLCA’99), volume 1581 of LNCS, pages 310–324. Spinger, 1999.
H. Reichel. An approach to object semantics based on terminal co-algebras.
Mathematical Structures in Computer Science, 5:129–152, 1995.
H. Reichel. Nested sketches. Technical Report ECS-LFCS-98-401, Edinburgh University, Laboratory for Foundations of Computer Science, 1998.
H. Reichel.	Specification semantics.	In E. Astesiano, H.-J. Kreowski, and
B. Krieg-Bru¨ckner, editors, Algebraic Foundations of System Specifications, pages 131–158. Springer, 1998.
J. Rothe, H. Tews, and B. Jacobs. The coalgebraic class specification language CCSL. Journal of Universal Computer Science, 7(2):175–193, 2001.
J. Rutten. Universal coalgebra: a theory of systems. Theoretical Computer Science, 249:3–80, 2000.
H. Tews. Coalgebras for binary methods. In H. Reichel, editor, Coalgebraic Methods in Computer Science (CMCS’2000), number 33 in ENTCS. Elsevier, Amsterdam, 2000.
J. Zwanenburg. Object-Oriented Concepts and Proof Rules: Formalization in Type Theory and Implementation in Yarrow. PhD thesis, Eindhoven University of Technology, 1999.
