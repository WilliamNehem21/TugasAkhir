Electronic Notes in Theoretical Computer Science 41 No. 3 (2000)
URL: http://www.elsevier.nl/locate/entcs/volume41.html pages 1–19


Syntactic Type Soundness for the Region Calculus

Simon Helsen and Peter Thiemann
Institut fu¨r Informatik, Universita¨t Freiburg Georges-K¨ohler-Allee 79
D-79110 Freiburg, Germany
Email: {helsen,thiemann}@informatik.uni-freiburg.de


Abstract
The region calculus of Tofte and Talpin is an annotated polymorphically typed lambda calculus which makes memory allocation and deallocation explicit. It is intended as an intermediate language in a compiler for ML-like languages. The region annotations are obtained by static region and effect inference, which makes it an attractive alternative for garbage collection. Soundness of the region and effect system is crucial to guarantee safe deallocation of regions, i.e. deallocation should only take place for objects which are provable dead.
Tofte and Talpin have proved type soundness of the region calculus using rule- based co-induction. This proof is quite complicated and not very intuitive. Much of the problem lies in the low-level big-step operational semantics which involves manipulations of an explicit store and which has a co-inductive definition. In this paper, we present a small-step operational semantics for the region calculus, based on syntactic rewriting. We prove type soundness following the approach of Wright and Felleisen, leading to very simple inductive proofs.

Introduction
Memory management for dynamic data structures is a problem in program- ming. While memory allocation is dictated by the problem at hand, there is considerable freedom in memory deallocation. If deallocation happens too late, the program suffers from memory bloat and space leaks, which impede performance. If deallocation happens too early, there might be dangling point- ers into deallocated memory. Dereferencing a dangling pointer is unsafe and might lead to a crash, or worse, to wrong results.
Some languages (like C or Pascal) leave the deallocation problem entirely to the programmer, whereas others (like Smalltalk, Java, ML, and Haskell) perform automatic deallocation by incorporating garbage collection into the
◯c 2000 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


runtime system. While the programmer-based solution is immensely error- prone, programs can in principle be tuned for optimal memory use. Garbage collection avoids a large class of errors, but it has some problems, too. Since the garbage collector is, in general, unaware of the semantics of the running program, it must preserve all pointers reachable from a given set of root point- ers. This set is a conservative approximation of the set of pointers that will actually be used by the program. In consequence, deallocation might happen too late, which can lead to space leaks. In addition, garbage collection takes extra, non-productive time and can cause erratic pauses in the execution of programs. Finally, interoperability between garbage collected languages, like ML, and non-garbage collected languages, such as C, is difficult.
The region calculus of Tofte and Talpin [16, 15] provides an alternative method of memory management for the functional language ML. It is intended and used as an intermediate language in an ML compiler [2, 3, 14, 15, 16]. The basic idea is to split memory into regions that are allocated in a stack-like manner, directed by a construct of the language. Deallocation is instanta- neous, it just pops the topmost region from the stack. Using this method, it is possible to implement ML without garbage collection (in principle), while guaranteeing safety. In some instances, the region calculus can even prove that a pointer is semantically dead, so that the region it points to can be safely deallocated. Standard garbage collectors cannot do this.
Related Work and Contribution
The proof of consistency, or type soundness, for the region calculus as it is given by Tofte and Talpin [16] is a complicated proof using rule-based co- induction. The source of the complication is the co-inductive definition of consistency caused by the explicit use of a store in their big-step semantics. Recently, alternative type-soundness proofs for the region calculus have been proposed.
Crary, Walker, and Morrisett [6] provide an indirect soundness proof by translating the region calculus into their capability calculus. For the latter calculus, they provide a syntactic soundness proof.
Banerjee, Heintze, and Riecke [1] translate the region calculus into an extension of the polymorphic lambda calculus called F#. For the latter, they construct a semantic soundness proof, exploiting the properties of their original denotational model.
Dal Zilio and Gordon [18] modify the operational semantics of Tofte and Talpin so that it also keeps track of deallocated regions. Albeit artificial, this extra information allows an inductive definition of the consistency relation and an inductive correctness proof. Then they go on to show that this result is a consequence of a more general result for a typed π- calculus with name groups. This is shown using a translation from the region caculus to the typed π-calculus with name groups.

However, the question for a direct syntactic soundness proof for the region calculus is still open. The present paper provides such a soundness proof using the technique of Wright and Felleisen [17]. This approach requires a small- step operational semantics which is based on syntactic rewriting. The main challenge in the present work is the definition of a language of computational terms that captures the intuition of Tofte and Talpin’s big-step semantics and is suitable to define a small-step operational semantics for the region calculus. Most striking, our rewrite semantics only uses region annotations on values and avoids the use of an explicit store.
The proofs themselves use routine inductive techniques and are therefore considerably easier than the co-inductive proofs of Tofte and Talpin.
In contrast to the other soundness proofs [6, 1, 18], we treat the complete polymorphic region calculus. As noted by Tofte and Talpin [16], type poly- morphism does not add conceptual problems to the type soundness result, but polymorphic recursion gives rise to some subtle twists. We have included some illustrative cases in the paper.
After submission of this paper, we learned of another soundness proof by Calcagno [4]. He defines a high-level structural operational semantics and proves type soundness for it. The similarities between his big-step semantics and our small-step semantics are remarkable: the main difference is that our semantics is entirely based on syntactic rewriting, whereas his operational semantics propagates a set of live regions. Calcagno formally relates the high- level semantics to the original low-level semantics of Tofte and Talpin.

Overview
The rest of the paper is structured as follows: in Section 2 we introduce the region calculus. Section 3 presents the small-step operational semantics. Then, in Section 4, we recall the static semantics of Tofte and Talpin and provide the necessary extensions for our presentation. In Section 5, we prove syntactic type soundness. A small example is given in Section 6 and finally we conclude.

The region calculus
The region calculus, λregion, is an explicitly typed polymorphic lambda cal- culus, which makes memory allocation and deallocation explicit. Figure 1 defines its syntactic categories. Surface terms are built up from variables, integer constants, lambda abstractions, applications, and recursive function definitions, as usual in applied lambda calculi. A copy operation serves as a prototypical primitive operation. In addition, there are terms particular to the region calculus, region introduction and application of a region abstraction.
Memory is divided in regions of unbounded size, which are allocated and deallocated in a stack-like manner. The term, letregion Q in e, allocates


Surface Terms	e ::= x | c at Q | λ x. e at Q | e @ e | copy [Q1, Q2] e |
letrec f = a at Q in e | letregion Q in e |
f [Q1,..., Qn] at Q

Region Abstractions a ::= Λ[Q1,..., Qn].λ x. e

x ∈ Vname	some infinite set of variable names
f ∈ Fname	some infinite set of function names with Vname ∩ Fname = ∅

Fig. 1. Syntax of λregion
a new region, binds it to Q, evaluates e, and finally deallocates the region. Hence, the lifetime of a region corresponds with the lexical scope of Q. All memory-allocating constructs carry a region variable. It indicates the re- gion in which the allocation must be performed. Constants have a boxed representation, hence c at Q allocates memory in Q and stores the integer
c. A lambda abstraction λ x. e at Q builds a closure in region Q. The term letrec f = a at Q in e recursively binds the variable f to the closure of a region abstraction a, which is put into region Q. A region abstraction is a lambda term, which is abstracted over zero or more region variables. The term f [Q1,..., Qn] at Q is a region function application. It carries a region annota- tion because it copies the closure for the region abstraction Λ[Q1,..., Qn].λ x. e bound to f to an ordinary closure in region Q.
The term copy [Q1, Q2] e denotes a copy operation which moves the (integer) value of e from region Q1 to region Q2.
The set, free (e) ⊆ Vname ∪ Fname, contains all term variables occurring free in term e, with the usual definition. The set, frv (e), contains the free region variables of e. There are two constructs that bind region variables: Region abstraction Λ[Q1,..., Qn].λ x. e binds region variables Q1,..., Qn and letregion Q in e binds Q. All other occurrences of region variables are free. The term e is closed if it contains no free term variables (free (e) = ∅). A closed term may contain free region variables.

Dynamic semantics of λregion
Differing from Tofte and Talpin, we define a small-step operational semantics for λregion by a set of rewrite rules on computational terms. Computational terms extend λregion-terms by constructs that make intermediate computa- tional states explicit. Figure 2 defines the extended syntax and the small-step


Computational Terms e ::= x | v | c at ρ | λ x. e at ρ | e @ e | copy [ρ1, ρ2] e |
letrec f = γ in e | letregion Q in e |
γ' [ρ1,..., ρn] at ρ
Values	v ::= ⟨c⟩ρ | ⟨λ x. e⟩ρ
Regions	ρ ::= Q |• 
Region Abstractions	a ::= Λ[Q1,..., Qn].λ x. e
γ ::= a at ρ | ⟨a⟩ρ
γ' ::= f | ⟨a⟩ρ

Evaluation Contexts	E ::= [ ] |E @ e | v @ E | copy [ρ1, ρ2] E | 
letregion Q in E

c at Q →r ⟨c⟩ę	(1)
λ x. e at Q →r ⟨λ x. e⟩ę		(2) letrec f = a at Q in e →r letrec f = ⟨a⟩ę in e	(3) letregion Q in v →r v[•/Q]	(4)
copy [Q1, Q2] ⟨c⟩ę1 →r ⟨c⟩ę2	(5)
⟨λ x. e⟩ę @ v →r e[v/x]	(6)



letrec f = γ in e2 →r e2[⟨Λ[Q1,..., Qn].λ x. letrec f = γ in e1⟩ρ/f ] where	γ = ⟨Λ[Q1,..., Qn].λ x. e1⟩ρ
(7)



'	'	'	'	'
⟨Λ[Q1,..., Qn].λ x. e⟩ę [ρ1,..., ρn] at Q →r ⟨λ x. e[ρ1/Q1,..., ρn/Qn]⟩ę'	(8)


e →r e'

E [e] →r E [e']
Fig. 2. Small-step Operational Semantics
(9)

transition relation →r using the technique of evaluation contexts [9]. The relation →r is its reflexive and transitive closure.
None of the original terms qualifies as a syntactic value because each of them performs a non-trivial computation step, even if it only allocates mem- ory. Hence, we introduce three new value terms. The value ⟨c⟩ρ is a pointer

to an integer c in region ρ. The value ⟨λ x. e⟩ρ is a pointer to a closure in region ρ. The metavariable ρ ranges over region variables Q and a distinct dead region •, which is the union of all deallocated regions. For example, ⟨c⟩• is a dangling pointer to an integer in a deallocated region.
The third value term, ⟨a⟩ρ, is a pointer to the closure of a region ab- straction. It only occurs in conjunction with letrec and region function application. Evaluation allocates the closure when it enters a letrec term for the first time. Unfolding the recursion presumes that the closure is already allocated. Consequently, a region function application either starts with some function variable f or with a pointer to such a closure, after unfolding the recursion.
The rules (1), (2), and (3) deal with memory allocation of constants, lambda abstractions, and region abstractions, respectively. The rules (5), (6), and (7) are computation rules that define the copy operation, beta-value reduction, and unfolding of letrec. The notation, e[e'/x], stands for the term e with e' substituted for each free occurrence of x (and analogously for e[⟨a⟩ρ/f ]). Substitution avoids capture of term and region variables by re- naming. Rule (4) deallocates a region of memory by substituting • for the letregion-bound region variable, once the body has turned into a syntactic value. The substitution v[•/Q] replaces all free occurrences of Q in v with •. Rule (8) defines region function application, which is just beta reduction for region abstractions. Finally, Rule (9) is a context rule, which specifies a call- by-value semantics through the set E of evaluation contexts. All rules require that the regions involved in the reduction step are not dead, as indicated by the use of Q.

Static semantics of λregion
This section first summarizes the semantic objects of the static semantics, as defined by Tofte and Talpin [16]. Then, it discusses the type rules for surface terms and the extensions for computational terms.

Semantic objects
An effect ϕ is a finite set of regions, ρ, and effect variables, ϵ. The effect of a term, e, contains the set of regions that may be affected by evaluation of e. A type, τ , and a type with place, µ, are defined by


τ ::= α | int | µ
є.q
−−−→ µ	µ ::= (τ, ρ)

A type is either a type variable, α, an integer type, or a function type. Function types carry an arrow effect ϵ.ϕ. An arroweffect is a pair of an effect variable and an effect. Arrow effects are a technical device for type reconstruction of λregion [13]. The effect, ϕ, is the latent effect that happens on application of

the function. The effect variable identifies a group of functions that share an application. The use of effect variables corresponds to a simple flowanalysis. A type with place, µ, is a pair of a type, τ , and a region, ρ. The region specifies where an object of type with place µ is stored. If the region is dead
then the object cannot be accessed anymore.
A substitution, Ss = (St, Sr, Se), is a triple of
a type substitution, St, which maps type variables to types,
a region substitution, Sr, which maps region variables to regions, and
an effect substitution, Se, which maps effect variables to arrow effects. Application of Ss to effects, types, and types with places is defined as follows:


Ss(ϕ)= {Ss(ρ) | ρ ∈ ϕ}∪ {η | ϵ ∈ ϕ ∧ Se(ϵ)= ϵ'.ϕ' ∧ η ∈ {ϵ'}∪ ϕ'}
Ss(int)= int Ss(α)= St(α)	Ss(Q)= Sr(Q)	Ss(τ, ρ)= (Ss(τ ), Ss(ρ))


S (•)= •	S (µ
є.q
')= 
є'.(q'∪Ss(q))
'	where S (ϵ)= ϵ'.ϕ'

s	s	−−−→ µ
Ss(µ)
−−−−−−−→ Ss(µ )	e



The domain of Ss is the set of variables, for which Ss(α) /= α, Ss(Q) /= Q, and Ss(ϵ) /= ϵ.{}. The substitutions It and Ir are the identities on type and region variables, respectively. The substitution Ie maps every effect variable ϵ to ϵ.{}. Sometimes, Sr stands for (It, Sr, Ie) and e[ρ1/Q1,..., ρn/Qn] for Sr(e) where Sr = {Q1 '→ ρ1,..., Qn '→ ρn}.
Type schemes, σ ::= ∀ α .∀ s .∀ ę .τ , extend those of Damas and Milner [8] by binding type, effect, and region variables, with α a sequence of distinct type variables α1,..., αn and similarly for regions and effect variables.
A type τ is an instance of a type scheme σ = ∀ α .∀ s .∀ ę .τ ' via substitu- tion Ss, written τ ≺ σ via Ss, if the domain of Ss ⊆ {α, s, ę} and Ss(τ')= τ . The instance relation extends to type schemes by σ ≺ σ' iff, for all types τ , τ ≺ σ via Ss implies τ ≺ σ' via S' .
A type environment, TE, is a finite map that maps lambda-bound variables to pairs of the form (τ, ρ) and letrec-bound variables to pairs of the form (σ, ρ). The updated type environment, TE + {x '→ µ}, maps x to µ and otherwise behaves like TE.
Substitutions extend to type schemes, type environments, and expressions in the obvious way, avoiding capture by renaming.
Free variables of the above semantic objects are defined in the usual way. For a semantic object O, the free type, region, and effect variables of O are ftv (O), frv (O), and fev (O), respectively. Furthermore, fv (O) = ftv (O) ∪ frv (O) ∪ fev (O).






(var)
TE(x)= (τ, ρ)

TE ▶tt x : (τ, ρ), ∅



(alloc-const)


TE ▶tt c at ρ : (int, ρ), {ρ}



(alloc-abstr)
TE + {x '→ µ1} ▶tt e : µ2,ϕ	ϕ ⊆ ϕ'


є.q'

TE ▶tt λ x. e at ρ : (µ1 −−−→ µ2, ρ), {ρ}

{Q1,..., Qn, s}∩ (fv (TE) ∪ {ρ})= ∅	σˆ = ∀ s .∀ Q1,..., Qn .τ

(alloc-letrec)
TE + {f '→ (σˆ, ρ)} ▶tt λ x. e1 at ρ : (τ, ρ), {ρ}	σ = ∀ α .σˆ
{α}∩ ftv (TE)= ∅	TE + {f '→ (σ, ρ)} ▶tt e2 : µ, ϕ


TE ▶tt letrec f = Λ[Q1,..., Qn].λ x. e1 at ρ in e2 : µ, ϕ ∪ {ρ}




(app)
TE ▶tt e1 : (µ1
є.q
−−−→ µ2, ρ), ϕ1	TE ▶tt e2 : µ1, ϕ2

TE ▶tt e1 @ e2 : µ2,ϕ ∪ ϕ1 ∪ ϕ2 ∪ {ϵ, ρ}



(recvar1)
TE(f )= (σ, ρ)	σ = ∀ α .∀ s .∀ Q1,..., Qn .τ
τ' ≺ σ via (St, Sr, Se)	Sr = {Q1 '→ ρ' ,..., Qn '→ ρ' }

1	n
TE ▶tt f [ρ' ,..., ρ' ] at ρ' : (τ ', ρ'), {ρ', ρ}
1	n


(letregion)
TE ▶tt e : µ, ϕ	Q ∈/ frv (TE, µ) TE ▶tt letregion Q in e : µ, ϕ \ {Q}



(effect)
TE ▶tt e : µ, ϕ	ϵ ∈/ fev (TE, µ) TE ▶tt e : µ, ϕ \ {ϵ}



(copy)
TE ▶tt e : (int, ρ),ϕ 


TE ▶tt copy [ρ, ρ'] e : (int, ρ'),ϕ ∪ {ρ, ρ'}

Fig. 3. Static semantics - Part 1





(use-const)


TE ▶tt ⟨c⟩ρ : (int, ρ), ∅



(use-abstr)
TE + {x '→ µ1} ▶tt e : µ2,ϕ	ϕ ⊆ ϕ'


є.q'

TE ▶tt ⟨λ x. e⟩ρ : (µ1 −−−→ µ2, ρ), ∅

{Q1,..., Qn, s}∩ (fv (TE) ∪ {ρ})= ∅	σˆ = ∀ s .∀ Q1,..., Qn .τ

(use-letrec)
TE + {f '→ (σˆ, ρ)} ▶tt ⟨λ x. e1⟩ρ : (τ, ρ), ∅	σ = ∀ α .σˆ
{α}∩ ftv (TE)= ∅	TE + {f '→ (σ, ρ)} ▶tt e2 : µ, ϕ


TE ▶tt letrec f = ⟨Λ[Q1,..., Qn].λ x. e1⟩ρ in e2 : µ, ϕ




(recvar2)
TE ▶tt ⟨λ x. e⟩ρ' : (τ, ρ ), ∅	{Q1,..., Qn}∩ (frv (TE) ∪ {ρ})= ∅
τ' = Sr(τ )	Sr = {Q1 '→ ρ' ,..., Qn '→ ρ' }

1	n
TE ▶tt ⟨Λ[Q1,..., Qn].λ x. e⟩ρ [ρ' ,..., ρ' ] at ρ' : (τ ', ρ'), {ρ', ρ}
1	n

Fig. 4. Static semantics - Part 2
Typing rules of λregion
The typing judgment of λregion has the form TE ▶tt e : µ, ϕ. It reads “in type environment TE, expression e has type µ and effect ϕ.” Figure 3 shows the typing rules for the surface terms. Except for the (copy)-rule and the generalization of region variables Q to regions ρ, the rules of Fig. 3 are identical to those of Tofte and Talpin [16]. Figure 4 shows the rules for the remaining computational terms.
Rule (var) is obvious. Rule (alloc-const) types the allocation of an inte- ger. It specifies an effect on the respective region. Contrast this with rule (use-const) (from Fig. 4), which types a pointer to an integer. It does not have an effect anymore. Likewise, rule (alloc-abstr), for allocating a closure, has an effect whereas the corresponding pointer reference in rule (use-abstr) has not. Both rules transfer the effect of the body term to the latent effect of the inferred function type. Analogously, rule (alloc-letrec) types the allo- cation of a recursive region closure whereas rule (use-letrec) only types the pointer to the closure. Both rules specify polymorphic recursion for effect and region variables, but not for types. In the body, e2, the function, f , is type polymorphic, too.
Rule (app) collects the effects of the subexpressions, the latent effect of the function, and the effect variable. Rule (recvar1) types a region application before substituting a region closure for f whereas (recvar2) applies after the

substitution. As the latter expression is a redex which involves both regions,
ρ and ρ', the effect contains both regions.
Rule (letregion) discharges a region variable if it does not occur in the type environment and in the expression’s type. Hence, effects on deallocated regions are masked. Rule (effect) discharges useless effect variables. Rule (copy) declares the effect {ρ, ρ'} of copying an integer from region ρ to ρ'.
Type soundness of λregion
This section provides a syntactic type soundness proof of the small-step transi- tion relation in λregion with respect to the type system of section 4. The proof is structured as follows: first we formulate some useful lemmas. Then, we prove type preservation, also known as subject reduction [17, 7], which states that a well-typed computational term remains well-typed under the small-step tran- sition relation →r. The second result is the progress property, which states that a well-typed closed term is either a value or it can be further reduced. Taken together, these two results imply type soundness.
Auxiliary Lemmas
The first lemma states that syntactic values have no effects.
Lemma 5.1 For all TE, values v, and types µ, if TE ▶tt v : µ, ϕ then ϕ = ∅.
The set of closed expressions is closed under small-step transition.
Lemma 5.2 If e is closed and e →r e', then e' is also closed.
Substitution of a value of the correct type for a variable of the same type preserves the type of the enclosing term.
Lemma 5.3 (First Substitution Lemma) Suppose TE + {x '→ µ} ▶tt e :
µ', ϕ' and TE ▶tt v : µ, ϕ, then TE ▶tt e[v/x]: µ', ϕ'.
Proof. By induction on the derivation of TE + {x '→ µ} ▶tt e : µ', ϕ'.
The only interesting case is the application of (var) to (free occurrences of) x. If TE' = TE + {x '→ µ}, then since TE'(x)= TE + {x '→ µ}(x)= µ, rule (var) yields TE' ▶tt x : µ, ∅. On the other hand, x[v/x] = v and, by assumption, TE ▶tt v : µ, ∅ since ϕ = ∅, by Lemma 5.1.
All other cases are simple appeals to the inductive hypothesis.	✷
Lemma 5.4 If TE ▶tt e : µ, ϕ then, for all substitutions Ss, we have that Ss(TE) ▶tt Ss(e): Ss(µ), Ss(ϕ).
Proof. By induction on the derivation of TE ▶tt e : µ, ϕ. Similar to Lemma 5.3 in [16] and Lemma 4.5 in [17].	✷
Lemma 5.5 If TE + {f '→ (σ, ρ)} ▶tt e : µ, ρ', and σ ≺ σ', then TE + {f '→
(σ', ρ)} ▶tt e : µ, ρ'


Proof. A straightforward induction on the depth of the proof of TE + {f '→ (σ, ρ)} ▶tt e : µ, ρ'. Proven analogously to lemma 5.4 in [16] and lemma 4.6 in [17].	✷
Unfolding a letrec-definition also preserves typing.
Lemma 5.6 (Second Substitution Lemma) Suppose
{Q1 ..., Qn, s, α}∩ (fv (TE) ∪ {ρ})= ∅
{α}∩ ftv (TE)= ∅
σ = ∀ α .σˆ and σˆ = ∀ s .∀ Q1 ... Qn .τ
TE + {f '→ (σ, ρ)} ▶tt e2 : µ, ϕ
TE + {f '→ (σˆ, ρ)} ▶tt ⟨λ x. e1⟩ρ : (τ, ρ), ∅
then TE ▶tt e2[⟨Λ[Q1,..., Qn].λ x. letrec f = γ in e1⟩ρ/f ] : µ, ϕ where γ =
⟨Λ[Q1,..., Qn].λ x. e1⟩ρ.
Proof. By induction on the derivation of TE + {f '→ (σ, ρ)} ▶tt e2 : µ, ϕ. All cases are straightforward applications of the induction hypothesis, except for free occurrences of f in e2.
In this case, assumption (iv) is as follows.
TE + {f '→ (σ, ρ)}▶ f [ρ' ,..., ρ' ] at ρ' : µ, ϕ	(10)
tt	1	n
This judgment must be due to rule (recvar1), that is, there exists Ss = (St, Sr, Se) such that µ = (τ ', ρ'); ϕ = {ρ, ρ'}; (TE + {f '→ (σ, ρ)})(f )= (σ, ρ); τ' ≺ σ via Ss; and Sr = {Q1 '→ ρ' ,..., Qn '→ ρ' }.
1	n
From this, it must be shown using (recvar2) that
TE ▶  ⟨Λ[Q1,..., Qn].λ x.letrec f = γ in e1⟩ρ [ρ' ,..., ρ' ] at ρ' : (τ ', ρ'), {ρ, ρ'}
tt	1	n
That is, there must exist some τ '' such that
TE ▶tt ⟨λ x. letrec f = γ in e1⟩ρ' : (τ '', ρ'), ∅;
{Q1,..., Qn}∩ (frv (TE) ∪ {ρ})= ∅ (this is immediate by assumption (i));
τ' = Sr(τ '') where Sr = {Q1 '→ ρ' ,..., Qn '→ ρ' }.
1	n
A suitable choice for τ '' is S' (τ ) where S' = (St, Ir, Se).	Without lack of
s	s
generality, α-conversion of Q1,..., Qn in γ ensures that Q1,..., Qn do not occur
in the range of Ss, so that Ss = SrS' . Since τ' ≺ σ via Ss, τ '' satisfies the last requirement. It remains to showthat

'	'	'
TE ▶tt ⟨λ x. letrec f = γ in e1⟩ρ' : (Ss(τ ),ρ ), ∅	(11)
To see this, it is first shown that
TE ▶tt ⟨λ x. letrec f = γ in e1⟩ρ : (τ, ρ), ∅	(12)



To this end, suppose that τ = µ1
є'.q'
−−−→ µ2. Then equation (12) follows

from assumption (v), (use-abstr), and from the implication: if, for some ϕ'' ⊆
ϕ',

then
TE + {f '→ (σˆ, ρ)} + {x '→ µ1} ▶tt
e1 : µ2, ϕ''	(13)

''
TE + {x '→ µ1} ▶tt letrec f = γ in e1 : µ2, ϕ	(14)
From assumption (v) it follows trivially that
TE + {x '→ µ1} + {f '→ (σˆ, ρ)} ▶tt ⟨λ x. e1⟩ρ : (τ, ρ), ∅	(15)
Applying Lemma (5.5) to equation (13) for σˆ ≺ σ and observing that
TE + {f '→ (σˆ, ρ)} + {x '→ µ1} = TE + {x '→ µ1} + {f '→ (σˆ, ρ)} because
x /= f yields
''
TE + {x '→ µ1} + {f '→ (σ, ρ)} ▶tt e1 : µ2, ϕ	(16)
Applying rule (use-letrec) to assumption (i), equation (15), and equa- tion (16) yields the claim in equation (14).
By rule (use-abstr), equation (12) is derivable from equation (14).

Applying Lemma 5.4 to equation (12) for S'
yields

S' (TE) ▶ S' (⟨λ x. letrec f = γ in e1⟩ρ): S' (τ, ρ), S' (∅)	(17)
s	tt	s	s	s
The domain of S' = (St, Ir, Se) is a subset of {s, α} since
τ' ≺ σ via (St, Sr, Se). By assumption (i), {s, α} is disjoint from fv (TE)∪{ρ}. Therefore,
S' (TE)= TE;
S' (⟨λ x. letrec f = γ in e1⟩ρ)= ⟨λ x. letrec f = γ in e1⟩ρ due to Ir; and
S' (τ, ρ)= (S' (τ ), ρ).
s	s
Using the rule (use-abstr) once backwards and once forwards replaces ρ by ρ'
and transforms equation (17) into equation (11), which proves the claim.  ✷
Type preservation
The following proposition states that for every well-typed term which has a transition, the reduct has exactly the same type as the redex, but possibly less effect.
Proposition 5.7 (Type Preservation) Suppose TE ▶tt e : µ, ϕ. If e →r e'
then TE ▶tt e' : µ, ϕ' where ϕ' ⊆ ϕ.
Proof. By induction on the definition of →r and the number of subsequent uses of (effect) at the end of e’s type derivation.
If TE ▶tt e : µ, ϕ derives from TE ▶tt e : µ, ϕ ∪ {ϵ} by rule (effect), for some ϵ /∈ fev (TE, µ, ϕ), then induction yields that TE ▶tt e' : µ, ϕ' where

ϕ' ⊆ ϕ ∪ {ϵ}. If ϵ /∈ ϕ' then the claim holds anyway. Otherwise, use (effect)
to get TE ▶tt e' : µ, ϕ' \ {ϵ} where ϕ' \ {ϵ}⊆ ϕ ∪ {ϵ}\ {ϵ} = ϕ, as required.
If the last rule in the proof of TE ▶tt e : µ, ϕ is not (effect) then perform a case analysis. Most cases are straightforward applications of the inductive hypothesis and/or one of the preceding lemmas.
Case c at Q →r ⟨c⟩ę is obvious by rules (alloc-const) and (use-const).
Case λ x. e at Q →r ⟨λ x. e⟩ę is obvious by rules (alloc-abstr) and (use- abstr).
Case letrec f = a at Q in e →r letrec f = ⟨a⟩ę in e is obvious by rules
(alloc-letrec) and (use-letrec).
Case copy [Q1, Q2] ⟨c⟩ę1 →r ⟨c⟩ę2 . By assumption, TE ▶tt copy [Q1, Q2] ⟨c⟩ę1 : µ, ϕ, for some µ and ϕ. Hence, by rules (copy) and (use-const), µ = (int, Q2) and ϕ = {Q1, Q2}. For the reduct, rule (use-const) yields TE ▶tt ⟨c⟩ę2 : (int, Q2), ∅, which verifies the claim.
Case ⟨λ x. e⟩ę @ v →r e[v/x]. The last rule in the typing proof of the redex must be (app), hence (using Lemma 5.1)


TE ▶tt ⟨λ x. e⟩ę : (µ1
є.q
−−−→ µ2, Q), ∅	TE ▶tt v : µ1, ∅



TE ▶tt (⟨λ x. e⟩ę)@ v : µ2,ϕ ∪ {ϵ, Q}

By rule (use-abstr) it must be that TE + {x '→ µ1} ▶tt e : µ2, ϕ' for some ϕ' ⊆ ϕ. By the First Substitution Lemma, it follows that TE ▶tt e[v/x] : µ2, ϕ'. Clearly, ϕ' ⊆ ϕ ∪ {ϵ, Q}, which proves the claim.
Case letregion Q in v →r v[•/Q]. The last rule in the typing proof of the redex must have been (letregion):

TE ▶tt v : µ, ϕ'	Q ∈/ frv (TE, µ)
TE ▶tt letregion Q in v : µ, ϕ' \ {Q}
By Lemma 5.1, ϕ' = ∅, hence ϕ' \ {Q} = ∅. By Lemma 5.4, TE[•/Q] ▶tt
v[•/Q] : µ[•/Q], ϕ'[•/Q]. Since Q ∈/ frv (TE, µ) and ϕ' = ∅, this amounts to
TE ▶tt v[•/Q]: µ, ∅, which verifies the claim.
Case letrec f = γ in e2 →r e2[⟨Λ[Q1,..., Qn].λ x.letrec f = γ in e1⟩ρ/f ] where γ = ⟨Λ[Q1,..., Qn].λ x. e1⟩ρ. The last step in the typing derivation for the redex must apply rule (use-letrec):

{Q1 ..., Qn, s}∩ (fv (TE) ∪ {ρ})= ∅	σˆ = ∀ s .∀ Q1 ... Qn .τ
TE + {f '→ (σˆ, ρ)} ▶tt ⟨λ x. e1⟩ρ : (τ, ρ), ∅

{α}∩ ftv (TE)= ∅	σ = ∀ α .σˆ
TE + {f '→ (σ, ρ)} ▶tt e2 : µ, ϕ



TE ▶tt letrec f = ⟨Λ[Q1,..., Qn].λ x. e1⟩ρ in e2 : µ, ϕ


By the Second Substitution Lemma, this yields
TE ▶tt e2[⟨Λ[Q1,..., Qn].λ x. letrec f = γ in e1⟩ρ/f ]: µ, ϕ as required.
'	'	'	'	'
Case ⟨Λ[Q1,..., Qn].λ x.e⟩ę [ρ1,..., ρn] at Q →r ⟨λ x.e[ρ1/Q1,..., ρn/Qn]⟩ę' .
The last step of the typing derivation for the redex is (recvar2):

TE ▶tt ⟨λ x. e⟩ę' : (τ, Q ), ∅
Sr = {Q1 '→ ρ' ,..., Qn '→ ρ' }	τ' = Sr(τ )	{Q1,..., Qn}∩ frv (TE)= ∅
1	n
TE ▶tt ⟨Λ[Q1,..., Qn].λ x. e⟩ę [ρ' ,..., ρ' ] at Q' : (τ ', Q'), {Q, Q'}
1	n
So, by Lemma 5.4, we have Sr(TE) ▶tt Sr(⟨λ x. e⟩ę' ) : Sr(τ, Q ), ∅, but since
Sr(τ )= τ' and {Q1,..., Qn}∩ frv (TE)= ∅, we have that
'	'	'	'
TE ▶tt ⟨λ x. e[ρ1/Q1,..., ρn/Qn]⟩ę' : (τ ,Q ), ∅.
Case e →r e' implies e @ e0 →r e' @ e0.	The last step in the typing derivation of the left term is the rule (app):


TE ▶tt e : (µ1
є.q
−−−→ µ2, ρ), ϕ1	TE ▶tt e0 : µ1, ϕ2


TE ▶tt e @ e0 : µ2,ϕ ∪ ϕ1 ∪ ϕ2 ∪ {ϵ, ρ}


By induction, TE ▶tt
e' : (µ1
є.q
−−−→ µ2
, ρ), ϕ'
where ϕ'
⊆ ϕ1. By rule (app),



TE ▶
e' : (µ
є.q
, ρ), ϕ'
TE ▶
e : µ ,ϕ 

tt	1
−−−→ µ2	1
tt  0	1	2

TE ▶tt e @ e0 : µ2,ϕ ∪ ϕ'
∪ ϕ2 ∪ {ϵ, ρ}

and ϕ ∪ ϕ' ∪ ϕ2 ∪ {ϵ, ρ}⊆ ϕ ∪ ϕ1 ∪ ϕ2 ∪ {ϵ, ρ}.
Case e →r e' implies v @ e →r v @ e'. Similarly simple appeal to the inductive hypothesis.
Case e →r e' implies copy [Q1, Q2] e →r copy [Q1, Q2] e'. Similarly simple appeal to the inductive hypothesis.
Case e →r e' implies letregion Q in e →r letregion Q in e'. Similarly simple appeal to the inductive hypothesis.	✷

Canonical Forms
A canonical forms lemma determines the form of a value, given its type.


Lemma 5.8 (Canonical Forms)	(i) If TE ▶tt v : (µ1
there are x and e so that v = ⟨λ x. e⟩ρ.
є.q'
−−−→ µ2, ρ),ϕ then

(ii) If TE ▶tt v : (int, ρ),ϕ then there is some constant c such that v = ⟨c⟩ρ.

Progress
The progress property states that a well-typed term is either a syntactic value or can be further reduced, if it is closed and does not affect a dead region.
Proposition 5.9 (Progress) If TE ▶tt e : µ, ϕ and • /∈ ϕ then either
there exists e' such that e →r e' or
e is a value or
e has form S [x], with x ∈ free (e) or
e has from S [f [ρ1,..., ρn] at Q], with f ∈ free (e).
Proof. Easy induction on the structure of e:
Case x: Item iii applies;
Case ⟨c⟩ρ: Item (ii) applies;
Case ⟨λ x. e⟩ρ: Item (ii) applies;
Case c at ρ: By (alloc-const), TE ▶tt c at ρ : (int, ρ), {ρ} and, by assump- tion, ρ /= •. Hence, Item (i) applies with reduction (1);
Case λ x. e at ρ: By (alloc-abstr), TE ▶tt λ x. e at ρ : µ, {ρ} and, by assump- tion, ρ /= •. Hence, Item (i) applies with reduction (2);
Case e1 @ e2: by induction, there are the following cases for e1:
one of Item (i), Item (iii), or Item (iv) applies to e1 with evaluation context
S . Since S @ e2 is an evaluation context, too, the respective case applies to e1 @ e2.
Item (ii) applies to e1. By typability, TE ▶tt e1 @ e2 : µ, ϕ. This must be

due to rule (app), so that TE ▶tt e1
: (µ1
є.q
———→ µ
, ρ), ϕ1, where {ϵ, ρ}∪ 

ϕ2 ∪ ϕ1 ⊆ ϕ. By Lemma 5.8, e1 has the form ⟨λ x. e⟩ρ where ρ /= •, by assumption. Again, by induction, there are the following cases for e2:
one of Item (i), Item (iii), or Item (iv) applies to e2 with evaluation context S . Since e1 @ S is an evaluation context, too, the respective case applies to e1 @ e2.
Item (ii) applies to e2, so that e1 @ e2 is a beta-redex. Hence, Item (i) applies with reduction (6) since ρ /= •.
Case letrec f = a at ρ in e: by typability and ρ /= •, Item (i) applies with reduction (3);
Case letrec f = ⟨a⟩ρ in e: Item (i) applies with reduction (7);
Case copy [ρ, ρ'] e: by induction, there are the following cases for e:
one of Item (i), Item (iii), or Item (iv) applies to e with evaluation context
S . Since copy [ρ1, ρ2] S is an evaluation context, too, the respective case applies to copy [ρ1, ρ2] e.
Item (ii) applies to e. By typability, TE ▶tt copy [ρ, ρ'] e : (int, ρ'), ϕ. By rule (copy), it must be that TE ▶tt e : (int, ρ), ϕ' where ϕ = ϕ' ∪ {ρ, ρ'}. By Lemma 5.8, e = ⟨c⟩ρ1 . Furthermore, by assumption and typability,

neither ρ nor ρ' can be •. Therefore, Item (i) applies with reduction (5).
Case letregion Q in e: by induction, there are the following cases for e:
one of Item (i), Item (iii), or Item (iv) applies to e with evaluation context
S . Since letregion Q in S is also an evaluation context, the respective case applies to letregion Q in e.
Item (ii) applies to e. Therefore, Item (i) applies with reduction (4).
Case f [ρ1,..., ρn] at ρ': Item (iv) applies.
Case ⟨Λ[Q1,..., Qn].λ x. e⟩ρ [ρ1,..., ρn] at ρ': by typability and assumption, neither ρ nor ρ' is •; hence, Item (i) applies with reduction (8).
✷

Soundness
Finally, the type soundness theorem says that a well-typed closed term either gives rise to an infinite reduction sequence, or it eventually reduces to a value of the same type.
Theorem 5.10 (Type Soundness) Suppose e is a closed surface term and
[] ▶tt e : (τ, Q),ϕ with • ∈/ ϕ. Then, either there exists some value v with
e →r v and [] ▶tt v : (τ, Q), ∅ or, for each e' where e →r e', there exists e'' with
e' →r e''.
Proof. Immediate consequence of propositions 5.7 and 5.9 and lemmas 5.1 and 5.2	✷

Discussion
The proof as presented here is a slight variation of the original strategy of Wright and Felleisen [17]. Instead of proving that it is always possible to continue evaluation of a typable closed term unless the term is already a value (the progress property), they prove the contraposition. This requires the introduction of stuck expressions: an expression e is stuck if e is not a value and there is no e' for which e →r e'. Then one approximates the set of expressions that become stuck by the set of faulty expressions, for which the following can be shown: if a closed expression cannot be reduced to a faulty expression, evaluation either does not terminate or returns a value. If faulty expressions coincide with untypable expressions, type soundness follows by type preservation.
We believe it is more natural to showprogress as in proposition 5.9, instead of using the unintuitive and superfluous notion of stuck states.
Example
It is instructive to look at an example of small-step evaluation and see how it preserves typing. Assume the usual semantics for let x = e1 in e2 and

suppose an existing Q1 :

(letregion Q2 in
let f1 = λ x. x at Q2 in
let f2 = λf. (4 at Q1) at Q1 in
λy. (f2 @ f1) at Q1	) @ (2 at Q1) →r
letregion Q2 in λy. (⟨λf. 4 at Q1⟩ę1 @ ⟨λ x. x⟩ę2 ) at Q1 @ (2 at Q1) →r
⟨λy. (⟨λf. 4 at Q1⟩ę1 @ ⟨λ x. x⟩•)⟩ę1 @ ⟨2⟩ę1 →r
⟨λf. 4 at Q1⟩ę1 @ ⟨λ x. x⟩• →r
⟨4⟩ę1

All intermediate terms are typable with the rules of Figures 3 and 4. The lambda abstraction λ x. x at ρ2 is first allocated in ρ2, which is safely deallo- cated after evaluation of λy. ... at Q1, since Q2 does neither occur free in the type of this lambda, nor in its environment. The dangling pointer ⟨λ x. x⟩• remains visible, but it is never dereferenced and disappears eventually.


Conclusion and further work
We have presented a small-step operational semantics for the region calculus and given a syntactic type soundness proof. Since it is solely based on rewriting and induction, the proof is considerably easier than the original soundness proof of Tofte and Talpin.
We were able to elide an explicit store from our presentation of the seman- tics because the region calculus of Tofte and Talpin never updates the contents of the store. Including references in our framework should be possible at the price of including an explicit store component in the transition relation.
The original motivation for this work is the desire to use the region cal- culus as a foundation for the binding-time analysis phase of oﬄine partial evaluation [5, 12, 11]. Region inference seems to provide exactly the right kind of flowanalysis for binding-time analysis in programming languages with ML-style polymorphism.
We are currently working on a binding-time annotated version of the region calculus. The corresponding type soundness result amounts to the correctness of the binding-time analysis. It remains to show the other properties (for instance semantics preservation), in analogy to the results of Hatcliff and Danvy [10] for a monomorphic version of the computational metalanguage.

References
Anindya Banerjee, Nevin Heintze, and Jon G. Riecke. Region analysis and the polymorphic lambda calculus. In Proc. of the 14th Annual IEEE symposium on Logic in Computer Science, Trento, Italy, July 1999. IEEE Computer Society Press.
Lars Birkedal and Mads Tofte. A constraint-based region inference algorithm.
Theoretical Computer Science, to appear, 1999.
Lars Birkedal, Mads Tofte, and Magnus Vejlstrup. From region inference to von Neumann machines via region representation inference. In Proc. 23rd Annual ACM Symposium on Principles of Programming Languages, pages 171–183, St. Petersburg, Fla., January 1996. ACM Press.
Cristiano Calcagno. Stratified operational semantics for safety and correctness of the region calculus. Personal communication, July 2000. Draft obtainable from ftp://ftp.disi.unige.it/person/CalcagnoC/regions.ps.
Charles Consel and Olivier Danvy. Tutorial notes on partial evaluation. In Proc. 20th Annual ACM Symposium on Principles of Programming Languages, pages 493–501, Charleston, South Carolina, January 1993. ACM Press.
Karl Crary, David Walker, and Greg Morrisett. Typed memory management in a calculus of capabilities. In Alex Aiken, editor, Proc. 26th Annual ACM Symposium on Principles of Programming Languages, pages 262–275, San Antonio, Texas, USA, January 1999. ACM Press.
H. B. Curry, R. Feys, and W. Craig. Combinatory Logic, volume I. North Holland, 1958.
Luis Damas and Robin Milner. Principal type-schemes for functional programs. In Proc. 9th Annual ACM Symposium on Principles of Programming Languages, pages 207–212. ACM, 1982.
Matthias Felleisen and Robert Hieb. The revised report on the syntactic theories of sequential control and state. Theoretical Computer Science, 10(2):235–271, 1992.
John Hatcliff and Olivier Danvy. A computational formalization for partial evaluation. Mathematical Structures in Computer Science, 7(5):507–542, 1997.
Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. Partial Evaluation and Automatic Program Generation. Prentice-Hall, 1993.
Torben Æ. Mogensen and Peter Sestoft. Partial evaluation. In Allen Kent and James G. Williams, editors, Encyclopedia of Computer Science and Technology, volume 37, pages 247–279. Marcel Dekker, 270 Madison Avenue, New York, New York 10016, 1997.
Mads Tofte and Lars Birkedal. Unification and polymorphism in region inference. In Milner Festschrift, 1996.


Mads Tofte and Lars Birkedal. A region inference algorithm. ACM Transactions on Programming Languages and Systems, 20(5):724–767, 1998.
Mads Tofte and Jean-Pierre Talpin. Implementation of the typed call-by-value λ-calculus using a stack of regions. In Proc. 21st Annual ACM Symposium on Principles of Programming Languages, pages 188–201, Portland, OG, January 1994. ACM Press.
Mads Tofte and Jean-Pierre Talpin.	Region-based memory management.
Information and Computation, 132(2):109–176, 1997.
Andrew K. Wright and Matthias Felleisen. A syntactic approach to type soundness. Information and Computation, 115(1):38–94, 15 November 1994.
S. Dal Zilio and Andrew Gordon. Region analysis and a pi-calculus with groups. In Proceedings of MFCS ’00, Lecture Notes in Computer Science, 2000.
