	Electronic Notes in Theoretical Computer Science 98 (2004) 21–33	
www.elsevier.com/locate/entcs




A Symbolic Procedure for Control Reachability in the Asynchronous π-calculus
Extended Abstract

Giorgio Delzanno1
Dipartimento di Informatica e Scienze dell’Informazione Universit`a di Genova, Via Dodecaneso 35 - 16146 Genova, Italy

Abstract
We study the relationship between the asynchronous π-calculus and the specification language MSRNC combining multiset rewriting over first-order atomic formulas (MSR) and name constraints (NC) proposed in [10]. We exploit this connection to define a sound and fully automatic procedure for attacking control reachability for infinite-state specifications given in asynchronous π-calculus, i.e., for specifications of mobile processes with unbounded control, name generation, and name mobility.
Keywords: Mobile concurrent systems, Control reachability, Constraints, Symbolic state exploration.


Introduction
In [13] German and Sistla established a connection between Petri Nets and CCS by means of which automated verification methods like the covering graph construction could be transferred to CCS-like models (see e.g. [5]). In this setting individual processes are viewed as “communicating finite state machines” (with one place buffer), whereas the entire system is composed of an arbitrary (but finite) number of processes. The connection between CCS and Petri Nets has been extended in several different ways. For instance, in

1 Email: giorgio@disi.unige.it


1571-0661 © 2004 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.10.004

[12] communication mechanisms like broadcast have been modelled via transfer arcs. Control reachability is still decidable for the extended Petri Nets models proposed in [12]. Formalisms used to specify mobile processes, often called nominal calculi [14], represent another important extension of value passing CCS. In this setting the use of channel names as values provides for a dynamic reconfiguration of the network (i.e. of the communication links between pro- cesses). A well-known example of nominal calculus is the π-calculus [16]. In the π-calculus process mobility is achieved by using names as communica- tion ports. Automated verification of specifications in the π-calculus becomes particularly challenging due to the presence of fresh name generation, name mobility, and unbounded control, i.e., their state-space is infinite in several dimensions. The application of automatic verification techniques developed for Petri Nets to specifications given in the π-calculus has been explored in different works in the literature. For instance, in [4] control reachability has been shown to be decidable for different fragments of asynchronous π-calculus (πa) via a reduction to Petri Nets with transfer arcs. The use of Petri Nets indicates a restriction to models with one infinite dimension (e.g. the number of processes or the number of names). Similar restrictions are taken in other verification methods for mobile systems like, e.g., [17,18,19], where processes are required to be ﬁnitary (there is a bound on the number of parallel com- ponents generated during execution).
The research direction that we are currently investigating concerns the appli- cability of inﬁnite-state veriﬁcation methods developed for concurrent systems with several sources of infiniteness [10] to mobile processes. Specifically, in this paper we will investigate the connection between specifications of mobile pro- cesses given in the asynchronous π-calculus and MSRNC [10,11], a specification language based on multiset rewriting over ﬁrst order atomic formulas (MSR) and name constraints (NC). MSRNC is a conservative extension of Petri Nets in which tokens are represented via atomic formulas and constraints define the relationship over data attached to the tokens. In order to establish a formal connection, we embed the formulation of asynchronous π-calculus proposed in [4] based on the notion of normalised equations into MSRNC. The pro- posed encoding preserves (control) reachability. Furthermore, it allows us to transfer the verification procedures for attacking control reachability studied in the context of MSRNC [10] to mobile processes. Specifically, the verification method is based on a symbolic representation of upward closed sets of configu- rations of unbound πa specifications. This data structure can be used then to attack the control reachability problem using symbolic backward reachability. In fact, the computation of the pre-image of a πa specification can be made effective by using the encoding and by specializing the pre-image operator de-

fined for MSRNC specifications.
The resulting method gives us a fully automatic and sound procedure for the verification of safety properties (often reducible to control reachability) for mobile processes. Termination cannot be guaranteed for generic πa specifica- tion. However, techniques like abstract interpretation or heuristics inspired to the Structural Theory of Petri Nets can be used here to enforce termination, to accelerate the speed of the analysis, or to simply compute approximated results. Furthermore, the study of fragments of πa related to the monadic fragment of MSRNC (for which backward reachability terminates) could rep- resent a promising research line for finding new decidability results for mobile processes.

Asynchronous π-calculus (πa)
The asynchronous π-calculus (πa) is a subcalculus of the π-calculus without choice and match and in which message emission is non-blocking [15,6]. The set of πa processes is defined as follows
P	::=	0 | xy  | x(y).P  | P1|P2 | (νx)P  | !P

The term 0 denotes a null process. The output term xy denotes an asyn- chronous message with target x and content y. With the input prefix x(y).P a process receives an arbitrary name z at channel x and then behaves like P [z '→y]. The process P [z '→y] is the result of substituting all free occur- rences of y in P by z. The argument y of x(y) binds all free occurrences of y in
P . The composition P |Q consists of P and Q running in parallel. The restric- tion (νx)P behaves like P except that it cannot exchange messages targeted to x with the environment; the argument x of (νx) binds all free occurrences of x in P . The replication !P provides an arbitrary number of copies of process P (!P ≡ P | !P ).
In [4], Amadio and Meyssonier proposed an equivalent reformulation based on the notion of normalised parametric equations in which repetition is replaced by recursion. In this paper we will take it as reference model. Let us use →a to denote a tuple a1,... , an of names, and [→a '→→b] to indicate a substitution mapping ai to bi for i : 1,... , n. Furthermore, let the term (ν→v)P denote the term (νv1) ... (νvn)P . Following [4], a normalised parametric equation is defined as follows
A(→x)= a(→u) . (ν→v)(a1→y1 | ... | an→yn | A1(w→ 1) ... | Am(w→ m))

`in˛p¸uxt
`g˛e¸n.x `
ou˛tp¸ut
x	`	contin˛u¸ations	x

where A, A1,... denote process identifier; the (bound) names in →x, →u, →v are all distinct each other; ai, →yi and w→ j are names taken from →x, →u, →v for i : 1,...,n and j : 1,..., m. We will use F n(P ) to denote the set of free names in the body of an equation A(→x)= P . A process is defined via a set E of normalised parametric equations, and by an initial conﬁguration. A conﬁguration is for- mally defined as a normalised process of the shape
(ν→v)(a1→y1 | ... | an→yn | A1(w→ 1) ... | Am(w→ m))
`	mes˛s¸ages	x	`	proc˛e¸sses	x
Two configurations P and Q are equivalent, written P ≡ Q, if P is syn- tactically equal to Q up to renaming of bound names, and associativity and commutativity of parallel composition.
The operational semantics of a process is defined as the reflexive-transitive closure of the reduction relation · ⇒πa · defined over configurations as follows. Let P be the configuration (νw→ )(A(→u) | c(→v) | Q) where Q is a multiset of messages and continuations, and let D ∈E be the equation A(→x)= a(→y).(ν→z)R such that the set of names →x, →y, →z and w→ and F n(P ) are all distinct each other. Given σ = [→x '→→u, →y '→→v] and its natural extension σˆ to expressions, if σˆ(a)= 
c, then P reduces to P ', written P ⇒π P ', where P ' = (νw→ , →z) (σˆ(R) | Q).
The control reachability problem [4] is defined as follows. Given a set of equations E containing the process identifier A, and an initial configuration

∗
P , does P ⇒πa
Q hold with Q = ν→a.(A(→b) | Q') for some →b and Q'?

Example 1.1 Let us consider the following equations:
Init(a)= (νp)(ap | W ait(p)),
W ait(p)= p(x).EndI(p, x),
Resp(a)= a(y).(νok)(yok | EndR(y, ok)).
Given P = (νc)(Init(c) | Resp(c)), a possible reduction is as follows
P = (νc, p)(cp | W ait(p) | Resp(c))
⇒πa (νc, ok, p)(W ait(p) | p ok | EndR(p, ok))
⇒πa (νc, ok, p)(EndI(p, ok) | EndR(p, ok))
This reduction describes a run of the protocol in which Init and Resp exchange the private channel name p along which Resp sends an acknowledge to Init. If we add the equation
Start = (νc)(Init(c) | Resp(c) | Start)

then Start will generate an arbitrary number of sessions of our protocol.

The Speciﬁcation Language MSRNC
Let V be a set of variables. We call name constraint a conjunction ϕ1,... , ϕn of atomic formulas of the shape true, x > y, x = y, x /= y, or x ≥ y with x, y ∈ V. The set of solutions Sol of a constraint ϕ consists of all evaluations from V to Z (integer numbers) that make ϕ true. A constraint ϕ is satisﬁable whenever Sol(ϕ) /= ∅.
Let P be a set of predicate symbols. An atomic formula p(x1,... , xn) is such that p ∈ P, and x1,... , xn ∈ V. A multiset of atomic formulas is indicated as A1,... , Ak, where the symbol “,” is an associative-commutative term constructor not occurring inside atomic formulas. We use “,” instead of the symbol “|” used in [10] to avoid confusion with parallel composition in πa. In the rest of the paper will use M, N , ... to denote multisets of atomic formulas, ϵ to denote the empty multiset, ⊕ to denote multiset union and g to denote multiset difference.
A conﬁguration is a multiset of ground atomic formulas, i.e, atomic formu- las were all variables are instantiated with integer values. An MSRNC rule has the form
A1,... , An −→ B1,... , Bm : ϕ
where M = A1, ... , An and M' = B1, ... , Bm are two (possibly empty) multisets of atomic formulas built on predicates in P, and ϕ is a constraint such that V ar(ϕ) ⊆ V ar(M) ∪ V ar(M'), where V ar(F ) is the set of free variables in the formula F . Equality constraints between variables can be implicitly defined by multiple occurrences of the same variable in a rule. The ground instances of an MSRNC rule are defined as
Inst(M −→ M' : ϕ)= {σ(M) −→ σ(M') | σ ∈ Sol(ϕ)}
where σ is extended in the natural way to multisets. The instances of a set of rules R = {R1,... , Rn} is defined as Inst(R)= Inst(R1) ∪ ... ∪ Inst(Rn). An MSRNC	speciﬁcation S is a tuple ⟨P, I, R⟩, where P is a set of predicate
symbols, I is a set of (initial) configurations, and R is a finite set of rules over
P. The operational semantics of S is defined via the rewriting relation ⇒R
defined over configurations (i.e. ground multisets) as follows.
Given two configurations M1 and M2, M1 ⇒R M2 if and only if there exists a multiset of ground atomic formulas Q s.t. M1 = N1 ⊕ Q, M2 = N2 ⊕ Q, and N1 −→ N2 is in Inst(R). A configuration M is reachable if there exists
∗	∗
M0 ∈I such that M0 ⇒R M, where ⇒R is the transitive closure of ⇒R.

From πa to MSRNC
In this section we define an encoding of infinite-state asynchronous π-calculus specifications into MSRNC. In this preliminary work we will restrict ourselves to closed πa specifications and configurations. Specifically, we will consider normalised equations of the form A(→x) = a(→u).(ν→v)R such that F n(R) ⊆
{→x, →u, →v}, and configurations (ν→v).Q such that F n(Q) ⊆ {→v}, i.e., we assume that all names with scope over different equations already occur in the quanti- fier associated to the initial configuration. Closed specifications and configura- tions present all the features of πa we are interested in (fresh name generation, unbound parallelism, name and process mobility).
The encoding of closed specifications is defined as follows. Names are encoded as integer values. Relations over names are symbolically represented as constraints. We first encode an input action a→x and an output action a(→x) as the atomic formula m(a, →x), where a, x1,... , xn are free variables. Input messages will occur in the left-hand side of an MSRNC rule encoding a process definition, whereas output messages will occur in its right-hand side. Then, we encode a process identiﬁer A using a predicate symbol pA taking as arguments as many variables as the parameters in its defining equation. Finally, we use an atomic formula new(f ) to keep track of fresh values (i.e. to separate used and unused names). We will explain its meaning in few lines.
Let us consider the initial configuration P defined as (ν→v)(a1→y1 | ... | an→yn | A1(w→ 1) ... | Am(w→ m))
The encoding of P is defined via the MSRNC rule P • defined as

init, new(f ) −→
m(a1, →y1),... , m(an, →yn), pA (w→ 1),... , pA (w→ m), new(f ') :
f ' > v1, v1 > v2,... , vr−1 > vr, vr > f.

The constraint over f, f ', →v ensures that the names in →v are distinct each other, and that the global memory new(f ) contains a name strictly greater than all used names.
Let us consider now a normalised parametric equation D defined as

A(→x)= a(→u).(ν→v)(a1→y1 | ... | an→yn | A1(w→ 1) | ... | Am(w→ m))

The encoding of D is defined via the MSRNC rule D• defined as
pA(→x), m(a, →u), new(f ) −→
m(a1, →y1),... , m(an, →yn), pA (w→ 1),... pA (w→ m), new(f ') :
f ' > v1, v1 > v2,..., vr−1 > vr, vr > f 
The constraint on →v, f, f ' ensures the freshness of the names in →v. Note that, if D has no generation of fresh values (i.e. r = 0), then we can simplify the rule by removing new(f ) and new(f ') from the left- and right-hand side, respectively.
Example 2.1 The MSRNC encoding of the equations of Example 1.1 is de- fined as follows (for brevity, we write pInit, ... as init, ...) 
init, new(f ) → init(c), resp(c), new(f ') : f ' > c, c > f.
start, new(f ) → start, init(c), resp(c), new(f ') : f ' > c, c > f.
init(a), new(f ) → m(a, p), wait(p), new(f '): f ' > p, p > f. wait(p), m(p, x) → endI(p, x) : true.
resp(a), m(a, y), new(f ) → m(y, ok), endR(y, ok), new(f ') : f ' > ok, ok > f.
Now, let P be the πa configuration
(ν→v)(a1→y1 | ... | an→yn | A1(w→ 1) | ... | Am(w→ m))
Let η be an injective mapping from →v to Z and let η(→v) denote η(v1),... , η(vn).
We define P •(η, N) as the MSRNC configuration
m(η(a1), η(→y1)),... , m(η(an), η(→yn)), pA1 (η(w→ 1)),... , pAm (η(w→ m)), new(N ) where N is an integer strictly greater than η(v1),... , η(vr). Let η : →v ~ Z,
η' : v→' ~ Z, and {→v} ⊆ {v→'}, then we define η ≤ η' if η(→v) = η'(→v). The
adequacy of the encoding is established via the following propositions.
Proposition 2.2 Let E be a set of closed normalised equations, and Pi be a closed conﬁguration for i : 1,... ,k such that P1 ⇒πa ... ⇒πa Pk. Then, there exists η1 ≤ ... ≤ ηk, and N1 ≤ ... ≤ Nk such that P1 (η1, N1) ⇒E• ... ⇒E• P •(ηk, Nk).
Proof. The proof is by induction on the length k of the derivation, the in- teresting case being the inductive step in which k ≥ 1. Suppose that P1 ⇒πa

... ⇒πa Pk and that there exist η1 ≤ η2 ... ≤ ηk, and N1 ≤ N2 ... ≤ Nk such
•	•
that P1 (η1, N1) ⇒E• ... ⇒E• Pk (ηk, Nk). Let Pk be the configuration
(νw→ ) (c→z | A(→b) | Q) Suppose there exists a normalised equation
A(→x)= a(→u).(ν→v)R
and a substitution σ = [→x '→→b, →u '→→z] such that σˆ(a)= c. Then, Pk ⇒πa Pk+1
where Pk+1 is the configuration
(νw→ , →u)(σ(R) | Q)
By definition of the encoding, P •(ηk, Nk) is the MSRNC configuration
m(η (c),η (→z)),p (η (→b)), new(N ), Q'
k	k	A  k	k
where ηk(c) < Nk, and d < Nk for any d ∈ {ηk(→z), ηk(→b)}, and Q' is the encoding of the remaining part of the configuration Q. Furthermore, D• is the rule

p (→x), m(a, →u), new(f ) −→ R', new(f '): f ' > v ,... ,v 
> f.

A	1	r
where R' is the multiset corresponding to the encoding of the body of the equation. Let γ be a solution for f ' > v1,... , vr > f such that γ(a)= ηk(c), γ(→x) = ηk(→b), and γ(→u) = ηk(→z), and γ(f ) = Nk. Furthermore, let ηk+1 be defined in such a way that ηk ≤ ηk+1 and ηk+1(vi)= γ(vi) for i : 1,... ,r and let Nk+1 = γ(f '). Then,
p (η (→b)), m(ηˆ (c),η (→z)), new(N ) −→ γ(R'), new(N	) ∈ Inst(D•).
A  k	k	k	k	k+1
where ηˆk, γˆ represent the natural extensions of ηk and γ to (multiset of) terms.
Furthermore, P •  (ηk+1, Nk+1) is the MSRNC configuration
'
new(Nk+1), ηˆk+1(Q ), ηˆk+1(R)
•	•
By definition of ⇒E• , it follows then that Pk (ηk, Nk) ⇒E• Pk+1(ηk+1, Nk+1). 
Proposition 2.3 Let E be a set of closed normalised equations and E• its MSRNC encoding, P1 an initial closed conﬁguration, and M1 = P •(η1, N1) for some η1 and N1. If M1 ⇒E• ... ⇒E• Mk, then there exists P2,... , Pk, η2 ≤ ... ≤ ηk, and N2 ≤ N3 ≤ ... ≤ Nk such that η1 ≤ η2, N1 ≤ N2,

P1 ⇒πa
... ⇒πa
Pk, and Mi = P •(ηi, Ni) for i : 2,... , k.

Proof. The proof is by induction on the length k of the derivation and follows a schema similar to the proof of the previous proposition.	 

A General Procedure for Control Reachability
Control reachability is undecidable for generic specifications in asynchronous π-calculus, while its decidable for restricted fragments that can be embedded into Petri Nets (with transfer) [4]. However, the encoding described in the previous sections allows us to tackle this problem in its more general form via the symbolic model checking procedure we defined for MSRNC in [10]. For studying the control reachability problem for specifications in asynchronous π-calculus we are interested in finitely representing configurations with an ar- bitrary number of names and processes. We will achieve this goal by resorting to the MSRNC encoding of π-calculus configurations. Specifically, we intro- duce a symbolic representation of upward closed sets of configurations, called constrained conﬁguration. A πa constrained conﬁguration is a formula
m(a1, →y1),... , m(an, →yn), pA1 (w→ 1),... , pAm (w→ m), new(f ) : ϕ	(1) defined over the set of variables V = {f, a1,... , an, →y1,... , →yn, w→ 1,... , w→ m}
such that ϕ is an NC constraints over V , and ϕ, f > x is satisfiable for any x ∈ V x /= f (in every reachable configuration new(f ) separates used from unused names). The denotation of a set S of πa constrained configurations is the upward closure of the ground instances of its elements, namely
[[S]] = {N | M “ N , M∈ Inst(M), M ∈ S}
where “ is multiset inclusion, and the operator Inst is defined as
Inst(M : ϕ)= {σ(M) | σ ∈ Sol(ϕ)}.
Thus, a πa constrained configuration like (1) represents the set of πa-calculus configurations of the shape
(ν→v)(ξ(a1)ξ(→y1) | ... | ξ(an)ξ(→yn) | A1(ξ(w→ 1)) | ... | Am(ξ(w→ m)) | Q)
where ξ is obtained by composing a solution σ for ϕ with an injective (possibly not surjective) mapping from Z to the set of names →v, and Q is any pool of messages and processes defined over a set of names containing →v.
This symbolic representation allows us to reason on inﬁnite sets of config- urations, thus forgetting about the actual number or processes/messages of a given run. Furthermore, the use of first order terms allows us to symbolically

PreR(S)= { A ⊕ N ⊕ {new(x)} : ξ | cond (1-7) listed below holds }
A⊕ {new(x)} −→ B ⊕ {new(x′)} : ψ ∈ R,
M⊕ {new(y)} : ϕ ∈ S,
B′ “ B, M′ “ M, N = Mg M′,
σ = mgu(M′, B′),
γ =  w∈V ar(A ⊕N ) x > w,
ξ = ∃x′, y, →z. (σ ∧ ϕ ∧ ψ ∧ γ) is satisfiable
→z = V ar(σ ∧ ϕ ∧ ψ) \ (V ar(A ⊕ N ) ∪ {x}).

Fig. 1. Symbolic Predecessor Operator for Logical Encoding of πa
represent an infinite number of different instances of the same collection of processes/messages. Constraints define the relationship between the data of different processes/messages.

Symbolic State Exploration for πa
We can now define a symbolic backward reachability procedure that computes all predecessor states of a given set of πa constrained configurations with re- spect to E•. The procedure is based on a breadth-first visit of the infinite state space of the MSRNC specification resulting from the encoding presented in the previous sections. The search is defined on the basis of a symbolic predecessor operator and on an entailment relation (over constrained configurations) both formally defined in [10].
To briefly explain the idea underlying the procedure given in [10], in the rest of this section we will present a specialization of the symbolic predecessor operator to the class of MSRNC specification resulting from the encoding of πa processes.
Let us first recall some definitions. Given two (multisets of) atomic formu- las with distinct free variables t and t', a uniﬁer for t and t' is a substitution σ such that σ(t) = σ(t'). The most general uniﬁer mgu(t, t') is the idempo- tent substitution σ such that any other unifier γ can be obtained from σ as γ = σ ◦ η for some substitution η; the most general unifier always exists and it is unique. In our settings unification might give rise to new bindings for in- teger variables. An mgu σ can also be viewed (and used) as an NC constraint of the shape of a conjunction of equalities x = y for some variables x, y.
Let S be a set of πa constrained configurations with distinct variables each other. The symbolic predecessor operator for an encoding in MSRNC R = E• of a specification in the asynchronous π-calculus E• is defined in Fig. 1. In the definition of Fig. 1 we combine uniﬁcation (via the calculation of the most

general unifier σ) and constraint solving (via satisfiability test and variable elimination); σ is needed to remember constraints on integer variables intro- duced via term unification. Condition 3 — 4 in Fig. 1 ensures the existence of a common pool of messages and processes shared between the right-hand side of a rule and a πa constrained configurations in S. Condition 5 in Fig. 1 allows us to prune all configurations that violate the freshness of generated names (this is specific to the πa encoding). Condition 6 ensures that the se- lected common multisets agree on the data part (i.e. the conjunction of their constraints is satisfiable). Existential quantification is used to project away all variables (Cond. (7)) not needed in the symbolic pre-image. The symbolic operator PreR returns a set of πa constrained conﬁgurations such that
[[PreR(S)]] = PreR([[S]])
for any set of πa constrained configurations S. This result follows from the result proved in [11] for the symbolic predecessor operator associated to an MSRNC specification. The specialized operator of Fig. 1 is presented here only for giving an intuition on how the general search technique for MSRNC. works.
The symbolic model checking procedure resulting from iterating the appli- cation of PreR can be used then to attack control reachability for unrestricted πa specifications. Let P be the initial configuration and A be the process iden- tifier we would like to reach. Then, we can run the symbolic backward search starting from the symbolic configuration A(→x), new(f ) : ϕ. If the search terminates we have to check then if init belongs to the resulting fixpoint. Clearly, in the MSRNC we can use search procedure to check generalization of this problems in which the target set of configurations is defined via πa con- strained configurations like A1(→xk),... , Ak(→xk), new(f ) : ϕ and ϕ expresses the relation over the names of the different processes.
Example 3.1 As an example, suppose we want to check that in Example 1.1, the initial configuration start | new(f ) always generates sessions that do not interfere with each other, i.e., we never reach configurations like
(ν c, d, d')(EndI(c, d) | EndR(c, d') | .. .)
where d' /= d, i.e., the processes involved in a session always exchange both names. To check this property we can apply the symbolic backward analysis described above starting from the πa configuration

endI(x, y), endR(x, z), new(f ) : z /= y, f > x, f > y, f > z

Using our CLP-based implementation, this computation terminates in 6s, af- ter a 4 steps, computing 22 πa constrained configurations. The resulting fix- point does not contain the configuration start, new(f ): true. This proves our original specification correct for an arbitrary number of Init-Resp sessions.

Related and Future Work
To our knowledge the present paper is the first attemp of establishing a connection between the infinite-state verification techniques based on con- straints [1,3,2,10,11] and calculi for expressing mobility of processes as the asynchronous πa calculus. Our verification method generalizes the ideas pro- posed for Time Petri Nets in [1,3] to more general classes of concurrent sys- tems that can be specified via multiset rewriting and constraints. In previous work (see e.g. the technical report [11]) we applied our framework to mutual- exclusion and data consistency protocols (e.g. cache coherence). Multiset rewriting over first order atomic formulas has been proposed for specifying security protocols by Cervesato et al. in [8].
As future work we plan to extend the encoding to specifications in full π calculus, and to study the possible impact of the presented relationship for finding new decidable verification problems for πa and π specifications.

References
P. A. Abdulla and B. Jonsson. Verifying Networks of Timed Processes. TACAS’98, p. 298–312, 1998.
P. A. Abdulla and B. Jonsson. Channel Representations in Protocol Verification. CONCUR ’01, p. 1–15, 2001.
P. A. Abdulla and A. Nyl´en. Better is Better than Well: On Efficient Verification of Infinite- State Systems. LICS ’00, p. 132–140, 2000.
R. Amadio and C. Meyssonier. On the Decidability of the Control Reachability Problem in the Asynchronous π-calculus. To appear in Nordic Journal of Computing.
T. Ball, S. Chaki, and S. K. Rajamani. Parameterized Verification of Multithreaded Software Libraries. TACAS ’01, p. 158-173, 2001.
G. Boudol. Asynchrony and the π-calculus. Rapport de recherche 1702, INRIA. Sophia- Antipolis, 1992.
A. Bouajjani, B. Jonsson, M. Nilsson, and T. Touili. Regular Model Checking. CAV’00, p. 403–418, 2000.
I. Cervesato, N.A. Durgin, P.D. Lincoln, J.C. Mitchell, and A. Scedrov. A Meta-notation for Protocol Analysis. In Proc. CSFW’99, p. 55–69, 1999.
S. Chaki, S. K. Rajamani, and J. Rehof. Types as models: model checking message-passing programs. POPL’02, p. 45-57, 2002.


G. Delzanno. An Assertional Language for Systems Parametric in Several Dimensions. VEPAS’01, ENTCS volume 50, issue 4, 2001.
G. Delzanno.  On the Automated Verification of Parameterized Concurrent Systems with Unbounded Local Data. TR-DISI, Universit`a di Genova, July 2002. Available at http://www.disi.unige.it/person/DelzannoG/MSR.
J. Esparza, A. Finkel, and R. Mayr. On the Verification of Broadcast Protocols. LICS ’99, p. 352-359, 1999.
S. M. German and A. P. Sistla. Reasoning about Systems with Many Processes. Journal of the ACM, 39(3):675–735, 1992.
A. D. Gordon. Notes on Nominal Calculi for Security and Mobility. FOSAD’00, p. 262-330, 2000.
K. Honda, M. Tokoro. An Object Calculus for Asynchronous Communication. ECOOP 1991: 133-147
R. Milner, J. Parrow, and D. Walker. A Calculus of Mobile Processes. Information and Computation, 100:1–77, 1992.
U. Montanari, and M. Pistore. Checking bisimilarity for finitary π-calculus. CONCUR ’95, p. 42-56, 1995.
P. Yang, C.R. Ramakrishnan, S.A. Smolka. A Logical Encoding of the pi-Calculus: Model Checking Mobile Processes Using Tabled Resolution. VMCAI ’03, p. 116-131, 2003.
B. Victor, F. Moller The Mobility Workbench: A Tool for the Pi-Calculus. CAV ’94, p. 428-440, 1994.
