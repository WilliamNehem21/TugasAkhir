	Electronic Notes in Theoretical Computer Science 210 (2008) 139–152	
www.elsevier.com/locate/entcs
Quantum Arrows in Haskell
Juliana Kaizer Vizzotto1, Antoˆnio Carlos da Rocha Costa2
Federal University of Rio Grande do Sul, Brazil Catholic University of Pelotas, Brazil
and Amr Sabry3
Indiana University, USA

Abstract
We argue that a realistic model for quantum computations should be general with respect to measurements, and complete with respect to the information flow between the quantum and classical worlds. We discuss two alternative models for general and complete quantum computations based on probability distributions of quantum state vectors and on density matrices with classical outputs. We show that both models can be structured using a generalization of monads called arrows.
Keywords: Quantum programming, density matrices, probabilities.


1	Introduction
In recent work [13] we established that a general model of quantum computing (including measurements), based on density matrices and superoperators, is an instance of a generalization of monads called arrows [5]. That work is strictly based on quantum data (any classical value must be represented as quantum). The model cannot express the passage of information between the classical and quantum worlds.
However, various quantum algorithms are explained in terms of the interchanging of quantum and classical information 4 . For example, quantum teleportation is a

1 Email: jkv@atlas.ucpel.tche.br
2 Email: rocha@atlas.ucpel.tche.br
3 Email: sabry@indiana.edu
4 By interchanging we mean, for instance, a measurement in the middle of the computation.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.023

140	J.K. Vizzotto et al. / Electronic Notes in Theoretical Computer Science 210 (2008) 139–152
traditional algorithm which is based on two quantum processes communicating via classical data. There is interest to consider measurements and the information flow between quantum and classical processes as essential components of quantum computations (for instance, see [11,6,9,4,12]).
On the other hand, the finding of a representation that is suitable for repre- senting both the results of unitary transformations and measurement operations should also be put into perspective, in order to uniformly fit with the requirements of generality and completeness.
That is, we would like that the same representational framework be able to take care of both: (1) the task of representing the quantum state resulting from a uni- tary operation applied to a given quantum state, and (2) the task of representing
the pair of information coming out from a measurement, namely: (2a) that cor- responding to the measure produced by the measurement (one of the eigenvalues of the measurement operator), and (2b) the quantum state that results from the
projection imposed on the original quantum state by the measurement (one of the eigenvectors of the measurement operator).
The main problem introduced by the need of that uniformity is that measure- ment results (both value and state results) are of a probabilistic kind, needing sets of possible results for their representation. The usual alternative solution to such
problem is the density matrix formalism.
However, there is a (possibly not minor) conceptual problem in the adoption of the density matrix formalism, namely: a density matrix is supposed to represent a set (ensemble) of quantum systems whose probability distribution of states the density matrix represents; however, from a programming theoretic point of view, one usually thinks of a quantum algorithm as being performed by one single quantum system, not an ensemble of quantum systems each possibly behaving in a different way according to a probability distribution.
We feel that the quantum programmer’s intuition of programming one single quantum system at a time, while elaborating his algorithms, may happen to be not appropriately captured by the density matrix formalism. We feel (but we have no definite argument) that a representation modelled on the usual set-theoretic repre- sentation of states of non-deterministic machines, adjusted to explicitly represent the probability of occurrence of each deterministic state, may happen to capture in a better way the quantum programmer’s intuition.
So, in the paper, we introduce two ways to deal with combined quantum and classical computations, which are based on different ways of representing states which result from measurements, one based on density matrices, the other based on explicit probability distributions over sets of quantum states.
The paper is organised as follows. In Section 2 we introduce indexed monads and indexed arrows in the context of Haskell. Section 3 briefly reviews our previous work [13] on modelling superoperators as arrows. We then show two alternative general and complete models for combined quantum and classical computations structured as indexed arrows in Section 4. Section 5 concludes.


The mathematical concept of monads was introduced to computer science by Mog- gi [7] in the late 1980’s as a way of structuring denotational semantics of pro- gramming languages. Several different language features, including nontermination, state, exceptions, continuations, and interaction can be viewed as monads. More re- cently, this construction has been internalised in the programming language Haskell as a tool to elegantly express computational effects within the context of a pure functional language.
Since the work of Moggi, several natural notions of computational effects were discovered which could only be expressed as generalisations of monads. Of particular importance to us is the generalisation of monads known as arrows [5] which is also internalised in the programming language Haskell. In this section, we briefly discuss a small variation of these notions in the context of the programming language Haskell, which we call indexed monads and indexed arrows. Those are the right notions needed to structure quantum computations.

Indexed Monads
A monad is used for formulating definitions and structuring notions of computations (possibly non-functional) in programming languages. In this context, a program, which features notions of computations, can be viewed as a function from values to computations. For instance a program with exceptions can be viewed as a function that takes a value and returns a computation that may succeed or may fail.
More precisely, to understand monadic computations one can consider a value category , as a model for functions, and build on top of that, notions of computa- tion via an operator (endofunctor ) T acting on objects of  - i.e., T maps an object B from , viewed as the set of values of type τ , to an object TB corresponding to computations of type τ . Then a program which takes an input of type A, and after performing a certain computation returns a value of type B, can be identified with a morphism from A to TB in C [8].
A monad is represented using a type constructor for computations m and two functions:
return :: forall a.a → ma 
>>= ::forall a b.ma → (a → m b) → mb 
The operation >>= (pronounced “bind”) specifies how to sequence computations and return specifies how to lift values to computations. Note the requirements of forall in the definitions above. This is because T , as explained above, is an endofunctor in C. Then, m is a type constructor acting on all objects from the value category.
However, sometimes we want to select some objects (sets) from to apply the constructor T . This notion is slightly more general than monads, and it is captured by the definition of Kleisli structure [2]. Basically, for indexed monads (as we prefer to call Kleisli structures), the function T does not need be an endofunctor on C. We can select some objects from C to apply the constructor. This is exactly the

notion we need to model quantum state vectors 5 as monads. The constructor for a quantum vector can only act over the types which constitute a basis.
Now, the definitions of return and >>= in Haskell should be rephrased as:
return :: forall a.F a ⇒ a → ma 
>>= ::forall a b.F a, F b ⇒ ma → (a → m b) → mb 
That is, for all a for which F a holds we can apply the constructor m, and for all a and b for which F a and F b hold we can apply >>=. Moreover, to construe a proper monad or indexed monad, the return and = functions must work together according to the three monad laws [7].


Indexed Arrows
To handle situations where monads are inapplicable, Hughes [5] introduced a new abstraction generalising monads, called arrows. Indeed, in addition to defining a notion of procedure which may perform computational effects, arrows may have a static component, or may accept more than one input.
Just as we think of a monadic type ma as representing a computation delivering an a, so we think of an arrow type ab c as representing a computation with input of type b delivering a c. Arrows make the dependence on input explicit.
arr	:: forall b c.(b → c) → ab c
(>>>) :: forall b c d.a b c → a c d → ab d
ﬁrst :: forall b c d.a b c → a (b, d ) (c, d )
In other words, to be an arrow, a type a must support the three operations arr, ≫, and ﬁrst with the given types. The function arr allows us to lift “pure” functions to computations. The function ≫ composes two computations. The function ﬁrst allows us to apply an arrow in the context of other data.
Observe the requirements of forall in the definitions. They mean that we can build computations on top of all value functions. However, as with monads, we want to select some specific value functions. This is the case for quantum functions: we want to lift simple functions acting on the basis elements to functions acting on vectors over those basis. Hence we define indexed arrows 6 :
arr :: (I b, I c) ⇒ (b → c) → a b c
(>>>) :: (I b, I c, I d ) ⇒ a b c → ac d → a b d ﬁrst :: (I b, I c, I d ) ⇒ ab c → a (b, d ) (c, d )
The operations for arrows or indexed arrows must satisfy the arrow laws [5], such that these operations are well-defined even with arbitrary permutations and change of associativity.



5 That is, a function which associates each basis element with a complex probability amplitude.
6 Categorically, the definition of arrows is captured by Freyd-categories [10]. Indexed arrows are indexed
Freyd-categories.

Review: Quantum Vectors as Indexed Monads and Superoperators as Indexed Arrows
Vectors as Indexed Monads
In this section we quickly review the work presented in [13]. Given a set a rep- resenting observable (classical) values, i.e. a basis set, a pure quantum state is a vector a  C which associates each basis element with a complex probability ampli- tude. In Haskell, a finite set a can be represented as an instance of the class Basis, shown below, in which the constructor basis :: [a ] explicitly lists the basis elements. The basis elements must be distinguishable from each other, which explains the constraint Eq a on the type of elements:
class Eq a	Basis a where basis :: [a ]
type K = Complex Double
type Vec a = a → K
The type K (notation from the base field) is the type of probability amplitudes.
The monadic functions for vectors are defined as:
return :: Basis a ⇒ a → Vec a
return a b = if a ≡ b then 1.0 else 0.0
(>>=) :: (Basis a, Basis b) ⇒ Vec a → (a → Vec b) → Vec b va >>= f = λb → sum [(va a) ∗ (f a b) | a ← basis ]
return just lifts values to vectors, and bind , given a unitary operator (i.e., unitary operator ) represented as a function a  Vec b, and given a Vec a, returns a Vec b (that is, it specifies how a Vec a can be turned in a Vec b).
Proposition 3.1 The indexed monad Vec satisﬁes the required equations for mon- ads.
Examples of vectors over the set of booleans may be defined as follows:
instance Basis Bool where
basis = [False, True ]
qFalse, qTrue, qFT, qFmT :: Vec Bool qFalse = return False
qTrue = return True
qFT = (1 / √2) $∗ (qFalse ‘mplus‘ qTrue)
qFmT = (1 / √2) $∗ (qFalse ‘mminus‘ qTrue)
The first two are unit vectors corresponding to basis elements; the last two represent states which are in equal superpositions of False and True. In the Dirac notation, these vectors would be respectively written as |False⟩, |True⟩, √1 (|False⟩+ |True⟩),
and √1 (|False⟩− |True⟩). The operations $∗, ‘mplus', and ‘mminus' are the usual scalar product, sum and subtraction of vectors, respectively.
Unitary operations can also be defined directly, for example:
type Uni a b = a → Vec b hadamard :: Uni Bool Bool

hadamard False = qFT hadamard True = qFmT zgate :: Uni Bool Bool
zgate False = qFalse zgate True = −1 $∗ qTrue

Superoperators as Indexed Arrows
Intuitively, density matrices can be understood as a statistical perspective of the state vector. In the density matrix formalism, a quantum state that used to be modelled by a vector v is now transformed in a matrix in such a way that the amplitudes of the state vector turn into a kind of probability distributions over state vectors.
type Dens b = Vec (b, b)
Operations mapping density matrices to density matrices are called superopera- tors:
type Super b c = (b, b) → Dens c
We represent a superoperator mirroring a big matrix, so mapping values to density matrices (that is, Super b c ≡ (b, b) → (c, c) → K ).
Just as the probability effect associated with vectors is a modelled by a indexed monad because of the Basis constraint, the type Super is modelled by a indexed arrow because the types include the additional constraint requiring the elements to form a set of basis values (the definition for arr , >>>, and ﬁrst for Super are in [13]). Using this general model of quantum computations structured as arrows we
can elegantly express quantum computations involving measurements. However, that work is strictly based on quantum data, we can not express algorithms with combined interactions of quantum and classical operations directly. Yet as noted in [4,12] a complete model for expressing quantum algorithms should accommodate both measurements and combined interactions of quantum and classical data.

Quantum Programs as Indexed Arrows
Based on the idea that fully expressible languages/models for quantum computation are supposed to include more than one final measurement operation, that is, they should accommodate both measurements and combined interactions of quantum and classical data, in this section we structure two alternative general (involving mea- surements) and complete (involving both quantum and classical data) approaches for combined quantum and classical computations as indexed arrows. The first one is based on a measurement approach for quantum programs. Basically, at each step (a part) of the density operator representing the global quantum state is measured, a perspective on the classical measurement results is returned, and the state is left in a new density operator. The second one is based on probability distributions over quantum state vectors. Attached to each vector in the distribution there is a list of classical values - the eigenvalues which are the output of performed measurements.

Essentially, the idea is to model the behavior of a single, well determined quantum system, where at any time one can express the information flow from the quantum to the classical level, and vice-versa.

Programs with Density Operators and Classical Outputs
We present a model for quantum computations based on a measurement approach. The idea is to have a density operator representing the global quantum state, and a probability distribution of classical values representing the classical part of the state. A quantum program acting on this state is interpreted by a special tracing superoperator, which in the general case traces out part of the state, returning a classical output, and leaving the system in a new state (possibly in a space with reduced dimension).

Programs with Density Matrices
Because the tracing superoperator in general forgets part of the state, we define a relation between bases which we call Dec (from decomposition):
class (Basis a, Basis b, Basis o) ⇒ Dec a b o where
dec :: [a ] → [(b, o)]
specifying that a basis a can be written as (b, o). Then, a quantum program from a to b, parameterised by i , the type of the input classical probability distribution, and o, the part to be measured, is represented by a superoperator from a to b, delivering a classical probability distribution over o.
type DProb c = [(c, Prob)]
type QProgram i o a b = (DProb i , (a, a)) → (DProb o, Dens b)
Note that our quantum programs should satisfy the restriction Dec a b o, and that DProb i is used in classical operations or quantum operations controlled by classical data.
As any type can be decomposed by the unit (), and can be decomposed by itself, and also can be decomposed into one of its parts, we have the following instances:
instance (Basis a)   Dec a a () where
dec [] = [] 
dec (x : l ) = (x , ()) : dec l
instance (Basis a)   Dec a () a where
dec [] = [] 
dec (x : l ) = ((), x ): dec l
instance (Basis a, Basis b)	Dec (a, b) ab where dec l = l
Any unitary operator can be lifted to a quantum program which traces out ().
uni2qprog :: (Basis a, Basis b, Basis i , Dec a b ())
Lin a b	QProgram i () ab uni2qprog f (dp, (a1, a2)) =
let d = uni2vec (f a1	f a2)
in ([ ], d )

where uni2vec f = [((a, b), f a b) | (a, b) ← basis ]
v1⟩∗⟨v2 = λa1 → [(a2, v1 a1 ∗ conjugate (v2 a2)) |
a2 ← basis ]
The function uni2qprog constructs a quantum program, acting on a combined state, from a unitary operator. The idea is to apply the default construction to build a superoperator from a unitary transformation. Note that the classical input is ignored and the classical output is empty: there is no interaction with the classical world when considering unitary transformations. For instance:
hadamardP :: QProgram i () Bool Bool hadamardP = uni2qprog hadamard
lifts the unitary operator hadamard to a quantum program acting on a combined state.
Given, a quantum state over a basis set (a, b), the quantum program trR forgets the right component, returning a new state over b. The subspace is measured before
being discharged outputting a classical probability distribution over the basis which forms that subspace. In this case, the input classical data is just ignored.
trR :: (Basis a, Basis b, Dec (a, b) a b)	QProgram i b (a, b) a trR (dp, ((a1, b1), (a2, b2))) = let d = if b1		b2 then return (a1, a2)
else vzero
p = [(b1, 1)  b1	b2 ]
in (p, d )
trA :: (Basis a, Basis i , Dec a () a)	QProgram i a a ()
trA (dp, (a1, a2)) = let d = if a1  a2 then return ((), ()) else vzero p = [(a1, 1) a1  a2 ]
in (p, d )
Similarly, the program trA forgets (measures) all quantum state returning only a classical probability distribution as the result. To construe the classical probability distribution we consider that any value from the type being measured can appear in the output quantum state. Hence each value from the basis is attached to the probability 1. The real probability to appear in the final state is calculated by the function app below, which given a program and a combined state calculates the new density matrix and the classical result (if there is some).
app :: (Basis a, Basis b, Basis i , Basis o, Dec a b o)
QProgram i o a b	(DProb i , Dens a)	(DProb o, Dens b) app p (di, da) = let dbf = [(b, sum [let (po, db) = p (di, a)
p2 = db b
p1 = da a
in p1	p2 a	basis ])  b	basis ]
po = [(o, p1	p2	p3)  a	basis, (b, o)	dec [a ],
let (po, db) = p (di, (a, a)),
let p1 = lookup o po, let p2 = da (a, a), let p3 = dbf (b, b)]
in (po, dbf )

The output density matrix is calculated by simple matrix multiplication: the su- peroperator matrix by the input density matrix. Note that the overall operation may depend of the classical state. The probability distribution of classical values is calculated by the multiplication of the probability of the observable value in the operator by the probability of the respective observable value in the input density matrix. Also we take into account the output density matrix in the calculation as it may be the case that a unitary operation is applied before the measurement.

Programs with Density Matrices as Indexed Arrows
We define the three functions, arr , >>>, and ﬁrst , over QProgram i o as follows:
arr :: (Basis b, Basis c, Dec b c ())	(b	c)	QProgram i () bc arr = uni2qprog.fun2uni
where fun2uni f = return.f
(>>>) :: (Basis a, Basis b, Basis c, Basis o1, Basis o2,
Dec a b o1, Dec b c o2)
QProgram i o1 ab	QProgram o1 o2 bc	QProgram i o2 ac 
(f >>> g ) (dpi, (a1, a2)) = app g (f (dpi, (a1, a2)))
ﬁrst :: (Basis a, Basis b, Basis c, Basis o,
Dec a b a2, Dec (a, c) (b, c) a2) ⇒
QProgram i o a b → QProgram i o (a, c) (b, c)

ﬁrst
p (dpi, ((b1, d1), (b2, d2))) =
let (dc, dpo) = p (dpi, (b1, b2))
vdd = return (d1, d2)
dbd = [(((b1, d12), (b2, d22)), db (b1, b2) dc ∗ vdd (d12, d22)) |
((b1, d12), (b2, d22)) ← basis ]

in (dpo, dbd )

Proposition 4.1 The indexed arrow QProgram i o satisﬁes the required equations for arrows.


Programs with Probability Distributions of Quantum Vectors States
The idea is to have a combined state, where the classical part is as before (i.e. a probability distribution of classical values), and the quantum part is represented by a explicit probability distribution over quantum states. A program acting on this combined state can act on the quantum part, on the classical part, or on both parts. Combined programs acting only on quantum data are of two kinds: i) the unitary transformations, which reversibly transform the state vector and nothing happens to the classical probability; and ii) measurements, which probabilistically yield one
of the eigenvalues of the observable being measured, and throws the system into
the correspondent eigenstate. Yet one can have quantum operations controlled by classical values as well as purely classical operations.

Programs with Probability Distributions
The probabilistic quantum programming model is based on a data type to represent
explicit probability distributions of quantum state vectors:
type EV = Double
type Prob = Double
newtype PDQst a = PDQ{unPDQ :: [([EV ], Vec a, Prob)]}
More specifically, a probability distribution over a basis set a is represented by a pair formed by: a list of real values EV , the eigenvalues which are the outputs of previously performed measurements, and a state vector, Vec a. We chose to keep a list of eigenvalues EV to maintain a history of measurements. For now this list does not include information about the source of eigenvalues, i.e., about the position of the qubit which was measured in the global state.
The dynamics of a quantum system is represented by two kinds of transforma- tions of probability distribution over state vectors:
data PDQTrans b c = Transform ((PDQst b) → (PDQst c))
| Meas ((PDQst b) → (PDQst c))
We made the difference explicit because the semantics of applying unitary transfor- mations is different from the semantics of applying measurements.
A simple unitary transformation can be defined in such a way that the transfor- mation is applied to all vectors in the distribution. The list of eigenvalues and the probabilities are preserved.
Measurements are the operations which produce eigenvalues as classical outputs
and return a new classical probability distribution of eigenstates of the observable according to each vector in the distribution.

Programs with Probability Distributions as Indexed Arrows
We define the three functions, arr , >>>, and ﬁrst , over PDQTrans as follows:
arr :: (Basis b, Basis c)	(b	c)	PDQTrans b c
arr f = Transform (λx	PDQ [(e1, v2, p)  (e1, v1, p)	unPDQ x ,
let fv = fun2vecfun f ,
let v2 = fv v1 ])
(>>>) :: (Basis b, Basis c, Basis d ) ⇒
PDQTrans b c → PDQTrans c d → PDQTrans b d
(Transform f ) >>> (Transform g ) = Transform (λx → let d = f x in g d ) (Meas f ) >>> (Transform g ) = Transform (λx → let d = f x in g d ) (Transform f ) >>> (Meas g ) = Meas (λx → let d = f x in g d )
(Meas f ) >>> (Meas g ) = Meas (λx → let d = f x in g d )
ﬁrst :: (Basis b, Basis c, Basis d ) ⇒
PDQTrans b c → PDQTrans (b, d ) (c, d )
ﬁrst (Transform f ) = 
Transform (λx	let fg = getvbs (Transform f )
fext = helper ﬁrst fg
in PDQ [(le, v, p) | (le1, v1, p1) ← unPDQ x ,





ﬁrst (Meas f ) = 
let (le, v, p) =	(le1, [((c, d ), k1 ∗ k2) |
((b, d ), k1) ← v1, let d2 = fext (b, d ), (le2, v2, p2) ← unPDQ d2,
((c, d ), k2) ← v2 ], p1)])

Meas (λx	let	fg = getvbs (Meas f )
fext = helper ﬁrst fg
in zipqd (PDQ [(le, v, p)  (le1, v1, p1)	unPDQ x ,
((b, d ), k1)	v1, let d2 = fext (b, d ), (le2, v2, p2)		unPDQ d2,
let (le, v ) = (le2 ++ le1,
[((c, d ), k1 ∗ k2) | ((c, d ), k2) ← v2 ]),
let p = p1 ∗ p2 ∗ (((∗∗2).magnitude) k1)]))
The first two functions are straightforward: arr constructs a reversible transforma- tion from a basic function, fun2vecfun converts a “matrix” to a function mapping
vectors to vectors, and >>> just composes two PDQTrans. The function ﬁrst is a
bit more subtle, the idea is to transform a function which acts in part of a quantum state (say Vec b) to a function which acts in the global state (say Vec (b, d )). The
implementation is based in the following two functions:
getvbs :: PDQTrans a b → (a → PDQst b)
getvbs (Transform f ) = λa → let d = dreturn a in f d getvbs (Meas f ) = λa → let d = dreturn a in f d helper ﬁrst :: (a	PDQst b)	(a, c)	PDQst (b, c)
helper ﬁrstl f (a, c) =	let	db = f a
dc = dreturn c
in PDQ [(le, v2, p	q )
(le, vb, p)	unPDQ db,
(, vc, q )	unPDQ dc,
let v2 = [((b, c),
vb b ∗ vc c) | (b, c) ← basis ]]
Given a PDQTrans, getvbs determines how that behaves for basic vectors. Then, given the basis’ elements, helper ﬁrst extends the transformation. Essentially, what ﬁrst does is to calculate the extended function for the input PDQTrans using ﬁrstbs, and then to calculate the output, correctly applying the extended PDQTrans to the
input probability distribution of state vectors. The trick for ﬁrst is that we have
made an explicit difference between measurements and unitary transformations. If the input function is not a measurement the calculation is standard, but if that is a measurement then the number of states vectors in the distribution is augmented
and we need to use the function zipqd , which combines all state vectors that are
tagged with the same eigenvalue.


Proposition 4.2 The indexed arrow PDQTrans satisﬁes the required equations for arrows.

Example: Quantum Teleportation
Quantum teleportation [3] is one of the most traditional examples of quantum algo- rithms which require the interchanging between quantum and classical data. T hat enables the transmission, using a classical communication channel, of an unknown quantum state via a previously shared epr pair. In this section we faithfully express the teleportation algorithm using the two models presented above.
In this section we use Paterson (2001)’s arrow notation. Arrow notation is an extension to Haskell with an improved syntax for writing computations using arrows. Here is a simple example to illustrate the notation:
e1 :: Super (Bool, a) (Bool, a) e1 = proc (a, b) → do
r ← lin2super hadamard ≺ a returnA ≺ (r, b)
The do-notation simply sequences the actions in its body. The function returnA is the equivalent for arrows of the monadic function return. The two additional keywords are:
the arrow abstraction proc which constructs an arrow instead of a regular function.
the arrow application ≺ which feeds the value of an expression into an arrow.

Teleportation with Density Matrices and Classical Outputs
The main procedure receives no classical data and three entangled qubits; then passes a qubit of the epr pair and the qubit to be teleported to Alice, which realizes some quantum operations and measures its two qubits, returning only classical values to the main procedure, which will be communicated to Bob.
teleportation :: QProgram () () (Bool, Bool, Bool ) Bool teleportation = proc (eprL, eprR, q ) → do
cs ← alice ≺ (eprL, q ) q' ← bob ≺ (eprR, cs) returnA ≺ q'
alice :: QProgram () (Bool, Bool ) (Bool, Bool ) ()
alice = proc (eprL, q ) → do
(q1, e1) ← qcnotP ≺ (q, eprL) q2 ← hadamardP ≺ q1
cs ← trA ≺ (e1, q2)
returnA ≺ cs
where qcnotP is the program:
qcnotP :: QProgram () () (Bool, Bool ) (Bool, Bool )
qcnotP = uni2qprog (controlled arr	)
where controlled f (b, a) = (return b)
(if b then f a else return a)
which acts as a controlled quantum not over the quantum data.
Bob is a procedure which receives a classical data over (Bool, Bool ) and a qubit.

The procedure analyses the classical data and depending on its value applies or not a certain quantum operation to the input qubit.
bob :: QProgram (Bool, Bool ) () ((), Bool ) Bool
bob = λ(pbb, db)	let (p1, d1) = if (lookup True (unzipL pbb) pbb > 0)
then (qnotP ([((), 1)], db))
else ([((), 1)], vreturn db)
(p2, d2) =  if (lookup True (unzipR pbb) > 0)
then (zgateP ([((), 1)], db))
else st1
in (p2, d2)
Again we are using a program version of a unitary operation:
zgateP :: QProgram () () Bool Bool zgateP = uni2prog zgate
The functions unzipL and unzipR take a list of tuples and return a list with the left elements of the tuples and a list with the right elements of the tuples, respectively.
unzipL :: [((a, b), p)]	[a ]
unzipL l = let (lb, lp) = unzip l
(las, lbs) = unzip lb
in las
unzipR :: [((a, b), p)]	[b ]
unzipR l = let (lb, lp) = unzip l
(las, lbs) = unzip lb
in lbs

Teleportation with Probability Distribution of Quantum State Vectors Using a reasoning as above, we model the algorithm for teleportation using explicit probability distributions as arrows:
alice :: PDQTrans (Bool, Bool ) ()
alice = proc (eprL, q ) → do
(q1, e1) ← controlled notD ≺ (q, eprL) q2 ← hadamardD ≺ q1
u1 ← discqD ≺ q2
e2 ← simplqD ≺ (u1, e1) u2 ← discqD ≺ e2 returnA ≺ u2
where the function
discqD :: PDQTrans Bool ()
discards a qubit, which physically corresponds to measuring it, returning a real value for the probability distribution; simplqD just simplifies unity ().
bob :: PDQTrans Bool Bool
bob = PDQTrans (λx → PDQ [((le1, v3), p1) | ((le1, v1), p1) ← unPDQ x ,
let v2 = if ((head le1) ≡ 1) then v1 >>= qnot else v1,

let v3 = if ((head (tail le1)) ≡ 1) then v2 >>= z else v2 ]) teleportation :: PDQTrans (Bool, Bool, Bool ) Bool teleportation = proc (eprL, eprR, q ) → do
u1 ← alice ≺ (eprL, q ) q' ← bob ≺ eprR returnA ← q'
Conclusions and Future Work
We have presented two general and complete models for combined (quantum and classical) computations structured as arrows. The presentation is a stepping stone to develop a language in which the classical, probabilistic, and quantum layers are separate, which would simplify reasoning about quantum programs. The implemen- tation is a prototype of the ideas in Haskell. We hope to integrate the results in some quantum programming language like QML [1].

References
Altenkirch, T. and J. Grattage, A functional quantum programming language, in: Proceedings of the 20th Annual IEEE Symposium on Logic in Computer Science, LICS 2005, IEEE Computer Society Press, 2005, pp. 249–258.
Altenkirch, T. and B. Reus, Monadic presentations of lambda terms using generalized inductive types, in: Computer Science Logic, 1999.
Bennett, C. H., G. Brassard, C. Crepeau, R. Jozsa, A. Peres and W. Wootters, Teleporting an unknown quantum state via dual classical and EPR channels, Phys. Rev. Lett. (1993), pp. 1895–1899.
Gay, S. J. and R. Nagarajan, Communicating quantum processes, in: Proceedings of the 32nd ACM Symposium on Principles of Programming Languages, 2005.
Hughes, J., Generalising monads to arrows, Science of Computer Programming 37 (2000), pp. 67–111.
Kashefi, E., P. Panangaden and V. Danos, The measurement calculus (2004).
Moggi, E., Computational lambda-calculus and monads, in: Proceedings of the Fourth Annual Symposium on Logic in computer science, IEEE Computer Society Press (1989), pp. 14–23.
Moggi, E., Notions of computation and monads, Information and Computation 93 (1991), pp. 55–92.
Nielsen, M. A., Universal quantum computation using only projective measurement, quantum memory, and preparation of the 0 state, Phys. Lett. A. 308 (2-3) (2003), pp. 96–100.
Paterson, R., A new notation for arrows, in: International Conference on Functional Programming
(2001), pp. 229–240.
Raussendorf, R., D. Browne and H. Briegel, Measurement-based quantum computation with cluster states, Phys. Rev. A 68 (2003).
Unruh, D., Quantum programs with classical output streams, in: Proceedings of the 3rd International Workshop on Quantum Programming Languages (QPL 2005), Electronic Notes in Theoretical Computer Science 170 (2006), pp. 165–184.
Vizzotto, J. K., T. Altenkirch and A. Sabry, Structuring quantum effects: Superoperators as arrows, Mathematical Structures in Computer Science, special issue on Quantum Programming Languages 16 (2006), pp. 453–468.
