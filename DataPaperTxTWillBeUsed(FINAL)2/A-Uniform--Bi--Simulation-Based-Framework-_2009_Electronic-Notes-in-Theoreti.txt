

Electronic Notes in Theoretical Computer Science 251 (2009) 27–48
www.elsevier.com/locate/entcs

A Uniform (Bi-)Simulation-Based Framework for Reducing Tree Automata

Parosh A. Abdulla1
Department of Information Technology University of Uppsala
Uppsala, Sweden

Luka´ˇs Hol´ık5 ,2
Faculty of Information Technology Brno University of Technology Brno, Czech Republic

Lisa Kaati3
Department of Information Technology University of Uppsala
Uppsala, Sweden

Toma´ˇs Vojnar5 ,4
Faculty of Information Technology Brno University of Technology Brno, Czech Republic


Abstract
In this paper, we address the problem of reducing the size of nondeterministic (bottom-up) tree automata. We propose a uniform framework that allows for combining various upward and downward bisimulation and simulation relations in order to obtain a language-preserving combined relation suitable for reducing tree automata without a need to determinise them. The framework generalises and extends several previous works and provides a broad spectrum of different relations yielding a possibility of a fine choice between the amount of reduction and the computational demands. We, moreover, provide a significantly improved way of computing the various combined (bi-)simulation relations. We analyse properties of the considered relations both theoretically as well as through a series of experiments.
Keywords: tree automata, bisimulation, simulation, combined relations, size reduction


1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.08.026

Introduction
Finite tree automata are a natural generalisation of word automata. Since trees (or terms) appear in many areas of computer science and engineering, tree au- tomata are quite broadly applicable—including, for instance, applications in XML manipulation, natural language processing, or formal verification. In most of these applications, dealing with as small automata as possible is highly desirable. In order to reduce the size of a given tree automaton, one can always try to determinise and minimise it. However, the determinisation may lead to an exponential blow-up in the size, and even the minimal deterministic automaton might still be bigger than the original nondeterministic automaton. Moreover, even if the minimal determin- istic automaton is really small, it might be impossible to compute it due to the very expensive determinisation step.
An alternative way to reduce a given (nondeterministic) tree automaton is to identify a suitable, language-preserving equivalence relation over its states and col- lapse those states that are equal according to this relation. As in the case of word automata, good candidates for such relations are various bisimulations and simula- tion equivalences. In particular, the so-called forward and backward bisimulations and simulation equivalences are well known to be useful when reducing the size of word automata. In this paper, we deal with their tree automata extensions—the so-called downward and upward bisimulations and simulation equivalences.
The downward (bi-)simulations, which straightforwardly generalise the appropri- ate backward (bi-)simulations from word automata to (bottom-up) tree automata, are compatible with the language inclusion preorder. That is, if a state r downward (bi-)simulates a state q, then the language accepted by q is a subset of the language accepted by r. Therefore, these relations are a natural choice for reducing the size of tree automata.
The upward (bi-)simulations are not compatible with the language inclusion preorder. Instead, they are compatible with the inclusion of the so-called context languages, where a context of a state q arises from a tree accepted at q by replacing some of its leaves by a “hole”. It can, however, be shown that when we restrict our- selves to upward (bi-)simulations compatible with the set of final states of automata, the downward and upward (bi-)simulations can be combined in such a way that they yield a language-compatible equivalence. In the worst case, the combined relation is as coarse as the appropriate downward (bi-)simulation equivalence, but according to our practical experiments, it usually leads to significantly better reductions of the automata.
Tree bisimulations can be computed efficiently in time O(rˆ2 m log n) where rˆ is the maximal rank of the input symbols, m the size of the transition table, and n the number of states of the given tree automaton [3,9,1]. However, the reduction

1 Email: parosh@it.uu.se
2 Email: holik@fit.vutbr.cz
3 Email: lisa.kaati@it.uu.se
4 Email: vojnar@fit.vutbr.cz
5 This work was supported by the Czech Science Foundation (projects 102/07/0322, 102/09/H042) and the Czech Ministry of Education, Sports, and Youth by the project MSM 0021630528.

obtained by using bisimulations is often limited. Tree simulations are weaker than bisimulations and hence offer a better reduction. On the other hand, despite the recent advances in algorithms devised for computing them [2], they are significantly more expensive to compute. The time complexity of computing simulation preorders is roughly in O(l rˆ2 m2) where l is the size of the alphabet.
In this paper, we propose a novel notion of upward simulations and bisimula- tions parameterised by an inducing downward simulation or bisimulation (in any possible combination). Moreover, we introduce a new operator—called a weaken- ing combination operator —for combining such upward and downward simulation and bisimulation relations on tree automata. This way, we obtain a uniform tree (bi-)simulation framework which brings in several significant advantages.
First, the proposed framework allows one to combine not only maximal down- ward and upward simulations or maximal downward and upward bisimulations as considered in previous works [2,1], but to combine any inducing downward simu- lation (i.e., also a downward bisimulation or, e.g., the identity relation) with any induced upward simulation (i.e., also a bisimulation or identity). This way, we ex- plain in a uniform way several previous results [9,2,1] and, moreover, we obtain several new combined relations suitable for reducing tree automata. The use of such relations mixing in various ways the advantages of simulations and bisimula- tions allows the user to ﬁne-tune the ratio between the possible reductions and their cost.
We carefully analyse mutual relationships of the various considered relations. We establish a certain partial ordering between their reduction capabilities, but we also show that many of them have an incomparable reduction power.
Further, compared to the previous works, the newly proposed combination operator brings in also a significantly improved way of computing the combined (bi-)simulation relations. Before the combination was accomplished by randomly looking for some combined relation satisfying the needed requirements. The newly proposed combination operator computes a maximal combined relation, which we show to be unique. The algorithm that we propose for this purpose turns out to be quite simple and runs in time O(n3) (or, in fact, even in a slightly better time). The use of the maximal combined relations turns out to itself give much better results in our experiments than the previously used random combination algorithms. Let us also note that the notion of combined (bi-)simulation relations that we propose is applicable even for word automata as for a special case of tree automata.
In order to experimentally examine the broad spectrum of relations offered by our framework, we implemented a prototype tool in which we have performed thor- ough experiments with tree automata from the domain of formal verification of infinite-state systems based on the so-called regular tree model checking and ab- stract regular tree model checking [6,4,7,5]. Our experimental results confirm that we have obtained a broad range of algorithms for reducing tree automata, differing in their computation complexity and reduction capabilities.

Related Work.
Several algorithms for reducing the size of non-deterministic tree automata while preserving their language have been proposed in the literature. The first attempt was done in [3] where an algorithm inspired by the partition refinement algorithm by Paige and Tarjan [11] was presented. In [9], two different types of bisimulations— a backward and forward bisimulation—were presented. These bisimulations turn out to be special cases of the relations arising in our framework.
Efficient algorithms for computing simulation equivalences over tree automata have then been discussed in [2] together with a proposal of combined simulation relations. In [1], the ideas from [2] were extended to work for bisimulations. In this paper, we combine these previous works in a framework which allows us to explain them in a uniform way and, moreover, to obtain multiple new relations applicable for reducing tree automata. The obtained framework allows the user to mix advantages of simulation and bisimulation approaches in a degree suitable for a given scenario. The way we use for computing the upward and downward relations that we are dealing with is inspired by the approach of [2] and [1]. We, however, provide a new and significantly improved way of combining these relations via the newly proposed weakening combination operator.

Plan of the Paper.
The rest of the paper is organised as follows. We start with some preliminaries in Section 2. In Section 3, we introduce the notions of downward (bi-)simulations, and propose the notion of parameterised upward (bi-)simulations. Subsequently, in Section 4, we propose the weakening combination operator and its use for ob- taining combined relations suitable for reducing tree automata. Next, Section 5 analyses properties of the most interesting possible combined relations. Section 6 overviews algorithms usable for computing downward and upward (bi-)simulations and proposes an algorithm for computing their combinations. In Section 7, we give an experimental evaluation of using the obtained spectrum of relations for reducing tree automata. Finally, we summarise the paper and discuss possible future work in Section 8.
Preliminaries
In this section, we introduce some preliminaries on relations, trees, and tree au- tomata.

Trees.
A ranked alphabet Σ is a set of symbols together with a function # : Σ → N. For f ∈ Σ, the value #(f ) is called the rank of f . For any n ≥ 0, we denote by Σn the set of all symbols of rank n from Σ. Let ϵ denote the empty sequence. A tree t over a ranked alphabet Σ is a partial mapping t : N∗ → Σ that satisfies the following conditions:
dom(t) is a finite, prefix-closed subset of N∗, and

for each p ∈ dom(t), if #(t(p)) = n ≥ 0, then {i | pi ∈ dom(t)} = {1,... , n}. Each sequence p ∈ dom(t) is called a node of t. For a node p, we define the ith
child of p to be the node pi, and the ith subtree of p to be the tree t' such that t'(p') = t(pip') for all p' ∈ N∗. A leaf of t is a node p which does not have any children, i.e., there is no i ∈ N with pi ∈ dom(t). We denote by T (Σ) the set of all trees over the alphabet Σ.

Tree Automata.
A (finite, non-deterministic, bottom-up) tree automaton (abbreviated as TA in the following) is a quadruple A = (Q, Σ, Δ,F ) where Q is a finite set of states, F ⊆ Q is a set of final states, Σ is a ranked alphabet, and Δ is a set of transition rules. Each transition rule is a triple of the form ((q1,... , qn), f, q) where q1,... , qn,q ∈ Q,
f ∈ Σ, and #(f )= n. We use (q ,... ,q ) −f→ q to denote that ((q ,... ,q ), f, q) ∈
1	n	1	n
Δ. In the special case where n = 0, we speak about the so-called leaf rules, which
we sometimes abbreviate as −f→ q. We use Lhs (A) to denote the set of left-hand
sides of rules, i.e., the set of tuples of the form (q ,... ,q ) where (q ,... ,q ) −f→ q
1	n	1	n
for some f and q. Finally, we denote by rˆ(A) the smallest n ∈ N such that n ≥ m
for each m ∈ N where (q1,... , qm) ∈ Lhs (A) for some qi ∈ Q, 1 ≤ i ≤ m. We omit the reference to A if no confusion may arise.
A run of A over a tree t ∈ T (Σ) is a mapping π : dom(t) → Q such that, for each node p ∈ dom(t) where q = π(p), if qi = π(pi) for 1 ≤ i ≤ n, then Δ has a rule
(q ,... ,q ) t(p)	π  q to denote that π is a run of A over t such that
1	n −→ q. We write t =⇒
π(ϵ) = q. We use t =⇒ q to denote that t =⇒ q for some run π. The language of
a state q is defined by L(q) = {t| t =⇒ q}, while the language of A is defined by
L(A)=  q∈F L(q).
An environment is a tuple of the form ((q1,... , qi−1, , qi+1,... , qn), f, q) ob- tained by removing a state qi, 1 ≤ i ≤ n, from the ith position of the left hand side of a rule ((q1,... , qi−1, qi, qi+1,... , qn), f, q), and by replacing it by a spe- cial symbol  /∈ Q (called a hole below). Like for transition rules, we write
(q1,... , ,... , qn) −f→ q provided ((q1,... , qi−1, qi, qi+1,... , qn), f, q) ∈ Δ for some
qi ∈ Q. Sometimes, we also write the environment as (q ,... ,  ,... ,q ) −f→ q to
1	i	n
emphasise that the hole is at position i. We denote the set of all environments of
A by Env(A) and we will drop the reference to A if no confusion may arise.

Relations.
For an equivalence relation ≡ defined on a set Q, we call each equivalence class of ≡ a block, and use Q/≡ to denote the set of blocks in ≡. For a preorder P , we will denote ≡P the maximal equivalence included in P .

Quotient Tree Automata.
The idea of reducing the size of an automaton is to identify suitable equivalence relations on its states, and then collapse the sets of states which form equivalence

classes. Consider a TA A = (Q, Σ, Δ,F ) and an equivalence relation ≡ on Q. The
quotient tree automaton derived from A and ≡ is A≡ = (Q≡, Σ, Δ≡, F≡) where:
Q≡ is the set of blocks in ≡. In other words, we collapse all states which belong to the same block into one state of the quotient automaton.
(B ,... , B ) −f→ B iff (q ,... ,q ) −f→ q for some q ∈ B ,... ,q  ∈ B ,q ∈ B.
1	n	1	n	1	1	n	n
This is, there is a transition in the quotient automaton iff there is a transition
between states in the corresponding blocks in the original TA.
F≡ contains a block B iff B ∩ F /= ∅. Intuitively, a block is accepting if it contains a state which is accepting.

(Bi-)Simulations on Tree Automata
We now present definitions of downward (bi-)simulations and subsequently, we pro- pose a notion of upward (bi-)simulations parameterised by a downward simulation as one of the cornerstones of our framework. We will call a downward simulation that is used as a parameter of an upward (bi-)simulation an inducing relation, and the obtained upward (bi-)simulation will then be called an induced relation.
In the next section, we will show how a pair of an inducing and induced relation can be combined into a new equivalence suitable for reducing tree automata. Note that the inducing relation is thus used in two different ways: as a parameter of the upward (bi-)simulation and as a constituent of the combined relation. By consid- ering various inducing relations, we obtain a wide spectrum of combined relations differing in their computational complexity and coarseness (which is usually better and never worse than that of the inducing relation).

Downward (Bi-)Simulations
For a tree automaton A = (Q, Σ, Δ,F ), a downward simulation D is a binary relation on Q such that if qDr and (q1,... , qn) −f→ q, then (r1,... , rn) −f→ r with qiDri for each i :1 ≤ i ≤ n. A downward bisimulation D is a binary relation on Q
such that if qDr, then (q ,... ,q ) −f→ q if and only if (r ,... ,r ) −f→ r with q Dr

1	n
for each i :1 ≤ i ≤ n.
1	n	i	i

The two lemmas below state some basic properties of downward (bi-)simulations.
Lemma 3.1 The set of all downward simulations on A is closed under reflexive and transitive closure and under union.
Proof. Union: Given two downward simulations D1 and D2, we want to prove that D = D1 ∪ D2 is also a downward simulation. Let qDr for some q, r ∈ Q, then either qD1r or qD2r. Assume without loss of generality that qD1r. Then, from the definition of downward simulations, whenever (q1,... , qn) −f→ q, then there is a rule

(r ,... ,r ) −f→ r with q D r for all i : 1 ≤ i ≤ n. As D ⊆ D gives q Dr
for all

1	n	i  1 i	1	i	i
the positions i, D fulfils the definition of a downward simulation.

Reflexive closure: It can be seen from the definition of downward simulations that the identity is a downward simulation. Thus, the union of the identity and any downward simulation is a downward simulation.
Transitive closure: Let D be a downward simulation and let DT be its transitive
closure. Let q1DT qm and (q1,... , q1) −f→ q1. From q1DT qm, we have that there
1	n
are states q1,... , qm such that q1Dq2D ... Dqm. Therefore, from the definition of
downward simulations, there are also rules (q1,... , q1) −f→ q1,... , (qm,... , qm) −f→
1	n	1	n
qm with q1D ... Dqm, and q1D ... Dqm for all i : 1 ≤ i ≤ n. Thus, as DT is the
i	i
transitive closure of D, we obtain q1DT qm for all i : 1 ≤ i ≤ n. We have proven
i	i
that DT fulfils the definition of downward simulations.	 
Lemma 3.2 The set of all downward bisimulations on A is a subset of the set of all downward simulations on A and it is closed under symmetric, reflexive, and transitive closure and under union.
Proof. The fact that each downward bisimulation is also a downward simulation follows straight from the definitions of these relations. The closure under union, reflexivity, and transitivity can be proven analogically as in the case of downward simulations. What remains is the closure under symmetry. Let D be a downward bisimulation and let DS = D ∪ D−1 be its symmetrical closure. It is sufficient to prove that D−1 is a downward bisimulation because then, from the closure under union, DS is a downward bisimulation too.
Let qD−1r. Then, from rDq, we have that (r1,... , rn) −f→ r if and only if

(q ,... ,q ) −f→ q with r Dq
for all i : 1 ≤ i ≤ n. As rDq is equivalent to

1	n	i	i

qD−1r, we can write that (q ,... ,q ) −f→ q iff (r ,... ,r ) −f→ r with q D−1r
for

1	n	1	n	i	i
all i : 1 ≤ i ≤ n. We directly see that D−1 matches the definition of downward bisimulations.	 
Lemma 3.1 and Lemma 3.2 imply that for a given tree automaton, there is a unique maximal downward bisimulation which is an equivalence and a unique maximal downward simulation which is a preorder. We note that the notion of downward bisimulations corresponds to that of backward bisimulations from [9].
The obvious fact that any downward bisimulation is a downward simulation al- lows us to simplify some further reasoning by considering just downward simulations and handling bisimulations as their special case.

Induced Upward Simulations
Given a tree automaton A = (Q, Σ, Δ,F ) and an inducing downward simulation preorder D on A, an upward simulation U induced by D is a binary relation on Q such that if qUr, then
if (q1,... , qn) −f→ q' with qi = q, 1 ≤ i ≤ n, then (r1,... , rn) −f→ r' with
ri = r, q'Ur', and qjDrj for each j :1 ≤ j /= i ≤ n;
q ∈ F =⇒ r ∈ F .

The following lemma subsumes basic properties of upward simulations. Note that it also implies that for any inducing downward simulation preorder D, there is always a unique maximal upward simulation induced by D which is a preorder.
Lemma 3.3 Given a downward simulation preorder D on A, the set of all upward simulations induced by D is closed under reflexive and transitive closure and under union.
Proof. Union: Given two upward simulations U1 and U2 induced by D, we want to prove that U = U1 ∪ U2 is also an upward simulation induced by D. Let qUr for some q, r ∈ Q, then either qU1r or qU2r. Assume without loss of generality that qU1r. Then, from the definition of upward simulations, whenever (q1,... , qn) −f→ q' with qi = q, then there is a rule (r1,... , rn) −f→ r' with q'U1r', q' ∈ F =⇒ r' ∈ F ,
and qjDrj for all j :1 ≤ j /= i ≤ n. As U1 ⊆ U gives q'Ur', U fulfils the definition of upward simulations induced by D.
Reflexive closure: It can be seen from the definition that the identity is an up- ward simulation induced by D for any downward simulation preorder D. Therefore, from the closure under union, the union of the identity and any upward simulation induced by D is an upward simulation induced by D.
Transitive closure: Let U be an upward simulation induced by D and let
UT be its transitive closure. Let q1UT qm and (q1,... , q1) −f→ r1 with q1 = q1.
1	n	i
From q1UT qm, we have that there are states q1,... , qm such that q1Uq2U ... Uqm.
Therefore, there are also rules (q1,... , q1) −f→ r1,... , (qm,... , qm) −f→ rm with
1	n	1	n
q1 = q1,... , qm = qm, r1U ... Urm, r1 ∈ F =⇒ ... =⇒ rm ∈ F , and q1D ... Dqm
i	i	i	j	j
for all j : 1 ≤ j /= i ≤ n. Thus, from the definition of UT , we have r1UT rm, from
the transitivity of =⇒ , we have r1 ∈ F =⇒ rm ∈ F , and from the transitivity of
D, we have q1Dqm for all j : 1 ≤ j /= i ≤ n. We have thus proven that UT fulfils
j	j
the definition of an upward simulation induced by D.	 

Induced Upward Bisimulations
Let A = (Q, Σ, Δ,F ) be a tree automaton and let D be a downward simulation preorder on A. An upward bisimulation U on A induced by D is a binary relation on Q such that if qUr, then
(q ,... ,q ) −f→ q' with q = q, 1 ≤ i ≤ n, if and only if (r ,... ,r ) −f→ r' with
1	n	i	1	n
ri = r, q'Ur', and qj ≡D rj for each j :1 ≤ j /= i ≤ n;
q ∈ F ⇐⇒ r ∈ F .
As for upward simulations, it is not hard to prove the basic properties of up- ward bisimulations. Note that the following lemma implies that for any downward simulation preorder D, there is a unique maximal upward bisimulation induced by D that is an equivalence. It is also clear that any upward bisimulation induced by D is also an upward simulation induced by D. This will allow us to prove the main results just for upward simulations and maintain bisimulations as a special case.

Lemma 3.4 Given a downward simulation preorder D on A, the set of all upward bisimulations induced by D is a subset of the set of all upward simulations induced by D and it is closed under symmetric, reflexive, and transitive closure and under union.
Proof. The fact that each upward bisimulation induced by a downward simulation D is also an upward simulation induced by D follows straight from the definitions of these relations. The closure under union, reflexivity, and transitivity can be proven analogically as in the case of upward simulations. What remains is the closure under symmetry. Let U be an upward bisimulation induced by a downward simulation preorder D and let US = U ∪ U −1 be its symmetrical closure. It is sufficient to prove that U −1 is an upward bisimulation induced by D because then, from the closure under union, US is an upward bisimulation induced by D too.
Let qU −1r. Then, from rUq, we have that (r ,... ,r ) −f→ r' with r = r if
1	n	i
and only if (q ,... ,q ) −f→ q' with q = q , r'Uq', and r ≡	q for all j : 1 ≤
1	n	i	j	D	j
j /= i ≤ n. As ≡D is an equivalence and as r'Uq' is equivalent to q'U −1r', we can
write (q ,... ,q ) −f→ q' with q = q iff (r ,... ,r ) −f→ r' with r = r , q'U −1r', and
1	n	i	1	n	i
qj ≡D rj for all j :1 ≤ j /= i ≤ n. We directly see that U −1 matches the definition of an upward bisimulation induced by D.	 
Let us note that the notion of an upward bisimulation induced by the identity relation corresponds to the notion of a forward bisimulation from [9].

Combined Relations for Reducing Tree Automata
Upward simulation equivalences and upward bisimulations alone cannot be used for reducing tree automata as they do not preserve their language. To circumvent this problem, we have to take into account the inducing relation and combine it with the induced upward (bi-)simulation—as we have already mentioned in the previous section, the induced relation is thus used in two different ways.
As one of the main contributions of this work, we are now going to define a new combination operator—we call it a weakening combination operator —over the in- ducing downward simulations and induced upward simulations. Unlike the operators used in previous works [2,1], the new operator allows us to combine any inducing downward simulation (i.e., also a bisimulation or identity) with any induced upward simulation (bisimulation, identity) offering us a broad spectrum of the resulting re- lations.
Moreover, in the previous works, we were randomly computing one relation out of the set of possible language-preserving combined relations. Here, we first prove that there is always a unique maximal combined preorder for a given upward simulation and its inducing downward simulation. In Section 6, we then provide a simple algorithm for computing this maximal preorder. From a practical point of view, using the maximal preorder instead of a random one has in some cases a great impact on the size of the reduced automaton as witnessed by our practical experiments.

A Weakening Combination Operator
We define the weakening combination operator ⊕, which is normally to be applied over an inducing downward simulation and an induced upward simulation, on arbi- trary preorders as follows: Given two preorders H and S over a set Q, for x, y ∈ Q, x(H ⊕ S)y iff (i) x(H ◦ S)y and (ii) ∀z ∈ Q : yHz =⇒ x(H ◦ S)z. 6 Intuitively, a pair e = (x, y) ∈ Q × Q that is in H ◦ S will also appear in H ⊕ S iff after adding it to the preorder H, there is a possibility to supplement the obtained relation H ∪ {e} by other pairs of elements of Q that are in H ◦ S to ensure transitivity and get this way a preorder again.
Lemma 4.1 For any set Q and any preorders H, S ⊆ Q × Q, H ⊕ S is a unique maximal preorder such that H ⊆ H ⊕ S ⊆ H ◦ S.
Proof. Let W = H ⊕ S and C = H ◦ S. 7 Keep in mind that W, H, S ⊆ C and that H and S are reflexive and transitive. We first prove some auxiliary facts for any x, y, z ∈ Q allowing us to derive existence of certain elements of the relations that we are dealing with:
xCy =⇒ xHwSy for some w ∈ Q, which follows directly from the definition of C.
xHyCz =⇒ xCz. From yCz and (I), we have yHwSz for some w ∈ Q. From xHyHw, we have xHw. From xHwSz and from the definition of C, we have xCz.
xWyHz =⇒ xCz, which follows directly from the definition of W .
xCySz =⇒ xCz. From xCy and (I), we have xHwSy for some w ∈ Q. From
wSySz, we have wSz. From xHwSz and (II), we have xCz.
xWyCz =⇒ xCz. From yCz and (I), we have yHwSz for some w ∈ Q. From xWyHw and (III), we have xCw, which together with (I) gives xHvSw for some v ∈ Q. From vSwSz, we have vSz and so vCz (as S ⊆ C), which together with xHv and (II) gives xCz.
Now, we can prove the claim of the lemma. First, we will argue that H ⊆ W . To do this, suppose that xHy for some x, y ∈ Q. We will show that xWy. As H ⊆ C, we have that xCy, which fulfils Condition (i) from the definition of ⊕. To satisfy Condition (ii), we have to show that for arbitrary z ∈ Q such yHz, xCz holds. From transitivity of H and from xHyHz, we have xHz, which implies that xCz when we take into account that H ⊆ C. Thus, even Condition (ii) is fulfilled, and we are obtaining xWy from the definition of ⊕. Hence, we have proved that H ⊆ W . Moreover, the fact that W ⊆ C is trivial as it is a part of the definition of
⊕.
We will now prove that W is a preorder. We first prove by contradiction that
W is transitive. Suppose that there exist x, y, z ∈ Q such that xWyWz, but not

6 Here, H ◦ S is the common composition of relations, i.e., ∀x, y ∈ Q : x(H ◦ S)y ⇐⇒ ∃z ∈ Q : xHzSy.
7 For an easier orientation in the symbols, let us note that we use W for the result of applying the weakening combination operator, C to denote the composition of H and S, H is a preorder which is “hard” in the sense that it has to be included in W , whereas S is “soft” in the same sense.

xWz. Recall that W ⊆ C. From (I), we have xHwSyHvSz for some v, w ∈ Q. From xWyHv and (III), we have xCv. From xCvSz and (IV), we have xCz. From the definition of ⊕, xCz together with not xWz imply that there is a q ∈ Q such that xCzHq, but not xCq. From yWzHq and (III), we get yCq. Then xWyCq, and (V ) gives xCq, which is a contradiction. We have proven that the relation W is transitive. Showing that W is also reflexive is immediate as we already know that H ⊆ W and that H is reflexive. Thus, we have proven that W is a preorder.
Finally, we will show that W is a unique maximal preorder included in C and containing H. It can be easily seen from the definition of ⊕ that any pair (x, y) ∈ C \ W cannot be contained in any preorder P such that H ⊆ P ⊆ C as no relation P such that H ⊆ P ⊆ C and (x, y) ∈ P can be transitive. Thus, W contains all the pairs that can be elements of a preorder included in C and containing H, and therefore any such preorder P is a subset of W . As we have proven that W itself is a preorder, it has to be the unique maximal preorder that includes H and that is itself included in C.	 
Lemma 4.1 is a key result that allows us to define combined preorders and equivalences applicable for reducing the size of tree automata as follows.
Combined Relations for Reducing Tree Automata
Consider a tree automaton A = (Q, Σ, Δ,F ), a downward simulation preorder D on A, and an upward simulation U induced by D. We call the relation W = D ⊕ U −1 a combined preorder and ≡W a combined equivalence. Correctness of using the combined equivalence for reducing the size of tree automata by quotienting is stated in the following Theorem 4.6 that relates the languages of A and A≡W . 8
Within the proof of Theorem 4.6, we make use of the notion of a context. In- tuitively, a context is a tree with “holes” instead of leaves. Formally, we consider a special symbol /∈ Σ with rank 0. A context over Σ is a tree c over Σ ∪ { } such that for all leaves p ∈ c, we have c(p) = . For a context c with leaves p1,... , pn and for trees t1,... , tn, we define c[t1,... , tn] to be the tree t, where
dom(t)= dom(c)  {p1 · p'| p' ∈ dom(ti)}     {pn · p'| p' ∈ dom(tn)},
for each p = pi · p', we have t(p)= ti(p'), and
for each p ∈ dom(c) \ {p1,.  , pn}, we have t(p)= c(p).
In other words, c[t1,... , tn] is the result of appending the trees t1,... , tk to the holes of c. We extend the notion of runs to contexts. Let c be a context with leaves p1,... , pn. A run π of A on c from (q1,... , qn) is defined in a similar manner to a run on a tree except that for a leaf pi, we have π(pi) = qi, 1 ≤ i ≤ n. In other
words, each leaf labelled with  is annotated by one qi. We use c [q ,... ,q ] =π⇒ q
1	n
to denote that π is a run of A on c from (q1,... , qn) such that π(ϵ) = q. The
notation c [q1,... , qn] =⇒ q is explained in a similar manner to runs on trees.

8 Note that contrary to downward simulations, the combined preorders do not have to refine the language inclusion preorder, which is due to the fact that they strongly depend also on the upward simulations, which are not compatible with the language inclusion preorder. Nevertheless, Theorem 4.6 shows that the combined equivalences still preserve the language of the entire automaton when used for collapsing it.

Lemma 4.2 If c[q1,... , qn] =⇒ q and qDr, then there are states r1,... , rn such that for each i with 1 ≤ i ≤ n, qiDri, and c[r1,... , rn] =⇒ r.
Proof. By induction on the height of c. The base case (where c is empty) is trivial. We consider the case where c contains at least one node. We know that
π
c[q1,... , qn] =⇒ q for some π. Let c(ϵ) = f . Furthermore, we know that there

are q' ,... , q'	such that (q' ,... , q' )	f
q, and π(i) = q'
for each i with 1 ≤

1	m	1
m  −→	i

i ≤ m. In other words, the run labels the root with q, and labels the children

of the root with q' ,... , q'
, respectively. This means that for all i : 1 ≤ i ≤ m,

c [q
m
πi	'	th

i  ni−1+1,... , qni ] =⇒ qi where ci is the i	subtree of c, πi is the restriction of
π to ci, n0 = 0, and nm = n.  Since qDr, we know that there are r' ,... , r'
1	m

such that (r' ,... , r' )	f	r and q'Dr'
for each i, 1 ≤ i ≤ m. By the induction

m  −→	i	i
hypothesis, it follows that for each i, 1 ≤ i ≤ m, there are states rni−1+1,... , rni
such that for each j, ni−1 +1 ≤ j ≤ ni, qjDrj and ci[rni−1 +1,... , rn ] =⇒ r'. Hence
i	i
c[r1,... , rn] =⇒ r.	 
Lemma 4.3 If c[q1, q2,... , qn] =⇒ q and qiU ri for some 1 ≤ i ≤ n, then there are states r1,... , ri−1, ri+1,... , rn,r such that qjDrj for each j :1 ≤ j /= i ≤ n, qUr, and c[r1,... , rn] =⇒ r.
Proof. To simplify the notation, we assume (without loss of generality) that i =
1. We use induction on the structure of c. The base case is trivial since the context c consists of a single hole. For the induction step, we assume that c is not
π
only a single hole. Suppose that c[q1, q2,... , qn] =⇒ q for some run π and that
q1U r1. Let p be the parent of the leaf p1 labelled by q1 and let p1,... , pm be its children. Let cp be the subtree of c rooted at p. Notice that for all i, 2 ≤ i ≤ m,

ci[qn
n	π q', where ci is the subtree of c rooted at pi, n
=1 and nm =

i−1+1,... ,q i ] =⇒ i	1
k for some k ≤ n. Let q' = π(p) and let c' be the context c with the subtrees rooted
at p1,... , pm deleted. In other words, dom(c') = dom(c) \  m {pip' | p' ∈ N∗},
c'(p') = c(p') if p' ∈ dom(c'), and c'(p) =  . Observe that c'[q', qk+1,... , qn] =⇒
q and that (q1, q' ,... , q' ) −f→ q' for some f . By the definition of the upward
m
simulation and the premise q1U r1, it follows that there are r' ,... , r' , r' such that
2	m

q' Dr' ,... , q' Dr' , q'Ur', and (r1, r' ,... , r'
) −f→ r'. Since c' is smaller than c, by

2	m	m	2	m
the induction hypothesis, there are rk+1,... , rn,r such that qk+1Drk+1,... , qnDrn
and c'[r', rk+1,... , rn] =⇒ r. For each i, 2 ≤ i ≤ m, we have q'Dr', and thus by
i	i
Lemma 4.2, there are states rni−1+1,... , rni such that for each j, ni−1 +1 ≤ j ≤ ni,
q' Dr' and ci[rn	+1,... , rn ] =⇒ r'. The claim follows immediately.	 
i−1
j	j	i	i
For a state r ∈ Q, a set B ⊆ Q of states, and a relation R ⊆ Q × Q, we write
BRq to denote that there is a q ∈ B with qRr.
Lemma 4.4 For blocks B1,... , Bn, B ∈ Q≡W and a context c, if c[B1,... , Bn] =⇒ B, then there exist states r1,... , rn,r ∈ Q with B1Dr1,... , BnDrn, BUr, and c[r1,... , rn] =⇒ r.
Proof. The claim is shown by induction on the structure of c. In the base case, the context c consists of a single hole. We choose any q ∈ B ∩ F provided that

B ∩ F /= ∅, and any q ∈ B otherwise. The claim holds obviously by reflexivity of D
and U .
For the induction step, we assume that c is not only a single hole. Suppose that
c[B ,... , B ] =π⇒ B for some run π. Let p ,... ,p be the left-most leaves of c with
1	n	1	j
a common parent. Let p be the parent of p1,... , pj. Note that B1 = π(p1),... , Bj = π(pj). Let B' = π(p) and let c' be the context c with the leaves p1,... , pj deleted. In other words, dom(c') = dom(c) \ {p1,... , pj}, c'(p') = c(p') provided
p' ∈ dom(c') \ {p, p1,... , pj}, and c'(p) =  . Observe that c'[B', Bj+1,... , Bn] =⇒
B. Since c' is smaller than c, we can apply the induction hypothesis and con-
clude that there are v, q'	,... , q' , q' such that B'Dv, Bj+1Dq'	,... , BnDq' , BUq',
j+1	n	j+1	n
c'[v, q'	,... , q' ] =⇒ q'. It follows that there are u ∈ B', qj+1 ∈ Bj+1,... , qn ∈
Bn,q ∈ B such that uDv, qUq', and qj+1Dq'	,... , qnDq' . By the definition of
A≡ , there are states q ∈ B ,... , qj ∈ B , and z ∈ B' such that (q ,... ,q ) −f→ z
W	1	1	j	1	j
for some f . Since D ⊆ W and uDv, we get uW v. Since u, z ∈ B', it follows that u ≡W z and hence zWu. From transitivity of W , we get zWv. From the definition of W , there is a state w such that zDw and vUw. By the definition of
the language inclusion preorder and premises zDw and (q1,... , qj) −f→ z, there are
states r ,... ,r with q Dr ,... ,q Dr , and (r ,... ,r ) −f→ w. By Lemma 4.3 and
1	j	1	1	j	j	1	j
premises vUw and c'[v, q'	,... , q' ] =⇒ q', there are states rj+1,... , rn, and r with

'
j+1
Drj+1,... , q' Drn, q'Ur, and c'[w, rj+1,... , rn] =⇒ r. Finally, by transitivity of

D and U , we get qj+1Drj+1,... , qnDrn, qUr. The claim thus holds.	 
Lemma 4.5 If t =⇒ B, then t =⇒ w for some w with BUw. Moreover, if B ∈ F≡W , then also w ∈ F.


Proof. Suppose that t =π  B for some π. Let p ,... ,p 
be the leafs of t, and let

⇒	1	n
π(pi) = Bi for each i : 1 ≤ i ≤ n. Let c be the context that we get from t by
deleting the leaves p ,... ,p . Observe that c[B ,... , B ] =π⇒ B. It follows from
1	n	1	n
Lemma 4.4 that there exist states r1,... , rn,r ∈ Q and q1 ∈ B1,... , qn ∈ Bn,q ∈ B
such that q1Dr1,... , qnDrn, qUr, c[r1,... , rn] =⇒ r, and if B ∩ F /= ∅, then

r ∈ F . By the definition of A≡W
, it follows that there are q'
∈ B1,... , q' ∈

B , and f ,... ,f	such that −f→i	q' for each i such that 1 ≤ i ≤ n.	We
n	1	n	i
show by induction on i that for each i such that 1 ≤ i ≤ n there are states

ui ,... , ui, vi	,... , vi , wi such that q' Dui ,... , q'Dui, qi+1Dvi
,... , qnDvi , rUwi,

1	i	i+1	n
1	1	i	i
i+1	n

and c[ui ,... , ui, vi	,... , vi ] =⇒ wi. The base case where i = 0 is trivial. We
1	i	i+1	n
consider the induction step. Since D ⊆ W and qi+1Dvi+1, we get qi+1W vi+1. Since

qi+1, q'
∈ Bi+1, we have that q'
≡W qi+1 and hence q'
Wqi+1. By transitivity

of W , it follows that q'
W vi+1. By the definition of W , there is zi+1 such that

'
i+1
Dzi+1 and vi+1U zi+1. By Lemma 4.3, there are z1,... , zi, zi+2,... , zn,z with

ui Dz1,... , uiDzi, vi	Dzi+2,... , vi Dzn, wiUz, and c[z1,... , zn] =⇒ z. By transi-
1	i	i+2	n
tivity of D and the premises q' Dui and ui Dzj, we have q' Dzj for each j :1 ≤ j ≤ i.
j	j	j	j
By transitivity of D and the premises qjDvi and vi Dzj, we have qjDzj for each
j : i+2 ≤ j ≤ n. Define ui+1 = zj for j :1 ≤ j ≤ i+1, vi+1 = zj for j : i+2 ≤ j ≤ n,
j	j
and wi+1 = z.

The induction proof above implies that c[un,... , un] =⇒ wn. From the definition
1	n
of the language inclusion preorder and the premises −f→i  q' and q'Dun, it follows
i	i	i

that −f→i
un for each i : 1 ≤ i ≤ n. It follows that t = c[f ,... ,f ] =⇒ wn. By

i	1	n
the definition of U and the fact that r ∈ F if B ∩ F /= ∅, it follows that for all i :1 ≤ i ≤ n, wi ∈ F provided that B ∈ F≡W . Thus, in the claim of the lemma, it suffices to take w = wn.	 

Theorem 4.6 L(A≡W )= L(A) for any tree automaton A and each combined pre- order W.
Proof. The inclusion L(A≡W ) ⊇ L(A) is trivial. Let t ∈ L(A≡W ), i.e., t =⇒ B for some block B where B ∩ F /= ∅. Lemma 4.5 implies that t =⇒ w such that w ∈ F . 

Note that the theorem also covers the case of reducing automata using downward simulations (and bisimulations) alone. Indeed, given any downward simulation D, the identity is always an upward simulation induced by D. Then, the combined preorder D ⊕ id −1 equals D, which means that we can reduce the automaton using
≡D. In particular, this covers as special cases the proofs of correctness of reducing automata using downward bisimulations and simulation equivalences stated in [2].
Corollary 4.7 L(A≡D ) = L(A) for any tree automaton A and each downward simulation preorder D.

Variants of Combined Relations and Their Properties
Theorem 4.6 and Lemmas 3.2 and 3.4 allow us to consider quite a large spectrum of relations suitable for reducing tree automata. We now examine properties of the relations from this spectrum that arise when we consider the identity, the maximal downward bisimulation, and the maximal downward simulation as the inducing relation D for both the maximal upward bisimulation and upward simulation.
Our notation for the various types of combined equivalences that we consider consists of two parts: a relation symbol and an additional symbol above the relation symbol. The relation symbol denotes the type of the inducing downward relation. Namely, = denotes the identity,  denotes the maximal downward bisimulation, and ∼ the maximal downward simulation. The additional symbol then denotes the type of the upward relation. We use • for the maximal upward bisimulation and
for the maximal upward simulation. No additional symbol corresponds to the maximum equivalence embedded in the downward relation itself—the downward (bi-)simulations can be viewed as compositions where the role of the upward relation
◦
is played by the identity. For example,  denotes the relation ≡D⊕U −1 where D
is the maximal downward bisimulation and U is the maximal upward simulation induced by D. In what follows, we will implicitly consider all the downward and upward (bi-)simulations that we will be dealing with to be the maximal ones.

◦	◦	◦
=		∼
•	•	•
=		∼
~
 
=
Fig. 1. Coarseness of various types of combined equivalences

A Partial Ordering of the Combined Relations wrt. their Coarseness
From the definition of a combined preorder, it clearly follows that, for a fixed in- ducing relation D, if we are choosing the type of the upward relations U from the strongest one to the coarsest one, i.e., starting from the identity and going through the upward bisimulation induced by D to the upward simulation induced by D, we obtain coarser and coarser combined preorders D ⊕ U −1.
On the other hand, if the inducing preorder D is growing, from the definition of the upward (bi-)simulation, we can see that the maximal upward (bi-)simulation U induced by D and thus also the relation D ◦ U −1 are growing too. But, when having D ◦ U −1 computed and then computing the preorder D ⊕ U −1 from it, the relation D acts as a restriction. A bigger relation D can cause that more pairs are violating Condition (ii) from the definition of ⊕. In general, having two downward simulation preorders D1 and D2, we are guaranteed that the maximal upward (bi-)simulation U1 induced by D1 is included in the maximal upward (bi-)simulation U2 induced
by D2. Therefore, we know that D1 ◦ U −1 ⊆ D2 ◦ U −1, but the combined preorders
1	2
D1 ⊕ U −1 and D2 ⊕ U −1 can be incomparable. 9
1	2
Based on these observations, we obtain the partial ordering of all the considered
types of combined equivalences according to inclusion which is depicted in Figure 1. For an automaton A, we denote by ≡(A) the combined equivalence of type ≡ on A. In the figure, the line from ≡1 up to ≡2 means that for any automaton A, ≡1(A) ⊆
≡2(A). It is not hard to find an automaton A showing that all these relationships are strict, i.e., such that for each of the edges in the figure, ≡1(A) Ç ≡2(A). We construct such an automaton in Example 5.1.
Example 5.1 Let Q = {q, r, s, t, u, v, w, x, y, z} be a set of states and let Σ be a ranked alphabet such that Σ0 = {l} and Σ1 = {a, b, c}. The automaton A = (Q, Σ, Δ1, {x}) proves strictness of the relations in Figure 1. For each two types of relations from Figure 1 such that ≡2 is above ≡1, ≡1(A) Ç ≡2(A) holds. The transition relation Δ1 is depicted in Figure 2(a). In the table below there are stated the appropriate combined equivalences for all the combinations of the considered types of inducing and induced relations. For each type of combination, we list

9 Although, in our experiments, the former one usually is included in the latter one.

nontrivial equivalence classes of the resulting combined equivalence:

◦
=: {q, r, s}
•
=: {r, s}

  : {t, u}, {q, r, s}
•
  : {t, u}, {r, s}

∼: {t, u, v}, {q, r, s}, {x, z}
•
∼: {t, u, v}, {r, s}

=:	 : {t, u}	∼: {t, u, v}
It is now easy to check that all the inclusions from Figure 1 are strict for the automaton A.	 
To complete the picture, we need to show that the types of combined relations that are not connected in Figure 1 are really incomparable. In other words, that for each pair ≡1, ≡2 of types of combined equivalences that are not connected in Figure 1 there exists an automaton A such that neither ≡1(A) ¢ ≡2(A) nor ≡1(A)  ≡2(A). We construct such automata within Example 5.2.
Example 5.2 Let Q = {q, r, s, t, u, v} be a set of states and let Σ be a ranked alphabet such that Σ0 = {l} and Σ1 = {a, b, c}. All the incomparability results show up taking automata A1 = (Q\{v}, Σ, Δ2, {u}) and A2 = (Q, Σ, Δ2 ∪ {v −a→ q}, {u}) where the transition relation Δ2 is depicted in Figure 2(b). One can easily check
◦
that =(A1) and =(A1) define just one nontrivial equivalence class {r, s} and thus
◦	•	◦
they are incomparable with  (A1), ∼(A1), ∼(A1) that define only one nontrivial
equivalence class {q, r}. In the case of the automaton A2, the added transition
v −a→ q distinguishes the downward simulation from the downward bisimulation.
◦
Analogically as for A1, we have that  (A2) and  (A2) define just one nontrivial
◦
equivalence class {r, s} and thus they are incomparable with ∼ (A2) and ∼(A2) that
define only one nontrivial equivalence class {q, r}. This gives all the incomparability relationships.	 
According to our experiments presented in Section 7, the reduction capabilities are rising when we move in Figure 1 not only in the bottom-up direction (according to the edges), but also in the left-right direction (as though within a full diamond).



w



q	a	y

r	x

s

w z
t u
v


x	t


q

r	u

s

(a) Δ1
q a	r
s  a	t	a	u
(c) Δ3
(b) Δ2


Fig. 2. Transition relations of automata proving the non-inclusion relationships from Figure 1, and of an automaton proving that one cannot use within ⊕ preorders included in the language inclusion preorder that are not downward simulations.

As a trade-off, the computational complexity of constructing the relations is rising in the same way from the bottom to the top and from the left to the right.

Impossibility of Relaxing the Need of Downward Simulations
It is easy to see that when not considering combined relations (and when not thinking of the computational complexity), one can replace the use of downward (bi-)simulations in reducing the size of tree automata by a use of any preorder which is included in the so called language inclusion preorder LP ((q, r) ∈ LP ⇐⇒ L(q) ⊆ L(r)). A natural question comes forward: Is it also possible to induce (and combine by ⊕) an upward (bi-)simulation with any preorder included in LP (not only with downward simulations)? Here, we give a negative answer. Not all pre- orders included in LP can be used within the operator ⊕ for reducing automata. We prove this claim by the following counterexample.
Example 5.3 Consider an automaton A = (Q, Σ, Δ3 ∪ Leaves, F ) where Q =
{q, r, s, t, u}, Σ0 = {l}, Σ1 = {a}, Δ3 is depicted in Figure 2(c), Leaves = {−→l	x |
x ∈ Q}, 10 and F = Q. Let us choose the relation R = id ∪ {(q, r), (r, t), (q, t)}, which is apparently contained in LP , as the inducing preorder. 11 We can choose the relation U = id ∪ {(q, t)} as the upward simulation preorder induced by R. Then, we obtain R ◦ U −1 = R ∪ U −1 ∪ {(r, q)}. The pair (r, q) is present in R ◦ U −1 because of (r, t) ∈ R and (q, t) ∈ U . Let W = R ⊕ U −1 be the combined preorder. R ◦ U −1 itself is already a preorder, and therefore W = R ◦ U −1. We see that we have obtained an equivalence class {q, r} of ≡W which is bad as it implies that
a
the quotient automaton A≡W  contains the rule {q, r} −→ {q, r}. This definitely
changes the language of the original automaton A since no cycles were present in
A.
Observe that if we take a downward simulation as the inducing preorder, such a situation does not arise. The problem above is caused by the presence of (r, q) in R ◦ U −1, which is enabled by (r, t) ∈ R. If R was a downward simulation containing (r, t), then R would have to contain even (q, s) from the definition of a downward simulation. So, we would get r(R ⊕ U −1)qRs which according to Condition (ii) of the definition of ⊕ enforces r(R ◦ U −1)s. However, r(R ◦ U −1)s does not hold for any pair of an inducing downward simulation R and an induced upward simulation U (not even when one considers the maximal ones), and so the pair (r, q) is not present in any combined preorder, and we are never allowed to collapse q and r. 

A Note on Word Automata
We note that all the above results carry over to word automata. The inclusion properties from Figure 1 hold for word automata too since they can be seen as a special case of tree automata. Moreover, our automata examples proving strictness

10 The set of rules Leaves is present so that the language of the automaton is not be empty.
11 As we deal here only with unary and leaf symbols, upward (bi-)simulation does not depend on the inducing relation.

of the relationships and incomparability relationships are built using just leaf and unary rules, and so they are valid for word automata as well.

Computing the Proposed Relations
Below, we first briefly discuss methods for computing downward and upward (bi-)simulations proposed in earlier works. Then, we propose an algorithm for computing the combined relations and analyse its complexity. For the rest of the section, let us fix a tree automaton A = (Q, Σ, Δ,F ) and let n = |Q|, m = |Δ|, l = |Σ|.
Computing Downward and Upward (Bi-)Simulations
The problem of computing (bi-)simulations over tree automata is addressed in [2,1,9]. In [2,1], a quite general method for computing tree (bi-)simulations via transforming this problem to special instances of the classical problem of comput- ing (bi-)simulations over labelled transition systems (LTS) is proposed. Classical (bi-)simulation algorithms like [11,12] are then applied to the LTSs obtained from the translation.
As studied in [1], using the above approach, we obtain algorithms for comput- ing the maximal downward and upward bisimulations in time O(rˆ3 m log n) and O(m log(n + l)+ T (D)), respectively, where T (D) denotes the complexity of com- puting the inducing relation D.
The case of tree simulations is considered in [2], where we obtain algorithms with the following complexities when using the translation to LTS: Let D be the maximal downward simulation on A and let |Lhs (A)/≡D| be the size of the partitioning of the left-hand sides of the transition rules according to D. D can be computed in time O((l + rˆ)) · |Lhs |· |Lhs/≡D|+ m · |Lhs/≡D|), which can be roughly approximated by O((rˆ+l) m2). Let U be the maximal upward simulation on A induced by a preorder D, we denote the set of environments partitioned with respect to U as Env/≡U . Assuming that T (D) is the time of computing the inducing relation D, U can be computed in time O((l |Env|+ rˆm) |Env/≡U |+ rˆ2 m log |Env|+ T (D)), which can be roughly approximated by O(l rˆ2 m2 + T (D)).
Let us add that specialised algorithms for computing the downward bisimula- tion and upward bisimulation induced by the identity were proposed in [9]. These algorithms run in time O(rˆ2 m log n) and O(rˆm log n), respectively.

Computing the Combined Relations
Given an inducing downward simulation D and an upward simulation U induced by D, the combined preorder W = D⊕U −1 can be easily computed by simply following its definition. It is sufficient to start by computing the relation C = D ◦ U −1 and then just erase all the elements of C (which are pairs of elements of the base set Q) that break Condition (ii) from the definition of ⊕. Using suitable data structures, this computation starting from the relations U and D can be implemented in time

O(min{|D|· |Q|, |U |· |Q|}) as follows.
We encode a relation ρ on Q as an array indexed by elements of Q of lists of elements of Q. A state q is present in a list with index r iff (r, q) ∈ ρ. Note that given a boolean matrix representation of the relation, the “array of lists”-representation can be derived in time O(|Q|2). Note also that as U and D are reflexive, we have that |U |, |D| ≥ |Q| and thus |Q|2 ≤ min{|D|·|Q|, |U |·|Q|}. Let arrays of lists D, U−1 encode relations D, U −1.
The relation C = D ◦ U −1 represented by a Boolean matrix C can be computed in the following way: (1) Initialise all entries of C to false . (2) For each q ∈ Q, pass through all elements of the list D[q], and for each r ∈ D[q], pass through all elements s of U−1[r], and set C[q, s] to true. This procedure takes time O(|{(q, r, s) | (q, r) ∈ D ∧ (r, s) ∈ U −1}|) ⊆ O(min{|D|· |Q|, |U |· |Q|}).
Then we compute a Boolean matrix representation W of the relation W = D ⊕ U −1 as follows: (3) We initialise W as a copy of the matrix C (representing D ◦ U −1), and in the subsequent Step (4), we erase from W all the pairs of elements of Q that break Condition (ii) from the definition of ⊕. In Step (4), we proceed in the following way: For all q ∈ Q, for all r ∈ D[q], for all s ∈ U−1[r], if not C[q, s] (i.e., (q, s) /∈ D ◦ U −1), then W[q, s]= false. This gives us the set D ⊕ U −1 represented by the matrix W. The complexity of Steps (3), (4) is in O(|{(q, r, s) | (q, r) ∈ D ∧ (r, s) ∈ U −1}| + |{(q, r, s) | (q, r) ∈ U −1 ∧ (r, s) ∈ D}|), which is again in O(min{|D|· |Q|, |U |· |Q|}).

Experiments
We have implemented our algorithms in a prototype tool written in Java. We have used the tool on a number of tree automata from the frameworks of regular tree model checking (RTMC) and abstract regular tree model checking (ARTMC) [6,4,7,5].
RTMC is the name of a family of techniques for analysing infinite-state sys- tems such as parameterised networks of processes, systems with queues, stacks, unbounded integers, and/or dynamic linked data structures like lists or trees. In RTMC, states are represented by trees, sets of states by tree automata, and tran- sitions by tree transducers (or, sometimes, also by some specialised operations on tree automata). ARTMC is a combination of RTMC and the abstract-check-refine paradigm which usually greatly improves the efficiency of the technique. Most of the algorithms in the frameworks of both RTMC and ARTMC rely crucially on ef- ficient automata reduction methods since the size of the generated automata often explodes, making computations infeasible without a reduction.
The tree automata that we have considered in our experiments arose within various computations within the frameworks of RTMC and ARTMC. Our experi- mental evaluation was carried out on an AMD Athlon 64 X2 2.19GHz PC with 2.0 GB RAM. We have compared the size of tree automata after reducing them with all the different reduction techniques considered in this paper.
Table 1 shows the computation time and the reduction (in percent) for the dif-

Table 1
The obtained reduction in percent and the computation time in seconds for the various considered relations applied for reducing TA obtained from RTMC and ARTMC case studies. The size of the TA is the number of their states plus the number of their transition rules.

ferent relations within the considered framework and illustrates that we have really obtained a wide spectrum of relations differing in their reduction capabilities and
◦
computational complexity. As can be seen from the results, ∼ gives the best reduc-
tion in all experiments, but it also suffers from a high computation time. Combining simulations and bisimulations does not give the same amount of reduction as the combined simulation, but the computation time is lower and the reduction is better
•
than  . Note that no attempt to optimise the implementation of any of the rela-
tions was done, and therefore the computation times could probably be much lower with an optimised implementation for all of them.

Conclusions and Future Work
We have presented a uniform framework for deriving equivalence relations suitable for reducing tree automata based on combining upward and downward simulations and bisimulations. The framework is based on two main ingredients: a new notion of upward (bi-)simulations parameterised by any downward (bi-)simulation and a new operator for combining upward and downward (bi-)simulations. The framework ex- plains in a uniform way various previously obtained results [9,2,1] and also yields multiple new combined relations for reducing tree automata that mix in various degrees advantages of the various upward and downward simulations and bisimula-

tions. This step is motivated by giving users of tree automata a finer choice between the reduction capabilities and computational costs of the relations to be used for reducing tree automata.
We have established a partial ordering of the obtained combined relations ac- cording to their reduction capabilities, and showed that some of them are also in- comparable. Moreover, we have performed a number of experiments with automata from the area of (abstract) regular tree model checking that show a practical ap- plicability of the obtained relations and allow us to conclude that the considered relations really offer a fine choice of balance in the trade-off between reduction capabilities and computational requirements.
Furthermore, the proposed weakening combination operator on which our frame- work is based yields a significantly more efficient way of combining upward and downward (bi-)simulations than the previously used random combination algo- rithms.
The proposed framework is built on quite general principles and we believe that it can be extended to more advanced types of automata such as guided tree automata, nested word automata, or hedge automata that find their use in many applications in formal verification, decision procedures of various logics, structured document processing, or natural language processing. Reduction of automata from some of such classes has already been considered in the literature (e.g., in [8], the author proposes a bisimulation-based minimisation of weighted word automata, and a use of bisimulations for reducing weighted tree automata is considered in [10]).
From the practical point of view, it is also interesting to investigate more ef- ficient techniques of computing the (bi-)simulation relations, e.g., by computing them in a symbolic way (for symbolically encoded automata). Furthermore, it can be interesting to explore more deeply the principles of the proposed combination of downward and upward (bi-)simulation relations. One can, for instance, think of defining still weaker types of relations preserving the language of tree automata by using the combined relations repeatedly as inducing relations.
Acknowledgement. We would like to thank Ahmed Bouajjani for fruitful discussions on the subject of the paper.

References
P.A. Abdulla, A. Bouajjani, L. Hol´ık, L. Kaati, and T. Vojnar. Composed Bisimulation for Tree Automata., 2008. Accepted at CIAA’08.
P.A. Abdulla, A. Bouajjani, L. Hol´ık, L. Kaati, and T. Vojnar. Computing Simulations over Tree Automata: Efficient Techniques for Reducing Tree Automata. In Proc. of TACAS’08, LNCS. Springer, 2008. An extended version appeared as the technical report FIT-TR-2007-001 of FIT, Brno University of Technology.
P.A. Abdulla, J. H¨ogberg, and L. Kaati. Bisimulation Minimization of Tree Automata. In Proc. of CIAA’06, volume 4094 of LNCS, pages 173–185. Springer, 2006.
P.A. Abdulla, B. Jonsson, P. Mahata, and J. d’Orso. Regular Tree Model Checking. In Proc. of CAV’02, volume 2404 of LNCS. Springer, 2002.
A. Bouajjani, P. Habermehl, A. Rogalewicz, and T. Vojnar. Abstract Regular Tree Model Checking.
ENTCS, 149:37–48, 2006.

A. Bouajjani and T. Touili. Extrapolating Tree Transformations. In Proc. of CAV’02, volume 2404 of
LNCS. Springer, 2002.
Ahmed Bouajjani, Peter Habermehl, Adam Rogalewicz, and Tomas Vojnar. Abstract Regular Tree Model Checking. In Proc. of INFINITY’05. Published in ENTCS 149(1), 2006.
Peter Buchholz. Bisimulation relations for weighted automata. Theor. Comput. Sci., 393(1-3):109–123, 2008.
Johanna H¨ogberg, Andreas Maletti, and Jonathan May. Backward and Forward Bisimulation Minimisation of Tree Automata. In Proc. of CIAA’07, volume 4094 of LNCS, pages 109–121. Springer, 2007.
Johanna H¨ogberg, Andreas Maletti, and Jonathan May. Bisimulation minimisation for weighted tree automata. In Tero Harju, Juhani Karhum¨aki, and Arto Lepist¨o, editors, Proc. 11th Int. Conf. Developments in Language Theory, volume 4588 of LNCS, pages 229–241. Springer, 2007.
R. Paige and R. Tarjan. Three Partition Refinement Algorithms. SIAM Journal on Computing, 16:973–989, 1987.
F. Ranzato and F. Tapparo. A New Efficient Simulation Equivalence Algorithm. In Proc. of LICS’07. IEEE CS, 2007.
