Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 51–66
www.elsevier.com/locate/entcs

Open Maps in Concrete Categories and Branching Bisimulation for Prefix Orders
H. Beohar1,2
Theoretical Computer Science Group Universit¨at Duisburg-Essen Duisburg, Germany
P.J.L. Cuijpers3
Dept. of Mathematics and Computer Science Technische Universiteit Eindhoven Eindhoven, The Netherlands

Abstract
Open maps, as introduced in concurrency theory by Joyal, Nielsen and Winskel, provide an abstract way to define functional bisimulations across a wide variety of models of computation (like labelled transition systems, event structures, etcetera). Furthermore, the existence of a span of open maps characterises the well-known relational definition of bisimulations found in the literature associated with these models of computation. However, in our working category of prefix orders (in which the objects represent the sets of executions generated by arbitrary dynamical systems) the open maps do not immediately result in functional bisimulations and the existence of a span of open maps does not result in an equivalence. This is rather surprising, since prefix orders are mere generalizations of (discrete) execution trees, for which the open map approach is known to work. After taking a closer look at the definition of open map, we show in this paper that the issue can be remedied by considering prefix orders as a concrete category and reinterpreting
the definition of open-map in this light. As a bonus, the choice of a path-category on which the notion of open-map relies becomes a natural one, namely the subcategory of embeddings. While the existence of spans still does not result in an equivalence, it is shown that the existence of cospans does. In fact, we present a characterisation of the notion of branching bisimulation by van Glabbeek and Weijland which, to the best of our knowledge, was not studied in the framework of open maps before.
Keywords: Open maps, Prefix orders, Branching bisimulation, Concrete categories.


Introduction
Since van Glabbeek’s work [20] on comparative concurrency semantics, we are aware of the many ways in which different states of a labelled transition system can be

1 Thanks goes to Paul Taylor for providing his macro to neatly draw commutative diagrams in LATEX.
2 Email: harshbeohar@gmail.com
3 Email: p.j.l.cuijpers@tue.nl

http://dx.doi.org/10.1016/j.entcs.2015.12.005
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

considered behaviourally equivalent (resulting in the well-known van Glabbeek spec- trum). In their seminal paper [14], Joyal, Nielsen and Winskel proposed an abstract definition of strong bisimulation using the language of category theory and thus embarked a way to capture behavioural equivalences in a uniform framework. In particular, bisimilarity through spans (cospans) of open maps is defined as the exis- tence of a span (cospan) of open maps between two objects, where a map o of M is open (denoted ◦ )) ) whenever, for any map p in a subcategory P (denoted ⊂ +) ) and maps s and m from M such that the outer square commutes (i.e., s · p = k · m),
B	s	) D

p +
∪	◦
A 	) C
m

there exists a map k in M (existence emphasised by dashed arrow) making the two inner triangles commute (i.e., k · p = m and o· k = s). These arrow-notations will be overloaded later in an obvious way, when discussing the concrete categorical variant of openness.
Taking M as the category of labeled transition systems with transition preserv- ing maps between them, and P as the category of path-extensions (containing all transition preserving maps between chains of transitions) Joyal et al. showed that bisimilarity through spans of open maps coincides with the familiar notion of strong bisimulation from concurrency theory [15]. Subsequently, bisimilarity through spans or cospans of open maps has been shown to coincide with useful notions of bisimu- lation in many alternative models of behaviour as well (see, e.g., [3,9,11,12]).
Despite the generality offered by the open map framework [13], it suffers from two limitations. Firstly, there is as yet no uniform treatment of weak equivalences from the van Glabbeek spectrum (see [17]). Most work on weak equivalences deals with the notion of weak bisimulation (e.g. [3,9]) and seems to rely on first saturating (merging) the so-called invisible steps of the transition systems under study and then instantiating the strong bisimilarity on the saturated versions. As it is well known from [19], such a saturation method of the invisible steps is not sound with respect to branching bisimulation equivalence; thus, the techniques developed in [3,9] fall short in characterising branching bisimulation equivalence. Secondly, in order for bisimilarity through spans of open maps to result in an equivalence, the category M must have pullbacks, which can be a difficult condition to obtain (see [7,16]).
Surprisingly, in our own research [4,5] on describing behavioural systems as prefix ordered sets of executions, the definitions of branching bisimulation arose naturally via a different path, but we had trouble to apply the open map framework of [14] even for strong bisimulation. To be precise, there was no suitable choice of the subcategory of paths such that open maps would result in the usual notion of functional bisimulation (cf. [14, Proposition 1]).

In our attempts to remedy this, we discovered that reinterpreting the above diagram in the context of concrete categories leads to many new insights. Firstly, it allows us to define functional bisimulations in the concrete category of prefix orders with partial orders as a base category. Secondly, the natural choice for the subcategory P of paths turns out to be the subcategory of embeddings. And thirdly, the existence of cospans of these embedding-open maps turns out to coincide with branching bisimulation when the prefix orders are the sets of runs generated by a labelled transition system. Finally, the reinterpretation comes with a flavour of syntax and semantics, in which we consider morphisms in the concrete (base) category to be implementations (observations).
The approach we take in this paper towards re-evaluating an existing cate- gorical notion is not uncommon. In many categories, for example, the notion of monomorphism is an effective way to capture the idea of a ‘subobject’, but in con- crete categories it often turns out that the notion of ‘embedding’ (a special kind of monomorphism) is to be preferred. In a similar vein, we hope that our adaptation of the notion of open map will result in a more widely applicable notion of ‘reflect- ing extensions’. The fact that we obtain embeddings as a natural choice for the subcategory of path-extensions is a hint that this may indeed be the case.
In the next section, we re-introduce the notion of open maps in the context of concrete categories. We re-emphasise the fact that preservation of open maps by pull-backs or push-outs is sufficient to guarantee that bisimilarity through spans or cospans, respectively, is an equivalence, and we show that in case there are ‘enough’ open maps, there is an alternative characterisation of open map that may appeal to the reader’s intuitions on bisimulation. Sadly, despite some effort, we did not find a nice categorical characterisation under which pull-backs and push-outs preserve open maps, so this will still remain to be proven for each category separately. In particular, the result of [14] that the existence of pullbacks suffices to guarantee equivalence does not carry over to the concrete setting straightforwardly. In section 4, we recall the category of prefix orders from [4,5,8] and prove that embedding- open maps are functional bisimulations and that pushouts preserve open maps in this category so that bisimulation through cospans is an equivalence. Finally, in section 5 we prove that the existence of cospans in fact coincides with branching bisimulation if the executions in the prefix order are generated by labeled transition systems. In section 6 we give some concluding remarks and suggestions for future.

Open maps in concrete categories
Let us start by adapting the notion of open map from [14] in the setting of concrete categories [1]. For this, we begin by recalling the following fundamental definition.
Definition 2.1 A category P is a subcategory of M if every morphism or object of
P is a morphism or object of M, respectively. A category M is concrete over a base

category S if there exists a faithful functor M
|.|
===
S, i.e., for any two morphisms

f, g : A → B from M we find that |f| = |g| implies f = g.

In this paper, by ‘a concrete category with faithful functor M
|.|
==== S’, we

tend to think of the objects of M as concrete models of behaviour and the objects of S as semantic models of behaviour. A morphism A f) B of M represents a way of implementing the behaviour of B (the specification) as a behaviour A (the implementation). On the semantic level, a morphism C g) D describes how the behaviour of C can be observed as a part of the behaviour of D.
Furthermore, in [14], the objects of the subcategory P of M represented a collec-
tion of path-extensions which needed to be preserved, but in this paper we simply think of them as arbitrary behavioural extensions, achieved through implementa- tion. We emphasise that extensions are concrete models, meaning intuitively that we are only interested in preserving behaviour that can be described as objects of M and not necessarily in all semantic behaviour that may occur in S. Informally, a P-open map X ◦ )o) Y says that if any observed behaviour of X has a concrete extension of interest (i.e. from P) observed in Y, then this extension can be observed in X as well (although it is not necessarily part of the implementation of X). Thus, in short, o reflects all the concrete extensions from P.

|B|	s ) |D|

ˆ
|p| +
∪
ˆ
|o|
◦

|A| 	) |C|
m


A map o from M is P-open if for every extension p from P and maps m, s from S with s · |p| = |o|· m, there exists a map k from S that makes the diagram commute.
A	B	A	B
C	C


Two objects A and B from M are P-bisimilar through spans if there exists a span of P-open maps from M between them.
Two objects A and B from M are P-bisimilar through cospans if there exists a cospan of P- open maps from M between them.

Fig. 1. Concrete definition of bisimulation through spans and cospans of open maps

Definition 2.2 [Open map] Given a concrete category with faithful functor

|.|
M ===
S and subcategory P of M, a map o from M is called P-open (denoted

 )) ) if for every p from P and maps m, s from S such that s · |p| = |o|· m (i.e. the outer square in diagram 1a commutes in S) there exists a map k from S such that k · |p| = m and |o|· k = s (i.e. the inner triangles in diagram 1a commutes as well). Two objects A and B from M are P-bisimilar through spans, denoted
A aP B, if there exists a span of P-open maps between them, i.e. if there exists

an object C in M and P-open maps C ◦ f)) A and C ◦ g)) B, as in Figure 1b. They are P-bisimilar through cospans, denoted A ar B, if there exists a cospan of P-open maps between them, i.e. if there exists an object C in M and P-open maps A ◦ )f) C and B ◦ )g) C, as in Figure 1c.
Obviously, our concrete definition coincides with the one in [14] when M = S and the faithful functor is the identity. This means that the only ‘new’ part in our definition is the distinction between the use of concrete and base maps. Just like in [14], open maps form a subcategory of M.

Theorem 2.3 Given a concrete category with faithful functor M
|.|
=== S and sub-

category P of M, every identity in M is P-open, and if A ◦ )p) B and B ◦ )q) C
are P-open maps, then so is their composition q · p.
Moreover, if pullbacks (pushouts) preserve open maps than bisimulation through spans (cospans) is an equivalence, which follows easily from diagram chasing.
Definition 2.4 Given any category M and a cospan X	f) Z (g	Y, a span

X (h	P	k) Y is a pullback if f
· h = g ·
k and for any span X (h′	Q	k′) Y

with f · hj = g · kj there exists a unique map Q	u) P such that h · u = hj and
g · u = gj. Dually, given a span X (f	Z	g) Y, a cospan X	h) P (k	Y is a

pushout if h · f = k · g and for any span X
h)′
Q (k′
Y with hj
· f = kj
· g there

exists a unique map P	u) Q such that u · h = hj and u · g = gj.
Theorem 2.5 (Bisimulation equivalence through spans or cospans) In	a

concrete category with faithful functor M
|.|
==== S, bisimulation through spans is

an equivalence if every cospan of open maps X ◦ f)) Z ((g ◦ Y has a pullback X ((h ◦ P ◦ )k) Y consisting of open maps. Dually, bisimulation through cospans is an equivalence if every span of open maps has a pushout of open maps.
Joyal et al. showed that in a category where all cospans have pullbacks also all open cospans have open pullbacks [14]. Therefore, in the original definition, bisim- ilarity through spans is an equivalence in all categories that have pullbacks. Re- versely, existence of pushouts is not sufficient to guarantee that bisimilarity through cospans is an equivalence.
In our new interpretation over concrete categories, this result is not so easily repeated. We have found some conditions under which bisimilarity through spans is an equivalence, but they involve the existence of retracts in the base category and were not very ‘elegant’. Furthermore, it turns out that our working category of choice, prefix orders with partial orders as a base category, does not satisfy those properties. Therefore we left those results out of the current presentation. In fact, in Section 4 we show that bisimilarity through spans turns out not to be an equivalence at all, even though pullbacks do exist in this category. On the other hand, bisimilarity through cospans does turn out to be an equivalence, even though we do not have a fully category theoretic proof for this, yet.

Embeddings as path extensions
In concrete categories, the natural notion of ‘extension’ is usually considered to be that of an embedding. And as it turns out, the subcategory of embeddings is a natural choice for the category P.
|.|	f
Definition 3.1 Given a concrete category M ===) S,a map A ⊂ +) B from M is an embedding, and B is called an extension of A if:
(underlying monos) for all maps g, h of S with |f|· g = |f|· h we find g = h;
(initial ) for any g of S and h of M with |h| = |f|· g there is a gˆ of M with |gˆ| = g.
We will denote embedding-bisimilarity though spans simply by as and embedding- bisimilarity through cospans by ac.
In [1], embeddings where also called extensions, which lead us to research the possibility of using embeddings as the subcategory of path-extensions. But we were convinced of being on the right track when we discovered the similarity between the definition of P-open map and that of P-injective objects defined in [1]. In particular, the observation in that an object is an absolute retract if and only if it is an injective object in any category that has enough injective objects (see Proposition 9.10 in [1] for the original definitions) turned out to have a nice translation to the setting of open maps as well.
The following definitions and theorems are direct adaptations of those in [1], and the proofs are completely analogous.


X	f	) Z
|X|	|f| ) |Y|

∩ ˆ
|p| + r
v
Y	|Z|


There are enough r-open maps when every map can be split into an extension and a r-open map.
A map has absolute retractability if every extension of its source has a base retract.

Fig. 2. If there are enough open maps, then open maps are precisely the absolute retractable maps.


Definition 3.2 Given a concrete category M
|.|
==== S and subcategory P of M,

we say that M has enough P-open maps if for every map X	f) Z there exists an
p	o
extension X ⊂ +) Y from P and a P-open map Y ◦ )) Z such that o · p = f .

Definition 3.3 Given a concrete category M
f
|.|
==== S and subcategory P of M,
p

a map X  ) Y has absolute P-retractability if for any extension X ⊂+) Z and map |Z| g) |Y| of S with g · |p| = |f|, there is a map |Z| r) |X| of S such that r · |p| = id and |f|· r = g.

Theorem 3.4 In a concrete category M
|.|
===
S and subcategory P of M, if M has

enough P-open maps then a map X	f) Y is P-open iff it is absolute P-retractable.
Interpreting this theorem using the view on concrete categories that concrete morphisms represent implementations and base morphisms represent observations, and especially considering P as the subcategory of embeddings, we see that in a category with enough open maps, a map A f ) B is open if and only if every extension of the behaviour of A that is observable within B is already observable within A. In other words, the behaviour of A is a complete representation of all observable behaviour in B.
Another nice result on our concrete definition of open map, is that all open maps are epimorphisms under the assumption that the faithful functor preserves epimorphisms and the initial object of a category. In fact, all open maps are retracts in the base category.

Definition 3.5 Given a category M,a map e is an epimorphism (denoted
f
if for any pair of maps B  ) C with f · e = g · e we find f = g.
g
)e) )

Definition 3.6 Given a category M, an object 0 is called initial if for any object X

there isa unique map0   ) X. A concrete category with faithful functor M
preserves the initial object of M if |0| is also initial for S.
|.|
=== S

Definition 3.7 Given a concrete category M
f →)
|.|	f
=== S a map X	Y in M is a
→

base retract if there exists a map |Y|
|X| in S such that |f|· f
= id .

Theorem 3.8 (Embedding-open maps are base retracts) Given a concrete

category M
|.|
=== S, if M has an initial object 0 and the faithful functor preserves

it, then every embedding-open map is a base retract and an epimorphism.
Proof. For any embedding-open map X f) Y consider |0|  n) |X|, m = id and
|0| p) |Y|. Since |0| is initial it has no incoming arrows except isomorphisms, hence p is an embedding. This gives us a map |Y| k) |X| that makes the diagram in figure 1a commute, hence k is a base retract for f in S, and because any retract
g
is an epimorphism, f is an epimorphism in S. Finally, for any Y  ) Z with
h
g · f = h· f we find |g|· |f| = |g · f| = |h · f| = |h|· |f|, so |h| = |g| and by faithfulness of |.| we have h = g. Therefore f is an epimorphism.	2
Prefix orders
In [4,5] we argued that any dynamical system, be it discrete, continuous, or hybrid, can be considered as a set of executions under their natural prefix ordering, and we showed how notions like refinement, bisimulation, and asynchronous product arise naturally as history preserving maps, cospans of history and future preserving

maps, and the categorical product on history preserving maps. We decided to choose history preserving maps as the natural notion of morphism for this category because of these results.
Definition 4.1 A partial order ⟨U, ≤⟩ is a set U equipped with a reflexive, tran- sitive and anti-symmetric relation ≤⊆ U × U. A preﬁx order is a partial order satisfying:
downward total : ∀x,y,z∈U (x ≤ z ∧ y ≤ z) ⇒ (x ≤ y ∨ y ≤ x).
A function f : U → V between two partial orders is order preserving if for all x ≤ y we find f (x) ≤ f (y), and we denote the category of partial orders with order preserving maps between them by Pos. Furthermore, we write x− = {y | y ≤ x} for the downward closure, or history, of a point x ∈ U in a partial or prefix order, and write f (A)= {f (a) | a ∈ A} to lift a function to sets. Then, a function f : U → V between prefix orders U, V is said to be
history preserving if ∀x∈U f (x)− = f (x−).
We write Pfx for the category of prefix orders and history preserving functions between them.
In order to define functional bisimulation on prefix orders without the use of category theory, we look at paths and their continuations explicitly.
Definition 4.2 A subset P ⊆ U is a path in a prefix order U if
P is a chain, i.e., ∀x,y∈P x ≤ y ∨ y ≤ x, and
P is preﬁx closed, i.e., ∀x∈P x− ⊆ P
Furthermore, a map f : U → V between prefix orders is a functional bisimulation if
f is history preserving, and
for any path P ⊆ U and v ∈ V with f (P ) ⊆ v−, there exists a u ∈ U with P ⊆ u−
and f (u)= v.
Note that in case of transfinite executions, this definition also relates Zeno-points and other limit behaviour, generalising the solution of [6] to a problem widespread in the study of e.g. timed and hybrid systems [18,10]. Also note, that this definition slightly differs from the one in [5] in which Zeno-choices were not explicitly taken into account yet. However, for executions of the more usual models of computations, such as labeled transition systems, they coincide.

Counterexample bisimulation in Pfx:
One of the concerns that were left in the categorical treatment of prefix orders was that functional bisimulations could not (yet) be described in terms of history preserving maps alone. The reason for this, turns out to be that the diagonal k in diagram 1a exists, but is merely order preserving and not history preserving. A simple example of this is the map o : {0, 1, 2}→ {0, 1} shown in figure 3. This is a functional bisimulation according the definition above, but also according to most

other definitions of functional bisimulation that have been proposed in literature. It is also history preserving, hence a morphism in Pfx, and taking B = {0, 1} and A = {0} gives us a commuting square of history preserving maps. Nevertheless, no history preserving diagonal k can exist for this square. The fact that there does exists an order preserving k in this case lead us to investigate the possibility of a concrete category theoretic approach.
2	).. 1
ˆ	ˆ
1
ˆ
0 ....................)	0
Fig. 3. A history preserving functional bisimulation o without history preserving diagonal k.


Counterexample equivalence through spans:
A second concern was that using spans of functional bisimulations to define bisimulation relations between prefix orders does not lead to an equivalence. An example of that was already mentioned in [5], based on the set −Ω of all ordinal numbers upto (but not including) the first uncountable ordinal, ordered in the opposite direction, and the set −N of all natural numbers ordered in the opposite direction. The maps −N  ) 1 and −Ω  ) 1 are both functional bisimulations, thus witnessing that −N is bisimilar to 1 and −Ω is bisimilar to 1 (the witnessing spans are those maps and the identities). Nevertheless, the pullback of these two maps, which is supposed to be a witness for bisimilarity of −Ω and −N, turns out to be the empty set ∅. There is no other prefix order possible that has order preserving surjections into both sets, simply because there is no order preserving surjection from −Ω to −N. Indeed, the pullback does exist, but the maps ∅   ) − Ω and
∅   ) − N are certainly not functional bisimulations (they are not even surjective).
We conclude that a span of functional bisimulations between −N and −Ω cannot exist, hence they are not bisimilar through spans.
In the previous section, we have paved a way of defining bisimulation through cospans categorically. What is left to show, is that the embedding-open maps indeed give the notion of bisimulation that we would like to have. In order to do this, we consider prefix orders as a concrete category over the category of partial orders.
In the following theorem, we compile a list of interesting facts pertaining to the categories Pfx and Pos. The proof of each items are either standard or trivial.
Theorem 4.3  (i) Every history preserving function is order preserving, hence
|.|)
the identity functor Pfx === Pos which maps every preﬁx order and history

preserving map to itself is a faithful functor.
The embeddings in the concrete category Pfx	|.)|
tive history preserving functions.

Pos are precisely the injec-

The empty set ∅ is the initial object of Pfx and Pos.

The surjective history preserving functions are precisely the epimorphisms of
Pfx, and are epimorphisms in Pos as well.
All pushouts and pullbacks exist in the category Pfx.
|.)|

Next, we show that the open maps in Pfx ===
bisimulations.
Theorem 4.4 A map o : U →
Pos are precisely the functional

|.|)

V of Pfx in the concrete category Pfx ===
embedding-open if and only if it is a functional bisimulation.
Pos is

Proof. That every open map is a functional bisimulation is straightforward to prove, by taking any path P from the definition of functional bisimulation as the object A and P  {v} as B in diagram 1a. The resulting map k will point out u = k(v), and order preservation of k gives P ⊆ u— and o(u) = v. The reverse direction, however, is less trivial and requires the set-theoretic axiom of choice.
Let o be a map of Pfx such that for any path P , any v ∈ V with o(P ) ⊆ v— there is a u ∈ U with P ⊆ u— and o(u) = v. Then, it is not hard to verify (using order preservation of o and downward totality of ≤) that in addition it also holds that:
∀v′ o(P ) ≺ vj ≤ v =⇒ ∃u′ P ≺ uj ≤ u ∧ o(uj)= vj.	(*)
Here, P ≤ uj ⇔ ∀u∈P u ≤ uj. Now, consider the commutative square of figure 1a. We need to find an order preservation function |B| k) |U| such that k · |p| = m and |o|· k = s. This we do by induction over prefix closed subsets of B. We prove that such a function exists for p(A) ⊆ B. And subsequently we will prove for any subset p(A) ⊆ X ⊆ B with X— = X and any point b ∈ B, that if there exists an order preserving function kX : X → U satisfying kX · p = m and |o|· kX = sX (where sX is a restriction of s defined as sX (b) = s(b) if b ∈ X and undefined otherwise), then there exists a set p(A) ⊆ X ⊆ Y ⊆ B with Y — = Y and b ∈ Y for which a similar function kY exists and furthermore kX (x) = kY (x) for x ∈ X. It is a standard category theoretic result that the limit of an infinite series of such order preserving maps results in such an order preserving map again, and therefore proving the hypothesis above suffices to conclude that |B| k) |U| exists.
Base case Pick X = p(A) and define kX = m · p—1. Note that p—1 is an order preserving function because p is an embedding, and by construction |o|· kX = sX .
Inductive case Pick p(A) ⊆ X ⊆ B with X— = X and any point b ∈ B, and let kX be satisfying kX · p = m and |o|· kX = sX . If b ∈ X, we pick Y = X and we are done. So let b /∈ X and construct the path P = kX (b— ∩ X)— ⊆ U to find o(P ) ≤ s(b). Condition (*) gives a point u such that P ≤ {u}, o(u)= s(b), and
∀b′ o(P ) ≺ s(bj) ≤ s(b) =⇒ ∃u′ P ≺ uj ≤ u ∧ o(uj)= s(bj).
Note that, for any bj satisfying the above antecedent, there may be more than one uj satisfying the above condition, but applying the set theoretic axiom of choice we may still construct a function g : b— → u— such that g(b)= u and o(g(bj)) = s(bj). As a second stage, we use a quotient construction to construct a function gˆs : b— → u—

such that for every b, bj ∈ B with s(b)= s(bj) we have gˆs(b)= gˆs(bj) and there exists a bjj such that s(b)= s(bjj) and gˆs(bjj)= g(bjj). Finally, we may define Y = X ∪ b— and merge kX and gˆs to find a function kY such that kY (y)= kX (y) if y ∈ X and kY (y) = gˆs(y) if P ≺ y ≤ b. Note that Y is prefix closed and kY · p = m and
|o|· kY = sY satisfies by construction; so it remains to show kY is order preserving.
For this, pick y, yj ∈ Y with y ≤ yj. We distinguish the following cases.
y, yj ∈ X: trivial since kX is order preserving;
y /∈ X and yj ∈ X: leads to a contradiction since X = X—;
y ∈ X and y /∈ X: because y ≤ yj we find kY (y)= kX (y) ∈ P and by construction
P ≺ gˆ(yj)= kY (yj);
y, yj /∈ X: Then kY (y), kY (yj) ≤ kY (b) and by downward totality we have either kY (y) ≤ kY (yj) (in which case we are done) or kY (yj) ≤ kY (y). In the latter case we find s(y) ≤ s(yj) = o(kY (yj)) ≤ o(kY (y)) = s(y) hence s(y) = s(yj) hence gˆs(y)= gˆs(yj) hence kY (y)= kY (yj).
This concludes the proof that o is an open map.	2
Finally, we already have seen that bisimulation through spans will not result in an equivalence, with the pullback of −Ω  ) 1 (  − N as an example of a pullback that does not preserve open maps. In order to prove that pushouts do preserve open maps, we first need to recall a few notions and theorems regarding the construction of pushouts.
Definition 4.5 Given a prefix order U, an equivalence relation ∼⊆ U × U is
Order contracting if: ∀u,v,w,x∈U u ≤ v ∧ v ∼ w ∧ w ≤ x ∧ x ∼ u ⇒ u ∼ v.
Theorem 4.6 Every morphism f : U → V deﬁnes an order contracting equivalence on U given by u ∼ uj ⇔ f (u)= f (uj). Furthermore, the equivalence classes U/ ∼ are preﬁx ordered by deﬁning [u]~ ± [uj]~ iff ∃w,w′ u ∼ w ≤ wj ∼ uj, and the projection [.]~ : U  ) U/ ∼ is an epimorphism.
Theorem 4.7 Given two preﬁx orders Y and Z, their coproduct is the disjoint union Y Z of the underlying sets, preﬁx ordered by the relation ± such that a ± b if and only if a ≤ b and a, b ∈ Y, or a ≤ b and a, b ∈ Z.
Theorem 4.8 Given two history preserving maps X f) Y and X g) Z, their pushout is the set (Y Z)/ ∼ where ∼ is the smallest order contracting equivalence such that ∀x∈Xf (x) ∼ g(x), and the natural projections are given by [.]~ : Y → (Y Z)/ ∼ and [.]~ : Z → (Y Z)/ ∼.

|.|
Theorem 4.9 In the concrete category Pfx ===
Pos pushouts preserve open maps

(hence bisimulation through cospans of open maps is an equivalence).
Proof. Given two open maps X ◦ )f) Y and X ◦ )g) Z, we know their pushout is the set (Y  Z)/ ∼ where ∼ is the smallest order contracting equivalence such that
∀x∈Xf (x) ∼ g(x). To see that the map [.]~ : Y → (Y  Z)/ ∼ is open (and similarly

for Z), pick P ⊆ Y a path in Y and [P ] ⊆ v— for some v ∈ (Y Z)/ ∼. So there exists either a y ∈ Y or z ∈ Z with [y]= v or [z]= v respectively. Furthermore, if z exists we use the fact that g is open hence has a base retract to find y = f (g→(z)) ∼ z hence [y]= v. Because taking equivalence classes is order preserving, either P ⊆ y— (in which case we are done) or there exists a p ∈ P that is unrelated to y, yet
[p] ≤ [y]. By history preservation of [.] we find a pj ≤ y with p ∼ pj. Next, we will show that the latter leads to a contradiction by induction on the construction of ∼. By construction p ∼ pj may be obtained in six ways:
(reflexivity) p = pj, but then p ≤ y; A contradiction.
(symmetry) pj ∼ p, in which case we find that all the other arguments actually are symmetric;
(transitivity) pj ∼ pjj ∼ p, in which case we find by induction a yj ∼ y such that
pjj ≤ yj, and by using induction once more a yjj ∼ yj with p ≤ yj. A contradiction.
(base equivalence) there exists x, xj such that p = f (x), g(x) = g(xj), and pj = f (xj). But in this case we use that f and g are open maps hence functional bisimulations to find a point yj ∼ y with p ≤ yj hence [p] ≤ [yj] = [y]. A contradiction;
(order contraction) there exist q, qj such that p ≤ pj ∼ q ≤ qj ∼ p. But then
p ≤ pj ≤ y. A contradiction;
(order contraction) there exist q, qj such that pj ≤ p ∼ q ≤ qj ∼ pj. But then by induction there is a successor yjj with qj ≤ yjj and by induction once more a yjjj with p ≤ yjjj and yjjj ∼ yjj ∼ yj ∼ y. A contradiction.
From this we conclude that [.] is a functional bisimulation, hence an open map. 2
As a side remark, there are enough open maps in our concrete category, allowing us an alternative route in reasoning about bismilarity using theorem 2a.
|.|)
Theorem 4.10 In Pfx === Pos, there are enough open maps.
Proof. Given a map X  f) Z as in figure 2a, simply start by extending all paths in X with the futures they will obtain after mapping to Z. This gives an embedding p into Y, and since no new behaviour is added while mapping Y to Z the resulting map o is a functional bisimulation, hence open.	2
A characterisation of branching bisimulation
In this final section, we show that the so-obtained notion of bisimulation through cospans on prefix orders coincides with branching bisimulation when studying the executions from labelled transition systems. In order to do this, we consider the executions over labeled transition systems as objects in the slice category Pfx/A∗,
i.e. the category in which the objects are history preserving maps of the form f : U  ) A∗ from some arbitrary prefix order U into the fixed prefix order A∗ of strings over the alphabet A, and in which a morphism between f : U  ) A∗ and g : V  ) A∗ is a history preserving map h : U → V such that f = g · h.

Note, that without the use of a slice category, prefix orders represent fully ob- served executions of a system, but in a slice category only the result of the map f : U  ) A∗ is observable. In a slice category, a system is therefore an observation as a function of ‘branching time’.
Definition 5.1 A labelled transition system is a tuple ⟨P, Aτ , →⟩ with P being a set of states and →⊆ P×Aτ ×P is the so called transition relations over the alphabet Aτ ,
with τ /∈ A denoting an invisible action. As usual, we write p −→a  q for (p, a, q) ∈→.
Definition 5.2 A run u starting from a state p is a function σ— → P (from the history of some word σ ∈ A∗ ) satisfying the following conditions: u(ε) = p and
τ
j	a	j
u(σ ) −→ u(σ a), for every σj ≤ σ.  We write Runs(p) to denote the set of all
runs starting from the state p, ordered by: u ≤ uj	⇐⇒  dom(u) ⊆ dom(uj) ∧
∀σ∈dom(u) uj(σ)= u(σ). Furthermore, obsp : Runs(p) → A∗ denotes the observation function which simply forgets the occurence of τ ’s in a word σ ∈ A∗ . In other
words, the invisible steps correspond to no change in observation.
Theorem 5.3 The sets of all runs starting from a state p in ⟨P, Aτ , →⟩ is a preﬁx order. Moreover, the observation function obsp is a history preserving function.
Definition 5.4 A binary relation R ⊆ P × P is a branching bisimulation relation if and only if the following transfer properties are satisfied.

If pRpj and p −→a
q, then either a = τ ∧ qRpj, or there are pjj, qj ∈ P such that

j ε	jj a	j	jj	j
p → p −→ q , pRp , and qRq .

If pRpj and pj −→a
q, then either a = τ ∧ pRq, or there are pjj, qj ∈ P such that

ε	jj a	j	jj	j	j
p → p −→ q , p Rp , and q Rq.
ε
Here, → denotes zero or more τ steps. Two processes p, q ∈ P are branching bisimilar
if there exists a branching bisimulation relation R such that pRq.
Theorem 5.5 Two processes are branching bisimilar iff their corresponding preﬁx orders are bisimilar through cospans of open maps in the slice category Pfx/A∗.
Proof. Let Runs(p), Runs(q) be bisimilar through cospans of open maps in the slice category Pfx/A∗. I.e., there exists a prefix order R and embedding-open maps Runs(p) ◦ )f) R ((g ◦ Runs(q) and a history preserving function obs : R → A∗ with obsp = obs ·f and obsq = obs ·g. Define a relation R⊆ P × P by relating π(u)Rπ(v) whenever f (u)= g(v), where π(u) returns the last state visited by u. It is easy to verify that this relation is indeed a branching bisimulation relation (see e.g. [5]).
Reversely, suppose R is the largest branching bisimulation relation, which is well known to exist between runs of this type and to be an equivalence relation (see [19]). Moreover, from [2], we know that there is a surjection f : P → Pj onto the reduced labelled transition system satisfying:

∀p,q∈P (p −→a
q ∧ a ∈ A) =⇒ f (p) −→a
f (q).

∀p,q∈P p −→τ
q =⇒ f (p)= f (q) ∨ f (p) −→τ
f (q).

a	ε	j a	j
∀p∈P,q¯∈P′ f (p) −→ q¯ =⇒ ∃p′,q∈P p → p −→ q ∧ f (p)= f (p ) ∧ f (q)= q¯.

Next, one may verify using induction on the length of runs that a function f : P → Pj satisfying conditions (i) and (ii) induces a history preserving function fp : Runs(p) → Runs(R(p)) (for any p ∈ P), where R(p) denotes the equivalence class of p. Moreover, Condition (iii) guarantees that fp is surjective and it satisfies the characterising set-theoretic condition of an embedding-open map of Theorem 4.4. Now suppose q is branching bisimilar to p. Like fp, there is an embedding-open map fq : Runs(q) → Runs(R(q)) (note R(p) = R(q)); thus, giving us a co-span of embedding-open maps fp, fq as required.	2

Discussion and conclusive remarks
In this paper we have shown that a concrete category theoretic interpretation of the definition of open map makes this notion applicable to a wider ranger of mod- els of behaviour and to a wider range of behavioural equivalences. In particular, we have shown that it is able to characterise the notion of branching bisimulation (something that was not possible before) in the setting of prefix orders (in which the original definition of open map did not produce satisfactory results). Further- more, we have shown that in the category of prefix orders, the path-category that usually parameterises the notion of open map can be chosen to be subcategory of embeddings, thus giving it a natural and fully category theoretic characterisation. A careful look at the characterisation of bisimulation which we obtained in the- orem 4.4, reveals that the paths that are being extended do not necessarily have a maximum. This means that also the continuations of paths that are transfinitely long are taken into account, which occur for example in the literature on hybrid systems in the context of Zeno behaviour [18,10,6]. Thus we expect that open maps
can be used to preserve these phenomena in a uniform manner.
From a philosophical point of view, using a concrete category for behavioural models means that we are to distinguish implementations from observations in such a way that we assume all implementations to be observable. Interpreting the result in Theorem 3.4 along these lines, we see that X is bisimilar to Y iff any conceivable extension of X that implements additional behaviour of Y is already observable in X (although may have been implemented differently). Still, it depends on the concrete category which implementations are actually extensions, i.e. which are the embeddings that need to be preserved.
In the quest for a common approach to modeling computations and other dy- namic behaviour, the next logical step seems to be to study split faithful functors over Pfx. This may give insight in which embeddings are and are not to be taken into account. In a sense we already have studied such a split in section 5 by look- ing at the runs of labeled transition systems rather than at the transition systems themselves. But more general theory may be found here. For example, take any cat- egory of syntactic computational models M. We expect the executions of a model in this category will form a prefix order, meaning that implementations in M can be mapped to history preserving maps in Pfx and order preserving maps in Pos. From the philosophical point of view, the syntactic constructs of M are the actual

implementations and the order preserving maps of Pos would serve as observations. The definition of bisimulation for M would then come from open maps in the con- crete category of M over Pos, but the expectation that this forgetful functor splits over Pfx can be exploited when studying bisimilarity of models in M. For sure, in such a split there are less embeddings in M than there are in Pfx, therefore the notion of bisimulation can only have become weaker (there is less to preserve). This means that two models in M are bisimilar whenever they are bisimilar in Pfx. The reverse does not necessarily hold, for example because open maps in Pfx check for Zeno behaviour, while there may not be any Zeno-embeddings in M.
Naturally, splits over Pfx alone will usually not be enough. Even in the case of labeled transition systems, we actually used a split over the slice category Pfx/A∗. The reason for this, is that prefix orders only model the actual behaviour and how it is implemented, while the order preserving maps in the base category only relate the moments of observation. If the actual observations need to be preserved, something more (like a slice category) is needed. The advantage of using A∗ as an observation space is that it is itself prefix ordered, but in continuous systems or probabilistic systems this will not be the case. Future research will be aimed at finding a method to deal with such observations of different kinds in a uniform manner.
Finally, this paper stirs up the discussion on whether bisimulation through spans or cospans of open maps is to be preferred as a general theory of behaviour. If we follow our own intuition on the meaning of the open map diagram in Pfx, we see that an open map X ◦ )) Y represents a relation between an implementation X and a specification Y such that all specified behaviour is actually implemented. The existence of a span of such maps then means that two specifications ’agree’ in the sense that they have a common implementation, while the existence of a cospan means that two implementations share the same specification. Apparently the latter indeed results in an equivalence, while the former does generally not. Indeed, if specification A and B have a common implementation D and specification C and B have a common implementation E, then this does not guarantee that specification A and C are not conflicting in some sense. So if our interpretation of the maps is any good, then using cospans is indeed the more reasonable approach towards obtaining an equivalence, but the meaning of spans may still be useful where multiple specifications need to be combined (for instance, in the context of model based design and system architecture).

References
Ad´amek, J., H. Herrlich and G. Strecker, “Abstract and Concrete Categories: The Joy of Cats,” University of Bremen, 2004, online Edition http://katmat.math.uni-bremen.de/acc/.
Caucal, D., Branching bisimulation for context-free processes, in: R. Shyamasundar, editor, Foundations of Software Technology and Theoretical Computer Science, Lecture Notes in Computer Science 652, Springer, 1992 pp. 316–327.
Cheng, A. and M. Nielsen, Open maps (at) work, BRICS Report Series 23, Aarhus University (1995).
Cuijpers, P., The categorical limit of a sequence of dynamical systems, in: EXPRESS/SOS 2013, EPTCS 120, 2013, pp. 78–92.

Cuijpers, P., Prefix orders as a general model of dynamics, in: DCM 2013, Pre-proceedings of the 9th international workshop on developments in computational models (DCM 2013)., 2013, pp. 25–29.
Cuijpers, P., M. Reniers and A. Engels, Beyond Zeno-behaviour, Technical Report CS-Report 01-04, TU/e, Eindhoven, Netherlands (2001).
Danos, V., J. Desharnais, F. Laviolette and P. Panangaden, Bisimulation and cocongruence for probabilistic systems, Information and Computation 204 (2006), pp. 503 – 523.
Ferlez, J., R. Cleaveland and S. Marcus, Generalized synchronization trees, in: Foundations of Software Science and Computation Structures, Lecture Notes in Computer Science 8412, 2014, pp. 304–319.
URL  http://dx.doi.org/10.1007/978-3-642-54830-7_20

Fiore, M., G. Cattani and G. Winskel, Weak bisimulation and open maps, in: Logic in Computer Science, 1999. Proceedings. 14th Symposium on, 1999, pp. 67–76.
Henzinger, T., The theory of hybrid automata, in: Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science (LICS 1996) (1996), pp. 278–292.
Hildebrandt, T., P. Panangaden and G. Winskel, A relational model of non-deterministic dataflow, in:
D. Sangiorgi and R. de Simone, editors, CONCUR’98 Concurrency Theory, Lecture Notes in Computer Science 1466, Springer Berlin Heidelberg, 1998 pp. 613–628.
Hune, T. and M. Nielsen, Timed bisimulation and open maps, in: L. Brim, J. Guska and J. Zlatuˇska, editors, Mathematical Foundations of Computer Science (MFCS’95), Lecture Notes in Computer Science 1450, Springer Berlin / Heidelberg, 1998 pp. 378–387.
Joyal, A. and I. Moerdijk, A completeness theorem for open maps, Annals of Pure and Applied Logic
70 (1994), pp. 51 – 86.
Joyal, A., M. Nielsen and G. Winskel, Bisimulation and open maps, in: Logic in Computer Science, 1993. LICS’93., Proceedings of Eighth Annual IEEE Symposium on, IEEE, 1993, pp. 418–427.
Milner, R., “A calculus of communicating systems,” Lecture Notes in Computer Science 92, Springer- Verlag, 1980.
Sanchez Terraf, P., Unprovability of the logical characterization of bisimulation, Inf. Comput. 209
(2011), pp. 1048–1056.
Sobocin´ski, P., Relational presheaves, change of base and weak simulation, Journal of Computer and System Sciences (2014), in press.
van der Schaft, A. and J. Schumacher, “An Introduction to Hybrid Dynamical Systems,” Lecture Notes in Control and Information Sciences 251, Springer-Verlag, London, 2000.
van Glabbeek, R. and W. Weijland, Branching time and abstraction in bisimulation semantics, J. ACM
43 (1996), pp. 555–600.
van Glabbeek, R. J., The linear time - branching time spectrum ii, Lecture Notes in Computer Science
715, 1993, pp. 66–81.
