Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 326 (2016) 3–25
www.elsevier.com/locate/entcs

On the Flora of Asynchronous Locally Non-monotonic Boolean Automata Networks
Aurore Alcolei1 K´evin Perrot2 Sylvain Sen´e3
Aix-Marseille Universit´e, CNRS, LIF UMR7279, 13288 Marseille, France

Abstract
Boolean automata networks (BANs) are a well established model for regulation systems such as neural networks or gene regulation networks. Studies on the asynchronous dynamics of BANs have mainly focused on monotonic networks, where fundamental questions on the links relating their static and dynamical properties have been raised and addressed. This paper explores analogous questions on non-monotonic networks, ⊕-BANs (xor-BANs), that are BANs where all the local transition functions are ⊕-functions. Using algorithmic tools, we give a general characterisation of the asynchronous transition graphs of most of the strongly connected ⊕-BANs and cactus ⊕-BANs. As an illustration of these results, we provide a complete description of the asynchronous dynamics of two particular structures of ⊕-BANs, namely ⊕- Flowers and ⊕-Cycle Chains. This work also draws new behavioural equivalences between BANs, using rewriting rules on their graph description.
Keywords: Interaction networks, Boolean automata networks, non-monotonicity, asynchronous dynamics, behavioural equivalence.


Introduction
Boolean automata networks (BANs) are discrete interaction networks that are now well established models for biological regulation systems such as neural net- works [9,10] or gene regulation networks [12,23]. To this extent, locally monotonic BANs have been widely studied, both on the applied side [8,15] and on the theo- retical side [11,14,17,19,20]. However, recent works have brought new interests in local non monotonicity [18].
On the biological side, it has been shown that, sometimes, gene regulations imply more complex behaviour than what is usually assumed: this is for example the case when one also takes in account the effect of their byproducts [22]. In this case, local

1 Email: aurore.alcolei@ens-lyon.fr
2 Email: kevin.perrot@lif.univ-mrs.fr
3 Email: sylvain.sene@lif.univ-mrs.fr

http://dx.doi.org/10.1016/j.entcs.2016.09.016
1571-0661/© 2016 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

non monotonicity may be required for modelling, in particular because this allows to express sensitivity to the environment.
On the theoretical side, it has been noticed [16,19] that non local monotonicity is often involved when it comes to singular behaviours in BANs. For example it has been shown that the smallest network that is not robust to the addition of synchronism (i.e. allowing some automata to update simultaneously) is a locally non-monotonic BAN [16,19].
In the lines of [18], the present study is a first step towards a better understanding of locally non-monotonic BANs. It focuses on ⊕-BANs, that is, BANs in which the state of an automaton i is updated by xoring the state value (or the negated state value) of the incoming neighbours of i. In other words, in these BANs, every local transition function is of the form fi =  j∈N +(i) σ(xj) where σ ∈ {id, neg} and N +(i) denotes the set of incoming neighbours of i [19].
Following a constructive approach, we first looked at some particular BAN structures that combine cycles, such as the double-cycle graphs [3,13], the flower- graphs [4] and the cycle chains. All these BANs belong to the family of cactus BANs since any two simple cycles in their structure have at most one automaton in common. Actually, we realised that most of the specific results we got for each of these BANs could in fact be generalised to a wide set of ⊕-BANs: the strongly connected ⊕-BANs with an induced double cycle of size greater than 3.
A precise specification of these BANs is given in Section 2. This section also introduces all the definitions and notations that will be used in the sequel. Section 3 is dedicated to the presentation and proofs of the general results obtained about the asynchronous dynamics of strongly connected ⊕-BANs with an induced double cycle of size greater than 3. Similarly to what is done in [13], these results are based on an algorithmic description of the asynchronous transition graph of these BANs. We conclude this paper in Section 4 with a full characterisation of two types of ⊕- BANs, the ⊕-flower BANs and the ⊕-cycle chain BANs, which illustrates the results of Section 3 and provides new behavioural equivalences bisimulation results specific to ⊕-BANs. These last results are of interest since they provide new perspectives for BAN classification through the use of rewrites of their interaction graphs.

Definitions and notations
Static definition of a BAN
A BAN is defined as a set of Boolean automata that interact with each other. The size of a network corresponds to the number of automata in it. For a network N of size n we denote V = {1,..., n} the corresponding set of automata.
A Boolean automaton i is an automaton whose state has a Boolean value xi ∈

B = {0, 1}. The Boolean vector x = (xi)n
that gathers together the states of all

automata in the network is called a conﬁguration of N . In the following, we will sometimes denote by x[i, k] the subvector that records the states of the automata from i to k, for i < k. We will shorten by xi the configuration x where the state of the ith automaton is negated, and similarly, for any subset I of V , xI will denote

the configuration x where the states of the automata in I are negated.
The state of an automaton can be updated according to its local transition func- tion fi : Bn → B. This local function characterises how the automaton reacts in a given configuration: just after being updated, the state of i has value fi(x) where x is the configuration of the network before the update. We say that i is stable in x if fi(x)= xi. It is unstable otherwise. Hence a network N is completely described
by its set of local transition functions N = {fi}n  .
An automaton i is said to be an influencer of an automaton j if there exists a configuration x such that fj(x) /= fj(xi). In this case j is said to be influenced by
i. We denote by Ij the set of influencers of j.
In a BAN, a path π = i0i1 ... ik of length k is a sequence of distinct automata such that for all 1 ≤ j ≤ k, ij−1 ∈ Ij. A BAN is strongly connected if there is a path between every two automata. A nude path is a particular path such that for all 1 ≤ j ≤ k, ij−1 is the unique influencer of ij (Ij = {ij−1}), i.e. fj(x) = xj−1 or fj(x) = xj−1. We define the sign of a nude path as the parity of the number of local functions of the form fi(x)= xi−1 that compose it,i.e. sign(π)= 

n j=1
1fj (x)=x

j−1
  mod (2). A nude path is maximal if any extension of it is not

a nude path. We will denote by πi the maximal nude path that ends in automaton
i. Paths and nude paths get their name from the graphical representation that is often associated to BAN as we will see next.
To get a sense of what a network looks like, it is common to give a graphical representation of it. To every local functions fi, one can associate a Boolean formula Fi over the variables xi. The literal associated to the kth occurrence of the variable xi is denoted by σk(xi) where σk is the sign of the literal. Then the interaction graph of N according to these formulas is the signed directed graph G = (V, A), where V = {1,..., n} is the set of nodes of G with one entry points per literal in Fi, and A is the set of arcs defined by (i, j, σk) ∈ A if the kth occurrence of the variable xi in Fj has sign σk (see Figure 1 (a)).
As we focus on ⊕-BANs, all formula Fi involving more than one automaton will be written in Reed-Muller canonical form, that is Fi =  j∈Ii σj(xj). The type of a BAN will refer to the underlying structure of its interaction graph (modulo the sign
of the literals and a renaming of the automata). A type of BANs can be described by a family of graphs, and we will say that two BANs are of the same type if their interaction graphs are isomorphic (we ignore the labels).
The simplest interaction structure that allows for complex behaviour is the cycle structure [21]. A Boolean automata cycle (BAC) C of size n is a BAN defined
as a set of local functions {fi}n	such that fi(x) = x((i−1) mod (n)) or fi(x) =
x((i−1) mod (n)) for all i ∈ {1,..., n}. Abusing notation we will often express fi
via its formula representation Fi = σi(xpred(i)) where pred(i)= (i − 1 mod (n)) is the only influencer of i in C and σi is its sign (either the identity or the negation function).
In the following, the majority of the networks or patterns we discuss are made of cycles that intersect each other. If an automaton i is the intersection of l distinct
cycles, then its local transition function will be fi(x) = Ll	σj(predj(i)) where

predj(i) represents the predecessor of i in each of the incident cycles.
If a BAN is described in terms of intersections of m simple cycles, C1,..., Cm, we will often represent its size by a vector of natural numbers n = (n1,..., nm), where nk is the size of the kth cycle. We will also use this vector representation to describe the configurations of the BAN: x = (x1,..., xm) ∈ Bn1 × ... × Bnm will represent the configuration where each cycle Ck is in configuration xk ∈ Bnk . By extension xk will denote the state of automaton ik which is the jth automaton of
j	j
cycle Ck.
As one can expect, a strongly connected ⊕-BAN is a ⊕-BAN whose interaction graph is strongly connected. Hence the type of these BANs can always be described as a set of simple cycles and intersection automata. Strongly connected cactus BANs are special strongly connected BANs where any two simple cycles intersect each other at most once [5]. The simplest example of BANs of this form are the
⊕-Boolean automata double-cycles (⊕-BADCs). These ⊕-BANs are described by
two cycles C1, C2 that intersect at a unique automaton o = i1 = i2. The ⊕-BAN
1	1
depicted in Figure 1 (a) is in fact a ⊕-BADC of size (2, 1) = 2 + 1 − 1= 2.

Asynchronous dynamics of a BAN
As previously mentioned, the configuration of a network may change in time along with the local updates that are happening. A local update is formally de- scribed by a subset W of V which contains the automata to be updated at a time. We say that W is asynchronous if it has cardinality 1, that is, W = {i} for some i ∈ V .
An update W makes the system move from a configuration x to a configuration
xj where xj = fi(x) if i ∈ W , and xj = xi otherwise. This defines a global function
i	i
FW : Bn → Bn over the set of configurations.
A network evolves according to a particular mode M ⊆ P(V ) if all its moves are due to updates from M . The asynchronous mode of a BAN of size n is then

defined by the set A = {{i}}n
of asynchronous updates, it is non-deterministic.

Note that our definition of update mode is not fully general [17] but sufficient for the scope of this paper.
We say that a configuration xj is reachable from a configuration x (in a mode

M ) if there exists a finite sequence of updates (Wt)s
(in M ) such that FW1
... ◦

FW (x) = xj. Then, a configuration is unreachable (in M ) if it cannot be reached
from any other configuration but itself (in M ). Finally a ﬁxed point (of M ) is a configuration x such that FW (x)= x for every update W (in M ).
The study of the dynamics of a network under a particular update mode aims at making predictions, i.e. given an initial configuration x, we want to tell what are the possible sets of configurations in which the network can end asymptotically. These sets are called attractors of the network and the set of configurations from which they can be reached are their attraction basins. Notice that a fixed point is an attractor of size 1.
The dynamics of a network N according to an update mode M can be modelled

by a labelled directed graph GM = (Bn, 

W∈M
FW ), called the M-transition graph


1	+	2

{1}
{2}

—
+
{2}	{1}, {2}

(a)	(b)

Fig. 1. (a) The interaction graph of BAN {f1(x)= x2, f2(x)= x1 ⊕x2} and (b) its asynchronous transition graph.
of N , such that:
the set of vertices Bn corresponds to the 2n configurations of N .
the arcs are defined by the transition graph of the functions FW for all W ∈ M , that is, x −W→ xj is an arc of G if and only if W ∈ M and FW (x)= xj.

The transition graph GA
associated to the asynchronous update mode is called the

asynchronous transition graph of G, shorten ATG. Figure 1 (b) shows the ATG of the ⊕-BADC depicted on the left.
In terms of transition graphs, an attractor of N for the mode M corresponds to a terminal strongly connected component of GM , that is, a strongly connected component that does not admit any outgoing arcs. The attraction basin of an attractor corresponds to the set of configurations in GM that are connected to this
component.
In a mode M , the configurations that do not pertain to an attractor are called transient configurations. These configurations can be reversible or irreversible de- pending on whether it is possible to reach them again once they have been passed. A particular type of irreversible configurations are the unreachable configurations that are the configurations that do not have any incoming arcs but self-loops in GM .
Because of the correspondence between transition graphs and dynamics, most of the results presented in the following are expressed in terms of walks and descriptions of the asynchronous transition graphs of the networks we study.
Behavioural isomorphism Bisimulation equivalence relation
We conclude this section with a quick reminder on behavioural isomorphism which is an equivalence relation over the set of BANs that expresses the fact that two networks “behaves the same way” (up to a renaming of their automata and/or of their configurations). More precisely, the equivalence of N and Nj means that,

for any update mode M , the transition graphs GM and GM
are isomorphic.

N	N′
Definition 2.1 Two BANs N and Nj are (behaviourally) isomorphic if there exist two bijections ϕ : V → V j over the set of automata and φ : Bn → Bn over the set of configurations such that for any update W ⊆ V in N , the corresponding update ϕ(W ) acts the same way in Nj, that is, for all configurations x, φ(FW (x)) =

j
ϕ(W )
(φ(x)).

This definition of isomorphism between BANs has been first introduced in [17] under the name of bisimulation. We recall here some general results about it.


Theorem 2.2 ([17]) Let N = {fi}n
be a BAN and N⊥ = {f⊥}n
be its dual

		i=1
i	i=1

network deﬁned as f⊥(x)= fi(x) then N and N⊥ are isomorphic.


Theorem 2.3 ([17]) Let N = {fi}n	be a BAN and N + = {f +}n
be its canon-

i=1	i	i=1
ical network deﬁned as (i) f +(x)= xj if fi(x)= xj or xj, and (ii) f +(x)= fi(xI )
i	i
otherwise, where I = {i ∈ V | sign(πi)= 1} is the set of automata whose maximal
incoming nude path has negative sign. Then N and N + are isomorphic.

Theorem 2.2 is of importance because it tells us that all the results stated in the sequel will also hold for ⇔-BANs, which are the dual BANs of the ⊕-BANs

since all their local functions are of the form fi(x)= ⇔
j∈Ii
σ(xj). On the other side,

Theorem 2.3 is very useful when studying particular types of networks because it
greatly reduces the number of cases to study. Indeed, it says that one only needs to focus on networks with positive nude paths to characterise the whole set of possible transition graphs for a given type of networks. For example, it states that there are only three different cases of ⊕-BADCs to study: the positive ones, the negative ones and the mixed ones, that respectively correspond to the case where fo(x)= x1 ⊕x2,
1	1
fo(x)= x1 ⊕ x2 and fo(x)= x1 ⊕ x2. There is actually only one class of ⊕-BADCs
1	1	1	1 
since: (i) the equality x1 ⊕x2 = x1 ⊕x2 implies that positive and negative ⊕-BADCs
1	1	1	1
are trivially isomorphic; (ii) a positive ⊕-BADC is isomorphic to a mixed ⊕-BADC
of same structure by taking φ(x)= xV .
To prove that two networks are isomorphic we will often use a stronger condition than the one given in Definition 2.1.


Lemma 2.4 Two BANs N = {fi}n , Nj = {fj}n
are isomorphic if and only

i=1	i i=1
if there exists a bijection ϕ : {1,..., n} → {1,..., n} and a set {φi : B → B}n
of (non constant) Boolean functions such that for all automata i, φi ∈ {id, neg},

and for all conﬁgurations x ∈ Bn, φi(fi(x)) = fj
(φ(x)) where φ(x) is deﬁned

componentwise by φ(x)i = φϕ−1(i)(xϕ−1(i)).
Proof. The proof of the right implication is straightforward since the equality

φi(fi(x)) = fj
(φ(x)) between the local functions induces the equality φ(FW (x)) =

j
ϕ(W )
(φ(x)) between the global functions for any update W .

To prove the reverse implication we need to show that every bijection φ can
be expressed locally: Suppose N and Nj are isomorphic and let ϕ and φ match Definition 2.1. For all i ∈ {1,..., n}, let φi : Bn → B be defined by φi(x)= φ(x)ϕ(i). We want to prove that φi does not depend on any other variable than xi (hence it can be rewritten as a Boolean function from B → B).

Let j ∈ {1,..., n} and let x be any configuration, then by definition,
φ(F (x)) = ⎧⎨ φ(x) if j is stable in x



and





j
ϕ(j)
⎩ φ(xj) if j is unstable in x

(φ(x)) = ⎧⎨ φ(x) if ϕ(j) is stable in φ(x)

⎩ φ(x)	if ϕ(j) is unstable in φ(x)
The function φ is a bijection so φ(x) /= φ(xj). In the same time, φ(Fi(x)) =

j
ϕ(j)
(φ(x)) and so φ(xj) /= φ(x) implies that φ(xj)= φ(x)ϕ(j)(/= φ(x)).

So if j /= i then for all x, φ (xj)= φ(xj)  = (φ(x)ϕ(j))  = φ(x)  = φ (x) so φi does not depend on xj for all j ∈ {1,..., n}— {i}, so φi only depends xi.
Finally, φi is bijective since φ is a bijection. This concludes the proof.	□
We will make great use of Theorem 2.3 and Lemma 2.4 in Section 4, when we will give new isomorphism results specific to ⊕-BANs.

General results on ⊕-BANs
This section presents the main theorem of this paper: a connexity result that char- acterises the shape of the ATG of any strongly connected ⊕-BAN with an induced BADC of size greater than 3.
Theorem 3.1 In a strongly connected ⊕-BAN with an induced BADC of size greater than 3, any conﬁguration that is not unreachable can be reached from any conﬁguration which is not stable in a quadratic number of asynchronous updates.
This theorem tells us that the ATG of any strongly connected ⊕-BAN which is not a cycle or a clique is characterised by (see Figure 2):
its fixed point(s) S (if any).
its unreachable configuration(s) U (if any).
a unique strongly connected component (SCC) of reversible transient configura- tions, reachable from any configuration of U\S and connected to any configuration of S \ U .
The proof of Theorem 3.1 is based on several algorithms that describe sequences of updates tomove from a given configuration to an other in the ATG of a ⊕-BAN. We start this section by presented these algorithms. In a second time we briefly discuss the complexity of these algorithms to give an upper bound on the length of the minimal sequence of updates between two configurations. The end of the section is dedicated to general remarks about the set of fixed points and unreachable configurations of any BANs and helps precise the results of Theorem 3.1.



Fig. 2. General ATG shape of strongly connected ⊕-BANs with an induced BADC of size greater than 3.

Proof of Theorem 3.1
Let N be a strongly connected ⊕-BAN with an induced BADC B of size greater than 3, let x be its initial (unstable) configuration, and let xj be the configuration to reach. The idea behind the proof of Theorem 3.1 is to take advantage of the high expressiveness of ⊕-BADCs and to use B as a “state generator” that sends information across the network in order to set up the state of every automaton of N to its value in xj. More precisely, if B is in an unstable configuration then we will show that, given an automaton i and a Boolean value b, N can always move to a configuration where i is in state b and B is unstable.
A good intuition for this is to see that, in a positive ⊕-BADC, if the central automaton receives a Boolean value 1 from one of its influencers then it can switch state as many times as desired by sending its own state along the opposite cycle. To make this explicit, suppose that xpred1(o) = 1 then updating the automata along C2 will lead to a configuration where xpred2(o) = xo and so fo(x)= xpred1(o) ⊕xpred2(o) = 1 ⊕ xo = xo. Hence, in a positive network, it is possible to set any automaton i to some state b, by setting o to b and then propagating b along a path from o to i. Moreover, one can ensure that this will be possible again, if in the end at least one of the two predecessors of o is in state 1.
To formalise this reasoning the proof of Theorem 3.1 is based on the following two lemmas.
Lemma 3.2 In a ⊕-BADC, every conﬁguration which is not unreachable can be reached from any other (unstable) conﬁguration in O(n2) updates (and the bound is tight).
Proof. First let us recall that all ⊕-BADCs of same size (n1, n2) are equivalent with respect to behavioural isomorphism. This means in particular that their ATGs are isomorphic and so proving that Lemma 3.2 holds for positive ⊕-BADCs is sufficent to prove Lemma 3.2 completely. Hence in the following we will assume that B is positive. One will notice however that the proof below is easy to adjust to any
⊕-BADC.
We prove Lemma 3.2 by presenting an algorithm that explains how to go from one (unstable) configuration to an other (reachable) one in the ATG of any positive
⊕-BADC that has at least one cycle of size greater than 3. The algorithm can be tuned to deal with BADCs where n1 and n2 are both less than or equal to 2 but this






{1}|{2}




{1}|{2}|{3}


{1}

{3}
{3}


{1}
{3}	{2}
101
{1}
{2}

000	001
{2}
{3}

{1}


{


11
{1}

{2}


{1}
{1}|{2}

{2}
110	111

{1}
{1}|{3}

{1}
2}	{2}

{3}

011

{2}|{3}



Fig. 3. The ATGs of the positive BADCs of size (1, 2) (left) and (2, 2) (right).


multiplies the number of cases that need to be considered and masks the general dynamics. So for the special case of BADCs of size (n1, n2)= (1, 2) (or vice-versa) and (n1, n2)= (2, 2) we prefer to prove Lemma 3.2 by looking directly at the form of their ATG. These ATGs are drawn in Figure 3 and they both satisfy Lemma 3.2 as desired.
We now assume that n1 ≥ 3. The algorithm works in two steps (summarised in Figure 4):
From any unstable configuration (i.e. with at least one automata in state 1 in the case of positive ⊕-BADC) one can reach the highly expressive alternating configuration x where xo = fo(x) and xi = fi(x) for all i /= o (i.e. xo =
xn ⊕ xn  and xk = xk	for all ik /= o). This is possible for example using the
1	2	j	j−1	j

following steps:
In a linear number of updates, set x1
to 1 and x2
to 0: Let ik
be the

automaton in state 1 that is the closest to i1
and update every automata

on the directed path from ik to i1
. If k = 1 then this simply propagates the

j	n1
state 1 on every automaton from j to n1 in C1. If k = 2 then this propagates
the state 1 on every automaton from j to n2 in C2 then from 1 to n1 in C1. In this second case we need to ensure that x 1 (= xo) is really set to 1 after
1
its update, but this is the case since x1 = 0 and x2 = 1, hence fo(x)= 1,

by the time o is updated. Hence these first updates set i1
to 1.

To finish, if x2
/= 0 (hence xn2
= 1) then update all the automata of C2

from i1 (= o) to i2 . When o is updated fo(x)=1 ⊕ 1 = 0 and so the value
1	n2
0 propagates as desired.
In a quadratic number of updates, set C1 to the alternating configuration
where x1 = 1, i.e. set C1 to 11(01)n1/2−1 if n1 is even and to 0(01)(n1−1)/2
if n1 is odd. This can be done as follows:
· for j = n1 to 2 do:
· update the automata of C1 from 1 to j







(i)
—→
(ii)
—→

Fig. 4. An example for Lemma 3.2 witha (4, 4) positive ⊕-BADC, from configuration (0000, 0001) to config- uration (0110, 0011). The algorithm works in two steps: first setting B in a fully alternating configuration, then updating each automaton according to its targeted state.
· update the automata of C2 from 2 to n2
In the above algorithm, the following invariant holds: after each iteration,

x1[n1, j] = (10)(n1—j)/2 and x2
= x1
= xo, hence fo(x) = x1	2

1 ⊕ x1 = x1. Indeed we start with x1 = 1 and x2
= 0 so by the end of

j	j	n1	n2
the first iteration x1	2 = xo = 1 ⊕ 0 = 1. Then, for the jth iteration,

we start with x1[n ,j + 1] = (10) n1−j+1 and with f (x)= x1
so we end up

1	2	o
j+1

with x1 = xn
= xo = x1
and so x1[n1, j]= (10)(n1—j)/2.

Similarly, force C2 to alternate in a quadratic number of updates (while pre- serving the alternating configuration in C1):
for j = n2 — 1 to 2 do:
update the automata of C2 from 1 to j
update the automata of C1 from n1 to 2
After each iteration, the following invariants hold: x2 is unchanged, x1 =
x2 = xo, fo(x) /= xo, and x1[2, n2] and x2[n2, j] are both alternating. The first two statements are direct translation of the instructions. The last two require the invariant hypotheses.
By the previous point all the invariants are satisfied before entering the

loop. Hence, right after its update xo /= x1
and xo /= x2
. So after its

update x2 = xo /= x2	(hence x2[n2, j] is alternating), and updating C1 in
j	j+1
reverse order leaves it alternating. This also restores the fact that xo /= fo(x)
since the state of i1 has been switched with the update of C1 while the state

of i2
has been left unchanged.

By the end of the two previous steps the system is in a configuration such
that fk(x) = xk for all Automata ik except Automata i1 and i2. The last
j	j	2	2
thing to do to reach a fully alternating configuration - where fi(x)= xi for
every automaton i but o - is thus to update C1 and C2 in reverse order (from
n1, respectively n2, to 2) and then update the central automaton o. This takes a linear number of updates.
Hence, the whole sequence takes a quadratic number of updates and it results in one of the following alternating configurations:

· (0(10)
n1−1
2  , 0(10)
n2−1
2  ) if n1 and n2 are odd,

n1
· ((10) 2 , 1(01)
n2−1
2  ) if n1 is even and n2 is odd,

n1	n2
((01) 2 , (01) 2 ) if n1 and n2 are even,
n1−1	n2
(1(01) 2  , (10) 2 ) if n1 is odd and n2 is even.
Let x denote the resulting alternating configuration, then any configuration xj

with at least one automaton ik in stable state (i.e. such that xjk = fk(xj)) is
j	j	j
reachable from x.
Indeed, xo = fo(x) and for all i /= o, xi = fi(x) so in a linear number of updates we can move from the configuration x to the configuration xˆ where

xˆo = xj
and
xˆi = fi(xˆ) for all i ∈/
{ij , o}. This is achieved by following

instructions:
· if ij /= o and xj
/= xo

o
· update o and the automata from nk to j in Ck.
Then, reaching xj from xˆ is straightforward: one simply needs to switch the state of the automata when necessary:
for j = n1 to 2 (in C1): update the automaton i1 if xˆ1 /= xj1;
j	j	j
for j = n2 to 2 (in C2): update the automaton i2 if xˆ2 /= xj2;

update the automaton ij .
j	j	j

These updates are efficient since for all i ∈/ {ij , o}, if xˆi /= xj then xj = xi =
k	i	i
fi(xˆ), which is the value returned by the update of i. Then, by definition of
xˆ, automaton o already has the right state. And, finally, by definition of ij ,
xjk = fk(xj), which is the value returned by fi after all the other automata
j	j
have been updated.
The second sequence takes a linear number of steps, so the whole sequence remains quadratic. This bound is tight since going from the configuration x = (10n1—1, 10n2—1) to a configuration xj where xj = fi(xj) for all Automata

i /= o (as for example the configuration xj = (0(10) n1−1 , 0(01) n2−1
if m and

n are odd) requires at least Σn1
j + Σn2
j = n1(n1—1) + n2(n2—1)
updates,

which is in θ((n1 + n2)2).
j=1
j=1	2	2
□

Remark 3.3 Note that if synchronous transitions are allowed, then every config- uration is reachable from any unstable configuration. Indeed, the above algorithm says that it is immediate if the target configuration is not unreachable, but it also tells us that if x is unreachable, one can still reach the configuration xˆ = xC1—{o},

o	o 1
o 2	1	2	1	2	1	2

since in that case fo(xˆ )= (xˆ )n1 ⊕ (xˆ )n2 = xˆn1 ⊕ xˆn2 = xn1 ⊕ xn2 = xn1 ⊕ xn2 =
fo(xo)= xo = xˆo (we assume B positive) and so xˆ is not unreachable.
Then for every automaton i1 of C1 — {o}, f 1(xˆ)= f 1(xC1—{o})= (xC1—{o})1	=

j	j	j
x1	1 i	1
j—1

j—1 = fj (x 1 )= xj—1, so the synchronous update of C1 — {o} changes the configu-
ration of the system from xˆ to x.
Lemma 3.4 In a ⊕-BAN N, if i and j are two automata such that there is a path from i to j, then for any conﬁguration x such that i is unstable in x there exists a conﬁguration xj reachable from x such that j is unstable in xj.
Proof. The proof is based on the fact that, in a ⊕-BAN, making a stable automaton become unstable can simply be achieved by switching the state of one of its incoming neighbours (because the state of an automaton depends on the parity of the number of its incoming neighbours in state 1).
So let i and j be two automata as described in Lemma 3.4, let p = i0, i1,..., ik

be a shortest path (in the interaction graph of N ) from i = i0 to j = ik and let il denotes the last automaton in p that is unstable. Then updating along p from il to ik—1 (so that nothing happens if l = k, i.e. if j is unstable) will lead to a configuration where j is unstable. This is straightforward from the remark above. The only subtlety is the choice of the path which must ensure that the update of one automaton only affects the next automaton on the path but not the automata after it, and this is true if one takes a shortest path.	□
Putting things together we can now describe the algorithm underlying the proof of Theorem 3.1:
Proof. Let B be an induced BADC of size greater than 3 in the BAN N and let x and xj respectively be the initial configuration and the target configuration described in Theorem 3.1. The configuration x is not stable so, by Lemma 3.4, it is possible to go from x to a configuration y where one automaton of B, hence B, is not stable. Then, using Lemmas 3.2 and 3.4, we claim that it is possible to set the state of every automata i outside of B to its value in xj while keeping B in an unstable configuration.
The idea is as follows: let i be an automaton that is not in B and let p = i0i1 ... ik be a shortest path (in the interaction graph of N ) from B to ik = i. Then, applying the algorithm from Lemma 3.2, we know how to reach a configuration where i0 is unstable and so, using the algorithm from Lemma 3.4, we know how to reach a configuration where i is unstable. From this configuration we can set the state of i to xj by updating i if necessary.
So, if we can guarantee that this process preserves the instability in B, then we can use it repetitively on every automaton outside of B to reach a configuration where B is unstable and where all automata outside of B are in the state specified by xj. Once this is done we only need to set B to its right value to reach xj and, since B is unstable, this can be done by using the algorithm from Lemma 3.2.
In fact, setting the automata outside of B to their state in xj cannot be done in any order. Indeed, the algorithm from Lemma 3.4 requires to switch the state of some automata outside of B (namely the one along the path from B to the automaton to be set up). Hence we need to guarantee that the automata that have already been treated are not switched again while processing the other automata. A way to ensure that is to compute a breadth first search tree of root B and to treat the automata in the order given by the tree from the leaves to the root, using the branches of the tree as the paths from B to the automata to be treated. An example of such ordering is given in Figure 5.
Moreover the use of Lemma 3.2 at the end of the update sequence requires that the restriction of xj to B is not unreachable for B (i.e. for B viewed as a ⊕-BADC whose local transition functions are fixed by its surrounding environment in xj). If this is not the case, we have to get around the problem by using the same kind of trick that the one used in the second step of the proof of Lemma 3.2 –when the stable state of the target configuration is not the central node o:

Let i is an automaton of N


such that fi(xj
)= xj (i exists since xj
is reachable),



Fig. 5. Example of update order using a breadth first tree.
and let p = i0 ... ik be a shortest path from i = i0 to B. Then we first reach the configuration xˆ such that (i) xˆj = xj if j ∈/ p, (ii) ik(∈ B) is such that the restriction of xˆ to B is reachable for B, and (iii) the state values of the automata in p are “alternating” in such a way that if we set up the state of the automata of p to their value in xj from ik to i1 then every time an automaton il is about to be set up, its predecessor in p must be unstable so as to enable l to switch state if necessary.
With such conditions it is easy to go from xˆ to xj: one only needs to set up p back up. As described in condition (iii), every automaton in p — {i0} will be able to switch state in turn if necessary, then, in the end, if i0 is not already in state xj

it will still be able to switch to the right state since fi(xj )= xj by assumption.
The configuration xˆ described above can be computed inductively by taking the
kth iteration, xˆk, of:
xˆ0 = xj

for l > 0, xˆl is inductively defined by: xˆl = xˆl—1 for all j ∈/ {il—1, il}, xˆl
= xj ,

and xˆl
Æ 1
is the solution of fi


Æ−1
j	j


(xˆl)= xˆl
Æ−1
iÆ	iÆ

Finally, to conclude the proof above, we still need to precise the way of using the algorithm from Lemma 3.4 that ensures that the instability of B is preserved by the updates outside of B.
So let z0 be the current configuration and let p = i0,..., ik be the path from B
to the automaton to be set up. Moreover, let j /= i0 be an influencer of i0 in B.
By assumption, B is unstable in z, so one can use Lemma 3.2 to put N in a configuration z0 where i0 is unstable, and such that:



z0 =
0i1
j
{i0,i1}
1 is an influencer of i0
(i1
∈ I(i0))
.

⎩ fj(z0
) if i1 is not an influencer of i0 (i1 ∈/ I(i0))

Actually, one can only guarantee that this is possible if B has one cycle of size at least 3, which enables to ask for a third automaton (different from i0 and j) to be stable in z0, making z0 reachable for B.
From there one can start applying Lemma 3.4:
Let il be the last automaton in p that is unstable. If l ≤ 1, then start updating p

from il to i1. This leaves N in a configuration z1 such that B is unstable. Indeed:
either nothing happened (l > 1) and so B is still unstable (because i0 is unstable in z0 for example).
or Automaton i1 is the only to have been updated and so:


if i
∈ I(i ), then z1 = z0 = f (z0i1 )= f (z1) and so j is unstable in z1;

1	0	j	j	j	j
if i1 ∈/ I(i0) then the neighbourhood of i0 has not changed so i0 is still unstable
in z1.
or both Automata i0 and i1 have been updated and so:
if i0 ∈/ I(i0) (i0 has no self loop) and if i1 ∈ I(i0), then i0 is still unstable (since it has changed and an odd number of its incoming neighbours have changed too);

if i


∈/ I(i ) then as previously z1 = z0 = f (z0{i0,i1}) = f (z1) and so j is

1	0	j	j	j	j
unstable in z1;
if i0 ∈ I(i0) then i0 is not an influencer of j (because B is an induced BADC of size 3 and j has been chosen to be the predecessor of i0 different from i0) so
f (z0{i1})= f (z0{i0,i1}), so z1 = f (z0{i0,i1}) which means as previously that j is
j	j	j	j
unstable in z1.
Now, let lj = max(2, l), lj is the last automaton of p to be unstable in z1. Then, again, B is unstable in z1 so we can use Lemma 3.2 to reach a configuration z2 such
that z2 = f (z1{iÆ′ ,...,in−1}) and z2 = z1 for all i ∈/ B. Moreover, since p was chosen
i0	i0	i	i
to be a shortest path, no automata in B influence the automata of index greater
than 2 in p. So the last automaton of p that is unstable in z2 is still il′ .
Hence we can finish running the algorithm of Lemma 3.4 (by updating the automata along p from il′ to in—1) and be sure that this leads to a configuration where in—1 is unstable. We also know that in this configuration B is unstable since
i has state f (z1{iÆ′ ,...,in−1}).
This last remark concludes the proof of Theorem 3.1.	□

Algorithmic complexity
The algorithm described above is quadratic in the worst case. However, its com- plexity highly depends on the structure of the network and/or the final configuration xj. For example, if every automaton in N is at bounded distance from the central node of an induced BADC of size greater than 3, then this algorithm becomes linear in n. Similarly, since the number of passes that are needed along a path depends on the number of alternating states (i.e. 01 or 10 patterns) along this path in xj, then if this number is less than a constant in any path the algorithm will also run in linear time. This is especially the case when xj is a fixed point of N and so every transient configuration can reach every stable state in a linear number of updates. Finally we need to point out the fact that this algorithm does not always provides the most efficient sequence of updates (for example it does not take into account the starting configuration) hence the complexity of this algorithm is only an upper bound on the length of the shortest path between two configurations. However,

let us notice that this bound can sometimes be reached, as when one move from configuration 10n—1 to configuration (10)n/2 in a positive ⊕-BADC of size n. These considerations on 01 patterns echo to the notion of expressiveness defined for the monotonic case in [13].
Fixed points and unreachable configurations
According to the definition, a configuration x is a fixed point for a mode if it has no outgoing arcs but self-loops in the transition graph associated to this mode. In the asynchronous update mode this means that for all i in V , fi(x)= xi. Hence, in a fixed point, the state of the automata along a nude path is completely determined by the head of this nude path. This leads to the following bound on the number of possible fixed points, that is related to the set of works [1,6,7].
Proposition 3.5 In any BAN N, the maximum number of ﬁxed points in the asyn- chronous mode A is 2k, where k is the number of automata i such that πi is of length 0 (i.e. i is an “intersection node” in some interaction graph of N).
Proof. It is enough to note that a configuration x is stable in A only if every automata along a nude path share the same state value in x. In other words, x is completely determined by the states of the intersection nodes of N .	□
This bound is rough and we believe that it is possible to lower it for subclasses of networks. However, if we define the contraction of a network to be the network obtained by removing any automaton i whose incoming maximal nude path πi has length greater than 1 and replacing the variable xi by the variable associated to the head of πi in the remaining local functions, then any BAN whose contraction results in the trivial network {fi(x)= xi}i∈V reaches the bound of 2k fixed points. Also, notice that in the asynchronous mode, the unreachable configurations
of a network N = {fi}n	are exactly the fixed points of the reverse network
i=1		
NR = {f R}n	defined by f R(x)= fi(xi). N and NR are of the same type hence
i	i=1	i
the maximum number of fixed points for the type of N will also be its maximum
number of unreachable configurations. Moreover, this implies that if all the net- works of a given type are behaviourally isomorphic then the number of unreachable configurations and the number of fixed points will be equal. These remarks will be illustrated by the description of the ATGs of ⊕-Flowers and ⊕-Cycle Chains presented in the next section.
Study of some specific ⊕-BANs
We now give a complete characterisation of two specific types of ⊕-BAN: the ⊕-BA Flowers and the ⊕-BA Chains. For each of these two types of BANs, we describe their behavioural isomorphism classes and give their number of fixed points and unstable configurations. This illustrates the results of Section 3, and introduces a new method for computing isomorphism classes through the use of rewriting on the interaction graph of the BANs: two BANs will be equivalent if one can be rewritten into the other.

⊕-BA Flowers
A ⊕-BA Flower (⊕-BAF) with m petals is defined as a set of m cycles that intersect at a unique automaton o = i1 = ... = ik (⊕-BADCS correspond to the
1	1
case m = 2). The following states that there are at most two isomorphism classes
fora given type of flower, i.e. for a given number of petals m and size (n1,..., nm).

Proposition 4.1 The set of ⊕-BAF with m petals of size (n1,..., nm) admits one isomorphism class if m is even and two if m is odd.
Proof. Similarly to what is done in Section 2 for ⊕-BADCs, we restrict our study to canonical ⊕-BAFs, that are ⊕-BAFs such that the only negative literals are in the local function of o (Theorem 2.3). According to the identity b1 ⊕ b2 = b1 ⊕ b2 that holds for every Boolean values b1, b2, the sign of any pair of negative literals cancel in fo. So there are at most two isomorphism classes for a given type of flower: the positive one, where fo has only positive literals (which thus corresponds to BAFs with an even number of negative cycles), and the negative one where fo has exactly one negative literal (which thus corresponds to BAFs with an even number of negative cycles).
Moreover, when m is even, the bijection φ(x)= xV over the set of configurations actually defines an isomorphism between the ATGs of the negative and the positive
⊕-BAF of same type. Therefore, for m even, the negative and positive classes coincide. On the contrary, when m is odd, the two classes remain distinct since, in particular, they do not have the same number of fixed points, as this is shown in the next proposition (4.2).	□
Proposition 4.2 A positive ⊕-BAF with m petals has a unique stable conﬁgura- tion, 0n, if m is even and two stable conﬁgurations, 0n and 1n, if m is odd. A negative ⊕-BAF (with an odd number of petals) does not have any ﬁxed point.
Proof. There are several ways to compute the fixed points of a ⊕-network. One way is to fix the state of one automaton and to propagate the information that this choice implies on the state of the other automata in the network, making new choices when necessary, until having completely fixed the configuration or until reaching a contradiction.
For example, in a positive ⊕-BAF F with an even number of petals, any config- uration x that contains an automaton i in state 1 is unstable. Indeed suppose for the sake of contradiction that x is stable, then o, and so every automata in F, are in state 1 (because updating from o to i implies that xi = xo), so x = 1n. But 1n
is not stable since fo(x)= Lm  1 = 0. This is a contradiction. Similarly we prove
for a negative ⊕-BAF with an odd number of petals, if a configuration contains
an automaton in state 0, respectively an automaton in state 1, then it cannot be stable, and so the BAF has no fixed points.	□
The results above allow us to fully characterise the ATG, GA, of any ⊕-BAF,
F, of a given type:
if F has an even number of petals then F and FR are in the same isomorphism



—	(1)	+
—	—	—
(5)
+	+	+

...	. .. ≡
—
...	. .. 
+
...	. .. ≡
+	+	+
...	. .. 
+	+	+



+	(2)	—
+	+	—
(6)
—	—	+

...	. .. ≡
—
...	. .. 
+
...	. .. ≡
+	+	+
...	. .. 
+	+	+



—	—	(3)	—	+
—	+	—
(7)
—	—	+

...  ≡
+	+
... 
+	+
...	. .. ≡
+	+	+
...	. .. 
+	+	+



+	—	(4)	+	+
+	—	—
(8)
—	+	+

...  ≡
+	+
... 
+	+
...	. .. ≡
+	+	+
...	. .. 
+	+	+


Fig. 6. Table of ⊕-equivalences.
class (the unique positive class). Hence, GA, has exactly one unreachable config- uration, one fixed point, and one SCC of 2n — 2 transient configurations.
if F has an odd number of petals then GA can have four different shapes depend- ing on the size of F and depending on its isomorphism class. Indeed, F and FR are isomorphic if and only if F has an even number of petals of even sizes and a self loop, or if it has an odd number of petals of even sizes and no self loop. Hence GA has one of the following forms: (i) a unique attractor of size 2n if F and FR are in the negative class ; (ii) two unreachable configurations, two fixed points, and one SCC of 2n — 4 transient configurations if F and FR are in the positive class; (iii) two fixed points, and one SCC of 2n — 2 transient configurations if F is in the positive class and FR in the negative class ; (iv) two unreachable configurations and one attractor of size 2n — 2 if F is in the negative class and FR in the positive class.

⊕-BAC Chains
A ⊕-BAC Chain (⊕-BACC) of length m is described by a set of m cycles, Ck, and m— 1 intersection automata, ok, such that for all 1 ≤ k < m, Ck intersects Ck+1 at a unique point ok = ik = ik+1. As previously, we characterise the isomorphism
1	lk
classes and the ATG of this type of BANs.
Isomorphism classes
Proposition 4.3 The set of ⊕-BACCs of length m and size (n1,..., nm) admits one isomorphism class if m— 1 is not a multiple of 3 and two if m— 1 is a multiple of 3.

As in the case of ⊕-BAFs, the proof of Proposition 4.3 is done in two steps.
Point 1. We first show that the set of ⊕-BACCs of a given type (n1,..., nm) is divided into two classes: the positive class and the negative class, which respec- tively corresponds to the isomorphism class of the BACC (n1,..., nm) where all path are positive, and the isomorphism class of the BACC (n1,..., nm) where all paths are positive except the one from i1 to i1 that is negative.
2	1
Point 2. We then prove that, in fact, when m — 1 is not a multiple of 3, the two classes coincide since the positive BACC and the negative BACC are isomorphic in this case.
The proof of these two points is based on the equivalences presented in Figure 6. Each pattern of these equivalences describes a subnetwork where every intersection automaton is a ⊕-automaton and every arc represents a signed path of arbitrary length (hence containing possibly several automata). These equivalences have to be understood as follows: given a BAN such that the left pattern of an equivalence appears in its interaction graph, then this BAN is behaviourally isomorphic to the BAN that has the same interaction graph except that the left pattern has been replaced by the right pattern of the equivalence, no matter what the outgoing dashed arcs are and no matter their number. In other words, Figure 6 presents a set of interaction graph rewriting rules that produce equivalent networks according to the (behavioural) isomorphism relation.
The following lemma (4.4) says in particular that it is enough to prove that the interaction graphs of two BANs can be rewritten one into an other using the equiv- alences from Figure 6, to prove that the two corresponding BANs are equivalent.
Lemma 4.4 The interaction graph rewriting rules depicted in Figure 6 preserve the behavioural isomorphism equivalence.

Proof. Equivalences (1) and (2) only translate the well known identities b1 ⊕ b2 =
b1 ⊕ b2 and b1 ⊕ b2 = b1 ⊕ b2 for any Boolean values b1 and b2.
The proofs of the other equivalences are a bit longer but do not present any difficulty. We now present a proof for the third equivalence, proofs for the other equivalences are similar:
Let N = {fi} and Nj = {fj} be two BANs whose interaction graphs only differ by the pattern shown in Equivalence (3). We denote by C1, C2 the two cycles of the pattern. Similarly, o1 and o2 denote the intersection automata and Cu denotes the upper half-cycle of C2. We are going to prove that N and Nj are isomorphic by giving a bijection ϕ : V → V j and a set of local bijections {φi : B → B}i∈V satisfying the conditions from Lemma 2.4.
Let ϕ be the identity over the set of automata and let φi = negB if i ∈ C1 ∪ Cu ∪
{o1} and φi = idB otherwise. We need to check that φi(fi(x)) = fj(φi(x)) for all automata i in the network. This is immediate for all automata that do not belong to C1 ∪ Cu ∪ {o1, o2} since for these automata we have used the identity everywhere. Now, if i ∈ C1 ∪ Cu, then φi(fi(x)) = φi(pred(i)) = pred(i) = φpred(i)(pred(i)) = fj(φ(x)) and so the identity holds. Finally it remains to check that the identity

holds for Automata o1 and o2. This is the case since:
φo1 (fo1 (x)) = φo1 (pred1(o1) ⊕ pred2(o1)) = pred1(o1) ⊕ pred2(o1)


= φpred (o )(pred1(o1)) ⊕ φpred (o )(pred2(o1)) = fj
(φ(x)),

1  1
and
2  1	o1

φo2 (fo2 (x)) = φo2 (pred1(o2) ⊕ pred2(o2)) = pred1(o2) ⊕ pred2(o2)
= φpred (o )(pred1(o2)) ⊕ φpred (o )(pred2(o2)) = fj (φ(x)).
1  2	2  2	o2
□
Using the equivalence of Lemma 4.4 we can now finish the proof of Proposi- tion 4.3. As mentioned above, we first show that the interaction graph of any
⊕-BACC can be rewritten into an interaction graph with at most one negative path
from i1 to o1(= i1). This proves that there are at most two isomorphism classes for
2	1
a given ⊕-BACC type, the positive one and the negative one. Then we prove that
if m — 1 is not a multiple of 3 this negative path can actually be removed by an other sequence of rewrites, hence proving that the two classes are equal in this case.
Proof. (Point 1.) As usually we focus on canonical BANs, since this already reduces the number of cases to consider. Then using Equivalences (1) and (2) from Figure 6 we rewrite the interaction graph of any of the canonical ⊕-BACC into interaction graphs where the only negative paths are paths from oi to oi+1 for i ∈ {1,..., m—2}, that is, the only negative paths are “on the top”.
Then, inductively on the negative path of higher index (the negative path from oi to oi+1 such that i is maximal), we use the equivalences (5), (6), (7) and (8) from left to right to lower this index by at least one after every rewrite. We stop the rewriting when i = 0 or when there are no negative paths left. In other words we do an inductive sequence of rewrites on the “right most” negative path so as to “push” this path to the left until reaching the end of the chain or making it disappear. An example of such a rewrite sequence is presented in Figure 7.
By Lemma 4.4 the above rewritings prove that any ⊕-BACC is isomorphic to a
⊕-BACC of same structure with at most two negative paths on its first two cycles. Finally the equivalences (3) and (4) reduce the four base cases (++,+—,—+,——) obtained this way to two: the positive case (++) and the negative case (—+).  □
Proof. (Point 2.) We now consider the interaction graph of a negative ⊕-BACC of length m. By Equivalence (2), this network is isomorphic to a ⊕-BACC of same structure with only one negative path on the first or on the second bottom half- cycle. Then, viewing the BACC upside-down, we can reuse the equivalences (6) and
(8) alternatively so as to push this negative path to the right. Every time we apply the equivalences (6) and (8) successively the negative path is pushed 3 half-cycles to the right. Finally Equivalence (4) tells us that if the negative path is pushed to the second last bottom half-cycle then the ⊕-BACC is in the positive class. This can only happen if m — 1 ≡ 1 mod (3) or if m — 2 ≡ 1 mod (3), depending on if we start from the first or from the second bottom half-cycle respectively. In other words, this is the case if m — 1 is not a multiple of 3.
Moreover, the equivalences presented in Figure 6 are exhaustive, i.e. any other

–	+	–	–	–
+	–
+	+	+	+	+
≡	(1)
–	+	–	–	+
+	+

+	+	+
+	+
≡	(8)

–	–	+	+	+
+	+




—
+	+

+

+	+
+	+	+
≡	(8)
+	+	+	+
+
+	+	+

Fig. 7. Example of the rewrite of a cycle chain of type (1,2,2,2,2,2,1) into a negative cycle chain of type (1,2,2,2,2,2,1)

equivalences involving ⊕-chains can be deduced from these eight equivalences. So, the argument above also proves that a positive ⊕-BACC and a negative ⊕-BACC cannot be isomorphic unless m — 1 is a multiple of 3. In other words, if m — 1 ≡ 0 mod (3) there are always two isomorphism classes, the positive one and the negative one.	□

ATG
For every type of ⊕-BACCs, we now study the number of fixed points of each of their behavioural isomorphism classes so as to precise the general picture of their ATG given by Theorem 3.1.
Proposition 4.5 A positive ⊕-BACC of length m and size n has a unique ﬁxed
m−1
point, 0 , if (m — 1) /≡ 0 mod (3) and has two ﬁxed points, 0  and (101)  , if
(m— 1) ≡ 0 mod (3). A negative ⊕-BACC (of length m ≡ 1 mod (3)) has no ﬁxed point.
Proof. In a stable configuration all the nodes of a given nude path have the same state, hence from now on we focus on determining the states of the intersection automata ok. As this is done in Section 4 for ⊕-BAF, we determined the fixed points of a positive ⊕-BACC by fixing the state of one of its automata and propagating the information induced until having to make a new choice or reaching a fixed point or a contradiction. Here, we start by fixing Automaton o1 (i.e. the “left most”

automaton) and by induction on the two possible cases (xo1 = 0 and xo1 = 1) we show that this completely determines the state of the other automata if x is a fixed point.
if xo1 = 0, then o1 is stable if and only if xo2 = 0 and, recursively, for all 1 < k ≤ m — 2 , if xok−1 = 0 and xok = 0 then ok is stable if and only if

xok+1
= 0. Hence 0m is the unique fixed point such that x0 = 0.

Similarly, if xo1 = 1 then o1 is stable if and only if xo2 = 0. Then, we have three induction cases for all 1 < k ≤ m — 2: (1) if xok−1 = 1 and xok = 0 then ok is stable if and only if xok+1 = 1 ; (2) if xok−1 = 0 and xok = 1 then ok is stable if and only if xok+1 = 1; (3) if xok−1 = 1 and xok = 1 then ok is stable if and only if xok+1 = 0. Hence the only way for the last intersection automaton, om—1, to be stable when xo1 = 1 is that (m— 1) ≡ 0( mod 3), and the corresponding configuration is (101)(m—1)/3.
This concludes the proof of the first statement.
To show the second statement one only needs to realise that having a stable configuration for a negative ⊕-BACC of length m ≡ 1 mod (3) amounts to having a stable configuration starting with a 1 for a ⊕-BACC of size m—1, which is impossible from the proof above. Indeed, if xo1 = 0 then Automaton o1 cannot be stable no matter the state value of Automaton o2 in the configuration. Hence, if x is a stable configuration xo1 must be 1. This forces xo2 to be 1 too (otherwise Automaton o1 is not stable). So, if x is stable then xo2 ... xom is a stable configuration starting with a 1 for a positive ⊕-BACC of size m — 1. This is a contradiction. So there are no stable configurations for the negative ⊕-BACC of length m ≡ 1 mod (3).   □

According to Proposition 4.3, if N is a ⊕-BACC of length m and size n such that m — 1 /= 0 mod (3), then there is only one behavioural isomorphism class and so, similarly to what we have done for ⊕-BAFs, it is possible to characterise

completely the ATG of N using Proposition 4.5: GA
has exactly one unreachable

configuration, one fixed point, and one SCC of 2n — 2 transient configurations.
The case where m — 1 is a multiple of 3 is more complex because there are no easy ways to tell whether a network belongs to the positive or the negative class of its type, other than to compute its reduction graph as this is done in the proof of Proposition 4.3. Moreover, the class of the reverse network also depends on the length of each half-cycle in the ⊕-BACC, so describing each possible case would be tedious. However, summarising the results above, we can still state that there is at most two fixed points and two unreachable configurations in the transition graph of a ⊕-BACC of length m — 1 ≡ 0 mod (3), or, to be more precise we can say that this transition graph has one of these four forms:
a SCC of size 2n — 4, two fixed points and two unstable configurations (case N
and NR are from the positive class);
a SCC of size 2n — 2 and two fixed points (case N is positive and NR is negative);
a SCC of size 2n — 2 and two unreachable configurations (case N is negative and
NR is positive);

a SCC of size 2n (case both N and NR are negative).
Interpretations and perspectives
Through general results and their application to particular classes of interaction graphs, the present work launches the description of asymptotic dynamical be- haviours of ⊕-BANs under the asynchronous update mode. By this means, it contributes to improve our understanding of the wild domain of non-monotonic Boolean automata networks. Theorem 3.1 and Section 4 suggest for example that non local monotonicity brings both entropy and stability to BANs since the high expressiveness of the resulting networks helps them to converge to fix points instead of getting stuck into larger attractors. In the context of cellular reprogramming, the small number of attractors in ⊕-BANs as well as the small number of irreversible configurations suggest that the genes involved in a ⊕-cluster won’t be good candi- dates for being reprogramming determinants [2]. Hence this might help to reduce the number of genes to consider.
The notion of behavioural isomorphism also reveals to be a powerful tool for factorising proofs when it comes to the study of a particular family of BANs. Even if finding a proper set of interaction graph rewritings may be a bit challenging, it results in a very interesting and comprehensive tool that highlights which charac- teristics of the interaction graphs really matter in the dynamical behaviours of the BANs.
We believe that most of the results obtained could be refined or extended to some other types of (⊕)-BANs. For example it should be possible to allow some arcs between or inside the cycles of a ⊕-BADC without changing the general shape of its corresponding ATG. These kinds of refinements draw a logical line for further works.
Another interesting question would be directed to the study and comparison of asymptotic behaviours under different update modes. From this perspective, the algorithms we describe and the ATG we get for strongly connected ⊕-BANs with an induced BADC of size greater than 3 suggest that the addition of k-synchronism, that is when one allows k automata to update simultaneously, make the set of unreachable configuration disappear if k is greater than the size of the smallest cycle in an induced BADC of the network.

References
J. Aracena, A. Richard, and L. Salinas. Maximum number of fixed points in AND-OR-NOT networks.
Journal of Computer and System Sciences, 80:1175–1190, 2014.
I. Crespo, T.M. Perumal, W. Jurkowski, and A. del Sol. Detecting cellular reprogramming determinants by differential stability analysis of gene regulatory networks. BMC Systems Biology, 7:140, 2013.
J. Demongeot, M. Noual, and S. Sen´e. Combinatorics of Boolean automata circuits dynamics. Discrete Applied Mathematics, 160:398–415, 2012.
G. Didier and E´. Remy. Relations between gene regulatory networks and cell dynamics in Boolean models. Discrete Applied Mathematics, 160:2147–2157, 2012.


E. S. El-Mallah and C. J. Colbourn. The complexity of some edge deletion problems. IEEE Transactions on Circuits and Systems, 35:354–362, 1988.
M. Gadouleau, A. Richard, and E´. Fanchon. Reduction and fixed points of Boolean networks and linear network coding solvability. 2014. Submitted (arXiv:1412.5310).
M. Gadouleau, A. Richard, and S. Riis. Fixed points of Boolean networks, guessing graphs, and coding theory. SIAM Journal on Discrete Mathematics, 2015. In press (arXiv:1409.6144).
C. Georgescu, W. J. R. Longabaugh, D. D. Scripture-Adams, E. David-Fung, M. A. Yui, M. A. Zarnegar,
H. Bolouri, and E. V. Rothenberg. A gene regulatory network armature for T lymphocyte specification.
Proceedings of the National Academy of Sciences, 105:20100–20105, 2008.
J. J. Hopfield. Neural networks and physical systems with emergent collective computational abilities.
Proceedings of the National Academy of Sciences of the USA, 79:2554–2558, 1982.
J. J. Hopfield. Neurons with graded response have collective computational properties like those of two-state neurons. Proceedings of the National Academy of Sciences of the USA, 81:3088–3092, 1984.
A. S. Jarrah, R. Laubenbacher, and A. Veliz-Cuba. The dynamics of conjunctive and disjunctive Boolean network models. Bulletin of Mathematical Biology, 72:1425–1447, 2010.
S. A. Kauffman. Metabolic stability and epigenesis in randomly constructed genetic nets. Journal of Theoretical Biology, 22:437–467, 1969.
T. Melliti, M. Noual, D. Regnault, S. Sen´e, and J. Sobieraj. Asynchronous dynamics of Boolean automata double-cycles. In Proceedings of UCNC, volume 9252 of Lecture Notes in Computer Science, pages 250–262. Springer, 2015.
T. Melliti, D. Regrault, A. Richard, and S. Sen´e. On the convergence of Boolean automata networks without negative cycles. In Proceedings of Automata, volume LNCS 8155, pages 124–138. Springer, 2013.
L. Mendoza, D. Thieffry, and E. R. Alvarez-Buylla. Genetic control of flower morphogenesis in arabidopsis thaliana: a logical analysis. Bioinformatics, 15:593–606, 1999.
M. Noual. Synchronism vs asynchronism in boolean networks. arXiv:1104.4039, 2011.
M. Noual. Updating automata networks. PhD thesis, ´ecole normale sup´erieure de Lyon, 2012. http:
//tel.archives-ouvertes.fr/tel-00726560.
M. Noual, D. Regnault, and S. Sen´e. About non-monotony in Boolean automata networks. Theoretical Computer Science, 504:12–25, 2012.
M. Noual, D. Regnault, and S. Sen´e. Boolean networks synchronism sensitivity and XOR circulant networks convergence time. In Full Papers Proceedings of Automata’12, volume 90 of Electronic Proceedings in Theoretical Computer Science, pages 37–52. Open Publishing Association, 2012.
E. Remy, B. Moss´e, C. Chaouiya, and D Thieffry. A description of dynamical graphs associated to elementary regulatory circuits. Bioinformatics, 19:172–178, 2003.
F. Robert. Discrete iterations: a metric study, volume 6 of Springer Series in Computational Mathematics. Springer, 1986.
D. Thieffry and R. Thomas. Dynamical behaviour of biological regulatory networks–ii. immunity control in bacteriophage lambda. Bulletin of mathematical biology, 57:277–97, 1995.
R. Thomas. Boolean formalization of genetic control circuits. Journal of Theoretical Biology, 42:563– 585, 1973.
