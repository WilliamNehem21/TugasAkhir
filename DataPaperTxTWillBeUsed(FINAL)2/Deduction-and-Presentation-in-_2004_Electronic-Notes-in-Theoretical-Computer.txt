 Electronic Notes in Theoretical Computer Science 93 (2004) 161–182 
www.elsevier.com/locate/entcs




Deduction and Presentation in ρLog
Mircea Marin1 ,3
Johann Radon Institute for Computational and Applied Mathematics Austrian Academy of Sciences
Linz, Austria
Florina Piroi2 ,4
Research Institute for Symbolic Computation Johannes Kepler University
Hagenberg, Austria

Abstract
We describe the deductive and proof presentation capabilities of a rule-based system implemented in Mathematica. The system can compute proof objects, which are internal representations of deduction derivations which respect a specification given by the user. It can also visualize such deductions in human readable format, at various levels of detail. The presentation of the computed proof objects is done in a natural-language style which is derived and simplified for our needs from the proof presentation styles of Theorema.
Keywords: Rule-based deduction, proof presentation, rewriting.


Introduction
One of the main problems of mathematical knowledge management is to struc- ture the knowledge from various mathematical sources in a way which is suit- able for testing and deriving new mathematical results. A promising approach

1 Mircea Marin has been supported by the Austrian Academy of Sciences.
2 Florina Piroi has been supported by the Austrian Science Foundation FWF, under the SFB grant F1302.
3 Email: Mircea.Marin@oeaw.ac.at
4 Email: fpiroi@risc.uni-linz.ac.at



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2003.12.033

to solve this problem is to express the knowledge as collections of transforma- tion rules, and to control the lookup for new results via user-defined strategies. The derivation of a new result is witnessed by a sequence of transformation steps, where each step is an instance of a transformation rule. The purpose of a strategy is to guide the search of such derivations by imposing a regular structure on the sequence of rule applications which constitute them.
The success of this approach relies on the availability of a system with programming primitives for rules and strategies. For this purpose, we have developed a programming system called ρLog. ρLog is a renamed version of the rule-based programming system FunLog [7,8]. We did this in order to avoid confusing it with FUNLOG [13], a programming system of the eighties. ρLog is a suitable environment for specifying and implementing deduction systems in a language based on rules whose application is controlled by user-defined strategies. More precisely, ρLog allows:
to program non-deterministic computations by using the advanced features of Mathematica [15], like matching with sequence patterns, and access to state-of-the-art libraries of methods for symbolic and numeric computation;
to program rules l whose reduction relation →l can be defined, possibly recursively, in terms of already defined reduction relations →l1 , ..., →ln ;
to enquire whether, for a given expression E and rule l, there exists an expression x such that the derivation relation E →l x holds. We denote such a query by ∃?x : E →l x.
to generate proof objects which encode deductions that decide the validity of a formula ∃x : E →l x. The system has the capability to visualize such deductions in human readable format, at various levels of detail.
We decided to implement ρLog in Mathematica mainly because this com- puter algebra system has advanced features for pattern matching and for computing with transformation rules. These features provide good support
for implementing a full-fledged rule-based system. Mathematica also offers a
very good support for symbolic and numeric computations. Another reason is that rule-based programming, as envisioned by us, could be used efficiently to implement provers, solvers, and simplifiers which could, then, be integrated in the Theorema framework [3]. Since Theorema is implemented in Mathem- atica, a Mathematica implementation of a powerful rule-based system may become a convenient programming tool for Theorema developers.
We refer to [10] for a complete description of the programming capabilities of our system, and to [15] for a description of the pattern matching constructs of Mathematica. The following example shows a problem which can be reduced to a query for ρLog, and how we can find a solution with ρLog.

Example 1.1 Consider the functions f1 : (−∞, 0) → R, f2 : (−∞, 1) → R, g : (0, ∞) → R defined by f1(x)= x + 7, f2(x)= x + 4, g(x)= x/2. Consider, now, the non-deterministic operation f : (−∞, 1) → R defined by
f (x)=  f1(x) if x < 0,

We want to program a rule which encodes the partially defined and non- deterministic computation of g(f (x)) for all x ∈ R.
First, we encode the functions f1, f2 and g as ρLog transformation rules
"f1", "f2" and "g":
DeclareRule[x Real/; (x < 0) :→ x + 7, "f1"]; DeclareRule[x Real/; (x < 1) :→ x + 4, "f2"]; DeclareRule[x Real/; (x > 0) :→ x/2, "g"];
Each call DeclareRule[patt :→ rhs, l] declares a new rule patt :→ rhs which is named l for later reference. The construct x Real specifies the pattern variable x which stands for a real value. All patterns have, in this example, side conditions which impose additional constraints on the values allowed for
x. For instance, rule "f1" requires the value of x to be negative (x < 0).
We convene to write →l for the reduction relation associated with a rule l. For example, we have 0.5 →"f2" 4.5 because 0.5 is a real number smaller than 1 which can be replaced by "f2" with 0.5+ 4 = 4.5.
The call
SetAlias["f1" | "f2", "f"];
declares the rule "f" whose reduction relation coincides with →"f1" ∪ →"f2"
and, therefore, it encodes the computation of f .
The call
SetAlias["f" ◦ "g", "fg"];
declares the rule "fg" whose associated reduction relation →"fg" coincides with the composition →"f" ◦ →"g" of the relations →"f" and →"g". 5 It is obvious that x →"fg" r iff r is a possible result of the computation g(f (x)). Thus, the rule "fg" encodes the computation which we look for.
The call ApplyRule[E , "fg"] enquires the system to decide whether, for a given expression E , the operation g(f (E )) is defined or not. If the oper- ation is defined then the call yields a possible result, otherwise it returns E

5 Note that the rule composition "f" ◦ "g" does not correspond to the composition f ◦ g
as understood in mathematics, but to the composition g ◦ f .

unevaluated. For instance, the call:
ApplyRule[−7.1, "fg"]
returns −7.1 because ∄x, y : (−7.1 →"f" y) ∧ (y →"g" x), and
ApplyRule[0.2, "fg"]
returns 3.6 because (0.2 →"f" 7.2) ∧ (7.2 →"g" 3.6).	 
The rest of the paper is structured as follows. Section 2 describes the main programming principles and constructs of ρLog. In Section 3 we describe the general structure of deduction derivations in ρLog. Section 4 is about proof objects, which constitute the internal representation of deduction derivations. Section 5 gives an account to the methods provided by ρLog to manipulate proof objects, and to view the encoded rule-based proofs in a human-readable format. Section 6 concludes.

Programming Principles
In this section we introduce the concepts of ρLog rule, ρ-valid expression, and describe how rules can be composed and applied.
Rules and Expressions
Rules are the main programming concept of ρLog. They specify partially defined and non-deterministic computations. Formally, a rule is an expression l :: patt :→ rhs where l is the rule name, patt is a pattern expression and rhs specifies a possibly non-deterministic computation in terms of the variables which occur in patt .
The main usage of rules is to apply them on expressions. Any expression which can be represented in the language of Mathematica [15] is a valid input expression for ρLog. Moreover, an expression may contain a distinguished number of selected subexpressions. The current implementation of ρLog is capable to apply rules on expressions with a (possibly empty) sequence of selected subexpressions E1, ..., En such that Ei+1 is a subexpression of Ei whenever 1 ≤ i < n. Such expressions are called ρ-valid.
Thus, the expressions which are meaningful for the current implementation of ρLog have at most one innermost selected subexpression.
When we want to emphasize that a ρ-valid expression E has the innermost selected subexpression E ', then we will write E [[E ']]. We may also write E [[E ]] when E has no selected subexpressions, and E [[E '/E '' ] for the expression

obtained from E [[E ' ] by replacing the distinguished subexpression E ' with the unselected expression E ''.
The notation E [[E ] is ambiguous: either E has no selected subexpressions or E is selected itself. We allow this ambiguity because it is harmless in our framework. In illustrative examples we will simply underline the selected subexpressions of an expression as in the following:
Example 2.1 Take the expressions

E1 = f[f[x, e], e], E2 = f[x, e], E3 = f[f[f[x, e], x], y], E4 = f[f[x, e], f[e, x]].

E1, E2, E3 are ρ-valid, whereas E4 is not ρ-valid because it has two innermost selected subexpressions.
We can write E1[[E1]], E2[[E2]] and E3[[f [x, e]]] to give information about the innermost selected subexpressions (if any) of these expressions. We have
E1[[E1/z]] = z, E2[[E2/z]] = z, E3[[f[x, e]/z]] = f[f[z, x], y].	 

In the sequel we will assume implicitly that E, E', E'', E1, E2, . . . denote
ρ-valid expressions, and l, l', l1, l2, . . . denote ρLog rules.


Rule Application
There are two procedure calls which trigger the application of a rule l on a ρ-valid expression E : ApplyRule[E , l] and ApplyRuleList[E , l]. The first call attempts to apply an already declared rule l :: patt :→ rhs on E by looking at the innermost selected subexpression of E , if any. ApplyRule[E , l] computes
E1 = E [[E '/E '']] if we have E [[E ' ] and it is possible to identify a substitution θ for which θ(patt )= E ' and the computation θ(rhs) can be carried out to produce a result E ''. In this case we write E →l E1.
E , otherwise. In this case we write E /→l .
We emphasize that the binary relation →l may not be one-to-one because either (1) the matching substitution θ for which θ(patt )= E ' is not unique, or
(2) there may be more than one possibilities to evaluate the instance θ(rhs) to a result (as in Example 1.1). These two sources of non-determinism are discussed in more detail in [10].
The call ApplyRuleList[E , l] will compute the possibly empty list of ρ- valid expressions {E ' | E →l E '}.

Combining Rules
The programming primitives of ρLog are the basic rules. These are named
Mathematica transformation rules declared via a call
DeclareRule[patt :→ rhs, l]
where patt :→ rhs is a Mathematica specification of a transformation rule [15] and l is a string which identifies uniquely the newly declared rule.
Rules can be combined into more complex rules. ρLog provides the fol- lowing combinators to program rules:
choice: If l1,... , ln are rules then l1 | ... | ln is a rule with E1 →l1 |...|ln E2 iff
E1 →li E2 for some 1 ≤ i ≤ n,
composition: If l1, l2 are rules then l1 ◦ l2 is a rule with E1 →l1 ◦l2 E2 iff there exists E such that E1 →l1 E and E →l2 E2,
reflexive-transitive closures: If l1, l2 are rules then Repeat[l1, l2] is a rule

with E1 →Repeat[l ,l ] E2 iff there exists E such that E1 →∗
E and E →l
E2.

We write →∗
1 2	l1	2
for the reflexive-transitive closure of →l1 .

Similarly, Until[l2, l1] is a rule with the same denotational semantics as
Repeat[l1, l2]; the only difference is that Repeat[l1, l2] applies l1 as many times as possible before applying l2 , whereas Until[l2, l1] applies l1 repeat- edly until l2 is applicable.
normal form: If l is a rule then NF[l] is a rule with E1 →NF[l] E2 iff E1 →∗ E2
and E2 /→l . Also, E →NFQ[l] E iff E /→l .
rewrite rule: If l1 is a rule then we can introduce the rule l with E →l E1 iff there exists a subexpression E ' of E such that E ' →l  E '' and E1 = E [[E '/E '']]. l is called the rewrite rule induced by l.
The operational semantics of rewriting depends on the choice of the subex- pression on which l1 can act. Introducing the rule together with its choice strategy can be done by a RWRule[ ] call. (See the following section.)
To make the combination of rules easier and more intuitive, we can define aliases via SetAlias[ ] calls, like we did in Example 1.1.

Rewriting
We continue now with a description of how rewriting is implemented in ρLog. A rewrite step can be regarded as a composition of two steps: one which selects the subexpression to be rewritten, followed by another one which rewrites it. To achieve suitable selection strategies for rewriting, we have designed two kinds of rules:

the basic rule "Rw" whose relation is E [[E ']] →"Rw" E [[E '/E ']]. This means that we add a selection to the innermost selected subexpression of E . If E has no selected subexpressions then we add a selection to it as a whole.
selection shift rules, which can shift the innermost selection on a proper subexpression of the innermost selected subexpression. Selection shift rules are important for navigating through the subexpressions of an ex- pression, until we reach one which can be rewritten.
Formally, a selection shift rule l is characterized by a computable function
shiftl and a rule rl, such that
E1 →l E2 iff ∃E ' ∈ shiftl[E1] such that E ' →rl E2.
It is assumed that shiftl[E1] is a finite list of values for every input E1. ρLog has only one built-in selection shift rule, SEL[l], whose applicative
behavior is defined as a side-effect of a call
RWRule[ l1, l, Traversal → val, Prohibit → {f1,... , fn}]	(1) with val ∈ {"LeftIn", "LeftOut"} and {f1,... , fn} is a list of Mathematica
symbols. The option Traversal defines the choice strategy of the rewrite rule. Traversal → "LeftIn" will make the selecting process look for a rewritable subexpression of the input expression in leftmost-innermost order, while with Traversal → "LeftOut" will look in the leftmost-outermost order.
When Prohibit is given a list of symbols {f1,... , fn}, the selection process will ignore the subexpressions of the expressions with the outermost symbol being one of f1,... , fn. The default value of Prohibit is {}, i.e., any subex- pression might be selected and rewriting can be performed everywhere.
The call (1), besides stating that l is a rewrite rule induced by l1, declares the selection shift rule SEL[l] to be associated with the computable function shiftSEL[l] defined by

1	m
	f /∈ {f ,... ,f }, and
	'	1	'	n

shiftSEL[l][E [[E ']]] =

Ei = E[[E /f [E1,... , Ei,... , Em]]]
for all i ∈ {1,... , m},


and with the rule

r
 { }	otherwise

=  l1 | SEL[l] if val = "LeftOut",

SEL[l]
 SEL[l] | l1 if val = "LeftIn".

The call (1) will also add the recursive definition l = "Rw" ◦ rSEL[l] into the
ρLog session. Throughout this paper we will always assume that rl and
shiftl represent the rule and the computable function associated with a se- lection shift rule l.
Example 2.2 Consider the declarations

DeclareRule[f[x , e] :→ x, "N"];
RWRule["N", "N*", Traversal → "LeftOut"];
and let E = f[f[x, e], y]. Then E →"N*" f[x, y] because of the following: "N*" can be reduced to "Rw" ◦ rSEL["N*"], and E →"Rw" f[f[x, e], y]; then we take f[f[x, e], y] ∈ shiftSEL["N*"][f[f[x, e], y]], and apply rSEL["N*"] = "N" | SEL["N*"]; we choose the alternative "N" and compute f[f[x, e], y] →"N" f[x, y].	 
Selection shift rules can be defined by users too, but the current way to do it is quite cumbersome. We are working on extending the actual implementa- tion of ρLog with a convenient definitional mechanism for selection shift rules.
We will give now an example that illustrates how ρLog can be used as a deductive system.
Example 2.3 [Joinability test in group theory] Consider the axioms of a non- commutative group with associative operation f, right-neutral element e, and inversion operation i. These axioms can be encoded in ρLog rules as follows:

DeclareRule[f[f[x ,y ],z ] :→ f[x, f[y, z]], "A"];
DeclareRule[f[x , e] :→ x, "N"];
DeclareRule[f[x , i[x ]] :→ e, "I"];
The call SetAlias["A" | "N" | "I", "G"] defines "G" as an alias for the com- posed rule "A" | "N" | "I". The rewrite relation induced by "G" is declared by:
RWRule["G", "Group"];
The relation →"Group" is terminating but not confluent, since
f[f[x, e], x] →"Group" f[x, x] /→"Group"; f[f[x, e], x] →"Group" f[x, f[e, x]] /→"Group"

and f[x, x] /= f[x, f[e, x]]. Therefore, checking whether two terms s and t are

joinable requires a systematic search for a term u such that s →∗
u and



∗
"Group"
u. A simple way to program this joinability test in ρLog is:
DeclareRule[eq[x ,x ] :→ True, "Eq"];
SetAlias[Until["Eq", "Group"], "Join"]; ApplyRule[eq[s, t], "Join"]

The last call returns True if s and t are joinable, and eq[s, t] otherwise. If we want to see a justification of the result we can call
ApplyRule[eq[s, t], "Join", TraceStyle → "Compact"];
This call will generate a Mathematica notebook with a human readable pre- sentation of the underlying deduction derivation. Figure 1 presents such a notebook for s = f[f[x, e], i[x]] and t = f[f[e, y], i[y]].	 

Fig. 1. "Compact"-style presentation of a rule-based deduction.
We summarize this section with the following observations:
a rule is applied to a whole expression or to a selected subexpression of an expression,
rule application is a non-deterministic operation,
rule application is a partially defined operation,
rules can be composed into more complex rules via various combinators.

Deduction Trees
Intuitively, a deduction tree (D-tree for short) is a trace of a validity-check for the rule application query ∃?x : E →l x, where the ρ-valid expression E and the rule l are given. The construction of a D-tree proceeds by successively reducing the query ∃?x : E →l x to a finite number of simpler queries. This reduction process is driven by the application of a set of inference rules.
We depict our inference rules as follows:


S1	.. .	Sn
∃?x : E →l x
(2)

where Si (1 ≤ i ≤ n) are either (a) queries of the form ∃?x : Ei →li x, or (b) valid reductions of the form Ei →l E ', or (c) expressions of the form
Ei →l' E ' ∧ ∃?x : E ' →l x where Ei →l E ' is a valid reduction. We write
i	i	1	2	i
[[Si ] for the logical formula obtained by dropping the ’ ?’ superscripts from Si.
With this convention, each inference rule of our system will have the following meaning:
∃x : E →l x iff [S1 ] or ... or [Sn]].
Before describing the inference rules, one by one, we would like to treat first the subject of rule reduction, used tacitly in Example 2.2, and define some auxiliary notions.
A rule l is elementary if it is either basic or of the form NFQ[l1]. We remind here that "Rw" is a built-in basic rule.
The reduct of l, denoted by red[l], is a rule whose applicative behavior coincides with that of l. This means that, for all E , E ' we have
E →l E ' iff E →red[l] E '.
A rule l is reducible if l /= red[l], and irreducible otherwise.
Based on the definition of red[ ] (detailed in [10]), we can define a well- founded relation > by
l > l' iff l' = red[l] and l /= l'.

Reducing a query ∃?x : E →l x to a simpler query is done by reducing l as much as possible, using the function red[ ], until we arrive at an irreducible rule which we try to apply on E . The fact that we eventually reach an irreducible rule is guaranteed by the well-foundedness property of >.
We proceed now with describing the inference rules.

If l is reducible then the corresponding inference rule is:
∃?x : E →red[l] x
∃?x : E →l x
If l is elementary then the corresponding inference rule is:
E →l E1	...	E →l En
∃?x : E →l x

where E1,... , En are all expressions such that E →l Ei.
If l is l1 | ... | ln then the corresponding inference rule is
∃?x : E →l  x	...	∃?x : E →ln x
∃?x : E →l1|...|ln x

If l is a selection shift rule then the corresponding inference rule is:
∃?x : E1 →rl x	...	∃?x : En →rl x
∃?x : E →l x
where {E1,... , En} = shiftl[E ].
l is l1 ◦ l2 where l1 is either elementary or a selection shift rule. If l1 is elementary then the corresponding inference rule is:
(E →l  E1 ) ∧ (∃?x : E1 →l  x)  ...  (E →l  En) ∧ (∃?x : En →l  x)
∃?x : E →l1 ◦l2 x


where E1,... , En (n ≥ 0) are all the expressions such that E →l1 Ei. If l1 is a selection shift rule then the corresponding inference rule is:
∃?x : E1 →rl1 ◦l2 x	...	∃?x : En →rl1 ◦l2 x
∃?x : E →l1◦l2 x
where {E1,... , En} = shiftl1 [E ].
The definitions of red[ ] and of the rule combinators guarantee that these inference rules cover all the possible situations for the shape of a query.
The D-tree for a query ∃?x : E →l x, denoted by T (E, l), is obtained by successive applications of the six inference rules defined above. It is easy to see that a D-tree T (E, l) may be infinite for certain values of E and l. Consider as an example the expression E = A∧B and the rule "comm" :: X ∧Y :→ Y ∧X,

then the D-tree T (E, l) for ∃?x : E →"comm" x is the following
.
 A ∧ B →"comm" B ∧ A
 B ∧ A →"comm" A ∧ B
 A ∧ B →"comm" B ∧ A B ∧ A →"comm" A ∧ B
To avoid the generation of such infinite structures, we restrict the system to the construction of partial D-trees which are obtained by imposing a limit on the maximum number of inference applications along the branches of the tree. Formally, the partial D-tree of maximum depth m, Tm(E, l), for the query
∃?x : E →l x, is defined by:


T0(E, l)  ::= ∃?x : E →l x
Tm+1(E, l) ::= E →l E1	...  E →l En
∃?x : E →l x
Tm+1(E, red[l])


l elementary

|	∃?x : E →l x	l reducible

|	Tm(E, l1)	...	Tm(E, ln)
∃?x : E →l x
l = l1
| ... | ln

|	(E →l1 E1 ) ∧ Tm(E1, l2 ) ...  (E →l1 Ek) ∧ Tm(Ek, l2)
∃?x : E →l x
Tm(E ' , rl )  ...  Tm(E ' , rl )
l = l1 ◦ l2
l1 elementary
l = l1

|		1	1	n	1 
∃?x : E →l x
Tm(E ' , rl ◦ l2 )  ...  Tm(E ' , rl


l2 )
l1 selection shift
l = l1 ◦ l2

|	1	1
k	1
∃?x : E →l x
l1 selection

shift rule
where k, m ∈ N and {E' ,... , E' } = shiftl [E].  Such a partial D-tree is
1	k	1
obtained by successive applications of the inferences defined earlier up to m
times along each branch. Inference steps of type (i) are not taken into account when computing the depth of the D-tree.
In the sequel we will omit the expression E , the rule l and the depth m from the notation of a (partial) D-tree Tm(E, l) whenever we consider it irrelevant.
The following classification of partial D-trees is relevant for interpreting the data stored in their structure:
success D-tree is a partial D-tree which has at least one leaf node computed by the application of inference rule of type (ii) with n ≥ 1.
failure D-tree is a D-tree with no leaf nodes computed by the application of inference rule of type (ii) with n ≥ 1.

pending D-tree is a partial D-tree which is neither success D-tree nor failure D-tree.
The meaning of a partial D-tree Tm(E, l) is: ∃x : E →l x if Tm(E, l) is a success D-tree; ∄x : E →l x if Tm(E, l) is a failure D-tree; and undefined otherwise.

Proof Objects
The two most often invoked reasons for using proof objects in automated reasoning, and also the reasons for which ρLog implements one, are:
keeping a complete record of a prover’s activity, and
providing guidance to users (graphical/natural language display of proof objects).
Other reasons for having a proof object in reasoning systems are extracting proof tactics, later checking, extracting algorithms and computational meth-

ods, etc.  [14].  The proof objects of ρLog
partial D-trees.
are internal representations of

The proof objects of ρLog are intended to be a compact and more explicit representation of the structure of a partial D-tree. They are defined by the following grammar:
N ::= $SNODE[{E , l, E '}]
|  $SNODE[{E , lexpr }, N1,... , Nn]
|  $FNODE[{E , lexpr }]
|  $FNODE[{E , lexpr }, N1,... , Nn]
|  $PNODE[{E , lexpr }, N1,... , Nn]
|  $EPNODE[{E , lexpr }]
lexpr ::= l | {l1,... , ln}| ⟨l, E, lexpr 1⟩.

A success object is a proof object of the form $SNODE[.. .]. Success objects are encodings of success D-trees, thus they justify the validity of a formula
∃x : E →l x or of a formula (E →l1 E ') ∧ (∃x : E ' →l2 x).
A failure object is a proof object of the form $FNODE[.. .]. Failure objects encode failure D-trees, and therefore they justify the validity of a formula
∄x : E →l x or of a logical conjunction (E →l1 E ') ∧ (∄x : E ' →l2 x).
A pending object is a proof object of the form $EPNODE[.. .] or $PNODE[.. .]. Pending objects of the form $EPNODE[.. .] are called elementary pending ob- jects, and they correspond to the objects of D-trees which are computed when

the depth limit for search is reached. The pending object corresponding to a pending D-tree Tm(E, l) justifies the fact that an exhaustive search until depth m is insufficient for deciding the validity of a formula ∃x : E →l x.

The encoding procedure
We will denote the encoding of a partial D-tree T by ⟨⟨T ⟩⟩. We will show how the encoding function of a partial D-tree T can be defined recursively, in terms of the partial D-subtrees of T .
Let Tm be a partial D-tree of depth m and d the search depth limit. The computation of the proof object ⟨⟨Tm⟩⟩ for Tm proceeds as follows:
If Tm ≡ ∃?x : E → x with m < d then ⟨⟨Tm⟩⟩ = $FNODE[{E , l}].
Otherwise, if Tm ≡ ∃?x : E → x with m = d then Tm is a partial D-tree
of maximum search depth, and ⟨⟨Tm⟩⟩ = $EPNODE[{E , l}].

Otherwise, if T
≡ E →l E1  .. .  E →l En
with n > 0 then

m	∃?x : E → x

⟨⟨Tm⟩⟩ =	$SNODE[{E , l, E1 }]	if n = 1,
$SNODE[{E , l}, $SNODE[{E , l, E1}],. .. , $SNODE[{E , l, En}]] if n > 1.

Otherwise, if there exists a sequence of partial D-trees T 1,... ,T n of depth most m such that

Tm = T 1(E, l), li+1 = red[li], T i(E, li) = 
T i+1(E, red[li])
∃?x : E →li x
for 1 ≤ i < n 

and T
n(E, ln) ≡
T n,1  ...  T n,k
∃?x : E →ln x
with ln irreducible and T n,i of depth

most m − 1, then we have the following cases:
if there is i ∈ {1,... , k} such that T n,i is a success D-trees then
⟨⟨Tm⟩⟩ = $SNODE[{E , {l1,... , ln}}, ⟨⟨T n,1⟩⟩,... , ⟨⟨T n,k⟩⟩]
if all T n,1,... ,T n,k are failure D-trees then
⟨⟨Tm⟩⟩ = $FNODE[{E , {l1,... , ln}}, ⟨⟨T n,1⟩⟩,... , ⟨⟨T n,k⟩⟩]
if there is i ∈ {1,... , k} such that T n,i is a pending D-tree, and none of T n,1,... ,T n,k is a success D-tree then
⟨⟨Tm⟩⟩ = $PNODE[{E , {l1,... , ln}}, ⟨⟨T n,1⟩⟩,... , ⟨⟨T n,k⟩⟩].



Otherwise, if Tm ≡
1 ≤ i ≤ k then
T 1 ... T k


∃?x : E →l x
with T i of depth most m − 1 for all

if there is i ∈ {1,... , k} such that T i is a success D-tree then
⟨⟨Tm⟩⟩ = $SNODE[{E , l}, ⟨⟨T 1⟩⟩,... , ⟨⟨T k⟩⟩]
if all T 1,... ,T k are failure D-trees then
⟨⟨Tm⟩⟩ = $FNODE[{E , l}, ⟨⟨T 1⟩⟩,... , ⟨⟨T k⟩⟩]
if there is i ∈ {1,... , k} such that T i is a pending D-tree, and for all
j ∈ {1,... , k}\ {i}, T j are pending or failure D-trees then
⟨⟨Tm⟩⟩ = $PNODE[{E , l}, ⟨⟨T 1⟩⟩,... , ⟨⟨T k⟩⟩]

Otherwise, Tm ≡
(E →l1
E1) ∧ T 1 ... (E →l
∃?x : E →l1◦l2 x
Ek) ∧ T k

where T i are

partial D-trees of depth at most m−1 for ∃?x : Ei →l
x, for all 1 ≤ i ≤ k.

For this situation we will make use of the function Annotate[E , l,N ] which is defined for an expression E , rule l and proof object N as follows:
- $SNODE[{E , ⟨l, E1, l'⟩, E2}] if N = $SNODE[{E1, l', E2}],
- n[{E, ⟨l, E1, lexpr ⟩}, N1,... , Nk] if N = n[{E1, lexpr }, N1,... , Nk] with
n ∈ {$SNODE, $FNODE, $PNODE}.
In the case k = 0, meaning that E /→l1 , we have
⟨⟨Tm⟩⟩ = $FNODE[{E, l1 ◦ l2}] For the case k > 0 we have the following subcases:
if there is i ∈ {1,... , k} such that T i is a success D-tree then ⟨⟨Tm⟩⟩ is
$SNODE[{E , l1 ◦ l2}, Annotate[E , l1, ⟨⟨T 1⟩⟩],... , Annotate[E , l1, ⟨⟨T k⟩⟩]].
if for all i ∈ {1,... , k}, T i is a failure D-tree then ⟨⟨T ⟩⟩ is
$FNODE[{E , l1 ◦ l2}, Annotate[E , l1, ⟨⟨T 1⟩⟩],... , Annotate[E , l1, ⟨⟨T k⟩⟩]].
if there is i ∈ {1,... , k} such that T i is a pending D-tree, and for all
j ∈ {1,... , k}\ {i}, T j are pending or failure D-trees then ⟨⟨Tm⟩⟩ is
$PNODE[{E , l1 ◦ l2}, Annotate[E , l1, ⟨⟨T 1⟩⟩],... , Annotate[E , l1, ⟨⟨T k⟩⟩]].
The following example illustrates the behavior of the encoding procedure in a concrete situation.

Example 4.1 Consider the rules declared in Example 1.1 and the query ∃?x :
−4.2 →"fg" x. The corresponding D-tree is T (−4.2, "fg")


(−4.2 →
  2.8 →"g" 1.4 
2.8) ∧

(−4.2 →

−0.2) ∧

"f1"
∃?x : 2.8 →
"g" x
"f2"
∃?x : −0.2 →
"g" x

∃?x : −4.2 →"f1"◦"g" x	∃?x : −4.2 →"f2"◦"g" x
∃?x : −4.2 →("f1"◦"g")|("f2"◦"g") x
∃?x : −4.2 →("f1"|"f2")◦"g" x
∃?x : −4.2 →"f"◦"g" x
∃?x : −4.2 →"fg" x
We construct the proof object ⟨⟨T ⟩⟩ incrementally, by traversing it from leaves towards the root.
There are two leaf D-trees:

  3.0 →"g" 1.5 
T =
and T =

1	∃?x : 3.0 →
"g" x
2	∃?x : 0. →
"g" x

with the corresponding proof objects
⟨⟨T1⟩⟩ = $SNODE[{3.0, "g", 1.5}] and
⟨⟨T2⟩⟩ = $FNODE[{0., "g"}].
The D-subtrees of T which have T1 and T2 as direct subtrees, are

 (−4.0 →"f1" 3.0) ∧ T1
T =
and T
 (−4.0 →"f2" 0.) ∧ T2 
=	.

3	∃?x : −4.0 →
"f1"◦"g" x
4	∃?x : −4.0 →
"f2"◦"g" x

The corresponding proof objects are
⟨⟨T3⟩⟩ = $SNODE[{−4.0, ⟨"f1", 3.0, "g"⟩, 1.5}] and
⟨⟨T4⟩⟩ = $FNODE[{−4.0, ⟨"f2", 0., "g"⟩}]
computed in the way described in case (vi) of the encoding procedure.
The D-subtree of T which has T3 and T4 as direct subtrees is
	T3	T4	
T =

5	∃?x : −4.0 →
("f1"◦"g")|("f2"◦"g") x

and the corresponding proof object is
⟨⟨T5⟩⟩ = $SNODE[{−4.0, ("f1" ◦ "g") | ("f1" ◦ "g")}, ⟨⟨T3⟩⟩, ⟨⟨T4⟩⟩].

The following D-trees correspond to the sequence of rules
("f1" ◦ "g") | ("f2" ◦ "g"), ("f1" | "f2") ◦ "g", "f" ◦ "g", "fg"
where every element is a reduct of the element which follows it. Therefore, by case (iv), ⟨⟨T5⟩⟩ gives us
⟨⟨T ⟩⟩ = $SNODE[ −4.0, {"fg", "f" ◦ "g",
("f1" | "f2") ◦ "g", ("f1" ◦ "g") | ("f2" ◦ "g")}, ⟨⟨T3⟩⟩, ⟨⟨T4⟩⟩]. It can be easily checked that T has the depth 3.	 
Visualizing and Manipulating ρLog Proof Objects
Having implemented a data structure for storing a partial D-tree, we desire to see and handle it in a useful way. Because speed is one of the main issues that we had in mind when designing ρLog, by default, the system does not create a proof object. However, the user has the possibility to trigger the creation of it, and choose between different styles of presentation: "Object"-style meant for debugging; "Compact"- and "Verbose"-style for a user friendly presentation. To achieve a natural style presentation of the ρLog proof objects, we adapted and simplified the proof presentation routines of the Theorema system [3,12], which also implements a tree-style data structure for storing proofs.
We have already seen in the Section 1 how ρLog can be invoked. Trigger- ing the different presentation styles is done via Mathematica’s options mech- anism [15, Section 1.9.5]. The options of ApplyRule[ ] and ApplyRuleList[ ] are TraceStyle, MaxDepth and MaxSols.
TraceStyle can have the following values:
"None" – the default value. ApplyRule[ ] will only return an eventu- ally found solution or the original expression if no solution was found. ApplyRuleList[ ] will return a possible empty list of solutions. When this value of the option is chosen, no proof object will be created by ρLog. This makes the time needed for obtaining an answer from the sys- tem considerably shorter compared with the time needed when using the other options of TraceStyle, where an object is created.
"Object" – choosing this value will display the proof object’s internal data structure. This can be very large, and inspecting it requires a clear understanding of how the data structure is defined (Section 4).
"Compact" – this value of TraceStyle will cause the generation of a
Mathematica notebook with a user friendly presentation of the partial

D-tree encoded in the proof object. As the name of the option-value says, it is a concise presentation of the rewriting process, skipping all the details about reducing the rules and selecting subexpressions.
"Verbose" – it is similar with the previous option value. The difference consists in the amount of presented information. Steps that reflect reduc- tion of rules, selection of subexpressions are now shown to the user. See Example 5.1 for an illustration of this option’s effect.
The "Compact" and "Verbose" styles of presentation take advantage of Mathematica’s notebook features, the most important which we mention here is having nested cells to reflect the structure of the (partial) D-tree.
MaxDepth The purpose of this option is to avoid infinite computations deter- mined by infinitely long branches in the search space for a derivation. Its default value is 10000. When TraceStyle has a different value than "None", the value of MaxDepth determines the maximum depth of the partial D-tree that is encoded in the proof object which will be created.
MaxSols The purpose of this option is to impose an upper limit on the number of expressions E ' to be found as witnesses for the validity of the query
∃?x : E →l x. For example, a call
ApplyRuleList[E , l, MaxSols → 3]
will stop the solution search process as soon as it had found 3 expressions
E1, E2, E3 for which E →l Ei.
The default value of MaxSols is ∞. This means that, by default, we do not impose any upper bound on the number of solutions to be found.
A very useful feature of ρLog is the possibility to further expand a pend- ing partial D-tree encoded in a proof object, and obtain a new proof object corresponding to the expanded partial D-tree. This can be done by invoking
ExpandObject[obj , MaxDepth → n];
where obj is a proof object and n ∈ N is the depth limit for the partial D- trees which will be computed and encoded to replace the elementary pending objects which occur in obj .
Displaying a proof object in a nice, user friendly manner, can be done not only using the TraceStyle option of ApplyRule[ ] but also by a call
DisplayProof[obj , options];
where the only option available at this time is DetailLevel. The possible values of DetailLevel and their meaning in DisplayProof[ ] calls coincide

with those of TraceStyle in ApplyRule[ ] calls.
Example 5.1 As an illustration of TraceStyle → "Verbose" usage we con- sider the query in Example 1.1, with the requirement for a "Verbose" presen- tation style:

ApplyRule[−4.0, "fg", TraceStyle → "Verbose"];

In this case, the notebook generated by the call looks as in Figure 2.
Notice that, with this presentation style, the information about the reduc- ing sequence of "fg" rule is presented to the user.	 


Fig. 2. "Verbose"-style presentation of a rule-based deduction.

Conclusion and Future Work
The design and implementation of ρLog was motivated by the desire to have a convenient tool to program reasoners with Mathematica. The design of its proof presentation capabilities is inspired from that of Theorema, whose provers work in a ”natural style”. That is, the inference rules are similar to the heuristics used by mathematicians, and the produced output is similar to the proofs written by them [12].
Obviously, the range of problems which can be modelled and solved ef- ficiently with ρLog is very large. Most of its expressive power stems from the capability to model non-deterministic computations as compositions of possibly non-deterministic rules. We expect to identify new combinators for composing rules in ways which are useful in strategy specifications. For in- stance, it is often desirable to have a combinator
XOR[l1, l2,... , ln]
whose applicative behavior is: E →XOR[l ,l ,...,ln] E ' iff E →li E ', where li is the first element of the sequence l1, l2,... , ln for which E →li . This combi- nator turned out to be useful in implementing the lazy narrowing calculi for E-unification described in [9,11]. Please note that the semantics of this com- binator is different from that of the choice combinator, and that the extension of our language with this combinator will need a revision of notion of pending object in particular, and of proof object in general. We are currently working on integrating this combinator in our system.
We have described how ρLog can be employed as a deductive system and be used to generate deduction trees for a certain kind of queries. We ex- pect our system to become a useful tool in the ongoing development of the Theorema system [1,2,3], which is a framework aimed to support the main ac- tivities of the working mathematician: proving, solving, computing, exploring and developing new theories. Up to now, we have implemented a library of unification procedures for free, flat and restricted flat theories with sequence variables and flexible arity symbols [4,7]. These unification procedures have straightforward and efficient implementations in ρLog because they are based on the non-deterministic application of a finite set transformation rules.
Another direction of future work is to introduce control mechanisms for pattern matching with sequence variables. In the current implementation, when enumerating the matching substitutions θ during a call of ApplyRule[ ],
ρLog relies entirely on the enumeration strategy which is built into the
Mathematica interpreter. However, there are many situations when this enu- meration strategy is not desirable. We addressed this problem in [5,6] and

implemented the package Sequentica with language extensions which can over- write the default enumeration strategy of the Mathematica interpreter. The integration of those language extensions in ρLog will certainly increase the expressive power of our rule based system. We are currently working on inte- grating Sequentica with ρLog.
The current implementation of ρLog can be downloaded from
http://heaven.ricam.uni-linz.ac.at/people/page/marin/RhoLog/

Acknowledgement
We would like to thank our colleague and friend Temur Kutsia for his useful comments and suggestions on how to improve the paper.

References
Bruno Buchberger. Theorema: A short introduction. Mathematica Journal, 8(2):247–252, 2001.
Bruno Buchberger, Claudio Dupr´e, Tudor Jebelean, Franz Kriftner, Koji Nakagawa, Daniela V˘asaru, and Wolfgang Windsteiger. The Theorema project: A progress report. In Manfred Kerber and Michael Kohlhase, editors, Symbolic Computation and Automated Reasoning. Proceedings of Calculemus’2000, pages 98–113, St.Andrews, UK, 6–7 August 2000.
Bruno Buchberger, Tudor Jebelean, Franz Kriftner, Mircea Marin, Elena Tomu¸ta, and Daniela V˘asaru. A survey of the Theorema project. In Wolfgang Ku¨chlin, editor, Proceedings of the International Symposium on Symbolic and Algebraic Computation, ISSAC’97, pages 384–391, Maui, Hawaii, US, 21–23 July 1997. ACM Press.
Temur Kutsia. Solving and Proving in Equational Theories with Sequence Variables and Flexible Arity Symbols. PhD thesis, Institute RISC-Linz, Johannes Kepler University, Hagenberg, Austria, June 2002.
Mircea Marin. Functional Programming with Sequence Variables: The Sequentica Package. In Jordi Levy, Michael Kohlhase, Joachim Niehren, and Mateu Villaret, editors, Proceedings of the 17th International Workshop on Unification (UNIF 2003), pages 65–78, Valencia, June 2003.
Mircea Marin and Dorin T¸ epeneu. Programming with Sequence Variables: The Sequentica Package. In Peter Mitic, Phil Ramsden, and Janet Carne, editors, Challenging the Boundaries of Symbolic Computation. Proceedings of 5th International Mathematica Symposium (IMS 2003), pages 17–24, Imperial College, London, July 7–11 2003. Imperial College Press.
Mircea Marin and Temur Kutsia. On the Implementation of a Rule-Based Programming System and some of its Applications. In Boris Konev and Renate Schmidt, editors, Proceedings of the 4th International Workshop on the Implementation of Logics, pages 55–69, Almaty, Kazakhstan, September 26 2003.
Mircea Marin and Temur Kutsia. Programming with Transformation Rules. In Proceedings of the 5th International Workshop on Symbolic and Numeric Algorithms for Scientific Computing, pages 157–167, Timi¸soara, Romania, October 1-4 2003.
Mircea Marin and Aart Middeldorp. New Completeness Results for Lazy Conditional Narrowing. In Proceedings of 6h International Workshop on Unification (UNIF 2002), Copenhagen, Denmark, July 22-26 2002.


Mircea Marin and Florina Piroi. Rule-based Deduction and Views in Mathematica. Technical Report SFB-2003-43, Johannes Kepler University, Linz, October 2003.
Aart Middeldorp and Satoshi Okui. A deterministic lazy narrowing calculus. Journal of Symbolic Computation, 25(6):733–757, 1998.
Florina Piroi and Tudor Jebelean. Advanced proof presentation in Theorema. In Proceedings of the 3rd International Workshop on Symbolic and Numeric Algorithms for Scientific Computing (SYNASC 2001), Timi¸soara, Romania, October 2-5 2001. Also avaialable as RISC- Linz Report Series No. 01-20.
P. A. Subrahmanyam and Jia-Huai You. FUNLOG: A Computational Model Integrating Logic Programming and Functional Programming. Logic Programming: Functions, Relations, and Equations, pages 157–198, 1986.
Geoffrey Norman Watson. Proof representation in theorem provers. Technical Report 98-13, Software Verification Centre, School of Informatics Technology, The University of Queensland, Queensland 4072, Australia, September 1998.
Stephen Wolfram. The Mathematica Book. Wolfram Media Inc. Champaign, Illinois, USA and Cambridge University Press, 1999.
