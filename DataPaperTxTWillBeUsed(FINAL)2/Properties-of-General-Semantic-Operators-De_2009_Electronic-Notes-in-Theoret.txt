

Electronic Notes in Theoretical Computer Science 225 (2009) 181–194
www.elsevier.com/locate/entcs

Properties of General Semantic Operators Determined by Logic-Based Systems
M´aire Lane 1,2
Department of Mathematics University College Cork Cork, Ireland
Anthony Karel Seda1,3
Department of Mathematics University College Cork Cork, Ireland

Abstract
We discuss a very general semantic operator arising within logic-based programming systems from an algebraic point of view, and show how it connects four interesting aspects of computation: neural networks, conventional logic programming, constraint logic programming, and simple models of uncertainty in logic- based systems.
Keywords: Semantic operators, (constraint) logic programming, neural networks, semirings, uncertain reasoning.

Introduction
A number of semantic operators have been defined and studied in the literature on the semantics of logic programs P . These operators map interpretations of P to interpretations of P , and the usual goal in defining them is to realize the various well-known semantics for P (such as the supported models, the perfect models, the stable models, the well-founded models etc.) as fixed points of one or other of these operators. A fairly general operator ΨP which subsumed certain of these semantics was defined by Fitting in [5] over Kleene’s three-valued logic and Belnap’s four-valued logic FOUR.

1 The authors thank the Boole Centre for Research in Informatics at University College Cork for substantial support during the preparation of this paper.
2 Email: maireln@eircom.net
3 Email: a.seda@ucc.ie

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.073

A quite general extension TP of Fitting’s operator was introduced and studied in [10], [11] and [9] over logics T satisfying certain conditions. This was done with a view to giving a unified treatment of several of the various semantics mentioned above, and to extending the ideas of logic programming beyond its usual boundaries, this latter point being the main point we take up here. Furthermore, the issue of the computation of this operator by means of artificial neural networks was addressed in [9] in an effort to give logical semantics to neural networks, and more generally to nature-inspired models of computation taking neural networks as a primary and motivating example. The key idea underlying the definition and properties of TP is that the connectives ∨ and ∧ in T should be ﬁnitely determined as defined in [11], see Definition 2.1 below. This condition on ∨ and ∧ implies that they are idempotent, associative and commutative. Indeed, if T is finite, then being finitely determined is equivalent to ∨ and ∧ being idempotent, associative and commutative; we summarize in Theorem 2.3 for the reader’s convenience the basic properties of completely general finitely-determined binary operations ⊙.
However, there are some extra-logical issues surrounding this operator by virtue of the generality of our definition, and this implies a meeting of certain seemingly disparate ideas. In fact, we give here an abstract definition TP,C of TP over sets C carrying two binary operations, and our definition is general enough for C to apply not only to conventional truth sets, but to semirings and c-semirings as well. Indeed, when C is a c-semiring we recover the semiring framework of Bistarelli et al. [1] for studying constraint logic programming. Hence, one can easily apply the results of [9] to the case of constraint logic programs. Furthermore, the extended syntax we employ here allows one to take truth values as literals in the bodies of clauses. Hence, another example of our current philosophy is that we can easily incorporate within our setting Stamate’s rather simple framework [12] for handling uncertainty in databases.
Thus, in summary, the objective of this paper is to (1) formulate an abstract, general definition of a semantic operator TP,C, and (2) to show how one can use it, with suitable choices of C, to consider the interaction between logic programs, constraint logic programs, Stamate’s model of uncertainty, and neural computation by means of the results of [9].
The overall structure of the paper is as follows. In Section 2, we discuss finitely- determined operations in general and show how they are used in giving the defini- tion of our general semantic operator TP,C. In Section 3, we show how this operator subsumes the three special cases mentioned above. In Section 4, we discuss mono- tonicity properties of TP,C and its Scott continuity. In Section 5, we briefly discuss the question of the computation of TP,C by artificial neural networks. Finally, in Section 6, we present our conclusions.

The General Semantic Operator TP,C
Finitely-Determined Operations
Let C denote a set endowed with binary operations + and ×, and with a unary operation ¬ satisfying ¬(¬c) = c for all c ∈ C. In [11], the notion of ﬁnitely- determined disjunctions and conjunctions (∨ and ∧) was introduced for such sets C of truth values. We begin by giving this definition for a general binary operation
⊙ on C. Note that we assume that ⊙ has meaningfully been extended to include products  i∈M ci of countably infinite families M of elements ci of C. Indeed, the way in which we carry out this extension is the main point of the next definition
and the discussion following it.
Definition 2.1 Suppose that C is a set equipped with a binary operation ⊙. We say that products (relative to ⊙) are ﬁnitely determined in C if for each c ∈ C there exists a countable (possibly infinite) collection {(Rn, En) | n ∈ J } of pairs of sets
c	c

Rn ⊆ C and En ⊆ C, where each Rn
is finite, such that a countable (possibly

c	c	c
infinite) product	i∈M ci is equal to c if and only if for some n ∈J we have
Rn ⊆ {ci | i ∈ M}, and
for all i ∈ M , ci ∈/ En, that is, {ci | i ∈ M}⊆ (En)co, where (En)co denotes the
c	c	c
complement of the set En.
We call the elements of En excluded values, we call the elements of An = (En)co
c	c	c
allowable values, and in particular we call the elements of Rn required values; note
that for each n ∈ J we have Rn ⊆ An, so that each required value is also an
allowable value (but not conversely). More generally, given c ∈ C, we call s ∈ C an excluded value for c if no product  i∈M ci with  i∈M ci = c contains s, that is, in any product  i∈M ci whose value is equal to c we have ci = s for no i ∈ M . We let Ec denote the set of all excluded values for c, and let Ac denote the complement (Ec)co of Ec and call it the set of allowable values.
The following example shows the thinking behind the previous definition; it was originally motivated by the results of [6].
Example 2.2 Consider Belnap’s well-known four-valued logic with set C = FOUR = {t, u, b, f} of truth values and connectives as defined in Table 1, where t denotes true, u denotes undeﬁned or none, b denotes both (true and false), and f denotes false.
Taking ⊙ to be disjunction ∨, the sets E and R are as follows.
For t, we have that n takes values 1 and 2, Et = ∅, R1 = {t}, and R2 = {u, b}.
t	t
For u, we have n = 1, Eu = {t, b} and Ru = {u}.
For b, we have n = 1, Eb = {t, u} and Rb = {b}.
For f , we have n = 1, Ef = {t, u, b} and Rf = {f}.
Thus, a countable disjunction  i∈M ci takes value t if and only if either (i) at least one of the ci is equal to t or (ii) at least one of the ci takes value u and at least one takes value b; no truth value is excluded. As another example, i∈M ci takes value u if and only if at least one of the ci is u, none are equal to t and none are equal to b.	 

Table 1
Truth table for the logic FOUR



It turns out that the connectives in all the logics commonly encountered in logic programming, and indeed in many others, satisfy Definition 2.1, and it will be convenient to state next the main facts we need concerning arbitrary finitely- determined operations (see [11] for all proofs).
Theorem 2.3 Suppose that ⊙ is a binary operation deﬁned on a set C. Then the following statements hold.
If products relative to ⊙ are ﬁnitely determined in C, then the operation ⊙ is idempotent, commutative and associative.
Suppose that products relative to ⊙ are ﬁnitely determined in C and that C contains ﬁnitely many elements {c1,..., cn}. Then, for any collection {si | i ∈ M}, where each of the si ∈ C and M is a denumerable set, the sequence s1, s1 ⊙ s2, s1 ⊙ s2 ⊙ s3,... is eventually constant with value s, say. Therefore, setting   si = s gives each countably inﬁnite product in C a well-deﬁned meaning which extends the usual meaning of ﬁnite products.

Suppose that products are ﬁnitely determined in C and that  i∈M si = c, where M is a countable set. Then the sequence s1, s1 ⊙s2, s1 ⊙s2 ⊙s3,... is eventually constant with value c.
Suppose that C is a countable set and ⊙ is idempotent, commutative and asso- ciative. Suppose further that, for any set {si | i ∈ M} of elements of C where M is countable, the sequence s1, s1 ⊙ s2, s1 ⊙ s2 ⊙ s3,... is eventually constant. Then all products in C are (well-deﬁned and are) ﬁnitely determined.
Suppose that C is ﬁnite. Then ⊙ is ﬁnitely determined if and only if it is idempotent, associative and commutative.
Furthermore, for finitely-determined operations + and × we define partial orders
≤+ and ≤× on C by s ≤+ t iff s + t = t, and s ≤× t iff s × t = t. Note that these orderings are dual to each other if and only if the absorption law holds for + and ×, in which case (C, ≤+, ≤×) is a lattice. Notice also that because + and × are finitely
determined, Σc∈Cc ∈ C is the top element of C relative to ≤+, and  c∈Cc ∈ C is
the top element of C relative to ≤×. Note, however, that it does not follow that we
have bottom elements for these orderings. We further suppose that two elements c¯ and c of C are distinguished, and these elements will be made use of in Section 2.2 and ¯in Section 4. (In some, but not all, situations when C is a logic, c¯ is taken to
be true, and c is taken to be false.)
¯
Notice that finitely-determined operations + and × need not satisfy the dis-
tributive laws. In any event, throughout what follows, C will denote a set endowed with binary operations + and ×, and + at least will be supposed to be finitely determined and × will be assumed to be associative for simplicity.
Of particular interest to us are the following three cases.
C is a set of truth values, + is disjunction ∨ and × is conjunction ∧.
C is a c-semiring (constraint-based semiring) as considered in [1]. Thus, C is a semiring, where the top element in the order ≤× is the identity element 0 for +, and the top element in the order ≤+ is the identity element 1 for ×. In addition,
+ is idempotent, × is commutative, and 1 annihilates C relative to +, that is,
1 + c = c + 1 = 1 for all elements c ∈ C.
	C is the set Lm of truth values considered in Section 3, + is max and × is min.
In fact, it transpires that our main definition (but not all our results) can be made simply in the context of the set C with sufficient completeness properties, namely, that arbitrary countable sums can be defined. Indeed, we next turn to making our main definition (of the operator TP,C).

The operator TP,C
Let L be a first-order language, see [8] for notation and undefined terms relating to conventional logic programming, and let the set C be given, as above. By a C-normal logic program P or a normal logic program P deﬁned over C we mean a finite set of clauses or rules of the type A ← L1,..., Ln (n may be 0, by the usual abuse of notation), where A is an atom in L and the Lj, for 1 ≤ j ≤ n, are either literals in L

or are elements of C. By a C-interpretation or just interpretation I for P we mean a mapping I : BP → C, where BP denotes the Herbrand base for P . We immediately extend I to negated atoms ¬A by I(¬A) = ¬I(A), and to BP ∪¬· BP ∪ C by setting I(c) = c for all c ∈ C. (The usual overloading of the symbol ¬ will not cause any confusion.) Finally, we let IP,C or simply IP denote the set of all C-interpretations for P ordered by ±+, that is, by the pointwise ordering relative to ≤+. Notice that the value I(L1,..., Ln) of I on any clause body is uniquely determined.
To define the semantic operator TP,C, we essentially follow [5], allowing for our extra generality, in first defining the sets P∗ and P∗∗ associated with P . To define P∗, we first put in P∗ all ground instances of clauses of P whose bodies are non- empty. Second, if a clause A ← with empty body occurs in P , add A ← c to P∗. Finally, if the ground atom A is not yet the head of any member of P∗, add A ← c to P∗. To define P∗∗, we note that there may be many, even denumerably many, elements A ← C1, A ← C2, ... of P∗ having the same head A. We replace them with A ← C1 + C2 + .. ., where C1 + C2 + ... is to be thought of as a formal sum. Doing this for each A gives us the set P∗∗. Now, each ground atom A is the head of exactly one element A ← C1 + C2 + ... of P∗∗, and it is common practice to work
with P∗∗ in place of P . Indeed, A ← C1 + C2 + ... may be written A ← Σ Ci and
i
referred to as a (or as the) pseudo-clause with head A and body Σ Ci.
Definition 2.4 Let P be a C-normal logic program. We define TP,C : IP,C → IP,C
as follows. For any I ∈ IP,C and A ∈ BP , we set
TP,C(I)(A) = I(Σ Ci) = Σ I(Ci),
where A ← Σ Ci is the unique pseudo-clause in P∗∗ whose head is A. Note that
when C is understood, we may denote TP,C simply by TP .
We note that I(Σ Ci) = Σ I(Ci) is well-defined in C by Theorem 2.3.

Some Special Cases
As mentioned in the introduction to the paper, the operator TP,C subsumes a number of important cases, and we show next how each of them can be recovered simply by choosing C suitably.

The Standard Semantics of Logic Programming
By choosing C to be an appropriate logic, one recovers the standard semantics of conventional logic programs P as fixed points of TP,C. For example, on choosing C to be classical two-valued logic, Kleene’s strong three-valued logic, and FOUR one recovers respectively the usual single-step operator TP , Fitting’s three-valued operator ΦP , and Fitting’s four-valued operator ΨP , see [5]. Hence, one recovers the associated semantics as the least fixed points of TP,C.
Furthermore, in [13], Wendt studied the fixpoint completion, fix(P ), of a nor- mal logic program P introduced by Dung and Kanchanasut in [3]. The fixpoint completion is a normal logic program in which all body literals are negated, and

is obtained by a complete unfolding of the recursion through positive literals in the clauses of a program. In fact, Wendt obtained interesting connections between various semantic operators by means of fix(P ). Specifically, he showed that for any normal logic program P , we have (i) GLP (I) = Tfix(P )(I) for any two-valued
interpretation I, and (ii) ΨP (I) = Φfix(P )(I) for any three-valued interpretation I,
where GLP is the well-known operator of Gelfond and Lifschitz used in defining the stable-model semantics, and ΨP is the operator used in [2] to characterize the
well-founded semantics of P . These connections have the following immediate con- sequence that GLP and ΨP can be seen as special cases of TP,C, and hence that the
well-founded and stable-model semantics can be viewed as special cases of the fixed points of TP,C.


Constraint Satisfaction Problems and Constraint Logic Programs
A constraint satisfaction problem (CSP) is defined over a constraint system CS = (S, D, V), where S is a c-semiring, D is a finite set called the domain of constraints and V is a set of variables. A constraint (def, c) consists of a subset c ⊆ V and a mapping def : Dk → S which assigns a semiring value a ∈ S to any k-tuple of elements of D, where k is the cardinality of c. A constraint satisfaction problem (C, var) consists of a set C of constraints and a set var ⊆ V. Thus, we have a set of variables to be assigned to elements of D in such a way that a set of constraints is to be satisfied. One particularly interesting class of such problems is the class of Semiring Based Constraint Satisfaction Problems. In that particular framework, different constraint systems are chosen by selecting an appropriate semiring. For example:
For classical constraints: S = ({0, 1}, ∨, ∧, 0, 1).
For fuzzy constraints: S = ([0, 1], max, min, 0, 1).
For probabilistic constraints: S = ([0, 1], max, ×, 0, 1).
For weighted constraints: S = (R+ ∪ +∞, min, +, ∞, 0).
For set-based constraints: S = (p(A), ∪, ∩, ∅, A).
In this list, the semiring (i) is just classical two-valued logic and is finitely deter- mined, but (ii), (iii) and (iv) are not finitely determined. If we take a finite number of truth values and use approximations based on a finite number of intervals, then the semiring (ii) is a finitely-determined logic, and semirings (iii) and (iv) have finitely-determined disjunctions. The semiring (v) depends on the cardinality of A: if A is finite then we have a finitely-determined logic, otherwise not.
A standard constraint logic program, see [7], consists of a finite set of clauses of the form
A ← L1, L2,..., Lk, c1, c2,..., cl,
where A is an atom, the Li are literals and the ci are constraints defined over some domain D of constraints. For our purposes, a semiring-based constraint logic

program (SCLP) P consists of a finite set of clauses each of which is of the form
A ← L1, L2,..., Lk,	(1)

where A is an atom and the Li are literals or is of the form

A ← a,	(2)

where A is an atom and a is any semiring value. Those clauses with a semiring value in the body constitute the constraints and are also known as “facts”. The distinguished values c¯ and c in a c-semiring are 1 and 0 respectively. Thus, when
constructing P∗ for a SCLP¯, unit clauses A ← are replaced by A ← 1 and for any
atom A not the head of a clause, we add the clause A ← 0 to P∗.
Example 3.1 Working over the natural numbers, we take D = (N, con), where con is some set of constraints such as x ≤ 5, for example. Then the CLP clause p(s(x)) ← p(x),x ≤ 5 can be written as p(s(x)) ← p(x), r(x) together with the clauses r(o) ←, r(s(o)) ←, r(s2(o)) ←, . . . , r(s5(o)) ← all of which are taken to be in P . We then see that the following clauses are in P∗:
p(s(o)) ← p(o), r(o)
p(s2(o)) ← p(s(o)), r(s(o))
.
p(s6(o)) ← p(s5(o)), r(s5(o))
r(o) ← 1
r(s(o)) ← 1
r(s2(o)) ← 1
.
r(s5(o)) ← 1
r(s6(o)) ← 0
r(s7(o)) ← 0
.
In this context, a pre-interpretation J for a language L consists of a domain D together with the assignment of a mapping fJ : Dn → D to each function symbol f in L, where n is the arity of f . Furthermore, an interpretation I is a mapping I : BP → S, and we denote by IP,S the set of all such interpretations. Finally, associated with each SCLP is a consequence operator TP,S : IP,S → IP,S defined in
[1] essentially as follows.
Definition 3.2 Given an interpretation I and a ground atom A, we define TP,S (I) by
TP,S (I)(A) = Σi I(Ci),

where A ← Σ
Ci is the unique pseudo-clause whose head is A, and I(Ci) is defined
Σ

as follows. We set I(Ci) = a when A ←	i Ci is the fact A ← a, and otherwise

when A ← Σ Ci is not a fact of the form A ← a, we set I(Ci) =  ni
I(Li ), where

Ci = Li ,..., Li , say.
1	ni
It is easy to see that if P is a SCLP, then the general semantic operator TP,C
coincides with TP,S when we take C to be the c-semiring S underlying P .
We close this discussion of constraint problems in relation to the general semantic operator by considering a simple example of a constraint problem that can be turned into a SCLP (and can ultimately be solved on an ANN, see Theorem 5.1). This example shows that we can solve a CSP, combine constraints and project over a subset of variables using methods from logic programming.
Example 3.3 In this example, the required CSP is defined over a constraint sys- tem CS = (S, D, V), where D = {a, b, c}, V = {x, y, z} and S is the classical- logic semiring ({0, 1}, ∨, ∧, 0, 1). The problem (C, var) we address consists of four constraints: C1 =< def1, {x} >, C2 =< def2, {x, y} >, C3 =< def3, {y} > and C4 =< def4, {y, z} > and the set of variables var = {x, y, z}. The functions defi are defined in the table below. Here, the logic is restricted to classical two-valued logic; thus, the constraints are either satisfied (indicated by value 1) or they are not (indicated by value 0).

Table 2 Constraints


A solution for this CSP is an assignment to the three variables in var which satisfies all the constraints. We introduce the relation Pxyz with arity 3 to calculate the c-semiring value of each of the assignments to x, y and z; it is included in the SCLP as follows.

C1(a) ← 1
C1(b) ← 1
C1(c) ← 0
C2(a, a) ← 0
C2(a, b) ← 1
.
C4(c, c) ← 1
Pxyz(a, a, a) ← C1(a)C2(a, a)C3(a)C4(a, a)
Pxyz(a, a, b) ← C1(a)C2(a, a)C3(a)C4(a, b)
Pxyz(a, b, a) ← C1(a)C2(a, b)C3(b)C4(b, a)
.
Pxyz(c, c, c) ← C1(c)C2(c, c)C3(c)C4(c, c)

A Simple Model of Uncertainty in Logic Programs
In [12], Stamate introduced a simple framework with which to model uncertainty in rule-based systems. We briefly consider this here.
Let m ∈ N.  Following [12], we define the logic Lm to be the set {±(  n ) | n = 0,..., m} of truth values together with disjunction ∨ taken as max relative to the usual ordering on the rational numbers, and conjunction ∧ taken as min relative to the same ordering. Note that disjunction and conjunction are both associative, commutative and idempotent, and hence both are finitely determined by Theorem 2.3; indeed, Lm is a c-semiring in which 0 = −1 and 1 = 1. Furthermore,
there are three distinguished truth values: 1 denotes true, −1 denotes false, and 0 denotes unknown. In this case, ≤+ or ≤∨ is the truth ordering ≤t of [12], namely, the ordering induced on Lm by the usual linear ordering on the rational numbers, and the knowledge order ≤k is defined by




and
1
0 ≤k − 
m
2
≤k −
m
m − 1
≤k ... −	≤k −1
m

1
0 ≤k m
2
≤k m
m − 1
≤k ...	≤k 1
m

with no other inequalities being present.
The sets Lm are then complete distributive lattices, and therefore the partial orders ≤∨ and ≤∧ determined by the connectives are dual to each other.
Example 3.4 L4 = ({−1, − 3 , − 2 , − 1 , 0, 1 , 2 , 3 , 1}, max, min), and the knowledge
4	4	4	4 4 4
order is the partial order shown in Figure 1.
Elements of Lm are allowed as literals in the bodies of the clauses in the programs discussed in [12], and therefore these programs are special cases of C-normal logic programs.  Furthermore, valuations or interpretations I are defined as usual as



−1,¸¸¸¸
¸¸¸
¸
− 3
cc 1 ,
ccc
3 cc

4 ¸,¸¸¸
¸¸¸¸
− 2
ee 4 ,
eee
e
2

4 ¸,¸¸¸
¸¸¸¸
− 1
ee 4 ,
eee
e
1

,,,,¸
,,,,
cc 4 ,
cccc

,0 cc


Fig. 1. Partial Order ≤k on L4.


functions from BP ∪ Lm → Lm, where I(l) = l for each l ∈ Lm, and a semantic

operator ΦS
is defined in [12] by

ΦS (I)(A) = sup≤ {I(C) | A ← C ∈ ground(P )}.

P	t

As usual, we take lub≤t (∅) to be the least element −1 for the order ≤t, and then
the operator ΦS is well-defined. Hence, −1 is taken to be the default value in this
setting. Since each Lm is a complete lattice, the least upper bound of any set of truth values exists and is equal to their infinite disjunction. Indeed, such an infinite disjunction is equal to a finite disjunction by Theorem 2.3, and it now follows easily
that ΦS coincides with TP,C when C is taken to be Lm.

Example 3.5 Stamate [12] only considers databases, that is, programs with no function symbols of arity greater than 0, and hence ground(P ) and P∗∗ are both finite. Let P be the following database, with three constants and two relation symbols.
p(a) ← ¬p(b)
p(b) ← q(a)
q(a) ← ¬p(a), p(c) 1
q(b) ←− 4
p(a) ← q(b), q(c)
p(b) ← ¬q(c)
Then P∗∗ is the following.

p(a) ← ¬p(b) ∨ (q(b) ∧ q(c))
p(b) ← q(a) ∨ ¬q(c)
p(c) ← −1
q(a) ← ¬p(a) ∧ p(c) 1
q(b) ←− 4
q(c) ← −1

Fixed-Point Properties of TP,C
In this section, we briefly consider the monotonicity and continuity properties of the operator TP,C. Thus, we suppose again throughout this section that the set C is given, as in Section 2.1, and that P denotes an arbitrary normal logic program defined over C. For Theorem 4.6 to hold, it is necessary for the underlying set C to be a complete partial order; thus, a least element with respect to ≤+ must be present in C (we add this element to C if necessary). To calculate the least fixed point of TP,C, it is common practice to iterate on the least element. However, if we require the least fixed point to coincide with any useful semantics, it will usually be necessary to choose the default value c ∈ C to be the least element in the ordering
≤+.	¯
Proposition 4.1 If P is a deﬁnite program, then the operator TP,C deﬁned over a lattice C is monotonic.
The preceding result is true for normal programs if the negation operator is itself monotonic, that is, if we have ¬a ≤ ¬b whenever a ≤ b.
Corollary 4.2 For any C-normal logic program P, the operator TP,C deﬁned over a lattice with monotonic negation is itself monotonic.
An example of a logic with monotonic negation is FOURk, where FOURk is Belnap’s four-valued logic with the knowledge ordering ≤k. (It is then the case that
+ coincides with the gullibility operator   and × coincides with the consensus operator  discussed by Fitting in [4].)
Proposition 4.3 Negation deﬁned on FOURk is monotonic with respect to ≤L.
Proof. In FOURk, ¬b = b, ¬u = u, ¬t = f , ¬f = t. Since b is the top element in the order ≤L, we have s ≤L b for s = t, u, b, f and hence ¬s ≤L ¬b since ¬b (= b) is also the top element in ≤L. Likewise for u, u is the bottom element in the order
≤L so that u ≤L s for s = t, u, b, f , and so ¬u ≤L ¬s also since ¬u = u is the bottom element. Therefore, it remains to check inequalities involving t and f , but t and f are incomparable and hence there are no inequalities involving only those truth values.	 
Proposition 4.4 If P is deﬁnite, then TP,C deﬁned over a c-semiring is monotonic.

Corollary 4.5 Suppose P is a deﬁnite program and that addition in C distributes over multiplication (that is, a × (b + c) = (a × b)+ (a × c) for all a, b, c ∈ C). Then TP,C is monotonic.
The previous result holds because: if c1 ≤ c2 and d1 ≤ d2, then c1 × d1 ≤ c2 × d2
and c1 + d1 ≤ c2 + d2.
Theorem 4.6 Suppose P is a deﬁnite program and that the underlying set C is a complete partial order. Then whenever TP,C : IP,C → IP,C is monotonic with respect to ±+, it is Scott continuous.
Proof. By monotonicity of TP,C, we immediately have that TP,C(D) is a directed set and that sup(TP,C(D)) ±+ TP,C(sup D) for each directed set D ⊆ IP,C. Thus, it remains only to show that TP,C(sup D) ±+ sup(TP,C(D)) for each directed set D ⊆ IP,C.
To establish this, let TP,C(sup D)(A) = tβ for an arbitrary A ∈ BP . Then sup D(Σj Cj) = tβ, that is, supI∈D I(Σj Cj) = tβ, where A ← Σj Cj is the unique pseudo-clause in P∗∗ with head A. Let sup(TP,C(D))(A) = tα which is to say
that supI∈D(TP,C(I))(A) = tα.  Then TP,C(I)(A) ≤+ tα for all I ∈ D, and from
the definition of TP,C, we have I(Σ Cj) ≤+ tα for all I ∈ D.  Thus, tα is an
j
upper bound for I(Σ Cj). But since tβ is the least upper, we must have tβ ≤+ tα.
j
Therefore, for any A ∈ BP , TP,C(sup D)(A) ±+ sup(TP,C(D))(A), and it follows that
TP,C(sup D) ±+ sup(TP,C(D)), as required. Therefore, TP,C is Scott continuous. 

Connections with Artificial Neural Networks ANN
The following result was established in [9]. As indicated in the introduction, it connects neural networks with logic programming, constraint logic programming, and uncertainty by computing TP,C in each of these three cases (with the choices for C made as in Section 3).
Theorem 5.1 Suppose that both + and × are ﬁnitely determined in C, and that P is a propositional logic program deﬁned over C. Then there is a 3-layer feedforward neural network containing conjunction units in the second layer and disjunction units in the third layer (where conjunction and disjunction units are as as deﬁned in [9]) which computes TP,C.

Conclusions
Inspired by a number of logic-based systems, we have shown how one may define a “semantic” operator in a purely algebraic way. Furthermore, we have also shown how it in fact encapsulates the logical semantics of a number of actual logic-based models of computation of current interest in the literature. Finally, we have ad- dressed the monotonicity properties and the Scott continuity of this operator, and also, briefly, its computation by artificial neural networks.

References
S. Bistarelli, U. Montanari, and F. Rossi. Semiring-based constraint logic programming: Syntax and semantics. ACM Transactions on Programming Languages and Systems (TOPLAS), 23(1):1–29, Jan 2001.
Stefan Bonnier, Ulf Nilsson, and Torbj¨orn N¨aslund. A simple fixed point characterization of three- valued stable model semantics. Information Processing Letters, 40(2):73–78, 1991.
Phan Minh Dung and Kanchana Kanchanasut. A fixpoint approach to declarative semantics of logic programs. In Ewing L. Lusk and Ross A. Overbeek, editors, Logic Programming, Proceedings of the North American Conference 1989, NACLP’89, Cleveland, Ohio, pages 604–625. MIT Press, 1989.
Melvin Fitting. Kleene’s logic, generalized. Journal of Logic and Computation, 1:797–810, 1992.
Melvin Fitting. Fixpoint semantics for logic programming — A survey. Theoretical Computer Science, 278(1–2):25–51, 2002.
Pascal Hitzler and Anthony K. Seda. Characterizations of classes of programs by three-valued operators. In Michael Gelfond, Nicola Leone, and Gerald Pfeifer, editors, Logic Programming and Non-monotonic Reasoning, Proceedings of the 5th International Conference on Logic Programming and Non-Monotonic Reasoning, LPNMR’99, El Paso, Texas, USA, volume 1730 of Lecture Notes in Artificial Intelligence, pages 357–371. Springer, Berlin, 1999.
J. Jaffar and J.-L. Lassez. Constraint logic programming. In POPL’87: Proceedings of the Fourteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, pages 111– 119, 1987.
John W. Lloyd. Foundations of Logic Programming. Springer, Berlin, 1987.
M´aire Lane and Anthony K. Seda. Some aspects of the integration of connectionist and logic-based systems. Information, 9(4):551–562, 2006.
Anthony K. Seda and M´aire Lane. On approximation in the integration of connectionist and logic- based systems. In L. Li and K.K. Yen, editors, Proceedings of The Third International Conference on Information, Information’04, Tokyo, November, 2004, pages 297–300. International Information Institute, 2004.
Anthony K. Seda and M´aire Lane. On the measurability of the semantic operators determined by logic programs. Information, 8(1):33–52, 2005.
Daniel Stamate. Quantitative datalog semantics for databases with uncertain information. In Alessandra Di Pierro and Herbert Wiklicky, editors, Proceedings of the 4th Workshop on Quantitative Aspects of Programming Languages (QAPL 2006), Electronic Notes in Theoretical Computer Science, Vienna, Austria, April 1–2 2006. Elsevier. To appear.
Matthias Wendt. Unfolding the well-founded semantics. Journal of Electrical Engineering, Slovak Academy of Sciences, 53(12/s):56–59, 2002.
