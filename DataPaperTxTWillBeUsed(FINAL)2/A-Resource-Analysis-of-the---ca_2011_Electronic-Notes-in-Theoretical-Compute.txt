Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 276 (2011) 313–334
www.elsevier.com/locate/entcs
A Resource Analysis of the π-calculus
Aaron Turon Mitchell Wand
College of Computer and Information Science Northeastern University
Boston MA, USA

Abstract
We give a new treatment of the π-calculus based on the semantic theory of separation logic, continuing a research program begun by Hoare and O’Hearn. Using a novel resource model that distinguishes between public and private ownership, we refactor the operational semantics so that sending, receiving, and allocating are commands that influence owned resources. These ideas lead naturally to two denotational models: one for safety and one for liveness. Both models are fully abstract for the corresponding observables, but more importantly both are very simple. The close connections with the model theory of separation logic (in
particular, with Brookes’s action trace model) give rise to a logic of processes and resources.
Keywords: separation logic, pi-calculus, ownership, resources, scope extrusion, full abstraction

Names play a leading role in the π-calculus [12]: they are both the means of communication, and the data communicated. This paper presents a study of the π- calculus based on a new mechanism for name management, which is in turn rooted in separation logic. The main benefit of this study is a very simple—but fully abstract—denotational semantics for the π-calculus.
Traditionally, the use of names in the π-calculus is governed by lexical, but dynamically-expandable, scope. In the composite process P new x.Q for example, the channel x is by virtue of scope initially private to Q. The prefix new x is not an imperative allocation. It is a binder that remains fixed as Q evolves—a constant reminder that x is private—until Q sends x in a message. At that point, the binder is lifted to cover both P and Q, dynamically “extruding” the scope of x. The π- calculus relies on α-renaming and side conditions about freshness to ensure that its privacy narrative is borne out.
In contrast, work on separation logic has led to models of dynamically-structured concurrency based on resources and ownership, rather than names and scoping [3,5]. From this perspective, programs consist of imperative commands that use certain resources (their “footprint”) while leaving any additional resources unchanged. Con- current processes must divide resources amongst themselves, with each process using only those resources it owns. Ownership makes it possible to constrain concurrent

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.09.028

interference, and thereby to reason compositionally about process behavior.
In this paper, we reanalyze the π-calculus in terms of resources and ownership, establishing a clear connection with models of separation logic. The analysis hinges on the use of resources to specify not just that a process can do something, but that other processes cannot. 1 Concretely, channels are resources that can be owned either publicly or privately. Public ownership asserts only that a channel can be used by the owning process. Private ownership asserts moreover that a channel cannot be used by other processes. And the prefix new x becomes an imperative action, allocating an initially private channel.
Armed with this simple resource model, we give a new operational semantics for the π-calculus (§1). The semantics is factored into two layers. The first layer generates the basic labeled transitions, without regard to their global plausibility. The second layer then uniformly interprets those labels as resource transformers, filtering out implausible steps. The two-layer setup is reminiscent of Brookes’s semantics for concurrent separation logic [3,2], and allows us to blend message passing and imperative interpretations of actions.
More importantly, the resource model also enables a very simple denotational treatment of the π-calculus. We give two denotational interpretations, both trace- theoretic. The first (§2) captures safety properties only, while the second (§3) is also sensitive to divergence and some branching behavior, along the lines of the failures/divergences model with infinite traces [18]. We prove that each model is fully abstract with respect to appropriate observables.
The semantic foundation reconciles the model theory of separation logic with the π-calculus; what about the proof theory? We sketch an integration of sepa- ration logic with refinement calculus for processes (§4). Refinement is justified by the denotational semantics, so the calculus is sound for contextual approximation. Resource reasoning allows us to derive an interference-free expansion law that uses privacy assertions to rule out interference on a channel.
To provide an accurate model of the π-calculus, public/private resources must be conservative in a certain sense: once a resource has been made public, it is im- possible to make it private again. Work in separation logic has shown the usefulness of more “aggressive” resource models that capture not just what can and cannot be done, but assert that certain things may not be done. We sketch a few such aggres- sive resource models (§5.1), including an interpretation of fractional permissions [1] and of session types [10].
Hoare and O’Hearn initiated a study of a π-calculus-like language in terms of separation logic semantics [9]. That study provided the impetus for our work, which goes farther by (1) handling the full calculus, (2) handling liveness, (3) proving full abstraction and (4) building a logic on the semantics. There have also been several fully abstract models of the π-calculus [20,8,7] based on functor categories for modeling scope. Our models complement these by providing an elementary account of behavior, structured around resources and abstract separation logic. A

1 Such a reading of resources has already appeared in e.g. deny-guarantee reasoning [6].

full discussion of related work is in §5.2.
A resource-driven operational semantics
There are many variants of the π-calculus; here’s ours:
P ∶∶= ∑ πi.Pi | P s Q | new x.P | P |Q | rec X.P | X π ∶∶= ee′ | e(x)	e ∶∶= x | c
We distinguish between external choice ( ) and internal choice ( ), which simplifies the liveness semantics (§3) but is not essential. We also distinguish between chan- nels (c, d) and channel variables (x, y, z) and include a simple grammar of channel expressions (e) ranging over both. A closed process has no unbound channel or process variables. Closed processes may, however, refer to channel constants and thereby communicate with their environment.
We write 0 for an empty summation, which is an inert process.
Generating actions
The operational semantics of closed processes is given in two layers, via two labelled transition systems. In both systems, the labels are (syntactic) actions, given by the following grammar:
α ∶∶= c!d | c?d | νc | τ | 3	(Action)
Actions record the concrete channels involved in sending, receiving, and allocating, respectively. The action τ , as usual, represents an internal (unobservable) step on
  

channel (§1.2). Communication actions are dual: c!d = c?d and c?d = c!d, while νc, τ , and 3 are undefined.
The first transition system generates all conceivable actions associated with a process, without considering whether those actions are globally plausible:
Operational semantics: action generation	P —α→ Q


⋯+ cd.P +⋯ —c!→d
⋯+ c(x).P +⋯ —c?→d
P
P (d/x}
P —α→ P ′


P |Q —α→ P ′|Q
Q —α→ Q′


P |Q —α→ P |Q′

P1 s P2 —→ P
τ


new x.P
—ν→c
P (c/x}
P —α→ P ′	Q —α→ Q′

rec X.P
—τ→ P (rec X.P /X}


P |Q —τ→ P ′|Q′



According to this semantics, we will have transitions like

new x.new y.xy.0

—ν→c

new y.cy.0

—ν→c

cc.0
—c!→c 0

where c is allocated twice, and used to communicate with an environment that cannot know it. To filter out such executions, we use resources.

Resources and action semantics
The execution above is intuitively impossible because, after the first νc action, the process already owns the channel c. Similarly, for the process new x.xx.0 the trace


new x.xx.0
—ν→c
cc.0
—c!→c 0


is impossible because the channel c, having just been allocated, is unknown to the environment—so no parallel process could possibly be on the other side of the communication, receiving along c.
Formally, resources are elements σ of the domain Σ	Chan	pub, pri , where
pub and pri are distinct atoms. If a process is executing with resources σ, it owns
Therefore, if c ‹ dom(σ), the action νc is impossible. Likewise, if σ(c) = pri, the The resources owned at a particular point in time determine not only what is
possible, but also what is permissible. For example, the process cd.0 immediately
attempts a communication along the channel c. If this channel is not allocated (i.e., not owned, i.e., not in dom σ ) then the process is faulty : it is attempting to use a dangling pointer.
We interpret actions α as resource transformers of type Σ Σt. 2 Since all nondeterminism is resolved during the generation of actions, these transformers are deterministic. A result of or represents that an action is not permissible or not possible, respectively.
Given the semantics α Σ Σt of actions (defined below), we can define a transition system that executes actions according to the currently-owned resources:
Operational semantics: resource sensitivity	P, σ —α→ P t, σt
P —α→ P t	Qα¢σ = σt	P —α→ P t	Qα¢σ =t 
	

α
P, σ d
P t, σt
3
P, σ d 0,σ 


Successful actions proceed normally, updating the owned resources—note that if
t
ing the faulting label 3. Impossible actions silently fail to occur.
The semantics of actions is as follows:


2 The notation ΣT denotes the set (Σ, t, ı} and implies an ordering ı c σ c t for all σ ‹ Σ. The order structure follows abstract separation logic [5], and is related to locality (§2).

Action semantics	Qα¢ ∶ Σ → Σt

⎧t	(c, d} ⊆/ dom(σ)
Qc!d¢σ ≜ ⎨σ[d pub]	σ(c)= pub

Qc?d¢σ
⎧t	c ∉ dom(σ)
⎪σ[d pub]	σ(c)= pub,

⎪	otherwise
≜ ⎨⎪
σ(d)m pri

⎩ı
⎪σ[c pri]	c ∉ dom(σ)
⎪⎩ı	otherwise

Qνc¢σ ≜ ⎨⎪⎩ı	otherwise	Qτ ¢σ ≜ σ	Q3¢σ ≜ t
Allocation is always permitted, but is not possible if the channel is already allocated. Allocated channels are initially private. Sending a channel publicizes it, but the communication is only possible if performed over an already public channel, and only permitted over an allocated channel. A locally-unknown channel received from the environment is known to the environment, and hence public; a locally-known channel received from the environment cannot possibly have been private.


Examples
Consider the process new x.0. We have
new x.0 for every channel c. It follows that
new x.0, ∅	νc




—ν→c	0



0, [c ↦ pri]

for every channel c, while executing with more resources
new x.0, [c ↦ pri]	νd	0, [c ↦ pri]⊎ [d ↦ pri]
results in constrained allocation: the ⊎ here denotes disjoint union, meaning that taking an impossible step), but introduced no new traces. Similarly,

new x.xx.0
—ν→c
cc.0
—c!→c 0



but, taking resources into account, we have
new x.xx.0, ∅	νc


cc.0, [c ↦ pri]

at which point the process is stuck: the action c!c is prevented from occurring, because c!c c  pri  . This deadlock is exactly what we expect to see when a process attempts to communicate along a private channel. Finally, we have

new x.(xx.0|x(y).yx.0)

—ν→c

	
cc.0|c(y).yc.0
—τ→	0|cc.0

—c!→d

0|0

which, with resources, yields
new x.(xx.0|x(y).yx.0),  ∅	νc


cc.0|c(y).yc.0, [c ↦ pri]	τ


0|cc.0, [c ↦ pri]


Here we see that internal communication along a private channel is both possible and permitted: such internal steps appear as τ actions to the resource-sensitive stepping relation, and hence always pass through. On the other hand, the inter- nal communication also leaves the ownership of c unchanged. Because it remains private, the final communication cc is stuck, as it should be.

Process safety
With the simple public/private resource model, faulting occurs only when using an unallocated channel. Our semantic framework can accommodate deallocation, but doing so complicates the full abstraction result, and we wish to focus on the standard π-calculus. Avoiding deallocation allows us to easily characterize “safe” processes: we say σ  P  iff P is closed and all channel constants in P are in


α	t	t	t
Lemma 1.1 If σ ⊢ P ✓ then P, σ →/ , and if furthermore P, σ —→ P ,σ then σ ⊢

Denotational semantics: safety traces
Resources provide an intriguing refactoring of the operational semantics for π- calculus, but their real payoff comes in the elementary denotational model they support. We begin with a simple trace model capturing only (some) safety proper- ties, which allows us to focus on the role of resources. Afterwards we incorporate liveness (§3) and its interaction with resources.
For the safety model, we have traces t, trace sets T and behaviors B:

Trace ≜ Action∗	Beh ≜ Σ → TraceSet
TraceSet ≜ (T ∶ ∅ ⊂ T ⊆ Trace, T prefix-closed}

Processes will denote behaviors: sets of action traces determined by the initially- available resources. Not every action is observable. We follow standard treatments of π-calculus [19,8] in considering τ steps unobservable, and eliding νc steps until just before the allocated channel c is sent over a public channel (a “bound send”). Our denotational semantics shows that the operators of the π-calculus are congruent for these observables, and the cited works prove that similar observables are fully abstract for yet coarser notions of observation. The observables of an action α are a (possibly empty) trace, depending on the available resources:

Action observables	|α|σ ∶ Trace

|τ |σ ≜ ϵ
|νc|σ ≜ ϵ
|3|σ ≜ 3 
|c?d|σ ≜ c?d

|c!d|σ
⎧⎪νd ⋅ c!d	σ(d)= pri
⎪⎩c!d	otherwise


We write t u or tu for trace concatenation, and ϵ for the empty trace. Although νc is not immediately observable, taking a νc step affects the resources owned by the process, so exposing c later will cause the νc step to visibly reemerge.
The safety behavior of a process can be read determined operationally:
Safety observation	O P ) ∶ Beh



ϵ ‹ O P )σ
α
P, σ d
P t, σt	t ‹ O P t σt
|α|σt ‹ O P )σ


The goal of the denotational semantics is to calculate the same traces composition- ally over process structure.
TraceSet is a complete lattice under the subset order, and behaviors inherit
t	t
have B Bt σ B σ Bt σ . The semantic operators are monotonic (in fact, continuous), so we are justified in defining rec as a fixpoint. For the safety semantics, which is based on finite observation, it is the least fixpoint.
The safety trace model is insensitive to branching behavior of processes [21], so internal and external choice are indistinguishable. We interpret both forms of c⊔hoice using , merging behaviors from all the alternatives. For empty summations, The denotation function is parameterized by an environment ρ, here taking channel variables x to channels c, and process variables X to behaviors B. It uses
two additional operators,  and , which we will define shortly.
Denotational semantics (safety)	 P ) ∶ Env → Beh


 eet.P )ρ  ≜	ρe!ρet ▷ P )ρ
 e(x).P )ρ  ≜ ⊔c ρe?c ▷ P )ρ[x↦c]
 new x.P )ρ  ≜	⊔c νc ▷  P )ρ[x↦c]
 rec X.P )ρ  ≜	μB. P )ρ[X↦B]
 ∑ πi.Pi)ρ  ≜ ⊔i πi.Pi)ρ
 P s Q)ρ ≜  P )ρ ⊔ Q)ρ
 P |Q)ρ  ≜  P )ρ   Q)ρ
 X)ρ  ≜ ρ(X)



The interpretation of prefixed processes resembles the operational semantics: each clause of the denotational semantics generates all locally-reasonable actions, without immediately checking global plausibility. We use to join the behaviors arising from each action—once more reflecting nondeterminism—and we update the environment as necessary.
The operator α  B prefixes an action α to a behavior B in a resource-sensitive way, playing a role akin to the second layer of the operational semantics:

Semantic prefixing	α ▷ B ∶ Beh
(α ▷ B)(σ) ≜ (αt ∶ Qα¢σ = σt, t ‹ B(σt)} ∪ (3 ∶ Qα¢σ = t} ∪ (ϵ}

To maintain prefix-closure, we include ϵ as a possible trace. A quick example:

 new x.xx.0)∅ = ⊔ νc ▷ xx.0)x↦c = ⊔ νc ▷ c!c ▷ 0)x↦c = ⊔ νc ▷ c!c ▷ λσ.(ϵ}
		

This expansion of the definition resembles the traces we see from the first layer of the operational semantics, without taking resources into account. The denotation, recall, is a behavior : to extract its set of traces, we must apply it to some particular resource σ. If we use the empty resource, we see that

(⊔ νc ▷ c!c ▷ λσ.(ϵ}) (∅) = (ϵ}∪ ⋃(νc ⋅ t ∶ t ‹ (c!c ▷ λσ.(ϵ}) [c ↦ pri]}
c
ϵ	νc t	t	ϵ
c
in other words, we have new x.xx.0)∅ (∅) = (ϵ}∪⋃c(νc}. Just as in the operational
Here, the prefix closure (in particular, the inclusion of ϵ in every application of	) ensures that we see the trace up to the point that we attempt an impossible action. Finally, we have parallel composition—the most interesting semantic operator.
Here we must ask a crucial question for the denotational semantics: if σ is the resource belonging to P Q, what resources do we provide to P and Q? The question does not come up in the operational semantics, which maintains a single, global resource state, but a compositional semantics must answer it.
Consider the process new x. xc x z . When the process reaches the parallel composition, x will still be private. The privacy of x means that the subprocesses can only communicate with each other (yielding τ ), not with the external environment of the process. But the subprocesses are communicating with environments external


communicate along it externally, but it is public to the subprocesses xc and x(z), Formally, we capture this narrative as follows:


1


2

ti‹Bi(̂σ)
1   2
⎪⎩undefined	otherwise

The resource σ given to a parallel composition of behaviors is fed in public-lifted
traces t1 and t2 from these sets, we calculate all interleavings t1  t2:


t  u ≜ λσ.(ϵ}	if t = ϵ = u
⊔ α ▷ (tt  u) if t = αtt
⊔ α ▷ (t  ut) if u = αut

⊔ tt  ut	if t = αtt, u = αut
Interleaving at first glance appears standard, but note the use of semantic prefixing
: the interleavings are not simply another set of traces, they are given as a behavior that must be evaluated. We evaluate with the original resources σ. The effect is that each interleaving is checked with respect to the resources held by the combined process. This additional check is the key to making the “declare everything public” approach work, allowing us to take into account channels that are private from the point of view of the combined process, but public between the subprocesses.
An example helps illuminate the definitions: take the process dc | d(z) with

 dc ∅(̂σ)= (ϵ, d!c}
 d(z))∅(̂σ)= (ϵ}∪ (d?e ∶ e ‹ Chan}
d!c	d?c = (d!c ▷ d?c ▷ λσ.(ϵ}) ⊔ (d?c ▷ d!c ▷ λσ.(ϵ}) ⊔ (λσ.(ϵ})
The interleaving d!c  d?c includes the case that d!c and d?c are two sides of the same communication (yielding λσ. ϵ ) and the two possible orderings if they are not. From the point of view of σ, which has lost the information that d is private to the combined process, this is the most we can say. However, the interleaving is built using the prefixing operation , so when we evaluate it with respect to the original σ, some traces will be silently dropped:
(d!c	d?c)(σ)
= (d!c ▷ d?c ▷ λσ.(ϵ})(σ)∪ (d?c ▷ d!c ▷ λσ.(ϵ})(σ)∪ (λσ.(ϵ})(σ)
= (ϵ}∪ (ϵ}∪ (ϵ}
In particular, for any B we have d!c	B σ	d?c	B σ	ϵ because σ d pri. We are left only with traces that could arise from internal communication, as expected. That is, new x. xc x y  )∅  c	pub		ϵ . More generally, we can show

Because  σ   , we have   B  λσ.  , ϵ  for any B. Thus, when a  action is interleaved, the interleaving is terminated with that action.
In summary, we calculate the traces of P Q by calculating the traces of P and Q under conservatively public-lifted resources, then evaluating the interleavings with complete information about what resources P Q actually owns.

Example calculations
Before proving full abstraction, we briefly examine a few of the expected laws.
For example, why does new x.0)	 0)? Expanding the former, we get ⊔c νc

λσ.(ϵ}. When applied to a particular σ, this behavior yields the simple set (ϵ}, observation |− |: it is crucial for ignoring when, or in some cases whether, channels
A more complex example is the following:
 new x.new y.P )ρ = ⊔ νc ▷ new y.P )ρ[x↦c]

= ⊔ νc ▷ ⊔ νd ▷ P )ρ[x↦c,y↦d]
	
= ⊔ νc ▷ νd ▷ P )ρ[x↦c,y↦d]

= ⊔ νd ▷ νc ▷ P )ρ[x↦c,y↦d]

= ⊔ νd ▷ ⊔ νc ▷ P )ρ[x↦c,y↦d]
	
= ⊔ νd ▷ new x.P )ρ[y↦d] =  new y.new x.P )ρ


νc ▷ B. The validity of this lemma, again, relies on observability: |νc|σ = |νd|σ = ϵ

Congruence for the basic operators
We prove full abstraction by proving a congruence result for each operator in the language. For the operators other than parallel composition, we show:
Lemma 2.1 (Core congruences) All of the following equivalences on closed pro- cesses hold:
O 0) = 0)∅

O cd.P ) = c!d ▷ O P )
O c(x).P ) = ⊔d c?d ▷ O P (d/x})
O new x.P ) = ⊔c νc ▷ O P (c/x})
O ∑i Pi) = ⊔i O Pi)
O P s Q) = O P )⊔ O Q)
These equivalences are straightforward to show; we prove each by showing con- tainment in both directions. For illustration, we give the proof that	 c x .P )
d		)
Proof. Let σ ‹ Σ and t ‹ O c(x).P )σ. We analyze cases on the derivation of
	)

Case:

Let d be a channel. Then t = ϵ ‹ c?d ▷ O P (d/x}) by definition of ▷. The result


Case:

Reasoning by inversion, we see that there are two subcases:
Subcase:
Then t = αtt ‹ ⊔d c?d ▷ O P (d/x}) trivially by the definition of ▷.
Subcase:
Then t = αtt = 3 because O 0)σt = (ϵ}. That 3 ‹ ⊔d c?d ▷ O P (d/x}) again

Congruence for parallel composition
The justification of our treatment of parallel composition goes back to the intuitions from the beginning of the paper: concurrent process must divide resources amongst themselves, with each process using only those resources it owns. We say σ separates into σ1 and σ2 if the following conditions hold:




σ ‹ (σ1  σ2) ≜
⎪⎨⎪ σ1(c)= pri =⇒ σ(c)= pri, c ∉ dom(σ2)
⎪⎩ σ2(c)= pri =⇒ σ(c)= pri, c ∉ dom(σ1)

We understand this definition as saying: if σ1 and σ2 are resources separately held by P and Q respectively, then σ is possibly the resource held by P Q. The subresources σi do not uniquely determine a combination σ because resources public to the subprocess may, or may not, be private to the combined process. 3 Separa- tion crisply captures the desired meaning of public and private ownership: if one
not own the resource at all (c ∉ dom(σ2)), but both processes may own a resource
To show that that P1 P2  P1  P2 , we must show that our strategy of interleaving traces from publicly-lifted resources agrees with the global operational semantics. A key idea is that σ σ1  σ2 constitutes an invariant relationship between the resources owned by subprocesses (in the denotational semantics) and those owned by the composite process (in the operational semantics). The invariant

3  This means that Σ with  does not form a separation algebra [5]; see §5.1.

holds initially because σ ‹ ̂σ  ̂σ.
The unobservability of νc steps complicates matters somewhat: it means there is an additional perspective on resources—call it σden—owned by a composite process. Generally, σden underestimates the true resources σ of the operational semantics. Consider the denotational interleaving of two traces t1 and t2 from subprocesses P1 and P2 respectively. If P1 allocates a channel, that allocation does not appear immediately in t1, and hence does not appear immediately in the resources σden of the interleaving, while it would immediately appear in σ, operationally. During denotational interleaving, the same channel can even be owned privately in both σ1 and σ2. The key observation here is that either both subprocesses eventually reveal a given private channel—in which case the denotational interleaving is filtered out— or at least one subprocess does not—in which case its choice of channel is irrelevant. Altogether, the four resources—σop, σden, σ1, and σ2—can always be related:
I(σop, σden, σ1, σ2) ≜ σop ‹ σ1  σ2, σden = σop ∖ (c ∶ σ1(c)= pri ∨ σ2(c)= pri}
provided that, within the proof, we apply appropriate channel renamings to avoid conflicts.
Validating parallel composition requires another important lemma, locality from abstract separation logic [5]. 4
Lemma 2.2 (Locality) If σ ‹ σ1  σ2 then
if Qα¢σ = t then Qα¢σ1 = t, and
if Qα¢σ = σt then Qα¢σ1 = t or Qα¢σ1 = σt for some σt with σt ‹ σt  σ2.
The lemma characterizes the transformations an action can make given some composite resources σ in terms of its behavior on subresources σ1. Providing ad- ditional resources can never introduce new faults, and if the action does not fault given just σ1 resources, then the changes it makes to σ must only change the σ1 portion (framing).
Locality was introduced to characterize the frame rule of separation logic [5], but we use it here to characterize interleaving steps in parallel composition. We have a related lemma for internal communication steps:

Le‹mma 2.3 (Communication) If σ ‹ σ1  σ2, Qα¢σ1 = σt
and Qα¢σ2 = σt
then

t  σt .
We prove each direction of congruence separately:
Lemma 2.4 If I(σop, σden, σ1, σ2), σi ⊢ Pi✓ and t ‹ O P1|P2)σop then
1	2	den	i	  i) i
Lemma 2.5 If I(σop, σden, σ1, σ2), σi ⊢ Pi✓, ti ‹ O Pi)σi, and
1	2	den	  1  2) op

4 For simplicity we avoid the order-theoretic definition here, which requires lifting some of our constructions to 2Σ in a way that is not otherwise useful.

The first of these two lemmas is easier to prove, because we are given a trace t derived from the operational semantics of the composite processes. This means that the subprocesses are guaranteed not to independently allocate the same channel. The second lemma requires more care, using the insights mentioned above about renaming unexposed channels.
The assumptions σi  Pi  are needed to ensure that the processes we are work- ing with do not fault. The reason that faulting is problematic is seen in the following example:

new x.cx.0 | c(y).cy.dy.0), [c ↦ pub]
cd.0 | c(y).cy.dy.0, [c ↦ pub,d ↦ pri]
d 0 | cd.dc.0, [c ↦ pub,d ↦ pri] d 0 | dc.0, [c ↦ pub,d ↦ pub] d 0 | 0, [c ↦ pub,d ↦ pub]
The uncomfortable aspect of this derivation is that the channel d occurred in the
process initially, even though it was not owned. As a result, the process was able to allocate d, in a sense falsely capturing the constant d that initially appeared. In cases where the process allocates a different channel than d, it will fault when it attempts to communicate along the constant channel d. But in this “lucky” case, the operational semantics allows communication along the constant channel.
The denotational semantics, however, always generates a fault. It computes the traces compositionally, meaning that a channel d allocated by one subprocess is not immediately available for use by a parallel subprocess.
Our full abstraction result applies only to nonfaulty processes, which, fortu- nately, is a trivial syntactic check. However, this does limit its applicability to languages that include features like deallocation, which makes checking for safety more difficult.
Full abstraction
To complete the proof of full abstraction, we must deal with recursion. We begin with the usual unwinding lemma, proved in the standard syntactic way:
Lemma 2.6 (Unwinding) We have O rec X.P ) = ⊔n O recnX.P ), where rec0X.P ≜
n+1	n
We also have the standard substitution lemmas:
Lemma 2.7 (Substitution) We have  P [Q/X])ρ = P )ρ[X↦Q] and
 P [c/x])ρ = P )ρ[x↦c].
Combined these lemmas with the previous congruence results, it is straightforward to show the following theorem relating the observed operational traces to those calculated denotationally:
Theorem 2.8 (Congruence) If P is closed, σ ⊢ P ✓ then O P )σ = P )∅ σ.

To prove this theorem, we must generalize it to deal with open terms. We do this by introducing a syntactic environment η as a finite map taking channel variables to channels and process variables to closed processes. Given a syntactic environment η the corresponding semantic environment η is given by:
(η̂)(x) ≜ η(x)	(η̂)(X) ≜ O η(X))
We write ηP for the application of η as a syntactic substitution on P . The needed induction hypothesis for congruence is then
if σ ⊢ ηP ✓ then O ηP )σ = P )η̂ σ.
Define P =Den Q iff  P )ρ σ = Q)ρ σ for all σ such that σ ⊢ P ✓ and σ ⊢ Q✓.
and σ ⊢ C[Q]✓. Full abstraction follows by compositionality:
Theorem 2.9 (Full abstraction) P =Den Q iff P =Op Q.
Denotational semantics: adding liveness
To round out our study of π-calculus, we must account for liveness properties. Liveness in process algebra appears under diverse guises, differing in sensitivity to branching behavior and divergence [21]. Each account of liveness corresponds to some choice of basic observable: given a process P and a context C, what behavior of C P matters?
The standard observable for the π-calculus is barbed bisimilarity [13], which sits quite far on the branching side of the linear-branching time spectrum [21]. Here, we choose a treatment more in the spirit of linear time: an adaptation of acceptance traces [8]. This choice is partly a matter of taste, but it also allows us to stick with a purely trace-theoretic semantics, which keeps the domain theory to a minimum. We do not see any immediate obstacles to applying our resource-based handling of names to a branching-time semantics. Branching sensitivity and resource-sensitivity seem largely orthogonal, though of course branches may be pruned when deemed impossible given the owned resources.
Liveness observables
We say that a process diverges if it can perform an infinite sequence of unobservable (i.e., internal) steps without any intervening interactions with its environment— which is to say, the process can livelock. On the other hand, a process that can make no further unobservable steps is blocked (waiting for interaction from its environment) or deadlocked.
The basic observables in our liveness model are:
A finite sequence of interactions, after which the process diverges or faults;
A finite sequence of interactions, after which the process is blocked, along with which channels it is blocked on (none for deadlock); and

An infinite sequence of interactions.
Notice that we have conflated divergence and faulting: we view both as erroneous behavior. In particular, we view any processes that are capable of immediately diverging or faulting as equivalent, regardless of their other potential behavior. This perspective is reasonable—meaning that it yields a congruence—because such behavior is effectively uncontrollable. For example, if P can immediately diverge, so can P Q for any Q.
Formally, we add a new action δΔ which records that a process is blocked at- tempting communication along the finite set of directions Δ:
α ∶∶= ⋯ | δΔ	Δ ⊆fin Dir ≜ (c! ∶ c ‹ Chan}∪ (c? ∶ c ‹ Chan}
We then define

LTrace ≜ NTAction∗; (3, δΔ} ∪ NTActionω
LBeh
≜ Σ → 2LTrace

where NTAction (for “non-terminating action”) refers to all actions except for 3 or blocking actions δΔ. Thus finite liveness traces must end with either a δΔ action or a  action, whereas neither of these actions can appear in an infinite trace.
Each liveness trace encompasses a complete behavior of the process: either the process continues interacting indefinitely, yielding an infinite trace, or diverges, faults or gets stuck after a finite sequence of interactions. Therefore, sets of liveness traces are not prefixed-closed.
As with the safety traces, we can observe liveness traces from the operational semantics. However, we do so using the greatest fixpoint of the following rules: Liveness observation	LO P ) ∶ LBeh



α
P, σ
P t, σt

α m3	dt ‹ LO P t σt

gfp
  P, σ 3
gfp
P, σ blocked Δ

gfp

|α|σt ‹ LO P )σ
3‹ LO P )σ


δΔ ‹ LO P )σ

where P, σ blocked Δ means that P, σ can only take communication steps, and Δ contains precisely the directions of available communication. Since the owned resources influence which communications are possible, they also influence the di- rections on which a process is blocked:
δ(c!} ‹ LO cc.0)[c ↦ pub]	δ∅ ‹ LO cc.0)[c ↦ pri]
The action δ∅ reflects a completely deadlocked process, and is for example the sole trace of the inert process 0.
Defining the observations via a greatest fixpoint allows for infinite traces to be observed, but also means that if a process diverges after a trace t, its behavior will
contain all traces tu, in particular t3. For example, suppose P, σ τ P, σ. If t is any
liveness trace whatsoever, we can use the first inference rule to shdow, coinductively,
that t ‹ LO P )σ. We merely assume that t ‹ LO P )σ, and derive that |τ |σt = t ‹

LO P σ. Thus, divergence is “catastrophic” (as in failures/divergences [4]).
An important step toward making these observables coherent is the notion of reﬁnement. In general, saying that P refines Q (or P “implements” Q) is to say that every behavior of P is a possible behavior of Q. In other words, P is a more deterministic version of Q. We define a refinement order on traces:
t ⊑ t	tδΔ ⊑ tδΔ′ if Δt ⊆ Δ	tu ⊑ t3

which we lift to sets of traces as: T  U iff  t  T.  u  U. t  u. This notion of refinement, which closely follows that of acceptance traces [8], says that an im- plementation must allow at least the external choices that its specification does. It also treats faulting as the most permissive specification: if Q faults, then any P will refine Q. Moreover, any two immediately-faulting processes are equivalent. Since faulting and divergence are treated identically, the same holds for divergent processes. Thus, the simple refinement ordering on traces has an effect quite similar to the closure conditions imposed in failures/divergences semantics.
The ordering on trace sets inherits the complete lattice structure of 2LTrace, as does the pointwise order on LBeh. We again exploit this fact when interpreting recursion.

Liveness semantics
To complete the semantic story, we need to interpret blocking actions. We define


QδΔ
⎧⎪t	∃c. (c! ‹ Δ ∨ c? ‹ Δ)∧ c ∉ dom(σ)
⎪⎩σ	otherwise

|δΔ|σ ≜ δΔ′ where Δt = Δ ↾ (c ∶ σ(c)= pub}
which shows the interaction between resources and blocking: blocking on a private resource is possible, but unobservable (cf. projection on δ in [2]). For example, we have
Qδ(c!}¢[c ↦ pub]= [c ↦ pub]	|δ(c!}|[c↦pub] = δ(c!}
Qδ(c!}¢[c ↦ pri]= [c ↦ pri]	|δ(c!}|[c↦pri] = δ∅
The denotational semantics for liveness,	, is largely the same as that for safety, except for the following clauses:
L rec X.P )ρ ≜ νB.L P )ρ[X↦B]
L ∑ π .P ρ ≜ (⊔ L π .P )ρ)⊔ (δ	▷ λσ.∅)
Recursion is given by a greatest fixpoint, as expected. A summation of prefixed actions now generates a corresponding blocking set, recording the external choice (where dir extracts the direction of a prefix). The blocking action is “executed” using the prefixing operator  so that the actual observed action corresponds to the available resources, as in the example above.

Finally, we use the following definition of interleaving:
t  u ≜gfp α ▷ (tt  u) if t = αtt, α not blocking
⊔  α ▷ (t  ut) if u = αut, α not blocking

⊔  δΔ∪Δ′	if t = δΔ, u = δΔ′ , Δ ⋔ Δt

⊔  tt  ut	if t = αtt, u = αut
Liveness interleaving is given by a greatest fixpoint. An infinite sequence of internal communications (operationally, an infinite sequence of τ moves) therefore yields all possible traces, including faulting ones, as it should. An interleaved trace is blocked only when both underlying traces are, and only when they do not block in opposite directions (Δ is Δ with directions reversed, and denotes empty intersection). If two processes are blocked in opposite directions, then their parallel composition is in fact not blocked, since they are willing to communicate with each other (cf stability [4]).
Full abstraction
The proof of full abstraction is structured similarly to the proof for the safety semantics. Congruence proofs must take into account blocking actions, which is straightforward in all cases except for parallel composition. There, we require a lemma:
Lemma 3.1 (Blocking congruence) Suppose I(σop, σden, σ1, σ2). Then
If δΔi ‹ LO Pi)σi and Δ1 ⋔ Δ2 then |δΔ1∪Δ2 |σden ‹ LO P1|P2)σop.

|If δΔ ‹ LO P1|P2)σop then δΔi ‹ LO Pi)σi for some Δ1, Δ2 with Δ1 ⋔ Δ2 and
Defining =LDen and =LOp analogously to the safety semantics, we again have full
abstraction:
Theorem 3.2 (Full abstraction) P =LDen Q iff P =LOp Q.
Logic
We now sketch a logic for reasoning about the safety semantics of processes. The logic proves reﬁnement between open processes—denotationally, trace containment; operationally, contextual approximation. The refinements are qualified by assertions about owned resources, which is what makes the logic interesting. The basic judg- ment of the logic is Γ  p  P  Q, which says the traces of P are traces of Q, as long as the initial resources and environment, respectively, satisfy assertions p and Γ (defined below).
Resource assertions p are as follows:
p ∶∶= true | false | p ∧ q | p ∨ q | p ∗ q | x pub | x pri | x = y | x m y

and we let x known x pub x pri. Satisfaction of assertions depends on both the environment and resources, as in these illustrative cases:

ρ, σ ⊧ x pub ≜ σ(ρ(x)) = pub
ρ, σ ⊧ p1 ∗ p2 ≜ ∃σ1, σ2.σ = σ1 ⊎ σ2 and ρ, σi ⊧ pi

Resource assertions like x pub are intuitionistic [17]; without deallocation there is no reason to use the classical reading, which can assert nonownership. We are using the standard interpretation of separation logic’s as disjoint separation to enable sequential reasoning about resource transformers in our logic. Action interpretations α are local with respect to , just as they were for .
Environment assertions Γ constrain process variables:

Γ ∶∶= ∅ | Γ, (p ▸ X ⊑ P )
ρ ⊧ (p ▸ X ⊑ P ) ≜  ∀σ. (ρ, σ ⊧ p) =⇒ ρ(X)(σ)⊆ P )ρ σ

The definition of entailment is thus:
Γ ⊧ p ▸ P ⊑ Q  ≜  ∀ρ, σ. (ρ ⊧ Γ ∧ ρ, σ ⊧ p) =⇒ P )ρ σ ⊆ Q)ρ σ

By qualifying refinements by resource assertions we can incorporate Hoare logic-like reasoning. Take, for example, the rule
	Γ ⊢ p ∗ (x pub ∧ y pub) ▸ P ⊑ Q	
Γ ⊢ p ∗ (x pub ∧ y known)▸ xy.P ⊑ xy.Q

for sending over a public channel. It is a kind of congruence rule, but we shift resource assumptions for the subprocesses, corresponding to the Hoare triple
(p ∗ (x pub ∧ y known)} xy (p ∗ (x pub ∧ y pub)}

The syntactic structure of prefixes (rather than sequential composition) prevents a clean formulation of the logic using Hoare triples. This is why the frame p is included, rather than added via a separate frame rule; we are using “large” rather than “small” axioms [15]. A better treatment is possible if we semantically in- terpret prefixing as sequential composition, which requires a variables-as-resources model [16].
For sending over a private channel, we have an axiom: xy.P refines any process when x is private, because xy.P is stuck. The corresponding Hoare triple is x pri

Here is a fragment of the logic, focusing on resource-sensitive rules:

A selection of logical rules for safety behavior	Γ ⊢ p ▸ P ⊑ Q
	Γ ⊢ p ∗ (x pub ∧ y pub) ▸ P ⊑ Q	
Γ ⊢ p ∗ (x pub ∧ y known)▸ xy.P ⊑ xy.Q	Γ ⊢ x pri ∧ y known ▸ xy.P ⊑ Q
Γ ⊢ (p ∗ x pub)∧ y pub ▸ P ⊑ Q	y ∉ fv(p, Γ)		
Γ ⊢ p ∗ x pub ▸ x(y).P ⊑ x(y).Q	Γ ⊢ x pri ▸ x(y).P ⊑ Q

Γ ⊢ p ∗ x pri ▸ P ⊑ Q	x ∉ fv(p, Γ)
Γ ⊢ p ▸ new x.P ⊑ new x.Q
	Γ ⊢ p̂▸ Pi ⊑ Qi	
Γ ⊢ p ▸ P1|P2 ⊑ Q1|Q2

p ▸ X ⊑ P ‹ Γ Γ ⊢ p ▸ X ⊑ P
Γ,p ▸ X ⊑ Q ⊢ p ▸ P ⊑ Q
Γ ⊢ p ▸ rec X.P ⊑ Q
p ⊧ pt	Γ ⊢ pt ▸ P ⊑ Q


Γ ⊢ p ▸ P ⊑ Q

The congruence rule for parallel composition performs public-lifting p on resource assertions (by replacing pri by pub in the assertion).
Fixpoint induction is resource-qualified as well. We reason about the body P of a recursive definition rec X.P using a hypothetical bound on X as the induction hypothesis. That hypothesis, however, is only applicable under the same resource assumptions p that were present when it was introduced—making p the loop invari- ant.
In addition to these resource-sensitive rules, we have the usual laws of process algebra, including the expansion law. Combining those laws with the ones we have shown, we can derive an interference-free expansion law, as in this simplified version: Γ  x pri  y known  xy.P x z .Q  P Q y z .

Discussion
Future work: richer resources
Our resource model captures exactly the guarantees provided by the π-calculus: until a channel is exposed, it is unavailable to the environment; afterwards, all bets are off. This property is reflected in the fact that Σ is not a separation algebra, since c pub  c pub can result in c pub or c pri. No amount of public ownership adds up definitively to private ownership.
Rather than using resources to model the guarantees of a language, we can instead use them to enforce guarantees we intend of programs, putting ownership “in the eye of the asserter” [14]. We can then recover privacy just as Boyland showed [1] how to recover write permissions from read permissions: via a fractional model of ownership, ΣFrac	Chan	0, 1 . Unlike traditional fractional permissions, owning a proper fraction of a channel does not limit what can be done with the channel—instead, it means that the environment is also allowed to communicate on the channel. The fractional model yields a separation algebra, using (bounded) summation for resource addition. An easy extension is distinguishing send and receive permissions, so that interference can be ruled out in a direction-specific way. One can also imagine encoding a session-type discipline [10] as a kind of resource:

ΣSess ≜ Chan ~ Session where
s ‹ Session ∶∶= l.s s l.s | l.s & l.s | !.s | ?.s | end
Separation of session resources corresponds to matching up dual sessions, and ac- tions work by consuming the appropriate part of the session. Ultimately, such resource models could yield rely-guarantee reasoning for the π-calculus, borrowing ideas from deny-guarantee [6]. A challenge for using these models is managing the ownership protocol in a logic: how are resources consistently attached to channels, and how are resources split when reasoning about parallel composition? We are far from a complete story, but believe our semantics and logic can serve as a foundation for work in this direction.

Related work
Hoare and O’Hearn’s work [9] introduced the idea of connecting the model the- ory of separation logic with the π-calculus, and provided the impetus for the work presented here. Their work stopped short of the full π-calculus, modelling only point-to-point communication and only safety properties. Our liveness semantics, full abstraction results, and refinement calculus fill out the rest of the story, and they all rely on our new resource model. In addition, our semantics has clearer con- nections to both Brookes’s action trace model [2] and abstract separation logic [5]. Previous fully abstract models of the π-calculus are based on functor cate- gories [20,8,7], faithfully capturing the traditional role of scope for privacy in the π-calculus. Those models exploit general, abstract accounts of recursion, nonde- terminism, names and scoping in a category-theoretic setting. We have similarly sought connections with a general framework, but have chosen resources, separation
and locality as our foundation.
An immediate question is: why do we get away with so much less mathematical scaffolding? This question is particularly pertinent in the comparison with Hen- nessy’s work [8], which uses a very similar notion of observation. Hennessy’s full abstraction result is proved by extracting, from his functor-categorical semantics, a set of acceptance traces, and showing that this extraction is injective and order pre- serving. The force of this “internal full abstraction” is that the functor-categorical meaning of processes is completely determined by the corresponding acceptance traces. But note, these traces are not given directly via a compositional semantics: they are extracted only after the compositional, functor-categorical semantics has been applied. What we have shown, in a sense, is that something like acceptance traces for a process can be calculated directly, and compositionally, from process syntax.
Beyond providing a new perspective on the π-calculus, we believe the resource- oriented approach will yield new reasoning techniques, as argued above. We have also emphasized concreteness, giving an elementary model theory based on sets of traces.
Finally, it is worth noting that substructural type systems have been used to

derive strong properties (like confluence) in the π-calculus [11], just as we derived interference-free expansion. Here, we have used a resource theory to explain the π-calculus as it is, rather than to enforce additional discipline. But the ideas of §5.1 take us very much into the territory of discipline enforcement. More work is needed to see what that territory looks like for the resource-based approach.
Acknowledgement
We are grateful to Paul Stansifer and Tony Garnock-Jones for feedback on drafts of this paper, and to the anonymous reviewers who provided guidance on presentation. The first author has been generously supported by a grant from Microsoft Research (Cambridge).

References
Boyland, J., Checking Interference with Fractional Permissions, in: SAS, 2003.
Brookes, S., Traces, Pomsets, Fairness and Full Abstraction for Communicating Processes, in:
CONCUR, 2002, pp. 45 –71.
Brookes, S., A semantics for concurrent separation logic, TCS 375 (2007), pp. 227–270.
Brookes, S. D. and A. W. Roscoe, An Improved Failures Model for Communicating Processes, in:
Seminar on Concurrency, 1984.
Calcagno, C., P. W. O’Hearn and H. Yang, Local Action and Abstract Separation Logic, in: LICS, 2007.
Dodds, M., X. Feng, M. Parkinson and V. Vafeiadis, Deny-guarantee reasoning, in: ESOP, 736 (2009),
pp. 363–377.
Fiore, M., E. Moggi and D. Sangiorgi, A fully-abstract model for the pi-calculus, in: LICS, December (1996).
Hennessy, M., A fully abstract denotational semantics for the pi-calculus, TCS 278 (2002), pp. 53–89.
Hoare, T. and P. O’Hearn, Separation Logic Semantics for Communicating Processes, Electronic Notes in Theoretical Computer Science (ENTCS) (2008).
Honda, K., V. T. Vasconcelos and M. Kubo, Language Primitives and Type Discipline for Structured Communication-Based Programming, in: ESOP, 1998, pp. 122–138.
Kobayashi, N., B. Pierce and D. Turner, Linearity and the pi-calculus, ACM Transactions on Programming Languages and Systems (TOPLAS) 21 (1999), pp. 914–947.
Milner, R., J. Parrow and D. Walker, A calculus of mobile processes, parts I and II, Information and computation 100 (1992).
Milner, R. and D. Sangiorgi, Barbed bisimulation, in: Automata, Languages and Programming, Lecture Notes in Computer Science 623, 1992 pp. 685–695.
O’Hearn, P., Resources, concurrency, and local reasoning, TCS 375 (2007), pp. 271–307.
O’Hearn, P., J. Reynolds and H. Yang, Local Reasoning about Programs that Alter Data Structures, in:
Computer Science Logic, 2001.
Parkinson, M., R. Bornat and C. Calcagno, Variables as Resource in Hoare Logics, in: LICS (2006).
Reynolds, J., Separation logic: a logic for shared mutable data structures, in: LICS, 2002.
Roscoe, A. W. and G. Barrett, Unbounded Non-determinism in CSP, in: MFPS, 1989.
Sangiorgi, D. and D. Walker, “The pi-calculus: a Theory of Mobile Processes,” Cambridge University Press, 2001.

Stark, I., A fully abstract domain model for the pi-calculus, in: LICS (1996), pp. 36–42.
Van Glabbeek, R., The linear time-branching time spectrum, CONCUR’90 Theories of Concurrency: Unification and Extension (1990), pp. 278–297.
