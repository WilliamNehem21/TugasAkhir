	Electronic Notes in Theoretical Computer Science 202 (2008) 171–189	
www.elsevier.com/locate/entcs

Sequential Real Number Computation and Recursive Relations
J. Raymundo Marcial-Romero1,2
Divisi´on de Computacio´n UAEM Ciudad Universitaria S/N, 50040 Toluca, Estado de M´exico M´exico
M. Andrew Moshier3
Department of Math and Computer Science Chapman University
Orange CA 92867 USA

Abstract
In the first author’s thesis [9], a sequential language, LRT, for real number computation is investigated. The thesis includes a proof that all polynomials are programmable, but that work comes short of giving a complete characterization of the expressive power of the language even for first-order functions. The technical problem is that LRT is non-deterministic. So a natural characterization of its expressive power should be in terms of relations rather than functions. In [2], Brattka investigates a formalization of recursive relations in the style of Kleene’s recursive functions on the natural numbers. This paper establishes the expressive power of LRTp, a variant of LRT, in terms of Brattka’s recursive relations. Because Brattka already did the work of establishing the precise connection between his recursive relations and Type 2 Theory of Effectivity, we thus obtain a complete characterization of first-order definability in LRTp.
Keywords: exact real-number computation, sequential computation, recursive relations, semantics, non-determinism, PCF


Introduction
In the literature on real number computation, several papers follow an idea orig- inally due to Scott [17] of interpreting a type for real numbers in the domain of compact intervals (for simplicity, often restricted to the closed unit interval). In particular, extensions to PCF following this approach are investigated at length in

1 This work was performed during the first author’s visit to Chapman University in the Fall of 2006. Dr. Marcial-Romero’s visit was funded by a grant from La Academia Mexicana de Ciencias y la Fundaci´on M´exico-Estados Unidos para la Ciencia (AMC-FUMEC) and the project PROMEP/103.5/05/1696.
2 Email: rmarcial@fi.uaemex.mx
3 Email:moshier@chapman.edu

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.014

Escard´o’s thesis [5]. See Di Gianantonio [3], Potts et. al. [16] and Farjudian [7] for other examples of this approach. One of the most striking results along this line is Escard´o, Hofmann and Streicher’s proof [6] that “parallel if” can be implemented in a language that includes addition extended canonically to the domain of partial reals. This means that in order to have a reasonably expressive language with se- quential interpretation, one must give up the canonical extension of addition. One way to do this is to introduce non-deterministic choice into the language. In [10,11], the sequential, non-deterministic language LRT is defined. In those papers, it is also shown that the non-determinism must be interpreted via the Hoare power domain. So, the ground types of the language are interpreted as Hoare power domains. It is the interaction of partiality and non-determinism that characterizes the basic idea of LRT.
LRT, with its sequential, non-deterministic semantics, seems naturally suited to a relational view of computation. And yet, all investigations into its expressive power [9,10,11] concentrate exclusively on functions. In particular, the operational concept of “strong convergence” is really useful only for analysis of programs that denote functions. The non-determinism of a strongly convergent program comes in only as the program produces partial results. In the limit, the non-deterministically produced partial outputs converge to a total (determined) value. Thus strong con- vergence, as it stands, is not useful for analyzing programs that are intended to produce non-deterministic (yet total) outputs. Furthermore, strong convergence is tied closely to the call-by-name semantics of LRT, which is forced by operational considerations. In particular, call-by-value simply makes no sense for the real num- ber type in LRT because a “value” only corresponds to a converging sequence of partial results. Since our goal is to understand relations, we extend the language to include a let construct, and propose a generalization of strong convergence and a family of semantic interpretations of let parameterized by a positive real number
p. The idea is to allow for reduction of a let term when a partial value is known within precision p. We call this reduction strategy call-by-partial-value. The corre- sponding denotational semantics employs several ideas familiar to domain theorists, including measurement as defined by Martin in [12] and a monadic treatment of the distinction between value and computation as in Moggi [14]. Furthermore, because we are interested in relations, say, on product types, we also extend the language to have explicit products of ground types.
In domain theoretic approaches to real number computation, one usually in- terprets the real number type as a domain D into which R embeds topologically. Typically, R embeds as the subspace of maximal elements of D, [17]. Thus, elements of D are taken to denote partial numbers, or information about real numbers. More generally, given a topological space X, a domain model for X [12] is a continuous domain D equipped with an embedding e of X onto max D, the set of maximal elements of D.
LRT interprets the real number type as the Hoare power domain (PH ) of a model of [0, 1]. In other words, the elements of this type are not merely partial real numbers, but are non-deterministic computations of partial real numbers. The reals

still embed in the resulting domain, but not as maximal elements. This introduces an extra layer of indirection with respect to the “actual” real numbers. The other basic types of LRT are treated exactly the same way. Namely, we fix models for the natural numbers and the Booleans, and deal with the Hoare power domains of these models.
The Hoare power domain itself constitutes a strong monad. Thus, one can adopt methods of Moggi [14], or better yet, Levy’s call-by-push-value [8] generalization of Moggi’s method, to talk about the relation between computations (elements of a powerdomain) and values (generators of that powerdomain). But in the case of LRT, the values are already indirect ways of talking about real numbers, natural numbers and Booleans.
For the purposes of this paper, a (total) value is a datum drawn from a complete metric space. We are concerned mostly with values from R, from the two discrete spaces N and T and from finite products of these. A partial value is a datum drawn from a designated corresponding domain model. Specifically, an element of Y⊥ is a “partial real”, an element of the flat domain of Booleans T⊥ is a “partial Boolean”, and an element of the flat domain of natural numbers N⊥ is a “partial natural number.” Elements of a product of these domains are partial values for the analogous product of metric spaces. We are justified in thinking of a tuple of partial values as a partial tuple because of the easily checked fact that the property “D is a domain model for X” is preserved by taking finite products.
A “real”, “Boolean” or “natural number” computation belongs to УH (Y⊥), УH (T⊥) or УH (N⊥), respectively. For tuples, we must face an important distinction between computations of tuples and tuples of computations. That is, УH (D) × УH (E) and УH (D × E) simply are not isomorphic. We avoid the isomorphism requirement in the denotational semantics of the language by interpreting product types in a special way.
The paper is organized as follows: after the basics, in Section 3 we present the Recursive Space System introduced by Brattka. In Section 4, we introduce the language LRTp and prove adequacy of the language. In Section 5, we present the translation between Brattka’s relations and LRTp programs. Finaly, Section 6 is devoted to Conclusions.

Basics
Continuous relations
In [2], Brattka extends Kleene’s system of recursive partial functions on the nat- ural numbers to other metric spaces, particularly to R. Continuity is a necessary condition for effectiveness, and yet the fact that R is connected means there are no non-constant continuous functions, e.g., from R to the discrete space N. So Brattka gives up functionality and retains a generalization of continuity to relations.
Definition 2.1 For binary relation R between sets X and Y and element x ∈ X, define R(x) := {y ∈ Y | xRy}. For B ⊆ Y , define R−1(B) := {x ∈ X : R(x) ∩ B /=

∅}, and let dom(R) = R−1(Y ) = {x ∈ X | R(x) /= ∅}. Thus we think of a relation as a partial function from X to non-empty subsets of Y . For this reason, we follow Brattka by usually writing f , g, etc., as names for binary relations. Binary relations from X to Y will be indicated by f : X ↔ Y .
If X and Y are topological spaces, then f is said to be continuous if and only if f−1(V ) is open in X whenever V is open in Y . Also f is said to have closed images if f (x) is closed in Y for every x ∈ X.
If X and Y are topological (or metric) spaces, then X × Y denotes the standard topological (metric) product.
Clearly, for a function h between spaces, the graph of h is a continuous relation if and only if h is continuous in the usual sense. In particular, the graphs of projec- tion maps for cartesian products are continuous. If the codomain is T1, graphs of functions also have closed images. Furthermore, any relation f is continuous if and only if f (A) ⊆ f (A) for every A ⊆ dom(f ). Note that A ranges only over subsets of dom(f ), not over all subsets of X. This jibes with our interpretation of f (x) = ∅ as meaning that f is undefined at x.
Continuous relations are not closed under the usual relational composition. On the other hand, for continuous relations f : X ↔ Y and g : Y ↔ Z, define g ⊙ f by
(g ⊙ f )(x) := ⎧⎨ (g ◦ f )(x), if f (x) ⊆ dom(g);
⎩ ∅,	otherwise.

where g ◦ f is the usual relational composition. A simple exercise shows that con- tinuous relations are closed under ⊙.
By definition, g ⊙ f has closed images. The graph of the identity function on a space Y satisfies f = I ⊙ f if and only if f has closed images, and similarly for g = g ⊙ I. So ⊙ defines composition for a category of topological (or metric) spaces in which the morphisms are continuous relations with closed images. This can be taken to be the ambient category for Brattka’s recursive relations. Note that the graphs of projections on products of T1 spaces are continuous with closed image. So the category can be given a monoidal structure.

The interval domain
The ideas discussed in this section are considered in more detail in [5].
The set Y of non-empty connected compact subsets of the Euclidean real line forms a continuous dcpo when ordered by reverse inclusion:
x ± y iff x ⊇ y.
We regard elements of Y as “partial real numbers”; the ±-maximal intervals are singletons, corresponding to “total numbers”. That is, the continuous map x '→ {x} embeds R as maximal elements, making Y into a domain model for R. The dcpo Y, however, does not have a least element. By adding a least element, corresponding to the completely under-specified partial real number R, we obtain a bounded complete

continuous domain Y⊥.
For any x ∈ Y⊥, we write
x = inf x and x = sup x
so that x = [x, x], and define
κx := x — x.
The upper bound of a subset A ⊆ Y⊥ is  A when this is not empty. Alternatively,
. A =  A = sup x, inf x .


x∈A

The way-below relation of Y⊥ is given by
x  y iff x < y  and y < x.
x∈A

This amounts to y being a subset of the interior of x. Of course R = ⊥ a for any compact interval a. The intervals with distinct rational end-points form a basis for Y⊥.
For basis element a, consider the partial function x '→ a H x defined when a and
x are consistent. This join map has a total continuous extension:
⎧ a H x, a and x are consistent;
joinax = ⎨ {a} ,  x < a;
⎪⎪⎩ {a} ,  a < x.
Also, joina⊥ = a. The map joina can be regarded as a partial output:
Lemma 2.2 For basis elements a and b,
joinajoinb = joinaHb if a H b exists;

joinajoinb = ka if b < a;
joinajoinb = ka if a < b;
where kz denotes the constant map x '→ {z}. Thus joina ± joinajoinb always holds.
Each basis element a is also associated with a positive affine map rrconsa : R → R given by x '→ κax + a. Taking images, rrconsa extends to a strict continuous map on Y⊥. These maps form a left group action on Y⊥. Because of this, we will think of the basis of Y⊥ as itself forming a group, writing ab for concatenation, a−1 for inverse and I for the identity (that is, the interval [0, 1], corresponding to the identity affine map).
Composites of joins and affine transformations interact as follows:
Lemma 2.3 For basis elements a and b,
rrconsajoinb = joinabrrconsa;
rrconsarrconsb = rrconsab;

Proof. Straightforward.

The functions rrconsa and joina are said to be strongly convergent, meaning that they send maximal elements to maximal elements. In addition, the functions rrconsa are all homeomorphisms (rrconsarrconsa−1 rrconsI = id), so they also send non-maximal elements to non-maximal elements.

The Hoare powerdomain
In [9,10,11], the first author shows that under certain reasonable assumptions, a suitable semantics for sequential, non-deterministic real number computation re- quires the Hoare powerdomain (УH ). That is, starting from the assumption that some functorial powerdomain is needed to model non-determinism, general consid- erations about continuity show that the Hoare powerdomain is the only one that can be used. We refer the reader to the cited work for an explanation. In that work, however, the fact that УH is actually a free construction is not used explic- itly (though certain definitions in the semantics depend on it implicitly). In this section, we review the basic facts about УH as the construction of free inflation- ary semi-lattices. The reader may consult [1] for a general theory of free domain constructions defined by inequalities.
A semi-lattice in the category of domains is simply a domain equipped with a continuous binary operation ∪ : X × X → X that satisfies the usual semi-lattice laws. Such a semi-lattice is inflationary if x ± x ∪ y. It is not hard to see that idempotency is equivalent to ∪ ◦δ = idX , and inflationarity to idX×X ± δ◦ ∪, where δ : X → X × X is the diagonal map. Since these two conditions constitute a Galois connection between ∪ and δ, if ∪ exists it is unique.
The Hoare powerdomain is the free construction for inflationary semi-lattices [1]. If f : X → Y is a continuous map and (Y, ∪) is an inflationary semi-lattice, then there is a unique continuous map f : УH (X) → Y that preserves ∪ for which f = fη, where η is the unit of the powerdomain monad. There is also a unique continuous map f : УH (X) → УH (Y ) defined by f := УH (f ).
In domains, the binary formal join of an inflationary semi-lattice extends au- tomatically to formal joins of non-empty sets: For A ⊆ X, take the closure of A under ∪. This is automatically a directed set and hence has a supremum, which we denote by   . If the generating domain has a least element, then so does  H (  ). So  is defined for all subsets of УH (X).
Concretely, elements of УH (X) are non-empty Scott closed subsets of X, the unit sends x ∈ X to the closure of {x}. Also, ∪ is simply binary union, and  is closure of union.
To mediate between products and powerdomains, we exploit the fact that the Hoare powerdomain is a monoidal monad with natural transformation m : УH (X) × УH (Y ) → УH (X ×Y ) satisfying the usual coherence conditions. In concrete terms, m(A, B) := A × B.
Thus the relevant structure of the Hoare powerdomain, for our purposes, is given

by the functor УH itself, the unit η : X → УH (X), the formal union ∪: УH (X) × УH (X) → УH (X) and the transformation m : УH (X) × УH (Y ) → УH (X × Y ).
A continuous map f between inflationary semi-lattice domains X and Y pre- serves ∪ if f (x ∪ y) = f (x) ∪ f (y).

Hoare power domains of domain environments
If D and E are domain environments for spaces X and Y , we can ask when a continuous function F : УH (D) → УH (E) corresponds naturally to a continuous relation from X to Y .
Definition 2.4 Suppose X is a topological space, EX is a domain model for X
with embedding eX and d ∈ УH (EX ). Let
uX (d) := {x ∈ X | νX (x) ± d} = (νX )−1(↓d)

νX := η ◦ eX
As usual, we omit the subscripts when possible.
Furthermore, suppose that Y is a second space and EY is a corresponding domain model. Say that a relation f from X to Y is captured by F : УH (EX ) → УH (EY ) (written f ∼ F ) if and only if for each x ∈ dom(f ), f (x) = u(F (νX (x))). Say that f is exactly captured by F (written f  F ) if and only if f ∼ F and
dom(f ) = {x ∈ X | u(F (ν(x))) /= ∅} .

Say that d ∈ УH (EX ) is convergent provided that d = {ν(x) | x ∈ u(d)}. Notice that by definition νX (x) is convergent. Also say that d is divergent provided that ν(x) /± d for all x. Also, say that continuous F : УH (EX ) → УH (EY ) is disciplined provided that it preserves ∪ and for each x ∈ X, F (νX (x)) is either convergent or divergent.
For the remainder of this section, we assume that X, Y , EX , EY , and embed- dings eX , eY are fixed.
Lemma 2.5 For any closed A ⊆ X, A = u(  x∈A ν(x)).
Proof. Let x ∈ A, ν(x) is a directed set with supremum x, hence x ∈ u(x∈A ν(x)), for all x ∈ A. The converse is straightforward.	 
Lemma 2.6 For any F : УH (EX ) → УH (EY ), there is a unique relation that is ex- actly captured by F. If F is disciplined, the exactly captured relation is a continuous relation with closed images.
Proof. Proof omitted	 
This leads to the following fundamental connection between continuous relations with closed images and disciplined functions.

Theorem 2.7 Disciplined functions are closed under composition. Moreover, if F and G are disciplined, f and g are continuous with closed images, f ∼ F and g ∼ G and these “type check” in the obvious way, then (g ⊙ f ) ∼ (G ◦ F ).

Proof. Closure under composition for preservation of ∪ follows from the general theory of power domains. And G(F (ν(x))) ⊇z∈m(G(F (ν(x)))) ν(z) is immediate from the definition. Conversely, z ∈ u(G(ν(y))) and y ∈ u(F (ν(x))) implies that ν(z) ± G(ν(y)) ± G(F (ν(x))), and by preservation of ∪,
G(F (ν(x))) = y∈u(F (ν(x))) z∈u(G(ν(y))) ν(z) So G ◦ F is disciplined.
The second statement is now routinely checked.	 

Discipline is closely related to the operational concept of strong convergence discussed at length in [11]. There a closed term of ground type is strongly conver- gent if it denotes ν(x) for some x in the modeled space (although the definition is given operationally and adequacy of the operational semantics justifies the present characterization). A closed first-order term is strongly convergent if it preserves strong convergence of inputs. The reason an operational definition is given is that proof of strong convergence typically involves the operational semantics. The reader may consult [9], [10] or [11] for discussion and examples. For the purposes of the earlier work, preservation of strong convergence makes sense because the authors are interested primarily in defining functions. In the present setting, definability of relations is our main concern. So discipline can be seen as a generalization of strong convergence to a relational setting.
The ground spaces about which we are concerned have additional structure that allow a form of call-by-value, which we refer to as call-by-partial-value. In [13], Martin introduces the concept of a measurement on a continuous domain, D, as a Scott continuous function M : D → ([0, ∞], ≥). That is, M assigns a positive extended real to each element of D so that M ( A) = infa∈A M (a) for directed A. A measurement is also required to satisfy M (a) = 0 if and only if a ∈ max D.
The domains Y⊥, T⊥ and N⊥ clearly can be equipped with measurements: in Y⊥, M (a) = κa; in T⊥, M (true) = M (false) = 0; in N⊥, M (n) = 0; and in all of these M (⊥) = ∞. In a finite product of domains with measurements, a measurement on a tuple is obtained by taking the minimum measurement of the components. For any positive p, any domain D with least element and with measurement M , the function pvp : D → D given by pvp(a) = a if M (a) < p and
pvp(a) = ⊥ otherwise is continuous. Its extension to УHD satisfies pv (d) ± d and
allows us to isolate the maximal part of an element d ∈ УH (D) that can be written
a∈A η(a) where all elements of A have “small” measurement. As p decreases, pvp
decreases as well. Importantly, each pv (d) is the identity map when restricted to

convergent d
p
is the identity on Y⊥.

The Recursive Space System (R, N, T, ρR)
Using continuous relations with closed images as his ambient category, Brattka defines a combinatorial notion of recursive relation over a fixed (finite) collection of (complete, separable) metric spaces {X0,..., Xn} that includes N. In this section, we provide a brief overview of Brattka’s approach where N, T and R are the given spaces, N and T have the discrete topology, and R has the Euclidean topology.
As a guide to intuition, think of “effectivity” for a relation f : X ↔ Y as mean- ing that for each a ∈ X, the set f (a) is recursively enumerable uniformly in a. This description is far too vague and cannot actually be the whole story when Y is uncountable, but it is of some help in justifying Brattka’s approach and, once sepa- rability is taken into account, can be justified formally. In the next few paragraphs, we discuss Brattka’s combinators. The idea is to capture methods of constructing “effective” relations from “effective” relations.
To make the exposition of these ideas a bit clearer, and to come closer to the type system assumed in the PCF family of languages, we modify Brattka’s original definitions to include the two element discrete space T = {true, false}. This exten-
sion is easily seen to be conservative in that every relation definable in Brattka’s original setting is definable here, and for X and Y being products that do not in- volve T, every relation f : X ↔ Y definable here is definable in Brattka’s original setting.
Definition 3.1 In addition to ⊙-composition, define the following combinators on binary relations:
Juxtaposition Given f : X ↔ Y and g : X ↔ Z, define (f, g): X ↔ Y × Z by (f, g)(a) = {(b, c) ∈ Y × Z : b ∈ f (a) and c ∈ g(a)}
This generalizes the pairing of functions to the relational setting.
Iteration Given f : X ↔ X, define f∗ : X × N ↔ X so that f∗(x, n) is the n-fold composition of f . That is,
f∗(x, 0) := {x}
f∗(x, n + 1) := f ⊙ f∗(x, n)
Minimization Given a relation f : X × N ↔ Y × T we think of a value (y, b) ∈ Y × T as a “possible result” y together with a “status flag” b. Beginning with n = 0, minimization dovetails the enumerations of f (x, 0), f (x, 1), . . . , f (x, n) and collects the pairs (y, i) where (y, true) ∈ f (x, i), incrementing n (that is the range over which dovetailing occurs) whenever a pair (y, false) is produced by f (x, n). So define min f : X ↔ N × Y by
min f (x) := {(n, y): (y, true) ∈ f (x, n) and ∀m < n∃y' ∈ Y.(y', false) ∈ f (x, m)}
The reader may wish to show that Kleene’s minimization combinator is definable using this min (together with composition, juxtaposition and the standard basic primitive recursive functions on N).

Limitation In a (complete) metric space, a sequence {Bn}n of subsets is strongly Cauchy provided that for each i and each bi ∈ Bi, bi is the i-th element of a strong Cauchy sequence {bn}n for which bn ∈ Bn for each n. In other words, all elements of Bi participate in some strong Cauchy sequence obtained from the sets Bn. For such a sequence of subsets, define limi→∞ Bi to consist of all limits (in the usual sense) of all strong Cauchy sequences ⟨bn⟩n such that bn ∈ Bn.
For a relation C : X × N ↔ Y , the limitation combinator is defined by
lim[C](a) := ⎧⎨ limn→∞ C(a, n), C(a, n)n is strongly Cauchy;
⎩ ∅,	otherwise.

All of the above combinators (along with ⊙-composition) preserve continuity, the property of having closed images and the property of being the graph of a function ( [2]: Lemma 11).
Definition 3.2 Complete metric spaces (X0,..., Xn−1, N, T) together with a col- lection ρ of continuous relations between products formed from the given spaces is called a recursive space system provided that ρ includes the graphs of projections and is closed under the combinators of ⊙-composition, juxtaposition, iteration, min- imization and limitation.
Consider the collection βK consisting of the following relations (all graphs of familiar basic primitive recursive functions):
succ: N ↔ N – graph of the successor function.
0N : N ↔ N – graph of the constant zero function.
iszero: N ↔ T – graph of the zero test, n '→ true iff n = 0.
nt: T ↔ N – graph of the right inverse of iszero where true '→ 0, false '→ 1.
Let ρ'  be the least set of relations between products of N and T that includes
βK and the graphs of projections, and is closed under Brattka’s combinators except for lim. It is not difficult to see that for relations between discrete spaces ⊙ is simply
the usual relational composition. So every relation f : Nk ↔ N in ρ' is the graph
of a Kleene recursive (partial) function. Likewise, the graph of every such function
appears in ρ' . In this sense, Brattka’s recursive relation spaces generalize Kleene’s
combinatorial approach to recursive functions on N.
In this paper, we are primarily concerned with the recursive space system ob- tained by including R with its field structure. Since there are no continuous func- tions from R to N or to T, a non-deterministic test is included. That is, let βR consist of βK plus the following relations:
0R : R ↔ R – the graph of constant zero.
1R : R ↔ R – the graph of constant one.
• +: R × R ↔ R – the graph of the addition.
∗ : R × R ↔ R – the graph of multiplication.

neg : R ↔ R – the graph of negation.
inv : R ↔ R – the graph of reciprocation, x ∈ inv(y) iff xy = 1.
ord : R ↔ T – true ∈ ord(x) iff x < 0, false ∈ ord(x) iff 0 < x + 1. Let ρR be the least recursive space system including βR.
For X = R, N, T, we assume given a partial continuous function δX from Baire
space B to X that is surjective. For X being a finite product of these spaces, δX is also definable inductively by pairing the functions defined on the three basic spaces. We omit the details of this, referring the reader to [2].
A partial computable function F : B → B determines a partial computable func-
tion Fˆ : B × N → B by Fˆ(p, n)(k) = F (p)⟨n, k⟩ where ⟨⟩ : N2 → N is Cantor’s

(computable) bijective pairing function.  The function Fˆ
Fˆ(p, n) is defined if and only if F (p) is defined.
has the property that

Brattka defines a relation f : X ↔ Y to be densely computable if there exists a partial computable F : B → B so that for all p ∈ B if δX (p) ∈ dom(f ), then
f (δX (p)) =	δY (Fˆ(p, n)) | n ∈ N . Furthermore, he defines f to be strongly densely computable if, in addition, p ∈ dom(F ) implies δX (p) ∈ dom(f ).
The main result of Brattka’s paper for our purposes is the following characteri- zation of the relations in ρR in terms of Type 2 Theory of Effectivity [18].
Theorem 3.3 (Corollary 33 and Theorem 34 in [2]) If f ∈ ρR, then f is densely computable. If f is strongly densely computable, then f ∈ ρR.


LRTp
The language LRT is a modification of RealPCF considered by Escardo´


[4] for

real number computation. In LRT, parallel conditional pif is replaced by a non- deterministic test rtestl,r. In this section, we describe a variant of LRT suitable for comparison to the recursive space system described above. The language LRTp differs from LRT in three ways: products of ground types are made explicit, the type
I for the compact interval [0, 1] is eliminated in favor of a type corresponding to R, and a let construct is introduced that provides for call-by-partial-value semantics.

Syntax
Syntactically, the type system for LRTp is given by
γ := nat | bool | real
β := γ | γ × β
τ := β | (τ → τ )
Types in the first clause are ground types; in the second clause, basic types; and in the third clause, general types. As usual, we associate → right to left, and omit parentheses when we can.
The raw syntax of the language is given by

x ∈ V ariable,
P ::= x | n | true | false | (+1)(P ) | (—1)(P ) |
(= 0)(P ) | if P then P else P | rrconsa(P ) | joina(P ) | rtestl,r(P ) | λxτ .P | PP | YP | let x = P in P |
priP | ⟨P0,..., Pn⟩
where (+1)(P ), (—1)(P ) and (= 0)(P ) amount for successor, predecessor and equal- ity for zero respectively; the subscripts of the constructs rrcons and join are proper rational intervals and those of rtest are rational numbers. In the let construct, the first term P must be of basic type.
In addition, we allow ourselves the syntactic sugar of writing
let ⟨x0,..., xn⟩ = P1 in P2
where the notation ⟨x0,..., xn⟩ stands for a variable of the appropriate product type and where free occurrences of xi in P2 abbreviate pri⟨x0,..., xn⟩.
Terms can be associated with types in the familiar style by proof rules and judgements, but in the interest of brevity, we trust the reader to fill in the details.

Denotational Semantics

We define denotational semantics —)p for LRTp subject to a positive real num- ber parameter p in such a way that M )p is semi-continuous in p and p M )p corresponds to call-by-name interpretation. The idea is to employ pvp (see page 8) in the interpretation of the let construct to ignore differences due to “badly” di- vergent behavior. As p increases, the semantics ignores less. We use B ) to denote basic types, which includes ground types and product types.
The ground types bool, nat and real are interpreted, first, as the domains of booleans (T⊥), natural numbers (N⊥) and compact intervals (Y⊥), respectively. That is,
B bool) := T⊥,	B nat) := N⊥,	B real) := Y⊥.
Finite products are interpreted the usual way: B γ × β) := B γ) × B β). Basic types are interpreted as Hoare powerdomains of finite products:

 β) := УH (B β)).

Function types are interpreted as function spaces in the category of dcpos:

 σ → τ ) := σ) → τ ).

These definitions reflect a call-by-name semantics in which product types are inter- preted as consisting of computations of tuples, rather than tuples of computations.

The interpretation of constants is given as follows:
 true)p = η(true),	 false)p = η(false),	 n)p = η(n),

 (+1))p = (^+1),	 (—1))p = (^—1),	 (= 0))p = (^0 =),
 joina)p = joina,	 rrconsa)p = r^rconsa,
 rtestl,r)p = rtestl,r,	 Y)p(F ) =	Fn(⊥),
n≥0
⎧X,	if B = η(true),
 if)p(B, X, Y )	Y,	if B = η(false),
X ∪ Y,	if B = η(true) ∪ η(false),
⎪⎩⊥,	if B = ⊥,
with syntactic sugar,

 if M then N else P )p := if)p( M )p, N )p, P )p)
ρ	ρ	ρ	ρ


 pr )p = π ,
i	^i
where πi is the usual projection map. Tuples are interpreted by
 ⟨X1,..., Xn⟩)p := m( X1)p,..., Xn)p)
ρ	ρ	ρ

Note that so far, none of these definitions depend on the parameter p. The let
construct enforces what we refer to as call-by-partial-value.


let
= M in N )p := N )pρ(x/pv ( M )p))

x	ρ	^p	ρ
the unit, f := УH (f ), f denotes the transpose of f : X → УH (Y ), m is the natural transformation УH (X0) × ... УH (Xn) → УH (X0 × ... × Xn). The functions (+1), (—1), (= 0) are the standard interpretations in the Scott model of PCF [15], the functions joina, rrconsa are defined in section 2.2, and the function rtestl,r is defined by:



rtestl,r
⎧η(true) ∪ η(false),	if l < x < x < r;

(x)	η(true),	if x ≤ r;
η(false),	if x ≥ l;
⎪⎩⊥,	otherwise.

Lemma 4.1 The constants (+1), (—1), (= 0), rtestl,r, joina, rrconsa and pri
denote disciplined functions.
Proof. Proof omitted	 

Lemma 4.2 The semantics —)p is semi-continuous in p: for bounded A ⊆ R+,

 M )p = M )sup A.
p∈A

Moreover, deﬁne )∞ exactly as )p for all cases except

 let x = M in N )∞ := N )∞ρ(x/ M )∞))
ρ	ρ

Then M )∞ = .p M )p.


Operational Semantics
We now develop single-step operational semantics, also parametric in p, so that the “p-th” operational interpretation is complete for —)p. We do not need an operational semantics corresponding to —)∞.

Definition 4.3 For each basic type β, we define a subset of the closed terms to be output terms, and for each output term M we define it’s output o(M ) to be a value in B β).
For real, a term of the form joinaM is an output term, and o(joinaM ) := a. For nat, a term of the form n is an output term, and o(n) = n. For bool, a term of the form true or false is an output term, and o is defined obviously. For γ × β, a term of the form ⟨M, N⟩ is an output term provided M and N are output terms, and o(⟨M, N⟩) = ⟨o(M ), o(N )⟩.

Lemma 4.4 For an output term M and p > 0,

η(o(M )) ± M )p ±  {ν(x) | o(M ) ± ν(x)} .


Proof. For an output term of type real, let x ∈ η(o(joina(M'))), hence x ∈ η(a) ± joina M')p = joina(M'))p. The second inequality is derived from the fact that ν(x) = η ◦ e(x). The proof for the other output terms is similar.	 


We define →p to be the least relation that includes single-step reduction rules for PCF [15] and is closed under rules for the type real and for let as follows.

rrconsa(rrconsbM ) →p rrconsabM



joinajoinbM →p joinaHbM	if b > a or a > b 
joinajoinbM →p rrconsaY (rrconsLjoinI )	if b ≤ a

joinajoinbM →p rrconsaY (rrconsRjoinI )	if a ≤ b
rrconsa(joinbM ) →p joinab(rrconsaM )

rtestl,rjoinaM →p true	a < r 
rtestl,rjoinaM →p false	l < a
if true then M else M' →p M
if false then M else M' →p M'
pri⟨M0,..., Mn⟩ →p Mi
let x = M in N →p [M/x]N	M is an output term
and μ(o(M )) < p 

N →p N'
MN → MN'
if	M	is	joina,

p	rrconsa,	rtestl,r,
if, pri, let and none of the above hold.
Definition 4.5 We define the operational meaning of a closed term M of basic type β in i steps of computation, written [M ]p ∈ β).
For a closed term of basic type β, define [M ]i as follows:
[M ]p =   {η(o(M')) | ∃M '∃k ≤ i, M' is an output term and M →k p M' },

where an empty formal join is ⊥, and →k p denotes the k-fold composition of the relation →p.
Finally,
[M ]p = .[M ]p.
i
which is justified by the obvious fact that [M ]p ± [M ]p  .
i	i+1
Note that implicit in this definition is the fact that the operational rules are such that M →k p M' can only hold for finitely many output terms M'. This can be established easily by induction on the operational rules.
The operational interpretation of closed terms is adequate with respect to the denotational semantics.
Lemma 4.6  M )p =  { N )p | M →p N} (this is a ﬁnite union).
Proof. Most of the details of the proof duplicate the analogous result in [9], except for let.

For let x = M in N →p	[	], the restriction on M implies that pv ( M )p) = 
 M )p. So the remaining argument for this case reduces to the argument for β- reduction.	 
Lemma 4.7 For all closed terms M of ground type,
[M ]p ± M )p.

Proof. Proof omitted	 
Definition 4.8 A closed term is said to be p-computable as follows:
A closed term M of basic type is p-computable whenever M )p ± [M ]p,
A closed term M : σ → τ is p-computable whenever MQ : τ is p-computable for every closed p-computable term Q of type σ,
An open term M : σ with free variables x1,..., xn of type σ1,..., σn is p-computable whenever [N1/x1] ··· [Nn/xn]M is p-computable for every family Ni : σi of closed p-computable terms.
Lemma 4.9 Every term of LRTp is p-computable.
Proof. Proof omitted	 
Theorem 4.10 [M ]p =  M )p, for all closed LRTp terms M and all positive reals
p.
Proof. Lemma 4.7 and Lemma 4.9.	 

Translations
The main aim of this section is to establish that all recursive relations in Brat- tka’s system (R, N, T, ρR) are programmable in LRTp and that all first-order closed terms of LRTp correspond to recursive relations. A recursive relation is (forget- fully) a function from a set X to a powerset У(Y ), but generally first-order terms of LRTp do not correspond to relations between the underlying domains. So the familiar technique of establishing a logical relation will not work here unmodified. For a first-order function f ∈ β1 → β2), the composite f ◦ η is a map from the underlying domain B β1) to УH (B β2)). In other words, we can think of f as an “implementation of” a certain kind of relation from B β1) to B β2). In order to dis- tinguish the domain-theoretical interpretation of basic types from the set-theoretic interpretation in LRTp, we use R ) for the latter.
Definition 5.1 For basic LRTp types, we define a set-theoretic interpretation as follows:
R nat) = N,
R bool) = T,
R real) = R,

R γ × β) = R γ) × R β),
Theorem 2.7 establishes that composition in LRTp corresponds to ⊙-composition. That is, if P and Q are closed terms of type β1 → β2 and β2 → β3, both are disci- plined and f ∼ F ) and g ∼ G), then g ⊙ f ∼ λx.let y = F (x) in G(y))p. We extend this to the other recursion operators.
Definition 5.2 Define the following closed terms of LRTp:
Jx[F, G](x) := ⟨F (x), G(x)⟩
Iter[F ](z) := let ⟨x, n⟩ = z in if (= 0)n then x else F (Iter[F ](⟨x, (—1)n⟩))
Min[F ](x) := Min'[F ](x, 0)
Lim[F ](x) := aux lim F (x, 0) id
where
Min'[F ](x, n)  :=
let ⟨y, b⟩  =  F (x, n) in if b then ⟨y, n⟩ else Min'[F ](⟨x, (+1)n⟩)

aux lim F (x, n) G  :=
let r = G(F (x, n)) in if rtest−1,1(r)
then if rtest−1,−1/2(r)
then join[−2,−1](aux lim F  (x, n) (rrcons[1,2] ◦  G))
else aux lim' F (x, n) G
else if rtest1/2,1(r)
then aux lim' F (x, n) G
else join[1,2](aux lim F (x, n) (rrcons[−2,−1] ◦ G))
aux lim' F (x, n) G  :=
let r = G(F (x, n)) in if rtest−5/16,5/16(r)
then if rtest−5/16,−4/16(r)
then consL(aux lim F (x, (+1)(n)) (tailL ◦ G))
else consC(aux lim F (x, (+1)(n)) (tailC ◦ G))
else if rtest4/16,5/16(r)
then consC(aux lim F (x, (+1)(n)) (tailC ◦ G))
else consR(aux lim F (x, (+1)(n)) (tailR ◦ G))

consa := joinA rrconsa taila := joinA rrconsa−1 A := [—1, 1]
L  :=  [—1/2, 0]
C  :=  [—1/4, 1/4]
R  :=  [0, 1/2]
In these definitions we understand Jx, for example, to be a third-order term, where F and G are arguments.  We set them apart for readability using square

brackets.
Lemma 5.3 For any p < 1/4, in the semantics —)p, the terms Jx, Iter, Min and Lim preserve discipline. Moreover, if f ∼ F and g ∼ G and these “type check” in the obvious way, then
(f, g) ∼ Jx)p(F, G);
f∗ ∼ Iter)pF;
min f ∼ Min)pF;
lim f ∼ Lim)pF.
Proof. The proof is straightforward, except for Lim. For that, the assumption p < 1/4 is needed to ensure that the set of limits of strong Cauchy sequences in which ri appears as the i-th term is bounded within a distance of 2−(i+2) from ri. In fact, this is the only point at when the assumption that p is small is required. 
Theorem 5.4 For every relation in f : R β1) ↔ R β2) belonging to ρR, there is a closed ﬁrst-order LRTp term Pf : β1 → β2 and p > 0 for which Pf )p is disciplined and f ∼ Pf )p. Furthermore, for every closed ﬁrst-order LRTp term P : β1 → β2 and p > 0 such that P )p is disciplined, there is a relation fP : R β1) ↔ R β2) belonging to ρR for which fP  P )p.
Proof. [Sketch] The basic relations in ρR are programmable in LRTp because the language supports general recursion on nat, ord ∼ rtest0,1) and the arithmetic functions are easily programmed in LRTp. The proof that each of these is disciplined is implicit in their proofs of correctness. The first claim holds for non-basic relations by induction using Lemma 5.3.
For the second claim, one can devise a G¨odel numbering system ’ for LRTp terms along with the standard primitive recursive apparatus for substitution, type checking and so on.	 

Conclusion
In this paper, we consider the relational semantics of non-deterministic, sequential exact real number computation in the style of RealPCF and LRT. The semantic interpretation, both denotational and operational, is parameterized by a positive real number that allows for control of a limited form of call-by-value, which we refer to as call-by-partial-value. Although our original goal was to characterize the expressive power of LRT with respect to Brattka’s recursive relations, we have found that in a non-deterministic setting, the call-by-name semantics of LRT is inadequate. Nevertheless, for exact real number computation, a value, i.e., a real number, is only understood to be a limit of finitely computable partial values. Operationally, no term corresponds to a total real number value. Even if we were to include countably many explicit names (say for the rationals), uncountably many values will be missed, so call-by-value semantics is out of the question. Nevertheless, by defining a parameterized family of interpretations in which partial reals of a specified

precision are treated as values, a middle ground is struck between call-by-value and call-by-name.

References
Abramsky, S., and A. Jung, Domain Theory, in: S. Abramsky and D. Gabbay and T. S. E. Maibaum, eds., Handbook of Logic in Computer Science 3 (Oxford University Press, 1994) 1–168.
Brattka, V., Recursive characterization of computable real-valued functions and relations, Theoretical Computer Science 162 (1) (1996) 45–77.
Di Gianantonio, P., “A Functional Approach to Computability on Real Numbers ”, PhD thesis, (Udine, 1993).
Escard´o, M. H., PCF Extended with Real Numbers, Theoretical Computer Science 162 (1) (1996) 79–115.
Escard´o, M. H., “PCF extended with real numbers: A domain-theoretic approach to higher-order exact real number computation”, PhD thesis at Imperial College of the University of London, 1997.
Escard´o, M. H., M. Hofmann., and Th. Streicher, On the non-sequential nature of the interval-domain model of exact real-number computation, Mathematical Structures in Computer Science 14 (6) (2004) 803–814.
Farjudian, A., “Sequentiality in Real Number Computation”, PhD thesis at the University of Birmingham, 2004.
Levy, P.B., Call-by-push-value: A subsuming paradigm, in: Typed Lambda Calculus and Aplications, (1999) 228–242
Marcial-Romero, J. R., “Semantics of a sequential language for exact real-number computation”, PhD thesis at the University of Birmingham, 2004).
Marcial-Romero, J. R. and M. Escard´o, Semantics of a sequential language for exact real-number
computation, in: Harald Ganzinger, editor., Proceedings of the 19th Anual IEEE Symposium on Logic in Computer Science, (IEEE Computer Society press, July 2004) 426–435.
Marcial-Romero, J. R. and M. Escard´o, Semantics of a sequential language for exact real-number computation, Theoretical Computer Science 379 (1-2) (2007) 120–141.
Martin, K., Domain theoretic models of topological spaces, in: A. Edalat and A. Jung and K. Keimel and M. Kwiatkowska, eds., Proceedings of Complox III, ENTCS (Elsevier, 1998) 13 173–181.
Martin, K., The measurement process in domain theory, in: Automata, Languages and Programming, (2000) 116–126.
Moggi, E., Notions of Computations and Monads, Information and Computation 93 (1) (1991) 55–92.
Plotkin, G. D., LCF Considered as a Programming Language, Theoretical Computer Science 5 (1)
(1977) 223–255.
Potts, P. J., A Edalat. and M. H. Escard´o, Semantics of Exact real arithmetic, Proceedings 12th IEEE Symposium on Logic in Computer Science (IEEE Computer Society press, July 1997) 248–257.
Scott, D., Lattice theory, data type and semantics, in: Randall Rustin, editor, eds., Formal Semantics of Algorithmic Languages (Prentice Hall, 1972) 65–106.
Weihrauch, K., “Computable Analysis”, Springer-Verlag, 2000.
