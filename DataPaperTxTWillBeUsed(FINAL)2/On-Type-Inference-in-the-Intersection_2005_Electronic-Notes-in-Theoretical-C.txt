Electronic Notes in Theoretical Computer Science 136 (2005) 23–42  
www.elsevier.com/locate/entcs


On Type Inference in the Intersection Type Discipline
G´erard Boudol and Pascal Zimmer1 ,2
INRIA Sophia Antipolis, BP93 06902 Sophia Antipolis Cedex, France

Abstract
We introduce a new unification procedure for the type inference problem in the intersection type discipline. We show that unification exactly corresponds to reduction in an extended λ-calculus, where one never erases arguments that would be discarded by ordinary β-reduction. We show that our notion of unification allows us to compute a principal typing for any strongly normalizing λ-expression.
Keywords: λ-calculus, type systems, type inference, unification


Introduction
Type inference – say, for any λ-calculus based model –, as it is now presented in textbooks (see for instance [18], p. 136), generally proceeds as follows:
	Assign a type to the expression and each subexpression. For any compound expression or variable, use a type variable.
Generate a set of constraints on types, reflecting the fact that, if a function is applied to an argument, then the type of the argument must agree with the type of the domain of the function.
Solve these constraints.

1 email: Gerard.Boudol@sophia.inria.fr
2 email: Pascal.Zimmer@sophia.inria.fr



1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.016


This design of a type inference algorithm was first (as far as we can see) proposed by J. Morris in his thesis [20]. At the first step of this procedure, a decision has to be taken, in order to build the type of a function, that is an abstraction λxM : in which way do we consider the collection of type variables
t1,... , tm assigned to the various occurrences of x in M as a type? There are
various possibilities, which are not unrelated:
Simple (monomorphic, possibly recursive) types: a variable x has only one type. That is, one has the constraint that the ti’s are equal (with or without “occur check”).
Generalized (polymorphic) types: the constraint here is that x is only used in M with types which are instances of the type of the domain of λxM .
Intersection types: the collection t1,... , tm is considered as a type, inter- preted as the conjunction of the ti’s.
Subtyping: x is only used in M with types which are subtypes of the type of the domain of λxM .
(The question, and thus the possible answers, would be different regarding the “let” construct, that is (λxMN ), where the abstraction λxM does not have to be explicitly typed, see for instance [11,17].)
In this paper we are interested in type inference for the intersection type discipline, introduced by Coppo and Dezani [8], and independently by Pot- tinger [21] (see [2,4] for a complete review of various systems with intersection types). There is no algorithm for deciding typability in this system, called
“system D” in [16], since this is equivalent to strong normalizability. How- ever, one can compute a principal typing for any typable expression [9,16,24], that is a typing from which any other typing for the given expression can be
derived, by means of suitable operations, among which the most important one is expansion (for an explanation of this notion, see for instance [3]). Type inference can be achieved by normalizing the expression, and then typing the
normal form, but obviously this cannot be extended to a language where one may wish to type non-terminating programs. Ronchi proposed in [23] a di- rect procedure, based on a generalized unification mechanism. This was later revisited by Kfoury [13], and then Kfoury and Wells [14], who used explicit
expansion variables, in order to provide a better understanding of the opera-
tion of expansion, and showed that type inference is decidable for subsystems with a bounded rank restriction.
In this paper we introduce a new way of solving the typing constraints that arise from type inference for intersection types. To give an idea of our generalized unification procedure, let us recall that the constraints to solve


which are attached to an application node (MN ) have the form

(τ → t) = σ

where t is the type variable assigned (at step 1) to the node, τ is the type of
the argument N , and σ is the type of M . When M is a function λxM ' – that is, when the application is a redex –, the latter has the form (t1,... , tm → θ) where t1,... , tm is the conjunction of the type variables assigned to x in M ',
and θ is the type of M '. Then, mimicking the β-reduction of (λxM 'N ) into
{x '→N }M ', our generalized unification procedure identifies t with θ, makes m distinct copies of the constraints associated with the argument N , and iden- tifies the ti’s with the appropriate copy of the type τ of N . This, however, is not correct in the case of a βK-redex, where m = 0, since we could then miss
to check that some subterms are typable. For instance, it would be wrong to declare that the expression (λu.F(uu))∆, where F = λxλy y and ∆ = λz(zz) is typable (in system D). We should rather keep in any case a copy of the con- straints associated with the argument in a redex, instead of removing them,
as it happens with β-reduction. Then we will show that our unification pro- cedure exactly corresponds to reduction in an extended λ-calculus, where one never erases subexpressions that would be discarded by ordinary β-reduction. This calculus, which builds upon Klop’s one [15], was introduced in [5]. It uses
in particular Klop’s construction [M, N ] where N is a “discarded” expression. For instance, the expression above reduces to (λu[λy y, (uu)]∆) in this calcu- lus. In order to perform the appropiate expansions in solving type equations, we shall keep, associated with each equation (τ → t) = σ corresponding to an
application (MN ), its territory, which is the set of type variables assigned to
subexpressions of the argument N . This is generally not directly accessible form the set of equations, because in an expression [M, N ], the constraints associated with N are disconnected from those of M .
Our semi-algorithm for type inference has been implemented by the sec- ond author of this paper, see [25]. For any λ-expression, it computes, when it exists, its principal typing, in the sense of [9,16,24]; more precisely, it com- putes a proof of the principal typing. Like the one of Kfoury and Wells [14], our semi-algorithm terminates when restricted to types of a bounded rank. Although it is, to our view, simpler, and thus easier to prove correct, it is not less (nor more) complex than Kfoury and Wells’ one: indeed, it is shown in
[19] that the type inference for system I of [14] is intrinsically as complex as strong normalization. A similar result holds for our type inference procedure, although we do not have to resort to sharing graphs and proof nets, as in [19], to establish a direct correspondence between β-reduction – or more accurately κ-reduction, see below – and the reduction of typing constraints.


When this paper was about to be finished, we became aware of [7], which presents a seemingly similar result. Indeed, a main result of [7] is that the type inference process proposed in that paper corresponds to β-reduction. However, there are two major differences with the results presented here: first, unlike [7], we do not use the notion of an “expansion variable” that was introduced in [13] (see also [14]). Second, [7] deals with an extended intersection type discipline where the type ω, introduced by Sall´e in [22], is assigned to any term (this is called “system DΩ” in [16]), thus making the typability problem trivial, whereas we deal with “system D” where only strongly normalizing λ-terms are typable. Clearly, there cannot exist a correspondence between β-reduction and type inference in system D, because of βK-redexes, and this is why we use a variant of Klop’s calculus instead. We also notice that, although a notion of principal typing does exist for “approximate normal forms” in system DΩ (see [9,24]), such a notion does not seem to exist for all (typable) expressions, and especially for λ-terms with an infinite Bo¨hm tree, like for instance the fixpoint combinator ∆(λyλf.f (yyf )). This contrasts with system D, where a principal typing exists for any typable expression.

The Extended λ-Calculus
Our extended λ-calculus is basically Klop’s one [15], with some differences that are explained in [5]. The syntax is as follows:
M, N ...  ..  x | λxM  | (MN ) | [M, N ]
In the new construction [M, N ] which is added to the λ-calculus primitives, M is the main expression, and N is an expression that is discarded when interpreting [M, N ] as an ordinary λ-expression. The operation of (capture avoiding) substitution, denoted {x '→N }M , is defined as usual. To define our
notion of reduction κ, we allow n to be 0 in an expression [··· [M, N1] ··· , Nn],
in which case this denotes M . We abbreviate this as [M, N1,... , Nn], and sometimes even [M,.. .]. The reduction −→ is then given by the two following
κ

axiom schemas:
x ∈ fv(M )

([λxM,.. .]N ) −→ [{x '→N }M,.. .]
κ

x /∈ fv(M )

([λxM,.. .]N ) −→ [M,...,N ]
κ

It has beeen shown in [5] that in this calculus, strong and weak normalization coincide.
Example 2.1 To illustrate the various notions introduced in our paper, we shall use the λ-term F(λu.∆(uu)), that is (λxλyyλu(λz(zz)(uu)). For this


expression, we have the following reductions:

F(λu.∆(uu)) −→ [λyy, λu.∆(uu)]
κ
F(λu.∆(uu)) −→ F(λu.(uu)(uu))
κ

Now let us introduce the intersection type system for this calculus. It is convenient to consider types where conjunction does not occur on the right of an arrow (this is not a serious restriction, see [4,5] for instance). That is, the syntax of types is as follows – where t is any type variable:

τ, σ ... ..  t | (π → σ)	prime types
π, κ... ..  ω | τ  | (π ∧ κ)	types

In the type system, we consider types modulo the congruence ≡UACI generated by the following equations:

(ω ∧ π) = π	(U)
((π0 ∧ π1) ∧ π2) = (π0 ∧ (π1 ∧ π2))	(A) (π0 ∧ π1) = (π1 ∧ π0)	 (C)
(π ∧ π) = π	(I)

Indeed, we shall most often write prime types as (τ1,... , τn → σ) where the order in the sequences τ1,... , τn is irrelevant (that is, the sequence τ1,... , τn stands for an arbitrary conjunctive combination of these types, and it denotes
ω when n = 0). We have included the idempotency property (I) mainly for completeness, that is, more precisely, to ensure that the intersection type system we use is a conservative extension of the standard system of simple types (where sequences are restricted to contain only one element). However, it should be pointed out that this idempotency property will not be used in any technical development.
The judgements of the type system have the form Γ ▶ M : τ , where Γ is, as usual, a typing context, assigning types to a finite number of λ-variables. We denote by Γ ∧ ∆ the conjunction of Γ and ∆, which is defined in the obvious
way (that is, pointwise, assuming that Γ(x) is ω for any x not in the domain of Γ). The congruence ≡UACI is extended pointwise to typing contexts, that is, Γ ≡UACI ∆ means Γ(x) ≡UACI ∆(x) for any x. The rules of the type system



are as follows:


x : τ ▶ x : τ


Γ ▶ M : σ	Γ(x) = π Γ\x ▶ λxM : (π → σ)


Γ ▶ M : σ	∆ ▶ N : τ


Γ ∧ ∆ ▶ [M, N ] : σ

where Γ\x denotes the typing context obtained from Γ by removing the typing assumption about x, if any.


Γ ▶ M : (τ1,... , τm → σ)	∀i.∆i ▶ N : τi


Γ ∧ ∆1 ∧ ··· ∧ ∆m ▶ (MN ) : σ

m > 0
Γ ▶ M : (ω → σ)	∆ ▶ N : τ

Γ ∧ ∆ ▶ (MN ) : σ





For instance, we have:
Γ ▶ M : τ	∆ ≡UACI Γ

∆ ▶ M : τ


	
z : τ0 → τ1 ▶ z : τ0 → τ1	z : τ0 ▶ z : τ0 z : (τ0 → τ1) ∧ τ0 ▶ (zz) : τ1

▶ ∆ : ((τ0 → τ1) ∧ τ0) → τ1
Example 2.1 (continued) The expression F(λu.∆(uu)) is typable, with type τ → τ , since F is typable, with type σ → τ → τ , and λu.∆(uu) is typable, with type
σ = (θ → τ0 → τ1), (θ → τ0),θ → τ1
We can easily extend the classical result that β-normal forms are typable in such a system (see [8,16]). To see this, let us first observe that the set N of normal forms (that is, κ-irreducible expressions) P , Q... of our extended
λ-calculus is given by the following grammar:

P, Q... ..  H  | λxP  | [P, Q]
H  ..  x | (HP ) | [H, P ]
We denote by hv(H) the head variable of H, that is
hv(x) = x	and	hv(HP ) = hv([H, P ]) = hv(H)
Then we define, up to the renaming of type variables, the canonical typing of
P . This is a pair of a typing context and a type, written Γ ▶ τ , inductively


given as follows, observing that, if P is an H with head variable x, this has the shape
{x : τ1 → ··· τn → t}∧ Γ' ▶ t
where t does not occur in Γ'.
x : t ▶ t is the canonical typing of x, where t is any type variable;
if ({x : τ1 → ··· τn → t} ∧ Γ) ▶ t is the canonical typing of H and ∆ ▶ τ
is the canonical typing of P , involving disjoint sets of type variables, then
{x : τ1 → ··· τn → τ → t}∧ Γ ∧ ∆ ▶ t

is the canonical typing of (HP );
if Γ ▶ τ is the canonical typing of P and Γ(x) = π (with π = ω if
x /∈ dom(Γ)), then Γ\x ▶ π → τ is the canonical typing of λxP ;
if Γ ▶ τ and ∆ ▶ σ are respectively the canonical typings of P and Q, involving disjoint sets of type variables, then Γ ∧ ∆ ▶ τ is the canonical typing of [P, Q].
It is easy to check that the canonical typing Γ ▶ τ of a normal form P is indeed a valid typing, that is, Γ ▶ P : τ is provable. We also recall that it has been shown (see [9,?]) that, for any λ-expression M having a β-normal form N , the canonical typing of N is a principal typing for M , in the sense that it is a valid typing for M , from which any other typing can be derived, by means of suitable operations. To conclude this section, we notice that one
can extend the classical result relating typability and strong normalization:
Theorem 2.2 In the extended λ-calculus, an expression is typable if and only if it is strongly normalizable.
The fact that typability implies strong normalization was established in [5] (the “subject reduction” property only uses AC). Conversely, it is not difficult to check (proving a “subject expansion” property, along the lines given in [1] for instance) that a strongly normalizing expression of the extended λ-calculus is typable.

Typing Constraints
In this section we define the constraints that are associated with an expres- sion, in order to perform type inference. The constraints are, as usual, type equations, but they involve types of a restricted shape, that we call skeletal.
A skeletal type is either a type variable, or a type of the form (t1,... , tm → ξ)


where ξ is skeletal (and the ti’s are type variables). The syntax is as follows :

ξ, ζ ... ..  t | (φ → ξ)	skeletal types
φ, ψ ... ..  ω | t | (φ ∧ ψ)
As we said in the introduction, a first phase of the type inference process consists in assigning types to the expression to type, and its subexpression,
assigning (distinct) type variables to compound expressions (MN ) and (oc- currences of) λ-variables. That is, we start with annotated expressions A, B ... defined as follows. We simultaneously define the set A of annotated expressions, together with the set tyvar(A) of type variables occurring in A.
The set A is inductively defined by:
	for each λ-variable x and each type variable t, the expression xt is in A, and tyvar(xt) = {t};
if A ∈A then λxA ∈A and tyvar(λxA) = tyvar(A);
if A ∈A and B ∈A with tyvar(A) ∩ tyvar(B) = ∅, and t is a type variable not in tyvar(A)∪tyvar(B) then (AB)t∈A and [A, B]∈A with tyvar((AB)t) = 
{t}∪ tyvar(A) ∪ tyvar(B) and tyvar([A, B]) = tyvar(A) ∪ tyvar(B).
Example 2.1 (continued) An annotated version of F(λu.∆(uu)) is, under- lining the type variables corresponding to an application node:
(λxλyyt0 λu(λz(zt1 zt2 )t3 (ut4 ut5 )t6 )t7 )t8
We define various functions over annotated terms: first, erase is the func- tion that erases the type annotations, producing an expression of the extended λ-calculus from an annotated expression (the definition is obvious). Then typ associates a (skeletal) type with an annotated expression. This is defined as
follows, using auxiliary functions ΓA which, given an annotated expression A, associate a (φ) type (that is, a sequence of type variables) with each λ-variable:


typ(x ) = t	Γxt (y) = 
⎧⎨ t if y = x
⎩⎧ ω otherwise

typ(λxA) = (ΓA
→ typ(A))	Γ


λxA
= ⎨ ω	if y = x
⎩ ΓA(y) otherwise

typ((AB) ) = t	Γ(AB)t = (ΓA ∧ ΓB)
typ([A, B]) = typ(A)	Γ[A,B] = (ΓA ∧ ΓB)


As the notation suggests, in what follows we also consider ΓA as a typing context associated with A. For instance, we have
typ(λz(zt1 zt2 )t3 ) = t1, t2 → t3
With an annotated expression A we finally associate a set of constraints to solve in order to type erase(A). These are, as usual, type equations typ(A1) → t = typ(A0) attached to application nodes (A0A1)t in the expression, except that we have to record also the territory of the equation, which is the set
of type variables that have to be duplicated when the equation is reduced, namely tyvar(A1)( 3 ). Then the constraints have the form (τ ⊥ σ; T ) where T is a set of type variables. We write τ ⊥ σ, instead of τ = σ, to remind that the left (resp. right) member of an equation should be considered as negative (resp. positive), see [6,12].  The set EA of constraints associated with A is
defined inductively as follows:

Ext = ∅ EλxA = EA
E(AB)t = {(typ(B) → t ⊥ typ(A); tyvar(B))}∪ EA ∪ EB
E[A,B] = EA ∪ EB

Example 2.1 (continued)	Associated with the annotated version (λxλyyt0 λu(λz(zt1 zt2 )t3 (ut4 ut5 )t6 )t7 )t8
of F(λu.∆(uu)), we get the following set of constraints:

E0 = { (t4, t5 → t7) → t8 ⊥ ω → (t0 → t0); {t1,... , t7}, t6 → t7 ⊥ t1, t2 → t3 ; {t4, t5, t6},
t5 → t6 ⊥ t4 ; {t5}, t2 → t3 ⊥ t1 ; {t2}} 
There are two kinds of equations in EA: those of the form (ξ → t) ⊥ t'
correspond to application nodes in A where the function is a λ-variable or

3 Without the construction [M, N ], this could be derived from the equations, starting from the set of type variables in typ(A1), and including in the territory all the type variables occurring in an equation ξ → t′ = ζ whose root t′ is already in the territory.


an application, while equations of the shape (ξ → t) ⊥ (t1,... , tn → ζ) correspond to application nodes where the function to apply is a λ-abstraction, that is to redexes, of the form ([λxA',.. .]B)t. It is worth observing that, given the polarities assigned to the members of an equation, and the fact that in a
typing Γ ▶ τ the types in the image of Γ are negative, whereas τ is positive,
we have:
Remark 3.1 (i) Each type variable t assigned to an application node has
exactly one negative occurrence in an equation of EA, namely in the equation (ξ → t) ⊥ ζ associated with the node. Moreover, it has at most one positive occurrence, either in EA, if the application node is a subexpression of another
application, or in typ(A).
(ii) Each type variable assigned to a λ-variable x has exactly one negative occurrence, either in EA, if x is bound by a λ-abstraction which is a subex- pression of an application, or in ΓA, and at most one positive occurrence, in
EA, if x is a subexpression of an application, or in typ(A).
This is in fact an invariant that will be preserved in solving the constraints.

∧-Unification
To solve a set of constraints, we will reduce them, by means of a generalized unification mechanism, which involves the notion of type substitution, that we introduce now. Since the constraints to reduce only involve skeletal types, we shall only consider applying substitutions to this restricted kind of types.
A prime type substitution is a map S from a finite set dom(S) of type variables
to prime types. If dom(S) = {t1,... , tn} and S(ti) = τi, we also denote S by
{t1 '→τ1,... , tn '→τn}. We let S(t) = t for t /∈ dom(S). The result of applying the substitution S to a (skeletal) type ξ is denoted Sξ (the definition, by induc- tion on the structure of τ , is the usual one). As a matter of fact, we shall only use Sξ in the case where S is a renaming, assigning (distinct) type variables to type variables. However, we shall also use the application of a substitution S to positive occurrences of type variables in a skeletal type. The resulting type is denoted S+ξ. Since there is exactly one positive occurrence of a type variable in ξ, the definition of S+ξ should be obvious: if ξ = (φ1 → ··· (φn → t) ··· ) then S+ξ is(φ1 → ··· (φn → S(t)) ··· ). Notice that this is a skeletal type if
S(t) is skeletal. These positive applications of type substitutions are extended,
according to the polarities we suggested above (negative on the left, positive on the right) to type equations, as follows:
S+(ξ → t ⊥ ζ) = S+ξ → t ⊥ S+ζ


Finally, we shall also consider substitutions that assign types (not necessarily prime) to type variables. Obviously, these should only be applied on the left of the arrow, that is, since we are only considering applications to skeletal types, to negative occurrences of type variables. Then, given such a mapping
D from a finite set dom(D) of type variables to types, extended with D(t) = t for t /∈ dom(D), we define D−ξ, the result of applying D to the (skeletal) type ξ, and D+φ, the type obtained by applying D to φ, as follows:

D−t = t	D+ω = ω
D−(φ → ξ) = (D+φ → D−ξ)	D+t = D(t)
D+(φ ∧ ψ) = (D+φ ∧ D+ψ)

As a matter of fact, we shall only use this in the case where D is a duplication, assigning a conjunction of distinct type variables to type variables. Notice that in this case D−ξ is a skeletal type. Again, we extend this to equations, but only when the root of the equation is not affected by D. That is, if t /∈ dom(D), we let:
D−(ξ → t ⊥ ζ) = D−ξ → t ⊥ D−ζ
Besides type substitutions, we shall also need, in order to solve the constraints, to apply some transformations on the territory of the equations. These are determined by mappings U from a finite set of type variables to finite sets of
type variables, which we denote U = {t1 '→U1,... , tn '→Un}. Assuming that, by convention, U(t) = {t} if t /∈ dom(U), these are applied to sets of type
variables as follows:
U(T ) =  U(t)
t∈T
Finally, identifying a pair of functions with a function returning pairs, we shall use transformations of the form
{t1 '→(τ1; U1),... , tn '→(τn; Un)}
which acts as the prime type substitution {t1 '→τ1,... , tn '→τn} on types and equations, and as {t1 '→U1,... , tn '→Un} on territories( 4 ), and similarly for transformations {t1 '→(π1; U1),... , tn '→(πn; Un)}. Type substitutions and term substitutions are related as follows. If tyvar(A) ∩ tyvar(B) = ∅, we denote by
{xt '→B}A the capture avoiding substitution of xt by B in A. Then we have:

4 As far as territories are concerned, the positive or negative application of such transfor- mations is simply U(T ), as defined above.

Lemma 4.1 (i) typ({xt '→B}A) = {t '→(typ(B); tyvar(B))}+typ(A)
(ii) if x occurs in A then E{xt '→B}A = EB ∪ {t '→(typ(B); tyvar(B))} EA.
Proof. By induction on A.	 
Now we define the notion of reduction E D E' on sets of constraints. This closely mimicks, as we shall see, the κ-reduction on expressions. A constraint corresponds to a redex ([λxA,.. .]B)t if it has the form
(ξ → t) ⊥ (φ → ζ); tyvar(B)
where ξ is the type assigned to the argument B, t is the type of the application node, φ = t1,... , tm is the sequence of types of the abstracted variable x in the function A, and ζ is the type of the function body A. As usual, to reduce
such an equation, we have to unify t with ζ (reflecting the fact that A, where the substitution of B for x is performed, takes the place of the application node) and ξ with φ, but the latter cannot be solved in the usual way (that
is, identifying the ti’s). By analogy with β-reduction, solving ξ ⊥ t1,... , tm
should correspond to substituting the argument B to the m occurrences of the variable x in A. In order to obtain a well-formed annotated term, we have to make m distinct copies of B, annotated with fresh type variables (which
are copies of the type variables in the territory tyvar(B) of the equation).
However, we cannot simply replace ξ ⊥ t1,... , tm by ξ1 ⊥ t1,... , ξm ⊥ tm where ξ1,... , ξm are copies of ξ, because the type variables occurring in ξ may also occur elsewhere in the set of constraints.
Example 2.1 (continued)  The reduction
F(λu.∆(uu)) −→ F(λu.(uu)(uu))
κ

should correspond to an “annotated reduction”


t0	t1

t2 t3

t4  t5 t6

t7 t8

t0	t1

t1 t1

t2  t2

t2 t3 t8

(λxλyy
λu(λz(z
z ) (u u
) ) )
−→ (λxλyy
κ
λu((u 4 u 5 ) 6 (u 4 u 5 ) 6 ))

and to a decomposition of the equation t6 → t7 ⊥ t1, t2 → t3, with territory
{t4, t5, t6}, since it is the redex of type t7 which is reduced. Therefore we should duplicate not only t6, but also t4 and t5, which appear in the dupli- cated argument (ut4 ut5 )t6 . These type variables also occur in other equations, namely (t4, t5 → t7) → t8 ⊥ ω → (t0 → t0) and t5 → t6 ⊥ t4. We see from the (annotated) κ-reduction that the latter should be simply duplicated, while in the former, we should replace the sequence t4, t5, corresponding to

the abstraction λu, by t1, t2, t1, t2
(modulo the associativity and commuta-

4  4  5  5
tivity axioms AC), in order to obtain the set of constraints associated with



t0	t1
t1 t1
t2  t2
t2 t3 t8

(λxλyy
λu((u 4 u 5 ) 6 (u 4 u 5 ) 6 )
), that is


E1 = { (t1, t1, t2, t2 → t3) → t8 ⊥ ω → (t0 → t0); {t3, t1, t2, t1, t2, t1, t2},

4  5  4  5
4  4  5
5  6  6

t2 → t3 ⊥ t1 ; {t2, t2, t2)},
6	6	4  5  6
t1 → t1 ⊥ t1 ; {t1},
5	6	4	5
t2 → t2 ⊥ t2 ; {t2}} 
5	6	4	5
This is formalized in the following rule, defining the ∧-unification process, which consists in a relation E D E' of reduction between sets of constraints. In the following definition, we explicitly record the transformation Θ used in the reduction, which is then denoted E D E' [Θ]. To state the definition, it is also convenient to introduce the following notations:

E ↓ T = { (ξ → t ⊥ ζ; U ) | (ξ → t ⊥ ζ; U ) ∈E & t ∈ T } E ↑ T = E − (E ↓ T )
One can see that, when T is the territory of some equation ξ → t ⊥ ζ in E, corresponding to an application node (AB)t, then E ↓ T is the set of constraints associated with the argument B, that is E ↓ tyvar(B) = EB.
Definition 4.2 (∧-Unification) Let E0 = {(ξ → t ⊥ φ → ζ; T )}∪ E be a set of constraints. Then E0 D E1 [Θ] where
if φ = ω then Θ = {t '→(ζ; ∅)}+ and E1 = Θ(E);
if φ = t1,... , tm with m > 0 then Θ = S+ ◦ {t '→(ζ; ∅)}+ ◦ D− and

E1 = S+{t '→(ζ; ∅)}+ D−(E ↑ T ) ∪ 
1≤j≤m
Rj(E ↓ T ) 

with, if T = {s1,... , sn},
D = { si '→s1,... , sm; {s1,... , sm}) | 1 ≤ i ≤ n }
i	i	i	i
Rj = {s1 '→(sj ; {sj }),... , sn '→(sj ; {sj })}	(1 ≤ j ≤ m)
1	1	n	n
S = {t1 '→(R1ξ; R1T ),... , tm '→(Rmξ; RmT )}
where s1,... , s1 ,... , sm,... , sm are fresh (not occurring in E0), distinct type
1	n	1	n
variables.

Example 2.1 (concluded)  Regarding our running example expression F(λu.
∆(uu)), or more precisely its annotated version

(λxλyyt0 λu(λz(zt1 zt2 )t3 (ut4 ut5 )t6 )t7 )t8 ,

we see that if we select from the set E0 of associated constraints the equation t6 → t7 ⊥ t1, t2 → t3 to reduce, with territory {t4, t5, t6}, we obtain, using the notations of the definition (with T = {t4, t5, t6} and E0 = {t6 → t7 ⊥ t1, t2 → t3; T }∪ E), the following substitutions to apply:

D = { ti '→t1, t2; {t1, t2}) | 4 ≤ i ≤ 6 }
i	i	i	i
R1 = {t4 '→(t1; {t1}), t5 '→(t1; {t1}), t6 '→(t1, {t1})}
4	4	5	5	6	6
R2 = {t4 '→(t2; {t2}), t5 '→(t2; {t2}), t6 '→(t2; {t2})}
4	4	5	5	6	6
S  = {t1 '→(t1, {t1, t1, t1}), t2 '→(t2, {t2, t2, t2})}
6	4  5  6	6	4  5  6

Since

E ↓ T = { t5 → t6 ⊥ t4 ; {t5}} 
E ↑ T = { (t4, t5 → t7) → t8 ⊥ ω → (t0 → t0); {t1,... , t7}, t2 → t3 ⊥ t1 ; {t2}} 
where E ↓ T is the set of constraints associated with the argument (ut4 ut5 )t6 of the redex, typed t7, that we are considering for reduction, we get E0 D E1 where

E1 = { (t1, t1, t2, t2 → t3) → t8 ⊥ ω → (t0 → t0); {t3, t1, t2, t1, t2, t1, t2},

4  5  4  5
4  4  5
5  6  6

t2 → t3 ⊥ t1 ; {t2, t2, t2)},
6	6	4  5  6
t1 → t1 ⊥ t1 ; {t1},
5	6	4	5
t2 → t2 ⊥ t2 ; {t2}} 
5	6	4	5


t0	t1
t1 t1
t2  t2
t2 t3 t8

which is the set of constraints associated with (λxλyy λu((u 4 u 5 ) 6 (u 4 u 5 ) 6 )),
as described above. In E1 there is only one reducible equation, with root t8.


Decomposing this equation, we apply the case (i) of the definition, and we get

E2 = { t2 → t3 ⊥ t1 ; {t2, t2, t2)},
6	6	4  5  6
t1 → t1 ⊥ t1 ; {t1},
5	6	4	5
t2 → t2 ⊥ t2 ; {t2}} 
5	6	4	5


t0	t1
t1 t1
t2  t2
t2 t3

which is the set of constraints associated with [λyy , λu((u 4 u 5 ) 6 (u 4 u 5 ) 6 )].
Notice that in the second step of solving the typing constraints, from E1 to E2, we had to apply the substitution t8 '→(t0 → t0). Since t8 does not occur in E1, apart obviously in the reduced equation, this substitution had no effect. However, one should notice that it transforms the type t8 of the annotated version of F(λu.∆(uu)) into (t0 → t0), which is the expected type of this
expression, and of its normal form [λyy, λu.(uu)(uu)].

Typability and Typing
Now we show that ∧-unification can be used to characterize typability, by showing that it exactly corresponds to reduction in the extended λ-calculus. First, we show the correspondence between the normal forms.
Lemma 5.1 (Normal Forms) An expression M of the extended λ-calculus is a κ-normal form if and only if EA is irreducible, for any A such that erase(A) = M.
(The proof is obvious.) The next lemma states the crucial property of ∧- unification. For its proof, we need the the UAC axioms, as one can see for instance when applying our type inference process to the λ-expression (λy(x(yx)) x).
Lemma 5.2 (Operational Correspondence) (i) If M −→ N and erase(A) = 
κ
M then there exists B such that erase(B) = N and EA D EB.
(ii) If EA D E then there exists B such that E = EB and erase(A) −→ erase(B).
κ

Proof. (Sketch)
We prove a more precise statement, namely that if M −→ N and erase(A) = 
κ
M then there exist B and Θ such that erase(B) = N , EA D EB [Θ], typ(B) ≡UAC
Θ(typ(A)), ΓB ≡UAC Θ(ΓA) and tyvar(B) = Θ(tyvar(A)). We proceed by in- duction on M −→ N .
κ



If M −→
κ
N is an axiom, then M = ([λxM0, N1,... , Nk]M1) and A =

([λxA0, B1,... , Bk]A1)t, and EA contains the equation (ξ → t) ⊥ (φ → ζ) where ξ = typ(A1), φ = ΓA0 (x) and ζ = typ(A0). Let T = {s1,... , sn} = tyvar(A1). There are two cases.
If x /∈ fv(M0), then N = [M0, N1,... , Nk, M1]. Since x /∈ fv(A0), we have
φ = ω. Then, by the definition of ∧-unification, we have
EA = {(ξ → t ⊥ ω → ζ; T )}∪ E D {t '→(ζ; ∅)}+E	[{t '→(ζ; ∅)}+]

Since E = EA0 ∪EB1 ∪···∪EBk ∪EA1 and t does not occur in A0, B1,... , Bk, A1, it is clear that we may let B = [A0, B1,... , Bk, A1].
If x ∈ fv(M0), then N = [{x '→M1}M0, N1,... , Nk]. Let φ = t1,... , tm. Then we have EA D E [Θ], where, using the notations of the Definition 4.2, Θ = S+ ◦ {t '→(ζ; ∅)}+ ◦ D− and

E = S+ ◦ {t '→(ζ; ∅)}+ D−(E[A ,B ,...,B ]) ∪    Rj(EA ) 

0  1	k
1
1≤j≤m

We let B = [{ xtj '→RjA1 | 1 ≤ j ≤ m }A0, B1,... , Bk], and we conclude using the Lemma 4.1.
If M = (M0M1) and N = (N0M1) with M0 −→ N0 then A = (A0A1)t with
κ
erase(Ai) = Mi and
EA = {(ξ → t ⊥ ζ; tyvar(A1))}∪ EA0 ∪ EA1
where ξ = typ(A1) and ζ = typ(A0). By induction hypothesis, there is B0 and Θ such that, in particular, erase(B0) = N0 and EA0 D EB0 [Θ]. We let B = (B0A1)t, and we use the induction hypotheses to conclude.
The other cases are similar.
By induction on A, omitted (see [26]).	 
Theorem 5.3 An expression M of the extended λ-calculus is typable if and only if there is no inﬁnite sequence of reductions from EA, for any A such that erase(A) = M.
Proof. By the Theorem 2.2, if M is typable, then M is strongly normalizing, and therefore, by the previous Lemma, there is no infinite sequence of reduc- tions from EA if erase(A) = M . Conversely, if, for A such that erase(A) = M ,


there is no infinite sequence of reductions from EA, then M is strongly nor- malizing, and we conclude using Theorem 2.2 again.	 
This result provides an alternative solution to a problem raised in [13], of finding a unification-like characterization of strong normalization of λ-terms, without using expansion variables. In the PhD Thesis of the second author [26], it is shown that if we do not distinguish the two cases (i) and (ii) in the Definition 4.2, allowing m to be 0 in the second case, then the reduction of the set of constraints associated with [an annotated version of] an expression M converges if and only if this expression M has a normal form. This corresponds to a characterization of (weakly) normalizing terms in system DΩ, see [10,16]. A consequence of the Lemma 5.2 is that, if EA D∗ E where E is irreducible,

then there exists B such that E = EB
and erase(A) −→∗
κ
erase(B). By the Lemma

5.1, we know that erase(B) is a normal form. Now we show how to built the
canonical typing of erase(B) using EB. To this end, we define a transformation D on pairs (E , Γ ▶ τ ), called simpliﬁcation (of typing constraints) and given as follows:
({σ ⊥ t; T }∪ E , Γ ▶ τ ) D {t '→σ}−(E , Γ ▶ τ )
where {t '→σ}− is only applied to types and equations, not to territories (by the Remark 3.1, this is well defined). Our final result, combined with Theorem reftheorema, establishes that ∧-unification and simplification allow us to com- pute a canonical typing for any strongly normalizing expression:
Theorem 5.4 For any normal form P and annotated expression A such that
∗
erase(A) = P there exists Γ and τ such that (EA, ΓA ▶ typ(A)) D (∅, Γ ▶ τ )
and Γ ▶ τ is the canonical typing of P.
Proof (Sketch) By induction on A. Let us just examine the case where A = (A0A1)t. Notice that erase(A0) must be an H, with a head variable x. We have
EA = {(ξ → t ⊥ ζ; T )}∪ EA0 ∪ EA1
where ξ = typ(A1) and ζ = typ(A0). Moreover ΓA = ΓA0 ∧ ΓA1 . By induction hypothesis, we have


(EAi, ΓAi ▶ typ(Ai))
∗
D (∅, Γi ▶ τi)

where Γi ▶ τi is the canonical typing of erase(Ai), for i = 0, 1, and therefore Γ0 = {x : σ1 → ··· σn → t'}∧ Γ'
with τ0 = t'. Since τi is obtained from typ(Ai) by a sequence of non trivial type substitutions, we have ζ = t', and the simplification of EA1 transforms ξ


into τ1. Then we have

E	∗	⊥ '	'	−

A D ({(τ1 → t	t ); T }, ΓA ▶ t) D {t '→(τ1 → t)}
(∅, ΓA ▶ t)

and it is easy to see that {t' '→(τ1 → t)}−(ΓA ▶ t) is the canonical typing of
P = erase(A).
The Lemma 5.2 and Theorem 5.4 are only existential assertions, and therefore they do not completely specify a semi-algorithm for type inference. Indeed, the algorithm implemented by the second author, which is available from the url mentionned in [25], is more clever than that: it deals with pairs (E , Π), where Π is a “tentative proof of typing”, that is a proof in the type system where the typing rule for application is
Γ ▶ M : τ	∀i.∆i ▶ N : τi
m > 0
Γ ∧ ∆1 ∧ ··· ∧ ∆m ▶ (MN ) : σ
Then the transformations performed by the algorihm do not only operate on the set of constraints (by ∧-unification), but also on the proof of typing part, in such a way that, if we start with (EA, ΠA) (for a suitably defined ΠA) where
erase(A) is strongly normalizing, then the algorithm ends up with (∅, Π) where
Π is a valid proof of typing for the initial expression erase(A). Moreover, the
algorithm checks at every step the rank of the generated types, so that if a bound is provided for the rank, the type inference algorithm terminate (we refer to [26] for the details). The algorithm could also more simply deal with
pairs (E , Γ ▶ τ ), starting from (EA, ΓA ▶ typ(A)).
It is not easy to compare our algorithm with the one of Kfoury and Wells for their system I [14], because the formalisms which are used are quite different. The main differences are that we replace the notion of an expansion variable with the notion of a territory of an equation, and that we perform in an atomic way several operations in one ∧-unification step, while these “micro-steps” are allowed to commute in Kfoury and Wells’ algorithm, thus making a precise comparison very difficult. Nevertheless, we strongly believe (see [26] for a thorough discussion) that one ∧-unification step in our algorithm, where the duplication factor is m, corresponds to m +2 (if m > 0, otherwise 3) steps in Kfoury and Wells’ algorithm.

Conclusion
We have presented a new semi-algorithm for inferring principal typings for strongly normalizing λ-expressions in the intersection type discipline. The


correctness of our unification mechanism is not too difficult to establish. Al- though we showed that in the pure λ-calculus our algorithm coincides with (strong) normalization, it still deals with typing constraints rather than with λ-expressions, and is therefore open to generalizations to enriched calculi. In
[26] some preliminary results in this direction are obtained, regarding the typ- ing of mutable variables (that is, references `a la ML) and of recursion.

References
R. Amadio, P.-L. Curien, Domains and Lambda-Calculi, Cambridge Tracts in Computer Science Vol. 46, Cambridge University Press (1998).
S. van Bakel, Intersection Type Disciplines in Lambda Calculus and Applicative Term Rewriting Systems, PhD Thesis, Mathematisch Centrum, Amsterdam (1993).
S. van Bakel, Principal type schemes for the strict type assignment system, J. of Logic and Computation, Vol. 3 No. 6 (1993) 643-670.
S. van Bakel, Intersection type assignment systems, Theoretical Comput. Sci. Vol. 151 No. 2 (1995) 348-435.
G. Boudol, On strong normalization in the intersection type discipline, TLCA’03, Lecture Notes in Comput. Sci. 2701 (2003) 60-74.
S. Carlier, Polar type inference with intersection types and ω, Workshop on Intersection Types and Related Systems, Electronic Notes in Theoret. Comput. Sci. Vol. 70 (2002).
S. Carlier, J.B. Wells, Type inference with expansion variables and intersection types in system E and an exact correspondence with β-reduction, Tech. Rep. HW-MACS-TR-0012, Heriot Watt University (2004).
M. Coppo, M. Dezani-Ciancaglini, An extension of the basic functionality theory for the
λ-calculus, Notre Dame J. of Formal Logic 21 (1980) 685-693.

M. Coppo, M. Dezani-Ciancaglini,
B. Venneri,
Principal type schemes and lambda-

calculus semantics, In To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism (J.R. Hindley and J.P. Seldin, Eds.), Academic Press (1980) 535-560.
M. Coppo, M. Dezani-Ciancaglini, B. Venneri, Functional characters of solvable terms,
Zeit. Math. Logik Grund. 27 (1981) 45-58.
L. Damas, Type Assignment in Programming Languages, PhD Thesis, University of Edimburgh CST-33-85 (1985).
T. Jim, A polar type system, Workshop on Intersection Types and Related Systems (2000).
A.J. Kfoury, Beta-reduction as unification, in Logic, Algebra and Computer Science,
H. Rasiowa Memorial Conference, December 1996 (D. Niwinski, Ed.), Banach Center Publication Vol. 46 (1999) 137-158.
A.J. Kfoury, J.B. Wells, Principality and decidable type inference for finite-rank
intersection types, Theoretical Comput. Sci. Vol. 311 No. 1 (2004) 1-70.
J.W. Klop, Combinatory Reduction Systems, PhD Thesis, Utrecht University. Mathematical Centre Tracts Vol. 127, Mathematisch Centrum, Amsterdam (1980).
J.-L. Krivine, Lambda-Calcul: Types et Mod`eles, Masson, Paris (1990). English translation “Lambda-Calculus, Types and Models”, Ellis Horwood (1993).


R. Milner, A theory of type polymorphism in programming, J. of Computer and System Sciences Vol. 17 (1978) 348-375.
J.C. Mitchell, Concepts in Programming Languages, Cambridge University Press (2003).
P. Møller Neergaard, H.G. Mairson, Rank bounded intersection: types, potency, and idempotency, Draft (2003).
J.H. Morris, Lambda-calculus models of programming languages, PhD Thesis, MIT (1968).
G. Pottinger, A type assignment for the strongly normalizable λ-terms, In To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism (J.R. Hindley and J.P. Seldin, Eds.), Academic Press (1980) 561-577.
P. Sall´e, Une extension de la th´eorie des types en λ-calcul, ICALP, Lecture Notes in Comput. Sci. 62 (1978) 398-410.

S. Ronchi
Della Rocca,
Principal type scheme and unification for intersection type

discipline, Theoretical Comput. Sci. 59 (1988) 181-209.
S. Ronchi Della Rocca, B. Venneri, Principal type schemes for an extended type theory,
Theoretical Comput. Sci. 28 (1984) 151-169.
P. Zimmer, TypI, a type inference interpreter for the intersection type discipline,
http://www-sop.inria.fr/mimosa/Pascal.Zimmer/typi.html (2003).
P. Zimmer, R´ecursion G´en´eralis´ee et Inf´erence de Type avec Intersection, Th`ese, Universit´e de Nice-Sophia Antipolis. Available from the web page of the author (2004).
