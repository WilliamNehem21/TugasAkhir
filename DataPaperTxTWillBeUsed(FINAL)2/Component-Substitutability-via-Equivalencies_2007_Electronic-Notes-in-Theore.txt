Electronic Notes in Theoretical Computer Science 182 (2007) 39–55	
www.elsevier.com/locate/entcs

Component Substitutability via Equivalencies of Component-Interaction Automata


Ivana Cˇern´a, Pavl´ına Vaˇrekova´
and Barbora Zimmerova1 ,2

Faculty of Informatics, Masaryk University Brno, Czech Republic

Abstract
We provide a new look at formal aspects of component substitutability (replacement of a component with a new one) and independent implementability (reuse of a component in any system where its implemen- tation satisfies the specification given by the environment), in view of an underlying formalism called Component-interaction automata. Our aim is to offer a formal characterization of preconditions that lead to reconfiguration correctness (proper component substitution and safe independent implementation). Such preconditions then guarantee that the updated system remains equivalent to the former one and hence there is no need to verify it again.
The contribution of the paper is twofold. First, we formally define three relations that allows us to com- pare behaviours of two components with respect to reconfiguration correctness. Namely, the equivalence relation, specification–implementation relation, and substitutability relation. Second, we formally charac- terize the problem of component substitutability for both equivalent and non-equivalent components, and the problem of independent implementability. The characterizations are captured in several propositions which are proved in the text.
Keywords: component-based systems, reconfiguration correctness, component substitutability, independent implementability


Introduction
One of the essential benefits of component-based systems is their flexibility with re- spect to future changes. As the systems are composed of autonomous components, they may evolve simply by update of particular components. However, the com- ponents are often developed by third parties which brings new verification issues regarding correctness of interaction among such components. One of the issues, in view of component updates, is called reconfiguration correctness. The recon- figuration correctness comprises two specific problems, component substitutability (replacement of a component with a new one) and independent implementability

1 Email: {cerna,xvareko1,zimmerova}@fi.muni.cz
2 The authors have been supported by grants No. 1ET400300504 and GACR 201/06/1338

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.09.030

(safe reuse of a component in any system where its implementation satisfies the spec- ification given by its environment).
Our solution to these problems, as alternative to verification from scratch, is based on formal characterization of relationship between the new and the former component, which guarantees that the update will not break the existing functional- ity of an overall system. We regard the problem of independent implementability as the substitutability of component implementation for its specification which allows us to propose a uniform solution for both problems.
We rely on an underlying formalism called Component-interaction automata [15], which is briefly described in Sections 2 and 4. Section 3 introduces the notion of equivalence between two component-interaction automata, which is defined with re- spect to a given set of observable labels. This allows us to explicitly state the level of accuracy at which automata are compared, and hence study several kinds of equiva- lencies between automata. The characterization of reconfiguration correctness with respect to substitution of two equivalent components is proposed in Section 5. Sec- tions 3 and 5 together provide a formal foundation stone for subsequent relations and results that are extensions of these. Sections 6 and 7 introduce the specification– implementation and the substitutability relations. In these sections we also char- acterize the problems of independent implementability and substitutability of non- equivalent components, and propose solutions based on the results of Section 5. Related work is discussed in Section 8 and we conclude in Section 9.

Component-interaction automata
The Component-interaction automata language [5,15] was designed for modelling of component interactions in hierarchical component-based software systems. It captures each component as a labelled transition system with structured labels (to remember components which communicated on an action) and a hierarchy of component names (which represents the architectural structure of the component). Such features allow the language to model component interactions in fine detail while the language is still generally usable for several variations of component- based systems (with different synchronization strategies for instance). The essential definitions are briefly reminded in this section.
A hierarchy of component names is a tuple H = (H1,... , Hn), n ∈ N, of one of the following forms, SH denotes the set of component names corresponding to
H. The first case is that H1,... , Hn are pairwise different natural numbers; then

SH =  n
{Hi}. The second case is that H1,... , Hn are hierarchies of component
n

names where SH1 ,... , SHn are pairwise disjoint; then SH =
i=1 SHi .

A component-interaction automaton (or a CI automaton for short) is a 5-tuple
C = (Q, Act, δ, I, H) where Q is a finite set of states, Act is a finite set of actions, Σ = ((SH ∪ {−}) × Act × (SH ∪ {−})) \ ({−} × Act × {−}) is a set of labels, δ ⊆ Q × Σ × Q is a finite set of labelled transitions, I ⊆ Q is a nonempty set of initial states, and H is a hierarchy of component names. The labels have semantics of input, output, or internal, based on their structure, as indicated in Notation 2.1.

Examples of two CI automata are in Figure 1.
A path of a CI automaton C = (Q, Act, δ, I, H) is an alternating sequence of states and labels given by δ that is either infinite, or is finite in case that it ends with a state from which there is no transition in δ. The set of all paths of a CI automaton C is denoted Path(C). The set of all finite prefixes of paths from Path(C) that end with a state is denoted F inP ath(C).
Notation 2.1 For a given CI automaton C = (Q, Act, δ, I, H) we denote
LC = {l | ∃ q0, l0,... , qk−1, lk−1, qk ∈ F inP ath(C): q0 ∈ I ∧ lk−1 = l}
the set of all labels reachable in C,
Linp,C = LC ∩ {(−, a, n2) | a ∈ Act, n2 ∈ N}
the set of all input labels reachable in C (a component n2 inputs an action a),
Lout,C = LC ∩ {(n1, a, −) | a ∈ Act, n1 ∈ N}
the set of all output labels reachable in C (a component n1 outputs an action a),
Lint,C = LC ∩ {(n1, a, n2) | a ∈ Act, n1, n2 ∈ N}
the set of all internal labels reachable in C (n1 and n2 synchronize on a),
Lext,C = Linp,C ∪ Lout,C = LC \ Lint,C
the set of all external (input and output) labels reachable in C.
... J,’¸q  ¸z,

(−,a,1) .
.....
(1,b,1)
J 

(2,a,−)	 

C1 :	 J,’¸p z,.¸,	J,’¸r z,


C2 :	 J,’¸p z,¸,	J,’¸q z,
(−,c,2)

Hierarchy: (1)	Hierarchy: (2)
Fig. 1. Example of CI automata


Equivalence of component-interaction automata
This section introduces the equivalence of two CI automata defined as an equivalence with respect to observable steps X. The observable step of an automaton consists of a single observable transition (with a label from X) preceded and followed by an arbitrary number (potentially zero) of silent transitions (with labels outside X). Using this concept we define the equivalence of two CI automata in a similar way to Milner’s weak bisimulation [13].
Definition 3.1 Let C' = (Q', Act', δ',I',H') and C'' = (Q'', Act'', δ'',I'',H'') be CI automata and X be a set of labels. A binary relation ∼ ⊆ Q' × Q'' is called an observation equivalence of C' and C'' with respect to X iff q' ∼ q'' implies:
Whenever (q', l, r') ∈ δ' then ∃ q''l0q1l1 ··· qnlnr'' ∈  F inP ath(C'') satisfying
r' ∼ r'' and
if l ∈/ X then {l0, l1,... , ln}∩ X = ∅,	( )
if l ∈ X then {l0, l1,... , ln}∩ X = {l} ∧ ∃! i ∈ {0, 1,... , n} : li = l
where ∃! i denotes that there is exactly one such index.

Whenever (q'', l, r'') ∈ δ'' then ∃ q'l0q1l1 ··· qnlnr' ∈  F inP ath(C') satisfying
r' ∼ r'' and ( ).
CI automata C', C'' are equivalent with respect to X, C' ≡X C'', iff there is an ob- servation equivalence ∼ of C' and C'' with respect to X such that:
For every q' ∈ I' there is q'' ∈ I'' such that q' ∼ q''.	(  )
For every q'' ∈ I'' there is q' ∈ I' such that q' ∼ q''.	(   )
The use of the parameter X in the definition of ≡X has a special significance. It allows us to explicitly state the level of accuracy at which the new and the former system are compared.
Remark 3.2 For CI automata C and C' some special cases of the set X are:
X = LC ∪ LC'
An analogy of strong bisimulation where all labels are observable.
X = Lext,C ∪ Lext,C'
An analogy of weak bisimulation where all internal labels are silent.
X = LC ∪ Lext,C'
Refinement of C by C' where C' must respect all transitions of C (input, output, internal), but may perform other new internal transitions.
X = (LC ∪ LC' ) \ {(n, a, n) | n ∈ N}
Only inner internal labels of primitive components are silent.
Note that in all these cases, the set X includes all external labels of the automata, X ⊇ Lext,C ∪ Lext,C' . This is natural as external labels may participate in communi- cation with other components which influence an overall behaviour of the system.
It can be easily proved that, for any fixed set of labels X, the relation ≡X is an equivalence (reflexive, symmetric, and transitive) on the set of all CI automata. Moreover, it has a property, stated by the following lemma, of which we take ad- vantage in following sections.
Lemma 3.3 Let C, C' be CI automata, X be a set of labels. Then
if	C ≡X C'	then	∀X' ⊆ X : C ≡X' C'
Proof. As C ≡X C', there exists an observation equivalence ∼ of C and C' with respect to X satisfying ( ) and (  ). It can be easily proved that the same ∼ is also an observation equivalence of C and C' with respect to any X' ⊆ X.	 
According to Definition 3.1, two CI automata may be equivalent only if their sets of reachable observable labels are identical. It among others means that they need to have the same names for functionally corresponding primitive components men- tioned in observable labels. However, more practical issue is to check whether two automata behave the same no matter what the names of their primitive components are.
Notation 3.4 Let SH be a set of component names and X be a set of labels. By

SH,X we denote the set of component names from SH that appear in any label from
X. Formally, SH,X = SH ∩ {n | ∃a, x : (n, a, x) ∈ X ∨ (x, a, n) ∈ X}.
Definition 3.5 Let C = (Q, Act, δ, I, H) be a CI automaton, let M ⊆ N, and r : M → N be a function, called renaming function. We say, that a CI automaton C' re- sults from C after renaming of all component names with r, iff C' = (Q, Act, δ',I,H') where δ' and H' results from δ, resp. H, by replacing every occurrence of any com- ponent name x ∈ M with r(x).
Definition 3.6 Let C and C' be CI automata, X be a set of labels. We say that a CI automaton C' is equivalent to C with respect to observable labels X up to 1:1 (or up to 1:N ) renaming, iff there is a bijection (resp. surjection) r : SH',X → SH,X such that the CI automaton C' , which results from C' after renaming of all component names with r, is equivalent to C with respect to observable labels X, C ≡X C' .
Thanks to the information about participating components, which CI automata encompass in the labels, the equivalence may be assessed according to the corre- spondence of primitive components. If the renaming function is a bijection, for each observable component ni in C there must be exactly one observable component nj
in C' performing an equivalent functionality. In case we do not want to make such a strict restriction, we may consider the case that for each observable component ni in C there may be a set of components in C' forming a notional component nj which performs an equivalent functionality. That is the second case when the renaming function is a surjection. Moreover, we could reason about another type of function that would join names of several components to a group to test whether we may replace them for another group of components with shifted responsibilities (some
services moved from one component to another one within the group) even if we know that one by one replacement would not succeed. In addition, the concept of equivalence up to renaming can be applied also to other relations of CI automata, in particular those introduced in Sections 6 and 7.
Composition with respect to architectural assembly
We have presented the definition of CI automata and introduced the notion of equivalence between them. Now, before we proceed to component update within a system, one more issue needs to be discussed. It concerns the role of compo- nent’s environment. As the component is interconnected with the rest of the sys- tem, the environment influence its behaviour coordinating the component. Hence the form of component interconnection with the rest of the system must be taken into consideration before the component substitution. This interconnection is in fact determined by the type of composition that was used to compose the system together.
Component-interaction automata offer a parameterizable composition operator which composes given automata in a way that it preserves only the transitions that are really feasible in a system. For example, let us consider a system consisting of three components C1, C2, and C3, where both C1 and C2 provide a service a and C3

requires a. Imagine that only C1 and C3 are connected by communicational bind- ing, C2 and C3 are not. Then the composition respects that only C1 and C3 may synchronize. The synchronization of C2 and C3 is syntactically possible, but not feasible in the system. One of the ways to provide such composition is to parame- terize the composition operator with a set of labels F which represents the bindings via which the components may communicate (in component assembly of the sys- tem). This is possible thanks to the structure of labels (in CI automata) which contain the names of components between which the actions are communicated.
Such composition operator is denoted ⊗F and its definition and several properties with respect to ≡X are presented in this section.
The composition of CI automata is defined as an operation that for a composable indexed set 3 of CI automata and an additional parameter F returns the composite automaton. A set of CI automata S = {(Qi, Acti, δi, Ii, Hi)}i∈I is composable if I ⊆ N is finite and (Hi)i∈I is a hierarchy of component names 4 . The composite CI automaton over S is defined with help of a complete transition space over S denoted ΔS. The complete transition space consists of transitions between product states for given automata, such that from each state, there are just the transitions of single component automata, and the transitions caused by synchronization of two component automata on a complementary label.
Definition 4.1 Let F be a set of labels, then ⊗F denotes a unary composition operator on composable sets of CI automata. If S = {(Qi, Acti, δi, Ii, Hi)}i∈I is a composable set of CI automata, then ⊗F S = (Πi∈IQi, ∪i∈I Acti, δ, Πi∈I Ii, (Hi)i∈I) where δ = {(q, x, q') | (q, x, q') ∈ ΔS ∧ x ∈ F}.
As the set F represents component assembly of the system, we require that it contains all internal labels of former automata (that are to be composed) since the assembly binds only external services of the components. It does not concern the former internal behaviour.
Definition 4.2 We say that the automaton ⊗F {Ci}i∈I is deﬁned iff {Ci}i∈I is

a composable set of CI automata and F ⊇ 
Lint,Ci .

Let {Ci}i∈I be a composable set of CI automata, then by ⊗{Ci}i∈I we denote the automaton ⊗( i∈I LCi ){Ci}i∈I. An example of ⊗{Ci}i∈{1,2} for automata C1, C2 depicted in Figure 1 is in Figure 2(a).
Example 4.3 Let C1 and C2 be the automata in Figure 1, let F = {(2, a, 1), (1, b, 1), (1, c, 2)} represent their feasible communication. As F ⊇ Lint,C1 ∪ Lint,C2 , the com- posite automaton C3 = ⊗F {Ci}i∈{1,2} is defined. It is depicted in Figure 2(b).
The following lemma shows that for the operator ⊗F , the order of component automata defined by their indexes is not important (from behavioural point of view) as the composite automata resulting from different orders are equivalent.

3 By an indexed set we mean a set with an implicit linear ordering of items, given by their numerical indexes in a least to greatest manner.
4 It among others means that SH , i ∈ I, are pairwise disjoint and hence any component name appears in
at most one automaton.



J¸ ,
,,¸¸¸¸¸_¸ ¸ (−,a,1)
(1,c,−)
 ,J¸˜q,p ` ,,\


(1,b,1)

 ,J¸˜r,p ` ,,\
J,˜¸ppJ` \, 

,J¸˜qp `,\ (1,b,1) ,J¸˜r p` ,\

¸¸¸¸¸¸¸¸¸¸¸¸¸	,,, ¸¸¸¸

(−,c,2)
(2,a,−)
¸¸¸¸¸
¸¸¸¸¸¸(¸2¸,a,−)
(−,c,2)
(2,a,−)
,,,
¸¸(¸1,c,2)

(−,c,2)
(2,a,1) ¸¸¸¸¸
¸¸¸¸¸¸(¸1,¸c,2)
(2,a,1) ,,
,
¸¸¸¸¸

J,˜¸` J\,
(−,a,1)
¸¸z,J¸˜ ` J,\
(1,b,1)¸¸¸¸¸¸ ,J¸˜ ` J,\
J,˜¸` \,
,zz
¸¸
,J¸˜ `,\

pq	 qq 
¸,
rq	pq	,J˜¸qq `,\ (1,b,1) rq 

(1,c,−)
Hierarchy: ((1),(2))	Hierarchy: ((1),(2))

(a) ⊗{Ci}i∈{1,2}	(b) ⊗F {Ci}i∈{1,2}
Fig. 2. Example of composite CI automata (states ij stand for (i, j))
Lemma 4.4 Let {Ci}i∈I be a set of CI automata, F a set of labels such that the au-

tomaton ⊗F {Ci}i∈I is deﬁned, and denote L = 

i∈I
LCi . Let f : I → I be a bijec-

tion and for all i ∈ I denote C' = Cf (i). Then ⊗F {C'}i∈I is deﬁned and
i	i
⊗F {Ci}i∈I ≡L ⊗F {C'}i∈I
Proof. For each i ∈ I, let Ci = (Qi, Acti, δi, Ii, Hi) and C' = (Q', Act' , δ',I',H').
i	i	i  i  i	i
F
As the automaton ⊗ {Ci}i∈I is defined, F ⊇	i∈I Lint,Ci and the sets SHi , i ∈ I,
are pairwise disjoint, ⊗F {C'}i∈I is also defined. To prove that ⊗F {Ci}i∈I	≡L
⊗F {C'}i∈I, it suffices to show that the relation ∼ ⊆ (Πi∈IQi) × (Πi∈IQ') defined
i	i
(qi)i∈I ∼ (q')i∈I	iff	∀i ∈ I : qi = q'
i	(f (i))
is an observation equivalence which satisfies (  ) and (   ) from Definition 3.1, which is straightforward.	 
Another property of ⊗F regarding the order of composition, which is important for proofs in the next section, is the following.
Lemma 4.5 Let {Ci}i∈I be a set of CI automata, F a set of labels such that the au-

tomaton ⊗F {Ci}i∈I is deﬁned, and denote L = 

i∈I
LCi . Then for any j ∈ I

the automaton ⊗F {Cj, Cj+1} where Cj+1 = ⊗{Ci}i∈I\{j} is deﬁned and
⊗F {Ci}i∈I ≡L ⊗F {Cj , Cj+1}
Proof. For each i ∈ I, let Ci = (Qi, Acti, δi, Ii, Hi). Analogically to the proof of Lemma 4.4, as ⊗F {Ci}i∈I is defined, the automata Cj+1 = ⊗{Ci}i∈I\{j} and
⊗F {Cj, Cj+1} are also defined. It is again straightforward to show that the relation
∼⊆ (Πi∈IQi) × (Qj × Πi∈I\{j}Qi) defined
(qi)i∈I ∼ (q' , (q')i∈I\{j})	iff	∀i ∈ I : qi = q'
j	i	i
is an observation equivalence which satisfies (  ) and (   ) from Definition 3.1. 
It is worth saying that thanks to Lemma 3.3, Lemmas 4.4 and 4.5 hold also for
any L ⊆	LC . Additionally, the existence of ≡X between CI automata C and C'
does not depend on labels from X \ (LC ∪ LC' ). Therefore Lemmas 4.4 and 4.5 hold

also for any L ⊇ 
LC . In general, we will write C ≡ C' whenever C ≡L
∪LC
' C',

because in such cases C ≡X C' for any set of labels X.
Substitutability of equivalent components
We would like to expect that whenever we have a system in which we replace one component with an equivalent one, the system will remain equivalent to the former one. This task is a bit more complicated, as it is parametrized by the intercon- nection of the component into the system (given by F in ⊗F ) and the accuracy of
the equivalence (given by X in ≡X ) 5 .
However, we can prove that if the two components are equivalent with respect to observable labels which encompass all their external labels (which is quite a nat- ural condition), it is true, that if in any system with any interconnection given by
some ⊗F we replace one of the components with its equivalent, the system remains equivalent to the previous one with respect to the same set of labels X 6 . In the fol- lowing lemma we prove this for the simple case when the environment constitutes of one component only. In Theorem 5.2 we extend it to an environment created of
several components, and in Corollary 5.3 we address also simultaneous replacement of several components.
Lemma 5.1 Let C1, C2 and C3 be CI automata and F a set of labels such that
the automata ⊗F {C1, C3} and ⊗F {C2, C3} are deﬁned. Let X be a set of labels such

that X ⊇ 

i∈{1,2}
Lext,Ci. Then

if	C1 ≡X C2	then	⊗F {C1, C3} ≡X ⊗F {C2, C3}
Proof. By δ13 we denote the transition set of automaton ⊗F {C1, C3} and by δ23
the transition set of ⊗F {C2, C3}.
Because C1 ≡X C2, there is an observation equivalence of C1 and C2 with respect to X which fulfills ( ) and (  ) from Definition 3.1. Let ≈ be an arbitrary, but fixed, relation satisfying these conditions.
It is necessary to show that there exists a relation, which is an observation equiv- alence of ⊗F {C1, C3} and ⊗F {C2, C3} with respect to X satisfying ( ) and (  ). We show that the relation ∼ defined:
(p1, p3) ∼ (q2, q3) ⇔ p1 ≈ q2 ∧ p3 = q3	(1) satisfies these conditions.
The relation ∼ fulfills (  ) and (   ).
Let (p1, p3) ∈ I1×I3, where I1, I3 are sets of initial states of C1, C3, then from the fact that ≈ satisfies ( ) it follows that there is a state q2 ∈ I2 such that p1 ≈ q2 and from the definition of ∼ it is seen that (p1, p3) ∼ (q2, p3). The relation ∼ satisfies the condition (  ) for similar reasons.

5 Note that X can be chosen in a way that the equivalence regards only the existing functionality of the system and allows the new component to perform additional actions that are not considered as observable (see Remark 3.2 (iii)).
6 Note that the main strength of this proposition is that it holds for an arbitrary environment of the compo- nent and an arbitrary coordination logic given by F (which may disable some behaviours of the component).

The relation ∼ is an observation equivalence of ⊗F {C1, C3} and ⊗F {C2, C3} with respect to X.
Let (p1, p3) ∈ Q1 × Q3, (q2, p3) ∈ Q2 × Q3 be states such that (p1, p3) ∼ (q2, p3). We prove that the condition (i) from Definition 3.1 is valid. The fact, that the condition
is satisfied can be proved analogically.
Suppose ((p1, p3), l, (p' , p' )) ∈ δ13, then there are three cases to analyse:
1	3
((p1, p3), l, (p' , p' )) is caused solely by C3, i.e. p1 = p' and (p3, l, p' ) ∈ δ3.
1	3	1	3
Then (q2, p3), l, (q2, p' ) ∈ F inP ath(⊗F {C2, C3}) is a path which fulfills ( ) and
(p1, p' ) ∼ (q2, p' ).
3	3
((p1, p3), l, (p' , p' )) is caused solely by C1, i.e. (p1, l, p' ) ∈ δ1 and p3 = p' .
1	3	1	3

Then because p1 ≈ q2 there is a path q2, l1, q' ,... , ln−1, q'
∈ F inP ath(C2)

2	n
which fulfills ( ) and p' ≈ q' . Since ((p1, p3), l, (p' , p' )) ∈ δ13 it holds that
1	n	1	3
l ∈ F. As {l1,... , ln−1} ∩ X ⊆ {l} and X ⊇ Lext,C2 it holds {l1,... , ln−1} ⊆ 
Lint,C2 ∪ {l}. And since Lint,C2 ⊆ F and l ∈ F also {l1,... , ln−1} ⊆ F and thus
(q2, p3), l1, (q' , p3), l2,... , ln−1, (q' , p3) ∈ F inP ath(⊗F {C2, C3}). From the def-
2	n
inition it follows that the path (q2, p3), l1, (q' , p3), l2,... , ln−1, (q' , p3) satisfies
2	n
( ) and (p' , p3) ∼ (q' , p3).
1	n
((p1, p3), l, (p' , p' )) is caused by synchronization of C1 and C3 on l = (n1, a, n2),
1	3
i.e. (p1, l', p' ) ∈ δ1  and  (p3, l'', p' ) ∈ δ3	where either l' = (n1, a, −) and
1	3
l'' = (−, a, n2), or l' = (−, a, n2) and l'' = (n1, a, −).
Since l' ∈ Lext,C2 it is true that l' ∈ X and because p1 ≈ q2 there is a path
q2, l1, q' ,... , lm−1, q' , l', q'	,... , ln−1, q' ∈ F inP ath(C2) such that p' ≈ q'
2	m	m+1	n	1	n
and ( ) is satisfied.	Similarly to the previous case it can be shown that

{l1,... , lm−1, lm+1,... , ln} ⊆ F, so both (q1, p3), l1, (q' , p3),... , lm−1, (q'
, p3)

2	m
and (q'	, p' ), lm+1,... , ln−1, (q' , p' ) are paths in F inP ath(⊗F {C2, C3}). Be-
m+1	3	n	3
cause ((p1, p3), l, (p' , p' )) ∈ δ13 it holds that l ∈ F. Moreover (q' , l', q'	) ∈
1	3	m	m+1
δ2 and (p3, l'', p' ) ∈ δ3, consequently ((q' , p3), l, (q'	, p' )) ∈ δ23 and thus
3	m	m+1	3
(q1, p3), l1, (q' , p3), l2,... , lm−1, (q' , p3), l, (q'	, p' ), lm+1,... , ln−1, (q' , p' )

2	m
∈ F inP ath(⊗F {C2, C3}).
m+1	3	n	3

From definition of ∼ it is seen that the path satisfy ( ) and (p' , p' ) ∼ (q' , p' ).
1	3	n	3
 
Note that Lemma 5.1 does not hold for an arbitrary X as it can be seen in Figure 3 which depicts the automata C1, C2, C3 and the sets X, F satisfying C1 ≡X C2 and not ⊗F {C1, C2} ≡X ⊗F {C1, C3}.


(1,a,−)
C1 :	 J,’¸q z,	C2 :	 J,’¸qJ ˜ z,¸` `,,,\
(−,a,2)
C3 :	 J,’¸qJ ˜ z,¸ `,,\

Hierarchy: (1)	Hierarchy: (1)	Hierarchy: (2)
F = X = {(1, a, 2)}
Fig. 3. Illustration that Lemma 5.1 does not hold for a general X

Lemma 5.1 can be also applied to replacement of many automata with just one automaton, one automaton with many, or a set of automata with another set. This is because a set of automata can be considered as a virtual composite automaton consisting of all (reachable) transitions of the complete transition space, as it was studied in Lemma 4.5. This idea can be applied to the following propositions too.
Now we can proceed to a more general case where the environment constitutes of several components (automata). This is the main result of this section which characterizes a precondition for safe substitutability of equivalent components in a general environment.
Theorem 5.2 Let I ⊂ N, j, k ∈ N \ I, {Ci}i∈I∪{j,k} be a set of CI automata, and F be a set of labels such that the automata ⊗F {Ci}i∈I∪{j} and ⊗F {Ci}i∈I∪{k} are deﬁned. Then for any set of labels X ⊇ Lext,Cj ∪ Lext,Ck
if	Cj ≡X Ck	then	⊗F {Ci}i∈I∪{j}  ≡X  ⊗F {Ci}i∈I∪{k}

Proof. When I = ∅, the result follows directly from Lemma 5.1 and the fact that
for any CI automaton C' and a set of labels F, it holds that ⊗F {C' } ≡ ⊗F {C' , C' }
1	1	1	2
where C' = ({q}, ∅, ∅, {q}, (n)) for a suitable n ∈ N. When I /= ∅, from Lemmas 3.3 and 4.5 it follows that
⊗F {Ci}i∈I∪{j} ≡X ⊗F {Cj , Cj+1 = ⊗{Ci}i∈I },
⊗F {Ci}i∈I∪{k} ≡X ⊗F {Ck , Ck+1 = ⊗{Ci}i∈I }.
Moreover, as Cj ≡X Ck, from Lemma 5.1 we get
⊗F {Cj, Cj+1 = ⊗{Ci}i∈I} ≡X ⊗F {Ck, Ck+1 = ⊗{Ci}i∈I}
and because ≡X is an equivalence, ⊗F {Ci}i∈I∪{j} ≡X ⊗F {Ci}i∈I∪{k}.	 

The following corollary addresses the simultaneous replacement of several com- ponents at the same time.

Corollary 5.3 Let {Ci}i∈I and {C'}i∈I be sets of CI automata, and F a set of
labels such that the automata ⊗F {Ci}i∈I and ⊗F {C'}i∈I are deﬁned. Then for any

set of labels X ⊇
i
i∈I (Lext,Ci ∪ Lext,C' )

if	∀i ∈ I : Ci ≡X C'	then	⊗F {Ci}i∈I ≡X ⊗F {C'}i∈I
Proof. We can assume, without loss of generality, that I = {1, 2,... , k} for some k ∈ N. And we use Ck+i to denote C' for any i ∈ I. Then from Theorem 5.2 it follows that ⊗F {C1, C2,... , Ck} ≡X ⊗F {C2,... , Ck, Ck+1} ≡X ⊗F {C3,... , Ck+1, Ck+2} ≡X
··· ≡X ⊗F {Ck+1,... , Ck+k} ≡X ⊗F {C' , C' ,... , C' }.	 
1	2	k

Moreover, Lemma 4.4 implies that if there exists a bijection f : I → I such that
∀i ∈ I : Ci ≡X C'	then also ⊗F {Ci}i∈I ≡X ⊗F {C'}i∈I where {Ci}i∈I , {C'}i∈I,
f (i)	i	i
F and X follow the assumptions from Corollary 5.3.

6	Independent implementability
Until now, we have studied the problem of replacement of one component with an equivalent one. We have shown that when the components are equivalent with respect to observable actions that encompass their external communication, the re- sulting system remains equivalent to the former one.
In this section, we focus on another interesting issue that can be regarded using a similar concept. It is the problem of independent development of components with certainty that they can be safely reused in any system where their implementation is compliant to the specification stated by their environment. The solution is based on the definition of a relationship between component specification and implementation that would assure this. Such specification-implementation relation moreover allows developers to design systems as compositions of specifications and then just search for appropriate implementations. Note that the independent implementability can be regarded as the substitutability of component implementation for its specification and hence to a certain extent, we may use the results of Section 5.
However, there are several distinctions between the specification-implementation relationship and ≡X, which need to be taken into consideration. First, the automata representing component specification and implementation do not need to be equiv- alent, as the implementation may provide new services beyond those stated by the specification. Second, as the equivalence requires equality in all aspects, there is no need to discuss a potential asymmetry of required and provided services, or of input and output actions. However we need to do this now for the specification– implementation relation. We informally consider the implementation to be compli- ant to the specification if it fulfills the following requirements:
Interface requirements
The implementation provides (resp. requires) all the services provided (resp. required) by the specification.
The implementation may provide (and require) services that are beyond the spec- ification.
Behavioural requirements
When serving the services provided (and required) by the specification, the im- plementation respects the specification in all observable steps.
Regarding (1.), the reason why the implementation must respect also required services of the specification follows from the fact that another component in the sys- tem may wait for the requisition to function correctly. The (2.) allows us to search for desired component implementation also among components that provide and require more services than the specification. The last requirement (3.) states that implementation does not require nor provide any additional observable service when serving the services provided and required by the specification.
At first glance, the symmetry between component provisions and requirements may seem surprising. However the clarification is straightforward. In fact, the asym- metry that is usually ascribed to provisions and requirements grounds deeper in

the asymmetry of inputs and outputs. As provided services usually respect the pat- tern input request then output response and required services the pattern output request then input response, the asymmetry is forwarded to provisions and require- ments too.
The systems with asymmetrical interpretation of input and output actions, as an output may be initiated anytime when an input needs to wait for a counterpart, are often called non-blocking systems. However, not all systems are non-blocking. Blocking systems, where both input and output are blocked in case a counterpart is not ready, are also of high interest. Majority of specification languages for com- ponent interactions focus on either the blocking strategy (Tracta [12], Wright [3]), or non-blocking strategy (Interface automata [9], SOFA Behavior protocols [14]). The Component-interaction automata [15] respect both as they are designed to model a variety of synchronization strategies.
We may now proceed to the definition of specification–implementation relation between two CI automata with respect to these two types of systems. In case of CI automata we may informally summarize the mentioned requirements of the relation as follows. A CI automaton C2 (implementation) is compliant to a CI automaton C1 (specification) if C2 behaves observably the same as C1 on every service provided and required by C1. Such restriction of C2 can be formally captured using composition that encloses the component represented by C2 to a higher level component C3 as depicted in Figure 4. In the figure, the arrows symbolize delegation of services outside the component. The inner services (e, f in this case) are not accessible from outside. It means that their actions are blocked from occurring in blocking systems, but may escape (in case of outputs) in non-blocking systems.

Fig. 4. Architectural view on restriction of C2 to given C1

Definition 6.1 Let C1 and C2 be CI automata, X be a set of labels. Then
C2 is compliant to C1 with respect to observable labels X in a blocking environ- ment, iff C1 ≡X ⊗R{C2} where R = Lext,C1 ∪ Lint,C2 ,
C2 is compliant to C1 with respect to observable labels X in a non-blocking envi- ronment, iff C1 ≡X ⊗R{C2} where R = Lext,C1 ∪ Lint,C2 ∪ Lout,C2 .
We now regard the independent implementability as the substitutability of restricted component implementation C3 = ⊗R{C2} for its specification C1. As the specification–implementation relation is defined using ≡X , we can use the re-

sults of Section 5. In particular, if X ⊇ (Lext,C1 ∪ Lext,C2 ) ∩ R = Lext,C1 ∪ Lext,C3 (where R is given by Definition 6.1), it follows from Lemma 5.1 that C1 ≡X C3 implies ⊗F {C1, C4}  ≡X  ⊗F {C3, C4} for any C4 and F such that the automata
⊗F {C1, C4} and ⊗F {C3, C4} are defined.
Moreover, provided that C1 is the exact specification of services used by an en- vironment on C2 (the rest will stay unused), then it holds that, if C2 is compliant to C1 with respect to X then the system with C2 in place of C1 will be equivalent to the former one with respect to the same X. This characterization of a pre- condition for independent implementability is formally captured in the following lemma for the basic case when the environment constitutes of one component (au- tomaton) only. The result can be extended for a general environment analogically to Section 5. Just before we proceed to the lemma, let us introduce an auxiliary definition needed for formalizing the concept of C1 being the exact speciﬁcation of services used by an environment on C2.
Definition 6.2 Participate denotes a function on sets of labels. If Y is a set of labels, then Participate(Y ) is a set consisting of the labels that are either from Y or represent internal communication in which the labels from Y participate. Formally, Participate(Y )= Y ∪ {(x1, a, x2) | x1, x2 ∈ N ∧ ((x1, a, −) ∈ Y  ∨ (−, a, x2) ∈ Y )}.
Lemma 6.3 Let C1, C2 and C3 be CI automata, R the set given by Def. 6.1. Let F be
a set of labels such that F∩Participate(LC2 \R)= ∅ and the automata ⊗F {C1, C3},

⊗F {C2, C3} are deﬁned. Let X be a set of labels such that X ⊇ ( 
Then
i∈{1,2}
Lext,Ci ) ∩ R.

if	C2 is compliant to C1 w.r.t. X 7 then	⊗F {C1, C3} ≡X  ⊗F {C2, C3}
Proof. As X ⊇ (	Lext,C ) ∩ R, it follows from Lemma 5.1 that ⊗F {C1, C3} ≡X
⊗F {⊗R{C2}, C3}. Since F ∩ Participate(LC2 \ R)= ∅ , i.e. F does not include la- bels of C2 that are not in R nor their connection into new internal labels, and
⊗F {⊗{C2}, C3} ≡ ⊗F {C2, C3}, it holds that ⊗F {⊗R{C2}, C3} ≡ ⊗F {C2, C3}. Thus
⊗F {C1, C3} ≡X ⊗F {C2, C3}.	 
Let us mention one more property of the specification–implementation relation with respect to the equivalence relation defined in Section 3. For any CI automata

C1, C2 and a set of labels X ⊇ 
i∈{1,2}
Lext,Ci
it holds that, if C1 ≡X C2 then C2 is

compliant to C1 w.r.t. X in both blocking and non-blocking environment.
7	Substitutability of non-equivalent components
The results of Section 5, Lemma 5.1 and Theorem 5.2 in particular, help us to determine when we can replace one component with another one with certainty that the new system will preserve the previous behaviour. The theorem states that whenever two components are equivalent, we can replace one with the other one and the new system will be equivalent to the previous one. It can also happen that

7 Generally for either blocking or non-blocking environment given by R.

the two components are not equivalent, but the new system (with a new component in a place of the former one) is equivalent to the former system. It can be caused by the fact that the component is bound into the system in a way that some of its behaviours are disabled and that can be exactly the behaviours that distinguish the components.
The substitutability relation is defined exactly for this purpose. It extends the notion of the specification–implementation relation with the assumption that the new component C2 does not have to simulate behaviours of the former compo- nent C1 that are not used by the environment (some interfaces/services of C1 may be unused by the environment). In the following definition, the services of C1 that are really used by the environment are represented by the set E.


Fig. 5. Architectural view on restriction of C1 and C2 for the same environment


Definition 7.1 Let C1 and C2 be CI automata, X, E be sets of labels. Then
C2 is substitutable for C1 with respect to observable labels X and labels (used by the environment) E in a blocking environment, iff ⊗R{C1} ≡X ⊗R{C2} where R = E ∪ Lint,C1 ∪ Lint,C2 ,
C2 is substitutable for C1 with respect to observable labels X and labels (used by the environment) E in a non-blocking environment, iff ⊗R{C1} ≡X ⊗R{C2} where R = E ∪ Lint,C1 ∪ Lint,C2 ∪ Lout,C1 ∪ Lout,C2 .
Similarly to the previous section, suppose that a component (a CI automaton C1) is connected with an environment (a CI automaton C3) by F in such a way that the environment really uses just the services of C1 that are specified by E.
Then if X ⊇ (Lext,C1 ∪ Lext,C2 ) ∩ R, and a CI automaton C2 is substitutable for C1,
i.e. ⊗R{C1} ≡X ⊗R{C2} for R given by the definition, then also the new system will be equivalent to the former one ⊗F {C1, C3} ≡X ⊗F {C2, C3}.
The following lemma states this formally giving a formal characterization of safe
substitutability of non-equivalent components. It is again the basic case considering one-item environment only, but extendable to the general case as in Section 5.
Lemma 7.2 Let C1, C2 and C3 be CI automata, E a set of labels, and R the set given by Def. 7.1. Let F be a set of labels such that F ∩ Participate((LC1 ∪ LC2 ) \ R)= ∅
and the automata ⊗F {C1, C3} and ⊗F {C2, C3} are deﬁned. Let X be a set of labels

such that X ⊇ ( 

i∈{1,2}
Lext,Ci ) ∩ R. Then

if	C2 is substitutable for C1 w.r.t. X, E 8 then	⊗F {C1, C3} ≡X  ⊗F {C2, C3}
Proof. As X ⊇ (	Lext,C ) ∩ R, from Lemma 5.1 we get ⊗F {⊗R{C1}, C3} ≡X
⊗F {⊗R{C2}, C3}. Hence it suffices to show that ⊗F {⊗R{C1}, C3} ≡ ⊗F {C1, C3} and
⊗F {⊗R{C2}, C3} ≡ ⊗F {C2, C3} whenever F satisfies the condition given above. This follows similarly to the proof of Lemma 6.3.	 
Note that again for any CI automata C1, C2, a set of labels E, and X ⊇

i∈{1,2}
Lext,Ci
it again holds that if C1 ≡X C2 then C2 is substitutable for C1 w.r.t.

X, E in both blocking and non-blocking environment. It is a direct application of
Theorem 5.2 for I = ∅.
8	Related work
The issue of relations between components in component-based systems has al- ready been addressed by several authors. The attention was focused mainly on the specification–implementation relation. The techniques for defining the relation are based either on strong/weak simulation or language inclusion. We have joint the first group as it allows finer grained comparison of two components because it can distinguish two behaviours that pass through different states even if their traces are the same. It comes in useful during formal verification which may also distinguish trace equivalent paths through different states.
One of the best known relations defined for component-based systems is the re- ﬁnement relation introduced within Interface automata [9,8] by de Alfaro and Henzinger. It focuses on the relationship between component specification and implementation to facilitate the independent implementability of components in component-based systems. The relation respects the difference of input and output actions where each input is considered as a provision and output as a requirement of a component. According to this, an implementation A refines a specification B if each input transition of B can be simulated by A, and each output transition of A can be simulated by B. The precise definition must take into account the hidden transitions of A and B too.
A different approach to relationship of component specification and implementa- tion was used in compliance relation for SOFA Behavior protocols [14,11] which was introduced by Plasil et al. It facilitates the decision whether the implementation given by a protocol A can replace the specification given by a protocol B without visible change for its environment. The relation is defined using two trace language inclusions. The first inclusion states that A has to render any sequence of provi- sions of B as it can be chosen by its environment. The second inclusion states that A leaded by the provisions of B may allow only the behaviour that was already possible for B. Additionally, A and B can be restricted to a partial alphabet if needed (to abstract from some of their actions). Besides the relation, the authors of SOFA also address the issue of partial bindings of component interfaces [2], which we considered in definition of our specification–implementation relation, and discuss

8 Generally for either blocking or non-blocking environment given by R.

the role of component environment that may coordinate an incorrect component in a way that the component does not perform any of its incorrect behaviours [1], which is a motivation of our substitutability relation.
Another approach that is worth mentioning was studied in [7,6] by Chaki et al. This work focuses on component substitutability directly from the verification point of view. The aim of the work is to provide an effective verification procedure that decides whether a component can be replaces with a different one without violating system correctness.

9	Conclusion and future work
We have provided a formal view on the issues of component-substitutability and independent implementability in component-based systems, which aims to facil- itate the task of checking reconfiguration correctness. Based on the formalism of Component-interaction automata, we have introduced three relations which support different levels of this task: (1) equivalence relation, (2) specification–implementation relation, and (3) substitutability relation.
The first relation, which provides an important basis extended by the other two relation, is defined as an observation equivalence with respect to X which represents the set of observable labels. The concept of the set X allows us to choose the level of accuracy at which we compare the components. Moreover, as components are modelled as CI automata, we may also choose the level of correspondence among primitive sub-components of compared components (in case they are composite). It can be done using the equivalence up to renaming.
The other two relations extend the concept of equivalence relation in allowing one (specification–implementation) or both (substitutability) components to pro- vide functionality that is not integrated into the system, and therefore should not be taken into account during component comparison. However, in non-blocking environment even the functionality that is not integrated could cause problems (output that was not awaited by the environment). Therefore we have also dis- cussed the consequence of blocking and non-blocking environment. In addition, both specification–implementation and substitutability relations are again parametrized by a set X, and both can be viewed by way of relation up to renaming.
As one of the most significant contributions of the paper, we have stated and proved several statements regarding the reconfiguration correctness for the equiv- alence relation, and discussed how these statements can be analogically applied to the other two relations. Roughly speaking, the main result shows that if we substi- tute a component with an equivalent one, replace a component specification with a compliant implementation, or change a component with a non-equivalent but sub- stitutable one, and the particular relation is assessed with respect to X that includes external labels of the automata, the system remains equivalent to the former one with respect to the same X, no matter what the environment is like.
Nowadays, we study the relationship of the equivalence relation and temporal logics used for formal verification. In future, we aim to implement the equivalence

checking into the verification tool DiVinE [4,10] which we have already used for verification of systems modelled as CI automata. We currently work on design of effective equivalence checking algorithms using various optimizations with respect to the input automata.

References
Adamek, J. and F. Plasil, Erroneous architecture is a relative concept, in: Proceedings of the Software Engineering and Applications conference (SEA’04) (2004), pp. 715–720.
Adamek, J. and F. Plasil, Partial bindings of components - any harm?, in: Proceedings of the Asia- Pacific Software Engineering Conference (APSEC’04) (2004), pp. 632–639.
Allen, R. J. and D. Garlan, The wright architectural specification language, Technical Report CMU- CS-96-TBD, Carnegie Mellon University, School of Computer Science, USA (1996).
Barnat, J., L. Brim, I. Cˇern´a, P. Moravec, P. Roˇckai and P. Sˇimecek, Divine – a tool for distributed verification, in: Proceedings of the Computer Aided Verification conference (CAV’06), Seattle, WA, USA, 2006, to appear.
Brim, L., I. Cˇern´a, P. Vaˇrekova´ and B. Zimmerova, Component-Interaction automata as a verification- oriented component-based system specification, in: Proceedings of the ESEC/FSE Workshop on Specification and Verification of Component-Based Systems (SAVCBS’05) (2005), pp. 31–38, published also in ACM SIGSOFT Software Engineering Notes, Volume 31, Issue 2 (March 2006).
Chaki, S., E. Clarke, N. Sharygina and N. Sinha, Dynamic component substitutability analysis, in:
Proceedings of the Formal Methods 2005 conference (FM’05) (2005).
Chaki, S., N. Sharygina and N. Sinha, Verification of evolving software, in: Proceedings of the ESEC/FSE Workshop on Specification and Verification of Component-Based Systems (SAVCBS’04), Newport Beach, California, USA, 2004, pp. 55–61.
de Alfaro, L. and T. A. Henzinger, Interface automata, in: Proceedings of the 9th Annual Symposium on Foundations of Software Engineering (FSE’01) (2001), pp. 109–120.
de Alfaro, L. and T. A. Henzinger, Interface-based design, in: Proceedings of the 2004 Marktoberdorf Summer School (2005).
Divine – Distributed Verification Environment, http://anna.fi.muni.cz/divine.
URL http://anna.fi.muni.cz/divine

Mach, M., F. Plasil and J. Kofron, Behavior protocols verification: Fighting state explosion, International Journal of Computer and Information Science 6 (2005), pp. 22–30.
Magee, J., J. Kramer and D. Giannakopoulou, Behaviour analysis of software architectures, in: Proceedings of the 1st Working IFIP Conference on Software Architecture (WICSA’99) (1999), pp. 35–50.
Milner, R., “Communication and Concurrency,” Prentice Hall, 1989.
Plasil, F. and S. Visnovsky, Behavior protocols for software components, IEEE Transactions on Software Engineering 28 (2002), pp. 1056–1076.
Vaˇrekova´, P. and B. Zimmerova, Component-Interaction automata for specification and verification of component interactions, in: Proceedings of the IFM 2005 Doctoral Symposium on Integrated Formal Methods (2005), pp. 71–75.
