

Electronic Notes in Theoretical Computer Science 225 (2009) 441–456
www.elsevier.com/locate/entcs

Reconstruction of Partial Orders and
List Representation as Random Structures
Thierry Vall´ee1 and Joseph Manning1,2
Centre for Efficiency-Oriented Languages (CEOL) Department of Computer Science
University College Cork Ireland
tv1 @ cs.ucc.ie / manning @ cs.ucc.ie

Abstract
MOQA is a new programming language with the unique property that the average running time of its programs can be (semi-)automatically deduced in a modular way by a static analysis of the program code. This is based on the fact that to each MOQA action there corresponds an operation on partial orders, which associates with each partial order a sequence of partial orders.
All programs in MOQA use a special data structure and an associated suite of operations. This data structure consists of a pair ( ( X, ± ), l ), where ( X, ± ) is a finite poset and l : X '→ L is a bijection from
X to a totally ordered set of labels L, satisfying the condition x ± y =⇒ l(x) ≤ l(y). Central to the analysis of MOQA programs is the set of all such pairs for a given ( X, ± ) and a given L; this set is called a random structure. The corresponding set of order-preserving bijections is called a random structuring.
This paper establishes a fundamental equivalence by showing that each poset is uniquely characterised by its associated random structuring, and derives algorithms to reconstruct a poset from its random structuring and to test if an arbitrary set of bijections forms a random structuring. It then develops some consequences of the previous results, and in particular a first characterisation of cardinalities of random structurings. These results open the way to the study of the representation of recursive sets of lists as random structures. This study is closely related to the implementation of list manipulation algorithms in MOQA.
Keywords: posets, random structures, labelings, average running time

Introduction
This paper investigates certain basic aspects of MOQA (MOodular Quantitative Analysis), a new programming language designed by Michel Schellekens at CEOL (Centre for Efficiency-Oriented Languages), and presented earlier in [15,16,14,17,19]. The most distinguishing feature of MOQA is the feasibility of determining the

1 Research supported by Science Foundation Ireland under Grant 02/IN.1/181
2 Research supported by Science Foundation Ireland under Grant 05/RFP/CMS0044

1571-0661/© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.091

average-case running time of its programs, merely by conducting an automated static analysis of the program code, and the ability to do so in a modular fashion. Just as LISP is based on lists and operations that manipulate them, MOQA programs are likewise based on a special data structure and an associated suite of operations. This data structure consists of a pair ( ( X, ± ), l ), where X is a finite set, ± is a partial order on X, and l : X '→ L is a bijection from X to a totally ordered set of labels L, satisfying the condition x ± y =⇒ l(x) ≤ l(y). Such a pair
is called a labeled partial ordered (lpo), and the bijection l a labeling.
A fundamental concept underlying the (semi-)automated average-case analysis of MOQA programs is the set of all lpo’s for a given poset ( X, ± ) and a given set of labels L; this set is called a random structure. We introduce here the notion of a random structuring as the set of all labelings from a given poset ( X, ± ) and set of labels L. Such a set is denoted by RL( X, ± ).
An lpo can be seen as the synthesis of two points of view. The first is that of programmers who, while writing list manipulation programs, deal with lists of values from a totally-ordered set (represented by the labelings) and are interested in the semantics (formalised or not) of their programs. The second is that of complexity analysts, who deal with random structures. Indeed, when the inputs of a program form a random structure, the special design of MOQA operations allows for control on the distribution of the program outputs. Moreover, it guarantees that the outputs themselves form a sequence of random structures. This strong property of MOQA operations allows an easy way to determine the average time of programs on random structures. In this context, it becomes interesting to explore the notion of random structuring and in particular to try and characterise to what extent it captures the notion of recursive sets of lists. A first step towards this characterisation is Theorem 5.5 below, where the possible cardinalities of finite random structurings are characterised.
In the sequel, we study the notion of random structuring for a class of poset called height-stratiﬁable posets (hs-posets), a class which includes all finite posets, and some which are infinite. These are introduced in Section 2. Then, in Section 3, we present
the Reconstruction Problem, that is, how to build a partial order starting from its labelings, and we show that it suffices to first establish an Equivalence Theorem
which establishes that the notion of poset and random structuring are equivalent, that is, that two partial orders are equal iff their sets of labelings are equal. In Section 4, we prove this theorem, using the fact that every well-founded locally
ﬁnite poset is uniquely determined by its set of labelings. This proof relies on the notion of height-canonical labeling and uses a technique of locally height-canonical labeling. A pair of reconstruction algorithms are also presented. Section 5 is then
devoted to additional results and in particular to a characterisation of cardinalities of random structurings.
We conclude this introduction with some remarks concerning an equivalent rep- resentation of labelings as linear extensions of posets. A linear extension of (X, ±) is a poset (X, ±') such that ± ⊆ ±' and ±' is total. Since the seminal works of
Szpilrajn [18] and Dushnik & Miller [8], linear extensions have received considerable

attention [1,2,3,4,6,7,12,13]. This attention focused in particular on the problems of generating all the linears extension of a poset, as well as the problem of finding its dimension (the minimal number of linear extensions needed to generate the poset). While these questions are certainly interesting, they are not our focus here. More- over, they appeared in a context which seems quite different than that of MOQA, where labelings are part of the lpo data structure. Thus, labelings seem the most natural and direct way to express and answer the particular questions raised by the development of the language. Finally, note that our Equivalence Theorem, which uses the labeling formulation, could itself be derived from an equivalent result of Szpilrajn in [18] using the linear extension theorem.
Preliminaries
Height-Stratiﬁable Posets
In this section, we recall some basic definitions concerning partial orders, and we then introduce the notion of height-stratiﬁable posets. We denote by N the set of natural numbers {0, 1, 2, 3,... }.
A partially ordered set (poset) is a pair ( X, ± ) where X is a set and ± is a partial order (p.o.) on X, that is, a reflexive, antisymmetric and transitive relation on X × X. To each partial order ±, we associate a strict partial order (s.p.o.) и defined by x и y ⇔ x ± y ∧ x /= y. Conversely, every antisymmetric and transitive relation и on a set X induces a p.o. ± (the reflexive closure of и). In this article, to define a p.o., we often content ourselves with defining the corresponding s.p.o. We use “±” to denote the p.o., and “и” to denote the corresponding s.p.o.
We now introduce the usual definitions of the ceiling, floor, ascending tree, and descending tree of a (set of) node(s).
Definition 2.1 Let ( X, ± ) be a poset, and Y ⊆ X. Then the following sets are, respectively, the ceiling, floor, ascending tree, and descending tree of Y in ( X, ± ):
[Y |± = {x ∈ X : ∃y ∈ Y, y и x ∧ ∀z ∈ X (y ± z ± x ⇒ z = x ∨ z = y)}
[Y ♩± = {x ∈ X : ∃y ∈ Y, x и y ∧ ∀z ∈ X (x ± z ± y ⇒ z = x ∨ z = y)}
⇑± Y = {x ∈ X : ∃y ∈ Y, y ± x}
⇓± Y = {x ∈ X : ∃y ∈ Y, x ± y}
Notation: We will often use the above notations without mentioning the order. For instance, [Y |± will simply be written as [Y |. Moreover, when Y = {x}, the sets defined above will simply be denoted by [x|, [x♩, ⇑ x, ⇓ x. Observe that (⇑x ∩ ⇓x) = {x}, for every x ∈ X, and that x ∈⇑z ⇔ z ∈⇓x.
Definition 2.2 A path from x0 to xn in the poset ( X, ± ) is a finite sequence (x0,..., xn) of elements of X such that, for each 0 ≤ i ≤ n−1, we have xi и xi+1. The length of the path x0,..., xn is n. In particular, (x0) is the only path from x0 to itself, and has length 0.
We now recall the usual notions of the maximal and minimal elements of a poset.

Definition 2.3 Let ( X, ± ) be a poset. Define, respectively, the set of maximal elements and the set of minimal elements of ( X, ± ) as:
M( X, ± ) = {x ∈ X : ∀y ∈ X, x ± y ⇒ y = x}
m( X, ± ) = {x ∈ X : ∀y ∈ X, y ± x ⇒ y = x}
Notation: For any set X, let ΔX = {(x, x) : x ∈ X}.
Remark 2.4 Note the following two special cases:
M ( X, ± ) = m( X, ± ) = X ⇔ ± = ΔX .
M ( X, ± ) = m( X, ± ) = ∅ ⇔ X = ∅, for X finite.
We now introduce the posets which we will focus on in the sequel.
Definition 2.5 The poset ( X, ± ) is:
locally ﬁnite if, for every x ∈ X, both [x| and [x♩ are finite.
ﬁnitely well-founded if X = ⇑ m( X, ± ), with m( X, ± ) finite.
height-stratiﬁable (hs-poset) if it is locally finite and finitely well-founded. Clearly, every finite poset is height-stratifiable. The following facts are also clear:
Fact 2.6 Let ( X, ± ) be a hs-poset. Then for every x ∈ X:
⇓± x ∩ m( X, ± ) is a non-empty ﬁnite set equal to {x} if x is minimal.
There are ﬁnitely many paths from any minimal element to x.
Fact 2.6 justifies the following definition.
Definition 2.7 Let ( X, ± ) be a hs-poset. Then:
For each x ∈ X, define the (ﬁnite) height of x w.r.t. ± as the maximal length of any path from a minimal element to x. In particular, the height of each minimal element of ( X, ± ) is 0. We will write height ±(x), or simply height (x), for the height of x ∈ X relative to the order ± .
For X /= ∅, the height of the poset ( X, ± ) is the maximal length of a path from a minimal element to an element of X; this value may be +∞.
The set heights ±(X), or simply heights(X), is the set of all heights of elements of X relative to ± .
In the sequel, we suppose that +∞ is greater than any positive integer, that is, we suppose that N ∪ {+∞} is totally ordered with greatest element +∞.
The next fact follows easily from the definition of the height of an element:
Fact 2.8 Let ( X, ± ) be a non-empty hs-poset, and x, y ∈ X. Then:
If x и y, then height (x) < height (y). In particular, if x ∈ [y♩ (≡ y ∈ [x|), then height (x) < height (y).
If height (y) = i + 1, then, for every path (x0,..., xi, y) from a minimal element
x0 to y and every 0 ≤ j ≤ i, we have height (xj) = j.

If height (y) = i + 1, then there exists an x ∈ X such that height (x) = i and
y ∈ [x|.
Lemma 2.9 Let ( X, ± ) be a non-empty hs-poset with height h. Then:
Hi = {x ∈ X : height (x) = i } is ﬁnite and non-empty, for each 0 ≤ i ≤ h.
The family (Hi)i∈heights(X) forms a partition of X.
h is ﬁnite iff X is ﬁnite.
Proof. To establish part (a), we use induction on i. For i = 0, since X is non- empty and ( X, ± ) is finitely well-founded, H0 = m( X, ± ) is finite and non-empty. For any 0 ≤ i < h, assume that Hi is finite and non-empty. Then there exists some y ∈ X with height (y) = k + 1 for some k ≥ i. Let (x0,..., xk, y) be a path of length k + 1 from a minimal element x0 to y. By Fact 2.8(b), we have height (xi+1) = i + 1, and so Hi+1 /= ∅. Now, by Fact 2.8(c), for each y ∈ Hi+1, there is some x ∈ Hi with y ∈ [x|, and so Hi+1 ⊆ [Hi|. Since Hi is finite and ( X, ± ) is locally finite, we now obtain that [Hi| is finite and so too is Hi+1.
Part (b) follows easily from part (a), while part (c) follows from parts (a) and (b). As an immediate consequence of part (a) of this lemma, we have the following:
Corollary 2.10 Every hs-poset is countable (either ﬁnite or denumerable).
Remark 2.11 There is the dual notion of depth-stratiﬁable posets, as locally finite posets ( X, ± ) such that X = ⇓M ( X, ± ) and M ( X, ± ) is finite. For such posets, the notion of (ﬁnite) depth can be defined, and for ds-posets, there exist dual results to those given for hs-posets. Nevertheless, to simplify our exposition, we limit ourselves to hs-posets, and we let the straightforward transpositions to ds-posets of the definitions and results given below to the interested reader.

Labelings and Random Structurings
In the following, a set of labels L is simply a linearly-ordered set (≡ totally-ordered), with its order denoted by ≤.
We recall that in [15,16], Schellekens defined the notion of random structure as the set of all lpo’s on a given poset.
Definition 2.12 Let X be a set, L a set of labels with the same cardinality as X, and ± a p.o. on X. Then:
An L-labeling on ( X, ± ) is an order-preserving bijection l from X to L, that is, a bijection such that x ± y ⇒ l(x) ≤ l(y), for all x, y ∈ X.
The L-Random Structuring on ( X, ± ) is the set of all L-labelings on ( X, ± ), and is denoted by RL( X, ± ).
A labeling (resp. random structuring ) is an L-labeling (resp. L-random structuring) for some set of labels L and poset ( X, ± ). We often use the calligraphic letter R to denote a random structuring.

We recall that (∅, ∅) is itself a partial order.
Remark 2.13 The only set of labels L for which RL(∅, ∅) is defined is L = ∅, and we have R∅(∅, ∅) = {∅}.
We now present two fundamental examples of random structurings.
Example 2.14 [Discrete Random Structuring]
The poset (X, ΔX ) is called the discrete order. Clearly, RL(X, ΔX ) consists of all bijections from X to L ; it is called the discrete random structuring.
Example 2.15 [Linear Random Structuring]
Each linear order x1 и ... и xn induces a unique L-labeling defined by l(xi) = ai, where a1,..., an are the elements of L, arranged in increasing order. Conversely, each bijection l : X '→ L induces a linear order defined by x и y ⇔ l(x) < l(y). If ± is a linear order, then RL( X, ± ) is called a linear random structuring.
Definition 2.16 Let ( X, ± ) be a poset. The bijection l : X '→ L is said to be
height-canonical if height ±(x) < height ±(y) implies l(x) < l(y), for all x, y ∈ X.
By Fact 2.8(a), we have immediately:
Fact 2.17 Let ( X, ± ) be a poset and let l : X '→L be a height-canonical bijection. Then l is a labeling on ( X, ± ).
Example 2.18 [Height-Canonical Labeling]
Clearly, ∅ is a height-canonical labeling on the poset (∅, ∅). We now give a simple way of constructing a height-canonical labeling when ( X, ± ) is a hs-poset with X /= ∅. By Corollary 2.10, X must be finite or denumerable. We show how to proceed when X is denumerable; the case when X is finite can be handled similarly.
Let L be any set of labels with the same cardinality as X. For each i ∈ N, let Hi = {x ∈ X : height (x) = i }, and ki = Card (Hi). By Lemma 2.9(a), each ki is finite and non-zero. Moreover, the partition (Hi)i∈N induces one on L. Indeed, letting a1, a2 ... be the labels of L arranged in increasing order, define a partition (Li)i∈N of L by Li = ani+1 ... ani+ki , where ni =  j<i kj, for each i ∈ N. So L1 contains the k1 smallest labels, L2 the k2 smallest remaining labels, and so forth. In particular, if a ∈ Li and b ∈ Lj with i < j, then we have a < b.
Now for every family of bijections Ψ = (ψi)i∈N respectively from Hi to Li, define
lΨ = ∪i∈Nψi. It is easy to verify that lΨ is indeed height-canonical on ( X, ± ).
Remark 2.19 Given a family Ψ = (ψi)i∈N defined as in the previous example, the union of every family Ψ' = (ψ')i∈N where, for all i ∈ N, the bijection ψ' is a per-
i	i
mutation of ψi, is clearly a labeling on ( X, ± ). Moreover, for any l ∈ RL( X, ± ), by taking ψi(x) = l(x) for every i ∈ N and x ∈ X, it is clear that every height- canonical labeling on a denumerable hs-poset can be defined as the union of such a family of bijections. A similar remark holds for finite hs-posets.
By Remark 2.13 and Example 2.18, we get the following easy fact:

Fact 2.20 For any hs-poset ( X, ± ) and label set L, with Card (X) = Card (L),
RL( X, ± ) /= ∅, and it contains at least one height-canonical labeling.
Reconstruction and Applicability of MOQA
The Reconstruction Problem
In this section, we are interested only in finite posets and finite random structurings, so in particular, every poset is a hs-poset.
The task of computing RL( X, ± ), starting from ± and L, is equivalent to the well-known problem of generating all linear extensions of ± , and there exist various algorithms to perform the latter computation. The Reconstruction Problem consists of the inverse task, that is, how to retrieve ± , starting from X, L, and RL( X, ± ). This justifies the following somewhat informal terminology.
Definition 3.1 An algorithm A is called a Reconstruction Algorithm if, for every poset ( X, ± ) and set of labels L with size Card (X): 
A(RL( X, ± ))) = ± .

But an immediate question arises:
What if different posets could have the same random structurings?
In other words, what if ±1 /= ± but RL( X, ±1 ) = RL( X, ±2 )? 
If this could happen, then the entire Reconstruction Problem becomes ill-defined and the very existence of a Reconstruction Algorithm becomes problematic!
To overcome this problem, we need to establish the following:
Theorem 3.2 (Equivalence Theorem) For any X, L, ±1 and ±2 :
±1 = ±2	⇐⇒	RL( X, ±1 ) = RL( X, ±2 )

The main consequences of the Equivalence Theorem are:
The Reconstruction Problem is indeed well-defined.
Posets and Random Structurings are interchangeable.
There are algorithms to map in both directions: starting from an order, to build its random structuring and, conversely, starting from a random structuring, to retrieve its associated order.
Tracing Computations in MOQA
We now recall the main reason for our interest in the Reconstruction Problem — it concerns the applicability of MOQA. Indeed, an interesting feature of MOQA, compared to other programming languages, is that to each program P of the lan- guage, there corresponds an operation P on partial orders which associates with each p.o. a sequence of p.o.’s. In particular, this correspondence means that, if the

set of inputs (of a given size) of a program P of MOQA is the random-structuring RL( X, ± ), then the outputs of P are exactly the labelings on the orders in the sequence P ( X, ± ). Thus, MOQA allows for the tracking of all the computations of a program on all its possible inputs (of a given size) in a very simple way. This tracking will then be used to facilitate the average time analysis of the program.
In this context, it becomes crucial to answer the question: “For a given program P , do the sets of all the inputs (of a given size) to P form a random structuring?”. The following theorem shows that the existence of a Reconstruction Algorithm enables us to answer this question.
Theorem 3.3 Let A be an algorithm deﬁned on all sets of bijections from X to L. Then, if A is a reconstruction algorithm, the following algorithm χA will decide, for any set F of bijections from X to L, whether or not there exists a partial order
± on X such that F = RL( X, ± ) : 
Run algorithm A on input F, and let ±F be its output.
If ±F is not a partial order, then return false.
Compute RL( X, ±F ) (using one of the existing algorithms).
If RL( X, ±F ) = F, then return true, else return false.
Proof. Clearly, for any set F of bijections, χA(F) returns either true or false.
If χA(F) = true, then step [4] was reached, with ±F being the partial order such that RL( X, ±F ) = F.
If χA(F) = false, then suppose there actually exists some partial order ± such that F = RL( X, ± ). However, step [4] will then be reached, with ±F = ± and RL( X, ± ) = F, giving χA(F) = true, contrary to assumption.
 
We will see in the next section that the Equivalence Theorem is a corollary of the Reconstruction Theorem (Theorem 4.1).
Defining a hs-poset from its Labelings
Reconstruction Theorem
We show that each hs-poset ( X, ± ) can be defined uniquely using the set of its order-preserving bijections (on any set of labels L for X).
Theorem 4.1 (Reconstruction Theorem) Let ( X, ± ) be a hs-poset, and L a set of labels with the same cardinality as X. Then, for all x, y ∈ X, we have:
x и y  ⇐⇒ ∀l ∈ RL( X, ± ) : l(x) < l(y)

Proof. Note first that, by definition of a labeling, we have immediately that x и y implies ∀l ∈ RL( X, ± ) : l(x) < l(y). The converse follows by contraposition from Proposition 4.2 below.	 

Proposition 4.2 Let ( X, ± ) be a hs-poset, and L a set of labels with the same cardinality as X. If x, y ∈ X are such that x /± y, then there exists an order- preserving bijection L w.r.t. ± such that L(x) > L(y).
We give the proof of the proposition in the next section, but we first present some of its easy corollaries.
Corollary 4.3 (Equivalence Theorem) Let ±1 and ±2 be two partial orders on a set X, and let L be a set of labels. Then:
±1 = ±2 ⇐⇒ RL( X, ±1 ) = RL( X, ±2 )
Proof. If ±1 = ±2, then clearly RL( X, ±1 ) = RL( X, ±2 ). To prove the converse, suppose ±1 /= ±2. Then there exist x, y ∈ X such that either x ±1 y and x /±2 y, or x ±2 y and x /±1 y ; without loss of generality, assume the former case.
By the Reconstruction Theorem, there exists some order-preserving bijection L ∈ RL( X, ±2 ) such that L(x) > L(y). Now, for each l ∈ RL( X, ±1 ), we have l(x) < l(y), as x ±1 y, so L /∈ RL( X, ±1 ), and so RL( X, ±1 ) /= RL( X, ±2 ). 
Recall that ΔX = { (x, x) : x ∈ X }. We now present the pseudo-code for a simple Reconstruction Algorithm A0, referred to as the “Brute-Force Algorithm”:
A0(J)  :=
-- INPUT	: a set J of bijections, with J = RL( X, ± ) for some ±
-- OUTPUT : the partial order ±
£ := ∅
for each pair (x, y) ∈ X × X such that x /= y
if 6 f ∈J : f (x) < f (y) then £ := £∪ { (x, y) }
return £ ∪ ΔX
Corollary 4.4 For any X, ±, L : A0(RL( X, ± )) = ± .
Proof. Let Y = RL( X, ± ); then (x, y) ∈ A0(Y) iff x = y or 6f ∈Y : f (x) < f (y). The result now follows from the Reconstruction Theorem.	 
Notation: Let J be a set of bijections from X to L :
иF = {(x, y) : 6f ∈ J, f (x) < f (y)}
±F = ΔX ∪ и J (= A0(J)) 
The above notation is justified by the following trivial corollary:
Corollary 4.5 Let J be a non-empty set of bijections from X to L. Then:
иF is a strict partial order.
±F is a partial order.
J ⊆ RL( X, ±F ).
Notation: The orders given in Corollary 4.5 are called the strict order induced by J
and the order induced by J, respectively.

Observe that the above corollary suggests that each set of bijections J defines a partial order whose structure can be deduced from that of J, as demonstrated in Example 4.9 below.
Definition 4.6 Let f, g : X '→ L be two bijections. Then g is an inverse of f if for all x, y ∈ X, we have g(x) < g(y) iff f (y) < f (x).
Remark 4.7 Clearly, if g is an inverse of f , then f is an inverse of g.
Remark 4.8 If X is finite and Card (L) = Card (X), then each bijection f : X '→L has a unique inverse. In fact, if (a1,..., an) are the labels in L in increasing order, and (x1,..., xn) are the elements of X, indexed so that f (xi) = ai, then the unique inverse g of f is given by g(xi) = an−(i−1), for each 1 ≤ i ≤ n.
Example 4.9 Let f, g : X '→L be two bijections. Then:
The induced order ±{f} is a linear order.
If f and g are inverses, then the induced order ±{f,g} is the discrete order.
Remark 4.10 Recall from Example 2.14 that the random structuring on a discrete order is isomorphic to the set of all the permutations on a given set of labels. Thus, the induced order ±{f,g} in the above example illustrates a case of an order which can be induced by a strict subset of its random structuring. We note that the task of determining how many labelings of an order are needed to induce that order is well known in the literature as the task of determining the dimension of the order.
Corollary 4.11 If J1 and J2 are two sets of bijections, then:
иF1∪F2  = иF1 ∩ иF2 .
±F1∪F2 = ±F1 ∩ ±F2 .
This observation suggests the following refinement of algorithm A0 :
A1(J)  :=
-- INPUT	: a set J = { f1, f2,..., fk } of bijections,
--	with J = RL( X, ± ) for some ±
-- OUTPUT : the partial order ±
£ := и { f1 }
for each 2 ≤ i ≤ k
if £ = ∅ then return ΔX
else
£ := £ ∩ и { fi }
return £∪ ΔX

Proof of the Fundamental Proposition
We now set about the proof of Proposition 4.2. In order to do this, we introduce the notions of pruned ascending tree and pruned descending tree (for the notions of ascending and descending trees, recall Definition 2.1).

Definition 4.12 Let ( X, ± ) be a partial order and x ∈ X. Define, respectively, the ascending tree of x pruned at height i and the descending tree of x pruned at height i by:
⇑i x = { y ∈⇑x : height (y) ≤ i }
⇓i x = { y ∈⇓x : height (y) ≥ i }
Recall that the ascending tree of x just consists of the elements of X encountered when ascending the paths starting from x, that is, to construct ⇑x we first take x, then the elements of [x|, plus those of [[x||, and so on. In the case of the pruned ascending tree, we just stop taking the elements of an ascending path when we find an element z of this path such that height (z) > i. In particular, we do not include this element z itself. Note that any element above such a z will also have height greater than i, and so it is useless to further explore the ascending path after z, that is, we cannot expect to find any further elements on that path to include in ⇑i x.
A symmetric line of reasoning applies in the case of ⇓i x. The next observations follow easily from Fact 2.8.
Fact 4.13 Let ( X, ± ) be a hs-poset, h its height and x, y ∈ X.
For all y ∈ ⇑i x, we have height (x) ≤ height (y) ≤ i.
For all y ∈ ⇓i x, we have i ≤ height (y) ≤ height (x).
x ∈ ⇑i x iff i ≥ height (x), and in this case, x is the unique element of ⇑i x
whose height equals height (x).
x ∈ ⇓i x iff i ≤ height (x), and in this case, x is the unique element of ⇓i x
whose height equals height (x).
If x /± y, then ⇑x ∩ ⇓y = ∅.
If x /± y, then ⇑i x ∩ ⇓j y = ∅, for all heights i, j ≤ h.
To prove Proposition 4.2, and for §5 below, the following simple concept is useful:
Definition 4.14 Let f be any function defined on X, and let x, y be fixed elements of X. Define the function fxy on X by:
⎧
fxy (z) = ⎪⎨ f (y), if z = x
⎪⎪⎩ f (z), otherwise
Notation: X\Y = {x ∈ X : x /∈ Y }.
Proof. (of Proposition 4.2) If x /± y, our task is to find a labeling L of ( X, ± ) such that L(x) > L(y). To accomplish this, we examine separately the three cases height (x) > height (y), height (x) = height (y), and height (x) < height (y).
If height (x) > height (y), we can take L to be any height-canonical labeling l
(see Example 2.18 and Fact 2.20), since l(x) > l(y) for any such l.
If height (x) = height (y), let l be any height-canonical labeling. If l(x) > l(y),

then take L = l, otherwise take L = lxy. Then L is still height-canonical and thus order-preserving (Remark 2.19), and of course L(x) > L(y).
If height (x) < height (y), then let l be any height-canonical labeling on ( X, ± ). Let Z = {z ∈ X : height (x) ≤ height (z) ≤ height (y)} and Λ = l(Z). In addition, let x↑y denote ⇑height(y) x and y ↓x denote ⇓height(x) y .
Before continuing, we make some observations:
Since l is height-canonical, we have, for any u ∈ X:
height (u) > height (y) ⇒ l(u) > a, 6a ∈ Λ.
height (u) < height (x) ⇒ l(u) < a, 6a ∈ Λ.
x↑y ∪ y ↓x ⊆ Z, by definition.
x↑y ∩ y ↓x = ∅, by Fact 4.13(f).
Let Z− = Z \ (x↑y ∪ y ↓x) (see observation 2). Let Λx and Λy denote the sets of the Card (x ↑ y) largest values and the Card (y ↓ x) smallest values in the set Λ, respectively, noting from observation 3 that Λx and λy must be disjoint. Finally, let Λ− = Λ \ (Λx ∪ Λy). With this notation, we complete our observations with:
a < b < c, 6a ∈ Λy, 6b ∈ Λ−, 6c ∈ Λx
We now define the required labeling L. The general idea is to label the elements of X\Z in the same manner as l does, setting L(u) = l(u) for all u ∈ X\Z. It then remains to define L on Z, and we do so by separately labeling the elements of x↑y with the labels of Λx, those of y ↓x with the labels of Λy, and finally, the remaining elements of Z, i.e., Z−, with those of Λ−, and we do so in a “height-canonical” way; in other words, we define L as a locally height-canonical labeling.
We present the detailed definition of L on x ↑ y; its definition on y ↓ x and Z− are done in a similar way. Let u ∈ x↑y, so that height (x) ≤ height (u) ≤ height (y); we proceed inductively on height (u): 
As the base case, note that by Fact 4.13(c), if height (u) = height (x) then u = x; define L(x) to be the smallest label in Λx.
Having already defined L on all elements of height k (height (x) ≤ k < height (y)), take successively each u ∈ x↑y of height k + 1, and define L(u) to be the smallest label in Λx which is not yet used by L.
Note that L(Z) = Λ. Thus, the labeling functions L and l are identical on X\Z, while their values on Z are merely permuted. Note also that the restrictions of L to the sets x ↑ y, y ↓ x and Z− are each height-canonical labelings relative to the corresponding restrictions on ± .
Since L(x) ∈ Λx and L(y) ∈ Λy, observation 4 gives L(x) > L(y), as desired.
It now remains for us to show that L is an order-preserving bijection w.r.t. ± . To do so, it suffices to show that for all u ∈ X and u' ∈ [u|, we have L(u) < L(u'). The possible cases are each examined in turn:
u /∈ Z, u' /∈ Z : Then L(u) = l(u) < l(u') = L(u').
u ∈ Z, u' /∈ Z : As u' /∈ Z, either height (u') < height (x) or height (u') > height (y).

But height (u') > height (u) ≥ height (x) (since u ∈ Z), so we must in fact have height (u') > height (y). Using observation 1.a (with u' in place of u) and the fact that L(u) ∈ Λ now gives l(u') > L(u), and as L(u') = l(u'), we have L(u) < L(u').
u /∈ Z, u' ∈ Z : By a symmetric argument to the previous one, but this time using observation 1.b, we conclude that L(u) < L(u') in this case also.
u ∈ Z, u' ∈ Z : Since Z is the union of the three disjoint sets x↑y, y ↓x, and Z−,
we consider separately the cases of u belonging to each of these three sets:
u ∈ x↑ y : Then u' ∈ x↑ y (by definition of x↑ y), and as L is height-canonical on x↑y, we have L(u) < L(u').
u ∈ y ↓x : Then L(u) ∈ Λy. We examine the three possible sub-cases:
u' ∈ x↑y : Then L(u') ∈ Λx and by observation 4, L(u) < L(u').
u' ∈ y ↓x : As L is height-canonical on y ↓x, we have L(u) < L(u').
u' ∈ Z− : Then L(u') ∈ Λ− and by observation 4, L(u) < L(u').
u ∈ Z− : Then L(u) ∈ Λ−. We examine the three possible sub-cases:
u' ∈ x↑y : Then L(u') ∈ Λx and by observation 4, L(u) < L(u').
u' ∈ y ↓x : This sub-case cannot arise, for if u' ∈ y ↓x, then since u ∈ [u'♩ and
height (u) ≥ height (x), we would have u ∈ y ↓x, contradicting u ∈ Z−.
u' ∈ Z− : As L is height-canonical on Z−, we have L(u) < L(u').

Some Further Results on Random Structures
A Characterisation of Atomic Isolated Subsets
In this section, we recall two significant concepts from MOQA : the concept of an Atomic Isolated Subset (AIS) and that of a free pair of labels for a given labeling. Then we show that the AIS’s can be characterised using only the labelings on the given poset. This result is a consequence of the Reconstruction Theorem.
Definition 5.1 A set Y ⊆ X is an Atomic Isolated Subset in ( X, ± ) if, for all distinct elements x, y ∈ Y :
x /± y and y /± x (Y is an antichain in ( X, ± )); and
[x| = [y| and [x♩ = [y♩.
Definition 5.2 Let a, b ∈ L be two labels, let l ∈ RL( X, ± ), and let x = l−1(a) and y = l−1(b). Then {a, b} is called a free pair of labels for l if lxy ∈ RL( X, ± ).
If x и y, then we must have l(x) < l(y) for all labelings l, and thus the set
{l(x), l(y)} cannot be a free pair.
Lemma 5.3 Let ( X, ± ) be a hs-poset, and let Y ⊆ X. Then Y is an AIS iff for every x, y ∈ Y and every l ∈ RL( X, ± ), the set {l(x), l(y)} is a free pair.
Proof. Firstly, suppose Y is an AIS, x, y ∈ Y , and l ∈ ( X, ± ). We show that
{l(x), l(y)} is a free pair by showing that 6u, v ∈ X : u и v ⇒ lxy(u) < lxy(v).
Since u и v, but Y is an antichain, at most one of u, v can belong to Y .

If neither u nor v equals x or y, then lxy(u) = l(u) < l(v) = lxy(v).
If u ∈ {x, y}, then assume, without loss of generality, that u = x. Then we have
v ∈ [x| = [y|, so l(y) < l(v). Thus lxy(u) = lxy(x) = l(y) < l(v) = lxy(v).
The case v ∈ {x, y}, taking v = x and thus u ∈ [x♩, is handled similarly.
Secondly, suppose that for all x, y ∈ Y and all l ∈ RL( X, ± ), the set {l(x), l(y)} is a free pair. It is clear that for all distinct x, y ∈ Y , we have x /± y and y /± x (otherwise, {l(x), l(y)} would not be a free pair for any labeling l).
We now show that, for all distinct x, y ∈ Y , we have [x| = [y| and [x♩ = [y♩.
We establish the first equality by contradiction; the second is handled similarly.
If x, y ∈ Y with [x| /= [y|, we exhibit a labeling l for which {l(x), l(y)} is not a free pair. By hypothesis, there exists z ∈ [x| and z /∈ [y|, or z ∈ [y| and z /∈ [x|. Assume the first case; the second is handled similarly. There are two possibilities:
y /± z : By Proposition 4.2, there is a labeling l such that l(y) > l(z). But then
lxy is not a labeling, since lxy(x) = l(y) > l(z) = lxy(z), although z ∈ [x|.
y ± z : Clearly, z /= y, since otherwise y ∈ [x|, contradicting x /± y. So y и z, and as z /∈ [y|, there exists a z' ∈ [y| with z' и z. Moreover, we have x /± z', since z ∈ [x|. Thus, we are now in the same situation as in the previous case, but with the roles of x and y reversed and z' in place of z: x /± z', z' ∈ [y| and z' /∈ [x|. We then conclude that {l(x), l(y)} is not a free pair.
 
Note that if Y is an AIS, then all its elements have the same ranking probabilities
in the sense of [12,13].

Cardinality of Finite Random Structurings
In this section, we give some results about the cardinality of random structurings on finite (and so height-stratifiable) posets.
Let ( X, ± ) be a finite poset with n = Card (X), and let L be a set of labels, with Card (L) = n. Denote RL( X, ± ) by Y, and let c = Card (Y).
If ± is a linear order, that is, if there is a bijection ƒ : X '→ L with ± = ±f , then we have Y = {ƒ}, and so c = 1.
If ± is the discrete order, then Y contains all possible bijections from X to L, and so c = n!. The result for non-discrete orders is given by:
Lemma 5.4 If ( X, ± ) is a non-discrete ﬁnite poset, then Card (RL( X, ± )) ≤ n! ,
where n = Card (X).
Proof. Suppose the contrary. Then RL( X, ± ) must contain a labeling, but also its inverse (as an easy consequence of the second part of Remark 4.8), and so ± must be the discrete order (Example 4.9). This contradicts the hypothesis.	 
We sum up the results of this section by the following:
Theorem 5.5 If ( X, ± ) is a ﬁnite poset, with n = Card (X), L is a set of labels with Card (L) = n, then the possible values of c = Card (RL( X, ± )) are:

c = 1	⇔ ± is a linear order
c = n! ⇔ ± is the discrete order
1 < c ≤ n! ⇔ ± is neither linear nor discrete.
Conclusion
We showed that every height-stratifiable poset is uniquely determined by the set of all labelings on it using a technique, in the proof of Proposition 4.2, based on the existence of height-canonical labelings. That technique consists of a direct modification of a labeling by definition of local height-canonical labelings to get a new labeling (or equivalently a new linear extension) satisfying a required property. It can be used, for instance, to prove that the possible values for l(x), where x ∈ X and l : X '→ L is a labeling on the poset ( X, ± ) with n elements, are precisely ai+1,..., an−j, where i = Card (⇓ x) − 1, j = Card (⇑ x) − 1, and a1,..., an are the labels, arranged in increasing order.
Theorem 5.5 gives a first characterisation of the cardinality of random structures. A more precise and complete characterisation is expected. Moreover, the theorem shows that many recursive sets of lists cannot be captured as random structures. Nevertheless, it opens the way to a more complex question, that is, how recursive sets can be captured by sequences of random structures in the most efficient way.
We may also expect that the new framework in the which linear extensions are used via their interpretations as labelings and random structures in [15,16,14] will open the way to interesting new questions about linear extensions.
Acknowledgement
The authors wish to thank the anonymous referees for their helpful suggestions.

References
Brightwell G.: Linear extensions of infinite sets. Discrete Math 70 (1988) 113–136.
Brightwell G., Pr¨omel H.-J., Steger A.: The average number of linear extensions of a partial order. J. Combinatorial Theory (A) 73 (1996) 193–206.
Brightwell G., Tetali P.: The number of linear extensions of the boolean lattice. Order 20 (2003) 333– 345.
Brightwell, G., Winkler P.: Counting Linear Extensions. Order 8 (1991) 225–242.
Brualdi, R. A.: Introductory Combinatorics, 4th ed. New York: Elsevier, 1997.
Bubley, R., Dyer, M.: Faster Random Generation of Linear Extensions. In Proc. Ninth Annual ACM- SIAM Symposium on Discrete Algorithms, San Francisco, Calif. (1998) 350–354.
Carlsen L., Lerche D., Sorensen P.B.: Improving the predicting power of partial order based QSARs through linear extensions. J. Chem. Inf. Comput. Sci. 42(4) (Jul–Aug 2002) 806–811.
Dushnik B., Miller E.W.: Partially ordered sets. American Journal of Mathematics 63 (1941) 600–610.
Flajolet P., Vitter, J.S.: Average-Case Analysis of Algorithms and Data Structures. Handbook of Theoretical Computer Science, Vol. A: Algorithms and Complexity. Elsevier (1990) 431–524.

Kelly, D.: The 3-irreducible partially ordered sets. Canad. J. Math. 29 (1977) 367–383.
Knuth D.: The Art of Computer Programming Vol. 3. Addison-Wesley (1973).
Lerche D., Sorensen P.B.: Evaluation of the ranking probabilities for partial orders based on random linear extensions. Chemosphere 53(8) (Dec 2003) 981–92.
Lerche D., Sorensen P.B., Bruggeman R.: Improved estimation of the ranking probabilities in partial orders using random linear extensions by approximation of the mutual ranking probability. J. Chem. Inf. Comput. Sci. 43(5) (Sep–Oct 2003) 1471–1480.
Schellekens M.: Modular Timing, An overview of CEOL research. Proceeding of MFCSIT’06, Cork, Ireland (Aug 2006), pp. 300–303.
Schellekens M.: A Modular Calculus for the Average Cost of Data Structuring. Springer (2008). See:
www.springer.com/computers/foundations/

Schellekens M.: MOQA: Unlocking the Potential of Compositional Static Average-Case Analysis. Journal of Logic and Algebraic Programming (2008) (in press).
Schellekens M., Hickey D., Bollella G.: ACETT, a Linearly-Compositional Programming Language for (semi-)automated Average-Case analysis. IEEE Real-Time Systems Symposium - Work In Progress Session (2004).
Szpilrajn E.: Sur l’extension de l’ordre partiel. Fundamenta Mathematicae 16 (1930).
Vall´ee T.: Functionally-Generalised MOQA Operations. Proceedings of MFCSIT’06, Cork, Ireland (Aug 2006), pp 308–311.
Varol, Y., Rotem, D.: An Algorithm to Generate All Topological Sorting Arrangements. Comput. J.
24 (1981) 83–84.
