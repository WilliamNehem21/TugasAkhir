Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 305 (2014) 5–18
www.elsevier.com/locate/entcs

Bisimilar and Logically Equivalent Programs in PDL
Mario R. F. Benevides1,2
Computer Science Department and Systems and Computer Engineering Program Federal University of Rio de Janeiro
Brazil

Abstract
In standard Propositional Dynamic Logic (PDL) literature [5,16,4] the semantics is given by Labeled Tran- sition Systems, where for each program π we a associate a binary relation Rπ . Process Algebras [1,8,10,2] also give semantics to process (terms) by means of Labeled Transition Systems. In both formalisms, PDL and Process Algebra, the key notion to compare processes is bisimulation. In PDL, we also have the no- tion of logic equivalence, that can be used to prove that two programs π1 and π2 are logically equivalent π1 ϕ	π2 ϕ. Unfortunately, logic equivalence and bisimulation do not match in PDL. Bisimilar
programs are logic equivalent but the converse does not hold.
This paper proposes a semantics and an axiomatization for PDL that makes logically equivalent programs also bisimilar. We prove soundness, completeness and the finite model property.
Keywords: Bisimulation, Propositional Dynamic Logic, Modal Logic

Motivation
In standard PDL literature [5,16,4] the semantics is given by Labeled Transition Systems, where for each program π we associate a binary relation Rπ. The sequential composition and non-deterministic choice operators are defined as the composition and union of relations respectively.
Rπ1;π2 = Rπ1 ◦ Rπ2	Rπ1∪π2 = Rπ1 ∪ Rπ2
Process Algebras [1,8,10,2] also give semantics to process (terms) by means of Labeled Transition Systems. In both formalisms, PDL and Process Algebra, the key notion to compare processes is bisimulation. In PDL, we also have the notion of logic equivalence, that can be used to prove that two programs π1 and π2 are logically equivalent ▶ ⟨π1⟩ϕ ↔ ⟨π2⟩ϕ (where ⟨πi⟩ϕ means that after the execution

1 This work was supported by the Brazilian research agencies CNPq and CAPES.
2 Email: mario@cos.ufrj.br

http://dx.doi.org/10.1016/j.entcs.2014.06.002
1571-0661/© 2014 Elsevier B.V. All rights reserved.

of program πi formula ϕ holds). Unfortunately, logic equivalence and bisimulation do not match in PDL. Bisimilar programs are logic equivalent but the converse does not hold. For instance, take programs π1 = a; (π3 ∪ π4) and π2 = a; π3 ∪ a; π4

⟨a; (π3 ∪ π4)⟩ϕ	↔	⟨a⟩⟨(π3 ∪ π4)⟩ϕ
↔	⟨a⟩(⟨π3⟩ϕ ∨ ⟨π4⟩ϕ)
↔	⟨a⟩⟨π3⟩ϕ ∨ ⟨a⟩⟨π4⟩ϕ
↔	⟨a; π3⟩ϕ ∨ ⟨a; π4⟩ϕ
↔	⟨a; π3 ∪ a; π4⟩ϕ

But it is not difficult to see that π1 and π2 are non-bisimilar programs, for after first a step on π1 it arrives at π3 ∪ π4, and this is matched by neither of the two possibilities on π2: π3 or π4.




◦
π3
J 
π2

zz
◦
π4
J 
π1
a
J 
◦

zz

◦	◦	◦	◦
Fig. 1. Non-Bisimilar Programs

One interesting discussion on trace semantics appears on [2]. They define and compare various semantics for concrete sequential processes and provide algebraic axiomatization and semantical modal characterization (no modal axiomatization) for them.
The main motivation of this work is to propose a new semantics for PDL, based on traces with context, which matches the notion of logic equivalence and with bisimulation, i. e., two programs π1 and π2 are logically equivalent (▶ ⟨π1⟩ϕ ↔
⟨π2⟩ϕ) if and only if they are bisimilar. We provide an axiomatization and prove completeness w.r.t this new semantics. The proof completeness yields finite model property and decidability.
It is important to notice that our contribution is on PDL and not on process theory.
Propositional Dynamic Logic
In this section, we present the syntax and semantics of PDL.
Definition 2.1 The PDL language consists of a set Φ of countably many proposi- tion symbols, a set Π of countably many basic programs, the boolean connectives
¬ and ∧, the program constructors ;, ∪ and ٨ and a modality ⟨π⟩ for every program

π. The formulas are defined as follows:
ϕ ::= p |Т| чϕ | ϕ1 Λ ϕ2 | ⟨π⟩ϕ, with π ::= a | π1; π2 | π1 ∪ π2 | π٨,
where p ∈ Φ and a ∈ Π.
In all the logics that appear in this paper, we use the standard abbreviations
⊥≡ чТ, ϕ V φ ≡ ч(чϕ Λ чφ), ϕ → φ ≡ ч(ϕ Λ чφ) and [π]ϕ ≡ ч⟨π⟩чϕ.
Definition 2.2 A frame for PDL is a tuple 7 = (W, R) where
W is a non-empty set of states;
R = {Ra | a ∈ Π}, Ra are binary relations over W , for each basic program a ∈ Π;
We can inductively define a binary relation Rπ, for each non-basic program π, as follows
Rπ1;π2 = Rπ1 ◦ Rπ2 ,
Rπ1∪π2 = Rπ1 ∪ Rπ2 ,
Rπs = R٨ , where R٨ is the reflexive transitive closure of Rπ.
Definition 2.3 A model for PDL is a pair M = (7, V), where 7 is a PDL frame and V is a valuation function V :Φ → 2W .
Definition 2.4 Let M = (7, V) be a model. The notion of satisfaction of a formula ϕ in a model M at a state w, notation M,w H ϕ, can be inductively defined as follows:
M,w H p iff w ∈ V(p);
M,w H Т always;
M,w H чϕ iff M,w /H ϕ;
M,w H ϕ1 Λ ϕ2 iff M,w H ϕ1 and M,w H ϕ2;
M,w H ⟨π⟩ϕ iff there is wj ∈ W s.t. wRπwj and M, wj H ϕ.
Example 2.5 M,w H ⟨(π1; π2)⟩p iff there is wj ∈ W s.t. wRπ1;π2 wj and M, wj H p, iff there is wj ∈ W s.t. wRπ1 ◦ Rπ2 wj and M, wj H p






π1;π2
w
π1
J 
◦
π2
 Jz 
p wj

Process Calculus
In this section, we propose a very small process (program) calculus for the PDL programs presented in the previous section 2. We prove that two processes are bisimilar if and only if they have the same set of finite possible runs with context. It is inspired on [2].


Table 1 Transition Relation

Let N = {a, b, c, . . .} be a set of names or actions, denoted by α, β,	The
language can be defined as follows.
π ::= α | π1; π2 | π1 + π2 | π٨, where α ∈N 
We use π and τ to denote processes (programs) and α, β and γ to denote actions.
We write π →α πj to express that the process π can perform the action α and
after that behave as πj. We write π →α √ to express that the process π successfully
finishes after performing the action α. A process finishes when there is no possible
β
action left for it to perform. For example, β →	.
The semantics of our process calculus can be given by the transition rules pre- sented in the table below.
The concept of bisimulation is a key notion in any process algebra. It is an equivalence relation between processes which have mutaly similar behavior. The intuition is that two bisimilar processes cannot be distinguished by an external observer.
Definition 3.1 Let P be the set of all processes. A set Z ⊆ P × P is a strong bisimulation if (π, τ ) ∈ Z implies the following:

If π →
If τ →
πj, then there is τj ∈P such that τ →α τj, then there is πj ∈P such that π →α
τj and (πj,τj) ∈ Z; πj and (πj,τj) ∈ Z;

π →
√ if and only if τ →α √.

Definition 3.2 Two process π and τ are strongly bisimilar (or simply bisimilar ), denoted by π ∼ τ , if there is a strong bisimulation Z such that (π, τ ) ∈ Z.
Proposition 3.3 π1; (π2 + π3) /∼ π1; π2 + π1; π3
See figue 1.

3.1	Runs with Context
In this section, we introduce the key concept of ﬁnite possible runs with context of a process. This concept plays a central role in the semantics of our logics.
Definition 3.4 A sequence of action with context, denoted by −→α c, is a sequence of actions and finite sets of actions of the form
α1{β1 ··· β1 }.α2{β2 ··· β2 }, ··· .αn{βn ··· βn }. ··· ,
where αi /∈ {βi ··· βi }, for 1 ≤ i ≤ n.

If −→α c = α1C1.α2C2	.αnCn is a finite sequence of action with context, we say that the length of −→α c is n.
Definition 3.5 Let −→α c = α1C1.α2C2 ··· .αnCn and
β  = β1D1.β2D2 ··· .βnDn sequences of action with context of length n. We define a strict partial order over sequences of actions with context as follows
−→α c ≺ −→β c iff for all i, 1 ≤ i ≤ n,	αi = βi,
Ci ⊆ Di,
for at least one i, Ci ⊂ Di.
Definition 3.6 Let −→α c = α1{β1...β1 }α2{β2...β2 } ...αn{βn ··· βn } be a sequence

of action with context. We say that −→α c matches a process π0 if π0 α1
π1 α2

π2 ··· πn−1 α→n πn and for all i, 0 ≤ i < n, {αi, βi ··· βi } are all the actions that πi

can perform.
1	ki

We write π −→α c πj to express that −→α c matches π and the process π may perform

⇒	−→c
j	−→α c √

the sequence of actions α  and after that behave as π . We write π ⇒	to express
that −→α c matches π and the process π may successfully finish after performing the sequence of actions −→α c (this, in particular, implies that −→α c is finite).
Definition 3.7 We define the set of finite possible runs with context of a process
π, denoted by −R→c (π), as −R→c (π)= {−→α c : π −→α c √ .
In order to obtain the desired relation between bisimulation and logic equiva- lence, we introduce the concept of ﬁnite possible runs with context of processes, i.e., situations in which the processes successfully finish. Thus, we present some useful results about finite possible runs with context. It is important to notice that in our process calculus all processes, at any state in their execution, can only perform a finite set of actions, i.e., they are image ﬁnite.
Definition 3.8 Let R and S be sets of finite sequences of actions with context. We can define the following operations on these sets:
R ◦ S = {−→α c.−→β c : −→α c ∈ R and −→β c ∈ S};
R ∪ S = {−→α c : −→α c ∈ R or −→α c ∈ S};
R0 = {−→ε }, Rn = R ◦ Rn−1(n ≥ 1);

R∗ = S
n∈N
Rn.

Lemma 3.9 If π ∼ τ, then, for every −→α c, π −→α c √ iff τ −→α c √.
⇒	⇒
A proof of this lemma can be found in appendix A. This proof is based in similar one presented in [3].
Lemma 3.10 If for every −→α c, π −→α c √ if and only if τ −→α c √, then π ∼ τ
Proof. Suppose π −→α c √ if and only if τ −→α c √ and π /∼ τ . Then there exists α  such

that π →α1 π
⇒
and for all τ

α1
either τ	τ
⇒
(1) or π

/∼ τ
1
(2). But (1) cannot be true,

because it contradicts the hypothesis that π and τ are able to perform the same set of actions, because if α1 is the first action in some sequence of action −→α c, then its context contains all the actions that π and τ can perform. The only remaining possibility is (2), π1 /∼ τ1. If we apply the same reasoning for π2 /∼ τ2 and so on
for πi /∼ τi and πi and τi must be able to perform the same set of actions. As all processes eventually terminate, we must eventually reach a pair πn and τn such that
πn /∼ τn and πn and τn must be able to perform the same set of actions γ1, ··· γkn
√	√	√	n	n
and either πn =	or τn =	or both πn = τn =	. The first two cases are not
possible because πn and τn must be able to perform the same set of action and √ does not perform any action and any process different of √ must be able to perform at least one action. Thus, the only possibility is πn = τn = √, which yields that
πn ∼ τn, which is a contradiction. Therefore, π ∼ τ .
2
Theorem 3.11 π ∼ τ if and only if −R→c (π)= −R→c (τ ).
Proof. (⇒) Suppose that −→α c ∈ −R→c (π). Then, π —→α c √. As π ∼ τ , this implies, by

f
—→c √
⇒	−→	−→

lemma 3.9, that τ ⇒	, which means that −→α c ∈ −R→c (τ ). Thus, Rc (π) ⊆ Rc (τ ).
f	f	f
The proof that −R→c (τ ) ⊆ −R→c (π) is entirely analogous.
(⇐) Suppose that −R→c (π) = −R→c (τ ).  By the definition of −R→c (π) and −R→c (τ ),

π —→α c √
f	f	f	f
—→α c √

⇒	if and only if τ ⇒
. And by lemma 3.10, π ∼ τ .
2

Next, we present some equalities between sets of finite possible runs that are useful to the soundness proof of our axiomatization.
Definition 3.12 Let −→α c = α1C1.α2C2 ··· .αnCn ∈ −R→c (π1),
{γ1, ··· , γm} be the set of all actions that π2 can perform and C1j = C1∪{γ1, ··· , γm}
and C1jj = C1 \ {γ1, ··· , γm}. We define
−→α c |+π2 = α1C1j .α2C2 ··· .αnCn
−→α c |—π2 = α1C1jj.α2C2 ··· .αnCn
−R→c (π1) |+π2 = {−→α c |+π2	| −→α c ∈ −R→c (π1)}
−R→c (π1) |—π2 = {−→α c |—π2	| −→α c ∈ −R→c (π1)}
Theorem 3.13 The following set equalities are true:
−R→c (α)= {α};
−R→c (π1; π2)= −R→c (π1) ◦ −R→c (π2);
−R→c (π1 + π2)= −R→c (π1) |+π2 ∪−R→c (π2) |+π1 ;
−R→c (π∗)= (−R→c (π))∗.
Proof. The proof is straightforward from table 1.	2

PDL+
In this section we present the language, semantics and an axiomatic system of our Propositional Dynamic Logic with a non-deterministic choice operator.
Language and Semantics
The language is similar to the one presented in definition 2.1, where we replace + for ∪.

ϕ ::= p |Т| чϕ | ϕ1 Λ ϕ2 | ⟨π⟩ϕ, with π ::= a | π1; π2 | π1 + π2 | π٨,
where p ∈ Φ and a ∈ N .
Definition 4.1 A frame for PDL+ is a tuple 7 = (W, Ra) where
W is a non-empty set of states;
Ra is a binary relation over W , for each basic program a ∈ Π;
We can inductively define a binary relation Rπ, for each non-basic program π, as follows
Rπ1;π2 = Rπ1 ◦ Rπ2 ,
Rπ1+π2 = {(s, t) | [(s, t) ∈ Rπ1 and ∃r(s, r) ∈ Rπ2 ] or
[(s, t) ∈ Rπ2 and ∃r (s, r) ∈ Rπ1 ]}
Rπs = R٨ , where R٨ is the reflexive transitive closure of Rπ.
The semantical notion of PDL+ model and satisfaction for PDL+ is as defined for PDL in definitions 2.3 and 2.4
If M,w H ϕ for every state w, we say that ϕ is globally satisﬁed in the model M, notation M H ϕ. If ϕ is globally satisfied in all models M of a frame 7 , we say that ϕ is valid in 7 , notation 7 H ϕ. Finally, if ϕ is valid in all frames, we say that ϕ is valid, notation H ϕ. Two formulas ϕ and ψ are semantically equivalent if H ϕ ↔ ψ.
Proposition 4.2 /H ⟨π1; (π2 + π3)⟩p ↔ ⟨π1; π2 + π1; π3⟩p
Proof. Let M be a model based on the frame bellow with V (p)= {v}. It is easy to verify that
M,w /H ⟨π1; (π2 + π3)⟩p and
M,w H ⟨π1; π2 + π1; π3⟩p
w

zz
◦	◦
π3	π3
J	J 
v	◦	2
Next definition and lemma relate our semantics with possible runs with context.

Definition 4.3 Let 7 = (W, Rα) be a frame, (v0, v1,..., vn),
n	1, be a finite path in	and −→α	(π), of length n, be a sequence of action with context of a process π. We say that −→α c matches path (v0, v1,..., vn) for
process π iff for all i, 1 ≤ i ≤ n, (−→α c)i = αi{βi ...βi } and (vi—1, vi) ∈ Rα and for
all βj, 1 ≤ j ≤ ki, there exists a w such that (vi—1, w) ∈ Rβ . We say that −→α c
matches exactly path
(v0, v1,..., vn), if there exists a unique w such that (vi—1, w) ∈ Rγ, for all γ ∈
{βi ··· βi } and 1 ≤ i ≤ n.
1	ki
A frame 7 matches a process π at state w iff for all −→α c ∈ −R→c (π), there exists a
path ρ, in 7 , such that −→α c matches ρ.
Lemma 4.4 M,w H ⟨π⟩ϕ iff 7 matches π at w, there is a ﬁnite path (v0, v1,..., vn), n ≥ 1, such that v0 = w, M, vn H ϕ and there is −→α  ∈ R (π) of length n such
that −→α c matches the path (v0,..., vn).
A proof of this lemma can be found in appendix B.
Bellow, we present the main theorem of this section, it establishes the equivalence between bisimilar and logically equivalent programs.
Theorem 4.5 −R→c (π)= −R→c (τ ) if and only if H ⟨π⟩p ↔ ⟨τ⟩p.
Proof. (⇒) Suppose that −R→c (π) = −R→c (τ ), but /H ⟨π⟩p ↔ ⟨τ⟩p. Then, we may
assume, without loss of generality, that there is a model M and a state v0 in this model such that M, v0 H ⟨π⟩p (1), but M, v0 /H ⟨τ⟩p (2). By lemma 4.4, (1) implies that there is a path (v , v ,..., v ), n  1, in  such that  , v H p (3) and there
is −→α c ∈ −R→c (π) that matches this path. But as −R→c (π)= −R→c (τ ), then −→α c ∈ −R→c (τ ).
This and (3) imply, by definition 4.4, that	, v0 H τ p, which contradicts (2). (⇐) Suppose that H ⟨π⟩p ↔ ⟨τ⟩p (1), but −R→c (π) /= −R→c (τ ). Then, we may
assume, without loss of generality, that there is −→α c such that −→α c ∈ −R→c (π), but
−→α c /∈ −R→c (τ ) and there is no −→β c ∈ −R→c (τ ) such that −→β c ≺ −→α c.
Let us build a frame , that matches π, which consists of a finite tree and has a path (v0,..., vn), n ≥ 1, such that −→α c matches exactly the path (v0,..., vn) for process π.
Let M = (7, V) be a model, such that V(p) is a singleton which the only element is vn, vn ∈ V(p). Then, we have a path (v0,..., vn) such that M, vn H p and −→α ∈ R (π) matches this path. By lemma 4.4, M, v0 H ⟨π⟩p.
As −→α c /∈ −R→c (τ ) and there is no −→β c ∈ −R→c (τ ) such that
−→β c ≺ −→α c, so as −→α c matches exactly the path (v0,..., vn), then (v0,..., vn) is not matched by any other sequence for process τ . Besides that, there is no other path (v0,..., vm), m ≥ 1, in M such that M, vm H p, because 7 is a tree. Thus, by lemma 4.4, M, v0 /H ⟨τ⟩p, which contradicts (1).	2
Corollary 4.6 π ∼ τ if and only if H ⟨π⟩p ↔ ⟨τ⟩p.

Proof. It follows directly from theorems 3.11 and 4.5.
2

Axiomatization
We use the standard boolean abbreviations ⊥, V, → and ↔ and the following abbreviations for the duals: [π]ϕ := ч⟨π⟩чϕ.
The axiomatization presented below is the standard PDL proof theory extended with a new axiom for non-deterministic choice.
Axioms
All tautologies,
[π](ϕ → ψ) → ([π]ϕ → [π]ψ),
[π1; π2]ϕ ↔ [π1][π2]ϕ,
⟨π1 + π2⟩p ↔ (⟨π1⟩p V ⟨π2⟩p) Λ (⟨π1⟩Т Λ ⟨π2⟩Т) , 
[π∗]ϕ ↔ ϕ Λ [π][π∗]ϕ,
[π∗](ϕ → [π]ϕ) → ([π]ϕ → [π∗]ϕ),
Inference Rules
M.P. ϕ, ϕ → ψ/ψ	U.G. ϕ/[π]ϕ	SUB. ϕ/σϕ
where σ is a map uniformly substituting formulas for propositional variables.
Axioms 1, 2, 3, 5 and 6 and the inference rules are standard in PDL for regular programs [5,16,4]. Axiom 4 deserves some explanation. It can be re-written as
⟨π1 + π2⟩p ↔ (⟨π1⟩p Λ ⟨π2⟩Т) V (⟨π1⟩Т Λ ⟨π2⟩p)
The intuitive meaning is ”whenever we perform a non-deterministic choice π1 + π2, we must be able to perform either π1 or π2, but both must be available for execution. This is what ⟨πi⟩Т (i = 1, 2) assures, i.e., it is possible to perform πi.
Example 4.7 M,w H ⟨(π1 + π2)⟩p and M,v /H ⟨(π1 + π2)⟩p

w	v
π1
zz	J 
p ◦	◦	p ◦

Soundness and Completeness
In order to prove soundness it is necessary to show both that every axiom is valid in this class of frames and the inference rules also preserve the validity. The validity of axioms 1, 2, 3, 5 and 6 and the inference rules are well-known from the PDL literature [5,16,4]. Below, we present the proof for axioms 4.
Lemma 4.8 The following formula is valid:
H ⟨π1 + π2⟩p ↔ (⟨π1⟩p V ⟨π2⟩p) Λ (⟨π1⟩Т Λ ⟨π2⟩Т) A proof of this lemma can be found in appendix C.

Theorem 4.9 (Soundness ): PDL+ is sound.
Theorem 4.10 (Completeness for Finite PDL+ Models): Propositional Dy- namic Logic PDL+ is complete with respect to the class of ﬁnite PDL+ models.
A proof of this theorem can be found in appendix D.

Decidability and Complexity
Section 4.3 proves that PDL+ is complete with respect to the classes of finite PDL+ models. Hence, it has have the finite model property, and moreover, that every consistent formula ψ can be satisfied ata state ofa model with at most 2|ψ|, where
|ψ| is the number of symbols of ψ. A naive decision procedure for the satisfiability problem of our logic could be: given a formula ψ, construct all Kripke models with at most 2|ψ| states, verify if they belong to the appropriate class, and test if ψ is satisfied at some state of them. There are approximately 22|ψ| such models. Therefore, this algorithm establishes a double exponential time upper bound for the satisfiability problem of our logic.
The satisfiability problem for PDL is EXPTIME-complete [5]. This yields an exponential time lower bound for the satisfiability problem of our logic.

Conclusion
This paper presents a new semantics to PDL based on finite runs with context, as far as we know this is a new semantics and opens up new possibilities not only for PDL but for other modal logics as well. We propose an axiomatization and prove its soundness, completeness and finite model property. The main result is equivalence between bisimilar programs and logically equivalent programs.
We proved completeness with respect to the class of finite PDL+ and the com- plexity should be the same as for PDL.
PDL+ opens up possibilities to investigate new variants of PDL where programs are process terms from some process algebra. In [3], a Dynamic Logic for CCS programs was presented, the main criticism of this logic was the lack of equivalence between bisimilar processes and logically equivalent programs. This problem is completely solved with our new semantics. In [3], we also present a logic that uses recursion in the place of iteration. But, in order to keep decidability, we had to restrict the use of recursive equations. In the present work, we use iteration and finite runs, dealing only with terminating programs. We would like to extend this work with recursion and investigate more expressive semantics.
Another possibility for future work would be to establish the precise complexity of the satisfability problem for PDL+. We already have the EXPTIME-hardness due to PDL. We suspect it is EXPTIME-complete, as PDL, but we would like to provide an EXPTIME algorithm for the satisfability problem.

References
J.A. Bergstra, A. Ponse and S.A. Smolka (editors), Handbook of Process Algebra, Elsevier, 2001.

R. J. van Glabbleek, The Linear Time - Branching Time Spectrum I: The Semantics of Concrete, Sequential Processes. In Handbook of Process Algebra (J.A. Bergstra, A. Ponse and S.A. Smolka, eds.), Chapter 1, pp. 3-99, Elsevier, 2001.

M. R. F. Benevides and L. M. Schechter. A propositional dynamic logic for CCS programs. In Proceedings of the XV Workshop on Logic, Language, Information and Computation, volume 5110 of LNAI, pages 83–97. Springer, 2008.

P. Blackburn, M. de Rijke, and Y. Venema. Modal Logic. Theoretical Tracts in Computer Science. Cambridge University Press, 2001.
D. Harel and D. Kozen and J. Tiuryn. Dynamic Logics. MIT Press, 2000.

M. Dam. On the decidability of process equivalences for the pi-calculus. Theoretical Computer Science, 183(2):215–228, 1997.

M. J. Fischer and R. E. Ladner. Propositional dynamic logic of regular programs. Journal of Computer and System Sciences, 18(2):194–211, 1979.

W. J. Fokkink. Introduction to Process Algebra. Texts in Theoretical Computer Science. Springer, 2000.
D. Harel and D. Raz. Deciding properties of nonregular programs. SIAM Journal on Computing, 22(4):857–874, 1993.
R. Milner. Communication and Concurrency. Prentice Hall, 1989.
R. Milner. Communicating and Mobile Systems: the π-Calculus. Cambridge University Press, 1999.

R. Milner, J. Parrow, and D. Walker. Modal logics for mobile processes. Theoretical Computer Science, 114(1):149–171, 1993.

D. Peleg. Communication in concurrent dynamic logic. Journal of Computer and System Sciences, 35(1):23–58, 1987.

D. Peleg. Concurrent dynamic logic. Journal of the Association for Computing Machinery, 34(2):450– 479, 1987.
C. Stirling. Modal and Temporal Properties of Processes. Texts in Computer Science. Springer, 2001.
R. Goldblatt. Logics of Time and Computation. CSLI Lecture Notes 7. Stanford, 1992.

Proof of lemmas 3.10
Proof. We prove by induction on the length n of —→α c.
n = 1, then —→α c = α{β1 ··· β1 }, for some action α. Then, π α  √ ⇔ π α √. By the hypothesis that

1	k1
⇒	→	√	√

π ∼ τ we have that {α, β1 ··· β1 } are the only actions π and τ can perform, and π α
τ α	. Finally,

τ α √

→−α c √
1	k1
→	⇔  →

→	⇔ τ ⇒	.	—→
I. H.: suppose that the lemma holds for all n < k. Let α c be a sequence of length k. Let α{β1 ··· β1 } be
the first action of the sequence and let —→γ c be a sequence of length k — 1 such that —→α c = α{β1 ··· β1 }.—→γ c.

→−α c √

′	α  ′

′ →−γ c √
1	k1
α  ′

Then, π ⇒	if and only if there is a process π such that π → π and π ⇒	. But if π → π and π ∼ τ,
then there is a process τ ′ such that τ α τ ′ and π′ ∼ τ ′. Moreover, as π ∼ τ, then {α, β1 ··· β1 } are the

→	—→
1	k1

′	′	′ →−γ c √
′ →−γ c √
→−α c √

hypothesis, as π ∼ τ and π ⇒
, then τ ⇒
. This means that τ ⇒	.	2

Proof of lemma 4.4
Proof. We prove by induction on the structure of π.
The base case is for | π |= 1, for atomic program it is straightforward. Suppose it holds for | π |≤ n, so we have three possibilties.
Suppose M,w H ⟨π∗⟩ϕ, iff iff there is v ∈ W s. t. wRπ∗ v and M,v H ϕ. But we know that Rπ∗ = R∗ .

Then we get we have a path wR v R ...R v. As R∗
π
is transitive wR v and M

iff  ,w H π ϕ. By the induction Hypothesis there is a finite path (v0, v1,..., vn), n  1, such that v0 = w, vn = v, M, vn H ϕ and there is —→α c ∈ —R→c (π) of length n such that —→α c matches the path (v0,..., vn). But by theorem 3.13 we know that —R→c (π) ⊆ (—R→c (π))∗ = —R→c (π∗)
The cases for π = π1 + π2 and π = π1; π2 are analogous to the previous case.
2
Proof of lemma 4.8
Proof.
( ) Suppose that, for some model  = ( , V) and some state w in this model, ,w H π1 + π2 p. Then, by lemma 4.4, matches π1 +π2 at w, there is a finite path (v0, v1,..., vn), n  1, such that v0 = w, M, vn H p and a sequence —→α c ∈ —R→c (π1 + π2) that matches this path.
Now, by the third equality in theorem 3.13, either —→α c ∈ —R→c (π1) |+π2 or —→α c ∈ —R→c (π2) |+π1 , It follows
f	f
directly from definition 3.12 that —→α c |−π2 ∈ —R→c (π1) or —→α c |−π1 ∈ —R→c (π2).
Besides, —→α c |−π2 and —→α c |−π1 match path (v0, v1,..., vn)., which implies that M,w H ⟨π1⟩p or
M,w H ⟨π2⟩p. Thus, M,w H ⟨π1⟩p ∨ ⟨π2⟩p (1).	—→
As F matches π1 + π2 at w, so F matches π1 and π2 at w. Then, there exist α—→1c ∈ Rc (π1) that
matches a path (w0, v1,..., wk) and α—→2c ∈ —R→c (π2) that matches a path (u0, v1,..., ul) and w = w0 = u0.
Which implies that M,w H ⟨π1⟩T and M,w H ⟨π2⟩T. Thus, M,w H ⟨π1⟩T ∧ ⟨π2⟩T (2).
From (1) and (2), we have
M,w H (⟨π1⟩p ∨ ⟨π2⟩p) ∧ (⟨π1⟩T ∧ ⟨π2⟩T)
(⇐) Suppose M,w H ⟨π1⟩p ∨ ⟨π2⟩p (1) and M,w H ⟨π1⟩T ∧ ⟨π2⟩T (2). From (2) we have that F matches π1 and π2 at w.
From (1) we have that M,w H ⟨π1⟩p (3) or M,w H ⟨π2⟩p (4).
(3) implies that	matches π1 at w and there is a finite path (v0, v1,..., vn), n	1, such that v0 = w,
M, vn H p and a sequence α—→1c ∈ —R→c (π1) that matches this path.
As α—→1c ∈ —R→c (π1), so α—→1c |+π2 ∈ —R→c (π1) |+π2 ⊆ —R→c (π1) |+π2 ∪—R→c (π2) |+π1 = —R→c (π1 + π2) (Using
theorem 3.13(3.)). Hence, α—→1c |+π2 ∈ —R→c (π1 + π2).
From (2), we have that α—→1c |+π2 matches path (v0, v1,..., vn). Thus,
M,w H ⟨π1 + π2⟩p.
Analogously, from (4) we also obtain M,w H ⟨π1 + π2⟩p.

Completeness Proof for PDL+
The canonical model construction is the standard one used for PDL [5,4,16].
Definition D.1 (Fischer and Ladner Closure): Let Γ be a set of formulas. The closure of Γ, notation
CFL(Γ), is the smallest set of formulas satisfying the following conditions:
CFL(Γ) is closed under subformulas,
if ⟨π∗⟩ϕ ∈ CFL(Γ), then ⟨π⟩⟨π∗⟩ϕ ∈ CFL(Γ),
if ⟨π1; π2⟩ϕ ∈ CFL(Γ), then ⟨π1⟩⟨π2⟩ϕ ∈ CFL(Γ),
if ⟨π1 ∪ π2⟩ϕ ∈ CFL(Γ), then ⟨π1⟩ϕ ∨ ⟨π2⟩ϕ ∈ CFL(Γ),
if ⟨π1 ∪ π2⟩ϕ ∈ CFL(Γ), then ⟨π1⟩T and ⟨π2⟩T ∈ CFL(Γ),
if ϕ ∈ CFL(Γ) and ϕ is not of the form ¬ψ, then ¬ϕ ∈ CFL(Γ).
The proof that if Γ is a finite set of formulas, then the closure CFL(Γ) of Γ is also finite. We assume Γ to be finite from now on.
Definition D.2 Let Γ be a set of formulas. A set of formulas	is said to be an atom of Γ if it is a maximal consistent subset of CFL(Γ). The set of all atoms of Γ is denoted by At(Γ).

Lemma D.3 Let Γ be a set of formulas. If ϕ ∈ CFL(Γ) and ϕ is consistent then there exists an atom
A∈ At(Γ) such that ϕ ∈ A.
Proof. We can construct the atom A as follows. First, we enumerate the elements oVf CFL(Γ)Vas φ1, ··· , φn.
WVe start the construction making A1 = {ϕ}, then for 1 < i < n, we know that ▶	Ai ↔ (  Ai ∧ φi+1) ∨
( Ai ∧ ¬φi+1) is a tautology and therefore either Ai ∧ φi+1 or Ai ∧ ¬φi+1 is consistent. We take Ai+1 as
the union of Ai with the consistent member of the previous disjunction. At the end, we make A = An.

Definition D.4 Let Γ be a set of formulas. The canonical relations over Γ SΓ on At(Γ) are defined as
follows:
ASΓB iff	A∧ ⟨π⟩	B is consistent.
Definition D.5 Let Γ be a set of formulas.  The canonical model over Γ is a tuple MΓ =< At(Γ),SΓ, VΓ >, where for all propositional symbols p and for all atoms A∈ At(Γ) we have
VΓ(p)= {A ∈ At(Γ) | p ∈ A} is called canonical valuation;
SΓ and SΓ+ are the canonical relations. 3
π	π
Lemma D.6 Let A∈ At(Γ). Then, for all basic programs α,
⟨α⟩ϕ ∈A iff there exists B ∈ At(Γ) such that ASαB and ϕ ∈ B.
Proof.
⇒: Suppose ⟨α⟩ϕ ∈ A. By definition D.2, we haVve that	A∧ ⟨α⟩ϕ is consistent. VUsing the tautology
▶ ϕ ↔ ((ϕ ∧ φ) ∨ (ϕ ∧ ¬φ)), we have that either	A∧ ⟨α⟩(ϕ ∧ φ) is consistent or	A∧ ⟨α⟩(ϕ ∧ ¬φ) is
consistent. So, bVy the appropriVate choice of φ, for all formulas φ ∈ CFL, we can construct an atom B such
that ϕ ∈B and	A∧ ⟨α⟩(ϕ ∧	B) is consistent and by deVfinition DV.4 ASαB.	V
⇐: Suppose there is B such that ϕ ∈B and ASαB. Then	A∧ ⟨α⟩ B is consistent and also	A∧ ⟨α⟩ϕ
is consistent. But ⟨α⟩ϕ ∈ CFL and by maximality ⟨α⟩ϕ ∈ A.

Lemma D.7 Let A, B ∈ At(Γ). Then if ASπ∗B then AS∗ B.
Proof. Suppose ASπ∗B. Let C = {C ∈ At(Γ) | ASπ ∗C}. We want to show that B ∈ C. Let C∧ =
(V C1 ∨ ··· ∨	C ).
∨
n
It is not difficult to see that C∧ ∧ ⟨π⟩¬C∧ is inconsistent, otherwise for some D not reachable from

A, C∧ ∧ ⟨π⟩ V D
∨	∨	C , V C
∧ ⟨π⟩ V D was also consistent, which would

∨	would be consistent, and for some i	i	V	∧
mean that D ∈ C, whichVis not the case. From a similar reasoning we know that	A∧ ⟨π⟩¬C∨ is also
As C∧ ∧ ⟨π⟩¬C∧ is inconsistent, so its negation is a theorem ▶ ¬(C∧ ∧ ⟨π⟩¬C∧) and also ▶ (C∧ →
[π]C∧) (1), applying generalization ▶ [π∗](C∧ → [π]C∧). Using Segerberg axiom (axiom 6), we have

∨
▶	∧	∗  ∧
∨  ∧	∨	∧	V	∧

V([π]C∨ → [π ]C∨) and by (1) wVe obtain ▶V(C∨ → [π∗]C∨). As ▶ VA → [π]C∨ is a theorem, then
▶	A→ [π∗]C∧. By supposition,	A∧ ⟨π∗⟩  B is consistent and so is	B∧ C∧. Therefore, for at least

∨
one C ∈ 
V B∧ V C is consistent. By maximality, we have that B
∨
. And by the definition

C, we know that	=
∧
of C∨, we have ASπ∗B.

Definition D.8 Let Γ be a set of formulas. The PDL+ model over Γ is a tuple M =< At(Γ), Rπ , V >, where for all propositional symbols p and for all atoms A∈ At(Γ) we have
V(p)=	At(Γ) p	;
Rα = Sα, for all basic programs α
Rπ is inductively defined as in definition 4.1.
Lemma D.9 Sπ ⊆ Rπ.
Proof. Induction on the straucture of π.
Base case is straightforward as Rα = Sα, for basic programs α.
Suppose it holds for programs π such that | π |≤ n. We only prove the case where π = π1 + π2. The
case for π = π1; π2 and π∗ arVe standard in PDVL literature.	V	V

SVuppose ASπ1 +π2 B, iff	A∧ ⟨π1 + π2⟩ B) is consistent. By axiom 4.	A∧ ((⟨π1⟩
B∧ ⟨π2⟩T) ∨

(⟨π2⟩V B∧ ⟨π1⟩TV)) is consistent. Either
A ∧V((⟨π1⟩  B∧ ⟨π2⟩T) is consistent (1) or
(⟨π2⟩  B V∧ ⟨π1⟩T)) is consistent (2).
From (1)	A∧ ((⟨π1⟩ V B) is consistent (3) and
V A∧ (⟨π2⟩T) is consistent (4)
From (3 and (4) we get ASπ1 B and there exists an atom C s.t. ASπ1 C. By the Induction Hypothesis
ARπ1 B and there exists C s.t. ARπ1 C (5).

3 For the sake of clarity we avoid using the Γ subscripts

Analogously, from (2) we can obtain
ARπ1 B and there exists C s.t. ARπ1 C, which together with (5) allows us to conclude ARπ1 +π2 B.

Lemma D.10 Exixtence Lemma: Let A∈ At(Γ). Then,
⟨π⟩ϕ ∈A iff there exists B ∈ At(Γ) such that ARπ B and ϕ ∈ B.
Proof.
: This direction follows is analogous to the one presented for basic programs in lemma D.6 and the previous lemma that states that Sπ	Rπ .
: Induction on the straucture of π.
Base case is straightforward from lemma D.6, for basic programs α.
Suppose it holds for programs π such that π	n. We only prove the case where π = π1 + π2. The case for π = π1; π2 and π∗ are standard in PDL literature.
Suppose ARπ1 +π2 B (1) and ϕ ∈B (2). That means that either
ARπ1 B and there exists C s.t. ARπ2 C (3) or
ARπ2 B and there exists C s.t. ARπ1 C (4)
From (2), (3 and (4) and the Induction Hypothesis we have that either
⟨π1⟩ϕ ∈A and ⟨π2⟩T ∈ A (5) or ⟨π2⟩ϕ ∈A and ⟨π1⟩T ∈ A (6)
By (5) and (6) and axiom 4., we have that	A ∧ ⟨π1 + π2⟩ϕ is consistent. And by maximality
⟨π1 + π2⟩ϕ ∈A 
2
Lemma D.11 Truth Lemma: Let M = (W, Sπ , V) be a finite canonical model for φ. For all atoms A
and all ϕ ∈ CFL(φ), M, A |= ϕ iff ϕ ∈ A.
Proof. : The proof is by induction on the construction of ϕ.
Atomic formulas and Boolean operators: the proof is straightforward from the definition of V.
Modality ⟨x⟩, for x ∈ {α, π1; π2, π1 + π2, π∗}.
⇒: Suppose M, A |= ⟨x⟩ϕ, then there exists A′ such that ASxA′ and
M, A′ |= A. By the induction hypothesis we know that ϕ ∈ A′, and by lemma D.10 we have ⟨x⟩ϕ ∈ A.
⇐: Suppose M, A |= ⟨x⟩ϕ, by the definition of satisfaction we have
M, A |= ¬⟨x⟩ϕ. Then for all A′, ASxA′ implies M, A′ /|= ϕ. By the induction hypothesis we know that
ϕ /∈ A′, and by lemma D.10 we have ⟨x⟩ϕ /∈ A.
2
Theorem D.12 (Completeness for Finite PDL+ Models): Propositional Dynamic Logic PDL+ is complete with respect to the class of finite PDL+ models.
Proof. For every consistent formula ϕ we can build a canonical finite PDL+ model Mϕ. By lemma D.3, there exist an atom  At(ϕ) such that ϕ  , and by the truth lemma D.11  ,  = ϕ. Therefore, our modal system is complete with respect to the class of finite PDL+ models.
2
