	Electronic Notes in Theoretical Computer Science 202 (2008) 121–135	
www.elsevier.com/locate/entcs

On the Complexity of Convex Hulls of Subsets of the Two-Dimensional Plane
Ker-I Koa,1 ,2	Fuxiang Yua,1 ,3
a Department of Computer Science, Stony Brook University, Stony Brook, NY 11794, USA

Abstract
We investigate the computational complexity of computing the convex hull of a two-dimensional set. We study this problem in the polynomial-time complexity theory of real functions based on the oracle Turing machine model. We show that the convex hull of a two-dimensional Jordan domain S is not necessarily recursively recognizable even if S is polynomial-time recognizable. On the other hand, if the boundary of a Jordan domain S is polynomial-time computable, then the convex hull of S must be NP-recognizable, and it is not necessarily polynomial-time recognizable if P =/ NP . We also show that the area of the convex hull of a Jordan domain S with a polynomial-time computable boundary can be computed in polynomial time relative to an oracle function in #P . On the other hand, whether the area itself is a #P real number depends on the open question of whether NP = UP .
Keywords: Convex hulls, two-dimensional set, computational complexity, polynomial time, NP.


Introduction
The convex hull of a set S of the two-dimensional plane is the smallest convex set CH(S) that contains S. It is a fundamental concept in mathematics and in computational geometry. For polygons and sets of finite points, there are a number of efficient algorithms to compute their convex hulls (see, for instance, O’Rourke [14] and de Berg et al. [7]). In general, however, no efficient algorithms are known to work for all subsets of the two-dimensional plane. In fact, for some set S, its convex hull could be very complicated and defies a simple algorithm.
In this paper, we study the complexity of computing the convex hull of a given set S ⊆ R2. In particular, we study two problems about the convex hull CH(S) of a polynomial-time computable set S ⊆ R2:

1 This material is based upon work supported by National Science Foundation under grant No. 0430124.
2 Email: keriko@cs.sunysb.edu
3 Email: fuxiang@cs.sunysb.edu

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.012

Membership Problem: For a polynomial-time computable set S and a given point z, determine whether z is inside CH(S).

Area
Problem: For a polynomial-time computable set S, compute the two-

dimensional measure of the convex hull of S.
There are a number of different formulations of the notion of polynomial-time computable sets in the two-dimensional plane. In this paper, we will use three notions introduced in Chou and Ko [3]: polynomial-time computable Jordan do- mains (i.e., sets whose boundaries are polynomial-time computable Jordan curves), polynomial-time recognizable sets, and strongly polynomial-time recognizable sets. Our main results can be summarized as follows:
There exists a Jordan domain S ⊆ R2 which is polynomial-time recognizable such that its convex hull is not even recursively recognizable.
If a set S ⊆ R2 is a Jordan domain and its boundary is polynomial-time computable, or if S is strongly polynomial-time recognizable, then its convex hull CH(S) is strongly nondeterministic polynomial-time recognizable.
If P /= NP , then there exists a Jordan domain S ⊆ R2 whose boundary is polynomial-time computable such that its convex hull CH(S) is not polynomial- time recognizable.
If a set S ⊆ R2 is a Jordan domain and its boundary is polynomial-time computable, or if S is strongly polynomial-time recognizable, then the area of its convex hull CH(S) is computable in polynomial-time with the help of an oracle function in #P .
If F P1 /= #P1, then there exists a Jordan domain S ⊆ R2 whose boundary is polynomial-time computable such that the area of its convex hull CH(S) is not a polynomial-time computable real number. 4
Our basic computational model for real-valued functions and two-dimensional sets is the oracle Turing machine. For the general theory of computable analysis based on the Turing machine model, see, for instance, Pour-El and Richards [15] and Weihrauch [21]. For the theory of computational complexity of real functions based on this computational model, see Ko [12]. Chou and Ko [3] extended this theory to the study of computational complexity of two-dimensional sets. Computational complexity of problems related to two-dimensional sets has recently been studied in several directions. Rettinger and Weihrauch [17], Rettinger [16], Braverman [1], and Braverman and Yampolsky [2] studied the the computational complexity of Julia sets. Chou and Ko [4] studied the problem of finding paths in a two-dimensional domain. Ko and Yu [13] studied the problem of computing single-valued analytic branches of logarithm and square-root functions on a two-dimensional domain. All these works used Turing machines and oracle Turing machines as the basic model.




4 FP1 and #P1 are functions in FP and #P , respectively, whose inputs are strings from a singleton alphabet.

Definitions and Notation
Discrete complexity classes
In this paper, we will work on both discrete and continuous objects. The basic objects in discrete complexity theory are binary strings w ∈ {0, 1}∗. We write l(w) to denote the length of a string w (and reserve the notation |x| for the absolute value of a real or complex number x).
The fundamental discrete complexity classes we are interested in are the class P of sets accepted by deterministic polynomial-time Turing machines (TMs), and the corresponding function class FP of functions computable by deterministic polynomial-time TMs. In addition to these classes, we are also interested, in this paper, in the following complexity classes (see, e.g., Du and Ko [9] for the formal definitions):
NP : Sets that are accepted by nondeterministic polynomial-time TMs.
UP : Sets that are accepted by nondeterministic polynomial-time TMs that have, on any input, at most one accepting computation.
#P : Functions that compute the number of accepting computations of a nonde- terministic polynomial-time TMs.
P #P : Sets that are accepted by deterministic polynomial-time oracle TMs with the help of an oracle function f ∈ #P (we also write P #P [1] for the sets for which the oracle function f ∈ #P is asked at most once during the computation).
FP #P : Functions that are computable by deterministic polynomial-time oracle TMs with the help of an oracle function f ∈ #P
The classes NP , UP and #P have nice characterizations in terms of class P . In the following, we let A  denote the size of a finite set A.
Proposition 2.1 (a) A set A ⊆ {0, 1}∗ is in NP if and only if there exist a set
B ∈ P and a polynomial function p such that, for any w ∈ {0, 1}∗,
w ∈ A ⇐⇒ (∃u, l(u)= p(l(w))) ⟨w, u⟩ ∈ B.
A set A ⊆ {0, 1}∗ is in UP if and only if there exist a set B ∈ P and a polynomial function p such that, for any w ∈ {0, 1}∗,

w ∈ A ⇐⇒ (∃u, l(u)= p(l(w))) ⟨w, u⟩ ∈ B
⇐⇒ (∃ a unique u, l(u)= p(l(w))) ⟨w, u⟩ ∈ B.

A function φ : {0, 1}∗→N is in #P if and only if there exist a set B ∈ P and a polynomial function p such that, for any w ∈ {0, 1}∗,
φ(w)= {u ∈ {0, 1}∗ : l(u)= p(l(w)), ⟨w, u⟩ ∈ B}.
It is known that P ⊆ UP ⊆ NP ⊆ P #P and FP ⊆ #P ⊆ FP #P . Whether any

of these inclusive relations is proper is not known and is a major open question in complexity theory.
For any of the above function classes C, we write C1 to denote the class of functions φ : {0}∗→N that are in C. These classes also satisfy the relation F P1 ⊆ #P1 ⊆ FP #P , and whether any of the relations is a proper inclusion is also open.

Complexity of real functions and two-dimensional sets
The basic objects in the Turing machine-based continuous computation are dyadic rationals D = {m/2n : m ∈ Z,n ∈ N}. Each dyadic rational d has infinitely many binary representations, with arbitrarily many trailing zeros. For each n ∈ N, we let Dn denote the class of dyadic rationals which have a binary representation of at most n bits to the right of the binary point; that is, Dn = {m/2n : m ∈ Z}.
A real number has a few basic representations. The most basic one is the Cauchy
function representation. We say a function φ : N→D binary converges to a real number x, or is a Cauchy function representation of x, if (i) for all n ≥ 0, φ(n) ∈ Dn, and (ii) for all n ≥ 0, |x − φ(n)| ≤ 2−n. A real number x may have many Cauchy function representations. However, there is a unique function φx : N→D that binary converges to x and satisfies the condition x − 2−n < φx(n) ≤ x for all n ≥ 0. We call this function φx the standard Cauchy function for x. We say a real number x is computable if it has a computable Cauchy function representation. A real number x is polynomial-time computable (or, simply, P-computable) if it has a Cauchy function representation φ : {0}∗→D in FP . 5 We write P R to denote the set of all P - computable real numbers. Similarly, we write #P R (or, P #P ) to denote the set of real numbers which have a Cauchy function representation φ : {0}∗→D such that the function φ'(0n) = φ(0n) · 2n is in #P (or, respectively, in FP #P ). We note that the relation between P R and #P R depends on that between F P1 and #P1: F P1 = #P1 if and only if P R = #P R (see Theorem 5.32 of Ko [12]).
To compute a real-valued function f : R→R, we use oracle TMs as the com- putational model. We say an oracle TM M computes a function f : R→R if, for a given oracle φ that binary converges to a real number x and for a given input n > 0, Mφ(n) halts and outputs a dyadic rational e such that |e − f (x)| ≤ 2−n. We say a function f : R→R is polynomial-time computable (or, simply, P-computable) if there exists a polynomial-time oracle TM that computes f .
We write z, Z or ⟨x, y⟩, where x, y ∈ R, to denote a point in the two-dimensional plane R2. For any two points z1 = ⟨x1, y1⟩ and z2 = ⟨x2, y2⟩ in R2, we write |z1 −z2| to denote the distance	(x1 − y1)2 + (x2 − y2)2 between them. For any point x ∈ R2 and a closed set A ⊆ R2, we write dist(x, A)= dist(A, x)= min{|x−y| : y ∈ A}.
The notions of computable and polynomial-time computable real functions can
be extended naturally to functions f : R→R2 and functions f : R2→R2. In par- ticular, we say a Jordan curve (simple, closed curve) Γ in R2 is polynomial-time computable if there exists a P -computable function f : [0, 1]→R2 such that the range of f is Γ, f is one-to-one on [0, 1) and f (0) = f (1). For any set S ⊆ R2, let

5 Note that the input integers n to φ are written in the form of the unary representation 0n.

∂S denote the boundary of S, i.e., the set of all points z ∈ R2 such that any neigh- borhood N (z; ϵ) of z contains points in S and points not in S. We say a bounded open set S ⊆ R2 is a Jordan domain if its boundary ∂S is a Jordan curve, and say it is P-computable if ∂S is a P -computable Jordan curve.
For any set S ⊆ R2, let χS denote the characteristic function of S; i.e., χS(x)= 1 if x ∈ S, and χS(x) = 0 otherwise. Intuitively, S is computable (or, polynomial- time computable) if the function χS is computable (or, respectively, polynomial- time computable). Since χS is discontinuous at the points on ∂S, the definition based on this concept is too strict. That is, suppose that we define a set S to be computable if there is an oracle TM computing χS; then, only two trivial sets, R2 and ∅, are polynomial-time computable. Chou and Ko [3] considered two ways to relax the computability requirements of this concept, and defined the notions of polynomial-time approximable and polynomial-time recognizable sets.
A set S ⊆ R2 is called polynomial-time recognizable (or, simply, P-recognizable) if there exists a polynomial-time oracle TM M that, when given two oracles φ1, φ2 and an input n > 0 (written in its unary representation 0n), computes χS(z) whenever
⟨φ1, φ2⟩ represents a point z in R2 having a distance greater than 2−n from the boundary ∂S; i.e, the error set
EM (n)= {z ∈ R2 | (∃⟨φ1, φ2⟩ representing z) Mφ1 ,φ2 (n) /= χS(z)}   (1) of M on input n is a subset of {z ∈ R2 | dist(z, ∂S) ≤ 2−n}.
A set S ⊆ R2 is called strongly recursively recognizable, (or, Strongly P-
recognizable) if it is recursively recognizable (or, respectively, P-recognizable) by an oracle TM M such that the error set EM (n) is also contained in R2 − S (i.e., errors only occur when the oracles representing a point outside S, and has distance
≤ 2−n from the boundary).
A set S ⊆ R2 is called polynomial-time approximable (or, simply, P- approximable) if there exists a polynomial-time oracle TM M that, when given two oracles φ1, φ2 representing a point z ∈ R, and an input 0n, computes χS(z) with possible errors such that the Lebesgue measure of the error set EM (n), defined in (1) above, is bounded by 2−n.
For any set S ⊆ R2, we let CH(S) be the convex hull of S; that is,
3	3
CH(S)= {z ∈ R2 | (∃z1, z2, z3 ∈ S) (∃r1, r2, r3 ∈ [0, 1]) Σ ri = 1, z = Σ rizi}.


Convex hull of a P -recognizable set
i=1
i=1

P -recognizability is the most general concept of polynomial-time computability for two-dimensional sets, but some of the important properties of a set are not re- tained in this formulation. For instance, Chou and Ko [6] pointed out that the distance function δS(z)= dist(z, ∂S) is not necessarily computable even if S is P - recognizable. It is not hard to see that this is also true for the notion of convex hulls. As a simple example, suppose S consists of four corners of a square [0, x] × [0, x]

where x is a noncomputable real number. Then, S is P -recognizable since all its points are on the boundary ∂S and so a trivial oracle TM M that always outputs 0 computes χS correctly for all points away from the boundary. On the other hand, we note that CH(S) is exactly the square R = [0, x] × [0, x]. It is not hard to see that R is recursively recognizable if and only if x is a computable real number.
In the following, we show that, even if S is a Jordan domain and is P - recognizable, its convex hull CH(S) is not necessarily recursively recognizable.
Theorem 3.1 There exists a P-recognizable Jordan domain S of which the convex hull CH(S) is not recursively recognizable.
Proof. Let K ⊆ N be an r.e., nonrecursive set of integers. Then, there exists a TM MK that enumerates the integers in K. That is, MK prints, on input 0, integers on its output tape one by one such that (i) it prints only integers in K, and (ii) every integer in K is eventually printed. For n ∈ K, let t(n) be the number of moves MK takes to print integer n on input 0. Without loss of generality, we assume that t(n) ≥ 2n + 1.
Let O denote the origin ⟨0, 0⟩ of R2 and C denote the unit circle, i.e., the circle with center O and radius 1. For any n > 0, let an = 1/4 − 2−(n+1), Zn = ⟨ cos(2πan), sin(2πan)⟩, and Cn be the chord of C connecting the points Zn and Zn+1.
We now define a function f : [0, 1]→R2 whose image is a Jordan curve Γ. On [1/4, 1], the image of f is the circle C on the second, third, and fourth quadrants; i.e., f (t) = ⟨ cos(2tπ), sin(2tπ)⟩, for t ∈ [1/4, 1]. Next, for each n > 0, if n /∈ K, then f is linear on [an, an+1], with f (an) = Zn and f (an+1) = Zn+1; i.e., f maps [an, an+1] linearly to the chord Cn. If n > 0 and n ∈ K, then f maps [an, an+1] to the chord Cn with a bump in the middle, where the bump has width 2−t(n) and height

hn = 1 − cos(2−(n+2)π). To be more precise, let X'
be the middle point of the chord
−−→

Cn, and Xn the intersection point of the circle C and the halfline OX. Define Pn

and Qn to be the two points on Cn with distance 2−t(n)−1 from X'
(with Pn closer

to Zn and Qn closer to Zn+1). 6 The function f is piecewise linear on [an, an+1] with f (an) = Zn, f ((an + an+1)/2 − 2−t(n)−n−3) = Pn, f ((an + an+1)/2 = Xn, f ((an + an+1)/2+ 2−t(n)−n−3) = Qn, and f (an+1) = Zn+1. (Figure 1 shows the curve Γ between Zn and Zn+1.) This completes the definition of function f . Note that f is a continuous function but is not computable.
Let S be the interior of the Jordan curve Γ. We claim that S is P -recognizable. First, it is easy to see that the set S0 that is enclosed by the curve f [1/4, 1] plus all chords Cn, for n > 0, is P -recognizable. Next let Bk be the area enclosed by the chord Cn and the circle C from Zn to Zn+1, and let Sk = S ∩ Bk. If k /∈ K, then Sk = ∅; and if k ∈ K, then Sk is a small bump of width 2−t(n) and height hn. Now, consider the following algorithm for the membership problem of S:
Oracles: ⟨φ1, φ2⟩ representing a point z ∈ R2.
Input: n > 0.

6 Note that t(n) ≥ 2n + 1 implies that 2−t(n)−1 ≤ 2−2n−2, and the distance between Zn and X' is
sin(2−n−2π) > 2−n−2. Therefore, Pn and Qn are between Zn and Zn+1.

Z n +1
















Zn




to O
Fig. 1. The curve ∂S between Zn and Zn+1
Ask the oracles to get a dyadic point w ∈ D2


with |w − z| < 2−(n+1).

If w ∈ S0, then answer yes;
Else if w /∈ Bk for any k ≤ n, then answer no;
Else if w ∈ Bk for some k ≤ n, then simulate TM MK for n moves, and answer yes if and only if MK prints k within n moves and w ∈ Sk.
To see that the above algorithm solves the membership problem of S correctly, assume that z is a point in R2 with dist(z, Γ) > 2−n. Then, if z ∈ S0 or if z lies outside C, then the answer given by the algorithm is correct. Next, suppose z ∈ Bk for some k > 0. If k /∈ K, or if k ∈ K and t(k) ≤ n, then again the answer is correct. Finally, suppose z ∈ Bk with k ∈ K and t(k) > n. Then, Sk is a small bump of width 2−t(k) < 2−n, and so all points in Sk have distance at most 2−(n+1) from the boundary Γ. Thus, the answer no is correct for z if it has distance > 2−n from Γ.
Next, we verify that this algorithm works in polynomial time. It is apparent that steps (1)—(3) and the first half of step (4) can be done in time polynomial in
n. For the second half of step (4), we note that if t(k) > n, then we can simulate Mk for n steps and answer no. Otherwise, if t(k) ≤ n, then we can calculate t(k) in O(n) moves, and compute points Xn, Pn, Qn correctly within error 2−(n+1) in time polynomial in n. From these points, we can then determine whether w ∈ Sk if w has distance > 2−(n+1) from the line segments PnXn, XnQn. This completes the proof that S is P -recognizable.
Now, let us consider the convex hull CH(S) of set S. For each n > 0, let Tn = CH(S) ∩ Bn. Note that the curve Γ lies completely within C and it includes all points Zn. Therefore, Tn depends only on the curve Γ between Zn and Zn+1.

That is, for n /∈ K, Tn = ∅; and for n ∈ K, Tn is equal to ΔZnXnZn+1, the triangle with the vertices Zn, Xn and Zn+1. Now, suppose that CH(S) is recursively recognizable. Then, we can determine whether n ∈ K as follows:

Let Yn be the middle point in X' Xn, and determine whether Yn is inside CH(S) with error ≤ 2−2n−6. Answer n ∈ K if and only if Yn ∈ CH(S).
Note that hn  = 1 − cos(2−(n+2)π) ≥ 2−2n−4, and the length of Cn is 2 sin(2−(n+2)π) ≥ 2−n−2. 7 Now, it is not hard to see that the distance between Yn and the boundary of CH(S) is greater than hn/4, no matter whether n ∈ K (or, equivalently, whether Yn ∈ CH(S)). Thus, the above algorithm determines whether n ∈ K correctly. This is a contradiction to the assumption that K is not a recursive set.  HH

Convex hull of a P -computable Jordan domain
In this section, we consider the complexity of convex hulls of P -computable Jordan domains. In order to characterize the complexity of convex hulls, we need to extend the notion of P -recognizable sets to NP -recognizable sets.
Definition 4.1 (a) A set T ⊆ R2 is NP-recognizable if there exists a polynomial- time nondeterministic oracle TM M such that, on oracles ⟨φ1, φ2⟩ representing a point z ∈ R2, and on input n > 0,
For z ∈ T with dist(z, ∂T ) > 2−n, Mφ1,φ2 (n) contains at least one accepting path, and
For z /∈ T with dist(z, ∂T ) > 2−n, Mφ1,φ2 (n) has no accepting paths.
A set T ⊆ R2 is strongly NP-recognizable if it is NP -recognizable and the nondeterministic oracle TM M also satisfies the following stronger condition
(i') For all z ∈ T , Mφ1,φ2 (n) contains at least one accepting path.
Theorem 4.2 Assume that S ⊆ [0, 1]2 is a Jordan domain whose boundary ∂S is
P-computable. Then, its convex hull CH(S) is strongly NP-recognizable.
Proof. Let Scl denote the closure of S; i.e., Scl = S ∪ ∂S. We note that, as S is a Jordan domain, CH(Scl) = CH(S) ∪ CH(S)cl. Since the notion of P - and NP -recognizable sets allows the machine to have errors near the boundary of the set, CH(S) and CH(Scl) have the same complexity as far as we are only concerned with these complexity notions. So, in the following, we will work directly with the convex hull CH(Scl) of the closed set Scl.
We note that a point z belongs to CH(Scl) if and only if there exist three points on the boundary ∂S such that z lies in the triangle D formed by these three points. The following algorithm for the membership problem of CH(S) is based on this idea.

7 By the Taylor expansion of the functions cos and sin, we know that for small t, 1 − cos t ≥ t2/2 − t4/24 ≥
t2/4, and 2 sin t ≥ 2(t − t3/6) ≥ t.

Assume that the function f : [0, 1]→R2 represents the boundary ∂S, and that f
is computable in time p(n) for some polynomial p.
Oracles: ⟨φ1, φ2⟩ representing a point z ∈ R2.
Input: n > 0.
Ask oracles ⟨φ1, φ2⟩ to get a dyadic point w ∈ Dn+32 such that |w−z|≤ 
2−(n+2).
Nondeterministically guess three dyadic numbers d1, d2, d3 ∈ Dp(n+3).
Compute three dyadic points x1, x2, x3 ∈ Dn+42 such that |xi −f (di)| ≤ 
2−(n+3) for i = 1, 2, 3.
Let D be the triangle whose three vertices are x1, x2 and x3. Accept z
if w is inside D or has distance ≤ 2−(n+1) from the boundary ∂D of D.
It is clear that the above algorithm works in polynomial time. To see that the above algorithm strongly recognizes CH(Scl), we first assume that z ∈ CH(Scl). Then, there must be three numbers t1, t2, t3 ∈ [0, 1] such that z lies in the triangle D0 formed by three vertices f (t1),f (t2) and f (t3).
Suppose that, for each i = 1, 2, 3, we have a dyadic number di ∈ Dp(n+4) and
dyadic point xi ∈ Dn+42 such that |di − ti| ≤ 2−p(n+3), and |xi − f (di)| ≤ 2−(n+3). Then, |xi − f (ti)| ≤ 2−(n+2). Let D be the triangle with x1, x2, x3 as the three vertices. Then, the Hausdorff distance between D0 and D is ≤ 2−(n+2). Therefore, z either lies inside D or has distance ≤ 2−(n+2) from ∂Q. It follows that w either lies inside D or has distance ≤ 2−(n+1) from ∂Q. Therefore, the computation path of the algorithm that guesses the numbers d1, d2, d3 will accept z.
Conversely, assume that the above algorithm accepts z, with the guesses d1, d2, d3 ∈ Dp(n+3). Then, the algorithm found a triangle D such that w is ei- ther inside D or has distance ≤ 2−(n+1) from ∂D. Let D1 be the triangle with the three vertices f (d1),f (d2) and f (d3). Then, the Hausdorff distance between D and D1 is ≤ 2−(n+3). It follows that w is either inside D1 or within distance 2−(n+1) + 2−(n+3) from ∂D1. Since |w − z| ≤ 2−(n+2), and since D1 ⊆ CH(Scl), the point z is either inside CH(Scl) or within distance 2−n from the boundary of CH(Scl). This shows that the acceptance of the algorithm is correct.  HH
Corollary 4.3 Assume that S ⊆ [0, 1]2 is strongly P-recognizable. Then, its convex hull CH(S) is strongly NP-recognizable.
Proof. Assume that an oracle TM M strongly P -recognizes S in time p(n). We modify the algorithm of Theorem 4.2 by replacing steps (2) and (3) with
(2') Guess three points x1, x2, x3 ∈ D2	, and verify that M xi (n + 3) = 1 for
i = 1, 2, 3,
where M xi (n) denotes the computation of M on input n with the standard Cauchy functions of xi as the oracles. Then, this new nondeterministic oracle TM strongly accepts CH(Sc).  HH

Next, we show that the result of strong NP -recognizability of the convex hulls

cannot be improved to P -recognizability, unless P = NP .
Lemma 4.4 For any set A ∈ NP, there exist a P-computable Jordan domain S,a P-computable (discrete) function g : {0, 1}∗→D, and a polynomial function q, such that, for any w ∈ {0, 1}∗,
The distance between g(w) and the boundary of CH(S) is at least 2−q(l(w)), and
w ∈ A if and only if g(w) ∈ CH(S).
Proof. Let A ∈ NP . From Proposition 2.1(a), there exist a polynomial function p
and a set B ∈ P such that, for all w ∈ {0, 1}∗,
w ∈ A ⇐⇒ (∃u, l(u)= p(l(w)))⟨w, u⟩ ∈ B.
For any w ∈ {0, 1}∗, we let iw be the integer between 0 and 2l(w) − 1 whose l(w)- bit binary representation (with possible leading zeroes) is equal to w. Also let w' denote the successor of w in the lexicographic ordering. Now, suppose l(w)= n > 0, we define a dyadic rational number in [0, 1/4]: xw = (1 − 2−(n−1) + iw · 2−2n)/4, and an interval: Iw = [xw, xw' ]. Note that Iw has length 2−2l(w)−2.
Next, for each u ∈ {0, 1}p(n), we define two dyadic rationals and two subintervals of Iw as follows:
xw,u = xw + 2−2n−4 + iu · 2−p(n)−2n−4,

'
w,u
= xw + 2−2n−3 + iu · 2−p(n)−2n−4 = xw,u + 2−2n−4,

Iw,u = [xw,u, xw,u + 2−p(n)−2n−4],

'
w,u
'
w,u
'
w,u
+ 2−p(n)−2n−4].

Now, we describe the boundary ∂S of the desired Jordan domain S. Let O be the origin, and C the unit circle with center O and radius 1. For each w ∈ {0, 1}∗ of length n, let Zw = ⟨ cos(2πxw), sin(2πxw)⟩, and Cw the chord connecting Zw and Zw' . Then, length of Cw is equal to 2 sin(2−2n−2π). We denote it by leng(Cw). Let Xw be the middle point on the arc of C between Zw and Zw' , and hn be the distance between Xw and the chord Cw; that is, hn = 1 − cos(2−2n−2π). Let Bw denote the area between the chord Cw and the arc of C from Zw through Xw to Zw' .
We now divide each chord Cw into four line segments of equal length, and further divide each of the two middle segments into 2p(n) subsegments, each corresponding

to a string u ∈ {0, 1}p(n). That is, let Vw, V ' , and V ''
be the points on Cw of

w	w
distance (1/4)leng(Cw ), (1/2)leng(Cw ), and (3/4)leng(Cw ) from Zw, respectively.
Also let Pw,u be the point on Cw of distance (iu · 2−p(n)−2 · leng(Cw)) from Vw, and

'
w,u
the point on Cw of distance (iu · 2−p(n)−2 · leng(Cw)) from V ' . Finally, let Qw,u

be the point in Bw that is of equal distance from Pw,u and Pw,u' and has distance

hn/2 from the chord Cw, and Q'
the point in Bw that is of equal distance from

'
w,u
and P '
' and has distance hn/2 from the chord Cw (see Figure 2).







to O
















to O
Fig. 2. The curve ∂S around Cw

Now, we are ready to define the function f : [0, 1]→R2 that computes the bound- ary ∂S of the desired Jordan domain S. First, f maps [1/4, 1] to the unit circle C on the second, third, and fourth quadrants; i.e., f (t) = ⟨ cos(2tπ), sin(2tπ)⟩, for t ∈ [1/4, 1]. Next, on each interval Iw = [xw, xw' ], f maps [xw, xw + 2−2n−4] lin- early to the line segment ZwVw, and maps [xw +3 · 2−2n−4, xw' ] linearly to the line segment V ''Zw' . For each u ∈ {0, 1}p(n), if ⟨w, u⟩ /∈ B, then f maps Iw,u linearly to


the line segment Pw,uPw,u', and maps I'
linearly to the line segment P '
w,u' .

If ⟨w, u⟩ ∈ B, then f maps Iw,u piecewise linearly to two line segments: Pw,uQw,u

and Qw,uPw,u' , and maps I'
piecewise linearly to two line segments P '
'
w,u
and

'
w,u
'
w,u
' . This completes the definition of f . Finally, we let g(w) be the point Yw

between O and Xw that has distance 3 · hn/4 from Xw. Figure 2 shows the curve
∂S in the area Bw.
It is not hard to see that the function f and g are polynomial-time computable.
We omit the details of the proof.
We now check that the domain S satisfies the required conditions. As we argued in the proof of Theorem 3.1, our design of the curve ∂S guarantees that the part of the convex hull CH(S) within Bw depends only on the curve ∂S between Zw and Zw' . More precisely, if w /∈ A, then CH(S) ∩ Bw = ∅, and Yw /∈ CH(S). On the other hand, if w ∈ A, then S ∩ Bw contains at least two bumps which lie to the two sides of Yw, and so Yw ∈ CH(S). Furthermore, we claim that, no matter whether Yw ∈ CH(S), the distance between Yw and the boundary of CH(S) is greater than 2−p(n)−4n−5.
For the case of Yw /∈ CH(S), we know that the chord Cw is part of the boundary

of CH(S), and dist(Yw, Cw) = hn/4. For the case of Yw ∈ CH(S), let us assume
that ∂S passes through two points Qw,u and Q'	. Then, the line segment Qw,uQ'
forms part of the boundary of the convex hull CH(S), and Yw has distance hn/4

from this boundary. In addition, we know that both Qw,u and Q'
have distance at


least (2−p(n)−3 · leng(Cw)) away from the line OXw. It implies that Yw has distance at least (2−p(n)−3 · leng(Cw)) from other parts of the boundary of CH(S). That is, no matter whether Yw ∈ CH(S), dist(Yw, ∂S) ≥ min{hn/4, 2−p(n)−3 · leng(Cw)}.
Note that hn = 1 — cos(2−2n−2π) ≥ 2−4n−3, and leng(Cw) = 2 sin(2−2n−2π) ≥ 2−2n−2. Therefore, dist(Yw, ∂S) ≥ 2−p(n)−4n−5. This completes the proof of the claim. The proof of the lemma is also complete by setting q(n) = p(n)+ 4n + 5. HH
Theorem 4.5 Assume that P /= NP. Then, there exists a Jordan domain S ⊆ R2 whose boundary ∂S is P-computable but whose convex hull CH(S) is not P- recognizable.
Proof. Assume that the convex hull CH(S) of the set S constructed in Lemma 4.4 is P -recognizable. Then, we can determine whether w ∈ A by asking whether g(w) is in CH(S), with error bound < 2−q(n).  HH
Corollary 4.6 Assume that P /= NP. Then, there exists a Jordan domain S ⊆ R2
which is strongly P-recognizable but whose convex hull CH(S) is not P-recognizable.

Areas of Convex Hulls
In this section, we consider the complexity of computing the area of the convex hull CH(S) of a P-computable Jordan domain S. We first recall the results about the complexity of computing the area of a set T in the two-dimensional plane.
Proposition 5.1 (a) If T ⊆ [0, 1]2 is P-approximable, then area of T is a real number in #P R.
If T ⊆ [0, 1]2 is a P-recognizable Jordan domain with a rectiﬁable boundary, then area of T is in #P R.
If F P1 /= #P1, then there exists a convex set T ⊆ [0, 1]2 that is P- approximable but its area is not in P R.
Remarks. (1) Friedman [10] proved that the integral ∫ 1 f of a P -computable function f : [0, 1]→R is a real number in #PR. Parts (a) and (b) of Proposition 5.1 are due to Chou and Ko [3], in which the result of [10] was extended to the measure of two-dimensional P -approximable and P -recognizable sets.
(2) Friedman [10] also showed that, if FP /= #P , then the integral 1 f of some P -computable function f : [0, 1]→R is not in P R. Du and Ko [8] and Chou and Ko [3] extended this result to two-dimensional, P -approximable, convex sets.
We note that a convex Jordan domain T must have a rectifiable boundary. There- fore, if the convex hull CH(S) of a Jordan domain is P -recognizable, then its area is a real number in #P R. This observation can be easily extended to NP -recognizable

convex hulls. We first need to extend the notion of #P -computable real numbers to #NP -computable real numbers.
Definition 5.2 We define the class #NP (or, #· NP ) 8 to be the class of functions φ : {0, 1}∗→N with the following property: There exist a set B ∈ NP and a polynomial function p such that, for any w ∈ {0, 1}∗,
φ(w)= {u ∈ {0, 1}∗ : l(u)= p(l(w)), ⟨w, u⟩ ∈ B}.

We let #NP R denote the class of real numbers x which have a Cauchy function representation φ : {0}∗→D such that the function φ'(0n) = φ(n) · 2n is a function in #NP .
Theorem 5.3 Assume that S is a P-computable Jordan domain. Then, the area of CH(S) is a real number in #NP R.
Proof. Without loss of generality, assume that S ⊆ [0, 1]2. Also assume that the boundary of CH(S) has length bounded by a. Assume that M is a nondetermin- istic polynomial-time oracle TM that strongly NP -recognizes CH(S), as given in Theorem 4.2. For any n > 0, let
B = {⟨0n, d1, d2⟩| d1, d2, ∈ Dn,Md1 ,d2 (n) accepts},
where Md1 ,d2 denotes the computation of the machine M using the standard Cauchy functions for d1 and d2 as the oracles. It is clear that B ∈ NP . Furthermore, the function
φ(0n)= {⟨d1, d2⟩| d1, d2 ∈ Dn, ⟨0n, d1, d2⟩∈ B}
is a function in #NP such that the function ψ(0n)= φ(0n) · 2−2n converges to the area of CH(S) with error |ψ(0n) — area(CH(S))| ≤ a · 2−2n+2.	HH

Next, we study whether CH(S) is actually a real number in #P R. For this question, we need to review more results about the relations between counting complexity classes in discrete complexity theory.
In his celebrated paper about counting complexity classes, Toda [18] showed that PPPH ⊆ P #P [1]; that is, if a set is computable in probabilistic polynomial time relative to a set in the polynomial-time hierarchy, then it is computable in polynomial-time with a single query to an oracle function in #P . 9 Toda and Watanabe [19] further extended this result to the function classes and showed that #PPH ⊆ FP #P [1]. Since #NP is a subclass of #PPH, the following result is immediate.

8 In the original paper of Valiant [20], the notation #NP was defined to mean the class #P NP . Hemas- paandra and Vollmer [11] pointed out that, in view of the characterization of #P of Proposition 2.1(c), it appears to be more approapriate to define #NP to mean the class we defined here, and proposed, in a general framework, the notation # · NP for this class. Here, we use #NP for its simplicity.
9 Here, PP denotes the class of sets accepted by polynomial-time probabilistic TMs with accepting proba- bility greater than 1/2, and PH denotes the polynomial-time hierarchy, of which NP is the first level. For more details, see Du and Ko [9].

Proposition 5.4 #NP ⊆ FP #P [1].
Combining Propositions 5.1 and 5.4, we obtain the following results about the area of CH(S).
Corollary 5.5 Assume that S ⊆ R2 is a P-computable Jordan domain. Then, the area of CH(S) is a real number in P #P .
Corollary 5.6 The following are equivalent:
For any P-computable Jordan domain S ⊆ R2, the area of CH(S) is in P R.
F P1 = #P1.
Corollary 5.5 leaves it open whether the area of CH(S) is actually in #P R. This question is clearly related to the question of whether the discrete classes #P and #NP are equal. The following nice characterization of this question is due to Hemaspaandra and Volmer [11].
Proposition 5.7 NP = UP if and only if #P = #NP.
Corollary 5.8 If UP = NP, then area of the convex hull CH(S) of a P-computable Jordan domain S is in #P R.
Whether the converse of the above holds remains open. We note that Proposition
5.7 implies that if UP /= NP then there exists some function ψ in #NP that is not in #P . However, this function ψ constructed in the proof in Hemaspaandra and Vollmer [11] is a simple, characteristic function of a set A ∈ NP — UP . It seems difficult to construct a P-computable Jordan curve S of which the area of CH(S) is related to such a function ψ. It would be interesting to find out whether a stronger condition of separating some discrete classes implies that the area of CH(S) is not in #P R.

Acknowledgment
The authors would like to thank Professor Joseph Mitchell for his suggestion of studying the complexity of convex hulls, and Professor Lane Hemaspaandra for the discussion on the relation between the counting classes #P and #NP and pointing out the relevant references.

References
Braverman, M., Hyperbolic Julia sets are poly-time computable, Proceedings of the 6th Workshop on Computability and Complexity in Analysis, Electron. Notes Theoret. Comput. Sci. 120 (2005), 17–30.
Braverman, M. and M. Yampolsky, Non-computable Julia sets, J. Amer. Math. Soc. 19 (2006), 551–578.
Chou, A. W. and K.-I. Ko,  Computational Complexity of Two-Dimensional Regions, SIAM. J. Comput. 24 (1995), 923–947.
Chou, A. W. and K.-I. Ko, On the complexity of finding paths in a two-dimensional domain I: Shortest paths, Math. Logic Quart. 50 (2004), 551–572.


Chou, A. W. and K.-I. Ko, On the complexity of finding paths in a two-dimensional domain II: Piecewise straight-line paths, Proceedings of the 6th Workshop on Computability and Complexity in Analysis, Electron. Notes Theoret. Comput. Sci. 120 (2005), 45–57.
Chou, A. W. and K.-I. Ko, The computational complexity of distance functions of two-dimensional domains, Theoret. Comput. Sci. 337 (2005), 360–369.
De Berg, M., M. van Kreveld, M. Overmars, and O. Schwarzkopf, “Computational Geometry: Algorithms and Applications”, 2nd Ed., Springer-Verlag, New York, 2000.
Du, D. and K.-I. Ko, Computational complexity of integration and differentiation of convex functions, System Sci. Math. Sci. 2 (1989), 70–79.
Du, D.-Z. and K.-I. Ko, “Theory of Computational Complexity”, John Wiley & Sons, New York, 2000.
Friedman, H., On the computational complexity of maximization and integration, Adv. in Math. 53
(1984), 80–98.
Hemaspaandra, L. and H. Vollmer, The Satanic notations: Counting classes beyond #P and other definitional adventure, SIGACT News 26 (1995), 2–13.
Ko, K.-I., “Complexity Theory of Real Functions”, Birkha¨user, Boston, 1991.
Ko, K. and F. Yu, On the complexity of computing the logarithm and square root functions on a complex domain, J. Complexity 23 (2007), 2–24.
O’Rourke, J., “Computational Geometry in C”, 2nd Ed., Cambridge University Press, Cambridge, UK, 1996.
Pour-El, M. B. and J. I. Richards, “Computability in Analysis and Physics”, Perspectives in Mathematical Logic, Springer, Berlin, 1989.
Rettinger, R., A fast algorithm for Julia sets of hyperbolic rational functions, Proceedings of 6th Workshop on Computability and Complexity in Analysis, Electronic Notes in Theoret. Comput. Sci. 120 (2005), 145–157.
Rettinger, R. and K. Weihrauch, The computational complexity of some Julia sets, Proceedings of 35th ACM Symposium on Theory of Computing, 2003, 177–185.
Toda, S., PP is as hard as the polynomial-time hierarchy, SIAM J. Comput. 20 (1991), 865-877.
Toda, S. and O. Watanabe, Polynomial-time 1-turing reductions from #PH to #P , Theoret. Comput. Sci. 100 (1992), 205–221.
Valiant, L., The complexity of computing the permanent, Theoret. Comput. Sci. 8 (1979), 189–201.
Weihrauch, K., “Computable Analysis,” Springer, Berlin, 2000.
