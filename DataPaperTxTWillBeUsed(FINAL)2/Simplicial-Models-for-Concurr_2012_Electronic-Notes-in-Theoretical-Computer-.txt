Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 283 (2012) 3–12
www.elsevier.com/locate/entcs
Simplicial Models for Concurrency
Peter Bubenik1,2
Department of Mathematics Cleveland State University Cleveland, USA

Abstract
We model both concurrent programs and the possible executions from one state to another in a concurrent program using simplices. The latter are calculated using necklaces of simplices in the former.
Keywords: Concurrency; Simplicial set; Simplicial category; Necklace

Introduction
We develop a discrete model for processes that is useful in the concurrent setting. It is based on the traditional model given by graphs. In this model, vertices of the graph represent states and edges represent transitions. The edges may be directed or undirected.
A more sophisticated model appropriate for concurrency is given by simplicial complexes. For example, the following triangle,
final
b
initial	a
models two processes a and b where the boundary models two executions, either a followed by b, or a and b concurrently. The interior of the triangle models inter- mediate executions. Adding another triangle we obtain a simplicial complex that models all possible executions of a and b.

1 The author would like to thank David Spivak for many useful conversations pertaining to this article. He would also like to thank the NSF for funding some of this research through the Midwest Topology Network (NSF grant DMS-0844249). In addition he would like to thank Martin Raussen and Lisbeth Fajstrup for organizing the GETCO 2010 conference that motivated this work.
2 Email: p.bubenik@csuohio.edu

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.05.002

a	final
b	b
initial	a
For three processes, the analogous model is a cube that is subdivided into six tetra- hedra.
The combinatorial versions of simplicial complexes are simplicial sets. These consist of sets of abstract vertices, edges, triangles, tetrahedra, and higher dimen- sional simplices. For a simplicial set, the corresponding simplicial complex is its geometric realization. Our figures will consist of simplicial complexes, but we in- tend these to represent the corresponding simplicial set.
Using Dijkstra’s formalism for concurrent programs [4], we give an explicit con- struction of a simplicial model for a concurrent program using filtered simplicial sets. The vertices of this simplicial model give states of the concurrent program. The executions between states are modeled by paths between vertices in the sim- plicial model. There is a growing literature of related models, which are mostly continuous. For some examples, see [7,8,2,3,12,11,6].
In concurrency, understanding the possible execution paths is one of the main sources of difficulty. In a simplicial set, the equivalence classes of paths can be described by a category called the fundamental category [10] or the path category [9]. In this category the objects are the vertices of the simplicial set, and between objects there is a set of equivalence classes of paths.
We consider a related but more sophisticated construction in which the objects are vertices of the simplicial set, but the executions from one state to another are described by a simplicial set. That is, our model is a simplicial category (i.e., a category enriched over simplicial sets). This construction can detect higher order structure that is invisible to the path category. To calculate it, we consider necklaces of simplices in our simplicial set models. In a related paper [14], Raussen constructs simplicial models of execution spaces for continuous models.
Outline of the paper: In Section 2, we discuss simplicial sets, filtered simplicial sets, necklaces, simplicial categories, and some of the other necessary mathematical machinery. In Section 3, we apply these constructions to construct simplicial models of concurrent systems and also of their execution spaces. Our examples include an example in which the structure of the executions is not detected by the path category, but is captured by our methods. In Section 4, we discuss a suitable model structure for this setting and we remark that one may try to apply these methods using cubical sets instead of simplicial sets.
Mathematical machinery
Simplicial sets
A simplicial set, X, consists of a sequence of sets, {X0, X1, X2,.. .} together with
face maps di : Xk → Xk−1 for 0 ≤ i ≤ k and degeneracy maps si : Xk → Xk+1 for

0 ≤ i ≤ k satisfying the following simplicial identities.
didj = dj—1di if i < j sisj = sj+1si if i ≤ j disj = sj—1di if i < j djsj = Id= dj+1sj
disj = sjdi—1 if i > j +1 
The elements of Xk are called k-simplices. The 0-simplices are called vertices and the 1-simplices are called edges. A morphism of simplicial sets, f : X → Y consists of a sequence of functions fk : Xk → Yk that commute with the face and degeneracy maps. The geometric realization of a simplicial set is a simplicial complex.
For example, for each n there is a simplicial set Δn whose geometric realization is the standard geometric n-simplex. Δ0 is the simplicial set with one element in each Xk and all of the face and degeneracy maps given by the identity. The k-simplices that are not in the image of a degeneracy map are called nondegenerate. Thus, Δ0 has only one nondegenerate simplex, which is a 0-simplex. The only nondegenerate simplices in Δ1 are a, b ∈ Δ1 and e ∈ Δ1 where d0(e)= b and d1(e)= a. Note that
0	1
the initial vertex is d1(e) and the final vertex is d0(e).
Simplicial sets and their morphisms form a category. Geometric realization is a functor from this category to the category of topological spaces. A more elegant but more sophisticated way of defining simplicial sets is as contravariant functors from the category of finite ordinals and order preserving maps to the category of sets.
Filtered simplicial sets
A sub-simplicial set A ⊆ X is a sequence of subsets Ai ⊆ Xi that are closed under the restrictions of the face and degeneracy maps. A ﬁltration on a simplicial set X is an increasing sequence X(0) ⊆ X(1) ⊆ X(2) ⊆ ... of sub-simplicial sets of X. The simplices in X(d) are said to be in degree d. A m-ﬁltration on X is a collection of

sub-simplicial sets X(i1,...,im
) of X such that if ij ≤ ij
for 1 ≤ j ≤ m then X(i1,...,im)

is a sub-simplicial set of X(i′ ,...,i′ ).
1	m
For simplicial sets X and Y , their product X×Y is given by (X×Y )n = Xn ×Yn
with face and degeneracy maps di = di × di and si = si × si. Note that the nondegenerate simplices of X × Y are not necessarily products of nondegenerate simplices of X and Y . A standard example is Δ1 × Δ1 which is a triangulation of the square. For filtered simplicial sets X and Y , X × Y has an induced filtration where (X × Y )(k) is the union of the sub-simplicial sets X(i) × Y(j) where i + j = k. Similarly, products of m-filtered simplicial sets have an induced m-filtration.
The path category of a simplicial set
Given a simplicial set X, we can define the path category, P (X), as follows. For a thorough exposition see [9]. The path category is also called the fundamental

category.
Definition 2.1 Let the path category P (X) of the simplicial set X be the category whose objects are the vertices of X and whose morphisms are concatenations of edges in X modulo the equivalence relation generated by the following relations
s0(a) ∼ Ida,	for all a ∈ X0, and
d1(t) ∼ d2(t)d0(t),	for all t ∈ X2.

The simplicial category of an ordered simplicial set
Since the path category only depends on the k-simplices for k ≤ 2, it does not detect higher order structure.
For this purpose, we consider the following construction of a category enriched over simplicial sets. In such a category, between two objects, instead of set of morphisms, we have a simplicial set of morphisms. For brevity, this is also called a simplicially enriched category, or a simplicial category. For a thorough exposition of the simplicial category of a simplicial set see [5].
A necklace is a simplicial set, T , of the form
Δn1 ∨ Δn2 ∨ ... ∨ Δnk
where the final vertex of Δni is glued to the initial vertex of Δni+1 . The simplicial set Δni is called a bead of T . Vertices of T that are initial or final vertices of any of the beads are called joints of T . The set of joints of T is denoted JT . Call the initial vertex of Δn1 the initial vertex of T and the final vertex of Δnk the final vertex of T .
A flag of T is an increasing sequence T = (T 0 ⊆ · · ·⊆ Tn) of subsets of vertices of T . The length of T is n. A flag is flanked if T 0 = JT and Tn = T0.
A simplicial set X is ordered if for each a ∈ X0, P (X)(a, a) consists of only the identity morphism, and no two simplices have the same set of vertices. The simplicial sets arising in our models in Section 3 will all be ordered. One can define the simplicial category for a simplicial set without this condition, but for ordered simplicial sets we have the following nice explicit construction from [5].
Definition 2.2 For an ordered simplicial set X, let C(X) be the category enriched in simplicial sets whose objects are vertices in X, and such that for vertices a and b, C(X)(a, b) is the simplicial set given as follows. Let C(X)(a, b)n be the set of triples (T, f, T ) where T is a necklace, f : T → X is a injective map of simplicial sets such that the images of the initial and final vertices of T are a and b respectively, and T is a flanked flag of length n. The degeneracy maps, si, for 0 ≤ i ≤ n are given by
si((T, f, T 0 ⊆ · · ·⊆ Tn)) = (T, f, T 0 ⊆ · · ·⊆ T i ⊆ T i ⊆ · · · Tn).
The face maps, di, for 0 < i < n are given by
di((T, f, T 0 ⊆ · · ·⊆ Tn)) = (T, f, T 0 ⊆ · · ·⊆ T i—1 ⊆ T i+1 ⊆ · · · Tn).

For i = 0, let T j the unique subnecklace of T whose set of joints is T 1 and whose set of vertices is Tn. Similarly, for i = n, let T jj be the unique subnecklace of T whose set of joints is T 0, and whose set of vertices is Tn—1. Then
d0((T, f, T 0 ⊆ · · ·⊆ Tn)) = (T j, f,T 1 ⊆ · · ·⊆ Tn), and
dn((T, f, T 0 ⊆ · · ·⊆ Tn)) = (T jj, f,T 0 ⊆ · · ·⊆ Tn—1).

Concurrency
We use Dijkstra’s abstraction of concurrent programming in which semaphores are used to control access by multiple processes to a common resource [4]. More precisely, a resource that may be used by only k processes at once is controlled by a k-semaphore. This is simply a nonnegative counter which starts at k. When a process wants to use the resource it tries to decrement the counter and when it is finished using the resource it increments the counter. 1-semaphores are also called binary semaphores.
A concurrent program can be abstractly written as a sequence of operations on semaphores. Following Dijkstra’s original notation, for a semaphore a, let Pa denote decrementing a and let Va denote incrementing a. We consider programs that are finite sequences of these operations. Abstractly a program for one process is given by
P = O1ai1 .O2ai2 . ··· .ON aiN ,	(1)
where Oj is either operator P or V and aij is one of the semaphores. Let s0 be the initial state of the program P and let sj be state of the program after the operation Ojaij .

Simplicial models of concurrent programs

Definition 3.1 The simplicial model for the program P for a single process in (1) is modeled by the simplicial set X that is the necklace of N 1-simplices. The vertices of the necklace correspond to states of the program. If there are m shared resources a1,..., am we define an m-filtration on this necklace. The initial vertex has degree (0,..., 0). The operation Pai increases by one the ai degree of the corresponding edge and the subsequent vertices and edges in the necklace. The operation V ai decreases by one the ai degree of the vertices and edges in the necklace following the corresponding edge.
Example 3.2 Let a and b be two binary semaphores. Consider the program
Pa.Pb.V a.V b

This program can be modeled by the following bifiltered simplicial set.

a a ab ab ab b  b

Here the unlabeled vertices and edges are in degree (0, 0). The vertices and edges labeled a, b and ab are in degree (1, 0), (0, 1) and (1, 1) respectively.
Assume programs P1, ..., Pn with shared resources a1,..., am have as simplicial models the m-filtered simplicial sets X1, ... Xn. We want a model for the concurrent program P = (P1|··· |Pn). The simplicial set X1 × · · · × Xn has an induced m- filtration (see Section 2.2). A state of P is a vertex x = (x1,..., xn) ∈ X1 ×· · ·×Xn.
Definition 3.3 We call a state x = (x1,..., xn) of P valid if across 1 ≤ i ≤ n the uses of resources by Pi at sji are compatible, where sji is the state of Pi corresponding to the vertex xi of the model Xi. More precisely, for 1 ≤ i ≤ n, 1 ≤ j ≤ m and xi ∈ Pi, let Dij(xi) be the amount that aj has decreased from kj if the program for the process Pi runs from its initial state to the state xi. A state x = (x1,..., xn) is valid if for each 1 ≤ j ≤ m
n
Dij(xi) ≤ kj.
i=1
Lemma 3.4 The set of valid states of P is given by the vertices in (X1 × ··· ×
Xn)(k1,...,km).
Proof. Consider x = (x1,..., xn) ∈ X1 ×· · ·× Xn. Let 1 ≤ i ≤ n and 1 ≤ j ≤ m. From the definition of the grading on Xi, xi has aj degree Dij(Xi). So the aj degree
of x is Σn	Dij(xi). Thus the degree of x is

n

i=1
n
Di1(xi),..., 
i=1
Dim(xi)! .

Therefore x is valid if and only if x ∈ (X1 ×· · · × Xn)(k1,...,km).	2
An edge of X1 ×· · ·× Xn is of the form (e1,..., en) where ei is an edge of Xi.
Note that ei may be degenerate. That is ei = sxi where xi is a vertex of Xi.
Definition 3.5 Define an edge e = (e1,..., en) to be valid if across 1 ≤ i ≤ n the

uses of resources by Pi from sji to sj′
are compatible, where sji  and sj′
are the

states corresponding to d1(ei) and d0(ei), respectively. More precisely, using the
notation of Definition 3.3, e is valid if for each 1 ≤ j ≤ m,
n
max{Dij(d1(ei)), Dij(d0(ei))}≤ kj
i=1
Lemma 3.6 The set of valid edges of P is given by the edges in (X1 × ··· ×
Xn)(k1,...,km).
Proof. Consider e = (e1,..., en) ∈ X1 ×· · ·× Xn. Let 1 ≤ i ≤ n and 1 ≤ j ≤ m. From the definition of the grading on Xi, ei has aj degree equal to the maximum of the aj degree of its vertices d1(ei) and d0(ei). Thus the degree of e is

n i=1
n
max{Di1(d1(ei)), Di1(d0(ei))},..., 
i=1
max{Dim(d1(ei)), Dim(d0(ei))}! .

Therefore x is valid if and only if x ∈ (X1 ×· · · × Xn)(k1,...,km).	2
Definition 3.7 Assume the program P = (P1| ... |Pn) has shared resources a1,..., am where ai is a ki-semaphore. The simplicial model for P is given by the simplicial set
(X1 ×· · · × Xn)(k1,...,km).
Example 3.8 Let a and b be two binary semaphores. Consider the two programs
A = Pa.Pb.V b.V a	and	B = Pb.Pa.V a.V b
These can be modeled by the following bifiltered simplicial sets A and B.

a a ab ab ab a a	b b ab ab ab b b
Here the unlabeled vertices and edges are in filtration (0, 0). The vertices and edges labeled a, b and ab are in filtration (1, 0), (0, 1) and (1, 1) respectively.
Now consider the concurrent execution of A and B, denoted (A|B). It is modeled by the following simplicial set (A × B)(1,1).

Example 3.9 Let a be a 2-semaphore. Consider the three identical programs, A, B and C given by
Pa.V a
This program is modeled by the following filtered simplicial set X.

a a a
The concurrent program (A|B|C) is modeled by the simplicial set (X×X×X)(2), which is a triangulation of the boundary of the cube.
Remark 3.10 One can also define analogous cubical models for concurrent pro- grams. The simplicial models presented here are the triangulations of those cubical models.

Simplicial models of execution spaces
Next we construct simplicial models for the space of executions from one state to another in the simplicial models in Section 3.1.

Definition 3.11 For vertices a and b in a simplicial model X, we define the sim- plicial model of the execution space from a to b to be the simplicial set C(X)(a, b).



Example 3.12 Let X be the boundary of the cube labeled as follows.
6	7
3


4
0	1
Then MapX (0, 7) is given by the following simplicial set.

4	5
24	35
2	3

Here a vertex labeled i represents the necklace with flanked flag (Δ1 ∨ Δ1, {0, i, 7}) and a vertex labeled ij represents the necklace with flanked flag (Δ1 ∨ Δ1 ∨ Δ1, {0, i, j, 7}). An edge between vertices i and ij represents the necklace with flanked flag (Δ2 ∨ Δ1, {0, i, 7}⊂ {0, i, j, 7}) or (Δ1 ∨ Δ2, {0, i, 7}⊂ {0, i, j, 7}).
Thus MapX (0, 7) is homotopy equivalent to the circle. We remark that this is an example of higher order structure that is not detected by the path category [9].



Example 3.13 Let X be the following simplicial set. For clarity, we omit the 1-simplices along the diagonals of each of the squares.
h	k	l
d



i
a	b	e
Then MapX (a, l) is given by the following simplicial set.







chk hk dhk

cf
cfk
ck
fk 




gk
dk
dgk
dg
cfi
fi 

f
bf
bfk
bk bgk
bg
g

gj
dgj


bfi
bi







bj
bgj





bei be bej

Here a vertex labeled x represents the necklace with flanked flag (Δ1∨Δ1, {a, x, l}), a vertex labeled xy represents the necklace with flanked flag (Δ1∨Δ1∨Δ1, {a, x, y, l}), and a vertex labeled xyz represents the necklace with flanked flag (Δ1 ∨ Δ1 ∨ Δ1 ∨ Δ1, {a, x, y, z, l}). A triangle between vertices x, xy and xyz represents the necklace with flanked flag (Δ2 ∨ Δ2, {a, x, l}⊂ {a, x, y, l}⊂ {a, x, y, z, l}).
Thus MapX (a, l) is homotopy equivalent to S1 ∨ S1, the wedge of two circles.





Future directions

It would be very nice to have a Quillen model structure on simplicial categories ap- propriate to their use as models for concurrency. A natural candidate is J. Bergner’s model structure on simplicial categories [1], which is closely related to A. Joyal’s quasi-category model structure on simplicial sets [10]. However this model structure is too strong, since the weak equivalences induce equivalences of path categories. Thus a weaker notion of equivalence is needed. For some recent ideas in this direc- tion, see [13].
The simplicial set models in this paper are in fact triangulations of cubical set models. When constructing models of the execution spaces from one state to another, we used (simplicial) necklaces on the simplicial models. Instead, one could use cubical necklaces on the cubical models, if one understood such things from a homotopy-theoretic point of view. These models would be more economical. For example, we should be able to redo Example 3.13 using cubical sets and cubical necklaces to obtain the following cubical set for MapX (a, l).



Acknowledgments
The author would like to thank David Spivak for many useful conversations per- taining to this article. He would also like to thank the NSF for funding some of this research through the Midwest Topology Network (NSF grant DMS-0844249). In ad- dition he would like to thank Martin Raussen and Lisbeth Fajstrup for organizing the GETCO 2010 conference that motivated this work.

References
Julia E. Bergner. A model category structure on the category of simplicial categories. Trans. Amer. Math. Soc., 359(5):2043–2058, 2007.
Peter Bubenik. Models and van Kampen theorems for directed homotopy theory. Homology, Homotopy Appl., 11(1):185–202, 2009.
Peter Bubenik and Krzysztof Worytkiewicz. A model category for local po-spaces. Homology, Homotopy Appl., 8(1):263–292, 2006.
E.W. Dijkstra. Cooperating sequential processes. Academic press, 1968.
Daniel Dugger and David Spivak. Rigidification of quasi-categories. arXiv:0910.0814 [math.CT], 2009.
L. Fajstrup, M. Raussen, E. Goubault, and E. Haucourt. Components of the fundamental category.
Appl. Categ. Structures, 12(1):81–108, 2004. Homotopy theory.
Lisbeth Fajstrup, Martin Raußen, and Eric Goubault. Algebraic topology and concurrency. Theoret. Comput. Sci., 357(1-3):241–278, 2006.
Marco Grandis. Directed homotopy theory. I. Cah. Topol. G´eom. Diff´er. Cat´eg., 44(4):281–316, 2003.
J.F. Jardine. Path categories and resolutions. Homology, Homotopy and Applications, 12(2):231–244, 2010.
A. Joyal. Quasi-categories and Kan complexes. J. Pure Appl. Algebra, 175(1-3):207–222, 2002. Special volume celebrating the 70th birthday of Professor Max Kelly.
Thomas Kahl. Reducing cubical set models of concurrent systems. arXiv:1005.5443 [math.AT], 2010.
Sanjeevi Krishnan. A convenient category of locally preordered spaces. Appl. Categ. Structures, 17(5):445–466, 2009.
Sanjeevi Krishnan. Cubical approximation for directed topology. arXiv:1012.0509 [math.AT], 2010.
Martin Raussen. Simplicial models of trace spaces. Algebr. Geom. Topol., 10(3):1683–1714, 2010.
