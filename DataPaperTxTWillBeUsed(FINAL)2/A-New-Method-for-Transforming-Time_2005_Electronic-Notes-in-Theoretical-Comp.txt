Electronic Notes in Theoretical Computer Science 130 (2005) 101–128 
www.elsevier.com/locate/entcs


A New Method for Transforming Timed Automata
Ahmed Khoumsi1	Lucien Ouedraogo2
Dept. of Elect. and Comp. Eng.
University of Sherbrooke Sherbrooke J1K2R1, CANADA

Abstract
Discrete events systems (DES) are defined by the sequences of events they can execute. For exam- ple, communication protocols and computer networks can be seen as DES. Finite state automata (FSA) are convenient for studying (i.e., analyzing, designing) DES, and timed automata (TA) are convenient for describing real-time DES. An approach for studying a real-time DES, has been to transform a TA describing the real-time DES into an equivalent FSA, and then to study the latter. We propose here a new transformation method of TA into FSA. The method is well suited for conformance testing and supervisory control of real-time DES.
Keywords: Transformation, Timed Automata, Set-Exp-Automata.


Introduction
Discrete events systems (DES) interact with their environment by executing events. Here are some examples of DES: communication protocols (events: send message, receive message, ... ), telephone systems (events: hang on, hang
up, ... ), mobile robot (events: start moving, stop, ... ). Correctness of a Real- time DES (RTDES) depends not only on how but also on when the RTDES interacts with its environment. Timed Automata (TA) [4] are convenient to describe RTDES, but a TA has inﬁnitely many states. An approach to give a finite representation of the state space of a TA, is to generate a region

1 Email: Ahmed.Khoumsi@USherbrooke.ca
2 Email: Lucien.Ouedraogo@USherbrooke.ca



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.03.007


automaton (RA) [2]. The state space of a RA is finite but can suffer from state explosion [2]. To reduce such a state explosion, several minimization methods have been proposed to transform a TA into an automaton with much less states than the corresponding RA [3,15,5,6,14,1].
We propose a new method called SetExp for transforming a TA into a finite state automaton (FSA), called Set-Exp-Automaton (SEA), which uses two additional types of events: Set and Exp that model the setting and expiring of clocks, respectively. A TA and the corresponding SEA represent two different ways to specify the same order and timing constraints of events.
In comparison to other minimization methods, SetExp is well suited for conformance testing and supervisory control of RTDES 3 . Conformance test- ing aims at checking whether an implementation conforms to a specifica- tion [13], and supervisory control aims at forcing an implementation to con-
form to a specification [12]. The application of SetExp to conformance testing (resp., supervisory control) has been demonstrated in [7,10] (resp., in [11,8,9]). In [7,10,11,8,9], SetExp is used as a black-box and the focus is on its applica- tion. In the present study, our aim is to “see inside SetExp”; more precisely, we explain formally how SetExp can be implemented. Therefore, this paper
is complementary to [7,10,11,8,9].
The remainder of the paper is structured as follows. Sect. 2 introduces the TA model. In Sect. 3, we illustrate SetExp by simple examples, and we present the SEA model. Sects. 4 and 5 explain in a formal way how SetExp is realized. In Sect. 6, we present a theorem that states correctness and some properties of SetExp. And Sect. 7 concludes the paper.



Timed Automata (TA)

A clock is a real-valued variable that can be reset (to 0) at the occurrence of an event and such that, between two resets, its derivative (w.r.t. time) is equal to 1. Let C = {c1, ··· , cNc } be a set of clocks.
A clock constraint is a formula in the form “ci ∼ k”, where ci is a clock,
∼∈ {<, >, ≤, ≥, =} and k is a nonnegative integer. Let ΦC denote the (infinite) set of clock constraints depending of clocks of C.
And let 2X denote the set of subsets of a set X.



3 SetExp does not aim at competing with other minimization methods in Veriﬁcation.

Syntax of TA
A TA is defined by (L, A, C, T , l0), where: L is a finite set of locations, l0 is the initial location, A is a finite set of events (alphabet), C is a finite set of clocks, and T ⊆ L×A× L× 2ΦC × 2C is a transition relation. A transition of TA is thus defined by T = ⟨q; σ; r; G; Z⟩, where: q and r are origin and destination locations, σ is an event, G is a finite subset of ΦC and is called guard of T , and Z is a subset of C and is called reset of T .
The example of Fig. 1 illustrates this definition. Locations are represented by nodes, and a transition Tr = ⟨q; σ; r; G; Z⟩ is represented by an arrow linking q to r and labeled (σ; G; Z). An empty G or Z is represented by “-”.

Fig. 1. Example of TA

Semantics of TA
At time τ0 = 0, the TA A = (L, A, C, T , l0) is at location l0 with all clocks of C equal to 0. A transition Tr=⟨q; σ; r; G; Z⟩ is enabled when q is the current location and all the clock constraints of the guard G (if any) evaluate to true; otherwise, Tr is disabled . From this location q, the event σ is executed only when Tr is enabled; and after the execution of σ, location r is reached and the clocks in Z are reset.
For example, the TA of Fig. 1 is initially in location l0; it reaches l1 at the occurrence of σ. From location l1, the TA reaches l2 at the occurrence of µ. From location l2, the TA reaches l0 at the occurrence of φ or ρ. Let δu,v denote the delay between events u and v. We have: δσ,µ ≤ 3, δσ,φ < 2, δσ,ρ ≥ 2, δµ,φ ≥ 1, and δµ,ρ ≥ 1.
The semantics of a TA A can also be defined by the set of timed sequences accepted by A. a A timed sequence of a TA is a sequence “(e1, τ1) ··· (ei, τi) ·· ·”, where e1, ··· , ei ∈ A, each τi is the time of occurrence of ei, and 0 < τ1 <
··· < τi < ·· ·. Now given a TA A, let us define the acceptance by A of a timed sequence λ = (e1, τ1)(e2, τ2) ·· ·. Let n be the length of λ (n can be infinite), and λi = (e1, τ1) ··· (ei, τi) be the prefix of λ of length i, for 0 ≤ i ≤ n (i is finite). λ is accepted by A iff :
Either λ is the empty sequence λ0;


Or A has a sequence of length n of consecutive transitions Tr1 Tr2 ··· that starts at l0 and s.t. ∀i = 1, 2, ··· , n: the event of Tri is ei and, after the execution of λi−1, Tri is enabled at time τi.
Definition 2.1 The Timed language of a TA A (TLTA) is the set of timed sequences accepted by A. That is, TLTA models the behavior of A.
A TA allows to express constraints on delays between events. For example, to specify that the delay d between two transitions Tr1 and Tr2 is such that d ∈ [1, 3], we use a clock c1 as follows: the reset of Tr1 is {c1}, and the guard of Tr2 is {(c1 ≥ 1), (c1 ≤ 3)}.
The class of TA that we will consider respects the following hypothesis:
Hypothesis 2.1 Each TA is assumed deterministic, i.e., if Tr1 and Tr2 are two transitions executing the same event from the same location, and are en- abled at the same time, then they lead to the same location and reset the same clock(s).

Illustration of SetExp, Set-Exp-Automata (SEA)
The aim of this paper is to present a method SetExp for transforming a TA into a finite state automaton, called Set-Exp-Automaton (SEA), which uses two additional types of events: Set and Exp that model the setting and expiring of clocks, respectively. A TA and the corresponding SEA represent two different ways to specify the same order and timing constraints of events. In this section,
we first introduce the events Set and Exp, followed by a trivial example that illustrates SetExp. Then, we present the SEA model, followed by a running example of SetExp corresponding to the TA of Fig. 1.


Events Set and Exp
An event Set(ci ; k ) means: clock ci is reset (to 0) and will expire when its value is equal to k. And Set(ci ; k1 , k2 , ··· , kp) means that ci is reset and will expire several times, when its value is equal to k1, k2, ··· , kp, respectively. We assume without loss of generality that k1 < k2 < ··· < kp.
An event Exp(ci ; k ) means: clock ci expires and its current value is k. Therefore, Set(ci ; k ) is followed (after a delay k) by Exp(ci ; k ),  and
Set(ci ; k1 , k2 , ··· , kp) is followed (after delays k1, ··· , kp) by Exp(ci ; k1 ),
Exp(ci ; k2 ), ··· , Exp(ci ; kp).  When a Set(ci ; ∗) occurs, then all expirations of ci which were foreseen before this Set(ci ; ∗) are canceled.


Trivial example of transformation
To explain the intuition of SetExp, let us consider the following two speci- fications. Specification 1: a task must be realized in less than two units of time. Specification 2: at the beginning of the task an alarm is programmed so that it occurs after two time units, and the task must be terminated before the
alarm. It is clear that these two expressions define the same timing constraint. In this example, SetExp can be used to obtain the second specification from the first one. The programming of the alarm corresponds to a Set event, and the occurrence of the alarm corresponds to an Exp event.

Transitions of SEA
Let A be a TA and SetExp(A) be the corresponding SEA. In the following: σ denotes an event of the alphabet of the TA A, S (resp. E) denotes a set of Set (resp. Exp) events, and occurrence of S (resp. E) means the simultaneous occurrences of all the events in S (resp. E). Let us categorize the transitions of the SEA SetExp(A) into three types:
Type 1 : a transition labeled (E) represents the occurrence of E.
Type 2 : a transition labeled (σ) or (σ, S): (σ) represents the occurrence of σ, and (σ, S) represents the simultaneous occurrences of σ and S. A transition TR of Type 2 in the SEA SetExp(A) corresponds to a transition of A.
Type 3 : a transition labeled (E , σ) or (E , σ, S): (E , σ) represents the simul- taneous occurrences of E and σ, (E , σ, S) represents the simultaneous oc- currences of E, σ and S. A transition TR of Type 3 in the SEA SetExp(A) corresponds to the simultaneous executions of E and a transition Tr of A.

Syntax and semantics of SEA
A SEA B is a particular FSA and its syntax can be simply defined by (Q, Γ, δ, q0), where Q is a set of states, q0 is the initial state, and Γ is an alphabet consisting of labels of transitions of types 1, 2 or 3. δ ⊆ Q × Γ × Q is a set of transitions.
Let a sequence denote a (finite or infinite) sequence “E1 ··· Ei ·· ·”, where Ei ∈ Γ. From a behavioral point of view, let us define the semantics of a SEA B = (Q, Γ, δ, q0) by the set of sequences accepted by B:
A finite sequence µn = E1 ··· En is accepted by B iff it labels a sequence of n consecutive transitions of B that starts in q0 and terminates in a state with no outgoing transition of Type 1 or 3. Intuitively, B can execute µn


and then stops only if there is no expiration after µn. This is so, because expirations cannot be delayed.
An infinite sequence µ∞ is accepted by B iff it labels a sequence of consec- utive transitions of B that starts in q0.
We can now introduce the notion of Language of a SEA:
Definition 3.1 The language of a SEA B (LSEA) consists of the (ﬁnite and inﬁnite) sequences accepted by B. That is, LSEA models the behavior of B.
Given a SEA B, note that LSEA implicitly respects the following condi- tion, called the Consistency condition: every Set(c; k ) and its corresponding Exp(c; k ) are effectively separated by time k.

Running example
For the TA A of Fig. 1, we obtain the SEA SetExp(A) of Fig. 2. We will explain in Sect. 5 how this SEA is computed. Transitions of type 1 are those labeled Exp(c1 ; 1 ), Exp(c1 ; 3 ), Exp(c2 ; 2 ) and (Exp(c1 ; 1 ), Exp(c2 ; 2 )). Tran- sitions of Type 2 are those labeled (σ, Set(c1 ; 3 ), Set(c2 ; 2 )),  (µ, Set(c1 ; 1 )), φ and ρ; they correspond to transitions Tr1, Tr2, Tr3, and Tr4, respectively, of the TA A of Fig. 1. Transitions of Type 3 are those labeled
(Exp(c2 ; 2 ), σ, Set(c1 ; 3 ), Set(c2 ; 2 )),  (Exp(c1 ; 1 ), φ),
(Exp(c1 ; 1 ), ρ),  (Exp(c2 ; 2 ), ρ),  (Exp(c1 ; 1 ), Exp(c2 ; 2 ), ρ),
(Exp(c2 ; 2 ), µ, Set(c1 ; 1 )),  (Exp(c1 ; 3 ), µ, Set(c1 ; 1 )).  Finite sequences ac-
cepted by the SEA SetExp(A) (i.e., ∈ LSEA	) start in q0 and terminate in
a shaded state (i.e., state without outgoing Exp event).
SetExp, that transforms a TA A = (L, A, C, T , l0) into a SEA SetExp(A), is realized in two steps. Step 1 does not modify the structure of A: it replaces the resets of transitions by Set events (substep 1a), and rewrites the guards of transitions in the form of order constraints relatively to Exp events (sub- step 1b). Step 2 generates SetExp(A) that describes explicitly all the possible orders of events, including Set and Exp events in addition to the events of the alphabet of A. Steps 1 and 2 are presented in Sects. 4 and 5, respec- tively. The results of Steps 1 and 2 will be denoted A' = StepOne(A) and B = SetExp(A) = StepTwo(A'), respectively.

First step of SetExp
Definition 4.1 In a TA A: a path is a transition or sequence of consecutive transitions of A.
Definition 4.2 In a TA A: a transition T ' is said reachable from a transition



Fig. 2. Example of SEA
T iff A contains a path T ··· T '.
Remark 4.1 In Def. 4.1 the guards of transitions are not taken into account, and thus, a path can be unexecutable. Therefore in Def. 4.2, “reachability of transition” is actually an abuse of the language. We need this non-standard deﬁnition to deﬁne in a simple way Substep 1a (in Sect. 4.1).
Notations 4.1 In a TA A:
঩T denotes the set of transitions that are reachable from a transition T .
℘T →T ' denotes the set of paths between two transitions T and T ', excluding T and T '. That is, ℘T →T ' contains every path T1 ··· Tm such that: the destination location of T is the origin location of T1, and the origin location of T ' is the destination location of Tm.
ZP is the set of clocks that are reset in a path P.
ZT denotes the set of clocks that are reset in T .
GT denotes the guard of T .
Since Step 1 replaces the resets of transitions by Set events and rewrites the guards of transitions in the form of order constraints relatively to Exp events, we will use the following Notations 4.2:
Notations 4.2 For a transition T of a TA A:
ZT is the set of Set events associated to T , and
ZT (ci ) is the part of ZT using ci.
GT is the rewritten guard associated to T , and

GT (ci ) is the part of GT using ci.
Notations 4.3 In a formal expression: Symbol “:=” denotes an assignment; and Symbol “:” have two possible meanings:
In a deﬁnition of a set, {A : B} denotes the set of A such that B is satisﬁed. Example: {(x, y) : x > y} is the set of pairs (x, y) s.t. x > y.
An expression “∀A : B” means that B is applied whenever A is satisﬁed. Example: ∀x > 3 : A[x] := 0 means that A[x] is set to zero ∀x > 3.



Substep 1a: replacing clock resets by Set events
In a TA, a clock c is reset with the objective to compare later its value to (at least) one constant, say k. The event Set(c; k ) is very convenient for that purpose, because it resets c and programs Exp(c; k ) which is a notification when c = k. The aim of Substep 1a is indeed to replace by Set(ci ; k ), each reset of ci if it is compared later to k before a subsequent reset. If for the same transition, we obtain several Set(ci ; k1 ), Set(ci ; k2 ), ·· ·, we replace them by a single Set(ci ; k1 , k2 , ·· ·). Without loss of generality, we consider that k1 < k2 < ·· ·. Here is a formal definition of Substep 1a:

Note that ZT (ci ) is either empty if ci /∈ ZT , or a singleton {Set(ci ; ∗)} if
ci ∈ ZT .



Substep 1b: rewriting the guards
Every guard ci ∼ k is rewritten in the form ∼ Exp(ci ; k ). Formally:
If we apply Step 1 to the TA A of Fig. 1, we obtain the StepOne(A) of Fig. 3. Labels are represented in one or two lines. The first line contains the event of the transition and Set event(s) if any. The second line contains the rewritten guard(s) if any.



Fig. 3. Step 1 applied to the TA of Fig. 1

Second step of SetExp
Step 2 transforms A' = StepOne(A) into a SEA B = SetExp(A) = StepTwo(A'). B describes explicitly all the possible sequences of events, in- cluding Set and Exp events in addition to the events of the alphabet of A.

States of SEA
Each state of a SEA is defined by a location and inequation(s) of clock(s). The latter definition, which we call state deﬁnition and present in this subsection, is not necessary for defining the syntax and semantics of a given SEA; but it is useful for algorithmic purpose, during the construction of SetExp(A) from StepOne(A). Once SetExp(A) constructed, this state definition can be ignored. Here are a few necessary definitions.
Definition 5.1 Clock ci is active when at least an expiration of ci is expected. More precisely, while a Set(ci ; k1 , ··· , kp) is the last Set(ci ; ∗) that has oc- curred: ci is active iff Exp(ci ; kp) has not occurred. Otherwise, ci is inactive.
Note that the set of current active clocks depends on the current time and on the history of the automaton up to the current time.
Definition 5.2 For a Set (ci ; k1 , ··· , kp), a Clock-Cond is an expression in one of the following three forms, for 1 ≤ u < p:
“0 < ci < k1”, which holds between Set(ci ; k1 , ··· , kp) and Exp(ci ; k1 ); “ku < ci < ku+1”, which holds between Exp(ci ; ku) and Exp(ci ; ku+1 ); and “kp < ci”, which holds after Exp(ci ; kp).
Definition 5.3 For a Set (ci ; k1 , ··· , kp), an ExpSeq is a sequence kuku+1 ··· kp, for 1 ≤ u ≤ p; it speciﬁes:
if u > 1: the remaining values to which ci will expire after Exp(ci ; ku−1 );
if u = 1: the values to which ci will expire after Set(ci ; k1 , k2 , ··· , kp).
Definition 5.4 A ∆Clock-Cond is an expression in one of the following four forms, where m, m1, m2 are integers (they can be positive, negative, or null):

“ci − cj < m2”, “m1 < ci − cj”, “m1 < ci − cj < m2”, and “ci − cj = m”.
Let A be a TA and B = SetExp(A) be the corresponding SEA to be computed. A state deﬁnition of a state q of B consists of three parts:
Part 1 indicates the location of A that corresponds to q, and is noted Lq .
Part 2 consists of a Clock-Cond and an ExpSeq for each clock in C. More precisely, for each ci, Part 2 contains (Cq(ci ), Kq (ci )) which is in one of the following forms, considering that Set(ci ; k1 , k2 , ··· , kp) is the last Set event of ci before q is reached:
If q is reached before Exp(ci ; k1 ):
Cq (ci ) = (0 < ci < k1),  Kq(ci ) = (k2k3 ··· kp).
If q is reached between Exp(ci ; ku ) and Exp(ci ; ku+1 ), u = 1, ··· ,p − 2:
Cq (ci ) = (ku < ci < ku+1),	Kq(ci ) = (ku+2 ··· kp).
If q is reached between Exp(ci ; kp−1 ) and Exp(ci ; kp):
Cq (ci ) = (kp−1 < ci < kp),	Kq (ci ) = ϵ (i.e., it is empty).
If q is reached after Exp(ci ; kp): Cq (ci ) = (kp < ci),	Kq (ci ) = ϵ.
Note that ci is active in the three first cases, and inactive in the fourth case.
Part 3 consists of zero or one ∆Clock-Cond ∆Cq (ci , cj ) for each pair of clocks
ci, cj ∈ C.
Notations 5.1 To recapitulate, a state q of B = SetExp(A) is deﬁned by three parts, which we note q = ⟨Lq , Cq, ∆Cq ⟩. Lq is a location; Cq is a Nc- tuple of pairs (Cq(ci ); Kq (ci )), for i = 1, ··· , Nc, where Cq(ci ) is a Clock-Cond and Kq (ci ) is an ExpSeq; and ∆Cq is a set of ∆Clock-Conds.
The usefulness of the three parts can be explained as follows:
The location Lq is used to determine the transitions of A that are candidate in q, which are the outgoing transitions of Lq in A.
Clock-Conds of q are used to determine:
-the transitions of A that are enabled in q (among the candidate ones), and
-the expected next expiration (if any) of each clock.
ExpSeqs of q are used to determine the Clock-Conds and ExpSeqs of the state reached by each transition of A that is enabled in q.
∆Clock-Conds of q are used to determine the expirations (or set of simul- taneous expirations) that can really occur at q, among the expected ones determined from Clock-Conds of q. Therefore when all the clocks are inac- tive, ∆Clock-Conds are irrelevant, and thus, Part 3 is empty.
When an expiration (or set of expirations) can occur in q, we obtain an enabled transition of type 1. When an event σ labelling a transition of A can occur in q, we obtain an enabled transition of type 2. And when expiration(s) and a σ


can occur simultaneously, we obtain an enabled transition of type 3.
The state definition for the SEA of Fig. 2 is represented in Fig. 4. ExpSeqs are empty, and thus not represented, because in every Set(ci ; ∗), ∗ consists of a single value.






















Fig. 4. Example of SEA with state definition

Principle of construction of SEA
Let A' = StepOne(A) be the automaton computed in the first step (see Sect. 4). The principle of construction of B = StepTwo(A') from A' is as follows:
First of all, we construct its initial state q0 = ⟨l0 , C0 , −⟩ where: l0 is the initial location of A', C0 is the Nc-tuple of pairs (0 < ci; ϵ), for i = 1, ··· , Nc. “0 < ci” and ϵ are a Clock-Cond and an empty ExpSeq, respectively; they mean that ci has been reset and no expiration is expected, i.e., ci is initially inactive. There is no ∆Clock-Cond because all clocks are inactive.
Then, we proceed iteratively as follows until no new state or transition is constructed: For every constructed state q, we determine every event or set of (simultaneous) events that can label a transition (of type 1, 2 or 3) enabled in q. And for every determined (enabled) label l, we construct: the state r reached by l from q, and the corresponding transition.
We see that this iterative process requires to determine if a label is enabled in a state, and to compute the state reached by an enabled label and the corresponding transition. Here are some related notations and definitions:


Notations 5.2 (OUT (l ), EXP (q ), ) : 
For a location l of A' (= StepOne(A)), OUT (l ) denotes the set of labels of the outgoing transitions of l, including the empty label noted .
If in a state q of SEA, cu1 , cu2 , ··· , cup are the active clocks and Exp(cui ; kui )
is the expected next expiration of cui , for i = 1, ··· , p, then: EXP (q ) = {Exp(cu1 ; ku1 ), ··· , Exp(cup ; kup )}.
Let q be a state of the SEA B = StepTwo(A') and l ∈ (2 EXP(q) ×
OUT (Lq )) \ {(∅, )} be a label of a transition of type 1, 2 or 3.
Definition 5.5 l is said to be enabled in q, which we note (q →l )!, iff it is possible that at a same time in q, all the events of l occur simultaneously before any other event.
Definition 5.6 Assuming (q →l )!, we can deﬁne the state reached from q after the occurrence of l, which we note (q →).
In Sect. 5.3, we explain in a formal way how to determine whether (q →l )! and how to compute the state (q →l ). Subsection 5.3.1 (resp. 5.3.2) corre- sponds to the case where l labels a transition of Type 1 (resp. Types 2 and 3). The reader who is not interested by these details, may directly go to Sect. 5.4 which presents in a formal way the iterative process of SEA construction.

Construction of states and transitions
From Sect. 3.3, a transition TR of B is labeled: E if TR is of Type 1, lT if TR is of Type 2, and (E , lT ) if TR is of Type 3; where lT is in the form (σ) or (σ, S). Recall that if TR is of Type 2 or 3, then it has a corresponding transition in A' (and A). The index T in lT indicates that: T is the transition in A' (and A) corresponding to TR, and lT consists of σ and Set events (if any) that label T in A'. The general form of a label of a transition TR of SEA can be written (E , lT ) where: lT =  if TR is of Type 1, and E = ∅ if TR is of Type 2.
Notations 5.3 :
Let X be a system of linear equations and inequations using a set of variables x1, x2, ··· , xN .	A nonnegative solution of X is any N-tuple (a1, a2, ··· , aN ) that satisﬁes X, where ai is a nonnegative value of xi. Let Sol≥0 (X ) denote the set of nonnegative solutions of X.
If S = e1e2 ··· en is a sequence, then:
|S| denotes the length of S (i.e., |S| = n),
S [i ] denotes the ith element of S (i.e., S [i ] = ei),

S [/ i] is obtained from S by removing the ith element of S.
Let ci and cj be two clocks, and ∆C1 and ∆C2 be two ∆Clock-Conds using ci — cj (see Def. 5.4). ∆C1 H∆C2 is obtained by combining ∆C1 and ∆C2 into a single ∆Clock-Cond that corresponds to the conjunction of ∆C1 and
∆C2. For example, if ∆C1 = (m1 < ci—cj < m2) and ∆C2 = (m < ci—cj), then the result of combination is max(m1, m) < ci — cj < m2.
Let ci and θi be two clocks, and C be a Clock-Cond using ci. C ⟨ci '→ θi — ci⟩ is obtained from C by replacing ci by θi — ci.
Let ∆C be a set of ∆Clock-Conds, and θi be a clock possibly used in ∆C.
∆C ⟨/ θi⟩is obtained from ∆C by eliminating θi (if any) from ∆C by rewrit- ing its ∆Clock-Conds. For that purpose, every pair of ∆Clock-Conds in
∆C that use a θi, are added with each other in order to eliminate θi. The addition of two ∆Cr (θi , cj ) and ∆Cr (θi , ck ) for the elimination of θi is re- alized as follows: 1) ∆Cr (θi , cj ) is expressed using θi — cj; 2) ∆Cr (θi , ck ) is expressed using ck — θi; 3) the members of the two ∆Clock-Conds are added in order to obtain a ∆Clock-Cond expressed using ck — cj; 4) the obtained ∆Clock-Cond is combined with ∆Cr (cj , ck ), if any.
If θi is used in a single ∆Clock-Cond, the elimination consists of removing this ∆Clock-Cond.

Study of transitions labeled (S) (i.e., of Type 1)
Let q be a state of the SEA B = StepTwo(A') and S be a set of expirations.
Let X be the following system of inequations (formally described as a set
of inequations) where the variables are clocks:
X = ∆Cq ∪ {ci — ki < 0 : Exp(ci ; ki ) ∈ S}
∪ {ci — ki = cj — kj : Exp(ci ; ki ), Exp(cj ; kj ) ∈ S}
∪ {ci — ki < cj — kj : Exp(ci ; ki ) ∈ EXP (q ) \ S , Exp(cj ; kj ) ∈ S}
The following lemma can be used to determine whether S is enabled in q. It states that S is enabled in q iff : each Exp(ci ; k ) ∈ S is the expected next expiration of ci, and X has nonnegative solutions.
Lemma 5.1 4 (q →E )! e (S ⊆ EXP (q ) and Sol	(X ) /= ∅).
When S is enabled in q (noted (q →E )!), let us express formally the procedure for computing the state r, noted (q →E ), reached from q after the occurrence of S:

4 Proof in Section A.1



Let us give some explanations of the above computation of (q →E ):
Line 1 : r is initialized with q.
Lines 2-4 : For each Exp(ci ; k ) ∈ S, the aim is to update Cq (ci ) and Kq (ci ).
Line 2 : We consider the case where an Exp(ci ; k ) ∈ S is the last expected expiration of ci. The assignment models the fact that Exp(ci ; k ) has occur- rred and that no other expiration of ci is foreseen.
Lines 3-4 : We consider the case where: Exp(ci ; k ) is the expected next expiration of ci, and another Exp(ci ; k ') becomes expected after Exp(ci ; k ). In Line 3 the assignment models the fact that Exp(ci ; k ) has occurred and that Exp(ci ; k ') is the expected new expiration. (k' is indicated by Kr (ci )[1 ].) In Line 4 , k' is removed from Kr (ci ) because Kr (ci ) is a se- quence that specifies the values to which ci will expire after its next expi- ration Exp(ci ; k ').
Line 5 : Let τ be the time of occurrence of S. For every Exp(ci ; ki ) ∈ S, ci — ki = 0 at time τ . Therefore for every Exp(ci ; ki ) and Exp(cj ; kj ) ∈ S, ci — ki = cj — kj = 0 at time τ . Since all the clocks increase at the same rate, ci — ki = cj — kj (i.e., ci — cj = ki — kj) is also satisfied before and after τ . This equality replaces ∆Cq (ci , cj ). Intuitively, from the observation of the simultaneity of Exp(ci ; ki ) and Exp(cj ; kj ), we can replace ∆Cq (ci , cj ) by a more precise information.
Lines 6-7 : Let τ be the time of occurrence of S. For every Exp(ci ; ki ) ∈ S, ci — ki = 0 at time τ . For every Exp(cj ; kj ) ∈ EXP (q ) \ S, cj — kj < 0 at time τ , because we are in the case where the expirations of EXP (q ) \S occur after S. This case is possible because S is enabled in q. Therefore cj — kj < ci — ki at time τ . Since all the clocks increase at the same rate, cj — kj < ci — ki (i.e., ki — kj < ci — cj) is also satisfied before and after τ . This ∆Clock-Cond is combined with ∆Cq (ci , cj ). For example, if
∆Cq (ci , cj ) is in the form m1 < ci — cj < m2, then the result of combination
is max(m1, ki — kj) < ci — cj < m2. Intuitively, from the observation that
Exp(ci ; ki ) is before Exp(cj ; kj ), we replace ∆Cq (ci , cj ) by a more precise


information.
Line 8 : ∆Cr is emptied when all the clocks are inactive, because in this case ∆Clock-Conds are irrelevant (and thus, useless).

Study of transitions of types 2 and 3
Let q be a state of the SEA B = SetExp(A) = StepTwo(A'), lT consist of σ and Set events (if any) that label a transition T in A', and S be a set of expiration(s).
The following lemma can be used to determine whether lT is enabled in q.
Lemma 5.2 5 (q →lT )! iff:
lT ∈ OUT (Lq );
∀“<Exp(ci ; k )” or “≤ Exp(ci ; k )” ∈ GT , ∃k' ≤ k such that Cq(ci ) = (u < ci < k');
/ ∃“= Exp(ci ; k )” ∈ GT ;
∀“>Exp(ci ; k )” or “≥ Exp(ci ; k )” ∈ GT , ∃k' ≥ k such that Cq(ci ) = (k' < ci < u) or Cq (ci ) = (k' < ci).
The following lemma can be used to determine whether (S , lT ) (i.e., label of a transition of Type 3) is enabled in q:
Lemma 5.3 6 (q E ,lT )! iff:
lT ∈ OUT (Lq );
(q →E )!;
∀“<Exp(ci ; k )” ∈ GT : Exp(ci ; k ) /∈ S , and
∃k' ≤ k such that Cq(ci ) = (u < ci < k');
∀“≤ Exp(ci ; k )” ∈ GT , ∃k' ≤ k such that Cq (ci ) = (u < ci < k');
∀“= Exp(ci ; k )” ∈ GT : Exp(ci ; k ) ∈ S , and Cq (ci ) = (u < ci < k);
∀“>Exp(ci ; k )” ∈ GT , ∃k' ≥ k such that
Cq(ci ) = (k' < ci < u) or Cq (ci ) = (k' < ci);
∀“≥ Exp(ci ; k )” ∈ GT :
∃k' ≥ k such that Cq (ci ) = (k' < ci < u) or Cq(ci ) = (k' < ci); or
Exp(ci ; k ) ∈ S and Cq(ci ) = (u < ci < k).
Let TR be a transition labeled (S , lT ) of Type 2 or 3 (S = ∅ if TR is

of Type 2). When (S , lT
) is enabled in q (noted (q (E ,lT ))!), let us express



5 Proof in Section A.2
6 Proof in Section A.3


formally the procedure for computing the state v, denoted (q E ,lT ), reached
from q after the execution of TR:

Let us give some explanations of the above computation of (q E ,lT ).
Lines 1 and 14 : The simultaneity of S and T is conceptually equivalent to the execution of S which is immediately followed by T . We first determine the intermediate (virtual) state v reached from q after the execution of S. We compute v by using (q →E ) without its last Line 8 . The latter is used at the end of (q E ,lT ) (in Line 14 ) because it is used only to finalize the computation of a “real” state. The aim of Lines 1-13 is to determine the (real) state v reached from v after the execution of T . In (q E ,lT ), v and v are indicated by the same variable v, because the intermediate state is directly modified for obtaining the final reached state. For the sake of clarity, in the following explanations, the two states are indicated differently by v and v.
Lines 2-13 are executed only if lT /= , because when lT = , the transition is of Type 1 and the reached state (q →E ) is computed by Lines 1 and 14 (i.e., the procedure of Sect. 5.3.1). The following explanations assume lT /= .
Line 2 : The location of the reached state is the destination location of T .
Lines 3-13 : If T resets no clock, then T has no influence on the values of clocks and State v is determined by Lines 1, 2 and 14. The aim of Lines 3-13 is to compute the effect of the resets of T on v.
Lines 3-11 : The aim is to compute the effect on v, of the reset of each clock.


Line 4 : For every ci that is reset by T , we use a fictitious clock θi that is equal to ci (before the reset of ci) and that is not reset by T . Therefore, all the ∆Clock-Conds using ci that were satisfied before T , will continue to be satisfied after T if we replace ci by θi.
Line 5 : Let τ be the time when T is executed and ci is reset. If ci does not expire at time τ , then Cv (ci ) is satisfied before the reset of ci and would be satisfied at instant τ if ci was not reset. At time τ , θi has the value ci would have if it was not reset, and ci is null. Therefore at time τ , θi — ci has the value ci would have if it was not reset. And since θi — ci is constant from τ and before another reset of ci, we deduce that in this period, θi — ci has the value ci would have at time τ if it was not reset. Therefore, Cv (ci ) is satisfied after T if we replace ci by θi — ci. This information is inserted into ∆Cr .
Line 6 : Let τ be the time when T is executed. θi = k at time τ because Exp(ci ; k ) occurs at time τ , and ci = 0 at time τ because ci is reset at time τ . Therefore, θi — ci = k at time τ . Since θi — ci is constant from τ and before another reset of ci, we deduce that θi — ci = k in this period. This informa- tion is inserted into ∆Cr .
Lines 7-9 are associated to a ci reset by T and consider every cj not reset by T .
Line 8 : Let τ be the time when T is executed and ci is reset. If cj (not reset by T ) does not expire at τ , then Cv (cj ) is satisfied at time τ . At time τ , cj — ci has the value of cj, because ci is reset at time τ . Since cj — ci is constant from τ and before another reset of ci or cj, we deduce that in this period, cj — ci has the value that cj has at time τ .
Therefore, Cv (cj ) is satisfied after T if we replace cj by cj — ci. This information is inserted into ∆Cr .
Line 9 : Let τ be the time when T is executed. cj = k at time τ because Exp(cj ; k ) occurs at time τ , and ci = 0 at time τ because ci is reset at time τ . Therefore cj — ci = k at time τ . Since cj — ci is constant from τ and before another reset of ci or cj, we deduce that cj — ci = k in this period. This information is inserted into ∆Cr .
Lines 10-11 : We insert in Cr the Clock-Cond that specifies the status of ci just after its reset. If Set(ci ; k1 , ··· , km) is the Set event of ci that is associated to T , then: in Line 10 we insert the information that ci has been reset and that its next foreseen expiration is Exp(ci ; k1 ), and in Line
11 we insert the information which specifies the expirations of ci that are foreseen after Exp(ci ; k1 ).
Line 12 : we insert into ∆Cr the information that the clocks reset by T are


equal with each other after the execution of T .
Line 13 : The use of θi is just a trick to deal with clocks that are reset while they are active. Now, we can eliminate every θi from ∆Cr . For that purpose, every pair of ∆Clock-Conds in ∆Cr that use a θi, are added with each other in order to eliminate θi. (See Item 7 in Notations 5.3 for more details about elimination of θi.)

Construction of SEA
The principle of the iterative procedure for computing B = StepTwo(A') (where A' = StepOne(A)) is explained in 5.2. The basis of this procedure can be formally expressed by the following fixpoint characterization:
Let us set the SEA B0 = (Q0, Γ0, δ0, q0) = ({q0}, ∅, ∅, q0), where q0 has been specified in Sect. 5.2. And let us consider the suite of SEA Bi = (Qi, Γi, δi, q0), defined by Bi+1 = Ω(Bi), for i ≥ 0, where the operator Ω: SEA→ SEA is defined by:

Q  = Q ∪ {(q →l ) : q ∈ Q ,l ∈ (2 EXP(q) × OUT (L )) \ {(∅, )}, (q →l )!}
δ	= δ ∪ {q —→l	r : q ∈ Q , (q →l )!,v = (q →l ) ∈ Q	}

Γi+1
= Γ ∪ {l : E(q —→l
r ) ∈ δi+1}

In the above expressions of δ	and Γ	, q —→l
state q to state v which is labeled l.
r denotes a transition from

Lemma 5.4 7 Ω has a ﬁxpoint that is obtained after a finite number of iter- ations. Formally: Ep ≥ 0 s.t. 6n ≥ p: Bn = Bp.
The SEA B = StepTwo(A') is indeed the fixpoint of Ω.

Correctness and properties of SetExp
Correctness
In this section, we present a theorem which states correctness of SetExp.
Let LSEA denote the regular language of a SEA B. Each sequence of LSEA
B	B
is in the form “E1E2 ··· Ei ·· ·”, where each Ei is the label of a transition of B,
and thus, consists of one event or several (simultaneous) events (see Sect. 3.3).
Definition 6.1 The timed language of a SEA B (TLSEA) is deﬁned as follows, where τi are real values: (E1, τ1)(E2, τ2) ··· ∈ TLSEA iff:

7 Proof in Section A.4

E1E2 ··· ∈ LSEA (see Def. 3.1),	0 < τ1 < τ2 < ·· ·,	and
6Ei, Ej, i < j: If Ei contains Set(c; k ), Ej contains Exp(c; k ), and
no Em (i < m < j) contains Set (c; ∗),
Then: τj = τi + k.
That is, TLSEA contains every timed sequence obtained from a sequence of

SEA B
by: associating a time to each event, and respecting the consistency

condition (i.e., each Set(c; k ) and corresponding Exp(c; k ) are separated by
the delay k).
Definition 6.2 A TA A is said equivalent to a SEA B iff TLTA (see Def. 2.1) is obtained from TLSEA by removing all the Set and Exp events.
Intuitively, a TA A is equivalent to a SEA B iff the behaviors of A and B cannot be differentiated by an observer who does not see (or ignores) Set and Exp events.
Theorem 6.1 8 Every TA A is equivalent to its corresponding SEA SetExp(A).
Theorem 6.1 states correctness of SetExp and implies the possibility to transform a study of a system modelled by a TA A into a non-real-time form (i.e., SetExp(A)), and thus, we can adapt non-real-time methods of study. This idea has been used in conformance testing [7,10] and supervisory con-
trol [11,8,9].  Therefore, this theorem confirms correctness of the methods in [7,10,11,8,9].

Properties
Property 6.1 (General property) If in a TA, we multiply by the same value K all the constants used in the guards, the results of Steps 1 and 2 are not modiﬁed, modulo the multiplication by K of every constant used in a Set or Exp event.
Property 6.1 can be intuitively justified as follows: multiplying all the con- stants of guards by the same value is equivalent to changing the unit of time, which has no influence on the generation of Set and Exp events. Here is a
mathematical justification: multiplying by the same value all the constants of guards, implies multiplying by the same value all the constants of the inequa- tions (Clock-Conds, ∆Clock-Conds) defining the states of SEA, which has no influence on the solutions of these inequations.
Property 6.1 is interesting because: (i) state space in the obtained SEAs does not increase when we multiply by the same value all the constants used in the transitions’ guards, and (ii) if SetExp has been applied to generate a SEA

8 Proof in Section A.5


B from a TA A, we can deduce straightforwardly every SEA corresponding to any TA A' that is similar to A modulo a multiplication of constant(s) used in guards.
We define now a more interesting property but that holds only for certain TA, for instance the TA of Fig. 1, and we consider a class of TAs for which this property holds.
Property 6.2 (Property of a class of TA) We consider a class of TAs such that for every TA A of this class: let k1, k2, ··· , kp (where ki < ki+1, for i = 1, 2, ··· p — 1) be all the constants used in the guards of A.
If every ki is replaced by mi such that mi < mi+1, for i = 1, 2, ··· p — 1, Then the SEA SetExp(A) is not modiﬁed, modulo the replacement of every ki by mi.
Property 6.2 holds for the TA of Figure 1, that is, if we replace the three values 1, 2, 3 used in the guards of the transitions, by any other integer values k, m, n respectively, such that k < m < n, the results of Figures 3 and 4 are not modified, modulo the replacement of 1, 2, 3 by k, m, n in Set and Exp events.
Note that we have studied several examples, and this property is satisfied in most of them.
Property 6.2 is more interesting than Property 6.1 because it does not restrict the modification of constants of guards by multiplying all of them by the same value. The determination of a class of TA in which Property 6.2 holds, is not trivial and we intend to study it in a near future.
Remark 6.1 (About Property 6.2)
In all the examples of TA we have studied, we note that, even for a TA where Property 6.2 does not hold, the state space of the corresponding SEA can change but its size does not increase signiﬁcantly with the magnitudes of constants used in guards.
Properties 6.1 and 6.2, and Remark 6.1 show an advantage of using SEA instead of RA. In fact, contrary to RA, in practice the state space of SEA does not increase with the magnitudes of the constants used in timing constraints.
We have used the term “in practice” because Remark 6.1 holds for all the examples we have studied, but we have no guarantee that it holds for every TA. We intend to study this aspect in a near future.
Let us now give an upper bound of the number of states of a SEA B obtained from a TA A (i.e., B = SetExp(A)). Let k be the greatest constant used in timing constraints. For each clock ci, let us consider the distinct Set events associated to ci, and let pi,j be the nΣumber of constants in each of these Set
events, for j = 1, ·· ·. Let then pi =	j=1,··· pi,j and p = maxi=1,···,Nc pi. And
recall that |L| and |C| are the numbers of locations and clocks of A, respectively.


Lemma 6.1 9 |L|p|C|2k|C|2 is an upper bound of the number of states of B.
Lemma 6.1 presents a coarse upper bound which is never reached. We intend in a near future to compute a more accurate upper bound.

Conclusion
We propose a method SetExp that transforms a TA A into an equivalent SEA B which uses two types of events: Set and Exp, in addition to the events of the TA. A and B are equivalent , in the sense that they specify the same order and timing constraints. Applicability of SetExp has been demonstrated in [7,10,11,8,9], where SetExp is used as a black-box. In the present study, we show how SetExp can be realized.
In the near future, we intend to investigate the following issues:
A software tool implementing SetExp has been recently realized. We intend to use this tool to implement a conformance testing method based on [10] and a supervisory control method based on [9].
In the architectures proposed in [7,10,11,8,9], SetExp is applicable for cen- tralized systems. It would be interesting to design a transformation appli- cable for distributed systems.
The state space of SEA increases exponentially with the number of clocks, and in practice this state space does not increase significantly with the magnitudes of the constants used in timing constraints. It is interesting to quantify more rigorously how the state space increases with the magnitudes
of constants. And it is also interesting to study more rigorously the com- plexity of SetExp in terms of memory and time that are necessary for the computation of SEA.
Determination of a class of TA for which Property 6.2 is satisfied.
For the sake of simplicity, we have considered only TA without invariants. We intend to develop an extension of SetExp supporting invariants.

References
Alur, R., Timed automata, in: Proc. 11th Intern. Conf. on Comp. Aided Verif. (CAV) (1999),
pp. 8–22.
Alur, R., C. Courcoubetis and D. Dill, Model checking for real-time systems, in: Proc. IEEE Sympos. on Logic in Computer Science, 1990.
Alur, R., C. Courcoubetis, N. Halbwachs, D. Dill and H. Wong-Toi, Minimization of timed transitions systems, in: CONCUR (1992), pp. 340–354.

9 Proof in Section A.5.1


Alur, R. and D. Dill, A theory of timed automata, Theoretical Computer Science 126 (1994),
pp. 183–235.
Kang, I. and I. Lee, State minimization for concurrent system analysis based on state space exploration, in: Proc. Conf. On Computer Assurance, 1994, pp. 123–134.
Kang, I. and I. Lee, An efficient state space generation for analysis of real-time systems, in:
Proc. Intern. Sympos. on Soft. Testing and Analysis (ISSTA’96), 1996.
Khoumsi, A., A method for testing the conformance of real time systems, in: Proc. 7th Intern. Sympos. on Formal Techn. in Real-Time and Fault Toler. Systems (FTRTFT), Oldenburg, Germany, 2002,
http://www.gel.usherb.ca/khoumsi/Research/Public/FTRTFT02.ps.
Khoumsi, A., Supervisory control of dense real-time discrete-event systems with partial observation, in: Proc. 6th Intern. Workshop on Discrete Event Systems (WODES), Zaragoza, Spain, 2002,
http://www.gel.usherb.ca/khoumsi/Research/Public/WODES02.ps.
Khoumsi, A., Supervisory control for the conformance of real-time discrete-event systems, in: Proc. 7th Intern. Workshop on Discrete Event Systems (WODES), Reims, France, 2004, http://www.gel.usherb.ca/khoumsi/Research/Public/WODES04.ps.
Khoumsi, A., T. J´eron and H. Marchand, Test cases generation for nondeterministic real-time systems, in: Proc. Formal Approaches to TEsting of Software (FATES), LNCS 2931 (2003), http://www.gel.usherb.ca/khoumsi/Research/Public/FATES03.ps.
Khoumsi, A. and M. Nourelfath, An efficient method for the supervisory control of dense real- time discrete event systems, in: Proc. 8th Intern. Conf. on Real-Time Computing Systems (RTCSA), Tokyo, Japan, 2002, http://www.gel.usherb.ca/khoumsi/Research/Public/RTCSA02-Cont.ps.
Ramadge, P. and W. Wonham, The control of discrete event systems, Proc. IEEE 77 (1989),
pp. 81–98.
Tretmans, J., Test generation with inputs, outputs and repetitive quiescence, Software-Concepts and Tools 17 (1996).
Tripakis, S. and S. Yovine, Analysis of timed systems based on time-abstracting bisimulations, in: Proc. 8th Intern. Conf. on Comp. Aided Verif. (CAV) (1995), pp. 229–242.
Yannakakis, M. and D. Lee, An efficient algorithm for minimizing real-time transition systems, in: Proc. 5th Conf. on Comp. Aided Verif. (CAV) (1993), pp. 210–224.

Proofs
In the following, by “is satisfied”, we mean “evaluates to True”.

Proof of Lemma 5.1
Let us define :
X1 = {ci — ki < 0 : Exp(ci ; ki ) ∈ S},
X2 = {ci — ki = cj — kj : Exp(ci ; ki ), Exp(cj ; kj ) ∈ S},
X3 = {ci — ki < cj — kj : Exp(ci ; ki ) ∈ EXP (q ) \ S , Exp(cj ; kj ) ∈ S}. We have therefore : X = ∆Cq ∪ X1 ∪ X2 ∪ X3.
Since all the clocks progress at the same rate, the system X1 ∪ X2 ∪ X3 has positive solutions iff with the passing of time and if no clock is reset, the following items 2 and 3 will be satisfied simultaneously.
6Exp(ci ; ki ) ∈ S : ci — ki = 0.
6Exp(cj ; kj ) ∈ EXP (q ) \S : cj — kj < 0.
Item 2 holds when and only when the expirations of S occur simultane- ously.
Item 3 holds while and only while no expiration of EXP (q ) \S has oc- curred.
Items 1, 4 and 5 mean that the system X1 ∪X2 ∪X3 has positive solutions iff at the same future instant of time and if no clock is reset: all the expirations of S occur and no expiration of EXP (q ) \S occurs.
Item 6 implies that the system X = ∆Cq ∪ (X1 ∪ X2 ∪ X3) has positive solutions iff ∆Cq allows that at a same future time : all expirations of S occur and no expiration of EXP (q ) \S occurs.	 

Proof of Lemma 5.2
Item 3 of Lemma 5.2 means that every guard of T is in one of the following forms : “<Exp(ci; k )”, “≤ Exp(ci ; k )”, “>Exp(ci ; k )”, “≥ Exp(ci ; k )”.
Items 2 and 4 of Lemma 5.2 mean that every guard of T is satisfied in q
if it is in one of the following forms :
“<Exp(ci; k )”, “≤ Exp(ci ; k )”, “>Exp(ci; k )”, “≥ Exp(ci ; k )”.
The above Items 1 and 2 mean that every guard of T is satisfied in q.
Item 1 of Lemma 5.2 and the above Items 1 and 3 mean that T can be executed at any time in q, without being simultaneous to any expiration. 


Proof of Lemma 5.3
In Item 3 of Lemma 5.3 :
“Cq(ci ) = (u < ci < k'), for k' ≤ k” means that every guard “<Exp(ci; k )” of T is satisfied in q;
“Exp(ci; k ) /∈ S” and Item 2 of Lemma 5.3 implies that such a guard “<Exp(ci; k )” remains satisfied at the occurrence of S.
In Item 4 of Lemma 5.3 :
“Cq(ci ) = (u < ci < k'), for k' ≤ k” implies that every guard “≤ Exp(ci ; k )” of T is satisfied in q;
“Cq(ci ) = (u < ci < k'), for k' ≤ k” and Item 2 of Lemma 5.3 imply that S occurs before or contains Exp(ci ; k ').
The above a) and b) imply that every guard “≤ Exp(ci ; k )” of T is and
remains satisfied at the occurrence of S.
Item 5 of Lemma 5.3 means that with the passing of time, every guard “= Exp(ci; k )” of T will be satisfied when and only when ci = k, i.e., simultaneously to Exp(ci ; k ) ∈ S.
Item 6 of Lemma 5.3 means that every guard “>Exp(ci ; k )” of T is satisfied in q. This guard remains satisfied at the occurrence of any expiration, and thus, at the occurrence of S.
In Item 7 of Lemma 5.3, for every guard “≥ Exp(ci ; k )” of T :
	“Cq (ci ) = (k' < ci < u) or Cq (ci ) = (k' < ci), for k ≤ k'” implies that “≥ Exp(ci ; k )” is and remains satisfied at the occurrence of S.
“Exp(ci ; k ) ∈ S and Cq(ci ) = (u < ci < k)” implies that “≥ Exp(ci ; k )” will be satisfied when and only when ci = k, i.e., simultaneously to Exp(ci ; k ) ∈ S.
Item 7 of Lemma 5.3 means a) or b) holds.
In the above Items 1, 2, 3, 4, 5a, and 5b, all the guards of T are consid- ered.
The above items 1, 2, 4, and 5a correspond to the guards of T that are satisfied in q. These guards remain satisfied at the occurrence of S.
The above items 3 and 5b correspond to the guards of T that will be satisfied with the passing of time. Each of these guards will be satisfied simultaneously to an Exp event of S.
Item 2 of Lemma 5.3 and the above Item 8 mean that the guards of T that will be satisfied with the passing of time, can all be satisfied at the same time, simultaneously to S.
The above items 6, 7 and 8 mean that there is no non-satisfied guard of
T that will not be satisfied with the passing of time.


The above items 7, 9, and 10 and Item 1 of Lemma 5.3 mean that the simultaneous executions of T and S is possible in q.	 

Proof of Lemma 5.4
We have defined the suite Bi+1 = Ω(Bi), for i ≥ 0. Let Qi, Γi, δi be such that
Bi = (Qi, Γi, δi, q0). We have, by definition of the operator Ω (see Sect. 5.4):
Qi+1 = Qi ∪ ∆Qi,	δi+1 = δi ∪ ∆δi,	Γi+1 = Γi ∪ ∆Γi, where :
∆Q = {(q →l ) : q ∈ Q ,l ∈ (2 EXP(q)×(OUT (L ) ∪ { }))\{(∅, )}, (q →l )!}
i	i	q
∆δ = {q —→l	r : q ∈ Q , (q →l )!,v = (q →l ) ∈ Q	}

∆Γ = Γ ∪ {l : E(q —→l
r ) ∈ δi+1}.

We will also use the notation |U| for the cardinal (i.e., number of elements) of
a set U . In order to prove Lemma 5.4, let us prove the following five lemmas :
Lemma A.1 6i ≥ 0 : Qi ⊆ Qi+1.
Lemma A.2 6p ≥ 0 : ((Qp = Qp+1) ⇒ (Bp+2 = Bp+1)).
Lemma A.3 6p ≥ 0 : ((Qp = Qp+1) ⇒ (6n > p : Bn = Bp+1)).
Lemma A.4 EK ﬁnite such that 6i ≥ 0 : |Qi|≤ K.
Lemma A.5 |limi→∞ Qi| exists and is ﬁnite.
Proof of Lemma A.1
From the fact that 6i ≥ 0 : Qi+1 = Qi ∪ ∆Qi, we deduce straightforwardly that Qi ⊆ Qi+1.	 

Proof of Lemma A.2
By definition : Qp+1 = Qp ∪ ∆Qp and Qp+2 = Qp+1 ∪ ∆Qp+1.
By definition :
∆Q = {(q →l ) : q ∈ Q ,l ∈ (2 EXP(q)×(OUT (L )∪{ }))\{(∅, )}, (q →l )!},
∆Q	={(q →l ) : q ∈ Q	,l ∈(2 EXP(q)×(OUT (L )∪{ }))\{(∅, )}, (q →l )!},
Item 2 implies that if Qp = Qp+1, then ∆Qp = ∆Qp+1.
Items 1 and 3 imply that if Qp = Qp+1, then Qp+2 = Qp+1 = Qp.
By definition : δp+1 = δp ∪ ∆δp and δp+2 = δp+1 ∪ ∆δp+1.
By definition : ∆δ = {q —→l	r : q ∈ Q , (q →l )!,v = (q →l ) ∈ Q	}, and
∆δ	= {q —→l	r : q ∈ Q	, (q →l )!,v = (q →l ) ∈ Q	}.
Items 4 and 6 imply that if Qp = Qp+1, then ∆δp = ∆δp+1.


Items 5 and 7 imply that if Qp = Qp+1, then δp+2 = δp+1.
By definition : Γp+1 = Γp ∪ ∆Γp and Γp+2 = Γp+1 ∪ ∆Γp+1.

By definition : ∆Γ = Γ ∪ {l : E(q —→l
∆Γp+1 = Γ ∪ {l : E(q —→ r ) ∈ δp+2}.
r ) ∈ δp+1}, and

Items 8 and 10 imply that if Qp = Qp+1, then ∆Γp = ∆Γp+1.
Items 9 and 11 imply that if Qp = Qp+1, then Γp+2 = Γp+1.
Items 4, 8 and 12 imply that if Qp = Qp+1, then : Bp+2 = Bp+1.	 

Proof of Lemma A.3
Let us consider a p ≥ 0 such that Qp = Qp+1. Lemma A.2 implies that
Bp+2 = Bp+1.
Let us us consider a n ≥ p + 2 such that Bn = Bn−1. Therefore, Qn =
Qn−1.
From Lemma A.2, we deduce that Bn+1 = Bn.
Items 1 and 2 imply by induction that :
if (Qp = Qp+1) for a given p ≥ 0, then 6n ≥ p +2 : Bn = Bn−1.
Item 3 is equivalent to :
if Qp = Qp+1 for a given p ≥ 0, then 6n ≥ p +2 : Bn = Bp+1.
Since Bn = Bp+1 for n = p + 1, Item 4 can be written :
if Qp = Qp+1 for a given p ≥ 0, then 6n ≥ p +1 : Bn = Bp+1.	 

Proof of Lemma A.4
Let A = (L, A, C, T , l0) be the TA from which we construct B0, B1, B2, ·· ·. Recall that each state of SEA, and thus of Bi, is defined by three parts :
Part 1 : a location of L,
Part 2 : a Clock-Cond and an ExpSeq for each clock of C, Part 3 : zero or one ∆Clock-Cond for each pair of clocks of C.
The cardinal of Part 1 has a ﬁnite upper bound equal to |L|.
The (integer) values to which a clock ci ∈ C is compared (i.e., the values used in guards using ci) are finite and their number is finite.
Item 2 implies that the number of pairs (Clock-Cond, ExpSeq) using a clock ci ∈ C has a ﬁnite upper bound which we denote U .
For each clock ci, let us consider the distinct Set events associated to ci, and let ki, j beΣthe number of constants in each of these Set , for
j = 1, ·· ·. Let pi =	j=1,··· ki,j and p = maxi=1,···,Nc pi. It can be easily
proved that U can be taken equal to p.


Item 3 and the fact that the number of clocks of A is finite (= |C|) imply that p|C| is a (finite) upper bound of the cardinal of Part 2.
For each pair of clocks ci, cj ∈ C, if Mi (resp. Mj) is the greatest value to which ci (resp. cj) is compared in the guards of A, then every ∆Clock- Cond using ci — cj is expressed by using (integer) values that fall within the interval [—Mj, Mi].
Items 2 and 5 imply that for each pair of clocks ci, cj ∈ C, the number of possible ∆Clock-Conds using ci — cj has a ﬁnite upper bound which we denote V .
Since the width of interval [—Mj, Mi] is ≤ 2k, it can be easily proved that V can be taken equal to 22k, where k is the greatest constant used in timing constraints.
Item 6 and the fact that the number of pairs of clocks of A is finite (< |C|2 )

2
imply that 22k |C| 
2
(= 2k|C|2 ) is a (finite) upper bound of the cardinal of

Part 3.
Items 1, 4 and 7 imply that |L|p|C|2k|C|2 is a (finite) upper bound of the number of states of every Bi.	 

Proof of Lemma A.5
Lemma A.1 implies that |limi→∞ Qi| exists. And from Lemma A.4, we deduce that that this |limi→∞ Qi| is finite.	 

Proof of Lemma 5.4
Lemmas A.1 and A.5 imply : Ei ≥ 0 such that Qi = Qi+1
Item 1 and Lemma A.2 imply Ep ≥ 0 such that 6n > p : Bn = Bp+1. 

Proof sketch of Theorem 6.1
Let A be a TA, A' = StepOne(A) be obtained from A by applying Step 1, and
B = StepTwo(A') be the SEA obtained by applying Step 2 to A'.
Step 1 of SetExp relabels transitions of the TA A without changing its structure. The fact to reset a clock c in a transition Tr1, in order to com- pare further in a transition Tr2 the value of c with k, is clearly equivalent to :
resetting c and programming it such that it expires after a delay k (Sub- step 1a), and then checking in Tr2 whether the expiration of c has oc- curred (Substep 1b). Therefore, A and A' describe exactly the same order and timing constraints of the events other than Set and Exp events.


SetExp is realized by a fix-point method that constructs iteratively all the reachable states and the transitions of the SEA. This fix-point method converges after a finite number of iterations (Lemma 5.4) and necessitates in each iteration :
to determine the labels enabled in every state, and
to construct the states reached by these enabled transitions. Therefore, this fix-point method generates a correct result iff (a) and (b) are realized correctly.
Lemmas 5.1, 5.2 and 5.3 imply that the labels enabled in every state are determined correctly.
The detailed explanations of the procedures in Sects. 5.3.1 and 5.3.2 can be considered as a proof sketch that the states reached by the enabled labels are constructed correctly.
Items 2, 3 and 4 imply that the fixpoint method is correct, i.e., Step 2 of SetExp is correct. Therefore, B accepts all and only the possible order of events that respects the specification of A'.
Item 5 and the fact that TLSEA (see Def. 6.1) models the behaviour of B, mean that TLSEA contains all and only the possible order of events that respects the specification of A'.
Items 1 and 6 mean that TLTA (Def. 2.1) is obtained from TLSEA by
removing all Set and Exp events, i.e., A and B are equivalent.	 

Proof of Lemma 6.1
See Proof of Lemma A.4.
