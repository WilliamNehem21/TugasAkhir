Electronic Notes in Theoretical Computer Science 215 (2008) 57–74	
www.elsevier.com/locate/entcs


Liveness in Interaction Systems
Mila Majster-Cederbaum,1
Moritz Martens2 and Christoph Minnameier3
Institute of Computer Science University of Mannheim Mannheim, Germany

Abstract
Interaction systems were proposed and implemented by Sifakis et al. as a model for the design and study of component based systems. We investigate here the property of liveness in interaction systems where liveness of an action, a component or a set of components means that the action (component, set of components) will repeatedly participate in every run of the global system. We show that deciding liveness is NP-hard. Then we present a characterization of liveness. Finally, by exploiting local information, we establish a polynomial-time criterion that guarantees liveness. We combine the criterion with the characterization to obtain a test for liveness.
Keywords: Component-based Modeling, Interaction Systems, Liveness


Introduction
In the last decade a variety of formal approaches to the specification and analysis of component based systems at different levels and with different specific objectives have been proposed [1,2,9,33,3,34,38,35,7,21,5,23,10,16,15]. We investigate here the approach of interaction systems that was proposed and discussed by Sifakis et al. in [16,17,15,40,41,39] and in more detail in [18]. The model clearly separates the issues of 1. interfaces, 2. behavior of the components and 3. interaction between components. It has been implemented

1  Email: mcb@informatik.uni-mannheim.de
2  Email: mmartens@informatik.uni-mannheim.de
3  Email: cmm@informatik.uni-mannheim.de



1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.06.021

successfully in the Prometheus tool [13] and the BIP system [4]. BIP has been extended to a framework for hierarchical components [19] and enriched with contracts as defined in the SPEEDS project [6]. The model was used to specify various applications, e.g. [4,13,14,16,40,27,31,29]. In this approach a component offers a certain set of ports. The communication behavior of a component is given by a labeled transition system where the labels are taken from the port set. That is, the transition system restricts the order of calls to the ports. Components are put together via connectors where a connector is a finite nonempty set of ports such that no two ports stem from the same component. The transitions which the induced global system can perform are regulated by these connectors. One port can be contained in various connectors of various sizes such that the cooperation between components can be regulated freely in a simple way. In approaches using process algebra the basic cooperation scheme is usually fixed and binary and it is cumbersome to realize more flexibility. I/O-automata [23] can be considered as a subclass of interaction systems. They also use some kind of transition systems to model components but have a more restrictive scheme of cooperation. This is also true for the interface-automata defined in [10].
Different aspects of component-based systems have been studied, for example compatibility [37], deadlock-freedom [21,5,1], reliability prediction [22,36,38].
In the framework of interaction systems properties such as local/global deadlock-freedom, progress of a component, availability of ports and robust- ness against failure of components have been discussed [18,14,24,25]. In gen- eral it is difficult to test these properties as they involve the exploration of the global state space. Indeed, it was shown that deciding deadlock-freedom in interaction systems is NP-hard [32]. Recently this result was strengthened by showing that deciding local and global deadlock-freedom is PSPACE-hard [26]. One way to proceed in such situations is to establish criteria that en- sure desired properties and can be tested more easily. In [25] for example we presented a condition that ensures deadlock-freedom and can be tested in polynomial time. In [24] we investigated criteria for robustness.
In this work we concentrate on liveness in interaction systems. A compo- nent is considered to be live if, no matter how the global system evolves and independently of the point of time we consider, it will repeatedly participate in some step of the system. We show first that deciding liveness of a set of components is NP-hard. Then we give a characterization of liveness of a set of components in an interaction system. Moreover, we establish a criterion that entails liveness and can be tested in polynomial time. We present a hy- brid algorithm for testing liveness that combines the characterization and the

criterion mentioned above.
The paper is structured as follows. Section 2 summarizes the basic def- initions. Section 3 contains the notions of deadlock-freedom and liveness. Liveness is investigated in Sections 4, 5 and 6 which are concerned with NP- hardness respectively present the characterization of, the criterion for liveness, and the hybrid algorithm.

Components, Connectors and Interaction Systems
We build on a model for component-based systems, called interaction systems, that was proposed in [16,17,15,40,41]. We start with a set K of components where we usually refer to a component as i ∈ K. For every component i ∈ K a set Ai of ports (or actions) is specified which are used for cooperation with other components. The cooperation is determined by so-called connectors. A connector is a finite nonempty set of ports that contains at most one port for every component in K. Any nonempty subset of a connector constitutes an interaction of the system. A port may be part of various connectors which may be of different size. Hence the cooperation can be regulated in a very flexible way. An interaction describes a step of the system where the ports contained in that interaction are performed together.
Definition 2.1 A component system is a pair CS = K, {Ai}i∈K  where K is the set of components, Ai is the port set of component i, and any two port sets are disjoint. Ports are also referred to as actions.
The union A = i∈K Ai of all port sets is the port set of K. A finite nonempty subset c of A is called a connector for CS, if it contains at most one port of each component i ∈ K, that is |c ∩ Ai|≤ 1 for all i ∈ K. A connector set is a set C of connectors for CS that covers all ports and contains only maximal elements:
1.   c = A	2. c ⊆ c' ⇒ c = c' for all c, c' ∈ C.
c∈C
If c is a connector, I (c) denotes the set of all nonempty subsets of c and is called the set of interactions of c. For a set C of connectors I (C)=   I (c)
c∈C
is the set of interactions of C. We also call connectors c ∈ C the maximal interactions. For component i and interaction α, we put i (α) = Ai ∩ α. We say that component i participates in α, if i (α) /= ∅.
We give a simple example to illustrate these concepts. We will extend this example throughout the text whenever we encounter new notions.

Example 2.2 We consider a component system CS5 = (K5, {Ai}i∈K5 ) con- sisting of five components, where K5 := {1, 2, 3, 4, 5} and the port sets of the components are given by A1 := {a1}, A2 := {b1, b2}, A3 := {d1, d2}, A4 := {e1, e2}, and A5 := {f1, f2}. Additionally we fix the connector set C5 :=
{{a1, b1} , {a1, e1} , {d1, f1} , {a1, e2, f2} , {b2, e2, f2} , {b2, d2, e2} , {a1, d2, e2}} .
This component system is illustrated in Fig. 1 where the components are shown as boxes and the ports of the components are the black boxes. The connectors are represented by lines connecting the respective ports. Here













f2





Fig. 1. The connectors for Example 2.2
for example components 1 and 2 may perform their respective first actions together whereas 2, 4, and 5 may perform their respective second actions together.
In the following, we always assume that K = {1,... , n} for some n ∈ N or that K is countably infinite.
An interaction model for a component system CS is defined by a connector set C together with a set Comp of interactions that are declared to be complete. If an interaction is declared complete it can be performed independently of the environment. Note that it is a design decision which interactions are chosen to be complete. This choice is not restricted in any way and only depends on the system one wishes to model.
Definition 2.3 Let C be a connector set for the component system CS and let Comp ⊆ I (C) be a subset of interactions. The pair IM := (C, Comp) is an interaction model for CS. The elements of Comp are called complete interactions.
Example 2.2 continued Let IM5 := (C5, ∅) be an interaction model for

CS5, i.e. only interactions in C5 are independent of the environment.
If for some reason the interactions {e2} and {f2, b2} for example should be independent of other actions, we could set Comp := {{e2} , {f2, b2}}.
The notions presented so far are only concerned with the possible structure of communication between the different components. In a further level of description of the components the order in which a component may perform the actions it provides is restricted. For that purpose for every component i ∈ K a labeled transition system Ti describing the behavior of i with respect to interaction is introduced. In the simplest case Ti is the “union” of transition systems Tij where Tij is the protocol regulating the cooperation of component i with component j.
Definition 2.4 Let CS = K, {Ai}i∈K be a component system and IM = (C, Comp) an interaction model for CS. Let for each component i  K a transition system Ti = (Qi, Ai, →i, Q0) be given where →i⊆ Qi × Ai × Qi and

0 ⊆ Qi
is a non-empty set of initial states. We write qi
ai
i
' instead of

(qi, ai, q') ∈→i.
The induced interaction system is given by Sys :=
 CS, IM, {Ti}i∈K

where the global behavior T = (Q, C ∪ Comp, →, Q0) is obtained from the
local transition systems of the individual components in a straightforward manner:
Q := i∈K Qi, the Cartesian product of the Qi which we consider to be order independent. We denote states by tuples q := (q1,... , qj,.. .) and call them (global) states.
Q0 :=  i∈K Q0, the Cartesian product of the local initial states. We call
the elements of Q0 (global) initial states.
→⊆ Q × (C ∪ Comp) × Q, the transition relation for Sys defined by

∀α ∈ (C ∪ Comp) ∀q, q' ∈ Q : q = (q ,... ,q ,.. .) →α
q' =

1	j
q' ,... , q' ,.. . ⇔

i(α)
∀i ∈ K : q	q' if i participates in α and q' = q
otherwise.

i →i  i	i	i
The global system can perform either complete or maximal interactions α where α may be performed in a global state q if all partners that are involved in α are offering their corresponding action.
Without loss of generality we always assume that every local state of every component is reachable from some initial state in the local transition system.
Example 2.2 continued The behavior of component i is given in Fig. 2

for i ∈ {1,... , 5}. For every component i we put Q0 = Qi. The induced
global transition system is called T (5).	For example in the global state


a1


b1	b2


d2
e2	f2



Fig. 2. The local behavior of the components of Example 2.2
(p1, p2, p3, p4, p5) a transition labeled with {d1, f1} is enabled. Our example
1	1	1	1	1
system Sys5 := (CS5, IM5, {Ti}i∈K5 ) is now completely specified.
Remark 2.5 In what follows, we often ment ion Sys = CS, IM, {Ti}i∈K .
	
(Qi, Ai, →i, Q0) for i ∈ K, and T are given as above. Usually we will dis- play the local transition systems graphically. If not explicitly stated otherwise the local initial states will be marked by an ingoing arrow which we will omit for component i whenever Q0 = Qi.

Liveness in Interaction Systems

Remark 3.1 From now on for all i ∈ K we will assume that Ti has the property that every state offers at least one action.
In order to define liveness we first need a notion of (global) deadlock- freedom. Note that in [25] we also investigated a notion of local deadlock of a subset K' ⊆ K of components which describes a situation where in the current state every component in K' needs the cooperation of at least one other component in K' which in turn does not offer the needed ports.
Definition 3.2 Let Sys be an interaction system.
Let q ∈ Q. q is reachable in Sys if there is a sequence q0 →α0 q1 →α1 ... αn−1 q
such that q0 ∈ Q0 and αi ∈ C ∪ Comp for all 0 ≤ i ≤ n − 1.
Sys is called deadlock-free if for every reachable state q there exists α ∈
C ∪ Comp and q' ∈ Q such that q →α q'.
This definition is justified by the fact that maximal as well as complete interactions are independent of the environment. They do not have to wait for

any other components and can be performed immediately. Started in a global initial state a deadlock-free system may always proceed with some maximal or complete interaction. Thus cyclic waiting involving all components cannot occur, whereas two or more components may be engaged in a local deadlock.
Example 2.2 continued It is easy to see that Sys5 is deadlock-free. We have Q0 = Qi for all components which means that every global state is reachable. Therefore one has to show that every global state offers at least one maximal interaction which boils down to a simple case distinction.
In deadlock-free systems runs always exist, where a run is simply an infinite thread of execution starting in a reachable state of the system.
Definition 3.3 Let Sys be a deadlock-free interaction system and let q ∈ Q
be a reachable state. A run of Sys is an infinite sequence σ : q = q0 →α0 q1 →α1
q2 ... with ql ∈ Q and αl ∈ C ∪ Comp for all l ∈ N.
Let i ∈ K be a component and let σ be a run of Sys. If there exists l such that i participates in αl we say that i participates in σ.
Now we can define when a set of components K' ⊆ K is live. Basically this is the case if for any point of time no matter how the system behaves some component in K' will eventually participate in some interaction. From now on we identify singleton sets with their element if it is convenient to do so.
Definition 3.4 Let Sys be a deadlock-free interaction system and let K' ⊆ K be a nonempty set of components. We say that K' is live in Sys if for every run σ of Sys there exists some i ∈ K' such that i participates in σ.
Remark 3.5 It should be noted that this notion of liveness applied to a component i is the same as requesting that this component should participate infinitely often in a run because runs may start in any reachable state.
This notion of liveness is different from the one introduced for Petri nets [8] that corresponds to our notion of local progress of a component i in interaction systems [14], which means that at any point in any run we may proceed in such a way that component i will participate. Clearly liveness of i implies local progress but not vice versa. A general form of liveness-properties for a component system as a whole is defined in [7]. The questions referring to single components that we are interested in cannot be directly formulated and investigated in [7] because the identity of a component may be lost in the system which means that it is not meaningful to consider liveness of a component.
If i is live in Sys any set of components containing i is also live. The

converse does not hold: even if K' is live in Sys there does not need to be any i ∈ K' that is live. Also note that for K' = K liveness follows from deadlock-freedom.

Deciding Liveness is NP-Hard
We will show that deciding liveness in interaction systems is NP-hard by reducing the question whether a formula F in 3-KNF [11] is not satisfiable to the question of deciding whether a certain component κ is live in a certain deadlock-free system. Note that the reduction technique only has to be slightly adapted in the case of I/O-automata [23] yielding an analogous result for this formalism.
The idea of the reduction is as follows. Each clause of F will be represented by one component as will be each literal of every clause. Other than that there is one component κ that is live if and only if F is not satisfiable. The clause components only have one state other than the starting state. This state represents an evaluation of the clause to true. The literal-components have a starting state from which two states representing the evaluation of the literal to true respectively f alse. The choice of the connector set will then make sure that all literals can only be set consistently. That means if one variable is set to a certain value all literals with the same variable must be set appropriately. Then it is clear that a global state where for each clause there is one literal- component that is in its state representing true can be reached if and only if F is satisfiable. This means all clause-components can move to their respective true state if and only if F is satisfiable. Then the choice of the connectors will ensure that it is only possible to start a run not involving κ in such a state.
Let F = k1 ∧ ... ∧ kn with ki =	l(i,1) ∨ l(i,2) ∨ l(i,3)		be a proposi- tional formula in 3-KNF, where l(i,1), l(i,2), and l(i,3) are literals.	For l a literal let var (l) denote the variable occurring in l.	Let var (F ) := var l(i,j) |1 ≤ i ≤ n, 1 ≤ j ≤ 3	denote the set of variables occurring in F . We construct a deadlock-free interaction system Sys(F ) with component-
set K (F ) containing a component κ such that
(F ∈/ 3-SAT) ⇔ (κ is live in Sys(F ))
where 3-SAT is the set of satisfiable formulas in 3-KNF. Besides the component κ we represent each clause ki by a component (i, 0) and each literal l(i,j) by a component (i, j). We define

Sys (F ) :=  CS (F ) , IM (F ) , T
}i=1,...,n ∪ {T } 

where the components and their port sets are given by:
K (F ) := {(i, j) | 1 ≤ i ≤ n, 0 ≤ j ≤ 3}∪ {κ}
A(i,0) := {truei, SATi} for 1 ≤ i ≤ n
A(i,j) := set1(i,j), set0(i,j), true(i,j), a(i,j)} for 1 ≤ i ≤ n, j /=0 
Aκ := {aκ}
We define the following connectors. First we have:
sat := {SAT1,... , SATn}
Next we define:
set1x :=  aκ, set1(i1 ,j1),... , set1(im,jm)} and
set0x := aκ, set0(i1 ,j1),... , set0(im,jm)}
where x = var l(i1 ,j1) = ... = var l(im,jm) and there is no other literal l
with x = var (l). Other than that we set:
t(i,j) := aκ, true(i,j), truei}
ca := {aκ}∪ a(i,j)|1 ≤ i ≤ n, j /= 0}


We set

C := {sat}∪ {ca}∪	 
x∈var(F )

{set1x, set0x}∪	 
1≤i≤n,j/=0

 t(i,j)}

and choose Comp to be the empty set.
The local transition system for κ is given in Fig. 3 (a). T(i,0) is given in Fig. 3 (b) and T(i,j) for j /= 0 and l(i,j) a positive (resp. negative) literal is given in Fig. 3 (c) (resp. (d)).


(a)
(b)
aκ


0 (i,0)
(c)

0
(i,j)


a(i,j)
(d)

0
(i,j)


a(i,j)

set1(i,j)	set0(i,j)	set1(i,j)	set0(i,j)
i


t
(i,0)

t
(i,j)

f
(i,j)

f
(i,j)

t
(i,j)

SATi	true(i,j)
a(i,j)	a(i,j)	a(i,j) true(i,j) a(i,j)

Fig. 3. The local transition systems for the components of Sys (F )

Theorem 4.1 Let Sys (F ) be deﬁned as above.

Going from F to Sys (F ) there is no exponential blow-up in notation.
Sys (F ) is deadlock-free.
F is not satisﬁable if and only if κ is live in Sys (F ).
The proof can be found in the technical report [28]. The following example illustrates the idea behind the reduction of the above theorem. For a satisfiable formula F it will be shown how a run in Sys (F ) can be found in which κ only participates finitely many often. Let F = (x1 ∨ x2 ∨ x3) ∧ (x1 ∨ x2 ∨ x3) ∧ (x1 ∨ x2 ∨ x3). F is satisfiable, namely v(F )= 1 for v(x1)= 1, v(x2)= 1, v(x3)= 0.
Consider K (F )  =  {(1, 0), (1, 1), (1, 2), (1, 3), (2, 0),..., (3, 3), κ}  and

Sys (F ) :=  CS (F ) , IM (F ) , T
}i=1,...,3 ∪ {T
}  as above. The evalu-

ation v given above yields the following path starting in q0 ending in a state where the connector sat can repeatedly be applied resulting in a run as above.
σ := q0 set1x1 q1 set1x2 q2 set0x3 q4 t(→1,1) q5 t(→2,2) q5 t(→3,3) q6 →sat q6 →sat ... 

In the first step component (1, 1) moves to its true-state and (2, 1) and (3, 1) move to their respective f alse-state representing the evaluation of x1 to 1. Analogously the other six literal-components change their state according to set1x2 and set0x3 . In steps four to six components (1, 0), (2, 0), and (3, 0)
move to their true-state together with (1, 1), (2, 2), respectively (3, 3). Note

that in the fifth step t(2,3) could also have been performed because q5
t
(2,3)

as well. Then sat is enabled in q6.

Characterizing Liveness of a Set of Components
In this section we consider a (not necessarily finite) deadlock-free interaction system. We present a characterization of all subsets K' ⊆ K that are live. The benefit of this characterization is that it can be used in combination with the sufficient criterion for liveness that we will present in Sect. 6 for cases where the criterion alone does not imply liveness.
Definition 5.1 Let K' ⊆ K be a subset of components. Let excl (K') :=
{α ∈ C ∪ Comp|∀i ∈ K' : i (α)= ∅} denote the set of maximal or complete interactions in which no component from K' participates.
Definition 5.2 Let Sys be a deadlock-free interaction system and let K' ⊆ K
be a non-empty subset of components. We define
K¯ ' := {k ∈ K|∃α ∈ excl (K'): k (α) /= ∅} .

Further we define the following labeled transition system
T¯ := Q¯, excl (K') , → 
where Q¯ :=  k∈K¯ ' Qk and →⊆ Q¯ × excl (K') × Q¯ is the transition relation
which is defined as follows: for any two states p¯, q¯ ∈ Q¯ and any interaction

α ∈ excl (K')
p¯ →
q¯ ⇔ ∀i ∈ K¯ ' p¯
i(α)
q¯
if i(α) /= ∅ and p¯
= q¯ otherwise .

K¯ ' contains those components that participate in at least one maximal or complete interaction not involving any component from K'. We clearly have K' ⊆ K\K¯ '. Q¯ can be understood as the projection of Q to K¯ ' where we only allow those transitions labeled with some α ∈ excl (K').
Theorem 5.3 Let Sys be deadlock-free and let K' ⊆ K. K' is live in Sys if and only if T¯ does not contain any inﬁnite path starting in a state q¯ for which there exists q' ∈ i∈K\K¯ ' Qi such that (q¯, q') is reachable in Sys.
For finite systems the characterization amounts to cycle detection and involves (partial) global state space analysis in the worst case and its usefulness to detect liveness depends on the size of K'. If K' contains very few elements usually it will not be helpful to analyze T¯, because its number of states may
still be exponential in the number of components.  But even in this case
the characterization can be helpful when the set excl (K') is small and T¯
sparse. In the extreme case every maximal or complete interaction involves some component from K' and excl(K') is empty. Then it is clear anyway that K' is live.

Testing Liveness
In this section we present a hybrid algorithm that tests liveness of a subset K' of components. The algorithm is based on a sufficient condition and the characterization given in the previous section applied to a subsystem.
The condition that has to be checked comes down to a reachability analy- sis in a graph where the components are the nodes. The graph is constructed by checking certain dependencies between pairs of components that can be checked by investigating the local transition systems only. Therefore the graph can be constructed in time polynomial in the number of components and the size of the local transition systems such that the criterion avoids the investi- gation of the global state space.
In this section we always assume that Sys is a deadlock-free interaction system with a finite set of components K and finite port sets Ai.

Definition 6.1 Let Sys be an interaction system as above and let j ∈ K be a component.

Let A'
⊆ Aj be a subset of actions of j. A'
is inevitable in Tj if only

finitely many transitions labeled with aj ∈ Aj\A'
can be performed in

Tj before some action from A'
must be performed.

Let Λ ⊆ I (C) be a nonempty set of interactions and let j ∈ K be a

component. We define Λ [j] := Aj ∩
α∈Λ
participate in one of the interactions of Λ.
α the set of ports of j that

A subset of actions of a component is inevitable if on every infinite path in the transition system of that component there are infinitely many transitions that are labeled with some action from that set. The second part of the definition gives a sort of a projection-operator that yields those actions of component j that participate in one of the interactions in Λ.
In the following we define the graph G := (K, E). The set of edges is given by the union  m≥0 Em where the sets Em ⊆ K × K are defined inductively.
Definition 6.2 Let
E0 := {(i, j) |Aj\ (excl (i) [j]) is inevitable in Tj}
and define En+1 inductively as follows:
En+1 := {(i, j) |Aj\ (excl (Reachn (i)) [j]) is inevitable in Tj}

Here Reachn (i) := {j|j is reachable from i in (K, n
Em)}.


Let E :=  ∞	Em and define G := (K, E).
Note that excl (i) [j] contains those ports of j that occur in some maximal or complete interaction that does not involve i. Thus Aj\ (excl (i) [j]) is the set of ports of j that only occur in maximal or complete interactions that also involve i. Then the intuitive meaning of an edge (i, j) ∈ E is that j can only participate in finitely many global steps before i also has to participate in such a step.
Theorem 6.3 Let K' ⊆ K be a set of components.  If all components in
K\K' are reachable from K' in G then K' is live in Sys.
Example 2.2 continued We have already explained why Sys5 is deadlock- free.
Figure 4 depicts the part of G only containing the edges from E0. The only component that is reachable from 1 is 2, but it can be seen that 3 respectively 5 can only advance finitely many times before component 4 has



Fig. 4. (K, E0) for Example 2.2
to participate in some step. Amongst others the edge (1, 4) is added to E1 in the next iteration step. Hence all components are reachable from component
1 in  K,  1	Em and therefore also in G. Then liveness of component 1
follows from Theorem 6.3 above.
In the following we present the algorithm that tests a given set K' of components for liveness. The algorithm first applies the sufficient condition of Theorem 6.3 to K' which causes polynomial cost. If the condition of the criterion is not satisfied then the algorithm applies the characterization of Theorem 5.3 to the set Reach of components that can be reached in G from K'. Note that the algorithm requires a system where each global state is a potential starting state. It can easily be adapted to the general case. In this case the algorithm reports “don’t know” if it detects a cycle in Q in the second part of the algorithm as we do not know if the cycle is reachable in the global system. A further refinement could use the techniques of [25] to find out whether the cycle is indeed reachable from a global starting state.
Lemma 6.4 Algorithm 1 terminates and correctly tests a given set K' of components for liveness. If it yields a positive answer in line 20 the total cost is polynomial in the size of the input.
The else-block starting in line 21 causes cost in the size of Q which is exponential in |K\Reach| in the worst case.
Proof. The correctness of the algorithm follows from Theorems 5.3 and 6.3. Each iteration of the loop in line 5 causes cost polynomial in |K|,
|C ∪ Comp|, and Σj∈K |Tj|, and this iteration will be performed at most |K|
2
times. Note that the test for inevitability in Tj from line 9 only causes cost polynomial in |Tj|. It can be performed by checking whether the system T ' ob- tained by deleting all edges labeled with a port from Aj\ (excl (Reach (i)) [j]) does not contain a cycle. The cost of the else-block is dominated by the cost for the computation of Q and the search for a cycle in Q.	 
Example 2.2 continued From the above explanations it is clear that Algorithm 1 launched with Sys5 and K' = {1} terminates in line 20 detecting liveness of component 1.



Algorithm 1 LIV ENESS (Sys, K')
Require: Sys	=	CS, IM, {Ti}i∈K	deadlock-free, Ti	= (Qi, Ai, →i, Qi) , K' ⊆ K
Ensure: TRUE if K' is live, FALSE otherwise
1: V ← K, E ← ∅, numberEdges ← 0
2: for all i ∈ K do 3:	Reach (i) ← {i} 4: end for
5: repeat
6:	numberEdges ← |E|
7:	for all i ∈ K do
8:	for all j ∈ K\ {i} do
9:	if Aj\ (excl (Reach (i)) [j]) is inevitable in Tj then
10:	E ← E ∪ {(i, j)}
11:	end if
12:	end for
13:	end for
14:	for all i ∈ K do
15:	Reach (i) ← {j ∈ K|∃ path from i to j in (V, E)}
16:	end for
17: until numberEdges = |E|

18: Reach ←
i∈K'
Reach (i)

19: if Reach = K then
20:	return TRUE {K' is live}
21: else
22:	compute excl (Reach)
23:	compute Reach
24:	Q ←	k∈Reach Qk
25:	if / ∃ cycle in Q then
26:	return TRUE {K' is live}
27:	else
28:	return FALSE {K' is not live}
29:	end if
30: end if
In the following example the else-block will be applied and yields liveness of component 1 if the algorithm is launched with the given system and K' =
{1}.
Example 6.5 Consider a system consisting of the four components 1, 2, 3, and 4 whose behavior is given by Fig. 5 where it is understood that the port

sets of the components are given implicitly by the transition systems. For every component i we put Q0 = Qi.
Fig. 5. Example illustrating Theorem 5.3

We define C  = {{a1, b1} , {b2, d1} , {d2, e1} , {d1, e1} , {d2, e2}} and set
Comp = ∅.
It is easy to check that the global system is deadlock-free. We apply Algorithm 1 to test liveness of K' = {1}.  The algorithm finds Reach =
{1, 2} /= K. The else-block will therefore be applied to {1, 2}. Because excl ({1, 2}) = {{d2, e1} , {d1, e1} , {d2, e2}} it is clear that Reach = {3, 4}. There is no cycle in Q¯. Thus the algorithm affirms liveness of 1.
Had we used Theorem 5.3 directly to test liveness of component 1 we would have got K¯ ' = {2, 3, 4}, i.e. a larger transition system would have had to be investigated. The combination of the criterion from Theorem 6.3 with the characterization of Theorem 5.3 in Algorithm 1 may yield greater benefit if
applied to larger examples.

Conclusion and Related Work
This work treats various aspects concerning liveness. The contribution is threefold:
We showed that deciding liveness in interaction systems is NP-hard by reducing 3-SAT to resolving the question whether a certain component is live in an interaction system 4 .
We presented a characterization for liveness.
We established a sufficient criterion for liveness that can be tested in polynomial time. In Algorithm 1 we combined this criterion with the characterization mentioned above.
Liveness has been treated in other settings for component-based systems. For example in the channel-based approach of [7] general liveness-properties

4 Work in progress suggests the conjecture that the problem is even PSPACE-hard.

have been investigated although no procedures that can be used to test live- ness are provided. Moreover Petri-nets have been used for component-based modeling [3]. For Petri-nets a notion of liveness has been investigated in de- tail [8] and depending on the considered class of Petri-nets the complexity of deciding this property is presented. This notion of liveness corresponds to our notion of local progress [14]. Liveness has been also discussed in [12,30].
The problem of repeated reachability of a set of accepting states of a Bu¨chi automaton has been dealt with in depth in the context of model checking of LTL formulae, see e.g. [20]. This problem corresponds to our condition in Theorem 5.3. However we propose an alternative idea. We exploit local information about the components and derive a criterion in Theorem 6.3, that guarantees liveness without considering (parts of) the global state space in any form. Algorithm 1 proceeds as follows: only if the criterion fails to establish liveness we apply cycle search in the projection of the global state space to Reach. To implement this part of the algorithm efficiently we could apply the ideas presented in [20].
Another approach to establish properties of systems while avoiding global state space analysis is to exploit compositionality. In [14] we defined a com- position operator for interaction systems and presented some first conditions under which properties of subsystems are preserved under composition.
In [14,25,24] we formulated and investigated further properties of interac- tion systems, in particular global and local deadlock, progress, and robustness. Currently we are enhancing the model by introducing probability. It is then possible to make statements such as “with probability p no deadlock will arise”.

References
Robert Allen and David Garlan. A Formal Basis for Architectural Connection. ACM Trans. Softw. Eng. Methodol., 6(3):213–249, 1997.
Farhad Arbab. Abstract Behavior Types: A Foundation Model for Components and Their Composition. In Formal Methods for Components and Objects (FMCO 02), volume 2852 of LNCS, pages 339–360, 2003.
Remi Bastide and Eric Barboni. Software Components: A Formal Semantics Based on Coloured Petri Nets. In Proceedings of the International Workshop on Formal Aspects of Component Software (FACS 05), ENTCS, 2005.
A. Basu, M. Bozga, and J. Sifakis.  Modeling Heterogeneous Real-time Systems in BIP. In Proceedings of the Third IEEE Conference on Software Engineering and Formal Methods (SEFM 2006), pages 3–12, 2006.
Hubert Baumeister, Florian Hacklinger, Rolf Hennicker, Alexander Knapp, and Martin Wirsing. A Component Model for Architectural Programming. In Proc. 2nd Int. Wsh. Formal Aspects of Component Software (FACS 05), volume 160 of Elect. Notes Theo. Comp. Sci., pages 75–96, 2006.

M. Bozga, O.Constant, B. Josko, Q. Ma, and M. Skipper. SPEEDS metamodel syntax and static semantics, January 2007. Deliverable D2.1b.
M. Broy. Towards a Logical Basis of Software Engineering. In M. Broy and R. Steinbru¨ggen, editors, Calculational System Design, IOS 1999, volume 158 of NATO ASI Series, Series F: Computer and System Sciences, pages 101 – 131. 1999.
Allan Cheng, Javier Esparza, and Jens Palsberg.  Complexity Results for 1-safe Nets. In Proceedings of Foundations of Software Technology and Theoretical Computer Science (FSTTSC 93), volume 761 of LNCS, pages 326–337, 1993.
S. Chouali, M. Heisel, and J. Souqui`eres. Proving Component Interoperability with B Refinement. In Proc. 2nd Int. Wsh. Formal Aspects of Component Software (FACS 05), volume 160 of Elect. Notes Theo. Comp. Sci., pages 67–84, 2006.
Luca de Alfaro and Thomas A. Henzinger. Interface Automata. In Proceedings of the Ninth Annual Symposium on Foundations of Software Engineering (FSE 01), pages 109–120, 2001.
M. R. Gary and D. S. Johnson. Computers and Intractability, A Guide to the Theory of NP-Completeness. New York: W.H. Freeman, 1979.
G. G¨ossler, S. Graf, M. Majster-Cederbaum, M. Martens, and J. Sifakis. An Approach to Modelling and Verification of Component Based Systems. In Proceedings of the 33rd International Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM 07), volume 4362 of LNCS, pages 295–308, 2007.
Gregor G¨ossler. Component-based Design of Heterogeneous Reactive Systems in Prometheus. Technical report 6057, INRIA, December 2006.
Gregor G¨ossler, Susanne Graf, Mila Majster-Cederbaum, Moritz Martens, and Joseph Sifakis. Ensuring Properties of Interaction Systems. In Program Analysis and Computation, Theory and Practice, volume 4444 of LNCS, pages 201–224, 2007.
Gregor G¨ossler and Joseph Sifakis. Component-based construction of Deadlock-free Systems. In Proceedings of Foundations of Software Technology and Theoretical Computer Science (FSTTCS 03), volume 2914 of LNCS, pages 420–433, 2003.
Gregor G¨ossler and Joseph Sifakis. Composition for Component-Based Modeling. In Formal Methods for Components and Objects (FMCO 02), volume 2852 of LNCS, pages 443–466, 2003.
Gregor G¨ossler and Joseph Sifakis. Priority Systems. In Formal Methods for Components and Objects FMCO 03), LNCS, pages 314–329, 2004.
Gregor G¨ossler and Joseph Sifakis. Composition for component-based modeling. Sci. Comput. Program., 55(1-3):161–183, 2005.
S. Graf and S. Quinton. Contracts for BIP: Hierarchical Interaction Models for Compositional Verification. In Proceedings of FORTE’07, volume 4574 of LNCS, pages 1–18. Springer, 2007.
R.H. Hardin, R.P. Kurshan, S.K. Shukla, and M.Y. Vardi. A New Heuristic for Bad Cycle Detection Using BDDs. In Proceedings of CAV’97, volume 1254 of LNCS, pages 268–278, 1997.
Paola Inverardi and Sebastian Uchitel. Proving Deadlock Freedom in Component-Based Programming. In Proceedings of the 4th International Conference on Fundamental Approaches to Software Engineering (FASE 01), volume 2029 of LNCS, pages 60–75, 2001.
Bernd J. Kr¨amer, Heinz W. Schmidt, Iman H. Poernomo, and Ralf H. Reussner. Predictable Component Architectures Using Dependent Finite State Machines. In Radical Innovations of Software and Systems Engineering in the Future, 9th International Workshop (RISSEF 2002), pages 310–324, 2002.
Nancy A. Lynch and Mark R. Tuttle. An Introduction to Input/Output Automata. CWI- Quarterly, 2(3):219–246, September 1989.
M. Majster-Cederbaum and M. Martens. Robustness in Interaction Systems. In Proceedings of the 27th International Conference on Formal Methods for Networked and Distributed Systems (FORTE 07), volume 4574 of LNCS, pages 325–340, 2007.

M. Majster-Cederbaum, M. Martens, and C. Minnameier. A Polynomial-Time-Checkable Sufficient Condition for Deadlock-freeness of Component Based Systems. In Proceedings of the 33rd International Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM 07), volume 4362 of LNCS, pages 888–899, 2007.
M. Majster-Cederbaum and C. Minnameier. Deriving Complexity Results for Interaction Systems from 1-safe Petri Nets., 2007. Submitted for publication.
M. Majster-Cederbaum, N. Semmelrock, and V. Wolf. Interaction Models for Biochemical Reactions. In Proceedings of BIOCOMP 07. CSREA Press, 2007.
M. Martens, C. Minnameier, and M. Majster-Cederbaum.  Deciding Liveness in Component-Based Systems is NP-hard.   Technical report TR-2006-017, University of Mannheim, Fakult¨at Mathematik und Informatik, 2006. http://madoc.bib.uni- mannheim.de/madoc/portal/inst inf/index.php.
Moritz Martens. Liveness in Interaction Systems - An Application to the Problem of the Dining Philosophers., 2006. Nordic Workshop on Programming Theory 2006.
Moritz Martens. Liveness in Interaction Systems. Technical report TR-2007-001, University of Mannheim, 2007. http://madoc.bib.uni-mannheim.de/madoc/portal/inst inf/index.php.
Moritz Martens. Using Interaction Systems to Model a Bank System, 2007. Internal Report.
Christoph Minnameier.	Deadlock-Detection in Component-Based Systems is NP-hard.
Information Processing Letters, 3630, 2007.
S. Moschoyiannis and M.W. Shields. Component-Based Design: Towards Guided Composition. In Proceedings of Application of Concurrency to System Design (ACSD’03), pages 122–131. IEEE Computer Society, 2003.
Oscar Nierstrasz and Franz Achermann. A Calculus for Modeling Software Components. In Formal Methods for Components and Objects (FMCO 02), volume 2852 of LNCS, pages 339– 360, 2003.
F. Pl´aˇsil, D. B´alek, and R. Janeˇcek. SOFA/DCUP: Architecture for Component Trading and Dynamic Updating. In CDS ’98: Proceedings of the International Conference on Conﬁgurable Distributed Systems, page 43, Washington, DC, USA, 1998. IEEE Computer Society.
Ralf H. Reussner, Heinz W. Schmidt, and Iman Poernomo. Reliability Prediction for Component-Based Software Architectures. Journal of Systems and Software – Special Issue of Software Architecture – Engineering Quality Attributes, 66(3), 2003.
Heinz W. Schmidt. Compatibility of Interoperable Objects. In Bernd Kr¨amer, Michael P. Papazoglou, and Heinz W. Schmidt, editors, Information Systems Interoperability. Research Studies Press, 1998.
Heinz W. Schmidt. Architecture-Based Reasoning About Performability in Component-Based Systems. In Proceedings of the 33rd International Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM 07), volume 4362 of LNCS, pages 130–137, 2007.
J. Sifakis. The Algebra of Connectors Structuring Interaction in BIP. In Proceedings of FMCO’07, LNCS. Springer, 2007. To appear.
Joseph Sifakis. Modeling Real-time Systems. In IEEE Real-Time Symposium (RTSS04), pages 5–6, 2004.
Joseph Sifakis. A Framework for Component-based Construction. In IEEE Conference on Software Engineering and Formal Methods (SEFM 05), pages 293 – 300, 2005.
