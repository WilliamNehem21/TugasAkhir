Electronic Notes in Theoretical Computer Science 45 (2001)
URL: http://www.elsevier.nl/locate/entcs/volume45.html 21 pages


Key Compromise, Strand Spaces, and the Authentication Tests *

Joshua D. Guttman
The MITRE Corporation Bedford, MA 01730 USA guttman@mitre.org

Abstract
Some cryptographic protocols are vulnerable to replay attacks, a type of weakness that was a focus of attention in the Burroughs-Abadi-Needham logic. Newer, more operational approaches to protocol analysis have not concentrated on this type of attack. This paper fills the gap for the strand space theory.
The main technical point is to provide a definition of recency. Our candidate is convenient because we already have a powerful way to prove events recent, namely the incoming and outgoing authentication tests.
A secondary purpose of this paper is to illustrate an easily mechanized pattern for using the authentication tests.
Key words: cryptographic protocols, authentication, authentication tests, strand spaces, bundles, key compromise


Introduction
Some cryptographic protocols are vulnerable to replay attacks, in which a message from a legitimate protocol execution is retransmitted later, typically when the same principal executes a different session of the protocol. If the message contains an encrypted session key that a penetrator has cracked via cryptanalysis, then the penetrator may induce the recipient to reuse the com- promised session key.
Although the Burroughs-Abadi-Needham logic [1] was particularly success- ful at identifying these situations, the newer, more operational approaches to protocol analysis have not concentrated on this type of attack. These include strand spaces [7,19], CSP model-checking [9], and rank functions [8,18], while Paulson’s inductive method [15,16] was the primary exception to this.

 I gave my MFPS 17 talk on 24 May 2001, Bob Dylan’s sixtieth birthday. This paper is dedicated to him.
◯c 2001 Published by Elsevier Science B. V. Open access under CC BY-NC-ND license.


In this paper we fill this gap in the strand space literature. We show how to specify the behavior of a key server so that recent keys remain un- compromised, whereas older keys may have been compromised. The famil- iar Needham-Schroeder private key protocol [13] is vulnerable in this model, whereas the Yahalom protocol [1] is not. The main technical point is to pro- vide a definition of recency. Our candidate is convenient because the strand space method already has a powerful way to prove that an event is recent, namely the incoming and outgoing authentication tests [5,7].
A supplementary purpose of this paper is to illustrate the power of the authentication tests. They provide simple and straightforward explanations of protocol correctness. We linger over several examples to illustrate the pat- terns of usage for the authentication tests. These patterns of usage are quite stereotyped, although there are several ingredients to be combined effectively.
The Needham-Schroeder Symmetric Key Protocol  In the seminal paper [13], Needham and Schroeder proposed a protocol using symmetric cryp- tography and another protocol using public key cryptography. Both turned out to be flawed.
The symmetric-key protocol NSSK assumes that each principal shares a long term key with a key server. Its purpose is to establish a secret session key between two principals, after each has authenticated the identity of the other. The intended execution of the protocol is summarized in Figure 1.
In this protocol, the initiator A sends a message to the key server containing his name, the name B of his partner, and a nonce Na. A nonce is a new, random number, generated for just one use. The message is encrypted using a long-term key, shared between A and the server. The server generates a new session key K, and sends it encrypted with A’s long-term key. B’s name and the nonce Na are enclosed with the session, together with a ticket. The ticket contains A’s name and the session key, encrypted with B’s long-term key. A forwards this ticket to B, expecting to receive back a new nonce Nb, encrypted with K. A demonstrates receipt by returning 1 + Nb, also encrypted with K.
The shape of the diagram in Figure 1 is striking: It consists of two rectan- gles, connected by a “neck,” the middle ⇒ in A’s behavior. The top rectangle involves just A and the server, while the bottom rectangle involves just A and B, so that the server is completed before B begins.
Denning and Sacco [2] promptly identified the failure that results. Al- though B, when receiving {|A , K|}KB , can infer that it was generated by the server, B has no way to know how much time has elapsed since the server completed. This is geometrically evident from Figure 1, as nothing available to B measures the length of the “neck” between A’s second and third nodes, nor the delay along the → arrow from A’s third node to B’s first node. So B cannot bound the delay between when S generated the session key K and when B receives it.
Assuming that A and B use K in a session for encrypted communication,


A	S
¨•	A , {|B , Na|}KA	✲ ¨•
  ✛	{|B , Na , K , {|A , K|}KB |}KA	 
¨•	•
¨
¨	B

¨
{|A , K|}
¨•

KB	✲ ¨•

  ✛	{|Nb|}K	 
¨•	¨•
	{|1+ Nb|}K	✲ 

Fig. 1. The Needham-Schroeder Symmetric Key Protocol (NSSK)

perhaps a penetrator will cryptanalyze the conversation to recover K. In this case, the penetrator can start a session by resending the same unit {|A , K|}KB , later returning {|1+ Nb|}K. Then B will have been had. The assumption that K is good should expire when it is no longer recently generated.
Our goal in this paper is to formulate a rigorous theory allowing us to prove that a protocol does not have flaws of this kind. The same ideas also suggest heuristics for finding such flaws, when we cannot prove their absence.

Strand Spaces
The strand space theory [7,19] is a particular way to formalize the Dolev-Yao model [3]. It assumes that cryptography is ideal, and aims to discover what authentication and secrecy properties protocols then achieve.
In the strand space model, the behaviors of principals are represented by a set of strands. A strand is a sequence of message send and receive events; for instance, each vertical column in Figure 1 is a strand (for each particular choice of parameters A, B, Na, etc.). The behaviors of the penetrator are also represented by strands; in this case, the strands represent basic actions such as encrypting or decrypting with a known key or selecting a nonce. Each strand is a purely local behavior of some particular principal on a particular occasion. A collection of strands forms a bundle if they are causally well- founded, so that every message received was actually sent previously by some strand, and no principal engages in a second or third event without having already performed the first.

Background
We compactly summarize the ideas behind the strand space model [4,7,19]; definitions are contained in Appendix A.

Terms and Subterms  A is the set of messages that can be sent between principals. Its elements, called terms, are freely generated from two disjoint sets, T (texts such as nonces or names) and K (keys), by concatenation and encryption. The concatenation of terms g and h is denoted g , h, and the encryption of h using key K is denoted {|h|}K. (See Appendix A.3.)
In NSSK, the initiator A sends a term of the form A , {|B , Na|}KA to start an exchange intended for B. This is a concatenation containing A’s name and a ciphertext. The ciphertext is created using A’s long-term key KA shared with the key server; its plaintext is the result of concatenating B’s name with a nonce (random bitstring) Na.
A term t is a subterm of another term t', written t и t', if starting with t we can reach t' by repeatedly concatenating with arbitrary terms and encrypting with arbitrary keys. Hence, K /и {|t|}K, except in case K и t. The subterms of t are the values that are uttered when t is sent; in {|t|}K, K is not uttered but used. (See Definition A.7.) For instance, the subterms of A , {|B , Na|}KA are A, B, Na, the concatenated message B , Na, the ciphertext {|B , Na|}KA , and the whole term itself. The key KA is not part of what is uttered; it just contributes to how the message is constructed.
Strands and Strand Spaces  A strand is a sequence of message transmis- sions and receptions, where transmission of a term t is represented as +t and reception of term t is represented as −t. A strand element is called a node. If s is a strand, s ↓ i is the ith node on s. The relation n ⇒ n' holds between nodes n and n' if n = s ↓ i and n' = s ↓ i + 1. Hence, n ⇒+ n' means that n = s ↓ i and n' = s ↓ j for some j > i. The relation n → n' represents inter-strand communication; it means that term(n)= +t and node term(n')= −t.
Continuing with NSSK as our illustration, an initiator strand offers a se- quence of events of the form shown in the leftmost column of Figure 1. In this strand si, the initiator A sends a term intended for the server S, and expects to receive back a “ticket” of the form {|B , Na , K , {|A , K|}KB |}KA , after which it will forward {|A , K|}KB , and so on. The first reception is si ↓ 2 and the next transmission is si ↓ 3.
An NSSK initiator strand has five parameters (or degrees of freedom), namely the two names A and B, the two nonces Na and Nb, and the session key
K. When we write si ∈ Init[A, B, Na, Nb, K] in this illustration, we will mean that si is an initiator strand using the particular values shown as parameters, and similarly for ss ∈ Serv[A, B, Na, K] and sr ∈ Resp[A, B, Nb, K]. A is the principal active in Init[A, B, Na, Nb, K] as initiator, while B is the principal active in Resp[A, B, Nb, K] as responder. We generally write parameters in this order: first the names of the intended participants, next any nonces seen in that run, and finally a session key (if the protocol distributes one).
A strand represents the local view of a participant. For a legitimate partic- ipant, a strand represents the messages that participant would send or receive as part of one particular run of his side of the protocol. We call a strand

representing a legitimate participant a regular strand.
A strand space Σ is a set of strands. The two relations ⇒ and → jointly impose a graph structure on the nodes of Σ. The vertices of this graph are the nodes, and the edges are the union of ⇒ and →.
Origination  We say that a term t originates at a node n = s ↓ i if the sign of n is positive; t и term(n); and t /и term(s ↓ i') for every i' < i. Thus, n represents a message transmission that includes t, and it is the first node in s including t. For instance, if si ∈ Init[A, B, Na, Nb, K], then Na and A both originate at si ↓ 1.
If a value originates on only one node in a set S of nodes, we call it uniquely originating in S; uniquely originating values are desirable as nonces and session keys. When we assume that a value like Na originates uniquely in some set S, we are effectively assuming that S is not unrealistically large, in a particular sense, namely so large as to contain independent events in which the same value is repeatedly chosen at random from a large set. Although both Na and A originate at si ↓ 1, Na is more likely to originate uniquely in relevant sets of nodes S.
Bundles A bundle is a finite, causally well-founded graph of nodes and arrows of both kinds → and ⇒. In a bundle, when a strand receives a mes- sage m, there is a unique node transmitting m from which the message was immediately received. By contrast, when a strand transmits a message m, many strands (or none) may immediately receive m. If s ↓ i is in a bundle and j < i, then s ↓ j must be in it also; taking the ith step depends on having already taken all previous steps. Moreover, the arrows must be acyclic, since otherwise an event would have preceded itself. (See Definition A.3.)
By acyclicity, the relation n0 ≤ n1 between nodes, which holds when there is a sequence of edges leading from n0 to n1, is a partial ordering. Since bundles are finite, ≤ is in fact a well founded relation, which justifies a principle of bundle induction (Proposition A.6). Every execution of a protocol must consist of a bundle, because a run is possible only if the causal constraints formalized in the definition of bundle are satisfied.
The height of a strand in a bundle is the number of nodes on the strand that are in the bundle. Authentication theorems assert that if some regular strand has at least a given height in a bundle, meaning that the principal must have engaged in at least that many steps of its run, then another regular strand must have a certain height in the bundle. They often assume that certain values are uniquely originating in the nodes of that bundle.
The Penetrator  While regular principals are represented only by what they say and hear, the behavior of the penetrator is represented more explic- itly. The values he deduces are treated as if they had been said publicly. A penetrator strand represents an atomic deduction, and more complex actions use several penetrator strands. We partition penetrator strands according

to the operations they exemplify. E-strands encrypt when given a key and a plaintext; D-strands decrypt when given a decryption key and matching ciphertext; C-strands and S-strands concatenate and separate terms, respec- tively; M-strands emit known atomic texts or guesses; and K-strands emit keys from a set of known keys. The set of initially known keys, that may be emitted in K-strands, is called KP. (See Definition A.8.)

Key Secrecy
In most cryptographic protocols, key secrecy relies on two basic facts. We let
У be a bundle, and consider how the regular nodes in У transmit keys.
First, suppose no regular strand in У ever originates a term containing a key K—that is, transmits K without having received it previously in the same form. Then either the penetrator starts off knowing K in KP, or else the penetrator never learns it. This is typically the situation with long-term shared keys, or with private keys in asymmetric cryptography. If K /∈ KP and no regular node in У ever originates a term containing K, then we say that K is immediately safe in У, written K ∈ S0(У), or K ∈ S0, since we will normally suppress the dependency of S0 on У.
Second, suppose that a key K may be transmitted by a regular strand in У, but if so it is always encrypted using another key K' such that K' ∈ S0. Then either the penetrator starts off knowing K in KP, or else the penetrator never learns it. This is typically the situation with session keys in well-designed protocols. When K /∈ KP and every regular strand that ever originates K protects it with some K' ∈ S0, then we say that K is safe at level 1, written K ∈ S1(У). Again, typically no confusion results from omitting У.
An inductive definition would be possible, but in practice S0 and S1 are usually sufficient. The safe keys are S = S0 ∪ S1. In [7] we prove that if K ∈ S and У is a bundle, then there is no node n ∈У such that K = term(n).

The Authentication Tests
Suppose in some bundle У, a principal creates and transmits a uniquely orig- inating value a, such as a nonce, and later receives a back in some crypto- graphically altered form. Then we could follow the trajectory of the value a from its origin, which we can call m0, through various sends and receives and along various strands, until it arrives back at the node m1 later on the same strand. Since m1 contains a in cryptographically altered form, some- where along this trajectory, someone has transformed it. If the key involved is safe, that someone cannot be the penetrator, it can only be a regular princi- pal. This is the authentication test idea, as developed and justified in [4,7,17]. There are two main forms of authentication test.
Outgoing Tests  A uniquely originating value a may be transmitted only in encrypted form {| ...a... |}K where the decryption key K−1 ∈ S is safe. If it



m¨0
¨
¨
¨
¨ 
m1
K−1 ∈ S	a и {|h|}K	✲



✛	a и term(n1)	✛ a и t'

n¨0
¨
¨
¨
¨ 
n1

Assume	{|h|}K /и term(n1)
a originates uniquely at m0, contained only in {|h|}K

Conclude	nodes n0, n1 exist in B and are regular
{|h|}K /и t'
m0 ≺ n0 ≺ n1 ≺ m1
Fig. 2. Outgoing Authentication Test
is later received outside the context {| ...a... |}K, then a regular participant, not the penetrator, must have been responsible the first time it appears in a different context. Observe that this regular participant transforms a after the original transmission of {| ...a... |}K at m0 and before the transformed version is received back at m1. The temporal relations “after” and “before” refer to the ordering ≺B generated by the arrows in the bundle У (as in Definition A.5). It is an outgoing test because the encrypted unit goes out; see Figure 2.
Incoming Tests  If, instead, a is received in encrypted form {| ...a... |}K although it was not sent in that context, and the encryption key K ∈ S is safe, then a regular participant must have been responsible when a entered this context. Again, the transformation producing {| ...a... |}K must occur after m0 and before m1. We call this an incoming test because the encrypted unit comes in, as shown in Figure 3.
Sometimes a uniquely originating value a is transmitted in one encrypted form {|h|}K and received back in a different {|h'|}K' . We include cases where h = h' or K = K', though not both. If K−1 ∈ S and K' ∈ S, then this is both an outgoing test and an incoming test. However, these two views may have different consequences. As an outgoing test, it implies a regular transforming edge that accepts {|h|}K and extracts a from it. This may be of some form other than {|h'|}K' , since another principal may later transform it again. The incoming test yields a transforming edge creating {|h'|}K' , although it may have received a in a form other than {|h|}K.
Pattern Matching to Find Transforming Edges  The authentication tests are important because they show that a regular strand does the trans- formation. Typically, there are very few edges on regular strands that are syntactically capable of performing the transformation. So a simple pattern



m¨0
¨
¨
¨
a и term(m0)	✲ 	✲ n

¨0
¨
¨
¨

 ¨   {|h|}	и term(m  )	K ∈ Safe	a и {|h|}	 ¨
m1 ✛	K	1	✛	K n1

Assume	{|h|}K /и term(m0)
a originates uniquely at m0
Conclude	nodes n0, n1 exist in B and are regular
m0 ≺ n0 ≺ n1 ≺ m1
Fig. 3. Incoming Authentication Test

matching determines which regular strands could have been responsible.
We call the responsible strand a transforming edge, because it transforms the way that a occurs. We will use the symbol ❀ to summarize what the trans- forming edge must do. We write for instance {|B , Na|}KA ❀ Na for a regular transforming edge containing a negative node with subterm {|B , Na|}KA fol- lowed by a positive node emitting a message in which Na occurs outside the context {|B , Na|}KA . An outgoing test guarantees the existence of a regu- lar, non-penetrator edge {|B , Na|}KA ❀ Na. The ❀ notation does not make explicit the form in which Na occurs; however, it is required that it occurs outside the context shown in the explicitly encrypted term on the other side. Conversely, we write Na ❀ {|B , Na|}KA for a regular transforming edge containing a negative node receiving Na outside of {|B , Na|}KA , followed by a positive node emitting a message with subterm {|B , Na|}KA . An incoming
test establishes that a regular transforming edge of this form exists.
Outgoing Tests: Additional Conclusion  There are additional conclu- sions that an authentication test allows in certain cases (see [7, Section 4.2.1]); one is relevant to the Yahalom protocol considered below.
Suppose in Figure 2 that a и {|h1|}K1 и term(n1), that a occurs only
−1
within {|h1|}K1 in term(n1), and that K	∈ S. Then there is also a regular
node n2 receiving {|h1|}K1 , meaning n2 is negative and {|h1|}K1 и term(n2).
Why does this hold? Either {|h1|}K1 и term(m1), in which case m1 is such a node, or else some principal must transform {|h1|}K1 to put a into whatever form it appears in term(m1). Because K−1 ∈ S, this transformation can be done only by a regular strand, which must receive {|h1|}K1 to do so.
This principle often helps to constrain the term {|h1|}K1 , or to fill in some parameters of the receiving strand. We use this principle twice in Section 5.3.
Unsolicited Tests   A third, related but weaker, type of test is the unso-


Table 1
The Authentication Tests
licited test. If a term {|t|}K is received, and K ∈ S is safe, then {|t|}K originated on some regular strand. After all, it originated somewhere, and that can not have been a penetrator strand if K ∈ S. Here we know only that the regular node originating {|t|}K is before the node on which it is received. We do not know any node after which it must have occurred. We write ❀ {|B , Na|}KA for the positive node that must exist as a result of an unsolicited test.
The authentication tests are summarized in Table 1. The last column contains × if the first node on the test edge is a lower bound (in the ordering
≤) constraining when the transforming edge occurs.
Assumptions for This Paper
If either of the long-term keys of two principals A and B is compromised, meaning that either KA ∈ KP or KB ∈ KP, then symmetric-key protocol exchanges involving them are hopeless: No security guarantee of interest will hold. Thus, we assume henceforth that for two particular principals A, B,
Assumption 1 KA, KB /∈ KP.
Hence, for reasonable protocols, KA, KB will be safe, i.e. KA, KB ∈ S0.
In the examples, we consider only symmetric cryptography, so we assume that the same key is used to create a ciphertext {|t|}K as to decrypt it:
Assumption 2 For all keys K, K = K−1.
Key Servers
We now formalize the intended behavior of key servers. They must obey three principles. First, the session key K delivered must never be known initially to the penetrator, since otherwise K is certainly not safe. Second, the key server must not re-use a session key, since it might spoil the confidentiality of a session key by retransmitting the same key to a compromised principal. A third principle is that a session key is never the same as a principal’s long term key, since otherwise the server might disclose a long term key by sending it (as a session key) to a compromised principal. We summarize these principles:
KS1 If ∃s . s ∈ Serv[∗∗, K] then K /∈ KP;
KS2 If s, s' ∈ Serv[∗∗, K], then s = s'; and


A	B
¨•	A , Na	✲ ¨•

¨
¨	S
¨
¨	B , Nb
¨	• ✛
¨  N , {|B , K , N |}	, {|A , B , K , N |}	¨ 
¨• ✛ b	a  KA	b  KB  •
¨
¨
¨
, {|A , Na|}KB
¨
¨
¨
¨

¨
{|A , B , K , Nb|}KB
, {|Nb|}
¨ 
K	✲ •


Fig. 4. The Yahalom-Paulson Protocol
KS3 ∃s . s ∈ Serv[∗∗, K] implies K /= KA for any A.
In normal protocols, all of the server parameters X1,..., Xn,K appear non- vacuously in messages, and K originates on a node of s ∈ Serv[∗∗, K]. Then KS1 and KS2 imply that K is uniquely originating. Moreover, when s ∈ Serv[X1,..., Xn, K] and s' ∈ Serv[X' ,..., X' , K], then KS2 implies X1 =
1	n
X' ,..., Xn = X' .
1	n
We interpret the principles as a constraint on bundles. That is, we intend
to consider only bundles У such that KS1–KS3 hold. The strands s are those strands such that for some node n = s ↓ i, n ∈ У. Thus, ∃s . φ means that there is some strand s with at least one node in У such that φ.
We regard a bundle У as formalizing what might reasonably happen over a period of time (whether brief or reasonably extended) in a network of prin- cipals executing one or more protocols. The likelihood that У contains a counterexample to KS1–KS3 is taken to be negligible if the cryptography and key-generation algorithms are well chosen and well implemented.

Yahalom and its Variants
We next present three variants of the Yahalom protocol [1,16]. They suggest the main idea for analyzing key compromise. We start with a variant in which key compromise is not an issue.

The Yahalom-Paulson Protocol
Paulson [16], following ideas from the BAN paper [1], modified a protocol originally invented by Yahalom. The result, as illustrated in Figure 4, is a tight protocol not vulnerable to key compromise. In this protocol, the participants get their guarantees by a succession of incoming tests.
The Initiator’s Guarantees  Assume given a bundle У containing an ini-

tiator strand si ∈ Init[A, B, Na, Nb, K], and assume that the nonces Na, Nb
are uniquely originating. What follows?
A’s nonce Na is returned in the form {|B , K , Na|}KA , thereby guarantee- ing an edge Na ❀ {|B , K , Na|}KA . By case analysis, this edge occurs on a server strand ss. By matching variables, ss ∈ Serv[A, B, Na, ∗, K].
Hence, {|A , Na|}KB и term(ss ↓ 1). We use {|A , Na|}KB as an unsolicited test term, which implies that there is a positive node ❀ {|A , Na|}KB . This node can occur only on sr ↓ 2 where sr ∈ Resp[A, B, Na, ∗∗]. We have now derived the initiator’s guarantees about ss and sr.
The Responder’s Guarantees Assume next a bundle У containing a responder strand sr ∈ Resp[A, B, Na, Nb, K], and assume that the nonces Na, Nb are uniquely originating. B’s nonce Nb is returned in both the forms
{|A , B , K , Nb|}KB and {|Nb|}K. The first is an incoming test, because KB ∈
S. This guarantees a transforming edge Nb ❀ {|A , B , K , Nb|}KB , which lies on a server strand ss. Noting the variables occurring in {|A , B , K , Nb|}KB , we infer ss ∈ Serv[A, B, ∗, Nb, K].
The key server assumption KS2 implies that K is transmitted only in the forms {|A , B , K , Nb|}KB and {|B , K , N |}KA (for some N ). Since in addition, by KS1, K /∈ KP, it follows that K ∈ S1, and is safe.
Thus +Nb ⇒ −{|Nb|}K is also an incoming test, and guarantees a trans- forming edge Nb ❀ {|Nb|}K. It can lie only on an initiator strand si ∈ Init[I, R, N, Nb, K]. We would like to ensure that I and R are A and B respectively. By the form of the strand, we know that {|R , K , N |}KI и term(si ↓ 2). However, K is transmitted only in the forms {|A , B , K , Nb|}KB and {|B , K , N |}KA . Since the first term does not match, {|R , K , N |}KI =
{|B , K , N |}KA , so R = B and I = B.
We need not worry about key compromise in this protocol. A’s incoming test guarantees that S generates K after receiving Na. So the key is more recent than the beginning of A’s own strand. This strand will be implemented to time out long before any cryptanalytic attack could be completed, so K cannot have been compromised yet. The same reasoning applies to B and Nb.

The Weakened Yahalom Protocol
The important change in the Yahalom-Paulson protocol was to include the responder’s nonce Nb as part of the encrypted ticket {|A , B , K , Nb|}KB gen- erated by the server. In contrast, a weakened Yahalom protocol (also discussed by Paulson) omits this nonce from the encrypted ticket. It is transmitted in plaintext and returned encrypted under the session key K, but not in the ticket (Figure 5). An authentication test analysis also verifies the correctness of this protocol, ignoring the risk of key compromise.
No compromise  Focusing on responder’s point of view, we cannot start with an incoming test as in the Yahalom-Paulson protocol, because Nb is not


A	B
¨•	A , Na	✲ ¨•

¨
¨	S
¨
¨	B , Nb
¨	• ✛
¨  {|B , K , N  , N |}	, {|A , K|}	¨ 
¨• ✛	a	b KA	KB  •
¨
¨
¨
, {|A , Na|}KB
¨
¨
¨
¨

¨
{|A , K|}KB
•
, {|Nb|}
¨ 
K	✲ •


Fig. 5. The Weakened Yahalom Protocol



returned encrypted under KB, and we do not yet know whether K ∈ S.
Instead, we start with an unsolicited test. {|A , K|}KB is encrypted with a safe key, so a regular node originates ❀ {|A , K|}KB . By the form of the protocol, this positive node is on ss ∈ Serv[A, B, ∗, ∗, K]. By KS1 and KS2, the only transmissions of K are protected by KA and KB, so K is safe.
We may now infer that the edge + ... Nb ··· ⇒ −{|Nb|}K is an incoming test, guaranteeing a regular transforming edge Nb ❀ {|Nb|}K. This is si ↓ 2 ⇒ si ↓ 3 for si ∈ Init[I, R, ∗, Nb, K]. However, by an unsolicited test, there exists
' ∈ Serv[I, R, ∗, ∗, K], so by KS2 ss = s' , whence I = A and R = B.
Compromised by time Key compromise changes this situation. Because we started with an unsolicited test, we do not know how long ago the server strand ss occurred. In particular, it may have been before a previous session in which the key K encrypted a large amount of data. Cryptanalysis may thus have disclosed it. If the penetrator has access to K, then the edge ... Nb ··· ⇒
{|Nb|}K is no longer an incoming test, invalidating the rest of our argument.
Figure 6 illustrates what might go wrong. In the upper left hand corner, we show incompletely an old server strand marked S. The term tB stands for the ticket {|A , K|}KB , and tA stands for the corresponding encrypted message for A. K originates in the center of Figure 6 as a result of cryptanalysis, which we have no desire to represent more explicitly. A , Na is a message sent by the penetrator, purporting to be A. Separation strands are shown in incomplete form when one result is discarded.
This key compromise attack is perhaps less obvious than the NSSK attack, since there is no suspicious neck in the protocol definition. However, the underlying problem is the same: B cannot verify the recency of the session key K. And the cause of the problem is the same, namely that the protocol relies on an unsolicited test rather than an incoming or outgoing test.



S
✛ tA , tB	•
¨
 


¨• ✛	K	•

•	tB	✲ •	¨
¨	¨
¨	¨
¨	¨
¨	¨
¨	¨
¨	 
¨¨	• ✛
	{|N |}	 
¨• ✛	b K	•


•
B , Nb
•
Nb	 
•

B
A , Na	✲ •
, {|A , Na|}K	 
¨
¨
¨
¨
¨
¨

	tB , {|Nb|}K	✲ 

Fig. 6. Key Compromise Attack on Weakened Yahalom

A	B
A , N
¨•	¨

¨
¨	S
¨
¨	B , {|A , N 
¨
¨
¨
, N |}

¨
¨  {|B , K , N  , N |}	, {|A , K|}
¨• ✛	a	b KA	KB
¨• ✛
¨ 
•
a	b KB
¨
¨
¨
¨

¨
{|A , K|}KB
•
, {|Nb|}
¨ 
K	✲ •


Fig. 7. The Yahalom Protocol
The Yahalom Protocol
The original Yahalom protocol (Figure 7) lies in between the Yahalom-Paulson protocol and the weakened version. It avoids sending the nonce Nb in plaintext, yet it does not include the nonce in the ticket S generates for B. Our question is, does this save the protocol from the key-compromise attack? To answer this question, we will extract a notion of recency from the examples, and use it to provide a more accurate specification for key servers.

Recency
We first define a useful notion of recency motivated by the causal ordering relation on bundles. We then adapt the constraints KS1–KS2 on key servers,

so that they entail that session keys are uncompromised if recently generated.
A Notion of Recency
Our core idea is that regular strands provide a way to measure recency. Im- plementors always ensure that a protocol run will time out long before crypt- analysis could have succeeded, a matter of hours at least in the case of any usable cryptosystem. 1 Thus, a principal engaged in a strand knows that an event is recent, if it happened after an earlier event on the same strand.
Definition 5.1 (Recency for) A node n is recent for a regular node m1 in
У if there is a regular node m0 ∈У such that m0 ⇒+ m1 and m0 ≤B n ≺B m1.
The incoming and outgoing tests entail recency. That is, if m0 ⇒+ m1 is a test edge, and n0 ⇒ n1 is the corresponding transforming edge in У, then m0 ≤ n0 ≺ n1 ≺ m1, so that n0 and n1 are recent for m1. By contrast, an unsolicited test provides no evidence of recency.
Key Servers and Recency
We now reformulate two of our principles governing key servers. The third, KS3, does not need reformulation, since it stipulates that session keys are disjoint from long term keys.
The other two original principles KS1–KS2 expressed the assumption that a session key would be uncompromised forever. The more realistic assumption is that it is uncompromised if recently generated. There are two ingredients in this, one being that the penetrator will not guess a recent session key. The other ingredient is that if a key server generated a session key K recently before a node n, then no other server run that could affect n also generated the same key K. We combine these two ingredients in a single principle.
We say that K originates uniquely previous to m in У if there exists a unique node n such that n ≤B m and K originates at n. The nodes previous to m are all those that could have a causal influence on m, its backward light cone, to borrow a metaphor from the theory of relativity.
RKS If ∃s . s ∈ Serv[∗∗, K] and some node s ↓ i on s is recent for m in У, then K originates uniquely previous to m in У.
In reasonable key distribution protocols, K originates on s if s ∈ Serv[∗∗, K]. Thus, RKS entails that there is no penetrator K-node previous to m emitting the session key K. That would be another originating node. It also entails that no other server strand emits the same session key K previous to m. Thus, it covers the intended effect of KS1–KS2, in case the server run was recent, for the part of У that can affect m.

1 Also, cryptanalysis can typically begin only after a key establishment protocol has com- pleted, as the traffic from an encrypted session is a more promising source than the protocol messages themselves.


Sub-Bundles  How can we reason about the nodes previous to a given node m? If У is a bundle and m ∈ У is any node in it, then the set of nodes S = {n ∈ У: n ≤B m} is a sub-bundle У0, when equipped with those edges of У both endpoints of which are in S [6].
Suppose moreover that we are trying to establish an authentication result for a particular strand s in У. The logical form of authentication results ([19], cp. [11,20]) requires us to show that a corresponding portion of another strand s' is also included in У. Let m be the last node on s such that m ∈ У, and consider the sub-bundle У0 of nodes n ≤B m. If we can prove that the required portion of s' is included in the sub-bundle У0, then it is also included in У.
Thus, when proving an authentication result, we may ignore the portion of У not previous to the nodes of interest. We then reason about the sub-bundle, and transfer the authentication results back to У. The transfer is valid even if the conclusions are drawn using the authentication test method using the safe keys S0 and S1 within У0, i.e. S0(У0) and S1(У0).

Analysis of Yahalom
We now show why Yahalom’s protocol is correct, even when non-recent session keys may be compromised. We again focus on the responder.
Suppose that a bundle У contains all three nodes of a regular strand sr ∈ Resp[A, B, Na, Nb, K], and Nb is uniquely originating. What authentication guarantees does the responder B have about the other participants in У? Let У0 be the sub-bundle of У containing the nodes n ∈ У, such that n ≤B (sr ↓ 3). First, since KB ∈ S0, the edge sr ↓ 2 ⇒ sr ↓ 3 is an outgoing test with test component {|A , Na , Nb|}KB . Thus, there is a recent transforming edge {|A , Na , Nb|}KB ❀ Nb. The latter must lie on a recent server strand
ss ∈ Serv[A, B, Na, Nb, K'] for some K'.
By RKS, we may infer that K' originates uniquely previous to Sr ↓ 3, and thus originates uniquely in У0. In particular, K' ∈ S. Since K' does not occur in the test term {|A , Na , Nb|}K , we cannot yet say whether K' = K.
We now use the extension to the outgoing test condition mentioned above in Section 2.3 and justified in [7, Section 4.2.1]. Nb is again transmitted on

ss ↓ 2, contained only in the form {|B , K' , Na , Nb|}K
.	Since KA ∈ S,

it implies that {|B , K' , Na , Nb|}K
is also a subterm of a regular receiving

node. 2 Considering the cases possible in this protocol, that node is si ↓ 2 where si ∈ Init[A, B, Na, Nb,K ]. Thus, term(si ↓ 3) = {|Nb|}K' .
Since K' ∈ S, we may apply the same principle again, inferring that
{|Nb|}K' is also a subterm of a regular receiving node. In the protocol, that

node is s'
↓ 3 where s'
∈ Resp[∗∗, Nb, K']. However, since Nb is uniquely

originating, and originates on both sr and s' , sr = s' . Therefore, K = K'.
r	r

2 Strictly speaking, the relevant fact is K −1 ∈ S, but K−1 = KA because the protocols
A	A
considered in this paper use only symmetrical keys (Assumption 2).


A	S

¨• ✛	A , B , Ns
  {|A , B , Ns , K|}K
•
•
 
•
  {|A , B , N ' , K|}	B
¨	¨

  ✛	{|N ' , Nb|}K
¨•	¨•
	Nb	✲ 

Fig. 8. The Trusted Introducer Protocol
Thus, ss ∈ Serv[A, B, Na, Nb, K] and si ∈ Init[A, B, Na, Nb, K]. This es- tablishes B’s authentication guarantees in У0. By our transfer principle for authentication results, the same guarantees also hold in the larger bundle У. Secrecy goals are of course a different matter. The secrecy of the session key K is guaranteed in У0, as a consequence of RKS. However, nothing guarantees that K remains secret in У, because У may contain nodes for which ss is no longer recent. Those nodes may issue in a disclosure of K, for instance as a consequence of cryptanalysis.

Conclusion
In this paper, we have distinguished between protocols like NSSK or Weakened Yahalom, which are susceptible to key compromise attacks, and those like Otway-Rees [1,14,19] or Yahalom, which are not. Our notion of recency is perfectly adapted to our protocol verification method, the authentication test method: the incoming and outgoing authentication tests provide a guarantee of the recency of their transforming edges.
This notion of recency is not complete. In the slightly peculiar protocol shown in Figure 8, the principals share a long term key with a server, which is only a trusted introducer; it does not generate session keys. The initiator furnishes the session key. The responder uses an outgoing test to ensure a recent server’s session ss ∈ Serv[A, B, ∗,N ', Nb, K]. The server had used an incoming test to ensure an initiator’s session si ∈ Init[A, B, Ns, K] recent for
ss. However, si is not recent for sr, although it was recently recent.
We want a sort of “extension ladder” notion of recency here. Let us define:
A node n is 1-recent for m if n is recent for m as in Definition 5.1;
A node n is i + 1-recent for m1 if there exists a node m0 such that n is
i-recent for m0 and m0 is recent for m1.
If n is i-recent for m, then there are i + 1 strands, each overlapping a portion of the preceding one. From beginning to end, at most i + 1 times the time-

out for a single regular strand can have elapsed. A particular cryptosystem and protocol implementation determines what values of i are small enough to avoid key compromise. The protocol determines what degree of recency is guaranteed, which for the introducer’s protocol is 2-recency.
Acknowledgments  Supported by the National Security Agency under US Army CECOM contract number DAAB07-99-C-C201.
Larry Paulson suggested the Yahalom protocol to me as a provocative test case. Gavin Lowe described related work of his own to me, and suggested the “extension ladder” notion of recency. They also made helpful comments on a previous draft. I am grateful to the two of them, and also to Javier Thayer, with whom I discussed all this.

References
Burrows, M., M. Abadi and R. Needham, A logic of authentication, Proceedings of the Royal Society Series A, 426 (1989), pp. 233–271, also appeared as SRC Research Report 39 and, in a shortened form, in ACM Transactions on Computer Systems 8, 1 (February 1990), 18-36.
Denning, D. and G. Sacco, Timestamps in key distribution protocols, Communications of the ACM 24 (1981).
Dolev, D. and A. Yao, On the security of public-key protocols, IEEE Transactions on Information Theory 29 (1983), pp. 198–208.
Guttman, J. D., Security goals: Packet trajectories and strand spaces, in:
R. Gorrieri and R. Focardi, editors, Foundations of Security Analysis and Design, LNCS 2171, Springer Verlag, 2001 Forthcoming.
Guttman, J. D. and F. J. Thayer F´abrega, Authentication tests, in:
Proceedings, 2000 IEEE Symposium on Security and Privacy, May (2000).
Guttman, J. D. and F. J. Thayer F´abrega, Protocol independence through
disjoint encryption, in: Proceedings, 13th Computer Security Foundations Workshop (2000).
Guttman, J. D. and F. J. Thayer F´abrega, Authentication tests and the
structure of bundles, Theoretical Computer Science (2001), to appear.
Heather, J. and S. Schneider, Toward automatic veriﬁcation of authentication protocols on an unbounded network, in: Proceedings, 13th Computer Security Foundations Workshop (2000).
Lowe, G., Breaking and ﬁxing the Needham-Schroeder public-key protocol using FDR, in: Proceeedings of tacas, Lecture Notes in Computer Science 1055 (1996), pp. 147–166.
Lowe, G., Casper: A compiler for the analysis of security protocols, in: 10th Computer Security Foundations Workshop Proceedings (1997), pp. 18–30.


Lowe, G., A hierarchy of authentication speciﬁcations, in: 10th Computer Security Foundations Workshop Proceedings (1997), pp. 31–43.
Marrero, W., E. Clarke and S. Jha, A model checker for authentication protocols, in: C. Meadows and H. Orman, editors, Proceedings of the DIMACS Workshop on Design and Veriﬁcation of Security Protocols, DIMACS, Rutgers University, 1997.
Needham, R. and M. Schroeder, Using encryption for authentication in large networks of computers, Communications of the ACM 21 (1978).
Otway, D. and O. Rees, Efficient and timely mutual authentication, Operating Systems Review 21 (1987), pp. 8–10.
Paulson, L. C., The inductive approach to verifying cryptographic protocols, Journal of Computer Security (1998), also Report 443, Cambridge University Computer Lab.
Paulson, L. C., Relations between secrets: Two formal analyses of the Yahalom protocol, Journal of Computer Security (2001), also available as Cambridge University Computer Laboratory Technical Report 432 (1997).
Perrig, A. and D. X. Song, Looking for diamonds in the desert: Extending automatic protocol generation to three-party authentication and key agreement protocols, in: Proceedings of the 13th IEEE Computer Security Foundations Workshop (2000).
Schneider, S., Verifying authentication protocols with CSP, in: Proceedings of the 10th IEEE Computer Security Foundations Workshop (1997), pp. 3–17.
Thayer F´abrega, F. J., J. C. Herzog and J. D. Guttman, Strand spaces: Proving security protocols correct, Journal of Computer Security 7 (1999), pp. 191–230.
Woo, T. Y. C. and S. S. Lam, Verifying authentication protocols: Methodology and example, in: Proc. Int. Conference on Network Protocols, 1993.

Strand Space Definitions
This appendix, derived from [4,7,19], defines the basic strand space notions.
Strands, Strand Spaces, and Origination
Consider a set A, the elements of which are the possible messages that can be exchanged between principals in a protocol. We will refer to the elements of A as terms. We assume that a subterm relation is defined on A. t0 и t1 means t0 is a subterm of t1. We constrain the set A further below in Section A.3, and define a subterm relation there.
In a protocol, principals can either send or receive terms. We represent transmission of a term as the occurrence of that term with positive sign, and reception of a term as its occurrence with negative sign.

Definition A.1 A signed term is a pair ⟨σ, a⟩ with a ∈ A and σ one of the symbols +, −. We will write a signed term as +t or −t. (±A)∗ is the set of finite sequences of signed terms. We will denote a typical element of (±A)∗ by ⟨ ⟨σ1, a1⟩, ..., ⟨σn, an⟩ ⟩.
A strand space over A is a set Σ with a trace mapping tr :Σ → (±A)∗.
By abuse of language, we will still treat signed terms as ordinary terms. For instance, we shall refer to subterms of signed terms. We will usually represent a strand space by its underlying set of strands Σ.
Definition A.2 Fix a strand space Σ.
A node is a pair ⟨s, i⟩, with s ∈ Σ and i an integer satisfying 1 ≤ i ≤
length(tr(s)). The set of nodes is denoted by N. We will say the node
⟨s, i⟩ belongs to the strand s. Clearly, every node belongs to a unique strand.
If n = ⟨s, i⟩ ∈ N then index(n) = i and strand(n) = s. Define term(n) to be (tr(s))i, i.e. the ith signed term in the trace of s. Similarly, uns term(n) is ((tr(s))i)2, i.e. the unsigned part of the ith signed term in the trace of s.
There is an edge n1 → n2 if and only if term(n1)= +a and term(n2)= −a for some a ∈ A. Intuitively, the edge means that node n1 sends the message a, which is received by n2, recording a potential causal link between those strands.
When n1 = ⟨s, i⟩ and n2 = ⟨s, i + 1⟩ are members of N, there is an edge n1 ⇒ n2. Intuitively, the edge expresses that n1 is an immediate causal predecessor of n2 on the strand s. We write n' ⇒+ n to mean that n' precedes n (not necessarily immediately) on the same strand.
An unsigned term t occurs in n ∈N iff t и term(n).
Suppose I is a set of unsigned terms. The node n ∈ N is an entry point for I iff term(n) = +t for some t ∈ I, and whenever n' ⇒+ n, term(n') /∈ I.
An unsigned term t originates on n ∈ N iff n is an entry point for the set I = {t' : t и t'}.
An unsigned term t is uniquely originating in a set of nodes S ⊂ N iff there is a unique n ∈ S such that t originates on n.
An unsigned term t is non-originating in a set of nodes S ⊂ N iff there is no n ∈ S such that t originates on n.
If a term t originates uniquely in a suitable set of nodes, then it can play the role of a nonce or session key, assuming that everything that the penetrator does in some scenario is in that set of nodes.
N together with both sets of edges n1 → n2 and n1 ⇒ n2 is a directed graph ⟨N , (→∪ ⇒)⟩.

Bundles and Causal Precedence
A bundle is a finite subgraph of ⟨N , (→∪ ⇒)⟩, for which we can regard the edges as expressing the causal dependencies of the nodes.
Definition A.3 Suppose →C ⊂ →; suppose ⇒C ⊂ ⇒; and suppose C =
⟨NC, (→C ∪ ⇒C)⟩ is a subgraph of ⟨N , (→∪ ⇒)⟩. C is a bundle if:
NC and →C ∪ ⇒C are finite.
If n2 ∈ NC and term(n2) is negative, then there is a unique n1 such that
n1 →C n2.
If n2 ∈ NC and n1 ⇒ n2 then n1 ⇒C n2.
C is acyclic.
In conditions ii and iii, it follows that n1 ∈ NC, because C is a graph.
Definition A.4 A node n is in a bundle C = ⟨NC, →C ∪ ⇒C⟩, written n ∈ C, if n ∈ NC; a strand s is in C if all of its nodes are in NC.
If C is a bundle, then the C-height of a strand s is the largest i such that
⟨s, i⟩∈ C. C-trace(s)= ⟨tr(s)(1),..., tr(s)(m)⟩, where m = C-height(s).
We say that s ∈C if the C-height of s equals length(s).
Definition A.5 If S is a set of edges, i.e. S ⊂→ ∪ ⇒, then ≺S is the transi- tive closure of S, and ≤S is the reflexive, transitive closure of S.
Proposition A.6 Suppose C is a bundle. Then ≤C is a partial order, i.e. a reflexive, antisymmetric, transitive relation. Every non-empty subset of the nodes in C has ≤C-minimal members.
We regard ≤C as expressing causal precedence, because n ≺S n' holds only when n’s occurrence causally contributes to the occurrence of n'. When a bundle C is understood, we will simply write ≤. Similarly, “minimal” will mean ≤C-minimal.
Terms, Encryption, and Freeness Assumptions
We will now specialize the set of terms A. In particular we will assume given:
A set T ⊆ A of texts (representing the atomic messages).
A set K ⊆ A of cryptographic keys disjoint from T, equipped with a unary operator inv : K → K. We assume that inv is an inverse mapping each member of a key pair for an asymmetric cryptosystem to the other, and each symmetric key to itself.
Two binary operators encr : K × A → A and join : A × A → A.
We follow custom and write inv(K) as K−1, encr(K, m) as {|m|}K, and join(a, b) as a , b. In this paper, we are concerned only with symmetric-key protocols, so we assume that K = K−1 always.
We assume, like many others (e.g. [10,12,15]), that A is freely generated.

Axiom 1 A is freely generated from T and K by encr and join.
Definition A.7 The subterm relation и is defined inductively, as the smallest relation such that a и a; a и {|g|}K if a и g; and a и g , h if a и g or a и h.
By this definition, for K ∈ K, we have K и {|g|}K only if K и g already.
Penetrator Strands
The atomic actions available to the penetrator are encoded in a set of pene- trator traces. They summarize his ability to discard messages, generate well known messages, piece messages together, and apply cryptographic operations using keys that become available to him. A protocol attack typically requires hooking together several of these atomic actions.
The actions available to the penetrator are relative to the set of keys that the penetrator knows initially. We encode this in a parameter, the set of penetrator keys KP.
Definition A.8 A penetrator trace relative to KP is one of the following:
Mt Text message: ⟨+t⟩ where t ∈ T.
KK Key: ⟨+K⟩ where K ∈ KP.
Cg,h Concatenation: ⟨−g, −h, +g , h⟩ Sg,h Separation: ⟨−g , h, +g, +h⟩ Eh,K Encryption: ⟨−K, −h, +{|h|}K⟩.
Dh,K Decryption: ⟨−K−1, −{|h|}K, +h⟩.
PΣ is the set of all strands s ∈ Σ such that tr(s) is a penetrator trace.
A strand s ∈ Σ is a penetrator strand if it belongs to PΣ, and a node is a penetrator node if the strand it lies on is a penetrator strand. Otherwise we will call it a non-penetrator or regular strand or node. A node n is M, C, etc. node if n lies on a penetrator strand with a trace of kind M, C, etc.
Since in this paper we assume K = K−1, the key used ina D-strand is the same as the one used to create the ciphertext.
