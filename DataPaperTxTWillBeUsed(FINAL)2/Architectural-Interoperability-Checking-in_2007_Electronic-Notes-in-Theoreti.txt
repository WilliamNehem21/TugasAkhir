Electronic Notes in Theoretical Computer Science 181 (2007) 81–96	
www.elsevier.com/locate/entcs

Architectural Interoperability Checking in Visual Coordination Networks1
David Sˇafra´nek2
Department of Computer Science, Faculty of Informatics Masaryk University Brno, Czech Republic

Abstract
In this paper, the approach [1] of architectural interoperability checking is revisited and utilized for interop- erability checking of architectures with connectors and components treated as behaviorally and expressively different elements of architecture description. By that way, the framework of architectural interoperability checking for a diagrammatic language Visual Coordination Networks is established.
Keywords: Visual Coordination Networks, architecture interoperability checking, visual specification, concurrent systems, exogenous coordination model


Introduction
Hierarchical component-based system design can be underlied with precise oper- ational semantics which allows to join traditional software and hardware design methods with formal methods known from the theory of process algebras (e.g., re- finement, equivalence or model checking). Additionally, syntactical and semantical separation of modeling of coordination (interaction) aspects from modeling of be- havioral (computation) aspects in architectural descriptions makes it possible to model a static communication infrastructure of a system independently of its be- havioral parts. In such a setting, it can be ensured by architectural description that the system under specification is correct by design concerning the interoperability correctness of component cooperation.
In this paper we present a formal architectural interoperability checking method- ology for a visual formalism Visual Coordination Networks (VCN). This language is based on our previous work [12].

1 This work has been supported by the Grant Agency of Czech Republic grant No. 201/06/1338, the Academy of Sciences of CR grant No. 1ET408050503, and the research center Institute for Theoretical Computer Science (ITI), project No. 1M0021620808.
2 Email: xsafran1@fi.muni.cz

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.01.055

VCN employ an exogenous coordination model [3]. In such a model, coordi- nation aspects are semantically separated from computational aspects. VCN can be viewed as static architecture diagrams specifying connections among compo- nents. To capture coordination aspects, connectors — so-called VCN buses — are introduced. By a particular VCN bus the behavior of some coordination model is specified.
Related Work
Graphical calculus of communicating systems [6] and Architectural Interaction Di- agrams [9] represent the previous work on this topic. To our best knowledge, for none of those languages interoperability aspects were studied.
In the community of coordination languages, there is a large group of languages which have properties of architectural languages. The most recent language from this domain is Reo [4]. Reo supports control-driven exogenous coordination and is execution-oriented in contrast to design-oriented VCN.
In the process of hardware and software design, it has appeared useful to treat behavioral aspects separately from architectural aspects of a system under design. Such ideas of aspect separation have been tackled in the most of work concerning architectural description languages [7]. These principles are also employed in the recent version of the UML language.
Our Contribution
There is an exhaustive piece of work by Bernardo et al. on the topic of interoperabil- ity checking of architectural descriptions formalized in traditional process algebraic framework. In [5] it has been proved that for checking of an acyclic component topology it suffices to check interaction compatibility of all pairs of mutually con- nected components. The notion of such compatibility is based on weak bisimilarity of the two components in a pair. An abstraction of both components is considered comprising only actions of mutual interaction, while all other actions are hidden. In [1] this methodology of compatibility checking has been extended to arbitrary network topologies which can include cyclic relationships among components.
We show that a similar approach can be extended to the behavioral model of VCN. In contrast to [1,5], dependency graph of an architecture in VCN is bipar- tite, as VCN distinguishes connectors and components as two semantically different members of the architecture. In other words, such an extension has to to define the notion of architectural compatibility between any two adjacent nodes, which are given as a pair of a connector and a component. Moreover, VCN introduces a set-labeled transition operational semantics to capture behavioral model of con- nectors. This extension increases the expressiveness of the supported coordination model. In this paper, the notion of architectural interoperability is revisited and extended to capture needs of such a setting. Especially, there is no traditional no- tion of a parallel composition operator in VCN and therefore general congruence results employed in [1,5] cannot be directly employed here. The main result of this paper shows how the ideas of [1] are extended for the VCN setting.

Visual Coordination Networks
Overview
At the most abstract level of view, VCN introduces hierarchy of two separate layers
— the computation layer and the coordination layer. The computation layer focuses on computational aspects of a system under design, while the coordination layer deals with interaction aspects. The principle of such a layered structure reflects the nature of component-based system design, and is inspired by the work on software architecture description (i.e., Wright [2]).
In our setting, the computation layer is treated as a low-level layer of system specification, upon which the coordination layer rests. Thus from the designers point of view, both the top-down and the bottom-up design methodologies can be applied in system design using VCN. On one hand, VCN allows the computation layer to be considered as a supplementary layer which can be added to the modeled system hierarchy later during the particular design process (top-down approach). On the other hand, one can specify the computation of components at first, while the coordination layer can be added later (bottom-up approach).

Coordination layer
The main idea of the VCN coordination layer, which revises the concept introduced in Wright [2], is to describe interaction aspects of a static component-based archi- tecture. The notion of such a static structure concerns topology of concurrently running components permanently coordinated by specific connectors. This topol- ogy is determined by the point-to-point links which connect component interface ports to particular connectors. The respective VCN construct that represents such topologies of components and connectors is called a network. An example of a network is depicted in Figure 1.







Fig. 1. A network of four components coordinated by one bus

Similarly to Wright, connectors are treated as first-class citizens (at the same specification level as components). In the VCN setting, connectors are called buses. Buses represent coordination mechanisms which control component interaction. The coordination model represented by buses is characterized by atomic actions called cooperations, which have the meaning of atomic multi-synchronization of a set of some components in a particular network.

Computation layer
Component computation is described by VCN leaves. VCN leaves are cornerstones of the computation layer. In our setting, leaves are assumed to be abstract computa- tion models of system components. More particularly, a leaf is an atomic element in the VCN structure that can be specified in an arbitrary formalism for formal descrip- tion of reactive computation. It is assumed that the kind of formalism which can be used for this purpose is compatible with the semantic model employed in VCN. In general, the potential set of such compatible formalisms includes any reactive computation description language which can be encoded into a labelled transition system.
Network hierarchy
The computation layer makes the bottom most level of the VCN hierarchy. It is determined by the set of all leaves which are used in the particular system design. As it has been mentioned above, leaves directly represent computation of components and are interconnected by buses to induce network topologies.
In a natural sense, such a network topology of leaves and buses can be abstractly viewed as a black box with complex behavior hidden inside (defined by computation of leaves coordinated by buses). More specifically, computation is represented not only by leaves, but also by entire network topologies. This idea leads us to consider the notion of component to be more abstract than the notion of leaf. In particular, either a leaf or a network can be sensed as a component in the VCN style of thinking. The possibility of taking a network as a component allows the coordination layer to have more levels of hierarchy.

VCN Structure and its Behavioral Model
In this section, we present a simplified version of VCN language. The considered simplification is focused on VCN networks in order to develop the framework for architectural interoperability checking.

Structural Terms
Similarly as in the case of Statecharts-like formalisms [8], the semantics of VCN is defined by textual terms. In VCN we distinguish between structural terms that formalize a system architecture, and behavioral terms that formalize a behavioral model (component and network computation). Key elements of VCN are ports which form component interfaces. Each port is identified by a label which is un- ambiguous in the scope of a particular level of hierarchy. A port can be sensed as a place on which events observed during the particular component computation occur. We distinguish two kinds of ports – input ports, on which the relevant events of the environment are received, and output ports, by which the relevant events are emitted to the environment.

Definition 3.1 Fix L a countable set of labels and assume τ
∈/ L. Define ports

as members of the set P
df
df
= L× {in, out}. Further define projections of P – the

set of output ports W = {p ∈ P  p = ⟨l, out⟩,l ∈ L} and the set of input ports
df
R = {p ∈P  p = ⟨l, in⟩,l ∈ L}.
To ensure that each port label is unique in the particular network scope, we annotate each port with an index denoting the component to which it belongs. In particular, we assume that each component in a network is identified by a unique natural number.
Definition 3.2 Define set of annotated ports P df {⟨p, i⟩ p ∈ P,i ∈ N }. Further define respective projections as sets of annotated output and annotated input ports,

W  df
  df

Remark 3.3 For some i ∈ N we denote the set of ports annotated by i as
df
= {⟨p, i⟩ p ∈ P}. Moreover, members of the set P are usually represented
by symbols p, p1, p2,.. ., members of W by w, w1, w2,. . . , and, finally, members of R by r, r1, r2,. . . Note the important fact that W ∩ R = ∅. By the notation p i for some i ∈N we mean ⟨p, i⟩∈ P . Thus an input port r ∈R annotated by i ∈ N , is denoted r i . Annotated output ports are denoted in the same way. Whenever the annotation number i is not important in the particular context for an annotated port p i , we omit the upper index ’ i’ and write simply p.
For a specific set of (unannotated) ports P ⊆ P, the set containing these ports all annotated by i ∈N is denoted P i . For the set of ports of all annotation indices

the notation P , P
  df 
i∈N P
 i , is used.

Now we introduce a fundamental notion of the concept of buses – the notion of cooperations. A cooperation can be sensed as a group of ports on which the respective computational events are atomically synchronized when the cooperation occurs.
Definition 3.4 Let W ⊂ W  and R ⊂ R  finite sets of ports. Define cooperation
as the pair ⟨W , R ⟩, denoted ⟨W /R ⟩, satisfying:
∀i, j ∈ N , w1, w2 ∈ W, r1, r2 ∈ R. (w1 i, w2 j ∈ W ⇒ i /= j)
∧(r1 i , r2 j ∈ R ⇒ i /= j)
We say that a port p is included in a cooperation c := ⟨W /R ⟩, and write p ∈ c,
if either p ∈ W  or p ∈ R . The set of all cooperations is denoted Coops.
The condition (1) ensures the natural requirement that at most one input port or one output port of each component can be involved in a cooperation.
Definition 3.5 Define bus B as a finite set of cooperations B ⊂ Coops such that B /= ∅. For a particular bus B the respective set of cooperations is denoted coop(B). Countable set of all buses is denoted Buses. Members of Buses are typically denoted B, B1, B2,.. .
df
Input of the bus B is denoted In(B) and defined as the set In(B) =
 {W   ⟨W /R ⟩ ∈ B}. Similarly, output of the bus B is denoted Out(B) and
df	

Definition 3.6 Define the link relation L as the relation L ⊂ P × Buses satisfying for each B ∈ Buses all of the following conditions:
∀i, j ∈ N , p1 i , p2 j ∈ P , ⟨p1 i , B⟩∈ L. ⟨p2 j , B⟩∈ L ⇒ p1 /= p2 ∨ i /= j
∀p ∈ P . ⟨p, B⟩∈ L ⇒ ∃c ∈ B. p ∈ c
∀w ∈ W .w ∈ In(B) ⇒ ⟨w, B⟩∈ L
∀r ∈ R .r ∈ Out(B) ⇒ ⟨r, B⟩∈ L

df
Denote the set of all links of the bus B as links(B, L) and define links(B, L) =
{l  ∃p ∈ P .l = ⟨p, B⟩∈ L}.

The condition (2) in the definition above ensures that at most one link can be defined for a particular component interface port. The set of conditions (3) guarantees consistency of an embedding of a particular bus into a particular link relation. More precisely, all the ports linked to a particular bus must be reflected by some cooperation and for each port of any cooperation of a particular bus there must exist a link connecting the bus with the respective port.
Remark 3.7 For a particular link l ∈ L of some link relation L we denote its port
df
as port(l) = p, where l ≡ ⟨p, B⟩.
Definition 3.8 Define the set of structural terms, denoted Tst, as the least set satisfying:
A ∈ Tst is a leaf
df
N ∈ Tst, if N is a network defined as a tuple N = ⟨C¯, B¯, L⟩ where

C¯
= ⟨C1,... , Cn⟩ for some n > 0 is a tuple of component terms, for each

i ∈ {1, ..., n}, Ci = ⟨Si, Ii, Gi⟩ is a component satisfying:
Ii ⊂P finite set of ports is an interface, denoted I(Ci)
Si ∈ Tst
Gi is a gate which maps the component body Si to the interface Ii
B¯ = ⟨B1,... , Bm⟩ for some m ≥ 0 is a tuple of buses

L a link relation satisfying

L ⊆	 
i∈{1,...,n}


Ii i × {Bi  i ∈ {1, ..., m}}


Additionally, we say that a port p is a free port in a network N if it has no link attached.
We do not define the notion of gate here, as we focus only on inner-level (hor- izontal) aspects of the architecture. However, the gate is an important element of VCN concerning the inter-level (vertical) aspects [12]. For the purpose of this paper, we treat a gate as an injective mapping gateG which maps a port of a component body to a port of the respective interface.

Behavioral Model
Leaves
Each leaf is characterized by the set of events which can occur during its compu- tation. The behavioral model of a leaf is determined by the traditional transition system S = ⟨S,T, s0⟩, s0 ∈ S where the transition relation has the form T = S×P×S. Behavioral model of the leaf S, denoted Φ(S), is determined by the initial state s0, Φ(S) = s0. The τ -event represents a silent event (unobservable by the environ- ment).

Buses
A particular behavioral model of a bus represents a coordination mechanism. An example of bus behavior is depicted in Figure 2. The model reflects the coordination
touch/−
touch/−

Fig. 2. Behavioral model of a COORD bus (a cooperation machine)

in the network from Figure 1, in particular, it deals with components T emp sensor, Humi sensor, which represent weather conditions sensors, the Display component representing the LCD panel reporting the current theater information, and the Switch component which initiates entire system computation. The coordination model of these components is determined by the bus COORD. The meaning of this bus is coordination behavior which combines atomic broadcast, synchronous channel, inhibitor, and a one-place buffer. The overall principle of the coordination model determined by the bus COORD in this particular example can be summa- rized in the following phases:
In the initial phase, pushing of the touch trigger causes broadcasting of initi- ating signal through the ini1, ini2, and reset ports to the corresponding com- ponents. This broadcasting is performed atomically in an indivisible instant of time to ensure immediate and uninterruptable reaction of the system to the initiating signal.
After initiation, the coordination model is waiting for the information to be signaled on the producers (T emp sensor and Humi sensor) output ports. In this phase, it is also capable of receiving the touch signal, to preserve blocking of the initiation switch.

When the temp and humi information appears on the respective ports, the coordination model acts like both a synchronous channel (relaying the temp information to the get1 port) and a one-place buffer (storing the humi infor- mation to the internal memory — the state (3)).
After filling of the buffer, the information stored in the buffer is transmitted to the get2 port. It ensures that the get1 and get2 ports are filled with the appropriate information in a sequence of a given order (i.e., the information of the current weather conditions can appear always in the predefined order on the display panel).
The coordination model returns to the initial phase (i).
The coordination behavior described above can be formally captured as a transi- tion system labeled with cooperations. We call such a variant of transition system as cooperation machine. A cooperation machine is declared formally by the following definition:
Definition 3.9 Assume B is a bus. Cooperation machine of B, denoted cm(B), is
df
a tuple cm(B) = ⟨Q, T, q0⟩ where
Q is a finite set of states,
q0 ∈ Q is an initial state,
T ⊆ Q × coop(B) × Q is a finite transition relation.
Remark 3.10 For a given bus B, the set of all states of the cooperation machine cm(B) is denoted Q(B). Further, the initial state of the cooperation machine cm(B) is denoted ΦB(B). The fact that ⟨q, ⟨W/R⟩, q'⟩ ∈ T for some q, q' ∈ Q(B) and ⟨W/R⟩∈ B is denoted q →W/R q'. Additionally, the set of all transitions in which

can be evolved from a state q ∈
Q(B).q →W/R q'}.
df
Q(B) is denoted en(q), en(q) = {⟨W/R⟩∈ B  ∃q ∈


Components and Networks
Definition 3.11 For each component C = ⟨S, I, G⟩ and each network or leaf con- figuration S define the component conﬁguration ⟨S,I, G⟩. Behavioral model of a component C is denoted ΦC(C) and determined by the initial state of S. Formally,
df
ΦC(⟨S, I, G⟩) = ⟨Φ(S),I, G⟩.
Definition 3.12 Define the set of network conﬁgurations as the set
{⟨⟨c1, .., cn⟩, ⟨q1, .., qm⟩⟩   ∀n, m ∈ N , c1, .., cn . . . component configurations,
q1 ∈ Q(B1), .., qm ∈ Q(Bm) ... bus states }
Behavioral model of the network N = ⟨⟨C1, .., Cn⟩, ⟨B1, .., Bm⟩, L⟩ is denoted
df
Φ(N ) and defined Φ(N ) = ⟨⟨ΦC (C1), .., ΦC (Cn)⟩, ⟨ΦB(B1), .., ΦB(Bm)⟩⟩.
Let N = ⟨⟨c1, .., cn⟩, ⟨q1, ..., qm⟩⟩ a network configuration. By the notation N[ci := c'] we denote a network configuration which differs from N only in the ith component configuration, provided that the component configuration ci is replaced with c'i.

Similarly, by the notation N[qj := q'] we denote a network configuration which differs from N only in the jth bus state, provided that the bus state qj is replaced with q'.
For some θ ⊆ {1, ..., n} denote N[ i∈θ ci := c'i] the network configuration which differs from N in all component positions included in θ, provided that each compo- nent configuration ci for some i ∈ θ is replaced with the configuration c'i. Moreover, the network configuration which differs from N in all component positions included in θ and additionally in the jth state of the bus Bj which has moved to state q' is denoted N[ i∈θ ci := c'i, qj := q'].
For an arbitrary configuration t of any kind denote en(t) the set of all events
df	'	e	'
which can be evolved from t, en(t) = {e  ∃t .t → t } where ’→’ represents the
relevant transition relation. Note that also the internal τ -event can be included in
en(t).
Now we present structural operational semantics rules which derive the behav- ioral model of components and networks from behavioral models of elementary entities (buses and leaves). The first rule defines the operational semantics of the bottom most components. Let C = ⟨S, I, G⟩ a component, and S a leaf. The oper- ational semantics of C is defined by the transition relation ’→C ’ over the relevant component configurations which is given by the inference rule:
s →e s s'

(1)
⟨s,I, G⟩
gateG
−→
(e)
C
⟨s',I, G⟩
e ∈ en(s)

Let C = ⟨N, I, G⟩ a component, and N = ⟨⟨C1, C2, ..., Cn⟩, ⟨B1, ..., Bm⟩, L⟩ a network. The operational semantics of C is defined by the transition relation ’→C ’ over the relevant component configurations which is given by the following rule:

→N N'
⎡ i ∈ {1, ..., n} ⎤

(2)
N,I,G 
gateG(e i )
N',I,G	⎣	⎦

Operational model of the network N is determined by the transition relation ’→N ’ over network configurations. The following rule captures the situation when a component performs an action occurring on a free port.
c	e	'	⎡ N = ⟨⟨c1, .., ci, .., cn⟩, q¯⟩ ⎤
i →C c
⎢	⎥

(3)
 i
→N  [ci
:= c']	⎢⎣
e ∈ en(ci)
e i is a free port

Finally, we present the rule responsible for network coordination. At each net- work configuration a maximal cooperation is chosen to be performed from all the enabled cooperations. Before we state the synchronization rule itself, we define the notion of maximal enabled cooperation which realizes such a choice.

Definition 3.13 Let N = ⟨⟨c1, ..., cn⟩, ⟨q1, ..., qm⟩⟩ a network configuration. Further let ⟨W/R⟩∈ Coops a cooperation satisfying ⟨W/R⟩∈ en(qj) for some j ∈ {1, ..., m}. We say that ⟨W/R⟩ is enabled in conﬁguration N and write enabled(⟨W/R⟩, N) if and

only if there exists a set of ports P ⊂ P  satisfying the following conditions:
If e i ∈ P for some i ∈ {1, ..., n} then e i ∈ en(ci).
e ∈ P ⇔ e ∈ W or e ∈ R.
We say that ⟨W/R⟩ is maximal enabled cooperation in qj of N and write maxenabled(⟨W/R⟩, N, qj ) if and only if enabled(⟨W/R⟩, N) and ∀⟨W '/R'⟩ ∈ en(qj). (W ' ⊆ W ∧ R' ⊆ R) ∨ (W ' ∩ W = ∅∧ R' ∩ R = ∅).
The following rule is responsible for the network coordination:
⎡ N = ⟨⟨c1, .., cn⟩, ⟨q1, .., qj, .., qm⟩⟩ ⎤

W/R
q	q
∀e i ∈M 
. c →e
]c'	⎢	⎥


  j	Bj  j	Bj	i	C	i 
⎢
maxenabled(⟨W/R⟩, N, qj)
⎥

N →τ	N[	c := c' ,q := q' ]	⎢
df
M	∪ R

N	i∈θ i
i  j	j	⎣
Bj = W
df



Network Interoperability Correctness
Our formal solution for checking of interoperability correctness of VCN behav- ioral model revisits and extends the approach previously presented and proved by Bernardo et.al. in [1]. Inspired by that work, we establish the solution for checking of arbitrary interoperability-critical property which is preserved by weak bisimula- tion equivalence of VCN terms. As weak bisimulation equivalence preserves validity of all μ-calculus formulae with weak versions of diamond and box operators, the in- teroperability checking method includes an exhaustive set of interesting properties including deadlock freedom. The principle of interoperability checking relies on the idea of searching for a situation in a particular network hierarchy in which validity of a property being checked is violated by interaction of some components and buses which otherwise satisfy the considered property (if taken as stand-alone entities). With respect to the inductive definition of VCN diagrams the interoperability check traverses the hierarchy from leaves up to higher network levels.
Note that the approach of Bernardo et.al. deals with architectures composed of uniform components connected by links which can be of one-to-many character. Anyway, those links are static (stateless) connectors. There is no explicit notion of a connector like in Wright or in our approach. However, connectors can be there still modeled explicitly as components which are logically treated differently than common components. What is not possible there is modeling of connector dynamism concerning atomic many-to-many cooperations, as our approach allows by the behavioral model of buses. This is the reason why the results of [1] cannot be directly applied for developing the interoperability checking framework for the behavioral model of VCN. We follow the way of utilizing and extending these results to fit the character of behavioral model of buses.
Remark 4.1 For a component Ci and a bus Bj of some network ⟨C¯, B¯, L⟩ ∈ Tst
denote Llinks(Ci, Bj) the set of all links between Ci and Bj:

df
Llinks(Ci, Bj) = {l ∈ links(Bj, L)  ∃p ∈ Ii. port(l)= p i }

Definition 4.2 Let N = ⟨⟨C1, ..., Cn⟩, ⟨B1, ..., Bm⟩, L⟩ a network. Define the de-
df
pendency graph of N , denoted G(N ), as a bipartite graph G(N ) = ⟨{C1, ..., Cn}∪ 
{B1, ..., Bm}, E⟩ where E is defined in the following way:

df
E = {⟨Ci, Bj⟩ Llinks(Ci, Bj) /= ∅}
In the following part, we will assume ϕ a formula of modal μ-calculus expressing some interoperability safety property. An example of such a property can be dead- lock freedom expressed by the formula νZ.⟨⟨−⟩⟩tt ∧ [[−]]Z. A significant feature of this formula is that it does not refer to any particular event and hence its validity is independent of the behavioral model alphabet.
In the previous section cooperation machines have been introduced as specific transition systems with cooperations appearing in transition labels. Hence we at first utilize the traditional (weak) bisimulation equivalence in order to establish the notion of so-called cooperation-labeled weak bisimulation.
Remark 4.3 Let γ ∈ Coops∗ a sequence of cooperations. Denote γˆ the following sequences of cooperations:
df
γˆ = ϵ, if γ = ⟨∅/∅⟩;

df	'
∗	'	∗	'

γˆ = γˆ , if γ = ⟨∅/∅⟩
γ
Denote
· γ · ⟨∅/∅⟩ where γ
/= ϵ.


γ  df

∅/∅ ∗  γ


∅/∅ ∗

⇒B the sequence of succeeding transitions ⇒B= (→B) →B (→B) .
Definition 4.4 Let B1 and B2 buses. Further let q ∈ Q(B1),b ∈ Q(B2) states of the respective cooperation machines. We say q and b are (weakly) bisimilar and write q ≈cl b if and only if for each γ ∈ B1 ∪ B2 both of the following holds:

If q	'	'
γˆ	'
'	cl  '

→B1 q  then ∃b
∈ Q(B2).b ⇒B2 b
and q ≈ b .

If b	'	'
γˆ	'
'	cl  '

→B2 b then ∃q
∈ Q(B1).q ⇒B1 q
and b ≈ q .

The fundamental idea of interoperability checking is based on the notion of so-called compatibility which is based on pairwise comparison of behavior of com- ponents and buses in the network. More particularly, the behavior observed on links between a component and a bus is considered. In order to enable such comparison we define a projection of bus behavior to a particular subset of links.
Definition 4.5 Let N = ⟨⟨C1, ..., Cn⟩, ⟨B1, ..., Bm⟩, L⟩ a network, and let Bj for some j ∈ {1, ..., m} a bus, cm(Bj)= ⟨Q, T, q0⟩ a cooperation machine, and L' ⊆ L a link relation. Define L'-projection of Bj, denoted π(Bj, L'), as the bus B' with
'  df	'
the semantics determined by the cooperation machine cm(B ) = ⟨Q, T , q0⟩ where
T ' is defined in the following way:


⟨q, ⟨W '/R'⟩, q'⟩∈ T ' df
q, ⟨W/R⟩, q'⟩∈ T



' df
'	' df	'

where W
= W ∩ ports(Bj,L ) and R
= R ∩ ports(Bj,L ).

The bus B' is defined as the set of all cooperations appearing in labels of T '.

Note that the cooperation-labeled transition relation of cooperation machines can be comprehended formally as an extension of the classical transition relation which is used for determining the operational semantics of VCN terms. This classi- cal transition relation can be lifted to the format of cooperation-labeled transition relation. More precisely, we can consider behavioral model of a VCN term in the form of so-called saturated cooperation machine (defined below). This way we achieve uniform framework for behavioral analysis of VCN terms. In such a setting, we represent the internal τ -event as an empty cooperation ⟨∅/∅⟩.
Definition 4.6 The cooperation machine cm(B) is called saturated if each transi- tion of cm(B) has the form ⟨q, b, q'⟩ satisfying just one of the following possibilities:
b ≡ ⟨{w}/∅⟩ for some w ∈ W ;
b ≡ ⟨∅/{r}⟩ for some r ∈ R ;
b ≡ ⟨∅/∅⟩.
To analyze interoperability of buses and particular components in a network we need to look into the network internal behavior. More specifically, cooperations cannot be hidden in such analysis. In particular, we need to observe cooperations occurring on the network link relation or on its specific subset. To capture this kind of observation of network behavior with respect to some link relation L, we define L-observable model of the network. This operational model is based on the cooperation-labeled transition relation. In the following definition the notion of L-observable model is given and consequently employed to formalize the notion of compatibility.
Definition 4.7 Let N = ⟨⟨C1, ..., Cn⟩, ⟨B1, ..., Bm⟩, L⟩ ∈ Tst a network. Define L-observable model of network N by a transition relation →L defined over network configurations by the following rules, which are modification of rules (3, 4):
⎡ N = ⟨⟨c1, .., ci, .., cn⟩, q¯⟩ ⎤
'	⎢	⎥

(3') 	ci →C c	 ⎢
e i is a free port
⎥

N  γ  N[c
:= c']
⎢ df ⎧⎨ ⟨e i/∅⟩, if e ∈ W, ⎥

→L	i
⎣ γ = ⎩	⎦
⟨∅/e i ⟩, if e ∈ R.

⎡ N = ⟨⟨c1, .., cn⟩, ⟨q1, .., qj, .., qm⟩⟩ ⎤

q →W/R q'
∀e i ∈M 
. c →e c'	⎢
⟨	⟩, N,q )	⎥

(4 )
N W/R N[ 
c := c' ,q := q' ]	⎢

df
M	∪ R

→L	i∈θ i
i  j	j	⎣
Bj = W
df
 i

θ = {i e ∈ MBj }
The L-observation of network N , denoted ΦL(N ), is determined as in the case of the common behavioral model by the initial network configuration Φ(N ), but the transition relation →L is taken instead of →N .
Definition 4.8 Let N = ⟨⟨C1, ..., Cn⟩, ⟨B1, ..., Bm⟩, L⟩ a network, and let Ci =
⟨S, I, G⟩ and Bj (for i ∈ {1, ..., n},j ∈ {1, ..., m}) adjacent nodes of G(N ). Further

let L' ⊆
' df {l ∈ links(B , L) ∃p ∈ I. p i = port(l)}.

L defined as a link relation L =	j

We say Ci is compatible in N with Bj, and write Ci 0N Bj, if and only if ΦB(B') ≈cl ΦL' (⟨⟨S, I', G'⟩, ⟨π(Bj, L')⟩, L'⟩) where

' df
df	'	 i

I = I ∩ P where P = {p ∈ I	∃l ∈ L ,i ∈ N .p  = port(l)},
G' is defined by G restricted to ports of I'.
An important subpart of an acyclic network topology is a so-called star topology. Intuitively, the star topology is a group of all components connected to the same bus in a particular acyclic network. Significance of this structure relies on the fact that for checking of interoperability it suffices to check compatibility of the central bus with every component included in the particular star topology. This result is included in the general theorem 4.11. In order to precise the notion of the star topology, we introduce formally the notion of subnetwork at first.
Definition 4.9 Let N = ⟨⟨C1, ..., Cn⟩, ⟨B1, ..., Bm⟩, L⟩ ∈ Tst a network.	For some n' ≤ n and m' ≤ m define the subnetwork N ' of N as a network N ' =
⟨⟨C' , ..., C' ' ⟩, ⟨B' , ..., B' ' ⟩, L'⟩∈ Tst satisfying:
1	n	1	m
{C' , ...., C' ' }⊆ {C1, ..., Cn} and {B' , ...., B' ' }⊆ {B1, ..., Bm}

1	n
' df
1	m
'	'	'	'

L = {l ∈ L  l ∈ Llinks(C, B) ∧ C ∈ {C1, ...., Cn' }∧ B ∈ {B1,	, Bm' }}
Each B ∈ {B' , ...., B' ' } is defined as π(Bj, L') for some j ∈ {1, ..., m}.
1	m
Further define for some j ∈ {1, ..., m} the star topology of Bj in N as a

'	'  df	'
'	'	'

subnetwork N  of N having the form N	= ⟨⟨C1, ..., Cn' ⟩, ⟨B ⟩,L ⟩ where each
C' ∈ {C' , ..., C' ' } satisfies Llinks(C', Bj) /= ∅.
i	1	n	i
In checking of network interoperability, existence of cyclic component relation- ships requires a special care. An example of interoperability correctness violation in a cyclic topology is depicted in Figure 3. If we take the star topology

⟨⟨C' ,C' ⟩, ⟨π(B , L)⟩, L⟩
df {⟨in 1 ,B ⟩, ⟨out 1 ,B ⟩, ⟨in 2 ,B ⟩, ⟨out 2 ,B ⟩}

1	2	1
, L =	1
1	1	1

where the components C' ,C' are C1, C2 projected to links in L then such a subnet-
1	2
work is deadlock free. Similarly, the same holds for the star topology of the bus B2.
However, if we consider the entire cyclic topology, a deadlock situation can arise, as it is shown by darkened states of the transition systems in the figure.
To capture the above stated problem, we present the main result of this paper declaring a set of conditions which are both necessary and sufficient to ensure an arbitrary network topology to satisfy some property ϕ. In the following theorem, by a maximal cycle we mean each subgraph of a network dependency graph which is not strictly contained in some larger cycle of the graph. Moreover, for each maximal cycle Ω of a network dependency graph we consider the respective subnetwork, so- called Ω-subnetwork, containing all the buses and components of the cycle and the link relation restricted to them. Additionally, we define the border of a cycle to denote the set of those components and buses each of which is identified by one of the following statements:
A component of the cycle which has at least one free port.





C1:



in?



ackin?
B1,B2:

in/out




out/in



out!	ackout!


Fig. 3. Violation of network interoperability correctness by deadlock
A component of the cycle linked to a bus outside the cycle.
A bus in the cycle which is linked to a component outside the cycle.
Definition 4.10 Let N = ⟨⟨C1, ..., Cn⟩, ⟨B1, ..., Bm⟩, L⟩ a network and Ω some (maximal) cycle of G(N ). Define border of Ω, denoted β(Ω), as the set
df
β(Ω) = {C ∈ Ω  ∃p ∈ ports(I(C)), ∀B ∈ Ω.p ∈/ ports(Llinks(B, C))}∪
{B ∈ Ω  ∃γ ∈ B, p ∈ γ, ∀C ∈ Ω.p ∈/ ports(Llinks(B, C))}
Theorem 4.11 Let N = ⟨⟨C1, ..., Cn⟩, ⟨B1, ..., Bm⟩, L⟩ a network with G(N ) which is a connected graph of arbitrary shape, and let ϕ a property. N satisﬁes ϕ if and only if the following conditions hold:
Each bus Bj ∈ {B1, ..., Bm} satisﬁes ϕ.
Each component Ci ∈ {C1, ..., Cn} satisﬁes ϕ.
Each bus B which is not included in any cycle of G(N ) satisﬁes C 0 B for each C such that Llinks(C, B) /= ∅.
Each bus B ∈ β(Ω) of each maximal cycle Ω of G(N ) satisﬁes C 0 B for each
C such that Llinks(C, B) /= ∅ and C is not included in Ω.
For each maximal cycle Ω of G(N ) the Ω-subnetwork of N satisﬁes ϕ.
To realize interoperability checking for arbitrary network topology and that way constructively prove the above stated theorem, we apply the idea of step-by-step reduction of the entire potentially cyclic topology to a smaller acyclic topology which has the behavioral model observationally equivalent to the original topology. The intuition about such an observational behavior preserving reduction of cyclic topologies to acyclic topologies is the following. Each cycle in the entire network is replaced with a star topology which has the behavior model equivalent to the original cyclic topology. This star topology is defined in such a way that all the relevant links

leading from components and buses of the cycle to the buses and components outside the cycle are remapped to equivalent links leading from components and buses of the star topology. The important property that must be satisfied by such a replacement is mutual compatibility of those components and buses. Moreover, the star topology must itself satisfy compatibility of its components with the bus forming its center. Then by replacing all the cyclic subnetworks with such compatible star topologies the acyclicity of the entire network is achieved and interoperability checking then relies on checking mutual compatibility of buses and components. The formal proof of the theorem is based on the intuition described in this paragraph and is given precisely in the full version of this paper [11].
Conclusion and Future Work
In this paper we have presented simplified version of the language VCN for hi- erarchical specification of component-based concurrent systems. The key concept of the language are buses which represent coordination models used in system ar- chitectures. We have utilized the process algebraic approach of [5] and proved its extension which has been introduced due to the specific features of VCN which are not incorporated directly in traditional process algebraic approaches for architec- tural description.
We are currently implementing a graphical tool [10] which allows VCN diagrams to be simply created and modified. In our future work, we would like to discuss endogenous and exogenous extensions of the VCN models in the style of [1]. We also aim at extending architectural interoperability checking to VCN bus classes which allow generalized definitions of buses [12].

References
Alessandro Aldini and Marco Bernardo. On the usability of process algebra: An architectural view.
Theor. Comput. Sci., 335(2-3):281–329, 2005.
R. Allen and D. Garlan. A formal basis for architectural connection. ACM Trans. Softw. Eng. Methodol., 6(3):213–249, 1997.
F. Arbab. What do you mean, coordination? Bulletin of the Dutch Association for Theoretical Computer Science (NVTI), 1998.
Farhad Arbab. Reo: a channel-based coordination model for component composition. Mathematical. Structures in Comp. Sci., 14(3):329–366, 2004.
Marco Bernardo, Paolo Ciancarini, and Lorenzo Donatiello. Architecting families of software systems with process algebras. ACM Trans. Softw. Eng. Methodol., 11(4):386–426, 2002.
R. Cleaveland, X. Du, and S. A. Smolka. GCCS: A Graphical Coordination Language for System Specification. In Proceedings of COORD’00. LNCS, Springer Verlag, 2000.
Paul C. Clements. A survey of architecture description languages. In IWSSD ’96: Proceedings of the 8th International Workshop on Software Specification and Design, page 16, Washington, DC, USA, 1996. IEEE Computer Society.
D. Harel. Statecharts: A Visual Formalism for Complex Systems. Technical report, The Weizmann Institute, 1987.
A. Ray and R. Cleaveland. Architectural Interaction Diagrams: AIDs for System Modeling. In Proc. of ICSE 2003. IEEE, 2003.

Z. Rehak.	VCNE project home page.	ParaDiSe Laboratory, Masaryk University Brno, 2006.
http://www.fi.muni.cz/∼xrehak5/vcne/.
D. Sˇafra´nek. Architectural Interoperability Checking in Visual Coordination Networks. Technical Report FIMU-RS-2006, Faculty of Informatics, Masaryk University Brno, 2006.
D. Sˇafra´nek and J. Sˇimˇsa. VCD: A Visual Formalism for Specification of Heterogeneous Software Architectures. In Theory and Practice of Computer Science: 31st Conference on Current Trends in Theory and Practice of Computer Science, volume 3381 of LNCS. Springer, 2005.
