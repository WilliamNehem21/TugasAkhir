

Electronic Notes in Theoretical Computer Science 229 (2009) 131–144
www.elsevier.com/locate/entcs

Making the Unobservable, Unobservable

Julian Rathke
ecs, University of Southampton

Pawel- Sobocin´ski1
ecs, University of Southampton

Abstract
Behavioural equivalences of various calculi for modelling distributed systems differ significantly because the properties which can be observed through interaction depend heavily upon their mode of communication. A typical approach to describing the semantics of communicating processes is to provide a labelled transition system (lts) which captures the interaction potential of the individual processes within a larger system. In many cases, a natural rendering of this lts leads to too fine a semantics as unobservability of certain communications is not accounted for.
We propose that a standard approach to augmenting ltss allows morally unobservable communications to actually be modelled as unobservables in the semantics. This approach derives from a rule initially given by Honda and Tokoro to account for unobservability of reception in the asynchronous π-calculus. We examine the implications of adding such rules to lts with respect to the proving behavioural equivalences for various synchronisation mechanisms.
Keywords: process algebra, structural operational semantics, observability, simulation, bisimulation


Introduction
Semantic descriptions of processes in the process algebra/calculus tradition have come to be dominated by the use of labelled transition systems (ltss) to describe the nature of the interaction contributed by each participant in a communication. This approach was inspired by early work of Plotkin [11] on structural operational semantics and Milner’s definition of lts semantics for ccs [8].
The use of labels has an interesting artefact. Labelled transition systems now not only capture reduction but also allow programs to be compared for equivalence without the need for examining their behaviour within all enclosing contexts. The dual purpose nature of these transition systems does have an unfortunate side- effect in that the labelled transitions, which are useful for describing structurally

1 Research partially supported by epsrc grant EP/D066565/1.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.043

defined reduction relations, do not always coincide with observability properties of language with respect to program equivalence. This problem is particularly acute when the underlying communication mechanism between processes is anything less than fully synchronous. In a nutshell, the “natural looking” structural ltss for a given language may yield too fine an equivalence relation if the labels are used for comparing programs.
A well-known example of this lies in the unobservability of reception in languages featuring asynchronous communication. This issue is studied thoroughly in [5, 1] in the setting of the asynchronous π-calculus in which it is demonstrated that (weak) bisimilarity on the structural lts for the π-calculus does not correctly capture a notion of (weak) observable equivalence in this language. There are two different, but related, approaches to resolving this problem: [1] proposes a variant definition of bisimilarity while [5] proposes an additional, non-structural labelled transition rule to model the unobservability of reception. For technical reasons concerning uniformity of definition and difficulties in establishing transitivity of the variant bisimilarity, we prefer the latter approach by Honda and Tokoro [5]. Their innova- tion was to blur the observability of reception actions in π-calculus by augmenting the standard lts with (essentially) the following rule:



P −a−?→b
P	a!b




This rule allows a process which genuinely performs a receive action P
a?b
−−→

to be identified with a process that may not be able to perform any actions, let alone a receive action. In fact, augmenting the lts with the above rule makes the contextually unobservable receive actions in the asynchronous world actually become unobservable in their lts model. We will refer to rules such as the above as Honda Tokoro (HT ) style rules.
In this paper we pursue the idea of Honda and Tokoro by generalising their approach of using additional lts rules to guarantee the correct unobservability properties in a structurally defined lts. We do this by identifying how we can routinely add HT rules to an lts without compromising the soundness and com- pleteness of its associated (bi)similarity with respect to a simple notion of contextual equivalence. We demonstrate this approach in three different scenarios: fully asyn- chronous, output asynchronous and fully synchronous communication in ccs-like calculi. Furthermore, we discuss how to specialise the resulting ltss by only adding the necessary additional unobservability rules – in some calculi some actions are inherently observable and do not require a HT rule. This analysis is useful because it results in more manageable ltss. Indeed, it is important to emphasise that this paper does not address the issue of characterising when particular actions are or are not contextually unobservable, as studied in [9]. The focus here is on the general applicability and correctness of the unobservability rules.

Structural rules, LTSs and (bi)simulations
We need to recall the standard notion of a labelled transition system. In all of our examples the set of states coincides with the set of processes of the calculus at hand.

Definition 2.1 Suppose that A is a set of observations and S is a set of states. An (A, S)-labelled transition system (lts) is a ternary relation T ⊆ S × A × S. We
will write s −→α s' for (s, α, s') ∈T .
Traditionally, ltss defined by a set of sos rules have been used to:
define the reduction relation compositionally by considering the structure of terms;
define the possible “interactions” and reason about the resulting (labelled) pre- orders/ equivalences;
characterise observational preorders/equivalences by using the aforementioned labelled preorders/equivalences.
There is a natural tension between the first and the third point. The first may require us to observe the intensional structure of the terms in order to characterise the possible reductions. The third requires us to characterise the structure that can be observed. Examples of and techniques for relaxing this tension are the remit of this paper.
Our ltss will be defined using simple sos rules. Given an lts T and a rule ψ, let ψ(T ) be the lts obtained by adding the extra transitions which can be derived using (possibly several applications of) ψ from the existing transitions of T . This is easily defined as a least fixed point. Seen as an endofunction on the class of ltss, ψ is idempotent. This notation can be extended to sets of rules Ψ = {ψi}i∈I in the obvious way; proof-theoretically, Ψ(T ) denotes the set of transitions that result from the derivations that use the rules in Ψ, assuming the transitions of T as axioms. When we speak about the lts defined by a set of rules Ψ, we mean the lts Ψ(∅) where ∅ is the empty lts.
Definition 2.2 Given two (A, S)-ltss T1 and T2, a simulation from T1 to T2 is a
binary relation R⊆ S × S such that if P R Q and P −→α P ' in T then ∃Q' such that
1
Q −→α Q' in T  and P ' R Q'. A simulation R is a bisimulation whenever R−1 is also
2
a simulation.
Given an lts T ,  T is similarity, the largest simulation, while ∼T is bisimilarity, the largest bisimulation.

Full asynchrony
Consider the following simple language Lf of finite processes generated by:
P ::= 0 | a! | a? | P	Q | τ

We can think of a typical term as a textual representation of a “soup” of processes [2] which interact with each other. We thus ask that parallel composition behave appropriately: a process is an equivalence class of terms quotiented by the smallest congruence in which  is associative, commutative and has 0 as identity.
The execution semantics (i.e. what a program does) is captured by the smallest (unlabelled) transition system → that contains τ → 0 as well as a!  a? → 0 (for any a) and is closed under parallel composition. We will refer to the edges in the above transition system as interactions or reductions.
Assume that an interaction has an observable effect, for concreteness let us say that each interaction generates a certain amount of heat which can be detected by the observer’s sophisticated sensors. The external observer cannot see the internals of a soup (the identity and number of its components) but can experiment with it only by:
introducing new ingredients into the soup;
measuring the change in heat, i.e. observing interactions.
Our most controversial assumption is that time can be slowed down to such an extent that no two reductions can ever happen truly concurrently, that is, the observer can observe the reductions one at a time. This is normally referred to as interleaving.
For example, the observer can distinguish between 0 and a!; the experiment runs as follows: the observer introduces a? into the both the soups and observes that while the first soup stays at constant temperature, the second soup gets a little bit hotter.
The above ingredients induce a canonical preorder and equivalence on the set of processes: the preorder being the largest (reduction) simulation which is a pre- congruence (wrt to ) and the equivalence being the largest reduction bisimulation which is a congruence. For us, these two relations capture the greatest reasonable power of an external observer.
Definition 3.1 Reduction precongruence is the largest relation  which:
is a simulation with respect to reduction, i.e. if P  Q and P → P ' then there exists Q' such that Q → Q' and P '  Q';
is stable wrt , i.e. if P  Q then for any R we have P  R  Q  R.
Definition 3.2 Reduction congruence is the largest relation  which:
(i) satisfies conditions (i) and (ii) of Definition 3.1;
(ii) is symmetric.
In the following we will attempt to reason about the contextually defined re- duction (pre)congruence by characterising the possible “experiments” (cf. the dis- cussion before Definition 3.1) as labelled transitions; the procedure (initial state, experiment, final state) will be a transition in an lts. Roughly, this means that we are in effect replacing “contexts” of Definitions 3.1 and 3.2 with “labels” in a lts. The goal is to use labelled preorders and equivalences, such as bisimulation, as proof methods for reasoning about reduction (pre)congruence.

The first kind of experiment is the simplest, the observer does not need to do anything and can observe a rise in temperature due to the presence of a τ within the term. Let us call this experiment τ . We can characterise inductively some of the processes for which this experiment is successful:



τ	(Tau)
τ
P −→ P '
τ

(Tau )

τ −→ 0

P Q −→ P ' Q

Another experiment is the following: the observer introduces an output on a (a!) and observes that there is a rise in temperature. Let us name (slightly counterintuitively) this kind of experiment a?. The reason for this label is that this is the capability (input) that has been observed. Also this kind of experiment can be characterised inductively:

a?	(In)
a?
a?
P −→ P '
a?

(In )

−→ 0
P Q −→ P ' Q

Dually, the observer can introduce an input to observe an output.



a!	(Out)
a!
a!
P −→ P '
a!

(Out )

−→ 0
P Q −→ P ' Q

Finally, if the observer’s experiments lead her to conclude that there is an input on a in soup A and an output on a in soup B, then a heating should be observed in the combined soup without additional ingredients. Note that the label is the same as our first experiment: this is because, from the observer’s point of view, the same (empty) process is provided to P  Q for a change in heat to be observed.


a?
P −→ P '
τ
a!
Q −→ Q'

(Comm)



Let Φf def
P Q −→ P ' Q'


def
f

Φf (∅). The following lemma shows that our intuition of this labelled transition system as a “logbook” of certain experiments is correct: for each kind of label α there is a process χα which is added by the experimenter to observe a reduction.

Lemma 3.3 χ	d=ef a?, χ	d=ef a! and χτ d=ef 0. P −→α
P ' implies P  χα → P '.	 

For τ -labelled transitions, the other direction also holds.

Lemma 3.4 P −→τ
P ' iff P → P '.	 

Indeed, reasoning on Cf is sound wrt to observation:
Lemma 3.5 (Soundness of Cf )  C ⊆  and ∼C ⊆  .
Proof. It suffices to show that  is a reduction simulation and stable under parallel composition. It is a reduction simulation because it is a τ -simulation and τ s coincide with reductions (Lemma 3.4). To show that it is stable under , it suffices to show that {(P  R, Q  R) | P  Q} is a simulation. This is easily checked by cases, the

most interesting being P	R −→τ
P '	R' where, for some a, P −a→!
P ' and R −a→?
R'.

Then, by assumption, ∃Q'.Q −a→!
Q' ∧ P '  Q'. But then Q	R −→τ
Q'	R' which

is in the relation. The proof for the case of bisimulation and reduction congruence proceeds similarly.	 
However, the reverse inclusion (completeness) does not hold. The lts allows us to distinguish processes which are observationally not distinguishable. For example:
Lemma 3.6 Let P1 d=ef a?  a! and P2 d=ef τ. Then P1  P2 but P1/  P2.

Proof. Clearly P /   P  since P −a→!
a? which cannot be matched by P2.

We will show that R d=ef
{(P1  R, P2  R) | R a process} ∪ Δ (where Δ is the

identity relation) is closed under reduction and stable under parallel composition. Suppose that P1  R → Q. Then:
R → R' and Q = P1  R'. Then also P2  R → P2  R' and Q R (P2  R') by construction;
P1 → 0 and Q = R. But also τ → 0 so τ  R → R;
R = a!  R' and P1  R → a!  R' = R. But also τ  R → R.
R = a?  R' which is similar to the previous case.	 

We also have P2 P1 and, moreover, P1 P2; the two processes are reduction congruent. In fact, already a!  P2 and a?  P2, although, in each of these cases the other direction does not hold since P2 can reduce. Of course, neither a? / a! nor a! / a?.
We have shown that there is a mismatch between our logbook (the lts) and the actual power of experiments. This can be expressed succinctly by noting that the converse of Lemma 3.3 does not hold and, more than this, no characterisation of the labels by contexts is possible. This is implied by the following result.
Theorem 3.7 If, for an lts X , there exist processes χα such that
P −→α	P '	iff	P	χ	→ P '


then  ⊆  X and  ⊆ ∼X .
Proof. We will show that  is a (X )-simulation. Suppose that P  Q and P −→α

P '.

Then P  χα → P ' and since  is stable under		and closed under reduction we have that there exists Q' such that P '  Q' and Q	χα → Q'. But, by assumption, the
final part implies that Q −→α Q'. The same reasoning shows that  is a bisimulation. 

Corollary 3.8 For α ∈ {a?, a!}, there do not exist χα such that P −→α
χα → P '.
P ' iff P

Proof. If such a set existed then by Theorem 3.7 we would have  ⊆ C which we know is not true by the conclusion of Lemma 3.6.	 

What has gone wrong? A moment’s reflection about the processes of Lemma 3.6

confirms that, for instance, our tentative idea that P −a→!
P ' tests for the presence

of an output (and dually, an input) on a in P is unimplementable. Indeed, the experimenter which provides an a? process and observes an interaction can conclude that either P has an output on a or that a reduction was already possible in P . The following rules 2 take into account the possibility of the latter:


τ
P −→ P '
a?

(InHT)

τ
P −→ P '
a!

(OutHT)

P −→ P ' a!	P −→ P ' a?
The extra component in the results is just the process that the experimenter pro- vided. Since the reduction was already present in P , this process was not consumed.

Letting Ψf
def
= {(InHT) (OutHT)}, we will consider the lts HT f
def
= Ψf Cf . In other

words, HT f is the lts with derivations that can be split into two (possibly empty) parts - the first which features rules from Φf and the second with rules from Ψf . We shall sometimes refer to those transitions which are in HT but not in C as Honda-Tokoro transitions.
The following lemma shows the relationship between the a?- and a!-labelled transitions in the two ltss.
Lemma 3.9 If α ∈ {a!, a?}: P −→α	P ' ⇔ P −→α	P ' ∨ (P −→τ P '' ∧ P ' = P ''  χα). 
The τ -labelled transitions are unchanged. We use these observations to show that simulation (bisimulation) on HT remains sound for reduction precongruence (congruence).
Lemma 3.10 (Soundness of HT f )  HT ⊆  and ∼HT ⊆  .
Proof. It suffices to show that  is stable under . This is done by showing that
{(P	R, Q	R) | P   Q} is a simulation. One of the two symmetric interesting
!	a?
cases is again P	R −→τ  P '	R' for P −a→ P ' and R −→ R'. Note that R = R'	a?.

We have, by assumption, that ∃Q'.Q −a→!
Q' such that P '   Q'. Now, using the

conclusion of Lemma 3.9, either Q −a→!	Q', in which case also Q	R −→τ
Q'	R', or

Q −→τ Q'' such that Q' = Q''	a?. But then Q	R −→τ
Q''	R = Q''	a?	R' = Q'

R'.	 
The rules of Ψf are designed so that the ‘if’ direction of the following statement holds, provided that the ‘only if’ direction holds.
Lemma 3.11 Let χα be deﬁned as in Lemma 3.3. Then
P −→α	P '	iff	P  χ	→ P '
Proof. Lemma 3.4 takes care of τ . (⇒) is implied by Lemma 3.3 and the fact that if P → P ' then P  χα → P '  χα. For (⇐) if P  χα → P ' then either the χα is
consumed in which case P −→α	P ' or it is not, in which case P −→α	P '.	 

2 These rules are named after Honda and Tokoro’s rule for asynchronous π-calculus, although here they are modified for strong equivalences.

The above is enough to derive completeness.
Corollary 3.12 (Completeness of HT f )  ⊆ HT and ⊆ ∼HT
Proof. Consequence of the conclusions of Lemma 3.11 and Theorem 3.7.	 

Asynchrony
Here we will consider a language La where, an a? capability can guard another process.
P ::= 0 | a! | a?P | P  Q | τP 
The reduction relation is the smallest transition system that contains a!  a?P →
P as well as τP → P and is closed by parallel composition.
As before, we have the experiment for the τ prefix where nothing needs to be provided in order to observe a heating:


τ	(Tau)

τ
P −→ P '
τ


(Tau )

τP −→ P

P Q −→ P ' Q

Also, the observer can experiment with a process by providing an output:

a?
P −→ P '
a?	(In)		 (In )

a?P −→ P
a?
P Q −→ P ' Q

The experiment for outputs is more involved because our language now allows more powerful tests: the observer introduces an input on a followed by some other process R of the observer’s choosing (a?R) and observes a rise in temperature con- sistent with one interaction. We will denote 3 this kind of experiment a!↓ R. The inductive presentation is the following:




a!↓ R
a!

(Out)
a!↓ R
P −−−→ P '
a!↓ R


(Out )

−−−→ R
P Q −−−→ P ' Q

The final rule is needed to characterise those internal reductions which come from two interacting parallel components:


a?
P −→ P '
a!↓ 0
Q −−−→ Q'
τ


(Comm)

P Q −→ P ' Q'
Let Φa = {(Tau), (Tau  ), (In), (In  ), (Out), (Out ), (Comm)} and Ca = Φa(∅). The follow- ing is the counterpart of Lemma 3.3 for our current setting.

Lemma 4.1 Let χ

a!↓ R
= a?R, χa?
= a!, χτ = 0. Then P −→α
P ' implies P  χα →

P '.	 

3 The motivation for this notation is our work on deriving structural ltss from reduction rules [12, 13]. Roughly, the ‘↓’ in the label separates the information provided by the process (here an output capability) from the data provided by the environment (here R).

It is also easy to check that the conclusion of Lemma 3.4 holds. We easily ob- tain soundness; the proof of the following is essentially the same as the proof of Lemma 3.5.
Lemma 4.2 (Soundness of Ca)  C ⊆  and ~C ⊆  .	 
Analogously to the fully synchronous case, simulation on Ca is too strong: there exist processes which are distinguished by similarity but which are not distinguished by observational precongruence.
Lemma 4.3 Let P1 d=ef a?a! and P2 d=ef τ. Then P1  P2 but P1/  P2.


Proof. Again, it is easy to see that P /   P  as P —a→?
by P2.
a! which cannot be matched

On the other hand Y = {(P1  R, P2  R) | R a process}∪ Δ is closed under reduction and stable under parallel composition: Suppose that P1  R → Q. Then:
the reduction comes from R, so Q = P1  R', and P2  R → P2  R';
R = a!  R' and P1  R → a!  R' = R. But also τ  R → R.

To obtain completeness, we can again generate a new lts 77 a from Ca by applying rules:

τ
P —→ P '

a?
—→ P  a!

(InHT)
τ
P —→ P '

a! R
———→ P  a?R

(OutHT)

Corollary 4.4 (Completeness of 77 a)  ⊆  HT and  ⊆~HT .
Proof. The presence of the Honda-Tokoro rules allows us to establish the counter- part to Lemma 3.11 and completeness follows from Theorem 3.7.	 
The fact that we are applying both (InHT) and (OutHT) should come as a surprise. In fact, in the fully asynchronous case, it was intuitively clear that both the labels should be unobservable. Here, while the a? transition should be unobservable, our intuition tells us that a! should be observable. The crucial observation is that while (InHT) really does make the inputs unobservable, the (OutHT) does not make outputs unobservable, it only accounts for the fact that the experiment for a! can fail. In fact, in the fully asynchronous setting we had a!  HT τ and this does not hold here:

Example 1 a!/ HT τ.
a!↓ τ
Proof. a! ———→ τ . The τ process must match this with the Honda-Tokoro transi-
a!↓ τ
tion τ ———→ a?τ . But clearly τ / HT a?τ , since the first process can do a τ labelled
transition.	 
Indeed, 77 remains sound.
Lemma 4.5 (Soundness of 77 a)  HT ⊆  and ~HT ⊆  .

Proof. We need to show that  is stable under . This is done by showing that
Y = {(P  R, Q  R)|P  HT Q} is a simulation.

τ	'	'
a!↓ 0	'
a?	'

The interesting case is P	R —→ P	R
for P ———→C P
and R —→C R . Suppose

that Q does not have an output on a available and will be forced to match the a!↓ 0 transition with a Honda-Tokoro transition.
We know that, for some S and R'', R = R''	a?S and R' = R''	S. The

a!↓ S
key observation is that P ———→C P
S. Then Q will have to match this with

a Honda-Tokoro transition, hence ∃Q'
such that Q —→τ Q'
a!↓ S
and Q ———→HT Q
a?S

with P '	S   Q'	a?S (†). But then Q	R —→τ
Q'	R = Q'	a?S	R''. But

P '  R' = P '  S  R'', hence by (†), we remain in Y.
Similar reasoning goes through for the case of bisimilarity and reduction con- gruence.	 
In Section 6 we will show that, when reasoning about reduction congruence, the rule (OutHT) is not actually necessary.

Synchrony
We can recycle our results for the synchronous language Ls, where both inputs and outputs guard other processes:
P ::= 0 | a!P | a?P | P  Q | τP 
The reduction relation → is the smallest relation which, for any P , Q contains a!P  a?Q → P  Q as well as τP → P and is closed under parallel composition. In this case, our Cs lts is generated by:




a?↓ R
a?P

(In)
a?↓ R
P ———→ P '
a?↓ R


(In )


a!↓ R

(Out)
a!↓ R
P ———→ P '
a!↓ R


(Out )

———→ P R
P Q ———→ P ' Q
a!P ———→ P R
P Q ———→ P ' Q


a?↓ 0	'

a!↓ 0	'

P τ	'

P ———→ P
Q ———→ Q		
—→ P


τ
P Q —→

P ' Q'
(Comm)
τ
τP —→ P
(Tau)


P Q τ P ' Q
(Tau )

The set Ψs of Honda-Tokoro rules is the set containing the two rules:


τ
P —→ P '

a? R
———→ P  a!R


(InHT)

τ
P —→ P '

a! R
———→ P  a?R


(OutHT)

and we automatically obtain a sound and complete lts (for both reduction precon- gruence and reduction congruence) 77 s = Ψs(Cs).
Just as in the asynchronous case, when reasoning about reduction congruence we can be more efficient. In fact, the results of the proceeding section imply that the transitions generated by the rules in Ψs are not actually necessary for complete- ness and, in fact, bisimilarity on Cs is already sound and complete for reduction congruence.

Refining rules
We have shown that closing wrt (InHT) and (OutHT) is an “automatic” way of ob- taining an lts on which similarity characterises reduction precongruence and indeed bisimilarity characterises reduction congruence. It is clear that this procedure is es- sentially the same in our three settings and is sufficient for completeness. What we have not addressed in closing the ltss with these rules is whether it was necessary to do so. Indeed, for the synchronous language one would expect that both input and output actions are observable and that there should be no need for additional
77 rules. This is indeed the case when considering bisimilarity and reduction con- gruence and in this section we shall demonstrate how we can safely remove some of the 77 rules in certain circumstances.
To start, consider the language La of asynchronous communication (cf. Sec- tion 4). Interestingly, although the exclusion of the (OutHT) rule breaks completeness of the lts for similarity, this is not the case for bisimilarity. To show this requires more work but the reward is a refined lts in the sense that bisimulations in specific cases can be made smaller, and therefore, reasoning about reduction congruence is easier.
The key to showing the redundancy of (OutHT) for the asynchronous language lies in the fact that strong output actions are preserved by reduction congruence as given by the following result, which is similar in spirit to Theorem 2 of [9]. However, the notion of observational equivalence is different (ours is “dynamic” in the sense of [10]).
Theorem 6.1 Suppose that a!  Q  R, then R = a!  R' for some R'.
Proof. Omitted.	 
Indeed, let ~inHT denote bisimilarity over the lts given by extending with only rule (inHT). The characterisation of reduction congruence does not break:
Theorem 6.2 ~inHT =  .
Proof. It is easy to check that soundness (~inHT ⊆ ) still holds. For the reverse inclusion, completeness, we establish that  is in fact a bisimulation relation. Sup-
pose then that P  Q and that P —→α  P . The interesting case is α = a!R: choose a
0
name c which is fresh for both P and Q and let χ d=ef c!  a?c?; P must be able to
engage in output on a so
P  χ —→ (P ''  c!  c?) —→ P '
for some P ',P '' where P0 is P '  R. We see that because P  Q, we must also have some Q', Q'' and
Q  χ —→ Q'' —→ Q'
such that (P ''  c!  c?)  Q'' and P '  Q'. The freshness of c and Theorem 6.1 tells us that c is not in P ' and thus Q' cannot be of the form c!  Q''' for any Q'''. But this means that the c! in χ must have been consumed. The only possibility for

this is if Q'' = Q'	c!	c? and this could have only arisen if Q = a!	Q'. From this

we can see that Q —a—!→R
Q'	R and, by congruence of  we have P '	R  Q'	R

as required.	 

The key property used in the above proof is the preservation of strong output actions given by Theorem 6.1. This property is a useful one for characterising the observability of particular actions and has in fact been exploited in the literature in the form of barbed equivalences [9, 6]. In fact, as a corollary of Theorem 6.1 we can easily check that reduction barbed congruence in the finite asynchronous calculus with output barbs coincides with our reduction congruence.
For the synchronous language Ls it is in fact possible to prove that bisimilarity over Φs(∅) without the addition of any Honda Tokoro rules is already complete for reduction congruence. The proof of this relies on establishing results that correspond to Theorems 6.1 and 6.2 but for both input and output actions separately. The point is that it is sound to blindly add the 77 rules to Φs(∅) in order to automatically obtain completeness. We do not need to know whether inputs and outputs are observable or not.
The 77 rules certainly increase the size of the lts and introduce some undesir- able properties such as infinite branching. Indeed, when 77 rules can be avoided, one often obtains a more useful lts in the sense that bisimulations are easier to construct. We finish this section with a trivial but illustrative example to show the impact of the (removal of the) rule (outHT) on reasoning with bisimilarity. Consider the processes of La
P d=ef a!  a?0	and	Q d=ef τ 0
and suppose that we wish to demonstrate that P / Q. Theorem 6.2 would immedi- ately distinguish these processes as there is no ~inHT which relates these due to the presence of an output action on a in P which is clearly absent from Q. Compare this the use of the ~HT relation: consider how Q could match

a!↓ c! c!↓ 0
P ———→ ——→ a?

a!↓ c!
for some c. The rule (outHT) would allow Q ———→ a?c! as an attempt to match P ’s
initial move but there can be no subsequent matching transition from a?c!.
The interesting point in the above example is that there is a non-trivial use of the continuation process in the experiment a!↓ c!. Indeed, these continuation processes are crucial to the soundness of using 77 rules. Note that in the more traditional approach to LTS semantics that one finds in, say, [8], there is no room for specifying the continuation process in an experiment — effectively it is always just the nil process. For the synchronous language this turns out to be sufficient as no 77 rules are necessary, however, what is significant that, if the continuation processes are restricted to be the nil process, it is actually unsound to add them. The previous example suffices to demonstrate this because P and Q would in fact become bisimilar if we restricted to a!↓ 0 labels and admitted rule (outHT).

Conclusions and related work
Sewell’s paper [16] about the derivation of lts has stimulated considerable interest (e.g. [7,14,15,4]) in the relationship between labelled transition systems and under- lying reduction semantics. Our simple “fully asynchronous” language (cf. Section 3) was considered already by Sewell but observability was not taken into account in his derived lts. Bonchi [3] has also considered this example: reduction congruence agrees with the closely related concept of saturated semantics. In this paper, we did not consider the derivation process as such but it is usually the case that such derivations (cf. [12, 13]) yield ltss which are sound but not complete, here we have illustrated a method by which one “completes” them. This fits in with our general research programme that aims at developing techniques (such as derivation of ltss) which are applicable across several languages for concurrency.
Throughout the present paper we have considered finite languages. A natural question is whether the techniques that we have studied extend to languages with infinite behaviour. To answer it, we must first divulge our reasons for considering finiteness: by assuming it we were able to use very simple notions of observational preorders/equivalences (cf. Definitions 3.1 and 3.2). In particular, we were able to avoid talking about barbs which specify “moral observability”, and such notions become less clear for more involved languages [9]. In particular, extending the ideas of [9] may lead to a more clear understanding of the general infinite case.

Acknowledgement
We thank the anonymous referees for their helpful remarks, which have helped us to improve the presentation of the paper.

References
R. Amadio, I. Castellani, and D. Sangiorgi. On bisimulations for the asynchronous pi-calculus. Theor. Comput. Sci., 195(2):291–324, 1998.
G. Berry and G. Boudol. The chemical abstract machine. Theor. Comput. Sci., 96:217–248, 1992.
F. Bonchi. Abstract Semantics by Observable Contexts. PhD thesis, Universit`a degli studi di Pisa, 2008.
F. Bonchi, B. K¨onig, and U. Montanari. Saturated semantics for reactive systems. In LiCS ’06, pages 69–80. IEEE Press, 2006.
K. Honda and M. Tokoro. An object calculus for asynchronous communication. In Proc. ECOOP, volume 512 of LNCS, pages 133–147. Springer, 1991.
K. Honda and N. Yoshida. On reduction-based process semantics. Theoretical Computer Science, 151(2):437–486, 1995.
J. Leifer and R. Milner. Deriving bisimulation congruences for reactive systems. In Proc. Concur, volume 1877 of LNCS, pages 243–258. Springer, 2000.
R. Milner. A Calculus of Communicating Systems, volume 92 of LNCS. Springer, 1980.
R. Milner and D. Sangiorgi. Barbed bisimulation. In ICALP ’92, volume 623 of LNCS, pages 685–695. Springer, 1992.


U. Montanari and V. Sassone. Dynamic congruence vs. progressing bisimulation for CCS. Fundamenta Informaticae, XVI:171–199, 1992.
G. Plotkin. A structural approach to operational semantics. Technical Report FN-19, DAIMI, Computer Science Department, Aarhus University, 1981.
J. Rathke and P. Sobocin´ski. Deconstructing behavioural theories of mobility. In TCS ’08. Springer Science and Business Media, 2008. To appear.
J. Rathke and P. Sobocin´ski. Deriving structural labelled transitions for mobile ambients. In Concur ’08, LNCS. Springer, 2008. To appear.
V. Sassone and P. Sobocin´ski. Deriving bisimulation congruences using 2-categories. Nordic Journal of Computing, 10(2):163–183, 2003.
V. Sassone and P. Sobocin´ski. Locating reaction with 2-categories. Theoretical Computer Science, 333(1-2):297–327, 2005.
P. Sewell. From rewrite rules to bisimulation congruences. Theor. Comput. Sci., 274(1-2):183–230, 2002. Extended version of Concur ’98 conference paper.
