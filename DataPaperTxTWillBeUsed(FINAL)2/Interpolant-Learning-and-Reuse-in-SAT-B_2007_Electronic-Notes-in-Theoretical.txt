Electronic Notes in Theoretical Computer Science 174 (2007) 31–43	
www.elsevier.com/locate/entcs

Interpolant Learning and Reuse in SAT-Based Model Checking
Joao Marques-Silva1
School of Electronics and Computer Science University of Southampton, Southampton, UK

Abstract
Bounded Model Checking (BMC) is one of the most paradigmatic practical applications of Boolean Satis- fiability (SAT). The utilization of SAT in model checking has allowed significant performance gains and, as a consequence, a large number of commercial verification tools now include SAT-based model checkers. Recent work has provided SAT-based BMC with completeness conditions, and this is generally referred to
as unbounded model checking (UMC). Among the existing approaches for SAT-based UMC, the utilization of interpolants is among the most effective. Despite their success, interpolants have only been used for identifying a fixed point of the set of reachable states. This paper extends the utilization of interpolants in SAT-based model checking. This is achieved by observing that, under reasonable assumptions, interpolants can be reused, i.e. computed interpolants can be reused at later stages of the model checking process. The paper develops conditions for validity of interpolant reuse. In addition, the paper outlines a new fixed point condition, alternative to the existing interpolant-based fixed point condition. Preliminary practical experience on interpolant learning and reuse is reported.
Keywords: Boolean Satisfiability, Bounded Model Checking, Interpolants.


Introduction
The utilization of Boolean Satisfiability (SAT) in Model Checking has been the subject of extensive research in recent years. The main result of this effort has been a number of fairly competitive incomplete and complete SAT-based model checking algorithms [3,4,5,20,21,26,27]. Moreover, SAT-based model checking has also been rapidly adopted by industry, and a number of vendors have included SAT-based Model Checking in their tools.
The utilization of SAT in model checking was first proposed in the form of Bounded Model Checking (BMC) [3], where a counterexample is searched for in- creasing unfoldings of a finite state automaton. The original BMC work has been shown to be extremely useful for finding counter-examples but, unless the recurrence

1 Email:jpms@ecs.soton.ac.uk

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.12.021

(or the reachability) diameter of the automaton is known [2], the BMC procedure is incomplete.
Different solutions have been proposed for ensuring the completeness of BMC [26,5,17,16,21], the most promising of which is arguably based on the uti- lization of interpolants [21].
This paper reviews the utilization of interpolants in SAT-based unbounded model checking and proposes the learning and reuse of computed interpolants with the purpose of allowing increased search pruning for subsequent calls to the SAT solver during the model checking process. The paper shows that different inter- polants can be computed and used in different contexts. Moreover, the paper out- lines a fixed point condition alternative to the one proposed in‘[21].
We note that the main objectives of the paper are to investigate the conditions for interpolant reuse, and to propose an alternative interpolant-based fixed point condition. However, our experimental results suggest that interpolant reuse may not yield improvements on industrial examples. A more effective implementation, as well as a more careful selection of which interpolants to reuse, may yield more effective interpolant reuse.
The paper is organized as follows. The next section provides a necessarily brief perspective on SAT solvers and related concepts. Afterwards, Section 3 reviews SAT-based model checking, including bounded and unbounded model checking. Section 4 develops conditions for reusing learnt interpolants. Initial practical expe- rience is summarized in Section 5 and Section 6 concludes the paper.

Preliminaries
Propositional formulas are defined over finite sets of Boolean variables X =
{x1, x2,.. .}, W = {w1, w2,.. .}, X1, X2, etc., where each variable can be assigned value 1 (True) or0 (False). In what follows propositional formulas are represented
by ψ1, ψ2,.   When relevant other subscripts can be used, e.g. ψa, ψb, etc. For spe-
cific cases, letters and names representing predicates are also used for denoting the associated propositional formulas, examples include I, T , F , P , Q and Bmc. When referring to propositional formulas in conjunctive normal form (CNF), we associate with each propositional formula ψa(Xa) a CNF formula ϕa(Xa, Ua), where Ua de- notes a set of auxiliary Boolean variables. Formulas in CNF consist of a conjunction of clauses (each clause represented by ωi), where each clause consists of a disjunction of literals (represented by lj). When used in an expression, a propositional formula ψ is interpreted as a predicate, and so corresponds to ψ = 1. Similarly, when the
propositional formula ¬ψ is used in an expression, it corresponds to ψ = 0.
We consider model checking of LTL safety properties G ψS.  A finite state
automaton M = (I, T, F ) is assumed, where I is a predicate defined on state
(i.e. F = ¬ψS), defined on state variables. Moreover, the utilization of predicates variables, T is the state transition relation, and F represents the failing property I, T or F assumes an underlying automaton M = (I, T, F ). As mentioned above,
for simplicity the propositional formulas associated with these predicates are repre-

sented with the same letters, I, T and F .
It will also be necessary to map propositional formulas from one set of vari- ables to another set of variables. The notation ψ(Y/Yk) is used to denote that the propositional formula ψ, defined over the set of variables Y , is mapped into the set of variables Yk. Moreover, state variables are preferably represented as set Y , Yk when referring to the state variables in time step k. Boolean circuit variables are preferably represented as sets X or W , respectively Xk and Wk for variables in time step k, and finally auxiliary variables used in the CNF representation are preferably represented as sets W or Z.

Boolean Satisﬁability Solvers
The remarkable evolution of Boolean Satisfiability (SAT) solvers over the last decade [19,23,14] has motivated the application of SAT in model checking. The most effective SAT solvers are based on backtrack search [9] and share a number of key techniques, including:
Unit clause rule, also referred as Boolean constraint propagation, that consists of the identification of implied variable assignments [10].
Clause learning, consisting of learning new clauses in presence of conflicts during the execution of backtrack search. A few techniques related with clause learning are the utilization of unique implication points (UIPs) [19], and non-chronological backtracking [19].
Memory efficient lazy data structures [23].
Adaptive branching heuristic, usually derived from the VSIDS heuristic [23].
Utilization of search restarts [15], by using some completeness criterion.
Because modern backtrack search SAT solvers learn clauses, it is straightforward to track all the learned clauses, and use these clauses for constructing a resolution refutation (or unsatisfiability proof) of the original formula [29].

SAT-Related Concepts
This subsection addresses a number of byproducts of modern SAT solvers, which are required for the utilization of interpolants in SAT-based model checking. For this purpose, we review proof traces, unsatisﬁable cores and unsatisﬁability proofs.
As mentioned above, modern SAT solvers learn clauses. For unsatisfiable in- stances, the original clauses and the learned clauses can be used for generating a resolution-based unsatisfiability proof [29]. Modern SAT solvers can be instructed for generating a proof trace, which associates with each learned clause ω, all the clauses that explain the creation of ω [29].
Given a proof trace Γ, where the final traced clause is the empty clause ⊥, we can identify, in linear time on the size of the proof trace, a subset of the original set of
clauses which is itself unsatisfiable [29]. This subset is referred to as an unsatisﬁable core.

Moreover, and given a proof trace Γ, generated by a SAT solver, it is possible to create a resolution-based unsatisfiability proof in time and size linear on the size of the proof trace.
Definition 2.1 [Unsatisfiability Proof [21]] A proof of unsatisfiability Π for a set of clauses ϕ is a directed acyclic graph (VΠ, EΠ), where VΠ is a set of clauses, such that:
For every ω ∈ VΠ, either
ω ∈ ϕ, and ω is a root, or
ω has two predecessors, ω1 and ω2, such that ω is the resolvent of ω1 and ω2
(the variable v used for resolving ω1 with ω2 is referred to as the pivot variable
of the resolution step), and
the empty clause ⊥ is the unique leaf.
Craig Interpolants
Assume a propositional formula ψA(Y, X), defined over the sets of variables Y and
and W . If ψA(Y, X) ∧ ψB(Y, W ) is unsatisfiable, then there exists a propositional X, and a propositional formula ψB(Y, W ), defined over the sets of variables Y formula ψP (Y ), defined over the set of variables Y , such that ψA(Y, X) → ψP (Y ) is a tautology and ψB(Y, W ) ∧ ψP (Y ) is unsatisfiable. The propositional formula ψP (Y ) is referred to as an interpolant for ψA(Y, X) and ψB(Y, W ) [8]. Recent work
resolution   refutation   of   ψA(Y,  X)  ∧  ψB(Y,  W  )   [25]. has shown that an interpolant can be constructed in linear time on the size of a
In what follows we outline McMillan’s interpolant construction [21], even though
Pudla´k’s construction [25] could also be considered. Regarding the propositional formulas ψA(Y, X) and ψB(Y, W ), and associated CNF formulas, respectively ϕA(Y, X, U ) and ϕB(Y, W, V ), variables in set Y are referred to as global variables, whereas variables in sets X and U are local to ϕA(Y, X, U ), and the variables in sets W and V are local to ϕB(Y, W, V ). Further, let g(ω) denote the literals correspond- ing to global variables in clause ω.
a proof of unsatisfiability of ϕA ∪ ϕB, with leaf vertex ⊥. For each vertex ω ∈ VΠ, Definition 2.2 [Interpolant [21]] Let (ϕA, ϕB) be a pair of clause sets and let Π be let ψω be a Boolean formula, such that:
If ω is a root then
if ω ∈ ϕA then ψω = g(ω),
else ψω = True
else, let ω1, ω2 be the predecessors of ω and let v be their pivot variable
if v is local to ϕA, then ψω = ψω1 ∨ ψω2 ,
else ψω = ψω1 ∧ ψω2
The Π-interpolant of (ϕA, ϕB), denoted Itp(Π, ϕA, ϕB) is ψ⊥.
The interpolant Itp(Π, ϕA, ϕB) has size linear on the size of the unsatisfiability proof [25,21].



Algorithm 1 Organization of BMC
BMC(M = (I, T, F ), λ, ι, μ)
1	j ← 0
k ← λ
while k ≤ μ
do ϕ ← Cnf(Bmck(M ),W )
if Sat(ϕ)
then return false D Found counterexample
k ← k + ι
return true

SAT-Based Model Checking
This section overviews the work on using SAT in model checking, emphasizing the initial work on Bounded Model Checking (BMC) and the more recent work on Unbounded Model Checking (UMC).

Bounded Model Checking
The generic Boolean formula associated with SAT-based BMC is the follow- ing [2,3,27]:
k	⎛	⎞	⎛	⎞
0	i	i+1	i
0≤i<k	j≤i≤k
This formula represents the unfolding of the state machine for k time steps, where I(Y0) represents the initial state, T (Yi, Yi+1) represents the transition rela- tion between states Yi and Yi+1, and F (Yi) represents the failing property in time step i. Given the Boolean formula Bmck(M ), it is straightforward to generate a CNF formula ϕ, by applying Tseitin’s [28] or the structure preserving [24] trans- formations, and by using additional auxiliary Boolean variables. This formula can then be evaluated by a SAT solver.
The typical organization of BMC for safety properties is illustrated in Algo- rithm 1. The details regarding the sets of variables associated with each proposi- tional formula are omitted, but are clear from the context. Experimental evidence has confirmed SAT-based BMC to be an extremely competitive technique, that has been widely applied in industrial settings [2,7,12].
In order to describe the work on UMC and the reusing of interpolants, the following predicates are extensively used:

s	⎛
−r	i
⎞
i+1

(2)
Unfold (M )= I(Y	) ∧
−r≤i<s
T (Y ,Y	)⎠

(3)
Trant (M )= 
T (Yi, Yi+1)

s≤i<t

u	⎛	⎞	⎛	⎞
i	i+1	i

(4)
Propv (M )= ⎝
u≤i<u+v
T (Y ,Y 
)⎠ ∧ ⎝
u≤i≤u+v
F (Y )⎠

Hence, we can express the BMC formula in terms of these predicates:

BMCk(M ) = Unfoldj (M ) ∧ Propj
(M )

(5)
j	0	k−j

= Unfold0(M ) ∧ Tranj (M ) ∧ Propj
(M )

0	0	k−j
Unbounded Model Checking
A key difficulty with BMC is its inability for proving that there is no counterexam- ple for a given safety property G ψS. Unless the recurrence (or the reachability) diameter [2] of an automaton is known, it is not possible to establish the value of the upper bound (UB) used in Algorithm 1; in the case the recurrence diameter is known, BMC becomes complete. In general the recurrence diameter of an au- tomaton is not known, and so BMC is incomplete. As a result, in recent years different approaches have been proposed for ensuring the completeness of SAT- based model checking. We refer to these approaches as Unbounded Model Checking (UMC) [20,21]. The first UMC SAT-based approach was proposed by Sheeran et al. in [26] and extended in [4]. Additional techniques include [5,20,13,22,21,16]. The induction-based approach of Sheeran et al. [26] requires unfolding the state machine for the largest simple path between any two reachable states in the worst case. However, the largest simple path between any two reachable states can be ex- ponentially larger than the reachability diameter. Alternatively, Chauhan et al. [5] and Glusman et al. [13] propose refinement techniques based on elimination of false counterexamples. Another approach based on iterative abstraction is proposed by Gupta et al. in [16]. More recently, McMillan and Amla [22] propose the utilization of proof-based abstraction, even though the proposed approach is not fully SAT- based. According to experimental data from [21], the utilization of interpolants in SAT-based model checking is the most effective approach. We detail the utilization of interpolants in the next section.
Interpolant-Based Unbounded Model Checking
Recent work on SAT-based Unbounded Model Checking has addressed the utiliza- tion of interpolants [21], with quite promising experimental results. This section reviews McMillan’s interpolant-based UMC algorithm [21].
The definition of the BMC proposition formula is modified slightly with respect to (1):


(6)
Prefl(M ) = I(Y−l) ∧   −l≤i<0 T (Yi, Yi+1) 
= Unfold0(M )


(7)
Suffk(M ) = 

0≤i<k
T (Yi, Yi+1) ∧ 

j≤i≤k
F (Yi) 

= Tranj (M ) ∧ Propj
(M )

0	k−j



Algorithm 2 UMC Algorithm UMC(M = (I, T, F ))
1	k ← 0
if Sat(I ∧ F )
then return false D Counterexample found
while true
do status = CheckFixpoint(M, k)
if status = false
then return false D Counterexample found
else if status = true
then return true D Property proved
k ← k +1 D Unfold further
Hence, the BMC formula becomes:
Bmck(M )= Pref1(M ) ∧ Suffk(M )
j	j
The above equation corresponds to the one proposed by McMillan [21], where the separation between prefix and suffix identifies the set of variables with respect to which interpolants are to be computed.
The SAT-based model checking algorithm can be organized into two main phases: a BMC loop, where the circuit is unfolded, and a fixed point checking step, that checks for the existence of a counterexample and where the existence of a fixed-point is tested. Observe that the second phase requires the iterative computation of interpolants until a fixed-point is reached or a true or (possibly) false counterexample is identified. The organization of the BMC loop is outlined in Algorithm 2, whereas the organization of fixed point checking step is outlined in Algorithm 3.
For the BMC loop there is no upper bound on the number of unfoldings, since the algorithm is now complete. The increment of k is not required to be 1. In fact, feedback from the fixed point checking procedure can be used for increasing k by values larger than 1 [18]. In addition, observe that the fixed point checking procedure consists of iterative computation of interpolants, where for iteration m the interpolant represents an abstraction of the reachable states in m time steps [21]. At each iteration of the UMC fixed point checking procedure, the existence of a fixed- point is tested. The fixed-point is reached when the abstraction of the reachable states in m time steps contains only states already included in the abstractions of the reachable states in less than m time steps. Finally, observe that the algorithm sets j = 0, because interpolants are computed with respect to Y0.

Interpolant Learning and Reuse
This section develops conditions for reusing computed interpolants, and consists of two main parts. Conditions for interpolants representing over-approximations of the set of reachable states, and conditions for interpolants representing over-



Algorithm 3 Fixed point identification in SAT-based UMC
CheckFixpoint(M = (I, T.F ), k)
R ← I
while true
do M ' ← (R, T, F )
A ← Cnf(Pref1(M '), W1)
B ← Cnf(Suffk(M '), W2)
(isSat, Γ) ← Sat(A ∪ B)
if isSAT
then if R = I
then return false
else return abort
D A ∪ B is unsat
Π ← UnsatProof(Γ)
P ← Itp(Π, A, B)
R' ← P (Y/Y0)
C ← Cnf(¬R, W3)
D ← Cnf(R', W4)
(isSat, Γ) ← Sat(C ∪ D)
if not isSAT
then return true
R ← R ∨ R'
approximations of the set of states satisfying the failing property. We should note
that the work on interpolant reuse is largely motivated by previous (and successful) work on clause reuse [27]. Clause reuse has been used extensively in BMC and is widely regarded as a key technique [27,12].
The main motivation is to develop conditions which enable computed inter- polants to be reused. Hence, the following definition is used extensively.
Definition 4.1 A Boolean formula ψN is said to be usable for Boolean formula ψB
iff ψB → ψN .
Hence, ψN preserves satisfiability of the original formula and so we get the
following straightforward result:

Proposition 4.2 Let ψN be usable for ψB. Then ψB is satisﬁable iff ψB ∧ ψN is satisﬁable.
In order to generalize the computation of interpolants, equation (5) is modified as follows:
Bmck(M )= Unfoldk(M ) ∧ Propk(M )
j	0	j
Observe that the new equation differs from (5) and (8). In equation (9) the failing property is checked for only in the last j time steps for an unfolding of k + j time

steps 2 . (This approach is also used for example in [7,26,12].) For simplicity we assume j = 0; generalization for j > 0 is simple.
The standard interpolants used in [21] are referred to as direct interpolants. It is also possible to compute reverse interpolants by exchanging the sets A and B in the definition of interpolant. Direct interpolants are computed as described in McMillan’s work [21] (see also the previous section), but relaxing the 1 time step
unfolding for A. For computing an interpolant after r time steps from I and t = k−r
time steps from F , the propositional formulas for A and B become:
A = Cnf(Unfoldr(M ), W1)


Cnf Trank
k−t
(M ) ∧ Propk(M ), W2)

The interpolant computed with A and B above will be denoted Pr. It is also possible
to compute an interpolant by replacing I with another interpolant Pu:
A = Cnf(Pu(Y0) ∧ Tranr(M ), W1)


v
Cnf Trank
k−t
0
(M ) ∧ Propk(M ), W2)

And the new interpolant is denoted Pu+r.

Consequently, Pr, with r, t ≥ 0, denotes the direct interpolant computed with a (possibly virtual) unfolding of r time steps from the initial state, and t time steps
until the failing property is checked for. Hence, Pr represents an over-approximation of the set of states reachable in r time steps and an under-approximation of the set of states which do not satisfy the failing property in t time steps.
Reverse interpolants are computed by interchanging the definitions of A and B
in (10) and (11), and will be denoted by Qr. Hence, Qr, r, t ≥ 0, denotes the reverse
t	t
interpolant computed with an unfolding of r time steps from the initial state, and
(possibly virtual) t time steps until the failing property is checked for. Hence, Qr represents an under-approximation of the set of states that are not reachable in r time steps and an over-approximation of the set of states which satisfy the failing property in t time steps. From (10) and (11) we obtain:


Cnf Trank
k−t
(M ) ∧ Propk(M ), W3)

B = Cnf(Unfoldr(M ), W4)
The interpolant computed with A and B above will be denoted Qr. It is also possible to compute an interpolant by replacing F with another interpolant Qu:


Cnf Trank
k−t
(M ) ∧ Qu(Yk))

B = Cnf(Unfoldr(M ), W4)
And the new interpolant is denoted Qr	.
Given the definitions of direct and reverse interpolants, we can now establish conditions for interpolant reuse in SAT-based model checking.

Theorem 4.3 Let Bmck(M ) be given by (9), and direct interpolants Pr
be com-

j	t
puted with (10) and (11). Then the following holds:

2 The automaton is assumed to be stuttering closed [6,21].

Pr(Yr) is usable for Bmck(M ), with t ≥ 0 and 0 ≤ r ≤ k.
t	j
¬Pr(Yk−t) is usable for Bmck(M ), with r ≥ 0 and 0 ≤ t ≤ k.
t	j
Proof.
(i) If Bmck(M ) is satisfiable, then Unfoldr(M ), with r ≤ k is also satisfiable and
j	0
Yr represents a state reachable in r time steps. By definition, Pr(Yr) represents
an over-approximation of the states reachable in r time steps. Hence, Pr(Yr) holds for any assignment to the variables in Yr representing a state reachable
in r time steps. Thus, Bmck(M ) → Pr(Yr), with r ≤ k. By definition, Pr(Yr)
j	t	t
is usable for Bmck(M ), with r ≤ k. Observe that there is no upper bound on
the value of t.
do not satisfy the failing property in t time steps.	Hence,  Pr(Yk−t)  → (ii) Observe that Pr(Yk−t) represents an under-approximation of the states which
¬Bmck(M ) with t ≤ k. Consequently, Bmck(M ) → ¬Pr(Yk−t). By defi-
j	j	t
nition, Pr(Yk−t) is usable for Bmck(M ), with t ≤ k. Observe that there is no
t	j
upper bound on the value of r.

Theorem 4.4 Let Bmck(M ) be given by (9), and reverse interpolants Qr be com-
j	t
puted with (14) and (15). Then the following holds:
Qr(Yk−t) is usable for Bmck(M ), with r ≥ 0 and 0 ≤ t ≤ k.
t	j
¬Qr(Yr) is usable for Bmck(M ), with t ≥ 0 and 0 ≤ r ≤ k.
t	j
Proof. The proof is similar to the proof for Theorem 4.3.
If Bmck(M ) is satisfiable, then Trank	(M ) ∧ Propk(M ), with t ≤ k is also
j	k−t	k
satisfiable and Yk−t represents a state that satisfies the failing property in t time
steps. By definition, Qr(Yk−t) represents an over-approximation of the states
that satisfy the failing property in t time steps. Thus, Bmck(M ) → Qr(Yk−t),
j	t
with t ≤ k. By definition, Qr(Yk−t) is usable for Bmck(M ), with t ≤ k.
t	j
Observe that there is no upper bound on the value of r.
Observe that Qr(Yr) represents an under-approximation of the states that are
unreachable r in time steps. Hence, Qr(Yr) → ¬Bmck(M ), with r ≤ k. Conse-
t	j
quently, Bmck(M ) → ¬Qr(Yr). By definition, Qr(Yr) is usable for Bmck(M ),
j	t	t	j
with r ≤ k. Observe that there is no upper bound on the value of t.
Remark 4.5 Even though we describe the most general setting for learning and
reusing interpolants, the specific interpolants computed in the standard interpolant- based fixed point condition [21] are also usable according to the conditions of The- orems 4.3 and 4.4. Hence, interpolant reuse can be readily integrated in a standard interpolant-based UMC flow.
Remark 4.6 The conditions of Theorems 4.3 and 4.4 can be used in any
BMC/UMC setting, independently of whether a fixed point is used and whether


Table 1
Results with and without interpolant reuse

it is based on interpolants.
Remark 4.7 It is straightforward to conclude that reverse interpolants can be used for developing a fixed point condition alternative to the one of [21]. Algorithm 3 can easily be adapted for using reverse interpolants, computed one time step from the time step at which the property is checked for. Similarly to image computation ap- proaches in BDD-based symbolic model checking, the advantages of this alternative fixed point condition are expected to depend on the actual automaton.

Experimental Results
The practical experience reported in this section respects a preliminary SAT- based model checking prototype. The prototype represents interpolants as Reduced Boolean Circuits (RBCs) [1]. The backend SAT solver is MiniSAT [11]. The imple- mentation of interpolant computation is still preliminary and, currently, different interpolants do not share structure. Even though each interpolant is generated with the rules of [1], each different interpolant is maintained with a separate RBC manager, and so common nodes among different interpolants are not shared. More- over, the utilization of interpolants was evaluated in a standard BMC loop, and so interpolants were solely computed for search pruning purposes. Iinterpolants were computed with respect to the last time step and reused in the last time step. As a result, reused interpolants serve for preventing sets of unwanted states to be reached.
Table 1 shows preliminary results from interpolant reuse. The first set of in- stances represent standard counters, for which counterexample exists. The second set of instances represent industrial problem instances, for which a counterexam- ple also exists. As can be concluded, the utilization of interpolants does not yield improvements to the run times. For the first set of (artificial) examples the results

are worse than for the second set of (industrial) examples. As mentioned above, the setup for the utilization of interpolants is certainly not the most adequate. We considered a simple BMC loop, where interpolants are solely used for search pruning purposes. The reuse of interpolants in a UMC setting is expected to provide more competitive results, since the interpolants have be computed for checking the fixed point condition.

Conclusions and Future Work
This paper develops conditions for learning and reusing of interpolants in SAT-based model checking. Computed interpolants can be used for requiring states from a set of states or for preventing states from a set of states. Besides interpolant reuse, an alternative fixed-point condition is also proposed, based on reverse (as opposed to direct) interpolants.
The preliminary results are not positive, albeit the implementation is still very preliminary. Moreover, the experimental setup chosen was not beneficial for the reuse of interpolants. Instead of an interpolant-based UMC algorithm, where inter- polants need to be computed, our experiments consisted of a standard BMC loop, where computed interpolants were solely used for search pruning purposes.
A few drawbacks of the current implementation have been identified. Examples include the lack of structure sharing between different interpolants, and the fact that interpolants were computed solely for interpolant reuse and not for checking the existence of a fixed point. Integration of these improvements is expected to yield more promising results for interpolant reuse.

Acknowledgments
This work has been partially supported by European project IST-033709 VERTIGO.

References
P. A. Abdulla, P. Bjesse, and N. E´en. Symbolic reachability analysis based on SAT solvers. In International Conference on Tools and Algorithms for the Construction and Analysis of Systems, 2000.
A. Biere, A. Cimatti, E. Clarke, O. Strichman, and Y. Zhu. Advances in Computers, chapter Bounded Model Checking. Academic Press, 2003.
A. Biere, A. Cimatti, E. Clarke, and Y. Zhu. Symbolic model checking without BDDs. In International Conference on Tools and Algorithms for the Construction and Analysis of Systems, pages 193–207, March 1999.
P. Bjesse and K. Claesen. SAT-based verification without state space traversal. In International Conference on Formal Methods in Computer-Aided Design, 2000.
P. Chauhan, E. Clarke, J. Kukula, S. Sapra, H. Veith, and D. Wang. Automated abstraction refinement for model checking large state spaces using SAT based conflict analysis. In International Conference on Formal Methods in Computer-Aided Design, 2002.
E. M. Clarke, O. Grumberg, and A. Peled. Model Checking. MIT Press, 1999.
F. Copty, L. Fix, R. Fraer, E. Giunchiglia, G. Kamhi, A. Tacchella, and M. Y. Vardi. Benefits of bounded model checking at an industrial setting. In International Conference on Computer-Aided Verification, 2001.

W. Craig. Linear reasoning: A new form of the Herbrand-Gentzen theorem. Journal of Symbolic Logic, 22(3):250–268, 1957.
M. Davis, G. Logemann, and D. Loveland. A machine program for theorem-proving. Communications of the Association for Computing Machinery, 5:394–397, July 1962.
M. Davis and H. Putnam. A computing procedure for quantification theory. Journal of the Association for Computing Machinery, 7:201–215, July 1960.
N. Een and N. Sorensson. An extensible SAT solver. In Sixth International Conference on Theory and Applications of Satisfiability Testing, May 2003.
N. Een and N. Sorensson. Temporal induction by incremental SAT solving. In Workshop on Bounded Model Checking, volume 89 of ENTCS, 2003.
M. Glusman, G. Kamhi, S. Mador-Haim, R. Fraer, and M. Vardi. Multiple-counterexample guided iterative abstraction refinement. In International Conference on Tools and Algorithms for the Construction and Analysis of Systems, April 2003.
E. Goldberg and Y. Novikov. BerkMin: a fast and robust SAT-solver. In Design, Automation and Test in Europe Conference, pages 142–149, March 2002.
C. P. Gomes, B. Selman, and H. Kautz. Boosting combinatorial search through randomization. In
National Conference on Artificial Intelligence, pages 431–437, July 1998.
A. Gupta, M. Ganai, Z. Yang, and P. Ashar. Iterative abstraction using SAT-based BMC with proof analysis. In International Conference on Computer-Aided Design, November 2003.
H.-J. Kang and I.-C. Park. SAT-based unbounded symbolic model checking. In Design Automation Conference, pages 840–843, June 2003.
J. P. Marques-Silva. Improvements to the implementation of interpolant-based model checking. In Advanced Research Working Conference on Correct Hardware Design and Verification Methods, October 2005.
J. P. Marques-Silva and K. A. Sakallah. GRASP: A new search algorithm for satisfiability. In
International Conference on Computer-Aided Design, pages 220–227, November 1996.
K. L. McMillan. Applying SAT methods in unbounded symbolic model checking. In International Conference on Computer-Aided Verification, July 2002.
K. L. McMillan. Interpolation and SAT-based model checking. In International Conference on Computer-Aided Verification, 2003.
K. L. McMillan and N. Amla. Automatic abstraction without counterexamples. In International Conference on Tools and Algorithms for the Construction and Analysis of Systems, April 2003.
M. Moskewicz, C. Madigan, Y. Zhao, L. Zhang, and S. Malik. Engineering an efficient SAT solver. In
Design Automation Conference, pages 530–535, June 2001.
D. A. Plaisted and S. Greenbaum. A structure-preserving clause form translation. Journal of Symbolic Computation, 2(3):293–304, September 1986.
P. Pudl´ak. Lower bounds for resolution and cutting planes proofs and monotone circuit computations.
Journal of Symbolic Logic, 62(3):981–998, 1997.
M. Sheeran, S. Singh, and G. Stalmarck. Checking safety properties using induction and a SAT solver. In International Conference on Formal Methods in Computer-Aided Design, 2000.
O. Strichman. Tuning SAT checkers for bounded model checking. In International Conference on Computer-Aided Verification, July 2000.
G. S. Tseitin. On the complexity of derivation in propositional calculus. Studies in Constructive Mathematics and Mathematical Logic, Part II, pages 115–125, 1968.
L. Zhang and S. Malik. Validating SAT solvers using an independent resolution-based checker: Practical implementations and other applications. In Design, Automation and Test in Europe Conference, pages 10880–10885, March 2003.
