Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 313 (2015) 47–64
www.elsevier.com/locate/entcs

Coarse-graining the Dynamics of Ideal Branched Polymers
Vincent Danosa,1 Ricardo Honorato-Zimmerb,2 Sebastian Jaramillo-Riveric,3 Sandro Stuckid,4
a School of Informatics University of Edinburgh Edinburgh, United Kingdom
b Informatics Life-Sciences Institute University of Edinburgh
Edinburgh, United Kingdom
c SynthSys
Edinburgh EH9 3JD, United Kingdom
d PPS Laboratory Universit´e Paris Diderot – Paris 7
Paris, France

Abstract
We define a class of local stochastic rewrite rules on directed site trees. We give a compact presentation of (often countably infinite) coarse-grained differential systems describing the dynamics of these rules in the deterministic limit, and study in a simple case finite approximations based on truncations to a certain size. We show an application to the modelling of the dynamics of sugar polymers.
Keywords: rule-based modelling, fragmentation, coarse-graining, ideal branched polymers


Introduction
There are well-understood limitations to using rate equations in the modelling of chemical and biochemical networks of reactions. Often, in realistic conditions, the number of molecules is small, stochastic effects become important and differential methods lose relevance. In this paper we will be concerned with another limitation induced by the constructive complexity of biochemical systems. To illustrate this idea

1 Email: vdanos@inf.ed.ac.uk
2 Email: s1066652@sms.ed.ac.uk
3 Email: sjaramil@staffmail.ed.ac.uk
4 Email: sandro.stucki@epfl.ch

http://dx.doi.org/10.1016/j.entcs.2015.04.018
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

consider proteins that can bind together via specific domains [17,14] and create a number of different species which is so enormous that it calls for different methods, perhaps even different questions and perspectives on the protein world [10]. Enters rule-based modelling. The idea is that basic molecules are now described as sets of domains, and the various reactions in which they can take part are pooled together into reaction classes or rules. This gives means to describe highly constructive sys- tems in a compact form and without having to enumerate a (possibly infinite) set of species. This idea has been captured, studied, and implemented in two languages which are essentially the same, namely Kappa and the BNG language [1]. Other formalisms, in the tradition of process algebras, use rules of less direct expressivity but broadly similar in their intentions, and have the same fundamental ability to cope with unbounded sets of species [2].
Let us make the idea of rules a bit more precise by considering a molecule (or agent) A with two domains x, y. We can write a generic rule A(x), A(y) → A(x1), A(y1) expressing the possibility of forming a bond between x and y (the bond is denoted by the shared superscript) provided they are both free. This rule will apply regardless of the larger context in which the two agents A are found. It follows that this single rule pools or subsumes countably many reactions. Indeed, the two agents of type A can themselves be part of two chains, perhaps formed by the repeated application of the same rule. Suppose now A has a third domain similar to x, say z, with a similar binding rule A(z), A(y) → A(z1), A(y1). Taken together these rules will lead to the formation of branched polymers. Note that in this paper, there is no attempt at representing the actual geometry of complexes or polymers. This corresponds in the vocabulary of polymer sciences to ideal or spherical polymers. Of course, not every polymer is like that. For polymers where geometry is important (as in some of the cell molecular machinery such as the proteasome [9]) other and richer methods are called for (e.g. see Ref. [5], same volume). Given the title of this paper, one might be tempted to conclude that we are interested in the macro structure of such polymers. This is not the case. Rather, we are interested in the fine details of the connectivity between monomers at the micro scale. At larger scales, other interesting phenomena occur such as those treated in Ref. [7].
What then, do we mean by coarse-graining? Due to the constructive complexity mentioned above, the old biochemical horizon of a few hundreds of species is broken. This is specially true for polymers, where the number of possible species generated by a single polymerisation rule is infinite. To deal with such systems, coarse-graining methods have been developed recently which can reduce considerably the number of variables to be considered. In the context of the present paper, we are interested in one of them, called fragmentation. This method is suited to rule-based models and allows one to extract a smaller dimensional, more efficient representation of the dynamics [11,12,3]. We will adopt the method presented in Ref. [12] and explore the implications of using it in a new setting. In this method, one starts with a set of observables S and the fragmentation will generate a differential equation that describes the evolution of each observable (or fragment ) in S as a function of some other observables T1,..., Tn. One can apply the same treatment to these new

observables Ti, in the hope that at some point the procedure will stop generating new observables. If that happens, one ends up with a finite and closed set of differential equations for a set of observables F(S), from which any reference to the actual state of the system has been eliminated.
So far, this methodology has been successful at dealing with rule sets that gen- erate only a finite number of species. Indeed, in this case, one is certain that the above expansion will terminate, as there cannot be more fragments than there are partial species. The overall goal of this paper is to take fragmentation to new terri- tories where the number of species generated by the dynamics is unbounded. In this case, there is no guarantee that the procedure terminates. The “lower dimensional” system describing the evolution of fragments in F(S) might not be finite. It is even doubtful in general whether it is decidable that a given observable T is in F(S). Note that in this work we are dealing with a different kind of infinity than that of infinite-state continuous-time Markov chains as presented in [13]: Here we have an unbounded number of species (i.e. dimensions), not only an unbounded number of tokens for one or more species.
To explore this new universe cautiously, we start with a rather tame kind of polymers, namely the branched trees alluded to above. Nodes are taken from an alphabet Σ of agent types, each type having a distinguished input site. A tree over Σ is said to be directed if all links it contains link an output site of a node to an input site of another node. Note that such trees are allowed to be partial, meaning that nodes do not have to exhibit all their sites. Dealing with acyclic and directed polymers is one strong restriction. We shall add another one by considering only simple local rules of the following three types: branching (B), extension (E), and deletion (D). We refer to the combination of these types of rules as the BED rule class.
The problem is still interesting despite those simplifications and the BED rule class exhibits a rich phenomenology in relation to the fragmentation problem as we will see below. We ask essentially three questions. Firstly, we ask if there is a simple presentation of F(S), given S. The answer is affirmative. The presentation can be given by a simple set of rewrite rules that will generate all fragments in F(S). This set is in general infinite and we give a series of simple examples, although there are interesting particular cases where it is finite. These rewrite rules used to generate fragments are slightly more general than the Kappa syntax allows because they deal with partial objects (as opposed to Kappa rules that deal with complete objects, i.e. mixtures). Secondly, we ask whether one can decide if F(S) is finite, or more generally if a given T is in F(S). We give partial answers to this second question. Thirdly, we investigate whether one can define consistent truncations of the set of differential equations E (T ), that is to say finite self-consistent subsets of equations, which will approximate the behaviour of the original system F(S) even if it is infinite. This is really two questions in one. We give an example of truncation in a very simple case and leave the general problem for future work.
This study increases our familiarity with fragmentation in general conditions, and advances the concept of approximate finite truncations as a way to deal with

infinite fragmentations. This is not to say that the purpose of this work is entirely theoretical and methodological. It turns out that one of the simple examples where we have a finite expansion can be seen as a stylised version of sugar polymers. To the extent that one can describe their dynamics without explicit mention of geometries, our methodology offers a simple system of differential equations to explore the competition one observes between branching and elongation in the fine structure of some of such polymers. This preliminary work also demonstrates that there are many basic questions that are not yet understood about the coarse-graining of rule- based systems. We return to these questions in the conclusion.

Preliminaries
The site graph rewriting system which we are going to use is called Kappa. We will keep our Kappa reminder informal because it has been well-explained in other references (e.g. [16]) and the rest of the paper will give several examples of actual rule sets. As said in the introduction, agents (or nodes) of a certain type have a fixed set of sites and they can assemble into site graphs by using sites to build connections. Sites can also hold one of finitely many states. This is convenient to represent allosteric states and/or post-translational modifications, but we will not use it in this paper. For instance, if we return to the divalent agent A(x, y) of the introduction, with the bond forming rule A(x), A(y) → A(x1), A(y1), we can form chains of any length, and even rings A(y0, x1), A(y1, x2), A(y2, x0). Complete (meaning all agents have all their sites) connected site graphs correspond to the usual notion of species (also known as complex in biology).
Site graphs and embeddings form a category and we write [x; y] for the set of embeddings of a site graph x into another site graph y. Our notion of embedding (sometimes called matching as well) is one-one on nodes and has to respect free sites: a free site can only be matched to a free site (unlike in traditional graph morphisms). This category has a fundamental property, namely it has a notion of minimal glueing. This means that for any two site graphs s1, s2, a pair of embeddings m1 ∈ [s1; x], m2 ∈ [s2; x] can always be factored uniquely up to unique isomorphism through a ‘smaller’ pair of embeddings that constitute a minimal glueing as follows:

m′	m′
s1 	1  t ¸¸,2  s2

x
One simply takes for t the union of the images of m1, m2 in x. There can be many minimal glueings depending on the pair m1, m2 one starts from. For example, in the case of s1 = s2 = A(x1), A(y1, x2), A(y2), there are nine different non-isomorphic minimal glueings (it is an interesting exercise to find them all). Importantly, a glueing g is a diagram, specifically a pair of embeddings with the same codomain (also known as a co-span). We write gˆ for that codomain (x and t respectively in the diagram above). Non-isomorphic minimal glueings can have the same codomain; so

the ˆ. map is not injective on (minimal) glueings. In other words, of all the (finitely) many minimal and non-isomorphic ways to glue two given site graphs s1, s2, some might lead to the same codomain t. This can cause some confusion and should be kept in mind for equation 1 below.
Rules are triples (s, α, k) consisting of a partial site graph s (the left hand side or lhs), a rule action α which is a composition of atomic actions such as erasing or adding an edge or a node (and changing internal states), and a rate k ≥ 0. The notion of embedding guarantees that these instructions carry over through any embedding to any complete site graph x, that is, that the action of the rule is applicable to
x. Each embedding of s in x a complete site graph can give rise to an event and is given rate k. This automatically defines the stochastic semantics of a set of rules as a continuous-time Markov chain which can be implemented efficiently [4]. Despite the said efficiency, and for other reasons we will mention in the next section, it is sometimes advantageous to use another semantics based on differential equations. One can do this on species, but for even moderately complex rule sets the number of species can be prohibitive, and the differential approximation of the natural stochastic semantics irrelevant. One solution to this is to write differential equations on partial observables.
Given a partial connected site graph F (also called a fragment) and a rule set R, the average rate of change in the number of embeddings for F in x can be expressed as follows:

 d [F ; x]= −
dt
Σ	k(r) · [Cˆ; x]+ Σ	Σ	k(r) · [(Pˆ)٨; x]	(1)

r∈R C∈g(F,r)	r∈R P ∈g′(F,r)
where g(F, r) is the set of minimal glueings of F and the lhs of rule r such that the action of the rule α(r) would modify F (called relevant glueings for short), gj(F, r) is the same but to the rhs of r, and (Pˆ)٨ denotes the result of applying the inverse rule r٨ to Pˆ.
One has a similar equation for the observables [Cˆ; x], and [(Pˆ)٨; x] which in turn
will produce new observables. The process of fragmentation consists in the repeated application of the equation above until a fixed point, possibly infinite, is reached [12]. Note that the procedure can be made relative to the reachable observables. There is no need to generate an equation for an observable that one knows will never be present in the system.

Directed site trees
We will assume throughout this paper that reachables are site trees built on di- rected agents (i, s1,..., sn) with a unique input site and any number of output ones (Fig. 1). To simplify notations, we suppose agent types are encoded in their unique i input site. So i ∈ I where I indexes agent types. We write σ(i) for the set of outputs of agent i, so that the complete interface of this agent type is {i}∪ σ(i). We fix once and for all the alphabet Σ of directed agents we work with, and will consider rule sets where only bonds between inputs and outputs can be formed.
We write T (Σ) for directed site trees over Σ, and T0(Σ) ⊆T (Σ) for the complete

ones, and T0(Σ)٨ for finite disjoint sums of trees in T0(Σ). Every tree, complete or not, has a natural order induced by the local orientation of agents. This order has a minimum node which we call the root of the tree, and a set of maximal nodes which we call the leaves of the tree (Fig. 1).
Given trees T , T1 in T (Σ), we write T1 ≤ T if T1 can obtained from T by repeatedly pruning leaves off of T (leaving the output site to which the leaf was attached free in the node below the leaf); by convention, this includes the case where T1 is the empty tree (all leaves have been pruned so to speak). This is stronger than the usual notion of sub-site-tree as one is not allowed to erase free sites.
Given a tree S, we write ∂S for the set of its free output sites; given a sequence of N complete trees, T , including possibly empty ones, and a tree S with |∂S| = N , we write S ◦ T for the tree obtained by binding each free output site of S to the root of its associated tree in T (if it is not empty, and doing nothing if it is).
We will restrict further our interest to rule sets under which the set T0(Σ)٨ is closed, that is, rule sets where the result of applying any rule to a complete site tree is again a complete site tree.






input site
output sites
σ(i)

leaves





Figure 1. Directed agent on the left and directed tree on the right.





Branching:



Extension:



Deletion:

Figure 2. BED rule set.

BED rule set
Our chosen BED rule set is as follows.
B(s, t, i)	:= (s1, t), (i1) → (s, t1), (i1)	Branching
E(s, i, t, j) := (s0), (i0, t), (j, σ(j)) → (s0), (i0, t1), (j1, σ(j))	Extension
D(s, i, t, j) := (s0), (i0, t1), (j1, σ(j)) → (s0), (i0, t), (j, σ(j))	Deletion
Fig. 2 shows a graphical representation of these rules. Branching is allowed anywhere including at a root, and not just at the leaves (i.e. not only at the ‘surface’ of the tree, hence we say this is the ‘volume’ version of the branching rule). Extensions and deletions on the other hand must happen on leaves, so at the surface. Extensions are obtained by binding a free output site t to an agent (j, σ(j)) with its input site j free. This can happen only provided t’s node is itself input bound via a specific (s, i) bond (called later sometimes the ‘witness’). This condition forces the node to not be the root - so we need at least a dimer seed to start up a polymer. This condition also allows for dependencies between the added edge (t, j) and the witness one (s, i), depending on whether the witnessing edge (s, i) can be any edge type or a subset of these.
Leaf deletion depends on a witnessing edge as well. This means that a seed dimer cannot be dissociated, thus avoiding the deadlock state in which we do not have a tree to grow.
These rules were chosen as a simple class of rules that allows nevertheless a stylised version of the action of different classes of enzymes involved in the poly- merisation and management of large sugar polymers. See next section for more motivations and explanations about the biological context. Having said that, in the context of this paper these rules serve mostly as a testbed to investigate infinite fragmentations as said earlier in the introduction.
It is easily seen that:
Lemma 1 T0(Σ)٨ is closed under the action of BED rules.
The fact that we can restrict to systems where the only reachable complexes are directed trees over Σ will greatly simplify our analysis of fragmentation.

Basic surface model
Before we move on to the general theory, let us investigate a simple surface model where we have only extension and surface branching. See Fig. 3 for the rules in graphical notation. In our model Σ consists of only one type of agent G(s1, s4, s6) where s1 is the distinguished input (see Fig. 4 for an example directed site tree gener- ated by this model). This agent is an abstract version of the glucose molecule which has three binding sites in sugar polymers. The indices 1, 4, 6 refer to the position of the atom used in the formation of a new bond in the molecule. The rule themselves abstract the behaviour of enzymes extending and rebranching sugar polymers. Re-

branching enzymes are known to rebranch with longer distances between the section node (white) and the insertion node (light blue), but one can imagine that an s4–s1 bond stands for several monomers in a chain.
Branching is directed from s4 to s6. Note that in this basic system, once a (white) node has chosen to extend, it can no longer branch, because B is only enabled at leaves.
Extension requires the s1 site of the left (white) node to be bound; otherwise free nodes can be used as seeds to generate new trees. This condition is expressed in Kappa by the use of a “semilink” which states that a site has to be bound. Semilinks are denoted by a thick line sticking out of a site in graphical notation and a star ( ) superscript in text notation. If we do not impose such condition on extensions, the formation of polymers is no longer a unique growth where monomers are added (for this kind of free polymerisation, the reader can consult Ref. [6]).
To analyse this basic model we define the following observables:

T  = G(s٨, s4)
G = G(s1, s4, s6)
Tf = G(s1, s6), G(s1, s4, s6)
4	1
Then, the extension and branching activities are:

αE = kE[G][T ]
αB = kB[Tf ]

where [G] is the number of free G agents and [Tf ] ≤ [T ] is the number of leaves u standing above a node free at s6. In Fig. 5, we can see an example tree where [Tf ] = 0, hence a deadlock state for this basic model.
We have a mostly branching regime when:


κ := αB
= kB · 1
· [Tf ]   1

αE	kE
[G]
[T ]

B


E


Figure 3. In this basic model, one can either branch (B) or extend (E). In both cases the right (light blue) agent has to be free on s4 and s6 to guarantee the absence of cycles. The initial state needs a seed chain,
i.e. a chain of length at least 1 (i.e. 2 agents), else no rule applies. Note the use of a semilink, denoted by the thick line, on site s1 of the left agent in rule E.

Fragmentation
To study the basic model, in particular the ratio κ = αB/αE, we can fragment it using as seeds the observables defined above, i.e. G, T , and Tf . The closure of this triple is given by:
X1 = G(s٨, s4)	= T X2 = G(s٨, s4, s6)
X3 = G(s1, s4, s6)	= G
Y1 = G(s1, s6), G(s1, s4, s6)	= Tf
4	1
Y2 = G(s٨, s1, s6), G(s1, s4, s6)
1	4	1
Indeed the fragmentation gives:
[X˙1] = −kE[X1][X3]+ kE[X1][X3]+ kB[Y2] = kB[Y2]
[X˙2] = −kE[X2][X3]+ kE[X1][X3]	= kE[X3]([X1] − [X2]) [X˙3] = −kE[X1][X3]+ φ

[Y˙ ] = −k [Y ][X ] − k
B[Y1]+ kE[X1][X3] = k
E[X3]([X1] − [Y1]) − kB[Y1]

[Y˙ ] = −k [Y ][X ] − k
B[Y2]+ kE[X2][X3] = k
E[X3]([X2] − [Y2]) − kB[Y2]



Figure 4. An example of a site tree generated by the basic model; with our simple branching steps, we can have nodes with an s6 bond and no s4 bond.



Figure 5. A site tree x over Σ; s6–s1 bonds are indicated in red; no leaf can induce a branching, in other words αB(x)= 0.


Figure 6. Each node is a pattern and an arrow represent a dependency in the fragmentation labelled by the rule and coloured green if it is an activation and red if an inhibition.

Figure 7. The evolution of the BE ratio starting in the E-regime. Initial conditions are [X1]= [X2]= [Y1]= 1, [Y2]= 0, kE = kB = 1, φ = 10, and [X3] = 50.

with φ the external flow of G. Note that [X1] ≥ [X2] ≥ [Y1] ≥ [Y2].
Note that {X1, X2, X3, Y2} is already closed, but we also need Y1 to obtain κ. This can be visualised with the rule-labelled dependency diagram shown in Fig. 6. With initial conditions: [X1]= [X2]= [Y1] = 1, [Y2]= 0, kE = kB = 1, φ = 10, and [X3]= [G] = 50, the initial BE ratio is κ = kB[Y1]/kE[X1][X3]= 1/50 well in the extension regime and Fig. 7 shows its evolution and asymptotic convergence to
a more balanced regime.

Aside on the system of differential equations
The advantage of working with a system of differential equations is not just that of obtaining a coarse-grained and therefore more efficient representation of the system. One can also take the opportunity of using techniques from qualitative dynamical

systems. For instance, one can compute the Jacobian of F for X˙
system above:
= F (X) the ODE

⎛	0	0	0	0	kB	⎞
⎜ kE[X3]  −kE[X3] kE([X1] − [X2])	0	0	⎟
JF = ⎜−kE[X3]	0	−kE[X1]	0	0	⎟
⎜ kE[X3]	0	kE([X1] − [Y1]) −kB − kE[X3]	0	⎟
⎝	0	kE[X3]  kE([X2] − [Y2])	0	−kB − kE[X3]⎠
and verify that the Thomas necessary condition for the existence of an oscillation is satisfied [15]. Such oscillations might be one of the sources of the alternating micro- structure of starch. We can also compute the time derivative of our BE-ratio:

k	[Y1]
[Y˙ ]
[X˙ ]
[X˙ ]

κ˙ =
 B ·
kE


[X1][X3]
(   1
[Y1]
  1
[X1]
  3 ) [X3]

Note that a serious modelling effort of this system, which we intend to pursue in later work, will need to take into account the actual mediation by enzymes and the saturation effect for extension and branching. This is all very interesting, but adding rule D creates countably many new fragments, which means that to do the kind of analysis (e.g. of the ratio κ) we have suggested one would have either to work in a regime where deletions are negligible, or else deal with an infinite system of differential equations. If one chooses the latter more theoretical option, it becomes even unclear how to describe these equations. This question is what we address in the next section.
Analysis of BED fragmentations
The goal of this section is to characterise simply the set of fragments of any BED rule set on directed trees. We suppose we are given a starting observable S and want to describe the set F(S) of fragments generated by S.
As said, adding deletions changes things dramatically in that fragmentations become infinite in general. In fact, even with just Es and Bs it is sometimes infinite as we will see. As we will also see, unless one is ready to ask very specific constraints, chains are not closed under fragmentation; specifically, the right glueings on D described below allow branching on any free site, and B glueings will generate such sites. So one strong conclusion of this section is that the simple BE fragmentation space, which we have studied above, is somewhat atypical and far from documenting the complexity of the general problem.

Before we look at the fragment-generation rules, we have to fix some notation and conventions. We will present F(S) by using rules acting on partial directed trees. The interpretation of these generative rules is that we can apply them in any context, and the claim is that F(S) is the (smallest) set of trees obtained by repeatedly applying these rules until a (smallest) fixed point is reached. It turns out that these rules are almost Kappa rules except for two facts: 1) one is allowed to add absent sites in the action of rules, and 2) one can test for the absence of speciﬁc sites. Specifically, we will use the notation ¬x to mean that a site x is not present in the agent interface it is matched to. Clearly, this addition to pattern matching is only useful when matching against partial objects. When matching against complete objects, by definition all sites are present as in their full interface, and a ¬x clause is never satisfied, unless x is not in the node interface in which case it is always satisfied. Implementation-wise, this is a minor generalisation which changes little to the matching engine and could be of direct modelling interest, e.g. for modelling protein cleavage.
Using this variant of Kappa, we now present our generative rules. For each rule type, the lhs glueings are presented first (with a − superscript) and the rhs ones second (with a + superscript). By convention, we present for each rule and side the generative rules in the order of increasing relevant intersections. So-called self-glueings where the intersection of the fragment and the lhs component is the component itself, and therefore the fragment under glueing is already big enough relative to that glueing, are not shown. They do not generate new variables in the final ODE (but, they do generate new terms). In each case the rhs of the generative rule is the lhs of the rule of interest, by definition of a glueing.
Here are the generative rules indexed by BED rules over Σ.
E−(s, i, t, j): (¬i, t)	⇒ (s!0), (i!0, t), (j, σ(j))	co-grow
E+(s, i, t, j): (¬i, t!1), (j!1, σ, ¬σ′)	⇒ (s!0), (i!0, t), (j, σ(j))	co-grow-and-cut-leaf
E+(s, i, t, j): (s!0), (i!0, t!1), (j!1, σ, ¬σ′) ⇒ (s!0), (i!0, t), (j, σ(j))	cut-leaf

D−(s, i, t, j): (¬i, t!1), (j!1, σ, ¬σ′)	⇒ (s!0), (i!0, t!1), (j!1, σ(j)) co-grow-and-leaf completion
D−(s, i, t, j): (s!0), (i!0, t!1), (j!1, σ, ¬σ′) ⇒ (s!0), (i!0, t!1), (j!1, σ(j)) leaf-completion
D+(s, i, t, j): (¬i, t)	⇒ (s!0), (i!0, t!1), (j!1, σ(j)) co-grow-and-grow leaf
D+(s, i, t, j): (s!0), (i!0, t)	⇒ (s!0), (i!0, t!1), (j!1, σ(j)) grow-leaf

1
2
1
2
3
If we have a rule r of the BED class, we write Γ(r) for the set of generative rules associated to r.
Let us discuss each rule in turn.
First, we see that E rules generate (j, σ(j)), a complete leaf of type j, as a fragment. To simplify the reasoning below, we will assume hereafter that all com- plete leaves are in the current fragmentation. This is without real loss of generality because any application of the E rules will add them, and apart from degenerate

examples, E rules will always apply to the fragment S of which one is computing the fragmentation F(S).
The rule E— “co-grows” an input-less node if this node has an extensible free output, and co-grows the witness of that extension (the term co-growth comes from the fact that the tree is growing by the root); it generates also a complete leaf of type
j. As all of the above rules bearing a ¬i constraint on their root node, namely E—,
E+, D—, D+, this rule can only be applied at the root of a fragment. Indeed, this is
1	1	1
the only node in a fragment where there might not be an input (by connectivity of
the fragment and the fact that the reachables can only connect via inputs and are trees). We note also that the result does not depend on j (the leaf added) except for adding that leaf to the current fragment.
For E+ and D— rules, σ is any subset of σ(j) and σj = σ(j) z σ (recall σ(j) is the complete output interface of agent j); in other words, all sites of our leaf are free 5 . One could, equivalently, write (s!0), (i!0, σ, ¬(σ(i) z σ)). There is one such rule for every subset σ of σ(j).
Note that D+, D+, and D+ can generate branching if the free site s, or t, sits
1	2
on a node that already has an outgoing edge. And, as B rules can add such sites,
unless one is very particular models, the set of chains will not be closed under BED fragmentation. Branching rules induce branches in the fragments as well.
All B+ instances incorporate a ‘co-swap’, swapping from sj back to s with the creation of missing material in the fragment intersection.
Proposition 4.1 Given S ∈T (Σ), and a rule set R of the BED class over Σ, the fragmentation of S, F(S), is the (smallest) set of trees obtained as a ﬁxed point of the set of generative rules ∪r∈RΓ(r).
Proof Clearly, it is enough to restrict to glueings of one single component: this remark only applies to left glueings to E, and right ones to D which are the only cases where one has more than one component; in both cases, it is impossible to glue to two components at once as one of them is an isolated node. 6
The proof can then proceed by inspection of all possible relevant intersections of a directed tree in T (Σ) with one BED rule component (left or right). Let us consider the case of a right glueing to B as an illustration. Suppose T is a tree in T (Σ). For a glueing of T on the rhs of a B rule to be relevant, the intersection must contain one of the three sites that are modified by the rule, s, sj and i. If the intersection is restricted to s on a node u ∈ T , this means two things: 1) s cannot be present in u (else it would either grow the intersection or make it incoherent and contradict the existence of a glueing), 2) the glueing will add the missing sj and an edge to a new node at i. It remains to apply the inverse of the action of the rule and we obtain B+. The intersection cannot be limited to sj since sj is bound in B’s rhs, but it can

5 This is not a Kappa rule, and if we were to write simply (j!1, σ) it would be a wrong Kappa rule, as one could cut a non-leaf.
6 In fact, one can prove much more generally, that double glueings in arbitrary rules with components in f (Σ)), which are possible with more complex rules, would induce cycles in fragments, and are therefore unnecessary with rule classes under which f0(Σ)s is closed. A consequence is that glueings are enumerated by one point of identification (by the rigidity of site graph embeddings).

be limited to (sj!1), (i!1) which gives the second case, and finally the intersection can contain the entire rhs which gives the third and last case. 2

Exercise in composition
The reﬁnement of leaf completion, the rule D—(s, i, t, j) where the fragment has a co-edge (s, i), can be simulated (assuming j-leaves are in the current fragmentation) by a combination of E+(s, i, t, j) and D+(s, i, t, j):
2	2
+	(s!1), (i!1, t!0), (j!0, σ, ¬σj)

E2 (s, i, t, j)
(s!1), (i!1, t)
cut-leaf

D+(r, h, s, i)	grow-leaf
2	(s!1), (i!1, t!0), (j!0, σ(i))
Similarly, E+(s, i, t, j) and D+(s, i, t, j) simulates D—(s, i, t, j). So from the strict
1	2	1
point of view of which fragments are generated, there is never a need to take into
account the D— rules. They do come into play to compute the differential system though. We will use this remark to simplify our reasoning below.

Divergences
It is easy to generate countably many fragments by using the simple D+ rule. For the refined case, one can use any periodic sequence of D+(sn, in, sn+1, in+1) rules. But in fact, divergent fragmentations can be obtained even without using the D rule, and using only E—, and B+ as follows:
E—(s ,i ,s , ) 	(s0)	

1  1	0
(s1), (i1,s )

B+(t ,s ,i ) 	1	1	0	

2	1	1  1
(s , t1), (i1,s )

E—(s ,i ,s , ) 	1  1	1	0	

2  2	1
(s2), (i2,s , t1), (i1,s )

B+(t ,s ,i ) 	2	2	1  1	1	0	

2	2	2  2
(s , t2), (i2,s , t1), (i1,s )

2  2	2	1  1	1	0
For this to work, however, one needs to be able to swap to a site that one can also co-extend. This would not be the case with our earlier sugar polymers exam- ple (previous section) even with volume branching since one swaps away from the edges generated by E rules. Indeed the fragmentation of the volume variant without deletion is finite in this case.

The complexity of F(S) in the ED class
Here we address the next important question which our first result leaves open, namely that of the complexity of the fragment set generated by an observable S.
Lemma 2 Let S be a tree in T (Σ) and R be a rule set of class ED, any T ∈ F(S) can be written as T = e ◦ T1 ◦ T for some sequence T of complete trees in T0(Σ), and e either empty or a rootless edge with one output site, and some T1 ≤ S.

Proof First, we do not need to consider rule D—, D— as they can be simulated.
1	2
Suppose now that S has an input i (necessarily free) in its root interface. Then none
of the remaining co-growth rules E—, E+, and D+ can be used. Remain E+, and
1	1	2
D+. Applying D+, and then E+ at the same node is the identity transformation.
2	2	2

So one can assume that all E+
cut-leaf rules are done first. This gives T1 ≤ T

by definition, and the remaining (optional) rule applications of type D+ define the
substitution vector T .
Consider now the case where S’s root, u, does not have an input. Then one can use rules E—, E+, and D+ at u. A careful inspection shows that all cases can be
1	1
traced back to the E— one. For E+ the leaf cut could have been cut by E+ and
1	2
this only changes the definition of T1 and we are back in the E— case. For D+, the leaf grown can be grown later by D+ after co-growth, so one can apply E— directly without changing the above decompositions T1, T . Remains E— which co-grows by adding an edge to u’s input (and adding that input at the same time) from a new root u—. That new root can support no further rewrite from E—, and D+ as u— has no free site. It can support an application of E+ but for this u has to be a leaf in T1. In which case T = e = (s!0), (i!0, t) a shape which is fixed under the action of E+ and we conclude with T1 the empty tree. 2
Proposition 4.2 Let S be a tree in T (Σ) and R be a rule set of class ED, whether
T ∈ F(S) is decidable.
Proof Suppose again S has an input at the root. Then T must have one as well. One can then enumerate the decomposition of T as T1 ◦ T , which is easily done as there are finitely many T1s such that T1 ≤ T . For each decomposition, it remains to see if R does contain enough rules to take the necessary E+, and D+ steps as in
2	2
the proof above.
If S has no input at the root. Then T should have none either. One can then try to decompose T = T1 ◦ T as above, or T = e ◦ T1 ◦ T for some edge e if S’s root has a free site, or barring that T = e ◦ T j for a complete T j; all of the above decompositions are easily enumerated and tested against R, as explained in the proof of the preceding lemma. 2

It follows immediately that deciding whether a given monomial is in the differen- tial system associated to S is decidable. Clearly, the decision procedure delineated above could be made more efficient. The style of proof might extend to cover the B case but we have not done it yet.

Truncation
Now that we know that most fragmentations are infinite and we have found a way to describe them compactly, the next step is to understand how one can truncate them. We will not address this question in the context of this preliminary investigation but we can work out a consistent truncation for a simple divergent fragmentation

for the ED system:

A(y)

−E→ A(y1), A(x1, y)

A(y1), A(x1, y) −D→ A(y)
Suppose the initial state is a chain with n links (if n = 0 this means no link and exactly one free A(x, y) node). Then the system is equivalent (because there is only ever one chain) to a continuous-time Markov chain on integers, namely, n →ke n+1, and n +1 →kd n. It is easy to verify that this chain has a probabilistic equilibrium which is a geometric distribution with α := kE/kD which we now suppose.
Set F0 := A(y), Fn := A(y1),..., A(xn, y) for n ≥ 1. Suppose we want to compute the average number of nodes in the chain. We take as our unique seed A() and get the following fragmentation:
A˙()	= ke[A(y)] − kd[A(y1), A(x1, y)]	= keF0 − kdF1 F˙n+1 = ke(Fn − Fn+1) − kd(Fn+1 − Fn+2)
So, F(A()) is infinite, and we get a simple recurrence for the associated countable ODE system, E (A()). That E is countable is not surprising because Fn =1 iff the chain is of length ≥ n.
Interestingly we can truncate this system at stage n +1 in two ways:

F˙n+1 = keFn − kdFn+1
F˙n+1 = keFn − (ke + kd)Fn+1
As can be seen in Fig. 9b the second truncation, which is purely syntactic (we set to zero the fragments we do not want) is worse than the first one in Fig. 9a compared with the true stochastic simulation given Fig. 8.

















Figure 8. Average and standard deviation for the number of As in the chain from 500 stochastic simulations, with a chain of length 1 as initial state. Rates ke and kd are set to 2 and 1 initially, then ke is set to 1 at time 100, and kd to 2 at time 200.













(a) Truncation 1	(b) Truncation 2
Figure 9. Numerical integration of truncations 1 and 2 up to F10, F50, and F200. Rates and initial states are as in the stochastic case. The quality of the approximation for truncation 2 degrades clearly for F50 compared to truncation 1.



Conclusion
We have defined a simple but expressive class of Kappa rules operating on directed polymers and which generates a type of coarse-graining called fragmentations, which lead in general to infinite ODE systems. We have shown on an example that such coarse-graining can be invaluable in the study of the dynamics of our ideal tree polymers. We have also captured the generation of fragments (the variables featuring in the coarse-grained ODE system) in a simple set of rewrite rules which use an extension of Kappa to the manipulation of partial objects (trees in our case). Finally we have shown that the ED class generates decidable fragmentations.
There are many questions this first investigation suggests. For one thing, can we decide the BED class? Can we replay this analysis with a larger rule class? Here one has to be a bit careful as it is easy to map Turing machines as simple systems of local rules and possibly the fragmentation of an observable could reveal information about termination.
But perhaps the most important question before one moves to a larger class is that of how to define a truncated version. Decidability should ensure that one can write syntactic truncations but as we have seen they might be entirely useless because they fail to propose consistent boundary conditions. Dually, one would like an appropriate version of Kurtz theory [8] which explains why truncations are sometimes working very well as approximations.
Finally, there are questions related to the algebraic aspects of the fragmentation expansion. For one thing, one would like to know in which generic rewriting universe the operations underpinning the construction of the generative rules are possible and for what specific rule class. Another point is that the fragmentation process as we have defined it is entirely syntactical, and will produce observables that are not all linearly independent. When that happens, there is no need to incorporate the new fragment into the current stock. So a natural question is whether we can recognise such situations and use it to simplify the above generation scheme.

References
Blinov, M. L., J. R. Faeder, B. Goldstein and W. S. Hlavacek, Bionetgen: software for rule-based modeling of signal transduction based on the interactions of molecular domains, Bioinformatics 20 (2004), pp. 3289–3291.
Cardelli, L., E. Caron, P. Gardner, O. Kahramanogullari and A. Phillips, A process model of actin polymerisation, Electronic Notes in Theoretical Computer Science 229 (2009), pp. 127–144.
Danos, V., J. Feret, W. Fontana, R. Harmer and J. Krivine, Abstracting the differential semantics of rule-based models: exact and automated model reduction, in: Logic in Computer Science (LICS), 2010 25th Annual IEEE Symposium on, IEEE, 2010, pp. 362–381.
Danos, V., J. Feret, W. Fontana and J. Krivine, Scalable simulation of cellular signaling networks, Programming Languages and Systems (2007), pp. 139–157.
Danos, V., R. Honorato-Zimmer, S. J. Riveri and S. Stucki, Rigid geometric constraints for kappa models, in: Third International Workshop on Static Analysis and Systems Biology (SASB 2012), 2012, to appear in ENTCS (Electronic Notes in Theoretical Computer Science).
Danos, V., H. Koeppl and J. Wilson-Kanamori, Cooperative assembly systems, DNA Computing and Molecular Programming (2011), pp. 1–20.
Daoud, M. and Joanny, J.F., Conformation of branched polymers, J. Phys. France 42 (1981), pp. 1359– 1371.
URL http://dx.doi.org/10.1051/jphys:0198100420100135900
Darling, R. and J. Norris, Differential equation approximations for Markov chains, Probability Surveys
5 (2008), pp. 37–79.
Deeds, E. J., J. A. Bachman and W. Fontana, Optimizing ring assembly reveals the strength of weak interactions, Proceedings of the National Academy of Sciences 109 (2012), pp. 2348–2353.
Deeds, E. J., J. Krivine, J. Feret, V. Danos and W. Fontana, Combinatorial complexity and compositional drift in protein interaction networks, PLoS ONE 7 (2012), p. e32032.
Feret, J., V. Danos, J. Krivine, R. Harmer and W. Fontana, Internal coarse-graining of molecular systems, Proceedings of the National Academy of Sciences 106 (2009), p. 6453.
Harmer, R., V. Danos, J. Feret, J. Krivine and W. Fontana, Intrinsic information carriers in combinatorial dynamical systems, Chaos: An Interdisciplinary Journal of Nonlinear Science 20 (2010),
pp. 037108–037108.
Henzinger, T. A., M. Mateescu and V. Wolf, Sliding Window Abstraction for Infinite Markov Chains, Technical report (2009).
Kapp, G., S. Liu, A. Stein, D. Wong, A. Rem´enyi, B. Yeh, J. Fraser, J. Taunton, W. Lim and
T. Kortemme, Control of protein signaling using a computationally designed gtpase/gef orthogonal pair, Proceedings of the National Academy of Sciences 109 (2012), pp. 5277–5282.
Kaufman, M., C. Soule and R. Thomas, A new necessary condition on interaction graphs for multistationarity, Journal of Theoretical Biology 248 (2007), pp. 675–685.
Murphy, E., V. Danos, J. Feret, J. Krivine and R. Harmer, Rule-based modeling and model refinement, Elements of Computational Systems Biology (2009), pp. 83–114.
Pawson, T. and P. Nash, Assembly of cell regulatory systems through protein interaction domains, Science’s STKE 300 (2003), p. 445.
