Electronic Notes in Theoretical Computer Science 116 (2005) 199–211 
www.elsevier.com/locate/entcs


Enhancing Test Coverage by Back-tracing Model-checker Counterexamples
A. Fantechi1 ,2
Dipartimento di Sistemi e Informatica Universit`a degli Studi di Firenze Firenze, Italy
S. Gnesi1 ,3
ISTI-CNR
Pisa, Italy
A. Maggiore1 ,4
AltraVeriﬁca Ltd, UK

Abstract
The automatic detection of unreachable coverage goals and generation of tests for ”corner-case” scenarios is crucial to make testing and simulation based verification more effective. In this paper we address the problem of coverability analysis and test case generation in modular and component based systems. We propose a technique that, given an uncovered branch in a component, either establishes that the branch cannot be covered or produces a test case at the system level which covers the branch. The technique is based on the use of counterexamples returned by model checkers, and exploits compositionality to cope with large state spaces typical of real applications.
Keywords: Coverability analysis, testing, modular, component-based system, compositionality


1 This work has been partially supported by the Italian Ministry of University and Research within the COFIN 2001 project ”Quack: a platform for the quality of new generation integrated embedded systems”
2 Email: fantechi@dsi.unifi.it
3 Email: gnesi@isti.cnr.it
4 Email: adriana@altraverifica.com



1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.077

200	A. Fantechi et al. / Electronic Notes in Theoretical Computer Science 116 (2005) 199–211
Introduction
Code coverage metrics, such as statement coverage and branch coverage, are largely used in testing and simulation based verification, both for software and hardware design, to measure the progress of the verification effort and to identify areas of the design where further tests are needed. Code coverage metrics report on areas of the design which were not exercised during sim- ulation. These will also include portions of code which are unreachable. A common objective of simulation based verification is that of achieving 100% justiﬁed branch coverage. The process of manually identifying the unreach- able portions of code or producing test cases for ”corner-case” scenarios is time consuming and error prone. The verification process is made more efficient by automatically and reliably establishing if a coverage goal, like the coverage of a branch in the control flow, is achievable or not. This process is the subject of coverability analysis [13]. A typical situation in which non-coverable goals can be found occurs when the unreachability is the result of constraints imposed on a component by the environment in which it operates.
In this paper we propose a methodology for coverability analysis and test case generation for uncovered branches at the system level which is based on the use of counterexamples returned by model checkers, exploiting composi- tionality to cope with large state spaces typical of real applications.
Counterexamples are one of the most useful outcomes of formal verification based on model checking [3], and have been extensively used for diagnosis of problems detected in the models of systems. Here a richer notion of coun- terexample is used, that is, the notion of ”counterexample automaton”, which expresses all finite linear counterexamples of a given formula on a given model. The paper is organized as follows. Section 2 introduces the proposed tech- nique in general terms. Section 3 introduce the framework (formalism, logic and tools) used in our proposal and describes by means of an example the
method. The complexity of the method is then discussed in 4.

The proposed methodology
The basic principle
The methodology we propose to check coverability and derive test cases from uncovered branches of a system is based on the following principles.
We suppose that the system can be modeled as a finite state Labelled Transi- tion System (LTS) [12], and that the testing process is able, through proper tools, to provide both the coverage measure and information about the un-

Starting from each uncovered branch, we build a temporal logic formula expressing the property: ”the uncovered branch can never be reached”.
We apply a model checker to the LTS which models the system, to check the given temporal logic formula on the model: if this returns TRUE, the branch cannot be covered.
Otherwise, we ask the model checker for a counterexample, which is a path that exercises the uncovered branch: this path contains information about the input needed to exercise it - that is, the sought test case.

Compositionality
This apparently simple process is however complicated by the fact that real applications have very large state spaces, and hence model checking becomes soon unfeasible. The methodology we propose exploits compositionality to address this problem, as follows.
We assume that the system is composed of a chain of modules (see Fig. 1), and that the uncovered branch we want to address can be localized in the inner module S0. Note that this assumption is less restrictive than what can appear at a first sight: indeed, a system where components interact with a more complex structure can be sliced in modules according to this assump- tion, by grouping more components in a single module (this is why in the following we refer to ”modules” rather than to ”components”); moreover, this structure is typical of the client-server interaction paradigm.
We apply the process described in sect. 2.1 to the module S0, obtaining a path which shows which inputs the module needs to exercise the uncovered branch. We assume that such inputs to S0 come, as outputs, by the previous module S1.
From this sequence of outputs of S1, we then elaborate a temporal logic formula φ1 expressing the property: ”it is never possible to produce such an output sequence”.
We apply the model checker on the model of the module S1 to check the formula φ1: again, this should return FALSE (if not, again, the sequence of outputs of S1 is unfeasible and hence the uncovered branch in S0 is not reachable).
We ask the model checker for a counterexample. This counterexample is a path of S1 which gives the output sequence that exercises the uncovered branch in S0. This path also contains information about the input needed to exercise it.


The system being structured as a chain of modules, each one producing input for the following one and receiving the output of the previous one, we can repeat the application of the process above to each module encountered. The final counterexample, produced on Sn is actually the sought test case for the interface of the module Sn, which when given as input to Sn causes the intermediate counterexamples to be given as input to the next modules, which finally causes the uncovered branch in S0 to be exercised.



Sn	Sn-1
...	S2
S1	S0



Fig. 1. A chain of modules


Coping with false counterexamples
It may be the case that the single counterexample trace returned by the method above for a given module does not correspond to any feasible path of the previous module in the chain. This does not mean that no test case exists to cover the uncovered branch. Actually, the model checker has pro- duced a single counterexample trace, which has shown to be not executable under the input sequences that can be provided by the previous module. We need therefore not to extract a single counterexample, but all the possible counterexample traces: actually, the number of the possible counterexample traces may be infinite. We are interested therefore to a finite representation of the possible counterexamples, and this leads us to the notion of “coun- terexample automaton”[8]. A counterexample automaton for a LTS A and a formula φ is an automaton which recognizes the language of all finite linear counterexamples of φ on A.
As a next step, from the counterexample automaton we need to extract a formula expressing “there exists in the model no path with a sequence of ac- tions which is recognized by the counterexample automaton”. In the following we will also refer to this formula as “counterexample formula”.
At this point, we can pass to model check the next module for satisfaction of this counterexample formula, in order to obtain a new counterexample automaton and then a new counterexample formula for the next module, and so on, repeating this process until we arrive at the borders of the system, that is, the last module, for which any linear counterexample provides a test case that is the desired test case. This case is to be used directly to test the whole

module chain, and it will cover the originally uncovered branch.



The overall test case generation procedure
The overall approach can be described by the following procedure, the details of which will be discussed in the next section by means of a running exam- ple, and with reference to a particular modeling formalism and verification environment.
We assume a chain structure such as that represented in Figure 1: Gi the set of common actions between Si and Si+1. φi is the temporal logic formula that is checked at the i-th step. φ0 will therefore be the formula expressing: ”the uncovered branch can never be reached”. The procedure for test cases generation is the following.

procedure testcasegen(φ0, S0)
if MC(φ0, S0)= true then "unfeasible path" else AC0 := AC(φ0, S0)
φ1 := FCG0 (AC0)
for i := 1,n do
if MC(φi, Si)= true then "unfeasible path" else
ACi := AC(φi, Si)/Gi−1 ACi−1
if i /=n then φi+1 := FCGi (ACi)
"any path of ACi is a test case for the system"
Where the following are auxiliary operators:
MC, which model checks a formula on a LTS, giving a boolean result
AC, which calculates the counterexample automaton from a formula and a LTS,
FC, indexed on a set of communication actions, which calculates the char- acteristic formula of a LTS, relative to the given set of actions,
A/GB, an indexed synchronization operator used to filter out spurious coun- terexamples.

Feasibility of the approach with JACK
In the following, in order to show the feasibility of the approach, we describe the steps of the methodology by applying it on a running example, which has been developed adopting the editing tools and the explicit model checker AMC included in the integrated verification environment JACK [1] 5 . Hence, we inherit from JACK the formalisms in which models are described (Labelled Transition Systems) and the logic in which properties can be described, namely ACTL (Action-based Computation Tree Logic) [7], which is an action-based version of the branching time temporal logic CTL [3].

Labelled Transition Systems
We use the graphical notation of Labelled Transition Systems (LTSs) and networks of LTSs inherited in JACK from Autograph [14].
An example of a LTS is reported in Figure 2. The initial state of the LTS is represented by a double circle and labels are associated to edges representing transitions of the LTS.

Fig. 2. The graphical specification of an example automaton (Mod0)

To express synchronous communication between two LTSs we use the graphical notation of networks (Fig. 3). A process represented by a box

5 Detailed information about the environment are available at http://fmt.isti.cnr.it/fmt- tools.htm


is said to be a network and the ports at the border are its places of inter- connection. A box is actually an abstraction of a LTS. If two networks are drawn at the same level, they can synchronize via the actions they execute by linking the corresponding ports. In this case the actions executed at the linked ports are no more observable, and the silent τ action is shown when they are executed.






?f


Fig. 3. An example network

The logic
We use in the following a subset of the ACTL logic (Action-based Computa- tion Tree Logic) [7], which is an action-based version of the branching time temporal logic CTL [3]. Formulae of the kind: ”the uncovered branch can never be reached” and “there exists no path with a sequence of actions rec- ognized by the counterexample automaton” are definable within this ACTL subset. Limiting to formulae of these kinds allows the notion of counterexam- ple itself and the counterexample automaton to be defined in a much more accurate and effective manner.
We can observe that all the formulae that interest us are of the kind: ∼ φ, where ∼ is the negation operator, and φ is an existential formula.
The formulae ψ we will use are hence defined according the following syn-
tax:
ψ ::= ∼ φ
φ ::= φ|φ  | φ ⇒ φ | EX{act} φ | EGφ | EFφ | E[φ{act}U {act}φ]
φ formulae form a subset of the positive existential fragment of ACTL,
including the propositional disjunction and implication, the EX existential next operator (”there exists a next state reachable with an action act and which satisfies φ”), the usual existential EG always, EF eventually and EU action-indexed until operators. We refer to [7] for the formal definition of the previous operators.
Since we use the negation only at the beginning of a formula, counterex- amples are actually ”witnesses” [4] of the corresponding positive formula. It can be seen that all the formulae of kind ψ, when not satisfied on a LTS,


admit linear counterexamples; correspondingly, φ formulae, when satisfied on a LTS, admit linear witnesses.
A test case generation example
We show the overall test case generation procedure by means of a simple example, a system composed by two modules, as represented by the network in Figure 3. The modules Mod0 and Mod1 are defined respectively by the LTSs in Figures 2 and 4.

Fig. 4. The graphical specification of the module Mod1
We assume that a testing activity has not covered the branch labelled by the action ?e, (after ?a and ?b) in Mod0.
We modify the LTS of Mod0 by adding a transition just after the uncovered branch, labelled with the fresh action !k (Figure 5, left)
mula:               ∼          EFEX{!k}true The property: ”the action k is never possible” is represented by the for-
Applying the model checker AMC to verify this formula on Mod0 we ob-
for the formula EFEX{!k}true . A witness automaton for a LTS A and a tain, as expected, a negative answer. We then generate the witness automaton formula phi is an automaton which recognizes the language of all finite linear
witnesses of phi on A. The algorithm that extracts the witness automaton from the labelling of the states produced by the model checker, works on the



Fig. 5. Marking uncovered branch in Mod0. − Counterexample automaton AC0
labelling computed by an explicit model checker during the successful check of φ, and proceeds by visiting the portion of the state space of A which is labelled by sub-formulae of φ; the visit is driven by the structural analysis of the formula itself, hence it is terminated when the leaves of the formula are reached (notice that for the used logic, the leaves are always the true sub- formula). If needed, A is unfolded if a sequence of actions in φ matches with a loop in A. The visit is implemented by a depth-first search by recursion.
of the formula: ∼ EFEX{!k}true and is represented in Figure 5, right. The automaton AC0 we obtain is therefore the counterexample automaton
We need now to provide a formula expressing “there exists no path with a
sequence of actions recognized by the counterexample automaton”. This can be achieved by giving the characteristic formula of the automaton [2,15], that is, a formula which describes completely the automaton itself. Actually, we need only the existential part of the characteristic formula, and we adopt the method shown in [9] to give an ACTL characteristic formula, exploiting the notion of implicit ﬁxed point, which requires no explicit fixed point operators.
Back to our running example, from the automaton AC0 we derive the formula FCG, with G = (a, b, c, d, e):
<<!a>><<!b>>((<<!e>>true) |
(EG ( EX{!c} true => (EX{!c}<<!d>><<!e|!c>>true))))
where << act >> is used as a shorthand for: E[true{∼!act1& ∼!act2& ... & ∼

!actn}U {act}φ]
In the second step we apply then the model checker to the Mod1 LTS and
to the formula:
~<<!a>><<!b>>((<<!e>>true) |
(EG ( EX{!c} true => (EX{!c}<<!d>><<!e|!c>>true))))
and we then obtain the counterexample automaton AC1 (Figure 6).


Fig. 6. The counterexample automaton AC1
The counterexample automaton AC1 shows a loop with !b and ?f actions, which would correspond to a cycle of ?b on Mod0, which is not feasible; only a single ?b action is indeed performed by Mod0 at that point. This means that AC1 generates false counterexamples which should be avoided.
This phenomenon is due to the fact that, within ACTL, it is not possible to predicate a complex formula on a path without using state formulae, each of which should be individually quantified. Hence it is not possible to express a predicate of the type ”there exists a path having a complex behaviour” but only ”there exists a path, which, after a simple behaviour, reaches a state from which there exists a path....”. This means that when computing the characteristic formula we introduce spurious traces.
In order to cut this kind of false counterexamples we should consider only the paths of AC1 that correspond to paths of AC0. This operation is essentially a synchronization operation between AC0 and AC1 on the common actions. We will use for this operation the notation AC1/GAC0, where G is the set of common actions, in our case (a,b,c,d,e).
Actually, after this operation, we still need to cut away all the terminating branches not ending in a final state. If this is done in the example, the operation produces the automaton represented in Figure 7.
The obtained counterexample reduces to the path ?g; !a; !b; !c; !d; !e., from which we extract the input sequence formed only by ?g, which is the test case that we were looking for.
Notice that producing a single linear counterexample at the first step,




Fig. 7. The automaton AC1/GAC0
instead of the counterexample automaton AC0, could have produced at the end the path: ?g; !a; !b; !c;, which is actually the shortest counterexample, but is not feasible in the Mod1 LTS.
This process can be repeated, as long as we have modules connected in a chain; for each intermediate module the counterexample automaton and formula should be calculated and the latter should be checked on the next module. For the last module the counterexample automaton, once false coun- terexamples have been filtered out, defines a set of test cases, each covering the originally uncovered branch.

Complexity of the procedure
The following elements add up to the computational complexity of the proce- dure:
Model checking (MC) is linear with the product of state space size times the length of the formula (that is, the maximum nesting of operators);
The length of characteristic formula (FC) is linear in the size of the au- tomaton. Linear as well is the complexity of the characteristic formula generation;
Synchronization of automata (/G) has a complexity of at most the product of the sizes of the automata; here it is applied to two successive counterexample automata;
Counterexample automata (AC) tend to be small, since they generate new test cases: if we assume that the approach is applied only when the ”eas- iest” test cases have already been exercised and only ”corner-case” test cases remain to be discovered, the counterexample automata is a small sub- automaton of the considered module (not really a sub-automaton, because some loops may be unfolded depending on the length of the formula).
The model complexity is anyway attacked compositionally

The order of complexity is therefore n∗m∗c, where n is the number of modules in the chain, m the (average) state space of a module, c the (average) state
better than n ∗ m ∗ m, due to the generally low dimensions of the counterex- space of a counterexample automaton. Note that this may be substantially ample automata, especially for ”corner-case” counterexamples.


An alternative to the above procedure could be defined using the explicit synchronization of two successive modules. We claim that, of the two, the procedure which uses the characteristic formula plus model checking has the minimal complexity achievable based on explicit state space enumeration.

Conclusions and Further Work
We have detailed the proposed approach using a single running example, and particular formalisms and verification tools. Nevertheless, we believe that the approach has a general validity. Work is in progress on implementations of the approach both using explicit model checking (as shown in the paper) and BDD-based symbolic model-checking, but still focusing on LTSs and on action-based temporal logics.
It seems however reasonable that the approach works as well with a state based formalism (Kripke Structures) and a state based temporal logic (such as CTL). This needs to be verified: the very definition of counterexample, witness and counterexample automaton is actually highly sensitive to the logic used and to the assumptions on the models.
A result which is related to our work is the definition of more expressive tree-like counterexamples for Kripke Structures and CTL; such counterexam- ples are used as a support to guide a refinement technique [5]. The main difference with respect to our approach is that a tree-like counterexample is in its entirety a proof that the formula is not valid. Our counterexample automa- ton gives instead the set of all linear counterexamples, each of which can be taken separately as a traditional counterexample. A recent evolution of tree- like counterexamples is represented by proof-like counterexamples [11], used to extract proofs for the non satisfiability of a formula over a model. Closer to our approach is the multiple counterexamples generation of [6,10], which generates all the counterexamples to a given length, expressed as a single counterexample trace annotated with possible values of binary variables.

References
A. Bouali, S. Gnesi, S. Larosa. The integration project for the JACK environment. Bulletin of the EATCS, n. 54, October, 1994, pp. 207-223.
M.C. Browne, E.M. Clarke, O. Grumberg: Characterizing Finite Kripke Structures in Propositional Temporal Logic, Theoretical Computer Science, 59 (1,2), 1988, pp. 115-131.
E.M. Clarke, E.A. Emerson, A.P. Sistla. Automatic Verification of Finite State Concurrent Systems using Temporal Logic Specifications. ACM Transaction on Programming Languages and Systems, vol.8, n. 2, 1986, pp. 244-263.
E. Clarke, O. Grumberg, K. McMillan, X. Zhao, Efficient generation of counterexamples and witnesses in symbolic model checking, 32nd design Automation Conference, DAC’95.


E.M. Clarke, S. Jha, Y. Lu, H. Veith. Tree-like Counterexamples in Model Checking. 17th IEEE Symposium on Logic in Computer Science (LICS’2002), pp. 19-29.
F. Copty, A. Irron, O. Weissberg, N. Kropp, G. Kamhi. Efficient Debugging in a Formal Verification Environment, CHARME’01, LNCS 2144, pp. 275-292,Springer-Verlag, 2001.
R. De Nicola, F.W. Vaandrager. Actions versus State Based Logics for Transition Systems. Proc. Ecole de Printemps on Semantics of Concurrency, Lecture Notes in Computer Science vol. 469, Springer, Berlin, 1990, pp. 407-419.
A. Fantechi, S. Gnesi, G. Ristori. Counterexample and Witness automata ISTI Technical Report, 2004.
A. Fantechi, S. Gnesi, G. Ristori. Modelling Transition Systems within an Action Based Logic. IEI Technical Report, 1996.
M. Glusman, G.Kamhi, S. Mador-Heim, R. Fraer, M. Vardi, Multiple-Counterexample Guided Iterative Abstraction Refinement: An Industrial Evaluation. TACAS 2003, LNCS 2619, pp. 176-191, Springer Verlag, 2003.
A. Gurfinkel, M. Chechik. Proof-Like Counter-Examples, TACAS 2003, LNCS 2619, pp. 160-
175, Springer Verlag, 2003.
R. Milner. Communication and Concurrency. Prentice-Hall International, Englewood Cliffs, 1989.
G. Ratzaby, S. Ur, Y. Wolfsthal, Coverability Analysis Using Symbolic Model Checking, CHARME 2001, LNCS 2144, Springer-Verlag, 2001.
V. Roy, R. De Simone. AUTO and Autograph, in Proceedings of the Workshop on Computer Aided Verification, LNCS 531, 65-75, 1990.
B. Steffen, Characteristic Formulae, Proceedings 16th ICALP, Lecture Notes in Computer Science, vol. 372, pp.723-732, 1989.
