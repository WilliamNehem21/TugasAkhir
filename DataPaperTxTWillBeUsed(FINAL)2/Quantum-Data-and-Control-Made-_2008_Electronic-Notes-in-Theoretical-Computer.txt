	Electronic Notes in Theoretical Computer Science 210 (2008) 85–105	
www.elsevier.com/locate/entcs
Quantum Data and Control Made Easier
Michael Lampis1,2 Kyriakos G. Ginis3 Michalis A. Papakyriakou4 Nikolaos S. Papaspyrou5
School of Electrical and Computer Engineering National Technical University of Athens
Athens, Greece.

Abstract
In this paper we define nQML, a functional quantum programming language that follows the “quantum data and control” paradigm. In comparison to Altenkirch and Grattage’s QML, the control constructs of nQML are simpler and can implement quantum algorithms more directly and naturally. We avoid the unnecessary complexities of a linear type system by using types that carry the address of qubits in the quantum state. We provide a denotational semantics over density matrices and unitary transformations, inspired by Selinger’s semantics for QPL. Our semantics leads naturally to an interpreter for nQML, written in Haskell. We also explore the extension of nQML with polymorphic higher-order functions.
Keywords: Functional quantum programming language, type system, denotational semantics.


Introduction
In the years following the discovery of Shor’s factoring algorithm [11] and Grover’s algorithm for database search [5] the field of quantum computations has attracted much scientific interest. Unlike classical algorithms, quantum algorithms are almost invariably studied at a low level, involving quantum circuits and their properties. The fact that reasoning about quantum circuits is no easier than reasoning about their classical counterparts has given rise to quantum programming languages, that is, languages that allow programmers to implement quantum algorithms and make use of the added power of the quantum computational model, while respecting its special restrictions. In this paper we present such a language named nQML.

1 Research supported in part by the European Social Fund (75%) and the Greek Ministry of Education (25%) through grant “Pythagoras” of the Operational Programme on Education and Initial Vocational Training.
2 Email: mlampis@cs.ntua.gr
3 Email: kyrginis@softlab.ntua.gr
4 Email: mpapakyr@softlab.ntua.gr
5 Email: nickie@softlab.ntua.gr

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.020

Our main focus in the design of nQML is to give programmers sufficient expres- sive power to implement quantum algorithms easily, while preventing them from breaking the rules of quantum computation. nQML is a high-level functional lan- guage based on the concept of “quantum data and control”. It includes constructs which allow any unitary transformation to be expressed as a program in nQML quite naturally, more or less using the same notation that is used by the designers of quantum algorithms. It also permits quantum measurements to be carried out at any point during the execution of a program.
The relative ease of use comes at the cost of putting aside a number of important practical issues, such as the existence of imperfect quantum hardware, the need for quantum error correction and the fact that every quantum program will eventually have to be implemented as a quantum circuit using only a finite set of quantum gates and, therefore, some of the unitary transformations that nQML allows will have to be approximated. Similar problems were a source of concern for the founders of the classical programming model many decades ago. Fortunately they have been resolved and their solutions have been abstracted in such a way that people who use modern high-level programming languages do not need to know anything about them. We believe that the same can and must be done for the quantum program- ming languages of the future and adopt the approach that such issues should be tackled not by the designer and users of a quantum programming language, but by the architect of a quantum computer, the designer of its operating system and, to a lesser extent, the designer of the compiler.
nQML admits a simple type system and denotational semantics. By simple, we mean that both use structures and techniques that are typical in the study of classical programming languages of similar size and complexity. They should therefore be easily accessible to readers with a basic knowledge of programming language semantics and an elementary understanding of the quantum computation model. The main novelty of nQML’s type system is that the type of a quantum expression conveys information which reveals the exact qubits of the quantum state in which the expression’s value resides. Qubit aliasing is allowed in such a way that the “no cloning” and “no dropping” principles are not violated. Programmers have the look-and-feel of a classical programming language, without linearity restrictions.
The denotational semantics of nQML is based on the use of density matrices to describe quantum states. The meaning of a well-typed nQML program is a function from density matrices to density matrices and describes the program’s effect on an arbitrary quantum input state. Well-typed programs which conduct no measure- ments 6 are also assigned a meaning in the form of a unitary matrix which describes the transformation they perform on the quantum state. The execution of a nQML program can be seen as a sequence of steps which affect the quantum state either by allocating new qubits, by applying unitary transformations to existing qubits or by measuring existing qubits. Our semantics leads to a straightforward implemen- tation for nQML in the form of an interpreter written in Haskell. 7 The interpreter,

6 In the sequel, such programs will be called “pure” quantum programs, for short.
7 The source code of the interpreter is available from ftp://ftp.softlab.ntua.gr/pub/users/nickie/

quite obviously, simulates quantum computations in a classical computer and takes exponential time.
The rest of the paper is structured as follows. Section 2 discusses related work. In Section 3 we describe the syntax and semantics of nQML and section 4 contains a number of examples. In section 5 we discuss how to extend nQML with a poly-
morphic type system supporting higher-order functions. Section 6 concludes with our final remarks. The appendix contains the complete formal definition of nQML.

Related work
Starting with Knill’s conventions for quantum pseudocode [6], several quantum pro- gramming languages have been proposed and an excellent survey of the emerging field can be found in [2]. Among the most notable are O¨ mer’s QCL, an impera- tive language with quantum primitives and automatic quantum scratch space man- agement [7], and Sanders and Zuliani’s qGCL, an extension of Dijkstra’s guarded command language [8]. Moreover, van Tonder has proposed a λ-calculus for higher- order quantum programs without measurements [12]. It is not clear however how this calculus corresponds to lower-level descriptions of quantum computations, such as quantum circuits.
Selinger’s QPL is a language following the paradigm “quantum data, classical control” [9]. It is functional in nature, although from a programmer’s point of view it looks more imperative than functional. QPL allows the programmer to access both classical and quantum memory and includes high-level features such as loops and recursion. Program control in QPL is strictly classical and quantum branching can only be implemented indirectly with appropriate unitary transformations. The denotational semantics of QPL is given in the form of superoperators on density ma- trices. A higher-order extension of QPL in the form of a quantum lambda calculus has also been proposed by Selinger and Valiron [10].
On the other hand, Altenkirch and Grattage’s QML is a functional language that follows the paradigm “quantum data and control” [1,3,4]. QML comes with a linear type system prohibiting implicit weakening, which would lead to implicit measurements and quantum collapse. Variables in QML correspond to wires in the produced quantum circuit and thus have to be shared implicitly when they are used in several places in a program so as not to break the “no cloning” rule. The sharing of wires is also monitored by the linear type system. The semantics of QML assigns to every well-typed program a quantum circuit. QML’s if ◦ operator implements the notion of quantum control and is the only available means of performing uni- tary transformation. The two branches of an if ◦ must be “orthogonal” quantum expressions, in order to preserve the reversibility of pure quantum computations.
The nature of our nQML is inspired from QML, the main addition being the quantum transformation construct e   x, x'.c which will be described in sec- tion 3. Its type system, although not linear, is an adaptation of Altenkirch and

papers/nqml06.code.tar.gz.

Grattage’s type system. The semantics of nQML, however, is very much in the spirit of Selinger’s denotational semantics for QPL.
The language nQML
The complete syntax of nQML is given in the following grammar. It is assumed that x is a variable identifier and λ is a complex constant. The grammar defines two syntactic classes. Quantum expressions are denoted by e; they represent quantum programs and their syntax is similar to that of QML. Classical expressions are denoted by c; they are only needed in the quantum transformation construct e
x, x'.c and they can represent two types of information: a structure of classical bits or a complex number.
e ::= x | { (λ) qfalse + (λ') qtrue } | let x = e1 in e2
|	(e1, e2) | let (x1, x2) = e1 in e2
|	if e then e1 else e2 | ifm e then e1 else e2 | |e⟩→ x, x'.c 
c ::= x | false | true | λ | let x = c1 in c2
|	(c1, c2) | let (x1, x2) = c1 in c2 | if c then c1 else c2
|	int c | c1 + c2 | c1 − c2 | c1 ∗ c2 | c1/c2 | c1  | c1 = c2 | c1 < c2
Variables in nQML are viewed as references to quantum information that is stored in a global quantum state. There are two types of quantum information: qubits and products. A new qubit is allocated in the quantum state when the superposition operator (λ) qfalse + (λ') qtrue is used, in the same way that new objects are allocated on the heap when a data constructor is used in a functional programming language. Products are introduced and eliminated with the constructs (e1, e2) and let (x1, x2) = e1 in e2. nQML also features three control constructs:
ifm e then e1 else e2: It conducts a measurement on e, which must be of type qubit. Depending on the result, it executes one of its branches. It is similar to a classical random branching, based on a toss of a biased coin with probabilities depending on the state of the qubit being measured.
if e then e1 else e2: It allows the programmer to perform quantum branching. If e, which must be of type qubit, is in a classical state, then the effect is what we would expect from ifm. But if e is in a quantum superposition, the pro- gram proceeds in a quantum superposition of both branches, most likely creating entanglement among the qubits of the quantum state.
	e   x, x'. c: A generic means of expressing any unitary transformation, which has to be relied upon when a transformation can not be easily broken down to a series of controlled operations, expressible with if . Its advantage is that, rather than forcing programmers to precompute and provide the whole unitary matrix of the transformation, whose size is exponential in the number of qubits that it affects, it allows them to express that matrix as a complex function of the input and output state of the transformed qubits. This leads to a succinct and clear expression of many useful quantum algorithms, such as the quantum Fourier transform that is described in Section 4.

In quantum pseudocode notation, all unitary transformations can be expressed in the form:

2n−1
|i⟩→ 
j=0
f (i, j) |j⟩

where f (i, j) is a function of the input state i of the quantum register and its out- put state j. The construct e  x, x'.c allows the programmers to use precisely this natural notation: the classical variables x and x' denote the register’s input and output state and the classical expression c denotes the function’s body.
From this notation, if the function f is known, the unitary matrix can be easily constructed by taking Sj,i = f (i, j). Of course, not all functions f result in unitary matrices and the type system of nQML cannot decide whether the
resulting transformation is indeed unitary. The type system of Altenkirch and Grattage’s QML is able to do that, at the expense of making the size of the program exponential and complicating the typing with orthogonality constraints.
The type system of nQML
There are two kinds of types: quantum types (τ ) and classical types (φ). For each quantum expression, the type system of nQML keeps track of the exact qubits of the state in which the value of this expression is stored. This information is stored in the types. It is used to make sure that the same qubit cannot be used twice in a transformation, thus allowing qubit aliasing without breaking the “no cloning” rule.
τ ::= qbit[n] | τ1 ⊗ τ2
φ ::= bit | φ1 × φ2 | complex
For example, an expression has type qbit[5] if its value is stored in the 5th qubit of the state.
For each quantum type τ , we define (τ ) to be the corresponding classical type; no quantum types correspond to complex. We denote by	(τ ) the size, in clas- sical bits, of the classical type corresponding to τ and by qbits(τ ) the set of the state’s qubits that are used by expressions of type τ . For example, qbits(qbit[4] qbit[2]) = 2, 4 . A quantum type τ is called pure if its representation uses distinct qubits. Notice that, in general, qbits(τ )	(τ ) , the two being equal if and only
if the type τ is pure. A quantum type environment Γ is a mapping of variables to quantum types and, similarly, a classical type environment Δ is a mapping of
variables to classical types. Γ k denotes the environment Γ restricted in such a way that it does not contain variables whose types use the state’s k-th qubit.
The typing relation for nQML is denoted by Γ; n  α e : τ ; m. More precisely, as in the type system of Altenkirch and Grattage’s QML, there are two typing relations: one for pure quantum expressions (i.e. without measurements), denoted by Γ; n  ◦ e : τ ; m, and one for arbitrary quantum expressions, denoted by Γ; n  e : τ ; m. We refer to both by allowing the superscript α to be either ◦ or empty. As the types of nQML convey information regarding the position of qubits in the quantum state, the typing relation is forced to process and propagate such information. In Γ; n ▶α

e : τ ; m, the natural number n appearing on the left side of the relation stands for the number of qubits of the original quantum state, before e starts evaluating. Obviously, for all pairs (x : τx)  Γ it must be qbits(τx)   0,...n  1 . The natural number m appearing on the right side of the relation stands for the number of new qubits, that are allocated during the evaluation of e. The final quantum state after e has been evaluated has n + m qubits and, obviously again, it must be qbits(τ ) ⊆ {0,...n + m − 1}.
The typing rules for nQML follow Altenkirch and Grattage’s QML, with the ex- ception that the type system is not linear and qubit information must be processed. For example, the typing rule for quantum superposition plans for the allocation of one new qubit and uses its position in the returned type.
|λ|2 + |λ'|2 = 1 

Γ; n ▶◦ { (λ) qfalse + (λ') qtrue } : qbit[n]; 1
(SUP)

Rules with more than one quantum expression must carefully combine the newly allocated qubits, e.g.
Γ; n ▶α e1 : τ1; m1	Γ; n + m1 ▶α e2 : τ2; m2

Γ; n ▶α (e1, e2) : τ1 ⊗ τ2; m1 + m2
(PROD)

The most complex of nQML’s typing rules are those for the control constructs. We explain two of them below. In a quantum branching expression if e then e1 else e2 the control qubit must not be used in the two branches. This restriction is necessary to simplify the semantics of if and eliminate the need for orthogonal branches. Unitary transformations which cannot easily be described as quantum controlled operations have their own dedicated construct in nQML. Notice also that the number of newly allocated qubits takes the maximum of the two branches.
Γ; n ▶α e : qbit[k]; m
Γ|k; n + m ▶◦ e1 : τ ; m1	Γ|k; n + m ▶◦ e2 : τ ; m2

Γ; n ▶α if e then e1 else e2 : τ ; m + max(m1, m2)
(IF)

The typing rule for nQML’s new construct e  x, x'.c is also straightforward. A unitary transformation is performed on the quantum bits where the value of expression e is stored. The type τ of this expression must be pure, to obey the “no cloning” rule. In the classical expression c which determines the contents of the transformation, the two variables x and x' are bound to the classical value of the expression. The type of both is C(τ ).
Γ; n ▶α e : τ ; m	pure(τ )	x : C(τ ), x' : C(τ ) ▶ c : complex

Γ; n ▶α |e⟩→ x, x'.c : τ ; m
The typing Δ ▶ c : φ of classical expressions presents no difficulties.

The denotational semantics of nQML
(TRANS)

Our denotational semantics for nQML uses density matrices for representing the quantum state. The semantic domain S(n) ⊂ C2n×2n contains density matrices. The meaning of an arbitrary well-typed expression e with a type derivation Γ; n ▶ e : τ ; m is a function of type S(n) → S(n + m); it maps an input quantum state of n

qubits to an output quantum state of n + m qubits. Pure quantum expressions that perform no measurements can be assigned unitary transformations as meanings. We
denote by T(n)  C2n×2n the domain of unitary transformation matrices. If e is a
well-typed pure quantum expression with a type derivation Γ; n  ◦ e : τ ; m, then its meaning is a unitary transformation matrix of type T(n + m). The semantics of embedding pure quantum expressions in impure quantum expressions is given below. The tensor product of A : S(n) with the matrix Δm appropriately expands the state with m new qubits which are initialized with zeroes.
EMB:	[ Γ; n ▶ e : τ ; m]](A)	=	T (A ⊗ Δm) T∗
where	T	=	[ Γ; n ▶◦ e : τ ; m]]
The use of a variable has no effect on the state, as variables are just references. How- ever, superpositions extend the state by allocating a new qubit and appropriately initializing it.
VAR:	[ Γ; n ▶◦ x : τ ;0 ]	=	In
SUP:	[ Γ; n ▶◦ { (λ) qfalse + (λ') qtrue } : qbit[n]; 1 ]	=
⎛ λ λ' ⎞

In
λ'
−λ ⎠

The semantics of the let construct, product introduction and elimination is straight- forward and very similar. In each of them, evaluation begins with the evaluation of e1 and continues with the evaluation of e2 on the new state. The impure cases are very similar. 8
LET ◦:	[ Γ; n ▶◦ let x = e1 in e2 : τ ; m1 + m2 ]]	=  T2 (T1 ⊗ Im )
where	T1  =	[ Γ; n ▶◦ e1 : τ1; m1 ]]
T2  =	[ Γ,x : τ1; n + m1 ▶◦ e2 : τ ; m2 ]]
The case of if is slightly more complicated. Evaluation begins with the condi- tion. The matrices that correspond to the two branches are calculated and their (inexistent) effect on the control bit is removed by using the auxiliary function except. Then, the two expressions are executed conditionally, with e as the control qubit. The impure case is again very similar.
IF ◦:	[ Γ; n ▶◦ if e then e1 else e2 : τ ; m + max(m1, m2) ]]	=
Tc (T ⊗ Imax(m1,m2))
where	T	=	[ Γ; n ▶◦ e : qbit[k]; m]]
T1 =	[ Γ|k; n + m ▶◦ e1 : τ ; m1 ]] T2  =	[ Γ|k; n + m ▶◦ e2 : τ ; m2 ]]

T1'
T2'
=  except(k, T1) ⊗ Imax(m1,m2)−m1
=  except(k, T2) ⊗ Imax(m1,m2)−m2

Tc = cond(k, T1' , T2' )

8 It can easily be proved that the semantics of pure and impure quantum expressions is consistent with the embedding rule. For example, the meaning is the same if EMB is applied separately to two pure expressions and then PROD is applied to the result, or if EMB is applied once to the result of PROD.

Surprisingly, the measuring conditional ifm is more straightforward. The condition is evaluated and then the corresponding qubit is measured. The auxiliary function measure returns the two density matrices that correspond to collapsing a qubit to a classical state. Then the two branches are combined. Each branch is evaluated on the corresponding result state of the measurement and their sum is the total result.
IFM :	[ Γ; n ▶ ifm e then e1 else e2 : τ ; m + max(m1, m2) ]](A)	=
B1 ⊗ Δmax(m1,m2)−m1 + B2 ⊗ Δmax(m1,m2)−m2
where	B =	[ Γ; n	e : qbit[k]; m]](A) (Bt, Bf ) = measure(k, B)
B1  =	[ Γ; n + m ▶ e1 : τ ; m1 ]](Bt ⊗ Δm1 )
B2  =	[ Γ; n + m ▶ e2 : τ ; m2 ]](Bf ⊗ Δm2 )
Finally, in the semantics of e   x, x'.c the described unitary transformation C is computed. As C only applies to the qubits used by e, it must be properly expanded to apply to the complete state.
TRANS ◦:	[ Γ; n	◦  e	x, x'.c : τ ; m]]	=  Tc T
where	Tc = expand(n, qbits(τ ), C) T	=	[ Γ; n ▶◦ e : τ ; m]]
Cj,i  =	[ x : C(τ ), x' : C(τ ) ▶ c : complex ]](ρ)
where	ρ = ρ0{x '→ valτ (i)}{x' '→ valτ (j)} for all 0 ≤ i, j < 2k, where k = |qbits(τ )|
Again, the semantics of classical expressions is standard and presents no difficulty.

Some metatheory
We start with the notion of well-formed types and environments, with respect to the current state. A type is only well-formed if all the qubit positions that it refers to exist in the state.
Definition 3.1 A type τ is well-formed in a state of n qubits, written as n ▶ τ , if for all k ∈ qbits(τ ) we have k < n.
Definition 3.2 An environment Γ is well-formed in a state of n qubits, written as
n ▶ Γ, if for all (x : τ ) ∈ Γ we have n ▶ τ .
It is then easy to prove the following theorem, which states that the types produced by the typing relation are well-formed.
Theorem 3.3 If Γ; n ▶α e : τ ; m and n ▶ Γ then n + m ▶ τ.
Proof (Sketch) By a straightforward induction on the typing derivation.	 
To prove that the denotational semantics is well-defined is a little trickier. It is only true if all constructs |e⟩→ x, x'.c define unitary transformations.
Definition 3.4 A transformation construct |e⟩ → x, x'.c with a typing Γ; n ▶◦
|e⟩→ x, x'.c : τ ; m is well-deﬁned if the matrix C in equation TRANS ◦ is unitary.

Lemma 3.5 If Γ|k; n ▶◦ e : τ ; m then the matrix [[ Γ|k; n ▶◦ e : τ ; m ]] is of the
k	k
form A ⊗ I1 ⊗ B where A : C2 ×2 , i.e. it is a transformation that leaves unchanged
the k-th qubit of the state.
Proof (Sketch) By induction on the typing derivation. Most cases are tedious and the interesting ones are IF and TRANS.	 
Theorem 3.6 If Γ; n ▶α e : τ ; m and all transformation constructs in e are well- deﬁned with their typings, then [[ Γ; n ▶α e : τ ; m ]] is well-deﬁned and:
if α = ◦, then the matrix [[ Γ; n ▶◦ e : τ ; m ]] is unitary.
if α = empty, then the function [[ Γ; n	e : τ ; m ]] maps density matrices to density matrices.
Proof (Sketch) By induction on the typing derivation. The proof uses the closure properties of density and unitary matrices. The case of TRANS is handled by the assumption. The only case worth mentioning is IF, which uses the matrices except(k, T1) and except(k, T2), where k is the qubit position of the condition. It is necessary at that point to prove that T1 and T2 are of the form A  I1  B, where A : C2k×2k . This can be obtained by the previous lemma.	 
Examples
We now present a few example nQML programs of varying complexity. We start with two useful operators in quantum programming: not and had, standing respectively for quantum negation and the Hadamard transformation. Both can be applied to any expression q of type qbit[n].
not(q)	≡ |q⟩→ x, x'. if x' = x then 0 else 1
had(q) ≡ |q⟩→ x, x'. if x then (if x' then − √1 else √1 ) else √1
These simple transformations may seem a bit awkward at first but now that we have defined them we can easily use them in conjunction with the quantum condi- tional construct to define more complex transformations. For example, controlled quantum negation of p by q can be defined as:
cnot(q, p)  ≡  if q then not(p) else p
where not(p) is defined as above.
This leads us to our first nQML program: an implementation of Deutsch’s algo- rithm. In this algorithm we are presented with a black box classical one-bit boolean function and we want to decide whether it is balanced, in which case we return 1, or constant, in which case we return 0. We assume that the unknown function is somehow included in our program and we write f (q) for the application of that function to a quantum parameter q. By using the definition of had and not given above, we arrive to the following program.
deutsch(f ) ≡ let (i, j) = ({ ( √1 ) qfalse + ( √1 ) qtrue },
{ ( √1 ) qfalse + (− √1 ) qtrue }) in

let r = if f (i) then not(j) else j in
had(i)
The program’s result is stored in variable i. This variable is used as the first operand of our branching operator, after f is applied to it. When f is a constant function and therefore f (i) has a classical value, i will be unaffected by the execution of the branching and its result after the Hadamard transform will be 0. When, however, f is balanced, i.e. it is the identity or the negation function, even though its application will have no direct effect on i, the use of i as a control bit for j’s negation means that the two variables interact non-classically.
Let us now see a few more examples that demonstrate the power of e  x, x'. c. Addition of a constant to a n-bit quantum register modulo 2n, which is typically denoted by |r⟩→ |r + c⟩ in quantum pseudocode, can be implemented as:
add(r, c) ≡ |r⟩→ x, x'. if int x' = int x + c then 1 else 0
Any other permutation of base states can easily be implemented in a similar manner. The implementation of the quantum Fourier transform for n qubits contained in register r is:
fourier(r, n)  ≡  |r⟩→ x, x'. 1/2n ∗ e2∗π∗i∗x∗x'/2n
which is derived in a straightforward way from the transform’s definition. In Selinger’s QPL, one can do the same by applying the unitary matrix S correspond- ing to the quantum Fourier transform to the quantum register r, using the construct r = S. However, unless some sophisticated language is used in combination with QPL to represent unitary transformations, the programmer has to use a precalcu- lated S and, as its size is 2n  2n, the size of the program increases exponentially. The same is true in the case of Altenkirch and Grattage’s QML, where the trans- form can be implemented by a tree of height n containing nested if ◦ branches; the size of the program is again exponential in n.
As a last example, let us see an implementation of Grover’s fast database search. Assuming that c denotes the value we are searching for, we first need to implement the query and diffusion operators.
query(q)	q	x, x'. if x = x'
then (if int x = c then	1 else 1)
else 0
diffusion(q, n) ≡ |q⟩→ x, x'. if x = x' then − 1+ 2/2n else 2/2n
Let us consider the most simple application of Grover’s algorithm: searching in a space of size 4 (n = 2 qubits). Even though O(√n) applications of the two operators
are generally needed to obtain high probability, in this special case one application is enough to produce the correct result with certainty:
grover ≡ let q1 = { ( √1 ) qfalse + ( √1 ) qtrue } in
let q2 = { ( √1 ) qfalse + ( √1 ) qtrue } in
2	2
let qs = (q1, q2) in
diffusion(query(qs), 2)

Assuming that the element we were looking for was c = 2, the Haskell interpreter that implements our semantics produces the following state (density matrix) of two qubits:
⎛ 0.0 :+ 0.0	0.0 :+ 0.0	0.0 :+ 0.0	0.0 :+ 0.0 ⎞
0.0 :+ 0.0	0.0 :+ 0.0	0.0 :+ 0.0	0.0 :+ 0.0
0.0 :+ 0.0	0.0 :+ 0.0	0.9999999999999997 :+ 0.0	0.0 :+ 0.0
0.0 :+ 0.0	0.0 :+ 0.0	0.0 :+ 0.0	0.0 :+ 0.0
where α :+ β is Haskell’s notation for the complex number α + βi. From it, we can easily verify that the correct answer was found: the register qs is in the classical state |10⟩, allowing for numerical errors.
Towards polymorphic higher-order functions
In the examples of the previous section we have used parametric expressions in nQML, such as not(q) or cnot(q, p). Such parametric expressions were used as macros: when used in another expression, not(e) is syntactically expanded by sub- stituting the expression e for q in the body of not. Macro expansion is an easy way to enjoy some of the advantages of having functions in nQML, without resorting to a more complex type system. Macros can even simulate higher-order functions, such as deutsch(f ) where f is a function from qubit to qubit, or polymorphic functions, such as add(r, c) where r is a quantum register of unknown type. They cannot, however, simulate recursive functions or currying.
In this section, we sketch a polymorphic type system for nQML to support higher-order functions. Although we do not deal with the denotational semantics of the extended language here, we believe that it is possible to extend nQML with polymorphic higher-order recursive functions, as also suggested by Selinger and Valiron [10]. The type system that is briefly presented here lays the ground for such an extension.
We adopt a very conservative extension to the syntax of nQML. Types are not visible by programmers; a type inference algorithm is used to typecheck the pro- grams of the extended language (see section 5.4). Functions take arguments of three kinds: quantum expressions, classical expressions and function names. For simplicity, we separate the three kinds of arguments in the syntax. We denote by f a function name. We also denote by →e a list of quantum expressions, by →c a list of classical expressions, by f→ a list of function names, etc. A program p is a list of function definitions, followed by a quantum expression to be computed. A function definition d determines the function’s name, the function’s arguments’ names and the function’s body.
e ::= ... | f (→e; →c; f→)
d ::= f (→x; →y; f→) ≡ e
p ::= d→; e

Types
To justify our design of nQML’s extended type system, we begin by discussing the types of the macros of section 4. A na¨ıve type system would give function not the type qbit[3]  qbit[3]. Such a type would make sense, but the function would only be useful if its argument resided in the 3rd qubit of the state. For functions to be useful, function types must be polymorphic w.r.t. the exact qubits to which they refer. A more useful polymorphic type for not would be:
not	:	∀k. qbit[k] → qbit[k]
where the variable k ranges over qubit positions. We take this idea even further and we disallow types of the form qbit[n] in function arguments, for any constant n. All function arguments must be polymorphic w.r.t. the qubits in which they reside.
However, qubit positions are not the only source of polymorphism in our ex- tension. Consider the function add, whose first argument is a quantum register of unknown type. It is reasonable to give add the polymorphic type:
add	:	∀t. (t; complex) → t
where the variable t ranges over quantum types. Similarly, a function type may be polymorphic in a variable u ranging over classical types.
Consider now a function that returns its result in a newly allocated qubit. 9 In order to know the exact qubit that will be used for the result, we need to know the number of qubits in the caller’s state. As this may vary, we need to make the function’s type polymorphic w.r.t. the number of qubits of the state. Fortunately we have disallowed constant qubit types in function arguments, so we can do this implicitly by taking the type qbit[m] in a function’s result, where m is a constant, to refer to the m-th available qubit above the ones used by caller’s state. For the logistics of the typing rule for function application, it will be useful to know the total number of qubits allocated by the function’s body and whether the body of a function performs a pure or impure computation; this information should also be present in the function’s type. As an example, consider a function of type:
f	:	∀k1, k2. qbit[k1] ⊗ qbit[k2] →◦ qbit[2]; 4
If the caller’s state uses n qubits (obviously k1 and k2 are two of these qubits, or even the same qubit) then the result of f will reside in the (n + 2)-th qubit of the state and the state after the call will contain n + 4 qubits. The function’s type also reveals that applying this function results in a pure expression.
We thus extend the syntax of types as follows, where b is a new syntactic class for qubit positions:
b  ::= k | n
τ ::= t | qbit[b] | τ1 ⊗ τ2
φ ::= u | bit | φ1 × φ2 | complex


9 deutsch is such a function, but we will not give it a type yet, as it is second-order.

As a last reference to our examples in section 4, consider the function cnot. The type k1, k2. (qbit[k1], qbit[k2])  qbit[k2]; 0 is not enough because, for the function’s body to typecheck, the typing rule for if requires that k1 = k2. This information must be added to the function’s type and, to do this, we need a syntax for constraints. One kind of constraint is disjoint(τ1, τ2), which provides us with the information that qbits(τ1) ∩ qbits(τ2) = ∅.
cnot	:	∀k1, k2. disjoint(qbit[k1], qbit[k2]) ⇒
(qbit[k1], qbit[k2]) → qbit[k2]; 0
This is precisely what is needed for the function’s body to typecheck. Other kinds of constraints state that a quantum type τ is pure and that a quantum type τ and a classical type φ satisfy C(τ ) = φ.
κ ::= pure(τ ) | disjoint(τ, τ ) | classic(τ, φ)
With all these in mind, the syntax of function types θ in our extended type system is the following:
θ ::= ∀(→k; →t; →u). →κ ⇒ (→τ ; φ→; θ→) →α τ ; n
and the type of deutsch is:
deutsch	:	(∀k. .qbit[k] → qbit[k]) → qbit[0]; 2


Typing
Some new environments are required for the typing of the extended language. In addition to the environments Γ and Δ that provide the types of quantum and clas- sical variables respectively, two new environments are necessary: for polymorphic (type) variables and Φ for function names. The environment associates polymor- phic variables with their kind. There are three kinds (#, , $), where k : # denotes that k is a qubit position variable, t : denotes that t is a quantum type variable and u : $ denotes that u is a classical type variable. Moreover, Φ associates function names with function types (f : θ).
The typing relation for the extended language is similar to that of section 3:
; C; Γ; Ξ; Δ; Φ; n  α e : τ ; m. In addition to the environments Γ, Δ,  and Φ, we have added two more elements. C is a set of constraints and Ξ is a set of qubit positions. Their purpose will become apparent in what follows. The typing relation for classical expressions is also extended: E ; C;Δ ▶ c : φ. We add two new typing relations for definitions and programs: Φ ▶ d and Φ ▶ p.
One of the existing typing rules that needs to change is the rule for if . Consider the case of a function f that is polymorphic in the qubit position k. Suppose that f takes an argument x of type qbit[k] and that the body of f contains the expression if x then e1 else e2. In the presence of a polymorphic qubit position b, it is hard to construct the environment Γ b by excluding from Γ the variables whose types mention b. It is easier to keep a set Ξ of qubit positions that must not be used in the typing of quantum expressions. The new rule for if extends Ξ with b.

E ; C; Γ; Ξ; Δ; Φ; n ▶α e : qbit[b]; m
E ; C; Γ; Ξ, b; Δ; Φ; n + m ▶◦ e1 : τ ; m1
E ; C; Γ; Ξ, b; Δ; Φ; n + m ▶◦ e2 : τ ; m2
E ; C; Γ; Ξ; Δ; Φ; n ▶α if e then e1 else e2 : τ ; m + max(m1, m2)




(IF)

The problem is then shifted to the typing of variables. Before deciding that a variable x has type τ , we must make sure that τ does not mention any of the qubit positions contained in Ξ. This may not be possible to verify without access to the function’s constraints, and thus we invent the judgement C |= qbits(τ ) ∩ Ξ = ∅.

 (x : τ ) ∈ Γ	C |= qbits(τ ) ∩ Ξ = ∅  E ; C; Γ; Ξ; Δ; Φ; n ▶◦ x : τ ;0 

(VAR)

In a similar fashion, the typing rule for e	x, x'.c needs to change, to support transforming expressions of polymorphic types.
E ; C; Γ; Ξ; Δ; Φ; n ▶α e : τ ; m	C |= pure(τ )	C |= C(τ ) = φ

E ; C; Δ,x : φ, x' : φ ▶ c : complex
E ; C; Γ; Ξ; Δ; Φ; n ▶α |e⟩→ x, x'.c : τ ; m

(TRANS)

The definition of appropriate inference rules for our new “verification” judgements (of the form C = prop) is far from trivial, but we shall not deal with it in this paper. In the rest of this section, we shift our attention to the typing rules for function application and function definition.
Let f be a polymorphic function of type (→k; →t; →u). →κ (→τ ; φ→; θ→) α τ ; m. When typechecking a call to f , the polymorphic variables →k, →t and →u must be substituted with actual qubit positions, quantum and classical types. This is performed by a substitution σ, whose formal definition we omit here. We denote by σ τ  the effect of σ on the quantum type τ , by σ φ its effect on the classical type φ, etc. The actual arguments to f must typecheck with the σ-substituted types of the formal arguments. Furthermore, the σ-substituted function constraints must be verified. The type of the result is τ , appropriately “shifted” and σ-substituted. We denote by τ ↑m the type that results from adding m to all constant qubit positions in τ .
(f : ∀(→k; →t; →u). →κ ⇒ (→τ ; φ→; θ→) →α τ ; m2) ∈ Φ
E ; C; Γ; Ξ; Δ; Φ; n ▶α →e : σ{→τ }; m1	E ; C;Δ ▶ →c : σ{φ→}
(f→ : σ{θ→}) ∈ Φ	C |= σ{→κ}

E ; C; Γ; Ξ; Δ; Φ; n ▶α f (→e; →c; f→) : σ{τ ↑n+m1 }; m1 + m2
(APP)

Typechecking the definition of a polymorphic function f is easier. The function’s body must typecheck and return the appropriate type, with the appropriate initial environments. Notice two things when typechecking a function’s body: (i) the only external environment that is used is Φ, and (ii) n = 0 is used, so that the numbering of the newly created qubits starts from 0.
(f : ∀(→k; →t; →u). →κ ⇒ (→τ ; φ→; θ→) →α τ ; m) ∈ Φ
→k : #, →t : ∗, →u : $; →κ; →x : →τ ; ∅; →y : φ→; Φ, f→ : θ→;0 ▶α e : τ ; m

Φ ▶ f (→x; →y; f→) := e
(DEF)

Some metatheory
In this section, we restrict ourselves to the well-formedness of types.
Definition 5.1 A type τ is well-formed in a state of n qubits and a type environ- ment E , written as E ; n ▶ τ , if for all n' ∈ qbits(τ ) we have n' < n and all type variables used by τ are defined in E with the appropriate kind.
Definition 5.2 A classical type φ is well-formed in a type environment E , written as E ▶ φ, if all type variables used by φ are defined in E with the appropriate kind.
Definition 5.3 A constraint κ is well-formed in a type environment E , written as
E ▶ κ, if all type variables used by κ are defined in E with the appropriate kind.
Definition 5.4 A function type θ ≡ ∀(→k; →t; →u). →κ ⇒ (→τ ; φ→; θ→) →α τ ; m is well- formed in a type environment E , written as E ▶ θ, if in the type environment E' ≡ E, →k : #, →t : ∗, →u : $ we have E' ▶ →κ, E';0 ▶ →τ , E' ▶ φ→, E' ▶ θ→ and E'; m ▶ τ .
Definition 5.5 An environment Γ is well-formed in a state of n qubits and a type environment E , written as E ; n ▶ Γ, if for all (x : τ ) ∈ Γ we have E ; n ▶ τ .
Definition 5.6 A classical environment Δ is well-formed in a type environment E , written as E ▶ Δ, if for all (y : φ) ∈ Δ we have E ▶ φ.
Definition 5.7 A function type environment Φ is well-formed in a type environ- ment E , written as E ▶ Φ, if for all (f : θ) ∈ Φ we have E ▶ θ.
Definition 5.8 A set of constraints C is well-formed in a type environment E , written as E ▶ C, if for all κ ∈ C we have E ▶ κ.
The following theorem states that the types produced by the typing relation are well-formed.
Theorem 5.9 If E ; C; Γ; Ξ; Δ; Φ; n ▶α  e : τ ; m, E ▶ C, E ; n ▶ Γ, E ▶ Δ and
E ▶ Φ, then E ; n + m ▶ τ.
Proof (Sketch) By induction on the typing derivation. It uses several “weakening” lemmata, e.g. if ; n τ then ; n' τ for all n' n. The case of APP requires a substitution lemma.	 

Type inference
Although the syntax of nQML extended with functions is rather simple, its type system is very complicated. Fortunately, a type inference algorithm can be used to automatically calculate the types of functions. The algorithm is based on type unification: it generates a set of uniﬁcation constraints whose solution provides a program’s missing types. In most aspects, this algorithm is simpler than Hindley- Milner style type inference algorithms, because in nQML polymorphism does not extend to function types and currying is not allowed. However, it faces the problem of calculating one set of constraints →κ for each polymorphic function in the program. Such constraints are gathered from the typing rules when typechecking the bodies

of functions. They are updated and the process is repeated, until a fixed point is reached. Although the results from using this type inference algorithm in practice are adequate, a thorough theoretical analysis is still missing.
Conclusion
Quantum programming is today more or less at the same point in its history as classical programming was in the 1940s. The hardware is non existent or faulty. The semantics of quantum programming languages is understood either at a very low level of abstraction, using quantum gates and circuits, or at a very high level of abstraction, using tensor products in categories of Hilbert spaces. One thing that is different, though, is our experience of more than half a century in the theory and practice of classical programming languages. It is this experience that must be put into work if, sometime in the future, quantum programming languages are going to be what classical programming languages are today. Quantum programming must exploit the advantages of the quantum computational model, putting aside its peculiarities and insignificant details, so that programmers can add two “quantum integers” and obtain another “quantum integer” without, for example, having to think about the reversibility of this computation.
It can be argued that our work takes the “quantum data and control” paradigm a very small step further towards simplicity. We have defined nQML, a new functional quantum programming language, inspired by Altenkirch and Grattage’s QML and following the “quantum data and control” paradigm. The type system of nQML keeps track of the use of qubits in expressions and avoids the complexities of lin- ear type systems. This type system scales well to include polymorphic higher-order functions and admits a type inference algorithm. The semantics of nQML is inspired by Selinger’s semantics for QPL. It is a simple denotational semantics with density matrices and unitary transformations as the semantic domains, which leads natu- rally to a simple implementation, in the form of an interpreter written in Haskell. Furthermore, the e  x, x'.c construct allows quantum algorithms to be imple- mented in a more direct and natural way.

References
Altenkirch, T. and J. Grattage, A functional quantum programming language, in: Proceedings of the 20th Annual IEEE Symposium on Logic in Computer Science, 2005, pp. 249–258.
Gay, S. J., Quantum programming languages: Survey and bibliography, Mathematical Structures in Computer Science 16 (2006), pp. 581–600.
Grattage, J. and T. Altenkirch, A compiler for a functional quantum programming language (2005), manuscript.
Grattage, J. and T. Altenkirch, QML: Quantum data and control (2005), manuscript.
Grover, L. K., A fast quantum mechanical algorithm for database search, in: Proceedings of the 28th Annual ACM Symposium on the Theory of Computing, Philadelphia, PA, 1996, pp. 212–219.
Knill, E., Conventions for quantum pseudocode, Technical Report LAUR-96-2724, Los Alamos National Laboratory (1996).

O¨ mer, B., “Structured Quantum Programming,” Ph.D. thesis, Institute of Information Systems, Technical University of Vienna (2003).
Sanders, J. W. and P. Zuliani, Quantum programming, in: Proceedings of the 5th International Conference on Mathematics of Program Construction, Lecture Notes in Computer Science 1837 (2000),
pp. 80–99.
Selinger, P., Towards a quantum programming language, Mathematical Structures in Computer Science
14 (2004), pp. 527–586.
Selinger, P. and B. Valiron, A lambda calculus for quantum computation with classical control, Mathematical Structures in Computer Science 16 (2006), pp. 527–552.
Shor, P. W., Polynomial time algorithms for prime factorization and discrete logarithms on a quantum computer, SIAM Journal on Computing 26 (1997), pp. 1484–1509.
van Tonder, A., A lambda calculus for quantum computation, SIAM Journal on Computing 33 (2004),
pp. 1109–1135.
Formal definition of nQML
Syntax
e ::= x | { (λ) qfalse + (λ') qtrue } | let x = e1 in e2 | (e1, e2) | let (x1, x2)= e1 in e2
|  if e then e1 else e2 | ifm e then e1 else e2 | |e⟩ → x, x'.c 
c ::= x | λ | false | true | let x = c1 in c2 | (c1, c2) | let (x1, x2)= c1 in c2
|  int c | c1 + c2 | c1 − c2 | c1 ∗ c2 | c1/c2 | cc2 | c1 = c2 | c1 < c2 | if c then c1 else c2
Typing
Types: quantum and classical
τ ::= qbit[n] | τ1 ⊗ τ2
φ ::= bit | φ1 × φ2 | complex

From quantum to classical types
C(qbit[n])	=	bit
C(τ1 ⊗ τ2)	=	C(τ1) × C(τ2)
Size of classical types
|C(qbit[n]) |	=	1
|C(τ1 ⊗ τ2) |	=	|C(τ1) | + |C(τ2) |
| complex |	=	undefined
Qubits used by a quantum type
qbits(τ )	:	P(N)
qbits(qbit[n])	=	{n}
qbits(τ1 ⊗ τ2)	=	qbits(τ1) ∪ qbits(τ2)
Pure quantum types


pure(qbit[n])
 pure(τ1)	pure(τ2)	qbits(τ1) ∩ qbits(τ2)= ∅ 
pure(τ1 ⊗ τ2)

Type environments: quantum and classical
Γ	:	a finite set of pairs of the form (x : τ ) Δ	:	a finite set of pairs of the form (x : φ)
Γ|k	=	{(x : τ ) ∈ Γ | k /∈ qbits(τ )}

Typing relation for quantum expressions
where α is empty or ◦

Γ; n ◦ e : τ ; m
(EMB)
Γ; n ▶ e : τ ; m
	(x : τ ) ∈ Γ	 (VAR)
Γ; n ▶◦ x : τ ;0 

|λ|2 + |λ'|2 =1 
Γ; n ▶◦ { (λ) qfalse + (λ') qtrue } : qbit[n]; 1

(SUP)

Γ; n ▶α e1 : τ1; m1	Γ,x : τ1; n + m1 ▶α e2 : τ ; m2

Γ; n ▶α let x = e1 in e2 : τ ; m1 + m2
(LET)

Γ; n ▶α e1 : τ1; m1	Γ; n + m1 ▶α e2 : τ2; m2
Γ; n ▶α (e1, e2): τ1 ⊗ τ2; m1 + m2

(PROD)

Γ; n ▶α e1 : τ1 ⊗ τ2; m1	Γ, x1 : τ1, x2 : τ2; n + m1 ▶α e2 : τ ; m2
Γ; n ▶α let (x1, x2)= e1 in e2 : τ ; m1 + m2
Γ; n ▶α e : qbit[k]; m
Γ|k; n + m ▶◦ e1 : τ ; m1	Γ|k; n + m ▶◦ e2 : τ ; m2

Γ; n ▶α if e then e1 else e2 : τ ; m + max(m1, m2)

(LETPROD)



(IF)

 Γ; n ▶ e : qbit[k]; m	Γ; n + m ▶ e1 : τ ; m1	Γ; n + m ▶ e2 : τ ; m2 
Γ; n ▶ ifm e then e1 else e2 : τ ; m + max(m1, m2)
Γ; n ▶α e : τ ; m	pure(τ )	x : C(τ ), x' : C(τ ) ▶ c : complex

(IFM)

Γ; n ▶α |e⟩ → x, x'.c : τ ; m

Typing relation for classical expressions
(TRANS)



 (x : φ) ∈ Δ  Δ ▶ x : φ

(var)

Δ ▶ false : bit

(false)

Δ ▶ true : bit

(true)


Δ ▶ λ : complex
(const)	 Δ ▶ c1 : φ1	Δ, x : φ1 ▶ c2 : φ 
Δ ▶ let x = c1 in c2 : φ

(let)

 Δ ▶ c1 : φ1	Δ ▶ c2 : φ2 
Δ ▶ (c1, c2): φ1 × φ2
(prod)	 Δ ▶ c1 : φ1 × φ2	Δ, x1 : φ1, x2 : φ2 ▶ c2 : φ 
Δ ▶ let (x1, x2)= c1 in c2 : φ

(letprod)

		Δ ▶ c : C(τ )	 Δ ▶ int c : complex
(int)	 Δ ▶ c : bit	Δ ▶ c1 : φ	Δ ▶ c2 : φ 
Δ ▶ if c then c1 else c2 : φ

(if)

 Δ ▶ c1 : complex	Δ ▶ c2 : complex	op ∈ {+, −, ∗, /, ˆ} 
Δ ▶ c1 op c2 : complex

(arith)

 Δ ▶ c1 : φ	Δ ▶ c2 : φ 
Δ ▶ c1 = c2 : bit
Semantics
Semantic domains
(eq)	 Δ ▶ c1 : complex	Δ ▶ c2 : complex 
Δ ▶ c1 < c2 : bit

(lt)

S(n)	=	A ∈ C2n×2n | A is a density matrix
T(n)	=	T ∈ C2n×2n | T is unitary
[[ Δ ]]	=	Π x : Var. [[ Δ(x) ]]
[[ bit ]]	=	B
[[ φ1	φ2 ]]	=	[[ φ1 ]]	[[ φ2 ]]
[[ complex ]]	=	C


Semantics of pure quantum expressions
VAR:	[ Γ; n ▶◦ x : τ ;0 ] = In
SUP:	[ Γ; n ▶◦ { (λ) qfalse + (λ') qtrue } : qbit[n]; 1 ]  = In ⊗




λ λ' λ' −λ


LET ◦:	[ Γ; n ▶◦ let x = e1 in e2 : τ ; m1 + m2 ]] = T2 (T1 ⊗ Im2 )
where	T1	=	[ Γ; n ▶◦ e1 : τ1; m1 ]]
T2	=	[ Γ,x : τ1; n + m1 ▶◦ e2 : τ ; m2 ]]
PROD ◦:	[ Γ; n ▶◦ (e1, e2): τ1 ⊗ τ2; m1 + m2 ]] = T2 (T1 ⊗ Im2 )
where	T1	=	[ Γ; n ▶◦ e1 : τ1; m1 ]]
T2	=	[ Γ; n + m1 ▶◦ e2 : τ2; m2 ]]
LETPROD ◦:	[ Γ; n ▶◦ let (x1, x2)= e1 in e2 : τ ; m1 + m2 ]] = T2 (T1 ⊗ Im2 )
where	T1	=	[ Γ; n ▶◦ e1 : τ1 ⊗ τ2; m1 ]]
T2	=	[ Γ, x1 : τ1, x2 : τ2; n + m1 ▶◦ e2 : τ ; m2 ]]
IF ◦:	[ Γ; n ▶◦ if e then e1 else e2 : τ ; m + max(m1, m2) ]]  =
Tc (T ⊗ Imax(m1 ,m2 ))
where	T	=	[ Γ; n ▶◦ e : qbit[k]; m ]]
T1	=	[ Γ|k; n + m ▶◦ e1 : τ ; m1 ]] T2	=	[ Γ|k; n + m ▶◦ e2 : τ ; m2 ]]
T '	=	except(k, T1) ⊗ Imax(m ,m )−m
T '	=	except(k, T2) ⊗ Imax(m ,m )−m

2
Tc	=	cond(k, T ',T ' )
1  2	2

1  2
TRANS ◦:	[ Γ; n  ◦ e	x, x'.c : τ ; m ]] = Tc T
where	Tc		=		expand(n, qbits(τ ),C) T	=	[ Γ; n ▶◦ e : τ ; m ]]
Cj,i	=	[ x : C(τ ), x' : C(τ ) ▶ c : complex ]](ρ)
where	ρ	=	ρ0{x '→ valτ (i)}{x' '→ valτ (j)} for all 0 ≤ i, j < 2k, where k = |qbits(τ )|


Semantics of impure quantum expressions
EMB:	[ Γ; n ▶ e : τ ; m ]](A)  = T (A ⊗ Δm) T ∗
where	T	=	[ Γ; n ▶  e : τ ; m ]]
LET :	[ Γ; n ▶ let x = e1 in e2 : τ ; m1 + m2 ]](A) = B2
where	B1	=	[ Γ; n ▶ e1 : τ1; m1 ]](A)
B2	=	[ Γ,x : τ1; n + m1 ▶ e2 : τ ; m2 ]](B1)
PROD :	[ Γ; n ▶ (e1, e2): τ1 ⊗ τ2; m1 + m2 ]](A) = B2
where	B1	=	[ Γ; n ▶ e1 : τ1; m1 ]](A)
B2	=	[ Γ; n + m1 ▶ e2 : τ2; m2 ]](B1)
LETPROD :	[ Γ; n ▶ let (x1, x2)= e1 in e2 : τ ; m1 + m2 ]](A) = B2
where	B1	=	[ Γ; n ▶ e1 : τ1 ⊗ τ2; m1 ]](A)
B2	=	[ Γ, x1 : τ1, x2 : τ2; n + m1 ▶ e2 : τ ; m2 ]](B1)
IF :	[ Γ; n ▶ if e then e1 else e2 : τ ; m + max(m1, m2) ]](A)  =
Tc (B ⊗ Δmax(m1 ,m2 )) T ∗
where	B	=	[ Γ; n ▶ e : qbit[k]; m ]](A) T1		=		[ Γ|k; n + m ▶ e1 : τ ; m1 ]] T2		=		[ Γ|k; n + m ▶  e2 : τ ; m2 ]]
T '	=	except(k, T1) ⊗ Imax(m ,m )−m
T '	=	except(k, T2) ⊗ Imax(m ,m )−m

2
Tc	=	cond(k, T ',T ' )
1  2	2

1  2
IFM :	[ Γ; n ▶ ifm e then e1 else e2 : τ ; m + max(m1, m2) ]](A)  =
B1 ⊗ Δmax(m1 ,m2 )−m1 + B2 ⊗ Δmax(m1 ,m2 )−m2
where	B	=	[ Γ; n		e : qbit[k]; m ]](A) (Bt, Bf )		=	measure(k, B)
B1	=	[ Γ; n + m ▶ e1 : τ ; m1 ]](Bt ⊗ Δm1 )
B2	=	[ Γ; n + m	e2 : τ ; m2 ]](Bf	Δm2 )
TRANS :	[ Γ; n	e	x, x'.c : τ ; m ]](A)  =  Tc BT∗
where	Tc		=	 expand(n, qbits(τ ),C) B	=	[ Γ; n ▶ e : τ ; m ]](A)
Cj,i	=	[ x : C(τ ), x' : C(τ ) ▶ c : complex ]](ρ)
where	ρ	=	ρ0{x '→ valτ (i)}{x' '→ valτ (j)} for all 0 ≤ i, j < 2k, where k = |qbits(τ )|


Semantics of classical expressions
var:	[ Δ ▶ x : φ ]](ρ) = ρ(x)
false:	[ Δ ▶ λ : false ]](ρ) = false

true:	[ Δ ▶ λ : true ]](ρ) = true
const:	[ Δ ▶ λ : complex ]](ρ) = λ	'
let:	[ Δ ▶ let x = c1 in c2 : φ ]](ρ) =  [ Δ,x : φ1 ▶ c2 : φ ]](ρ )
where	ρ'	=	ρ{x '→ [[ Δ ▶ c1 : φ1 ]](ρ)}
prod:	[ Δ ▶ (c1, c2): φ1 × φ2 ]](ρ) = ( [ Δ ▶ c1 : φ1 ]](ρ), [[ Δ ▶ c2 : φ2 ]](ρ))
letprod:	[ Δ ▶ let (x1, x2)= c1 in c2 : φ ]](ρ) =
[[ Δ, x1 : φ1, x2 : φ2 ▶ c2 : φ ]](ρ')
where	(v1, v2)	=	[ Δ ▶ c1 : φ1 × φ2 ]](ρ)
ρ'	=	ρ{x '→ v1}{y '→ v2}
int:	[ Δ ▶ int c : complex ]](ρ) = codeτ ([[ Δ ▶ c : C(τ ) ]](ρ))
arith:	[ Δ ▶ c1 op c2 : complex ]](ρ) =
[[ Δ ▶ c1 : complex ]](ρ) op [[ Δ ▶ c2 : complex ]](ρ)
eq:	[ Δ ▶ c1 = c2 : bit ]](ρ)  =
true , if [ Δ ▶ c1 : φ ]](ρ)= [[ Δ ▶ c2 : φ ]](ρ)
false , if [ Δ ▶ c1 : φ ]](ρ) /= [[ Δ ▶ c2 : φ ]](ρ)
lt:	[ Δ ▶ c1 < c2 : bit ]](ρ) =
true , if [ Δ ▶ c1 : complex ]](ρ) < [[ Δ ▶ c2 : complex ]](ρ)
false , if [ Δ ▶ c1 : complex ]](ρ) ≥ [[ Δ ▶ c2 : complex ]](ρ)
if :	[ Δ ▶ if c then c1 else c2 : φ ]](ρ)  =
[[ Δ ▶ c1 : φ ]](ρ) , if [[ Δ ▶ c : bit ]](ρ) = true
[[ Δ ▶ c2 : φ ]](ρ) , if [[ Δ ▶ c : bit ]](ρ) = false
Auxiliary functions
In	:	the identity matrix of size 2n × 2n
Δn	:	a matrix of size 2n × 2n with all zeroes and a 1 in the top-left corner
except	:	N × S(n + 1) → S(n)
	!

except(k + 1,  A B !)	=	  except(k, A) except(k, B) !

cond	:	N × S(n) × S(n)!→ S(n + 1)

cond(k + 1,  TA TB ! ,  FA FB !)	=	  cond(k, TA, FA) cond(k, TB, FB) !

measure	:	N × S(n + 1) → S(n + 1) × S(n + 1)
	!		!	!

measure(k + 1,  A B !)	=	(  TA TB ! ,  FA FB !)
where (TA, FA) = measure(k, A) (TB, FB) = measure(k, B) (TC , FC ) = measure(k, C) (TD, FD)  =  measure(k, D)
expand	:	Π n : N. Π S : (N). T( S )	T(n)
expand(n, S, T )	=	expa0(n, S, T )
where	expan(n, S, T )	=	T
expa (n, S,  A B  )	=	expak+1(n, S, A) expak+1(n, S, C)
if k < n and k ∈ S
expak (n, S, T )	=	I1 ⊗ expak+1(n, S, T ) if k < n and k /∈ S
codeτ	:	[ C(τ ) ]] →( N

codeτ1 ⊗τ2 (v1, v2)	=	2k codeτ1 (v1)+ codeτ2 (v2)
where	k	=	|C(τ2) |
valτ	:	N → [[ C((τ ) ]]
valτ1 ⊗τ2 (n)	=	(valτ1 (n/2k), valτ2 (n mod 2k))
where	k	=	|C(τ2) |
