Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 336 (2018) 57–78
www.elsevier.com/locate/entcs
On Models of Higher-Order Separation Logic
Aleˇs Bizjak1 Lars Birkedal2
Department of Computer Science, Aarhus University, Denmark

Abstract
We show how tools from categorical logic can be used to give a general account of models of higher-order separation logic with a sublogic of so-called persistent predicates satisfying the usual rules of higher-order logic. The models of separation logic are based on a notion of resource, a partial commutative monoid, and the persistent predicates can be defined using a modality. We classify well-behaved sublogics of persistent predicates in terms of interior operators on the partial commutative monoid of resources. We further show how the general constructions can be used to recover the model of Iris, a state-of-the-art higher-order separation logic with guarded recursive predicates.
Keywords: separation logic, model, modalities


Introduction
In recent years we have seen many models of variations of higher-order separation logic, e.g., [4,14,6,3,1,16,10,9,11]. Separation logic is a substructural logic and the models are all based on some notion of resource. Originally, resources were heap fragments, and predicates in the logic described sets of heaps. For instance, the points-to predicate l '→3 described those heaps that contain the value 3 at location
l. Later on, more elaborate notions of resources were used because they allow for stronger specifications and they can be used to keep track of data and relationships not explicitly given in the program code.
With these richer notions of resources it has often been noticed that it is very useful to be also able to single out and work with predicates that are “persistent”. Persistent predicates are, in particular, duplicable (meaning P ? P ⇔ P ), and they obey more standard (not substructural) logical rules. One way this has been achieved is via a modality  (pronounced always) which is a necessity-like modality and obeys rules akin to those obeyed by the bang modality ! of linear logic. Such a

1 Email: abizjak@cs.au.dk
2 Email: birkedal@cs.au.dk

https://doi.org/10.1016/j.entcs.2018.03.016
1571-0661/© 2018 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

modality also gives the ability to make propositions persistent inside the logic, which significantly increases its expressiveness, as demonstrated in previous work [9,11].
Examples of persistent predicates are simple facts like equality of values, and Hoare triples. Hoare triples are specifications of (parts of) programs. They describe the knowledge (in separation logic jargon) that a program requires certain resources (precondition) and ensures certain properties after execution (postcondition). As such this knowledge should be reusable many times, in the sense that during veri- fication of a larger program, we can use the specification of the subparts as many times as the subparts appear. In sophisticated logics, in particular in concurrent separation logics such as Iris [10], there are many other persistent predicates, e.g., invariants, which describe the knowledge that a certain predicate holds for some shared memory. This knowledge should be shared between different parts of the program which operate on the shared memory, and hence invariants should be du- plicable.
Thus in advanced separation logics it is useful to have a distinction between predicates which involve some form of ownership, such as l '→3, and persistent predicates, such as Hoare triples and invariants, which do not involve any exclusive ownership, but rather express knowledge, i.e., which can be freely duplicated. The
 modality can be used to take out the “persistent core” of a predicate inside the logic, i.e.,  P contains those resources in P which are duplicable. This ability can, e.g., be used for deﬁning Hoare triples in Iris [10,9,11] and also for modelling intuitionistic types inside a separation logic [15,18,12].
In this paper we show how tools from categorical logic can be used to give a general account of models of higher-order separation logic with a sublogic of persistent predicates. We focus on the basic rules and basic connectives used in separation logic and do not consider the so-called specification logic, i.e., Hoare triples, and concepts such as invariants, and rules particular to specific separation logics. We aim to show how to model the basic parts of the logic in a general way, so that in future work the effort can be spent on modelling the parts particular to the logic at hand.
We make use of the standard notion of a complete Heyting algebra to model standard higher-order logic and the notion of a complete BI algebra [4] to model higher-order separation logic. We show how to construct such algebras based on a model of resources, formalized by a kind of partial commutative monoid, and different ways of singling out the idempotent (duplicable) monoid elements. We show that our abstract framework is general enough to encompass models which also include a modality for reasoning about guarded recursive predicates: by a simple change of the ambient category, from sets to the topos of trees, we recover the step-indexed notion of resource model used to model Iris [9], a state-of-the-art higher-order separation logic with guarded recursive predicates.

Overview
In Section 2 we recall the definition of BI hyperdoctrine and how models of resources can be used to construct BI hyperdoctrines. In the end of the section we

show that it is in general impossible to single out exactly the duplicable resources using a well-behaved modality.
In Sections 3 and 4 we study conditions under which one can obtain a logic of persistent predicates. We give two different constructions, one based on idempotent resources and one based on an interior operator on the resources. For the first construction, one obtains a sublogic closed under some of the logical connectives, but in general not all. In particular it can fail to be closed under universal quantification of the ambient logic. For the second construction, one obtains a sublogic closed under all the standard logical connectives of the ambient logic.
In Section 5 we show that any sublogic on duplicable predicates only, and closed under all the standard connectives must be of the form considered in Section 4. We further show that sublogics considered in Section 4 are all at most as expressive as the logic based on idempotent elements considered in Section 3, and we show necessary and sufficient conditions for this latter logic to be closed under univer- sal quantification. These conditions are stated in terms of the structure of the idempotents of the resource monoid.
The approach using an interior operator is closely related to the core operator of Pottier [15], (though Pottier includes some additional requirements on his notion of core); and to the core operator used in Iris [9]. In Section 5 we thus show that the notion of the core arises naturally as soon as we desire a well-behaved modality in the logic.
The models described hitherto do not directly support guarded recursive pred- icates, as used in Iris [10,9] and other logics, e.g. Appel [1]. To support guarded recursive predicates, the types and terms of the Iris logic are modelled using a sub- category of the topos of trees [9]. The Iris model construction is based on a kind of step-indexed resource model, called a complete metric resource algebra (CMRA). The technical definition of a CMRA, recalled in Definition 6.5, perhaps looks a bit ad-hoc. In Section 6 we show that it is in fact canonical, because it can be understood as a partial commutative monoid, just in a different ambient category. Moreover, we also show that the model of Iris predicates [9] can be recovered by using the topos of trees as the ambient category in which the constructions from Sections 3 and 4 are carried out.

BI-algebras and BI-hyperdoctrines
In this section we begin by calling to mind the notion of a BI-hyperdoctrine, a category-theoretic definition of a model of higher-order separation logic [4]. For simplicity, we focus on so-called canonically presented BI-hyperdoctrines.
Recall that a hyperdoctrine [13] is a cartesian closed category C together with a generic object Ω and for each object X ∈ C a choice of a partial order on the hom set HomC (X, Ω) satisfying the following properties:
HomC (X, Ω) is a complete Heyting algebra for all X.
HomC (f, Ω) : HomC (X, Ω) → HomC (Y, Ω) is a complete Heyting algebra homo-

morphism for all f : Y → X in C.
For any pair of objects X, Y ∈ C the function
HomC (π, Ω) : HomC (X, Ω) → HomC (X × Y, Ω)
has left and right adjoints which additionally satisfy the Beck-Chevalley condition.
A complete BI-algebra [4] is a complete Heyting algebra which in addition has closed monoidal structure (?, −?, I). A BI-hyperdoctrine is a hyperdoctrine such that for each X the set HomC (X, Ω) is a complete BI-algebra and HomC (f, Ω) is a complete BI-algebra homomorphism.
To model logic using a hyperdoctrine we interpret types and terms of the logic as objects and morphisms of C, whereas predicates are interpeted as elements of HomC (X, Ω), where X is the (denotation of the) domain of the predicate.
A canonical way to construct a hyperdoctrine is from an internal complete Heyt- ing algebra H in C (this requires that C has sufficient structure to express what a complete Heyting algebra is). The Heyting algebra H is the generic object and the order on HomC (X, H) is pointwise, as are all the complete Heyting algebra operations.
Similarly, a canonical way to construct a BI-hyperdoctrine is from an internal complete BI-algebra. Operations are again given pointwise.
It is well-known [4] how to model higher-order separation logic in BI- hyperdoctrines. Thus, in light of the above canonical constructions, in the remainder of this paper we focus on constructing and studying complete Heyting algebras and complete BI-algebras.

Construction of complete BI-algebras
A very general way to construct BI-algebras is from a partial commutative monoid M equipped with a preorder ≤ which interacts with the operation in a reasonable way, which we make precise below. The set of upwards-closed subsets of M, written P↑ (M), is a complete BI-algebra.
By varying the preorder on the monoid we can obtain models of different sep- aration logics. In particular if the order is extension order (also called divisibility preorder) then we get a model of so-called affine separation logic, which enjoys the weakening rule p ? q ▶ p for all propositions p, q. Recent logics such as iCAP [16], and various versions of Iris [10,9,11] have been such logics.
On the other hand if we take the discrete preorder, i.e., equality, we obtain a model which does not validate weakening. Such a logic allows for a more precise control over resources. For instance it allows one to express the property that the heap is empty, which is, e.g., used in the logics in some logics [1] to, for instance, guarantee that programs which are proved correct do not leak memory.
Most of the constructions below work for an arbitrary preorder and partial com- mutative monoid. In various statements we point out how additional assumptions on the preorder lead to validity of certain additional rules.

Definition 2.1 In this paper an ordered partial commutative monoid is a structure (M, ·, E, ≤) such that · : M × M ~ M is a partial function and E ⊆ M is the set of units satisfying the following axioms 3

m · n  n · m
(m · n) · k  m · (n · k)
∀m ∈ M, ∃e ∈ E,m · e  m
∀m ∈ M,e ∈ E,m · e defined ⇒ m · e  m

Finally ≤ is a preorder (a reflexive and transitive relation) on M satisfying mono- tonicity in the following sense: if nj ≤ n and mj ≤ m, and if n · m is defined then so is nj · mj and nj · mj ≤ n · m.

Canonical examples of orders satisfying monotonicity are extension, or divisi- bility, preorder, and the discrete order (equality). Recall that the extension order relates m ≤ n if there is a k, such that m · k  n, i.e., if n is divisible by m.
We write m ∼= n if m ≤ n and n ≤ m. In particular when we write m· n ∼= mj · nj
we also mean that both sides are defined.
Departing slightly from the usual terminology we call an element s ∈M idem- potent if s · s ∼= s. The motivation for this looser notion of idempotents is that if n ∼= m then n and m are completely exchangeable with regards to any logical operations, and thus there is no need to treat them differently in the model.
An example the reader should keep in mind is the partial monoid of finite partial functions N ~ X to some set X where composition is only defined when the domains are disjoint and in that case is given by the union of the graphs of the respective functions. There is a single unit, the map with the empty domain.
Let B = P† (M) be the set of upwards-closed subsets of M with respect to the order ≤ and let P (M) be the power set of M. Recall that any element p ∈B is a union of principal ideals ↑m = {n | n ≥ m}.
The following facts are well-known.
Fact 2.2 The sets B and P (M) when ordered by subset inclusion are complete Heyting algebras. The operations on B are given as

T = M	⊥ = ∅
p ∧ q = p ∩ q	p ∨ q = p ∪ q
^ pi = \ pi	_ pi = [ pi

p ⇒ q = {m | ∀n ≥ m, n ∈ p ⇒ n ∈ q}



3 We use  for Kleene equality.

and the operations on P (M) as
T = M	⊥ = ∅
p ∧ q = p ∩ q	p ∨ q = p ∪ q
^ pi = \ pi	_ pi = [ pi

p ⇒ q = {m | m ∈ p ⇒ m ∈ q}
Moreover there is an inclusion ι : B → P (M) which preserves both inﬁma and suprema.
Since ι preserves infima and suprema it has in particular a left adjoint, which is the closure operation Cl (·) : P (M) → B, which maps a subset p to the least upwards-closed subset containing p.
Cl (p)= {m ∈M| ∃n ∈ p, n ≤ m}
Lemma 2.3 The closure operation preserves suprema but in general it does not
preserve inﬁma.
The following is also well-known.
Fact 2.4 The set P (M) is a complete BI-algebra for the following operations.
I = E
p?q = {k | ∃m ∈ p, n ∈ q, k = m · n}
p −?q = {n | ∀m ∈ p, m · n deﬁned ⇒ m · n ∈ q}
Proposition 2.5 The set B is also a complete BI-algebra where the unit and mul- tiplication are deﬁned as follows
Ij = Cl (I)
p ?j q = Cl (p? q)
where the operations on the right-hand side are those deﬁned in 2.4.
Proof It is easy to see Cl (p? q) = Cl (Cl (p) ? Cl (q)) in P (M). Because for any
p ∈B we have Cl (p)= p we get for any p ∈B 
Ij ?j p = Cl (Cl (I) ? p)= Cl (Cl (I) ? Cl (p)) = Cl (I ? p)= Cl (p)= p.
To show that p?j − has a right adjoint it suffices to check that it preserves suprema. This follows from the fact that ? in P (M) does so and the fact that closure Cl (−) preserves suprema.
p ?j _ pi = Cl p? _ pi  = Cl  _(p? pi)  = _ Cl (p? pi)= _(p ?j pi)


2
These allow us to construct a model of basic logic of resources. Additional properties we might wish to model however depend on the interaction of ≤ and ·.
Lemma 2.6 The property p?q ⊆ p is equivalent to the following property. For any
m, n ∈M such that m · n is deﬁned, we have m · n ≥ m.
Proof That the second property implies the first is straightforward.
To see the converse we have by assumption (↑m)?(↑n) ⊆↑m. Since by definition
m · n ∈ (↑m) ? (↑n) we get m · n ∈↑m which by definition means that m · n ≥ m.2
The condition in the previous lemma is for instance satisfied by extension or- dering on a monoid, but it is not satisfied by discrete ordering.

Duplicable Predicates
As we alluded to in the introduction the main property we wish to single out with the sublogic is that a predicate P is duplicable, i.e., that it satisfies P ⇔ P ? P . Thus let F ⊆ B be the set of those P which satisfy P ? P = P . Notice that F is the set of fixed points for a monotone operator P '→P ? P on a complete lattice B, hence is itself a complete lattice by Knaster-Tarski’s fixed point theorem, although in general not a sublattice of B. In order to have a modality on B that singles out exactly F, the inclusion of F into B must have a right adjoint, which is equivalent to the property that F is closed under arbitrary unions.
Lemma 2.7 Suppose the order ≤ on M is extension order. Then F is closed under arbitrary unions.
Proof It suffices to show that if Pi = Pi ? Pi for any collection i ∈I then
[ Pi ⊆ [ Pi  ? [ Pi  .

But this is immediate, since for any i ∈I we have
Pi = Pi ? Pi ⊆ [ Pi  ? [ Pi  .

i∈£
i∈£
2

Thus in a large class of practical cases the inclusion of F to B has a right adjoint
G. However we wish the modality arising from this adjunction to be well-behaved and thus we also wish that it preserve unions, since this is needed for the modality to commute with existential quantification in the logic. Therefore we are interested in situations where G preserve unions as well. However it does not do so in many practical cases as we demonstrate below.

Example 2.8 Let M be the non-negative rational numbers and ≤ the extension order, which coincides with the usual ordering on rationals. It is straightforward to compute that F = {∅, P0, P>0} where P0 = M and P>0 = {q ∈M| q > 0}. Moreover it is easy to see that the function
G(P )=	P	if P ∈F 
∅	otherwise
is the right adjoint to inclusion F ⊆ B. And G does not preserve unions, since
P>0 =  q>0 {r | r ≥ q}.
Note that essentially the same counterexample, mutatis mutandis, can be con- structed using the partial commutative monoid of partial finite maps with fractional permissions, as used in some program logics. One particular thing we can learn from this example is that problems are caused by duplicable elements P which are approximated entirely by non-duplicable ones. Thus one possible solution presents itself. We restrict attention to those predicates P which are generated by duplicable principal ideals. We study the set of such predicates in the next section.
Persistent Predicates via Idempotent Resources
The definition of C below is motivated by the following two properties.
Lemma 3.1 A principal ideal ↑m is in F if and only if m · m ∼= m.
Proof Suppose m · m ∼= m. We show two inclusions. First ↑m ⊆ (↑m) ? (↑m). If
x ≥ m then also x ≥ m · m and so x ∈ (↑m) ? (↑m) because m · m is.
Conversely if x ∈ (↑m) ? (↑m) then are y, y1, y2 such that x ≥ y, y = y1 · y2 and
y1, y2 ≥ m. Then y ≥ m · m and so x ≥ y ≥ m · m ∼= m, thus x ∈↑m.
Suppose now that ↑ m is duplicable. Since m ∈↑ m there are x1, x2 such that m ≥ x1 · x2 and x1, x2 ≥ m. Thus m · m is defined and m ≥ m · m. Finally, m · m ∈ (↑ m) ? (↑ m) and so m · m ≥ m because we have assume that ↑ m is duplicable. We thus have m · m ∼= m.	2
Similar reasoning yields the following proposition.
Proposition 3.2 If the order ≤ satisﬁes that for any two idempotents s1, s2, if s1 · s2 is deﬁned then either s1 ≤ s1 · s2 or s2 ≤ s1 · s2 then any union s∈X ↑s for some set of idempotents X is duplicable.
It is perhaps slightly unfortunate that the condition on idempotents is necessary, but the condition is satisfied by a large class of monoids of practical interest. In particular, the condition is satisfied when the order is the extension order.
Let C be those elements p of B which are generated by idempotents in the following sense.
C = {p ∈B | ∀m ∈ p, ∃s ∈ p, s ≤ m ∧ s · s ∼= s}

Let δ : C → B be the inclusion.
We have the following simple lemma.
Lemma 3.3 C and δ have the following properties.
δ is monotone and also reflects the order, i.e., it is a full and faithful functor.
C has suprema inherited from B and δ preserves them.
δ has a right adjoint γ : B→ C given by
γ(q)= {m ∈M| ∃s ∈ q, s ≤ m ∧ s · s ∼= s}.
Moreover γ ◦ δ = id.
The right adjoint γ preserves suprema.
γ has a right adjoint ξ, given by
ξ(q)=	p.
p∈B,γ(p)⊆q
Further, ξ is full and faithful.
Proof Most of this is completely straightforward. For the last part, observe that we now have δ E γ E ξ and the result follows by [7, Lemma 1.3] and the fact that δ is full and faithful, i.e., it reflects and preserves the order.	2
Lemma 3.4 C has all inﬁma. They are given as
^ pi = γ ^ δ(pi)  .
Proof First recall that we have γ ◦ δ = id. We are now ready to show that i∈£ pi is the infimum of all pi. Since	i∈£ δ(pi) is the infimum in B, we have i∈£ δ(pi) ⊆ δ(pi) for all i ∈ I. Then by definition of the proposed infimum and monotonicity of γ, we have	i∈£ pi ⊆ γ(δ(pi)) = pi for all i ∈ I. This shows that we have a lower bound. Suppose now there is another lower bound b for all pi. Then δ(b) is a lower bound for all δ(p ) and so δ(b) ⊆	δ(p ), since this is the infimum in B. Using γ again we get b = γ(δ(b)) ⊆		i∈£ δ(pi), concluding the proof.	2
We can see from this construction that in general the inclusion δ will not preserve infima. In Section 5 we establish a necessary and sufficient condition for infima to be constructed by intersections using the structure of the idempotents of M.
Proposition 3.5 C is a complete Heyting algebra.
Proof It follows from Lemma 3.4 that C has all infima. By the previous Lemma γ preserves infima, i.e., all limits. Since ξ is full and faithful with a left adjoint that preserves finite limits, C is (equivalent to) an exponential ideal of B [8, A4.3.1], which implies that C is cartesian closed, i.e., a Heyting algebra.	2

Since we have the adjunction δ E γ with δ full and faithful we can characterize the subset C of B using a modality □ = δ ◦ γ on B. That is, C is the set of fixed points of □. Or if we view □ as a comonad (i.e., interior operator) then C is the set of coalgebras of □.
Proposition 3.6 The □ operator satisﬁes the following properties.
□ is idempotent.
For all p ∈ B, □(p) ⊆ p.
□ preserves all suprema, but not inﬁma in general.
However as stated above in general neither δ nor □ preserve infima. Thus C is in particular not a Heyting subalgebra of B [8, A4.3.1].
However in some cases it will be. In the case when the ordering on the monoid is extension ordering it is possible to show that δ and so □ preserves ﬁnite infima. Indeed we only need to show that p∧q is the intersection of p and q for any p, q ∈ C. Suppose r ∈ p ∩ q. Then there exists an s ∈ p such that s · s ∼= s and s ≤ r and similarly there exists a t ∈ q such that t · t ∼= t and t ≤ r. In particular, this means
that r = rj · t and r = rjj · s, by definition of the extension ordering. Then
s · t ≤ s · r = s · rjj · s = rjj · s = r
and since s, t ≤ s · t we have s · t ∈ p ∩ q and since s · t is clearly idempotent we have shown that p ∩ q ∈ C.
It is clear that δ preserves T and so since δ is just inclusion and (finite) infima in B are given by interesections, δ clearly preserves them, and so also □.
This then also implies by [8, A4.3.1] that C is a Heyting subalgebra of B, however it is not a complete Heyting subalgebra, that is, infinite infima are in general not given by intersections.
In the case when ordering on the monoid is discrete on the other hand it is easy to see that δ and □ preserve all infima. Indeed, in such a case □(p) is the set of idempotents in p.
In general the reason □ does not preserve infima is that given a collection of idempotents si ≤ m for some element m such that si ∈ pi there is no canonical choice of an idempotent s ∈ i∈£ pi such that s ≤ m. In fact, in Section 5 we show that infima are given by intersections if and only if the set I(m) = {s ≤ m | s · s = s} has a greatest element. In the following section we show that given such a choice of idempotents we have that C is a complete Heyting subalgebra of B and that the □ is a complete Heyting algebra morphism. Before that we discuss one of the reasons for introducing C and □.
Idempotents and separating conjunction
One of the reasons for introducing □ is that it allows us to express more properties of propositions, in particular in how ? and ∧ interact.
Lemma 3.7

If the order ≤ satisﬁes that for any idempotent s and any element x ∈M such that x ≥ s, the composition x · s is deﬁned then
□(p) ∧ q ⊆ □(p) ?q 
If the order ≤ satisﬁes the property that for any element x and any idempotent
s such that x · s is deﬁned, then x · s ≥ s, then the following property holds.
□(p) ?q ⊆ □(p) ∧ q.
The first condition is satisfied by extension order as well as the discrete order. The second condition is satisfied by the extension order, but not necessarily by the discrete order.
Persistent Predicates via an Interior Operator
In this section we show that an interior operator on M, interior with respect to the preorder ≤, lifts to an interior modality on B which preserves suprema and infima and moreover that the set of its fixed points is a complete Heyting subalgebra of B. By assuming additional properties relating f and the monoid operation we recover rules governing the interaction of ? and ∧ as in the previous section.
Let f : M → M be an interior operator on M with respect to the order
≤. Explicitly, this means that f is a monotone function that additionally satisfies
f (m) ≤ m and f (m) ≤ f (f (m)) for all m ∈ M.
Note that together, the above properties imply that for all m ∈ M, f (m) ≈
f (f (m)), i.e. f (f (m)) ≤ f (m) and f (f (m)) ≥ f (m).
The function f lifts to a function f−1 on B by taking preimages. Let
Lf = {p ∈B | p = f−1 [p]}
be the set of fixed points of f−1 and let Δ : Lf →B be the inclusion. Equivalently
Lf could be defined as Lf = {p ∈B | p ⊆ f−1 [p]} since f (m) ≤ m for all m ∈ M.
Lemma 4.1 If we consider Lf and B, partially ordered by inclusion then
Δ preserves and reflects the order, i.e., is a full and faithful functor.
Lf is closed under arbitrary suprema and inﬁma in B.
Δ preserves inﬁma and suprema.
Δ has a right adjoint Γ: B→ Lf given by
Γ(q)= f−1 [q]
Further, Γ preserves all inﬁma and suprema.
Proof The fact that Lf has infima and suprema given by intersection follows di- rectly from the fact that the preimage function preserves intersections and unions. The first and third items are immediate.

For the last item we proceed as follows. To show that Γ is the right adjoint to Δ we have to show that it actually maps to Lf and that Δ(p) ⊆ q ⇐⇒ p ⊆ Γ(q) for p ∈ Lf and q ∈ ¥.
To see that it maps to Lf is not difficult, using the fact that f is monotone and idempotent up to isomorphism: Suppose q ∈ ¥. Since f is monotone f−1 [q] is also upwards closed, whenever q is. Since q is upwards closed we have that f (f (m)) ∈ q if and only if f (m) ∈ q and so f−1 f−1 [q] = f−1 [q].
Now we show Δ(p) ⊆ q ⇐⇒ p ⊆ Γ(q).
⇒ Suppose Δ(p) ⊆ q. Then f−1 [p] ⊆ f−1 [q]= Γ(q) and since p ∈ Lf , p ⊆ f−1 [p], thus p ⊆ Γ(q).
⇐ Suppose p ⊆ Γ(q) = f−1 [q]. Then f [p] ⊆ f f−1 [q] ⊆ q. Since q is upwards closed and using the fact that f (m) ≤ m, this together implies Δ(p)= p ⊆ q.
Since infima and suprema are given by unions and intersections respectively it is immediate that Γ preserves them.	2
Lemma 4.2 Δ has a left adjoint Ξ: ¥→ Lf given by
Ξ(p)= \ {q ∈ Lf | p ⊆ q}

Proof This is an immediate consequence of Lemma 4.1 and [2, Corollary 9.32]. 2
Lemma 4.3 Γ has a right adjoint ∇, given by
∇(q)= [ {p ∈¥ | Γ(p) ⊆ q}
Further, ∇ is full and faithful.
Proof That Γ has a right adjoint given as above follows from the Lemma 4.1 and [2, Corollary 9.32].
For the second part, observe that we now have Δ E Γ E∇ and the result follows by [7, Lemma 1.3] and the fact that Δ is full and faithful.	2
Proposition 4.4 Lf is a complete Heyting subalgebra of ¥.
Proof By the above lemmas Lf has all infima and suprema. Since Γ is a right adjoint it preserves infima. Since ∇ is full and faithful with a left adjoint that preserves finite infima, Lf is (equivalent to) an exponential ideal of ¥ [8, A4.3.1], which implies that Lf is cartesian closed, i.e., a Heyting algebra.	2
We have shown that we have a sequence of adjunctions
Ξ E Δ E Γ E ∇,

where Δ and ∇ are full and faithful. Further, it does not seem that Ξ preserves infima or that ∇ preserves suprema so we cannot extend this sequence of adjunctions further.

Define  f : ¥ → ¥ as the interior operator arising from the adjunction Δ E Γ, explicitly
 f (p)= {m ∈M| f (m) ∈ p} = f−1 [p] .
When f is clear from the context we will write simply  for  f .
Lemma 4.5 The  operator satisﬁes the following properties.
preserves all inﬁma and suprema.
(p) ⊆ p for all p ∈ ¥.
is idempotent.
These follow immediately from properties of Δ and Γ stated above.
Separating conjunction and the  operator
Lemma 4.6 If the function f satisﬁes that for any m, f (m) · m ∼= m then
 (p) ∧ q ⊆  (p) ? q.
Corollary 4.7 If ≤ satisﬁes the conditions of Lemma 2.6 and f satisﬁes the con- dition in Lemma 4.6 then  (p) ?q =  (p) ∧ q and  (p)=  (p) ? p.
To summarise we have the following theorem.
Theorem 4.8 Let (M, ·, E, ≤) be an ordered partial commutative monoid and f : M → M an interior operator with respect to ≤. Then ¥ is a complete BI-algebra for operations deﬁned above. The subset Lf of ¥ consisting of ﬁxed points of  is a complete Heyting subalgebra of ¥.
Moreover.
If f satisﬁes f (m) · m  m for all m then  (p) ∧ q ⊆  (p) ? q.
If the order ≤ satisﬁes m ≤ m · n whenever m · n is deﬁned then p?q ⊆ p ∧ q.
Thus, starting with an ordered partial commutative monoid we construct a com- plete BI-algebra. Using this complete BI-algebra we construct a BI-hyperdoctrine which is a model of higher-order separation logic, together with a  modality which singles out the sublogic of persistent predicates which enjoy special properties with respect to separating conjunction, as explained in the above theorem.
The Interior Operator is Necessary
In this section we show that any complete sublattice L of ¥ for which the right adjoint G to the inclusion also preserves unions, is of the form Lf for an interior operator f . Moreover, if L⊆F then it must also be a subset of C, and we establish necessary and sufficient conditions for when Lf = C for some f . The characterisation uses the structure of the idempotents of M.
Thus we can state a form of completeness of the class of models. If we wish a well-behaved modality on ¥ then it must be of the form considered in Section 4 for

some function f . Further, if we wish that all predicates in Lf are duplicable then f must map into idempotents. Hence we show in particular that the notion of a core, as considered in Iris, is necessary as soon as we decide that we wish a well-behaved modality  in the logic. 4
Note that when we say L is a complete sublattice of ¥ we in particular mean that infima and suprema on L are inherited from ¥, i.e., they are intersections and unions, respectively.
In brief, if the monoid M satisfies the assumptions of Proposition 3.2, e.g., if it is extension order, then the complete sublattices L of ¥, which are included in F, can be depicted as follows.


Theorem 5.1 Suppose L is a complete sublattice of ¥. Let G : ¥→ L be the right adjoint to the inclusion L⊆ ¥. Then there exists an interior operator on M such that G = f−1.

Proof Since G is the right adjoint to inclusion and L and ¥ are posets we have for any p ∈¥ that p ∈L if and only if G(p)= p.
Let us look at L as a topology on M. Since it is by assumption closed under arbitrary intersections (it is an Alexandrov topology) points have least neighbour- hoods. For m ∈ M let N (m) ∈ L be the least neighbourhood of m. Then there exist some X ⊆M such that


N (m)= 
x∈X
↑x.





4 Note that some of the proofs in this section, in particular those which construct functions f , use choice, and are thus not constructive. For some monoids M and orders ≤ the use of choice can be avoided, but we do not study such conditions.

For instance take X = N (m). Hence
N (m)= G(N (m)) =	G (↑x)
x∈X
and so there exists x ∈ X such that m ∈ G(↑ x). But then G(↑ x) is clearly a neighbourhood of m, and so N (m)= G(↑x).
We now claim G(↑x) =↑x, for which it suffices to show ↑x ⊆ G(↑x). We have


↑x ⊆
x∈X
↑x = N (m)= G(↑x).

Thus N (m) =↑x. Moreover it is clear that this x is unique up to ∼=. Let f : M→M be a function which picks for each m an element f (m) such that N (m) =↑f (m). It is immediate that f is an interior operator.
Finally, let p ∈ ¥. Then p ∈L if and only if  m∈p N (m)= p, and so
G(p)= [ {N (m) | N (m) ⊆ p}
by the adjoint functor theorem for posets and the fact that N (m) generate L.
Hence m ∈ G(p) if there exists n, such that m ∈ N (n) and N (n) ⊆ p. But then N (n) is a neighbourhood of m and so N (m) ⊆ N (n) and thus we conclude m ∈ G(p) if and only if N (m) ⊆ p, or in other words, if and only if f (m) ∈ p.  2

Relationship between the two modalities
A natural question is how C and Lf , and □ and  are related.
Proposition 5.2 The set Lf is a subset of C if and only if f (m) · f (m) ∼= f (m)
for all m.
Proof For the first part suppose first that Lf ⊆ C and let m ∈ M. Since we always have ↑f (m) ∈ Lf from the fact that f is monotone and idempotent, we have
↑ f (m) ∈ C, hence there exists an element s ∼= f (m) such that s · s ∼= s. Hence
f (m) · f (m) ∼= f (m).
Conversely suppose f (m) · f (m) ∼= f (m) for all m and let p ∈ Lf . Then clearly for any m ∈ p there is an idempotent f (m) ∈ p below m, thus p ∈ C.	2
Proposition 5.3 If the order ≤ satisﬁes that for any two idempotents s1, s2, if s1 · s2 is deﬁned then either s1 ≤ s1 · s2 or s2 ≤ s1 · s2, then the set Lf is a subset of F (duplicable predicates) if and only if f (m) · f (m) ∼= f (m) for all m. Thus Lf ⊆F if and only if Lf ⊆ C.
Proof Suppose f (m) · f (m) ∼= f (m) for all m. Then by Proposition 5.2 Lf ⊆ C 
and so, using Proposition 3.2, we have Lf ⊆F as claimed.
Suppose now that Lf ⊆ F. Since f is idempotent we have ↑ f (m) ∈ Lf for all
m. Hence by Lemma 3.1 f (m) is idempotent for each m.	2

Lemma 5.4 The property  (p) ⊆ □(p) is equivalent to f (m) · f (m) ∼= f (m) for all
m.
Proof For the right to left direction assume f (m) · f (m) ∼= f (m) for all m. Let p ∈ ¥. If m ∈  (p) then f (m) ∈ p and thus m ∈ □(p), since f (m) is an idempotent. Suppose now that  (p) ⊆ □(p) for all p.	In particular  (↑ f (m)) ⊆ □(↑ f (m)) ⊆↑ f (m). Notice that ↑ f (m) =  (↑ f (m)). Thus □(↑ f (m)) =↑ f (m), which means in particular (because f (m) ∈↑f (m)) that there exists an idempotent s ∈↑ f (m) with f (m) ≤ s. Hence f (m) ∼= s, and thus f (m) · f (m) ∼= s · s ∼= s ∼= f (m).		2
Proposition 5.5 The lattices Lf and C coincide if and only if f is a retraction to the set of idempotents, i.e., if f (m) · f (m) ∼= f (m) for all m and f (s) ∼= s for all idempotents s.
Proof Suppose first that f is a retraction to the set of idempotents. Then we know from the previous lemma that (p) ⊆ □(p), so it suffices to show the converse inclusion. If m ∈ □(p) then there is an idempotent s ∈ p below m. But f (s) ∼= s, so f (m) ≥ f (s) ≥ s, hence m ∈  (p).
Suppose that Lf and C coincide. Let s be an idempotent. Then ↑ s ∈ C and so ↑ s ∈ Lf , but this means f (s) ∈↑ s, thus f (s) ≥ s, and since we always assume f (s) ≤ s we have f (s) ∼= s.	2
Finally we characterise exactly when such a retraction exists.
Proposition 5.6 Let I(m) be the set of idempotents below m. There exists a re- traction f in the sense of Proposition 5.5 if and only if I(m) has a greatest element for each m.
Proof Suppose a retraction f exists. We claim f (m) ∈ I(m) is the greatest element of I(m). This is immediate, since if s ∈ I(m) then s ∼= f (s) ≤ f (m) by monotonicity of f and the assumption that it is a retraction.
Suppose now that each I(m) has a greatest element. Let f be a function which for m ∈M picks one of the greatest elements f (m) ∈ I(m). It is clearly monotone, idempotent, and satisfies f (m) ≤ m, i.e., it is an interior operator. Moreover it clearly maps into idempotents and if s is an idempotent then s is the greatest element of I(s), and so f (s) ∼= s.	2
We now summarise the lemmas and propositions above in the useful case of monoids with extension order.
Theorem 5.7 Let M be a partial commutative monoid and ≤ the extension order on M. Then
C ⊆ F
Any modality  on ¥ that preserves unions and intersections and such that P is duplicable for any P is of the form f for some interior operator f mapping into idempotents. Moreover the set L of ﬁxed points of  is a subset of C.

The lattice C is of the form Lf for some (necessarily unique up to ∼=) f if and only if for each element m ∈M the set of idempotents below m has a greatest element. Moreover, this is the case if and only if C is closed under arbitrary intersections. Finally, in such case the modalities  and □ coincide.
Interior operators f mapping into idempotents correspond to the core operation of Iris. What we have shown is that the choice made in Iris is necessary if we wish to have a well-behaved sublogic of persistent predicates, all of which are duplicable. Moreover, we have shown conditions under which a largest such sublogic exists. This is exactly when the set of idempotents below m has a greatest element for any
m. For many of the monoids considered in practice, and in Iris, there will in fact be a unique idempotent below every element m, and thus there will automatically be the greatest one.
Changing the Ambient Logic
In this section we show how some previous results found in the literature are in- stances of the above constructions. In particular by working in an ambient logic of the topos of trees [5] we recover the notion of complete metric resource algebra [9], from the notion of a resource algebra, thus showing in particular that the notion of a complete metric resource algebra and the model derived from it are natural and canonical.
A resource algebra is a notion of resources used in the model of the Iris program logic, which is a very general program logic which can be used for reasoning about fine grained concurrent algorithms, but also as a metalanguage for constructing models of programming languages via logical relations. Iris simplifies these by abstracting handling of resources, such as heaps, and invariants.
Definition 6.1 [[9,11]] A (unital) resource algebra is a structure (M, ·, ε, |·| , V) such that (M, ·, ε) is a commutative monoid, |·| : M → M called the core is a monotone function with respect to the extension order of M, and V ⊆ M is a subset of so-called valid elements which is downwards closed with respect to the extension order and contains the unit. Additionally the core is assumed to be an interior operator (with respect to the extension order of M) which maps into idempotents of M.
Remark 6.2 There is also a notion of a non-unital resource algebra [9]. These are used as intermediate steps in the construction of a unital resource algebras which is used in the construction of the model. Since we are interested in the model we only focus on unital resource algebras in connection with ordered partial commutative monoids.
A (unital) resource algebra gives rise to a complete BI-algebra by taking upwards closed subsets of valid elements with respect to the extension order:
P† (V)= {p ⊆V | ∀m ∈ p, ∀n ∈ V,n ≥ m ⇒ n ∈ p} .



Remark 6.3 In the actual model of Iris one instead takes upwards closed subsets of M but only upwards closed with respect to the valid elements, quotiented by the relation equating two subsets if they agree on the valid elements. This is clearly order-isomorphic to P† (V) defined above so we choose to work with the above presentation since it is simpler for our purposes.
The notion of a (unital) resource algebra is subsumed by the notion of a partial commutative monoid with regards to models as explained in the following proposi- tion.
Proposition 6.4 For any unital resource algebra (M, ·, ε, |·| , V) there exists an ordered partial commutative monoid (Mj, ·, E, ≤) such that the complete BI-algebras P† (V) and ¥ (as deﬁned in Section 2) are isomorphic.
Moreover the core |·| gives rise to an interior operation f : Mj → Mj satisfying assumptions of Theorem 4.8.
Proof Given a unital resource algebra as in the statement of the proposition define Mj to be the set of valid elements V. Let E = {ε} and let ≤ be the extension order. Finally we define the partial multiplication · on Mj as a function · : Mj × Mj → S (Mj) into the set of subsingletons, 5 using the fact that the set of subsingletons is the partial map classifier [8, A2.4]. Define for m, n ∈ Mj the element m· n ∈ S (Mj) as
m · n = {m · n | m · n ∈ V}
It is clear that with these definitions we have the equivalence of P† (V) and ¥
as defined above. 6
The assumptions on the core in a unital resource algebra ensure that it restricts to a function V → V, and by assumption the core is an interior operator which also satisfies assumptions of Theorem 4.8.	2
Resource algebras in the topos of trees
The equivalence and constructions described above are valid in any topos. Hence we can read the definitions in particular in the topos of trees S [5], the presheaf category over the first infinite ordinal ω. Recall that objects of this category are families of sets and restriction functions

r	r
1  X2  X3
r3	··· 

The full subcategory of S on those objects whose restrictions are surjective (such objects are called total ) is equivalent to the category of complete ordered families of
5 Classically S (n′) = 1 + n′, of course, however we do not wish do use classical reasoning principles because we will later apply this result in the topos of trees, whose logic is not classical.
6 Note that the correct definition of “m · n defined” is that the subsingleton m · n is inhabited.

equivalences (COFE) [5] whose objects are sets X together with a family of equiv- alence relations =n indexed by natural numbers n and satisfying suitable closure and completeness conditions. A morphism between such objects is a function which respects the equivalence relations (the non-expansive functions) in the sense that for any n ∈ N we have
x =n y ⇒ f (x) =n f (y).
Let U be the category of COFEs.
Indeed, given an object X in the topos of trees the COFE X corresponding to it is defined as
X = {{xn}n∈N | xn ∈ Xn ∧ rn(xn+1)= xn}
which is the set of global sections of X. The equivalence relations are defined as
{xi}i∈N =n {yi}i∈N whenever xn = yn.
With this presentation a subobject A of a total object X can be described as a family of subset An ⊆X such that An+1 ⊆ An for all n and additionally satisfying for any x, y ∈ X such that x =n y then x ∈ An ⇔ y ∈ An.
Similarly, a monoid in S whose carrier is total can be presented as an ordinary monoid M equipped with a family of equivalence relations =n making M a COFE, such that the operation · is non-expansive.
With these equivalent we have the following proposition relating resource alge- bras and CMRAs. To state it we recall the definition of a complete metric resource algebra [9].
Definition 6.5 [CMRA] A (unital) complete metric resource algebra [9] is a tuple (M, {Vn}n∈N, |·| , ·, ε)
such that M is a COFE, (M, |·| , ε) is a commutative monoid, the functions |·| and the multiplication · are non-expansive and the structure satisfies the following additional axioms.
∀n, a, b, a =n b ⇒ a ∈ Vn ⇔ b ∈ Vn
∀m, n, m ≥ n ⇒ Vm ⊆ Vn
∀a, |a|· a = a
∀a, ||a|| = |a|
∀a, b, a ≤ b ⇒ |a|≤ |b|
∀n, a, b, a · b ∈ Vn ⇒ a ∈ Vn
∀n, ε ∈ Vn
where the order ≤ is extension order.
Remark 6.6 A unital CMRA in [9] must satisfy the following axiom
∀n, a, b1, b2,a ∈ Vn ∧ a =n b1 · b2 ⇒ ∃c1, c2,a = c1 · c2 ∧ c1 =n b1 ∧ c2 =n b2.

This is needed to validate certain interactions between the later modality d and separating conjunction, but is not essential for any of the basic rules and connectives we are considering, hence we omit it in the rest of the paper.
Proposition 6.7 A unital complete metric resource algebra (CMRA) [9,11] is sim- ply a unital resource algebra (M, ·, ε, |·| , V) in the topos of trees which additionally satisﬁes that the carrier M is a total object.
The proof of this proposition is straightforward, using the equivalences described at the beginning of this section.
The above proposition, together with Proposition 6.4, shows that the notion of a complete metric resource algebra is just a presentation of a partial commutative monoid in the topos of trees.
To claim that Proposition 6.7 together with Proposition 6.4 imply that the model of (a large part of) Iris can be recovered from the general constructions of the preceding sections we must explain in what way carrying out constructions in the internal logic of the topos of trees gives the same result as the externally constructed model. The precise statement is the following theorem.
Theorem 6.8 Let p : E → S be the S-based hyperdoctrine presented as a ﬁbration and derived from an RA M internal to the topos of trees. Let ι : U → S be the inclusion of the category of COFEs to the topos of trees and suppose that M is in the image of ι of a CMRA Mj. There is a pullback situation
U ×E E	E
τ
pI	p

U	ι	S

such that pI is the hyperdoctrine derived from the CMRA Mj which is used to model the Iris program logic.
Thus all the operations defined for the model of Iris derived from a complete metric resource algebra are determined from the same general principles as in the case without step-indexing. They are but a particular presentation of the general construction carried out in the topos of trees.

6.2  Adding guarded recursion
Since the topos of trees is a model of guarded recursive terms [5] all predicates in S come equipped with a L¨ob induction principle. Since predicates in the logic such as Iris are modelled as particular predicates of S we have that in addition to the constructs considered above, we can also model the later modality and its properties, in particular L¨ob induction. This modality is essential in a higher- order separation logics such as Iris and iCAP to be able to deal with so-called

impredicative invariants, which are in turn needed for verifying intricate concurrent algorithms and data structures.
Conclusion and Future Work
We have shown how a modicum of categorical logic can be used to give a gen- eral account of models of higher-order separation logic with a sublogic of persistent predicates. In particular, we have shown that changing the ambient category pro- vides a systematic way to obtain models supporting guarded recursive predicates, as used, e.g., in the model of Iris, a state-of-the-art higher-order separation logic with guarded recursive predicates. In the future, we are interested in employing this systematic approach to investigate variations of models which combine linear and separation logic together with guarded recursive predicates. Such combinations of linearity and separation are useful for tracking resource usage more precisely, as, e.g., demonstrated in recent work by Tassarotti et. al. [17].
Acknowledgement
This research was supported in part by the ModuRes Sapere Aude Advanced Grant from The Danish Council for Independent Research for the Natural Sciences (FNU).

References
Andrew W. Appel. Program Logics - for Certified Compilers. Cambridge University Press, 2014.
S. Awodey. Category Theory. Oxford Logic Guides. OUP Oxford, 2010.
Jesper Bengtson, Jonas Braband Jensen, Filip Sieczkowski, and Lars Birkedal. Verifying object- oriented programs with higher-order separation logic in coq. In Interactive Theorem Proving - Second International Conference, ITP 2011, Berg en Dal, The Netherlands, August 22-25, 2011. Proceedings, pages 22–38, 2011.
Bodil Biering, Lars Birkedal, and Noah Torp-Smith. Bi-hyperdoctrines, higher-order separation logic, and abstraction. ACM Transactions on Programming Languages and Systems (TOPLAS), 29(5):24, 2007.
Lars Birkedal, Rasmus Ejlers Møgelberg, Jan Schwinghammer, and Kristian Støvring. First steps in synthetic guarded domain theory: step-indexing in the topos of trees. Logical Methods in Computer Science, 8(4), 2012.
Adam Chlipala. The bedrock structured programming system: combining generative metaprogramming and hoare logic in an extensible program verifier. In ACM SIGPLAN International Conference on Functional Programming, ICFP’13, Boston, MA, USA - September 25 - 27, 2013, pages 391–402, 2013.
Roy Dyckhoff and W Tholen. Exponentiable morphisms, partial products and pullback complements.
Journal of Pure and Applied Algebra, 49:103–116, Nov 1987.
Peter T. Johnstone. Sketches of an Elephant: A Topos Theory Compendiumm vol. 1 (Oxford Logic Guides, 43). Oxford University Press, USA, November 2002.
Ralf Jung, Robbert Krebbers, Lars Birkedal, and Derek Dreyer. Higher-order ghost state. In Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming, ICFP 2016, pages 256–269, New York, NY, USA, 2016. ACM.
Ralf Jung, David Swasey, Filip Sieczkowski, Kasper Svendsen, Aaron Turon, Lars Birkedal, and Derek Dreyer. Iris: Monoids and invariants as an orthogonal basis for concurrent reasoning. In Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL ’15, pages 637–650, New York, NY, USA, 2015. ACM.


Robbert Krebbers, Ralf Jung, Aleˇs Bizjak, Jacques-Henri Jourdan, Derek Dreyer, and Lars Birkedal. The essence of higher-order concurrent separation logic. In ESOP, 2017.
Robbert Krebbers, Amin Timany, and Lars Birkedal. Interactive proofs in higher-order concurrent separation logic. In Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages, POPL 2017, pages 205–217, New York, NY, USA, 2017. ACM.
F.W. Lawvere. Adjointness in foundations. Dialectica, 23:281–296, 1969.
Zhaozhong Ni and Zhong Shao. Certified assembly programming with embedded code pointers. In Proceedings of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2006, Charleston, South Carolina, USA, January 11-13, 2006, pages 320–333, 2006.
Francois Pottier. Syntactic soundness proof of a type-and-capability system with hidden state. Journal of Functional Programming, 23(1):38–144, January 2013.
Kasper Svendsen and Lars Birkedal. Impredicative concurrent abstract predicates. In ESOP, pages 149–168, 2014.
Joseph Tassarotti, Ralf Jung, and Robert Harper. A higher-order logic for concurrent termination- preserving refinement. In Proceedings of ESOP, 2017.
Aaron Turon, Derek Dreyer, and Lars Birkedal. Unifying refinement and hoare-style reasoning in a logic for higher-order concurrency. In Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming, ICFP ’13, pages 377–390, New York, NY, USA, 2013. ACM.
