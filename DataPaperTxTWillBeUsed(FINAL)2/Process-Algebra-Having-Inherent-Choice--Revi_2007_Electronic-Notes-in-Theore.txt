Electronic Notes in Theoretical Computer Science 192 (2007) 45–60	
www.elsevier.com/locate/entcs

Process Algebra Having Inherent Choice: Revised Semantics for Concurrent Systems 1
Harald Fecher2
Department of Computing Imperial College
London, UK
Heiko Schmidt3
Institut fu¨r Informatik Christian-Albrechts-Universita¨t Kiel, Germany

Abstract
Process algebras are standard formalisms for compositionally describing systems by the dependencies of their observable synchronous communication. In concurrent systems, parallel composition introduces resolvable nondeterminism, i.e., nondeterminism that will be resolved in later design phases or by the operating system. Sometimes it is also important to express inherent nondeterminism for equal (communication) labels.
Here, we give operational and axiomatic semantics to a process algebra having a parallel operator interpreted as concurrent and having a choice operator interpreted as inherent, not only w.r.t. different, but also w.r.t. equal next-step actions. In order to handle the different kinds of nondeterminism, the operational semantics uses μ-automata as underlying semantical model. Soundness and completeness of our axiom system w.r.t. the operational semantics is shown.
Keywords: nondeterminism, process algebra, axiom system, expansion theorem, μ-automata


Introduction
Process algebras, see [2] for an overview, are standard formalisms for composition- ally describing systems based, e.g., on synchronous communication on an abstract level by the dependencies of their observable communication. They serve as a do- main for semantical foundations of programming or modeling languages and are also used as modeling languages [6].

1 This work is in part financially supported by the DFG project Refism (FE 942/1-1)
2 Email: hfecher@doc.ic.ac.uk
3 Email: hsc@informatik.uni-kiel.de

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.08.016

  ,,. , ,,¸ request ,,. , ,,¸ sendPhoto ,,. , ,,¸	  ,,. , ,,¸ 

r¸eque¸st	r¸eque¸st	r¸eque¸st
r¸eque¸st

cancel	¸z,,. ,,,  ˛request ¸ z,,. , ,,  ˛sendPhoto ¸ z,,. ,,, ˛
cancel	¸z,,. , ,,  ˛request ,,. , ,,¸ sendPhoto ,,. ,,,¸ 

J	¸¸
¸¸	¸¸
J	¸¸	¸	¸

,,. , ,,¸¸	sendD¸o¸c z˛ sendD¸o¸c z ˛ sendD¸o¸c z˛
	
,,. , ,,¸¸	sendD¸o¸c z˛ sendD¸o¸c z ˛ sendD¸o¸c z˛

cancel
reque¸st
,,. , ,,
request ,,. , ,, sendPhoto ,,. , ,, 
cancel
reque¸st
,,. , ,,
request ,,. , ,, sendPhoto ,,. , ,, 

¸z,,. , J,,
˛ 
cancel
¸z,,. , J,,
˛ 
cancel

¸¸
¸¸z,,. , J,, ˛  M
¸¸
¸¸z,,. , J,,
˛  M^rs

Fig. 1. The transition system Mc corresponding to the semantics of (1) and a refinement Mcrs of Mc w.r.t.
ready simulation
Example 1.1 Suppose there are two processes running concurrently on a single processor computer that both have the possibility to send print jobs to a printer. Prior to sending the data to the printer, any process must gain exclusive access to the printer by synchronizing on an action request. After that, the print job can be sent. In our example, the first process sends a photo (sendPhoto), whereas the second sends a document (sendDoc). Furthermore, the first process can be disrupted by a user via action cancel. This simplified concurrent system (in a parallel environment) can be modeled in process algebra based on synchronous communication by
(request.sendPhoto + cancel) (request.sendDoc)
where the printer and the user that can disrupt belong to the environment. Here, operator  denotes parallel composition, a.B denotes action prefix, and + denotes the choice operator. The semantics of (1) in terms of transition system is given by M^ of Figure 1.
In the transition system of the above example two kinds of choice can be dis- tinguished: (i) External choice represented by outgoing edges with different labels. This choice occurs in implementations and remains undecided until in an execution the environment decides which of the possible actions is performed. (ii) Internal (nondeterministic) choice represented by outgoing edges with the same labels. This nondeterminism is resolved by the scheduler 4 of the operating system, since the two processes run on a single processor computer: The scheduler will decide which process may perform its request action, i.e., synchronize to get exclusive access to the printer. This refinement, performed by adding the scheduler, is formally made precise by ready simulation [5], which essentially allows the removal of multiple outgoing edges with the same label, as long as one remains (see Figure 1).
Nondeterminism that will be removed in later design phases or by the operating system is called resolvable nondeterminism, whereas nondeterminism that has to re- main in implementations and is decided independently for each execution (e.g., by random), is called inherent nondeterminism. Consequently, the nondeterminism in- troduced by abstracting from schedulers in a concurrent setting is resolvable. Note, however, that in standard semantics based on bisimulation the abstraction from schedulers can be regarded as inherent (since transition systems with bisimulation cannot express resolvable nondeterminism). We consider this to be counterintuitive in most cases, because schedulers usually do not show “random” behaviour that is determined independently for each execution.

4 In a generative rather than reactive setting, different outgoing labels can also express internal choice and thus be resolved by the scheduler. However, this paper only considers reactive systems.

Branching time logics, like the modal μ-calculus [17], are often used for describ- ing properties of process algebras. Unfortunately, they are not preserved under refinement based on ready simulation. Consider, e.g., the statement that there is an immediate request action enabled such that afterwards no document can be sent to the printer. This property is described by the μ-calculus formula
⟨request⟩ ([sendDoc] false ).
Property (2) holds in M^ of Figure 1, but not in its refinement M^rs of Figure 1. This
illustrates that branching times properties applied to a concurrent setting need to be interpreted w.r.t. sets of schedulers: ⟨a⟩ φ requires the existence of a scheduler such that φ holds after the execution of a, and [a] φ states that, independent of which scheduler is chosen, φ will hold after the execution of a. Consequently, property (2) has to be understood as follows: There is a scheduler for the next step such that request is enabled and its execution (which is deterministic if the scheduler is given) leads to a state where sendDoc is for any scheduler disabled. Since the refinement in Figure 1 specializes schedulers, μ-calculus formula (2) is not preserved.
In Example 1.1, we illustrated that resolvable nondeterminism naturally arises through parallel composition. In the following examples we argue that also inher- ent nondeterminism, i.e., internal choice that remains in running implementations, occurs in applications:
Example 1.2 In the situation of Example 1.1, assume a faulty channel between the first process and the printer. Then it is possible that a signal request (e.g., encoded as 1) can be turned into a signal cancel (e.g., encoded as 0). This is reflected by the process algebra term
(request.sendPhoto + request + cancel) (request.sendDoc) .
We get inherent nondeterminism w.r.t. the same label request, because in case of a faulty transmission it has to be handled as an action cancel. The nondeterminism is inherent, because refinement cannot decide on the existence of a fault, this is decided for every execution.
Example 1.3 In the situation of Example 1.1, consider request to be an abstract action [25] for more refined labels like requestLowRes and requestHighRes, where the first establishes access to the low resolution printing features of the printer, and the second gains access to the high resolution features. Then, based on the printing capabilities offered by the printer, the usual photo can be sent (sendPhoto) or a low resolution alternative (sendLowResPhoto). This is reflected by the following process algebra term having inherent nondeterminism w.r.t. the same label request:
(request.sendPhoto + request.sendLowResPhoto + cancel)  (request.sendDoc) .
Note that in these scenarios we have both inherent nondeterminism, introduced
by the choice operator of the first process, and resolvable nondeterminism, intro- duced by the unknown scheduler of the parallel composition. In case there is no resolvable nondeterminism, i.e., if we consider concrete systems only with inherent nondeterminism, transition systems together with bisimulation as underlying equiv- alence notion is an appropriate semantical model. Here, bisimulation equivalence

is a specialization of ready simulation for concrete systems, i.e., a ready simulation between concrete systems implies bisimilarity. The μ-calculus yields a suitable logic, since it characterizes transition systems up to bisimulation.
Nevertheless, transition systems are not an appropriate model whenever inher- ent and resolvable nondeterminism occur in a single setting, like in Examples 1.2 and 1.3. This is because a choice for an underlying equivalence or preorder has to be made: Bisimulation interprets nondeterminism as inherent, ready simula- tion as resolvable. Furthermore, when using resolvable nondeterminism, we expect a three-valued satisfaction interpretation over the μ-calculus, with the possibil- ity that a formula is neither satisfied nor falsified. For example, we expect that
⟨request⟩ ((⟨sendDoc⟩ true ) ∨ (⟨sendLowResPhoto⟩ true )) holds in (4), since all its implementations do, but property (2) is “unknown” for (4), since there are imple- mentations that satisfy the property and there are implementations that do not.
Contribution. We give an operational and an axiomatic semantics to a pro- cess algebra having a parallel operator interpreted in a concurrent (rather than distributed) setting and a choice operator interpreted as inherent, not only w.r.t. different, but also w.r.t. equal next-step actions. In particular, we adjust the se- mantics of [3], which has an inherent as well as a resolvable choice operator, to our interpretation of parallel composition, since in their interpretation parallel compo- sition yields inherent nondeterminism. In order to handle the two kinds of nonde- terminism adequately, a semantical model with two kinds of transition relations, as in [3] and [14], is used, namely μ-automata [16] with their standard refinement notion and their three-valued satisfaction relation over the μ-calculus. The two transition relations are defined using structural operational semantics. One rela- tion corresponds to the execution of actions, the other corresponds to the removing of the underspecification for the next action execution, which is called concretiza- tion. In order to develop an axiomatic semantics, the process algebra is extended by further operators, especially by a choice operator corresponding to resolvable nondeterminism. From our axiom system, we derive an expansion theorem, which expresses the parallel composition operator in terms of choice operators. Soundness and completeness of this axiom system w.r.t. the operational semantics is shown.

Syntax
In order not to distract from the technical problems and their solutions, we only present a simple process algebra that does not have recursion, sequential compo- sition, and parallel composition with a synchronization mechanism. Our process algebra consists of action prefix, inherent nondeterminism, parallel composition, and action renaming. Note that a (CSP-based) hiding operator is a special case of a renaming operator, where the action is renamed to the internal action. Here, we follow the philosophy that internal actions are observable. In other words, we do not consider weak equivalence or weak refinement notions. Furthermore, we assume that nondeterminism obtained via “mixed choices” is resolved inside the environ- ment: For example, if the system provides actions a and b and the environment their

corresponding counterparts, then the environment decides if a or b is executed. 5 The renaming/hiding operator is also of special interest in our setting, since it intro- duces nondeterminism, too. For example, the process that provides action a leading to B1 and that provides action b leading to B2 does not contain nondeterminism, but after hiding a and b, i.e., renaming a and b to the internal action, a nondeter- minism occurs, since now an internal step either leads to B1 or to B2. Again, the two interpretations of inherent or resolvable nondeterminism are possible for the renaming operator. But in our setting the nondeterminism obtained through hid- ing (and therefore implicitly for renaming) should be a resolvable nondeterminism, which is argued as follows: The system has a stimulus for any hidden action. These can be considered to be provided by an additional component continuously provid- ing hidden actions. Then the scheduler of the parallel composition decides, which parallel component executes next. Consequently, hiding (and therefore renaming) yields resolvable nondeterminism with our interpretation of schedulers of parallel components, which assumes that schedulers do not behave randomly.
Before we formally present our process algebra, we introduce some notations. Let Act denote the set of all actions, let |S| denote the cardinality of a set S, and let P(S) denote its power set. Furthermore, ◦ denotes relational composition. For a binary relation ρ ⊆ S × I with subsets X ⊆ S and Y ⊆ I we write X ◦ ρ for
{i ∈ I | ∃x ∈ X : (x, i) ∈ ρ} and ρ ◦ Y for {s ∈ S | ∃y ∈ Y : (s, y) ∈ ρ}. For a
ternary relation ~⊆ S × Act × I we write s ~a i for (s, a, i) ∈~, and we write ~a
for the binary relation {(s, i) | s ~a i}, thus {s}◦ ~a = {i ∈ I | s ~a i}. Furthermore, we write s ~/ a , iff {s}◦ ~a = ∅.
PA, the set of all basis process algebra terms, is generated by
B ::= 0 | a.B | B + B | B  B | B⟨a/b⟩ ,
where a, b ∈ Act. Process 0 describes a deadlocked process, i.e., no further actions can be executed. We sometimes omit symbol 0 by writing a instead of a.0. Process
a.B allows the execution of action a resulting in the process B. Inherent choice is described by B1 + B2, and B1  B2 describes parallel composition. The parallel com- position has implicit resolvable nondeterminism, introduced by abstraction from a scheduler favoring one of the two sides. B⟨a/b⟩ describes the process where the execution of a in B becomes the execution of b. All other action execution, includ- ing action b, remains unaffected. Note that this renaming process also introduces resolvable nondeterminism as described in the beginning of this section.

Operational Semantics
μ-automata
As underlying semantical model we use μ-automata [16] in the notation of [9], except that we omit fairness constraints and that we do not consider propositions.

5 Otherwise, the system has to resolve this nondeterminism in which case two communications instead of one have to be modeled: The environment sends its provided actions and the system answers which action it chooses.

Definition 3.1 [μ-automata] A μ-automaton M w.r.t. Act is a tuple (S, S, si, ⇒,
'−→) such that (s ∈)S is the set of OR-states, (s˜ ∈)S the set of BRANCH-states
(disjoint from S), si ∈ S its initial element, ⇒ ⊆ S × S the OR-transition relation, and '−→⊆ S˜ × Act × S the BRANCH-transition relation.
The BRANCH-states do not contain underspecification for the next action ex- ecution, whereas OR-states can be underspecified in that sense. This underspeci- fication is resolved via the OR-transition relation (for this reason also called con- cretization relation), which is made precise by the standard refinement notion of μ-automata:
Definition 3.2 [μ-refinement] A relation R ⊆ (S1 ×S2)∪(S1×S2) is a μ-reﬁnement
between two μ-automata M1 and M2 if (si , si ) ∈ R and
1	2
∀(s1, s2) ∈ R, s˜1 ∈ ({s1}◦ ⇒): ∃s˜2 ∈ ({s2}◦ ⇒): (s˜1, s˜2) ∈ R,
∀(s˜1, s˜2) ∈ R, a ∈ Act, s1 ∈ ({s˜1}◦ '−a→): ∃s2 ∈ ({s˜2}◦ '−a→): (s1, s2) ∈ R, and
∀(s˜ , s˜ ) ∈ R, a ∈ Act, s ∈ ({s˜ }◦ '−a→): ∃s ∈ ({s˜ }◦ '−a→): (s ,s ) ∈ R.
1	2	2	2	1	1	1	2
M1 μ-reﬁnes M2 if there exists a μ-refinement R between M1 and M2.
Labeled transition systems are straightforwardly embedded into μ-automata by using OR-states having exactly one outgoing transition. The restriction of μ- refinement onto these systems coincides with bisimulation. As commonly known, μ-refinement yields a partial order. Furthermore, μ-automata come with a three- valued satisfaction relation over the μ-calculus, which is preserved under refinement.
Operational semantics rules
In order to define the operational semantics we use two different kinds of expressions: one where underspecification for the next step is allowed (PA, corresponding to the OR-states) and one where it is not (PAcon, corresponding to the BRANCH- states), i.e., where the resolvable nondeterminism for the next execution is resolved. Then additionally to the step transition relation ('−→, corresponding to BRANCH-
transition relation) from PAcon to PA, a concretization relation (⇒, corresponding to the OR-transition relation) from PA to PAcon, which resolves the resolvable
nondeterminism for the next execution, is used. Formally, PAcon denotes the set of all process algebra terms generated by
P ::= [0] | [a.B^] | P + P | P |⟩Bb,A,Be P | P ⟨a/b, v⟩ ,
where a, b ∈ Act, A ⊆ Act, B^, B˜ ∈ PA, and v ∈ {d, s}. The intuition of the
operators is similar to the one of the operators given in Section 2, except that here the scheduler of the parallel composition and of the renaming operator is determined for the next step. First, we explain the intuition of parallel composition P1|⟩B1 ,A,B2 P2, at first neglecting B1 and B2, which will be explained later, and using the notation P1|⟩AP2 instead. Here, A specifies a scheduler, which is not necessary in standard semantics based on ready simulation, since there schedulers are adequately handled via the ready simulation. However, the scheduler needs to be modeled if

both resolvable nondeterminism and inherent choice should appear in one setting. The scheduler information is interpreted as follows: The right side is favored in P1|⟩AP2 for actions from A, whereas the left side is favored for actions from Act \ A. This favoring concerns only the next step, i.e., after the execution of an action, any scheduling is allowed again. This is even the case if an action in parallel to P1|⟩AP2 is executed, e.g., if P3 executes action a leading to B3 in (P1|⟩AP2)|⟩AP3 the resulting process is, roughly speaking, (P1  P2)  B3, where all next step scheduling is removed. Note that this approach is more appropriate than the approach where the partial scheduler is kept (in which case (P1|⟩AP2)  B3 would be the result), since the scheduler is global and therefore can depend on any past execution. 6 Furthermore, associativity of  would be lost in the alternative approach, which is illustrated later in Example 3.5. In order to model the undoing of the scheduler information efficiently, the parallel composition stores the original processes of its components (here B1 and B2) and replaces the non-executing component by its stored original one, where no scheduler information is present. This will be clarified by the transition rules.
The scheduler information of the next execution v is added to the renaming operator: The execution of the action corresponding to the source label a of the renaming, which becomes b, is favored in B⟨a/b, s⟩, whereas the execution of the ac- tion corresponding to the destination label b is favored in B⟨a/b, d⟩. Here, favoring means that for B⟨a/b, d⟩, process B may only execute a (which will be renamed to b) if B cannot execute b and analogously for B⟨a/b, s⟩, where a is favored. Again, this scheduling of the renaming operator only applies for the next action execution, i.e., after the execution of any action, possibly different from b, the current favoring is removed.
The concretization relation ⇒ is given in the upper section of Table 1, where the underspecification of the next step is resolved, and the step transition relation '−→
is presented in the lower section of Table 1, where actions are executed resulting in processes having underspecification for the next step executions. We give some
comments on ⇒: The resolution of next-step-underspecification has to take place in every subpart that can potentially make the next execution, consequently resolution
does not take place for B in a.B. In the parallel composition, however, the next- step-underspecification is resolved by choosing an arbitrary scheduler. The parallel composition operator stores the original processes such that it can efficiently undo the concretization. In the renaming operator, the next-step-underspecification is resolved by either favoring the action corresponding to the source label (s) or fa- voring the action corresponding to the destination label (d) of the renaming. We proceed with some comments on '−→: The rules for [a.B] and P1 + P2 are standard. The left side of the parallel composition P1|⟩B3 ,A,B4 P2 can execute a if (i) the left side is favored for a by the scheduler (a ∈/ A) or (ii) the right side does not provide a (P2 '/−a→). Symmetric constraints hold for the execution of a on the right side of P1|⟩B3 ,A,B4 P2. As already mentioned before, the next-step-underspecification reso-

6 The approach where the partial scheduler is kept makes only sense if each parallel component has its own scheduler and there is an additional global scheduler which decides which of the parallel components is favored.


0 ⇒ [0]	a.B ⇒ [a.B]
B1 ⇒ P1	B2 ⇒ P2	A ⊆ Act B1  B2 ⇒ P1|⟩B1,A,B2 P2
B1 ⇒ P1	B2 ⇒ P2
B1 + B2 ⇒ P1 + P2
B ⇒ P	v ∈ {d, s} B⟨a/b⟩ ⇒ P ⟨a/b, v⟩







[a.B] '−a→ B
i ∈ {1, 2}	Pi '−a→ B P1 + P2 '−a→ B

P1 '−a→ B1
a ∈ A ⇒ P2
/'−a→
P '−→c  B	c ∈/ {a, b}

P |⟩
P '−a→ B B
P ⟨a/b, v⟩ '−→c
B⟨a/b⟩

1  B3,A,B4  2	1	4

P2|⟩B4,Act\A,B3
P1 '−a→ B4  B1

P '−→b
B	v = s ⇒ P /'−a→
P '−a→ B	v = d ⇒ P '−→b

P ⟨a/b, v⟩ '−→b
B⟨a/b⟩
P ⟨a/b, v⟩ '−→b
B⟨a/b⟩

Table 1
Upper section: Resolving of the next-step-underspecification via relation ⇒⊆ PA × PAcon. Lower section: Action executions via '−→⊆ PAcon × Act × PA.

lution has to be undone for the parallel component that did not make the execution. Therefore, process B3, resp. B4 replaces the non-executed side. In P ⟨a/b, v⟩ an ac- tion c different from a and b can be executed leading to B⟨a/b⟩, whenever P can execute c leading to B. This is stated in the first rule. Furthermore, P ⟨a/b, v⟩ can execute b, leading to a process B⟨a/b⟩, where B can be obtained after executing b in P , whenever v favors the destination label (v = d) or no action a is provided by
P . Similarly, P ⟨a/b, v⟩ can execute b, leading to a process B⟨a/b⟩, where B can be obtained after executing a in P , whenever v favors the source label (v = s) or no action b is provided by P . In all these three cases, the scheduler is removed after the execution. Note that by definition, the target processes of '−→ do not contain any scheduling information.
Definition 3.3 [Operational semantics] The operational semantics of a process al- gebra term B ∈ PA is the μ-automaton (PA, PAcon, B, ⇒, '−→), where ⇒ and '−→
are given in Table 1. We say that a process algebra term B from PA reﬁnes another
one B', written B ≤ B', if the operational semantics of B μ-refines the operational semantics of B'. Furthermore, B is reﬁnement equivalent to B', written B ≡ B', if B refines B' and B' refines B.
Example 3.4 The operational semantics for (a + a.b)  a is illustrated in Figure 2.
Example 3.5 We illustrate that associativity of the parallel composition does not hold, if the resolution of underspecification in the parallel composition rule of Table 1 is not undone, i.e., if the original process does not replace the current process in case of non-execution. Under this assumption, B˜1 = a.b  (a  a.c) does not refine B˜2 = (a.b  a)  a.c: By definition B˜1 ⇒ [a.b] |⟩Act([a] |⟩Act[a.c]). Since action c has to be
possible afterwards, this process can only be adequately matched by B˜2 viaa process
that is refinement equivalent to ([a.b] |⟩{a} [a])|⟩{a} [a.c] or to ([a.b] |⟩∅ [a])|⟩{a} [a.c].








J˜

a

,¸



Fig. 2. The operational semantics for (a + a.b)  a, where Act = {a, b}. OR-states of the μ-automaton have double-lined frames, whereas BRANCH-states have single-lined frames. OR-transitions are drawn as double-line arrows, whereas BRANCH-transitions are drawn as labeled single-line arrows. A state described by a set stands for a set of states, described by the elements of the set and having the same incoming and outgoing transitions as the state labeled with the set.
Thus after the execution of a we would need that a.b  (a  c) refines ([a.b] |⟩{a} [a])  [c] or refines ([a.b] |⟩∅[a])  [c]. Furthermore, a.b  (a  c) can be concretized such that either b is possible after the execution of a or no b is possible after the execution of a. But only one of these concretizations is possible in ([a.b] |⟩{a} [a])  [c] and in ([a.b] |⟩∅ [a])  [c]. Hence, B˜1 does not refine B˜2.
Example 3.6 Process a.(B1  (a.B2)) refines (a.B1)  (a.B2), but not vice versa. This illustrates that refinement over PA does not yield an equivalence relation.
Theorem 3.7 Reﬁnement is preserved under all process algebra operators, i.e., if
B1 ≤ B' ∧ B2 ≤ B' then a.B1 ≤ a.B' ∧ B1 + B2 ≤ B' + B' ∧ B1  B2 ≤ B' B' ∧
1	2	1	1	2	1	2
B1⟨a/b⟩ ≤ B' ⟨a/b⟩.
Note that the straightforward extension of ≤ to PAcon is also preserved under all process algebra operators for PAcon.

Axiomatic Semantics
In this section, we present a sound and complete axiom system for the refinement over PA.
Process algebra extension
In order to define the axioms, further terms are introduced: The most interesting one is the resolvable nondeterminism operator ⊕, which is also of interest for modeling by itself. The intuition of resolvable nondeterminism B1 ⊕ B2 is that either B1 or B2 is implemented, but not both. Thus, B1 + B2 is in general not an allowed implementation.
Further added terms are: (i) A next step restriction process B \ a, where B
may not execute action a as its next step. Note that action a may be executed

i ∈ {1, 2}	Bi ⇒ P B1 ⊕ B2 ⇒ P
	B2 ⇒ P2	
c.B1 >a B2 ⇒ c.B1 >a P2

		B ⇒ P	 B \ a ⇒ P \ a
	B1 ⇒ P1	B2 ⇒ P2	
B1|⟩B3,A,B4 B2 ⇒ P1|⟩B3,A,B4 P2
		B ⇒ P	 B⟨a/b, v⟩ ⇒ P ⟨a/b, v⟩



P2 /'−a→	P '−a→ B	b /= a

c.B1
>a P2
'−→c  B
P \ b '−a→ B

Table 2
Additional transition rules for the extended process algebra.

if an action different from a is executed before. (ii) A conditional prefix term c.B1 >a B2, which is equivalent to c.B1 whenever B2 cannot execute action a in its next step and it is equivalent to 0 if B2 can execute action a in its next step. (iii) A parallel composition B1|⟩B3 ,A,B4 B2 where the scheduler information for the next execution and the replacing processes for non-execution are already given. (iv) A renaming operator B⟨a/b, v⟩, where the scheduler information for the next execution is already present. Also some counterparts of these new expressions are added to the
process algebra terms where the next-step-underspecification is resolved. Formally, we define P˜A to be the set of all process algebra terms generated by
B ::= 0 | a.B | B + B | B B | B⟨a/b⟩| B ⊕ B | B \ a | c.B >a B | B|⟩B,A,BB |
B⟨a/b, v⟩
con
and we define P˜A	to be the set of all process algebra terms generated by
P ::= [0] | [a.B^] | P + P | P |⟩Bb,A,Be P | P ⟨a/b, v⟩ | P \ a | c.B^ >a P
where a, b, c ∈ Act, A ⊆ Act, B, B ∈ PA and v ∈ {d, s}. The previous transition rules (Table 1) are extended by those from Table 2. We give some comments on
⇒: the resolvable nondeterminism ⊕ is resolved by choosing either the right or the left side and resolving this term. In B1|⟩B3 ,A,B4 B2 only B1 and B2 have to be
resolved, since no next step analysis takes place in term B3 and B4. By the same argument, only B2 has to be resolved in c.B1 >a B2. Now some comments on '−→: In c.B1 >a P2 a c-step to B1 is possible iff the right hand side cannot execute a. In P \ b all executions of P that differ from b can take place as next step, in which case \b is removed, since this restriction only holds for the next step execution.
Remark 4.1 For terms of PA, after every ⇒-step the same set of provided actions is obtained. This does not hold for terms of P˜A, as, e.g., illustrated by a ⊕ 0.
The operational semantics of terms in PA and refinement (equivalence) over PA are defined as in Definition 3.3 except that the extended concretization and step transition relations are used.
Equations
Before we present the axiom system, we discuss some of the (standard) axioms that do not hold in general, i.e., where refinement equivalence cannot be guaranteed,


nuf(0)	nuf(a.B1)
		nuf(B2)	 nuf(c.B1 >a B2)
nuf(B1)	nuf(B2) nuf(B1 + B2)
nuf(B1)	nuf(B2) nuf(B1|⟩B3 ,A,B4 B2)
Table 3
 nuf(B)  nuf(B \ a)
		nuf(B)	 nuf(B⟨a/b, v⟩)

Definition of predicate nuf.

which is denoted by / :
B + B / B, since the left hand side allows more kinds of resolution of underspec- ification. For example, (a ⊕ b)+ (a ⊕ b) can be resolved to [a]+ [b], which provides a as well as b. On the other hand, a ⊕ b cannot be resolved such that both actions are provided. By similar arguments,
(B1  B2)+ (B1  B3) / B1  (B2 + B3),
since the underspecification in B1 can possibly be resolved in two different ways such that it cannot be matched by a single resolution of B1. More precisely, after
⇒, it is possible that the left hand side of (5) can provide more actions than the right hand side. In case B1 is next-step-underspecification-free, e.g., if B1 is of form
i∈I ai.Bi for some I, ai, and Bi, we do not have this problem. Predicate nuf on PA, which is formally defined in Table 3, collects those next step underspecification free processes. Resolution of next-step-underspecification yields a unique term if nuf holds:
Lemma 4.2 Suppose B ∈ PA and Act /= ∅. If nuf(B), then B has a unique target
w.r.t. ⇒, i.e., nuf(B) ⇒ |{B}◦ ⇒ | = 1.
Nevertheless, the processes of (5) are not equivalent even if nuf(B1) holds, since the resolvable nondeterminism of the parallel composition can be resolved in dif- ferent ways. For example, after applying ⇒ on (a.b)  (a.c + 0) there is exactly one
transition t labeled with a and either b or c is possible afterwards. On the other
hand a ⇒ step from ((a.b)  (a.c)) + ((a.b)  0) exists where two transitions t1, t2 la- beled with a are possible such that b is possible after t1 and c is possible after t2.
We remedy this problem by resolving the resolvable nondeterminism of the paral- lel operator before the parallel composition is expanded. This motivates why we introduced the term B1|⟩B3 ,A,B4 B2 already in PA.
In Table 4 axioms for the refinement relation ≤ over PA are presented, where we assume for simplicity that Act is finite.
Theorem 4.3 The axioms from Table 4 are sound and complete, i.e., ∀B1, B2 ∈
P˜A : B1 ≤ B2 ⇐⇒ B1 ≤ B2.
Example 4.4 By using Axiom A32, we get a.(b ⊕ c) ≤ (a.(b ⊕ c)) ⊕ (a.b). Further- more, by using Axiom A32 and then Axiom A3 we get (a.(b ⊕ c)) ⊕ (a.b) ≤ (a.(b ⊕ c)) ⊕ (a.(b ⊕ c)) a.(b ⊕ c). Thus we have shown that a.(b ⊕ c)  (a.(b ⊕ c)) ⊕ (a.b). Note that this cannot be shown by using only Axioms A1 – A31, since the necessary removal of ⊕ becomes impossible. This illustrates that Axiom A32 is also essential for the completeness of our Axiom system w.r.t. ≡.


(A1)	B1 ⊕ B2  B2 ⊕ B1
(A2)	B1 ⊕ (B2 ⊕ B3)  (B1 ⊕ B2) ⊕ B3
(A3)	B ⊕ B  B
(A4)	B1 + B2  B2 + B1
(A5)	B1 + (B2 + B3)  (B1 + B2)+ B3 (A6)	a.B + a.B  a.B
(A7)	B +0  B
(A8)	B1 + (B2 ⊕ B3)  (B1 + B2) ⊕ (B1 + B3)
(A9)	B1  B2   A⊆Act(B1|⟩B1 ,A,B2 B2) (A10)	B1|⟩B4,A,B5 B2   B2|⟩B5,Act\A,B4 B1
(A11)	B1|⟩B4 ,A,B5 (B2 ⊕ B3)  (B1|⟩B4 ,A,B5 B2) ⊕ (B1|⟩B4 ,A,B5 B3)
(A12)	B1|⟩B4 ,A,B5 (B2 + a.B3)   ((B1 \ a)|⟩B4 ,A,B5 B2)+ a.(B4  B3)	if a ∈ A
(A13)	B1|⟩B4 ,A,B5 (B2 + a.B3)  (B1|⟩B4 ,A,B5 B2)+ (a.(B4  B3) >a B1)
if a ∈/ A ∧ nuf(B1)
(A14)  0 |⟩B4 ,A,B5 0  0
(A15)	B⟨a/b⟩  B⟨a/b, d⟩⊕ B⟨a/b, s⟩
(A16)	(B1 ⊕ B2)⟨a/b, v⟩  B1⟨a/b, v⟩⊕ B2⟨a/b, v⟩
(A17)	(B1 + c.B2)⟨a/b, v⟩  B1⟨a/b, v⟩ + c.(B2⟨a/b⟩)	if c ∈/ {a, b}
(A18)	(B1 + a.B2)⟨a/b, d⟩  B1⟨a/b, d⟩ + (b.(B2⟨a/b⟩) >b B1)	if nuf(B1) (A19)	(B1 + b.B2)⟨a/b, d⟩ (B1 \ a)⟨a/b, d⟩ + b.(B2⟨a/b⟩)
(A20)	(B1 + a.B2)⟨a/b, s⟩  (B1 \ b)⟨a/b, s⟩ + b.(B2⟨a/b⟩)
(A21)	(B1 + b.B2)⟨a/b, s⟩  B1⟨a/b, s⟩ + (b.(B2⟨a/b⟩) >a B1)	if nuf(B1) (A22)	0⟨a/b, v⟩ 0
(A23) (B1 ⊕ B2) \ a  (B1 \ a) ⊕ (B2 \ a) (A24) (B1 + B2) \ a  (B1 \ a)+ (B2 \ a) (A25) 0 \ a  0
(A26) (a.B) \ a  0
(A27)	(b.B) \ a  b.B	if b /= a
(A28)	c.B1 >a (B2 ⊕ B3)  (c.B1 >a B2) ⊕ (c.B1 >a B3) (A29)	c.B1 >a (B2 + a.B3)  0
(A30)	c.B1 >a (B2 + b.B3)   c.B1 >a B2	if b /= a
(A31)	c.B >a 0  c.B
(A32)	B1 ≤ B1 ⊕ B2


Axioms for ≤, where  =≤ ∩ ≥. Here, L
L
Table 4
i∈{j} Bi is defined to be Bj and for I finite,

i∈I Bi

is defined

to be Bi' ⊕ (
i∈I\{i'} Bi) where i' ∈ I (by the associativity and commutativity of ⊕ the definition is

independent of the chosen i'). Note that we assume that Act is finite. Otherwise, more complex formulas have to be used in order to remain in PfA.

How the parallel composition can be expressed in terms of nondeterminism, known as the expansion theorem [23,4], is one of the most important rules. In our setting the expansion theorem is more complicated than usually, since resolvable as
well as inherent nondeterminism has to be handled. It is directly derived from our
axiom system and illustrated in the following, where Σ−1 Bj yields 0:
Theorem 4.5 (Expansion theorem)
n	n'

B  B' ≡ 
	Σ
ai,j.(Bi,j  B')+	Σ
'
i ,j
' .(B B'
') 

A⊆Act i=0 i'=0
j∈J(A,i,i')
j'∈J '	'

(A,i,i )

where	B =
n i=0
m(i) −1
j=0
ai,j .Bi,j ,	B' =
n' i=0
(i) −1
j=0
'
i,j
i,j ,

J(A,i,i') = {j < m(i) | ai,j ∈ A ⇒ ∀j' < m' '
: ai,j /= a''
'},

J '	'
= {j' < m' '
| a''
' ∈/ A ⇒ ∀j < m(i) : ai,j /= a''
' }.

(A,i,i )
(i )
i ,j
i ,j

Here, (i) the scheduler (A ⊆ Act) is determined by a resolution of resolvable nondeterminism, (ii) any combination of resolutions of both sides is considered, and (iii) the complete inherent nondeterminism of a component for a is taken if this component is favored by the scheduler or if the current resolution of the other component cannot provide a.

Related Work
An overview on algebraic approaches to nondeterminism is given in [27]. Nondeter- minism is often interpreted as angelic (chosen positively w.r.t. to a desired property) or demonic (chosen by an adversary). In [22], both nondeterminism interpretations are modeled in a single setting. The angelic/demonic view is orthogonal to our view, leading to the following four interpretations: (i) The task of resolving resolv- able, angelic nondeterminism is a satisﬁability check, i.e., an abstraction has an implementation satisfying the desired property if there is an angelic resolution. (ii) On the other hand, the task of resolving resolvable, demonic nondeterminism is a satisfaction check on the abstract level: the property holds if a demonic resolution satisfies it. (iii) Inherent, angelic nondeterminism ensures the existence of a step such that the desired property holds, whereas (iv) inherent, demonic nondetermin- ism ensures that all possible next steps satisfy the property. In alternating-time temporal logic [1], interpretations (iii) and (iv) are generalized to multiple actors.
In [3], both our choice operators (inherent and resolvable) are used in a process algebra and an operational semantics in terms of μ-automata as well as an axiomatic semantics is given. The difference to our work consists in the semantics of the parallel operator, since the semantics of the parallel operator in [3] is based on inherent instead of resolvable scheduling choice, i.e., schedulers behave “randomly” also at the concrete level, which is in most applications, like schedulers in operating systems, not the case. If the scheduler can prefer different parallel components per action, we cannot apply the usual approach to split the parallel composition by using the left merge operator, as it is also made in [3]. Therefore our axiom system

becomes more complicated by using additional operators and by using predicate nuf. A further choice operator is presented in [3]. The interpretation of this choice operator ⊕' is similar to our resolvable choice operator ⊕, except that the resolving can be moved outwards, e.g., a.(b ⊕' c) is equivalent to a.b ⊕' a.c, which is not the case for ⊕. The choice operator ⊕' has the same expressiveness as ⊕ w.r.t. the describable sets of concrete systems, i.e., replacing ⊕' by ⊕, or vice versa, does not change the set of concrete systems that refine the corresponding expressions. A difference arises in the refinement relation between different abstract levels, i.e., the refinement relation between non-concrete systems is different.
In [26] a process algebra having our resolvable choice operator together with a choice operator that is only resolvable w.r.t. the same action, which harmonizes with ready simulation, is presented. Thus full inherent nondeterminism is not handled there. The semantics is given as possible worlds, i.e., sets of concrete systems. No parallel operator is considered at all. This process algebra is extended by recursion in [21], but still no parallel composition is considered. Different kinds of choice operators are considered in hybrid systems, see, e.g., [7], but those choice operators concentrate on underspecification (i.e., resolvable nondeterminism) resulting from time aspects.
Other abstract models that can express inherent as well as resolvable nondeter- minism are, e.g., (disjunctive) modal transition systems [18,19], hypermixed Kripke structures [11], generalized Kripke modal transition systems [24], modal automata
[9] and ν-automata [12]. These models are often used as abstract models for tran- sition systems in order to improve verification of full branching time properties, as in [13,10].
In some settings the scheduler can be restricted by further constraints, like priority or fairness assumptions. They can be interpreted as a refinement of an abstract level where no constraint on the scheduler is enforced. This allowance to describe a more detailed scheduler is orthogonal to the problem of handling the interaction of inherent nondeterminism with the resolvable nondeterminism of an underspecified scheduler.
In probabilistic process algebras, see [20] for an overview, choice operators are extended with a distribution determining the way the different sides are favored. Randomized choice operators are special kinds of inherent nondeterminism. Never- theless, it is important to examine inherent choice operators, which do not contain a distribution, for their own, since sometimes the distribution is not known and sometimes it does not exist at all (cf. Examples 1.2 and 1.3). Note that approaches trying to embed pure inherent nondeterminism into probabilistic settings lead to unnecessarily complex models and thus unnecessarily increase the cost of verifica- tion.

Conclusion
We have presented the structural operational semantics of a process algebra that handles choice operators corresponding to inherent nondeterminism as well as re-

solvable nondeterminism obtained by abstraction from the scheduling of the paral- lel composition or the renaming/hiding operator. In particular, μ-automata, which have two kinds of transition relations (one for action execution and one for resolu- tion of resolvable nondeterminism), are used as underlying model for the structural operational semantics. In order to avoid any restriction on schedulers, the resolu- tion of the resolvable nondeterminism has to be made undone if it was not affected by the previous execution step. A sound and complete axiom system has been presented, where in particular a choice operator representing resolvable nondeter- minism is used. Note that the increased complexity of our semantics, compared to the standard semantics, is unavoidable if μ-calculus formulas should be preserved under refinement.
Our operational semantics can be straightforwardly adapted to process algebra having parallel composition with a CSP-based synchronization [15], sequential com- position, or recursion. The only problem arises for unguarded recursion, i.e., if there exists a variable that is bound without being behind an action prefix: There the
definition of the concretization relation ⇒ yields problems, since infinite derivation trees can be generated. This is not very critical, because usually process algebras
without unguarded recursion are sufficient for applications.

References
R. Alur, T. A. Henzinger, and O. Kupferman. Alternating-time temporal logic. J. ACM, 49(5):672–713, 2002.
J. C. M. Baeten. A brief history of process algebra. Theor. Comput. Sci., 335(2-3):131–146, 2005.
J. C. M. Baeten and J. A. Bergstra. Process algebra with partial choice. In B. Jonsson and J. Parrow, editors, CONCUR, volume 836 of LNCS, pages 465–480. Springer, 1994.
J. A. Bergstra and J. W. Klop. Algebra of communicating processes with abstraction. Theor. Comput. Sci., 37:77–121, 1985.
B. Bloom, S. Istrail, and A. Meyer. Bisimulation can’t be traced. J. ACM, 42(1):232–268, 1995.
T. Bolognesi and E. Brinksma. Introduction to the ISO specification language LOTOS. Computer Networks and ISDN Systems, 14:25–59, 1987.
S. Bornot and J. Sifakis. On the composition of hybrid systems. In T. A. Henzinger and S. Sastry, editors, HSCC, volume 1386 of LNCS, pages 49–63. Springer, 1998.
R. Cousot, editor. Verification, Model Checking, and Abstract Interpretation, 6th International Conference, VMCAI 2005, Paris, France, January 17-19, 2005, Proceedings, volume 3385 of LNCS.
Springer, 2005.
D. Dams and K. S. Namjoshi. Automata as abstractions. In Cousot [8], pages 216–232.
L. de Alfaro, P. Godefroid, and R. Jagadeesan. Three-valued abstractions of games: Uncertainty, but with precision. In LICS, pages 170–179. IEEE Computer Society Press, 2004.
H. Fecher and M. Huth. Ranked predicate abstraction for branching time: Complete, incremental, and precise. In S. Graf and W. Zhang, editors, ATVA, volume 4218 of LNCS, pages 322–336. Springer, 2006.
H. Fecher, H. Schmidt, and J. Sch¨onborn.  Refinement sensitive formal semantics of state machines having inherent nondeterminism. In MODELS, 2007. Available at http://www.informatik.uni-kiel.de/~hsc/models07.pdf, submitted for publication.
O. Grumberg, M. Lange, M. Leucker, and S. Shoham. Don’t know in the μ-calculus. In Cousot [8], pages 233–249.

H. Hansson and B. Jonsson. A calculus for communicating systems with time and probabilities. In
Proc. 11th IEEE Real-Time Systems Symposium (RTSS), Orlando, Fl., January 1990.
C. A. R. Hoare. Communicating Sequential Processes. Prentice Hall, 1985.
D. Janin and I. Walukiewicz.	Automata for the modal mu-calculus and related results.	In
J. Wiedermann and P. H´ajek, editors, Mathematical Foundations of Computer Science, volume 969 of LNCS, pages 552–562. Springer, 1995.
D. Kozen. Results on the propositional μ-calculus. Theor. Comput. Sci., 27:333–354, 1983.
K. G. Larsen and B. Thomsen. A modal process logic. In LICS, pages 203–210. IEEE Computer Society Press, 1988.
K. G. Larsen and L. Xinxin. Equation solving using modal transition systems. In LICS, pages 108–117. IEEE Computer Society Press, 1990.
N. L´opez and M. Nu´n˜ez. An overview of probabilistic process algebras and their equivalences. In
C. Baier, B. R. Haverkort, H. Hermanns, J.-P. Katoen, and M. Siegle, editors, Validation of Stochastic Systems, volume 2925 of LNCS, pages 89–123. Springer, 2004.
M. E. Majster-Cederbaum. Underspecification for a simple process algebra of recursive processes.
Theor. Comput. Sci., 266:935–950, 2001.
C. E. Martin, S. A. Curtis, and I. Rewitzky. Modelling nondeterminism. In D. Kozen and C. Shankland, editors, MPC, volume 3125 of LNCS, pages 228–251. Springer, 2004.
R. Milner. A Calculus for Communicating Systems, volume 92 of LNCS. Springer-Verlag, 1980.
S. Shoham and O. Grumberg. 3-valued abstraction: More precision at less cost. In LICS, pages 399–410. IEEE Computer Society Press, 2006.
B. Thomsen. An extended bisimulation induced by a preorder on actions. Master’s thesis, Aalborg University Centre, 1987.
S. Veglioni and R. De Nicola. Possible worlds for process algebras. In D. Sangiorgi and R. de Simone, editors, CONCUR, volume 1466 of LNCS, pages 179–193. Springer, 1998.
M. Walicki and S. Meldal. Algebraic approaches to nondeterminism: An overview. ACM Comput. Surv., 29(1):30–81, 1997.
