Electronic Notes in Theoretical Computer Science 174 (2007) 83‚Äì98	
www.elsevier.com/locate/entcs

Coding Mobile Synchronizing Petri Nets into Rewriting Logic 
Fernando Rosa-Velardo
Departamento de Sistemas Informa¬¥ticos y Programaci¬¥on Universidad Complutense de Madrid, Spain
e-mail: fernandorosa@sip.ucm.es


Abstract
Mobile Synchronizing Petri Nets (MSPN‚Äôs) are a model for mobility and coordination based on coloured Petri Nets, in which systems are composed of a collection of (possibly mobile) hardware devices and mobile agents, both modelled homogenously. In this paper we approach their verification, for which we have chosen to code MSPN‚Äôs into rewriting logic. In order to obtain a representation of MSPN systems by means of a
rewrite theory, we develop a class of them, that we call ŒΩ-Abstract Petri nets (ŒΩ-APN‚Äôs), which are easily representable in that framework. Moreover, the obtained representation provides a local mechanism for fresh name generation. Then we prove that, even if ŒΩ-APN‚Äôs are a particular class of MSPN systems, they are strong enough to capture the behaviour of any MSPN system. We have chosen Maude to implement ŒΩ- APN‚Äôs, as well as the translation from MSPN‚Äôs to ŒΩ-APN‚Äôs, for which we make intensive use of its reflective features.
Keywords: Mobility, Petri nets, rewriting, security, specifications


Introduction
In several previous papers [14,15] we have presented a model for concurrent, mobile and ubiquitous systems [5,12], based on Petri Nets, that we call Mobile Synchron- izing Petri Nets (MSPN). Petri nets provide friendly graphical representations of systems, and we can profit from their solid theoretical background. Moreover, since they are not Turing-complete, there are many decidability results for them that do not hold in general for other more expressive models. Several models for mobility based on Petri Nets have been proposed in the literature [1,19,9,3,8]. However, the previous models do not consider security aspects, certainly crucial in this setting, nor any other Petri net based model for mobility, up to our knowledge.

Ÿ® Work partially supported by the Spanish projects MIDAS TIC 2003-01000, MASTER TIC 2003-07848- C02-01 and PROMESAS-CAM S-0505/TIC/0407.

1571-0661 ¬© 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2006.10.021

In [15] we studied the expressiveness of MSPN systems. We proved several interesting decidability results, such as the decidability of coverability, that can be used to specify security properties such as integrity or confidentiality. In order to achieve the verification of these properties, we have chosen rewriting logic [10] as the framework to develop it. This logic supports in a natural way the managing of distributed and concurrent systems, and has been efficiently implemented by the Maude [6] programming language, that has been widely used for the implementation of a number of process algebras and other formalisms for concurrency [20,18].
In order to perform the translation from MSPN systems to rewriting logic, we introduce ŒΩ-Abstract Petri nets (ŒΩ-APN‚Äôs), that provide an intermediate step in the procedure. They are essentially a subclass of coloured Petri nets that can produce fresh identifiers. These nets capture the core of MSPN systems. Any time a name is created in a MSPN system, any different new name could have been created, so that reachability of a certain marking is equivalent to that of any marking in which we (consistently) rename the set of new names. However, for the sake of homogeneity, we will assume that we can rename any name, even those that were present in the initial marking. To capture this intuition, we assume that ŒΩ-APN‚Äôs work module Œ±-conversion of tokens. We represent them as rewrite theories in such a way that generation of fresh names can be achieved without needing to access the global state.
Since the rewrite theory that results from the translation of an MSPN system to a ŒΩ-APN first, and then to rewriting logic, can be quite distant from its original description, we use the reflective properties of Maude in order to automatically perform that translation. Finally, we implement an algorithm that decides the coverability problem for MSPN systems.
The remainder of the paper is structured as follows. Section 2 gives an informal description of Mobile Synchronizing Petri Nets. Section 3 describes in a nutshell the representation of Petri nets in Maude. Section 4 defines Abstract Petri Nets and ŒΩ-Abstract Petri Nets, establishes their translation to rewrite theory and proves the equivalence of MSPN systems and ŒΩ-APN‚Äôs. Finally, in Section 5 we briefly describe the implementation in Maude and Section 6 presents the conclusions and directions for further work.

Mobile Synchronizing Petri Nets: overview
In this section we briefly describe our Mobile Synchronizing Petri Nets. For more details see [14] or [15]. An MSPN N = (P, T, F, Œª, C) is a special kind of labelled coloured Petri Net [7], that is, P is a finite set of places, T is a finite set of transitions, and F is a partial function that defines as its domain the set of arcs, and labels those arcs with variables taken from a set Var = Var L ‚à™ Var Id ‚à™ {Œµ}. We say that some variables in Var Id , those in Var Auth ‚äÇ Var I d, are authentication variables. MSPN‚Äôs only have three different colour types: one for localities, taken from a set L, one for identifiers, taken from a set Id , with both L and Id infinite, and a singleton colour type {‚Ä¢} for ordinary black tokens. Sometimes we just write ‚Ä¢

k







Figure 1. Autonomous (left) and synchronizing (right) transitions

to denote that singleton. We use the symbol 1 to range over the set {‚Ä¢, L, Id }, and Tokens to denote the union L ‚à™ Id ‚à™ {‚Ä¢}. The function C : P ‚Üí {‚Ä¢, L, Id } establishes a partition in the set of places, so that a place p with C(p) = 1 may only contain tokens in 1. Finally, according to Œª : T ‚Üí ffi ‚à™ Sync, MSPN‚Äôs may have two different kinds of transitions, autonomous (those with Œª(t) ‚àà ffi) and synchronizing transitions (those with Œª(t) ‚àà Sync). The set ffi of autonomous labels has two distinguished labels new and go. The set Sync of synchronizing labels is the disjoint union of S?= {s? | s ‚àà S} and S!= {s! | s ‚àà S}, where S is a set of service names. Intuitively, s! is the offer of a service s, while s? is the request of that service, although formally they are just the two symmetric sides of a synchronization.
Unlike for ordinary Coloured Petri Nets, where arbitrary expressions over some syntax can label arcs, we only allow variables to specify the flow of tokens from preconditions to postconditions. In particular, this means that only equality of identifiers can be imposed by matching, but not any other relation between them. For consistency we are assuming in the definition that every arc (every pair (p, t)
or (t, p) in the domain of F ) is labelled by a variable. However, since we only need variables to distinguish between different locality tokens and identifier tokens, we introduce the special variable Œµ, that labels every arc that is adjacent to an ordinary black-token place and is not usually depicted. Moreover, variables from Var L are only used for arcs that are adjacent to places p with C(p)= L and those from Var Id only for arcs next to places p with C(p)= Id . In this way, we guarantee that the different types of tokens are never mixed.
We use post (t) to denote the set of variables in arcs going from t to some place, i.e., going out of t (except for Œµ). Analogously, we use pre (t) to denote the set of variables in arcs reaching t. We take Var (t)= post (t)‚à™pre (t). If t is an autonomous transition with Œª(t) /= new then it must be the case that post (t) ‚äÜ pre (t), so that autonomous transitions can only move or delete locality and identifier tokens, but not create them. As usual in P/T nets, we denote by t‚Ä¢ and ‚Ä¢t the set of postconditions and preconditions of t, respectively.
Then, an MSPN system S is just a pair (ùí©, N), where ùí© is a set of disjoint nets and N is the initial marking of ùí©. A marking of ùí© is a pair (M, loc), where M is a function that maps each place to a finite multiset of tokens, and loc : ùí© ‚Üí L maps each net to its current location, taken from the set L. Given two markings N1 = (M1, loc1) and N2 = (M2, loc2), we say that N2 covers N1 if M1(p) ‚äÜ M2(p), for every p ‚àà P , and loc1(N )= loc2(N ), for all N in ùí©.
Since our nets are a particular class of coloured nets [7], their transitions fire relative to a mode, that chooses the particular tokens taken from the precondition

l	k	l	k

~


Figure 2. Movement transitions
places. Modes are defined as mappings from Var (t) to Tokens, assigning values in
1 to variables in Var T. We denote modes by œÉ, œÉ', œÉ1, œÉ2,... 
Autonomous transitions t with Œª(t) ‚àà/ {new , go} work as the ordinary trans-
itions in coloured nets (see Fig. 1 left). Movement transitions, those labelled by go, are autonomous transitions that change the location of the net firing it. For that purpose, every movement transition has a single distinguished locality precon- dition to specify the destination of the net (see Fig. 2). Name-creating transitions, those labelled by new , are autonomous transitions that, when fired, generate a fresh identifier in its identifier postconditions.
Instead, the firing of a synchronizing transition needs the presence of a compat- ible transition in the same location, that will be fired at the same time. For a pair of synchronizing transitions t1 and t2 we denote by post (t1, t2)= post (t1) ‚à™ post (t2), pre (t1, t2)= pre (t1) ‚à™ pre(t2) and V ar(t1, t2)= post (t1, t2) ‚à™ pre (t1, t2). The com- patibility conditions are merely syntactical: On the one hand, their labels must be complementary, s? and s! for some s ‚àà S; On the other hand, the pair of transitions together must meet the same constraint imposed on autonomous transitions, that is, post (t1, t2) ‚äÜ pre (t1, t2) (see Fig. 1 right); Finally, whenever an authentication variable appears in a precondition arc, then it must also appear in a precondition arc of its compatible transitions; This is the way the mechanism for authentication is implemented, by forcing the matching of two identifers.
In order to fire a pair of compatible synchronizing transitions, t1 and t2, they must be co-located and separately fireable according to the ordinary firing rule, but relative to a common mode œÉ, that in the case of synchronizing transitions are mappings from Var (t1, t2) to Tokens.
In order to have a more compact notation we use u, u', u1, u2,... to range both over autonomous transitions and pairs of compatible synchronizing transitions, thus writing N[u(œÉ)‚ü©N' if N' is the reached state after the firing of u with mode œÉ.

Maude and Petri Nets
In rewriting logic and Maude the state of a system is formally specified by means of an equational specification in membership equational logic [4]. In this logic we can define sorts, subsorts, constructor operators (that can have associated equational attributes such as commutativity or associativity), or equations between terms, to name a few of the elements of this logic.
The following functional module of Maude defines the syntax of a consumer- producer system where producers can be either idle or ready to send an item,


readyToSendProducer	readyConsumer
idleProducer	waitingConsumer

Figure 3. Petri Net modelling a producer-consumer system

consumers can be waiting for a product or ready for their consumption and items can be ready for departure, stored or accepted for consumption.
fmod CONSUMER-PRODUCER-SIGNATURE is
sorts ProducerState ConsumerState ItemState State . subsorts ProducerState ConsumerState ItemState < State . op   : State -> State [assoc comm id: null] .
op null : -> State .
ops idleProducer readyToSendProducer : -> ProducerState . ops waitingConsumer readyToConsume : -> ConsumerState . ops itemReady itemStored itemAccepted : -> ItemState .
endfm
Equations are assumed to produce confluent and terminating rewriting systems, so that they can be used from left to right to obtain unique (modulo the operational attributes) normal forms representing terms. In our case, we will see that our equational specifications will not need equations, since our set of terms can be obtained as the term algebra generated by the constructors, modulo some equational attributes.
The dynamic part of a system is specified by rewrite rules. In general these rules can be conditional, but in our case they will just have the form t ‚Üí t', meaning that whenever a part of the system matches t then that part can be replaced by the corresponding instance of t'.
The next module specifies the behaviour of the producer-consumer system.
mod PRODUCER-CONSUMER is
inc PRODUCER-CONSUMER-SIGNATURE .
rl [produce] : idleProducer => itemReady readyToSendProducer .
rl [send] : itemReady readyToSendProducer => idleProducer itemStored . rl [accept] : itemStored waitingConsumer => itemAccepted readyConsumer . rl [consume] : itemAccepted readyConsumer => waitingConsumer .
endm
In fact, the previous module can be seen as the rewriting semantics, written in Maude, of the Petri Net shown in Fig. 3, as stated in [17] or in [16], where the authors continued the work started in [11]. The basic idea is that each marking of a P/T net can be represented as the multiset of places where their tokens lie, so that the firing of a transition corresponds to a rewriting over those multisets.

Abstract Petri Nets
In order to be able to apply a similar approach to the one just discussed for plain Petri Nets in the previous section to the representation of our nets in Maude, we introduce Abstract Petri Nets (APN‚Äôs). An APN is a labelled coloured Petri Net

q

b


Figure 4. Example of APN
with only one colour type for identifiers, taken from an arbitrary set Id . As in MSPN systems, we only allow variables as labels of arcs (not arbitrary expressions over some syntax, as in general CPN‚Äôs), that in the case of APN‚Äôs, are all taken from the same set Var .
We denote by NS(A) the set of multisets of elements in A, that is, the set of mappings ffi : A ‚Üí N.
Later, we will allow also the use of a special variable that will mimic the beha- viour of the new transitions in MSPN systems, but for now we prefer to omit it, in order to focus on the abstract nature of identifier tokens in APN‚Äôs. The syntactic definition of APN‚Äôs is the following.
Definition 4.1 An Abstract Petri Net (APN) is a tuple N = (P, T, F ) where P is the set of places, T is the set of transitions, and F : (P √ó T ) ‚à™ (T √ó P ) ‚Üí Var is a partial function such that for every t ‚àà T it holds post (t) ‚äÜ pre (t), where ‚Ä¢t = {p ‚àà P | (p, t) ‚àà Dom(F )}, t‚Ä¢ = {p ‚àà P | (t, p) ‚àà Dom(F )}, pre(t) = {F (p, t) | p ‚àà ‚Ä¢t} and post (t)= {F (t, p) | p ‚àà t‚Ä¢}.
We also write Vars (t) = pre (t) ‚à™ post (t), by ‚Ä¢tx we denote the set {p ‚àà P | F (p, t)= x} and, analogously, t‚Ä¢ = {p ‚àà P | F (t, p)= x}. Next we define markings of APN‚Äôs and equivalent markings.
Definition 4.2 A marking M of an APN N = (P, T, F ) is a mapping M : P ‚Üí NS(Id ). We define Ids(M )= {a ‚àà Id | a ‚àà M (p) for some p ‚àà P }. We take ‚â°Œ± as the least equivalence relation on markings such that M ‚â°Œ± M [b/a] with b ‚àà/ Ids(M ), where M [b/a](p)(c)= M (p)(c) if c /= a, b and M [b/a](p)(b)= M (p)(a).
We denote by Markings(N ), or just Markings when there is no confusion, the set of markings of N . In Fig. 4 we show a simple APN. We are assuming that there are two identifiers in Id , Œ∑1 and Œ∑2, and two variables in Var , x and y. That net can fire transition t1, and then t2, producing a marking composed only by identifier Œ∑2 in r and b.
Let us now define the operational behaviour of APN‚Äôs. We denote by + and
‚Äî the multiset union and difference, to distinguish them from ‚à™ and \, the corres- ponding operations over sets. As they are a particular class of Coloured Petri Nets, their transitions are fired relative to a mode, that we denote by œÉ, œÉ',... 
Definition 4.3 Let t be a transition of an APN N . We say that œÉ : Vars (t) ‚Üí Id is a mode for t, and denote by Modes (t) the set of modes of t. We say that t is enabled with mode œÉ in marking M if œÉ(F (p, t)) ‚àà M (p) for all p ‚àà ‚Ä¢t. In that case the transition can be fired, thus producing a marking M ', defined by

M '(p)= M (p) ‚àí {œÉ(F (p, t))} + {œÉ(F (t, p))} for every p ‚àà P (taking œÉ(F (a)) = ‚àÖ if
a ‚àà/ Dom(F )). As usual, we write M [t(œÉ)‚ü©M '.
We want to represent APN‚Äôs in Maude, similar to ordinary Petri nets. For that purpose we define a normal form for sets of equivalent markings. Now that we have distinguishable tokens, it is not sufficient to consider the set of places occupied by tokens, but we need to do that for every different token, thus getting not a multiset of places, but a multiset of multisets of places, one multiset per identifier. However, the ordinary structure in multisets (of multisets) is not enough for our purposes. This is because we do not want to consider multisets containing the empty multiset since, intuitively, the empty multiset would correspond to a non existing identifier, which could then be removed. Instead of restricting the set of states to those multisets not containing the empty multiset, for the sake of homogeneity we prefer to proceed as follows.
Definition 4.4 Let ~ be the least equivalence relation over NS(NS(P )) such that
ffi + {‚àÖ} ~ ffi for ffi ‚àà NS(NS(P )).
In the following, we will work in NS(NS(P )) modulo ~. However, for the sake of clarity of notations, we write ffi instead of [ffi]~ for elements in NS(NS(P ))/~. In order to avoid confusion, sometimes we use the empty operator as union in NS(P ) and the symbol + as the union in NS(NS(P )), together with the corresponding
extended operators   and Œ£. Moreover, we denote by ‚àÖ the empty multiset of
places and by {} the empty multiset of multisets.
Before the definition of the mapping from markings to multisets, let us see an example. The marking shown in Figure 4 has two different identifiers, Œ∑1 and Œ∑2, so that we use two multisets to represent it, one for each token. The identifier Œ∑1 appears in q, so that we represent it by {q} and Œ∑2 only in p, so that we represent it by {p}. Therefore, we map that marking to the multiset {{p}, {q}}, that we will denote by p + q. After the firing of t1 first and then t2 a marking with only Œ∑2 in places r and b is reached. The corresponding multiset will be simply denoted by r b.
Normal forms are defined as follows:
Definition 4.5 Let N = (P, T, F ) be an APN. We define
NF : Markings(N )/‚â°Œ± ‚Üí NS(NS(P ))/~
as NF ([M ]‚â°Œ± ) = ffiM = {Ma | a ‚àà Ids(M )}, where Ma ‚àà NS(P ) is defined by
Ma(p)= M (p)(a).
In principle, the previous definition is formalized using a particular representat- ive of the equivalence class. Let us see that any representative behaves in the same way.
Proposition 4.6 NF is well deÔ¨Åned and is an injection.
Of course, the union in NS(NS(P )) is commutative and associative, so that

(NS(NS(P )), +, {}) is a commutative monoid. These properties are preserved in the quotient.
Proposition 4.7 (NS(NS(P ))/~, +, [{}]~) is a commutative monoid, where + is (well) deÔ¨Åned by [ffi]~ + [$]~ = [ffi + $]~.
We want to use the previous domain to represent the states of our nets, so let us see that the previous result also holds for markings. We denote by 0 the marking given by 0(p)= ‚àÖ for every p. Moreover, if M and M ' are markings of an APN N , we write M + M ' to denote the marking defined by (M + M ')(p)= M (p)+ M '(p). Just taking care of the details, we can export this definition to classes of markings.
Definition 4.8 Let [M1]‚â°Œ± , [M2]‚â°Œ± ‚àà Markings/‚â°Œ± . We define [M1]‚â°Œ± + [M2]‚â°Œ± as [M ' + M ' ]‚â°Œ± with M1 ‚â°Œ± M ' , M1 ‚â°Œ± M ' and Ids(M ' ) ‚à© Ids(M ' )= ‚àÖ.
1	2	1	1	1	2
The previous definition does not depend on any of the representatives chosen, and provides a monoid structure also for markings modulo ‚â°Œ±.
Proposition 4.9 Given an APN N, (Markings(N )/‚â°Œ± , +, [0]‚â°Œ± ) is a commutative monoid.
Furthermore, our translation function preserves those properties.
Proposition 4.10 NF is an isomorphism of commutative monoids.
Therefore, we can represent a whole class of markings, [M ]‚â°Œ± as the multiset (of multisets) NF ([M ]‚â°Œ± ). Now let us see how to move the operational behaviour of an APN to that domain. Transitions have the form M1[t(œÉ1)‚ü©M ' . However, in MSPN systems (and ŒΩ-APN‚Äôs, as we will see), tokens with new fresh names can be created. In particular, their particular names are not relevant, since any new name can be created. We have reproduced that situation in APN‚Äôs by introducing abstract markings, which are induced by the considered Œ±-equivalence. In fact, it can be seen that if M1 ‚â°Œ± M2 then there is some œÉ2 such that M2[t(œÉ2)‚ü©M ' , with
M ' ‚â°Œ± M ' . Moreover, when working modulo Œ±-conversion, a mode only identifies
1	2
the relations between the different tokens involved, not the individual values. We
formalize all that by means of the following definitions.
Definition 4.11 Let œÉ be a mode for t. We define the relation on variables ‚àºœÉ by
x ‚àºœÉ y ‚áî œÉ(x)= œÉ(y).
The relation ‚àºœÉ identifies those variables that are instantiated to the same value by the mode œÉ. That is the information about modes in which we are interested, so that we identify modes up to that information, as formalized as follows:
Definition 4.12 Let t be a transition. We define the relation ‚âàt over modes of t
by œÉ1 ‚âàt œÉ2 ‚áî‚àºœÉ1 =‚àºœÉ2 .
Proposition 4.13 Let us suppose that t is Ô¨Åreable in M1 with mode œÉ1 and M1 ‚â°Œ± M2. Then there is a mode œÉ2 with œÉ1 ‚âàt œÉ2 such that t is Ô¨Åreable in M2 with mode œÉ2. Moreover, the markings obtained by Ô¨Åring t(œÉ1) and t(œÉ2) in M1 and M2, respectively, are also Œ±-equivalent.

p	q

Figure 5. Simple ŒΩ-APN
Therefore, when we are working modulo Œ±-conversion, the firings can be repres- ented in the corresponding quotient space as [M1]‚â°Œ± [t([œÉ]‚âàt )‚ü©[M2]‚â°Œ± . Our goal is to simulate these firings by means of rewrites NF ([M1]‚â°Œ± ) ‚Üí NF ([M2]‚â°Œ± ). Let us see which rules generate those rewrites. In fact, we will see that each pair consisting of t and [œÉ]‚âàt gives rise to a different rule.
First, we introduce the following auxiliary notation. Given a transition t of an APN and a mode œÉ for t we denote by P(t(œÉ)) the quotient Vars (t)/‚àºœÉ . We will treat elements in P(t(œÉ)) as the sets of their representatives, so that we can write Var ‚äá X ‚àà P(t(œÉ)).
Lemma 4.14 If œÉ1 ‚âàt œÉ2 then P(t(œÉ1)) = P(t(œÉ2)).
We have already settled all the machinery we need for the translation of the operational semantics of APN‚Äôs into rewriting logic. In the following we denote by V the set of variables in the logic, to distinguish them from APN variables. Moreover, we will use injections FV : P(t(œÉ)) ‚Üí V .
Definition 4.15 Let œÉ be a mode for t. We define rl(t(œÉ)) as the unconditional rule lt(œÉ) ‚Üí rt(œÉ), where

lt(œÉ) =	Œ£
   ‚Ä¢tx FV (X),	rt(œÉ) =	Œ£
   t‚Ä¢ FV (X)

X‚ààP(t(œÉ))
x‚ààX
X‚ààP(t(œÉ))
x‚ààX

Intuitively, each of the multisets appearing in rl(t(œÉ)) represent an identifier that is involved in the firing of t(œÉ). Therefore, given X ‚àà P(t(œÉ)), if œÉ(X)= {a} for some a ‚àà Id , then FV (X) represents the multiset of places containing a that are not affected by the firing.
Lemma 4.16 If œÉ1 ‚âàt œÉ2 then rl(t(œÉ1)) and rl(t(œÉ2)) are equal up to a consistent renaming of its free variables.
If rl is a rule of a rewrite theory we write t ‚Üírl t if t ‚Üí t can be proved using the replacement rule of deduction exactly once, with rule rl.
rl(t(œÉ))
Theorem 4.17 [M1]‚â°Œ± [t([œÉ]‚âàt )‚ü©[M2]‚â°Œ± ‚áî NF ([M1]‚â°Œ± ) ‚àí‚Üí NF ([M2]‚â°Œ± ).
Example 4.18 Let us see what are the rules that we obtain by applying Def. 4.15 to the net in Fig. 4.	That net has two transitions, t1 and t2.	The quotient
Modes (t1)/‚âàt1  has only one element, that can be represented as {{x}}.	Since
(t1) = {p} and (t1)‚Ä¢ = {r, a} the rule generated is p M ‚Üí r a M . However,
Modes (t2)/‚âàt2 has two elements, that we represent as {{x, y}} (identifying x and
y) and {{x}, {y}} (not identifying them). Therefore, that transition produces two

different rules. Since ‚Ä¢(t2)
= {a}, ‚Ä¢(t2)
= {q}, (t2)‚Ä¢
= {b} and (t2)‚Ä¢
= ‚àÖ, the

resulting rules are a q M ‚Üí b M and a M1 + q M2 ‚Üí b M1 + M2, respectively.
Notice that the resulting rules are only valid because we are working module ~. Indeed, if we want to be able to use the last rule to rewrite the state a + q, we must



Figure 6. A simple example
instantiate both M1 and M2 with ‚àÖ, thus producing b ‚àÖ + ‚àÖ, which we identify via
~ with b.
So far we have dealt with APN‚Äôs, which are just a particular class of coloured Petri nets that work under Œ±-conversion. Our goal is to use APN‚Äôs to simulate MSPN systems. However, for that purpose, APN‚Äôs are not sufficient, due to the new transitions in MSPN‚Äôs that produce fresh identifiers. Therefore, we need to add that primitive to APN‚Äôs, thus getting ŒΩ-APN‚Äôs. For that purpose, we assume that there is a special variable ŒΩ ‚àà Var , that we will only use to label arcs going from transitions to places. If we only allow modes to instantiate this variable by values that do not appear in the current marking, then we get a safe by construction mechanism of fresh name creation. Moreover, when moving to the representation of markings in NS(NS(P )), the described mechanism of name creation can be implemented in a local way, without having to explore the whole marking to guarantee the freshness of the new name or without the need of a global variable, because the new name simply corresponds to a new multiset, that at the time of the creation will only contain the place where the identifier is created.
The syntactic definition is almost the same as that of APN‚Äôs, but for the con- sideration of the new variable.
Definition 4.19 A ŒΩ-Abstract Petri Net (ŒΩ-APN) is a tuple N = (P, T, F ) where P is the set of places, T is the set of transitions, and F : (P √óT )‚à™(T √óP ) ‚Üí Var is a partial function such that for all t ‚àà T it holds post (t) ‚äÜ pre (t), where ‚Ä¢t = {p ‚àà P | (p, t) ‚àà Dom(F )}, t‚Ä¢ = {p ‚àà P | (t, p) ‚àà Dom(F )}, pre (t)= {F (p, t) | p ‚àà ‚Ä¢t}\ {ŒΩ} and post (t)= {F (t, p) | p ‚àà t‚Ä¢}\ {ŒΩ}.
However, the behaviour changes as follows.
Definition 4.20 Let t be a transition of a ŒΩ-APN N . We say that œÉ : Vars (t) ‚Üí Id is a mode for t if whenever ŒΩ ‚àà Vars (t) then œÉ(ŒΩ) /= œÉ(x) for every x ‚àà Vars (t) with x /= ŒΩ. We say that t is enabled in mode œÉ in marking M if:
If ŒΩ ‚àà Vars (t) then œÉ(ŒΩ) ‚àà/ Ids(M )
œÉ(F (p, t)) ‚àà M (p) for all p ‚àà ‚Ä¢t.
Then the transition can be fired, producing a marking M ', defined by M '(p) = 
M (p) ‚àí {œÉ(F (p, t))} + {œÉ(F (t, p))}. Once again, we write M [t(œÉ)‚ü©M '.
Therefore, the only difference is that now we restrict modes so that the variable ŒΩ can only be instantiated by identifiers not appearing in the marking. In particular, modes must not instantiate ŒΩ and any other variable by the same value, so that the only element in P(t(œÉ)) to which ŒΩ can belong is {ŒΩ}.

l
k







Figure 7. MSPN system
All the previous considerations about the representation of an APN as a rewrite theory are still valid if we extend our mappings FV to FV : P(t(œÉ)) ‚Üí V ‚à™ {‚àÖ}, so that only FV ({ŒΩ}) = ‚àÖ. Thus, the multiset appearing in rl(t(œÉ)) that represents ŒΩ is empty in the left handside of the rule (because ‚Ä¢tŒΩ = ‚àÖ) and is only t‚Ä¢ in the right hand side, so that we obtain a fresh identifier. Consider for instance the net in Fig. 5, that takes a token from p and produces a fresh identifier in q. Since modes cannot instantiate x and ŒΩ by the same value, the only equivalence class in Modes (t)/‚âàt is P = {{x}, {ŒΩ}}, that is, that in which x and ŒΩ are not related. Thus, according to the definition in the previous section, the only rule produced by that net is
‚Ä¢txFV ({x})+ ‚Ä¢tŒΩFV ({ŒΩ}) ‚àí‚Üí t‚Ä¢ FV ({x})+ t‚Ä¢ FV ({ŒΩ})
x	ŒΩ
If we take FV ({x})= M , since it must be the case that FV ({ŒΩ})= ‚àÖ, the rule is just p M ‚Üí M + q, so that it is guaranteed that the name appearing in q is indeed fresh.
Notice that the reachability property in ŒΩ-APN‚Äôs differs from ordinary reachabil- ity, since we are allowing the renaming of every identifier appearing in markings, and not only those newly created. For instance, let us consider the net in Fig. 6, in which no token is created. If we ask whether the marking M given by M (p1)= M (p2)= ‚àÖ, M (p3) = {b} and M (p4) = {a}, can be reached, the result would be affirmative, since M [a/b, b/a] is reachable in one step, and M ‚â°Œ± M [a/b, b/a]. Instead, if we do not consider Œ±-equivalence over markings, then the answer should be negative, since the only reachable marking is that with an a in p3 and a b in p4, which is different from M . This situation, as proved in 4.17, is mimicked in our representation of multisets, in which the multiset p1 + p2 (p1 representing a and p2 representing b) is rewritten to p3 + p4.
This can be avoided with the introduction for each name in the initial marking of an isolated place containing that name. Let us see how this construction works for the net in Fig. 6. Since there are only two names in the initial marking, we add two places, one for a and one for b, containing tokens a and b, respectively. Now, the reached marking M ' is that given by M '(p0) = M '(p1) = ‚àÖ, M '(p3) = M '(a) = a and M '(p4)= M '(b)= b, but now it is not the case that M ' = M [a/b, b/a], because of the introduced places, nor any other marking that is Œ±-equivalent to M . That marking would be represented in the rewrite theory as a p1 + b p2, which can be rewritten to the multiset a p3 + b p4.
On the one hand, ŒΩ-APN‚Äôs are a particular class of MSPN systems, with only one net component, without locality places or movement transitions and without

@1	r	@2






Figure 8. APN that simulates the MSPN system in Fig. 7
synchronizing transitions. However, on the other hand, they are powerful enough to simulate any arbitrary MSPN system stepwise.
Theorem 4.21 Every MSPN system can be (strongly) simulated by a ŒΩ-APN.
In Fig. 8 we show the APN that results from the construction described in the proof of the previous theorem, applied to the MSPN system in Fig. 7. Basically, it consists on adding places {@1,... , @n}, used to save the current location of each net, unfold possible synchronizations ad adding test arcs to restrict them according to locations. We assume, in order to simplify notations, that ‚Ä¢‚àà Id and L ‚äÜ Id .
Summing up, we have proved that MSPN systems can be strongly simulated by rewrite systems, meaning that there is a one-to-one correspondence not only between their states, but also between their computations. Moreover, this isomorphism preserves the monoid structure in MSPN systems, so that typical property in Petri Nets, such as reachability, coverability, boundedness or home space property, can be studied in the resulting rewrite theory.

Some implementation details
We have seen a canonical translation from the operational semantics of ŒΩ-APN‚Äôs to rewrite theories. These rewrite theories can be straightforwardly expressed in Maude. We need, not only sorts for places and multisets of places, but also for multisets of multisets of places, which correspond to markings.
sorts Place MSPlaces Marking . subsorts Place < MSPlaces < Marking .
The following are the constructors for multisets of places and multisets of multis- ets of places, respectively.
op emptySet : -> MSPlaces .
op   : MSPlaces MSPlaces -> MSPlaces [comm assoc id: emptySet] . op _+_ : Marking Marking -> Marking [comm assoc id: emptySet] .
We want to work module ~, so that M + {‚àÖ} = M must be a valid identity in the equational theory. The relation ~ can be proved to be the least congruence for
+ such that {} ~ {‚àÖ}. Therefore, it is enough to use the same constant as identity both in MSPlaces and in Marking in order to obtain the desired domain.
Then, a ŒΩ-APN is simply a system module of Maude that rewrites terms of sort
Marking. The construction of the rewrite theory can be rather cumbersome for

systems of medium size. This is because the Maude system module corresponding to the ŒΩ-APN translation of the given MSPN system can be much bigger and quite different to that of the original system. In fact, if Var (t) has n different variables then t produces Bn different rules, where Bn is the n-th Bell‚Äôs number. Therefore, to develop it in an automatic way using the Maude system, we define a signature for MSPN systems so that they can be represented as Maude terms of sort NetSystem. We represent nets as sets of arcs and places (in order to allow the existence of isolated places). We need auxiliary sorts for labels, colours, variables and others that we do not mention here. Some of the main constructors are the following:
subsorts Place Arc < Net < NetSystem .
op _-_->_ : Place Var Transition -> Arc . op _,_ : Net Net -> Net [assoc comm] .
op _-_ : NetSystem NetSystem -> NetSystem [assoc comm] .
As an example to illustrate the signature, we can define the following constants, that represent the MSPN system in Fig. 7.
ops N1 N2 : -> Net . op S : -> NetSystem .
eq N1 = ((l,locality) - y -> [t1,go]) , ((q,black) - eps -> [t2,new]) ,
([t1,go] - eps -> (p,black)),([t2,new] - y -> (a,identifier)),
((p,black) - eps -> [t3,s ?]),((a,identifier) - x -> [t3,s ?]).
eq N2 = ((r,black) - eps -> [t4,s !]),([t4,s !] - x -> (b,identifier)) . eq S = N1 - N2 . 
We take advantage of the reflective properties of Maude in order to automatically perform the desired translation, by means of a function
op moduleOf : NetSystem -> SModule .
that returns the metarepresentation of the Maude system module that gives us the translation of the given system into an equivalent ŒΩ-APN. We can use the module moduleOf(S) to query about the behaviour of S. For instance, we can execute S from an initial marking
red metaRewrite(moduleOf(S),upTerm((rid1,black)+(pid2,locality)),
unbounded) .
or ask whether a marking is reachable from an intitial marking
red metaSearch(moduleOf(S),upTerm((rid1,black)+(pid2,locality), upTerm((rid2,black)+(sid1,locality)),‚Äô*,unbounded,0) .
In [15] we proved that coverability is decidable for MSPN systems. We have implemented in Maude the decision procedure used there, by means of
op cover : Marking Marking SModule -> Bool .
In order to avoid the user the torment of introducing the description of a system by hand, we have implemented an interface with one of the many existing graphical tools that deal with Petri nets. We have chosen CPN Tools [13], since it is probably the most widely used tool in the Petri Net community. By using CPN Tools we can draw Coloured Petri nets in a friendly way. Those nets are stored in a special format called CPNML, which is just an XML type definition. We have used the XML ‚àí > Maude translator written by Steven Eker. The obtained file contains a module ‚ÄúTRANSLATION‚Äù that declares a constant ‚Äútranslation‚Äù defined by a

term over a Maude signature for XML documents. To conclude we just need to define the mapping from these translations into NetSystem terms.
op translate : Element -> NetSystem . op translatedNet : -> NetSystem .
eq translatedNet = translate(translation) .
Thus, the term moduleOf(translatedNet) is the metarepresentation of the system module corresponding to the system drawn in CPN Tools. Therefore we can, for instance, use it as an input for the coverability function shown before.

Conclusions and future work
In this paper we have introduced a possible approach for the verification of MSPN systems, based on a translation to rewriting logic, that is a natural semantic frame- work for concurrent systems. We have defined ŒΩ-APN‚Äôs, that capture the essential characteristics of MSPN systems, and formalized the translation from a ŒΩ-APNs to an equivalent rewrite theory. The resulting theory can be implemented in Maude, and we can use the reflective properties of Maude in order to automatically perform the translation.
As future work, we plan to improve and enhance our Maude prototype, since it is still at a very early stage. For instance, we have only defined a one-way translation, from MSPN systems to Maude modules. It would be desirable to be able to deal with markings in the same level as MSPN systems, so that we could also use CPN Tools to enter initial markings or markings to reach or cover. For that purpose we would need to implement not only the function NF , but also NF ‚àí1. Moreover, from the point of view of verification it would be essential to have a link from the translation back to the original model.
In the last section we have mentioned an algorithm to decide the coverability problem of MSPN systems. However, that algorithm is far from efficient. Although some of the causes can be mitigated, the problem lies in the fact that the backward analysis produces an explosion on the set of predecessor markings, even with the ideal-based representation of sets of markings we use. We plan to study in depth the complexity of the algorithm, and we are currently studying the possibility of using a forward analysis instead, that as in [2] should contribute to increase the efficiency of the algorithm. We also plan to combine that approach with the introduction of abstractions or appropriate type systems, that would turn our analysis incomplete, but at the same time more manageable when applicable.
So far, we have only defined the behaviour of our nets by means of firings, so that the implicit semantics that we are considering is in fact a trace semantics. We also plan to extend the existing works on firings of bags of transitions and process semantics of Petri nets to our setting and study to which extent the developed translation into rewriting logic preserves also those concurrent semantics.
It would also be interesting studying how we can use Maude built-in facilities in the analysis of our systems. Finally, since we are using the CPNML markup language to represent MSPN systems, it would be desirable to have a type definition to detect documents that, although syntactically correct according to CPNML, do

not represent any MSPN system.

Acknowledgements
The author would like to thank David de Frutos and Alberto Verdejo for their valuable comments and Steven Eker for his XML‚ÜíMaude translator.

References
A. Asperti, and N. Busi. Mobile Petri Nets. Technical Report UBLCS-96-10, University of Bologna, 1996.
P. A. Abdulla, A. Collomb-Annichini, A. Bouajjani, and B. Jonsson. Using forward reachability analysis for verification of lossy channel systems. Formal Methods in System Design, 25(1):39‚Äì65, 2004.
M.A. Bednarczyk, L. Bernardinello, W. Pawlowski, and L. Pomello. Modelling Mobility with Petri Hypernets. 17th Int. Conf. on Recent Trends in Algebraic Development Techniques, WADT‚Äô04. LNCS vol. 3423, Springer-Verlag, 2004.
A. Bouhoula, J. Jouannaud and J. Meseguer. Specification and proof in membership equational logic.
Theoretical Computer Science, vol. 236(1-2), pp. 35-132, 2000.
L. Cardelli. Abstractions for Mobile Computation. Secure Internet Progr., Security Issues for Mobile and Distributed Objects, LNCS vol. 1603. Springer-Verlag, 1999.
M. Clavel, F. Dur¬¥an, S. Eker, P. Lincoln, N. Mart¬¥ƒ±-Oliet, J. Meseguer and C. Talcott. The Maude 2.0 System. In Proc. Rewriting Techniques and Applications, 2003. LNCS vol. 2706, pp. 76‚Äì87. Springer- Verlag, 2003.
K. Jensen. Coloured Petri Nets. Basic Concepts, Analysis Methods and Practical Use. Volume 1, Basic Concepts. Monographs in Theoretical Computer Science, Springer-Verlag, 2nd corrected printing 1997. ISBN: 3-540-60943-1.
O. Kummer. Referenznetze. Logos-Verlag, 2002.
I.A. Lomazova. Nested Petri Nets; Multi-level and Recursive Systems. Fundamenta Informaticae vol.47, pp.283-293. IOS Press, 2002.
N. Mart¬¥ƒ±-Oliet and J. Meseguer. Rewriting logical as a logical and semantic framework. ENTCS vol. 4, 2000.
J. Meseguer and U. Montanari. Petri Nets are Monoids: a New Algebraic Foundation for Net Theory. In Proc. 3rd Annual Symposium on Logic in Computer Science, pp. 155-164. IEEE Comput. Soc. Press, 1988.
R. Milner. Theories for the Global Ubiquitous Computer. Foundations of Software Science and Computation Structures-FoSSaCS 2004, LNCS vol.2987, pp.5-11. Springer-Verlag, 2004.
A.V. Ratzer, L. Wells, H.M. Lassen, M. Laursen, J.F. Qvortrup, M.S. Stissing, M. Westergaard,
S. Christensen, K. Jensen. Tools for Editing, Simulating, and Analysing Coloured Petri Nets. In Applications and Theory of Petri Nets, ICATPN 2003, LNCS vol. 2679, pp. 450-462. Springer-Verlag, 2003.
F. Rosa Velardo, O. Marroqu¬¥ƒ±n Alonso and D. Frutos Escrig. Mobile Synchronizing Petri Nets: a choreographic approach for coordination in Ubiquitous Systems. In 1st Int. Workshop on Methods and Tools for Coordinating Concurrent, Distributed and Mobile Systems, MTCoord‚Äô05. ENTCS, 150.
F. Rosa Velardo, D. Frutos Escrig and O. Marroqu¬¥ƒ±n Alonso. On the expressiveness of Mobile Synchronizing Petri Nets. In 3rd International Workshop on Security Issues in Concurrency, SecCo‚Äô05. ENTCS (to appear). http://kimba.mat.ucm.es/Àúfrosa.
M. Stehr, J. Meseguer and P.C. O¬® lveczky. Rewriting Logic as a Unifying Framework for Petri Nets.
In Unifying Petri Nets, Advances in Petri Nets. LNCS, vol. 2128, pp. 250-303. Springer-Verlag, 2001.
M. Stehr, J. Meseguer and P.C. O¬® lveczky. Representation and Execution of Petri Nets Using Rewriting Logic as a Uniform Framework. In Uniform Approaches to Graphical Process Specification Techniques, UNIGRA‚Äô01. ENTCS, vol. 44, 2001.
P. Thati, K. Sen, and N. Mart¬¥ƒ±-Oliet. An Executable Specification of Asynchronous Pi-Calculus Semantics and May Testing in Maude 2.0. ENTCS, 71, 2002.


R. Valk. Petri Nets as Token Objects: An Introduction to Elementary Object Nets. Applications and Theory of Petri Nets 1998, LNCS vol.1420, pp.1-25, Springer-Verlag, 1998.
Alberto Verdejo and Narciso Mart¬¥ƒ±-Oliet. Implementing CCS in Maude 2. Electr. Notes Theor. Comput. Sci., 71, 2002.
