Electronic Notes in Theoretical Computer Science 125 (2005) 67–89  
www.elsevier.com/locate/entcs


Metareasoning about Security Protocols using Distributed Temporal Logic
Carlos Caleiro1
CLC, Department of Mathematics, IST, Lisbon, Portugal
Luca Vigan`o2	David Basin3
Department of Computer Science, ETH Zurich, Switzerland

Abstract
We introduce a version of distributed temporal logic for rigorously formalizing and proving met- alevel properties of different protocol models, and establishing relationships between models. The resulting logic is quite expressive and provides a natural, intuitive language for formalizing both local (agent specific) and global properties of distributed communicating processes. Through a sequence of examples, we show how this logic may be applied to formalize and establish the cor- rectness of different modeling and simplification techniques, which play a role in building effective protocol tools.
Keywords: Security protocols, protocol models, intruder models, distributed temporal logic, secrecy, authentication, metareasoning.


Introduction
Many security protocols have been proposed to help build secure distributed systems. Given how difficult it is for humans to predict all the possible ways

1 Email: ccal@math.ist.utl.pt
2 Email: vigano@inf.ethz.ch
3 Email: basin@inf.ethz.ch
This work was partially supported by FCT and EU FEDER via the Project FibLog POCTI/MAT/37239/2001 of CLC, and by the FET Open Project IST-2001-39252 and BBW Project 02.0431, “AVISPA: Automated Validation of Internet Security Protocols and Applications”.


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.05.020


for distributed computation to proceed, it is not so surprising that attacks have been found on many protocols that were originally believed to be secure. Due to the subtlety of the problem, the use of formal methods for analyzing security protocols has been gaining popularity, e.g. [1,2,5,10,13,14,15,16]. In this paper, we report on how a suitable version of temporal logic for communicating agents can be used as a metalevel tool for analyzing security protocol models and properties.
Our starting point is the distributed temporal logic DTL of [9], which focuses on the expressibility of properties from the local point of view of each agent, and which we extend in order to also express global properties. Aside from its clean interpretation structures, which provide a simple, intu- itive model of distributed systems, our reasons for using this logic are primarily threefold. First, it is well-suited for specifying and reasoning about communi- cating agents in distributed systems. Second, its temporal dimension can be effectively used to formalize and reason about interleaved protocol executions. Finally, its distributed dimension, with explicit agent identifiers, supports an elegant formalization of the different security goals that protocols are supposed to achieve, such as different forms of authentication and secrecy.
The logic we introduce here provides an object level tool where we can specify and reason about specific protocols and the properties that the proto- cols are supposed to establish. In particular, as we describe in [3,4], using the logic it is possible to specify a protocol-independent distributed communica- tion model, on top of which protocols can be formally defined and analyzed. The principal aim of our work, however, is not the mere ad hoc analysis of specific protocols. Rather, our long-term objective is to use our logic as a metalevel tool for the comparative analysis of security protocol models and properties. Our logic provides a basis to rigorously investigate general met- alevel properties of different protocol models by establishing modeling and analysis simplification techniques that contribute to the sound design of ef- fective protocol validation tools. In this regard, we believe that our logic can contribute to clarifying the concepts involved by providing a basis for naturally representing and reasoning about the underlying computational models.
We anticipate several applications. The most direct consists of a rigorous account of different widely used simplification techniques, as we discuss in this paper. We prove here a general lemma about secret data that is similar to the secrecy theorems of [7,12]. We also obtain soundness and completeness results, with respect to typical security goals, for two model-simplification techniques: one intruder is enough, along the lines of [6], and the predatory intruder, a restriction on the behavior of the intruder, variants of which underly the trace models used in practice, e.g. [14]. While these results, mutatis mutandis, have


already been shown for other particular formalisms, our logic provides a means for proving them in a general and uniform way within the same formalism, which paves the way for further general investigations. Our formalization has also allowed us to clarify aspects of these simplification properties that are often neglected or cannot be specified in the first place (e.g. concerning principals’ identities and the way security properties are established).
We have also begun applying our logic to other metatheoretical investiga- tions, such as developing appropriate partial-order techniques that may reduce the (potentially infinite) state-space exploration involved in model-checking protocol properties (cf. [2]). This is work in progress and the first results are promising.
We proceed as follows. In §2 we introduce our distributed temporal logic. Using the logic, in §3, we define a protocol-independent distributed communi- cation model, on top of which protocols and security goals can be formalized and analyzed, as shown in §4. In §5 we present metalevel results, and conclude in §6 with a discussion of related and future work.

Distributed temporal logic
DTL [9] is a logic for reasoning about temporal properties of distributed sys- tems from the local point of view of the system’s agents, which are assumed to execute sequentially and to interact by means of synchronous event sharing. Distribution is implicit, making it easier to state the properties of an entire system through the local properties of its agents and their interaction. Herein, we introduce a minor extension of DTL tailored also to support the smooth formalization and proof of global properties.
The logic is defined over a distributed signature
Σ= ⟨Id, {Acti}i∈Id, {Propi}i∈Id⟩
of a system, where Id is a finite set of agent identiﬁers and, for each i ∈ Id, Acti is a set of local action symbols and Propi is a set of local state propositions. The global language L is defined by the grammar
L ::= @i[Li] | ⊥ | L ⇒ L ,
for i ∈ Id, where the local languages Li are defined by
Li ::= Acti | Propi | ⊥ | Li ⇒ Li | Li U Li | Li S Li | @j[Lj] ,
with j ∈ Id. Locally for an agent, U and S are respectively the until and
since temporal operators. Actions correspond to true statements about an


e1 	 e4	 e5	 e8	 . . . 
	
e2 	 e4	 e7	 e8	 . . . 
e3 	 e4	 e6	 e7	 e9	 . . . 

Fig. 1. A distributed life-cycle for agents A, B and C.

π (∅) αA(e1 ) π ({e }) αA (e4 ) π ({e ,e }) αA(e5 ) π ({e ,e ,e })αA(e8 ) . . . 

A	A	1
A	1 4
A	1  4  5


Fig. 2. The progress of agent A.
agent when they have just occurred, whereas state propositions characterize the current local states of the agents. Note that @j[ϕ] means different things depending on the context. If it is a global formula, it means that ϕ holds at the current local state of agent j. If it is a local formula appearing inside an @i-formula then it is called a communication formula and it means that agent i has just communicated with agent j for whom ϕ held.
The interpretation structures of L are suitably labeled distributed life- cycles, built upon a simplified form of Winskel’s event structures [19]. For brevity, we just give an outline of their definition here and refer to [3] for details. A local life-cycle of an agent i ∈ Id is a pair λi = ⟨Evi, →i⟩, where Evi is the set of local events and →i ⊆ Evi ×Evi is the local successor relation, such that the transitive closure →∗ defines a well-founded total order of local
causality on Evi. A distributed life-cycle is a family λ = {λi}i∈Id of local
life-cycles such that the transitive closure →∗ o f → =  i∈Id →i defines a

last condition is essential since events can be shared by several agents at
communication points.
We can check the progress of an agent by collecting all the local events that have occurred up to a certain point. This yields the notion of the local conﬁguration of an agent i: a finite set ξi ⊆ Evi closed under local causality,
i.e. if e →∗ e' and e' ∈ ξi then also e ∈ ξi. The set Ξi of all local configurations of an agent i is clearly totally ordered by inclusion and has ∅ as the minimal element. In general, each non-empty local configuration ξi is reached, by the occurrence of an event that we call last(ξi), from the local configuration
ξi \ {last(ξi)}. We can also define the notion of a global conﬁguration: a finite set ξ ⊆ Ev closed for global causality, i.e. if e →∗ e' and e' ∈ ξ then also e ∈ ξ. The set Ξ of all global configurations constitutes a lattice, under inclusion, and has ∅ as the minimal element. Clearly, every global configuration ξ includes
the local configuration ξ|i = ξ ∩ Evi of each agent i. Given e ∈ Ev, note that
e↓= {e' ∈ Ev | e' →∗ e} is always a global configuration.
An interpretation structure µ = ⟨λ, α, π⟩ consists of a distributed life-cycle



{e1 } ¸	{e1 , e2}¸	{e1 , e2, e3, e4, e5 }


¸¸ .¸.¸..	¸¸¸¸¸
,,,,,,

... ¸¸	¸
,,,
... 

∅ ¸¸
{e2 } ¸	{e1 , e3}  {e1 e2, e3 }  {e1 , e2, e3 , e¸4}


¸¸¸¸
¸¸¸ ¸   
....
¸¸¸¸¸¸

¸	sss ¸¸	...	¸¸

{e3 }
{e2 , e3}
{e1 , e2, e3, e4, e6 }


Fig. 3. The lattice of global configurations.

λ plus families α = {αi}i∈Id and π = {πi}i∈Id of local labeling functions. For each i ∈ Id, αi : Evi → Acti associates a local action to each local event, and πi : Ξi → ℘(Propi) associates a set of local state propositions to each local configuration. We denote the tuple ⟨λi, αi, πi⟩ also by µi.
Fig. 1 illustrates the notion of a distributed life-cycle, where each row com- prises the local life-cycle of one agent. In particular, EvA = {e1, e4, e5, e8,... } and →A corresponds to the arrows in A’s row. We can think of the occur- rence of the event e1 as leading agent A from its initial configuration ∅ to the configuration {e1}, and then of the occurrence of the event e4 as leading to configuration {e1, e4}, and so on; the state-transition sequence of agent A is displayed in Fig. 2. Shared events at communication points are highlighted by the dotted vertical lines. Note that the numbers annotating the events are there only for convenience since no global total order on events is in general imposed. Fig. 3 shows the corresponding lattice of global configurations.
We can then define the global satisfaction relation at a global configuration
ξ of µ as
µ, ξ H @i(ϕ) if µ, ξ|i Hi ϕ;
µ, ξ /H ⊥;
µ, ξ H γ ⇒ δ if µ, ξ /H γ or µ, ξ H δ,
where the local satisfaction relations at local configurations are defined by
µ, ξi Hi act if ξi /= ∅ and αi(last(ξi)) = act;
µ, ξi Hi p if p ∈ πi(ξi);
µ, ξi /Hi ⊥;
µ, ξi Hi ϕ ⇒ ψ if µ, ξi /Hi ϕ or µ, ξi Hi ψ;
µ, ξi Hi ϕ U ψ if there exists ξ'' ∈ Ξi with ξi  ξ'' such that µ, ξ'' Hi ψ,
i	i	i
and µ, ξ' Hi ϕ for every ξ' ∈ Ξi with ξi  ξ'  ξ'';
i	i	i	i
µ, ξi Hi ϕ S ψ if there exists ξ'' ∈ Ξi with ξ''  ξi such that µ, ξ'' Hi ψ,
i	i	i
and µ, ξ' Hi ϕ for every ξ' ∈ Ξi with ξ''  ξ'  ξi;
i	i	i	i
µ, ξi Hi @j[ϕ] if ξi /= ∅, last(ξi) ∈ Evj and µ, (last(ξi) ↓)|j Hj ϕ.



 
  ϕ	 ¬ ϕ	 ϕ	 


 e ϕ 


 . . . 

A	1	4	5	8
 	  	     	  	  

B	e2	e4
  ψ	ψ
 	 
∅
e7	e8
ψ	@A[ϕ]
 
 ξ'
... 


Fig. 4. Satisfaction of formulas.
We say that µ is a model of Γ ⊆ L if µ, ξ H γ for every global configuration ξ
of µ and every γ ∈ Γ. Other standard operators are defined as abbreviations,
e.g. ч, T, V, Λ, and


X ϕ ≡ ⊥ U ϕ  next
Y ϕ ≡ ⊥ S ϕ  previous
F ϕ ≡ T U ϕ sometime in the future
P ϕ ≡ T S ϕ  sometime in the past
G ϕ ≡ ч F ч ϕ always in the future
H ϕ ≡ ч P ч ϕ always in the past
† ≡ ч X T	in the end
∗ ≡ ч Y T	in the beginning
F◦ ϕ ≡ ϕ V F ϕ now or sometime in the future P◦ ϕ ≡ ϕ V P ϕ now or sometime in the past G◦ ϕ ≡ ϕ Λ G ϕ now and always in the future H◦ ϕ ≡ ϕ Λ H ϕ now and always in the past

Fig. 4 illustrates the satisfaction relation with respect to communication formulas of our running example. Clearly µ, ∅ H @B[ψU@A[ϕ]], because µ, ξ' H @B[@A[ϕ]]. Note however that µ, ξ /H @B[@A[ϕ]], although µ, ξ H @A[ϕ].
Rules for proving invariants by induction can be established in our logic in the standard way (see [3,4]).

The network model
We provide a specification of a generic open network where agents interact by exchanging messages through an insecure public channel. A network signature is a pair ⟨Princ, Name⟩, where Princ is a finite set of principal identifiers A, B, C,... , and Name is a family {NameA}A∈Princ of pairwise disjoint finite
sets of names, corresponding to the possible aliases used by each principal (the
importance of aliases will become clearer below, e.g. in §5.2). We use primed notation to denote names, e.g. writing A' to denote a name used by principal
A. By abuse of notation, we also use Name =  A∈Princ NameA. Furthermore,
we assume fixed two sets Nonce and Key of “numbers” that can be used as
nonces and keys, respectively, and whose members we denote by N and K, possibly with annotations. In general, we assume that several kinds of keys can coexist and that each key K has its own inverse key K−1. Messages,


which we denote by M , possibly with annotations, are built inductively from atomic messages (names and “numbers”), by concatenation (; ), which we assume to be associative, and encryption under a key K ({}K). The set Msg of messages is thus defined by
Msg ::= Name | Nonce | Key | Msg; Msg | {Msg}Key .
Note that we consider an equational signature with four sorts, namely the sort of messages and its subsorts names, nonces and keys, where we follow the usual free-algebra assumption so that syntactically different terms denote different messages.
Given a network signature ⟨Princ, Name⟩, we obtain a distributed signa- ture by taking Id = Princ {Ch}, where Ch is the communication channel (used to model asynchronous communication), and defining the local alphabet of each agent (the principals and the channel) as follows. The signature of a principal A requires actions ActA and state propositions PropA, where ActA includes
send(M, B') — sending of the message M to B';
rec(M ) — reception of the message M ;
spy(M ) — eavesdropping of the message M ; and
nonce(N ) — generation of the fresh nonce N ,
and PropA includes
knows(M ) — knowledge of the message M .
Note that we do not explore the epistemic dimension of this knowledge.
For the channel Ch we do not require any state propositions, i.e. PropCh =
∅, whereas the actions ActCh include
in(M, A') — arrival at the channel of the message M addressed to A';
out(M, A') — delivery of the message M from the channel to principal
A; and
leak — leaking of messages.
The model could, of course, be extended in many ways. For example, we could include other kinds of message constructors (e.g. for hashing and expo- nentiation), or further actions and state propositions. We will consider such extensions in future work, where we will also include servers and further chan- nels with distinct accessibility and reliability properties. For now, however, the above is enough to abstractly formalize and reason about the properties of communication between principals executing security protocols.
In the network model that we define, principals can send and receive mes- sages, at will, always through the channel. If the principal A sends a message


to B', then the message synchronously arrives at the channel, where it is stored for future delivery to B. If delivery ever happens, it must be synchronized with the corresponding receive action of B. However, the principal A can only send M to B' if A knows both the name B' and how to produce the message M . As usual, the knowledge of principals is not static. In addition to their initial knowledge, principals gain knowledge from the messages they receive and the fresh nonces they generate. Principals may also spy on messages being leaked
by the channel and learn their content. We do not allow principals to explic- itly divert messages, but we also do not guarantee that messages delivered to the channel are ever received.
To ensure that principals cannot learn messages in an ad hoc fashion, we specify that the knows propositions only hold where strictly necessary. To this end, we follow the idea underlying Paulson’s inductive model [14], in accor- dance with the usual assumption of perfect cryptography (that the only way to decrypt an encrypted message is to have the appropriate key). We restrict attention to those interpretation structures µ such that, for every principal A, the following condition holds for all messages M and global configurations ξ ∈ Ξ such that ξ|A /= ∅:
(K) µ, ξ HA knows(M ) iff M ∈ synth(analz({M ' | µ, ξ HA (Y knows(M ')) V
rec(M ') V spy(M ') V nonce(M ')})),
where analz and synth are the functions representing how principals analyze or synthesize messages from a given set of messages (see, e.g., [14]). Note that (K) implies that, in every model µ = ⟨λ, α, π⟩ of the specification, π is completely determined by λ and α, given πA(∅) for each A ∈ Princ. This is equivalent to saying that the knowledge of each principal only depends on its initial knowledge and on the actions that have occurred. A number of other useful properties follow from (K), e.g. for each principal A ∈ Princ:
(K1) @A[knows(M1; M2) ⇔ (knows(M1) Λ knows(M2))];
(K2) @A[(knows(M ) Λ knows(K)) ⇒ knows({M }K)];
(K3) @A[(knows({M }K) Λ knows(K−1)) ⇒ knows(M )]; (K4) @A[knows(M ) ⇒ G◦ knows(M )];
(K5) @A[rec(M ) ⇒ knows(M )];
(K6) @A[spy(M ) ⇒ knows(M )]; and
(K7) @A[nonce(N ) ⇒ knows(N )].
To guarantee the freshness and uniqueness of the nonces generated by each principal, we further require the axioms
(N1) @A[nonce(N ) ⇒ Y ч knows(MN )],

(N2) @A[nonce(N )] ⇒  B∈Princ\{A} @B[ч knows(MN )],
where MN ranges over all the messages containing the nonce N . Together with (K7), (N1) and (N2) guarantee that every nonce is generated at most once, if at all, in each model, and always freshly (also taking into account the initial knowledge of all agents). The specification of the network model also comprises a number of axioms that characterize the behavior of the channel and of each principal A ∈ Princ:
(C1) @Ch[in(M, A') ⇒  B∈Princ @B[send(M, A')]];
(C2) @Ch[out(M, A') ⇒ P in(M, A')]]; and
(C3) @Ch[out(M, A') ⇒ @A[rec(M )]],
(P1) @A[send(M, B') ⇒ Y(knows(M ) Λ knows(B'))];
(P2) @A[send(M, B') ⇒ @Ch[in(M, B')]];

(P3) @A[rec(M ) ⇒ @Ch[  A'∈Name
(P4) @A[spy(M ) ⇒ @Ch[leak Λ P
out(M, A')]];
A
B' ∈Name in(M, B')]];

(P5) @A[  B∈Princ\{A} ч@B[T]]; and
(P6) @A[nonce(N ) ⇒ ч @Ch[T]].
The channel axioms (C1–C3) are straightforward. They state that a message addressed to A' only arrives at the channel if it is sent to A' by some principal B; that the channel only delivers a message to A' if such a message for A' has previously arrived; and that if the channel delivers a message to A' then A receives it. The principal axioms are also simple. (P1) is a precondition for sending a message, stating that the sender must know both the message and the recipient’s name beforehand. The next three formulas are interaction axioms. (P2) and (P3) state that the sending and receiving of messages, re- spectively, must be shared with the corresponding arrival and delivery actions of the channel. (P4) guarantees that a spied message must have arrived at
the channel, addressed to some recipient. The two final axioms limit the possi- ble interactions: (P5) guarantees that principals never communicate directly (only through the channel), and (P6) states that nonce generating actions are not communication actions.

Modeling security protocols
Protocols are usually informally described by short sequences of messages that are exchanged by principals in order to achieve particular security goals in open, hostile environments. We model protocols on top of our network.
We illustrate protocol modeling by using a standard example: the (flawed)


simplified Needham-Schroeder Public Key Protocol NSPK [10], which we present as the following sequence of message exchange steps.
(step1) a → b : (n1). {n1; a}Kb
(step2) b → a : (n2). {n1; n2}Ka
(step3) a → b :	{n2}Kb
In this notation, a and b are variables of sort name that denote the roles played in one execution of the protocol, and n1 and n2 are variables of sort nonce. The arrows represent communication from the sender to the receiver. The parenthesized nonces prefixing the first and second messages signify that these nonces must be freshly generated before the message is sent. Moreover, it is assumed that public and private keys have been generated and appropriately distributed: Ka represents the public key of a, whose inverse key should be private, i.e. known by no one but the principal using that name. Although other possibilities, such as shared keys, could be easily added to the model, we refrain from doing so here, for simplicity, and assume that these are the only existing keys.
Formalizing a protocol like the above involves defining the sequences of actions (send, rec, and nonce) taken by honest agents executing the protocol. Namely, for each role, we formalize the actions taken and the order in which they must be taken. In the case of NSPK, there are two roles: an initiator role Init, represented by a, and a responder role Resp, represented by b. Given distinct names A' and B', of principals A and B respectively, and nonces
N1 and N2, the role instantiations should correspond to the execution, by
principal A, of the sequence of actions runInit(A', B', N1, N2):
⟨nonce(N1).send({N1; A'}K ' , B').rec({N1; N2}K ' ).send({N2}K ' , B')⟩ ,
and to the execution, by principal B, of the sequence runResp(A', B',N ,N ):
B	1	2
⟨rec({N1; A'}KB' ).nonce(N2).send({N1; N2}KA' , A').rec({N2}KB' )⟩ .
In the remainder of the paper, we use w = ⟨w1.w2.w3 ... ⟩ to denote a (possibly infinite) sequence composed of the elements w1, w2, w3,... , and we use |w| to denote its length. Of course, ⟨⟩ denotes the empty sequence and
|⟨⟩| = 0. We assume that |w| = ∞ if w is infinite. We write w . w' to denote sequence concatenation, provided that the first sequence is finite.
In general, a protocol description like the one above may involve j name variables a1,... , aj, corresponding to j distinct roles, and k nonce variables n1,... , nk, and consist of a sequence ⟨step1 ... stepm⟩ of message exchange

steps, each of the form
(stepq )	as → ar  : (nq1 ,... , nqt ). M ,
where M can include any of the name and nonce variables. A protocol in- stantiation is a variable substitution σ such that each σ(ai) ∈ Name, each σ(ni) ∈ Nonce, and σ is injective on name variables, i.e. if i1 /= i2 then σ(ai1 ) /= σ(ai2 ). We extend σ to messages, actions, sequences, and formu- las in the natural way. Each instantiation prescribes a concrete sequence of actions to be executed by each of the participants in a run of the protocol: for each role i, if σ(ai) ∈ NameA then we have the corresponding sequence
runi (σ)= σ(stepi ) . ··· . σ(stepi ) where
1	m
⎧ ⟨nonce(nq1 ) ... nonce(nqt ).send(M, ar)⟩ if i = s, stepi =	⟨rec(M )⟩	if i = r,
⎪⎩ ⟨⟩	if i /= s and i /= r.
We can easily formalize in the logic the complete execution by principal A
of the run corresponding to role i of the protocol. If runi (σ)= ⟨act1 ... actn⟩
then we can consider the local formula rolei (σ):
actn Λ P(actn−1 Λ P(... Λ P act1) ... ) .
In general, if we denote the set of all protocol instantiations by Inst, we

can define the set Runsi
of all possible concrete runs of principal A in role i,

and the set RunsA of all of A’s possible concrete runs in any of the j roles:

Runsi =   {runi (σ) | σ(ai) ∈ NameA}	and	RunsA =  Runsi .

A	A
σ∈Inst
A
i=1

It should be clear that µ, ξ H @A[rolei (σ)] if and only if A has just completed the required sequence of actions runi (σ) at ξ. Often, in examples, we will use a¯ = ⟨a1 ... aj⟩ and n¯ = ⟨n1 ... nk⟩, and write runi (σ(a¯), σ(n¯)) instead of
runi (σ), and rolei (σ(a¯), σ(n¯)) instead of rolei (σ).
A	A	A

Honesty
We take an external view of the system, and consider a protocol signature to be a triple ⟨Hon, Intr, Name⟩ where Hon and Intr are disjoint sets of honest and intruder principals, and ⟨Hon ∪ Intr, Name⟩ is a network signature such that every honest principal has exactly one name. Note that this implies that


no honest agent will ever play two different roles in the same run of a protocol. Without loss of generality, we assume that NameA = {A} for every A ∈ Hon. This implies that if we know that a principal A is honest then we always write A instead of A'. We assume also that the private key of each honest principal
is initially only known by that principal. This can be achieved by the axioms
(Key1) and (Key2) below, where A ∈ Hon:
(Key1) @A[∗⇒ knows(K−1)]; and
(Key2) @B[∗⇒ ч knows(M )], for every B ∈ Princ \ {A} and every M con- taining K−1.
Models of a protocol are those network models where, furthermore, all honest principals strictly follow the rules of the protocol. That is, for every A ∈ Hon, if the local life-cycle of A is e1 →A e2 →A e3 →A ... , then the corresponding (possibly infinite) sequence of actions


w(A)= ⟨αA(e1).αA(e2).αA(e3) ... ⟩


must be an interleaving of prefixes of sequences in RunsA, but using distinct fresh nonces in each of them. Formally, we say that two sequences of actions w and w' are independent provided that if wi = nonce(N ), for some i ≤ |w|
and N ∈ Nonce, then w' /= nonce(N ) for every j ≤ |w'|. The requirement
on protocol models can now be rigorously defined. For each A ∈ Hon, there
must exist a set W ⊆ RunsA of pairwise independent sequences such that for every i ≤ |w(A)| it is possible to choose w ∈ W , j ≤ |w| and i1 < ··· < ij = i satisfying w(A)ik = wk for all k ≤ j.
Note that this is essentially equivalent to approaches such as [14], where the behavior of an honest agent A is defined inductively in such a way that the jth action of a sequence w ∈ RunsA can be executed only if the previous j − 1 actions have already been executed, or to strand spaces [17,18] where essentially the same sequences of RunsA are used to model honest agents. In all cases, the intruders (attackers or penetrators) can act freely, according to the standard Dolev-Yao capabilities.
In the case of the NSPK protocol, this means that the life-cycle of each honest agent must be built by interleaving prefixes of sequences of the form
runInit(A, B',N ,N ) or runResp(B', A,N ,N ), where no two such initiator
A	1	2	A	1	2
runs can have the same N1, no two responder runs can have the same N2, and
the N1 of an initiator run must be different from the N2 of any responder run.

Security goals
The aim of protocol analysis is to prove (or disprove) the correctness of a protocol with respect to the security goals that the protocol should achieve. For instance, the secrecy of the critical data exchanged during an execution of the protocol among its participants is one such goal. In addition, an honest principal running the protocol should be able to authenticate the identities of its protocol partners by examining the messages he receives. There are many approaches to specifying secrecy and authentication in the literature, depend- ing in part on the underlying model used. However, the various approaches mostly agree on the general picture. Below, we show how to formulate the required secrecy and authentication goals of protocols in the general case, illustrating them by means of the NSPK protocol.
As usual, given a security goal, we call an attack on a protocol any protocol model µ and configuration ξ for which the formula expressing the goal does not hold. Let us start with secrecy.

Secrecy
We can formalize that the messages in a finite set S will remain a shared secret between the participants A1,... , Aj after the complete execution of a protocol instantiation σ, with each σ(ai) ∈ NameAi , by the formula secrS(σ):




  @A [P◦ rolei
(σ)] ⇒		  @B[ч knows(M )].

i	Ai
i=1
B∈Princ\{A1 ,...,Aj } M ∈S

Of course, this property can only be expected to hold in particular situa- tions. Assume that all the participants are honest, i.e. each Ai ∈ Hon and so NameAi = {Ai}. One might then expect that the “critical” nonces generated during that run will remain a secret shared only by the participating princi- pals. Indeed, being honest, they will not reuse those nonces in further protocol runs. Using the logic, we can check the property secrσ(F )(σ) for the relevant set of fresh nonce variables F ⊆ {n1,... , nk}. As before, we sometimes write secrσ(F )(σ(a¯), σ(n¯)) instead of secrσ(F )(σ).
In the case of the NSPK protocol, this would amount to requiring that secr{N1 ,N2}(A, B, N1, N2) holds, with A and B both honest.

Authentication
There are many possible notions of authentication (see, e.g., [11]). How- ever, most authors agree that authentication expresses some kind of corre- spondence property between the messages an agent receives in a protocol run


and the messages that other participants of the same run are supposed to send. The typical authentication goal states that if an honest principal A completes his part of a run of a protocol in role i, with certain partners and data, then it must be the case that these partners have also been actively involved by sending to A the messages that he received.
Given a protocol instantiation σ such that σ(ai) = A ∈ Hon and σ(aj) ∈ NameB, the property that A authenticates B in role j at step q of the protocol can be defined in our logic by the formula authi,j,q (σ), which is
@A[rolei (σ)] ⇒ @B[P◦ send(σ(M ), A)], if B is honest, and
@A[rolei (σ)] ⇒    @C[P◦ send(σ(M ), A)], if B is dishonest,
C∈Intr
assuming that the protocol stepq requires that aj sends the message M to ai. Note that if we consider only one dishonest principal, as is usual, this distinc- tion vanishes, but our formalization is more general and we will make use of this generality later (see Proposition 5.3 below). We should therefore require authi,j,q (σ) to hold whenever step q is considered essential for authentication.
As before, we sometimes write authi,j,q (σ(a¯), σ(n¯)) instead of authi,j,q (σ).
A,B	A,B
In the case of the NSPK protocol, assuming for the moment that only one
dishonest principal exists, we could specify for honest A acting as initiator, the
Init,Resp,2	'
authentication of the responder at step 2 using authA,B	(A, B , N1, N2):

@ [roleInit(A, B',N ,N )] ⇒ @ [P send({N ; N }
, A)] ,

A	A	1	2	B  ◦	1	2 KA
and for honest B acting as responder, the authentication of the initiator at
Resp,Init,3	'
step 3 using authB,A	(A , B, N1, N2):
Resp	'
@B[roleB	(A , B, N1, N2)] ⇒ @A[P◦ send({N2}KB , B)] .
This last property fails in the man-in-the-middle attack on NSPK [10], as we show in [3,4].

Metalevel analysis of the model
Our protocol analysis framework is based on a logic that is not specifically tailored to security protocols, and we are thus not bound to any assumptions about the underlying protocol model. Rather, we can use our logic to specify and reason about different assumptions, proving different metalevel proper- ties of security protocol models, as well as the correctness of different model simplification techniques, within one and the same formalism in a uniform


way. We develop our proofs in the context of the general network model we have defined above, with explicit asynchronous communication through the channel, and where intruders are modeled as agents within the system.
In this section, we give three substantial examples of formally reasoning about simplification techniques for protocol models. These examples are in- teresting in their own right. Moreover, they also illustrate how our approach can help to clarify a number of underlying concepts that are often left implicit, or neglected, when considering such simplifications within other approaches.
Secret data
The following lemma is an example of the kind of metalevel property that any suitable network model should enjoy. Let S ⊆ Msg be a set of secret atomic messages (names, nonces, and keys), and denote by MsgS the set of S-secure messages, i.e. all messages where items from S can only appear if under the scope of an encryption with a key whose inverse is also in S. It should be clear that MsgS contains precisely the messages that can be securely circulated in the network without danger of compromising any of the secrets in S. Indeed, synth(analz(MsgS )) = MsgS and MsgS ∩ S = ∅.
More specifically, the following lemma states that under the assumption
that no principal in G will ever send an S-insecure message and that all the nonces in S are freshly generated among the principals in G, if at some point the S-insecure data is unknown outside of G, then it will forever remain so.
Lemma 5.1 (Secret Data) Assume that G ⊆ Princ is a group of princi-
H	'
M ∈/ MsgS and every name C', and µ H  A∈G @A[∗⇒ F nonce(N )] for every
µ, ξ H  B∈Princ\G @B[ч knows(M )] for every M ∈/ MsgS,
then also
µ, ξ H  B∈Princ\G @B[G◦ ч knows(M )] for every M ∈/ MsgS.
Proof. By induction on configurations ξ' ⊇ ξ. Assuming the base case, as given, it suffices to prove that, given ξ' ⊇ ξ, if µ, ξ' H @B[ч knows(M )] for
every M ∈/ MsgS and every principal B ∈/ G, and ξ' ∪ {e} ∈ Ξ, then also
µ, ξ' ∪ {e} H @B[ч knows(M )] for every M ∈/ MsgS and B ∈/ G.
Suppose, by absurdity, that µ, ξ'∪{e} H @B[knows(M )] for some M ∈/ MS and B ∈/ G. Then it must be the case that e ∈ EvB and so the local config- uration of all other principals does not change. Moreover, αB(e) cannot be a sending action since this would not change the local state of B. If αB(e) is ei-
ther rec(M '') or spy(M '') then it must be the case that M '' ∈/ MsgS , but, since


it had to have been previously sent to the channel, this is impossible. Indeed, by assumption, principals in G never send such messages, and no other prin- cipal could have sent it before. Hence, it must be a nonce(N ) action for some N ∈ S. But this contradicts the fresh nonce axioms because, by assumption, N is generated by some principal in G. Thus, µ, ξ' H @B[ч knows(M )] for
every M ∈/ MS, B ∈/ G and ξ' ⊇ ξ, and the result follows.	 

Note that the set Msg \ MsgS of S-insecure messages forms precisely what has been called an ideal in the context of strand spaces [17], whereas the set MsgS of S-secure messages is the corresponding coideal, in the terminology of [7,12]. In fact, Lemma 5.1 is a general result about the flow of data in the network, which is independent of protocols. The result can of course be used to reason about secrecy properties in protocol models, providing a result that is very similar to those found in [7,12]. Indeed, under reasonable conditions, the secrecy of generated nonces can be easily seen to hold.

Proposition 5.2 (Secrecy) A given protocol guarantees secrσ(F )(σ) for an instantiation σ with only honest participants σ(a1) = A1, ..., σ(aj) = Aj, provided that all the messages ever sent by A1,... , Aj in any protocol run are
({K−1,... , K−1}∪ σ(F ))-secure.
A1	Aj

Proof. The result follows by an application of the Secret Data Lemma 5.1,
using G = {A1,... , Aj} and S = {K−1,... , K−1}∪ σ(F ). Let µ be a protocol
A1	Aj
model, ξ a global configuration, and assume that µ, ξ H j	@A [P◦ rolei (σ)].
The assumption that A1,... , Aj will only send S-secure messages is the first
precondition for the application of the lemma. The second precondition of the lemma follows immediately from the fact that all the corresponding roles of the protocol have been completed and therefore all the nonces in S are generated in µ among the principals in G.
Take the initial configuration ∅. Clearly, no principal outside G initially knows S-insecure messages. For the nonces it is trivial as they are gen- erated in the model; for the keys it follows from the axioms (Key1) and (Key2).  By the lemma, we conclude that µ, ∅ H @B[G◦ ч knows(M )] for
every B ∈ Princ \ G and M ∈/ MsgS . In particular, we have that µ, ξ H
  B∈Princ\{A ,...,A }  N ∈σ(F ) @B [ч knows(N )].	 

Note that our assumption here that all the messages ever sent by A1,... , Aj
in any protocol run are ({K−1,... , K−1}∪ σ(F ))-secure is essentially equiva-
A1	Aj
lent to discreetness in the terminology of [7,12].

One intruder is enough
In the following, we distinguish between one-intruder and many-intruder pro- tocol signatures and models, depending on whether Intr is a singleton or not. Indeed, most approaches to protocol analysis only consider one-intruder mod- els. Below, we show that this simplification is adequate. We achieve this by postulating a unique intruder Z who controls the activity of all dishonest prin- cipals, by making Z inherit the initial knowledge of all of them and perform, in some compatible sequential order, all the actions each of them performed. Of course, this transformation should be transparent to honest agents.
Proposition 5.3 (One intruder is enough) The restricted class of one- intruder models is fully representative in the following sense: any attack on a protocol in a many-intruder model can be mapped to a corresponding attack in a one-intruder model.
Proof. Let cpΣ = ⟨Hon, Intr, Name⟩ be a many-intruder signature and as- sume that an attack on the security goal γ happens at configuration ξ of
µ = ⟨λ, α, π⟩. Consider the one-intruder signature cpΣ' = ⟨Hon, {Z}, Name'⟩,

with Name'
=  A∈Intr
NameA, and build µ' = ⟨λ', α', π'⟩ as follows: µ'  =

µA for every A ∈ Hon; µ'	= µCh; and λ'  = ⟨EvZ, →Z⟩ where EvZ =

  A∈Intr EvA and →Z is the successor relation a ssociated to some discrete lin-
ration, α' (e) = αA(e), where A ∈ Intr is the unique principal such that
Z
'	'
a one-intruder model of the protocol and ξ is still a configuration. We now show that:
µ, ξ H @A[ϕ] iff µ',ξ H @A[ϕ], for every A ∈ Hon and every ϕ ∈ LA that does not include communication subformulas; and
µ, ξ H	A∈Intr @A[P◦ act] iff µ',ξ H @Z[P◦ act ], for every action act.
Property (i) is an immediate consequence of the fact that µ' = µA for every
A ∈ Hon, if we note that, by definition, the satisfaction of a local formula with-
out communication subformulas only depends on the local life-cycle. Prop- erty (ii) follows directly from the fact that EvZ =  A∈Intr EvA, and for each e ∈ EvZ, α' (e) = αA(e) where A ∈ Intr is the unique principal such that
e ∈ EvA. Clearly, these two properties imply that if γ is an authentication
property then the attack must also appear at ξ in µ'. Indeed, if γ ≡ authi,j,q (σ) with honest A, then it follows from (i) that the antecedent @A[rolei (σ)] of the main implication in γ still holds at µ' and ξ since rolei (σ) ∈ LA does not in- clude communication subformulas. As for the consequent, if B is honest then @B[P◦ send(σ(M ), A)] must also fail at µ' and ξ, again by using (i), given that



  send	
spy1
nonce1

Z1 ...	•
... 	•	 ...	... 	•	 
... 

... 
...     nonce2   	 	rec		     spy2	 		  

Z2	•	•	•
Ch ...  	•	 ...  	•	•	 ...  	•	 		 . . . 

in
can be reduced to
... 
leak1
out
leak2
 ξ


 . . . 

Z
Ch ... 


in	leak1


out


leak2

 . . . 
 
 ξ

Fig. 5. The one-intruder reduction.

P◦ send(σ(M ), A) ∈ LB does not have communication subformulas. If B is dishonest then the failure of C∈Intr @C[P◦ send(σ(M ), A)] at µ and ξ implies the failure of @Z[P◦ send(σ(M ), A)] at µ' and ξ, according to (ii). Note that
if µ, ξ H  A∈Intr @A[knows(M )] then µ',ξ H @Z[knows(M )],
follows easily from (ii) and condition (K). Hence, an attack on a secrecy
property can be shown to appear at ξ in µ'. If γ ≡ secrσ(F )(σ) with all roles
played by honest principals then the antecedent  j	@A [P◦ rolei (σ)] of the
main implication in γ still holds at µ' and ξ, according to (i). To show that the consequent  B∈Princ\{A ,...,A }  N ∈σ(F ) @B[ч knows(N )] also fails at µ' and
ξ it now suffices to use either (i), for honest B, or (iii) for dishonest B.	 
Fig. 5 provides a visual example of this transformation. Note that in this case we chose a linearization where nonce1 happened before nonce2, but any other possibility would be fine, as long as the initial causal restrictions are met, namely, nonce1 must occur after spy1, and nonce2 must precede the occurrence of rec. Note that the other initial causal restrictions, such as the fact that send must precede spy1, are automatically met since the channel is preserved.
The one-intruder reduction is an intuitive and widely used simplification, but its proof can be enlightening. In fact, not only can the disjunctive view of the many dishonest principals be seen as a kind of “group intruder”, but the translation also caters for the one intruder as controlling all of them, for which our characterization of authentication in the presence of many intruders was essential. The result is similar to part of the one obtained in [6]. There, however, the intruder was modeled as an abstract entity, with an obvious counterpart on the way security properties were expressed. Our result takes this same view from inside the system since we model the intruder as a concrete entity, namely one (or several) of the principals.

The predatory intruder
Among the possible one-intruder models of a given protocol, many will feature a rather passive intruder. Any attack that can happen under these circum- stances should certainly also be achievable by a more effective intruder. In the following, we show that we can restrict attention to models where the intruder Z is relentlessly and effectively committed to his task, namely:
he spies every message sent by an honest agent immediately after it arrives to the channel, and that is all the spying he does:

@Ch[@Z[spy(M )] ⇔ Y 
A∈Hon
@A[	 
B' ∈Name
send(M, B')]] ;

he never bothers receiving messages (he has already spied them):
@Z[ч rec(M )] ;
he only sends messages to honest agents, and he manages to send every message just immediately before the honest agent gets it:
@Z[ч send(M, Z')]	and	@Z[send(M, A) ⇒ @Ch[X @A[rec(M )]]] .
We call any one-intruder model fulfilling these requirements a predatory in- truder protocol model. To show that this restriction is adequate, we need to be able to transform every one-intruder model into an attack-preserving preda- tory intruder model. The transformation amounts to purging all the (possibly erratic) old interactions of the intruder, and introducing new timely interac- tions according to the predatory intruder requirements, while not changing anything from the point of view of honest agents.
Proposition 5.4 (The predatory intruder) The restricted class of preda- tory intruder models is fully representative in the following sense: any attack on a protocol in a one-intruder model can be mapped to a corresponding attack in a predatory intruder model.
Proof. Let cpΣ= ⟨Hon, {Z}, Name⟩ be a one-intruder protocol signature and assume that an attack on the security goal γ happens at ξ of µ = ⟨λ, α, π⟩. Consider the sets Old = EvZ ∩ EvCh, Succ =  A∈Hon{e ∈ EvA | αA(e) = 
send()}, Orig(M, B')= {e ∈ EvCh | αCh(e)= in(M, B')} with M ∈ Msg and
B' ∈ Name, Pred =  A∈Hon{e ∈ EvA | αA(e) = rec(M ), {e' ∈ Orig(M, A) |
'	+ e} ⊆ Old}, and New = {s(e) | e ∈ Succ} ∪ {p(e) | e ∈ Pred}. Define
the model µ' = ⟨λ', α', π'⟩ as follows:
' = µA for every A ∈ Hon;



'	= ⟨Ev'
' ⟩ with Ev'
= (EvCh \ Old) ∪ New and →'
the

successor relation obtained from →∗
by letting e →'
s(e) for every

e ∈ Succ, and p(e) →'
e for every e ∈ Pred, α'
(e) = αCh(e) for

e ∈ EvCh \ Old, α'
(s(e)) = leak and α'
(p(e)) = in(M, A) if αCh(e) = 

out(M, A);

λ' = ⟨Ev' , →' ⟩ with Ev' = (EvZ \ Old) ∪ New and →'
any successor

Z	Z	Z	Z	Z
relation compatible with →'	on New that guarantees that every e ∈
EvZ \ Old with αZ(e) = nonce(N ) precedes any p(e) with αCh(e) =
out(M, A) and N occurring in M , α' (e) = αZ(e) for e ∈ EvZ \ Old,
α' (s(e)) = spy(M ) if αCh(e) = in(M, B') and α' (p(e)) = send(M, A) if
Z	Z
αCh(e)= out(M, A), and π' (∅)= πZ(∅).
It is straightforward to check that µ' is a predatory intruder model of the protocol. Take now the global configuration ξ' ∈ Ξ' such that ξ'|A = ξ|A for every A ∈ Hon, ξ'|Ch \ New = ξ|Ch \ Old and ξ'|Z \ New = ξ|Z \ Old, plus ξ' ∩ New = {p(e) | e ∈ ξ ∩ Pred}∪ {s(e) | e ∈ ξ ∩ Succ}. We now show that:
µ, ξ H @A[ϕ] iff µ', ξ' H @A[ϕ], for every A ∈ Hon and every ϕ ∈ LA that does not include communication subformulas; and
µ, ξ H @Z[P◦ send(M, A)] if µ', ξ' H @Z[P◦ send(M, A)], for every A ∈
Hon and message M .
Property (i) follows from the fact that µ' = µA for every A ∈ Hon. Property
results from the fact that the only send actions of the predatory Z are on
p(e) events. Therefore, it must be the case that e ∈ ξ ∩ Pred is an out event preceded by a corresponding in event e' ∈ ξ. Clearly, e' is an origination event for the message and so, by definition of Pred, e' ∈ Old. Therefore e' ∈ EvZ and αZ(e') is the send action we were looking for. Using the two, we can show that if γ is an authentication property then the attack also appears at ξ' in µ'. If we also prove:
if µ, ξ H @Z[knows(M )] then µ', ξ' H @Z[knows(M )],
then an attack can be shown to appear at ξ' in µ' also in the case that γ is a secrecy goal. Property (iii) follows from the facts that the initial knowledge of the predatory intruder is exactly the same, he does exactly the same nonce actions, and he spies every message at least as early as the original intruder
received or spied it.	 

Fig. 6 provides a visual example of the transformation. The old events are represented by ◦ in the first model, whereas the new events are represented by ⬦ in the second model. Clearly both inA and inZ are successor events, but only outN is a predecessor event since outA is preceded by inA, coming from an honest principal. Note also that nonceN could be ordered in other ways,




Z ... 
 . . . 



Ch ... 
 . . . 



can be reduced to
... 


 . . . 

Z
Ch ... 

 . . . 



Fig. 6. The predatory intruder reduction.
but always before sendN .
The predatory intruder reduction is a first step towards formally justifying the linearization of distributed communication that underlies the inductive trace models of protocols (see [14] and also [2], for example). The remaining step, which we do not include here for brevity, involves abstracting away the communication channel by “replacing” it with the intruder: this amounts to identifying the two lines Z and Ch in the bottom half of Fig. 6. A nice side- effect of the predatory intruder reduction is that the sending actions of the intruder can really be bound by the possible shapes of messages that honest principals can receive in protocol roles, as is commonly assumed.
Corollary 5.5 The restricted class of one-intruder models where the intruder only ever sends messages according to the protocol description is fully repre- sentative.

Discussion
Communication and distribution are the essential ingredients of protocols. These are the main concepts underlying our logic. Through the choice of different signatures and axioms, we can define theories for formalizing and reasoning about different application domains, as shown here in the case of security protocol models and their properties. It is worth noting in this regard that many of the problems with security protocols arise out of problems with communication, as opposed to problems with the underlying cryptographic algorithms (which are abstracted away with the black-box, perfect cryptogra- phy approach). While some of the results presented here, mutatis mutandis, have already been shown using other formalisms, our logic provides a means


for proving them in a general and uniform way, which provides a basis for further general investigations.
Event structures, which are the underlying models of our logic, are compa- rable with strand spaces, as explained in [8]. A comparison to other formalisms for reasoning about communicating processes can be found in [9]. It is worth emphasizing some of the advantages of our approach. To begin with, our approach provides not just a language for describing models (as in process algebras, for example) but also a logic for reasoning about them. Reasoning about local temporal properties of agents in a distributed system could also be performed in a linear temporal logic over linearizations of the distributed models. However, this would come at the price of readability and simplicity, as the locality dimension is lost. In contrast, our distributed logic is simple and robust in the sense that formulas are invariant with respect to different linearizations. We have taken advantage of this in the proofs of both the one-intruder and the predatory intruder reductions.
We have begun applying our logic to other metatheoretical investigations, such as developing appropriate partial-order techniques that may reduce the (potentially infinite) state-space exploration involved in model-checking pro- tocol properties (cf. [2]). This is work in progress and the first results are promising. Further work is the application of our logic for reasoning about protocol composition, as well as the development of a calculus for the logic.

References
A. Armando and L. Compagna. Abstraction-driven SAT-based Analysis of Security Protocols. In Proc. SAT 2003, LNCS 2919. Springer-Verlag, 2003. Available at http://www.avispa-project.org .
D. Basin, S. M¨odersheim, and L. Vigan`o. An On-The-Fly Model-Checker for Security Protocol Analysis. In Proc. ESORICS’03, LNCS 2808. Springer-Verlag, 2003. Available at http://www.avispa-project.org .
C. Caleiro, L. Vigan`o, and D. Basin. Distributed Temporal Logic for Security Protocol Analysis. In preparation, 2004.
C. Caleiro, L. Vigan`o, and D. Basin. Towards a Metalogic for Security Protocol Analysis (extended abstract). In Proc. Comblog’04, 2004.
Y.	Chevalier	and	L.	Vigneron.	Automated Unbounded Verification of Security Protocols. In Proc. CAV’02, LNCS 2404. Springer-Verlag, 2002. Available at http://www.avispa-project.org.
H. Comon-Lundh and V. Cortier. Security properties: two agents are sufficient. In Proc. ESOP’2003, LNCS 2618. Springer-Verlag, 2003.
V. Cortier, J. Millen, and H. Rueß. Proving secrecy is easy enough. In Proc. CSFW’01. IEEE Computer Society, 2001.
F. Crazzolara and G. Winskel. Events in security protocols. In Proc. of CCS’01. ACM Press, 2001.


H.-D. Ehrich and C. Caleiro. Specifying communication in distributed information systems.
Acta Informatica, 36:591–616, 2000.
G. Lowe. Breaking and Fixing the Needham-Shroeder Public-Key Protocol Using FDR. In
Proc. TACAS’96, LNCS 1055. Springer-Verlag, 1996.
G. Lowe. A hierarchy of authentication specifications. In Proc. CSFW’97. IEEE Computer Society Press, 1997.
J. Millen and H. Rueß. Protocol-independent secrecy. In Proc. 2000 IEEE Symposium on Security and Privacy. IEEE Computer Society, 2000.
J. Millen and V. Shmatikov. Constraint solving for bounded-process cryptographic protocol analysis. In Proc. CCS’01. ACM Press, 2001.
L. Paulson. The inductive approach to verifying cryptographic protocols. Journal of Computer Security, 6:85–128, 1998.
P. Ryan, S. Schneider, M. Goldsmith, G. Lowe, and B. Roscoe. Modelling and Analysis of Security Protocols. Addison Wesley, 2000.
D. Song, S. Berezin, and A. Perrig. Athena: a novel approach to efficient automatic security protocol analysis. Journal of Computer Security, 9:47–74, 2001.
F. J. Thayer F´abrega, J. C. Herzog, and J. D. Guttman. Honest ideals on strand spaces. In
Proc. CSFW’98. IEEE Computer Society, 1998.
F. J. Thayer F´abrega, J. C. Herzog, and J. D. Guttman. Strand spaces: Proving security protocols correct. Journal of Computer Security, 7:191–230, 1999.
G. Winskel. Event structures. In Petri Nets: Applications and Relationships to Other Models of Concurrency, LNCS 255. Springer-Verlag, 1987.
