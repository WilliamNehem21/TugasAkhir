Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 298 (2013) 309–324
www.elsevier.com/locate/entcs
Monads for Behaviour
Maciej Pir´og1 Jeremy Gibbons2
Department of Computer Science University of Oxford

Abstract
The monads used to model effectful computations traditionally concentrate on the ‘destination’—the final results of the program. However, sometimes we are also interested in the ‘journey’—the intermediate course of a computation—especially when reasoning about non-terminating interactive systems. In this article we claim that a necessary property of a monad for it to be able to describe the behaviour of a program is complete iterativity. We show how an ordinary monad can be modified to disclose more about its internal computational behaviour, by applying an associated transformer to a completely iterative monad. To illustrate this, we introduce two new constructions: a coinductive cousin of Cenciarelli and Moggi’s generalised resumption transformer, and States—a State-like monad that accumulates the intermediate states.
Keywords: completely iterative monads, effects, tracing, resumptions


Introduction
In this article we are concerned with semantics of programs like the following Haskell fragment:
echo :: IO ()
echo = do { x <- getChar ; putChar x ; echo }
More precisely, we are interested in programs that (1) have side-effects, and (2) depend on a (not necessarily terminating) recursion—or a corecursion, if you will. In the example, echo performs observable actions and then calls itself, ‘unfolding’ an infinite series of events.
Since Moggi’s work [24], monads have become the standard model for computa- tional effects. For example, a popular choice to model I/O operations is to employ the State monad A ×→(A × S)S, model the outside world as an object S, and see the program semantics as a function transforming an initial state into a final

1 maciej.pirog@cs.ox.ac.uk
2 jeremy.gibbons@cs.ox.ac.uk

1571-0661 © 2013 Elsevier B.V. Open access under CC BY-NC-ND license.
http://dx.doi.org/10.1016/j.entcs.2013.09.019

state [7,18]. Alternatively, we could consider side-effects as communication with the environment, so no assumption about semantics of effects needs to be made at this point: the program semantics is a free structure generated by the ‘effect- ful’ constructs (getChar and putChar), which is then interpreted by an external handler [16,29,32].
The situation becomes much more complicated in the context of (2). While a pure corecursive function is often denoted by the unique homomorphism to the final coalgebra that represents the type of the unfolded codata, a monad that models the effects in question need not be the carrier of a final coalgebra. Instead, we turn our attention to monads that come equipped with their own corecursive structure— completely iterative monads (‘cims’), introduced by Elgot [12] and recently studied by Aczel et al. [1,22]. A monad M is a cim if for certain morphisms e : X → M (A + X) there exists a unique morphism e† : X → MA that is coherent with the monadic structure of M (for the full definition, see Section 2). This rather axiomatic approach makes it possible to separate the corecursion guarded by invocation of effects from any recursive structure enjoyed by the base category, like order or metric enrichment. As an example, in Section 4.1 we give a categorical interpretation of generalised While programs that do not need to terminate.
A known example of a cim is the free cim Σ∞ generated by an endofunctor Σ. It is given by Σ∞A = νX.A + ΣX. However, the mentioned State and free monads are not in general completely iterative. For example, the State monad does not build the final state incrementally, so in case of non-terminating programs, such as echo, it is useless. The free structure, on the other hand, sometimes needs to be infinite, so in general the free monad Σ∗ (for an endofunctor Σ representing the signature) is ‘too small’. Nevertheless, we should not discard the ‘usual’ monads too hastily. For example, if we program a divergent computation in the State monad, the intermediate states are physically ‘put’ and ‘gotten’ somewhere in the memory of the computer, so the internal behaviour of the computation is, in a sense, accurate. The point is to reify it as a mathematical model. An interesting fact is that the IO monad in the Haskell Glasgow Compiler (GHC) is implemented using the State monad [20], so whatever its mathematical model, the two presumably have to be related.
Our idea is to use transformers associated with the ‘usual’ monads to trace computations. For a cim T and an adjunction F E U that gives rise to a monad M (that is, UF = M ), we use the monad UTF to trace computations in M . Clearly, UTF supports M -computations (via the canonical monad morphism M → UTF ), but it can also store some observations about the course of the computation in the inner cim. The choice of the monad T and the adjunction reveals different aspects of computations in M . As our main technical result, we prove that UTF is completely iterative.
As an example, we use the currying adjunction to derive what we call the States monad, which behaves like State, but also gathers the intermediate states in a stream. This way, the result of the computation is not a single, final state, but rather a possibly infinite trace consisting of intermediate states.

We then introduce the Coinductive Generalised Resumption transformer M (ΣM )∞, which is a coalgebraic cousin of Cenciarelli and Moggi’s Generalised Resumption transformer M (ΣM )∗ [9]. It allows one to decompose a monadic com- putation into a possibly infinite number of steps interleaved with free structure. It is also a categorical model for datatypes built around resumptions, such as Haskell iteratees [21] (for ΣA = A1+I ) or pipes [15] (for ΣA = AI + A×O), used to perform resource-aware lazy I/O. The fact that we use the free cim is crucial, since program- ming patterns for iteratees and pipes rely heavily on coalgebraic computations.

Completely iterative monads
Initial assumptions and notations
For the entire article, we assume that we are working in a base category B with binary coproducts and all the necessary final coalgebras. We denote the coproduct injections by inl and inr. We use a subscript for the composition of a natural transformation with a functor; for example, for functors H and J , if ξ : F → G is natural, then ξH : FH → GH. If ξ is natural in two variables, by ξH,J we mean a natural transformation ζ with components ζA = ξHA,JA.
We also recall the standard interpretation of coinductive datatypes as final coal- gebras. For an endofunctor F , an F -coalgebra is a pair ⟨A, f : A → F A⟩. We call A the carrier of the coalgebra. A morphism h : A → B is an F -coalgebra homo- morphism, denoted as h : ⟨A, f⟩→ ⟨B, g⟩, if g · h = Fh · f . An F -coalgebra ⟨νF, β⟩ is ﬁnal if for every F -coalgebra ⟨A, f⟩ there exists precisely one homomorphism
⟨A, f⟩→ ⟨νF, β⟩, called an anamorphism and denoted as [(f )].

Cims deﬁned
An anamorphism allows to unfold a (possibly infinite) data structure, while its uniqueness amounts to the principle of coinduction. A corecursive monadic compu- tation can also be described by a coalgebra e : X → M (A + X), called an equation morphism. The object X represents (a set of) variables—the seeds of the core- cursion. The object A represents (a set of) parameters, which are final values of the computation. However, the described computation is not intended to be un- folded in the final M (A + -)-coalgebra. Instead, the results of subsequent steps are combined using the monad multiplication. Of course, such (possibly infinite) multiplications need not exist for a monad. Their existence (and uniqueness) is the defining property of completely iterative monads.
We note that not every equation morphism describes a meaningful computa- tion. For example, a morphism that incessantly returns the seed with the unit of the monad is intuitively a pure divergent computation, which does not have an interpretation in the category Set. Thus, we assume the view that some com- putations generate observable behaviour of the program, while others are ‘silent’. We restrict equation morphisms to those that always generate observable actions. We call such morphisms guarded. It guarantees that each step of the computation

contributes a new bit of observable behaviour. Hence, following the type theoretic nomenclature [10], we call such a computation productive.
To formalise this, we need the notion of ideals of a monad. Analogously to ideals in a ring or a semigroup (subsets closed under the operations), they mark a subset of effects encompassed by the monad, for example the subset of observable actions. Informally, once an action from an ideal is performed, it cannot be undone. More precisely, a computation in the ideal composed with any other operation is again in the ideal. An example is non-failing and non-idempotent nondeterminism; it can be idealised with nondeterministic computations with at least n possible results: once n choices are made, there will be at least n (possibly duplicate) final answers, no matter what is the rest of the computation (assuming termination). We can formalise it as follows. (All the definitions in this section are as given by Ad´amek, Milius, and Velebil [2].)

Definition 2.1 Let ⟨M, η, μ⟩ be a monad. For an endofunctor M, a natural trans- formation σ : M → M with monomorphic components is called a subfunctor of M. We call σ an ideal of M if there exists a natural transformation μ : MM → M such that the following diagram commutes.
σM
MM	M 2
μ
σ

M	M
We call a pair of a monad and its ideal an idealised monad. An idealised monad
M is called an ideal monad if M = Id + M with η = inlId,M and σ = inrId,M .
Examples of ideal monads include: free monads, exceptions, interactive output, and nonempty lists. Note that in a category with an initial object 0, every monad M is idealised with respect to the trivial ideal FX = 0, that is a constant functor that always returns the initial object.
We also need morphisms that respect the internal structure of idealised mon- ads. If Σ is an endofunctor, then a natural transformation ξ :Σ → M is ideal if its codomain contains only observable computations. Intuitively, this means that an in- terpretation of a symbol from the signature should never yield a silent computation. Formally:
Definition 2.2 Let ⟨M, σM ⟩ and ⟨N, σN ⟩ be idealised monads. A natural transfor- mation ξ :Σ → M is ideal if it factors through σM .
A monad is completely iterative with respect to an ideal, which contains the observable, corecursive effects of the monad. Thus, we restrict codomains of equa- tion morphisms to ideals. This makes the corecursion guarded by invocation of observable effects.
Definition 2.3 A morphism e : X → M (A + Y ) is guarded if it factors through the morphism [σA+Y , ηA+Y · inlA,Y ], that is there exists a morphism j such that the

following diagram commutes.
e
X


M (A + Y )


[σA+Y , ηA+Y · inlA,Y ]
M (A + Y )+ A

If X = Y , we call e a guarded equation morphism.
We use a guarded equation morphism e to unfold a computation e†, called a solution. Intuitively, a solution is an infinite iteration of parameter-preserving Kleisli-compositions of e. A monad is a cim if such a composition always exists and is unique. Formally:
Definition 2.4 Let e : X → M (A + X) be a morphism. We call a morphism
e† : X → MA a solution of e if the following diagram commutes.


X
e  M (A + X)
e†


M [ηA, e†]
MA
μA M 2A

An idealised monad M is completely iterative if every guarded equation morphism
has a unique solution.
The free cim
An example of a cim is a generalisation of the infinite term monad generated by an endofunctor (intuitively, a signature) Σ. Its functorial part is given by a family of final coalgebras Σ∞A = νX.A + ΣX. Below we define the unit η∞ and a natural transformation emb :Σ → Σ∞ that embeds Σ in Σ∞.


Id
 η∞ = inlId,ΣΣ∞ Id + ΣΣ∞ ∼= Σ∞
Σ
 emb = inrId,ΣΣ∞ · Ση∞
Id + ΣΣ∞ ∼= Σ∞


The multiplication μ∞ can be described with the following universal property: it is a unique morphism u : Σ∞Σ∞ → Σ∞ that satisfies the following equation.
u =	Σ∞Σ∞ ∼= Σ∞ + ΣΣ∞Σ∞ ∼= Id + ΣΣ∞ + ΣΣ∞Σ∞
 id + [id, Σu]
Id + ΣΣ∞ ∼= Σ∞

As discussed by Aczel et al. [1], Σ∞ is the free cim generated by Σ. Intuitively, this means that every interpretation of Σ in a cim M extends in a unique way to an interpretation of the entire (possibly infinite) term Σ∞ in M . Formally, for an ideal natural transformation ξ : Σ → M , there exists a unique monad morphism ι(ξ): Σ∞ → M such that the following diagram commutes.
emb
Σ	Σ∞
ι(ξ)
M

The monad morphism ι(ξ) is given by [ηM , ξ† ∞ ]. Diagrammatically:


ΣΣ∞
ξΣ∞
M Σ∞ ∼= M (Id + ΣΣ∞)
ΣΣ∞
ξ† ∞
M Id = M
Σ∞ ∼= Id + ΣΣ∞
ι(ξ)= [ηM , ξ† ∞ ]
M


Another example of a cim is the Exception monad A ×→A + E. Also, every monad is completely iterative with respect to the trivial ideal FX = 0. But, except for those and the free cim, there are hardly any examples of cims commonly used in programming or semantics. This paper aims to fill this void in a rather generic fashion.
Cims, adjunctions, and tracing
Let M be a monad, and let ⟨F, U, η, ε⟩ : B → C be a factorization of M as an adjunction, that is M = ⟨UF, η, U εF ⟩. Let ⟨T, ηT , μT , σT ⟩ be a cim with solutions -†. It is standard that UTF is a monad with ηUT F = UηT ·η and μUT F = UμT ·UTεTF ,
F	F

and that lift = UηT
: UF → UTF is a monad morphism. We prove that UTF

inherits complete iterativity from T .
Theorem 3.1 The natural transformation UσT

: UTF → UTF forms an ideal.

The monad UTF is completely iterative with respect to this ideal.
Proof. Right adjoints preserve monomorphisms, hence the components of the nat-

ural transformation UσT
are monic, and so it is a subfunctor. We define μ to be




UμT · UTεTF . It is easy to verify that it satisfies the condition for ideals.
Let e : X → UTF (A + X) be a UσT -guarded equation morphism. By [-♩ : C[FA, B] ∼= B[A, UB]: [-| we denote the natural isomorphism associated with the adjunction. Recall that left adjoints preserve coproducts, that is F (A + B) ∼= FA +

FB. One can calculate that [e| ∼= [σT
T
(FA+FX)
· inl(FA,FX)] · (εTF (A+X) +

idFA) · Fj, which means that [e| : FX → TF (A + X) ∼= T (FA + FX) is a guarded equation morphism in T with a unique solution [e|† : FX → TF A.

We define the solution of e as [[e|†♩. The following diagram commutes:
[[e|†♩ = U[e|† · ηX
X
ηX
U[e|†
e	UFX	UTFA

U[e|	T
FA 
T	†	μUT F

UTF (A + X)
UT [ηFA, [e| ]	A

∼= UT (FA + FX)	UT 2FA 
UTεTFA 
(UTF )2A
UTF [ηUT F ,U[e|† · ηX ]
The inner square is the U -image of the solution diagram for [e|†. The outer triangles commute due to properties of adjunctions and the definition of μUT F .
For uniqueness, let g : X → UTFA be a solution of e. Substitute [g| for [e|† in the above diagram. The outer square commutes, because [[g|♩ = g is a solution, and the triangles commute, because of properties of adjunctions, hence the inner square precomposed with ηX also commutes. For all morphisms f, fj : FB → C, if Uf · ηB = Ufj · ηB then f = fj. Therefore, [g| is a solution of [e|, so [g| = [e|†, hence g = [[g|♩ = [[e|†♩.	2
Intuitively, T collects observations about a computation in M . Thus, we need a new operation that allows us to actually observe the current state of the computa- tion, for example the current state in the State monad (this example is elaborated in the next section). It could be given as a natural transformation olift : M → UTF with components that factor through UσT . It will not in general be a monad mor- phism; on the contrary, performing two actions and then observing the effect differs in general from observing the effect of each action individually. More formally, let f ◦ g be a computation in the Kleisli category of M , where ◦ is the Kleisli com- position. We can decorate it with observers in two different ways: olift · (f ◦ g) or (olift · f ) ◦ (olift · g). For example, when tracing a computation in State, we may want to observe only ‘put’ operations, as long as we are certain that there are only finitely many invocations of ‘get’ in between every two invocations of ‘put’. In the rest of the paper we always define olift as U obs for a natural transformation obs : F → TF . For convenience, we also define a ‘save the current state of computation’ operation save = olift · η : Id → UTF .
Though we do not use this property directly in the rest of the article, observa- tions should not modify the computation. This could be captured by the following cancellation property: for all morphisms f, fj : A → MB and g, gj : B → MC, if (lift · g) ◦ saveB ◦ (lift · f )= (lift · gj) ◦ saveB ◦ (lift · fj) then g ◦ f = gj ◦ fj.

The States monad
Our first example is a monad we call States. If the base category B is cartesian closed, the State monad arises from the currying adjunction −×S E −S. We choose

(−× S)∞
, for which we write
−→
S , to be the inner cim, and the result is the monad

−→	S	−→
A ×→( S (A × S)) . Intuitively, S is a possibly infinite stream of states of type
S. The ‘base’ of the exponential is the trace of the computation: a stream that, if finite, is terminated with an answer A and a current state S. The latter is used only to compose two computations and is not stored in the stream.
We define ‘put’ and ‘get’ operations as standard liftings of ‘put’ and ‘get’ for State. The natural transformation obs duplicates the current state and puts it in the stream as follows, where outlA,B : A × B → A and outrA,B : A × B → B are the left and right projections respectively.


A × S
⟨⟨outl, outr⟩, outr⟩
(A × S) × S
embA×S
−→
S (A × S)


For example, consider the following computation in States on Set for S = N
(using Haskell syntax):
let f = do {put 2; save; put 3; save; put 5} g = do {x <- get; put (x+1); save; g}
in do {f; g}
For any initial state, f evaluates to the trace (2, 3, ⟨ , 5⟩), while the whole compu- tation evaluates to (2, 3, 6, 7, 8, 9,.. .).
Example: Control structures for While

Consider a generalised While language, as given by Rutten [30]:
P, Q ::= A | P ; Q | if b then P else Q | while b do P
For a monad M , the symbol A represents a set of actions (denoted as a), that is morphisms of type1 → M 1. The symbol b represents elements of a set B of Boolean expressions, that is a set of morphisms of type 1 → M (1 + 1). We parametrise the semantics with a ‘guard’ operation γ : 1 → M 1, which allows the addition of behaviour on every choice point of a control structure. The denotation of a program P is given by [P ]]:1 → M 1, defined as follows, where ◦ is Kleisli composition.
[[a]] = a
[[P ; Q]]= [[Q]] ◦ [[P ]]
[[if b then P else Q]]= [ [P ]], [[Q]]] ◦ b ◦ γ
[[while b do P ]]= ([M inr1,1 · [[P ]], M inl1,1 · ηM ] ◦ b ◦ γ)†

Actions denote themselves, and compositions of programs are just Kleisli compo- sitions of morphisms. The denotation of if statements first performs the guard γ, then b, and then the appropriate branch is chosen (we use the left component of 1 + 1 to represent ‘true’). The denotation of while first builds an equation mor- phism by composing the guard, the condition, and the choice between returning the left component of the coproduct (a constant, which means ‘stop the iteration’), or performing the body, and right-injecting the result (which makes it a ‘continue the iteration’ variable). The denotation of the entire while expression is a solution to that morphism. The solution might not exist, or might not be unique; hence, de- pending on the choice of M , A, B, and γ, the denotation might not be well-defined. This semantics specialises to a couple of known cases:

If we choose the regular State monad on
Dcppo
(the category of pointed

directed-complete partial orders and continuous functions) for M and its unit on 1 for γ, the solution diagram simplifies to the familiar equation for denotation of While [27, Chapter 4]. So, if we assume -† to be the least fixed point, we yield the standard denotational semantics.
If we instantiate M with a cim, we can ensure that unique solutions always exist by an appropriate γ-guarding of while loops. (Note that it is not sufficient to ask for the A actions to be guarded, since while true do while false do a diverges without invoking an action.) In case of the States monad, this means that every iteration stores its initial state in the stream, that is γ = save. Additionally, if we assume that ‘put’ operations are always guarded and ‘get’ are not, we obtain a semantics trace-equivalent to Nakata and Uustalu’s trace operational semantics [26].


Coinductive generalised resumptions
Let ⟨M, ηM , μM ⟩ be a monad, and Σ be an endofunctor on the base category B. In this section we give a monadic structure to M (ΣM )∞ and examine its basic properties. We proceed by first giving a monadic structure to the endofunctor

KA = νX.M (A + ΣX),

which is isomorphic to M (ΣM )∞ through the coalgebraic version of the rolling rule [5]:
Lemma 5.1 Let F, G be endofunctors. Then νFG ∼= FνGF.
For convenience, we define two auxiliary natural transformations. The first one, flatA,B : M (MA + B) → M (A + B), flattens a computation that may return a value or a new computation. The second one, unf : K2 → M (Id + ΣK2), unfolds and flattens two levels of structure of K. Note that the final coalgebra map αA : KA → M (A + ΣKA) is natural in A.





flatA,B =
M (MA + B)
 M (idMA + ηM ) M (MA + MB)
M [M inlA,B,M inrA,B]
unf =
K2
 αK M (K + ΣK2)
M (α + idΣK2 )

M 2(A + B)
M A+B
M (A + B)
M (M (Id + ΣK)+ ΣK2)
 flatId+ΣK,ΣK2
M (Id + ΣK + ΣK2)



The unit ηK of the monad K is given below. The multiplication is defined as the anamorphism μK = [(mA)] for the following natural transformation m.



ηK =
Id
inlId,ΣK
m =	K2
unf

Id + ΣK
M
Id+ΣK
M (Id + ΣK) ∼= K
M (Id + ΣK + ΣK2)
 M (id + [ΣηK, idΣK2 ])
M (Id + ΣK2)



Theorem 5.2 The following hold:
The tuple ⟨K, ηK, μK⟩ is a monad,
There exists a monad distributive law λ : (ΣM )∞M → M (ΣM )∞ given by
λ = μK · M (ΣM )∞Mη∞ · ηM	∞  ,
(ΣM ) M
There exist two monad morphisms liftl : M → M (ΣM )∞ and liftr : Σ∞ →
M (ΣM )∞.


Proof. The statement (i) can be proved by the structural coinduction provided by the finality of K. For example, to prove the associativity of the monad multipli- cation, one can define a natural transformation w : K3 → M (Id + ΣK3) in a way
similar to the transformation m, and calculate that m · μK = M (id + ΣμK) · w
and m · KμK  = M (id + ΣKμK) · w, which means that both μK and KμK
are coalgebra homomorphisms μK, KμK : ⟨K3, w⟩ → ⟨K2, m⟩. By uniqueness,
μK · μK = [(m)] · μK = [(w)] = [(m)] · KμK = μK · KμK. Diagrammatically:
K	K



⟨K3, w⟩


⟨K2, m⟩
[(w)]
⟨K2, m⟩


	
⟨K, α⟩

The distributive law λ can be obtained from Barr and Wells’ notion of compati- bility of monads [6, Chapter 9], which in this case amounts to the following equalities (note that Barr and Wells’ book give five conditions for compatibility, but the last two are redundant, and follow from the first three; see [11] for discussion):
ηK = ηM	∞ · η∞ = Mη∞ · ηM
(ΣM )
Mμ∞ = μK · M (ΣM )∞ηM	∞

μM
∞ = μK · Mη∞
(ΣM )
∞

(ΣM )	M (ΣM )
They can also be proved by the coinduction. The distributive law induces two canonical monad morphisms M → K and (ΣM )∞ → K. We compose the latter with a monad morphism Σ∞ → (ΣM )∞ given by ι(emb · ΣηM ).	2

Alternatively, the definition of μK can be given with the following universal property:
Lemma 5.3 for any natural transformation u : K2 → K, we deﬁne the transfor- mation u˜ to be the following composition.

K2
 unf
M (Id + ΣK + ΣK2)
 M (id + [idΣK, Σu])
M (Id + ΣK)
 α−1 K
Then, u = u˜ if and only if u = μK.
Despite the existence of the cospan M → M (ΣM )∞ → Σ∞, the monad M (ΣM )∞ is in general not a coproduct of M and Σ∞ as monads. To see that, it is sufficient to assume that the base category is Set, M is ideal, and to recall the construction of coproducts of ideal monads by Ghani and Uustalu [14]. In such a setting the coproduct allows only a finite number of interleavings between M and Σ∞, so it is distinct from K.

Complete iterativity of K
Consider the category M -Fema of free Eilenberg-Moore M -algebras, that is, alge- bras where the carrier is of the shape M A, and the action is defined as μM . We identify an algebra ⟨MA, μM ⟩ with M A, which makes M -Fema a subcategory of B. It is equivalent to the Kleisli category for M . There is a standard free-underlying adjunction F E U : B → M -Fema.
As discussed by Mulry [25], liftings of an endofunctor T on B to M -Fema are in one-to-one correspondence with distributive laws TM → MT . Moreover, a simple calculation shows that if T has a monadic structure and the distributive law respects this structure, the corresponding lifting (T ⟩ is also a monad. The monad MT induced by the distributive law is equal to the monad U (T ⟩F .
Now, consider the monad (ΣM )∞. The monad distributive law λ from The- orem 5.2 gives rise to a lifting ((ΣM )∞⟩, defined on objects as ((ΣM )∞⟩MA = M (ΣM )∞A ∼= KA. The following theorem states that the lifting is also a free cim (note that M Σ is an endofunctor also over M -Fema):
Theorem 5.4 The monad ((ΣM )∞⟩ is the free cim generated by M Σ in M-Fema. Therefore, it is completely iterative.
Proof. For a homomorphism f : MX → M (A + ΣMX) in M -Fema, consider the following diagram in the base category. It commutes, because KA is the carrier of the final M (A + Σ−)-coalgebra.

αA
KA	M (A + ΣKA)


[(f )]
f
MX 
M (idA + Σ[(f )])
M (A + ΣMX)

It is easy to check that αA, α−1 and M (A+Σ[(f )]) are also homomorphisms (modulo the isomorphism KA ∼= M ((ΣM )∞)A), and [(f )] is a homomorphism as a compo- sition of homomorphisms via the computation law: [(f )] = α−1 · M (A + Σ[(f )]) · f . This means that this diagram commutes also in M -Fema. One can define co- products in M -Fema as MA ⊕ MB = M (A + B). Expanding the definitions we obtain that the following diagram commutes in M -Fema, where α∞ : (ΣM )∞A → A + ΣM (ΣM )∞A is the action of the final (A + ΣM−)-coalgebra (the morphism Mα∞ is isomorphic to α via the rolling rule). Moreover, [(f )] is unique with this property, since M -Fema is a subcategory of B.


((ΣM )∞⟩MA 
Mα∞
M (A + Σ((ΣM )∞
⟩M A)


[(f )]
f
MX 
= MA ⊕ M Σ((ΣM )∞⟩MA 
 M (idA + Σ[(f )])= idMA ⊕ M Σ[(f )] M (A + ΣMX)= MA ⊕ M ΣMX 

Note that in M -Fema, M (A+Σ−)= MA⊕M Σ− is a functor, hence ((ΣM )∞⟩MA is the carrier of the final (MA⊕M Σ−)-coalgebra, and so, according to [22, Corollary 6.3], ((ΣM )∞⟩ is the functorial part of the free cim in M -Fema generated by M Σ. It is left to see that the monadic structures given by the lifting and given by the free cim coincide. Here, we show it for multiplications. In case of ((ΣM )∞⟩ the multiplication is given by Mμ∞. For an object M A, we unfold the universal
property of μ∞ (Section 2.3):

((ΣM )∞⟩((ΣM )∞⟩MA = M (ΣM )∞(ΣM )∞A
 M (α∞ + id) · Mα∞ = (Mα∞ ⊕ M id) · Mα∞ M (A + ΣM (ΣM )∞A + ΣM (ΣM )∞(ΣM )∞A)
 M (id + [id, ΣMμ∞]) = M id ⊕ M [id, ΣMμ∞]
M (A + ΣM (ΣM )∞A)
 M (α∞)−1 M (ΣM )∞A = ((ΣM )∞⟩MA 
One can show that M [id, ΣMμ∞], where [-, -] is the coproduct mediator in B, is equal to [[idM ,M ΣMμ∞]], where [[-, -]] is the coproduct mediator in M -Fema. Instantiating it in the above composition and some basic properties of functors give us that Mμ∞ = (Mα∞)−1 · (id ⊕ [[id,M ΣMμ∞]]) · (Mα∞ ⊕ id) · Mα∞, which means that Mμ∞ satisfies the universal property of the multiplication of the free cim in M -Fema generated by M Σ.	2
The above characterisation and Theorem 3.1 yield that K ∼= U ((ΣM )∞⟩F is completely iterative. The guardedness condition specialises as:
X	e	K(A + X)

−1
A+X
· M inrA+X,ΣK(A+X), ηK
· inlA,X ]

M ΣK(A + X)+ A
Example: Bisimulation
Let Σ = Id, so that K ∼= MM∞. Similarly to Cenciarelli and Moggi’s transformer MM∗ [9], a K-computation can be seen as an M -computation split into a series of suspended steps. However, in case of MM∞, the structure can be infinite, so it can also store a divergent computation. We can see the result of each step as a rather robust observation about the current state of the computation. So, even if the computation does not have a final value, we can still reason about the course of

the computation.
We define the natural transformation obs : M → MM∞ as:


MηM
M
M emb
MM

MM∞

It builds an empty level, so that a composition with another value will not affect the current structure. Intuitively, the outer M is the current state of the computation, while M∞ is a kind of continuation. To acquire the second state, we can contract the top two steps of execution using a natural transformation force defined as follows, where flatj is equal to flat, but with the monadic argument as the second component of the coproduct rather than the first.
MM∞ ∼= M (Id + MM∞)
j
Id,M∞
M (Id + M∞) ∼= M (Id + Id + MM∞)
 M ([id, id]+ idMM∞ )
M (Id + MM∞) ∼= MM∞

On Set, we can define a simple notion of bisimulation between programs as a predicate ≈ ⊆ (MM∞A)2, such that for p, q ∈ MM∞A, it is the case that p ≈ q precisely if M (idA+!M∞A)(p) = M (idA+!M∞A)(q) and force(p) ≈ force(q), where !A : A → 1 is the unique morphism to the final object. In other words, we compare the functorial structure of the outer M (the observable result of the first step), and continue the process after performing the next step with the force natural transformation. This means that two programs are bisimilar if for every n ∈ N, the respective prefixes of performing the first n steps are equal.
Related and future work
Cims arise from completely iterative algebras. Both concepts have been exten- sively studied by Elgot [12] and by Aczel et al. [1,22]. Milius and Moss [23] con- sider recursive program schemes in terms of solutions in Elgot algebras [3] (that is, Eilenberg-Moore algebras for free cims).
Cenciarelli and Moggi [9] introduced the Generalised Resumption transformer M (ΣM )∗, which decomposes a monadic computation into a series of steps (layers of free structure). Hyland, Plotkin, and Power [19] proved it to be the coproduct M + Σ∗ in the category of monads. The monad M (ΣM )∞ captures also poten- tially infinite computations. In some categories—and so programming languages like Haskell—the limit-colimit coincidence [31] identifies M (ΣM )∗ and M (ΣM )∞, but the explicit use of the free cim is significant in Set and in type theories with guarded (co)recursion. Interleaving data and monadic actions is a powerful ab- straction studied recently also by Filinski and Støvring [13], Atkey et al. [4], and the present authors [28].

Since the free cim is a final coalgebra [22], we can see (M Σ)∞ in M -Fema from Theorem 5.4 as an example of Hasuo, Jacobs, and Sokolova’s generic trace seman- tics [17], which models state-based systems as F -coalgebras in a Kleisli category (or, equivalently, a Fema). The coalgebra represents transitions (for example, with ΣA = A × O for labelled transitions), and the monad represents the underlying effect (like the Powerset monad for nondeterminism or the Probability Distribution monad for probabilistic systems).
In this paper we concentrate on the monads and tracing, and we only sketch po- tential applications in defining semantics and reasoning about programs. The nat- ural next step is to formalise a language like Moggi’s computational λ-calculus [24] with recursion provided by a background cim. It is also an interesting question whether the presented theory could be used to develop a practical framework for reasoning about effectful programs in type theories, like those implemented by the Coq or Agda proof systems. So far, Capretta [8] represented general recursion by the free cim generated by the identity functor; we conjecture fruitful applications of other cims too.
Acknowledgment
This work was supported by the UK EPSRC project Reusability and Dependent Types (EP/G034516/1). We would like to thank Ralf Hinze, Marek Materzok, Nicolas Wu, and the anonymous reviewers for their comments.

References
Peter Aczel, Jir´ı Ada´mek, Stefan Milius, and Jiri Velebil. Infinite trees and completely iterative theories: a coalgebraic view. Theoretical Computer Science, 300(1-3):1–45, 2003.
Jir´ı Ada´mek, Stefan Milius, and Jiri Velebil. On rational monads and free iterative theories. Electronic Notes in Theoretical Computer Science, 69:23–46, 2002.
Jir´ı Ada´mek, Stefan Milius, and Jiri Velebil. Elgot algebras. Logical Methods in Computer Science, 2(5), 2006.
Robert Atkey, Neil Ghani, Bart Jacobs, and Patricia Johann. Fibrational induction meets effects. In Lars Birkedal, editor, Foundations of Software Science and Computational Structures—15th International Conference, FoSSaCS 2012, volume 7213 of Lecture Notes in Computer Science, pages 42–57. Springer, 2012.
Roland Carl Backhouse, Marcel Bijsterveld, Rik van Geldrop, and Jaap van der Woude. Categorical fixed point calculus. In David H. Pitt, David E. Rydeheard, and Peter Johnstone, editors, Category Theory and Computer Science, volume 953 of Lecture Notes in Computer Science, pages 159–179. Springer, 1995.
Michael Barr and Charles F. Wells. Toposes, Triples, and Theories. Grundlehren der mathematischen Wissenschaften. Springer-Verlag, 1985.
Andrew Butterfield. Reasoning about I/O in functional programs. In Proceedings of the 4th Central European Functional Programming School, CEFP’11, pages 93–141, Berlin, Heidelberg, 2012. Springer- Verlag.
Venanzio Capretta. General recursion via coinductive types. Logical Methods in Computer Science, 1(2), 2005.
Pietro Cenciarelli and Eugenio Moggi. A syntactic approach to modularity in denotational semantics. In Proceedings of the 5th Biennial Meeting on Category Theory and Computer Science, CTCS 93, CWI Technical Report, Amsterdam, The Netherlands, 1993.

Thierry Coquand. Infinite objects in type theory. In Henk Barendregt and Tobias Nipkow, editors,
TYPES, volume 806 of Lecture Notes in Computer Science, pages 62–78. Springer, 1993.
Jeremy E. Dawson. Categories and monads in HOL-Omega. In preparation, http://users.cecs.anu. edu.au/~jeremy/pubs/holw-cm/root.pdf.
Calvin C. Elgot. Monadic computation and iterative algebraic theories. In Logic Colloquium ’73, Proc., Bristol 1973, 175-230, 1975.
Andrzej Filinski and Kristian Støvring. Inductive reasoning about effectful data types. In Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming, ICFP ’07, pages 97–110, New York, NY, USA, 2007. ACM.
Neil Ghani and Tarmo Uustalu. Coproducts of ideal monads. Theoretical Informatics and Applications, 38(4):321–342, 2004.
Gabriel Gonzalez. The pipes package, 2012. http://hackage.haskell.org/package/pipes.
Peter Hancock and Anton Setzer. Guarded induction and weakly final coalgebras in dependent type theory. In L. Crosilla and P. Schuster, editors, From Sets and Types to Topology and Analysis. Towards Practicable Foundations for Constructive Mathematics, pages 115 – 134, Oxford, 2005. Clarendon Press.
Ichiro Hasuo, Bart Jacobs, and Ana Sokolova. Generic trace semantics via coinduction. Logical Methods in Computer Science, 3(4), 2007.
Graham Hutton and Diana Fulger. Reasoning about effects: Seeing the wood through the trees. In Proceedings of the Symposium on Trends in Functional Programming, Nijmegen, The Netherlands, May 2008.
Martin Hyland, Gordon D. Plotkin, and John Power. Combining effects: Sum and tensor. Theoretical Computer Science, 357(1-3):70–99, 2006.
Simon L. Peyton Jones and Philip Wadler. Imperative functional programming. In Mary S. Van Deusen and Bernard Lang, editors, Symposium on Principles of Programming Languages, Charleston, South Carolina, USA, pages 71–84. ACM Press, 1993.
Oleg Kiselyov. Iteratees. In Tom Schrijvers and Peter Thiemann, editors, FLOPS, volume 7294 of
Lecture Notes in Computer Science, pages 166–181. Springer, 2012.
Stefan Milius. Completely iterative algebras and completely iterative monads. Information and Computation, 196:1–41, 2005.
Stefan Milius and Lawrence S. Moss. The category-theoretic solution of recursive program schemes.
Theoretical Computer Science, 366(1-2):3–59, 2006.
Eugenio Moggi. Notions of computation and monads. Information and Computation, 93(1):55–92, 1991.
Philip S. Mulry. Lifting theorems for Kleisli categories. In Stephen D. Brookes, Michael G. Main, Austin Melton, Michael W. Mislove, and David A. Schmidt, editors, Mathematical Foundations of Programming Semantics, 9th International Conference, New Orleans, LA, USA, volume 802 of Lecture Notes in Computer Science, pages 304–319. Springer, 1993.
Keiko Nakata and Tarmo Uustalu. Trace-based coinductive operational semantics for While. In Stefan Berghofer, Tobias Nipkow, Christian Urban, and Makarius Wenzel, editors, TPHOLs, volume 5674 of Lecture Notes in Computer Science, pages 375–390. Springer, 2009.
Hanne Riis Nielson and Flemming Nielson. Semantics with applications: a formal introduction. John Wiley & Sons, Inc., New York, NY, USA, 1992.
Maciej Pirog and Jeremy Gibbons. Tracing monadic computations and representing effects. In James Chapman and Paul Blain Levy, editors, Proceedings Fourth Workshop on Mathematically Structured Functional Programming, Tallinn, Estonia, 25 March 2012, volume 76 of Electronic Proceedings in Theoretical Computer Science, pages 90–111. Open Publishing Association, 2012.
Gordon D. Plotkin. Adequacy for infinitary algebraic effects (abstract). In 3rd Conference on Algebra and Coalgebra in Computer Science, CALCO 2009, Udine, Italy, pages 1–2, 2009.
Jan J. M. M. Rutten. A note on coinduction and weak bisimilarity for While programs. Theoretical Informatics and Applications, 33(4/5):393–400, 1999.
Michael B. Smyth and Gordon D. Plotkin. The category-theoretic solution of recursive domain equations. SIAM Journal on Computing, 11(4):761–783, 1982.
Wouter Swierstra and Thorsten Altenkirch. Beauty in the beast: A functional semantics of the awkward squad. In Haskell ’07: Proceedings of the ACM SIGPLAN Workshop on Haskell, pages 25–36, 2007.
