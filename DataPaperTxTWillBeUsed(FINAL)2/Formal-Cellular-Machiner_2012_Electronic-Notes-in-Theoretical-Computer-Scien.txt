Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 284 (2012) 55–74
www.elsevier.com/locate/entcs
Formal Cellular Machinery
Troels C. Damgaard
Edlund A/S, Denmark
Espen Højsgaard
IT University Copenhagen, PLS group, Denmark
Jean Krivine1
Univ Paris Diderot, Sorbonne Paris Cit´e, Laboratoire PPS, UMR 7126, F-75205 Paris, France

Abstract
Various calculi have been proposed to model different levels of abstraction of cell signaling and molecular interactions. In this paper we propose a framework inspired by some of these calculi that structures inter- actions and agents from the most basic elements of the cell (protein interaction sites) to higher order ones (compartments and molecular species).
Keywords: systems biology, compartment, rule-based modeling, kappa, bigraphs, projectivity, membrane, term rewriting


Introduction
It has been about 10 years now since part of the theoretical computer science com- munity got interested in applying formal methods to systems biology. Since then it seems that the quest for a calculus having proteins, compartments or channels as first class citizens has not reached an end. Among the large variety of lan- guages that have been proposed to tackle various aspects of systems biology (see Refs. [22,5,21,10,12,3,1,18,20,17,19,15,2,4,14] for a non exhaustive list), several ideas seem of particular importance to us: (i) the cellular medium can be described as a graph where nodes represent molecules and edges represent physical contacts be- tween these molecules [10,12,1,14], (ii) languages with a natural notion of location

1 corresponding author: jean.krivine@pps.jussieu.fr

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.05.015

of reaction can be used to represent cellular compartments [21,19,20,15,2], (iii) in- teractions between compartments and proteins or vesicle transformations can be described using local patches of membranes, without committing to any particular global curvature [11,4], and (iv) although laws governing interactions of molecular components are numerous, they can be engendered by a small set of generators [3]. The present work proposes to integrate points (i) to (iv) in a single formalism.
More specifically we define a language for proteins and cells in an incremental way, making explicit the trade-off between expressiveness and complexity. We decompose the construction of the language in four steps:
C0: an “untyped” calculus aimed at modeling protein-protein interactions. The dynamics of these interactions is presented as a small set of generator rules, which modelers can refine and compose but not change.
C1: an intermediate version of the term language that allows modelers to type reactions introduced at the previous stage.
C2: the main expressiveness increment of our language. It introduces compart- ments and the notion of projectivity of membrane reactions, i.e. the possibility to mention patches of membrane, without having to deal with their global curvature. We propose a matching algorithm, that is proven both sound and complete. At this stage, generators allow modelers to create and destroy compartments in a projective fashion.
C3: the final step of the construction deals with the diffusion problem. In partic- ular we incorporate means to talk about connected components of reactants, which is a key feature for a new set of generators modeling diffusion of molecular species and intra-molecular complex formation. To the best of our knowledge C3 is the first calculus of its kind that allows one to model molecular agents both at a micro level (where interactions are purely local) and a macro level (where interactions involve connected components of agents).
The language we build is inspired by and closely related to the κ-calculus of Danos and Laneve [9,10] and Milner’s bigraphical reactive systems [16], however these connections will be left informal throughout the paper. The reader might refer to Appendix A and to Ref. [6] for some preliminary work on the subject.

C0: forming molecules
Proteins are long polymers built over an alphabet of 20 amino acids. Each protein’s interaction capabilities are mediated by its 3D folding in space which in turn depends on its amino acid composition. Protein interactions are either structural when they form non-covalent bonds to other molecular agents (DNA, RNA, other proteins) or enzymatic when they can catalyze the chemical modification of the substrate to which they are bound. In the first case one usually talks about complex formation, in the latter one talks about post-transcriptional modification. It has been observed that the amino acid sequence of most proteins appearing in living organisms can be regrouped into domains which are strings of amino acids that have a specific

fold in space that is rather context free. Biologists tend to associate “functions” to domains, for instance zinc finger domains are often linked to the specific DNA binding capability of their host protein.
The first step of our construction, termed C0, is aimed at representing domains as a collection of interaction sites, proteins as a collection of domains and interactions as protein assembly and complex formation.
Terms
Consider an infinite set of site names S = {x, y, z, . . . } and a disjoint infinite set of backbone names B = {a, b, c, . . . }. Let D be a terminal symbol, distinct from all others, that we use to denote domains. Terms T of C0 are built on the following grammar:
D, Dj ::= Da(x1,..., xk)	for a ∈ B, xi ∈S 
T, S	::= D | 0 | (T, S) | T\v	for v ∈S ∪ B
Intuitively a k-ary domain Da(x1,..., xk) is the placeholder of k (interaction) sites and one backbone. Each site i is equipped with a name xi ∈ S and each domain with a backbone name a ∈ B. Backbone name sharing denotes domains that belong to the same protein, site name sharing denotes complex formation. We inductively define free occurrences of names as:
fn (Da(x1,..., xk)) = {a, x1,..., xk}
fn(0) = ∅
fn(T, S) = fn(T ) ∪ fn(S)
fn(T\v) = fn(T ) − {v}

Symmetrically, one can define the bound occurrences of names, which we shall denote by bn(T ). Terms are equipped with a natural notion of structural congruence defined in Fig. 1. The structural congruence relation rules include a natural α- equivalence on bound names. In the following we assume that names that are not under the same binder are kept distinct.
Graphical notation

		

T = Da(x, y), Db(x, z) \y
S = (Da(x), Da(x)) \x
U = (Da(x, x), Da(z), Da()) \a\x

Intuitively, the term to port graph correspondence is the following: domains are nodes, sites and backbones are ports and name sharing denotes (hyper) edges. Bound names denote closed ports and we use the term closed edges to denote a


(S, T )	≡ (T, S)
((T, S),Tj) ≡ (T, (S, T j))


Fig. 1. Structural congruence for C0.

bound name that is shared. Similarly, free names denote open ports and form open edges when they are shared. Open ports or edges can be merged or closed in the context (see later). With these conventions, one may view any term (up to struc- tural congruence) as the isomorphism class of a port graph (with hyper-edges), in the style of bigraphs [16], where nodes (domains) are equipped with connection ports (sites and backbones). As an example we give above the port graph repre- sentation of terms T, S and U . The reader familiar with bigraphs will notice that we drift slightly away from Milner’s notation: site ports are represented by small circles that are filled when they are closed. Backbone ports are represented as small triangles that are also filled when they are closed. We use curved lines for site edges and straight lines for backbone edges. We label open edges or open ports with the corresponding free name (closed edges and ports are not labelled). Note that we will omit site numbers whenever they are not necessary.
Connections between sites correspond to physical contacts between protein parts. This connection being exclusive we want to restrict to terms where restrictions bind at most two occurrences of site names. In the following of this paper we will assume that for any term T , free site names occur exactly once in T and bound site names have at most two occurrences. Note that we do not impose such restrictions on backbone name sharing.

Pattern matching and dynamics
A match for T in S is defined as a context C[•] with exactly one hole such that
C[T ] ≡ S. Such contexts are defined inductively as:

C[•] ::= •| C[•]\u | C[•],T	u ∈B ∪ S

A rule is a pair of terms ⟨T, S⟩ such that fn(S) ⊆ fn(T ). Given a set R of such pairs, one may rewrite terms by letting these rules be applied in a context free


disconnect

connect


cleave

fuse


degrade


Fig. 2. The set G0 of generators for C0.


manner, i.e. :
r = ⟨T, S⟩∈R	T j ≡ C[Tσ]	Sj ≡ C[Sσ]

T j →r Sj

for some name substitution σ.

Generators
It is clear that not all rules make sense from a biological point of view: the fact that backbone names denote the core of a protein and that site names denote connection between protein domains is purely conventional and this convention could be easily broken. A way to proceed is to define some sorting discipline that allows one to screen off undesired terms from admissible ones [2], invalid rule applications being discarded “on the fly”. Instead of doing this, we adopt a strategy of pre-conceiving what “laws” a modeler is able to invoke when defining her own rule set. This is achieved by defining a set G0 of basic rule generators that a modeler can only refine to her needs, cf. Fig. 2. These generators allow one to perform standard atomic actions of graph rewriting. It is noteworthy that these generators, including degrade, are side effect free. We shall carry this set of generators throughout the rest of this paper, incorporating new generators as the language grows.
Say a rule r = ⟨T, S⟩ is generated if and only if it can be obtained by:
refinement: there exists ⟨T j, Sj⟩∈ G0 such that T ≡ C[Tjσ] and S ≡ C[Sjσ] for some context C[•] and substitution σ.
composition: one can generate two rules ⟨T, T j⟩ and ⟨T j, S⟩.

Discussion
We have introduced so far a simple calculus that rewrites proteins structured as connected domains. Proteins can be connected to each other (as in complex for- mation), new domains can be fused to proteins (as in protein synthesis) or severed (as trans-membrane proteins can be cleaved to emit signals into the inter cellular medium). This calculus is fairly abstract in the sense that two proteins may only differ in the number of domains they have and in the number of sites these domains

possess. It is clear that we lack means of naming molecular components such as do- main names (SH2, Tyrosine, PWWP etc.) or protein names (SOS, EGF, IGF, p53, etc.). Before performing a bigger increment in expressiveness, when we introduce compartments in Section 4, we would like to briefly introduce a way to deal with names as a particular type of context in which unamed proteins can be embedded. The intent is to provide a way to define molecular reactions as refinements of the generators we have just presented, in keeping with the biological intuition that in- formation about molecular objects is always partial and that more context could reveal more about the nature of a molecule. In particular, we have the ontology problem in mind that several names can denote the same protein or gene.

C1: naming molecules
Terms
Consider a new set of names M that is pairwise disjoint from B and S. Terms of C1 are essentially those of C0 where domains have an extra meta name m, mj ∈M that will point to new type of terms called info terms (denoted by I, J, . . . ). Let I be a set of terminal symbols (distinct from all previous ones) called informations (think of protein or domain names). The grammar of C1 is:

m






Structural congruence coincides with the one defined earlier.

Graphical notation
This simple extension has a natural impact on the graphical notation, as shown in Fig. 3 with an example of amino acid synthesis. Info nodes are represented by their type (Nucl., G, Ribosome, Prot. compl., Amino acid, Glycine) without drawing borders around them. Meta names that are shared by nodes induce thin straight hyper edges. Open meta ports are not drawn, and closed meta edges are represented with filled arrowheads (as in the Amino acid and Glycine nodes on the right hand side).
There are only two specific generators for C1, for all Info ∈ I:

(Concretize)	Da (x1,..., xk) → Da (x1,..., xk), Infom
m	m
(Abstract)	Da (x1,..., xk), Infom → Da (x1,..., xk)
m	m

and again, rules can be generated by refinement and composition of generators.









⟨G, ∗,G⟩→ Glycine








Fig. 3. Graphical illustration of the role of info nodes and meta names, with the rule for the RNA translation of a Glycine amino acid. Node shape is purely illustrative. A ribosome is bound to a guanine being part of an RNA strand (backbone b) and has started to assemble a new protein (backbone a). The next nucleotide on the right is of unspecified type followed by a G nucleotide, this triplet ⟨G, ∗, G⟩ codes for the Glycine that is produced on the right.

Discussion
With little symbol pushing burden we obtain a fairly expressive language which, at this stage, is already a reasonable candidate for representing most types of synthetic biology systems. It is noteworthy that the nature of an interaction can be expressed here as a form of type instantiation. One may think of C0 generators as polymorphic reaction types: (α, β) connect or α synthesize. They can be instantiated as (A,B ) connect or Amino acid synthesize.
This second step brings us closer to the κ-calculus of Danos and Laneve [10]. In fact, our calculus now encompasses κ in a straightforward way (see Appendix A).

C2: placing molecules
As we already stressed in the previous sections, we have for now abstracted away from space and geometry: molecules are assumed to be floating in a uniform medium that lets domains react freely with each other. One could for instance encode a discrete compartment as info nodes attached to each domain and make sure they are compatible when two domains encounter. Yet, not only would this induce an explosion in the number of rules to write, but also entail a lot of book keeping rules in order to make sure that protein domains remain co-localized. We propose here to exploit our informal yet underlying relationship with bigraphs in order to add a simple notion of compartmentalization to our language.

Terms
Let V be an infinite set of parameter names {X, Y, Z, ... } assumed to be pairwise disjoint from S, B and M. Let C be a terminal symbol, distinct from previous ones. Terms P, Q,... of C2 are generated by the following extension of the grammar for C1:
T, S ::= ··· | Cm(T ) | X	m ∈ M, X ∈V	(local terms)
P, Q ::= T | (T	P ) | P\v	v ∈ M∪S ∪B	(wide terms)

Terms of the form Cm(T ) denote compartments. They are nodes with a meta name, like domains, but have neither sites nor backbone. In the way defined in the previous section, this meta name allows one to specify a type of compartment: for instance nucleus, membrane ∈ I (one may also think of region ∈ I to denote compartments with no physical boundaries).
Note also the use parameters as in Cm(X), where X denotes the unspecified content of compartment Cm. We use V(P ) to denote the set of parameter names in P . For simplicity we consider here “linear terms”, i.e. terms that do not contain multiple copies of the same parameter variables. It entails that a rule may delete parameters but not duplicate them.
Terms of C2 are either local, in which case we use T, S to denote them, or wide in which case we use P, Q. The term P = (T  S) is a pattern requiring T and S to be separated by exactly one compartment boundary in any context; note that this differs from the interpretation of wide composition in bigraphs, where they may be separated by any number of boundaries. Hence we will see that P has a match in both (Cm(T ), S) and (T, Cm(S)). We want to absorb here the projective view of membrane reactions introduced by Danos and Pradalier [11] and also present in a later work by Cardelli [4]. The underlying idea is that membrane curvature is a global property that one may not want to consider when expressing cellular mechanisms. This trait will turn out to be very useful when defining a minimal set of generators for C2.
Definition 4.1 [Local contexts] A context C[•] with exactly one hole is a local context if it is of the form:
C[•] ::= •| C[•]\u | C[•],T	u ∈B ∪ S
Note that the context Cm(•) is not a local context. It is however a derivable wide context as we will see shortly.
Structural congruence for C2 extends the one of C1 with the following laws for wide composition of terms:
Cm(T )  ≡ Cm(T j)	if T ≡ T j Cm(T\u) ≡ Cm(T )\u	if u /= m (P\u)\v ≡ (P\v)\u
P\u  ≡ (P {v/u})\v  v /∈ fn(P ) T\u  P ≡ (T  P )\u   u /∈ fn(P ) T  P\u ≡ (T  P )\u   u /∈ fn(T )
It is clear that any wide term is structurally congruent to a term of the form (T1  ···  Tn)\V (using the shorthand P\V for the restriction of the names of V ). We sometimes write P  Q to denote the concatenation P and Q (in the style of list concatenation). Importantly a pattern of the form T  S  T j specifies

that T and T j are exactly two compartment layers away from each other, and that S is one compartment layer away from both T and T j, we will call this distance projective because it does not take the orientation of the compartment borders, that will separate the terms in the context, into account. We shall see that valid matches for a wide term (T1  · · ·  Tn)\V will correspond to those in which the distance between Ti and Ti+k is exactly k, for all i ∈ {1,...,n − k}.
Pattern matching
For any wide term P , say that P has width w(P )= n if P ≡ (T1  · · ·  Tn)\V for some local terms Ti.
Definition 4.2 [Projective distance]
Let P be a wide term and Ti, Tj two disjoint term occurrences in P .  The
projective distance of Ti, Tj in P , written ΔTi,Tj (P ) is inductively defined as:
ΔTi,Tj (Ti, Tj)	= 0
ΔTi,Tj (T, S)	= ΔTi,Tj (T )	if Ti, Tj /∈ S
ΔTi,Tj (P\u)	= ΔTi,Tj (P ) ΔTi,Tj (Cm(T ))	= ΔTi,Tj (T )
ΔTi,Tj (Cm(T ), S) = ΔTi,Tj (T, S)+1	 if Ti ∈ T and Tj ∈ S ΔTi,Tj (T  P )	 = ΔTi,Tj (P )	 if Ti, Tj ∈ P ΔTi,Tj (T  P )	= ΔTi,Tj (T )	if Ti, Tj ∈ T ΔTi,Tj (T  S  P ) = ΔTi,Tj (T  P )+1 if Ti, Tj /∈ S ΔTi,Tj (T  S)	= ΔTi,Tj (T, S)+1	 if Ti ∈ T, Tj ∈ S
In other terms, the projective distance between Ti and Tj is equal to the number of wide compositions and compartment layers that separate Ti from Tj.
Given a wide term P = (T1  · · ·  Tn)\V , we need to define contexts Cn[•,..., •] with exactly n holes in which one may embed P while preserving nesting distance. Let generic contexts (with an arbitrary number of holes) be inductively defined as:
T•, S• ::= •| T | (T•, S•) | (T•)\u | Cm (T•)	u ∈B ∪ S ∪ M & m ∈M 

For any such context T• with exactly k holes, we write T• = Ck[•,..., •] or simply T = Ck. Importantly, not all contexts of the form C1 is a local context since Cm(•) is not local. Furthermore, not all contexts of k holes will be valid placeholders for wide terms of width k. Rather than trying to enumerate valid contexts with n holes we use a procedure that generates valid matches for terms of arbitrary width. We will then prove that this procedure is both sound and complete in the sense that it finds only correct matches for wide terms, and finds them all.

(ax.)


T ‹→• C[•]
P ‹→π T•	v /∈ fn(T•) ∪ bn(T•)
P\v ‹→π T•
(rest)



P ‹→π T•	m fresh	Q·π·¢ /→⊥ 
P ‹→Q·π·¢ Cm(T•)
(wrap)



P ‹→π0 T•	Q ‹→π1 S•	π0 · π1 /→⊥ 
(comp)


Table 1
The extension relation. Contexts C[•] are the local contexts of Definition 4.1.

def
Let projection constraints π be words on the alphabet Π = {Q, ¢, •, ⊥}. We use
these constraints during the construction of a wide context Cn, as an abstraction of the context that retains only the positions of compartments borders, symbols Q and ¢, and holes, symbol •. In order to check that Cn is a valid context, it will suffice to make sure that the projection constraint is well-formed. For instance, the constraint π = •· Q·• ·¢ ·• is an abstraction of an invalid context with exactly three holes, that would place the term T  S  T j in an environment where T and T j would be at (projective) distance 0 instead of 2. Invalid constraints are detected during the construction of a wide context (cf. Table 1), using the reduction relation of Table 1.
Definition 4.3 [Valid constraints] Let π ∈ Π∗ be a projection constraint. Let · denote the concatenation of words over the alphabet Π. Say that π is valid if π /→ ⊥ with → ⊆ Π∗ × Π∗ the least reflexive, transitive, and compatible relation engendered by:

The inductive construction of the extension relation is given in Table 1. Let μ, μj,... denote (possibly empty) lists of parameter assignation of the form [X1 → T1]; ... ; [Xn → Tn] with V(Ti)= ∅. We use |μ| to denote the set of parameter names in μ, and Pμ to denote P in which parameters have been substituted according to μ.
Definition 4.4 [Matches] A wide context Cn[•,..., •] with exactly n holes and a parameter assignation list μ form a match ⟨Cn, μ⟩ for a wide term P = (T1  ···  Tn)\V in S if and only if:
P ‹→π Cn	and	|μ| = V(P )	and	((Cn[T1,..., Tn]μ)\V )σ ≡ S
for some name substitution σ.
Furthermore, a pair r = ⟨P, Q⟩ with w(P ) = w(Q) = n and V(P ) = V(Q)

Informal

Left hand side	Right hand side

Informal



Fig. 4. Generators for C2.


generates a transition T →r S if the match ⟨Cn[•,..., •], μ⟩ for P in T is a match for Q in S.
We conclude this section with the expected soundness and completeness results for our extension relation with respect to projective distance.

Theorem 4.5 (Soundness) Let ⟨Cn[•,..., •], μ⟩ be a match for a wide term P in a local term T. For all disjoint local term occurrences S, Sj ∈ P, we have ΔS,S′ (P )= ΔS,S′ (T ).

Theorem 4.6 (Completeness) Let P = (T1  · · ·  Tn)\V be a wide term and Cn[•,..., •] be a generic context with exactly n holes. Let also T ≡ ((Cn[T1,..., Tn]μ)\V )σ for some parameter assignation μ and name substitution σ.
If for all i, j ≤ n one has ΔT ,T (P ) = ΔT ,T (T ), then P ‹→π Cn is derivable,
i  j	i  j
for some π ∈ (Π\{⊥})∗.

Generators
The generators are presented in Fig. 4, keeping with the graphical convention in- troduced earlier. We add here compartments, represented as nodes with double line boundaries, and variables. Wide terms are simply represented next to each other. Crucially, the possibility to express compartment patches independently of their general curvature allows us to maintain a minimal set of generators. Rules specifying curvature are then obtained as refinements of these generators. The wide versions of the fuse and cleave generators now allow for the representation of trans- membrane proteins (aka receptors). Note that we do not generalize the connect and disconnect generators to keep with the fact that protein-protein interactions are local.
The other generators rely on the intuition, sketched in an earlier work on bi- graphs [15], that dynamic molecular compartments can be modeled using an inter- mediate step where two compartments are connected by a “neck”. This neck, visible in generators pinch, merge, touch and unsafe-diffuse, is represented by two connected channel nodes, which are particular info nodes. In the unsafe-diffuse rule, they are used to indicate that molecules can translocate from one location to another, along the channel edge. This rule can be applied in order to populate a vesicle after pinch or touch, and until part or merge is applied.
At this stage our language is equipped with ways to model dynamic compart- ments and diffusion. Yet, consistency of the biological interpretation of C2 terms relies on a careful usage of the unsafe-diffuse rule. Indeed, nothing prevents mod- elers from using this generator to stretch a protein across several membranes by diffusing only a part of it, violating the desired invariant that only a backbone edge may cross a compartment (in the case of a receptor). In order to correct for this, we need to restrict diffusion to instances that will preserve biological soundness of terms. The final step in the design of our language is aimed at solving this question.

C3: moving molecules
Terms
Let specB be a family of B and S indexed terminal symbols (distinct from all others) with B ⊆ B and S ⊆ S ∪ M. The grammar generating terms of C3 extends the previous one in the following way:

T, S ::= ...	 (local terms) G, H ::= T | specB(T ) | (G, H)	(global terms) P, Q ::= G | (P  Q) | ...	(wide terms)
where specB(T ) denotes the fact that term T describes a partial species, i.e. is either a connected component or a pattern that should be placed in a context that will make it connected. The sets B and S denote respectively the free backbone names

of the species and its free site and meta names. These names are kept separated for convenience because backbones will be allowed to cross membranes while meta and site names will not be shared by nodes that are not co-located in the same
compartment. For instance, the expression spec{a}((Db (x),X)\b, x, m) denotes a
$	m
partial species that contains a domain Db (x) and that may only have a connection
with other nodes outside the species boundaries by sharing the backbone name a.
The idea behind C3 is that although connectivity, i.e. transitive closure of name sharing, is a property one may not want to consider in general, it becomes relevant for some particular interactions including diffusion. We will come back to this in the section describing the new generators.
Structural congruence allows us to form spec nodes on demand. To do so, we extend previous structural laws with the following ones:


Da (x ,...,x ) ≡ spec{a}
(init)
(Da (x ,...,x ))

m	1	k
{m,x1,...,xk}	m	1	k


fn(A) ∩ (B ∪ S) /= ∅	Bj = B ∪ (fn(A) ∩ B)	Sj = S ∪ (fn(A) ∩ S)
specB(T ),A ≡ specB′ (T, A)	(grow)
S	S′


u ∈B ∪ S	Bj def B − {u}	Sj def S − {u}
T ≡ T j

specB(T )\u ≡ specB′ (T\u)	specB(T ) ≡ specB(T j)
S	S′	S	S
Where A is either a domain node or an info node. Intuitively, the left-to-right orientation of the above first three equations allows one to capture more knowledge about connectivity, while the other direction is forgetful. If one wishes to consider diffusion of vesicles, one needs the additional rule:
fn(Tj) ∩ (B ∪ S) /= ∅  Bj = B ∪ (fn(T j) ∩ B)  Sj = S ∪ (fn(Tj) ∩ S)

specB(T ), C (T j) ≡ specB′ (T, C
(T j))

S	m	S′	m
that allows one to encompass compartments in the recognition of molecular species. In order to ease the understanding of the generators presented in the next section,
let us give a simple example of the usage of a species term in a pattern. Consider
the term P = (speca(X)	speca(Y ))\a which denotes a transmembrane complex
$	$
split in two parts X and Y on both sides of a membrane. We wish to find a match
for P in the term:

T = Da (x), SH2m , Cm (Da (y), Db
(y)) \ {a, b, x, y, mi}

m1	1	2	m3	m4
To do so, we first need to turn T into a form that makes the desired connectivity apparent:
T ≡ speca(Da (x), SH2m \ {x, m1}),
$	m1	1

Cm (speca((Da (y), Db
(y))\ {b, y, m3, m4})\m2 \a

2	$	m3	m4



diffuse


(spec∅(X), channelm  0  channelm)\m → (channelm  0  channelm, spec∅(X))\m
∅	∅

diffusem



(speca(X ), channelm  specA∪a(Y )  channelm)\m\a → (channel
specA∪a(Y )  channel
, speca(X))\m\a

∅	S	m	S	m	∅

intra


specab (Da(x1,..., xi,..., xk), Db(y1,..., yj,..., yq ))\xi\yj → specab ' (Da(x ,...,z,...,x ), Db(y ,...,z,...,y ))\z

x˜,y˜
x˜' ,y˜	1
k	1	q

Fig. 5. C
generators. In the intra
def
{x ,...,x }
def
{y ,...,y }
′ def
{z/x }

3
′ def
generator, let x˜ =	1
k and y˜ =	1
q , x˜ = x˜	i

and y˜ = y˜ {z/yj }
Then, using the extension relation, we generate a context for P
P ‹→•·Q·•·¢ (•, Cm(•)) = C2[•, •] which, together with a list of parameter assignations
def	a	a	b
μ = [X → (Dm1 (x), SH2m1 )\ {x, m1}]; [Y → (Dm3 (y), Dm4 (y))\ {b, y, m3, m4}]
defines a valid match for P in T . One verifies that, indeed:
(C[speca(X), speca(Y )]μ) {m2/m} \a ≡ T
$	$
Generators
Generators are given in Fig. 5. They extend the generators of all previous stages, to the exception of the unsafe-diffuse rule that is replaced by its safe counterparts. We keep with the graphical conventions introduced earlier, and use cloud nodes to denote (partial or total) species.
As one may see in Fig. 5, we now have two generators for diffusion. The first one models classical diffusion: a total species may move from one compartment connected to another via a channel. The second generator models diffusion of transmembrane species: two partial and parametric species denote, respectively, both sides of a transmembrane complex. The side of the complex whose content is X may translocate while the other side stays in its current location. The result of this operation in the two possible projections, is informally depicted on both

sides of the generator and corresponds to the diffusion of a transmembrane complex along the neck. Finally, the intra generator stands for intra-molecular complex formation 2 .
Definition 5.1 [Mixture] Say that a term P is a mixture if:
w(P )= 1, fn(P )= ∅ and P is parameter free
Site edges have exactly two sites and do not cross compartments
Backbone hyper edges cross at most one compartment
P is structurally equivalent to a term that contains no species node.
The last condition essentially states that species nodes that are present in a mixture are derivable from a species free mixture to which the above structural congruence rules have been applied. To ensure this one simply needs to verify the simple syntactical condition:
Proposition 5.2 A global term of the form G = specB(T ) is a mixture if and only
if T:
T is a mixture.
fn(T )= B ∪ S.
T is a connected component.
The above proposition guarantees that one may always eliminate species nodes of the form specB(T ) from a mixture, provided the sets B and S capture the free names of T and provided T defines a single connected set of agents. Note however, that general global terms need not be mixtures and one may have occurrences of species node in rules that do not satisfy this condition as it is for instance the case in the diffusem generator. Yet not all species node make sense in a C3 expression.
For instance spec$(Da (x),X) will never have a match in any mixture since the
$	m
structural congruence for species node introduction will always insure that the free
names a, m and x will appear in the superscript and subscript of spec. The following proposition defines well-formed expressions with species nodes:
Proposition 5.3 For any term G = specB(T ), there exists a mixture M such that
G has a match in M if and only if:
fn(T ) ⊆ B ∪ S
and either:
T is connected
u(T ) /= ∅ and fn(T ) /= ∅
fn(T )= ∅ and T = X1,..., Xn for some parameters Xi .
Note that the second condition says that either T needs to be already connected in the expression or leave ”room enough” so that the context will make T connected. It is easy to check that all the generators introduced in Fig. 5 satisfy this condition.

2 This generator cannot be obtained as a refinement of connect since specB(•) is not a valid local context.

Lemma 5.4 (Preservation) Let R be a set of generated rules and let P be a mixture. If P →r Q with r ∈R then Q is a mixture.
As a corollary of the above lemma and Proposition 5.2, one has that a term containing specB(T, S) can only have a match in a mixture where T and S are part of the same connected component, which is a guarantee of the soundness of the intra generator.
Conclusion
The idea that models of signaling pathways or protein assembly should be considered as programs is now wending its way through the systems biology crowd. This is an appealing fact to language theoreticians, because it implies that one needs to accomplish in Systems Biology the same mutation that was accomplished in software engineering, when programs became too cumbersome and unwieldy to be developed in a non uniform way. This suggests that systems biology will soon require the development of high level languages, debuggers, and IDEs to compensate for the increasing gap between accumulation of data and its representation in executable models. The work we have presented here is an attempt to comply with Fontana’s requirement that “a model should be a data structure that contains a transparent, formal, and executable representation of the facts it rests upon” [13]. In order to do so, we have structured our language in order to be able to tune the resolution level of the entities we wanted to describe: from anonymous domains, to molecular species, and from membrane patches to full fledged compartments.
We have already mentioned several approaches that were conducted with similar motivations, some of which we took inspiration from. Yet, we believe that the presented language offers a level of expressivity that was not accessible before in a single formalism. In particular we should mention that our language strictly contains the κ-calculus and corresponds to a particular class of bigraphical reactive systems that is yet to be defined formally 3 . Obviously, expressiveness and relative ease of use is not enough and future work should aim at developing quantitative simulation and analysis techniques. Here again, previous works have paved the way for such developments. In particular, proximity with the κ-calculus for which such analysis and simulation technique have been defined [8,7] and the stochastic semantics for bigraphs [15], should be of great help.

References
Andrei, O. and H. Kirchner, Graph rewriting and strategies for modeling biochemical networks, in:
Proc. SYNASC, 2007, pp. 407–414.
Bacci, G., D. Grohmann and M. Miculan, A framework for protein and membrane interactions, in:
Proc. MeCBIC’09, 2009, pp. 19–33.
Cardelli, L., Brane calculi - interactions of biological membranes, in: Computational Methods in Systems Biology, Springer, 2004 pp. 257–278.

3 This may prove to be a complex task, since projectivity is not a trivial concept to capture with the standard definition of bigraphs. See Ref. [6] for some hints on how to do this.

Cardelli, L., Bitonal membrane systems - interactions of biological membranes, Theoretical Computer Science 404 (2008).
Chabrier, N. and F. Fages, Symbolic model checking of biochemical networks, in: Proc. CMSB’03, LNCS
2602, 2003, pp. 146–162.
Damgaard, T. C. and J. Krivine, A generic language for biological systems based on bigraphs, Technical Report 115, IT University of Copenhagen (2009).
Danos, V., J. Feret, W. Fontana, R. Harmer and J. Krivine, Abstracting the differential semantics of rule-based models: exact and automated model reduction, in: IEEE Symposium LICS, 2010, pp. 362–381.
Danos, V., J. F´eret, W. Fontana and J. Krivine, Scalable simulation of cellular signaling networks, in:
Proc. APLAS’07, LNCS 4807, 2007, pp. 139–157.
Danos, V. and C. Laneve, Core formal molecular biology, in: Proc. ESOP’03, LNCS 2618, 2003, pp. 302–318.
Danos, V. and C. Laneve, Graphs for formal molecular biology, in: Proc. CMSB’03, LNCS 2602, 2003,
pp. 34–46.
Danos, V. and S. Pradalier, Projective brane calculus, in: Proc. CMSB’04, 2004, pp. 134–148.
Faeder, J. R., M. L. Blinov and W. S. Hlavacek, Rule based modeling of biochemical networks, Complexity (2005), pp. 22–41.
Fontana, W., Systems biology, models, and concurrency, in: Proc. POPL’08, 2008, pp. 1–2.
John, M., C. Lhoussaine, J. Niehren and C. Versari, Biochemical reaction rules with constraints, in:
Proc. ESOP 2011, LNCS 6602, 2011, pp. 338–357.
Krivine, J., R. Milner and A. Troina, Stochastic bigraphs, in: Proceedings of MFPS XXIV, ENTCS
218, 2008, p. 7396.
Milner, R., “The Space and Motion of Communicating Agents,” Cambridge University Press, 2009.
Phillips, A. and L. Cardelli, Efficient, correct simulation of biological processes in the stochastic pi- calculus, in: CMSB, 2007, pp. 184–199.
Priami, C. and P. Quaglia, Beta binders for biological interactions, in: Computational Methods in Systems Biology, LNCS 3082, 2005, pp. 20–33.
P˘aun, G. and F. J. Romero-Campero, Membrane computing as a modeling framework. cellular systems case studies, in: Formal Methods for Computational Systems Biology, LNCS 5016, 2008, pp. 168–214.
R.Barbuti, A.Maggiolo-Schettini, P.Milazzo and A.Troina, A calculus of looping sequences for modelling microbiological systems, Fundamenta Informaticæ72 (2006), pp. 21–35.
Regev, A., E. M. Panina, W. Silverman, L. Cardelli and E. Shapiro, Bioambients: An abstraction for biological compartments, Theoretical Computer Science 325 (2004), pp. 141–167.
Regev, A., W. Silverman and E. Y. Shapiro, Representation and simulation of biochemical processes using the π-calculus process algebra, in: Pacific Symposium on Biocomputing, 2001, pp. 459–470.

Retrieving the κ-calculus.
In this section we show how one may naturally represent any κ-calculus model at the C1 level of our language. As the encoding is rather straightforward from a technical point of view, we shall simply describe here the translation of a particular example. We then show how C3 enables us to go beyond what one can express in κ.
The κ-calculus
We consider here the definition of κ that is implemented in the κ-simulator KaSim 4 . Terms of the κ-calculus are built on the following grammar:
Definition A.1 (κ-Agents)
agent	a ::= N (σ)
agent name	N ::= A ∈A 
interface	σ ::= ∅| s, σ
site	s ::= nλ
site name	n ::= x ∈S 
internal state	ι ::= ϵ	(any state)
| m ∈ V


Expressions are simply formed by concatenation of agents E ::= a, E | ∅. Every agent represents a molecular entity (such as a protein) that has sites that can be used for complex formation (i.e. binding with other sites). For instance the expression:
EGF(r1),ErbB1(l1,CR3,Y1016p,Y1092?),EGF(r2),ErbB1(l2,CR3,Y1092−)
p	u
corresponds to a molecular soup containing two instances of the agent ErbB1 (a membrane receptor for the epidermial growth factor protein) and two instances of the agent EGF (the growth factor signal). In κ, each agent name comes with a fixed signature Σ: N → P(S) that specifies the names of the sites each instance has. For
def
instance Σ(ErbB1) = {l, CR, Y1016, Y1092,... }. Note that the protein ErbB1 has
in fact numerous tyrosine domains (whose name are of the form Yxxx where xxx
corresponds to some amino acid position in the chain) that we do not list here. As

4 http://kappalanguage.org




























Fig. A.1. Representation of the κ expression into C1.
a convention in κ, one does not represent sites that take no part in a given rule. In the example above, the site Y1092 is left aside in one of the instances of ErbB1.
The superscript on a site indicate its binding state. The empty superscript ϵ marks a site that is free of any connection, indicates that the site is bound to an unspecified partner, ? indicates a site that is either free or bound and an integer is used to denote an explicit edge, as the one that connects the site r of the leftmost EGF to the site l of ErbB1.
The subscript on a site indicate its internal state. This is essentially a placeholder for a tag that serves to identify sites that have been chemically modified. Note that the absence of tag indicates that one does not care about its internal state in the expression.
The κ-calculus in C1
Fig. A.1 shows the C1 representation of the above κ-expression.
The convention we adopt for the representation of κ-terms is the following: we use a domain node for each site of the kappa expression to translate. Internal states, site and agent names are represented by info nodes. Sites that belong to the same κ-agents will share the same backbone. Sites that are connected in the κ expression will be bound in the C1-term. Notice that the backbone of both instances of ErbB1 are both open. This captures the fact that not all sites of the signature of ErbB1 are present in the expression.
Expressiveness of C3
As said, ErbB1 proteins are in fact membrane receptors. ErbB1 protein is composed of an extra cellular domain that holds the ligand binding site l and an intra cellular domain that bears the other interaction sites. Now that we have represented our expression in a richer language, it becomes natural to represent these facts as we show in Fig. A.2.










cell








Fig. A.2. Adding compartments to the the κ expression.
A key regulatory mechanism of the EGF pathway is called receptor internaliza- tion. It is a mechanism by which receptors become trapped in inner vesicles that may eventually bubble down to the cytoplasm of the cell. This prevents the receptor from binding to new incoming signals. It is not possible to represent this behavior in κ for two reasons. The first reason, which we have already solved, is that there is no way to represent compartments in κ. The second reason is more subtle. Indeed, during receptor internalization, not only will ErbB1 get trapped inside the vesicle, but along with it will be any protein complex attached to its extra cellular domain. In the example of Fig. A.2, one should capture also the EGF ligand that is bound to it. This is what we do in Fig. A.3 by defining an internalization rule that utilizes a species node.


Intern.



(spec∅(X)  spec∅(Dm(x), ErbB1m))\b → channelp  (Cm' (channelp, spec∅(X)), vesiclem' , spec∅(Dm(x), ErbB1m))\b












cell









Fig. A.3. The Intern. rule is obtained by composition of the pinch and diffusem generators and invoking the species node where it is needed. Below is the result of the application of this rule to our example. Notice that the receptor gets internalized together with its ligand protein EGF.
