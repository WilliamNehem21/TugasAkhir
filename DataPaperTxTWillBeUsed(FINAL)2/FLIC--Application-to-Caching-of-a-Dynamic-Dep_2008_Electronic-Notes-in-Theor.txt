

Electronic Notes in Theoretical Computer Science 219 (2008) 3–18
www.elsevier.com/locate/entcs

FLIC: Application to Caching of a Dynamic Dependency Analysis for a 3D Oriented CRS
Gurvan Le Guernic 1
KSU, Manhattan, KS 66506, USA &
IRISA, 35042 Rennes, France
Julien Perret 2
INRIA Rocquencourt, 78153 Le Chesnay, France &
Thinkcollabs, collaborative research lab, France

Abstract
FL-systems are conditional rewriting systems. They are used for programming (describing) and evaluating (generating) huge 3D virtual environments, such as cities and forests. This paper presents a formal semantics and a dynamic dependency analysis for FL-systems. This analysis allows the characterization of a set of terms which are joinable with the currently rewritten term. Consequently, it is possible to speed up the
rewriting steps of the environments generation by using a cache mechanism which is smarter than standard ones. This work can be seen as a dynamic completion of a set of rewriting rules. This completion increases the number of terms which are rewritten in normal form by the application of a single rewriting rule.
Keywords: dependency analysis, conditional rewriting system, FL-system, cache


Introduction
Managing huge 3D virtual environments involves dealing with some particular con- straints. It requires storing the description of many objects having structural sim- ilarities and appearing identically (or nearly so) in different places of the environ- ment. For example, in a virtual city, the geometric objects representing background buildings of the same size and of similar architectural styles are likely to be identi- cal. The exhaustive description of a virtual environment in a 3D modeling language (e.g. VRML [7]) represents a huge amount of data (which can be problematic when

1 Email: Gurvan.Le Guernic@irisa.fr
2 Email: Julien@thinkcollabs.org

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.031

this description must be sent to another user, stored, or simply displayed) and im- plies a difficult management of the environment. With the example of an urban environment, changing the style of the street lamps requires going through the en- tire environment and changing the description of each street lamp. This, obviously, is a lot of work. Fortunately, most 3D modeling languages include the concept of prototype, allowing the user to define parameterized 3D objects. Nevertheless, this technique involves additional work for the user during the modeling process.
Another solution consists in using a conditional rewriting system (CRS) ([4,3]) called FL-system [14], short for Functional Lindenmayer-system. This system, based on L-systems [12] and Chomsky grammars [16], enables the description of the general structure of each type of object appearing in the environment. Each object is then generated by rewriting a parameterized module (a level 1 term). The whole environment is described by an axiom (the initial module) which is the starting point of the environment’s generation process, and a set of rewriting rules describing the construction of the different types of objects. This method allows for a smaller description of the environment and is easier to manage. The generation of many objects belonging to the same type is achieved by rewriting the same module but with different parameter values.
The main problem of FL-systems, compared to an exhaustive description, is the cost of the rewriting step. However, this cost can be reduced by reusing the result of previous rewriting processes. For example, in an urban environment, it is likely that two buildings appearing in different places will be represented by the same geometric object. It is even more likely that a geometric object representing a window will be reused in a lot of different places. It would then be interesting to be able to directly reuse a geometric object without going through the rewriting step if two modules representing elements of the environment are rewritten to the same geometric object. It is possible to implement this directly in the description of the environment. However this method complicates the work of the author of the FL-system and reduces the generality of the model obtained. Another solution consists in using a cache. Whenever a module has to be rewritten, if a key in the cache maps that module then the geometric object associated to that key is used as the result of the rewriting process.
Due to the parametric nature of the FL-system’s modules, a simple syntactic mechanism to verify if a key maps a module is insufficient. For example, a module (of name B) generating a simple building can be defined using three parameters: d for the distance between the building and the observation point (1 being the value for the background), n for the number of floors, and s for the style of the building (B(d, n, s)). For n constant, it is likely that this module would generate the same geometric object whenever d equals 1. Then, B(1, 8, s1) and B(1, 8, s2) generate the same geometric object. However a simple cache mechanism is not able to detect that both modules must be assumed equivalent.
The method proposed in this paper uses some notions and mechanisms similar to those used for the analysis of dependencies between software inputs and outputs [17,2]. Many computer problems are related to dependency [1]. In our case, a

dependency analysis can determine that, whenever d equals 1, the result obtained by rewriting a module B(1,.. .) depends only on its two first parameters. This way, the cache mechanism can automatically detect that B(1, 8, s1) and B(1, 8, s2) must be assumed equivalent. This paper has been inspired by a work of Abadi, Lampson and L´evy. In [2], they present a dependency analysis for the λ-calculus. This analysis enables them to develop a cache mapping some λ-terms to their value. The work presented here adapts and extends their work to the context of conditional rewriting systems. It can be seen as the dynamic completion of the set of rewriting rules in order to be able to rewrite some particular modules by the application of a single rewriting rule.
This paper starts by presenting a simplified version of FL-systems. In Sect. 3, the dynamic dependency analysis used is formalized. Some properties of this analysis, relevant to the cache system, are stated in the same part. The following section presents the application of the theory to the practical case of the cache mechanism. Finally, related works and conclusion come in Sect. 5.

What Are FL-systems?
As stated before, an FL-system is a conditional rewriting system. It is a structural description of the geometric objects appearing in the environment. Those descrip- tions are shorter than standard descriptions of 3D environments. They are also more generic and allow an easier reuse of previous work. This section proposes a grammar and a semantics for FL-systems.

A Grammar for FL-systems
A FL-system is a set of rewriting rules. As defined in Fig. 1, a rule (RWrule) is composed of a left part which is a module, a condition on the module’s variables, and a right part which is a term. The left part is constructed from a module name (its name) and a list of variables or parameters (V arN ame). A term is a sequence of modules and terminals. A module is composed of a module name and a list of expressions (Exp). Constants used in expressions belong to R. In the case of FL- systems, terminals are primitive calls. More precisely, they are calls to geometric primitives belonging to a geometric language or a graphics library (VRML[7,13], OpenGL[18], .. . ).
Example 2.1 [FL-system of bushes]
A(n, δ, l, w, color) : n > 0 → B(n − 1, δ, l, w, color)	rotateZ(δ × 5)
B(n − 1, δ, l, w, color)	rotateZ(δ × 5)	B(n − 1, δ, l, w, color)
A(n, δ, l, w, color) : n ≤ 0 → ϵ
B(n, δ, l, w, color) : n > 0 → [ rotateX(δ)	F(n − 1, δ, l, w, color)
L(n − 1, δ, l, w, color)	A(n − 1, δ, l,w × 0.707, color)]
B(n, δ, l, w, color) : n ≤ 0 → ϵ


T erminal ::= T erminalN ame ( Exp )	|	Symbols
Cond ::= true	|	Exp = Exp	|	Exp > Exp	|	... Exp ::= V arN ame	|	Constant
|	(Exp + Exp)	|	(Exp × Exp)	|	... 
M odule ::= M oduleIdentif ier ( Exp )
T erm ::= M odule Term	|	T erminal  T erm	|	ϵ
RWrule ::= M oduleIdentif ier ( V arN ame ): Cond → T erm

Fig. 1. Grammar of FL-systems. A stands for a list of elements of type A.
F(n, δ, l, w, color) : n > 0 → F(n − 1, δ, l, w, color)	L(n − 1, δ, l, w, color)
rotateZ(δ × 5)	F(n − 1, δ, l, w, color)
F(n, δ, l, w, color) : n ≤ 0 → cylinder(l, w)	moveZ(l)
L(n, δ, l, w, color) : true → [ rotateX(−δ × 2)	leaf(l, color) ] 
Example 2.1 is an FL-system which is a modified version of an L-system found in [15]. It is the description of bushes. In this example, the parameters are n, δ, l, w and color. n reflects the age of the bush and thus influences its size. δ is a rotation angle which has an effect on the general structure of the bush. l and w give the length and width of each bough. Finally, color corresponds to the color of the bush’s leaves. Terminal rotateX (respectively rotateZ) rotates the local coordinate system around the x-axis (respectively z-axis). Terminal moveZ moves the local coordinate system along the z-axis; while terminal [ (respectively ]) pushes (respectively pops) information about the local coordinate system in (respectively from) a stack.
A module A(.. .) is an apex from which three boughs are created. A bough B(.. .) is composed of a flange F(.. .), a leaf L(.. .), and a new apex A(.. .). Each flange is built from a smaller flange, a leaf, and an other flange. When the recursion stops (n = 0), the remaining flanges are replaced by a cylinder of size l and w using the terminal cylinder(l, w). By increasing the recursion in the generation of flange (which is controlled by the parameter n) and the size of the smaller flanges (l and w), it is possible to simulate the bush’s growth phenomenon. Leaves are replaced by geometric objects generated by the terminal leaf(l, color). Figure 2 shows the graphical result for the module A(7, 22.5, 10, 1, green).
A Semantics for FL-systems
In this paper, we assume that an FL-system is valid only if any module, whatever the value of the parameters, can be and is rewritten to a unique normal form. A term in normal form is a term composed only of terminals. We also assume that there is no overloading of the module names. This means that a module name is always followed by the same number of parameters.
The evaluation of an FL-system proceeds in a left to right fashion and enforces a deterministic selection of the rewriting rule applied. This is different from the strategy used for L-systems [12] which is parallel. This restriction is applied in order



Fig. 2. Bush resulting from the FL-system of Example 2.1

to make each rewriting step deterministic. The construction of a cache system for the rewriting process only requires that the normal form obtained by rewriting a given module is unique. However, a stronger restriction has been chosen in order to simplify the proofs of the theorems in Sect. 3 as well as their presentation. In the general case, different rewriting strategies can be used for FL-systems. For more details, see [14].
Let Sem0 be the default semantics for FL-systems and R be the ordered list of the rewriting rules of the FL-system used. NT is a term in normal form. A(v) is a module of identifier A and whose parameter v is a list of values (belonging to R). S is a term. In order to rewrite the term “NT A(v) S ”, the semantics Sem0 applies the following rule:
first(R, A(v)) = A(p): c∗ ∧ c → T
NT A(v) S	→R	NT eval(T [v/p]) S
first(R, A(v)) returns the rewriting rule “A(p): c∗ ∧ c → T ” where: “A(p): c → T ” is the first rule (ri) in the list R applying to A(v) (i.e. the first rule in R whose condition c is true with the values v); and c∗ is the conjunction of the negation of the condition of all the rules applying to a module of identifier A and appearing before ri in the list R. X [v/p] returns the term X where all occurrences of a parameter p appearing in p are replaced by the value corresponding to p in v. For example, (A(x + 3, y))[(1, 0)/(x, y)] returns A(1 + 3, 0). The function eval(T ) goes through the term T to replace every expression by its value. eval(A(1 + 3, 0)) returns A(4, 0).
Example of a Rewriting Step
Example 2.2 (A simple FL-system)
A(m, n): m ≤ 0 → t(n)
A(m, n): n > 0 → A(m, (n − 1))
A(m, n): n ≤ 0 → u(m)

Using the set of rules (FL-system) given in Example 2.2, when rewriting A(1, 2) the function call “first(R, A(1, 2))” returns:
A(m, n): ¬(m ≤ 0) ∧ (n > 0) → A(m, (n − 1))
The term on the right side of the rule (A(m, n − 1)) is then processed. The function eval replaces m by its value (1) and evaluates the expression “n − 1” to 1. So, one rewriting step applied to A(1, 2) returns A(1, 1). In this example, the condition
¬(m ≤ 0) ∧ n > 0 emphasizes the dependency between the rule applied and the value of the parameters m and n. If the negation of the condition m ≤ 0 was not included in the result of the call to first, then the importance of the value of the parameter m would not be explicit.
The preceding paragraph introduces some notions about the dependencies be- tween the result of a rewriting step and the values of the parameters of the module rewritten. The next section formalizes the analysis used to extract those dependen- cies.

A Dynamic Dependency Analysis for CRS
The cache system presented in this paper is based on the notion of joinability of terms in rewriting systems [4]. Two terms are said to be joinable if the terms in normal form obtained after rewriting them are the same. For the work presented in this paper, this notion is extended to a notion of structural joinability. Two terms are said to be structurally joinable if the terms in normal form obtained after rewriting them have the “same structure”. Two terms are said to have the “same structure” if they are constituted of the same sequence of modules or terminals, but with parameters which may have different values. For example, u(1) t(2, 3) and u(3) t(0, 0) have the “same structure”. Based on this notion, an equivalence relation on terms, denoted ≡S, is defined.
Definition 3.1 [Same Structure Equivalence Relation] T and S have the same structure, written T ≡S S , if and only if T and S are empty terms; or the first element of T and the first element of S have the same identifier and the rest of T and S have the same structure.
This section formalizes the method used in order to compute dynamically a set, as big as possible, of terms structurally joinable with the term currently rewritten. The method used is inspired by some work on confidentiality [10]. It is based on the modification of the semantics in order for it to manipulate labeled values. Rewriting a module parameterized with labeled values will then return a term in normal form and a label. This label depends on the labels of the parameters which have influenced the structure of the resulting term.
Computing the Resulting Label
The grammar of FL-systems is slightly modified in order to deal with labeled values. A label is a set of identifiers. Values are now pairs written “l : n” and belonging to Label × R. The second element of the pair (n), also called numerical value,

corresponds to the value used in Sect. 2. The first element of the pair (l) is a label. At the beginning of a rewriting process, a new label composed of a unique identifier is associated to the value of each parameter of the axiom (the initial module serving as starting point for the rewriting process).

Updated Semantics.
Sem0, presented in Sect. 2.2, is updated in order to deal with labeled values and labeled terms. The identifiers contained in a term’s label refer to the parameters which have influenced the rewriting process so far. In order to compute this label, two new functions are introduced: var returns the set of all the variables contained in its argument; and ident returns the label (which is a set of identifiers) of its argument. For example, “var(x > y)” returns the set {x, y} and “ident(l : 3)” returns l. When rewriting a term T into the term S (l : T →R l' : S) a new label l' is generated. This new label is obtained by union of the previous label l and of a new label lc. lc is the union of the labels of all the parameters which have influenced the selection of the rewriting rule applied. Let us call Sem1 this new semantics. When rewriting the term “NT A(v) S ”, Sem1 applies the following rule:
first(R, A(v)) = A(p): c∗ ∧ c → T
lc =	x[ident(v)/p]
l : NT A(v) S	→R	l ∪ lc : NT eval(T [v/p]) S
This new semantics has lots of similarities with Sem0. It can easily be proved that, except for the new labels, both semantics rewrite a module to the same normal form. The proof relies on the fact that derivations in Sem0 and Sem1 are in 1-1 correspondence. With x a member of p, thus a parameter of the module whose identifier is A, and v the list of values applied to the list of parameters p of the module whose identifier is A, x[ident(v)/p] is the label of the value applied to the parameter of name x in the call A(v). Therefore lc is the union of the labels of the values which are used in the evaluation of c∗ ∧ c.
As in Sect. 2, the function eval evaluates all the expressions contained in its parameter. Those expressions are now composed of labeled values. The labeled value of a constant c is “∅ : c”. For the evaluation of expressions, the function eval uses the following rule:
x →e lx : nx	y →e ly : ny
(x op y)	→e	lx ∪ ly : fop(nx, ny)
fop is the function corresponding to the operator op. For example, if op is + then fop is the addition and fop(1, 2) is 3.

Properties of the Semantics.
The projection of a list of values v into another list of values w restrained by
l 		  l
the label l is denoted “v - w”. For all label l and lists of values v and w, v - w

if and only if any value whose label in v is a subset of l has the same numerical value in v and w. A formal definition of this relation follows. In this definition, [a | b] is the list resulting from the concatenation of a at the beginning of the list b. Additionally, in this definition, and the remaining of the paper, ⊥ is used in place of elements which are of no use for stating the definition. For example, as every value has a label, in “⊥ : y” ⊥ stands for the label of y; which however is not used in the definition. This projection will be used in the cache mechanism to determine if a result previously computed for a module can be reused. Assuming a previous

rewriting of A(v) has generated the term NT and the label l, if v -l
w then NT,

with some small modifications, can be used as the result of rewriting A(w).
Definition 3.2 (Projection Relation)
 lv	w if and only if one of the following is true:
v and w are empty list,

v = [lx : x | v'], w = [⊥ : y | '
'  l  '
/⊆ l.

Let A be a module name, v a list of values, T the term in which the module
A(v) is rewritten into one step, and l the label generated by this rewriting process.

Let w be a list of values such that v -l
w, and S the term in which the module

A(w) is rewritten into one step. Theorem 3.3 states that T and S have the “same structure”.
Theorem 3.3 (One step dependency) For all module name A, values list v, and set of rewriting rules R, if “⊥ : A(v) →R l : T” then, for all list of values w
such that v -l w, “ ⊥ : A(w) →	⊥ : S” with S ≡  T.
R	S
Proof (Sketch) Theorem 3.3 relies on the fact that the same rewriting rule is applied in both cases. It comes from the way the generated label is constructed. Indeed, all the parameters influencing the selection of the rewriting rule to apply to this module belong to the generated label. As a consequence, rewriting the same module, with parameters into which the original parameters project themselves, will apply the same rewriting rule. And then, it will return a term with the “same structure”.	 
Example 3.4 (Application of Theorem 3.3)
Using the FL-system described in example 2.2, one rewriting step on “la : A(l1 : 0, l2 : 2)” yields the term “la ∪ l1 : t(2)”. Therefore, Theorem 3.3 implies that, for
la∪l1 
any list of values w such that [l1 : 0, l2 : 2] - w (i.e. of the form [⊥ : 0, ⊥ : ⊥]),
one rewriting step on “⊥ : A(w)” yields a term having the same structure than t(2) (i.e. a single call to the primitive t but potentially with a different value as parameter).

Let →†
be the function mapping a term to the normal form obtained by the

reflexive transitive closure of →R. Corollary 3.5 is the generalization of Theorem 3.3 to →† .

Corollary 3.5 (Multi-step dependency) For all module name A, values list v,
and set of rewriting rules R, if “⊥ : A(v) →† l : NT” then, for all list of values w

such that v -l
w, “⊥ : A(w) →†
⊥ : NS” with NS ≡S NT.

Proof (Sketch) The proof goes by induction on the number of rewriting steps. For one rewriting step, this corollary is equivalent to Theorem 3.3. Otherwise, for the same reasons than for Theorem 3.3, the first rewriting step of both rewriting process uses exactly the same rule and gives back two terms (T and S ) with the exact same structure. If a parameter of a module appearing in T influences the structure of NT then its tag is a subset of l (it comes from the fact that a rewriting step only adds identifiers to the tag of the resulting term). If the tag of a parameter in T is a subset of l, it means that all the parameters (in v) which have been used to compute its value have the exact same numerical value in v and in w (because

of v -l
w). Then, as S has been constructed using the same rule than T , this

parameter has the same numerical value in T and in S . So, it is possible to use the inductive hypothesis on all the modules appearing in T in order to finish the proof.	 


Interpretation.
As exposed in the beginning of this section, the goal of this dynamic depen- dency analysis is to characterize a set of modules (S), as big as possible, which are structurally joinable with a given module (A(v)) which has just been rewritten into the term in normal form “l : NT”. Corollary 3.5 implies that any module A(w),

such that v -l
w, is structurally joinable with the module A(v). The triplet (A, v, l)

is then a valid characterization of the set S. Any module, whose name is A and
l
whose parameters w are such that v - w, will be rewritten in a term in normal
form which has the same structure than NT.
This property is useful for the main goal of this paper, which is to develop a cache for the rewriting process of FL-systems. For each module rewritten, Corollary 3.5 enables the cache system to characterize a set, potentially infinite, of modules for which it already knows the structure of the rewritten term in normal form. How- ever, this corollary does not help to determine the values of the parameters of the terminals contained in the term in normal form. This is the subject of the next subsection.

What about the Parameters?
The work presented above enables the cache system to characterize a set S of modules for which it is able to determine the structure of the term in normal form obtained by rewriting them. For FL-systems, the structure of a term in normal form is a sequence of calls to graphic primitives. For the cache system to be fully functional, it must also determine the values of the parameters of the terminals (or graphic primitives) contained in the term in normal form.

In an earlier version of this work [11] (in French), the method used to determine those values fixes the value of any parameter appearing in any expression during the rewriting process. As a consequence, it reduces the size of the set S, and then the power of the cache system. The only generalization achieved by this method concerns parameters which are just transferred from the original module to the graphic primitives. Even if this method is simple, a prototype for a forest of bushes as described in Example 2.1 and Fig. 2 has shown that the benefit of the early version of the FL-system Intelligent Cache (FLIC) can reach 25%.
The method presented in this paper uses symbolic execution [9]. This enables the cache system to express the values of the parameters of the terminals in the term in normal form, for the modules belonging to S, as an expression of the original parameters.

A New Semantics Making Use of Symbolic Execution.
In this part of the work, parameters of the axiom are replaced by a unique iden- tifier. Values are now expressions of identifiers and constants. A list of values (i.e.
a list of expressions) is written e. The label of a value is then the set containing all

the identifiers appearing in it (ident(e)= 

id∈e
{id}). Let Sem2 be the semantics

doing the same job as Sem1, but with values which are expressions of identifiers
and constant. When rewriting the term “NT A(e) S ”, Sem2 applies the following rule:
first(R, A(eval(e, σ))) = A(p): c∗ ∧ c → T
lc =	x[ident(e)/p])
l : NT A(e) S	→R	l ∪ lc : NT T [e/p] S
Compared to the semantics Sem1 (Sect. 3.1), there are only a few differences.
To rewrite an axiom A(v) with v a list of numerical values, the first step is to replace the numerical values used as parameters of A by some unique identifiers. The result is a module A(e) whose values are identifiers. A value store σ is then generated from e and v; it maps the ith element in e to the ith element in v. Rewriting A(e) with this value store generates a term in normal form NT whose values are expressions. Finally, the term in normal form resulting from A(v) is eval(NT, σ).
As values are now expressions, it is required to evaluate those expressions before using the function first. σ is a value store which maps the identifiers of the parameters of the axiom with their numerical value. The function eval is updated to take this store as a parameter and use it to evaluate the expressions appearing in its first parameter. The value of a constant is the constant itself, and the value of a variable id is σ(id). For expressions, the function uses the following rule:
σ ▶ x →e nx	σ ▶ y →e ny σ ▶ (x op y) →e fop(nx, ny)

The identifiers added in the label of the resulting term (lc) are mostly computed as in Sem1. The only “difference” is that the function ident now collects all the identifiers occurring in an expression, instead of extracting the label of a labeled value (as in Sem1).
As in Sem1, the module rewritten is replaced by the term given by the rewriting rule. The parameters in this term are replaced by their “value” in the module rewritten. However, with Sem1 the expressions obtained are evaluated, with Sem2 the expressions obtained (which are expressions of identifiers) are not evaluated and are now considered “values”.

Properties of the New Semantics.
As in Sem1, the rewriting process of a module A(v) returns the characterization of a set of modules S and a term in normal form NT (values in this term are expressions of identifiers). To get the final term in normal form with numerical values, the function eval is called on NT with the value store which maps the identifiers of the parameters of A to their respective value in v. In fact, as shown by Corollary 3.8, for any module in S with values w, the only thing to do to get the rewritten term is to call the function eval on NT with the value store which maps the identifiers of the parameters of A to their respective value in w.
Let zip be the function labeling the values in the first list with the identifiers in the second (i.e. zipping two lists). For example, zip([1, 2], [x, y]) is the list [{x} : 1, {y} : 2]. Let σe,v be the store mapping the ith element in e to the ith element in v.
Theorem 3.6 (One step rebuilt) For all module name A, numerical values list v, identiﬁers list e such that v and e have the same size, and set of rewriting rules R, if, with the value store σe,v,“ ⊥ : A(e) →R l : T ” then for all list of numerical

values w, such that zip(v, e) -l
yields the term T.
zip(w, e), rewriting A(e) with the value store σe,w

Proof (Sketch) Theorem 3.6 comes from the way the generated label is con- structed. Indeed, all the parameters influencing the selection of the rewriting rule to apply to a module to be rewritten belong to the generated label. As a conse- quence, rewriting the same module, with parameters into which the original pa- rameters project themselves, will apply the same rewriting rule and then the same operations on the parameters. As there is no numerical evaluation of the values the two terms obtained are the same.	 
Example 3.7 (Application of Theorem 3.6)
Using the FL-system described in example 2.2 with Sem2, one rewriting step on “la : A(m, n)” with the value store [m '→ 0,n '→ 2] yields the term “la ∪ {m} : t(n)”.
Therefore, Theorem 3.6 implies that, for any list of numerical values w such that
la∪{m}	
[{m} : 0, {n} : 2]	-	zip(w, [m, n]) (i.e. of the form [0, ⊥]), one rewriting step
on “⊥ : A(e)” with the value store σ[m,n],w yields the exact same term t(n).

Corollary 3.8 (Multi-step rebuilt) For all module name A, numerical values list v, identiﬁers list e such that v and e have the same size, and set of rewriting

rules R, if, with the value store σe,v, “ ⊥ : A(v) →†
l : NT” then for all list of

values w, such that zip(v, e) -l  zip(w, e), rewriting A(e) with the value store σe,w
yields the term in normal form NT.
Proof (Sketch) This corollary follows directly from Theorem 3.6 by doing an induction on the number of rewriting steps.	 
The main difference between Corollary 3.8 and Corollary 3.5 is that for Corol- lary 3.5 only the structure of the two final term in normal form are identical, whereas for Corollary 3.8 the two final term in normal form are exactly identical.

Application to an FL-system’s Cache
As expressed before, the work presented in this paper aims at developing an efficient cache mechanism for FL-systems. In order to achieve more efficiency, not only the main rewriting process is cached, but also are all the sub-processes. With the small steps semantics presented earlier only the main rewriting process can be cached. The sub-processes are not explicit. To be able to formalize the cache system, the semantics Sem2 (Sect. 3.2) is rewritten as a big steps semantics in Fig. 3. Let us
call Sem3 this big step semantics. The function →†  is the restriction to a range
belonging to the normal form terms of the reflexive transitive closure of →R.

This semantics uses an environment variable called σ. As previously, σ is a value store. It maps the variables in the term undergoing the rewriting process to their numerical value. The first rule states that a term already in normal form is rewritten into itself. The label generated by this rewriting step is empty. In the second rule, the left-most module is rewritten first and the selection of the rewriting rule to apply is done as in Sem2. var collects the parameter names appearing in its argument. Therefore, the parameters influencing the selection of the rewriting rule are given by lc. This label is expressed using parameters in p. Before including this label in the label of the final term in normal form, lc has to be translated in a label expressed using parameters appearing in e. This is done by applying the substitution: l[ident(e)/p]∪. This substitution replaces each parameter name (pi)

in l by its corresponding set (ident(ei)); and finally flattens the set of sets obtained. The term on the right side of the rewriting rule (T ) is rewritten in normal form in NT. T is expressed using the parameters in p. Its rewriting process has then to use a new value store mapping the parameters in p to their numerical value. This is done by mapping the parameter at position i to the numerical value obtained by evaluating the value at position i in e using the previous value store (σ). In order to express the parameters of the primitive calls in NT in function of the initial parameters, the parameters belonging to p in NT are replaced by the value (i.e. expression of identifiers) at the same position in e (NT[e/p]). That rewriting process generates the label lt. This label has to follow the same treatment as lc for the same reason. The term at the right of the left-most module (R) is also rewritten in a term in normal form (NR). This rewriting process generates the label lr. This label is already expressed using the parameters appearing in e; so it can be directly included in the label of the final term in normal form. This term is obtained by replacing A(e) and R by their respective normal form rewritten term.
This semantics returns exactly the same result than Sem2. However, with this semantics, the complete rewritings of sub-processes are explicit. In Fig. 3, the main term rewritten is eval(NS A(e) R, σ). The rule shows explicitly the final result of the sub-process rewriting the module eval(A(e), σ); the resulting term in normal form is eval(NT, σ). It is then possible, during the execution of the main rewriting process, to add in the cache a pair (key, value) linking eval(A(e), σ) to eval(NT, σ). The next subsection exposes the method to generate a generic key mapping some modules structurally joinable with eval(A(e), σ) and the associated value.

Generation and Usage of Keys and Values
Generation of pairs (key ,value) to be inserted into the cache.
First, let us introduce a function used for the generation of the keys. gen takes as parameters a list of numerical values (n), a same length list of parameter names p (considered as identifiers), and a label l (i.e. a list of identifiers). It returns a list of numerical values with wild-cards (#1..#n). The element at position i in the result is ni (the element at position i in n) if and only if pi ⊆ l, otherwise it is the wild-card #i. For example, gen([1, 2, 3], [x, y, z], {x, y}) returns [1, 2, #3].
Let us consider the caching of the result NT of the rewriting of A(e) with the value store σe,n where e is a list of identifiers. We assume that this rewriting process generated the label l. The key used for caching is a module whose identifier is A and parameters are gen(n, e, l). The value is the term NT where identifiers appearing in e are replaced by #i where i is the position of this identifier in e. Assume that # is the following list of arbitrary length n: [#1, #2,... , #n]. The value associated to the key is NT[#/e].
Example 4.1 (Generating a cache entry) Using the FL-system described in exam- ple 2.2, rewriting A(m, n) with the value store [m '→ 0,n '→ 2] yields the term in normal form t(n) and label {m}. Therefore the pair added in the cache for this rewriting process is (A(0, #2), t(#2)).

Usage of pairs (key ,value) appearing in the cache.
We first define a concretization relation among lists of elements belonging to R ∪  i∈R #i. A list nc is a concretization of an other same length list na if and only if any element belonging to R in na is equal to the element at the same position in
nc. It can also be seen as the formalization that nc is an “instance” of na (with #i denoting variables, as in Prolog). It is denoted nc > na. A formal definition of this relation follows.
Definition 4.2 (Concretization relation)
nc > na is true if and only if one of the following is true:
nc and na are empty list,
nc =[ x | mc ], na =[ y | ma ], mc > ma, and x = y or y ∈/ R.

Let e be a list of size s of expressions of identifiers, i be a list of size s of identifiers and n be a list of size s of real numbers. Before starting the rewriting process for the module A(e) with the value store σi,n, the cache system checks if there exists a pair (A(na), NT) such that eval(e, σi,n) > na. If that is the case, then the cache mechanism returns directly the term in normal form NT[eval(e, σi,n)/#]. This term is the result which would have been obtained by executing all the rewriting process for A(eval(e, σi,n)).
Example 4.3 (Using a cache entry) If the cache contains a pair (A(0, #2), t(#2)), it means that whenever rewriting the module whose name is A with a first parameter equal to 0, and whatever value as second parameter, the final term in normal form is the terminal t with the value of the second parameter of A as argument. For example, the rewriting process of A(0, 2) should return t(2).

Conclusion
In this paper, we presented an intelligent cache mechanism called FL-system intel- ligent cache (FLIC). This mechanism is based on a dynamic dependency analysis and on symbolic execution. This new cache mechanism for FL-systems enables to take more benefit from the high level of redundancy which appears in relatively large virtual environments. The reuse of geometric objects, which has to be made explicit with standard methods, is partially automatic and implicit with the FLIC. This cache is more efficient than a simple cache due to the higher generality of the pairs (key, value) generated with our method. It is then possible to get from the cache the rewritten form of a module which has never been rewritten. This rewrit- ten form is obtained by instantiation of a value whose key is “sufficiently similar” to the module to rewrite.
To the best of our knowledge, except for [2], there is no equivalent work. The authors of [2] use similar methods to achieve similar goals in the λ-calculus. Their cache maps λ-terms to their normal form value. The main differences with our work are, first, that the context is slightly different; and that the values in our cache are not normal form values, but generalizations of normal form terms. This general-

ization enables our cache to be more efficient. In computer graphics, there exist few works aiming at similar goals. It is frequent to try to reuse geometric objects already defined somewhere else. The two main motivations for this are to reduce the size of the model and to enhance the efficiency of the rendering. For example, Hart[6] proposed the instantiation of geometric objects which is now integrated in the majority of geometric modeling languages (e.g. VRML[13]). In the area of natural environments modeling, Deussen et al. [5] propose the approximate instan- tiation as an extension of Hart’s instantiation paradigm. Procedurally generated objects are grouped in clusters in function of the values of their parameters. For each cluster, only one geometric object is generated. This object is used as the approximate instance of all the procedurally generated objects belonging to that cluster. This method reduces the number of objects in the environment (each ob- ject can be reused plenty of times in the same environment). However, it brings approximation. This approximation is minimized by assuming, without checking it, that two procedurally generated objects having similar parameters generate similar geometric objects. In our opinion, the FLIC is an optimization complemental to the approximate instantiation. Use of Deussen’s technique on the key generated by the cache mechanism would increase the precision of the approximate instantiation and allow the environment generation to benefit from both techniques. In the context of 3D tree computation, Kang et al. [8] propose the creation of a library of random substructure instances randomly assembled at plant level in order to speed up the generation of plant topology without altering the visual realism of the simulated trees. In their work, the plant is explicitly described as an assembly of substruc- tures, whereas in this paper, reuse of substructures is automatically deduced by the rewriting mechanism.
The cache mechanism proposed in this paper is under integration into a virtual environment generation platform. This platform is already under development and partially functional (Fig. 2 has been generated using this platform). It will be used to test the benefit given by the symbolic evaluation. It will also serve to fine tune some of the features of the cache mechanism; for example, the management of the pairs (key, values) by the cache. Future work will involve exploring the complementarity of the cache mechanism and the approximate instantiation, as well as fine tuning the cache mechanism in order for the platform to take the most benefit from it.
Acknowledgement
The authors are grateful to the reviewers and Thomas Genet for their insightful and helpful comments.

References
Abadi, M., A. Banerjee, N. Heintze and J. G. Riecke, A core calculus of dependency, in: Proc. Principles of Programming Languages, 1999, pp. 147–160.
Abadi, M., B. Lampson and J.-J. L´evy, Analysis and caching of dependencies, in: Proc. Functional Programming (1996), pp. 83–91.

Baader, F. and T. Nipkow, “Term Rewriting and All That,” Cambridge University Press, 1998.
Dershowitz, N. and J.-P. Jouannaud, Rewrite systems, in: J. van Leeuwen, editor, Handbook of Theoretical Computer Science, Volume B: Formal Models and Semantics, Elsevier Science, Amsterdam, 1990 pp. 243–320.
Deussen, O., P. Hanrahan, B. Lintermann, R. Mˇech, M. Pharr and P. Prusinkiewicz, Realistic modeling and rendering of plant ecosystems, in: Proc. Computer Graphics and Interactive Techniques (1998),
pp. 275–286.
Hart, J. C., The object instancing paradigm for linear fractal modeling, in: Proc. Graphics Interface
(1992), pp. 224–231.
Hartman, J. and J. Wernecke, “VRML 2.0 Handbook, The: Building Moving Worlds on the Web,” Addison Wesley Professional, 1996, 1 edition.
Kang, M., P. De Reffye, J. Barczi, B. Hu and F. Houllier, Stochastic 3d tree simulation using substructure instancing, in: Proceedings of the International symposium on plant growth modeling, simulation, visualization and their applications (2003), pp. 154–168.
King, J. C., Symbolic execution and program testing., Commun. ACM 19 (1976), pp. 385–394.
Le Guernic, G. and T. Jensen, Monitoring information flow, in: A. Sabelfeld, editor, Proc. Workshop on Foundations of Computer Security (2005), pp. 19–30, lICS’05 Affiliated Workshop.
Le Guernic, G. and J. Perret, FL-system’s Intelligent Cache, in: A. Vautier and S. Saget, editors, Proc. MajecStic, Rennes, France, 2005, pp. 79–87.
Lindenmayer, A., Mathematical models for cellular interactions in development, I & II, Journal of Theoretic Biology 18 (1968), pp. 280–315.
Marrin, C., R. Carey and G. Bell, A VRML specification, Technical report, VRML consortium (1997), http://www.vrml.org/Sprecifications/VRML97.
Marvie, J.-E., J. Perret and K. Bouatouch, The FL-system: A functional L-system for procedural geometric modeling., The Visual Computer 21 (2005), pp. 329–339.
Prusinkiewicz, P., A. Lindenmayer, J. S. Hanan et al., “The algorithmic beauty of plants,” Springer- Verlag, New York, 1990.
Prusinkiewicz, P., L. Mundermann, R. Karwowski and B. Lane, The use of positional information in the modeling of plants, in: Proc. Computer Graphics and Interactive Techniques (2001), pp. 289–300.
Pugh, W. and T. Teitelbaum, Incremental computation via function caching, in: Proc. Principles of Programming Languages, 1989, pp. 315–328.
Shreiner, D., “OpenGL Reference Manual: The Official Reference Document to OpenGL,” OpenGL, Addison Wesley Professional, 2004, 4 edition.
