

Electronic Notes in Theoretical Computer Science 264 (2010) 69–84
www.elsevier.com/locate/entcs

Model Testing Asynchronously Communicating Objects using Modulo AC Rewriting
Olaf Owe, Martin Steffen, and Arild B. Torjusen
Department of Computer Science, University of Oslo, Norway

Abstract
Testing and verification of asynchronously communicating objects in open environments are challenging due to non-determinism. We explore a formal approach for black-box testing by proposing an interface specification language that gives an assumption-commitment style description of an object’s behavior. The approach is applied to Creol objects. Creol is a high-level, object-oriented modelling language, hence we do model-based testing of behavioral models. The testing is done by synchronising execution of a specification and the component under test. Due to the asynchronous nature of communication, testing should be done up-to observational equivalence. This leads to a large increase in the reachable state space for the test cases. We reduce the state space by using facilities for rewriting modulo AC (associativity and commutativity) built into the rewriting logic system Maude, and explore the state space by breadth first search. We present experimental results that show the usefulness of this approach.
Keywords: Testing and verification, asynchronous method calls, active objects, rewriting logic, formal semantics.


Introduction
Systematic testing is indispensable to assure reliability and quality of software and systems. Hosts of different testing approaches and frameworks have been proposed and put to (good) use over the years. Formal methods and program language theory have proven valuable to render testing practice a more formal, systematic discipline (cf. e.g. [16,2]). Formal approaches to testing have gained momentum in recent years, as for instance witnessed by the trend towards model-based testing [12,4]. In previous work [19] we presented a formal approach for black-box specification- based testing of asynchronously communicating components in open environments

٨ Part of this work has been supported by the EU-project IST-33826 Credo: Modeling and analysis of evolutionary structures for distributed services, HATS: Highly Adaptable and Trustworthy Software us- ing Formal Methods (http://www.hats-project.eu), and the German-Norwegian DAAD-NWO exchange project Avabi (Automated validation for behavioral interfaces of asynchronous active objects).

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.12.015

together with an implementation of a testing framework. In this paper we show how to extend the approach to veriﬁcation of components and present experimental results that show the usefulness of our approach.
We do this in the context of Creol [11,27], a high-level, object-oriented modelling language for distributed systems. Object-orientation is a natural choice, as object modelling is the fundamental approach to open distributed systems as recommended by RM-ODP [24]. For such systems an asynchronous communication model is advantageous as it decouples caller and callee thus avoiding unnecessary waiting for method returns. On the downside, asynchronicity makes verifying and testing models more challenging. In an asynchronous system, communication delays due to the network or to queuing may lead to message overtaking and the resulting non-determinism leads to a state space explosion.
It is generally accepted that the way to tackle complex systems is to “divide-and- conquer”, i.e., consider components interacting with their environment. Abstracting from internal executions, the black-box behavior of Creol components is given by interactions at their interface. We use a concise language over communication labels to specify components and the expected behavior of a component is given as a set of traces at the interface. Both input and output interactions are specified but play quite different roles. As input events are not under the control of the object, in- put is considered as assumptions about the environment whereas output describes commitments of the object. This separation of concerns between interaction un- der the control of the component and coming from the environment leads to an assumption-commitment style specification of a component’s behavior by defining the valid observable output behavior, assuming a certain scheduling.
For input interactions, we ensure that the specified assumptions on the environ- ment are fulfilled by scheduling the incoming calls in the order specified, while for output events, which are controlled by the component, we test that the events occur as specified. Scheduling and testing of a component are done by synchronizing the component’s execution with the specification. As a result, the scheduling is enforced in the execution of the component and the actual outgoing interactions from the component are tested against the output events in the specification. This gives a framework for testing whether an implementation of a component conforms with the interface specification. Incorrect or nonconforming behavior of the component under a given scheduling is reported as an error by the testing framework.
Due to message delays and overtaking, the order in which outgoing messages from a component are observed by an external observer does not necessarily reflect the order in which they were actually sent. Testing is based on behavior observable at the interface, and the order of outgoing communication should therefore not affect the test results. The operational semantics of the specification language takes the asynchronous nature of the communication model into consideration by treating certain reorderings of output events as observationally equivalent, and testing is done up-to observational equivalence.
Reordering of output events can be expressed by defining sequences of out- put events as associative and commutative. We argue that our testing framework

is especially well suited to implement this since, using the rewriting logic system Maude, associativity and commutativity can be declared using equational attributes
[9] which allows efficient evaluation of such specifications.
This paper extends [19] which introduced and gave the formal basis for the approach to testing that we explore further here, the main contributions are:
Verification We provide an implementation in the rewriter Maude and use Maude’s search functionality for state exploration (for rewriting modulo AC) for verifica- tion of components and investigate how the support for AC reasoning built in into Maude contributes to state space reduction in verification of asynchronously communicating components.
Experimental results We present experimental results from using the Maude rewriting tool which give empirical evidence of the benefits of our method. We compare, in two series of experiments, the influence on the state space of us- ing Maude’s built in AC support against explicit representation of all possible reorderings of output events. Using AC rewriting may considerably reduce the resource consumption when testing asynchronously communicating objects. AC rewriting significantly pays off in terms of time and the number of rewrites.
We review the formalisation of Creol in Sect. 2, some technicalities from the pre- vious paper are repeated when necessary. The corresponding behavioral interface specification language and an explanation of how this is used for testing are given in Sect. 3. In Sect. 4, we describe the executable implementation of the theory. The experimental results are in Sect. 5.



The Creol modeling language

We formalise Creol, a high-level, object-oriented modelling language for distributed systems, Creol features active objects and asynchronous method calls.
In contrast with object-oriented languages based on multi-threading, such as Java or C #, the language features active objects. The unit of activity is the ob- ject; every process belongs to an object, and activity does not cross object borders. Communication is based on exchanging messages asynchronously, and is asymmet- ric in the sense that there are linguistic means to send a message, but not to accept a message: objects are always input-enabled. On the callee side of a method call therefore each object possesses an input “queue” in which incoming messages are waiting to be served by the object. To avoid uncontrolled interference, each object acts as a monitor ; at most one method body is executing at each point in time. By default the choice of which method call in the input queue that enters the ob- ject next is non-deterministic. After the abstract syntax, we sketch the operational semantics, concentrating on the external behavior, i.e., the message exchange with the environment.

C ::= 0 | C  C | ν(n:T ).C | c[(F, M )] | o[c, F, L] | n⟨t⟩	component
F ::= l = f, .. ., l = f	fields
M ::= l = m, . .., l = m	method suite
m ::= ς(n:T ).λ(x:T, ... , x:T ).t	method
f ::= ς(n:T ).λ().v | ς(n:T ).λ().⊥n'	field
t ::= v | stop | let x:T = e in t	thread
e ::= t | if v = v then e else e | if undef (v.l()) then e else e	expr.
|  v@l(v) | v.l(v) | v.l() | v.l := ς(s:T ).λ().v
| new n | claim@(n, n) | get@n | suspend(n) | grab(n) | release(n)
v ::= x | n | ()	values
L ::= ⊥ | T	lock status
Table 1 Abstract syntax


Syntax
The abstract syntax, in the style of standard object calculi, is given in Tab. 1. Names n represent references to classes, to objects, and to threads. To facilitate reading, we allow ourselves to write o and its syntactic variants for names referring to objects, c for classes, and n when being unspecific. A component C is a collection of classes, objects, and (named) threads, with 0 representing the empty component. The sub-entities of a component are composed using the parallel-construct . The entities executing in parallel are the named threads n⟨t⟩, where t is the code being
executed and n the name of the thread. The name n of the thread is at the same
time the future reference under which the result value of t, if any, will be available. In this paper we restrict ourselves to the situation where the component consists of one object only, plus arbitrary many threads. A class c[(F, M )] carries a name c and defines its fields and methods in F and M . An object o[c, F, L] with identity o keeps a reference to the class c it instantiates, stores the current value F of its fields, and maintains a binary lock L indicating whether any code is currently active inside the object (in which case the lock is taken) or not (in which case the lock is free). The symbols T and ⊥ indicate that the lock is taken or free respectively.
The named threads n⟨t⟩ are incarnations of method bodies “in execution”. Each thread belongs to one specific object “inside” which it executes, i.e., whose instance
variables it has access to. Built in object locks are used to rule out unprotected concurrent access to the object states: Though each object may have more than one method body incarnation partially evaluated, at each time point at most one of those bodies (the lock owner) can be active inside the object. The ν-operator is used for hiding and dynamic scoping, as known from the π-calculus.
Besides components, the grammar specifies the lower level syntactic constructs, in particular, methods, expressions, and (unnamed) threads, which are basically sequences of expressions. The further expressions claim, get, suspend, grab, and release deal with synchronization. They take care of releasing and acquiring the lock of an object appropriately. All of the features and their representation is pretty standard and (apart from the communication via method calls) not visible at the interface, we omit further details here and refer to the technical report [20].

Operational semantics
The operational semantics of a program being tested is given in two stages: steps
internal to the program, and those occurring at the interface.
The internal rules deal with steps not interacting with the object’s environment, such as sequential composition, conditionals, field look-up and update, etc. The rules are standard and we omit them here. More interesting and relevant are the “external” rules which describe the interaction of a component with its environ- ment, by exchanging communication labels. The communication labels, the basic building blocks of the interface interactions, are given in Tab. 2. A component or object exchanges information with the environment via call - and return-labels, and the interactions is either incoming or outgoing (marked ? resp. !). The label n⟨call o.l(v)⟩ represents a call of method l in object o. In that label, n is a name
identifying the thread that executes the method in the callee and is therefore the
(future) reference under which the result of the method call will be available (if ever) for the caller. The incoming label n⟨return (v)⟩? hands the value from the corresponding call back to the object, which renders it ready to be read. Its coun- terpart, the outgoing return, passes the value to the environment. Besides that,
labels can be prefixed by bindings of the form ν(n:T ) which express freshness of the transmitted name, i.e., scope extrusion. .
The interface behavior is given by rules as those of Tab. 3 (we show 2 of the four rules, dealing with incoming communication, the missing 2 for outgoing com- munication are similar). The external steps are given as transitions of the form
Ξ ▶ C −→a  Ξ´ ▶ C´, where Ξ and Ξ´ represents the assumption/commitment contexts
of C before and after the step, respectively. In particular, the context contains the
identities of the objects and threads known so far, and the corresponding typing information. This information is checked in incoming communication steps, and up- dated when performing a step (input or output). These two operations are captured by the following notation
Ξ ▶ a : T   and   Ξ + a	(1)
which constitute part of the rule premises in Tab. 3. Intuitively, they mean the following: label a is well-formed and well-typed wrt. the information Ξ and refers to an asynchronous call which results in a value of type T . The right-hand notation of (1) extends the binding context Ξ by the bindings transmitted as part of label a appropriately. For lack of space, we omit the formal definitions here. Intuitively, they make sure that only well-typed communication can occur and that the context is kept up-to date during reduction. Rule CallI deals with incoming calls, and

γ ::= n⟨call n.l(v)⟩ | n⟨return(n)⟩ | ν(n:T ).γ	basic labels
a ::= γ? | γ!	input and output labels
Table 2
Structured communication labels



a = ν(Ξ′). n⟨call o.l(v)⟩? Ξ ▶ a : T	Ξ´ = Ξ + a

CallI

Ξ ▶ C  o[c, F, ⊥] −→a Ξ´ ▶ C  o[c, F, T]  n⟨let x:T = M.l(o)(v) in release(o); x⟩

a = ν(Ξ′). n⟨return (v)⟩?	Ξ ▶ a : ok
Ξ´ = Ξ + a

RetI

a ´
Ξ ▶ C −→ Ξ ▶ C  n⟨v⟩

Table 3 External steps

basically adds the new thread n (which at the same time represents the future reference for the eventual result) in parallel with the rest of the program. The notation M.l(o)(v) represents the parameter passing of the actual values to the method body t, where s is the “self”-parameter, which is substituted by the identity

o of the callee. We write Ξ1 ▶ C1 =⇒t
Ξ2 ▶ C2 if Ξ1 ▶ C reduces in a number of

internal and external steps to Ξ2 ▶ C2, exhibiting t as the trace of the external
steps.

A behavioral interface specification language
The behavior of an object in a particular execution is, at the interface, described by a sequence of labels as given by Tab. 2. The black-box behavior of an object can therefore be described by a set of traces, each consisting of a finite sequence of labels. This would be the same also for a component consisting of a set of objects, for that matter. To specify sets of label traces, we employ a simple trace language with prefix, choice and recursion. Table 4 contains its syntax. The syntax of the labels in the specification language, naturally, quite resembles the labels of Tab. 2. Comparing Tabs. 2 and 4, there are two differences: first, instead of names or references n, the specification language here uses variables. Second, the labels here allow a binding of the form (x:T ).γ, which has no analog in Tab. 2; the form ν(x:T ).γ corresponds to ν(n:T ).γ, of course. Both binding constructs act as variable declarations, with the difference that ν(x:T ).γ not just introduces a variable, but in addition asserts that the names represented by that variable must be fresh. The binding (x:T ).γ corresponds to a conventional variable declaration, introducing the variable x which represents arbitrary values.
The grammar given in Tab. 4 allows to specify sets of traces. Not all specifica- tions, however, are meaningful. We rule out ill-formed specifications by introducing

γ ::= x⟨call x.l(x)⟩ | x⟨return(x)⟩ | ν(x:T ).γ | (x:T ).γ   basic labels
a ::= γ? | γ!	input and output labels
ϕ ::= X | ϵ | a . ϕ | ϕ + ϕ | rec X.ϕ	specifications
Table 4 Specification language

restrictions on: typing: Values handed over must correspond to the expected types for that methods; scoping: Variables must be declared before their use; and com- munication patterns: No value can be returned before a matching outgoing call has been seen at the interface. In addition we take care to consider the polarity of the specification. In the specification, it is important to distinguish between input and output interactions, as input messages are under the control of the environment, whereas the outputs are to be provided by the object as specified. This splits the specification into an assumption part under the responsibility of the environment, and a commitment part, controlled by the component. To specify non-deterministic behavior, the language supports a choice operator, and we distinguish between choices taken by the environment—external choice—and those the object is respon- sible for—internal choice. Especially, we do not allow so-called mixed choice. Cf.
[20] for details about the formalization of these restrictions, presently just note that
it is required that specifications are well-formed, and Ξ ▶ ϕ : wf p stands for the corresponding judgment. The metavariable p (for polarity) stands for either ?, !, or
?!, where ?! indicates the polarity for an empty sequence or for a process variable, and ? and ! indicate well-formed input and output specifications respectively.

Observational blur
Creol objects communicate asynchronously and the order of messages might not be preserved during communication. The order observed by an external observer or tester does not necessarily reflect the order in which the messages were sent, there- fore an observed “wrong” order of communication should not be taken to be an error and we must relax the specification up-to some appropriate notion of observational
equivalence, denoted by ≡obs and defined by the rules of Tab. 5. Note that the pur- pose is not to reconstruct some “correct” order of communication. When testing a component, we control the communication, the test specification and framework plays the role of both environment (generating input to the CUT) and observer
(controlling output), but want to retain the external perspective in order to test up-to observability. When testing a given object, we specify the order in which the inputs are consumed by the object, rather than the time they have been generated. In this way we specify the input scheduling of the object, which makes our speci- fications more expressive than in the case of blurring input. At the same time, we specify the outputs of the object as seen from the environment. We therefore blur the output, but not the input. This setting allows synchronous parallel composition. Input blur may be beneficial in other settings, and has e.g. been applied in a rea- soning system [14] for Creol based on Hoare logic. In the presented compositional reasoning system, message generation is considered observable, but not messages consumption. Hence, in that system, input is blurred, but not output.
Rule Eq-Switch captures the asynchronous nature of communication, in that the order of outgoing communication does not play a role. Rule Eq-Plus allows to distribute an output over a non-deterministic choice. Rule Eq-Rec expresses the standard unrolling of recursive definitions. The operational semantics of the specification language is straightforward reduction.





ν(Ξ) . γ1! . γ2! . ϕ ≡obs ν(Ξ) . γ2! . γ1! . ϕ 
▶ (ϕ1 + ϕ2): wf !
Eq-Switch



γ! . (ϕ1 + ϕ2) ≡obs γ! . ϕ1 + γ! . ϕ2
Eq-Plus
rec X.ϕ ≡obs ϕ[rec X.ϕ/X]
Eq-Rec


Table 5 Observational equivalence



τ	´	a ´
▶ a .σ b
´	b ´

Ξ ▶ C −→ Ξ ▶ C
Par-Int
Ξ1 ▶ C −→ Ξ1 ▶ C	Ξ1 ▶ ϕ −→ Ξ2 ▶ ϕ´
Par

Ξ ▶ C  ϕ −→ Ξ ▶ C´ ϕ
Ξ1 ▶ C ϕ −→ Ξ´1 ▶ C´
ϕ´σ

Ξ ▶ ϕ : wf ?
Err-Call
Ξ ▶ ν(Ξ ).(C  n⟨let x:T = o.l(v) in t⟩  ϕ) −→ 
Ξ ▶ ϕ : wf ?
′

Err-Ret

	


Table 6 Parallel composition
Ξ ▶ ν(Ξ ).(C  n⟨v⟩  ϕ) −→ 


Asynchronous testing of objects
Table 6 defines the interaction of the interface specification, ϕ, with the component, basically by synchronous parallel composition. Both ϕ and the component must engage in corresponding steps, which, for incoming communication schedules the order of interactions with the component whereas for outgoing communication the interaction will take place only if it matches an outgoing label in the specification and an error is raised if input is required by the specification. The component can proceed on its own via internal steps (cf. rule Par-Int). Rule Par requires that, in order to proceed, the component and the specification must engage in the “same” step, where ϕ’s step b is matched against the step a of the component. Here
▶ a .σ b states that there exist a substitution σ such that the label a produced by the component and the label b specified by the interface description can be matched. Note that after a successful application of the Par rule, variables in the specification may have been substituted with concrete values. We omit the details
of the matching and refer to the technical report [20]. The rules Err-Call and Err-Ret report an error if the specification requires an input as the next step and the object however could do an output, either a call or a return. In the rule indicates the occurrence of an error. Note that the equivalence relation, according to the rule Eq-Switch, allows the reordering of outputs, but not of inputs.

A specification-driven interpreter for Creol
The operational semantics of Creol is formalized in rewriting logic [31] and exe- cutable on the Maude rewriting engine [8], this gives an interpreter for Creol. Our

executable framework for testing Creol components includes: the specification lan- guage formalized in rewriting logic and a modified version of the Creol interpreter. We obtain a speciﬁcation-driven interpreter for testing by synchronizing the com- munication between specification terms and objects. Input to the component is generated non-deterministically within the bounds of the specification, and at the same time it is tested that the output behavior of the object conforms to the spec- ification, the internal activity is unmodified compared to the standard interpreter. The default behavior for Creol is to place incoming method calls into the callee’s input queue from which calls are non-deterministically selected for execution. For the specification-driven interpreter if an incoming call is specified and the lock of the object is free the corresponding method code should start executing immedi- ately. In the implementation the incoming messages are generated directly from the specification.
Standard simulation of a Creol model in Maude is achieved by rewriting an in- tial model configuration together with the interpreter. Maude’s search command may also be used to search for specific result configurations. For testing a compo- nent, instead of using the initial configuration as input, we extract from the model one object and its class definitions. This becomes the component under test (CUT). The CUT, its specification and the modified interpreter is then rewritten by Maude. Thus specific behavioral properties of selected objects from a large model may be tested. A standard Creol state configuration (Cfg) is a multiset of objects, classes, and messages and the Maude rewrite rules for transitions are of the form rl Cfg => Cfg’. For the specification-driven interpreter, we introduce terms Spec for specifi- cations and add rules on the form (Spec || O) Cfg => (Spec’ || O’) Cfg’ to test the object O with respect to Spec, where || represents the synchronous parallel composition. Each rule evolves the state of a specification and the state of an object in a synchronized manner: an interaction only takes place when it matches a com- plementary label in the specification. E.g., the Par rule in Tab. 6 is implemented by several Maude rules for the different kinds of communication events that may occur. We refer the reader to [19] for some examples.
In the implementation, we define associative and commutative (AC) output pre- fixes by declaring the prefix operator to be AC in the cases where an output label is prefixed to an output specification. Together with a Maude rule that imple- ments distribution over choice (the rule Eq-Plus above), this enables the testing framework to do testing up-to observational equivalence.

Experimental results
This section describes two series of experiments, using the implementation sket- ched in the previous section. The experiments demonstrate the usefulness of the approach: using AC rewriting may considerably reduce the resource consumption, when testing asynchronously communicating objects. AC rewriting significantly pays off in terms of time and the number of rewrites. With regards to the state space, the effects are not so definite.

The first example is tailor-made to show the effects for a simple component. The second example is an abstracted version of the “loan quote example” known from the area of enterprise application integration [23]. The examples also illustrate how to use the interface specification language for testing component behavior and how to employ model checking via the search command of Maude to also achieve veriﬁcation of a component with a trace specification. When using the search command, Maude not just explores one trace, but explores the set of behaviors given by the component together with the interface trace description. That the system in general explores a set of traces, as opposed to just one, has the following reasons: first, exploring a trace (trivially) means exploring all prefixes; that, of course, does not only apply to using Maude’s search, but to simple rewriting as well. Second, the specification may contain non-determinism (besides the fact that also the component may behave non- deterministically). Finally, and most important in our context, one trace is always meant up-to the “observational blur”, as specified in Tab. 5.
To measure the effect of AC rewriting, both series of experiments are carried out two times, either with AC rewriting switched on, or else off. When AC equivalence on the specification is switched off, we use an equivalent but expanded version of the specification to compare the results.
In the first example, the component under test consists of one object with n methods m1 through mn. The specification prescribes that all methods must have been called before any method may return. In Creol this is implemented by com- bining processor release points and await guards [27]. The behavioral specification for 3 methods reads:
ϕc3 = n1⟨call c.m1(x1)⟩? . n2⟨call c.m2(x2)⟩? . n3⟨call c.m3(x3)⟩? .
(n1⟨return (y1)⟩! . n2⟨return (y2)⟩! . n3⟨return (y3)⟩!) . ϵ 
A test is executed by giving the Maude command: rew (ϕc3 || c) cClass ., where c represents the Creol object. Maude rewrites the configuration, either re- sulting in an error reported when the component is about to execute an unspecified output, or stopping when no more rules apply. In the latter case, if the original specification is fully consumed this gives evidence that the component conforms to the specification, in the sense that test execution of c only leads to output foreseen by the specification ϕc3. This conformance relation is similar to the input-output conformance relation (ioco) of [35].
Definition 5.1 Let out(ϕ after t) represent the set of all possible output events that is specified by ϕ after execution of the trace t. Let out(c after t) represent the set of possible output events for the component c after execution of t. Let traces(ϕ) be the set of traces that the specification designates. Our conformance relation conf is defined as follows:
c conf ϕ ⇔def ∀t ∈ traces(ϕ): out(c after t) ⊆ out(ϕ after t)
Depending on the internal interleaving of the threads initiated by the method calls, different outcomes are possible. Maude’s search command can be used to do


ms 15.000
10.000

5.000

0
3	4	5	6	7	8

Non AC 	AC 
Fig. 1. Validation of c with and without AC rewriting.

a breadth first search for error configurations in the reachable state space:
search in PROGRAM : ϕc3 || c cClass =>+
ϕ || conf errorMsg(S:String) .
By altering the order of the input labels in the specification, we can easily check how different scheduling of input affect the execution of the object. E.g., a search
for error states from a specification ϕj  where the order of calls are to m1, m3, and
m2 gives no solutions, which means that with the methods called in this order, the
component cannot fail to conform to the specification.
The two series of data, plotted in Fig. 1, show the time needed for exploring the state space with or without AC rewriting, where n is the number of methods. The figures show that with AC rewriting the increase in number of rewrites is considerably less than using the equivalent, expanded version of the specification.
In the second example, a broker acts as an intermediary between a client and several providers of some service (cf. [23]). Initially we consider a broker that after being requested to do so by a client queries a fixed number of providers for a (price) quote and returns an answer to the client giving the best alternative found. A specification for a broker querying two service providers can be given as:
ϕb = nc1⟨call b.getP (x)⟩? .
( n1⟨call p1.getQ(x)⟩! . n2⟨call p2.getQ(x)⟩!) . n1⟨return (v1)⟩? . n2⟨return (v2)⟩? . nc1⟨return (v)⟩! . ϵ.
Note that whereas the previous example illustrated generation of incoming calls to the component and testing of outgoing returns from the component, this example also includes testing of outgoing calls, and generation of incoming returns. For incoming returns, the test framework generates pseudo-random, type correct return values. For this specification a broker component would be non-conforming if it were to call the providers before receiving a call from the client and also if it were to return the initial call from the client before finishing its interaction with the providers.
In an open setting, the number of providers that a broker knows is likely to

ms 300
200
100

3	4	5	6	7	8	9
k-values
Non AC 	AC 
Fig. 2. Validation of the broker component
change over time, hence we assume that a broker will be notified by new providers and establish connections with them as well as losing connections with others. A further developed version of the broker supports this by allowing the client to give the number of providers that the broker must query before giving a response as a parameter to the call to the method getP. The method getP now takes two param- eters, the name of the service for which a quote is requested, and the number of providers the broker should contact. To validate the behaviour of this new broker we use a series of specifications on the following form
ϕbk = nc1⟨call b.getP (x, k)⟩? .
(provider registration) .
( n1⟨call p1.getQ(x)⟩! . ... . nk⟨call pk.getQ(x)⟩!) .
n1⟨return (v1)⟩?	nk⟨return (vk)⟩? . nc1⟨return (v)⟩! . ϵ ,
where k is the number of providers. Figure 2 plots the times of AC rewriting, resp. explicit rewriting against k.

Conclusion
We have presented a formalization of a concurrent object-oriented language and a behavioral specification language, for testing and validation of asynchronously communicating objects. Potential reorderings of communication events occur due to network properties. Our approach describes one way to deal with such situ- ations, namely by defining rewriting specifications modulo AC for output events. One advantage of this approach is that we can define precisely the scheduling of input, and test internal synchronization properties of the object. When evaluating our approach by experimental case studies we get evidence that using modulo AC rewriting enable us to cover more extensive test cases than we could do otherwise. Testing of Creol models is relevant also for testing of implementations in lan- guages like C or Java: First indirectly, since many forms of non-determinism inher- ent in distributed system can be formalized by means of associativity and commu- tativity, our results are relevant also for other languages with asynchronous com-

munication, and for alternative definitions of observational equivalence. Second, and more directly, in [22] and [1] it is shown how different testing techniques can be employed to check for conformance between a Creol model and an industrial distributed system implemented in C. In [22] the technique of dynamic symbolic execution is used to test for conformance between the Creol model and the imple- mentation. Using the same case study, the authors of [1] show how to instrument existing Creol models for testing. Aspect-C is used to insert event recording points into the existing code of the SuT. The model is likewise instrumented with syn- chronisation points. A tester process is used to replay the recorded events in the model and synchronises with events recorded by the tester, only allowing the model to proceed beyond synchronisation points if the corresponding event was recorded in the SuT. Thus conformance of implementation and Creol model may be verified. Combining these methods with our method for verification of conformance between the Creol model and the specification yields a method for conformance testing of implementations against a specification.
Related work
Systematic testing is indispensable to assure quality of software and systems. [6] presents an approach to integrate black-box and white-box testing for object-oriented programs. Equivalence is based on the idea of observably equivalent terms and fun- damental pairs as test cases, but not in an asynchronous setting.
Godefroid et.al. [18] describe how state-space reductions can be achieved for input sequences in the context of constraint-based programming languages. A test algorithm is proposed which systematically generates all possible behavior by se- lecting input events non-deterministically from a predefined set. By exploiting the inability of constraint languages to observationally distinguish permutations of un- ordered sets of inputs, the combinatorial explosion is reduced, and a significantly more effective test algorithm is presented. A main difference from our approach is that the reduction in the state space is derived from the structure of the constraint- program itself and not from commutativity of the communicated events. The testing process is driven by the state-space exploration tool VeriSoft [17].
The paper [13] describes compositional analysis based on combining compo- nents with specifications. Also here VeriSoft is used for bounded model checking of assume/guarantee specifications, built-in partial order reduction contributes to effi- ciency of the analysis. However, both the object interaction model, shared variables, and the specifications, invariant based, using Hoare logic, differ from ours.
In [3] assumptions are used as environments to drive individual components for unit testing. LTSs are used to model the behavior of components. An interesting feature of this work, absent in ours, is techniques for automatic generation of exactly the assumptions that a component needs to make about the environment for some property to hold.
Testing for concurrent object-oriented programs based on synchronization se- quences is investigated in [7], using Petri nets and OBJ as foundation. In his thesis [29], Long presents ConAn (“concurrency analyser”), which generates test drivers

from test scripts. The method allows to specify sequences of component method calls and the order in which the calls should be issued (see also [30,33]). For scheduling the intended order, an external clock is used, introduced for the purpose of test- ing. The NModel-framework, comprehensively covered in [25], offers model-based analysis and model-based testing for C #, where abstract models, generally speak- ing transition systems, of object-oriented programs are used for testing. Related and likewise developed at Microsoft is the Spec Explorer approach (and its prede- cessor AsmLT), a tool for testing reactive, object-oriented programs. Underlying the model programs, given e.g., in the Spec# specification language, are “model automata” which can be seen as a combination of interface automata and abstract state machines (ASMs), and which are used for test case generation. Dealing with non-determinism, the models separate observable and controllable actions, similar as we distinguish between inputs and output actions in our specification language. Relying on game theoretic foundations, their notion of conformance is based on al- ternating simulation, not on comparing traces, as in this work. To cope with large and potentially infinite state spaces, Spec Explorer uses different abstraction and pruning techniques. One is based on building a quotient of the model automaton by identifying states which are considered equivalent (“state groupings”, cf. [21] and [5]). These state groupings correspond to predicate abstraction known from model checking and serve a similar purpose as the observable equivalence presented here. I.e., the are used to reduce the state space, but are user-given and not specifically capturing observably equivalent states due to asynchronous communication. For a thorough discussion of Spec Explorer and links to further results in that context, see [37].
Another well-established approach for functional testing is input/output con- formance testing (ioco for short) [34,35]. Ioco is based on input-output transition systems, our conformance relation is closely related. Component-based testing and testing in context, using the ioco test theory, are studied in [36]. A number of test-tools are based on variants of the ioco test theory, such as TGV, TestGen, and TorX. In the context of ioco testing, [15] uses symbolic transition systems to counter the state explosion problem. Unit testing framework for actors, i.e., active concurrent objects, is presented in [10], using the discrete event based simulation en- vironment OPNET. Validation of component interfaces specified in rewriting logic is the subject also of [26]. [32] considers Creol and investigates how different schedul- ing of object activity restrict the behavior. The focus is on intra-object scheduling, and on test purposes as assertions on the internal state of the object. This is in contrast to our focus on the interface communication.

Future work
Creol has successfully been used to model complex and highly dynamic communi- cation systems, e.g. wireless sensor networks in [28], where the Ad hoc On-Demand Distance Vector (AODV) routing algorithm is used as a case study. ASK is an industrial size multi-threaded, asynchronous application for connecting people. A substantial part of ASK has been modelled in Creol [1]. Both these models are com-

plex. The similarity of Creol and an object-oriented programming language, and Creol’s expressiveness allow for models that are structurally close to the AODV algorithm resp. the ASK system itself. This leads to a need for testing the models. We are currently working on applying our method for model-based testing of Creol models to the AODV model.

Acknowledgement
We thank Rudolf Schlatte for insight into application testing with Creol, and the anonymous referees for constructive criticism and hints to related work.

References
Bernhard Aichernig, Andreas Griesmayer, Rudolf Schlatte, and Andries Stam. Modeling and testing multi-threaded asynchronous systems with Creol. In TTSS’08, volume 243 of ENTCS. Elsevier, 2009.
G. Bernot. Testing against formal specification: A theoretical view. In Samson Abramsky and T. S. E. Maibaum, editors, TAPSOFT ’91, Volume 1, volume 493 of LNCS, pages 99–119. Springer, 1991.
C. Blundell, D. Giannakopoulou, and C. S. Pasareanu. Assume-guarantee testing. In Proceedings of SAVCBS’05, pages 7–14, 2005.
M. Broy, B. Jonsson, J.-P. Katoen, M. Leucker, and A. Pretschner, editors. Model-Based Testing of Reactive Systems, volume 3472 of LNCS. Springer, 2005.
Colin Campbell and Margus Veanes. State exploration with multiple state groupings. In ASM’05. Laboratory of Algorithms, Complexity, and Logic, University Paris 12, 2005.
H. Y. Chen, T. H. Tse, F. T. Chan, and T. Y. Chen. In black and white: An integrated approach to class-level testing of object-oriented program. ACM Transactions of Software Engineering and Methodology, 7(3):250–295, 1998.
Huo Yan Chen, Yu Xia Sun, and T. H. Tse. A strategy for selecting synchronization sequences to test concurrent object-oriented software. In COMPSAC ’03. IEEE Computer Science Press, 2003.
Manuel Clavel, Francisco Dur´an, Steven Eker, Patrick Lincoln, Narciso Mart´ı-Oliet, Jos´e Meseguer, and Carolyn Talcott. The Maude 2.0 system. In RTA 2003, volume 2706 of LNCS. Springer, June 2003.
Manuel Clavel, Francisco Dur´an, Steven Eker, Patrick Lincoln, Narciso Mart´ı-Oliet, Jos´e Meseguer, and Carolyn Talcott. The Maude Manual (version 2.1.1). SRI International, Menlo Park, April 2005.
Mark E. Coyne, Scott R. Graham, Kenneth M. Hopkinson, and Stuart H. Kurkowski. A methodology for unit testing actors in proprietary discrete event based simulations. In WSC ’08. Winter Simulation Conference, 2008.
The Creol language. http://heim.ifi.uio.no/creol .
S. R. Dalal, A. Jain, N. Karunanithi, J. M. Leaton, C. M. Lott, G. C. Patton, and B. M. Horowitz. Model-based testing in practice. In Proc. of the 1999 Intl. Conference on Software Engineering, 1999.
Juergen Dingel. Computer-assisted assume/guarantee reasoning with verisoft. In 25th International Conference on Software Engineering (ICSE’03), 2003.
Johan Dovland, Einar Broch Johnsen, and Olaf Owe. Observable behavior of dynamic systems: Component reasoning for concurrent objects. In FInCo ’07, volume 203 of ENTCS. Elsevier, 2008.
Lars Frantzen, Jan Tretmans, and Tim A. C. Willemse. Test generation based on symbolic specifications. In J. Grabowski and B. Nielsen, editors, FATES 2004, pages 1–15, 2005.
Marie-Claude Gaudel. Testing can be formal, too. In Peter D. Mosses, Mogens Nielsen, and Michael I. Schwarzbach, editors, Proceedings of TAPSOFT ’95, volume 915 of LNCS, pages 82–96. Springer, 1995.
Patrice Godefroid. Model checking for programming languages using VeriSoft. In Proceedings of POPL ’97, pages 174–186. ACM, January 1997.


Patrice Godefroid, L. Jagadeesan, R. Jagadeesan, and K. L¨aufer. Automated systematic testing for constraint-based interactive services. In SIGSOFT FSE. ACM, 2000.
Immo Grabe, Marcel Kyas, Martin Steffen, and Arild B. Torjusen. Executable interface specifications for testing asynchronous Creol components. In FSEN ’09, volume 5961 of LNCS. Springer, 2010.
Immo Grabe, Marcel Kyas, Martin Steffen, and Arild Braathen Torjusen. Executable interface specifications for testing asynchronous Creol components. Tech. Report 375, Univ. of Oslo, July 2008.
W. Grieskamp, Y. Gurevitch, W. Schulte, and M. Veanes. Generating finite state machines for abstract state machines. In ISSTA’07, vol. 27 of Software Engineering Notes. ACM, 2002.
Andreas Griesmayer, Bernhard Aichernig, Einar Broch Johnsen, and Rudolf Schlatte. Dynamic symbolic execution of distributed concurrent objects. In FMOODS/FORTE’09, volume 5522 of LNCS. Springer, June 2009.
Gregor Hohpe and Bobby Woolf. Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions. Addison-Wesley, 2003.
International Telecommunication Union. Open Distributed Processing - Reference Model parts 1–4. Technical report, ISO/IEC, Geneva, July 1995.
Jonathan Jacky, Margus Veanes, Colin Campbell, and Wolfram Schulte. Model-Based Software Testing and Analysis with C . Cambridge University Press, 2008.
Einar Broch Johnsen, Olaf Owe, and Arild B. Torjusen. Validating behavioral component interfaces in rewriting logic. Fundamenta Informaticae, 82(4):341–359, 2008.
Einar Broch Johnsen, Olaf Owe, and Ingrid Chieh Yu. Creol: A type-safe object-oriented model for distributed concurrent systems. Theoretical Computer Science, 365(1–2):23–66, November 2006.
Wolfgang Leister and Joakim Bjørk. Modelling routing algorithms for wireless sensor networks in Creol, 2009. Presented at the 21st Nordic Workshop on Programming Theory, NWPT ’09, Copenhagen.
Bradley Long. Testing Concurrent Java Components. PhD thesis, University of Queensland, July 2005.
Bradley Long, D. Hofmann, and P. Strooper. Tool support for testing concurrent Java components.
IEEE Transactions on Software Engineering, 29(6):555–566, 2003.
Jos´e Meseguer. Conditional rewriting as a unified model of concurrency. TCS, 96:73–155, 1992.
Rudolf Schlatte, Bernhard Aichernig, Frank de Boer, Andreas Griesmayer, and Einar Broch Johnsen. Testing concurrent objects with application-specific schedulers. In ICTAC ’08, volume 5160 of LNCS. Springer, 2008.
Paul Strooper and Luke Wildman. Testing concurrent Java components. In ICSE COMPANION ’07, pages 161–162, Washington, DC, USA, 2007. IEEE Computer Society.
Jan Tretmans. Test generation with inputs, outputs, and quiescence. In T. Margaria and B. Steffen, editors, TACAS ’96, volume 1055 of LNCS. Springer, 1996.
Jan Tretmans. Test generation with inputs, outputs, and repetetive quiescence. Software — Concepts and Tools, 17(3):103–120, 1996.
Machiel van Bijl, Arend Rensink, and Jan Tretmans.	Compositional testing with ioco.	In
TestCom/FATES 2003, volume 2931 of LNCS, pages 86–100. Springer, 2003.
Margus Veanes, Colin Campbell, Wolfgang Grieskamp, Wolfram Schulte, Nikolai Tillmann, and Lev Nachmanson. Model-based testing of object-oriented reactive systems with spec explorer. In Formal Methods and Testing, volume 4949 of LNCS. Springer, 2008.
