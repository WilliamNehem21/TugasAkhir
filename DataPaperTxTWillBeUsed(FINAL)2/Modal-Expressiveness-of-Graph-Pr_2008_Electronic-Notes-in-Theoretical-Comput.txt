Electronic Notes in Theoretical Computer Science 205 (2008) 31–47	
www.elsevier.com/locate/entcs

Modal Expressiveness of Graph Properties
Mario R. F. Benevides1 ,3
Computer Science Department and Systems and Computer Engineering Program Universidade Federal do Rio de Janeiro
Brazil
L. Menasch´e Schechter2 ,4
Systems and Computer Engineering Program Universidade Federal do Rio de Janeiro Brazil

Abstract
Graphs are among the most frequently used structures in Computer Science. In this work, we analyze how we can express some important graph properties such as connectivity, acyclicity and the Eulerian and Hamiltonian properties in a modal logic. First, we show that these graph properties are not definable in a basic modal language. Second, we discuss an extension of the basic modal language with fix-point operators, the modal μ-calculus. Unfortunately, even with all its expressive power, the μ-calculus fails to express these properties. This happens because μ-calculus formulas are invariant under bisimulations. Third, we show
that it is possible to∗express some of the above properties in a∗ basic hybrid logic. Fourth, we propose
an extension of CTL with nominals, that we call hybrid-CTL , and then show that it can express the
Hamiltonian property in a better way than the basic hybrid logic. Finally, we introduce a promising way of expressing properties related to edges and use it to express the Eulerian property.
Keywords: Graphs, Modal Logic, Modal Definability, Hybrid Logic, CTL∗, Modal μ-Calculus


Introduction
Graphs are among the most frequently used structures in Computer Science [6]. In this discipline, usually many important concepts admit a graph representation, and sometimes a graph lies at the very kernel of the model of computation used. This happens, for instance, in the field of distributed systems [3,10], where the underlying model of computation is built on top of a graph. In addition to this central role, in distributed systems, graphs are also important as tools for the description of

1 The author was partially supported by a grant from CNPq
2 The author was supported by a D.Sc. scholarship from CNPq
3 Email: mario@cos.ufrj.br
4 Email: luis@cos.ufrj.br

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.064

resource sharing problems, scheduling problems, deadlock issues, and so on. The case of distributed systems is also particularly appealing from the standpoint of the use of graphs as modeling tools because it illustrates well two different levels at which graph properties have to be described. One is the “local” level, encompassing properties that hold for vertices or constant-size vertex-neighborhoods. The other level is “global” and comprises properties that hold for the graph as a whole, as acyclicity and connectivity.
In this work, we analyze how we can express these “global” graph properties in a modal logic. A similar attempt to do this was presented in [4]. That work also tries to use modal languages to express graph properties, but it approaches this issue from a different point of view. The key differences between the two works will be discussed in the last section of the paper.
Trying to express graph properties using modal logic is an interesting idea for a number of reasons. First, modal logic achieves a good balance between what can be expressed in the language and how complex (computationally) it is to make infer- ences in it. It is a logic that certainly has more expressive power than propositional logic, but it is still decidable, unlike first-order logic. Second, modal logic formulas are evaluated in structures that are essentially graphs, which makes it a very natural choice for our work.
A ﬁnite directed graph (from now on called simply a graph) G is a pair (V, R), where V is a finite set of vertices and R ⊆ V × V is a set of ordered pairs of vertices (a binary relation on V ), called edges. If ⟨vi, vj⟩ ∈ R, we say that vi is adjacent to vj and vj is adjacent from vi. The out-degree of a vertex is the number of vertices adjacent from it and the in-degree the number of vertices adjacent to it. The set R of edges can also be written as a relation between two vertices vi and vj. We write viRvj to express the fact that vi is adjacent to vj.
A path in a graph G is a sequence of vertices ⟨v1, v2,... , vn⟩, where ⟨vi, vi+1⟩ ∈ R, for 0 < i < n. A closed path is a path such that v1 = vn. A cycle is a path where v1 = vn and vi /= vj, for 1 < i, j < n. A graph G is said to be acyclic if there is no cycle in it, otherwise it is cyclic.
Every directed graph has an underlying undirected graph, in which we do not consider the particular orientation of the edges. This means that, if G = (V, R) and ⟨v, w⟩ ∈ R, then v is adjacent to w and w is adjacent to v in the underlying undirected graph of G.
The rest of this paper is organized as follows. In section 2, we present a simple modal logic suited for the description of graph properties. In section 3, we inves- tigate the issue of whether some well-known graphs properties are definable or not in the language presented in the previous section: connectivity, acyclicity and the Eulerian and Hamiltonian properties. In section 4, we extend the modal logic of the previous sections to allow the presence of nominals, obtaining a hybrid modal logic, and use it to express some of the above properties. In section 5, we introduce the branching-time temporal logic CTL∗ with nominals, which is a very expressive logic, and use it to express the Hamiltonian property in a better way than it was expressed in the basic hybrid logic. In section 6, we introduce a promising way of

expressing properties related to edges and use it to express the Eulerian property. Finally, in section 7 we draw our concluding remarks.

Basic Graph Language
In this section, we define a modal language with two modal operators:  and  +. We call it basic graph language.
Definition 2.1 The basic graph language is a modal language consisting of a set Φ of countably many proposition symbols (the elements of Φ are denoted by p1, p2,.. .), the boolean connectives ч and Λ and two modal operators:  and  +. The formulas are defined as follows:
A ::= p |T| чA | A1 Λ A2 |  A |  +A

We freely use the standard boolean abbreviations V, →, — and ⊥ and also the following abbreviations for the duals:  A := ч чA and +A = ч +чA. Also, in order to make the language more elegant, we introduce some abbreviations for the reflexive and transitive closures:  ∗A = A V  +A and  ∗A = ч ∗чA.
We now define the structures in which we evaluate formulas in modal logics:
frames and models.
Definition 2.2 A frame for the basic graph language is a pair J = (V, R), where V
is a set (finite or not) of vertices and R is a binary relation over V, i.e., R ⊆ V × V .
As we see, a frame for the basic graph language is essentially a graph. This confirms our statement in the first section that modal languages are a very natural choice for this work.
Definition 2.3 A model for the basic graph language is a pair ł = (J, V), where J is a frame and V is a valuation function mapping proposition symbols into subsets of V , i.e., V :Φ '→ У(V ).
The semantical notion of satisfaction is defined as follows:
Definition 2.4 Let ł = (J, V) be a model. The notion of satisfaction of a formula A in a model ł at a vertex v, notation ł,v H A, can be inductively defined as follows:
ł,v H p iff v ∈ V(p);
ł,v H T always;
ł,v H чA iff ł,v /H A;
ł,v H A Λ B iff ł,v H A and ł,v H B;
ł,v H  A iff there is a w ∈ V such that vRw and ł,w H A;
ł,v H  +A iff there is a w ∈ V such that vR+w and ł,w H A. Here, R+ denotes the transitive closure of R.

A formula A is satisfied at a vertex v if, for some vertex w, vRw and A is satisfied at w. A formula +A is satisfied at a vertex v if there is a path ⟨v1,... , vn⟩, n ≥ 2, such that v = v1, w = vn, viRvi+1 for 1 ≤ i < n and A is satisfied at w.
Let ł be the model shown (without its valuation) in figure 1. In order to illustrate the use of the language, we can see that the following formulas are satisfied at vertex w in ł, supposing that A is satisfied at vertex v in ł: ł,w H A, ł,w H    A, ł,w H  +A and ł,w H  + ⊥.
v




w

Fig. 1. Model M, where a formula A is satisfied at vertex v.
If ł,v H A for every vertex v in a model ł, we say that A is globally satisﬁed in ł, notation ł H A. And if A is globally satisfied in all models ł of a frame J, we say that A is valid in J, notation J H A.
In this work, we want to find a modal formula φ (for each property), such that a graph G has the desired property if and only if J H φ, where J is the frame that represents G.
In a general level, the problem of determining whether there is a model ł and a vertex v in ł such that, for a given formula φ, ł,v H φ is called the satisﬁability problem for φ and the problem of determining whether, for a given formula φ, J H φ, for all frames J, is called the validity problem for φ. These two problems are duals to each other. In the basic graph logic, they are decidable, having EXPTIME complexity [5]. As we mentioned in the first section of the paper, this decidability is one of the reasons why it is an interesting idea to use modal logics in this work.

Modal Definability
In this section, we investigate whether some well-known graph properties are mod- ally definable or not in the basic graph language. These properties are: connectivity, acyclicity and the Hamiltonian and Eulerian properties.
The limits to the expressive power of basic modal languages are fairly well known. There are a series of standard results that state that frames that are “similar” in a number of ways must agree on the validity of formulas. We can then use these results to prove that a certain property cannot be expressed by any modal formula. To do this, we take two frames that are “similar” and show that in one the desired property holds, while in the other it does not. We present two of these “similarity” results (more details about them and other related results may be found in [5]), and then we prove some theorems for graph properties using them.
Definition 3.1 Let ł = (W, R, V) and ł' = (W ', R', V') be two models. A function f : W → W ' is a bounded morphism if it satisfies the following conditions:

w and f (w) satisfy the same proposition symbols;
f is a homomorphism with respect to R (if wRv, then f (w)R'f (v));
if f (w)R'v', then there is a v such that wRv and f (v)= v'.
If there is a surjective bounded morphism from W to W ', then we say that ł'
is a bounded morphic image of ł and use the notation ł ⇒ ł'.
Another important definition concerns collections of disjoint models. We say that two models ł1 = (W1, R1, V1) and ł2 = (W2, R2, V2) are disjoint models if and only if W1 ∩ W2 = ∅.
Definition 3.2 Let łi = (Wi, Ri, Vi) be a collection of disjoint models. The
disjoint union łi = (W, R, V) is defined as
W - the union of Wi;
R - the union of Ri;
V - for each proposition symbol p, V(p)=  Vi(p).
Similar definitions can be given for a bounded morphism and a disjoint union of frames, just removing the parts of the above definitions that deal with valuations. Below are two basic theorems about modal definability that are going to be used throughout the next subsections. Their proofs for a language that contains only  can be found at [5]. It is not difficult to extend that proof to a language
that contains both  and  +.
Theorem 3.3 Let ł = (W, R, V) and ł' = (W ', R', V') be two models such that
ł ⇒ ł'. Then, ł,w H φ if and only if ł',f (w) H φ.
Corollary 3.4 Let J = (W, R) and J' = (W ', R') be two frames such that J ⇒ J'. If J H φ, then J' H φ.
Theorem 3.5 Let łi = (Wi, Ri, Vi) be a collection of disjoint models and łi = (W, R, V) their disjoint union. Then, łi,w H φ if and only if  łi,w H φ.
Corollary 3.6 Let Ji = (Wi, Ri) be a collection of disjoint frames and Ji = (W, R) their disjoint union. If Ji H φ for every i, then Ji H φ.
Connectivity
We can define two levels of connectivity for a graph. On a first level, a graph G is said to be (weakly) connected if and only if, for any two vertices v and w in G, there is a path from v to w in the underlying undirected graph of G. On a second level, a graph G is said to be strongly connected if and only if, for any two vertices v and w in G, there is a path from v to w in G itself.
Theorem 3.7 Weak and strong connectivity are not modally deﬁnable.
Proof. The disjoint union of connected graphs is not a connected graph. By corol- lary 3.6, since connectivity is not preserved under taking disjoint unions, it is not modally definable.	 

Acyclicity
A graph G is said to be acyclic if and only if there is no path in G from any vertex
v to itself.
Theorem 3.8 Acyclicity is not modally deﬁnable.
Proof. We can take a frame J = (W, R) where W = N and R = {⟨i, i + 1⟩,i ∈ N} and a frame J' = (W ', R') where W ' = {O, E} and R' = {⟨O, E⟩, ⟨E, O⟩}. If we define f as f (i) = E if i is even and f (i) = O otherwise, we have that f is a surjective bounded morphism between J and J'. But J is acyclic while J' is not. Hence, by corollary 3.4, since acyclicity is not preserved under bounded morphic images, it is not modally definable.	 

Hamiltonian Graphs
A connected graph G is said to be Hamiltonian if and only if there is a cycle in G
which goes through every vertex of it.
Theorem 3.9 The class of Hamiltonian graphs is not modally deﬁnable.
Proof.	From figure 2, let f = {(1, a), (2, b), (3, c), (4, d), (5, b)}. It is straightfor-
2	3	c


1

5	4	d
Fig. 2. Graph 1,2,3,4,5 is Hamiltonian and graph a,b,c,d is not.

ward to prove that f is a bounded morphism. By corollary 3.4, since the Hamil- tonian property is not preserved under bounded morphic images, it is not modally definable.	 

Eulerian Graphs
A connected graph G is said to be Eulerian if and only if there is a closed path in
G in which every edge of it appears exactly once.
Theorem 3.10 ([6]) A connected graph G is Eulerian if and only if the out-degree of every vertex of G is equal to its in-degree.
Theorem 3.11 The class of Eulerian graphs is not modally deﬁnable.
Proof. From figure 3, let f = {(1, a), (2, b), (3, c), (4, c), (5, d)}. It is straightfor- ward to prove that f is a bounded morphism. By corollary 3.4, since the Eulerian property is not preserved under bounded morphic images, it is not modally defin- able.	 


1	a











Fig. 3. Graph 1,2,3,4,5 is Eulerian and graph a,b,c,d is not.
The Modal μ-Calculus
Looking at the results of the previous subsections, we see that, unfortunately, the basic graph language does not have enough expressive power to define the proper- ties that we want. We need a stronger language. One idea could be to use the modal μ-calculus [7,15]. This language incorporates fix-point operators and is very expressive. In fact, not only the basic graph language can be embedded into the μ-calculus, but so can be the temporal languages LTL, CTL and CTL∗ [8].
Unfortunately, even with all this expressive power, the μ-calculus fails to express these properties because of the same reasons exposed in the previous subsections. This happens because μ-calculus formulas, as the basic graph formulas, are invari- ant under bisimulations (disjoint unions and bounded morphisms are special cases of bisimulation). In fact, the μ-calculus is the bisimulation-invariant fragment of Monadic Second-Order Logic (MSOL) [7].
To bypass this problem, we introduce a different kind of language in the next section. This language has a mechanism to name vertices of the model and allows us to express the graph properties that we want.

Hybrid Graph Language
As was shown in the previous section, the basic graph language does not have enough expressive power to describe the properties that we want. In order to achieve our goal, we need a language that is more expressive but, if possible, still decidable.
One interesting class of languages to take into consideration is the class of hybrid languages [2,5]. In these languages, there is a new kind of atomic symbol: nominals. Nominals behave similarly to proposition symbols. The key difference between them is related to their valuation in a model. While the set V(p) for a proposition symbol p can be any element of У(V ), the set V(i) for a nominal i has to be a singleton set. This way, each nominal is satisfied at exactly one vertex, and thus, can be used to reference a unique vertex of the model.
A hybrid extension of our previous language is an interesting choice because of a combination of factors. It improves the expressive power of that language, since hybrid formulas are no longer invariant under neither disjoint unions nor bounded morphic images [2], but it is still a decidable language (in fact, with complexity no worse than the one from the previous language) [1].

In this section, we define an extension of the basic graph language that includes nominals. We call it hybrid graph language. After that, we try to express, in this new language, the graph properties that we are discussing.

Language
Definition 4.1 The hybrid graph language is a hybrid language consisting of a set Φ of countably many proposition symbols (the elements of Φ are denoted by p1, p2,.. .), a set L of countably many nominals (the elements of L are denoted by i1, i2,.. .) such that Φ ∩L = ∅ (the elements of Φ ∪L are called atoms), the boolean connectives ч and Λ and the modal operators @i, for each nominal i,  and +. The formulas are defined as follows:
A ::= p | i |T| чA | A1 Λ A2 |  A |  +A | @iA
Again, we freely use the standard abbreviations V, →, —, ⊥,  A,  +A,  ∗A
and  ∗A.
The definition of a frame is the same as the one from section 2. The definition of a model is slightly different.
Definition 4.2 A model for a hybrid graph language is a pair ł = (J, V), where J is a frame and V is a valuation function mapping proposition symbols into subsets of V , i.e., V : Φ '→ У(V ), and mapping nominals into singleton subsets of V , i.e, if i is a nominal then V(i)= {v} for some v ∈ V . We call this unique vertex that belongs to V(i) the denotation of i under V. We can also say that i denotes the single vertex belonging to V(i).
The notion of satisfaction is defined adding two extra clauses to definition 2.4:
ł,v H i iff v ∈ V(i);
ł,v H @iA iff ł,d H A, where d is the denotation of i under V.
For each nominal i, the formula @iA means that if V(i)= {v} then A is satisfied at v. As in section 2, if ł,v H A for every vertex v, we say that A is globally satisﬁed in the model ł (ł H A) and if A is globally satisfied in all models ł of a frame J, we say that A is valid in J (J H A).
It is important to see that the operators @i are normal modal operators. For every nominal i, @i(A → B) → (@iA → @iB) is a formula valid in all frames. Also, it is interesting to see that the operators @i are duals to themselves.

Hybrid Deﬁnability
In the hybrid graph language we can now express at least two of the properties that we want.
Theorem 4.3 A graph G, where G' is its underlying undirected graph, is strongly connected if and only if J H φ and (weakly) connected if and only if J' H φ, where

J is the frame that represents G, J' is the frame that represents G' and φ is the formula
φ = @i(чj →  +j).
Proof. We prove the theorem only for strong connectivity. The other case is com- pletely analogous.
(⇐) Suppose that J H φ but G is not strongly connected. Then, there are at least two distinct vertices v, w in G such that w is not reachable from v. We will evaluate φ in a model with a valuation V such that V(i) = {v} and V(j) = {w}. Then, for any vertex u in G, (J, V),u /H φ, contradicting the fact that φ is valid in J.
(⇒) Suppose that G is strongly connected but J /H φ. Then, there is a valuation V and a vertex u such that (J, V),u /H φ. Let V(i) = {v} and V(j) = {w}. If v = w, then φ is satisfied, so we may assume that v /= w. Then for φ to be falsified, we need (J, V),u H @iч +j. This, on the other hand, is equivalent to vR+w being false in G, which means that w is not reachable from v. This contradicts the fact that G is strongly connected.	 
Theorem 4.4 A graph G with frame J is acyclic if and only if J H φ, where φ is the formula
φ = @iч +i.
Proof. (⇐) Suppose that J H φ but G is not acyclic. Then, there is at least one vertex v in G such that there is a path in G from v to itself. We will evaluate φ in a model with a valuation V such that V(i) = {v}. Then, for any vertex u in G, (J, V),u /H φ, contradicting the fact that φ is valid in J.
(⇒) Suppose that G is acyclic but J /H φ. Then, there is a valuation V and a vertex u such that (J, V),u /H φ. Let V(i) = {v}. Then for φ to be falsified, we need (J, V),u H @i +i. This, on the other hand, is equivalent to vR+v being true in G, which means that v is reachable from itself. This contradicts the fact that G is acyclic.	 
Before trying to find a formula to describe the Hamiltonian graphs, we need to consider some graph-theoretical issues. In graph theory [6], there is no known result that states a necessary and sufficient condition for a graph to be Hamiltonian. If we could find a formula that describes the Hamiltonian graphs without having to describe the Hamiltonian cycle itself, we would be finding such necessary and sufficient condition. Thus, what our formula does is to inspect all of the paths in the graph, searching for a Hamiltonian cycle. Not surprisingly then, the only formula we could find in this simple language to describe the Hamiltonian property has length proportional to n!, where n is the number of vertices in the graph.
Let Ln = {i1,... , in} be a set containing n nominals. Before defining a formula for the Hamiltonian property, we will define a formula that is globally satisfied in a model under a valuation V if and only if V(ik) /= V(il), for all ik, il ∈ Ln such that k /= l.

Lemma 4.5 A valuation satisﬁes V(ik) /= V(il), for all ik, il ∈ Ln such that k /= l, if and only if (J, V) H ψn, where ψn is the formula


ψn =	 
⎛@ik	 
⎞
чil	.

1≤k≤n ⎝	1≤l≤n,l/=k	⎠
Proof. It follows directly from the definitions of a valuation for a nominal and of satisfaction for a nominal and for a formula @iϕ.	 
We now define a set F of permutations of the nominals in Ln. This set has n! elements. We represent a permutation as a bijective function σ : {1,... , n} '→ Ln.
Theorem 4.6 A connected graph G (with n vertices) with frame J is Hamiltonian
if and only if J H φ, where φ is the formula
φ = ψn → δn,
with
δn =   (σ(1) Λ  (σ(2) Λ  (σ(3) ... (σ(n − 1) Λ  (σ(n) Λ  σ(1)) .. .).
σ∈F
Proof. (⇐) Suppose that the formula φ is valid in J. We will evaluate φ in an arbitrary vertex v of a model with a valuation V such that V satisfies ψn and V(i1) = {v}. First, this means that each nominal is denoting a different vertex. Second, V must also satisfy δn. If δn is satisfied, at least one of the members in its disjunction is satisfied. Let σ' be the permutation correspondent to this member. To simplify the notation and without loss of generality, we consider that σ'(k)= ik. Let then Δn = in Λ  i1. We also define the formulas Δk, for 1 ≤ k ≤ n − 1, as
Δk = ik Λ  Δi+1.
Thus, (J, V),v H Δ1. From this and from the construction rule of the formulas Δk, we have that there are vertices wk in G such that (J, V), wk H Δk, wkRwk+1, for 2 ≤ k ≤ n − 1, vRw2 and wnRv. We then have that ⟨v, w2,... , wn, v⟩ is a Hamiltonian cycle in G.
(⇒) Suppose that there is a Hamiltonian cycle ⟨v1,... vn, v1⟩ in G. We denote the vertices with nominals in such a way that Ln = {i1,... , in} and ik denotes vk. This valuation satisfies ψn. We have that vnRv1, so Δn is satisfied at vn. Similarly, Δk is satisfied at vk. Since Δ1 is a member of the disjunction in δn, δn is satisfied at v1. Repeating the previous line of thought, but starting the cycle at v2, v3 and so on, we can see that δn is also satisfied at all the vertices in the cycle. Since the cycle is Hamiltonian, this means that δn is satisfied in all the vertices of G. Since φ is trivially satisfied in all the valuations that do not satisfy ψn, we only need to think about the ones that do. If we change the valuation of the nominals in Ln to another one that satisfies ψn, this is equivalent to applying a permutation to the nominals.

As δn contains a member in its disjunction for each permutation, we conclude that in fact φ is valid in J.	 
The difficulty in finding a formula to describe Eulerian graphs is of a completely different nature. Here, the limitation is on the language, not on the theoretical definition of the property. There is a known result that states a necessary and sufficient condition for a graph to be Eulerian (theorem 3.10), so the argument used above for Hamiltonian graphs is not valid here. However, the hybrid graph language does not have the expressive power, at least not without falling again in a factorial-length formula, to state cardinality conditions on edges incident from and to a vertex, as is needed in theorem 3.10.
The other way to describe the Eulerian property would be to find a formula that explicitly describes an Eulerian path in the graph. However, it is very hard to find such a formula, since the hybrid graph logic and many other modal logics are not good languages to talk about edges. One of the reasons for that is the fact that the modal operator  does not differentiate between edges incident from a vertex. We now, using nominals, have names for vertices, but we still cannot keep track of which edges we are using when we walk in a graph. This suggests that a possible solution would be to find a way to name the edges in some similar way to the use of nominals to name vertices. We do this in section 6, where we describe a method to name edges within the framework of a hybrid language and use it to find a formula for the Eulerian property.
The Temporal Logic Hybrid-CTL∗
The fact that the formula describing Hamiltonian graphs has factorial size makes its verification impossible. Of course, we can never expect to verify the Hamiltonian property in polynomial time, since determining whether a graph is Hamiltonian is an NP-Complete problem [9], but we may try to verify it a little faster than in factorial time. That is our goal in this section.
In order to write a short (with polynomial size) formula to describe the class of Hamiltonian graphs, we use the temporal branching-time logic CTL∗ [11] with nominals (hybrid-CTL∗). We could use the full hybrid μ-calculus presented in [13], since it contains the hybrid-CTL∗ [8]. But we will not do this, since the hybrid- CTL∗ is strong enough for what we want to do and its formulas are incredibly easier to read and to understand than hybrid μ-calculus formulas (which is another reason for the introduction of the hybrid-CTL∗).
The hybrid-CTL∗ is also decidable. We can establish an exponential upper bound to the complexity of the validity problem in this hybrid temporal language, following the validity problem’s complexity in the hybrid μ-calculus.
Language
Definition 5.1 The hybrid-CTL∗ language is a temporal language consisting of a set Φ of countably many proposition symbols (the elements of Φ are denoted by

p1, p2,.. .), a set L of countably many nominals (the elements of L are denoted by i1, i2,.. .) such that Φ ∩L = ∅, the boolean connectives ч and Λ and the operators @i, for each nominal i, and A, E, X, F, G and U. Formulas are divided into vertex formulas S and path formulas P co-inductively defined as follows:
S ::= p | i |T| чS | S1 Λ S2 | AP | EP | @iS P ::= S | чP | P1 Λ P2 | XP | FP | GP | P1UP2
The language of hybrid-CTL∗ is then the set of all vertex formulas generated by the above rules.
The definition of a frame and of a model are the same as the ones from the previous section. The notion of satisfaction in hybrid-CTL∗ is defined as follows:
Definition 5.2 Let ł = (J, V) be a model. We also need the auxiliary notation that if π = ⟨s0, s1,.. .⟩ is a path, we denote by πi the suffix of π starting at si. The notion of satisfaction of a vertex formula S in a model ł at a vertex v or of a path formula P in a model ł at a path π, notation ł,v H S and ł,π H P , can be inductively defined as follows:
ł,v H p iff v ∈ V(p);
ł,v H i iff v ∈ V(i);
ł,v H T always;
ł,v H чS iff ł,v /H S;
ł,v H S1 Λ S2 iff ł,v H S1 and ł,v H S2;
ł,v H AP iff for every path π starting in v, ł,π H P ;
ł,v H EP iff there is a path π starting in v such that ł,π H P ;
ł,v H @iS iff ł,d H S, where d is the denotation of i under V;
ł,π H S iff v is the first vertex of π and ł,v H S;
ł,π H чP iff ł,π /H P ;
ł,π H P1 Λ P2 iff ł,π H P1 and ł,π H P2;
ł,π H XP iff ł, π1 H P ;
ł,π H FP iff there is a k ≥ 0 such that ł, πk H P ;
ł,π H GP iff for all k ≥ 0, ł, πk H P ;
ł,π H P1UP2 iff there is a k ≥ 0 such that ł, πk H P2 and for all 0 ≤ j < k,
ł, πj H P1.
We should think of A as “for all paths starting in the current vertex”, E as “there is a path starting in the current vertex such that...”, X as “in the next vertex of the current path”, F as “in the current vertex or at some future vertex in the current path”, G as “in the current vertex and for all future vertices in the current path” and U as “the first formula is satisfied in a path until the second formula is satisfied in this path, and the second formula will be satisfied eventually”.

The Hamiltonian Property
Let G be a graph with n vertices and let Ln = {i1,... , in}. Let us add a loop to all the vertices in G. We can then define the formula that is valid if and only if G is Hamiltonian.
Theorem 5.3 A connected graph G (with n vertices) with frame J is Hamiltonian
if and only if J H φ, where φ is the formula
φ = ψn → δn,
with
δn = @i1 E[XFi1 Λ Fi2 Λ ... Λ FinΛ
ΛXG(i1 → Gi1) Λ G(i2 → XGчi2) Λ ... Λ G(in → XGчin)].
Proof. (⇐) Suppose that the formula φ is valid in J. We will evaluate φ in an arbitrary vertex v of a model with a valuation V such that V satisfies ψn. First, this means that each nominal is denoting a different vertex. Second, V must also satisfy δn. If δn is satisfied, then there is a path π in G starting at the vertex denoted by i1 such that the formula inside the brackets in δn is satisfied in this path for the valuation V. This means that Fik is satisfied for 2 ≤ k ≤ n and XFi1 is satisfied. Thus, every vertex in G appears at least once in π. Also, the formulas G(ik → XGчik) are satisfied for 2 ≤ k ≤ n. This means that the vertices denoted by ik, for 2 ≤ k ≤ n, appear exactly once in the path. Finally, XG(i1 → Gi1) is satisfied, which means that after the second visit to the vertex denoted by i1, no other vertex in G is visited anymore in the path. So, if we disregard the final looping in the vertex denoted by i1, we have a path that starts and ends in this vertex and visit every other vertex of G exactly once. This is exactly a Hamiltonian cycle.
(⇒) Suppose that there is a Hamiltonian cycle ⟨v1,... vn, v1⟩ in G. We denote the vertices with nominals in such a way that Ln = {i1,... , in} and ik denotes vk. This valuation satisfies ψn. Consider the extended path ⟨v1,... vn, v1, v1,.. .⟩. Clearly, the components of the conjunction inside brackets in δn are satisfied in this path. Then, since this path starts at v1, E[.. .] is satisfied in v1 and δn is satisfied at all vertices, because v1 is denoted by i1. Since φ is trivially satisfied in all the valuations that do not satisfy ψn, we only need to think about the ones that do. Changing the valuation of the nominals in Ln to another one that satisfies ψn is harmless, since the @ operator in the beginning of the formula is marking a starting point in the cycle, which contains all the vertices. This means that no matter where V(i1) send us, it will be a point inside the cycle. Thus, φ is valid in J.	 

Edge-Related Properties
As was mentioned in the end of section 4, one way to describe the Eulerian property would be to use theorem 3.10. However, this would be very hard to do using our standard  operators, or even the temporal operators defined in the previous

section. This happens because all of these operators are “existential” operators. All they can do is to differentiate between things like “there is some edge” and “there is no edge”, or “there is some path” and “there is no path”. We would need “counting” operators to be able to efficiently express theorem 3.10. Although they exist in the literature ([12], for example), we don’t want to introduce a whole new formalism. We want to express the Eulerian property in a hybrid language.
So, if we are not going to use theorem 3.10, we need to define the Eulerian property with a formula that explicitly describes an Eulerian path in the graph. This is also a difficult task, because of the reasons exposed in the end of section 4. We need a way to identify particular edges, but hybrid languages only have names for vertices. So, we first develop a method to name edges within the formalism of a hybrid language and later use it to define the Eulerian property.

Graph Subdivisions
Definition 6.1 Let ⟨v, w⟩ be an edge in a graph G. An edge subdivision consists of adding a new vertex u to G, deleting the edge ⟨v, w⟩ and adding the edges ⟨v, u⟩ and ⟨u, w⟩ to G. A graph subdivision of a graph G is a graph G' obtained from G by a (finite) number of edge subdivisions.
Definition 6.2 Let G be a graph. We define G' = E(G) to be the graph obtained from G by subdividing every edge of G exactly once. We call G' an E-graph.
Thus, if G has n vertices and m edges, G' will have m + n vertices. In fact, if we call V the set of vertices of G and V ' the set of vertices of G', we have that V ' = V ∪ V ∗ (V ∩ V ∗ = ∅), where V ∗ is the set of new vertices added during the subdivision. We also have that every edge of G' has an extremity in V and the other in V ∗ and that there is a bijective map between elements of V ∗ and edges of G.
This bijective map between the set V ∗ and the edges of G is the key point in this construction. In the original graph G, we cannot identify particular edges using just an hybrid language. So, if we want to define a property in G, described using its edges, we build G' = E(G) and describe it in G', using the elements in V ∗. These elements can be identified by standard nominals. This is what we do to express the Eulerian property.
For this method to work, we just have to pay attention to an important detail. In E-graphs, it is fundamental to be able to distinguish whether a given vertex is in V or in V ∗. Thus, instead of working with one set of nominals L, we will be working with two such sets, L1 and L2 (L1 ∩ L2 = ∅). Instead of writing G' = (V ', R'), we write G' = (V, V ∗, R'), to make clear the difference between the two sets of vertices, and define valuations V as V(p) ∈ У(V ∪ V ∗), if p is a proposition symbol, V(i) = {v}, such that v ∈ V , if i ∈ L1 and V(j) = {w}, such that w ∈ V ∗, if j ∈ L2. We will denote the nominals in L1 by i1, i2,... and the nominals in L2 by j1, j2,.. ..

The Eulerian Property
Since, as stated in the beginning of the section, we are going to define the Eulerian property with a formula that explicitly describes an Eulerian path in the graph, we can borrow ideas from two previously presented formulas: the formulas in theorems
4.6 and 5.3. But the formula in the first theorem has factorial length, so we will only adapt the formula in the second theorem to the Eulerian case.
This is not a difficult task. The formula in theorem 5.3 states that, for a graph G = (V, R), there is a cycle that visits every vertex in V exactly once (with the exception of the first vertex of the cycle). To define the Eulerian property, we need a formula that checks that, for a graph G, there is a closed path such that every edge in G appears exactly once in it. This is equivalent to check, in G' = E(G), whether there is a closed path that visits every vertex in V ∗ exactly once.
Let G' = E(G) be a E-graph with n vertices in V and m vertices in V ∗ and let Lm = {j1,... , jm}. Let us add a loop to all its vertices in V . We can then define the formula that is valid if and only if G is Eulerian.
Theorem 6.3 A connected graph G (with m edges) is Eulerian if and only if J H φ, where J is the frame that represents G' = E(G) and φ is the formula
φ = ψm → δm,


with

δm = @i1 E[Fj1 Λ Fj2 Λ ... Λ FjmΛ

ΛG(j1 → XGчj1) Λ G(j2 → XGчj2) Λ ... Λ G(jm → XGчjm) Λ XG(i1 → Gi1)].
Proof. As a consequence of G being connected, if a closed path goes through every edge in G, it also goes through every vertex in G and, as a consequence, through every vertex in G'. From this observation, the proof of the above theorem follows using the same ideas that are present in the proof of theorem 5.3.	 

Conclusions
Our goal in this paper is to try to express, using modal logics, some “global” graph properties that are central to many computer science applications. [4] is a work closely related to this one. In that work, the interest was also in how to use modal logics to express “global” graph properties. One of the differences is that, in [4], only the basic modal logic, increased with the transitive modalities + and +, was used. Also, that work had the goal of providing axiomatizations to classes of graphs with these “global” properties, while our approach in this work is to test whether a single formula could express each of these properties. Finally, [4] did not explore the Hamiltonian and the Eulerian properties. The work in [14] also has some similarity with ours. In that work, a fragment of first-order logic is used to describe graph properties in the particular context of graph transformations and graph rewriting. It would be interesting to analyze the interconnection between our work and [14].

In the present work, we presented various formalisms, from a very basic modal logic to a very powerful temporal logic and used them to define four graph properties: connectivity, acyclicity and the Hamiltonian and Eulerian properties. It would also be interesting to continue this line of work and try to express some other graph properties such as planarity and k-colorability of vertices and edges.
This work is an interesting way of exposing an important issue. Sometimes, standard modal languages, even the ones that are incredibly expressive, such as the μ-calculus, are not capable of expressing some important properties. This happens because of some strong invariance conditions (such as the ones defined in section 3) that these languages satisfy. In these cases, the use of a hybrid language is a very simple way to bypass this problem. Hybrid languages have much weaker invariance conditions [2], which increases the number of definable properties.
Also, we showed a practical application of a hybrid temporal language. We used a hybridized version of CTL∗ to describe the class of Hamiltonian graphs. The introduction of hybrid-CTL∗ is also important on its own, since it is expressive enough for many applications, which makes the use of the full hybrid μ-calculus of [13], a language with very poor readability (as most fixpoint languages), unnecessary in such cases.
Finally, we describe in section 6 a way to name edges in the hybrid language using graph subdivisions, which does not require any major change in the language. One open issue with this method is that some formulas satisfied at a vertex v in G are no longer satisfied in the same vertex in E(G). For instance, a formula  ϕ may be satisfied at v in G but not in G', because of the new vertices that are added between the old ones. If we just want to evaluate formulas in G' and forget about G, as we did in section 6, then this is not a problem. But if we want to work with both graphs at the same time, then it would be very interesting to define a translation T between formulas, such that if ϕ is satisfied at v in G, then T (ϕ) is satisfied at v in G'. It would also be interesting to study what other properties could be expressed in the hybrid language using this construction that allows us to name not only vertices but also edges.

References
Areces, C., P. Blackburn and M. Marx, The computational complexity of hybrid temporal logics, Logic Journal of the IGPL 8 (2000), pp. 653–679.
Areces, C. and B. ten Cate, Hybrid logics, in: P. Blackburn, J. van Benthem and F. Wolter, editors,
Handbook of Modal Logic, Elsevier, 2006 pp. 821–868.
Barbosa, V. C., “An Introduction to Distributed Algorithms,” MIT Press, 1996.
Benevides, M. R. F., Modal logics for finite graphs, in: R. Queiroz, editor, Logic for Synchronization and Concurrency, Trends in Logic, Kluwer Academic Publisher, 2003 pp. 239–267.
Blackburn, P., M. de Rijke and Y. Venema, “Modal Logic,” Theoretical Tracts in Computer Science, Cambridge University Press, 2001.
Bondy, J. A. and U. S. R. Murty, “Graph Theory with Applications,” Elsevier, New York, 1979.
Bradfield, J. and C. Stirling, Modal mu calculi, in: P. Blackburn, J. van Benthem and F. Wolter, editors,
Handbook of Modal Logic, Elsevier, 2006 pp. 721–756.

Dam, M., CTL∗ and ECTL∗ as fragments of the modal mu-calculus, Theoretical Computer Science
126 (1994), pp. 77–96.
Karp, R., Reducibility among combinatorial problems, in: Complexity of Computer Computations, Plenum, New York, 1972 pp. 85–103.
Lynch, N., “Distributed Algorithms,” Morgan Kaufmann Publishers, San Mateo, 1996.
Moller, F. and A. Rabinovich, On the expressive power of CTL∗, in: XIV IEEE Symposium on Logic in Computer Science, 1999, pp. 360–369.
Ohlbach, H. J., R. A. Schmidt and U. Hustadt, Translating graded modalities into predicate logic, Technical Report MPI-I-95-2-008, Max-Planck-Institut fu¨r Informatik, Saarbru¨cken (1995).
Sattler, U. and M. Y. Vardi, The hybrid μ-calculus, in: First International Joint Conference in Automated Reasoning, 2001, pp. 76–91.
Strecker, M., Modeling and verifying graph transformations in proof assistants, in: 4th International Workshop on Computing with Terms and Graphs, 2007, pp. 112–124.
Venema, Y., Lectures on the modal mu-calculus (2007).
URL http://staff.science.uva.nl/∼ yde/teaching/ml/mu/mu.pdf
