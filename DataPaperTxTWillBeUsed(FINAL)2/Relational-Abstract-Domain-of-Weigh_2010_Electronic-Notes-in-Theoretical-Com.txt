

Electronic Notes in Theoretical Computer Science 267 (2010) 59–72
www.elsevier.com/locate/entcs

Relational Abstract Domain of Weighted Hexagons
Jędrzej Fulara1,2, Konrad Durnoga3, Krzysztof Jakubczyk1,4 and Aleksy Schubert1,5
Institute of Informatics University of Warsaw ul. Banacha 2
02-097 Warsaw, Poland

Abstract
We propose a new numerical abstract domain for static analysis by abstract interpretation, the domain of Weighted Hexagons. It is capable of expressing interval constraints and relational invariants of the form x ≤ a · y, where x and y are variables and a denotes a non-negative constant. This kind of domain is useful in analysis of safety for array accesses when multiplication is used (e.g. in guarding formulæ or in access expressions). We provide all standard abstract domain operations, including widening operator, as
well as a graph-based algorithm for checking satisfiability and computing normal form for elements of the
domain. All described operations are performed in O(n3) time. Expressiveness of this domain lies between the Pentagons by Logozzo and Fähndrich and the Two Variables Per Inequality by Simon, King and Howe.
Keywords: Numerical abstract domains, static analysis, abstract interpretation.


Introduction
The concrete semantics of a program yields possibly infinite computations, hence an- swering any non trivial questions may be infeasible. A simpler, yet not fully precise, model can be employed to reason about program properties. Abstract Interpreta- tion [6] is a widely used technique that simplifies the process of computation so that its vital properties can be captured within finite resources (time, space etc.) of a computing machine. This technique has been successfully applied in various fields, including program verification [2], error discovery and debugging [3], specification

1 This work was partly supported by Polish government grant N N206 493138.
2 Email: fulara@mimuw.edu.pl
3 Email: kdr@mimuw.edu.pl
4 Email: kjk@mimuw.edu.pl
5 Email: alx@mimuw.edu.pl


1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.09.006

Require: array input[1...m]
1: {input.len ≤ m}
2: output ➟ array [1...2 * input.len]
3: {output.len ≤ 2 · input.len; ... ; m ≤ 1 · output.len}
4: for i ➟ 1 to m do
5:	{i ≤ 1 · output.len; ... }
6:	output[2 * i - 1] ➟ input[i]
7:	output[2 * i] ➟ input[i]
8: end for
9: return output
Fig. 1. A simple code fragment along with invariants that allow proving correctness of the array accesses in lines 6 and 7.
generation or code optimisation during compilation, including program transforma- tion [5].
The Abstract Interpretation Framework allows one to automatically infer invari- ants that describe some properties of the analysed program. To apply this framework we need to define an abstract domain — a representation of the invariants, and op-
erations on them (union, intersection, widening, satisfiability test, etc.) [8]. In this paper, we present an abstract domain that can express relations between pairs of numerical variables x, y of the form x ≤ a · y, where a is a non-negative constant, as well as interval constraints x ∈ [b, c]. In a two-dimensional case such constraints describe a polygon with at most 6 edges and angles determined by the coefficients
from the inequalities (Figure 2). This motivates the name Weighted Hexagons.

Example
Figure 1 presents a simple procedure that duplicates all entries of the given input array. Static analysis using the domain of Weighted Hexagons can automatically infer in line 5 an invariant i ≤ 1 · output.len.

Related Work
In the past, several numerical abstract domains were developed. The most basic one is the Domain of Intervals [7] that represents invariants of the form x ∈ [a, b]. It is efficient (linear time and memory), but does not handle relations between variables. The domain of Convex Polyhedra [10] is very precise — it represents invariants of the form α1v1 + α2v2 + ... + αnvn ≤ c where v1,..., vn are program variables and c, α1,..., αn are numerical constants. However the domain representation and op- erations are inefficient (exponential in the number of variables), and so not practical for many applications. The domain of Octagons [1,12] stores constraints ±x± y ≤ c where x and y are program variables and c is a constant. All domain operations can be performed in O(n3) time using O(n2) of memory, where n denotes the num- ber of variables. Using the domain of Pentagons [11] one can represent numerical intervals together with symbolic inequalities between variables of the form x < y. The complexity of domain operations is O(n2), but the authors do not present a satisfiability test (if a domain element describes a system of constraints with empty

y	y	y





x	x	x
(a)	(b)	(c)

Fig. 2. Pentagon (a), Weighted Hexagon (b), and TVPI (c) for the same set of concrete points.

set of solutions). The Two Variables Per Inequality (TVPI) abstract domain [13] is more powerful (it makes possible to represent ax+by ≤ c), but is also less efficient — the worst case time complexity is O(k2n3 log n(log n + log k)), where n denotes the number of variables and k can be as large as the maximal number of inequalities between a pair of variables (which, in case of TVPI, can be arbitrarily large). A comparison of Pentagons, TVPI and Weighted Hexagons can be found in Figure 2.

Paper Outline
Section 2 describes the representation of elements of the abstract domain and defines the join and meet operators and introduces a lattice structure using these operators. Section 3 presents an algorithm for checking satisfiability and computing a normal form of a given element of our domain. In Section 4 we provide a widening operator. The transfer function for the domain is discussed in Section 5. We conclude in Section 6.

Problem Definition
We are concerned with determining whether a system of constraints x ≤ a · y (where x, y are variables and a is some non-negative constant) is satisfiable or not. More formally: we are given a finite set of variables Var and a set I chosen to be the field of reals R or rationals Q with their natural order.
We consider a finite system I of inequalities of a form x ≤ a · y such that x, y ∈ Var and a ∈ I≥0, where by I≥0 we mean {a' ∈ I | 0 ≤ a'}. Note that we put an important limit on a, that is we only allow non-negative coefficients. This makes possible to maintain a nice geometrical interpretation of the constraints. When we
ask for satisfiability of such a system I, we in fact inquire whether there exists some valuation ρ : Var → I assigning numerical values to variables such that all constraints ρ(x) ≤ a · ρ(y) hold over I.
Additionally we want to restrict values of variables to certain intervals, that is to model interval restraints such as x ∈ [b, c] where b ∈ I ∪ {−∞} and c ∈ I ∪ {+∞} (with a premise that −∞ ≤ a' ≤ +∞ for all a' ∈ I; below we write just ∞ to indicate
+∞). In order to do that we introduce three artificial variables denoted as v−, v0 and v+ that can be assumed to be contained in Var. It should be taken for granted that v−, v0, v+ always admit values −1, 0 and 1, respectively. Everywhere below we

y y ≤ 2x

y ≤ 1 x
x


y ≤ x
Fig. 3. Region of possible solutions limited by pivotal inequalities y ≤ 2x and y ≤ 1 x.

narrow our attention to valuations ρ : Var →• I, where • indicates that ρ performs this fixed assignment on v−, v0 and v+. Now that we have defined helper variables, we can express conditions such as x ∈ [−5, 3] (say when I = R) as conjunction of inequalities: v− ≤ 1 x and x ≤ 3v+. Clearly, only a single inequality is derived in cases where x ∈ [b, +∞] (or x ∈ [−∞, c]). Observe that v0 is necessary to express inequalities of the form 0 ≤ x.
A system I may contain some redundant information. We are particularly inter- ested in paired constraints binding the same two variables, e.g. y ≤ 2x and y ≤ 1 x for I = R. Unless we have an extra knowledge about x and y (for instance that x and y are limited to positive values) we have to keep track of both inequalities. However, if we additionally had that y ≤ x then this constraint would be superfluous as can be seen in Fig. 3. Thus the y ≤ x inequality can be safely discarded. This justifies the approach of keeping only the pivotal polar constraints. Namely we establish two complementary functions s, l : Var × Var → I≥0 ∪ {∞, Nil} (s stands for the smallest, l for the largest) defined as


s(x, y) , min a ∈ I≥0 ∪ {∞} | inequality x ≤ a · y is in I
l(x, y) , max a ∈ I≥0 ∪ {∞} | inequality x ≤ a · y is in I}
(1)

with an arrangement that s(x, y) and l(x, y) are both equal to the special value Nil in case when I contains no inequality of the form x ≤ a · y (thus s(x, y) = Nil if and only if l(x, y) = Nil). We extend the standard multiplication in I≥0 on ∞ and Nil in the following way:
a · Nil = Nil · a = Nil	∞· a = a ·∞ = ∞ iff a /= 0	0 ·∞ = ∞· 0 = 0 

Using the above settings, we are interested in ascertaining a set of possible solu- tions γ with respect to s and l:
γ (s, l) , ρ : Var →• I | ∀	if s(x, y) /= Nil and l(x, y) /= Nil
then ρ(x) ≤ s(x, y) · ρ(y) and ρ(x) ≤ l(x, y) · ρ(y)  .
We refer to these sets as Weighted Hexagons throughout this paper.

Lattice Structure
Paired (s, l) constraints exhibit algebraic properties conforming to the lattice struc- ture. We state these properties more precisely in this subsection.
Let L be a subset of a Cartesian product	2 composed of exactly those pairs (s, l) for which γ (s, l) is not empty and for each x, y ∈ Var we have either s(x, y) = l(x, y) = Nil or s(x, y) ≤ l(x, y) (where neither s(x, y) nor l(x, y) is equal to Nil). Additionally, we let a special element ⊥ to be in L. Intuitively,
⊥ is a common representative for all empty Weighted Hexagons, i.e. (s, l) pairs with
γ (s, l) = ∅. We can thus make an arrangement that γ(⊥) = ∅.
We define two binary operations: greatest lower bound ∧ (a meet) and least upper bound ∨ (a join) that operate on pairs of elements from L. For this, we begin with two auxiliary order relations ≤Nil and ≤Nil on I≥0 ∪ {∞, Nil} that extend ≤:
a ≤Nil a' iff a ≤ a' or a' = Nil	a ≤Nil a' iff a ≤ a' or a = Nil .

Obviously, we can also introduce operators (that are denoted as min≤Nil and max≤Nil ; similarly for ≤Nil) for computing minimum and maximum of an arbitrary, yet finite, number of elements with respect to ≤Nil and ≤Nil orders.
Now for a, b ∈ L we have

a ∧ b , (sa∧b, la∧b)  if a = (sa, la) and b = (sb, lb) and γ (sa∧b, la∧b) /= ∅
⊥	otherwise,
where for all x, y ∈ Var functions sa∧b and la∧b are given by





Likewise
sa∧b(x, y) , min Nil sa(x, y), sb(x, y)	and
la∧b(x, y) , max≤Nil la(x, y), lb(x, y)  .
⎧⎪⎨(sa∨b, la∨b)	if a = (sa, la) and b = (sb, lb)

(2)

a ∨ b ,

where for all x, y ∈ Var
a	if b = ⊥
⎪⎩b	otherwise,



sa∨b(x, y) , max Nil sa(x, y), sb(x, y)	and
la∨b(x, y) , min≤Nil  la(x, y), lb(x, y) 
(3)

only in the case where max≤Nil sa(x, y), sb(x, y)  ≤ min≤Nil la(x, y), lb(x, y) , while
sa∨b(x, y) = la∨b(x, y) = Nil otherwise. An intuition, why we put this restriction, is
depicted in Fig. 4. The point a from Fig. 4(c) must belong to γ(a ∨ b), but does not fulfil the constraint min(la(y, x), lb(y, x)).
Notice that (sa∨b, la∨b) settles a non-contradictory system of inequalities, i.e.
γ (sa∨b, la∨b) /= ∅. This can be apprehended using the following lemma.
Lemma 2.1 For all a, b ∈ L we have that:


y	y
max(sa , sb )
a

x





(a)

(b)
min(la , lb )


(c)


Fig. 4. A hint why max(sa (y, x), sb (y, x)) ≤ min(la (y, x), lb (y, x)) is needed in the ∨ definition.
γ(a ∧ b) = γ(a) ∩ γ(b),
γ(a ∨ b) ⊇ γ(a) ∪ γ(b).
Note 1 Both ∧ and ∨ operators can be computed efficiently. This observation may seem to be obvious in case of intersection as the lemma above says that ∧ corresponds directly to this operation. However it is not that evident as in the definition of ∧ there is a check against emptiness of γ (sa∧b, la∧b) . However the algorithm we present in Section 3 below addresses this issue. It can decide, among other things, whether (sa∧b, la∧b) represents a satisfiable system of inequalities or not.
Now that we have listed the above key definitions, we can restate the property mentioned at the beginning of this subsection.
Theorem 2.2 Set L forms a lattice under ∧ and ∨ operators.
From the above theorem it follows that L can be viewed as a poset. In particular, the meet (or join) relation induces a canonical partial ordering on L:
a ≤ b	iff	a ∧ b = a	for all a, b ∈ L.	(4)

When I is chosen as R, then L with ∧ and ∨ form a complete lattice. In this case the concretization function γ uniquely defines an abstraction function α : P(Var →• I) → L as α(c) =  {a ∈ L | c ⊆ γ(a)} such that γ and α form a Galois connection [9].

Graph Model
A convenient way to represent a system of inequalities I is to use graphs. The correspondence between these two is quite straightforward and we favour the graph representation over the set of inequalities model. This allows us to apply a standard graph algorithm that can determine whether I is satisfiable and, in case it is, we can construct an explicit conforming valuation ρ. We define two weighted digraphs Gs = (V, E, s) and Gl = (V, E, l) with:
set of vertices V isomorphic to Var – each vertex is labelled with its own variable name (we can use notions of vertex and variable interchangeably). We also assume that V is ordered, i.e. it is isomorphic to {1 ... |Var|}.



1
2
x ≤ 2y x ≤ 5
−3 ≤ x
0 ≤ z






v− 3
y

z

1

v+	v

y




v− 3
z

1

v+	v



Fig. 5. A system of inequalities (a) and its graph representation Gs (b) and Gl (c).




sets of directed edges E such that (x, y) ∈ E iff I contains an inequality of the form x ≤ a· y for some a ∈ I≥0 (or, which amounts to the same, s(x, y) and l(x, y) are not equal to Nil),
weight functions s and l given by (1).
A typical pair of graphs Gs and Gl is depicted in Fig. 5.
We say that a variable u is positive if there exists a path ⟨v+, v0, v1,..., u⟩ in E . Similarly u is negative if there is a path ⟨u, w0, w1,..., v−⟩. For a given weighted di- graph G = (V, E, ω) we define product length πG (p) of a path p = ⟨v, v1, v2,..., vk, u⟩ as πG (p) = ω(v, v1) · ω(v1, v2) ··· ω(vk, u).





Satisfiability Testing and Normal Form

It may happen that multiple systems of inequalities have the same set of solutions. It is desirable to define a transformation that computes their normal form. This is indeed the aim of the Algorithm 1 we present below. It also solves another problem — the emptiness test. The Algorithm 1 allows determining whether a given system of inequalities is satisfiable.
The algorithm, for a = (s, l) and corresponding Gs, Gl as above, computes a variant of the transitive closure of the given inequalities. It is based on the well- known Floyd-Warshall algorithm [4] for computing shortest paths between all pairs of vertices in a graph. If the set of solutions γ (s, l)  for the given input graphs is empty, the algorithm returns False. Otherwise it computes a normal form a∗ , (s∗, l∗).
Algorithm 1 Execute the following steps:
Add to (s, l) reflexive information x ≤ x, trivial constraints v− ≤ 0 · x, v0 ≤ 0 · x
and x ≤ ∞· v+ and relations between v−, v0 and v+. To achieve this, we define

For k from 1 to |Var| we define:

(s0, l0)(x, y)	= (sin, lin)(x, y)
(sk, lk)(x, y)	= (min≤Nil (sk−1(x, y), sk−1(x, vk) · sk−1(vk, y)),
⎪⎩	max≤Nil (lk−1(x, y), lk−1(x, vk) · lk−1(vk, y))) .
Now, (sout, lout)(x, y) = (s|Var|, l|Var|)(x, y).
Fig. 6. Modified Floyd-Warshall (FW) algorithm for finding paths with smallest and greatest product lengths. The pair (sout, lout) denotes the computed output for the input (sin, lin).
(s', l') as:
0, max	(0, l(x, y))	if x ∈ {v−, v0}, x /= y




(s', l')(x, y) 6 =
s(x, y) = l(x, y) = Nil
(0, 1)	if x = y = v−



or y = v0, x ∈ {v−, v0}
⎪(1, ∞)	if x = y = v+

Find all positive variables. To do this, traverse one of the graphs (Gs or Gl), using a standard breadth-first search algorithm, starting from v+. Mark each visited node as positive. If v0 is reached, return False.
Find all negative variables: traverse Gs or Gl, but with reversed edges, starting from v−. If v0 or a node that was previously marked as positive is reached, return False. Mark each successfully visited node as negative.
For each pair of vertices, find paths with the smallest and greatest product lengths. We use here a modification of the Floyd-Warshall algorithm (FW) presented in Fig. 6 applied to (s', l'). Let (s'', l'') = FW(s', l').
Find cycles c and c˜ with product length πGs (c) < 1 and πGl (c˜) > 1: let X =
{v ∈ Var | s''(v, v) < 1} and Y = {v ∈ Var | l''(v, v) > 1}. If X contains positive variables or Y contains negative ones, return False.
For x ∈ X assign s''(x, x) = 0. For y ∈ Y assign l''(y, y) = ∞. For x such that l''(x, y) = 0 for some y, let s''(x, v0) = 0 and let l''(x, v0) = ∞. For x such that l''(x, y) /= 0 and s''(x, y) = 0 for some y, let s''(x, v0) = 0 and let l''(x, v0) = ∞.
Apply the algorithm from Fig. 6 to (s'', l'') and denote the output as (s∗, l∗). If there exist s∗(v+, v) = 0 (which corresponds to an 1 ≤ 0 · v) or l∗(v, v−) = ∞

6 We use a notation (s, l)(x, y) , `s(x, y), l(x, y)´.

(that represents v ≤ −∞), return False. Otherwise return True.
The generated normal form contains for each pair of variables the most restrictive constraints that are fulfilled by each solution of the input system. In the step i of the Algorithm 1 we add some trivial constraints that must be included in the normal form, but cannot be found while computing the standard transitive closure (performed in step iv) — they are not a consequence of the original inequalities. The steps ii and iii allow us to find variables the value of which must be positive (or negative). In the step iv we propagate the constraints, using the Floyd-Warshall algorithm. In step v we check if there exists a positive variable x and an inequality x ≤ a · x where a < 1 or a negative y and an inequality y ≤ b · y where b > 1. Such inequalities cannot be satisfied. As for the step vi, if there is a constraint x ≤ a · x where a < 1 and x is not positive, it can be iterated arbitrarily many times: x ≤ a · x ≤ a2 · x ≤ ... ≤ ak · x ≤    The path with smallest product length
between x and x is not well defined. To avoid this problem, we replace in s'' the
original inequality x ≤ a · x with x ≤ 0 · x. For a similar reason we replace in l'' inequalities of the form y ≤ b · y with y ≤ ∞ · y if b > 1. Finally we propagate the modifications, using the Floyd-Warshall algorithm once more in step vii.
The theorems stated below express the main properties of the Algorithm 1. We start with showing that it can be used as a satisfiability test.
Theorem 3.1 (Satisfiability Test) I is satisfiable if and only if the Algorithm 1 returns True for the corresponding pair of functions (s, l).
Proof. If the algorithm returns True, we can construct a valuation ρ : Var →• I that satisfies I in the following way:
if u is positive then ρ(u) = ∗ 1	(note that s∗(v+, u) > 0),
s (v+,u)
if u is negative then ρ(u) = −l∗(u, v−) (note that l∗(u, v−) < ∞),
ρ(u) = 0 in other cases.
Each inequality x ≤ ay from the original system I matches one of the following cases:
x, y are positive. Then ρ(x) = 1/s∗(v+, x) and ρ(y) = 1/s∗(v+, y). Because s∗(v+, y) denotes the smallest product length of all paths between v+ and y, we have that
s∗(v+, y) ≤ a · s∗(v+, x) .
Both s∗(v+, x) > 0 and s∗(v+, y) > 0 (because x, y are positive). Dividing both sides by s∗(v+, x) · s∗(v+, y) we get:
1	1
s∗(v+, x) ≤ a · s∗(v+, y) .
Hence ρ satisfies the inequality x ≤ a · y, that is ρ(x) ≤ a · ρ(y).
x, y are both negative. Hence ρ(x) = −l∗(x, v−) and ρ(y) = −l∗(y, v−). Because
l∗(x, v−) denotes the greatest product length of all paths between x and v−, it

holds that
a · l∗(y, v−) ≤ l∗(x, v−) .
Multiplying both sides by −1 we get
−l∗(x, v−) ≤ −a · l∗(y, v−) . and therefore the valuation ρ satisfies x ≤ a · y.
In other cases x is not positive and y is not negative. Hence ρ(x) ≤ 0 and ρ(y) ≥ 0. All coefficients in all inequalities are nonnegative and so valuation ρ satisfies x ≤ a · y.
A standard case analysis can be applied to show that if the algorithm returns False
then γ (s, l) = ∅.	2
The following theorem shows that if the algorithm returns True, then the com- puted output (s∗, l∗) is equivalent to the input (s, l).
Theorem 3.2 (Correctness) The computed output (s∗, l∗) has the same set of solutions as the input (s, l): ρ ∈ γ (s, l) iﬀ ρ ∈ γ (s∗, l∗) .
Proof. We show that no solution is lost and no new one is introduced. No solution is lost since the computed new weight of an edge should be obeyed anyway due to the transitivity of inequalities. No solution is introduced since all the inequalities in the result are not less tight than the original ones.	2
Now we can show that the output of the Algorithm 1 is indeed a normal form of all domain elements that have the same set of solutions.
Theorem 3.3 (Normal Form) If (s, l) is satisfiable then
inf≤{c ∈ L | γ(c) = γ (s, l) }
is well defined and equal to (s∗, l∗).
Proof. The pair (s∗, l∗) is in A = {c ∈ L | γ(c) = γ (s, l) } by Theorem 3.2. We then take any element of A and show that each of its elements after the normalisation with Algorithm 1 is still above (s∗, l∗).	2
A join of two Weighted Hexagons does not need to be a Weighted Hexagon. Our join operator (∨) computes only some over-approximation of the union of Weighted Hexagons described by its arguments (see Lemma 2.1). The following theorem shows that normalizing both arguments results in the smallest possible Weighted Hexagon:
Theorem 3.4 (Best Approximation) Normal forms a∗ and b∗ computed by the Algorithm 1 can be used to find the best over-approximation of γ(a) ∪ γ(b):
γ(a∗ ∨ b∗) = inf⊆{γ(c) | γ(c) ⊇ γ(a∗) ∪ γ(c) ⊇ γ(b∗)} .

Proof. We prove first the property
γ(a∗ ∨ b∗) = inf⊆{γ(c ∨ d ) | γ(a∗) ⊆ γ(c) and γ(b∗) ⊆ γ(d )} .
Then standard considerations give the required result.	2
Widening Operator
When a loop is encountered in a control flow graph of the analysed program, one may need to compute a fixpoint to find the corresponding abstract state. When the abstract domain used in the analysis is of an infinite height this may lead to infinite iteration process. To avoid this problem, widening operator was introduced [6]. It is used to compute an over-approximation of the fixpoint in a finite number of steps. Thus we need to define the widening operator for the Weighted Hexagons. Intuitively, if for a pair of variables x and y the second argument of the widening contains a weaker constraint than the first one, then the result does not contain a constraint for this pair. We define the widening operator o: L × L → L as:

aob ,
a	if b = ⊥,
⎪⎩b	otherwise,

where for any x, y ∈ Var:
if sb(x, y) ≤Nil sa(x, y) and la(x, y) ≤Nil lb(x, y) then:
saob(x, y) = sa(x, y)	and	laob(x, y) = la(x, y) .
saob(x, y) = laob(x, y) = Nil otherwise.
We have to show that o defined above is in fact a widening operator.
Theorem 4.1 Our operator o meets the definition of a widening operator:
for all a, b ∈ L  a ∨ b ≤ aob,
for every infinite sequence of abstract states c0, c1,.. ., sequence a0, a1,... defined as:
a0 = c0
ai = ai−1oci	for i > 0 
is not strictly increasing.
Proof. Direct examination of the required properties.	2
Note that one should not normalize the result of the widening (replace (saob, laob) with (saob, laob)∗). This may result in a potentially infinite increasing sequence a0, a1,... . Figure 7 presents a sequence c0, c1,.   that generates infinite increasing
sequence a0, a1,.. .. For simplicity, only a part of the Gs graph is presented (the variables v− and v0 are not shown). Note that using the widening operator without normalization, the sequence a' stabilises after the first step (Figure 7(e)).

y	y



x
2
(a) c0
y
z	x	z
2
(b) ci
y	y



22i
x
1
1	1
v+
2
(c) a2i
22i+1
z
22i+2
x
1
1	1
v+
2
a2i+1
22i+1
z


x


z
2
a∗ = a∗

1	2
Fig. 7. Normalization of the result of widening may give a strictly increasing infinite sequence.
Transfer Function
To apply an abstract domain to program analysis, one needs to specify how an abstract state is altered by each type of instruction. The transfer function must over-approximate the concrete semantics [6]. We show a few examples of how to model a test in the Weighted Hexagons. Let a represent a set of states before a test
e. We compute an over-approximation b of the set after the test:
{ρ ∈ γ(a) | ρ satisfies e}⊆ γ(b) .
For e = v1 ≤ c ∗ v2 we compute b as:

b =	⊥	if a = ⊥ or γ(b') = ∅
b'	otherwise,


where b' is defined as:
b'(x, y) =	sa(x, y), la(x, y)
min≤Nil (sa(x, y), c), max≤Nil (la(x, y), c)


if (x, y) /= (v1, v2)
otherwise.

Let us now consider an assignment w ← w +k for k > 0. Figure 8 shows the result of an assignment in a two-dimensional case. Note that the transfer function introduces some loss of precision — the computed Weighted Hexagon over-approximates the exact result of the operation (represented in Figure 8(b) as a dashed shape).
The whole transfer rule for an assignment is long and technical. For clarity and brevity we present here only the case when the added constant k is positive. The result b of an assignment, given a non-empty input a, is computed as follows:
for x, y /= w: b(x, y) = (s∗(x, y), l∗(x, y))
a	a

u	u
d	d




c	c
w
a	b
(a)

w
a + k	b + k
(b)


Fig. 8. Weighted Hexagon before (a) and after (b) assignment w ← w + k. The dashed shape represents the exact result of the assignment.


(	) = ⎪⎨(0, l∗(w, y)+ ∗
k − )	if l∗(y, v−) /= Nil, l∗(w, v−) /= Nil,

b w, y	a
⎪

la (y,v )
a
l∗(w, v−
a
) — k > 0

(Nil, Nil)	otherwise,
b(x, w) = (sb(x, w), lb(x, w)), where:

  s∗(x,w)·s∗(x,v+)

if s∗(x, w) /= Nil, s∗(x, v+) /= Nil

s∗(x, w)	otherwise,

	l∗(x,w)
if 0 < l∗(v−, w) < ∞, 1 — k · l∗(v−, w) > 0

· lb(x, w)=
1−k·l∗ (v−,w)	a	a

l∗(x, w)	otherwise.

Conclusion
We have described a new numerical abstract domain that represents inequalities of the form x ≤ a · y, between pairs of variables x, y with a being a non-negative constant, as well as interval constraints x ∈ [b, c], where b and c are arbitrary constants. It is an abstract domain that handles multiplication in a simple fashion. Let n denote the number of program variables. An abstract state can be represented with O(n2) worst case memory cost. The most time-consuming operations are the normalisation and satisfiability test, which use the Floyd-Warshall algorithm. Their worst case time complexity is O(n3). The domain of Weighted Hexagons lies between Pentagons and TVPI in terms of expressiveness and efficiency.
We plan to investigate how to extend the Weighted Hexagons to handle strict inequalities and work within the ring of integers. We are also working on an imple- mentation of an analyser for the Java language that uses our domain.

References
Balasundaram, V. and K. Kennedy, A technique for summarizing data access and its use in parallelism enhancing transformations, SIGPLAN Not. 24 (1989), pp. 41–53.

Blanchet, B., P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Miné, D. Monniaux and X. Rival, A static analyzer for large safety-critical software, in: PLDI ’03 (2003), pp. 196–207.
Bourdoncle, F., Abstract debugging of higher-order imperative languages, in: PLDI ’93 (1993), pp. 46–55.
Cormen, T. H., C. E. Leiserson and R. L. Rivest, “Introduction to Algorithms,” MIT Press, 1990.
Cousot, P., Design of syntactic program transformations by abstract interpretation of semantic transformations, in: Proceedings of the 17th International Conference on Logic Programming (2001),
pp. 4–5.
Cousot, P. and R. Cousot, Abstract interpretation: a uniﬁed lattice model for static analysis of programs by construction or approximation of ﬁxpoints, in: POPL ’77 (1977), pp. 238–252.
Cousot, P. and R. Cousot, Static determination of dynamic properties of recursive procedures, in:
E. Neuhold, editor, IFIP Conf. on Formal Description of Programming Concepts, St-Andrews, N.B., CA (1977), pp. 237–277.
Cousot, P. and R. Cousot, Systematic design of program analysis frameworks, in: POPL ’79 (1979),
pp. 269–282.
Cousot, P. and R. Cousot, Abstract interpretation and application to logic programs, J. Log. Program.
13 (1992), pp. 103–179.
Cousot, P. and N. Halbwachs, Automatic discovery of linear restraints among variables of a program, in: POPL ’78: Proceedings of the 5th ACM SIGACT-SIGPLAN symposium on Principles of programming languages (1978), pp. 84–96.
Logozzo, F. and M. Fähndrich, Pentagons: a weakly relational abstract domain for the eﬃcient validation of array accesses, in: SAC ’08 (2008), pp. 184–188.
Miné, A., The octagon abstract domain, Higher Order Symbolic Computation 19 (2006), pp. 31–100.
Simon, A., A. King and J. M. Howe, Two variables per linear inequality as an abstract domain, in: LOPSTR’02: Proceedings of the 12th international conference on Logic based program synthesis and transformation (2003), pp. 71–89.
