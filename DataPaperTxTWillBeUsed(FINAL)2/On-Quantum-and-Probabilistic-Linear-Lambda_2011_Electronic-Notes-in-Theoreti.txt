

Electronic Notes in Theoretical Computer Science 270 (1) (2011) 121–128
www.elsevier.com/locate/entcs

On Quantum and Probabilistic Linear Lambda-calculi
(Extended Abstract)
Benoˆıt Valiron1
Laboratoire d’Informatique de Grenoble, Universit´e Joseph Fourier, Grenoble, France

Abstract
In this paper we give a fully complete model for a linear probabilistic lambda-calculus. The model is a Kripke semantics based on the category of stochastic relations. We sketch how this relates to quantum computation.
Keywords: Probabilistic computation, quantum computation, Bell inequalities, linear lambda-calculus, Kripke semantics, completely positive maps, multinorm.

Introduction
Selinger and Valiron [6] gave a fully-abstract semantics for a linear quantum lambda- calculus using the category CPM of completely positive maps. This semantics is not surjective, and thus fails to distinguish between maps in the category that are denotations of a program and maps that are not.
A surjective semantics for the first-order case was provided in [4]. The semantics uses a notion of norm to determine which completely positive maps are denotations of terms; namely, these are precisely the trace non-increasing ones. However, the no- tion of norm fails to provide a suitable characterization of higher-order functions [5]. In this paper, we restrict our study to the probabilistic fragment of the language described in [6]. We characterize the image of the language using the notion of polytopes, and sketch how one can use such a result to characterize the information- theoretic power of quantum computation over probabilistic computation. Finally we provide a full and complete denotational semantics for a fragment of the probabilistic
linear lambda-calculus using an idea from Jung and Tiuryn [3].

1 Email: benoit.valiron@imag.fr

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.01.011

The linear quantum lambda-calculus
We recall the linear typed lambda calculus for quantum computation defined in [6]. The terms and the types are respectively the following:

M, N, P ::= x | λx.M | MN | ⟨M, N∗|∗| Ω | let ⟨x, y∗ = M in N |
let ∗ = M in N | if P then M else N | 0 | 1 | meas | new | U, A, B	::= A ⊗ B |T| A ( B | bit | qbit,
where x ranges over term variables. We remind the reader that Ω corresponds to the diverging term and we refer to [6] for the definition of the typing judgements.
This language is interpreted in the category CPM of completely positive maps [4]. The types are interpreted in the following way.
[[bit ]]= 1, 1,	[[qbit ]]= 2,	[[A ⊗ B]]= [[A ( B]]= [[A]] ⊗ [[B]].

In this extended abstract we only recall the definition of the Booleans 0 and 1 and refer the reader to [6] for the interpretation of all the terms: [[0]] = (1, 0) ∈ C2, [[1 ] = (0, 1) ∈ C2.
Using the language, it is possible to simulate a fair coin toss, for example with the program meas(H(new 0)) : ( bit , with H corresponding to the Hadamard gate. The interpretation of this term is ( 1 , 1 ). Using a similar technique (and
2 2
possibly using the term Ω), it is possible to get a term simulating an unfair coin
with denotation (a, b) where a, b ≥ 0 and a + b ≤ 1.
A probabilistic linear lambda calculus
We can modify the language of Section 2 to remove the quantum aspects and obtain a purely probabilistic language. For this, we only need to change the constants. We replace meas, new and U with a set of constants c(a, b), one for each pair of real numbers (a, b) such that a, b ≥ 0 and a + b ≤ 1. The types are modified by removing the type qbit .
We are left with the following terms and types:
M, N, P ::= x | λx.M | MN | ⟨M, N∗|∗| Ω | let ⟨x, y∗ = M in N |
let ∗ = M in N | if P then M else N | c(a, b) | 0 | 1, A, B	::= A ⊗ B |T| A ( B | bit.
In this context, the semantics in CPM of a term M is a completely positive map from vectors of Cm to vectors of Cn for some natural numbers m and n. Note that a completely positive map in this setting is the same as a (partial) stochastic map from [0, 1]m to [0, 1]n. The result presented in [6] specializes to this case and the semantics is fully abstract.

Interpretation of the Bell inequalities
The Bell experiment [1] is the following. Consider a quantum machine that maxi- mally entangles two quantum bits A and B
1
|φAB∗ = √2 (|0∗⊗ |1∗− |1∗⊗ |0∗)
and sends qubit A to Alice and qubit B to Bob. Suppose that Alice and Bob can independently choose one of the following three bases {a, b, c} for measuring their quantum bits:
1	√3	1	√3
|0a∗ = |0∗,	|0b∗ = 2 |0∗ + 2 |1∗,	|0c∗ = 2 |0∗− 2 |1∗,
√3	1	√3	1

|1a∗ = |1∗	|1b∗ =
2 |0∗− 2 |1∗,	|1c∗ = 2 |0∗ + 2 |1∗.

The question is to compute the probability of obtaining the same output when measuring A and B with respect to two different bases.
One can interpret this experiment in the context of higher-order quantum com- putation. First, the machine entangles two quantum bits: It produces a map EPR : T→ qbit ⊗ qbit . Then Alice and Bob each takes one qubit, chooses a basis, and measures: the measurement they perform is then a function f : qbit ⊗trit → bit , where trit = T⊕T⊕ T. One can curry this function to f j : qbit → (trit ( bit )
The algorithm can be described by the composition


EPR
f ′⊗f ′

T −−−→ qbit ⊗ qbit −−−→ (trit ( bit ) ⊗ (trit ( bit ).
The algorithm produces a term of type (trit ( bit ) ⊗ (trit ( bit ). This type is classical, and one can wonder whether the denotation of this term is the denotation of a term in the probabilistic linear calculus. The Bell inequalities precisely show that it is not the case. In other words, the terms expressible in the probabilistic linear lambda calculus correspond precisely to what is known to physicists as local hidden variable theories.
Consider a classical type A (that is, not containing qbit ). In the remainder of this paper, we shall develop a methodology for determining the vectors of [A]] that are representable by a term in the probabilistic linear calculus. This can be seen as a generalization of the Bell inequalities to any higher-order type.
Factorization of the probabilistic calculus
As in [2], a program written in the probabilistic linear lambda-calculus of Section 3 can be “factored” into a probabilistic sum of deterministic programs. That is, the denotation of any valid typing judgement Δ D M : A can be re-written as a probabilistic sum
[[Δ D M : A]] = Σ αi[[Δ D Ni : A]]
i


[[c(a, b)]]	= [if c(a, b) then 1 else 0]]
[[M (if c(a, b) then N1 else N2)]]	= [if c(a, b) then MN1 else MN2]]
[[⟨M, if c(a, b) then N1 else N2∗]]	= [[if c(a, b) then ⟨M, N1∗ else ⟨M, N2∗]] [[λx.if c(a, b) then N1 else N2]]	= [[if c(a, b) then λx.N1 else λx.N2]]
[[if (if c(a, b) then M else N ) then P else Q]]
= [[if c(a, b) then if M then P else Q else if N then P else Q]]

Table 1
Rewriting rules for the if -term.

where each αi ≥ 0 and i αi ≤ 1, and where Ni does not contain any constant term c(a, b).
The idea of the proof is the following: first, note that
[[Δ D if c(a, b) then M else N : A]] = b · [[Δ D M : A]] + a · [[Δ D N : A]].

Thus, for the result to be true, one needs to be able to send a term M containing a constant term c(a, b) to a term of the form if c(a, b) then M1 else M2 with same denotation, where M1 and M2 satisfy some invariant. Since the language is linear, this is possible. As a proof start, consider the equalities in Table 1 with orientation left-to-right.
Interpretation as polytopes
The deterministic terms (i.e. the ones with no occurrence of c(a, b)) share a special property:
Proposition 6.1 Given a typing context Δ and a type A, there is a ﬁnite number of deterministic terms Ni (up to beta-equivalence) such that Δ D Ni : A.
This proposition comes from the fact that the language is linear: one can enu- merate all the possible (CUT-free) typing derivations. One can go one step further:
Proposition 6.2 Any deterministic closed term of type A has a denotation of the

form (xi ,..., xi ) ∈ [[A]], where for all j, xi
is either 0 or 1.

It allows us to state the following theorem:
Theorem 6.3 The set of vectors in the set [[A]] that are the image of some linear probabilistic program through the denotation is a convex 0-1-polytope (i.e. whose vertices are of the form (x1,..., xn) ∈ [[A]], where each xi is either 0 or 1).
A few examples are given below:
The deterministic closed terms of type [bit ] are Ω, 0 and 1. That is, the polytope of admissible vectors is spanned by (0, 0), (1, 0) and (0, 1).

The deterministic closed terms of type [bit ( T ] are Ω, λx.if x then ∗ else Ω, λx.if xthen Ω else ∗ and λx.if xthen ∗else ∗. That is, the polytope of admissible vectors is spanned by (0, 0), (0, 1), (1, 0) and (1, 1).
The deterministic closed terms of type [[(bit ( T) ( T ] are of the form Ω, λf. let ∗ = f 0 in ∗ and λf. let ∗ = f 0 in ∗. That is, the polytope of admissible vectors is spanned by (0, 0), (1, 0) and (0, 1).
Polytopes are not compositional
The naive idea to develop a full and complete semantics for the probabilistic linear lambda-calculus is the following. Consider a category whose objects are polytopes and whose maps are CPM maps sending polytopes into polytopes. Then interpret the language in this category.
It turns out that this does not work. Indeed, if it were the case, the identity map C2 → C2 should be represented by a judgement x : (bit ( T) ( T D M : bit . However, the only deterministic closed terms corresponding to ((bit (T)(T)(bit are of the form λf. let ∗ = f (λx.if x then a else b) in c where c ranges over {0, 1} and where a and b over {∗, Ω}. The corresponding vertices are
(0, 0, 0, 0), (1, 0, 0, 0), (1, 0, 1, 0), (0, 0, 1, 0), (0, 1, 0, 1), (0, 1, 0, 0), (0, 0, 0, 1).
The identity map corresponds to the vector (1, 0, 0, 1), which is not in the polytope spanned by these vectors. The closest approximation is 1 (1, 0, 0, 1).
Thus, although polytopes provide a sound semantics, they are not sufficient to characterize the definable maps of the probabilistic language.

Toward a full and complete semantics for the proba- bilistic linear calculus
The polytopes we constructed are closed convex sets P containing the origin. Thus they define a norm via
||v|| = min{λ | v ∈ λP}.
We are going to extend the idea of norm to the work of Jung and Tiuryn [3], and define what we will call linear Kripke logical relations: instead of considering norms of single vectors, we consider the norm of tuples of vectors.
A toy language
Consider the following reduced version of the probabilistic linear lambda-calculus:
Term M, N ::= xA | ΩA | c(μ) | λxA.M | MN | if P then M else N,
Type A, B ::= bit | A ( B,
where 0 ≤ μ ≤ 1.

Linear Kripke logical relations
Consider a small category of sets C with the cartesian product as a monoidal struc- ture, containing the object T = { }. We are going to define a logical relation over each object w of C, asa norm || − ||w on tuples (xi)i∈w where xi ∈ [[A]] for all i ∈ w. The relation at ground type must satisfy the following compatibility property: if f : v → w is a map in C, then
w	v
||(xi)i∈w||bit ≤ 1	→	|(xf (i))i∈v||bit ≤ 1.
Also, still at ground type bit , the norm should satisfy the norm axioms:
w	w	w
||(xi + yi)i||bit ≤ ||(xi)i||bit + ||(yi)i||bit ,
||(xi)i||bit	≥ 0,
w	w
||(λxi)i||bit	= |λ|||(xi)i||bit ,
||(xi)i||bit	=0	iff	∀i	xi = 0.
Finally, one should have ||((a, b))||T	=	|a| + |b| We extend the relation

for higher types as follows:	||(gj)j∈w||w
is defined as the maximum of

′
||(gf (j)(xi))j⊗i∈w′⊗v ||B	, where f  : w
||(xi)i∈v||A ≤ 1.
→ w ∈ C, (xi)i∈v  ∈ [[A]] such that

We interpret (gf (j)(xi))j⊗i∈w′⊗v as the tuple (h(k))k∈w′⊗v where h is the map


f⊗id
−−−→
g⊗x
w ⊗ v −−→
єA,B
[[A ( B]] ⊗ [[A]] −−−→
[[B]]

T	w
We will write ||x||	for ||(x)|| . We call (|| − || )w∈|C|,A∈Type a norm with varying
A	A	A
arity.
Lemma 8.1 Given w ∈ |C| and a type A, the norm || − ||w satisﬁes the compatibility
property and the norm axioms.
Soundness
Lemma 8.2 (Soundness) For all closed terms M : A, ||[[M ]]||A ≤ 1.
The proof follows the idea developed in [3]. We define the notion of extended environment as a pair (φ, ρ) of partial maps, where φ : Var → |C| and where ρ is a map that assigns to a variable xA a tuple (xi)i∈φ(xA), with xi ∈ [[A]]. If Δ = {x1 : A1,..., xn : An}, we write φ(Δ) in place of φ(x1) ⊗ · · · ⊗ φ(xn). We define the extended interpretation of a typing judgement as a tuple
[[x1 : A1,..., xn : An ▶ M : A]]ρ,φ = (xi)i∈φ(x1)⊗···⊗φ(xn),
where xi ∈ [[A]] for all i, and where the domain of ρ and φ is the set {x1,..., xn}.
The proof of Lemma 8.2 is done by structural induction. We first show that for all typing judgements x1 : A1,..., xn : An ▶ M : B, for all extended environments

(φ, ρ) such that ||ρ(xi)||φ(xi) ≤ 1, the inequality
||[[x1 : A1,..., xn : An ▶ M : B]]ρ,φ||B	≤ 1 is satisfied. We then conclude by using the following result.
Lemma 8.3 Given an environment ρ, let φ¯ be the constant map of value { } and
let ρ¯ be the map assigning (ρ(xA)) to xA. Then [[Δ ▶ M : A]]ρ¯,φ¯ = ( [Δ ▶ M : A]]ρ).2
Completeness
The completeness result is obtained by choosing a carefully crafted category C. For each type A, denote by BA the canonical basis of [A]]. Define a category C as follows: objects are products BA1 ×· · ·× BAn , and arrows are the identities on objects.
Convention 8.4 When considering the set BA, we will use the implicit order (1,..., 0),..., (0,..., 1). We extend the order on BA1 × · · · × BAn using the lex- icographic convention.
Definition 8.5 Let UA1,...,An be the set of tuples
 ([[M ]](a1) ··· (an))(a1,...,an)∈BA1 ×···×BAn  ▶ M : A1 ( ··· ( An ( bit ,
Lemma 8.6 The set UA1,...,An is convex, and its interior contains the origin.
Proof. The convexity is shown using the denotation of the if and of the Ω term. The fact that the origin lies in the interior comes from the correspondence between first-order and higher-order types.	2
Lemma 8.7 Consider the tuple (xi)i∈BC1 ×···×BCk , where for all tuples i, xi ∈
[[A1 ( ··· ( An ( B]]. Then for all a ∈ BA1 ×	× BAn , the value xi(a1)	(an)
is equal to (xi)a1⊗···⊗an , the coordinate of xi at a1 ⊗	⊗ an. Moreover, its norm
BC1 ×···×BCk ×BA1 ×···×BAn	BC1 ×···×BCk
||(xi(a1) ··· (an))(a1,...,an)||B	= ||(xi)i||A1(···(An(B
Definition 8.8 Define the norm with varying arity (|| − ||w )w∈|C|,A∈Type at ground

types as follows: the unit ball of || − ||BA1 ×···×BAn is U
A1,...,An .

Lemma 8.9 (Completeness) Given x ∈ [[A]] such that ||(x)||A ≤ 1, there exists a closed term M such that [[M ]] = x.
Theorem 8.10 The element x ∈ [[A]] is representable by a probabilistic lambda term if and only if for all norms with varying arity (|| − ||w )w∈|C|,A∈Type , the norm
||(x)|| ≤ 1.
Conclusion
We considered the probabilistic fragment of the linear quantum lambda-calculus described in [6]. We interpreted the Bell inequalities in this higher-order context.

We sketched a method for computing generalized Bell inequalities at higher types, using convex polytopes.
The polytope interpretation does not provide a compositional semantics. Fi- nally, we drafted a compositional full and complete semantics for a fragment of the probabilistic linear lambda-calculus.
Acknowledgement
I would like to thanks Peter Selinger for suggesting the problem of characterizing the definable higher-order probabilistic functions, and for providing the counterexample in Section 7.

References
Bell, J. S., On the Einstein Podolsky Rosen paradox, Physics 1 (1964), pp. 195–200.
Danos, V. and R. S. Harmer, Probabilistic game semantics, ACM Transactional on Computational Logic
3 (2002), pp. 359–382.
Jung, A. and J. Tiuryn, A new characterization of lambda definability, in: Proceedings of TLCA’93, Lecture Notes in Computer Science 664, 1993, pp. 245–257.
Selinger, P., Towards a quantum programming language, Mathematical Structures in Computer Science
14 (2004), pp. 527–586.
Selinger, P., Towards a semantics for higher-order quantum computation, in: P. Selinger, editor,
Proceedings of QPL’04, TUCS General Publication No 33 (2004), pp. 127–143.
Selinger, P. and B. Valiron, On a fully abstract model for a quantum linear functional language (extended abstract), in: P. Selinger, editor, Proceedings of QPL’06, Electronic Notes in Theoretical Computer Science 210, 2008, pp. 123–137.
