

Electronic Notes in Theoretical Computer Science 265 (2010) 123–144
www.elsevier.com/locate/entcs

Towards Measurable Types for Dynamical Process Modeling Languages
Eric Mjolsness1
Department of Computer Science University of California Irvine, California, USA

Abstract
Process modeling languages such as “Dynamical Grammars” are highly expressive in the processes they model using stochastic and deterministic dynamical systems, and can be given formal semantics in terms of an operator algebra. However such process languages may be more limited in the types of objects whose dynamics is easily expressible. For many applications in biology, the dynamics of spatial objects in particular (including combinations of discrete and continuous spatial structures) should be formalizable at a high level of abstraction. We suggest that this may be achieved by formalizing such objects within a type system endowed with type constructors suitable for complex dynamical objects. To this end we review and illustrate the operator algebraic formulation of heterogeneous process modeling and semantics, extending it to encompass partial differential equations and intrinsic graph grammar dynamics. We show that in the operator approach to heterogeneous dynamics, types require integration measures. From this starting point, “measurable” object types can be enriched with generalized metrics under which approximation can be defined. The resulting measurable and “metricated” types can be built up systematically by type constructors such as vectors, products, and labelled graphs. We find conditions under which functions and quotients can be added as constructors of measurable and metricated types.
Keywords: biological models, dynamical systems, master equation, measureable type, metricated type, operator algebra, process modeling language, stochastic processes, stochastic semantics

Introduction
Modeling complex biological systems is a substantial challenge that requires the integration of ideas from many subfields of science, mathematics and computing. For applications in “computational morphodynamics” [4], the local dynamics of form in biology and elsewhere, the dynamics of spatial objects (including mixtures of discrete and continuous spatial structures) requires integration of models from geometry, physics, biochemistry, dynamical systems, and stochastic processes. An arena where this integration can occur is in formally defined modeling languages that incorporate heterogeneous dynamics: discrete, continuous, deterministic, stochas- tic, and spatial paradigms for dynamical systems. As shown for example by the

1 Email: emj@uci.edu

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.08.008

“Dynamical Grammars” (DG) process modeling language, these objectives can be achieved by defining formal semantics in terms of an operator algebra of stochas- tic processes. DG’s comprise a language with defined syntax and semantics [14], first implemented as an embedded language by the “Plenum” package [21] for the Mathematica computer algebra system.
In pursuit of biological applications, a natural sequence of generalizations to pro- cess models have been encountered. The simplest processes are essentially chemical reactions, in which a few input objects meet and are converted into some other out- put objects. These reaction proceswes are assembled into network models. Chemical reactions can be modeled deterministically, for example using differential equations that evolve real-valued concentrations, or they can be modeled more accurately as stochastic processes. Essentially the same models are used in elementary population genetics, where the “molecules” are actually organisms in one or more genetically defined species. In both cases, the next escalation involves giving state attributes (such as position or internal state) to the reacting objects. As modeled in DG’s, the resulting state attributes can evolve in discrete stochastic jumps or continuously via differential equations. In this way, local information processing within and between neighboring cells can be very flexibly modeled, but the evolution of the cell-cell neighborhood relationships themselves requires further topological and geometric expressiveness.
A useful plateau of biological expressiveness is reached with the encoding of graph grammars within DGs, which enables the simulation of variable-structure dis- crete spatial models such as stem cell niche models with biomechanics [21]. Further spatial abstraction and expressiveness, such as manifold and non-manifold contin- uous dynamic geometries encountered in developing biological tissues and organs, will require improved support for labelled graphs and continuous spatial object types, perhaps by introducing powerful type construction mechanisms as proposed below. However, this is not as easy to do in an operator algebraic process mod- eling language as in a programming language owing to the need for integration of operators over the values of each type, and possibly for distance functions that can quantify the approximation of one value by another, as we will show. So we seek type constructors for spatial modeling which are amenable to the operator algebra formulation of dynamics.
This paper is organized as follows. In the remainder of Section 1 we exhibit a dynamical grammar for a biological model, and define notation. In Section 2 we review the operator algebra approach to defining the semantics of process modeling languages, as it has been applied in the particular case of Dynamical Grammars. In Section 2.2 we review the existing DG mechanisms for generalized reactions or rules, including systems of differential equations, acting on parameterized terms; in each case we exhibit the operator expressions for the modeling language semantics. We also show how type polymorphism may be expressed in DGs. In Section 2.3 we consider extensions to DG semantics for graph grammars and for general (possibly stochastic) partial differential equations, the latter by means of operator functional integrals as an infinite limit. In Section 2.4 we summarize dynamical process se-

mantics and formulate the integration criterion for new type constructors, which requires that types must be measurable.In Section 3 we consider extensible types built by means of primitive types and type constructors. Section 3.2 describes the existing DG type constructors (vectors, products, and labelled graph container ob- jects encoded using product types). As a step forward in Section 3.3 we consider intrinsic labelled graph types, followed by the more difficult cases of functions and quotients. Finally we collect a set of well known observations that together define a sufficient condition for the formation of measurable product types, and likewise formulate a set of properties for object types that in principle allow them to be subjected to quotient operations. These properties include measurability, but also various quantification conditions that are weaker than metrizability. These points are summarized in Section 4.

Syntax
Briefly, a dynamical grammar consists of a header followed by an unordered set or multiset “ ... ” of generalized reactions or rules, each representing a process. Each rule has a left hand side (LHS), an arrow, a right hand side (RHS), followed by a keyword (in this paper, keywords are in boldface), followed by additional algebraic syntax depending on the keyword. LHS and RHS consist of multisets of parameterized terms. The header begins with the keyword “grammar”, followed by the name of the grammar (so that grammars can invoke one another recursively using rules with appropriate keywords), followed optionally by allowed input and output object multisets in the form of an LHS→RHS rule.

Example: Olfactory epithelium stem cell niche model
A model similar to that of [21] for the regeneration of odorant-sensing neurons in mouse olfactory epithelium can be expressed as a dynamical grammar. Let the parameterized term “cell  x    ” represent a cell with discrete cell type label χ 1, 2, 3 χmax , d-dimensional position x, volume v, and growth inhibitor concentration φ. Then the grammar could be written as follows:
grammar Epithelium {
/* cell replication with or without differentiation : */

cell[χ ∶ N, x ∶ Rd,V ∶ R,φ ∶ R] —→ cell[χ + Δχ1, x + Δx,V /2, φ],
cell[χ + Δχ2, x − Δx,V /2, φ]

with
ρˆ(V )P (Δχ1 ∶ N, Δχ2 ∶ N∣χ, φ)N (Δx ∶ Rd; cV 1/d)
×Θ(χ < χmax)Θ(Δχ1 ∈ {0, 1})Θ(Δχ2 ∈ {0, 1})



/* cell death : */


cell[χmax, x,V, φ] —→∅ with γ

/* cell growth, dependent on cell type χ : */

cell[χ, x,V, φ] —→ cell[χ, x,V + dV, φ]
solving	{ dV = kΘ(χ < χmax)+ kς(V )Θ(χ = χmax)}

/* symmetric cell-to-cell diffusion of growth inhibition signal φ : */

cell[χ1, x1, V1, φ1], cell[χmax, x2, V2, φ2]
—→ cell[χ1, x1, V1, φ1 + dφ1], cell[χmax, x2, V2, φ2]
solving	{ dφ1	= D(∣∣x1 − x2∣∣, (V1V2)1/(2d))  (φ2 − φ1)}

/* signal production, dependent on cell type χ, and degradation : */

cell[χ, x,V, φ] —→ cell[χ, x,V,φ + dφ]
solving	{ dφ = k′Θ(χ = χmax)− λφ}
}
Here ρˆ, D, and ς are nonnegative monotonic bounded functions of their argu-
ments; P and N are conditional probability distributions (in particular  .; σ is the normal distribution with mean zero and standard deviation σ); c, k, k ,γ, and λ are nonnegative real-valued constants; and Θ is the 0/1-valued Heaviside step function on a predicate Q. “x τ ” introduces a parameter x with type τ , and com- ments are set off as /* ... */. The first rule states that cell division cuts cell volume in half, leaves growth inhibitor concentration fixed, jostles the positions slightly while preserving center of mass, and leaves cell type either constant or increased by one step along an irreversible path from “stem cell” to “transit-amplifying cell” to “neuron”. This process generates discrete events in continuous time happening with a specified probability per unit time. There are also processes that occur over a continuous duration of time, given by the differential equations shown in the solving clauses. An additional solving rule (not shown) can change the position of cells in response to crowding by their neighbors.
Many of the foregoing rules could be split up into multiple rules. For example the first rule could equivalently be replaced by the more elementary rules:
stemcell[x ∶ Rd,V ∶ R,φ ∶ R]→ stemcell[x + Δx, V , φ], stemcell[x − Δx, V , φ]


with
2	2
ρˆ(V )Pstemcell(0∣φ)N (Δx; V 1/d)

stemcell[x,V, φ]→ TAcell[x + Δx,V /2, φ], stemcell[x − Δx,V /2, φ]
with	ρˆ(V )Pstemcell(1∣φ)N (Δx; V 1/d)
stemcell[x,V, φ]→ TAcell ∶∶ cell[x + Δx,V /2, φ], TAcell[x − Δx,V /2, φ]
with	ρˆ(V )Pstemcell(2∣φ)N (Δx; V 1/d)

and likewise three more rules for TAcells giving rise to TAcells and/or neurons.

Notation
Notation is as follows.	represents a function evaluated with ordered arguments x, y, .... On the other hand τ x, y, ... with square brackets represents an object of type τ that retains all the information in parameters x, y, and so on. It may be thought of as a syntax tree with root node τ and ordered children x, y,
.... Also	is an unordered set, and		with an asterisk subscript is an unordered multiset, i.e. a function from the set x, y, ... to the positive natural numbers specifying “how many times” each element occurs in the set. In addition to the standard set-builder notation x P x  for defining the members of a set based on a predicate P , we will build ordered sets (tuples or lists in the finite case) using square brackets:		. More generally,		imposes the image of a preexisting ordering of the index set onto any elements  selected for inclusion by the predicate . Similarly,	is a shorthand for		1
1	N  which is in turn a shorthand for	. Θ	1
if  is true, otherwise 0 is the Heaviside function on predicates.	Θ	is the Kronecker delta function.   .; σ is the normal distribution with mean zero and standard deviation σ. In case of type ambiguity (eg. for type inference or dynamic typing) we use the notation	to indicate that variable has type , and the notation	to indicate that  returns a value of type  . Similarly,
τ1  τ2 indicates that τ1 is a subtype of τ2.  Metalanguage syntax is as follows.
Macro expansion or evaluation is indicated by the function-like notation: μ〚 〛.
Substitution of an expression s for an unbound variable x in a term t is denoted
t⟪x ↦ s⟫.

Defining Processes
We now describe the semantics of processes. Most of the technical descriptions in this section up through Section 2.2, and also Section 3.2.2, are lightly edited excerpts from [14], which is the primary source for the ideas presented in these sections of the paper.

Time-evolution operator semantics
The “master equation” for the continuous-time evolution of probabilities is:
dp(t) = W ⋅ p(t)	(1)

where p t is the joint probability distribution over all possible states of the system at time t. The semantics of a model is given by the operator W , which specifies a stochastic process. These stochastic processes can be specialized to deterministic dynamics as well as shown below. The model operator W can be composed by simply adding up operators Wr that correspond to parallel, interacting subprocesses

indexed by r:

W = ∑ Wr	(2)


Simple process operators Wr can be built out of products of elementary process operators by which objects of specified type and state are created or destroyed. The semantics of a product of operators is an infinitely rapid sequence of changes taking zero time. Scalar multiplication can speed up or slow down a given process. Thus, we are concerned with at least the algebraic structure of a ring of operators that act linearly on probability vectors. All of this is analogous to the operator algebras encounted in quantum mechanics and quantum field theory, except that
only classical probab√ilities need be used. Quantum semantics would be obtained by
inserting a factor of	−1 in Equation 1, obtaining the Schr¨odinger equation.
The semantics of a modeling language such as Dynamic Grammars is given by the procedure by which its process expressions can be converted into time evolution operators Wr. The resulting continuous-time dynamics can be related to a discrete- time dynamics in which composition is somewhat more complicated.
Stochastic process operator semantics for modeling languages, including the mas- ter equation for time evolution and measures for product types, was proposed in [13] and elaborated in detail in [14]. The master equation was proposed independently for a “small stochastic process algebra” in [3]. Stochastic semantics for the “kappa” rule-based modeling language [5,6] was also proposed in [7].

Current DG Semantics
We first review those aspects of Dynamical Grammar semantics that have been pre- viously defined and, with the exception of polymorphism, implemented in Plenum.


Chemical reactions
Consider the chemical reaction:
Amax




(r)




k(r)








Amax




(r)


a=1
ma  Aa	—→

b=1
nb  Ab	(3)

Applications of this kind of process model are legion in biochemistry, population biology, and cellular systems biology.
We can translate this information into a stochastic process obeying the master equation, by defining a suitable operator W algebraically in terms of elementary annihilation and creation operators aa(i) and aˆb(j) obeying the Heisenberg algebra
aiaˆj aˆjai  δij or variants thereof. The general principle is : destroy all the objects
on the left hand side (LHS) of the rule, and instantaneously thereafter, create all the objects on the RHS. The operator expression of this principle for chemical reactions

is:
Oˆr = k(r) ⎧⎨⎪ ∏
aˆb(j)⎫⎬⎪ ⎧⎨⎪ ∏
aa(i)⎫⎬⎪

.	(4)

⎩j∈rhs(r)	⎭⎩i∈lhs(r)	⎭

This operator is off-diagonal and represents the flow of probability into a new state. We must also represent the compensating flow of probability out of the old state, Dr  diag 1T Oˆr (where the matrix notation is that 1T is the transpose of the column vector all of whose elements take the value one, and “diag” converts the resulting row vector into a diagonal matrix), resulting in a net operator Wr  Oˆr Dr. If there are many reactions indexed by r in a reaction network, their operators Wr add up as in Equation 2. The result is a stochastic model of mass action kinetics for each reaction and for the whole reaction network.
An alternative notation for the reaction in Equation 3 could be a multiset rewrite

rule: {m(r) × A ∣m(r) > 0}
—k(→r)
{n(r) × A ∣n(r) > 0}
, where n×x means that object

x occurs n times in the multiset.
It is conventional in biochemical network models to reduce higher-order reactions to those with just one or two inputs (unimolecular or bimolecular reactions) by splitting up reactions, so that ∑ m(r) is a small integer. Likewise ∑ n(r) is typically
a small integer. Thus, the total amount of computational work that has to be done “instantaneously” in Equation 4 is a small constant. The same principle can be applied in the more expressive parameterized reactions below. The analogous expressions represent interaction vertices for Feynman diagrams in quantum field
theory, where they also have low total degree: ∑(m(r) + n(r)) is usually 2, 3, or 4.

Parameterized reaction
A minimal generalization of chemical reaction notation is to allow the chemical species or “types” to be indexed by static parameters in a reaction
{τa(i)[xi]∣i ∈ IL}∗ —→ {τa′(j)[yj]∣j ∈ IR}∗with	ρr([xi] , [yj])	(5)
This syntax can be used to formulate dynamical models of stateful objects like cells, molecular complexes, or covalently modified proteins such as those with multiple
phosphorylation sites. Here ... ∗represents a multiset, and with is a keyword introducing the probability per unit time ρr that the specified discrete event will
occur instantaneously at a particular moment in real-valued time. Assuming that the parameter expressions x, y contain no variables Xc, the time-evolution operator for each individual reaction is:

Oˆr = ρr ([xa] , [yb]) ⎧⎪⎨ ∏	aˆj(b)([yb])⎫⎪⎬ ⎧⎪⎨ ∏	ai(a)([xa])⎫⎪⎬

(6)

⎪⎩b∈rhs(r)	⎪⎭ ⎪⎩a∈lhs(r)	⎪⎭
Note that there are now separate creation and annihilation operators for every possible value of the parameter list xa - all acting on the same very large Fock space, defined in Section 3.2.2 below.
However, a much more useful rule would be a rule schema with many possible values for some of its parameters, obtained by making the parameter expressions be a function of some variables. If there are variables {Xc}, we must sum or integrate

over all their possible values in a suitable measure space Ⓒc Dβ(c):


Oˆr
Dj(1)

...
j(k)

... (∏ dμj(k)(Xk)) ρr( [xa([Xk])] , [yb ([Xk])] )

× ⎧⎪⎨ ∏	aˆj(b) (yb([Xk]))⎫⎪⎬ ⎧⎪⎨ ∏	ai(a) (xa([Xk]))⎫⎪⎬

(7)

⎪⎩b∈rhs(r)	⎪⎭ ⎪⎩a∈lhs(r)	⎪⎭

For example, some object types could be parameterized by position and veloc- ity vectors; others by rotation matrices. Different measures would be required to integrate over these different kinds of parameters.
The nonnegative real-valued reaction rate	is given by an algebraic expression in a typed language	R, and denotes a function in a Banach space	V of real-valued functions defined on the Cartesian product space V of all the value
spaces Va(i) of the terms appearing in the rule. Depending on the norm used in the Banach space	it may be possible to formulate rate functions that grow without
bound as a function of their arguments, and allow in principle for an infinite amount of computation to be done in a finite time. In that case, not all models formulate- able with Dynamical Grammars are effectively simulate-able in finite time on Turing machines.
We assume that there is a typed language  that constrains the parameterized terms xi occurring in the rules. The essential feature of  P is that it includes a set of function symbols with defined input and output type signatures. These function symbols represent type-supported operations on the typed constants, variables Xk, and typed parameter expressions  in   . The typed parameter expressions  may
appear in the parameter lists of LHS and RHS terms τa(i) xi , and as arguments to the rate functions ρr. In this way, algebraic data types make contact with
algebraic time-evolution operators. Rate functions ρr xi , yj  ultimately relate the domain-specific types to nonnegative real numbers that specify process rates.
Each parameterized term τa(i) xi or τa′(j) yj  is of type τa and its parameters
xi take values in an associated (ordered) Cartesian product set Va of da factor
spaces chosen (possibly with repetition) from a set of base spaces	Dβ β . Each Dβ is a measure space with measure μβ. Particular Dβ may for example be isomorphic to the integers Z with counting measure, or the real numbers R with

Lebesgue measure. The ordered choice of spaces Dβ
the type signature {γak ∈ B∣1 ⩽ k ⩽ da} of type τa.
in Va
da
β=γ(ak)
k=1
constitutes


Polymorphism
Polymorphic argument type signatures are supported by defining a derived type signature	from factor space compatibilities ˜	1
k	da,β	. For example we can regard Z as a subset of R. Then we can define the overall ability to cast type τb as a subtype of type τa using a 0/1-valued matrix

σab:

δab ≤ σab ≤ Θ(∃mapping lb(k)∣ ∧1≤k≤da σ˜akγ(bl(k,b)))

Some freedom is present in the choice of σ, with which various different polymor- phism schemes could be implemented. Let	be the map	whose existence is assured by σab 1 (if it is so). Let λ˜ab Vb Va be the associated linear projection operator, which drops parameters in b having no counterpart in a, We parameterize

the nullspace of λ˜ by z	Vb′
m∈{1,...db}∧m∉Im(lb)
Dβ=γ(bl), and let πV ′ ∶ Vb → Vb′ be

the projection operator complementary to ˜. We define	′	so that
λ ○ (λ˜, πVb′ ) = id(Vb). We will eliminate extraneous values of Va from consideration
with Heaviside step functions Θ xi Xc	Im λab	0, 1 .
Then the time-evolution operator expression Equation 7 for the rule of Equation 5 becomes


Oˆr
Dβ(1)

...
β(c)

... (∏ dμβ(c)(Xc)) ρr( [xi([Xc])] , [yj([Xc])] )

× ⎛ ∏  Θ(xi([Xc]) ∈ Im(λ˜ab))⎞ ⎧⎪⎨ ∏
aˆa(j)(yj([Xc]))⎫⎪⎬

⎝i∈lhs(r)	⎧⎪
⎠ ⎪⎩j∈rhs(r)
⎪⎭	⎫⎪

× ⎪⎨⎪ ∏ [∑ σb(i)d ∫V ′ dz ad(λ(xi([Xc]), z))]⎪⎬⎪ .  (8)
⎪⎩i∈lhs(r)	d	d	⎪⎭
Note that	1 is reflexive and can be chosen to be antisymmetric, hence defining a partial ordering “ ” on types. We say  is a subtype of . The type ordering is related to substitutability: If	then expressions of type can be substituted for variables of type τa in language P without type violation, at least in covariant contexts such as the foregoing rule semantics. In this semantics, subtyping is used only on the LHS and not the RHS of a rule. Subtyping polymorphism is
not supported in the Plenum implementation of Dynamical Grammars; instead, subtyping of “cell types” was hand-coded using graph grammar rules (see Section 2.3.1 below) along with extra parameter-bearing objects representing the subtype memberships.
This version of Equation 8 is corrected from that of [14], which included σ but omitted consideration of the map λ˜.

Graph grammar rules
In [14], labelled graphs were encoded using parameterized terms by devoting the first parameter of each term to an integer-valued Object Identifier (OID), and using some of the other parameters to hold the OIDs of other graph-linked objects. In this way graph-grammar rules could be systematically translated into parameterized- grammar rules.
Already the OID translation of graph grammar rules may be used to implement conventional Abstract Data Types (ADTs) such as lists in terms of pointer data structures such as doubly linked lists.  Using the Heisenberg algebra of creation

and annihilation operators, it is possible to algebraically verify the ADT relation between inserting and removing an item in such a list: insertion followed by deletion should yield the identity operation.
Differential equations (ODE, SDE)
The system of Langevin equations
dxi = v ([x ]) + η (t)	(9)

are stochastic if the continous stochastic process ηi t 0 given by Stochastic Dif- ferential Equations (SDEs); otherwise they specialize to a system of ordinary dif- ferential equations (ODEs). It may be recast as a time-evolution operator by using differential operators:

Oˆdrift = − ∫ d {x} ∫ d {y} aˆ([y])a([x]) (∑∇yi vi([y]) ∏ δ(yk − xk))	(10)
	
Oˆdiffusion = ∫ d {x} ∫ d {y} aˆ([y])a([x]) ⎛∑∇yi ∇yj Dij([y]) ∏ δ(yk − xk)⎞ (11)
⎝ ij	k	⎠
Consequently, process reactions or rules that syntactically incorporate ordinary dif- ferential or stochastic equations may be given semantics. The ODE version of this possibility has been implemented in Plenum [21] and results in a very flexible kind of hybrid system for biological models.
In the current Plenum implementation of DGs only very specific partial differ- ential equations (PDEs) are supported: diffusion equations with constant, isotropic D.
Algorithms for simulation and learning
Probably the most surprising aspect of the operator formulation of dynamics is that finite, computationally tractable algorithms can be found for sampling from the resulting probability distributions and indeed can be derived systematically. For stochastic discrete event processes, the Dyson series or “time-ordered product expansion” can be used to systematically derive simulation algorithms. In particular if one considers off-diagonal elements as a perturbation, this method can be used to rederive Gillespie’s Stochastic Simulation Algorithm [22,14] and its generalization to parameterized terms. Other operator splittings yield other algorithms including hybrid ODE/discrete-event solvers [21]. In addition, parameter inference algorithms can be derived for this power series approach [20,22]. Thus even when all operators used are infinite objects, finite and effective algorithms can be derived from them.
Proposed DG-like Semantics
Graph grammar rules
In [14], labelled graphs were encoded using parameterized terms using unique integer-valued Object Identifiers (OIDs). However, there was no “intrinsic” graph

type constructor or graph grammar dynamics in the language. We now suggest such a dynamics.
Suppose that with consistent node indexing i1, i2, ... we wish to rewire the small graph g as the new small graph g′, where a, b range over the same sets of nodes. Represent these graphs by 0/1-valued adjacency matrices, and suppose the node labels are λa a and λ′a a before and after rewriting. Then the rewriting operator deletes all the old edges and nodes labels, if they exist in exactly the pattern required
by g and λ, and replaces them with the corresponding new edges and node labels:

1
Or	k!

(aˆ


icid
)g′ cd ][ ∏


aˆicλ′c

][	∏


(aiaib
)gab ][ ∏


aiaλa ]

{i1,...ik} c,d∈rhs(r)
c∈rhs(r)
a,b∈lhs(r)
a∈lhs(r)
(12)

This semantics automatically generalizes to multigraphs as well, by allowing gab N. The summation implies a search for matching graph structures which is considerably reduced if the input graph g has relatively unique node labels λ.
In this way, graph rewrite rules may be made intrinsic to a graph type or type constructor rather than just being encoded by OIDs. Graph type constructors can be used to build other container types including lists, trees, and so on. One danger with an expression such as Equation 12 is that the product of operators may grow to more than just a handful of operators, so that the amount of computational work that must be done “instantaneously” at each event is bounded by a larger constant. The number of operators multiplied together grows with the size of the graph fragments being rewritten.
Partial differential equations (PDE’s) and stochastic PDE’s
We may translate partial differential equations and stochastic partial differential equations of general form into the operator algebra, by relating PDE’s and SPDE’s to large systems of ODE’s and SDE’s, and taking the limit symbolically. Nontrivial analysis may be needed to confirm whether the indicated limits really exist or not in any given case [9,10].
Consider the following (possibly stochastic) PDE :

∂Φ(x)
∂t

F [Φ] (x)= F (Φ(x),
∂Φ(x) , ...,
∂x
∂nΦ(x))+ ( )	(13)

where x may be a scalar or a vector, and likewise for Φ. We define a translation to (Equation 9 and Equation 10) using Table 1.
With this table of translations, the drift and diffusion operators for PDE’s and SPDE’s become
Odrift = − ∫ ∫ DΦDΦ′ aˆ(Φ′)aτ (Φ) (∫ dx 	δ	 F [Φ′] (x) Δ(Φ′ − Φ))	(14)


and


′	′	δ2	′

Odiffusion = D ∫ ∫ DΦDΦ aˆ(Φ )aτ (Φ) (∫ dxδΦ′(x)2 Δ(Φ
– Φ)) .	(15)

Table 1
Ordinary vs. Partial differential objects
Ordinary differential object	Partial differential object
d/dt	∂/∂t
i ∈ N	x ∈ R
xi	Φ(x)
yi	Φ′(x)
∂/∂xi(partial derivative)	δ/δΦ(x) (functional derivative) D (homog. scalar diffusion coef.) D (homog. scalar diffusion coef.) δ(y − x) = ∏ δ(yi − xi)		Δ(Φ′ − Φ) = ∏ δ(Φ′(x)− Φ(x))
i	x
∫ dxg(x) (ordinary integral)	∫ DΦG[Φ] (functional integral)
aτ (x) = aτ ([xi])	aτ (Φ) = aτ (x ↦ Φ(x))


where

Δ(Φ′ − Φ) = limσ→0 ∏ N (Φ′(x)− Φ(x); σ)
≡ limσ→0 exp ∫ dx log(N (Φ′(x)− Φ(x); σ))

This gives another potential application of the time-ordered product expansion which can be used to create simulation algorithms.
With suitable PDE’s it becomes possible to represent dynamically changing manifolds, either by differential equations for the metric as in General Relativity, or for an explicit embedding into a higher dimensional space, or for an implicit embedding given by a function f (x)= 0 (a level set method).

Discussion of dynamics
Table 2 summarizes the increasing DG capabilities called for by various keywords that can appear in the generalized reaction or rule syntax. Recursive process models are available through the “via” and “substituting” keywords and their semantics, which are analogous to subroutine calls and macro substitutions respectively. An essential point in the semantics is that repeatedly, greater expressivity is achieved by taking limits that yield object types and processes of higher (finite or infinite) cardinality. Examples include infinite limits of the maximum number of molecules of each type, the number of values each parameter can have, the precision of a numerical parameter, and the cardinality of allowed index sets for collections of parameters.
Equation 7 and Equation 10 above involve sums or integrals over the values taken by a variable of some particular type. Equation 12 can be regarded as a sum over variables whose types are nodes and links in a graph data type. Technically, the values of the integrands are operators in the Fock space defined in Section
3.2.2 below, which means that even integrals over infinite domains integrate up to operators whose nonzero real-valued elements are each the summed reaction rates ρr of all fully redundant copies of some rule. This quantity can be restricted to be finite, usually just a process rate times a small integer. Such integrals are typically encountered in the Lagrangian functionals of quantum field theory, where the integration parameters are taken to include particle momenta.

Table 2
DG keywords and the notation they introduce


What is essential for each semantic operator above is the capability to inte- grate over the various required domains of integration, i.e. over the values taken by the typed variables. The reason is that variable-binding in the process syntax corresponds to integration in the operator semantics. Integration in turn requires a measure with which to integrate, defined on a measure space. Thus, the operator algebra approach to dynamics requires measurable data types.

Defining Object Types
Language
Type-specific subsets of the language	P of Section 2.2.2 may have variables, func- tion symbols, relation symbols, and quantifiers as usual, or they may be more con- strained for a particular type. Logic may be classical or intuitionistic. Real-valued function expressions are needed to specify process rates. Relations are functions taking values in a truth-value space Ω, which for classical logic is the Boolean alge- bra on		. Constraints on processes can be specified by predicates. The typed language	shares some similarities with for example the typed “local language” in [2]. However, a type expression component of the language	P is not yet for- malized since we don’t yet know what function and power type constructors may
be measurable.
We will allow axioms expressed in P to be associated with types and type constructors. For example, the axioms for object types arising in “universal algebra” (such as groups and rings but not fields) would be equational laws, universally quantified.

Existing types
Primitive types
The primitive types for modeling include numbers: minimally, the integers Z and the real numbers R (or finitely computable approximations thereof). In each case it is important that there is a standard algebraic structure (a ring or field supporting arithmetic operations), a standard topology, a standard measure, and a standard

distance metric. Specifically the integers have the discrete topology, the uniform measure, and can be integrated over by summation; the real numbers have the topology generated by open intervals, the associated Borel measure, and Lebesgue integration; and both have distances defined by d x, y x y that generalize to Euclidean distance in vector spaces over the respective primitive types. For many applications including quantum mechanical ones, the complex field C should also be taken as a primitive type. Integration is essential for the operator representation of dynamics, and distance measures enable controlled approximations.
Thus the expressions in the language  involving a primitive type include variables of type  (denoted	or	etc ), functions such as	and distance dist x, y , the equality relation =, as well as the integration linear func- tional . Given integration it is possible to define distributions or generalized functions including the delta “function” satisfying  δ x, y f x dx  f y . This is the Kronecker delta function for integers and the Dirac delta function for reals.

Vector and product types
Type constructors generate new types from old ones. Standard type constructors in mathematically defined programming languages may include type sums, products, powers, and function types, and we will also include quotient types. Here we describe the type constructors already present in Stochastic Parameterized Grammars and therefore in Dynamical Grammars: vector and product types.
Vector spaces Rd or Zd of fixed finite integral dimension d 0 over R or Z have addition, subtraction, equality, scalar multiplication, distance and integration de- fined as usual. Distance is defined by the additivity of squared Euclidean distances; integration is defined by multiple integration. In addition, linear transformations on vector spaces may be defined by their action on a vector basis. This fact distin- guishes a vector space from a general product type, though it is a specialization or subtype thereof. Other non-primitive types that support	R-scalar multipli- cation,  , and dist ., . can also serve as the substrate for d-dimensional vectors.
In defining Dynamical Grammars and SPGs (Stochastic Parameterized Gram- mars: DG’s without differential equations or differential operators), the notation for instances of product type τ was τ x1, ..., xn where the parameters xi could be values or instances of different types according to a type signature. The type signa- ture for τ is of course the same for all instances. In particular the parameters could be instances of the foregoing primitive types and/or vector types over primitive types. In the case  1, we have an alternative notation of an object of type . Generically τ [x1, ..., xn] are called parameterized objects.

For product types
i∈I⊆N
τi, a Fock space was constructed in [14] within which

one can represent the probability distribution over numbers of objects of each type, taking into account the indistinguishability of objects of the same type and same parameter values, as follows. Each value space Va is a measure space, with a σ- algebra of “events” on which probability is to be defined. A probability distribution
on a measure space X is just a (nonnegative) measure P on the σ-algebra for which
P (X)= 1. We may construct a probabilistic version of a many-particle “symmetric

Fock space” following [15]. Given a nonnegative integer na we may define the set of states that have a total of na “copies” of grounded parameterized term τa(xa):
na
fa na	Va	na .
m=1
Here n is the symmetric group on n items. The quotient is taken with respect to equivalence classes of Cartesian-product members that differ only by a permutation of na items. A new σ-algebra is induced on the space fa na by the Cartesian product operation and the symmetrization operation. Next, any finite nonnegative number na of terms are allowed in a disjoint union of measure spaces fa na , and the construction is repeated in a cross product over for all term types a:
∞
fa = Ⓒ fa(na) and f = Ⓒ fa
na=0	a
Now f is a measure space (since it has an induced σ-algebra) and thus defines a
probabilistic Fock space  as the set of probability distributions defined on f .
Products types with parameters of the same product type, or otherwise recur- sively defined product types, are accommodated in DG’s indirectly by way of graph grammars, with graph links represented by equality of unique integer-valued object identifiers (OIDs) defined at various positions in the parameter list as described in Section 2.3.1. This encoding was needed due to the lack of function or power types that could more naturally represent relationships.

Labelled graph types
A de facto type constructor is given by the OID encoding of labelled graphs de- scribed in Section 2.3.1. Here we exhibit a syntax extension for such labelled graphs.
The OID label or address symbols Oidλ(i) denote OID-typed variables taking unique values in a discrete domain such as the nonnegative integers. The graph is related to two subgraphs of neighborhood indices	and ′  specific to the input and output sides of a rule. Unique OIDs are maintained, so that  and λ′ j are injective maps on nonnegative integers i  and j  . A rule in a graph grammar then takes the form

{Oidλ(i) ∶= τi[xa(i); [OidN(i,σ)∣σ ∈ 1..σmax]]∣i ∈ I}

—→ {Oid
∣i ∈ I1 ⊆ I} ∪ {L ′
∶= τj[x′ ′( ); [L ′
∣σ ∈ 1..σmax ]]∣j ∈J }
(16)

λ(i)
with	ρr([x′ ′
λ (j)
] , [xa(i)])
a j	N (j,σ)
a′(j)

as explained in [14]. Nodes in the LHS and RHS graphs are parameterized types τi xa(i) . Links in these two graphs are specified by repetition of the same value for an Oid variable occurring on the left of a “:=” symbol and on the right of one or more “:=” symbols, all on the same side (either left or right) of the rule arrow “—→”.

Such rules have been used in models of the regulated growth and cellular dif- ferentiation of the filamentous cyanobacterium Anabaena catenula, the root of the plant Arabidopsis thaliana, and the mouse olfactory epithelium [21]. Translation of such rules to the syntax and semantics of Equation 5 is shown in [14]. It uses
both product types such as τi[Oidλ(i), xa(i), [OidN(i,σ)∣σ ∈ 1..σcur]] and vector types

such as [Oid
∣ ∈ 1
cur]	i

resulting parameterized terms could possibly conflict with others of the same type name and signature, not involved in representing graphs.
Rules of this form allow graphs whose nodes are parameterized terms
of one or more types τi   to undergo local rewriting operations, conditioned on their graph connections to other such terms. Thus, we have a de facto “graph type constructor” that takes in a set of types   and produces a new container type.
Using polymorphism it may be possible, as in many programming languages, to replace the set of types  with a single base type τbase for the nodes in the graph. And of course given graphs one can implement many other container types, such as
trees and arbitrary-length lists, though not in a type-safe manner. So it would be preferable to have graph types supported rather than just encoded in the modeling language, as we discuss in the next section.



Proposed type constructors

Function types	are needed for dynamics of geometry among other application areas, and quotient types τ  are needed for mathematical abstraction. There are a number of obstacles to creating function and quotient types with the properties needed for the operator algebra formulation of dynamics. In this section we review a few well-known concpts that collectively may indicate a way forward for function and quotient types.
We will begin, however, with labelled graph types.


Labelled graph types
Given a set of types  , for example a base type τbase and all of its subtypes, we would like to create a graph (or tree or list) type whose nodes are labelled by objects whose types are in  . The semantics of Section 2.3.1 shows the kind of transformations required; what is still needed is suitable syntax for specifying labelled graphs on the LHS and RHS “directly” and in a permutation-invariant way, rather than through a redundant encoding. Similar to an abstract data type, such labeled graphs would not be “built” out of sets or pointers but rather manipulated algebraically. Beginning with the primitive “α λ  β” for a pair of nodes labelled by α and β connected by a link labelled by λ, we can use a “Merge” operation (a macro taking any number of arguments) which equates nodes that share labels to

build up small graphs directly, so that for example
Merge〚α —λ→ β, β —μ→ γ, γ —ν→ α〛 = α  λ /β /.	(17)
,,,	μ
ν ,, J 

Here the labels α, β, λ, μ, ... represent constants or variables, taking typed val- ues for which equality can be tested (for example they may represent integers). Merge〚...〛 is a macro, which is evaluated before the DG model is simulated, mapped
to its semantics, or analysed.  Other basic graph-producing macros may be de-
fined as well. Labels can be further controlled with a relabelling macro operation “ nodelabelmap; linklabelmap ” where  is a labelled graph and the label maps specify substitutions acting on label expressions in  . For example, nodelabelmap for integer-valued labels might take the form i  f 〚i〛. Such maps can be used to erase label distinctions among nodes and edges, potentially increasing the automor-
phism group of a labelled graph. For very small graphs, 2D layouts such as the RHS of Equation 17 can be written directly. With such a language we obtain symbolic expressions representing labelled graphs, in such a way that the expressions can oc- cur in the LHS or RHS of a rewrite rule. In the absence of link labels the semantics of such a rule can be given by Equation 12. In the presence of link labels, a similar operator expression can be given or else the node- and link-labelled graphs can first be translated into purely node-labelled bipartite graphs.
As an example of such a graph rewrite rule, one might have a pair of cells sharing a common “face” which is to be divided into two different subfaces:

( 1 → 3 ← 2 ) ⟪[cell(c1), cell(c2), face(φ0)] ; ∂⟫
⎛	cc 4 ,,,¸, ⎞
⎜	ccc	,,,,	⎟
—→ ⎜ 1 cc	2 ⎟ ⟪[cell (c ) , cell (c ) , ∅, face (φ ) , face (φ )] ; ∂⟫

,,,,
,,
1	2	1	2
cc
cc

⎝	,z5 zc jc  ⎠
A Dynamical Grammar that also uses the graph rewriting capabilities called for here and in Section 2.3.1 may be termed a “Dynamical Graph Grammar”. Exam- ples of related frameworks in which one of the graph link types is used to formal- ize containment relations between biological structures include P-systems [18] and stochastic bigraphs [11]. In addition Finite Element Method (FEM) geometries and other discretized manifold or nonmanifold geometries (eg. cell complexes) can be represented with suitable labelled graphs. However, to represent continuous limits of such geometries also requires function types, discussed in the next section. For reflective or meta-modeling, labeled graphs can be used to represent commutative diagram specifications of axioms, and also graphical models of probability distri- butions.  Simple meta-rules were demonstrated in [21].  Like any discrete space,

discretely labelled graphs can be given a counting measure.

Function types
Product, function, and power types can all substantially raise the cardinality of the (finite or infinite) objects they represent or approximate, and can therefore be computationally problematic. Integrating a functional over a domain consisting of real-valued functions introduces new complications not present in finite-dimensional multiple integration, since Lebesgue measure is not available in infinte-dimensional vector spaces. Instead one may use the Wiener measure which is defined in terms of a diffusion stochastic process, or more generally the “abstract Wiener space” measure on any separable Banach space [8,17], if a suitable norm has been defined. There are several plausible topologies for function spaces, including strong (derived from the norm) and weak. Linear operators, required for meta-modeling and a natural next step in the type progression, have even more topologies that generalize the topology of finite matrices: norm, weak, strong, ultraweak, ultrastrong, and so on. So ideas of topology, measure, and integration each split up into several different generalizations in infinite dimensional settings.
Thus each function type requires in principle a verification that a measure suit- able for integration can be defined. If the domain of the function is Z or Zd then the uniform measure and the discrete topology can be used. If the domain is R or Rd then we can use the Wiener measure which is natural when spatial locality is reflected in processes that permit local diffusion. More generally if a suitable norm, separable Banach space, and embedded separable Hilbert space can be defined, then we can use the abstract Wiener measure. In this way, definitions of norm and in- ner product (or distance) can serve as essential stepping stones towards defining measure, in the case of types in infinite dimensional function spaces.
Since a separable topological space is one that contains a countable dense subset, and since the product of at most c separable spaces is separable (where c  R is the cardinality of the continuum) [16], the function types admitted above cannot be iterated indefinitely without further constraint to restore separability.

Quotient types
Quotient types, formed by taking equivalence classes modulo an equivalence rela- tion, have the potential to lower cardinality, mitigating the problems introduced by function types. They are essential to defining abstractions. But quotients may introduce computational problems when equivalence is hard to determine. Thus, the relation of equality (=) between instances of a type may be augmented by a separate, coarser internal equivalence relation ( ) to keep the equality of abstract types computationally tractable by representing separately the accumulated equiv- alences that can’t easily be computed. A motivating example of a quotient space is the space of differential manifolds, which is usually defined in terms of atlases of coordinate charts (with transition functions), modulo a “compatibility” equivalence relation between atlases.
Coarser and finer equivalence relations may be defined using distance metrics

and related concepts. A real-valued distance metric obeys the axioms of (A1) non- negativity	0, (A2) identity	0	, (A3) symmetry
, and (A4) the triangle inequality	. Implicitly there is also (A5) finiteness d x, y	. These axioms can be relaxed in various useful ways. Dropping (A3) results in a “quasimetric”, which can be symmetrized to give a metric by either + or maximum operations. Relaxing (A2) to x  y  d x, x  0 gives a “pseudometric”. Dropping (A5) results in an “extended” metric. Several of these omissions may be combined.
The extended pseudoquasimetric (or extended quasipseudometric) was advo- cated in [12] for its categorical properies under the quotient operation. One key point is that the Hausdorff metric is a symmetrized version of a pseudometric be- tween sets in a metric or pseudometric space; such sets can be taken to be the equivalence classes under an equivalence relation, . In this way, the pseudometric property can be preserved when one takes the quotient by an equivalence rela- tion. The same argument applies in the more general case of a quasi-pseudometric. Unfortunately pure metrics, satisfying axiom (A2) along with the others, are not generally preserved under quotients. Also metric spaces are first-countable (have a countable local base topology), in contrast to unrestricted function spaces such as R R. Consequently, we won’t insist on a tight relationship between distance metrics and topology.
To show that the triangle inequality persists for asymmetric Hausdorff dis- tances between equivalence classes 〚x〛, 〚y〛 etc of variables x, y, etc. is stan- dard: D(〚x〛, 〚z〛) ≡ supx∈〚x〛infz∈〚z〛d(x, z) ⩽ supx∈〚x〛infy∈〚y〛infz∈〚z〛(d(x, y) + d(y, z)) ⩽ supx∈〚x〛infy∈〚y〛d(x, y) +infy∈〚y〛infz∈〚z〛d(y, z) ⩽ supx∈〚x〛infy∈〚y〛d(x, y)
+supy∈〚y〛infz∈〚z〛d(y, z) ≡ D(〚x〛, 〚y〛)+ D(〚y〛, 〚z〛)  .

Properties of metricated types
In addition, distance metrics and the foregoing relaxations of them can serve to define topologies and measures, as we have seen, and can directly serve our criterion of model approximation. So we may propose the following set of properties as essential to objects types τ simulatable with dynamical grammars:
(P1) a set of functions and relations within the language P whose type signa- tures include type τ , among them equality (=) defined on objects of the type τ ;
(P2) a list of immediate supertypes ′ - i.e. information to determine ’s position in the type ordering   ′;
(P3) a measure μτ , and an associated extremal distribution δτ (x, y);
(P5) functions d+,τ (x, y) and d−,τ (x, y) such that:
(P5b)		are extended pseudoquasimetrics, i.e.	they satisfy axioms (A1), (A4), and	0 ;
(P5c) the upper function d+,τ (x, y)satisfies (d+,τ (x, y)= 0)⇒ (x ≈τ y);

(P5d) the lower function	satisfies	0 ; (P6) a set of type-specific axioms in LP .
Such a type τ will be called metricated, to distinguish from the stronger claim of “metrizable” (with a Borel measure) and the weaker claim of “measurable”.
Note that if	for metricated type  then	0	, which is a version of axiom (A2) with equality replaced by . Also, (A1) and (A4) and (x =τ y) ⇒ (d±,τ (x, y) = 0) imply that (d+,τ (x, y) = 0)∧ (d+,τ (y, x) = 0) and
−,τ	−,τ
trivial lower and upper bound candidate distance-like functions as a default, in case
no serious use is to be made of them, for example in defining the required measure.
Given a new equivalence relation defined on a metricated type , the quotient type τ  is defined as follows. Measure μτ /∼: the pushforward measure, as for example when Lebesgue measure on R maps to (Lebesgue) measure on the unit circle 1. Equivalence relation  : closure of	, so that
and x τ y	x τ /∼ y . If	is coarser than τ , then this closure τ/ is just . Upper and lower extended pseudoquasimetrics: can be taken as the nonsymmetric version of Hausdorff distance, possibly loosened for tractability:	〚 〛 〚 〛 supx∈〚x〛infy∈〚y〛d±,τ (x, y), for equivalence classes 〚x〛 and 〚y〛 under ∼ , subject to
axioms (P5). Equality   : must be an equivalence relation on  , satisfying
. For example, we may take
0)∧ (d+,τ (y, x)= 0)) since the latter is an equivalence relation and since (x =τ y)⇒ 
+,τ	τ	τ /∼
This approach to quotient types is in the spirit of “setoids” [1], though with
ideas of “generalized metric space” (explored much further in e.g. [19]) added. The idea is that computing equivalence or “actual” distance may be intractable, but computing some upper and lower bounds on distance can be made tractable. It may also be that verifying proofs of equivalence in particular cases is much more tractable than deciding equivalence.
Thus we see that an object type must support measure and integration, and object type constructors can do this through the use of several kinds of norms and distances including extended pseudoquasimetrics. The generic object data type may take values in some measurable, quasimetric space. Conditions sufficient for the construction of function types and quotient types are given above.
Conclusions
Process modeling languages with operator algebra semantics can be augmented with type constructors to create objects and processes at successively larger scales as well as greater levels of abstraction. Vector, product, and graph type constructions are straightforwardly available, and recursively related processes can be defined as well. However, function types and quotient types are more subtle. We give conditions under which they can be defined, but we do not know how often these constructions can be iterated before the conditions are necessarily violated.
A dynamical model may now be defined by a “workspace” containing a combi-

nation of dynamical grammar specifications, which define processes, and nontrivial object type declarations. These grammars and user-defined types are syntactic ob- jects upon which a semantics is defined. They can be regarded as constant values (not varying over time) denoted by their names, in which case there is a clear sepa- ration between syntactic expressions and dynamical objects. But there could also be time-varying dynamical grammars and/or types, whose discrete-time or continuous- time dynamics is given by suitable metagrammars.
Acknowledgement
Discussions with Christophe Godin, Przemek Prusinkiewicz, and Guy Yosiphon were helpful in this work. Research was supported by NIH R01 GM086883 and P50 GM76516.

References
G. Barthe, V. Capretta, and O. Pons. Setoids in type theory. Journal of Functional Programming, 13(2):261–293, March 2003.
J. S. Bell, Toposes and local set theories, Chapter 3, Oxford U. Press 1988. Dover reprint 2008.
L. Cardelli. A process algebra master equation. Proc. Fourth International Conference on the Quantitative Evaluation of Systems, QEST 2007.
V. Chickarmane, A. H. K. Roeder, P. T. Tarr, A. Cunha, C. Tobin, E. M. Meyerowitz. Computational Morphodynamics: A modeling framework to understand plant growth, Annu. Rev. Plant Biol. 61:65-67, 2010.
V. Danos, J. Feret, W. Fontana, and J. Krivine. Scalable simulation of cellular signaling networks. In Zhong Shao, editor, APLAS, volume 4807 of Lecture Notes in Computer Science, pages 139{157. Springer, 2007.
V. Danos, C. Laneve. Formal molecular biology. Theoretical Computer Science 325(1), 69–110 (2004).
J. Feret, H. Koeppl, T. Petrov. Stochastic fragments: A framework for the exact reduction of the stochastic semantics of rule-based models. 2009. URL http://infoscience.epfl.ch/record/142570? ln=fr, last accessed 6/2010.
Gross, Leonard (1967). Abstract Wiener spaces. In Proc. Fifth Berkeley Sympos. Math. Statist. and Probability (Berkeley, Calif., 1965/66), Vol. II: Contributions to Probability Theory, Part 1. Berkeley,
Calif.: Univ. California Press. pp. 31–42. MR0212152
G. Johnson and M. Lapidus, The Feynman integral and Feynman’s operational calculus. Oxford U. Press 2000.
H. Kleinert, Path integrals in quantum mechanics, statistics, polymer physics, and financial markets.
World Scientific 2009.
J. Krivine, R. Milner, and A. Troina, 2008. Stochastic Bigraphs. Electron. Notes Theor. Comput. Sci. (ENTCS) 218 (Oct. 2008), 73-96. DOI= http://dx.doi.org/10.1016/j.entcs.2008.10.006.
F. W. Lawvere. (1973, 2002), Metric spaces, generalised logic, and closed categories, In Reprints in Theory and Applications of Categories, 1, pp. 1–37, 2002.
E. Mjolsness. Stochastic process semantics for dynamical grammar syntax: an overview. In: Ninth International Symposium on Artificial Intelligence and Mathematics, Fort Lauderdale, Florida, 4-6 January 2006 (http://anytime.cs.umass.edu/aimath06/ last accessed 6/2010); also arXiv:cs.AI/0511073v1, 20 Nov 2005.
E. Mjolsness, G. Yosiphon. Stochastic process semantics for dynamical grammars. Annals of Mathematics and Artificial Intelligence 2006, 47:329-395.
M. Reed and B. Simon. Methods of modern mathematical physics: Functional analysis I. New York: Academic Press, 1972.

K. A. Ross and A. H. Stone, Products of Separable Spaces, The American Mathematical Monthly, Vol. 71, No. 4 (Apr., 1964), pp. 398-403
D. Stroock (2008). Abstract Wiener Space, Revisited. Communications on Stochastic Analysis, Vol. 2, No. 1 (2008) 145-151.
A. Spicher, O. Michel, M. Cieslak, J-L. Giavitto, and P. Prusinkiewicz (2008) Stochastic P systems and the simulation of biochemical processes with dynamic compartments. BioSystems 91: 458-472.
S. Vickers, Localic Completion of Generalized Metric Spaces I, Theory and Applications of Categories, Vol. 14, No. 15, pp 328-356, 2005.
Y. Wang, S. Christley, E. Mjolsness and X. Xie. Parameter inference for discretely observed stochastic kinetic models using stochastic gradient descent, submitted manuscript.
G. Yosiphon. Stochastic parameterized grammars: Formalization, inference and modeling applications. PhD thesis, Department of Computer Science, University of California, Irvine, May 2009. URL: http:
//computableplant.ics.uci.edu/~guy/downloads/DGPublications.html, last accessed June 2010.
G. Yosiphon, E. Mjolsness. Towards the inference of stochastic biochemical network and parameterized grammar models. In Learning and Inference in Computational Systems Biology. Edited by Lawrence ND, Girolami M, Rattray M, Sanguinetti G: MIT Press; 2009.
