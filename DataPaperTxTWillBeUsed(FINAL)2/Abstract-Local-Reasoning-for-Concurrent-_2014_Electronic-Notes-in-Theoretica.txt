Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 308 (2014) 147–166
www.elsevier.com/locate/entcs

Abstract Local Reasoning for Concurrent Libraries: Mind the Gap
Philippa Gardner1, Azalea Raad1, Mark Wheelhouse1 and Adam Wright1
Department of Computing, Imperial College London, UK

Abstract
We study abstract local reasoning for concurrent libraries. There are two main approaches: provide a specification of a library by abstracting from concrete reasoning about an implementation; or provide a direct abstract library specification, justified by refining to an implementation. Both approaches have a significant gap in their reasoning, due to a mismatch between the abstract connectivity of the abstract data structures and the concrete connectivity of the concrete heap representations. We demonstrate this gap using structural separation logic (SSL) for specifying a concurrent tree library and concurrent abstract
predicates (CAP) for reasoning about a concrete tree implementation. The gap between the abstract and concrete connectivity emerges as a mismatch between the SSL tree predicates and CAP heap predicates. This gap is closed by an interface function I which links the abstract and concrete connectivity. In the accompanying technical report, we generalise our SSL reasoning and results to arbitrary concurrent data libraries.
Keywords:  Concurrency, Abstraction, Refinement, Separation, Translation, Reasoning


Introduction
Local reasoning was first introduced in separation logic to reason about the RAM memory model. Since then, there has been considerable work on combining lo- cal reasoning with abstraction. There are two main approaches. One approach starts with concrete reasoning about code that manipulates the standard heap and then builds up layers of abstraction: this approach is used by concurrent abstract predicates (CAP) and its variants [1,16,17], and is ideal for reasoning about the concurrent library java.util.concurrent where the library functions are built up using implementations. The other approach provides direct abstract specifications of abstract code manipulating abstract models, and then justifies the specification by reﬁning it to a correct concrete implementation: this approach is used by context

1 Email: {pg, azalea, mjw03, adw07}@doc.ic.ac.uk

http://dx.doi.org/10.1016/j.entcs.2014.10.009
1571-0661/© 2014 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/3.0/).

logic [7,9], and is ideal for reasoning about libraries such as POSIX and sequential DOM where the library specification is not grounded on implementation.
These current abstraction and refinement approaches have a significant gap in their reasoning. With abstraction, the implementation details leak into the ab- straction. For example, consider a CAP predicate tree(t)(i, j)(l, u, r) for describing tree fragments. The predicate is parameterised by an abstract tree t, with con- crete pointers (i, j)(l, u, r) describing the concrete interface used to connect the concrete tree fragments. In this case, the concrete interface consists of the first (i) and last (j) nodes of the tree fragment, and the parent (u), left (l) and right (r) siblings. A different implementation, say one using lists, would require a differ- ent concrete interface. Thus, this tree predicate is not abstract enough to reason abstractly about updating tree fragments 2 . The missing piece is an abstract way of splitting and combining tree fragments, and a way of linking it to the concrete interface given by (i, j)(l, u, r). With the refinement approach, we have examples where the specification is truly abstract (e.g. [12,19]), but they are typically justified by a soundness result to an operational semantics rather than an implementation. For example, truly abstract reasoning of a tree module (such as DOM) works with predicates based on connecting tree fragments using contexts and place holders. In contrast, the concrete reasoning about an implementation uses pointers. We need to bridge the gap between the abstract connectivity of abstract data structures and the concrete connectivity of concrete heap representations.
We introduce Structural Separation Logic (SSL) for reasoning about concurrent abstract data libraries [2,19]. SSL is underpinned by a particular general approach to abstract connectivity for structured data. In this paper, we use a simple concurrent tree library to illustrate our ideas. We provide concrete reasoning about a tree implementation of the library using CAP [1]. The gap between the abstract and concrete connectivity emerges as a mismatch between SSL tree predicates and CAP tree predicates. This gap is closed by an interface function I which links the abstract and concrete connectivity. In the accompanying technical report [18] and Raad’s forthcoming thesis, we generalise SSL and our results to arbitrary structured data libraries. The work presented here does depend on the particular SSL approach to abstract connectivity. Our ideas should, however, apply whenever there is a mismatch between abstract and concrete connectivity.
SSL supports reasoning about fine-grained abstract data fragments stored in abstract heaps. Abstract heaps contain cells identified by abstract addresses (e.g. address x) whose values are the disjoint data fragments. These data fragments contain context holes, also given by abstract addresses, which are place holders for the data fragments found at the appropriate abstract cells. For example, the SSL predicate ATree (t)(x) describes a tree cell with abstract address x contain- ing tree context t. We can split (abstractly allocate) this predicate to obtain the

2 The same issue arises with the well-known predicate listseg([1, 2, 3])(i)(r) which describes list fragments with concrete address i, abstract contents 1, 2, 3, and concrete right pointer r. This predicate is appropriate for implementations using singly-linked lists, but not for those using doubly-linked lists which require an additional concrete left pointer. The predicate is not abstract enough because the concrete interface is leaking into the predicate. The missing bit is the abstract connectivity of the list fragment.

semantically-equivalent assertion ∃y. ATree (t1)(x)∗ ATree (t2)(y) with t = t1[t2/y]. The assertion represents the same underlying tree fragment, just in two disjoint parts. Reasoning about semantically-equivalent assertions is only possible due to recent advances in concurrent reasoning given by the Views framework [6].
We provide a natural implementation of our tree library and show that it is correct with respect to our abstract SSL specification, by relating abstract SSL specifications of the library functions with CAP-like specifications of the concrete function implementations. To do this, we must extend CAP predicates with a inter- face function I which relates abstract addresses with concrete pointers. For exam- ple, consider the abstract tree predicate ATree(t)(x) and the corresponding concrete CAP predicate CTreeI (t)(x), where the interface function I relates the abstract ad- dress x with the pointer interface (i, j)(l, u, r). We prove that our implementation is correct with respect to our abstract specification, using a ∗-preserving translation (analogous to locality-preserving translation in [9]) parameterised by I.
In this paper, we concentrate on refinement. It is trivial to adapt our work to the approach of fictional separation logic (FSL) [13], where translations are in- corporated within the Hoare derivation. However, our choice of translation differs fundamentally from FSL. FSL is designed to reason about sequential programs using
∗-breaking translations (analogous to locality-breaking translation in [9]): the proofs of FSL assume all possible frames are preserved during the execution of program. While this is a reasonable assumption when reasoning about sequential programs, it is non-trivial to establish its soundness for concurrent programs. One possible way to demonstrate its correctness is to provide linearisability proofs to show that all frames are indeed preserved and that the program behaves atomically. In con- trast, our ∗-preserving translation ensures that compatible stable resources at the abstract level (p ∗ q) yield compatible stable resources once translated (p′ ∗ q′) 3 . The correctness of concurrent programs then follows immediately from the disjoint concurrency rule of concurrent separation logic [20].
With abstraction using CAP, we start by concretely reasoning about the heap and then build up levels of abstraction in such a way that ∗ is preserved. As demon- strated, current CAP reasoning leaks implementation details into the abstractions. We believe this can be rectified by extending the abstraction rule to hide the inter- face functions as well as the predicate interpretations.
We believe that interface functions I have been barely studied in the literature. They do appear in [9] for reasoning about sequential libraries using context logic. Context logic is not fine-grained enough to extend to concurrency, since it uses a non-commutative separating application unsuitable for use with the disjoint con- currency rule. SSL reasoning makes this extension possible. SSL is used in [19] for specifying sequential POSIX, with the aim to extend to concurrent POSIX in future. However, soundness was proved by comparison with an abstract operational semantics, so the relationship between abstract and concrete connectivity did not arise. In [15,16,13], there is an emphasis on interpretations which relate abstract

3 Note that p ∗ q does not necessarily suggest physically disjoint resources; rather two compatible resources that can be composed together providing a fiction of disjointness.



Fig. 1. Abstract (de)allocation in SSL (left); reasoning about deleteTree(n) in SSL (right)
and concrete states. However, there is no mention of a mapping I between abstract and concrete interfaces since the connectivity in the examples studied is simple.
Structural Separation Logic: Tree Library
Structural separation logic (SSL) is a general program logic for specifying structured data libraries and reasoning locally about client programs which call such libraries. Here, we give the intuition and technical details of SSL using an abstract tree library. We give the general theory of SSL in the accompanying technical report [18]. Further details, including a wide number of examples, can be found in [2].

Intuition
We give our axiomatic SSL specification of a simple deleteTree(n) command. Intuitively, this command removes the entire subtree whose top node identifier cor- responds to the value of variable n, leaving the rest of the tree unchanged. We formalise this English description using assertions which describe abstract heaps.
Abstract heaps store abstract data fragments. For instance, Fig. 1a illustrates an abstract heap describing a variable cell n with value n, and a tree cell R with a complete abstract tree as its value. This tree consists of a subtree n[t] with parent u, and left and right siblings l and r with no children. It abstracts away from how a tree might be concretely represented in a machine.
Intuitively, the deleteTree(n) command only affects the subtree identified by n. Abstract heaps enable structured data to be split to provide direct access to this subtree by imposing additional instrumentation using abstract addresses. Consider the transition from Fig. 1a to 1b. Fig. 1a contains an abstract heap with a complete tree at R. We split this complete tree using abstract allocation to obtain the abstract heap in Fig. 1b with subtree n[t] at a fresh, fictional abstract cell x and an incomplete tree at R with a context hole x indicating the position to which the subtree will return. The subtree at n can now be accessed directly. Once the updates have been achieved, the heap can be joined back together using abstract deallocation, as in the transition from Fig. 1b to 1a.
The axiomatic specification of deleteTree(n) (Fig. 1c) is formalised as:
{var (n, n)× ATree (n[isComplete])(x)} deleteTree(n) {var (n, n)× ATree (∅)(x)}
The precondition describes a variable store, in which variable n has value n and

abstract cell x has complete subtree with top node n as its value 4 . Since the subtree at x is complete, we own the exclusive right to update its contents. Similarly, the postcondition states that the result of the update is an empty tree at abstract cell x, while variable n remains unchanged. Note that the abstract cell x must be preserved in order to join this tree fragment with the tree it was split from, using abstract deallocation. The footprint of this command is small in the sense that it intuitively captures the minimum resources required for safe execution of deleteTree(n).
With this axiomatisation, we can verify that the simple client program deleteTree(l) ∣∣ deleteTree(n) deletes two disjoint subtrees concurrently. Con- sider the proof derivation in Fig. 2 with program variables l and n, their values l and n, and an abstract tree predicate ATree (u[l ⊗ n[t]⊗ r])(R) denoting a com- plete tree at R containing a subtree with top node n, left and right siblings with top nodes l and r, and parent u. The initial precondition describes the complete tree at R. To get at the two subtrees, we split the tree twice using abstract allocation, placing the subtrees at nodes l and n at the freshly allocated cell addresses y and x, respectively. We apply the standard separation logic rules of existential elimination and frame to temporarily set aside the partial tree at R as it is not being updated by the program. The resulting state can then be split into two disjoint parts using the disjoint concurrency rule. Both parts are now in the right form to match the precondition of the deleteTree axiom. The two updates can happen resulting in the postconditions with empty trees at y and x which are joined together by the disjoint concurrency rule. We reintroduce the state set aside through the existen- tial elimination and frame rule, and obtain the complete tree at R using abstract deallocation twice to remove y and x.
Technical Details
We give the technical details of SSL using the tree library T discussed in §2.1.
Definition 2.1 The set of abstract atomic tree commands of T are defined as:
AtomT ∶∶= m := getFirst(n) ∣ m := getRight(n) ∣ m := getUp(n)
∣ m := newNodeAfter(n) ∣ deleteTree(n) ∣ appendChild(m, n)
for all program variables n, m ∈ PVars. Our commands are chosen to demonstrate a wide range of structural manipulations. The command getFirst(n) returns the identifier of the first child of node n, or null if n has no children. The getRight(n) and getUp(n) commands behave analogously with respect to the right sibling and parent of node n, respectively. The command newNodeAfter(n) creates a new node with a fresh identifier, making it the right sibling of node n and returning the fresh identifier. The deleteTree(n) command removes the entire subtree identified by n from the tree. Finally, the command appendChild(m,n) moves the subtree at n to be the last child of node m. Each of these commands faults if any of the nodes given

4 Note that the precondition is a pair consisting of a variable assertion and a subtree (heap) assertion. We use the variables-as-resource model [14]. However, in contrast to the assertions of variables-as-resource where heap and variable assertions are combined using ∗, we keep the two components separate. As we demonstrate in §4, this is because when translating a library, only heaps are transformed by the translation while program variables are simply preserved.



{(var (l, l)∗ var (n, n)) × (ATree (u[l ⊗ n[t]⊗ r])(R))}
//Abstract allocation (Twice)
{(var (l, l)∗var (n, n))×(∃x, y.ATree (u[y⊗x⊗r])(R)∗ATree (l)(y)∗ATree (n[t])(x))}
//Existential elimination and frame rule
{(var (l, l)∗ var (n, n)) × (ATree (l)(y)∗ ATree (n[t])(x))}
//Disjoint Concurrency rule

{(var (l, l)) × (ATree (l)(y))}
deleteTree(l)
{(var (l, l)) × (ATree (∅)(y))}
{(var (n, n)) × (ATree (n[t])(x))}
deleteTree(n)
{(var (n, n)) × (ATree (∅)(x))}

{(var (l, l)∗ var (n, n)) × (ATree (∅)(y)∗ ATree (∅)(x))}
//Existential elimination and frame rule
{(var (l, l)∗var (n, n))×(∃x, y. ATree (u[y⊗x⊗r])(R)∗ATree (∅)(y)∗ATree (∅)(x))}
//Abstract Deallocation (Twice)
 {(var (l, l)∗ var (n, n)) × (ATree (u[r])(R))}	
Fig. 2. Proof derivation of the concurrent program deleteTree(l) || deleteTree(n).
as parameters are not present in the tree. Additionally, the appendChild(m,n) command faults if m is a descendant of n. These commands are intended to be used with any programming language. In this paper, we use the programming language of the Views framework [6] instantiated with AtomT as the set of atomic commands. We write ProgT to denote the set of programs written in this language.
We specify the tree commands using abstract heaps with cells whose addresses are either abstract addresses or the tree root address R, and whose values are abstract trees.
Definition 2.2 Given a countably infinite set of abstract addresses AAdd ranged over by x, y, z, the set of addresses for the abstract tree heaps is AddT ≜ {R}⊎AAdd.
We now define abstract trees, which can either be complete trees or tree frag- ments with abstract addresses for context holes 5 .
Definition 2.3 Given the set of abstract addresses AAdd, the set of abstract trees
DataT, ranged over by t, t1, ⋯tn, is defined inductively as:
t ∶∶= ∅ ∣ n[t] ∣ t1 ⊗ t2 ∣ x
where n ∈ N+, x ∈ AAdd, the sets AAdd and N+ are disjoint, and no tree contains duplicate node identifiers or abstract addresses. Abstract trees are equal up to the associativity of ⊗ with unit ∅. For brevity, we write n for n[∅]. There is an associated identiﬁers function ids ∶ DataT → ℘(N+) and an associated addresses function addrs ∶ DataT → ℘(AAdd) which respectively, return the sets of node identifiers and abstract addresses present in an abstract tree. The application t1○xt2 is standard: it is undefined when x ∈/ addrs(t1) and is otherwise defined as t1[t2/x], denoting the standard substitution of t2 for x in t1.

5 Strictly speaking, this grammar describes forests or ordered lists of abstract trees. We use the term forest when we wish to emphasise the list with a first and last element.

An abstract tree heap is a mapping from addresses to abstract trees.
Definition 2.4 The set of abstract tree heaps HT ∶ AddT ⇀ Data , ranged over
fin

by h, h1, ⋯, hn, is the set of functions from addresses to abstract trees such that for all h ∈ HT the following restrictions hold:
∀a1, a2 ∈ AddT. a1 = a2 ∨ addrs(h(a1)) ∩ addrs(h(a2)) = ∅
∀a1, a2 ∈ AddT. a1 = a2 ∨ ids(h(a1)) ∩ ids(h(a2)) = ∅
∃/ x ∈ AAdd. x D+ x ∧ ∀x ∈ dom(h)∩ AAdd. R D+ x
h	h
where the descendent relation D for heap h is defined as:
a Dh y ⇐⇒ y ∈ addrs(h(a))
and D+ denotes its transitive closure.
The first two restrictions state that the abstract addresses being used as context holes and the node identifiers are unique across an abstract heap. The last condi- tion states that the abstract addresses join up to produce sensible abstract trees. For instance, {x → m[y], y → n[x]} is not an abstract tree heap because of the cycle. An abstract tree heap may be: complete, with no use of abstract addresses; complete, but with the tree split across several heap cells; or incomplete, missing some heap cells needed to join some abstract addresses. Incomplete abstract heaps are necessary for local reasoning using the frame rule. In this case, there will be some choice for the missing cells that would render the tree complete.
Given an abstract tree heap h, hin and hout denote the set of abstract cell ad- dresses and context holes, respectively:
hin ≜ AAdd ∩ dom(h)	hout ≜ AAdd ∩ (⋃t∈co-dom(h) addrs(t)).
By design, abstract tree heaps are similar to standard heaps. The construction of a separation algebra over them is thus straightforward.
Definition 2.5 The separation algebra of abstract tree heaps is AT ≜ (HT, ●T, 0T), where HT is given in Def. 2.4, ●T is the standard disjoint function union with the proviso that the resulting abstract heap is well-formed as per Def. 2.4; and 0T is a singleton set consisting of the partial function with an empty domain and co-domain.
Since we use variables as resource [14], we pair variable stores for declaring the values of variables with our abstract tree heaps.
Definition 2.6 The separation algebra of abstract tree states SAT ≜ (Σ×HT, ●σ ×
T, 0σ × 0T), is the Cartesian product of the separation algebra of variables
(Σ, ●σ, 0σ) [14] and the algebra of abstract tree heaps (Def. 2.5).
To reason about our tree programs, we use the program logic of the Views framework as described in [6]. We instantiate the framework with the separation algebra of abstract tree states (Def. 2.6) as the view monoid and the tree library commands (Def. 2.1) as the atomic commands. What remains is to describe the axioms associated with the tree library commands (Def. 2.7).





{ (var (n, n)∗ var (m, o)) × (ATree (n[m[y]⊗ z])(x)) }
m := getFirst(n)
{ (var (n, n)∗ var (m, m)) × (ATree (n[m[y]⊗ z])(x)) }
{ (var (n, n)∗ var (m, o)) × (ATree (n[y]⊗ m[z])(x)) }
m := getRight(n)
{ (var (n, n)∗ var (m, m)) × (ATree (n[y]⊗ m[z])(x)) }
{(var (n, n)∗var (m, o))×(ATree (m[y⊗n[z]⊗w])(x)) }
m := getUp(n)
{(var (n, n)∗var (m, m))×(ATree (m[y⊗n[z]⊗w])(x))}
{ (var (n, n)∗ var (m, o)) × (ATree (n[∅])(x)) }
m := getFirst(n)
{ (var (n, n)∗ var (m, null)) × (ATree (n[∅])(x)) }
{(var (n, n)∗var (m, o))×(ATree (u[y⊗n[z]])(x)) }
m := getRight(n)
{(var (n, n)∗var (m, null))×(ATree (u[y⊗n[z]])(x))}
{(var (n, n)∗var (m, o))×(ATree (x⊗n[y]⊗z)(R)) }
m := getUp(n)
{(var (n, n)∗var (m, null))×(ATree (x⊗n[y]⊗z)(R))}

{(var (n, n)∗ var (m, o)) × (ATree (n[y])(x))}

{(	(	)) × (

( [ ])(

)) }

m := newNodeAfter(n)
var n,n 
ATree n tc	x

⎧⎪	(var (n, n)∗ var (m, m)) × ⎫⎪
deleteTree(n)

⎨⎪∃m ∈ N+. (
⎬⎪	{ (var (n, n)) × (ATree (∅)(x)) }

⎪⎩	ATree (n[y]⊗ m[∅])(x)) ⎪⎭
{ (var (m, m)∗ var (n, n)) × (ATree (m[z])(y)∗ ATree (n[tc])(x)) }
appendChild(m, n)
{ (var (m, m)∗ var (n, n)) × (ATree (m[z ⊗ n[tc]])(y)∗ ATree (∅)(x)) }

Fig. 3. Axiomatisation of tree library commands: assume arbitrary m, n ∈ PVars, l, m, n, o ∈ N+ ⊎ {null},
w, x, y, z ∈ AAdd and tc ∈ CompDataT.
Our views are sets of abstract tree states in ℘(Σ×HT). To increase readability of variable sets, we write var (x, v) for {x → v} and p ∗ q for {σ1 ●σ σ2 ∣ σ1 ∈ p ∧ σ2 ∈ q}. For sets of abstract tree heaps, we write ATree (d)(x) for {x → d} and p ∗ q for
{h1 ●T h2 ∣ h1 ∈ p ∧ h2 ∈ q}. For abstract tree states, we write ∃v ∈ V. (p × q) for
{(σ, h) ∣ v ∈ V ∧ σ ∈ p ∧ h ∈ q} assuming any carrier set V . Finally, we define the set of complete abstract trees as the set of abstract trees with no context holes: CompDataT = {d ∈ DataT ∣ addrs(d)= ∅}.
Definition 2.7 The axiomatisation of atomic tree commands :
AxiomT ∶ AtomT → (Σ × HT)× (Σ × HT)
is defined in Fig. 3. For soundness, each axiom must preserve the set of abstract addresses present in the described data. Failure to do so would give unstable com- mands, as the abstract connectivity described by abstract addresses would be bro- ken. This is evident in the deleteTree axiom, which requires that the subtree being removed be complete, in that it contains no context holes. If the sub-tree did contain a context hole, it would be destroyed, and there would be some matching abstract heap cell which could not be connected anywhere.
The technical details of the Views framework uses a labelled transition system to describe transitions between states. Transitions are labelled either by atomic com- mands or by id which labels computation steps in which states are not changed. We extend the behaviour of the id transitions of Views by declaring the relation AxiomId for abstract allocation/deallocation. Abstract (de)allocation does not change the underlying program states and can therefore be seen as id transitions.
Definition 2.8 The identity axiomatisation: AxiomId ∶ (Σ × HT)× {id}× (Σ × HT)

is given by the abstract allocation and deallocation axioms:
{ATree (d1 ○x d2)(a)} id {∃y. ATree (d1○xy)(a)∗ATree (d2)(y)}
{∃y. ATree (d1○xy)(a)∗ATree (d2)(y)} id {ATree (d1 ○x d2)(a)}
The existential quantification of the abstract address y is analogous to the existential quantification used for heap allocation in separation logic.
Definition 2.9 Given the set of abstract tree heaps HT (Def. 2.4), the set of atomic commands AtomT (Def. 2.1) and their axiomatisation AxiomT (Def. 2.7), the ab- stract tree library T is defined as:  T ≜ (HT, AtomT, AxiomT ∪ AxiomId)
Definition 2.10 Given abstract tree states p, q ∈ ℘(Σ×HT) (Def. 2.6) and program C ∈ProgT (Def. 2.1), an abstract triple is Ω ⊧T {p}C{q}. Ω∈PEnvT is a procedure speciﬁcation environment which is a set of procedure specifications f ∶ p1 ↣ q1, where f is a procedure name and p1, q1 ∈ ℘(Σ×HT) are pre/post-conditions of f.
Concurrent abstract predicates: Tree Implementation
We use concurrent abstract predicates (CAP) to reason about our implementation. We describe the concrete representation of our abstract trees and the concrete im- plementation of the tree commands in §3.1. We reason about our implementation in §3.2. We give an informal account of how to establish its correctness with respect to the abstract specification in §3.3, and give the formal justification in §4.

Concrete Tree Implementation
Tree Representation We give a concrete representation of the abstract tree heaps introduced in §2.  Consider the abstract tree heap depicted in Fig. 1a.  The corresponding concrete tree heap is illustrated in Fig. 4.  Each tree node is represented by a node cell with pointers to its left sibling, par- ent, first child, last child and right sibling where ‹ denotes a null pointer.
With the abstract tree heap, the deletion of the subtree rooted at n is a self-contained operation; it does not rely on the context surrounding the subtree. However, this is not the case for the implementation. Since each node cell maintains pointers to its siblings, deletion of the subtree at n requires altering the outgoing pointers of its sib- lings (and sometimes the parent). In this example, the

right pointer of node cell l must be redirected to r and vice-versa; only then can the subtree at n be discarded. Furthermore, in the implementation of the concurrent
Fig. 4: Concrete tree representation.

client program deleteTree(l) || deleteTree(n), both executing threads need
to access the pointers between l and n simultaneously, which calls for a suitable synchronisation technique. In our implementation, we synchronise access to these pointers through locking. Each of the left, first, last and right pointers are protected



proc deleteTree(n){ local l,u,d,r	in
//Acquiring the necessary pointer locks.
u := [n.up] ; lock(n.leftL) ; l:= [n.left] ;
if l =/ null then lock(l.rightL) else if u =/ null then lock(u.firstL) ;
lock(n.rightL) ; r:= [n.right] ;
if r =/ null then lock(r.leftL) ; else if u =/ null then lock(u.lastL) ;
//Pointer Swinging.
if l =/ null then [l.right]:= r else if u =/ null then [u.first]:= r
if r =/ null then [r.left]:= l else if u =/ null then [u.last]:= l
//Unlocking the acquired pointer locks.
if l =/ null then unlock(l.rightL) else if u =/ null then unlock(u.firstL)
if r =/ null then unlock(r.leftL) else if u =/ null then unlock(u.lastL)
//Disposing the sub-tree at node n
d := [n.first] ; call disposeForest(d) ; dealloc(n, 9) ;
}

proc disposeForest(n){ local r, d in
if n =/ null then
r ∶= [n.right] ; call disposeForest(r) ;
d ∶= [n.first] ; call disposeForest(d) ;
dealloc(n, 9)
}
proc lock(a){
while(!CAS(a, 0, 1)) skip ;
}
proc unlock(a){ [a]:= 0 ;
}



Fig. 5. Implementation of deleteTree(n) and some auxiliary procedures.


by corresponding locks (lL, dL, eL, rL) that are to be acquired by the competing threads beforehand. We refer to these locks as pointer locks.
We represent each tree node as a node cell consisting of a block of nine con- secutive heap cells, n → l, u, d, e, r, lL, dL, eL, rL where the first five cells contain pointers to the siblings, parent and children, and the last four cells contain the pointer locks. The primary reason for choosing this particular representation was its resemblance to the representation of tree nodes in the Document Object Model (DOM) implementation of the WebKit project 6 . To increase readability, we write n.l, n.u, ⋯, n.rL for n, n + 1, ⋯,n + 8, respectively.
Tree Implementation We provide a concrete implementation of each of the abstract tree commands. Fig. 5 shows our implementation of the deleteTree command with some auxiliary procedures. The implementation needs to cater for various cases regarding the siblings of node n such as when n does not have a left or right sibling. The implementation of the remaining commands are given in the technical report [18]. Note that this implementation is prone to deadlocks; this can occur with our example program deleteTree(l) || deleteTree(n) when l and n are adjacent siblings. We focus on this simple implementation here as it is sufficient to describe our ideas. We reason about a deadlock-free implementation in [18].


6 However, WebKit supports only sequential DOM manipulation and does not use locks.

Reasoning about Concrete Tree Implementation
Recall that the pointers between two sibling nodes (or sometimes a parent and child node) are shared resources accessible by both nodes. We use concurrent abstract predicates (CAP) [1] to manage this sharing.
Concurrent Abstract Predicates With CAP, the state is modelled as a pair consisting of a thread-local state and a shared state. The shared state is divided into a set of regions, each encompassing some shared portion of the state. Each region is identified by a region identifier R and is governed by a protocol that describes how the resources of the region can be manipulated. For instance, a lock resource at location x can be specified by:

lock (x)≜ ∃R, π. [L]R ∗
R
T (R,x)

where Unlocked(R, x)≜ x ↦ 0 ∗ [U ]R and Locked(R, x)≜ x ↦ 1. This lock definition states that there exists a shared region R containing the lock at location x and the thread’s local state contains some (for permission π ∈ (0, 1]) locking capability [L]R to acquire it. The region is in one of two states: either the lock is unlocked
(x ↦ 0) and the region holds the full capability [U ]R to unlock it; or the lock is
taken (x ↦ 1) and the unlocking capability has been claimed by the locking thread.
The protocol of a shared region is specified through a set of actions, such as actions L and U for the lock example. A thread can perform an action if it has
a non-zero capability for that action (such as the capability [L]R for π > 0). The
actions permitted on the lock region are declared in T (R, x):
T (R, x)≜ {L∶ (x ↦ 0 ∗ [U ]R ) ↝ x ↦ 1	U ∶ x ↦ 1 ↝ (x ↦ 0 ∗ [U ]R )
The action associated with L changes the state of the shared region from unlocked to locked, moving the capability [U ]R to the thread’s local state. The action associated with U behaves dually, returning [U ]R from the local state to the shared region.
The definition of the CAP separation algebra is given in [1,6]. It provides a set of instrumented states MH consisting of a local state, a shared state and an action relation capturing the ways in which the shared state can be manipulated. The definition is parametrised by an underlying separation algebra for describing the local state. For this paper, we work with the CAP separation algebra instantiated with the standard fractional heap separation algebra.
Definition 3.1 The CAP separation algebra, instantiated with fractional heap sep- aration algebra, is ACH ≜ (MH, ●CH , 0CH ). The separation algebra of CAP states is SACH ≜ (Σ×MH, ●σ ×●CH , 0σ ×0CH ), where × denotes standard Cartesian product.
Recall that we base our reasoning on the Views framework [6] which provides general reasoning about a generic programming language parametrised by a set of atomic commands and their axiomatisation.
Definition 3.2 Let AtomH be the set of atomic heap commands including as-
signment, value lookup, memory allocation/deallocation and the compare and set

construct CAS. We write ProgH for the set of programs generated from Views’ pro- gramming language instantiated with set AtomH. Let AxiomH be the standard set of separation-logic axiomatisations for these commands based on the fractional heap separation algebra. The Views framework provides the associated reasoning for ProgH.
Definition 3.3 Given the CAP separation algebra ACH (Def. 3.1), the atomic heap commands AtomH and their axiomatisation AxiomH, the CAP library CH for frac- tional heaps is defined as: CH ≜ (ACH , AtomH, AxiomH).
Definition 3.4 Given CAP states p, q ∈ ℘(Σ × MH) (Def. 3.1) and program C ∈ ProgH (Def. 3.2), a concrete triple is Ω ⊧CH {p}C{q}. Ω ∈ PEnvCH is a set of procedure specifications f ∶ p1 ↣ q1, where f is a procedure name and p1, q1 ∈ ℘(Σ× MH) are pre/post-conditions of f.
In §4, we define the library refinement τ ∶ T → CH for abstract tree library T (Def. 2.9) and concrete CAP library CH (Def. 3.3). As a first step in defining τ , we identify the concrete CAP states corresponding to the abstract tree fragments. These concrete CAP states rely on an interface function Iτ linking abstract addresses with concrete pointers.
Interface Functions. Fig. 4 illustrates a concrete heap representation of a complete abstract tree at root address R. However, many of the abstract tree commands (e.g. deleteTree) are specified using tree fragments rather than complete trees. We need to understand the concrete representation of tree fragments.
When an abstract tree heap is split using abstract allocation, the constituent heaps are agnostic to one-another’s shapes. For instance, consider the abstract tree heap R ↦ l ⊗ i ⊗ j ⊗ r which can be split as h1 ●T h2 where h1 ≜ R ↦ l ⊗ x ⊗ r and h2 ≜ x ↦ i ⊗ j. The abstract tree heap h1 embodies no knowledge of the tree placed within x; mutatis mutandis for h2. At the concrete level, the situ- ation is different. The concrete representation of h2 relies on additional knowl- edge from the concrete representation of h1, since the representation of node i includes pointers to its left sibling (l) and parent (u).  Thus, when translat- ing an abstract heap with abstract addresses, we require supplementary infor-
mation originating from the concrete heap.  We track this additional piece of
information associated with each abstract address x ∈ AAdd through a con-
crete interface. Consider Fig. 6, which depicts an abstract tree at abstract cell x (left) and its concrete representation (right) assuming an interface function Iτ . In the concrete representation, the solid lines rep-
resent resources held locally, such as node n, its up pointer and the subtree t, while the dashed lines de- note shared resources, such as the pointers between node n and its siblings. A concrete in-interface records the address of the first (i) and last (j) nodes

of the concrete representation of the forest pointed
Fig. 6: Tree Fragments.

to by x; in our example, the in-interface is in ≜ (n, n). A concrete out-interface



CTreeIτ (t)(R) ≜ ∃i, j. ICTreeIτ (t) (i, j) (null, null, null)
CTreeIτ (t)(x)≜ ICTreeIτ (t) (ix,jx) (lx, ux, rx)
∗Iτ in(x)=˙ (ix,jx)∗ Iτ out(x)=˙ (lx, ux, rx)
ICTreeIτ (∅) (i, j) (l, u, r)≜ (i=˙ r)∗ (j=˙ l)
ICTreeIτ (x) (i, j) (l, u, r)≜ Iτ in(x)=˙ (i, j)∗ Iτ out(x)=˙ (l, u, r)
ICTreeIτ (t1⊗t2) (i, j) (l, u, r)≜ ∃p, q. ICTreeIτ (t1) (i, p) (l, u, q)
· ICTreeIτ (t2) (q, j) (p, u, r)
ICTreeIτ (n[t]) (i, j) (l, u, r)≜ i=˙ j=˙ n ∗ n.u → u ∗ ∃d, e.
⎛⎜Left (n, l, u)∗First (n, d)∗Last (n, e)∗Right (n, r, u)⎞⎟
⎝∗ICTreeIτ (t) (d, e) (null, n, null)	⎠

Fig. 7. CAP Representation of Abstract Tree Heaps: we write a ≐ b for a = b ∧ emp.

records the addresses of the parent node (u) and nodes placed immediately to the left (l) and right (r) of the abstract address x; in our example, the out-interface is out ≜ (lx, ux, rx). The interface function Iτ maps x to (in, out).
Definition 3.5 The sets of concrete in- and out-interfaces are defined by:
Inτ ≜ (N+ ⊎ {null})2	Outτ ≜ (N+ ⊎ {null})3
The set of in- and out-interface functions are defined by Iin ≜ ℘(AAdd ⇀ Inτ ) and
Iout ≜ ℘(AAdd ⇀ Outτ ). The set of interface functions is Iτ ≜ Iin × Iout.
CAP Representation of Trees Fig. 7 defines concurrent abstract predicates for de- scribing the concrete representation of abstract tree heaps, parameterised by inter- face function Iτ . The CTreeIτ (t)(R) predicate provides a concrete representation of the tree fragment t at root address R. The predicate CTreeIτ (t)(x) provides a concrete representation of the tree fragment at abstract address x. Both predicates are defined using a ICTree predicate indexed by in- and out-interfaces determined by Iτ . For R, the out-interface is (null, null, null). The in-interface is unknown at this point and hence is existentially quantified. Its value is later found using the ICTree predicate. The interface of x is determined by the interface function Iτ .
We now describe the ICTree predicate with the explicit in- and out-interface arguments (i, j) and (l, u, r), following the cases of the inductive definition.
ICTreeIτ (∅) There is no resource in the concrete heap representation, simply some pointer equalities. The assertion i ≐ r simply states that the address of the first node cell in the forest is equal to the address of the node cell immediately to the right of the tree; similarly for j and l. This is to ensure the correct concrete representation of trees such as t1 ⊗∅⊗ t2.
ICTreeIτ (x) There is no resource in the concrete heap representation, simply the

appropriate connection between abstract address x and the interfaces given by Iτ .
ICTreeIτ (t1 ⊗ t2) This is simply the ∗-composition of the concrete representations of the constituent abstract subtrees, given an appropriate choice of interfaces.
ICTreeIτ (n[t]) The first two lines provide the concrete representation of the node n, and the last line represents the subtree t. For the subtree, the concrete repre- sentation is straightforward. For the node, i ≐ j ≐ n since there is only one tree in the forest. The concrete representation has full ownership of the parent pointer
n.u → u, as there is no competition for this resource from other nodes. The Left, Right, First and Last predicates represent the pointers and locks associated with the left sibling, right sibling, first child and last child, which are in competition with the representations of nearby nodes and hence must be shared.
We give the definition of Left predicate here; the Right, First and Last predicates are defined analogously and we defer them to the accompanying technical report [18].
The definition of the Left predicate is given in Fig. 8 and is described by the
isLLock and ownsR predicates.
isLLock(n, l, u, 0.5) This predicate states that there exists a shared region Rnl containing the left pointer lock of node n; the thread’s local state contains some locking capability [L]Rnl associated with the region.
ownsR(n, l, u, 1) Similar to isLLock, this predicate refers to the Rnl region where the thread’s local state holds full permission on the witness capability [W]Rnl . This is to denote that even though the pointers between n and its left sibling l are shared, node n itself is owned by the current thread. Later in the description of LWit predicate we demonstrate how this capability can be used to track the identity of the thread that has claimed the left pointer lock of n.
The contents of the Rnl region are analogous to that of the lock example given before. The difference is the additional pointer resource (⋐) contained within the region. The region can be in one of two states: LUnlocked or LLocked.
LUnlocked(Rnl, n, l, u) In this state, the left pointer lock is not taken (n.lL → 0), and the full unlocking capability ([U ]Rnl ) and the ⋐ resource are in the region.
n,l,u  This predicate describes the pointer resources between node n and its left hand side depending on its position in the tree. When n has a left sibling (l =/ null), it consists of partial ownership of the pointers between n and l, that is,
n.l 0↦.5 l ∗ l.r 0↦.5 n. It also contains the capability to acquire the right pointer lock of l, in order to obtain full ownership of the pointers between node n and l. This is captured by the isRLock (l, n, u, 0.5) predicate. On the other hand, if n does not have a left sibling and is thus the first child of node u (l = null ∧ u =/ null), the ⋐ resource consists of partial ownership on the left pointer of n and the first pointer of u (n.l 0↦.5 l ∗ u.d 0↦.5 n) as well as the capability to acquire the first pointer lock of u (isDLock (u, n, 0.5)). Finally, if n is the first child underneath the root address R, and thus both its left sibling and parent correspond to null (l = u = null), the ⋐
resource consists of full permission on n’s left pointer (n.l ↦1 l) and the remaining




Left (n, l, u)≜ isLLock (n, l, u, 0.5)∗ ownsR (n, l, u, 1)

isLLock (n, l, u, π)≜ ∃Rnl. [L]Rnl ∗

ownsR (n, l, u, π)≜ ∃Rnl. [W]Rnl ∗ LUnlocked (Rnl, n, l, u)





Rnl



LC(Rnl,n,u) Rnl


LC(Rnl,n,u)

LUnlocked (Rnl, n, l, u)≜ n.lL → 0 ∗ [U ]Rnl ∗ ⋐n,l,u
⎛⎜ ( l =/ null ∧ l.r 0↦.5 n ∗ isRLock (l, n, u, 0.5) )	⎞⎟
⎜⎜ ∨( l=˙ u=˙ null ∗ n.l 0↦.5 l ∗ isLLock (n, l, u, 0.5) )	⎟
LLocked (Rnl, n, l, u)≜ n.lL → 1 ∗ LWit (l, n, u)
LWit (l, n, u)≜ ownsR (l, n, u, 0.5)
∨ (l =/ null ∧ ownsL (l, n, u, 0.5))
∨(l = null ∧ u =/ null ∧ ownsD (u, n, 0.5))
⎧⎪ L∶  LUnlocked (Rnl, n, l, u)↝ LLocked (Rnl, n, l, u)
⎪	′

LC(R
, n,u 
⎪ U ∶ LLocked (Rnl, n, l, u)↝ LUnlocked (Rnl, n,l , u)

)≜ ⎨⎪ W ∶ LInit (n, l, u)↝ LUnlocked (R , n, l, u)∨ LLocked (R , n, l, u)
⎪	LUnlocked (Rnl, n, l, u)∨ LLocked (Rnl, n, l, u)↝ LInit (n, l, u)
	⎩	

Fig. 8. The definition of Left and its auxiliary predicates.

locking capability on region Rnl (isLLock (n, l, u, 0.5)).
LLocked(Rnl, n, l, u) In this state, the left pointer lock is taken (n.lL → 1), and the capability [U ]Rnl and the pointer resources ⋐ have been claimed by the locking thread in exchange for the LWit resource.
LWit(l, n, u) Since the left pointer lock of n can only be be acquired by the thread in possession of node n, or node l (or node u if n is the first child of u and does not have a left sibling), the LWit predicate is used to track the identity of the locking thread. Recall from the definition of the Left predicate that the full witness capability [W]Rnl is held by the thread that owns node n, as described by ownsR (n, l, u, 1). We thus use the witness capabilities to determine the identity of the locking thread. The first disjunct denotes the case where the lock has been claimed by the thread in possession of node n and corresponds to the witness capability on this region (ownsR (n, l, u, 0.5)).  Analogously, the second disjunct

represents the case where the thread in possession of node l has acquired the lock, denoted by (ownsR (n, l, u, 0.5)). The third disjunct captures the case where n does not have a left sibling and the lock has been taken by the thread that owns the parent node u (ownsD (u, n, 0.5)).
LC(Rnl, n, u) The Rnl region is governed by the LC(Rnl, n, u) protocol describing the ways in which its contents can be manipulated through actions. The action associated with L changes the state of Rn from LUnlocked to LLocked. Dually, the action of U changes the state of the region from LLocked to LUnlocked. The first action of W initialises the contents of Rnl immediately after its creation. Similarly, the second action ﬁnalises the contents of the region right before its destruction. The initial/final contents of the region are realised by the LInit predicate. The definition of LInit predicate is nonessential as it bears no relevance in understanding the interactions between the threads and the shared region and is thus omitted here.
Recall that abstract trees can be split and joined using abstract allocation and deallocation. We show that concrete trees can be split (joined) analogously provided that the interface function is extended (reduced) accordingly to capture the interface associated with the freshly allocated (deallocated) abstract address.
Theorem 3.6 (Abstract (de)allocation) For all interface functions Iτ ∈Iτ , ad- dresses a ∈AddT and trees t1, t2 ∈ DataT:
CTreeIτ (t1○xt2)(a)≡ ∃y ∈ AAdd, in ∈ Inτ , out ∈ Outτ .
CTree τ (t1○xy)(a)∗CTree τ (t2)(y)
where Inτ , Outτ and Iτ are given in Def. 3.5 and I′ ≜ Iτ ⊎ ([y ↦ in], [y ↦ out]).
Proof. The proof of this theorem is provided in the technical report [18].    ◻

Soundness of Concrete Tree Library CH
In order to show that our concrete CAP library CH (Def. 3.3) is sound with respect to the abstract tree library T (Def. 2.9), we show that everything that can be proved about the abstract library T, can also be proved about the concrete library CH. That is, for every abstract triple Ω ⊧T {p}C{q} (Def. 2.10), we show that there exists a corresponding concrete triple Ω′ ⊧CH {p′}C′{q′} (Def. 3.4) where C′ is the implementation of C and p′, q′ denote the concrete representations of p, q, respectively. For instance, we need to show that the implementation of the deleteTree command in Fig. 5, satisfies its abstract specification as given in Fig. 3.
In §4, we formalise triple transformation (Def. 4.6) and define what it means for the CAP library CH to be sound with respect to the abstract tree library T (Def. 4.8). We then prove that CH is sound with respect to T (Theorem 4.9). In what follows, we give an informal account of establishing the correctness of the deleteTree implementation and state a pseudo-theorem that almost captures the desired result. We defer the formalisation of the correct theorem to §4 (Theorem 4.7), and the full proof to the accompanying technical report [18].

Pseudo-Theorem 1 Let	[∣deleteTree(n)∣]τ	denote	the	implementation	of
deleteTree(n) command in Fig. 5. The following statement almost holds:
∀Ic ∈ Iτ .  { ∃Id ∈ Idel. (var (n, n)× CTreeIc⊎Id (n[t])(x)) }
[∣deleteTree(n)∣]τ
{∃Id ∈ Idel. (var (n, n)× CTreeIc⊎Id (∅)(x))}
with    Idel ≜ {I ∈ Iτ ∣ dom(Iin)= {x}∧ dom(Iout)= ∅} .
The pre-condition contains the variable resource var (n, n) and the concrete tree representation CTree(n[t])(x) of complete subtree at abstract address x. The pre- condition gives the right to control and modify the inner interface Idel of address x (in this case, (n, n)). This freedom to modify Idel is captured by the existential quantification of Id in both pre- and post-conditions. Note that the control over the outer interface of x as well as the interfaces associated with other abstract addresses lies with the context. We therefore need to be agnostic to the interfaces associated with abstract addresses outside the domain of Id and show that the implementation is correct for all valid choices of context interfaces Ic. This is realised by the universal quantification of Ic outside the Hoare triple. However, since we are reasoning about concurrent programs, during the execution of deleteTree, the interfaces captured by Ic are potentially changing underfoot. Hence, contrary to what the above triple states, the value of Ic in the pre-condition does not necessarily agree with that of Ic in the post-condition. The correct theorem is given in §4.
Correct Library Translation
We state what it means to correctly implement our abstract tree library T (Def. 2.9) with our CAP library CH (Def. 3.3) by defining a library translation τ ∶ T → CH. In
§4.1, we give our specific library translation τ and, in §4.2, we prove its soundness.
In the accompanying technical report [18], we generalise this approach to translate arbitrary abstract libraries, and stipulate a set of general properties that when satisfied, will warrant sound translation of any abstract library. These properties are stated for our specific library translation in Theorem 4.9.
Tree to CAP Translation
Our goal is to define a translation τ ∶ T → CH in such a way that would allow us to correctly transform abstract tree triples to concrete CAP triples, following the spirit of Pseudo-theorem 1. We give an abstract tree heap translation that maps abstract tree heaps to CAP heaps. To keep the translation concise, we define it using CAP assertions which can then be interpreted as elements of ℘(MH) [1].
Definition 4.1 Given the separation algebra of abstract tree heaps (Def. 2.5) AT ≜ (HT, ●T, 0T), the tree interface function Iτ (Def.3.5) and the CAP separation algebra (Def. 3.1) ACH ≜ (MH, ●CH , 0CH ), the abstract tree heap translation ⟨.⟩(⋅) ∶ HT → Iτ →
℘(MH) is a function defined inductively over the structure of abstract tree heaps:

⟨0T⟩I ≜ emp	⟨R → t⟩I ≜ CTreeI (t)(R)	⟨x → t⟩I ≜ CTreeI (t)(x)
⟨h1 ●T h2⟩I ≜ ∃I1, I2.I = I1 ∪ I2 ∧ ⟨h1⟩I1 ∗ ⟨h2⟩I2
where the definition of the CTree predicate is as given in Fig. 7.
We also need to transform programs in ProgT to programs in ProgH.
Definition 4.2 The implementation function [∣.∣]τ ∶ ProgT → ProgH, replaces
each call to an atomic tree command in AtomT with a call to a correspondingly
named procedure denoting its implementation, while other program constructs re- main unchanged. The implementation of deleteTree is as given in Fig. 5; the implementation of other atomic commands are given in the technical report [18].
Definition 4.3 The translation τ ∶ T → CH is a triple comprising the set of inter- faces Inτ × Outτ (Def. 3.5), the abstract tree heap translation ⟨.⟩(⋅) (Def. 4.1) and
the implementation function [∣.∣]τ (Def. 4.2): τ ≜ (Inτ × Outτ , ⟨.⟩(⋅) , [∣.∣]τ ).
Correctness of Translation
Given the translation τ , our goal is to state and prove the correctness of a translation of abstract tree triples Ω ⊧T {p}C{q} to concrete CAP triples Ω′ ⊧CH {p′} [∣C∣]τ {q′} in the spirit of Pseudo-Theorem 1. To do this, we need to define a state translation between abstract tree states and concrete CAP states.
Recall from §3.3 that the universal quantification of context interface function Ic in Pseudo-Theorem 1 is incorrect, since interfaces captured by Ic are subject to change by the environment. We define the set of stable interface functions SIτ whereby an abstract address is associated not with a single interface but with a set of interfaces. By associating a set of possible interfaces with an abstract address at any one time, we can account for the potential change of interfaces by the environment.

Definition 4.4 Given the sets of inner and outer interfaces Inτ , Outτ (def. 3.5), the set of stable inner-interface functions is SIτ in ∶ ℘(AAdd ⇀ ℘(Inτ )) and the set of stable outer-interface functions is SIτ out ∶ ℘(AAdd ⇀ ℘(Outτ )). The set of stable interface functions is defined by SIτ ≜ SIτ in ×SIτ out. For SI ∈ SIτ , SIin and SIout denote the first and second projections, respectively. The collapse of SI is SI ↓≜ (SI ↓in × SI ↓out) where SIin ↓ (and analogously SI ↓out ) is defined as:

SIin ↓≜ { I ∈ Iin
dom(I)= dom(SIin) ∧ ∀x ∈ dom(I). I(x)∈ SIin(x) }

We can now give a state translation between abstract tree states and concrete CAP states, parametrised by the stable interface functions.
Definition 4.5 The state translation: ⟨∣.∣⟩(⋅) ∶ ℘(Σ × HT)→ SIτ → ℘(Σ × MH) is:

⟨∣p SI
⎧
σ, m)
(σ, h)∈ p ∧	⎫⎪

∣⟩τ ≜ ⎨⎪⎪(
Id.m 
Ic∈SI↓
{⟨h⟩Ic⊎Id
dom(Idin)= hin ∧ dom(Idout)= hout} ⎬⎪⎪⎪⎭

where hin, hout are given in Def. 2.4 and I1 ⊎I2 ≜ (I1in ⊎ I2in, I1out ⊎ I2out) with ⊎
denoting the standard disjoint function union.
Note that when transforming a tree state, the variable store σ remains unchanged while the tree heap h is translated as ⟨h⟩Ic⊎Id . Id captures the interfaces of abstract addresses within the control of the thread and thus are in the footprint of h. On the other hand, Ic represents the interfaces of abstract addresses controlled by the environment. Id and Ic are analogous to those of Pseudo-theorem 1, with the exception that they are drawn from the stable interface function SI.
We can now formalise the transformation of an abstract triple Ω ⊧T {p}C{q} to a concrete triple (∣Ω∣)τ ⊧CH {⟨∣p∣⟩τ } [∣C∣]τ {⟨∣q∣⟩τ }, where (∣.∣)τ is defined in Def. 4.6.
Definition 4.6 Given the library translation τ ∶ T → CH, for all procedure spec- ification environments Ω ∈ PEnvT, abstract tree states p, q ∈ ℘(Σ × HT) and tree programs C ∈ ProgT, the translated triple τ ∶ Ω ⊧T {p}C{q} is:

τ ∶ Ω ⊧T {p} C {q} ≜ ∀SI ∈ SIτ . (∣Ω∣)τ ⊧CH {⟨∣p∣⟩	} [∣C∣]
SI

{⟨∣q∣⟩SI }

where (∣Ω∣) ≜ {f ∶ ⟨∣p∣⟩SI ↣ ⟨∣q∣⟩SI ∣ (f ∶ p ↣ q)∈ Ω ∧ SI ∈ SIτ }.
We can now amend the statement of Pseudo-theorem 1 and formulate the the- orem describing the correctness of the deleteTree command.
Theorem 4.7 (deleteTree Correctness) The implementation of deleteTree
command as given in Fig. 5 is correct if
τ ∶ Ω ⊧T {var (n, n)× ATree (n[t])(x)} deleteTree {var (n, n)× ATree (∅)(x)} 

Proof. The correctness proof of the above statement is given in the accompanying technical report [18].	◻
Definition 4.8 The library translation τ ∶ T → CH is sound if, for all Ω ∈ PEnvT,
p, q ∈ ℘(Σ × HT) and C ∈ ProgT:    Ω ⊧T {p} C {q} =⇒ τ ∶ Ω ⊧T {p} C {q}
Theorem 4.9 (Sound translation) The library translation τ ∶ T→CH is sound.
Proof. The proof is by induction over the structure of C in Ω ⊧T {p}C{q} and is given in the technical report [18]. We show that translation τ has the following properties and appeal to these properties in the proof.	◻
Property 1 (Axiom Correctness) For all Ω ∈ PEnvT, p, q ∈ ℘(Σ × HT), A ∈
AtomT,	Ω ⊧T {p} A {q} =⇒ τ ∶ Ω ⊧T {p} A {q}
This ensures that the translation correctly implements abstract atomic commands, as demonstrated intuitively throughout the paper with the deletetree command.
Property 2 (Monotonicity of id Relation) For all h1, h2 ∈ HT and I ∈ Iτ :
{{h1}} id {{h2}} =⇒ { ⟨h1⟩I } id { ⟨h2⟩I }
A lifting of this property to abstract tree states is used in proof of rule of consequence.

Property 3 (∗-Preservation) For all h1, h2 ∈ HT and I ∈ Iτ
⟨h1 ●T h2⟩I ≡ ∃I1, I2. I1 ∪ I2 = I ∧ ⟨h1⟩I1 ●C ⟨h2⟩I2
A lifting of this property to tree states is used in proof of disjoint concurrency rule.
Concluding Remarks
We have highlighted a gap in reasoning between abstract libraries and concrete implementations, due to the mismatch between the abstract connectivity of abstract data fragments and the concrete connectivity of their concrete representations. We have illustrated this gap using SSL reasoning applied to an abstract concurrent tree library T and CAP reasoning about a concrete implementation. This gap is closed by a refinement translation τ ∶ T → CH, which depends crucially on an interface function Iτ mapping abstract addresses to pointer interfaces. Our SSL reasoning and results generalise to arbitrary structured data libraries, as we report in [18]. Our work concentrates on the abstract connectivity associated with our SSL reasoning. However, the gap in reasoning occurs whenever there is a difference between abstract and concrete connectivity.

References
Dinsdale-Young, T., M. Dodds, P. Gardner, M. Parkinson and V. Vafeiadis, “Concurrent Abstract Predicates”, ECOOP (2010), 504–528
Wright, A. D., “Structural Separation Logic”, PhD thesis, Imperial College London, 2013.
Wheelhouse, M. J., “Segment Logic”, PhD thesis, Imperial College London, 2011.
Smith, G. D., “Local Reasoning about Web Programs”, PhD thesis, Imperial College London, 2011.
Dinsdale-Young, T., “Abstract Data and Local Reasoning”, PhD thesis, Imperial College London, 2010
Dinsdale-Young, T., L. Birkedal, P. Gardner, M. Parkinson and H. Yang, “Views: Compositional Reasoning for Concurrent Programs”, POPL (2013), 287–300
Calcagno, C., P. Gardner and U. Zarfaty, “Context logic and Tree Update”, POPL (2005), 271–282
Filipovic, I., P. O’Hearn, N. Torp-Smith and H. Yang, Blaming the Client: on Data Refinement in the Presence of Pointers, Formal Aspects of Computing 22 (2010), 547–583.
Dinsdale-Young, T., P. Gardner, M. Wheelhouse, “Abstraction and Refinement for Local Reasoning”, VSTTE (2010), 199–215.
Calcagno, C., P. O’Hearn and H. Yang, “Local Action and Abstract Separation Logic”, LICS (2007), 366–378.
Bornat, R., C. Calcagno, P. O’Hearn and M. Parkinson, “Permission Accounting in Separation Logic”, POPL (2005), 259–270.
Gardner, P., G. Smith, M. Wheelhouse and U. Zarfaty, “Local Hoare Reasoning about DOM”, PODS (2008), 261–270.
Jensen, J. and L. Birkedal, “Fictional Separation Logic”, ESOP (2012), 377–396.
Bornat, R., C. Calcagno and H. Yang, Variables As Resource in Separation Logic, Electronic Notes in Theoretical Computer Science 155 (2006), 247–276.
Turon, A., D. Dreyer and L. Birkedal, Unifying Refinement and Hoare-Style Reasoning in a Logic for Higher-Order Concurrency.
Svendsen, K., L. Birkedal and M. Parkinson, Impredicative Concurrent Abstract Predicates, ESOP2014.
Svendsen, K, L. Birkedal and M. Parkinson, “Higher-order Concurrent Abstract Predicates”, Technical report, IT University of Copenhagen (2012).
Raad, A., P. Gardner, A. Wright, M. Wheelhouse, “Abstract Local Reasoning for Concurrent Libraries (Technical Report)”, http://www.doc.ic.ac.uk/∼azalea/MFPS2014/TechnicalReport.pdf.
Gardner P., G. Ntzik and A. Wrigth, Local Reasoning for POSIX File System, ESOP (2014), 169–188.
P. O’Hearn, Resources, Concurrency and Local Reasoning, Theor. Comput. Sci., 375 (2007), 271–307.
