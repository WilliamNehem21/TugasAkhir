

Electronic Notes in Theoretical Computer Science 247 (2009) 103–121
www.elsevier.com/locate/entcs

Some Remarks on Type Systems for Course-of-value Recursion
Favio Ezequiel Miranda-Perea1,2
Departamento de Matema´ticas Facultad de Ciencias UNAM
Circuito Exterior s/n, Cd. Universitaria, M´exico D.F. 04510, M´exico

Abstract
Course-of-value recursion is a scheme which allows us to define the value of a function in some argument of an inductive structure by using not only the immediate, but arbitrary previously computed values. In the categorical approach to typed (total) functional programming, where datatypes (codatatypes) are initial algebras (final coalgebras), one models this principle by a construction called histomorphism. On the other hand, it is known that other categorical principles such as catamorphisms and anamorphisms representing
definitions by iteration and coiteration have been successfully used to implement safe type systems extending the second-order polymorphic lambda calculus, system F. Hence it is natural to pursuit the definition and implementation of fold operators corresponding to course-of-value recursion as well. This paper proposes some new such extensions and states some important remarks emerged while verifying the correctness and safety properties of their operational semantics, relying not only on the categorical, but also on the logical approach based on fixed-point operators. Our observations should be considered as a starting point for a deeper study of the interrelation between these two approaches.
Keywords: schemes of (co)recursion, course-of-value, typed lambda calculi, category theory, histomorphism, (co)inductive types, least fixed points


Introduction
In the calculational approach to programming, an implementation of a problem is derived from a particular specification by means of algebraic manipulation of formu- las or equations. This approach has been quite succesful in functional programing, since expressions in such a language behave as mathematical functions due to the property of referential transparency. However, in order to enhace the efectiveness of calculations, the use of unstructured general recursion should be abandoned in favor of a set of structured (co)recursion schemes encoding typical recursion patterns, just

1 This research has been partially supported by Conacyt-UNAM Mexico postdoctoral grant number 050289
2 Email: favio@matematicas.unam.mx

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.051

as the use of arbitrary goto statements was replaced by the use of primitive control structures in imperative programming.
A usual basis for the calculational approach is category theory, where recur- sion patterns are modelled by categorical constructions such as catamorphisms and anamorphisms, implemented in functional programming by the higher-order func- tions fold and unfold, respectively.
This paper concentrates in another useful pattern known as course-of-value re- cursion, captured by a construction called histomorphism in [21]. However, we do not focus in the categorical concepts, but rather in their implementation as type systems, which has been succesfully achieved for other schemes (see [13,17]). Our overall goal is to implement recursion principles in the setting of typed lambda calculus, taking the categorical approach discussed above, as well as a fixed-point approach, usual in logics with inductive definitions, as a foundation. Although the formalisms presented here are not new strictly speaking (see [21,22]), our contribu- tion, apart from present them in the framework of Curry-style type systems and generalizing them with full monotonicity instead of positivity, is to state some im- portant remarks about their static and dynamic semantics. Moreover this work intends to be a starting point for a deeper comparison of two distinct approaches to model course-of-value recursion.
The paper is organised as follows: after this introduction we recall the categorical approach to (co)iteration in section 2. We settle a formal definition of course-of- value recursion and introduce the categorical construction modelling it in section
3. The migration from categories to types is explained in section 4 where we also present the formalization of basic fold and unfold operators. In section 5 we discuss a safe type system for course-of-value iteration and two different operational semantics
corresponding to different implementations of the course-of-value fold operator, this is made clear in the case of natural numbers. After a brief discussion on termination (strong normalization) and its high price, we adopt the point of view of [20], and still pursuit this property by abandoning the realm of categories in favor of the fixed-point approach in section 6, where we present an alternative system for course- of-value iteration which happens to be terminating. Here we realize that for natural numbers there are still some operational problems and propose full course-of-value primitive recursion as definitive solution in section 7. Finally in section 8 we provide some closing remarks and future work.
Through the paper we will be using Haskell notation, in particular f . g denotes function composition. Nevertheless the translation to other functional language is straightforward.

The Categorical Approach
In the categorical approach to typed (total) functional programming, datatypes, like natural numbers, lists or trees, are modelled by initial algebras, whereas co- datatypes, like streams, colists or infinite trees are modelled by final coalgebras. For this purpose a default category C is used, which usually has finite products

(×, 1) and coproducts (+, 0) such that products distribute over coproducts, for ex- ample the category Set. The basic function definition schemes are iteration and coiteration modelled by constructions named catamorphisms and anamorphisms. Let us briefly recall the basic concepts.
Definition 2.1 Let F : C → C be a functor. If it exists, the initial algebra of F is a pair ⟨μF, in⟩ such that for every object B and arrow ϕ : F B → B there exists a unique arrow foldμ ϕ such that the following diagram commutes:




F (fold
F (μF )
.
.
.
.
.
.
.
.i.n

.....

.
.
.
.
.
.
.

μ	.
.
.
....
FB 
.	μ
.
.
....
ϕ	.....

That is (foldμ ϕ) . in = ϕ.F (foldμ ϕ). In such case the arrow foldμ ϕ, is called a catamorphism and the equation is called the principle of iteration on ϕ.
To get codatatypes we just dualize the above definition.
Definition 2.2 Let F : C → C be a functor. If it exists, the final coalgebra of F is a pair ⟨νF, out⟩ such that for every object B and arrow ϕ : B → F B there exists a unique arrow unfoldν ϕ such that the following diagram commutes:




unfold
νF
.....
.
.
.
ϕ .
..o.u.t
. F (νF )
.....
.
.
. F (unfold ϕ)

.	.
.	.
.	.
.	.
.	.
.	.
B	ϕ	.....
That is out . (unfoldν ϕ) = F (unfoldν ϕ) . ϕ. In such case the arrow unfoldν ϕ, is called an anamorphism and the equation is called the principle of coiteration on ϕ.
The existence of initial algebras and final coalgebras is guaranteed for a wide class of functors including all the functors built up from the identity and constant functors using products and coproducts. Let us recall some typical examples.
Example 2.3 The natural numbers are defined as Nat = μF where FX = 1 + X. In this case in : 1 + Nat → Nat encodes the usual constructors zero, suc by means of zero = in . inl and suc = in . inr where inl, inr are the coproduct injections. As usual, in category theory, zero is a global element zero : 1 → Nat. Moreover, given functions c : 1 → C and g : C → C the catamorphism f = foldμ[c, g], where [c, g] : 1+ B → B is the usual copair of arrows, generates the following version of the principle of iteration: f.zero = a, f.suc = g.f . This corresponds to the following fold operator on natural numbers in Haskell
foldnat a g 0 = a
foldnat a g (n+1) = g (foldnat a g n)

Example 2.4 The codatatype of streams over a given type A is usually represented as stream A = νF , where F X = A × X. The out : stream A → A × stream A arrow encodes the usual destructors head, tail defined by head = fst . out, tail = snd . out. Given two functions h : B → A, t : B → B the anamorphism f = unfoldν⟨h, t⟩, where ⟨h, t⟩ : B → A×B is the usual pair of arrows, generates the following version of the coiteration principle: head.f = h, tail.f = f.t. This corresponds to the following unfold operator on streams in Haskell:
head (unfold h t x) = h x
tail (unfold h t x) = unfold h t (t x)
Example 2.5 The definition Colist C = νF , where F X = C × (1 + X), generates the codatatype of non-empty and maybe infinite lists of elements of C. In this case we have tail : Colist C → 1+ Colist C, tail = snd . out. Therefore this destructor can return an error (an inhabitant of 1) indicating that the tail does not exist, in this case the colist is finite. We will use colists in several ocassions later in this paper.
The following well-known result, due to Lambek, states that the arrows in and
out are isomorphisms
Proposition 2.6 The arrows in, out are isomorphisms. Therefore there are inverse arrows in−1 : μF → F (μF ) and out−1 : F (νF ) → νF such that in−1 . in = Id and out . out−1 = Id.
The basic function definition schemes foldμ, unfoldν are useful and well-known. However, there are other enhaced principles which allow us to define a wider class of functions in a more direct or elegant way. In this paper we are concerned with one of such principles called course-of-value recursion.
Course-of-Value Recursion
The scheme of course-of-value recursion (iteration) generalizes conventional itera- tion, given by catamorphisms, by allowing the result sought after to depend not only on the recursive result of applying the function to the immediate children of the current input, but also on the recursive result of any previous subterm. This idea is captured, for the case of natural numbers, by the following definition, which we consider to be simpler and more friendly than the usual mathematical definition.
Definition 3.1 Let Nat be the datatype of natural numbers, C any (co)datatype, c0,..., ck ∈ C and g : Colist C → C. A function f : Nat → C is defined by course-of-value iteration with base cases c0,..., ck and step function g if and only if:
f (0) = c0, f (1) = c1, ..., f (k) = ck
f (n + 1) = g rcd f n , n ≥ k
where rcd : (Nat → C) → Nat → Colist(C) is the function returning the history or record of f , namely rcd f n = [f n, f (n − 1),...,f 0]. This function is coiteratively defined by:

head (rcd f n) = f n 
tail (rcd f n) = if n = 0 then error else rcd f (n − 1)
This definition generates, in particular, the following fold operator in Haskell, called a course-of-value fold cvfold:
cvfold g c 0 = c
cvfold g c (n+1) = g (rcd (cvfold g c) n) where
rcd f n = (f n):
(if n == 0 then error ‘‘No tail for rcd f 0’’ else (rcd f (n-1))
Observe that the step function g is required to receive the whole record of pre- vious values. For efficiency instead, one could think of calculating only the values needed for the recursive call. However, a good implementation of course-of-value recursion does not calculate values repeatedly but relies on dynamic programming techniques like memoization, which in our case can easily be achieved, see section
5.3. The reader can also realize that the record function rcd could also be defined
by simple iteration, we will consider this option later. However we prefer the above definition, for one of the side goals of this paper is to show the nice interaction between recursion and corecursion, after all this latter principle comes almost free because of duality.
Example 3.2 Some functions definable with the above scheme are:
The function fibo generates the elements of the sequence of Fibonacci numbers and is defined by taking c0 = c1 = 1 and gl = sum (take 2 l) where sum adds the elements of a list of numbers and take nl returns the list of first n elements of the list l
The function half returns the integer half of a natural number, specified by half 0 = 0 = half 1 and half (n + 1) = half(n − 1) + 1. It is defined by taking c0 = c1 = 0 and gl = l !! 1 + 1 where l !! n returns the nth element of l counting from zero.
A more interesting example is the function generating the Catalan numbers Cn given by C0 = 1, Cn+1 = C0Cn + C1Cn−1 ... + Cn−1C1 + CnC0. This shows the extreme case of course-of-value iteration where the whole record [Cn,..., C0] is needed to define Cn+1 . A generating function cat arises by taking c0 = 1 and gl = cnv l l, where cnv is a function calculating the convolution of two lists, which in particular yields
cnv [a0,..., an] [b0,..., bn] = a0bn + a1bn−1 + ... + an−1b1 + anb0.
The scheme of course-of-value iteration given in definition 3.1 is captured by the categorical combinator known as histomorphism (see [21]). We briefly recall it here.
Definition 3.3 [cv-algebra] Let ⟨μF, in⟩ be the initial algebra of a functor F : C → C. Given an object C ∈ C we define F× X = C × F X. Assuming that for every C there is a final coalgebra ⟨νF×, out⟩, we define a new functor F ν such that F ν C = νF×. An F -cv-algebra is a pair ⟨C, ϕ⟩ where ϕ : F (F νC) → C.

Definition 3.4 [Histomorphism] Let ⟨μF, in⟩ be the initial F -algebra. Given an F -cv-algebra ⟨C, ϕ⟩ the histomorphism cvfoldμ ϕ : μF → A, is the unique arrow making the following diagram commute:


F (μF )
.
.
.
.
.
.i.n

.	μF
.
.
.
.
.

ν	μ

F (F
.
.
.
....
ν C)



ϕ	.....
.	μ
.
.
....
C


where unfoldν ⟨cvfoldμ ϕ, in−1⟩ denotes the anamorphism of the functor F× with step arrow ⟨cvfoldμ ϕ, in−1⟩. The equation (cvfoldμ ϕ). in = ϕ.F (unfoldν⟨cvfoldμ ϕ, in−1⟩) is called the principle of course-of-value iteration.
Example 3.5 For the datatype of natural numbers Nat defined in example 2.3, cv-algebras are pairs ⟨C, ϕ⟩ where ϕ : 1 + Colist(C) → C. We will make clear later in section 5.1 that in this case, a histomorphism f = cvfoldμ ϕ corresponds to a function f : Nat → C defined by course-of-value iteration according to definition 3.1.
The existence and uniqueness of histomorphisms is ensured by the following property first obtained in [21].
Proposition 3.6 Let ⟨μF, in⟩ be the initial F-algebra, h : μF → C and ϕ : F (F νC) → C. Then the equation h. in = ϕ.F (unfoldν⟨h, in−1⟩) holds if and only if h = fst . out . foldμ(out−1 . ⟨ϕ, Id⟩). Therefore we can deﬁne a histomorphism as cvfoldμ ϕ = fst . out . foldμ(out−1 . ⟨ϕ, Id⟩).
An interesting task is to model course-of-value recursive types in Kleisli cate- gories or to compare histomorphisms with Kleisli or Eilenberg-Moore constructions. However, it is not a goal of this paper to further develop the work on category theory (for this see [19,21]), but rather to implement recursion principles in the setting of typed lambda calculi, taking the categorical approach as a foundation. We discuss next the general idea to model later the principle of course-of-value iteration.
From Categories to Types
Our goal is to implement the course-of-value iteration scheme as defined by histo- morphisms. This categorical approach is interesting and useful to obtain recursion combinators in typed lambda calculus. Recall that although the untyped lambda calculus has general recursion, the simple typed lambda calculus lacks recursion, for fixed-point operators like Y are not typable and, although simple iteration princi- ples can be modelled in the second-order lambda calculus (system F), the encodings are impredicative and very hard to handle from a practical point of view.
To implement categorical combinators as constructors of typed lambda calculi, we need to see the type system as a category T where types are objects, arrows

are transformations between types and arrow composition is the usual composition. Such categories of types and their features are well-known, see for example [4].
A functor F : T → T is then a transformation between types. In particular we use functors FX depending on a type variable X, which map a type B to a type FB. Such functors are defined, more accurately, by expressions of the form λXF or F = λXG abstracting the type variable X. Note that the systems developed in this paper are not higher-order and therefore abstractions like λXF are only a useful notation. In particular an application (λXF )B of a functor to a type B should be understood as the capture-avoiding substitution F [X := B].
Our aim is to define type systems with (co)inductive types: given a functor λXF we model its initial algebra with an inductive type μ(λXF ) or its final coalgebra with a coinductive type ν(λXF ) . Observe that we cannot consider λXF to be immediately a functor, for we only know its action on objects (types) but not on arrows (transformations between types). To allow the construction of the types μ(λXF ), ν(λXF ) for a functor, type systems handling some kind of recursive or (co)inductive types, usually require the syntactical condition of X ocurring only on positive positions in F , that is, not to the left of an odd number of the → type constructor (see, for example [7]). Such condition guarantees the functoriality or monotonicity of λXF on function types. In our treatment we prefer to follow [13] and use full monotonicity instead: the functoriality of λXF on arrows is represented
internally by means of a term map : (λXF ) mon in a given context.  The type
(λXF ) mon, defined as ∀X∀Y.(X → Y ) → F → FY , represents the fact that the functor λXF is monotone (covariant) with respect to its argument X. Such terms are called monotonicity witnesses. For the merits of using full-monotonicity instead of positivity we point to [2]. In conclusion, a functor in our framework is a pair
⟨λXF, map⟩ where map is a term of type (λXF ) mon in the needed context. Thus, our functors are just like instances of the class Functor in Haskell. Next we define the basic (co)iteration schemes following the above ideas.

The Basic System
The definition of the type (λXF ) mon implies the use of polymorphic types. There- fore the systems in this paper are all extensions of the second-order polymorphic lambda calculus, system F or λ2 (for a complete definition see appendix A). Our ba- sic system will model initial algebras and catamorphisms as well as final coalgebras and anamorphisms as follows:
Initial algebra: given a functor F = λXG we model its initial algebra ⟨μF, in⟩ by means of a new type μF , called an inductive type, and a type constructor in defined by the following rule:

Γ ▶ t : F (μF ) (μI) Γ ▶ in t : μF
Catamorphisms: we introduce a new ternary term constructor foldμ typed as

follows:

Γ ▶ t : μF
Γ ▶ m : mon F
Γ ▶ ϕ : F B → B

Γ ▶ foldμ
(μE)
m ϕ t : B

Finally the operational semantics is given by the following reduction rule, rep- resenting the principle of iteration:
foldμ m ϕ (in t) → ϕ(m (foldμ m ϕ) t)
where foldμ m ϕ means λx. foldμ m ϕ x. From now on we will be using similar conventions without further notice, for they simplify the reading of reduction rules. The origin of this reduction rule is clear, it corresponds to the principle of iteration of definition 2.1. It is also worth noting that the operational semantics models only a weak initial algebra, for we are not modelling uniqueness. However, this suffices our purposes.
Final coalgebra: given a functor F = λXG we model its final coalgebra ⟨νF, out⟩ by means of a new type νF , called a coinductive type, and a type constructor out with the typing rule:

Γ ▶ t : νF
Γ ▶ out t : F (νF )
(νE)

Anamorphisms: we introduce a new ternary term constructor unfoldν, typed as follows:
Γ ▶ t : B
Γ ▶ m : F mon
Γ ▶ ϕ : B → FB 

Γ ▶ unfoldν
(νI)
m ϕ t : νF

The operational semantics is given by the following reduction rule, representing the principle of coiteration:
out(unfoldν m ϕ t) → m(unfoldν m ϕ)(ϕ t)

Systems with iteration and coiteration constructors are well-known, in particular the one just described here is safe and terminating, for simple (co)iteration is definable as syntactic sugar in F, see for example [6,13,17].

On Inverses
Proposition 2.6 states that the arrows in, out are isomorphisms. The inverses in−1, out−1 play usually the role of inductive destructors and coinductive construc- tors, respectively. In the case of Nat the inverse in−1 : Nat → 1 + Nat represents the predecessor function whereas for stream A the inverse out−1 : A × stream A →

stream A represents the stream constructor cons. These operators are modelled in a type system by the following rules:


Γ ▶ t : μF
Γ ▶ m : F mon

Γ ▶ in−1 m t : F (μF ) with operational semantics
Γ ▶ t : F (νF ) Γ ▶ m : F mon
Γ ▶ out−1 m t : νF

in−1 m (in t) → t	out(out−1 m t) → t
Observe that we are only modelling one half of the isomorphism, namely that
in−1 . in = IdF (μF ), out . out−1 = IdνF .
A System with Course-of-Value Iteration
Next, we model course-of-value iteration obtaining an extension of system F called CCVT, a system with Categorical Course-of-Value (co)inductive Types. The new features are:
Cv-algebras. Given a functor F = λXG the associated functors F× and F ν are defined as F× = λX.C × F X and F ν = λZ.ν(F×) = λZ.ν(λX.Z × F X)
C	Z
Course-of-value Iteration:


Γ ▶ t : μF
Γ ▶ m : F mon
Γ ▶ ϕ : F (F ν C) → C
Γ ▶ cvfoldμ mϕt : C




(μEcv)

The dynamic semantics is given by the following reduction rule:
cvfoldμ mϕ (in t) → ϕ m unfoldν m× ⟨cvfoldμ mϕ, in−1⟩ t 
where m× = λfλp.(fst p, mf (snd p)). Therefore, this reduction corresponds to the principle of course-of-value iteration of definition 3.4

Let us see now the meaning of these definitions on natural numbers.

Course-of-Value on Usual Natural Numbers
The type of natural numbers is defined as Nat = μF with F = λX.1 + X and canonical monotonicity witness mapN = λf.[inl, inr .f ], where [f1 f2] = λx.case(x, y.f1y, z.f2y) is the copair of functions. The constructors 0 : Nat, suc : Nat → Nat are encoded in the in arrow by 0 = in(inl ) and suc n = in(inr n). In this case a histomorphism is a function f : Nat → C defined by f = cvfoldμ mapN ϕ with step function ϕ : 1 + Colist(C) → C, where Colist(C) = F ν(C) = ν(λX.C × (1 + X))

is the type of potentially infinite non-empty lists. This coinductive type has coded destructors head and tail, denoted here as cur : Colist(C) → C, cur = fst . out, prev : Colist(C) → 1+ Colist(C), prev = snd . out, which return the current value and the colist of previous values of a given colist, respectively. The operational semantics becomes
f (in t) → ϕ mapN unfoldν mapN× ⟨f, pred⟩ t 
where pred : Nat → 1 + Nat is the predecessor function on naturals defined as pred = in−1 mapN. The anamorphism g = unfoldν mapN× ⟨f, pred⟩ behaves as fol- lows: out(g 0) →٨ (f 0, error) , out(g (suc x)) →٨ f (suc x), inr(g x) .
Therefore g is esentially the history rcd f given in definition 3.1. A histomor- phism f , is easier to understand if the step function ϕ is decomposed as the copair ϕ = [z, s] with z : 1 → C, s : Colist(C) → C. In this case f behaves as follows: f 0 → z , f (suc n) → s(g n). Thus, f corresponds to the function defined by course-of-value iteration with basis z  and step function s according to definition
3.1. The record function rcd f is now faithfully implemented and the scheme of course-of-value iteration on naturals is fully available.
Example 5.1 The Fibonacci function fibo : Nat → Nat such that fibo 0 = 1, fibo 1 = 1, fibo(n + 2) = fibo(n) + fibo(n + 1) is programmed as fibo n = cvfoldμ mapN [z, s],n where z = λ .1 is the constant function returning 1 and s = λx.case prev x, y.1, z.(cur x)+(cur z) . It can be verified that this is a sound def- inition, for its behavior is fibo 0 → 1, fibo 1 → 1, fibo(n + 2) → fibo(n)+ fibo(n + 1).

Course-of-Value Iteration as Syntactic Sugar
As we have seen in the previous section, the principle of course-of-value iteration can be faithfully modelled in a type system. However a natural question when proposing a new language is if the new constructors could be defined, as syntactic sugar, in a basis language, which usually already has some important properties like safety or termination. It turns out that this holds in our case. Consider the following alternative reduction rule for course-of-value iteration:
cvfoldμ m ϕ (in t) → cur . foldμ m (out−1 m× . ⟨ϕ, Id⟩) (in t)
The system obtained from CCVT by abandoning its reduction rule in favor of the above rule is called CCVT2.
A nice explanation for this reduction in the case of Nat is the following: Given f : Nat → C, its record rcd f : Nat → Colist C can be defined either by coiteration as in definition 3.1, or iteratively as: rcd f 0 = [f 0], rcd f (n + 1) = (f (n + 1) : (rcd f n)). This last choice corresponds to the above rule, since if we put f : Nat → C as be- fore, with ϕ = [z, s] : 1 + Colist C → Colist C and rcd f = foldμ mapN (cons .⟨ϕ, Id⟩) : Nat → Colist C, where cons = out−1 mapN× is the colist constructor, then we get the following behavior: rcd f 0 → cons (z , error), which yields the single colist [z ], cor- responding to [f 0]. Similarly, rcd f (suc n) → cons (s(rcd f n), inr(rcd f n)) yields essentially the colist (f (suc n) : rcd f n). Therefore we can restate the reduction

rule as f (in t) → cur(rcd f (in t)) which implies f n → cur(rcd f n) for n : Nat. This looks really inefficient, for it reduces the problem of constructing the value of f at n to the construction of the whole record up to n and only then taking its head, which is the needed current value.

Memoizing Histomorphisms
The above inefficiency can be avoided by a dynamic programming technique called memoization which consists in storing previously computed values of a function instead of recalculating them. This can be achieved by simple coiteration as follows, according to the treatment in [8]. The function tabN : (Nat → C) → stream C, defined coiteratively as tabN f = (f 0 : tabN(f. suc)), constructs the whole record of the function f , namely tabN f = [f 0,f 1,f 2,.. .]. To obtain a particular value f n we need a consulting function consN : Nat → stream C → C such that consN ns returns the nth element of the stream s. This function is defined iteratively as consN 0 = head, consN (n + 1) = (consN n). tail. Finally we define memo : (Nat → C) → Nat → C by memo = (flip consN). tabN, where flip = λfλxλy.f y x. Thus, memo f is a memoized efficient version of f .
Remark 5.2 The alternative dynamic semantics for course-of-value iteration in CCVT2 is not directly acceptable from a practical point of view but, as the above discussion shows, efficiency can be gained by implementing memoization. This can also be done with the previous semantics which is also inefficient.
From the theoretical point of view this semantics is an improvement over the former, for now the histomorphisms are just syntactic sugar definable on the basic system of section 4.1. We can observe that the reduction rule of CCVT2 consists in desugaring the cvfoldμ constructor exactly as in proposition 3.6.

On Safety and Termination
Type safety is a desirable property for a language, usually composed by subject reduction (type preservation) and evaluation progress.
Proposition 5.3 (Subject reduction) Systems CCVT, CCVT2 enjoy subject re- duction. That is, if Γ ▶ e : A and e → e' according to CCVT or CCVT2 then Γ ▶ e' : A
Proof This can be easily achieved in a similar way to the proof for the systems in [17], which is based in the one for system F given in [11]. Observe that the property is not trivial as it would be for a Church-style system. The systems are presented here in Curry-style and therefore the rules for polymorphic typing are not syntax-directed.	 
Proposition 5.4 (Progress) Systems CCVT, CCVT2 enjoy progress of the evalu- ation relation. That is, if ▶ e : A then either e is a normal form or there exists e' such that e → e'.
Proof Straightforward induction on ▶.	 

On the other hand the termination or strong normalization property for a lan- guage generates some interesting remarks. From the point of view of language design, this is not a decisive issue although its merits are also defendable, see [20]. From the point of view of program analysis the undecidability of the halting prob- lem leaves no hope for an automated universal termination checker. We have to put up with a termination checker working for some restricted class of programs together with human reasoning. For example the prominent system T of Go¨del cap- tures the class of primitive recursive functions on natural numbers, and the basic system of section 4.1 guarantees termination for the class of (co)iteratively defined functions on every monotone (co)inductive type. Termination checkers are either syntax-directed using a well founded order on terms for instance, or type-based where termination is ensured by a type system; that is, if a program passes the type-checker, then it will terminate on all inputs. This is the kind of termination we pursuit here. For a deep discussion on termination we point to [1].
Next, we make some remarks related to termination of our systems.
The languages CCVT, CCVT2 are not terminating. This is exclusively due to the reduction rules for (co)inductive inversion. Define T = ν(λX.X → 1),m = λfλxλy. , ω = λx.(out x)x, Ω = ω(out−1 m ω). We have the typings ▶ m : (λX.X → 1) mon, ▶ ω : T → 1, ▶ out−1 m ω : T and
▶ Ω : 1.  With the rule out(out−1 m t) → t we get Ω →+ Ω as follows: Ω → (out(out−1 m ω))(out−1 m ω) → ω(out−1(m, ω)) ≡ Ω. The same hap- pens with the rule in−1 m (in t) → t. This phenomenon was first noticed in [14] for fixed-point-types. It is worth noting that the type T is non-positive and trivial.
A natural question is asking if there would be a positive type causing no termi- nation, but we are not aware of such example. However we can mention that, for the case of positive types the out−1 constructor and its operational semantics can easily be defined in an extension of F with primitive corecursion, which we prove to be terminating in [16]. For a further discussion on this see appendix B of [12].
The languages CCVT, CCVT2 could be terminating. This is achieved by changing the operational semantics for inversion as follows:
out(out−1 m t) → m(λzz)t	in−1 m (in t) → m(λzz)t
Observe that categorically the expressions m(λzz)t and t are equivalent as m plays the role of a functor on arrows, and λzz is the identity arrow. Therefore, m(λzz)t = t is a consequence of the first functor law F (Id) = Id.
The termination of these new systems is carried out by a type-respecting and reduction-preserving embedding into a terminal system developed in [17], which is basically the one described in section 4.1 plus the above operational rules for inversion. The essential part of this embedding can be read from the definition of histomorphisms by catamorphisms (simple iteration) of proposition 3.6.
The price of termination. In our type systems the reduction m(λzz)t → t, needed for a correct operational semantics, does not hold in general. An interesting task is to assert when it holds, for which we can give the following answer: If F = λXG and X occurs only positively in G, then the first functor law can

be ensured for so-called canonical witnesses defined recursively according to the shape of G (see [13,16]). However, some extensionality principles are needed. That is, if m is canonical then m(λzz)t →βη t. For instance, for natural numbers the witness mapN = λf.[inl, inr .f ] is canonical and we have mapN(λzz)t →٨ case(t, y. inl y, z. inr z) →η t. The price is high, for it is well-known that subject reduction fails already for system F (see [16], page 65) when adding the rule λx.fx →η f, x ∈/ FV (f ).
From the above remarks it is clear that, for the current extensions, termination should not be pursuit. However, there is another way to define course-of-value iteration, which is based on a fixed-point logic, is terminating and does not require inversion principles.

The Logical Approach
From the logical point of view, (co)inductive types correspond to fixed-points of monotone operators F = λX.G. In particular the course-of-value least-fixed point, denoted by μ٨F is algebraically defined as the least element of the set of all R's such that F (ν(λX.R ∧ FX)) is less than R. Observe that this condition is analogous to the definition of a cv-algebra. Based on this idea, we describe another type system.

The Iterative System LCVT
This extension is essentially the natural deduction system involving the course-of- value logical constant μ٨ in [22], gained by using the Curry-Howard correspondence. We call this a system with Logical Course-of-Value (co)inductive Types. In com- parison to our previous system CCVT we will have a new kind of inductive type denoted μ٨F , which is characterized by a different way of constructing its inhabi- tants. Moreover, there will be no need to use the inverse constructors in−1, out−1 anymore, which are the source of non-termination in the previous systems.
LCVT is obtained by modifying the rule for course-of-value-iteration (μEcv) of page 9, replacing μF by μ٨F and adding a new unary constructor cvin with the below mentioned typing rule corresponding to folding of the course-of-value least fixed point:

Γ ▶ t : F (F ν(μ٨F ))
Γ ▶ cvin t : μ٨F	μI
cv)

where F ν = λZ.ν(λX.Z×F X) as before. Observe that we are using a conventional coinductive type ν to define the new course-of-value fixed point μ٨.
The operational semantics is given by the following rule:

cvfoldμ mϕ (cvin t) → ϕ m unfoldν m× ⟨(cvfoldμ m ϕ) . cur, prev⟩ t 

where cur, prev, m× are defined as before. This rule is easier to understand if we set f = cvfoldμ m ϕ, becoming f (cvin t) '→β ϕ m (unfoldν m×⟨f. cur, prev⟩) t . Let us see now its meaning on course-of-value natural numbers.

Course-of-Value Natural Numbers
The inductive type of course-of-value natural numbers is defined as Nat٨ = μ٨(λX.1+X). This is not the usual type of natural numbers. In particular, the usual succesor function is not directly encoded by cvin, whose native encoded construc- tors are 0 : Nat٨, 0 = cvin(inl ) and suc٨ : Colist(Nat٨) → Nat٨, suc٨ = cvin . inr. This last function defines a course-of-value succesor receiving a colist of natural numbers and encapsulating it to form a new natural number. The operational semantics captures yet another scheme of course-of-value recursion based on a func- tion rcd٨ : (Nat٨ → C) → Colist Nat٨ → Colist C which constructs the record of a function on a given colist of arguments, namely rcd٨ f [a1,..., ak] = [f a1,...,f ak]. Thus, rcd٨ is a map function on colists. Given f = cvfoldμ mapN ϕ : Nat٨ → C the function rcd٨ f is implemented as rcd٨ f = unfoldν mapN×⟨f. cur, prev⟩ and if ϕ = [z, s] the reduction rule yields f 0 → z and f (suc٨ l) → s(rcd٨ f l). To obtain a scheme working on numbers and not colists we need to implement the usual succesor function. This can be done as in [22], by defining suc = suc٨ . tcl where tcl : Nat٨ → Colist(Nat٨) receives a number n and constructs the colist [n, n − 1,..., 0], therefore the number suc n encapsulates its colist of predecessors just as a set-theoretic ordinal is simply the set of its predecessors. Thus, we can im- plement a course-of-value iterative function corresponding to the following scheme working with numbers directly: Given a : Nat٨, g : Colist C → C there is a function f : Nat٨ → C such that f 0 = a, f (n + 1) = g (rcd٨ f [n,..., 0]). A corresponding cvfold operator can be easily defined in Haskell. In particular, if the scheme is well implemented in the type system, the Fibonacci function definition of example
3.2 still works. But once again the operational correctness of the whole scheme depends on a good predecessor function.


The Iterative Predecessor
The predecessor function is constructed similarly to the succesor by first defin- ing, through course-of-value iteration, a function pred٨ : Nat٨ → 1 + Colist(Nat٨) which destructs a non-zero natural by returning the colist of all its prede- cessors.  The usual predecessor can then be defined as in [22], by compos- ing pred٨ with the application of the map function to the cur colist destruc- tor.  Formally we have pred = (mapN cur) . pred٨, pred٨ = cvfoldμ mapN ϕ, ϕ = mapN (unfoldν mapN× ⟨cvin . cur, prev⟩). Unfortunately this predecessor def- inition does not have the required behavior, for we only get pred(suc n) →٨ inr (cvin(pred٨ n)) but the term cvin(pred٨ n) cannot be further reduced to n as de- sired. However the reduction cvin(pred٨ n) → n seems correct, since the left hand side is constructing a new inhabitant of Nat٨ from the ancestral pred٨ n, which should be just n. This reduction seems to be an η rule modelling some kind of uniqueness. However, adding it to the system, apart from being a tailor-made so- lution, contradicts the belief that η-rules are not rules of computation, which up to our knowledge is still a piece of folklore, although it seems to be confirmed in the case of conventional (co)inductive types (see [9]).

Towards a System with Course-of-Value Primitive Recursion
It is well-known that the inefficiency of an iterative predecessor vanishes using prim- itive recursion instead of simple iteration to define it (see [18]). Therefore, we think that the needed well-behaved predecessor for course-of-value natural numbers can be obtained using primitive course-of-value recursion. Moreover, this would solve the problem not only for natural numbers, but also for the destructor of any course- of-value monotone inductive type.
Conjecture 7.1 There is a safe and terminating type system modelling course-of- value primitive recursion on monotone inductive types. Furthermore, this principle would allow us to deﬁne operationally well-behaved inductive destructors without requiring the use of η-rules.
A system including course-of-value primitive recursion has been mentioned in [23,22] but, up to our knowledge, it was never developed. We are currently designing such a system. For the time being we have the following rule for the static semantics.


Γ ▶ t : μ٨F
Γ ▶ m : F mon
Γ ▶ ϕ : F μ٨F × F ν(C) → C
Γ ▶ rcvfoldμ mϕt : C




(μEcvr)


The difference with iteration arises on the signature of the function ϕ which now requires a pair whose first element belongs to the inductive type, over which, we are recursing. For the case of Nat٨ we get ϕ : 1 + (Nat٨ × Colist C) → C, this function encodes the value c and the step function g of the following principle: given a value c : C, and a function g : Nat٨ × Colist C → C there is a function f : Nat٨ → C such that f 0 = c, f (n + 1) = g (n, rcd٨ f [n, .., 0]).
Example 7.2 An interesting example fitting this last scheme is the function bp : Nat٨ → Nat٨ returning the number of binary partitions of a number n, that is, the number of ways n can be decomposed as a sum of powers of two, ignoring the order. The usual definition is bp 0 = 1, bp (n + 1) = if even n then bp n else (bp n) + (bp (ndiv 2)) and can be implemented by course-of-value primitive recursion taking c = 1 and g (n, l) = if (even n) then head l else (head l)+ l !! (ndiv 2), where l !! n returns the nth element of l counting from zero.
Regarding the operational semantics it is clear that it should be analogous to the one for the iterative cvfoldμ, but instead of the simple coiterator unfoldν we would need a primitive corecursor (apomorphism). Further research on this subject is being done.

Final Remarks
We have presented three different safe type systems comprising course-of-value it- eration schemes. The first two are based on the categorical constructor modelling course-of-value iteration called histomorphism, and do not change the definition of datatypes as initial algebras of functors, whereas the last one comes from a logical approach based on fixed-points and changes the representation of datatypes. As all systems are safe, they can be used as prototypes for a programming language with an explicit higher-order course-of-value fold operator. Regarding termination (strong normalization), though we think this must not be a decisive issue in the design and use of a language, we adopt the point of view of type-based termination and pursuit this property finding some interesting remarks: systems CCVT, CCVT2 are not terminating though this property can be gained by a small modification to the operational semantics, yet at a high price, including the need for some exten- sionality η-rules which would jeopardise the safety of the languages, as mentioned in section 5.4. On the other hand, system LCVT is terminating, for it can be em- bedded in the basic terminating (co)iterative system of section 4.1. For the case of positive (co)inductive types this result appears in [22]. Nevertheless, the prede- cessor function needed to ensure the correctness of the course-of-value scheme on naturals, is faulty. We could overcome this defect by adding an η-rule at the price of destructing the safety of the language. A definitive solution is conjectured by the use of primitive course-of-value recursion, a useful principle that we are cur- rently studying. Furthermore, the corecursive counterpart of the systems discussed here is straightforward definable by duality (for the logical approach this has been done in [22]) and implements the scheme of course-of-value corecursion captured by a categorical construction called futumorphism in [21]. This principle allows us to specify arguments for the construction of remaining parts of a coinductive structure at arbitrary stages instead of being forced to specify for the following stage already. Concerning future work, apart from developing more examples and a Haskell implementation, we want to settle the exact relation between the categor- ical and logical approaches, as well as investigate other recursion schemes such as hylomorphisms (see [15,3]), a more recent scheme called dynamorphism, developed in [10], and the very efficient TABA-pattern of [5], not to mention Mendler-style course-of-value recursion schemes. Another line of research is the use of clausular (co)inductive types (see [7,16,17]), which improves the style of programming as well as the definition of witnesses of monotonicity by avoiding the use of injections and projections.

Acknowledgement
We are thankful to our anonymous referees for the helpful comments and sugges- tions regarding the contents and presentation of this paper. We also gratefully acknowledge the LSFA 2008 travel grants committee for providing partial funds to attend the meeting and Martha Buschbeck for improving the English manuscript.

References
Abel, A.,“A Polymorphic Lambda-Calculus with Sized Higher-Order Types”. Dissertation. Universit¨at Mu¨nchen. Germany 2006. URL: http://www.tcs.informatik.uni-muenchen.de/~abel/diss.pdf

Abel, A., R. Matthes, T. Uustalu. Iteration and Coiteration Schemes for Higher-Order and Nested Datatypes. Theoretical Computer Science 333(2005). 3-66.
Cunha, M.A., Recursion Patterns as Hylomorphisms. Technical report DI-PURe-03.11.01, Department of Informatics, University of Minho. November 2003.
Crole, R.L., “Categories for Types”. Cambridge Mathematical Textbooks. Cambridge University Press, 1993.
Danvy, O., M. Goldberg, There and Back Again. BRICS Report Series RS-05-3. University of Aarhus. January 2005.
Geuvers, H., Inductive and coinductive types with iteration and recursion. In Nordstr¨om B., K. Petterson,
G. Plotkin, Eds. Proceedings of the 1992 Workshop on Types for Proofs and Programs. B˚astad, Sweden June 1992, pp. 183-207.
Hagino, T., A Typed Lambda Calculus with Categorical Type Constructors. In Pitt D.H., Poign´e, A., Rydeheard, D.E. (eds). Category Theory and Computer Science. LNCS, vol 283. pp. 140–157. Springer, Heidelberg (1987).
Hinze, R., Memo functions, polytipically!. In Johan Jeuring, editor, Proceedings of the Second Workshop on Generic Programming, WGP 2000, Ponte de Lima, Portugal, 6th July 2000.
Howard, B.T., “Fixed Points and Extensionality in Typed Functional Programming Languages”. Ph. D. Thesis, Stanford University 1992.
Kabanov, J., V. Vene, Recursion Schemes for Dynamic Programming. In: Uustalu T., (ed) Proc. of 8th Int. Conf. on Mathematics of Program Construction, MPC 06. LNCS, vol. 4014, pp. 235-252. Springer, Heidelberg (2006).
Krivine, J.L.. “Lambda-Calculus, Types and Models”. Ellis Horwood Series in Computers and their Applications. Ellis Horwood, Masson 1993.
Matthes, R., “Extensions of System F by Iteration and Primitive Recursion on Monotone Inductive Types”, Dissertation Universit¨at Mu¨nchen, 1999. URL: http://www.tcs.informatik.uni-muenchen.de/
~matthes/dissertation/matthesdiss.ps.gz

Matthes, R., Monotone (co)inductive types and positive fixed-point types. Theoretical Informatics and Applications 33(4-5) pp. 309-328 (1999).
Matthes, R., Monotone fixed-point types and strong normalization. In Georg Gottlob, Etienne Grandjean, and Katrin Seyr, editors, Computer Science Logic, 12th International Workshop, Brno, Czech Republic, August 24-28, 1998, Proceedings, volume 1584 of Lecture Notes in Computer Science, pages 298-312. Springer Verlag, 1999.
Meijer, E., M. Fokkinga, R. Paterson, Functional programming with bananas, lenses, envelopes and barbed wire. In: Hughes, J. (ed) FPCA 91. LNCS, vol. 523, pp 124–144. Springer, Heidelberg (1991).
Miranda-Perea, F.E., “On Extensions of AF2 with Monotone and Clausular (Co)inductive Definitions”. Dissertation, Ludwig-Maximilians-Universit¨at Mu¨nchen. Germany 2004. URL: http://edoc.ub.
uni-muenchen.de/2855/

Miranda-Perea, F.E., Two Extensions of System F with (Co)iteration and Primitive (Co)recursion Principles. Submitted to Theoretical Informatics and Applications. February 2007. A preliminary draft is available on http://www.matematicas.unam.mx/favio/drafts/stmunu.pdf

Parigot, M., On the Representation of Data in Lambda-Calculus. In Egon B¨orger, Hans Kleine Bu¨ning, Michael M. Richter (Eds.): CSL ’89, 3rd Workshop on Computer Science Logic, Kaiserslautern, Germany, October 2-6, 1989, Proceedings. Lecture Notes in Computer Science 440 Springer Verlag 1990.
Simpson, A., Recursive Types in Kleisli Categories. Unpublished draft. URL: http://homepages.inf. ed.ac.uk/als/Research/kleisli.ps.gz

Turner, D., Total Functional Programming. Journal of Universal Computer Science, v. 10, n. 7. pp 751–768. 2004.
Uustalu, T., V. Vene, Primitive (co)recursion and course-of-value (co)iteration, categorically. INFORMATICA, v. 10, n.1, pp. 5-26. 1999.


Uustalu, T., V. Vene, Least and greatest fixed-points in intuitionistic natural deduction. Theoretical Computer Science, v. 272, n. 1-2, pp. 315-339, 2002.
Uustalu, T., “Natural deduction for intuitionistic least and greatest fixedpoint logics, with an application to program construction” (PhD thesis). Dissertation TRITA-IT AVH 98:03, Dept. of Teleinformatics, Royal Inst of Technology (KTH), Stockholm, 1998.
Vene, V., “Categorical programming with inductive and coinductive types”. Diss. Math. Uni. Tartuensis,
v. 23, Uni. of Tartu, Aug. 2000.

A	System F
We describe here system F of Girard and Reynolds in a Curry-style presentation. For convenience we add sums, products and unit type as primitives.
Types. Built from an infinite set of type variables denoted by metavariable X. A, B, C, F, G ::= X | A → B | ∀XA | A + B | A × B | 1
Terms. Built from an infinite set of term variables denoted by metavariable x. t, r, s ::= x | λxr | rs | inl r | inr s | case(r, x.s, y.t) | (r, s) | fst r | snd r | 
Contexts. Finite sets Γ of pairs of the form x : A. The expression Γ,x : A denotes
the context Γ ∪ {x : A} always assuming that a pair x : B was not previously declared in Γ.
Typing rules. Inference rules of the form Γ ▶ t : A denoting that t is a well-formed term of type A in context Γ.

Γ,x : A ▶ x : A (V ar)	Γ ▶  : 1 (Unit)


Γ,x : A ▶ r : B


Γ ▶ λxr : A → B
(→I)	Γ ▶ r : A → B  Γ ▶ s : A (→ E)
Γ ▶ rs : B



Γ ▶ t : A


Γ ▶ t : ∀XA
(∀I)	Γ ▶ t : ∀XA
Γ ▶ t : A[X := F ]

(∀E)



Γ ▶ r : A


Γ ▶ inl r : A + B

(+IL
)	Γ ▶ r : B
Γ ▶ inr r : A + B

(+IR)



Γ ▶ r : A + B  Γ,x : A ▶ s : C  Γ,y : B ▶ t : C
Γ ▶ case(r, x.s, y.t) : C

(+E)



Γ ▶ r : A  Γ ▶ s : B


Γ ▶ (r, s) : A × B
(×I)	Γ ▶ s : A × B
Γ ▶ fst s : A

(×EL
)	Γ ▶ s : A × B
Γ ▶ snd s : B

(×ER)

Reduction. The operational semantics is given by the one-step β-reduction rela- tion t → t' defined as the closure of the following axioms under all term formers.

(λxr)s → r[x := s]
case(inl r, x.s, y.t) → s[x := r]
case(inr r, x.s, y.t) → t[y := r]
fst (r, s) → r
snd (r, s) → s
