 Electronic Notes in Theoretical Computer Science 99 (2004) 229–243 
www.elsevier.com/locate/entcs




Model-checking the Secure Release of a Time-locked Secret over a Network 1
Salvatore La Torre1	Aniello Murano1,2	Mimmo Parente1
1 Universtit`a degli Studi di Salerno, 84041 Baronissi(SA), Italy.
2 Hebrew University, Jerusalem 91904, Israel.
{slatorre, murano, parente}@unisa.it

Abstract
Weighted timed automata extend timed automata with costs on both locations and transitions. This allows us to associate a quantitative measure to a run, and thus several problems of practical relevance for system design can be studied on this model (optimal reachability, optimal control, etc.). In this paper, we argue that weighted timed automata are suitable models for studying some security properties. In particular, we describe a scenario where we wish to send a message through a network of computers and would like to use sufficient cryptography to ensure the secrecy of the message up to a certain time deadline. We assume that an intruder attempting to decrypt the message can only use resources (computational power) that are local to the nodes visited by the message: we give evidence of this assumption based on a scenario introduced by Rivest, Shamir and Wagner. The computational power of a node is given in terms of number of operations per time unit. We show how this setting can be nicely captured by a weighted timed automaton where: the underlying timed automaton models the features of the network and the weights on the locations represent the computational power of each node. Therefore, we can use model-checking techniques to establish the desired security properties.
Keywords: model-checking, weighted timed automata, timed-release cryptography


Introduction
In Timed-Release Crypto [12] a message M is encrypted in such a way that nobody (but the originator ) can decrypt it until a desired amount of time Θ
is elapsed. Only after time Θ, the message M is available, and anyone can read it.  The novelty of such approach by Rivest et al.  is the choice of a

1 This work was supported by the MURST in the framework of the project “Metodi Formali per la Sicurezza ed il Tempo” (MEFISTO).

1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.02.010

symmetric key, that is, the same key is used both to encrypt and to decrypt the message. As usual, the key is a function that is easy to compute in the encryption phase (once the factorization of a large composite number N is known). While in the decryption phase, everybody can decrypt the message only after a pre-determined amount of time Θ has elapsed (unless one succeed in factorizing N ). Time Θ can be chosen by the originator of the message as
follows: let sq be a basic computer-operation (the squaring operation modulo
N ) and let tsq be the time required by the destination machine to perform sq, then Θ = tsq · k, where k is a positive integer chosen by the originator. Since this basic operation is intrinsically sequential, time Θ can then be precisely
specified for a machine by simply giving the number k of squaring operations to be performed.
As reported in [12] the possible applications of timed-release crypto are many: for example auctions where the bids can be opened after a given dead- line, payments that have to be done at the beginning of each month, and so on (see also [6], for other examples).
In this paper we analyze the natural scenario where the timed-release crypto is used on a message that has to get through a network of comput- ers before being delivered at a destination. Thus the sender (Alice) cannot
rely only on the speed at which the receiver (Bob) can perform sq as in [12],
but has to consider also the traversed nodes of the network that play the ad- versary role. She aims to put in M as much “difficulty” as needed to achieve the following goals: she wants to be sure that Bob will be able to decipher the message within a time interval pre-determined by her and also, she wishes to keep secret the message contents until a certain time deadline. This sce- nario is resumed in Figure 1, where the edges are labeled with an interval indicating the minimum and maximum time a message can take to cross that edge and the nodes are labeled with an interval indicating the minimum and maximum time a message can be processed in it before being forwarded to adjacent nodes 2 .
Now assume Alice chooses a k = J ∗, the number of sq operation needed to
compute the key, and ciphers M with this key. Let CM (k) be the ciphered mes- sage. She wants to know which are her guarantees injecting the network with CM (k). More precisely, let CM (k) be a message ciphered using timed-release
crypto such that J ∗ squaring modulo N operations are needed to decipher it,
in this paper we address the following decision problem:
Security Problem: Given an insecure network of computers G witha source

2 Though this information about the network is hard to collect for large networks, as the Internet for example, we can reasonably assume this knowledge for private networks as those used in some corporate.





[1, 2]
[0, 2]
q1

[1, 3]
[0, 1]
q3


[4, 8]

A
[3, 5]
[1, 2]	[0, 2]	B

[1, 5]

q2
[2, 3]
[1, 2]
q4
[0, 3]

Fig. 1. A network with latency times on the edges and processing times on the nodes.

A and a destination B, a time deadline Θ < Θmin and a time interval [Θmin, Θmax], does CM (k) can be sent from A to B such that it cannot be deciphered before time Θ and B can read M at some later time within interval [Θmin, Θmax]?
We propose to rephrase our security problem within the framework of weighted timed automata and then solve it using model-checking techniques.
Timed automata were introduced in [2] to model real-time systems, that is, systems interacting with physical processes and whose correct behavior crucially depends upon real-time considerations. A timed automaton is a finite
automaton augmented with a finite set of real-valued clocks. Transitions are
enabled according to the current location and the current clock values. In a transition, clocks can be instantaneously reset, and the value of a clock is exactly the time elapsed since the last time it was reset. Weighted timed
automata extend timed automata by associating weights (different costs) with both locations and transitions. This model was independently introduced and studied in [3,5] 3 with the aim of providing timed automata with a performance measure of their finite outcomes. The weight of a location gives the cost of staying at that location per each time unit and the weight of a switch is the cost of taking that discrete transition. Therefore, a cost is associated to each run as the sum of two addend: the sum of the costs of the taken switches and the sum of the costs of the time spent in each location. This way, with each run a linear-cost function of time is associated that accounts for visited locations and taken transitions.
A network can be naturally modeled as a timed automaton where the nodes are represented as locations, and the actions of sending and receiving a message can be modeled as transitions. Time features of the network behaviour (such as traffic delay, latency time, processing time, etc.) can be captured by clocks, resets, and clock constraints. In such a model, weights can be used to capture the computational speed of each node, i.e., the number of squaring operations

3 In [5] weighted timed automata are named linearly priced timed automata.

per time unit that can be performed at a specific location 4 . In this setting, the security problem can be rephrased as the following decision problem on weighted timed automata. Given a weighted timed automaton A and a target
location T of weight w, for all runs r ending at T of total time tr ≤ Θ we ask
the following questions where Jr denotes the cost of r:
If tr = Θ, is Jr less than J ∗?
Is there a t ≥ 0 such that t + tr ∈ [Θmin, Θmax] and w · t + Jr = J ∗?
We refer to this decision problem as the Time-cost Bounded Reachability problem (shortly TBR problem). Clearly, to decide this problem it is suffi- cient to determine the maximum and the minimum cost runs to T among
all the runs that reach T within time Θ. In this paper, we give a solution that consists of reducing these problems to analogous problems in a weighted (discrete) directed graph and then uses standard algorithms to solve them. The reduction requires the construction of a graph of exponential size in the length of parameter Θ and in the number of clock variables. If we use Dijk- stra’s algorithm to compute shortest paths from a single source, to solve the optimization problems on the resulting discrete graph, it turns out that the total time taken by our algorithm is exponential in the length of Θ and in the number of clock variables. For the TBR problem we have a trivial lower bound from reachability in timed automata that is known to be Pspace-complete [2]. We recall that the minimum-cost reachability problem on weighted timed automata was independently studied in [3] and [5]. Let us note that the methods used in those papers do not apply directly to compute the maximum cost of a run. Moreover, also for the computation of the minimum cost of a run, here we consider a simpler setting (we have an upper bound on the time of the runs we consider) and even if this does not allow to achieve dramatic improvements of the computational complexity of the decision algorithms, the description is much simpler. Minimum-cost reachability and minimum- cost control problems on acyclic weighted timed automata were studied in [8]. In [1], a weight w can be associated with each location q such that w gives the cost of a unit of time spent in q. On such a model, given a cost interval I and two states s and t, the decision problem “is t reachable from s at a
cost c ∈ I?” (duration-bounded reachability ) is addressed. Duration-bounded reachability differs from time-cost bounded reachability since the latter has as
a parameter also a time bound besides a cost bound. Finally, time-optimal

4 In a general framework, the computational speed of a node may depend on several pa- rameters: number of performed tasks, resource allocation, and so on. Here, we assume that we have an accurate assessment of the expected values of such parameters and thus of the expected speed at which the squaring operations can be performed at each node of the network.

reachability, that is, the minimum time to reach a given target location, was first considered in [7]. In that paper, the authors addressed the problem of computing lower and upper bounds on time delays in timed automata. Minimum-time reachability is also considered in [11] and the related minimum- time control problem is considered in [4].
The rest of the paper is organized as follows. In Section 2, we recall the main ideas used in timed-release crypto [12] and state our security problem. In Section 3 we recall the definition of weighted timed automata and introduce our notation. Our solution to the TBR problem for weighted timed automata is given in Section 4. Finally, in Section 5 we give a few remarks.

Timed-Release Crypto
In this section we recall how the timed-release crypto can be implemented using the so-called “time-lock puzzle” computational problems, following [12]. In Section 2.2 we briefly describe the problem in our setting.

Time-lock puzzles
A time-lock puzzle is a computational problem (puzzle) that cannot be solved unless a machine performs a computation for at least a certain amount of time. Here is how Rivest et al. have created the time-lock puzzle implementing the timed-release crypto. Alice has a message M for Bob but she wants to encrypt M for a period of time Θ, that is, she does not want Bob (or any other) decrypt the message before time Θ has elapsed. To perform this encryption she executes the following steps:
She generates a composite number N computed as the product of two large primes p and q. Along with it she also computes the Euler function Φ(N ) = (p − 1)(q − 1).
She computes k = Θ · spBob, where spBob is the number of squaring operations modulo N that Bob can perform per time unit (in some sense
the speed of Bob’s computer).
She picks a random a modulo N 5 and encrypts M as CM (k) = M + a2k (mod N ). This operation is performed efficiently by computing first e = 2k(mod Φ(N )) and then computing CM (k) = M + ae(mod N ).
She sends the puzzle (N, a, k, CM (k)) to Bob and erases all variables created (as for p and q).

5 For practical purposes a =2 can also be used.

The creation and solution of the puzzle is thus based on the computation of the number a2k , for the chosen k. The scheme used is a symmetric-key encryption/decryption and the key is the number a2k . If the factorization of N is known, then the number can be computed efficiently by doing O(log N ) multiplications, otherwise the only way to compute a2k is to compute k iterated squarings, that is, each squaring can only be performed on the result of the preceding squaring. Specifically, one has to compute the function F (0) = a20 and F (i) = (F (i − 1))2, for 0 < i ≤ k. As the squaring is a basic operation, an attempt of parallelization is useless since the communication complexity
would be overwhelming, see [10] for more on this.


Our problem
As described in the previous section, the authors of [12] created a computa- tional problem (a ciphered message CM (k)) that can be solved (deciphered) in a certain amount of time Θ (chosen by Alice, and depending on Bob’s com- puter power to decipher it). Our setting extends their approach in that here CM (k) has to get through a network before reaching the destination. The computers of the network are all adversaries of Alice playing together: each of them performs some computation on what received, for some time, and then it transmits the result to the adjacent computers. We assume that each node of the network has an interval of time within which it can compute and each link connecting two computers has an interval bounding the time a message can suffer to get through it (both of these intervals represent usual traffic delays in a network), see Figure 1. Obviously, there are other time constraints in the networks, modeling more practical and complicated situations.
In such a scenario, Alice may not be able to choose an instant at which she wants that Bob would decipher the sent message, since there are many com- puters with possibly different computational capabilities that can be visited each for a different amount of time. Thus, she will rather pick an interval of time [Θmin, Θmax] and require that Bob will decipher the message within this interval. Another complication is that Alice cannot refer to a single computer (Bob’s computer in the previous scenario) for calculating a suitable number k of squaring modulo N operations that must be performed to ensure decryption within [Θmin, Θmax]. In fact, she needs to refer to the speed of the computers that CM (k) may visit but also to the amount of time CM (k) may spend in each of them. Moreover, for each connecting path it is important to verify its
feasibility, that is, whether the path agrees with the time constraints of the network. Therefore, given a network A, instead of the step (ii) of the schema from Section 2.1 Alice will perform the following steps:

She chooses a time Θ.
She computes the minimum and the maximum number of squaring mod- ulo N operations that the network can perform using exactly time Θ, called Jmin and Jmax, respectively.
She chooses J ∗ > Jmax.
She computes Θmin = Θ + (J ∗ − Jmax)/spBob and Θmax = Θ + (J ∗ −
Jmin)/spBob.
In the rest of the paper, we will discuss a tool for automatically performing the above step 2. Assuming that we can determine Jmin and Jmax, directly from the above scheme, the following properties hold.
Proposition 2.1 For all paths p of A with finishing time tp ≤ Θ, the total number of squaring operations along p are less than J ∗.
Proposition 2.2 For all paths p of A that reach Bob’s location at a time tp ≤ Θmin, the residual number of operations to perform can be computed in time t' such that t' + tp ∈ [Θmin, Θmax].
Observe that Proposition 2.1 ensures that nobody can decipher the mes- sage earlier than time Θ, and Proposition 2.2 ensures that Bob can decipher the message within [Θmin, Θmax],

Weighted timed automata
In this section, we recall the definition and the notation of timed automata and weighted timed automata.
A timed automaton models a real-time system. We assume that there is a central (real-valued) clock, and the model can use a finite set of clock variables (also said simply clocks) along with time constraints to check the satisfaction of time requirements. Each clock can be seen as a chronograph synchronized
with the central clock, thus it can be read or set to zero (reset): after a reset, a clock restarts automatically. In each automaton, time constraints are expressed by clock constraints. Let C be a set of clocks, the set of clock constraints Ξ(C) contains:
x ≤ y + c, x ≥ y + c, x ≤ c and x ≥ c ∀x, y ∈ C and for a natural number c;
¬δ and δ1 ∧ δ2 where δ, δ1, δ2 ∈ Ξ(C).
Furthermore, a clock interpretation is a mapping ν : C −→ R+. We denote by 0 the clock interpretation mapping each clock to 0. If ν is a clock interpre-
tation, λ is a set of clocks and d is a real number, we denote with ν + d the clock interpretation that gives the value ν(x) + d for each clock x, and with


λ(ν) the clock interpretation that differs from ν only on the values of clocks x ∈ λ to which it assigns 0. In particular, we will use λ(ν + d) to denote the clock interpretation that assigns to a clock x value 0, if x ∈ λ, and ν(x)+ d, otherwise.
Definition 3.1 A timed automaton A is a tuple (Σ, Q, Q0, C, ∆, inv ) where:
Σ is a finite set of symbols (the alphabet);
Q is a finite set of locations;
Q0 ⊆ Q is the set of initial locations;
C is a finite set of n clock variables;
∆ is a finite subset of Q× Σ × Ξ(C) × 2C ×Q (edges);
inv : Q −→ Ξ(C) maps each location q to its invariant inv (q).
The clock constraint on an edge is called a guard. A state of a timed automaton A is a pair ⟨q, ν⟩ where q ∈ Q and ν ∈ Rn .  An initial state is a pair ⟨q0, 0⟩ where q0 ∈ Q0 is an initial location. The semantics of a timed automaton is given by a transition system over the set of states. The
transitions of this system are divided into discrete steps and time steps. A

discrete step is
σ	'	'
where (q, σ, δ, λ, q') ∈ ∆, ν satisfies δ, ν' =

⟨q, ν⟩ −→ ⟨q ,ν ⟩
λ(ν), and ν' satisfies inv (q'). A time step is
d	' where ν' = ν + d,

⟨q, ν⟩ −→ ⟨q, ν ⟩
d ≥ 0, and ν + d' satisfies inv (q) for all 0 ≤ d' ≤ d. A step is

σ,d	'	'

where ⟨q, ν⟩ −→d
⟨q, ν⟩ −→ ⟨q ,ν ⟩
⟨q, ν''⟩ and ⟨q, ν''⟩ −σ→ ⟨q', ν'⟩, for some ν'' ∈ Rn.

A timed sequence (σ, τ ) over the alphabet Σ is such that σ ∈ Σ∗, τ ∈ R∗ ,
and |σ| = |τ |.
A run r of a timed automaton A on a timed sequence (σ, τ ), where σ =

σ ... σ
and τ = τ
... τ , is a finite sequence
σ1 ,τ1
σ2 ,τ2
σk,τk

1	k	1	k
⟨q0, ν0⟩ −→ ⟨q1, ν1⟩ −→ ... −→

⟨qk, νk⟩. We say that r starts at q0 and ends at qk. We denote with RunA the

set of A runs, and with RunN
the subset of RunA containing all the runs r

over a timed sequence (σ, τ ) such that τ is a sequence of integers (i.e., delays
σ1 ,τ1	σ2 ,τ2
in these runs are natural numbers). For a run r = ⟨q0, ν0⟩ −→ ⟨q1, ν1⟩ −→
σk,τk	σ1	σ2	σk
... −→ ⟨qk, νk⟩, the signature of r is q0 −→ q1 −→ ... −→ qk, that is, the
sequence of the visited locations and of the taken discrete steps. Moreover,
the total time taken by r is Σk	τi.
A weighted timed automaton is a timed automaton A with cost functions:
Js : ∆ −→ N (switch cost ), and
Jd : Q −→ N (duration cost).
Given a run r of A, let e1,... , ek be the sequence of transitions taken in
r and q0,... , qk be the sequence of visited locations. We associate to r the

following costs:
Js(r) = Σk	Js(ei), and
Jd(r) = Σk−1 τi · Jd(qi).
The total cost associated with a run r is then J (r) = Js(r)+ Jd(r).
In the following example we show a weighted timed automaton modeling a simple network of computers.
Example 3.2 Consider the timed transition system in Figure 2. It models as a weighted timed automaton the network from Figure 1. Besides the locations that are already in Figure 1, there are 5 additional locations p0, p1, p2, p3, p4 that are used to implement the transmission delays, that is, the time elapsed from the instant at which the message is sent from a node of the network to the instant at which the same message is received at the destination node. We need to use locations to model transmission delays since transitions in timed automata are instantaneous (i.e., they are not time consuming) and we need to distinguish between processing time and transmission time at each node of the network. The only starting location is A. The automaton in Figure 2 uses two clocks. A clock x is used to account for the time spent at each location and thus is reset on each transition (for a clearer representation in Figure 2 we have omitted the resets on the edges) and a clock y is used to measure the total time to reach B from A. Weights on the locations represent the computational power of the corresponding node in the network, that is, the number of operations that can be performed per time unit. Therefore, 0 labels all the locations p0, p1, p2, p3, p4 that do not represent an actual node of the network. There are no weights on the edges, and there are only trivial invariants. Therefore, they are omitted in the figure. Guards are used to model processing and transmission delays.

Consider a run of A r = ⟨A, (0, 0)⟩ −→0
⟨p , (0, 0)⟩ −1→.5
⟨q , (0, 1.5)⟩ −0→.2

⟨p , (0, 1.7)⟩
−→1
⟨q , (0, 2.7)
0.1
(0, 2.8)
6.3
(0, 9.1)⟩.  The cost

1	3	⟩
−→ ⟨p3,
⟩ −→ ⟨B,

associated with r is J (r) = 0.2 · w1 + 0.1 · w3 and represents the amount of
computation performed in the network on the path from A to B. The total
time of r is 9.1.	 


Decision and optimization problems on WTA
In this section, we discuss two optimization problems on weighted timed auto- mata that address step 2 of the scheme given in Section 2.2. Solving these problems turns out to be sufficient to solve a general decision problem on weighted timed automata that is a natural framework for verifying security


w1	0	w3	0







w2	0	w4	0
Fig. 2. A simple model of a network.

properties of the type discussed in this paper.
Step 2 of the scheme from Section 2.2 requires the computation of the minimum and the maximum number of squaring operations modulo N that the network can perform using exactly a time Θ chosen by Alice. We can reduce this problem to compute minimum and maximum cost runs in weighted timed automata. For this purpose, we can model the network as a weighted timed automaton as in Example 3.2, then we add a target location T with transitions to T from all locations corresponding to an actual node in the network. We let this added transitions be guarded by z = Θ where z accounts for the total time since the starting of the computation.
Let A be a weighted timed automaton and T be a target location. The
maximum-cost reachability at a fixed time Θ is the problem of computing the
maximum cost over all runs ending at T and whose total time is Θ. Anal- ogously, the minimum-cost reachability at a fixed time Θ is the problem of computing the minimum cost over all runs ending at T and whose total time is Θ. Let us recall that minimum-cost reachability at a fixed time is a special
case of the minimum-cost reachability problems addressed in [3] and [5].
In the following, we will reduce the defined minimum-cost and maximum- cost reachability problems on weighted timed automata to the analogous prob- lems on weighted directed graphs. To simplify the presentation of our results, we restrict to weighted timed automata with guards and invariants that are
closed sets (closed guards and invariants). This is without loss of generality, since for a timed automaton A, the minimum and the maximum cost of runs
at time Θ are those of the weighted timed automaton A' that is obtained from
A by changing all the strict inequalities to non-strict ones (see [3]). We start with the following technical lemma that allows us to restrict our search for
optimal paths simply to the paths within RunN .
Lemma 4.1 Let A be a weighted timed automaton with closed guards and

invariants. Given a run r ∈ RunA, there are two runs r1, r2 ∈ RunN
such

that J (r1) ≤ J (r) ≤ J (r2), and the signature of r1 and r2 is the same as the
signature of r.

Proof. Let r be

σ1 ,τ1
σ2 ,τ2
σk,τk

. From the resets,

⟨q0, ν0⟩ −→ ⟨q1, ν1⟩ −→ ... −→ ⟨qk, νk⟩
the invariants of the visited locations, and the guards of the taken transitions
on r it is possible to construct a system of linear inequalities I over variables
y1,... , yk such that for every choice of real numbers d1,... , dk that satisfy I,

σ1 ,d1
'  σ2 ,d2
σk,dk	'

⟨q0, ν0⟩ −→ ⟨q1, ν1⟩ −→ ... −→ ⟨qk, νk ⟩ is a run of A. Notice that coefficients
of variables in I are all 1, and being the constants in the clock constraints
natural numbers, we have that all the corner points of the polyhedral set P
corresponding to I have natural numbers as components. Recall that a linear cost function over a polyhedral set reaches its minimum/maximum at one of its corner points. Thus, we can pick (d1,... , dk) ∈ P such that the cost of a

run
σ1,d1
'  σ2 ,d2
σk,dk	'

⟨q0, ν0⟩ −→ ⟨q1, ν1⟩ −→ ... −→ ⟨qk, νk⟩ is minimized/maximized over P
and d1,... , dk are integers. Being (τ1,... , τk) ∈ P and since all inequalities in
I are not strict, we obtain the lemma.	 
The above lemma allows us to compute on a weighted directed graph. In fact, we can restrict to runs that visit states ⟨q, ν⟩ where ν(x) is an integer for every clock variable x. For the following construction, we assume that A has a clock that is never reset on all transitions (i.e., we assume that this clock always
contains the total time elapsed since the beginning of the computation). Let this clock be y. Let GA = (V, E) be the weighted graph with weight function W defined as:
V = {⟨q, ν⟩| ν(x) ∈ {0,... , Θ} for all x ∈ C and ν satisfies inv (q)};
(u, v) ∈ E and W ((u, v)) = c if and only if either u −→1	v is a time step
of A, and c = J (q), or u −σ→ v is a discrete step of A corresponding to a
transition e and c = Js(e).
A vertex ⟨q, ν⟩ of GA such that ν(y) = d is called a vertex at time d. Given a run r ∈ RunN such that its total time is not larger than Θ, we denote by ρ(r)
σ1 ,τ1	σ2 ,τ2
the corresponding path of GA. For a given run r = ⟨q0, ν0⟩ −→ ⟨q1, ν1⟩ −→

σk,τk
w1	wm

... −→ ⟨qk, νk⟩, the path ρ(r) is u0 −→ ... −→ um whΣere for i = 0,... , m, ui

is ⟨qj, νj + h⟩ with h ≤ τj+1, j ∈ {0,... , k} and i = h +
j
l=1
(τl + 1) (assuming

that the sum is 0, if j = 0) 6 . The total cost associated with the path ρ(r) is
W (ρ(r)) = Σm  wp.
The following theorem holds.
Theorem 4.2 Let A be a weighted timed automaton, T be a target location, and Θ be a positive real number. It holds that r is a run of A starting from q0 ∈ Q0, ending at T and whose cost is maximum (resp. minimum) among all the runs of total time Θ if and only if ρ(r) is a maximum-cost (resp.

6 The sequence of wi’s is uniquely determined by the sequence of ui’s being GA a graph.

minimum-cost) path in GA from ⟨q0, 0⟩ to ⟨T, ν⟩, where ⟨T, ν⟩ is a vertex at time Θ.
Proof. By Lemma 4.1, we can restrict the search for minimum/maximum cost runs to the runs in RunN . ¿From the definition of the weighted graph GA associated to A, we have that a run r of A, starting from ⟨q0, 0⟩ and ending
at T if and only if there is a corresponding path ρ(r) in GA from ⟨q0, 0⟩ to
a vertex of the form ⟨T, ν⟩. Moreover, the total time of r is Θ if and only if
⟨T, ν⟩ is a vertex at time Θ. To conclude the proof, we only need to show that the costs of r and ρ(r) coincide.

Let r =
σ1 ,τ1
σ2 ,τ2
σk,τk
.  By definition, the


path ρ(r) is
⟨q0, ν0⟩
w1
−→ ⟨q1, ν1⟩
wm
−→ ... −→ ⟨qk, νk⟩
σj+1 ,τj+1
such that each transition ⟨q ,ν ⟩

u0 −→ ... −→ um
wi+1	w '
j	j	−→

⟨qj+1, νj+1⟩ in r corresponds to a sub-path ui −→ ... −→i
ui' in ρ(r), where

j
l=1
(τl + 1) (if j = 0, then i = 0) and i' = i + (τj+1 + 1).  Recall

that for 0 ≤ p ≤ τj+1, ui+p = ⟨qj, νj + p⟩, and W ((ui+p, ui+p+1)) = Jd(qj).
Moreover, ui'−1 = ⟨qj, νj + τj+1⟩ and W ((ui'−1, ui' )) = Js(ej) where ej is the
σj+1
discrete step ⟨qj, νj + τj+1⟩ −→ ⟨qj+1, νj+1⟩. Thus, the cost associated with
wi+1	w '

u −→ ... −→i  u ' is τ
· J (q )+ J (e ), that is exactly the cost associated

i	i	j+1	d  j	s  j
σj+1 ,τj+1
with ⟨qj, νj⟩	−→	⟨qj+1, νj+1⟩.
Iterating this argument for every j = 0,... k, we have that J (r) = W (ρ(r)).
 
Using the above results we have the following theorem.
Theorem 4.3 Minimum-cost (resp. maximum-cost) reachability at a fixed time for weighted timed automata can be solved in exponential time.
Proof. By Theorem 4.2, given a weighted timed automaton A, we can restrict such problems to search for minimum and maximum-cost paths in the weighted directed graph GA. By a simple counting the number of vertices of GA is
|Q| · (Θ + 1)n, where Q is the set of locations and n is the number of clocks of
A. Thus, the size of GA is linear in the number of locations and exponential
in both the length of the representation of Θ and the number of clocks. To
compute optimal weighted paths on a weighted directed graph, we can use a standard algorithm that runs in polynomial time in the number of vertices. For example, we could use Dijkstra’s algorithm to compute the shortest paths from a single source. Hence, we get the theorem.	 
We end this section discussing a decision problem related to the considered optimization and security problems.
Let Θ ≤ Θmin ≤ Θmax and J ∗ be natural numbers. Given a weighted timed automaton A and a target location T of weight w, we are interested in

the following decision problems:
(Problem 1) For all the runs r ending at T whose total time is at most Θ, we wish to determine if J (r) is less than J ∗.
(Problem 2) For all the runs r ending at T whose total time is Θ, we wish to determine if there exists a t ≥ 0 such that t + Θ ∈ [Θmin, Θmax] and
t · w + J (r) = J ∗.
We refer to the whole of Problems 1 and 2 above as the Time-cost Bounded Reachability problem. To solve Problem 1, we can just compute the maximum cost of a run to T within time Θ. While to solve Problem 2, besides solving
the maximum-cost reachability problem we also compute the minimum cost of a run to T at time Θ. In fact, let Jmin and Jmax be respectively the minimum cost and the maximum cost of a run to T at time Θ. Clearly, there exists a t satisfying the condition required by Problem 2 if and only if both
Jmin + (Θmax − Θ) · w ≥ J ∗ and J max + (Θmin − Θ) · w ≤ J ∗ hold.
Using the above results we obtain the desired result.
Theorem 4.4 Time-cost bounded reachability for weighted timed automata is decidable and can be solved in exponential time.
Since the reachability problem in timed automata turns out to be Pspace- complete [2] we also get the following lower bound for the problem.
Corollary 4.5 Time-cost bounded reachability problem for weighted timed auto- mata is Pspace-hard.

Conclusions
In this paper, we have dealt with timed-release cryptography across a network of computers. Timed-release crypto was introduced and studied by Rivest at al. in [12], motivated by the idea of sending “information to the future”. In this paper, we have extended their approach to analyze a natural scenario where the timed-release crypto is used on a message that has to get through a network of computers before being delivered at a destination. Thus, several parameters of the used network need to be taken in account in order to ensure the secrecy of the message up to a certain time deadline. In particular, for a given insecure network of computers G with source A and destination B, we have addressed the following security problem: “Does a ciphered message CM (k) can be sent from A to B such that it cannot be deciphered before a fixed time deadline and can instead be deciphered at B within a time interval [Θmin, Θmax]?”
We have proposed a solution of this security problem based on weighted

timed automata. The solution consists of rephrasing the problem into a deci- sion problem for such class of automata, the time-cost bounded reachability. We have studied this problem and proposed an algorithm that takes time ex- ponential in the size of the time deadline and in the number of clocks used in the automaton. We observe that it is unlikely that this problem can admit a sub-exponential solution, since from the computational complexity of reacha- bility in standard timed automata [2], we get that this problem is Pspace-hard. In some situations, it is reasonable to assume that the receiver of the message can control only some nodes of the network and thus routes the message only to these adjacent nodes instead of to others. We could capture this framework by modeling the network as a two-player game on a weighted timed automaton, and search for a winning strategy of the receiver. We will
explore this scenario in a future research.

References
R. Alur, C. Courcoubetis, and T.A. Henzinger. Computing accumulated delays in real- time system. In Proc. of the Fifth International Conference on Computer-Aided Verification, CAV’93, LNCS 697, pages 181 – 193. Springer, 1993.
R. Alur and D.L. Dill. A theory of timed automata. Theoretical Computer Science, 126:183 – 235, 1994.
R. Alur, S. La Torre, and G. J. Pappas. Optimal paths in weighted timed automata. In Proc. of the 4th International Workshop on Hybrid Systems: Computation and Control, HSCC’01, LNCS 2034, pages 49 – 62. Springer, 2001. To appear in Theoretical Computer Science.
E. Asarin and O. Maler. As soon as possible: Time optimal control for timed automata. In Proc. of the 2nd International Workshop on Hybrid Systems: Computation and Control, LNCS 1569, pages 19 – 30. Springer, 1999.
G. Behrman, T. Hune, A. Fehnker, K. Larsen, P. Pettersson, R. Romijn, and F. Vaandrager. Minimum-cost reachability for priced timed automata. In Proc. of the 4th International Workshop on Hybrid Systems: Computation and Control, HSCC’01, LNCS 2034, pages 147–
161. Springer, 2001.
D. Boneh, M. Naor, Timed Commitments, Advances in Cryptology: Proceedings of CRYPTO ’00, Lecture Notes in Computer Science 1880, Springer-Verlag 2000, 236–254.
C. Courcoubetis and M. Yannakakis. Minimum and maximum delay problems in real-time systems. In Proc. of the 3rd International Conference on Computer Aided Verification, LNCS 575, pages 399 – 409. Springer, 1991.
S. La Torre, S. Mukhopadhyay, and A. Murano. Optimal-Reachability and Control for Acyclic Weighted Timed Automata. In 2nd IFIP International Conference on Theoretical Computer Science, IFIP TCS’02, pages 498 –510. Kluwer, 2002.
K. G. Larsen, G. Behrman, E. Brinksma, A. Fehnker, T. Hune, P. Petersson, and J. Romijn. As cheap as possible: Efficient cost-optimal reachability for priced timed automata. In Proc. of the 13th International Conference on Computer Aided Verification, CAV’01, LNCS, pages 493–505. Springer, 2001.
W. Mao, Timed-Release Cryptography, In Proceedings of SAC 2001, S. Vaudenay and A. Youssef (Eds.), Lecture Notes in Computer Science Vol. 2259, 342–357, 2001.

P. Niebert, S. Tripakis, and S. Yovine. Minimum-time reachability for timed automata. In
Proc. of the 8-th IEEE Mediterranean Conference on Control and Automation, 2000.
R.L.    Rivest,    A.    Shamir,    D.    A.    Wagner,    Time- Lock puzzles and Timed-Release Crypto, Technical report, MIT/LCS/TR-684. Available at the URL: (theory.lcs.mit.edu/ rivest/RivestShamirWagner-timelock.ps).
