Electronic Notes in Theoretical Computer Science 171 (2007) 11–23	
www.elsevier.com/locate/entcs

Translating Mobile Ambients into P Systems
Aman Bogdan1 and Gabriel Ciobanu2
Romanian Academy, Institute of Computer Science Blvd. Carol I nr.8, 700505 Ia¸si, Romania

Abstract
We present a translation of the mobile ambients without communication and replication into P systems with mobile membranes. We introduce a set of developmental rules over membranes, and describe the correspondence between the behaviour of an ambient and the evolution of its translated membrane system. We give an operational correspondence result between the mobile ambients and P systems.
Keywords: mobile ambients, membrane systems, operational correspondence.


Introduction
The mobile ambients and membrane systems (called also P systems) have similar structures and common concepts. Both have a hierarchical structure, and work mainly with a notion of location. Mobile ambients are suitable to represent migra- tion of processes between certain boundaries; P systems are suitable to represent the evolution of a system composed by objects, rules and membranes. We consider these new computing models, and translate the mobile ambients into membrane systems. We present this translation by explaining carefully each step of the translation.
A successful formalism for expressing mobility is provided by ambient calculus [3], where ambients change their location by consuming certain capabilities. This formalism is well suited for expressing such issues of mobile computations as work- ing environment, and access to information or resources [6]. Membrane systems represent a new abstract model inspired by cell compartments and molecular mem- branes [8]. Essentially, such a system is composed of various compartments, each compartment with a different task, and all of them working simultaneously to ac- complish a more general task of the whole system. The P systems with mobile membranes [7] is a model which expresses mobility by the movement of membranes

1 Email: baman@iit.tuiasi.ro
2 Email: gabriel@iit.tuiasi.ro

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.05.001

in such a system. The movement is given mainly by two operations: exocytosis and endocytosis. Both mobile ambients and P systems are used to model various aspects on the distributed systems. Distributed features of mobile ambients are described in [3], and distributed algorithms for membrane systems are presented in [4].
The structure of the paper is as follows. Section 2 presents the pure mobile ambients, whereas Section 3 presents the P systems with mobile membranes and local evolution rules. The core of the paper is represented by Section 4, where we present the translation of mobile ambients into P systems. We introduce a particular set of developmental rules, and simulate the behaviour of an ambient by applying the developmental rules in the corresponding P system. We establish an operational correspondence between the mobile ambients and membrane systems. Conclusion and references end the paper.

Mobile Ambients
We give a short description of pure mobile ambients; more information can be found in [3]. Given an infinite set of names N (ranged over by m, n,.. .) we define the set A of MA-processes (denoted by A, A', B,.. .) together with their capabilities (denoted by C, C',.. .) as follows:
C	::=	in n	|	out n	|	open n
A	::=	0	|	C.A	|	n[A]	|	A | B	|	(νn)A
The process 0 is an inactive process (it does nothing). The processes C.A are called actions, and the processes n[A] are called ambients. A | B is a parallel composition of MA-processes A and B, and (νn)A creates a new unique name n within the scope of A. The structural congruence ≡amb on MA-processes is the least congruence satisfying the following requirements:
(A, |, 0) is a commutative monoid;
(νm)A ≡amb (νn)A{n/m} and (νn)(A | B) ≡amb A | (νn)B, where n /∈ fn(A); if n /= m then (νn)m[A] ≡amb m[(νn)A];
(νn)0 ≡amb 0, (νn)(νm)A ≡amb (νm)(νn)A.
The operational semantics of pure ambient calculus is defined in terms of a reduction relation ⇒amb by the following axioms and rules.
(In)	n[in m.A | A'] | m[B] ⇒amb m[n[A | A'] | B]; 

Axioms:


Rules:
(Out)	m[n[out m.A | A'] | B] ⇒amb n[A | A'] | m[B]; 
(Open)	open n.A | n[B] ⇒amb A | B .

(Res)	A ⇒amb A'
(νn)A ⇒amb (νn)A'
;	(Comp)	A ⇒amb A'	;
A | B ⇒amb A' | B

(Amb)		A ⇒amb A' n[A] ⇒amb n[A']
;	(Struc)	A ≡amb A', A' ⇒amb  B', B' ≡amb B .
A ⇒amb B

We define a set TA of top ambients, and a set TC of top capabilities:

Top ambients	Top capabilities
T A(0)= ∅	1. TC(0)= ∅
T A(n[ ]) = n	2. TC(n[ ]) = ∅
T A(cap n.A)= ∅	3. TC(cap n.A)= cap n
T A(A | B)= T A(A) ∪ T A(B)	4. TC(A | B)= TC(A) ∪ TC(B)
T A((νn)A)= T A(A)	5. TC((νn)A)= TC(A)
where A, B ∈ A and cap is in, out or open.
Besides the previous known notions in ambients calculus, we introduce here a notion of deadlock: an ambient A is a deadlock if there exists no B such that A ⇒amb B. The set Ðamb of deadlocks in mobile ambients is defined by the following rules:

—

0 ∈ Ðamb
A ∈ A 

cap n.A ∈ Ðamb
D ∈ Ðamb, TA(D)= ∅

n[D] ∈ Ðamb

D ∈ Ðamb; T A(D) /= ∅; f or all j ∈ T A(D)
open j|D ⇒amb D' , out n ∈/ TC(D'),
n[D] ∈ Ðamb

A ∈ Ðamb

(νn)A ∈ Ðamb

D1, D2 ∈ Ðamb; f or all k ∈ T A(Di), for all m ∈ T A(Dj), i /= j

'
open m ∈/ TC(D ), open k | D ⇒
∈	'i

i
i	amb Dk , in m / TC(Dk ),


D1 | D2 ∈ Ðamb
We explain the rules 3, 4 and 6.
If D ∈ Ðamb does not contain any top ambients (T A(D) = ∅), then D =
D1 | ... | Dk where each Dj = cap j.D' , j = 1, k. It follows that n[D] ∈ Ðamb.
On the other hand, if D ∈ Ðamb contains top ambients (T A(D) /= ∅), then
D = D1 | ... | Dk where Dj = [jD' ]j or Dj = cap j.D' , j = 1, k. Then n[D] ∈ Ðamb

j	j
whenever out n ∈/ TC(D' ) for each Dj = [jD' ]j.
6.  If D ,D	∈ Ð	, then D	= D1 | ... |	1

1	'1	1

1	2	amb
1	1	Dt  with Dk = [kDk ]k or Dk =

'1	2	2	2	'2	2	'2

cap k.Dk , k = 1, t, and D2 = D1 | ... | Ds with Dk = [kDk ]k or Dk = cap k.Dk ,

k = 1, s. Then we have D | D  ∈ Ð 
i	'i
'
does not

1	2	amb if for each Dk = [kDk ]k, Dk
contain a capability which allows the ambient k to enter into an ambient from the
i	'i
other Dj, and for each Dk = cap k.Dk , cap k does not open an ambient from the
other Dj, where i = 1, 2, j = 1, 2 and i /= j.

P Systems
A detailed description of the P systems can be found in [8]. A membrane system consists of a hierarchy of membranes which do not intersect, with a distinguishable membrane called skin surrounding all of them. The space outside the skin mem- brane is called the environment. A membrane contains multisets of objects, evolution

rules, and possibly other membranes. The multisets of objects from a membrane correspond to the “chemicals swimming in the solution in the cell compartment”, while the rules correspond to the “chemical reactions possible in the same com- partment”. The rules must contain target indications, specifying the membrane where the new objects obtained after applying the rule are sent. The new objects either remain in the same membrane whenever they have a here target, or they pass through membranes in two directions: they can be sent out of the membrane, or can be sent in one of the membranes included in the current membrane which is precisely identified by its label. In one step, the objects can pass only through one membrane.
There are many variants and classes of P systems; many of them are introduced in [8]. We give here a short description of the P systems with mobile membranes having local evolution rules [7]. We use these particular P systems to build our translation.

Definition 3.1 A P system with mobile membranes having local evolution rules is a construct  = (V, H, μ, w1,... , wn, R), where:
n ≥ 1 (the initial degree of the system);
V is an alphabet (its elements are called objects);
H is a finite set of labels for membranes;
μ is a membrane structure, consisting of n membranes, labelled (not necessarily in a one-to-one manner) with elements of H;
w1, w2,... , wn are strings over V , describing the multisets of objects placed in the n regions of μ;
R is a finite set of developmental rules of the following forms:
[h[ma → v]m]h for h, m ∈ H, a ∈ V, v ∈ V ∗;	local evolution rules
These rules are called local because the evolution of an object a of m is possible only when m is inside h; if this restriction is not imposed, that is, the evolution of a in m is allowed irrespective of where m is placed, then we say that we have a global evolution rule, and write it simply as [ma → v]m.
[ha]h[m]m → [m[hb]h]m for h, m ∈ H, a, b ∈ V ;	endocytosis
An elementary membrane labelled h enters the adjacent membrane la- belled m, under the control of object a. The labels h and m remain un- changed during this process; however the object a may be modified to b during the operation. Membrane m is not necessarily elementary.
[m[ha]h]m → [hb]h[m]m for h, m ∈ H, a, b ∈ V ;	exocytosis
An elementary membrane labelled h is sent out of a membrane labelled m under the control of object a. The labels of the two membranes remain unchanged; the object a of membrane h may be modified to b during this operation. Membrane m is not necessarily elementary.
[ha]h → [hb]h[hc]h, h ∈ H, a, b, c ∈ V ;	elementary division rules
In reaction with an object a, the membrane labelled h is divided into two membranes labelled h, with the object a replaced in the two new

membranes by possibly new objects b and c.
We do not use rules of type (d) in the translation presented in this paper.

Relating Mobile Ambients to P Systems
In this section we describe a relationship between pure mobile ambients (without communication and replication) and P systems. This relationship is mainly pro- vided by a translation of the ambients into P systems. Other encoding of the mobile ambients into new computational models is also presented in [5]. In order to translate the pure mobile ambient into a specific class of P systems we use the following translation steps:
every ambient n is translated into a membrane having the same label n;
every capability cap n from an ambient is translated both into an object “cap n” in the corresponding membrane, and into a membrane labelled “cap n”, both placed in the same membrane; every path of capabilities from an ambient is translated into a nested structure of membranes; (for example in m.out n is translated into in m[in mout n[out n]out n]in m);
an object dlock is placed near the membrane structure after all the translation is done. The additional object dlock is used to simulate the deadlocks from mobile ambients in membrane systems. It prevents the consumption of capability objects in a membrane system which corresponds to a deadlock structure in mobile ambients.
A feature of pure mobile ambients is that they have a spatial tree-like structure. The nodes in this structure are represented by ambients and capabilities. When translating a pure mobile ambient into P systems, we obtain the same tree structure of the membrane system, where every node is a membrane corresponding to an ambient or a capability. When translate the ambient n[in m.0 | t[]] | m[] into a P system, we obtain dlock [nin m [in m]in m[t]t]n[m]m.
Whenever we translate a path of capabilities, we should preserve the order in which they are consumed. This order is preserved by the translation described above, even it requires a lot of resources. Another solution is to translate every capability only into an object, and to preserve the order of the objects by adding extra objects into the system. This should be done by introducing objects able to enchain a certain sequence of rules: for instance, if we have in n.in m . . ., then in the corresponding P system we get the rules:
in n → in n x,	in n x → in m y,	... 
Cardelli and Gordon use in [3] the following structure
p[succ[open op]] | open q.open p.P | op[in succ.in p.in succ.
(q[out succ.out succ.out p] | open op)]
Starting from such a structure, we can understand why we use the translation steps given above. For every consumed capability in mobile ambients, we simulate the change of the ambient structure by the help of some special rules in P systems. Following [7], we introduce some developmental rules. In these rules, by star objects we mean cap∗ and cap∗.

[m[nout m dlock single]n]m → [m[nout∗m out∗m dlock]n]m – whenever we have a configuration which permits us to extract membrane n from membrane m, then the object out m from membrane n is destroyed, and the objects out∗m, out∗m replace it; the object out∗m is created to announce membrane n that it can exit membrane m whenever it is an elementary membrane, and the object out∗m is created to announce that membrane out m can be dissolved;
out∗m[out m]out m → [out mδ]out m – once the object out m is consumed, this rule allows us to dissolve the corresponding membrane;
[m[nout∗m]n]m → [n]n[m]m – if membrane n is elementary, and it contains an object out∗m created by the previous rule, then the membrane labelled by n exits the membrane labelled by m, and the object out∗m is consumed;
[nin m dlock single]n[m]m → [nin∗m in∗m dlock]n[m]m– whenever we have a configuration which permits us to introduce membrane n into membrane m, then an object in m from membrane n is destroyed, and the objects in∗m, in∗m replace it; the object in∗m is created to announce membrane n that it can enter membrane m whenever it is an elementary membrane, and the object in∗m is created to announce that the membrane in m can be dissolved;
in∗m[in m ]in m → [in mδ]in m – once the object in m is consumed, this rule allows to dissolve the corresponding membrane;

[nin∗m]n[m]m  → [m[n]n]m  |[
¬cap∗ ¬cap∗]m
– if the membrane n is elementary

and contains an object in∗m created by the previous rule, and the membrane
m does not contain any star objects (this is denoted in membrane systems by
|[m¬cap∗ ¬cap∗]m ), then the membrane labelled n enters the membrane labelled m, and the object in∗m is consumed;
[m]mopen m dlock single → [mδ]mopen∗m dlock – in the presence of an object open m, the membrane m is dissolved, and the object open∗m is created to announce that membrane open m can be dissolved;
open∗m[open m]open m → [open mδ]open m – once the object open m is consumed, this rule allows us to dissolve the corresponding membrane;
[nin∗m U ∗ [t]t]n → [nin∗m U ∗ [tin∗m out∗n in∗n U ∗]t]n, where by U* we denote the set of star objects placed in the membrane n, except the object in∗m – if membrane n contains other nested membranes and an object in∗m, then it begins the process of recursively extracting all the nested membranes in order to become elementary; after this process is finished, it is allowed to enter into membrane m; the created objects from the right part of the rule are used to obtain the initial configuration of nested membranes in n. The new created objects help the membranes to exit n, then to enter m, and finally to enter again n. This rule makes a copy of all-star objects of a membrane (namely U ∗ and in∗m), and sends them in the nested membrane; it also makes two new objects which have the signature of the membrane which creates them (for example the membrane n creates the objects out∗n, in∗n, and then sends them to all nested membranes);
[nout∗m U ∗ [t]t]n → [nout∗m U ∗ [tout∗m out∗n in∗n U ∗]t]n, where by U* we

denote the set of star objects placed in the membrane n, except the object out∗m – if membrane n contains other nested membranes and an object out∗m, then it begins the process of recursively extracting all the nested membrane in order to become elementary; after this it is allowed to exit membrane m, and then rebuild the initial configuration of the nested membranes (in all the nested membranes in n are created objects which help the membranes to exit n, then to exit m, and finally to enter again in n to restore the initial configuration). This rule works similarly to the previous one;
dlock[n]n → dlock[ndlock]n |¬n[n¬dlock]n – if the object dlock is outside a mem- brane n which does not already contain an object dlock, and there is no object n in the same membrane with the object dlock, then a new object dlock is placed inside the membrane n; the rule specifies the fact that the object dlock can only pass through membranes corresponding to translated ambients, this making impossible the consumption of capability objects from the translated deadlock ambients;
[ndlock]n → [n]n – if the objects dlock is placed inside a membrane, then it is removed; in this way the object dlock outside the membrane system is preserved;
[ndlock]n → [ndlock single]n – an object single is created in an arbitrary mem- brane containing an object dlock; the object single is used to ensure that only rule of type a), d), g) is applied at a given moment;
single → [δ] – an object single is consumed; the last two rules assure that at most one object single is in the membrane system at any moment.
Whenever we get the membrane structure
dlock [nin m[in m]in m[tout n[out n]out n]t]n[m]m
after applying in a maximally parallel manner the rules defined above, we could obtain either the configuration dlock [m[n]n[t]t]m or dlock [t]t[m[n]n]m. The order in which the non-star objects (cap n) are consumed in the translated membrane should be the same as the order in which the capabilities are consumed in the translated ambient. However in the example above this order cannot be established; the non- star objects can be consumed by two rules applied in parallel. Related to this remark, we have the following priorities:
b), e), h) > c), f), i), j) > a), d), g), k) > n) > l), m)
According to these priorities, the membrane structure
dlock [nin m[in m]in m[tout n[out n]out n]t]n[m]m
evolves to the configuration dlock [m[n]n[t]t]m whenever the first object consumed is in m. The applied rules are:
r1 : dlock [n]n → dlock [ndlock]n – a copy of the object dlock is created inside the membrane n, which does not contain a dlock object;
r2 : dlock [m]m → dlock [mdlock]m – a copy of the object dlock is created inside the membrane m, which does not contain a dlock object;
r3 : dlock [t]t → dlock [tdlock]t – a copy of the object dlock is created inside the membrane t, which does not contain a dlock object;

r4 : [ndlock]n → [ndlock single]n – an object single is created in the membrane n
which contains the object dlock;
r5 : [nin m dlock single]n[m]m → [nin∗m in∗m dlock]n[m]m – membrane n can enter in membrane m under the control of the objects in m, dlock and single, and so the objects in m and single are consumed and other two objects (in∗m and in∗m ) are created in order to control the process: in∗m dissolves the corresponding membrane labelled in m, and in∗m allows membrane n to enter in membrane m (if n is an elementary one);
r6 : in∗m[in m]in m → [in mδ]in m – in the presence of an object in∗m, the mem- brane labelled in m is dissolved; the object in∗m signals the fact that the object in m has been consumed;
r7 : [nin∗m [t]t]n → [nin∗m [tin∗m out∗n in∗n]t]n – in the presence of star objects in membrane n (which is not an elementary one), all the star objects from this membrane are copied in the nested membrane, and another two objects out∗n, in∗n are created and sent in the nested membrane; these objects allow the nested membrane t to be extracted and then reintroduced in n; after n enters m with the help of this objects, n restores the initial nested structure;
r8 : [tin∗m out∗n in∗n [out n]out n]t → [tin∗m out∗n in∗n [out nin∗m out∗n in∗n
in∗t out∗t]out n]t – in the presence of star objects in membrane t (which is not elementary), all the star objects from this membrane are copied in the nested mem- brane, and another two objects out∗t, in∗t are created and sent in the nested one, allowing the nested membrane out n to be extracted and then reintroduced in t;
r9 : [t[out nout∗t]out n]t → [t]t[out n]out n – the membrane out n, being elementary and containing the object out∗t, is extracted from the membrane t;
r10 : [n[out nout∗n]out n]n → [n]n[out n]out n – the membrane out n, being elemen- tary and containing the object out∗n, is extracted from membrane n;
r11 : [n[tout∗n]t]n → [n]n[t]t – the membrane t, being elementary and containing the object out∗n, is extracted from the membrane n;
r12 : [nin∗m]n[m]m → [m[n]n]m – the membrane n, being elementary and contain- ing the object in∗m, is introduced in the membrane m which does not contain any star objects;
r13 : [tin∗m]t[m]m → [m[t]t]m – the membrane t, being elementary and containing the object in∗m, is introduced in the membrane m which does not contain any star objects;
r14 : [out nin∗m]out n[m]m → [m[out n]out n]m – the membrane out n, being elemen- tary and containing the object in∗m, is introduced in the membrane m which does not contain any star objects;
r15 : [tin∗n]t[n]n → [n[t]t]n – the membrane t, being elementary and containing the object in∗n, is introduced in the membrane n which does not contain any star objects;
r16 : [out nin∗n]out n[n]n → [n[out n]out n]n – the membrane out n, being elementary and containing the object in∗n, is introduced in the membrane n which does not contain any star objects;
r17 : [out nin∗t]out n[t]t → [t[out n]out n]t – the membrane out n, being elementary

and containing the object in∗t, is introduced in the membrane t which does not contain any star objects;
r18 : [tdlock]t → [tdlock single]t – an object single is created in the membrane t
which contains the object dlock;
r19 : [n[tout n dlock single]t]n → [n[tout∗n out∗n dlock]t]n – membrane t can be extracted from membrane n under the control of an object out n; this object is consumed and other two objects (out∗n and out∗n) are created in order to control the remaining actions: out∗n dissolves the corresponding membrane labelled out n, and out∗n allows membrane t to be extracted from membrane n (if t is an elementary one);
r20 : out∗n[out n]out n → [out nδ]out n – in the presence of an object out∗n, the membrane labelled out n is dissolved; out∗n signals the fact that the object out n is consumed;
r21 : [n[tout∗n]t]n → [t]t[n]n – the membrane t, being elementary and containing an object out∗n, is extracted from the membrane n.
As a final step, all the possible rules of type l) are applied in order to eliminate all the internal dlock objects. The rules are applied in the order we have presented them, with the additional remark that the rules of the tuples (r1, r2), (r10, r11), (r12, r13, r14), (r15, r16) can be applied in any order. The computation stops when all the star objects from the membranes are consumed, and after introducing all the objects dlock by applying rules of the form k), none of the rules of the form a), d) or g) can be applied.
It is worth to note that the membrane structure
dlock [nin m[in m]in m[tout n[out n]out n]t]n[m]m
evolves to the configuration dlock [t]t[m[n]n]m whenever the first step consumes
out n.
We denote by A, B,... the mobile ambients, and by M,N ... the P systems. We
denote by M →r N the fact that by applying a developmental rule r toa membrane
system M we get a new membrane system N . Considering a membrane system M
r1	ri
and the rules r ,... ,r such that M	...	N , we say that such a computation
1	i	→	→
is successful if N does not contain any star objects and contains only one object
dlock.
We denote with 0 the object associated with the ambient 0; 0 represents an object which does not appear in any reaction. To simplify the membrane systems, we use the following abbreviation: [n0]n = [n]n.
Definition 4.1 The set M of membrane configurations M is defined by
M ::= 0 | O1, O2 | M1, M2 | O, M | [nM ]n | (νn)M
where by O we denote a finite multiset of objects.
The restriction operator (νn)M creates a fresh membrane around the configu- ration M . As in [3], the restriction operator can float outward to extend the scope of the membrane, and can float inward to restrict the scope of the membrane. The restriction construction is transparent with respect to reduction; this is expressed

by the following rule: if M →r
N then (νn)M →r
(νn)N .

We can write O1, O2 or O, M omitting the surrounding membrane because all this structures are at least inside the skin membrane.
Definition 4.2 The structural congruence ≡mem over M is the smallest congruence relation satisfying
M, 0 ≡mem M ,	M, N ≡mem N, M	M, (N, M ') ≡mem (M, N ),M '
(νm)M ≡mem (νn)M {n/m} and (νn)(N, M ) ≡mem M, (νn)N where n is not a membrane in M ;
if n /= m, then (νn)[mM ]m ≡mem [m(νn)M ]m; (νn)0 ≡mem 0, (νn)(νm)M ≡mem (νm)(νn)M .
We deal with multisets of objects, and multisets of sibling membranes. For example, we have [n]n[m]m ≡mem [m]m[n]n, in m[n]n ≡mem [n]nin m and in∗n out∗m ≡mem out∗m in∗n. The structural congruence has the following properties:
M ≡mem M ,	M ≡mem N implies N ≡mem M , M ≡mem N and N ≡mem M ' implies M ≡mem M ', M ≡mem N implies M, M ' ≡mem N, M ',
M ≡mem N implies M ',M ≡mem M ',N , M ≡mem N implies M ' [M ] ≡mem M ' [N ].
The operational semantics of P systems is defined in terms of a relation →r by the following rules:

(Res)
M →r
(νn)M →r
M '	;	(Comp)
(νn)M '
M →r M, N →r
M '	;
M ',N 

M →r	M '
M ≡mem M ', M ' →r  N ', N ' ≡mem N

(Amb)


[nM ]n →r	[nM ']n
; (Struc)
M →r	N	.

Definition 4.3 We define a translation function T : A → M,
T (A)= dlock T1(A) where: 80	if A = 0
cap n[cap nT1(A1)]cap n  if A = cap n.A1
T1(A)=  [nT1(A1)]n	if A = n[A1]
(νn)T1(A1)	if A = (νn)A1
:T1(A1) | T1(A2)	if A = A1 | A2
Proposition 4.4 If A and B are two mobile ambients and M is a membrane system
such that A ⇒a B and M = T (A), then there exists a chain of transitions M →r
1
... ri N such that r ,... ,r are developmental rules, and N = T (B).
→	1	i
Proof. (Sketch) Since A ⇒amb B, then one of the requirements In, Out or Open is fulfilled for subambients A' and B' which are included in A and B, respectively. We consider the case when A' = n[in m] | m[] and B' = m[n[ ]]. Then accord- ing to the definition of the translation, M contains the submembrane structure [nin m[in m]in m]n[m]m, which after applying a number of rules of the form k) we obtain the following structure [ndlock in m[in m]in m]n[mdlock]m. Using the rules
r1 : [ndlock]n → [ndlock single]n
r2 : [nin m dlock single]n[m]m → [nin∗m in∗m dlock]n[m]m

r3 : in∗m[in m]in m → [in mδ]in m
r4 : [nin∗m]n[m]m → [m[n]n]m,
and some rules of the form l) there exists the following sequence of transitions

k) ∗	'	r1
r2	r3
l)
r4	'	∗	'	'

M —→
M1 —→ M1 —→ M2 —→ M3
—→ M3 —→
N , where M1, M1, M2, M2

and M3 are intermediate membrane configurations, and the membrane structure N
contains the submembrane structure [m[n]n]m. Once the objects dlock and single are created near the object in m, these transitions are the only deterministic steps which can be performed. We can notice that [m[n]n]m = T1(B'). Hence, according to the definition of translation function T and transition relation →r , we reach the conclusion that the membrane structure M admits the required sequence of tran- sitions leading to the membrane structure N which does not contain star objects, and N = T (B).
The case of a nested ambient where A' = n[in m t[ ]] | m[] and B' = m[n[t[ ]]] has already been presented. The other cases (when A' and B' satisfy the requirements Out, or Open) can be treated analogously.	 
Proposition 4.5 Let M and N be two membrane systems with no star objects and only one dlock object, and a mobile ambient A such that M = T (A). If there is a
r1	ri
sequence of transitions M → ...	N, then there exists a mobile ambient B such
that N = T (B). If only one non-star object is consumed, then we have A ⇒amb B.
Proof. (Sketch) We proceed by structural induction. Since M does not contain any star object, the first rule which consumes a translated capability has one of the following forms:
[nin m dlock single]n[m]m → [nin∗m in∗m dlock]n[m]m, [m[nout m dlock single]n]m → [m[nout∗m out∗m dlock]n]m, [m]mopen m dlock single → [mδ]mopen∗m dlock.
We present only the first case, the others being treated similarly. If we consider that the first rule is applicable in M , then M contains the membrane structure [nin m[in m]in m]n[m]m. According to the definition of T , M can be written as M1,M ' or M1[M '], where M ' = [nin m[in m]in m]n[m]m. We study only the first case, the other one being treated similarly. If A is a mobile ambient encoded by M , then according to the definition of T it contains two subambients A' = n[in m] | m[] and A1 such that A = A1 | A', M ' = T1(A'), and M1 = T1(A1). The application of the rule [nin m dlock single]n[m]m → [nin∗m in∗m dlock]n[m]m to the membrane system M changes only the membrane system M '. In M ' we have two new objects, in∗m and in∗m, which signal that membrane n can enter into the membrane m. These objects are used by some other rules, and control the moving of membrane n into the membrane m. After the application of these rules, M ' is evolving to N ' = [m[n]n]m. The induction hypothesis expresses that N ' encodes an ambient B'. After obtaining N ', N has the structure N = M1,N ' and it encodes the mobile ambient B = A1 | B'. The transition from M ' to N ' represents also the transition from M to N .
It should be notice that by consuming the capability in m we have A' ⇒amb B'.

So the transition from M to N with the consumption of only one non-star object is simulated by the transition of A to B.	 

Remark 4.6 If M r1 ... ri
N , and both M and N do not contain star objects and

contain only one dlock object, then the number of steps between mobile ambients A and B is the number of non-star objects consumed during the computation in the membrane evolution. The order in which the rules are applied in ambients is the order in which the non-star objects are consumed in the P systems M and N .
If we have two membrane systems M and N with no star objects and only an ob- ject dlock, we say that M ⇒mem N if there is a sequence of rules r1,... , ri such that
M →r1 ... ri N , where only one rule consumes only one non-star object. Consider-
ing together the previous two propositions, we have an operational correspondence result.
Theorem 4.7 (operational correspondence)
If A ⇒amb B, then T (A) ⇒mem T (B).
If T (A) ⇒mem M, then exists B such that A ⇒amb B and M = T (B).

Conclusion
In this paper we translate the mobile ambients into P systems, giving also an opera- tional correspondence between these two formalisms. The translation of the mobile ambients into P systems can be presented as a relationship between ⇒amb and
⇒mem. An example of using the translation is given in [1] by considering the cab protocol in ambient calculus presented in [6].
Previous attempts to relate one formalism to another had been published before in [9] and [2]. In [9] the authors show a simple way of encoding a P system into a mobile ambient having the same structure. In order to do this, the authors introduced a new primitive in the ambient calculus (namely the prioritized choice operator), importing an idea from P systems. The authors also provides ideas how other features from P systems can be simulated in mobile ambients:
P systems with cell division can be easily simulated by creating new ambients having the same name,
P systems where both the objects and the membranes have no names but they are provided with electrical charge can be modelled by an ambient for which all the subambients are named either pos or neg, depending on the electrical charge.
In [2] the authors discuss about a relationship between the mobile ambients and P systems. They model the Ethernet network technology by using P systems, starting from the idea that ambient calculus are used for describing the mobile computation over the World Wide Web. The authors do not actually translate the mobile ambients into P systems. However they identify some problems which appear during such a translation:
the difficulty of expressing mobility of the ambients in P systems because there

is no explicit mobility of membranes in P systems; therefore mobility must be expressed in some indirect way: destroy the membrane, representing a moving ambient with its content at its initial location, and then create a new membrane with the same content at the destination location;
the difficulty of having the right order of execution for primitive operations and capabilities of the ambient calculus.
In order to express the mobility of membranes, we introduce in P systems new developmental rules inspired by biology (endocytosis, exocytosis). Similar rules are presented in brane calculi.

References
B. Aman, G. Ciobanu. On the Relationship Between P Systems and Mobile Ambients FML-06-02 Technical Report, ISSN 1842 - 1490. http://iit.iit.tuiasi.ro/TR/ , 2006.
E. Boian, V. Rogozhin. Simulation of Mobile Ambients by P Systems. Proc WMC 2003, Lecture Notes in Computer Science vol.2933, Springer, 304-319, 2004.
L. Cardelli, A. Gordon. Mobile Ambients, Proc. Foundations of Software Science and Computation Structures, Lecture Notes in Computer Science vol.1378, Springer, 140-155, 1998.
G. Ciobanu. Distributed Algorithms over Communicating Membrane Systems. Biosystems vol.70, Elsevier, 123-133, 2003.
G. Ciobanu, V.A. Zakharov Encoding Mobile Ambients into the π-calculus. Proc. Perspectives of System Informatics, Lecture Notes in Computer Science, Springer, 2006.
D. Hirschkoff, D. Teller, P. Zimmer. Using Ambients to Control Resources Proc. CONCUR’02, Lecture Notes in Computer Science vol.2421, Springer, 288-303, 2002.
S.N. Krishna. On the Efficiency of a Variant of P Systems with Mobile Membranes Cellular Computing; complexity aspects, ESF PESC Exploratory Workshop, Fenix Editora, Sevilla, 237-246, 2005.
Gh. P˘aun. Membrane Computing. An Introduction. Springer, 2002.
I. Petre, L. Petre. Mobile Ambients and P Systems, TUCS Technical Report 293, 2001.
