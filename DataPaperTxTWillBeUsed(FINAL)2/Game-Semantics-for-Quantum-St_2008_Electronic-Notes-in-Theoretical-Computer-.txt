

Electronic Notes in Theoretical Computer Science 218 (2008) 153–170
www.elsevier.com/locate/entcs
Game Semantics for Quantum Stores
Yannick Delbecquea,1 ,2	Prakash Panagadena,3
a School of Computer Science McGill University Montreal, Canada

Abstract
This paper presents a game semantics for a simply-typed λ-calculus equipped with quantum stores. The quantum stores are equipped with quantum operations as commands which give the language enough expressiveness to encode any quantum circuits. The language uses a notion of extended variable, similar to that seen in functional languages with pattern matching, but adapted to the needs of dealing with tensor products. These tensored variables are used to refer to quantum stores and to keep track of the size of the states which they contain. The game semantics is constructed from classical game semantics using intervention operators to encode the effects of the commands. A soundess result for the semantics is given.
Keywords: Game semantics, quantum programing languages, quantum games.


Introduction
An important problem in the development of higher-order quantum programming languages is to find an appropriate structure to define a denotational semantics. For example, there was no denotational semantics given in the first presentations of the quantum λ-calculus developed by Selinger and Valiron [15,13]. They proposed in [14] a denotational semantics for the linear part of the quantum λ-calculus; their interpretation is in the category CPM of completely positive maps on finite dimen- sional Hilbert spaces. Working with this restricted language allows them to avoid the problem of finding a structure which can model the possible interactions between the quantum data and the classical data in higher order quantum programming lan- guages. To address this problem, there are many structures to choose from. One can consider for example the biproduct completion of CPM [12,14] or the concept of classical objects [2]. These two examples share a common approach: classical data is encoded using properties of the Hilbert space structure used to describe quantum

1 This research was supported by a grant from NSERC (Canada)
2 Email: yannick@delbecque.org
3 Email: prakash@cs.mcgill.ca

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.010

data. In this paper we use a different strategy: quantum data is represented by the classical interactions used to manipulate quantum states and extract information from them with measurements. More precisely, a quantum state is represented as a strategy which makes someone chose the actions according to the laws of quantum mechanics. Our proposed model is built with ideas from game semantics augmented with a new game in which plays describe the behavior of quantum stores.
There are important differences between the quantum λ-calculus of Valiron and Selinger and the language presented in this paper. First, the former language does not allow quantum states to be introduced directly: they can only be referred to using variables of type qbit. Thus, in the type system quantum states are considered as data of type qbit which cannot be duplicated. The quantum store language introduced below is based upon the idea that there should be no harm in duplicating a reference to a qbit, as long as it is not possible to duplicate the qbit itself. With this approach, it is not necessary to assume that variables are used only linearly: each use updates the stored value.
A second difference between the quantum λ-calculus and the quantum store language is the way tensor products of quantum states are dealt with. There is a tensor type-constructor in the quantum λ-calculus which is complemented with a bang operation and typing rules inspired from linear logic. The idea is that the distinction between classical types and quantum types can be reduced to duplica- bility since quantum data is not duplicable while classical data is. When combined with abstraction, a tensor type constructor allows one to take a program of type qbit ⊗ qbit  qbit ⊗ qbit to a program of type qbit  (qbit  qbit ⊗ qbit). This may seem problematic, since intuitively this takes a function with two input qbits, which may be in some entangled state, to a program with should be equivalent but using only separated qbits. This is avoided in the quantum store language since there is no tensor type construction. Instead, the quantum stores are equipped with a preparation operation which allows one to add qbits to the current state as necessary. To keep track of the size of the currently held state, we introduce tensor of variables to refer to the quantum stores.

Quantum mechanics and quantum interventions
A quantum system A is represented as a finite-dimensional Hilbert space HA. A quantum state is represented as a Hermitian positive operator ρ on HA of unit trace. These operators are called density matrices. The set of density matrices on HA is denoted D(HA). The set of positive operators of trace less than one is denoted SD(HA); we call such operators subdensity matrices.
An important postulate of quantum mechanics is that the states of a composite quantum system AB are described by the density matrices on the tensor product HA ⊗ HB. The evolution of a state over time is described by unitary operation on the Hilbert space: a state ρ is sent to U(ρ)= UρU †. The final ingredient of basic quantum mechanics is the concept of quantum measurement by which one extracts classical information about a state by interacting with it. The measurement gives

some information m and alters the measured state. This is usually described using projections: a projective measurement is a family of projection operators {P }
indexed by the measurement results such that Σ Pm = 1 and Pm1 Pm2 = 0 if
m1 /= m2. If a state ρ is measured, we get the result m with probability pm =
tr P  ρP †  and the process leaves the system in state P  ρP † /p  . We will denote
the projection operator on the canonical basis vector |k⟩ by [k]. To simplify the notation, an operation of the form IA ⊗ M ⊗ IC on HA ⊗ HB ⊗ HC, where M is a linear operator on HB, is denoted by MB.
Peres introduced a general description of quantum measurements called inter- vention operators [10]. The measurement process is conceived of as a unitary in- teraction of a measurement apparatus with the quantum system to be measured, followed by a projective measurement on the combined system. Mathematically, Peres proved that this process is some described by what are commonly called su- peroperators. A superoperator is a completely positive trace non-increasing map E : SD (HA) → SD (HB). Superoperators are composed as usual, but we use a convenient convention: if the domain of E does not match the codomain of F we put EF = 0. This convention is consistent with the quantum mechanical inter- pretation of superoperators: an impossible operation is assigned probability zero. A quantum intervention on a Hilbert space HA is a collection of superoperators E = {Em : SD(HA) → SD(HBm )} indexed by measurement results m, such that we have m tr (Em(ρ)) = 1 for any state ρ. If the system is initially in state ρ, per- forming the quantum intervention yields result m with probability pm = tr (Em(ρ)) and leaves the system in state Em(ρ)/pm. Note that the space HBm may depend on the measurement outcome.
Simply typed λ-calculus with quantum stores
We now introduce a λ-calculus with quantum stores language (QSL) The syntax of QSL is built upon a simply typed λ-calculus with pairing, conditionals and se- quential composition. Quantum operations are added using quantum stores which have a syntax analogous to classical stores. In a classical higher-order programming language with stores, like idealised ALGOL [11], stores are references to values. They are used through various operations like dereferencing and assignment. The quantum stores we use below are defined according to the following parallel between classical and quantum references:
Classical stores	Quantum stores
Dereferencing	Measurement
Assignment		Preparation Command with side effects	Unitary transformation
In this picture, the quantum counterpart of dereferencing, which classically returns the value stored, is quantum measurement. The counterpart of assignment is state preparation. Note that, while classically it is possible to assign a value to a store multiple times, this is not the case with quantum stores, as a quantum state cannot be destroyed. Instead, preparation expands a given state with a new known quan-

tum state. Classical stores can be equipped with commands with side effects, for example, an integer incrementation command. Unitary operations on the store are the quantum counterpart of classical update operations.
Syntax
We need to introduce a new syntactic device to accommodate quantum stores. When multiple quantum stores are combined, they can be measured by using a projective measurement on the whole space. Because of this, we must be able to refer to the combined store as a whole, while keeping the possibility to refer to a part of the system. To this end, we introduce tensor of variables in the syntax. An extended variable is an expression of the form x1 ⊗ ··· ⊗ xn, where the xi are variables such that xi /= xj if i /= j. Two extended variables x1 ⊗ ··· ⊗ xn and y1 ⊗ ··· ⊗ ym are disjoint if xi /= yj for all i, j. Two such extended variables can be joined to form a new extended variable x1 ⊗··· ⊗ xn ⊗ y1 ⊗··· ⊗ ym. Note that when we use x1 ⊗ ··· ⊗ xn to refer to an arbitrary extended variable, the case n =1 is also possible. We use the notation x1 ⊗···⊗xn ± y1 ⊗···⊗ym when each of the variables x1,... , xn occurs in y1 ⊗ ··· ⊗ yn and the order of the occurrences is the same in both extended variables. We say in this case that x1 ⊗ ··· ⊗ xn is a subvariable of y1 ⊗ ··· ⊗ ym. To simplify the notation, we use x instead of x1 ⊗ ··· ⊗ xn, leaving the number n implicit.
The terms of QSL are defined by
M, N, P ::= x | ∗ | 0 | 1 | skip | λx. M | MN |
if M then N else P | ⟨M, N ⟩| fst M | snd M | M ; N |
meas x | new x in M | UM | prep y with x in M
where x and y can be any extended variables and U can be any multiple-qbits unitary transformation. All the classical operations used are standard operations: ⟨M, N ⟩ is pairing, fst and snd are the two associated projection operations, M ; N is sequential composition, and skip is the operation doing nothing. The quantum part of the language consists of operations to manipulate quantum stores: measurement, qbit creation, unitary modification and preparation of extra qbits. The measurement operation meas x measures the qbit x in the quantum register in the canonical basis and returns a boolean value corresponding to the measurement result. For the preparation operation, prep y with x in M means that a given quantum store x is extended to a larger store by adding extra qbits prepared in the |0⟩ state. In M , the whole extended store is referred to as x ⊗ y.
As in any λ-calculus, the λ operation is a binder. Observe that it can be used on extended variables, i.e. terms like λx ⊗ y. meas x are allowed. The preparation operation is also a binder: x is not free in the term prep y with x in M . The set of free extended variables of M is denoted by FV(M ). A term M is closed if it has no free extended variables. We use the notation M [N/x] to denote the capture-free substitution (no occurrence of a free variable in N is bound in M ) of the term N for every occurrence of x. For clarity, we use the alternative notation let x = N in M



Table 1 QSL typing rules

Γ, x : A ▶ x : A	Γ ▶ 0: bool	Γ ▶ 1: bool	Γ ▶ ∗: T	Γ ▶ skip : com

 Γ ▶ M : A ⇒ B	Γ ▶ N : A 
Γ ▶ MN : B
Γ, x : A ▶ M : B
Γ ▶ λx. M : A ⇒ B
Γ ▶ M1 : A1	Γ ▶ M2 : A2

Γ ▶ ⟨M1, M2⟩: A1 × A2

Γ ▶ M : A × B
Γ ▶ fst M : A
Γ ▶ M : A × B
Γ ▶ snd M : B
Γ ▶ P : bool	Γ ▶ M : A	Γ ▶ N : A

Γ ▶ if P then M else N : A

 Γ ▶ M : com	Γ ▶ N : A 
Γ ▶ M ; N : A
A = com or bool	Γ, x : qstore ▶ meas xi : bool xi ± x

	 y ± x

Γ, x : qstore ▶ U y1 ⊗· · · ⊗ ym : com
U : unitary, rank(U )= m

Γ, x : qstore ▶ M : A
Γ ▶ new x in M : A
Γ, x ⊗ y : qstore ▶ M : A
Γ, x : qstore ▶ prep y with x in M : A



for (λx. M )N . When multiple variables are bound in this manner successively, we use the notation let x1 = N1,... , xn = Nn in M for (λxn. ... (λx1.M ) N1 ... ) Nn.
The types of the λ-calculus with quantum stores are the following:
A, B ::= bool | com |T| A × B | A ⇒ B | qstore.

The type bool is the type of boolean constants, A × B and A ⇒ B are respectively the types of pairs and functions. The type com is the type of commands which can be composed using sequential composition. The type qstore is the type of a quantum store. A quantum store does not have a fixed dimension, as the number of qbits it hold can vary in the course of a computation if preparation operations are used.
The typing rules rules for the classical part are given in table 1. The rules for the classical part of the language are the standard rules of a simply typed λ- calculus where extended variables can be used. The rules for involving quantum operations encode the idea that the content of quantum stores can be measured, modified using unitary transformations and that quantum stores can be prepared or extended with an ancilla state. Note that the unitary operation rule allows unitary operations to be applied only to part of a quantum register. An important feature of QSL is that the typing rules do not forbid having multiple references to a quantum store. For example, the typing judgement x : qstore ▶ ⟨meas x, meas x⟩: bool × bool is valid. Copying a reference to a qbit is not the same thing as duplicating the qbit. Yet the language does not allow unknown qbit duplication: to duplicate the content of a quantum store x, one would need to prepare a new qbit y and apply an appropriate unitary transformation to the quantum store x ⊗ y. There is no such unitary transformation.

Operational semantics
The operational semantics of the classical part of the quantum store language is standard. For the quantum part we use a quantum variant of stores. Note that

we expect that the reduction relation of this language depends on reduction order. There is nothing special in the quantum case in this regard. For example, assuming that x is a classical integer store holding the value 1, the term ⟨x := x + 1, x⟩ will reduce in a classical language to either ⟨2, 2⟩ or ⟨2, 1⟩ depending on which component is reduced first.
A quantum store Q is a function taking extended variables x1 ⊗ ··· ⊗ xn taken in a finite domain of extended variables |Q| to a state |x1 ... xn⟩Q ∈ C2 ⊗n. The domain |Q| is assumed to contain only disjoint extended variables. A quantum store holds the state of the quantum registers that are used in a quantum λ-calculus term. We drop the index Q when the context makes it clear to which quantum store a state belongs.
A quantum store Q can be modified in various ways. First, it can be extended by the addition of a new quantum register; since this is similar to the extension of a classical store we use the notation Q[|x1 ... xn⟩ '→ |ϕ⟩] to denote the extension of Q to a store with domain |Q|∪ {x1 ⊗ ··· ⊗ xn} and associating to the new extended variable the state |x1 ... xn⟩ = |ϕ⟩.
Another important operation is preparation of extra qbits appended to a cell of a given quantum store Q. If x1 ⊗ ··· ⊗ xn ∈ |Q|, then Q[|x1 ... xny1 ... ym⟩ '→
|x1 ... xn⟩|0 ... 0⟩] is the quantum store with x1 ⊗ ··· ⊗ xn removed from |Q| and
x1 ⊗ ··· ⊗ xn ⊗ y1 ⊗ ··· ⊗ ym added, and with associated state |x1 ... xny1 ... yn⟩ =
|x1 ... xn⟩|0 ... 0⟩.	Note that by definition of quantum store, {x1,... xn} and
{y1,... ym} are disjoint.
The final operation that we need is the modification of one register using a unitary operation or a projection. Given a quantum store Q and a linear map A over the Hilbert space associated to the extended variable x1 ⊗ ··· ⊗ xn ∈ |Q|, we denote by Q[|x1 ... xn⟩ '→ A|x1 ... xn⟩] the quantum store where |x1 ... xn⟩ is replaced by A|x1 ... xn⟩.
A QSL program is a pair Q, Γ ▶ M : A where Q is a quantum store, Γ ▶ M : A is a valid typing judgement such that all the qstore variables in Γ are in |Q|. We say that a program Q, M is closed if |Γ| ⊆ |Q|. To simplify the notation, we will often leave the types implicit and write Q, M instead of Q, Γ ▶ M : A.
A value for QSL is a term of the recursively defined form
V ::= x1 ⊗ ··· ⊗ xn | 0 | 1 |∗| skip | λy. M | ⟨M, N ⟩,
where x can be any extended variable and M is any term with y ∈ FV(M ).
We define the operational semantics of QSL as a big-step probabilistic reduction relation between programs. The notation Q, M ⇓p Q',V means that when M is run with a quantum store in state Q, it reduces with probability p to the value
V with the quantum store left in state Q'. When p = 1, we omit the probability argument and write simply Q, M ⇓ Q',V . This relation is defined inductively by the rules in table 2. Most of these reduction rules are the usual reduction rules for the simply typed λ-calculus, sequential composition, conditionals and pairing. The reduction rules for the classical part of the language do not affect the quantum stores. The rules involving measurements, preparations or unitary transformations



Table 2
Big-step reduction for the λ-calculus with quantum stores.



Q, V ⇓ Q, V
Q, M ⇓p Q', λx. M '	Q',M '[N/x] ⇓q Q'',V Q, MN ⇓pq Q'',V 

Q, M ⇓p Q',V 
Q, fst ⟨M, N ⟩ ⇓p Q',V 
Q, N ⇓p Q',V 
Q, snd ⟨M, N ⟩ ⇓p Q',V 
Q, M ⇓p Q', skip	Q',N ⇓q Q'',V Q, M ; N ⇓pq Q'',V 

Q, P ⇓p Q', 0	Q',N ⇓q Q'',V 
Q, if P then M else N ⇓pq Q'',V 
Q, P ⇓p Q', 1	Q',M ⇓q Q'',V 


Q, if P then M else N ⇓pq Q'',V 



Q, Uy1 ⊗ .. . ⊗ ym ⇓ Q[|x1 ... xn⟩ '→ U |x1 ... xn⟩], skip


Q[|x1 . .. xn⟩ '→ |0 .. . 0⟩],M ⇓p Q',V 

Q, new x1
⊗· · · ⊗ xn
in M ⇓ Q',V	x1 ⊗· · · ⊗ xn /∈ |Q|

Q[|x1 ... xny1 . .. ym⟩ '→ |ϕ⟩|0⟩],M ⇓p Q',V Q[|x1 .. . xn⟩ '→ |ϕ⟩], prep y with x in M ⇓p Q',V 

change the quantum stores according to quantum mechanics. For example, the rule for measurement says that if xi is measured with a quantum store in state Q, then the state |x1 ... xn⟩Q where x occurs is projected with the projection [0]xi or [1]xi , depending on the measurement result, and normalised. Note that this is the only place where there is a probabilistic branching in the reduction. For a unitary transformation operation U , the part of the quantum store Q affected by U is updated to U |x1 ... xn⟩ and the term reduces to the command skip.
Example 3.1 Consider the following two terms M1 and M2 defined respectively by
M1 : ∧Ux ⊗ y	M2 : if meas x then (U y) else skip
where ∧U denote the controlled version of a unitary operation U . This is defined by ∧U |b1⟩|b2⟩ = |b1⟩|b1 ⊕ b2⟩, where ⊕ is the exclusive-or operation. We have that x ⊗ y : qstore ▶ M1, M2 : com. In a quantum store state Q which assign |ϕ⟩ to x ⊗ y, M1 reduce to skip and the state Q is modified by the unitary operation:
Q, M1 ⇓ Q [|xy⟩ '→ ∧U |xy⟩] , skip.
The term M2 also reduce to skip but leaves the quantum store in a different state:
Q [|xy⟩ '→ |ϕ⟩] , M2 ⇓p Q [|xy⟩ '→ [0]x|xy⟩] , skip
Q [|xy⟩ '→ |ϕ⟩] , M2 ⇓1−p Q [|xy⟩ '→ Uy[1]x|xy⟩] , skip
where p = tr ([0]x|ϕ⟩⟨ϕ|).
Example 3.2 It is possible to program the quantum teleportation protocol [1] in the quantum store language. It is represented as a term teleportxz which transfers an unknown state from some quantum store x to another quantum store z:

prep y ⊗ z with x in H y; ∧Xy ⊗ z; H x; ∧Xx ⊗ y;
let bx = meas x, by = meas y in if bx then
if by then U11 z else U10 z
else
if by then U01 z else U00 z
where H is the Hadamard tranformation and U00 = I, U01 = X, U10 = Z and U11 = ZX are the four possible correction operations, one of which must be applied to z to change its state to that of the input quantum store x. If follows from the typing rules that
x : qstore ▶ teleportxz : com
The command teleportxz performs the teleportation protocol to transfer the state of the qbit register x to the qbit register z. This can be verified using the operational semantics rules: it is possible to derive that
Q, teleportxz ⇓ Q |xyz⟩ '→ Uz	[bx]x[by]ycnotxyHx|xyz⟩  , skip,

where we label each unitary transformation and projectors by the subspace associ- ated to the label variables.
Note that it is possible to represent any quantum circuit as a term of QSL. The input is fed to the circuit using a quantum store x. Some ancilla qbits can be added to the input state using a prep ... with ... in command. The unitary gates of the circuit are added as unitary commands which are composed using sequential composition. The resulting state can then be measured using meas commands.
Denotational semantics
Probabilistic game semantics
The game semantics presented in this paper is constructed using the definitions of probabilistic games semantics introduced by Danos and Harmer [3]. We give here an overview of the basic definitions and facts of probabilistic game semantics.
Definition 4.1 An arena A is a triple (MA, λA, ▶A) where MA is a set of moves, the function λA : MA → {O, P}×{Q, A}×{I, N} is a labeling which assigns moves to the two players Opponent and Player, and tells us which moves are Questions and which are Answers, and whether they are Initial or Noninitial moves, and finally
▶A⊆ MA × MA is a relation, called the enabling relation, such that
(A1) if a ▶A b, then λOP(a) /= λOP(b), λQA(a) /= λQA(b),
A	A	A	A
(A2) if λIN(a)= I, then λA(a) = OQI,
(A3) if a ▶ b and λQA(b)=A then λQA(a)= Q,
A	A

where the functions λOP, λQA and λin are λA composed with the projections on the
A	A	A
sets {O, P}, {Q, A} and {I, N}.
We use the convention that MX, where X is some list of superscripts taken from the set of move labels {O, P, Q, A, I, N} denote the set of moves labeled with these labels. Moves in an arena are thus of various types, and the constraints on the enabling relation ▶A limit the possible interactions in the arena by limiting which moves can be made at a certain point given the past interactions. The condition (A1) forces that only Player moves to enable Opponent moves and vice versa, (A2) asks for all initial moves to be questions by Opponent and finally (A3) says that answers can only be enabled by questions.
A play in A is a sequence of moves s ∈ M ∗ . This does not take into account the enabling relation; we define a justiﬁed play to be a play where each occurrence of a non-initial move b has a pointer to a previous occurrence of a move a with a ▶A b. We finally need to enforce alternation of the two players. A legal play is a justified play where Opponent and Player alternate; we denote the set of legal plays in A by LA. Note that because all initial moves are Opponent moves, Opponent is always making the first move. The sets of odd and even length legal plays are respectively
denoted by Lodd and Leven.
A	A
Example 4.2 The bool arena is defined with Mbool = {?, 0, 1} λbool(?) = (O, Q, I) and λbool(0) = λbool(1) = (P, A, N) and with the enabling relation
? ▶bool 0, 1.
Example 4.3 The empty arena I is the arena with no moves at all. The only legal play in I is the empty play ε.
Suppose sa ∈ LA. Starting from a and following the justification pointers will always lead to an occurrence of an initial move b, which we call the hereditary justiﬁer of a in sa. We can see that every legal play will be partitioned in subplays, each one consisting of all occurrences of moves hereditarily justified by a given initial move. These subplays are called threads. The current thread of a legal play sa ending with an opponent move, denoted by [sa|, is the thread of sa where a occurs. If sa ends with a Player move, the current thread is then defined by [s|a. We want the current thread to be a legal play, so it is necessary to impose an extra condition on legal plays: a legal play s is well-threaded if for every subplay ta ending with a Player move, the justifier of a is in [t|. In a well-threaded play, player always plays in the last thread where Opponent played.
Given arenas A, B, the product A ⊙ B and linear arrow A  B operations are defined respectively as follows:

MA⊙B = MA + MB (disjoint union)
MA  B = MA + MB
λA  B	=

OP	QA IN

λA⊙B = [λA, λB] (copairing)
m ▶A⊙B n iff m ▶A n or m ▶B
n.
⟨λA , λA  , λA ⟩, λB
m ▶A  B n iff m ▶A n or m ▶B
n or λIN(n)= λIN(m)= I.

B	A

OP	IN
where λA  inverts the roles of the two players and λA  makes all moves of A non-
initial. The product arena A ⊙ B is intuitively understood as the arena where at each of Opponent’s turn she can choose to play a move in either A or B, and where Player must answer in the last component where Opponent played. In the arena A  B, after Opponent makes an initial move in B, at each of his turns Player can choose to play either one of his moves in B or an Opponent move in A.
Given a legal play s in an arena A, let nextA(s)= {a ∈ MA|sa ∈ LA} be the set of all moves that can be legally made after the play s.

Definition 4.4 A probabilistic strategy for Player is a function σ : Leven
→ [0, 1]

such that
σ(ϵ)=1	and	σ(s) ≥	Σ
b∈next(sa)
σ(sab)

The set of traces of a strategy σ in A is the set of even length legal plays which are assigned a non-zero probability by σ: it is denoted Tσ. A strategy σ is deterministic if σ(s) = 1 for all s ∈ Tσ.
It is possible to describe a probabilistic strategy σ in conditional form. The

probability σ(b | sa) = σ(sab)
is the probability of Player choosing to play b after

the play sa.
Composition of strategies is the way interactions between parts of a program are encoded in game semantics. Given two strategies σ : A  B and τ : B  C, we define a new strategy σ; τ : A  C obtained by letting σ and τ “interact” on B. Before giving the definition of composition, it is necessary to formalise this notion of interaction. The set of interactions for A, B, C is
IA,B,C = {u ∈ (MA + MB + MC)∗ | u|AB ∈ LA  B, u|BC ∈ LB  C , u|AC ∈ LA  C}
where u|AB is the sub sequence of u obtained by deleting the moves of C, and similarly for u|BC . The case of u|AC is a bit different because deleting from u the moves of B and their associated pointers might leave the moves of A or C that are justified by B-moves without justifiers. In this case, we define the justifiers of u|AC to be as follows: a move a in C justified by a move b in B will be justified by the first move of either A or C we get to by following back the justification pointers from a in u. The set of witnesses wit(s) of s ∈ LA  C in an interaction IA,B,C is the set of interactions u ∈ IA,B,C such that u|AC = s. The composition of two strategies σ : A  B and τ : B  C can now be defined as follows:

[σ; τ ](s)=	Σ
u∈wit(s)
σ(u|AB)τ (u|BC ).

The identity strategy (or so-called “copycat strategy”) idA : A  A is neutral with respect to composition. It is defined as the strategy which makes Player copy Opponent moves between corresponding components. Formally, this is defined as the deterministic strategy with trace
T (1A(s)) = s ∈ LAl  Ar | ∀s' ±even s. s'|Ar = s'|Ar } .

Using all the structure defined so far it is possible to define a category of arenas and probabilistic strategies. Taking arenas as objects, a morphism A → B is a strategy in A  B. Composition of strategy is the needed composition, with the identity strategies as identity morphisms. It is associative, and it is shown in [3] that probabilistic strategies are closed under composition. This category is also symmetric monoidal. The operation ⊙ is a tensor product, which acts on

morphisms as follows. Given σ : A → C and τ : B → D and s ∈ Leven
'	' , we

(A⊙B)  (A ⊙B )
set [σ ⊙ τ ](s)= σ(s|A C )τ (s|C D). All coherence isomorphisms are easily defined using variants of the copycat strategy.
Threads have an important role in game semantics as a way to characterize the strategies that encodes programs with side-effects, like stores. This is achieved by forcing Player to use only the limited information available in the current thread instead of using all the information that can be extracted from the whole previous plays, including move made in other threads.
A strategy σ is well-threaded if Tσ consists only of well-threaded plays. Note that this condition forces Player to answer in the last thread where Opponent played.

Given two well-threaded plays sab ∈ Leven and ta ∈ Lodd
with [sa| = [ta|, we

A	A
define match(sab, ta) to be the unique legal play tab with b justified as in [sa|.
A well-threaded strategy σ is said to be thread independent if sab ∈ Tσ, t ∈ Tσ,
a ∈ next(t) and [sa| = [ta| implies that


σ(sab)
σ(s)
σ((match(sab, ta))
=	.
σ(t)

The meaning of this condition is that if Player plays according to σ, Player chooses his answers with probabilities that only depend on the current thread, i.e. σ(b | sa)= σ(b | ta).
The diagonal strategy ΔA : A → A ⊙ A is defined as the deterministic strat-
egy with trace set s ∈ Leven	| ∀s' ±even s.s'|A ∈ idA ∧s'|A  ∈ idA ,. This is
l	r	r
similar to the definition of the identity strategy: Δ instructs Player to use copy- ing strategies between A and its two copies Al and Ar. Possible conflicts in A are resolved by separating in different threads moves made according to the left or the right copy plays. There is also a unique strategy A  I, namely the trivial strategy with trace {ε}.
The pairing of two thread independent strategies σ : A   B and τ : A   C
is defined by ⟨σ, τ ⟩ = ΔA; σ ⊙ τ . Thus when Player plays using the pair strategy
⟨σ, τ ⟩, he plays using σ after an initial move in B, and using τ after an initial move in C.
For each arena A, (A, ΔA,  A) is a comonoid. It is shown in in [7] thata strategy σ : A  B is thread independent if and only if σ is a comonoid homomorphism. Using a known fact in category theory[8], this implies that the restriction of the category of arena and probabilistic strategies to thread independent strategies is a Cartesian closed category. Note that projection strategies like πA : B ⊗ A  A are defined as copying strategies which makes Player copies Opponent’s moves between the two A component arenas.

The quantum store arena
While all the classical operations of QSL have known game semantics interpreta- tions, we need new tools to be able to define the denotational semantics of the quantum store operations. The main idea used to describe a state ρ as a strategy is borrowed from the consistent histories approach to quantum mechanics [4,9,6]: sequences of measurement results are used to describe the evolution of quantum states.
Definition 4.5 The qstore arena is the arena with quantum interventions E? = E? as questions and natural numbers m as answers. The question E? enables its possible measurements results.
A play in this arena is a sequence of moves E?[1]m1 ··· E?[n]mn where the quantum interventions E?[k] may all be different. We need a strategy [ρ] in qstore which describes a quantum state ρ.
Definition 4.6 The probabilistic strategy [ρ] in qstore associated to a density
matrix ρ is defined by [ρ](ϵ)=1 and [ρ](E	m  ... E	m )= tr  E?[n] ... E?[1](ρ) .
Note that since we use the convention that impossible composition of super- operators yields the zero operator, the above definition assigns probability zero to plays which involve domain inconsistencies. For example, if Opponent asks another question E?[2] after receiving an answer to E?[1], all possible Player answers will have probability zero when the domain of E?[2] is different than SD(Hm1 ). When the domain and SD(Hm) match, the question E?[2] is answered using the normalised
state E?[1](ρ)/ tr E?[1](ρ) .
It is easy to verify this satisfies the definition of probabilistic strategies. Note that the strategy [ρ] is thread dependent: the first question is answered using the
probabilities given by pm1 = tr E	(ρ) , but a second question in a new thread
?[1]

will be answered with the probability distribution given by tr E?[2]E?[1](ρ) /p	,

i.e. using the updated state E?[1](ρ)/pm
. Thus in general the probability distribu-

tion used is different in different threads, and is updated according to the laws of quantum mechanics.
Example 4.7 We can define a strategy which describes a unitary operation. This is a strategy [U ] in the arena qstore → com. Suppose that the superoperator corresponding to U is U. A typical play using [U ] is “run {U0}? 0 done”. The {U0}? question in the qstore arena change the state used to answers future questions in the
arena. Notice that Player does not learn anything about the state in this interaction with Opponent because there is only one possible measurement result. The strategy [U ] really describe the effect of U since one can verify that [ρ]; [U ] = [U(ρ)]; skip using the definition of composition of strategies.
Example 4.8 We define a strategy which represents performing a projective mea-

surement of the state of a quantum store as follows:
qstore	meas	◦bool
?
{У0, У1}?
m
m
where Уm is the projection superoperator on the canonical basis state |m⟩. The measurement strategy makes Player answer the first question in the output Boolean component by asking about the result of a measurement in the computational basis of the input qbit and copying the answer m to the output component. In contrast to the case of unitary transformations, Player does learn some information about the input state in the part of the exchange happening in the qstore arena, and this information is used to provide an answer in the bool arena.
Deﬁnition of the denotational semantics
We now use quantum strategies to construct a denotational semantics for the quan- tum store language. For each type A, we want to define an arena [A]], and given a term Γ ▶ M : A, we want a strategy [M ]] : [Γ]] → [[A]].
For types, the definition is given by the following inductive construction :
[[bool]] = bool	[[com]] = com	[[T]] = T	[[qstore]] = qstore
[[A × B]] = [A]] ⊙ [[B]]	[A ⇒ B]] = [A]]  [[B]]

The arena T has one possible even-length play: ?∗, and there is thus only one possible strategy aside from the empty one. We denote this strategy ∗. The arena com is defined similarly, but with the moves “run” and “done” instead. Intuitively, in the com arena Opponent asks Player to run a command, and Player confirms when it is done. The quantum store type is interpreted using the arena qstore.
Given a context Γ = x1 : A1,... , xn : An, we set [[Γ ] to be [A1]] ⊙ ··· ⊙ [[An]]. The interpretation [Γ ▶ M : A ] is defined by induction on the derivation of Γ ▶ M : A in what follows.
We begin the definition of [Γ ▶ M : A ] with the base cases of variables and constant terms. The interpretation of Γ,x : A ▶ x : A using the projection strategy πA. The Boolean constants 0, 1 are interpreted as their corresponding deterministic strategies in bool. The denotation of ∗ is the unique non-trivial deterministic strategy ∗: [Γ ]  T. Similarly, the constant skip is interpreted as the unique non-trivial deterministic strategy skip in com.
The strategy [U y1 ⊗ ··· ⊗ ym ] corresponding to unitary transformation is de- fined as the strategy [U ]: qstore  com. In the case of measurements, [meas xi]] is interpreted as the meas strategy.
We now turn to the inductive cases. The definition of [M1; M2 ] follows the standard idea in game semantics: it is defined as the composition ⟨[[M1]] , [[M2]]⟩; seq,

where seq is the strategy com ⊙ com   com defined with the following typical play:
com	⊙	com	seqcom	◦com
run

run
done

run done



done

Using this scheme, the commands M1 and M2 are successively ran when seq is composed with ⟨[[M1]] , [[M2]]⟩. The other classical operations are also interpreted using the usual game semantics ideas. We refer the reader to [7] for a detailed account.
For quantum store creation using new, suppose that the denotation of Γ, x1 ⊗
··· ⊗ xn : qstore ▶ M : A is already defined. The term new x1 ⊗ ··· ⊗ xn in M is interpreted as the composition id ⊙ [|0⟩⟨0|]; [M ]]. The strategy [|0⟩⟨0|] is used to initiate the state of the new quantum store.
The last case is for the preparation typing rule. The strategy [prep y with x in M ]] is defined as the strategy prep ([[M ]]) : [[Γ]] ⊙ qstore  A defined with the following idea. Let F0 be the preparation superoperator taking ρ to ρ⊗|0 ... 0⟩⟨0 ... 0|. Player plays using prep ( [M ]) by making the moves prescribed by [M ] except that before playing his first move in the qstore arena, he must initiate an exchange in this arena which forces Opponent to add the |0 ··· 0⟩ state to the state ρ she uses to answer Player’s questions about the state of the quantum store. This is achieved by playing a {F0}? quantum intervention question in the qstore arena before any other move
is played there.
This completes the definition of the denotational semantics.
Soundness
To study the relation between the operational and denotational semantics, we need to take quantum stores into account. We use the standard approach used in game semantics of classical stores, described in the last chapter for the language MCdata: we define a strategy [Q, M ] for each pair Q, M . This strategy is defined as the com- position of [M ] with a strategy [Q ] representing the state of the quantum registers in Q. For each extended variable x1 ⊗ ··· ⊗ xn ∈ |Q|, the state |x1 ... xn⟩Q can be described as a strategy [|x1 ... xn⟩] in I qstore. The strategy [Q ] associated to the quantum store Q is defined as the ⊙-product of all the strategies [|x1 ... xn⟩], x1 ⊗ ··· ⊗ xn ∈ |Q|.
Lemma 5.1 (Substitution) For any QSL terms Γ,x : A ▶ M : B and Γ ▶ N : A
with x ∈ FV(M ), we have that Γ ▶ M [N/x]: B and [[M [N/x]]] = ⟨id[[Γ]], [[N ]]⟩; [[M ]].
Proof. A standard structural induction on the construction of M .	 
Proposition 5.2 (Consistency for QSL) Let M and V be two terms of ground type.

If Q, M ⇓p Q',V , then for all well-opened sab ∈T ([[Q',V ]]) we have that
[[Q, M ]] ( b | sa )= p [[Q, V ]] ( b | sa ).

Proof. The proof is a structural induction on the derivation of Q, M ⇓p Q',V .  We show how to deal with the most interesting cases.  In the case of a unitary transformation operation U , suppose that Q, U x1 ⊗ ··· ⊗ xn ⇓ Q [|x1 ... xn⟩ '→ U |x1 ... xn⟩] , skip holds. By definition of the denotational seman- tics, we have that [[Q, U x1 ⊗ ··· ⊗ xn ] is the composition
[[Q]]	[[x1⊗···⊗xn]]	[U ]
I	◦[[Γ ]	◦	◦
A run move in the final com arena is answered with the question {U0}? in the qstore arena and then copied by the projection strategy to the [Γ ] arena, where an interaction begins with [Q ] in which the unitary transformation move
{U0}? is made, affecting all subsequent interactions in the qstore component. The 0 answers that Opponent gives back to Player is copied back to the ini- tial qstore arena, and then a “done'' move is made in the com arena. In any further interaction with the quantum store strategy [Q ] Player will behave as if he is using the strategy [Q[|x1 ... xn⟩ '→ U |x1 ... xn⟩]]]. If Player uses the strat- egy [Q[|x1 ... xn⟩ '→ U |x1 ... xn⟩], skip ], then the behaviour is the same: the ini- tial “run” move is answered with “done” without interacting with the strategy Q |x' ... x' ' ⟩ '→ U |x' ... x' ' ⟩  .
The two rules for quantum measurement operations are dealt with similarly.
Suppose that
Q, meas xi ⇓tr([0]xi [x1...xn]) Q [|x1 ... xn⟩ '→ [0]xi |x1 ... xn⟩/  [0]xi |x1 ... xn⟩] , 0.
By definition we have that [Q, meas xi ] is the strategy [Q]]; [[xi]] ; meas in I [[Γ]] qstore  bool. Any interaction starting with the question ? in bool is answered by measuring in the canonical basis the qbit of the arena qstore. The answer to this is given according to [[Q ] and is 0 with probability [0]xi |x1 ... xn⟩. Any further inter- action with [Q ] will be made according to [Q[|x1 ... xn⟩ '→ [0]xi |x1 ... xn⟩]]], and the answer to the initial question in bool is 0. This amounts to saying that [Q, meas xi]] behaves like Q |x1 ... xn⟩ '→ [0]0|x1 ... xn⟩ , 0 with probability [0]xi |x1 ... xn⟩. The other measurement case is similar.
The most interesting induction case is the preparation case. Suppose that the proposition holds when Q [|x1 ... xn⟩|y1 ... ym⟩ '→ |ϕ⟩|0 ... 0⟩] ⇓p Q',V . As- sume that Q [|x1 ... xn⟩ '→ |ϕ⟩] , prep y with x in M ⇓p Q',V .  By definition of [[Γ, x : qstore ▶ prep y with x in M : A]], any play in [[Γ]] ⊙ qstore  [[A ] will be played with player using the strategy [M ], except that a preparation move is made in qstore. This preparation move is answered by Opponent using the [[Q [|x1 ... xn⟩ '→ |ϕ⟩]]] strategy, which make her pick her answers using the strategy [|ϕ⟩⟨ϕ|]. After the preparation move, Opponent will play as if she is using the strat- egy [|ϕ⟩⟨ϕ||0 ... 0⟩⟨0 ... 0|], which is [Q [|x1 ... xn⟩|y1 ... ym⟩ '→ |ϕ⟩|0 ... 0⟩]]].  The

overall play is thus just like what would happen if Player uses [M ] composed with this last strategy. We get the desired result because the induction hypothesis im- plies that composed strategy dictates the same moves to Players as the strategy [[Q',V ]].	 
A term Γ ▶ M : A is said to be semi-closed if FV(M ) contains only variables of type qstore.
Proposition 5.3 (Adequacy for QSL) Let M be a semi-closed term of ground type. If for all well opened sab ∈ T ([[Q',V ]]) we have that [[Q, M ]] (b | sa)= p [[Q, V ]] (b | sa), then we must also have that Q, M ⇓p Q',V .
We use the standard proof technique that uses a computability predicate. The usual definition of computability predicate is adapted to quantum stores as follows.

Definition 5.4 (Computability for QSL) Let Γ1, Γ2 ▶ M : A, with Γ1 containing only variable of type qstore. We say M is computable if
Γ1 ▶ M : A, A = bool, qstore, T or com and if for all sab ∈ T ([[Q',V ]]) we have that [Q, M ]] (b | sa)= p [[Q',V ]] (b | sa), then Q, M ⇓p Q',V ,
Γ1, x1 : A1,... , xn : An ▶ M : A is Γ1 ▶ M [N1/x1,... , Nn/xn]: A is computable for all computable semi-closed terms Γ1 ▶ N1 : A1, . .., Γ1 ▶ Nn : An,
Γ1 ▶ M : A  B, M semi-closed and for all semi-closed Γ1 ▶ N : A we have that Γ1 ▶ MN : B is computable,
M = x with Γ1 ▶ x : qstore and both Γ1 ▶ meas xi : bool and Γ1 ▶ Uy : com with y ± x are computable.
Proposition 5.3 is a direct consequence of the following lemma.
Lemma 5.5 All QSL terms are computable.
Proof. By induction on the construction of M . By the second and third clauses of the definition of computability, we can assume that M is constructed out of semi- closed terms. We explain the most interesting part of the proof, leaving out the cases which are standard classical cases.
For the base case, M must be a constant or a quantum store variable x. If M = x is a quantum store variable, we must apply the last clause of the definition of com- putability. We need to check that both Γ1 ▶ meas xi : bool and Γ1 ▶ U y : com, y ± x are computable. In the first case, suppose that [Q, meas xi ] makes Player behave as [Q',V ] for some boolean value V . This means that measuring the qbit i of the quantum store x with the quantum register in some state Q gives the boolean result V (without loss of generality, suppose that V = 0) with probability p and a quantum register left in state Q [|x1 ... xn⟩ '→ [0]xi |x1 ... xn⟩]. This implies that Q, meas xi ⇓p Q',V . A similar argument is used to show that Γ1 ▶ U y : com is computable.
For the induction step, we assume that M is constructed out of semi- closed computable terms.  In the case of local preparation, consider that M =

prep y with x in N is a semi-closed term. Assume that [Q, M ] makes Player be- have as if he was using the strategy [Q',V ]], with probability p. Since in the definition of [Q, M ] Player plays a preparation move before the first question about the state held by x ⊗ y in Q, the answer to this question is given using [[Q [|x1 ... xny1 ... ym⟩ '→ |x1 ... xn⟩|0 ... 0⟩]]]. Thus the strategy [Q',V ]] make player behave as [Q [|x1 ... xny1 ... ym⟩ '→ |x1 ... xn⟩|0 ... 0⟩] ,M ]. By induction hypothe- sis, this implies that Q [|x1 ... xny1 ... ym⟩ '→ |x1 ... xn⟩|0 ... 0⟩] ,M ⇓p Q',V . Using the operational semantics derivations rules, we get that Q, M ⇓p Q',V , which is the desired result.	 
To state the soundness result, we need a few extra definitions. A context with a hole of type B is a term C[−] with a special free variable “−” of type B, i.e. it is possible to derive that Γ, −: B ▶ C[−]: A. Capture-free substitution of a term Γ ▶ M : B in the context C[−] is denoted by C[M ]. Two semi-closed terms Γ ▶ M1 : A and Γ ▶ M2 : A are contextually equivalent if for all quantum stores Q, Q' and ground type context C[−] we have Q, C[M1] ⇓p Q',V if and only if Q, C[M2] ⇓p Q',V . This relation is denoted by M1 ∼ M2.
Proposition 5.6 Let M1 and M2 be two semi-closed terms. If [[M1]] = [M1]], then
M1 ∼ M2.
The proof is a standard argument using consistency and adequacy.
Conclusion and future work
Usually game semantics is used to get full-abstraction results by putting appropriate restrictions on the strategies. Here the main goal was instead to introduce a new kind of model for quantum programming languages. While the soundness result we obtained confirms the usefulness of using quantum games to model quantum types, it is a natural next step to seek a full-abstraction result for QSL. The main difficulty is that there is no known characterisation of the probabilistic strategies which can be defined as quantum strategies where the weight assigned to a play is given using the quantum intervention formalism. Gleason’s theorem [5] is one result in this spirit: it gives conditions which allow one to know when weights assigned to projection operators P can be described as those computed using a density matrix ρ with the formula tr(ρ). There is no similar result for quantum interventions. Thus, a full abstraction result here would be a major advance in understanding how to characterize quantum processes. In this case the obstacle has nothing to do with the usual subtleties associated with higher-type languages.
We did not explore fully the categorical properties of the quantum store are- nas. For example, one could consider the subcategory of the category of arenas and probabilistic strategies that consist of quantum store arenas and the quantum strategies between them. This category is very different from the other categories which were studied to understand quantum information flow since the qstore arena does not have a fixed dimension while the objects in these other categories are finite dimensional Hilbert space.

References
Bennett, C. H., G. Brassard, C. Cr´epeau, R. Jozsa, A. Peres and W. K. Wootters, Teleporting an unknown quantum state via dual classical and Einstein-Podolsky-Rosen channels, Physical Review Letters (1993), pp. 1895–1899.
Coecke, B. and D. Pavlovic, Quantum measurements without sums (2006).
Danos, V. and R. Harmer, Probabilistic game semantics, in: ACM Transactions On Computational Logic, Special Issue for LICS’00, Association For Computing Machinery (2002), pp. 359–382.
Gell-Mann, M. and J. Hartle, Classical equations for quantum systems, Physical Review D 47 (1993),
pp. 3345–3382.
Gleason, A. M., Measures on the closed subspaces of a hilbert space, Journal of Mathematics and Mechanics (1957), pp. 885–893.
Griffiths, R., Consistent histories and quantum reasoning, Physical Review A 54 (1996), pp. 2759–2774.
Harmer, R., “Games and Full Abstraction For Nondeterministic Languages,” Ph.D. thesis, Imperial College (1999).
Jacobs, B., Semantics of weakening and contraction, Annals of Pure and Applied Logic (1994), pp. 73– 106.
Omn`es, R., “The Interpretation of Quantum Mechanics,” Princeton Univ. Press, 1994.
Peres, A., Classical interventions in quantum systems. I. The measuring process, Physical Review A
61 (2000).
Reynolds, J. C., The essence of ALGOL, in: J. W. de Bakker and J. C. van Vliet, editors, Algorithmic Languages, Proceedings of the International Symposium on Algorithmic Languages (1981), pp. 345–372.
Selinger, P., Towards a quantum programming language, Mathematical Structures in Computer Science
14 (2004), pp. 527–586.
Selinger, P. and B. Valiron, A lambda calculus for quantum computation with classical control, Mathematical Structures in Computer Science 16 (2006), pp. 527–552.
Selinger, P. and B. Valiron, On a fully abstract model for a quantum linear functional language, in: Proceedings of the 4th International Workshop on Quantum i Programming Languages, Oxford, July 17-19, 2006.
Valiron, B., “A functional programming language for quantum computation with classical control,” Master’s thesis, Departement of Mathematics, University of Ottawa (2004).
