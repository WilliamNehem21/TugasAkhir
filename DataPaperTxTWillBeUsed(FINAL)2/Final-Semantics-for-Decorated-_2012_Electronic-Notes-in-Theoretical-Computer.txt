Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 286 (2012) 73–86
www.elsevier.com/locate/entcs

Final Semantics for Decorated Traces
Filippo Bonchia, Marcello Bonsangueb,c, Georgiana Caltaisd,c,
Jan Ruttene,c, Alexandra Silvae,c,f
a ENS Lyon, Universit´e de Lyon, LIP (UMR 5668 CNRS ENS Lyon UCBL INRIA)
b LIACS - Leiden University, The Netherlands
c Centrum voor Wiskunde en Informatica, The Netherlands
d School of Computer Science - Reykjavik University, Iceland
e Radboud University Nijmegen, The Netherlands
f HASLab / INESC TEC, Universidade do Minho, Braga, Portugal

Abstract
In concurrency theory, various semantic equivalences on labelled transition systems are based on traces enriched or decorated with some additional observations. They are generally referred to as decorated traces, and examples include ready, failure, trace and complete trace equivalence. Using the generalized powerset construction, recently introduced by a subset of the authors [13], we give a coalgebraic presentation of decorated trace semantics. This yields a uniform notion of canonical, minimal representatives for the various decorated trace equivalences, in terms of final Moore automata. As a consequence, proofs of decorated trace equivalence can be given by coinduction, using different types of (Moore-) bisimulation (up-to), which is helpful for automation.
Keywords: Labelled transition systems, decorated traces, coalgebras, final Moore automata


Introduction
The study of systems equivalence has been an interesting research topic for many years now. Several equivalences have been proposed throughout the years, each of which suitable for use in different contexts of application. Many of the equivalences that are important in the theory of concurrency were described in the well-known paper by van Glabbeek [14].

1 The work of Georgiana Caltais has been partially supported by a CWI Internship and by the project ‘Meta-theory of Algebraic Process Theories’ (nr. 100014021) of the Icelandic Research Fund. The work of Alexandra Silva is partially funded by the ERDF through the Programme COMPETE and by the Portuguese Government through FCT - Foundation for Science and Technology, project ref. PTDC/EIA-CCO/122240/2010 and SFRH/BPD/71956/2010. We thank Luca Aceto and Anna Ing´olfsd´ottir for comments and references to the literature.

1571-0661 © 2012 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2012.08.006

Proof methods for the different equivalences are an important part of this re- search enterprise. In this paper, we propose coinduction as a general proof method for what van Glabbeek calls decorated trace semantics, which includes (complete) trace, ready and failure semantics.
Coinduction is a general proof principle which has been uniformly defined in the theory of coalgebras for different types of state-based systems and infinite data types. Given a functor F : Set → Set, an F-coalgebra is a pair (X, f ) consisting of a set of states X and a function f : X → F(X) defining the dynamics of the system. The functor F determines the type of the transition system or data type under study. For a large class of functors F, there exists a final coalgebra into which every F-coalgebra is mapped by a unique homomorphism. Intuitively, one can see the final coalgebra as the universe of all behaviours of systems and the unique morphism as the map assigning to each system its behaviour. This provides a standard notion of equivalence called F-behavioural equivalence. Moreover, these canonical behaviours are minimal, by general coalgebraic considerations [10], in that no two different states are equivalent.
Labelled transition systems (LTS’s) can be modelled as coalgebras for the func- tor F(X) = (PωX)A and the canonical behavioural equivalence associated with F is precisely the finest equivalence of the spectrum in [14]. In the recent past, other equivalences of the spectrum have been also cast in the coalgebraic framework. No- tably, trace semantics was widely studied [5,13] and, more recently, decorated trace semantics was recovered via a coalgebraic generalization of the classical powerset construction [12].
To get some intuition on the type of distinctions the equivalences above en- compass, consider the following labelled transition systems over the alphabet A = {a, b, c}:


q
a	a
•	•	•

•
r

•	•	•	•

b
•	•	•	•
c	b	c

•	•	•
The traces of the states p, q, r and s are {a, ab, ac}, and therefore they are all trace equivalent. Complete trace semantics identifies states that have the same set of complete traces, that is, traces that lead to states where no further action are possible. Of the four states above, q and r and s are complete trace equivalent, but not p since it is the only state that has a as a complete trace. Failure semantics takes into account the set of actions that cannot be fired immediately after the execution of a certain trace. Only r and s are failure equivalent, since after a, state p might not be able to fire actions b and c, whereas p, r and s might not be able to fire only one of b or c and q never fails with those two actions. Ready semantics identifies states according to the set of actions they can trigger immediately after a certain trace has been executed. None of the states above are ready equivalent, since after a only p has the option of not executing any action, q and s can choose from b or c but r cannot and q always has two options b, c whereas s can end in a state where only b or c can be taken.

The contributions of the paper are three-fold. First, we prove that the coal- gebraic decorated trace semantics, which are mentioned without proof in [12] as examples, are equivalent to the corresponding set-theoretic notions from [14]. Sec- ond, we show how the coalgebraic semantic leads to canonical representatives for the various decorated trace equivalences. Third, we show how to prove decorated trace equivalence using coinduction, by constructing bisimulations (up-to congru- ence) that witness the desired equivalence. The latter is interesting also from the point of view of tool development: construction of bisimulations is known to be par- ticularly suitable for automation. Moreover, the up-to congruence technique also increases the efficiency of reasoning, as verifications are performed under certain closure properties, which means the bisimulations that are built are smaller (see Section 3, and Section 4 for an example). The techniques we use here for up-to reasoning are an extension of the recent work by the first author [2].
The paper is organized as follows. In Section 2, we provide the basic notions from coalgebra and recall the generalized powerset construction. In Section 3, we show how the powerset construction can be applied for determinizing LTS’s in terms of Moore automata (X, f : X → B × XA), in order to coalgebraically characterize decorated trace semantics. A detailed description of coalgebraic ready semantics is provided in Section 4. Here we also prove that the obtained coalgebraic model is equivalent to the original definition, and illustrate how one can reason about ready equivalence by constructing bisimulations up-to congruence. By following the ap- proach in Section 4, similar results can be easily shown for (complete) trace and failure semantics coalgebraically modelled as in [12]. Section 5 discusses that the canonical representatives of LTS’s we obtain coalgebraically coincide with the min- imal LTS’s one would obtain by identifying all states equivalent w.r.t. a particular decorated trace semantics. Section 6 contains concluding remarks and discusses future work.

Preliminaries
In this section, we briefly recall basic notions from coalgebra and the generalized powerset construction [5,13]. We first introduce some notation on sets.
We denote sets by capital letters X, Y, . . . and functions by lower case letters
f, g, . . .. The cartesian product of two sets X and Y is denoted by X × Y , and
has the projection maps X  π1 X × Y  π2  Y . The disjoint union of X and Y is

written X + Y and has the injection maps X −k→1
X + Y
→k−2
Y . By XY we represent

the family of functions f : Y → X, whereas the collection of finite subsets of X is denoted by PωX. For each of these operations defined on sets, there is an analogous one on functions (for details see for example [1]). This turns the operations above into (bi)functors, which we shall use throughout this paper.
For an alphabet A, we denote by A∗ the set of all words over A and by ε the
empty word. The concatenation of words w1, w2 ∈ A∗ is written w1w2.
Coalgebras: We consider coalgebras of functors F defined on Set – the category of sets and functions. An F-coalgebra (or coalgebra, when F is understood) is a

pair (X, c : X → FX), where X ∈ Set. We call X the state space, and we say that F together with c determine the dynamics, or the transition structure of the F-coalgebra.
An F-homomorphism between two F-coalgebras (X, f ) and (Y, g), is a function
h : X → Y preserving the transition structure, i.e., g ◦ h = F(h) ◦ f .
An F-coalgebra (Ω, ω) is final if for any F-coalgebra (X, f ) there exists a unique F-homomorphism J−)X : X → Ω. A final coalgebra represents the universe of all possible behaviours of F-coalgebras. The unique morphism J−)X : X → Ω maps each state in X to its behaviour. Using this mapping, behavioural equivalence can be defined as follows: for any two coalgebras (X, f ) and (Y, g), the states x ∈ X and y ∈ Y are behaviourally equivalent, written x ∼F y, if and only if they have the same behaviour, that is
x ∼F y iff Jx)X = Jy)Y .	(1)
We think of Jx)X as the canonical representative of the behaviour of x. Also it can be viewed as the minimization of (X, f ), since the final coalgebra contains no pairs of equivalent states.
For an example we consider deterministic automata (DA). A deterministic au- tomaton over the input alphabet A is a pair (X, ⟨o, t⟩), where X is a set of states and ⟨o, t⟩: X → 2 × XA is a function with two components: o, the output function, determines if a state x is final (o(x) = 1) or not (o(x) = 0); and t, the transition function, returns for each input letter a the next state. DA’s are coalgebras for the functor D(X) = 2 × XA. The final coalgebra of this functor is (2A∗ , ⟨ǫ, (−) ⟩) where 2A is the set of languages over A and ⟨ǫ, (−) ⟩, given a language L, determines whether or not the empty word is in the language (ǫ(L) = 1 or ǫ(L) = 0, resp.) and, for each input letter a, returns the derivative of L: La = {w ∈ A∗ | aw ∈ L}. From any DA, there is a unique map J−) into 2A which assigns to each state its behaviour (that is, the language that the state recognizes).


X	J−)X
⟨o,t⟩
2 × XA
id ×J−)A
2A∗
⟨ǫ,(−)a⟩
2 × (2A∗ )A
Jx)X(ε) = o(x)
Jx)X(aw) = Jt(x)(a))X(w)


Therefore, behavioural equivalence for the functor D coincides with the classical language equivalence of automata.
Another example (fundamental for the rest of the paper) is given by Moore automata. Moore automata with inputs in A and outputs in B are coalgebras for the functor M(X) = B ×XA, that is pairs (X, ⟨o, t⟩) where X is a set, t : X → XA is the transition function (like for DA) and o : X → B is the output function which maps every state in its output. Thus DA can be seen as a special case of Moore automata where B = 2. The final coalgebra for M is (BA∗ , ⟨ǫ, (−) ⟩) where BA∗ is the set of all
functions ϕ : A∗ → B, ǫ : BA∗ → B maps each ϕ into ϕ(ǫ) and (−) : BA∗ → (BA∗ )A

is defined for all ϕ ∈ BA∗ , a ∈ A and w ∈ A∗ as (ϕ) (w) = ϕ(aw).


X	J−)X
⟨o,t⟩
B × XA
id ×J−)A
BA∗
⟨ǫ,(−)a⟩
B × (BA∗ )A
Jx)X(ε) = o(x)
Jx)X(aw) = Jt(x)(a))X (w)

Coalgebras provide a useful technique for proving behavioural equivalence: bisimulation. Let (X, f ) and (Y, g) be two F-coalgebras. A relation R ⊆ X × Y is a bisimulation if there exists a function αR : R → FR such that π1 : R → X and π2 : R → Y are coalgebra homomorphisms. In [10], it is shown that under certain conditions on F (which are met by all the functors in this paper), bisimulations are a sound and complete proof technique for behavioural equivalence, namely,
x ∼F y iff there exists a bisimulation R such that xRy.	(2)
The generalized powerset construction: As shown above, every functor F induces both a notion of F-coalgebra and a notion of behavioural equivalence ∼F. Some- times, it is interesting to consider different equivalences than ∼F for reasoning about F-coalgebras. This is the case of labeled transition systems which are coalgebras for the functor L(X) = (PωX)A. The induced behavioural equivalence ∼L coin- cides with the standard notion of bisimilarity by Milner and Park [8,6]. However, in concurrency theory, many other equivalences have been studied, notably, decorated trace equivalences [14]. Another example is given by non-deterministic automata which are coalgebras for the functor N(X) = 2 × (PωX)A. The associated equiva- lence ∼N strictly implies language equivalence, which is often taken as an intended semantics.
For this reason, a subset of the authors has introduced in [12] the generalized powerset construction, for coalgebras f : X → FT (X) for a functor F and a monad T , with the proviso that that FT (X) is an algebra for the monad T . In [12], all the technical details are explored and many interesting instances of the construction are shown. In this paper, we will only be interested in the case where T = Pω and M(X) = B × XA, for B a semilattice, and we will therefore only explain the concrete picture for the functor and monad of interest. The fact that we take B to be a semilattice is enough to guarantee that MT (X) = B ×(PωX)A is a semilattice. This fulfills then the proviso above, since semilattices are precisely the algebras of the monad Pω.
Given a coalgebra f : X → MPωX, and because M has a final coalgebra, we can extend it uniquely to f♯ : PωX → MPωX and consider the unique coalgebra homomorphism into the final coalgebra, as summarised by the following diagram:

X
f
B × (Pω



X)A
{·}	P X

f♯

idB ×[[−]]A
[[−]]	BA∗
⟨ǫ,(−)a⟩
B × (BA∗ )A
(3)

With this construction, one can coalgebraically characterize language equiva- lence for Moore automata and, in particular, for non-deterministic automata. Take T = Pω and F = D, which is an instance of M for B = 2, the two-element semi- lattice. An MT -coalgebra is a pair (X, f ) with f : X → 2 × (PωX)A, i.e., an NDA. Therefore every NDA (X, f ) is transformed into (PωX, f♯) which is a DA. This cor- responds to the classical powerset construction for determinizing non-deterministic automata. The language recognized by a state x can be defined by precomposing
∗
the unique morphism J−): PωX → 2A with the unit of P , which is the function
{−}: X → PωX mapping each x ∈ X into the singleton set {x} ∈ PωX.

Decorated trace semantics via determinization
Our aim is to reason about decorated trace equivalences of labelled transition sys- tems. In this section, we use the generalized powerset construction and show how one can determinize arbitrary labelled transition systems obtaining particular in- stances of Moore automata (with different output sets) in order to model ready, failure, trace and complete trace equivalences. This paves the way to building a general framework for reasoning on decorated trace equivalences in a uniform fash- ion, in terms of bisimulations up-to congruence.
A labeled transition system is a pair (X, δ) where X is a set of states and δ : X →
(PωX)A is a function assigning to each state x ∈ X and to each label a ∈ A a finite
set of possible successors states. We write x −→a y whenever y ∈ δ(x)(a). We extend
the notion of transition to words w = a1 . . . an ∈ A∗ as follows: x −→w y if and only
if x a1	an	ε
−→ . . . −→ y. For w = ε, we have x −→ y if and only if y = x.
We now define in a nutshell the equivalences we will be dealing with in this paper. For a function ϕ ∈ (PωX)A, I(ϕ) denotes the set of all labels “enabled” by ϕ, given by I(ϕ) = {a ∈ A | ϕ(a) /= ∅}, while Fail(ϕ) denotes the set {Z ⊆ A | Z∩I(ϕ) = ∅}. Let (X, δ) be a LTS and x ∈ X be a state. A trace of x is a word w ∈ A∗ such that
x →w y for some y. A trace w of x is complete if x →w y and y stops, i.e., I(δ(y)) = ∅.
A failure pair of x is a pair (w, Z) ∈ A∗ ×PωA such that x →w y and Z ∈ Fail(δ(y)).
A ready pair of x is a pair (w, Z) ∈ A∗ × PωA such that x →w y and Z = I(δ(y)).
(See [14] for more details on the classical definition of traces, complete traces, ready and failure pairs.) We use T (x), CT (x), F(x) and R(x) to denote, respectively, the set of all traces, complete traces, failure pairs and ready pairs of x.
For I ranging over T , CT , F and R, two states x and y are I-equivalent iff
I(x) = I(y) [14].
Intuitively, these equivalences can be described as follows:
ready semantics identifies states of LTS’s according to the set Z of actions they can trigger immediately after a certain action sequence w has been “consumed”; we call a pair (w, Z) a ready pair,
failure semantics takes into account the set Z of actions that cannot be fired immediately after the execution of sequences w; we call a pair (w, Z) a failure pair,
trace semantics identifies system states if and only if they can execute the same

sets of action sequences w,
complete trace semantics identifies system states that perform the same sets of “complete” traces w; we call an action sequence w a complete trace of a state p
if and only if p −→w q and q cannot execute any further action.
The slight difference between trace and complete trace semantics consists in the fact that trace semantics does not detect stagnation, whereas the latter semantics takes into consideration deadlock states.
The coalgebraic characterization of the equivalences above was obtained in [12] in the following way. Given an arbitrary LTS (X, δ : X → (PωX)A), we associate a dec- orated LTS represented by a coalgebra of the functor FI(X) = BI ×(PωX)A, namely (X, ⟨oI, id⟩ ◦ δ : X → BI ×(PωX)A), where the output operation oI : (PωX)A → BI provides the observations of interest corresponding to the original LTS and depend- ing on the equivalence we want to study. (At this point, BI represents an arbitrary semilattice with a ∨ operation, instantiated for each of the semantics under con- sideration as in [12].) Then, we determinize the decorated LTS, as depicted in Figure 1.


X	{−}
PωX
J−)
(BI

)A∗

o(Y ) = Wy∈Y oI(δ(y))

δ	t(Y )(a) = S

y∈Y
δ(y)(a)

(PωX)A

⟨o,t⟩
[[Y ]](ε) = S oI (δ(y))
y∈Y
⟨ǫ,(−)a⟩

⟨oI ,id⟩
[[Y ]](aw) = [[ S
y∈Y
δ(y)(a)]](w)
∗

FIX = BI × (PωX)A

A
idBI ×J−)
BI × ((BI)A )A



Fig. 1. The powerset construction for decorated LTSs.

Note that both the output operation and its image are parameterized by I ∈ {R, F , T , CT }, depending on the type of decorated trace semantics under consideration. The explicit instantiations of oI and BI for ready semantics are provided in Section 4, where we will also show that the coalgebraic modelling in fact coincides with the original definition of ready equivalence. (Note that the same result can easily be derived in the same style also for the case of trace, complete trace and failure semantics.) A fact that was not formally shown in [12].
The coalgebraic representation of ready, failure, trace and complete trace models as illustrated in Fig. 1 enables the definition of the corresponding equivalences as Moore bisimulations (i.e., bisimulations for a functor M = BI × XA). This way, checking behavioural equivalence of x1 and x2 reduces to checking the equality of their unique representatives in the final coalgebra: J{x1}) and J{x2}) .
Moreover, it is worth observing that when reasoning on behavioural equivalence it is preferable to use relations as small as possible, that are not necessarily bisimu- lations, but contained in a bisimulation relation. These relations are referred to as bisimulations up-to [11].

In what follows we exploit the generalized powerset construction summarized in Fig. 1 and get an extension of bisimulation up-to congruence in [2] to the context of decorated LTS’s determinized in terms of Moore automata.
Let Ldec = (X, ⟨oI, id⟩ ◦ δ : X → BI × (PωX)A) be a decorated LTS and (PωX, ⟨o, t⟩ : Pω X → BI × (PωX)A) its associated Moore automaton, as in Fig. 1. A bisimulation up-to congruence for Ldec is a relation R ⊆ (PωX) × (PωX) such
that:


X1 R X2
⇒  o(X1) = o(X2)
 (∀a ∈ A) . t(X1)(a) c(R) t(X2)(a)	(♠)

where c(R) is the smallest equivalence relation which is closed with respect to set union and which includes R, defined as in [2].
Remark 3.1 Observe that by replacing c(R) with R in (♠) one gets the definition of Moore bisimulation.
Theorem 3.2 Any bisimulation up-to congruence for decorated LTS’s is included in a bisimulation relation.
Proof. The proof consists in showing that for any bisimulation up-to congruence R, c(R) is a bisimulation relation (recall that R ⊆ c(R)). The result follows imme- diately by structural induction.	✷
Remark 3.3 Based on (1), (2) and Theorem 3.2, verifying behavioural equivalence of two states x1, x2 in a decorated LTS consists in identifying a bisimulation up-to congruence Rc relating {x1} and {x2}:
J{x1}) = J{x2}) iff {x1} Rc {x2}.	(4)
Also note that Theorem 3.2 is not a very different, but useful generalization of Theorem 2 in [2] to the context of decorated LTS’s.
More insight on how to derive canonical representatives of decorated trace se- mantics and how to apply the bisimulation up-to congruence proof technique is provided in Section 4, for the case of ready semantics.

Ready semantics
In this section we show how the ingredients of Fig. 1 in Section 3 can be instantiated in order to provide a coalgebraic modelling of ready semantics, as introduced in [12]. Moreover, we prove that the resulting coalgebraic characterization of this semantics is equivalent to the original definition.
Consider an LTS (X, δ : X → (PωX)A) and recall that, for a function ϕ : A →
PωX, the set of actions enabled by ϕ is given by
I(ϕ) = {a ∈ A | ϕ(a) /= ∅}.	(5)

For the particular case ϕ = δ(x), I(δ(x)) denotes the set of all (initial) actions ready to be fired by x ∈ X.
Recall also that a ready pair of x is a pair (w, Z) ∈ A∗ × PωA such that x −→w y
and Z = I(δ(y)). We denote by R(x) the set of all ready pairs of x.
Intuitively, ready semantics identifies states in X based on the actions a ∈ A they can immediately trigger after performing a certain action sequence w ∈ A∗, i.e., based on their ready pairs. It was originally defined as follows:
Definition 4.1 [R-equivalence [14]] Let (X, δ:X → (PωX)A) be an LTS and x, y ∈ X two states. States x and y are ready equivalent (R-equivalent) if and only if they have the same set of ready pairs, that is R(x) = R(y).
Next, we instantiate oI of Fig. 1 to ready semantics, where I = R.
First note that in the setting of ready semantics, the observations provided by the output operation, which we denote by oR, refer to the sets of actions ready to be executed by the states of the LTS. Therefore, oR is defined as follows:
oR : (PωX)A → Pω(PωA) oR(ϕ) = {I(ϕ)}.
For the case ϕ = δ(x), where x ∈ X, it holds that:


oR(δ(x)) = {I(δ(x))} = {{a ∈ A | δ(x)(a) /= ∅}}.
In this particular instance, BI = BR = Pω(PωA) and the final Moore coalgebra
((P (P A))A∗ , ⟨ǫ, (−) ⟩)
associates to each state {x} the set of action sequences w ∈ A∗ such that x −→w






x′,

together with the sets of actions ready to be triggered by (all such) x′, for x, x′ ∈ X.
Next, we will prove the equivalence between the coalgebraic modelling of ready semantics and the original definition, presented above. More explicitly, given an arbitrary LTS (X, δ : X → (PωX)A) and a state x ∈ X, we want to show that J{x}) is equal to R(x).
The first remark is that the behaviour of a state x ∈ X is a function J{x}): A∗ → Pω(PωA), whereas R(x) is defined as a set of pairs in A∗ ×PωA. However, this is no problem since the set of functions A∗ → Pω(PωA) and P(A∗ ×PωA) are isomorphic. The set of all ready pairs R(x) associated to x ∈ X is equivalently represented by

R
{x}
, where, for w ∈ A∗ and Y ⊆ X,

ϕR : A∗ → Pω(PωA)
ϕR(w) = {Z ⊆ A | ∃y ∈ t(Y )(w) ∧ Z = I(δ(y))}

At this point, showing the equivalence between the coalgebraic and the original

definition of ready semantics reduces to proving that


(∀x ∈ X) . J{x}) = ϕR
.	(6)

Equality (6) is a direct consequence of the following theorem:
Theorem 4.2 Let (X, δ : X → (PωX)A) be an LTS. Then for all Y ⊆ X and
w ∈ A∗, JY )(w) = ϕR(w).
Proof. We proceed by induction on words w ∈ A∗.
Base case. w = ε. Consider an arbitrary set Y ⊆ X. We have:

JY )(ε) = o(Y ) =	{I(δ(y))}
y∈Y
ϕR(ε) = {Z ⊆ A | ∃y ∈ Y ∧ Z = I(δ(y))} (by def., (∀y ∈ Y ) . y −→ε  y)
=	{I(δ(y))}
y∈Y

Hence, JY )(ε) = ϕR(ε), for all Y ⊆ X.
Induction step.
Consider w ∈ A∗ and assume JY )(w) = ϕR(w), for all Y ⊆ X. We want to prove
that JY )(aw) = ϕR(aw), where a ∈ A.

JY )(aw) = Jt(Y )(a))(w)
ϕR(aw) = {Z | ∃y ∈ t(Y )(aw) ∧ Z = I(δ(y))}
= {Z | ∃y ∈ t(t(Y )(a))(w) ∧ Z = I(δ(y))}

R
t(Y )(a)
(w)

By the induction hypothesis, it follows that JY )(aw) = ϕR(aw), for all Y ⊆ X. We have that JY )(w) = ϕR(w), for all Y ⊆ X and w ∈ A∗.	✷
Example 4.3 In what follows we illustrate the equivalence between the coalgebraic and the original definitions of ready semantics by means of an example. Consider the following LTS.




p2
c
p1
p3
d

p4	p5
We write an to represent the action sequence aa . . . a of length n ≥ 1, with

n ∈ N. The set of all ready pairs associated to p0 is:

R(p0) = {(ε, {a}), (an, {a}), (an, {b}), (anb, {c}), (anb, {d}),
(anbc, ∅), (anbd, ∅) | n ∈ N ∧ n ≥ 1}.

We can construct a Moore automaton, for S = {p0, p1, . . . , p5},

(PωS, ⟨o, t⟩: PωS → Pω(PωA) × (PωS)A)

by applying the generalized powerset construction on the LTS above. The automa- ton will have 26 = 64 states. We depict the accessible part from state {p0}, where the output sets are indicated by double arrows:


{p0} 
a
{p0, p1}
{{a}}

{{a}, {b}}



{p2, p3}  {{c}, {d}}
{∅}  {p4}	{p5}  {∅}
Fig. 2. Ready determinization when starting from {p0}.


The output sets of a state Y of the Moore automaton in Fig. 2 is the set of actions associated to a certain state y ∈ Y which can immediately be performed. For example, process p0 in the original LTS above is ready to perform action a, whereas p1 can immediately perform b. Therefore it holds that o({p0}) = {{a}} and o({p0, p1}) = {{a}, {b}}.
At this point, by simply looking at the automaton in Fig. 2, one can easily see that the set of action sequences w ∈ A∗ the state {p0} can execute, together with the corresponding possible next actions equals R(p0). Therefore, the automaton generated according to the generalized powerset construction captures the set of all ready pairs of the initial LTS.

As we remarked in Section 3, ready equivalence of LTS’s can be established in terms of bisimulation up-to congruence on Moore automata with output in Pω(PωA), representing the sets of actions ready to be triggered.
Next, we will explain how one can reason on ready equivalence of two LTS’s, by constructing bisimulations up-to congruence on the associated Moore automata generated according to the powerset construction in Fig. 1.

Example 4.4 Consider the following LTS.

a
q3
a
q1	q7
q4	q5	q6
c	d	d
q8	q9	q10

It is easy to check that q0 and p0 have the same ready pairs, that is R(q0) = R(p0), where p0 is the state in the LTS of the previous example.
Since we have shown the coincidence between the original definition involving equality of ready pairs and the coalgebraic representation, we can now prove that q0 and p0 are ready equivalent by building a bisimulation up-to congruence relating
{p0} and {q0}.
First, we have to determinize the LTS above. We show below the accessible part of the determinized automaton starting from state {q0}:


{q0}
a
a	{q1, q2, q3, q7}
a	b
{{a}}

{{a}, {b}}

{{a}, {b}}  {q0, q1, q2, q3, q7}
b	{q4, q5, q6}
d
{{c}, {d}}

{∅}  {q8}	{q9, q10}  {∅}
Fig. 3. Ready determinization when starting from {q0}.

The next step is to build a bisimulation up-to congruence R on the sets of states of the generated Moore automata in Fig. 2 and Fig. 3, such that ({p0}, {q0}) ∈ R. We start by taking R = {({p0}, {q0})} and check whether this is already a bisimulation up-to congruence, by considering the output values and transitions, and check whether no new states appear in c(R) in the process. If new pairs of
states appear, we add them to R and repeat the process.
Eventually, we end-up with a bisimulation up-to congruence

R = {({p0}, {q0}), ({p0, p1}, {q1, q2, q3, q7}),
({p2, p3}, {q4, q5, q6}), ({p4}, {q8}), ({p5}, {q9, q10})}

By construction ({p0}, {q0}) ∈ R, so by (4) it follows that [[{p0}]] = [[{q0}]].
Note that R  is not a bisimulation relation since {p0, p1}	−→a	{p0, p1}
and {q , q , q , q }	−→a	{q , q , q , q , q }  but ({p , p }, {q , q , q , q , q })	/∈

1  2  3  7
0  1  2  3  7
0	1	0  1  2  3  7

R.	Nevertheless, observe that R is a bisimulation up-to congruence since

({p0, p1}, {q0, q1, q2, q3, q7}) ∈ c(R):
{p0, p1}	=	{p0} ∪ {p0, p1}
c(R) {q0} ∪ {p0, p1}	(({p0}, {q0}) ∈ R)
c(R) {q0} ∪ {q1, q2, q3, q7}	(({p0, p1}, {q1, q2, q3, q7}) ∈ R)
=	{q0, q1, q2, q3, q7}

Also observe that the bisimulation up-to congruence given above is one pair smaller than the Moore bisimulation relating the automata in Fig. 2 and Fig. 3, which would also include ({p0, p1}, {q0, q1, q2, q3, q7}).

Canonical representatives
Given a decorated LTS (X, ⟨oI, id⟩ ◦ δ), we showed in the previous section how to construct a determinized decorated LTS (PωX, ⟨o, t⟩). The map J−): PωX →
A provides us with a canonical representative of the behaviour of each state in
PωX. The image (C, δ) of (PωX, ⟨o, t⟩), via the map J−), can be viewed as the minimization w.r.t. the equivalence I.
Recall that the states of the final coalgebra (BA∗ , ⟨ǫ, (−) ⟩) are functions
I	a
ϕ : A∗ → BI. and that their decorations and transitions are given by the func-
tions ǫ : BA∗ → B  and (−) : BA∗ → (BA∗ )A, defined in Section 2. The states of
I	I	a	I	I	∗
the canonical representative (C, δ) are also functions ϕ : A∗ → BI, i.e., C ⊆ BA .
Moreover, the function δ : C → BI × CA is simply the restriction of ⟨ǫ, (−)a⟩ to C, that means δ(ϕ) = ⟨ϕ(ǫ), (ϕ)a⟩ for all ϕ ∈ C.
Finally, it is interesting to observe that BA∗ carries a semilattice structure (in-
I
A∗
herited by BI) and that J−): PωX → BI is a semilattice homomorphism. From this observation, it is immediate to conclude that also C is a semilattice, but it is not necessarily freely generated, i.e., it is not necessarily a powerset.

Conclusions and future work
In this paper, we have proved that the coalgebraic characterizations of decorated trace semantics in [12] are equivalent with the corresponding standard definitions. More precisely, for the case of ready equivalence, we have shown that for a state x in a labelled transition system, the coalgebraic canonical representative J{x}), given by determinization and finality, coincides with the classical semantics R(x) representing the ready pairs of x. In addition, we have illustrated how to rea- son about decorated trace equivalence using coinduction, by constructing suitable bisimulations up-to congruence. This is a very efficient sound and complete proof technique, and represents an important step towards automated reasoning, as it opens the way for the use of, for instance, coinductive theorem provers such as CIRC [9]. Note that even though in this paper we provided explicit proofs and ex- amples only for the case of ready equivalence, similar results can be easily derived

in the same style for (complete) trace and failure semantics.
A similar idea of system determinization was also applied in [4], in a non- coalgebraic setting, for the case of testing semantics where must testing coincides with failure semantics in the absence of divergence. A coalgebraic characterization of the spectrum was also attempted in [7], in a somewhat ad hoc fashion. Connec- tions with these works are still to be explored.
There are two possible directions for future works. On the one hand, we would like to investigate to what extent the coalgebraic treatment of decorated trace se- mantics can be applied in the context of probabilistic systems. On the other hand, we would like to understand how our approach can be combined with [3] to obtain a coinductive approach to denotational (linear-time) semantics of different kinds of processes calculi.

References
Awodey, S., “Category theory,” Oxford Logic Guides, Oxford University Press, 2010.
Bonchi, F. and D. Pous, Checking NFA equivalence with bisimulations up to congruence, Technical report (2012), 13p.
URL http://hal.archives-ouvertes.fr/hal-00639716
Boreale, M. and F. Gadducci, Processes as formal power series: A coinductive approach to denotational semantics, Theor. Comput. Sci. 360 (2006), pp. 440–458.
Cleaveland, R. and M. Hennessy, Testing equivalence as a bisimulation equivalence, Formal Asp. Comput. 5 (1993), pp. 1–20.
Hasuo, I., B. Jacobs and A. Sokolova, Generic trace semantics via coinduction, Logical Methods in Computer Science 3 (2007).
Milner, R., “Communication and concurrency,” Prentice-Hall international series in computer science, Prentice Hall, 1989.
Monteiro, L., A coalgebraic characterization of behaviours in the linear time - branching time spectrum, in: A. Corradini and U. Montanari, editors, WADT, Lecture Notes in Computer Science 5486 (2008),
pp. 251–265.
Park, D. M. R., Concurrency and automata on infinite sequences, in: P. Deussen, editor, Theoretical Computer Science, Lecture Notes in Computer Science 104 (1981), pp. 167–183.
Ro¸su, G. and D. Lucanu, Circular Coinduction – A Proof Theoretical Foundation, in: CALCO’09, LNCS, 2009.
Rutten, J. J. M. M., Universal coalgebra: a theory of systems, Theor. Comput. Sci. 249 (2000), pp. 3–80.
Sangiorgi, D. and J. Rutten, “Advanced Topics in Bisimulation and Coinduction,” Cambridge Tracts in Theoretical Computer Science, Cambridge University Press, 2011.
Silva, A., F. Bonchi, M. Bonsangue and J. Rutten, Generalizing determinization from automata to coalgebras, submitted.
Silva, A., F. Bonchi, M. M. Bonsangue and J. J. M. M. Rutten, Generalizing the powerset construction, coalgebraically, in: K. Lodaya and M. Mahajan, editors, FSTTCS 2010, LIPIcs 8, 2010, pp. 272–283.
URL http://drops.dagstuhl.de/opus/volltexte/2010/2870

van Glabbeek, R., The linear time - branching time spectrum I. The semantics of concrete, sequential processes, in: J. Bergstra, A. Ponse and S. Smolka, editors, Handbook of Process Algebra (2001), pp. 3–99.
