Electronic Notes in Theoretical Computer Science 117 (2005) 353–373 
www.elsevier.com/locate/entcs


Communicating Concurrent Objects in HiddenCCS
Gabriel Ciobanu Dorel Lucanu
“A.I.Cuza” University, Faculty of Computer Science Berthelot 16, 700483 Ia¸si, Romania
E-mail: {gabriel,dlucanu}@info.uaic.ro


Abstract
In this paper we add value-passing communication to hiddenCCS, a new formalism proposed in [2] for synchronizing concurrent objects. We use hidden algebra to specify object-oriented systems, and CCS process algebra to describe the coordination aspects. The new specification formalism extends the object specification with synchronization and communication elements associated with methods and attributes of the objects, and use a CCS description of the interaction patterns. The operational semantics of hiddenCCS specifications is based on labeled transition systems which can be specified in rewriting logic. We use Maude as a platform for verification of the communicating concurrent objects specified in hiddenCCS. Triple Modular Redundancy is used as an example of a hiddenCCS specification and its verification in Maude.
Keywords: Algebraic specification, concurrent systems, process algebra, object- oriented specification, hidden algebra, rewriting logic, Maude, CCS, linear temporal logic, verification techniques.

Introduction
The motivating idea of this paper is to study the coordination of some local goals given by various computing components in a concurrent system. In our approach, hidden algebra is used to specify the local goals as concurrent objects, and CCS is used to describe the coordination of the synchronizing and communicating objects.
State-based formalisms such as hidden algebra provide specification tech- niques for capturing complex data and states; however they are weak for capturing the interaction aspects of communicating concurrent systems. On the other hand, the process algebra and other concurrent calculi can support


1571-0661 © 2004 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.06.018


dynamic interaction and mobility; however they generally are not adequate to model data and states of complex concurrent systems. We have proposed an integration of hidden algebra and CCS, introducing hiddenCCS in [2]. In hid- denCCS we use hidden algebra to specify objects, and CCS to describe their synchronization. In this paper we extend the hiddenCCS approach, adding value-passing communication between distributed objects. We keep the name hiddenCCS for this extension. Synchronization and communication are pre- sented as two forms of interaction between objects. From an object-oriented point of view, we preserve the properties and the expressive power of hidden algebra specification; from a process algebra point of view, we describe the possible patterns of interaction and preserve the expressive power of CCS.
Hidden algebra takes as basic the notion of equational behavioral satisfac- tion: this means that hidden specifications characterize how objects behave in response to a given set of experiments. Hidden algebra is able to handle several features of large systems, including local states, nondeterminism, as well as the usual features of the object-oriented programming paradigm [8]. CCS is a concurrency calculus used to model the interaction among objects; a CCS process expresses the capability of the system to interact with other systems running concurrently. We use CCS to specify the communication requirements, describing interaction patterns between concurrent objects.
We extend the algebraic specifications of hidden algebra with two ele- ments of interaction, namely with synchronization and communication ele- ments. Synchronization elements link two objects whenever one is asking for a resource, and the other can offer such a resource. Communication given by a method accessing an attribute is similar to a value-passing interaction from the object having the attribute to the object having the method. The formal operational semantics of hiddenCCS integrates model semantics of hid- den algebra and CCS reduction rules by using these elements of interaction. The resulting labeled transition systems are translated into rewriting logic specifications using the Maude implementations of CCS and Hennessy-Milner logic. We use the Maude implementation of the linear temporal logic to verify properties of the hiddenCCS specifications.
The structure of the paper is as follows. Section 2 briefly presents hidden algebra. Section 3 briefly presents CCS. Section 4 includes the main contribu- tions: we introduce the new hiddenCCS specifications, and present some theo- retical results. Then we show how the operational semantics of the hiddenCCS specifications is described in rewriting logic and how the Maude system is used to verify temporal properties of hiddenCCS specifications. Conclusions and references end the paper.

Specification of Objects in Hidden Algebra

We briefly present the main concepts and notations of the hidden algebra. A detailed presentation of hidden algebra can be found in [8,14].
A ﬁxed data hidden-signature Σ consists of:
two disjoint sets: V (Σ) of visible sorts, and H(Σ) of hidden sorts;
a many sorted (V ∪ H)-signature Σ;
an ΣTV -algebra D(Σ) called data algebra.
We simply write V , H, and D whenever Σ is understood from the context. Given a hidden-signature Σ, a hidden Σ-model is a Σ-algebra M such that M TΣ†V = D. This means that the interpretation of each sort s ∈ V ∪ H is a distinct set Ms, and the interpretation of a symbol f ∈ Σs1 ···sn,s is a function [[f ]]M : Ms1 × ··· × Msn → Ms. We denote by MTΣ†V the algebra M restricted only to the visible sorts and visible operations. A hidden Σ-homomorphism

h : M → M' is a Σ-homomorphism such that hTΣ†
= idD. Given a hidden-

signature Σ and a subsignatu re Γ ⊆ Σ such that ΓTV = ΣTV , a Γ-context for
sort s is a term in TΓ({ : s}	Z) having exactly one occurrence of a special
variable  of sort s. Z is an infinite set of distinct variables. CΓ[ : s] denotes the set of all Γ-contexts for the sort s. If c ∈ CΓ[ : s], then the sort of c, viewed as a term, is called the result sort of the context c. A Γ-context with visible result sort is called a Γ-experiment. If c ∈ CΓ[ : s] with the result sort
s' and t ∈T (X) , then c[t] denotes the term in T (var(c) ∪ X) obtained from
Σ	s	Σ
c by substituting t for  . Furthermore, for each hidden Σ-model M, c defines
a map [c]]M : Ms → [Mvar(c) → Ms' ] defined by [c]]M (a)(ϑ) = aϑ(c), where aϑ(c) is the variable assignment { '→ a}∪ {z '→ ϑ(z) | z ∈ var(c)}. We call [[c]]M the interpretation of the context c in M.
Given a hidden-signature Σ, Γ ⊆ Σ such that ΓTV = ΣTV , and a hidden Σ-model M, the Γ-behavioral equivalence on M, denoted by ≡Γ , is defined as
follows:
for any sort s ∈ V ∪ H and any a, a' ∈ Ms, a ≡Γ a' iff [c]]M (a)(ϑ)= [c]]M (a')(ϑ)
for all Γ-experiments c and
all (V ∪ H)-sorted maps ϑ : var(c) → M.
Given an equivalence ∼ on M, an operation f ∈ Σs1...sn,s is congruent wrt
~ iff [f ]]M (a ,...,a ) ∼ [[f ]] (a' ,..., a' ), whenever a ∼ a' for i = 1,..., n.
1	n	M	1	n	i	i
An operation f ∈ Σ is Γ-behaviorally congruent wrt M iff it is congruent wrt
≡Γ . A hidden Γ-congruence on M is a (V ∪ H)-equivalence on M that is an identity on visible sorts, and each operation in Γ is congruent wrt it.


Theorem 2.1 [8,14] Given a hidden-signature Σ,a subsignature Γ ⊆ Σ such that ΓTV = ΣTV , and a hidden Σ-model M, then Γ-behavioral equivalence is the largest hidden Γ-congruence on M.
A hidden Σ-model M Γ-behaviorally satisﬁes a Σ-equation e of the form (∀X)t = t' if C, where C is a set of pairs of Σ(X)-terms, if and only if for all ϑ : X → M, ϑ(t) ≡Γ ϑ(t') whenever ϑ(u) ≡Γ ϑ(v) for all (u, v) ∈ C. We
Σ	Σ
write M |≡Γ e. If E is a set of Σ-equations, we write M |≡Γ E iff M |≡Γ e for
Σ	Σ	Σ
all e in E.
A behavioral speciﬁcation is a triplet B = (Σ, Γ, E) consisting of a hidden signature Σ, a subsignature Γ ⊆ Σ such that ΓTV = ΣTV and a set E of Σ- equations. We often denote the constituents of B by Σ(B), Γ(B) and E(B), respectively. The operations in Γ \ (ΣTV ) are called behavioral. A hidden Σ- model M behaviorally satisﬁes the specification B iff M Γ-behaviorally satisfies E, that is M |≡Γ E. We write M |≡ B and we say that M is a B-model. For any equation e, we write B |≡ e iff M |≡ B implies M |≡ e. An operation f ∈ Σ is behaviorally congruent wrt B iff f is Γ-behaviorally congruent wrt each B-model M.
Behavioral specifications can model concurrent objects. B specifies a sim- ple object iff:
H(B) has a unique element h called state sort;
each operation f ∈ Σ \ ΣTV is either:
a hidden (generalized) constant modeling an initial state, or
a method g : hv1 ··· vn → h with vi ∈ V for i = 1,..., n, or
an attribute q : hv1 ··· vn → v with v, v1, ··· , vn ∈ V .
In other words, the framework for simple objects is the monadic fixed-data hidden algebra [14]. A concurrent connection B1  ···  Bn is defined as in [7] where the (composite) state sort is implemented as tupling. If hi is the state sort of Bi, then a composite state is a tuple ⟨st1,... , stn⟩ : Tuple where the state sti is of sort hi. Projection operations i∗, i = 1,... , n, are defined by
projection equations i∗(⟨st ,... , st ⟩ = st together with “tupling equation”
1	n	i
⟨1∗st,... , n∗st⟩ = st, where st is of sort Tuple. We assume that all specifica- tions B1,... , Bn share the same data algebra. For each component Bi and f in Bi, we consider an operation f.Bi defined by:
f.Bi(⟨st1,... , stn⟩, −→x )= f (sti, →−x ) if f is an attribute, and
f.Bi(⟨st1,... , stn⟩, −→x )= ⟨st1,... ,f (sti, →−x ),... , stn⟩ if f is a method, where by −→x we denote a sequence of the form x1,... , xn.
Proposition 2.2 [8] 1. If g is a method of Bi, g' a method of Bj, and i /= j,



then
g.B (g'.B (st, −→y ), →−x )= g'.B (g.B (st, →−x ), −→y )

i	j	j	i
2. If q is an attribute of Bi, g a method of Bj, and i /= j, then
q.Bi(g.Bj(st, −→y ), −→x )= q.Bi(st, −→x ).
The first part of Proposition 2.2 allows us to consider the method g.Bi  g'.Bj
such that g.B g'.B (st, −→x, →−y ) means the concurrent execution of g.B (st, −→x )
i	j	i
and g'.Bj(st, −→y ). If g.Bi and g'.Bj are in Γ, then g.Bi  g'.Bj is in Γ(B  ...  Bn)
as well. Note that the new added functions f.Bi could be non-behavioral in B
even if f is behavioral in Bi.
By object speciﬁcation we mean either a simple object specification, or a conservative extension of a concurrent connection of object specifications. We extend an object specification by adding the following elements of interaction:
Elements of synchronization given by pairs (a, a) denoting the necessity and availability of the shared name a. Both a and a denote behavioral methods in different object components; the invocation of these methods expresses the necessity and the availability of a (it does not matter which one). An element a is called closed synchronization for B iff both a and a are present. If only one (either a or a) is present, then we have an open synchronization. Let Synch(B) denote the set of the synchronization elements of B.
Elements of communication given by pairs (a, a) denoting the receiving and sending of a value along the communication channel a. Now a de- notes a behavioral method and a denotes a behavioral attribute; the value supplied by the attribute is passed to the second component as an argu- ment of the calling method. A communication channel a is called closed communication for B iff both a and a are present. If only one element of a communication pair (either a or a) is present, then we have an open com- munication. Let Comm(B) denote the set of the communication elements of B.
We use the BOBJ language (http://www.cs.ucsd.edu/groups/tatami/bobj/) to ex- press the behavioral specifications. We enrich the BOBJ syntax by adding the synchronization capabilities by synch attributes of the corresponding meth- ods, and the communication capabilities by comm: ~a and comm: index ->
a. The index in comm: index -> a is used to identify the receiving com- ponent linked to the corresponding comm: ~a. Our extension of the BOBJ language uses ~a to denote a. We consider methods receiving along at most a single communication channel. However the attributes may send values along more than one communication channel.


  
Fig. 1. Triple Modular Redundancy
Example 2.3 Triple Modular Redundancy.
The following example exhibits how the synchronization and communication elements are used. Triple Modular Redundancy (TMR) is a popular technique in fault tolerance. Three copies of a module M are put together using a splitter S and a voter V (see Figure 1). The splitter sends the input value to each copy of the system module M. There is no fixed order in which the splitter sends the input value to the three copies of M. A faulty M either behaves correctly or may output an arbitrary value. The voter accepts the results from each of these copies of M, and outputs the majority value. The behavioral specification of the system is:
dth DATA is sort Data .
sort ModuleId . ops 0 1 : -> Data .
ops 1 2 3 : -> ModuleId .
op vop : Data -> Data .	*** equations defining vop are missing end
bth MOD1 is sort Mod1 . inc DATA .
op put : Mod1 Data -> Mod1 .	[comm: 1 -> mi1] op hop : Mod1 -> Mod1 .	[synch: w1]
op get : Mod1 -> Data .	[comm: ~mo1] var M : Mod1 . var D : Data .
eq get(put(M, D)) = D . end
*** MOD2 and MOD3 are defined in a similar way as MOD1 bth SPLITTER is
sort Splitter .
inc DATA .
op rec : Splitter Data -> Splitter . [comm: 1 -> in]
op split : Splitter -> Data .	[comm: ~mi1, ~mi2, ~mi3] op rack : Splitter -> Splitter .	[synch: ack]
var S : Splitter . var D : Data . eq split(rec(S, D)) = D .


end
bth VOTER is sort Voter . inc DATA .
op rec1 : Voter Data -> Voter . [comm: 1 -> mo1] op rec2 : Voter Data -> Voter . [comm: 1 -> mo2] op rec3 : Voter Data -> Voter . [comm: 1 -> mo3] op val : Voter -> Data .    [comm: out]
var V : Voter . vars D1 D2 D3 : Data . eq val(rec3(rec2(rec1(V, D1), D2), D3)) =
if (D1 == D2) then D1 else D3 fi .
op sack : Voter -> Voter .   [synch: ~ack] end
bth TMR is
inc (SPLITTER || MOD1 || MOD2 || MOD3 || VOTER) * (sort Tuple to Tmr) . end
MOD1 specifies a simple TMR module that receives an input data from somewhere and executes an operation (method) hop over these values. Nor- mally we expect the result of the operation hop( ) to be vop(get(hop( ))), but unfortunately the system may have faults and therefore the result is un- predictable. This nondeterministic property is implicitly expressed by the fact that we have no equation regarding the effect of hop. The comm at- tributes are introduced to describe the communication elements of the mod- ule. For instance, comm: 1 -> mi1 specifies that the 1st visible argument of the method put is the value passed by someone else using the communica- tion channel ~mi1. This value is bound to the 1st argument of the method. comm: ~mo1 specifies that the module sends along the communication channel mo1 the value returned by the attribute get for the current state. We have synch(hop.MOD1) = w1, comm(put.MOD1) = 1 → mi1, comm(get.MOD1) =
~mo1, Synch(MOD1) = {w1}, Comm(MOD1) = {mi1, ~mo1}.  The splitter re-
ceives a value along in, passes this value along ~mi1, ~mi2, ~mi3, and waits for an acknowledgment along ack. The voter receives data along mo1, mo2, mo3, and sends the majority value along ~out; then it sends an acknowledg- ment along ~ack. The effective actions are made by the operations behind these synchronization and communication elements.

CCS
The Calculus of Communicating Systems (CCS) was originally developed in the ’80s by Milner [12]. CCS provides a minimal formal framework to describe and study synchronized and communicating concurrent processes and various behavioral equivalences. Interaction among processes is established by a non-



Fig. 2. CCS operational semantics
deterministic matching between complementary ends of some synchronization and communication channels. When there are many pairs which can satisfy the matching condition, only a single pair (a, a) is selected.
We assume a set A of names; the elements of the set A = {a | a ∈ A} are called co-names, and the elements of the set L = A∪ A are labels naming ordinary actions. The standard definition of CCS includes only one special action called silent action and denoted by τ , intended to represent an internal action of the system.
The processes are defined over the set A of names by the following syntac- tical rules:
P ::= 0 | α.P  | P + Q | P |Q | new L P  | A⟨a1,... , an⟩
where P and Q range over processes, α over actions, ai over names, L over sets of names, and A over process identifiers.
A structural congruence relation is defined over the set of processes. The relation ≡ over the set of processes is called structural congruence, and is defined as the smallest congruence which satisfies:
P ≡ Q if Q can be obtained from P by α-conversion,
P +0 ≡ P , P + Q ≡ Q + P , (P + Q)+ R ≡ P + (Q + R),
P | 0 ≡ P , P | Q ≡ Q | P , (P | Q) | R ≡ P | (Q | R).
The structural operational semantics is shown in Figure 2, where we have already assumed that the summation and parallel composition are associative

−→	−→
−→ −→

and commutative. If
a = (a1,... , an) and
b = (b1,... , bn), then { b / a }P

denotes the simultaneous substitution P [b1/a1,... , bn/an]. We also assume
that every process identifier A has a defining equation of the form A(−→a ) d=ef P
A
where PA is a summation of processes, and −→a = (a1,... , an) includes all the free names in PA.
Strong bisimulation, written ∼, is defined over the processes as the largest

symmetrical relation such that: if P ∼ Q and P −→α  P ', then there exists Q'
such that Q −→α  Q' and P ' ∼ Q'. Weak bisimulation, written ≈, is defined
over the processes as the largest symmetrical relation such that: if P ≈ Q and
P −→α  P ', then there exists Q' such that Q =α⇒ Q' and P ' ≈ Q'.
In our formalism, we provide a computational structure to the CCS ac- tions, and it is enough to consider pure CCS to model the synchronization and communication between concurrent objects. According to the computa- tional structure behind each action, it is possible to decide the type of an interaction. The synchronization elements are provided by pairs (a, a) with each component associated with a method; in this way we have a method- method interaction. The communication elements are also provided by pairs (a, a); however, now a is associated with an attribute, and a is associated with a method.
Hennessy-Milner Modal Logic (HML) is a simple modal logic of actions used for describing local capabilities of CCS processes. HML formulas are as follows:
ϕ ::= tt | ff | ϕ1 ∧ ϕ2 | ϕ1 ∨ ϕ2 | [α]ϕ | ⟨α⟩ϕ | [[α]]ϕ | ⟨⟨α⟩⟩ϕ
If P is a CCS process and ϕ a HML formula, the satisfaction relation P |= ϕ
is inductively defined as:
P |= tt
P |= ϕ1 ∧ ϕ2 iff P |= ϕ1 and P |= ϕ2 P |= ϕ1 ∨ ϕ2 iff P |= ϕ1 or P |= ϕ2

P |= [α]ϕ iff (∀P '
∈ {P ''
α
| P −→ P
''}
) P ' |= ϕ

P |= ⟨α⟩ϕ iff (∃P '
∈ {P ''
α
| P −→ P
''}
) P ' |= ϕ

P |= [[α]]ϕ iff (∀P ' ∈ {P '' | P	α
P |= ⟨⟨α⟩⟩ϕ iff (∃P ' ∈ {P '' | P	α
''} ''
) P ' |= ϕ
) P ' |= ϕ


HiddenCCS Specifications
The integration of CCS and object specification in hidden algebra is given by the elements of synchronization and communication. A CCS process over the elements of synchronization and communication works as a coordinating module that manages the interaction between objects. A hiddenCCS spec- iﬁcation is a triple (B, P, IC) consisting of objects specifications B given in hidden algebra, a CCS description P of the coordinating module, and a set IC of integration consistency requirements. The semantics of hiddenCCS spec-


ifications is given by a labeled transition system defined over configurations (hidden state, CCS process) as follows:

If
α
P −→ P
' and α is open, then (st, P ) α
(st',P '), where st' is obtained

from st by applying the method associated to α.

If
α	',
α	', and α is closed, then (st, P | Q) τ
(st',P ' | Q'),

where st' is obtained from st by synchronously applying the methods associated to α and α whenever the integration consistency requirements are satisfied.

If P −→a  P ', Q −→a
Q' where k→a = comm(g) and a ∈ comm(q), then

τ
(st, P | Q) −→
(st',P ' | Q') such that st' is obtained from st applying the

method g having the kth argument provided the attribute q, whenever the integration consistency requirements are satisfied. Moreover, the sort of the kth argument of g should be equal to the sort of q.
This definition is sound if each (co-)name is uniquely associated to a method or attribute. Whenever the same name a is related to more than one method, e.g., to the methods g1,... , gn, then we consider n distinct copies a1,..., an of the name a, each of them for the corresponding method, and we define a relation eq given by ai eq a for i = 1,... , n. The operational semantics of CCS is modified as follows. The “synchronization” rule is replaced with:

αi	'
αj	'

P −→ P	Q −→ Q
αi eq α and αj eq α

τ (αi,αj )	'	'
P |Q −−−−→ P |Q
For the silent action τ we use a more exact notation τ (αi, αj) indicating the names involved in such an internal action. This notation is necessary to inte- grate CCS semantics with the behavioral semantics of hidden algebra. Since τ is used in the definition of the CCS bisimulation, the following rules restore it from τ (αi, αj), where α∗ = if (α = τ (αi, αj)) then τ else α:

τ (αi,αj )
τ ∗	'
' α	'
'  τ ∗

P −−−−→ Q
τ
P =⇒ Q
P =⇒ P	P −→ Q	Q =⇒ Q
α∗
P =⇒ Q

A CCS(B)-process is a CCS process built over the set Synch(B) ∪ Comm(B).
An integration consistency requirement expresses the availability of an inter- action resource and consists of a finite set of equations q( , d1,... , dn) = d, where q is an attribute in Γ, and d, d1,... , dn ∈ D(B). Let ic(a, a) denote the integration consistency requirement corresponding to the interaction pair (a, a). A state st of a model M satisﬁes ic(a, a) whenever [q]]M (st, d1,..., dn)= d for each q( , d1,... , dn) = d in ic(a, a); we write st |= ic(a, a). Our TMR example does not use the integration consistency requirements. An example of integration consistency requirement is offered by a critical resource where it is expressed by an equation of the form isAvailable( ) = true meaning


that the critical resource may interact only if it is available in the current state. Such an example is presented in [2].

Fig. 3. HiddenCCS operational semantics
Given an object specification B and a hidden B-model M, we denote by LT SΓ,CCS(M) the labeled transition system defined by the rules in Figure 3, where P , P ' and Q are CCS(B)-processes, and −→ and −→' are sequences of data
values from D(B). The transitions corresponding to noninteracting behavioral
methods are labeled by idle. If st is a state in M and P is a CCS process, then LT SΓ,CCS(M, st, P ) denotes the subsystem induced by the subset of the configurations which are reachable from (st, P ).
Definition 4.1 Let Σ be an object signature, Γ a subsignature of Σ, and let

M and M' be two Σ-models. The relation  Σ,Γ
' ⊆ Mh × M'
is defined by:

Σ,Γ	'	'
st M,M ' st iff [q]]M (st, d1 ..., dn) = [q]]M' (st , d1 ... , dn) for any attribute
q ∈ Γ, and data values d1,... , dn ∈ D(B).


Definition 4.2 Given an object specification B = (Σ, Γ, E), and two B- models M and M', then the behavioral CCS-based strong Γ-bisimulation be-
'

tween M and M
(st' ,P ') implies
is the largest relation ∼M,M' such that (st1,P ) ∼M,M'

st1
Σ,Γ
M,M
' st' ,

if (st ,P ) −→α  (st , Q) then there is (st' , Q') such that (st' ,P ') −→α  (st' , Q')
1	2	2	1	2
'	'
and (st2, Q) ∼M,M' (st2,Q ), and

if (st' ,P ') α (st' , Q') then there is (st , Q) such that (st ,P ) α
(st , Q)

1	−→	2	2
'	'
1	−→	2

and (st2, Q) ∼M,M' (st2,Q ).
We say that a state st is consistent with a process P iff for each configura- tion (st',P ') reachable from (st, P ), st' satisfies the integration consistencies required by P '. A ground term t of state sort is consistent with a process P iff [t]]M is consistent with a P for each B-model M.
Proposition 4.3 Given an object speciﬁcation B = (Σ, Γ, E), two CCS(B)- processes P and P ', and two B-models M and M ', then P ∼ P ' whenever there are st in M and st' in M ' such that st is consistent with P, st' is consistent
'	'	'
with P , and (st, P ) ∼M,M' (st ,P ).
'	'
Proof. Let us consider (st, P ) ∼M,M' (st ,P ) such that st is consistent with
and st' is consistent with P '. We have to show that P ∼ P '. Let R be

the relation defined by Q R Q' iff there are st and st'
such that (st1, Q) ∈

'	'	'	'	'
LT SΓ,CCS(M, st, P ), (st1,Q ) ∈ LT SΓ,CCS(M , st ,P ), and (st1, Q) ∼M,M'
(st' , Q'). We show that if Q R Q' and	α	, then there is Q' such that

1	1	1
Q1 −→ Q2	2

−→α  Q' and Q RQ' . Let Q ,Q , Q'
be such that Q RQ' and Q
−→α
Q . By

2	2	2	2
1	2	1
1	1	1	2

definition of R there are st  and st'
'	'	'	'	'
such that (st1, Q1) ∈ LT SΓ,CCS
'	'
(M, st, P ),

(st1, Q1) ∈ LT SΓ,CCS(M , st ,P ), and (st1, Q1) ∼M,M' (st1, Q1). We distin-
guish the following cases:
a
α = a. Let g be the method in Bi associated to a. We have (st1, Q1) −→
−→	−→
(st ,Q ), where st = [[g.B ]] (	) for certain	. There is (st' , Q' )

2	2	2
'	'	α
i M st1, d
'	'
d	2	2
'	'

such that (st1, Q1) −→ (st2, Q2) and (st2, Q2) ∼M,M' (st2, Q2) by the def-
inition of ∼M,M' .  Since a is uniquely associated to g, it follows that

'	' −→
'  a	'	'

st2 = [[g.Bi]]M' (st1, d ) and Q1 −→ Q2. Hence Q2 R Q2.
The case α = a is similar.
α = τ . We suppose that τ is restored from τ (αi, αj). Since st is consistent with P and (st1, Q1) is reachable from (st, P ), it follows that st1 |= ic(αi, αj) which implies the existence in LT SΓ,CCS(M) of a transition
a	'	'
(st1, Q1) −→ (st2, Q2). Since (st1, Q) ∼M,M' (st1,Q ), it follows that there
'	'	'	'	a	'	'	'	'
is (st2, Q2) such that (st1, Q1) −→ (st2, Q2) and (st2, Q2) ∼M,M' (st2, Q2).

By the definition of our transition system, there exists (α', α' ) such that
i	j
τ (α' ,α' )
Q' −−−−→ Q' . It follows that	'	τ	' by the restoring rule, and

1
Q R Q'
2
by definition of R.
Q1 −→ Q2

Therefore we obtained that there is Q' such that	α	and Q R Q'
in all

2	Q2 −→ Q2	2	2
cases. It follows that R ⊆ ∼.	 
Proposition 4.4 Given an object speciﬁcation B = (Σ, Γ, E), and a B-model
M, then (st, P ) ∼M,M (st',P ') whenever st ≡Γ st' and P ∼ P '.
Proof. We define the relation R by (st, P ) R (st',P ') iff st ≡Γ st' and P ∼

P '. If (st, P ) R (st',P ') then st  Σ,Γ
st' because  Σ,Γ
is included in the

behavioral equivalence. We suppose that (st ,P ) R (st' ,P ') and (st ,P ) α

1	1	1	1
(st2, P2). We have the following cases:
1	1 −→

α = a.	Let g be the method in Bi associated to a.	Then st2 =

−→
[[g.Bi]]M (st1, d ) for certain
−→
d , and P1
a
−→ P2 by the definition of the

transition system. Since P
~ P ', there is P ' such that P ' −→a  P ' and

1	1	−→ 2	1	2

P ∼ P '. We consider st'
= [[g.B ]] (st' , d ). We have st ≡Γ st'
be-

2	2	2
i M	1
a  2	Σ	2

cause st ≡Γ st'
and g is behavioral. It follows (st' ,P ') −→ (st' ,P ') and

1	Σ	1
1	1	2	2

(st ,P ) R (st' ,P '). The case α = a is similar.
2	2	2	2
α = τ . By the definition of the transition system, there exists (αi, αj)

such that
τ (αi,αj )
'	'  τ (αi,αj )	'

P1 −−−−→ P2. Then there is P2 such that P1 −−−−→ P2

because P
~ P '. Since st ≡Γ st' , it follows that st' |= ic(α ,α ). A

1	1	1	Σ	1	1	i	j
reasoning similar to that of the previous case implies that there are st'

'	'	'	τ	'	'
'	'	2

and P2 such that (st1, P1) −→ (st2, P2) and (st2, P2) R (st2, P2).
α = idle. We have P1 = P2. Then there is a noninteracting method g
−→	→−
in Bi, for certain i, and d such that st2 = [[g.Bi]]M (st1, d ). We take
P ' = P ' and st' = [[g.B ]] ( ' −→). We have (st ,P ) R (st' ,P ') because

2	1	2
i M st1, d
2	2	2	2

g is behavioral.
We obtained in all the cases that there are st'

and P ' such that (st' ,P ') −→α

'	'	'	'
2	2	1	1

(st2, P2) and (st2, P2) R (st2, P2). Therefore R ⊆ ∼.	 
Remark 4.5 The converse of Proposition 4.4 is not generally true [9]. This is due to the fact that we may have ∼M,M' /= ≡Γ .

Describing the LTS in Rewriting Logic
Rewriting logic [4] is a logic able to deal with the concurrent changes of states and with concurrent computations. It has good properties, and provides a general semantic framework for executable implementations of a wide range


of languages and models of concurrency. In particular, it supports the imple- mentations of CCS and HML [16].
Maude [4] is a system extending OBJ3 with support for membership equa- tional logic and rewriting logic. A distinguished feature of Maude is the use of the reflection property of the rewriting logic for creating executable envi- ronments for different logics, theorem provers, and models of computations. However, the current version of Maude does not support yet the hidden logic used by BOBJ for behavioral specification and verification.
We denote by R(P)= (Σ(P), E(P), R(P)) the rewriting specification as- sociated with the CCS specification P as in [16], and by |=HML the deduc- tion relation for HML. The sort of the CCS processes in R(P) is denoted by
α
Process. succ(P, α) is the function which returns the set {Q | P −→ Q}. Let
SP = (B, P, IC) be a hiddenCCS specification where B = (Σ, Γ, E) and the state sort of B is h. We associate with SP a rewriting specification R(SP )= (Σ', E', R), where Σ' is Σ ∪ Σ(P) ∪ Σ(HML) together with a new sort St and a new operation ( , ): h Process → St, and E' = E ∪ E(P) ∪ E(HML). R includes the following rules:
if g : hiv1 ... vn → hi is a method in Bi such that synch(g) = α or
comm(g)= k→α and α is open, then we add rewriting rules of the form:

α : (st, P ) → (g.Bi(st, d1,..., dn), Q) if P |=HML ⟨α⟩tt ∧ Q ∈ succ(P, α)

for appropriate d1,... , dn ∈ D(B);
if q : hiv1 ... vn → v is an attribute in Bi such that a ∈ comm(q) and a is open, then we add rewriting rules of the form:

a : (st, P ) → (st, Q)	if P |=HML ⟨a⟩tt ∧ Q ∈ succ(P, a)

if g : hiv1 ... vn → hi is a noninteracting method in Γ, then we add a rewriting rule of the form:
idle : (st, P ) → (g.Bi(st, d1,... , dn),P ) for appropriate d1,... , dn ∈ D(B).
if g : h v ... v	→ h is a method in B with synch(g) = α , g' :
i 1	n	i	i	i
hjv' ... v' ' → hj is a method in Bj with synch(g') = αj, and there is
1	n
α such that αi eq α and αj eq α, then we add rewriting rules of the

form:
τ : (st, P ) → (g.B g'.B (st, d ,... ,d , d' ,... , d' '), Q)

i	j	1
n	1	n

if P |=HML ⟨τ (αi, αj)⟩tt ∧ Q = succ(P, τ (αi, αj)) ∧ ic(αi, αj)
for appropriate d ,... ,d , d' ,... , d' ' ∈ D(B);
1	n	1	n
if g : hiv1 ... vn → hi is a communicating method with comm(g)= k→ai, q in Bj, aj ∈ comm(q), and there is a such that ai eq a and aj eq a, then we add rewriting rules of the form:
τ : (st, P ) → (g.Bi(st, d1,... , dn), Q)
if P |=HML ⟨τ (ai, aj)⟩ tt ∧ Q ∈ succ(P, τ (ai, aj)) ∧ ic(ai, aj)

where dl ∈ D(B)v if l /= k, and dk = q.Bj(st, d' ,... , d'
) for appropriate

'	'	Æ	1	m
d1,..., dm ∈ D(B);
Remark 5.1 1. If D(B) is infinite, then R(SP ) could include an infinite number of rewriting rules. A particular case when the number of rules is finite is that when all the communicating methods in Γ have all the visible argu- ments bound to communication channels, the communicating attributes in Γ are unary – i.e., the only argument is the current state, the communication elements are closed, and Γ does not include noninteracting methods.
2. We note that R(SP ) forgets the behavioral operations. This has some dras- tic semantic consequences; e.g., not all R(SP )-models produce SP -models. Therefore we restrict the semantics of R(SP ) to those models where the states behaviorally satisfy the equations E. This restriction together with Proposition 4.4 make sound the following deduction rule:
st' ≡ st	α : (st ,P ) −→ (st , Q)	st ≡ st'
1	1	1	2	2	2
α : (st' ,P ) −→ (st' , Q)
1	2
The use of this rule can reduce the state space within a model checking algo- rithm over the rewriting specifications according to the approach presented in [10].
We use the TMR example to exhibit how the Maude system can be used to build R(SP ). We first modify the Maude module implementing the oper- ational semantics of CCS by replacing the rule for synchronization and com- munication with the following two rules:
crl P | Q => {tau(L)}(P’ | Q’) if P => {L}P’ /\ Q => {~ M}Q’ /\ L eq M . crl P | Q => {tau(M)}(P’ | Q’) if P => {L}P’ /\ Q => {~ M}Q’ /\ L eq M .
where L eq M represents the implementation of the eq relation. Then we change the definition of τ , representing it by a function having as argument one

of the actions involved in synchronization. This is not a restriction, because

τ (αi,αj )
P | Q −−−−→ P
| Q'
τ (αi)
is the same as P | Q −−−→ P
| Q'
τ (αj )
and P | Q −−−→ P  |

Q'. Moreover, we have τ (α)= τ (α).
The Maude description of the CCS expressions for TMR is as follows:
mod TMR-CCSPROC is inc CCS .
ops in out mi1 mi2 mi3 mo1 mo2 mo3 w1 w2 w3 ack : -> Label . ops S S1 S2 M1 M2 M3 V TMR : -> ProcessId .
eq context = ( S =def in . S1 ) &
( S1 =def ~ mi1 . ~ mi2 . ~ mi3 . S2 + ~ mi1 . ~ mi3 . ~ mi2 . S2 + 
~ mi2 . ~ mi1 . ~ mi3 . S2 + ~ mi2 . ~ mi3 . ~ mi1 . S2 + 
~ mi3 . ~ mi1 . ~ mi2 . S2 + ~ mi3 . ~ mi2 . ~ mi1 . S2 ) & ( S2 =def ack . S ) & ( M1 =def mi1 . w1 . ~ mo1 . M1 ) & 
( M2 =def mi2 . w2 . ~ mo2 . M2 ) & ( M3 =def mi3 . w3 . ~ mo3 . M3 ) & 
( V =def mo1 . mo2 . mo3 . out . ~ ack . V ) & ( TMR =def ( S | M1 | M2 | M3 | V ) 
\ mi1 \ mi2 \ mi3 \ mo1 \ mo2 \ mo3 \ ack ) .
endm
Note that the operator new L P is represented by the restriction P \ L. The Maude description of the rewriting specification associated with the TMR hiddenCCS specification is :
mod TMR-CCS is
pr TMR-TEST . pr MODAL-LOGIC .
sort CcsTmr .
op <_‘,_> : Tmr Term -> CcsTmr .
op 1*_ : CcsTmr -> Tmr . op 2*_ : CcsTmr -> Term .
var C : CcsTmr . vars A A’ : Tmr . vars P P’ Q Q’ : Term . eq < 1* C, 2* C > = C .
eq 1* < A, P > = A . eq 2* < A, P > = P . 
crl [in] : < A, P > =>
< < rec(1* A, 0), 2* A, 3* A, 4* A, 5* A >,succ(P,’in.Label) > if P |= < ’in.Label > tt .
*** missing one ’in’ rule
crl [out] : < A, P > => < A, succ(P,’out.Label) > if P |= < ’out.Label > tt .
crl [w1] : < A, P > =>
< < 1* A, hop(2* A), 3* A, 4* A, 5* A >,succ(P,’idle1.Label) > if P |= < ’idle1.Label > tt .
*** missing two ’idle’ rules crl [tau] : < A, P > =>
< < 1* A, put(2* A, split(1* A)), 3* A, 4* A, 5* A >, succ(P,’tau[’mi1.Label]) >
if P |= < ’tau[’mi1.Label] > tt .
*** missing five ’tau’ rules crl [tau] : < A, P > =>
< < rack(1* A), 2* A, 3* A, 4* A, sack(5* A) >, succ(P,’tau[’ack.Label]) >
if P |= < ’tau[’ack.Label] > tt .
endm


The Maude module MODAL-LOGIC describes HML and “|=” is the Maude im- plementation of the relation |=HML. Since HML is implemented at the met- alevel, the names used in the CCS terms are quoted. In this example the successor is unique. We have to include a rule for each successor when we have more successors.
Maude has some useful commands to analyze the dynamics of the rewrit- ing specifications. Here we use the search command to generate possible evolutions for the TMR system:
search [50] < init, ’TMR.ProcessId > =>+ ST:CcsTmr .
Maude provided 50 solutions possible:
...
Solution 50 (state 50)
states: 51 rewrites: 4079783942 in 8365430ms cpu (8438250ms real) (487695 rewrites/second)
ST:CcsTmr --> < < rec(rack(rec(initS, 1)), 0),put(hop(put(initM1, 1)), 0), put(hop(put(initM2, 1)), 0),hop(put(initM3, 1)),sack(rec(initV, get(hop(put(initM1, (1).Data))), get(hop(put(initM2, (1).Data))), get(hop(put(initM3, (1).Data))))) >, ’_\_[’_\_[’_\_[’_\_[’_\_[’_\_[’_\_[’_|_[’M3.ProcessId,
’V.ProcessId,’_._[’w1.Label,’_._[’~_[’mo1.Label],’M1.ProcessId]],
’_._[’w2.Label,’_._[’~_[’mo2.Label],’M2.ProcessId]],’_._[’~_[’mi3.Label],
’S2.ProcessId]],’mi1.Label],’mi2.Label],’mi3.Label],’mo1.Label], ’mo2.Label],’mo3.Label],’ack.Label] >
The execution performance of Maude is not encouraging. A reason for this weak performance is that CCS and LTL model checker are implemented at the metalevel. Built-in CCS module and LTL model checker could improve the Maude execution time.
A Linear Temporal Logic (LTL) model checker is implemented in Maude [6], and it can be used to verify temporal properties of the rewriting specifi- cations. The atomic temporal propositions for the state sort h are equations having one of the forms:
q(, d1,... , dn)= d with q an attribute in Γ and d, d1,... , dn ∈ D(B), or
⟨−⟩ = g( , d1,..., dn) with g a method in Γ and d1,..., dn ∈ D(B).
The intuitive meaning of an atomic Γ-proposition q( , d1,..., dn)= d is that we obtain d whenever we execute a query q( , d1,..., dn) over the current state. The intuitive meaning of ⟨−⟩ = g( , d1,... , dn) is that there is a state which can be obtained from the current state by applying the method g over the current state with the arguments d1,... , dn.
The linear temporal logic model checker works only if the set of reachable states is finite. The state space generated by the hiddenCCS specification TMR-CCS is infinite. However it can be abstracted and reduced into a finite state space by considering the behavioral equivalences. For instance, we have


such behavioral equivalences for the splitter: rack(rec(initS, 1)) ≡ initS and rack(rec(initS, 0)) ≡ initS. Similar equivalences are given for the other components.
We verify now the following property: if two modules are working properly, then the voter will select the right value. In order to have a module working properly (without failures), we add the equation get(hop(M)) = vop(get(M)) to its specification. We use the linear temporal logic formula
[] (in-is-eq-0 -> <> (in-is-eq-0 U out-is-eq-0))
expressing that the splitter value (here 0) remains unchanged until the voter outputs it. The state for which we verify the temporal formula is defined as follows:
op initS : -> Splitter . op initM1 : -> Mod1 . op initM2 : -> Mod2 . op initM3 : -> Mod3 . op initV : -> Votter . op init : -> Tmr .
eq init = < initS, initM1, initM2, initM3, initV > .
Then we add to TMR the equations expressing the behavioral equivalences:
vars D1 D2 D3 : Data .
eq rack(rec(initS, 0)) = initS . eq rack(rec(initS, 1)) = initS .
eq put(op(put(initM1, D1)), D2) = put(initM1, D2) . eq put(op(put(initM2, D1)), D2) = put(initM2, D2) . eq put(op(put(initM3, D1)), D2) = put(initM3, D2) .
eq sack(rec(initV, D1, D2, D3)) = initV .
The following two Maude specifications define the predicates and load the model checker.
mod TMR-PREDS is protecting TMR-CCS . including SATISFACTION . subsort CcsTmr < State .
ops out-is-eq-0 in-is-eq-0 : -> Prop . ops out-is-eq-1 in-is-eq-1 : -> Prop . var CT : CcsTmr .
cq CT |= in-is-eq-0 = true if (split(1* 1* CT) == 0) . cq CT |= in-is-eq-1 = true if (split(1* 1* CT) == 1) . cq CT |= out-is-eq-0 = true if (val(5* 1* CT) == 0) . cq CT |= out-is-eq-1 = true if (val(5* 1* CT) == 1) .
endm
mod TMR-CHECK is including TMR-PREDS .
including MODEL-CHECKER . including LTL-SIMPLIFIER .


ops initconf : -> CcsTmr .
eq initconf = < init, ’TMR.ProcessId > . endm
Maude provides the following output which express that the property holds:
red modelCheck(initconf, [](in-is-eq-0 -> <> (in-is-eq-0 U out-is-eq-0))) .
Maude> red modelCheck(initconf, [](in-is-eq-0 ->
<>(in-is-eq-0 U out-is-eq-0))) . reduce in TMR-CHECK : modelCheck(initconf, [](in-is-eq-0 ->
<> (in-is-eq-0 U out-is-eq-0))) . rewrites: 5752427265
result Bool: true Maude>
On the contrary, if we consider only one module working properly, then the property does not hold:
Maude>
red modelCheck(initconf, [](in-is-eq-0 -> <>(in-is-eq-0 U out-is-eq-0))) . reduce in TMR-CHECK : modelCheck(initconf, [](in-is-eq-0 ->
<>(in-is-eq-0 U out-is-eq-0))) . rewrites: 900617437
result ModelCheckResult: counterexample({< <initS,initM1,initM2,initM3,...

Conclusion
The complexity and dynamic interaction of software components provide chal- lenging research issues in large system design and verification. In this paper we investigate the integration between hidden algebra and CCS, using a new specification technique called hiddenCCS. The way we combine process al- gebra CCS used for interaction aspects with hidden algebra used for objects descriptions allows to take advantage of both approaches: high abstraction level, expressiveness, and verification tools. To summarize, in hiddenCCS we use hidden algebra to specify concurrent objects, and CCS to coordinate them by their synchronization and communication elements. A hiddenCCS speci- fication is a triple (B, P, IC) consisting of an object specification B given in hidden algebra, a CCS description P of the coordinating module, and a set IC of integration consistency requirements. The semantics of hiddenCCS specifi- cations is given by a labeled transition system defined over configurations of form (hidden state, CCS process). We investigate how Maude system is able to describe and verify useful properties of the synchronized and communicat- ing concurrent objects. Maude is used to represent the CCS-based semantics of the synchronized concurrent objects. Since CCS, its Hennessy-Milner logic, and linear temporal logic are implemented in Maude, this system is used to represent the hiddenCCS specifications and their semantics, as well as to ver- ify some properties expressed in linear temporal logics. Rewriting logic is


considered as a logical and semantic framework for object-oriented systems and process calculi of communicating concurrent systems.
A further step is to develop a software tool which automatically builds this rewriting logic specification using the reflection property of the rewriting logic.
The object-oriented features of hidden algebra add a new dimension that is missing in other approaches including LOTOS [1], a formalism combining a dynamic part based on CCS and CSP with the algebraic specification language ACT ONE. Another formalism with a high level of abstraction is presented in [15]; it combines CCS with the Common Algebraic Specification Language (CASL). In hiddenCCS we have a clear concern separation that allows a better reuse of the coordination and objects than in [15].

References
T. Bolognesi, and E. Brinksma. Introduction to the ISO Specification Language LOTOS. In P.H.J.van Eijk, C.A.Vissers, and M.Diaz (Eds.), The Formal Description Technique LOTOS,
pp. 23-73, Elsevier, 1989.
G. Ciobanu, and D. Lucanu. Specification and Verification of Synchronizing Concurrent Objects. In E.Boiten, J.Derrick, and G.Smith (Eds.) IFM 2004, Lecture Notes in Computer Science vol.2999, pp. 307-327, Springer, 2004.
E.M. Clarke, O. Grumberg, and D.A. Peled. Model Checking. MIT Press, 2000.
M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and J.F. Quesada. Maude: Specification and Programming in Rewriting Logic. Theoretical Computer Science, vol.285(2), pp. 187-243, Elsevier, 2002.
R. Cleaveland, J. Parrow, and B. Steffen. The Concurrency Workbench: a semantics-based tool for the verification of concurrent systems. In ACM Transactions on Programming Languages and Systems, vol.15(1), ACM Press, pp. 36-72, 1993.
S. Eker, J. Meseguer, and A. Sridharanarayanan. The Maude LTL Model Checker. In 4th WRLA, Electronic Notes in Theoretical Computer Science, vol.71, Elsevier, 2002.
J. Goguen, K. Lin, and G. Ro¸su. Circular Coinductive Rewriting. In Proc. Automated Software Engineering, IEEE Press, pp.123-131, 2000.
J. Goguen, and G. Malcolm. A hidden agenda. Theoretical Computer Science vol.245(1), pp.55-101, 2000.
D. Lucanu, and G. Ciobanu. Model Checking for Object Specifications in Hidden Algebra. In B.Steffen, G.Levi (Eds.) Veriﬁcation, Model Checking, and Abstract Interpretation, Lecture Notes in Computer Science vol.2937, Springer, pp.97-109, 2004.
J.  Meseguer,  M.  Palomino,  and  N.  Mart´ı-Oliet.    Equational  Abstractions.
http://maude.cs.uiuc.edu/papers, submitted for publication, 2003.
J. Meseguer, and G. Ro¸su. Behavioral Membership Equational Logic. Electronic Notes in Theoretical Computer Science, vol.65, Elsevier, 2002.
R. Milner. Communication and Concurrency. Prentice Hall, 1989.
R. Milner. Communicating and Mobile Systems: the π-calculus. Cambridge University Press, 1999.
G. Ro¸su. Hidden Logic. PhD Thesis, Univ. California at San Diego, 2000.


G. Salau¨n, M. Allemand, and C. Attiogb´e. A Formalism Combining CCS and CASL. Research Report 00.14, IRIN, Univ. Nantes, 2001.
A. Verdejo, and N. Mart´ı-Oliet. Implementing CCS in Maude 2. In 4th WRLA, Electronic Notes in Theoretical Computer Science, vol.71, Elsevier, 2002.
