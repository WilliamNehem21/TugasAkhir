

Electronic Notes in Theoretical Computer Science 219 (2008) 67–82
www.elsevier.com/locate/entcs

A Rewriting Calculus for Multigraphs with Ports
Oana Andrei1 and H´el`ene Kirchner2
INRIA & LORIA 3

Abstract
In this paper, we define labeled multigraphs with ports, a graph model which specifies connection points for nodes and allows multiple edges and loops. The dynamic evolution of these structures is expressed with multigraph rewrite rules and a multigraph rewriting relation. Then we encode the multigraphs and multigraph rewriting using algebraic terms and term rewriting to provide an operational semantics of the multigraph rewriting relation. This term version can be embedded in the rewriting calculus, thus defining for labeled multigraph transformations a high-level pattern calculus, called ρmg -calculus.
Keywords: Multigraphs with ports, multigraph rewriting, term rewriting, rewriting calculus.


Introduction
Graphs are high-level constructs widely used for describing complex structures, like communication networks, neural networks, UML diagrams, microprocessor design, XML documents, biological systems. Graph transformation provides a rule-based modeling of their dynamic evolution. Different approaches have been proposed to formalize graph transformation and to define graph rewriting, summarized for instance in [18].
We have explored graph models for simulating chemical reactors [8,1] and pro- tein interactions [3]. In this context we found the need for graph structures where the nodes have points, called ports, for attaching the edges, thus providing an ex-
plicit partitioning of nodes connectivity. We have identified a quite general class of directed graphs allowing multiple edges and loops, where node information is
represented as node labels, and an edge label is the ordered pair of source port and target port; we call such graphs labeled multigraphs with ports.

1 Email: Oana.Andrei@loria.fr
2 Email: Helene.Kirchner@loria.fr
3 UMR 7503 CNRS-INPL-INRIA-Nancy2-UHP. Campus Scientifique, BP 239, Nancy, France

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.10.035

The concept of port for graphs is not a novelty. It can be seen as a refinement of the connectivity information for nodes. The Graph Markup Language GraphML [9], an XML format for graph structures, backed to the graph drawing community, uses ports in nodes for partitioning incidences. An immediate application of multigraphs with ports is for modeling protein-protein interactions concerned with the connec- tivity inside molecular complexes (see [13] for a process algebra approach, and [7] for an approach based on graph rewriting). Proteins are abstracted as boxes with interaction sites on the surface having particular states. Hence, adding a refinement on the ports and calling them sites with at most one edge attached to each port, the multigraph rewriting and its correspondent rewriting calculus become suitable for modeling the interactions of molecular complexes. We called this variant of multi- graphs with ports used for modeling molecular complexes molecular graphs [3]. In Fig. 1 we illustrate in the middle a reaction pattern that applied on the left molecu- lar graph creates an edge (bond) as we can see in the molecular graph on the right. This example is extracted from a larger example developed in [3] which models the beginning of the epidermal growth factor receptor signaling cascade. The protago- nists of the example are four signal proteins denoted by S with S.S their dimerized form, two receptor proteins R, and one adapter protein A. Sites are represented differently according to their state: filled circles for bound sites, and empty circles for free ones.

Fig. 1. Two molecular graphs related by a complexation reaction

Membranes can also form complexes, called tissues, due to the binding proteins on their surfaces. While on the one side we can model interactions between biochemical entities like proteins, proteins and lipids, or membranes, on the other side we are able to model as well chemical reactions (like the ones in [1]) using the multigraph rewriting: atoms represent the nodes, the covalence of an atom gives the number of identical ports, and chemical bonds between atoms are multiple edges.
The paper is divided in three parts: after giving basic definitions in Sect. 2, we first define in Sect. 3 the labeled multigraphs with ports, multigraph rewrite rules, and the multigraph rewriting relation; second, in Sect. 4, we encode the multigraphs and multigraph rewriting using algebraic terms and term rewriting to provide an operational semantics for the multigraph rewriting relation; and third, in Sect. 5, we embed the term approach on multigraph rewriting in the rewriting calculus obtaining for free a rewriting calculus for labeled multigraphs, called ρmg-calculus. Therefore we provide for the multigraph rewriting a high-level calculus extending

algebraic rewriting allowing us to benefit from the properties of the ρ-calculus, especially the possibility of using rewriting strategies and rule conditions to control rule application. The operational correspondence result stated in Sect. 4 allows us to visually express quite complex multigraph transformations and perform them using term rewriting. In Sect. 6 we give some implementation hints for multigraph rewriting and sketch some extensions and applications for multigraphs with ports.
The proofs of the results stated in this paper are available in [2].

Background
In this section we briefly review some basic definitions of graph theory and graph transformation [12,18] used in this paper. We adopt the classical definitions for order-sorted algebra and term rewriting from [14] and [4,15] respectively.
Labeled Graphs. A label alphabet L = (LV , LE) is a pair of sets of node labels and edge labels. A (finite) graph over L is a triple G = (V, E, s, t, l) where V is a set {v1,..., vk} of elements called nodes (or vertices), E is a set {e1,..., em} of elements of the Cartesian product V × V called edges, s, t : E → V are the source ant target functions respectively, and l = (lV , lE) is the labeling function for nodes
(lV : V → LV ) and edges (lE : E → LE). If G is a graph, we usually denote by VG its node set and by EG its edge set. An edge of the form (v, v) is called a loop. For an edge (u, v), u and v are called end nodes with u the source and v the target; moreover we say that u and v are adjacent or neighbouring nodes, with v neighbour of u. An edge is incident to a node if the node is one of its end nodes. An edge is multiple if there is another edge with the same source and target; otherwise it is simple. A multigraph is a graph allowing multiple edges and loops. An adjacency list
for a node is given by a list of pairs consisting of a neighbour and the corresponding edge label. If a node has no neighbour then its adjacency list is empty. A subgraph of a graph G is a graph whose node and edge sets are subsets of those of G. A graph
morphism assigns the nodes and edges of a given graph to the nodes and edges of another graph while preserving adjacency. In the case of labeled graphs, the node and edge labeling is also preserved.
Graph Transformation. A graph transformation rule L ~ R consists of two graphs L and R called the left- and right-hand side respectively, and a correspon- dence between elements of the left-hand side and elements of the right-hand side. This correspondence is provided by some unique identifiers associated to nodes.
As presented in [18], the application of a graph transformation rule L ~ R to a graph G, called host graph, produces a new graph G' according to the following steps:
Find a matching morphism m for L in G (hence m(L) is a subgraph of G).
Remove the subgraph m(L) from G resulting in the context graph G−.
Add m(R) to the context graph G−.
Reconnect m(R) and G−.
The differences between various approaches for graph replacement arise mainly

in the last step, depending on the mechanism chosen for establishing connec- tions between new and old nodes. Two particular problems are handled at this stage ([12,18]). The first one refers to whether or not noninjective matching is al- lowed. For example, if two different nodes L are matched to one node in the host graph, and one of the two nodes is deleted and the other preserved, will the node in the host graph be deleted or preserved? The second problem concerns the dan- gling edges in the host graph which are unmatched edges with one endpoint deleted by the transformation rule. These two problematic situations are referred to as the identification and the dangling problem respectively. We will see later how we handle these points in our framework.
Labeled Multigraphs with Ports
We refine the definition of multigraphs by typing nodes with names and by adding explicit connection points, called ports, to nodes; then edges attach, more specifi- cally, to ports of nodes. Let P be a finite set of ports and N a finite set of node names.
Definition 3.1 A labeled multigraph with ports over N , P takes the form G = (V, E, ι, s, t, l) where:
V is a finite set of nodes (also referred to as node identifiers);
ι = (ι1, ι2) : V → N × P(P) assigns a name and a port set to each node, with
ι1(v) = n and ι2(v) = P for ι(v) = (n, P );
E ⊆ {(v-p, u-r) ∈ (V × P )2 | p ∈ ι2(v),r ∈ ι2(u)} a finite multiset of edges;
s, t : E → V × P the usual source and target functions;
l = (lV , lE) is the labeling function associating to each node v ∈ V the triple consisting of the identifier, the name, and the port set, lV (v) = ⟨v : ι1(v) || ι2(v)⟩, and to each edge (v-p, u-r) ∈ E the couple formed by the source port and the target port, lE((v-p, u-r)) = (p, r).
Hereinafter we say (labeled) multigraph instead of labeled multigraph with ports if there is no risk of confusion. Let P = {a, b, c, . . .} and N = {A, B, C,.. .} the sets of constants denoting ports and names respectively. We consider variables ports and names as well, denoted by XP = {x, y, z,.. .} and XN = {X, Y, Z, .. .} respectively. We represent the node identifiers by non-empty sequences of integers. We denote by Var(G) the set of variables occurring in G. In Fig. 2 we illustrate two views of a multigraphs with ports: on the left, we use the classical drawing of a labeled multigraph, while on the right, we emphasize the ports. We will use the latter more suggestive representation for multigraphs by representing a node as a box with the identifier and the name placed outside the box and a port as a small point on the surface of the box.
Graph transformation rules are instantiated in this context.
Definition 3.2 (Multigraph rewrite rule) A multigraph rewrite rule is an or- dered pair of multigraphs over N ∪ XN , P ∪XP denoted by L ~ R, where all node



Fig. 2. Two views of a labeled multigraph with ports
identifiers in L are variables, and such that Var(L) ⊇ Var(R). The multigraphs L
and R are called the left- and right-hand side of the rule respectively.
Definition 3.3 (Node-substitution) The correspondence between nodes of the left- and right-hand side of a multigraph rewrite rule L ~ R is a mapping ξ : VL → P(VR) that we call node-substitution. It associates to each node v in L a (possibly empty) set of nodes in R. In practice, it associates to each node v in L the set of all nodes in R whose identifiers contain v; if v is deleted then it does not occur in the node identifiers in R and ξ(v) = ∅.
Given the definition above, we assume that for each multigraph rewrite rule we can automatically extract from the node identifiers the node-substitution.
Example 3.4 We illustrate in Fig. 3 four multigraph transformation rules: (a) splitting a node with ξ(i) = {i.1, i.2}, ξ(j) = {j}; (b) deleting a node with ξ(i) = ∅, ξ(j) = {j}; (c) deleting two edges with ξ(v) = {v} for each node v; (d) merging two nodes ξ(i) = ξ(j) = {i.j}.

Fig. 3. Multigraph rewrite rules
We call a partial node of a node v with ι(v) = (n, P ) a node with the same identifier, the same name, and a non-empty subset of P as the port set.
Let L ~ R be a multigraph rewrite rule applied to the multigraph G with ξ the associated node-substitution. Then a matching morphism m for L in G assigns the nodes of L to partial nodes of G while preserving adjacency. Each matched node v ∈ VG with some unmatched ports can be partitioned into a matched partial node containing the matched ports (hence it occurs in m(L)), and an unmatched partial node containing the unmatched ports. A constant name can be mapped by a multigraph morphism only to itself.
The delicate point of applying L ~ R to G is to properly define the replacement of m(L) by m(R) in G and the way m(R) is reconnected with G.  Let us first




=


G	G	G' ?

Fig. 4. A graph replacement sketch

illustrate graphically in Fig. 4 the replacement procedure: the first graph is G where the area with the dashed border represents m(L); the second graph is also G but where we emphasize the edges (that we call bridges) connecting unmatched nodes to matched nodes; and the third graph represents the result of replacing the subgraph m(L) by m(R) and we see that some bridges are pending if their targets formerly in m(L) no longer occur in m(R). The step of reconnecting identifies the old end node of the bridges from m(L) with their correspondent nodes from m(R) given by ξ(m). The same operation must be performed as well on the unmatched edges and unmatched partial nodes. Then, the result of the multigraph rewriting of G consists of putting together the context multigraph G−, m(R), and the updated unmatched edges and partial nodes, and bridges using ξ(m). The unmatched partial nodes have to be updated first, since they can be end points for unmatched edges or bridges.
The context multigraph G− =  G \ m(L) is given by the set of nodes
Vt− = Vt \ Vm(L), and the set of edges Et− = {(u-p, v-r) ∈ Et | u, v ∈ Vt− }.
We denote by Un the set of unmatched partial nodes, by Ue the set of unmatched edges (i.e., the not matched edges whose both endpoints are matched), and by B the set of bridges (i.e., the edges in G not matched by an edge of L, with one end a matched node and the other end not matched).
If v ∈ Un and ξ(v) = {v1,..., vk} then, for each k-partition (P1,..., Pk) of the port set ι2(v), we have m(ξ)(v) = {m(v1),..., m(vk)} with ι2(vi) = Pi. The applica- tion of m(ξ) on a set of edges E is defined component-wise, and m(ξ)((u-p, v-r)) =
{(u-p, v-r) | uk ∈ m(ξ)(u) s.t. p ∈ ι2(uk) and vL ∈ m(ξ)(v) s.t. r ∈ ι2(vL)}.
k	L
By analogy with term rewriting, we can write G = G−[m(L)]U ,U ,B, as a de-
n  e
composition of G into the context graph G−, the matched subgraph m(L), the un- matched partial nodes Un, the unmatched edges Ue, and the bridges B. Then, once m(R) is computed, it is replaced in the context multigraph G− and the bridges are reconnected, thanks to m(ξ)(Un), m(ξ)(Ue), and m(ξ)(B), to get a resulting
multigraph G−[m(R)]m(ξ)(U ),m(ξ)(U ),m(ξ)(B).
n	e
We are now able to formulate the definition of multigraph rewriting.
Definition 3.5 (Multigraph rewriting relation) Given a multigraph rewrite system R, a multigraph G rewrites to a multigraph G', denoted by G ~R G', if there exists:
a multigraph rewrite rule L ~ R in R,
a multigraph morphism m such that m(L) is a subgraph of G,
a set of unmatched partial nodes Un, a set of unmatched edges Ue, and a set of




G	r






I	G'





Fig. 5. An application of the multigraph rewrite rule r on t resulting in the multigraph t' with an intermediate multigraph I

bridges B,
such that G = G−[m(L)]U ,U ,B and G' = G−[m(R)]m(ξ)(U ),m(ξ)(U ),m(ξ)(B).
With respect to the discussion at the end of Section 2 concerning the identifi- cation and the dangling problems, the particularities of labeled multigraphs with ports transformations are first, that we consider only injective matching morphism, second, that when deleting a node, all its incident edges are deleted as well.
Example 3.6 We illustrate in Fig. 5 a multigraph resulting from rewriting G (also given in Fig. 2) using the rule r (also given in Fig. 3 (a)). The resulting multigraph G' is obtained by splitting the node 1, choosing to place the unmatched port c in 1.2, and then redirecting the two bridges (4-d, 1-c) and (1-b, 3-a) to 1.2. In the intermediate step we emphasize the incidence of the node 4 to the unmatched partial node 1 with the the port set {c}. The node-substitution may identify this partial node to either of the two resulting nodes 1.1 and 1.2. Therefore two solutions are possible: the one illustrated in Fig. 5, and the other one where c is placed in the node 1.1.
In order to define multigraph rewriting in a more operational way, we choose to go in the world of algebraic terms and term rewrite rules and to benefit from a classical ACU-matching algorithm for the application of rewrite rules, where ACU stands for associative-commutative with neutral element.

Term Rewriting Semantics for Multigraph Rewriting
In this section we define an encoding function E for multigraphs, multigraph rewrite rules, and multigraph rewrite relation as particular terms, term rewrite rules, and term rewriting relation respectively.
Concerning the problem of dangling edges, instead of mapping a node from the



: −→ Id	• : −→ Port	• : −→ Node	ϵX : −→ XSet
,	: XSet XSet −→ XSet [ACU (ϵX)]
⟨ :	|| ⟩ : Id Name PortSet −→ Node
( , )	: Port Port −→ Edge
-	: Id EdgeSet −→ Neighbour
	: Id NeighbourSet −→ AdjacencyEq
Q ¢	: NodeSet AdjacencyEqSet −→ MGraph

Fig. 6. The operation set F

left-hand side to an empty set of nodes from the right-hand side, we introduce a special node • called the black hole. Consequently, we replace a deleted node in an intermediate step by a black hole whose behaviour consists in deleting itself along with the incident edges. In a similar way we use the black hole to replace in an intermediary step a deleted port as well. Hence, the dangling edges are deleted using some particular intermediate and transparent operation as we will see later in this section.
We define an order-sorted signature Σ = (S, <, F) for encoding multigraphs, where, in order to eliminate redundancies, we represent a multigraph as a pair made of the set of node labels and the set of adjacency lists (for each node we list its neighbours with the corresponding edges as pairs of ports):
the sort set S consists of sorts for each component or set of components: Id , Name, Port , Node, Edge, Neighbour , AdjacencyEq , PortSet , NodeSet , EdgeSet , NeighbourSet , AdjacencyEqSet , MGraph.
the subsort relation is defined by X < XSet for X ∈ {Port , Node, Edge, Neighbour, AdjacencyEq, MGraph}, i.e.  each term of sort X can be seen as
a set with a single element.
the operation set F allowing to describe the graph structure, is given in Fig. 6 where X takes sort values from the set {Node, Edge, Neighbour , AdjacencyEq}.
The associative-commutative operator ,	(union) is overloaded on each of the set sorts, and ϵX denotes the identity element (the empty set) for the operation
,  . We use ϵ instead of ϵX whenever the sort X can be easily deduced from the
context. The constant operator • is overloaded as well, it can be an Id -, a Port -
or a Node-sorted term.
Let X be an (S, <)-sorted family of variables.
Definition 4.1 (Encoding multigraphs as terms) We encode a labeled multi- graph G = (V, E) as an algebraic term E (G) = T1QT2¢ of sort MGraph where:
T1 ∈ TΣ,NodeSet (X ) is the set of all node labels in G, and
T2 ∈ TΣ,AdjacencyEqSet (X ) is the set of adjacency equations providing the neigh- bours for each node in V (if any) and the pairs of ports corresponding to the incident edges.

Additionally, algebraic terms encoding multigraphs must satisfy some structural properties in order to be considered well-formed.
Definition 4.2 (Well-formed terms) A term t ∈ TΣ,MGraph (X ) is well-formed if
(i) each node identifier occurs at most once: in the node set, in the adjacency equation set as left-hand side of an adjacency equation, in the neighbour set of a node identifier, (ii) each node identifier or port occurring in the adjacency equation set must also occur in the node set.
We also impose a canonical form (a representative of each equivalence class modulo ACU) for the terms encoding multigraphs, in order to eliminate useless information as follows:
Definition 4.3 (Canonical form) A term t ∈ TΣ,MGraph (X ) is in canonical form if:
right-hand sides of adjacency equations are non-empty sets of neighbours;
only non-empty set of edges occur in neighbour terms.
Example 4.4 The multigraph G illustrated in Fig. 2 is encoded as the following term: E (G) = (⟨1 : A || a, b, c⟩, ⟨2 : B || e⟩, ⟨3 : A || a, b, c⟩, ⟨4 : C || d⟩)Q 1 (2-(a, e), (b, e)), (3-(b, a))), (3  4-(a, d)), (4  1-(d, c)) ¢ .
For all rewrite rules over TΣ,MGraph (X ), according to Definition 3.2, we impose node identifiers occurring in the left-hand side to be variables. We say that a rewrite rule over TΣ,MGraph (X ) is well-formed (in canonical form) if both t1 and t2 are well- formed (in canonical form respectively). We call mg-rewrite rule a well-formed rewrite rule in canonical form.
Definition 4.5 (Encoding multigraph rewrite rules as term rewrite rules) Given a labeled multigraph rewrite rule L ~ R, we encode it as a term rewrite rule E (L ~ R) = E (L) d E (R).
The encoding of a multigraph rewrite rule is an mg-rewrite rule since, by defi- nition, the term encoding a multigraph is well-formed and in canonical form.
The node-substitution from nodes of the left-hand side to nodes of the right- hand side of an mg-rewrite rule can be extracted automatically by means of an analysis on the identifier occurrences. We call this procedure GetMap; it produces a set of elementary mappings (or elementary node-substitutions) from TΣ,Node(X ) to TΣ,NodeSet (X ) for each node occurring in the left-hand side of the rule. Identity mappings are usually omitted. Note that the node-substitution for a multigraph rewrite rule is encoded as in the following example.
Example 4.6 The encoding of the multigraph rewrite rule (a) given in Fig. 3 is: (⟨i : X || x, z⟩, ⟨j : Y || y⟩)Qi j-(x, y), (z, y)¢ d 
(⟨i.1 : X.1 || x⟩, ⟨i.2 : X.2 || z⟩, ⟨j : Y || y⟩)Q(i.1  j-(x, y)), (i.2  j-(z, y))¢
with the node-substitution ξ = {⟨i : X || x, z⟩ '→ (⟨i.1 : X.1 || x⟩, ⟨i.2 : X.2 || z⟩)),
⟨j : Y || y⟩ '→ ⟨j : Y || y⟩}.

After encoding multigraphs and their transformation rules, we now translate multigraph rewriting into term rewriting.
In a first step we customize the rewrite rules on TMGraph (X ) before applying
them. In order to model multigraph rewriting using algebraic terms, we need to handle the context of the multigraph in which the replacement is performed. This is done by a systematic enrichment of rewrite rules with extension variables that help storing the context and applying rewrite steps in subterms. This is a usual method employed when performing rewriting modulo associativity and commutativity [16].
We usually denote by W an extension variable and by t the extension of term t. For each rewrite rule t1 d t2, extension variables are appended to set-sorted terms to produce the extended rule (t1 d t2). An extension variable is added to each
set-sorted subterm in the left-hand side (and accordingly in the right-hand side). This technical construction is formalised in [2]. We just give here an example of rule extension.
Example 4.7 The extension of the rule given in Example 4.6 is:
(⟨i : X || x, z, Wp,Wp⟩, ⟨j : Y || y, Wp⟩,Wn)Q(i  (j-((x, y), (z, y),We)),Wh),Wa¢ d 
1	2	3	4	5	6	7
(⟨i.1 : X.1 || x, Wp⟩, ⟨i.2 : X.2 || z, Wp⟩, ⟨j : Y || y, Wp⟩,Wn)Q(i.1  j-(x, y)),
1	2	3	4
(i.2  j-(z, y)), (i  (j-We),Wh),Wa¢
5	6	7
with the node-substitution ξ = (⟨i : X || x, z, Wp,Wp⟩) '→ ⟨i.1 : X.1 || x, Wp⟩, ⟨i.2 : 
p	p	1	2	1
p
X.2 || z, W2 ⟩), (⟨j : Y || y, W3 ⟩) '→ {⟨j : Y || y, W ⟩) where the extension variables Wi
have appropriate set sorts. The exponents used for the extension variables indicate their set sort: p for PortSet , n for NodeSet , e for EdgeSet , h for NeighbourSet , a for AdjacencyEqSet .


Instantiation of a node-substitution
Let σ be a substitution and ξ a node-substitution. We denote by ξσ the instantia- tion by σ of variables occurring in ξ computed component-wise: {t '→ t1,..., tk}σ =
{σ(t) '→ σ(t1),..., σ(tk)}.


Node-substitution application
The application of a node-substitution ξ on a term consists in applying sequen- tially each elementary node-substitution of ξ on the term; this is illustrated in Fig. 7. An elementary node-substitution is propagated inside an MGraph-sorted term using (Propagate), inside the set of adjacency equations of neighbours using (Distribute), and then applied on each of them. The application of a node-substitution on an adjacency equation using (ApplySrc) (or a neighbour using (ApplyTar)) transforms it in n adjacency equations (resp. neighbours), one for each corresponding node in the right-hand side of the mapping, and propagates the node-substitution application on the set of neighbours. We illustrate this operation in Example 4.10.
After applying a node-substitution, the MGraph-terms may be neither well- formed, nor in canonical form, hence they require some cleaning and restructuring operations.



(Propagate) {t '→ T}N QA¢ e⇒= N Q{t ~ T}A¢
(Distribute) {t '→ T}(S1,..., Sk) e⇒= {t '→ T}S1,..., {t1 '→ t2}Sk
(ApplySrc) {t '→ t1,..., tn}(i  V ) e⇒=
if id(t) /= i then i  ({t '→ t1,..., tn}V )
else id(t1)  ({t '→ t1,..., tn}V ),..., id(tn)  ({t '→ t1,..., tn}V ) (ApplyTar) {t '→ t1,..., tn}(i-E) e⇒=
if id(t) /= i then i-E else id(t1)-E, ..., id(tn)-E

Fig. 7. Node-substitution application

u, v : Id, t1, t2 : NeighbourSet, t3, t4 : EdgeSet, p, r : Port
(c1) •  t1 → ϵAdjacencyEq
(c2) •-t3 → ϵNeighbour
(c3) (v  t1, (u-t3, (p, r), t4), t2) → (v  t1, (u-t3, t4), t2)
if p ∈/ ports(v) or r ∈/ ports(u)





Cleaning
Fig. 8. Cleaning rules C

Let C be the rewrite system defined by the cleaning rules presented in Fig. 8 which transform terms with respect the condition of well-formedness of MGraph- sorted terms specified in Definition 4.2 as follows: (c1) deletes the adjacency equa- tions for black holes; (c2) deletes the black hole neighbours; (c3) handles the removal of extra-edges (edges whose endpoints do not appear among the ports of the con- nected nodes).
The extra-edges appear as a consequence of the application of the node- substitution according to (ApplySrc) and (ApplyTar) on adjacency equations and neighbours respectively, without checking the connectivity between the new nodes. An illustration of the cleaning operation can be found in Example 4.10.

Restructuring
Let R be the rewrite system defined by the rules presented in Fig. 9, which transforms terms in the canonical form specified by Definition 4.3 as follows: (r1) merges nodes having the same identifier into one node by merging their port sets; (r2) deletes a neighbour with empty set of edges; (r3) merges the associated sets of edges for identical neighbours; (r4) deletes adjacency equations with empty set of neighbours; (r5) merges adjacency equations having the same identifier in the first component into one adjacency equation by merging the sets in the second component.



v : Id, n : Name, t1, t2 : PortSet, t3, t4 : NeighbourSet, t5, t6 : EdgeSet
(r1) ⟨v : n || t1⟩, ⟨v : n || t2⟩ → ⟨v : n || t1, t2⟩
(r2) v-ϵEdge → ϵNeighbour
(r3) (v-t5), (v-t6) → v-t5, t6 (r4) v ϵNeighbour → ϵAdjacencyEq (r5) (v  t3), (v  t4) → v  t3, t4
Fig. 9. Restructuring rules R

It is not difficult to prove (see [2]) that:
Proposition 4.8 C and R are strongly terminating and confluent.
We denote by t↓C and t↓R the normal forms of a term t w.r.t. the rewrite rules in C and R respectively. By Prop. 4.8 such normal forms exist and are unique.
We are now ready to define the mg-rewriting relation. Operationally, we apply extended rewrite rules, which allows us to deal only with rule application at the root position of terms.
Definition 4.9 (mg-rewriting relation) A term t of sort MGraph rewrites to a term t' using an mg-rewrite rule r : t1 d t2 where t1, t2 ∈ TΣ,MGraph (X ) with r :
t d t and ξ = GetMap(r), which is denoted by	r	', if there exists a substitution
1	2		t d t
σ, a solution of the ACU-matching problem t1  t, such that t' = ξσ(σ(t2)) ↓C↓R. We call this relation mg-rewriting and we say that t mg-rewrites to t' by r.
Example 4.10 We present here a solution of mg-rewriting the term t = E (G) from Example 4.4 encoding the multigraph from Fig. 2, using the rewrite rule t1 d t2 given in Example 4.6 and extended in Example 4.7 which encodes the multigraph rewrite rule (a) from Fig. 3. This mg-rewriting corresponds to the multigraph rewriting depicted in Fig. 5.
one solution of the matching problem t1   t is given by the substitution
σ = {i '→ 1, X '→ A, x '→ a, z '→ b, j '→ 2, Y '→ B, y '→ e, Wp '→
1
p	p	n	e
ϵ, W2 '→ c, W3 '→ ϵ, W4 '→ (⟨3 : A || a, b, c⟩, ⟨4 : C || d⟩), W5 '→ ϵ, Wh '→
3-(b, a), Wa '→ ((3  4-(a, d)), (4  1-(d, c))}
σ(t2) = (⟨1.1 : A.1 || a, ⟩, ⟨1.2 : A.2 || b, c⟩, ⟨2 : B || e⟩, ⟨3 : A || a, b, c⟩, ⟨4 :
C || d⟩)Q 1.1  (2-(a, e)), 1.2  (2-(b, e)), (3-(b, a)), (3  4-(a, d)), (4 
1-(d, c)) ¢ and we note the occurrence of the node identifier 1 in the adjacency equation set which is no longer a valid node identifier in this term;
ξσ = (⟨1 : A || a, b, c⟩) '→ ⟨1.1 : A.1 || a⟩, ⟨2.2 : A.2 || b, c⟩), (⟨2 : B || e⟩) '→ {⟨2 : 
B || e⟩)
ξσ(σ(t2)) e⇒=+ (⟨1.1 : A.1 || a, ⟩, ⟨1.2 : A.2 || b, c⟩, ⟨2 : B || e⟩, ⟨3 : A || a, b, c⟩, ⟨4 : 
C || d⟩)Q 1.1  (2-(a, e)), 1.2  (2-(b, e)), (3-(b, a)), (3  4-(a, d)), (4 
1.1-(d, c), 1.2-(d, c)) ¢ by applying at the end the rule (ApplyTar) on 4 

1-(d, c);
ξσ(σ(t2)) ↓C= (⟨1.1 : A.1 || a, ⟩, ⟨1.2 : A.2 || b, c⟩, ⟨2 : B || e⟩, ⟨3 : A || a, b, c⟩, ⟨4 : 
C || d⟩)Q 1.1  (2-(a, e)), 1.2  (2-(b, e)), (3-(b, a)), (3  4-(a, d)), (4 
1.2-(d, c)) ¢ using the reduction 4  1.1-(d, c), 1.2-(d, c) (ExtraEdges) 4 
1.2-(d, c) since c does not occur in the port set of the node identified by 1.1, but occurs in the port set of the node identified by 1.2;
ξσ(σ(t2)) ↓C↓R= ξσ(σ(t2)) ↓C since no restructuring rule is applied.
The  above  solution  σ  of  the  matching  problem  leads  to  the  result  term
ξσ(σ(t2)) ↓C↓R which in fact is the encoding of the multigraph G' in Fig. 5.

Proposition 4.11 If t mg-rewrites to t' and t is a well-formed term in canonical form then t' is well-formed and in canonical form.
Theorem 4.12 (Operational correspondence)
Let G, G' be two multigraphs, r a multigraph rewrite rule and m a multigraph
morphism such that G ~r  G' using m. Then there exists a substitution σ and a term
E (r)
t' such that E (G) −d t' using the substitution σ and t' = E (G').
Let G be multigraph, t = E (G), t1 d t2 an mg-rewrite rule, and t' such that



t1dt2
t −d t'
with σ the solution of the matching t1  t used in the rewriting. Then

there exist (i) a multigraph rewrite rule r satisfying E (r) = t1 d t2, (ii) a multigraph morphism that can be constructed using σ and the structures of t and G, and (iii)
a multigraph G' such that G ~r G' using the matching morphism m and E (G') = t'.

G  ¸¸˛¸˛¸˛r¸˛¸˛¸˛¸˛¸˛ G˛ '
E (G) = t 	t1dt2	 t' 

m
E	E
J	E (r)	J 
,,	σ	,,
E	E
∃r s.t. E (r)=t1dt2

E (G) = t
∃σ	 ∃t '
¸¸˛¸˛¸˛¸˛¸˛¸˛¸˛¸˛¸˛¸˛¸˛¸˛ ˛ '
∃m


There is also a correspondence between all possible results of rewriting a multi- graph G using a rule G1 ~ G2 and a morphism m, and possible results of rewriting t = E (G) using t1 d t2 = E (G1 ~ G2) since all solutions of the matching t1  t have as common basis the encoding of m, but different mappings for the extension variables. Hence, while the application for multigraphs of the node-substitution on unmatched partial nodes produces k results, the application of node-substitution for a term produces a term and the k solutions arise from different solutions of the ACU-matching problem with the extension variables.


A Multigraph Rewriting Calculus
After a short overview of the rewriting calculus (or ρ-calculus), the embedding of mg-rewriting in the rewriting calculus is presented, resulting in a multigraph term rewriting calculus.

The Rewriting Calculus
The rewriting calculus (or ρ-calculus) [10] extends first-order term rewriting and λ-calculus. From the λ-calculus, the ρ-calculus inherits its higher-order capabilities and the explicit treatment of functions and their applications. It was introduced to make all the basic ingredients of rewriting explicit objects, in particular the notions of rewrite rule (or abstraction) “ d ”, rule application “”, and set of results “ ”. In the ρ-calculus, the usual λ-abstraction λx.t is replaced by a rule abstraction T1 d T2, where T1 and T2 are two arbitrary terms, and the free variables of T1 are bound in T2.
The syntax is defined in Fig. 10 with X the set of variables and K the set of function symbols. The operator “ ” groups terms together into structures, and, depending on the chosen theory for this operator, it provides lists, sets or multisets to represent multiple results.

Terms	T ::= X | K | P d T | T T | T  T
Patterns	P ⊆ T

Fig. 10. The syntax of ρ-calculus

The small-step reduction semantics of the ρ-calculus is defined by the two eval- uation rules in Fig. 11. If the matching problem p  t3 has a solution σ, then the application of the rewrite rule to t3 evaluates to σ(t2). The set of patterns is not a priori fixed, and the matching power of the ρ-calculus can be regulated using arbitrary theories. Therefore the semantics of the calculus depends essentially on those parameters.

(ρ)	(p d t2)t3	→ρ	σ1(t2) ... σn(t2)	with σi ∈ Sol(p  t3)
(δ)	(t1 t2)t3	→δ	t1t3  t2t3

Fig. 11. The semantics of ρ-calculus

An important feature of the ρ-calculus is its capability of encoding rewrite strate- gies as shown in [11]. The basic strategies are the rewrite rules. An immediate application of the use of rewrite strategies in the ρ-calculus is the encoding of con- ditional rewriting [10]. The ρ-calculus has been proved confluent for linear algebraic patterns [10].

Embedding mg-Rewriting into Rewriting Calculus
Relying on the encoding of multigraph rewriting, we can now encode the mg- rewriting in the ρ-calculus as follows:
take for K the operation symbols in F with the partial ordered set of sorts (S, <) and for X an (S, <)-sorted family of variables;
consider as patterns well-formed terms in canonical form in TΣ,MGraph (X );

consider only rewrite rules whose both sides are patterns.
We benefit in addition of the structure operator which allows grouping rules or results of applications.
As for the semantics, while (δ) dealing with the distributivity of the application over structures is taken as such from the ρ-calculus, we need a new rule for the application of a rewrite rule t1 d t2 on a well-formed term t3 in canonical form as
follows:
(ρmg)(t1 d t2) t3 →ρ S(ς1(t2)) ... S(ςn(t2))	, 
if σi ∈ Sol(t1  t3),ξ = GetMap(t1 d t2), ςi = σi ◦ ξσi

where t1 d t2 is the extended rule associated to t1 d t2, the matching problem is solved using an ACU-matching algorithm, and S is a strategy which reduces a term to its normal form w.r.t. the cleaning and restructuring rules respectively.
We obtain this way a rewriting calculus for labeled multigraphs with ports, which is an instance of ρ-calculus, and we call it the ρmg-calculus.
Conclusion
An implementation for the multigraphs with ports is currently developed in TOM 1 [6] using pointers for the termgraph implementation [5] which handles cyclic termgraphs as well. We use a more efficient encoding for programming by repre- senting a multigraph by its node set and each edge by a pointer to the target port associated to the source port. The use of pointers and TOM’s maximal sharing is very important in order to cope with computer representation of large terms.
The generality of the notion of multigraph with ports allows expressing different types of multigraphs, from simple graphs to multigraphs with ports with states. For further applications, an interesting research direction is to enhance multigraphs with ports with a hierarchical node structure describing nested nodes, and to relate them to Milner’s bigraphs [17].

References
Andrei, O., L. Ibanescu and H. Kirchner, Non-intrusive Formal Methods and Strategic Rewriting for a Chemical Application, in: K. Futatsugi, J.-P. Jouannaud and J. Meseguer, editors, Algebra, Meaning, and Computation, Essays Dedicated to Joseph A. Goguen on the Occasion of His 65th Birthday, LNCS 4060 (2006), pp. 194–215.
Andrei, O. and H. Kirchner, A Rewriting Calculus for Labeled Multigraphs with Ports, Long version available at http://hal.inria.fr/inria-00139363/en/.
Andrei, O. and H. Kirchner, Rewrite Rules and Strategies for Molecular Graphs, Submitted, May 2007.
Baader, F. and T. Nipkow, “Term Rewriting and All That”, Cambridge University Press, 1998.
Balland, E. and P. Brauner, Term-graph rewriting in Tom using relative positions, in: Pre-proceedings of 4th International Workshop on Computing with Terms and Graphs - TERMGRAPH, 2007.
Balland, E., P. Brauner, R. Kopetz, P.-E. Moreau and A. Reilles, Tom: Piggybacking Rewriting on Java, in: To appear in Proceedings of RTA, 2007.

1 Web page http://tom.loria.fr.


Blinov, M. L., J. Yang, J. R. Faeder and W. S. Hlavacek, Graph theory for rule-based modeling of biochemical networks, in: C. Priami, A. Ing´olfsd´ottir, B. Mishra, and H. R. Nielson, editors, T. Comp. Sys. Biology VII, LNCS 4230 (2006), pp. 89–106.
Bournez, O., L. Ibanescu and H. Kirchner, From Chemical Rules to Term Rewriting, ENTCS 147
(2006), pp. 113–134.
Brandes, U., M. Eiglsperger, I. Herman, M. Himsolt and M. S. Marshall, GraphML Progress Report: Structural Layer Proposal, in: Graph Drawing, LNCS 2265 (2002), pp. 501–512.
Cirstea, H. and C. Kirchner, The rewriting calculus - Part I and II, Logic Journal of the IGPL 9 (2001),
pp. 427—498.
Cirstea, H., C. Kirchner, L. Liquori and B. Wack, Rewrite strategies in the rewriting calculus, ENTCS
86 (2003), pp. 593–624.
Corradini, A., U. Montanari, F. Rossi, H. Ehrig, R. Heckel and M. L¨owe, Algebraic Approaches to Graph Transformation - Part I: Basic Concepts and Double Pushout Approach, in: G. Rozenberg, editor, Handbook of Graph Grammars and Computing by Graph Transformations, Volume 1: Foundations, World Scientific, 1997 pp. 163–246.
Danos, V. and C. Laneve, Formal molecular biology, TCS 325 (2004), pp. 69–110.
Goguen, J. A. and J. Meseguer, Order-Sorted Algebra I: Equational Deduction for Multiple Inheritance, Overloading, Exceptions and Partial Operations, TCS 105 (1992), pp. 217–273.
Kirchner, C. and H. Kirchner, Rewriting, Solving, Proving, Available at http://www.loria.fr/
~ckirchne/=rsp/rsp.pdf.
Kirchner, H. and P.-E. Moreau, Promoting rewriting to a programming language: a compiler for non- deterministic rewrite programs in associative-commutative theories, J. Funct. Program. 11 (2001),
pp. 207–251.
Milner, R., Bigraphical Reactive Systems, in: K. G. Larsen and M. Nielsen, editors, CONCUR’01, LNCS
2154 (2001), pp. 16–35.
Schu¨rr, A., Programmed Graph Replacement Systems, in: G. Rozenberg, editor, Handbook of Graph Grammars and Computing by Graph Transformations, Volume 1: Foundations, World Scientific, 1997
pp. 479–546.
