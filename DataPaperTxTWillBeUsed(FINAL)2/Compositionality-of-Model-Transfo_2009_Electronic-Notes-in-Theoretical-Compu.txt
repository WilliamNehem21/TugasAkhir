

Electronic Notes in Theoretical Computer Science 236 (2009) 5–19
www.elsevier.com/locate/entcs
Compositionality of Model Transformations
D´enes Bisztraya,1 Reiko Heckela,2 Hartmut Ehrigb,3
a Department of Computer Science, University of Leicester, United Kingdom
b Institut fu¨r Softwaretechnik und Theoretische Informatik, Technische Universita¨t Berlin, Germany

Abstract
Model transformations can be used not only for code or platform-specific model generation, but also for denotational semantics definition, e.g. using process algebras as semantics for visual modeling languages. Denotational semantics of programming languages are by definition compositional. In order to enjoy a similar property in the case of model transformations, every component of the source model should be distinguishable in the target model and the mapping compatible with syntactic and semantic composition. Since typed graphs are a natural representation of visual models, model transformations are often described by typed graph transformations. This paper proposes a formal definition of compositionality for mappings from typed graphs to semantic domains. To verify compositionality, syntactic criterion has been established for the implementation of the mappings by graph transformations with negative application conditions.
An example compositional transformation is presented that maps architectural models described in UML component diagrams to CSP.
Keywords: compositionality, graph transformation, category theory, typed graphs, model driven engineering, denotational semantics


Introduction
As a consequence of the widespread use of visual languages, new applications for model transformations arise. Model transformation techniques are not only used for code or platform-specific model generation, but also for software refactoring, defini- tion of semantics, formal verification and even architecture migration purposes [11]. Most of these applications are assumed to preserve the structure of the participant models, i.e. they should be compositional.
Compositionality is a property of model transformations that may be interpreted in two different ways according to [21]. Sequential compositionality is similar to function composition, i.e. given two transformations f : A → B and g : B →
C, it is possible to compose them for a transformation g ◦ f : A → C.  While

1 Email: dab24@mcs.le.ac.uk
2 Email: reiko@mcs.le.ac.uk
3 Email: ehrig@cs.tu-berlin.de

1571-0661/Crown Copyright © 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.03.011

sequential composition is obviously an essential property of any transformation, we are interested in spatial composition.
Spatial composition is similar to the compositionality property of denotational semantics. As for simple mathematical expressions, we assume that the meaning of expression 2 + 5 is determined by the meaning of 2, 5 and the semantics of the + operator, i.e. [[2 + 5]] = [[2]]  [[5]].

Figure 1. Compositional Semantic Mapping

In terms of model transformations, compositionality is presented in Figure 1. A system consisting of components A and B with a connector c is mapped to a semantic domain through transformation sem. The result is a set of semantic expressions sem(A), sem(B) and sem(c) such that their composition represents the semantics of the whole system.
Compositionality is an important property for denotational semantics and thus for model transformations that establish a mapping between existing modelling ar- tifacts and a semantic domain. Without compositionality, the modular specification and verification of model transformations would be impossible.
A typical semantic verification scenario is depicted in Figure 2. A modelling lan- guage (ML) is mapped to a semantic domain (SD) and programming language (PL) code is generated. To verify semantic consistency, a semantics of the programming language has to be defined typically through a mapping PL → SD. The generated source code is semantically correct if the triangle commutes. Although the different model instances are numerous, they are composed from the basic elements (BE) of the modelling language. In case of compositional transformations the mapping can be described in terms of the basic building blocks, enabling the modular verification of various semantic properties.
Models and denotational semantics can be represented as instances of meta- models. A mathematical model is provided by type and instance graphs. Model transformations can be described by graph transformations. In this paper we present a notion of compositionality for any total functions defined by graph transforma- tions between sets of graphs (representing models). Conditions are also provided and proved which guarantee compositionality for simple graph transformations and graph transformations with negative application conditions.


BE	⊆
ML 	z P L 

=
zJ 
SD
Figure 2. Semantic Verification

The paper is organised as follows. In Section 2 related approaches are sum- marised. Compositionality is formally introduced in Section 3. In Section 4 a con- dition for compositionality is given for simple graph transformations, generalised to graph transformations with negative application conditions in Section 5. In Sec- tion 6 a case study of compositional model transformations is introduced. Section 7 concludes the paper.

Related Work
Several contributions have been published on the verification of graph transforma- tions.
To ensure uniqueness of results the concepts of confluence and critical pair anal- ysis were presented in [12]. A working implementation can be found in AGG [1] for checking critical pairs [5]. Criteria for termination were introduced in [6,17]. An implementation for termination checking is also provided in AGG [4]. These def- initions are applied to graph transformations with basic control conditions in [14] through the introduction of transformation units. Compositionality in bidirectional transformations discussed in [21].
In terms of bidirectional transformations that may be used as semantic relation between the model and semantic domain, there are two notable approaches: Triple Graph Grammars (TGGs) [20] and QVT [18]. TGGs have reliable tool support [10].

Formalising Compositionality
In this section compositionality is introduced formally. As the results proposed in this paper are generic with respect to the semantic domain, we provide a general, axiomatic definition.
Definition 3.1 (semantic domain) A semantic domain is a triple (D, ±, C) where D is a set, ± is a partial order on D, C is a set of total functions C[ ] : D → D, called contexts, such that d ± e =⇒ C[d] ± C[e] (± is closed under contexts).
The equivalence relation ≡ is the symmetric closure of ±.

Both source and target models and their semantics are represented as typed graphs. For clarity, we present the definition of typed graphs that we use.
Definition 3.2 (typed graph and typed graph morphism [7]) Given type graph TG = (VTG, ETG, sTG, tTG), VTG and ETG are called vertex and edge label alphabet respectively. Then, a tuple (G, type) of a graph G together with a graph morphism type : G → TG is called a typed graph.

Given typed graphs GT
= (G1, type1) and GT
= (G2, type2), a typed graph

morphism f : GT
→ GT
is a graph morphism f : G1 → G2 such that type2 ◦ f =

type1.



G1 f  G 2
= 
type1 type2
J , s
TG 
The concept of context is central to compositionality. In set-theoretic terms a context C of graph D in graph G is given by C = G\D. Context C is not necessarily a graph due to the possible dangling edges. To have a correct separation of context and included graph, we need a special set of contexts SC and set of graphs SG .
Definition 3.3 (Compositionality) A semantic mapping sem : GraphsTG →
(D, ±, C) with set of contexts SC and set of graphs SG is compositional if, for any
injective m0 : G0 → H0 and pushout (1) with G0, G' ∈ SG , there is a context
E ∈ SC with sem(H0) ≡ E[sem(G0)] and sem(H' ) ≡ E[sem(G' )]
0	0
G0 	 G '

m0	(1)
J 
'
0
J' 

H0 	 H 0
Intuitively the concept of compositionality is depicted in Figure 3. The semantic expression generated from G contains the one derived from L, through the inclusion morphism m.

Figure 3. Intuitive approach to compositionality

Theorem 3.4 Assume a compositional mapping sem : GraphsTG → (D, ±, C).
Then, for all transformations G =p,m	via rule p : L → R with injective match m,
it holds that sem(L) ± sem(R) implies sem(G) ± sem(H).
Proof Pushout (1) implies that sem(G) ≡ E[sem(L)] and sem(H) ≡ E[sem(R)].

L	 R 
(1)
J   J 


Now, E[sem(L)] ± E[sem(R)] since sem(L) ± sem(R) and ± is closed under context. Hence sem(G) ≡ E[sem(L)] ± E[sem(R)] ≡ sem(H)	 
The statements in Theorem 3.4 also hold for the relation ≡, obtained as the symmetric closure of ±.

Compositionality of Basic Graph Transformations
After giving an abstract definition in Section 3, in this section we prove a condition for compositionality of semantic mappings specified by graph transformations with- out negative application conditions. We assume that the semantic mapping sem is defined by a typed graph transformation system GTS = (TG, P ) consisting of a type graph TG and a set of typed graph productions P .
Definition 4.1 (nontermination) A graph G is non-terminating with respect to a typed graph transformation system GTS = (TG, P ) if ∃p ∈ P that is applicable to G. The notation for a non-terminating graph is G  .
Definition 4.2 The result of the semantic mapping sem on a source graph G0 is

sem(G ) = G
if and only if there is a transformation	p1
pn	with

0	n	G0 ⇒ G1...Gn−1 ⇒ Gn
rules p1, ..., pn ∈ P which is terminating.
It is important to note that only a locally confluent and terminating [7] trans- formation produces a unique result for a source graph. Thus, local confluence is also required for sem.
Definition 4.3 (separable semantics) A semantic mapping sem : GraphsTG → (D, ±, C) is separable with respect to a set of contexts SC and set of graphs SG if for all pushouts (1) with G ∈ SG and C ∈ SC it holds that if H  then either G or C  .

B 	 G 
(1)
J	 J 


We recall the definition of the initial pushout [7], as it is used extensively throughout the paper.
Definition 4.4 (initial pushout) Given a morphism f : A → A', an injective morphism b : B → A is called the boundary over f if there is a pushout complement of f and b such that (1) is a pushout initial over f . Initiality of (1) over f means, that for every pushout (2) with injective b' there exists unique morphism b∗ : B → D and c∗ : C → E with injective b∗ and c∗ such that b' ◦ b∗ = b, c' ◦ c∗ = c and (3) is a pushout. B is then called the boundary object and C the context with respect to f .

 	b	 
b	 A  B b∗ D   b' zA 

(1)	f
(3)
(2)	f

J   J '  J ∗ J  '  J 

c	A	C	c
E	c	 A¸
c

For the transformation sem :
∗
G0 ⇒ Gn
we create a boundary graph B and a

context graph C through an initial pushout. The boundary graph is the smallest subgraph of G0 which contains the identification points and dangling points of m0. The next definition is IPO compatibility of semantic mappings. While compo- sitionality was defined through an unknown context E, IPO compatiblity defines it
through the semantics of the context graph.
Definition 4.5 (IPO Compatibility) A semantic mapping sem : GraphsTG → (D, ±, C) with sets SC and SG is initial pushout compatible (IPO compatible) if for any injective m0 : G0 → H0 and initial pushout (2) over m0 we have sem(H0) ≡ sem(C)[sem(G0)] and C ∈ SC, G0 ∈ SG .

B 	 G 0
(2)	m0
J	J 
C	 H 0
Lemma 4.6 If a semantic mapping sem : GraphsTG → (D, ±, C) with sets SG and
SC is IPO compatible, then it is also compositional.
Proof Given pushout (1) with injective morphism m0 : G0 → H0 and initial pushout (2) over m0. The closure property of initial pushouts [7] implies that pushout (2) + (1) is also initial over m' .

B 	 G 0 	 G '

(2)
J 
m0 (1)
J 
'
0
J' 

C	 H 0 	 H 0
Since sem is IPO-compatible with (2), sem(H0) ≡ sem(C)[sem(G0)] and G0 ∈ SG . As (2) + (1) is also an initial pushout, sem is compatible with it, and thus
sem(H' ) ≡ sem(C)[sem(G' )] and G' ∈ SG as well. Hence sem is compositional
0	0	0
with E = sem(C) ∈ SC .	 
The definition of initial-preserving graph transformations is inspired by the world of Triple Graph Grammars [20]. We assume an implicit source model left untouched by the transformation, while the transformation constructs the target model.
Definition 4.7 (initial-preserving) A (typed) graph transformation t : G0	⇒
Gn is initial-preserving if it is non-deleting with respect to its initial graph G0.
A (typed) graph transformation system GTS = (TG, P ) is initial-preserving if all transformation sequences are initial-preserving.

Although initial-preservation seems similar to nondeletion, but elements of the target model may be deleted or modified through the transformation process.
Theorem 4.8 (Basic Compositionality Theorem) A semantic mapping sem : GraphsTG → (D, ±, C) with sets SG and SC is compositional if it is initial-preserving and separable.
Proof
The main argument is based on the Embedding Theorem [7]. For the transfor-

mation sem :
∗
G0 ⇒ Gn
we create a boundary graph B and context graph C. The

boundary graph is the smallest subgraph of G0 which contains the identification points and dangling points of m0. Pushout (2) is the initial pushout of m0.
b

B	b G 0 ¸i,d
zG˛ dn  G 
B 	 G sema zG 


(2)  m0
J	J 
0
sema
   ˛,n

(2)
J c0
0 	n
m0 (3)
J sema	J 

C0 	 H 0
C0 	 H 0
 zH n

semb	(4)	semb
cz	cz
Cm 	 H m
Since t is initial-preserving the consistency diagram [7] above can be used with initial pushout (2). G0 replaces D as it is preserved throughout the transformation. Hence m0 is consistent with respect to sem and there is an extension diagram over sem and m0 [7]. Transformations sema only denotes particular rule application order of sem.
This essentially means that (3) is a pushout and Hn is the pushout object of sem and m0, thus can be determined without applying the transformation sem on H0.

While sem(G0) = Gn
and thus G0
∗
⇒ Gn
is terminating, Hn
is possibly not

terminating. The parts of H0 not present in G0 were not transformed to the semantic domain by the rules in sema, but the reasoning above holds for C0 as well. The extension diagram over C0 is pushout (4) and sem(C0) = Cm. The termination of
Hm is also unknown.
According to the Concurrency Theorem [7] the concurrent production can be

created for both H0
∗
⇒ Hm
and H0
∗
⇒ Hn
.  Since the transformation is initial-

preserving, the resultant morphisms hn and hm are inclusions (or identities) and
the extension diagrams (5) and (6) exist. Since pushouts are unique, (5) = (6) and thus HA = HB = H.
H0  sema zH n	H0  hn  H n

hm	(5)
ha semb
(6)
semb

J sema
J   czhb	cz

Hm  zH A
Hm 	 H B

This leads to the diagram below. Since Gn ∈ GS and Cm ∈ GC , the semantics is separable and they are terminating (i.e. no semantic rule applicable), H must be also terminating. If H is terminating, that means sem(H0) = H.



B 	 G 0  sema zG n

(2)
J c0
C0
m0 (3)
J sema
H0

J zH n

semb
(4)
semb
(5)
semb

cz	czsema	cz
Cm 	 H m  zH 
According to the composition property of pushouts [7], (2) + (3) and (4) + (5) are pushouts and thus the big (2) + (3) + (4) + (5) square is a pushout as well. Since
H is a pushout object, H ∼= Gn +B Cm = Cm[Gn] which means that sem(H0) = 
sem(C0)[sem(G0)]. Hence sem is IPO compatible and according to Lemma 4.6 it is also compositional.	 

Graph Transformations with NACs
In Section 4 the compositionality of graph transformations with non-deleting rules was proved. However in order to control the transformation, negative application conditions (NACs) need to be used as well.
The definition of separable semantics (Definition 4.3) carries over to this section
with the presence of negative application conditions allowed.
Definition 5.1 (negative application condition [7]) A simple negative applica- tion condition is of the form NAC(x), where x : L → X is a morphism. A morphism m : L → G satisfies NAC(x) if there does not exist a morphism p : X → G in M' with p ◦ x = m:
L	x X 
m	p
G
Before the establishment of Theorem 5.6, the necessary definitions are presented.
Definition 5.2 (gluing and created points) Given a (typed) graph production

p = (L ←−l
K −→r
R).

The gluing points GP are those nodes and edges in L that are not deleted by p,
i.e. GP = lV (VK) ∪ lE(EK) = l(K).
The created points CP are those nodes and edges in R that are created by p, i.e.
CP = rV (VK)\VK ∪ rE(EK)\EK.

Figure 4. Production Rule with Created Points

The concept of created points is demonstrated in Figure 4. Since the C node is deleted, the only gluing points are the two A nodes. They are not deleted by the rule in Fig. 4. The created points are the B nodes on the right hand side of the rule.
It is possible that the B nodes are always - if present - gluing points in every production rule of the graph transformation system. This means that the node type B is such a special type that its instances are never deleted. This observation leads to the definition of constant types that are already present in the start graph are not deleted throughout the transformation.
Definition 5.3 (constant types) Given a typed graph transformation system GTS = (TG, P ). Constant types CT ⊆ TG = (VCT , ECT ) are those nodes and edges in the type graph T G, whose instances are not deleted or modified by any production p ∈ P . i.e. CT = {v ∈ VTG | ∀p ∈ P : v = typeV (w) ∧w ∈ GPpi } ∪ {e ∈ ETG | ∀p ∈ P : e = typeE(f ) ∧ f ∈ GPpi } .
In an instance graph, constant points are those nodes and edges that are of a constant type.
The definition of constructive transformations are inspired by Triple Graph Grammars. While the NACs contain only non-constant elements, the intial graph consists exclusively constant points. This way the NACs concentrate on the target elements of the transformation.
Definition 5.4 (constructive transformation) A graph transformation t : G ∗
Gn with NACs through embedding m0 : G0 → H0 is constructive if
G0 and H0 contains only constant points, i.e. type(G0), type(H0) ⊆ CT .
all NACs consist of non-constant points, i.e. ∀p ∈ P with each NAC(n),n :
L → N of p we have ∃x ∈ N \ n(L) with type(x) ∈/ CT

Corollary 5.5 A constructive graph transformation t :
∗
G ⇒ H
with NACs is also

initial-preserving because G consists of constant points that are not deleted through the transformation.
Theorem 5.6 (compositionality theorem with nacs) Given a semantic map- ping sem : GraphsTG → (D, ±, C) with sets SG and SC described by a graph trans- formation system GTS = (TG, P ) with constant types CT ⊆ TG. Then, it is compositional if it is separable and constructive.
Proof The proof is based on the basic compositionality theorem. In order to apply the Embedding Theorem in the proof of Theorem 4.8, it is suffice to show that the extension diagrams over m0 and c0 exist in the presence of NACs.
As the equivalent left NACs can be constructed from the right NACs, the NACs throughout this proof are assumed to be left NACs, if not explicitly stated on the contrary.
The extension diagram exists in case of NACs, if the transformation not only boundary-consistent [15], but also NAC-consistent [16]. According to the synthesis construction of Concurrency Theorem a concurrent rule pc with a concurrent match

gc exists [7]. The concurrent rule pc is basically the merge of all rules of a specific

rule application order in sem :
∗
G0 ⇒ Gn
such that the target graph Gn
is produced

by the application of pc on the source graph G0.
In graph transformations containing NACs, a concurrent NACpc exists for the concurrent rule pc. To achieve NAC-consistency, we have to show, that k0 ◦ gc |= NACpc with NACpc being the concurrent NAC, gc the concurrent match induced by t and k0 : G0 → H0 the inclusion morphism [16].
Since type(H0) ⊆ CT , this follows from Lemma 5.7, because the existence of a morphism q : Nc → H0 that satisfies an arbitrary NAC would imply for x ∈ NC \ n(LC) with type(x) ∈/ CT also type(q(x)) = type(x) ∈/ CT which is contradiction to type(H0) ⊆ CT .	 
Lemma 5.7 All NACs of pc are non-constant provided that ∀p ∈ P have non- constant NACs.
Proof The proof is by mathematical induction over the length of sem : G0 ⇒ Gn.
Basis. n = 1. We have pc = p0 which has the property of the assumption.
Induction Step. Consider tn : G0 ⇒n Gn ⇒ Gn+1 via the rules p0, p1, ..., pn. We

can assume by induction that p' =
ni	'
'	' (the concurrent rule for

c	Ni ←− Lc ←− Kc −→ Rc
nj
p0, p1, ..., pn−1) and pn : Nj ←− Ln ←− Kn −→ Rn have non-constant NACs. We have
to show that all NACs for pc are non-constant.


Ni ¸,¸ ¸	N ,
¸¸ni

ei
J' 
¸¸¸

' ¸, 

' 	 '

'
nj

¸, 		 

Ni  (1)  Lc
Kc	Rc
Nj  (3)  Ln	Kn	Rn

,¸'
ni
c
,,
'
e'	j	en

J 
Lc ¸,
'
c

gc
J 
Cc ,¸
kc


(2)
Kc
c
 E ¸,


h
J  r
_Cn 
kn	+1

h


h'	gn
tJz	J	c	zJz	J 
G0 ¸,  Dn 	 G n ¸,	 D 	 G n+1
According to the synthesis construction of Concurrency Theorem with NACs the

concurrent rule p
with NACs induced by G
=n+⇒1 G
is p =
l◦kc
r◦kn

c	0	n+1
c	Lc ←−− Kc −−−→ Rc

(with match gc : Lc → G0, comatch hc : Rc → Gn+1). The concurrent NACpc
consists two parts.

Case 1
n' : LC → N' defined by ni : L' → Ni from p' .
i	i	C	c
By assumption ii of constructiveness we have ∃xi ∈ Ni \ ni(L' ) with type(xi) ∈/
CT . Let x' = ei(xi) such that type(x') = type(xi) ∈/ CT . Moreover x' ∈ N' \n'(LC)
i	i	i	i	i

because otherwise pushout and pullback (1) implies that ∃yi ∈ L' with ni(yi) = xi
and hence xi ∈ ni(L' ) which is a contradiction. Thus n' is non-constant.
C	i


Case 2
n'' : LC → N'' defined by nj : Ln → Nj with n'

: E → Nj through pushouts

j	j	j
(3) − (5).

N'' ¸,  Z 	 N '

,j ,
''	(5)
,,
(4)
,j ,
'
j

Lc ¸,  Cc 	 E 
If the pushout complement Cc of (4) does not exists, the induced NAAC is always true.
By assumption on pn we have xj ∈ Nj \nj(Ln) with type(xj) ∈/ CT . Because (3)
is a pushout and pullback, ∃x' = z1(xj) ∈ Nj \n' (E) and type(x' ) = type(xj) ∈/ CT .
j	j	j
Also ∃yj ∈ Z \ Cc with (Z → N')(yj) = x' using pushout (4) with type(yj) = 
j	j
type(x' ) ∈/ CT . And finally ∃x'' = (Z → N'')(yj) ∈ N'' \ n''(LC) because (5) is
j	j	j	j	j

a pushout and pullback with type type(x'') = type(yj) ∈/ CT . Thus n''
is non-

constant.	 

Application to the Case Study
Compositionality is an important property of typed graph transformations in the field of semantic verification. In this section we present an application of the pre- sented theoretical concepts using the mapping mentioned in [3].
In order to improve the internal structure, performance or scalability of a soft- ware system, behaviour-preserving changes are introduced known as refactorings [9]. As the applications of today tend to be service-oriented, we deal with refactorings of business workflows.
We use UML activity diagrams specifying the workflows executed by service instances [19]. The semantics of the relevant fragment of the UML is expressed in a denotational style, using CSP [13] as semantic domain and defining the mapping from UML diagrams to CSP processes by means of graph transformation rules. The semantic relation of behaviour preservation can be expressed using one of the refinement and equivalence relations on CSP processes, and checked using FDR2 [8].

Short Introduction to CSP
In this section we briefly introduce the necessary concepts from CSP. A Process is the behaviour pattern of a component with an alphabet of events. Processes are defined using recursive equations called ProcessAssignments. The ProcessExpressions used in Section 6.2 are based on the following syntax.

P ::= event → P | P || Q | R

The PreﬁxOperator a → P performs action a and then behaves like P . The Concurrency process P || Q behaves as P and Q engaged in a lock-step synchroni- sation.
Formally, the UML models are instances of metamodels represented by at- tributed typed graphs.  The abstract syntax of CSP can be also represented as a typed graph. The typed graph based metamodel for CSP is defined in [2]. This way, the semantic mapping can be defined as a typed graph transformation.
CSP is a semantic domain in the sense of Definition 3.1. D is the set of CSP expressions and ± can be trace, failure or divergence refinement as they are closed under context [13]. A context is a process expression E(X) with a single occurrence of a distinguished process variable X.

Implementation
Although the transformation mechanics was inspired by TGGs, the transformation was implemented in Tiger EMF Transformer [22] and thus it is unidirectional.

Figure 5. Mapping of Actions and ActivityEdges
To present the definitions in practice, a simple pair of rules are introduced in the following. Figure 5 shows their concrete syntax. The rules in Figure 6 and 7 are responsible for creating the edge processes, as well as weaving the edge processes to the events created from the actions. The attribute values A and B denote variables that holds the same values in both sides of the rule.
Figure 6. Implementation of Edge Rule
The Edge rule in Figure 6 creates the process definition for the corresponding edge. The NAC, defined on CSP expressions, checks the existence of a similar process definition. If none exist, the matched edge has not been transformed yet. Thus it creates the empty A = process definition.
The Action rule in Figure 7 creates an event from the corresponding action and
inserts it to the definition of the related process. The NAC, consisting of CSP expressions only, works the same way as the one in the Edge rule.



Figure 7. Implementation of Action Rule
Proof of Compositionality
This semantic transformation is compositional, if it is terminating, locally confluent, separable, integrated and constructive.
Termination and local confluence can be proven through a critial pair and ter- mination analysis in AGG [1].
The semantic mapping basically reads the architectural model and creates the corresponding set of CSP expressions. None of the rules deletes any element typed from the CSP metamodel. Thus, all elements of the CSP metamodel are stable types, since all instances of them are stable points in this semantic mapping. Also, the NACs are defined on CSP expressions only. These three observations corre-
sponds to the assumptions of Definition 5.4, thus the transformation is constructive.
To prove separablility the sets SC and SG need to be defined. We define on set of graphs SAD that represents both. SAD is a set of subgraphs of H0 such that if an ActivityNode is present in G, then all incoming and outgoing ActivityEdges connected to the node should be present as well. Since every transformation rule in sem transforms a single ActivityNode into the semantic domain, every node type has a related production rule in sem. As ActivityEdges are transformed to pro- cesses, they form a frame around the ActivityNodes, enabling their transformation. Thus, boundary graphs consist of only ActivityEdges. If all the incoming and out- going ActivityEdges are included with the relevant node, all corresponding rules are triggered in the subgraph. Hence no new structures are created during the merge process that enables a previously disabled rule. Thus if C0 and G0 are of SAD, then if C0 and G0 are terminating, then H as well.

Conclusions
In this paper the notion of compositionality has been formalised for mappings be- tween typed graphs and semantic domains. The semantic mapping was represented by typed graph transformations. As a main result, conditions for compositionality has been established for simple graph transformations as well as graph transfor- mations with negative application conditions with the necessary concepts defined. An example compositional transformation was presented that maps UML activity

diagrams to CSP.
Future work includes the research on graph transformation with basic control structures as well as advanced control flow.
Acknowledgement
This work has been partially sponsored by the project SENSORIA, IST-2005- 016004.

References
AGG - Attributed Graph Grammar System Environment (2007).
URL http://tfs.cs.tu-berlin.de/agg

Bisztray, D. and R. Heckel, Rule-level verification of business process transformations using csp, in: Proc. of 6th International Workshop on Graph Transformations and Visual Modeling Techniques (GTVMT’07), 2007.
Bisztray, D., R. Heckel and H. Ehrig, Verification of architectural refactorings by rule extraction, in: Proc. of Fundamental Approaches to Software Engineering (FASE’08), Lecture Notes in Computer Science, 2008, to appear.
Bottoni, P., M. Koch, F. Parisi-Presicce and G. Taentzer, Termination of high-level replacement units with application to model transformation., Electr. Notes Theor. Comput. Sci. 127 (2005), pp. 71–86.
URL  http://dblp.uni-trier.de/db/journals/entcs/entcs127.html#BottoniKPT05

Bottoni, P., G. Taentzer and A. Schu¨rr, Efficient parsing of visual languages based on critical pair analysis and contextual layered graph transformation, in: Proceedings of the IEEE International Symposium on Visual Languages (VL’00), IEEE Computer Society, 2000, p. 59.
Ehrig, H., K. Ehrig, J. de Lara, G. Taentzer, D. Varr´o and S. Varr´o-Gyapay, Termination criteria for model transformation, in: M. Cerioli, editor, Proc. of International Conference on Fundamental Approaches to Software Engineering (FASE’05), Lecture Notes in Computer Science 3442 (2005), pp. 49–63.
Ehrig, H., K. Ehrig, U. Prange and G. Taentzer, “Fundamentals of Algebraic Graph Transformation,” Monographs in Theoretical Computer Science, Springer-Verlag, 2006.
Formal Systems Europe Ltd, FDR2 User Manual (2005).
URL http://www.fsel.com/documentation/fdr2/html/index.html

Fowler, M., K. Beck, J. Brant, W. Opdyke and D. Roberts, “Refactoring: Improving the Design of Existing Code,” Addison-Wesley Professional, 1999, 1st edition.
Fujaba Tool Suite (2007).
URL http://wwwcs.uni-paderborn.de/cs/fujaba

Heckel, R., R. Correia, C. Matos, M. El-Ramly, G. Koutsoukos and L. Andrade, “Architectural Transformations: From Legacy to Three-tier and Services,” To appear.
Heckel, R., J. M. Ku¨ster and G. Taentzer, Confluence of typed attributed graph transformation systems, in: Proc. of the 1st International Conference on Graph Transformation (ICGT’02) (2002), pp. 161–176.
Hoare, C. A. R., “Communicating Sequential Processes,” Prentice Hall International Series in Computer Science, Prentice Hall, 1985.
Ku¨ster, J. M., Definition and validation of model transformations, Software and Systems Modeling 5
(2006), pp. 233–259.
Lambers, L., Adhesive high-level replacement systems with negative application conditions, Technical report, Technische Universit¨at Berlin (2007).
Lambers, L., H. Ehrig, F. Orejas and U. Prange, Adhesive high-level replacement systems with negative application conditions, in: Proc. of Applied and Computational Category Theory Workshop (2007).
Levendovszky, T., U. Prange and H. Ehrig, Termination criteria for dpo transformations with injective matches, Electron. Notes Theor. Comput. Sci. 175 (2007), pp. 87–100.

MOF Query/View/Transformation (QVT) Final Adopted Specification (2005).
URL http://www.omg.org/docs/ptc/05-11-01.pdf
OMG, Unified Modeling Language, version 2.1.1 (2006).
URL http://www.omg.org/technology/documents/formal/uml.htm

Schu¨rr, A., Specification of graph translators with triple graph grammars, in: Proc. of Int. Workshop on Graph-Theoretic Concepts in Computer Science (WG’94), Lecture Notes in Computer Science 903 (1994), pp. 151–163.
Stevens, P., Bidirectional Model Transformations in QVT: Semantic Issues and Open Questions, in: Proc. of 10th International Conference on Model Driven Engineering Languages and Systems (MODELS’07), Lecture Notes in Computer Science 4735 (2007), pp. 1–15.
Team, T. D., “Tiger EMF Transformer,” (2007). URL http://www.tfs.cs.tu-berlin.de/emftrans
