Electronic Notes in Theoretical Computer Science 203 (2008) 49–70	
www.elsevier.com/locate/entcs
A Name Abstraction Functor for Named Sets
Vincenzo Ciancia 1 Ugo Montanari 1
Department of Computer Science University of Pisa

Abstract
The problem of defining fully abstract operational models of name passing calculi has been given some elegant solutions, such as coalgebras over presheaf categories or over nominal sets. These formalisms fail to model garbage collection of unused names, hence they do not have nice properties with respects to finite state algorithms. The category of named sets, on the other hand, was designed for the purpose of supporting efficient algorithms to handle the semantics of name passing calculi. However the theory was developed in a rather ad-hoc fashion (e.g. the existence of a final coalgebra was only proved in the finite case). In this work we introduce a name abstraction functor for named sets and show that it provides a simple and effective notion of garbage collection of unused names. Along the way, we survey a number of needed results on the category of permutation algebras, an algebra-theoretic definition of nominal sets. In particular we give a formalization of the adjunction between abstraction and concretion, an example illustrating a nominal syntax alike handling of De Bruijn indexes, and an explicit functor to model the early semantics of the π-calculus in nominal sets.
Keywords: named sets, nominal sets, binding, garbage collection, De Bruijn indexes


Introduction
In the field of programming language semantics and concurrency theory, wide atten- tion is paid nowadays to the so called name-passing calculi, i.e. formalisms where name generation and passing play a fundamental role. Among the most important research contributions in this area, we find the introduction of the π-calculus [1], which allows one to model the topology of a network of mobile components, by generating and passing fresh channels. Traditional logical methods, such as modal logics, proved inadequate to reason about this formalism, leading to the definition of logics with name binding, such as [2] or [3].
On the side of the syntax, the problem of representing binding in a satisfying way has been long standing, the most famous attempt being that of De Bruijn indexes [4]. The problem was tackled in the work on nominal syntax [5,6,7], aimed

1 Research partially supported by the EU FP6-IST IP 16004 SEnSOria

1571-0661© 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.05.019

to provide a logical framework in which to represent axioms on terms up to α- equivalence [8], employing the category of nominal sets. Also on the side of semantic models, it was soon recognized that ordinary labeled transition systems (LTS) and their bisimulations do not fully capture the notion of name allocation, which is required in the operational semantics of the π-calculus (and other name-passing calculi). New models where developed, noticeably presheaf models, such as [9,10], and those based on the theory of permutation algebras [11,12].
As it was soon recognized, even though they where developed independently, the category of nominal sets, and that of permutation algebras, are essentially the same. We remark that the latter is not a new definition, but rather the standard notion of algebra for a specification. While the idea of modeling binding in this category certainly has its roots in the work on nominal syntax, the key role of the symmetry of elements, which subsumes the notion of ﬁnite support and its properties (cf. theorem 2.11 in the following) is a result of the research on permutation algebras. A key motivation for studying symmetries was the development of history-dependent automata with symmetries [13], a categorial model, based on the theory of named sets, closely connected to permutation algebras, capable of finite-state verification of processes that can allocate fresh resources.
A comparison of the various categorial models of name passing was done in [14] and [15], resulting in the proof of categorial equivalence of permutation algebras (hence nominal sets), the Schanuel topos (the pullback-preserving full subcategory of the presheaf category SetI) and named sets. Even though this shows that, from a theoretical point of view, there is no difference in adopting one of a number of equivalent formalisms, named sets enjoy nice algorithmic properties which are absent in all the other models, and are due to the handling of names as local, bindable resources, rather than constants which have a global, immutable meaning.
The equivalence result in [14] was focused on the base categories, without an- alyzing in detail functors and associated categories of coalgebras that express the operational semantics of calculi. In this work, along the way to define a name abstraction functor on named sets, we add some missing pieces to this puzzle.
In [12], the final coalgebra semantics of the π-calculus was obtained in an implicit form, reusing results on lifting of SOS rules [16] defining transition systems in Set (again, exploiting the algebraic definition of the category of nominal sets). The functor defined by the lifting was never made explicit, thus name abstraction was never defined for permutation algebras. We do this exploiting a theory morphism. A coalgebra modeling the early semantics of the π-calculus using named sets was
given in [17,18], together with a minimization procedure based on iteration along
the terminal sequence. However, the functor given there was defined in an ad-hoc way, without providing separate components (such as name abstraction) that allow one to reuse the existing theory to express the semantics of other calculi. The “monolithic” definition of the functor therein makes difficult to reason about it (for example, it has not been proved if it has admits a final coalgebra).
Our main contribution is to develop the equivalence results in [14] a step further, by characterizing, in the category of named sets, the name abstraction functor

modeling binding operations. Name abstraction can be considered, not without a reason, the novel, and most important feature of the name-aware models we mentioned, and we foresee that it will allow us a generalization of the results in [18].
The map of the paper is as follows. We start by defining permutation algebras in section 2.1, and proving a number of relevant (possibly folklore) results in section
2.2. Among these, without claiming originality, we mention some that up to our knowledge had not been clearly stated before, even though deserving attention: theorem 2.13, and theorem 2.11, whose subsequent corollary is one of the peculiar features of permutation algebras (and nominal sets).
Then, in section 3, exploiting the notion of theory morphism (whose definition is recalled in section 2.3), we obtain the abstraction functor δ on permutation alge- bras as the forgetful functor of the associated adjunction. The corresponding free functor F is called concretion. Group-theoretical properties (namely, orbits and symmetries) of both functors are explored in sections 4.1 and 4.2.
In section 4.3 we provide the due comparison with the nominal set of abstractions and the freshness relation of nominal sets. The notions turn out to be isomorphic (hence, we get a proof of another folklore result, the adjunction between the two functors in nominal syntax). Nevertheless, the adjunction we provided is still worth being studied for some side results. In example 4.12, we provide the definition of the machinery of De Bruijn indexes as the initial algebra for a functor involving δ, thus filling the gap between nominal abstract syntax and De Bruijn indexes. Moreover, the pair of adjoints introduces the counit, whose effect is to reveal a bound name, in a similar way to the concretion operation of nominal syntax. Giving a precise role to this operator opens the way to formally link the field of spatial logics for nominal calculi [19,20] with the algorithmic framework of named sets (see remark 4.13).
On the side of the semantics of calculi, we show in section 5 that the functor used in [12] can be defined using ordinary endofunctors (polynomials and power set) and δ, thus addressing the question of an explicit form for that functor. The definition of coalgebraic models over nominal sets has been recently proposed also in [21], where an example showing the late semantics of the π-calculus is provided using the abstraction functor of nominal syntax.
In section 6 we introduce the theory of named sets, attempting to explain some of their properties in terms of results on permutation algebras, in light of the equiv- alence result of [14] which we shortly present. Finally, in section 7.1, we define the abstraction functor in named sets, exploiting results of section 4.1. An isomor- phism result with the corresponding functor in permutation algebras (thus, with abstraction as defined in nominal syntax) is established.
The obtained framework has a distinguishing feature, with respects to presheaves and permutation algebras: the abstraction functor has an implicit notion of garbage collection, that allows names to be discarded, without necessarily keeping memory
of names generated in the past transitions. This is not the case, either in presheaves or in permutation algebras/nominal sets, as we explain in section 7.2.

Background
Here we introduce the basic algebraic and group-theoretic notions that are used in the rest of the paper. In section 2.1 we introduce the category of sets equipped with an action of finite-kernel permutations over the set of natural numbers ω, and corresponding morphisms. These are usually known as FM-sets from the set theory of Fraenkel and Mostowski, who developed this model to show independence of the axiom of choice from other axioms of set theory. This category can be conveniently defined observing that FM-sets are algebras for the finite-kernel permutation group viewed as a monadic, single-sorted algebraic theory, obtaining the notion of equiv- ariant function as the morphisms of the associated category of algebras. In section 2.2, we show a number of results that are needed. Many of these are folklore, the remarkable exception being theorem 2.11, a simple result that explains in terms of symmetry one of the most pervasive properties of the support: it never grows along morphisms. This leads, in all categorial formalisms that handle names using injective relabelings (presheaves, nominal sets and named sets), to the necessity of defining specialized functors for abstraction. In section 2.3 the notion of theory morphism and associated adjunction is explained.

Nominal Sets as Algebras for the Permutation Signature
The set of permutations over a set S forms a group where the operation is function composition. The core of the theory we present is the subgroup of ﬁnite-kernel permutations over the set of natural numbers ω, which we will denote with Autf , without making an explicit distinction between it seen as a set, a group, or the algebraic specification of definition 2.2 below.
Definition 2.1 (finite-kernel permutation) The kernel ker (π) of a permutation π : N → N is the set x ∈ N π (x) /= x . A permutation is ﬁnite-kernel if its kernel is finite. The set of all finite-kernel permutations over ω is denoted with
Autf .
Now we introduce the notions of permutation signature 2 and permutation al- gebra.
Definition 2.2 (permutation algebra) The (finite-kernel) permutation signature over ω is the set Autf of finite kernel permutations over ω, considered as unary, one-sorted algebraic operations of the form π : 1 → 1, together with the equational axioms id (x) = x and π1 (π2 (x)) = (π1 ◦ π2) (x) for each π1 and π2 in Autf . A per- mutation algebra is an algebra A = ⟨A,{πA : A → A | π ∈Autf }⟩ for Autf , where A is the carrier set, and πA is the interpretation of π, also called permutation action.
Identity and composition operations are not explicitly part of the permutation signature. However the axiom for identity, and the axiom schema for composition,

2 The definition really introduces an algebraic specification made up of a signature and an equational theory, not just a signature. However, since “permutation signature” has often been used to denote that theory, we stick with common terminology.

make the interpretation of composed permutations act like composition.
Definition 2.3 (morphism) An algebra morphism between permutation algebras A = ⟨A,{πA}⟩ and B = ⟨B,{πB}⟩ is a function f : A → B that preserves operations of the permutation signature, i.e. ∀π ∈Autf .f (πA (x)) = πB(f (x)).
Such morphisms are called equivariant functions in the theory of nominal syntax. Notice that ω can be considered a permutation algebra using the natural interpre- tation πω = π. We now introduce the group-theoretical notions of symmetry (also called isotropy group or stabilizer ), support and orbit.
Definition 2.4 (symmetry) The symmetry of an element a of A = ⟨A,{πA}⟩ is the set of all permutations fixing a in A, defined as G (a) = {π ∈Autf π (a) = a}.
The identity group of X ⊆ ω is defined as fix (X) = {π ∈Autf π  = id } and is used to define the notion of support in permutation algebras.
Definition 2.5 (support) We say that X ⊆ ω supports a ∈ A if fix (X) ⊆ GA (a),
i.e. if all permutations fixing X also fix a in A. The least ﬁnite set X satisfying this condition, if it exists, is called the support of a, written suppA (a). A permutation algebra is said to be ﬁnitely supported if all of its elements have finite support.
Each element of a permutation algebra is trivially supported by ω. A ﬁnite supporting set might not exist, but if there is one, then the support is the inter- section of all of them. The notion of support generalizes that of “free variables” of terms, thus we will often refer to ω as the set of names. On the other hand, the notion of symmetry models indistinguishability of free names with respects to certain permutations.
Definition 2.6 (category of permutation algebras) Permutation algebras and their morphisms form a category, named Algπ. We will denote with FSAlgπ the full subcategory of finitely supported permutation algebras and their morphisms.
Finitely-supported permutation algebras are the nominal sets of Gabbay and Pitts. The last notion we need to introduce on permutation algebras is that of orbit.
Definition 2.7 (orbit) The orbit of a ∈ A is orbA (a) = {πA (a) | π ∈Autf }.
Orbits partition algebras in equivalence classes. We denote with ao the (canon-

ical representative of) the equivalence class of a, and with Xo
the set {xo
| x ∈ X},

for X ⊆ A. Orbits play a central role when switching from the category of permu- tation algebras to their “finitistic” counterpart, named sets.
Example 2.8 (terms with variables) Let Σ be a signature. Free terms with variables in ω form a permutation algebra T = ⟨TΣ (ω) , {πT }⟩, with πT (t) = t π(i)/i  for i ∈ ω. It is easy to see that a ﬁnite set X ⊆ ω supports a term t if and only if its set of free variables FV (t) is a subset of X. So, the least such set, i.e. the support, is the set of free variables of t.

Some Results on Permutation Algebras
First of all, we show that the action of a permutation π on elements of a permutation algebra is determined by the action of π on their support.
Lemma 2.9 In a ﬁnitely supported permutation algebra A = ⟨A,{πA}⟩, for each

a ∈ A, we have π|

suppA(a)
= π'
|suppA(a)
=⇒ πA (a) = π'
(a).

Remark 2.10 Because of lemma 2.9, we will usually deﬁne a permutation π only on the support of an element a ∈ A, when it is clear from the context that π is to be applied only to a. In this case, we assume that the deﬁnition of π is completed in order to obtain a ﬁnite-kernel permutation
The following theorem, and in particular its subsequent corollary, gives an important property of nominal sets, extensively used in proofs about this category. Even though the corollary is well known (see e.g. corollary 9 in [14]), it is interesting to observe that it just comes from the symmetry of elements.
Theorem 2.11 Let f : ⟨A,{πA}⟩→ ⟨B, {πB}⟩. Then ∀a ∈ A.GA (a) ⊆ GB (f (a)).
Lemma 2.12 For each morphism f in FSAlgπ , we have suppB (f (a)) ⊆ suppA (a).
The following “isomorphism theorem” is relevant for named sets, since it asserts that a named set represents a class of isomorphic permutation algebras.
Theorem 2.13 Two permutation algebras A = ⟨A,{πA}⟩ and B = ⟨B,{πB}⟩ are isomorphic if and only if there exists a choice of canonical representatives of orbits,

and an isomorphism i : Ao
→ Bo
in Set, such that GA (ao) = GB (i (ao)).

Finally, we provide a “representation theorem”, taken from [12], aimed to give a finite representation of the symmetry of finitely supported permutation algebras.
Theorem 2.14 The symmetry GA (a) of a ∈ A is obtained by composition of two subgroups as follows: GA (a) = fix (suppA (a)) ◦ (GA (a) ∩ fix (ω \ suppA (a)))
In words, the infinite set of all permutations in GA (a) can be reconstructed from the information described by the (finite) set of all permutations in GA (a) that only alter the support of a, by composition with all the permutations that only alter names outside the support of a. This theorem is exploited in named sets to obtain a finite description of the symmetries. Such a finite description is still a group, hence it can be efficiently represented (using its generators, see [18]).

Theory Morphisms
Theory morphisms, or views, are equation-preserving signature morphisms M : Σ1 → Σ2, that yield algebras of Σ1 from algebras of Σ2. Here we just deal with the single-sorted case, since it is sufficient to present our work. The contents of this section are standard material from the theory of algebras (see e.g. [22]).
We denote with TΣ the initial algebra of the signature Σ, with TΣ (V ) the free Σ-algebra over a set of variables V , and with TΣ,E (V ) the free Σ-algebra over

V quotiented with equations derivable from E. The operations of the two initial algebras are indicated with opTΣ(V ) and opTΣ,E (V ), for op ∈ Σ. Given a Σ-algebra A = A, opA op ∈ Σ  , we call presentation of A, denoted with Pres (A), the kernel of the unique m : TΣ → A, i.e. the set of pairs t1 = t2 such that t1, t2 ∈ TΣ
and m (t1) = m (t2). Eq (E) represents the set of all equations derivable from E.
Definition 2.15 A signature morphism M between signatures Σ1 and Σ2 is a func- tion from the operators of Σ1 to the operators of Σ2 that respects operator arity, i.e. for every operator op of arity k, M (op) has arity k. A signature morphism is induc- tively extended to TΣ (V ), as M (op (T1,..., Tk)) = M (op) (M (T1) ,...,M (Tk)), and M (X ∈ V ) = X, and to equations as M (T1 = T2) = (M (T1) = M (T2)). Given two specifications S1 = ⟨Σ1, E1⟩ and S2 = ⟨Σ2, E2⟩, a theory morphism from S1 to S2 is a signature morphism from Σ1 to Σ2 that preserves equations derivable from E1, i.e. (T1 = T2 ∈ Eq (E1)) =⇒ (M (T1 = T2) ∈ Eq (E2)).
Every theory morphism induces a (forgetful) functor from the category of al- gebras of its destination to the category of algebras of its source, having a left adjoint.
Definition 2.16 Let Th1 = ⟨Σ1, E1⟩ and Th2 = ⟨Σ2, E2⟩ be two specifications. A theory morphism M : T h1 → Th2 associates to every ⟨Σ2, E2⟩-algebra A =
⟨A,{opA | op ∈ Σ2}⟩ a ⟨Σ1, E1⟩-algebra U (A) = ⟨A,{opU (A) | op ∈ Σ1}⟩ with the same carrier, where opU (A) = M (op)A for each operator op in Σ1. The map U extends to a functor, acting on arrows as Uarr (f ) = f. U has a left adjoint.
A definition of the left adjoint F of U can be given as a free construction that returns, for each Σ1-algebra A, the free Σ2-algebra over its carrier A, quotiented with the translation of Pres (A) via M .
Definition 2.17 Given a theory morphism M : ⟨Σ1, E1⟩ → ⟨Σ2, E2⟩, for each
⟨Σ1, E1⟩-algebra A = ⟨A,{opA}⟩, there is an associated ⟨Σ2, E2⟩-algebra F (A) = 
⟨TΣ2,E2 (A) /≡, {opTΣ ,E (A)}⟩, where ≡ is the equivalence relation defined by
2  2

T1 = T2 ∈ Pres (A)
M (T1) ≡ M (T2)
This map extends to a functor, acting on arrows f : ⟨A,{opA}⟩→ ⟨B, {opB}⟩ as
F (f ) (x ∈ A) = f (x), F (f ) (op (T1,..., Tn)) = op (F (f ) (T1) ,...,F (f ) (Tn)).
Theorem 2.18 F is left adjoint to U.
Name Abstraction and Concretion
In this section, we introduce the forgetful functor δ induced by a particular theory morphism, and its left adjoint F . We call these abstraction and concretion in analogy with the terminology of nominal syntax. We show how the unit and the counit of the adjunction are obtained, deferring informal explanations to section 4.1.

The definitions here and those of [7] may look different, but obtained objects are easily shown to be isomorphic. Our contribution here is to show how, by viewing the model as a category of algebras, we can characterize these two functors and their adjunction as a standard result.

The Abstraction and Concretion Functors
A signature morphism from Autf to itself is a function that preserves identity and composition. We now define such a morphism.
Definition 3.1 The right shift operator −+1 :Autf →Autf gives, for each operation
π, the operation π+1 such that π+1 (0) = 0, π+1 (i + 1) = π (i)+ 1.
Theorem 3.2 The right shift operator is a theory morphism.
The purpose of the morphism is to send a permutation π into ι ◦ (π ⊕ 1) ◦ ι−1, where ι is an isomorphism from ω ⊕ 1 to ω. We have chosen the isomorphism ˆι sending ⟨0, ∗⟩ to 0 and ⟨1, i⟩ to i + 1 (the famous “Hilbert’s hotel paradox”), but any other choice is possible 3 . We can describe all these different ι as the set
{ρ ◦ ˆι | ρ ∈Autf }. The effect of a generic ι is to “make room” for a fresh name, that actually comes from ω ⊕ 1. This makes evident the close analogy with the “typed” counterpart of nominal sets: presheaf categories such as SetI, where the abstraction functor is usually defined on a presheaf T as δ (T ) (n) = T (n ⊕ 1).
We obtain the abstraction functor as the associated forgetful functor.
Definition 3.3 The name abstraction functor δ : Algπ → Algπ acts on objects as
δobj (⟨A,{πA}⟩) = ⟨A, π+1 ⟩, and on arrows as δarr (f ) = f .
Being defined by a theory morphism, δ has a left adjoint, the concretion functor. The permutation signature is only made up of unary, composable operators, so the presentation of a permutation algebra is in the simple form π (a) = ρ (b), for a, b ∈ A, and π, ρ ∈Autf . In the following definition, we represent the free algebra over A simply as the product A× Autf , i.e. we write ⟨a, π⟩ instead of the usual notation π (a) for terms in TAutf (A), to avoid confusion with the notation πA (a). Notice that terms in TAutf (A) are already quotiented with axioms of the permutation signature.
Definition 3.4 The functor F : Algπ → Algπ which is left adjoint to δ is de- fined on objects as Fobj(⟨A,{πA}⟩) =  TAutf (A)/≡, πF (A) , with πF (A) (⟨a, ρ⟩) = 
⟨a, π ◦ ρ⟩, and on arrows as Farr (f ) (⟨a, ρ⟩) = ⟨f (a) , ρ⟩. The equivalence relation
≡ is defined by the following rule:
πA (a) = ρA (b)
a, π+1 ≡ b, ρ+1
We now provide a definition of the unit and the counit of the adjunction. It suffices to exhibit an universal arrow from A to δ, whose target is exactly δ (F (A)),

3 The choice we make matches the idea of De Bruijn indexes, as shown in example 4.12.

A ¸  ηA δ ( F (A))

F (A)

¸¸¸¸¸f
¸

δ(f #)
 
 f #

¸z J 
 J 

δ (B)	B
Fig. 1.
i.e. an arrow ηA : A→ δ (F (A)) such that, for each f : A→ δ (B) , there exists an unique f # making the diagram in figure 1 commute.
Theorem 3.5 An universal arrow ηA : A → δ (F (A)) is deﬁned as ηA (a) =
⟨a, id⟩. For each f : A → δ (B), we have f # : F (A) → B, with f # (⟨a, ρ⟩) =
ρB (f (a)).
The usual definition of adjunction relies on an isomorphism of homsets, which obtains for each arrow f : A→ δ (B) simply the arrow f # : F (A) → B. As it is well known from the theory of adjunctions (see e.g. [23]), the universal arrow ηA, defined for each object A of Algπ, can be seen as a natural transformation η : Id → δ ◦ F , which is the unit of the adjunction. The counit is given by ϵ : F ◦ δ → Id, such that

ϵA = id#
. By expanding the definition, we obtain the following:

Definition 3.6 The counit ϵA : F (δ (A)) →A of the adjunction between δ and F
is defined, for each permutation algebra A, as ϵA (⟨a, ρ⟩) = ρA (a).

Properties of Abstraction and Concretion
In this section we study the support, symmetry and orbits of elements of finitely supported permutation algebras obtained using δ and F . In particular, we show that both functors restrict from Algπ to FSAlgπ, and how in δ (A) we find more distinct orbits than in A, containing the hidden elements of δ (A), i.e. those that have a “bound” name, which is not observable. In F (A) instead, we find a name freely added to the support of each element of A, and an isomorphic set of orbits. The counit plays exactly the role to “reveal” a bound name, which is a non-trivial operation due to lemma 2.12. In section 4.3 we compare our notion of abstraction with the one defined by Gabbay and Pitts, showing that the difference is the same that exists between the ordinary axioms of α-conversion and the solution to the problem of binding given by De Bruijn indexes. For the purpose, we describe the syntax of the λ-calculus as an initial algebra for a functor employing δ.

Properties of Abstraction
Theorem 4.1 The support and symmetry of elements of δ (A) are obtained as
suppδ(A) (a) = {i − 1 | i ∈ suppA (a) \ 0}, and Gδ(A) (a) = {π | π+1 ∈ GA (a)}.
The above theorem proves that δ restricts from Algπ to FSAlgπ. The intuition behind it is that, in δ (A), we remove 0 from the support of each element. This way, name 0 ∈ suppA (a) becomes fresh in δ (A): no observation can be made about it,

but it is still a hidden name of a. This name can be used, exploiting the action of
δ on arrows: we just have δ (f (a)) = f (a), hence f can use all the names of a.
The property of 0 being fresh is also assured by the symmetry of a in δA: Gδ(A) (a) is the subgroup of GA (a) that fixes 0, shifted by one name. Information about interchangeability of 0 is thrown away, making it distinct from any other name.
We now define a set of permutations used to describe orbits of δ (A). Below, the finite set S will be used as the support of an element of a permutation algebra, hence by the convention of remark 2.10 we define these permutations only on S.
Definition 4.2 Given a finite set S, we define a permutation πold(S) such that πold(S) (i) = i + 1 for i ∈ S, and |S| permutations πh(S,i), for i ∈ S, such that πh(S,i) (i) = 0, and πh(S,i) (j) = j +1 if j ∈ S \ i.
Now we define functions in Set acting on carriers of permutation algebras. One is called old, because it embeds an element a from A into δ (A) preserving all of its properties (support, symmetry, orbit). The other ones are called hidden since they obtain, from a, new elements in δ (A), whose properties can not be recovered in A.
Definition 4.3 The old element oldA (a) and the ith hidden element hidi (a) of

a ∈ A are defined as oldA (a) = πold(suppA(a)) (a), and hidi
(a) = πh(suppA(a),i) (a).

A	A	A
It is straightforward to check that old is a morphism of type A→ δ (A). It holds that suppδ(A) (oldA (a)) = suppA (a), Gδ(A) (oldA (a)) = GA (a), and orbδ(A) (oldA (a)) =
oldA (x) x ∈ orbA (a)  . In other words, old is an embedding of A in δ (A).
The crucial property of hidi is to send name i to 0, hence we have (by theorem
4.1), suppδ(A) hidi (a) = suppA (a) \ i. In words, for each element a and each
name i of a, we can identify an element of δ (A) which has the same names as a, minus i. As we will see, such an operation is of fundamental importance to define coalgebras for δ, allowing these to hide names along transitions.
Remark 4.4 In the following, we will use hidi (a) to deﬁne an element of δ (A):
the subscript A denotes the application of the permutation action in A, thus iden- tifying an element of the carrier A, which is also the carrier of δ (A), not the fact
that element hidi (a) belongs to permutation algebra A as one might expect.
We show that the old and hidden elements form a partition of a permutation algebra.
Lemma 4.5 For each a ∈ A, there exist either b ∈ A such that a = oldA (b), or
b ∈ A and i ∈ supp (b) such that a = hidi (b).
Using this basic meta-language, we can relate orbits of δ (A) to orbits of A. For each orbit in A, represented by ao , there is a corresponding orbit in δ (A) without any hidden name, plus as many orbits in δ (A) as the possible abstractions of names in suppA (ao ), modulo its symmetry: there are as many ways to hide a name in
o  as names in its support, up-to an equivalence relation saying that there is no
difference in abstracting two names, when they are swapped by some permutations in GA (ao ).

Theorem 4.6 For a ∈ A, let Ha = {oldA (a)}∪ {hidi (a) | i ∈ suppA (a) /≡}, with
i ≡ j ⇐⇒ ∃π ∈ GA (a) .π (i) = j. Let Ao be a set of canonical representatives for

A. A set Ao
for δ (A) is obtained as Ao
=  a∈Ao Ha

The result on orbits also asserts a fundamental property: hidden elements can never be turned into old elements employing the permutation action of δ (A), hence they actually are new elements in the resulting algebra. The following example illustrates the need for an existential quantification over GA (a).
Example 4.7 Applying the result of theorem 4.6 to symmetries obtained by round shifts may look counterintuitive. Consider the set of π-calculus agents with names in ω, up to structural equivalence, seen as a permutation algebra Pi = ⟨APi, {πPi}⟩, and agent P (1, 2, 3) = ¯12 + ¯23 + ¯31. Its symmetry is id, σ, σ2 , generated by the round shift σ (1) = 2,σ (2) = 3,σ (3) = 1. The three agents P1 = (ν1) P (1, 2, 3), P2 = (ν2) P (1, 2, 3) and P3 = (ν3) P (1, 2, 3) belong to the same orbit due to struc- tural equivalence. However, the symmetry of P1 (and consequently, of P2 and P3 which are on the same orbit) is just {id}: the support of P1 is {2, 3}, hence the only possible candidate permutation besides the identity is the swap ρ (2) = 3,ρ (3) = 2, but ρPi (P1) = (ν1) (¯13 + ¯32 + ¯21) which is not structurally equivalent to P1 itself, whereas one might have expected ρ ∈ GPi (P1).
Finally, we observe that, being a right adjoint, δ admits a final coalgebra: FSAlgπ has a final object 1 where each permutation acts as the identity. Since right adjoints preserve final objects, the final coalgebra of δ is just id : 1 → 1.

Properties of Concretion
The following theorem shows that each element of F (A) has an additional name, which is added “syntactically” or “freely”, i.e. is not obtained by properties of A.
Theorem 4.8 We have suppF (A) (⟨a, ρ⟩) = {ρ (0)}∪ {ρ (i + 1) | i ∈ suppA (a)}.
The symmetry of an element of F (A) is given by the symmetry of a in A, translated using the right shift theory morphism and the permutation ρ.
Theorem 4.9 The symmetry GF (A) (⟨a, ρ⟩) is given by {ρ◦π+1 ◦ρ−1 | π ∈ GA (a)}. Notice that no permutation in the symmetry can swap (shifted) names of a and
0, hence 0 is distinguished from names already in a.
We finally analyze the set of orbits of F (A), which is isomorphic to that of A.
Theorem 4.10 Given a permutation algebra A = ⟨A,{πA}⟩, a set of canonical representatives of orbits of F (A) is given by F (A)o = {⟨a, id⟩| a ∈ Ao }.
For each a ∈ A we can recover, as we did for abstraction (employing old), an element having the same properties of a in A, plus the addition of a new name.
Lemma 4.11 For each element a, and each name i ∈/ suppA (a) there exists an
element of F (A) whose support is suppA (a) ∪ {i}, with GF (A) (a) = GA (a) ∩fix (i).

f (λx.l) = ⟨0, hidx (f (l))⟩ if x ∈ fn (l)	f (l1l2) = ⟨1, ⟨f (l1) ,f (l2)⟩⟩
f (λx.l) = ⟨0, oldΛ (f (l))⟩ if x ∈/ fn (l)	f (x) = ⟨2, x⟩
Fig. 2.

The contents of this section, and in particular the above lemma, amount to say that the algebra F (A) is, by theorem 2.13, isomorphic to the algebra FA =
⟨FA, {πFA}⟩ where FA = {⟨n, a⟩∈ ω × A | n ∈/ suppA (a)}, and πFA is the permu- tation action over the product algebra ω×A, which is πFA (⟨n, a⟩) = ⟨π (n) , πA (a)⟩.

Comparison with Abstraction and Concretion in Nominal Sets
Abstraction [i] a for an element a of a nominal set A and a name i (see [7]) is defined as the equivalence class obtained by swapping i with a name j in the pair ⟨i, a⟩, for all possible names j not in the support of a. This is quite the idea of representing the axioms of α -conversion, while the idea of shifting names, and calling the bound name 0, is typical of the De Bruijn indexes approach [4]. Nevertheless, objects obtained from the two constructions are isomorphic by theorem 2.13.
On the other hand, the freshness relation i#a in nominal syntax is defined as the set of elements a paired with names i which are fresh for a, i.e. not in its support. This is a nominal set when equipped with the ordinary action of the permutation on the product. Observing the conclusion of section 4.2, the nominal set of freshness is isomorphic to the object F (A). Hence, the adjunction associated to the definition of the right shift theory morphism provides a proof of the adjunction between abstraction and concretion in the setting of nominal sets.
To illustrate how De Bruijn indexes are obtained using δ, we show an encoding of the syntax of the λ-calculus. We assume finite products and coproducts to be defined in FSAlgπ (these functors are trivially lifted from Set, defining the permutation operation pointwise), and, given a finite coproduct X0 + X1 + ... + Xn we denote
its elements with  ⟨i, x⟩ i ∈ {0,..., n}∧ x ∈ Xi .
Example 4.12 (De Bruijn indexes) Consider the set of λ-calculus terms, deﬁned by the syntax L ::= λx.L | LL | x, for x ∈ ω. Instead of introducing the notion of α- equivalence for terms, we can deﬁne the syntax as the term algebra Λ of the functor T, i.e. as an arrow in FSAlgπ of type T (X) → X, where T (X) = δ (X)+X×X+ω, and ω is seen as a permutation algebra with πω (i) = π (i). Notice that, being T a functor in FSAlgπ, an action of the permutation πΛ on Λ is deﬁned by initiality using πω as the base case, thus introducing support, symmetry and orbits of elements. An interpretation f of λ-terms as elements of Λ is given in ﬁgure 2.
The most important case is the usage of hidx to deﬁne f (λx.l): it shifts all
names of l by one, and assigns the name 0 to the bound name. There is more: all the α-equivalent terms of the form λy.l [y/x] are translated into the same element t of Λ, where name 0 is not “visible” in suppΛ (t), and permutations can not exchange it with any other. This corresponds to a notion of “capture-avoiding permutation” for Λ. In fact, by theorem 4.1, we have suppΛ (t) = suppλ (f (t)) \ {x}.

Remark 4.13 As a side result of this work, we observe that the concretion oper- ation of Gabbay and Pitts, which closely resembles the reveal connective of spatial logics such as [19,20], arises as the counit of the adjunction. The action of the counit is ϵA (⟨a, ρ⟩) = ρA (a). Notice that ρ is also applied to name 0, differently
from the action of ρ in δ (A). Let ρ (i) = 0,ρ (0) = i, with i ∈/ suppA (a). We
have ϵA (⟨a, ρ⟩) = a i/0 : the hidden name 0 is “bound” by ρ to the fresh i, using a morphism of the category. This operation is not trivial: names of ρA (a) are pos- sibly more than names of a ∈ δ (A), hence by lemma 2.12 such an operation must have, as a domain, at least F (δ (A)). Even though it is not a major concern in this work, and the topic should be developed in detail, ﬁnding a place in the diagram for a reveal operation clariﬁes the formal relationship between the dual notions of abstraction and freshness, and that of revelation. This relationship can easily be mistaken, since these notions have often been jointly used.
Coalgebras over Nominal Sets for the Semantics of Name Passing Calculi
In this section, we show how δ can be used to express the early semantics of the π-calculus as a coalgebra in FSAlgπ, hence in nominal sets. We closely follow [12], where the early semantics of the π-calculus is given in the form of Structural Operational Semantics rules, implicitly defining a functor for the π-calculus. Results in [16] ensure a lifting of the semantics from the category Set to the category Algπ that respects axioms, obtaining a bialgebra where the algebraic operations and axioms are those of the permutation signature.
Our contribution here is to give an explicit form for the functor employed in [12], which is T (X) = Pfs (L' × X + L'' × δ (X)), where L' and L'' are disjoint, and Pfs is a finitely-supported variant of the power set functor. By posing L = L' ∪ L'', and using the embedding of X into δ (X), one could just define T (X) = Pfs (L× δ (X)). Notice how the latter is much closer to ordinary labeled transition systems in Set, than many definitions of endofunctors in presheaf categories. A possible reason is that in SetI each process is given a “type” representing its support, thus the semantics carries some redundant information that is missing in its untyped counterpart, nominal sets, and can be discarded without loosing full abstractness.
The contribution of this section might thus be summarized as showing that the category of nominal sets, together with the abstraction functor, allows one to enrich in a natural way ordinary labeled transition systems with operators for dynamic allocation of names.
Hiding for the early semantics of the π-calculus
For ⟨A,{πA}⟩ permutation algebra, and S ∈P (A), let the action of a permutation on any subset of A be defined as πP(A) (S) = {πA (a) | a ∈ S}, extended to a power set endofunctor in Algπ. The countable power set functor Pω can then be defined as in Set. However, it does not restrict to an endofunctor in FSAlgπ. For example, the set of odd numbers is not finitely supported as an element of Pω (ω).




rule 1:
X =⇒l	X'

for l ∈ L'	rule 2:
X bo=ut(x) X'


ρ (X) =ρ(l) ρ  X' 

ρ (X) ρ(b=out(x)) ρ+1 X' 


Fig. 3.


p −τ→ p'
xy
p −→ p
x¯y
p −→ p
x¯(y)
−→ p



p −ta→u f p'


in(x,y)
p −→ f p


out(x,y)
p −→ f p
bout(x)
p −→ f
hidy
 p' 


Fig. 4.


This motivates the definition of a countable ﬁnitely supported power set, which we denote with Pfs. Elements of Pfs (A) are all the elements of Pω (A) having the finite support property.
The definition of Pfs actually addresses a potential question that might arise on the results in [12]: the lifting of the semantics is to Algπ, not FSAlgπ. However, the theorem is applied to ensure that a final coalgebra semantics of the early π-calculus
exists as a finitely supported permutation algebra. The reason why this holds is that FSAlgπ is a full subcategory of Algπ, hence the image of each morphism yields a finitely supported algebra out of any finitely supported algebra.
In the following, we define two permutation algebras of labels, with x and y ranging over ω, having syntactic substitution as the permutation action πL: L' with carrier {tau, in (x, y) , out (x, y)} and L'' with carrier {bout (x)}.
A transition speciﬁcation [16] is a set of “meta-rules” that specify the possible format of transition rules, allowing the transition system to lift from Set to an appropriate category of algebras. The transition specification Δπ for the π-calculus given in [12] can be found in figure 3. These rules describe the action of algebraic operations on transitions, obtaining a bialgebra in Algπ.

Theorem 5.1 Let T (X) = Pfs (L' × X + L'' × δ (X)). A transition function in
FSAlgπ is a coalgebra for T if and only if it respects Δπ.

This shows that δ is essentially the only addition needed to represent the early semantics of the π-calculus in a purely coalgebraic way. In FSAlgπ, bisimulation for the early π-calculus is the coalgebraic notion, without any side condition on bound names, due to proper handling of fresh names.
Let Pi denote the permutation algebra of π-calculus agents whose permutation action is defined as the standard notion of substitution. An arrow f : Pi → T (P i) representing the semantics of the π-calculus is described by the rules in figure 4. As in [12], we employ the transition system in Set in premises of the rules. Notice that permutation σ, applied to p' in rule for bound output in [12], corresponds exactly to
hidy (p'), hence the coalgebra provided there is the same as the one we introduced.

Named Sets and HD-Automata
Named sets with symmetries arise from permutation algebras, after observing the effectiveness of this model to faithfully represent the semantics of name-passing calculi, but the failure to re-use names, that is, to model garbage collection. Named sets are a computationally efficient representation of permutation algebras (thus, of nominal sets and Schanuel topos), allowing systems represented as coalgebras in this category to be minimized and verified. The theory of named sets has been developed in various stages, however it can be captured, a posteriori, by two basic facts.
The first distinguishing feature of the category is locality of names: the meaning of a name is not assumed to be globally known, but rather relationships between names of different elements are established locally by morphisms of the category. For this reason, elements that are on the same orbit can be safely identified. This way, garbage collection is modeled.  Consider for example the π-calculus agent P (a) = (νx) a¯x.P (x). Due to freshness of names, the standard LTS semantics can
reach all the states in the (infinite) orbit  P (x) x ∈ ω . Identifying all elements of an orbit, we just have one state in the system, P (a). The transition function has an associated “relocation” function for names, that at each step discards names
that are no longer used, and at the same time can allocate a new one.
The second novel aspect of named sets is based on the observation that the essence of permutation algebras lies in the symmetry of orbits. Two objects that have isomorphic sets of orbits, and for each pair of orbits in the isomorphism, a pair of elements with the same symmetry, are isomorphic in turn as objects of the category, as shown in theorem 2.13.
From this fact, and theorem 2.14, comes the representation of named sets: they are sets whose elements have an attached group of permutations, acting, for each element, on a finite set of names. Arrows of the category reflect this structure: they are total functions, equipped with injective renamings that “go backwards” and represent history of names: hence the name of history-dependent automata for the coalgebras of this category.

Named Sets
Here we present the category NSet, as it was defined in [17]. Similarly to [14,15], we try to adopt a simpler notation, in particular omitting an ordering over elements, which is not needed here. We denote with  x∈S t(x) the set-theoretical dependent
product construction, i.e. the function space x → t(x) for x ranging over S and t(x)
a set, and with Aut (N ) the set of all permutations over the finite set N .
Definition 6.1 (named set) A named set N is a pair, consisting of a set QN and, for each element q of QN , a group of permutations SN (q) over a finite set Nq ⊂ ω:


N = ⟨QN , SN :
q∈QN
Aut (Nq)⟩

We can recover the support  −N : QN → Pfin (ω) as q  N = dom (SN (q)). The intuition is that each element of QN is the canonical representative of an orbit of a permutation algebra, up-to algebra isomorphism. The restriction of the symmetry of q ∈ QN to its support is described by SN (q). In virtue of theorem 2.14, it is not necessary to describe the action of the symmetry on names outside the support.
Definition 6.2 (named function) A named function F : N → M between named sets N and M is made up of a function hF , and for each element q of qN a set of

injective functions Σ
, each one with type  h  (q) inj  q

F	 F	 →  
F = ⟨h  : Q	→ Q  , Σ  :   P   h  (q) 	inj  q 	⟩

subject to the following additional constraints, for each q ∈ QN , and σ ∈ ΣF (q):
σ ◦ SM (hF (q)) = ΣF (q)
SN (q) ◦ σ ⊆ ΣF (q)

Condition (1) is equivalent to say that ΣF
is given by σ◦SM
(q) for σ :  (q)
inj
M →

ω. The intuition is that ΣF is a name mapping, tracing the history of names of q when mapped via hF . However, ΣF cannot be just the injective function σ, because that would distinguish names that are in the symmetry of hF (q). Thus, ΣF is an injective function, saturated by composition with SM (q).
Condition (2) has not been given a particularly intuitive meaning in previous work on named sets. We try here to explain its purpose: by substitution of (1) in

(2) we obtain SN (q) ◦ σ ⊆ σ ◦ SM (hf (q)), then SN (q)|

cod(σ)
⊆ σ ◦ SM (hf (q)) ◦ σ−1.

This is the same as thesis of theorem 2.11, asserting that symmetry grows along morphisms: violating this condition would result in named functions that do not represent permutation algebra morphisms. Due to locality of names, the symmetry
SM has to be translated to the domain of SN exploiting the name mappings σ ∈ Σ and σ−1, in order to allow the two to be compared.
Definition 6.3 (identity and composition) The identity named function is idN =
⟨idQN , λq.SN (q)⟩.  The composition of two named functions F : N → M and
G : M → O is given by G ◦ F = ⟨hG ◦ hF , Σ⟩, where Σ (q) = ΣF (q) ◦ ΣG (hf (q)).
The proof that composition of named functions yields a named function, hence that named sets and named functions form a category, can be found in [18].
A further explanation can be given for names as modeling a number of local
resources attached e.g. to a state of a system, and for symmetries as denoting indistinguishability of some resources. The backward set of name mappings in a named function traces the history of resources along the function, in particular identifying those that are preserved, and those that are discarded.
We recall the following theorem, proved as proposition 29 in [14].
Theorem 6.4 The categories NSet and FSAlgπ are equivalent: there exist two functors E : NSet → FSAlgπ and G : FSAlgπ → NSet such that the compositions G ◦ E and E ◦ G are isomorphic to the two identity functors.

The meaning of the above theorem is that there exist constructions to obtain a permutation algebra from a named set, and conversely a named set from a permu- tation algebra, in such a way that going in one direction, and then back, gives an isomorphic object. We introduce the functor G, used in theorem 7.3.
Definition 6.5 G sends A = ⟨A,{πA}⟩ to NA = ⟨Ao, SN ⟩, where SN (ao) =

GA (ao)

|suppA(ao)
. For f : A → B, let ρ be such that ρB (f (ao)o) = f (ao). G

sends f to F = ⟨hF , ΣF ⟩, where hF (ao) = f (ao)o, and ΣF (ao) = ρ ◦ SN (f (ao)o).
Notice that composition with the symmetry of f (ao)o restricts the permutation

ρ, (whose inverse normalizes f (ao)) to suppB (f (ao)o) =  f (ao)o
G(B)
, turning it

into a bijection from this set to suppB (f (ao)) ⊆ suppA (ao) =  ao G(A), as required by definition 6.2. We also recall the definition of E, to explain locality of names.
Definition 6.6 The functor E acts on each object N , returning AN = ⟨AN , {πN }⟩, where AN = {⟨q, ρ◦ SN (q) | q ∈ QN ,ρ ∈Autf ⟩}, and πN (⟨q, I⟩) = ⟨q, π ◦ I⟩. E acts on each arrow F returning the morphism f (⟨q, I⟩) = ⟨hF (q) ,I ◦ ΣF (q)⟩.
The point is that, when mapping back a named set to a permutation algebra, the whole orbit that q ∈ QN represents is reconstructed by the permutation action πN . Thus, one has the choice of a permutation ρ which maps the local names  q  N of q to ω, giving a global meaning to them: actually, employing the above definition, it is
easy to see that suppAN (⟨q, ρ◦SN (q)⟩) = ρ (  q  N ). Composition of the permutation ρ with SN (q) ensures that the obtained permutation action πN respects the sym- metry of q itself. A morphism follows the mapping ρ, by just “carrying it on” using
the history of names ΣF : we have f (⟨q, ρ ◦ SN (q)⟩) = ⟨hF (q) ,ρ ◦ SN (q) ◦ ΣF (q)⟩. The initial choice of ρ uniquely determines the mapping of local names in elements of the destination of F .
Remark 6.7 The necessity to choose a permutation ρ expresses precisely the notion of locality of names. As a practical example, consider the addition of a fragment of code to an existing program. The ﬁrst thing a programmer should do is to rename all free variables of the pasted fragment, in order to avoid name clashes. In doing so, one can as well rename the variables of the whole target program, without affecting the meaning of the composition, provided that clash is avoided. This is the same as stating, in our terminology, that the free variables of a program fragment are local names, and their global meaning has to be established when it is needed.
Abstraction for Named Sets and Garbage Collection
In this section we define the endofunctor of abstraction in named sets, which we call H (standing for “hiding”). In section 7.1, we give the formal definition, and a theorem that establishes a correspondence with the definition in FSAlgπ, exploiting the equivalence result given in [14]. Then, in section 7.2, we give an account on how unused names are discarded, by means of some example, to the aim of motivating the main “slogan” we would like to propose in this work: named sets are nominal sets plus garbage collection.

The Abstraction Functor in NSet
Abstraction can be defined in named sets with the aid of theorems 4.1 and 4.6.
The underlying set QH(N ) resulting from the action of H on an object N is the union of QN itself, representing the orbits of the old elements of definition 4.3, and a set of pairs ⟨q ∈ QN ,i ∈ q  N ⟩, representing the orbit of the ith hidden element. Intuitively, i marks the ith name of q as hidden. As we did in theorem 4.6, the possible values for i have to be quotiented using the symmetry of q. We pose i ≡q j ⇐⇒ ∃π ∈ SN (q) .π (i) = j, and define
QH(N ) = QN ∪ ⟨q, i⟩ q ∈ QN ,i ∈ (  q  N ) /≡q ,
For readability, in all the following definitions, we implicitly assume the pattern matching on q and ⟨q, i⟩ to have the additional constraint q ∈ QN , to avoid clashes. The symmetry of elements of the form ⟨q, i⟩ is defined as the subgroup of the symmetry of q that fixes i (which we denote with gfix (SN (q) , i)) according to theorem 4.1. This symmetry is opportunely restricted in order to exclude i from the support. We thus pose SH(N) (q) = SN (q), and

SH(N) (⟨q, i⟩) =gf ix (SN (q) , i)|
q  N \i
The action of H on arrows maps F : N → M to H (F ) =  hH(F ), ΣH(F ) . A pair
⟨q, i⟩ is mapped by hH(F ) to a pair ⟨hF (q) , j⟩ if and only if j is mapped by some injection in ΣF (q) into i, that is, if and only if i is still present in the destination hF (q), according to the history of names ΣF (q). We have hH(F ) (q) = hF (q), and



hH(F )
(⟨q, i⟩) =	⟨hF (q) , j⟩	if ∃σ ∈ ΣF (q) .σ (j) = i hF (q)	otherwise

Notice that j stands for its canonical representative in ≡hF (q). For hH(F ) to be well-defined, we have to show that it respects the equivalence relation on hidden names. This comes from condition (1) in the definition of a named function: for each σ ∈ ΣF (q) we have ΣF (q) = σ ◦ SM (hF (q)). If there exist σ' ∈ ΣF (q) and j' /= j such that σ' (j') = i, then at least a permutation exchanging j and j' belongs to SM (hF (q)), hence j and j' are quotiented by the equivalence relation. The mapping ΣH(F ) is defined as ΣH(F ) (q) = ΣF (q), and



ΣH(F )
(⟨q, i⟩) =	σ|dom(σ)\j σ (j) = i ∧ σ ∈ ΣF (q)	if hH(F ) (⟨q, i⟩) = ⟨hF (q) , j⟩
ΣF (q)	otherwise


When an hidden name is preserved by ΣF (q) we take the subset of ΣF (q) that sends j into i, restricted so that j is not mapped at all. This is the same as taking


dom(σ)\j
G', where G' is the subgroup of SM (hF (q)) fixing j. This follows the

correspondence with algebras, and in particular theorem 4.1.
Now we summarize the contents of this section in the following definition.



Fig. 5.

Definition 7.1 The abstraction functor H : NSet → NSet is defined on objects as H (N ) = ⟨QH(N ), SH(N)⟩, and on arrows as H (F ) =  hH(F ), ΣH(F ) .
Theorem 7.2 H is a functor.
Finally, we show that δ and H are related by an isomorphism of functors.
Theorem 7.3 The two functors G ◦ δ and H ◦ G are isomorphic, i.e. there exists a natural transformation ι : G ◦ δ → H ◦ G such that each component ιN is an isomorphism in NSet.

Garbage Collection
Consider the definition of hH(F ) (⟨q, i⟩) in the abstraction functor for named sets and observe that, when the hidden name i is discarded along a morphism, the resulting element is just q. This introduces garbage collection, allowing the semantics to reuse old states whenever a fresh name is discarded. We now attempt to give an intuition of this fact by the means of two examples in π-calculus. We ignore labels of transitions, since these do not contribute to the intuition, and we omit to denote the power set, because both systems are deterministic. When representing HD- automata, we draw the backward mappings of names, together with supports of states, side by side with the transition function. Since the symmetry of both the agents we present is just {id}, a backward mapping Σ is represented by a single function.

Consider the agent P (1) = (νx) 1x.P (1). Even though it has no memory of the past, thus after just one step there are no more free names to be discarded, the permutation algebra semantics of the system reaches all the (infinite, count- able) elements in the orbit of 4 P (1). Figure 5 depicts a sketch of its permutation algebra semantics, compared to its HD-automaton, which is a simple loop. The transition (named) function tr = ⟨htr, Σtr⟩ acts on P (1) (intended as the canonical representative of its whole orbit) as htr (P (1)) = {P (1)}, Σtr (P (1)) = {id{1}}.

4 So does the nominal sets semantics, even when employing the abstraction functor of Gabbay and Pitts. We omit such an example for space reasons.



Fig. 6.
Now let R (1) = (νx) ¯1x.R (x). Consider a presheaf semantics for the π-calculus. On the left of each state, we draw in figure 5 the least stage (object of the base category) in which the state is found at all (the categorial support of the element, as it is called in [14]), and the stage in which the coalgebra is applied to it. Recall that, given a presheaf T , the functor δ : SetI → SetI is defined on objects as δ(T ) (X) = T (X ⊕ 1). To distinguish the different instances, in the successive applications of the coproduct, of the only element ∗∈ 1 (the final object of I), we denote it with ∗', ∗'' and so on. In the same figure, we can find the HD-automata semantics of R (1). The HD-automata semantics is now made up of two states, since in the first step the free name a has to disappear. The transition function is htr (R (1)) = {⟨R (1) , 1⟩}, thus hiding name 1, and htr (⟨R (1) , 1⟩) = {⟨R (1) , 1⟩}. We have the name mapping Σtr (R (1)) = Σtr (⟨R (1) , 1⟩) = {∅}, the empty name mapping. This is required since the support of the destination is empty.
What both permutation algebras and functors in SetI lack, is a mechanism to discard unused names using a quotient operation: on orbits, in the case of permu- tation algebras, on isomorphic categorial supports, in the case of presheaves.
These examples should explain what we mean with locality of names. In particu- lar, notice how the backwards name mappings of named functions trace the history of names along morphisms, allowing the semantics to reuse the same state with different names. One might wonder if this is just a trick and, in the end, one has to perform an “unfolding” of the HD-automata semantics into the ordinary LTS se- mantics to implement algorithms such as bisimulation checking or model checking. Results in [18] for minimization and bisimulation checking, and work in progress on the model checking side, show that this is not necessary, and the model can be used “as is” to verify systems up-to garbage collection.

Conclusions and Future Work
We have provided the necessary theory to take in account garbage collection in nominal models of computation, by defining a suitable abstraction functor in the category of named sets. This is essential for the definition of algorithms to handle the syntax and the semantics of name passing calculi. We have also shown that, using the algebraic definition of nominal sets, a very simple theory morphism induces

a number of commonly used operations in the category of nominal sets: name abstraction, the freshness relation, and the concretion, or reveal, operation.
Future work includes the study of other behavioral functors on named sets, and the proof of a final coalgebra theorem for their composition. The definition of adequate modal logics, and of an efficient model checking algorithm, is yet to be
done on history dependent automata with symmetries (even though work in progress
is promising). In this light, it is useful to define generic functors on named sets, in order to define modal logics using Stone duality. The approach proved fruitful
to express the logical semantics of nominal calculi [24], and could be applied to coalgebras over named sets to obtain a generic, algorithmic model for calculi with name passing.
In [18], the group-theoretical notion of generators is exploited to give a compact
representation of elements of named sets in terms of the symmetry of orbits. To improve the minimization algorithm, and in perspective for model checking, effi- cient group-theoretical algorithms over generators could be employed. We plan to investigate the adoption of algorithms described in [25] to this aim.
Finally, the relationship between the counit of the adjunction, and spatial oper- ators over names such as those in [19,20] should be studied in detail.

References
Milner, R., Parrow, J., Walker, D.: A calculus of mobile processes, part i. IC 100(1) (1992) 1–40
Milner, R., Parrow, J., Walker, D.: Modal logics for mobile processes. TCS 114(1) (1993) 149–171
Dam, M.: Model checking mobile processes. LNCS 715 (1993) 22–36
de Bruijn, N.: Lambda-calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser Theorem. Indag. Mat. 34(5) (1972) 381–392
Fiore, M., Plotkin, G., Turi, D.: Abstract syntax and variable binding. In: LICS. (1999) 193–202
Gabbay, M., Pitts, A.: A new approach to abstract syntax involving binders. In: LICS. (1999) 214–224
Gabbay, M., Pitts, A.M.: A new approach to abstract syntax with variable binding. FAC 13(3-5) (2002) 341–363
Pitts, A.M.: Nominal logic: A first order theory of names and binding. LNCS 2215 (2001) 219–242
Cattani, G.L., Stark, I., Winskel, G.: Presheaf models for the π-calculus. In: CTCS. (1997) 106–126
Fiore, M.P., Moggi, E., Sangiorgi, D.: A fully abstract model for the π-calculus. IC 179(1) (2002) 76–117
Montanari, U., Pistore, M.: pi-calculus, structured coalgebras, and minimal hd-automata. In: MFCS. (2000) 569–578
Montanari, U., Pistore, M.: Structured coalgebras and minimal hd-automata for the π-calculus. TCS
340 (2005) 539–576
Pistore, M.: History Dependent Automata. PhD thesis, Universit`a di Pisa, Dipartimento di Informatica (1999) TD-5/99.
Gadducci, F., Miculan, M., Montanari, U.: About permutation algebras, (pre)sheaves and named sets.
HOSC 19(2-3) (2006) 283–304
Fiore, M., Staton, S.: Comparing operational models of name-passing process calculi. IC 204(4) (2006) 524–560

Corradini, A., Heckel, R., Montanari, U.: Compositional sos and beyond: a coalgebraic view of open systems. TCS 280(1-2) (2002) 163–192
Ferrari, G.L., Montanari, U., Pistore, M.: Minimizing transition systems for name passing calculi: A co-algebraic formulation. In: FoSSaCS. (2002) 129–158
Ferrari, G.L., Montanari, U., Tuosto, E.: Coalgebraic minimization of hd-automata for the pi-calculus using polymorphic types. TCS 331(2-3) (2005) 325–365
Caires, L., Cardelli, L.: A Spatial Logic for Concurrency (Part I). IC 186(2) (2003) 194–235
Caires, L.: Behavioral and spatial properties in a logic for the pi-calculus. In: FoSSaCS. (2004) 72–89
Klin, B.: Coalgebraic modal logic beyond sets. In: MFPS. (2007) 177–201
Goguen, J.A., Burstall, R.M.: Institutions: Abstract model theory for specification and programming.
J. ACM 39(1) (1992) 95–146
Rydeheard, D.E., Burstall, R.M.: Computational category theory. Prentice Hall (1988)
Bonsangue, M.M., Kurz, A.: Pi-calculus in logical form. In: LICS. (2007) 303–312
Luks, E.M.: Permutation Groups and Polynomial Time Computation. DIMACS DMTCS 11 (1993) 139–175
