Electronic Notes in Theoretical Computer Science 125 (2005) 55–66  
www.elsevier.com/locate/entcs


Deciding the Security of Protocols with Commuting Public Key Encryption *

Yannick Chevaliera,1	Ralf Ku¨stersb,4	Micha¨el Rusinowitcha,2 Mathieu Turuania,3
a LORIA-INRIA, France
54506 Vandoeuvre-les-Nancy cedex, France
b Department of Computer Science, Stanford University, Stanford CA 94305, USA


Abstract
Many cryptographic protocols and attacks on these protocols make use of the fact that the order in which encryption is performed does not affect the result of the encryption, i.e., encryption is commutative. However, most models for the automatic analysis of cryptographic protocols can not handle such encryption functions since in these models the message space is considered a free term algebra. In this paper, we present an NP decision procedure for the insecurity of protocols that employ RSA encryption, which is one of the most important instances of commuting public key encryption.
Keywords: Cryptographic Protocols, Extension of Dolev-Yao Model, Deduction modulo and Complexity.



 This work was partially supported by PROCOPE, by the DFG, and by the FET Open Project IST-2001-39252 “AVISPA: Automated Validation of Internet Security Protocols and Applications”, http://www.avispa-project.org/.
1 email: chevalie@loria.fr
2 email: rusi@loria.fr
3 email: turuani@loria.fr
4 email: kuesters@theory.stanford.edu


1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.05.019

Introduction

Most automatic analysis techniques for security protocols take as a simpli- fying hypothesis that the cryptographic algorithms are perfect: One needs the decryption key to extract the plaintext from the ciphertext, and also, a ciphertext can be generated only with the appropriate key and message (no collision). Under these assumptions and given a bound on the number of protocol sessions, the insecurity problem is decidable (see e.g. [1,15,5,10]). However, it is an open question whether this result remains valid when the in- truder model is extended to take into account even simple algebraic properties of low-level cryptographic primitives. This question is important since many security flaws are the consequence of these properties and many protocols are based on these operators (see, e.g., [16,14]).
Only recently the perfect encryption assumption for protocol analysis has been slightly relaxed. In [12], unification algorithms are designed for handling properties of Diffie-Hellman cryptographic systems. Although these results are useful, they do not solve the more general insecurity problem. In [7,8], decidability of security has been proved for protocols that employ exclusive or. In [6], we have extended this result to protocols that are based on Diffie- Hellman exponentiation. Diffie-Hellman exponentiation has also been studied in [13] and [3]. However, in the former work no decision procedure is provided and in the latter severe restrictions are imposed on the protocol and intruder model.
In this paper, we show that the insecurity problem for protocols that use commuting public-key encryption operators (such as RSA encryption with common modulus) admits an NP decision procedure for a finite number of sessions (see the main result in Section 4). In Section 2, we present a very simple protocol illustrating that protocols and attacks on these protocols may rely on the commutativity of encryption.
This problem can be related to the analysis of Diffie-Hellman protocols as studied in [6] since Diffie-Hellman exponentiation and commuting public-key encryption, which in case of RSA also involves exponentiation, share algebraic properties. However, there are significant differences.
First, the intruder capabilities differ. In case of public-key encryption the intruder is not able to compute the inverse of exponents, e.g., given a public key (n, e) and a cipher text c = me mod n, the intruder can not compute the private key d and then by computing cd mod n obtain m. Conversely, in the Diffie-Hellman setting, exponentiation is done modulo a publicly known prime, and thus, it is computationally feasible to compute the inverse of exponents, e.g., given m = ga·b and b where g generates the multiplicative group induced


by the prime p, the intruder can easily invert b modulo p − 1 obtaining b−1 (in case an inverse exists) and by computing mb−1 obtain ga.
Second, in [6] the intruder can not obtain inverses of messages, such as b−1 directly, but only use them in exponents. However, in the public-key setting we consider here, this would be unrealistic since inverses correspond to private keys, and of course, we need to allow the intruder to possess such keys (own private keys and private keys of dishonest principals).
As a result of these differences, the proofs differ as well. First, while roughly speaking in [6] we reduce the insecurity problem to solving linear equations in integers, we now obtain linear equations in non-negative integers. Also, we need to extend the intruder to allow private keys in her possession. To minimize the changes necessary compared to the proof in [6], we consider private keys as atomic messages and extend the normalization function to make sure that in exponents public and private keys cancel each other out. This allows us to lift the proofs presented in [6] to the setting considered here.

Examples of Protocols Relying on Commutative En- cryption
Let us illustrate by two simple examples given in [17] how commutative proper- ties of public key encryption schemes are employed in cryptographic protocols. The first protocol is due to Shamir. The aim of this protocol is to permit secure communication between two agents who neither share a symmetric key nor know the public key of the other agent. The protocol uses the commuta-
tivity property of the RSA encryption scheme:
A → B : {secret}p
B → A : {{secret}p	p
A → B : {secret}p
In this protocol, a common RSA modulus n is assumed. The public key of A is (n, KA) and the one for B is (n, KB). The message secret is some non-negative
integer < n. The term {secret}p	stands for secretKA mod n. By the algebraic
KA
p	p	p	p
properties of exponentiation, we have that {{secret}K }K = {{secret}K }K .

In step 3 of the protocol, A computes {{{secret}pA }pB }p	=
B  pA

KA  KB	'
{secret}K

where K'
is A’s private key. Thus, the protocol itself uses the commutativity

of encryption. Since B is not authenticated in this protocol, it is obvious that the intruder I can impersonate B, by simply playing B’s role while using her own public key KI.
A commutative public key encryption scheme or signature scheme may


also be relevant in the case of group protocols. Inspired by the protocol given in [17], Chapter 23, consider a group of l agents. A trusted server generates two large prime numbers p and q, computes n = p · q, and l +1 numbers k0,... , kl such that:
k0 ··· kl ≡ 1 mod (p − 1) · (q − 1)
Each agent Ai, 1 ≤ i ≤ l, receives the public keys Kj = k0 · ... · kl · kj−1 for every j and the private key ki. Note that



and in particular,
p
k0 ···kl


{{M }p }p
= M,

= M.

ki Ki
Once the key distribution is completed, a message can be signed by a subset
{Ai}i∈I,I⊆[1,..,l] of the members of the group. For example, suppose l =4 and A1 wants to sign a contract, say the message M , with A2 and A4. A possible message sequence is:
A1 → A2 : {M }p
A2 → A4 : {{M }p }p
k1 k2
A4 → A1 : {{{M }p }p }p
k1 k2 k4
On receiving the second message, A4 can verify the signatures and identity the agents that have signed M by testing whether


{{{{M }p }p }p }p
= {{{{M }p }p
}p }p
= M.

k1 k2
K1  K2
k1 K1 k2 K2

Agent A4 can then also sign the contract using her private key k4. The point here is that due to the commutativity property, A4 does not need to know in what order the agents signed the message. Certainly, this protocol, when for instance used as a contract signing protocol, has many problems, which, however, we do not want to discuss here.

The Protocol and Intruder Model
The protocol and intruder model we describe here extend standard models for automatic analysis of security protocols in two respects. First, messages can be built using the operator { }p, which stands for encryption by a multiset of public/private keys described as a product of public/private keys. For in-

stance, we have that {{m}p	p
p
KA·KB
p
KB ·KA
= {{m}p	p


In particular, we can model the commutativity of public key encryption. Sec- ond, in addition to the standard Dolev-Yao intruder capabilities, the intruder is equipped with the ability to perform this generalized encryption with any set of public or private keys she knows (we even allow arbitrary messages).

For instance, if she happens to know A’s private key K'
and the message

c = {m}p  , then she can compute {c}p '  = {m}p	'  = {m}p
= m. In

KA	KA	KA·KA	1
what follows, we provide a formal definition of our model by defining terms,
messages, protocols, the intruder, and attacks.
Terms and Messages
The set of terms term is defined as the union of roots (also called standard terms) and products (also called non-standard terms) in the following gram- mar:

root ::= A|V | ⟨root, root ⟩ | {root}s
p
product

product ::= root IN | root IN · product
where A is a finite set of constants (atomic messages), containing principal names, nonces, keys, and the constants 1 and secret; K is a subset of A denoting the set of public and private keys; V is a finite set of variables; and IN is the set of non-negative integers. We assume that there is a bijection ·' on K which maps every public (private) key k to its corresponding private (public) key k'. The binary symbol ⟨·, ·⟩ is called pairing, the binary symbol {·}s is called symmetric encryption, the binary symbol {·}p is public key encryption. Note that a symmetric key can be any standard term and that for public key encryption the key can be any non-standard term (product). The non-negative integers occurring in products are called product exponents.
Envision a term t as a tree structure where each internal node is labelled by a constructor and each leaf is either a variable or a constant. A term u is a subterm if the tree representing u is a subtree of the tree representing t and if u is a root term. We note Sub(t) the set of subterms of a term t. By extension if E is a set of terms we note Sub(E) the union for t ∈ E of the sets Sub(t).
The size of a term t is denoted |t| and is the size of the representation of t by a labelled DAG (Directed Acyclic Graph). It is linear with respect to the cardinal of Sub(t) plus the space needed to represent the coefficients in binary.
A ground term (also called message) is a term without variables. Like a term, it can be standard or non-standard. A (ground) substitution is a mapping from V into the set of standard (ground) terms. The application of a substitution σ toa term t (a set of terms E) is written tσ (Eσ), and is defined as expected.


We now formulate the algebraic properties of terms. Besides commutativ- ity and associativity of the product operator we consider the following prop- erties where t is a standard term, M1, M2 are products, k ∈ K, k' is the corresponding inverse key to k, and z, z' are non-negative integers:
t1 = t	t · 1 = t	{t}p = t

t0 = 1	tz · tz' = tz+z'	{{t}p	p
p M1·M2

1z = 1	k · k' = 1 
A normal form t’ of a term t is obtained by exhaustively applying these identities from left to right. Note that t’ is uniquely determined up to com- mutativity and associativity of the product operator. Two terms t and t' are equivalent if t’ = t'’. The notion of normal form extends in the obvious way to sets of terms and substitutions. We illustrate the notion of a nor- mal form by some examples: If a, b, c, d ∈ K, then i) (a2 · b1) · b'2’ = a2 · b',
ii) {{a}p	}p	’ = {a}p	, and iii) {{a}p	}p ’ = a. Recall that, for

b1·c1
c'·d'2
b·d'2
b3·c'6 ·b'3  c6

instance, b' denotes the decryption key corresponding to b.
One easily shows:
Protocols
Protocols are defined as follows.
Definition 3.1 A protocol rule is of the form R ⇒ S where R and S are standard terms.
A protocol P is a tuple ({Ri ⇒ Si | i ∈ I}, <I, E) where E is a finite nor- malized set of standard messages with 1 ∈ E, the initial intruder knowledge, I is a finite (index) set, <I is a partial ordering on I, and Ri ⇒ Si, for every i ∈ I, is a protocol rule such that
the (standard) terms Ri and Si are normalized,
for all x ∈ V(Si), there exists j ≤I i such that x ∈ V(Rj), and

for every subterm {t }p
of R , there exists r ∈ {1,... , n} such that

1 tz2 ···tzn	i
2	n
V(tl) ⊆ ∪j<I iV(Rj) for every l ∈ {1,... , n}\ {r}.
Condition 1. in the above definition is not an actual restriction. One ob- tains an equivalent protocol (in the sense that the same attacks are possible) by normalizing the Ri and Si in the protocol rules in case they are not normal- ized already. Roughly speaking, Condition 2. guarantees that a principal can only output messages she has learned before. Finally, Condition 3. ensures that every single protocol rule can be applied deterministically to an input


message. These conditions do not seem to exclude realistic protocols. See [6] for more detailed remarks on the above conditions. Note that in our model, a protocol corresponds to a specification in the Alice&Bob notation together with an instantiation. As a result, several sessions are modelled as only one protocol.
In our protocol model, the RSA protocol (Section 2) can formally be stated as follows where we assume that A runs one instance of the protocol as initiator and B runs one instance as responder. The protocol consists of three protocol rules denoted (A, 1), (A, 2), and (B, 1) with
(A, 1) : 1 ⇒ {secret}p  ,
(A, 2) : x ⇒ {x}p ' ,	and
A
(B, 1) : y ⇒ {y}p
where (A, 1) and (A, 2) denote the first and second protocol step performed by
A, respectively, and (B, 1) denotes B’s protocol step. The partial ordering is
<= {((A, 1), (A, 2))}, i.e., it only satisfies (A, 1) < (A, 2), and thus, makes sure that (A, 1) must be performed before (A, 2). The initial intruder knowledge is {1, KI, K' }, i.e., besides the constant 1, the intruder knows her public and
private key.

The Intruder Model and Attacks
Given a finite normalized set E of messages, the (infinite) set forge(E) of messages the intruder can derive from E is the smallest set satisfying the following conditions:
E ⊆ forge(E).
If ⟨m, n⟩ ∈ forge(E), then m ∈ forge(E) and n ∈ forge(E). Conversely, if m, n ∈ forge(E), then ⟨m, n⟩ ∈ forge(E).
If {m}s ∈ forge(E) and n ∈ forge(E), then m ∈ forge(E). Conversely, if
m, n ∈ forge(E), then {m}s ∈ forge(E).

If m, m ,... ,m  ∈ forge(E), and z ,... ,z 
∈ IN then {m}p z	’ ∈

1	n	1	n
m 1 ···,mzn

1	n
forge(E).
While the first three conditions are standard for Dolev-Yao intruders, the last condition, which gives the intruder the ability to perform commuting public key encryption, is new. We call this extended intruder the RSA intruder. Note that by performing pubic key encryption, the intruder can both encrypt and decrypt messages. Also note that if E is a set of normalized messages, then so is forge(E).


We now define attacks. In an attack on a protocol P , the intruder (nonde- terministically) chooses some execution order for P , i.e., a linearization of the protocol rules which is compatible with the partial ordering, and then tries to produce input messages for the protocol rules. These input messages are derived from the intruder’s initial knowledge and the output messages pro- duced by executing the protocol rules. The aim of the intruder is to derive the message secret.
Definition 3.2 Let P = ({Rj ⇒ Sj | j ∈ I}, <I, S0) be a protocol. Then an attack on P consists of a linearization π : R1 ⇒ S1,... , Rk ⇒ Sk of the protocol rules in P assuming k = Card(I) which is compatible with <I and a normalized ground substitution σ of the variables occurring in P such that
Riσ’ ∈ forge( S0, S1σ, ..., Si−1σ’) for every i ∈ {1,... , k} and
secret ∈ forge( S0, S1σ, ..., Skσ’).
In Definition 3.2 we restrict ourselves to k = Card(I) for simplifying no- tations. Considering k < Card(I) would amount to detect attack even with partial (i.e. unfinished) sessions. This kind of attacks can be captured too by analyzing protocols with some final steps removed.
The decision problem we are interested in is the following set of protocols:
Insecure := {P | there exists an attack on P }.
It can easily be checked that the RSA-protocol as formally described in Sec- tion 3.2 is insecure according to our definition.

Main Theorem
The main result of this paper is the following:
Theorem 4.1 For the RSA intruder, the problem Insecure is NP-complete.
As mentioned in the introduction, the proof follows the same lines as the one for Diffie-Hellman exponentiation presented in [6]. Here we only provide a very brief proof sketch.
NP-hardness can easily be established (see for instance [1]). The decision procedure first guesses an execution order of the protocol rules and a ground substitution σ of size polynomially bounded in the size of the protocol, and then checks whether condition 1. and 2. of Definition 3.2 are met. This check can be done in polynomial time.
The completeness and the complexity of this procedure can be proved in two steps. First, we prove that it is possible to check in polynomial time w.r.t.


the sizes of P and σ whether a couple (π, σ) is an attack. Then we prove it is sufficient to consider substitutions σ of polynomial size w.r.t. the size of the protocol in order to prove whether there exists attacks on a given protocol P.
Deciding whether (π, σ) is an attack
We want to have a procedure with a time complexity polynomial w.r.t. the sizes of P and σ. Since in Definition 3.2 we have k ≤ |P|, it is sufficient to prove that:
for all terms t and all substitutions σ, we have:
| tσ’| ≤ |t| + |σ|
for every set of terms E and for all term m, it can be decided in polynomial time w.r.t. |E, t| if m is in forge(E).
The first point is a consequence of the definition of the normalisation function. We give now a sketch of the proof of the second point.
The deduction power of the intruder can be modelled by an infinite set of ground deduction rules l → r where l is a set of terms and r is a term. A set L of such rules defines a transition relation between sets of terms as follows. Let E and E' be two sets of terms, then we have E →L E' iff there exists l → r ∈ L such that l ⊆ E and E' = E, r. The set forge(E) can then equivalently be defined as the closure of E by the rules of L.
Let F be the set of constructors {⟨ , ⟩ , { }s, { }p}. The path followed in [4] is then to associate to each constructor f in F a system of rewrite rules Lf . The first result is that for each constructor f ∈ F, the transition relation between two sets E and F for the set of rewrite rules Lf can be decided in polynomial time w.r.t. |E, E'|. We just give here the proof for the commutative encryption operator { }p.

Proposition 4.2 Let E and E' be two sets of terms and f = { }p. Then
E →L E' can be decided in polynomial time w.r.t. |E, E'|.
Proof. First, we check that E ⊆ E' and E' \ E = {t}. Then let r be the root of t, and Er be the subset of E of terms of root r. For each u ∈ Er, compute pu, the product of t divided by the product of u. If each root term v in pu is in E, answer yes.
If no check succeeds, answer no.	 

Example.
Let E = a, {a}p	' , ka, k' , kb and F = E ∪ {{a}p  ' }. We want to decide
ka·kc	a	kb·kc
whether there exists a one-step transition from E to F . We have E ⊆ F and

F \ E = {{a}p } = {t}. The root of t is the constant a. The subset of E of
kb
p
terms of root a is Ea = a, {a}ka·k' .
For a, we take the product equal to 1. Thus, pa = kb · k' and since k' ∈/ E,
c	c
the check fails in this case;
For {a}p	' , we have:

ka·kc


p{a}p

= (kb · k' )/(ka · k' )= kb · k' · k' · kc = kb · k'

ka ·k'
c	c	c	a	a



In this case, kb ∈ E and k'
∈ E, and thus the check succeeds. The procedure

returns with the answer yes.
There is a transition from E to E' iff there exists f ∈ F such that E →L
E'. Thus, the one-step transition problem can be decided in polynomial time for the set of rewrite rules L = ∪f∈F Lf . We now consider the derivation problem:
DERIVE := {(E, m) | m ∈ forge(E)}
where E is a finite set of normalized standard messages and m is a normalized standard message (both given as DAG). It is equivalent to decide DERIVE and to decide whether there exists n sets of terms E1,... , En such that E1 = E and m ∈ En and for all i ∈ {1,... ,n− 1} we have Ei →L Ei+1. A fundamental result is that if there exists such a sequence of transitions, then there exists one such that En ⊆ Sub(E, m). The proof consists in considering a sequence of transitions of minimal length E1 →L ... →L En such that m ∈ En and to prove that each transition adds a subterm of E or of m. Such a transition sequence is called a normal proof in [8] or a well-formed derivation in [7]. Combining this result with Proposition 4.2, one obtains the following proposition:
Proposition 4.3 For the RSA intruder, DERIVE can be decided in deter- ministic polynomial time.
Proof. (sketch) The procedure consists in computing F = forge(E)∩Sub(E, m). We start with F0 = E, and Fi+1 is computed from Fi by adding all the terms t in Sub(E, m) such that there exists a transition between Fi and Fi, t. The computation stops as soon as Fi+1 = Fi. The existence of well-formed deriva- tion then implies Fi = forge(E) ∩ Sub(E, m). We have to decide a polynomial number of times a one-step transition problem. Thus, the total running time is polynomial w.r.t. |E, m|.	 

Bounds on |σ|
The involved part of the proof of Theorem 4.1 is to show that when there is an attack on a protocol P , then there exists an attack of size polynomially


bounded in the size of the protocol. This proof is done in two steps. First, it is shown that the number of subterms occurring in σ can polynomially be bounded in the size of P . Note that this does not bound the size of prod- uct exponents in σ. Therefore, in a second step, it is shown that the size of product exponents can polynomially be bounded in the size of P . This is done as follows: Given an attack with substitution σ, the product expo- nents in σ are replaced by variables (taking non-negative integers) yielding a symbolic substitution σZ. Now, we associate a linear Diophantine equa- tion system in non-negative integers (of polynomial size in P ) with the attack which constraints the variables in σZ (and auxiliary variables) such that when instantiating σZ by a non-negative solution of the equation system this also gives an attack on P . By [2], the size of the solutions can polynomially be bounded in the size of the equation system, and thus, P . This shows that the size of product exponents can polynomially be bounded in the size of P .

Conclusion
We have shown that the security problem for a class of protocols with commut- ing public key encryptions is in NP. This result was obtained by a reduction to the satisfiability of linear diophantine equations on IN . The result generalizes easily to the more common case where the set of keys yielding commuting encryption is a subset of the set of all keys. It would be interesting to charac- terize a class of algebraic properties that can be captured by our approach.

References
R. Amadio, D. Lugiez, and V. Vanackere. On the symbolic reduction of processes with cryptographic functions. Theoretical Computer Science, 290(1):695–740, 2002.
I. Borosh and L.B. Treybig. Bounds on positive integral solutions of linear Diophantine equations. In Proc. Amer. Math. Soc. 55, 299-304 (A6), 1976.
M. Boreale and M.G. Buscemi. On the symbolic analysis of low-level cryptographic primitives: Modular exponentiation and the Diffie-Hellman protocol. In Proc. of FCS 2003.
Y. Chevalier. R´esolution de probl`emes d’accessibilit´e pour la compilation et la validation de protocoles cryptographiques M´emoire de th`ese, Universit´e Henri Poincar´e Nancy 1, 2003.
Y. Chevalier and L. Vigneron. Towards Efficient Automated Verification of Security Protocols. In Proceedings of the Verification Workshop (VERIFY’01) (in connection with IJCAR’01), Universit`a degli studi di Siena, TR DII 08/01, pages 19–33, 2001.
Y. Chevalier, R. Ku¨sters, M. Rusinowitch, and M. Turuani. Deciding the Security of Protocols with Diffie-Hellman Exponentiation and Products in Exponents. In Proc. of FSTTCS 2003.
Y. Chevalier, R. Ku¨sters, M. Rusinowitch, and M. Turuani. An NP Decision Procedure for Protocol Insecurity with XOR. In Proceedings of the Logic In Computer Science Conference LICS’03, June 2003. Long version available as Technical Report RR-4697, INRIA, France.


H. Comon-Lundh and V. Shmatikov. Intruder Deductions, Constraint Solving and Insecurity Decision in Presence of Exclusive or. In Proceedings of the Logic In Computer Science Conference, LICS’03, pages 271–280, 2003.
R. Corin and S. Etalle. An Improved Constraint-based system for the verification of security protocols. In Proceedings of the 9th Int. Static Analysis Symp. (SAS), LNCS 2477, pp. 326-341, Springer-Verlag, 2002.
R. Ku¨sters. On the Decidability of Cryptographic Protocols with Open-ended Data Structures. In Proc. of CONCUR 2002.
R. Ku¨sters and T. Wilke. Automata-based Analysis of Recursive Cryptographic Protocols. In Proc. 21st Symposium on Theoretical Aspects of Computer Science (STACS 2004a), LNCS 2996, pages 382–393, Springer-Verlag, 2004.
C. Meadows and P. Narendran. A unification algorithm for the group Diffie-Hellman protocol. In Proc. of WITS 2002.
J. Millen and V. Shmatikov. Symbolic protocol analysis with products and Diffie-Hellman exponentiation. In Proc. of CSFW 16, 2003.
O. Pereira and J.-J. Quisquater. A Security Analysis of the Cliques Protocols Suites. In
Proc. of CSFW-14, pages 73–81, 2001.
M. Rusinowitch and M. Turuani. Protocol Insecurity with Finite Number of Sessions is NP- complete. In Proc. of CSFW-14, pages 174–190, 2001.
P. Ryan and S. Schneider, An attack on a recursive authentication protocol: A cautionary tale. Information Processing Letters 65 (1998), 7-10.
B. Schneier. Applied Cryptography. John Wiley & sons, New York, 1996.
