

Electronic Notes in Theoretical Computer Science 248 (2009) 115–130
www.elsevier.com/locate/entcs

Thresholded Tabulation in a Fuzzy Logic Setting
Pascual Julia´n1
University of Castilla-La Mancha Department of Information Technologies and Systems
Pascual.Julian@uclm.es
Jesu´s Medina2
University of C´adiz Department of Mathematics Jesus.Medina@uca.es
Gin´es Moreno1
University of Castilla-La Mancha Department of Computing Systems Gines.Moreno@uclm.es
Manuel Ojeda-Aciego2
University of Ma´laga Department of Applied Mathematics
aciego@ctima.uma.es

Abstract
Fuzzy logic programming represents a flexible and powerful declarative paradigm amalgamating fuzzy logic and logic programming, for which there exists different promising approaches described in the literature. In this paper we propose an improved fuzzy query answering procedure for the so called multi-adjoint logic programming approach, which avoids the re-evaluation of goals and the generation of useless computations thanks to the combined use of tabulation with thresholding techniques. The general idea is that, when trying to perform a computation step by using a given program rule R, we firstly analyze if such step might contribute to reach further significant solutions (non tabulated yet). When it is the case, it is possible to avoid a useless computation step via a rule R by using thresholds and filters based on the truth degree of R, as well as a safe, accurate and dynamic estimation of the maximum truth degree associated to its body.
Keywords: Fuzzy Logic Programming, Tabulation, Thresholding


1 Partially supported by the EU (FEDER), and the Spanish Science and Education Ministry (MEC) under grants TIN 2004-07943-C04-03 and TIN 2007-65749.
2 Partially supported by the EU (FEDER), and the Spanish Science and Education Ministry (MEC) under grant TIN 2006-15455-C03-01 and by Junta de Andaluc´ıa under grant P06-FQM-02049.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.063

Introduction

Fuzzy Logic Programming is an interesting and still growing research area that agglutinates the efforts to introduce fuzzy logic into Logic Programming. During the last decades, several fuzzy logic programming systems have been developed [3, 8,9,15], where the classical inference mechanism of SLD–Resolution is replaced with a fuzzy variant which is able to handle partial truth and to reason with uncertainty. This is the case of the extremely flexible framework of Multi-adjoint logic pro- gramming [18–20]. Given a multi-adjoint logic program, queries are evaluated in two separate computational phases. Firstly, an operational phase in which admissible steps (a generalization of the classical modus ponens inference rule) are system- atically applied by a backward reasoning procedure, in a similar way to classical resolution steps in pure logic programming; until an expression is obtained in which all atoms have been evaluated. Then, this last expression is interpreted in the un- derlying lattice during an interpretive phase [12], providing the computed answer
for the given query.
In [5] a non-deterministic tabulation goal-oriented proof procedure was intro- duced for residuated (a particular case of multi-adjoint) logic programs over com- plete lattices. The underlying idea of tabulation is, essentially, that atoms of selected tabled predicates as well as their answers are stored in a table. When an identi- cal atom is recursively called, the selected atom is not resolved against program clauses; instead, all corresponding answers computed so far are looked up in the table and the associated answer substitutions are applied to the atom. The process is repeated for all subsequent computed answer substitutions corresponding to the atom.
In [13] a fuzzy partial evaluation framework was introduced for specializing multi-adjoint logic programs. Moreover, it was pointed out that if the proposed partial evaluation process is combined with thresholding techniques, the following benefits can be obtained:
The unfolding tree (i.e., an incomplete search tree used during the partial evalu- ation process), consumes less computational resources by efficiently pruning un- necessary branches of the tree and, hence, drastically reducing its size.
Those derivation sequences performed at execution time, need less computation steps to reach computed answers.
In this paper, we show how the essence of thresholding can be also embedded into a tabulation-based query answering procedure, reinforcing the benefits of both meth- ods in a unified framework. We also provide several kinds of “thresholding filters” which largely help to avoid the generation of redundant and useless computations. The structure of the paper is as follows. In Section 2 we summarize the main features of multi-adjoint logic programming. Section 3 adapts to the multi-adjoint logic framework the original tabulation procedure for residuated logic programs of [5]. Inspired by [13], the resulting method is refined by using thresholding techniques in Section 4. The benefits of such combination are reinforced in Section 5. Finally,

in Section 6 we draw some conclusions and discuss some lines of future work.

Multi-Adjoint Logic Programs
This section is a short summary of the main features of multi-adjoint languages. The reader is referred to [18, 20] for a complete formulation.
We will consider a language, L, containing propositional variables, constants, several (arbitrary) connectives to increase language expressiveness. In our fuzzy setting, we use implication connectives (←1, ←2,... , ←m) together with a number of aggregators, which are only required to be monotonic. They will be used to com- bine/propagate truth values through the rules. The general definition of aggregation operators subsumes conjunctive operators (denoted by &1, &2,... , &k), disjunctive operators (V1, V2,... , Vl), and average and hybrid operators (usually denoted by @1, @2,... , @n).
Aggregators are useful to describe/specify user preferences: when interpreted as a truth function they may be considered, for instance, as an arithmetic mean or a weighted sum. For example, if an aggregator @ is interpreted as [@]](x, y, z) = (3x + 2y + z)/6, x, y, z ∈ [0, 1], we are giving the highest preference to the first
argument, then to the second, being the third argument the least significant. By
definition, the truth function for an n-ary aggregator [@ ] : Ln → L is required to be monotone and fulfill [@ ](T,... , T)= T, [[@ ](⊥,... , ⊥)= ⊥.
The	language	L	will	be	interpreted	on	a	multi-adjoint	lattice,
⟨L, ≤, ←1, &1,... , ←n, &n⟩, which is a complete lattice equipped with a collection of adjoint pairs ⟨←i, &i⟩, where each &i is a conjunctor 3 intended to provide a modus ponens-rule wrt ←i. In general, the set of truth values L may be the carrier of any complete bounded lattice but, for simplicity, in the examples of this work we shall select L as the set of real numbers in the interval [0, 1].
A rule is a formula A ←i У, where A is an propositional symbol (usually called the head) and У (which is called the body) is a formula built from propositional symbols B1,... , Bn (n ≥ 0), truth values of L and conjunctions, disjunctions and aggregations. Rules with an empty body are called facts. A goal is a body submitted as a query to the system.
Roughly speaking, a multi-adjoint logic program is a set of pairs ⟨Y; α⟩, where Y is a rule and α is a value of L, which might express the confidence which the user of the system has in the truth of the rule Y. Note that the truth degrees in a given program are expected to be assigned by an expert. We will often write “Y with α” instead of ⟨Y; α⟩.

Procedural Semantics
The procedural semantics of the multi–adjoint logic language L can be thought as an operational phase followed by an interpretive one [12].

3 An increasing operator satisfying boundary conditions with the top element.

In the following, C[A] denotes a formula where A is a sub-expression (usually a propositional symbol) which occurs in the (possibly empty) context C[], whereas C[A/A'] means the replacement of A by A' in context C[]. In the following definition, we always consider that A is the selected propositional symbol in goal Q.
Definition 2.1 [Admissible Steps] Let Q be a goal, which is considered as a state, and let G be the set of goals. Given a program P, an admissible computation is formalized as a state transition system, whose transition relation →AS ⊆ (G× G) is the smallest relation satisfying the following admissible rules:
Q[A]→ASQ[A/v&iУ] if there is a rule ⟨A←iУ; v⟩ in P and У is not empty.
Q[A]→ASQ[A/v]) if there is a fact ⟨A←i; v⟩ in P.
Q[A]→ASQ[A/⊥] if there is no rule in P whose head is A.
Note that the third case is introduced to cope with (possible) unsuccessful admis- sible derivations. We shall use the symbols →AS1, →AS2 and →AS3 to distinguish between computation steps performed by applying one of the specific admissible rules. Also, the application of a concrete program rule on a step will be annotated
as a superscript of the →AS symbol, when it was considered relevant.
Definition 2.2 Let P be a program and let Q be a goal. An admissible derivation is
a sequence Q →∗	Q'. When Q' is a formula not containing propositional symbols
it is called an admissible computed answer (a.c.a.) for that derivation.
Example 2.3 Let P be the following program and let ([0, 1], ≤) be the lattice where
≤ is the usual order on real numbers.
Y1 : p←P q &G r with 0.8
Y2 : q←P s	with 0.7
Y3 : q←L r	with 0.8
Y4 : r←	with 0.7
Y5 : s←	with 0.9
where the labels P, G and L stand for Product, G¨odel and L- ukasiewicz connectives.
In the following admissible derivation for the program P and the goal p&Gr, we underline the selected expression in each admissible step:
p&Gr→AS1R1 (0.8&P(q&Gr))&Gr→AS1R2 (0.8&P((0.7&Ps)&Gr))&Gr→AS2R5 (0.8&P((0.7&P0.9)&Gr))&Gr→AS2R4 (0.8&P((0.7&P0.9)&G0.7))&Gr→AS2R4
(0.8&P((0.7&P0.9)&G0.7))&G0.7

The a.c.a. for this admissible derivation is: (0.8&P((0.7&P0.9)&G0.7))&G0.7.
If we exploit all propositional symbols of a goal, by applying admissible steps as much as needed during the operational phase, then it becomes a formula with no propositional symbols which can then be directly interpreted in the multi–adjoint lattice L. We recall from [12] the formalization of this process in terms of the following definition.
Definition 2.4 [Interpretive Step] Let P be a program and Q a goal. We formalize the notion of interpretive computation as a state transition system, whose transition relation →IS⊆ (G × G) is defined as the least one satisfying: Q[@(r1, r2)] →IS Q[@(r1,r2)/[[@]](r1,r2)], where [@]] is the truth function of connective @ in the lattice
⟨L, ≤⟩ associated to P.
Definition 2.5 Let P be a program and Q an a.c.a., that is, Q is a goal not containing propositional symbols. An interpretive derivation is a sequence Q →∗ Q'. When Q' = r ∈ L, being ⟨L, ≤⟩ the lattice associated to P, the value r is called a fuzzy computed answer (f.c.a.) for that derivation.
Example 2.6 We complete the previous derivation of Example 2.3 by executing the necessary interpretive steps to obtain the final fuzzy computed answer, 0.504, with respect to lattice ([0, 1], ≤).
(0.8&P((0.7&P0.9)&G0.7))&G0.7 →IS
(0.8&P(0.63&G0.7))&G0.7 →IS (0.8&P0.63)&G0.7 →IS 0.504&G0.7 →IS
0.504
In this section we have just seen a procedural semantics which provides a means to execute multi-adjoint logic programs. However, there exist a more efficient alter- native for obtaining fuzzy computed answers for a given query as occurs with the following tabulation-based proof procedure.

The Tabulation Proof Procedure
In what follows, we adapt the original tabulation procedure for propositional resid- uated logic programs described in [5] to the general case of multi-adjoint logic pro- grams [18]. There are two major problems to address: termination and efficiency. On the one hand, the TP operator is bottom-up but not goal-oriented. Further- more, the bodies of rules are all recomputed in every step. On the other hand, the usual implementations of Fuzzy Logic Programming languages (e.g. [24]) are goal- oriented, but inherit the problems of non-termination and recomputation of goals. In order to overcome these problems, the tabulation technique has been proposed in the deductive databases and logic programming communities. For instance, in [14]

it is proposed an extension of SLD for implementing generalized annotated logic programs that will be used to implement the here defined tabling procedure. Other implementation techniques have been proposed for dealing with uncertainty in logic programming, for instance translation into Disjunctive Stable Models [17], but rely on the properties of specific truth-value domains.
The idea of tabulation (or tabling) is simply to create a table for collecting all the answers to a given goal without repetitions. Every time a goal is invoked it is checked whether there is already a table for that goal. If so, the caller becomes a consumer of the tree, otherwise the construction of a new table is started. All answers produced are kept in the table without repetitions, and are propagated to the pending consumers. The most complete implementation of a full working tabulation system is XSB-Prolog [7] which implements SLG resolution. There is also an extension of SLG for generalized annotated logic programs [14,22] but differs from the system we present here.
In this section we present a general tabulation procedure for propositional multi- adjoint logic programs. The datatype we will use for the description of the method is that of a forest, that is, a finite set of trees. Each one of these trees has a root labeled with a propositional symbol together with a truth-value from the underlying lattice (called the current value for the tabulated symbol); the rest of the nodes of each of these trees are labeled with an “extended” formula in which some of the propositional symbols have been substituted by its corresponding value. For the description of the adaptation of the tabulation procedure to the framework of multi-adjoint logic programming, we will assume a program P consisting of a finite
number of weighted rules having the form ⟨A←iУ; ϑ⟩ together with a query ?A. The purpose of the computational procedure is to give (if possible) the greatest truth-value for A that can be inferred from the information in the program P.

Operations for Tabulation
For the sake of clarity in the presentation, we will introduce the following notation: Given a propositional symbol A, we will denote by P(A) the set of rules in P which have head A. The tabulation procedure requires four basic operations: Create New Tree, New Subgoal, Value Update, and Answer Return. The first operation creates a tree for the first invocation of a given goal. New Subgoal is applied whenever a propositional variable in the body of a rule is found without a corresponding tree in the forest, and resorts to the previous operation. Value update is used to propagate the truth-values of answers to the root of the corresponding tree. Finally, answer return substitutes a propositional variable by the current truth-value in the corresponding tree. We now describe formally the operations:

Rule 1: Create New Tree.
Given a propositional symbol A, assume P(A)= {⟨A←jУj; ϑj⟩ | j = 1,... , m} and construct the tree below, and append it to the current forest. If the forest did not exist, then generate a singleton list with the tree.


A : ⊥


ϑ1&1B1 ϑ2&2B2 .. . ϑm&mBm

Rule 2: New Subgoal.
Select a non-tabulated propositional symbol C occurring in a leaf of some tree (this means that there is no tree in the forest with the root node labeled with C), then create a new tree by directly applying Rule 1, and append it to the forest.

Rule 3: Value Update.
If a tree, rooted at C : r, has a leaf У with no propositional symbols, and У→IS∗s, where s ∈ L, then update the current value of the propositional symbol C by the value of supL{r, s}.
Furthermore, once the tabulated truth-value of the tree rooted by C has been modified, for all the occurrences of C in a non-leaf node У[C] such as the one in the left of the figure below then, update the whole branch substituting the constant u by supL{u, t} (where t is the last tabulated truth-value for C—i.e., supL{r, s}—) as in the right of the figure.


.
B[C]
.
B[C]

	

B[C/u]

.
B[C/ supL{u, t}]
.


Rule 4: Answer Return.
Select in any leaf a propositional symbol C which is tabulated, and assume that its current value is r; then add a new successor node as shown below:
B[C]
B[C/r]

Once we have presented the rules to be applied in the tabulation procedure, it is worth to recall some facts:
The only nodes with several immediate successors are root nodes; the successors correspond to the different rules whose head matches the label of the root node.
The leaf of each branch is a conjunction of the truth value of the rule which determined the branch, with an instantiation of the body of the rule.
The extension of a tree is done only by Rule 4, which applies only to leaves and extends the branch with one new node.
The only rule which changes the values of the roots of the trees in the forest is Rule 3 which, moreover, might update the nodes of existing branches.

p : ⊥→ 0.54
(ii) 0.6 &P q	(iii) 0.5 &P r

0.6 &P 0.9	(xi) 0.5 &P 0.8

0.54	(xii) 0.4
q : ⊥→ 0.9
0.9

r : ⊥→ 0.8
0.8 (x) 0.9 &L p

0.9 &L 0.54
0.44
Fig. 1. Example forest for query ?p.

A non-deterministic procedure for tabulation
Now, we can state the general non-deterministic procedure for calculating the an- swer to a given query by using a tabulation technique in terms of the previous rules.
Initial step Create the initial forest with the create new tree rule, applied to the query.
Next steps Non-deterministically select a propositional symbol and apply one of the rules 2, 3, or 4.
Following the steps in [6] it is not difficult to show both that the order of application of the rules is irrelevant, and that the algorithm terminates under very general hypotheses.
Example 3.1 Consider the following program with mutual recursion and query ?p:
Y1 : p ←P q with 0.6 Y2 : p ←P r with 0.5 Y3 : q ←  with 0.9 Y4 : r ←  with 0.8 Y5 : r ←L p with 0.9
Firstly, the initial tree consisting of nodes (i), (ii), (iii) is generated, see Figure 1. Then New Subgoal is applied on q, a new tree is generated with nodes (iv) and (v), and its current value is directly updated to 0.9.
By using this value, Answer Return extends the initial tree with node (vi). Now
Value Update generates node (vii) and updates the current value of p to 0.54.

Then, New Subgoal is applied on r, and a new tree is generated with nodes (viii), (ix) and (x). Value Update increases the current value to 0.8.
By using this value, Answer Return extends the initial tree with node (xi). Now Value Update generates node (xii). The current value is not updated since its value is greater than the newly computed one.
Finally, Answer Return can be applied again on propositional symbol p on node (x), generating node (xiii). A further application of Value Update generates node
(xiv) and the forest is terminated, as no rule performs any modification.

Combining Tabulation with Thresholding
In this section we will focus on the concept of thresholding, initially proposed in [13] for safely pruning branches when generating unfolding trees. The original method was firstly introduced inside the core of a fuzzy partial evaluation (PE) frame- work useful not only for specializing fuzzy programs, but also for generating re- ductants [20]. Reductancts were introduced in the context of multi-adjoint logic programming to cope with a problem of incompleteness that arises for non-linear lattices. For instance, given a, b two non-comparable elements in ⟨L, ≤⟩; assume that
for a goal A there are only two facts (⟨A←; a⟩ and ⟨A←; b⟩) whose heads are A;
both a and b are correct answers and, moreover, by definition of correct answer [20],
the supremum supL{a, b}, is also a correct answer which cannot be computed. The problem above can be solved by extending the original program with a special rule
⟨A← supL{a, b}; T⟩, the so called reductant.
The above discussion shows that a multi-adjoint logic program, interpreted inside a partially ordered lattice, needs to contain all its reductants in order to guarantee the completeness property of a sequence of admissible computations. This obvi- ously increases both the size and execution time of the final “completed” program. However, this negative effects can be highly diminished if the proposed reductants have been partially evaluated before being introduced in the target program: the computational effort done (once) at generation time is avoided (many times) at execution time.
Fortunately, if queries are evaluated following the tabulation method proposed before, reductants are not required to be included in a program (which obviously would increase both the size and execution time of the final completed program) be- cause their effects are efficiently achieved by the direct use of Rule 3: Value Update, as the reader can easily check. Anyway, even when reductants are not mandatory in the tabulation method described in Section 3, it is important to recast some useful ideas introduced in [13], where a refined notion of reductant (called PE- reductant) was given using partial evaluation techniques with thresholding. Partial evaluation [1, 10, 16] is an automatic program transformation technique aiming at the optimization of a program with respect to parts of its input: hence, it is also known as program specialization. It is expected that the partially evaluated (or residual ) program could be executed more efficiently than the original program. This is because the residual program is able to save some computations, at exe-

cution time, that were done only once at PE time. To fulfill this goal, PE uses symbolic computation as well as some techniques provided by the field of program transformation [2,4,23], specially the so called unfolding transformation (essentially, the replacement of a call by its definition body).
Following this path, the idea is to unfold goals, as much as possible, using the notion of unfolding rule developed in [11, 12] for multi-adjoint logic programs, in order to obtain an optimized version of the original program. In [13], the construc- tion of such “unfolding trees” was improved by pruning some useless branches or, more exactly, by avoiding the use (during unfolding) of those program rules whose weights do not surpass a given “threshold” value. For this enhanced definition of unfolding tree we have that:
Nodes contain information about an upper bound of the truth degree associated to their associated goal;
A set of threshold values is dynamically set to limit the generation of useless nodes.
This last feature provides great chances to reduce the unfolding tree shape, by stopping unfolding of those nodes whose truth degree upper bound component falls down a threshold value α.

Rules for tabulation with thresholding
In what follows, we will see that the general idea of thresholding can be combined with the tabulation technique shown in the previous section, in order to provide more efficient query answering procedures. Specifically, we will discard the previous descriptions of Rule 1: Create New Tree and Rule 2: New Subgoal, and instead of them, we propose new definitions:

Rule 1: Root Expansion.
Given a tree with root A : r in the forest, and a program rule ⟨A←iУ; ϑ⟩ not con- sumed before, such that ϑ # r, append the new child ϑ&iУ to the root of the tree and mark the program rule as consumed.

Rule 2: New Subgoal/Tree.
Select a non-tabulated propositional symbol C occurring in a leaf of some tree (this means that there is no tree in the forest with the root node labeled with C), then create a new tree with a single node, the root C : ⊥, and append it to the forest.
There are several remarks to do regarding the new definitions of Rules 1 and 2.
Firstly, notice that the creation of new trees is now performed in Rule 2, instead of Rule 1, which justifies its new name. On the other hand, the new Rule 1, does not create a new tree by expanding (one level) all the possible children of the root. Instead of it, the Root Expansion rule has a lazy behaviour: each time it is fired, it expands the tree by generating at most one new leaf, if and only if this new leaf might contribute in further steps to reach greater truth degrees than the current

one heading the tree. In this sense, the truth degree attached to the root of the tree, acts as a threshold for deciding which program rules can be used for generating new nodes in the tree. Note also that this threshold is dynamically updated by rule Value Update: the more it grows, the less chances for Root Expansion to create new children of the root.
The new non-deterministic procedure for tabulation with thresholding is as fol- lows:
Initial step Create an initial tree by using the rule new subgoal/tree on the query.
Next steps Non-deterministically select a propositional symbol and apply one of the rules 1, 2, 3, or 4.
In order to show the correctness of the new tabulation procedure, we have just to note that, in the Root Expansion rule, when we generate a leaf ϑ&iУ for a root node A : r, the value generated by the leaf will always be less than ϑ, independently of the truth degree eventually computed for the subgoal У. So, we can safely discard at run-time the use of those program rules (or facts) whose weight ϑ falls down the threshold value r. Otherwise, we would generate useless nodes which never would increase the truth degree of the root.

A deterministic procedure for tabulation with thresholding
The main goal of thresholding is to reduce the number and size of trees in the forest. This way, although the order of application of the rules is irrelevant because they generate the same solutions, the refinements introduced by thresholding might produce different forests depending on how and when rules are applied. In this section we provide some heuristics in order to minimize as much as possible the complexity of the generated forest.
To begin with, we assume now that the procedure starts with a forest containing a single tree with root A : ⊥, being A the propositional query we plan to answer.
Obviously, the Root Expansion rule has a crucial role in this sense: the more
lazily it is applied, the less chances it has to generate new nodes. So, we assign it the lowest priority in our deterministic procedure. For a similar reason, it is also important to increase the threshold at the root of a tree as fast as possible. In order to do this, we propose:
Assign maximum priority to Value Update and Answer Return.
When program rules are consumed by Root Expansion in a top-down way, we assume that facts textually appear before rules with body, and program rules are distributed in a descending ordering w.r.t. their weights, whenever possible.
Notice for instance, the distribution of the rules in Example 3.1, which accom- plish with the ordering we have just commented. The proposed strategy applied to the example avoids the construction of a number of nodes, see Figure 2, which evidences the benefits of combining tabulation with thresholding.
The answer to the query example with this optimized procedure is as follows: the initial tree consisting of nodes (i), (ii) is generated. Then New Subgoal/Tree is

p : ⊥→ 0.54
0.6 &P q

(v) 0.6 &P 0.9

0.54
q : ⊥→ 0.9
0.9
Fig. 2. Example threshold forest for p

applied on q, a new tree is generated with nodes (iii) and (iv), and its current value is directly updated to 0.9.
By using this value, Answer Return extends the initial tree with node (v). Now
Value Update generates node (vi) and updates the current value of p to 0.54.
Now, Root Expansion prevents using the rule with body r, since its weight is smaller than the currently computed for p. Hence, the forest is terminated.

Reinforcing Thresholding
As we have shown in the previous section, thresholding can be seen as an improve- ment performed on the core of the basic tabulation proof procedure. The general idea is that all nodes whose value of the body cannot surpass the current value of the root node can be safely removed, or directly, not generated. The thresholding technique described in Section 4 was based on the truth degree of each program rule tried to expand the root of a given tree. However, there is at least two more opportunities for performing thresholding, thus avoiding the unnecessary expansion of trees, as we are going to see in this section.
A sound rule for determining the maximum value of the body of a program rule, might consist in substituting all the propositional variables occurring in it by the top element of the lattice, T. It is easy to see that this second kind of ﬁlter can reduce the search space if it is appropriately implemented inside the Root
Expansion Rule. This idea was initially proposed as a further refinement of the original tabulation method for propositional, residuated logic programs of [5]. In the multi-adjoint logic setting, we also find a recent precedent: the same test was used in the PE-based reductant calculus proposed in [13], when collecting leaves of residual unfolding trees. In this paper we are interested in formalizing the same idea inside our thresholded tabulation method for multi-adjoint logic programs.
It is easy to see that the previous pruning rule can be further enhanced if there is information available about completed tables in the forest, i.e. the truth degrees associated to roots of completed or closed trees (i.e., which do not admit further updates). Obviously, when the process ends, all trees in the forest are closed. However, the clever point now is how to dynamically guess when a particular tree reach this category in the middle of the process. Fortunately, we have a successful answer to this question, as we are going to explain.

Note that, when the deterministic procedure for tabulation with thresholding we have just seen at the end of the previous section, is not able to fire the root expansion rule (which has the lowest priority in the deterministic strategy explained before) on a concrete tree in the forest, then the maximum truth degree of the propositional symbol rooting such tree has been reached (even when other open trees in the forest might update –increase– the truth degrees of their roots in further steps of the tabulation process). This information collected on the so called closed trees, will be crucial for approximating as much as possible the maximum truth degree of the body of a program rule, say Up body, as follows:
Let Y = ⟨A←iУ; ϑ⟩ be a program rule.
Let У' an expression with no atoms, obtained from body У by replacing each occurrence of a propositional symbol p by T if there is not a closed tree for p in the forest, or by the corresponding truth degree of p at the root of the closed tree, otherwise.
Let v ∈ L be the result of interpreting (by applying the corresponding interpretive
steps) У' under a given lattice, i.e. У' →∗ v.
Then, Up body(Y)= v.
Apart from the truth degree ϑ of a program rule Y = ⟨A←iУ; ϑ⟩ and the maximum truth degree of its body Up body(Y), in the multi-adjoint logic setting, we can consider a third kind of filter for reinforcing thresholding. The idea is to combine the two previous measures by means of the adjoint conjunction &i of the implication ←i in rule Y . Now, we define the maximum truth degree of a program rule, symbolized by function Up rule, as: Up rule(Y)= ϑ&i(Up body(Y)).
Putting all pieces together, we propose the new improved version of the root
expansion rule as follows:

Rule 1: Root Expansion.
Given a tree with root A : r in the forest, if there is at least a program rule Y =
⟨A←iУ; ϑ⟩ not consumed before and verifying the three conditions below, append the new child ϑ&iУ to the root of the tree or otherwise, mark the tree as closed.
Condition 1. ϑ # r.
Condition 2. Up body(Y) # r.
Condition 3. Up rule(Y) # r.
There are some remarks to do about our definition.
The more ﬁlters for thresholding we use, the more efficient the method becomes, since the number of nodes in trees can be drastically diminished. Think that by avoiding the generation of a single node, the method implicitly avoids too the generation of all its possible descendants.
On the other hand, the time required to properly evaluate the filters is largely compensated by the effects explained in the previous item.

Anyway, in order to perform and efficient evaluation of filters, it must be taken into account that a condition only is checked if none of the previous ones fails. In particular, the unique situation in which the three filters are completely evaluated appears only when the first two ones don’t fail.
In order to illustrate the advantages of our improved method, consider that in our running example, we replace the second program rule Y2 : p ←P r with 0.5
by Y' : p ←P  (r&P q) with 0.55. It is important to note that with the old version
(previous section) of the Root Expansion Rule, we could not obtain thresholding
benefits, due to the new truth degree 0.55 of Y' . Note also, that this value verifies the first condition of the new Root Expansion Rule when building the forest of Figure 2. So, we proceed by evaluating the second one, which is also satisfied since Up body(Y' )= 1 ∗ 0.9 = 0.9 # 0.54 (observe that q has a closed tree rooted with truth degree 0.9). Fortunately, the third condition fails, since Up rule(Y' )= 
0.55 ∗ 0.9= 0.495 < 0.54, which avoids future expansions of the tree (which is then labeled as closed) and in our case, the process finishes generating exactly the same
forest of Figure 2.

Conclusions and Further Research
In this paper we were concerned with efficient query answering procedures for propo- sitional multi-adjoint logic programs. We have shown that, by using a fuzzy variant of tabulation (specially tailored for the multi-adjoint logic approach) it is possible to avoid the repeated evaluation of redundant goals. Moreover, in the same fuzzy setting, we have also combined tabulation with thresholding, thus safely avoiding other kind of non-redundant, but useless computations.
Thresholding has been naturally embedded into the core of the tabulation method by simply reformulating in a lazy way the rule which expands the root node of trees.
By proposing a deterministic strategy which assigns priorities to each “tabulation rule”, it is possible to increase the efficiency of the whole method.
We exploit three kinds of “thresholding filters” for stopping the creation of new tree nodes and maximally reducing the search space.
Such filters (based on the truth degree of program rules, an upper bound esti- mation of the truth degrees of their bodies, and a suitable combination of both values), specially the first and third one, have been specially formulated for the multi-adjoint logic approach, and can not be applied to other settings not based in weighted rules (such as pure logic programming, residuated logic programming, etc).
Nowadays, we are working in two practical extensions of our approach:
In order to cover more realistic programs than the ones reported in this paper, we are enriching our technique to cope with the first order case. In this sense, we plan to take advantage from the experience acquired in [6] when lifting to

this more general case the original tabulation proof procedure for propositional residuated logic programs [5].
Regarding implementation issues, our efforts are devoted to incorporate the proposed technique inside the kernel of the FLOPER environment (see [21] and visit http://www.dsi.uclm.es/investigacion/dect/FLOPERpage.htm). Our tool offers several programming resources regarding the multi-adjoint logic approach, including two operational procedures for debugging/tracing and ex- ecuting goals. The first way is based on a direct translation of fuzzy logic programs into Prolog code in order to safely execute these final programs (via classical SLD-resolution steps) inside any standard Prolog interpreter in a com- pletely transparent way for the final user. The second alternative implements the notion of admissible step seen in Definition 2.1, in order to generate declar- ative traces based on unfolding trees with any level of depth. We think that the inclusion of a third operational semantics supporting the thresholded tabu- lation technique studied so far, will give us great opportunities for highlighting the practical benefits of our approach and providing experimental results.
For the future, beyond query answering procedures, we also plan to study the role that tabulation combined with thresholding might play in program transformation techniques such as partial evaluation and fold/unfold, in order to efficiently special- ize and optimize multi-adjoint logic programs.

References
M. Alpuente, M. Falaschi, P. Juli´an, and G. Vidal. Specialization of Lazy Functional Logic Programs. In Proc. of the ACM SIGPLAN Conf. on Partial Evaluation and Semantics-Based Program Manipulation, PEPM’97, volume 32, 12 of Sigplan Notices, pages 151–162, New York, 1997. ACM Press.
M. Alpuente, M. Falaschi, G. Moreno, and G. Vidal. Rules + Strategies for Transforming Lazy Functional Logic Programs. Theoretical Computer Science, Elsevier, 311(1-3):479–525, Jan. 2004.
J. F. Baldwin, T. P. Martin, and B. W. Pilsworth. Fril- Fuzzy and Evidential Reasoning in Artificial Intelligence. John Wiley & Sons, Inc., 1995.
R.M. Burstall and J. Darlington. A Transformation System for Developing Recursive Programs.
Journal of the ACM, 24(1):44–67, 1977.
C.V. Dama´sio, J. Medina, and M. Ojeda-Aciego. A tabulation proof procedure for residuated logic programming. In Proc. of the European Conference on Artificial Intelligence, Frontiers in Artificial Intelligence and Applications, 110:808–812, 2004.
C.V. Dama´sio, J. Medina, and M. Ojeda-Aciego. Termination of logic programs with imperfect information: applications and query procedure. Journal of Applied Logic, 5(3):435–458, 2007.
David S. Warren et al. The XSB system version 3.1 volume 1: Programmer’s manual. Technical Report Version released on August, 30, Stony Brook University, USA, 2007. (Available from URL: http://xsb.sourceforge.net/ ).
S. Guadarrama, S. Mun˜oz, and C. Vaucheret. Fuzzy Prolog: A new approach using soft constraints propagation. Fuzzy Sets and Systems, Elsevier, 144(1):127–150, 2004.
M. Ishizuka and N. Kanai. Prolog-ELF Incorporating Fuzzy Logic. In Aravind K. Joshi, editor, Proceedings of the 9th International Joint Conference on Artificial Intelligence (IJCAI’85). Los Angeles, CA, August 1985., pages 701–703. Morgan Kaufmann, 1985.
N.D. Jones, C.K. Gomard, and P. Sestoft. Partial Evaluation and Automatic Program Generation. Prentice-Hall, Englewood Cliffs, NJ, 1993.


P. Juli´an, G. Moreno, and J. Penabad. On Fuzzy Unfolding. A Multi-adjoint Approach. Fuzzy Sets and Systems, Elsevier, 154:16–33, 2005.
P. Juli´an, G. Moreno, and J. Penabad. Operational/Interpretive Unfolding of Multi-adjoint Logic Programs. Journal of Universal Computer Science, 12(11):1679–1699, 2006.
P. Juli´an, G. Moreno, and J. Penabad. Efficient reductants calculi using partial evaluation techniques with thresholding. Electronic Notes in Theoretical Computer Science, Elsevier Science, 188:77–90, 2007.
M. Kifer and V.S. Subrahmanian. Theory of generalized annotated logic programming and its applications. Journal of Logic Programming, 12:335–367, 1992.
Deyi Li and Dongbo Liu. A fuzzy Prolog database system. John Wiley & Sons, Inc., 1990.
J.W. Lloyd and J.C. Shepherdson. Partial Evaluation in Logic Programming. Journal of Logic Programming, 11:217–242, 1991.
T. Lukasiewicz. Fixpoint characterizations for many-valued disjunctive logic programs with probabilistic semantics. Proc of Logic Programming and Non-Monotonic Reasoning, LPNMR’01, Springer-Verlag, Lecture Notes in Artificial Intelligence, 2173:336–350, 2001.
J. Medina, M. Ojeda-Aciego, and P. Vojt´aˇs. Multi-adjoint logic programming with continuous semantics. Proc of Logic Programming and Non-Monotonic Reasoning, LPNMR’01, Springer-Verlag, Lecture Notes in Artificial Intelligence, 2173:351–364, 2001.
J. Medina, M. Ojeda-Aciego, and P. Vojt´aˇs. A procedural semantics for multi-adjoint logic programing. Progress in Artificial Intelligence, EPIA’01, Springer-Verlag, Lecture Notes in Artificial Intelligence, 2258(1):290–297, 2001.
J. Medina, M. Ojeda-Aciego, and P. Vojt´aˇs. Similarity-based Unification: a multi-adjoint approach.
Fuzzy Sets and Systems, 146:43–62, 2004.
P.J. Morcillo and G. Moreno. Programming with Fuzzy Logic Rules by using the FLOPER Tool. Proc. of 2nd Intl Symposium on Rule Interchange and Applications, RuleML’08, Springer-Verlag, Lecture Notes in Computer Science, 3521:119–126, 2008.
T. Swift. Tabling for non-monotonic programming. Annals of Mathematics and Artificial Intelligence, 25(3–4):201–240, 1999.
H. Tamaki and T. Sato. Unfold/Fold Transformations of Logic Programs. In S. T¨arnlund, editor, Proc. of Second Int’l Conf. on Logic Programming, pages 127–139, 1984.
P. Vojt´aˇs and L. Paul´ık. Soundness and completeness of non-classical extended SLD-resolution. In
R. Dyckhoff et al, editor, Proc. ELP’96 Leipzig, pages 289–301. LNCS 1050, Springer Verlag, 1996.
