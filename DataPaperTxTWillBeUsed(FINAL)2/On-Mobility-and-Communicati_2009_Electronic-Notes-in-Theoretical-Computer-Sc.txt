

Electronic Notes in Theoretical Computer Science 257 (2009) 19–33
www.elsevier.com/locate/entcs

On Mobility and Communication 1
Wenjie Du 2	Yuxin Deng3
Shanghai Jiao Tong University Shanghai, China

Abstract
By imposing three semantic constraints on the π-calculus equipped with delayed input, we obtain a variant of the π-calculus. We prove that Hennessy and Riely’s distributed π-calculus can be encoded into this new model, satisfying a full abstraction theorem, which means that one-dimensional mobility can be characterized by communication. We also discuss the difficulties of expressing two-dimensional mobility, the mechanism used by ambient calculi.
Keywords: mobility, communication, distributed π-calculus, delayed input


Introduction
In the community of process algebra, there exist different kinds of strategies for controlling resource access, which entail different models for describing concurrency and mobility. For example, in the standard π-calculus [8], the restriction operator can be considered as a tool of limiting names for local use. In distributed π-calculus (Dπ) [6], location is introduced to realize this function, since processes in different locations are not able to interact with each other directly. In mobile ambients [4], every ambient has a boundary which distinguishes interior processes from exterior ones.
But all those controlled resources are not isolated. To describe mobile systems, i.e., systems with a dynamically changing linkage topology, each

1 Deng would like to acknowledge the support of the National Natural Science Foundation of China (Grant No. 60703033
2 Email: wenjiedu@shnu.edu.cn
3 Email: yuxindeng@sjtu.edu.cn





1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.11.024

model must provide a mechanism to allow resources to extrude their original scope so as to be used by processes outside the scope. For instance, in the π-calculus, the following reduction relation holds.
(νb)(a¯b.P |Q)|a(x).R −→ (νb)(P|Q|R{b/x})
The private name b, which is previously shared by a¯b.P and Q, is transmitted along a. As a consequence, the scope of b is extended to R{b/x}. Consider the following example from Dπ:
l[go k.¯ab.P |Q]|k[a(x).R] −→ l[Q]|k[a¯b.P ]|k[a(x).R]
−→ l[Q]|k[P |R{b/x}]
After the first step of reduction, the agent a¯b.P moves from one location to another, say from l to k. Then it can communicate with a(x).R which stays in location k. In mobile ambients, mobility paves the way for one ambient to enter the range of another. A typical example is given below:
n[in m.⟨b⟩.P|Q]|m[open n.(x).R] −→ m[n[⟨b⟩.P|Q]|open n.(x).R]
−→ m[⟨b⟩.P|Q|(x).R]
−→ m[P|Q|R{b/x}]
To send the name b to process R, ambient n has to enter the domain of m, be opened and then communicate with (x).R.
In example (1), only communication happens. In the next two examples, both mobility and communication take place. A careful observation reveals that (2) and (4) use different sorts of mobility, which we call one-dimensional mobility and two-dimensional mobility respectively. In (2), all locations are always located on the same level, no location nesting being permitted, while in (4), ambient n becomes a subambient of m after its movement.
In this paper, we will show that one-dimensional mobility can be char- acterized by communication if we use the semantics of delayed input [10,7]. Such a delayed input prefix, written a(x) : P , allows the continuation P to evolve underneath the input guard, except for observable actions related to x. Hence, it allows more parallelism in processes. However, the sequentialization forced by the ordinary prefix is useful for expressing the behaviors of many concurrent systems. So in this paper, instead of replacing one with the other, we keep both operators, with the requirement that the delayed input only possesses a part of its functions under the ordinary meaning. First, we give a restricted form of the π-calculus with delayed input (πDI), called πrdi. It is ob- tained by allowing only a portion of the legal operations in ordinary semantics of delayed input. In other words, if we use S1 and S2 to stand respectively for all legal operations in πrdi and πDI, then S1 is actually a subset of S2. Then we give an encoding of Dπ into πrdi. So the reductions in example (2) will be simulated as follows:

(7)	l : ¯l.k : a¯b.k¯.⟨⟨P ⟩⟩k|⟨⟨Q⟩⟩l|k : a(x).k¯.⟨⟨R⟩⟩k
(8)	−τ→ k : a¯b.k¯.⟨⟨P ⟩⟩k|⟨⟨Q⟩⟩l|k : a(x).k¯.⟨⟨R⟩⟩k
(9)	−τ→ k : k¯.⟨⟨P ⟩⟩k|⟨⟨Q⟩⟩l|k : k¯.⟨⟨R⟩⟩k{b/x}

(10)
−τ→2
⟨⟨P ⟩⟩k|⟨⟨Q⟩⟩l|⟨⟨R⟩⟩k{b/x}

≡ ⟨⟨Q⟩⟩l|⟨⟨P |R{b/x}⟩⟩k
where l and k¯ are abbreviations of l(y) and k¯(z) respectively, for some y and z, since we are not concerned with the names transmitted. We prove that our encoding meets the correctness criteria: operational correspondence and full abstraction. At last, we give a brief discussion about the difficulties of simulating two-dimensional mobility by communication.
In Section 2, we review Hennessy and Riely’s Dπ and give a labelled tran- sition system which is new because [6] only provides a reduction semantics. In Section 3, we present the syntax and semantics of πrdi. In Section 4, we report the encoding of Dπ into πrdi, which is fully abstract. In Section 5, we discuss two-dimensional mobility. Finally in Section 6, we consider related work and summarize our main achievements.

The Distributed π-calculus
In this section, we review Dπ, with some notational changes from [6]. And we do not consider type system since in this paper we are devoted to the encoding, thus the syntax, semantics and bisimulation relations are enough to achieve our aim.

Syntax
Let N be a countable infinite set of names ranged over by the metavariable x, y, z, ·· ·. We will distinguish two subsets of names: channels and locations, ranged over by a, b, c, ··· and k, l, ··· respectively. Let N et be the set of net- works, ranged over by M, N, ·· ·, built from processes, which in turn, are built from names. Fig. 1 lists the production grammar. All the operators for net- works and processes have the usual meanings [2]. The definition of free names and bound names of a network N , written f n(N ) and bn(N ) respectively, arise as expected; the names of N , written n(N ), are given by f n(N ) ∪bn(N ). Substitutions, ranged over by σ, are functions from N to N ; for any name e, eσ represents the name by applying σ to e; we write Pσ and Nσ for the process and network obtained by applying σ to P and N respectively, with renaming possibly involved to avoid capture of free names. Note that Fig. 1 only displays monadic input and output, but we can easily extend them to





Fig. 1. Syntax of Dπ

allow a tuple of names a1, ··· , an be transmitted. In some examples we write a˜ for the names occurring in polyadic input and output. The compound name introduced in [6] can also be added to our syntax.
To get an overview of the features of the language, we present an exam- ple borrowed from [2]. This example formalizes the mechanism of standard remote procedure call. A client process Q, located at k, wants to call a ser- vice located at l with arguments d˜, and waits for the results, to be processed
by a continuation process P . Using our syntax, the example is written as
N = k[Q]|l[R], where
Q = (νr)(go l.a¯⟨d˜, r, k⟩|r(v˜).P )

R = !a(x˜, y, z).go z.y¯⟨f (x˜)⟩

Semantics
In [6] only reduction semantics is given. However we would like to use labelled transition semantics to compare the operational correspondence between Dπ and πrdi. Fig. 2 displays this semantics in the so-called early style [8]. It is based on an auxiliary relation called structural congruence which abstract away some irrelevant details from the static structure of terms. It is closed under composition and restriction, satisfying the axioms listed below:
M ≡ N   if M α-convertible N
M|0 ≡ M,   M|N ≡ N|M,   M|(N|O) ≡ (M|N )|O
k[(νe)P ] ≡ (νe)k[P ]	if e /= k
k[P|Q] ≡ k[P ]|k[Q]
(νe)0 ≡ 0,	k[0] ≡ 0
The rules com, close and par have a symmetric version which is omitted. Tran-

sitions are of the form N
k,α
N', where k represents the location where the

transition takes place and action α is the same as the action in standard π-
calculus [10]. The definitions of subj(α), fn(α), bn(α) and n(α) inherit their
meaning directly from the π-calculus. Relation (−k→,τ )∗ is the reflexive and

k,τ
transitive closure of
; moreover,
k,α
=
stands for (−k→,τ )∗
k,α
(−k→,τ )∗, and

k,αˆ
k,α
k,τ  ∗

=⇒ for =⇒ if α /= τ , and for (−→) if α = τ .
Remark. We explain why, in this transition system, a label (k, α) consists of two components, k and α. In rules comm and close, the prerequisite for the communication between M and N is that they can perform complementary actions in the same location. This kind of mechanism for communication is different from those of π1l-calculus [1] and distributed join-calculus [5], where communication is deterministic, static and point-to-point, and participants for interaction need not be in the same location.

Bisimulation
We can now define a notion of (weak) bisimulation over the transition system given in last section. It is simply the easy adaption of the bisimulation relation in the π-calculus [8].
Definition 2.1 A symmetric relation S ⊆ N et × N et is a bisimulation if
MSN implies:





in
k[a(x).P ] −→ k[P{b/x}]
out


k,a¯b
k[a¯b.P ]	k[P ]

k,α
N
N'	b /∈ n(α) ∪ {k}

go	k,τ
k[go l.P ]	l[P ]
res
k,α
(νb)N	(νb)N

k,a¯b
N
N'	b /∈ {k, a}
k,α
k[P ]
k[P ']

open
(νb)N
k,a¯(b)
−→ N
mat	k,α
'	k[[a = a]P, Q] −→
k[P ']

k,α
k[Q]
k[Q']	a /= b
k,α
N
N'	bn(α) ∩ f n(M )= ∅

mis
k,α	'
par
k,α	'

k[[a = b]P, Q] −→ k[Q ]	N|M −→ N |M

comm
k,a¯b
M
M'	N −k,→ab N'
close
k,a¯(b)
−→ M	N −→ N

M|N −→
M'|N'
M|N −→
(νb)(M'|N')

rep
k[P|!P ] −→ N

k,α
str
N ≡ M	M −→
k,α
M'	M' ≡ N'
'

k[!P ] −→ N	N −→ N

Fig. 2. Labelled transition system for Dπ


k,α
If M
M' then there exists N' such that N k⇒,αˆ
N' and M'SN'.

Two networks M and N are bisimilar, written M ≈D N , if MSN for some
bisimulation S.
Another important notion in process calculi is expansion relation, since it is sometimes useful to count the number of silent moves performed by a process. Here we introduce this notion into Dπ and require that M expands to N if M ≈D N and N has at least as many silent moves as M .
Definition 2.2 A relation S ⊆ N et × N et is an expansion if MSN implies:

If M
k,α
M' then there exists some N' such that N k⇒,α
N' and M'SN'.

k,α
If N
N' then there exists some M' such that M −k→,αˆ
M' and M'SN'.

N expands M , written M ≤D N , if MSN for some expansion S.
Obviously, M ≤D N implies M ≈D N . It is easy to check that we also have the following lemma.
Lemma 2.3 M ≈D N implies:
M|O ≈D N|O	(2) (νe)M ≈D (νe)N

πrdi

In this section we introduce πrdi, a restricted form of the π-calculus with delayed input. Since the processes in πrdi is very similar to the processes located in some locations in Dπ, we abuse some notation and do not dwell much on the syntax and semantics of πrdi.
Let Pr be the set of processes in πrdi, also ranged over by P, Q, ·· ·, built from the operators of inaction, input preﬁx, output preﬁx, parallel composition, restriction, replication, match and delayed input according to the following grammar:
P, Q, R ··· ::= 0 | a(x).P | a¯b.P | P|Q | (νa)P |!P | [a = b]P, Q | a(x): P When the names transmitted are not important, we do not write them ex-

plicitly and abbreviate a(x).P,
a¯b.P and a(x) : P as a.P,
a¯.P and a : P

respectively. The definitions of action α, subj(α), fn(α), bn(α), n(α) and
f n(P ) remain unchanged. So the syntax of πrdi is the same as that of πDI.
The labelled transition semantics for πrdi is displayed in Fig. 3, where u ranges over the set N ∪ {ε}. The semantics of πrdi is obtained by applying three semantic constraints on πDI. (1) a(x) : P can receive a name along a only from one source: P , i.e., there is a subterm of P in the form of a¯b.Q. The process a(x) : P|a¯b.R is not able to be reduced to P{b/x}|R since a¯b.R is outside the scope of P . So we disallow the general rule for input:



a(x): P −a→b
P{b/x}

and only reserve COM1 and CLS1. (2) Suppose P ≡ a(x): P1, Q ≡ b(y): Q1 and P1 has a complementary action of Q1, then P can communicate with Q only if a = b. This reminds us of Remark 1. The encoding in Section 4 tells us the necessity of this constraint given by rules COM2 and CLS2. (3) We do not want two consecutively nesting delayed input to occur in a process expression. This constraint can be lifted, but keeping it simplifies our proofs in Section 4. Rule ACT implies this constraint.
The transition system rests on the following structural congruence relation.
P ≡ Q  if P α-convertible Q
P|0 ≡ P,   P|Q ≡ Q|P,   P|(Q|R) ≡ (P|Q)|R
(νa)0 ≡ 0,	(νa)(νb)P ≡ (νb)(νa)P

u,α
The label of a transition P
P ' has two components: u and α, where u

is used for bookkeeping so as to reflect the second constraint. In fact, all the
three constraints are imposed on the operator of delayed input. If we erase





IN	ε,ab
a(x).P −→ P{b/x}
OUT


ε,a¯b
a¯b.P −→ P

ACT
ε,α
P −→ P
x /∈ n(α) a /∈ subj(α)
COM1
ε,a¯b
P −→ P

a,α
a(x): P
a,τ	'

ε,a¯(b) '
u,a¯b
P
u,ab  '

CLS1 	P −→ P		COM2   −→ P	Q −→ Q

a,τ
a(x): P
u,τ	'	'

u,a¯(b)
P
u,ab  '
u,α	'

CLS2
−→ P
Q −→ Q
b /∈ fn(Q)
PAR P −→ P	bn(α) ∩ fn(Q)= ∅



u,α
P
u,τ
P|Q −→
'
(νb)(P'|Q')


u,a¯b
P|Q u,α P'|Q
'

RES
−→ P	a /∈ n(α) ∪ {u}
OPEN P −→ P	b /∈ {u, a}

u,α
(νa)P −→ (νa)P
u,a¯(b)
(νb)P −→ P

u,α	'
u,α
Q

MAT 	P −→ P	
[a = b]P, Q u,α P'
MIS 	−→ Q	a /= b 
[a = b]P, Q u,α Q'

P|!P u,α P'
u,α	'	'	'

REP	−→
STR P ≡ Q  Q −→ Q	Q ≡ P 

u,α
!P −→ P
u,α
P −→ P



Fig. 3. Labelled transition semantics for πrdi


delayed input from πrdi, u will always be ε. Moreover, in that case, when we

ε,α
write P
P ' as P −α→ P ', the LTS of π
rdi
will become the LTS of standard

π-calculus. So we can consider π as a special instance of πrdi. Another point
worthy of mentioning is that πrdi is purely communication-based, involving neither one-dimensional mobility nor two-dimensional mobility.
Bisimulation and expansion can be adapted from Definitions 2.1 and 2.2 by replacing Dπ networks with πrdi processes and extending the corresponding
u,aˆ
definition of = .
Definition 3.1 A symmetric relation S ⊆ Pr × Pr is a bisimulation if PSQ
implies:

u,α
If P
P ' then there exists Q' such that Q u⇒,αˆ
Q' and P 'SQ'

P is bisimilar to Q, written P ≈r Q, if PSQ for some S.
Definition 3.2 A relation S ⊆ Pr × Pr is an expansion if PSQ implies:

u,α
If P
u,α
If Q
P ' then there exists some Q' such that Q u⇒,α
Q' then there exists some P ' such that P −u→,αˆ
Q' and P 'SQ'.
P ' and P 'SQ'.

Q expands P , written P ≤r Q, if PSQ for some expansion S.
All the properties of ≈D and ≤D hold for ≈r and ≤r.




Fig. 4. Encoding Dπ into πrdi
Encoding Dπ into πrdi
The translation from Dπ to πrdi is displayed in Fig. 4, where the translation of networks relies on an auxiliary translation of processes which is parametric in a location name. The name represents the location where the process is run- ning. Every location is translated into a delayed input and an output within its continuation process, and we are not concerned with what is transmitted between them. The pair of delayed input and the continuing output performs as an entity, either appear or disappear at the same time. That’s why we impose constraints (1) and (2) on πDI so as to reduce it to πrdi.
Let’s consider the network N defined in Section 2.1. It can be translated as ⟨⟨N ⟩⟩ = ⟨⟨Q⟩⟩k|⟨⟨R⟩⟩l, where
⟨⟨Q⟩⟩k = (νr)(k : k¯.l : a¯⟨d˜, r, k⟩.¯l|k : r(v˜).k¯.⟨⟨P ⟩⟩k)
⟨⟨R⟩⟩l = !l : a(x˜, y, z).¯l.l : ¯l.z : y¯⟨f (x˜)⟩.z¯
For the translation ⟨⟨N ⟩⟩, we neither add any new names to nor delete any existing names from N , so the free names of N are preserved and remain free in ⟨⟨N ⟩⟩.
Lemma 4.1 f n(⟨⟨M ⟩⟩)= f n(M )
Lemma 4.2 For any substitution σ, the following properties hold:
(⟨⟨P ⟩⟩k)σ = ⟨⟨P σ⟩⟩kσ
⟨⟨Mσ⟩⟩ = ⟨⟨M ⟩⟩σ

Proof. By induction on the structures of processes and networks. The proof of clause (2) makes use of (1) when analyzing the case of M ≡ k[P ].	 
Lemma 4.3 (1) If M ≡ N then ⟨⟨M ⟩⟩≡ ⟨⟨N ⟩⟩.
If ⟨⟨M ⟩⟩ ≡ P then there exists some N such that P ≡ ⟨⟨N ⟩⟩ and M ≡ N.
Proof. By induction on the structural congruence of N et and Pr respectively. Details are omitted.	 
Now we are prepared to prove that the encoding ⟨⟨·⟩⟩ enjoys an operational correspondence up to ≤r.
Lemma 4.4 (Operational correspondence) Let M be a network in Dπ.

k,α
Suppose that M
M', then we have:

if α ∈ {ab, a¯b, a¯(b)} then ⟨⟨M ⟩⟩
k,α  k,τ
⟨⟨M '⟩⟩;

if α = τ then ⟨⟨M ⟩⟩(−k→,τ )t⟨⟨M '⟩⟩ and t =1 or t = 3.

Suppose that ⟨⟨M ⟩⟩
and ⟨⟨M '⟩⟩ ≤r P.
u,α
P, then there exists M' ∈ N et such that M −u→,α  M'

Proof. By transition induction. The proof relies on the last three lemmas. Details can be found in the Appendix.	 
Theorem 4.5 (Full abstraction) Let M and N be two networks in Dπ, then
M ≈D N iff ⟨⟨M ⟩⟩ ≈r ⟨⟨N ⟩⟩
Proof. (⇒) We can construct a relation
R = {(⟨⟨M ⟩⟩, ⟨⟨N ⟩⟩) | M ≈D N}∪ ≈r
and prove that it is a bisimulation in πrdi. (⇐) Similarly we can prove that the relation
S = {(M, N ) | ⟨⟨M ⟩⟩ ≈r ⟨⟨N ⟩⟩}
is a bisimulation in Dπ.
The two parts of proof rely on Lemma 4.4. Refer to the Appendix for more details.	 

Discussion
We take mobile ambients [4] as a typical example of process calculus with two-dimensional mobility. It has two characteristics: (1) it has hierarchical structure, i.e., an ambient may contain several subambients; (2) a process

may be influenced by the operations of its sibling processes without noticing the effect. For example, the following reduction rules are the cornerstones for ambient calculus.

n[in m.P|Q]|m[R] −→ m[n[P|Q]|R]
m[n[out m.P|Q]|R] −→ n[P|Q]|m[R]


In (16) and (17), the environments of Q are both changed by P . There is not any symptom for Q to know when and how its environment will be changed. This kind of phenomenon is hard to be simulated in communication-based models, since in these models a process cannot have any influence to a sib- ling process if no communication happens between them. So one may think of treating a pair of sibling processes, say in m.P and Q in (16) as a whole entity in the translation (if it exists), and either process can perform some actions to influence the entity, which also means to influence itself and its sibling process. There are two reasons against this strategy. (1) A good trans- lation should be homomorphic with respect to parallel composition, namely
⟨⟨P |Q⟩⟩ = ⟨⟨P ⟩⟩|⟨⟨Q⟩⟩ [9]. This condition requires us to encode in m.P and Q separately. (2) In (17), the behavior of ambient n has no effect to the sibling process R. Therefore, it should be better to take ambient n and R as two different entities in the translation. Now we are trapped in a dilemma: there are arguments to support two opposite opinions.
To translate two-dimensional mobility, we have to consider the problem of how to represent hierarchical structure in a flat space. (In the π-calculus and its variants, all processes stand on the same level.) It is difficult to use only prefix operators to describe nesting ambients. The techniques of polyadic synchronization [3] can be thought of communication over channels with structured address. But it is of little help for the translation of ambient. For example, one may conceive of a translation of m in (17) like this: m · n : C[⟨⟨out m.P|Q⟩⟩]|m : D[⟨⟨R⟩⟩], where C and D are some contexts of the target language. It says that C and D lie on different levels. But it does not solve the problem. If R has the operator of open n, one may want C to be lifted to a higher level, directly underneath m. However, the semantics of polyadic synchronization [3] forbids any communication between two processes sharing different channels, say m · n and n in this example.
Therefore, we leave the proof or disproof of the possibility of directly en- coding two-dimensional mobility into communication-based models as an open problem.

Conclusions and Related Work
We have presented a variant of the π-calculus (πrdi) by imposing three seman- tic constraints on the π-calculus with delayed input. The model we obtained is purely based on communication, involving nothing about mobility. By en- coding Hennessy and Riely’s distributed π-calculus (Dπ) into πrdi, we show the possibility of characterizing one-dimensional mobility using only commu- nication. To compare the operational correspondence between Dπ and πrdi, we enrich the original Dπ with labelled transition semantics and bisimulation. It is shown that the encoding is fully abstract. We have also discussed the difficulties of dealing with two-dimensional mobility which is one of the main features of mobile ambients.
In [1], Amadio has presented an asynchronous model (π1l) of locality, fail- ure and process mobility. It is shown that π1l can be encoded into π1,a typed version of the asynchronous π-calculus. But π1l requires that every channel name is associated with a unique process which serves messages addressed to that name. Therefore, location does not have a strong efficacy to limit resource access, since the communication is point-to-point and the processes of sending and receiving message can stay in different locations. In contrast, the communication in Dπ is local and there is no direct message exchange between two different locations. In fact, the main role location plays in π1l is to describe failure. In the absence of failure, the distribution of processes is transparent and enjoys the property: r ≈a erl(r), where erl is the function of location erasure [1]. In [5], location nesting shows the hierarchical structure of location tree. But message transmission is also deterministic and point- to-point as every name is defined in at most one solution. Hence it is not surprising that there exists an encoding of distributed join-calculus into the join-calculus. In [2], a subcalculus of Dπ, the receptive distributed π-calculus is studied. It is shown to be expressive enough to contain the π1-calculus proposed in [1].

References
R. M. Amadio. An asynchronous model of locality, failure, and process mobility. In D. Garlan and D. Le Metayer, editors, Proceedings of COORDINATION ’97, volume 1282 of LNCS. Springer, 1997. Extended version as Rapport de Recherche RR-3109, INRIA Sophia-Antipolis, 1997.
R. M. Amadio, G. Boudol, and C. Lhoussaine. The receptive distributed pi-calculus (extended abstract). In C. Pandu Rangan, V. Raman, and R. Ramanujam, editors, Proceedings of FSTTCS ’99, volume 1738 of LNCS, pages 304–315. Springer, Dec. 1999.
M. Carbone. On the expressive power of polyadic synchronisation in π-calculus. Electronic Notes in Theoretical Computer Science, 68(2), 2002.

L. Cardelli and A. D. Gordon. Mobile ambients. Theoretical Computer Science, 240(1):177– 213, 2000. An extended abstract appeared in Proceedings of FoSSaCS ’98 : 140–155.
C. Fournet, G. Gonthier, J.-J. L´evy, L. Maranget, and D. R´emy. A calculus of mobile agents. In U. Montanari and V. Sassone, editors, Proceedings of CONCUR ’96, volume 1119 of LNCS, pages 406–421. Springer, 1996.
M. Hennessy and J. Riely. Resource access control in systems of mobile agents. In U. Nestmann and B. C. Pierce, editors, Proceedings of HLCL ’98, volume 16.3 of ENTCS, pages 3–17. Elsevier Science Publishers, 1998. Full version as CogSci Report 2/98, University of Sussex, Brighton.
M. Merro. Locality in the π-calculus and applications to distributed objects. PhD thesis, Ecole des Mines, France, October 2000.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, part I/II. Journal of Information and Computation, 100:1–77, Sept. 1992.
C. Palamidessi. Comparing the expressive power of the synchronous and the asynchronous
π-calculus. In Proceedings of POPL ’97, pages 256–265. ACM, Jan. 1997.
D. Sangiorgi and D. Walker. The π-calculus: a Theory of Mobile Processes. Cambridge University Press, 2001.

A	Delayed Proofs
Proof of Lemma 4.4
Proof. The proof proceeds by transition induction. We prove part 1. The proof of part 2 is similar.

Suppose that M
k,α
M' and α = ab. When α =
a¯b or a¯(b), similar

analysis can be applied.
When the last rule applied to get M

k,ab

M' is in, then we have

⟨⟨M ⟩⟩ ≡ k : a(x).k¯.⟨⟨P ⟩⟩k −k,→ab
k : k¯.⟨⟨P ⟩⟩k{b/x} −k→,τ
⟨⟨P ⟩⟩k{b/x}. By

Lemma 4.2, ⟨⟨P ⟩⟩k{b/x} = ⟨⟨P {b/x}⟩⟩k ≡ ⟨⟨M '⟩⟩.
When res is the rule used last, then M ≡ (νe)N, M' ≡ (νe)N', e /∈

{a, b} and N
k,ab
N'. By induction hypothesis, ⟨⟨N ⟩⟩
k,ab
Q
k,τ

⟨⟨N '⟩⟩, it follows that (νe)⟨⟨N ⟩⟩
k,ab
k,τ
(νe)Q
(νe)⟨⟨N '⟩⟩≡ ⟨⟨M '⟩⟩.

When the last rule used is mat, then M ≡ k[[c = c]P, Q], M' ≡ k[P ']

k,ab
and k[P ]
k[P '] for some c, P and Q. By induction hypothesis,

we can obtain ⟨⟨P ⟩⟩k −k,→ab
k,τ
R
⟨⟨P '⟩⟩k, then it follows that ⟨⟨M ⟩⟩ ≡

[c = c]⟨⟨P ⟩⟩k, ⟨⟨Q⟩⟩k −k,→ab
k,τ
R
⟨⟨P '⟩⟩k ≡ ⟨⟨M '⟩⟩ by rule MAT.

The case for mis is similar to the last case.
When par is used last to derive the transition of M , then M ≡

N |N , M' ≡ N' |N
and N
k,ab
N' , for some N
and N .	By

1	2	1	2	1	1	1	2

induction hypothesis, ⟨⟨N1⟩⟩
k,ab
R
k,τ
⟨⟨N ' ⟩⟩.	It follows that

⟨⟨M ⟩⟩ ≡ ⟨⟨N ⟩⟩|⟨⟨N ⟩⟩
k,ab
R|⟨⟨N ⟩⟩
k,τ
⟨⟨N ' ⟩⟩|⟨⟨N ⟩⟩ ≡ ⟨⟨M '⟩⟩ by rule

1	2
PAR.
2	1	2

When the last rule applied is rep, then M ≡ k[!P ] and k[P|!P ] −→

M'. By induction hypothesis, ⟨⟨P ⟩⟩k|!⟨⟨P ⟩⟩k
k,ab
R
k,τ
⟨⟨M '⟩⟩. By

rule REP, we have that ⟨⟨M ⟩⟩≡ ⟨⟨P ⟩⟩k −k,→ab
k,τ
R
⟨⟨M '⟩⟩.

When str is applied as the last rule, then M ≡ N, N
k,ab
N' and

N' ≡ M'. From induction hypothesis, we have ⟨⟨N ⟩⟩
k,ab k,τ
⟨⟨N '⟩⟩.

Lemma 4.3 shows that ⟨⟨M ⟩⟩ ≡ ⟨⟨N ⟩⟩, ⟨⟨N '⟩⟩ ≡ ⟨⟨M '⟩⟩. By using rule

STR, we conclude that ⟨⟨M ⟩⟩
α = τ
k,ab k,τ
⟨⟨M '⟩⟩.

When the rule used to derive the transition of M is go, then M ≡
k[go l.P ], N ≡ l[P ] for some l and P .  So we have ⟨⟨M ⟩⟩ = k :

k¯.⟨⟨P ⟩⟩l −k→,τ
⟨⟨P ⟩⟩l ≡ ⟨⟨N ⟩⟩.

When com is applied last, then M ≡ N |N , M' ≡ N' |N' , N  −k,→a¯b N'
1	2	1	2	1	1

and N
k,ab
N' for some N ,N' ,N 
and N' . By induction hypothesis,

2	2	1	1	2	2

⟨⟨N ⟩⟩
k,a¯b
R
k,τ
⟨⟨N ' ⟩⟩, ⟨⟨N ⟩⟩
k,ab
R
k,τ
⟨⟨N ' ⟩⟩. So ⟨⟨M ⟩⟩ ≡

1	1	1	2	2	2
⟨⟨N ⟩⟩|⟨⟨N ⟩⟩(−k→,τ )3⟨⟨N ' ⟩⟩|⟨⟨N ' ⟩⟩≡ ⟨⟨M ' ⟩⟩ by rule COM2, PAR.
1	2	1	2	2
When the rule close is applied in the last step of derivation, then M ≡

N |N , M' ≡ (νb)(N' |N' ), N
k,a¯(b)
N
and N
k,ab
N' , for some

1	2	1	2
1 −→	1	2	2

N ,N' ,N 
and N' . By induction hypothesis ⟨⟨N
k,a¯(b)
R
k,τ
⟨⟨N ' ⟩⟩

1	1	2	2
1⟩⟩ −→	1	1

and ⟨⟨N ⟩⟩
k,ab
R
k,τ
⟨⟨N ' ⟩⟩. So we have ⟨⟨M ⟩⟩ ≡ ⟨⟨N ⟩⟩|⟨⟨N ⟩⟩(−k→,τ

2	2	2	1	2
)3(νb)(⟨⟨N ' ⟩⟩|⟨⟨N ' ⟩⟩) ≡ ⟨⟨M '⟩⟩ by rule CLS2, PAR and RES.
1	2
The other cases are similar to 1.

Proof of Theorem 4.5
Proof. (⇒) We can construct a relation
R = {(⟨⟨M ⟩⟩, ⟨⟨N ⟩⟩) | M ≈D N}


and prove that it is a bisimulation up to ≈r in πrdi. Suppose that ⟨⟨M ⟩⟩
k,α

P, α ∈ {ab, a¯b, a¯(b),τ }. By operational correspondence, we have M
k,α
M

for some M' such that ⟨⟨M '⟩⟩ ≤r P , i.e., ⟨⟨M '⟩⟩ ≈r P . Since M ≈D N , we

k,αˆ
know that N =
N' and M' ≈D
N'. By Lemma 4.4, ⟨⟨N ⟩⟩ k⇒,αˆ
⟨⟨N '⟩⟩ ≡ Q.

So we have P ≈r RQ. Similarly, by using the ”up-to” techniques of [10], we
can prove that the relation R∪ ≈r is a bisimulation in πrdi. (⇐) Similarly we can prove that the relation
S = {(M, N ) | ⟨⟨M ⟩⟩ ≈r ⟨⟨N ⟩⟩}

k,α
is a bisimulation in Dπ. Suppose M
M'. By operational correspondence

we have ⟨⟨M ⟩⟩ =⇒
⟨⟨M '⟩⟩. Since ⟨⟨M ⟩⟩ ≈r
⟨⟨N ⟩⟩, we know that ⟨⟨N ⟩⟩ =⇒

P ≈r ⟨⟨M '⟩⟩. From Lemma 4.4, it follows that there exists some N', such that
k,αˆ
N
=⇒ N and ⟨⟨N ⟩⟩ ≤r P . So we have that ⟨⟨N ⟩⟩ ≈r P ≈r ⟨⟨M ⟩⟩. Therefore
(M', N') ∈ S, which means that S is a bisimulation in Dπ.
