

Electronic Notes in Theoretical Computer Science 240 (2009) 149–166
www.elsevier.com/locate/entcs

Multiple Synchrony in MSC
Fl´avia Falca˜o	Juliano Iyoda1	Augusto Sampaio
Centro de Informa´tica - UFPE Cidade Universita´ria, Recife-PE Brazil

Abstract
We propose an extension to Message Sequence Charts (MSC); MSC diagrams comprise processes (called instances) and messages. Messages in MSC are either asynchronous or method calls. Our extension adds multiple synchronous messages. We present a transformation algorithm that takes as input a diagram in the extended MSC and generates an equivalent one in the standard MSC. The synchronous messages are
transformed to the standard notation via the introduction of several control messages. We also define a semantics for MSC (both the standard and our extension) using the process algebra CSP. Both instances and messages in MSC are characterised as CSP processes. This semantics allows us to formally establish the equivalence between an extended MSC diagram and its corresponding standard diagram (generated by the
transformation algorithm). Although our strategy is application independent, the motivation came from an attempt to generate test scripts from MSC diagrams describing the behaviour of mobile phone devices.
Keywords: Message Sequence Charts, MSC, process algebra, multiple synchrony, synchronous communication, Communicating Sequential Processes, CSP.


Introduction
Message Sequence Chart (MSC) is a visual trace language, extensively used in academy and industry, to describe the communication behaviour of system compo- nents and their environment. The MSC syntax and semantics are now a standard defined by the International Telecommunication Union (ITU) [11].
A typical MSC diagram comprises several processes, called instances, and mes- sages exchanged among these processes. There are two kinds of messages: asyn- chronous and method calls. Asynchronous messages never block the sender, always take a finite amount of time to reach the receiver and are never instantaneous. Method calls block the sender until the receiver sends a return message (similar to the Sequence Diagrams messages of UML [2]). Although a method call can be used to model a synchronous message between two instances, modelling multiple

1 Juliano Iyoda wishes to thank FACEPE for the financial support.

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.050

instances synchronising over the same event might not be simple (nor elegant) with method calls, let alone with asynchronous messages.
The motivation for this work has originated from an effort to model scenarios of mobile device applications for the purpose of automatic test generation. We used the PowerToolKit (PTK) [1], a tool developed by the Motorola Labs which automatically generates test cases from MSC diagrams. Nevertheless, modelling some applications, which involved multi-synchronisation, with standard MSC has resulted in diagrams difficult to understand or with a behaviour different from the intended one. Despite this motivation, our approach is application independent.
We propose an extension to MSC in order to allow messages to be synchronous. The proposed synchronous messages denote events that are instantaneous (we ab- stract the real time duration for a communication to be established) and may in- volve multiple instances. Our extension is conservative in the sense that it allows diagrams to contain both synchronous and asynchronous messages. We developed a transformation algorithm which takes an extended MSC diagram and generates a diagram in the standard MSC. This transformation algorithm implements syn- chronous messages as a sequence of asynchronous messages following a particular handshake protocol.
A second contribution of this work is the definition of a semantics for MSC (both the standard and our extension) using the process algebra CSP [16].The semantics is defined in an algebraic way: instances and messages of an MSC diagram are CSP processes running in parallel. The formalisation of MSC in CSP allows us to show the equivalence between an extended MSC diagram and its corresponding standard diagram (generated by the transformation algorithm). Moreover, modelling MSC as a CSP process allows us to reason about MSC diagrams by using the rich set of algebraic laws of CSP, as well as its tools, like FDR2 [8] and CSP-prover [10].
There are several proposals of extensions to MSC. Different features have been added to the notation, like liveness [6], scenario triggering [17], object-orientation [4] and shared-variable communication [9]. Not surprisingly, synchronous messages have also been proposed in some works [3,6,12,13]. However, to the best of our knowledge, none have introduced multiple synchrony or have used CSP as a se- mantic model for MSC; as already mentioned, this has the advantage of immediate mechanised reasoning. More on related work can be found in Section 5.
This paper is organised as follows. Section 2 introduces the basics of the standard MSC, followed by the definition of our extension described in Section 3. Section 4 presents the semantics of MSC in CSP and, finally, conclusions, applications and future work are addressed in Section 5.

MSC
Message Sequence Chart (MSC) is a trace language for describing the communi- cation behaviour of system components and the environment. The MSC syntax and semantics are defined by the ITU [11]. MSC has two syntaxes: a graphical syntax and a textual one. The graphical syntax is the most commonly used, while

its textual form is mainly adopted by tools that perform automatic formal analysis. Figure 1 shows a simple example of the MSC graphical notation.

Fig. 1. A simple example of MSC.


An MSC diagram is formed of instances of distributed components involved in some communication. In Figure 1, we declare the instances A, B and C. The communication between instances is represented by arrows which denote messages sent from one instance to another. Each message is related to two events: a send event and a receive event. In the example, the message x is related to the events sendx and receivex; these communications are asynchronous.
The MSC semantics dictates that for each instance axis, time progresses as we move down from top to bottom. However, no global time exists. These different instances are only loosely coupled in time. For example, if an instance sends out two messages to two distinct instances, the messages can arrive in any order regardless the order they were sent. For example, the events receivex and receivey in Figure 1 can occur in any order in time. MSC event occurrences follow a partial order defined by: 1) the instance order : the events are ordered over the axis of each instance; and
2) the send-receive relation: the receive event of a message always happens after the send event of the same message. For example, we can derive the following relations from the messages in Figure 1:

sendx < receivex sendy < receivey sendx < sendy,
where a < b means that event a occurs before event b. Therefore we can see that a basic MSC can denote more than one trace of events. For instance, the traces of
the MSC depicted in Figure 1 are:
⟨sendx, receivex, sendy, receivey⟩,
⟨sendx, sendy, receivex, receivey⟩,
⟨sendx, sendy, receivey, receivex⟩.
The language is further enhanced by other operators and hierarchical constructors
(like parallel composition and choice) to compose diagrams in a higher level of abstraction. As we are not dealing with them in this work, we omit them here for conciseness.

Synchronous MSC
Synchronous communication provides a convenient model to specify interactive sys- tems in a higher level of abstraction in comparison to asynchronous communication. In particular, it abstracts away implementation details of handshake protocols, al- lowing the designer to focus on the communication at the application level. In this section we propose an extension to MSC that allows the user to specify synchronous communication, where two or more MSC instances can be synchronised on the same event. Moreover we propose an algorithm to convert from the extended MSC to the standard MSC.
Figure 2 shows an example of a conference call among three people in the standard MSC notation. The instance Flavia starts the conference by sending an invitation to the other two participants.
Flavia starts the conversation by sending two Hello messages, one to each partici- pant. Augusto replies by saying How are you to both Flavia and Juliano. This diagram denotes several traces. For instance:

⟨sendinviteJ, receiveinviteJ, sendinviteA, receiveinviteA, sendackJ, receiveackJ, sendackA, receiveackA, sendHello0, sendHello1, receiveHello1,
sendHow are you0, sendHow are you1, receiveHow are you1, receiveHello0, receiveHow are you0⟩
Although this could be a valid scenario for some systems, such a trace might be illegal for others. If we want to model a system that prevents traces where Hello messages are interleaved with How are you messages, we have to introduce several control messages to guarantee atomicity and multiple synchrony. For instance, Au- gusto should only be able to send a message after receiving the system’s permission.

Fig. 2. A conference call with 3 people.
Alternatively, Figure 3 shows the same scenario using our extension to MSC. This diagram contains both synchronous and asynchronous messages. The mes- sages that invite participants to the conference call are asynchronous. For instance,

the invitation to Augusto can be sent before the arrival of Juliano’s invitation. In contrast, once all participants have agreed to join the call, the conversation is car- ried out in a synchronous way. The messages Hello and How are you are atomic, and synchronise over all participants simultaneously. Hello was sent by Flavia and How are you, by Augusto. Although this information is indicated in the diagram (Figure 3), it is omitted here for simplicity.
The diagram shown in Figure 3 denotes several traces.

⟨sendinviteJ, sendinviteA, receiveinviteJ, sendackJ, receiveackJ, receiveinviteA, sendackA, receiveackA, Hello, How are you⟩,
⟨sendinviteJ, receiveinviteJ, sendackJ, sendinviteA, receiveackJ, receiveinviteA, sendackA, receiveackA, Hello, How are you⟩, ... 
Nevertheless, notice that the synchronous messages are related to a single event.

Fig. 3. A synchronous MSC diagram.
As the standard MSC notation is widely used by many designers and, especially, by many tools, we propose a transformation algorithm that generates a standard MSC diagram from the extended one. The algorithm introduces several control messages to implement the synchronous events.
The first step of the algorithm transforms each synchronous message into a sequence of asynchronous messages. This sequence must adhere to the following generation condition: every instance involved in the multiple synchrony must either send or receive at least one asynchronous message. For example, the message Hello in Figure 3 is sent by Flavia to all, and synchronises the instances Flavia, Juliano and Augusto. So, these instances must either send or receive an asynchronous Hello. In our example, two asynchronous messages sent from Flavia to Juliano and Augusto are generated (see Figure 4). These messages satisfy the generation condition and model the first sentence of the dialogue, where Flavia says Hello to everybody. In fact, we could have added more Hello messages and in a different order if we wished, provided that the generation condition is satisfied. These choices are design de- cisions left to the engineer. The generation condition minimally ensures that all instances in multiple synchrony are somehow participating in a communication in the asynchronous domain.

Figure 4 shows this step applied to the diagram of Figure 3. The sequence of asynchronous messages generated from a single synchronous message is called a synchronous section. The synchronous sections are indicated in Figure 4 by dashed boxes, which are not part of the MSC diagram. For instance, the messages Hello0 and Hello1 in Figure 4 belong to the same synchronous section as they are derived from the synchronous message Hello in Figure 3. The messages inviteJ, inviteA, ackJ and ackA, which were originally asynchronous, remain the same. We call the instances that either send or receive messages inside a synchronous section S , the active instances of S . For example, the active instances of the synchronous section 1 are Flavia, Juliano and Augusto.







Synchronous section 1


Synchronous section 2


Fig. 4. First step of the algorithm.

The second step introduces control messages τ in order to isolate each syn- chronous section from the messages that occur before and after it. These messages
are introduced according to the following rules. For each synchronous section:
Above Add τ messages above the synchronous section from all active instances to the active instances which produce the first “send” events of the synchronisation
section.
Below Add τ messages below the synchronous section from the active instances which produce the last “receive” events of the synchronisation section to all the
active instances.
In both cases, we do not need to send τ messages from an instance to itself.
The τ messages above the synchronisation section force the completion of all pre- instance has to receive or send a τ message before synchronising. As every instance ceding events of messages that occur before the section. This happens because every obeys a total order of events on its axis, no preceding event on that axis occurs
after send τ or receiveτ events (recall the instance order described in Section 2). Moreover, all τ messages arrive before the first messages of the synchronisation sec- τ messages before starting the synchronisation. Therefore τ messages isolate the tion are sent. The send-receive relation (Section 2) ensures the completion of all

all active instances get ready to synchronise. Similarly, the τ messages below the synchronisation section to ensure that every preceding event occurs in advance so messages are received. As mentioned above, we can omit τ messages sent from an synchronisation section force every event following the section to occur after its last instance to itself. According to the algorithm, such instances are those which either
those which are either the target of τ messages sent from others (above) or the initiate or terminate the synchronisation. Therefore, these instances are precisely source of τ messages sent to others (below). This automatically guarantees the
isolation of such instances.
Figure 5 shows the transformation from the extended MSC to the standard MSC using the rules above. Again the dashed boxes only indicate the synchronous
sections (now extended with the τ messages) but are not part of the MSC dia- gram. Note that the message τ0 forces any event above the synchronisation section on the Juliano’s axis to occur before sendHello0, which is the only initial event of
sages sent in parallel). Any such event must be followed by sendτ0, receiveτ0 and this section (in general, more than one initial events might be present due to mes- sendHello0. Similarly, the τ messages inserted below the synchronisation section
prevents any event to occur before the last events of the section. Notice that in this
example, both receiveHello0 and receiveHello1 may be considered the last events of the synchronisation section. There is no total order for their occurrences, in
contrast to the only possible first event sendHello0. This justifies the addition of τ2 and τ3 for receiveHello1, and τ4 and τ5 for receiveHello0. The τ messages related to How are you0 and How are you1 follow a similar reasoning. Some τ messages are redundant in this example, but this might not be the case in general.
We still have a final issue to address: How do we relate the asynchronous diagram in Figure 5 to the extended one in Figure 3? The diagram in Figure 5 denotes several traces like:

⟨sendinviteJ, receiveinviteJ, sendinviteA, receiveinviteA, sendackJ, sendackA, receiveackJ, receiveackA, sendτ0, receiveτ0,
sendτ1, receiveτ1, sendHello0, receiveHello0, sendHello1, receiveHello1, sendτ2, receiveτ2, sendτ3, receiveτ3, sendτ4, receiveτ4,
sendτ5, receiveτ5, sendτ6, receiveτ6, sendτ7, receiveτ7, sendHow are you0, receiveHow are you0, sendHow are you1, receiveHow are you1, sendτ8, receiveτ8, sendτ9, receiveτ9, sendτ10, receiveτ10, sendτ11, receiveτ11⟩
We need a mapping which transforms such traces into the traces of Figure 3. For instance, the equivalent trace of the one shown above in the extended MSC is:

⟨sendinviteJ, receiveinviteJ, sendinviteA, receiveinviteA, sendackJ, sendackA, receiveackJ, receiveackA, Hello, How are you⟩
Both diagrams of figures 3 and 5 denote several traces. We have to find a mapping between their events which relate them all.
From the example above, it is not hard to see that this mapping has to remove



Fig. 5. The standard MSC diagram derived from the extended one.
all sendτi and receiveτi and has to relate, say, the set
{sendHello0, receiveHello0, sendHello1, receiveHello1}
to the event Hello. Similarly, the events {sendHow are you0, receiveHow are you0, sendHow are you1, receiveHow are you1} must be associated with How are you. Modelling systems at different levels of abstraction has the advantage of captur-
ing several architectural views. In general these views are presented using different alphabets. Therefore it is necessary to provide a mapping between them [5]. Syn- chronous communication is observed by the environment as an atomic event. At this level of abstraction, we observe the system at specific relevant moments. However, any synchronous communication is implemented by some kind of handshake pro- tocol dealing with asynchronous communication. A designer of such system must
messages τ and allows system observations only when the last asynchronous mes- observe it in a higher frequency (see Figure 6). Our mapping simply ignores control sage of the handshake occurs. This last event characterises a successful handshake
and, therefore, the end of a transaction. These concepts are partly inspired by the time abstraction concept used in hardware design [15]. The asynchronous messages present in the extended MSC are mapped to themselves. The following sections describe how this mapping can be formally defined to provide a solid justification for our transformation algorithm.

synchronous model
Hello
t





receiveτ

sendHello0

receiveHello0

sendHello1	receiveHello1
t '
sendτ

asynchronous model
Fig. 6. Mapping asynchronous events to synchronous ones.
MSC Semantics
In this section we propose a formal semantics for MSC based on CSP (Commu- nicating Sequential Processes). This semantics allows us to formally define the transformation from synchronous MSC to asynchronous MSC and to reason about the relationship between them, possibly using tools such as FDR: a model checker for CSP.

CSP
CSP allows describing systems in terms of processes that operate independently and interact with each other through synchronous message passing-communication. CSP offers a rich repertoire of process algebra operators and a few primitive con- structors. Communications in CSP are atomic and instantaneous events. Events can transmit information through unidirectional channels. The occurrence of an event characterises a communication with another process or with the environment. Processes are behavioural description units described by the way they commu- nicate with their environment. There are two primitive processes: Stop, which represents canonical deadlock; and Skip, which represents successful termination. The simplest CSP operator is the prefix. Let a be an event and P a process, then a → P is the process that waits indefinitely to communicate a and, after that,
behaves like the process P .
For example, suppose we define (S = a → b → c → Skip), (T = r → a → U ) and (U = d → Skip). S waits for the events a, b and c to happen in sequence and then terminates successfully. T communicates the events r and a, and behaves like
U . Finally U waits for the event d before terminating with success.
example, the alphabets of S , T and U are {a, b, c}, {r , a} and {d }, respectively. The set of all events that a process can engage in is called its alphabet . For Processes can be composed in a sequential way using the sequential operator.
In (P = Q ; R) the process P behaves like Q initially. If Q terminates successfully, the process behaves like R. If Q does not terminate, the process P also does not terminate and never behaves like R.
Alternative behaviour is provided by two operators: internal and external choice. The internal or non-deterministic choice H allows the future behaviour of a process to be defined internally to the system, with no control from the environment. External

or deterministic choice  allows the environment to choose between two processes by communicating the initial event of one of them. For example, (a → Stop) (b → Stop) communicates either a or b, depending on what the environment offers firstly. We denote by (?x : A → P ) the process which accepts any element of the set A and behaves like P .
Processes can also be combined in parallel. Let A and B be sets of events. The alphabetised parallel operator A ||B combines processes that must cooperate upon every event in the set A ∩ B . Events outside the intersection are communicated with the environment. For instance, the process
(a → b → b → Stop) {a,b}||{b,c} (b → c → b → Stop)
behaves like (a → b → c → b → Stop). Usually processes combined with the alphabetised parallel operator follow the pattern
(P X||Y ∪Z (Q Y ||Z R)).
If we have to compose a large network of processes this way, the notation becomes
very clumsy. A convenient indexed notation is provided to handle very large com- positions like this [16].


n  i =1
(Pi , Xi ) = P1 X1||X2 ∪...∪Xn (... (Pn−1 Xn−1||Xn Pn) .. .)

The interface parallel operator || explicitly shows the set of processes C over
C
which the component processes synchronise on. For example, the process (P || Q )
C
synchronises P and Q in all communication events in the set C . Events outside C
proceed independently.
The interleaving operator ||| combines processes in parallel which are completely independent from each other. The process (P ||| Q ) behaves as both P and Q simul- taneously. The events are interleaved in time. The indexed notation for interleaving is defined as follows.


n  i =1
Pi = P1 ||| ... ||| Pn

Events can be made invisible to the environment by the hiding operator \. This
operator is used to remove some events from the interface. Let P be a process and
A be a set of events. All the events in A are removed from the interface of the process P \ A.
traces. For instance, the trace ⟨a, b⟩ is a trace of the process P = a → b → c →  The simplest semantic model of a CSP process is that which denotes a set of Skip. The set of all traces of a process P is denoted by traces (P ). In the traces
model, a process P is refined by a process Q , denoted by P ±T Q , whenever traces (Q ) ⊆ traces (P ). Two processes P and Q are equivalent in the traces model whenever P ±T Q and Q ±T P . There are other models of CSP which are more

elaborate than the traces model. The failures model takes into account the events a process can refuse to do. The failures/divergences model takes into account the possibility of a process to enter an infinite sequence of internal actions (called a divergence). These models also have their notions of refinement, denoted by P ±F Q
for the failures model and P ±FD Q for the failures/divergences model (see [16] for
their formal definitions).

Formal Semantics for Standard and Extended MSC in CSP
The semantics of an MSC diagram is defined as a CSP process. This mapping is defined based on the partial order of events used to generate the traces of an MSC diagram. Inspired by the MSC trace generation rules, we look at a diagram from two perspectives: the vertical and the horizontal dimensions. The first perspective works only with the vertical axis where the instances run. Each instance becomes a CSP process defined by the sequence of events that occurs along its axis. For example, the instance A in Figure 1 is represented by the following process.
A = send x → send y → Skip
The CSP events send x and send y are precisely those events that occur along the axis of the instance A in the diagram of Figure 1. Similarly, the instances B and C have the following CSP representation.
B = receivex → Skip
C = receivey → Skip
The horizontal dimension captures the messages themselves. Every message of an MSC diagram becomes a process defined by two events: the send and the receive events. The messages in Figure 1 are defined as follows.

x = send x → receivex → Skip y = send y → receivey → Skip
These two dimensions are then combined to form the formal semantics of an MSC diagram. The partial order of the events defined in a diagram naturally occurs in the CSP process once we compose the processes that represent the two dimensions in parallel. The parallel composition is defined according to the following rule.
Let instancei be a process that represents an instance, and messagej a process that represents a message. Let Σ be the union of the alphabets of all processes. The semantics of a standard MSC diagram is defined by


standardMSC = (|||
n  i =1
instancei ) ||
Σ
m
(
j =1
messagej )

For the diagram example in Figure 1, the process that captures its semantics is

defined as


simpleMSC = (A ||| B ||| C ) ||
Σ
(x ||| y )

where Σ = {send x , receivex , send y , receivey }.
The traces generated by this CSP process are exactly the same defined by the
corresponding MSC diagram. Intuitively, each process enforces the partial order rules (recall the instance order and the send-receive relation introduced in Sec- tion 2). The processes instancei ensure the correct order of events along the life axis of each instance. The processes messagej enforce that every send event comes before a receive event. In the standard MSC, there is no synchronisation among instances as they always communicate via asynchronous messages. Messages also do not interact among themselves. Thus we can group them together using interleav- ing. However, messages and instances do synchronise, which is captured by their parallel composition. For instance, the processes B and x synchronise on the event receivex .
In the case of the proposed MSC with multi synchrony, the primitive processes are defined in the same way. For instance, the processes for the extended MSC depicted in Figure 3 are shown below.

Flavia = send inviteJ → send inviteA → receiveackJ → receiveackA →
Hello → How are you → Skip
Juliano = receiveinviteJ → send ackJ → Hello → How are you → Skip Augusto = receiveinviteA → send ackA → Hello → How are you → Skip minviteJ = send inviteJ → receiveinviteJ → Skip
minviteA = send inviteA → receiveinviteA → Skip mackJ = send ackJ → receiveackJ → Skip mackA = send ackA → receiveackA → Skip mHello = Hello → Skip
mHowAreYou = How are you → Skip

Note that the synchronous messages Hello and How are you are represented as a single event in CSP. Nevertheless, the top-level process is constructed in a slightly different way. As the instances now synchronise among themselves, we have to use the parallel operator to group them.
Let instancei and messagej be processes which represent an instance and a mes-
sage, respectively. Let αi be the alphabet of instancei and Σ =  n	αi . We define
the semantics of extended MSC diagrams as follows.


extendedMSC =( 
n  i =1
(instancei , αi )) ||
Σ
m
(
j =1
(messagej ))

The top-level process for the example of Figure 3 is shown below.
confCall = (Flavia αF ||αJ ∪αA (Juliano αJ ||αA Augusto)) ||
Σ
(minviteJ ||| minviteA ||| mackJ ||| mackA ||| mHello |||
mHowAreYou)
where αF = {send inviteJ , send inviteA, receiveackJ , receiveackA, Hello,
How are you}, αJ = {receiveinviteJ , send ackJ , Hello, How are you}, αA =
{receiveinviteA, send ackA, Hello, How are you} and Σ = αF ∪ αJ ∪ αA.
The semantics of the standard MSC is actually a special case of the semantics of
the extended MSC. The alphabets of the instances instancei in the standard MSC form a partition; therefore, their alphabets are pairwise disjoint. From the definition of the parallel operator, these processes run independently: in interleaving.
An Equivalence Notion for Standard and Extended MSC
In order to show that our translation from extended to standard MSC diagrams preserve behaviour, we need to define an equivalence notion for such diagrams. Clearly, we cannot compare these diagrams directly, since their alphabets are not the same; as illustrated by Figure 6, a synchronous message can be regarded as an abstraction of a sequence of asynchronous messages. Therefore, we need to take into account such a mapping to be able to define an equivalence notion for extended and standard MSC diagrams.
Let Sync be the set of synchronous events of an extended diagram whose se- mantics is given by the CSP process extended . Similarly, let Async be the set of asynchronous messages of the standard diagram whose semantics is given by the CSP process standard .  These processes are compared through a mapping
M : Sync '→ ℘(seq Async) that relates each (abstract) synchronous message into
a set of corresponding traces of (concrete) asynchronous messages. Intuitively, we
consider extended and standard equivalent diagrams if and only if replacing the synchronous messages with the corresponding concrete traces in extended results in a process, say mappedExtended , equivalent to standard in the failures/divergences model of CSP.
As an example, we show below the corresponding sequences of asynchronous messages related to the synchronous message Hello (see Figure 5).
M (Hello) '→ { ⟨send Hello0, receiveHello0, send Hello1, receiveHello1⟩,
⟨send Hello0, send Hello1, receiveHello0, receiveHello1⟩,
⟨send Hello0, send Hello1, receiveHello1, receiveHello0⟩ } 
Our first step is to build the process mappedExtended . This can be achieved by
first characterising the mapping as a CSP process.
Map(Async, Sync)= (?async : Async → Map(Async, Sync))
  (?sync : Sync → P (M (sync)))
  (f → Skip)

where P (M (sync)) denotes the process whose traces are those returned by M (sync).
For instance, P (M (Hello)) denotes the process


send Hello0 →
(receiveHello0 → send Hello1 → receiveHello1 → Map(Async, Sync))
  (send Hello1 → (receiveHello0 → receiveHello1 → Map(Async, Sync))
  (receiveHello1 → receiveHello0 → Map(Async, Sync))).
The process Map is designed to run in parallel with extended . They synchronise in every event. Whenever they synchronise over an asynchronous event, Map simply recurses and no mapping is done. In contrast, if they synchronise over a synchronous event sync, all the corresponding sequences of asynchronous events of sync are generated by P (M (sync)). The event f is used to detect termination of extended and, consequently, of Map.
The process mappedExtended can then be defined as:
mappedExtended (Async, Sync) = ((extended ; (f → Skip)) ||
Σ∪{f }
Map(Async, Sync)) \ (Sync ∪ {f })
whereΣ is the alphabet of extended . Notice that extended is composed in sequence with (f → Skip). The event f signals to Map the termination of extended . The final step hides the synchronous events and f from mappedExtended , leaving it with asynchronous events only.
We say that standard and extended are equivalent if and only if the following holds:


mappedExtended (Async, Sync) ±FD (standard \ taus) (standard \ taus) ±FD mappedExtended (Async, Sync)


where taus is the set of all τ events introduced. The advantage of this characteri- sation is that it can be mechanically checked using FDR.
As an example, in the reminder of this section we show that the translation of the diagram in Figure 3 into that in Figure 5 does preserve behaviour. First we define the CSP process for the diagram of Figure 5. Every instance and every

message becomes a process as shown below.

receiveτ0  →  receiveτ1  →  send Hello0  →  send Hello1  → Flavia' = send inviteJ → send inviteA → receiveackJ → receiveackA → receiveτ3 → receiveτ5 → send τ7 → receiveHow are you1 → send τ8 → send τ9 → receiveτ11 → Skip
Juliano' = receiveinviteJ → send ackJ → send τ0 → receiveHello0 →
receiveτ2 → send τ4 → send τ5 → send τ6 → receiveHow are you0 →
receiveτ8 → send τ10 → send τ11 → Skip
Augusto' = receiveinviteA → send ackA → send τ1 → receiveHello1 →
send τ2 → send τ3 → receiveτ4 → receiveτ6 →
receiveτ7 → send How areyou0 → send How areyou1 →
receiveτ9 → receiveτ10 → Skip inviteJ = send inviteJ → receiveinviteJ → Skip
inviteA = send inviteA → receiveinviteA → Skip ackJ = send ackJ → receiveackJ → Skip
ackA = send ackA → receiveackA → Skip Hello0 = send Hello0 → receiveHello0 → Skip Hello1 = send Hello1 → receiveHello1 → Skip
HowAreYou0 = send How are you0 → receiveHow are you0 → Skip HowAreYou1 = send How are you1 → receiveHow are you1 → Skip
τ0 = send τ0 → receiveτ0 → Skipτ1. =.. send τ1 → receiveτ1 → Skip
τ2 = send τ2 → receiveτ2 → Skip τ3 = send τ3 → receiveτ3 → Skip τ4 = send τ4 → receiveτ4 → Skip τ5 = send τ5 → receiveτ5 → Skip τ6 = send τ6 → receiveτ6 → Skip τ7 = send τ7 → receiveτ7 → Skip τ8 = send τ8 → receiveτ8 → Skip τ9 = send τ9 → receiveτ9 → Skip τ10 = send τ10 → receiveτ10 → Skip τ11 = send τ11 → receiveτ11 → Skip
Following the strategy presented in the previous section, these processes are combined to capture the behaviour of the entire diagram, giving rise to the following process.


confCall ' = (Flavia' ||| Juliano' ||| Augusto') ||
Σ
(inviteJ ||| inviteA ||| ackJ |||

ackA ||| Hello0 ||| Hello1 ||| HowAreYou0 ||| HowAreYou1 |||
τ0 ||| τ1 ||| τ2 ||| τ3 ||| τ4 ||| τ5 ||| τ6 ||| τ7 ||| τ8 ||| τ9 ||| τ10 ||| τ11)
where Σ is the union of the alphabets of all processes.
Now we can focus on the relations between confCall ' and confCall , which is defined in Section 4.2. The mapping M between the synchronous and the asyn-

chronous messages is defined as follows:
M (Hello) '→ { ⟨send Hello0, receiveHello0, send Hello1, receiveHello1⟩,
⟨send Hello0, send Hello1, receiveHello0, receiveHello1⟩,
⟨send Hello0, send Hello1, receiveHello1, receiveHello0⟩ } 
M (How are you) '→ { ⟨send How are you0, receiveHow are you0,
send How are you1, receiveHow are you1⟩,
⟨send How are you0, send How are you1, receiveHow are you0, receiveHow are you1⟩,
⟨send How are you0, send How are you1, receiveHow are you1, receiveHow are you0⟩ } 
The set of synchronous events Sync = {Hello, How are you}. The CSP process Let Σ be the alphabet of confCall and Async be the alphabet of confCall '. that represents this mapping can be automatically obtained by instantiating Map
with the relevant parameters; its extended definition is given below (notice that we inlined P (M (Hello)) and P (M (How are you))).
MapConf = (?async : Async → MapConf (Async))
  Hello → send Hello0 →
((receiveHello0 → send Hello1 → receiveHello1 → MapConf )
  (send Hello1 → ((receiveHello0 → receiveHello1 → MapConf )
  (receiveHello1 → receiveHello0 → MapConf ))))
  How are you → send How are you0 →
((receiveHow are you0 → send How are you1 →
receiveHow are you1 → MapConf )
  (send How are you1 → ((receiveHow are you0 →
receiveHow are you1 → MapConf )
  (receiveHow are you1 →
receiveHow are you0 → MapConf ))))
  (f → Skip)
The process confCallMapped with its synchronous messages mapped to the cor- responding asynchronous sequences is defined as:


confCallMapped = ((confCall ; (f → Skip))	||
Σ∪{f }
MapConf ) \ (Sync ∪ {f })

Let taus = {send τ0, receiveτ0,... , send τ11, receiveτ11}. Finally we check their equivalence by submitting the following assertions to FDR:

confCallMapped ±FD (confCall ' \ taus) (confCall ' \ taus) ±FD confCallMapped
which holds, as expected.

Conclusion



We extended MSC with synchronous messages, which denote an atomic and instan- taneous single event in the MSC traces. Multiple instances are able to synchronise over the same message. Our extended MSC allows both synchronous and asyn- chronous messages to appear in a diagram. An example shows how a conference call dialogue is modelled with the extended MSC. Asynchronous messages are sent to all participants, followed by multiple synchronous messages once the conference call is established.
A transformation algorithm which takes an extended MSC diagram and gener- ates a standard one was proposed. The algorithm implements multiple synchronous messages via the introduction of several asynchronous control messages.
In addition to that, we also defined a formal semantics for both the standard and the extended MSC in CSP. Our formalisation mapped each instance and each message of an MSC diagram into a CSP process. By composing them in parallel, we capture the MSC semantics of the partial order of events. All traces in CSP are precisely the same as those in MSC. We showed in CSP that an extended MSC diagram and its corresponding standard diagram (generated by the transformation algorithm) are equivalent by replacing a synchronous message by its corresponding asynchronous messages. We checked their equivalence in FDR [8].
There are several dialects of MSC. Most of them offer only asynchronous and method call messages like Object MSC [4] and Sequence Diagrams [2]. Extended Event Traces [3] and Interworkings [13] provide only synchronous messages, while Live Sequence Charts [6] and Ladkin and Leue’s extension [12] offer both syn- chronous and asynchronous messages. However, none of them provide multiple synchrony or an algorithm which converts an MSC dialect into the standard MSC. Engels et al. propose an approach in the other direction, though [7]. They present formal definitions to verify whether a standard MSC diagram can be implemented in several communication models, including the synchronous messages of Inter- workings. Most of related works have also proposed a formal semantics for MSC. However, to our knowledge, there are no semantics based on CSP, although there are semantics based on process algebra [14].
As already mentioned, the motivation for this work resulted from our effort to use the PowerToolKit (PTK) [1]: a tool developed by Motorola Labs which generates executable test scripts by reading and analysing MSC diagrams together with associated message specifications. The tool can generate multiple test scripts which test the behaviour of a standard MSC. With extended MSC, we are now able to properly model mobile device applications with multi-synchronisation and to investigate a development process using our extended notation and PTK. We also plan to mechanise the generation of standard MSC diagrams from extended ones and to provide a general proof of correctness of the translation.

References
Baker, P., P. Bristow, C. Jervis, D. J. King and B. Mitchell, Automatic generation of conformance tests from message sequence charts, in: E. Sherratt, editor, Telecommunications and beyond: The Broader Applicability of SDL and MSC, Lecture Notes in Computer Science 2599 (2002), pp. 170–198.
Booch, G., J. Rumbaugh and I. Jacobson, “The Unified Modeling Language User Guide,” Addison Wesley, Reading, Massachusetts, 1998.
Broy, M., C. Hofmann, I. Kruger and M. Schmidt, Using extended event traces to describe communication in software architectures, in: Proceedings of the Asia-Pacific Software Engineering Conference and International Computer Science Conference (1997).
Buschmann, F., R. Meunier, H. Rohnert, P. Sommerlad and M. Stal, “Pattern-Oriented Software Architecture. Volume I: A System of Patterns,” Wiley, 1996.
Cabral, G. and A. Sampaio, Formal specification generation from requirement documents, Electronic Notes in Theoretical Computer Science 195 (2008), pp. 171–188.
URL http://dx.doi.org/10.1016/j.entcs.2007.08.032

Damm, W. and D. Harel, LSCs: Breathing life into Message Sequence Charts, Formal Methods in System Design 19 (2001), pp. 45–80.
Engels, A. G., S. Mauw and M. A. Reniers, A hierarchy of communication models for Message Sequence Charts, Science of Computer Programming 44 (2002), pp. 253–292.
“Failures-Divergence Refinement: FDR2 User Manual,” (2005).
Grosu, R., I. Kruger and T. Stauner, Hybrid sequence charts, in: ISORC’00 (2000), p. 104.
Isobe, Y. and M. Roggenbach, A generic theorem prover of CSP refinement, in: N. Halbwachs and
L. D. Zuck, editors, TACAS’05, Lecture Notes in Computer Science 3440 (2005), pp. 108–123.
ITU-TS, ITU-TS recommendation Z.120: Message sequence chart 1999 (MSC99), Technical report, ITU-TS, Geneva (1999).
Ladkin, P. B. and S. Leue, What do Message Sequence Charts mean?, in: FORTE’93, Proceedings of the IFIP TC6/WG6.1. (1994), pp. 301–316.
Mauw, S. and M. Reniers, A process algebra for Interworkings, in: J. A. Bergstra, A. Ponse and S. A. Smolka, editors, Handbook of Process Algebra (2001), pp. 1269–1327.
Mauw, S. and M. A. Reniers, An algebraic semantics of basic Message Sequence Charts, The Computer Journal 37 (1994), pp. 269–278.
Melham, T. F., Abstraction mechanisms for hardware verification, in: G. Birtwistle and P.A. Subrahmanyam, editors, VLSI Specification, Verification, and Synthesis (1988), pp. 129–157.
URL http://citeseer.ist.psu.edu/melham87abstraction.html
Roscoe, A. W., “Theory and Practice of Concurrency,” Prentice-Hall, 1998.
Sengupta, B. and R. Cleaveland, Triggered Message Sequence Charts, IEEE Transactions on Software Engineering 32 (2006), pp. 587–607.
