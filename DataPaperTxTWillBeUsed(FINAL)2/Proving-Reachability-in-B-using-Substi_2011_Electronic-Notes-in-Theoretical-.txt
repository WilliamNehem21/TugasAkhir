Available online at www.sciencedirect.com



Electronic Notes in Theoretical Computer Science 280 (2011) 47–56
www.elsevier.com/locate/entcs

Proving Reachability in B using Substitution Refinement
Marc Frappiera,1,2 Fama Diagnea,b,3 Amel Mammarb,4
a GRIL, D´ep. d’informatique, Universit´e de Sherbrooke, Sherbrooke (Qu´ebec), Canada
b Institut Telecom SudParis, CNRS/SAMOVAR, Paris, France

Abstract
This paper proposes an approach to prove reachability properties of the form AG (ψ ⇒ EF φ) using substi- tution refinement in classical B. Such properties denote that there exists an execution path for each state satisfying ψ to a state satisfying φ. These properties frequently occur in security policies and information systems. We show how to use Morgan’s specification statement to represent a property and refinement laws to prove it. The idea is to construct by stepwise refinement a program whose elementary statements are operation calls. Thus, the execution of such a program provides an execution satisfying AG (ψ ⇒ EF φ).
Proof obligations are represented using assertions (ASSERTIONS clause of B) and can be discharged using Atelier B.
Keywords: B Notation, proof, reachability, CTL, refinement calculus


Introduction
Reachability properties frequently occurs in information systems and security poli- cies. For example, in a library system, a typical property is that a member should always be able to borrow a book. If the book is available and the member hasn’t reached his loan limit, he can proceed immediately and borrow the book; if he has reached his loan limit, he can return one of his borrowed book and then borrow the book. If the book is already borrowed by another member, then he can make a reservation and wait for his turn to borrow the book. In this description, we see that the specifier must take into account several cases when proving such a property. They are documented in use cases and scenarios during requirements analysis. In a

1 This research is supported in part by the Natural Sciences and Engineering Research Council of Canada (NSERC)
2 Email: Marc.Frappier@USherbrooke.ca
3 Email: Fama.Diagne@USherbrooke.ca
4 Email: Amel.Mammar@it-sudparis.eu

1571-0661 © 2011 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2011.11.017

clinical information system, similar properties arise, especially when access control rules and patient consent rules are used. One wants to ensure that in case of emer- gencies, doctors can still reach the desired information, or appropriately process patient transfers between departments, etc.
Such reachability properties can be expressed in CTL [8], because one only needs to show the existence of a path. LTL [18] is inappropriate, because LTL properties must be satisfied by all execution paths. Our reachability properties need not be satisfied by all execution path: for instance, a member is never forced to borrow a book. In fact, such properties triggered the definition of CTL in the early 80’s.
This form of reachability is expressed in CTL as AG (ψ ⇒ EF φ). This formula denotes that there exists an execution path from each state satisfying ψ to a state satisfying φ. In the context of proving CTL properties for classical B abstract machines, an execution path is a sequence of operation calls. One way to prove a reachability property is to provide a program p, whose elementary statements are operation calls, which are combined with some operators, and to show that ψ ⇒ [p]φ. Operator “[ ]” is the traditional substitution semantic operator of the B theory, which is the same as Dijkstra’s weakest precondition operator, denoted by wp(p, φ). This statement essentially states that p, when started in ψ, is guaranteed to terminate in a state satisfying φ. By proving this statement, one proves the existence of a path from ψ to φ. If one uses B substitutions to construct p, then the B theory can be used to prove this statement.
Existing tools like Atelier B cannot directly handle an expression like ψ ⇒ [p]φ, but such an expression can easily be translated into an assertion, using the laws of “[ ]”. One can then use traditional tools like Atelier B to prove it. However, the proof obligations generated from ψ ⇒ [p]φ can be large and complex, so hard to prove. This is why the idea of refinement calculus was introduced [2,3,10,13,15,17]. In this paper, we show how to prove these statements using the well-documented refinement calculus of Carroll Morgan [14] in a B context.
Proving Reachability using Substitution Refinement
Morgan has proposed a number of refinement rules to develop sequential programs in a stepwise fashion. He introduced the notion of speciﬁcation statement, denoted by w : [pre, post], that specifies a computation which, when started in a state satisfying pre, must terminate in a state satisfying post, by modifying variables w. To avoid any confusion with “[. . . ]” of the B notation, let us write Morgan’s specification statement as Spec(pre , post) and consider it as a new B substitution. We eliminate w from the notation, because it suffices for our purpose to implicitly let w denote all variables of a B machine. Note that this statement can be written in B as:
w : [pre, post]= PRE pre THEN ANY wj WHERE postj THEN w := wj  (1) The wp-semantics of Spec(pre , post) is defined as follows:
[Spec(pre , post)]Q  ⇔  pre ∧ (∀ w · post ⇒ Q)

One can prove the refinement of a specification statement by a substitution S as follows:
Spec(pre , post) ± S  ⇔  (pre ⇒ [S]post)	(2)
Thus, the problem of proving a CTL reachability formula AG (ψ ⇒ EF φ) can be formulated as finding a program S such that Spec(ψ , φ) ± S. We will show how to conduct these proofs using refinement laws proposed by Morgan in [14].
As a first example, let us consider a B machine which describes the behavior of a library system, and show that a member can always borrow a book (see Appendix A). Thus we want to prove the following:
AG (me ∈ member ∧ bo ∈ book ⇒ EF bo '→ me ∈ loan)
The B machine variables member, book and loan respectively denote the set of members, books and loans of the library. All the variables of this CTL formula are implicitly universally quantified. In the sequel, we will use the following abbrevia- tions:
ψ = me ∈ member ∧ bo ∈ book φ = bo '→ me ∈ loan
Thus, we must find a program S such that Spec(ψ , φ) ± S. We will construct S by stepwise, algorithmic refinement (ie, B substitution refinement, not B machine refinement) using Morgan’s laws. The execution path that S will follow can be summarized as follows: i) if the member has reached his loan limit, return one book borrowed by the member; ii) if the book is borrowed, return it; iii) if the book has reservations, cancel them. This is a brute force strategy in terms of path. Other paths corresponding to more probable scenarios could also be proved. We shall
come back to this discussion at the end of the section. For now, this brute force strategy is sufficient to prove our CTL formula.
The first step is to decompose the specification in two parts: the first part will establish a condition C1 sufficient to satisfy the precondition of operation Lend; the second part will start from C1 and establish φ, and we will then show its refinement by a call to Lend. So our first refinement step is the following:
Spec(ψ , φ) ± S1 ; S2	(3)
where
S1 = Spec(ψ , ψ ∧ C1) S2 = Spec(ψ ∧ C1 , φ) C1 = C2 ∧ C3 ∧ C4
C2 =Δ card(loanD{me}) < MaxNbLoans
C3 = bo /∈ dom(loan)
C4 = reservation(bo)= [ ]

Refinement (3) is immediately proved using law 3.3 of [14]:
Spec(pre , post) ± Spec(pre , mid); Spec(mid , post)	(4) We can refine S2 by an operation call to Lend.
S2 ± Lend(me, bo)	(5)
This refinement can be proved using (2).
S2 ± Lend(me, bo) ⇔  (ψ ∧ C1 ⇒ [Lend(me, bo)]φ)
This proof can be discharged by rewriting [Lend(me, bo)]φ using standard B axioms, which results in the following formula that can be proved by adding it as an assertion in the Library machine.
ψ ∧ C1 ⇒ me ∈ MEMBERID ∧
me ∈ member ∧ bo ∈ BOOKID ∧ bo ∈ book ∧
bo /∈ dom(loan) ∧
reservation(bo)= [ ] ∧ card(loanD{me}) < MaxNbLoans ∧ bo '→ me ∈ loan<+{bo '→ me}
We have now solved S2 by refining it into a substitution whose elementary state- ments are operation calls. We will solve S1 in three steps.
S1 ± S3 ; S4	(6)
S3 = Spec(ψ , ψ ∧ C2)
S4 = Spec(ψ ∧ C2 , ψ ∧ C1) We can again prove (6) using (4).
Specification S3 states that the member should not have reached it loan limit. To solve it, we can test C2, which ensures that the loan limit is not reached; if C2 is false, then we nondeterministically chose a borrowed book of the member and return it, to establish C2. Thus S3 is solved as follows:
S3 ± IF ¬C2 THEN S5 END	(7)
where
S5 =Δ ANY boj WHERE boj ∈ loan—1[{me}] THEN Return(boj) END   (8) We can prove (7) using (2) and B axioms for “[IF]”, generating the appropriate proof obligation. We can solve S4 is a similar fashion using an IF statement and a
loop.

S4 ± S6 ; S7	(9)
S6 = Spec(ψ ∧ C2 , ψ ∧ C2 ∧ C3) S7 = Spec(ψ ∧ C2 ∧ C3 , ψ ∧ C1)
S6 ± IF ¬C3 THEN Return(bo) END	(10)

S7 ± WHILE ¬C4
DO S8
INVARIANT ψ ∧ C2 ∧ C3
VARIANT size(reservation(bo)) END
S =Δ ANY mej WHERE mej ∈ ran(reservation(bo)) THEN Cancel(mej, bo) END
(11)

We can again immediately prove (9) using (4). We can prove (10) using (2) and the B axiom for “[IF]” to generate a proof obligation.
The WHILE statement of (11) is not a syntactically accepted WHILE statement in the B notation, because its loop body does not use implementation substitutions, but the semantics and rules of the WHILE statement are valid for any substitution, so we can use them to generate proof obligations. We can prove (11) using law 5.5 of [14], provided that we discharge the following proof obligations.
ψ ∧ C2 ∧ C3 ∧ ¬C4 ⇒ [S8]ψ	(* loop body preserves the invariant *)
ψ ∧ C2 ∧ C3 ∧ ¬C4 ⇒ [n := V ][S8](V < n)	(* loop body decreases
Δ
the variant V = size(reservation(bo)) *)
ψ ∧ C2 ∧ C3 ∧ ¬C4 ⇒ V ∈ N	(* the variant is a natural number *)
Note that there is no proof obligation for the initialisation of the loop, since the loop refines S7, whose precondition is the loop invariant.
We have added as assertions the proof obligations that we manually generated from (5), (7), (10), and (11). They are provided in the Library specification of Appendix A in the ASSERTIONS clause. These assertions generate 14 PO; 10 are automatically proved and 4 are easily proved with the interactive prover.
Figure 1 provides the program obtained by piecing together the leafs of this refinement tree. By transitivity of refinement, this program refines Spec(ψ , φ), itself representing the CTL formula AG (ψ ⇒ EF φ). This program executes operation calls, thus it provides an execution path from ψ to φ. Other solutions could explore more probable scenarios. For instance, the user could make a reservation when the book is borrowed; a loop over operations Take and Return or Cancel would empty the list of reservations and allow the member to ultimately borrow the book. These alternative solutions should also be devisable by stepwise refinement.
Related Work
There were other attempts at implementing Morgan’s refinement calculus. The Re- finement Calculator [6] uses HOL to formalize the refinement calculus and conduct proofs; PRT [7] uses Ergo. By reusing a B tool, we avoid to formalise the theory of refinement; we instead reuse the theory of B.

IF ¬C2 THEN
ANY boj WHERE boj ∈ loan—1[{me}] THEN Return(boj) END END ;
IF ¬C3 THEN Return(bo) END ; WHILE ¬C4 DO
ANY mej WHERE mej ∈ ran(reservation(bo))
THEN Cancel(mej, bo) END INVARIANT ψ ∧ C2 ∧ C3
VARIANT size(reservation(bo)) END ;
Lend(me, bo)
Fig. 1. The program which refines the reachability property “a member can always borrow a book”

In a companion paper [12], we outline an alternative approach to prove reacha- bility properties. We propose an algorithm that, given a path expression, generates proof obligations for AG (ψ ⇒ EF φ). A path expression is an angelic choice be- tween basic paths. A basic path starts with a precondition and includes operation calls or loops on operation calls. The generated proof obligations are slightly more complex than those obtained by the approach proposed here, but the specifier does not have to go through a stepwise refinement process. On the other hand, step- wise refinement provides greater freedom in constructing a program showing the
existence of a path.
Brown and M´ery [5] have shown how to encode UNITY’s ensures and leadsto modalities in Atelier B using the wp-calculus. Abrial and Mussat [1] introduced the leadsto modality of UNITY for an ancestor of Event B. UNITY’s leadsto, denoted by ψ ~ φ, is defined in LTL as (ψ ⇒ ⬦φ). This modality is proved by showing that a set of events decrease a variant V , pretty much like the while loop rule 5.5 of [14] which we have used. In [1], events have a guard, which is refined by strengthening it, thus potentially eliminating some execution paths. To ensure that execution
paths are preserved by guard refinement, one must also prove that the disjunction of the guards is not strengthened. Because we use classical B with preconditions for operations, substitution refinement directly preserves the existence of a path from ψ to φ, so we do not have this additional proof obligation. This also means that any implementation of a B abstract machine will also satisfy our reachability properties.
The work of [1] is extended in [4] by adding UNITY’s ensures modality as well as weak fairness and minimal progress. We do not take into account fairness in our work, because it is not relevant in information systems (IS), since an IS user is never forced to invoke an action. However, we must take into account progress in the context of while loops. Additional proof rules for ensures and leadsto are proposed in [20].
The work of Pnueli et al [11,19] is probably the closest to ours. It includes a number of rules to prove CTL∗ properties, also taking into account fairness and justice. Their approach is to reduce CTL∗ formula into basic formula without temporal connectors which can then be proved using elementary rules. We plan to investigate how to adapt these rules to a refinement context, in order to deal

with more complex patterns of CTL formula. Rule e-until of [19] is the main one involved for a proof of AG (ψ ⇒ EF φ). It requires to find an invariant ϕ and a variant V . We provide it below, instantiating it for EF .
ψ → ϕ
ϕ → φ ∨∃ wj · ρ(w, wj) ∧ ϕj ∧ V j < V 

ψ → EF φ
e-until

Symbol ρ denotes the transition relation of the system. The notation ψ1 → ψ2 denotes AG ψ1 ⇒ ψ2, which means that ψ1 ⇒ ψ2 holds in all reachable states. To prove it, it is sufficient to prove ψ1 ⇒ ψ2 for any state (not only states reachable from the initial state). In a B context, one can use machine invariants to prove this. Essentially, rule e-until is similar to a WHILE proof rule. It is not so easy to use in practice. Our approach allows one to restrict this invariant and variant identification to the iterative part of the program p that we have to construct. The rest is done with other B operators, where termination is implicit. Moreover, e-until uses an existential quantification, which is an angelic sequential composition, which is not monotonic with respect to refinement, because the transition relation is coded like a precondition. During refinement, if the path chosen does not match the value
selected by this existential quantification, then reachability is lost during sequential composition of actions. Thus, properties proved using e-until are not preserved by refinement; in our approach, properties are indeed preserved by refinement. Finally, using refinement allows one to decompose a proof into several small proof obligations, instead of one monolithic proof as required by e-until.
Discussion and Conclusion
We have shown how to prove a reachability property using substitution refinement. We construct by stepwise refinement, reusing Morgan’s specification statement and laws, a program whose elementary statements are operations calls. Thus, the ex- ecution of this program provides a path to prove the reachability property. Such a program is not written in B0; we take the liberty of freely combining all substi- tutions offered by the B notation, since our purpose is not to built an executable program. Our only constraint is that elementary substitutions are operation calls. We could have used machine refinement, instead of substitution refinement, to conduct this reachability proof. The idea is to write an abstract machine that in- cludes the library specification, and that contains an operation specifying the reach- ability property, ie, an operation that describes the same behavior as Spec(ψ , φ) using (1). One then implements this machine into an executable program similar to the one of Figure 1, except that it must satisfy the syntactic restrictions of the B notation for implementations and use only concrete expressions and substitutions. Getter operations have to be added to code conditions of IF and WHILE, since these conditions cannot use the variables of the imported Library machine. Sim- ilarly, ANY substitutions have to be encapsulated as B operations, since ANY is not allowed in implementations. A machine refinement approach has the advantage of letting Atelier B generate the proof obligations. On the other hand, it generates

significantly more POs: for our case study, it generates 28 POs, with 14 remaining to prove interactively. These turned out to be hard to prove. We added extra vari- ables to help in the proof of the WHILE loop, which brought the number of POs to 88, out of which 30 had to be proved interactively. This is significantly higher than our approach based on assertions and substitution refinement, which gener- ates 14 POs, of which only 4 had to be proved interactively. Stepwise substitution refinement allows the specifier to work directly with abstract variables and manage the size of proof obligations by properly decomposing the proof into several small steps. Moreover, by applying refinement laws, we avoid some POs that the machine refinement approach has to generate. This is somehow similar to the BART tool [9], which proposes automatic refinement laws.
The automation of our approach could be quite simple. The specifier would provide the refinement steps under the form of a list of refinement inequations and definitions, as illustrated in this paper, and provide a reference to a database of refinement laws (eg, Morgan’s laws in [14]) to justify each refinement step. The tool could syntactically check the call to refinement laws, generate the proof obligations and insert them as assertions in the B abstract specification. These assertions could then be proved using a tool like Atelier B.

References
Abrial, J.-R., L. Mussat, Introducing Dynamic Constraints in B. In B’98: Recent Advances in the Development and Use of the B Method, LNCS 1393, pp 83–128, Springer-Verlag (1998).
Back, R.J.R.: On the Correctness of Refinement in Program Development. Ph. D. Thesis Report A- 1978-4, Dept. of Computer Science, University of Helsinki, 1978.
Back, R.J.R.: Correctness Preserving Program Refinements: Proof Theory and Applications. Mathematical Center Tracts 131, Mathematical Centre, Amsterdam, 1980.
Barradas, H.R., D. Bert, “Specification and Proof of Liveness Properties under Fairness Assumptions in B Event Systems”, in Integrated Formal Methids 2002, LNCS 2335, pp 360–379 (2002).
Brown, N., M´ery, D.:“A Proof Environment for Concurrent Programs”, in FME ’93: Industrial-Strength Formal Methods, LNCS 670, Springer-Verlag, pp 196–215 (1993).
Butler, M., J. Grundy , T. L˚angbacka, R. Rukˇse˙nas, J. von Wright, “The Refinement Calculator: Proof Support for Program Refinement”, in Formal Methods Pacific ’97, pp 40–61, Springer-Verlag (1997).
Carrington, D., I. Hayes, R. Nickson, G. Watson, J. Welsh, “A Tool for Developing Correct Programs By Refinement”, Technical report 95-49, The University of Queensland (1996).
Clarke, E.M., E.A. Emerson, “Design and Synthesis of Synchronization Skeletons using Branching Time Temporal Logic”, in Logic of Programs Workshop. LNCS 131, pp 52–71, Springer-Verlag (1982).
Clearsy: Bart : B Automatic Refinement Tool, Clearsy System Engineering, Aix-en-provence, France,
http://www.tools.clearsy.com/index.php5?title=BART_Project.
Hehner, E.C.R.: A Practical Theory of Programming. Springer Verlag, 1993.
Kesten, Y., Amir Pnueli, “A Compositional Approach to CTL∗ Verification”, Theoretical Computer Science, 331(2-3), pp 397–428, February 2005.
Mammar, A., Frappier, M., Diagne, F.: A Proof-Based Approach to Verifying Reachability Properties,
26th ACM Symposium on Applied Computing,Tunghai University, TaiChung, Taiwan, March 21-24, 2011, to appear.
Morgan, C.: The Specification Statement. ACM Transactions on Programming Languages and Systems
11(4) (1988) 517–561.
Morgan, C.C., Programming from Specifications, Second edition, Prentice Hall, 1998.
http://web2.comlab.ox.ac.uk/oucl/publications/books/PfS/PfS.ps.gz.
Morris, J.M.: A Theoretical Basis for Stepwise Refinmement and the Programming Calculus. Science of Computer Programming 9 (1987) 287–306.
Morris, J.M.: Laws of Data Refinement. Acta Informatica 26 (1989) 287–308.

Nelson, G.: A Generalization of Disjktra’s Calculus. ACM Transactions on Programming Languages and Systems 11(4) (1989) 517–560.
Pnueli, A.: “The Temporal Logic of Programs”, in 18th IEEE Annual Symposium on Foundations of Computer Science, pp 46–57, IEEE Computer Society (1977).
Pnueli, A., Y. Kesten, A Deductive Proof System for CTL∗, in 13th International Conference on Concurrency Theory 2002, LNCS 2421, pp 24–40, Springer-Verlag (2002).
J. Misra, A Discipline of Multiprogramming, Springer-Verlag, 2001.
Appendix A	The B Specification of the Library System
MACHINE Library
SETS MEMBERID; BOOKID
ABSTRACTCONSTANTS MaxNbLoans
PROPERTIES MaxNbLoans ∈ N 
DEFINITIONS
Index(bb, mm) == ((reservation(bb)) −1 (mm));
phi == ((bo '→ me) ∈ loan);
psi == (me ∈ member ∧ bo ∈ book); C1 == (C2 ∧ C3 ∧ C4);
C2 == (card(loan Q { me }) < MaxNbLoans); C3 == (bo /∈ dom(loan));
C4 == (reservation(bo) = [])
ABSTRACTVARIABLES
loan , member , book , reservation


INVARIANT
member ⊆ MEMBERID ∧ book ⊆ BOOKID ∧ loan ∈ book →' reservation ∈ book → iseq(member) ∧

member ∧

∀ mm . ( mm ∈ member ⇒ card ( loan Q { mm } ) ≤ MaxNbLoans )
ASSERTIONS
/* PO (5) : Lend refines S2 */
∀ (bo,me) . (psi ∧ C1 ⇒ (
me ∈ member ∧ bo ∈ BOOKID ∧ bo ∈ book ∧ bo /∈ dom(loan) ∧
reservation(bo) = [] ∧ card(loan Q { me }) < MaxNbLoans ∧
bo '→ me ∈ loan <+ { bo '→ me } ));
/* PO (7) Refinement of S3 */
∀ (bo,me) .( psi ⇒ (
¬ (C2) ⇒ (
∀ bop . (bop ∈ loan −1 [{me}] ⇒ (
bop ∈ BOOKID ∧ bop ∈ book ∧ bop ∈ dom ( loan ) ∧ psi ∧
(card(({ bop } —Q loan) Q {me}) < MaxNbLoans))))
∧
(C2 ⇒ (psi ∧ C2))));
/* PO (10) Refinement of S6 */
∀ (bo,me) . ( (psi ∧ C2) ⇒ (
¬ (C3) ⇒ (
bo ∈ BOOKID ∧ bo ∈ book ∧ bo ∈ dom ( loan ) ∧ psi ∧
(card(({ bo } —Q loan) Q {me}) < MaxNbLoans) ∧
(bo /∈ dom({ bo } —Q loan)))
∧
(C3 ⇒ (psi ∧ C2 ∧ C3))));
/* PO (11) Refinement of S7 */
∀ (bo,me) . (

(psi ∧ C2 ∧ C3 ∧ ¬ (C4)) ⇒
∀ mep . (mep ∈ ran(reservation(bo)) ⇒ (
mep ∈ MEMBERID ∧ mep ∈ member ∧ bo ∈ BOOKID ∧
bo ∈ book ∧ bo ∈ dom(reservation) ∧
mep ∈ ran(reservation(bo)) ∧
size((reservation(bo) ↑ (Index(bo, mep) - 1)) -
(reservation (bo) ↓ Index(bo, mep)))
< size(reservation(bo))))) INITIALISATION
loan := ∅ || book := ∅ || member := ∅ || reservation := ∅
OPERATIONS
Lend ( member , book ) = 
	
PRE
member ∈ MEMBERID ∧ member ∈ member ∧
book ∈ BOOKID ∧ book ∈ book ∧
book /∈ dom ( loan ) ∧ reservation(book )=[] ∧
card ( loan Q { member } ) < MaxNbLoans
THEN
loan ( book ) := member
END ;
Reserve ( member , book ) = 
PRE
member ∈ MEMBERID ∧ member ∈ member ∧
	
book ∈ BOOKID ∧ book ∈ book ∧ member /∈ ran(reservation(book )) ∧ book '→ member /∈ loan ∧
( book ∈ dom ( loan ) ∨ reservation(book ) /= [] ) 
THEN
reservation := reservation <+
{ book '→ ((reservation(book ) → member )) }
END ;
Return ( book ) = 
PRE
book ∈ BOOKID ∧ book ∈ book ∧
book ∈ dom ( loan )
THEN
loan := { book } Q— loan
END ;
Take ( member , book ) = 
PRE
member ∈ MEMBERID ∧ member ∈ member ∧
book ∈ BOOKID ∧ book ∈ book ∧
book /∈ dom ( loan ) ∧
card ( loan Q { member } ) < MaxNbLoans ∧ size(reservation(book )) /= 0 ∧ first(reservation(book )) = member
THEN
loan ( book ) := member ||
reservation := reservation <+ {book '→ tail(reservation(book ))}
END ;
Cancel ( member , book ) = 
	
PRE
member ∈ MEMBERID ∧ member ∈ member ∧
book ∈ BOOKID ∧ book ∈ book ∧
member ∈ ran(reservation(book ))
THEN
reservation(book ) :=
(reservation(book ) ↑ (Index(book , member ) - 1))
-
(reservation (book ) ↓ Index(book , member ))
END
END
