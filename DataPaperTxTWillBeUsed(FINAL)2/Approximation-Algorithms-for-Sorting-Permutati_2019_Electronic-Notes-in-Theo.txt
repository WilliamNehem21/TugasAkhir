Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 346 (2019) 29–40
www.elsevier.com/locate/entcs

Approximation Algorithms for Sorting Permutations by Length-Weighted Short Rearrangements
Alexsandro Oliveira Alexandrinoa,1,2 Guilherme Henrique Santos Mirandaa,1,3 Carla Negri Lintzmayerb,1,4 Zanoni Diasa,1,5
a Institute of Computing, University of Campinas (Unicamp), Brazil
b Center for Mathematics, Computation and Cognition, Federal University of ABC (UFABC), Brazil

Abstract
Genome rearrangements are events that affect large portions of a genome. When using the rearrangement distance to compare two genomes, one wants to find a minimum cost sequence of rearrangements that transforms one into another. Since we represent genomes as permutations, we can reduce this problem to the problem of sorting a permutation with a minimum cost sequence of rearrangements. In the traditional approach, we consider that all rearrangements are equally likely to occur and we set a unitary cost for all rearrangements. However, there are two variations of the problem motivated by the observation that rearrangements involving large segments of a genome rarely occur. The first variation adds a restriction to the rearrangement’s length. The second variation uses a cost function based on the rearrangement’s length. In this work, we present approximation algorithms for five problems combining both variations, that is, problems with a length-limit restriction and a cost function based on the rearrangement’s length.
Keywords: Genome Rearrangements, Approximation Algorithms, Sorting Permutations.

Introduction
Understanding the evolutionary process and finding the evolutionary distance be- tween two distinct organisms are challenging tasks in Computational Biology. A

1 This work was supported by the National Counsel of Technological and Scientific Development, CNPq (grants 400487/2016-0 and 425340/2016-3), S˜ao Paulo Research Foundation, FAPESP (grants 2013/08293- 7, 2015/11937-9, 2017/12646-3, 2017/16246-0, and 2017/16871-1), the Brazilian Federal Agency for the Support and Evaluation of Graduate Education, CAPES, and the CAPES/COFECUB program (grant 831/15).
2 Email: alexsandro@ic.unicamp.br
3 Email: guilherme.miranda@students.ic.unicamp.br
4 Email: carla.negri@ufabc.edu.br
5 Email: zanoni@ic.unicamp.br

https://doi.org/10.1016/j.entcs.2019.08.004
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

well-accepted way to estimate such distance is to use the rearrangement distance between the genomes of the two organisms, which is given by the smallest number of rearrangements required to transform one genome into another.
Genome rearrangements are events that modify segments of genomes. A rear- rangement model M is the set of valid rearrangements that can be used to estimate the evolutionary distance. Two well known types of genome rearrangements are reversals, which revert and flip the orientation of elements in a genome, and trans- positions, which exchange the positions of two adjacent segments in a genome.
We represent a genome as a permutation of integers, where each element cor- responds to a genomic fragment shared by the genomes we are comparing. This representation assumes that there are no duplicate genes. If the orientation of the genes is known, we use a signed permutation, where each element has a sign to represent its orientation. If the orientation is unknown, the signs are omitted and we use an unsigned permutation.
Due to algebraic properties, it is possible to represent one of the genomes as the identity permutation and, in this way, we can reduce the problem of estimat- ing the rearrangement distance to the problem of finding the minimum number of rearrangements to sort a permutation.
The problem of Sorting Unsigned Permutations by Reversals is NP-Hard [3]. The best-known result is an algorithm with approximation factor of 1.375, given by Berman et al. [1]. On the other hand, as shown by Hannenhalli and Pevzner [6], the problem of Sorting Signed Permutations by Reversals is polynomial. The problem of Sorting (Unsigned) Permutations by Transpositions is NP-Hard [2] and the best- known result is an algorithm with approximation factor of 1.375, given by Elias and Hartman [4].
When the rearrangement model contains reversals and transpositions, we have the problems of Sorting Signed and Unsigned Permutations by Reversals and Trans- positions. The complexity of both problems are unknown. For unsigned permuta- tions, the best-known result is a 2k-approximation algorithm [14], where k is the approximation factor for cycle decomposition of breakpoints graphs. For signed permutations, Walter et al. [16] presented a 2-approximation algorithm.
Many variants of sorting permutations problems were inspired by different bio- logical relevance [5, 7–9, 12, 13, 15]. Some of these variants [5, 7–9, 15] add an extra restriction that limits the length of the rearrangements. This restriction is moti- vated by the observation that rearrangements involving large segments of a genome rarely occur [11]. For length-limits equal to 2 and 3, we call these rearrangements super short and short, respectively. The problems of Sorting by Super Short Op- erations are polynomial [5, 8]. The best-known algorithms for Sorting Signed and Unsigned Permutations by Short Reversals have approximation factors of 5 [5] and 2 [7], respectively. The best-known algorithm for the problem of Sorting (Unsigned) Permutations by Short Transpositions has approximation factor of 5/4 [9]. For the same problem, there exists a (1 + n/x)-approximation [10], where n is the number of elements and x is the number of inversions in the permutation. This algorithm gives a lower approximation factor for permutations with many inversions. For the prob-

lems of Sorting Signed and Unsigned Permutations by Short Reversals and Short Transpositions, the best-known algorithms have approximation factors of 3 [5] and 2 [15], respectively.
The same motivation for the length-limit restriction inspired some authors [12, 13] to consider length-weighted rearrangements, that is, a rearrangement has a cost based on its length. In this approach, the goal of the problem is to find a minimum-cost rearrangement sequence that sorts a permutation. We present ap- proximation algorithms for five such problems: Sorting by Length-Weighted Short
Reversals (SbR), Sorting by Length-Weighted Short Signed Reversals (SbR¯ ), Sort-
ing by Length-Weighted Short Transpositions (SbT), Sorting by Length-Weighted Short Reversals and Short Transpositions (SbRT), and Sorting by Length-Weighted Short Signed Reversals and Short Transpositions (SbR¯ T). To the best of our knowl- edge, there are no results in the literature considering length-weighted short rear-
rangements.
This work is organized as follows. Section 2 presents all concepts and notations related to the problems. Sections 3, 4, and 5 describe the approximation algorithms we developed. Section 6 concludes our work.

Definitions
A signed permutation of size n is represented as π = (π1 π2 ... πn), such that πi ∈ {−n,..., −2, −1, 1, 2,..., n} and |πi| /= |πj| if and only if i /= j, for all i and j. An unsigned permutation of size n is represented similarly, but πi ∈ {1, 2,..., n} and πi /= πj if and only if i /= j, for all i and j. The identity permutation, ι = (1 2 ... n), is the goal of the sorting problems we will study. For signed permutations, all elements of ι have positive sign.
A signed reversal ρ¯(i, j), with 1 ≤ i ≤ j ≤ n, reverts the segment πi, πi+1,..., πj and flips the sign of each affected element. An unsigned reversal ρ(i, j), with 1 ≤ i < j ≤ n, only reverts the segment πi, πi+1,..., πj. So, when π is a signed permutation, we have that (π1 ... πi ... πj ... πn) · ρ¯(i, j)= (π1 ... −πj ... −πi ... πn) and, when π is an unsigned permutation, we have that (π1 ... πi ... πj ... πn) · ρ(i, j)
= (π1 ... πj ... πi ... πn). A signed (or unsigned) reversal ρ¯(i, j) (or ρ(i, j)) is called a signed (or unsigned) k-reversal, where k = |ρ¯| = j − i +1 (or k = |ρ| = j − i + 1) is the rearrangement’s length.
A transposition τ (i, j, k), with 1 ≤ i < j  < k  ≤ n + 1, ex- changes the two adjacent segments πi, πi+1, . .., πj−1 and πj, πj+1,..., πk−1 without changing signs of their elements.   Therefore,  we have that  (π1  ...  πi−1  πi ... πj−1  πj ... πk−1  πk  ...  πn) · τ (i, j, k)  =
(π1 ... πi−1 πj .. . πk−1 πi ... πj−1 πk ... πn).	A transposition τ (i, j, k) has length |τ | = k − i.
For transpositions and reversals, we say that a rearrangement is super short if its length is less than or equal to 2 and short if its length is less than or equal to 3. Furthermore, considering the length-weighted approach, a rearrangement β has cost f (β)= |β|α, where α ≥ 0. Given a sequence of rearrangements S = β1, β2,..., βm,

we have that f (S)= Σm  f (βi). Note that the unweighted approach is equivalent
to set α = 0. In this work, we will consider that α = 1, that is, f (β)= |β|.
Given a rearrangement model M with only short rearrangements, the cost func-

tion f , and a permutation π, the short rearrangement distance cf
(π) is equal to

Σm	M
and Σm  f (βi) is minimum.
We use sr, sr¯, st, srt, sr¯t to denote unsigned short reversals, signed short re- versals, short transpositions, unsigned short reversals and short transpositions, and signed short reversals and short transpositions, respectively. For instance, the signed short reversals distance of permutation π is denoted by cf (π).
Inversions and Inversion Graph
A pair of elements (πi, πj) of π is called an inversion if i < j and |πi| > |πj|. We use Inv(π) to denote the number of inversions in a permutation π. For any permutation π, Inv(π) = 0 if |π1| < |π2| < ... < |πn|. Note that considering unsigned permutations, only the identity permutation has Inv(π)= 0.
Lemma 2.1 For any permutation π, if Inv(π) > 0, then there exists an inversion
(πi, πi+1).
Proof. Let π1,..., πi be a maximal subsequence such that |πj| < |πj+1| for all 1 ≤ j < i. Since Inv(π) > 0, we have that i < n. So, |πi| > |πi+1| and (πi, πi+1) is an inversion.	2
Given a permutation π and a rearrangement β, let ΔInv(π, β)= Inv(π) − Inv(π · β), that is, ΔInv(π, β) denotes the change caused by β in the number of inversions in π. From Lemma 2.1, we can conclude that for any permutation π such that Inv(π) > 0, there exists a super short rearrangement β with ΔInv(π, β) = 1. Lemma
provides bounds on the value ΔInv(π, β), where |β|≤ 3.
Lemma 2.2 (Galv˜ao et al. [5]) Given a permutation π and a short rearrangement
β, we have that
−1 ≤ ΔInv(π, β) ≤ 1 if β has length 2,
−2 ≤ ΔInv(π, β) ≤ 2 if β is a transposition of length 3, and
−3 ≤ ΔInv(π, β) ≤ 3 if β is a signed or unsigned reversal of length 3.
The permutation graph or inversion graph of a permutation π is the undirected graph G(π) = (V, E), where V = {π1, π2,..., πn} and E = {(πi, πj) : the pair (πi, πj) is an inversion in π}. Figure 1 shows an example of a permutation graph.
Given a signed permutation π, a connected component C of G(π) is odd if it contains an odd number of negative elements (vertices) and it is even otherwise. We use c(π) and codd(π) to denote the number of connected components and the number of odd connected components of G(π), respectively. An edge e of G(π) whose deletion increases the number of connected components of G(π) is called a cut-edge. We use γ(π) to denote the number of non-isolated vertices in G(π), that is, the number of elements in π belonging to at least one inversion.




Fig. 1. Permutation graph G(π) of the signed permutation π = (+3 −4 +6 −1 +5 −2). In this example,
c(π)= codd(π) = 1 and γ(π)= 6.
2.2	Entropy
Given a permutation π, the entropy of πi is defined as ent(πi) = ||πi| − i|, for 1 ≤ i ≤ n. In other words, the entropy of an element πi is the distance between πi
and its position in the identity permutation. We define the sets Eeven− = {π : π < 0
i
and ent(π ) is even} and Eodd+ = {π : π > 0 and ent(π ) is odd}. These sets will
i	π	i	i	i
be used in lower bounds for SbR¯ and SbR¯ T.
As an example, for π = (+5 −4 +3 −1 +2), we have ent(+5) = 4, ent(−4) = 2,

ent(+3) = 0, ent(−1) = 3, and ent(+2) = 3, and the sets Eeven−
= {−4} and

Eodd+ = {+2}.

Approximation Algorithms for Unsigned Permuta- tions
In this section, we present a 4 -approximation algorithm for SbT and a 2- approximation algorithm for SbR and SbRT. They are greedy algorithms whose choice is to prioritize rearrangements that reduce the most number of inversions with the lowest cost. These algorithms are named 4 -T, 2-R, and 2-RT for the
problems SbT, SbR, and SbRT, respectively.
To prove the approximation factors, Lemma 3.1 presents bounds on the ratio
ΔInv(π,β) considering that β is a short rearrangement. With these results, Lemmas
3.2 and 3.3 present lower bounds for the problems SbT, SbR, and SbRT relating the sorting distance to the number of inversions in a permutation.
Lemma 3.1 Given a permutation π, any short reversal ρ has ratio ΔInv(π,ρ) ≤ 1
and any short transposition τ has ratio ΔInv(π,τ) ≤ 2 .
|τ|	3
Lemma 3.2 For any permutation π, cf (π) ≥ 3 Inv(π).
st	2
Proof. By Lemma 3.1, for any transposition τ , the ratio ΔInv(π,τ) is at most 2 ,
which means that the minimum cost to decrease Inv(π) by1 is 3 . Since the identity permutation has Inv(ι) = 0, any sorting sequence needs to decrease Inv(π) inversions in π to sort the permutation, resulting in the lower bound 3 Inv(π).	2

Lemma 3.3 For any permutation π, cf (π) ≥ cf
(π) ≥ Inv(π).

sr	srt
Proof. Since any sorting sequence for the problem SbR is a valid sorting sequence

for SbRT, we have that cf (π) ≥ cf
(π). The proof of cf
(π) ≥ Inv(π) is analogous

sr	srt
srt

to the proof of Lemma 3.2. Note that for any rearrangement β, the ratio ΔInv(π,β)
is at most 1 (Lemma 3.1).	2
The following lemma describes upper bounds for the distance given by the greedy algorithms.
Lemma 3.4 For any permutation π, cf (π) ≤ 2 Inv(π) and cf (π) ≤ cf (π) ≤

2 Inv(π).
st	srt	sr

Proof. We need to prove that it is always possible to decrease the number of inver- sions by 1 with a cost less than or equal to 2, considering the three rearrangement models. If Inv(π)= 0, then π is already sorted. If Inv(π) > 0, then there exists an inversion (πi, πi+1) in π (Lemma 2.1). So, the transposition τ (i, i+1, i+2) and the re- versal ρ(i, i+1) both have cost 2 and ΔInv(π, τ (i, i+1, i+2)) = ΔInv(π, ρ(i, i+1)) = 1, since the inversion (πi, πi+1) is removed.	2
Theorem 3.5 SbR and SbRT are 2-approximable and SbT is 4 -approximable.
Observe that the distance is O(n2) because any permutation can have at most n inversions. Besides that, the variation in the number of inversions caused by a short rearrangement can be calculated in constant time, since at most three elements are affected. As there are O(n) possible short rearrangements, the algorithms spend O(n) time to choose the best rearrangement to apply at each step. Thus, all three algorithms have time complexity O(n3).
We note that the exact algorithm for the problem of Sorting by Super Short Rear- rangements has time complexity of O(n2) [8] and it is also a valid algorithm for SbR, SbT, and SbRT. Given a permutation π, at each step, this algorithm removes an inversion with a rearrangement of length 2. Therefore, a sorting sequence retrieved by this algorithm has a cost of exactly 2 Inv(π), which means that this algorithm is a 2-approximation for SbR and SbRT (Lemma 3.3) and a 4 -approximation for SbT (Lemma 3.2). However, the greedy algorithms presented above retrieve sorting sequences with a cost of at most 2 Inv(π) and, so, they have better practical results. Furthermore, a sorting sequence S retrieved by one of the greedy algorithms has a cost of exactly 2 Inv(π) if, and only if, it does not contain any rearrangement of length 3.
Improved Approximation for Transpositions
This section presents an improved approximation algorithm for permutations with many inversions. The algorithm is defined in Algorithm 1.
For each element πk = i, with 1 ≤ i ≤ n, Algorithm 1 applies a sequence of short transpositions to move πk to its correct position. In this way, the permutation π is sorted at the end of this algorithm. This algorithm has time complexity of O(n2), since it has n iterations and, in the worst case of each iteration, O(n) short transpositions are applied in π. Lemma 4.1 gives an upper bound on the cost of a sorting sequence used by Algorithm 1.

Algorithm 1 Approximation Algorithm for SbT
function sort (π)
c → 0
for i from 1 to n do if πi /= i then
let k be the position of element i
if k − i is even then
π → π · τ (k − 2, k,k + 1) · τ (k − 4,k − 2,k − 1) · ... · τ (i, i + 2,i + 3)
otherwise
π → π · τ (k − 2, k,k + 1) · τ (k − 4,k − 2,k − 1) · ... · τ (i, i + 1,i + 2)
c → c + 3[ k—i ♩ +2 ((k − i) mod 2)
return c

Lemma 4.1 For any permutation π, Algorithm 1 ﬁnds a sorting sequence S with
f (S) ≤ 3 Inv(π)+ γ(π) .
2	2
Proof. We analyze the average cost to remove an inversion in each iteration of the algorithm.
Consider the i-th iteration. Let π be the permutation at the beginning of this iteration and πj be the permutation at the end of this iteration. Furthermore, let πk = i. In this iteration, we know that π = (1 2 ... (i − 1) πi ... πk ... πn) and that there exists an inversion (πj, πk), for any i ≤ j < k, since j < k and πk < πj. After moving πk to its correct position with the sequence Sj, the permutation πj = (1 2 ... (i − 1) i πi ... πk—1 πk+1 ... πn).
If k − i is even, then Sj contains k—i transpositions of length 3 and f (Sj) = 
3 (k − i). Otherwise, Sj has [ k—i ♩ transpositions of length 3 and one transposition
2	2
of length 2, which means that f (Sj) = 3[ k—i ♩ +2 = 3 (k − i)+ 1 , because k − i
2	2	2
is odd. Since Sj removes k − i inversions and does not add any inversions in the
permutation, we conclude that Sj has an average cost of 3 to remove one inversion and, if k − i is odd, it has an additional cost of 1 . Therefore, f (S)= 3 Inv(π)+ 1 m,
2	2	2
where m is the number of iterations where a transposition of length 2 is used.
Since any transposition of S removes at least one inversion and no inversions are added, any isolated element of G(π) is not affected by S. Thus, the permutation π is not changed in n − γ(π) iterations of the algorithm. Consequently, m ≤ γ(π) and f (S) ≤ 3 Inv(π)+ 1 γ(π).	2
2	2
Theorem 4.2 Algorithm 1 is a (1 + γ(π)/(3 Inv(π)))-approximation for SbT.
If Inv(π) ≥ cn2, where c is a constant, then the approximation factor of Algo- rithm 1 is
γ(π)	n	1
1+ 3 Inv(π) ≤ 1+ 3 cn2 =1 + 3 cn.
As an example, if n = 200 and Inv(π) = 10000, then the approximation factor is approximately 1.007.
Lemma 4.3 The approximation factor of Algorithm 1 is at most 5 .

Proof. The graph G(π) has at least γ(π) edges. Thus, the approximation factor is


γ(π)
1+ 
3 Inv(π)
≤ 1+ 
γ(π)


3 γ(π)/2
2	5
=1 +  = .
3	3
2

Approximation Algorithms for Signed Permutations
In this section, we present greedy algorithms for SbR¯ and SbR¯ T with approximation
factor of 3, which are called 3-R¯ and 3-R¯ T, respectively. Furthermore, we present
a 7 -approximation algorithm for SbR¯ T called 7 -R¯ T.
3	3
The 3-Approximation Algorithms for SbR¯ and SbR¯ T
To show how these greedy algorithms work, we define a score function φ based on the inversion graph of π and on the sets Eeven− and Eodd+ .
π	π
Given a permutation π and a rearrangement sequence S, let πj be the resulting permutation after applying S to π. The score function is defined as
  Σ d(v)+ |Eeven− | + |Eodd+ |  −  Σ d(v)+ |Eeven− | + |Eodd+ | 


φ(π, S)= 
π
v∈G(π)
π

|β|
β∈S
π′	π′
v∈G(π′)

(2 Inv(π)+ |Eeven− | + |Eodd+ |) − (2 Inv(πj)+ |Eeven− | + |Eodd+ |)
π	π	π′	π′
=	|β|	,
β∈S
since v∈G(π) d(v)= 2 Inv(π) for any permutation π.
The identity permutation is the only permutation with Inv(π) = |Eeven− | =
|Eodd+ | = 0. An optimal sorting sequence is the one with highest score function. So, the greedy choice of 3-R¯ and 3-R¯ T is to always apply the short rearrangement with highest score function until the permutation is sorted. The following lemmas are used to prove the approximation factor of both algorithms.
Lemma 5.1 (Galv˜ao et al. [5]) For any signed permutation π and signed 2-reversal
ρ¯, we have that |Eeven− | + |Eodd+ | = |Eeven− | + |Eodd+ |, where πj = π · ρ¯.
π	π	π′	π′
Lemma 5.2 For any signed permutation π and short signed reversal ρ¯, we have that φ(π, ρ¯) ≤ 3.
Proof. Let πj = π · ρ¯ and ρ¯ = ρ¯(i, j). Recall that ΔInv(π, ρ¯) = Inv(π) − Inv(πj). We can divide the proof into the following cases:
ρ¯ has length 1. As a 1-reversal only changes the sign of element πi, the number of inversions in πj is the same as in π. Since the parity of ent(πi) does not

change, we have (|Eeven− | + |Eodd+ |) − (|Eeven− | + |Eodd+ |) ≤ 1. Therefore,

π	π
φ(π, ρ¯) ≤ 1.
π′	π′

ρ¯ has length 2. A signed 2-reversal can remove at most one inversion and,
consequently, 2(ΔInv(π, ρ¯)) ≤ 2. Moreover, we have that |Eeven− | + |Eodd+ | =
π	π
|Eeven− | + |Eodd+ | (Lemma 5.1). Therefore, φ(π, ρ¯) ≤ 1.
π′	π′
ρ¯ has length 3. A signed 3-reversal can remove at most three inversions and,
consequently, 2(ΔInv(π, ρ¯)) ≤ 6. Moreover, we have that (|Eeven− |+|Eodd+ |)−
π	π
(|Eeven− |+|Eodd+ |) ≤ 3, since only three elements are affected by ρ¯ and Eeven− ∩
π′	π′	π
Eodd+ = ∅. Therefore, φ(π, ρ¯) ≤ 9 = 3.
π	3
2
Lemma 5.3 For any signed permutation π and short transposition τ, we have that
φ(π, τ ) ≤ 7 .
Proof. Analogous to the proof of Lemma 5.2.	2
Lemma 5.4 For any signed permutation π /= ι, there exists a short signed reversal
ρ¯ with φ(π, ρ¯) ≥ 1.
Proof. Let πj = π · ρ¯. If Inv(π) = 0, then ent(πi) = 0 for all elements πi of π
and |Eodd+ | = 0. As π /= ι, there exists an element π < 0 in Eeven− and, after
π	i	π
applying ρ¯(i, i) in π, this element becomes positive in πj. Therefore, we have that
|Eeven− |− |Eeven− | = 1 and φ(π, ρ¯)= 1.
π	π′
If Inv(π) > 0, then there exists an inversion (πi, πi+1) in π (Lemma 2.1). Thus,
the signed 2-reversal ρ¯(i, i+1) removes this inversion, resulting in 2(ΔInv(π, ρ¯)) = 2
and |Eeven− | + |Eodd+ | = |Eeven− | + |Eodd+ | (Lemma 5.1). Therefore, φ(π, ρ¯)= 1.2
π	π	π′	π′

Theorem 5.5 3-R¯
respectively.
and 3-R¯ T are 3-approximation algorithms for SbR¯
and SbR¯ T,

Proof. Since the algorithm 3-R¯ always searches for the short signed reversal with highest score function, at each step the algorithm finds a short signed reversal ρ¯ with φ(π, ρ¯) ≥ 1 (Lemma 5.4). The value of φ(π, S), for any sorting sequence S, is less than or equal to 3 (Lemma 5.2) and the algorithm ensures a score function greater than or equal to 1, which gives us the approximation factor of 3.
The proof for 3-R¯ T is analogous.	2
Algorithms 3-R¯ and 3-R¯ T have time complexity O(n3). This analysis is similar to the one used for algoritms 4 -T, 2-R, and 2-RT. Note that the score function φ can be calculated in constant time for any short rearrangement, since at most three elements are affected.

The 7/3-Approximation Algorithm for SbR¯ T
Given a permutation π and a rearrangement sequence S, let πj be the resulting permutation after applying S to π. We define a new score function ψ as

  Σ d(v)+ codd(π)  −  Σ d(v)+ codd(πj) 

ψ(π, S)= 
v∈G(π)
v∈G(π′)
|β|
β∈S

(2 Inv(π)+ codd(π)) − (2 Inv(πj)+ codd(πj))
=	|β|	.
β∈S
The identity permutation is the only one with Inv(π)+ codd(π) = 0. The greedy choice of the 7 -approximation algorithm is to always apply the short rearrangement with highest score function until the permutation is sorted. The following lemmas present bounds on the values of the score function.
Lemma 5.6 For any signed permutation π and short rearrangement β, we have that ψ(π, β) ≤ 7 .
Proof. Let πj = π · β. We can divide the proof into the following cases:
β is a signed reversal of length 1. A signed 1-reversal affects only one element and does not change the number of inversions in the permutation. Besides that, since only the component containing the affected element may become even, we have that codd(π) − codd(πj) ≤ 1. Therefore, ψ(π, ρ¯) ≤ 1.
β is a rearrangement of length 2. Let πi and πi+1 be the elements affected by
β. We further divide our analysis into the following subcases:
(πi, πi+1) is an inversion. The rearrangement β removes the inversion (πi, πi+1) and, consequently, 2(ΔInv(π, β)) = 2. Besides that, note that πi and πi+1 are in the same component of G(π). So, β affects only one component and codd(π) − codd(πj) ≤ 1.
(πi, πi+1) is not an inversion.  The rearrangement β adds the inversion
(πj, πj	) and, consequently, 2(ΔInv(π, β)) = −2. Furthermore, since πi
i	i+1
and πi+1 are in distinct components of G(π), β affects only two components
and codd(π) − codd(πj) ≤ 2.
In both cases, we have that (2 Inv(π)+ codd(π)) − (2 Inv(πj)+ codd(πj)) ≤ 3 and, consequently, ψ(π, β) ≤ 3 .
β is a rearrangement of length 3. Let πi, πi+1, and πi+2 be the elements affected by β. We further divide our analysis into the following subcases:
πi, πi+1, and πi+2 are in the same component of G(π). We have that 2(ΔInv(π, β)) ≤ 6 (Lemma 2.2) and codd(π) − codd(πj) ≤ 1.
Two elements of {πi, πi+1, πi+2} are in a component C1 and the remaining is in a component C2 of G(π). Since there is only one edge connecting the elements πi, πi+1, and πi+2, we have that 2(ΔInv(π, β)) ≤ 2. Furthermore, β affects only two components of G(π) and codd(π) − codd(πj) ≤ 2.
πi, πi+1, and πi+2 are in distinct components of G(π). In this case, we have that 2(ΔInv(π, β)) ≤ −4 and codd(π) − codd(πj) ≤ 3. Note that a short transposition τ (i, j, i + 3), with i < j < i + 3, adds two inversions and a signed short reversal ρ¯(i, i + 2) adds three inversions in the permutation.

In all cases, we have that (2 Inv(π)+ codd(π)) − (2 Inv(πj)+ codd(πj)) ≤ 7. Therefore, ψ(π, β) ≤ 7 .
2

Lemma 5.7 For any signed permutation π /= ι, there exists a short rearrangement
β with ψ(π, β) ≥ 1.

Proof. Let πj = π · β. If Inv(π) = 0, then there are no edges in G(π) and each component of G(π) is a single vertex. As π /= ι, there exists an odd component C = {πi} and, after applying β = ρ¯(i, i) in π, the component C becomes even. Thus, we have that (2 Inv(π)+ codd(π)) − (2 Inv(πj)+ codd(πj)) = 1 and ψ(π, β) ≥ 1. If Inv(π) > 0, then there exists an edge e = (πi, πi+1) in G(π).  Let C be the component that contains e. Suppose that e is not a cut-edge. A rearrangement β = τ (i, i+1, i+2) removes the inversion (πi, πi+1) and, since e is not a cut-edge, the components of G(πj) are the same components of G(π). Moreover, the parity of the components remains the same, as a transposition does not change signs of elements.
Thus, we have (2 Inv(π)+ codd(π)) − (2 Inv(πj)+ codd(πj)) = 2 and ψ(π, β) ≥ 1.
Now, suppose that e is a cut-edge. Let C1 and C2 be the components of C − e. Since e is a cut-edge, the elements πi and πi+1 are in distinct components of C − e. We further divide this proof into the following cases:
C1 and C2 are both even. After applying β = τ (i, i + 1,i + 2) on π, we have that 2(ΔInv(π, β)) = 2 and codd(π) − codd(πj) = 0. Note that C is also even and the parity of the components C1 and C2 remains the same.
C1 and C2 are both odd. After applying β = ρ¯(i, i + 1) on π, we have that 2(ΔInv(π, β)) = 2 and codd(π) − codd(πj) = 0. Note that C is even and the components C1 and C2 become even after applying the signed 2-reversal in π.
C1 and C2 have distinct parities. After applying β = τ (i, i + 1,i + 2) on π, we have that 2(ΔInv(π, β)) = 2 and codd(π) − codd(πj) = 0. Note that C is odd and the parity of the components C1 and C2 remains the same.
In all cases, we have that (2 Inv(π)+ codd(π)) − (2 Inv(πj)+ codd(πj)) = 2 and
ψ(π, β) ≥ 1.	2
Theorem 5.8 7 -R¯ T is a 7 -approximation algorithm for SbR¯ T.
3	3
Proof. Since the algorithm 7 -R¯ T always searches for the short rearrangement with highest score function ψ, at each step the algorithm finds a short rearrangement β with ψ(π, β) ≥ 1 (Lemma 5.7). The value of ψ(π, S), for any sorting sequence S, is less than or equal to 7 (Lemma 5.6) and the algorithm ensures a score function greater than or equal to 1, which gives us the approximation factor of 7 .	2
Algorithm 7 -R¯ T has time complexity of O(n4). The analysis is similar to the previous greedy algorithms, except that it takes linear time to find the variation in the number of odd components caused by a short rearrangement [5].

Conclusion
In this work, we introduced the study of Sorting Permutations by Length-Weighted Short Rearrangements problems. We developed approximation-algorithms for five such problems. For future work, we aim at improving the approximation factors for problems involving signed permutations. Furthermore, we intend to study a new variation of this problem where the rearrangements’ length-limit is equal to an integer λ, with λ ≤ n.

References
Berman, P., S. Hannenhalli and M. Karpinski, 1.375-Approximation Algorithm for Sorting by Reversals, in: Proceedings of the 10th Annual European Symposium on Algorithms (ESA’2002), Lecture Notes in Computer Science 2461, Springer-Verlag Berlin Heidelberg New York, 2002 pp. 200–210.
Bulteau, L., G. Fertin and I. Rusu, Sorting by Transpositions is Difficult, SIAM Journal on Computing
26 (2012), pp. 1148–1180.
Caprara, A., Sorting Permutations by Reversals and Eulerian Cycle Decompositions, SIAM Journal on Discrete Mathematics 12 (1999), pp. 91–110.
Elias, I. and T. Hartman, A 1.375-Approximation Algorithm for Sorting by Transpositions, IEEE/ACM Transactions on Computational Biology and Bioinformatics 3 (2006), pp. 369–379.
Galv˜ao, G. R., O. Lee and Z. Dias, Sorting Signed Permutations by Short Operations, Algorithms for Molecular Biology 10 (2015), pp. 1–17.
Hannenhalli, S. and P. A. Pevzner, Transforming Cabbage into Turnip: Polynomial Algorithm for Sorting Signed Permutations by Reversals, Journal of the ACM 46 (1999), pp. 1–27.
Heath, L. S. and J. P. C. Vergara, Sorting by Short Swaps, Journal of Computational Biology 10 (2003),
pp. 775–789.
Jerrum, M. R., The Complexity of Finding Minimum-length Generator Sequences, Theoretical Computer Science 36 (1985), pp. 265–289.
Jiang, H., H. Feng and D. Zhu, An 5/4-Approximation Algorithm for Sorting Permutations by Short Block Moves, in: Proceedings of the 25th International Symposium on Algorithms and Computation (ISAAC’2014), Lecture Notes in Computer Science 8889 (2014), pp. 491–503.
Jiang, H., D. Zhu and B. Zhu, A (1+є)-Approximation Algorithm for Sorting by Short Block-Moves, Theoretical Computer Science 437 (2012), pp. 1–8.
Lefebvre, J.-F., N. El-Mabrouk, E. R. M. Tillier and D. Sankoff, Detection and validation of single gene inversions, Bioinformatics 19 (2003), pp. i190–i196.
Nguyen, T. C., H. T. Ngo and N. B. Nguyen, Sorting by Restricted-Length-Weighted Reversals, Genomics Proteomics & Bioinformatics 3 (2005), pp. 120–127.
Pinter, R. Y. and S. Skiena, Genomic Sorting with Length-Weighted Reversals, Genome Informatics
13 (2002), p. 2002.
Rahman, A., S. Shatabda and M. Hasan, An Approximation Algorithm for Sorting by Reversals and Transpositions, Journal of Discrete Algorithms 6 (2008), pp. 449–457.
Vergara, J. P. C., “Sorting by Bounded Permutations,” Ph.D. thesis, Virginia Polytechnic Institute and State University (1998).
Walter, M. E. M. T., Z. Dias and J. Meidanis, Reversal and Transposition Distance of Linear Chromosomes, in: Proceedings of the 5th International Symposium on String Processing and Information Retrieval (SPIRE’1998) (1998), pp. 96–102.
