Electronic Notes in Theoretical Computer Science 137 (2005) 111–129 
www.elsevier.com/locate/entcs


The Specification Logic νZ
Martin C. Henson1	Besnik Kajtazi2
Department of Computer Science University of Essex
Wivenhoe Park, Colchester, Essex, CO4 3SQ, UK

Abstract
This paper introduces a wide-spectrum specification logic νZ. The minimal core logic is extended to a more expressive specification logic which includes a schema calculus similar (but not equiva- lent) to Z, some new additional schema operators and extensions to a programming and program development logic.
Keywords: Specification Language, Wide Spectrum Language, Specification Logic, Operation Refinement, Program Development.


Introduction
In this paper we introduce a wide-spectrum logic νZ. This is a very small spec- ification logic based on a total correctness relational semantics with refinement as its fundamental relation.
The language which underlies the logic is Z-like, that is to say, we have schemas and schema operators.  A significant difference is that operation
schemas have two predicates, so resemble more the specification statements of the refinement calculus (e.g. [1] and [6]). This is, in fact, a fairly trivial differ- ence, and the language could easily be set up using single predicate schemas if preferred. On the other hand, there are several significant differences between νZ and Z:

1 Email: hensm@essex.ac.uk
2 Email: bkajta@essex.ac.uk



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.04.027


Z is based on a partial -correctness semantics; νZ is based on a total -correctness semantics.
Z permits refinement of over–specifications; νZ does not.
Z schema operators are not monotonic; νZ schema operators are monotonic (anti-monotonic).
Z is based on equality ; νZ is based on reﬁnement.
Z is a speciﬁcation language; νZ is wide-spectrum.
Z is relatively inflexible; νZ is extensible.
Z is a language; νZ is a logic.
In this introductory paper we concentrate entirely on the system itself, its mathematical basis and methodologies for extending the core framework with additional features for specification, for programming and for program development. In future publications we will explore more pragmatic issues, providing techniques and examples to demonstrate how to effectively specify, refine and implement systems within νZ.



Core νZ
νZ is interpreted within the logic Z⊥, the extension of ZC introduced in [3] which includes ⊥ elements in all types. We assume familiarity with this theory (and notational conventions); all this is also covered in [4].



Syntax of νZ
The syntax of the core νZ framework is minimal. The type of an operation schema, U , is P T (written U P T ) where T is a schema type which has the form ∆V = V Y V '. Generally we will, as is usual in Z, write ∆V for V Y V '. We will write U (v ) to indicate that variable v may appear free in the schema
expression U . 3



3 When the variable has the type P T and T is a schema type (that is: it is a variable over schemas) we shall write it in Z⊥, as we do in νZ, in upper-case.


Definition 2.1
U P T ::=
X P T	– schema variable
[T | P | Q ]	– atomic specifications
¬U P T	– negation

U P T0 ∨ U P T1
(T = T
Y T ) – disjunction

0	1	0	1

∃ xTx • U P T0
(T = T0
— Tx) – existential hiding

µX P T • U (X )P T	– recursive schemas

Semantics of νZ
We first need to define refinement. In this framework it is simply containment.


Definition 2.2

U P T ± U P T =

 U ) ⊆
 U )

We also need to specify the universe of specification models for a given type. Part (ii) is based on [2] section 8.1.
Definition 2.3


magicP T =
[T | true | false]

WT
=df
{ U P T  | magicP T ± U ∧ U o magicP(∆Tout ) ± U }

Now we have the semantics of specifications.
Definition 2.4 In what follows, T ٨ =df V⊥ * V ' . The types are omitted here, but are taken to be as specified in the syntax above.

 X )	=df X

'
df	0	1
٨
٨ | z0.P ⇒ z0.z '.Q }

 ¬U )	=df {z ∈ T
| z =V ⊥∨ z /∈ U }

٨	.	.

 U0 ∨ U1)	=df {z ∈ T
 ∃ x • U0)	=df {z ∈ T
| z ∈ U0) ∨ z ∈ U1)}
| ∃ y ∈ T ٨ • y ∈ U ) ∧ z = y T T }

 µX • U (X )) =df .{X ∈ WT | U (X )) ± X }

In the case of recursion, the schema variable X must appear in a positive position in U . That is: this is monotone recursion. The notation t.P indicates the usual distribution of the binding t through the proposition P so that its component observations x are replaced by t.x. Note that ⊥ .P = false for all P (⊥ satisfies nothing, in particular it is outside every precondition).

Logic of νZ
The semantics induces a logic for the constructs, as follows. In this introduc- tory paper we omit the proofs.

Reﬁnement
The rules for operation refinement in νZ are as follows:
Proposition 2.5 Let z be a fresh variable.
z ∈ U0 ▶ z ∈ U1 (±+)	U0 ± U1	t ∈ U0 (±−)
U0 ± U1	t ∈ U1
Atomic operation schemas
The rules for atomic operation schema in νZ are as follows:
Proposition 2.6


	t0.P ▶ t0.t ' .Q
(U )
t0 * t ' ∈ [T | P | Q ]
 t0 * t ' ∈ [T | P | Q ]	t0.P
(U )
t ' .Q

Negated schemas
Note that negation in νZ is not the relational inverse: it is well-known that the universe of total-correctness relations in this model is not closed under that operation (see e.g. [2]). An alternative characterisation of the semantics is available using a combination of relational inverse, disjunction and magic.
Definition 2.7
¬U = U −1 ∨ magic
In any event, the rules for negation are derivable:
Proposition 2.8


t /∈ U (U + )	t0 =⊥
(U + )

t ∈ ¬U	¬0
t0 * t ' ∈ ¬U	¬1



 t0 * t ' ∈ ¬U	t0 * t ' /∈ U ▶ P	t0 =⊥ ▶ P
(U )
P	¬
The notion satisfies double negation and excluded middle.
Proposition 2.9


 t ∈ U  t ∈ ¬¬U
t ∈ ¬¬U		
t ∈ U	t ∈ ¬U ∨ U

Disjunction schemas
The rules for disjunction schemas in νZ are derivable, as follows:
Proposition 2.10 Let i ∈ 2.
.	.	.

	t ∈ Ui	 (U + )	t ∈ U0 ∨ U1	t ∈ U0 ▶ P	t ∈ U1 ▶ P
(U −)

t ∈ U0 ∨ U1	∨i	P	∨

Existential hiding schemas
The rules for existential hiding schemas in νZ are derivable, as follows:
Proposition 2.11
	t ∈ U	 (U +)	t ∈ ∃ xTx • U	t * ⟨| x$y |⟩ ∈ U ▶ P	−

t	Tx	∃
(U∃ )

∈ ∃ x  • U	P
Recursive schemas
The rules for recursive schemas in νZ are derivable, as follows:
Proposition 2.12


t ∈ U (µX • U (X )) (µ+)	t ∈ µX • U (X )
(µ−)

t ∈ µX • U (X )	t ∈ U (µX • U (X ))
Specifying a specification language in νZ
The principles on which νZ is based include economy (the core system begin so small) and extensibility (the ease with which the core system can be made
more expressive). Since the core system is so inexpressive, a first ambition will be to provide additional infrastructure which provides for a considerably


more expressive specification language. We cover some aspects of this in this section, beginning with extensions providing other standard schema operators. Some of the operators which we consider here are familiar from Z (though, because the semantics is differnt, the logic of these operators departs from that in Z). In addition there will be variations on familiar operators, such as composition: in this section we provide a notion of composition which allows
arbitrary schemas to be composed, even when those schemas do not match for
type. Finally, we introduce a range of quite new operators, unfamiliar in Z, which we will see have some use when we turn to the topic of programming languages and program development logics in later sections.

Schema conjunction and implication
We can define these in terms of disjunction and negation, using the usual de Morgan definitions. We omit the proofs, which are a little more involved than usual, due to the more complex notion of negation we are obliged to use.
Definition 3.1
U0 ∧ U1 =df ¬(¬U0 ∨ ¬U1)
The usual rules are derivable.
Proposition 3.2 Let i ∈ 2.
t ∈ U0	t ∈ U1 (U +)	t ∈ U0 ∧ U1 (U − )


Definition 3.3
t ∈ U0 ∧ U1	∧
t ∈ Ui	∧i

U0 ⇒ U1 =df ¬U0 ∨ U1
With the obvious rules derivable:
Proposition 3.4

z ∈ U0 ▶ z ∈ U1 (U + )	t ∈ U0 ⇒ U1	t ∈ U0 (U − )
z ∈ U0 ⇒ U1	⇒	t ∈ U1	⇒
Universal Hiding
Universal hiding is defined in terms of existential hiding and negation, us- ing the standard de Morgan definition. We provide the proofs in detail, for illustration.
Definition 3.5
∀ xTx • U =df ¬∃ xTx • ¬U


And then the usual introduction and elimination rules are derivable.
Proposition 3.6 Let z be a fresh variable. We assume that t has the form t0 * t ' .



Proof.
t * ⟨| x$z |⟩ ∈ U
t ∈ ∀ xTx • U


	t =	(0)




δ.0
.

t0 =⊥∨ t0 /=⊥
t ∈ ¬ ∃ xTx • ¬U	t ∈ ¬ ∃ xTx • ¬U

t ∈ ¬ ∃ xTx • ¬U	(0)


where δ0 is:


t ∈ ∃ xTx • ¬U (1)

δ.1
.
false




and where δ1 is:
	false		(z)
t /∈ ∃ xTx • ¬U (1)
t ∈ ¬ ∃ xTx • ¬U





t  ⟨| x$z |⟩ ∈ чU (2)
t ⟨| x$z |⟩ /∈ U (3) t ⟨| x$z |⟩ ∈ U false
t0 =⊥ (3) t0 /=⊥ (0)
false false

false	(3)
 
Proposition 3.7 Let t have the form t0 * t ' .
t ∈ ∀ xTx • U	v ∈ Tx t * ⟨| x$v |⟩ ∈ U


Proof.


t0 =⊥∨ t0 /=⊥


(LEM )


δ.0
.
t * ⟨| x$v |⟩ ∈ U

δ.1
.
t * ⟨| x$v |⟩ ∈ U

t * ⟨| x$v |⟩ ∈ U	(0)
where δ0 is:




t0 ⟨| x$v |⟩ /∈ U (1)
t0 ⟨| x$v |⟩ ∈ чU t0 ⟨| x$v |⟩ ∈ Ts



t0 =⊥


(0)
t0  ⟨| x$v |⟩ ∈ T0 (2)

.
t0 ∈ T0
t0 /=⊥
t0  ⟨| x$v |⟩ =⊥ (2)

⟨| x$v |⟩ =⊥
v =⊥


v ∈ Tx
v /=⊥

t0  ⟨| x$v |⟩ ∈ T0⊥
false
false

false	(2)
t  ⟨| x$v |⟩ ∈ U (1)


and δ1 is:



t ∈ ч Е xTx • чU

t * ⟨| x$v |⟩ /∈ U (q)
t * ⟨| x$v |⟩ ∈ чU t ∈ Е xTx • чU
		false	  t * ⟨| x$v |⟩ ∈ U (q)



t0 * ⟨| x$ ⊥|⟩ =/
t0 /=⊥


(0)
⊥



Ξ-schemas
We have the usual idea of Ξ-schemas:
Definition 3.8
ΞT =df [∆T | true | θT = θ'T ]
The rules are straightforward:
Proposition 3.9

t * t ' ∈ ΞT
 t0 * t ' ∈ ΞT t0 = t1

The skip-extension
We use this to define the skip-extension of a schema:
Definition 3.10 When T0 and T1 are disjoint, we define:
U P T0 ⬦ T =	U Λ ΞT
Naturally this is well-defined even when the types are not disjoint, but the purpose of this is, as described, to extend a schema with skip and the definition has pathological effects in other circumstances.
The rules are straightforward:



Proposition 3.11

.
 t0 * t ' ∈ U	t0 =T t1
(U )

t0 * t ' ∈ U ⬦ T	o


t ∈ U ⬦ T
.
(U — )
t * t ' ∈ U ⬦ T
1	 (U — )

t ∈ U
t0 =T t1	o1


Schema Composition
In νZ we wish to compose arbitrary specifications; even when the types of the operations do not match. In this regard νZ differs from Z. For such composi- tions to make sense, it is necessary to match incompatible types and to ensure that operations do not arbitrarily adjust bindings in the process. The defini- tion of schema composition in νZ is, therefore, a little more complex than in
Z. Nevertheless, it is possible to specify composition in the core theory, using the skip-extension operator.

Definition 3.12 Let T
= T − T
with the form ∆T
= Tin Y T out '
and

L	1	0
' L	L	L

let Let TR = T0 − T1 with the form ∆TR = Tin Y T out . Let t be a vector of
R	R '	'

fresh observations with the size of the alphabet of T out
Y T out
(equivalently:

Tin Y Tin ).

1	R
P(T in YT out ' )


P(T in YT out ' )		'	'

0	0	o	1	1
0	9	1
=df E t • (U0 ⬦ TL)[α(T out
Y T out )/ t] Λ

(U1 ⬦ TR)[α(Tin Y Tin )/ t]
1	R
The following introduction and elimination rules are derivable for schema composition:
Proposition 3.13

.
t0 * t ' ∈ U0	t0 =T
.
t2	t2 * t ' ∈ U1	t2 =T t1	+

	2	L	1	R	 (Uo )
t0 * t ' ∈ U0 o U1	9

1	9
Proposition 3.14
.	.
t0 * t ' ∈ U0 o U1	t0 * t ' ∈ U0, t0 =T t2, t2 * t ' ∈ U1, t2 =T


t1 ▶ P

1	9	2	L	1	R	—
o
P	9
Restricted chaos
This definition introduces a restricted form of chaos: outside P this schema blocks.


Definition 3.15
chaosP =df [T | чP | false]
This leads to the following logical rules.


Proposition 3.16
	t0.P	


(chaos+)

 t0 * t ' ∈ chaosP	чt0.P
(chaos )

t0 * t ' ∈ chaosP	P	false	P

Schema specialisation
We use restricted chaos to introduce the specialisation of a schema at a par- ticular observation (it blocks elsewhere).
Definition 3.17 Let ET be the schema type corresponding to the observa- tions contained in E . Let ∆[xTx ] ≤ T .


P T	E

P ∆([xTx ]YET)

U	[x$E
T ] =df chaos(x=E)	Λ U

This induces the following rules:


Proposition 3.18
.
 t ∈ U	t.x = z.E t ∈ U [x$E ]


t ∈ U [x$E ]
	.	
t ∈ U

t ∈ U [x$E ]
t.x = t.E


Strengthening preconditions
This operator has the effect of (in general) strengthening the precondition of a schema U by stipulating an additional condition P .
Definition 3.19 Let TP ≤ T .
U P T ↑ PTP =	chaos ⇒ U
The operator is governed by induced logical rules.
Proposition 3.20


t.P ▶ t ∈ U t ∈ U ↑ P
t ∈ U ↑ P	t.P t ∈ U

Specifying a programming language in νZ
It is central to the methodology of νZ that it smoothly integrates specification and programming, and that it is possible to develop programs from specifica- tions. This is achieved by firstly specifying a programming language in νZ and then inducing a corresponding program logic: refinement then automatically
permits development from specifications to programs. We will develop such a language incrementally in this section.


skip
Definition 4.1

Rules for skip:
Proposition 4.2


skipP(∆T) =	ΞT


t * t '

∈ skip
(skip+)
 t0 * t ' ∈ skip
(skip )
t0 = t1



Inequation:
Proposition 4.3


θT = θ'T ▶ Q
skip ± [T | P | Q ]

Assignment
Let V = TE − [x T ]
Definition 4.4
x:= E =df [∆[x T ] | true | x ' = E ] Λ ΞV


Rules for assignment:
Proposition 4.5

t * t '[x'/t.E ] ∈ x:= E



(:=+)


 t0 * t ' ∈ x:= E
(:= )
t0[x/t0.E ] = t1



Rule for assignment:

z .P ▶ z .z '[x'/z.E ].Q
x:=E ± [xT ; V | P | Q ]


Conditional
We define a new operator, a conditional schema, in terms of conjunction and strengthening of preconditions:
Definition 4.6 Let TD ≤ T0 Ω T1.

if D then U P T0 else U P T1 =	U ↑ D Λ U
↑ чD

Rules for the conditional:
Proposition 4.7
.	.
t.D ▶ z ∈ U0	чt.D ▶ t ∈ U1 (if+)
t ∈ if D then U0 else U1


t ∈ if D then U0 else U1	t.D
.
t ∈ U0
(if—)

t ∈ if D then U0 else U1	t.(чD )  (if—)
.	1
t ∈ U1
Equations and inequations:
Proposition 4.8

.
if true then U0 else U1 = U0
Proof. Follow from specialisations of the introduction rule and the first elim- ination rule:
 false (1)
.	.







 
Proposition 4.9
	z ∈ U0	z ∈ U1	 (1)
z ∈ if D then U0 else U1
z ∈ if D then U0 else U1
.
z ∈ U0



Proposition 4.10

.
if false then U0 else U1 = U1

if D then [T | P | D Λ Q ] else [T | P | чD Λ Q ] ± [T | P | Q ]


Proof. In what follows we write φ for
z ∈ if D then [T | P | D Λ Q ] else [T | P | чD Λ Q ]






D ∨ чD

z .P (1)
φ	z .D (z)


z ∈ [T | P | D Λ Q ]
z .(D Λ Q )
z .Q

z .P (1)
φ	z .(чD ) (z) z ∈ [T | P | чD Λ Q ] z .(чD Λ Q )

z .Q

	z.Q		(z)
z ∈ [T | P | Q ] (1)


Cases
The previous section can easily be generalised to case commands:
We define a new operator, a case schema, in terms of conjunction and strengthening of preconditions:
Definition 4.11 Let T = {··· ci ·· ·}.

cases ET in c0
: U P T0
··· cn
: U P Tn endcases =

def

U0 ↑ E = c0 Λ ··· Λ Un ↑ E = cn
Rules and inequations are omitted here, but are obvious generalisations of those for the conditional.

Scope
Definition 4.12
begin var x : T ;U end =	Tx	'Tx • U
Proposition 4.13


t ∈ U
.
(begin+)

t ∈ begin var x : Tx;U end


t ∈ begin var x : Tx;U end t * ⟨| x$y0, x'$y1 |⟩ ∈ U ▶ P P
(begin—)

Procedure call
This and the interpretation of procedures themselves are mutually dependent. Suppose that f is a procedure (we will see an example in the next section), then procedure call is trivially defined:

f (E ) =df f [x$E ]

This leads to inference rules:


.
t ∈ f	t.x = t.E
t ∈ f (E )
t ∈ f (E )
	.	
t ∈ f
t ∈ f (E )
t.x = t.E


It is necessary to analyse this in advance of procedures themselves, as it is implicated in the definition, as we will now see.


Primitive recursive procedures over numbers
We define a new schema operator, primitive recursion over the natural num- bers, in terms of conjunction, strengthening of preconditions, existential hid- ing, schema application and recursive schemas.

Definition 4.14

proc f (x) cases x in 0 : U0; m +1 : U1(f (m)) endcases =df
µX • U0 ↑ x = 0 Λ E m • U1(X [x$m]) ↑ x = m +1 

The idea is that U1 is a schema whose alphabet includes m and which con- tains a free schema variable X whose type is the type of the entire procedure.
And the rules.

Proposition 4.15 Introduction:

.	.
t.x = 0 ▶ t ∈ U0	t.x = t.m +1 ▶ t ∈ U1(f (m))
	.	
t ∈ f

Consider the following derivation:



Proof.


(1)

t.x = t. .m +1 (z)
.

t.x .= 0	.	.

. .
t ∈ U0
.

(1)
 	t ∈ U1[f (m)]	(z)
t ∈ U1[f (m)] ↑ x = m +1 
.

t ∈ U0 ↑ x = 0	t ∈ E m • U1[f (m)] ↑ x = m +1 
	.	
t ∈ U0 ↑ x = 0 Λ E m • U1[f (m)] ↑ x = m +1  (µ+)
t ∈ f

Proposition 4.16 Elimination:

.
t ∈ f	t.x = 0 
	.	
t ∈ U0
.
t ∈ f	t.x = m +1 
	.	
t ∈ U1(f (m))

In what follows, we write U [E ] for U [x$E ], when x is understood.
Proposition 4.17 The following rule is derivable:
n ∈ N ▶ f (n) ± U [n]
f ± U


Proof. Consider the following derivation:

(1)		


z .x .∈ N

z ∈ f	z .x = z .x
z ∈ f (z .x)
.
f (z .x) ± U [z .x]

z ∈ U [z .x]

z ∈ U f ± U
(1)



And now, the key rule for program development for recursive programming: the rule for recursive synthesis:
Proposition 4.18 The following rule is derivable:
U0 ± U [0]	f (m) ± U [m] ▶ U1(f (m)) ± U [m + 1]
f ± U


Proof. Consider the following derivation:


(z)
z ∈ f (0)
z .x = 0 
U0 ± U [0]	z ∈ U0
z ∈ U [0]
(z)
f (0) ± U [0]
(z)
z ∈ f (0)
z ∈ f


f (n) ± U [n]



δ.
.
f (m + 1) ± U [m + 1]






(1)

f ± U	(0)


where δ is:
z ∈ f (m + 1) (3)	z ∈ f (m + 1) (3)


(0)
f (m) ± U [m]

z.x = m + 1	z ∈ f z ∈ U1(f (m))
.
.
U1(f (m)) ± U [m + 1]

z ∈ U [m + 1]
f (m + 1) ± U [m + 1] (3)



Primitive recursion over lists
The technique is easy to generalise. For example:
Definition 4.19

proc f (x) cases x in Nil : U0; Cons m0 m1 : U1(f (m1)) endcases =df
µX • U0 ↑ x = Nil Λ E m0, m1 • U1(X [x$m1]) ↑ x = Cons m0 m1

The rule for recursive synthesis over lists:
Proposition 4.20 The following rule is derivable:
U0 ± U [Nil]	f (m1) ± U [m1] ▶ U1(f (m1)) ± U [Cons m0 m1]
f ± U

Primitive recursion over trees
Similarly for trees:


Definition 4.21

proc f (x) cases x in Leaf m0 : U0; Node m1 m2 : U1(f (m)) endcases =df
µX • E m0 • U0 ↑ x = Leaf m0 Λ E m1, m2 • U1(X [x$m1], X [x$m2]) ↑ x = Node m1 m2
The rule for recursive synthesis over trees:
Proposition 4.22 The following rule is derivable:
U0 ± U [Leaf m0]	f (m1) ± U [m1], f (m2) ± U [m2] ▶ U1(f (m1, m2)) ± U [Node m1 m2]
f ± U
Primitive recursion over arbitrary free-types
All these special cases can be generalised to syntax-directed free types.
Types of the form Υ are the names of the free types and are given by equations of the form:
Υ ::= ··· | ci ⟨⟨··· Υij ·· ·⟩⟩ | ··· 
The terms of free-type:
t Υ ::= ci ··· t Υij ··· 
The logic of free types permits the introduction of values in the type, equality reasoning and finally, elimination (generally by induction).
Proposition 4.23
··· zij ∈ Υij ··· (Υ+)	··· zij ∈ Υij ···	··· zkl ∈ Υkl ··· (Υ )

ci ··· zij ··· ∈ Υ
ci ··· zij ··· =/
ck ··· zkl ···	/=


ci ··· zij ··· = ci ··· yij ··· 
zij = yij	(Υ=)

···	··· zij ∈ Υij ··· , ··· P [z/yk ] ··· ▶ P [z/ci ··· zij ·· ·]	··· (Υ—)
z ∈ Υ ▶ P
where the yk are all those variables occurring in the zij with type Υ.
Given a general free type Υ, the corresponding recursive program scheme
is:


Definition 4.24
procΥ f (x ) cases x in ··· Hi ··· endcases
where the Hi are the component cases:
Hi =df ci ··· mi ··· : Ui (··· f (wk ), ·· ·) where the wk are those observations among the mi with type Υ.
The semantics in the general case is given by:
Definition 4.25
procΥ f (x ) cases x in ··· Hi ··· endcases =df µX • ··· Λ Ki (X ) Λ ··· 
where:
Ki (X ) =df E ··· mi ··· • Ui (··· X [x$wk ] ·· ·) ↑ x = ci ··· mi ··· 
Conclusions and further work
As we mentioned in the introduction, this expository paper concentrates en- tirely on the theoretical basis of νZ. We have showed how an extremely simple logic can be extended towards an expressive specification logic and a program (development) logic. One of the benefits of this approach is its flexibility: one is not constrained by any particular specification or programming language infrastructure. The ability to provide elegant rules for total correctness de- velopment of procedures is also a strength: these rules resemble those which proved so useful in program development within constructive theories (see, for example, [5]) but are here combined with the ability to synthesize imperative programs.
Much infrastructural and pragmatic work remains to be done, both at the level of specification and program development. At the pragmatic level in particular, much work is being undertaken by Kajtazi and this will be reported in his PhD thesis.

Acknowledgements
The authors are grateful to Steve Reeves, Lindsay Groves and especially Moshe Deutsch for numerous discussions and critical appraisal of this work. We would like to acknowledge the support of the EPSRC RefineNet Network Grant (Ref: GR/S69979/02) in the development of this work, including comments from


participants at the January 2004 meeting in Sheffield where an earlier version of this material was presented.

References
R. J. R. Back and J. von Wright. Reﬁnement Calculus: A Systematic Introduction. Springer, 1998.
W. P. de Roever and K. Engelhardt. Data Reﬁnement: Model-Oriented Proof Methods and Their Comparison. Prentice Hall International, 1998.
M. Deutsch, M. C. Henson, and S. Reeves. An analysis of total correctness refinement models for partial relation semantics I. Logic Journal of the IGPL, 11(3):287–317, 2003.
M. C. Henson and S. Reeves. Investigating Z. Logic and Computation, 10(1):43–73, 2000.
P. Martin-L¨of. Constructive mathematics and computer programming. In Logic, Methodology and Philosophy of Science VI, pages 153–175. North Holland, 1982.
C. C. Morgan. Programming from Speciﬁcations. Prentice Hall International, 2nd edition, 1994.
