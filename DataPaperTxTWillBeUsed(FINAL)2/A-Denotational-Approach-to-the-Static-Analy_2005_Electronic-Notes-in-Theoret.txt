Electronic Notes in Theoretical Computer Science 118 (2005) 19–36  
www.elsevier.com/locate/entcs


A Denotational Approach to the Static Analysis of Cryptographic Processes
Benjamin Aziz1 ,2
Computer Science Department University College Cork
Cork, Ireland
Geoff W. Hamilton3, David Gray4
School of Computing Dublin City University Dublin, Ireland

Abstract
We present in this paper, a non-uniform static analysis for detecting the term-substitution property in processes specified in the spi calculus. The property is essential in defining security breaches, like secrecy and authenticity. The analysis is fully denotational, preserving compositionality and facilitating implementations in functional programming.
Keywords: Static Analysis, Cryptographic Protocols, Denotational Semantics


Introduction
The spi calculus [3] offers a process algebraic theory for the modelling of mobile cryptographic systems that essentially extends the value-passing theory of the π-calculus [18] by the addition of primitives for performing cryptographic

1 This work was partially funded by project IMPROVE (Enterprise Ireland Strategic Grant ST/2000/94)
2 Email: b.aziz@cs.ucc.ie
3 Email: hamilton@computing.dcu.ie
4 Email: dgray@computing.dcu.ie



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.12.016


operations. We view the cryptographic operations as the value-processing behaviour of processes. One aspect of the term-passing and term-processing behaviours that has significance when detecting security breaches in processes is term substitution. Term substitutions occur whenever communications, successful decryption, signature verification and tuple splitting take place. Security implications arise in scenarios where a process classified at a low secrecy level obtains high-level data, or a process classified at a high trust level obtains low-level data. We call the former information leakage and the latter authenticity breach.
In this paper, we propose a non-uniform static analysis that captures the property of term substitution in the spi calculus, and that is capable of distin- guishing between the different instances of these substitutions. The analysis is based on a closed denotational model of the language derived from Stark’s domain-theoretic equations for the π-calculus [20]. Apart from facilitating the use of computationally important mathematical concepts, like fixed-points, the denotational approach has the advantage that it results in an implemen- tation that is straightforward in functional programming.
The abstraction that we adopt limits, in a safe manner, the number of new names and the depth of data structures, both of which can grow, in concrete semantics, to an infinite level as a result of the use of the replication operator. Since the abstract semantic domain is kept finite, least fixed-point calculations are guaranteed to terminate for our monotonic semantic functions.

Related Work
The area of the static analysis of cryptographic processes has been researched intensively in recent years using a variety of techniques, which one can only mention here a few examples. These include types [2,1,7], symbolic methods [5,16,12,13,17], abstract interpretation [19,6,15,21] and control flow analysis [8,9,11,10]. The current work expands on previous work presented in [6] for mobile systems modelled by the π-calculus. In [6], names substituting vari- ables were captured directly in the analysis, and limiting the number of copies of these names was sufficient as an abstraction. In the spi calculus, the diffi- culty with this abstraction is that complex data structures also have infinite depths, as well as containing infinite number of names. This problem is solved by the use of tags. Also, in [6], the main property of interest was privacy, whereas here, we also deal with authenticity. Finally, the current analysis, unlike [6], is capable of distinguishing between the different instances of vari- ables, which is necessary for future definitions of the properties like freshness and resource exhaustion.

A Domain-Theoretic Model
We extend Stark’s domain-theoretic model [20] by introducing the following predomain equations, which underlie the primitive behaviour of input, output and silent actions as well as termination (deadlock) in the spi calculus:
Spi ∼= 1+ P(Spi ⊥ + In + Out )	(1)
In ∼= N × (T → Spi ⊥)	(2)
Out ∼= N × (T × Spi ⊥ + N → ... N → (T × Spi ⊥))	(3)
T ∼= N + Sec + Pub + Sig + Tup	(4)
Sec ∼= T × N	(5)
Pub ∼= T × N	(6)
Sig ∼= T × N	(7)
Tup ∼= T × ... × T	(8)
Where Spi ⊥ is the domain of processes, In and Out are the predomains of input and output actions, respectively. Input actions are modelled as pairs; a name, N (the channel), and a function, T → Spi ⊥, that can be instantiated with a term, T , yielding a process in Spi ⊥. Output actions are divided into free and bound output actions. These are pairs consisting of the channel, N , and either another pair, T × Spi ⊥, denoting the message, T , and the residue Spi ⊥ (free outputs), or composed functions, N → ... N → (T × Spi ⊥), that introduce new names to the message, T , and the residue, Spi ⊥ (bound outputs). P(−) is Plotkin’s powerdomain applied to the disjoint union of input, output and silent actions (the latter represented by Spi ⊥) to construct Spi . The one-element predomain, 1, representing terminated (deadlocked) processes is adjoined as in [4, Def. 3.4]. The flat predomain of closed terms, T , is defined as the disjoint union of the predomains of names, N , secret-key ciphers, Sec, public-key ciphers, Pub, digital signatures, Sig and finite tuples, Tup. The predomains Sec, Pub and Sig can be expressed as pairs, where a term, T , is encrypted/signed with a key, N .
The following functions are defined as usual, leading to Spi ⊥ [4, Def. 3.3]:
∅ :1 → Spi ⊥	(9)
{| − |} : (Spi ⊥ + In + Out )⊥ → Spi ⊥	(10)
  : (Spi ⊥ × Spi ⊥) → Spi ⊥	(11)
new : (N   Spi ⊥) → Spi ⊥	(12)
The empty set, ∅, is required to represent inactive processes. The singleton map, {| − |}, creates elements of Spi ⊥ from elements of input, output and silent actions. new is used to interpret the effects of restriction. Finally, , is the standard multiset union operator representing non-determinism.
Concrete elements of t ∈ T include names, a, b, c, k, secret-key ciphers,


sec(t, k), public-key ciphers, pub(t, k), digital signatures, sig(t, k) and tu- ples, (t1,... , tn). Elements p ∈ Spi ⊥ include the bottom element, {|⊥|}, the empty set, ∅ (where {|⊥|} ± ∅), input actions, in(a, λy.p), free output actions, out(a, t, p), bound output actions, out(a, λn1 ... λnm.(t, p)) and silent actions, tau(p). The effects of restriction are interpreted by defining new concretely as in Figure 1.

Fig. 1. The concrete definition of new over elements p ∈ Spi ⊥.

These effects lead to the blocking of processes attempting to communicate over fresh, non-extruded channels and the transformation of free outputs to bound outputs whenever the message of communication is a fresh name. The denotational semantics for the spi calculus can now be given as a semantic
function, S([P ]) ρ φS ∈ Spi⊥, defined by the set of rules of Figure 2. The multiset, ρ, is used to hold processes composed in parallel with the analysed process, where rule (R0) is used to interpret the contents of ρ. The envi- ronment, φS : V → T⊥, where V is the predomain of variables, captures any term substitutions that occur in the semantics. The special function,


(S1) S([0]) ρ φS	= ∅
(S2) S([M (y).P ]) ρ φS = {|in(ϕS (φS ,M ), λy.R([{|P |}ρ]) φS )|} where, ϕ(φE ,M ) ∈ N
(S3) S([M ⟨L⟩.P ]) ρ φS =



M '(z ).P '∈ρ
{|tau(R([{|P |}ρ ρ ρ[P ′/M ′(z).P ′]]) φS [z '→ ϕS (φS , L)]|}

 {|out (ϕS (φS ,M ), ϕS (φS , L), R([{|P |}ρ]) φS )|}
where, ϕS (φS ,M ) = ϕS (φS ,M ′) ∈ N


where,
( ) = let
= ([ n
[bnv (
) bnv (
)] ])	in

let

= ([ n +2

[bnv (
) bnv (

)] ])
= in

if p1 = p2 then p1 else F(n + 1)
and, bnv i(P ) = {xi | x ∈ bnv (P )}
(S7) S([if M = L then P else Q]) ρ φS =
R([{|P |}ρ ρ ρ]) φS , if ϕS (φS ,M ) = ϕS (φS , L)
R([{|Q|}ρ ρ ρ]) φS , otherwise
(S8)  S([let (x1,... , xn) = M in P else Q]) ρ φS =
 R([{|P |}ρ ρ ρ]) φ′ , if ϕS (φS ,M ) = (t1,..., tn)

R([{|Q|}ρ ρ ρ]) φS , otherwise
(S9) S([case L of {x}N in P else Q]) ρ φS =
 R([{|P |}ρ ρ ρ]) φ′ ,	if ϕS (φS , L) = sec(t, k) and ϕS (φS ,N ) = k

R([{|Q|}ρ ρ ρ]) φS ,	otherwise
(S10) S([case L of {[x]}N in P else Q]) ρ φS =
 R([{|P |}ρ ρ ρ]) φ′ , if ϕS (φS , L) = pub(t, k+) and ϕS (φS ,N ) = k−

R([{|Q|}ρ ρ ρ]) φS , otherwise
(S11) S([case L of [{x}]N in P else Q]) ρ φS =
 R([{|P |}ρ ρ ρ]) φ′ , if ϕS (φS , L) = sig (t, k−) and ϕS (φS ,N ) = k+

R([{|Q|}ρ ρ ρ]) φS , otherwise
(R0) R([ρ]) φS	=	S([P ]) (ρ\{|P |}ρ) φS
P ∈ρ

Fig. 2. The denotational semantics of the spi calculus.


ϕS : (V → T⊥) × Term → T , returns the semantic value of a term, given substitutions recorded by φS as follows:
 φS(M ),	if M ∈ V
 M,	if M ∈ N
 sec(ϕS(φS,M '), ϕS(φS,N )),	if M = {M '}N

ϕS(φS,M )= 
pub(ϕS(φS,M '), ϕS(φS,N )),	if M = {[M ']}N
 sig(ϕS(φS,M '), ϕS(φS,N )),	if M = [{M '}]N
 (ϕS(φS, M1),... , ϕS(φS, Mn)), if M = (M1,... , Mn)

Note that since we only deal with closed terms, the case where M = x ∈ V
and φS(x)= ⊥ will never be encountered (the case of open terms).
The description of rules (S1)–(S11) is as follows. Rule (S1) interprets the meaning of a null process as the empty set mapping, ∅. Rules (S2) and (S3) deal with processes guarded with input and output actions, respectively. The rule for output actions, (S3), considers communications between the output channel and appropriate input channels guarding processes in ρ. The φS is updated appropriately with semantic elements. Rule (S4) uses the new mapping to interpret the meaning of a restriction. Rule (S5) interprets directly parallel composition by the addition of the parallel subprocesses to ρ.
Finally, rule (S6) interprets a replicated process, !P , by calculating the higher-order function, F : N → Spi ⊥, starting from the bottom number, n =
−1, which computes the bottom semantic element, F(−1) = {|⊥|}. The value
of n is increased by 2 in each iteration to allow for any interactions between the copies of the replication to take place. This continues until the least fixed- point is reached. Due to the fact that the semantic domain, Spi ⊥, is infinite, this calculation may not terminate within finite limits. The rule also uses the labelling mechanism to rename all the bound names and variables, bnv(P ), of the spawned processes by subscripting those variables and names with a
number signifying each spawned copy. Since this renaming of bound variables and names is, in fact, α-conversion, the resulting process on the right side of the rule is structurally equivalent to a subprocess of the replication on the left side. This preserves the compositionality of the denotational semantics.
The rest of the rules rely on the meaning of terms as held by the φS environment before resolving the analysed process. In rule (S7), the meaning of two terms is compared, and depending on the result, one of two processes is chosen and added to ρ. Rules (S8)–(S11) deal with tuple splitting and cryptographic processes. The result of the tuple splitting and cryptographic


operations are used to update the φS with the appropriate semantic terms. A residual process, P , signifying the success of the operation is also added to ρ. In case an operation fails, an alternative process, Q, is chosen and added to ρ.




Non-Standard Semantics

The non-standard semantics of the spi calculus extends the standard denota- tional semantics introduced in Section 3, where term substitutions are recorded in a special environment φE : V → ℘(T ) that maps each variable of a closed process to the set of semantic terms that may substitute that variable during the evaluation of the meaning of a process. Since the non-standard seman- tics is precise (copies of bound names and variables are always distinct), each variable will be mapped to a singleton set at most per choice of control flow, representing the term that substitutes the variable.
A domain, D⊥ = V → ℘(T ), can be constructed, ordered by subset inclu- sion:

∀φE1, φE2 ∈ D⊥ : φE1 ±D⊥ φE2 ⇔ ∀x ∈ V : φE1(x) ⊆ φE2(x)

With the bottom element, ⊥D⊥ , being the null environment, φE0, that maps each variable to the empty set. The union of environments operation, ∪φ, can also be defined as follows:

∀φE1, φE2 ∈ D⊥,x ∈ V : (φE1 ∪φ φE2)(x)= φE1(x) ∪ φE2(x)

The non-standard semantic domain is formed by pairing D⊥ with the standard semantic domain, Spi ⊥, resulting in Spi ⊥ × D⊥. The bottom element of this domain is the pair (⊥Spi⊥ , ⊥D⊥ ). The non-standard semantics for the spi calculus can now be defined by the semantic function, E ([P ]) ρ φE ∈ (Spi ⊥ × D⊥), on the structure of P as in Figure 3.
The ρ multiset holds all the processes in parallel with the process under
interpretation. The definition of the ϕE : (V → ℘(T )) × Term → T func- tion allows for the meaning of a term to be computed under a particular φE


(E1) E([0]) ρ φE	= (∅, φE )
(E2) E([M (x).P ]) ρ φE = ({|in(ϕE (φE ,M ), λx.p′)|}, φE ) where, (p′, φ′ ) = R([{|P |}ρ]) φE and, ϕE (φE ,M ) ∈ N
(E3)  E([M ⟨L⟩.P ]) ρ φE =

(		{|tau(p′)|}  {|out (ϕE (φE ,M ), ϕE (φE , L), p′′)|},	 φ
′  ∪φ φE )

M '(z).P '∈ρ
if, ϕE (φE ,M ) = ϕE (φE ,M ′) ∈ N
M '(z).P '∈ρ

where, (p′, φ′ ) = R([{|P |}ρ ρ ρ[P ′/M ′(z).P ′]]) φE [z '→ {ϕE (φE , L)}] and, (p′′, φ′′) = R([{|P |}ρ]) φE
(E4) E([(νa)P ]) ρ φE	= (new (λa.p′), φ′ ) where, (p′, φ′ ) = R([{|P |}ρ ρ ρ]) φE
E	E
(E5) E([P | Q]) ρ φE	= R([{|P |}ρ ρ {|Q|}ρ ρ ρ]) φE
(E6) E([!P ]) ρ φE	= F(−1)

where,
( ) = let
= ([ n
[bnv (
) bnv (
)] ])	in

let
= ([ n +2

[bnv (
) bnv (

)] ])
in if
=	then
else
(  + 1)

and, bnv i(P ) = {xi | x ∈ bnv (P )}
(E7) E([if M = L then P else Q]) ρ φ =  R([{|P |}ρ ρ ρ]) φE , if ϕE (φE ,M ) = ϕE (φE , L)
R([{|Q|}ρ ρ ρ]) φE , otherwise


(E8)  E([let (x ,...,x ) = M in P else Q]) ρ φ = 
xn '→ {tn}],

1	n	E



if ϕE (φE ,M ) = (t1,... , tn)
 R([{|Q|}ρ ρ ρ]) φE , otherwise


(E9) E([case L of {x}N
R([{|P |}ρ ρ ρ]) φE [x '→ {t},
in P else Q]) ρ φ =  if ϕE (φE , L) = sec(t, k)





( 10)  ([case



of [ ]	in



else	])
and ϕE (φE ,N ) = k
R([{|Q|}ρ ρ ρ]) φE , otherwise
R([{|P |}ρ ρ ρ]) φE [x '→ {t}],
=  if ϕE (φE , L) = pub(t, k+)

E	E	L
{ x }N	P
Q  ρ φE
and ϕE (φE ,N ) = k−
R([{|Q|}ρ ρ ρ]) φE , otherwise
R([{|P |}ρ ρ ρ]) φE [x '→ {t}],


( 11)  ([case
of [	]  in
else	])
=  if ϕE (φE , L) = sig (t, k−)

E	E	L
{x} N
P	Q  ρ φE

 	 

	 
and ϕE (φE ,N ) = k+
 R([{|Q|}ρ ρ ρ]) φE , otherwise



Fig. 3. The non-standard semantics of the spi calculus.



environment:




ϕE (φE,M )= 

 t,	if M ∈ V ∧ φE (M )= {t}
 M,	if M ∈ N
 sec(ϕE (φE ,M '), ϕE (φE,N )),	if M = {M '}N
pub(ϕE (φE ,M '), ϕE(φE ,N )),	if M = {[M ']}N
 sig(ϕE (φE ,M '), ϕE (φE,N )),	if M = [{M '}]N
 (ϕE (φE , M1),... , ϕE (φE , Mn)), if M = (M1,... , Mn)

The semantic rules are described as follows. In (E 1), the meaning of a null process is described as the pair (∅, φE), where φE is the environment supplied to the rule initially. Rules (E 2) and (E 3) deal with the cases of input and output actions, respectively. Communications are dealt with in (E 3) for output actions, therefore, φE remains unchanged in (E 2) for input actions. The rule for output actions requires that terms used as channels should evaluate to names, and communications occur whenever an input channel is matched in ρ. The value of φE is updated with the message term substituting the input parameter. Rule (E 4) interprets the meaning of a restriction using the new operation on the first element of the resulting pair, whereas the second element reflects the environment resulting from the residue. This is justified as internal communications are preserved by restriction. Rule (E 5) composes two parallel processes in ρ.
The replication of processes is dealt with in rule (E 6) by computing a special function, F : N → Spi ⊥ × D⊥, starting at the bottom number, n = −1, and incrementing n by 2 until we reach a least fixed-point for v1 ∈ Spi ⊥ × D⊥. Such a computation is not guaranteed to terminate due to the infinite nature of the non-standard semantic domain, Spi ⊥ × D⊥. Also, α-conversion renames the set of bound names and variables of each process copy, while maintaining the compositionality of the semantics. Rule (E 7) deals with a conditional
process, where the meaning of the overall process is chosen from the two branch processes based on the semantic equality of the compared terms. Pair splitting is dealt with in rule (E 8) where the φE is updated to hold the result of the substitution of local variables by elements of a tuple. The rest of the rules (E 9)–(E 11) deal with cryptographic processes performing secret-key decryption, public-key decryption and digital signature verification.
The correctness requirement for the non-standard semantics of the spi cal- culus, with respect to its standard semantics, is expressed in the following theorem, which states that the standard element of the non-standard seman-

tics is equivalent to the value obtained from the standard semantics..
Theorem 1 (Correctness of the Non-Standard Semantics)
∀P ∈P : (S([P ]) ρ φS = p) ∧ (E ([P ]) ρ φE = (p', φ' ))	⇒	p = p'
Proof . The proof is by induction on the standard and non-standard semantics.
 

Abstract Semantics
We begin by assuming a finite predomain of tags, Tag , ranged over by t, t˙, t¨, where t is the tag of a generic term, t˙ is the tag of a primitive term (name, vari- able) and t¨ is the tag of a complex term (ciphertext, signature, tuple). Next we tag (sub)terms of the analysed process with unique tags. More precisely, we tag M in the constructs let (x1,..., xn) = (M1,..., Mn) in P else Q, case {M }L of {x}N in P else Q, case {[M ]}L of {[x]}N in P else Q,
case [{M }]L of [{x}]N in P else Q and N ⟨M ⟩.P .
For example, tagging the term {({a}c, {b}e)}d yields {({at˙1}t¨1, {bt˙2}t¨2)t¨3}t¨4.
c	e	d
The following functions are also defined over tags, terms and processes:
value of ({t1,... , tn})= {M1,... , Mn}. This function can be applied to a set of tags, {t1,..., tn}, returning the corresponding set of terms, {M1,... , Mn}.
Hence, value of ({t˙1, t¨4})= {at˙1, {({at˙1}t¨1, {bt˙2}t¨2)t¨3}t¨4 }.
c	e	d
tags of (P )= {t1,... , tn}. This function returns the set, {t1,... , tn}, of tags
used in a process, P .
For example: tags of (m⟨at˙1⟩.m⟨{(bt˙2, ct˙3)t¨1}t¨2⟩.0)= {t˙1, t˙2, t˙3, t¨1, t¨2}.
untag ({M ' ,... ,M ' }) = {M1,... , Mn}. When applied to a set of tagged
1	n
terms, {M ' ,... ,M ' }, this function removes all associated tags yielding a set
1	n
of untagged terms, {M1,... , Mn}. Hence:
untag({at˙5, {(at˙1, {bt˙2}t¨2)t¨3}t¨4 }) = {a, {(a, {b}e)}d }. The function behaves
e	d
as id if a term, M ', has no tags.
We now introduce the αk,k' abstraction function, which keeps to a finite level, the number of copies of bound variables, names and tags.
Definition 1 Deﬁne αk,k' : N × N × (V + N + Tag) → (V + N + Tag ):


 ¨k	¨i	'

∀M ∈ (V +N +Tag), i, k,k ∈ N : αk,k'(M )= 
xk, if M = xi ∈ V and i > k ak, if M = ai ∈ N and i > k 
 M, otherwise

The resulting abstract predomains, V , N and Tag , can be defined as V =
V \{xj | j > k}, N = N \{aj | j > k} and Tag = Tag\({t˙j | j > k}∪ 
{t¨i | i > k'}). Informally, k constrains the number of bound variables and names, and tags of primitive terms, whereas k' constrains the number of tags of complex terms. In effect, constraining the tags of primitive terms implies limiting the copies of bound names and variables carrying the tags, whereas constraining the number of tags of complex terms means limiting the depth of data structures.
For example, in the process !(ν n)a⟨nt˙⟩ | !a(x), it is possible to spawn
infinite copies of each replication, (νn )a⟨nt˙1 ⟩ | a(x ) | (νn )a⟨nt˙2 ⟩ | a(x ) |
1	1	1	2	2	2
.. .. It is clear that t˙ is an indicator to the number of copies n has after
spawning each process. On the other hand, the process !a(x).a⟨{x}t¨⟩ | a⟨b⟩,
which also spawns a(x ).a⟨{x }t¨1 ⟩ | a(x ).a⟨{x }t¨2 ⟩ | a⟨b⟩ | ... demonstrates
1	1 k	2	2 k
the role of t¨ as an indicator to the number of times the ciphertext, {x}k, is
applied to b.
Using the αk,k' abstraction, we construct the abstract environment φA : V → ℘(Tag ), which maps each abstract bound variable of the analysed process to a set of tags, representing terms that could substitute that variable
during the abstract semantics. An abstract domain D  = V  → ℘(Tag ) is
formed ordered by subset inclusion:





∀φA1, φA2 ∈ D ,x ∈ V  : φA1 ±
φA2 ⇔ φA1(x) ⊆ φA2(x)

⊥	D⊥




The bottom element, ⊥   , is the null environment, φA0, mapping each variable
⊥

to {}. Taking D 
as the abstract semantic domain, we can define the abstract

semantics of the spi calculus by the function A([P ]) ρ φA ∈ D , as in Figure
4. ρ again is a multiset of processes in parallel with the analysed process. The special function, ϕA : (V → ℘(Tag )) × Term → ℘(Term), returns a set of terms corresponding to a term, M , given substitutions captured by φA:
ϕA(φA,M )= ϕ' (φA,M '){},
where, M ' = M [αk,k' (t)/t][αk,k'(x)/x][αk,k' (n)/n] and ϕ' (φA,M )s = if M ∈ s then {} else


(A1) A([0]) ρ φA = φA	(A2) A([M (x).P ]) ρ φA = φA

(A3) A([M ⟨Lt⟩.P ]) ρ φA = (	φ
M '(z).P '∈ρ
φ′ )  ∪φ φA

if, untag(ϕA(φA,M )) ∩ untag(ϕA(φA,M ′)) ∩N /= {}
where, φ′ = R([{|P |}ρ ρ ρ[P ′/M ′(z).P ′]]) φ′′
and, φ′′ = φA[αk,k' (z) '→ φA(αk,k' (z)) ∪ {αk,k' (t)}] (A4) A([(νa)P ]) ρ φA	= R([{|P |}ρ ρ ρ]) φA
(A5) A([P | Q]) ρ φA	= R([{|P |}ρ ρ {|Q|}ρ ρ ρ]) φA

( 6)
([! ])
=	( 1) where,
( ) = let
=  ([
 n ren(
) ])	in

let
= ([ n +2

) ])
in if
=	then
else
( + 1)

and, ∀x ∈ bnv (P ),t ∈ tags of (P ) : ren(P, i) = (P [xi/x])[ti/t] (A7) A([if M = L then P else Q]) ρ φA =
R([{|P |}ρ ρ ρ]) φA, if, untag(ϕA(φA,M )) ∩ untag(ϕA(φA, L)) /= {}
R([{|Q|}ρ ρ ρ]) φA, otherwise
(A8) A([let (x1,... , xn) = M in P else Q]) ρ φA =
	R([{|P |}ρ ρ ρ]) φ′	if, ∃(Mt1 ,...,Mtn ) ∈ ϕA(φA,M )

φ
(Mt1 ,...,Mtn )∈ϕA(φA ,M)
A	1	n

 where, φ′

= φA[αk,k' (x1) '→ φA(αk,k' (x1)) ∪ {αk,k' (t1)},... ,
αk,k' (xn) '→ φA(αk,k' (xn)) ∪ {αk,k' (tn)}]

R([{|Q|}ρ ρ ρ]) φA,	otherwise
(A9)  A([case L of {x}N in P else Q]) ρ φA =

	 φ
R([{|P |}ρ ρ ρ]) φ′ , if, n ∈ ϕA(φA,N )



where, φ′
= φA

[αk,k
' (x) '→ φA

(αk,k
' (x)) ∪ {α


k,k
' (t)}]



	 φ

R([{|P |}ρ ρ ρ]) φ′ , if, n− ∈ ϕA(φA,N )



where, φ′

= φA
[αk,k
' (x) '→ φA
(αk,k
' (x)) ∪ {α

k,k
' (t)}]



	 φ

R([{|P |}ρ ρ ρ]) φ′ , if, n+ ∈ ϕA(φA,N )



where, φ′

= φA
[αk,k
' (x) '→ φA
(αk,k
' (x)) ∪ {α

k,k
' (t)}]




P ∈ρ

Fig. 4. The abstract semantics of the spi calculus.

	ϕ' (φA, L)s∪{M}	if M ∈V 
A
 L∈value of (φA(untag(M )))
{M },	if, M ∈N 
 {∀N ' ∈ ϕ' (φA,N )s∪{M}, L' ∈ ϕ' (φA, L)s∪{M} : {N '}t ' }, if, M = {N }t
{∀N ' ∈ ϕ' (φA,N )s∪{M}, L' ∈ ϕ' (φA, L)s∪{M} : {[N ']}t ' }, if, M = {[N ]}t
A	A	L	L

A	A	L	L

1	A	n	A

 (M ' ,...,M ' )t },	if, M = (M1,..., Mn)t

The description of the rules is as follows. Rules (A1) and (A2) return the φA environment unchanged. Communications are dealt with in rule (A3) for output actions, where synchronising output and input channels yield a communication, in which the tag of the message is captured by φA. The semantics is imprecise, since φA only captures an abstract tag as a value for an abstract variable. Rules (A4) and (A5) deal with the cases of restriction and parallel composition directly by placing the subprocesses with the rest in ρ. The rule for replication, (A6), performs a least fixed-point calculation using a special function, F : N → D . This least fixed-point occurs at the minimum

number, n, such that A([
n	n+2
ren(P, i) ]) ρ φA = A([	ren(P, i) ]) ρ φA. The

i=1	i=1
termination property of this calculation is stated formally in the following
theorem.
Theorem 2 (Termination of the least fixed-point calculation)
The calculation of rule (A6) terminates.
Proof. To prove the termination property, it is necessary to satisfy two re- quirements. First, the semantic domain must be finite. This is satisfied by the definition of D . The second requirement is to prove the monotonicity
n	n	n+2
of A([	P ]) ρ φA, i.e. A([	P ]) ρ φA ± A([	P ]) ρ φA. To prove this,
we simplify the inequality into A([ Q ]) ρ φA ± Aπ([ Q | P ]) ρ φA, where
 n	π	'
where ρ' = ρ ρ {|P |}ρ. This can be proven by induction over A([ P ]) ρ φA. In particular, the most interesting cases are rules (A3) and (A8)–(A11), where φA changes. For example, in rule (A3), we have that since ρ ⊆ ρ', then M '(y).P ' ∈ ρ ⇒ M '(y).P ' ∈ ρ'.  From this we can conclude that A([ Q ]) ρ φA ± A([ Q ]) ρ' φA, since the environment resulting from A([ Q ]) ρ φA will necessarily be a subset of the environment resulting from A([ Q ]) ρ' φA


(i.e. the larger system induces more term substitutions).	 

The rule for replication also uses the labelling mechanism to α-convert the set of bound names and variables of each copy of the replication, bnv(P ), as well as its set of tags. This renaming retains the compositionality of the semantics. The rule for conditional processes, (A7), relies on the equality of two untagged terms under φA. If in the case that the equality does not hold, a different alternative process is chosen. The rule for tuple splitting, (A8), attempts to split elements of a set of tuples corresponding to the value of ϕA(φA, L) of a term, L. The φA environment is updated with the tags of the elements of each tuple. In case no tuples exist in the set, an alternative process is chosen and φA is left unchanged. The rest of the rules, (A9)–(A11), deal with cryptographic processes. Again, a process attempts to decipher (verify) a term, L, closed by ϕA(φA, L). The tags of the deciphered terms are added to φA. Else a different process is chosen without affecting φA. Finally, rule (R0) groups all the environments resulting from the interpretation of processes in ρ with the union of environments operation, ∪φ.
We can state the safety of the abstract semantics by the following theorem.

Theorem 3 (Safety of the abstract semantics for the spi calculus)
(E ([P ]) ρ φE = (p, φ' )) ∧ (A([P ]) ρ φA = φ' ) ∧
E	A
(∃M ∈ Term : ϕE (φE ,M ) ∈ φE (x) ⇒ ∃t ∈ φA(αk,k'(x)) : value of ({t}) = 
{M '} ∧ untag (M ')= (∀y ∈ bnv (M ): M [αk,k' (y)/y]))
⇒	(∃M ∈ Term : ϕE (φ' ,M ) ∈ φ' (x) ⇒ ∃t ∈ φ' (αk,k'(x)) : value of ({t})= 
E	E	A
{M '} ∧ untag (M ')= (∀y ∈ bnv (M ): M [αk,k' (y)/y]))
Proof . The proof is by induction over the structure of the abstract semantics.
 

The theorem states that for any term, M , captured in the non-standard se- mantics by including its ϕE (φ' ,M ) value in the value of a variable, φ' (x),
E	E
then that will correspond to capturing a tag, t, in the abstract semantics, by
φ' (αk,k'(x)). The appropriateness of t is expressed by the ability to obtain an abstract form, ∀x ∈ bnv (M ) : M [αk,k' (x)/x], of the concrete term, M , by evaluating t using value of and untagging the resulting term, M ', using untag . More concisely, every concrete term, M , captured in the non-standard semantics is captured as the corresponding abstract tag, t, in the abstract semantics.

Secrecy and Authenticity
To reason about the secrecy and authenticity properties of a system, it is necessary to give formal definitions of these properties with respect to the result of the static analysis, i.e. φA. We start by assuming that S and A are finite chains of secrecy and trust levels, respectively, where l, l' ∈ S and a, a' ∈
A. A well-defined security policy, controlled by the system administrators,
classifies (sub)processes of a system with their secrecy and trust levels using the S and A chains, and according to the security requirements of the system. Furthermore, let ξS : (U ∪ V) → S and ξA : (U ∪ V) → A be two environ- ments that map the new names and variables of classiﬁed processes, [P |l and [P |a, to their secrecy and trust levels, respectively. The null environments are defined as: 6x ∈ U ∪ V : ξS0(x) = ⊥S, ξA0(x) = ⊥A. To construct a general environment ξ for some classified process, the function Z is defined over the structure of [P |z as in Figure 5, where ξ = ξS whenever z ∈ S, and ξ = ξA
whenever z ∈ A.

Fig. 5. Definition of the Z function over classified processes.
The rules use the ∪ξ operation defined as follows:
6x ∈U ∪ V : (ξ1 ∪ξ ξ2)(x)= ξ1(x) H ξ2(x)	(13)
The use of H is due to the fact that x can be defined in one environment at most, ξ1 or ξ2. One may now define the following secrecy and authenticity threats:
Property 1 (Information Leakage & Authenticity Breach) Given a pro- cess P, the static analysis environment φA = A([P ])s ρ0 φA0, and the environ-


ments ξS and ξA, then the information leakage and authenticity breach threats occur whenever the following conditions hold true:
∃x ∈ dom(φA),y ∈ φA(x): ξS(x) ± ξS(y)    (Information Leakage)
∃x ∈ dom(φA),y ∈ φA(x): ξA(x) ± ξA(y)    (Authenticity Breach)
The information leakage property captures instances where names created by high-secrecy-level processes are obtained by processes classified at low secrecy levels. The word obtained refers to substitutions occurring as a result of input actions or the success of cryptographic and tuple-splitting operations. On the other hand, the direction of concern in the authenticity breach property is reversed. Here, the authenticity requirements of a high-trust-level process are breached whenever it inputs a name, or decrypts, verifies or splits a term resulting in a name, which was created by a less trusted process.

Conclusion and Future Work
We have presented a static analysis for security properties in cryptographic processes modelled by the spi calculus. The analysis is characterized as be- ing fully denotational; this leads to implementations that are closely related to functional programming. The applicability of the analysis in detecting in- stances of information leakage and authenticity breaches was demonstrated for a number of cryptographic protocols, with the results shown in Figure 6. All of these protocols were analysed in the presence of an intruder process, I, such that I represents the most general attacker of Dolev-Yao [14]. The analysis is then performed by applying A([Protocol ]) {|I|} φA, where Protocol is the specification of the protocol.
Future work is under way to expand the analysis to be able to use the non- uniformity of the domain of φA in defining security properties, in particular, the freshness property. This non-uniformity also permits the definition of a resource exhaustion property based on a cost-resource relationship, where variables denote the available resources and the captured names, the cost. plain

References
Mart´ın Abadi. Secrecy by typing in security protocols. In Mart´ın Abadi and Takayasu Ito, editors, Proceedings of the 3rd International Symposium on Theoretical Aspects of Computer Software, volume 1281 of Lecture Notes on Computer Science, pages 611–638, Sendai, Japan,
September 1997. Springer Verlag.
Mart´ın Abadi and Bruno Blanchet. Analyzing security protocols with secrecy types and logic programs. In Proceedings of the 29th Annual ACM SIGPLAN-SIGACT Symposium on


Fig. 6. Results of the analysis of some authentication protocols.
Principles of Programming Languages, pages 33–44, Portland, USA, January 2002. ACM Press.
Mart´ın Abadi and Andrew Gordon. A calculus for cryptographic protocols: The spi calculus. In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 36–47, Zurich, Switzerland, April 1997. ACM Press.
Samson Abramsky. A domain equation for bisimulation. Information and Computation, 92(2):161–218, June 1991.
Roberto Amadio and Denis Lugiez. On the reachability problem in cryptographic protocols. In Catuscia Palamidessi, editor, Proceedings of the 11th International Conference on Concurrency
Theory, volume 1877 of Lecture Notes on Computer Science, pages 380–394, Pennsylvania, USA, August 2000. Springer Verlag.
Benjamin Aziz and Geoff Hamilton. A privacy analysis for the π-calculus: The denotational approach. In Proceedings of the 2nd Workshop on the Speciﬁcation, Analysis and Validation for Emerging Technologies, Copenhagen, Denmark, July 2002.
Bruno Blanchet. From secrecy to authenticity in security protocols. In Manuel V. Hermenegildo and German Puebla, editors, Proceedings of the 9th International Symposium in Static Analysis, volume 2477 of Lecture Notes on Computer Science, pages 342–359, Madrid,
Spain, September 2002. Springer Verlag.
Chiara Bodei, Pierpaolo Dagano, Flemming Nielson, and Hanne Riis Nielson. Control flow analysis for the π-calculus. In Proceedings of the 9th Conference on Concurrency Theory,
volume 1466 of Lecture Notes on Computer Science, pages 84–98, Nice, France, September 1998. Springer Verlag.
Chiara Bodei, Pierpaolo Dagano, Flemming Nielson, and Hanne Riis Nielson. Static analysis of processes for no read-up and no write-down. In Proceedings of the Conference on Foundations of Software Science and Computation Structures, volume 1578 of Lecture Notes on Computer Science, pages 120–134, Lisbon, Portugal, March 1999. Springer Verlag.
Chiara Bodei, Pierpaolo Dagano, Flemming Nielson, and Hanne Riis Nielson. Static analysis for secrecy and non-interference in networks of processes. In Proceedings of the 6th International Conference in Parallel Computing Technologies, volume 2127 of Lecture Notes on Computer
Science, pages 27–41, Novosibirsk, Russia, September 2001. Springer Verlag.
Chiara Bodei, Pierpaolo Dagano, Flemming Nielson, and Hanne Riis Nielson. Static analysis for the π-calculus with applications to security. Information and Computation, 168(1):68–92, July 2001.


Michele Boreale. Symbolic trace analysis of cryptographic protocols. In Fernando Orejas, Paul G. Spirakis, and Jan van Leeuwen, editors, Proceedings of the 28th International
Colloquium on Automata, Languages and Programming, volume 2076 of Lecture Notes on Computer Science, pages 667–681, Crete, Greece, July 2001. Springer Verlag.
Michele Boreale and Maria Grazia Buscemi. Experimenting with sta: A tool for automatic analysis of security protocols. In Proceedings of the ACM Symposium on Applied Computing, pages 281–285, Madrid, Spain, March 2002. ACM Press.
Danny Dolev and A. Yao. On the security of public key protocols. In Proceedings of the 22nd
Annual Symposium on Foundations of Computer Science, pages 350–357, October 1981.
J´erˆome Feret. Confidentiality analysis of mobile systems. In Proceedings of the 7th International Static Analysis Symposium, volume 1824 of Lecture Notes on Computer Science, pages 135–154, University of California, Santa Barbara, USA, June 2000. Springer Verlag.
Antti Huima. Efficient infinite-state analysis of security protocols. In Proceedings of the FLOC 1999 Formal Methods and Security Protocols Workshop, pages 21–51, Trento, Italy, July 1999.
Fabio Martinelli. Symbolic partial model checking for security analysis. In Proceedings of the 2nd Workshop on the Speciﬁcation, Analysis and Validation for Emerging Technologies, Copenhagen, Denmark, July 2002.
Robin Milner, John Parrow, and David Walker. A calculus of mobile processes (parts i & ii).
Information and Computation, 100(1):1–77, September 1992.
David Monniaux. Abstracting cryptographic protocols with tree automata. In Agostino Cortesi and Gilberto Fil´e, editors, Proceedings of the 6th International Static Analysis
Symposium, volume 1694 of Lecture Notes on Computer Science, pages 149–163, Venice, Italy, September 1999. Springer Verlag.
Ian Stark. A fully abstract domain model for the π-calculus. In Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science, pages 36–42, New Brunswick, New Jersey, USA, July 1996. IEEE Computer Society.
Arnaud Venet. Abstract interpretation of the π-calculus. In Mads Dam, editor, Proceedings of the 5th LOMAPS Workshop on Analysis and Veriﬁcation of Multiple-Agent Languages,
volume 1192 of Lecture Notes on Computer Science, pages 51–75, Stockholm, Sweden, June 1996. Springer Verlag.
