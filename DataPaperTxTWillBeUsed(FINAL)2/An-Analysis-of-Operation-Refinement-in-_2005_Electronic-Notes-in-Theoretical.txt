Electronic Notes in Theoretical Computer Science 137 (2005) 67–92  
www.elsevier.com/locate/entcs


An Analysis of Operation-Refinement in an Abortive Paradigm
Moshe Deutsch1	Martin C. Henson2
Department of Computer Science University of Essex
Wivenhoe Park, Colchester, Essex, CO4 3SQ, UK

Abstract
This paper begins a new strand of investigation which complements our previous investigation of refinement for specifications whose semantics is given by partial relations (using Z as a linguistic vehicle for this semantics). It revolves around extending our mathematical apparatus so as to continue our quest for examining mathematically the essence of the lifted-totalisation semantics (which underlies the de facto standard notion of refinement in Z) and the role of the semantic elements ⊥ in model-theoretic refinement, but this time in the abortive paradigm. We consider the simpler framework of operation-reﬁnement and, thus, (at least at this stage) abstract from the complications emerging when data simulations are involved: we examine the (de facto) standard account of operation-refinement in this regime by introducing a simpler, normative theory (SP- refinement) which captures the notion of ﬁring conditions refinement directly in the language and in terms of the natural properties of preconditions and postconditions; we then summarise our observations and link them to the particular role each of the possible extreme speciﬁcations in Z plays in the abortive paradigm - this lays the foundations to a more intricate future investigation of data-reﬁnement in this paradigm. We conclude by providing a detailed account of future work which generalises Miarka, Boiten and Derrick’s work of combining the abortive and chaotic paradigms for
refinement, in our mathematical framework of ZC and Z⊥.
Keywords: Operation-Refinement, Specification Language, Specification Logic.


Introduction
The concept of stepwise-refinement constitutes a pragmatic interpretation of the Transformational Software Process Model widely-known in the Software

1 Email: mdeuts@essex.ac.uk
2 Email: hensm@essex.ac.uk



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.04.025


Engineering literature. It embodies the most important strategy employed for managing the immense complexity arising during the development process of large-scale software systems: separation and orthogonality of software compo- nents so as to structure the development in a systematic manner that would be easier for human consumption. The idea is to decompose the design phase of the software life cycle into a number of simpler (and, thus, manageable) steps, each of which transforms a system description of a certain level of ab- straction into a more concrete one; the final step transforms a concrete system description into a computer program. Each of these transformations is verified by refinement rules; this ensures that, firstly, the process is gradual (each step includes some more design decisions within the system under development) and, secondly, that correctness is preserved in the course of development (the final program is guaranteed to meet the initial abstract specification). Operation-reﬁnement concerns the derivation of a more concrete operation from a given abstract one, without changing the representation of its under- lying state space. 3 It is, effectively, the degenerate case of data-reﬁnement in which data simulations are identity functions.
Z is a state-based formalism based on an underlying partial relation seman- tics, where a specification (of an operation) denotes a set of bindings which can be construed to be a partial relation between input sub-bindings and out- put sub-bindings (see, for example, [25] and [40,10,37] for accounts of Z logic and semantics along these lines). Unlike some other formalisms such as B
[1] and VDM [30], the (standard) language definition of Z does not provide any account of refinement. Therefore, in light of both the popularity of Z and the increasing interest in incorporating refinement within development processes, it is very important to acquire a comprehensive understanding of foundational (as well as pragmatic) aspects of refinement in Z. Note that, in the world of state-based formalisms, there are two major paradigms for refine- ment of partial specifications; we refer to these as the chaotic and the abortive paradigms. The former represents a more sequential view where preconditions may be weakened in the course of refinement, whereas the latter represents a more concurrent view in which preconditions remain fixed during refinement.
Indeed, we have, in previous work (e.g. [16,14,13,15,12]), concentrated on a foundational investigation of both operation-refinement and data-refinement in the chaotic paradigm. The (de facto) standard approach for refinement in this paradigm is a model-theoretic one, where the specifications (partial relations) are both completed (made total) and extended (by means of an additional semantic value, often called bottom and written ⊥); this semantics is often known as the chaotic-lifted-totalisation. We examined (in ibid.) the

3 Hence, it is often known as algorithm / algorithmic reﬁnement or algorithm design.


essence of this semantics and explained precisely the mathematical (as well as the conceptual ) role of the ⊥ values in model-theoretic refinement in this paradigm.
In this paper, we begin a new strand of investigation which complements our previous work: we will extend our mathematical apparatus so as to es- tablish an investigation of operation-refinement in the abortive paradigm. We shall, thus, begin to shed some light on ﬁring conditions refinement, in general, and on the (de facto) standard (model-theoretic) account of refinement in this paradigm, in particular. This account is based on a distinct lifted-totalisation semantics which manifests itself in the strictness it imposes, on all the initial values outside the precondition of the underlying operation, with respect to the distinguished value ⊥. We will begin to expound, fundamentally, the cru- cialness of this setting, in obtaining an acceptable model-theoretic notion of ﬁring conditions refinement, and the critical role that the ⊥ values play within it. Indeed, we shall see that the mathematical role of ⊥ in this paradigm is entirely different to that of ⊥ in the chaotic paradigm.
We begin our pursuit by revising various concepts related to the partial relation semantics of Z and to refinement of specifications in view of this se- mantics (section 2). We then proceed with the definition of the two basic theories of operation-refinement, each of which captures a particular aspect of ﬁring conditions refinement (section 3). These are: a theory capturing the properties expected in a refinement in an apparent mathematical manner (section 3.1) - this is a purely proof-theoretic notion that is used as our bench- mark for determining the validity of any other notion of operation-refinement in the abortive paradigm; and a theory capturing the standard model-theoretic account, in this paradigm, which is based on the abortive-lifted-totalisation semantics (section 3.2). We then prove that these two theories of refinement are equivalent (section 4). In section 5, we summarise our observations from the comparison between the theories; in particular, we emphasise the critical role of the ⊥ values, as well as the unique manner in which they interact with the completion, in substantiating the equivalence results in section 4. We then link these observations to the particular role that each of the possible extreme speciﬁcations in Z plays in the abortive paradigm; not only is this analysis very revealing, but it also paves the way for our future work in generalising this to a more intricate investigation of data-reﬁnement in the abortive paradigm. Finally, in section 6, we provide a detailed account of additional interesting future work which would investigate some generalisations of Miarka’s (et al.) framework [32] for combining the two abortive and chaotic paradigms for re- finement. We revise this framework, emphasise the role of ⊥ within it and discuss (in view of our current and previous analyses) whether a supplemen-


tary semantic element, that is distinct from ⊥, would be crucial for capturing model-theoretic characterisations of operation-reﬁnement and data-reﬁnement within it.
Such an investigation becomes possible in virtue of ZC , the logic for Z reported in e.g. [25], and a simple conservative extension Z⊥, reported in
e.g. [16], which incorporates ⊥ terms into the types of ZC . We summarise
this, and additional notational conventions, in appendix A. 4 We employ a
novel technique of rendering all the theories of refinement in a proof-theoretic form: as sets of introduction and elimination rules. This leads to a uniform and simple method for proving the various results in the sequel. As such, it contrasts with the more semantic-based techniques employed in [9].

The Partial Relation Semantics of Z
In this first section we will lay the basic mathematical and conceptual scenes which underlie our investigation. In the process, we will revise a little Z logic, settling some notational conventions; additional detail can be found in appendix A.
Schemas
The schema notation constitutes the most recognisable feature of Z (partly due to its semi-graphical form) and it, indeed, occupies a central place within the language as a means of structuring not only the mathematical text, that is used for describing rigorously properties of the system, but also the entire system itself.
In [25], Z schemas, and operation schemas in particular, were formalised as sets of bindings. This captures the informal account to be found in the literature (e.g. [19], [40]), where an operation schema may be understood as a relation between states: a transition relation from an unprimed state, denoting the state “before” the operation, to a primed state, denoting the state “after” the operation. In this paper, we will use the meta-variable U (with decorations) to range over operation schemas. As an example, consider the operation schema (written horizontally) specifying the predecessor operation:
Pred =^ [ x, x' : N | x > 0 ∧ x' = x − 1 ]
Pred has the type P[x : N, x' : N], and is understood to be a set of bindings of schema type [x : N, x : N]. The bindings ⟨| x $n, x $m |⟩, where n > 0,

4 This is included for convenience only and the reader may wish to consult [25], [28] and
[16] for further detail concerning our notational and meta-notational conventions.


are all elements of Pred . In fact, there are no other elements in this case. Recall that unprimed labels (such as x) are understood to be observations of
the state before the operation takes place, whereas primed labels (such as x )
are observations of the state afterwards. Each operation schema U will have a
type of the form P T , where T is a schema type. The type T can, additionally, always be partitioned as the (compatible) union of its input (or before) type
Tin, and its output (or after) type T out' . That is, T =	Tin Y T out' . For the
'
schema Pred , we have Tin =	[x : N] and T out =	[ ' : N]. In this paper,
since we are only dealing with operation-refinement, we can assume that all
'
operation schemas have the type P T where T =df Tin Y T out . With this in
place, we can omit the type superscripts in most places in the sequel.

Preconditions
Z takes the logical (i.e. “postcondition only”) approach to pre and postcondi- tions [33,39,38,22]. That is, being a single-predicate framework, preconditions in Z are implicit and may be calculated by existential closure of the defining predicate with respect to all its after observations.
We can formalise the idea of the precondition of an operation schema (domain of the relation, between before and after states, the schema denotes) to express the partiality involved:
Definition 2.1 Let Tin ≤ V .	Pre U x V =	∃ z ∈ U • x =. z
Notice that if V is precisely Tin , the definition above amounts to no more than:
∃ z • x * z ' ∈ U
This facilitates the analysis significantly when reasoning about the precondition- status 5 of before-state variables (as opposed to variables ranging over a larger schema type).
The following introduction and elimination rules are immediately derivable for preconditions: 6
Proposition 2.2

t0 ∈ U	t0 =. Pre U t1
t1 (P ve+)
Pre U t	y ∈ U , y =.
P
t ▶ P

(P ve−)



5 Whether or not the variable is in the precondition of the specification in question.
6 For later convenience, the notion of precondition is introduced as a predicate. In ver- nacular Z, the precondition constitutes a state schema comprised of all the valid before- states (bindings) of the operation in question. This is easily captured when necessary as:
{z Tin | Pre U z }.

The usual sideconditions apply to the eigenvariable y. 
Clearly, the precondition of Pred is not (and for operation schemas in general, will not be) the whole of [x : N] (in general, Tin). In this sense, operation schemas denote partial relations. Indeed, Pred is a partial operation
because it ranges over all natural numbers (its before-type) but is defined for only those natural numbers that are greater than zero (its domain); that is, it does not specify the behaviour:
⟨| x$0, x'$m |⟩
for any m ∈ N. More precisely, it is silent with regards to the outcome of the operation when it is applied outside its precondition.
What Happens Outside the Preconditions?
The above raises an immediate question: what behaviour is permitted for a correct implementation of a (partial) specification (of an operation) outside its precondition? To answer this question we need a theory of reﬁnement: a means of comparing such an implementation with such a specification. The general answer to this question is based on total correctness refinement. That is, refinement is based on a subsequent total relation semantics, known as the lifted-totalisation. This interpretation serves as the semantic basis for refinement in Z. It is modelled by, first, extending (i.e. lifting ) the source set and co-domain of the operation in question with a distinguished (semantic) element (often referred to as “bottom”) ⊥, which represents some unwelcome behaviour, and then totalising the operation in a certain way with which the distinguished elements interact in a certain way.
In the world of state-based specifications, there are two well-known fun- damentally different paradigms for refinement of partial specifications, where each of these paradigms induces a distinct lifted-totalisation semantics under- lying refinement. This leads to two different concepts of refinement, each of which is based on a different answer to the question above. First is the chaotic paradigm, sometimes also known as the contractual approach [32] [10, ch.2-3]; this represents a more sequential view and, thus, underlies the standard inter- pretation of refinement in Z. In this paradigm, preconditions are considered as minimal conditions for establishing the postconditions (i.e. they may be weakened in a refinement process), therefore the answer to the above ques- tion is: anything can happen outside the precondition of the operation. That is, the operation behaves as specified when it is applied within its precondi- tion and may establish any arbitrary outcome, including unwelcome behaviour, when applied outside its precondition; this is often referred to as “divergence”


[36,32]. In previous work (cited in section 1) we examined thoroughly mod- els of operation-refinement and data-refinement in this paradigm, where our mathematical foundation enabled us to surgically scrutinise these models in a manner that would not be possible otherwise. Indeed, we resolved various difficulties many informal and semi-formal accounts ran into in an attempt to determine the essence of the chaotic-lifted-totalisation semantics, in general, and the role of the ⊥ elements, in particular, in model-theoretic refinement.
The second paradigm for refinement is the abortive one, sometimes also known as the behavioural [10] or blocking [32] approach (in [21], this is, ef- fectively, what Grundy denotes as the partial model ); this represents a more concurrent view: it is reminiscent of the notion of “refusals” or “deadlock” in process algebras and, therefore, it is typically employed when state-based for- malisms are combined with process algebras (e.g. [20], [4] and [10, ch.18-19]). In this paradigm, preconditions are considered as guards [32,10] or ﬁring con- ditions [31,36] (i.e. they are trigger/fixed conditions - not to be weakened in a reﬁnement process) 7 , therefore the answer to the above question is: nothing can happen outside the precondition of the operation. More precisely, when applied within its precondition, the operation behaves as specified and it is blocked outside its precondition: it may not be applied outside its precondition and if it is, it will result solely in an unwelcome behaviour.
The bulk of this paper is devoted to the investigation of the basic no- tions of operation-refinement in the abortive paradigm. This rather simplified framework enables us to abstract from the complications arising when data simulations are involved and, thus, to, at least, begin to reason about the mathematical role of the ⊥ values in this paradigm (and in comparison to their role in the chaotic paradigm).

A Basic Analysis of Refinement
Naturally, the partial relation semantics of operation schemas in Z raises an immediate question: what does it mean for one operation schema to refine another in the abortive paradigm? More generally, we are asking: what does it mean for one partial relation to refine another in this paradigm?
We begin our analysis by introducing two distinct notions of operation- refinement based on two distinct answers to the questions above. We, then, proceed with an analysis, of the relationships amongst these, which throws a new light on both of them but, in particular, on the standard (model-theoretic)

7 Naturally, they are not to be strengthened either, in order not to violate the principles of refinement (see e.g. [9], [10], [16] and [13]); hence they, effectively, remain ﬁxed in the process of refinement.

notion in this paradigm, based on the abortive-lifted-totalisation semantics.
SP-Reﬁnement
Our first theory is SP-refinement, the normative theory of operation-refinement in the abortive paradigm. SP-refinement is a purely proof-theoretic charac- terisation which serves as a benchmark for determining the validity of any of the other notions of operation-refinement in this paradigm.
This notion is based on three basic properties one expects in a ﬁring con- ditions refinement: firstly, that a refinement guarantees that preconditions do not strengthen; secondly, that a refinement guarantees that postconditions do not weaken; and, finally, that a refinement guarantees that preconditions do not weaken. Notice that the first two properties are standard in a refinement, thus SP-refinement may involve the reduction of nondeterminism (and, hence, it is, indeed, a special case of S-refinement, the normative characterisation of operation-refinement in the chaotic paradigm - see e.g. section 3.2 of [16] for its definition); however, the first and the last properties impose stability of the domain of the definition (i.e. the precondition) throughout the refinement pro- cess (hence “SP”-refinement). SP-refinement can be captured by forcing the refinement relation to hold exactly when these conditions apply. It is written U0 ±sp U1 and is given by the following ZC definition:
Definition 3.1
U0 ±sp U1 =df (∀ z • Pre U1 z ⇒ Pre U0 z ) ∧
(∀ z0, z1 • z0 * z ' ∈ U0 ⇒ z0 * z ' ∈ U1)
1	1
The following introduction and elimination rules are derivable for SP-refinement:

Proposition 3.2 Let z , z0, z1 be fresh variables.
Pre U1 z ▶ Pre U0 z	z0 * z ' ∈ U0 ▶ z0 * z ' ∈ U1	+

1
U0 ±sp U1
sp)

U0 ±sp
U1	Pre U1 t	−
(
U0 ±sp
U1	t0 * t ' ∈ U0
(±	)

Pre U0 t
±sp0 )
t0 * t ' ∈ U1
sp1


Notice that, in contrast to S-refinement, the conjunct Pre U1 z0 is absent from the antecedent of the postcondition premise in the introduction rule for SP-refinement (±+ ). This conjunct is precisely what distinguishes between



Fig. 1. An example: the abortive-lifted-totalisation of the predecessor operation.
S-refinement and SP-refinement: the two premises of (±+ ) together guar- antee that the precondition remains ﬁxed in the course of refinement. As a result, the two elimination rules above establish necessary conditions for refine- ment which are distinct from the ones for S-refinement: akin to S-refinement,
—
(±sp0 ) guarantees that preconditions do not strengthen, yet, as opposed to
—
S-refinement, (±sp1 ) guarantees that both postconditions and preconditions
do not weaken. This proof-theoretic representation enables us to take SP-
refinement as the normative characterisation of operation-refinement in the abortive paradigm: this is our prescription for refinement, and another theory is acceptable providing it is at least sound with respect to SP-refinement since (as we shall see in section 4) soundness necessarily means that it must satisfy the two necessary conditions for SP-refinement above; 8 completeness, on the other hand, means that the other theory sanctions at least what SP-refinement does, namely strengthening of postconditions.
W -Reﬁnement
In this section, we provide the formal technical development underlying the (de facto) standard (model-theoretic) notion of operation-refinement in the abortive paradigm. Akin to all our model-based theories, this takes place within our extended theory of Z⊥.
We begin by expressing, in our mathematical framework, the intentions be-
hind the abortive-lifted-totalisation semantics discussed in the literature (e.g. [4], [10, ch.3] and [3]). An example of applying this semantics to the operation
 
Pred (written Pred in our nomenclature) is depicted in Fig. 1. Recall (from e.g. [16]) that the chaotic-lifted-totalisation semantics makes no distinction between arbitrary and unwelcome behaviour resulting from applying an oper- ation outside its precondition: anything may happen outside the precondition of the operation; this may include unwelcome behaviour as well as a possible

8 This measurement of validity manifests itself more considerably in the generalisations to data-refinement (see e.g. [11]).


“divergence” of results. In the abortive paradigm, however, there is no such latitude: an operation is blocked outside its precondition; hence the “block” notation, used to denote the abortive-lifted-totalisation of a set of bindings, in the following definition: 9

 
Definition 3.3 U
=df
{z0
* z ' ∈ T٨ | z0
* z ' ∈ U ∨ (¬ Pre U z0
∧ z ' =⊥')}

Notice the way this definition explicitly deploys the ⊥ value in order to capture the blocking interpretation. This suggests (though, at this stage, fairly superficially) that the mathematical role of ⊥ in this paradigm is different to that of ⊥ in the chaotic paradigm; indeed, Boiten and de Roever [3] refer to
⊥, in this context, as the element representing “deadlock”. We will discuss this issue in further detail, following the rest of our analysis, in section 5.
The following introduction and elimination rules are derivable for abortive- lifted-totalised sets:
Proposition 3.4

 t0 * t ' ∈ U
(  )
 t0 * t ' ∈ T٨	¬ Pre U t0	t ' =⊥'
(  )

t * t ' ∈	0	t * t ' ∈	1

0	1	U
'		'
0	1	U
'	'
t * t ' ∈ 

t0 * t1 ∈ U	t0 * t1 ∈ U ▶ P	¬ Pre U t0, t1 =⊥ ▶ P ( −
 0	1	U  ( −)

P	 )
t0 * t ' ∈ T٨	1

The following additional rules are derivable for abortive-lifted-totalised sets:
Lemma 3.5

(i)
(ii)
¬ Pre U t	t ∈ Tin
 
(iii)

U ⊆ U
⊥∈ U
t * ⊥'∈ U

t * t ' ∈	Pre U t
t * t ' ∈	t ' /=⊥'

 0	1		U	0 (iv) t0 * t ' ∈ U
 0	1	U	1	 (v)
t0 * t ' ∈ U

'	t0 * t ' ∈ T٨	Pre U t0 ∨ t ' /=⊥' ▶ t0 * t ' ∈ U

t0 * t1 ∈ U	t0 =⊥
	1	1	1	 (vii)

t ' =⊥'	(vi)
t * t ' ∈ 

1	0	1	U
9 For notational convenience, we write T ٨ for the set T in  T out' (note the use of  for
⊥	⊥
sets, as opposed to Y used for types).


Lemmas 3.5(i) to (vi) show that definition 3.3 is consistent with the inten- tions described in the literature (embodied in Fig. 1): (i) to (iv) demonstrate that the abortive completion is contained in the chaotic completion (written
•
U in our nomenclature - see e.g. section 3.3 of [16] for its definition), the
distinguished value is present in the completion and everything outside the precondition is mapped onto it, where all the states in the underlying rela- tion remain unchanged in the completion; (v) and (vi) together express the strictness, of all the initial values outside the precondition of the underly- ing relation, with respect to ⊥ in the completion. Additionally, note that definition 3.3 may be expressed using implication (in the obvious way) in- stead of disjunction: lemma 3.5(vii) constitutes the introduction rule, for the abortive-lifted-totalisation, based on implication introduction.
With this in place, we can easily define the standard notion of refinement in the abortive paradigm. We name this W -reﬁnement; it is written U0 ±w U1 and is defined as follows:


Definition 3.6 U0 ±w  U1 =df
U0 ⊆ U1

Obvious introduction and elimination rules follow from this definition.

Two Equivalent Theories
In this section, we shall demonstrate that our two theories of refinement are equivalent. This analysis will aid us to begin to shed some light on the math- ematical and conceptual roles that the ⊥ values play, in model-theoretic re- finement, in the abortive paradigm.
Methodologically, we shall be showing that all judgements of refinement in one theory are contained among the refinements sanctioned by another. Such results can always be established proof-theoretically because we have expressed even our model-theoretic approach as a theory (set of introduction and elimination rules). Specifically, we will show that the refinement relation of a theory T0 satisfies the elimination rule (or rules) for refinement of another theory T1. Since the elimination rules and introduction rules of a theory enjoy the usual symmetry properties, this is sufficient to show that all T0-refinements are also T1-refinements. Equivalence can then be shown by interchanging the roles of T0 and T1 in the above.
We begin by showing that W -refinement satisfies the two SP-refinement elimination rules. Firstly, the rule which guarantees non-augmentation of undefinedness.
Proposition 4.1 The following rule is derivable:





Proof
U0 ±w U1	Pre U1 t Pre U0 t

δ.

.	t ⊥'∈ U
'
(2)
(L. B.4)


Pre U1 t ¬ Pre U1 t
(2)

t ⊥ ∈ U1
false
false
false
(2)

Pre U0
Where δ stands for the following branch:
t (1)






Pre U1 t



'	(3)
t  y ∈ U1

t  y ' ∈ T
t ∈ T in t ∈ T in

¬ Pre U0
t (1)
t ∈ T in
(3)
(L. 3.5(iii))

U0 ±w  U1
'
t ⊥'∈ U

t ⊥ ∈ U1

Turning now to the SP-elimination rule which guarantees non-augmentation
of both definedness and nondeterminism.
Proposition 4.2 The following rule is derivable:
'
U0 ±w  U1	t0 * t ∈ U0


Proof


t0 * t ' ∈ U1




'	'	'
' (1)

 t0  t1 ∈ U0 
 
t0  t1 ∈ U0 t1 =⊥ 
t  ⊥'∈ U

U0 ±w  U1
t0  t ' ∈ U
'	 

'	(1)
0
false
'
0 (L. B.4)

t0  t1 ∈ U1	t0  t1 ∈ U1	t0  t1 ∈ U1 (1)
t0  t ' ∈ U1

The following theorem is then immediately derivable by propositions 4.1
and 4.2, in addition to the rule (±+ ): 10

10 The proofs of such theorems are always automatic by the structural symmetry between introduction and elimination rules. We shall, therefore, not provide them explicitly.



Theorem 4.3


 

U0 ±w U1 U0 ±sp U1

We now show that SP-refinement satisfies the W -elimination rule.
Proposition 4.4 The following rule is derivable:


U0 ±sp
 
U1	t0 * t ' ∈ U0
 


Proof
t0 * t ' ∈ U1

U ±  U	t  t ' ∈ U
(1)
δ.

t  t ' ∈ U	.
 0	1	1 	.
'	'	'
t0  t1 ∈ U0	t0  t1 ∈ U1	t0  t1 ∈ U1  (1)
'
t0  t1 ∈ U1
Where δ stands for the following branch:


'	U ±  U	¬ Pre U t
(1)

t0  t1 ∈ U0 	0  sp  1	0 0
(1)


t  t ' ∈ T s
¬ Pre U
'
1 t0
 
t ' =⊥'

t0  t1 ∈ U1

Then the following theorem immediately follows, by (±+ ), from proposi-

tion 4.4:
Theorem 4.5


 



U0 ±sp U1 U0 ±w  U1

Together, theorems 4.3 and 4.5 establish that the theories of SP-refinement and W -refinement are equivalent. Notice that, unlike the chaotic paradigm counterpart results (substantiating equivalence between W•-refinement 11 and
S-refinement - see e.g. section 4.2 of [16]) where the explicit use of ⊥ is crucial
only for guaranteeing that preconditions do not strengthen, the explicit use of
⊥ here is crucial for establishing all three results: the two results (propositions 4.1 and 4.2) underlying the soundness theorem 4.3 and the result (proposition

11 W•-refinement, in our nomenclature, is the (de facto) standard (model-theoretic) notion of operation-refinement in the chaotic paradigm - see e.g. section 3.3 of [16] for its definition.


4.4) underlying the completeness theorem 4.5. We will further elaborate on this observation in the next section.

Discussion
In this paper, we have conducted a foremost foundational analysis of operation- refinement in the abortive paradigm. We have developed two theories of refine- ment, each of which constitutes a specialisation, of the corresponding theory in the chaotic paradigm (see e.g. section 3 of [16]), which adheres to the con- cept of ﬁring conditions refinement. The standard account in this paradigm is a model-theoretic one; it is based on a particular notion of lifted-totalisation, in which all the initial values outside the precondition of the underlying op- eration are strict with respect to the distinguished value ⊥ in the completion. SP-refinement belongs to our proof-theoretic family of refinement theories. Again, it serves as the normative characterisation of operation-refinement in the abortive paradigm because it captures the intentions behind ﬁring con- ditions refinement in an apparent mathematical manner and directly, within the language, in terms of the predicates involved: it does not involve the introduction of an auxiliary semantics, nor the introduction of auxiliary ele- ments. We have demonstrated that, by establishing this approach as a theory (rather than suﬃcient conditions), we can attain an equivalent framework in which the model extensions with auxiliary semantic elements are unnecessary for formalising the concept of ﬁring conditions refinement. Once again, we have demonstrated that what look like different models of specification and refinement are, in fact, intimately related.
However, being confined to only operation-refinement, this analysis aids us to only begin to explain some of the mathematical reasons why the abortive- lifted-totalisation, underlying the standard characterisation of refinement in this paradigm, has been defined in just the way it has (i.e. insisting on strict- ness with respect to the distinguished value ⊥), and what the mathematical role of the ⊥ values, in the context of ﬁring conditions refinement, is. Indeed, conceptually, akin to the chaotic paradigm, ⊥ here represents some unwel- come behaviour, but its mathematical role is, evidently, different to that in the chaotic paradigm. This difference manifests itself precisely in the proofs of propositions 4.1, 4.2 and 4.4: it is clear that the accomplishment of all these proofs is critically contingent not only on the explicit use of the ⊥ value, but also on the strictness, of all the initial values outside the precondition, with respect to it; recall that, in contrast to that, the explicit use of ⊥ in the chaotic paradigm is crucial only for substantiating that the standard account of refine- ment guarantees that preconditions do not strengthen (see e.g. proposition 4.11


of [16]). This suggests that the distinguished values, in this paradigm, and the way they interact with the completion (and vice versa) are absolutely vital for capturing correctly the guarded interpretation underlying model-theoretic refinement, and there seems to be no other way to model refusals in relational completion (i.e. without utilising ⊥ values). 12
As usual, we can emphasise this point (or at least begin to emphasise it) by considering the idea of extreme speciﬁcations in the abortive paradigm. 13 Akin to the chaotic paradigm, the specification True denotes explicit permis- sion to behave. The only sanctioned property in a ﬁring conditions refinement is reduction of nondeterminism; hence, since True is the most nondetermin- istic specification, any specification which reduces this behaviour constitutes its refinement. Now recall that True is a total specification. A mathematical fact is that all the relational completion models at our disposal underlie equiv- alent theories of reﬁnement when the underlying speciﬁcations are total. The proof of this is very simple: we established, in section 6 of [16], that the strict and non-strict-chaotic-lifted-totalisation models underlie equivalent theories of refinement; 14 moreover, it is evident that the strict-chaotic-lifted-totalisation and the abortive-lifted-totalisation models are equivalent when the underlying specifications are total, in which case refinement in both paradigms amounts to a ﬁring conditions refinement so as to prevent augmentation of undeﬁnedness.
The specification Chaos, however, denotes something completely different in the abortive paradigm. Recall that, in the chaotic paradigm, Chaos denotes implicit permission to behave and, as a result, any specification refines it (see e.g. section 4.4 of [16]). This, of course, coincides with the fact that, in that paradigm, anything can happen outside the precondition of any operation. In the abortive paradigm, on the other hand, any operation aborts outside its precondition, blocking any possibility of recovery from this outcome in the context of refinement (as we have seen in section 4, this setting seems inevitable in order to obtain an acceptable model-theoretic notion of ﬁring conditions refinement). Now since everything is outside the precondition of

12 This is in contrast to the chaotic paradigm, in which we established a model-theoretic characterisation of operation-refinement based on a relational completion model that is totalised, but not lifted ; we proved that this characterisation captures the (necessary and sanctioned) properties expected in a refinement in that paradigm. Notwithstanding, there is a price for this formulation, namely the necessity of relying on an alternative interpretation of the concept of preconditions (for further detail, see section 5 of [16]).
13 See appendix A for the definitions of the two extreme specifications True and Chaos in
our nomenclature (definition A.4).
14 The strict-chaotic-lifted-totalisation semantics in ibid. captures (in our mathematical framework) the informal intentions described in [7]: divergence outside the precondition of the underlying relation and strictness for ⊥ (i.e. ⊥ in the source set maps only to its co-domain counterpart).



Fig. 2. An illustration: the specification Chaos represents implicit deadlock in the abortive paradigm.

Chaos, it implicitly denotes here a situation in which everything is blocked, namely implicit deadlock ; this situation is defined by, for example, Roscoe [35, ch.0] as follows: “a concurrent system is deadlocked if no component can make any progress...”. Indeed, in a ﬁring conditions refinement Chaos cannot refine anything (which is, of course, natural in order to prevent preconditions from strengthening ) but, actually, nothing can refine it either in this regime.
 
We, therefore, refer to abortive-lifted-totalised Chaos (i.e. Chaos ) as Deadlock , from which no recovery is possible; this is illustrated in Fig. 2.
In [3], Boiten and de Roever refer to ⊥ (in the context of the abortive paradigm) as the element representing “deadlock”. We, for reasons discussed earlier, prefer to follow the lines of the concurrent formalisms’ literature (e.g. [35]) and refer to the situation (i.e. the lifted-totalised specification) as Deadlock and to ⊥, which evidently has a crucial role in preventing non-strict recovery from this situation, as the abortive element. In this way, we still manifest the intuitions discussed in [3], in this context. Indeed, we will, in future work - in the generalisations to simulation-based data-reﬁnement - reinforce our con- clusions (and terminology) regarding the role of ⊥ in the abortive paradigm, as well as the significance of the strictness of both completions of the oper- ations and the lifting of data simulations in obtaining a valid forward sim- ulation and a useful backward simulation model-theoretic characterisations of ﬁring conditions refinement. Akin to the analysis of data-refinement in the chaotic paradigm (e.g. [13,15,12]), we will uncover many issues, concern- ing data-refinement in the abortive paradigm, when non-trivial data simula- tions are permitted. A particularly interesting revelation is the fact that the abortive-lifted-totalisation semantics can underlie the standard notion of for- ward simulation reﬁnement in both the chaotic and the abortive paradigms, where the actual paradigm depends solely on the way in which the data sim- ulations are lifted. 15

15 The bulk of this analysis is reported in [11].

Future and Related Work: Generalisations of Miarka, Boiten and Derrick’s Framework for Combining the Abortive and Chaotic Paradigms for Refinement
Intentions, Intuitions and Motivations
In [32], Miarka et al. develop a framework which combines the two abortive and chaotic paradigms for refinement. This framework allows the represen- tation of both refusals and underspecification in the same account. The authors’ motivation lies in the fact that the two paradigms are neither ex- clusive 16 nor mutually exclusive. They begin with a simple, yet very tan- gible example which illustrates this point. The example is given by means of a Z specification modelling a simple money transaction system: Bank is a state schema which specifies a repository of bank accounts by means of a partial function between (unique) account numbers and integer numbers, each of which represents the balance of the account it is devoted to. Transfer is an operation schema on Bank which effectively specifies an increase of the bal- ance of a given account by a given value; the precondition of Trasfer comprises two predicates: one guarantees that the given account exists in the repository and the other guarantees that the given value (to be added to the balance) is not negative, so that no money can be withdrawn as a consequence of this operation. They then demonstrate that non of the chaotic and abortive char- acterisations provides an adequate solution of (operation-) refinement for this system. Refinement in the chaotic paradigm is too permissive: it enables a sensible approach of extending the repository with a new bank account (whose balance is the given value), in case the given account number does not exist in the repository; however, it also allows the dangerous case of money withdrawal (both of these cases constitute a natural consequence of weakening the pre- condition). Conversely, refinement in the abortive paradigm is too restrictive: it prevents the dangerous case of money withdrawal, but it also prevents the sensible case of extending the repository with a new account.
The reason why non of these paradigms provides a satisfactory solution for refining this operation is that, apparently, the two predicates in its pre- condition have different roles: the one insisting that the added value is not negative is more like a guard, whereas the one insisting that the given account already exists is more like a precondition. Indeed, the authors’ solution is based on combining the two paradigms for refinement and it revolves around the idea of essentially separating the predicates which form the guard, of a

16 Indeed, we presented in [18] another characterisation of refinement (SC-refinement) in which preconditions may weaken, but postconditions remain ﬁxed.



Fig. 3. The possible regions of operation behaviour in the combined paradigm for refinement.

certain operation schema, from those which form the precondition. In this way, they enable both guards and preconditions in the same speciﬁcation. By and large, in this framework, an operation outside its guard behaves like in the abortive paradigm: it is blocked, regardless of whether or not its precondi- tion holds; whereas inside its guard, the operation behaves like in the chaotic paradigm: the outcome depends on whether or not the precondition holds (as usual, anything can happen outside the precondition). The way in which they implement this idea is by viewing an operation schema as being comprised of a brace of schemas: the first is the “enabled” schema which denotes the guard, whereas the second is the “effect” schema which denotes the actual operation; this is an operation schema in the usual sense (i.e. its precondition may be calculated as usual). It is important to note that this is merely a cosmetic way of separating the guard explicitly from the predicate of the operation schema: naturally, the signature of the “enabled” schema is either identical to, or contained in, the signature of the “effect” schema; thus when required in a schema expression, the operation is taken as simply the conjunction of these two schemas. In this way, no changes are required for the schema cal- culus operations. Having said that, notwithstanding, an operation is given a non-standard interpretation, based on three-valued logic, which explicitly gives manifestation to three regions of operation behaviour delineated in Fig. 3: the operation is deﬁned when both the guard and the precondition hold (this re- gion is represented by true); the operation is impossible (i.e. blocked ) when the guard does not hold (this region is represented by false); the operation is undeﬁned when the guard holds, but the precondition does not hold (this is a “don’t care” situation in which anything can happen, thus it is represented by the third logical value which precisely embodies this interpretation).
The authors then define a characterisation of (sufficient conditions for) operation-refinement, in accordance with these three regions, whereby post- conditions may strengthen, preconditions may weaken and the guard may strengthen. Having said that, it is important to note that “the precondition is the upper bound for strengthening the guard and the guard is the lower


bound for weakening the precondition” [32]. Put another way: going back to Fig. 3, the deﬁned region may be enlarged, but not beyond the impossible region’s boundaries; likewise, the impossible region may be enlarged, but not beyond the deﬁned region’s boundaries.
It would be very interesting to capture these ideas in our mathematical framework. Such an extension of the mathematical apparatus for refinement would emphasise three salient issues. We discuss these, in detail, in the re- maining sub-sections.

Proof-Theoretic Operation-Reﬁnement
Firstly, the three-valued logic interpretation of operations does not seem to be entirely crucial for capturing the intentions from [32] in the form of a proof- theoretic characterisation of refinement in our usual setting based on classical logic. The key issue here is, of course, capturing adequately the concept of sep- aration between preconditions and guards. Aside from the approach suggested in [32], there are two alternative interesting ways of capturing this concept. One way is to have an operation schema defined with two predicates: one constituting the guard and the other constituting the (usual) Z postcondition; in a sense, this approach is reminiscent of the one taken in [32], only that this would require some changes to be made in the definitions of the schema cal- culus operations. Another way is to generalise the approach taken in [26,27], where the pre and postconditions are syntactically separated, by adding a third predicate for the guard. Either way, it would be very interesting to examine the ramifications of these approaches.
Model-Theoretic Operation-Reﬁnement
The second issue (which was not covered in [32]) concerns model-theoretic refinement. Our conjecture (based on the experience we acquired through the entire project investigating foundational issues in refinement - pursued over the last four years) is that W -refinement, that is a model-theoretic notion based on a lifted-totalisation semantics delineated in Fig. 4, would also capture the intentions from [32]. This combined -lifted-totalisation semantics is based on an additional semantic element “top” T (see e.g. [29, ch.2]) we require in the completion. Consider, for example, the combined-lifted-totalisation of
 
the abstract specification U1 (written U1 ) in Fig. 4; this precisely adheres to the three possible regions of operation behaviour illustrated in Fig. 3: the before-state x is in both the guard and the precondition of the underlying operation and, thus, the two states forking from it belong to the deﬁned region of the operation; y is in the guard but outside the precondition, thus all the


 	
Fig. 4. A conjecture: W -refinement is based on a lifted-totalisation semantics that captures the intentions depicted in [32].
states forking from it belong to the undeﬁned region - anything is possible including ⊥ and T; z and w are both outside the guard and, thus, belong to the impossible region - the operation is blocked, regardless of whether or not any of these before-states is in the precondition. As we can see in Fig. 4, it seems that the subset relation (in conjunction with this notion of lifted-totalisation) guarantees precisely the properties addressed in [32]: that postconditions can
 

only strengthen (see x in
 
U0 ), that preconditions can only weaken (see y
 

in U0 ) and that guards may not weaken (see z and w in U0 ). Moreover,
the fact that anything within the guard but outside the precondition maps to
anything, including ⊥, enables strengthening of the guard within the undeﬁned
 
region: had y in U0 been mapped onto only ⊥, as a result of strengthening the guard, the subset relation would have still held. It would be very interesting to examine mathematically this conjecture, as well as the monotonicity properties of this notion.
Generalisations to Data-Reﬁnement
Finally, the generalisations to data-reﬁnement. Prima facie, one might argue that the top element T is not particularly crucial for establishing a combined- lifted-totalisation semantics, underlying W -refinement, which would capture the intentions depicted in Fig. 4. This is, indeed, the case for operation- reﬁnement: one might use the same model as in Fig. 4, but with T (and any of its interactions with the completion) excluded, without loss of any gener- ality discussed earlier. Nonetheless, our point of departure here is influenced by a broader perspective acquired from our investigation of data-refinement (some of which is reported in earlier work and some of which will be reported in future work). Recall (from e.g. [13] and [11]) that the way in which data simulations interact with the standard notion of refinement in each paradigm


is by means of lifting. 17 In the chaotic paradigm, simulations are non-strictly- lifted, whereas in the abortive paradigm, they are strictly-lifted. The use of non-standard lifting of simulations has consequences which either restrict or invalidate the notion of refinement expected in each of the two paradigms. Now, for the sake of argument, consider the combined-lifted-totalisation with- out the top element T. Let us examine the consequences of using a non- standard lifting of simulations in each paradigm; we can, thus, demonstrate that a single semantic element is (generally) insufficient for capturing ade- quately the intentions we discussed earlier, in the context of data-refinement:
	Forward Simulation. The use of strictly-lifted simulations in the chaotic paradigm prevents weakening of preconditions [13], whereas the use of non-strictly-lifted simulations in the abortive paradigm per- mits weakening of preconditions [11]; in which case, weakening of guards would be permitted in our combined model for reﬁnement. Hence, non of these settings is adequate for forward simulation refinement in the com- bined paradigm;
	Backward Simulation. The use of strictly-lifted simulations in the chaotic paradigm induces a theory of reﬁnement that is equivalent to the standard one [15,12], whereas the use of non-strictly-lifted simula- tions in the abortive paradigm prevents strengthening of postconditions [11]. Hence, the former setting might be adequate for backward simula- tion refinement in the combined paradigm, but the latter is not sufficiently general.
In conclusion, it is evident that, in the context of forward simulation, the only way to explicitly distinguish the undeﬁned region of an operation from its impossible region, so as to obtain an adequate model-based theory of forward simulation reﬁnement in the combined paradigm, is by means of employing an additional semantic element distinct from ⊥. In which case, the notion of lifting of data simulations would have to apply for both semantic elements; the optimal setting in this case seems to be strict-lifting with respect to ⊥ and non-strict-lifting with respect to T. On the other hand, it seems that, in order to obtain an adequate model-based theory of backward simulation reﬁnement in this paradigm, ⊥ on its own is sufficient providing that simulations are strictly-lifted.
Indeed, all the intuitions above are based on our existing mathematical analysis of data-refinement and, therefore, they would certainly provide a good

17 Lifting signifies mapping ⊥ of the source set of the relation onto all the states in its co-domain. In general, the notion of strictness discussed in this paper is with respect to ⊥; therefore, strict-lifting denotes mapping ⊥ onto only its co-domain counterpart.


start for future investigation. However, by all means, these would have to be carefully examined mathematically, in the context of the combined paradigm for refinement.

Acknowledgements
This work has been influenced in its development by too many people to name explicitly. However, special thanks for particularly important discus- sions and comments go to Steve Reeves, Ray Turner, Eerke Boiten, John Derrick, Steve Dunne, Neil Evans, Ralph Miarka, Greg Reeve, Steve Schnei- der, David Streader, Helen Treharne and Rob Arthan. Also, many thanks to Jonathan Bowen, John Derrick and Steve Schneider for supporting Moshe’s research proposal to the Royal Academy of Engineering.

References
J. R. Abrial. The B-Book. Cambridge University Press, 1996.
D. Azada and P. Muenchaisri, editors. APSEC 2003: 10th Asia-Paciﬁc Software Engineering Conference, Chiangmai, Thailand, December 10-12, 2003, Proceedings. IEEE Computer Society Press, December 2003.
E. A. Boiten and W. P. de Roever. Getting to the Bottom of Relational Refinement: Relations and Correctness, Partial and Total. In R. Berghammer and B. M¨oller, editors, RelMiCS 7: 7th International Seminar on Relational Methods in Computer Science, Malente, Germany, 12-17 May, 2003, Proceedings, pages 82–88. University of Kiel, 2003.
C. Bolton, J. Davies, and J. C. P. Woodcock. On the Refinement and Simulation of Data Types and Processes. In K. Araki, A. Galloway, and K. Taguchi, editors, Integrated Formal Methods (IFM ’99). Springer, 1999.
J. P. Bowen, S. Dunne, A. Galloway, and S. King, editors. ZB 2000: Formal Speciﬁcation and Development in Z and B, First International Conference of B and Z Users, York, UK, August
29 - September 2, 2000, Proceedings, volume 1878 of Lecture Notes in Computer Science. Springer, 2000.
J. P. Bowen, A. Fett, and M. G. Hinchey, editors. ZUM ’98: The Z Formal Speciﬁcation Notation, 11th International Conference of Z Users, Berlin, Germany, September 24-26, 1998, Proceedings, volume 1493 of Lecture Notes in Computer Science. Springer, 1998.
A. Cavalcanti and J. C. P. Woodcock. A Weakest Precondition Semantics for Z. Technical Monograph PRG-TR-16-97. Oxford University Computing Laboratory, 1997.
D.Bert, J. P. Bowen, S. King, and M. Wald´en, editors. ZB 2003: Formal Speciﬁcation and Development in Z and B, Third International Conference of B and Z Users, Turku, Finland, June 4-6, 2003, Proceedings, volume 2651 of Lecture Notes in Computer Science. Springer, 2003.
W. P. de Roever and K. Engelhardt. Data Reﬁnement: Model-Oriented Proof Methods and Their Comparison. Prentice Hall International, 1998.
J. Derrick and E. A. Boiten. Reﬁnement in Z and Object-Z: Foundations and Advanced Applications. Formal Approaches to Computing and Information Technology – FACIT. Springer, May 2001.


M. Deutsch. Firing Conditions. University of Essex, technical report CSM-386, April 2002.
M. Deutsch and M. C. Henson. An Analysis of Backward Simulation Data-Refinement for Partial Relation Semantics. In APSEC 2003 [2], pages 38–48, 2003.
M. Deutsch and M. C. Henson. An Analysis of Forward Simulation Data Refinement. In ZB 2003 [8], pages 148–167, 2003.
M. Deutsch and M. C. Henson. An analysis of total correctness refinement models for partial relation semantics II. Logic Journal of the IGPL, 11(3):319–352, 2003.
M. Deutsch and M. C. Henson. Four Theories for Backward Simulation Data-Refinement. In
T. Muntean and K. Sere, editors, RCS’03 – 2nd International Workshop on Reﬁnement of Critical Systems: Methods, Tools and Developments, bo Academi, Turku – Finland, June 2003.
M. Deutsch, M. C. Henson, and S. Reeves. An analysis of total correctness refinement models for partial relation semantics I. Logic Journal of the IGPL, 11(3):287–317, 2003.
M. Deutsch, M. C. Henson, and S. Reeves. Modular reasoning in Z: scrutinising monotonicity and refinement. University of Essex, technical report CSM-407 (under consideration of FACJ), December 2003.
M. Deutsch, M. C. Henson, and S. Reeves. Operation Refinement and Monotonicity in the Schema Calculus. In ZB 2003 [8], pages 103–126, 2003.
A. Diller. Z: An Introduction to Formal Methods. J. Wiley and Sons, 2nd edition, 1994.
C. Fischer. How to Combine Z with a Process Algebra. In ZUM ’98 [6], pages 5–23, 1998.
J. Grundy. A Method of Program Reﬁnement. PhD thesis, University of Cambridge, 1993.
I. J. Hayes, C. B. Jones, and J. E. Nicholls. Understanding the differences between VDM and Z. Technical Report UMCS-93-8-1. Department of Computer Science, University of Manchester, August 1993.
M. C. Henson and S. Reeves. Revising Z: I - logic and semantics. Formal Aspects of Computing, 11(4):359–380, 1999.
M. C. Henson and S. Reeves. Revising Z: II - logical development. Formal Aspects of Computing, 11(4):381–401, 1999.
M. C. Henson and S. Reeves. Investigating Z. Logic and Computation, 10(1):43–73, 2000.
M. C. Henson and S. Reeves. Program Development and Specification Refinement in the Schema Calculus. In ZB 2000 [5], pages 344–362, 2000.
M. C. Henson and S. Reeves. A logic for schema-based program development. Formal Aspects of Computing, 15(1):84–99, 2003.
M. C. Henson, S. Reeves, and J. P. Bowen. Z logic and its consequences. Computing and Informatics, 22(4):381–415, 2003.
C.A.R Hoare and J. He. Unifying Theories of Programming. Prentice Hall International, 1998.
C. B. Jones. Systematic Software Development using VDM. Prentice Hall International, 2nd edition, 1990.
M. B. Josephs. Specifying Reactive Systems in Z. Technical Monograph PRG-TR-19-91. Oxford University Computing Laboratory, 1991.
R. Miarka, E. A. Boiten, and J. Derrick. Guards, Preconditions, and Refinement in Z. In ZB 2000 [5], pages 286–303, 2000.
C. C. Morgan. The specification statement. ACM Transactions on Programming Languages and Systems, 10:403–419, 1988.


S. Prehn and W. J. Toetenel, editors. VDM ’91 – Formal Software Development, 4th International Symposium of VDM Europe, Noordwijkerhout, The Netherlands, October 21- 25, 1991, Proceedings, Volume 2: Tutorials, volume 552 of Lecture Notes in Computer Science. Springer-Verlag, 1991.
A. W. Roscoe. The Theory and Practice of Concurrency. Prentice Hall, 1998.
B. Strulo. How Firing Conditions Help Inheritance. In J. P. Bowen and M. G. Hinchey, editors, ZUM ’95: The Z Formal Speciﬁcation Notation, volume 967 of Lecture Notes in Computer Science, pages 264–275. Springer-Verlag, 1995.
I. Toyn, editor. Z Notation: Final Committee Draft, CD 13568.2. Z Standards Panel, 1999.
J. C. P. Woodcock. An Introduction to Refinement in Z. In VDM ’91 (volume 2) [34], pages 96–117, 1991.
J. C. P. Woodcock. The Refinement Calculus. In VDM ’91 (volume 2) [34], pages 80–95, 1991.
J. C. P. Woodcock and J. Davies. Using Z: Speciﬁcation, Reﬁnement and Proof. Prentice Hall, 1996.

Specification Logic - A Synopsis
In this appendix, we will revise the specification logic underlying our investigation, settling our notational conventions in the process. The reader may wish to consult [25], [28] and [16] for a more leisurely treatment of our notational and meta-notational conventions.
Our analysis takes place in the “Church-style” version of the Z-logic due to Henson and Reeves, namely ZC (e.g. [23,24,25]), and a simple conservative extension of that, we name Z⊥ (e.g. [16,17]). This provides a convenient basis, in particular a satisfactory logical account of the schema calculus
of Z, as it is normally understood, upon which the present work can be formalised.
The ZC Speciﬁcation Logic
ZC is a typed theory in which the types of higher-order logic are extended with schema types whose values are unordered, label-indexed tuples called bindings. For example, if the Ti are types and the zi are labels (constants) then:
[··· zi : Ti ·· ·]
is a (schema) type. Values of this type are bindings, of the form:
⟨| · · · zi $ti ··· |⟩
where the term ti has type Ti . Binding selection, written t.x, is axiomatised so that, for example:
⟨| x$2, y$3 |⟩.x =2 
Selection generalises so that t.P denotes the predicate P in which each observation x is replaced by t.x. Filtered bindings play a major role in the schema calculus. Such terms have the form t T T and are axiomatised so that, for example:
⟨| x$2, y$3 |⟩ T [x : N]= ⟨| x$2 |⟩
The symbols ≤, Ω, Y and − denote the schema subtype relation, and the operations of schema type intersection and (compatible) schema type union and schema type subtraction. Every type in ZC has a corresponding carrier set. This is formed by closing the carrier for the type in question
N	18
(e.g. N =df {z  | true}) under the cartesian product, power type and schema type operations.
Therefore, the following axiom is admissible and is, thus, incorporated within the system:
t T ∈ T (T )

18 The notational ambiguity does not introduce a problem since only a set can appear in a
term or proposition and only a type can appear as a superscript.


As we discussed in section 2.1, we let U (with diacriticals when necessary) range over operation schema expressions. These are sets of bindings linking, as usual, before observations with after
observations. We can always write the type of such operation schemas as P(T in Y T out' ) where T in is the type of the “before” sub-binding (state) and T out' is the type of the “after” sub-binding. We also permit binding concatenation, written t0 t1 , when the alphabets of t0 and t1 are disjoint. This is, in fact, exclusively used for partitioning bindings in operation schemas into before and after components, so the terms involved are necessarily disjoint. We lift this operation to sets (of appropriate types), with obvious introduction and elimination rules, by means of:
Definition A.1 C0  C1 =df {z0  z1 | z0 ∈ C0 ∧ z1 ∈ C1}
The same restriction obviously applies here: the types of the sets involved must be disjoint.
In this way, reasoning in Z becomes no more complex than reasoning with binary relations.
We introduce two notational conventions in order to avoid the repeated use of filtering in the context of membership and equality propositions.

Definition A.2 Let T
≤ T .	t T0 . C
P T1 =
df t T T1 ∈ C

Definition A.3 Let T1 ≤ T0 or T0 ≤ T1 .
t T0 .  T1
0 = t1 =df t0 T (T0 Ω T1)= t1 T (T0 Ω T1)
In [25], the authors showed how to extend ZC to the schema calculus. For example:
[S | P ] =df {z T | z ∈ S ∧ z .P }

defines atomic schemas, and:
S P T0 ∨ S P T1 =


{z T0 YT1 | z ∈ S ∨ z ∈ S }

S P T0 ∧ S P T1 =
{z T0 YT1 | z ∈ S ∧ z ∈ S }

respectively define schema disjunction and schema conjunction.
Finally, we need the concept of extreme speciﬁcations. There are only two possible extreme specifications in Z: True (sometimes also known as chance, e.g. [21, ch.3]) which comprises every- thing and Chaos which comprises nothing. We define these in our logical framework as follows:

Definition A.4 (i) True =df [T | true] (ii) Chaos =df [T | false]


The Z⊥
Specification Logic - A Conservative Exten-

sion of ZC
The only modification we need to make in Z⊥ is to include the new distinguished terms which are explicitly needed in the various lifted-totalisation semantics. Specifically: the types of ZC are extended to include terms ⊥T for every type T . There are, additionally, a number of axioms which ensure that all the new ⊥T values interact properly, e.g.

⊥[z0:T0···zn:Tn]= ⟨| z $ ⊥T0 ··· z $ ⊥Tn |⟩

In other words, ⊥[z0:T0···zn:Tn] .z

=⊥Ti (0 ≤ i ≤ n). Note that this is the only axiom concerning

distinguished bindings; hence, binding construction is non-strict with respect to the ⊥T values.
Finally, the extension of Z⊥ which introduces schemas as sets of bindings and the various operators of the schema calculus is undertaken as usual (see e.g. [25]), but the carrier sets of the types must be adjusted to form what we call the natural carrier sets which are those sets of elements of types which explicitly exclude the ⊥T values:
N	N
Definition B.1 Natural carriers for each type are defined by closing: e.g. N =df {z | z /=⊥ }
under the type forming operations (i.e. cartesian product, power type and schema type).


Naturally, the following elimination rule is derivable for natural carriers:
Proposition B.2

t ∈ T
t /=⊥
(NatCar−)


As a result, the schema calculus is hereditarily ⊥-free:
Definition B.3 [Semantics for Atomic Schemas]
[S | P ] =df {z ∈ T | z ∈ S ∧ z .P }

Note that this definition draws bindings from the natural carrier of the type T . As a conse- quence, writing t (⊥) for a binding satisfying t.x =⊥ for some observation x, we have:
Lemma B.4
t (⊥) ∈ U
false
We proved (in [16]) that the Z⊥ core is conservative over the ZC core, and (in [17]) that the schema calculus in Z⊥ preserves the meaning of the schema calculus in ZC .
