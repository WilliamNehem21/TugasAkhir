Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 352 (2020) 283–304
www.elsevier.com/locate/entcs

Hennessy-Milner Results for Probabilistic PDL
Tao Gu Alexandra Silva Fabio Zanasi
Department of Computer Science University College London London, UK

Abstract
Kozen introduced probabilistic propositional dynamic logic (PPDL) in 1985 as a compositional framework to reason about probabilistic programs. In this paper we study expressiveness for PPDL and provide a series of results analogues to the classical Hennessy-Milner theorem for modal logic. First, we show that PPDL charaterises probabilistic trace equivalence of probabilistic automata (with outputs). Second, we show that PPDL can be mildly extended to yield a characterisation of probabilistic state bisimulation for PPDL models. Third, we provide a different extension of PPDL, this time characterising probabilistic event bisimulation.
Keywords: Probabilistic Propositional Dynamic Logic, Probabilistic bisimulation, Hennessy-Milner property

Introduction
Probabilistic programming is an extension of imperative programming that enables the specification and implementation of randomized network and security protocols, machine learning and quantum algorithms. The variety of applications has recently led to a rapidly growing interest in the probabilistic perspective. Reasoning about the correctness of such programs, and more generally verifying properties such as convergence and termination, is quite intricate. It is thus important to establish formal techniques that enable these forms of reasoning.
The origins of the formal semantics of probabilistic programs can be traced back to the early 1980s. The seminal work by Kozen [13,14] describes how to use Markov Kernels to give precise denotational semantics to simple imperative probabilistic programs. Probabilistic programs allow to encode conditionals and iterations parametric on a coin flip: e.g., “execute program p with probability 0.3 and program q with probability 0.7”. Thus, their semantics is not simply a relation from inputs to outputs, but rather a map from an initial state to a (sub-)distribution over possible final states. Reasoning about correctness of such programs differs from

https://doi.org/10.1016/j.entcs.2020.09.014
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

the classical setting in that one moves from a Boolean — is a property true or not
— to a quantitative perspective — is a property true with high probability.
Probabilistic propositional dynamic logic (PPDL) [14] establishes a framework for expressing and verifying properties of probabilistic programs, which moves from the traditional truth-functional interpretation to a quantitative one. Many properties of probabilistic programs, like termination, can be encoded and verified in PPDL. The box and diamond modalities in PPDL can be thought of as probabilistic ana- logues of Dijkstra’s weakest preconditions [5]. McIver and Morgan [15], and more recently, also Katoen and Kaminski [12,16], have developed a quantitative analogue of Dijkstra’s calculus to reason about termination of probabilistic programs, which is closely related to PPDL. In addition to applications in verification, PPDL has found its way to other areas, e.g. it has been used to reason about uncertainty and knowledge in multi-agent systems [8].
On the other hand, Hennessy and Milner first noticed a relationship between bisimulation of labelled transition systems (LTS) and a simple modal logic, subse- quently referred to as Hennessy-Milner logic (HML) [10]. In particular, they proved that HML characterises bisimilarity (the largest bisimulation) within the class of image-finite LTS: two states in an image-finite LTS are bisimilar if and only if they satisfy exactly the same HML formulas. The existence of such characterisation of bisimilarity has practical implications for verification of properties: if two states of a system belong to the same HM class, then they can be checked for bisimulation equivalence by looking at HML formulas instead. Moreover, and perhaps more in- terestingly, if two states are not bisimilar, then one can find an HML formula to witness the failure of (and serve as counter-example to) bisimilarity. For a simple logic such as HML, this is a considerable advantage.
Since the seminal paper of Hennessy and Milner, analogous characterisations have been studied for other logics and systems. In particular, there has been grow- ing interest in the quantitative setting. For example, an HML-style simple logic, called L0, was introduced in [3,2] to characterise state and event bisimilarity for labelled Markov processes (LMPs). Later on, Desharnais et al. [4] proposed a real- valued logic which gives the same characterisation result for LMPs. Doberkat [6] studied stochastic Kripke models, and introduced (Boolean-valued) stochastic PDL to characterise behavioural equivalence of such models.
In this work, we continue this line of research by studying Hennessy-Milner properties for PPDL. The main contributions of the paper (and its technical roadmap) are as follows:
First, we show that PPDL functions (or, more precisely, PPDL with well- structured programs) characterise probabilistic trace equivalence of PPDL mod- els. These are the probabilistic analogues of Kripke models — probabilistic automata with a continuous state space and multiple output functions (Sec- tion 3). Not unexpectedly, the challenge here is to prove that trace equivalence implies PPDL equivalence.
In Section 4, we show that a small extension of PPDL, which we call PPDL+, characterises probabilistic state bisimilarity for PPDL models (with analytical

state spaces). PPDL+ extends PPDL with additional function constructors (for Boolean functions) of the form (−) > r, where r is arbitrary non-negative rational.
In Section 5, we show that a different extension of PPDL, which we call PPDL], characterises probabilistic event bisimilarity for PPDL models. Note that, dif- ferently from state bisimilation, this result does not require the state spaces to be analytical.
Preliminaries
In this section, we fix some basic notation and recall the necessary background on Markov Kernels, PPDL, and labelled Markov processes.
Measurable spaces, Markov Kernels, and Categories.
A measurable space is a set X equipped with a σ-algebra ΣX on X: ΣX ⊆ P(X) isa collection of subsets of X such that it includes X, is closed under complement, and is closed under countable intersections. When no confusion arises, we shall often refer to a measurable space simply by its underlying set. Given two measurable spaces (X, ΣX ) and (Y, ΣY ), we recall the following notions:
A function f : X → Y is measurable if f−1(B) ∈ ΣX whenever B ∈ ΣY .
A function μ : ΣX → [0, +∞] isa measure if it satisfies the countable additivity property: for any countable family {Ai | i ∈ I} of pairwise disjoint subsets of X,
μ [ Ai! = Σ μ(Ai)
In particular, a (sub-)probability measure is one such that μ(X)=1 (or μ(X) ≤
1).
A function h : X × ΣY → [0, 1] is a (sub-)Markov kernel if:
h(·, B): X → [0, 1] is a measurable function for any B ∈ ΣY .
h(x, ·): ΣY → [0, 1] is a (sub-)probability measure for any x ∈ X.
Finally, we recall the definition of analytic space — for more details, see e.g. [7]. A metric space M is complete if every Cauchy sequence of points in M has a limit in M, and separable if M contains a countable dense subset. A Polish space is the topological space underlying a complete and separable metric space. Suppose (X, ΣX ) is Polish. A subset C of X is analytic in X if it is the continuous image of some Polish space. A measurable space (Y, ΣY ) is analytic if it is measurably isomorphic to some analytic set C in a Polish space (X, ΣX ).
Probabilistic propositional dynamic logic (PPDL)
We now recall the basic syntax and semantics for PPDL from [14]. A PPDL signature is a pair of finite sets (P, F), where P and F are respectively the sets of primitive

programs and primitive functions. The programs, functions and formulas of PPDL
are defined as:
Booleans	B ::= 1 | F ∈ F | ¬B | B ∧ B | B ∨ B
programs	 p, q ::= P ∈ P | p; q | B? | ap + bq | p∗ functions	f, g ::= 1 | F ∈ F | af + bg | B · f | ⟨p⟩f formulas		φ ::= f ≤ g

where a, b ∈ Q≥0 are non-negative rational numbers. Often we shall omit the operators “·” and “;” when the context is clear, so that Bf and pq stand for B · f and p; q, respectively. Note that primitive functions F ∈ F appear also as Booleans. This is because, as we will see below, primitive functions are interpreted as {0, 1}- valued measurable functions on the state space.
Remark 2.1 In the paper originally introducing PPDL [14], arbitrary linear combi- nations of functions are allowed. In our presentation, we admit only positive linear combinations for the sake of simplicity. Note that eliminating such restriction would not affect the results that we prove.
Remark 2.2 As we will see, PPDL formulas do not actually play a role in the re- sults of the next sections, which instead revolve on PPDL functions. We still included formulas in our presentation for two reasons. First, to adhere to the original defini- tion of PPDL, as in [14]. Second, to contrast formulas with the function constructor (−) > r that we will introduce in Section 4, see Remark 4.1 below.
To emphasise how PPDL programs capture standard programming constructs, we shall also use the following abbreviations:

if B then p else q := (B?; p)+ (¬B?; q)	while B do p := (B?; p)∗; (¬B)?
In this paper we will focus on the fragment of well-structured programs, where the usage of linear combination and iteration is restricted:
programs	p, q ::= P | p; q | B? | if B then p else q | while B do p

Such restriction, which already appears in [14], has a natural justification. Intu- itively, the Kleene star p∗ of a program p describes finite iterations of execution of p, which may not always converge to a finite value for all inputs. The restriction to well-structured programs enforces the semantics of p∗ (and all programs as given above) to be defined everywhere and return a real value in [0, 1] (for a full proof see e.g. [17]).Whenever we want to emphasise such restriction, we will refer to the fragment of PPDL whose programs are well-structured as well-structured PPDL.
A PPDL model for the signature L = (P, F) is a tuple X = (X, ΣX, VP, VF), where:
(X, ΣX ) is a measurable space (called the state space), and X is called the set of states.

VP assigns to every P ∈ P a sub-Markov kernel X × ΣX → [0, 1].
VF assigns to every F ∈ F a measurable function X → {0, 1}.
The semantics · X for well-structured programs and functions are inductively de-
fined as follows:J )
(Well-structured) programs are interpreted as sub-Markov kernels X × ΣX →
[0, 1]:

X = VP(P )
X	X	X
Jif B then p else q)	= JB?; p)  + J(¬B)?; q)

p; q X = λ(x, A).
y∈X
Jp) (x, dy) · Jq) (y, A)

Jwhile B do p)X = ΣJ(B?; p)i; (¬B)?)X

X
JB?)	= λ(x, A). B	(x) · χA(x)

where (B?; p)0 = 1?, (B?; p)i+1 = (B?; p)i; (B?; p), and χA is the characteristic function for set A.
Boolean functions are interpreted as {0, 1}-valued measurable functions:


JF )
= VF(F )
X
0	1 X = λx. B0 X
X	X
∧ B1 X
X
(x)

J¬B)	= λx.1 − JB) (x)	JB0 ∨ B1)	= λx.JB0) (x) ∨ JB1)
(x)

Functions are interpreted as measurable functions X → [0, +∞):


J1)
= λx.1 (the constant function to 1)	F X
= VF(F )

X	X	X
Jaf + bg)	= λx.a · f	(x)+ b · g	(x)	Bf
= λx. B X
· f X
(x)

J⟨p⟩f )X = λx. ∫


y∈X
Jf ) (y) · Jp) (x, dy)


Formulas are interpreted as {0, 1}-valued measurable functions:


Jϕ ≤ ψ)
(x) = 
1	if ϕ X (x) ≤ ψ X (x)
0	otherwise


A pointed PPDL model is a model X together with a state x ∈ X. We say two pointed models (X, x) and (Y, y) are equivalent with respect to PPDL functions (denoted

as (X, x) ≡
PPDL
(Y, y)) if
Jf ) (x) =
Jf ) (y), for all functions f . We will also

encounter other logics, whose syntax does not have functions but just formulas:
with slight abuse of notation, for such logic L, we will use ≡L to mean the binary relation that two (pointed) L-models are equivalent with respect to all L-formulas.

Labelled Markov processes and probabilistic bisimulation.
Given a finite set of actions A, a labelled Markov process (LMP) is an A-labelled tuple (X, ΣX, τa)a∈A, where (X, ΣX ) is a measurable space, and for each a ∈ A, τa : X × ΣX → [0, 1] is a sub-Markov kernel.
We are going to study two different notions of bisimulation for LMPs. Suppose (X, ΣX, τa)a∈A is an LMP. First, we introduce state bisimulation [18]. For a relation R⊆ X ×X and a subset A ⊆ X, we say that A is R-closed if for any xRxj, one has x ∈ A if and only if xj ∈ A. The relation R⊆ X × X is a (LMP) state bisimulation if for any xRxj, a ∈ A, and R-closed A ∈ ΣX ,
τa(x, A)= τa(xj, A).
We say two pointed LMPs (X, x) and (X, xj) are state bisimilar, denoted as
(X, x) a0 (X, x ), if there exists a state bisimulation R⊆ X × X such that xRx .
There is another notion of bisimulation on LMPs, called event bisimulation [2]. A sub-σ-algebra Λ ⊆ ΣX is an event bisimulation if (X, Λ, τa)a∈A is also a LMP. Such Λ generates a binary relation R(Λ), such that (x, xj) ∈ R(Λ) if x ∈ A precisely when xj ∈ A, for all A ∈ Λ. With a bit abuse of terminology, we may also refer to this R(Λ) as an event bisimulation when Λ is. We say two pointed LMPs (X , x)

and (X, xj) are event bisimilar, denoted as (X, x) bisimulation Λ such that (x, xj) ∈ R(Λ).
a0 (X, x ), if there exists an event

It is worth noting that state and event bisimulation coincide in discrete settings and for analytic state spaces. However, in general, the two notions are orthogonal [2,20]. From a categorical point of view, LMP state bisimulation are spans in the category of LMPs with analytic state spaces (seen as coalgebras). Note that the spans are properly definable (as a weak pullback) only when the LMPs are analytic [3,18]. On the other hand, LMP event bisimulations are cospans of surjections in the category of LMPs, which are definable without any need of the analyticity restriction [2].
Logical characterisation of bisimilarity for LMPs.
For our later developments, it is important to recall two Hennessy-Milner results in the context of LMPs. The simple logic L0 [3] is defined inductively as follows:
φ ::= T| φ ∧ φ | ⟨a⟩rφ	(1)
where a ∈A is an action and r is a rational number in [0, 1). A model for L0 is a

LMP (X, ΣX
, τa)a∈A
. Let
J·)L0
denote the interpretation of L0
in X , or simply
J·)

if the context is clear. Then
X | τa(x, Jφ)) > r}.
JT)
:= X,
Jφ ∧ ψ)
Jφ) ∩
Jψ), and
J⟨a⟩rφ)
:= {x ∈

There are two important results (which we will use in Section 4 and 5): (1) if we consider LMPs whose state spaces are analytic, then L0 characterises LMP state bisimilarity [18]. (2) if we consider LMPs in general, then L0 characterises LMP event bisimilarity [2].

Proposition 2.3 ([18]) For a countable action set A, suppose X = (X, ΣX, τa)a∈A
is an LMP with an analytic state space, and x, y are two states in X. Then (X, x)	0
(X, y) if and only if (X, x) ≡L0 (X, y).

Proposition 2.4 ([2]) Suppose that X = (X, ΣX, τa)a∈A is an LMP, and x, y are

two states in X. Then (X, x)
e (X, y) if and only if (X, x) ≡
(X, y).

a0	L0


PPDL characterises trace equivalence
In this section we provide a Hennessy-Milner property for PPDL (functions). First, we introduce the notion of trace equivalence between PPDL models, which is a gen- eralization of that for probabilistic automata (PA). Then, we prove that PPDL char- acterises trace equivalence. Note that trace equivalence is a relatively weak notion, so the non-trivial direction is that trace equivalence implies PPDL equivalence (Prop. 3.6).
The first question to tackle is how to define a notion of trace equivalence for
PPDL models in a principled way. To this aim, we use the observation that a PPDL
model can be seen as a (continuous) probabilistic automaton (PA) with multiple output functions. The standard trace semantics of a PA is the set of its trace distributions, each of which is a probability distribution assigning to a certain set of traces a probability value [19]. Two pointed PAs are trace equivalent if the two states have exactly the same trace distributions. Motivated by this, we define trace distributions and trace equivalence between pointed PPDL models. Since we now work in the continuous case, the trace semantics consists of sets of probability measures (while in the discrete case we reason with sets of probability distributions).
To present our definition, we fix a finite signature (P, F). We define the alphabet as Σ := P  B?, where B is the set of all Boolean combinations of F ∈ F, and B? = {B? | B ∈ B}; we use Σ∗ to denote the set of all finite words over Σ; in particular, ϵ is the empty word.

Remark 3.1 Note that, since F is finite, there are only finitely many elements in B modulo logic equivalence ≡. With slight abuse of notation, henceforth we use B? to denote a finite set of letters, containing one fixed B? from each ≡-equivalence class in B. The choice of the representative of equivalence classes does not affect our results. Hence the alphabet Σ is finite.

Definition 3.2 (Trace) A PPDL model X = (X, ΣX, VP, VF) determines, for each word ω ∈ Σ∗, a sub-Markov kernel τω : X × ΣX → [0, 1], inductively as follows. For

arbitrary x ∈ X and A ∈ ΣX :
τє(x, A) := χA(x)
τP (x, A) := VP(P )(x, A) where P ∈ P
  1	JB)F (x)=1 and x ∈ A
τω·a(x, A) :=	τ (x, dy) · τ (y, A),Jwh) ere ω ∈ Σ∗, and a ∈ Σ
y∈X
Then the trace at state x is a function ρx : Σ∗ × F → R such that given ω ∈ Σ∗ and
F ∈ F,

ρx(ω, F ) :=
y∈X
τω(x, dy) · VF(F )(y)

Given two pointed PPDL models (X, x) and (Y, y), we say they are trace equivalent

(denoted as (X, x) ≈tr (Y, y)) if ρF = ρY , namely if ρF and ρY
coincide on all

x	y	x	y
inputs (ω, F ) ∈ Σ∗ × F.
Towards a characterisation result, our first observation is that PPDL equivalence entails trace equivalence.
Proposition 3.3 (X, x) ≡PPDL (Y, y) implies (X, x) ≈tr (Y, y).
Proof. By Definition 3.2 we have (X, x) ≈tr (Y, y) if and only if that ρx(ω, F ) = ρy(ω, F ) holds for arbitrary primitive function F ∈ F and finite word ω ∈ Σ∗. Note that every value ρx(ω, F ) is exactly the interpretation of a PPDL formula ⟨ω⟩F at the state x, so (X, x) ≡PPDL (Y, y) implies ρx(ω, F )= ρy(ω, F ), for all ω and F . 2
Remark 3.4 Note that the proof of Proposition 3.3 also implies a “minimal” real- valued logic which characterises trace equivalence between PPDL models. Its func- tions are of the form ⟨ω⟩F , where ω ∈ Σ∗ and F ∈ F. This logic is “minimal” in the sense that it can be expressed by any real-valued logic characterising trace equivalence.
For the converse direction, namely trace equivalence implies PPDL equivalence, we need the following factorisation lemma.
Lemma 3.5 (Factorisation) Every PPDL function f is equivalent to some PPDL
function g (in the sense that Jf )	= J )	for all models X) of the following form:
G ::= 1 | F | B | ⟨p⟩G	(2)
g ::= G | ag + bg | B · g
where p is a program, a, b ∈ [0, +∞). In other words, one can always push the appearance of programs in PPDL functions to “the innermost layer”.
Proof. The proof goes by induction on the complexity of PPDL functions. We show the only non-trivial case, which is f = ⟨p⟩fj for some fj. First, let us write  for

semantic equivalence between PPDL functions, namely f  g if
f F = g F for all

models X . We then prove by cases of the structure of fj. If fj =J )1 or fJj =) F for a
primitive F , then f = ⟨p⟩fj is already in the correct shape. If fj = af0+bf1, we have f = ⟨p⟩(af0 + bf1)  a⟨p⟩f0 + b⟨p⟩f1, and we can apply the induction hypothesis on f0 and f1. If fj = B·fjj, note that f = ⟨p⟩B·fjj  ⟨p⟩⟨B?⟩fjj  ⟨p; B?⟩fjj, and again we can conclude using the induction hypothesis on fjj. Finally, if fj = ⟨pj⟩fjj, we have that f = ⟨p⟩⟨pj⟩fjj ⟨p; pj⟩fjj, and we can conclude by induction hypothesis on fjj.	2

We are now ready to show that trace equivalence implies PPDL equivalence.
Proposition 3.6 (X, x) ≈tr (Y, y) implies (X, x) ≡PPDL (Y, y).
Proof. Suppose (X, x) ≈tr (Y, y). It suffices to prove that (X, x) and (Y, y) agree on all functions g in Lemma 3.5. We reason by induction on the structure of g. We first consider the case where g is some G, defined as in (2). This has 4 sub-cases:
G = 1: trivial.
G is a primitive function F : since (X, x) ≈tr (Y, y), they agree on the empty word ϵ. In particular, ρx(ϵ, F )= ρy(ϵ, F ).
G is some Boolean combination B of primitive functions. This case follows from the fact that the value of B is totally determined by its component primitive functions.
G = ⟨p⟩F , where F ∈ F. We first show that every program p can be written as

a (countable) sum of words in Σ∗. Then
⟨p⟩F
F (x)= ⟨p⟩F
Y (y) is reduced

to ⟨ω⟩F F (x)= ⟨ω⟩F Y (y) for any ω ∈ Σ∗, which is exactly the definition of trace equivalence. We reason by induction on the structure of the programs.
The cases for p = P and p = B? are trivial, as they are already in the alphabet.
As for the cases for p = if B then p0 else p1 and p = while B do q, one simply spells out the definitions.
p = p0; p1. By induction hypothesis, both p0 and p1 can be written as sums of words in Σ∗, say p	=	ω , p	=	π , then p ; p	=
i∈I,j∈J ωi; πj .
Next we consider the remaining two cases for g, namely g = ag0 + bg1 and g = B· gj. Both can be proved by straightforward application of the induction hypothesis. 2

Propositions 3.6 and 3.3 together yield the desired Hennessy-Milner property for
PPDL:

Theorem 3.7 (PPDL characterises trace equivalence) For arbitrary pointed
PPDL models (X, x)and (X, y), (X, x) ≡PPDL (X, y) if and only if (X, x) ≈tr (X, y).
Example 3.8 Let the signature be P = {a, b} and F = {F1, F2}. Consider the

following two pointed PPDL models (X, x0) and (Y, y0):


x0
a, 1
2 
x1
b, 1
3 
y0
a, 1
2 
y1
z 

x2	y2	y3
Also, define F1(x2) = F1(y2) = F1(y3) = 1, F2(x2) = F2(y2) = 1, and for all the other unmentioned cases F1 and F2 have value 0. Then (X, x0) and (Y, y0) are not trace equivalent. Theorem 3.7 tells us that there exists some PPDL function f that has different values on x0 and y0. For example, let f = ⟨a⟩⟨b⟩(F1 ∧ F2), then
F	1	1	1	Y	1	1	1	1	1
Jf ) (x0)= 2 × 3 × 1= 6	Jf ) (y0)= 2 × 2 × 1+ 2 × 2 × 0= 4
Extended PPDL characterises state bisimilarity
Theorem 3.7 characterises trace equivalence in terms of PPDL. It is a natural question to ask what extra logical structure is needed in order to characterise state bisim- ularity and event bisimilarity for PPDL models. In this section we focus on state bisimulation (and leave event bisimulation to the next section). To this aim, we in- troduce a suitable extension of PPDL, called PPDL+, and we show that it characterises state bisimilarity over PPDL models with analytic state spaces.
PPDL+
We start with introducing the logic PPDL+ as an extension of PPDL. The idea is that, since L0 characterises LMP state bisimilarity (Proposition 2.3), we extend PPDL so that it can interpret L0 formulas as functions. In the grammar below, we point out which clauses are the same as in PPDL to emphasise the difference between the two logics. PPDL+ is defined as
PPDL+ Booleans	B ::= 1 | F ∈ F | ¬B | B ∧ B | B ∨ B | f > r
PPDL+ programs	 p, q ::= P ∈ P | p; q | B? | ap + bq | p∗ PPDL+ functions	f, g ::= B | af + bg | B · f | ⟨p⟩f PPDL+ formulas		φ ::= f ≤ g
where a, b ∈ [0, +∞), and r is arbitrary rational number in [0, +∞). As in the case of PPDL, we always restrict to the well-structured programs for PPDL+. The resulting logic PPDL+ has the same set of programs as PPDL, but with additional function constructors (for Boolean functions) of the form (−) > r.
Remark 4.1 Note that this new function constructor apparently resembles the shape of the constructor of PPDL formulas, but it is of a different nature: (−) > r is fixed for each rational number r ∈ Q≥0, and it yields a function, whereas (−) ≤ (−) in the PPDL syntax acts on two variable arguments, and it yields a formula.

The logic PPDL+ is also interpreted on PPDL models. The (boolean) function f > r

is interpreted as a {0, 1}-valued function such that and 0 otherwise (namely if f F (x) ≤ r).
State bisimulation
f > r F (x)=1 if
Jf ) (x) > r,

We now develop the characterisation result for state bisimilarity. For the reminder of this subsection, we restrict ourselves to those LMPs (and PPDL models) whose state spaces are analytic. The notion of state bisimulation for PPDL models is defined as the extension of the same notion on the underlying LMPs, by taking the extra weight structure into account.
Definition 4.2 (State bisimulation for PPDL models) Let X be a PPDL model. A state bisimulation on X is an equivalence relation R⊆ X × X, such that if xRxj, then
VP(P )(x, A) = VP(P )(xj, A), for any P ∈ P and R-closed A ∈ ΣX (for the definition of R-closure, see Section 2).
VF(F )(x)= VF(F )(xj), for any F ∈ F.
Given two states x, xj ∈ X, we say the two pointed PPDL models (X, x) and (X, xj)

are state bisimilar (denoted as (X, x)
R⊆ X × X such that xRxj.
a (X, x )) if there exists a state bisimulation

Remark 4.3 Recall that, when defining trace equivalence (Definition 3.2), we let the primitive functions (and their boolean combinations) be the labels of the LMPs. This allows us to account for tests of the form B?, where B is some boolean com- bination of primitive functions. Only with this setup the resulting notion of trace equivalence implies logical equivalence. For bisimulation, such extra label structure is unnecessary, whence the above definition.
Although the above definition only concerns a single model X , for bisimulation between two models X and Y, one can simply apply the definition to their disjoint union X Y. It is an immediate observation that condition (i) above, can be extended to τω for arbitrary program ω ∈ Σ∗ (where Σ = P B? as defined in Section 3):

Lemma 4.4 If (X, x)
and R-closed A ∈ ΣX.
as (X, xj) by R, then τω
(x, A)= τω
(xj, A), for any ω ∈ Σ∗

Proof. We prove the statement by induction on ω.
ω = ϵ: we need to show that x ∈ A if and only if xj ∈ A, which holds because
xRxj and set A is R-closed.
ω = P , where P ∈ P: we need to show that VP(P )(x, A)= VP(P )(xj, A), and this is already (part of) the definition of state bisimulation.
ω = B?, where B ∈ B: the desired equation is reduced to VF(B)(x) = VF(B)(xj), and x ∈ A if and only if xj ∈ A. They follow immediately from condition 2 in Definition 4.2 and that A is R-closed.

ω = ωj · a, where ωj ∈ Σ∗ and a ∈ Σ: there are two sub-cases.
a = P ∈ P. First, recall that τω′·P (x, A) = y∈X τω′ (x, dy) · VP(P )(y, A). Note that (VF(P )(−, A))—1(r) is always R-closed, for arbitrary r ∈ [0, 1]. So by induction hypothesis,
τω′ (x, VF(a)(−, A)	(r)) = τω′ (x , VF(a)(−, A)	(r))
which implies that the two integrals are equivalent.
a = B?, where B ∈ B. Similarly, note that τω′·B?(x, A)= y∈X τω′ (x, dy) · τB?(y, A), and that (τB?(−, A))—1(r) is always R-closed, for arbitrary r ∈ [0, 1].
2
The next observation is that, as in the non-probabilistic setting, state bisimula- tion implies trace equivalence.

Lemma 4.5 (X, x)
s (X, xj) implies (X, x) ≈
(X, xj).

a	tr
Proof. Suppose R⊆ X ×X is a state bisimulation on X such that xRxj. We make a case distinction on ω ∈ Σ∗ to show that ρx(ω, F )= ρx′ (ω, F ), for any F ∈ F.
ω = ϵ: ρx(ϵ, F )= VF(F )(x), and by Definition 4.2 VF(F )(x)= VF(F )(xj).
ω	is	non-empty:	ρx(ω, F )	=	∫y∈X τω(x, dy)VF(F )(y)	=

R-closed, so by Lemma 4.4 we have τω(x, VF(F )—1(1)) = τω(xj, VF(F )—1(1)).
2
The above observation, paired with our characterisation of trace equivalence in terms of PPDL (Theorem 3.7), yields the question of how PPDL fails to characterise the stronger notion of state bisimilarity, thus making necessary the introduction of PPDL+. The following counterexample illustrates this point.
Example 4.6 Consider the PPDL signature (P = {a, b}, F = {F}), and the following two pointed models (X, x0) and (Y, y0):



x
b,1


1
x0

z 
x2
b,1
y0
a,1
  
y1

z 
x3	x4	y3	y4
where F (x1) = F (x2) = F (x3) = F (y1) = F (y3) = 1, F (x4) = F (y4) = 0, and
F (x0) = F (y0) = 0. We claim that x0 ≡PPDL y0. By Theorem 3.7, it suffices to check that (X, x0) and (Y, y0) are trace equivalent. For example, ρx0 (a, F ) = 
1 × 1+ 1 × 1 = 1, and ρy (a, F ) = 1 × 1 = 1. However, the two pointed models
2	2	0
are not state bisimilar. This is because if such R exists, then R should also contain
(x1, y1) and (x2, y1), but this does not work because y1 has a non-trivial probabilistic branching, which neither x1 nor x2 has.

For the non-trivial direction of the characterisation, namely ≡PPDL+ implies state bisimilarity, the idea is to start from some simple logic L, resembling L0 (see Section 2), such that ≡L implies state bisimilarity. If we can show that PPDL+ can express L, then ≡PPDL+ implies ≡L, and we are done. This motivates us to introduce L1 as an extension of L0, based on the observation that the main difference between PPDL models and LMPs is that the former has some extra weight structure (namely VF). Differently from L0, in L1 we have those primitive functions F in F as primitive formulas:
L1 e φ ::= T| F | φ ∧ φ | ⟨P⟩rφ	(3)
where F ∈ F, P ∈ P, and r is arbitrary rational number in [0, 1). The logic L1 is interpreted on PPDL models, and the semantics is similar to that for L0 on LMP. In particular (X, x) ▶ F if VF(F )(x) = 1. We can show the following proposition as the analogue of Proposition 2.3 for the case of PPDL model. The proof can be found in Appendix A.
Proposition 4.7 Suppose that X = (X, ΣX, VP, VF) is a PPDL model with an an-

alytic space, and x, y are two states in X. Then (X, x)
(X, x) ≡L1 (X, y).
s (X, y) if and only if

Then, in order to show that PPDL+ equivalence imply state bisimilarity, it suffices to show that PPDL+ can encode L1 (as defined in (3)). In the following lemma, let
≈ denote the binary relation between L1 formulas and PPDL+ (boolean) functions, such that φ ≈ f if and only if they are semantically equivalent: for any PPDL model
X and x ∈ X, X,x ▶ φ if and only if f F (x) = 1, and X,x /▶ φ if and only if
Jf ) (x)= 0.
Lemma 4.8 For every L1 formula φ, there exists some PPDL+ Boolean function f
such that φ ≈ f.
Proof. We reason by induction on L1 formulas φ. Note that T ≈ 1; F ≈ F ; φ1 ∧ φ2 ≈ f1 ∧ f2, where φi ≈ fi, i = 1, 2. For the case φ = ⟨a⟩rψ, suppose by induction hypothesis that ψ ≈ f . Then one may check that ⟨a⟩rψ ≈ (⟨a⟩f ) > r. 2
We are now ready to prove the main result of this subsection.
Theorem 4.9 (PPDL+ characterises state bisimilarity) For arbitrary pointed

PPDL model X with analytic state spaces and states x, y ∈ X, (X, x)
if and only if (X, x) ≡PPDL+ (X, y).
a (X, y)

Proof. For the forward direction, we reason by induction on functions f . Given Lemma 4.5 and Proposition 3.6 , it only remains to show the case in which f =
fj ≥ r. Suppose (X, x)	s (X, y). By inductive hypothesis, fj (x) = fj (y), so
fj (x) ≥ r if and only ifafj (y) ≥ r. This entails f > r (x) =J )f > r (yJ). )
For the other direction, suppose (X, x) ≡PPDL+ (X, y). We construct a binary relation R⊆ X ×X, and check the two conditions in Definition 4.2. By Lemma 4.8, (X, x) ≡PPDL+ (X, y) implies (X, x) ≡L1 (X, y). So simply let R be ≡L1 , and xRy.
Then apply Proposition 4.7, we know that (X, x)	s (X, y) under bisimulation R.2

Example 4.10 We recall Example 4.6, where (X, x0) are and (X, y0) are not state bisimilar. Then Theorem 4.9 implies that there is some PPDL+ function that can distinguish the two pointed models. For example, let f = ⟨a⟩ ⟨b⟩(F ) > 1 > 2 .


2 F
2 F
2 Y



which entails that
f F (x ) = 1 and
f Y (y ) = 0. So f can distinguish (X,x )

and (Y, y0).
J )	0
J )	0	0

Extended PPDL characterises event bisimilarity
This section is devoted to showing that another mild extension of PPDL can be used to characterise event bisimilarity for PPDL models. The notion of event bisimulation was proposed in [2] as a more appropriate way than state bisimulation to define behavioural equivalence for LMPs, because it does not require the underlying state spaces to be analytic. In what follows, we first introduce the new logic, then the notion of event bisimulation for PPDL models, and finally show their correspondence.
PPDL]
The logic characterising event bisimilarity for PPDL models will be called PPDL]. Intuitively, PPDL] is obtained by adding L0 to PPDL in a “minimal” way: unlike PPDL+, where (−) > r can be applied to arbitrary functions, in PPDL] only certain instances of f > r are admitted. More precisely, PPDL] programs p, pj and PPDL] functions f are defined as follows, where we highlight when the grammar has the same clauses as PPDL.

As in the case of PPDL, we always restrict to the well-structured programs. Note a PPDL] function f is defined to be either a PPDL function g, or a function C in which a new function constructor ⟨P⟩(·) > r may appear. Intuitively, the reason for considering PPDL] instead of PPDL+ is that event bisimulation is too weak to preserve arbitrary functions of the type ⟨p⟩f , as allowed by PPDL+ syntax, and instead requires functions to enjoy some structural property, as the one guaranteed by Lemma 3.5 for PPDL functions.
The semantics of PPDL] is based on PPDL models: all the programs and func- tions are interpreted as in PPDL, whereas the new function construct ⟨P⟩(C) > r is

interpreted as a measurable {0, 1}-valued function
⟨P⟩(C) > r (x)=	1	if P (x, {u ∈ X | C (u)= 1}) > r .
0	otherwise
Event bisimulation
As for state bisimulation, we can define event bisimulation for PPDL models as a mild extension on the same notion on LMPs.
Definition 5.1 (Event bisimulation for PPDL models) An event bisimulation on a PPDL model X = (X, ΣX, VP, VF) is a sub-σ-algebra Λ of ΣX such that (X, Λ, VP, VF) is also a PPDL model.
In other words, Λ is an event bisimulation on X if Λ is an event bisimulation on the LMP (X, ΣX, VP(P ))P ∈P, and VF(F ) ∈ Λ for all F ∈ F. Note that Λ generates an equivalence relation R(Λ) on X: xR(Λ)y if and only if x ∈ A precisely when y ∈ A, for all A ∈ Λ. We say two states x and y are event bisimilar (denoted

as (X, x)
e (X, y)) if there exists an event bisimulation Λ such that xR(Λ)y.

Intuitively, two states x and y are event bisimilar by Λ if they cannot be separated by any set in Λ.
Remark 5.2 Just as for state bisimulation (Lemma 4.5), one may prove that event bisimulation entails trace equivalence. We do not elaborate further on this result, as it is not needed for the sequel.
We now move on to proving the characterisation result for event bisimilarity. The idea is similar to that for state bisimilarity, but here the non-trivial direction is that PPDL] is invariant under event bisimulation. We present a simple logic L¬,∨ which is invariant under (actually, characterises) event bisimulation. Then we show that, L¬,∨ is strong enough to “express” PPDL] (Lemma 5.7).
The (Boolean) logic L¬,∨ is defined by adding Boolean operators ¬ and ∨ to L1: L¬,∨ e φ ::= T| F | φ ∧ φ | φ ∨ φ | ¬φ | ⟨P⟩rφ	(8)
where F ∈ F, P ∈ P, and r ranges over all rational numbers in [0, 1). The semantics of L¬,∨ on PPDL models is the same as that of L1 w.r.t. T, F ’s, ∧ and modality; ∨ and ¬ are interpreted as boolean operaters as usual.
We now establish a characterisation result of the logic L¬,∨. First, we need to introduce some terminology. With a bit abuse of notation, we use J·)L¬,∨ to denote
the interpretation of L¬,∨, or simply · when the context is clear. We also need the
J )
notion of stability from [2]: a set Λ ⊆ Σ is stable w.r.t. Σ if for all P ∈ P, A ∈ Λ, and all rational numbers r ∈ [0, 1], the set ⟨P⟩r(A) := {y ∈ X | VP(P )(y, A) > r} is in Λ. We use L1 to denote the set { φ | φ ∈ L1}⊆ P(X) of interpretations of all L1 formulas, and likewise for L¬,∨. Recall that a π-system C on set X is a subset of P(X) such that X ∈C and C is closed under intersection. Given C ⊆ P(X), we use σ(C) to denote the σ-algebra generated by C. We would like to point out that the

following proof of Proposition 5.5 via Lemma 5.3 and 5.4 has a similar structure to the proof of that L0 characterises LMP event bisimulation in [2].
Lemma 5.3 L1 is the smallest stable π-system w.r.t. ΣX that contains F  for all F ∈ F.
Proof. To see that L1 is a π-system, simply note that X = T is in L1 , and
∧ is interpreted as intersection. To see that L1 is stable, given φ ∈ L1 , then
⟨P⟩r(Jφ)) = J⟨P⟩rφ) ∈ JL1). It is the smallest because if C is a stable π-system

T = X ∈ C.
∈ C, for all F ∈ F.
JF )
If Jφ), Jψ) ∈ C, then Jφ∧ψ) = Jφ)∩Jψ) ∈ C, since C is closed under intersection.

If φ
C, since C is stable.
So any stable π-system C is a superset of JL1).
J	r )
r J )

2

Lemma 5.4 σ(JL1)) is the smallest stable σ-algebra included in ΣX that contains

Proof. First we know that if C is a stable π-system, then σ(C) is also stable (Lemma 5.4, [2]). So σ( L1 ) is a stable σ-algebra included in ΣX . Let Λ be an arbitrary stable σ-algebra Λ ⊆ ΣX containing all F s. Since Λ is also a π-system, by Lemma
we know that L1 ⊆ Λ. Then σ( L1 ) ⊆ Λ as well. Since σ( L1 ) is contained	 by every such σ-algebra, it is the smallest one.	2
Proposition 5.5 (L¬,∨ characterises event bisimilarity) Let X  be a PPDL

model, and x, y are two states in X. Then (X, x) ≡ ¬,∨
1
(X, y) if and only if

(X, x)	e (X, y).
Proof.aThe first observation is that, since σ(JL¬,∨))= σ(JL1)), Lemma 5.4 entails
that σ( L1	) is the smallest stable σ-algebra included in Σ that contains all F s.
We now prove the claim. On one direction, σ( L¬,∨ ) itself is an event bisimu-
J 1  )
lation because it is a stable σ-algebra. This means that if (X, x) ≡L1 (X, y), then
x and y are event bisimilar under σ( L¬,∨ ).
J 1  )
Conversely, suppose there is an event bisimulation Λ ⊆ Σ such that xR(Λ)y. Since σ( L¬,∨ ) is the smallest among all event bisimulations over X , we have

J 1  )
¬,∨
¬,∨

σ( L1 ) ⊆ Λ, and R(Λ) ⊆ R(σ( L1  )). Therefore xR(σ( L1  ))y as well, which
implies that x and y agree on all L¬,∨ formulas.	2
Remark 5.6 It is worth noticing that a similar argument as the one above may show that L1 (defined as in (3)) also characterises event bisimilarity. Then, one may wonder why we introduced L¬,∨ in first place. This has to do with our overall aim, of proving that PPDL] characterises event bisimilarity. The non-trivial direction of this result is that event bisimulation perserves PPDL] functions. For this purpose, we want to use a logic L such that event bisimulation preserves L functions, and

L can “almost” express PPDL] (for example, a PPDL] formula can be expressed by an infinite conjunction of L formulas). It turns out L1 is too simple for the task, whence the introduction of L¬,∨.
The next lemma is needed to show that event bisimulation implies PPDL] equiv-

alence. It focusses on PPDL] functions of the form ⟨p⟩Bˆ, where Bˆ
is any Boolean

(c.f. (4)) and p ∈ Σ∗. Intuitively, it states that L¬,∨ can express such functions,
provided that we allow infinite conjunctions.
Lemma 5.7 For all PPDL] formula of the form ⟨p⟩Bˆ (where p ∈ Σ∗), there exist a (possibly inﬁnite) set of L1 formulas Φ(p), such that for any Boolean B, any states
x, y, if x and y agree on (every formula in) Φ(p)[B/Bˆ], then ⟨p⟩B (x)= ⟨p⟩B (y).
The proof for Lemma 5.7 can be found in Appendix A. We Jare no)w readJy to p)rove
our Hennessy-Milner result for PPDL] and event bisimilarity.
Theorem 5.8 (PPDL] characterises event bisimilarity) For	arbitrary	PPDL
model X and states x, y ∈ X, (X, x) ≡PPDL] (X, y) if and only if (X, x) a (X, y).
Proof. We first prove the simpler direction. Suppose that (X, x) ≡PPDL] (X, y).

Note that PPDL+ can encode L¬,∨, so this implies (X, x) ≡
¬,∨
1
(X, y).	By

Lemma 5.5, x and y are bisimular, as witnessed in particular by the bisimulation
R(σ( L¬,∨ )).
J 1  )	e
As for the non-trivial direction, suppose (X, x) a (X, y). We need to prove
EquaJtio)n (7), PPJDL)] functions can be of two kinds.
First, f might be a PPDL function (as in (6)). So Lemma 3.5 applies, and we may assume f = ⟨p⟩B, where B is some PPDL Boolean. By the semantics of PPDL, it suffices to show that x and y have the same value for all functions of the type ⟨p⟩B, where p ∈ Σ∗ = (P ∪ B?)∗. This is proved in Lemma 5.7.
The second case is when f is C, for C defined as in (5). Note that each such C

can be expressed as a L¬,∨ formula, so by Proposition 5.5,
C F (x)= C
Y (y)

1
for all Cs.
Therefore for any PPDL] function f we have

f F (x)= f
J )	J )
Y (y).	2

Remark 5.9 Note that in the discrete caseJ, t)he notionJs )of state bisimulation and
event bisimulation coincide [2]. So the two pointed models (X, x0) and (Y, y0) in Example 4.6 are not event bisimilar. According to Theorem 5.8, there is some PPDL] function that distinguishes the two models.  In fact, the function
f = ⟨a⟩ ⟨b⟩(F ) > 2  > 1 from Example 4.10 still works here, since such f is
6	Discussion
In this paper we provided three Hennessy-Milner style characterisation results. First, we showed that PPDL functions characterises trace equivalence. Second, we

extended PPDL with a new function constructor (−) > r for any rational r ∈ [0, 1], which allows us to express “threshold check” of function values. The resulting logic, PPDL+, characterises state bisimilarity of PPDL models with analytic state spaces. Third, we studied a different extension PPDL] of PPDL, in which the use of the func- tion constructor (−) > r is restricted: one can only apply multiple constructors of the form ⟨a⟩(−) > r to PPDL Booleans. We proved that PPDL] characterises event bisimulation between PPDL models. Note that, in the characterisations of PPDL+ and PPDL], a key step was to show that they can encode the simple logic L0: this allowed us to exploit the results in in [18], relating L0 to bisimilarity for LMPs. With re- spect to [4], we characterised a richer class of models (namely PPDL models instead of LMPs) using logics with extra structure in the modality. Also, we considered both bisimilarity and trace equivalence.
Comparison with PDL. In the non-probabilistic case, finiteness of branching of the models plays a role in the characterisation results: PDL, similarly to modal logic [1], characterises only bisimilarity of finitely branching Kripke models but not bisimilarity of arbitrarily branching models. In contrast, such restrictions are not needed in the probabilistic case: in fact, though we chose to present our results using continuous distributions, the same results also hold if one restricts to the discrete case. From a categorical point of view, it means that our results cover models that are elements of the Kleisli category of both the Giry monad G≤1 (continuous) and the sub-distribution monad D≤1 (discrete). Note that in the non-probabilistic setting, finitely-branching Kripke models are precisely the Kleisli arrows of the finite powerset monad Pf and possibly infinite-branching Kripke models are the Kleisli arrows of the unrestricted powerset monad P.
To illustrate this, we now provide a counterexample showing that PDL- equivalence does not imply P-bisimulation — to the best of our knowledge this observation is novel. Let the alphabet set be Σ = {a, b}, and fix an infinite string ω ∈ Σ∞ as follows:
•  a  •  ¸b  •  ¸b  •  ¸a  •  ¸a  •  ¸a  •  ¸b  •  ¸b  •  ¸b  •  ¸b  •  ¸a · ·¸· 

More precisely, there are n + 1 appearances of label a right after n appearances of label b, and n + 2 appearances of label b right after n + 1 appearances of label a, for all n ∈ N. The key property of ω is that it is acyclic. Then consider the following two pointed relational models (X, x) and (Y, y):



a  a  a
x
···

z··· 

a  a  a
y
···

z··· a

x ¸c .
,7   j	z˛
y _c•  .• ,7  yj
z˛ zyj_

0	•	•
b	b
       
···	xj
  
.
··· 
0
b	b
      
··· 
j	···	ω
  
    .	.

x1	•	.
b
  
x2
y1	•	.	.
b
  
y2

In words, in (X, x) all the finite paths x··· xn (n ∈ N) exhaust all the finite initial segments of ω, and all infinite paths xxj ··· exhaust the infinite paths in Σ∞ \ {ω}.

The same holds for (Y, y), except that y has an extra successor yj , such that the

infinite path yyj
··· forms the sequence ω. It is not hard to check that (X, x) and

(Y, y) are equivalent with regard to all PDL formulas, but they are not bisimilar.
Outlook: coalgebraic charaterisations. Finally, we also regard our work as a starting point of further investigation on Hennessy-Milner results for the generic coalgebraic dynamic logic (CoDL) [11,9]. The analogy between the case of CoDL and that of PPDL is summarised by the following table.

More details on the items appearing in the column for CoDL can be found in [11]. The column for PPDL simply reformulates categorically the presentation of PPDL semantics in Section 2, where Meas is the category of measurable spaces and G≤1 is the sub-Giry monad on Meas.
There are various interesting observations on CoDL that can be made exploiting this analogy. For example, if in a CoDL-system L (defined in [11]) the proposition op- erators distribute over modalities, then a similar argument as the one of Proposition
3.6 shows that L characterises trace equivalence. We leave further developments as future work.

References
Patrick Blackburn, Maarten de Rijke, and Yde Venema. Modal Logic, volume 53 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, 2001.
Vincent Danos, Jos´ee Desharnais, Francois Laviolette, and Prakash Panangaden. Bisimulation and cocongruence for probabilistic systems. Information and Computation, 204:503–523, 04 2006.
Jos´ee Desharnais, Abbas Edalat, and Prakash Panangaden. Bisimulation for labelled markov processes.
Inf. Comput., 179(2):163–193, 2002.
Jos´ee Desharnais, Vineet Gupta, Radha Jagadeesan, and Prakash Panangaden. Metrics for labelled markov processes. Theoretical Computer Science, 318(3):323 – 354, 2004.
Edsger Wybe Dijkstra. A Discipline of Programming. Prentice Hall PTR, Upper Saddle River, NJ, USA, 1st edition, 1976.
Ernst Doberkat. A stochastic interpretation of propositional dynamic logic: Expressivity. volume 77, pages 50–64, 01 2011.
R. M. Dudley. Real Analysis and Probability. Cambridge Studies in Advanced Mathematics. Cambridge University Press, 2 edition, 2002.
Ronald Fagin and Joseph Y. Halpern. Reasoning about knowledge and probability. In Proceedings of the 2Nd Conference on Theoretical Aspects of Reasoning About Knowledge, TARK ’88, pages 277–293, San Francisco, CA, USA, 1988. Morgan Kaufmann Publishers Inc.
Helle Hvid Hansen, Clemens Kupke, and Raul Andres Leal. Strong completeness for iteration-free coalgebraic dynamic logics. In IFIP International Conference on Theoretical Computer Science, pages 281–295. Springer, 2014.

Matthew Hennessy and Robin Milner. Algebraic laws for nondeterminism and concurrency. J. ACM, 32(1):137–161, 1985.
Helle Hvid Hansen and Clemens Kupke. Weak completeness of coalgebraic dynamic logics. Electronic Proceedings in Theoretical Computer Science, 191, 09 2015.
Nils Jansen, Benjamin Lucien Kaminski, Joost-Pieter Katoen, Federico Olmedo, Friedrich Gretz, and Annabelle McIver. Conditioning in probabilistic programming. Electr. Notes Theor. Comput. Sci., 319:199–216, 2015.
Dexter Kozen. Semantics of probabilistic programs. J. Comput. Syst. Sci., 22(3):328–350, 1981.
Dexter Kozen. A probabilistic pdl. Journal of Computer and System Sciences, 30(2):162 – 178, 1985.
Annabelle McIver and Carroll Morgan. Developing and reasoning about probabilistic programs in pGCL. In Ana Cavalcanti, Augusto Sampaio, and Jim Woodcock, editors, Refinement Techniques in Software Engineering, First Pernambuco Summer School on Software Engineering, PSSE 2004, Recife, Brazil, November 23-December 5, 2004, Revised Lectures, volume 3167 of Lecture Notes in Computer Science, pages 123–155. Springer, 2004.
Annabelle McIver, Carroll Morgan, Benjamin Lucien Kaminski, and Joost-Pieter Katoen. A new proof rule for almost-sure termination. PACMPL, 2(POPL):33:1–33:28, 2018.
Prakash Panangaden. Probabilistic relations. School of Computer Science Research Reports-University of Birmingham CSR, pages 59–74, 1998.
Prakash Panangaden. Labelled Markov Processes. Imperial College Press, London, UK, UK, 2009.
Roberto Segala. A compositional trace-based semantics for probabilistic automata. In Insup Lee and Scott A. Smolka, editors, CONCUR ’95: Concurrency Theory, pages 234–248, Berlin, Heidelberg, 1995. Springer Berlin Heidelberg.
Pedro Sanchez Terraf. Unprovability of the logical characterization of bisimulation. Information and Computation, 209(7):1048 – 1056, 2011.


A  Missing Proofs
Proof. [Lemma 4.7] The forward direction is easy, so we do not elaborate it here. As for the other direction, we apply Proposition 2.4. We first construct a LMP £ from X . £ has the action set A := P F?, where F? := {F ? | F ∈ F}. The state space (S, ΣS) of £ is the same as (X, ΣX ). For the transition functions, define:
ρP (s, A) := VP(P )(s, A)
  1	if VF(F )(s)=1 and s ∈ A


Then (X, ΣX, τa)a∈A is a LMP. In the rest of this proof let L0(A) be the simple logic L0 based on this new signature A. Then (S, ΣS, τa)a∈A is a model for L0(A). Suppose (X, x) ≡L1 (X, y). We claim that (£, x) ≡L0(A) (£, y). This is proved by a stronger result: for every L0(A) formula φ, there exists a L1 formula κ(φ) such that (£, x) ▶ φ if and only if (X, x) ▶ κ(φ). We reason by induction on the structure of L0(A) formulas.
For φ = T, we simply let κ(T)= T.
For φ = φ1 Λ φ2, we let κ(φ1 Λ φ2)= κ(φ1) Λ κ(φ1).
For L0(A) formula φ of the form ⟨P⟩rψ, we let κ(⟨P⟩rψ) be ⟨P⟩rκ(ψ).

For L0(A) formula φ of the form ⟨F ?⟩rψ, we let κ(⟨F ?⟩rψ) be F Λ κ(ψ).
We need to check that such κ indeed works. For example, (£, x) ▶ ⟨F ?⟩rψ is defined as ρF ?(x, {u ∈ S | (£, u) ▶ ψ}) > r. Note that rational number r takes value in [0, 1), so the inequality holds if and only if VF(F )(x)=1 and (£, x) ▶ ψ. Then by induction hypothesis we know that this is equivalent to that (X, x) ▶ F Λ κ(ψ).

Now apply Proposition 2.3 to (£, x) ≡
L0(A)
(£, y), and we know that (£, x) a0



if (£, x) a0
(£, y) under some LMP state bisimulation R, then R is also a state
s

bisimulation such that (X, x) a (X, y). We simply check the two conditions:
Let P ∈ P, and A ∈ ΣX be R-closed. Then by definition of LMP state bisimulation, we know that VP(P )(x, A)= ρP (x, A)= ρP (y, A)= VP(P )(y, A).
Let F ∈ F be a primitive function, and xj, yj be two states in X such that xjRyj. Note that VF(F )(xj) = 1 if and only if (£, xj) ▶ ⟨F ?⟩ 1 T. Also, R is a LMP state
2
bisimulation over £ implies that (£, xj) ≡L (A) (£, yj). In particular, (X, xj) ▶
⟨F ?⟩ 1 T if and only if (X, yj) ▶ ⟨F ?⟩ 1 T. Therefore VF(F )(xj)= VF(F )(yj).
	
2	2
In particular, according to the proof of Proposition 2.3 in [18], we know that ≡L1
is a state bisimulation on X .	2
Proof. [Lemma 5.7] We reason by induction on the structure of p.

p is empty string. Then Φ(Bˆ) := {Bˆ}. This is because
B (x) = B (y) if

and only if X,x ▶ B ⇐⇒ X,y ▶ B.
p is some primitive program P ∈ P. Then define
J )	J )

Φ(P ) := {⟨P⟩rBˆ | r is a rational number in [0, 1)}
To see that this Φ(P ) works, suppose that x and y agree on all formulas

in Φ(P )[B/Bˆ], but
⟨P⟩B (x) /=
⟨P⟩B (y). Without loss of generality, we

assume that ⟨P⟩B (x) <  ⟨P⟩B (y). Then there exists some rational number
(y). But this means that X,x /▶
r ∈ [0, 1) such that ⟨P⟩B (x) < r < ⟨P⟩B
⟨P⟩rB while X,y ▶ ⟨P⟩rB, contradicting the assumption that x and y agree on all formulas in Φ(P )[B/Bˆ].
p is some test B?. Then Φ(B?) := {B Λ Bˆ}. For arbitrary Boolean Bj, note

that ⟨B?⟩Bj
is {0, 1}-valued:
j	j



Therefore,
⟨B?⟩B (x)=1 ⇐⇒	B (x)= B  (x)=1 
⇐⇒ X,x ▶ B Λ Bj.
⟨B?⟩Bj (x) =  ⟨B?⟩Bj (y) if and only if x and y agree on the

formula B ΛJ Bj.	)	J	)
p = pj; B?. Let Φ(p) := {ψ[(B Λ Bˆ)/Bˆ] | ψ ∈ Φ(pj)}. Let Bj be an arbitrary PPDL] Boolean, and states x and y agree on all formulas in Φ(p)[Bj/Bˆ]. Then we know that for every ψ ∈ Φ(pj), x ▶ ψ[(B Λ Bj)/Bˆ] if and only if y ▶

ψ[(B Λ Bj)/Bˆ]. By induction hypothesis, this means that
⟨p ⟩(B Λ B ) (y), so ⟨p ; B?⟩B  (x)= ⟨p ; B?⟩B  (y).
p = pj; Q, where Q ∈ P. Let Φ(p) be the following set:
⟨pj⟩(B Λ Bj) (x)= 

{ψ[⟨Q⟩rBˆ/Bˆ] | ψ ∈ Φ(pj),r is rational number in [0, 1)}.
Let B be an arbitrary PPDL] Boolean, and x and y be two states that agree on all formulas in Φ(p)[B/Bˆ]. We add a new pseudo function symbol ⟨Q⟩rB, whose value at any state x is the same as the truth value of the L1 formula
⟨Q⟩r at state x. Then x and y also agree on Φ(p)[⟨Q⟩rB/Bˆ], for arbitrary
rational r ∈ [0, 1). By induction hypothesis, ⟨pj⟩⟨Q⟩rB(x) = ⟨pj⟩⟨Q⟩rB(y), for any rational r ∈ [0, 1). Note that

⟨pj⟩⟨Q⟩rB(x)= ∫

=


u∈X
j

Jp )(x, du)J⟨Q⟩rB)(u)


Jp )(x, J⟨Q⟩rB))


so we have
pj (x, ⟨Q⟩ B ) = pj (y, ⟨Q⟩ B ), for all rational numbers r ∈





⟨pj; Q⟩B(x)= 
u∈X
Jp )(x, du)JQ)(u, JB))

= lim
n→∞
n—1
pj (x, {u ∈ X | Q (u, B
i=0
i
) ∈ (     ,
n
i +1	i
]}) · 
n	n

in which every set {u ∈ X |
Q (u,
B ) ∈ (  i , i+1 ]} is exactly
⟨Q⟩ i+1 B \

J⟨Q⟩  i B). So
J )	J )	n	n


⟨pj; Q⟩B(x)
n—1
J	n	)

= lim ΣJpj)(x, J⟨Q⟩ i+1 B) \ J⟨Q⟩ i B))
= lim Σ(Jpj)(x, J⟨Q⟩ i+1 B)) − Jpj)(x, J⟨Q⟩ i B)))
= lim Σ(Jpj)(y, J⟨Q⟩ i+1 B)) − Jpj)(y, J⟨Q⟩ i B)))

= ⟨pj; Q⟩B(y)
2
