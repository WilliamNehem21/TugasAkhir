Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 319 (2015) 369–385
www.elsevier.com/locate/entcs

Complete Positivity and Natural Representation of Quantum Computations
Mathys Rennela1
Institute for Computing and Information Sciences Radboud University
Nijmegen, The Netherlands
Sam Staton2
Department of Computer Science Oxford University
Oxford, United Kingdom

Abstract
We propose a new ‘quantum domain theory’ in which Scott-continuous functions are replaced by Scott- continuous natural transformations.
Completely positive maps are widely accepted as a model of first-order quantum computation. We begin by establishing a categorical characterization of completely positive maps as natural families of positive maps. We explore this categorical characterization by building various representations of quantum compu- tation based on different structures: affine maps between cones of positive elements, morphisms of algebras of effects, and affine maps of convex sets of states. By focusing on convex dcpos, we develop a quantum domain theory and show that it supports some important constructions such as tensor products by quantum data, and lifting.
Keywords: Operator algebra, complete positivity, quantum computation, domain theory, convex set


Introduction
This paper is about semantic models of quantum computation. In common with other approaches to programming language semantics, the general idea is to inter- pret a type A as a space JA) of observations about A. One interprets a computation x : A ▶ t : B, that produces something t of type B but depends on something x of type A, as a predicate transformer JB) → JA), which maps a predicate on B to its weakest precondition. (See e.g. [4,18,3].)

1 Email: mathysr@cs.ru.nl
2 Email: sam.staton@cs.ox.ac.uk

http://dx.doi.org/10.1016/j.entcs.2015.12.022
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

In more detail, one interprets a type A as a C*-algebra of operators JA), and the computations describe maps that are in particular positive: it is actually only the positive elements of the algebra that describe the observables, and these must be preserved. Moreover the maps should be completely positive. Informally this means that it makes sense to run the computation on a subsystem of a bigger system; for example, we could adjoin an extra qubit to the system and still run the computation. More formally it means that not only does the map Jt) : JB) → JA) preserve positive elements, but also idJqubit) ⊗Jt) : Jqubit) ⊗ JB) → Jqubit) ⊗ JA) preserves positive elements.
The first contribution of this paper (Section 2) is a technique for building rep- resentations of quantum computation in terms of completely positive maps. In the second half of the paper (Section 3) we demonstrate our technique by making some first steps in the development of a ‘quantum domain theory’.

A technique for building representations
Here, a representation is a full and faithful functor F : C → R, that is, a functor for which each function FA,B : C(A, B) → R(F (A),F (B)) is a bijection.
From a programming language perspective, where objects interpret types and morphisms interpret programs, a representation result gives two things. Firstly, it gives a way of interpreting types as different mathematical structures, which can be illuminating or convenient, while retaining essentially the same range of interpretable programs. Secondly, since R may be bigger than C, it gives the chance to interpret more types without altering the interpretation of programs at existing types.
There are several existing representation results which allow us to understand and analyze quantum computations in terms of different structures, such as convex sets (e.g. [11]), domains (e.g. [18]), partial monoids and effect algebras (e.g. [10]). However, many of these representation results are only valid for positive maps, and so they do not fully capture quantum computation. Our contribution is a general method for extending these results to completely positive maps. Roughly, the method allows us to convert a full and faithful functor
(positive maps) −→ R
(where R is an arbitrary category) into a full and faithful functor
(completely positive maps) −→ [N, R]
into a functor category, where N is a category whose objects are natural numbers.

Towards a quantum domain theory
In the second part of the paper we demonstrate our technique by making some first steps in the development of a ‘quantum domain theory’. The ultimate goal in this line of work is to analyze all kinds of quantum programming by solving

domain equations involving qubits. For example, one should expect a solution to the equation
A = (qubit ⊗ A)⊥
which would be a type of infinite streams of qubits. In this paper we exhibit (for the first time) a domain theory that supports qubits and lifting.
In brief, we begin from the observation that taking states of a W*-algebra yields a representation of positive maps in terms of affine maps between convex sets. We use this to build a representation
(W*-algebras and completely positive maps) −→ [N, (convex sets and affine maps)]
We can now extend the representation with domain theoretic structure, by replacing convex sets with directed complete convex sets. Thus ‘quantum domains’ are defined to be functors
N → (convex dcpos and affine continuous maps)
and quantum computations are interpreted as affine Scott-continuous natural trans- formations between quantum domains. We show that this class of quantum domains supports various constructions, including tensor with quantum data and lifting.
Preliminaries
Linear maps of C*-algebras
The basic idea of matrix mechanics is that the observables for a quantum system are elements of a C*-algebra. Recall that a (unital) C*-algebra is a vector space over the field of complex numbers that also has multiplication, a unit and an invo- lution, satisfying associativity laws for multiplication, involution laws (e.g. x∗∗ = x, (xy)∗ = y∗x∗, (αx)∗ = α¯(x∗)) and such that the spectral radius provides a norm making it a Banach space.
A key source of examples of C*-algebras are the algebras Mk of k × k complex matrices, with matrix addition and multiplication, and where involution is conjugate transpose. In particular the set M1 = C of complex numbers has a C*-algebra structure, and the 2 × 2 matrices, M2, contain the observables of qubits.
If A is a C*-algebra then the k × k matrices valued in A also form a C*-algebra, Mk(A). For instance Mk(C)= Mk, and Mk(Ml) ∼= Mk×l. Informally, we can think of the C*-algebra Mk(A) as representing k entangled copies of A. This can be thought of as a kind of tensor product: as a vector space Mk(A) is a tensor product Mk(C) ⊗ A. There are various ways to extend this to define a tensor product on arbitrary C*-algebras, but we will not need tensor products other than Mk(A) in this paper.
The ‘direct sum’ X ⊕ Y of C*-algebras is given by the cartesian product of the underlying sets. It has the universal property of the categorical product. The C*-algebra C ⊕ C represents classical bits.

An element x ∈ A is positive if it can be written in the form x = y∗y for y ∈ A. We denote by A the set of positive elements of a C*-algebra A and define the following partial order on the elements of A: x ≤ y if and only if (y − x) ∈ A+.
We consider the following kinds of map of C*-algebras. Let f : A → B be a linear map between the underlying vector spaces.
P The map f is positive if it preserves positive elements and therefore restricts to a function A+ → B+. A positive map A → C will be called a state on A.
U The map f is unital if it preserves the unit, i.e. f (1A)= 1B;
SU The map f is sub-unital if f (1A) ≤ 1B;
CP The map f is completely positive if it is n-positive for every n ∈ N, i.e. the map Mn(f ) : Mn(A) → Mn(B) defined for every matrix [xi,j]i,j≤n ∈ Mn(A) by Mn(f )([xi,j]i,j≤n)= [f (xi,j)]i,j≤n is positive for every n ∈ N.
As a matter of convenience, we will denote through this paper different classes of maps by the first letters of the names of the properties they follow. In particular, the term (C)P((S)U)-map will refer respectively to a (completely) positive (sub-) unital map. We write C∗-AlgCPSU for the category of C*-algebras and completely positive sub-unital maps, and so on.
We refer the interested reader to [20,24] for a complete introduction to C*- algebras.
Representation of quantum computations
For the reader familiar with semantics of programming languages, we recall basic ideas for the semantics of quantum programming languages in C*-algebras. A type A is interpreted as a C*-algebra JA). A terminating computation-in-context x1 : A1,..., xn : An ▶ t : B is interpreted as a CPU-map B → i Ai, transforming observations about the result type to requisite observations about the free variables. We let Jqubit) = M2, and the empty tensor is C, and so a computation ▶ t : qubit that generates a qubit with no free variables is interpreted as a CPU-map M2 → C. In the theory of operator algebras, CPU-maps into C are called states.
Isometries and pure states
An important class of CP-maps comes from multiplication by matrices. Let A be a C*-algebra. Any m	n complex matrix F induces a CP-map F∗ F : Mm(A) Mn(A) given by (F∗ F )(x) = F∗xF , where F∗ is the conjugate transpose of F . This is a CPU-map if F is an isometry, i.e. F∗F = I. In particular, putting n =1 and A = C, any vector v ∈ C2 with v∗v = 1 induces a state v∗ v : M2 → C, called a ‘pure state’.
In what follows we will consider the vectors

 1 
 0 
 1  1 
 1   1 

|0⟩ =	0
|1⟩ =	1
|+⟩ = √2  1
|ρ⟩ = √2 −i

which all induce CPU-maps M2 → C. One often writes ⟨v| for the conjugate

transpose |v⟩∗, so the induced CPU-map can be written ⟨v| |v⟩ : M2(A) → A. In particular:
⟨0| a b |0⟩ = a	⟨+| a b |+⟩ = 1 (a + b + c + d)
⟨1| a b |1⟩ = d	⟨ρ| a b |ρ⟩ = 1 (a − ib + ic + d)
Naturality and representations of complete positivity
In this section, we will provide a new categorical characterization of completely pos- itive maps as natural families of positive maps (§2.1–§2.3). This gives a technique for building representations of completely positive maps (§2.3), which we demon- strate with several examples: positive cones (§2.4–2.5), effects (§2.6), and states (§2.7).
Complete positivity as naturality
In Section 1.3 we considered how a matrix F ∈ Cm×n induces a completely positive map F∗ F : Mm → Mn. This construction is functorial. To make this precise, we introduce the category NMat of complex matrices: the objects are non-zero natural numbers seen as dimensions, and the morphisms m → n are m×n complex matrices. Composition is matrix multiplication. (We remark that the category NMat is equivalent to the category of finite-dimensional complex vector spaces and linear maps, since every finite-dimensional vector space is isomorphic to Cn. It is also equivalent to the category of finite-dimensional Hilbert spaces and linear maps, since every such space has a canonical inner product.)
The construction of matrices of elements of a C*-algebra can be made into a functor C∗-AlgCP × NMat → C∗-AlgP. It takes a pair (A, m) to Mm(A) and a pair of morphisms (f, F ) : (A, m) → (B, n) to the positive map F (f )F : Mm(A) → Mn(B).
We will consider this functor in curried form, M : C∗-AlgCP → [NMat, C∗-AlgP]. It takes a C*-algebra A to a functor, i.e. an indexed family of C*-algebras, M (A)= 
{Mn(A)}n. A completely positive map f : A → B is taken to the corresponding family of positive maps M (f ) = {Mn(f ) : Mn(A) → Mn(B)}n. This gives our main result: the completely positive maps are in natural bijection with families of positive maps.
Theorem 2.1 The functor M : C∗-AlgCP → [NMat, C∗-AlgP] is full and faithful.
The rest of this section is dedicated to the proof of Theorem 2.1. Faithfulness is obvious, since for any CP-map f : A → B we have M (f )1 = f . To show fullness we begin with the following lemma.
Lemma 2.2 Consider two positive maps f2 : M2(B) → M2(A) and f1 : B → A of C*-algebras. The following conditions are equivalent:
∀y ∈ M2(B),v ∈ C2.  v∗(f2(y))v = f1(v∗yv)
f2 = M2(f1).

Proof. We can show that (ii) implies (i) with the following argument:
⎣c d⎦	2
v∗(M (f ) ⎡a b⎤)v = v∗ ⎡f1(a) f1(b)⎤ v = f (v∗ ⎡a b⎤ v)

2  1 ⎣c d⎦
⎣f (c) f (d)⎦
1	⎣c d⎦

since v∗ v maps a 2-by-2 matrix to a linear combination of its entries, which will be preserved by the linear map f1.
We will now focus on the proof that (i) =⇒ (ii).

⎡a b⎤
⎡aj bj ⎤
⎡a b⎤

Consider ⎣
⎦ ∈ M2(B), let ⎣
j⎦ = f2 ⎣
and suppose that (i) holds.
c d 

We use the assumption (i) with the vectors 0 , 1 , + and ρ , to obtain aj = f1(a), dj = f1(d), aj + bj + cj + dj = f1(a)+ f1(b)+ f1(c)+ f1(d) and aj  ibj + icj + d = f1(a) if1(b)+ if1(c)+ f1(d). We can combine these four facts to also deduce that bj = f1(b) and cj = f1(c).

And thus finally, we observe that f
⎡a b⎤ = ⎡f1(a) f1(b)⎤ = M (f ) ⎡a b⎤.

2 ⎣c d⎦
⎣f (c) f (d)⎦
2  1 ⎣c d⎦

This concludes our proof of Lemma 2.2.	2
We use Lemma 2.2 to establish fullness in our proof of Theorem 2.1. Consider a natural transformation f : M (A) ⇒ M (B), described by the following commuting diagram:
n	M (A)  fn zM,(B)

g
m, 
g⊗A
, 

g⊗B
, 
z,

Mm(A) fm
where g is a n-by-m complex matrix in NMat.
Mm(B)

As the map g can correspond to any pure state v∗ v : M2 → C, the con- dition (i) of Lemma 2.2 holds and therefore f2 = M2(f1). By induction, if f2k+1 = M2(f2k ) : M2k+1 (A) → M2k+1 (B) for some natural number k, then f2k+2 = M2(f2k+1 ) : M2k+2 (A) = M2(M2k+1 (A)) → M2(M2k+1 (B)) = M2k+2 (B)
since the condition (i) holds when one consider M2k+1 (A) as A and M2k+1 (B) as
B. Then M2k (f1)= f2k for every natural number k. It follows that the map f1 is 2k-positive for every k ∈ N. Finally, since n-positive maps are (n − 1)-positive (see Mn—1(B) as the left upper block of Mn(B) for n ≥ 1), one can conclude that f1 is a completely positive map, with Mn(f1)= fn for every natural number n.
So M : C∗-AlgCP → [NMat, C∗-AlgP] is a full functor. This concludes our proof of Theorem 2.1.

Variations on the characterization theorem
The proof of Theorem 2.1 is quite flexible and can accommodate some variation in the index category and the base category.
For a first variation, we change the index category so that we can focus on unit- preserving completely positive maps. We consider the subcategory NIsom of NMat with the same objects but where the morphisms are isometries (F∗F = I).
We will be quite general about the base category. Consider a subcategory V of
C∗-AlgP that is closed under matrix algebras, i.e.
C ∈ V	and	A ∈ V =⇒ Mn(A) ∈ V.	(1)
Then define VC to be the closure of V under matrices of morphisms: the objects of VC are the same as the objects of V, and a function f : A → B is in VC if Mn(f ): Mn(A) → Mn(B) is in V for all n. For instance, (C∗-AlgP)C = C∗-AlgCP.
Theorem 2.3 Consider a subcategory V of C∗-AlgP satisfying (1) and such that the matrices functor
VC × NIsom → C∗-AlgP
factors through V. It induces a full and faithful functor VC → [NIsom, V].
There are other variations on the result, by changing the index category to a dif- ferent subcategory of C∗-AlgCP. We focus on two examples which are particularly relavant in the enriched setting (see §2.4):
Let NCP be the category whose objects are natural numbers and where a mor- phism m → n is a completely positive map Mm → Mn. In the literature, this category is often called CPMs [15,3], W [21] or CPM[FdHilb] [22].
Let NCPU be the category whose objects are natural numbers and where a mor- phism m → n is a completely positive unital map Mm → Mn. The dual of this category can be thought of as comprising the trace-preserving completely positive

maps between density matrices (e.g. Qj
in [15, Def. 2.9]).

The matrices functors
C∗-AlgCP × NMat → C∗-AlgP	C∗-AlgCPU × NIsom → C∗-AlgPU
extend to functors
C∗-AlgCP × NCP → C∗-AlgP	C∗-AlgCPU × NCPU → C∗-AlgPU
using the idea that Mn(A)= Mn ⊗ A, and if f : Mm → Mn is completely positive then so too is f ⊗ A : Mm(A) → Mn(A).
Theorem 2.4 Consider a subcategory V of C∗-AlgP that is closed under matrix algebras (1) and such that the matrices functor
VC × NCP(U) → C∗-AlgP
factors through V. It induces a full and faithful functor VC → [NCP(U), V].

Representations of quantum computation
Our intention is to use Theorem 2.1 to build representation results for completely positive maps out of representation results for positive maps. For instance, the following corollary is immediate:
Corollary 2.5 Every full and faithful functor F : C∗-AlgP → R induces a full and faithful functor C∗-AlgCP → [NMat, C∗-AlgP] → [NMat, R].
For the remainder of this section we illustrate our technique by building repre- sentation theorems for CP-maps.

Example: positive cones of C*-algebras
We show how to build a representation for CP-maps out of affine maps between cones. We begin by recalling basic definitions. For any i ≤ m let δi,m be the Kronecker vector with δi,m = 1 and δi,m =0 for i /= j.
Definition 2.6 A cone is a set X together with an m-ary function (→r)X : Xm → X
for each vector →r = (r1 ... rm) of non-negative real numbers, often written infix as
Σ ri.xi, such that for each i, δi,m(x1,... xm) = xi, and for each m × n matrix
(si,j)i,j of non-negative real numbers,	i ri.(	j (si,j.xj)) =	j ((	i(ri.si,j)).xj).  A homomorphism of cones is a function that preserves the algebraic structure.
Homomorphisms are often called affine maps. The category Cone is the category of cones together with affine maps.
There are different ways to formulate this definition. A subset of a real vector space forms a cone if it is closed under addition and multiplication by positive real scalars, and conversely every cone arises in this way. This motivates the terminology ‘affine map’.
Alternatively, the abstract definition of cones can be reformulated in terms of scalar multiplication and binary addition, and all the m-ary operations can be built from these operations.

Representations
For any C*-algebra the positive elements form a cone.
Lemma 2.7 Taking the cone of positive elements yields a full and faithful functor
(−) : C -AlgP → Cone.
Proof. [notes] Any positive map f : X → Y is completely defined by its action on X+: an arbitrary element x ∈ X can be written as a linear sum of four positive elements x = x1 + ix2 − x3 − ix4, for xi all positive [7, Lemma 2.2], determining the value f (x), which does not depend on a particular decomposition of x.	2
Example 2.8 The functor C∗-AlgCP → [NMat, Cone] taking A to n '→ (Mn(A))+ is full and faithful.

This appears to be a new categorical way to formulate the theory of matrix ordered spaces (e.g. [6], [17, Ch. 13]).

Enrichment
Example 2.9 The functor C∗-AlgCP → [NCP, Cone] taking A to n '→ (Mn(A))+ is full and faithful.
The category NCP is enriched in Cone: one can scale completely positive maps and add them too. This leads us to focus on locally affine functors F : NCP → Cone, i.e., functors that preserve the cone structure of the hom-sets, i.e., enriched presheaves [5].
The category of locally affine functors NCP → Cone is the free colimit com- pletion of NCP as a Cone-enriched category. This draws a comparison with other models of quantum computation, which partly inspired the current work. Firstly there are models based around biproduct completions of NCP (e.g. [21] and [16]); this is relevant since a biproduct completion is a free coproduct completion of NCP as a Cone-enriched category. Secondly there are models based around (non-enriched) colimit completions of categories such as NCPU [15].
Example: Directed complete cones and W*-algebras
Directed-completeness
Recall that a directed complete partial order is a partial order in which every directed set has a least upper bound. A bounded dcpo (bdcpo) is a partial order in which every directed set that has an upper bound has a least upper bound.
Definition 2.10 A conic bdcpo (or d-cone) is a cone X (Def. 2.6) equipped with a bdcpo structure such that the operations (→r)X : Xm → X are all Scott-continuous functions from the product bdcpo. This yields a category dCone of conic bdcpos and affine Scott-continuous maps between them.
Definition 2.11 A C*-algebra A is called monotone complete if the cone A+ of positive elements is a conic bdcpo. A positive map between monotone complete C*-algebras A → B is called normal if its restriction to the positive cone preserves joins of bounded directed sets.
We will focus on W*-algebras, which are monotone complete C*-algebras such that for every non-zero positive element x ∈ A+ there is a normal positive map f : A → C such that f (x) /= 0 (e.g. [24, III.3.16]). W*-algebras encompass all finite dimensional C*-algebras, and also the algebras of bounded operators on any Hilbert spaces, the function space L∞(X) for some standard measure space X, and the space l∞(N) of bounded sequences.
We write W∗-AlgP for the category of W*-algebras and normal positive maps, and W∗-AlgCP for the category of W*-algebras and normal completely positive maps, and so on. Essentially by definition we have a full and faithful functor (−) : W -AlgP → dCone. In consequence:

Example 2.12 The functor W∗-AlgCP → [NMat, dCone] taking A to n '→
(Mn(A))+ is full and faithful.
Examples: Effects
We briefly discuss examples based on the theory of effects of C*-algebras, although we will not elaborate on this any further in this article.
An effect of a C*-algebra is a positive element that is less than 1. Informally, an effect is a kind of ‘unsharp’ predicate. The effects [0, 1]A of a C*-algebra A form an algebraic structure called an ‘effect module’: they have a partial monoid structure given by addition, a top element, and they admit multiplication by scalars in the unit interval [0, 1].
Taking effects actually yields a full and faithful functor C∗-AlgPU → EMod
(see e.g. [7]), giving us another illustration of our framework:
Example 2.13 The functor C∗-AlgCPU → [NIsom, EMod], taking A to n '→
[0, 1]Mn(A), is full and faithful.
There are some interesting variations on this example.
Example 2.14 • A ‘generalized effect module’ is an effect module without a top element. By ignoring the top effects we obtain a full and faithful functor C∗-AlgPSU → GEMod [7] and hence a full and faithful functor C∗-AlgCPSU → [NIsom, GEMod].
In a W*-algebra, the effects form a directed complete effect module; this gives a full and faithful functor W∗-AlgPU → dEMod [18] and hence we obtain a new full and faithful functor W∗-AlgCPU → [NIsom, dEMod].
Similarly, from a full and faithful functor W∗-AlgPSU → dGEMod [18] we obtain a full and faithful functor W∗-AlgCPSU → [NIsom, dGEMod].
Examples: States
Convex sets
Definition 2.15 A convex set is a set X together with an m-ary function (→r)X :
Xm → X for each vector →r = (r1 ... rm) of non-negative real numbers with	i ri =
1, such that for each i, δi,m(x1,... xm) = xi, and for each m × n matrix (si,j)i,j

X
of non-negative real numbers such that
Σj ((Σi(ri.si,j)).xj).
Σj si,j = 1, we have
Σi ri.(
Σj (si,j.xj)) =

A homomorphism of convex sets is a function that preserves the algebraic struc-
ture. Homomorphisms are often called affine maps.
The definition of convex sets can be reformulated in terms of a weighted binary addition (e.g. [14]). For example, a subset of a real vector space is convex if it is closed under convex sums.
For	a	W*-algebra	A,	consider	the	normal	state	space	NS(A)	=
W∗-AlgPU(A, C). The hom-sets of the category W∗-AlgPU can be given a con-

vex structure, considered as a subset of the vector space of all linear maps. The mapping NS(−) can thus be turned into a contravariant functor to the category of convex sets, which acts as follows on positive unital maps: NS( A   f  zB,) = 
(−) ◦ f : NS(B) → NS(A).
Theorem 2.16 ([20],[2],[8]) The functor NS(−) : W∗-Algop → Conv is full
and faithful.
(The normal states functor is not faithful when restricted to completely positive

maps (W∗-Algop
): the transpose map is positive but not completely positive,

and it yields an isomorphism of convex sets.)

Example 2.17 The functor W∗-Algop
→ [NIsom
, Conv], taking A to n '→

NS(Mn(A)), is full and faithful.
Example 2.18 The functor W∗-Algop	→  [N	, Conv], taking A to n '→
CPU
NS(Mn(A)), is full and faithful.

Quantum domain theory
In this section, we will use the techniques in Section 2 to begin to build a ‘quantum domain theory’: a new categorical model for quantum computations based on order- valued functors.
We proceed by analogy with classical domain theory. Recall that in classical domain theory there are two categories that play important roles: firstly a category Predom of dcpos and Scott-continuous functions, and secondly a category Dom! of pointed dcpos (dcpos with a bottom element) and strict Scott-continuous functions (functions that preserve the bottom element). Lifting (freely adding a bottom element) is left adjoint to the evident forgetful functor (e.g. [1]).

Preliminaries on convex dcpos
Definition 3.1 A convex dcpo is a convex set (Def. 2.15) equipped with a dcpo structure such that the functions that constitute its convex structure are Scott- continuous. This yields a category dConv of convex dcpos and affine Scott- continuous maps between them.
A simple example of a convex dcpo is the unit interval of the reals.

Sums of convex dcpos
Recall that the sum A + B of two convex sets, A and B, can be described as the set A B (A × B × (0, 1)), where (0, 1) is the open unit interval. Its elements either come directly from A, or from B, or are a non-trivial formal convex combination of elements from A and B. With a slightly informal notation, we write (a, −, 0)

instead of a, and (−, b, 1) instead of b. Then define the convex structure as follows


Σ	def Σ  ri(1 − λi) 
Σ  riλi  	Σ

ri.(ai, bi, λi) = ( 

1 − Σ
r λ .ai,
Σ r λ .bi, (
i riλi))


taking the obvious convention where ( i riλi) is 0 or 1. This has the universal property of the coproduct in the category of convex sets.

Skew sums
There is a variation on the sum that will be useful in what follows. To motivate, observe that if A and B are partial orders then we can form a new partial order A <+ B whose carrier is A + B but with the partial order generated by a ≤A +B aj whenever a ≤A a , and b ≤A +B b whenever b ≤B b , and a ≤A +B b whenever a ∈ A
and b ∈ B. We call this the skew sum. It gives a universal square

A × B

A ¸r ≤
A <+ B
tB¸


If A and B are convex dcpos then we define a skew sum A <+ B as the coproduct of convex sets, but with the partial order (a, b, λ) ≤ (aj, bj, μ) if a ≤ aj and b ≤ bj and λ ≤ μ. This has a universal property like a coproduct except with an additional requirement that a ≤ b for a ∈ A, b ∈ B.
For example, we can freely add a bottom element to a convex dcpo A by taking the skew sum (1 <+ A).

Abstract deﬁnitions of quantum domains
Our definition of quantum domain is inspired by Example 2.18. Recall that NCPU
is the category of natural numbers and where a morphism m → n is a CPU-map
(§ 2.3). A functor D : Nop	→ dConv is ‘locally affine’ if D preserves the convex
structure of morphisms, i.e. D(r.f + s.g)= r.D(f )+ s.D(g) whenever r + s = 1.
Definition 3.2 A quantum predomain is a locally affine functor D : Nop	→

dConv. A quantum domain is a locally affine functor D : Nop
CPU
→ dConv such

that the convex dcpo D(1) has a least element.

A morphism of quantum (pre)domains, which will be called a QD-map, is a natural transformation φ : D ⇒ E between quantum (pre)domains, i.e. a family of continuous affine maps {φn : D(n) → E(n)}n∈N such that, for every map f : n → m

in NCPU, the following diagram commutes:
n	D(n)  φn zE,(n)

¸¸
f	D(f )
¸¸
E(f )

m, 
D(m)
φm zE,(m)

If D is a quantum domain, i.e. D(1) has a least element, then we say that a QD-map φ : D → E is strict if φ1(⊥D(1)) is a least element in E(1).
We define QDom to be the full subcategory of QPredom comprising quantum domains, and QDom! to be the subcategory of QPredom comprising quantum domains and strict QD-maps. Those three categories are enriched over the category Dcpo of dcpos together with Scott-continuous maps.
For a motivating example, recall (Ex. 2.18) that every W*-algebra A induces a
functor NS(A): Nop	→ Conv with NS(A)(n)= W -AlgCPU(Mn(A), C). This
can be understood as a quantum predomain, where each NS(A)(n) is considered
with a discrete order. In particular NS(C) ∼= NCPU(−, 1). This gives an embedding
∗	op
NS : W -AlgCPU → QPredom.
Construction of quantum domains
Sums of quantum predomains
The coproduct of quantum predomains is defined pointwise. We define the sum of two quantum predomains D and E pointwise: let (D + E)(n) = D(n)+ E(n) for n ∈ N. This has the universal property of the coproduct in QPredom.
The embedding W∗-Algop	→ QPredom preserves sums. This follows from

∗	op
CPU
~	∗	op
∗	op

two facts: first, W -AlgCPU(A ⊕ B, C) = W -AlgCPU(A, C)+ W -AlgCPU(B, C)
(e.g. [11, Prop. 16]) and second, Mn(A⊕B) = Mn(A) ⊕Mn(B), for all W*-algebras
A and B.
Tensor with quantum data, aka copower
For every quantum predomain D, one can define a quantum predomain (n ⊙ D) by (n⊙ D)(m)= D(nm) for every natural number n ∈ N and (n⊙ D)(f )= D(Mn(f ))
for f : m → p in Nop . In particular (2 ⊙ D) can be thought of informally as a
predomain of entangled pairs (x, d) where x is a qubit and d is from D.
We can build a functor
⊙ : NCPU × QPredom → QPredom.
This has the universal property of ‘copower by representables’ (see e.g. [12]).
Lifting via skew sums
We can also define a pointwise skew-sum of quantum predomains. For quantum predomains D and E, as a quantum predomain D + E with (D <+ E)(n)= D(n) <+

E(n) for n ∈ N. This has the universal property of the skew coproduct (§3.1.2) in
QPredom.
We use the skew coproduct to define a way of lifting quantum predomains to quantum domains.  Let D⊥ = NS(C) <+ D.  In more detail, D⊥(n) = W∗-AlgCPU(Mn, C) <+ D(n). Since (NS(C))(1) = 1 we know that D⊥(1) has a least element for any quantum predomain D.

Proposition 3.3 The construction (−)⊥ : QPredom → QDom! is left adjoint to the forgetful functor QDom! → QPredom.


QDom! ,,
U	z¸
QPredom
(—)⊥

Moreover the adjunction is Dcpo-enriched. Proof. Consider δ : D ⇒ E and η : D⊥ ⇒ E.
Firstly, one can define a strict QD-map δ∗ : D⊥ ⇒ E as a natural family of maps δ∗(n) : D⊥(n) = W∗-AlgCPU(Mn, C)+ D(n) → E(n), where δ∗(n) : (ϕ, x, λ) '→ (ϕ, δ(n)(x), λ) for every n ∈ N.
Secondly, one can define a QD-map η∗ : D ⇒ E as a natural family of maps
η∗(n): D(n) → E(n), where η∗(n): x '→ η(−, x, 1) for every n ∈ N.
The Scott-continuous maps of hom-sets, (−) : QPredom(D, U (E)) → QDom!(D⊥, E) and (−)∗ : QDom!(D⊥, E) → QPredom(D, U (E)), are inverse of each other.	2
Relationship with the L¨owner order and earlier work
We conclude by relating these steps in quantum domain theory with earlier work on using operator algebra to model quantum computation.
To make an analogy, we recall the basic adjunction between the category Set of sets and functions and the category Pfn of sets and partial functions.
identity on objects

Set ,,
( )+1
 P¸fn

Partial functions can be thought of as first-order computations, and indeed each hom-set forms a dcpo. However, the adjunction is not enriched in dcpos. Thus, although there is a notion of lifting it does not properly capture partiality. The set A + 1 captures the notion of ‘programs that either return something of type A or diverge’, but the order structure associated with partiality is not captured in this

set. To remedy this, one embeds this adjunction into one involving domains
identity on objects

Set ,,

flat predomain
, 
Predom ,,

( )+1

( )⊥ forgetful
 P¸fn
flat domain
, 
Dom!

where the lower adjunction and the right-hand embedding are dcpo-enriched.
Now, we also have an adjunction between W∗-AlgCPSU and W∗-AlgCPU:
identity on objects

W∗-AlgCPU ,,
( )⊕C
zW¸∗-AlgCPSU

which has been proposed for studying quantum computation. The hom-sets of W∗-AlgCPSU are dcpos, under the L¨owner order: f ≤ g if g — f is completely positive. Again, however, the adjunction is not dcpo-enriched. This time, the W*- algebra A ⊕ C captures the notion of ‘programs that either return something of type A or diverge’, but again the order structure associated with partiality is not captured in this algebra. Our proposal for quantum domains resolves this since there is an embedding
identity on objects

W∗-AlgCPU ,,

NS 
, 
QPredom ,,

( )⊕C

( )⊥ forgetful
zW¸∗-AlgCPSU
NS( )⊥
, 
QDom!

where the right-hand embedding is dcpo-enriched and so is the lower adjunction.
3.5  Next steps for quantum domain theory
We have demonstrated that our representation techniques can be used to build a quantum domain theory that supports lifting and tensor products by quantum data. We conclude by mentioning some next steps in this direction.
Each quantum predomain of the form N£(A) has some extra structure. For example, the block diagonal function A ⊕ A → M2(A) between W*-algebras gives a QD-map 2 ⊙N£(A) → N£(A)+ N£(A). This can be thought of as measuring a qubit in the standard basis, returning a classical bit. This algebraic structure has been axiomatized in [23]. It seems likely that it would be helpful to require this structure on all quantum domains.
Some authors impose additional conditions on d-cones and convex dcpos (see e.g. [13,14]). In this article we are focusing on morphisms, rather than objects, but

we suppose that extra conditions will be relevant in future work on semantics of quantum programs.
In earlier work [19] the first author has shown that the category W∗-AlgCPSU is algebraically complete, and so supports the solution of recursive domain equations. An important next step is to investigate whether this result extends to quantum domains.
It would also be interesting to investigate connections to other models of higher- order quantum computation [9].

Summary
In the first part of the paper, we have characterized the notion of complete positivity in a natural way. This abstract setting can be used as a way of extending the logical and semantical properties of positive maps to completely positive maps. In the other half of the paper, we have shown that W*-algebras are order- valued presheaves on a category of qubits, and normal completely positive maps are natural transformations between W*-algebras, seen as order-valued presheaves. We have exposed some of the categorical properties of those presheaves. We argue that our presheaves are a suitable generalization of W*-algebras when it comes to
denotational semantics of quantum programs.
Acknowledgment
We would like to thank Kenta Ch¯o, Robert Furber, Tobias Fritz, Bart Jacobs, Klaus Keimel and Phil Scott for helpful discussions, and the anonymous referees for their suggestions. This research has been financially supported by the European Research Council (ERC) under the QCLS grant (Quantum Computation, Logic & Security) and a Royal Society University Research Fellowship.

References
S. Abramsky, A. Jung, “Domain Theory”, Handbook of logic in computer science 3, pp. 1-168, 1994.
E.M. Alfsen, F.W. Shultz, “State spaces of operator algebras: basic theory, orientations and C*- products”, Birkha¨user, 2001.
K. Cho, “Semantics for a Quantum Programming Language by Operator Algebras”, in B. Coecke, I. Hasuo, P. Panangaden, Proceedings of the 11th workshop on Quantum Physics and Logic, EPTCS 172,
pp. 165-190, 2014.
E. D’Hondt, Prakash Panangaden. “Quantum weakest preconditions”. Mathematical Structures in Computer Science 16(3): 429-451, 2006.
B. J. Day. “Construction of biclosed categories”, PhD thesis, University of New South Wales, 1970.
E. G. Effros & Z.-J. Ruan, “Operator spaces”, London Mathematical Society monographs 23, Clarendon Press, Oxford, 2000.
R. Furber, B. Jacobs, “From Kleisli categories to commutative C*-algebras: Probabilistic Gelfand Duality”, in R. Heckel, S. Milius, Algebra and Coalgebra in Computer Science, pp. 141-157, Springer Berlin Heidelberg.
R. Furber, PhD thesis, forthcoming.


I. Hasuo & N. Hoshino, “Semantics of Higher-Order Quantum Computation via Geometry of Interaction”, in 26th Annual IEEE Symposium on Logic in Computer Science (LICS) (pp. 237-246), p. 237-246, IEEE Computer Society, 2011.
B. Jacobs, “New Directions in Categorical Logic, for Classical, Probabilistic and Quantum Logic”, arXiv preprint arXiv:1205.3940, 2012.
B. Jacobs, B. Westerbaan, B. Westerbaan, “States of convex sets”, in A. Pitts, Foundations of Software Science and Computation Structures, Lecture Notes in Computer Science 9034, pp. 87-101, Springer Berlin Heidelberg, 2015.
G. Janelidze and G.M. Kelly. “A Note on Actions of a Monoidal Category”, Theory and Applications of Categories 9(4), pp.61-91, 2001.
C. Jones, G. D. Plotkin, “A probabilistic powerdomain of evaluations”, Proceedings of the Fourth Annual Symposium on Logic in computer science, pp.186-195, 1989.
K. Keimel, G. D. Plotkin, “Mixed powerdomains for probability and non-determinism”, to appear in Logical Methods in Computer Science, 2015.
O. Malherbe, P. Scott, P. Selinger, “Presheaf models of quantum computation: an outline”, in B. Coecke,
L. Ong, P. Panangaden, “Computation, Logic, Games, and Quantum Foundations. The Many Facets of Samson Abramsky”, Lecture Notes in Computer Science Volume 7860, pp. 178-194, 2013.
M. Pagani, B. Valiron, P. Selinger, “Applying quantitative semantics to higher-order quantum computing”, In Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 2014), San Diego, ACM SIGPLAN Notices 49(1), pp. 647-658, 2014.
V. Paulsen, “Completely bounded maps and operator algebras”, Cambridge Studies in Advanced Mathematics 78, 2003.
M. Rennela, “Operator Algebras in Quantum Computation”, Master thesis, 2013.
M. Rennela, “Towards a Quantum Domain Theory: Order-enrichment and Fixpoints in W*-algebras”, in B. Jacobs, A. Silva & S. Staton, Proceedings of the 30th Conference on the Mathematical Foundations of Programming Semantics (MFPS XXX), Electronic Notes in Theoretical Computer Science 308, pp. 289-307, 2014.
S. Sakai, “C*-algebras and W*-algebras”, Springer-Verlag, 1971.
P. Selinger, “Towards a quantum programming language”, Mathematical Structures in Computer Science 14, pp. 527-586, 2004.
P. Selinger, “Dagger compact closed categories and completely positive maps”, In P. Selinger, Proceedings of the 3rd International Workshop on Quantum Programming Languages (QPL 2005), Chicago, Electronic Notes in Theoretical Computer Science 170, pp.139-163, Elsevier, 2007.
S. Staton. “Algebraic effects, linearity, and quantum programming languages”, in Proceedings of 42nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 2015), pp. 395-406, 2015.
M. Takesaki, “Theory of operator algebras Vol. 1”, Springer, 2002.
