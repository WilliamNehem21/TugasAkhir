Electronic Notes in Theoretical Computer Science 136 (2005) 203–227 
www.elsevier.com/locate/entcs


Intersection and Union Types for X

Steffen van Bakel
Department of Computing, Imperial College London, 180 Queen’s Gate, London SW7 2BZ, UK, svb@doc.ic.ac.uk


Abstract
This paper presents a notion of intersection and union type assignment for the calculus X , a substitution free language that can be used to describe the behaviour of functional programming languages at a very low level of granularity, and has first been defined in [14,5]. X has been designed to give a Curry-Howard-de Bruijn correspondence to the sequent calculus for classical logic.
In this paper we will define a notion of sequent-style intersection type assignment on X that needs union types, and show that this notion is closed for both subject-reduction and subject-expansion. We will also show that it is an extension of the Strict system for lc.
Keywords: Intersection types, union types, conditional rewriting, classical logic


Introduction
This paper will present a notion of intersection and union type assignment for the (untyped) calculus X , as first defined in [14] and later extensively studied in [5]. The origin of X lies within the quest for a language designed to give a Curry-Howard-de Bruijn correspondence to the sequent calculus for Classical Logic. X is defined as a substitution-free programming language that, perhaps surprisingly, is extremely well equipped to describe the behaviour of functional programming languages at a very low level of granularity (see [14,5]).
The Curry-Howard property strongly links typeable programs and provable theorems, and can be understood as follows:
(Curry-Howard isomorphism) “Terms as Proofs, Types as Propositions.” Let
M be a term, and A a type, then M is of type A if and only if A, read as a
1 Email: svb@doc.ic.ac.uk
1571-0661 © 2005 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2005.06.009


logical formula, is provable in the corresponding logic, using a proof which structure corresponds to M.
A sequent style implicative classical logic can be defined by:


(Ax) : Γ,A ▶ A, ∆	(cut) : Γ ▶ A, ∆	Γ,B ▶ ∆
Γ ▶ A, ∆	Γ,A ▶ ∆ Γ ▶ ∆
Γ,A ▶ B, ∆

(LI) : 
Γ, A→B ▶ ∆
(RI) : 


Γ ▶ A→B, ∆


Starting from different approaches in that area [10,15], in [14] the calculus X was introduced, and shown to be equivalent to the λµµ˜-calculus of [10] in terms of expressivity. Using this correspondence, a strong normalization result is shown for λµµ˜. In fact, [14] did not study any property of untyped X, but focused only on its type aspects in connection with the sequent calculus.
As far as the Curry-Howard isomorphism is concerned, X stands out in that it is the first calculus to achieve that in full for a classical logic. For example, in λµµ˜, all provable propositions can be inhabited, but not all terms correspond to proofs, and in λµ, not all proofs can be represented, since there reduction is confluent.
When studying X as an untyped language, soon the unexpected special properties surfaced: it became apparent that X provides an excellent gen- eral purpose machine, very well suited to encode various calculi (for details, see [5]). Amongst the calculi studied in that paper, the Calculus of Explicit Substitutions λx stands out. In fact, a ‘subatomic’ level was reached by de- composing explicit substitutions into smaller components. Even more, the
calculus is actually symmetric [7]; the ‘cut ’, represented by Pα † xQ repre-
sents, in a sense, the explicit substitution of P for x in Q, but also that of Q
for α in P .
Perhaps the main feature of X is that it constitutes a variable and sub- stitution-free method of computation. Rather than having variables like x representing places where terms can be inserted, in X the symbol x represents a socket, to which a term can be attached. The definition of reduction on X shows nicely how the interaction between the two subtly and gently percolates
through the terms.
Although the origin of X is a logic, and one could expect it to be close to lc, it is in fact specified as a conditional term rewriting system; the only non-standard aspect is that it treats three different classes of variables (for plugs, sockets, and nets).
In this paper we will treat X as a pure, untyped calculus, and ignore its origin


in that we define a notion of sequent-style intersection type assignment on X ; intersection types are notorious for lacking a solid background in logic. We will see that, in view of the special nature of X as an input-output calculus, we will need to add also union types. The notion of intersection type assignment for X as defined in this paper is inspired by the system of [12] (the precise relation between the two –through the interpretation functions as defined in [14,5]– needs to be studied, and is left for further research).
It is a conservative extension of the Strict Intersection Type Assignment System of [1] (see also [2,3]), in that lambda terms typeable in that system translate to X -nets, while preserving the type. It is also a natural extension of the system considered in [5], i.e. the basic implicative system for Classical Logic, but extended with (strict) intersection and union types and the type constant T. The main results of this paper are that this notion is closed for both subject-reduction and subject-expansion.
As was the case for systems with intersection types for lc [9,2], in order to get a notion of type assignment that is closed for η-reduction, we would need to introduce a ≤-relation on types which is contra-variant in the arrow; this is not part of the present system.
This paper is constructed as follows. Section 1 presents the syntax and reduction system of the calculus X . In Section 2 we define the basic system of type assignment for X, then in Section 3 we will embed lc into X and discuss η-reduction, and, in Section 4, present the Strict Intersection System for lc. Then, in Section 5, we will define a notion of type assignment on X that uses strict intersection and union types, give an extended example, and show that type assignment in the strict system is preserved by the translation of lc into
X. Finally, in Section 6, we will show that the notion of type assignment introduced in this paper is closed for both subject-reduction and expansion, but not for η-reduction.


The X -calculus
In this section we will give the definition of the X -calculus, that was proven to be a fine-grained implementation model for various well-known calculi in [5]. Its features two separate categories of ‘connectors’, plug and socket, that act
as input and output channel, and is defined without a notion of substitution (implicit or explicit).

Definition 1.1 [Syntax] The nets of the X -calculus are defined by the fol- lowing syntax, where x, y,... range over the infinite set of sockets, and α, β


over the infinite set of plugs.

P, Q ::= ⟨x.α⟩ | y^P β^ · α | P β^ [y] x^Q | P α^ † x^Q


In this definition, the ˆ· symbolizes that the socket or plug underneath is bound in the net. The free sockets fc(P ) and free plugs fs(P ) in a net P are defined as usual. The set of free connectors is the union of those of free sockets and plugs: fc(P ) = fs(P )∪fp(P )
A connector (socket or plug) which is not free is called bound. We will,
as usual, identify porcesses that only differ in the names of bound connectors (α-conversion).
We use the following terminology for our nets: ⟨x.α⟩ is called a capsule,
(yP β · α) an export net, (P β [y] xQ) a mediator, and (P α † xQ) a cut.
Diagrammatically, we represent these nets as:


 x)α 

vα
 α) x


The nets of X can be seen as a collection (heap) of wires (streams, strings), each with an input and an output. When two heaps interact, they do so through one input and one output name only, that are bound in the interac- tion. This interaction can be possible via a net like (P α † xQ) that expresses an active computation; it will try to connect the wires ending with α in the
heap called P to the wires beginning with x in the heap called Q. On the other hand, they can be bound as in (P β [y] xQ), which expresses two heaps that try to connect the wires ending with β and beginning with x, but that need another heap to mediate between them; this new net will need to interact via the input name y (which might appear in P and Q as well). Also, a heap P that is willing to interact via the names y and β can itself be made available (exported) via the name α, as in (yP β · α).
At any given moment, all names of unconnected inputs and outputs in a heap make up the collection of free names, that are inactive during the computational step; the bound names are all involved in some interaction.
The calculus, defined by the reduction rules below, explains in detail how cuts are distributed through nets to be eventually evaluated at the level of capsules. Reduction is defined by giving how the basic syntactic structures that are well-connected interact, and specifies how to deal with propagating active nodes in the computation to points where they can interact.

Definition 1.2 [Reduction: Logical rules] (var) :	⟨y.α⟩α † x⟨x.β⟩ → ⟨y.β⟩
(exp) :	(yP β · α)α † x⟨x.γ⟩ → yP β · γ,	α /∈ fp(P )


(ins) : (y^P β^ · α)α^ † x^(Qγ^ [x] z^P ) →
Qγ † y(P β † zP ) (Qγ † yP )β † zP
α /∈ fp(P ),x /∈ fs(Q, P )


The first three logical rules above specify a renaming (reconnecting) pro- cedure, whereas the last rule specifies the basic computational step: it links a function, available over the unique plug α, to an open adjacent mediator position in the net that ports the unique socket x.
We now extend the syntax with two flagged, or active cuts:
P ::= ... | P1α^	x^P2 | P1α^	x^P2
Terms constructed from the restricted syntax without those flagged cuts are called pure (the diagrammatical representation of flagged cuts is the same as that for unflagged cuts). These flagged cuts either reduce to normal cuts when dealing with a capsule, or are propagated through the net.
Definition 1.3 [Reduction: Activating the cuts] We define the following two activation rules.




where:
(act-l) : Pα † xQ → Pα
(act-r) : P α  † xQ → P α
xQ if P does not introduce α Q if Q does not introduce x

	introduces x Either P = P α [x] yQ, and x does not occur free in P, Q, or P = ⟨x.δ⟩.

P introduces δ Either P =
P = ⟨x.δ⟩.
x^Qβ^ · δ, and δ does not occur free in Q, or

The activated cuts (obtained from cuts to which the logical rules cannot be applied) are introduced to obtained a fine-tuned reduction system. An activated cut is processed, by ‘pushing’ it, systematically, in the direction indicated by the tilting of the dagger, through its syntactic structure, until a cut is created that involves a capsule. The cut is then deactivated, such that a logical rule can be applied or, else, the ‘pushing’ can go on, but now in the other direction.


Definition 1.4 [Reduction: Propagation rules] Left propagation


(dl) :	⟨y.α⟩α
xP → ⟨y.α⟩α † xP

(l1) :	⟨y.β⟩α
'
x^P → ⟨y.β⟩^	^
β /= α

(l2) :	(yP β · α)α
(l3) :	(y^P β^ · γ)α^
xP → (y(P α
^P → y^(P α^
xP )β · γ)γ † xP ,	γ fresh
x^P )β^ · γ, γ /= α

(l4) : (Qβ^ [z] y^P )α^
Right propagation
xP → (Qα x^P → (Qα^
xP )β [z] y(P α	xP )
x^P )β^ † y^(P α^	x^P )



(dr) : Pα
(r1) : P α
x⟨x.β⟩	→ Pα † x⟨x.β⟩
x^⟨y.β⟩	→ ⟨y.β⟩

y /= x

(r2) : P α
x^(y^P β^ · γ)	→ y^(P α^	x^P )β^ · γ

(r3) : P α
x^(Qβ^ [x] y^P ) → P α^ † z^((P α^	x^Q)β^ [z] y^(P α^	z fresh

(r4) : P α	x(Qβ [z] yP ) → (P α	xQ)β [z] y(P α	xP )	z /= x
(r5) : P α^	x^(Qβ^ † y^P ) → (P α^	x^Q)β^ † y^(P α^	x^P )
We write → for the (transitive, compatible) reduction relation that only re-
duces active cuts (and those to which the logical rules can be applied).
Although the origin of X is a logic, and one could expect it to be close to lc, it is in fact specified as a conditional term rewriting system; the only non-standard aspect is that it treats three different classes of variables (for
plugs, sockets, and nets). The implications of this observation are left for further research; a first result can be found in [6].
The rules (l2) and (r3) deserve some attention. Here the exposed oc- curence of the plug α (socket x) need not be the only one. The cut wants to
connect all its occurences to the corresponding socket (plug), so, first all other occurences, i.e. not to top one, are eliminated (notice that reducing the cut will erase the bound connectors), at the end of which the remaining occurence is now introduced in the term, and can be dealt with (if the other side of the
cut is of the right shape). We rename to avoid α (x) to occur both bound and free; but, in fact, no confusion is possible, so the α-conversion here is almost cosmetical.
The reduction relation → is not confluent; this comes in fact from the critical pair that activates a cut P α † xQ in two ways if P does not introduce α and Q does not introduce x. When activating according to the first criterium, the reduction will connect the wires in P that end with α with the wires from Q that begin with x; if α does not appear in P , this will return P . When using the second, the reduction will connect the wires in Q that begin with x


with the wires from P that end with α; if x does not appear in Q, this will return Q. As an example, consider that (when β /= γ, and y /= z)

(x^⟨x.α⟩α^ · γ)β^ † z^⟨y.δ⟩ →  (x^⟨x.α⟩α^ · γ)β^

z⟨y.δ⟩ → ⟨y.δ⟩
z^⟨y.δ⟩ → x^⟨x.α⟩α^ · γ


So, if activation in both directions is possible, the end result of the reduction can be different.
In [5] some basic properties were shown, which essentially show that the calculus is well-behaved, and the relation between X and a number of other calculi. These results motivate the formulation of new rules:
Lemma 1.5 ([5]) The following reduction rules are admissible:


(gc-l) : Pα
(gc-r) : P α
xQ → P, if α /∈ fp(P ), P pure. Q → Q, if x /∈ fs(Q), P pure


Typing for X
The notion of Curry type assignment as presented in [14,5] on X is defined in such a way that it gives a straightforward Curry-Howard isomorphism and Gentzen’s sequent calculus for (implicative) Classical Logic [13].
Definition 2.1 [Curry types and Contexts]
The set of Curry types is defined by the grammar:
A, B ::= ϕ | A→B
The Curry types considered in this paper are normally known as Curry
types.
A context of variables Γ is a mapping from variables to types, denoted as a finite set of statements x:A, such that the subject of the statements (x) are distinct. We write Γ, x:A for the context of names defined by:
Γ, x:A = Γ∪{x:A}, if Γ is not defined on x
= Γ,	otherwise
So, when writing a context as Γ, x:A, this implies that x:A ∈ Γ, or Γ is not defined on x.
Contexts of names are defined in a similar way.


The normal view for derivable statements in Gentzen’s system, like Γ ▶ ∆, is that the formulae in the context Γ are all assumptions and are therefore supposed to hold, and at least one of the formulea in ∆ is a consequence of Γ. However, not all the formulae in ∆ necessarily follow from Γ. In other words, the formulae in the context Γ are connected through the logical ‘and’, whereas those in ∆ are connected through the logical ‘or’. This is reflected in the type assignment rules of the system of Definition 5.2.
Definition 2.2 [Curry Typing for X [5]]
Type judgements are expressed via a ternary relation M : Γ ▶C ∆, where Γ is a context of variables and ∆ is a context of names, and M is a term. We say that M is the witness of this judgement.
Curry type assignment for X is defined by the following sequent calculus:


(cap) : ⟨y.α⟩ : Γ, y:A ▶C α:A, ∆
M : Γ ▶C α:A, ∆	N : Γ, x:A ▶C ∆

(cut) : 


: Γ ▶C ∆
Mα^ † x^N

(med) : 
M : Γ ▶C α:A, ∆	N : Γ, x:B ▶C ∆
:

Mα^ [y] x^N	Γ, y:A→B ▶C ∆

(exp) : 
M : Γ, x:A ▶C α:B, ∆
:

x^M α^ · β	Γ ▶C β:A→B, ∆
We write M : Γ ▶C ∆ if there exists a derivation that has this judge- ment in the bottom line, and write D :: M : Γ ▶C ∆ if we want to name that derivation.


The relation with the Lambda Calculus
The remainder of this paper will be dedicated to the definition of a notion of intersection type assignment on X . The definition will be such that it will be a natural extension of a system with intersection types for lc; we will start by briefly summarizing the latter. We assume the reader to be familiar with the lc [8]; we just recall the definition of lambda terms and β-contraction. We will write n for {1,..., n}, where n ≥ 0.
Definition 3.1 [Lambda terms and β-contraction [8]]


The set Λ of lambda terms is defined by the syntax:
M ::= x | λx.M | M1M2
The reduction relation →β is defined as the contextual (i.e. compatible [8]) closure of the rule:
(λx.M )N  →β  M[N/x]
The relation →→β is the reflexive and transitive closure of →β , and the =β is the equivalence relation generated by →→β
We can define the direct encoding of lc into X :
Definition 3.2 [[5]] The interpretation of lambda terms into terms of X via the plug α, [[M♩♩λ , is defined by:

[[x♩♩λ [[λx.M ♩♩λ
λ
= ⟨x.α⟩
λ β
λ	λ

[[MN ♩♩α = [[M♩♩γγ^ † x^([[N ♩♩ββ^ [x] y^⟨y.α⟩), with x fresh

The image of Λ in to X is not extensional:
[[λx.yx♩♩λ = x[[yx♩♩λ β^ · α	=∆
^

x(⟨y.γ⟩γ † z(⟨x.δ⟩δ [z] w⟨w.β⟩))β · α →
x^(⟨x.δ⟩δ^ [y] w^⟨w.β⟩)β^ · α	/= ⟨y.α⟩ = [[y♩♩λ
Directly translating the η-reduction rule ‘λx.Mx → M if x /∈ fv(M)’ into
X would give:


γ	α
or, in a more general notation:
Definition 3.3 [η-reduction on X ]
x(P γ † z(⟨x.δ⟩δ [z] w⟨w.β⟩))β · α → P γ † z⟨z.α⟩
Notice that we need to create a cut on the right-hand side to make sure that the result of P is available on the plug α.
This is of course a true extension of the notion of reduction, but we can ‘justify’ it by taking P to be the interpretation of abstraction (with x /∈ fv(Q)):



x((vQϵ · γ)γ † z(⟨x.δ⟩δ [z] w⟨w.β⟩))β · α →
x^(⟨x.δ⟩δ^ † v^(Q^ϵ † w^⟨w.β⟩))β^ · α	→
x(Q[β/ϵ][x/v])β^ · α	= (α-conversion) and that (vNϵ · γ)γ † z⟨z.α⟩→ vNϵ · α, exactly as expected.
As shown in [5], the notion of Curry type assignment for lc, Γ ▶λ M : A
is strongly linked to the one defined for X . In [5], the following relation is shown between lc and X :
Theorem 3.4 ([5])	(i) If M →β N, then [[M♩♩λ → [[N ♩♩λ .
α	α
(ii) if Γ ▶λ M : A, then [[M♩♩λ : Γ ▶C α:A.

Intersection Type Assignment for the Lambda Cal- culus
The notion of intersection type assignment for X as defined in the next section is inspired by the system of [12] (the precise relation between the two – through the interpretation functions as defined in [14,5] – needs to be studied, and is left for further research). It is a conservative extension of the Strict Intersection Type Assignment System of [1] (see also [2,3]), in that lambda terms typeable in that system translate to X nets, while preserving the type.
In this section, we will present that strict system; it can be seen as a restricted version of the BCD-system as presented in [9]. The major feature of this restricted system, compared to the BCD-system, is that the ≤-relation on types is not contra-variant over arrow types. Also, the ≤ relation on types is no longer contra-variant on the argument type in arrow-types, but restricted to the one induced by A∩B ≤ A and taking T to be the maximal type.
We now come to the definition of strict intersection types.
Definition 4.1 [Strict types, statements, and contexts]
Let Φ be a countable (infinite) set of type-variables, ranged over by ϕ. Ts, the set of strict types, and the set T of intersection types, both ranged over by A, B,.. ., are defined through:
The set Ts of strict types is inductively defined by:

A, B ::= ϕ | ((A1∩··· ∩An) → B), (n ≥ 0)


The set T of strict intersection types is defined by:
{A1∩··· ∩An | n ≥ 0 & ∀i ∈ n [Ai is a strict type]} We will write T for the empty intersection type.
A statement is an expression of the form M:A, with M ∈ Λ, and A ∈ T .
M is the subject and A the predicate of M:A.
A context Γ is a partial mapping from term variables to intersection types, so we can use Γx for the type stored for x in Γ. As standard, a context is also represented as a set of statements with only distinct variables as subjects. We will write x /∈ Γ if Γ is not defined on x.
For contexts Γ1,... , Γn, the context Γ1∩··· ∩Γn is defined by: x:A1∩··· ∩Am
∈ Γ1∩··· ∩Γn if and only if {x:A1,..., x:Am} is the set of all statements with strict predicate about x that occur in Γ1  ···  Γn.
We write Γ∩x:A for the context Γ∩{x:A}, i.e., the context defined by:
Γ∩x:A = Γ∪{x:A},	if x /∈ Γ
= Γ\x∪{x:A∩B}, if x:B ∈ Γ We will often write Γ, x:A for Γ∩x:A when x /∈ Γ.
Notice that strict types are either type-variables, ϕ, or arrow types. In
an arrow type, the type on the right of the arrow type constructor is always strict; the type on the left of the arrow is an intersection type, but since Ts is a proper subset of T , it can be strict.
In the notation of types, as usual, right-most outer-most brackets will be omitted. Also, we write ∩nAi for the type A1∩··· ∩An.
We will consider a pre-order on types which takes into account the idem-
potence, commutativity and associativity of the intersection type constructor, and defines T to be the maximal element.
Definition 4.2 [Relations on types]
The relation ≤ is defined as the least pre-order (i.e. reflexive and transitive relation) on TS such that:
∩nAi  ≤  Ai,  for all i ∈ n, (n ≥ 1)
B ≤ Ai,  for all i ∈ n ⇒ B ≤ ∩nAi,	(n ≥ 0)
The equivalence relation ∼ on types is defined by: A ∼ B ⇐⇒ A ≤ B ≤
A, and we will consider types modulo ∼.
We write Γ ≤ Γ' if and only if for every x:A' ∈ Γ' there is an x:A ∈ Γ such that A ≤ A', and Γ ∼ Γ' ⇐⇒ Γ ≤ Γ' ≤ Γ.


T may be considered modulo ∼; then ≤ becomes a partial order.
Notice that A ≤ A, and A ≤ T, for all A; it is easy to show that both (A∩B)∩C ∼ B∩(A∩C) and A∩B ∼ B∩A, so the type constructor ∩ is asso- ciative and commutative, and we will write A∩B∩C rather than (A∩B)∩C. Moreover, we will assume, unless stated explicitly otherwise, that in ∩nAi each
Ai is a strict type.
The definition of the ≤-relation as given in [9] (apart from dealing with intersection types occurring on the right of the arrow type constructor) or [2] also contained the alternative:
C ≤ A & B ≤ D ⇒ A→B ≤ C→D
This was added mainly to obtain a notion of type assignment closed for η- reduction (i.e. β-reduction extended with λx.Mx →η M, if x is not free in M), a feature that is not considered here.
Definition 4.3 [Strict type assignment and derivations]
Strict intersection type assignment and strict intersection derivations are defined by the following natural deduction system (where A in rules (→E) and (→I) is in T ):


(Ax) :	(i ∈ n)	(
Γ ▶λ M : A1 ... Γ ▶λ M : An
(n ≥ 0)


x:∩nAi ▶λ x : Ai
∩I) : 


Γ ▶λ M : ∩nAi



(→I) : 
Γ, x:A ▶λ M : B


Γ ▶λ λx.M : A→B
(→E) : 
Γ ▶λ M : A→B	Γ ▶λ N : A


Γ ▶λ MN : B

We write Γ ▶λ M : A if this statement is derivable using a strict intersec- tion derivation, and write D :: Γ ▶λ M : A to specify that this result was obtained through the derivation D.
Notice that, since T is considered to be the empty intersection, the deriva- tion rule



is implicit in rule (∩I).


(T) : Γ ▶λ M : T

Theorem 4.4 (cf. [1,4]) The following rules are admissible:


(≤) : Γ ▶λ M : A (Γ' ≤ Γ,A ≤ B)
(=β
Γ ▶λ M : A
) :	(M =β N )

Γ ▶λ M : B	Γ ▶λ N : A



(cut) : 
Γ, x:A ▶λ M : B	Γ ▶λ N : A


Γ ▶λ M[N/x]: B

Intersection and Union Type Assignment for X
The notion of intersection type assignment on X that we will present in this section is a natural extension of the system considered in [5], i.e. the basic implicative system for Classical Logic, but extended with intersection and union types and the type constant T.
The initial aim of this work was to define a system using intersection types only, but, when trying to prove the conversion results of the next section, problems were encountered. These were mainly due to the fact that, in that approach, when a plug carried an intersection type A∩B, if was not sure if
B, so, in particular, step (r3) of the proof of Theorem 6.1 was troublesome. this was derived by combining two derivations, one with A, and the other with Also, just forcing intersection types only on the system violates the normal
interpretation of the system of Classical Logic of Definition 2.2. The normal view for statements like Γ ▶ ∆ is that the formulae in the context Γ are all necessary for the result, and not all the formulae in ∆ necessarily follow from Γ; in other words, the formulae in the context Γ are connected through the logical ‘and’, whereas those in ∆ are connected through the logical ‘or’. So,
also inspired by [12], a system was set up that allowed only intersection types for sockets, and only union types for plugs, but this soon proved to be too
restrictive. Intersection types are sometimes needed on plugs, and union types can be needed on sockets.
These observations then led to the present definition. Essentially, the choice above still stands: intersection types for sockets, and union types for plugs, and obsolete types can be added at will via the rules (∩L) and (∪R), respectively. However, a union type like A∪B for sockets is allowed, but only
if both A and B can be justified (see rule (∪L)); similarly, an intersection type
like A∩B for plugs is only allowed if both A and B can be justified (see rule (∩R)).
The following definition of strict types is a natural extension of the notion of strict types of the previous section, by adding union as a type constructor.
Definition 5.1 [Types, statements, and contexts] (i)
The set Ts of strict types is inductively defined by:
A, B ::= ϕ | ((A1∩··· ∩An) → B), (n ≥ 0)
| ((A1∪··· ∪An) → B), (n ≥ 0)


The set T of types is defined by:
{A1∩··· ∩An | n ≥ 0 & ∀i ∈ n [Ai is a strict type]}∪ 
{A1∪··· ∪An | n ≥ 0 & ∀i ∈ n [Ai is a strict type]}
We will write T for the empty intersection type.
Statements and contexts are defined as in Definition 4.1.
For contexts of sockets Γ1,... , Γn, the context Γ1∩··· ∩Γn is defined by: x:A1∩··· ∩Am ∈ Γ1∩··· ∩Γn if and only if {x:A1,..., x:Am} is the set of all statements about x that occur in {v:C | ∃i ∈ Γi [v:C ∈ Γi]}. We write Γ∩x:A for the context of sockets Γ∩{x:A}, i.e., the context defined by
(where  is the operation of union on sets):
Γ∩x:A = Γ  { x:A},	if x /∈ Γ
We will often write Γ, x:A for Γ∩x:A when x /∈ Γ.
For contexts of plugs, ∆1,... , ∆n, the context ∆1∪··· ∪∆n is defined by: α:A1∪··· ∪Am ∈ ∆1∪··· ∪∆n if and only if {α:A1,... , α:Am} is the set of all statements about α that occur in {β:C | ∃i ∈ ∆i [β:C ∈ ∆i]}. We write α:A∪∆ for the context of sockets {α:A}∪∆, i.e., the context defined
by:
α:A∪∆ = {α:A}   ∆ ,	if α /∈ ∆
We will often write α:A, ∆, for α:A∪∆ when α /∈ ∆.
In order to not have derivations littered with applications of the Weakening rule, we allow rules to combine the contexts of the subterms involved; this does not exclude the normal approach, since the contexts can be equal. The most important thing to notice is that, by rule (Ax), only strict types are added to contexts, and that, via the rules, intersection types are built of contexts of sockets, and union types are built for contexts of plugs.
However, a union type can appear in a contexts of sockets, but only via the rule (∪L); similarly, an intersection type can appear in a contexts of plugs, but only via the rule (∩R). This restriction helps to avoid the famous subject reduction problem of systems with union types.
Definition 5.2 [Intersection and Union Typing for X ]
Intersection type
judgements are expressed via a ternary relation P : Γ ▶ ∆, where Γ is a context of sockets and ∆ is a context of plugs, and P is a net. We say that P is the witness of this judgement.


Intersection and union type assignment for X is defined by the following sequent calculus:


(Ax) : ⟨y.α⟩ : Γ∩y:A ▶ α:A∪∆

(A ∈ Ts)

(→R) : 
P : Γ, x:A ▶ α:B, ∆
:

x^P α^ · β	Γ ▶ β:A→B∪∆

(→L) : 
P : Γ1 ▶ α:A, ∆1	Q : Γ2, x:B ▶ ∆2
:

P α^ [y] x^Q	Γ1∩Γ2∩y:A→B ▶ ∆1∪∆2

(cut) : 
P : Γ1 ▶ α:A, ∆1	Q : Γ2, x:A ▶ ∆2
:



(∩L) : 

P : Γ, x:A ▶ ∆
P : Γ, x:A∩B ▶ ∆
P α † xQ

(∩R) : 
Γ1∩Γ2 ▶ ∆1∪∆2
P : Γ1 ▶ α:A, ∆1	P : Γ2 ▶ α:B, ∆2
P : Γ1∩Γ2 ▶ α:A∩B, ∆1∪∆2

(∪L) : 
P : Γ1, x:A ▶ ∆1	P : Γ2, x:B ▶ ∆2
P : Γ1∩Γ2, x:A∪B ▶ ∆1∪∆2
(∪R) : 
P : Γ ▶ α:A, ∆
P : Γ ▶ α:A∪B, ∆

(TL) : P : Γ, x:T ▶ ∆	(TR) : P : Γ ▶ α:T, ∆
We write P : Γ ▶ ∆ if there exists a derivation that has this judgement in the bottom line, and write D :: P : Γ ▶ ∆ if we want to name that derivation.
Notice that, in P : Γ ▶ ∆, there is no notion of type for P itself, instead the derivable statement shows how P is connectable; Γ and ∆ carry the types
of the free connectors in P , as unordered sets.
Lemma 5.3 (Weakening) The following rule is admissible:
P : Γ ▶ ∆

(W) : 


P : Γ∩x:A ▶ α:B∪∆

We can now show that typeability is preserved by [[·♩♩λ :

Theorem 5.4 If Γ ▶λ M : A, then [[M♩♩λ
: Γ ▶ α:A.

Proof. By induction on the structure of derivations in ▶λ.
Ax Then M ≡ x, and Γ = Γ', x:∩nAi, and A = Ai ∈ Ts for some 1≤i≤n. Take Γ'' = Γ, x:A1∩··· ∩Ai−1∩Ai+1∩··· ∩A
so Γ''∩x:Ai = Γ, then


[[x♩♩λ

: Γ''∩x:A

▶ α:Ai
(Ax)


→I Then M ≡ λx.N , A = C→D, and Γ, x:C ▶λ N : D. Then
D :: [[N ♩♩λ : Γ, x:C ▶ β:D exists by induction, and we can construct:

\	/
\	D	/
\	/

[[N ♩♩λ
: Γ, x:C ▶ β:D
:
(→R)

x^[[N ♩♩λ β^ · α
Γ ▶ α:C→D
λ

Notice that x[[N ♩♩ββ · α = [[λx.N ♩♩α.
∩I Then A = ∩nAi, and we have Γ ▶λ M : Ai for all i ∈ n. By induction,
[[M♩♩λ : Γ ▶ α:Ai for all i ∈ n, so, by rule (∩R), also [[M♩♩λ : Γ ▶ α:A.

T Notice that [[P ♩♩λ
: Γ ▶ α:T by rule (TR).

→E Then M ≡ M1M2, and there exists B such that both Γ ▶λ M1 : B→A
and Γ ▶λ M2 : B. By induction, both D1 :: [[M ♩♩λ : Γ ▶ γ:B→A and
1 γ
D2 :: [[M ♩♩λ : Γ ▶ β:B exist, and we can construct:
2 β

\	/
		\	D2	/
\	/	\	/		 (Ax)

\	D1
/	[[M ♩♩λ
: Γ ▶ β:B
⟨y.α⟩ : y:A ▶ α:A

\	/
	2 β	
:
(→L)

1 γ	2 β

[[M ♩♩λ	Γ ▶ γ:B→A	[[M ♩♩λ β^ [x] y^⟨y.α⟩
Γ, x:B→A ▶ α:A



[[M1♩♩γγ^ † x^([[M2♩♩ββ^ [x] y^⟨y.α⟩)	Γ ▶ α:A
Notice that [[M1M ♩♩λ = [[M ♩♩λ γ † x([[M ♩♩λ β^ [x] y^⟨y.α⟩), and that, by
^	^

Example 5.5 [Why strict types] The real motivation for using strict types rather than the – perhaps more easier to understand – normal types defined by the syntax
A, B ::= ϕ | A∩B | A∪B
is that we would have loss of the subject reduction property, as in the system of [11] defined for lc (there the solution is to use Harrop types).
Using essentially the same rules as in Definition 5.2 (using normal types rather than strict types, of course), we can derive:

\\	DA	//	\\	DB	/

\	/	\	2	/
\	2	 /

\	D1	/
[[xtt♩♩λ : Γ, t:A ▶ ∆	[[xtt♩♩λ : Γ, t:B ▶ ∆

\	/
	β	β	

[[Iyz♩♩λ : Γ ▶ δ:A∪B, ∆
[[Iyz♩♩δδ^
[[xtt♩♩λ : Γ, t:A∪B ▶ ∆
: Γ ▶ ∆
^t[[xtt♩♩α


where Γ = x:(A→A→C)∩(B→B→C), y:D→(A∪B), z:D, and ∆ = α:C. In this derivation, DA and DB are identical, but for the type used for t, and the
2	2
choice for x:A→A→C or x:B→B→C. Now
[[Iyz♩♩λδ	λ
λ	λ
= [[Iyz♩♩δδ^	^t([[xt♩♩є^ϵ † ^c(⟨t.µ⟩µ^ [c] d^⟨d.α⟩))
→ ([[Iyz♩♩λδ^	^t[[xt♩♩λ)^ϵ † ^c([[Iyz♩♩λδ^	^t(⟨t.µ⟩µ^ [c] d^⟨d.α⟩))

→ ([[Iyz♩♩λδ^	^t[[xt♩♩λ)^ϵ † ^c(([[Iyz♩♩λδ^	^t⟨t.µ⟩)µ^ [c] d^([[Iyz♩♩λδ^
^t⟨d.α⟩))

→ ([[Iyz♩♩δδ^	^t[[xt♩♩є)^ϵ † ^c([[Iyz♩♩δδ^ [c] d^⟨d.α⟩)
Now the last term above is not typeable. This can be observed from the fact that the derivation would need to have the following shape:

\	/
\	D1	/
\	/
[[Iyz♩♩λ : Γ ▶ δ:A∪B, ∆ ⟨d.α⟩	Γ, d:C ▶ ∆

: Γ, c:(A∪B)→C ▶ ∆
[[Iyz♩♩δδ^ [c] d^⟨d.α⟩

	

\	/
\	D1	/
\	/
\	D3	/

\	/
[[Iyz♩♩λ : Γ ▶ δ:A∪B, ∆
λ
\	/
[[xt♩♩λ : Γ, t:A∪B ▶ ϵ:(A∪B)→C, ∆
λ :

[[Iyz♩♩δδ^ † ^t[[xt♩♩є
Γ ▶ ϵ:(A∪B)→C, ∆
:

([[Iyz♩♩λδ^ † ^t[[xt♩♩λ)^ϵ † ^c([[Iyz♩♩λδ^ [c] d^⟨d.α⟩)	Γ ▶ ∆
but the subderivation D3 does not exist: picking either A or B for t gives derivations for
[[xt♩♩λ : Γ, t:A ▶ ϵ:A→C, ∆ and[[xt♩♩λ : Γ, t:B ▶ ϵ:B→C, ∆
є	є
Notice that the types ’derived’ for the plug ϵ differ, and do not permit the application of rule (∪L); there is no way around this problem.
In fact, the proofs of Theorems 6.1 and 6.2 strongly depend on the fact that, when we have a derivation for P : Γ, t:A∪B ▶ ∆, then rule (∪L) has been used to ‘insert’ the union type.

Preservance of types under conversion
In this section, we will perform the main ‘soundness’ checks of the system with intersection and union types as introduced for X above. We will show that the notion of type assignment is closed for both reduction and expansion, but that it is not with respect to the notion of η-reduction as introduced in Definition 3.3.


Theorem 6.1 (Subject reduction)
If P : Γ ▶ ∆, and P → Q, then Q : Γ ▶ ∆.
Proof. See the appendix.	 
Theorem 6.2 (Subject expansion)
If Q : Γ ▶ ∆, and P → Q, then P : Γ ▶ ∆.
Proof. See the appendix.	 
We will finish the presentation of the results of this paper by looking at the η-reduction rule, and show, as can be expected – seen that the notion of type assignment defined here for X is a natural extension of the strict system for lc – that type assignment in the system as presented here is not preserved by this rule.
Example 6.3 Take the η-rule for X as defined in Definition 3.3:

x(P γ † z(⟨x.δ⟩δ [z] w⟨w.β⟩))β · α → P γ † z⟨z.α⟩

Let A be strict; the following is a possible derivation for the left-hand side:

\
\	D	/
/				
⟨x.δ⟩	x:A∩C ▶ δ:A	⟨w.β⟩	w:B ▶ β:B

\	/
P : Γ ▶ γ:A→B, ∆
⟨x.δ⟩δ^ [z] w^⟨w.β⟩
: x:A∩C, z:A→B ▶ β:B

P γ^ † z^(⟨x.δ⟩δ^ [z] w^⟨w.β⟩)
Γ, x:A∩C ▶ β:B.∆
:

x^(P γ^ † z^(⟨x.δ⟩δ^ [z] w^⟨w.β⟩))β^ · α	Γ ▶ α:(A∩C)→B, ∆
However, using the same derivation for P , we cannot derive
:
P γ † z⟨z.α⟩	Γ ▶ α:(A∩C)→B
At most, we can derive:

\	/
\	D	/
\	/		
P	Γ ▶ γ:A→B, ∆	⟨z.α⟩	z:A→B ▶ α:A→B
:
P γ^ † z^⟨z.α⟩	Γ ▶ α:A→B, ∆
As was the case for systems with intersection types for lc [9,2], in order to get a notion of type assignment that is closed for η-reduction, we would need to introduce a ≤-relation on types which is contra-variant in the arrow (see the discussion after Definition 4.2).


In such a system, in the style of [2], the (Ax)-rule of Definition 5.2 could be replaced by:
(Ax) : ⟨y.α⟩ : Γ∩y:A ▶ α:B∪∆ (A ≤ B; A, B strict)
With this new rule, we can derive the desired result:

\	/
\	D	/
\	/		
P	Γ ▶ γ:A→B, ∆	⟨z.α⟩	z:A→B ▶ α:(A∩C)→B
:
P γ^ † z^⟨z.α⟩	Γ ▶ α:(A∩C)→B, ∆
If this indeed gives a sound system (and a true extension of the system of [9,2]), will be left for future research.

Future work
There exists a whole plethora of directions of research that need exploration for X . The one started with this paper, a notion of type assignment using intersection types, will need to be more strongly linked to existing systems, like those of [9,2,12]. Using those results, we want to look at the problem of termination, semantics, approximation, etc.
Also, in view of the striking similarities between the nets of X and the processes of the π-calculus, perhaps a suitable notion of type assignment using both intersection and union types can be defined for the latter.

Acknowledgement
I am greatly indebted to Pierre Lescanne, who not only suggested to use union types, but also drew my attention to the paper [12]. The solution for various problems noted there for a system with intersection types for Curien and Herbelein’s calculus λµµ˜ gave the final inspiration towards the type assignment rules defined here.
My thanks go also to Mariangiola Dezani, who pointed out a flaw in an earlier version of this paper.

References
S. van Bakel. Complete restrictions of the Intersection Type Discipline. Theoretical Computer Science, 102(1):135–163, 1992.



S. van Bakel. Intersection Type Assignment Systems. Theoretical Computer Science, 151(2):385–435, 1995.

S. van Bakel. Strongly Normalising Cut-Elimination with Strict Intersection Types. In Electronic Proceedings of International Workshop Intersection Types and Related Systems 2002 (ITRS ’02), Copenhagen, Denmark, volume 70.1 of Electronic Notes in Theoretical Computer Science, 2002.
S. van Bakel. Cut-Elimination in the Strict Intersection Type Assignment System is Strongly Normalising. To appear in: Notre Dame Journal of Formal Logic, 2004.
S. van Bakel, S. Lengrand, and P. Lescanne. The language §: computation and sequent calculus in classical logic. Submitted, 2004.
S. van Bakel and J. Raghunandan.	Implementing §.	In Electronic Proceedings of
TermGraph’04, Rome, Italy, Electronic Notes in Theoretical Computer Science, 2004.  To
appear.
F. Barbanera and S. Berardi. A symmetric lambda calculus for classical program extraction.
Information and Computation, 125(2):103–117, 1996.
H. Barendregt. The Lambda Calculus: its Syntax and Semantics. North-Holland, Amsterdam, revised edition, 1984.

H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini. A filter lambda model and the completeness of type assignment. Journal of Symbolic Logic, 48(4):931–940, 1983.
Pierre-Louis Curien and Hugo Herbelin. The duality of computation. In Proceedings of the 5 th ACM SIGPLAN International Conference on Functional Programming (ICFP’00), pages 233–243. ACM, 2000.

M. Dezani-Ciancaglini, U. de’ Liguoro, and A. Piperno. Intersection and union types: syntax and semantics. Information and Computation, 119:202–230, 1995.
Dan Dougherty, Sivia Ghilezan, and Pierre Lescanne. Characterizing strong normalization in a language with control operators. To appear, 2004.
G. Gentzen. Investigations into logical deductions. In M.E. Szabo, editor, Gentzen collected works. North Holland, 1969. First published in 1935.
St´ephane Lengrand. Call-by-value, call-by-name, and strong normalization for the classical sequent calculus. In Bernhard Gramlich and Salvador Lucas, editors, Electronic Notes in Theoretical Computer Science, volume 86. Elsevier, 2003.
Christian Urban. Classical Logic and Computation. PhD thesis, University of Cambridge, October 2000.

A  Conversion proofs

tion rules (∪L) in the case for (l2) shown, and (∩R) in the one for (r3). We start with the proof of a subject-reduction result. Notice the use of deriva-
Theorem A.1 (Subject reduction)
If P : Γ ▶ ∆, and P → Q, then Q : Γ ▶ ∆.
Proof. By induction on the definition of →, where we focus on the rules: the proof consists of showing, for each rule, the ’minimal’ derivation for the left-hand side, and that, using the restrictions that poses, we can type the right-hand side. We only show the interesting cases.


Logical rules ins (yP β · α)α † x(Qγ [x] zR) → (Qγ † yP )β † zR, with α /∈
fp(R),x /∈ fs(Q, R).



\\	D1	/


\	D2	/


\	D3	/

\	/
P	Γ1, y:A ▶ β:B, ∆1
\	/
Q  Γ2 ▶ γ:A, ∆2
\	/
R  Γ3, z:B ▶ ∆3

ybP βb · α : Γ1 ▶ α:A→B, ∆1	Qγb [x] zbP : Γ2 ∩Γ3 , x:A→B ▶ ∆2 ∪∆3
(ybP βb · α)αb † xb(Qγb [x] zbR) : Γ1 ∩Γ2 ∩Γ3 ▶ ∆1 ∪∆2 ∪∆3
Notice that y, β /∈ fc(Q, R).



\\	D2	/


\	D1	/

\	/
Q  Γ2 ▶ γ:A, ∆2
\	/
P	Γ1 , y:A ▶ β:B, ∆1

/
\	D3	/

Qγb † ybP : Γ1 ∩Γ2 ▶ β:B, ∆1 ∪∆2	R : Γ3, z:B ▶ ∆3
(Qγb † ybP )βb † zbR : Γ1 ∩Γ2 ∩Γ3 ▶ ∆1 ∪∆2 ∪∆3

CBV propagation l2 (y^P β^ · α)α^
x^Q → (y^(P α^
x^Q)β^ · γ)γ^ † x^Q, with




		

\	/
\	D1
\	/
\	D2
\	/
\	D3

P : Γ1, y:A ▶ β:B, α:C, ∆1
Q : Γ2, x:A→B ▶ ∆2  Q : Γ3 , x:C ▶ ∆3

ybP βb · α : Γ1 ▶ α:(A→B)∪C, ∆1	Q : Γ2 ∩Γ3 , x:(A→B)∪C ▶ ∆2 ∪∆3
(∪L)

(ybP βb · α)αb	xbQ : Γ1 ∩Γ2 ∩Γ3 ▶ ∆1 ∪∆2 ∪∆3



\\	D1	//


\	D2	/

\	/	\	/
P	Γ1 , y:A ▶ β:B, α:A→B, ∆1  Q  Γ2, x:A→B ▶ ∆2

P αb	xbQ : Γ1 ∩Γ2 , y:A ▶ β:B, ∆1 ∪∆2

\	/
\	D3

yb(P αb	xbQ)βb · γ : Γ1 ∩Γ2 ▶ γ:A→B, ∆1 ∪∆2	Q : Γ3, x:A→B ▶ ∆3
(yb(P αb	xbQ)βb · γ)γb † xbQ : Γ1 ∩Γ2 ∩Γ3 ▶ ∆1 ∪∆2 ∪∆3
CBN propagation r3

P α^
x^(Qβ^ [x] y^R) → P α^ † v^((P α^
x^Q)β^ [v] y^(P α^
x^R)), with v fresh.






	

\	/
\	D3
\	/
\	D4

Q : Γ3, x:C ▶ β:A, ∆3  R : Γ4, y:B, x:C ▶ ∆4
Qβb [x] ybP : Γ3 ∩Γ4, x:A→B ∩C ▶ ∆3 ∪∆4

	

\	/
\	D1
\	/
\	D2

P : Γ1 ▶ α:A→B, ∆1  P : Γ2 ▶ α:C, ∆2

P : Γ1 ∩Γ2 ▶ α:A→B ∩C, ∆1 ∪∆2
(∩R)

P αb
xb(Qβb [x] ybR) : Γ1 ∩··· ∩Γ4 ▶ ∆1 ∪··· ∪∆4

\\	D1	/
\	//
P	Γ1 ▶ α:A→B, ∆1

\	D2	/
\	D3	/
\	D2	/
\	D4	/

\\	//	\\	//	\\	//	\\	//
P	Γ2 ▶ α:C, ∆2  Q  Γ3, x:C ▶ β:A, ∆3  P	Γ2 ▶ α:C, ∆2  R	Γ4, y:B, x:C ▶ ∆4
Pα	xQ : Γ2 ∩Γ3 ▶ β:A, ∆2 ∪∆3	Pα	xR : Γ2 ∩Γ4, y:B ▶ ∆2 ∪∆4
^ (P^ α^	x^Q)β^ [v] y^(P α^	x^R) : Γ2 ∩Γ3 ∩Γ^4, v^:A→B ▶ ∆2 ∪∆3 ∪∆4
P α † v((P α	xQ)β^ [v] y^(P α^	xR))  Γ1 ∩··· ∩Γ4 ▶ ∆1 ∪··· ∪∆4
^


rules (∪L) in the cases (l2), (l4), and (l5), and that of (∩R) in the cases (r3), Next we show a subject-expansion result. Notice the use of the derivation (r4), and (r5).
Theorem A.2 (Subject expansion) If Q : Γ ▶ ∆, and P → Q, then P : Γ ▶ ∆.
Proof. By induction on the definition of →, where we focus on the rules: the proof consists of showing, for each rule, the ’minimal’ derivation for the right-hand side, and that, using the restrictions that poses, we can type the left-hand side. We will only show the interesting cases.
CBV propagation l1 ⟨y.β⟩α	xP → ⟨y.β⟩, with β /= α. Notice the use of

the type T.

⟨y.β⟩ : y:A ▶ β:A


⟨y.β⟩ : y:A ▶ β:A
⟨y.β⟩ : y:A ▶ α:T,β:A (W)



P : x:T ▶ ∅ (TL)

⟨y.β⟩αb
xbP : y:A ▶ β:A

l2 (y^P β^ · α)α^
x^Q → (y^(P α^
x^Q)β^ · γ)γ^ † x^Q, with γ fresh.	Notice


that y, β /∈ fc(Q).

\\	D1	//	\	D2	//
\	/	\	/
P	Γ1 , y:A ▶ α:C, β:B, ∆1  Q  Γ2 , x:C ▶ ∆2

P αb	xbQ : Γ1 ∩Γ2, y:A ▶ β:B, ∆1 ∪∆2
\	D3	/
\/

yb(P αb	xbQ)βb · γ : Γ1 ∩Γ2 ▶ γ:A→B, ∆1 ∪∆2	Q : Γ3, x:A→B ▶ ∆3
(yb(P αb	xbQ)βb · γ)γb	xbQ : Γ1 ∩Γ2 ∩Γ3 ▶ ∆1 ∪∆2 ∪∆3



\	/
\	D1


\	/
\	D2


\	/
\	D3

P : Γ1, y:A ▶ α:C, β:B, ∆1
Q : Γ2, x:C ▶ ∆2  Q : Γ3, x:A→B ▶ ∆3

ybP βb · α : Γ1 ▶ α:(A→B)∪C, ∆1
(ybP βb · α)αb
Q : Γ2 ∩Γ3 , x:(A→B)∪C ▶ ∆2 ∪∆3
xbQ : Γ ▶ ∆
(∪L)

l4 (P β [z] yQ)α
fc(R).
x^R → (P α^	x^R)β^ [z] y^(Qα^


x^R). Notice that y, β /∈



\	/
\	D1
\	/
\	D2
\	/
\	D3
\	/
\	D4

P : Γ1 ▶ α:C, β:A, ∆1  R : Γ2, x:C ▶ ∆2
Q : Γ3, y:B ▶ α:D, ∆3  R : Γ4 , x:D ▶ ∆4

P αb	xbR : Γ1 ∩Γ2 ▶ β:A, ∆1 ∪∆2
Qαb	xbR : Γ3 ∩Γ4, y:B ▶ ∆3 ∪∆4

(P αb
xbR)βb [z] yb(Qαb
xbR) : Γ1 ∩··· ∩Γ4 ∩z:A→B ▶ ∆1 ∪··· ∪∆4

\\	D1	/
\	D3	/
\	D2	/
\	D4	/

\	//	\\	//	\\	//	\\	//
P	Γ1 ▶ α:C, β:A, ∆1  Q  Γ3, y:B ▶ α:D, ∆3  R	Γ2, x:C ▶ ∆2  R	Γ4, x:D ▶ ∆4
	:	 	:	 (∪L)
P β^ [z] y^Q Γ1 ∩Γ3 ∩z:A→B ▶ α:C ∪D, ∆1 ∪∆3	R	Γ2 ∩Γ4, x:C ∪D ▶ ∆2 ∪∆4
(P β^ [z] y^Q)α^	xR	Γ1 ∩··· ∩Γ4 ∩z:A→B ▶ ∆1 ∪··· ∪∆4

l5 (P β † yQ)α
fc(R).
x^R → (P α^
x^R)β^ † y^(Qα^
x^R). Notice that y, β /∈




\	/
\	D1

\	/
\	D2

\	/
\	D3
\	/
\	D4

P : Γ1 ▶ α:C, β:B, ∆1  R : Γ2, x:C ▶ ∆2
Q : Γ3, y:B ▶ α:D, ∆3  R : Γ4 , x:D ▶ ∆4

P αb	xbR : Γ1 ∩Γ2 ▶ β:B, ∆1 ∪∆2
Qαb	xbR : Γ3 ∩Γ4, y:B ▶ ∆3 ∪∆4

(P αb	xbR)βb † yb(Qαb
xbR) : Γ1 ∩· · · ∩Γ4 ▶ ∆1 ∪··· ∪∆4

\\	D1	/
\	D3	/
\	D2	/
\	D4	/

\	//	\\	//	\\	//	\\	//
P	Γ1 ▶ α:C, β:B, ∆1  Q  Γ3, y:B ▶ α:D, ∆3  R	Γ2, x:C ▶ ∆2  R	Γ4, x:D ▶ ∆4
	:	 	:	 (∪L)

P β^ † y^Q
Γ1 ∩Γ3 ▶ α:C ∪D, ∆1 ∪∆3
R  Γ2 ∩Γ4, x:C ∪D ▶ ∆2 ∪∆4

(P β^ † y^Q)α^
xR	Γ1 ∩··· ∩Γ4 ▶ ∆1 ∪··· ∪∆4

CBN propagation r1 Pα
x^⟨y.β⟩ → ⟨y.β⟩, y /= x. Again, notice the use



of the type T.

⟨y.β⟩ : y:B ▶ β:B	P : ∅ ▶ α:T (TR)


⟨y.β⟩ : y:B ▶ β:B
⟨y.β⟩ : y:B, x:T ▶ β:B (W)

P αb

r3 P α	x(Qβ^ [x] y^R) → P α^ † v^((P α^
^


xb⟨y.β⟩ : y:B ▶ β:B
x^Q)β^ [v] y^(P α^	x^R)), with v

\\	D2	//	\\	D3	/
\	/	\	//
P	Γ2 ▶ α:C, ∆2  Q  Γ3, x:C ▶ β:A, ∆3
	

Pα	xQ : Γ	Γ ▶ β:A, ∆	∆
\	D4	/
\	D5	//

^	^	2 ∩ 3


2 ∪  3
\	/	\	/
P	Γ4 ▶ α:D, ∆4  R	Γ5, x:D, y:B ▶ ∆5

\\	D1	//
Pα	xR : Γ ∩Γ , y:B ▶ ∆ ∪∆

: \	/
:^	^	4	5	4	5

P	Γ1 ▶ α:A→B, ∆1
(P α	xQ)β^ [v] y^(P α^
^
xR)  Γ2 ∩··· ∩Γ5, v:A→B ▶ ∆2 ∪··· ∪∆5

P α  † v((P α
x^Q)β^ [v] y^(P α^	xR))  Γ1 ∩··· ∩Γ5 ▶ ∆1 ∪··· ∪∆5


\	/
\	D1

\	/
\	D2

\	/
\	D4

P : Γ1 ▶ α:A→B, ∆1  P : Γ2 ▶ α:C, ∆2  P : Γ4 ▶ α:D, ∆4

P : Γ1 ∩Γ2 ∩Γ4 ▶ α:(A→B)∩C ∩D, ∆1 ∪∆2 ∪∆4
(∩R)



\\	D3	/


\	D5	/

\	/	\	/
Q  Γ3 , x:C ▶ β:A, ∆3  R  Γ5, x:D, y:B ▶ ∆5

P αb
Qβb [x] ybR : Γ3 ∩Γ5 , x:A→B ∩C ∩D ▶ ∆3 ∪∆5
xb(Qβb [x] ybR) : Γ1 ∩··· ∩Γ5 ▶ ∆1 ∪· · · ∪∆5

r4 P α	x(Qβ^ [z] y^R) → (P α^
^


	
x^Q)β^ [z] y^(P α^


x^R), x /= z. Notice



\\	D1	//
\	D2	//
\	D3	/
\\	D4	/

\	/
\	/
\	/
\	/

P : Γ1 ▶ α:C, ∆1 Q : Γ2 , x:C ▶ β:A, ∆2
P : Γ3 ▶ α:D, ∆3 R : Γ4 , x:D, y:B ▶ ∆4

P αb	xbQ : Γ1 ∩Γ2 ▶ β:A, ∆1 ∪∆2
P αb	xbR : Γ3 ∩Γ4 , y:B ▶ ∆3 ∪∆4

(P αb
xbQ)βb [z] yb(P αb
xbR) : Γ1 ∩··· ∩Γ4 ∩z:A→B ▶ ∆1 ∪··· ∪∆4

\\	D1	/
\	D3	/
\	D2	/
\	D4	/

\	//
P	Γ1 ▶ α:C, ∆1
\\	//
P	Γ3 ▶ α:D, ∆3
\\	//
Q  Γ2, x:C ▶ β:A, ∆2
\\	//
R  Γ4, x:D, y:B ▶ ∆4

	:	 (∩R) 	:	
P	Γ1 ∩Γ3 ▶ α:C ∩D, ∆1 ∪∆3	Qβ^ [z] y^R	Γ2 ∩Γ4 ∩z:A→B, x:C ∩D ▶ ∆2 ∪∆4
:
P α	x^(Qβ^ [z] y^R) Γ1 ∩··· ∩Γ4 ∩z:A→B ▶ ∆1 ∪··· ∪∆4



r5  P α
fc(P ).
x^(Qβ^ † y^R) → (P α^
x^Q)β^ † y^(P α^
x^R). Notice that y, β /∈



\\	D1	/
\	D2	/
\	D3	/
\	D4	/

\	/	\	/
P	Γ1 ▶ α:A, ∆1 Q  Γ2 , x:A ▶ β:B, ∆2
\	/	\	/
P	Γ3 ▶ α:C, ∆3 R  Γ4, x:C, y:B ▶ ∆4

P αb	xbQ : Γ1 ∩Γ2 ▶ β:B, ∆1 ∪∆2
P αb	xbR : Γ3 ∩Γ4 , y:B ▶ ∆3 ∪∆4

(P αb	xbQ)βb † yb(P αb
xbR) : Γ1 ∩· · · ∩Γ4 ▶ ∆1 ∪··· ∪∆4

\	D1	/
\	D3	/
\	D2	/
\	D4	/

\\	//
P	Γ1 ▶ α:A, ∆1
\\	//
P	Γ3 ▶ α:C, ∆3
\\	//
Γ2, x:A ▶ β:B, ∆2
\\	//
Γ4, x:C, y:B ▶ ∆4

	:	 (∩R) 	:	

P	Γ1 ∩Γ3 ▶ α:A∩C, ∆1 ∪∆3
:
Qβ^ † y^R	Γ2 ∩Γ4, x:A∩C ▶ ∆2 ∪∆4

P α	x^(Qβ^ † y^R)
Γ1 ∩··· ∩Γ4 ∩z:A→B ▶ ∆1 ∪··· ∪∆4
