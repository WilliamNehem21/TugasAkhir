

Electronic Notes in Theoretical Computer Science 237 (2009) 23–38
www.elsevier.com/locate/entcs

Closure of Tree Automata Languages under Innermost Rewriting
Adria` Gasco´na,1, Guillem Godoya,1 and Florent Jacquemardb,1
a Technical University of Catalonia, Jordi Girona 1, Barcelona, Spain. 2
b INRIA Futurs & LSV, UMR CNRS/ENS Cachan, France.

Abstract
Preservation of regularity by a term rewriting system (TRS) states that the set of reachable terms from a tree automata (TA) language (aka regular term set) is also a TA language. It is an important and useful property, and there have been many works on identifying classes of TRS ensuring it; unfortunately, regularity is not preserved for restricted classes of TRS like shallow TRS. Nevertheless, this property has
not been studied for important strategies of rewriting like the innermost strategy – which corresponds to the call by value computation of programming languages.
We prove that the set of innermost-reachable terms from a TA language by a shallow TRS is not necessarily regular, but it can be recognized by a TA with equality and disequality constraints between brothers. As a consequence we conclude decidability of regularity of the reachable set of terms from a TA language by innermost rewriting and shallow TRS. This result is in contrast with plain (not necessarily innermost) rewriting for which we prove undecidability. We also show that, like for plain rewriting, innermost rewriting with linear and right-shallow TRS preserves regularity.
Keywords: Term Rewriting, Tree Automata, Rewrite Strategies.

Introduction
Finite representations of infinite sets of terms are useful in many areas of computer science. The choice of a formalism for this purpose depends on its expressiveness, but also on its computational properties. Finite-state Tree Automata (TA) [3] are a well studied formalism for representing term languages, due to their good compu- tational and expressiveness properties. They are used in many fields of computer science, from a theoretical and a practical point of view. For instance, for the analysis of systems or programs, when configurations can be represented by trees (e.g. concurrent processes with parallel and sequential composition operators) TAs provide a finite representation of possibly infinite sets of configurations.

1  adriagascon@gmail.com, ggodoy@lsi.upc.edu, florent.jacquemard@lsv.ens-cachan.fr
2 The first two authors were supported by Spanish Min. of Educ. and Science by the FORMALISM project (TIN2007-66523) and by the LOGICTOOLS-2 project (TIN2007-68093-C02-01)

1571-0661/© 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.03.033

Term rewriting is a general formalism for the symbolic evaluation of terms by replacement of some patterns by others, following oriented equations, or rewrite rules, given in a finite set (a term rewriting system, or TRS). Plain rewriting is sometimes too general, and in many contexts rewriting is applied with specific strategies giving a finer representation of the system behaviour. This is the case of the innermost strategy, which corresponds to the call by value computation of programming languages, where arguments are fully evaluated before the application of the function.
In the above application to system verification, transitions in infinite state sys- tems can usually be represented by rewrite rules. There have been many studies of the connections between TA and rewriting, and a central property in this domain is the preservation of regularity. It states that for any given regular language L (which means that L is accepted by a TA), the set of reachable terms from L by a TRS R, denoted R∗(L) is also regular. Preservation of regularity has been widely studied. The first result of this kind was that preservation of regularity holds for every ground TRS, as shown in [17]. In [15] this property was established for lin- ear (variables occur at most once in every left-hand and right-hand side of a rule) and right-flat (the right-hand sides of the rules have height 0 or 1) TRS. There have been several extensions of this result, e.g. [6,11,14,16,5], and [14] represents a break- through since the left-linearity condition (linearity of left-hand sides of rules of the TRS) was dropped. However, in all the above cases, the condition of right-linearity remains necessary and in fact, a rewrite rule like g(x) → f (x, x) does not preserve regularity. Moreover, only plain rewriting is considered in these works, except in [5] where the bottom-up strategy is considered; there have been (up to our knowledge) no studies of regularity preservation under the innermost strategy.
The aim of this work is to study the preservation of regularity for innermost rewriting, and to identify a class of TRS for which better results can be found un- der the innermost strategy than under plain rewriting. We consider the class of shallow (all variables occur at depth 0 or 1 in the terms of the rules) TRS. Al- though the shallow case seems restrictive, for plain rewriting, shallow TRS do not preserve regularity. Moreover, several interesting properties of TRS, like reachabil- ity, joinability, confluence [13] and termination [9], are undecidable for shallow TRS, while adding certain linearity restrictions allows the decidability of all these prob- lems [14,16,10,9]. Hence, from a theoretical point of view, the shallow case draws a frontier for decidability when one considers classes of TRS defined by syntactic restrictions.
Our main result (Theorem 4.9, Section 4.2) is that, given a regular language L and a shallow TRS R, the set R±(L) of terms reachable from L using R with the innermost strategy is recognized by tree automata extended with equality and disequality constraints between brothers in their state transitions. This kind of automata, which we call BTTA, was introduced in [2] as an extension of TA, and it has also good closure and decidability properties, but with worst complexity than standard TA. This is in contrast with the situation with plain rewriting: R∗(L) (the set of terms reachable from L using R with plain rewriting) is in general neither a

TA nor a BTTA language under the same hypotheses (Proposition 3.2, Section 3). One of the classical techniques for proving results of preservation of regularity consists of adding transitions to the automaton recognizing the starting language L, in order to simulate rule applications of R and recognize also all the terms reachable from L. Apparently, this completion technique which works well for standard TAs (in all the regularity preservation results cited so far) does not work for general shallow TRS. Innermost rewriting cannot be simulated by TA transitions, despite it does operate almost in a bottom-up fashion for shallow TRS [5].  The reason
follows from two other results of the paper:
First, we show that innermost rewriting with flat TRS (TRS whose all left-hand- side and right-hand-sides of rules have depth at most one) does not preserve regularity (Proposition 4.2, Section 4). As a consequence, we need to consider BTTAs instead of standard TAs.
Second, flat and linear TRS do neither preserve BTTA-recognizably (Proposi- tion 4.3, Section 4.1). Consequently, TA completion cannot work in this case.
The main result is obtained in two steps. First, we reduce the problem of representing the reachable terms from a regular set to the reachable terms from a constant. Next, we give a direct construction of a BTTA recognizing the reachable terms from a constant. It is based on a representation of the set of reachable terms introduced in [8] using constrained terms. As an immediate consequence of the main result, we obtain from [1] that given a regular language L and a shallow TRS R, it is decidable whether R±(L) is regular in the case of innermost rewriting. In contraposition, we prove undecidability of regularity of R∗(L) when plain rewriting is considered.
Another positive result (Theorem 5.2, Section 5.1) is that, like for plain rewriting, innermost rewriting with linear and right-shallow TRS preserves regular languages. This result has been independently obtained in [12]. In our case it is proved with a non trivial adaptation of the TA completion technique of e.g. [15,11]. The cases of plain and innermost rewriting are different in essence to treat, and some subtle differences need to be introduced. We show in particular that even though TA completion permits to establish that right-linear and right-flat TRS (i.e. when left-hand sides of rules might be not linear) preserve regular languages under plain rewriting, we show that this property is no longer true for under innermost rewriting (Proposition 5.3, Section 5.2).
A long version of this paper is available as a Research Report [7].

Preliminaries
We use standard notation from the term rewriting literature [4]. A signature Σ is a finite set of function symbols with arity. We write Σm for the subset of function symbols of Σ of arity m. Given an infinite set V of variables, the set of terms built over Σ and V is denoted T (Σ, V), and the subset of ground terms is denoted T (Σ). The set of variables occurring in a term t ∈ T (Σ, V) is denoted vars(t). A

substitution σ is a mapping from V to T (Σ, V). The application of a substitution σ
to a term t is written σ(t), and is the homomorphic extension of σ to T (Σ, V).
A term t is identified as usual to a function from its set of positions (strings of positive integers) Pos(t) to symbols of F and V. We note Λ the empty string (root position). The length of a position p is denoted |p| and also called depth. The height of a term t, denoted h(t), is the maximum of {|p| p ∈ Pos(t)}. A subterm of t at position p is written t|p, and the replacement in t of the subterm at position p by u denoted t[u]p.
A term rewriting system (TRS) over a signature Σ is a finite set of rewrite rules l → r, where l ∈ T (Σ, V) \V (it is called left-hand side of the rule) and r ∈T (Σ, vars(l)) (it is called right-hand side). A term s ∈T (Σ, V) rewrites to t by a TRS R at a position p of s with a substitution σ, denoted s −R−−,p−,σ→ t (p and σ may be omitted in this notation) if there is a rewrite rule l → r ∈R such that s|p = σ(l) and t = s[σ(r)]p. In this case, s is said to be reducible. The set of irreducible terms, also called R-normal-forms, is denoted by NFR. The transitive and reflexive closure
of −−→ is denoted −−∗→. Given L ⊆T (Σ), we note R∗(L) = {t | ∃s ∈ L, s −−∗→ t}. The
R	R	R
above rewrite step is called innermost if all proper subterms of s|p are R-normal
forms. In this case, we write s −−ı→ t, and −−±→ for the the transitive and reflexive
R	R
closure of this relation, and R±(L) for {t | ∃s ∈ L, s −−±→ t}. We shall also use the
notations NF∗ (s) and NF± (s) (with s ∈ T (F, V)) for resp.  R∗({s}) ∩ NFR and
R	R
R±({s}) ∩ NFR.
A TRS is called linear (resp. right-linear, left-linear ) if every variable occurs at
most once in each term (resp. right-hand side, left-hand side) of the rules. It is called shallow (resp. right-shallow, left-shallow ) if variables occur at depth 0 or 1 in the terms (resp. in the right-hand sides, in the left-hand sides) of the rules and
flat (resp. right-flat, left-flat ) if the terms (resp. the right-hand sides, the left-hand sides) in the rules have height at most 1. A rule l → r is called collapsing if r is a
variable.

Tree automata with constraints between brothers
A tree automaton (TA) A on a signature Σ is a tuple (Q, Qf, Δ) where Q is a finite set of nullary state symbols, disjoint from Σ, Qf ⊆ Q is the subset of final states and Δ is a set of ground rewrite rules of the form: f (q1,..., qm) → q, or q1 → q (ε-transition) where f ∈ Σm, and q1,..., qm,q ∈ Q (q is called the target state of the rule).
A Bogaert-Tison tree automaton (BTTA, or tree automaton with constraints between brothers) is defined like a TA except that its states are unary and its transitions are constrained rewrite rules of the form f q1(x1),..., qm(xm)  → q f (x1,..., xm) c), or ε-transitions q1(x1) −→ q(x1), where x1,..., xm are dis- tinct variables and the constraint c is a Boolean combination of equalities xi = xj. Equivalently, the constraint c can be defined as a partition P of {1,..., m} with the same meaning as a conjunction of equalities xi = xj for the indexes i, j such that i ≡P j, and disequalities xi /= xj for the indexes i, j such that i /≡P j. Follow-

ing the notations of [2,3], the above transitions are written f (q1,..., qm) −→c  q (or f (q1,..., qm) → q when c is true) and q1 → q, and every equality xi = xj (resp. disequality xi /= xj) in the constraint c is written i = j (resp. i /= j). Note that every TA is the special case of BTTA whose constraints are all equal to true.
The language L(A, q) of a BTTA A in state q is the set of ground terms accepted
in state q by A, i.e. the terms t such that t −−∗→ q(t). The language L(A) of A is
Δ
L(A,q 

q∈Qf
) and a set of ground terms is called regular (resp. BT-regular ) if it is

the language of a TA (resp. BTTA).
Example 2.1 The following BTTA recognizes the set of Bin of complete binary trees over Σ = {a : 0,f : 2}, whose internal nodes are labeled by f and whose leaves are labeled by a: {q}, {q}, {a → q, f (q, q) −1−=−→2 q . It is well known that Bin is not regular.	 
A BTTA A is called deterministic (resp. complete) if for every term t ∈T (Σ), there is at most (resp. at least) one state q such that t ∈ L(A, q). If A is determin- istic and complete, this unique state is denoted A(t). A BTTA A is normalized if it does not contain ϵ-transitions, constraints in transitions are defined using parti- tions, and for every function symbol f with arity m, states q1,..., qm and partition
P of {1,..., m}, A contains exactly one rule of the form f (q1,..., qm) −P→ q. A
normalized BTTA A is deterministic and complete, and any BTTA can be trans- formed into a normalized one recognizing the same language. If A is normalized, we write A(t, P ), for a flat term t ∈ T (Σ ∪ Q), to denote the unique state q such
that t −P→ q is a transition of A. BTTA are useful for representing the set of normal
forms of certain classes of TRSs, like flat TRSs, see e.g. [3].
Lemma 2.2 [3] Let R be a flat TRS over Σ. There exists a normalized BTTA B = (QB, Qf , ΔB) on Σ which recognizes the set of ground R-normal forms. Moreover
|QB \ Qf | = 1.
Proof. The construction of B = (QB, QB \{qreject}, ΔB) on Σ is as follows. Its set of states QB is {qc | c ∈ Σ0}∪ {q, qreject} where all of them except qreject are accepting states. Its set of rules ΔB contains:
the rules c → qc for every constant c that is a R-normal form.
the rules c → qreject for every constant c that is not a R-normal form.
the	rules	f (q1,... qm)	−→c	qreject	such	that	either	some	qi	is
qreject	and  c  is  true,	or  every  qi	is  different  from  qreject	and  c  is
  ƒ (l ,...,l )→r∈R,∀1≤i≤m l ∈Σ ⇒q =q   1≤i<j≤m l =l ∈V i = j.
1	m	i	0	i	Æi	i	j
the rules f (q1 ... qm) −→c	q such that every qi is different from qreject and c is
 ƒ (l ,...,l )→r∈R,∀1≤i≤m l ∈Σ ⇒q =q  1≤i<j≤m l =l ∈V i /= j.
1	m	i	0	i	Æi	i	j

Example 2.3 Let Σ be the signature {a : 0,g : 1,f : 2} and R be the flat TRS
{g(x) → f (x, x)}. The BTTA B recognizing the ground R-normal forms is B =
 {qa, q, qreject}, {qa, q}, Δ  with Δ = {a → qa}∪ {g(q∗) → qreject,f (q∗, qreject) →
qreject,f (qreject, q∗) → qreject | q∗ = qa, q, qreject}∪ {f (q', q') → q | q' = qa, q}.	 

Closure under plain rewriting with shallow TRS
Right-(shallow and linear) TRSs preserve regularity [14]. It is well known that right-linearity cannot be omitted, as the following example shows.
Example 3.1 Let Σ = {a : 0,g : 1,f : 2} and R := {g(x) → f (x, x)} as in Exam-
ple 2.3 and let L be the regular language {gn(a) | n ≥ 0} = {a, g(a), g(g(a)),.. .}. The set R∗(L) is not regular because its intersection with the regular set T ({a, f}) is the non-regular set Bin of complete binary trees over Σ = {a : 0,f : 2}, and the
class of regular tree languages is closed under intersection.	 
We show below that considering BTTA does not help in this case.
Proposition 3.2 In general, R∗(L) is not BT-regular when L is a regular tree language and R a flat TRS.
Proof. Let us consider R, L and Bin as in Example 3.1. The set R∗(L) is not BT- regular. Indeed, the intersection of R∗(L) with the regular (hence BT-regular) set L2 := {f (s, t) | s ∈ T ({g, a}),t ∈ T ({f, a})} is the subset L' of terms f (s, t) ∈ L2 with t ∈ Bin and h(s) = h(t). This latter set is not BT-regular, as shown below. It follows that R∗(L) is not BT-regular because the class of BT-regular tree languages is closed under intersection [2].
Let us now show that L' is not BT-regular. Assume that it is recognized by a BTTA A = (Q, Qf, Δ) on Σ with n states, and for all i ≥ 1 let f (si, ti) be the term of L' with h(s) = h(t) = i. For each i, there exists a reduction sequence f (si, ti) −−∗→ q(f (si, ti)) with q ∈ Qf, and we consider the last rule ρi of Δ applied in this reduction sequence. There exist two distinct indexes i1, i2 ≥ 1 such that ρi1 = ρi2 . Let f (q1(x1), q2(x2)) −→c q(f (x1, x2)) be this unique rule of Δ. Note that the constraint c does not contain the equality x1 = x2, actually c may be x1 /= x2 or true. In both cases, it follows that f (si , ti ) −−∗→ f (q1(si ), q2(ti )) −−→ q(f (si , ti )). This

1	2	Δ
1	2	ρi1	1	2

is contradiction with the fact that f (si , ti ) ∈/ L' because h(si ) /= h(ti ).	 
1	2	1	2
Closure under innermost rewriting with shallow TRS
The essential problem in Proposition 3.2 relies on the fact that after an application of the rule g(x) → f (x, x) on a term g(t), producing f (t, t), the following application of rewrite rules can change the two occurrences of t in different ways, producing terms f (t1, t2) with t1 /= t2. The equality constraints of BTTA have not the expressive power to capture the relation relating t1 and t2 (i.e. that both are reachable from a common term). The situation is getting better when the innermost strategy is applied.
Example 4.1 In Example 3.1, when we apply the rule g(x) → f (x, x) to terms of L = {gn(a) | n ≥ 0} with the innermost strategy, the subterm where it is applied must be g(t) for a R-normal form t. Hence, in the term f (t, t) obtained, t cannot be modified by rewriting. Hence R±(L) = {gn(t) | t ∈ Bin,n ≥ 0}. This set is

BT-regular; it is indeed recognized by the following BTTA:
 {q, qg}, {q, qg}, {a → q, f (q, q) −1−=−→2  q, g(q) → qg, g(qg) → qg .


Note however that R±(L) is not regular in the above example.
Proposition 4.2 In general, R±(L) is not regular when L is a regular tree language
L and R a flat TRS.
Closure of BTTA languages with flat TRS
Linear and flat TRSs preserve regularity [15]. This result cannot be extended to BT-regularity, neither for plain nor innermost rewriting.
Proposition 4.3 In general, R∗(L) and R±(L) are not BT-regular when L is BT- regular and R is a flat and linear TRS.
Proof. The tree language L = {h(fn(0),fn(0)) | n ≥ 0} is recognized by the following BTTA, with one equality constraint tested at the root position:
 {q, qf}, {qf}, {0 → q, f (q) → q, h(q, q) −1−=−→2 qf} . Note that L is not regular.
Let us consider the flat and linear TRS R = {f (x) → g(x)} and the regu- lar tree language L' = {h(fn(0), gm(0)) | n ≥ 0}.  The closure R∗(L) ∩ L' =
{h(fn(0), gn(0))} is not BT-recognizable, hence R∗(L) is neither BT-recognizable. This is also true if we consider innermost rewriting.	 
Closure of TA languages with shallow TRS
The classical approach for proving preservation of regularity [11,14,16] consists in completing a TA recognizing the original language L with new rules inferred us- ing R. This method cannot be generalized to BT-regular languages, according to Proposition 4.3. Therefore, we follow a different approach.
We prove first that given a regular tree language L and a flat TRS R on a signature Σ , we can generate a new TRS Rc over an extended signature including a new constant c such that R±({c}) coincides with R±(L) on the given signature Σ. This simple and enabling result permits to represent the set of terms innermost- reachable from a regular term set as the set of terms innermost-reachable from a constant.
Later, we show how to compute a BTTA recognizing the terms innermost- reachable from a constant. To this end we make use of some results in [8] on innermost rewriting with shallow TRSs.
Simplifying assumptions on the signature and the TRS.
All the results of this section are concerned with shallow TRS over an arbitrary signature. In order to simplify the proof, we shall assume fixed from now on in this section a TRS R over a signature Σ who following these two non restrictive assumptions:

Σ contains several constant function symbols and only one non-constant symbol
f of arity m,
the TRS R is flat.
Such assumptions, already used e.g. in [8], can be made without loss of generality for the problem considered here, see [7] for details.
Reduction to terms innermost-reachable from constants.
Our goal is to reduce the effort of characterizing the set of terms innermost-reachable with R from a regular language L to characterizing the set of terms innermost- reachable from a single constant. The idea is to add to the rewrite system R the inverse of the transition rules of a TA A recognizing L. We show then that the generation of the terms of L starting from the final states of A and using the transitions of A backward can be performed following the innermost strategy.
Lemma 4.4 For every flat TRS R and regular language L, over a signature Σ, there exists an extension Σ' ⊃ Σ, a constant c ∈ Σ' \ Σ and a flat TRS Rc over Σ' such that R±({c}) ∩T (Σ) = R±(L).
Proof. Let A = (Q, Qf, Δ) be a TA on Σ recognizing L. Without loss of generality, we assume that every state q ∈ Q is the target of a rule of Δ. Let Σ' be Σ ∪Q∪ {c}, where c is a new constant not in Σ ∪ Q and let Rc be R∪ Δ−1 ∪ {c → q | q ∈ Qf}. We prove that R±({c}) ∩T (Σ) = R±(L).
Direction ⊇. Let t ∈ R±(L) and let s ∈ L such that s −−±→ t. We have s −−±→ q ∈ Qf.
R	Δ
Therefore c −−ı−→ q −−±−→ s −−±→ t and hence c −−±→ t.

c→q
Δ−1	R	Rc

Direction ⊆. Let t ∈T (Σ) be such that c −−±→ t. Since c /∈ Σ, there is necessarily
c
in this derivation at least one rewrite step of the form c −−ı→ q for q ∈ Qf. The
c
subderivation q −−±→ t can contain alternate rewrite steps using rules of Δ−1 or of R.
c
We want to show that these rewrite steps can be commuted such that a (Δ−1 ∪ R)-

innermost derivation of the form q −−∗−−→1
s −−∗→
t is possible. To this end it is

sufficient to see that any (Δ−1 ∪ R)-innermost subderivation u −R−,−p→ v −Δ−−−−1,−p→ w
1	2
can be commuted to a (Δ−1 ∪ R)-innermost subderivation u −Δ−−−−1,−p→ v' −R−,−p→ w,
2	1
which will be straightforward if we prove that the positions p1 and p2 are disjoint.
Note that the term u|p1 does not contain any symbol q ∈ Q: otherwise the rewrite step u −R−,−p→ v would not be (Δ−1 ∪ R)-innermost since there exists a rule of the
form q → r in Δ−1 according to our assumptions. Hence, v|p  does not contain
any symbol q ∈ Q neither. Therefore, the rewrite step v −Δ−−−−1,−p→ w is produced at
a position p2 disjoint with p1, and we are done. Hence, there exists a (Δ−1 ∪ R)- innermost derivation q −−∗−→ s −−∗→ t. In order to prove that t ∈ R±(L) it suffices
Δ−1	R
to see that s ∈ L. Since s −−±→ q ∈ Qf, it is enough to prove that s ∈ T (Σ), i.e. that s does not contain any symbol q ∈ Q. Suppose that s|p is a certain q ∈ Q. Similarly as before, no rule in R can be applied at a position p' < p. Otherwise this rewrite step would not be innermost. Hence, repeated applications of rules of R under innermost rewriting do not remove q. Therefore, q is a symbol occurring

in t, a contradiction.	 
Note that this reduction works only when the innermost strategy is used. How- ever, it is valid for any class of TRS closed under the addition of ground rules.
Example 4.5 Let Σ = {a : 0,g : 1,f : 2}, R := {g(x) → f (x, x)} and L = {gn(a) | n ≥ 0} as in Example 3.1. In order to fulfil the conditions of Lemma 4.4, we let Σ' = Σ {c}, and Rc = R∪ {c → g(c),c → a}.
The following BTTA B is built following the construction in the proof of Lemma 4.4 for the recognition of the ground normal forms for this extended TRS. It extends the BTTA of Example 2.3. B = {qa, qc, q, qreject}, {qa, qc, q}, Δ with Δ = {a → qa,c → qreject}∪ {g(q∗) → qreject,f (q∗, qreject) → qreject,f (qreject, q∗) → qreject | q∗ = qa, qc, q, qreject}∪ {f (q', q') → q | q' = qa, qc, q}. Note that B can be cleaned: all the transition rules with qc in left hand side can be removed since no term is recognized in this state.	 

Weak normal forms and constrained terms.
From [8], we have the following definitions and results. A term t is a weak normal form if it is either a constant or a term of the form t = f (t1,..., tm) such that every ti is either a constant or a normal form.
Let P(Σ0) denotes the powerset of Σ0 minus the empty set. A constraint C is a partial function C : V → P(Σ0) i.e. an assignment from variables to non-empty sets of constants. We say that a substitution σ is a solution of a constraint C (with respect to a TRS R) if for all x in dom(C), σ(x) ∈ NF± (C(x)) \ Σ0.  A
constrained term is a pair denoted t|C, where t is a flat term and C is a constraint,
with dom(C) = vars(t). A term σ(t) is called an instance of t|C if σ is a solution of C. Note that every instance of a constrained term is a weak normal form.
In [8] it is shown how to compute for every flat TRS R and for every constant c ∈ Σ0 two finite sets rc and rc of flat constrained terms whose set of instances (resp. normal form of instances) contain exactly the weak normal forms (resp. non-constant normal forms) innermost-reachable from c. More precisely, rc and rc satisfy the following properties.
for every t|C ∈ rc, there exists at least one solution of C, and all instances of
t|C are innermost-reachable from c.
for every t|C ∈ rc, all non-constant normal form instances of t|C are innermost- reachable from c.
for every weak normal form s innermost-reachable from c, there exists some constrained term t|C ∈ rc such that s is an instance of t|C.
for every non-constant normal form s innermost-reachable from c, there ex- ists some constrained term f (t1,..., tm)|C ∈ rc such that s is an instance of f (t1,..., tm)|C.
Example 4.6 Let us consider the TRS Rc = {g(x) → f (x, x),c → g(c),c → a} of Example 4.5. We have NF± (c) = Bin, the set of complete binary trees of T {a, f} .

The  set  of  weak  normal  forms  innermost-reachable  from  c  is
{c, a, g(c), g(a),f (c, c)} ∪ {g(t),f (t, t) | t ∈ Bin}, and its subset of normal forms innermost-reachable from c is is {a}∪ {f (t, t) ∈ Bin}. The following sets satisfy the above properties:
rc = c|∅, a|∅, g(c)|∅, g(a)|∅,f (c, c)|∅,f (a, a)|∅, g(x)|{x '→ {c}},f (x, x)|{x '→ {c}}},
rc =  f (a, a)|∅,f (x, x)|{x '→ {c}}},  ra =  a|∅},  ra = ∅	 

Recognizing terms innermost-reachable from constants.
We assume some sets rc and rc as above and we construct a normalized BTTA AR which recognizes the terms innermost-reachable from constants in Σ0 using R with the innermost strategy. For this purpose, we shall use the BTTA B of Lemma 2.2 recognizing the ground normal forms of R. Let Q0 = {q ∈ QB | ∃d ∈ Σ0, B(d) = q}, and Q1 = Qf \Q0. Without loss of generality we assume that only constants lead to states in Q0. Thus, the states of Q1 characterize the set of non-constant R-normal- form. The states of AR are pairs ⟨S, q⟩, where S ⊆ Σ0 and q ∈ QB. The intuitive idea is that a term t will lead to ⟨S, q⟩ with AR if it leads to q with B and S is the set of all constants that innermost-reach t with R. To this end, the set of transition rules contains:
b → {d | b|∅ ∈ rd}, B(b) , for every constant b.
f ⟨S1, q1⟩,..., ⟨Sm, qm⟩ −P→ S, B f (q1,..., qm),P  , for every S1,..., Sm ⊆ Σ0,
q1,..., qm ∈ QB, and partition P of {1,..., m}, and where S is the set of constants
c ∈ Σ0 such that there exists f (α1,..., αm)|C ∈ (rc ∪ rc) with:
∀1 ≤ i ≤ m, if αi ∈ Σ0 then αi ∈ Si and if αi ∈V then C(αi) ⊆ Si and qi ∈ Q1,
∀1 ≤ i < j ≤ m, if αi = αj ∈ V then i ≡P j and if f (α1,..., αm)|C ∈ rc \ rc
  
By construction, the automaton AR is normalized.
Example 4.7 Let us come back to Examples 4.5 and 4.6. The BTTA constructed as above in this case has the following transitions rules (we forget several useless rules for the sake of clarity):
a	→	 {a, c}, qa ,	c →  {c}, qreject ,
f ⟨{a, c}, q'⟩, ⟨{a, c}, q'⟩ −1−=−→2 ⟨{c}, q⟩	(q' = qa, q), f ⟨{c}, q'⟩, ⟨{c}, q'⟩ −1−=−→2 ⟨{c}, q⟩,
g(⟨{a, c}, q∗⟩) → ⟨{c}, qreject⟩, g(⟨{c}, q∗⟩) → ⟨{c}, qreject⟩ (q∗ = qa, q, qreject).	 

The following lemma states the correctness of the construction of the BTTA AR.
Lemma 4.8 For all t ∈T (Σ) AR(t) = {d ∈ Σ0 | d −−±→ t}, B(t) .

Proof. Let AR(t) = ⟨S, q⟩. It is straightforward by construction that B(t) = q. We prove S = {d ∈ Σ0 | d −−±→ t} by induction on the size of t.

We first consider the case where t is a constant. By definition of AR, S = {d ∈ Σ0 | (t|∅) ∈ rd}. It suffices to see that the conditions d −−±→ t and (t|∅) ∈ rd are equivalent when t is a constant. This is a consequence of conditions (a ) and (c) above.
Now, assume that t is of the form f (t1,..., tm). Let ⟨S1, q1⟩ = AR(t1), ..., 
⟨Sm, qm⟩ = AR(tm). By induction hypothesis, B(ti) = qi and Si = {d ∈ Σ0 | d −−±→
R
P
fired in the last applied transition of AR(t). Then, it holds that i ≡P j iff ti = tj. We prove the two inclusions of S = {d ∈ Σ0 | d −−±→ t} separately.
Direction ⊆. Let c ∈ S. By construction of AR there exists a constrained term
f (α1,..., αm)|C ∈ (rc ∪ rc) for which the above conditions i and ii hold.
Let σ be a substitution of domain vars(f (α1,..., αm)) with σ(αi) := ti. The substitution σ is well defined: if for different i and j we have αi = αj ∈ V, by condition ii, it implies that i ≡P j and then ti = tj. It holds that every such σ(αi) is a non-constant normal form, because αi ∈ V implies that qi = B(ti) ∈ Q1 due to condition i. Moreover, σ(αi) is reachable from C(αi) because αi ∈ V implies C(αi) ⊆ Si from condition i and Si = {d ∈ Σ0 | d −−±→ ti} by induction hypothesis.
Altogether, it follows that σ(f (α1,..., αm)) is an instance of f (α1,..., αm)|C ∈ (rc ∪rc). We know that either f (α1,..., αm)|C ∈ rc or f (α1,..., αm)|C ∈ rc \rc. On the one hand, if f (α1,..., αm)|C ∈ rc then, by condition a, c −−±→ σ(f (α1,..., αm)). On the other hand, if f (α1,..., αm)|C ∈ rc \ rc then condition ii implies that B(f (q1,..., qm),P ) ∈ Q1, and hence q ∈ Q1 and t is a non-constant normal form. Moreover, the αi’s that are constants are also normal forms.  For every one of
these constants αi we know that αi ∈ Si, and hence we also have αi −−±→ ti.
But since this αi is a normal form it follows that αi = ti. This implies that σ(f (α1,..., αm)) = t, and hence, that t is a non-constant normal form that is an instance of f (α1,..., αm)|C ∈ rc, and by condition b, c −−±→ σ(f (α1,..., αm)).

Hence it suffices to show that σ(f (α1,..., αm)) −−±→
t in order to conclude.

By definition of σ, terms σ(f (α1,..., αm)) and t can only differ in the positions
i such that αi is a constant. But in such cases we know that αi ∈ Si, and using
Si = {d ∈ Σ0 | d −−±→ ti} we obtain αi −−±→ ti. Hence, σ(f (α1,..., αm)) −−±→ t follows.
R	R	R
Direction ⊇. Let c be such that c −−±→ t. Since t is not a constant, the previous derivation can be written by making explicit the last rewrite step at position Λ as (>Λ represents any position other than Λ):
c −−±→−−−→ f (s1,..., sm) −−−±−→ t = f (t1,..., tm)
R	R,Λ	R,>Λ
Hence, there exist (sub-)derivations si −−±→ ti. The term s = f (s1,..., sm) is a weak normal form, and hence, by condition c, there exists a constrained term u|C ∈ rc such that s is an instance of u|C. At this point, either there exists such a u of the form f (α1,..., αm), or every u satisfying this condition is a variable. In the second case, s is necessarily a normal form, and hence, by condition d , there exists a con- strained term f (α1,..., αm)|C in rc such that s is an instance of f (α1,..., αm)|C. For proving that c ∈ S, it suffices to show that the conditions i and ii hold.

If a certain αi is a constant, then it coincides with si, which R-reaches ti. Since
Si = {d ∈ Σ0 | d −−±→ ti}, it necessarily contains αi.
If a certain αi is a variable, then si coincides with ti and is a non-constant normal form reachable from C(αi). Hence, qi = B(ti) is in Q1, and again since Si = {d ∈ Σ0 | d −−±→ ti}, it necessarily includes C(αi).
If αi = αj ∈V then si = sj and since both are normal forms we also have ti = tj, from which i ≡P j follows.
In the case where f (α1,..., αm)|C belongs to rc \ rc, f (s1,..., sm) is a non- constant normal form. Therefore, q = B(f (q1,..., qm),P ) ∈ Q1 and all the con- stants αi are also normal forms.	 
Given a flat TRS R and a regular set L, the BTTA ARc (corresponding to the Rc associated to R as in Lemma 4.4), restricted to the signature Σ of R, recognizes R±(L) by marking as accepting states the pairs ⟨S, q⟩ such that c ∈ S, according to Lemmas 4.4 and 4.8. Together with the simplifying assumptions on the TRS, this permits to conclude the proof of Theorem 4.9.
Theorem 4.9 R±(L) is BT-regular when L is regular and R is shallow.
Ground reachability (is a given ground term t reachable from another given ground term s?) and joinability (does there exists a term u reachable from two given ground terms s and t?) are undecidable for flat TRSs [13]. They become decidable when the innermost strategy is applied [8]. We can express this property here as a corollary of Theorem 4.9.
Corollary 4.10 Ground reachability and joinability are decidable for innermost rewriting with shallow TRS.
Proof. When restricting to innermost rewriting, t is reachable from s iff t ∈ R±({s}). Since {s} is a regular language when s is ground, R±({s}) is BT-regular by Theorem 4.9. Therefore ground reachability reduces to the membership problem for BTTA, which is decidable.
Similarly, s and t are joinable iff R±({s}) ∩ R±({t}) /= ∅. By Theorem 4.9 and closure of BT-languages under Boolean operations [2,3], we obtain a reduction of ground joinability to the emptiness problem for BTTA, which is also decidable. 
In [1] the decidability of the regularity of a BTTA was shown. Combining this result with Theorem 4.9 we obtain the following corollary.
Corollary 4.11 Given a regular language L and a shallow TRS R, it is decidable whether R±(L) is regular.
This result does not hold when we deal with plain rewriting. In [13] it has been proved that reachability is undecidable for flat TRSs by reduction of the Post correspondence problem into 0 −−∗→ 1. We show below how to extend R into R0
such that R∗(0) is regular iff 0  ∗R 1.
0	R

Theorem 4.12 Given a regular language L and a flat TRS R, it is undecidable whether R∗(L) is regular.

Proof. In [13] it is proved that reachability is undecidable for flat TRSs by reduc- tion of a PCP instance P into a TRS R over a signature including {0, 1} such that P has a solution iff 0 −−∗→ 1. The reduction in [13] also satisfies that if P has no solution, the 0 does not reach any term containing 1 nor any term containing 0 properly.
This reduction can be modified by adding new symbols {f, h, g, a, b, c} to the current signature Σ, and adding two new sets of rules to R: R1 = {0 → f (a, b),a → g(a),b → g(b),a → c, b → c, f (x, x) → h(x, x)} and R2 containing all the necessary rules for making R∗(1) to be T (Σ ∪ {f, h, a, b, c}). The rules of R ensure (R∪ 
R1 ∪ R2)∗(0) to be a non-regular language, unless 0 −−∗→ 1.  Note that if P has
solution, then 0 −−∗→ 1, and hence (R∪R ∪R )∗(0) is T R ∪ {f, h, a, b, c}), which is
R	1	2	(Σ
regular. Otherwise, if P has no solution, then 0 does not reach any term containing 1, nor containing 0 properly, and hence (R∪ R1 ∪ R2)∗(0) ∩T ({h, c}) is the set
{h(gn(c), gn(c)) | n > 0}, which is not regular.	 

Innermost rewriting and right-shallow TRS
In this section, we study the closure of regular languages under innermost rewriting with TRS whose right-hand sides of rules are shallow. We show that regularity is preserved by innermost rewriting with linear right-shallow TRSs (Subsection 5.1), but not by innermost rewriting with right-(linear and flat) (non left-linear) TRSs (Subsection 5.2). The first result was also proved independently in [12].

TA languages and linear and right-shallow TRS
First, we observe that every right-shallow TRS R can be transformed into a right- flat TRS R' (on an extended signature) such that for all s, t ∈ T (Σ), s −−±→ t iff

s −−±→ t. The idea is to add a new constant c  and a rule c
→ r for every ground

R'	r	r
proper subterm r of a right-hand side of a rule of R, and to replace r by cr in all the right-hand sides of R. This transformation preserves linearity and reachability between terms of the original signature.
Let A = (Q, Qf, Δ) be a deterministic and complete TA on Σ recognizing a tree language L, and let R be a linear and right-flat TRS. For all c ∈ Σ0 we denote as qc the unique state of Q such that c → qc ∈ Δ. We assume moreover wlog that
L(A, qc) = {c}.
We construct a finite sequence of TA A0, A1,... whose last element recognizes R±(L). The construction of the sequence is incremental. Every Ak+1 is obtained from Ak by the addition of some new transitions, such that if some term s is recognized by Ak and s rewrites (in one step of innermost rewriting) to t, then t is recognized by Ak+1.

In order to restrict to innermost rewriting, we shall use a complete and de- terministic TA B = (QB, Qf , ΔB) (without ε-transitions) recognizing the ground R-normal forms (see e.g. [3] for its construction). As in Lemma 2.2, we can assume that B has only one non-accepting state qreject. Let A0 be a TA rec- ognizing L(A):  A0 :=  Q × QB, Qf × QB, Δ0  where Δ0 is the set of transi-
tions f ⟨q1, q' ⟩,..., ⟨qm, q' ⟩  → ⟨q, q'⟩ such that f (q1,..., qm) → q ∈ Δ and

f (q' ,..., q'
1	m
) → q' ∈ ΔB.

1	m
The addition of transition rules to Ak, giving Ak+1, is defined by the superposi-
tion of rules of R into a sequence of transitions of Δk. More precisely, Ak+1\Ak con- tains all the transitions which can be constructed from a rewrite rule l → r of R (we let l = f (l1,..., lm)) and a substitution θ of the variables of l into states of Q×Qf whose accepted language wrt Ak is not empty, such that: θ(l) −−∗→ ⟨q0, qreject⟩, and

the last step of the above reduction is	'
'   Δk
and

f  ⟨q1, q1⟩,..., ⟨qm, qm⟩  −Δ−→ ⟨q0, qreject⟩

for all i ≤ m, q' /= qreject
. There are two cases for the transitions of Ak+1 \ Ak:

case 1: r is a variable. In this case, r ∈ vars(l). Let ⟨q, q'⟩ = θ(r), we add the
ε-transition ⟨q, q'⟩ →− ⟨q0, q'⟩.
case 2: r = g(r1,..., rm). We add all the transitions g ⟨q1, q' ⟩,..., ⟨qm, q' ⟩ →
1	m
⟨q0, q'⟩ such that g(q' ,..., q' ) → q' ∈ ΔB and for each i ≤ m, if ri is a variable
1	m

then ⟨qi, q' ⟩ := θ(ri), otherwise, if ri is a constant then qi is qr
restriction for q' .
and there is no

All the TAs have the same state set, hence the construction terminates with a fixpoint denoted A∗. The number |A∗| of states of A∗ is at most |A|× |B|, and the number of rules of A∗ is polynomial in the same measure 3 , if we assume as usual that the maximum arity m of a function symbol is fixed for the problem.
We show that L(A∗) = R±(L(A)), more precisely, that for all t ∈ T (Σ), t ∈ L A∗, ⟨q, q'⟩ iff t ∈ L(B, q') and there exists s ∈ L(A, q) such that s −−±→ t. To this end we follow the principle of the proofs given e.g. in [15,11,14], but some technical difficulties appear when we try to replace a subterm by another subterm while preserving an execution with Δ∗. They are solved thanks to the following technical Lemma 5.1(its proof can be found in [7]).

Lemma 5.1 For all t ∈T (Σ ∪ Q ∗ ), if t ⟨q ,q 

⟩  −−∗→ ⟨q, q
⟩ then, for all

A	0 reject
p Δ∗
reject

q' ∈ QB
, there exists q'' ∈ QB
such that t[⟨q0, q'⟩]p
−−∗→∗  ⟨q, q''⟩.

Theorem 5.2 R±(L) is regular when L is regular and R is linear and right-shallow.
Proof. (sketch, the complete proof can be found in [7]). The if direction is proved by induction on the number of rewrite steps in s −−±→ t, using Lemma 5.1.
The other direction is proved by an induction on the multiset associated to the derivation t −−∗→∗  ⟨q, q'⟩ by mapping each transition rule ρ used to the least index i of the Ai to which ρ belongs.	 

3 Note however that |B| can be exponential in the size of R in the worst case.

Closure of TA languages with right-(linear and flat) TRS
When we drop the restriction that R is left-linear in Theorem 5.2, we lose regularity preservation with innermost rewriting. This is in contrast with plain rewriting, since regularity is preserved for right-linear and right-shallow TRSs [14].
Proposition 5.3 In general, R±(L) is not BT-regular when L is regular and R is right-linear and right-flat.
Proof. Let L = {f (f (a, a), c)}, and R = {f (x, c) → x, f (g(x), x) → h(x), h(x) → h(x),a → g(a),a → b}. The intersection of R±(L) with the language of all terms containing only the symbols f , g, b is the set {f (gn(b), gm(b)) | n /= m + 1}, which is not BT-regular.	 
Conclusion and further work
We have covered much of the cases of closure of TA and BTTA languages by in- nermost rewriting, providing results for each case. The positive results are that the set of terms innermost-reachable from a regular language with a shallow TRS is BT-regular, and it is regular when the TRS is linear and right-shallow. Moreover, given a shallow TRS, regularity of the innermost-reachable terms from a regular language is decidable. Other consequences are the decidability of the problems of ground reachability, ground joinability and regular tree model checking (given two regular languages Linit and Lbad and the TRS R, do we have R± Linit ∩ Lbad = ∅?) for innermost rewriting with TRS in the above classes.
As future work, it could be interesting to consider other variants of TA with more general or different constraints, and to consider other strategies of rewriting different from innermost.

References
B. Bogaert, F. Seynhaeve, and S. Tison. The recognizability problem for tree automata with comparisons between brothers. In Second International Conference on Foundations of Software Science and Computation Structure, (FoSSaCS), volume 1578 of Lecture Notes in Computer Science, pages 150–164. Springer, March 1999.
B. Bogaert and S. Tison. Equality and disequality constraints on direct subterms in tree automata. In
International Symposium on Theoretical Aspects of Computer Science (STACS), pages 161–171, 1992.
H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi. Tree automata techniques and applications. Available on: http://www.grappa.univ-lille3.fr/tata, 2007.
N. Dershowitz and J. P. Jouannaud. Rewrite systems. In Handbook of Theoretical Computer Science (Vol. B: Formal Models and Semantics), pages 243–320, North-Holland, 1990.
I. Durand and G. S´enizergues. Bottom-up rewriting is inverse recognizability preserving. In 18th International Conference on Term Rewriting and Applications (RTA), volume 4533 of LNCS, pages 107–121. Springer, 2007.
R. Gilleron and S. Tison. Regular tree languages and rewrite systems. Fundam. Inform., 24(1/2):157– 174, 1995.
G. Godoy, A Gasc´on, and F Jacquemard. Closure of Tree Automata Languages under Innermost Rewriting. Laboratoire Sp´ecification et V´erification, Research Report number 08-31, 2008. http:
//www.lsv.ens-cachan.fr/Publis/RAPPORTS_LSV/PDF/rr-lsv-2008-30.pdf


G. Godoy and E. Huntingford. Innermost-reachability and innermost-joinability are decidable for shallow term rewrite systems. In 18th International Conference on Term Rewriting and Applications (RTA), volume 4533 of LNCS, pages 184–199, Springer, June 2007.
G. Godoy, E. Huntingford, and A.Tiwari. Termination of rewriting with right-flat rules. In 18th International Conference on Term Rewriting and Applications (RTA), volume 4533 of LNCS, pages 200–213, Springer, 2007.
G. Godoy and A. Tiwari. Confluence of shallow right-linear rewrite systems. In 19th International Workshop of Computer Science Logic (CSL), volume 3634 of LNCS, pages 541–556, Springer, 2005.
F. Jacquemard. Decidable approximations of term rewriting systems. In 7th International Conference on Rewriting Techniques and Applications (RTA), volume 1103 of LNCS, pages 362–376, Springer, 1996.
Yoshiharu Kojima and Masahiko Sakai. Innermost reachability and context sensitive reachability properties are decidable for linear right-shallow term rewriting systems. In 19th International Conference on Rewriting Techniques and Applications (RTA), volume 5117 of LNCS, pages 187–201. Springer, 2008.
I. Mitsuhashi, M. Oyamaguchi, and F. Jacquemard. The confluence problem for flat TRSs. In 8th International Confernce on Artificial Intelligence and Symbolic Computation (AISC), volume 4120 of LNAI, pages 68–81. Springer, 2006.
T. Nagaya and Y. Toyama. Decidability for left-linear growing term rewriting systems. In 10th International Conference on Rewriting Techniques and Applications (RTA), volume 1631 of LNCS, pages 256–270. Springer, 1999.
K. Salomaa. Deterministic tree pushdown automata and monadic tree rewriting systems. J. Comput. Syst. Sci., 37:367–394, 1988.
T. Takai, Y. Kaji, and H. Seki. Right-linear finite path overlapping term rewriting systems effectively preserve recognizability. In 11th International Conference on Rewriting Techniques and Applications, (RTA), volume 1833 of LNCS, pages 246–260, 2000.
W.S.Brainerd. Tree generating regular systems. Information and Control, 4:217–231, 1969.
