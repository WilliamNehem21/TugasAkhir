

Electronic Notes in Theoretical Computer Science 242 (2009) 161–183
www.elsevier.com/locate/entcs

A Calculus for Mobile Ad-hoc Networks with Static Location Binding
Jens Chr. Godskesen 1
IT University of Copenhagen

Abstract
We present a process calculus for mobile ad hoc networks which is a natural continuation of our earlier work on the process calculus CMAN [6]. Essential to the new calculus is the novel restricted treatment of node mobility imposed by hiding of location names using a static binding operator, and we introduce the more general notion of unidirectional links instead of bidirectional links. We define a natural weak reduction semantics and a reduction congruence and prove our weak contextual bisimulation equivalence to be a sound and complete co-inductive characterization of the reduction congruence.
The two changes to the calculus in [6] yields a much simpler bisimulation semantics, and importantly and
in contrast to [6] we manage to provide a non-contextual weak bisimulation congruence facilitating ease of proofs and being strictly contained in the contextual bisimulation.
Keywords: Mobile ad-hoc network, statis location binding, process calculi, CMAN


Introduction
The widespread use of communicating mobile devices makes mobile and wireless networks become more and more important. The area of application is broad, spanning from ambient intelligence over mobile ad hoc, sensor, and mesh networks, to cellular networks for mobile telephony.
The communication primitive for wireless networks is message broadcast. How- ever in contrast to wired local area networks where broadcasted messages reach every node in the network, for wireless networks broadcast is local because mes- sages will only reach the nodes within the communication range of the emitting node. Put differently, in wired networks broadcast scope is transitive and bidirec- tional in that if nodes l and m can communicate directly and if m and n can do so also, then in turn l and n can communicate directly whereas this is not necessarily the case for wireless networks.

1 Supported by grant no. 272-05-0258 from the Danish Research Agency.
2 Email: jcg@itu.dk

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.06.018

Our work is devoted to a particular kind of wireless networks, i.e. Mobile Ad Hoc Networks (MANETs). MANETs are self organizing without centralized control, and they do not contain a pre-deployed infrastructure for routing messages. A MANET may be formed when a collection of nodes join together and agree on how to route messages for each other over possibly multiple hops.
In this paper we present a process calculus for MANETs which is a natural continuation and refinement of our earlier work on the calculus CMAN [6]. Es- sential to the new calculus is the restricted treatment of node mobility imposed by hiding of location names using a static binding operator, this yields a much sim- pler labelled transition system and bisimulation semantics. To our knowledge no other calculus for MANETs hides nodes and restricts mobility through a calculus operator. Also, we introduce the more general notion of unidirectional links instead of bidirectional links; e.g. because some nodes have larger transmission range than others. We define a natural weak reduction semantics, radically different from the one in [6], and we define a reduction congruence and prove our weak contextual bisimulation equivalence to be a sound and complete co-inductive characterization of the reduction congruence. Most importantly, and in contrast to [6], we conve- niently manage to devise a non-contextual weak bisimulation congruence that is a considerably advantage in many proofs. The non-contextual bisimulation is strictly contained in our reduction congruence.

Related Work
Despite the widespread use of broadcasting technology it turns out that process calculi for broadcasting systems are not as well-studied as the more common point-to-point calculi like e.g. CCS [9], or in a mobile setting for instance the π- calculus [10,11] and the Ambient Calculus [3]. Moreover, in [5] it is demonstrated that that it is impossible to encode broadcast communication using point-to-point communication uniformly in the π-calculus.
The first study of calculi for broadcasting systems was CBS [15]. Later broad- casting was introduced in a mobile setting in bπ [4], MBS [16], and HOBS [14]. However, they all let broadcast be transitive and hence are not well suited for local wireless broadcast. More recently local wireless broadcast has been studied in CBS# [13], an extension of CBS. The neighborhood relation between nodes is dealt with letting the semantics be parameterized and quantified over a set of configurations (graphs).
The ω-calculus [17] is an extension of the π-calculus. It is interesting in that the neighborhood relation is modeled by annotating the processes with the groups to which they belong. A group is a set of nodes that lie within each others communi- cation range. Local wireless broadcast has also been studied in CMN [7], here the neighborhood relation is taken care of by a metric function that tells if two physical locations are close enough to communicate. 3

3 The calculus CWS [8] also studies wireless broadcast but at a much lower level of abstraction, in particular they take the phenomenon of interference into account.

As mentioned above, in [6] we developed CMAN where also the neighborhood relation is explicitly part of the syntax because a node is annotated by the nodes to which it is connected. However, a bit unnaturally, and like in the ω-calculus, communication between nodes is carried out on bidirectional links. Further we assumed, as in CBS#, CMN, and the ω-calculus, that nodes may move and connect arbitrarily, but to be realistic it is easy to envisage that two particular mobile nodes in a MANET can never meet due to physical obstacles (walls, buildings, etc.). Even though we apply many changes to CMAN in this paper the analysis of a cryptographic routing protocol for MANETs carried out in [6] is still valid for our new calculus.
Motivation
Our goal in this paper is to develop a process calculus for MANETs where commu- nication links are not assumed to be bidirectional, and moreover we want primitives that restrict the otherwise unrestricted mobility of nodes.
A node, [p♩σ, in our new calculus is modeled as a process p located at some logical location (or identity) l and connected to other nodes at locations σ. Nodes composed in parallel constitute a network, say

(1)
[p♩m
[q♩n
 [r♩n ,

where the node at location l, [p♩m, is connected to the node at location m, [q♩n ,
l	m
which in turn is connected to the node at location n, [r♩n.
Mobility is defined by a simple reduction, say that the node at location n in (1) autonomously moves and becomes connected to the node at location l,

(2)
[p♩m
[q♩n
 [r♩n  [p♩m
[q♩n
[r♩l .

Dually, nodes may arbitrarily disconnect, for instance m disconnects from n in

(3)
[p♩m
[q♩n
[r♩l
  [p♩m
 [q♩m  [r♩l .

A process ⟨t⟩.p can broadcast t and in so doing become p, and a process (x).q can receive a broadcasted message t becoming q{t/x}, i.e. q with all free occurrences of x replaced by t. Local synchronous broadcast is defined by a network broadcast reduction labelled by the location of the node containing the emitting process, say

(4)
[⟨n⟩.p♩mk
 [(x).q♩m  [(x).r♩k  l [p♩mk
 [q{n/x}♩m  [r{n/x}♩k ,

where ⟨n⟩.p broadcasts n to all nodes to which the node at l is connected.
In CMAN one may choose to hide locations in order to let broadcasting be unobservable, the hiding is carried out by a scope extensible binder, νl. For in- stance, the hidden node νl.[⟨n⟩.p♩l, may connect to other nodes by first extruding its location name (through structural congruence, assuming l is fresh),


νl.[⟨n⟩.p♩l  [(x).q♩m ≡ νl.([⟨n⟩.p♩l  [(x).q♩m)  νl.([⟨n⟩.p♩m
 [(x).q♩m) ,

and subsequently send its messages to its new neighbor,


νl.([⟨n⟩.p♩m
 [(x).q♩m)  νl.([p♩m
 [q{n/x}♩m) ,

the latter carried out as an unlabelled and hence unobservable reduction. As a novelty, in this paper we instead introduce a static binder for location names, de- noted by \l, whose scope cannot be extended and we abolish the scope extensible binder mentioned above. Not only will such a binding outside its scope conceal all broadcasting events carried out at l, but also connectivity involving the node at l is restricted within the scope of the binder. For instance, in

(5)
P  [r♩k ,	where P = ([⟨n⟩.p♩m
 [(x).q♩m) \ l

the location name l is bound and inaccessible to the node at k, so the two nodes cannot connect and hence not directly receive messages from each other. The hidden node in (5) may broadcast to m as demonstrated by

(6)
P  ([p♩m
 [q{n/x}♩m) \ l ,

but then the broadcast is carried out as an unobservable unlabelled reduction.


Structure
The paper is organized as follows: Our new calculus is presented in the next section and in Section 3 we define a reduction semantics and a reduction congruence. In Section 4 we define bisimulation equivalences, one being a contextual co-inductive characterization of the reduction congruence, and one being a non-contextual con- gruence strictly contained in reduction congruence.
We illustrate the application of the calculus on a simple cryptographic message passing protocol where node mobility is restricted, this example could not have been modeled and analyzed in our previous work [6]. Finally, we end by a conclusion.


The Calculus
In this section we outline our calculus defining first terms, then processes, and finally networks.


Terms
Assume an infinite set of names N ranged over by n, an infinite set of variables X ranged over by x, and two disjoint finite sets, F and G, of constructor and destructor symbols ranged over by f and g respectively. Then the set of terms is defined by the grammar below where f is a constructor symbol with arity k. We let T denote the set of all terms with no variables.

s, t ::= n | x | f (t1,... , tk)

Processes
We assume a set of process variables Z ranged over by z. The set of processes is defined by the grammar
p, q ::= 0 | ⟨t⟩.p | (x).p | if (t = s) then p else q | let x = t in p |
let x = g(t1,... , ti) in p else q | νn.p | z | rec z.p

The processes 0, νn.p, if (t = s) then p else q, let x = t in p, and rec z.p are standard. 4 The process ⟨t⟩.p may broadcast t and in so doing become p, and (x).p binds x in p and may receive a term t and replace all free occurrences of x in p by t. Often we write ⟨t⟩ for ⟨t⟩.p when p is 0. The process let x = g(t1,... , tk) in p else q also binds x in p, if the destructor application g(t1,... , tk) evaluates to a term t then x is bound to t in p, otherwise the process becomes q.
We let p{t/x} denote p where x is substituted by t. Likewise, p{q/z} denotes p where z is substituted by q. The set of free names in p is denoted by fn(p), and its free variables are denoted by fv (p). A process p is closed if fv (p) = ∅. P denotes the set of all closed processes and we identify processes up to α-equivalence.
Networks
Assume a finite set of location names L ranged over by l and k. We assume N ∩L =
∅. We let σ range over sets of location names, and we let ϵ denote the empty set. The set of networks is defined by the grammar


P, Q ::= 0 | [p♩σ
| νn.P  | P \ σ | P	Q

The network 0 denotes the empty network. [p♩σ is a node at location l containing the process p and connected to all nodes in σ. νn.P is the network P with a new name n bound by νn, P \σ denotes a network with locations in σ bound and hidden, and finally P  Q is the parallel composition of the two networks P and Q. We let the new name operator have higher precedence than the hiding operator which in turn has higher precedence than the left associative parallel composition. We write [p♩l instead of [p♩є. When n˜ = {n1,... , ni} we write n˜n for n˜ ∪ {n} and we write νn˜ instead of νn1 ... νni. We write σl instead of σ ∪ {l}, l for {l}, and σσ' for the union of disjoint sets σ and σ'.
The sets of free names, locations, and variables in P , denoted by fn(P ), fl (P ), and fv (P ) respectively, are defined as expected. We let P {t/x} denote P where all free occurrences of x in P are substituted by t. We let Pl⊕k denote network P where k is added to the connections at the (free) location l, taking care that k is not
bound in P (using α-conversion if needed), formally we define: ([p♩σ)l⊕k = [p♩σk,
l	l
([p♩σ )l⊕k = [p♩σ , if l /= m, (νn.P )l⊕k = νn.(Pl⊕k), (P  Q)l⊕k = Pl⊕k  Ql⊕k, and
m	m
(P \ σ)l⊕k = (Pl⊕k)\ σ if l, k /∈ σ. We let Pl⊕σ be the obvious generalization of Pl⊕k.

4 We assume all free occurrences of z in p to be either input or output prefixed.



Table 1
Structural congruence, processes.

We say that a network P is well-formed if each node in P is not connected to itself and if each location in P is unique. In the sequel we consider only the set of well-formed networks and we identify networks up to α-equivalence. The set of well-formed and variable closed networks is denoted by N.

Reduction Semantics
In this section we provide our calculus with a natural reduction semantics; interest- ingly and due to the static location binder, the semantics is quite different compared to the one for CMAN.
As in the seminal work on barbed bisimulation [12], and as in [6], we strive to have as simple as possible reduction semantics and to allow an external global observer to have minimal observability, in our case: reductions l when the node at the free location l broadcasts, and reductions  for connections, disconnections, and broadcast from hidden nodes. In particular an observer cannot identify the broadcasted message and the receivers of the message. Indistinguishability under these observations gives rise to a natural equivalence which in turn induces a natural congruence over networks, i.e. the equivalence in all contexts closed under structural congruence.

Reductions
As usual, a binary relation R on P is a congruence if p R q implies c(p) R c(q) for any variable closing process context c. Structural congruence on P, ≡P, is the least congruence and equivalence relation that is closed under α-conversion and the rules in Table 1. We write C(P ) for the insertion of P in the hole of a network context C whenever C(P ) is well-formed and variable closed. A relation R on N is a congruence if P R P ' implies C(P ) R C(Q) for all C(P ). 5 Structural congruence on N, ≡, is the least congruence and equivalence relation that is closed under α- conversion and the rules in Table 2. The rules are standard except that new names can be extruded from nodes and pass the scope of statically bound location names. To assist in the definition of the reduction rules we introduce a family of ab-

5 Notice that any congruence, Y, has the property that P Y Q implies fl (P ) = fl (Q) due to the well- formedness criteria.



Table 2
Structural congruence, networks.

stractions ranged over by Aσ and defined by:


Aє ::= 0	Al ::= [0♩σ
| [⟨t⟩.p♩σ
| [(x).p♩σ
Aσσ' ::= Aσ  Aσ'

Aσ ::= Aσ  P  | νn.Aσ  | Aσ \ σ' , if σ ∩ σ' = ∅

In Aσ all locations in σ are free and hence may receive messages. Given an abstrac- tion Aσ we define Aσ ◦ t, i.e. a network being the application of a term t on locations σ in Aσ, inductively by the rules in Table 3.

Table 3 Abstraction application.

We define  l,t ⊆ N × N as the least relation closed under ≡ and satisfying the rules in Table 4. Intuitively, P  l,t P ' means that the node at (the free) location l has completed broadcasting t to all nodes to which it is connected. A reduction due to rule (emp) describes that a node may broadcast to the empty set of receivers, whereas rule (brd ) allows auxiliary nodes σ to be connected to a node l and let the nodes in σ synchronously receive t, whenever l has otherwise completed its broadcast of t. As an example, since [⟨n⟩.p♩l  l,n [p♩l we obtain

(7)
[⟨n⟩.p♩m
 [(x).q♩m  l,n [p♩m
 [q{n/x}♩m ,

from (brd ), and from (7) and rule (brd ) we get

(8)
[⟨n⟩.p♩mk
 [(x).q♩m  [(x).r♩k  l,n [p♩mk
 [q{n/x}♩m  [r{n/x}♩k .

Rule (hde 1) in Table 4 allows free locations to broadcast a term.
We define  l ⊆ N × N as the least relation closed under ≡, new name, parallel composition, and satisfying the rules in Table 4. Intuitively, P  l P ' means that the node at location l has completed broadcasting some message as indicated by rule (cls). Rule (hde 2) allows broadcast from free locations. As an example, the reduction (4) in the Introduction is inferred from (8) and rule (cls), and from (4) we may further infer


νn.[⟨n⟩.p♩mk
 [(x).q♩m  [(x).r♩k  l νn.([p♩mk
 [q{n/x}♩m  [r{n/x}♩k) ,


















Table 4 Reduction rules.

which does not belong to the reductions in  l,n.
Finally, we define ⊆ N × N as the least relation closed under ≡, new name, parallel composition, and location hiding, and satisfying the rules in Table 4. P P ' is either the result of a hidden broadcast, i.e. rule (hde 3), or a connection or disconnection as defined by the rules (con ) and (dis) respectively. For instance, the reduction (6) in the Introduction is inferred from (7) and rule (hde 3), and (2) and
(3) are inferred from (con ) and (dis ) respectively.

Reduction Congruence
Next we introduce a natural weak congruence in which reductions  l are our only observables. Let ∗ be the reflexive and transitive closure of . We say that a binary relation R on N is weakly reduction-closed if whenever P R Q then P  l P ' (P  P ') implies the existence of some Q' such that Q  ∗  l ∗ Q' (Q  ∗ Q') and P ' R Q'.
Definition 3.1 A symmetric relation R on N is a weak reduction congruence if it is weakly reduction-closed and a congruence.
Let ∼= be the largest weak reduction congruence. As an example, P ∼= Q if fl (P ) = fl (Q) and if neither P nor Q can ever broadcast since no context can distinguish them apart, in particular 0 ∼= P if fl (P )= ∅.

Bisimulation Semantics
In this section we first provide a labelled transition system; interestingly the net- work semantics turns out much simpler than the one for CMAN. Next, we give the definition of a weak bisimulation, ≈, a sound and complete co-inductive character- ization of ∼=. Also this definition is quite different from the corresponding weak bisimulation for CMAN, but it is still contextual. Therefore, as a novelty compared to [6], we define a non-contextual weak bisimulation that is strictly contained in ≈, and we demonstrate its convenience in our examples.

Labeled Transition System Semantics
We begin with the process semantics and continue with semantics for networks.
Process Semantics











Table 5 Transition Rules, Processes.

Let the set of process actions, AP, where t ∈T , be defined by:
λ ::= (t) | νn˜⟨t⟩
The action (t) describes that t is received by a process and the action νn˜⟨t⟩ denotes the emission of the term t with names in n˜ bound. If n˜ = ∅ we write ⟨t⟩ instead of ν∅⟨t⟩. We let fn(λ) (bn (λ)) denote the free (bound) names in λ.
The processes semantics is defined by (P, AP, →) where →⊆ P× AP × P is the least relation defined by the rules in Table 5 and closed by ≡P. The rules (out ) and (in1) are immediate, and (in2) and (in3) state that processes may lose messages. The rule (new ) is standard and the rule (open ) takes care of extrusion of new names.
Networks Semantics
The set of network actions A ranged over by α is defined by:
α ::= lσνn˜⟨t⟩| σ(t) | β	β ::= l | τ

where t ∈T . The action lσνn˜⟨t⟩ means that the node at location l broadcasts t to nodes in σ where the names in n˜ are bound. σ(t) means that t is received by the nodes in σ. l denotes that the broadcast session for the node at l has completed. As usual τ denotes an internal computation. We let bn(α) (fn(α)) denote the bound (free) names in α, and we let fl (α) denote the free locations in α.
The semantics for networks is defined by (N, A, →) where → ⊆ N ×A × N is the least relation satisfying the rules in Table 6, omitting the symmetric counter parts of rules (syn) and (par ). The rules (new ), (hde 1), and (par ) are as expected. The rule (con ) deals with connectivity, and so does (dis). As an example, consider the network
P = νn.(Q \ m)  [(x).p♩k ,	Q = [⟨n⟩.q♩l  R ,	R = [(x).r♩m  [(x).r'♩m'  .































Table 6 Transition Rules, Networks.

Using rules (con ), (par ), (hde 1), and (new ) we may get
P −τ→ νn.(Ql⊕k \ m)  [(x).p♩k = Pl⊕k

The rule (brd ) states that a node may broadcast to all those nodes to which it is currently connected, (rec1) defines when a single node can receive a message, and (rec3) defines when multiple nodes can receive a message. Not all nodes in a parallel
m'(t)
compostion are required to receive because of (rec2), for instance R −→ [(x).r♩m
[r'{t/x}♩m' . The rule (syn) defines synchronization of broadcasting enforcing no name clash. For instance, assuming n /∈ fn(r) ∪ fn(r'),


lє⟨n⟩
mm'	'

Ql⊕{m,m'} −→ [q♩l	 ([r{n/x}♩m  [r {n/x}♩m' ) ,
so due to (cls), which closes a broadcast session, we get

l	mm'	'
Ql⊕{m,m'} −→ [q♩l	 ([r{n/x}♩m  [r {n/x}♩m' ) .

lm⟨n⟩
Observe that Ql⊕m / −→ because m ∈ fl (R), and notice also that rule (rec2) will



allow locations m and m' to be bypassed in Q −→l
the emitter of the broadcasted message, so e.g.
[q♩l  R. The rule (hde 2) conceals

τ	m,m'	'
Ql⊕{m,m'} \ l −→ ([q♩l	 ([r{n/x}♩m  [r {n/x}♩m' )) \ l .







Table 7
Network context application, Cl,σ.

lk⟨n⟩
Observe that Ql⊕k \ k /−→ because of (hde 2). The rule (opn ) takes care of extrusion
of bound (term) names, hence



Pl⊕k
−→l
νn.(([q♩k
R) \ m  [p{n/x}♩k) .


Correspondence
The correspondence between the transition semantics and structural equivalence is demonstrated by the lemma below.
Lemma 4.1 If P −α→ P ' and P ≡ Q then there exists Q' such that Q −α→ Q' and
P ' ≡ Q'.
and the correspondence between the transition and the reduction semantics is demonstrated by Lemma 4.2 and 4.3.

Lemma 4.2 P −→l  ≡ P ' iff P   P '.
l
Lemma 4.3 P −τ→≡ P ' iff P  P '.
Weak Contextual Bisimulation
Based on the network semantics given in the preceding section below we define our weak contextual bisimulation. First we introduce a subset of network contexts

ranged over by Cσ'
and defined by the grammar



є l,є
::= (−)


σ''	σ''
Cl,σσ' ::= Cl,σ ((−)  Aσ' ) , if l /∈ fl (Aσ' )
Cσ'σ''	σ'	''	''
l,σ	::= Cl,σ((−) \ σ ) ,  if σl ∩ σ  = ϵ

'	σ'	σ'
Notice that σ binds free locations of P in Cl,σ (P ). We write Cl,σ instead of Cl,σ
if σ' is not important. Given Cl,σ we write Cl,σ ◦ t for the network context being
the application of t on all locations σ in Cl,σ as defined in Table 7. We write Cl,σ ◦ (n˜, t, P ) for νn˜.((Cl,σ ◦ t)(P )) assuming that n˜ does not overlap with the free names in Cl,σ.
Intuitively, for all Cl,σ(P ), if l ∈ fl (P ) then the node at location l in P may broadcast messages to all nodes in Cl,σ with locations in σ as demonstrated by the Lemma below:

Lemma 4.4 For all C
(P ), if P lσνn˜⟨t⟩ P ' then C


(P ) −→l	C
(n˜, t, P ').

l,σ	−→
l,σ
l,σ



Table 8
Network context application, ⟨t⟩Dl,σ.

Also we define a set of network contexts ranged over by ⟨t⟩Dl,σ and defined by the grammar:

⟨t⟩D	::= (−)	Cσ'' ([⟨t⟩.p♩σσ' ) , if σ ∩ (σ'' ∪ fl (Cσ'' )) = ϵ

l,σ
l,σ'	l
l,σ'

⟨t⟩Dl,σ ::= ⟨t⟩Dl,σσ' ((−)  Aσ' )
⟨t⟩Dl,σ ::= ⟨t⟩Dl,σ((−) \ σ') , if σl ∩ σ' = ϵ

Moreover, for a context ⟨t⟩Dl,σ we write Dl,σ ◦ t for the context defined by the rules in Table 8. To clarify, for any ⟨t⟩Dl,σ(P ) if σ ⊆ fl (P ) then all nodes at locations σ in P may receive t broadcasted by the node at location l in ⟨t⟩Dl,σ as illustrated by:

σ(t)
Lemma 4.5 For all ⟨t⟩D	(P ), if P	P ' then ⟨t⟩D


(P ) −→l	(D
t)(P ').

l,σ	−→
l,σ
l,σ


4.2.1	Weak Contextual Bisimulation
Making use of the two types of contexts outlined above we next define weak contex- tual bisimulation. As usual we let =τ⇒ be the reflexive and transitive closure of −τ→


and we define =⇒l
by =τ⇒−→l
=τ⇒.

Definition 4.6 A symmetric relation R on N is a weak contextual bisimulation if
P R Q implies
if P −τ→ P ' then ∃Q'. Q =τ⇒ Q' and P ' R Q'

	

lσνn˜⟨t⟩
if P
'	l	'	'	'

−→ P
then ∀Cl,σ(Q). ∃Q . Cl,σ(Q) =⇒ Q and Cl,σ ◦ (n˜, t, P ) R Q

σ(t)
if P


'	l	'	'	'

−→ P
then ∀⟨t⟩Dl,σ(Q). ∃Q .⟨t⟩Dl,σ(Q) =⇒ Q and (Dl,σ ◦ t)(P ) R Q


We let ≈ denote the largest weak contextual bisimulaiton.
Theorem 4.7 ≈ is an equivalence relation and a congruence.
Example 4.8 It is obvious that [⟨t⟩.⟨s⟩♩l /≈ [⟨s⟩.⟨t⟩♩l if t /= s. However, similar to what is shown in [7] the order of infinite broadcast sequences may be interchanged,

i.e. whenever C binds l then
C([rec z.⟨t⟩.⟨s⟩.z♩l ) ≈ C([rec z.⟨s⟩.⟨t⟩.z♩l )
Intuitively, the reason why (9) holds is that receivers may disconnect from l before a term is broadcasted and connect again in order to receive next.
The first clause in Definition 4.6 is standard. The second clause says that when- ever node l in P is able to broadcast to nodes σ in the environment, then when Q is placed in any such environment l in Q must complete a broadcast, but we do not know the receiving nodes. Dually, the third clause states that whenever nodes σ in P synchronously may receive a broadcasted message from the environment then when Q is placed in any such environment the emitting node must complete a broadcast, but again we may not know the actual receiving nodes. The giving up of knowing the broadcast receivers in the matching part of the two latter clauses in Definition 4.6 is related to the fact that in the observables of our reduction seman- tics we only know the broadcasting node, but we have no means of telling which nodes actually received the broadcasted message.
A major and non-trivial result of this paper is that weak bisimulation is a sound and complete characterization of reduction congruence.
Theorem 4.9 ≈ = ∼=.
Weak Non-Contextual Bisimulation
Because weak contextual bisimulation uses quantification over all contexts it may be hard to show equivalence between two networks, hence we provide a standard non- contextual weak bisimulation letting γ be a network action defined by the grammar:
γ ::= lσνn˜⟨t⟩ | σ(t) | τ


Definition 4.10 A symmetric relation R on N is a weak bisimulation if P R Q
implies
γ	'	'	γ	'	'	'
if P −→ P then ∃Q . Q =⇒ Q and P R Q


The largest weak bisimulation, ≈˙ and
, is an equivalence relation and a congruence,

Theorem 4.11 ≈˙  ⊂ ≈.
Notice that in contrast to weak contextual bisimulation in a weak bisimulation a matching network must output exactly the same term and also let exactly the same nodes synchronously receive a term. For instance, if f and g are two unary constructors with no destructors then [νn.νm.⟨n⟩.⟨m⟩♩l and [νn.⟨g(n)⟩.⟨f (n)⟩♩l are weak contextual bisimilar because for both two unrelated values are broadcasted that are different from any value any context can build, but clearly the two nodes are not weak bisimilar.

Weak bisimulation abstracts from connectivity in that Pl⊕k≈˙
P  because

Pl⊕k
=τ⇒ P and P
=τ⇒ Pl⊕k. This property is a characteristic of MANETs in

that connection to any reachable node may be obtained and also it turns out useful in many proofs. The adequacy of weak bisimulation is further illustrated by Ex- ample 4.12 below which would have been quite hard to show in case of just weak
contextual bisimulation. The example illustrates the use of the new feature with restricted mobility and could not have been modelled by the calculus in [6].

Table 9
A simple cryptographic message passing protocol.


Example 4.12 Suppose a node, [p♩l0 , that repetitively sends a message, msg , to a node, [q♩l1 . The message msg is re-broadcasted by p only when the reception of the previous msg has been acknowledged. A simple example with only one intermediary node, [r♩l2 , that can communicate with both l0 and l1, and where l0 and l1 are outside reach of each other, so they must communicate via l2, may be defined by:
P = ν key.([p♩l0  ([r♩l2  [q♩l1 ) \ l1) \ l2
where key is a secret symmetric key shared between p and q. Notice that only q can return the encrypted acknowledge expected by p. Further, let pair (x, y) be a constructor for pairs and let snd be the destructor returning the second element of a pair. Also, let enc(x, y) be a constructor denoting the symmetric encryption of a message x by the key y and let dec be the corresponding decryption destructor defined by: dec(enc(x, y), y)= x. We define p, q, and r in Table 9 using equations instead of recursion. Despite the risk of having a copy of msg forward broadcasted by each of two intermediary nodes one may show that one or two intermediary nodes
will not make any observational difference, i.e. P ≈˙ Q where
Q = ν key.([p♩l0  ([r♩l2  [r♩l3  [q♩l1 ) \ l1) \ {l2, l3}

Conclusion
The main contribution of this paper is the refinement of CMAN [6] to allow for restricted node mobility through the novel introduction of a static location binder, and also we imposed the more realistic use of unidirectional instead of bidirectional links. Importantly the refinement gives rise to a much simpler labelled transition system and bisimulation semantics than in [6]. Moreover, we have developed a nat- ural reduction semantics and congruence, ∼=, for which the largest weak contextual bisimulation, ≈, is a co-inductive sound and complete characterization. Most signifi- cantly and in contrast to [6] we manage to define a non-contextual weak bisimulation

where the largest bisimulation, ≈˙ , is strictly contained in ≈ and which turned out
adequate in the proofs of our examples.
Several further developments of our calculus are immediate: For instance the process language could easily be extended with concurrency, and one may consider extending the language with active substitutions as in [1] in order to have a less contextual characterization of ∼=. Moreover, instead of just restricting mobility of nodes we could enforce explicit mobility models as described in [2]. Also, we plan to investigate other equivalences, in particular we want to consider equivalences where the observer is mobile and has only a limited and not a global view of the whole network, and we want to investigate equivalences suitable to help reason about MANETs, and in particular routing and secure routing.

References
Martin Abadi and Cedric Fournet. Mobile vales, new names, and secure communication. In Hanne Riis Nielson, editor, 28th ACM Symposium on Principles of Programming Languages, pages 104–115, London, UK, January 2001. ACM.
T. Camp, J. Boleng, and V. Davies. A survey of mobility models for ad hoc network research. Wireless Comm. & Mobile Comp.: Special issue on Mobile Ad Hoc Networking: Research, Trends and Applications, 2(5):483–502, 2002.
L. Cardelli and A.D. Gordon. Mobile ambients. In Foundations of Software Science and Computation Structures: First International Conference, FOSSACS ’98. Springer-Verlag, Berlin Germany, 1998.
C. Ene and T. Muntean. A broadcast-based calculus for communicating systems. In 6th International Workshop on formal Methods for Parallel Programming: Theory and Applications, San Francisco, 2001.
Cristian Ene and Traian Muntean. Expressiveness of point-to-point versus broadcast communications. In Fundamentals of Comp. Theory, pages 258–268, 1999.
J.C. Godskesen. A calculus for mobile ad hoc networks. In Proceedings of the 9th International Conference, COORDINATION 2007, volume 4467 of LNCS, pages 132–150, Paphos, Cyprus, June 2007. Springer–Verlag.
M. Merro. An observational theory for mobile ad hoc networks. Electron. Notes Theor. Comput. Sci., 173:275–293, 2007.
N. Mezzetti and D. Sangiorgi. Towards a calculus for wireless systems. Electr. Notes Theor. Comput. Sci., 158:331–353, 2006.
R. Milner. Communication and Concurrency. Series in Computer Science. Prentice–Hall International, 1989.
R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, part I/II. Journal of Information and Computation, 100:1–77, September 1992.
Robin Milner. Communicating and Mobile Systems: the π-Calculus. Cambridge University Press, May 1999.
Robin Milner and Davide Sangiorgi. Barbed bisimulation. In Proceedings ICALP ’92, volume 623, pages 685–695, Vienna, 1992. Springer-Verlag.
Sebastian Nanz and Chris Hankin. A framework for security analysis of mobile wireless networks.
Theoretical Computer Science, 367(1):203–227, 2006.
K. Ostrovsky, K. V. S. Prasad, and W. Taha. Towards a primitive higher order calculus of broadcasting systems. In PPDP ’02: Proceedings of the 4th ACM SIGPLAN international conference on Principles and practice of declarative programming, pages 2–13, New York, NY, USA, 2002. ACM Press.
K. V. S. Prasad. A calculus of broadcasting systems. Sci. Comput. Program., 25(2-3):285–327, 1995.
K. V. S. Prasad. A prospectus for mobile broadcasting systems. Electr. Notes Theor. Comput. Sci., 162:295–300, 2006.
A. Singh, C.R. Ramakrishnan, and S.A. Smolka. A process calculus for mobile ad hoc networks. www.lmc.cs.sunysb.edu/˜cram/Papers/SRS OmegaCalc2006/.

Appendix
This appendix contains the proofs of the Theorems and Lemmas of our theory.
Proof of Lemma 4.1
Proof. Suppose P ≡ Q. We must show the property

(10)
P  α	'
'	α	'	'	'

It’s obvious that (10) is preserved by α-conversion 6 and also by reflexivity, symmetry, and transitivity (recall ≡ is closed by α-conversion and it is an equivalence relation). One may show by induction in the

α
depth of the inference of P −→
P ' that (10) is closed by (well-formed) parallel composition, by new name

generation, and by restriction of location names (recall ≡ is defined to be a congruence). Finally, we show

is closed by the rules in Table 2 also by induction in the depth of the inference of P α
P '.	 

From Lemma 4.1 it is immediate that:
Corollary 6.1 ≡ is a weak bisimulation.
Proof of Lemma 4.2 and 4.3
Below is a series of lemmas that show how the reduction and the labeled transition system semantics relate. Lemma 4.2 follows from Lemma 6.13 and 6.14, and Lemma 4.3 follows due to Lemma 6.11 and 6.12.

(t)
Lemma 6.2 p −→≡P

p' iff for some n˜ where n˜ ∩ fn(t)= ∅ either

p ≡P p' ≡P νn˜.0 ,
p ≡P p' ≡P νn˜.⟨t'⟩.q for some t' and q , or
p ≡P νn˜.(x).q and p' ≡P q{t/x}


Proof. The ’only if’ direction follows by induction in the derivation of p (t) p', and the ’if’ direction follows

because λ	P
(t)
'	(t)	'
(t)

−→ is closed by ≡ and because νn˜.0 −→ νn˜.0, νn˜.⟨t ⟩.q −→ νn˜.⟨t ⟩.q, and νn˜.(x).q −→ q{t/x}
when n˜ ∩ fn(t)= ∅.	 


νn˜(t⟩
Lemma 6.3 p −→ ≡P

p' iff p ≡P

νn˜n˜'.⟨t⟩.q and p' ≡P

νn˜'.q for some q and n˜' with n˜ ⊆ fn(t) and

n˜' ∩ fn(t)= ∅.
Proof. The ’only if’ direction follows by induction in the derivation of p νn˜(t⟩ p', and the ’if’ direction

follows because νn˜n˜'.⟨t⟩.q νn˜(t⟩ νn˜'.⟨t⟩.q and since λ
is closed by ≡P.	 

−→	−→
Lemma 6.4 P ≡ Q implies Pl⊕σ ≡ Ql⊕σ.
Proof. Immediate from the rules in Table 2 and the fact that ≡ is an equivalence relation, a congruence, and closed under α-conversion.	 

σ(t)
Lemma 6.5 P −→≡

P ' iff P ≡ Aσ

for some Aσ

and P ' ≡ Aσ

t.

Proof. (’only if’) The proof is by induction in the inference of P σ(t) P '. (’if’) By induction on the structure
σ(t)
of Aσ we show Aσ −→ Aσ ◦ t, then the rest follows due to Lemma 4.1.


Lemma 6.6 P


lσνn˜(t⟩
−→ P and σ ∩ fl (P )= ∅ implies P


l⊕σ


'
lσσ νn˜(t⟩
−→	P

l⊕σ' .



Proof. By induction in the inference of P lσνn˜(t⟩ P '.	 
Let Pl σ be P where all connections at l in σ are removed.



'
lσσ νn˜(t⟩
Lemma 6.7 P

lσνn˜(t⟩ '

−→	P
implies Pl σ'
−→ P l σ' .



6 We identify processes up to α-conversion.



'
Proof. By induction in the inference of P lσσ νn˜(t⟩ P '.	 



Lemma 6.8 P lc(t⟩ P ' implies P 


l,t

P ' if P contains no bound names.


	
Proof. Suppose P lc(t⟩ P ', the proof is by induction in the inference of P lc(t⟩ P '.



Case Assume [p
lc(t⟩
p'♩σ because p (t⟩ p'. Then, since p contains no bound names, due to Lemma 6.3,

♩l −→ [	l	−→
p ≡P ⟨t⟩.q	and p' ≡P q for some q. Also, [p♩σ ≡ [⟨t⟩.q♩l. Next, from reduction rule (emp) it follows
that [⟨t⟩.q♩l  l,t [q♩l. Hence, [p♩l  l,t [p'♩σ.

Case The cases where P lc(t⟩ P ' is due to rule (hde ) follows by induction.
−→	1

	

Case Suppose P	Q lc(t⟩ P '	Q' because P lσ(t⟩ P ' and Q σ(t) Q'. Due to Lemma 6.5, Q ≡ A
and

	−→		−→	−→	σ

Q' ≡ Aσ
t for some Aσ . Also, by Lemma 6.7, we obtain P


lc(t⟩
l σ −→ P

l σ
and hence by induction

Pl σ  l,t P 'l σ. Finally, by (brd ) and because  l,t is closed by ≡, we get P  Q  l,t P '  Q'.




Lemma 6.9 P 
l,t
P ' implies P lc(t⟩ Q for some Q such that Q ≡ P '.

Proof. The proof is by induction in the inference of P  l,t P '. The case where P  l,t P ' is due to the rule (empty ) is trivial. If P  l,t P ' is due to rule (new ) or rule (res 1) the result follows by induction. Suppose, due to rule (brd ), that
Pl⊕σ  Aσ  l,t P 'l⊕σ  Aσ ◦ t


because P 


l,t
P '. By induction, P lc(t⟩ σ(t)

P ', and therefore due to Lemma 6.6 and 6.4, P


lσ(t⟩ l⊕σ −→ ≡

P 'l⊕σ .

Now, because Aσ −→ Aσ ◦ t, due to Lemma 6.5, we obtain



Pl⊕σ
lc(t⟩
Aσ −→≡
P 'l⊕σ
 Aσ ◦ t


Finally, if P  l,t P ' is due to closing by structural congruence the result follows by induction and Lemma 4.1.	 



lσνn˜(t⟩
Lemma 6.10 P  −→  P


lσ(t⟩
implies P ≡ νn˜.Q for some Q such that Q −→ Q

and Q' ≡ P '

and n˜ ⊆ fn (t).



Proof. By induction in the inference of P lσνn˜(t⟩ P ' using Lemma 6.3.	 



l
Lemma 6.11 P −→
P ' implies P l
P '.


	

Proof. Suppose P l
P '. The proof is by induction in the derivation of P  l
P '.



The case where P  l
P ' is due to the rule (par ) 7 , (new ), or (hde 1) follows by induction. Suppose



P  l	'
lcνn˜(t⟩  '

lc(t⟩  '

−→ νn˜.P
because P
−→ P . Then by Lemma 6.10 P ≡ n˜.Q for some Q such that Q −→ Q
for

some Q' with P ' ≡ Q'. Next, let Q ≡ νm˜ .R for some m˜ and R where R contains no bound names. Then
lc(t⟩
R
−→ R for some R such that Q ≡ νm˜ .R . Hence, due to Lemma 6.8, R  l,t R so also R  l R ,
therefore Q  l Q' and also P  l νn˜.P '.	 


Lemma 6.12 P  l


P ' implies P  l

Q for some Q such that Q ≡ P '.

Proof. Suppose P  l P '. The proof is by induction in the inference of P  l P '.
The case where the reduction is due to closing by parallel composition or by new name generation follows by induction. If the reduction is due to closing by structural congruence the result holds by induction and because of Lemma 4.1. If P \ σ l P ' \ σ because P l P ' and l /∈ σ the result follows by induction. Finally, if P  l P ' because P  l,t P ' the lemma holds due to Lemma 6.9.	 

7 or its symmetric counterpart

Lemma 6.13 P  τ
τ
Proof. Suppose P

P ' implies P  P '.
P '. The proof is by induction in the derivation of the transition P  τ



P '.

−→
The case where P τ
−→
P ' is inferred by one of the rules (con ) and (dis ) is immediate. If P τ

P ' is

due to rule (hde ) the result follows due to Lemma 6.11 and the reduction rule (hde ). Finally, if P  τ  P '
follows by one of the rules (par ) (or its symmetric counterpart), (new ) or (hde 1) the lemma holds because
  is closed by parallel composition, new names, and hiding of location names.	 

Lemma 6.14 P  P ' implies P  τ
Q for some Q such that Q ≡ P '.

Proof. Suppose P  P '. The proof is by induction in the inference of P  P '.
The case where P  P ' is due to rule (con ) or (dis ) is immediate. If P  P ' is because of the rule (hde 3) the result follows due to Lemma 6.12 and the lts-rule (hde 2). The closing by parallel composition, new names, and hiding of location names follows by induction and the lts-rules (par ) and its symmetric counterpart, (new ), and (hde 1) respectively. Finally, the closing by ≡ follows by Lemma 4.1.	 

Proof of Lemma 4.4 and 4.5
The proof of Lemma 4.4 is by induction on the structure of Cl,σ, and the proof of Lemma 4.5 follows by structural induction on ⟨t⟩Dl,σ with the help of Lemma 4.4.

Bisimulation up to
Definition 6.15 Let Y be binary relations on N. Then Y is a weak simulation up to ≡ if P Y Q implies

if P  τ	'
'	τ	'	'	'


lσνn˜(t⟩
if P


'	l	'	'	'

−→ P then ∀Cl,σ(Q). ∃Q . Cl,σ(Q) =⇒ Q and Cl,σ ◦ (n˜, t, P ) ≡Y≡ Q

σ(t)
if P


'	l	'	'	'

−→ P
then ∀⟨t⟩Dl,σ (Q). ∃Q .⟨t⟩Dl,σ(Q) =⇒ Q  and (Dl,σ ◦ t)(P ) ≡Y≡ Q


Y is a weak bisimulation up to ≡ if both Y and Y−1 are weak simulations up to up to ≡.
Lemma 6.16 If Y is a weak bisimulation up to ≡ then ≡Y≡ is a weak bisimulation.
Proof. Suppose Y is a weak bisimulation up to ≡. We only show that ≡Y≡ is a weak simulation 8 , the proof of (≡Y≡)−1 being a weak simulation is similar.

Let P ≡ P1 Y Q1 ≡ Q. Suppose P  α
P '. We only consider the case where α = lσνn˜⟨t⟩, the other

cases are immediate or similar.

lσνn˜(t⟩
If P  −→ P
then, due to Lemma 4.1, there exists P1'
such that P1
lσνn˜(t⟩
−→ P1
and P '
≡ P1'. Then,

since P1 Y Q1, for all C


there exists Q1' such that C	1	l  Q1' and .C
(νn˜, t, P1') ≡Y≡ Q1'.

l,σ
l,σ(Q ) =⇒
l,σ

Because ≡ is a congruence we have Cl,σ ◦ (νn˜, t, P ') ≡ Cl,σ ◦ (νn˜, t, P1') and Cl,σ(Q) ≡ Cl,σ(Q1). From

Lemma 4.1 we infer that there exists Q' such that C
τ  Q' and Q1' ≡ Q'. Hence, since ≡ is

l,σ(Q) =⇒
transitive, Cl,σ ◦ (νn˜, t, P ') ≡Y≡ Q'.	 

Proof of Theorem 4.7
That ≈ is a congruence follows from the lemmas below.

σ	σ	' ''
Lemma 6.17 For any C 0 (P  C 1 ' ([⟨t⟩.p♩σσ σ )) there exists ⟨t⟩lDσ'' such that
l,σ	l,σ	l


σ	σ	' ''

C 0 (P C 1 ' ([⟨t⟩.p♩σσ σ
)) = ⟨t⟩lDσ'' (P )

l,σ	l,σ	l


and

' ''
(C 0 ◦ t)(P  (C 1 ' ◦ t)([p♩σσ σ

)) = (Dσ'' ◦ t)(P )


if σσ'' ∩ (σ1 ∪ fl (Cσ1 ' )= ∅.
l,σ
l,σ	l


Proof. The proof is by induction on the structure of Cσ0 .	 

8 We here assume a definition of weak bisimulation, similar to the one for weak bisimulation up to ≡, such that Y is a weak bisimulation if both Y and Y−1 is a weak simulation.



Lemma 6.18 P lσ(t⟩ P ' implies P ≡ νn˜.Cσ'' ([⟨t⟩.p♩σσ' ) for some p, n˜, and Cσ''

with σ ∩ (σ'' ∪ fl (P )) =

−→	l,σ'	l
''	'
l,σ'

∅, n˜ ∩ fn (t)= ∅, and P ' ≡ νn˜.(Cσ ' ◦ t)([p♩σσ ).
l,σ	l

Proof. By induction in the inference of P lσ(t⟩ P '.	 


σ''


'  lσ(t⟩	''	'	''

Lemma 6.19 C  ' ([⟨t⟩.p♩σσ ) −→ (Cσ ' ◦ t)([p♩σσ ) if σ ∩ (σ'' ∪ fl (Cσ ' )) = ∅.

l,σ	l
l,σ	l
l,σ

Proof. By induction on the structure of Cσ'' .	 



lσνn˜(t⟩
Lemma 6.20 P  −→ ≡
P ' iff

''	'

P ≡ νn˜n˜'.Cσ ' ([⟨t⟩.p♩σσ )

and
l,σ	l

''	'

P ' ≡ νn˜'.(Cσ ' ◦ t)([p♩σσ )
l,σ	l
''
for some p, n˜', and Cσ ' with σ ∩ (σ'' ∪ fl (P )) = ∅, n˜ ⊆ fn (t), n˜' ∩ fn(t)= ∅.
Proof. The ’only if’ direction follows from Lemma 6.10 and 6.18, and the ’if’ direction follows due to Lemma 4.1 and 6.19.	 
Lemma 6.21 P ≈ Q implies C(P ) ≈ C(Q)
Proof. Let Y = {(C(P ),C(Q)) | P ≈ Q}. It is sufficient, due to Lemma 6.16, to prove that Y is a weak
bisimulation up to ≡. We only show Y is a weak simulation up to ≡. The proof of Y−1 being a weak simulation up to ≡ is similar. Let C(P ) Y C(Q), the proof is by induction on the structure of C.

Case 1 (C = (−)) : Immediate.
Case 2 (C = C' R) : The proof is by induction in the derivation of C'(P ) R α



P '  R'.

Case 2.1 (α = τ ): Assume (11)

C'(P )  R  τ


P '  R'

The case where C'(P ) τ
P ' and R = R' follows by induction.

The case where R τ
R' and C'(P )= P ' is trivial.

Case 2.2 (α = lσνn˜⟨t⟩): Assume
(12)


C'(P ) R lσνn˜(t⟩ P '  R'



'	'
Suppose (12) is due to C'(P ) lσσ νn˜(t⟩ P ' and R σ (t) R' where n˜ ∩ fn(R)= ∅ and σ ∩ fl (R)= ∅. Due
to Lemma 6.5, R ≡ Aσ' and R' ≡ Aσ' ◦ t for some Aσ' . For all Cl,σ(C'(Q)  Aσ' ) there exists Cl,σσ'
such that

Cl,σσ' (C'(Q)) = Cl,σ(C'(Q)  Aσ' )
Then, by induction C'(P ) Y C'(Q) and there exists Q' such that C	'	'


l Q' and C	' ◦

l,σσ (C (Q)) =⇒
l,σσ

(n˜, t, P ') ≡Y≡ Q'. Because ≡ is a congruence we obtain Cl,σ
(C'(Q)


l
R) =⇒
Q'' for some Q'' where

Q'' ≡ Q' from Lemma 4.1. Finally, since
(Cl,σσ' ◦ t)(P ')= (Cl,σ ◦ t)(P '  Aσ' ◦ t)
we have Cl,σ ◦ (n˜, t, P '  R') ≡ Y ≡ Q''.
'	'
Suppose (12) is due to C'(P ) σ (t) P ' and R lσσ νn˜(t⟩ R' where n˜ ∩ fn(C'(P )) = ∅ and σ ∩ fl (C'(P )) =

−→
∅. From Lemma 6.20 we infer,

and
−→

R ≡ νn˜n˜'.Cσ0 ''



' ''
([⟨t⟩.p♩σσ σ )

' ''

R' ≡ νn˜'.(Cσ0 '' ◦ t)([p♩σσ σ )
l,σ	l
for some p, n˜', and Cσ0 '' with σσ' ∩ fl (Cσ0 '' ) = ∅, σσ' ∩ σ0 = ∅, and n˜' ∩ fn(t) = ∅. For any
l,σ	l,σ
Cσ1 (C'(Q) R), assuming (using α-conversion if needed) n˜n˜' ∩ fn (Cσ1 (C'(Q))) = ∅, we have

l,σ

Cσ1 (C'(Q) R) ≡ νn˜n˜'.Cσ1 (C'(Q) Cσ0
l,σ

' ''
([⟨t⟩.p♩σσ σ ))

l,σ
l,σ
l,σ''	l



From Lemma 6.17 we infer
Cσ1 (C'(Q)  Cσ0


' ''
([⟨t⟩.p♩σσ σ )) = ⟨t⟩D

(C'(Q))

l,σ
l,σ''	l
l,σ'

for some ⟨t⟩Dl,σ' . By induction there exists Q' such that

⟨t⟩D  '	'


l  Q'

l,σ (C (Q)) =⇒
and (Dl,σ' ◦ t)(P ') ≡Y≡ Q'. Hence, because
νn˜n˜'.⟨t⟩Dl,σ' (C'(Q)) ≡ Cσ1 (C'(Q)  R)

we obtain, due to Lemma 4.1, Cσ1 (C'(Q)


R) =l

Q'' for some Q'' with Q'' ≡ νn˜n˜'.Q'. From

Lemma 6.17 we have

(Cσ1 ◦ t)(P ' (Cσ0

' ''
t)([p♩σσ σ )) = (D

t)(P ')

l,σ
l,σ''	l	σ'

and finally we obtain Cσ1 ◦ (n˜, t, P '  R') ≡ Y ≡ Q''.
Case 2.3 (α = σ(t)): Suppose

C'(P )  R σ(t) P '  R'
is due to C'(P ) σ1 (t) P ', R σ2 (t) R', where σ = σ σ . From Lemma 6.5 it follows that R ≡ A


and

−→	−→	1 2	σ2
R' ≡ Aσ2 ◦ t for some Aσ2 . For any ⟨t⟩Dl,σ (C'(Q)  Aσ2 ) there exists ⟨t⟩Dl,σ1 such that
⟨t⟩Dl,σ (C'(Q)  Aσ2 )= ⟨t⟩Dl,σ1 (C'(Q))

By induction there exists Q' such that ⟨t⟩D	'


l  Q' and



But then since
l,σ1 (C (Q)) =⇒
(Dσ1 ◦ t)(P ') ≡Y≡ Q'

⟨t⟩Dl,σ1 (C'(Q)) ≡ ⟨t⟩Dl,σ (C'(Q)  R)

we obtain ⟨t⟩D

l,σ
(C'(Q)


l
R) =⇒
Q'' for some Q'' with Q'' ≡ Q' due to Lemma 4.1 and because

(Dl,σ ◦ t)(P '  R') ≡ (Dl,σ1 ◦ t)(P ')
finally we get (Dl,σ ◦ t)(P '  R') ≡ Y ≡ Q''. Case 3 (C = C' \ σ) : Similar to the case above Case 4 (C = νn.C') : Follows easily by induction.
 
Lemma 6.22 (Process Normal Form) For any process p ∈ P, p ≡P νn˜.q where q = 0, q = (x).q', or
q = ⟨t⟩.q' for some n˜, q', x, and t.
Proof. The proof is by induction on the structure of p.	 Lemma 6.23 (Network Normal Form) For all P and for all σ ⊆ fl (P ) there exists Aσ such that P ≡ Aσ. Proof. The proof is by induction on the structure of P with help of Lemma 6.22	 Lemma 6.24 P ≈ Q implies fl (P )= fl (Q).
Proof. Assume fl (P ) /= fl (Q). Without loss of generality, l ∈ fl (P ) \ fl (Q) for some l. Due to Lemma 6.23
and 6.5, P σ(t) P ' for some σ and P ' with l /∈ σ. Suppose, in order to obtain a contradiction, that P ≈ Q. Observe that there exists some ⟨t⟩Dl,σ such that ⟨t⟩Dl,σ(Q) is well-defined. Then since for all ⟨t⟩Dl,σ (Q)

there must exists some Q' such that ⟨t⟩D


l
l,σ	⇒
Q' and (D

l,σ
t)(P ') ≈ Q' we obtain a contradiction

because no (Dl,σ ◦ t)(P ') is well-defined as l ∈ fl (P '). Consequently it must be that P /≈ Q.	 
Theorem 6.25 ≈ is a congruence.
Proof. Suppose P ≈ Q and C(P ) is well-defined for some context C. Then, because of Lemma 6.24, we know fl (P )= fl (Q) and hence also C(Q) is well-defined. Then remaining part of the proof follows due to Lemma 6.21.	 
Theorem 6.26 ≈ is an equivalence relation
Proof. Reflexivity holds due to Lemma 4.4 and 4.5, symmetry follows by definition of ≈, and transitivity holds due to Theorem 6.25.	 

Proof of Theorem 4.9
In order to show ≈ ⊆ ∼= it is sufficient to show that ≈ is weak reduction closed because from Theorem 1 we know ≈ is a congruence. That ≈ is weak reduction closed follows from Lemma 6.11, 6.12, 6.13, and 6.14 and Corollary 6.1.
The remaining part of the proof establishes that ∼= ⊆ ≈. It’s sufficient to show that ∼= is a weak bisimulation. Let P1 ∼= P2.


Case 1 (α = τ ): The case where P	τ
P1' is immediate due to Lemma 6.13 and 6.14.




Case 2 (α = lσνn˜⟨t⟩): Suppose P
lσνn˜(t⟩ P '. Due to Lemma 4.4,

1 −→	1



Cl,σ
(P1) l
Cl,σ
(n˜, t, P1')


for all Cl,σ(P1). Hence, because of Lemma 6.11,

Cl,σ(P1)  l Cl,σ ◦ (n˜, t, P1')

Now, because ∼= is a congruence and weak reduction closed there exists P2' such that
Cl,σ (P2 )  ∗  l  ∗ P2'



and C	◦ (n˜, t, P1') ∼= P2'. Then due to Lemma 4.1, 6.12, and 6.14 it follows that C
2	l	P2'.

l,σ
The remaining part of the proof follows since ≡ ⊆ ∼=.
l,σ(P ) =⇒≡



Case 3 (α = σ(t)): Suppose P
σ(t) P '. Due to Lemma 4.5,

1 −→ 1



⟨t⟩D
l,σ
l
(P1) −→
(Dl,σ
t)(P1')

for all ⟨t⟩Dl,σ (P1). Hence, because of Lemma 6.11,

⟨t⟩Dl,σ(P1)  l (Dl,σ ◦ t)(P1')

Now, because ∼= is a congruence and weak reduction closed there exists P2' such that
⟨t⟩Dl,σ (P2)  ∗  l  ∗ P2'



and (D	◦ t)(P1') ∼= P2'. Then due to Lemma 4.1, 6.12, and 6.14 it follows that ⟨t⟩D
2	l	P2'.

l,σ
The remaining part of the proof follows since ≡ ⊆ ∼=.
l,σ (P ) =⇒≡

Proofs for ≈˙ being an equivalence relation and a congruence
Theorem 6.27 ≈˙ is an equivalence relation.
Proof. Standard.	 
Lemma 6.28 P ≈˙ Q implies C(P ) ≈˙ C(Q)
Proof. Let Y = {(C(P ), C(Q)) | P ≈˙ Q}. It is sufficient to prove that Y is a weak bisimulation. To show

that Y is a weak simulation, let C(P ) Y C(Q) and suppose C(P ) α
P '. The proof is a straightforward

α
outer induction on the structure of C and a inner induction in the derivation of C(P ) −→
P '. The proof of

Y−1 being a weak simulation is similar.	 
Theorem 6.29 ≈˙ is a congruence.
Proof. Due to the clause about input in the definition of weak bisimulation it is immediate that P ≈˙ Q
implies fl (P )= fl (Q). Hence whenever P ≈˙ Q and C(P ) is well-defined then also C(Q) is well-defined. The remaining part of the proof then follows from Lemma 6.28.	 

Proof of Theorem 4.11

In order to show ≈˙
⊆ ≈ it is sufficient to prove that ≈˙
is a weak bisimulation. We show ≈˙
to be a weak

simulation. The proof of (≈˙ )−1 being a weak simulation is similar.
Suppose P ≈˙ Q.

Suppose P lσn˜(t⟩ P ' for some l, σ, n˜, t, and P '. In that case we must show that for all C
(Q) there

−→
exists Q' such that C


l  Q' and C

(n˜, t, P ')≈˙
l,σ
Q'. The proof follows due to Lemma 4.4 and

l,σ(Q) =⇒
l,σ

because P ≈˙
Q implies Q


lσn˜(t⟩
=⇒ Q  for some Q  such that P ≈
Q''.

Suppose P σ(t) P ' for some σ and t. In that case we must show that for all ⟨t⟩D

l,σ
(Q) there exists Q'

such that ⟨t⟩D


l l,σ (Q) =⇒
Q' and (D

l,σ
t)(P ') ≈˙
Q'. The proof follows due to Lemma 4.5 and because

P ≈˙
σ(t)
Q implies Q =⇒ Q for some Q such that P ≈
Q''.

τ
The case where P −→
In order to show ≈˙
P ' is trivial.
⊂ ≈ let f and g be two unary constructors with no destructors and let P =

νn.νm.[⟨n⟩.⟨m⟩♩l and Q = νn.[⟨g(n)⟩.⟨f (n)⟩♩l then P ≈ Q because in both P and Q the outputs are two
unrelated values that are different from any value any context can build, but clearly P ≈/ ˙ Q.


Proof of Example 4.8
In order to show (9) define the family of (parameterized) processes


Pσ  def
σ	σ  def	σ

t,s = [rec x.⟨t⟩.⟨s⟩.x♩l	Qt,s = [⟨t⟩.rec x.⟨s⟩.⟨t⟩.x♩l


and let

Yσ = {(C(Pσ ),C(Pσ )), (C(Qσ ),C(Pσ )), (C(Pσ ),C(Qσ )) | C binds l}

s,t
t,s
s,t
s,t
s,t
t,s
t,s



Then Ys,t= S
Yσ  is a weak contextual bisimulation. Consider for instance C(Pσ ) Y C(Pσ ). If

σ	s,t
t,s
s,t

C(Pσ ) τ
C'(Qσ ) then intuitively, we let the process at location l in C(Pσ ) completely disconnect from

t,s  −→
s,t
s,t

other nodes and then let it broadcast s to an empty set of receivers, afterwards we then let l connect to all nodes in σ again after which it can broadcast t.


Proof of Example 4.12
Y, the least relation on N such that for all σ0, σ1, σ1', σ2:


σ0,σ1 ,σ2
σ0 ,σ1 ,σ1 ' ,σ2
σ0,σ1 ,σ2
σ0 ,σ1 ,σ1 ' ,σ2

P0	Y Q0i	and P4	Y Q4i	for i = 0, ... , 4

σ0,σ1 ,σ2
σ0 ,σ1 ,σ1 ' ,σ2
σ0,σ1 ,σ2
σ0 ,σ1 ,σ1 ' ,σ2

P1	Y Q1i	and P3	Y Q3i	for i = 0, ... , 5

σ0,σ1 ,σ2
σ0 ,σ1 ,σ1 ' ,σ2

P2	Y Q2i	for i = 0, ... , 2

is a weak bisimulation containing P ≈˙ Q where


Pσ0,σ1 ,σ2 = ([p♩σ0
([r♩σ1
 [q♩σ2 ) \ {l1}) \ {l2}

l0	l2	l1

Pσ0,σ1 ,σ2 = ([p'♩σ0
 ([⟨t1⟩.r♩σ1
 [q♩σ2 ) \ {l1}) \ {l2}

l0	l2	l1

Pσ0,σ1 ,σ2 = ([p'♩σ0
([r♩σ1
 [⟨t2⟩.q♩σ2 ) \ {l1}) \ {l2}

l0	l2	l1

Pσ0,σ1 ,σ2 = ([p'♩σ0
 ([⟨t2⟩.r♩σ1
 [q♩σ2 ) \ {l1}) \ {l2}

l0	l2	l1

Pσ0,σ1 ,σ2 = ([p'♩σ0
([r♩σ1
 [q♩σ2 ) \ {l1}) \ {l2}

l0	l2	l1

with t1 = enc((msg , n), key), t2 = enc(n, key), and let, where n /∈ fn (t, t'),


σ0 ,σ1 ,σ1 ' ,σ2

σ0	σ1

σ1 '	σ2

Q00	= ([p♩l0  ([r♩l2  [r♩l3   [q♩l1 ) \ {l1}) \ {l2, l3}
σ0 ,σ1 ,σ1 ' ,σ2	σ0	σ1	σ1 '	σ2
Q01	= ([p♩l0  ([⟨t⟩.r♩l2  [r♩l3  [q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
σ0	σ1
σ1 '	σ2

Q02	= ([p♩l0  ([r♩l2  [r♩l3  [⟨t⟩.q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2	σ0
σ1	σ1 '	'	σ2

Q03	= ([p♩l0  ([⟨t⟩.r♩l2  [r♩l3  [⟨t ⟩.q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2	σ0
σ1	'
σ1 '	σ2

Q04	= ([p♩l0  ([⟨t⟩.r♩l2  [⟨t ⟩.r♩l3  [q♩l1 ) \ {l1}) \ {l2, l3}


σ0 ,σ1 ,σ1 ' ,σ2

' σ0

σ1	σ1 '	σ2

Q10	= ([p ♩l0  ([⟨t1⟩.r♩l2  [r♩l3   [q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q11	= ([p ♩l0  ([⟨t1⟩.r♩l2  [⟨t1⟩.r♩l3   [q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q12	= ([p ♩l0  ([⟨t1⟩.r♩l2  [⟨t⟩.r♩l3   [q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q13	= ([p ♩l0  ([⟨t1⟩.r♩l2  [r♩l3  [⟨t⟩.q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q14	= ([p ♩l0  ([⟨t1⟩.r♩l2  [⟨t1⟩.r♩l3   [⟨t⟩.q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	'	σ2

Q15	= ([p ♩l0  ([⟨t1⟩.r♩l2  [⟨t⟩.r♩l3   [⟨t ⟩.q♩l1 ) \ {l1}) \ {l2, l3}


σ0 ,σ1 ,σ1 ' ,σ2

' σ0

σ1	σ1 '	σ2

Q20	= ([p ♩l0  ([r♩l2  [r♩l3  [⟨t2⟩.q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0	σ1
σ1 '	σ2

Q21	= ([p ♩l0  ([⟨t1⟩.r♩l2  [r♩l3   [⟨t2⟩.q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q22	= ([p ♩l0  ([⟨t⟩.r♩l2  [r♩l3  [⟨t2⟩.q♩l1 ) \ {l1}) \ {l2, l3}


σ0 ,σ1 ,σ1 ' ,σ2

' σ0

σ1	σ1 '	σ2

Q30	= ([p ♩l0  ([⟨t2⟩.r♩l2  [r♩l3   [q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q31	= ([p ♩l0  ([⟨t2⟩.r♩l2  [⟨t1⟩.r♩l3   [q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q32	= ([p ♩l0  ([⟨t2⟩.r♩l2  [⟨t2⟩.r♩l3   [q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q33	= ([p ♩l0  ([⟨t2⟩.r♩l2  [r♩l3   [⟨t2⟩.q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q34	= ([p ♩l0  ([⟨t2⟩.r♩l2  [⟨t⟩.r♩l3   [q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q35	= ([p ♩l0  ([⟨t2⟩.r♩l2  [r♩l3  [⟨t⟩.q♩l1 ) \ {l1}) \ {l2, l3}


σ0 ,σ1 ,σ1 ' ,σ2

' σ0

σ1	σ1 '	σ2

Q40	= ([p ♩l0  ([r♩l2  [r♩l3   [q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q41	= ([p ♩l0  ([⟨t⟩.r♩l2  [r♩l3  [q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	σ2

Q42	= ([p ♩l0  ([r♩l2  [r♩l3  [⟨t⟩.q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	σ1 '	'	σ2

Q43	= ([p ♩l0  ([⟨t⟩.r♩l2  [r♩l3  [⟨t ⟩.q♩l1 ) \ {l1}) \ {l2, l3}

σ0 ,σ1 ,σ1 ' ,σ2
' σ0
σ1	'
σ1 '	σ2

Q44	= ([p ♩l0  ([⟨t⟩.r♩l2  [⟨t ⟩.r♩l3  [q♩l1 ) \ {l1}) \ {l2, l3}
