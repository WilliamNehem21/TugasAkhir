

Electronic Notes in Theoretical Computer Science 249 (2009) 377–405
www.elsevier.com/locate/entcs

An Algebraic Account of References in Game Semantics
Paul-André Melliès1	Nicolas Tabareau2
Laboratoire Preuves Programmes Systèmes CNRS & Université Paris Diderot

Abstract
We study the algebraic structure of a programming language with higher-order store, in the style of ML references. Instead of working directly on the operational semantics of the language, we consider its fully abstract game semantics defined by Abramsky, Honda and McCusker one decade ago. This alternative description of the language is nice and conceptual, except on one significant point: the interactive behavior of the higher-order memory cell is reflected in the model by a strategy cell whose definition remains slightly enigmatic. The purpose of our work is precisely to clarify this point, by providing a neat algebraic definition of the strategy. This conceptual reconstruction of the memory cell is based on the idea that a general reference behaves essentially as a linear feedback (or trace operator) in an ambient category of Conway games and strategies. This analysis leads to a purely axiomatic proof of soundness of the model, based on a natural refinement of the replication modality of tensor logic.
Keywords: game semantics, general references, tensor logic, replication modality, compact-closed categories, trace operator, memory access.


Introduction
Game semantics as an idealized compilation
The purpose of game semantics is to interpret programs as interactive strategies playing against their environment. It is nice to think that game semantics provides in this way an idealized compilation scheme, where the programs written in a high-level language are translated as strategies expressed in the low-level language of automata theory. This line of thought motivated already Berry and Curien to define their model of the purely functional language PCF based on concrete data structures and sequential algorithms – an early precursor of game semantics [7]. From that point of view, it is important to investigate what features of (high-level) programming languages can be compiled in game semantics, and what expressive power of the

1 Email: mellies@pps.jussieu.fr
2 Email: tabareau@pps.jussieu.fr

1571-0661 © 2009 Published by Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.07.099

target (low-level) language is necessary in order to perform the translation. A typical question is:
Does one need to equip the target language (seen as a game or as an automa- ton) with a notion of state, in order to compile a programming language admitting itself a notion of state?
In their seminal work on ground-type references in Idealized Algol, Abramsky and McCusker answered to this question in the most unexpected way, see [4]. In order to understand properly the unexpected nature of their answer, one needs to start from the beginning – that is, the interactive description of the purely functional programs discovered by Hyland and Ong a few years earlier. They established that the functional programs written in the language PCF translate precisely as innocent and well-bracketed strategies – where innocence and well-bracketedness are conditions on strategies formulated in the framework of arena games [10].
Idealized Algol is an imperative extension of the language PCF with ground- type memory cells, where boolean and integer values can be stored. In their work, Abramsky and McCusker established that the imperative programs written in Ide- alized Algol translate precisely as visible and well-bracketed strategies – where the notion of visibility is formulated in the framework of arena games, and weakens the notion of innocence defined by Hyland and Ong.
This result is remarkable because it demonstrates that one does not need to refine the target language of functional languages (arena games) in order to translate imperative programs: it it is sufficient to relax the original constraint (innocence) into a weaker one (visibility.) In particular, the framework of arena games does not carry any explicit notion of state. This “stateless approach” is inspired by the “object-based” semantics of Idealized Algol developed in [24]. One main benefit of the approach is to clarify in what sense a given programming feature is more expressive than another one. In particular, the same type in PCF and in Idealized Algol is interpreted as the same arena game in each interpretation: the only difference between the two languages is the class of strategies playing on the arena game.

General references and game semantics
Abramsky, Honda and McCusker carried on in this line and established a similar result for a call-by-value language with higher-order store, in the style of ML general references. Recall that general references can store not only values of ground types (i.e. integers, booleans) but also those of higher types (procedures, higher-order functions, or references themselves). They provide a useful and powerful program- ming construct: the ability to write, to read and to transmit higher-order informa- tion through the store is essential not only for efficiency but also for clarity of the program structures involving states. Thus, the definition of a fully abstract model characterizing the programs written in this paradigm was an important achievement of game semantics. The interested reader will find in [22] a recent application of the model to an investigation of aspect-oriented programming.
Developing on their previous work, Abramsky, Honda and McCusker established

that the imperative programs written with general references define precisely the thread-independent and well-bracketed strategies of arena game. So, just as visibil- ity weakens innocence and characterizes programs written with ground-type refer- ences, thread-independence weakens visibility and characterizes programs written with general references, see [2] for details.
This nice sequence of characterization theorems may be summarized in the fol- lowing table:

purely functional programs		innocent and well-bracketed strategies

imperative programs with ground-type references
imperative programs with general references
	visible and
well-bracketed strategies
		thread-independent and well-bracketed strategies


where we are careful to indicate with the sign  that the definability result holds in all rigor for the compact (that is, finite) strategies of a given class.




Investigating the algebraic structure of general references
The purpose of this paper is to uncover a series of elementary algebraic structures hidden in the arena game model of general references designed by Abramsky, Honda and McCusker. Each ingredient is simple and conceptually clear, and we review them in turn:
first of all, one needs to relax linear logic into tensor logic in order to study arena games, and to define the right kind of replication modality,
then, the most primitive notion of general reference – called linear memory cell – may be constructed by feedback using a trace operator,
here, one recalls that there exists a canonical notion of trace operator in any compact-closed category,
so, we will work inside a compact-closed category of Conway games and well- bracketed strategies,
linear memory cells are much too primitive: hence, we will need the replication modality ! of tensor logic in order to replicate them an infinite number of time, and a notion of memory access in order to bundle this infinite number of linear memory cells into the familiar notion of memory cell for general references.
Put all together, these five ingredients induce a purely axiomatic proof of soundness for the model of general references defined by Abramsky, Honda and McCusker. We review below these ingredients in turn.

Tensor logic and replication modalities in game semantics
Tensor logic was introduced in [19] in order to regenerate the fruitful connection between linear logic and game semantics. Tensor logic is simply obtained by relaxing the involutive negation of linear logic into a general notion of tensorial negation. The shortest way to describe the logic is to start from its categorical semantics. A dialogue category is defined as a symmetric monoidal category C equipped with an exponentiable object ⊥, called the tensorial pole of the dialogue category. Recall that an object ⊥ is exponentiable when every functor
A	'→	C(A ⊗ B, ⊥)	:	Cop	−→	Set
is representable by an object B   ⊥ and a bijection
φA,B	:	C(A ⊗ B, ⊥)	∼=	C(A, B   ⊥)
natural in A. The tensorial negation of the dialogue category C is then defined as the functor


induced by the tensorial pole
¬	:	C	−→	Cop


¬A	=	A   ⊥.

Every such tensorial negation induces a self-adjunction, whose monad is called the linear continuation monad of the dialogue category. Note that the dialogue category is ∗-autonomous precisely when the unit of the monad
ηA	:	A	−→	¬¬A
is an isomorphism. One main reason for relaxing linear logic into tensor logic is that this enables to define a general notion of replication modality for categories of games and strategies. Indeed, such a category of games and strategies typically defines a dialogue category C. A replication modality is then defined as a monoidal adjunction between the dialogue category C and a cartesian category M
  U 
z 
M ,¸ ⊥	C
F
this generalizing the usual notion of a replication modality in a model of linear logic, see [6]. This notion of replication modality on tensor logic will become the key ingredient of our algebraic account of general references. The reason is that an explicit description of resources is necessary in order to describe how the memory cell manages the various copies induced by the sequence of write and read operations.

References as feedback in traced monoidal categories
Traced monoidal categories were introduced by Joyal, Street and Verity as a uni- form account for several constructions dealing with cyclic behaviours in mathematics

and computer science – most notably braid closure in knot theory, trace operators in linear algebra, and feedback in computer science, see [12] for details. Recall that a traced symmetric monoidal category is a symmetric monoidal category (C, ⊗,I, c) equipped with a natural family of functions, called a trace operator,


X A,B
: C(X ⊗ A, X ⊗ B) → C(A, B)

which is nicely depicted in string diagrams

which satisfies a series of coherence axioms reflecting topological properties of the diagrammatic notation.
As far as we know, Milner was the first one to observe that linear feedback could be used in order to interpret restriction in process calculi. Milner describes this basic construction in the framework of action calculi, where he calls reflection the linear feedback operator. This feedback operator enables him to describe the restriction operator of arity

as the trace of the diagonal along the arity p, see [20].
ν		:		ϵ → p δp	:		p → p ⊗ p

Of course, we are interested in general references rather than channels, but the mechanism transforming a global variable into a local one works in a very similar way. In the usual monadic approach to effects, one interprets a programming language in a category by distinguishing between the objects A describing a value, and the objects TA describing computation of type A, where T is a given monad reflecting the particular notion of effect considered. In the case of references, the relevant monad is the state monad X '→ S  (S⊗X) which enables to interpret a program P of type A → B as a morphism
A	−→	S   (S ⊗ B)
taking a value of type A as input and producing a computation of type S  (S ⊗ B) as output. It follows from the definition of linear implication in a symmetric monoidal category that this morphism may be seen alternatively as a morphism
f	:	S ⊗ A	−→	S ⊗ B
This reformulation enables to see the monadic interpretation as the description of an input/output system with a store accessible by the user. Now, imagine that the trace of the morphism f along the object S is defined. In that case, we obtain a

morphism
g	:	A	−→	B
which behaves exactly like the original program P in which the state S is not global anymore, but local. This is precisely the analogous to the restriction (or localization) of Milner, where the channels are replaced by memory addresses.

Feedback in compact closed categories
We want to reconstruct the notion of general reference from the existence of a linear feedback, or trace operator, in a symmetric monoidal category of interest. One most natural way to obtain such a trace operator is to start from a compact closed category.
Recall that a compact closed category [13] is a symmetric monoidal category C in which every object A has a dual object. This means that for every object A, there exists an associated object A∗ and two morphisms called unit ηA : I → A∗ ⊗ A and counit εA : A ⊗ A∗ → I, depicted in the language of string diagrams as
ηA :  	and	εA :  ,
satisfying the two zigzag identities

= 	and	= 


Every such compact closed category is equipped with a canonical trace operator defined in the expected diagrammatic way.
So the second ingredient of our reconstruction of general references will be to work in a compact closed category. More precisely, we will consider the full subcat- egory Conway− of games starting by an Opponent move inside a compact closed category Conway of Conway games. This subcategory is symmetric monoidal closed and inherits a trace operator from the ambient compact closed category. In fact, the category Conway− inherits its closed structure from an adjunction
J
z 

Conway,¸
⊥	Conway
Neg

where Neg removes all the initial Player’s moves in the general Conway game. It is worth mentioning that early discussions with Masahito Hasegawa on this specific example enabled him to clarify the general categorical situation: he showed indeed that every traced symmetric monoidal closed category embeds as a full co-reflective subcategory in a compact closed category – typically defined by the Int construction, see [9].

Conway games and well-bracketed strategies
Since we are interested in defining a compact closed category of games and strate- gies, it is natural to start from the first category of games and strategies ever consid- ered in the literature: the category of Conway games defined in [11] which is indeed compact closed. In fact, the starting point of our work is precisely the observation that this category is very deeply related to the game model of general references introduced by Abramsky, Honda and McCusker.
One missing ingredient in Conway games (however) is a notion of well-bracketing which enables to constraint the strategies of arena games. Hence, we take advantage of our recent construction of a compact closed category of Conway games and well- bracketed strategies, see [19]. In fact, our construction goes much further than this, since we are able to see the very notion of well-bracketing as an effect of linearity conditions on games and strategies. Although this logical aspect of the construction is fundamental, its role is very limited here. So, we will avoid discussing the details of the construction. Let us simply mention that in order to define a notion of bracketing on Conway games, while keeping the self-dual nature of Conway games, one needs to replace the traditional notions of question and answer by the more conceptual (and expressive) notions of query and response attached to the moves. See [19] and [26] for details.

Memory access modality
It appears that the category of call-by-value games defined by Abramsky, Honda and McCusker is isomorphic to a well-understood subcategory of the Kleisli category induced by the replication modality on our category of bracketed games. In fact, we could easily use their full abstraction result directly in order to obtain a full abstraction result for our model. But this is not really our point, here. The only novelty of our work is that the strategy cellA interpreting a memory cell of type A is obtained in a nice and conceptual way in our formulation.
The existence of a trace operator and a tensorial negation on the category Conway− enables to construct a very primitive notion of memory cell – called linear memory cell because it can be written and read only once. The replication modality of tensor logic enables then to replicate this linear memory cell in order to transform it into a constant memory cell, where one may write only once, but may then read as many times as desired.
The very last step is thus to construct a general memory cell. Here, we take advantage of the presence of linearity in our model, which enables to capture the difference between the copy management performed by a usual memory cell and by a constant memory cell. This difference is nicely axiomatized by the existence of two particular natural transformations
ξA,B : !(A ⊗ !B) −→ !A ⊗ !B	αA : A ⊗ !A −→ !A

defining what we call a memory access modality. These two maps will enable us to construct in basic little steps the familiar notion of memory cell:

the linear memory cell which can be written and read only once – its construction requires the negation of tensor logic, and the compact closed structure of Conway games,
the constant memory cell which can be written only once, but read an infinite number of times – this construction requires the replication modality of tensor logic,
the familiar memory cell which can be written and read an infinite number of times – this construction requires the assumption that that the replication modality is equipped with a memory access map.
Moreover, the resulting notion of memory cell coincides with the strategy cellA
defined by Abramsky, Honda and McCusker in the model of general references.

Bad variables in game semantics of states
One embarrassing point about this game-theoretic approach on references is that one needs to extend the programming language with a bad variable constructor in order to achieve the expected full abstraction result, characterizing programs as visible (or thread-independent) well-bracketed strategies. This particular problem is nicely explained and corrected in [18] and [21] for ground type references, by refining the notion of arena game. The main idea is to constrain the use of read and write moves by introducing new relations on plays and strategies to express an aspect of uniformity characterizing the interaction of every memory cell strategy. The main idea is that in absence of bad variables, each variable operation, whether a Read or a Write, produces the same side-effects while it is being completed.
Confronted to this difficulty, and the wish to extend the original notion of refer- ence with the ability to compare names, the temptation is high to escape from the original framework. This may be done in two directions:
shift to a monadic approach, where the strategies interpreting the imperative programs are innocent, rather than visible or thread-independent. This is the solution recently explored in [27] in a nominal setting,
shift to a game model with an explicit notion of state in the game. This is the solution recently advocated in [16] and [15].
We hope that our algebraic approach to general references will enable to regulate the field, and to relate these apparently diverging approaches to game semantics.

Related works
There are not so many axiomatic approaches to programming languages based on game semantics. Let us mention three of them however. Abramsky gave a purely axiomatic proof of definability for PCF [1] followed by an axiomatic proof of full completeness for models of ML polymorphic types, in collaboration with Lenisa [3]. A few years later, Laird worked out an axiomatic proof of definability for a language with higher-order store [14]. His construction starts from the definition of an asymmetric tensor product on games, discussed with the first author a few years



Fig. 1. Typing rules of IdeaML
before. This asymmetry is indeed an important ingredient underlying the interactive behavior of higher-order store. In this paper, we prefer to derive the asymmetry from the existence of a pair of left-to-right and right-to-left coercion strategies
 	  

¬¬A ⊗ ¬¬B
   ¬¬(A ⊗ B)

reflecting the fact that the continuation monad ¬¬ is strong but not commutative. Accordingly, the existence of a retraction
!A   !B	Œ	!(!A   B)
mentioned in [14] is very similar to our notion of memory access. It will be interesting to understand how the logical and algebraic framework developed in this paper enables to clarify these axiomatic approaches to higher order store.

A language with general references
Types and terms
In this section, we recall the call-by-value language with higher-order store con- sidered by Abramsky, Honda and McCusker. We call this language IdeaML for clarity’s sake. Its types are defined by the grammar below
A, B ::= Unit | Nat | A → B | A × B | ref[A]
The terms and typing rules of IdeaML are recalled in Figure 1, where Γ is a typing context which associates a type to every variable. Note that the constructor mkvar is here to compensate for the presence of bad variables. This problem, first identified by John Reynolds [25], comes from terms of type ref[A] which do not have a memory



Fig. 2. Operational semantics of IdeaML
interpretation. The constructor mkvar allows to create bad variables from a term of type A → Unit (the writing method) and from a term of type Unit → A (the reading method).

Operational semantics
We also recall the operational semantics of the language. A configuration is defined as a triple (M, L, σ) where M is a term, L is a set of memory locations, and σ is a partial function, called memory state, which goes from locations to values of the appropriate type. As in the original paper by Abramsky, Honda and McCusker, we choose here a big step semantics. We thus need a notion of value, which are terms of the form:
V ::= n | b | x | skip | λx.V | ⟨V1, V2⟩
When a configuration (M, L, σ) reduces to a value (V, L', σ'), we note
(M, L, σ) ⇓ (V, L', σ')
For a more convenient notation, when the evolution of the memory state can be left implicit, we adopt the convention that
M ⇓ V	M' ⇓ V '
M'' ⇓ V ''
is an abbreviation for
(M, L, σ) ⇓ (V, L', σ')	(M', L', σ') ⇓ (V ', L'', σ'') (M'', L, σ) ⇓ (V '', L'', σ'')

Figure 2 describes inductively the operational semantics of our language.

Bracketed Conway games
The category Conway of bracketed Conway games was introduced in [19]. As we will see, it is compact-closed, and its full subcategory Conway− of Opponent-starting games is symmetric monoidal closed and traced – this providing the appropriate model of tensor logic in order to perform our algebraic reconstruction of the arena game model of IdeaML.
Conway games.
A Conway game A is an oriented rooted graph (VA, EA, λA) consisting of (1) a set VA of vertices called the positions of the game; (2) a set EA ⊂ VA × VA of edges called the moves of the game; (3) a function λA : EA → {−1, +1} indicating whether a move belongs to Opponent (−1) or Proponent (+1). We note A the root of the underlying graph. A Conway game is said to be negative (resp. positive) when all its move starting from the root belongs to Opponent (resp. Proponent).
A play s = m1 · m2 · ... · mk−1 · mk of a Conway game A is a path s :  A → xk
starting from the root A


s : 
−m−→1  x
−m−→2
mk−1	m
...	x	x

A	1	−−−→
k−1 −−→  k

Two paths are parallel when they have the same initial and final positions. A play is alternating when
∀i ∈ {1,...,k − 1},	λA(mi+1) = −λA(mi).
We note PlayA the set of plays of a game A.
Bracketed Conway games.
A bracketed Conway game is defined as a Conway game equipped with
a finite set QA(x) of queries for each position x ∈ VA of the game,
a function λA(x) : QA(x) −→ {−1, +1} which assigns to every query in QA(x) a po- larity which indicates whether the query is made by Opponent (−1) or Proponent (+1),
for each move x −m→ y, a residual relation
[m] ⊂ QA(x) × QA(y)
satisfying:
r[m]r1	and	r[m]r2 =⇒ r1 = r2 r1[m]r	and	r2[m]r =⇒ r1 = r2

The definition of residuals is then extended to paths s : x → y in the usual way – by composition of relations. We then define
r[s] d=ef {r' | r[s]r'}	and	[s]r d=ef {r' | r'[s]r}.
We say that a path s : x → y:
complies with a query r ∈ QA(x) when r has no residual after s — that is, r[s] = ∅,
initiates a query r ∈ QA(y) when r has no ancestor before s — that is, [s]r = ∅.
We require that a move m only initiates queries of its own polarity, and only complies with queries of the opposite polarity. In order to formalize that a residual of a query is intuitively the query itself, we also require that two parallel paths s and t induce the same residual relation: [s] = [t]. Finally, we require that there are no queries at the root: QA( ) = ∅.

Resource function.
Extending Conway games with queries enables the definition of a resource function
κA = (κ+, κ−)
A	A
which counts, for every path s : x → y, the number κ+(s) (respectively κ−(s)) of
A	A
Proponent (respectively Opponent) queries in r ∈ QA(y) initiated by the path s — that is, such that [s]r = ∅.
Dual.
Every bracketed Conway game A induces a dual game A∗ obtained simply by re- versing the polarity of moves and queries.

Tensor product.
The tensor product A ⊗ B of two bracketed Conway games A and B is essentially the asynchronous product of the two underlying graphs. More formally, it is defined as:
VA⊗B = VA × VB,
its moves are of two kinds :

x ⊗ y → ⎧⎨ z ⊗ y if x → z in the game A
⎩ x ⊗ z if y → z in the game B,
QA⊗B(x ⊗ y) = QA(x)  QB(y),
the polarities of moves and queries in the game A ⊗ B is inherited from games A
and B and the residual relation is defined pointwise.

The unique bracketed Conway game 1 whose underlying Conway game is the game with a unique position and no move is the neutral element of the tensor product. As usual in game semantics, every play s of the game A ⊗ B can be seen as the interleaving of a play s|A of the game A and a play s|B of the game B.
Strategies.
A strategy σ of a bracketed Conway game A is defined as a non empty set of al- ternating plays of even length such that (1) every non empty play starts with an Opponent move; (2) σ is closed by even length prefix; (3) σ is deterministic, i.e. for all plays s, and for all moves m, n, n',
s · m · n ∈ σ ∧ s · m · n' ∈ σ ⇒ n = n'.
We write σ : A → B to indicate that σ is strategy over the game A∗ ⊗ B.
Well-bracketed plays.
An alternating play s is well-bracketed (from the Player’s point of view) in the game A when for every factorization s = s1 · m · t · n · s2 with m an Opponent move and n a Player move, one has
κ+(m · t · n) = 0	implies	κ−(m · t · n) = 0 
A	A
An alternating play s is well-bracketed (from the Opponent’s point of view) in the game A when it is well-bracketed from the Player’s point of view in the dual game A∗. An alternating play s is well-bracketed in the game A when it is well-bracketed from the Player and the Opponent’s point of view.
Well-bracketed strategies.
A strategy σ is well-bracketed when all its plays s ∈ σ are well-bracketed (from Player’s point of view).
Composition.
We define the composite of two strategies σ : A → B and τ : B → C in the usual fashion based on “parallel composition plus hiding”. The proof that the composite of two well-bracketed strategies is well-bracketed is far from immediate: the interested reader will find in [19].
Identity morphism.
We define the identity morphism idA on a game A by the expected copycat strategy on the game A∗ ⊗ A, in the same way as André Joyal defined it in [11]. The copycat strategy replies to any Opponent move in one of the component A∗ or A by the dual move in the other component.

The category of bracketed Conway games.
The category Conway has bracketed Conway games as objects, and well-bracketed strategies σ of A∗ ⊗ B as morphisms σ : A → B. The resulting category Conway is compact-closed in the sense of [13]. The unit ηA : 1 → A ⊗ A∗ and counit εA : A∗ ⊗ A → 1 are defined as the expected copycat strategies.
From now on, we will consider the full subcategory Conway− of negative brack- eted Conway games. By negative game A, we mean a game where Opponent starts. This category Conway− is symmetric monoidal, and inherits a trace operator from the ambient category of bracketed Conway games. Not only that: the category Conway− is symmetric monoidal closed. As such, it defines a model of tensor logic for every object ⊥ selected as tensorial pole in the category Conway−. The tenso- rial negation below is induced by defining ⊥ as the game with a unique move, which is played by Opponent, and initiates no query.
Tensorial negation.
The negation ¬A of a negative game is the pointed game obtained by lifting the dual game A∗ with a unique Opponent move that does not initiate any query.
Replication modality.
Every negative Conway game A induces a duplicable game !A which should be seen as some kind of infinite tensor product of the game A. We define !A as follows
its positions are finite words w = x1 ··· xk whose letters are positions xi of the game A which are different from the root; the intuition is that a letter xi describes the current position in the ith copy of A;
its root is the empty word !A = ε;
a move w → w' is either a move played in one copy:
w1 y w2 → w1 y' w2
where y → y' is a move of the game A and y /= A; or an opening of a new copy:
w → w · y
where A → y is a move of the game A strating from the root  A.
its queries at the position w = x1 ··· xn are the pairs (i, r) composed by an index 1 ≤ i ≤ n and a query r at the position xi of the game A. In particular, there is no query at the empty position ε.
The polarities of moves and queries are inherited from those of the game A in the obvious way; and the residual relation is defined as for the tensor product. Using the limit construction of free exponentials described in [23,26], we are able to show that the game !A is the free commutative comonoid generated by the game A. In this way, we have just defined a model of tensor logic (without coproducts) in a traced monoidal category equipped with a notion of well-bracketing.

Accommodating the additives.
At this point, there remains to define a notion of finite coproduct in the category Conway−. Unfortunately, the category Conway− does not have coproducts. In- stead, it has all products, noted &iAi, defined as the direct sum of the underlying graphs. So, we apply the family construction, described in [5], in order to freely add the coproducts to our category. One extremely pleasant aspect of tensor logic is that the category Fam(Conway−) defines a model of tensor logic with sums and a repli- cation modality inherited from the category Conway−. Namely, the exponential modality on the category Fam(Conway−) is defined pointwise, and thus transports an object (Ai)i∈I of the category Fam(Conway−) to the object !(Ai)i∈I = (!Ai)i∈I .
Notation.
Before interpreting the language IdeaML in our game semantics, we find use- ful to polarize formulas, so that negative formulas are interpreted in the category Conway− of Opponent-starting Conway games, whereas the positive formulas are interpreted in the category
Conway+	d=ef	(Conway−)op
of Player-starting Conway games. In order to distinguish between a positive and a negative formula, one has to clone every connective of tensor logic. Typically, the tensorial negation ¬ is cloned as two functor
P : Conway− −→ Conway+	O : Conway+ −→ Conway−
ˆ	´
This leads us to draw the mnemonic table:
Note in particular that the replication modality ! does not alter the polarity of the negative formula, in contrast to what happens in usual polarized logic. This point is not only a key aspect of tensor logic: it is also necessary in order to achieve our reconstruction the memory cell in the next section.

Full abstraction by comparison
In this section, we establish a full abstraction theorem for our game semantics of the language IdeaML. We achieve this by reformulating the game model designed by Abramsky, Honda and McCusker as a subcategory of the Kleisli category Conway− induced by the replication comonad ! on the category Conway− of negative brack- eted Conway games.
Recall that Abramsky, Honda and McCusker construct a category AHM with arena games as objects, and well-bracketed strategies on the game A ⇒ B as mor-

phisms from A to B, see [2] for details. An arena is a triple A = (MA, λA, ▶A)
where MA is a set of moves, λA = (λOP , λQA) : MA → {O, P}×{Q, A} is a labelling
A	A
function and ▶A is a justification relation between the moves. A strategy of such an
arena is then defined as a set of justified, alternating and well-bracketed plays, in the tradition of [10].
The three authors declare that a strategy σ is thread-independent when it plays according each “thread” or “connected component” of the game independently. In other words, a thread-independent strategy σ plays according to all the moves of the game which are hereditarily justified by the same initial move. A more conceptual way to think of these strategies is to observe that they are precisely the comonoid morphisms between arenas, seen as commutative comonoids in the category AHM, see [8] for details.
Our point is that every such thread-independent strategy σ from A to B in the category AHM may be seen as a strategy of the form !A  B in the category Conway− of negative Conway games. We formalize this intuition below. Let us define AHMthread the category whose objects are arenas and whose morphisms from A to B are well-bracketed and thread-independent strategies on the game A ⇒ B. It is by definition a subcategory of AHM.
We define a faithful (but not full) functor
U	:	AHM	−→	Conway−

which transports an arena A = (MA, λA, ▶A) to the negative bracketed Conway game U (A) defined as follows:
the positions of U (A) are the plays of the arena game A,
there is a move m between two plays s and s' precisely when s' = s · m,
the polarity of moves is inherited from the polarity of those of A,
a move s −m→ s' initiates a query when m is a question in the game A;
a move n complies with a query initiated by the move m when n is an answer and
m justifies n.
Every strategy σ of the game A −→ B in the category AHM is transported to the corresponding strategy σ of the game U (A) −→ U (B) in the category Conway− of negative bracketed Conway games. The functor U is obviously faithful.
Let us briefly explain why the functor U is not full. This is a subtle point which deserves to be clarified. The anomaly is minor however, and comes in fact from the very definition of well-bracketed strategies in arena games – as strategies σ containing only well-bracketed plays, where well-bracketed means that the play is well-bracketed from the point of view of Player and Opponent. Given two arena games A and B, it is generally possible to find an alternating play s in the arena game A ⇒ B which is well-bracketed from the point of view of Player but not from the point of view of Opponent. Then, any well-bracketed strategy τ which contains the play s in the Conway game U (A)  U (B) cannot be the image of a well-bracketed strategy σ : A −→ B in the category AHM of arena games.

This anomaly is easy to correct however, since every well-bracketed strategy τ on a Conway game contains a largest well-bracketed strategy τ of the form U (σ), defined as the set of plays s ∈ τ which are not only well-bracketed from the point of view of Player, but also from the point of view of Opponent. The strategies of the form U (σ) are then characterized as the strategies τ such that the equality τ = τ holds.
The functor U : AHM → Conway− lifts to a faithful functor
U˜ : AHMthread −→ Conway−
such that the following diagram commutes


AHM
 Ue  C onway−

t˛zhread

J	U
˛z !
J 

AHM	 C onway−

Observe that the category AHMthread defines a subcategory of Conway− in which all the bracketed Conway games of the form U (A) are bracketed in the usual sense... that a move in the game can initiate at most one query.
At this stage, Abramsky, Honda and McCusker shift to the game semantic in- terpretation of a call-by-value language, by applying the family construction on the category AHM, exactly as we have done in order on the category of negative Con- way games Conway− in order to obtain a model of tensor logic with sums and replicative modality. From this, we deduce that the category introduced by Abram- sky, Honda and McCusker in order to give a fully abstract model of IdeaML lives inside the category Fam(Conway−). Moreover, the morphisms of this underling category are characterized by the equality τ = τˆ. Besides, the contextual equiva- lence of the category Fam(Conway−) identifies two strategies σ and τ containing

the same well-bracketed plays:
σ ∼ τ	⇐⇒


σˆ = τˆ. 

Hence, the category Fam(Conway−) provides a fully abstract model of IdeaML which coincides with the model provided by Abramsky, Honda and McCusker after this mild quotient by contextual equivalence.

An algebraic account of memory cells
The main novelty of our approach to general references is that it enables us to recon- struct the interactive strategy interpreting the memory cell in a purely conceptual way. In fact, we work gradually, and define three different paradigms of memory cell, using tensor logic and the compact closed structure of the underlying category of Conway games. A pleasant aspect of the approach is to relate the copy management performed by the familiar memory cell to the existence of a natural transformation

on the replication modality
ξA,B	:	!(A ⊗ !B)	−→	!A ⊗ !B

satisfying two coherence laws.

An analysis of the strategy cellA.
Before constructing the strategies associated to each kind of cell, it seems useful to recall how the language IdeaML is interpreted in the category Fam(Conway−), following [2]. Abramsky, Honda and McCusker interpret the call-by-value language IdeaML using a cartesian closed category equipped with a strong monad. This monad, defined on the family category, is described in our model by


T (A )
d=ef
O	P
(  ⊕	A )

i i∈I
´	i ˆ	i


seen as a singleton family in the category Fam(Conway−). The unit of this monad is obtained from the unit of the continuation monad and from injections. The strength of the monad T is easily deduced from the strength of the continuation monad. We note

TA ⊗ TB 
	left
 T ( A ⊗ B)
rightA,B

the left-to-right and right-to-left coercions of the strong monad T . The interpretation of a typing judgment


is given by a morphism
x1 : X1, ··· xn : Xn ▶ M : A


!{X1} ⊗ ··· ⊗ !{Xn} −→ T{A}


where {A} = (Ai)i∈I is the translation of the type A in the category Fam(Conway−). Such a morphism in the category Fam(Conway−) may be seen as a strategy which lets Opponent choose a component Yi in each family Xi, and then plays according to a strategy
O	P

!Y1 ⊗ ··· ⊗ !Yn	−→
´ ⊕i ˆ Ai

in the category Conway−. The translation of the arena corresponding to the type ref[A] is the bracketed game


{ref[A]} d=ef
O P
!(&
`?A∗)) ⊗ ! T (A ) d=ef
!Write
⊗ !Read

i ´ (ˆ 1	i	i
!A	A

seen as a singleton family in the category Fam(Conway−). The formulas


Write
O  P
= &	` A∗)	Read
= T (A )

A	i ´ (ˆ 1	i
A	i i∈I


{Γ ▶ new x : A, y : B in M} = {Γ ▶ new y : B, x : A in M}	(1)
{Γ,x : ref[A] ▶ new y : B in x := V ; M} = {Γ,x : ref[A] ▶ x := V ; new y : B in M}	(2)
{Γ ▶ new x : A, y : B in x := V1; y := V2; M} = {Γ ▶ new x : A, y : B in y := V2; x := V1; M}	(3)
{Γ ▶ new x : A in x := V ; (λy.M )(deref(x))} = {Γ ▶ new x : A in x := V ; (λy.M )V }	(4)
{Γ ▶ new x : A in x := V1; x := V2; M} = {Γ ▶ new x : A in x := V2; M}	(5)


Fig. 3. Semantics of the memory cell
denote the type of the write and read methods for the family A = (Ai)i∈I . When
I = {i} is a singleton, the game T{ref[A]} can be depicted as the arena
O

,,!,,, P ¸¸¸! ¸

write(i¸)
read

,?,,
i
¸¸¸¸


ok	i
Ai

The interactive strategy cellA implementing the memory cell may be described informally as follows:
the strategy cellA reacts to the first move O by playing the move P ,
if the next move played by Opponent is read, the strategy does not respond,
the strategy cellA reacts to the move write(i) by playing the move ok,
when Opponent plays the move read and when the last writing move which has been played is write(i), the strategy cellA answers i,
when Opponent plays an initial move of Ai in the read component, the strategy
cellA answers by playing an initial move in a new copy of the game ?A∗, which
corresponds to the last move write(i) played,
then, the strategy cellA copycats the Opponent moves in Ai (resp. A∗) by playing
the corresponding moves in A∗ (resp. Ai).
We will now reconstruct the strategy cellA in three elementary steps.
Linear memory cell and dual object.
First, we construct the strategy lin_cellA of type

lin_cell
−−−−−−−→

T WriteA

⊗ ReadA
 ,	(6)

which interprets the linear memory cell. The construction of this strategy relies on the tensorial negation and on the existence of dual objects. Those two things enable to build a right inverse to the strength tA,B,C

O	P	O	P
A,B,C : ´ (A` ˆ (B ⊗ C)) −→ ´ (A` ˆ B) ⊗ C.

The construction starts from an elementary property of duals in a monoidal closed category, which the interested reader will find mentioned by Peter May [17].
Proposition 5.1 Let (C, ⊗, 1,  ) be a symmetric monoidal closed category. If the object C possesses a dual object C∗ in the category C, then the canonical morphism

fA,B,C	:	(A   B) ⊗ C	−→	A   (B ⊗ C)

is an isomorphism, for every object A and B.
We use a variant of this property, where the closure is replaced by a tensorial nega- tion. As starting point, we observe that the strength

O (A` P B) ⊗ C	tA,B,C	O (A` P (B ⊗ C))
´	ˆ	−−−−→	´	ˆ

which exists in the category Conway− extends in fact to the whole category Conway. This point is subtle: note in particular that the strategy tA,B,C is partial when the game C is positive, since it does not answer when Opponent plays his first move in the left hand side game C. For that reason, the algebraic and logical status of the strength in the whole category Conway remains somewhat enigmatic at that level of description.
The strategy A,B,C in the category Conway may be defined as follows:

O (A` P (B ⊗ C))	−⊗ηC	O (A` P (B ⊗ C)) ⊗ C∗ ⊗ C
´	ˆ	−−−−→	´	ˆ

−t⊗−→C
O (A` P (B ⊗ C ⊗ C∗)) ⊗ C

´	ˆ
(−⊗εC )⊗C  O	P
−−−−−−−→ ´ (A` ˆ B) ⊗ C.

When the game A is positive and the games B and C are negative, the resulting strategy defines a morphism in the category Conway−, which is right inverse to the strength. This right inverse morphism will be at the heart of our definition of the strategy lin_cellA. The construction starts by composing the injection of the singleton family (Ai) into the family (Ai)i∈I with the unit of the monad T

Ai −→ (Ai)i∈I  −→ T (Ai)i∈I = ReadA.	(7)

We then take its image by the tensorial negation and apply the law defining the tensorial negation, so as to obtain the morphism

χ	:	1	−→	O (A∗` P Read  .

Then, we use the right inverse of the strength for A = A∗, B = 1 and C = ReadA

and define a strategy of domain and codomain
write(¸i)

∗	¸¸
write(i)
read

Ai	ok
read	−→

i Ai
¸¸¸
∗	ok		i Ai

in the arena games notation. Every play s played by this strategy starts with the moves	write(i) · (write(i))∗ · i∗ · i
followed by a copycat strategy. So, the strategy is the copycat strategy which does
not answer in the case Opponent decides to read the memory cell before writing in it.
At this stage, there only remains to take the product on every index i and to compose with the unit of the continuation monad, in order to obtain the strategy lin_cellA described by Equation (6). The linear dereference method is defined by the copycat strategy on T ReadA, and the linear assign method is provided by


assign


linA
d=ef
eval P
:	A ⊗ WriteA
−→ T 1


where


eval
A,ˆ1

:	A⊗ O (A∗ ` B)	→	O B

A,B	´	´
is obtained by applying the law defining the tensorial negation to the identity mor- phism
O (A∗ ` B)	id	O (A∗ ` B).
´	−→	´
At this point, we show that this linear memory cell is well behaved in the sense that it satisfies the first four equations of Figure 3. Those four equations are well known because they constitute four of the five equations validated by a memory cell in the work of Abramsky, Honda and McCusker [2]. They ensure together the soundness of a linear memory cell.
The formalism provided by tensor logic enables us to deduce the validity of those four equations in a purely categorical way, using commutative diagrams of an algebraic flavor. In particular, we never have to refer to the strategies underlying the canonical morphisms.
Equality (1) comes from the fact that the diagram


A ⊗ B
	ηA⊗ηB	 T A  ⊗ TB 
	left
 T ( A ⊗ B)
rightA,B

commutes, where the two morphisms leftA,B and rightA,B are the left-to- right and right-to-left coercions induced by the strong monad T ,
Equality (2) follows directly from the coherence laws (associativity and multi- plication) satisfied by the monad T ,

Equality (3) follows from the bifunctoriality of the tensor product,
Equality (4) is more difficult to derive, because it involves diagrammatic prop- erties of the morphism . In order to simplify, we only describe here the key diagrams in the case of a singleton family, (Ai)i∈I = (A). Namely, we use the fact that the morphism is constructed from the strength of the tensorial negation and from the unit and counit of the compact closed structure.
More precisely, this equation reduces to the commutative diagram


TA  T A⊗χA     O	∗	P		T A⊗ A ,1,TA	   O	P
∗




tA,1
T A⊗ ´ (A ` ˆ T A)
tA,X1
J 
T A⊗ ´ (A ` ˆ 1) ⊗ TA 
tA,X2
J 

TA 		O	∗	P
 T (A⊗ A∗,1,TA) 	O	P

T (A⊗χA)T (A⊗ ´ (A ` ˆ T A))
T evalA,Y1
J 
T (T 2A)





T 1,1,TA
T (A⊗ ´ (A ` ˆ 1) ⊗ T A)
T (assignlinA⊗T A)
 T ( T 1 J  )

T μA

J c 
TTA 
μA
T left,1,A

		J 
TA 

where


X	O	∗	P
O	∗	P	P

1 =´ (A ` ˆ T A)	X2 =´ (A ` ˆ 1) ⊗ TA	Y1 =ˆ TA.

The two squares on the top commute by naturality of the strength of the monad T . The bottom-left triangle commutes as a variation on the zigzag identity involving the tensorial negation. By expanding the definition of and using the naturality of the unit and counit coming from the compact closed structure, the commutation of the square involving eval can be reduced to the commutation of the square,


O	P	 A⊗tA∗,TA,(TA)∗    O	P

A⊗ ´ (A∗` ˆ T A) ⊗ (T A)∗
evalA,Y ⊗(T A)∗
A⊗ ´ (A∗` ˆ (TA ⊗ (T A)∗))
evalA,Y2

2	J   ∗	tTA,(TA)∗		J   ∗
T A ⊗ (T A)	T (TA ⊗ (T A) )


where Y
P
2 =ˆ (
TA ⊗ (T A)∗). In the same way, to see that the down-right triangle

commutes, we have to come back to the definition of . The commutation is then

reduced to the commutation of the diagram


2	T 2A⊗ηTA   2 
∗	tTA,(TA)∗ ⊗T  A 
∗	 T εTA⊗TA  

T A	T
A ⊗ (T A)
⊗ TA 
¸¸¸¸¸¸¸¸¸
T (TA ⊗ (T A) ) ⊗ TA 
T 1 ⊗ TA 

tTA,1=idT 2A
t	∗ ¸¸¸¸¸¸¸
tTA⊗(TA)∗,TA
t1,A

TA,(TA) ⊗TA 
¸¸z  J	J 

2		 T ( TA ⊗ (T A)∗ ⊗ T A)
T (T A⊗ηTA)
T (εTA⊗T A)
 T 2 A

The left square commutes by naturality of the strength, the triangle in the middle commutes by associativity of the strength, and the square on the right commutes again by naturality of the strength.
Constant cell and replication modality.
We describe below the strategy const_cellA which interprets the constant memory cell in which one can write only once, but read infinitely many times. We construct it by taking the image through ! of the morphism (7) obtained by composing an injection and the unit of the monad T

!Ai −→ !A = (!Ai)i∈I −→ !ReadA
instantiated at the family A = (Ai)i∈I . We then apply the same transformation as for the linear memory cell, and obtain a morphism
−−−−−−−−→	T (Write!A ⊗ !ReadA).	(8)
This strategy has only one writing stage, and then throws a new copy on the same thread each time Opponent asks for reading the value. The dereference method is given by the dereliction


derefA d=ef
εTA	:	!ReadA −→ TA 

while the constant assign method is given by



assignconstA
d=ef
eval	P
:	!A ⊗ Write!A
−→ T 1

!A,ˆ1
Using the naturality of the dereliction of the replication modality, one easily estab- lishes that the constant memory cell validates the first four equations of Figure 3 from the fact that the linear memory cell satisfies them.
Memory cell and temporality.
At this point, we are ready to describe the memory cell which can be written and read an infinite number of times. The most natural idea is to think of such a memory cell as an infinite number of constant memory cells. This gives rise to a strategy of type
1 −→ !(Write!A ⊗ !ReadA)

where the scheduling of each copy is explicit. The whole point of the memory cell is precisely to hide this management at the level of types. In order to achieve this, it is necessary to take advantage of the high level of control available in the strategies between Conway games, in order to define a memory access strategy
ξWrite!A,ReadA	:	!(Write!A ⊗ !ReadA)	→	!Write!A ⊗ !ReadA
whose task is to enforce that every time a read access is performed on the memory cell, it reads the last written value. We start by defining this strategy in the language of Conway games, before describing the series of algebraic properties it satisfies. It is worth observing already that since the strategy is not innocent (not even visible), there is no hope to define it using structural morphisms. Given a play s of the game
!A ⊗ !B
s	:	 !A⊗!B → (wA, wB)
where wA ∈ V!A and wB ∈ V!B, we define the position of the game !(A ⊗ !B)


(wA, wB) ↓ s	d=ef
(a1, w1) ··· (an, wn)

where ai ∈ VA and wi ∈ V!B for all 1 ≤ i ≤ n, by requiring that
wA	=	a1 ··· an	wB	=	w1 ··· wn
and that the copies of the component B appearing in the position wi have been opened by the play s after the copy of the component A corresponding to the posi- tion ai, and before the copy of the component A corresponding to the position ai+1. So, the transformation of (wA, wB) into (wA, wB) ↓ s consists in gathering together as wi all the copies of the component B opened by the play s between the i-th and (i + 1)-th copies of the component A, witnessed by the positions ai and ai+1. This scheduling enables us to define the memory access function
f	:	Play!A⊗!B → Play!(A⊗!B)
as the unique function
s :  !A⊗!B → (w, w')	'→	f (s) : !(A⊗!B) → (w, w') ↓ s
such that the plays s and f (s) have the same underlying moves. This memory access function induces a memory access strategy
ξA,B	:	!(A ⊗ !B) → !A ⊗ !B


defined as

ξA,B	d=ef

{s | ∀t ≺ s , t|!(A⊗!B) = f (t|!A⊗!B )}

where s and t are even length paths of the game !(A ⊗ !B)  (!A ⊗ !B) and t is a prefix of s. We will also need to consider the strategy
αA : A ⊗ !A −→ !A

consisting of a copycat between the first opened copy of the game !A on the right- hand side and the game A, followed by a copycat between the other copies of the game !A and the game !A on the left-hand side. We will now axiomatize the proper- ties satisfied by the memory access strategy, properties that will be enough to show the validity of this strategy (for clarity, we omit explicit mention to the associativity in the monoidal category).
A memory access modality is defined as a replication modality ! equipped with two natural transformations ξ and α of component
ξA,B : !(A ⊗ !B) −→ !A ⊗ !B	αA : A ⊗ !A −→ !A
such that the diagrams

!(TA ⊗ !TB)	ξTA,TB	 !T A ⊗ !TB 


εTA⊗!TB 
J 
TA 

εTA⊗εTB 
J 
TA 

(9)

⊗ !TB 
T A⊗εTB 
⊗ TB 
leftA,B

J 	 T ( A J 

TA ⊗ TB	left


A,B
⊗ B)



!(TA ⊗ !TB) 	ξTA,TB	 !T A ⊗ !TB 


dTA⊗!TB 
J 
!(TA ⊗ !TB)

⊗ !TB)
dTA⊗!TB 
!	! J  !


εTA⊗!TB⊗εTA⊗!TB 
J 

εTA⊗εTA⊗εTB 
J 
(10)

TA ⊗ !TB ⊗ TA ⊗ !TB 
T A⊗eTB⊗T A⊗εTB 
TA ⊗ TA ⊗ TB 
leftA,A⊗TB;leftA⊗A,B

J		 T ( A ⊗ J  B)
TA ⊗ TA ⊗ TB leftA,A⊗TB;leftA⊗A,B	A ⊗


T A⊗!TB⊗!(T A⊗!TB)   α	 !(T A⊗!TB) 	d	 !(T A⊗!TB)⊗!(T A⊗!TB)

T A⊗!TB⊗ε
J 
ε⊗ε
J 

T A⊗!TB ⊗ T A⊗!TB 
T A⊗e⊗T A⊗ε
J 
TA ⊗ TA ⊗ TB 
leftA,A⊗TB 
T A⊗!TB ⊗ T A⊗!TB 
T A⊗e⊗T A⊗ε
J 
TA ⊗ TA ⊗ TB 
leftA,A⊗TB 

(11)

J 
T (A ⊗
leftA⊗A,B T ( A ⊗ A ⊗ B) ¸lef,tA⊗A,B T (A ⊗ J TB 

commute, where εA : !A → A denotes the unit and dA : !A → !A ⊗ !A denotes the multiplication of the replication comonad ! while eA denotes the counit of the com- mutative comonoid !A. We let the reader check that the memory access strategy ξ satisfies the Diagrams (9) and (10) and that the strategy α satisfies the Diagram
(11). This enables us to define the memory cell as the strategy


cellA	d=ef
ξWrite!A,ReadA	◦	!const_cellA

Coarsely speaking, Diagram (9) states that the memory cell behaves as the constant cell on the first copy. Diagram (10) states that the copy in B are linked to the last opened copy of A. It is worth stressing here the crucial use of the strength of the monad T in order to express the order in which the different copies are opened and played.
At this point, there remains to show that the notion of memory access is sufficient to guarantee that the strategy cellA interpreting the memory cell, validates the five equations exhibited in the work of Abramsky, Honda and McCusker [2], see Figure
3. The first three equations are deduced from the same ingredients as for the linear or constant cell. Namely, we use properties of the tensor product and of the strong monad T .
Equation (4) is more difficult to derive, and follows essentially from Diagram (9). The proof is purely diagrammatic. The basic idea is to establish that for a unique assignment, the memory cell behaves as the constant memory cell, and then, to take advantage of the fact that we already know that the constant memory cell validates Equation (4). Technically speaking, the proof is based on the diagram
  !(f⊗const_cellA)  !(! A ⊗ Write  ⊗ !Read ) ξ!A⊗Write!A,ReadA !(! A ⊗ Write  ) ⊗ !Read


f⊗!const_cellA
J 
!A ⊗ !(Write

!(assignA⊗!ReadA )
J 



ξT 1,ReadA	 

!assignA⊗!ReadA
J 



!A⊗εWrite!A⊗!ReadA
!A ⊗ !ReadA)
!(T 1 ⊗ !ReadA)
εT 1⊗!ReadA
!T 1 ⊗ !ReadA
εT 1 ⊗εReadA

J		  J	J 

!A ⊗ Write!A ⊗ !ReadA assign
⊗!ReadA
T 1 ⊗ !ReadA
T 1 ⊗ ReadA

T 1⊗εReadA	left1,A
J 	  J 

T 1 ⊗ ReadA	left1,A
T ReadA

which is shown to commute for every morphism f : 1 → !A. The left top square commutes by naturality of the counit ε, the right top square commutes by naturality of the memory access ξ, and the bottom square commutes as an instance of Dia- gram (9). This diagram states that a single use of the assign or dereference method induces the same interactive behaviour for the memory cell as for the constant cell. Finally, Equation (5) follows essentially from our assumption that Diagram (10) commutes, which ensures that a memory cell always reads the last written value. Just as in the case of Equation (4), the proof is purely diagrammatic. The basic idea of the proof is to establish that for every pair of morphisms f, g : 1 → !A, whenever one assigns the value f and then the value g to the memory cell, and then one reads

the cell, one gets the value g. In order to establish this fundamental property, it appears convenient to introduce the morphism
ƒ a g	:	1	−→	!(!A ⊗ Write!A ⊗ !ReadA)


defined as
ƒ a g d=ef

(ƒ ⊗ const_cellA) ⊗ !(g ⊗ const_cellA); α!A⊗Write!A⊗!ReadA

in the category Fam(Conway−). The proof is based on the following diagram

ξ!A⊗WriteA,ReadA
1	f¢g	 !(! A ⊗ Write ⊗ !Read )	 !(! A ⊗ Write  ) ⊗ !Read
!A	A

f⊗g⊗!const_cellA
J 

!(assignA⊗!ReadA )
J 

!assignA⊗!ReadA
ξ	J 

!A ⊗ !A⊗
!(Write!A ⊗ !ReadA)
!A ⊗ !A⊗
!(T 1 ⊗ !ReadA

dT 1⊗!Read
) 	T 1,ReadA	 !T 1 ⊗ !Read

dT 1 ⊗!ReadA

dWrite!A
⊗!Read
A
A J	J	J 

!A ⊗ !A ⊗ Write!A ⊗ !ReadA
⊗Write!A ⊗ !ReadA
σ;assignA⊗assignA
J 
!(T 1 ⊗ !ReadA) ⊗ !(T 1 ⊗ !ReadA)
εT 1⊗!ReadA
⊗εT 1⊗!ReadA
J 
!T 1 ⊗ !T 1 ⊗ !ReadA

εTA⊗εTA⊗εReadA
J 

T 1 ⊗ !ReadA ⊗ T 1 ⊗ !ReadA
T 1 ⊗ eReadA
⊗T 1 ⊗ εReadA J 
T 1 ⊗ !ReadA ⊗ T 1 ⊗ !ReadA
T 1 ⊗ eReadA
⊗T 1 ⊗ εReadA J 
T 1 ⊗ T 1 ⊗ ReadA
left1,1 ⊗ ReadA;
left1,A
J 

T 1 ⊗ T 1 ⊗ ReadA	T 1 ⊗ T 1 ⊗ ReadA 	 Re adA
left1,1 ⊗ ReadA;
left1,A

which is shown to commute for every pair of morphisms ƒ and g: the right top square commutes by naturality of ξ, the right bottom square is an instance of Diagram (10) and we leave the reader check the left square postcomposed with the morphism
T 1 ⊗ T 1 ⊗ ReadA	left1,1⊗ReadA	 T 1  ⊗ ReadA	left1,A	 Re adA
commutes, this fact itself following from our assumption that Diagram (11) com- mutes.

Conclusion and future works
We have defined a compact closed category of games, equipped with a notion of well-bracketing. This category offers an alternative way to think of the fully abstract model of the call-by-value language with higher-order store defined by Abramsky, Honda and McCusker. One interesting point about our approach is that the treat- ment of the memory cell is done diagrammatically, thus avoiding the direct and somewhat uncomfortable definitions and proofs in the original paper. We use only a fragment of our linear type system, corresponding to the traditional notion of “bracket” in arena games. We believe that this offers an opportunity to refine the

type system of the original programming language, in order to integrate the hugely extended notion of control provided by linear logic. It would be also interesting to analyze the models defined by McCusker [18] and Murawski [21] in order to avoid the bad variable constructor mkvar in the definition of the language. More gener- ally, we believe that much remains to be done in order to understand the algebraic structure of memory in game semantics. Ideally, this algebraic analysis should con- nect the game models based on visible or thread-independent strategies studied in this paper, with the monadic approach to general references recently advocated by Tzevelekos [27] which is based on innocent strategies and a state monad defined by recursion on all types.

Acknowledgement
The two authors are grateful to Russ Harmer, Masahito Hasegawa, Martin Hyland and Luke Ong for stimulating discussions and encouragement.

References
S. Abramsky. Axioms for Deﬁnability and Full Completeness. MIT Press, 1999.
S. Abramsky, K. Honda, and G. McCusker. A fully abstract game semantics for general reference. In
13th IEEE Symposium on Logic in Computer Science. IEEE Computer Society Press, 1998.
S. Abramsky and M. Lenisa. Axiomatizing Fully Complete Models for ML Polymorphic Types. In Proceedings of the International Symposium on Mathematical Foundations of Computer Science, volume 1893. Springer Lecture Notes in Computer Science, 2000.
S. Abramsky and G. McCusker. Linearity, sharing and state: a fully abstract game semantics for idealized algol with active expressions, 1997.
Samson Abramsky and Guy McCusker. Call-by-value games. In Mogens Nielsen and Wolfgang Thomas, editors, 6th Annual Conference of the European Association for Computer Science Logic, volume 1414 of Lecture Notes in Computer Science. Springer, 1998.
Nick Benton. A mixed linear and non-linear logic: Proofs, terms and models. In 3th Annual Conference of the European Association for Computer Science Logic, volume 933 of LNCS, Poland, June 1995. Springer-Verlag.
G. Berry and P.-L. Curien. Sequential algorithms on concrete data structures. Theoretical Computer Science, 20:265–321, 1982.
Russ Harmer. Games and Full Abstraction for Nondeterministic Languages. PhD thesis, University of London, 2000.
Masahito Hasegawa. On traced monoidal closed categories. Mathematical Structures in Computer Science, 2008. Published online on 27 October 2008.
Martin Hyland and Luke Ong. On full abstraction for PCF: I, II and III. Information and Computation, 163(2):285–408, December 2000.
André Joyal. Remarques sur la théorie des jeux à deux personnes. Gazette des Sciences Mathématiques du Québec, 1(4):46–52, 1977. English version by Robin Houston.
André Joyal, Ross Street, and Domnic Verity. Traced monoidal categories. Mathematical Proceedings of the Cambridge Philosophical Society, 119(447-468):184, 1996.
Max Kelly and Miguel Laplaza. Coherence for compact closed categories. Journal of Pure and Applied Algebra, 19:193–213, 1980.
J. Laird. A categorical semantics of higher order store. In Proceedings, 9th Conference on Category Theory and Computer Science, 2002.

J Laird. A game semantics of names and pointers. Annals of Pure and Applied Logic, 2009.
Paul Blain Levy. Global state considered helpful. In Proceedings of Mathematical Foundations of Programming Semantics (MFPS 2008), Electronic Notes in Computer Science, volume 218, pages 241–259, 2008.
Peter May. Duality in bicategories and topological applications. A brief memorial talk for Saunders MacLane, april 2006. http://www.math.uchicago.edu/∼may/.
Guy McCusker. On the semantics of Idealized Algol without the bad variable constructor. Proceedings of Mathematical Foundations of Programming Semantics (MFPS 2003), Electronic Notes in Computer Science, 83, 2003.
Paul-André Melliès and Nicolas Tabareau. Resource modalities in game semantics. In 22th IEEE Symposium on Logic in Computer Science, pages 389–398, 2007.
Robin Milner. Action Calculi V: reflexive molecular forms. Unpublished, third draf, June 1994.
A.S. Murawski. Bad Variables Under Control. In 21th Annual Conference of the European Association for Computer Science Logic, 2007.
C.-H. L. Ong and S. Sanjabi. Fully abstract semantics of additive aspects by translation. In Proceedings of Sixth International Conference on Aspect-Oriented Software Development (AOSD 2007), 2007.
Paul-André Melliès and Nicolas Tabareau and Christine Tasson. An explicit formula for the free exponential modality of linear logic. In 36th International Colloquium on Automata, Languages and Programming (ICALP), 2009.
Uday Reddy. Global state considered unnecessary: An introduction to object-based semantics. Journal of Lisp and Symbolic Computation, 9:7–76, 1996.
John Reynolds. Syntactic control of interference. 5th ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 39–46, 1978.
Nicolas Tabareau. Modalités de ressources et contrôle en logique tensorielle. PhD thesis, Université Paris Diderot, 2008.
N. Tzevelekos. Full abstraction for nominal general references. In 22th IEEE Symposium on Logic in Computer Science, pages 399–410, 2007.
