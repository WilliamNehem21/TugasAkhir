

Electronic Notes in Theoretical Computer Science 267 (2010) 89–100
www.elsevier.com/locate/entcs
Quadtrees as an Abstract Domain
Jacob M. Howe1,4
Dept of Computing, City University London, UK
Andy King1,3,5 and Charles Lawrence-Jones2,6
School of Computing, University of Kent, Canterbury, UK

Abstract
Quadtrees have proved popular in computer graphics and spatial databases as a way of representing regions in two dimensional space. This hierarchical data-structure is flexible enough to support non-convex and even disconnected regions, therefore it is natural to ask whether this data-structure can form the basis of an abstract domain. This paper explores this question and suggests that quadtrees offer a new approach to weakly relational domains whilst their hierarchical structure naturally lends itself to representation with boolean functions.
Keywords: Weakly relational domains, abstract interpretation, quadtrees, boolean formulae.


Introduction
Program analyses based on abstract interpretation require an abstract domain. One of the first domains described was that of polyhedra [9] and recent work has inves- tigated subclasses of polyhedra, referred to as weakly relational domains (examples include [6,15,16,17,21]). The motivation for weakly relational domains is the cost of polyhedral domain operations: weakly relational domains restrict the dependen- cies between variables that can be expressed in order to achieve tractable domain operations whilst retaining sufficient expressivity to be useful.
This paper proposes a new abstract domain based on the well-known data- structure of quadtrees [11]. The domain belongs to the weakly relational domain

1 This work is supported by EPSRC projects EP/E033105/1 and EP/E034519/1.
2 Supported by a Nuffield Science Bursary
3 Partly supported by a Royal Society Industrial Fellowship
4 Email: jacob@soi.city.ac.uk
5 Email: a.m.king@kent.ac.uk
6 Email: clawrencejones@gmail.com


1571-0661© 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.09.008

family, but its representation is not given in terms of linear inequalities. The repre- sentation means that disjoint, non-linear and non-convex regions can be represented naturally, but this flexibility comes at a cost.
The paper is neutral as to the suitability of quadtrees for use in practical anal- ysers. It is a paper that aspires to promote discussion on the relationship between spatial abstractions and boolean formulae. Nevertheless, the paper makes the fol- lowing contributions:
introduces a weakly relational domain for analysis of machine integers that is based on quadtrees
discusses how this domain might be represented and details how this might be achieved using boolean formulae, either as binary decision diagrams [3] or as formulae in (non-canonical) conjunctive normal form [14]
The paper is structured as follows: section 2 recalls the definition of quadtrees and introduces the underlying idea of using them as an abstract domain; sections 3 and 4 formally introduce the domain and its operations; section 5 discusses the encoding of quadtrees using boolean data-structures and sections 6 and 7 conclude with a survey of related work and a discussion of the strengths and weaknesses of the new domain.

Quadtrees
A quadtree is a tree where each node has four children; it is interpreted as decompo- sition of a square in smaller squares, the root being the largest, containing square. A node corresponds to a square and its children to the four squares obtained by dividing the containing square evenly into four. Following [10] the child nodes are ordered anti-clockwise from the top right, as below:




NE	NW	SW	SE
In this work the interest is not only in the decomposition of a square into further squares, but in whether or not these squares are part of some region of interest. Therefore the leaves of quadtrees will be labelled with 0 or 1 to indicate whether or not the corresponding square is part of the region of interest.
Quadtrees are potentially infinite data-structures, as squares can be continually subdivided. However, this work, like others [19], is concerned with analysis over machine integers. This gives a smallest meaningful square, one that is 1 × 1. Later in this work quadtrees whose smallest square has a larger size will be considered. Henceforth, the minimum square size will be described by the log of its width

and this will be referred to as the granularity of the quadtree. For example, a quadtree with granularity 2 has minimum square size 4 × 4. A quadtree with a given granularity is then finite. Assuming that the granularity is a non-negative integer g, a quadtree with 2n × 2n root square has leaves at maximum depth n − g, where the root is considered to be depth zero.
Consider the following decomposition of an 8 × 8 grid into 1 × 1 cells, where the dark cells are the region of interest:

It can be represented by the following quadtree (with granularity 0):



0





0  1  1  1	1  0  1  1	1  1  0  1	0  0  1  0
The nature of this decomposition echoes BDDs that have been used to express disjunctive properties [8,13]. This link is further explored in section 5.

The Lattice of Quadtrees
This section formally introduces the lattice of quadtrees. The definition introduces quadtrees as purely spatial objects (in fact, divorcing them from their representation as trees) as this provides the most natural description of the lattice.
Quadtrees give a description of two dimensional collections of squares within a regular square grid. Each axis of the grid is intended to capture an analysis variable. There are, of course, likely to be many analysis variables, therefore the domain needs

to be able to capture some higher dimensional relationships as well. Although the quadtree domain elements are purely spatial, intuitively, these elements derive from collections of quadtrees, each quadtree in a collection being over a pair of variables. The pairs of variables are not necessarily disjoint, therefore the various quadtrees in a domain element interact via their intersection in higher dimensional space. The domain is weakly relation since the higher dimensional relationships are induced by two dimensional relationships over quadtrees.

Quadtrees
First, a spatial definition of quadtrees in two dimensions is given. This is then used as the basis of a definition for arbitrary dimensions.
Let X = {x1, ...xd} be a finite set of variables. Let I = [min, max) ⊂ Q denote an interval such that min, max ∈ Z and max = min + 2n for some n ∈ N. The starting point is the definition of Cn,i, where x, y ∈ X, the set of all squares
resulting from the decomposition of the I × I grid (whose axes are x and y) where the granularity is i. Cn,i is defined when i ≤ n by:
Ci,i = {{⟨x, y⟩| min ≤ x < min + 2i, min ≤ y < min + 2i}}
Cn,i = {{⟨x, y⟩| min ≤ x < min + 2n, min ≤ y < min + 2n}} ∪
n−1,i xy
{C + {⟨0, 2n−1⟩} | C ∈ Cn−1,i}	∪
{C + {⟨2n−1, 0⟩} | C ∈ Cn−1,i}	∪
{C + {⟨2n−1, 2n−1⟩} | C ∈ Cn−1,i}
where in the second case i < n and + denotes the Minkowski sum.
Now define Qn,i = {∪S | S ⊆ Cn,i}. That is, q	∈ Qn,i is a subset of I × I and
xy	xy	xy	xy
can be represented by a quadtree. The second superscript, i, will be omitted when it takes the value 0. Note that Qn,i could be defined directly, though a recursive formulation might be seen as more natural.
The next definition gives a spatial notion of quadtrees in higher dimensions. Define the projection of a d-dimensional object S onto variables xj, xk as follows, πjk(S) = {⟨aj, ak⟩ | ⟨a1, ..., ad⟩ ∈ S}. Now define the expansion of a two dimen-

sional quadtree as q+
= ∪{S | πjk
(S) = qxjxk
n,i xj xk
}. That is, qxy
n,i xy

is interpreted as an n-dimensional, rather than 2 dimensional, object by extending it through the other dimensions, analogous to a prism in three dimensions. Then

Qn,i = {∩m
q+ | m ≥ 1,q 
∈ Qn,i
for x ,x ∈ X, k /= l}. Hence, each q
∈ Qn,i is

X	j=1 j
j	xkxl	k	l	X	X

a subset of Id. Again, the granularity superscript i will be omitted when it is not necessary.

Meet, Join and Entailment
With the spatial definition of quadtrees, the remaining lattice operations are defined straightforwardly with set operations.

Let the ordering operation on Qn,i be defined by q1 |= q2 iff q1 ⊆ q2, that is, ordering is by inclusion. Let H, H denote the meet and join lattice operations. For q1, q2 ∈ Qn,i, q1 H q2 = q1 ∩ q2, q1 H q2 = q1 ∪ q2. Notice that Qn,i+1 ⊂ Qn,i.
X	X	X
To conclude, ⟨Qn,i, |=, H, H⟩ forms a finite lattice.

Representation and Operations
This section spells out how quadtrees can be represented in terms of their two dimensional projections. It then gives spatial definitions of the domain operations that reduce to operations on each two dimensional projection. However, there are several possibilities as to how a two dimensional quadtree might be realised, and this choice is delayed until the following section.


Representation
The definition of Qn


in section 3 defines elements of the domain as sets of points in

Id without reference to how these sets can be represented. As a weakly relational domain, the expectation is that the representation is in terms of the two variable projections of the space. The definition suggests that each domain element should

be represented by a set of quadtrees, qxjxk
n xj xk

A domain element qX ∈ Qn is represented by a set consisting of exactly one
qxy ∈ Qn  for each x, y ∈ X. Such a set, of size d(d — 1)/2, will be denoted S.
Define JS) = ∩{q+ | qxy ∈ S} so as to interpret a set S as a domain element. Note
that the same domain element can be represented by different sets.

Meet
With a set representation for domain elements, meet can be determined pair- wise on the individual quadtree components. Over a variable pair, meet is sim- ply intersection: define qxy H pxy = qxy ∩ pxy. This lifts to domain elements: where qX, pX ∈ Qn , and qX = JSq), pX = JSp), meet can be determined by qX H pX = J{qxy H pxy|x, y ∈ X, qxy ∈ Sq, pxy ∈ Sp}).

Variable Elimination
A resolution step tightens a two dimensional quadtree by taking account of the interaction of two others. Where, qxy ∈ Qn , qyz ∈ Qn , res(qxy, qyz) = ∩{pxz ∈
xy	yz
Qn | q+ ∩ q+ ⊆ p+ }, it follows that res(qxy, qyz) ∈ Qn .
xz	xy	yz	xz	xz
Variable elimination is then defined by updating each two variable projection with resolvants and removing all two variable projections over the variable to be eliminated. That is, where JS) = qX , Ey.qX = J{quv ∈ S | y /∈ {u, v}} ∪ {qxz ∩ res(qxy, qyz) | qxy, qyz, qxz ∈ S}).

Completion
Completion is the operation in weakly relational domains through which the various two dimensional projections in the representation communicate with each other. An element of the quadtree domain is complete if no two variable component can be tightened whilst leaving the higher dimensional quadtree unchanged. Formally, let
qX = JS). S is complete if whenever qX = JS') and qxy ∈ S, q' ∈ S' then qxy ⊆ q' .
Completion can be computed by recursively updating a representation S by S'. If qxy, qyz ∈ S, then S' = (S \ {qxz}) ∪ {qxz ∩ res(qxy, qyz)}. This rule is applied until any selection of qxy, qyz results in S' = S. Termination is ensured as the Qn
lattice is finite.
Completion is a crucial component of a number of domain operations as specified in this section. The application of meet does not require completion and variable elimination can be thought of as partial completion, whereas join and entailment re- quire the representation to be complete. However, it will be argued in section 5 that with boolean representations of quadtrees completion is an unnecessary operation.


Join
Suppose that JSq) = qX ∈ Qn , JSp) = pX ∈ Qn


and that Sp, Sq are complete. Then

X	X
join can be determined pairwise on the individual quadtree components. Over a variable pair, join is simply union: define qxy H pxy = qxy ∪ pxy. This lifts to domain elements: qX H pX = J{qxy H pxy|x, y ∈ X, qxy ∈ Sq, pxy ∈ Sp}).

Entailment
Entailment can be determined in terms of pairwise entailment on the individual quadtree components, but again completion is required. Suppose that JSq) = qX ∈
Qn , JSp) = pX ∈ Qn and that Sq is complete. Over a variable pair, entailment
X	X
is containment: qxy |= pxy if and only qxy ⊆ pxy. This lifts to domain elements:
qX |= pX if and only if qxy |= pxy for each {x, y}∈ X, qxy ∈ Sq, pxy ∈ Sp.

Abstraction
The abstraction of a set R ⊆ Id is given by α(R) = H{qX ∈ Qn |R ⊆ qX}. Concreti- sation is simply the identity. The weakly relational nature of quadtrees induces a loss of information for three (and higher) dimensional regions, as the following exam- ple illustrates. Suppose that R = (I ×I ×{min}) ∪ (I ×{min}×I) ∪ ({min}×I ×I). Then α(R) = I × I × I.
Abstraction is potentially expensive. Consider for example, a chessboard of 2n × 2n squares where the dark square are the region of interest. The quadtree describing this has maximum size, that is (4n+1 — 1)/3 nodes. This is potentially
problematic. However, this problem might be addressed in at least two ways. One approach is to restrict the granularity to throttle the size of the representation. The other, complementary, approach is to table commonly occurring programming constructs, allowing abstraction via lookup.

Assignment can be handled as in the TVPI domain [21] by introducing a fresh variable. Consider, for example, the assignment x := x+1. This becomes x' = x+1, which is abstracted and the meet of the result with the current domain element is calculated. x is then projected out and x' is renamed to x. Note the importance of variable elimination to this approach.

Widening

Note that QI  forms a finite lattice, hence widening is not strictly necessary to
enforce termination, even if fixpoint acceleration is desirable.
As noted by [13] the choice of widening is key to getting a domain to perform well in an analysis. One widening for quadtrees naturally suggests itself: increase the granularity as the number of iterations increases. Formally this is as follows (and is parameterised by a function associating an iterate with a granularity).
Suppose that JSq) = qX ∈ Qn , JSp) = pX ∈ Qn , where qX represents the jth
X	X
iterate of analysis and pX the (j + 1)th iterate. The expectation is that Sp, Sq are complete, although this is not strictly necessary. Over a variable pair, widening

is as follows: q  ∇p	= q	∪ (∩{r	| r
∈ Qn,k,p	\ q	⊆ r  }), where the

xy	xy	xy
xy	xy
xy	xy	xy	xy

granularity k is a history dependent value.  This then lifts to domain elements:
qX∇pX = J{qxy∇pxy | x, y ∈ X, qxy ∈ Sq, pxy ∈ Sp}).
Further discussion of widening quadtrees represented as booleans, or rather not doing so, is given in section 5.
Boolean Formulae for Quadtrees
Elements of the quadtrees domain can be represented easily by structures for boolean formulae. This section details the encoding of quadtrees into Binary Deci- sion Diagrams (BDDs) and formulae in conjunctive normal form (cnf), as well as discussing the implications of these encodings.
A quadtree over x and y, Qn , has associated with it 2n variables. That is, one variable for each dimension and each permitted square size. These variables will be referred to by xi and yi, where i is the power describing the width of the corresponding squares. It is important to note that when the same axis occurs in different quadtrees, the same boolean variables are used. Satisfying assignments over these variables then correspond to the region of interest described by a quadtree.
Quadtrees as BDDs
The encoding of a quadtree as a BDD is straightforward. The four children of a node in the quadtree become four leaves of a BDD over two variables. That is, the nodes correspond to (xi, yi) pairs as follows: NE to (1, 1), NW to (0, 1), SW to (0, 0), SE to (1, 0).
The quadtree in section 2 is represented by the following OBDD (reduction omitted for presentational purposes). The ordering is [x2, y2, x1, y1, x0, y0] and left

branches correspond to true.


0	0
0
0	0
1	1	1	0
0	1	0	1  1	0	0	1
A multi-rooted ROBDD will then describe a quadtree over many dimensions, exploiting structural similarity to obtain a compact representation.

Quadtrees as cnfs
The counterpart of the reduced disjunctive normal form of BDDs is conjunctive normal form, here not reduced. The clauses can be thought of as each describing a region of the grid not captured by the quadtree. That is, a counter-model to each clause describes a region not in the quadtree.
The following is the cnf describing the quadtree from section 2:

The various two dimensional projections give rise to cnf formulae and conjoining these gives a single cnf describing the higher dimensional quadtree.

Avoiding completion
Completion is an apparently crucial operations in weakly relational domains, and the treatment of quadtrees in section 4 is no different. However, notice that when a quadtree is represented by a boolean formula in cnf completion becomes less

compelling. Completion can easily be calculated by resolution steps, but these steps simply add redundent clauses to the representation. All of the domain operations can be performed by their logical equivalents at the level of cnf formulae without applying completion and it is not clear that completion leads to any computational advantage.
The same tactic can be applied with the BDD representation – simply take the conjunction of the two variable projections. However, note that since ROBDDs give a canonical representation this tactic corresponds to calculating the completion since completion aspires to a canonical representation.
In order to reflect on the two representations, consider their complexities. Both ROBDDs and cnf are have potentially exponentially large representations. The following tabulates complexity of the core domain operations (where N is the size of the input):

The gain by using cnf comes from the low complexity of conjunction, the re- sult of the non-canonical representation. This is offset by the cost of the entail- ment/equivalence and projection. Entailment for cnf is implemented by SAT solving and although of high theoretical complexity, SAT solving has been demonstrated to be surprisingly tractable on very large structured problems. Projection is impor- tant to this approach since it is required in the treatment of assignment and the relatively high cost of this operation might prove to be prohibitive. The answers to these performance questions are left open, but it is noted that implementation work for dependency analysis has demonstrated that cnf is an attractive representation [14].


Avoiding widening
As noted above, defining suitable widening operations is one of the most difficult tasks in numeric domains. Recent work [18] on the automatic derivation of transfer functions offers a promising way forward – it shows how least solutions to fixpoint equations can be derived symbolically by applying universal quantifier elimination over systems of linear inequalities. This finesses the need for widening. The tactic amounts to stating that the least solution both constitutes a solution and is smaller than every other solution (hence the need for universal qualification). The domain of quadtrees is ordered by entailment in its boolean encoding which suggests that forall elimination can be applied to directly compute least fixpoints without employing widening. This would provide a spatial analogue of immediate fixpoint calcula- tion [22], which has been applied to directly compute fixpoints over the domain of positive boolean functions.

Related Work
The work contained in this paper can be viewed as a weakly relational domain that is to finite powersets of intervals, as TVPI is to polyhedra. The use of finite powersets of intervals has received some attention recently. In [2] the authors are concerned with widenings for powerset domains in general, whilst in [20] the focus is on how to analyse across paths (something that powerset domains are well suited to) whilst retaining the more attractive computational properties belonging to the base domains owing to their path summarisation.
However, the closest work to that presented here is that of Gurfinkel and Chaki. In [4] LDDs are introduced. These are BDD like structures where nodes are inter- preted as linear inequalities, giving a decompostion of n-dimensional space into (a finite number of) regions of interest. In [13] a domain that corresponds to finite powersets of intervals is given. The domain is represented as LDDs (in fact, a re- striction of LDDs, since only single variable inequalities are required) leading to an attractive analysis that appears to scale.
A completely different approach to representing non-convex spaces is to use congruences as discussed in [1].
In the context of bounded model checking quadtrees have been used to model electrical fields [12] as part of a system to diagnose spirals of electrical activity indicating cardiac abnormalities. Note that spirals are particularly suited to the widening presented in section 4.8. Finally, the paper uses quadtrees with back arcs in order to define fractals, which suggests that quadtrees can have dense representation akin to BDDs with back arcs.

Discussion and future work
Quadtrees have a vast literature. They have been generalised to higher dimension (octrees) and applied in diverse applications. They do not necessarily have to rep- resent a square grid structure which offers another degree of expressive freedom. Exploiting the quadtree literature is one avenue of future work. In tandem with this existing implementations of quadtrees will be investigated for their suitabil- ity in program analysis. Theoretical questions such as optimality of the operators presented remain open, and such questions will be subject to further enquiry.
In [7] it is noted that successful analyses result, in part, from careful selection of component domains. This motivates research into new domains that might earn their place in the toolkit. It is not yet clear how effective quadtrees will be for program analysis, therefore the advantages and disadvantages of quadtrees are given by way of summary. Advantages include:
they are a weakly relational domain not based on inequalities
they can describe spaces that are not necessarily convex or linear
they can be encoded in propositional logic, allowing use of BDDs and SAT
they come with a natural form of widening, though their propositional link sug-

gests that widening may not be required at all
the granularity can be throttled to control the size of the representation
the technique does not inherit the problem of storing and manipulating large coefficients that often arise with linear inequalities [5].
Disadvantages include:
the data-structure is potentially large
it is not clear how to effectively deal with abstraction
the proposed widening is natural, but it is also crude and it is not clear how much information will be preserved.
Acknowledgement
The authors would like to thank Sagar Chaki and Arie Gurfinkel for making [13] available ahead of publication. They would also like to thank Karl Newman-Smart for discussion and his help with the diagrams. Finally they would like to thank the anonymous referees for helpful comments.

References
Bagnara, R., K. Dobson, P. M. Hill, M. Mundell and E. Zaffanella, Grids: A Domain for Analyzing the Distribution of Numerical Values, in: Logic-Based Program Synthesis and Transformation, Lecture Notes in Computer Science 4407 (2006), pp. 219–235.
Bagnara, R., P. M. Hill and E. Zaffanella, Widening Operators for Powerset Domains, International Journal on Software Tools for Technology Transfer 8 (2006), pp. 449–466.
Bryant, R., Symbolic Boolean Manipulation with Ordered Binary-Decision Diagrams, ACM Computing Surveys 24 (1992), pp. 293–318.
Chaki, S., A. Gurfinkel and O. Strichman, Decision Diagrams for Linear Arithmetic, in: International Conference on Formal Methods in Computer-Aided Design (2009), pp. 53–60.
Charles, P. J., J. M. Howe and A. King, Integer Polyhedra for Program Analysis, in: Algorithmic Aspects in Information and Management, Lecture Notes in Computer Science 5564 (2009), pp. 85–99.
Claris´o, R. and J. Cortadella, The Octahedron Abstract Domain, Science of Computer Programming
64 (2007), pp. 115–139.
Cousot, P., R. Cousot, J. Feret, L. Mauborgne, A. Min´e and X. Rival, Why does Astr´ee Scale Up?, Formal Methods in System Design 35 (2009), pp. 229–264.
Cousot, P., R. Cousot and L. Mauborgne, A Scalable Segmented Decision Tree Abstract Domain, in:
Z. Manna and D. Peled, editors, Pnueli Festschrift, Lecture Notes in Computer Science 6200 (2010),
pp. 72–95.
Cousot, P. and N. Halbwachs, Automatic Discovery of Linear Restraints among Variables of a Program, in: Principles of Programming Languages (1978), pp. 84–97.
de Berg, M., O. Cheong, M. Kreveld and M. Overmars, “Computational Geometry: Algorithms and Applications,” Springer, 2008, 3rd edition.
Finkel, R. A. and J. L. Bentley, Quad Trees: a Data Structure for Retrieval on Composite Keys, Acta Informaticae 4 (1974), pp. 1–9.
Grosu, R., S. A. Smolka, F. Corradini, A. Wasilewska, E. Entcheva and E. Bartocci, Learning and Detecting Emergent Behavior in Networks of Cardiac Myocytes, Communications of the ACM 52 (2009), pp. 97–105.

Gurfinkel, A. and S. Chaki, BOXES: A Symbolic Abstract Domain of Boxes, in: Static Analysis Symposium, Lecture Notes in Computer Science (2010), forthcoming.
Howe, J. M. and A. King, Positive Boolean Functions as Mulitheaded Clauses, in: International Conference on Logic Programming, Lecture Notes in Computer Science 2237 (2001), pp. 120–134.
Howe, J. M. and A. King, Logahedra: a New Weakly Relational Domain, in: Automated Technology for Verification and Analysis, Lecture Notes in Computer Science 5799 (2009), pp. 306–320.
Logozzo, F. and M. F¨ahndrich, Pentagons: a Weakly Relational Abstract Domain for the Efficient Validation of Array Accesses, in: ACM Symposium on Applied Computing (2008), pp. 184–188.
Min´e, A., The Octagon Abstract Domain, Higher-Order and Symbolic Computation 19 (2006), pp. 31– 100.
Monniaux, D., Automatic Modular Abstractions for Linear Constraints, in: Principles of Programming Languages (2009), pp. 140–151.
Mu¨ller-Olm, M. and H. Seidl, Analysis of Modular Arithmetic, Transactions on Programming Languages and Systems 29 (2007).
Sankaranarayanan, S., F. Ivanˇci´c, I. Shlyakhter and A. Gupta, Static Analysis in Disjunctive Numerical Domains, in: Static Analysis Symposium, Lecture Notes in Computer Science 4134 (2006), pp. 3–17.
Simon, A., A. King and J. M. Howe, Two Variables per Linear Inequality as an Abstract Domain, in: M. Leuschel, editor, Logic Based Program Development and Transformation, Lecture Notes in Computer Science 2664 (2002), pp. 71–89.
Søndergaard, H., Immediate Fixpoints and Their Use in Groundness Analysis, in: Foundations of Software Technology and Theoretical Computer Science, Lecture Notes in Computer Science 1180 (1996), pp. 359–370.
