	Electronic Notes in Theoretical Computer Science 188 (2007) 91–103	
www.elsevier.com/locate/entcs

Improving the Context-sensitive Dependency Graph
Beatriz Alarc´on, Rau´l Guti´errez, and Salvador Lucas 1 ,2
Departamento de Sistemas Informa´ticos y Computacio´n Universidad Polit´ecnica de Valencia
Valencia, Spain

Abstract
The dependency pairs method is one of the most powerful technique for proving termination of rewriting and it is currently central in most automatic termination provers. Recently, it has been adapted to be used in proofs of termination of context-sensitive rewriting. The use of collapsing dependency pairs i.e., having a single variable in the right-hand side is a novel and essential feature to obtain a correct framework in this setting. Unfortunately, dependency pairs behave as a kind of glue in the context-sensitive dependency graph which makes the cycles bigger, thus making some proofs of termination harder. In this paper we show that this effect can be safely mitigated by removing some arcs from the graph, thus leading to faster and easier proofs. Narrowing dependency pairs is also introduced and used here to eventually simplify the treatment of the context-sensitive dependency graph. We show the practicality of the new techniques with some benchmarks.
Keywords: Dependency pairs, term rewriting, program analysis, termination.


Introduction
Termination is one of the most interesting problems when dealing with context- sensitive rewrite systems. With context-sensitive rewriting (CSR [10,11]) we can achieve a terminating behavior with non-terminating Term Rewriting Systems (TRSs [14,15]), by pruning (all) infinite rewrite sequences. In CSR we only rewrite μ-replacing subterms. Here, μ is a replacement map, i.e., a mapping μ : F → P(N) satisfying μ(f ) ⊆ {1,... , k}, for each k-ary symbol f of the signature F [10]. We use them to discriminate the argument positions on which the rewriting steps are allowed. Then, ti is a μ-replacing subterm of f (t1,... , tk) if i ∈ μ(f ); every term t (as a whole) is μ-replacing by definition. For other subterms we proceed inductively

1 This work has been partially supported by the EU (FEDER) and the Spanish MEC, under grants TIN 2004-7943-C04-02 and HA 2006-0007, the Generalitat Valenciana under grant GV06/285, and the ICT for EU-India Cross-Cultural Dissemination ALA/95/23/2003/077-054 project. Beatriz Alarc´on was partially supported by the Spanish MEC under FPU grant AP2005-3399.
2 Email: {balarcon,rgutierrez,slucas}@dsic.upv.es

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.05.040

in this way. Then, for a given TRS, we obtain a restriction of rewriting which we call context-sensitive rewriting. Proving termination of CSR is an interesting problem with several applications in the fields of term rewriting and programming languages (see [5,6,8,11,13] for further motivation).
The dependency pairs method [1] is one of the most powerful techniques for prov- ing termination of rewriting. Roughly speaking, given a TRS R, the dependency pairs associated to R conform a new TRS DP(R) which (together with R) deter- mines the so-called dependency chains whose finiteness characterizes termination of R. The dependency pairs can be presented as a dependency graph, where the absence of infinite chains can be analyzed by considering the cycles in the graph. In [3], the dependency pairs method has been adapted to be used in proofs of termi- nation of CSR. The technique has been implemented in the tool mu-term [2,12]. Basically, the non-variable subterms in the right-hand sides of the rules which are considered to build the CS-dependency pairs must be μ-replacing terms. Neverthe- less such ‘standard’ dependency pairs do not suffice to obtain a correct method for proving termination of CSR.
Example 1.1 [3, Example 2] Consider the following TRS R:
a -> c(f(a))
f(c(X)) -> X
together with μ(c)= ∅ and μ(f)= {1}. There is no μ-replacing subterm s in the right-hand sides of the rules which is rooted by a defined symbol. Thus, there is no ‘standard’ dependency pair. We could wrongly conclude that R is μ-terminating, which is not true:
f(a) ‹→μ f(c(f(a))) ‹→μ f(a) ‹→μ ··· 

Indeed, as shown in [3], we must add the following dependency pair
F(c(X)) -> X
which would not be allowed in Arts and Giesl’s approach [1] because the right-hand side is a variable. In this paper, we call collapsing to such kind of dependency pairs. As in Arts and Giesl’s approach, the analysis of infinite sequences of context- sensitive dependency pairs can be made by looking at (the cycles C of) the context- sensitive dependency graph associated to the CS-TRS R. The nodes of the de- pendency graph are the dependency pairs in DP(R, μ). A disappointing aspect of collapsing context-sensitive dependency pairs (as F(c(X)) -> X above) is that they are connected to every other dependency pair in the context-sensitive dependency graph [3]. Intuitively, this is because the variable X in the right-hand side of the dependency pair could be instantiated to anything, thus being potentially able to
‘connect’ to every other dependency pair.
In this paper, we show that we can restrict the number of outcoming links of collapsing dependency pairs to dependency pairs headed by the so-called hidden symbols which are defined symbols that occur in non-replacing positions in the right-hand sides of some rule in the TRS. This leads to a new definition of the context-sensitive dependency graph which greatly improves the performance of the original method.

Example 1.2 Consider the following non-terminating TRS R which can be used to compute the list of prime numbers [7]: 
primes -> sieve(from(s(s(0))))	tail(cons(X,Y)) -> Y
from(X) -> cons(X,from(s(X)))	if(true,X,Y) -> X
head(cons(X,Y)) -> X	if(false,X,Y) -> Y
filter(s(s(X)),cons(Y,Z)) -> if(divides(s(s(X)),Y),filter(s(s(X)),Z),cons(Y,filter(X,sieve(Y))))
sieve(cons(X,Y)) -> cons(X,filter(X,sieve(Y)))
together with μ(cons) = μ(if) = {1} and μ(f ) = {1,... , ar(f )} for any other symbols f . No (automatic or manual) proof of termination for this CS-TRS has been reported to date. By using the dependency graph as defined in [3] we were not able to find a proof with mu-term 4.3 [2].
In contrast, with the new definition in this paper, we have no cycles! Thus, a direct (and automatic) proof of μ-termination of R is easy now.
Narrowing dependency pairs was also introduced by Arts and Giesl to im- prove the efficiency of the dependency pairs technique in proofs of termination [1]. Roughly speaking, under some conditions, a dependency pair can be replaced by a set of pairs which could simplify or restructure the dependency graph and eventually simplify the proof of termination. We also investigate this technique for dealing with the context-sensitive dependency graph.
After some preliminary definitions in Section 2, Section 3 introduces the notion of hidden symbol and investigates its properties in proofs of termination of CSR. Section 4 shows how to use it to improve the context-sensitive dependency graph. Section 5 adapts narrowing of dependency pairs to context-sensitive dependency pairs. Section 6 provides an experimental evaluation of our techniques. Section 7 concludes.

Preliminaries
Throughout the paper, X denotes a countable set of variables and F denotes a signature, i.e., a set of function symbols {f, g,.. .}, each having a fixed arity given by a mapping ar : F → N. The set of terms built from F and X is T (F , X ). Positions p, q,... are represented by chains of positive natural numbers used to address subterms of t. Given positions p, q, we denote its concatenation as p.q. If p is a position, and Q is a set of positions, p.Q = {p.q | q ∈ Q}. We denote the empty chain by Λ. The set of positions of a term t is Pos(t). The subterm at position p of t is denoted as t|p and t[s]p is the term t with the subterm at position p replaced by s. We write t o s if s = t|p for some p ∈ Pos(t) and t D s if t o s and t /= s. The symbol labelling the root of t is denoted as root(t). A context is a term C ∈T (F ∪ { }, X ) with zero or more ‘holes’  (a fresh constant symbol).
A rewrite rule is an ordered pair (l, r), written l → r, with l, r ∈ T (F , X ), l /∈ X and Var(r) ⊆ Var(l). The left-hand side (lhs) of the rule is l and r is the right-hand side (rhs). A TRS is a pair R = (F , R) where R is a set of rewrite rules. Given R = (F , R), we consider F as the disjoint union F = C D of symbols c ∈ C, called constructors and symbols f ∈ D, called deﬁned functions, where

D = {root(l) | l → r ∈ R} and C = F − D.

Context-sensitive rewriting.
A mapping μ : F → P(N) is a replacement map (or F -map) if ∀f ∈ F , μ(f ) ⊆
{1,... , ar(f )} [10]. Let MF be the set of all F -maps (or MR for the F -maps of a TRS (F , R)). A binary relation R on terms is μ-monotonic if t R s implies f (t1,... , ti−1, t,... , tk) Rf (t1,... , ti−1, s,... , tk) for every t, s, t1,... , tk ∈T (F , X ).
The set of μ-replacing positions Posμ(t) of t ∈T (F , X ) is: Posμ(t)= {Λ}, if t ∈X 

and Posμ(t)= {Λ}∪ 

i∈μ(root(t))
i.Posμ(t|i), if t /∈ X . The set of replacing variables

of t is Varμ(t) = {x ∈ Var(t) | ∃p ∈ Posμ(t), t|p = x}. The μ-replacing subterm relation oμ is given by t oμ s if there is p ∈ Posμ(t) such that s = t|p. We write t Dμ s if t oμ s and t /= s. In context-sensitive rewriting (CSR [10]), we (only) contract replacing redexes: t μ-rewrites to s, written t ‹→μ s (or t ‹→R,μ s), if
t →R s and p ∈ Posμ(t). A TRS R is μ-terminating if ‹→μ is terminating. A term
t is μ-terminating if there is no infinite μ-rewrite sequence t = t1 ‹→μ t2 ‹→μ ··· ‹→μ tn ‹→μ ··· starting from t. A pair (R, μ) where R is a TRS and μ ∈ MR is often called a CS-TRS.

Dependency pairs.
Given a TRS R = (F , R) = (C  D, R) a new TRS DP(R) = (F , D(R)) of
dependency pairs for R is given as follows: if f (t1,... , tm) → r ∈ R and r = C[g(s1,... , sn)] for some defined symbol g ∈ D and s1,... , sn ∈ T (F , X ), then f (t1,... , tm) → g (s1,... , sn) ∈ D(R), where f and g are new fresh symbols (called tuple symbols) associated to defined symbols f and g respectively [1]. Let D be the set of tuple symbols associated to symbols in D and F = F∪D . As usual, for t = f (t1,... , tk) ∈T (F , X ), we write t to denote the marked term f (t1,... , tk). Conversely, given a marked term t = f (t1,... , tk), where t1,... , tk ∈T (F , X ), we write tq to denote the term f (t1,... , tk) ∈T (F , X ). Given T ⊆T (F , X ), let T be the set {t | t ∈ T }.

Structure of infinite μ-rewrite sequences
Let M∞,μ be a set of minimal non-μ-terminating terms in the following sense: t belongs to M∞,μ if t is non-μ-terminating and every strict μ-replacing subterm s of t (i.e., t Dμ s) is μ-terminating. Obviously, if t ∈ M∞,μ, then root(t) is a defined symbol. Furthermore, since μ-terminating terms are preserved under μ-rewriting, it follows that M∞,μ is also preserved under inner μ-rewritings.
>є
Lemma 3.1 Let R be a TRS and μ ∈ MR. Let t ∈ M∞,μ. If t ‹→∗ s, then
s ∈ M∞,μ.
The following proposition establishes that, given t ∈ M∞,μ, there are two ways for an infinite μ-rewrite sequence to proceed. The first one is by using ‘visible’ parts of the rules which correspond to μ-replacing subterms in the right-hand sides which

are rooted by a defined symbol. The second one is by showing up ‘hidden’ non-μ- terminating subterms which are activated by migrating variables in a rule l → r, i.e., variables x ∈ Varμ(r) −Varμ(l) which are not μ-replacing in the left-hand side l but become μ-replacing in the right-hand side r.
Proposition 3.2 [3] Let R = (C D, R) be a TRS and μ ∈ MR. For all t ∈ M∞,μ, there exist l → r ∈ R, a substitution σ and a term u ∈ M∞,μ such that
>є	є
t ‹→∗ σ(l) → σ(r) oμ u and either (1) there is a μ-replacing subterm s of r such that
u = σ(s), or (2) there is x ∈ Varμ(r) − Varμ(l) such that σ(x) oμ u.
Now we investigate the structure of such sequences in more detail. In the fol-
lowing, we write t D/μ s to denote that s is a non-replacing (hence strict!) subterm of t: t D/μ s if there is p ∈ Pos(t) − Posμ(t) such that s = t|p.
Definition 3.3 [Hidden symbol] Let R = (F , R) be a TRS and μ ∈ MR. We say
that f ∈ F is a hidden symbol if there is a rule l → r ∈ R and t ∈ T (F , X ) such that r D/μ t and root(t) = f . Let H(R, μ) (or just H, if R and μ are clear for the
context) be the set of all hidden symbols in (R, μ).
Lemma 3.4 Let R = (F , R) be a TRS and μ ∈ MR. Let t ∈T (F , X ) and σ be a substitution. If there is a rule l → r ∈ R such that σ(l) ф t and σ(r) D/μ t, then there
is no x ∈ Var(r) such that σ(x) o t. Furthermore, there is a term t' ∈ T (F , X )
such that r D/μ t', σ(t')= t and root(t)= root(t') ∈ H.
Proof. By contradiction. If there is x ∈ Var(r) such that σ(x) o t, then since
variables in l are always below some function symbol we have σ(l) D t, leading to a contradiction.
Since there is no x ∈ Var(r) such that σ(x) o t but we have that σ(r) D/μ t, then there is a non-variable and non-replacing position p ∈ PosF (r) −Posμ(r), such that
root(r|p)= root(t) ∈ H(R, μ) and σ(r|p)= t. Then, we let t' = r|p.	 
The following lemma establishes that minimal non-μ-terminating and non-μ- replacing subterms occurring in a μ-rewrite sequence involving only minimal terms directly come from the first term in the sequence or are rooted by a hidden symbol.
Lemma 3.5 Let R = (F , R) be a TRS and μ ∈ MR. Let A be a ﬁnite μ-rewrite sequence t1 ‹→ t2 ‹→ ··· ‹→ tn with ti ∈ M∞,μ for all i, 1 ≤ i ≤ n and n ≥ 1. If there is a term t ∈ M∞,μ such that t1 ф t and tn D/μ t, then root(t) ∈ H.
Proof. By induction on n:
If n = 1, then it is vacuously true.
If n > 1, then we assume that t1 ф t and tn D/μ t. Let l → r ∈ R be such that
tn−1 = C[σ(l)] and tn = C[σ(r)] for some context C[ ]. We consider two cases:
either tn−1 D/μ t holds or not.
If tn−1 D/μ t, then by the induction hypothesis we have that root(t) ∈ H.
If tn−1 D/μ t does not hold, then one of the following cases holds:
tn−1 Dμ t; then tn−1 ∈ M∞,μ implies that t ∈/ M∞,μ, leading to a contra-
diction.

tn−1 ф t (in particular, σ(l) ф t); then, since tn D/μ t there must be
σ(r) D/μ t. Thus, by Lemma 3.4 we conclude that root(t) ∈ H.
Now we use the previous lemmas to investigate infinite sequences that mix μ- rewriting steps on minimal non-μ-terminating terms and the extraction of such subterms as μ-replacing subterms of (instances of) right-hand sides of rules.
Proposition 3.6 Let R = (F , R) be a TRS and μ ∈ MR. Let A be an inﬁnite
є	'  >є	є	>є
sequence of the form t1 → s1 oμ t2 ‹→∗ t2 → s2 oμ t' ‹→∗ t3 ··· with ti, t' ∈ M∞,μ
3	i
for all i ≥ 1. If there is a term t ∈ M∞,μ such that ti D/μ t for some i ≥ 1, then
root(t) ∈H ∩ D or t1 D/μ t.
Proof. By induction on i:
If i = 1, it is trivial.
If i > 1 and ti D/μ t, then we consider two cases: either ti−1 D/μ t holds or not.
If ti−1 D/μ t, then by the induction hypothesis we get t1 D/μ t or root(t) ∈
H∩ D, as desired.
If ti−1 D/μ t does not hold, then let l → r ∈ R be such that ti−1 = σ(l) and
si−1 = σ(r) oμ t'. We consider two cases:
if ti−1 Dμ t then being ti−1 ∈ M∞,μ it would imply that t ∈/ M∞,μ, thus leading to a contradiction.
If ti−1 ф t, then we consider two cases: either t' D t or t' ф t.
i	i
If t' D t, since t' ,t ∈ M∞,μ the case t' Dμ t is excluded and the only
i	i	i
possibility is that t' Dμ t. Then, since σ(l)= ti−1 ф t and σ(r) oμ t' Dμ t,
i	/	i	/
i.e. σ(r) D/μ t, by Lemma 3.4 we conclude that root(t) ∈ H. Since
t ∈ M∞,μ, we have root(t) ∈H ∩ D
If t' ф t, then, by applying Lemma 3.1 and Lemma 3.5 to the μ-rewrite
>є
sequence t' ‹→∗ti we conclude root(t) ∈H ∩ D.

As an immediate consequence of Proposition 3.6, we have the following result which we will use later.
Corollary 3.7 Let (R, μ) be a CS-TRS, A be an inﬁnite sequence of the form
є	'  >є	є	>є
t1 → s1 oμ t2 ‹→∗ t2 → s2 oμ t' ‹→∗ t3 ··· with ti, t' ∈ M∞,μ for all i ≥ 1. If there is
a term t ∈ M∞,μ such that ti D/μ t for some i ≥ 1 and root(t) ∈ D − H, then t1 D/μ t.
Revised context-sensitive dependency graph
Proposition 3.2 motivates the definition of context-sensitive dependency pair(s) and chain of context-sensitive dependency pairs.
Definition 4.1 [CS-dependency pairs [3]] Let R = (F , R)= (C D, R) be a TRS and μ ∈ MR.  We define DP(R, μ) = DPF (R, μ) ∪ DPX (R, μ) to be the set of

context-sensitive dependency pairs (CS-DPs) where:
DPF (R, μ)= {l → s | l → r ∈ R, r oμ s, root(s) ∈ D,l / Dμ s}
and DPX (R, μ)= {l → x | l → r ∈ R, x ∈ Varμ(r) −Varμ(l)}. We extend μ ∈ MF
into μ ∈ MF  by μ (f )= μ(f ) if f ∈ F, and μ (f )= μ(f ) if f ∈ D.
Example 4.2 Consider the CS-TRS (R, μ) in Example 1.2. There are six context- sensitive dependency pairs:
1: PRIMES -> SIEVE(from(s(s(0))))
2: PRIMES -> FROM(s(s(0)))
3: TAIL(cons(X,Y)) -> Y
4: IF(true,X,Y) -> X
5: IF(false,X,Y) -> Y
6: FILTER(s(s(X)),cons(Y,Z)) ->
IF(divides(s(s(X)),Y),filter(s(s(X)),Z),cons(Y,filter(X,sieve(Y))))
Note the three collapsing dependency pairs: (3), (4), and (5).
Definition 4.3 [Chain of CS-DPs [3]] Let (R, μ) be a CS-TRS. Given P ⊆ DP(R, μ), an (R, P, μ )-chain is a finite or infinite sequence of pairs ui → vi ∈ P, for i ≥ 1 such that there is a substitution σ satisfying both:
σ(vi) ‹→∗	  σ(ui+1), if ui → vi ∈ DPF (R, μ), and
R,μ
if ui → vi = ui → xi ∈ DPX (R, μ), then there is si ∈ T (F , X ) such that
σ(xi) oμ si and s ‹→∗	σ(ui+1).
i	R,μ 
Here, as usual we assume that different occurrences of dependency pairs do not share any variable (renamings are used if necessary). An (R, P, μ )-chain is called minimal if for all i ≥ 1 σ(ui)q ∈ M∞,μ, si ∈ M∞,μ (whenever they occur in the chain) and all dependency pairs in P occur infinitely often.
Remark 4.4 When an (R, DP(R, μ), μ )-chain is written for a given substitution σ, we write σ(u) ‹→DP(R,μ),μ σ(v) for steps which use a dependency pair u → v ∈ DPF (R, μ) but we rather write σ(u) ‹→DP(R,μ),μ s for steps which use a dependency pair u → x ∈ DPX (R, μ), where s is as in Definition 4.3.
Theorem 4.5 (Correctness and completeness [3]) Let R be a TRS and μ ∈
MR. R is μ-terminating if and only if there is no inﬁnite (R, DP(R, μ), μ )-chain.
An essential aspect of the mechanization of the dependency pairs approach is the analysis of infinite sequences of dependency pairs by looking at (the cycles C of) the dependency graph associated to the TRS R. In [3],he context-sensitive dependency graph, is defined as follows:
There is an arc from a dependency pair u → v ∈ DPF (R, μ) to a dependency
pair u' → v' ∈ DP(R, μ) if there is a substitutions σ such that σ(v) ‹→∗

σ(u').
R,μ

There is an arc from a dependency pair u → v ∈ DPX (R, μ) to each dependency pair u' → v' ∈ DP(R, μ).
Connecting each collapsing dependency pair with every other dependency pair

makes the cycles bigger, thus making some proofs of termination harder. Thanks to the results in the previous section, we can prove the following.
Theorem 4.6 There is no inﬁnite minimal (R, P, μ )-chain involving an inﬁnite number of dependency pairs ui → vi ∈ DPX (R, μ) such that root(ui+1)q /∈ H.
Proof. By contradiction. Let A be an infinite (R, P, μ )-minimal chain of CS-DPs characterized by the CS-DPs ui → vi for i ≥ 1:
є	∗	є	∗


where, s 
σ(u1) ‹→P s1 ‹→R σ(u2) ‹→P s2 ‹→R ··· 
= σ(vi) if ui → vi ∈ DPF (R, μ) and σ(xi) oμ si if ui → vi = ui →

xi ∈ DPX (R, μ). Let I be the infinite set of indices satisfying that for all i ∈ I, ui → vi ∈ DPX (R, μ) and root(ui+1)q /∈ H. Given i ∈ I, let η(i) be the ‘next’ positive integer in I: η(i)= min({j ∈ I | j > i}). Obviously, for all i ∈ I, η(i) ∈ I. Now consider the following sequence Aq which is obtained from A by ‘unsharping’ the tuple symbols and using the rules li → ri which originate the dependency pairs ui → vi which are used in A:
q  є	∗	q  є	∗
σ(u1) ‹→R σ(r1) oμ s1 ‹→R σ(u2) ‹→R σ(r2) oμ s2 ‹→R ··· 
which corresponds to A above: by minimality of A (see Definition 4.3), we have that σ(ui)q, si ∈ M∞,μ for all i ≥ 1. By definition of I, for all i ∈ I, vi = xi ∈ X . By definition of collapsing dependency pair, xi ∈ Pos(ui) − Posμ(ui) and σ(xi) oμ si. Thus, σ(ui) D/μ si for all i ∈ I. By repeatedly applying Corollary 3.7, we have that
σ(ui) D/μ σ(uy(i)), i.e., σ(ui) D σ(uy(i)) for all i ∈ I. Thus, we obtain an infinite
D-sequence which contradicts well-foundedness of D.	 
As a consequence of this result, we can dismiss the arcs of the dependency graph which connect collapsing dependency pairs u → v and dependency pairs u' → v' such that root(u')q /∈ H. This leads to a new definition of the context-sensitive dependency graph:
Definition 4.7 [Context-Sensitive Dependency Graph] Let R be a TRS and μ ∈ MR. The context-sensitive dependency graph consists of the set DP(R, μ) of context-sensitive dependency pairs together with arcs which connect them as fol- lows:
There is an arc from a dependency pair u → v ∈ DPF (R, μ) to a dependency
pair u' → v' ∈ DP(R, μ) if there is a substitutions σ such that σ(v) ‹→∗

σ(u').
R,μ

There is an arc from a dependency pair u → v ∈ DPX (R, μ) to a dependency pair u' → v' ∈ DP(R, μ) if root(u')q ∈ H(R, μ).
Example 4.8 Consider again the TRS R in Example 1.2. The hidden defined symbols are filter, from and sieve. The dependency graph which corresponds to this example is shown in Figure 1 (right). Note that, in contrast to the situation


	
Fig. 1. Dependency graphs for Example 1.2: according to [3] (left) and according to Definition 4.7 (right)


with the old dependency graph (Figure 1, left) the new dependency graph has no
cycle!

As noticed by Arts and Giesl, the presence of an infinite chain of dependency pairs corresponds to a cycle in the dependency graph (but not vice-versa). In the dependency graph this is true in the following sense: for each infinite chain of dependency pairs there is a suffix of the chain which corresponds to a cycle in the new dependency graph.
On the other hand, the treatment of cycles of the context-sensitive dependency graph for concluding termination by means of orderings remains as described in [3], but using the dependency graph in Definition 4.7.

Example 4.9 Consider the following TRS R [16, Example 4]
f(X) -> cons(X,f(g(X))) g(0) -> s(0)
g(s(X)) -> s(s(g(X)))
sel(0,cons(X,Y)) -> X sel(s(X),cons(Y,Z)) -> sel(X,Z)
with μ(0)= ∅, μ(f)= μ(g)= μ(s)= μ(cons)= {1}, and μ(sel)= {1, 2}. Then,
DP(R, μ) is:
G(s(X)) -> G(X) SEL(s(X),cons(Y,Z)) -> SEL(X,Z)
SEL(s(X),cons(Y,Z)) -> Z
The set of hidden symbols is H = {f, g} and there are two cycles:
G(s(X)) -> G(X)
SEL(s(X),cons(Y,Z)) -> SEL(X,Z)
By using the subterm criterion [3, Section 5] we can easily prove that the system is
μ-terminating.

Narrowing context-sensitive dependency pairs
There are examples where the automation of the CS-DP method can fail or be more difficult due to the estimation of the arcs that connect two CS-dependency pairs (by means of functions Capμ and Renμ, see [3]).
Example 5.1 Consider the following example [13, Proposition 7]
f(0) -> cons(0,f(s(0)))
f(s(0)) -> f(p(s(0))) p(s(X)) -> X
together with μ(f)= μ(p)= μ(s)= μ(cons)= {1} and μ(0)= ∅. Then DP(R, μ) is:
F(s(0)) -> F(p(s(0)))
F(s(0)) -> P(s(0))
The estimated CS-dependency graph contains one cycle consisting of the CS-depen- dency pair
F(s(0)) -> F(p(s(0)))
However, this cycle does not belong to the CS-dependency graph because there is no way to μ-rewrite F(p(s(0))) into F(s(0))!
The problem is that with the estimated CS-dependency graph, we connect more dependency pairs than needed. The over-estimation eventually comes when a CS- dependency pair u → v is is connected to u' → v' in the estimated dependency graph and v and u' do not unify, i.e. at least a rewriting step with some rule of R is needed to reduce (some instance of) v to (the corresponding instance of) u'. It is then possible that, after performing such a necessary μ-rewriting step, the connection between them gets clearly lost, i.e, the nodes were not really connected in the graph. This is missed in the estimated dependency graph due to the use of Capμ and Renμ. We can use context-sensitive narrowing to avoid this problem.
Definition 5.2 [Context-sensitive narrowing [10]] Let (R, μ) be a CS-TRS. A term t μ-narrows to a term s (written t ~μ s ), if there exists a non-variable position p ∈ Posμ(t), θ is the most general unifier of t|p and l for a rewrite rule l → r in R (sharing no variable with t), and s = θ(t[r]p).
To achieve more precision when connecting two CS-DPs in a (R, DP(R, μ), μ )- chain, we may perform all possible μ-narrowings steps on v in order to develop the reductions from (instances of) v to (instances of) u'.Then, we obtain new terms v1,
.. ., vn which are μ-narrowings of v with unifier θi for i ∈ {1,... , n} and can be used instead of v. Not only the right-hand sides of the CS-dependency pairs are μ-narrowed: the unifier which used in the narrowing step should also be applied on the left-hand sides of the μ-narrowed pairs. Therefore, we can replace a CS- dependency pair u → v by all new μ-narrowed pairs θ1(u) → v1,... , θn(u) → vn. The next result shows that under those conditions, the set of CS-dependency pairs can be replaced by their narrowings without losing correctness or completeness.

Theorem 5.3 (Narrowing refinement for CS-termination) Let R be a TRS and let P be a set of CS-dependency pairs. Let u → v ∈P such that v is linear and for all u' → v' ∈ P (with renamed variables) the terms v and u' are not uniﬁable. Let
P' = (P− {u → v}) ∪ {u' → v' | u' → v' is a narrowing of u → v}.
There exists an inﬁnite (R, P, μ )-chain iff there exists an inﬁnite (R, P', μ )- chain.
Proof. The proof of this theorem corresponds to the proof of Theorem 25 in [1]
. Note that only dependency pairs in DPF (R, μ) can be narrowed. As in Arts and Giesl’s proof, requiring the no-unification between the CS-dependency pair to narrow and the rest of the set; the linearity of v; and the renaming of the variables of the different (occurrences of) dependency pairs is still necessary to guarantee that narrowing CS-dependency pairs do not miss any chain from P. The main difference is that the reductions between dependency pairs are μ-reductions, but since we are using μ-narrowing, the whole proof is adapted without loss of generality.	 
Thus, after narrowing the dependency pairs in DP(R, μ) we can build a narrowed
dependency graph. Afterwards, we can use it to check termination as usual.
Example 5.4 (Continuing Example 5.1) Since the right-hand side of the CS-de- pendency pair in Example 5.1 does not unify with any left-hand side of a dependency pair, (including itself) and it can be μ-narrowed at position 1 (notice that μ(f)={1}) by using the rule
p(s(X)) -> X
we can replace it by its μ-narrowed CS-dependency pair:
F(s(0)) -> F(0)
The narrowed pair does not form any cycle in the estimated narrowed graph and termination is easily proved now.

Experiments
The techniques described in the previous sections have been implemented as part of the tool mu-term [2,12]. We have used our new implementation to compare

with the last version of the tool:
mu-term 4.3. The benchmarks were executed

in a completely automatic way (see [2] for a description of mu-term’s termination expert) and with a timeout of 1 minute on the 90 examples in the Context-Sensitive Rewriting subcategory of the 2006 Termination Competition, available through the URL:
http://www.lri.fr/∼marche/termination-competition/2006
As remarked above, our termination expert works as explained in [2] for version
4.3 of mu-term. For the new version 4.4 of mu-term, we have just used the new definition of the (eventually narrowed) dependency graph. We have compared our new implementation with the previous version of mu-term (corresponding to [3]).


Table 1

We have also used AProVE for proving termination of the examples. AProVE [9] is currently the most powerful tool for proving termination of TRSs and implements most existing results and techniques regarding DPs and related techniques. AProVE is also able to prove termination of Context-Sensitive Rewriting by using transfor- mations. Such transformations obtain a proof of the μ-termination of a TRS R as
a proof of termination of a transformed TRS Rμ (where Θ represents the transfor-
μ
mation). If we are able to prove termination of RΘ (using the standard methods),
then the μ-termination of R is ensured (see [13] for a recent survey).
A complete account of our experiments can be found here:
http://www.dsic.upv.es/∼rgutierrez/muterm/prole/benchmarks.html
Table 1 summarizes our bechmarks. As shown in Table 1, the results make clear the advantages of the new refinement: we are able to prove 10 additional examples and the proofs are almost three times faster (in the average).
Furthermore, we can say that the new refinement developed for the CS-DP approach greatly improves on the use of other techniques: the use of transformations and other (also powerful) techniques like CSRPO [4] becomes now anecdotic or null.

Conclusions
We have introduced a simplification of the context-sensitive dependency graph by restricting the outcoming links of collapsing dependency pairs to dependency pairs headed by the so-called hidden symbols. Hidden symbols are defined symbols that occur in non-replacing positions in the right-hand sides of some rule in the TRS. This greatly improves the performance of termination proofs based on the dependency graph proposed in [3]. Narrowing context-sensitive dependency pairs has also been investigated. It can also be helpful to simplify or restructure the dependency graph and eventually simplify the proof of termination. Regarding the practical use of the (refinements on the) new CS-dependency graph in proofs of termination of CSR, we have implemented these ideas as part of the termination tool mu-term and we have obtained quite good results in terms of new examples which could be proved, and also regarding the time for achieving the proofs.
Since the state-of-the-art of DP-based techniques for proving termination of CSR which has been introduced in this paper corresponds to the developement of DPs in the late nineties, we can conclude that further improvements of CS- DPs will evolve in such a way that the CS-dependency pairs approach can play for CSR the (practical and theoretical) role than dependency pairs play in rewriting.

Many other aspects of the dependency pairs approach are also worth to be con- sidered and extended to CSR (modularity issues, innermost computations, usable rules,. . . ). They provide an interesting subject for future work.

References
T. Arts and J. Giesl. Termination of Term Rewriting Using Dependency Pairs Theoretical Computer Science, 236:133-178, 2000.
B. Alarc´on, R. Guti´errez, J. Iborra, and S. Lucas. Proving Termination of Context-Sensitive Rewriting with MU-TERM. Electronic Notes in Theoretical Computer Science, to appear, 2007.
B. Alarc´on, R. Guti´errez, and S. Lucas. Context-Sensitive Dependency Pairs. In N. Garg and S. Arun- Kumar, editors Proc. of the 26th Conference on Foundations of Software Technology and Theoretical Computer Science, FSTTCS’06, LNCS 4337:297-308, Springer-Verlag, Berlin, 2006.
C. Borralleras, S. Lucas, and A. Rubio. Recursive Path Orderings can be Context-Sensitive. In A. Voronkov, editor Proc. of 18th International Conference on Automated Deduction, CADE’02, LNAI 2392:314-331, Springer-Verlag, Berlin, 2002.
F. Dura´n, S. Lucas, J. Meseguer, C. March´e, and X. Urbain. Proving Termination of Membership Equational Programs. In P. Sestoft and N. Heintze, editors, Proc. of PEPM’04, pages 147-158, ACM Press, New York, 2004.
F. Dur´an, S. Lucas, J. Meseguer, C. March´e, and X. Urbain. Proving Operational Termination of Membership Equational Programs. Higher-Order and Symbolic Computation, to appear, 2006.
J. Giesl and A. Middeldorp. Transforming Context-Sensitive Rewrite Systems. In P. Narendran and M. Rusinowitch, editors, Proc. of 10th International Conference on Rewriting Techniques and Applications, RTA’99, LNCS 1631:271-285, Springer-Verlag, Berlin, 1999.
J. Giesl and A. Middeldorp. Transformation techniques for context-sensitive rewrite systems. Journal of Functional Programming, 14(4): 379-427, 2004.
J. Giesl, P. Schneider-Kamp, and R. Thiemann. AProVE 1.2: Automatic Termination Proofs in the Dependency Pair Framework. In U. Furbach and N. Shankar, editors, Proc. of Third International Joint Conference on Automated Reasoning, IJCAR’06, LNAI 4130:281-286, Springer-Verlag, Berlin, 2006. Available at http://www-i2.informatik.rwth-aachen.de/AProVE .
S. Lucas. Context-sensitive computations in functional and functional logic programs. Journal of Functional and Logic Programming, 1998(1):1-61, January 1998.
S. Lucas. Context-sensitive rewriting strategies. Information and Computation, 178(1):293-343, 2002.
S. Lucas. MU-TERM: A Tool for Proving Termination of Context-Sensitive Rewriting In V. van Oostrom, editor, Proc. of RTA’04, LNCS 3091:200-209, Springer-Verlag, Berlin, 2004. Available at http://www.dsic.upv.es/∼ slucas/csr/termination/muterm .
S. Lucas. Proving termination of context-sensitive rewriting by transformation. Information and Computation, 204(12):1782-1846, 2006.
E. Ohlebusch. Advanced Topics in Term Rewriting. Springer-Verlag, Berlin, 2002.
TeReSe, editor, Term Rewriting Systems, Cambridge University Press, 2003.
H. Zantema. Termination of Context-Sensitive Rewriting. In H. Comon, editor, Proc. of RTA’97, LNCS 1232:172-186, Springer-Verlag, Berlin, 1997.
