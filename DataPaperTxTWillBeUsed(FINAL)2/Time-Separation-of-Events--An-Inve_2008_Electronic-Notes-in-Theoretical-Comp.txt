	Electronic Notes in Theoretical Computer Science 209 (2008) 135–148	
www.elsevier.com/locate/entcs

Time Separation of Events: An Inverse Method
Emmanuelle Encrenaz 1 Laurent Fribourg a,2
a LSV, ENS de Cachan & CNRS Paris, France

Abstract
The problem of “time separation” can be stated as follows: Given a system made of several connected components, each one entailing a local delay known with uncertainty, what is the maximum time for traversing the global system? This problem is useful, e.g. in the domain of digital circuits, for determining the global traversal time of a signal from the knowledge of bounds on the component propagation delays. The uncertainty on each component delay is given under the form of an interval. The general problem is NP-complete. We focus here on the inverse problem: we seek intervals for component delays for which the global traversal time is guaranteed to be no greater than a specified maximum. We give a polynomial time method to solve it. As a typical application, we show how to use the method in order to relax some specified local delays while preserving the maximum traversal time. This is especially useful, in the area of digital circuits, for optimizing “setup” timings of input signals (minimum timings required for stability).
Keywords: Execution time analysis, Timing constraints, Time separation problem, Inverse method


Introduction
As said in [5]: “The behavior of asynchronous and concurrent systems is naturally described in terms of events and their interactions. A fundamental problem in ana- lyzing such systems is to determine bounds on the time separation of events. Stated informally, we seek answers to questions such as: “How late can event i occur after event j?” for arbitrary events i and j. The problem of computing time separation bounds is compounded in practice by statistical variations in manufacturing and op- erating conditions that introduce uncertainties in component delays. Consequently, finding bounds on time separation of events in the presence of uncertain component delays is an important practical problem.”
The uncertainty on each component delay is given under the form of an interval. The general problem of finding the exact bound on the time separation between two

1 Email: emmanuelle.encrenaz@lsv.ens-cachan.fr
2 Email: fribourg@lsv.ens-cachan.fr

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.04.008

given events i and j is NP-complete ([12]). We focus here on the inverse problem: we seek intervals for the component delays, so that the time separation between i and j is guaranteed to be no greater than a specified bound. We give a polynomial time method to solve it, and explain how it is useful for relaxing some bounds associated to some component delays while preserving the global separation time from i to j.

Related Work.
The direct problem of time separation of events has received considerable atten- tion in the literature (see, e.g. [5] for an extensive survey). Even in the case of acyclic timing constraint graphs, the direct problem is NP-complete [12]. Many researchers have thus proposed polynomial-time approximating algorithms, which give an upper approximation of the maximal separation time. In contrast here, the time generated will be guaranteed to be the exact maximal time (for a pos- sibly restricted domain of component delays, however). Other researchers have replaced some of the bound values by parameters, then have computed the exact solution space using exponential-time procedures (e.g., Fourier-Motzkin elimination or Presburger-based procedures [2])). A variant of this approach has been proposed using additional techniques of abstract interpretation [9] or parametric reachability analysis [8].
In this paper we focus on the inverse problem. To our knowledge, such an inverse problem has been rarely tackled in the literature. An exception is [6]. Its goal is there to compute safe bounds on some timing constraints (typically, setup timings), in the sense that, when satisfied, these constraints guarantee “correct” operation of the circuit. In their context, “correct” means that the circuit has no hazard, i.e., roughly speaking, that the output signal changes at most once. Such a guarantee is complementary to ours, since what we guarantee, in this context, is that the first change of the output signal occurs before a specified lapse of time. Also, their analysis does not take place in the framework of separation of events, but in the framework of “multi-value signal algebra”, which is well-suited to the problem of hazard-detection. Another work, which can be viewed as an inverse method, is by
[4]: they pose the problem as a min-max linear programming problem and use it for computing optimal clock schedules in synchronous circuits, but their method is exponential.

Time Separation of Events
The Direct Problem.
Formally, the system can be represented under the form of a “timing constraint graph” [7]. The graph is oriented: vertices (or nodes) represent events and directed edges represent causal dependencies between them. Let {0, ..., N − 1} be the set of vertices. Each event is labeled with a min, max or delay operator specifying how the time of occurrence of event q, denoted tq, depends on those of its predecessors in the timing constraint graph. A delay node q is either a source event (no incoming edge), or has a unique predecessor, say p, in the graph, and the edge from event p

to event q is labeled with symbol δp,q representing the (non-negative) delay in the propagation of event p to event q. For any vertex q, let preds(q) denote the set of its predecessor vertices. We have the system 3 :
for each delay-node q, distinct from the source, of (unique) predecessor p:
tq = tp + δp,q	(1)
for each min-node q:
tq = minp∈preds(q) tp	(2)
for each max-node q:
tq = maxp∈preds(q) tp	(3)

In the following, we restrict our analysis to acyclic timing constraint graphs, with a unique source (event with no incoming edge). The delay-edges are the edges linking a node p to a delay-node q. Note that, for a given vector of values d for δ, system (1)-(2)-(3) has a unique solution in t0, ..., tN−1.
For all delay-edge from p to q, the associated delay δp,q is constrained to fall within fixed (nonnegative) lower and upper bounds lp,q and up,q. That is:
lp,q ≤ δp,q ≤ up,q.
Let δ be the vector of the δp,qs, where q is a delay-node (distinct from the source). Let l and u be the vectors of lp,qs and up,qs respectively. Note that all these vectors
have r−1 components, where r is the number of delay-nodes (including the source). 4

Let Δ = (l, u) be the zone delimited by intervals (lp,q, up,q). Henceforth, the set of inequations {lp,q ≤ δp,q ≤ up,q} will appear under the form l ≤ δ ≤ u or δ ∈ Δ. The direct problem is posed as one of finding the maximum achievable separation
max(tj − ti) between two events i and j under the considered system of timing constraints. We will assume here that the time of source event is null, and coincides with vertex i (ti = 0). In the direct problem, one seeks therefore the maximal value of tj, denoted by MAXj:
MAXj = maxδ∈(l,u) tj .
As usual, a path πp from the source to event p is a sequence of adjacent edges going
from the source to p. The delay of a path π is the sum of the delays of its edge components, Σ   δp,q, which will be abbreviated as Σ δ.
Henceforth, we assume given a Time Separation of Events system with an acyclic timing constraint graph with a unique source (node i), a set of vertices {0, ..., N −1}, a domain Δ = (l, u), and an associated set of equations (1)-(2)-(3) (together with implicit equation ti = 0).
Example 2.1 This example concerns SPSMALL, an embedded memory designed by STMicroelectronics which has been presented in [8]. The constraint timing graph

3 In the original formulation of the problem, there is no delay-nodes, but one allows min-nodes of the form tq = min(tp + δp,q, tr + δr,q ) (and similarly for max-nodes). Such a timing constraint graph can be transformed into an equivalent form as above, at the price of introducing new intermediate nodes on each edge. This adds to the original graph at most n × K new vertices, where n is the number of vertices of the original graph, and K the maximum number of predecessors of any vertex. (Usually K is a small constant, and in any case bounded by n.)
4 It is convenient to assume that all the other edges (to min/max nodes q) have delays δp,q which are null (i.e., lp,q = up,q = 0 for min/max node q).


0



min node



 max node



delay node







1




























Fig. 1. Timing Constraint Graph for SPSMALL (δ0,1 stands for δHI + δLO − δsetupD , and δ0,2 stands for
δHI + δLO − δsetupW )

(for the write operation) is made of 27 event nodes (see Fig. 1). For the sake of homogeneity with presentation of [8], we proceed to cosmetic changes with respect to the presentation of timing constraint graphs given above. Thus, events are not only numbered but also denoted by symbols corresponding to those used in [8]; for example event 20 is also denoted by o↓ . 5 Also, delays δp,q between events p and q are allowed to appear as an algebraic sum of more elementary delays: for example,
δ0,1 corresponds to δHI + δLO − δsetup , δ3,6 to δ↑ + δ↑,.	The separation time of
D	3	2
interest is here tQ↑ (≡ t23). The delay δHI (resp. δLO) corresponds to the high-level (resp. low-level) period of the clock of the circuit. These delays are specific, as they
are assumed to be fixed: the bounds lHI and uHI of δHI are equal to a common value denoted by dHI , and similarly for δLO. Henceforth, δHI and δLO will appear under the form dHI and dLO respectively. The expression δ ∈ (l, u) (where l and u correspond to implementation SP1 of [8]) is given componentwise as follows:
5 The symbols ↑ and ↓ indicate the rising or falling nature of the edges of the corresponding signal.

δ↑ ∈ (94, 95), δ↓ ∈ (65, 66), δ↑ ∈ (13, 14), δ↓ ∈ (17, 18), δ↑ ∈ (23, 24), δ↓ ∈ (29, 30), δ↑ ∈ (5, 5), δ↓ ∈ (2, 2),
0	0	1	1	2	2	3	3

δ↑ ∈ (21, 22), δ↓ ∈ (44, 45), δ↑ ∈ (20, 21), δ↓ ∈ (19, 20), δ↑ ∈ (0, 0), δ↓ ∈ (21, 22), δ↑ ∈ (10, 11), δ↓
∈ (8, 8),

5	5	7	7	8	8	13	13

↑ ∈ (21, 22), δ↓
∈ (21, 22), δ↑
∈ (13, 14), δ↓
∈ (10, 11), δ↑
∈ (23, 24), δ↓
∈ (0, 0), dHI = 36, dLO = 74,

δsetupD
∈ (108, ?), δsetupW
∈ (48, ?). 6

Besides: MAX23 ≡ MAXQ↑ = 56  (+dHI + dLO). All these values have been found by the manufacturer via electrical simulation (at the transistor level). Decreasing
values lsetupD = 108 and lsetupW = 48 would lower the cost of the circuit, but this should not alter the maximal response time MAX23 = 56 (see [8]). Our inverse method will show that this can be safely done.

Interest of the Inverse Problem.
Before giving the inverse method, let us explain why the resolution of the inverse problem can help to relax the bounds assigned to the component delays of the system.
In the direct problem, we have:
as an input: Δ = (l, u),

as an output: MAXj, a value such that tj ≤ MAXj for all δ ∈ Δ. In the inverse problem, we will have:
as an input: a specific value d0 for δ,

as outputs: a domain Δ∗ = ( ∗
∗), and a value MAX∗, such that



tj ≤ MAX∗ for all δ ∈ Δ∗.
In a “good situation”, we will have for MAX∗ and Δ∗ the following:
MAX∗ ≤ MAXj,
Δ∗ = ( ∗ ∗) ⊃ Δ = (l, u)	(i.e: l∗ ≤ l and u ≤ u∗).
In this case, we can safely relax the original bounds l and u to l∗ and u∗, and still guarantee an upper bound (no greater than) MAXj. As illustrated in Example 1, the method is useful, in the area of digital circuits, for optimizing “setup” timings of input signals (i.e., for minimizing the stability period of an input signal required before the circuit clock changes). Even if the second item does not hold for all its components, i.e.: l∗ > lk or uk > u∗ for some events k, the knowledge of Δ∗ may
k	k
be instructive: it allows in particular to identify certain sets of “key” parameters k, which, when ranging over a restricted interval, enables the relaxation of the bounds of the other parameters (see Appendix 2).

Inverse Method
Let us now describe our inverse method.
Definition 3.1 We say that O is a canonical order on the events if O is of the form tk1 ≤ · · · ≤ tkr , where k1, ..., kr are the delay-nodes of the timing constraint graph, and k1 corresponds to source node i (hence: tk1 = 0).

6 The maximal values of δsetupD and δsetupW are unspecified. (The values of interest are the minimal values, which correspond to optimal behavior of the circuit.)

Given two delay-nodes p1 and p2, we say that p1 is O-earlier (resp. O-later) than p2 if tp1 ≤ tp2 (resp. tp2 ≤ tp1 ) according to O.
Definition 3.2 Let O ≡ tk1 ≤ · · · ≤ tkr be a canonical order. For all event q, the representative delay-node of q (or the delay-node representing q) under O, denoted by q∗, is defined recursively as follows:
if q is a delay-node then q∗ = q.
if q is a min-node (resp. max-node) then q∗ is the O-earliest (resp. O-latest) node among the delay-nodes representing the predecessors of q (i.e. among {p∗ | p ∈ preds(q)}).
For all event q of representative delay-node q∗, it follows from (1)-(2)-(3) that
tq = tq∗ .
Consider a vector of (nonnegative real) values d for the delay-edges. When d is assigned to δ, each time tp (0 ≤ p ≤ N − 1) takes a unique value, say Dp, according to (1)-(2)-(3). Let us order the delay-nodes by non-decreasing values of D (in case there are two delay-nodes p and q with Dp = Dq, we order them in an arbitrary way). This yields a non-decreasing sequence of the form tk1 ≤ tk2 ≤ · · ·≤ tkr . Such an order is said to be a canonical order induced by d.
Example 3.3 Consider Example 2.1. As for particular value d0 of δ, we take the maximal values u of the specification. (Note that, for δ0,1 and δ0,2, this corresponds to the minimal values of δsetupD and δsetupW respectively, since δ0,1 = dHI + dLO − δsetupD , and similarly for δ0,2.) For d , the time of each event is: t0 = 0,  t1 = 2, t3 = 36, t4 = 41, t2 = 62, t6 = 65, t5 = t10 = 70, t11 = t19 = t20 = 92, t7 = t12 = 97,  t8 = 110,  t14 = t15 = 111,  t9 = 112,  t18 = t21 = 123,  t16 = 133,  t13 =
142, t22 = t25 = 145, t17 = 146, t23 = 166, t24 = t26 = 220. This induces the following order O0:
t0 ≤ t1 ≤ t3 ≤ t4 ≤ t2 ≤ t6 ≤ t5 ≤ t19 ≤ t20 ≤ t7 ≤ t8 ≤ t15 ≤ t9 ≤ t18 ≤ t16 ≤
t13 ≤ t25 ≤ t17 ≤ t23 ≤ t24.
The representative nodes q∗ of min/max nodes q under O0 are given by:
10∗ = 5, 11∗ = 19, 12∗ = 7, 14∗ = 15, 21∗ = 18, 22∗ = 25 and 26∗ = 23.
Definition 3.4 Let O be a canonical order of the form tk1 ≤ · · ·≤ tkr . For all event
q, the representative path to q associated to O, and denoted by π∗, is recursively
defined as follows:
if q is the source node, then π∗ is the empty path.
if q is a delay-node (distinct from the source) then π∗ = π∗ ∪ (p, q), where p is
q	p
the unique predecessor of q, and π∗ the representative path of p for O.
if q is a min-node (resp. max-node) then π∗ = π∗ , where q∗ is the delay-node

representing q.
q	q∗

Example 3.5 For ordering O0 (see Example 3.3), the representative path π∗ to
event 23 (≡ Q↑) is {(0, 3), (3, 8)(8, 18)(21, 25), (22, 23)}, whose support is drawn in bold font on Fig. 1.
Definition 3.6 Let O ≡ tk1 ≤ · · · ≤ tkr be a canonical order for the considered

system, and π∗
s
the representative path of ks (1 ≤ s ≤ r). We call δ-constraints

associated to O the set I∗ = {Ik , ..., Ik } with, for all 1 ≤ s ≤ r:
Ik	≡ Σ ' δ ≤ Σ '	δ,

s
where π'
πs
and π'
πs+1
are the disjoint parts of π∗
s
and π∗
s+1
respectively

(i.e. π' = π∗
\ π∗
and π'
= π∗	\ π∗ ).

s	ks
ks+1
s+1
ks+1	ks

Example 3.7 Consider in O0 inequation t17 ≤ t23, and let us give the associated
inequality, say I18. For path π∗ associated to event 23, we have (see Example 3.5):
Σ ∗ δ = dHI + dLO + δ↓ + δ↓ + δ↓ + δ↑.

π23
3	15	8	7

Likewise, for event 17 ≡ ck↓, the representative path π∗ goes from 0 to 17 through
vertices 3 and 8. We have:
Σ ∗ δ = 2dHI + dLO.
17
Therefore t17 ≤ t23 corresponds (after elimination of the delay dHI + dLO associated
to the common sub-path of π∗ and π∗ ) to

I18 ≡ Σ ' δ ≤ Σ '  δ,	i.e.:	dHI ≤ δ↓ + δ↓
+ δ↓ + δ↑.

π17
π23∗
3	15	8	7

The other inequalities of I0 associated to O0 are given in Appendix 1.
Proposition 3.8 Let O ≡ tk1 ≤ ··· ≤ tkr be a canonical order, π  the representa-
∗
tive path of event p (0 ≤ p ≤ N − 1) associated to O, and I∗ ≡ {Ik , ..., Ik } the set
1	r
of δ-constraints associated to O.
If d is a value of δ satisfying I∗, then we have (under (1)-(2)-(3)), for δ = d: tp = Σ ∗ d, for all event p.
p

Proof. Suppose that d is a value of δ satisfying I∗. Let us prove: tp = Σ


∗ d, for
p

all event p. The proof proceeds by induction on the depth of event p in the timing constraint graph. The proof of the base case is trivial. Let us prove the induction step. Node p is either a min/max node or a delay-node. Suppose first that p is a min/max-node, say a min-node (the case of a max-node is similar). Then p is the sink of a “min/max subgraph”, i.e. the smallest (directed) subgraph of sink p having
only delay-nodes, say p1, ..., pm, as sources (All the non-source nodes are min/max

nodes).  By induction hypothesis on pk (1 ≤ k ≤ m), we have: tpk
Σ	
= Σ ∗ d.
πpk


Furthermore, since d is a solution of I∗, the values (
∗  d)1≤k≤m are ordered as
pk

(tpk )1≤k≤m in O. It follows that all the nodes v of the min/max subgraph are such
that tv = Σ ∗ d. In particular for the sink p: tp = Σ ∗ d.
πv	πp
Suppose now that p is a delay-node. Then p has p1 as a unique predecessor
and tp = δp ,p + tp .  Now, by induction hypothesis, tp  = Σ ∗ d.  Therefore:

1
tp = δp ,p + Σ ∗
1
d = Σ ∗ d.
1	πp1

1	πp1	πp
In both cases, tp = Σ ∗ d. This achieves the proof of the induction step.	 
p

Definition 3.9 Let O ≡ tk1
≤ · · · ≤ tkr
be a canonical order, and π∗
s
the repre-

sentative path of πk (1 ≤ s ≤ r). Let I∗ ≡ {Ik , ..., Ik }, be the set of δ-constraints
s	1	r
associated to O. We call y≤x-constraints associated to O the set J ∗ = {Jk , ..., Jk },
1	r
where Jks (1 ≤ s ≤ r) is obtained by replacing every δp,q of the left (resp. right) side of inequality Iks by a new variable yp,q (resp. xp,q), i.e:

Jk	≡ Σ ' y ≤ Σ '	x,

s
where π'
πs
and π'
πs+1
are the disjoint parts of π∗
s
and π∗
s+1
respectively.

Example 3.10 Let us consider I∗ associated to the ordering O0 for SPSMALL
Example (see Appendix 1). By substituting each δp,q of the left (resp. right) side of
I∗ by yp,q (resp. xp,q), we obtain the following system J ∗ (after having discarded
0	0
trivial inequalities 0 ≤ δ↑ and 0 ≤ δ↓ for k = 14, 15, 16):
3	k
ysetupD ≤ dHI + dLO
dLO ≤ xsetupD

y↑ + ysetup
≤ dLO

dLO ≤ x↑ + x↑ + xsetup
3	2	W
y↑ + y↑ + ysetup	≤ dLO + x↓

3
y↓
2
↓	↓
14	16
W
+ ysetupD
13
≤ xsetupW
+ x↑

y↑ ≤ xsetup

ysetup
≤ x↑ + x↑

D	0	1
y↑ + y↑ ≤ xsetup  + x↓
0	1	D	3
y↓ + y↓ + ysetup  ≤ x↑ + x↑ + x↑
3	15	D	0	1	5
y↑ + y↑ + y↑ ≤ x↓ + x↓ + xsetup
0	1	5	3	2	D
y↓ ≤ x↓ + x↓
2	15	8
y↓ + y↓ + y↓ ≤ dHI
3	15	8
14, dHI ≤ x↓ + x↓ + x↓ + x↑
3	15	8	7
15. y↓ + y↓ + y↓ + y↑ ≤ dHI + dLO
3	15	8	7
Theorem 3.11 Let O be a canonical order of events, π∗ the representative path of

event j, and J ∗ the associated set of y≤x-constraints.
Let l∗ and u∗ be solutions of J ∗for x and y respectively, and let Δ∗ = ( ∗
∗).

Then, under (1)-(2)-(3), the representative path π∗ is such that:
∗	Σ	∗	j

MAXj  ≡ maxδ∈Δ∗ tj =
∗ u .
j

Proof. Since l∗ and u∗ are solutions of J ∗, we have: Σ
ks
u∗ ≤ Σ '
πks+1
l , for all

1 ≤ s ≤ r. Hence, for all d with l∗
≤ d ≤ u
∗: Σ '
πks
d ≤ Σ '
πks+1
d. It follows that, for

all d with l∗ ≤ d ≤ u∗, d is a solution of I∗. Therefore, under (1)-(2)-(3), for all event
p associated to δ = d, we have by Prop. 3.8: tp = Σ ∗ d ≤ Σ ∗ u∗. In particular,

πp
for δ = u∗, we have: tp =	∗ u∗. It follows: MAX∗
πp
≡ max
∗ tp = Σ
∗ u∗.

πp	p	δ∈Δ	πp
This is true in particular for p = j.	 
The system J ∗ is a linear system of r inequalities with r unknowns xp,q and r unknowns yp,q, where r is the number of delay-nodes (r is less than or equal to the number N of events). The problem now reduces to find solutions l∗ and u∗ which delimit a domain of interest Δ∗ as large as possible. This problem can be seen as an optimization problem in linear programming, which is solvable in polynomial time in N .
Example 3.12 Let us consider system J ∗ generated for SPSMALL system (see Example 3.10). In order to find optimal values for xsetupD , ysetupD , xsetupW , ysetupW ,



we instantiate the other components of x and y with the corresponding values of l and u respectively (see Example 2.1). In other terms, we have l∗ = l and u∗ = u, for each component distinct from setupD and setupW . J ∗ then reduces to:
ysetupD ≤ 110	(from: ysetupD ≤ dHI + dLO)

107 ≤ xsetup
(from: y↑ + y↑ ≤ xsetup  + x↓)

D	0	1	D	3

ysetup
≤ 53	(from: y↑ + y↑ + ysetup	≤ dLO + x↓ )

W	3	2	W	13

46 ≤ xsetup
(from: dLO ≤ x↑ + x↑ + xsetup  )

ysetup
W
≤ xsetup
+ 64	(from: y↓
+ y↓
+ y↓
+ ysetup
3	2
≤ xsetup
W
+ x↑)

D	W	13	14	16	D	W	0
Therefore, optimal (i.e., least) solutions are:

∗
setupD
∗
setupD
∗
setupW
∗
setupW
= 53.

On Δ∗, we have: MAX∗
≡ max
t ↑ = (d
+ d	+) u↓ + u↓
+ u↓ + u↑.

Q↑	δ∈Δ∗ Q
HI	LO
3	15	8	7

This gives: MAX∗ ↑ = 56	(+dHI + dLO). Therefore: MAX∗ ↑ = MAXQ↑ , where
Q	Q
MAX	l∗

Q↑ is the original value of the specification. Besides, the value 107 of
setupD

is (slightly) relaxed with respect to the value lsetupD = 108 of the specification, as

well as the value 46 of l∗
with respect to lsetupW
= 48. Therefore Δ∗ ⊃ Δ. We

are thus in the “good situation” described in Sect. 4. The lower bound l∗	can
however been further optimized (from 107 to 100), using an enhancement of the method described in Sect. 4.
Complexity and Enhancements
The inverse method described in Sect. 3 can be recapitulated as follows:
find an order O induced by a specific point d0
construct the associated set of δ-constraints J ∗

find an optimal solution ( ∗
∗) of the associated system J ∗.

We have already mentioned that the last step can be seen as an optimization problem of linear programming, and, as such, is polynomial in N . It is easy to see that the two first steps are also polynomial in N (actually, respectively quadratic and linear). It follows:
Proposition 4.1 Given a system of time separation of events with N events, with an acyclic timing constraint graph of unique source and j an event of interest, the complexity of ﬁnding the domain Δ∗ = (l∗, u∗) and the maximal separation time MAX∗ by the inverse method is polynomial in N.
Let us recall that the number N of edges of the timing constraint graph is at most quadratic in the number n of vertices of the original graph (see footnote of Sect. 2).
Let us now focus on a possible enhancement of the method. In order to have a domain Δ∗ as large as possible, it is of great interest to be allowed to remove inequalities from I∗, hence from J ∗, as much as possible. Intuitively, in order to guarantee that the representative path π∗ is still critical, we need to check that the removal of an inequality of I∗, does not entail any new path to j of separation time

greater than Σ ∗
j


δ . Formally:

Proposition 4.2 Let O be a canonical order of events, π∗ the representative path of j, I∗ and J ∗ the associated sets of δ-constraints and y≤x-constraints respectively. Let I be an inequation of I∗, and J its counterpart in system J ∗.
Suppose that the system
I∗ − {I}∪ {(1-2-3)}∪ {tj > Σ ∗ δ}	(4)
j
has no solution in δ. Then, for all solutions l∗∗, u∗∗ of J ∗ − {J} in x, y resp., and

Δ∗∗ = (l∗∗
, u∗∗
), we have:	MAX∗∗ ≡ max	∗∗ tj  =
Σ ∗ u∗∗.
j

Note that checking the unsatisfiability of system (4) is exponential in the num- ber N of events, due to the presence of min and max constraints in (2)-(3) (The general problem is indeed NP-complete; see, e.g. [4]). We loose therefore the polynomial-time complexity result of the basic method. Still, this enhancement turns out to be useful in practice.
Example 4.3 In order to decrease the lower bound of δsetupD , we have to remove
the “restrictive” inequality, say J , of J ∗: y↑ + y↑ ≤ xsetup  + x↓. This inequality
0	0	1	D	3
originates itself from inequality, say I, of I∗: δ↑ + δ↑ ≤ δsetup  + δ↓. Let us consider

system I∗ − {I}∪ {(1-2-3)
Σ	 0	1
D	3
+ ↓ + ↓ +
↓ + ↑ .

0	}∪ {t23 >
∗ δ ≡ dHI + dLO	δ
23
δ15	δ8
δ7 }

It can be checked that such a system has no solution in δ. Hence J can be safely removed from J ∗. After instantiation of x, y with l, u respectively, for components distinct from setupD and setupW , J ∗ − {J} then reduces to:
ysetupD ≤ 110	(from: ysetupD ≤ dHI + dLO)

100 ≤ xsetup
(from: y↑ + y↑ + y↑ ≤ x↓ + x↓ + xsetup  )

D	0	1	5	3	2	D

ysetup
≤ 53	(from: y↑ + y↑ + ysetup	≤ dLO + x↓ )

W	3	2	W	13

46 ≤ xsetup
(from: dLO ≤ x↑ + x↑ + xsetup  )

ysetupD
W
≤ xsetupW
+ 64	(from: y↓
↓	↓
14	16
3
+ ysetupD
2
≤ xsetupW
W
+ x↑)

Accordingly, solutions are now:

∗∗
setupD
∗∗
setupD
∗∗
setupW
∗∗
setupW
= 53,

for which MAX∗∗ ≡ max	∗∗ t23 is still equal to 56  (+dHI + dLO).
23	δ∈Δ
Similar results were obtained in [8] by addressing the direct problem, but it required the decomposition of the system into three smaller parts, and heavily relied on heuristics (via the repeated integration of the negation of “suspect” inequalities).
In case the space of solutions S of system (4) (see Prop. 4.2) is non empty, one can still remove (the counterpart of) inequality I: This requires the integra- tion of the negation of an inequality delimiting the convex hull of S (cf. Appendix 2).
Implementation. Rather than a direct implementation of the inverse method, we transform the given timing constraint graph into a synchronized product of timed automata [1], then used the facilities of HYTECH [11]. Basically, each node of the timing constraint graph corresponds to a timed automaton and each edge as a synchronized transition. It is then easy to infer the order O induced by a particular point d , then to generate, via parametric reachability analysis, the associated set I∗ of δ-constraints. The test of unsatisfiability for removing inequalities is also done using HYTECH. Apart from the two examples given here, we tried other examples

(SP2 from [8], buffer from [7]). They all took less than 5 minutes (on 1GHz PowerPC G4 with 512 MB of memory).
Final Remarks
The main advantage of the inverse method, compared with the direct method, is that the method gives an exact maximal separation time, which can be computed in a polynomial time (at least without the enhancement of inequality removal). A drawback is that the range of some component delays may have to be tightened with respect to the original interval. On the other hand, many other intervals may be relaxed substantially. Results obtained with the inverse method thus give a useful complementary information.
The inverse method basically relies on the choice of the input point d0 of the
component delays. Intuitively, this point corresponds to a point of “good behavior”, and the method infers a (rectangular) domain for points that behave similarly. Such a method is similar in spirit to a common engineering practice, where the parameters of the systems are tuned around a typical point of good behavior. Note also that the “critical path” (the representative path to the output event j) is often known in the area of digital circuits, when the system is designed in a top-down manner by assembling portions of circuit around this crucial path (see, e.g., [10]).  Such
a critical path induces a partial order on events that may be useful to infer the complete order O (instead of starting from d0).
Finally, let us note that timing constraint graphs correspond to unconditional systems like “free-choice” Petri nets [3]. The inverse method can be extended to more general systems (timed Petri nets or timed automata) in a natural manner.

References
R. Alur and D.L. Dill. A theory of timed automata. TCS 126, 1994.
T. Amon, G. Borriello, T. Hu, and J. Liu. Symbolic timing verification of timing diagrams using Presburger formulas. In Proc. 34th DAC, 1997.
W. Belluomini and C. Myers. Timed state space exploration using posets. IEEE Transactions on Computer-Aided Design of Integrated Circuits, 19(5), 2000.
T. Burks and K. Sakallah. Min-max linear programming and the timing analysis of digital circuits. In
Proc. of ICCAD, pages 152–155, 1993.
S. Chakraborty, D. Dill, and K. Yun. Efficient algorithms for approximate time separation of events.
Sadhana, 27(2):129–162, 2002.
S. Chakraborty, D. Dill, K. Yun, and K. Chang. Practical timing analysis of asynchronous circuits using time separation of events. In Proc. of IEEE Custom Integrated Circuits Conference, 1998, 1998.
S. Chakraborty, P. Subrahmanyam, and D. Dill. Approximate time separation of events in practice. In
Proc. of 5th ACM/IEEE Int. Workshop TAU, 1997.
R. Chevallier, E. Encrenaz-Tiph`ene, L. Fribourg, and W. Xu. Verification of the generic architecture of a memory circuit using parametric timed automata. In Proc. FORMATS’06, volume 4202 of LNCS, pages 113–127. Springer, 2006.
R. Clariso and J. Cortadella. Verification of timed circuits with symbolic delays. In Proc. ASP-DAC, pages 628–633, 2004.

J. Cortadella, M. Kishinevsky, S. Burns, A. Kondratyev, L. Lavagno, K. Stevens, A. Taubin, and
A. Yakovlev.	Lazy transition systems and asynchronous circuit synthesis with relative timing assumptions. IEEE Trans. on CADICS 21:2, 2002.
T.A. Henzinger, P.-H. Ho, and H. Wong-Toi. A User Guide to HYTECH. In TACAS’95, volume 1019 of LNCS, pages 41–71. Springer, 1995.
K. McMillan and D. Dill. Algorithms for interface timing specification. In Proc. of the IEEE Int. Conf. on Computer Design (ICCD), pages 48–51, 1992.
Appendix 1: System I∗ associated to O0 for SPSMALL
0 ≤ dHI + dLO − δsetupD	(t0 ≤ t1)
dLO − δsetupD ≤ 0	(t1 ≤ t3 after elim. of dHI )


0 ≤ δ↑
δ↑ ≤ dLO − δsetup
(t3 ≤ t4 after elim. of dHI ) (t4 ≤ t2 after elim. of dHI )

dLO − δsetup
≤ δ↑ + δ↑
(t2 ≤ t6 after elim. of dHI )

W	3	2

δ↑ + δ↑ ≤ dLO − δsetup  + δ↓
(t6 ≤ t5 after elim. of dHI )

0 ≤ δ↓	(t5 ≤ t19 after elim.  of dHI + dLO − δsetup  )
W

0 ≤ δ↓
(t19 ≤ t20 after elim. of dHI + dLO − δsetupW
↓ + δ↓ )

−δsetupW
↓	↓
13	14
↓ ≤ −δsetup
+ δ↑
(t20≤t7 after elim.  dHI + dLO)

−δsetupD
+ δ↑ ≤ 0	(t7 ≤ t8 after elim. of dHI + dLO)

0 ≤ −δsetup
+ δ↑ + δ↑
(t8 ≤ t15 after elim. of dHI + dLO)

D	0	1
[−δsetup  + δ↑ + δ↑ ≤ δ↓]	(t15 ≤ t9 after elim. of dHI + dLO)

D	0	1	3
0 ≤ δ↓
(t9 ≤ t18 after elim.  of dHI + dLO + δ↓)

δ↓ + δ↓ ≤ −δsetup  + δ↑ + δ↑ + δ↑
(t18 ≤ t16 after elim. of dHI + dLO)

3	15	D	0	1	5

−δsetup
+ δ↑ + δ↑ + δ↑ ≤ δ↓ + δ↓
(t16 ≤ t13 after elim. of dHI + dLO)

D	0	1	5	3	2

δ↓ ≤ δ↓
+ δ↓
(t13 ≤ t25 after elim.  of dHI + dLO + δ↓)

2	15	8	3
δ↓ + δ↓ + δ↓ ≤ dHI	(t25 ≤ t17 after elim. of dHI + dLO)
3	15	8

dHI ≤ δ↓ + δ↓ + δ↓ + δ↑
(t17 ≤ t23 after elim. of dHI + dLO)

3	15	8	7
δ↓ + δ↓ + δ↓ + δ↑ ≤ dHI + dLO	(t23 ≤ t24 after elim. of dHI + dLO)
3	15	8	7
Appendix 2: A system of concurrent processors
In [7], a multiprocessor system is evaluated by solving the direct problem. The timing constraint graph is depicted in Fig.2. The separation time of interest is here t19. The set of inequations δ ∈ (l, u) is here of the form: δ0,1 ∈ (5, 10), δ0,2 ∈ (5, 10), δ4,5 ∈ (3, 5), δ7,8 ∈ (3, 5), δ6,9 ∈ (6, 12), δ8,10 ∈ (5, 10), δ8,11 ∈ (5, 10), δ9,15 ∈ (6, 12), δ13,14 ∈ (3, 5),
δ15,18 ∈ (6, 12), δ16,17 ∈ (3, 5), δ18,19 ∈ (6, 12). As for d , take the middle of each interval (i.e.: δpq = [ upq−lpq ♩). This yields O:






s1



s3














s10


 min node max node

delay node




s12











Fig. 2. Timing constraint graph for the system of concurrent processors

t0 ≤ t1 ≤ t2 ≤ t5 ≤ t6 ≤ t8 ≤ t10 ≤ t11 ≤ t14 ≤ t15 ≤ t17 ≤ t18 ≤ t19
The delay-nodes representing the min/max nodes are given by:
3∗ = 2, 4∗ = 1, 7∗ = 5, 9∗ = 6, 12∗ = 11, 13∗ = 10, 15'∗ = 15, 16∗ = 14, 18'∗ = 18.
The support of the representative path to 19 is in bold font in Fig. 2. The system I∗
is:

We can remove the 4th, 6th and 8th inequalities (under brackets), using the enhancement of removal of inequalities (see Sect. 4). Further restrictive inequalities δ0,1 ≤ δ0,2 and δ8,10 ≤ δ8,11 can be also removed, but this requires the addition of new inequalities (obtained by negating constraints delimiting the hull of solutions of system (4)). This yields the set I∗∗:
δ0,2 ≤ δ0,1 + δ4,5
δ0,1 ≤ δ0,2 + δ4,5	(added for removing δ0,1 ≤ δ0,2)


Possible solutions of the associated system J ∗∗ are:


∗∗
5,6
∗∗
9,15
= 10, l∗∗
= 5, l∗∗
∗∗
0,2
∗∗
15,18
= 5, l∗∗
= 0,

for all other (p, q).

The lower bounds of δ5,6 and δ9,15 are thus increased (from 6 to 10), as well as the lower bound of δ4,5 (from 3 to 5). This is a restriction of their original domain. The set {δ4,5, δ5,6, δ9,15} is thus a set of “key-parameters” whose tightening allows to extend the domain of all the other δp,qs (smaller lower bounds). Besides, we have:


MAX∗∗ = max
∗∗ t19 = u0,1 + u4,5 + u5,6 + u9,15 + u15,18 + u18,19

19	δ∈Δ
= 10+5+ 12+ 12+ 12+ 12 = 63.

This coincides with the upper bound value obtained in [7].
