	Electronic Notes in Theoretical Computer Science 215 (2008) 209–226	
www.elsevier.com/locate/entcs


Checking Equivalence for Reo Networks
Tobias Blechmanna,1	Christel Baiera,1
a Chair for Algebraic and Logical Foundations of Computer Science Technical University of Dresden
Dresden, Germany

Abstract
Constraint automata have been used as an operational model for component connectors described in the coordination language Reo which specifies the cooperation and communication of the compo- nents by means of a network of channels. This paper addresses the problem of checking equivalence of two Reo networks. We present a compositional approach for the generation of a symbolic repre- sentation of constraint automata for Reo networks and report on an implementation that realizes a partitioning splitter technique for checking bisimulation equivalence for Reo networks. Using a special operator on our symbolic data structure enables efficient treatment of the rich labeled transitions in constraint automata. In order to show the power of this approach we then present some benchmarks.
Keywords: Reo, bisimulation, coordination, partitioning splitter, symbolic model checking


Introduction
Reo is a channel-based exogenous coordination language [1]. It was invented to provide the glue code for describing how component instances communicate with each other and how they are coordinated. Since then it has been used to model many different complex systems. The Reo point of view is that a system consists of component instances which execute at different locations and communicate through connectors. The main idea is to define a small set of simple channels and their behavior. More complex connectors then can be constructed through composition of these simple channels. During design

1 The authors are supported by the EU-project Credo and the DFG-and-NWO-project SYANCO


1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.06.029

of such coordination protocols questions like whether two specifications have the same observable behavior or whether one is an abstraction of another one arise naturally and frequently. Therefore we use constraint automata which are a special kind of labeled transition systems introduced by [2]. Constraint automate provide an operational semantics for Reo which nicely reflects its compositional channel-based approach. The model of constraint automata is equipped with operators which mimic the operations provided for Reo. This yields a compositional approach to construct the corresponding constraint automata to a given Reo circuit is provided.
Notions of bisimulation equivalence for constraint automata yield a def- inition for the equivalence of constraint automata. This is e.g. important to replace a given Reo connector component by a functional equivalent, but simpler (or cheaper) one. Furthermore bisimulation equivalence can be used as specification formalism: Having a certain coordination mechanism in mind, it is often quite easy to depict an automaton that describes its permissible behavior. In this sense this automaton serves as a specification for the Reo circuit we want to design. Correctness can then be understood w.r.t. bisim- ulation equivalence. Algorithms to compute bisimulation equivalence classes provide a sound way to check for equivalence of two given constraint automata or Reo circuits.
In this paper we report an implementation of a bisimulation checker us- ing a symbolic approach working on switching functions. One could also try to model the behavior of Reo circuits using well-known bisimulation model checking tools like [3] or [4]. But representing the compositional approach of Reo using standard tools would require to provide a semantics for Reo based on the process algebra operators and therefore leads to huge and rather arti- ficial looking system descriptions. For us the two main challenges were (1) to find an efficient way to deal with the rich labeled transitions occurring in con- straint automata and (2) to symbolically compute logical equivalence classes as this is needed for implementation of the partitioning splitter algorithm. We report on how to accomplish the composition of two symbolic representations of constraint automata in a very efficient way.
Then we introduce a pattern equivalence operator which allows to effi- ciently compute logical equivalence classes and show how it enables a sym- bolic implementation of the partitioning splitter algorithm. This leads to a tool which enables us to automatically and efficiently treat constraint au- tomata with lots of states but rather few bisimulation equivalence classes. In order to measure the efficiency of our approach we report on some benchmark results.
This paper starts with a summary of the main concepts of Reo and con-

straint automata in section 2. Section 3 explains how the compositional ap- proach to generate a constraint automaton from a given Reo circuit can work symbolically. Then section 4 explains the main features of our implementation and section 5 reports on our experimental results.

Reo and Constraint Automata
We briefly summarize the main concepts of Reo and constraint automata. For further information see [1] and [2]. In Reo every connector is constructed out of channels using the provided operators for channel composition. The sim- plest channel is a synchronous channel shortly called sync channel. It accepts data written to its source end when the same data can leave the channel at the same moment through its sink end. There are two basic operations used for composition called join an hiding. Join plugs to channel-ends together creating a node at the point of connection. To this node one can connect more channels via join afterwards. If more than one accepting channel-ends are connected to a node every incoming message is simultaneously written to all outgoing channels whenever all outgoing channels at the node are ready to accept data. Whenever more than one channel-end offers data at a node a non-deterministic choice decides which data is taken and written to all out- going channels. The hiding operation hides away one node which means that the data-flow occurring at this node cannot be observed from outside and no new channel-end can be connected to this node.
Constraint automata as introduced by [2] can serve as an operational semantics
for Reo. Similar to other finite automata, constraint automata consist of states and a transition relation between those states. All transitions in constraint automata are labelled to describe the node where data enters a channel or is taken from a channel. The labeling also determines what data item is trans- ferred. Constraint automata use a finite set N of names. Roughly speaking the elements in N are the nodes in the corresponding Reo circuit. Transitions in constraint automata are labeled with pairs consisting of a non-empty subset N ⊆N and a data constraint g. Data constraints are propositional formulas describing the data items that enable a transition in the constraint automata. These formulas are built out of atoms dA where d ∈ Data a finite data domain and A ∈ N . To simplify the notations we assume that Data = {0, 1}. The atom dA stands for the interpretation ‘d is written to or read from port/node A.’. Data constraints are given by the grammar g ::= true | dA | g1 ∨ g2 | ¬g where A ∈ N is a name and d ∈ Data. The boolean operators ∧ (conjunc- tion), ⊕ (exclusive or), → (implication), ↔ (equivalence) can be derived as usual. We often use derived data constraints such as dA = dB which means

that on port A and port B the same element out of Data is transferred. In the sequel we write DC(N, Data) for N ⊆U and N /= ∅ to denote the set of data constraints that use only atoms dA = d for A ∈ N . For all data constraints in the whole automaton we write DC as an abbreviation for DC(U , Data).
Definition 2.1 (Constraint Automata) A constraint automaton is a tuple A = (Q, U , →— , Q0) where Q is the set of states, U is the set of nodes, —→ is a subset of Q × 2N × DC × Q called the transition relation of A and Q0 ⊆ Q
N,g
is the set of initial states. We write q ——→ p instead of (q, N, g, p) ∈→— . N is
called the name-set and g the guard of the transition. We require that N /= ∅
and g ∈ DC(N, Data). A is called finite iff Q and —→ are finite. 2
For an intuitive interpretation one can see the states as representations of the connector configurations and the transitions as the possible single-step behavior.









F0




Fig. 1. Two Reo connectors and a constraint automata

In Figure 1 we present the dining philosophers example as shown in [5]. The left part of Figure 1 shows a Reo circuit which specifies the dining philoso- phers protocol for two philosophers and two chopsticks. Solid arrows stand for sync channels. To gain a constraint automaton that describes the behavior of this circuit we have to specify what happens inside of a PHIL and a CHOP component. The constraint automaton in the middle of the picture models the behavior of one PHIL component. The philosophers starts in state think and if this is possible writes 3 a message to T0 which intuitively means picking one of the chopsticks next to him. After writing the message he enters state wait0. If writing the message T1 is possible this message is written and the component enters state eat. On the way back to state think the component then has to write two messages which release the chopsticks. What remains is

2 We demand Data and Q to be finite so here —→ is finite.
3 One cannot take from the constraint automata whether this is a write or take operation
but in the Reo circuit message directions are shown

to specify the behavior of the chopsticks. The right part of Figure 1 shows a Reo circuit for the chopsticks. We use a blocking FIFO1 channel (marked by a box in the middle of the channel) and join its sink end with one of the source ends of a synchronous drain (SYNCDRAIN) channel. The blocking FIFO1 channel behaves in a natural way. If its buffer is empty it accepts one data item. Afterwards it does not accept any write operations to its source end and waits for a read operation happening at the sink end. The SYNCDRAIN channel has two source ends and no sink end. It accepts any data item on one of its ends iff at the same moment another data item is written to the other end. As we are not interested in the communication taking place at the inner node we can hide it which is shown by the enclosing box. The semantics of the two atomic channels we used must again be specified using constraint automata. What remains is to show how we can mimic the join and the hiding operation on the automata level.
Due to the fact that in constraint automata there is no way to distinguish between incoming and outgoing ports we have to use two different operations to mimic the merge semantics of Reo nodes. On the automata level we first provide the product automata operator for joining a source node with another node (no matter what type). Then we use a merger automaton to simulate the merger behavior of multiple joined sink channel ends. This merger automaton can be regarded as a new primitive connector in the Reo circuit plugged before the old node which just performs a non-deterministic choice on its source ports and forwards the chosen data to the old node. Its semantics can be represented by a constraint automaton with only one state and self-loop transitions for every incoming channel-end.
Assume two Reo circuits with node-sets U1 and U2 and their corresponding automata are given.  We want to perform a join operation for node-pairs
⟨Bi, B¯i⟩ ∈ U1 × U2, i = 1,... ,k where, for any i, at least one of the nodes
Bi or B¯i is a source node. We assume that the nodes are renamed in a way
that B1 = B¯1,... , Bk = B¯k holds and the two automata do not contain
other common nodes. Thus we join all common nodes B ∈ U1 ∩ U2. On
the automata level the join operator (denoted da) is performed as shown in Definition 2.2.
Definition 2.2 (Product automaton) The product automaton for the two constraint automata A1 = (Q1, U1, —→1, Q0,1) and A2 = (Q2, U2, —→2, Q0,2) is A1daA2 = (Q1 × Q2, U1 ∪ U2, —→, Q0,1 × Q0,2) were —→ is defined by the following rules (let q1, p1 ∈ Q1 and q2, p2 ∈ Q2):


N1,g1	N2,g2

q1 ———→1 p1, q2 ———→2 p2, N1 ∩ U2 = N2 ∩ U1
N1∪N2,g1∧g2
⟨q1, q2⟩ ———————→ ⟨p1, p2⟩
N,g
q1 ——→1 p1, N ∩ U2 = ∅
N,g
⟨q1, q2⟩ ——→ ⟨p1, q2⟩
And a third rule symmetric to the second one.
(1)

(2)

The definition of product automaton reflects the possible synchronous and asynchronous behavior of two joined constraint automata. The first rule (1) describes the synchronous behavior. After joining both automata only a syn- chronous step is possible for transitions involving common nodes. The data transferred in this step has to match g1 ∧ g2. The second rule (2) and the sym- metric one define asynchronous actions. If N ∩ U2 = ∅ the first automaton can make a step and the second one remains in the current state.
The second operation on Reo circuits also has a counterpart on the con- straint automata level. Hiding a node in a constraint automaton produces a new automaton in which data at the hidden node is no longer observable from
{A},dA=d
the outside. For a transition q1 —————→ q2 which only relies on the hidden
port A this means that the transition can always be taken in state q1.
Definition 2.3 (Hiding on constraint automata) Let A = (Q, U , →— , Q0) be a constraint automaton and C ∈ U . After hiding C the resulting constraint automaton ∃C[A]= (Q, U \ {C}, —→C, Q0,C) is defined as follows. Let ~∗ be the transition relation such that q ~∗ p iff there exists a finite path


{C},g1
{C},g2
{C},g3
{C},gn

q ————→ q1 ————→ q2 ————→ ... ————→ p
where g1,... , gn only depend on C and are satisfiable. The set Q0,C of initial states is Q0,C = Q0 ∪ {p ∈ Q : q0 ~∗ p for some q0 ∈ Q0}.
The transition relation —→C is given by


q ~∗ p, p N,g
e, N¯ = N \ {C} /= ∅,
N¯ ,g¯
q ——→C e
g¯ = ∃C[g]

where ∃C[g] = d∈Data g[dC/d]. We write g[dC/d] to denote the data con- straint obtained by syntactically replacing all occurrences of dC in g with d. To be more precise we replace all atoms dC = d¯ with true if d = d¯ and with f alse if d /= d¯.
When constructing larger Reo circuits the question whether two circuits show the same observable behavior arise naturally. Also often it is easy to

give a constraint automaton describing the desired behavior. Then compar- ing its behavior with the behavior of the constructed Reo circuit shows if the Reo circuit is a correct implementation. This is sometimes called a homoge- neous approach to verification (model checking). There is a strong connection between this problem and the bisimilarity of constraint automata. An algo- rithm computing the bisimulation relation therefore can be of great help when treating larger Reo circuits. We start with some notations which are needed to introduce bisimulation for constraint automata.
For a constraint automaton A = (Q, U , →— , Q0), q ∈ Q, N ⊆U and P ⊆ Q
we define dcA(q, N, P )=  {q : q	p for some p ∈ P }
N,g
If the automaton is clear from the context we leave out the subscript and write dc(q, N, P ). Then dc(N, P ) =  q∈Q dc(q, N, P ) dc(q, N, P ) stands for the weakest transition using only N ports from q to an arbitrary chosen state in P . If no such transition exists dc(q, N, P )= f alse.
With this notations we can now define bisimulation for constraint au- tomata.
Definition 2.4 (Bisimulation) Let A = (Q, U , —→, Q0) be a constraint au- tomaton. An equivalence relation R on Q is called bisimulation for A if for all pairs (q1, q2) ∈ R, all R-equivalence classes P ∈ Q/R and every N ⊆ U , dc(q1, N,P ) ≡ dc(q2, N,P ) holds.
Two states are called bisimilar (or bisimulation-equivalent) iff there exists a bisimulation R with (q1, q2) ∈ R. Intuitively bisimilar states are equal powerful with respect to their outgoing transitions.
We write q1 ∼ q2 iff q1 and q2 are bisimilar and q1  q2 iff they are not. Two constraint automata A1 and A2 with the same set of names are bisim-
ilar (A1 ∼ A2) if in the bisimulation equivalence classes for the disjoint union automaton B = A1 A2 for every initial state of A1 there exists a bisimilar initial state in A2 and vice versa.

Symbolic Constraint Automata
The basis of our implementation is a definition of a symbolic representation based on switching functions [7] that supports an efficient treatment of join and product. For our implementation we then use ordered binary decision diagrams [6][9][10][11] to represent and manipulate those switching functions. Let Z = {z1,... , zn} be a finite set of boolean variables. An evaluation of Z is a function η : Z → {0, 1} that assigns a value η(z) ∈ {0, 1} to each variable z ∈ Z. Eval(Z) identifies the set of all evaluations of Z. Let a = (a1,... , an) ∈ {0, 1}n and z = (zi1 ,... , zin ) ∈ Zn such that zij ,... , zij

are distinct. Then [z = a] denotes the evaluation η ∈ Eval(Z) with η(zij ) = 
aj, j = 1,... , n. If b = (b1,... , br) ∈ {0, 1}r and z = (zi ,... , zi ) ∈ Zr
1	r
with η on all variables and assigns bj to z for z ∈ {zi1 ,... , zir } A switching function is a function f : Eval(Z) → {0, 1}. The set of all switching functions will be called B(Z) or B(z1,... , zn). In the following we will use the common notions to denote operations on switching functions. Logical connectors like
∧, ¬ and the derived operators for propositional logic have analog meanings for switching functions. To keep notations simple we use set operations like ∩ and ∪ with analog meaning for variable tuples like b. Let z¯ and ¯b be as before and f ∈ B(Z). The cofactor of f related to z¯ is defined by f |z¯=¯b ∈ B(Z) where f |z¯=¯b(η) = f (η z¯ = ¯b ). Let f ∈ B(Z) and z ∈ Z then ∃z[f ] ∈ B(Z)
is given by ∃z[f ] = f |z=0 ∨ f |z=1 To keep notations simple we write ∃z¯[f ] as
short form for ∃z1 ... ∃zn[f ] with z¯ = (z1,... , zn). Further we use f (z' ← z) to denote a new function which is derived from f be replacing all z variables by z' variables.
For every constraint automaton A = (Q, U , →— , Q0) we can now define the corresponding symbolic representation (δ(x¯, y¯, N, d), χinit(x¯)).
After renaming we can assume a state set Q = {q0,... , qn},n ≥ 2 and we identify element qi with its number i. Using k = [log(n+1)| boolean variables
x¯ = (x1,... , xk) we define χq (x¯) = xb1 ∧ ... ∧ xbk ∈ (Bk → B) as symbolic
i	1	k
representation for state qi where bj ∈ {0, 1}, x0 = ¬xj, x1 = xj, j = 1,... ,k 

and i = Σk
j	j
bj · 2j.

As we want to reason about transitions from one state to another we have to distinguish between start and end states. We introduce copies of the x- variables (that serve to encode the start state of transitions) and deal with variables y¯ = (y1,... , yk) to represent the end states of transitions.
With N = (A1,... , Am) we use the names as boolean variables for our ports. Further we define boolean variables d = (dA1 ,... , dAm ) to represent the data items observed at the corresponding ports.
For every name set N ⊆U we define



χN (N )= 
Ai∈N
Ai ∧
Ai∈N \N
¬Ai


As we restricted our data domain to {0, 1} data constraints can be viewed as switching functions over d.
Definition 3.1 (Symbolic Constraint Automata) A symbolic constraint au- tomaton for a constraint automaton A = (Q, U , →— , Q0) is a tuple Asym =



Fig. 2. Constraint automata for one PHIL component

 

(δ(x¯, y¯, N, d), χinit(x¯)) where
δ(x¯, y¯, N, d)= 
(q,N,g,p)∈—→

χq(x¯) ∧ χN (N ) ∧ χg(da) ∧ χp(y¯)



and χinit(x¯)= 
q∈Q0
χq(x¯).

Example 3.2 Figure 2 shows the constraint automata that was introduced in Figure 1 after renaming the state set. The corresponding switching function is given by:

δ(x¯, y¯, N, d)= (¬x1 ∧ ¬x0 ∧ ¬y1 ∧ y0 ∧ T0 ∧ ¬T1 ∧ ¬F0 ∧ ¬F1)
∨ (¬x1 ∧ x0 ∧ y1 ∧ ¬y0 ∧ T1 ∧ ¬T0 ∧ ¬F0 ∧ ¬F1)
∨ (x1 ∧ ¬x0 ∧ y1 ∧ y0 ∧ F1 ∧ ¬T0 ∧ ¬T1 ∧ ¬F0)
∨ (x1 ∧ x0 ∧ ¬y1 ∧ ¬y0 ∧ F0 ∧ ¬T0 ∧ ¬T1 ∧ ¬F1)
As in [2], the join operator is assumed to be preceded by an appropriate node-renaming such that all ports to be joined are named the same in both automata and therefore the variables for those ports and their constraints agree. Note that if A is a common node then A belongs the variable set of the symbolic representations of both automata.
Definition 3.3 (Symbolic Product Automaton) Given two symbolic con- straint automata Asym = (δA(x¯A, y¯A, N A, dA), χinitA (x¯A)) and Bsym =
(δB(x¯B, y¯B, N B, dB), χinitB (x¯B)) with x¯A ∩ x¯B = ∅ and y¯A ∩ y¯B = ∅ the prod-
uct automaton Csym = Asym da Bsym is defined as Csym = (δC(x¯C, y¯C, N C, dC),
χinitC (x¯C)) with x¯C = x¯A ∪ x¯B, y¯C = y¯A ∪ y¯B, δC(x¯C , y¯C, N C , dC)= δsync ∨ δasync
and χinitC (x¯C)= χinitA (x¯A) ∧ χinitB (x¯B). Where δsync = δA ∧ δB and


δasync =	δA ∧
A∈NB

¬A ∧ (x¯B ↔ y¯B)	∨	δB ∧
A∈NA

¬A ∧ (x¯A ↔ y¯A) 

Where x¯ ↔ y¯ stands for	 
(xi ↔ yi).




This operation on switching functions is the exact counterpart of our prod- uct automata operation defined in Definition 2.2. Every fullfilling evaluation for δsync is a fullfilling evaluation for δA and δB. Thus the evaluation for N is such that common ports of both automata are equally active or passive. The conjunctive combination of the constraints g belonging to the transitions is given by the conjunctive combination of δA and δB.
We obtain the asynchronous transitions by evaluating the δasync function. The intuitive interpretation for the formula is Asym makes a step which does not depend on ports in Bsym. The formulas (x¯B ↔ y¯B) ensure that Bsym cannot make a step. This has to be done again with Asym and Bsym switching their positions. By δsync ∨ δasync we then compute the union of the synchronous and asynchronous transitions. Thus we obtain a function representing all transitions which exist in the product automaton.
Like the product operation hiding can also be done on the symbolic repre- sentation 4 . Because hiding relies on at least two steps we need another set of state variables z¯. Remember the definition of hiding on constraint automata. In the symbolic case we have to perform a fixpoint iteration in order to col- lapse multiple transitions that rely only on the port we want to hide. A pseudo code version of this algorithm is shown in Algorithm 1. Our implementation also provides another variant of hiding using a repeated squaring approach. It depends on the example which one of them is slightly faster. Let C be the port we want to hide. First we divide our system in two parts. δP contains all transitions which are labeled only with {C}. Analogously δR represents all transition which are not in δP . The first loop then computes our new set of initial states by performing a reachability analysis from all initial states using transitions in δP only. The second loop takes every two step transition

{C}
N,g
N,g

q ——→ p ——→ s and adds a new transition q ——→ s. If there is a sequence of

{C}
{C}
N,g
N,g

consecutive transitions like l ——→ q ——→ p ——→ s we first add q ——→ s. The
N,g
next iteration then adds l ——→ s. The loop is continued until no new transition
can be added. The last operation δ = δR ∧ ¬δP deletes all transitions labeled with {C}.
When reasoning about equivalence using bisimulation we need to regard two disjoint automata A and B as one big automaton. We call the resulting automaton C a disjoint union of two automata denoted by C = A B. For explicit representations with disjoint node sets the node set of the new au- tomaton is the union of both node sets. The new transition relation is the union of both transition relations. The set of initial states consists of all states

4 Hiding some nodes in our examples showed that you cannot expect the BDD representa- tion of an automaton to be smaller after hiding.



Algorithm 1: Hiding for symbolic constraint automata

A∈N \{





until χinit = χold;

{C}

N,g

N,g

repeat	// for q ——→ p ——→ s add new transitions q ——→ s δO := δR;
δR := δP ∧ δR{z¯ ← y¯, y¯ ← x¯};
δR := ∃y¯[δR]{y¯ ← z¯};
δR := δR ∨ δO;
until δO = δR;
δ = δR ∧ ¬δP ;	// delete all {C}-transitions
return (δ(x¯, y¯, N \ {C}, d \ {dC}), χinit(x¯))
that are in the union of the two sets of initial states of the disjoint automata. The same operation on symbolic representations can be done but we have to pay attention to non-essential variables when putting the two automata together.
Symbolic representation using switching functions to encode transition re- lations and binary decision diagrams to represent those switching functions is a powerful method to handle large transition systems [7].
To obtain compact BDD-representations of constraint automata the vari- able ordering must be chosen carefully. A detailed description of our heuristics to determine a good variable ordering goes beyond the scope of this paper. We just mention that our heuristics attempt to put variables representing constraints close to variables representing states having transitions relying on those constraints.

Bisimulation
Checking whether two automata are bisimilar (A1 ∼ A2) is known to be coNP-hard [2]. Therefore we cannot expect good performance for every in- stance when computing bisimulation quotients. A well known way to compute bisimulation quotient for ordinary labeled transition systems is the algorithm by Kannelakis/Smolka [8]. A sketch of how to adapt this algorithm for con- straint automata is presented in [2]. We start with some notation needed for

this algorithm.
Partition: For a constraint automaton A = (Q, U , →— , Q0) a partition for Q stands for a set Π = {P1,... , Pn} of pairwise disjoint, non-empty subsets of Q such that Q = P1 ∪ ... ∪ Pn. For a partition Π = {P1,... , Pn} of Q we call the elements Pi blocks. A super-block then denotes a non-empty union of blocks in Π. A splitter denotes a pair (N, P ) consisting of a non-empty subset N of U and a super-block P for Π.
Reﬁne: Let Π be a partition for Q, (N, P ) a splitter for Π and B a block for Q. For two states q1,q2 we then define the equivalence ≡(N,P ) such that

q1 ≡(N,P ) q2 iff dc(q1, N,P )= dc(q2, N,P )

Then we define Ref ine(B, N, C)= B/ ≡(N,P ). A block B is called stable with respect to (N, P ) if Ref ine(B, N, P ) = {B}. For a refinement of the whole partition we write Ref ine(Π, N,P )=  B∈Π Ref ine(B, N, P )
The idea of the partitioning splitter algorithm is to construct a sequence
Π0, Π1,... , Πk of partitions with Πi+1 is strictly finer than Πi but coarser than the bisimulation quotient Q/ ∼. For a finite set Q we get Πk = Q/ ∼ for some k ≤ |Q|. A brief sketch of this algorithm is shown in Algorithm 2. The most critical part is the calculation of the logical equivalence classes of the data constraints and the refinement of the actual block according to those classes. This operation is performed on our symbolic representation using the following ideas. First we choose an arbitrary state q out of B. Then we select its transitions to the current splitter. The function describing the labeling of this transition is the pattern function p for the pattern equivalence operator. With Z' = N ∪ d we then obtain a function representing all states that are in the same refined block as q. We remove these states from the current block and start with a new arbitrarily chosen state if one is left.
We implemented a symbolic version of Algorithm 2 based on ordered binary decision diagrams (OBDDs) in order to estimate its efficiency for constraint automata. Note that our approach is not restricted to using OBDDs. For this partitioning splitter algorithm we have to compute logical equivalence classes with respect to the data constraints. This cannot be done by the standard operators provided by an OBDD library. The main idea of our approach is to arbitrarily choose a state and regard its outgoing transitions as representative for one equivalence class. What remains is to efficiently compute the class belonging to this representative. For this purpose we define
a special pattern equivalence operator on switching functions in order to find logical equivalence classes. First we start with a function getAssignment(fˇ) which chooses an arbitrary fullfilling evaluation for fˇ and returns a switching



Algorithm 2: Partitioning splitter algorithm Π := Q;
Splitters := {(N, Q): N ⊆ U ,	dc(q, N, Q) /≡ false} ;
q∈Q
while Splitters /= ∅ do
choose(N, P ) ∈ Splitters and remove (N, P ) from Splitters;
forall B ∈ Π do
find equivalence classes D1,... , Dr of dc(q, N, P ), q ∈ B;
// If r =1 then B is stable w.r.t. (N, P )
// in other words Refine(B, N, P ) := {B}
if r ≥ 2 then	// B is not stable
Bi = {q ∈ Q : dc(q, N, P ) ∈ Di};
// Refine(B, N, P )= {B1,... , Br}
Π := (Π \ {B}) ∪ {B1,... , Br};
forall (N˜, Bi) with ∅ /= N˜ ⊆ U , dc(N˜, Bi) /≡ f alse do
 add (N˜, Bi) to Splitters;
return Π;
function that is true for this evaluation and false for all other evaluations. 5 This function can be used to select one state and its transitions. Using an existential quantification we then compute the representative for the logical equivalence class. It remains to explain how to compute the switching function describing the set of all states in this logical equivalence class. This can be done by applying our pattern equivalence operator on the state space representation with function p being our representative and therefore Z' consisting of all variables representing labels of transitions.
Definition 4.1 Let Z = {z1,... , zn} be a finite set of boolean variables and
Z' = {z' ,... , z' } ⊂ Z be a subset of Z.  Let f ∈ B(Z) a function and
1	k
p ∈ B(Z') a pattern function. The pattern equivalence of f with respect to p

(written f/≡p ) is defined by: f/≡p
: Eval (Z\Z') → B where



f/≡p
(η)=	1	p = f |η where f |η is the cofactor of f with respect to η
0	otherwise

with η ∈ Eval (Z\Z').


5 At the OBDD level this means a representative for a path to the 1-sink

Example 4.2 Let Z = {x, y, z} and Z' = {y}. The function f (x, y, z) = (x ∧ y) ∨ z and the pattern function p(y)= y. The results for f/≡p are shown in the following tables.

The pattern equivalence operator allows to efficiently handle symbolic rep- resentations of the whole automata in contrast to [12] that treads small state spaces explicitly and only uses symbolic methods for the labeling of transi- tions. In contrast to [13] our approach is capable of handling the rich labeled transitions of constraint automata directly. As our algorithm works on a sym- bolic representation a complexity analysis is leads to distorted results. One can count the number of symbolic operations but the OBDDs this operations work on can have exponential size in the number of variables.

Benchmarks
After describing how the partition splitter algorithm can be implemented on symbolic constraint automata we now present some benchmarks for the im- plementation of this algorithm.
In Reo a FIFO(N)-component should behave like N FIFO(1)-components after joining them together and hiding away the inner nodes. We used an- other approach and tried to specify the constraint automaton for a FIFO(N) component directly. Using the partitioning splitter algorithm we found very subtle differences in these two implementations. When building the FIFO(N) directly we considered two possible operations. One can put one data element into the FIFO if the FIFO is not full and one can take one out of it when it is not empty. In contrast using the Reo construction leads to a component which can perform both operations at the same time. Our constraint automata does not specify the behavior of a correct Reo FIFO(N)-component. So the two approaches lead to non-bisimular constraint automata. To gain bisimilar au- tomata we can eliminate the concurrent operations by adding an AsyncDrain channel which prevents the incoming and outgoing ports from performing operations at the same time. Benchmark results for showing bisimulation equivalence of this components are shown in Tab. 1. Note that the automaton

resulting from direct construction has much fewer states than the automaton built from the Reo circuit gained through join and hide. All states of the first automaton build their own equivalence class. While the states of the second automaton are divided in exactly the same number of equivalent classes. This example shows how join and hide can lead to redundancy in the resulting constraint automaton.


Table 1
Bisimulation and FIFO(N) versus n·FIFO(1)





Table 2
Bisimulation and the mutual exclusion protocol (PROC2)


 
Another example used for our benchmarks are the two different Reo circuits specifying a mutual exclusion protocol shown above. This protocol specifies the interaction of n processes that want to enter a critical section of their execution while only k processes are allowed to be in the critical section at the same time. Using the algorithm presented in this paper we could prove that the two versions do not to lead to the same observable behavior. This is because the left one allows one process to enter its critical section while another one leaves its critical section at the same time. One can add an asynchronous drain channel (which accepts all data at its ends but not at both at the same time) connecting nodes Req and Rel to render this impossible. Then the constraint automata for the two circuits become bisimilar. Results for this example are shown in Tab. 2.

Conclusion and Perspective
Using Reo to model the behavior of coordination protocols raises the question whether two connectors have the same observable behavior. This shows the need for a tool to answer this question in an automated way. This work shows how techniques known to work for labeled transition systems can be adapted to constraint automata. Introducing a symbolic representation for constraint automata and explaining how the product and hide operator can be performed in a symbolic way. Large Reo networks with many components can by handled automatically. In order to compare two constraint automata we show how a partition splitter algorithm for computing the bisimulation equivalence classes of constraint automata can be adapted to work on our symbolic representation.

By introducing the pattern equivalence operator for switching functions we gain a powerful tool for symbolic treatment of the rich labeled transitions that occur in constraint automata. The benchmarks section gives an impression of how fast constraint automata for huge Reo circuits can be constructed and compared using our ideas. Future work will address several improvements of our implementation. Especially the set of splitters may be implemented in a more efficient way. At the moment we are working on combining our tool with the BTSL model checker for constraint automata presented in [14] and integrating both with the graphical design tool for Reo circuit currently being developed at CWI Amsterdam. Furthermore bisimulation as a homogenous approach to model checking constraint automata should be extended to richer versions of constraint automata like timed or probabilistic ones. Also one should extend the ideas presented here to make them applicable for constraint automata with priorities.

Acknowledgement
We like to thank J¨orn Ossowski for his help implementing the pattern equiv- alence operator for his OBDD library.

References
F. Arbab, Reo: A Channel-based Coordination Model for Component Composition,
Mathematical Structures in Computer Science, 14(3):1-38, 2004
C. Baier and M. Sirjani and F. Arbab and J.J.M.M. Rutten, Modeling Component Connectors in Reo by Constraint Automata, Science of Computer Programming, 61:75-113, 2006
CAPD: Construction and Analysis of Distributed Processes,
http://www.inrialpes.fr/vasy/cadp/
CWB: The Edinburgh Concurrency Workbench,
http://homepages.inf.ed.ac.uk/perdita/cwb/

F. Arbab, Abstract Behavior Types: A Foundation Model for Components and Their Composition, Lecture Notes in Computer Science Volume 2852/2003, pp 33-70
R. Bryant, Graph-Based Algorithms for Boolean Function Manipulation, IEEE Transactions on Computers, C-35, 1986
K. McMillan, Symbolic Model Checking, Kluwer Academic Publishers, 1993
P. Kannelakis and S. Smolka. Finite State Processes and three Problems of Equivalence. In CCS expressions, pages 228-240, 1983. Proc. 2nd ACM Symposium on the Principles of Distributed Computing 1983
S. Minato, N. Ishiura, S. Yajima, Shared binary decision diagrams with attributed edges for efficient Boolean function manipulation, Proceedings of the 27th ACM/IEEE Design Automation Conference, ACM, New York, pp 52-57, 1990
C. Meinel and T. Theobald, Algorithms and Data Structures in VLSI Design, Springer-Verlag, 1998

I. Wegener, Branching Programs and Binary Decision Diagrams. Theory and Applications,
Monographs on Discrete Mathematics and Applications, SIAM, 2000
Parosh Aziz Abdulla, Lisa Kaati, Marcus Nilsson, Minimization of Non-Deterministic Automata with Large Alphabets, Proc. CIAA’05, 2005
Amar Bouali and Robert de Simone, Symbolic Bisimulation Minimisation, Computer Aided Verification, pp 96-108, 1992
S. Klu¨ppelholz and C. Baier, Symbolic Model Checking for Channel-based Component Connectors, FOCLASA 2006
J. Ossowski, JINC, a bdd library, http://www.jossowski.de.
