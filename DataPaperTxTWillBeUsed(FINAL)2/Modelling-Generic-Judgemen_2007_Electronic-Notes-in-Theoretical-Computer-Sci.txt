Electronic Notes in Theoretical Computer Science 174 (2007) 19–35	
www.elsevier.com/locate/entcs

Modelling Generic Judgements
Ulrich Sch¨opp1
TCS, Institut fu¨r Informatik Ludwig-Maximilians-Universita¨t Mu¨nchen
Oettingenstraße 67, D-80538 Mu¨nchen, Germany

Abstract
We propose a semantics for the ∇-quantifier of Miller and Tiu. First we consider the case for classical first-order logic. In this case, the interpretation is close to standard Tarski-semantics and completeness can be shown using a standard argument. Then we put our semantics into a broader context by giving a general interpretation of ∇ in categories with binding structure. Since categories with binding structure also encompass nominal logic, we thus show that both ∇-logic and nominal logic can be modelled using the same definition of binding. As a special case of the general semantics in categories with binding structure,
we recover Gabbay & Cheney’s translation of FOλ∇ into nominal logic.
Keywords: Higher-Order Abstract Syntax, First-Order Logic, Model Theory, Categorical Logic


Introduction
Miller & Tiu [18] have introduced the logic FOλ∇ for reasoning about specifications in λ-tree syntax (a version of higher-order abstract syntax). The main new feature of FOλ∇ is the ∇-quantifier for the treatment of object-level eigenvariables. The design of FOλ∇ is based on a study of the proof-theory of first-order logic and the result is an elegant and simple calculus.
In addition to the proof theory for FOλ∇, one may be interested in a model- theoretic semantics, e.g. [6,17,25]. A simple semantics is useful for explaining the logic and for understanding the meaning of formulae. It may also help in trans- ferring technology from other, semantics-based, approaches. Nominal Logic [19], for example, solves a problem similar to that solved by FOλ∇, but is based on a semantic approach. A clarification of the semantics of FOλ∇ should help in study- ing the connection of FOλ∇ to Nominal Logic, in order to answer questions such as whether the elegant proof theory of FOλ∇ can be used for Nominal Logic, or whether programming in the style of Fresh O’Caml [23,22] is possible with ∇. In general, a model-theoretic explanation of the ∇-quantifier should make it amenable

1 Email: schoepp@tcs.ifi.lmu.de

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.01.027

for inclusion in solutions that are based on the model-theory of first-order logic, an example being Brotherston’s very general approach to cyclic proofs [2].
In this paper we give a simple and direct semantic interpretation of FOλ∇. We focus on classical logic with its easy-to-describe Tarski semantics and show that well-known theory can be adapted to classical FOλ∇. We focus on the classical case, as it is particularly simple to describe. In the second part of this paper we give a general framework for modelling FOλ∇, which we hope will help in studying the relationships of models for FOλ∇, such as those of Gabbay & Cheney [6] and Miculan & Yemane [17].
To explain the interpretation informally, recall from [18] that FOλ∇ is a first- order logic over simply-typed λ-calculus. Object-level syntax is represented by λ-tree types (HOAS). For instance, the type of λ-terms can be represented by a type Tm with two constants app : Tm × Tm → Tm and lam : (Tm → Tm) → Tm. In addition to the usual existential and universal quantification, ∃x : τ. ϕ(x) and
∀x : τ. ϕ(x), FOλ∇ also features the quantification ∇x : Tm. ϕ(x). In this paper we restrict the ∇-quantifier to range only over a subclass of types such as Tm, which we call λ-tree types. A similar restriction is imposed in [25]. Our restriction on ∇ is in line with restrictions imposed on the new-quantifier of Gabbay & Pitts, which typically ranges over names only. For the semantics, we use a standard interpretation for the quantifiers ∃ and ∀. Our interpretation of ∇x : Tm. ϕ(x) may be expressed as: ‘for all new variables x : Tm the formula ϕ(x) holds.’ The quantification ranges only over variables, but not over terms of the form app⟨x, y⟩ or lam(f ). The meaning of the formula ∇x : Tm. ϕ(x) may equivalently be expressed as: ‘for some new variable x : Tm the formula ϕ(x) holds.’
To formalise this informal description of the semantics, we have to deal with a number of issues. First, object-level terms are represented using higher-order abstract syntax. To model the type Tm, and in particular the constant lam of type (Tm → Tm) → Tm, adequately, we must find a model in which the interpretation of the function space (Tm → Tm) contains just α-equivalence classes of object-level terms. We address this issue using an approach of Hofmann [12], who has shown that certain presheaves provide a canonical model in which such an interpretation of Tm is available. A second issue is that to model ∇ we want to explain quantification over variables only. The internal logic of the presheaf-category, in which the terms are interpreted, is not suitable for this purpose, since it can express only propositions that are closed under all substitutions. We address this issue by modelling the terms in a presheaf category, but taking the logic from a so-called category with binding structure. This approach of modelling terms in one place and using the logic from another place is also used by Hofmann [12]. We consider a number of different logics including Nominal Logic, in which case we recover the interpretation of FOλ∇ in Nominal Logic proposed by Gabbay & Cheney [6].
In Part I of this paper we spell out directly an interpretation of classical FOλ∇. The aim of this part is to present the interpretation as simple as possible, without assuming knowledge of FOλ∇. We show that the semantics is close to the standard Tarski semantics for classical logic and that the well-known completeness argument

goes through almost unchanged. The point of Part I is to stress that just a little change to the standard Tarski-semantics is enough for modelling the ∇-quantifier.
In Part II, we generalise the development from the first part by giving models of ∇ in categories with binding structure [20, Chapter 10], which capture a general definition of binding. Since Nominal Logic also fits into the framework of categories with binding structure, the development in Part II will therefore show that both ∇ and nominal logic can be modelled using the very same definition of binding.

Part I
Classical First-Order Logic with ∇
Simply typed λ-calculus
We fix the notation for a simply typed λ-calculus.
Types:	τ := base types | λ-tree types | 1 | τ × τ | τ → τ
Terms:	M := x | c | ∗ | ⟨M, M ⟩| π1(M ) | π2(M ) | λx:τ. M | M M 
Contexts:	Σ := ·| Σ, x : τ
Terms are identified up to renaming of bound variables. We assume constants c to be defined in a signature S, and we assume the choice of S and the primitive types to be such that the types and terms are countable.
In addition to the normal base types, there is a second kind of base types, which we call λ-tree types. The intended use of λ-tree types is for higher-order abstract syntax encodings. We use ι to range over λ-tree types.
Contexts are subject to the usual convention that no variable may be declared more than once. A context that contains only declarations x : ι of λ-tree types is called a λ-tree context. We use σ to range over λ-tree contexts.
The typing judgement is defined by the following rules.

(x : τ ) ∈ Σ Σ ▶ x : τ
(c : τ ) ∈S 
Σ ▶ c : τ	Σ ▶ ∗: 1 

Σ ▶ M : τ	Σ ▶ N : τ '
Σ ▶ ⟨M, N ⟩: τ × τ '
Σ ▶ M : τ × τ '
Σ ▶ π1(M ): τ
Σ ▶ M : τ × τ '
Σ ▶ π2(M ): τ '

Σ, x : τ ▶ M : τ '
Σ ▶ λx:τ. M : τ → τ '
Σ ▶ M : τ → τ '	Σ ▶ N : τ
Σ ▶ M N : τ '

A substitution ρ : Σ → Σ' is a function that assigns to each variable (x : τ ) in Σ' a term Σ ▶ M : τ . We use the following notation for substitutions:
[M1/x1] ... [Mn/xn]: Σ → (x1 : τ1,... , xn : τn)
We use the letters ρ and θ to range over substitutions. An order-preserving renaming
is a substitution of the following form (note the order):
[y1/x1] ... [yn/xn]: (y1 : τ1,... , yn : τn) → (x1 : τ1,... , xn : τn)

We use the letters α and β to stand for an order-preserving renaming.
We write T for the category having contexts as objects and substitutions as morphisms, and we write L for the sub-category of T consisting of λ-tree contexts and substitutions between them.
The semantic structure corresponding to simply-typed λ-calculus is that of a Cartesian closed category with finite products. An interpretation of the syntax in such a category C is given by a functor −  : T → C that preserves finite products and exponents.
In order to model higher-order syntax adequately, we will interpret the types as presheaves on L, i.e. as functors Lop → Sets. This means that the interpretation τ  of a type τ is a mapping that assigns to each λ-tree context σ a set τ  σ and that assigns to each substitution θ : σ → σ' and each element x ∈ τ  σ' an element x[θ] ∈  τ  σ in such a way that the equations x[id ]= x and x[θ ◦ ρ]= x[θ][ρ] hold. A term Σ ▶ M : τ is interpreted as a natural transformation M  : Σ  →τ  . This means that the interpretation of a term is given by, for each σ, a function M  σ : Σ  σ → τ  σ, such that these functions behave well with respect to substitution, that is ( M  σ' (x))[θ]= M  σ(x[θ]) holds for all θ : σ → σ' and all x ∈ Σ  σ'.
For a small category C, we write C^ for the category of functors Cop → Sets. The point of using presheaves is that λ-tree syntax can be modelled adequately,
as has been shown in [12]. Consider for example the λ-tree type Tm with con- stants app and lam, as described in the introduction. For the interpretation Tm  we choose the presheaf Tm  (σ)= {M | σ ▶ M : Tm} with the canonical substitu- tion action. Now, the Cartesian closed structure on L^ is such that there are isomor- phisms Tm × Tm  σ ∼= Tm  σ × Tm  σ and Tm → Tm  σ ∼= Tm  (σ, x : Tm). In particular, the interpretation of the function type Tm → Tm at stage σ consists just of terms with an additional variable x. Therefore, we can interpret the terms app and lam by the maps  Tm  × Tm  →  Tm  and  Tm → Tm  →  Tm  given by ⟨M, N ⟩ '→ app⟨M, N ⟩ and M '→ lam(λx:Tm.M ) respectively.
The reader unfamiliar with the presheaf semantics may find it instructive to think of the term model (up to α-equivalence), in which all types are interpreted by τ  σ = {M | σ ▶ M : τ }.

Classical First-order Logic with ∇
Logical formulae in context Σ can be defined using a base type o and, for each relation symbol R, a constant R : τ1 → ··· → τn → o, as well as constants for the logical connectives ¬: o → o and ∨, ∧: o × o → o and ∀, ∃: (τ → o) → o and ∇: (ι → o) → o etc. Although these constants can be interpreted in our semantics, it is simpler to consider logical formulae as a separate entity with the evident inductive definition, which is the view we adopt in this section.
We define a sequent calculus for a classical logic with ∇. The sequents have the form Σ | Γ −→ Δ, in which Σ is a context and Γ and Δ are (possibly infinite) sets of formulae in a local signature σ D A. A local signature σ is a λ-tree context and σ D A in context Σ presupposes that A is a well-formed formula in context Σ, σ. We

General Rules

(Axiom)


Σ | Γ −→ Δ

Γ ∩ Δ /= ∅




Logical Rules

(Cut)
Σ | Γ −→ B	Σ | B, Δ −→ Φ Σ | Γ, Δ −→ Φ

(⊥-L)	(T-R)
Σ | Γ, σ Q ⊥ −→ Δ	Σ | Γ −→ Δ, σ Q T

(¬-L)
Σ | Γ −→ Δ, σ Q A
Σ | Γ, σ Q ¬A −→ Δ
(¬-R)
Σ | Γ −→ Δ, σ Q A


Σ | Γ, σ Q ¬A −→ Δ

(∧-L)
Σ | Γ, σ Q A, σ Q B −→ Δ
Σ | Γ, σ Q A ∧ B −→ Δ
(∧-R)
Σ | Γ −→ Δ, σ Q A	Σ | Γ −→ Δ, σ Q B


Σ | Γ −→ Δ, σ Q A ∧ B

(∨-L)

(⊃-L)
Σ | Γ, σ Q A −→ Δ	Σ | Γ, σ Q B −→ Δ Σ | Γ, σ Q A ∨ B −→ Δ
Σ | Γ −→ Δ, σ Q A	Σ | Γ, σ Q B −→ Δ Σ | Γ, σ Q A ⊃ B −→ Δ
(∨-R)

(⊃-R)
Σ | Γ −→ Δ, σ Q A, σ Q B


Σ | Γ −→ Δ, σ Q A ∨ B
Σ | Γ, σ Q A −→ Δ, σ Q B


Σ | Γ −→ Δ, σ Q A ⊃ B

(∀-L)
Σ, σ ▶ M : τ	Σ | Γ, σ Q A[M/x] −→ Δ Σ | Γ, σ Q ∀x : τ. A −→ Δ
(∀-R)
Σ, h | Γ −→ Δ, σ Q A[h σ/x] Σ | Γ −→ Δ, σ Q ∀x : τ. A

(∃-L)
Σ, h | Γ, σ Q A[h σ/x] −→ Δ Σ | Γ, σ Q ∃x : τ. A −→ Δ
Σ | Γ, (σ, x : ι) Q A −→ Δ
(∇-R)
Σ | Γ, σ Q ∇x : ι. A −→ Δ
(∃-R)
Σ, σ ▶ M : τ	Σ | Γ −→ Δ, σ Q A[M/x] Σ | Γ −→ Δ, σ Q ∃x : τ. A
Σ | Γ −→ Δ, (σ, x : ι) Q A
(∇-R)
Σ | Γ −→ Δ, σ Q ∇x : ι. A


Fig. 1. Sequent calculus


identify statements σ D A up to bound renaming of variables in σ. One may think of σ D A as the formula ∇σ. A. For · D A we write just A.
The rules of the sequent calculus, which are given in Fig. 1, are a straightforward extension to classical logic of the rules in [18].
Just as in FOλ∇, the ∇-quantifier commutes with all other logical connectives,
i.e. one can prove equivalences of the form (∇x : ι. A ∧ B) ⊃⊂ (∇x : ι. A) ∧(∇x : ι. B) and (∇x : ι. ∃y : τ. A(x, y)) ⊃⊂ (∃h : ι → τ. ∇x : ι. A(x, h x)) and likewise for all the other connectives. This property of ∇ makes it very similar to the new- quantifier  of Gabbay & Pitts [7]. The quantifier ∇ differs from , however, in the fact that the following equivalences are not provable: ∇x : ι. ∇y : ι.A(x, y) ⊃⊂
∇y : ι. ∇x : ι.A(x, y) and ∀x : ι. A(x) ⊃ ∇x : ι. A(x) and ∇x : ι. A(x) ⊃ ∃x : ι. A(x). In Part II we will show that both ∇ and are nevertheless instances of the same structure (Prop. 2.2).
We omit sequent rules for equality and definitions. Although these rules are important for practical reasoning and are non-trivial from a proof-theoretic per- spective, for semantic purposes it is simpler to replace them by axiom-schemes.


Semantic Interpretation
To give a meaning to the logic, we must first interpret the underlying λ-calculus. To do this, we assume, for each base type τ , an object  τ  of L^. We extend this

assignment to an interpretation of the λ-calculus by the following clauses.
ι  σ = y(x : ι) ∼= {M | σ ▶ M : ι}, where ι is a λ-tree type 1  σ =1 
τ × τ '  σ = τ  σ × τ '  σ
τ → τ '  σ = L^(y(σ) × τ  , τ '  )
Here, y(σ)= L(−, σ) is the Yoneda-embedding. We note that, as a consequence of the Yoneda Lemma, there is an isomorphism ι → τ  (σ) ∼= τ  (σ, x : ι) for all λ-tree types ι. We extend the interpretation to contexts by use of Cartesian products.
Propositions are interpreted as subsets closed under order-preserving renaming of variables. That is, a proposition A in context Σ is interpreted by, for each σ, a subset A(σ) ⊆  Σ  σ, such that, for each σ, each x ∈ A(σ) and each bijective variable renaming α : σ' → σ, we have x[α] ∈ A(σ'). Note that propositions must be closed only under variable-renaming, not under all substitutions.
The interpretation of base-types, constants and relations is recorded in a struc- ture A. It assigns to each base type τ an object τ  in L^ and to each constant c : τ a morphism 1  →τ  in L^. It assigns to each relation symbol R : τ1 → ··· → τn → o a proposition on x1 : τ1, ... , xn : τn, as described just above.
The interpretation of formulae is defined by the satisfaction relation σ Ηρ,Σ A, in which the stage σ is a λ-tree context, A is a formula in context Σ and ρ is a Σ-valuation at stage σ defined as follows: a Σ-valuation at stage σ is a function ρ mapping each variable x : τ in Σ to an element of τ  (σ). For a term Σ ▶ t : τ , we write ρ(t) for the evident element of τ  (σ).
σ Ηρ,Σ R(t1,... , tn) iff ⟨ρ(t1),... , ρ(tn)⟩∈R  (σ)
σ Ηρ,Σ ⊥ never
σ Ηρ,Σ T always
σ Ηρ,Σ ¬A iff not σ Ηρ,Σ A
σ Ηρ,Σ A ∧ B iff σ Ηρ,Σ A and σ Ηρ,Σ B σ Ηρ,Σ A ∨ B iff σ Ηρ,Σ A or σ Ηρ,Σ B
σ Ηρ,Σ A ⊃ B iff σ Ηρ,Σ A implies σ Ηρ,Σ B
σ Ηρ,Σ ∃x : τ. A iff there exists e ∈ τ  (σ) such that σ Ηρ[e/x],(Σ,x : τ ) A σ Ηρ,Σ ∀x : τ. A iff σ Ηρ[e/x],(Σ,x : τ ) A for all e ∈ τ  (σ)
σ Ηρ,Σ ∇x : ι. A iff σ, x : ι Ηρ[x/x], (Σ,x : ι) A
The interpretation of formulae is extended to local signatures by:


σ Ηρ,Σ (x1 : ι1, ... , xn : ιn) D A
⇐de⇒f
σ Ηρ,Σ ∇x1 : ι1	∇xn : ιn.A 

For a set of formulae Γ, we define σ Ηρ,Σ Γ as an abbreviation for 

G∈Γ
(σ Ηρ,Σ G).

A formula A is valid in A if, for all Σ-valuations ρ at the empty stage, · Ηρ,Σ A
holds. A sequent Σ | Γ −→ Δ is valid in A if, for all Σ-valuations ρ at the empty

stage, · Ηρ,Σ Γ implies the existence of a D ∈ Δ such that · Ηρ,Σ D holds. A structure A is a model of a set of closed formulae Γ, if all G ∈ Γ are valid in the interpretation relative to A. A formula (respectively sequent) is valid if it is valid in all structures A.

Examples
Lambda calculus and its induction principle. As an example of an induction principle that can be justified in the semantics, we consider the induction principle for the untyped λ-calculus Tm. The following induction schema is valid for all formulae P .


∀t, t' : Tm. P (t) ∧ P (t') ⊃ P (app ⟨t, t'⟩),
Σ |
∀f : (Tm → Tm). (∀t : Tm. P (t) ⊃ P (f t)) ⊃ P (lam f )
−→ ∀t : Tm. P (t)

That this induction schema is indeed valid follows because the definition of validity uses valuations at the empty stage, so that the quantification in this schema is over closed terms only. It is also possible to quantify over terms with free variables in σ by introducing a local signature σ.


σ D ∀t : Tm. isVar (t) ⊃ P (t),
Σ | σ D ∀t, t' : Tm. P (t) ∧ P (t') ⊃ P (app t t'),

−→ σD∀t : Tm.P (t)

σ D ∀f : (Tm → Tm). (∀t : Tm. P (t) ⊃ P (f t)) ⊃ P (lam f )
Here, isVar is the predicate expressing that t is a variable. It is interpreted by isVar  σ = {x | σ ▶ x : Tm, x is a variable}. Note that the interpretation of isVar is closed under order-preserving renaming but not under all substitutions.
Finally, if we let

σ D ∀t : Tm. isVar (t) ⊃ P (t),
Γσ = σ D ∀t, t' : Tm. P (t) ∧ P (t') ⊃ P (app t t'),
σ D ∀f : (Tm → Tm). (∇x : Tm.P (f x)) ⊃ P (lam f )

and let Γ be the union of all Γσ for all σ, then the sequent Σ | Γ −→ σ'D∀t : Tm.P (t) is valid for all σ'.
Standard classical logic.  The well-known Tarski-style semantics for classical logic is a special case of the above definition. Consider the case where there are no λ-tree types. By the syntactic restrictions, no ∇-quantification is allowed in
this case. Furthermore, L^ is just the category of sets. Hence, in this case, the
above definition of the satisfaction relation coincides with the well-known standard interpretation of classical logic.

Soundness
For soundness, we first show that the ∇-quantifier commutes with all the other logical connectives. With this property, the proof of soundness is a straightforward induction on derivations. The soundness proof of Miculan & Yemane [17] is similar.
Lemma 1.1 For any θ :Σ → Σ', we have σ Η(θ◦ρ),Σ' A ⇐⇒ σ Ηρ,Σ A[θ].
Proof. By induction on the structure of the formula A. The only interesting case is the base case, which follows because we have (θ ◦ ρ)(t)= ρ(t[θ]).	 
We show that ∇ commutes with the quantifiers, omitting the similar cases for the other connectives for space-reasons.
Lemma 1.2 The following equivalences hold.

Proof. We consider the case for the existential quantifier. The other case is dual.
σ Ηρ,Σ ∇x : ι. ∃y : τ. A ⇐⇒ σ, x : ι Ηρ[x/x],Σ,x: ι ∃y : τ. A
⇐⇒ exists e ∈ τ  (σ, x : ι) with σ, x : ι Ηρ[x/x,e/y],Σ,x: ι, y : τ A
Consider the substitution [h x/y]: (Σ, h : (ι → τ ), x : ι) → (Σ, x : ι, y : τ ). By use of the isomorphism i : τ  (σ, x : ι) ∼= ι → τ  σ, we obtain from e the element i(e) of ι → τ  σ. The interpretation of application in L^ is such that we have [h x/y] ◦ ρ[i(e)/h, x/x]= ρ[x/x, e/y]. Using the above lemma, we can continue as follows.
exists e ∈ τ  (σ, x : ι) with σ, x : ι Ηρ[x/x,e/y],Σ,x : ι, y : τ A
⇐⇒ exists e ∈ τ  (σ, x : ι) with σ, x : ι Ηρ[i(e)/h,x/x],Σ,h : (ι→τ ),x : ι A[h x/y]
⇐⇒ exists e' ∈ ι → τ  σ with σ, x : ι Ηρ[e'/h,x/x],Σ,h : (ι→τ ),x : ι A[h x/y]
⇐⇒ exists e' ∈ ι → τ  σ with σ Ηρ[e'/h],Σ,h : (ι→τ ) ∇x : ι. A[h x/y]
⇐⇒ σ Ηρ,Σ ∃h : (ι → τ ). ∇x : ι. A[h x/y]


Using this lemma, we obtain by induction on derivations:
Proposition 1.3 (Soundness) Any derivable sequent is valid.
Completeness
In this section we show that the well-known completeness argument for first-order logic, see e.g. [5,11], goes through almost unchanged.
Definition 1.4
A theory T is a set of closed formulae such that (· | T −→ A) implies A ∈ T

A theory T is syntactically consistent if · | T −→ ⊥ is not derivable.
A theory T is a Henkin Theory if, for each closed formula ∃x : τ. A(x), there exists a constant ·▶ c : τ such that (∃x : τ. A(x) ⊃ A(c)) ∈ T holds.
Lemma 1.5 Let T be a syntactically consistent theory for the signature S. There exists a signature S∗ extending S with countably many new constants and a the- ory T ∗ for the signature S∗, such that the following hold:
T ∗ is conservative over T;
T ∗ is a Henkin theory.
Notice that even though we are extending the signature with closed witnesses only, by  τ  (σ) ∼=  σ → τ  (·) we can reach all stages of the presheaves. Moreover, suppose we have ∇σ. ∃x : τ. A(x). This is equivalent to ∃h : ι → τ. ∇σ. A(h σ), so that we have a witness c making ∇σ. A(c σ) true.
Lemma 1.6 For any syntactically consistent theory T, there exists a maximally consistent extension T ∗ ⊇ T for which the following hold:
A /∈ T ∗ iff ¬A ∈ T ∗;
A ∧ B ∈ T ∗ iff A ∈ T ∗ and B ∈ T ∗;
A ∨ B ∈ T ∗ iff A ∈ T ∗ or B ∈ T ∗;
A ⊃ B ∈ T ∗ iff {¬A, B}∩ T ∗ /= ∅;
Lemma 1.7 If T ∗ is a maximally consistent extension of T and T is a Henkin theory then T ∗ is also a Henkin theory.
Lemma 1.8 Any syntactically consistent set Γ has a model.
Proof. Let T be the theory axiomatised by Γ and extend it to a maximally con- sistent Henkin theory T ∗. We define a model from T ∗. Base types are interpreted by τ  (σ) = {M | σ ▶ M : τ } and the presheaf action is given by substitution. A relation R : τ1 → ··· → τn → o is interpreted by
R  (σ)= {⟨t1,... , tn⟩| ∇σ. R(t1,... , tn) ∈ T ∗}	(1)
Notice that this presheaf R  only has to be closed under variable renaming, not under all substitutions. That it is indeed closed follows because ∇σ. R(t1,... , tn) is closed under α-conversion.
It remains to show that this definition does indeed define a model of T ∗. It suffices to show the equivalence · Ηρ,Σ A ⇐⇒ A[ρ] ∈ T ∗ for all stages σ, all contexts Σ, all formulae A in context Σ and all Σ-valuations ρ at stage σ. The assertion follows from this, since, by letting Σ be the empty context, it can be seen that each formula A ∈ T ∗ is valid in the above model.
The proof of the equivalence goes by induction on the number of logical connec- tives other than ∇ in a formula A. Since we have the well-known equivalences of

classical logic, we can restrict our attention to the connectives ¬, ∨ and ∃. We pro- ceed by case-distinction on the outermost connective in A. We show the base-case and the case for the existential quantifier. The other cases are similar.
A is ∇σ. R(t1,... , tn). Let ρ' = ρ[σ/σ]. Then we have:
· Ηρ,Σ ∇σ. R(t1,... , tn) ⇐⇒ σ Ηρ',(Σ, σ) R(t1,... , tn)
⇐⇒ ⟨ρ'(t1),... , ρ'(tn)⟩∈ R  (σ)
⇐⇒ ∇σ. R(t1[ρ'],... , tn[ρ']) ∈ T ∗
⇐⇒ (∇σ. R(t1,... , tn))[ρ] ∈ T ∗
A is ∇σ. B, where B is neither of the form ∇x : ι. C nor R(t1,... , tn). We consider the representative case where B is ∃x : τ. B'. Since the formula A is provably equivalent to ∃h. ∇σ. B[h σ/x], this case is handled by that for ∃ below.
A is ∃x : τ. B. From left to right, · Ηρ,Σ ∃x : τ. B gives e ∈ τ  · with · Ηρ[e/x],(Σ,x : τ ) B. By induction hypothesis this implies B[ρ[e/x]] ∈ T ∗. Using rule ∃-R, we de- rive · | T ∗ −→ (B[ρ][e/x]) ⊃ ((∃x : τ. B)[ρ]).	By maximality of T ∗, we get (∃x : τ. B)[ρ] ∈ T ∗.
From right to left, suppose (∃x : τ. B)[ρ] ∈ T ∗. Since T ∗ is a Henkin theory, there exists c ∈  τ  · such that ((∃x : τ. B)[ρ] ⊃ B[ρ][e/x]) ∈ T ∗. By modus po- nens and maximality, B[ρ][e/x] ∈ T ∗. By induction hypothesis, · Ηρ[e/x],(Σ,x: τ) B. By definition of Η, we get the required · Ηρ,Σ ∃x : τ. B.

Using this lemma, completeness now follows by a standard argument [5,11].
Proposition 1.9 (Completeness) Any valid sequent ·| Γ −→ A is derivable.

Part II
Models in Categories with Binding Structure
In Part I of this paper we have given a simple model of classical first-order logic with ∇ that is very close to classical Tarski-semantics. In the second part we generalise this result by giving a general notion of model in categories with binding structure. We describe these models in the language of categorical logic, which we assume the reader to be familiar with, see e.g. [14] for an introduction.
To simplify the presentation, we assume from now on that there is only a single λ-tree type Tm. In this case, the objects of L may be identified with finite sets. We write Tm also for the presheaf in L that interprets the type Tm.

Categories with Binding Structure
Categories with binding structure [20, Chapter 10] axiomatise binding in a general way. The definition of binding structure can be seen as a direct formalisation of the statement: ‘Working with an α-equivalence class is the same as working with a

freshly named instance’. This statement, expressing that two modes of working are equivalent, is being formalised directly as an equivalence of two categories (Def. 2.1). Let B be a category with finite limits and consider its internal language, i.e. the codomain fibration on B. The aim is to explain that constructions with ordinary judgements in the internal language of B are essentially the same as constructions
with judgements that may make use of a fresh name. To formalise ‘judgements with a fresh name’ we use the glueing construction, see e.g. [24]. Given an endofunctor U on B, consider the pullback as in the left diagram below. In this diagram, B→ has as objects the morphisms of B, and a morphism in B→ from f : A → B to g : C → D is a pair ⟨u : A → C, v : B → D⟩ of B-morphisms for which v ◦ f = g ◦ u holds. The functor cod maps objects to their codomain and morphisms ⟨u, v⟩ to v. The category B/U has as objects the B-morphisms of the form f : A → UB. Its morphisms from f : A → UB to g : C → UD are pairs ⟨u : A → C, v : B → D⟩ of B-morphisms for which Uv◦f = g◦u holds. The functor Gl (U ) maps f : A → UB to B and ⟨u, v⟩ to v. Both cod and Gl (U ) are fibrations. There is an canonical functor WU : B→ → B/U making the triangle on the right below commute. Specifically, WU maps an object f : A → B to Uf : UA → UB.


B/U 	 B →
B→ 	WU	 B /U

_
Gl (U )

cod
¸¸¸¸
cod ¸¸¸¸
   
  Gl (U )

J	J 
z ,s 

B	U	 B	B

We use the glued fibration Gl (−⊗ V ) for talking about judgements with a fresh name, where ⊗ is a monoidal structure and V is an object of B. The intuition is that A ⊗ B consists of pairs whose components do not share names, and V is an object of names. Then, the functor W(−⊗V ) adds a fresh name to a judgement. We write short WV for it.
With this notation, the definition of a category with binding structure is simple:
Definition 2.1 A category with binding structure is a triple (B, ⊗,V ) consisting of a category B with finite limits, a monoidal structure ⊗ on B and an object V of B, such that the functor W(−⊗V ) is an equivalence of fibrations.
Instances of categories with binding structure are given in [20, Chapter 10]. A prime example is the category of nominal sets (also known as the Schanuel topos, or FM-Sets) [7], where A ⊗ B = {⟨a, b⟩: A × B | a#b} and V is the set of atoms.
To understand the motivation for Def. 2.1, recall that in categorical logic existen- tial quantification is modelled by a left adjoint to weakening and, dually, universal quantification is modelled by a right adjoint to weakening. The functor WV can be thought of as a non-standard ‘weakening’ functor. Since it is an equivalence, there is a functor H that is both left and right adjoint to WV . By the view of quantifiers as adjoints to weakening, H can be viewed as a non-standard quantifier that is both an existential and a universal quantifier at the same time. It can be shown that H di- rectly generalises the new-quantifier  of Gabbay & Pitts. The defining feature of H

is that it preserves all categorical constructions, e.g. H(A ⇒ B) ∼= (HA) ⇒ (HB), which follows because H is part of an equivalence. This suggests a relation to ∇, which has the same defining feature, e.g. ∇x. (A ⊃ B) ∼= (∇x. A) ⊃ (∇x. B).
In [21] and [20], the structure of categories with binding structure used as the basis of a dependent type theory.
Categories with binding structure have rich structure, see [20, Chapter 10]. The properties we use in this paper are given by the next three propositions from [20].
Proposition 2.2 For each category with binding structure (B, ⊗,V ), there exists a functor : Sub(Γ ⊗ V ) → Sub(Γ) that is left and right adjoint to WV : Sub(Γ) → Sub(Γ ⊗ V ).
In the statement of this proposition we have used the fact that WV , being a right adjoint, preserves monomorphisms and so restricts to a functor on subobjects.
Proposition 2.3 In each category with binding structure (B, ⊗,V ), the functor (−) ⊗ V has a right adjoint V  (−), which itself has a further right adjoint. We write ε⊗ for the co-unit of the adjunction (−) ⊗ V E V   (−).
If B is the category of nominal sets then (V  X) is (isomorphic to) the abstraction set [A]X of Gabbay & Pitts. The application map (V  X) ⊗ V → X amounts to the concretion operation x@a. The binding operation, mapping a ∈ A and x ∈ X to a.x ∈ [A]X with a#(a.x) and (a.x)@a = x, is given by β in the next proposition.
Proposition 2.4 In each category with binding structure (B, ⊗,V ), there is a nat- ural transformation β : ((−) ⊗ V ) × A → ((−) × (V A)) ⊗ V making the following diagram commute for all objects Γ.
(Γ ⊗ V ) × A ¸¸¸

π1  ,,,,
,,,,	βΓ
¸¸¸¸¸¸¸ π2
¸¸¸¸¸¸¸

 ,  ,	J 
⊗	(Γ ×	⊗ V
(V   A) ⊗
¸¸¸¸¸¸z 

¸,
π1⊗id
(V   A))


π2⊗id
V	 A 
ε

This proposition has its origin in the work of Menni [16].
Modelling ∇ in a Category with Binding Structure
As in Part I, we interpret the λ-calculus in L^. As outlined in the introduction, the internal logic of this category is not appropriate for modelling a logic with the ∇-quantifier. Instead, we use the internal logic of a category with binding structure B, which we transfer to L^ by reindexing along a functor F : L^ → B, as in the following change-of-base situation. This idea has been used with different categories by Hofmann [12] to model the Theory of Contexts [13], see also [3].


E	 Su b(B)
_
p	sub
J	J 
L^	 B 
(2)

We need the subobject logic on B to be strong enough to provide a model for at least first-order logic. Hence, we assume sub to be a first-order fibration:
Definition 2.5 A fibration q : E → B is a ﬁrst-order ﬁbration if the following hold.
Each fibre EΓ is a preorder with finite products (T, ∧), coproducts (⊥, ∨) and exponents (⊃).
For each map u : Γ → Δ, the reindexing functor u∗ has a left adjoint ∃u that satisfies the Beck-Chevalley and Frobenius conditions.
For each map u : Γ → Δ, the reindexing functor u∗ has a right adjoint ∀u that satisfies the Beck-Chevalley condition.
We refer to e.g. [14] for a definition of the Beck-Chevalley and Frobenius conditions. To model ∇-logic in the fibration p defined in (2), we use the following structure.
Definition 2.6 A ∇-model consists of a category with binding structure (B, ⊗,V ) and a functor F : L^ → B with the following additional structure.
The subobject fibration on B is a first-order fibration.
The functor F preserves finite limits and has a right-adjoint. We use the notation δA,B : FA × FB → F (A × B) for the natural isomorphism witnessing product-preservation of F .
There are a distinguished morphism η : V → FTm and natural transformations ı : FA ⊗ FB → FA × FB and θ : (V   F A) → F (Tm ⇒ A) in B for which the following diagram commutes.
(V   F A) ⊗ V   θ⊗id	 F (Tm ⇒ A) ⊗ V  fTm⇒A  F ((Tm ⇒ A) × Tm)
Fε⊗	Fε 
J	J 
FA	FA 
Here, fTm⇒A is part of the natural transformation f : F (−)⊗V → F ((−)×Tm) defined by F Γ ⊗ V  ı	 F Γ × V  id×η  F Γ × FTm  δ  F (Γ × Tm).
Using η we can map abstract variables in V into the object FTm, which encodes the object-level syntax. The morphism θ and thes diagram relate binding in the category with binding structure to higher-order abstract syntax.
Next we study the structure of the fibration p in (2). We may assume that the pullback (2) is constructed such that the fibre EA over an object A in L^ is the partial order Sub(F A) of subobjects on FA in B. Given u : Γ → Δ in L^, the reindexing functor u∗ : EΔ → EΓ for p is given by (Fu)∗ : Sub(F Δ) → Sub(F Γ) for sub. It is well-known that the structure of a first-order fibration is preserved under reindexing along a functor F that preserves finite limits and has a right adjoint [12].
Proposition 2.7 The functor p : E → L^ is a ﬁrst-order ﬁbration.
We remark that this proposition can be extended to higher-order logic [12], and all the concrete models that we consider in this paper are indeed models of higher-

order logic. This means that it is straightforward to extend our results to defining an interpretation of the type o and to validating higher-order logic.
Definition 2.8 For each object Γ of L^, define the functor ∇Γ : EΓ×Tm → EΓ to be the functor f ∗ : Sub(F (Γ × Tm)) → Sub(F Γ).
This definition captures the quantification over some/any fresh variable of type Tm. Since u∗∇Δ = ∇Γ(u×id )∗ holds for all u : Γ → Δ in L^, it is justified to write just ∇. Now we come to the central property of ∇: it commutes with existential and
universal quantification. This is given by the following generalisation of Lemma 1.2.
Lemma 2.9 For each Γ in L^, we have ∇∃A = ∃Tm⇒A∇s∗ and ∇∀A = ∀Tm⇒A∇s∗, where s is the map ⟨π1 × id,ε ◦ (π2 × id )⟩: (Γ × (Tm ⇒ A)) × Tm → (Γ × Tm) × A.
We remark that to prove this lemma, we make essential use of the binding map β, for moving from a quantification over A to one over (Tm ⇒ A).
With the evident translation of formulae in the structure of the first-order fibra- tion p, we now have the following soundness result for the intuitionistic version of the sequent calculus. With Lemma 2.9, the proof is a straightforward induction.
Proposition 2.10 For any sequent Σ | Γ −→ A provable in the intuitionistic se- quent calculus, there is a morphism Γ  → A  in E  Σ .
In the next section we give concrete examples of ∇-models. These examples do, in fact, all validate classical logic.
Instances of the Interpretation
Linear Species. The semantics in Part I is an explication of the interpretation in a
∇-model of linear species. The category of linear species [1] is the presheaf category Cˆop, where C is the category of finite totally ordered sets with order-preserving bijections. Along the lines of [20, Prop. 10.3.13], Cˆop can be seen to be a category with binding structure. The object V is the presheaf with V {x} = {x} and Vσ = ∅ if |σ| /= 1. The set (A ⊗ B)σ consists of pairs ⟨x ∈ Aσ1,y ∈ Bσ2⟩ with σ = σ1, σ2. Then, the set (V  A)σ is isomorphic to A(σ, x).
To obtain a ∇-model in Cˆop, we take F : L^ → Cˆop to be the canonical inclusion, arising because each presheaf in L^ is all the more a presheaf in Cˆop. For the map η : V → FTm, we take the inclusion function that maps the variable x ∈ V {x} to the term x : Tm in (FTm){x} = {t | x : Tm ▶ t : Tm}. Finally, we define the map θ : (V   F A) → F (Tm → A) to be the isomorphism arising from (V   F A)σ ∼= F A(σ, x) in Cˆop and (Tm → A)σ ∼= A(σ, x) in L^. Because the functor F is so simple, the conditions of Def. 2.6 are straightforward to verify.
A convenient way of working with the internal language of a topos is the Kripke- Joyal semantics, see e.g. [15]. When spelled out for the linear species model, the Kripke-Joyal semantics specialises exactly to the satisfaction relation Η from Sect. 1.3 (Theorem VI.7.1 of [15]). We should say, however, that the notion of va- lidity in Sect. 1.3 differs from the standard notion of validity from categorical logic.

Although Part I can be adapted for the standard notion of validity, we have opted for the non-standard definition, since it matches better with existing work on FOλ∇. Species. Very similar to the model in linear species is that of ordinary species of
structures. In this case, B is the presheaf category Dˆop, where D is the category of
finite sets and all bijections. This model differs from the model in linear species in that the local λ-tree contexts are unordered. As a consequence, this model validates the equivalence ∇x. ∇y. B(x, y) ⊃⊂ ∇y. ∇x. B(x, y). Just as for linear species, the interpretation in Dˆop can be described in the style of Part I. We expect that the completeness argument can be adapted to this case.
Nominal Sets. The prototypical instance of a category with binding structure is the category of nominal sets S, also known as the Schanuel topos, see [20, Chapter 10]. The category S provides an instance of Def. 2.6 if we take F : L^ → S to be the composite of the inclusion functor I : L^ → I^op, where I is the category of finite sets and injections, with the sheafification functor a: I^op → S with respect to the atomic topology on Iop. We refer to e.g. [10,15] for more information on this situation.
We use the notation of Gabbay & Pitts [7] to describe the structure of S. Specif- ically, we take V to be the object of atoms A, and we use the freshness monoidal structure A ⊗ B = {⟨a ∈ A, b ∈ B⟩| a#b}. In S, the functor L(X)= A + (X × X)+ [A]X  has  an  initial  algebra  [var, app, lam]: L(T )  →   T  that can be used to represent untyped λ-terms. It can be shown that FTm is iso- morphic to T , by observing that ITm is already a sheaf. We take η : V → FTm
to be the map V = A v→ar T ∼= FTm. We have to omit the definition of θ for space
reasons.
The interpretation of ∇ in S provides a translation of ∇-logic to Nominal Logic, since the internal logic of S is (a version of) Nominal Logic. The translation is similar to that described by Gabbay & Cheney in [6]. In particular, the definition of the functor ∇ in Def. 2.8 is such that ∇x. ϕ(x, y) is interpreted as n. ϕ  (η(n), y), which agrees with the interpretation in [6]. As observed by Gabbay & Cheney, the interpretation in S is not complete: it validates ∀x. ϕ ⊃ ∇x. ϕ and ∇x. ϕ ⊃ ∃x. ϕ.

Conclusion and Further Work
We have explained a simple sound and complete model for classical FOλ∇, and we have worked towards identifying the essential structure of ∇ by giving an abstract model in categories with binding structure. We have shown that ∇ and can be modelled by the same concept of binding.
In further work, the semantics of intuitionistic FOλ∇ should be studied. A starting point in this direction is Cheney’s sound and complete translation from FOλ∇ into intuitionistic nominal logic [4] together with Gabbay’s complete model for intuitionistic nominal logic [8]. Perhaps the semantics from Part I can also be generalised directly to a Kripke-style model.
Regarding other related work, we conjecture that the model for FOλ∇ of Micu- lan & Yemane [17] fits in the general construction of Part II, but the details remain

to be worked out. Finally, a-logic, proposed by Gabbay & Gabbay [9], has an infor- mal explanation that appears to be quite similar to our explanation of FOλ∇, and it would be interesting to make precise the relationship.

Acknowledgement
I thank Ian Stark, Marino Miculan, James Cheney and Lennart Beringer for dis- cussions and the referees for their comments. In particular, Ian suggested to use presheaves over finite sets with bijections.

References
F. Bergeron, G. Labelle, and P. Leroux. Combinatorial Species and Tree-like Structures. Cambridge University Press, 1997.
J. Brotherston. Cyclic proofs for first-order logic with inductive definitions. In TABLEAUX’05, volume 3702 of LNCS, pages 78–92. Springer-Verlag, 2005.
A. Bucalo, M. Hofmann, F. Honsell, M. Miculan, I. Scagnetto. Consistency of the Theory of Contexts.
In Journal of Functional Programming, 16(3):327–395, 2006
J.R. Cheney. A simpler proof theory for nominal logic. In FOSSACS 2005, number 3441 in LNCS, pages 379–394. Springer-Verlag, 2005.
D. van Dalen. Logic and Structure. Springer Verlag, Berlin, 1983.
M.J. Gabbay and J.R. Cheney. A sequent calculus for nominal logic. In LICS 2004, pages 139–148. IEEE Computer Society Press, 2004.
M.J. Gabbay and A.M. Pitts. A new approach to abstract syntax with variable binding. Formal Aspects of Computing, 13:341–363, 2002.
Murdoch J. Gabbay. Fresh Logic. Pending publication, July 2003.
Murdoch J. Gabbay and Michael J. Gabbay. a-logic. In We Will Show Them: Essays in Honour of Dov Gabbay, volume 1. College Publications, 2005.
F. Gadducci, M. Miculan, and U. Montanari. About permutation algebras, (pre)sheaves and named sets. In Higher Order and Symbolic Computation, 2006.
H. Herre. Logik. Lecture Notes, University of Leipzig, 1999.
M. Hofmann. Semantical analysis of higher-order abstract syntax. In LICS’99, 1999.
F. Honsell, M. Miculan, and I. Scagnetto. An axiomatic approach to metareasoning about nominal algebras in HOAS. In ICALP01, 2001.
B. Jacobs. Categorical Logic and Type Theory. Elsevier Science, 1999.
S. Mac Lane and I. Moerdijk. Sheaves in Geometry and Logic: A First Introduction to Topos Theory. Springer-Verlag, 1992.
M. Menni. About -quantifiers. Applied Categorical Structures, 11(5):421–445, 2003.
M. Miculan and K. Yemane. A unifying model of variables and names. In FOSSACS’05, volume 3441 of LNCS, pages 170–186. Springer-Verlag, 2005.
D. Miller and A. Tiu. A proof theory for generic judgments. ACM Transactions on Computational Logic, 6(4):749–783, 2005.
A.M. Pitts. Nominal logic, a first order theory of names and binding. Information and Computation, 186:165–193, 2003.
U. Sch¨opp. Names and Binding in Type Theory. PhD thesis, University of Edinburgh, 2006.


U. Sch¨opp and I. Stark. A dependent type theory with names and binding. In CSL’04, volume LNCS of 3210, pages 235–249. Springer-Verlag, 2004.
M.R. Shinwell. The Fresh Approach: functional programming with names and binders. PhD thesis, University of Cambridge, 2005.
M.R. Shinwell and A.M. Pitts. On a monadic semantics for freshness. Theoretical Computer Science, 342:28–55, 2005.
P. Taylor. Practical Foundations of Mathematics. Cambridge University Press, 1999.
A. Tiu. A logic for reasoning about generic judgements. In LFMTP’06, 2006.
