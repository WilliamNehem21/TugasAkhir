Electronic Notes in Theoretical Computer Science 176 (2007) 61–78	
www.elsevier.com/locate/entcs

Partial Order Reduction for Rewriting Semantics of Programming Languages
Azadeh Farzan and Jos´e Meseguer 1
Computer Science Department University of Illinois at Urbana-Champaign
Urbana, USA

Abstract
Software model checkers are typically language-specific, require substantial development efforts, and are hard to reuse for other languages. Adding partial order reduction (POR) capabilities to such tools typically requires sophisticated changes to the tool’s model checking algorithms. This paper proposes a new method to make software model checkers language-independent and improving their performance through POR. Getting the POR capabilities does not require making any changes to the underlying model checking algorithms: for each language L, they are instead achieved through a theory transformation RL '→ RL+POR of L’s formal semantics, rewrite theory RL. Under very minimal assumptions, this can be done for any language L with relatively little effort. Our experiments with the JVM, a Promela-like language and Maude indicate that significant state space reductions and time speedups can be gained for tools generated this way.
Keywords: Partial order reduction, model checking, programming language semantics, rewriting logic, Maude.


Introduction
This paper proposes a new method to make software model checking tools language- independent; and to substantially improve their performance using partial order re- duction (POR) (see, for example, [22,14,15,25,1,12,3,18]). The key insight of POR is that the state space explosion caused by the many interleaving computations of a concurrent program can be tamed using the fact that many such computations are semantically equivalent, because they are different descriptions of the same partial order of events. This means that only a representative subset of all the interleaving computations has to be model checked, without losing completeness: the model checking results are the same as if all computations had been analyzed, but perfor- mance can thus be greatly increased.

1 Email: {afarzan,meseguer}@cs.uiuc.edu

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.06.008

Although the theoretical foundations of POR are very general and can be applied to many different languages, at present POR-enabled software model checkers are typically language-speciﬁc: they typically only work for programs in a particular language such as Java, C, Promela, and so on. One exception to this common situation is the Verisoft tool [15]. However, Verisoft is applied in practice to a limited family of languages. The question this paper raises and presents an affirmative answer to is: can POR-enabled software model checking tools become language- independent in the strong sense of being generic, that is, being applicable not just to a few, but to an unlimited class of languages satisfying some very basic abstract requirements?
This work is part of a broader research effort to develop a range of generic soft- ware analysis tools based on formal semantic deﬁnitions of programming languages [20,21]. The tools are generic (i.e., language-independent) because their specializa- tion to each particular language, say Java, is based on providing the generic tool with an executable formal semantics of the language in question. We use rewriting logic [19] as a semantic framework, because the distinction between equations and rules in a rewrite theory provides powerful abstraction capabilities [21], and also because its high-performance Maude implementation and tools [5,7] offer a good basis for developing efficient generic tools that have competitive performance.
Within this larger research effort this paper gives an answer to the question of how POR capabilities can likewise be made generic at the tool level. The practical advantages of our approach come from the fact that the prevalent way of developing a software model checker for a specific programming language is a labor-intensive process often requiring man-years of effort; and that language-specific checkers are typically hard to reuse for other languages. Furthermore, adding POR capabili- ties to a language-specific model checker typically requires sophisticated changes to the tool’s model checking algorithms. By contrast, our generic method can be specialized to any particular language of choice in a few weeks, including the time of developing the formal semantic definition of the chosen language (e.g., Java). In particular, the specific task of adding the POR capabilities to the tool thus obtained can be accomplished in a few hours.
Our method is based on a theory transformation RL '→ LR+POR in which the original rewrite theory RL specifying the semantics of the language L is transformed into a stuttering equivalent rewrite theory RL+POR that accomplishes the desired partial order reduction when used for model checking a given program. This theory transformation approach means that no changes to the underlying model checker are needed to achieve the desired partial order reduction, which is one of the reasons why developing a POR-enabled LTL model checker for a language L using our method requires such little effort. Besides its genericity and short development time, our method has two additional advantages:
Flexible Partial Order Heuristic Algorithm. The heuristic algorithm can be specified using a few equations. Although our basic version of the heuristic can in principle work for any programming language, additional optimizations, based on specific knowledge of the given programming language or of the types of programs

to be verified, can make the POR reduction considerably more efficient. The tool builder can easily customize the heuristic algorithm, which compares favorably with having to change the source code of a model checker.
Flexible Dependence Relation. Although a basic dependence relation can gen- erally hold for a certain programming language, additional knowledge of the types of programs that one needs to verify can result in removing some dependencies; for example, Java supports shared memory in general, so we have to assume that memory read/write pairs are generally interdependent; but if the programs being verified do not use the shared memory at all, we can remove this dependency for such programs. Having the dependence relation as an explicit parameter of the par- tial order reduction module not only contributes to the generality of the method, but also gives the tool builder the advantage of specializing it, based on the type of input programs.
Our generic theory transformation assumes a simple basic interface of function- ality in the language L. This allows a first phase of automatic transformation of the theory RL. But this can be followed by a second language-speciﬁc customization phase supporting features 1–2 above. This can be easily accomplished by adding or customizing a few equations in this second phase, so that detailed knowledge of L’s semantics can be used to optimize the reduction; for example, by optimizing the heuristic algorithm and/or by defining a more precise dependence relation using static analysis techniques.
Besides developing its theoretical foundations and establishing its correctness, the practical usefulness of a generic method like the one we propose should be eval- uated experimentally. Therefore, we have developed a prototype tool in Maude that, given an original semantics of a language L specified as a rewrite theory RL, performs the theory transformation RL '→ LR+POR and can be used to model check LTL properties of programs in L using Maude’s generic LTL model checker. We have applied this prototype to the rewriting semantics of the Java bytecode, a simple Promela-like language, and Maude; and have evaluated the performance of our POR methods for these languages using several benchmarks. The goal of this prototype and experimentation is a proof-of-concept one. Therefore, we have not incorporated a number of well-known optimizations that a mature tool should sup- port. Nevertheless, our experiments indicate that, even without such optimizations, substantial gains in time and space can be obtained using our POR method.
The rest of the paper is organized as follows: Section 2 contains the back- ground needed in Section 3, where we discuss the generic method in detail; Section 4 presents the experimental results including the instantiation of the method for the Java bytecode and for a Promela-like language, as well as presenting some performance figures; and Section 5 discusses related work, conclusions, and future directions.

Preliminaries
Rewriting Logic Language Speciﬁcation
The rewriting logic semantics of a programming language [20] combines and ex- tends both equational/denotational semantics based on semantic equations, and structural operational semantics (SOS) based on semantic rules. Given a pro- gramming language L, its rewriting logic semantics is defined as a rewrite theory RL = (ΣL, EL, RL), with ΣL a signature specifying both the syntax of L and of op- erations on auxiliary semantic entities like the store, environment, and so on, with (ΣL, EL) an equational theory specifying the semantics of the sequential features of L, and with RL a collection of (possibly conditional) rewrite rules specifying the semantics of L’s concurrent features. Under the assumption that RL is coherent [26], equations in EL (corresponding to execution of sequential features) are applied until reaching a canonical form, and then rules in RL (corresponding to execution of concurrent features) are applied. This key distinction between equations and rules immediately gives the advantage of reductions similar to those in [24]. The invisible states in [24] are closely related to the reduction steps done by equations in EL. Only when no more equations from EL apply to the state, does a rewrite with a rule in RL take place. This makes any sequence of sequential instructions in a thread to be executed as an atomic block, without any interleavings. Note that this kind of state reduction is available at the level of the original semantics RL; what is now further needed, which is the topic of this paper, is to achieve an additional POR state space reduction by reducing the state explosion due to the execution of concurrent features.
Specifying formally the semantics of a concurrent programming language L in the Maude rewriting logic language not only yields a language interpreter for free, but also, thanks to the generic analysis tools for rewriting logic specifications that are provided as part of the Maude system [4], additional analysis tools are also automatically provided for L, including a semi-decision procedure to find failures of safety properties, and an LTL model checker. There is already a substantial experience on the practical use of such language definitions and the associated analysis tools for real languages such as Java, the JVM, and a substantial subset of OCaml [20,11,9].
Background on Partial Order Reduction
A ﬁnite transition system is a tuple (S, S0,T, AP, L), where S is a finite set of states, S0 ⊆ S is the set of initial states, T is a finite set of transitions such that α ∈ T is a partial function α : S → S, AP is a finite set of propositions and L : S → 2AP is the labeling function. A transition α is enabled in a state S if α(s) is defined. Denote by enabled(s) the set of transitions enabled in s. The main goal of partial order reductions is to find a subset of enabled transitions ample(s) ⊆ enabled(s) that is used to construct a reduced state space that is behaviorally equivalent. Partial order reduction is based on several observations about the nature of concurrent computations. The first observation is that concurrent transitions

are often commutative, which is expressed in terms of an independence relation, I ⊆ T × T , that is, a symmetric and anti-reflexive relation which satisfies the following condition: for each (α, β) ∈ I, and for each state s, if α, β ∈ enabled(s) then: (1) α ∈ enabled(β(s)) and β ∈ enabled(α(s)), and (2) α(β(s)) = β(α(s)). Note that D = (T × T )\I is the dependence relation. The second observation is that in many cases only a few transitions can change the value of the propositions, which suggests the concept of visibility; a transition α ∈ T is invisible if for each s ∈ S, if s' = α(s) then L(s) = L(s').
There are several existing heuristics to compute ample(s). [2] gives a set of four conditions that, if satisfied by ample(s), guarantee a correct reduction of the given state transition system. In Section 3.3, we present a special case of the conditions in [2] which are used in this paper.

Partial Order Reduction for Language Definitions
Some Assumptions
In order to devise a general partial order reduction module for semantic definitions of concurrent programming languages, we have to make some basic assumptions about these semantic definitions. These assumptions are quite reasonable and do not limit in practice the class of semantic definitions that we can deal with. They simply specify a standard interface between the semantic definition module and the partial order reduction module. We can enumerate these assumptions as follows:
(1) In each program there are entities equivalent to threads which can be uniquely identified by a thread identiﬁer. The computation is performed as the combination of local computations inside individual threads, and communication between these threads through any possible discipline such as shared memory, synchronous or asynchronous message passing, and so on. (2) In any computation step (transition) a single thread is always involved. In other words, threads are the entities that carry out the computations in the system.
The Theory Transformation
The rewrite theory RL = (ΣL, EL, RL) specifying the semantics of a concurrent programming language L is transformed in two steps into the semantically equivalent theory RL+POR = (ΣL+POR, EL+POR, RL+POR) that is equipped with partial order reduction capabilities.

The Marked-State Theory.
The objective of the first step of this transformation is to change the original theory RL in order to facilitate the addition of the partial order module. In the transformed theory R^L = (Σ^L, E^L, R^L): (1) the rewrite rules of RL are changed syntactically to only allow one-step rewrites, and (2) the structure of the states of R is enriched to allow a specific thread to be marked as enabled. Rewrite rules are then modified to only allow the threads that are marked enabled to make a transition.

This way, when the POR heuristic decides on an ample set, the corresponding threads can be marked as enabled, and this causes only the ample transitions to be explored next. Here we give a detailed construction of R^L and show that RL and R^L are one-step bisimilar.
We assume that RL is coherent [26] and that all rules in RL are of the form l(u(t)) −→ r(u'(t)) where terms l and r are of sort State, and where the subterms u(t) and u'(t) are thread expressions of sort Thread, and t is variable ranging over thread identifiers of sort Tid. Note that based on the assumptions we made (see Section 3.1), there is going to be exactly one such thread expression u(t) on either side of a rule. We also assume that the equations in EL are thread-preserving, that is, in any two state expressions equated by EL both must have the same number of thread expressions and there is a bijective correspondence between such thread expressions preserving their thread identifiers.
We define Σ^ L by adding fresh new sorts: MState and MThread. A new con- structor enabled : Thread Bool −→ MThread is introduced for the sort MThread to instrument threads with this additional flag that allow us to mark them as enabled or not for the next execution step. The use of the sort Thread in all state construc- tors is everywhere replaced by the sort MThread. We also add two unary operators
{ }, [ ] : State −→ MState. The equations in E^L are systematically derived from
those in EL by replacing in each equation in EL each occurrence of a thread ex- pression u(t) by the expression enabled(u(t), bt), where bt is a fresh new variable of sort Bool depending on t. For every rewrite rule l(u(t)) → r(u'(t)) if C in RL, the corresponding rewrite rule in R^L is then of the form {Ct(l(enabled(u(t), true))}→ [Ct(r(enabled(u'(t), true)))] if C^, where Ct(.) is the context expression for the ap- plication of the rule in case r does not rewrite the entire state but only a state fragment 2 , and where C^ is the conjunction of equations obtained from C by chang- ing each equation in C containing thread expressions as done in the definition of E^L, and leaving all other equations untouched. Note that the use of the operators
{ }, [ ] in the rules in R^L means that in R^L only one-step rewrites are possible, since
the operator [ ] in the right-hand side blocks the application of any further rules.
As an example of the above transformation, consider the following rewrite rule specifying the semantics of the monitorenter instruction of Java bytecode:
rl < T: JavaThread | callStack:([PC, monitorenter, Pgm, ..., (REF(K) # OperandStack), ...] CallStack), ... > < O : JavaObject | Addr: K,
..., Lock: Lock(OIL, NoThread, 0) > => < T: JavaThread | callStack: ([PC + 2, Pgm(PC + 2), Pgm, ..., OperandStack, ...] CallStack),
... > < O: JavaObject | Addr: K, ..., Lock: Lock(OIL, T, 1) > .
the transformed rewrite rule has the following form:
rl { enabled( < T:JavaThread | callStack:([PC, monitorenter, Pgm, ..., (REF(K) # OperandStack), ...] CallStack), ... >, true) < O:JavaObject
| Addr:K, ..., Lock:Lock(OIL, NoThread, 0) > Ct } => [ enabled(
< T: JavaThread | callStack: ([PC + 2, Pgm(PC + 2), Pgm, ..., OperandStack, ...] CallStack), ... >, true) < O: JavaObject | Addr: K, ..., Lock: Lock(OIL, T, 1) > ] .


2 If the rule r rewrites the global state of the computation, the context Ct(.) is empty, i.e. Ct(l(u)) = l(u). We do however allow language specifications in which a rule r can be local to some fragment of the state. In this second case, it is important to make explicit a pattern Ct(.) for the context in which the rule is applied.

The key point about the transformation RL '→R^L is then:
Proposition 3.1 The surjective projection π mapping terms of sort MState to terms of sort State deﬁned by: (1) erasing the operators { }, [ ], and (2) erasing the enabled operators, the corresponding flags and the context expression deﬁnes a one-step bisimulation between the corresponding rewrite theories.
That is, if we have a one-step rewrite u → v with R^L, then we have also a corresponding one-step rewrite π(u) → π(v) with RL; and conversely, if we have a one-step rewrite u' → v' with RL, then we can find u ∈ π−1(u') v ∈ π−1(v') such that we have a one-step rewrite u → v with R^L (see [10] for proof).

The Partial Order Reduction Theory.
In the second step, the theory R^L = (Σ^L, E^L, R^L) is transformed into RL+POR = (ΣL+POR, EL+POR, RL+POR) which adds to R^L the partial order reduction module. Components of the transformed theory are defined based on the components of R^L as follows:
ΣL+POR = Σ^ L ∪ ΣPOR ∪ ΣAUX, that is, the signature Σ^ L is extended with the signature ΣPOR of operators used in implementing the partial order heuristic algorithm, plus the signature of auxiliary operators ΣAUX that are used for im- plementation purposes.
EL+POR = E^L ∪ EPOR ∪ EAUX, that is, the set of equations E^L are extended with the equations EPOR which specify the partial order heuristic algorithm, plus the equations EAUX which define the auxiliary operators.
RL+POR = R^L ∪ {rstep}. In the case of the rewrite rules, only one new rewrite rule is added. We label this rule as step. It is the only rule applicable to the new state, and therefore the only rule which will determine the transitions of the system at a given state.

The New State.
There is a new fresh sort PState, as part of ΣPOR, representing the new state of the system. A new sort StateInfoSet also belongs to ΣPOR, capturing all the infor- mation necessary for the reduction algorithm (see Section 3.3). A new constructor operator { | } : MState StateInfoSet −→ PState is introduced for the new state. Therefore, a state in RPOR is a pair {s|I}, where s is a state in R^L, and I is a term containing information necessary for the reduction algorithm.

The New Rule (step).
A single new conditional rule rstep in RL+POR simulates one step rewrites of the original system:
step : {s|I}→ [s'|I] if s → s' ∧ s /= s'
where s and s' are variables of sort MState, and the operators { | } and [ | ] are state constructors for the sort PState and are frozen operators [4], that is, no rewriting

is allowed below these operators. I is a variable of sort StateInfoSet. By using this single rewrite rule, only one rewrite at a time can happen, which changes the given state to one of its successor states. Since the resulting state is in [ | ] format, no rewrite rule is applicable to it anymore, until it is changed to the { | } format. This is the point at which the partial order heuristic algorithm is applied, using an equation that completes the effect of the above rule:
[s | I]= {state(MarkAmples(s, I)) | stateInfo(MarkAmples(s, I))}.	(∗)
The partial order reduction is applied at state s, using the information in I, by means of a single operation MarkAmples. This operation takes a pair of elements of sorts MState and StateInfoSet as an input, and returns a pair of the same sort. The MarkAmples operation computes the ample set for the current state and returns the state with the ample transitions marked as specified by the POR algorithm. It also returns an updated version of StateInfoSet (see the POR algorithm part of Section 3.3). In the next section, we discuss in detail how the MarkAmples operations is specified.

The Partial Order Reduction Module
This module performs two main tasks: (1) extracting the set of enabled transitions at a given state, and (2) finding an ample subset of these transitions.
First, we have to define a transition in this context. Having the rewriting se- mantics (ΣL, EL, RL) of a concurrent programming language L, one can view the initial state of the system (a program and its inputs) as a ΣL-term t being rewritten by the equations EL and the rewrite rules RL of the specification.
In a state transition system, a given state s has a set of immediate successor states {s1, s2,... , sk}, and each pair (s, si) is an enabled transition from state s. In the rewriting semantics, state s is a term, and the set of enabled transitions leading to successor states can be represented as a set of pairs (ri, pj), where ri ∈ RL and pj is a position in term s. In other words, if a certain rule ri : l(u) → r(v) is enabled at a position pj in term s, then we have a transition from s to its successor s[l(u)\r(v)].
In general a position p can be any position in the term tree. However, in our special case of semantics of concurrent programming languages together with the general assumptions discussed in Section 3.1, a thread identiﬁer will uniquely specify a position, since we have assumed that a single thread is involved in each rewrite. Therefore, a pair (ti, rj) consisting of a thread identifier ti together with an ap- plicable rule rj uniquely characterizes a transition. This gives us a considerable practical advantage; because when the algorithm decides on an ample subset of the transitions, it suffices to mark the corresponding threads as enabled (see Section 3.1), which makes it unnecessary for all the unmarked threads (transitions) to be explored. Note that in the transformed theory, although the only rule applied to the state of the system is the rule step, in fact an application of step always simulates some rewrite rule ri from the original system, and it is that rule that we consider

in the above pair.
Extracting Enabled Transitions
As discussed above, a transition is a pair (ti, ri) of a thread identifier and a rewrite rule. We can add a third component Ik to this tuple, which includes all the informa- tion about context (i.e., names of variables, functions, locks, ...). This information can later help resolving some dependencies between the transitions, which may re- sult in fewer dependencies and possibly in a better reduction.
At a given state s, we have to find all pairs (ti, rj : l(u) → r(v)) where the rewrite rule rj is enabled for the term s at the position associated with the thread ti. In other words, we have to go over all the rewrite rules rj ∈ RL and find all the positions at which rj can be applied to the term s. To do this, we generate a new set of equations, based on the rewrite rules in RL, with exactly one equation per rule in the following manner. Let us assume that a rewrite rule r ∈ R^L is of the following general form:
r : {l(u(t))} => [r(u'(t))] if C
where u(t) and u'(t) are subterms of sort Thread, t is a variable of sort Tid, and C
is the rule’s condition. The corresponding equation for r is then:
⟨Te, l(u(t))⟩ = ⟨Te ∪ {< t, r, I >}, l(u(t))⟩ if C ∧ Te ∪ {< t, r, I >} /= Te
where Te is a set that accumulates enabled transitions. Note that rewrite rules in R^L are already modified to capture the context in which the corresponding original rule of RL would have been applied. Starting from the pair < ∅, ts >, by applying all equations of the above form, we will converge to the pair < Te, ts >, where Te is the set of all enabled transitions.
Since the context information I depends on the specific programming language L and on the way the semantics of L is defined, the I component has to be left as a null constant when these equations are generated automatically based on the rules. However, a tool builder familiar with the language semantics can customize these equations to include whatever context information may be useful later. In our experience with several rewriting semantics for different programming languages, there are relatively few rewrite rules in the semantic definitions (that is, EL is much bigger than RL), so this process is rather quick and easy.
Computing the Ample Set
Dependence Relation.
The Definition of a dependence relation between the transitions is required for computing the ample sets. The dependence relation is represented by the operator Dependence: Transition Transition −→ Bool. Clearly, the dependence relation is different for different programming languages. Some common dependence properties can be shared by many programming languages, such as: “all the transitions in a single thread are interdependent”, which is expressed by the following equation:


Fig. 1. Two Partial Order Reduction Heuristics.


Dependence(< t, r, I >, < t, r',I' >)= true
where t is a variable ranging over thread identifiers, r and r' are variables ranging over rule names, and I and I' are variables ranging over context information.
In order to have the best possible reduction, the language specifier/tool builder should supply the definition of the dependence relation for the given language as a set of additional equations. The dependence relation can often be defined through a few equations, even for complicated languages. See Section 4 for the definition of the dependence relation for the Java bytecode. Note that, in general, since the dependence relation is defined by a set of equations (that can potentially be conditional) we can naturally support the case of conditional dependence as in [6,17].

The Heuristic Algorithm.
Since the core of the heuristic algorithm can be specified using a few equations, we have specified two different heuristics. Many additional optimizations for these heuristics and also other heuristics can likewise be specified with little effort (see Section 5), but they are beyond the scope of this work. Figure 1 shows both algorithms. Functions C' , C2, and C3 check the three conditions discussed in the next section, returning true or false.  These procedures are called at each state (see Section 2) to compute the ample set at that state. The algorithm on the left is a simpler version, which only considers ample sets including transitions of a single thread. The algorithm on the right extends the former to consider ample sets that can include transitions of more than one thread, which can result in a better reduction. If we have n threads, and at some point no single thread can be a candidate for ample, we may be able to find a subset of threads that can satisfy the conditions as a whole. To do so, we use the transitive closure of the dependence

relation D defined on the set T of transitions as follows:
D : T 2 → {true, false}	S, T, U ⊆T ,t ∈T 
tr : T → P(T )	tr(t)= {t}∪ {t'|thread(t)= thread(t')}
cD,S : P(T ) → P(T )	cD,S(T )= T ∪ U = {t' ∈ S|∃t ∈ T, D(t, t')= true}


t∈U
tr(t)

μcD,S
: P(T ) → P(T )	μc


D,S
(T )=  ∞
n D,S
(T )

where cD,S(T ) computes all the transitions of S which are immediately dependent on transitions in T . Since S is a finite set of transitions, cD,S is monotonic; if we reapply cD,S repeatedly, we eventually reach a set T (a fixpoint) where cD,S(T )= T . The function μcD,S represents this fixpoint. The set μcD,Te (t) is a good candidate for an ample set, since we know that at least no transition outside the set μcD,Te (t) is dependent on anything inside it. A good method to find the best ample set is to sort the sets μcD,Te (t), for all t ∈ Te based on their cardinality, and then start checking the conditions, beginning with the smallest one. This way, if we verify all the conditions for a candidate set, we are sure that it is the smallest possible ample set, and we are done.
Checking The Conditions.
The most involved part of the partial order reduction algorithm is checking the conditions in [2]. Conditions C2 and C3 are exactly the same as in [2]. Condition C'1 is a stronger version (see [10]) of condition C1 from [2] (since the original C1 from the POR theory is not locally verifiable) and very similar to the variation of it in the heuristic proposed in [2]. Since the algorithm always works on nonempty sets, we are left to check three out of the four conditions. Here, we describe how the conditions are checked for a candidate set of transitions (ample set). The special case of a single transition as a candidate (as in [2]) follows from this easily.
Te represents the set of all enabled transitions in the current state. Note that, as argued before, the notions of transition and of enabled thread are equivalent in our framework, so we often switch between the two.

C'1: if transition set T ⊂ Te is a an ample set, then no thread in Te − T
should have a transition in the future that is dependent on t.
To compute future transitions of a thread ti ∈ Te − T , a conservative flow- insensitive context-insensitive static analysis of the code is performed. This kind of static analysis can be done locally, and is different for different programming languages. Therefore, the language specifier/tool builder needs to provide it. In the definition of the algorithm we assume that there is an operation ThreadTransitions which takes the thread identifier and the current state of the system and returns all the future transitions of the thread in the form of a set of tuples (transition format) through a purely static analysis of the code of the input program which usually

offers an overestimation of the actual set. Having the future transitions of all the threads in Te − T , condition C'1 can then be easily checked by using the dependence relation. To see that C'1 implies C1 in [2], see [10].

C2: ample transitions should be invisible if the state is not fully ex- panded.
This condition is the simplest of the three to verify. The set of propositions used in the desired property is given as an input. The check just has to go over this set, element by element, and check whether each proposition has the same truth value in state s and in its successor state with respect to all transitions in the ample candidate set.

C3: Cycle-closeness Condition.
This condition ensures that no transition is enabled over a cycle in the state transition graph and is never taken in the ample set. This condition can be easily checked when the partial order reduction algorithm is embedded in a model checker, since the stack of states being explored is available. In our case, we use exactly the same method, but we simulate part of that stack as part of the state. The second component of the new system state, StateInfoSet takes care of this. Whenever in a state s there is a transition t outside the ample set, the pair (t, s) will be stored in the StateInfoSet component. As soon as a transition is taken in some future step, the pair is removed from the StateInfoSet. If a pair (t, s) is still there when we revisit s, we know that we are closing a cycle, so we must take the transition.
Correctness of the Theory Transformation
The correctness of our theory transformation can be now stated as the following theorem, whose proof is sketched in [10]:
Theorem 3.2 Assuming that a set AP of atomic state predicates has already been added to RL by means of a set of equational deﬁnitions, the Kripke structures asso- ciated to the rewrite theories RL (with State as its sort of states) and to RL+POR (with PorState as its sort of states) are stuttering bisimilar.

Applications of the Method and Experiments
We have implemented the theory transformation for our generic POR reduction method in a Maude [4] prototype and have used it to build POR units for Java bytecode and for a Promela-like language. In this section we illustrate how the method was used to build the POR unit for Java bytecode, which has been added to JavaFAN [11], a tool to formally analyze Java programs based on a rewriting semantics of both Java source code and bytecode. We also present some performance figures for both the JVM and the Promela-like language to show that the generic partial order module can result in drastic reductions in the state space of programs in the above languages.

The JVM POR Unit
By briefly discussing this example, we illustrate how the language-dependent parts are defined in Maude for the Java bytecode semantics to give a better understanding of these parts, and also to show that they can be specified by the tool builder with relatively little effort and in a program-independent way.

Extracting Transitions.
There are 16 equations, corresponding to the 16 rewrite rules in the semantics of the Java bytecode, which extract all the enabled transitions from a given state. Here is an example of one of these equations:
ceq << S, < T: JavaThread | callStack:([PC, monitorenter, .., (REF(K) # OperandStack), ...] CallStack), .. > < O:JavaObject|Addr:K, .., Lock:Lock(OIL, NoThread, 0) > Ct >> = << S {’MONITORENTER, T, noInfo},
< T: JavaThread | callStack: ([PC, monitorenter, ..., OperandStack, ...] CallStack), Status: scheduled, ... > < O: JavaObject | Addr: K, ..., Lock: Lock(OIL, NoThread, 0) > Ct >> if S {’MONITORENTER, T, noInfo} =/= S .
where S is the enabled transitions set. The equation says that if in the current state (containing a thread T , an object O, and a context Ct which captures the rest of the JVM state that is a multiset), T is ready to execute a monitorenter (lock) instruction, and O is not locked by any other thread, it means that the tuple
{’MONITORENTER, T, noInfo} is an enabled transition, and it is added to the set S if it is not already in it.

Dependence Relation.
The dependence relation for Java bytecode is defined based on the following facts: (1) two accesses to the same location are dependent if at least one of them is a write. This is defined through a few equations to cover the access to the instance fields as well as static fields; (2) two lock operations accessing the same lock are dependent. This is defined through a few equations to cover synchronized method calls, the monitorenter instruction, as well as the notifyAll built-in method of Java.
As an example of equations defining the dependence relation we have:
eq Dependence({T, ’PutField, I}, {T’, ’GetField, I’}) = true .
eq Dependence({T, ’InvokeStatic, C}, {T’, ’InvokeStatic, C) = true .
which specify that a read and a write to an instance field (first line) are always dependent, and (second line) two synchronized static method calls are dependent if they are locking the same class, C.

Thread Transitions.
As mentioned at the end of Section 3.3, to check condition C'1, the operation ThreadTransitions, which conservatively computes the set of future transitions of a thread, has to be specified by the user. In the case of Java bytecode the idea is to start from the current point in ti and add all the future instructions (transition steps) of the current method executing, and upon a method call, add in all the instructions (transitions) of the code of that method as well (avoiding repetition). This is conservative, in the sense that in the cases where more than one method

can be the potential resolution of a call site, all of them are considered, and also in transitions such as reading/writing a field of an object where the object cannot be resolved until the point of execution, conservatively all possible objects will be considered.
Experiments
Table 1 presents the reduction comparison of sieve of eratosthenes modeled in Promela language and Maude. The first column shows the result for the Promela program model checked with SPIN. The second column contains the result for the same model written in Maude language together with our POR unit. The third col- umn shows the result of the same Promela program when it is model checked using the semantics of Promela together with our POR unit in Maude. The overhead of interpreting Promela in this case results in a larger number of states.

Table 1
Time and Space Reduction Comparisons.

Table 2 shows the results of time/space reduction for a deadlock-free version of dining philosophers with different number of philosophers in the Promela-like language. Entries left empty indicate that we could not model check the example on our platform, a PC running Linux with a 2.4GHz processor and 4GB of memory.
Table 3 illustrates a dining philosophers program (5 philosophers) model checked in JavaFAN, where two versions of the dependency relation are compared. In the “basic” version, the dependency relation is the general version (presented in Section 4) that holds for all Java programs. The “NotShared” version lifts the dependencies of read/write memory accesses, since we know that the dining philosophers code does not use any shared memory and works merely based on locks. As shown in Table 3, a simple change like this (which means commenting out a few equations in the definition of the dependency relation) can result in a considerably better performance.
Table 4 shows the state reduction obtained when the partial order reduction module is used. The JavaFAN tool reduces the number of states substantially by itself, since it uses the rewrite rules to model only the concurrent parts of Java (see [11] for details). But, the partial order reduction can still add a substantial reduc- tion to that. PL is a two stage pipeline, DP is a deadlock-free version of the dining philosophers, RA is NASA’s remote agent benchmark, and SE is a distributed sieve


Table 2 Dining Philosophers.

Table 3
Changing Dependency Relation.

of Eratosthenes. All programs in these experiments, as well as the semantic defini- tions of the JVM and the Promela-like language and their POR-transformations by our method are available in [8].

Table 4
Partial Order Reduction Results.


Related Work and Conclusions
Related Work.
There are two well-known approaches to attack the state-explosion problem while model checking. The first approach consists of partial order methods intro- duced by Peled in [22]. The generic method proposed in this paper fits within this approach. Several different variations [14,15,25,1,12,3,18] of the POR approach have

been introduced since.
A first class of POR methods —including the stubborn sets method of [25], the persistent sets method of [16], and the ample sets method of [23]— are based on modifying the search algorithm and applying the reduction dynamically. [12] takes the matter even further, and dynamically tracks the interactions between threads based on initially exploring an arbitrary interleaving of them. Details of the reduction heuristic are orthogonal to our method; although we propose two different heuristics in this paper, many other heuristics can be implemented with little effort. A second class of POR methods such as the one in [18] use a static approach in which all partial order reduction information is computed statically, and then an already reduced model is generated to be model checked.
In the dynamic methods, one has to alter the existing model checker to include the reduction, while static methods suffer from the fact that only a limited amount of information is available at compile time. We believe that our method addresses both problems: it can work with an existing model checker, so it has the advantages of the static methods, but it applies the reduction dynamically and therefore can benefit from the runtime information.
It seems fair to say that current POR-enabled model checkers are mostly language- specific, or, by using for example a static approach such as [18], achieve only a lim- ited “genericity by translation into a common intermediate language”. Tools such as Verisoft [15] that can monitor and control the execution of programs in different languages for model checking purposes are in practice applied to a limited family of languages and cannot benefit from any optimizations that can potentially be in- troduced using some sort of static analysis of the program, which is not the case in our method. To the best of our knowledge this work represents the first attempt to develop LTL model checkers with POR capabilities for concurrent languages in a generic way using their semantic definitions.
Besides the POR methods, a second state space reduction approach, which could be called transaction-based, consists of more recent techniques that consider various kinds of exclusive access predicates for shared variables specifying some synchroniza- tion disciplines [24,13,6]. These predicates can be used to reduce the search space during the state space explorations. The POR techniques (including the method proposed in this paper) are complementary to these other methods. We discussed how our method exploits some ideas from [24] in Section 2.1. We strongly believe that the reductions in [13] can be achieved using a very similar method to that presented in this paper (see below for more details).

Conclusions.
We have presented a general method to make software model checkers with POR capabilities language-independent, so that they can be specialized to any program- ming language L of interest. Our method is based on a theory transformation of the rewriting logic formal semantics of the given language. The language specialization can be done semi-automatically and with relatively little effort by a tool builder. Language-specific optimizations can also be added, because the heuristic algorithm

and the dependence relation are explicit parameters of the theory transformation. Since all POR computations are performed in the transformed theory itself, the method does not require any modifications to the underlying LTL model checker. Our experience evaluating this method in practice for the JVM, a Promela-like language, and Maude, indicates that significant state space reductions and time speedups can be gained.
Our method is also generic at the semantic framework level: we have developed it in detail within rewriting logic, but the same idea can be applied within other frameworks, for example SOS. In any such framework, the semantics of L will have a specification SL. We then would obtain the POR capabilities by a suitable theory transformation SL '→LS+POR.
The current prototype implementation of our method does not support various well-known optimization strategies, but many of these can be incorporated into our framework in a straightforward way. These strategies are often based on as- sumptions about the structure of the programming language under consideration. Therefore, they belong to the second, language-specific customization phase of our theory transformation, although in some cases they can be applied to entire families of languages. For example, a reduction strategy proposed in [6] for concurrent ob- ject oriented software is detecting heap objects that are thread-local to sharpen the dependence relation. All the static/dynamic analysis in [6] that leads to detecting the thread locality is possible in our framework, since we have both the static and dynamic information available. A more extensive experimentation with a broader set of language instantiations and incorporating the above optimizations should be performed in the future. Furthermore, the mechanical verification of the correctness of our theory transformation along the lines of the proof sketched in [10] should be investigated.
Another interesting direction for future work is extending our generic method beyond POR to also support what we have called “transaction-based reductions” in Section 1. Such reductions are complementary to those obtained by POR meth- ods. We conjecture that a similar theory transformation would allow us to achieve transaction-based reductions in a generic way. The equation (*) in Section 3.2 works as a nondeterministic scheduler which in the present method schedules all the threads belonging to the ample set for the next step. In a transaction-based method the role currently played by the MarkAmples operation could instead sched- ule a single thread t, provided t is inside a transaction, and the component I could then be used for the instrumentation predicates.

References
R. Alur, R. K. Brayton, T. A. Henzinger, S. Qadeer, and S. K. Rajamani. Partial order reduction in symbolic state exploration. In CAV, pages 340 – 351, 1997.
E. M. Clarke, O. Grumberg, and D. A. Peled. Model Checking. MIT Press, 2000.

E.M. Clarke, O. Grumberg, M. Minea, and D. Peled. State space reduction using partial order techniques. Journal of STTT, 2:279 – 287, 1999.


M. Clavel, F. Dur´an, S. Eker, P. Lincoln, N. Mart´ı-Oliet, J. Meseguer, and C. Talcott. Maude 2.0 Manual, 2003. http://maude.cs.uiuc.edu/manual.
Manuel Clavel, Francisco Dur´an, Steven Eker, Patrick Lincoln, Narciso Mart´ı-Oliet, Jos´e Meseguer, and Jos´e Quesada. Maude: specification and programming in rewriting logic. Theoretical Computer Science, 285:187–243, 2002.
M. Dwyer, J. Hatcliff, and V. Prasad. Exploiting object escape and locking information in partial order reductions for concurrent object-oriented programs. Formal Methods in System Design Journal, 25:199–240, 2004.
S. Eker, J. Meseguer, and A. Sridharanarayanan. The Maude LTL model checker and its implementation. In SPIN’03, LNCS, pages 230 – 234, 2003.
A. Farzan. Specifications and examples. http://maude.cs.uiuc.edu/POR/.
A. Farzan, F. Chen, J. Meseguer, and G. Ro¸su. Formal analysis of Java programs in JavaFAN. In
Proceedings of CAV, volume 3114, pages 501 – 505, 2004.
A. Farzan and J. Meseguer. Partial order reduction for rewriting semantics of programming languages. Technical Report UIUCDCS-R-2005-2598, University of Illinois at Urbana-Champaign, 2005.
A. Farzan, J. Meseguer, and G. Ro¸su. Formal JVM code analysis in JavaFAN. In AMAST, volume 3116, pages 132 – 147, 2004.
C. Flanagan and P. Godefroid. Dynamic partial order reduction for model checking software. In
Proceedings of POPL, 2005.
C. Flanagan and S. Qadeer. Transactions for software model checking. In Workshop on Software Model Checking, volume 338–349, 2003.
P. Godefroid. Partial-order methods for the verification of concurrent systems - an approach to the state-space explosion problem. In Lecture Notes in Computer Science, volume 1032. Springer-Verlag, 1996.
P. Godefroid. Model checking for programming languages using Verisoft. In POPL, volume 174–186, 1997.
P. Godefroid and P. Wolper. A partial approach to model checking. In Proceedings of Logic in Computer Science, pages 406 – 415, 1991.
S. Katz and D. Peled. Defining conditional independence using collapses. Theoretical Computer Science, 101:337–359, 1992.
R. Kurshan, V. Levin, M. Minea, D. Peled, and H. Yenigun. Static partial order reduction. In TACAS, volume 1384, pages 345 – 357, 1998.
J. Meseguer. Conditional Rewriting Logic as a Unified Model of Concurrency. Theoretical Computer Science, pages 73–155, 1992.
J. Meseguer and G. Ro¸su. Rewriting logic semantics: from language specifications to formal analysis tools. In Automated Reasoning, volume 3097, pages 1–44, 2004.
J. Meseguer and G. Ro¸su. The rewriting logic semantics project. In Proc. SOS 2005. Elsevier ENTCS, 2005.
D. Peled. All from one, one for all: on model checking using representatives. In CAV’93, LNCS, pages 409–423, 1993.
D. Peled. Combining partial order reduction with on-the-fly model checking. In Proceedings of computer aided verification, volume 818, pages 377 – 390, 1994.
S. D. Stoller. Model-checking multi-threaded distributed java programs. In SPIN Workshop, pages 224–244, 2000.
A. Valmari. A stubborn attack on state explosion. In Proceedings of the 2nd workshop on computer aided verification, volume 531, pages 156 – 163, 1990.
P. Viry. Equational rules for rewriting logic. Theoretical Computer Science, 285:487–517, 1992.
