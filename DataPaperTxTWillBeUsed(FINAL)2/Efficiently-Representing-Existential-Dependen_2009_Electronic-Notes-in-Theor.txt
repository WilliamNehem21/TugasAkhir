

Electronic Notes in Theoretical Computer Science 251 (2009) 83–95
www.elsevier.com/locate/entcs

Efficiently Representing Existential Dependency Sets for
Expansion-based QBF Solvers
Florian Lonsing and Armin Biere1
Institute for Formal Models and Verification Johannes Kepler University
Linz, Austria

Abstract
Given a quantified boolean formula (QBF) in prenex conjunctive normal form (PCNF), we consider the problem of identifying variable dependencies. In related work, a formal definition of dependencies has been suggested based on quantifier prefix reordering: two variables are independent if swapping them in the prefix does not change satisfiability of the formula. Instead of the general case, we focus on the sets of depending existential variables for all universal variables. This is relevant particularly for expansion-based QBF solvers. We present an approach for efficiently computing existential dependency sets by means of a directed connection relation over variables and demonstrate how this relation can be compactly represented as a tree using a union-find data structure. Experimental results show the effectiveness of our approach.
Keywords: Quantified Boolean Formulae, QBF, expansion, dependencies.


Introduction
The logic of quantified boolean formulae (QBF) extends propositional logic (SAT) with universal quantification. Whereas QBF is not more expressive than SAT, relevant problems from model checking and verification [6,8,13,19] often can be encoded more compactly in QBF than in SAT. In the domain of SAT, encouraging progress has been made during the last years in the development of efficient decision procedures based on the DPLL-framework [12]. The success is due to advanced strategies for pruning the search space such as learning, backjumping or restarts. These techniques were successfully extended to DPLL-based algorithms for QBF [11,17,26] but, although still being important for performance, it turned out not to guarantee similar progress as for SAT.

1 http://fmv.jku.at/

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.08.029

There is strong indication [4,14,15,18] that the quantifier prefix of QBFs in prenex conjunctive normal form (PCNF) could be one reason for this phenomenon. In QBF the presence of different types of quantifiers introduces dependencies be- tween variables which have to be respected by QBF solvers. In many cases depen- dencies resulting from linear quantifier prefixes are too pessimistic and have negative influence on solver performance. In [23] a formal definition of dependencies has been suggested and it was shown that the problem of identifying the optimal (smallest) dependency set is, as the decision problem of QBF, PSPACE-complete [24]. Be- cause of this fact a compromise has to be found between efficiency and optimality. Various approaches have been suggested to identify dependencies and thus overcome the drawback of linear quantifier prefixes [2,4,7,9,15,18,20,23]. To our knowledge all of these approaches are based on analyzing the syntactic structure of a QBF.
Apart from search-based QBF solvers, which suffer from dependencies in ex- ploring irrelevant parts of the search space, handling dependencies is crucial for solvers based on variable elimination [2,5,7,10,20]. These solvers have to cope with dependency-related size increase of the formula involved with eliminations.
In this paper we address the problem of computing dependency sets of univer- sally quantified variables for QBFs in PCNF, which is relevant for expansion-based QBF solvers [2,5,7,10,20]. Our work is based on [7,9]. We briefly introduce universal expansion and analyze an algorithm suggested in [9] for computing dependencies of universal variables. Starting from our analysis we develop a formal definition of dependencies in the context of universal expansion. The definition is based on a syntactic connection relation of variables. We obtain a directed dependency relation by defining an equivalence relation over existential variables. This relation can be represented as a tree excluding transitive edges. As experimental results demon- strate, this relation allows efficient computation of dependency sets for all universal variables in a QBF. As we do not consider dependencies of existential variables, our approach can not directly be applied in search-based solvers, yet we see the
potential of extending our work to dependency sets for existential variables. 2

Preliminaries
For a set of variables V , a literal is either a variable x ∈ V or its negation чx where v(x) = x and v(чx) = x denotes the variable of a literal. A clause is a disjunction over literals. A propositional formula is in conjunctive normal form (CNF) if it consists of a conjunction over clauses.
A quantified boolean formula (QBF) F ≡ S1 ... Sn φ in prenex conjunctive nor- mal form (PCNF) consists of a propositional formula φ in CNF over a set of variables
V and a quantiﬁer preﬁx S1 ... Sn. The quantifier prefix is a linearly ordered set of
scopes Si, such that S1 < . . . < Sn, which forms a partition on the set of variables:
V = S1 ∪ ... ∪ Sn and Si ∩ Sj = / 0 for 1 ≤ i, j ≤ n and i /= j.

2 In [21] we have in fact extended our approach. We obtained a compact graph representation for depen- dencies of both existential and universal variables. This representation is also based on syntactic variable connections [23].

A scope Si is existential if it is associated with an existential quantifier, written as q(Si) = ∃ and universal otherwise where q(Si) = ∀. The set of existential and universal variables is denoted by V∃ =  Si for q(Si) = ∃ and V∀ =  Si for q(Si) = ∀, respectively. For a variable x ∈ Si, s(x) = Si is the scope of x and q(x) = q(s(x)) the type of x. For two adjacent scopes Si and Si+1 where 1 ≤ i < n, q(Si) /= q(Si+1). Given a QBF with n scopes, there are n− 1 quantiﬁer alternations.
For some variable x, R(x) = {y ∈ V | δ(x) ≤ δ(y)}. That is, R(x) is the set of all variables larger than x.
For a scope Si and literal l, δ(Si) = i and δ(l) = δ(s(v(l))) denote the level of
Si and of l, respectively. For scopes Si, Sj and literals l, k, Sj is larger than Si and
k is larger than l if δ(Si) < δ(Sj) and δ(l) < δ(k), respectively.
Let R ⊆ V × V be a binary relation on the set of variables V . The reflexive and transitive closure of R is the smallest reflexive and transitive R' ⊆ V × V such that R ⊆ R'. The reflexive and transitive reduction of R is the smallest R' ⊆ V ×V such that R and R' have the same reflexive and transitive closure.
In the following, QBFs in PCNF are considered such that for all clauses C = (l1 ∨ ... ∨ lk), v(li) /= v(lj) and δ(li) ≤ δ(lj) for 1 ≤ i < j ≤ k and q(v(lk)) = ∃. A clause neither contains multiple nor complementary literals of one and the same variable, all literals are sorted ascendingly according to their level and the largest literal is existential. Universal reduction [7,10] can be applied to remove literals lk for which q(v(lk)) = ∀. Furthermore, we assume that there occurs at least one literal for each x ∈ V in the formula.

Universal Expansion
Apart from solving QBF using DPLL-based algorithms where a semantic search tree is implicitly constructed [11,12], resolution and expansion can be applied in order to successively eliminate variables at the cost of formula size [2,5,7,10,20]. In [9], cost-based expansion of universal variables was applied for preprocessing QBF, which generalizes an approach first used in Quantor [7].
Basically, expanding a universal variable x ∈ V∀ involves copying a subformula, assigning x and duplicating depending existential variables D(x) ⊆ (R(x) \ V∀).
For detailed information about expansion we refer to the aforementioned publica- tions. In this work we focus on efficient computation and representation of D(x) and |D(x)|, respectively. Duplicating variables is necessary in order to reflect the possibility of a depending existential variable to assume different values with respect to the value of the universal variable.
Example 3.1 In the satisfiable formula ∀x∃y (x ∨ чy) ∧ (чx ∨ y), y depends on x: y must be assigned true if x = true and false otherwise. Incorrectly expanding x without duplicating y yields ∃y (чy) ∧ (y), which is unsatisfiable. If y is duplicated, then the resulting formula ∃y, y' (чy) ∧ (y') is equisatisfiable.
A popular approach for computing set D(x) is based on rules for syntactically pushing quantifiers from the prefix inside the formula, thus minimizing the sub-

a1	a2

e3	e4	e5

a6	a7

e8		e10	e9 a11

e13
e12
e14


Fig. 1. QBF example. The table on the left shows the levels, quantifiers and variables for each scope in the first three columns and clauses as lists of literals in the last column. Variables and literals are uniquely identified by integers as in QDIMACS format [22]. The corresponding c-forest including sets H(x) (see Sec. 4.1 and 4.2) is depicted on the right. Identifier prefixes “a” and “e” indicate variable types ∀ and ∃, respectively.

formula within the range of a quantifier: (Qx φ ⊗ ψ) ≡ (Qx φ) ⊗ ψ if x /∈ V (ψ),
⊗∈ {∨, ∧} and Q ∈ {∀, ∃}. This method, also called miniscoping [2], has been ap- plied in various contexts [2,4,7,9,15,20,23]. Informally, for some QBF and variable x ∈ V∀, D(x) ⊆ (R(x) \ V∀) is the set of variables appearing to the right of x after pushing quantifiers inside F as far as possible.
In [7] a connection relation of existential variables was defined in order to com- pute D(x) for x ∈ Sn−1, which was generalized in [9] to arbitrary universal scopes: two variables v and w are locally connected if they occur in a common clause. The original definition [9] for computing D(x) where x ∈ V∀ is as follows:
D0(x) := {y ∈ (R(x) \ V∀) | x is locally connected to y} Dk+1(x) := {z ∈ (R(x) \ V∀) | z is locally connected to y ∈ Dk}
D(x) :=  Dk
k
Let X = D(x) ∪ {x}. Set D(x) where x ∈ V∀ has the following properties:
D(x) ⊆ (R(x) \ V∀)
For y ∈ D(x) : q(y) = ∃ and δ(x) < δ(y)
For y ∈ D(x) : x is connected to y via clauses containing variables in X
For y, z ∈ D(x) : y is connected to z via clauses containing variables in X
Essentially, D(x) contains existential variables which have larger levels than x only and x is connected to all variables in D(x) via clauses containing variables from D(x) ∪ {x}. This is also the case for all pairs of variables in D(x).
In an implementation directly applying the definition, set D(x) can be computed by starting at clauses C such that x ∈ C, collecting existential variables y ∈ C where δ(x) ≤ δ(y) and recursively inspecting clauses containing y. During this process, the connection relation is implicitly constructed. This algorithm requires O(|F|) time for one x ∈ V∀, where |F | is the length of the formula.

Example 3.2 For the QBF in Fig. 1, D(a1) = {e3, e4, e8, e10, e12, e13}, D(a2) = 
{e5, e9, e14}, D(a6) = {e8, e12, e13}, D(a7) = {e10} and D(a11) = {e12, e13}.

Defining a Directed Dependency Relation
Based on the properties of set D(x), an approach for efficient computation and representation of D(x) for all x ∈ V∀ is presented. The idea is to avoid computing a connection relation for each universal variable from scratch. Instead, such a relation is constructed once for all existential variables, which forms the basis for retrieving sets D(x) and computing |D(x)|, respectively. For example, in expansion-based QBF solvers this information could be used in variable selection heuristics. It is shown how the connection relation can be compactly represented by defining an equivalence relation on existential variables and by excluding transitive edges. In the following, a formal definition is developed.
Definition 4.1 For a QBF, V∃,i = {y ∈ V∃ | i ≤ δ(y)}.
In Def. 4.1 V∃,i denotes the set of existential variables which are larger than or equal to scope Si. We first introduce variable connections by clauses containing common variables (definition adapted from [23]). This will be needed for proving some of our results.
Definition 4.2 For x, y ∈ V and X ⊆ V , an X-path between x and y is a sequence
C1,..., Ck of clauses such that x ∈ C1, y ∈ Ck and Ci ∩ Ci+1 ∩ X /= ∅ for 1 ≤ i < k.
Example 4.3 For the QBF in Fig. 1, there is an X-path between a1 and e3 for
X = {e12, e13} and clauses (a1, a6, e8, e13), (e4, e12, e13) and (e3, e8, e12).
Definition 4.4 For x, y ∈ V , y is locally depending on x with respect to scope Si, written as x →i y, if, and only if q(y) = ∃, i ≤ δ(y) and there exists a clause C such that both x ∈ C and y ∈ C. The reflexive and transitive closure of →i is denoted by →∗. If x →∗ y, then y is transitively locally depending on x.
i	i
The term “locally” refers to the fact that the relation is defined with respect to some scope Si. There is a correspondence between →∗ and X-paths, which follows
from Def. 4.4 and Def. 4.2.
Corollary 4.5 For x, y ∈ V , if x →∗ y, then there is an X-path between x and y
for X = V∃,i.
Due to Def. 4.4 the converse of Cor. 4.5 does not hold in general. For example, if there is an X-path between x ∈ V∃ and y ∈ V∀ then x /→∗ y for all i. A weaker
variant can be stated as follows.
Corollary 4.6 For x ∈ V, y ∈ V∃, if there is an X-path between x and y for
X = V∃,i and i ≤ min(δ(x), δ(y)), then x →∗ y.
By Def. 4.4 connections with respect to a scope Sj are preserved for any smaller scope Si as stated in the following corollary.

Corollary 4.7 For x, y ∈ V , i ≤ j: if x →∗ y, then also x →∗ y.
j	i
Example 4.8 For the QBF in Fig. 1, e3 →4 e8 but e3 /→5 e8, e8 →6 e12 and by Cor. 4.7 also e8 →1 e12, further e3 →∗ e13.
Definition 4.9 For x, y ∈ V∃, x is transitively locally connected to y with respect to scope Si, written as x ∼i y, if, and only if q(x) = q(y) = ∃ and x →∗ y.
Actually, ∼i is a special case of →∗ by restricting the set of variables to V∃. For
proper values of i, ∼i is symmetric.
Lemma 4.10 For x, y ∈ V∃,i ≤ min(δ(x), δ(y)) : if x ∼i y then y ∼i x.
Proof. If x ∼i y for x, y ∈ V∃ and i ≤ min(δ(x), δ(y)), then by Def. 4.9 also x →∗ y. By Cor. 4.5, there is an X-path between x and y for X = V∃,i and a sequence of clauses C1,..., Ck. Then the reversed sequence of clauses Ck,..., C1 is an X-path between y and x. Since x, y ∈ V∃ and i ≤ min(δ(x), δ(y)), by Cor. 4.6 also y →∗ x and further y ∼i x by Def. 4.9.	 
Example 4.11 For the QBF in Fig. 1, e3 ∼2 e10 since q(e3) = q(e10) = ∃ and
e3 →∗ e10 via variables e12, e4 and e10.
Definition 4.12 For x, y ∈ V , x is globally connected to y, written as x ≈ y, if, and only if either (1) x = y or (2) q(x) = q(y) = ∃, δ(x) = δ(y) = i and x ∼i y.
Relation ≈ is “global” because the definition is independent from a particular scope. It follows from Def. 4.12 that for x, y ∈ V if x ≈ y then also s(x) = s(y) and δ(x) = δ(y). We now prove that ≈ allows to merge existential variables from the same scope into equivalence classes. This is an important step towards a compact representation of dependencies.
Theorem 4.13 ≈ is an equivalence relation. For x ∈ V , [x] is the class of x.
Proof. Reflexivity is trivial since x ≈ x for x ∈ V by Def. 4.12. If not q(x) = q(y) = ∃ then by Def. 4.12 x ≈ y if, and only if x = y. Since = is an equivalence relation, symmetry and transitivity of ≈ follow immediately. Otherwise, assume q(x) = q(y) = ∃. If x ≈ y and x = y, then also y ≈ x by Def. 4.12. If x ≈ y and x /= y then by Def. 4.12 x ∼i y for i = δ(x) = δ(y). Then by Lem. 4.10 and since i = δ(x) = δ(y) also y ∼i x and hence y ≈ x. Therefore ≈ is symmetric. To show transitivity, assume x ≈ y' and y' ≈ y for y' ∈ V . If y' ∈ V∀ then trivially x = y' = y by Def. 4.12 and hence also x ≈ y. Otherwise y' ∈ V∃ and by Def. 4.12 and Def. 4.9 also x →∗ y', y' →∗ y for i = δ(x) = δ(y') = δ(y) and q(x) = q(y') = q(y) = ∃.
i	i
By x →∗ y', y' →∗ y and transitivity of →∗, also x →∗ y, and further x ≈ y since
i	i	i	i
x ∼i y.	 
Example 4.14 For the QBF in Fig. 1, e3 ≈ e4 because q(e3) = q(e4) = ∃ and
δ(e3) = δ(e4) = 2 and e3 ∼2 e4 since e3 →∗ e4 via variable e12. Furthermore,
e12 ≈ e13.
Lemma 4.15 Let x ∈ V, i = δ(x) and y ∈ [x]. Then x →∗ y.

Proof. If x ∈ V∀ and y ∈ [x] then trivially x = y because x ≈ y by Def. 4.12 and also x →∗ x for i = δ(x) by reflexive closure of →i as in Def. 4.4. If x ∈ V∃ then x ≈ y since y ∈ [x] and x ∼i y for i = δ(x) = δ(y) by Def. 4.12 and further x →∗ y by Def. 4.9.	 
Theorem 4.16 Let x, y ∈ V, i ≤ min(δ(x), δ(y)). Then x →∗ y if, and only if
x' →∗ y' for all x' ∈ [x], y' ∈ [y].
Proof. The proof works regardless of the types of x and y by Def. 4.4 (reflexivity of
→∗), Cor. 4.7 and Def. 4.12. Trivial cases arise for V∀. Assume x →∗ y for x, y ∈ V
i	i
and i ≤ min(δ(x), δ(y)). Then for x' ∈ [x], y' ∈ [y], x' →∗ x and y →∗ y' by Cor. 4.7
i	i
and Def. 4.12. Since x' →∗ x, x →∗ y (by assumption), y →∗ y', also x' →∗ y' by
i	i	i	i
transitivity of →∗. The other direction can be shown analogously.	 
Lem. 4.15 and Thm. 4.16 state compatibility of →∗ with ≈: if two variables are connected (dependent) then so are all members of their respective classes and vice versa. When regarding [x] as an arbitrary class member, we may write, for example,
[x] →∗ [y] by Thm. 4.16. This notation denotes connections between classes. Note that Thm. 4.16 would not hold for arbitrary values of i. For example, if δ(x) < i then x /→∗ x' for x' ∈ [x], which contradicts Def. 4.12.
Definition 4.17 ~∗ denotes the global directed dependency relation. For x, y ∈ V ,
[x] ~∗ [y] if, and only if, δ(x) ≤ δ(y) and x →∗ y for i = δ(x). The transitive
reduction of ~∗ is denoted by ~.
Lemma 4.18 For x, y ∈ V : if [x] ~∗ [y] and [x] /= [y] then δ(x) < δ(y).
Proof. Assume [x] ~∗ [y], [x] /= [y] but δ(x) ≥ δ(y). Then by Def. 4.17, δ(x) = δ(y) and hence also q(x) = q(y). Since [x] ~∗ [y], also x →∗ y for i = δ(x) = δ(y) and
[x] →∗ [y] by Thm. 4.16 and hence [x] ≈ [y] by Def. 4.9 and Def. 4.12. Then [x] = [y] which contradicts the assumption.	 
The proof of the following lemma works analogously to the one of Lem. 4.18.
Lemma 4.19 For x, y ∈ V : if [x] ~∗ [y] then either [x] = [y] or δ(x) < δ(y).
By Lem. 4.18 and Lem. 4.19, if [x] ~∗ [y] then either x and y are in the same class or in different classes but from different scopes.
Theorem 4.20 For x ∈ V∀,i = δ(x) : 
D(x) = {y ∈ V∃ | x →∗ y} = {y ∈ V∃ | [x] →∗ [y]} = {y ∈ V∃ | [x] ~∗ [y]}.
i	i
Proof. Assume x ∈ V∀ and i = δ(x).
D(x) = {y ∈ V∃ | x →∗ y} holds since D(x) as defined in Sec. 3 corresponds to the transitive closure of →i in Def. 4.4.
To show {y ∈ V∃ | x →∗ y} ⊆ {y ∈ V∃ | [x] →∗ [y]} first assume x →∗ y, y ∈ V∃.
i	i	i
By Def. 4.12, x ≈ x and x = [x], hence [x] →∗ y and i ≤ δ(y) by Def. 4.4. In fact,
i < δ(y) because i /= δ(y) since q(x) /= q(y). For j = δ(y) = δ([y]), y →∗ [y] because
y ≈ [y]. By Cor. 4.7 and y →∗ [y], also y →∗ [y] since i < j. By transitivity of →∗
j	i	i

as in Def. 4.4, [x] →∗ y and y →∗ [y], also [x] →∗ [y]. The other direction follows
i	i	i
right from Thm. 4.16, hence {y ∈ V∃ | x →∗ y} = {y ∈ V∃ | [x] →∗ [y]}.
i	i
To show {y ∈ V∃ | [x] →∗ [y]}⊆ {y ∈ V∃ | [x] ~∗ [y]} first assume [x] →∗ [y],y ∈
i	i
V∃. Then i < δ([y]) since i ≤ δ([y]) by Def. 4.4 and i /= δ([y]) because q(x) /= q(y). By Def. 4.12, δ(y) = δ([y]) and hence δ(x) < δ(y) where i = δ(x). If [x] →∗ [y] for i = δ(x) then also x →∗ y and hence [x] ~∗ [y] by Def. 4.17 and δ(x) < δ(y). The other direction follows from Def. 4.17, q(x) /= q(y), δ(x) < δ(y), x →∗ y for i = δ(x) and Thm. 4.16. Hence {y ∈ V∃ | [x] →∗ [y]} = {y ∈ V∃ | [x] ~∗ [y]}.	 
By Thm. 4.20, relations →∗, →∗ combined with ≈ and ~∗ are equivalent in
i	i
theory for computing D(x).  Note that computing D(x) by →∗ corresponds to
applying the original definition (see also Sec. 3) introduced in [9]. From a practical point of view, →∗ is restricted to classes by ≈ which again can be improved with a compact representation of ~.

Efficiently Representing Directed Dependency Relations
Applying relation ~∗ for dependency computation is most interesting for practical application. Since ~∗ is directed, it restricts the set of classes to be considered when connections of a variable are determined. This contributes to compactness in addition to equivalence classes induced by ≈. In this section we first examine properties of ~∗ over existential variables which allow to efficiently represent its reflexive and transitive reduction ~ as a tree. This tree can be shared between all variables and is the basis for a graph data-structure representing dependencies of universal variables.
The following lemma states a property of ~∗ which accounts for the tree struc- ture of ~.
Lemma 4.21 Let x, y, z ∈ V∃ where δ(x) ≤ δ(y). If [x] ~∗ [z] and [y] ~∗ [z] then
~∗ [y].
Proof. Assume [x] ~∗ [z] and [y] ~∗ [z] for x, y, z ∈ V∃ where δ(x) ≤ δ(y). Then by Def. 4.17, x →∗ z for i = δ(x) and y →∗ z for j = δ(y) and δ(x) ≤ δ(y) ≤ δ(z).
i	j
By Cor. 4.7 also y →∗ z and by Lem. 4.10 z →∗ y. By Def. 4.4, x →∗ z and z →∗ y,
i	i	i	i
also x →∗ y and [x] ~∗ [y].	 
Corollary 4.22 For ~∗ on V∃, ~ can be represented as a forest.
By Lem. 4.21, whenever [x] ~∗ [z] and [y] ~∗ [z] for δ(x) ≤ δ(y) then [x] ~∗ [y]. That is, there is always a transitive edge of the form [x] ~∗ [z] by [x] ~∗ [y] and
~∗ [z]. The transitive reduction ~ of ~∗ removes [x] ~∗ [z] such that at most one class is related to another one. Hence by Cor. 4.22 and due to the properties of ~∗, in ~ situations like in directed acyclic graphs can not occur. This allows ~ on existential variables to be represented as a forest. Note that since ~∗ is directed by Def. 4.17 and hence also antisymmetric and acyclic, its transitive reduction ~ is unique [1].

Definition 4.23 The connection forest (c-forest) for a QBF with m existential scopes is a collection of trees over V∃ with respect to ≈ with the following properties:
For x, y ∈ V∃ : there is an edge ([x], [y]) if, and only if [x] ~ [y].
For x, y ∈ V∃ : there is a path from [x] to [y] if, and only if [x] ~∗ [y].
the maximum length (number of edges) of a path is m − 1.
All paths in the c-forest consist of classes only, the levels of which are strictly increasing by Lem. 4.18. Hence the maximum path length is m − 1.

Computing Dependencies by Directed Dependency Relations
Given a QBF in PCNF, the corresponding c-forest for V∃ is the basis for computing
D(x) for all x ∈ V∀.
Definition 4.24 For x ∈ V∀,y ∈ V∃ and the c-forest, let h(x, [y]) = [y'] such that y' ∈ V∃, [y'] ~∗ [y], δ(x) < δ(y') and there is no y'' ∈ V∃ with δ(x) < δ(y'') < δ(y') and [y''] ~∗ [y].
In the c-forest class h(x, [y]) denotes the smallest ancestor of [y] which is larger than x, hence h(x, [y]) is minimal with respect to the scope ordering.
Definition 4.25 For a QBF F , x ∈ V∀ and the c-forest, the set of descendants
H∗(x) is defined as follows:
C(x) := {C ∈ F | x ∈ C}
VC(x) := {[y] | y ∈ V∃,i,i = δ(x) and y ∈ C for C ∈ C(x)}
H(x) := {[z] | [z] = h(x, [y]) for [y] ∈ VC(x)}
H∗(x) := {[y] | [z] ~∗ [y] for [z] ∈ H(x)}
From clauses containing x, classes of existential variables larger than x are col- lected in VC(x). Note that if [y] ∈ VC(x) then x →∗ y for i = δ(x). H(x) contains smallest ancestors for classes in VC(x). H∗(x) comprises descendants of classes in H(x) and represents all connections of x to existential variables larger than x.
Lemma 4.26 For x ∈ V∀,i = δ(x) : if [y] ∈ H∗(x) then x →∗ y.
Proof. Let [y] ∈ H∗(x) for x ∈ V∀. Then by Def. 4.25 [z] ~∗ [y] for [z] ∈ H(x) where [z] = h(x, [y']) for some [y'] ∈ VC(x). Then x →i y' for i = δ(x) by definition of set VC(x) and also x →∗ [y'] by Thm. 4.16. By Def. 4.17 and since δ(x) < δ(y') also [x] ~∗ [y']. Because [z] = h(x, [y']) also [z] ~∗ [y'] by definition of function
h.  By Def. 4.24 δ(x) < δ(z) and by [x] ~∗ [y'], [z] ~∗ [y'] and Lem. 4.21 also
[x] ~∗ [z].  By Def. 4.17, [x] ~∗ [z] and [z] ~∗ [y] also [x] ~∗ [y] and finally
x →∗ y.	 
For x ∈ V∀, the set of descendants H∗(x) in the c-forest exactly characterizes connections of x to relevant (larger) existential variables. This is sufficient for computing D(x) as stated in the following theorem.

Theorem 4.27 For x ∈ V∀ : D(x) = {y | y ∈ [z] for [z] ∈ H∗(x)}.
Proof. Assume x ∈ V∀. Direction ⊇ follows right from Lem. 4.26 and Thm. 4.20 since if y ∈ [z] for [z] ∈ H∗(x) then x →∗ y for i = δ(x) by Lem. 4.26 and further
y ∈ D(x) by Thm. 4.20.
To show ⊆, assume y ∈ D(x) and i = δ(x). Then by Thm. 4.20 x →∗ y and by Cor. 4.5 there is an X-path P between x and y for X = V∃,i. Hence there are clauses C1,..., Ck where x ∈ C1 and y ∈ Ck. Since P connects x and y, also x, y1 ∈ C1 for some y1 ∈ V∃,i with δ(x) < δ(y1). Such y1 always exists since by assumption the largest literal in a clause is existential. Thus [y1] ∈ VC(x) and [z1] ∈ H(x) for [z1] = h(x, [y1]). Then by Def. 4.24, [z1] ~∗ [y1]. P is also an X-path between y1 and y by C1,..., Ck, hence y1 →∗ y and δ(x) < δ(y1), δ(x) < δ(y). Let w denote the smallest connecting variable in P between y1, y: m = δ(w) = min({δ(v) | v ∈

Ci ∩ Ci+1 ∩ X, 1 ≤ i < k}). Since m is minimal, also y1 →∗
w, w →∗
y and by

Lem. 4.10 w →∗ y1. By Def. 4.17 and since m = δ(w), also [w] ~∗ [y1], [w] ~∗ [y].
By Lem. 4.21, [z1] ~∗ [y1] and [w] ~∗ [y1], also [z1] ~∗ [w]. Then by [z1] ~∗ [w],
[w] ~∗ [y] and transitivity also [z1] ~∗ [y], hence [y] ∈ H∗(x) because [z1] ∈ H(x). 
By Thm 4.27 and Def. 4.25 members of classes in H∗(x) exactly correspond to
D(x). Computing D(x) from a c-forest therefore does not require searching since subtrees rooted at classes in H(x) denote subsets of D(x). Thus the c-forest, which is computed once and then shared between all x ∈ V∀, combined with sets H(x) is sufficient to identify and compactly represent D(x).
Example 4.28 Fig. 1 shows a c-forest (dotted edges) and sets H(x) (solid edges). Variables e3, e4 and e12, e13 are in one class, respectively (horizontal edges). According to Def. 4.25, C(a1) = C(a6) = {(a1, a6, e8, e13)}, VC(a1) = VC(a6) = {[e8], [e13]}, H(a1) = {[e3]}, H∗(a1) = {[e3], [e8], [e10], [e13]}, H(a6) = 
{[e8]}, H∗(a6) = {[e8], [e13]}, D(a1) = {e3, e4, e8, e10, e12, e13} and D(a6) =
{e8, e12, e13}. Note that the path from [e8] to [e13] is shared between variables
a1 and a6.

Experimental Results
We have implemented a tool which, given a QBF in PCNF, builds the c-forest and determines sets H(x) for all x ∈ V∀ incrementally. Clauses are inspected exactly once one after another: a pair of variables x, y ∈ C for some clause C where x ∈ V∀, y ∈ V∃ and δ(x) < δ(y) results in an update of H(x) by adding h(x, [y]). If x, y ∈ V∃ and δ(x) ≤ δ(y) then the c-forest is updated by inserting an edge for [x] ~∗ [y]. Relation ≈ is computed using an efficient union-find algorithm [25]. Tab. 1 shows experimental results on structured formulae from QBF competitions [16]. 3
The first line shows the number of formulae per set. Run times are in seconds for the whole set and on average per formula. Maximum and average sizes of sets
∗
H∗(x) and D(x) for x ∈ V∀ are reported (see also Sec. 4.2).  |H (x)| for x ∈ V∀

3 Setup: 64-bit Ubuntu Linux 8.04, Intel Q6700 at 2.66 GHz, 8 GB of memory.


Table 1
Experimental results on structured formulae from QBF competitions 2005 to 2008 [16]. Columns labelled 2005 to 2008 denote formulae sets from QBFEVAL competitions of the respective year. See section 5 for comments.

relates the sizes of the two representations of D(x): the c-forest is compared to the directly computed set by →∗. The worst-case value is 100%, which means no improvement can be achieved by the c-forest. On the contrary, the average of |H (x)| over all x ∈ V∀ indicates that the c-forest representing ~ allows to represent D(x) more compactly than →∗. This observation is supported by the maximum and average values of |H∗(x)| and |D(x)|. The last line reports the ratio between the
total number of equivalence classes and the total number of existential variables per
formula set, where the worst-case value is 100%: one class per variable. The values indicate that there are few, yet large classes which demonstrates the compacting effect of relation ≈.

Conclusion
We have presented an efficient way to compute and represent dependency sets for all universal variables in QBFs, which is relevant for expansion-based QBF solvers. As previous work, our approach relies on a syntactic connection relation of variables. By defining an equivalence relation on existential variables and excluding transitive edges, we obtain a directed connection relation which can be implemented using a tree and a union-find data structure. This relation can be shared between all universal variables. Experiments show that dependencies can be compactly repre- sented with our approach. We are planning to extend this method to dependency sets for existential variables for use in search-based QBF solvers. Furthermore, our representation can be regarded as static, that is, the effect of removing clauses from the formula has not yet been taken into consideration. Certainly, a dynamic version will be more flexible when used in combination with variable expansion.

References
Aho, A. V., M. R. Garey and J. D. Ullman, The Transitive Reduction of a Directed Graph, SIAM J. Comput. 1 (1972), pp. 131–137.
Ayari, A. and D. A. Basin, QUBOS: Deciding Quantified Boolean Logic Using Propositional Satisfiability Solvers, in: M. Aagaard and J. W. O’Leary, editors, FMCAD, Lecture Notes in Computer Science 2517 (2002), pp. 187–201.
Bacchus, F. and T. Walsh, editors, “Theory and Applications of Satisfiability Testing, 8th International Conference, SAT 2005, St. Andrews, UK, June 19-23, 2005, Proceedings,” Lecture Notes in Computer Science 3569, Springer, 2005.
Benedetti, M., Quantifier Trees for QBFs, in: Bacchus and Walsh [3], pp. 378–385.
Benedetti, M., sKizzo: A Suite to Evaluate and Certify QBFs, in: R. Nieuwenhuis, editor, CADE, Lecture Notes in Computer Science 3632 (2005), pp. 369–376.
Benedetti, M. and H. Mangassarian, QBF-Based Formal Verification: Experience and Perspectives, JSAT 5 (2008), pp. 133–191.
Biere, A., Resolve and Expand, in: H. H. Hoos and D. G. Mitchell, editors, SAT (Selected Papers), Lecture Notes in Computer Science 3542 (2004), pp. 59–70.
Biere, A., A. Cimatti, E. M. Clarke and Y. Zhu, Symbolic Model Checking without BDDs, in:
R. Cleaveland, editor, TACAS, Lecture Notes in Computer Science 1579 (1999), pp. 193–207.
Bubeck, U. and H. K. Bu¨ning, Bounded Universal Expansion for Preprocessing QBF, in: J. Marques- Silva and K. A. Sakallah, editors, SAT, Lecture Notes in Computer Science 4501 (2007), pp. 244–257.
Bu¨ning, H. K., M. Karpinski and A. Fl¨ogel, Resolution for Quantified Boolean Formulas, Inf. Comput.
117 (1995), pp. 12–18.
Cadoli, M., A. Giovanardi and M. Schaerf, An Algorithm to Evaluate Quantified Boolean Formulae, in: AAAI/IAAI, 1998, pp. 262–267.
Davis, M., G. Logemann and D. Loveland, A Machine Program for Theorem-proving, Commun. ACM
5 (1962), pp. 394–397.
Dershowitz, N., Z. Hanna and J. Katz, Bounded Model Checking with QBF, in: Bacchus and Walsh [3],
pp. 408–414.
Egly, U., M. Seidl, H. Tompits, S. Woltran and M. Zolda, Comparing Different Prenexing Strategies for Quantified Boolean Formulas, in: E. Giunchiglia and A. Tacchella, editors, SAT, Lecture Notes in Computer Science 2919 (2003), pp. 214–228.
Egly, U., H. Tompits and S. Woltran, On Quantifier Shifting for Quantified Boolean Formulas, in:
Proc. SAT’02 Workshop on Theory and Applications on QBFs, 2002, pp. 48–61.
Giunchiglia, E., M. Narizzano and A. Tacchella, QBF Solver Evaluation Portal (2001), http://www. qbflib.org/index_eval.php.
Giunchiglia, E., M. Narizzano and A. Tacchella, Backjumping for Quantified Boolean Logic satisfiability, Artif. Intell. 145 (2003), pp. 99–120.
Giunchiglia, E., M. Narizzano and A. Tacchella, Quantifier Structure in Search-Based Procedures for QBFs, IEEE Trans. on CAD of Integrated Circuits and Systems 26 (2007), pp. 497–507.
Jussila, T. and A. Biere, Compressing BMC Encodings with QBF, ENTCS 174 (2007), pp. 45–56.
Lonsing, F. and A. Biere, Nenofex: Expanding NNF for QBF Solving, in: H. K. Bu¨ning and X. Zhao, editors, SAT, Lecture Notes in Computer Science 4996 (2008), pp. 196–210.
Lonsing, F. and A. Biere, A Compact Representation for Syntactic Dependencies in QBFs, in:
O. Kullmann, editor, SAT, Lecture Notes in Computer Science 5584 (2009), pp. 398–411.
QBFLIB, QDIMACS Standard v1.1, http://www.qbflib.org/qdimacs.html.
Samer, M. and S. Szeider, Backdoor Sets of Quantified Boolean Formulas, Journal of Automated Reasoning (JAR) 42 (2009), pp. 77–97.

Stockmeyer, L. J. and A. R. Meyer, Word Problems Requiring Exponential Time: Preliminary Report, in: STOC (1973), pp. 1–9.
Tarjan, R. E., Efficiency of a Good But Not Linear Set Union Algorithm, J. ACM 22 (1975), pp. 215– 225.
Zhang, L. and S. Malik, Conflict driven learning in a quantified Boolean Satisfiability solver, in: L. T. Pileggi and A. Kuehlmann, editors, ICCAD (2002), pp. 442–449.
