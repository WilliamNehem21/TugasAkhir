

Electronic Notes in Theoretical Computer Science 223 (2008) 87–102
www.elsevier.com/locate/entcs

The Reach-and-Evolve Algorithm for Reachability Analysis of Nonlinear Dynamical Systems
Pieter Collins2
Centrum voor Wiskunde en Informatica Amsterdam, The Netherlands
Alexandre Goldsztejn3
CNRS, LINA, UMR 6241
Nantes, France

Abstract
This paper introduces a new algorithm dedicated to the rigorous reachability analysis of nonlinear dynamical systems. The algorithm is initially presented in the context of discrete time dynamical systems, and then extended to continuous time dynamical systems driven by ODEs. In continuous time, this algorithm is called the Reach and Evolve algorithm. The Reach and Evolve algorithm is based on interval analysis and a rigorous discretization of space and time. Promising numerical experiments are presented.
Keywords: Reachability analysis, nonlinear dynamical systems, interval analysis.


Introduction
We consider the computation of the reachable set of a dynamical system. For a set of initial conditions X0 ⊆ Rn and a system f with time axis T, the reachable set is defined as
Reach(f , X0) := {y |∃ solution x(·) of f and t ∈ T
s.t. x(0) ∈ X0 and x(t)= y}.  (1)

1 P. Collins was partially supported by the Nederlandse Wetenschappelijk Organisatie (NWO) through VIDI project number 639.032.408 .
2 Email: Pieter.Collins@cwi.nl
3 Email: Alexandre.Goldsztejn@univ-nantes.fr

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.12.033

We present a high-level algorithm for computing over-approximations reachable set, which can be effectively implemented in different ways. We consider both discrete- time systems defined by iterated maps
x(k + 1) = f(x(k)),	(2)
where x(k) ∈ Rn and f : Rn −→ Rn is a continuous function, and continuous-time systems defined by differential equations
x˙ (t)= f(x(t)),	(3)
where x(t) ∈ Rn and f : Rn −→ Rn is a locally Lipschitz function.
In this paper, we present a high-level algorithm for rigorously computing an enclosure of the reachable set (1) for dynamical systems (2,3) defined by arbitrary nonlinear continuous functions. In continuous time, we call our algorithm the Reach- and-Evolve algorithm (R&E ) since it involves computing reachability steps and evolution steps for the system. The algorithms are based on interval analysis which is introduced in Section 2. Section 3 presents the R&E algorithm, and some of its properties. Promising experiments are finally presented in Section 4.

Interval Analysis
The modern interval analysis was born in the 60’s with [14]. Since, it has been widely developed and is today one important branch of numerical analysis (see [1,16,8,7] and extensive references). The main concepts of interval analysis that will be used in the sequel are now presented.
Interval and Interval Vectors
Interval analysis usually considers only closed intervals. The set of these intervals is denoted by IR. An interval is usually denoted using brackets. As often as possible, the bounds of the interval [x] are denoted by x and x, i.e. [x] = [x, x], and an element of [x] by x. Interval vectors (boxes) can be defined in two equivalent ways: First as a vector of intervals [x] = ([x1],... , [xn]). In this case x ∈ [x] is defined by x1 ∈ [x1], ..., xn ∈ [xn]. Second, as a interval of vectors [x] = [x, x] where x, x ∈ Rn such that x ≤ x, the inequality being defined component-wise. In this case x ∈ [x] is defined by x ≤ x ≤ x. Both definitions are obviously equivalent, and used indifferently. Interval matrices are defined in the same way.
Interval Extensions
The main concept of interval analysis is the extension of real functions to intervals, which is defined as follows:
Definition 2.1 Let f : Rn −→ Rm be a continuous real function, and [f]: IRn −→
be an interval function. Then [f] is an interval extension of f if and only if for every [x] ∈ IRn, {f(x): x ∈ [x]} ⊆ [f ]([x]).

Remark 2.2 It is important to note the difference between f ([x]) which is the exact range of the function over [x], i.e. f ([x]) = {f(x): x ∈ [x]} and [f ]([x]) which is the evaluation of an interval function. Usually, the symbol [f ] is used for an interval extension of the real function f , and in this case f ([x]) ⊆ [f ]([x]).
Hence, an interval extension allows computing enclosures of the image of boxes by real functions. This definition is very useful in many contexts, obviously including reachability analysis. It now remains to show how to compute such extensions.
The first step is to compute formally the interval extension of elementary func-

tions. For example, we define [x]+ [y] := [x + y, x + y]. Similar simple expressions are obtained for other functions like −, ×, ÷, xn, √x, exp,.   This process gives rise
to the so-called interval arithmetic.
Then, an interval extension for real functions compound of these elementary operations is simply obtained changing the real operations to their interval coun- terparts. This interval extension is called the natural interval extension.
Example 2.3 Let f (x, y)= x(y − x). The interval function [f ]([x], [y]) = [x]([y] −
[x]) is the natural interval extension of f . Hence for example
[f ]([0, 1], [−1, 1]) = [−2, 1] ⊇ {f (x, y): x ∈ [0, 1],y ∈ [−1, 1]}.	(4)
Note that the exact range is f ([0, 1], [−1, 1]) = [−2, 1/4], and the natural interval extension is thus pessimistic. One main issue of interval analysis is to fight this pessimism introduced by the interval evaluation of a function.
There are other interval extensions, in particular the mean-value interval ex- tension which uses the natural extension of the derivatives to try improving the enclosure. See [16] for details.
Finally, the interval arithmetic also allows extending vector/matrix and ma- trix/matrix multiplications. Such definitions preserve the enclosing property of interval extensions (they are actually special cases of interval extensions).
Remark 2.4 When one represents numbers using a finite precision [5], the previous operations cannot be computed in general. The outer rounding is then used so as to keep valid the interpretations. For example, [1, 2]/[3, 7] would result of [0.142, 0.667] if rounded with a three decimal accuracy. Such an outer rounding is implemented in most interval libraries, e.g. [9,20,21].
Rigorous Iteration of Maps
While it is possible to iterate a dynamical system f : Rn → Rn using an interval extension [f] : IRn → IRn directly, the errors of this approximation tend to grow exponentially due to the so-called wrapping effect. There are many methods used in the literature to reduce the wrapping effect, all of which rely on using higher- order enclosures of the set of evolved points. Such methods include ellipsoidal calculus [11], orthogonal parallelotopes [12], zonotopes [10] and Taylor models [13]. We henceforth assume a class E of enclosure sets which are used to enclose the

current state set, and an enclosure extension ⟨f⟩ : E → E of f such that
⟨f⟩(⟨x⟩) ⊃ f(⟨x⟩).	(5)
Of course, we want the enclosure extension to be better than the interval extension
i.e. ⟨f⟩([x]) ⊂ [f ]([x]) for [x] ∈ IRn ∩ E.
Rigorous Integration of Ordinary Differential Equations
The rigorous integration of continuous time dynamical systems driven by ODEs is an important application of interval analysis. It can be formalized as follows. The ODE x˙ (t) = f(x(t)) gives rise to an operator Φ : R × Rn −→ Rn which associate x(t) to x(0), i.e. Φ(t, x(0)) = x(t). This operator is called the solution operator of the ODE. Note that in general the solution operator is not defined inside the whole space R × Rn but instead in a subspace. For clarity, we will use R × Rn.
Interval analysis offers a wide variety of methods dedicated to computing interval extensions and enclosure extensions of Φ. This means that given a time interval
[t] and an enclosure ⟨x⟩, the evaluation of an enclosure extension ⟨Φ⟩ gives rise to an enclosure that contains all solutions which start inside ⟨x⟩ after evolution for a duration included inside [t]. This rigorous enclosure of the flow is basically obtained using a truncated Taylor series with a rigorous bound on the remainder. For details on parallelepiped methods, see the survey paper [15] and references therein. For the Taylor method see [13] and references therein. It is also very useful to rigorously compute the space derivatives of the flow [22,6].
For completeness, a simple interval integrator is presented in Appendix A. It is based on a first order Taylor expansion with rigorous bound of the remainder. Higher order expansions are much more efficient, but the method presented in Ap- pendix A is simple to present and gives rise to interesting results.

The Reach and Evolve Algorithm
Bounded Reachability Analysis
In discrete-time, the reachable set can be written
Reach(f , X0) =   f k(X0).	(6)
k∈N
In order to compute the reachable set with the unbounded time horizon using a purely numerical algorithm, we need the trajectories of (2,3) starting in X0 to be bounded in space. To force this property in general, we introduce the bounded reachable set as follows: Let U be a bounded subset of Rn (called the universe),
then
ReachU(f , X0) :=   (fU)k(X0	U),	(7)
k∈N
where fU(X)= f(X) ∩ U.

In general ReachU(f , X0) is only a subset of Reach(f , X0). However, in several situations this relationship can be stronger. When U happens to be a trapping region that contains X0 then the equality holds. A weaker condition can be verified a posteriori:
f ReachU(f , X0) ⊆ U =⇒ ReachU(f , X0)= Reach(f , X0).	(8)
Also, when every trajectory which leaves U remains outside U then ReachU(f , X0)= Reach(f , X0)∩U. This allows tackling a large class of reachability problems by com- puting an enclosure of the bounded reachable set. Furthermore, in some situations such a universe is meaningful because physical solutions outside this universe do not exist, and the bounded reachable set is then useful by itself.
In continuous time, the bounded reachable set is

ReachU(Φ, X0) :=	 
t∈R+
ΦU(t, X0 ∩ U),	(9)

where R+ = {x ∈ R : x ≥ 0} and ΦU is defined similarly to fU:
ΦU(t, X0) := y ∈ Rn : ∃x ∈ X, y = Φ(t, x) ∧ ∀t' ≤ t, φ(t, x) ∈ U ,.	(10)

Boxes and Enclosure Sets
In order to perform a global analysis of our system in some universe U, we take a finite subset B of the set of all boxes B in Rn such that the elements of B have disjoint interiors and form a cover of the universe	. We perform numerical computation of the system evolution on a class of enclosure sets E.
To convert from boxes to enclosure sets, we assume that we have access to a function Enclose : B → E such that
[x] ⊂ Enclose([x]).	(11)
In many cases we have B ⊂ E, and can take Enclose to be the identity. We also as- sume we have access to a function Cover : E ×P(B) → P(B) such that Cover(⟨x⟩, B) returns a cover of ⟨x⟩ by boxes in B. Formally, Cover is required to satisfy
{[u] ∈B : [u] ∩ ⟨x⟩ /= ∅} ⊆ Cover(⟨x⟩, B) ⊆ B.	(12)
If ⟨x⟩ ⊂  B, then ⟨x⟩ ⊆ Cover(⟨x⟩, B).Such a function is easily implemented as soon as a sufficient condition for [u] ∩ E is available.
Remark 3.1 If implemented naively, the function Cover has a complexity propor- tional to the number of elements in B even for small sets ⟨x⟩. This is impracticable since B is huge and the function Cover will be intensively called for small sets
⟨x⟩. An indexation of the elements of B, which reduces the complexity of Cover to log(card B) for small sets ⟨x⟩, is therefore necessary.

Reachability Algorithm for Discrete Time Dynamical Systems
Let us consider the discrete-time dynamical system (2). The reachable set is given by
Reach(f , X0)=   f k(X0)	(13)
k∈N
We also consider a finite set of boxes B whose union 4  B will play the role of the universe. These boxes represent the discretization of space, and hence need to be taken sufficiently small. On the other hand, the smaller the more expensive will be the computation on this discretization. The reachability algorithm is given in Algorithm 1.
Algorithm 1 In: f , X0, B	Out: R = RA(f , X0, B) 1:	I ← Cover(X0, B)
2:	R←I and P ← ∅
3:	while R\P =/	∅
4:	[x] ← Element(R\P)
5:	⟨x⟩← Enclose([x])
6:	⟨y⟩← ⟨f⟩(⟨x⟩)
7:	R←R ∪ Cover(⟨y⟩, B)
8:	[x]
9:	end while
10: return R

Informally, the algorithm works as follows. The initial condition X is discretized as a union of boxes I from B i.e. X0 ⊂  I and I ⊆ B. The set I is computed from the initial set X0 using a function Cover : P(Rn) × P(B) → P(B). The over-approximation to the (bounded) reachable set computed by the reachability algorithm is also union of boxes R from B. The principle of the algorithm is simple: R contains all the boxes that have been reached so far. These boxes needs to be propagated computing their image. However, the key point is to note that if a box has already been propagated, which means that its image is already covered by the boxes of R, then it is useless to propagate it again. Therefore, the reachability algorithm maintains a list of boxes P which contains the boxes that have already been propagated. So, the boxes that actually remain to be propagated are the boxes of R\P, and the algorithm stops when R\P = ∅, which means that no more box has to be propagated. The propagation itself is performed in Lines 5-7.
Remark 3.2 The set difference R\P at Line 3 can be expensive to compute when R and P are large. In practice, the algorithm is slightly modified to prevent com- puting this set difference by updating incrementally a set of boxes which remains equal to R\P.

4 The union of a set of boxes contains every vector which belong to at least one of these boxes, e.g.
∪{[0, 1], [2, 4], [3, 5]} = {x ∈ R : x ∈ [0, 1] ∨ x ∈ [2, 5]}.

Remark 3.3 The same algorithm can be used to compute the reachable set for a multivalued map F : Rn ⇒ Rn, as long as an enclosure extension ⟨F⟩ : E ⇒ E

Properties of the Reachability Algorithm
In this section, Algorithm 1 is first prove to halt, and then to be correct.
Proposition 3.4 (Halting) The Reachability Algorithm 1 halts after a ﬁnite num- ber of executions of the while-loop.
Proof. Using a simple induction, P starts empty (Line 2) and is added elements of R at Line 8 (because [x] ∈R in Line 4). Therefore, P ⊆ R holds during the whole execution. Now, Cover(⟨y⟩, B) ⊆ B as a consequence of (12). A simple induction using Line 2 and Line 8 thus shows that R⊆ B during the whole execution. There- fore P ⊆ B holds during the whole execution. Finally, the cardinality of P increases of one at each execution of the while-loop, but is bounded by the cardinality of B. Therefore, P reaches its limit in a finite number of executions of the while-loop. Then, R\P has to be empty, otherwise P would increase more. The while-loop halts at this moment.
The following Lemma will be used in the proof of correctness of Algorithm 1.
Lemma 3.5 If fU(X) ⊆ X holds then ReachU(f , X) ⊆ X.
Proof. By definition of the bounded reachable set (7), it is sufficient to prove that for all k ∈ N the inclusion (fU)k(X ∩ U) ⊆ X holds. Let us prove this by induction. For k = 0, (fU)0(X ∩ U)= X ∩ U ⊆ X. Now, let us suppose that (fU)k(X ∩ U) ⊆ X holds. Then (fU)k+1(X ∩ U)= fU((fU)k(X ∩ U)) ⊆ fU(X) ⊆ X, which concludes the proof.
Proposition 3.6 (Correctness) If U ⊂  B, then the following inclusion holds:
ReachU(f , X0) ⊆   RA(f , X0, B).	(14)
Proof. First, let us prove by induction that
 x ∈ (  P) ∧ f(x) ∈ (  B)  =⇒ f(x) ∈ (  R)	(15)
holds during the whole execution of the algorithm. Entering the first time in the while-loop, P is empty and hence (15) trivially holds. Now suppose that (15) holds when entering the while-loop. Then leaving the while-loop, P has been added the box [x]. But in the same time, R has been added Cover(f , [x], B), and therefore
(15) holds when finishing the while-loop.
Now, when the algorithm halts P = R and thus (15) gives rise to
 x ∈ (  R) ∧ f(x) ∈ (  B)  =⇒ f(x) ∈ (  R).	(16)

This reads f   (   )  (   ). Therefore, Lemma 3.5 can be applied to prove
that Reach (f ,  )  (  ) holds. Finally, as X  U	the inclusion ReachU(f ,  I) ⊆ ReachU(f ,  R) holds, which concludes the proof.		 
In [3,4], it is shown that any algorithm which relies on numerical approximations cannot in general compute arbitrarily accurate over-approximations to the reachable set itself, but only convergence to the chain-reachable set can be achieved. It can be shown that the result of Algorithm 1 converges to the chain reachable set as the maximum width of the boxes of B converges to zero, assuming convergence conditions on the enclosure extension ⟨f⟩ and the function Enclose and Cover. The experiments presented in Section 4 show sharp enclosures of the bounded reachable sets.
The Reach-and-Evolve Algorithm for Discrete Time Dynamical Systems
We now consider the R&E algorithm for systems in discrete time. The main problem with the basic reachability algorithm is that at each step, we perform an over- approximation of the enclosure set on a grid. This operation introduces zero-order errors, and hence causes a greater loss of accuracy than the higher-order enclosure computation. To reduce the errors, we can modify the algorithm so that we only perform an over-approximation on a grid every M steps. We call the new algorithm the discrete-time reach-evolve algorithm.
Fix M > 0 and define the evolution step operator eM : Rn	Rn and the
reachability step operator rM : Rn ⇒ Rn by

eM (x) := f M (x);	rM (x) :=
M −1

m=0
f m(x).	(17)

The following elementary proposition shows how to re-write the reachability algo- rithm (7).
Proposition 3.7
Reach(f , X0) =   ek (rM (X0)) = Reach(eM , rM (X0)).	(18)
k∈N
We can therefore use Algorithm 1 to compute the bounded reachable set Reach B(f , Φ) as follows. First, a set of boxes I is computed such that  I ⊇ X0 ∩ U (this is easily done using the function Cover). Next, an over-approximation of	f ( ) is computed using en enclosure extension r of r . Finally, Algorithm 1 is applied to eM , H and B, returning a superset of ReachU(f , X0) by Proposition 3.9. This yield the Reach-and-Evolve Algorithm 2.
The “reach” part of the algorithm is in Lines 3-9, and the “evolve” part in Lines 10- 16.
Remark 3.8 By increasing M , the accuracy of the algorithm is increased, since the number of evolution steps between each over-approximation on the grid is large.

Algorithm 2  In: f , X0, B, M	Out: R = RE(f , X0, B,M )

1:	I ← Cover(X0, B)
10: while R\P =/	∅

2:	R←∅ and P ← ∅
3:	for [x] in I
4:	⟨x0⟩← Enclose([x])
5:	for m =0 to M − 1
6:	R←R ∪ Cover(⟨xm⟩, B)
7:	⟨xm+1⟩← ⟨f⟩(⟨xm⟩)
8:
9:	end for
11:	[x] ← Element(R\P)
12:	⟨x⟩← Enclose([x])
13:	⟨y⟩← ⟨f ⟩M (⟨x⟩)
14:	R←R ∪ Cover(⟨y⟩, B)
15:	[x]
16: end while
17: return R



However, the algorithm will essentially evolve many times over the same part of state space, which is computationally more expensive. We expect the complexity of the algorithm to be roughly proportional to M . However, decreasing the size of the state-space grid can be even more expensive, typically exponential in the dimension d.

The Reach-and-Evolve Algorithm for Continuous Time Dynamical Systems
We now consider the R&E algorithm for systems in continuous time. Let Φ(t, x) be the solution operator of the ODE (3). The reachable set can then be written as

Reach(Φ, X0) :=	 
t∈R+
Φ(t, X0).	(19)

Fix h > 0 and define the evolution step operator eh : Rn	Rn and the reachability step operator rh : Rn ⇒ Rn by
eh(x) := Φ(h, x);	rh(x) := Φ([0, h], x)	(20)
The following proposition shows how to discretize rigorously time in order to apply the reachability algorithm to enclose (9).
Proposition 3.9
Reach(Φ, X0) =   ek(rh(X0)) = Reach(eh, rh(X0)).	(21)
k∈N
We can therefore use Algorithm 1 to compute the bounded reachable set Reach B(f , Φ) as follows. First, a set of boxes I is computed such that  I ⊇ X0 ∩ U (this is easily done using the function Cover). Next, an over-approximation of Φ([0, h],	) is computed using en enclosure extension r	of r . Finally, Algorithm 1 is applied to eh,	H and B, returning a superset of ReachU(Φ, X0) by
Proposition 3.9. This yield the Reach-and-Evolve Algorithm 3.
The “reach” part of the algorithm is in Lines 3-7, and the “evolve” part in Lines 8-14.

Algorithm 3  In: f , X0, B, h	Out: R = RE(f , X0, B, h)

1:	I ← Cover(X0, B)
8:	while R\P =/	∅

2:	R←∅ and P ← ∅
3:	for [x] in I
4:	⟨x⟩← Enclose([x])
5:	⟨y⟩← ⟨rh⟩(⟨x⟩)
6:	R←R ∪ Cover(⟨y⟩, B)
7:
9:	[x] ← Element(R\P)
10:	⟨x⟩← Enclose([x])
11:	⟨y⟩← ⟨eh⟩(⟨x⟩)
12:	R←R ∪ Cover(⟨y⟩, B)
13:	[x]
14: end while
15: return R


Remark 3.10 A na¨ıve way of computing the reachable set is to use the for- mula Reach(f , X0) = k∈N rk(X0) and to apply Algorithm 1 to rh. This ap- proach fails because of the inherent over-approximation involved in computing Cover(rh(Enclose([x])), B). Note that x ∈ Φ([0, h], x) for all x. Hence the over- approximation of rh([x]) is likely to contain all boxes touching [x]. Iteration of this operator will therefore ultimately result in all boxes being found!
Remark 3.11 An alternative way to compute the reachable set is to use the for- mula Reach(f , X0) = rh  k∈N ek(X0) . However, the ordering (21) used in Algo- rithm 3 appears to be more efficient in practice.

Numerical Experiments
We report experiments on two non linear dynamical systems. Algorithm 1 has been implemented in C++, using the interval library PROFIL/BIAS [9], and ran on an Intel Dual Core 2.2Ghz processor.
In all cases, the universe is a box. This box is covered by a set of boxes B, which is used in the algorithm. The initial conditions are disks. In order to be used in the algorithm, these disks are covered using boxes of B, resulting in a list of box I whose union contains the initial condition. The enclosure of the bounded reachable set computed by the reachability algorithm is a subset R of B. However, the number of boxes in R is too big to obtain nice graphical representations. Therefore a post- processing that reduces the number of boxes is performed .
The H´enon Map
The H´enon map is defined by
⎛ x2 +1 − ax2 ⎞

f(x)= ⎝
bx1
⎠ .	(22)

We use here the standard parameter values a = 1.4 and b = 0.3 for which the dynamical system is chaotic. The universe is chosen to be U = {x ∈ R2 : −2 ≤ x1 ≤ 2, −2 ≤ x2 ≤ 2}. The bounded reachable set computed by the reachability algorithm is shown in Figure 1, the initial condition being the disk centered at



Fig. 1. Enclosure of the bounded reachable set (gray boxes) for the H´enon map and the black disk as initial condition.
(−0.5, 0) of radius 0.2. It has been computed in 7.5 seconds. Furthermore, the initial condition is inside the well known trapping region of the H´enon map, and
therefore the bounded reachable set is equal to the reachable set.

Continuous Time Dynamical System with a Limit Cycle
The ODE x'(t) = f(x(t)) with
⎛ x1 − x2 − x1(x2 + x2) ⎞
f(x) = ⎝	2	2 ⎠	(23)
x1 + x2 − x2(x1 + x2)
has an attracting cycle. It is interesting to verify that the R&E algorithm allows separating the two areas of the universe that are separated by this cycle. The bounded reachable sets computed by the R&E algorithm are shown in Figure 2 for two initial conditions (the disks centered at (1.5, 1.5) and (0, 0) respectively,
and of radius 0.2). The universe is U = {x ∈ R2 : −2 ≤ x1 ≤ 2, −2 ≤ x2 ≤ 2}
and the step size used for discretization of time is h = 0.005. They both have
been computed in 250 seconds. Furthermore, we can again check a posteriori that Φ(h, R) ⊆ ( B), which implies that the bounded reachable is is equal to the reachable set. In both cases, the R&E algorithm is able to separate the two area
delimited by the attracting cycle. Up to the authors knowledge, the R&E algorithm is the first numerical algorithm which is able to prove rigorously this separation for such a nonlinear dynamical system.

Comparison with HSolver
HSolver [18,19] is dedicated to the safety analysis for nonlinear hybrid systems. This include ODE driven dynamical systems. In this case, HSolver also tackles bounded reachable sets. It is based on interval analysis and constraint propagation. Although HSolver tackles a larger class of problem than the R&E algorithm presented in this paper, the following example shows that it lacks efficiency for the reachability analysis of ODE driven dynamical systems.
Let us consider the linear ODE x'(t) = x(t), the universe U = {x ∈ R2 : 0 ≤ x1 ≤
10, 0 ≤ x2 ≤ 10} and the initial condition X = {x ∈ R2 : 1 ≤ x1 ≤ 10, 0 ≤ x2 ≤ 1}.




Fig. 2. Enclosure of the bounded reachable set (gray boxes) for an ODE with an attracting cycle, and two different initial conditions (displayed in black).

We wish to decide whether the vector (7, 10) is inside the bounded reachable set or not. Because of the simplicity of the system, it is easy to see that it is not. However, HSolver fails to prove this property after 10 minutes of computations 5 . The enclosure of the bounded reachable set computed by the R&E algorithm in 36 seconds is represented in Figure 3 with a step size h = 0.1. It clearly shows that (7, 10) is not reachable inside the universe U. Note that the enclosure shown on Figure 3 has been computed using the simple integrator described in Appendix
A. The usage of a more sophisticated interval integrator should improve a lot the enclosure, while HSolver cannot benefit of the usage of higher order Taylor expansions.

Conclusion
Dealing with an infinite time horizon within a purely numerical algorithm is difficult, but necessary for enclosing rigorously reachable sets of nonlinear dynamical systems. In this paper, we introduced the bounded reachable set, which forces the space variables to be bounded. Once space is bounded, the infinite time horizon can be handled rigorously through the Reach and Evolve algorithm proposed in this paper. The inclusion of the reachable set inside the bounded reachable set in several situations allows tackling a large variety of reachability problems.
Presented experiments have shown that the R&E algorithm is able to compute accurate enclosures of the reachable set for non-trivial nonlinear dynamical systems. It has also been compared to Stefan Ratschan’s HSolver, and shows a much better behavior. It can be noted that on the one hand HSolver is dedicated to a wider class of hybrid problems. On the other hand, the R&E algorithm will directly benefit of the usage of high order Taylor expansion of flows while HSolver’s method

5 Stefan Ratschan has pointed out in a personal communication that the improvements presented in [17] to HSolver can solve this linear problem. However, these improvements are restricted to linear ODE.

10

8

6

4

2

0
0	2	4	6	8	10

Fig. 3. Enclosure of the bounded reachable set (gray boxes) for a linear ODE, and the black rectangle as initial condition.
is intrinsically restricted to first order integration.
Future works include using higher order Taylor expansions. Although we of course expect drastic improvements, this also raises several issues, like tuning the step size, the space discretization size and the order of the Taylor expansion. Fur- thermore, the R&E algorithm will be extended to hybrid systems. A simple version of the algorithm has been implemented in the software package Ariadne [2].

References
Alefeld, G. and J. Herzberger, “Introduction to Interval Computations,” Computer Science and Applied Mathematics, 1974.
Benvenuti, L., D. Bresolin, A. Casagrande, P. Collins, A. Ferrari, E. Mazzi, A. Sangiovanni-Vincentelli and T. Villa, Reachability computation for hybrid systems with ariadne, in: Proceedings of the 17th IFAC World Congress, 2008.
Collins, P., Continuity and computability of reachable sets, Theor. Comput. Sci. 341 (2005), pp. 162– 195.
Collins, P., Optimal semicomputable approximations to reachable and invariant sets, Theory Comput. Syst. 41 (2007), pp. 33–48.
Goldberg, D., What every computer scientist should know about floating-point arithmetic, Computing Surveys 23 (1991), pp. 5–48.
Goldsztejn, A. and W. Hayes, Reliable Inner Approximation of the Solution Set to Initial Value Problems with Uncertain Initial Value, in: Proceedings of SCAN 2006.
Hayes, B., A Lucid Interval, American Scientist 91 (2003), pp. 484–488.
Jaulin, L., M. Kieffer, O. Didrit and E. Walter, “Applied Interval Analysis with Examples in Parameter and State Estimation, Robust Control and Robotics,” Springer-Verlag, 2001.
Knueppel, O., PROFIL/BIAS - A Fast Interval Library, Computing 53 (1994), pp. 277–287.
Ku¨hn, W., Rigorously Computed Orbits of Dynamical Systems Without the Wrapping Effect, Computing 61 (1998), pp. 47–67.
Kurzhanski, A. B. and P. Varaiya, On ellipsoidal techniques for reachability analysis. I. External approximations, Optim. Methods Softw. 17 (2002), pp. 177–206.


Lohner, R., Enclosing the solutions of ordinary initial and boundary value problems, Computer Arithmetic: Scientific Computation and Programming Languages, Wiley-Teubner Series in Computer Science, Stuttgart (1987), pp. 255–286.
Makino, K. and M. Berz, Suppression of the Wrapping Effect by Taylor Model-based Verified Integrators: Long-term Stabilization by Preconditioning, International Journal of Differential Equations and Applications 10 (2005), pp. 353–384.
Moore, R., “Interval Analysis,” Prentice-Hall, 1966.
Nedialkov, N. S., K. R. Jackson and G. F. Corliss, Validated Solutions of Initial Value Problems for Ordinary Differential Equations, Applied Mathematics and Computation 105 (1999), pp. 21–68.
Neumaier, A., “Interval Methods for Systems of Equations,” Cambridge Univ. Press, 1990.
Ratschan, S. and Z. She, Constraints for continuous reachability in the verification of hybrid systems, in: Proc. 8th Int. Conf. on Artif. Intell. and Symb. Comp., AISC’2006, number 4120 in LNCS (2006),
pp. 196–210.
Ratschan, S. and Z. She, Safety verification of hybrid systems by constraint propagation based abstraction refinement, ACM Transactions in Embedded Computing Systems 6 (2007).
Ratschan, S. and Z. She, Recursive and backward reasoning in the verification on hybrid systems, in:
Proceedings of the 5th Int. Conf. on Informatics in Control, Automation and Robotics, 2008.
Rump, S. M., INTLAB - Interval Laboratory, in: T. Csendes, editor, Developments in Reliable Computing, Kluwer, 1999 p. 77104.
Wolfram Research inc., Mathematica, Champaign, Illinois (2007).
Zgliczynski, P., C1-Lohner Algorithm, Foundations of Computational Mathematics 2 (2002), pp. 429–
465.

A First-Order Interval Integrator
The aim of this section is to describe a very simple first order interval integrator for ODE. We consider an ODE x'(t)= f(x(t)) and a set of initial conditions [x]. The aim of the rigorous integration is to compute a box [y] which contains Φ([h], [x]) for a given interval [h] ≥ 0, that is, which contains all states reached starting in [x] and evolving for a duration h ∈ [h] (note that the interval [h] can be degenerated, i.e h = h). An interval integration is usually performed in two steps. The first consists of computing a crude enclosure of Φ([0, h], [x]). Then this crude enclosure is used to compute a sharper enclosure of Φ([h], [x]). These computations are based on the first order Taylor expansion of the solution of the ODE:
x(h)= x(0) + h f(x(0)) + r,	(A.1)
where the remainder r = (r1 ... , rn) is


ri =
h2
2 (∇fi)(x(ξi)) · f(x(ξi))	(A.2)

with ξi ∈ [0, h] for i ∈ {1,... n}.

Crude Enclosure

In this section, we show how to build a box [xC ] which contains Φ([0, h], [x]). This crude enclosure computation relies on the following idea: Let us first suppose that [xC ] is such an enclosure. Then by (A.1)





[x' ] := [x]+ [0, h] [f ]([x]) +
[0, h]2
2	[Df ]([xC ]) · f ([xC])	(A.3)

is also an enclosure of Φ([0, h], [x]). If the inclusion [x' ] ⊆ [xC ] does hold, then this confirms the hypothesis that [xC] encloses Φ([0, h], [x]). This is due to the Picard operator which can be proved to be contracting because of the inclusion [x' ] ⊆ [xC].
If h is small enough then we expect the fixed point iteration




[xC] ← [x]+ [0, h] [f ]([x]) +


[0, h]2
2	[Df ]([xC ]) · f ([xC ])	(A.4)

to be contracting, its limit satisfying the equality, and hence the wanted inclusion. However, finite precision computations prevent from computing the exact limit and an inflation process has to be interleaved with the fixed point computation (A.4). We obtain Algorithm 4 for the computation of a crude enclosure of Φ([0, h], [x]).
Note that Line 5 simply performs a 1% inflation of the box [x' ]. If Algorithm 4 returns the emptyset then the crude enclosure process has failed. Otherwise, it returns an enclosure of Φ([0, h], [x]).

Algorithm 4 In: f , [h], [x]	Out: [xC]
1: [x' ] ← [x]
2: kmax ← 10
3: k ← 0
4: Repeat
5:	[xC ] ← xˆ' + 1.01([x' ] − xˆ' )	/ xˆ' is the midpoint of [x' ] /

6:	[x' ] ← [x]+ [0, h] [f ]([x]) + [0,h]2 [Df ]([x
]) · f ([x ])

7: While(not([x' ] ⊆ [xC]) ∧ k ≤ kmax)
8: If([x' ] ⊆ [xC]) Return([x' ]) Else Return(∅)
C	C
Sharper Enclosure

Once a crude enclosure [xC] of Φ([0, h], [x]) has been computed using Algorithm 4 a sharper enclosure [y] of Φ([h], [x]) is easily obtained in the following way:
[h]2
[y] = [x]+ [h] [f ]([x]) +	[Df ]([xC ]) · f ([xC]).	(A.5)
2
When the crude enclosure process fails, the normal action is to reduce h and try again. However, this step size reduction is not implemented in the presented experiments. The initial step size was chosen small enough to obtain the success of the crude enclosure process everywhere in the universe.
Extra Proofs
Proof. [Proposition 3.9] Note that Φ([0, h], X0)=  t∈[0,h] Φ(t, X0). Hence,

Reach(f , Φ([0, h], X0)) = Reach(f , 
t∈[0,h]
Φ(t, X0)).	(B.1)

Now, since in general Reach(f , A ∪ B)= Reach(f , A) Reach(f , B),

Reach(f , Φ([0, h], X0)) = 
t∈[0,h]
Reach(f , Φ(t, X0)).	(B.2)



By definition of the reachable set,
Reach(f , Φ([0, h], X0)) =	 
k∈N, t∈[0,h]

f k(Φ(t, X0)).	(B.3)

As Φ is an ODE solution operator, it satisfies Φ(t', Φ(t'', x)) = Φ(t' + t'', x). There- fore

Reach(f , Φ([0, h], X0)) =	 
k∈N, t∈[0,h]
Φ(hk, Φ(t, X0)) =	 
k∈N, t∈[0,h]
Φ(hk + t, X0).
(B.4)

This latter is obviously equal to Reach(Φ, X0).	 
