Electronic Notes in Theoretical Computer Science 123 (2005) 179–193 
www.elsevier.com/locate/entcs


Realizability for Monotone and Clausular (Co)inductive Definitions
Favio E. Miranda-Perea 1 ,2
Institut fu¨r Informatik Ludwig-Maximillians-Universit¨at
Oettingenstr. 67, D-80538 Mu¨nchen, Germany

Abstract
We develop an extension of second order logic (AF2) with monotone, and not only positive, (co)inductive definitions and a clausular feature which simplifies considerably the defining mecha- nism. A sound realizability interpretation, where the extracted programs are untyped, but typable, terms of a strongly normalizing Curry-style system of monotone (co)inductive types makes our logic into a logical framework suitable for programming with proofs.
Keywords: second-order logic AF2, realizability, monotone (co)inductive definitions, system F, monotone (co)inductive types, programming with proofs.


Introduction
During the last decade several authors have studied logical systems of (co)in- ductive definitions and given realizability interpretations with purposes of pro- gram extraction ([9],[11],[10],[12]). We continue this line of research extending second-order logic and focusing on simplicity in the mechanism for defining (co)inductive objects, achieved by the use of clauses, as well as in a deep study of the term system of realizers. For sake of generality we consider monotone, and not only positive, inductive definitions —after all positivity is only used to ensure monotonicity. This choice allows to obtain shorter and simpler proofs

1 This research is being supported by grant 154186 of the CONACYT-DAAD agreement
2 Email: miranda@informatik.uni-muenchen.de



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.04.048


as we do not have to calculate specific monotonicity witnesses, we only require the presence of a proof of monotonicity which might even be only an extra assumption. Moreover the study of full monotonicity shows what is needed to obtain a realizability interpretation where both, source and target logics, are structurally the same, the essential difference being the need of some extra equations involving monotonicity witnesses, namely those expressing the first functor law. Apart from the definition of a logic with clauses and full mo- notonicity the main contribution of this paper is the formulation of a sound realizability interpretation where the realizability of (co)inductive definitions is not reductive, like those in [9] and [10], but again a (co)inductive definition. In section 2 we extend second order logic (AF2) with monotone and clausular (co)inductive predicates and state two important properties of the system, namely subject reduction and strong normalization. The realizability inter- pretation and its soundness theorem are developed in section 3. Related work as well as conclusions and further work are provided in sections 4 and 5.

(Co)inductive Definitions with Tags
We extend second order logic (precisely Krivine’s and Leivant’s AF2 [4]) with (co)inductive predicates. For simplicity we include ∧, ∨ as primitives in AF2. Recall that AF2 works with Leibniz’ equality defined as r = s := ∀X.Xr → Xs. Therefore the derivation relation ▶ depends not only on a context of formulas but also on a given context of equalities , the judgements of the logic are then of the form Γ ▶ r : A. For comprehension predicates we use the notation λyF where F is a formula, the arity of λyF is the length of the vector y and (λyF )t means F [y := t ].
The concept of clause will allow to simplify the way of defining (co)inductive predicates.
Definition 2.1 A clause is a tuple ⟨F , 1,... , m⟩ such that F is a predicate of arity m and i are given function symbols associated to F called tags. The arity of a clause is the arity of its defining predicate F, which is also the number of tags in that clause. Clauses will be denoted with the letters Ci, Dj.
If Ci = ⟨Fi, i ,... , i ⟩ we set ci := i ,... , i , and if t := t1,... , tm, we define
1	m	1	m
cit := i t1,... , i tm.
1	m
Definition 2.2 An expression of the form µX(C1,... , Ck), where Ci := ⟨Fi, ci⟩ and X and all the k clauses have the same arity m, is called an inductive pre- dicate. The arity of an inductive predicate is the arity of the variable X. In this case the tags of a clause are called constructors. Analogously a coinduc-


tive predicate is an expression of the form νX(D1,... , Dk) and we speak of destructors instead of tags.
The predicate µX(C1,... , Ck) represents the least fixed point of the closure operator generated by F1 ∨ ... ∨ Fk via the constructors c1,... , ck. Analo- gously, νX(D1,... , Dk) represents the greatest fixed point of the support (co- closure) operator generated by F1 ∧ ... ∧ Fk via the destructors c1,... , ck. The below inference rules will formalize this intuitive meaning.
The formula F mon X := ∀X∀Y.X ⊆ Y → F ⊆ F[X := Y ] 3 expresses the fact that the predicate F is monotone w.r.t the variable X, we use this full- monotonicity instead of the usual syntactical restriction of positivity following [5]. There are no syntactical restrictions to form a (co)inductive predicate. However there will be some restrictions to eliminate an inductive predicate or to introduce a coinductive predicate, namely we will require some monotoni- city proofs.
The (co)inductive definitions are ruled by:
Folding of the Least Fixed Point: for 1 ≤ j ≤ k


Γ ▶  r : Fj[X := µX(C1,... , Ck)]t
Γ ▶ ink,j r : µX(C1,... , Ck)cjt
(µI)



Iteration:

Γ ▶ r : µX(C1,... , Ck)r
Γ ▶  mi : FimonX, 1 ≤ i ≤ k
Γ ▶ si : Fi[X := K] ⊆ Kci , 1 ≤ i ≤ k
Γ ▶ Itk(m, s, r): Kr





(µE)

where Kci := λy.K(ciy).
Primitive Recursion:


Γ ▶ r : µX.(C1,... , Ck)r
Γ ▶  mi : FimonX, 1 ≤ i ≤ k
Γ ▶  si : Fi[X := µX(C1,... , Ck) ∧ K] ⊆ Kci ,  1 ≤ i ≤ k
Γ ▶ Reck(m, s, r): Kr




(µE+)



3 We set, as usual, F ⊆ G := ∀x.Fx → Gx


Coiteration:


Γ ▶  r : Kt
Γ ▶  mi : FimonX, 1 ≤ i ≤ k
Γ ▶ si : K ⊆ Fi[X := K]ci , 1 ≤ i ≤ k
Γ ▶  CoItk(m, s, r): νX(D1,... , Dk)t
Primitive Corecursion:



(νI)



Γ ▶  r : Kt
Γ ▶  mi : FimonX, 1 ≤ i ≤ k
Γ ▶  si : K ⊆ Fi[X := νX(D1,... , Dk) ∨ K]ci ,  1 ≤ i ≤ k
Γ ▶  CoReck(m, s, r): νX(D1,... , Dk)t
Folding of the Greatest Fixed Point (Inversion):



(νI+)



Γ ▶  ri : Fi[X := νX(D1,... , Dk)])cit,  1 ≤ i ≤ k
Γ ▶ mi : Fi mon X, 1 ≤ i ≤ k
Γ ▶  out−1(m, r): νX(D1,... , Dk)t
Unfolding of the Greatest Fixed Point: for 1 ≤ j ≤ k


(νIi)



Γ ▶  r : νX(D1,... , Dk)t


Γ ▶  outk,j r : Fj[X := νX(D1,... , Dk)]cjt
(νE)

The reader may have noticed that the symmetry between the inductive and coinductive parts is lost because we did not give a rule for unfolding of the least fixed point (inductive inversion), this rule, having a bad reduction behaviour, would produce more problems than benefits, its main application — to define inductive destructors (like the predeccesor in naturals), can be achieved in a satisfactory way with the rule for primitive recursion. In contrast the rule for coinductive inversion has a good reduction behaviour and it is neccesary to obtain coinductive constructors (like the cons function on streams) in an optimal way.
Some examples of (co)inductive predicates in our logic are the natural numbers  := µX ⟨ , 0g⟩, ⟨X, s⟩ , where is the unit predicate, inhabited by only one element, and the constructors 0g,s represent a global zero and the succesor function respectively, analogously LA := µX ⟨ , nilg⟩, ⟨A × X, cons⟩


represents lists of elements of A, where the product predicate is coinductively defined as P×Q := νX ⟨P, π1⟩, ⟨Q, π2⟩ . The p redicate of streams of elements
systems ours allows to define (co)inductive objects in a very simply way due to the clausular feature, as the previous examples let it show.
The proof-reduction for (co)inductive definitions is given by the following
β-reduction rules between proof-terms:
Itk(m, s, ink,i t) '→β si mi λx.Itk(m, s, x) t 
Reck(m, s, ink,i t) '→β si mi ⟨Id, λz.Reck(m, s, z)⟩ t 
outk,i CoItk(m, s, t) '→β	mi λz.CoItk(m, s, z) (sit)
outk,i CoReck(m, s, t) '→β	mi [Id, λz.CoReck(m, s, z)] (sit)
outk,i out−1(m, t) '→β	mi(λz.z)ti
where ⟨·, ·⟩, [·, ·] denote the usual pair and copair of functions respectively. These rules are obtained, as usual, by normalizing proofs which contain con- secutive ocurrences of an introduction and elimination rule for the same for- mula constructor. They also have a categorical interpretation which cannot be discussed here due to lack of space. If we consider in detail the rule for ite- ration, for example, we observe that the function f := λx.Itk(m, s, x), which is the function being defined by iteration, when applied to the argument ink,i t, reduces to a term with access to the entire f . However, we get strong nor- malization because the typing of m controls the access to f —an instance of type-based termination. The described logical system will be called MCICD, a system of Monotone and Clausular Inductive and Coinductive Definitions.

Properties of MCICD
Our logic possess two important properties, namely subject-reduction (type preservation) and strong normalization. The type preservation: If Γ ▶ r : A and r →β s then Γ ▶ s : A, being MCICD a system in Curry-style, is not trivial and can be proven, for example, adapting Krivine’s method for AF2 (see [4]). To prove the strong normalization of MCICD we embed it into a type sys- tem via a first-order forgetful map (and using +, × instead of ∨, ∧, as usual). The resulting system will be called MCICT and it is an extension of system F with (co)inductive types of the form µα(ρ1,... , ρk), να(ρ1,... , ρk). A re- lated system with only positive (co)inductive types of this shape and without polymorphism was developed in [2]. The above examples of (co)inductive predicates become (co)inductive types, for example, nat := µα(1, α), list(ρ) :=


µα(1,ρ × α), stream(ρ) := να(ρ, α). The strong normalization of MCICT is proved by embedding it into a system without clauses, like those of [6], so that the coinductive type να(ρ1,... , ρk) embeds into the type να.ρ1 × ... × ρk and the inductive type µα(ρ1,... , ρk) is mapped to µα.ρ1 + ... + ρk. The strong normalization of this final system is proved directly via saturated sets.

Realizability
Realizability is a powerful mathematical tool to synthetize programs from, usually constructive, proofs. If a logical system is based on contructive logic and has a sound realizability interpretation we can extract a program and its verification proof effectively from a proof of the specification of the program using such interpretation.
We give a realizability interpretation of MCICD-formulas into the system MCICD٨, which is MCICD over the term system MCICT and extended with first order existential formulas and restricted formulas.
The Logic MCICD٨
MCICD٨ is an extension of MCICD defined as follows: we add first-order exis- tential and restricted formulas (defined below), we extend the term system to MCICT. Finally, tags in clauses can be either function symbols (considered as constants added to MCICT) or closed terms of MCICT. Subject reduction and strong normalization hold also for this extended system.
Existential Formulas
Existential formulas are ruled by:


Γ ▶ t : A[x := s] Γ ▶ pack t : ∃xA
(∃I)
Γ ▶  t : ∃xA  Γ,z : A[x := u] ▶  r : B


Γ ▶ open(t, z.r): B
(∃E)

where in the (∃E) rule, u ∈/ FV (Γ, B, ∃xA). Proof reduction is given by the following β-reduction rule: open(pack t, z.r) '→β r[z := t]
The rules for existential formulas are given only in partial Curry-style, due to the fact that the rules in full Curry-style (non-traceable rules) would cause the subject reduction property to fail.
Restricted Formulas
We will also need Parigot’s restriction to be able to formulate realizability for disjunctions. Expressions of the form AT s1 = t1,... , sk = tk are called restricted formulas. A restricted formula represents a conjunction A ∧ s1 =


t1 ∧ ... ∧ sk = tk where the equations do not have computational content, i.e. are not traced by the proof-term system.
Restriction behaves according to the following rules, where we abbreviate a sequence of equations as s = t. : 
Γ ▶ r : A	Γ ▶ s = t

Γ ▶  r : AT s = t
Γ ▶  r : AT s = t
Γ ▶ r : A
(T I)

(T E)

The notation Γ ▶ s = t means a derivation obtained within MCICD٨ and possibly using the following rule:
Γ ▶ r : AT s = t

Γ ▶ si
= ti
(T ER)

We have a basic context of equalities β := {t = r | t →β r or r →β t}, which represents β-equality but only for one-step reduction. Unless stated otherwise, while working in MCICD٨, we will write ▶ for ▶ .
The Realizability Interpretation
To define realizability we will use the following notation: given a n-ary predi-
cate variable X, we denote with X+ a (n + 1)-ary predicate variable uniquely associated with X. We also set:	k := λx. ink,i x and	k := λx. outk,i x
i	i
Definition 3.1 Given an MCICT-term t and an MCICD−formula A we define the MCICD٨−formula t r A as follows:
t r Xs := X+st
t r A → B := ∀z.z r A → tz r B t r ∀xA := ∀x.t r A
t r ∀XA := ∀X+.t r A
t r A ∧ B := (π1t r A) ∧ (π2t r B)
t r A ∨ B := ∃z.(z r AT t = inl z) ∨ (z r BT t = inr z) t r µX(C1,... , Ck)s := µX+(Cr,... , Cr)s t
1	k
t r νX(D1,... , Dk)s := νX+(Dr,... , Dr)s t
1	k
where for an n-ary predicate F we define the (n + 1)-ary predicate Fr :=
λy, z.z r F y with z ∈/ y ∪ FV (F ), and if Ci := ⟨Fi, ci⟩, Di := ⟨Gi, di⟩ then

Cr := ⟨Fr, ci,  k⟩, Dr := ⟨Gr, di,  k⟩.
i	i	i	i	i	i
Observe that the last tag in the clauses Cr, Dr is a closed term, existential
i	i
and restricted formulas are only needed to define realizability for disjunctions
and that the realizability for a (co)inductive predicate is (co)inductively de- fined.
The essential difference with the more usual modified realizability inter- pretation is the case for first order universal formulas, in our case the realizer does not behave as a function, so that universal formulas do not have com- putational content. In the formula t r ∀xA the term t can be thinked of as a “potential” realizer of the formula ∀xA. In the cases of interest, involving some formal datatype, the actual realizer t will behave as a function. This choice of definition simplifies proofs, in particular it allows for the canonical iterator (recursor) to be the realizer of the induction (extended induction) axiom (see prop. 3.6).
Lemma 3.2 (Substitution Properties) The following properties hold:
(t r A)[x := s] ≡ t[x := s] r A[x := s].
(t r A)[X+ := Fr] ≡ t r A[X := F].
Proof. Induction on A.	 

Realizing the Axioms
The rules for (co)inductive predicates generate the following axioms.
Definition 3.3 Given an inductive predicate µX(C1,... , Ck) we define the closure, induction and strong induction axioms for µX(C1,... , Ck) as follows 4 :

ClµX(C ,...,C ),i := Fi[X := µX(C1,... , Ck)] ⊆ (µX(C1,... , Ck))ci
IndµX(C ,...,C ) := ∀Z. F mon X, F1[X := Z] ⊆ Zc1 ,... , Fk[X := Z] ⊆ Zck
→ µX(C1,... , Ck) ⊆ Z

+
µX(C1,...,Ck)
:= ∀Z. F mon X, F1[X := µX(C1,... , Ck) ∧ Z] ⊆ Zc1 ,... ,
Fk[X := µX(C1,... , Ck) ∧ Z] ⊆ Zck → µX(C1,... , Ck) ⊆ Z


Analogously, given a coinductive predicate νX(D1,... , Dk) we define its

4 A1,..., Ak →	B means A1	→	...	→	Ak →	B  and  F mon X  denotes
F1 mon X,... , Fk mon X


coclosure, coinduction and inversion axioms as follows:
CoClνX(D ,...,D ),i := νX(D1,... , Dk) ⊆ (Fi[X := νX(D1,... , Dk)])ci
CoIndνX(D ,...,D ) := ∀Z. F mon X, Z ⊆ F1[X := Z]c1 ,... ,Z ⊆ Fk[X := Z]ck
→ Z ⊆ νX(D1,... , Dk)

+
νX(D1,...,Dk)
:= ∀Z. F mon X, Z ⊆ F1[X := νX(D1,... , Dk) ∨ Z]c1 ,... ,

Z ⊆ Fk[X := νX(D1,... , Dk) ∨ Z]ck → Z ⊆ νX(D1,... , Dk)
InvνX(D1 ,...,Dk) := ∀z. F mon X, F1[X := νX(D1,... , Dk)]c1z,... ,
Fk[X := νX(D1,... , Dk)]ckz → νX(D1,... , Dk)z

The usual (co)induction axioms for each predicate can be derived from these general ones, for example from Ind+ as the monotonicity assumptions are trivially derivable in this case, we can derive the extended induction axiom:
∀Z.Z0, (∀x. x∧Zx → Zsx) →  ⊆ Z, where 0 is defined as the global zero 0g, applied to the unique inhabitant of the unit predicate *, i.e., 0 := 0g*. In the rest of this section we look for realizers for the (co)closure and (co)induction axioms which will be needed in the proof of the soundness theorem.
Proposition 3.4 Given an inductive predicate µX(C1,... , Ck) we have:
▶ λx. ink,j x :	k r ClµX(C ,...,C ),j
j	1	k
Proof. Using lemma 3.2, part (ii), we get that k r ClµX(C ,...,C ),j is equivalent
j	1	k
to ClµX+(Cr,...,Cr ),j. The proof is now obvious.	 
1	k
Proposition 3.5 Given a coinductive predicate νX(D1,... , Dk) we have:
▶ λx. outk,j x :	k r CoClνX(D ,...,D ),j
j	1	k
Proof. Analogous to proposition 3.4.	 

Proposition 3.6 If Θ ▶ mi : Fr mon X+ for 1 ≤ i ≤ k then
Θ ▶ λx.λy.λz.Itk(m, s, z):	r IndµX(C1 ,...,Ck )
Θ ▶ λx.λy.λz.Reck(m, s, z):	r Ind+
where	:= λxλyλz.Itk(x, y, z),	:= λxλyλz.Reck(x, y, z) and for 1 ≤ i ≤ k,
si := λui.yi(xi(λv.v)ui)
Proof. We prove part (ii). Set Ci = ⟨Fi, ci⟩, µ := µX(C1,... , Ck) and µr :=

µX+(Cr,... , Cr). Our goal is to prove Θ ▶	r Ind+
, which unfolds

1	k	µX(C1 ,...,Ck)



to
∀Z+.∀m. ..., mi r Fi mon X,.. .(1≤i≤k) →
∀f. ... , fi r Fi[X := µ ∧ Z] ⊆ Zci ,.. .(1≤i≤k) →
mf r µX(C1,... , Ck) ⊆ Z
Assume for 1 ≤ i ≤ k


(1)

xi : mi r Fi mon X	(2)
and yi : fi r Fi[X := µ ∧ Z] ⊆ Zci , that is
yi : ∀v.∀u.u r Fi[X := µ ∧ Z]v → fiu r Z(civ).	(3) We need to show	mf r µX(C1,... , Ck) ⊆ Z, i.e.
∀v.∀w.w r (µX(C1,... , Ck))v →  mfw r Zv
Assume now z : w r (µX(C1,... , Ck))v ≡ (µX+(Cr,... , Cr))vw, and de-
1	k
fine Q := λx, z.  mfz r Zx. Set
Γ := Θ, xi : mi r Fi mon X, yi : fi r Fi[X := µ ∧ Z] ⊆ Zci , z : (µX+(Cr,... , Cr))vw
1	k
where 1 ≤ i ≤ k. We need to prove Γ ▶ Qvw.
Obviously Γ ▶ mi : Fr mon X+ and Γ ▶ z : (µX+(Cr,... , Cr))vw. There-
i	1	k
fore using the elimination rule (µE+) it suffices to show
Γ ▶ Fr[X+ := µr ∧ Q] ⊆ Qci , k , (1 ≤ i ≤ k)
i


that is

∀x.∀z.Fr[X+ := µr ∧ Q]xz → Q(cix)( kz).

i	i
Assume
ui : Fr[X+ := µr ∧ Q]xz  (1 ≤ i ≤ k)	(4)
and set Π := Γ, ui : Fr[X+ := µr ∧ Q]xz. We need to prove
Π ▶ Q(cix)( kz)  (1 ≤ i ≤ k)	(5)
The assumptions (2) unfold to:


xi : ∀X+∀Y +∀z. (∀y ∀w.w r Xy → zw r Y y) →
(∀y ∀u.u r Fiy → mizu r Fi[X := Y ]y)
(6)


Next we instantiate the predicate variables X + := µr ∧ Q,Y + := (µ ∧ Z)r to obtain:
xi : ∀z.(∀y∀w.(µr ∧ Q)yw → (µ ∧ Z)ry(zw)) →
(∀y∀u.Fr[X+ := µr ∧ Q]yu → mizu r Fi[X := µ ∧ Z]y)
Instantiate now z := λx.⟨x,  mfx⟩, getting
xi : (∀y∀w.(µr ∧ Q)yw → (µ ∧ Z)ry((λx.⟨x,  mfx⟩)w)) →
(∀y∀u.Fr[X+ := µr ∧ Q]yu → mi(λx.⟨x,  mfx⟩)u r Fi[X := µ ∧ Z]y)
Observing that (F ∧ G)r ≡ λz, u.Frz(π1u) ∧ Grz(π2u) and
β ▶ π1 (λx.⟨x, π2mfx⟩)w  = w
β ▶ π2 (λx.⟨x, π2mfx⟩)w  = π2mfw
using the rule for Leibniz’ Equality (Eq) it is easy to see that
▶ λv.v : ∀y∀w.(µr ∧ Q)yw → (µ ∧ Z)ry((λx.⟨x,  mfx⟩)w).
Therefore we can eliminate the implication and obtain
Π ▶ xi(λv.v): ∀y∀u.Fr[X+ := µr ∧ Q]yu →
mi(λx.⟨x,  mfx⟩)u r Fi[X := µ ∧ Z]y.

From this, instantiating y,u := x,z and using assumption (4) we get Π ▶ xi(λv.v)ui : mi(λx.⟨x,  mfx⟩)z r Fi[X := µ ∧ Z]x.
On the other hand, from assumptions (3), with v,u := x, mi(λx.⟨x,  mfx⟩)z
we get:
Π ▶ yi : mi(λx.⟨x,  mfx⟩)z r Fi[X := µ∧Z]x → fi(mi(λx.⟨x,  mfx⟩)z) r Z(cix).
Therefore Π ▶ yi(xi(λv.v)ui): fi mi(λx.⟨x,  mfx⟩) z  r Z(cix).
But it is easy to see that	β ▶ fi mi(λx.⟨x, mfx⟩)z =	mf ( kz), hence using (Eq) we get:
Π ▶ yi(xi(λv.v)ui):  mf ( kz) r Z(cix),


That is Π ▶ yi(xi(λv.v)ui): Q(cix)( kz) and the goal (5) is proved. Therefore Γ ▶ λu .y (x (λv.v)u ) : Fr[X+ := µr ∧ Q] ⊆ Qci , k , which by

(µE+) yields:
i  i	i	i	i	i

Γ ▶ Reck(m, s, z): Qvw
Finally, discharging the assumptions x, y, z, we get formula (1), which coincides with:
Θ ▶MCICDs λx.λy.λz.Reck(m, s, z):	r IndµX(C ,...,C )
1	k


Analogously we can get the realizability of the coinduction axioms:
Proposition 3.7 If Θ ▶ mi : Fr mon X+ for 1 ≤ i ≤ k, then
Θ ▶ λxλyλz.CoItk(m, s, pack z):	r CoIndνX(D1 ,...,Dk)
Θ ▶ λxλyλz.CoReck(m, q, pack z):	r CoInd+
Θ ▶ λxλy.out−1(m, r ):  r InvνX(D ,...,D )
k	1	k
with	:= λxλyλz.CoItk(x, y, z),	:= λxλyλz.CoReck(x, y, z),  := λxλy.
out−1(x, y ) and for 1 ≤ i ≤ k, we set:
si := λv. open(v, w.xi(λu. pack u)(yiw)),
qi := λv. open  v, w.xi λu. open u, v.case(v, v1.inl v1, v2.inr pack v2)  (yiw) 
ri := xi(λzz)yi.

Observe that the proof-terms are quite complicated due to the absence of existential rules in full Curry-style.
The additional requirements Fr mon X+ in propositions 3.6 and 3.7 are somehow unpleasant, we would like to obtain them from the fact that Fi mon X is realizable, fact which will be available from some induction hypothesis. Unfortunately this is not true in general but we have the following result,
Proposition 3.8 If  Θ ▶MCICDs m^ : m r F mon X and	▶ m(λxx) = λxx
r	+
(i.e. the ﬁrst functor law holds for m) then Θ ▶MCICDs,  m^ : F mon X  .
Proof. Instantiate z := λx.x in m r F mon X (cf. formula (6), page 10) and use some equational reasoning.	 
This proposition allows to obtain a soundness theorem where both source and target logical systems only differ on the underlying object-term system and on the equational theory given by the equations on the above proposition,


which express the first functor law for m. This is an important difference with the treatment in [11].

The Soundness Theorem
We come to the main result of this paper, a soundness theorem for our realiza- bility interpretation, which guarantees the correctness of program extraction. Important feature of this result is the fact that the extracted program coin- cides with the code of the original proof of the specification A.
Definition 3.9 Given a proof-term t, and a subterm m such that m occurs in m for some subterm of t of one of these forms: Itk(m, s, r), Reck(m, s, r), CoItk(m, s, r), CoReck(m, s, r), out−1(m, s ), we say that m is an on-display monotonicity witness of t. The set of all on-display monotonicity witnesses of t will be denoted by W(t).
Definition 3.10 Given a derivation Γ ▶ s : A we define	(s) := {m(λzz)= λzz | m ∈ W(s)} and ٨(s) :=	∪	(s) The equations in		(s) represent the first functor law for every on-display monotonicity witness m occurring in s.
The equations in	٨(s) allow to derive all needed formulas of the form
Fr mon X+ required by propositions 3.6 and 3.7.
Given a context Γ = {x1 : A1,... , xk : Ak} we set Γr := {x1 : x1 r A1,... , xk : xk r Ak}, where w.l.o.g. xi ∈/ FV (Ai). It is important to remark that we make no syntactic distinction between object and proof-term variables.
Theorem 3.11 (Soundness of Realizability for MCICD) If Γ ▶MCICD, s :
A then Γr ▶MCICDs, s(s) s˜ : s r A
Proof. Induction on ▶MCICD, . Lemma 3.2 as well as subject reduction of the system will be needed. The cases (µI), (µE), (µE+), (νE), (νI), (νI+), (νIi) are solved using the propositions 3.4,3.6,3.5,3.7, respectively.	 
The proof-term s is in all cases but the disjunctions and (co)inductive predicates, homomorphic to s and can be automatically obtained from it.

Related Work
Logical systems handling only inductive definitions are presented in [9,11,7]. The system of [10], based on that of [9], is an extension of AF2 with positive (co)inductive definitions but does not include primitive recursion and uses a fixed point operator within the proof-term system, which is therefore not


strongly normalizing. An extension of Beeson’s EON with monotone induc- tive definitions and only iteration is presented in [11], there is no treatment of proof-terms and only partial terms of combinatory logic are used in a q- realizability interpretation which needs a fixed point operator to realize the induction axiom. In [7] I present an extension of AF2 with monotone inductive definitions without clauses and only iteration and give a realizability interpre- tation into AF2, i.e. where the case for inductive predicates is reductive. [12] presents several strongly normalizing extensions of first order intuitionistic logic with positive (co)inductive definitions.
The type system MCICT of realizers is essentially a polymorphic and mono- tone version of the system developed in [2], which also uses clauses, but we include primitive (co)recursion and use a natural deduction approach, follow- ing [5] very closely. The use of clauses in the logic is already present in [1], this paper also inspires our definition of realizability for the case of inductive predicates, but we do not use modified realizability.

Conclusions and Further Work
The logical system MCICD together with its realizability interpretation are a logical framework suitable for extract typable programs from specifications including monotone (co)inductive definitions. These definitions are given by clauses, a concept which simplifies the defining formulas. The extracted pro- grams are guaranteed to terminate because they belong to a strongly normali- zing term rewrite system. To my knowledge this is the first realizability inter- pretation for full monotone (co)inductive definitions (including (co)recursion) where the system of realizers is strongly normalizing.
Although all usual examples of (co)inductive predicates are positive, the use of full monotonicity simplifies the proofs and allows for a direct extension to higher-order logic (corresponding to the type system Fω) where a concept of positivity is not well determined. On the other hand we have defined a tarskian semantics for MCICD and extended the programming with proofs paradigm of [3,9], which allows to program functions defined by equations on formal datatypes (like the examples in page 4) without having to calculate realizers (see [8]).

Acknowledgement
I wish to thank Ralph Matthes for several fruitful discussions. The Graduier- tenkolleg Logik in der Informatik of the Deutsche Forschungsgemeinschaft pro- vided the travelling funds to Fontainebleau.

References
Berger Ulrich. A constructive interpretation of positive inductive deﬁnitions. Unpublished Draft. 1995.
Hagino T. A Typed Lambda Calculus with Categorical Type Constructors, “Category Theory and Computer Science” edited by Pitt D.H, A. Poign´e, D.E. Rydeheard. LNCS 283. Springer 1987.
Krivine J.L, M. Parigot. Programming with Proofs. Journal of Information Processing and Cybernetics EIK 26(3) (1990) pp. 149-167.
Krivine J.L. “Lambda-Calculus, Types and Models”. Ellis Horwood Series in Computers and their Applications. Ellis Horwood, Masson 1993.
Matthes Ralph. “Extensions of System F by Iteration and Primitive Recursion on Monotone Inductive Types”. Dissertation Universit¨at Mu¨nchen, 1999.
Matthes Ralph. Monotone (co)inductive types and positive ﬁxed-point types. Theoretical Informatics and Applications 33(4-5) (1999) pp. 309-328. EDP Sciences.
Miranda-Perea Favio E. A Curry-Style Realizability Interpretation for Monotone Inductive Deﬁnitions. Proc. 7th. ESSLLI Student Session (2002) edited by Nissim M. Available from the web site: http://www.iccs.informatics.ed.ac.uk/~malvi/esslli02/index.html

Miranda-Perea Favio E. A Logic for Monotone and Clausular (Co)inductive Deﬁnitions. Unpublished Draft. 2004 (Available upon request).
Parigot M. Recursive programming with proofs. Theoretical Computer Science 94 (1992) pp.335-356.
Raffalli C. “L’ Arithm´etique Fonctionnelle du Second Ordre avec Points Fixes”. Th`ese de l’Universit´e Paris VII. 1994.
Tatsuta M. Two Realizability Interpretations of Monotone Inductive Deﬁnitions. International Journal of Foundations of Computer Science 5(1) (1994) pp. 1-21.
Uustalu T. “Natural deduction for intuitionistic least and greatest fixedpoint logics, with an application to program construction”. Dissertation TRITA-IT AVH 98:03, Dept. of Teleinformatics, Royal Inst of Technology (KTH), Stockholm, 1998.
