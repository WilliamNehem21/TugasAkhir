Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 312 (2015) 125–141
www.elsevier.com/locate/entcs

A Calculus for Automatic Verification of Petri Nets Based on Resolution and Dynamic Logics 1
Claudia Nalon2
Departament of Computer Science University of Bras´ılia
Bruno Lopes3
Departamento de Inform´atica Pontif´ıcia Universidade Cat´olica do Rio de Janeiro
Gilles Dowek4
Deducteam
Institut National de Recherche en Informatique et en Automatique
Edward Hermann Haeusler5
Departamento de Inform´atica Pontif´ıcia Universidade Cat´olica do Rio de Janeiro

Abstract
Petri Nets are a widely used formalism to deal with concurrent systems. Dynamic Logics (DL) are a family of modal logics where each modality corresponds to a program. This works presents a resolution-based method for Petri-PDL, a DL where programs are replaced by Petri Nets. We present a procedure to convert any Petri-PDL formula into a normal form, a set of resolution-based inference rules, examples of application of the method, and discuss soundness and completeness.
Keywords: Dynamic logic, Petri Nets, Resolution, Deductive systems


1 This work was partially supported by the Brazilian research agencies CNPq, CAPES and FAPERJ.
2 Email: nalon@unb.br
3 Email: bvieira@inf.puc-rio.br
4 Email: gilles.dowek@inria.fr
5 Email: hermann@inf.puc-rio.br

http://dx.doi.org/10.1016/j.entcs.2015.04.008
1571-0661/© 2015 The Authors. Published by Elsevier B.V.
This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).

Introduction
Concurrency and synchronisation play an important role in computer science, spe- cially concerning distributed and asynchronous environments, which reflect usual situations in network-based systems. Modelling and verifying if the requirements are satisfied in these systems takes a lot of effort and are always a challenge. Among the most used formalisms to solve these problems, Petri Nets stands in a special place [2,4,19]. They present a theoretical background that support these characteristics and present an intuitive graphical representation. Quoting James L. Peterson [15]
“[. . . ] when synchronization is necessary, for instance when both a job and an idle processor must be available for processing to start, the situation is also easily modelled. Thus a Petri net would seem to be ideal for modelling systems of distributed control with multiple processes occurring concurrently.”
Dynamic Logics, in general, are modal logic systems where each program is a modality. These logics are used to deal with the verification of properties in programs and Propositional Dynamic Logic (PDL) [6] is one of its most well-known variants, dealing only with regular programs (regular in the sense that they are specified similar to regular expressions). In PDL each program P corresponds to a modality ⟨P⟩ where a formula ⟨P⟩ϕ means that after the running of P , ϕ is possibly true, considering that P stops. There is also the possibility of using [P ]ϕ (as an abbreviation for ¬⟨P⟩¬ϕ) indicating that the property denoted by ϕ holds after every possible running of P . Several systems and tools have been proposed to deal with problems expressed in Dynamic Logics, including tools for automatic verification of programs [7,8,9].
Petri-PDL [11] is a dynamic logic derived from PDL where each modality is a Marked Petri Net. If π is a Petri Net with markup s, then a Petri-PDL formula
⟨s, π⟩ϕ means that after the running of π with the initial markup s, ϕ will possibly be true (the 2-like modality, given by [s, π], is also possible, where [s, π]ϕ is an abbreviation for ¬⟨s, π⟩¬ϕ). In order to simplify the approach, the language of Petri-PDL refers to a subclass of Petri Nets, where each Petri Net is a composition of basic Petri Nets built from only three kinds of transitions. However, this restriction in the language does not reflect on the class of problems that can be expressed in Petri-PDL: as shown in [1], the combination of those three types of transitions is enough to represent any possible Marked Petri Net.
The axiomatisation of Petri-PDL is sound and complete, and the satisfiability problem is decidable [11]. Other systems have been proposed in the literature to reason about the properties and behaviour of Petri Nets, but they lack some of these properties, as, for instance, the Trace Theory [12,13], which is incomplete and undecidable. Other systems may retain those properties, but reasoning can only be carried out after the translation of Petri Nets into the target language, as, for instance, in [18], where PDL is used as a query language for properties of Petri Nets. By embedding Petri Nets as part of the language, Petri-PDL provides a natural way of specifying complex systems and the properties to be verified. Also, the provision of such abstractions at the (logical) specification level comes at no extra cost: the

complexity of the satisfiability problem for Petri-PDL is the same as the complexity of the satisfiability problem for PDL, that is, EXPTIME-complete [11].
In this paper, as a first step towards the automation of proofs for Petri-PDL, we present a resolution-based calculus to deal with the (un)satisfiability problem in Petri-PDL. The method is clausal: a formula to be proved unsatisfiable is trans- lated into a normal form, which separates the different contexts to which a set of resolution-based inference rules are applied. Correctness results are briefly discussed and some examples are provided.
The paper is structured as follows. In the next section, we explain the basics of Marked Petri Nets. In Section 3, we introduce the syntax, semantics, and the ax- iomatisation of Petri-PDL. The resolution-based method for Petri-PDL is presented in Section 4: the transformation into the normal form, the inference rules, the main results, and a few examples are given. Conclusions and future work are given in Section 5.
Petri Nets
A Petri Net [16] is a 3-tuple ⟨P, T, W⟩, where P is a finite set of places, T is a finite set of transitions with P ∩T = ∅ and P ∪T /= ∅ and W is a partial weighting function which associates directed edges between places and transitions to a multiplicative weight, that is, W : (P × T ) ∪ (T × P ) →  . In this work we assume w =1 for all edges.
Petri Nets can be extended to represent the flow of resources from one place to another. Tokens denote the amount of a resource available in a place. A Marked Petri Net is a 4-tuple π = ⟨P, T, W, M0⟩, where P , T and W are defined as above. M0 is an initial distribution of tokens over the places, that is, it is formally defined as M0 : P →  . In the following, when referring to a Petri Net we mean a Marked Petri Net.
We define the preset of t ∈ T , denoted by •t, as the set of all si ∈ P that origins an edge to t. The postset of t, denoted by t• is defined as the set of all sj ∈ P that t origins an edge to. We say that a transition t is enabled if, and only if, there is at least one token in each place s ∈ •t.
From M0 we can define the behaviour of a Marked Petri Net π by the flow of tokens (i.e. a list of markups). The function Mi (i.e. the distribution of tokens over π after i firings) over enabled transitions t is defined as:
⎧	•	•
Mi+1(x)= ⎪⎨ Mi(x)+ 1, ∀x ∈ t• \ •t .	(1)
⎪⎪⎩ Mi(x),	other case
In the following, if π = ⟨P, T, W, M0⟩ and πj = ⟨P j,Tj,Wj,Mj ⟩ are Petri Nets, with Pj ⊆ P , T j ⊆ T , where for all t ∈ T exists tj ∈ T j such that •tj = •t, Wj ⊆ W , and Mj ⊆ M0, we say that πj is a subnet of π, denoted by πj ⊆ π. The concept of subnet corresponds to that of graph inclusion with the appropriate restrictions on

the relation W and on the function M0.
We define Petri Nets as in the work of Almeida & Haeusler [1], where it has been shown that every valid Petri Net can be represented by the composition of only three basic Petri Nets. As shown in Fig. 1, in a basic Petri Net of Type 1, a transition connects two places; in a basic Petri Net of Type 2, two places are connected by a transition to one place; and in a basic Petri Net of Type 3, one place is connected by a transition to two places, where places are represented by circles, tokens are represented by black circles within a place, and transitions are represented by boxes.

X

Z	X
X	Y


Type 1: t1
Y
Type 2: t2
Z
Type 3: t3

Fig. 1. Basic Petri Nets

As an example, the Petri Net on Fig. 2(a) represents the operation of an elevator for a building with five floors. There are two places, U (the elevator can go up) and D (the elevator can go down), and tokens within those places say how many floors the elevator can travel in the specified direction. For instance, one token in the place U indicates that the elevator is able to go up one floor. If t1 fires, a token goes from U to D, representing that the elevator can go down one floor. If the elevator goes down one floor (i.e. t2 fires) a token goes from D to the place U . Figure 2(a) illustrates the Petri Net with its initial markup, that is, the elevator is on the ground floor and can go up to the highest floor. Note that this Petri net is a composition of the two Petri Nets of Figures 2(b) and 2(c), where places have the same names given in Figure 2(a).

U	U	U
t2	t1	t2 	t1


D
Petri Net for an elevator
D
To go up
D
To go down

Fig. 2. Petri Nets of an elevator and basics for composition


Petri-PDL Language and Semantics
The language of Petri-PDL [11] is constructed from a denumerable set of propo- sitional symbols Φ = {p, q, . . .}, a set of place names P = {a, b, c, d, . . .}, a set of

transition names T = {t1, t2, t3,.. .}, the classical operators for negation (¬) and conjunction (∧), and a set of modal operators, ⟨s, π⟩, where s is a sequence of names (i.e. s ∈ P٨ is a sequence representing the marking on a Petri Net, where ϵ ∈ P٨ is the empty sequence), and π is a Petri Net program, defined as follows. Firstly, each transition name is associated with an unique type, either T1, T2, or T3. We write Ti : t, for t ∈ T , to denote that the transition t has type Ti, i ∈ {1, 2, 3}. In the following, we will often identify a transition name ti with a type Ti, that is, we have that Ti : ti. A basic Petri Net program πb has one of the syntactical forms given by the following BNF:


πb ::= at1b | at2bc | abt3c


where ti are transition names of type Ti and a, b, c ∈ P. A Petri Net program π is built from basic Petri Net programs as given by the following BNF:


π ::= πb | π ⊙ π


where πb is a basic Petri Net program and ⊙ is the composition operator. The set of well-formed formulae of Petri-PDL can now be defined as follows:


ϕ ::= p |T| ¬ϕ | ϕ ∧ ϕ | ⟨s, π⟩ϕ


where p ∈ Φ, T is a nullary connective, ϕ is a formula, s ∈ P٨, and π is a Petri Net program. We use the standard abbreviations for the nullary connective ⊥ (⊥ ≡ ¬T), disjunction (ϕ ∨ ψ ≡ ¬(¬ϕ ∧ ¬ψ)), implication (ϕ → ψ ≡ ¬(ϕ ∧ ¬ψ)), and the box-like modality ([s, π]ϕ ≡ ¬⟨s, π⟩¬ϕ).
The semantics of Petri-PDL is given in terms of a Kripke structure, as usual in modal logics. First, we define the firing function. Let s and sj be sequences of place names. We use the notation s ≺ sj to denote that all names occurring in s also occur in sj, regardless of order.


Definition 3.1 We define the ﬁring function f : P٨ × Π → P٨ as follows, where a, b, c ∈ P, Ti : ti ∈T , for i = 1, 2, 3, s, s1, s2, s3 ∈ P٨, Π is a set of basic Petri Net programs, and π ∈ Π:

f (s, at b) = ⎧⎨ s1bs2 if s = s1as2 and a /< s1
⎩	ϵ if a /< s

f (s, abt c) = ⎧⎨ s1cs2s3 if s = s1as2bs3,a /< s1, and b /< s2
⎩	ϵ if a /< s or b /< s

f (s, at bc) = ⎧⎨ s1s2bc if s = s1as2 and a /< s1
⎩	ϵ if a /< s


f (ϵ, π) = ϵ, for all basic Petri Net programs π
Note that, because order of places in a sequence are not regarded, in the case of a transition of type T2, f (s, abt2c) also applies if s = s2bs1as3, b /< s2 and a /< s1. The firing function is only defined for basic Petri Net programs. The behaviour of the whole Petri Net can be determined by the interleaving of the application of this function to its components (see axiom PC below).
Given a Petri Net π = ⟨P j,Tj, W, M0⟩, where Pj ⊆ P, T j ⊆ f , W and M0 are defined as before, we define a Kripke model for π as follows.
Definition 3.2 A Petri-PDL model for π = ⟨P j,Tj, W, M0⟩ is a tuple ⟨S, s0, Rπ, L, V ⟩, where S is a non-empty set of states; s0 ∈ S is the initial state; L : S → P٨ is a labelling function which associates each state with a sequence of place names, Rπ is a binary relation over S, and V : Φ → 2S is a valuation function. The relation Rπ is inductively defined where Rπb ⊆ S × S.
f (L(w), π) /= ϵ iff wRπb v ◦ vRπu for all πb c π
if f (L(w), π)= ϵ, wRπv iff w = v
Let {π1,..., πn} be all the basic Petri Net programs in π. The relation Rπ is defined as {(w, v) | for some πi there exists u such that f (L(w), πi) < L(u), wRπi u and uRπv} for all 1 ≤ i ≤ n.
The relation Rπ over S denotes the flow of a Petri Net, according to equation (1), where s0 is the state that corresponds to the initial markup, M0. The markup of a Petri-PDL program that corresponds to π in each state can be retrieved by L.
Definition 3.3 Let M = ⟨S, s0, Rπ, L,V ⟩ be a Petri-PDL model for π. The satis- faction of a formula in M at a state w, denoted by M,w H ϕ, can be inductively defined as follows (where ϕ, ϕ1, ϕ2 are formulae, s is a sequence of names, πb, ηi are basic Petri Net programs, and η = η1 ⊙... ⊙ηn, n ∈  , is a Petri Net program):
M,w H p iff w ∈ V(p);

M,w H T;
M,w H ¬ϕ iff M,w /H ϕ;
M,w H ϕ1 ∧ ϕ2 iff M,w H ϕ1 and M,w H ϕ2;
M,w H ⟨s, η⟩ϕ if there exists v ∈ S, wRηv, s < L(w) and M,v H ϕ.
Note that, from Definitions 3.3 and 3.2, a modality labelled by a basic Petri Net program is satisfied if the respective transition is ﬁred with the markup s. That is, if πb is of the form at1b, ⟨s, πb⟩ϕ is satisfied at a state w ∈ S iff there exists v ∈ S, wRat1bv, a < s and M,v H ϕ; if πb is of the form abt2c, ⟨s, πb⟩ϕ is satisfied at w iff there exists v ∈ S, wRabt2cv, a < s, b < s and M,v H ϕ; finally, if πb is of the form at3bc, ⟨s, πb⟩ϕ is satisfied at w iff there exists v ∈ S, wRat3bcv, a < s and M,v H ϕ. If a Petri Net program π is a composition of basic Petri Net programs of the form π1 ⊙ ... ⊙ πn, then the modality is satisfied if at least one of its compounds πi is ﬁred with the markup s and the Petri Net π program satisfies ϕ taking as input
the resulting markup f (s, πi), i.e. from the definition of Rπ,we have that ⟨s, π⟩ϕ is
satisfied at w iff  n  ⟨s, πi⟩⟨f (s, πi), π⟩ϕ is satisfied at w.
Satisfaction in a Petri-PDL model M = ⟨S, s0, Rπ, L,V ⟩ is given with respect to the initial state. If M, s0 H ϕ, we say that ϕ is satisﬁed in the model M, denoted by M H ϕ. If ϕ is satisfied in all models M we say that ϕ is valid , denoted by H ϕ. The axiomatisation for Petri-PDL consists of the following set of axioms and inference rules, where p and q are propositional symbols, ϕ and ψ are formulae, and
π and η = η1 ⊙ η2 ⊙ ··· ⊙ ηn are Petri Net programs.
(PL) Enough propositional logic tautologies
(K) [s, π](p → q) → ([s, π]p → [s, π]q)
(Du) [s, π]p ↔ ¬⟨s, π⟩¬p
(PC) ⟨s, η⟩ϕ ↔ ⟨s, η1⟩⟨f (s, η1), η⟩ϕ ∨ ⟨s, η2⟩⟨f (s, η2), η⟩ϕ ∨· · · ∨ ⟨s, ηn⟩⟨f (s, ηn), η⟩ϕ, where η = η1 ⊙ η2 ⊙· · · ⊙ ηn
(Rє) ⟨s, π⟩ϕ ↔ ϕ, if f (s, π)= ϵ
(Sub) If H ϕ, then H ϕσ, where σ uniformly substitutes proposition symbols by arbitrary formulae
(MP) If H ϕ and H ϕ → ψ, then H ψ
(Gen) If H ϕ, then H [s, π]ϕ
The axioms (PL), (K), and (Du), together with the inference rules (Sub), (MP), and (GEN), correspond to the usual axiomatisation for normal modal logics. The axiom (PC) expresses how the interleaving of firings in a Petri Net program occurs and (Rє) expresses the behaviour when no transition is enabled in a Petri Net.
A Resolution system for Petri-PDL
In this section, we present a clausal resolution-based calculus for Petri-PDL. In order to prove that a formula ϕ is valid, we apply the inference rules to the clausal form

of the negated formula, ¬ϕ. The transformation into the normal form follows [14] and [3], which use anti-prenexing together with simplification, followed by rewriting and renaming to separate the contexts to which the inference rules are applied.

Normal Form
Let ϕ be a formula in the language of Petri-PDL. The set of inference rules are ap- plied to the transformation of ϕ into a specific normal form, called Divided Separated Normal Form for Petri-PDL (DSNFPPDL), which separates the contexts (formulae which are true only at the initial state; formulae which are true in all states) for
reasoning. Before applying the transformation, we require that a formula ϕ to be in Anti-Prenex Normal Form (APNF), i.e. when modal operators are moved inwards a formula as much as possible. It has been shown in [5] that the transformation of a given problem into anti-prenex normal form (i.e. when quantifiers are moved in- wards a formula) results in a better set of clauses for First-Order Logics. The same approach for modal logics was investigated in [14], where it has been shown that anti-prenexing together with simplification may also result in a better set of clauses for a particular logic if its language allows for collapsing and/or simplification of modal operators (e.g. 22φ is simplified to φ, in S5, which reduces the nesting of modal operators). The application of such a technique to formulae in the language of Petri-PDL is justified by the axiom (PC), which allows similar simplifications. The transformation rules into APNF are given after the following definitions.
Definition 4.1 A literal is either p or ¬p, for p ∈ Φ. The literals l and ¬l are called complementary literals. A modal literal is either ⟨s, π⟩l or [s, π]l, where s is a sequence of names, π is a Petri Net program, and l is a literal.
Definition 4.2 A modal term is a formula of the form M1 ... Mkl, where l is a literal and Mi is of the form [si, πi] or ⟨si, πi⟩, 1 ≤ i ≤ k, k ∈  , where each si is a sequence of place names and πi is a Petri Net program.
Note that when k = 0, the literal l is not preceded by any modal operator.
Definition 4.3 Let ϕ and ψ be formulae in the language of Petri-PDL. A formula
χ is in Anti-Prenex Normal Form (APNF) if, and only if,
χ is a modal term; or
χ is of the form (ϕ ∧ ψ) or (ϕ ∨ ψ), and ϕ and ψ are in APNF;
χ is of the form [s, π]ϕ, ϕ is disjunctive, and ϕ is in APNF; or
χ is of the form ⟨s, π⟩ϕ, ϕ is conjunctive, and ϕ is in APNF.
We define a function α(ϕ), where ϕ is a formula, which produces the anti-prenex normal form of ϕ. The base case (i) occurs when the formula ϕ is already in APNF, that is, ϕ is a modal term. In this case, α(ϕ)= ϕ. If the main operator is modal, it can be distributed over subformulae in the following cases (where ϕ and ψ are formulae):

α([s, π](ϕ → ψ)) = α([s, π]ϕ → [s, π]ψ)
α([s, π](ϕ ∧ ψ)) = α([s, π]ϕ ∧ [s, π]ψ)
α([s, π]¬(ϕ → ψ)) = α([s, π]ϕ ∧ [s, π]¬ψ)
α([s, π]¬(ϕ ∨ ψ)) = α([s, π]¬ϕ ∧ [s, π]¬ψ) α(⟨s, π⟩(ϕ → ψ)) = α(⟨s, π⟩¬ϕ ∨ ⟨s, π⟩ψ) α(⟨s, π⟩(ϕ ∨ ψ)) = α(⟨s, π⟩ϕ ∨ ⟨s, π⟩ψ) α(⟨s, π⟩¬(ϕ ∧ ψ)) = α(⟨s, π⟩¬ϕ ∨ ⟨s, π⟩¬ψ)

If we have two consecutive modal operators, the function is applied recursively, where ϕ is of the form [sj, πj]ψ or ⟨sj, πj⟩ψ, for any sj a sequence of place names and πj a Petri Net program, and ψ is a formulae which is not in APNF:
α([s, π]ϕ) = α([s, π]α(ϕ)) α(⟨s, π⟩ϕ) = α(⟨s, π⟩α(ϕ))
If the main operator is a modal operator, but the formula inside its scope is not one of the above, we apply the anti-prenexing function to this formula, that is:
α([s, π]ϕ) = [s, π]α(ϕ) α(⟨s, π⟩ϕ) = ⟨s, π⟩α(ϕ)
When the main operator is classical, the transformation function is also applied recursively. Note that when the polarity of a subformula is negative, we rewrite the formula in order to make this explicit.


α(¬[s, π]ϕ) = α(⟨s, π⟩¬ϕ)
α(ϕ → ψ) = α(¬ϕ) ∨ α(ψ)
α(ϕ ∧ ψ) = α(ϕ) ∧ α(ψ)
α(ϕ ∨ ψ) = α(ϕ) ∨ α(ψ)
α(¬⟨s, π⟩ϕ) = α([s, π]¬ϕ)
α(¬(ϕ → ψ)) = (α(ϕ) ∧ α(¬ψ))
α(¬(ϕ ∧ ψ)) = (α(¬ϕ) ∨ α(¬ψ))
α(¬(ϕ ∨ ψ)) = (α(¬ϕ) ∧ α(¬ψ))

Because of the axiom (PC) and seriality, simplification of modal operators can be applied at any step of the transformation into the anti-prenexing normal form, as follows (where π = π1 ⊙ π2 ⊙· · · ⊙ πn, 1 ≤ i ≤ n):
α([s, πi][f (s, πi), π]ϕ) = α(⟨s, π⟩ϕ)
α([s, πi]⟨f (s, πi), π⟩ϕ) = α(⟨s, π⟩ϕ)
α(⟨s, πi⟩[f (s, πi), π]ϕ) = α(⟨s, π⟩ϕ)
α(⟨s, πi⟩⟨f (s, πi), π⟩ϕ) = α(⟨s, π⟩ϕ)
Note that, at the end of the transformation, α(ϕ) is in both APNF and in Negation

Normal Form (that is, a formula where the connectives are restricted to ¬, ∨, ∧, the modal operators are applied to literals, disjunctions or conjunctions, as given in Definition 4.3, and the negations are applied only to propositional symbols). The proof that the transformation into APNF is satisfiability preserving is given by the following lemma.
Lemma 4.4 Let ϕ be a Petri-PDL formula and let α(ϕ) be a formula resulting from the transformation of ϕ into APNF. H ϕ if, and only if, H α(ϕ).
Proof. The proof follows immediately from the soundness and completeness of the axiomatisation of Petri-PDL.	2
In order to separate the contexts for reasoning, we define a Petri-PDL problem to be a tuple ⟨I, U⟩, where I, the set of initial formulae, is a finite set of non- modal propositional formulae; and U , the set of universal formulae, is a finite set of formulae in the language of Petri-PDL. Let M = ⟨S, s0, Rπ, M, V⟩ be a Petri-PDL model. We say that a Petri-PDL problem Q = ⟨I, U⟩ is satisfied in M (denoted by M H Q) if and only if M,s0 H I and, for all s ∈ S, M,s H U (where satisfiability of sets is defined in the usual way).
Let α(ϕ) be a formula in APNF. The set of resolution-based inference rules, given in Section 4.2 are applied to the transformation of α(ϕ) into a clausal Petri- PDL problem, which is formally defined as a Petri-PDL problem ⟨I, U⟩, where I, the set of initial clauses, contains formulae in the form of

  li,
i
i ∈  , where li are literals; and U , the set of universal clauses, contains formulae in the form of
  li ∨  [sj, πj]lj ∨  ¬[sj , πj ]ljj,

j
i	j	k
k	k k

i, j, k ∈  , where li, lj , ljj are literals, sj, sj are sequences of place names, and πj, πj
j  k	k	k
are Petri Net programs.
The transformation of a formula ϕ into the clausal form starts by taking the problem ⟨{t0}, {t0 → α(ϕ)}⟩, where t0 is a new propositional symbol (i.e. a propo- sitional symbol that does not occur in ϕ), and applying exhaustively the following rewriting rules (where t is a literal, t1 is a new propositional symbol, and ψ1, ψ2 are formulae):
(τ1) ⟨I, U ∪ {t → (ψ1 ∧ ψ2)}⟩ −→ ⟨I, U ∪ {t → ψ1,t → ψ2}⟩;
(τ2) ⟨I, U ∪ {t → (ψ1 ∨ ψ2)}⟩ −→ ⟨I, U ∪ {t → (ψ1 ∨ t1), t1 → ψ2}⟩, if ψ2 is not a modal literal;
(τ3) ⟨I, U ∪ {t → ⟨s, π⟩ψ1}⟩ −→ ⟨I, U ∪ {t → ⟨s, π⟩t1, t1 → ψ1}⟩, if ψ1 is not a literal;

(τ4) ⟨I, C ∪ {t → [s, π]ψ1⟩—→ ⟨I, C ∪ {t → [s, π]t1, t1 → ψ1}⟩, if ψ1 is not a literal .
Note that we take conjunctions and disjunctions as being associative and commuta- tive. Thus, for instance, the transformation rule (τ2) also applies when ψ1 is not a literal. As a final step, we replace the modal operator ⟨s, π⟩ by its dual and rewrite implications as disjunctions, that is, we apply the following rewriting rules (where t, l are literals, D is a disjunction of literals and/or modal literals, s is a sequence of names, and π is a Petri Net program):
(τ5) ⟨I, C ∪ {t → D V ⟨s, π⟩l}⟩ —→ ⟨I, C ∪ {t → D V ч[s, π]чl}⟩;
(τ6) ⟨I, C ∪ {t → D}⟩ —→ ⟨I, C ∪ {чt V D}⟩.
We note that simplification takes place at any step of the transformation (i.e. in the application of both α and τ ), that is, we remove occurrences of the constants T and
⊥ as well as duplicates of formulae in conjunctions and disjunctions. This is achieved by exhaustively applying the following simplification rules (where conjunctions and disjunctions are commutative, ϕ is a formula, s is a sequence of place names, and π is a Petri Net program):

The transformation of a Petri-PDL formula into the clausal normal form is satisfiability preserving, as shown by the next lemma.
Lemma 4.5 Let ϕ be a well-formed formula in the language of Petri-PDL. ϕ is satisﬁable if, and only if, the transformation of α(ϕ) into DSNFPPDL is satisﬁable.
Proof. The proof that the transformation of a Petri-PDL formula into its nor- mal form is satisﬁability preserving follows immediately from Lemma 4.4, as only equivalences are used in the transformation into APNF, from the soundness and completeness of the axiomatisation of Petri-PDL, and from the fact that renaming of formulae by means of the introduction of new propositional symbols, during the transformation into the clausal normal form, is satisﬁability preserving.	2
Resolution rules
Let ϕ be a formula in the language of Petri-PDL and let τ (α(ϕ)) be the set of clauses resulting from the transformation of ϕ into the clausal normal form, as given in the

previous section. The resolution method for Petri-PDL, named RESPPDL, consists of applying the following inference rules to clauses in τ (α(ϕ)) (where C, Cj are disjunctions of literals, D, Dj are disjunctions of literals and/or modal literals, l, li,
0 ≤ i ≤ n, are literals, m is a literal or a modal literal, s is a sequence of place names, and π, η are Petri Net programs).

(ires) C V l	∈I ∪ C
Cj V чl ∈I 

C V Cj ∈I 

(ser1) D V [s, π]l	∈C 


D V ч[s, π]чl ∈C 


(ref)	D V [s, π]l ∈C 


if f (s, π)= ϵ D V l	∈C 
(ures) D V m	∈C 
Dj V чm ∈C 

D V Dj  ∈C 
(ser2) D V ч[s, π]l	∈C 
l1 V ··· V ln V l	∈C 


D V ч[s, π]чl1 V · · · V ч[s, π]чln ∈C 
(comp)	D V ч[s, π]l   ∈C if η ⊆ π and  Dj V [f (s, πb), η]l ∈C for any πb ∈ π, D V ч[s, π]чDj ∈C 

The inference rules (ires) and (ures) are equivalent to classical resolution applied within each context of a given problem. The inference rules (ser1) and (ser2) deal with seriality: a Petri Net cannot lead to a contradicting state. The inference rule (ref) corresponds to reflexivity and it can only be applied if f (s, π) = ϵ. The inference rule, (comp), deals with compositionality: if η is a Petri subnet of π, then we cannot have that both π = π1 ⊙ · · ·⊙ πn and η lead to a contradicting state, through sequences of names s and f (s, πb) for any basic program πb, b = 1,..., n. This rule can only be applied to clauses where all modal literals are subnets of π. The subformula ч[s, π]чDj in the resolvent of (comp) must be translated into its normal form through rewriting as follows. If Dj = l1 V ... V lm is a disjunction, then ч[s, π]ч(l1 V... Vlm) is translated into ч[s, π]чl1 V... Vч[s, π]чlm, where each ч[s, π]li, i = 1,..., m, is rewritten in its simplified form. For instance, if li is of the form [f (s, πb), ηj]lj, where lj is a literal, then ч[s, π]чli = ч[s, π]ч[f (s, πb), ηj]lj = ч[s, π]чlj. The next lemma shows that the resolution rules for Petri-PDL are sound.
Lemma 4.6 The resolution rules for Petri-PDL are sound.
Proof. Soundness of (ires) and (ures) follow from soundness of the resolution in- ference rule for propositional logic [17]. Soundness of (ser1) and (ser2) follow from (PC) and (Du). Soundness of (ref) follows from (Rє). Soundness of (comp) follows from the deﬁnition of satisﬁability of clauses in C, (K) and (PC).	2
Definition 4.7 A derivation from a Petri-PDL problem in DSNFPPDL Q = ⟨I, C⟩ 
by RESPPDL is a sequence Q0, Q1, Q2,... of problems such that Q0 = Q, Qi =
⟨Ii, Ci⟩, and Qi+1 is either
⟨Ii ∪ {D}, C⟩, where D is the conclusion of an application of (ires); or

⟨Ii, Ci ∪ {D}⟩, where D is the conclusion of an application of (ures), (ser1), (ser2), (ref), or (comp);
and D /= T.
We note that the resolvent D is only included in the set of clauses if it is not a tautology. Also, a resolvent is always kept in the simplest form: duplicate literals are removed; T and ⊥ are removed from conjunctions and disjunctions with more than one conjunct/disjunct, respectively; conjunctions (resp. disjunctions) with either complementary literals or ⊥ (resp. T) are simplified to ⊥ (resp. T).
Definition 4.8 A refutation for a Petri-PDL problem in DSNFPPDL Q = ⟨I, C⟩ (by RESPPDL) is a derivation from Q such that for some i ≥ 0, Qi = ⟨Ii, Ci⟩ contains a contradiction, where a contradiction is given by either ⊥∈ Ii or ⊥∈ Ci.
A derivation terminates if, and only if, either a contradiction is derived or no new clauses can be derived by further application of resolution rules of RESPPDL.

Correctness
In this section, we present the main results concerning the calculus for Petri-PDL, RESPPDL: soundness, termination, and complexity. We also discuss completeness of the method.
The first theorem shows that the resolution method for Petri-PDL is sound.
Theorem 4.9 The resolution method for Petri-PDL is sound.
Proof. Soundness of the resolution method for Petri-PDL follows from Lemma 4.5, which shows that the transformation of a Petri-PDL formula into DSNFPPDL is sat- isﬁability preserving, and from Lemma 4.6, which shows that each of the resolution inference rules is satisﬁability preserving.	2
The next theorem ensures that the application of the method is terminating.
Theorem 4.10 The resolution method for Petri-PDL is terminating.
Proof. Termination follows from the fact that, in a given clausal Petri-PDL prob- lem, there are only a ﬁnite number of literals and modal literals. Also, from the fact that a derivation (as given in Def. 4.7) cannot produce an inﬁnite number of clauses. Note, in particular, that the resolution rules (ser1), (ser2) and (comp) can generate new modal literals. As the number of modal literals of the form [s, π]l is ﬁnite, only a ﬁnite number of new modal literals of the form ч[s, π]чl can be generated by (ser1) or (comp). Similarly, as the number of literals is ﬁnite, (ser2) can only generate a ﬁnite number of new modal literals of the form ч[s, π]чl. Therefore, only a ﬁnite number of clauses (modulo ordering and simpliﬁcation) can be expressed. Thus, either we ﬁnd an empty clause or the method terminates as no new clauses can be generated.	2

The following theorem shows that the resolution-based calculus for Petri-PDL is optimal, as the complexity of the satisfiability problem for Petri-PDL is EXPTIME- complete [11].
Theorem 4.11 The resolution method for Petri-PDL runs in exponential deter- ministic time in the size of the Petri-PDL formula being tested for unsatisﬁability.
Proof. Let ϕ be a Petri-PDL formula. It is easy to see that the transformation into the normal form is linear in the size n of ϕ and so it is the size of a problem (given as the number of clauses). The inference rules (ser1), (ser2), and (ref) also produce a linear number of clauses in the size of the problem. The remaining rules are syntactical variations of classical propositional resolution, which takes exponential time in the size of a formula [17]. The number of applications of such inference rules depends on the modal depth of the original formula, but this cannot be greater then the size of ϕ. Therefore, the resolution method for Petri-PDL runs in O(n) × 2O(n),
i.e. it takes exponential deterministic time.	2
Completeness of the resolution method for Petri-PDL is ongoing work.
Claim 4.12 The resolution method for Petri-PDL is complete.
We hope to prove completeness as in the following argumentation, which is standard for proving completeness of calculi for modal logics. If the problem ⟨I, C⟩ is valid then the canonical model M (derived from the Petri-PDL language) satisfies
⟨I, C⟩. This canonical model generates a problem ⟨Ij, Cj⟩ where Ij is defined from the propositional formulae in I and Cj is the Hintikka set associated with the canonical model. We can show that the resolvents from the application of the inference rules to formulae in ⟨Ij, Cj⟩ are formulae in ⟨Ij, Cj⟩. Thus, the empty clause cannot be derived from ⟨I, C⟩. Therefore, if ⟨I, C⟩ is valid in M then there is no refutation of ⟨I, C⟩.

Examples
Before concluding, we show two examples of the application of the method.
Example 4.13 Suppose we want to test the formula

ϕ = [s, π1 ⊙ π2](p → q) → ([s, π1][f (s, π1), π1 ⊙ π2]p → [s, π2][f (s, π2), π1 ⊙ π2]q)
for unsatisfiability — an instance of the (K) axiom. Firstly, we transform чϕ into APNF, which results in:

α(чϕ)= (⟨s, π1 ⊙ π2⟩чp V [s, π1 ⊙ π2]q) Λ [s, π1 ⊙ π2]p Λ ⟨s, π1 ⊙ π2⟩чq

The transformation of α(чϕ) into the normal form results in the following clauses:



t0	[I]
чt0 V ч[s, π1 ⊙ π2]p V [s, π1 ⊙ π2]q [C ]
чt0 V [s, π1 ⊙ π2]p	[C ]
чt0 V ч[s, π1 ⊙ π2]q	[C ] The refutation proceeds as follows:
чt0 V ч[s, π1 ⊙ π2]p [C,(ures),2,4]
чt0	[C,(ures),5,3]
⊥	[I,(ires),6,1]

Example 4.14 Suppose a game where a player walks through scenarios, as repre- sented by the Petri Net in Fig. 3. The player uses keys to open doors which separate these scenarios. The number of open doors is given by the amount of tokens in place
O. The amount of keys available to the player is denoted by the amount of tokens in place K. A key can be used to open a door only if the player has a free hand, which is denoted by a token in place H. If both hands are busy there is a token in place B. We can show that, after three rounds of the game, the player has opened one door, has a free hand and still has two keys to continue the play. We represent the conjunction of these conditions by p. The three rounds are represented by the following set of clauses, where π = HKt2x ⊙ xt3yO ⊙ yt1H ⊙ Htj B ⊙ BtjjH:
1	1

p0	[I]
чp0 V ч[(KKKH), π]чp1 [C ]
чp1 V ч[(KKx), π]чp2	[C ]
чp2 V ч[(KKyO), π]чp3  [C ]
чp3 V чp	[C ]
where each pi, i = 1,..., 3, represents the i-th moment in time. We now show that this corresponds to a possible output of the game, that is, that ⟨KKHO, π⟩чp cannot hold in the initial time, which is given by the following clause:

чp0 V [(KKHO), π]p [C ]
The refutation proceeds as follows:


tj	H
B





K	O

Fig. 3. A Petri Net denoting a game where doors separate scenarios


чp2 V ч[(KKyO), π]p  [C,(ser2),4,5]
чp1 V ч[(KKx), π]p	[C,(comp),7,3]
9 чp0 V ч[(KKKH), π]p [C,(comp),8,2]
чp0	[C,(ures),9,6]
⊥	[I,(ires),10,1]

Conclusions and further work
Petri Net is one of the most used formalisms to deal with concurrent systems. Given a logical representation of a Petri Net program, it is desirable to have tools to rea- son about properties of the program within this framework. In this paper we have presented a sound resolution-based method for proving satisfiability of formulae in Petri-PDL, a logic system that takes advantage of the graphical interpretation of Petri Nets within a known decidable and complete fragment. In order to apply the resolution method, formulae in Petri-PDL are firstly converted into Anti-Prenex Normal Form (APNF) and simplification is applied whenever possible, which might lead to the generation of a better set of clauses. A formula in APNF is then trans-
formed into a normal form (DSNFPPDL), which separates the contexts for reasoning: an initial context (a finite set of non-modal formulae) and an universal context (a fi- nite set of Petri-PDL formulae). The inference rules presented in Section 4 are then
applied to the different contexts until a contradiction is found or no new clauses can be derived.
We have proved soundness and termination of the method and shown that the running time for testing satisfiability of a set of clauses is optimal. We are currently investigating its completeness, as given in Claim 4.12. The design of strategies for the method is left as future work. Further work also includes the implementation of an automatic theorem-prover and the extension of this method to DS3 [10], a logic system which extends Petri-PDL in order to deal with Stochastic Petri Nets (Petri Nets with probabilistic temporal variables).

References
de Almeida, E. S. and E. H. Haeusler, Proving properties in ordinary Petri Nets using LoRes logical language, Petri Net Newsletter 57 (1999), pp. 23–36.
Bourcerie, M., F. Bousseau and F. Guegnard, Petri Nets for production systems: Teaching and research in europe, in: Global Cooperation in Engineering Education: Innovative Technologies, Studies and Professional Development - International Conference Proceedings, 2008, pp. 85–89.
Degtyarev, A., M. Fisher and B. Konev, Monodic temporal resolution, ACM Trans. Comput. Log 7
(2006), pp. 108–150.
URL http://doi.acm.org/10.1145/1119439.1119443

Denaro, G. and M. Pezze, Petri nets and software engineering, in: J. Desel, W. Reisig and G. Rozenberg, editors, Lectures on Concurrency and Petri Nets: Advances in Petri Nets, Lecture Notes in Computer Science 3098, 2004, pp. 439–466.
Egly, U., On the value of antiprenexing, in: F. Pfenning, editor, Proceedings of the 5th International Conference on Logic Programming and Automated Reasoning, LNAI 822 (1994), pp. 69–83.
Fischer, M. J. and R. E. Ladner, Propositional Dynamic Logic of regular programs, Journal of Computer and System Sciences 18 (1979), pp. 194–211.
de Giacomo, G. and F. Massacci, Combining deduction and model checking into tableaux and algorithms for Converse-PDL, Information and Computation 160 (1998), p. 2000.
G¨oller, S. and M. Lohrey, Infinite state model-checking of Propositional Dynamic Logics, in: Z. E´sik, editor, Computer Science Logic, Lecture Notes in Computer Science 4207, Springer, 2006 pp. 349–364.
Lange, M., Model checking Propositional Dynamic Logic with all extras, Journal of Applied Logic 4
(2006), pp. 39–49.
Lopes, B., M. Benevides and E. H. Haeusler, Extending Propositional Dynamic Logic for Petri Nets, Electronic Notes in Theoretical Computer Science 305 (2014), pp. 67–83.
Lopes, B., M. Benevides and E. H. Haeusler, Propositional dynamic logic for petri nets, Logic Journal of the IGPL 22 (2014).
Mazurkiewicz, A., Trace theory, in: W. Brauer., W. Reisig and G. Rozenberg, editors, Petri Nets: Applications and Relationships to Other Models of Concurrency, Lecture Notes in Computer Science 255, Springer, 1987 pp. 278–324.
Mazurkiewicz, A., Basic notions of trace theory, in: J. W. Bakker, W.-P. Roever and G. Rozenberg, editors, Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, Lecture Notes in Computer Science 354, Springer, 1989 pp. 285–363.
Nalon, C. and C. Dixon, Anti-prenexing and prenexing for modal logics, in: Proceedings of the 10th JELIA (2006), pp. 333–345.
Peterson, J. L., Petri nets, Computing Surveys 9 (1977).
Petri, C. A., Fundamentals of a theory of asynchronous information flow, Communications of the ACM
5 (1962), pp. 319–319.
Robinson, J. A., A Machine–Oriented Logic Based on the Resolution Principle, ACM Journal 12
(1965), pp. 23–41.
Tuominen, H., Elementary net systems and Dynamic Logic, in: G. Rozenberg, editor, Advances in Petri Nets 1989, Lecture Notes in Computer Science, Springer Berlin Heidelberg, 1990 pp. 453–466.
Zurawski, R. and M. C. Zhou, Petri Nets and industrial applications – a tutorial, IEEE Transactions on Industrial Electronics 41 (1994), pp. 567–583.
