Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 347 (2019) 241–259
www.elsevier.com/locate/entcs

Deriving Logical Relations from Interpretations of Predicate Logic
Claudio Hermida1 Uday S. Reddy2
University of Birmingham
Edmund P. Robinson3,4
Queen Mary, University of London

Abstract
This paper extends the results of Hermida’s thesis about logical predicates to more general logical relations and a wider collection of types. The extension of type constructors from types to logical relations is derived from an interpretation of those constructors on a model of predicate logic. This is then further extended to n-ary relations by pullback. Hermida’s theory shows how right adjoints in the category of fibrations are composed from a combination of Cartesian lifting and a local adjunction. This result is generalised to make it more applicable to left adjoints, and then shown to be stable under pullback, deriving an account of n-ary relations from standard predicate logic. A brief discussion of lifting monads to predicates includes the existence of an initial such lifting, generalising existing results.
Keywords: logical relations, fibrations, categorical type theory, monadic types


Introduction
The purpose of this paper is to illustrate a link between logical relations and pred- icate logics. We begin by revisiting the conditions under which the predicates in a predicate logic for reasoning about a type theory can be shown to carry the struc- ture of that type theory. We then show that similar structure on binary and more generally n-ary relations can be derived from that on unary predicates. Finally, we take a look at structure defined via monads. The core of this material is already

1 Email: claudio.hermida@gmail.com
2 Email: u.s.reddy@bham.ac.uk
3 Email: e.p.robinson@qmul.ac.uk
4 This work was partially supported by EPSRC grant EP/R006865/1, Interface Reasoning for Interacting Systems

https://doi.org/10.1016/j.entcs.2019.09.013
1571-0661/© 2019 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

known. We extend the results to bring out more clearly what is needed, handle n-ary predicates via change of base, and discuss monadic types.
In order to do this we make use of the tools of category theory. From this per- spective, predicate logic is formalised as a fibration over a category representing the type theory. More accurately the base can be taken to have objects representing contexts consisting of variable:type bindings, and morphisms given by substitu- tions. We concentrate first on type theoretic structure that is defined by adjunction (products, function spaces and sums), but we then discuss monadic structure.
Logical relations were introduced by Gordon Plotkin [13,15]. But he is generous in giving credit to others, notably Hans Lau¨chli, Mike Gordon and Robert Milne. Milne had come up with a similar idea in connection with proving the equivalence of different semantics for programming languages (under the name of inclusive pred- icates) [12]. It is Milne’s insight, that these structures can be used to establish a formal link between different semantics, that has led to most of the modern work using them.
Since this time, the basic idea has been interpreted in a variety of settings. Calculi have been introduced for working with them, [14] and others, and the idea has been explained in terms of structure-preserving functor from categories of logical relations to the underlying types.
In this paper we build on that, starting out with Hermida’s work on logical predicates and how the structure of adjunctions between fibrations leads to an account of the interpretation of type theory in logical predicates.
We mine Hermida’s work slightly to show that we do not always need the full structure of fibrations. The key point where this has impact in the case of coprod- ucts. Hermida’s account along with successors, requires all cocartesian liftings. This is a strong condition that does not hold in all the syntactic fibrations corresponding to logics.
We then prove a change of base theorem for Hermida’s account, and use it to derive the formation of the same type constructions in n-ary relations. The example of function spaces shows that this is not as straightforward as first appears.
We conclude the paper with a discussion of monadic types. These behave dif- ferently from the conventional type-theoretic structures. We emphasise this with examples: monads on Set preserves monics, and hence extend to functors on Pred, but not all are fibred (the continuation monad); even though we immediately get an extension to Pred we need more work to get one for Rel (continuations again and also some algebraic theories like Mal’cev algebras). We also present a sufficient condition to have an initial lifting of a monad, relating it to recent work of Kammar and McDermott [8].
This work forms part of a programme, starting with [6], in which we attempt to relate the theory of logical relations to other forms of programme logic and standard forms of mathematical reasoning. The work in this paper supports deriving logical relations from predicates in the standard way that we expect. An issue with this approach is that it requires relations to have a single logical metastructure, rather than to give a systematic link between two different metastructures.  This can

be mitigated to some extent because the structures considered are closed under products, so can always be combined into a single entity. The work also contains the start of a treatment of monadic types. We expect to put more detail on that in future work.
Predicates and relations
To illustrate the concepts we use the categories of unary and binary relations: Pred
and Rel.
Definition 2.1 [Pred] The objects of the category Pred are pairs (P, A) where A is a set and P is a subset of A. A morphism (P, A) → (Q, B) is a function f : A → B such that ∀a ∈ A.a ∈ P ⇒ f (a) ∈ Q. Identities and composition are inherited from Set.
Pred also has a logical reading. We can take (P, A) as a predicate on the type A, and associate it with a judgement of the form a : A ▶ P (a) (read ”in the context a : A, P (a) is a proposition”). A morphism (a : A ▶ P (a)) → (b : B ▶ Q(b)) has two parts: a substitution b '→ t(a), and the logical consequence P (a) ⇒ Q(t(a)) (read ”whenever P (a) holds, then so does Q(t(a))).
Definition 2.2 [Rel and Reln] The objects of the category Rel are triples (R, A1, A2) where A1 and A2 are sets and R is a subset of A1 × A2 (a relation between A1 and A2). A morphism (R, A1, A2) → (S, B1, B2) is a pair of functions f1 : A1 → B1 and f2 : A2 → B2 such that ∀a1 ∈ A1, a2 ∈ A2.(a1, a2) ∈ R ⇒ (f1(a1), f2(a2)) ∈ S. Identities and composition are inherited from Set × Set.
P  Q	R  S


f
A  B	A1 × A2
f1×f2
B1 × B2

Reln is the obvious generalisation of Rel to n-ary relations.
Pred has a forgetful functor p : Pred → Set, p(P, A)= A, and similarly Rel has a forgetful functor q : Rel → Set × Set, q(R, A1, A2) = (A1, A2). These functors carry a good deal of structure and are critical to a deeper understanding of the constructions.
Moreover, both Pred and Rel are cartesian closed categories.

Cartesian closed structure
The terminal object in Pred is (1, 1), a singleton set with itself as designated subset. In Rel the terminal object is (1 × 1, 1, 1), the total relation on two singletons.
Products are not much more complex. In Pred the product of (P, A) and (Q, B) is (P × Q, A × B). And in Rel the product of (R, A1, A2) and (S, B1, B2) is (R × S, A1 × B1, A2 × B2), where ((a1, b1), (a2, b2)) ∈ R × S if and only if (a1, a2) ∈ R and (b1, b2) ∈ S.

The last part of the cartesian closed structure is the function space construction. In Pred, the function space [(P, A) → (Q, B)] is [R, A → B] where R is the subset of functions A → B mapping P into Q. In Rel The function space [(R, A1, A2) → (S, B1, B2)] is (R → S, A1 → B1, A2 → B2), where f1[R → S]f2 if and only if
∀a1 ∈ A1, a2 ∈ A2. a1RA2 ⇒ f1(a1)Sf2(a2).
So, both Pred and Rel are not only cartesian closed categories, but the forgetful functors p and q preserve all of that structure.

Sums
These properties extend to sums (coproducts). In Pred (P, A)+ (Q, B) = (P +
Q, A + B) where c ∈ P + Q if and only if c ∈ P or c ∈ Q.
Sums in Rel are constructed similarly. (R, A1, A2)+ (S, B1, B2)= (R + S, A1 + B1, A2 + B2), where x[R + S]y if and only if (x = inl a ∧ y = inl(b) ∧ aRb) ∨ (x = inr a ∧ y = inr(b) ∧ aSb).

Fibrations
We start with an interpretation of predicate logic such as p : Pred → Set. This has structure beyond being a homomorphism of cartesian closed categories. It is a fibration equipped with structure that supports an interpretation of predicate logic. See Jacobs [7] for a comprehensive introduction to fibrations and the interpretation of logic in them.
Given a functor p : E → C, and an object A of C, then p−1(A) forms a sub- category in which the morphisms are those mapping onto the identity of A. This is called the ﬁbre of p over A, written EA. In the context of fibrations, the morphisms of EA are called vertical maps. In the context of logic, the object A represents a context in the sense of a structure giving variable:type bindings, and the fibre over it represents propositions definable in that context ordered by consequence.
For any functor p : E → C, each object of E is an object of a unique fibre. Hence the objects of E are the disjoint union of the objects of the fibres, ob E =

A∈ob C
EA. But for a general functor p the fibres over distinct objects A and B

may be entirely unrelated, even when there is a morphism f : A → B. That is not
the case in p : Pred → Set, or in fibrations more generally.
In p : Pred → Set, pulling back along f : A → B induces a functor f∗ : PredB → PredA and rewriting the defining property of the pullback of p along f in terms of the functor p we get the definition of a cartesian map.
Definition 3.1 If p : E → C is a functor, then F : e1 → e2 is said to be cartesian with respect to p iff for any G : e0 → e2 and any factorisation p(G)= p(F ) ◦ h, then there is a unique map H : e0 → e1 such that G = F ◦ H and p(H)= h.
Definition 3.2 A functor p : E → C is a ﬁbration if for any f : c1 → p(e2) there is a cartesian map F : e1 → e2 such that p(F )= f (and hence p(e1)= c1). This map is called a cartesian lifting of f .

The next lemma collects properties of p : Pred → Set, and follows immediately from the definitions.
Lemma 3.3 For p : Pred → Set:
f : (P, A) → (Q, B) is cartesian if and only if P = f—1(Q) (i.e. the implicit commutative square is a pullback)
p is a ﬁbration
the ﬁbre of p over A is the lattice of subsets of A.
It follows easily from the definition that cartesian liftings are unique up to unique

isomorphism. Specifically, if F : e1 → e2 and Fj : ej
→ e2 are both cartesian liftings

of f : c1 = p(e1) = p(ej ) → e2, then there is a unique map i : e1 → ej
such that

1	1
F = i; Fj and p(i) is the identity on c1. The map i is necessarily an isomorphism.
Moreover, suppose we are given f : A → B and for each object e2 of EB a chosen cartesian lifting of f , Fe : f∗(e) → e. Then f∗ (defined on objects) extends uniquely to a functor f∗ : EA → EB. This does not mean that if we are given chosen cartesian liftings, then we can use these to derive a functor p∗ : Cop → Cat. We may not be able to choose our cartesian liftings so that the composite of the liftings along morphisms g and f are always the liftings along the composite gf . Instead we get a pseudo-functor, in which the functor p∗(gf ) is naturally isomorphic to (p∗g) ◦ (p∗f ). The components of these natural isomorphisms are vertical, they are maps in the relevant fibres.
However, we will be working mainly with fibrations where the fibres are partial orders. In this case, the only isomorphisms in a fibre are identities, cartesian liftings are thus unique, and we do get a functor.
Note that in any fibration p : E → C, any morphism f : e1 → e2 in E factors as a vertical map followed by a cartesian (the cartesian is the lifting of p(f ), and the vertical is obtained by factoring f through the cartesian over the triangle id; p(f )= p(f )). This factorisation is unique up to isomorphism, so when fibres are partially ordered it is unique. That applies in particular to p : Pred → Set and to q : Rel → Set × Set.
A morphism of ﬁbrations (or cartesian functor) is given by a commutative square in Cat as on the left below in which the topmost functor preserves cartesian maps. Since any Φ over φ preserves vertical maps, a cartesian functor also preserves the factorisation of morphisms into vertical and cartesian. In any square of functors as

on the left below, Φ induces functors between the fibres: ΦA : EA → Ej
. Since

a morphism of fibrations preserves cartesian maps, those functors are natural with respect to the reindexing functors f∗, at least up to isomorphism, as on the right:

E	Φ	Ej	EB
ΦB
EφB

p	p′
f∗ 	(φf )∗

C  Cj	EA
ΦA
EφA

The exact formal expression of this naturality for general fibrations requires

detailed coherence conditions for pseudo-natural transformations, while the formal definition in the fibrational approach is simple. In our case, we are dealing with partial orders and might reasonably adopt this alternative approach.
The interpretation of logical relations requires extending type structure from the base category C to the global category E. In order to do that we need structure defined by adjunctions. Formalisation of that requires 2-cells between functors.
Definition 3.4 The 2-category Cat↓ has:
objects (0-cells): an object is a functor p : E → C
morphisms (1-cells): a morphism from p : E → C to pj : Ej → Cj is a pair of functors Φ : E → Ej and φ : C → Cj such that pjΦ= φp.
2-cells: a 2-cell from (Φ, φ) to (Ψ, ψ) is a pair of natural transformations X :Φ ⇒ Ψ and χ : φ ⇒ ψ such that pjX = χp.

Φ
E	Ej
Φ

E	Ej

p	Ψ	p′ = p	φ	p′
C	Cj	C	Cj

ψ	ψ
The 2-category Fib is the subcategory of Cat↓ in which objects are fibrations, mor- phisms are cartesian functors and 2-cells are as in Cat↓ (it is a locally full sub-2- category).
Suppose f : C → Cj and pj : Ej → Cj is a fibration. Then a simple check shows that the pullback of pj along f in Cat is also a fibration, and that the pullback square is a morphism of fibrations.
f∗Ej	F	Ej
τ
f∗p′	p′

C  Cj
Note that if A is an object of C, then the fibre of f∗p over A is (isomorphic to) the fibre of pj over f (A). A particular example of this is Rel, which is the pullback of Pred along the product map Set × Set → Set.
Rel  Pred
τ
q	p
Set × Set (—)×(—) Set
We shall be particularly interested in two kinds of fibrations, semantic and type- theoretic/logical.
Our paradigmatic example of a semantic fibration is Pred. In a semantic fibra- tion, the underlying category C is a category of (semantic) mathematical objects, such as Set. The fibre of E over an object A of C is (derived from) a class of maps into A in C. In the case of Pred, these are the inclusions of subsets. Reindexing is

given by pullback, and hence cartesian maps correspond to pullback squares. If we need to interpret logical formulae, then we use the standard trick in which an n-ary predicate on A1,..., An is interpreted as an element of the fibre over A1 × ... × An. In the case of Pred this says that an n-ary predicate on A1,..., An is interpreted as a subset of, and hence a unary predicate on A1 × ... × An.
In a logical/type-theoretic fibration, the objects of C consist of contexts, usually a list of variable/type bindings: x1 : A1,..., xn : An. Objects of the fibre over a context consist of types (if modelling type theory) or predicates (if logic) in the given context. An example would be: x : A, y : A, z : B ▶ x = y. Morphisms in C are substitutions. So a morphism from y1 : B1,..., ym : Bm to x1 : A1,..., xn : An is given an n-tuple of terms in context y1 : B1,..., ym : Bm, y1 : B1,..., ym : Bm ▶ ti : Ai, representing the substitution (xi '→ ti)i=1...n. Reindexing, and hence the cartesian maps of the fibration, corresponds to performing these substitutions in the types or in the predicates. If contexts admit the laws of contraction, weakening and exchange, then the base category has finite products. If (in addition) the type theory itself has finite product types, then the context x1 : A1,..., xn : An can be replaced by x : A1 × ... × An, and so can be taken to consist only of a single type.
Adjunctions
Much type-theoretic structure is defined categorically through adjunctions. This includes products, coproducts and function spaces, though not monadic structure.
The standard definition of an adjunction between a functor F : C → D and a functor G : D → C (written F E G : C → D) is an isomorphism D(Fa, b) ~= C(a, Gb) natural in a and b. But this is equivalent to a formulation that allows us to define an adjunction between morphisms in an arbitrary 2-category:
Definition 4.1 An adjunction F E G : C → D in a 2-category is a pair of 2-cells
η : 1C → GF and ϵ : FG → 1D satisfying


F	D	C	F	D
id	id = id	id
G

id
C	D	G	C
id = id	id

D	C	F	D
G	C
G	C

This gives us the definition of an adjunction in Cat↓ and an adjunction in Fib.
Unpacking these definitions we see that in both cases an adjunction between

Φ	Ej
p	p′
C	φ	Cj
Ej	Ψ	E
and	p	p′
Cj	ψ	C

amounts to an adjunction in the base φ E ψ and an adjunction between the global categories Φ E Ψ which live over each other in the appropriate sense. Specifically, this means that an adjunction (Φ, φ) E (Ψ, ψ) in Cat↓ is exactly a map (p, pj) of

adjunctions as in Mac Lane [11] IV.7.
We will also use a third characterisation of adjunctions.
Lemma 4.2 Suppose F E G : C → D, and let ϵ : FGd → d be the adjoint of id : Gd → Gd (the counit of the adjunction). Then for any ƒ : Fc → d, ƒˆ, the adjoint of ƒ, is the unique map ƒˆ : c → Gd such that ƒ = F (ƒˆ); ϵ.
This tells us that if we consider the comma category (F ↓ d), whose objects are morphisms in D Fc → d, and whose morphisms are maps ƒ in C, such that F (ƒ ) makes the obvious triangle commute, then ϵ : FGd → d is terminal in (F ↓ d). A converse is also true. Given F , and for each object d of D a choice of terminal object ϵd : F (cd) → d in (F ↓ d), then there is a unique functor G : D → C such that Gd = cd, F E G and ϵ is the counit of the adjunction.
A dual result links the other direction of the adjunction and the unit (the adjoint of id : Fa → Fa): for any g : a → Gb, gˆ, the adjoint of g, is the unique map gˆ : Fa → b such that g = η; G(gˆ).
Adjunctions between Fibrations
Each map in a fibration factors as a vertical part (something that lives in a single fibre), followed by a cartesian part (something that represents a straightforward translation between fibres). In this section we reproduce Hermida’s result that adjunctions between fibrations factor in a similar way, and extend it slightly to morphisms of categories.
Change of base
The equivalent of a cartesian map in a fibration, is a cartesian functor that arises through change of base. The first result says that an adjunction in the base extends to an adjunction between a fibration and its change of base.
Lemma 5.1 (Hermida, [4,5]) Suppose p : C → A is a ﬁbration, and ƒ E g : B →
A is an adjunction, then there is a ﬁbred adjunction
p∗f
ƒ∗C	C

f∗p
gˆ	p
f

B	A
g

Proof. Let ϵ be the counit of ƒ E g and c an object of C. Then define gˆ(c) = (g(c), ϵ∗c), where ϵ : ϵ∗c → c is a (chosen) cartesian lifting of ϵpc : ƒgpc → pc.	2
Looking closely at the proof, we have only used the fibration structure to justify the existence of ϵ. So the same proof gives a result for arbitrary categories:
Corollary 5.2 Suppose q : C → A, and ƒ E g : B → A is an adjunction, and for all c ∈ C, the counit of ƒ E g, ϵ : gƒpc → pc has a cartesian lifting to c, then there

is an adjunction p∗ƒ E gˆ : p∗C → C over the original adjunction, as in section 4, giving an adjunction in Cat↓.
Taking the opposite of all categories we get a corresponding result for left ad- joints:
Corollary 5.3 Suppose q : C → A, and ƒ : B → A has a left adjoint g. Suppose moreover that the unit of the adjunction has a cocartesian lifting to C, then p∗ƒ : p∗C → C has a left adjoint gˆ, and the adjunction gˆ ▶ p∗ƒ lies over the original adjunction g ▶ ƒ.
Factorisation of adjunctions
These results can now be extended to arbitrary adjunctions. We show that under some lifting conditions, an adjunction can be composed of an adjunction over a fixed based (the vertical part) and an adjunction obtained from change of base as in Lemma 5.2 (the cartesian, horizontal part). The following is also a vanilla extension of Hermida, [4,5]. We do not require the functors p and q to be fibrations.

Proposition 5.4 Suppose ƒ : D → C over ƒ : B → A, that ƒ has a right (resp. left) adjoint g, and that both the unit, η and counit ϵ of that adjunction have carte- sian liftings to arbitrary objects of C and D Let ƒ factor through the pullback ƒ∗C as follows:


f
D	⊥	C	=	D
q	g	p f


f


C
p

B	A	A
g	g
Then the following are equivalent:
ƒ has a right (resp. left) adjoint g over the adjunction ƒ E g
ƒ˜ has a right (resp. left) adjoint g˜ over the identity on B.
Proof. For right adjoint (i)→(ii): Suppose (b, c) ∈ ob(ƒ∗C). Let η˜ : η∗c → gc be a (chosen) cartesian lifting of the unit η : b → gƒb = gpc = qgc. Define g˜(b, c)= η∗c. As before, g˜ extends canonically to a functor over the identity on B.
To establish the adjunction, suppose β = (β1, β2) : ƒ˜d = (qd, ƒd) → (b, c) in

ƒ∗C. We have ƒβ1 = pβ2 : ƒqd = pƒd → ƒb = pc. Using the adjunction in the base, the right adjoint of this is (gƒβ1)η : qd → gƒb. But η is natural, so (gƒβ1)η = ηβ1. Turning now to the adjunction ƒ E g, the right adjoint β^ : d → gc of β2 : ƒd → c lives over ηβ1. Since η˜ is cartesian over η, there is a unique β˜ : d → η∗c = g˜(b, c), lying over β1, such that η˜β˜ = β^. This construction is natural in both variables, and hence gives an adjunction lying over the identity adjunction on B as required.
For left adjoint: apply the result to the duals of all categories.	2

This decomposition of adjoints says that right adjoints are obtained in two parts. The first part is a cartesian lifting. In terms of standard predicate structure, this amounts to substituting terms into the predicate given as argument. The second part is an adjunction between two fibrations over the same base. This part depends on the existence of particular logical structure. For example, we will see that con- junction is used to give products, disjunction is used for sums (using the dual result for left adjoints), and implication and first order quantification produce function spaces.
Examples
In this section we look out how the construction above helps define structure on
Pred → Set.
Example 5.5 [Products]	Product	is	right	adjoint	to	the	diagonal:
Δ
Set	Set × Set
×
Consider the pullback of Pred × Pred along Δ:
Δ



Pred
Δ˜
⊥	Δ∗(Pred × Pred)
∧
p	Δ∗(p×p)
Set
(p×p)∗Δ
⊥
gˆ
Δ
⊥
×

Pred × Pred
p×p

Set × Set

On Pred, Δ maps a predicate P on set A to the pair of predicates (P, P ) on the pair of sets (A, A). The fibre of Δ∗(Pred × Pred) over the set A is Pred(A) × Pred(A), so

Δ factors through Δ∗(Pred × Pred) by Δ˜ , where Δ˜
maps P to (P, P ) in the fibre of

Δ∗(Pred×Pred) over A. (p×p)∗Δ now maps this to (P, P ) in the fibre of Pred×Pred
over A × A.
The adjoint of (p × p)∗Δ, as per Lemma 5.1, is given by lifting along the counit of the adjunction in the base. That counit is the product of the projections ϵ : (a0 × a1, a0 × a1) → (a0, a1): λ(x, y). (π0(x), π1(y)). Hence, given predicates P on A and Q on B, gˆ maps (P, Q) over (A, B) to (π∗P, π∗Q) over A × B.
0	1
Putting this in more logical terms: if a : A ▶ P (a): Pred and b : B ▶ Q(b): Pred,
then the result of applying gˆ to this pair of predicates is the pair got by substituting a '→ π0(x) into P (a), and b '→ π1(x) into Q(b): x : A × B ▶ (P (π0x), Q(π1x)) : Pred × Pred.
The point of this operation is to get two predicates on the same type. This is obscured if we write something like: a : A, b : B ▶ (P (a), Q(b)) : Pred × Pred.

The adjoint of Δ˜
is ∧, which takes a pair (P1, P2) of predicates on A to their

intersection, P1 ∧ P2. From a logical perspective, this is conjunction.
Putting this together, we get that the right adjoint to Δ : Pred → Δ × Δ takes

a pair of predicates (P, Q) over (A, B) (written as (P (a), Q(b)) to the predicate P (a) ∧ Q(b) on A × B. This is what we expect. It would be easy to calculate this directly, but the point is to see this as coming from our general framework for adjunctions.
Example 5.6 [Function spaces] For function spaces we have:
—×P



Pred






A→—
Pred
p

Set

Here, P is a predicate on A, and −× P is the functor just calculated, sending a predicate Q on B to Q(b) ∧P (a) on B ×A. As before, we compute the right adjoint in stages.
Given (Q, B) in Pred(B), the counit in the base is evaluation: evB : (A →
B) × A → B.
gˆ(Q, B) is then ev∗ (Q, B), the pullback of (Q, B) along evB. Reading this from a logical perspective, this amounts to a substitution b '→ ƒ (a) in Q(b). We write the result informally as ƒ : A → B, a : A ▶ Q(ƒ (a)) Pred, or more formally as x : (A → B) × A ▶ Q((π0x)(π1x)) Pred.
Now, the fibre of (−× A)∗Pred over a set C is Pred(C × A), and −× P factors through this via −∧P . Specifically, if R is a predicate on C, then R∧P is R(c)∧P (a), a predicate on C × A.
The right adjoint to this, g˜, takes a predicate S(c, a) to ∀a ∈ A.P (a) → S(c, a). This exists in Pred, but if we are working in a fibration encoding a more general logic, it will be sufficient for that logic to have implication and first-order quantification. Putting this with the previous adjoint, we get that Q is sent to a predicate on
A → B which holds of ƒ iff ∀a ∈ A, P (a) → Q(ƒ (a)), as expected.
Example 5.7 [Coproducts] The theory for coproducts is similar to that for prod- ucts. The overall structure of the diagram below is identical to that for prod-

ucts, but we have left adjoints rather than right.	In particular, Δ, Δ˜
and

Δ∗(Pred × Pred), etc are exactly as before.	The left adjoint to Δ˜
is disjunc-

tion in the fibres. To get a left adjoint to (p × p)∗Δ we use a cocartesian lifting along the unit in the base. The unit in the base is λ(a, b).(inl a, inr b) : (A, B) → (A + B, A + B). The cocartesian lifting of this takes a pair of predicates P on A and Q on B to the predicates case x of {inl a -> P(a); inr b -> False} and case x of {inl a -> False; inr b -> Q(b)}, both predicates on A + B. This is a weak form of existential quantification, significantly weaker than having cocarte- sian liftings along arbitrary maps. Cocartesian liftings along product projections correspond to standard existential quantification.

Δ



Pred
Δ˜
T	Δ∗(Pred × Pred)
∨
p	Δ∗(p×p)
Set
(p×p)∗Δ
T
gˆ
Δ
T
+

Pred × Pred
p×p

Set × Set


Change of base
Results
This section is about the implication of the results in section 5 for situations obtained by change of base. We want to transfer structure from a primary fibration to another obtained from it by pullback along a suitable change of base. The key example is pullback of Pred along Π : Setn → Set, which expresses the fact that an n-ary relation can be regarded as a unary predicate on the product of the underlying sets.
First, we observe that pullback preserves cartesianness, even when the categories involved are not fibrations.

Lemma 6.1 Suppose the diagram below is a pullback of categories, and that α : P0 → P1 is cartesian in P over Fα where α : B0 → B1. Then (α, α) is cartesian in F∗P over α.

F∗P
F∗p
B
p∗F
P
p
F	A


For our purposes we consider the following situation in the base. We have a commutative square, as below, in which the horizontal arrows F and G have right adjoints Fr and Gr. It is not necessarily the case that KGr = FrH, though there is a canonical natural transformation between them, the mate of the identity on FK = HG. We will consider an adjunction of categories over F E Fr, pulled back along H and K.

Lemma 6.2 Suppose we are given a commutative square as above, and a category P over A. This produces the cube below in which the front face and the left and right sides are pullbacks. The functor G is obtained as the obvious pullback factorisation. The functors F and G have right adjoints Fr and Gr.




K∗F∗P
G	H∗P



K∗F∗p	P


D	p

A
Fr

Suppose ϵ is the counit of G E Gr, and that Hϵ has cartesian liftings to P. Then G
has a right adjoint over Gr.
Proof. Since pullbacks compose, the composite of the front and left faces is also a pullback. Hence so is the composite of the back and right faces. This in turn implies that the back face is a pullback. We now apply lemma 6.1, to show that ϵ has cartesian liftings to H∗P , and lemma 5.2 to yield the result.	2
Lemma 6.3 Suppose G E Gr is an adjunction in Cat/B, then pulling back along a functor K : D → B gives an adjunction over D.
Proof. Pullback along K gives a 2-functor K∗ : Cat/B → Cat/D. K∗ therefore preserves unit and counit of the adjunction in Cat/B, and the fact that they satisfy the triangle identities. It therefore preserves the adjunction.	2
The following proposition assembles these results together to give an account of changing the base of an adjunction between p and q by puling back along functors H and K as in the diagram below. The input data here consists of the front and bottom faces of the cube

K∗Q
G	H∗P

K∗q	P
D	p
A
Fr

so that (q, p) is a map of adjunctions and HG = FK. G is the map K∗Q → H∗P
obtained by factorisation through pullback.
Proposition 6.4 Given a cube as above, suppose the front face is a map of adjunc- tions obtained by factorisation through the pullback as in proposition 5.4, and that HG = FK, Suppose further that the counit ϵ : GGr → 1C of G E Gr has cartesian



liftings to H∗P (e.g. if Hϵ has cartesian liftings to P). Then G : K∗Q → H∗p is the left adjoint in an adjunction living over G E Gr, in which the right adjoint is also constructed by factorisation through the pullback as in 5.4.
Proof. This follows immediately from lemmas 6.2 and 6.3.	2
Examples
Example 6.5 [products] We consider the binary product of n-ary relations.

Reln
Δ
Reln × Reln

Δ
Pred	⊥



Pred × Pred


Setn	Setn × Setn

Set	Set × Set
×
The front face of the cube is the construction of the binary product of logical predicates that we saw in example 5.5.
Relations are constructed by pullback from Pred along the product functor Π : Setn → Set. This leads us to the bottom face of the cube, which commutes. It is worth spelling this out.
Given an n-tuple of sets: (Ai)i∈{1...n}, taking this along the rear and right hand sides gives (Π × Π)Δ(Ai)= (ΠAi, ΠAi) And taking it along the left and front gives ΔΠ(Ai) = (ΠAi, ΠAi). These are equal, not just canonically isomorphic, and so we can apply the theory developed above immediately to show that the product of n-ary relations is constructed as we expect.
Example 6.6 [function spaces] To derive n-ary function spaces from unary ones, the diagram is:
Reln  Reln




Setn
Pred	Pred

Setn


Set	Set
(ΠAi)→—
However the bottom face of this cube does not commute. Consider an object (Bi) of Setn. Going left and down round the square we get Π(Bi × AI ), while going

down and left we get (ΠBi) × (ΠΑi). These are naturally isomorphic but not equal. Consequently we cannot simply apply the results above.
There are at least two ways out of this problem. The more principled is to redo the theory so that it will cope with commutation up to natural isomorphism. The technically simpler alternative is to fix the square so that it commutes. Replace the front left vertical edge of the cube by its product with the indiscrete category on ob Setn. The objects of ob Setn × Set are pairs ((Bi), C) where (Bi) is an n-tuple of sets and C is a set. Morphisms ((Bi), C) → (Bj), Cj) are functions C → Cj. This gives us a structure equivalent to the original, and with the same formal properties. But we can tinker with the two functors that form edges of the bottom square. We take the first to be given by (Bi) '→ ((Bi), ΠBi), and the second to be given by the natural extension to morphisms of:
F ((Bi), C)= C × ΠΑi if C /= ΠBi
F ((Bi), C)= Π(Αi × Bi) if C = ΠBi
The square now commutes and our theory applies. But since everything is equivalent to the original, the logical description of the function space still works.
Example 6.7 [coproducts] As before, the story for coproducts is the same as the story for products. It makes use of the same diagrams, but the theory is applied to the opposite categories, yielding left adjoints rather than right. In particular the bottom face of the cube is obtained from the bottom face of the diagram for products by applying op to all of the categories involved. It therefore commutes exactly.
Monads
Monads provide another approach to defining structure. Given a category B rep- resenting types, a category P representing a predicate logic for B, and a monad T on B, then there is no fully general method of extending T to a monad on P . But there are ways that work under some circumstances.

Initial cocartesian lifting of a monad
In [8,9,10] such an extension of a monad from the base B to the total category P of a fibration (logic) is called a lifting . Katsumata’s method involves embedding into a given continuation or codensity monad, which relies both on closed structure and a somewhat arbitrary parameter. Kammar’s method seeks an initial lift for the given monad. We can indeed provide such an initial lift under very minimal conditions on p:
Theorem 7.1 (Initial lifting of a monad) Given a monad (T : B → B, η, μ), whenever p : E → B admits cocartesian liftings of η, the category Lift(T ) of monad liftings admits an initial object.
Proof. Define the lifted monad (T : E → E, η, μ) as follows: for an object X ∈ E,

let ηX : X → TX be a cocartesian lifting of ηpX : pX → TpX at X. This defines both T and η. Using both unit equations, we have μ ◦ (η • η) = η and since η • η is cocartesian, there is a unique transformation μ : TT → T over μ such that μ ◦ (η • η)= η. Cocartesianness also proves the monad equations for these data, as well as the initiality.	2
In general the lifted monad functor T will not be fibred even when p is a fibration, but it is cofibred.
The initial lifting of [8, Theorem 4.8] is a special case of this, under the assump- tion that the fibres of the functor p are small complete preorders. When p admits cartesian as well as cocartesian liftings, we have for ηX : X → TX the adjunction

ΣηX
E η∗
: ETX → EX . Under the assumption that the fibres are small complete

preorders, the adjoint functor theorem tells us that the left adjoint (= cocartesian
lift) is computed as Ση (y) =  {x ∈ ETX|y ≤ η∗ x}. The condition y ≤ η∗ x is
X	X	X
equivalent, for a faithful functor p, to the existence of a morphism y → x over ηX .
This latter is precisely the condition the unit respects y in the construction of the initial lifting of T in p. 254 of [8]. We are ignoring here the presence of algebraic operations in T , which we deal with separately in a follow up article.
It is worth noticing that the ’formula’ for initial lift of a monad T , T = Ση(id ) as presented in our theorem, is used in [1] for the interpretation of the  -modality of their FIX-logic but without reference to it being a monad, let alone an initial lift.
Image factorisation and monads on monics
If P is presented as a subcategory of monics in C (e.g. Pred), then T is already defined on the objects of P , and we can take T (P > A) to be defined from TP → T A. If T preserves monics in our subcategory, then this is fine. If not we can hope to use someimage factorisation TP  T jP  TA, as in [3]. This method of lifting has been recast in fibrational language, using cocartesian liftings and comprehension, in place of image factorisation in [2].
We use two particular monads as running examples: the list monad, L, and the continuation monad, C. The list monad is an example of algebraic structure, and the continuation monad is not.
Monads on Set and unary predicates
Let T be a monad on Set. Then T preserves monics.
Lemma 7.2	(i) Let F : Set → Set be a functor, and i : A > B a monic, where
A /= ∅, then Fi is also monic.
Let M : Set → Set be a monad, and i : A > B any monic, then Mi is also monic.
Let M : Set → Set be a monad, then M extends to a functor Pred → Pred over
Set.
Proof. (i) i has a retraction which is preserved by F . (ii) If A is non-empty, then this follows from the previous remark. If A is empty, then there are two cases. If

M∅ = ∅, then Mi : ∅ = M∅ = MA → MB is automatically monic. If M∅ /= ∅, then let r be any map B → M∅. MB is the free M -algebra on B, and therefore there is a unique M -algebra homomorphism r∗ : MB → M∅ extending this. Mi is also an M -algebra homomorphism and hence so is the composite r∗(Mi). Since M∅ is the initial M -algebra, it must be the identity, and hence Mi is monic. (iii) Immediate.	2
Example 7.3 The list monad: LB is the set of lists whose elements come from B, and so is a subset of LA.
The direct image powerset functor P : Set → Set, where P (ƒ )= {b|∃a.ƒ (a)= b}, also has the property that PB ⊆ PA if B ⊆ A.
The continuation monad is defined by CA = (A → K) → K, where K is the set of continuations. C∅ is isomorphic to K and contains the constant functionals. These are included in any type CA. If B ⊆ A, then CB = (B → K) → K, and if j : B → A is the inclusion of B in A, then Cj sends CB to
{Φ: (A → K) → K | g T B = gj T B → Φg = Φgj}.
But there is a difference from the point of view of fibrations: L and P are fibred functors, while C is not. From the logical perspective, this means that L works well with substitution, but C does not.
Lemma 7.4 C is not a ﬁbred functor.
Proof. Let A = {0, 1}, B = {a, b, c} and ƒ : B → A be defined by: ƒa = 0, ƒb = ƒc = 1. Let P = {1} ⊂ A. Then ƒ∗P = {b, c}. Given Ψ : CB, (Cƒ )Ψ = λg : A → K. Ψ(g ◦ ƒ ). Consider the functional Θ : CB, defined by
Θh = hb	if hb = hc
= ha	if hb /= hc
Now, for any g : A → K, ((Cƒ )Θ)g = Θ(g ◦ ƒ ), but (g ◦ ƒ )b = g1 = (g ◦ ƒ )c, so ((Cƒ )Θ)g = g1. It follows that (Cƒ )Θ is in CP , and hence Θ is in (Cƒ )∗(CP ). However, the result of applying Θ to h can clearly depend on ha. Θ is therefore not in C(ƒ∗P ). It follows that C is not a fibred functor.	2

Monads on Set and binary relations
There is also a difference when it comes to binary, and more generally, n-ary rela- tions. Suppose R > A × B, then MR > M (A × B), and there is a canonical map M (A × B) → MA × MB, but this is not necessarily monic, and hence the induced MR → MA × MB is also not necessarily monic.
Lemma 7.5 The map (CπA, CπB) : C(A × B) → CA × CB is not necessarily monic.
Proof. CX = (X → K) → K. Consider the example where K = 2, A = B = 2. Then a simple cardinality argument shows that no map C(A× B) → CA× CB can

be monic. |C(A × B)|
= 224
= 216
, while
|CA × CB| = 222 ∗ 222 = 28.	2

Some monads, such as the list monad, do have the property that this map is monic, and hence that they preserve binary relations.
Lemma 7.6 If i : R > A × B, then LR > L(A × B) → LA × LB is monic.

Proof. Let [(a0, b0),... (an, bn)] and [(aj , bj ),... (aj , bj
)] be two typical elements

0  0	m  m

of LR. Then these map to ([a0,..., an], [b0,..., bn]) and ([aj ,..., aj ], [bj ,..., bj
]) in

0	m	0	m
LA×LB. These are equal if and only if [a0,..., an]= [aj ,..., aj ] and [b0,..., bn]= 
0	m
[bj ,..., bj ]. But this implies m = n and that ai = aj and bi = bj for all i = 0 ... n.
0	m	i	i
So [(a0, b0),... (an, bn)] = [(aj , bj ),... (aj , bj )].	2
0  0	m  m
It may appear that this is because the list monad is algebraic, but not all alge- braic monads have normal forms that can be used like this.
Example 7.7 A Mal’cev operation is a ternary operation m(x, y, z) such that m(x, x, z) = z and m(x, z, z) = x. An important example is m(x, y, z) = xy—1z in the theory of groups. Let M be the monad corresponding to an algebra freely generated by a single Mal’cev operation. Then M (A×B) → MA×MB is not neces- sarily monic. Consider A = {a, b} and B = {0, 1}. Then m((a, 0), (a, 1), (b, 1)) maps
to m(a, a, b)= b in MA and to m(0, 1, 1) = 0 in MB, but m((a, 0), (a, 1), (b, 1)) is not equal to (b, 0) in M (A × B). This can be shown by exhibiting any algebra with a Mal’cev operation and four elements u, v, w, x such that m(u, v, w) /= x.
As a consequence, if M is the monad corresponding to the theory of a free Mal’cev operator, then M 4 does not map injectively into M 2 × M 2.
But factorisation will always work in Set. If M is any monad, then MA × MB has a natural M -algebra structure, and M (A × B) → MA × MB is an M -algebra homomorphism. Just as with standard algebraic varieties, sub-algebras are closed under arbitrary intersecion, and therefore we can take MR to be the intersection of all the sub-algebras containing the image of R under η.

References
Crole, R. L. and A. M. Pitts, New foundations for fixpoint computations: Fix-hyperdoctrines and the fix-logic, Information and computation 98 (1992), pp. 171–210.
Ghani, N., P. Johann and C. Fumex, Fibrational induction rules for initial algebras, in: International Workshop on Computer Science Logic, Springer, 2010, pp. 336–350.
Goubault-Larrecq, J., S. Lasota and D. Nowak, Logical relations for monadic types, Mathematical Structures in Computer Science 18 (2008), pp. 1169–1217.
Hermida, C., “Fibrations, logical predicates and related topics,” Ph.D. thesis, PhD thesis, University of Edinburgh, 1993. Tech. Report ECS-LFCS-93-277. Also available as Aarhus Univ. DAIMI Tech. Report PB-462 (1993).
Hermida, C., Some properties of fib as a fibred 2-category, Journal of Pure and Applied Algebra 134
(1999), pp. 83–109.
Hermida, C., U. S. Reddy and E. P. Robinson, Logical relations and parametricity - A reynolds programme for category theory and programming languages, Electr. Notes Theor. Comput. Sci. 303 (2014), pp. 149–180.
URL https://doi.org/10.1016/j.entcs.2014.02.008
Jacobs, B., “Categorical logic and type theory,” Studies in logic and the foundations of mathematics
141, Elsevier, 1999.


Kammar, O. and D. McDermott, Factorisation systems for logical relations and monadic lifting in type- and-effect system semantics, Electronic Notes in Theoretical Computer Science 341 (2018), pp. 239– 260.
Katsumata, S., A semantic formulation of tt-lifting and logical predicates for computational metalanguage, in: C. L. Ong, editor, Computer Science Logic, 19th International Workshop, CSL 2005, 14th Annual Conference of the EACSL, Oxford, UK, August 22-25, 2005, Proceedings, Lecture Notes in Computer Science 3634 (2005), pp. 87–102.
URL https://doi.org/10.1007/11538363_8

Katsumata, S. and T. Sato, Codensity liftings of monads, in: L. S. Moss and P. Soboci’nski, editors, 6th Conference on Algebra and Coalgebra in Computer Science, CALCO 2015, June 24-26, 2015, Nijmegen, The Netherlands, LIPIcs 35 (2015), pp. 156–170.
URL https://doi.org/10.4230/LIPIcs.CALCO.2015.156

Mac Lane, S., “Categories for the working mathematician,” Number 5 in Graduate Texts in Math, Springer-Verlag, 1971.
Milne, R., “The formal semantics of computer languages and their implementations,” Oxford University Computing Laboratory, Programming Research Group, 1974.
Plotkin, G., “Lambda-definability and logical relations,” Edinburgh University, 1973.
Plotkin, G. and M. Abadi, A logic for parametric polymorphism, in: International Conference on Typed Lambda Calculi and Applications, Springer, 1993, pp. 361–375.
Plotkin, G. D., Lambda-definability in the full type hierarchy, To HB Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism (1980), pp. 363–373.
