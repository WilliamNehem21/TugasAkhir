	Electronic Notes in Theoretical Computer Science 215 (2008) 191–208	
www.elsevier.com/locate/entcs

Process Algebra with Local Communication
Muck van Weerdenburg1
Eindhoven University of Technology Department of Mathematics and Computer Science
P.O. Box 513, 5600 MB Eindhoven, The Netherlands

Abstract
In process algebras like μCRL and ACP communication is defined globally. In the context of component-based architectures one wishes to define subcomponents of a system separately, includ- ing communication within that subcomponent. We define a process algebra with an operator for local communication that facilitates component-based architectures. Besides being compositional, this language is aimed to be a more practical language (with respect to closely related languages) and also allows for straightforward modelling of synchronous as well as asynchronous behaviour.
Keywords: process algebra, local communication, true concurrency, compositionality, synchrony


Introduction
In modelling systems, component-based architectures are a natural way of sep- arating different parts (and subparts) of a system and specifying how these parts relate to each other by means of, for example, communication. Espe- cially in the case of larger systems (i.e. real-life systems and complex proto- cols), component-based modelling is essential to avoid losing overview of the model. We introduce a new process algebra called LoCo which aim it is to be a practical language supporting such hierarchical modelling. Besides the asynchronous behaviour seen in most languages, this algebra also supports the modelling of synchronous behaviour. This allows for the modelling of, for example, electronic circuits (from which one wants to abstract away from the relatively small delays) or easy multiway communications.

1 E-Mail: M.J.van.Weerdenburg@tue.nl



1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.06.028

The main difference between LoCo and most other process algebras is the fact that it has a local communication mechanism and multiactions. Local communication means that one can specify communication between compo- nents precisely where it is relevant, whereas global communication means that one has to specify the communication for the whole system in one place. Multi- actions are basically multisets of actions that occur at the same time (without communicating). With these concepts we also get a straightforward way to model synchronous behaviour.
To illustrate the differences between global and local communication we consider Figure 1. Here a system with two of components, A and B, that desire to communicate via actions s and r is depicted. Now say that in another part of the system there is a components C that, for some purpose, also uses an action r (possibly because C is actually just B but in a different context). In Figure 1(a) it is illustrated that it is not possible to simply define these communications on a global level. There is no way for component A to avoid communicating with C instead of B. The only way to avoid such mistakes is to rename some of the actions (e.g. r in A to rA etc.). With local communication one can simply specify that a given communication is only meant for certain parts of the system. This is illustrated on the right in Figure 1(b).

s communicates with r










(a) Global communication	(b) Local communication

Fig. 1. Global vs. local communication
Primarily, the language LoCo was developed as a basis for mCRL2 2 [13,15], successor of μCRL [14], where an important motivation was to be able to straightforwardly express Petri nets [17] in process algebra. In Petri nets the firing of a transition consist of taking tokens from some places and, at the same time, putting tokens in others. This was the initial reason to

2 mCRL2 is basically LoCo with a slightly different syntax, timing and a (more or less) fixed data algebra.

introduce multiactions, which in turn resulted in the addition of local instead of global communication. After adding this local communication it became clear that it made the language a truly compositional process algebra. This led us to reversing the thought process; local communication is introduced to make the language compositional and it is this local communication that leads to the introduction of multiactions (as is explained below).
It is due to this origin that LoCo seems to be more closely related to other attempts to link Petri nets and process algebra than to process algebras developed for component-based modelling. Also the fact that the latter are often inspired by CCS [20] or the π-calculus [22] plays a role. These languages, such as CaSE [23], IP-calculus [10] and PiLar [11], have local communication, but it is restricted to actions (a) communicating with their counterparts (a) only. Or, as in PADL [6], they use strict synchronisation on actions. In such cases, communication (or synchronisation to a single action) is tightly linked to the parallel operators and therefore does not require multiactions. It does, however, restrict the freedom in modelling and complicates constructions as multiway communication. Other process algebras with local communication or synchronisation, such as LOTOS [16] and the Interworkings language [19], also have this strong connection between communication and parallelism.
In LoCo we have separated the concepts of parallelism and communica- tion and linked them by means of multiactions. This also gives a more natural intuition to the operators. Parallel composition now means just putting two components in parallel; the execution of actions in one component is inde- pendent of the other component. Only by applying a special operator for communication one creates links between components. To make this possible, multiactions are needed. The parallel composition results in multiactions as a consequence of components executing actions at the same time. Creating a link between two (or more) components is done by applying the local com- munication operator. This way actions within the multiactions result in a communication. It is also much easier to model multiway communication in this way, in contrast to algebras where communication and parallelism are as one. In these languages one has to specify communication per pair of compo- nents (and pair of pair of components etc.) in such a way that the result is in fact a multiway communication. That is, if it is even possible to do so only by means of communication.
This separation of parallelism and communication is also seen in ACPec [3] and the algebra from [2], which describe an ACP [4] approach to combining process algebra and Petri nets. However, in [3] the communication used by the local communication operator is still defined globally and thus limits composi- tionality. Because of this one cannot use a single component multiple times in

the same system (in different contexts) without renaming its actions. On the other hand, [2] uses a renaming operator to apply local communication, but in a setting with data this is not really a preferable choice. It is more intuitive for renaming to disregard data and for communication to require that data parameters (of actions) are equivalent.
The Petri Box Calculus [8,7,9] gives a more Petri-net-based approach to combining both formalisms. Although the communication is done in the CCS style, multiactions are used here. Because of these multiactions multiway communication becomes feasible, but it remains cumbersome due to the type of communication. A component needs to know that it is going to participate in a multiway communication or one has to introduce a special component that takes care of it. The same holds for SCCS [21] and MEIJE [1], which add synchrony to CCS.
What is not encountered in any of the above algebras with multiactions is a restriction operator that only allows certain actions. Only in [2] one might consider it present in the blocking (or encapsulation) operator (the inverse of restriction), but blocking on its own is not sufficient in practice. The reason to add the restriction operator is that it can often be the case that one only wishes to allow a small number of multiactions of a process with a much greater total amount of different multiactions. Take for example the parallel composition of n actions, which results in 2n − 1 different multiactions. If one only wants to allow the multiaction in which each action is present, blocking would require one to specify 2n − 2 multiactions (instead of just one with our restriction operator).
In Section 2 we introduce the syntax of LoCo for which we give a semantics in Section 3. An axiomatisation for LoCo is given in Section 4 to facilitate algebraic reasoning. As abstraction and data often play an important role in systems, we discuss these in Sections 5 and 6, respectively. Some examples are given in Section 7 to illustrate LoCo by modelling a Petri net and a simple compositional system.

Syntax
We describe the elements of our algebra informally. A detailed definition of the syntax can be found in [28] (without data) and [27] (with data).
The basic elements of processes are multiactions. Multiactions are bags (or multisets) of actions, from the set of actions NA, that execute together. We write a multiaction of actions a, b and c as ⟨a, b, c⟩ (or ⟨b, a, c⟩ as order has no meaning in bags). Often we write multiactions that consist of only one action without brackets (i.e. a instead of ⟨a⟩). We can combine such multiactions

with the common operators · and + to form a sequence of multiactions or a nondeterministic choice between multiactions, respectively. The special case of the empty multiaction ⟨⟩ is called a silent step, which we often write as τ . To denote inaction or deadlock we write δ.
For parallel composition we have the merge  which interleaves and/or synchronises multiactions. A communication operator Γ allows explicit spec- ification of (two or more) actions that communicate with each other (e.g. Γ{a|b→c}(⟨a, b, b⟩+⟨a⟩), meaning that a and b communicate to c in ⟨a, b, b⟩+⟨a⟩, is equivalent to ⟨c, b⟩ + ⟨a⟩).
To limit the behaviour of a process, it has been common to define which actions are not allowed. However, the number of multiactions we want to pro- hibit can increase exponentially with the number of parallel processes; putting n actions in parallel results in 2n − 1 different multiactions. Therefore we added a restriction operator ∇ that specifies precisely which multiactions are allowed, by a set V of action sequences (e.g. V = {a} or V = {b|c|c, d, c|e}). If one wishes that in the parallel composition of a,b and c action a does not execute synchronised with another action and b and c must synchronise, one can write ∇{a,b|c}(a  b  c), which behaves as a · ⟨b, c⟩ + ⟨b, c⟩· a.
The blocking operator ∂H (commonly referred to as encapsulation opera- tor) prohibits actions in its set parameter H from executing (e.g. ∂{a}(a + b · ⟨a, c⟩), which behaves as b · δ), the hiding operator τI makes actions in I invisible (e.g. τ{a}(⟨a, b⟩) becomes ⟨b⟩) and the renaming operator ρ renames actions (e.g. ρ{a→b}(a) becomes b). Finally we have process references with which we can write definitions such as P = a · P , which denotes the process that can do infinitely many a actions.
Table 1, where V = {a1| ... |an : a1,..., an ∈ NA} the set of possible action-name combinations, C = {a1| ... |an → b : a1,..., an,b ∈ NA} the set of possible communications and R = {a → b : a, b ∈ NA} the set of all renamings, contains a summary of the above.
Note that this syntax allows one to write sets (R) that can contain elements with the same left hand side (e.g. {a → b, a → c}). This should not be possible as the meaning of these sets are meant to be functions. Therefore we put the restriction on this syntax that in the sets described by R no left hand side of an element may be the same as the left hand side of another.
For the set C a similar restriction holds. Specifically, left hand sides must be disjoint, meaning that {a|b → c, d|b → e} is not allowed as b occurs in both left hand sides. Otherwise communication applied to ⟨a, b, d⟩ could result in either ⟨c, d⟩ or ⟨a, e⟩, which we consider to needlessly complicate the commu- nication (such behaviour can better be explicitly modelled by the user, in our opinion).

Table 1
LoCo Syntax
a, b, c, ...	Single actions (from NA, also ⟨a⟩, ⟨b⟩, .. .)
⟨a⟩, ⟨b, c, d, b⟩, ⟨⟩, ...	Multiactions (containing single actions)
δ	Deadlock/inaction
τ	Silent step (also ⟨⟩)
+	Alternative composition
·	Sequential composition
Merge/Parallel composition
ß	Left merge
|	Synchronisation operator
P , Q, ...	Process references
∇V ( )	Restriction operator (V ⊆ V)
ΓC(  )	Communication operator (C ⊆ C)
∂H( )	Blocking operator (Encapsulation, H ⊆ NA)
τI( )	Hiding operator (I ⊆ NA)
ρR( )	Renaming operator (R ⊆ R)
P =	Process definition (with P a process reference)
Some additional notation is used in this document for ease of reading. Instead of writing the sequence of terms t1, t2,..., tn (e.g.  the actions in a multiaction) we often write t. We also write α, β etc. instead of the multiactions like ⟨a⟩.
Now that we have introduced our syntax, we will have a look at some ex- amples of LoCo processes. Process M = (coin  button) · product · M models a simple vendor machine that waits for a user to insert a coin and press a button (in any order) and then gives a product. This process has the same behaviour as M' = (coin · button + button · coin + ⟨coin, button⟩) · product · M', where the third alternative indicates that it is possible to insert a coin at the same time as pressing the button. Another example is ∇{a,b}(τ{sab }(Γ{sa|sb→sab }(A  B))), with A = a · sa and B = sb · b, which models two separate processes A and B that have to synchronise such that a happens before b. This process has the same behaviour as a · b (in branching bisimulation semantics [25]).
Operational Semantics
For the definition of the semantics of LoCo we need some auxiliary notation (for precise definitions, see [28]). First of all, we will use the set of all multiac- tions A = {⟨a⟩ : a ∈ A} and we use | to combine multiactions (i.e. ⟨a⟩|⟨b⟩

is just ⟨a, b⟩). To be able to reason about terms of our language, we introduce some sets and notations. The set VP , with elements x, y,.. ., consists of pro- cess variables. For the set of LoCo terms (described by) TP we have elements t, u, ... and process-closed terms p, q, . . . in Tpc (terms that do not have any process variables or references in them).
In Table 2 we give the operational semantics of LoCo. We use the standard transition relations −→ and −→ C, and assume we have a set E containing process definitions. Note that the semantics of the operators ∇V , ΓC, ∂H, τI and ρR is given separately.
Table 2
LoCo Semantics

	


t −α→ C
⟨a⟩
a −→ C
t −α→ t'
α −α→ C
⟨⟩
τ −→ C
α	α

α	α	 t −→ C 
t −→ t'

t + u −→ C
u + t −α→ C
t −α→ C
t + u −→ t'
u + t −α→ t'
t −α→ t'
t · u −α→ u

α


t · u −α→ t' · u

α

α	α	 t −→ C 
t −→ t'

u −→ u
t −α→ u
u −→ t'	u
t −α→ u	t'
tßu −α→ u


tßu −α→ t'	u


t −α→ C,u −β→ C
t −α→ C,u −β→ u'

t −α→ t',u −β→ u'

α|β
t	u −→ C
α|β
u −→ u
α|β
t −→ u
α|β
t	u −→

t'	u'


t −α→ C,u −β→ C
t −α→ C,u −β→ u'

t −α→ t',u −β→ u'

α|β
t|u −→ C
α|β
t|u −→ u
α|β
u|t −→ u
α|β
t|u −→

t'	u'

t −α→ C
α	P = t ∈ E P −→ C
t −α→ t'
P −α→ t' P = t ∈ E

The definition of the operators ∇V , ΓC, ∂H, τI and ρR in the semantics requires some functions that perform the needed transformations or checks on multiactions. To start with the blocking operator ∂H, we need to test whether or not an action in H occurs in a multiaction. We do this by converting such a multiaction α to a set α{} (i.e. if α is ⟨a, b, c, c⟩, then α{} will be {a, b, c}) and then taking the intersection of α{} and H, which gives all actions that occur in both α and H.
Restriction operator ∇V needs to check whether or not a given multiaction occurs in its set V (or is τ or ⟨⟩, which is always allowed). Because the set

V does not contain multiactions but action sequences of the form a|a|b, we convert V to V⟨⟩, which is defined by {⟨a1,..., an⟩ : a1| ... |an ∈ V }.
To apply renaming, defined by R in ρR, to a multiaction α, we write R • α. For example, if we apply R = {a → b, b → a} to ⟨a, b, b, c⟩, we get R • ⟨a, b, b, c⟩ = ⟨R(a), R(b), R(b), R(c)⟩ = ⟨b, a, a, c⟩.
With hiding τI, we need to remove all actions in I from multiactions. We introduce a special function θI for this purpose. Thus, θ{a,b}(⟨d, a, b, a, c⟩) would result in ⟨d, c⟩ and θ{a}(⟨a, a⟩) in ⟨⟩ (or τ ).
For the communication operator we need a somewhat more complex def- inition. We introduce a communication function γC that takes a multiaction and finds all occurrences of left hand sides in C and replaces those occurrences with the corresponding right hand side. To be somewhat more precise (note that we implicitly use the commutativity of bags in this definition):
γC(⟨a1,..., an⟩|α)	=	⟨c⟩|γC(α)	if a1| ... |an → c ∈ C
γC(α)	=	α	if there is no such a1,..., an
So, if C is {a|b → a, c|c|d → b}, then γC(⟨a, a, a, b, b, c, c, d⟩) results in
⟨a, a, a, b⟩. Note that the extra condition on C (discussed in Section 2) is required to make γ a true function. That is, γC(α) is a unique multiaction, which follows from the fact that if an action can participate in two possible communications, then these have to be equivalent due to the restriction on C (e.g. a can communicate with the first or the second b of ⟨a, b, b⟩, but either way the effect is the same).
With these auxiliary functions the semantics of LoCo is completed with the rules from Table 3.


t −α→ C
Table 3
LoCo Semantics (continued)
t −α→ t'

α	α ∈ V⟨⟩ ∪ {⟨⟩}
∇V (t) −→ C
t −α→ C

∇ (t) −α→ ∇
t −α→ t'
(t') α ∈ V⟨⟩ ∪ {⟨⟩}

Γ (t) γC (α) C
Γ (t) γC (α) Γ
(t')

t −α→ C
α	α{} ∩ H = ∅
∂H(t) −→ C
t −α→ C

t −α→ t'
∂ (t) −α→ ∂ t −α→ t'
(t') α{} ∩ H = ∅

τ (t) θI (α) C	τ (t) θI (α) τ (t')
I	−→	I	−→ I

t −α→ C
ρ (t) −R→•α C
t −α→ t'
ρ (t) −R→•α ρ (t')

To be able to compare and calculate with processes, we need to know when two processes are equal (i.e. have the same behaviour). We therefore use the default notion of (strong) bisimilarity [20,24] and write LoCo ▶ p↔q (or just p↔q) to denote that p and q are (strongly) bisimilar. And as the rules in Table 2 and Table 3 are in the path format [5], we have that bisimulation ↔ is a congruence with respect to all operators.

Axioms
We introduce the axiomatisation in Table 4 for the semantics given in the previous section. The axioms allow for more straightforward reasoning in certain cases. It also shows that LoCo has a reasonably elegant algebraic structure similar to those of other process algebras.
Table 4
LoCo Axioms

MA1
MA2
.
a = ⟨a⟩	VD	∇V
. ⟨⟩	V 1	∇V
.
(δ) = δ
.

∈ V(⟩ ∪ {⟨⟩}

τ =	.
(α) = α  if α

MA3	⟨a, b⟩ = ⟨b, a⟩	V 2	∇V
.
(α) = δ . if α
/∈ V(⟩ ∪ {⟨⟩}

.	V 3	∇V (x + y) = ∇V (x)+ ∇V (y)

A1	x + y = y + x	V 4	∇ (x ·
.
x + (y + z) = (x + y)+ z
.
y) = ∇V (x) · ∇V (y)

.
A3	x + x = x .
.
∂H (δ) = δ

A4	(x + y) · z = x · z + y · z	D 1
.
.
∂H (α) = α  if α
{} ∩ H = ∅

A5	(x · y) · z = x · (y · z)	D 2
.
.
∂H (α) = δ . if α
{} ∩ H /= ∅

A6	x + δ = x	D 3	∂H (x + y) = ∂H (x)+ ∂H (y)

A7	δ ·
.
x = δ
D 4	∂H (x ·
.
y) = ∂H
(x)
· ∂H (y)

CM 1	x 	.	|y	TID	I	.
CM 2	δ	.	δ · x	TI 1	I	.  I
CM 3	αδ ·	.	δ · (x  y)	TI 3	I	.  I	I

CM 4	.
TI 4	τI (x ·	.  I
· τI (y)

CM 5	(αδ · x)| δ .	δ|βδ) · x

β
CM 6	αδ|(βδ ·
= (α
.
δ|βδ) · x	RD	R	.

x) = (α .
CM 7	(αδ · x)|(βδ · y) = (αδ|βδ) · (x  y)	R1
ρ (δ) = δ
.
R	• α

.	ρ (α) = R.
CM 8	(x + y)|z = x|z + y|z	R3	ρR(x + y) = ρR(x)+ ρR(y)

CM 9	x|
.  |y + x|z	R4	ρR(x ·
.  R	· ρR(y)

(y + z) = x
CM 10	⟨a⟩|⟨b⟩ . ⟨a, b⟩
.
y) = ρ
.
Γ (δ) = δ
(x)

CD 1	δ|αδ
= δ	G 1
.
.
ΓC (α) = γC.(α)

CD 2	αδ|δ = δ	G 3	ΓC (x + y) = ΓC (x)+ ΓC (y)
G 4	ΓC (x ·	.	C	· ΓC (y)
y) =Γ (x)
With a, b ∈ NA, α, β ∈ A, αδ, βδ ∈ A ∪ {δ} and x, y ∈ VP .
If we can derive q from p with the axioms (in the ordinary equational sense),
we write LoCo ▶ p . q (or just p . q). And if we do so, we obviously want
the same to hold for bisimulation, which is stated in the following theorem.
Theorem 4.1 Let p, q ∈ Tpc.	The axiomatisation of LoCo is sound with
respect to strong bisimulation (i.e. LoCo ▶ p . q ⇒ LoCo ▶ p↔q).

Proof. This proof is very straightforward and therefore not given here. How- ever, it can be found in [28].
The other way around is also a desired property.
Theorem 4.2 Let p, q ∈ Tpc. The axiomatisation of LoCo is complete with
respect to strong bisimulation (i.e. LoCo ▶ p↔q ⇒ LoCo ▶ p . q).
Proof. The full proof can be found in [28].
Because we also wish to use recursive processes, we will (at least) need some
.extension to the axioms given in Table 4. We extend	with the following
rule:
P = t ∈ E

.
= t
From the rules for process definitions in Section 3 the soundness of this rule clearly follows.

Abstraction
If we want τ (or empty multiset ⟨⟩) to bea “real” silent step, we want to be able to remove τ where its presence cannot be determined. Due to the nature of multiactions, it is already the case that if τ is synchronised with (i.e. executed at the same time as) some action α, the τ “disappears” (applying axiom MA2 to τ |α gives ⟨⟩|α and with CM 10 we get just α). A multiaction is not just a multiset of actions, but a multiset of observable actions. There is always the possibility that unobservable actions happen at the same time. Note that this behaviour of the synchronisation operator is not to be confused with the behaviour of the communication operator in, for example, ACP, which would deadlock (because τ cannot communicate). Also note that this behaviour is the same as seen in, for example, the Petri Box Calculus and similar to that in SCCS (apart from the different interpretation of this multiaction identity). However, this is not the only place where we wish to hide these silent steps. In these cases, strong bisimulation is no longer suitable and we will use (rooted) branching bisimulation [25,26]. For this form of equivalence, we also need a matching (i.e. sound and complete) axiomatisation. Fortunately, the axioms given before are still sound, but to make the axiomatisation complete again (i.e. to have axioms that reflect the behaviour of τ ) it is sufficient to
add the following two axioms, as in [12].

T 1	x · τ . x

T 2	x · (τ · (y + z)+ y) .
x · (y + z)

Theorem 5.1 The axiomatisation of LoCo is sound with respect to (rooted) branching bisimulation.
Proof. In [28] one can find the soundness proofs of the axioms T 1 and T 2. The other axioms of LoCo, which have already been proven to be sound with respect to ↔, do not need to be proven again, as ↔ ⊂ ↔rb holds.
Theorem 5.2 The axiomatisation of LoCo is complete with respect to rooted branching bisimulation.
Proof. The proof is similar to that in [12].
Data
In many systems, data plays an essential role and is therefore a neces- sity for any practical language. We add data by adding parameters to ac- tions. So, instead of actions a, b etc. we now also have actions like a(1), b(true, [c0, c1(1, 2), c0]) and b(4, error ). The precise data expressions that are allowed as parameters are defined by a data algebra A. All we need to know about it is that it contains a number of data types, one of which is the boolean type (with the default constants (t, f ) and operators). Detailed requirements
are given in [27], as well as a more detailed definition of syntax and semantics with data.
We also need the summation Σ	p, the conditional operator b → p and

data parameters for process references. The behaviour of
d:D p is the same

as the alternative composition of all p[e/d] (i.e.  p with every unbounded
occurrence of d replaced by e), for each e in data type D. Conditional b → p behaves as p or deadlock if the boolean condition b is equivalent to t or f , respectively. With process references with data we can write definitions

such as P (n : N)= Σ
m:N
m < n → a(m), meaning that, for example, process

reference P (5) is equivalent to a(0) + a(1) + a(2) + a(3) + a(4).
In short, the extensions to our syntax is as follows:
a(.. .), b(.. .), ...	Single action with data parameters

d:D
Summation over variable d of type D

→	Conditional operator
P (.. .), Q(.. .), ...	Process references with data parameters
P (d : D,.. .)=	Process definition with parameters

These extensions must also be reflected in the semantics and axioms. Because of the fact that actions can now have data parameters, the semantics of oper- ators ∇V , ∂H, τI and ρR must be reformulated such that data will not affect their behaviour (i.e. data is ignored). For the communication function we will only mention that, with data, we wish actions can only communicate if, and only if, they have equivalent parameters. Also, the rules for single actions and process references must be extended to include data parameters. As these changes are rather trivial, we will not give them here.
The additional rules and axioms are as given in Table 5 and Table 6. Note that we assume to have capture avoiding substitution and alpha conversion in
.
=.
Table 5
Additional LoCo Semantics for Data

t −α→ C
α	A ▶ b
b → t −→ C

t[e/d] −α→ C
t −α→ t'
b → t −α→ t' A ▶ b

t[e/d] −α→ t'


d:D
α	e ∈ D
t −→ C

d:D
t −α→ t' e ∈ D



Table 6
Extra LoCo Axioms for Data
.	P	.

C1	t → x = x	SUM1
C2	f → x . δ	SUM3
Pd:D x = Px
p + p[e/d] with e ∈ D

P	. P
Pd:D	d:.DP	P

V6	∇V (P d:D p) =P d:D ∇V (p) SUM4
Pd:D (p + q) =P d:D p +
d:D q

D6	∂H (
.	∂H (p)	SUM5	(
p) ·	.
(p · y)

P d:D p) =P d:D
Pd:D
y =P d:D

TI6	τI (
Pd:D
.
p) = Pd:D
τI (p)	SUM6	(
.
Pd:D p)ßy =P d:D
(pßy)

R6	ρR(
p) .
ρR(p)	SUM7	(
p)| .
(p|y)

G6	ΓC (
=
Pd:D	Pd:D
ΓC (p)	SUM7 '	x|(
y =
Pd:D	Pd:D
(x|q)

d:D p) =
d:D
d:D q) =
d:D

With x, y ∈ VP and p, q ∈ Tpc.

Of course, also with these extensions we want to have a sound and complete axiomatisation, as stated in the following theorems. Note that the complete- ness of the axiomatisation now depends on the completeness of derivability in the data algebra A. As we do not explicitly consider this algebra, we say that our axiomatisation is relatively complete. This means that it is complete if we have completeness of derivability in A.
Theorem 6.1 The axiomatisation of LoCo with data is sound with respect to (rooted) branching bisimulation.
Proof. This proof is very straightforward and therefore not given here. How- ever, it can be found in [27].

Theorem 6.2 The axiomatisation of LoCo with data (without T 1 and T 2) is relatively complete with respect to strong bisimulation.
Proof. This proof is similar to completeness proof in [18]. Also, the full proof can be found in [27].
Theorem 6.3 The axiomatisation of LoCo with data is relatively complete with respect to rooted branching bisimulation.
Proof. The proof is similar to that in [12].
Examples
To illustrate the use of LoCo, we look at the following examples.
Petri net
The (coloured) Petri net in Figure 2 describes a little system that takes to- kens (natural numbers) from place P1 one at a time, performs a calculation on the token, and places it in P4. We verify this behaviour by considering an interpretation of this Petri net in LoCo. We assume a true concurrency semantics for the Petri net. Although an interleaving semantics would make no difference here due to the structure of the example, the translation to LoCo itself does not put this restriction on the system.





P4








Fig. 2. A simple Petri net
Places are modelled by recursive processes parameterised with the contents of such a place. For places P1, P2, P3 and P4 this is a bag of natural numbers and for place Q a bag of  (with  = {1}). Transitions are modelled by recur- sive processes without parameters (as transitions are memoryless) consisting of a single multiaction. Actions rx and sx are used to model the receiving respectively sending of a token by a place or transition X. These actions correspond to the incoming and outgoing arrows, respectively. If there are

two such incoming or outgoing arrows, the actions are labelled with the cor- responding number from Figure 2. Thus transition Enter has an action r1
with which he can receive a token from place P1
The whole system is a parallel composition of the places and transitions enclosed by communication (modelling the links between places and transi- tions), hiding and restriction. Note that places P1 and P4 are enclosed by a blocking operator because they do not have an incoming or outgoing link, respectively. Also note that the behaviour of places is somewhat restricted here for simplicity; normally it would be possible to atomically take several tokens from one place, as well as putting new ones in it.

Pi(b : Bag (N))	=	Σ

n:N
rpi (n) · Pi(b ∪ {n})+ 
n ∈ b → spi (n) · Pi(b \ {n})

Q(b : Bag ())	=	Σ 

i: 
rq(i) · Q(b ∪ {i})+ 
(i ∈ b) → sq(i) · Q(b \ {i})

Enter	=	Σ

n:N
1
enter
2
enter
(1)|senter (n) · Enter

Calc	=	Σ

n:N
rcalc(n)|scalc(f (n)) · Calc

Exit	=	Σ
rexit (n)|s1  (n)|s2  (1) · Exit

PN (in : Bag (N), out : Bag (N)) =
∇{}(τ{c}(Γ{sp |r1



→c, sq|r2



→c, senter |rp →c,

1  enter	enter	2

sp |rcalc→c, scalc|rp →c, sp |rexit →c, s1
|rp →c, s2
|rq→c}(

2	3	3
exit	4
exit

∂{rp }(P1(in))  P2(∅)  P3(∅)  ∂{sp }(P4(out )) 
Q({1})  Enter  Calc  Exit))))
With basic expansion of the parallel operators and application of communica- tion, hiding and restriction, we get the following result.
PN (in : Bag (N), out : Bag (N	.

)) =
n:Nat
n ∈ in → τ · PN (in \ {n}, out ∪ {f (n)})

As one can see, and could have expected, the behaviour of the system is the same as that of places P1 and P4 connected by transition Calc, which simply takes a number n from P1 and puts f (n) in P4.
Components
In Figure 3, a system C, which checks whether components S1 and S2 return the same result for a given input, is depicted. Both components S1 and S2 take

an integer as input and return an integer as output. For computation they use components Mul and Plus, that multiply and add two integers, respectively. In addition, S1 also uses One, that can always return a 1 on its output. Component Cmp takes two integers and returns t if they are equal (and f otherwise). Note that all computations occur instantaneous; a component produces output at the same time it takes it input.

Fig. 3. A simple compositional system
All components are straightforwardly implemented as follows. Incoming arrows of a component X correspond to actions rX and outgoing arrows cor- respond to actions sX. If a component has more that one of such actions, then they are numbered from top to bottom as seen in Figure 3. Note that the individual components’ specifications are completely self contained.
One	=	sone (1) · One
Mul	=	P	P	r1  (x)|r2  (y)|smul (x ∗ y) · Mul

Plus	=
Px:Z Py:Z
mul
r1
mul
|r2
|splus (x + y) · Plus

x:Z	y:Z
plus
plus

S1	=	∇{rs1 |ss1 }(ρ{smul →ss1 }(τ{c}(Γ{r1
One	Plus	Mul ))))
1
plus
→rs1 , sone |r2
→c, splus |r2
→c}(

S2	=	∇{rs2 |ss2 }(ρ{splus →ss2 }τ{c}(Γ{r1
|r2
|r2
→rs2 , smul |r1
→c}(Mul  Plus))))

P	P	1	2
mul
mul
plus
plus

Cmp	=
x:Z
y:Z rcmp(x)|rcmp(y)|scmp(x = y) · Cmp

C	=	∇{rc|sc}(ρ{scmp →sc}(τ{c}(Γ{rs  |rs  →rc, smul |r1
→c, splus |r2
→c}(S1  S2  Cmp))))

1  2	cmp
cmp

We can derive the following for S1, S2 and C.

.
S1	=
Σ	rs (x)|ss (x ∗ (x + 1)) · S1

.
S2	=
x:Z
rs2
(x)|ss2
(x ∗ x + x) · S2

.
=	x:Z
rc(x)|scmp(t) · C

It is not possible to simple move the communication operators to the top level as would be required in language that have global communication instead

of local communication. If one would do so, it is impossible for, say, component One to know that he is communicating with the right Plus component. At least one instance of both the Plus and Mul components need to be changed to avoid conflicts in action names.
Although in this example the consequences of global communication are not extremely problematic, with bigger systems this becomes quite bother- some. Also, components S1 and S2 are typically developed independently. This means that one has to change the internals of S1 and S2 in order to use them safely in one system with global communication. It is clear that this is contrary to the ideas of component-based modelling.
Conclusion
We have introduced the process algebra LoCo that is truly compositional due to its local communication operator and the use of multiactions. It has a formal syntax, semantics and a sound and complete axiomatisation. We have included two small examples to illustrate the compositionality of LoCo and the ease with which Petri nets can be modelled in it.
As this work is mainly a basis for the mCRL2 language, future work will be continued in this context. This includes the addition of time, formal trans- lations of Petri nets to mCRL2 and adapting existing proof techniques (such as those used with μCRL, for example) to the new setting.

References
Austry, D. and G. Boudol, Alg`ebre de processus et synchronisation, Theoretical Computer Science 30 (1984), pp. 91–131.
Baeten, J. and A. Basten, Partial-order process algebra (and its relation to Petri nets), in:
J. Bergstra, A. Ponse and S. Smolka, editors, Handbook of Process Algebra, Elsevier, 2001 pp. 769–872.
Baeten, J. and J. Bergstra, Non interleaving process algebra, in: E. Best, editor, Proceedings of the 4th International Conference on Concurrency Theory (CONCUR ’93), Lecture Notes in Computer Science 715 (1993), pp. 308–323.
Baeten, J. and W. Weijland, “Process Algebra,” Cambridge Tracts in Theoretical Computer Science 18, Cambrdige University Press, 1990.
Baeten, J. C. M. and C. Verhoef, A congruence theorem for structured operational semantics with predicates, in: E. Best, editor, Proceedings of the 4th International Conference on Concurrency Theory (CONCUR ’93), Lecture Notes in Computer Science 715 (1993), pp. 477–492.
Bernardo, M., P. Ciancarini and L. Donatiello, Architecting families of software systems with process algebras, ACM Trans. Softw. Eng. Methodol. 11 (2002), pp. 386–426.
Best, E., R. Devillers and J. G. Hall, The box calculus: a new causal algebra with multi- label communication, in: G. Rozenberg, editor, Advances in Petri Nets: The DEMON Project, Lecture Notes in Computer Science 609 (1992), pp. 21–69.

Best, E., R. Devillers and M. Koutny, “Petri net algebra,” Springer-Verlag New York, Inc., New York, NY, USA, 2001.
Best, E., R. Devillers and M. Koutny, A uniﬁed model for nets and process algebra, in:
J. Bergstra, A. Ponse and S. Smolka, editors, Handbook of Process Algebra, Elsevier, 2001
pp. 873–944.
Bracciali, A., A. Brogi and F. Turini, A framework for specifying and verifying the behaviour of open systems, Journal of Logic an Algebraic Programming 63 (2005), pp. 215–240.
Cuesta, C. E., P. de la Fuente, M. Barrio-Sol´orzano and M. E. Beato, An “abstract process” approach to algebraic dynamic architecture description, Journal of Logic an Algebraic Programming 63 (2005), pp. 177–214.
Groote, J. and S. Luttik, A complete axiomatisation of branching bisimulation for process algebras with alternative quantiﬁcation over data, Technical Report SEN-R9830, Centrum voor Wiskunde en Informatica (CWI) (1998).
Groote, J., A. Mathijssen, M. van Weerdenburg and Y. Usenko, From μCRL to mCRL2: Motivation and outline, in: L. Aceto and A. D. Gordon, editors, Proceedings of the Workshop Essays on Algebraic Process Calculi (APC 25), Electronic Notes in Theoretical Computer Science 162, 2006, pp. 191–196.
Groote, J. and A. Ponse, The syntax and semantics of μCRL, in: A. Ponse, C. Verhoef and
S. van Vlijmen, editors, Algebra of Communicating Processes, Workshops in Computing, 1994,
pp. 26–62.
Groote, J. F., A. Mathijssen, M. Reniers, Y. Usenko and M. van Weerdenburg, The formal speciﬁcation language mcrl2, in: E. Brinksma, D. Harel, A. Mader, P. Stevens and R. Wieringa, editors, Methods for Modelling Software Systems (MMOSS), number 06351 in Dagstuhl Seminar Proceedings, 2007.
ISO, ISO 8807: Information processing systems – open systems interconnection – LOTOS – a formal description technique based on the temporal ordering of observational behaviour, Standard, International Standards Organization, Geneva, Switzerland (1987), first edition.
Jensen, K., “Coloured Petri nets: basic concepts, analysis methods and practical use, vol. 2,” Springer-Verlag, 1995.
Luttik, B., “Choice Quantification in Process Algebra,” Ph.D. thesis, University of Amsterdam (2002).
Mauw, S. and M. Reniers, A process algebra for interworkings, in: J. Bergstra, A. Ponse and
S. Smolka, editors, Handbook of Process Algebra, Elsevier, Amsterdam, 2001 pp. 1269–1327.
Milner, R., “A Calculus of Communicating Systems,” Springer-Verlag New York, Inc., 1982.
Milner, R., Calculi for synchrony and asynchrony, Theoretical Computer Science 25 (1983),
pp. 267–310.
Milner, R., “Communicating and mobile systems: the π-calculus,” Cambridge University Press, 1999.
Norton, B., G. Lu¨ttgen and M. Mendler, A compositional semantic theory for synchronous component-based design., in: R. M. Amadio and D. Lugiez, editors, CONCUR 2003 - Concurrency Theory, 14th International Conference, Lecture Notes in Computer Science, 2003,
pp. 453–467.
Park, D., Concurrency and automata on inﬁnite sequences, in: P. Deussen, editor, Proceedings of the 5th GI-Conference on Theoretical Computer Science, Lecture Notes in Computer Science 104 (1981), pp. 167–183.
van Glabbeek, R. J., The linear time- branching time spectrum II, in: E. Best, editor, CONCUR ’93: Proceedings of the 4th International Conference on Concurrency Theory, Lecture Notes in Computer Science 715 (1993), pp. 66–81.

van Glabbeek, R. J. and W. P. Weijland, Branching time and abstraction in bisimulation semantics, J. ACM 43 (1996), pp. 555–600.
van Weerdenburg, M., “GenSpect Process Algebra,” Master’s thesis, Eindhoven University of Technology (2004).
van Weerdenburg, M., Process algebra with local communication, Technical Report 05/05, Eindhoven University of Technology (2005).
