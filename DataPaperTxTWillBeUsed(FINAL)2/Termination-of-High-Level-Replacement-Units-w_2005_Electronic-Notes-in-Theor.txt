Electronic Notes in Theoretical Computer Science 127 (2005) 71–86  
www.elsevier.com/locate/entcs


Termination of High-Level Replacement Units with Application to Model Transformation *

Paolo Bottonia,1	Manuel Kochb,2	Francesco Parisi-Presiccea,d,3 Gabriele Taentzerc,4
a
Universit`a di Roma “La Sapienza” - Italy
b
Freie Universit¨at Berlin - Germany
c
Technische Universit¨at Berlin - Germany
d
George Mason University - USA


Abstract
Visual rewriting techniques, in particular graph transformations, are increasingly used to model transformations of systems specified through diagrammatic sentences. Several rewriting models have been proposed, differing in the expressivity of the types of rules and in the complexity of the rewriting mechanism; yet basic results concerning the formal properties of these models are still missing for many of them. In this paper, we propose a contribution towards solving the termination problem for rewriting systems with external control mechanisms. In particular, we obtain results of more general validity by extending the concept of transformation unit to high-level replacement systems, a generalization of graph transformation systems. For high-level replacement units, we state and prove several abstract properties based on termination criteria. Then, we instantiate the high-level replacement systems by attributed graph transformation systems and present concrete termination criteria. These are used to show the termination of some replacement units needed to express model transformations as a consequence of software refactoring.
Keywords: Transformation units, graph transformation, termination, refactoring.



  Research partially supported by the European Community under RTN Segravis
1 Email: bottoni@di.uniroma1.it
2 Email: mkoch@inf.fu-berlin.de
3 Email: fparisi@ise.gmu.edu
4 Email: gabi@cs.tu-berlin.de



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.08.048


Visual rewriting techniques are increasingly used to model transformations of systems specified through diagrammatic sentences. Researchers are moving from the specification of static aspects of languages (defined through parsing processes) to the modelling of their dynamics. Graph transformations, in particular, are a widespread formalism with applications to parsing, model animation or transformation. Moreover, a whole new wealth of problems, such as software or model evolution [17,15,3,14] arises from the diffusion of UML as a tool for the specification of both software and general systems.
When specifying such transformations, it is hardly the case that a single, unstructured, diagram rewriting system is used to define complex transforma- tions. A typical problem is to steer the progress of the transformation towards some well-defined configuration of the diagram, i.e. state of the system. This may involve the definition of some sequence of rule applications, as well as the prevention of repeated application of a same rule to the same match, or of cyclic repetitions of the same sequence of applications.
In general, guaranteeing such properties of the rewriting process is equiva- lent to proving its termination, an undecidable problem in its uniform version [16], but which can be studied for individual rewriting systems, following the classical approach of proving termination by constructing a monotone mea- sure function on some multiset, and showing that the value of such a function decreases at each application, as introduced by Dershowitz and Manna in [6]. This problem is further complicated by the need for rule expressivity. In- deed, there is always a trade-off between the inherent expressivity (and com- plexity) of the rewriting relation for a single step and the availability of ex- ternal control mechanisms steering the rewriting process. Although a number of rewriting models have been proposed, differing in the expressivity of the types of rules and in the complexity of the rewriting mechanism, basic results concerning the formal properties of these models are still missing for many of them. The combination of attributed rules and transformation units employ- ing rule expressions seems to provide a transformation approach which can already be used practically, but which is simple enough for formal reasoning. In this paper we first study a more abstract version of attributed rules, namely high-level replacement systems [9], to which we extend the notion of transformation unit [13]. We thus obtain an abstract property that a function has to satisfy in order to be used as a termination criterion for such units. In particular, Section 2 introduces related work, while Section 3 adapts the con- cept of transformation units to define high-level replacement units. In Section 4, a motivating example from software transformation, namely refactoring, is


presented. Section 5 discusses termination criteria for high-level replacement systems and shows some concrete termination results. These are illustrated by presenting some sample transformations in which replacement units are used to specify transformations of UML models consequent to software refactoring. Finally, conclusions are given in Section 6.

Related work
Transformation units have been introduced by Kreowski and Kuske in [13] and extensively used for several types of visual transformations since. Ku¨ster et al. have considered the role of transformation units in defining transfor- mations of UML models [14]. In particular, they have studied the problem of termination and confluence. Recognising, as demonstrated by Plump in [16], that termination of graph rewriting is undecidable in general, they provide some intuitive consideration on the causes for termination or non-termination of transformation units iterating as long as possible the use of some given rules. However, they do not present results on the iteration of sequences of rules, for which we provide some termination criteria here. Termination crite- ria for graph transformation have already been considered by Aßmann [1], who sticks to a concrete set of criteria and has not developed a general approach to termination based on criteria, as we will do in this paper.
The combined use of negative application conditions, set nodes, and con- trol expressions for the management of visual transformation processes has been proposed in several occasions. In [5], layering conditions were applied to ensure termination of parsing processes. We can observe how the general problem of proving termination of a given transformation unit is equivalent to introducing some form of local layering, so that the conditions on elimina- tion or insertion of elements in the diagram proceed in accordance with the decrease or increase of the adopted monotone function. It is to be considered, however, that, rather than in parsing processes, we are interested here in gen- eral types of transformations. Such a situation has also been considered in [2], where transformation units were employed to define a semantics for OCL.

High-Level Replacement Units
High-Level Replacement Systems [9,7] are an instantiation of the general graph transformation approach, at the basis of the definition of transformation units [13]. The resulting notion is called high-level replacement unit. Its semantics is given by the set of all possible derivation sequences. Thereafter, high-level replacement units are instantiated by attributed graph transformation.

High-Level Replacement Units
Let CAT be a category with one distinguished class M of morphisms.

Definition 3.1 [rule] A rule p : L ←l
I →r
R is given by two morphisms l and

r of M . Let L(p) be the left-hand side and R(p) the right-hand side of rule p.
A transformation unit controls the rule application by a set of control conditions specified by expressions over rule names.
Definition 3.2 [control expressions] The class C of control expressions over
N ames (representing a set of rule names) is recursively defined by
N ames ⊆ C,
C1; C2 ∈ C, if C1, C2 ∈ C, and
asLongAsPossible C end ∈ C, if C ∈ C.
The intended meaning of the operator asLongAsPossible C is the (se- quential) application of the expression C as long as its application is possible.
Definition 3.3 [High-level replacement unit] A high-level replacement unit RU = (P, name, C) in a category CAT , or just replacement unit, consists of a finite set P of rules, a bijective function name : P → N ames, and a control expression C ∈ C over N ames.
High-level replacement units are units in the sense of [13]: we have a graph transformation approach consisting of the class of objects in CAT , the class of rules in this category, the application operator as defined in Definition 3.4, a class of control expressions as defined in Definition 3.2 and a class of graph class expressions being the class of objects in CAT itself. A replacement unit is a transformation unit with objects of CAT as initial and terminal graphs. Moreover, the set of imported units for a high-level replacement unit is always empty. In contrast to transformation units, the semantics of high- level replacement units is defined by derivation sets.
Definition 3.4 [match and direct derivation] Given an object G and a rule

p : L ←l
I →r
R, a match of p to G is a morphism m : L → G. A direct

derivation d from G to H by p and match m, d : G ⇒p,m H, is given by a double pushout (see Figure 1). start and end are two projections from direct derivations to objects such that start(d)= G and end(d)= H. A derivation id : G ⇒pid,m G, is called identical. Given a set P of rules, Der(P )= {G ⇒p,m H|G, H ∈ Obj(CAT ) ∧ p ∈ P } is the set of all direct derivations with rule set P .


L ¸,l	 I   r  R 
m	(1)	(2)
J	J	J 
G ¸,  D 	 H 
g	h
Fig. 1. The double-pushout approach

Definition 3.5 [derivation sequence] Given a set P of rules, a derivation se- quence on P is defined by a function s : N → Der(P ) with start(s(i + 1)) = end(s(i)) for i ≥ 0. The length of a derivation sequence s is n if s(i) is the identity derivation ∀i > n, and end(s(n)) is called the derivation result. The concatenation s ◦ t of two derivation sequences s – of length m – and t – such that start(t(0)) = end(s(m)) – is the derivation sequence u with u(i) = s(i) for 0 ≤ i ≤ m and u(m + i)= t(i − 1) for 0 < i.
Remark. If t has length n, then the concatenation is finite and u(m + i) = 
t(i − 1) for 0 < i ≤ n.
Definition 3.6 [derivation subsequence] A derivation sequence d1 is a sub- sequence of the derivation sequence d2 (d1 ≤ d2), if there exists a derivation sequence d3 such that d1 ◦ d3 = d2. One sees that ≤ is a partial order.
Definition 3.7 [derivation sets] A derivation set der consists of a number of derivations. If all derivations in der start at object G it is also called derG. The concatenation of two derivation sets der1 and der2 is given by der1 ◦ der2 = {d1 ◦ d2|d1 ∈ der1, d2 ∈ der2}. The product dern is defined by dern−1 ◦ der for n ∈ N . der0 is the empty set. The star product der∗ is defined

i≥0
deri.

Definition 3.8 [derived rule] Given a direct derivation d : G ⇒r,m H by a

double pushout as in Definition 3.4, the derived rule is pd
g
: G ←
D →h  H.

Given two finite derivation sequences d1 : G ⇒∗ H and d2 : H ⇒∗ K with

their derived rules pd1
g
: G ← D1
→h1
h2
H and pd2 : H
D →k
K, the derived

g◦c1	k◦c2
rule of d = d ◦ d  is defined by p  : G	D → K where c  and c
are the

1	2	d	←	1	2
pullback of h1 and h2.
Definition 3.9 [semantics of control expression] Given an object G and a replacement unit RU = (P, name, C), the semantics of RU applied to G is the set der(C)G of all possible derivation sequences starting at G and applying rules of P according to C.
C = name(p): der(C)G = {d ∈ Der({p})|start(d)= G},
C = C1; C2: der(C)G =  {der(C1)G ◦ der(C2)H | H = end(d1), d1 ∈
der(C1)G},



C =asLongAsPossible C' end: der(C)G = {d ∈ der(C')∗
| d is maxi-

mal in der(C')∗
wrt. ≤}

Coeherently with this semantics, we consider that a replacement unit of type name(p) fails if p is not applicable, C1; C2 fails if either C1 or C2 fails, as- LongAsPossible C' end fails if C' fails and it is not of the form name(p); C'' or if C' is of this form and C'' fails. Due to the transactional nature of the units, failure restores the situation prior to its attempted application.

Instantiation by attributed graph transformation
In the following, we present attributed graph structures as defined in [10]. For the category of attributed graph structures and homomorphisms with a distinguished class M of morphisms, the Church-Rosser, Parallelism and Concurrency Theorem have been shown in [10].
Definition 3.10 [category of attributed graph structure signatures] A graph structure signature GSIG = (SG, OPG) is an algebraic signature with unary operations op : s → s' in OPG only. An attributed graph structure signature ASSIG = (GSIG, DSIG) consists of a graph structure signature GSIG and
a data signature DSIG = (SD, OPD) with attribute value sorts S'  ⊆ SD such
that S' = SD ∩ SG and OPD ∩ OPG = ∅. ASSIG is called well-structured if
for each op : s → s' in OPG we have s ∈/ SD.
The category of all ASSIG-algebras and ASSIG-homomorphisms is denoted by ASSIG-Alg . The distinguished class M for ASSIG-Alg is defined by f ∈ M if fGSIG is injective.
Remark: Given an SDSIG-indexed set of variables X = (Xs)s∈SDSIG , all rule objects are attributed by the term algebra TDSIG(X).
Proposition 3.11 (local C-R, parallelism and concurrency) The local Church-Rosser theorems I and II, the parallelism theorem and the concurrency theorem as stated in [9] are valid for each graph transformation system based on ASSIG-Alg.
Proof. See [10].	 

Examples from UML refactoring
In this section we present an example of refactoring from [11], and model the transformations that the model of a system software must go through to be maintained consistent with the modifications in the code. Elsewhere ([4]) we have illustrated how to coordinate transformations occurring in the code –


represented at the level of its abstract syntax – with those occurring in the model, represented by graphs, typed according to the UML metamodel.
In [4], we studied how modifications of the code could affect different com- ponents of the model, typically class and sequence/collaboration diagrams, and we modelled the necessary coordination of the transformations of such representations through transition units defined on hierarchical distributed graph transformations. However, we are now interested in this example only to illustrate the termination problem of replacement units. As distribution does not add causes for non-termination (actually, it possibly reduces them), we discuss here a refactoring involving only modifications in class diagrams.
PullUpVariable(class; attr) moves the variable named attr from sub- classes of class to class. This is used when a variable of the same name with the same type is used throughout all the subclasses of a given class. Previous renamings of such variables may have occurred in order to create the condi- tions for the application of this refactoring. It is important to note that a requirement for this refactoring, as it guarantees behaviour preservation, is that all the subclasses of class own a copy of this variable. Hence, this refac- toring must be performed through the repeated application of a rule which moves the variable from a subclass to its superclass, checking that this oc- curs for all the (direct) subclasses of the class to which the variable has been moved. In order to keep the theory simple, and to avoid using negative ap- plication conditions to check that no subclass has been neglected, we propose an adaptation of the metamodel for class diagrams, to the effect that each class node n is associated with a node of type ClassDescriptor, possessing an attribute which keeps a constantly updated list of the direct subclasses of n.
To this end, we modify the rule for class creation, which does not have preconditions, as shown in Figure 2. Declaring that a class is a subclass of another, or removing the generalisation relation between two classes, produces the effects described by the rules of Figures 3 and 4, respectively. In all the rules discussed in this section, the values of the parameters of the rule, to be matched on concrete instances, are indicated by showing their names in italic, while variables present in the rule, and subject to a unification process, are written with a capitalized initial. In this version of the rules, which do not present negative application conditions, we do not check for the absence of inheritance cycles or of multiple inheritance.
The elimination of a class is accompanied by the destruction of its associate ClassDescriptor node, as shown in Figure 5. As we are using the DPO approach, class elimination is possible only when it has been stripped of all owned features and relations with other classes.


createClass(String class)




Fig. 2. The rule to create a class, associated with the node recording all its subclasses.


insertGeneralization(String parent, String child)



Fig. 3. The rule to insert a generalization relation between two classes.

removeGeneralization(String parent, String child)



specialization




Fig. 4. The rule to remove a generalization relation.

removeClass(String class)



Fig. 5. The rule to remove a class.
The replacement unit which performs the pulling up of the variable starts with a rule, called startCheck, which marks the class to which the variable must be pulled up by associating with it an Auxiliary node, whose list attribute will contain all the names of the class from which the pulled up

variable have been removed (see Figure 6).

startCheck(String class)


Fig. 6. The rule to attach an Auxiliary node to the class that the variable must be pulled up to.

The rule startRefactoring, presented in Figure 7, extracts the variable from one of the subclasses of class. The name of the subclass is added to the list attribute of the Auxiliary node. Note that at least one such subclass must exist, otherwise the whole replacement unit will fail.

startRefactoring(String class, String attr)


owner
feature specialization


specialization











Fig. 7. The rule to pull the variable attr from a non deterministically chosen subclass of class.

The rule completeRefactoring, shown in Figure 8 is then applied as long as possible, i.e. until there are subclasses of class owning a variable of the same name and type as the one first moved. For each subclass to which the rule is applied, the name of the class is added to the list attribute of the Auxiliary node.
Finally, the rule doFinalCheck (see Figure 9) controls that all the sub- classes of class have been considered and that from each of them the variables has been pulled up, by comparing the values of the two list attributes for the nodes of type ClassDescriptor and Auxiliary, associated with class. The failure of this rule indicates that some subclass did not possess the vari-


completeRefactoring(String class, String attr)




specialization












Fig. 8. The rule to pull the variable attr from any subclass possessing a copy of the variable to be pulled up.

doFinalCheck(String class)



Fig. 9. The final rule to check success of the pull up transformation.

able, and makes the whole replacement unit fail. It is to be noted that if this occurs, due to the transactional behaviour of units, the situation prior to the attempted unit is restored. Hence, either because rule doFinalCheck removes the Auxiliary node, or because of restoration after failure, no such node exists once the process is completed.
Hence, the complete replacement unit is expressed as:
pullUpVariable(String class, String attr) = startCheck(class); startRefactoring(class, attr);
asLongAsPossible completeRefactoring(class, attr) end; doFinalCheck(class)

Termination of Replacement Units
Termination of replacement units is not always guaranteed. If an expression asLongAsPossible contains a rule that can be applied indefinitely to the re- sult graphs, the replacement unit does not terminate. Next, we give conditions for the termination of replacement units.

A General Termination Criterion for High-Level Replacement Units
Let G be the set of all objects in a category CAT and P be the set of all the rules on G. In the following, we discuss the notion of termination criterion, by assigning a natural number to each object of CAT .
Definition 5.1 [termination criterion] A function F : G → N from objects to natural numbers is a termination criterion for CAT if for any two arbitrary morphisms a : C → A and b : C → B in M , the value F (A +C B) of the pushout object A+C B of a and b is given by F (A+C B)= F (A)+F (B)−F (C). Given a rule p with morphisms in M , a termination criterion F for CAT is a termination criterion for p if F (L(p)) > F (R(p)).
The reason for removing the value of F in C from the sum is that it contains common elements to A and B, which would otherwise be considered twice. Even if in Definition 5.1 we have considered p to be a rule in the double pushout approach, we refer only to its left-hand and right-hand sides. Hence, the same definition could, under the appropriate definition of the class M , be used also for the single pushout approach. We develop here the theory only for the DPO approach, but will sketch out a consequence on the definition of concrete criterion for SPO.
Proposition 5.2 (direct derivation) If F is a termination criterion for a rule p, then it is also a termination criterion for the derived rules pd of all d : G ⇒p H.


Proof. Since F is a termination criterion for the rule p : L ←l
I →r
R we

have F (L) > F (R). For each direct derivation G ⇒r H given by a double pushout as in Figure 1 we need F (G) > F (H). From F (L) > F (R), we have F (L)+ F (C) − F (I) > F (R)+ F (C) − F (I), i.e. F (L +I C) > F (R +I C),
i.e. F (G) > F (H). Hence, F is a termination criterion for the derived rule
g	h
pd : G ← C → H.	 
Termination criteria for specific instances of derived rules can be used as termination criteria for a rule, as shown by the following theorem.


Proposition 5.3 (termination of derived rules) If F is a termination criterion for one derived rule pd of d : G ⇒p H, then it is a termination criterion for the rule p.
l	r
Proof. Let p be the rule p : L ← I → R. If F is a termination criterion for the
g	h
derived rule pd : G ← C → H then it must hold that F (L)+ F (C) − F (I)= 
F (L +I C) = F (G) > F (H) = F (R +I C) = F (R)+ F (C) − F (I). Hence
F (L) > F (R) and F is a termination criterion for p.	 
Definition 5.4 [terminating expressions] Given a replacement unit in CAT RU = (P, name, C) and an expression E over N ames, F is a termination criterion for E if it is a termination criterion for CAT and
if E = name(p) ∈ N ames, then F (L(p)) > F (R(p));
if E = E1; E2, then, for each derived rule pd of d ∈ der(E), F (L(pd)) > F (R(pd));
if E = asLongAsPossible E' end, then, for each derived rule pd of
d ∈ der(E'), F (L(pd)) > F (R(pd)).
Proposition 5.5 (sequential composition) If F is a termination crite- rion for E1 and E2, then it is also a termination criterion for E = E1; E2.
Proof. If F is a termination criterion for the derived rule pd1 of the derivation d1 : G ⇒ H ∈ der(E1)G and for the derived rule pd2 of the derivation d2 : H ⇒ K ∈ der(E2)H, then F (G) > F (H) and F (H) > F (K). Hence F is also a termination criterion for the derived rules pd of all derivations d ∈ der(E)G. 
Note that the converse is not true, as there may be termination criteria for the composition that are not termination criteria for one of the components.
Proposition 5.6 (as long as possible loops) If F is a termination crite- rion for E', it is also a termination criterion for E = asLongAsPossible E' end.
Proof. If F is a termination criterion for each derived rule pd' of derivations d' : G ⇒ H ∈ der(E')G, then F (L(pd' )) > F (R(pd' )). Applying E' as long as possible, we get a derivation sequence s : N → der(E') with F (start(s(i))) > F (start(s(i+1))) for i ≥ 0. Since N has no infinite descending sequence, there must be an m ∈ N such that for j > m, F (start(s(j))) = F (start(s(j + 1)))
= F (end(s(j))) so that s(j) is the identity derivation, i.e. all derivations in
der(E) terminate.	 
Theorem 5.7 (terminating derivations) All derivation sequences over rules in P ∈ P are terminating if there is a termination criterion F which holds for all p ∈ P.


Proof. Given any derivation sequence s : N → Der(P ), we know that F (start(s(i))) > F (start(s(i + 1))) for i ≥ 0, due to proposition 5.2. Thus, there must be an m ∈ N such that for j > m, s(j) is the identity derivation,
i.e. all derivations in der(E) are terminating.	 

The result of Theorem 5.7 is adapted to replacement units where control conditions are used, in the following corollary.
Corollary 5.8 (termination of replacement units I) Given a replace- ment unit RU = (P, name, C), all derivations in der(C) terminate, if there is a termination criterion F which holds for all p ∈ P.
Proof. Direct consequence of Theorem 5.7.	 

The following theorem shows that the termination criterion need not be unique over a whole control expression.
Theorem 5.9 (Termination of replacement units II) A replacement u- nit RU = (P, name, C) terminates if each asLongAsPossible-subexpression C' of C has a termination criterion F.
Proof. The proof is by induction on the structure of the expression C:
Base step:
C is a rule name: in this case, since each single rule application termi- nates, then RU is terminating.
inductive step:
C = C1; C2
By induction hypothesis, both C1 and C2 define sets of only finite derivation sequences der(C1) and der(C2); hence also der(C1; C2) con- tains only finite derivations.
C = asLongAsPossible C' end
By induction hypothesis, C' has a termination criterion F which, by proposition 5.6, is also a termination criterion for C. Hence RU termi- nates.

Hence, Theorem 5.9 states that a replacement unit is terminating if, for each asLongAsPossible-subexpression of C, there is a suitable termination criterion. The important aspect of this is that these criteria may differ from subexpression to subexpression.

Concrete termination criteria for Attributed Graph Transformation
We show now how some functions which naturally arise from counting elements in a graph can be used to establish criteria for termination.
Definition 5.10 [Concrete termination criteria] Let n : G → U be a function returning the number of nodes in G, i.e. n(G) = |GN |, and e : G → U a function computing the number of edges in G, i.e. e(G) = |GE|, for each graph G in the category ASSIG-Alg . If s is a sort in SG, the function ts : G → U yields, for each graph A in ASSIG-Alg , the number of elements in ASG .
We show that n, e, and ts can be used as termination criteria within the category ASSIG-Alg .
Proposition 5.11 The functions n, e, and ts, for each s ∈ SG, satisfy the termination criterion in Deﬁnition 5.1.
Proof. We can prove that the functions n(G), e(G), and ts satisfy the crite- rion for the pushout construction on two morphisms a : C → A and b : C → B where a ∈ M and b is arbitrary, so that a fortiori it holds when b ∈ M , which is what is required by Definition 5.1. Since the graph part of a is injective, the pushout construction glues graphs A and B only at elements of the graph C, by taking, for nodes and edges separately, the disjoint union of B and the part of A not in the image of C under a i.e. D = B  (A — a(C)). Thus n(D) = n(A +C B)= n(A)+ n(B) — n(C), e(D)= e(A +C B)= e(A)+ e(B) — e(C),
and ts(D)= ts(A +C B)= ts(A)+ ts(B) — ts(C) for each s ∈ SGS.	 
A concrete criterion, other than simple counting of nodes and edges, can be obtained for any rule p in the SPO approach by considering the function Fp(G) which counts the number of matches and partial matches for L, the left-hand side of p, in G. The class M is here considered that of partial morphisms m such that if i /= j, then m(i) /= m(j). Hence, we consider the partial morphism L → R, given by the rule p, and the match L → G. The pushout construction produces the graph H as the result of the application of p. Now, if Fp(L) > Fp(R), we have Fp(H) = Fp(G)+ Fp(R) — Fp(L), so that H has fewer total or partial matches for p than G. This means that at each application of p the number of possible future applications of it decreases, so that it can be applied only a finite amount of time, as the original graph G was finite.
Termination of Sample UML Refactorings
The replacement unit of Section 4 is terminating. Indeed, we only have to check the termination of completeRefactoring for any possible choice of class


and attr, as this is the only rule to be looped on. At each application of this rule, a node of type Variable is removed (together with the edges connecting it to nodes of type Class and Type). Hence, both functions n and e of Section
5.2 can be used as termination criteria to prove termination of this sub-unit.




Conclusions

Termination is an important issue for model transformations. Specifying them by graph transformation in the double-pushout approach has the advantage that they are precisely defined and can be formally analyzed.
In this paper, we are concerned with the termination of transformations and propose a general termination criterion for high-level replacement sys- tems, a generalization of graph transformation systems. Since model trans- formations can become complex, we do not only consider the application of single rules but replacement units where rule applications are restricted ac- cording to an additional control flow. For the description of the control flow we allow application of single rules, sequential composition of rule expressions, and loops applying an expression as long as possible. This paper contains a number of results concerning termination of replacement units.
We plan to extend the presented results in several ways, such as studying additional operators for control expressions, e.g. optional rule applications, if- then-else expressions, priorities, etc. By doing so, we could show that the ter- mination of layered graph transformation to be used for graph parsing would be a special case of the results for our framework. Layered graph transfor- mation systems can be considered as a special case of high-level replacement units where the control expressions are sequential compositions of as-long-as- possible loops applying a set of rules each. Moreover, we plan to study wider criteria to establish termination of sequential compositions of rules.
Furthermore, we would like to take negative application conditions (NACs) into account. NACs for graph transformation have been introduced in [12] and have proven useful when applying graph transformation to practical problems. Recently ([8]), they have been incorporated into the high-level replacement framework in. We would like to build up on this approach to formulate ter- mination results for replacement units taking NACs into account.
Acknowledgments We thank the anonymous referees and Kathrin Hoffmann for several useful observations on a previous version of this paper.

References
Aßmann, U., Graph rewrite systems for program optimization, ACM TOPLAS 22 (2000),
pp. 583–637.
Bottoni, P., M. Koch, F. Parisi Presicce and G. Taentzer, Automatic consistency checking and visualization of OCL constraints, in: UML 2000 - The Uniﬁed Modeling Language (2000), pp. 294–308.
Bottoni, P., F. Parisi-Presicce and G.Taentzer, Specifying Integrated Refactoring with Distributed Graph Transformation, in: Applications of Graph Transformations with Industrial Relevance, LNCS 3062 (2004), pp. 220–235.
Bottoni, P., P. Parisi-Presicce and G. Taentzer, Specifying Coherent Refactoring of Software Artefacts with Distributed Graph Transformations, in: P. v. Bommel, editor, Transformation of Knowledge, Information, and Data: Theory and Applications (2004), to appear.
Bottoni, P., G. Taentzer and A. Schu¨rr, Efficient parsing of visual languages based on critical pair analysis (and contextual layered graph transformation), in: IEEE Symposium Visual Languages (2000), pp. 59–61.
Dershowitz, N. and Z. Manna, Proving termination with multiset orderings, Commun. ACM
22 (1979), pp. 465–476.
Ehrig, H., M. Gajewsky and F. Parisi-Presicce, High-Level Replacement Systems applied to Algebraic Speciﬁcations and Petri Nets, in: Handbook of Graph Grammars and Computing by Graph Transformation. Vol 3: Concurrency, Parallelism and Distribution, World Scientific, Singapore, 2000 pp. 341–400.
Ehrig, H. and A. Habel, Constraints and Application Conditions: From Graphs to High-Level Structures, in: Proc. Int. Conf. on Graph Transformation 2004, 2004, to appear.
Ehrig, H., A. Habel, H.-J. Kreowski and F. Parisi-Presicce, Parallelism and concurrency in High Level Replacement Systems, Math. Struc. in Comp. Science 1 (1991), pp. 361–404.
Ehrig, H., U. Prange and G. Taentzer, Fundamental Theory of Typed Attributed Graph Transformation, in: Proc. Int. Conf. on Graph Transformation 2004, 2004, to appear.
Fowler, M., K. Beck, W. Opdyke and D. Roberts, “Refactoring: Improving the Design of Existing Code,” Addison-Wesley, 1999.
Habel, A., R. Heckel and G. Taentzer, Graph Grammars with Negative Application Conditions, Fundamenta Informaticae 26 (1996), pp. 287–313.
Kreowski, H.-J., S. Kuske and A. Schu¨rr, Nested graph transformation units, Int. Journal on Software and Knowledge Engineering 7 (1997), pp. 479–502.
Ku¨ster, J. M., R. Heckel and G. Engels, Deﬁning and Validating Transformations of UML Models, in: Proc. HCC 2003 (2003), pp. 145–152.
Mens, T., S. Demeyer and D. Janssens, Formalising behaviour preserving program transformations, in: A. Corradini, H. Ehrig, H.-J. Kreowski and G. Rozenberg, editors, Proc. ICGT02, 2002, pp. 286–301.
Plump, D., Termination of graph rewriting is undecidable, Fundamenta Informaticae 33 (1998),
pp. 201–209.
Suny´e, G., D. Pollet, Y. L. Traon and J.-M. J´ez´equel, Refactoring UML models, in: M. Gogolla and C. Kobryn, editors, UML 2001 - The Uniﬁed Modeling Language. Modeling Languages, Concepts, and Tools. 4th International Conference (2001), pp. 134–148.
