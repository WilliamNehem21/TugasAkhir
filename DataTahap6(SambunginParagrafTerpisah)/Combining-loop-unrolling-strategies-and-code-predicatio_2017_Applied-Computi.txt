Worst-case execution time (WCET) is a parameter necessary to guarantee timing constraints on real-time systems. The higher the worst-case execution time of tasks, the higher will be the resource demand for the associated system. The goal of this paper is to propose a different way to perform loop unrolling on data-dependent loops using code predication targeting WCET reduction, because existing techniques only consider loops with fixed execution counts. We also combine our technique with existing unrolling approaches. Results showed that this combination can produce aggressive WCET reductions when com- pared with the original code.

Loop unrolling can contribute to improve the instruction level parallelism (ILP) and execution performance of programs, by enabling more optimization that are affected by code expansion. Although, this code expansion can lead to instruction-cache perfor- mance degradation, if not carefully applied. If loop unrolling is applied before the register allocation phase, register pressure can be increased, leading to the insertion of more spill and reload oper- ations in the code. However, a standard compiler cannot use loop unrolling directly if worst-case execution time (WCET) reduction is desirable, due to the instability of the execution path that gener- ates the worst possible execution time and negative cache effects. Some techniques were proposed in the literature to achieve WCET reduction using loop unrolling, as in [4,6]. In these works, loops are

The contribution of this paper is twofold. Firstly, we propose an alternative way to perform loop unrolling on loops with arbitrary (or variable) execution counts. Traditionally, loops with unknown execution counts are unrolled with fixed unrolling factors, with the corner conditions (i.e, the unrolling factor is not a multiple of the number of iterations) treated with branch instructions. The approach adopted in this work is to treat the same corner condi- tions using code predication instead of instructions that perform control flow changes. Code predication is already used in software pipelining of loops, but its application directly with loop unrolling was not reported in the literature. Code predication also can be explored using a transformation called If-Conversion, which is a standard compiler optimization that converts control dependen- cies into data dependencies, removing branches.

The second contribution of this paper is the combination of our technique with other standard unrolling approaches for data dependent loops and loops with fixed execution counts. In this way, we can decide on a per loop level which of the approaches should be used for loop unrolling. This combination of techniques is important because not every loop can be unrolled in the same way. For example, loops with variable number of iterations must include compare and branch instructions to treat different exit conditions, but loops with static execution counts can be unrolled without these instructions. The necessity of compare and branch instructions is not the only difference when unrolling these two types of loops, but the selection of a valid unrolling factor is also different. In loops with a static number of iterations, we can only consider unrolling factors that perfectly divide such number of iterations. Until the present moment, no work addressing the com- bination of different unrolling techniques was identified in the literature.

The remainder of this paper is organized as follows: Section 2 outlines the related work on loop unrolling directed to WCET reduction. Section 3 shows the motivations of this work. Section 4 explains the proposed approach to perform loop unrolling target- ing real-time applications. In Section 5 we describe briefly our testbed. Section 6 presents the obtained results using a benchmark suite. In Section 7 presents our conclusions and final remarks.

The first work that concerns WCET reduction using loop unrol- ling, consists in applying this optimization directly at assembly level [4]. In this work, only innermost loops with fixed number of iterations are unrolled and the unrolling factor used for all loops is 2. Although, not all candidate loops are unrolled, but only those that are present in the worst-case execution path (WCEP), and they are kept unrolled only if WCET reduction is achieved. At every opti- mization application, the WCET information must be re-calculated to update the worst-case path information that drives the algo- rithm. This recalculation is necessary because any code change that affects the WCET may result in a WCEP change. These WCET recal- culations are a common strategy employed by compilers focused in worst-case execution time reduction. Experiments using a proces- sor with no caches showed that a WCET reduction up to 10% was achieved for all benchmarks.

Both the previously presented approaches consider only loops with fixed number of iterations. In fact, both techniques can be used to unroll loops with arbitrary counts or data-dependent loops, providing necessary code to exit the loop when the termination condition is reached. This code is commonly generated as branch instructions.

If-Conversion [7] is a technique used to convert control depen- dencies into data dependencies. The basic principle consists in eliminating gotos and branches and inserting logical variables to control the execution of instructions in the program. If- Conversion can be performed at IR-level or machine-level as stated by [8] and is related to region enlargement techniques used to expand the instruction scheduling scope beyond a single basic block, which is specially beneficial for very long instruction word machines (VLIW).

The application of If-Conversion techniques in loops is not a novel idea. Software pipeline [9] can benefit from If-Conversion and code predication to control the execution of prologue and epilogue of pipelined loops [10]. Another technique that can benefit from If- Conversion is loop flattening [11]. Loop flattening is a form of soft- ware pipelining that merges nested loops into a single loop body, providing necessary code to control the execution and the flow of data between blocks. In [12] If-Conversion is used to eliminate back-edges of flattened loops. The next section outlines the motiva- tion and the key ideas behind the proposed unrolling technique.

There are some approaches to perform the loop unrolling opti- mization considering this loop. The simpler strategy consists in optimizing only loops with fixed counts. In this case, the compiler chooses an unrolling factor that exactly divides the number of iter- ations of the loop. If a compiler is able to optimize data-dependent

In the next section, we present our approach to perform loop unrolling which applies simultaneously code predication directly in machine code. The technique starts from a simple data- dependent loop and directly generates an unrolled and predicated version, as done step-by-step in this section. The main improve- ment of our approach is that it avoids the use of branch instruc- tions, differently from what is usually done by traditional techniques.

The algorithm works as follows: First, header and body are identified, which is done by Lines 2 and 3. The second step removes the unconditional branch from the loop body to the header. This branch instruction will be re-inserted at the end of the algorithm, as a last instruction (Line 14). The next step is to unroll the loop using the provided unrolling factor, using the original loop body as first copy.

(p) means that the operation execution is conditioned to the con- tent of the flag register p, which is a common notation of predi- cated code. For comparison purposes, the same code is unrolled in the standard way as shown in code listing of Listing 6. Compar- ing the two approaches, we can see that the predicated version presented fewer instructions than the standard counterpart (with branches).

For data-dependent loops with some kind of control flow change inside of the loop body, we can use loop unrolling with compare and branch instructions to exit the loop when the condition is reached. For simplicity, we apply this unrolling alternative to loops with call instructions in the body. This approach is also a common strategy considering compiler optimization, and we will omit its representation in pseudo-code. If we must use this approach, we

For data-dependent loops with simple loop bodies, we can use the predicated version. We cannot use this type of unrolling in loops with call instructions because condition or flag registers are not commonly exposed to the calling conventions used in processors. If we had to save the flag registers, it would be better to use the previous approach. We will call this approach as predi- catedLoopUnrolling, as presented by Algorithm 1.

The previous algorithm is responsible for unrolling the loops of a program using a set of unrolling factors. It is also necessary to choose a unrolling factor for each loop that minimizes the WCET. As we are interested only in verifying the effectiveness of our tech- nique, we are not concerned in choosing an optimal unrolling fac- tor considering code increase and WCET reduction.

We adopted a scheme that tries to iteratively choose an unrol- ling factor for each loop in the program. If the loop has no impact on the worst-case execution time, i.e. resides outside the WCEP (worst-case execution path), it will be kept rolled, otherwise it will be unrolled. The set of unrolling factors will vary according to char- acteristics of the loop, such as data dependency and parity of exe- cution counts.

If the unrolled loop increases the WCET, then it will be also kept rolled. Otherwise it will be maintained unrolled using the factor that best minimizes the WCET considering the previously consid- ered ones from the set. Each loop is processed exactly once, and after each loop handling the WCET (and WCEP) information must be updated to guide the treatment of the next loops. To verify if a WCET increase occurs, it is necessary to perform a program recompilation and an invocation to the WCET analyzer. We do not reconsider loops in case of path changes, since typically all loops in a program are on the WCEP, as stated by [6]. We only check if the current loop is on the WCEP.

must allow the correlation between the loops and the worst- case execution time related data. Execution counts must be exported as well. In case of data-dependent loops, execution counts can be provided as annotations in the source code, for example. These execution counts are also necessary for the cal- culation of the worst-case execution time.

As we can see, the previous relation between compiler and algo- rithm forms a cyclic and incremental approach to optimize loops. The parameter of Algorithm 3 is the representation of a compiled program. The first step of the algorithm is to retrieve a list of (exported) loops of the program representation (Line 2) followed by a WCET analysis (Line 3). The main loop of the algorithm iter- ates over the loop list (Line 4), considering only loops that are in the WCEP (Line 5). Then, we assume that it will be kept rolled (Line 6) if its is not possible to choose an unrolling factor. The next step sor characteristics, these values can be tuned experimentally. If such unrolling factor exists, we recompile the program and test for WCET changes. In case of WCET increase (Line 21), we use the last chosen unrolling factor (Line 22) and skip to the next loop. Otherwise we use the actual factor updating the WCET (Line 24 and 25).

We used a custom compiler back-end developed for the target architecture using the LLVM [18] infrastructure. The compiler also produces all necessary information for WCET calculation, as an annotated CFG containing information like loop bounds and map- pings between CFG nodes (basic blocks) and a target program code. For data-dependent loops, worst-case execution counts (or bounds) must be provided through source code annotations.

The unrolling technique was implemented in our back-end at the end of machine code generation. It is difficult to perform WCET-oriented optimization using LLVM due to its highly opti- mized pass-manager that isolates the treatment of each function of a compilation unit. Due to this fact, we cannot optimize the pro- gram as a whole aiming at WCET reduction using the standard LLVM pass-manager because the generated code is only fully mate- rialized at the end of the complete process. Moreover, the pass- manager deallocates any machine related code representation structures of a function after writing its generated object code to file at the end of the pass-manager execution. So, when we can finally calculate the WCET of a program, we cannot use this data to change the code (optimization application), because the needed intermediate structures no longer exist. Due to this fact, strategies like that proposed by [5], where the analyzer is invoked directly by the compiler to take optimization decisions cannot be used.

responsible to select the parts of the program that must be opti- mized, using WCET information as guidance. This tool shares a database with the compiler that is used as communication chan- nel. This database stores facts about the structure of the program and values that specify if such structure must be touched by a specific optimization. The tool invokes the compiler to generate the object code and data used as input for the WCET analyzer. After that, WCET information is obtained through the WCET analyzer. Using this information, the planning tool updates the database using heuristics like the one proposed in Section 4.3, which chooses the loops and unrolling factors and invokes the compiler again. This task repeats until WCET stabilization or when the entire code is already analyzed by the planning tool.

We proposed in this paper an alternative way to perform loop unrolling with arbitrary iteration counts. Traditionally, this type of loop is unrolled using compare and branch operations to control different exit conditions or contexts. What we propose is the use of code predication to control the loop execution under different exit conditions, since worst-case analyzers tend to consider that each loop, even unrolled, is always fully executed up to its execution bound. The approach can be used in architectures with full predi- cation support and is better applicable when branch operations are segmented in more than one step.

We introduced an algorithm that performs this code transfor- mation directly at the machine code level (or assembly). In our framework, each data dependent loop of each benchmark is anno- tated with a safe loop bound that represents an upper bound on the execution count. After loop unrolling application, the annota- tion is transformed to reflect the new loop bound of the unrolled loop. Since our technique does not depend on branches, the num- ber of instructions is reduced and the instruction scheduling scope

We also proposed a strategy that selects which unrolling tech- nique to apply in a per loop basis. For loops with fixed execution counts, we applied the standard technique that unrolls loops using unrolling factors that perfectly divide execution counts to avoid compare and branch instructions. For data dependent loops, we used our predicated or the branch-based approach, depending on the case.

We observed in the experiments that the combination of unrol- ling techniques was able to reduce the WCET of 18 from 33 bench- marks. For six benchmarks we obtained gains above 20%. In the experiments, we also showed that the predicated approach, even with its limited applicability, can exploit cases where the standard approach fails to get WCET reduction.

