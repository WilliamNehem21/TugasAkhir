Testing and debugging are very important tasks in software development. Fault localization is a very critical activity in the debugging process and also is one of the most difficult and time-consuming activities. The demand for effective fault localization techniques that can aid developers to the location of faults is high. In this paper, a fault localization technique based on complex network theory named FLCN-S is proposed to improve localization effectiveness on single-fault subject programs. The proposed technique diagnoses and ranks faulty program statements based on their behavioral anomalies and distance between statements in failed tests execution by utilizing two network centrality measures (degree centrality and closeness centrality). The proposed technique is evaluated on a well-known standard benchmark (Siemens test suite) and four Unix real-life utility subject pro- grams (gzip, sed, flex, and grep). Overall, the results show that FLCN-S is significantly more effective in locating faults in comparison with other techniques. Furthermore, we observed that both degree and closeness centrality play a vital role in the identification of faults.

This work builds on previous work [17] where we have proposed a new fault localization technique based on complex network theory (FLCN). Statements behavioral anomalies and the distance between program statements in both passed and failed tests execution are the two variables that the technique takes into account. Degree centrality and closeness centrality were adopted for fault diagnosis and a ranking for- mula was also proposed to aid in identifying fault location. The technique locates faulty statements irrespective of whether the statements were

The rest of the paper is organized as follows. Section 2 highlights some existing related work. Section 3 presents the proposed fault local- ization technique. Section 4 describes the experimental setup, results, and discussion. Lastly, the study is concluded in Section 5.

former was built for programs with a single fault, while the latter is for programs containing multiple faults. The result of the study showed that O and O<SUP>P</SUP> are more effective in localizing faults than Tarantula. Shu et al. proposed a fault localization method based on

an important sampling of program statements was proposed [10]. By utilizing probability updates and sampling, the approach can help iden- tify statements that have a high likelihood of being faulty. The approach was found to be more sensitive to failed test inputs than passed test in- puts. In addition, Wong et al. proposed two machine learning-based techniques for fault localization, fault localization based on BP (back-- propagation) neural network [34] and fault localization based on RBF (radial basis function) neural network [14] to localize faults effectively. The result shows that these techniques are effective in locating program faults. However, these techniques have problems of paralysis and local minima. In another study by Zheng and Wang, a fault localization based on Deep Neural Network (DNN) was proposed to tackle the problems of paralysis and local minima [13]. DNN was found to be very effective in comparison to other machine learning-based techniques.

To improve the effectiveness of the former fault localization tech- nique (FLCN) in the single-fault context, we proposed a technique named Fault Localization based on Complex Network theory for Single-Fault programs (FLCN-S), which is a variant of our initial technique in Ref. [17] coined FLCN. FLCN localizes faults with the utilization of both passed and failed test inputs. However, from our initial results, we observed that by utilizing both test inputs (passed/failed) in a single-fault context, the technique (FLCN) effectiveness reduces significantly. At best, FLCN aids developers in locating 40% of the faults by checking less than 10% of the program code in single-fault subjects. This is mainly due to the high sensitivity of FLCN with program statements executed by passed test inputs. Hence, the effectiveness is not convincing in comparison with similarity coefficient-based techniques such as Ochiai [19], Jaccard [15], execution is labeled as 1, it indicates that the statement is executed by the test input in that test run, and 0 otherwise. For the test result of each test input, 0 means the test input has passed while 1 means the test input has failed. Out of the six available test inputs, two of which are failed test inputs tf = (t5, t6) while four are passed test inputs tp = (t1, t2, t3, t4). In order to model the complex network, failed test inputs tf = (t5, t6) is to be utilized. For the first failed test input t5, there is an edge from m1 to m2, m2 to m3, m3 to m5, and m5 to m12. For the second failed test t6, there is an extra edge from m5 to m6 and m6 to m8, respectively.

Therefore, all the failed test inputs in corresponding to the statements will be modeled as N. As a result, a single network N will be generated to capture the entire tests execution behavior with statements represented as nodes and execution between statements as edges. Cytoscape software platform (http://www.cytoscape.org/) is used for network construction and generation. We model the network as an undirected/unweighted complex network. The next section highlights the general framework of the proposed fault localization technique.

Step 1: In this step, the faulty program P will be executed by all the available test inputs in T and the execution data will be collected. The execution profile of statements with respect to each test input will be collected. The set of passed and failed test inputs will be identified.

[53] and four Unix real-life utility programs (gzip, sed, flex, and grep) [54] to evaluate the proposed technique. Generally, various studies have utilized these subject programs for fault localization [9,18,19]. Siemens test suite programs are utilized because the programs contains single fault each, while Unix real-life utility programs contains both real and seeded faults [33]. All of these subject programs are also written in C programming language.

Siemens test suite is composed of seven subject programs, namely schedule, schedule2, print_tokens, print_tokens2, replace, tot_info, and tcas where each of the subject programs has more than 1000 test inputs. For the Unix real-life utility program, gzip program is utilized for file compression and decompression. The program is normally utilized to decrease the size of name files. The input of gzip program comprises of 13 options with a list of files as well. The program has 6573 lines of code and 211 test inputs. The sed program performs simple changes in an input stream. It is basically utilized to parse textual input and also to apply a specified user changes to the input. The program has 12,062 lines of code and 360 test inputs.

The flex program is a lexical analyzer. It reads a file and produces a C source file called scanner. The input files contain sets of consistent expression and C code, called rules. The program has 13,892 lines of code and 525 test inputs. The grep program has two input parameters which are patterns and files. The program prints lines in each file that contains a match of any of the patterns. The program has 12,653 lines of code and

Top-N. Top-N symbolizes the percentage of faults a fault local- ization technique ranks for all faulty statements among the Top N (N = 1, 5, 10) positions in the ranked list. Hence, the smaller the value of N in Top-N, the stricter the metric. For instance, Top-5 metric demands that all faults are ranked within the top 5 positions in the ranked list.

In part (c) and (d), the effectiveness score of print_tokens is presented. We observed that, by examining less than 10% of the program code, FLCN-S can only locate 65% of the faulty versions in the best case and 35% in the worst case. Ochiai (the second best) can locate 60% of the faults in the best case, and 25% in the worst case. Moreover, the per- centage for Tarantula (the third best) is 55% (best case), and 15% (worst case). However, looking at the curves in part (c) and (d), the two tech- niques (Jaccard and SNCM) are the least effective on print_tokens program faulty versions.

Few scenarios have confidence level that is lesser than 95%, for instance, FLCN-S being more effective than Ochiai with 90.00% confi- dence for the best case of tcas, 93.33% confidence being better than Ochiai for the best case of print_tokens2, and with 92.31% confidence being better than Ochiai for the worst case of print_tokens. In summary,

In our earlier work, we studied the impact of degree centrality and how statements degree relates to faults. We concluded that statement degree is vital in identifying faulty program statements, especially in a multiple-fault context. In this paper, we observed that on Siemens test suite programs, 23% of all faulty statements have degree centrality of 3 while 77% have a degree centrality of 2. Hence, we found out that in the single-fault context, closeness centrality plays a vital role in ranking and identifying program statements. Moreover, on both Siemens test suite and Unix real-life utility programs, both degree centrality and closeness centrality play a critical and vital role in the identification of faulty program statements.

Generally, the effectiveness of a given technique is not always con- stant and can change depending on the subject program used. We observed that by utilizing failed test inputs alone, the effectiveness of the proposed fault localization technique (FLCN-S) has increased on single- fault programs. In our initial work, we utilized both test inputs (passed/failed) to localize single faults, the accuracy was not convincing, where we achieved 40% Exam score by checking less than 10% of the program faulty versions on Siemens test suite programs. This is mainly due to the high sensitivity of the technique (FLCN) with program state- ments executed by passed test inputs. Therefore, we concluded that by utilizing failed test inputs alone, the accuracy of our proposed technique (FLCN-S) increases in the context of single fault due to the minimal fault- to-failure complexity that affects localization on multiple-fault programs. Our technique can effectively localize 65% of all faulty versions on Siemens test suite subjects by checking less than 10% of the program code and is largely more effective on Unix real-life utility program in comparison with other techniques in both best and worst case scenarios. Finally, we also observed that both degree centrality and closeness cen- trality plays a vital role in the identification of faulty program statements.

In this paper, we presented an automated debugging technique, coined FLCN-S to improve localization effectiveness in a single-fault context. The proposed technique is a variant inspired by our previous work [17] which uses both passed and failed tests executions. Our pre- vious technique has proven to be less effective on single-fault subject programs where both test inputs (passed/failed) are taken into account. In contrast, FLCN-S diagnoses and rank program statements based on their behavioral anomalies and distance between statements in failed test inputs.

The proposed technique is evaluated on a well-known standard benchmark (Siemens test suite) and four Unix real-life utility programs (gzip, sed, flex, and grep). We compared our technique with four fault localization techniques, namely Ochiai, Tarantula, Jaccard, and SNCM. Overall, the results show a significant improvement on the single-fault subjects where 65% of all the faulty versions can be localized by checking less than 10% of the program code on Siemens test suite pro- grams and is largely more effective on Unix real-life utility program in comparison with other techniques in both best and worst case scenarios. Furthermore, we observed that both degree centrality and closeness centrality play a vital role in the identification of faults.

For future work, we will like to explore other centrality measures for fault localization. And we plan to further explore the effectiveness of our technique on larger datasets to further substantiate our claims. Moreover, the proposed fault localization technique (FLCN-S) is considerably more effective in localizing faults in a single-fault context in comparison with our previous work and other techniques compared with.

