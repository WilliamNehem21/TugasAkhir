The paper describes Lustre, a language and specification tool for modeling synchronous data-flow computations (such as those seen in cyclic computations) predominantly in control and command systems like those used for electricity generation. Instead of automatically generating code, the paper operates under the assumption that Lustre is applied primarily as a specification language, and the actual implementation may be manually coded to enhance efficiency or integrate existing code.

The paper first introduces Lustre, as well as the process of resolving constraints using a tool called GATeL. Following this, the paper outlines the methods for selecting test cases. An example involving a microwave oven controller demonstrates the first method, which involves deriving test objectives. The second method is interactive domain splitting, which investigates sub-cases in the initial constraints, using either predefined or user-driven scenarios.

Lustre, part of the synchronous data-flow language family, was created at IMAG Institute in Grenoble and has industrial applications (e.g., companies like Schneider Electric and Aerospatiale). Lustre offers both textual and graphical notations, the latter resembling those found in hardware design.

The paper provides an example of a reaction system with four inputs—start, abort, open, and duration—and three outputs—remaining_time, cooking, and bell, explaining how these interact in the context of a microwave oven's controls.

The paper discusses the use of assertions to enforce invariant properties and the GATeL tool's efficiency in variable instantiation and consistency checking. It also addresses the need to ensure the coherence of environmental specifications, which are verified using simulations.

GATeL offers two methodologies for describing test cases. The first involves an interactive decomposition of Lustre operators, suitable for unit testing, while the second employs predefined functional scenarios, useful during the integration phase to focus on specific behavior instances.

The paper further explains how a constraint system is built from assertions and the use of a technique adapted from the Loft tool, which facilitates the splitting of validity domains based on Lustre operators' sub-cases.

The process of unfolding these operators is dynamic, allowing users to determine subdomains and paths for output predicates through interactive selection, supporting versatile test objective domain splitting.

Challenges arise in complex examples when selecting the appropriate operator for unfolding due to the potential involvement of multiple variables over several cycles or when an excess of unfoldable operators is present.

Lastly, the paper notes ongoing research in handling real and floating point numbers within GATeL, highlighting the complexities introduced by such data types, including the design of a constraint solver for floating point arithmetic and the observability issues they pose for test oracles.