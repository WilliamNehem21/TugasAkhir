This paper is part of a broad initiative aimed at enhancing the debugging processes for functional logic programming languages. Its core concept revolves around generating execution traces via side effects in such programs, subsequently using these traces to create various diagnostic perspectives. Such perspectives facilitate established debugging techniques—declarative debugging, expression observation, redex trailing—as well as the development of step-by-step debuggers and symbolic profiling tools based on cost centers. New debugging views tailored to specific needs should also be straightforward to create and implement.

The authors underscore the benefits of declarative programming, which abstracts from certain low-level concerns, thereby reducing common sources of coding errors such as memory management issues and type errors. Consequently, programs are more comprehensible and maintainable since they align closely with the logic of the underlying algorithms.

Visualization tools are discussed as an effective method for identifying bugs by representing program execution in an easily navigable format. While many such tools exist for various languages, they often lack portability. The paper lists several sophisticated instances of such tools designed for declarative languages.

The paper then delves into value-oriented debugging techniques, which focus on analyzing the values computed by program expressions. Unlike these techniques, the research presented includes recording additional information about pattern matching occurring during program execution. Such information is key to integrating operational tools that rely on understanding the state transformations during execution.

The primary aim of this work is to provide a simple and versatile interface for tracing program execution in the functional logic language Curry. It discusses the representation of such traces in Curry and proposes a simplified data structure for general computations. The paper details how this data structure facilitates the implementation of runtime data access tools.

The data structure simplifies the representation of computations, classifying computation steps into categories such as single steps, subcomputations, or branching. It interprets these steps in light of different evaluation strategies, distinguishing between strict and lazy evaluations based on the extent of subcomputation.

Previous work laid the foundation for this paper, extending semantics to include a trace graph and demonstrating a program transformation technique to record trace information into a file. The paper explains how argument arrows in such graphs signify expressions and provide an efficient method of representing computation paths in lazy functional languages, including the possibility of constructing cyclic graphs.

Despite possible limitations like memory constraints during the recording of tracing data, an alternative implementation overcomes this by representing the trace graph as a potentially infinite term and retrieving nodes from a trace file when needed.

The paper further describes the monadic programming style for generating and processing computations and illustrates the synergy of advanced programming techniques in Curry to provide a higher level of abstraction for execution traces. Finally, it outlines future work on employing this framework to explore various strategies and perspectives for debugging.