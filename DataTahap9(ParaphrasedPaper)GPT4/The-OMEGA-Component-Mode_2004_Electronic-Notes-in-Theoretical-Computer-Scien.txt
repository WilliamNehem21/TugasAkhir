In an object-oriented (OO) setting, a class diagram is fundamental to an application, and similarly, for a component-based application styled using our component model. We've described transitioning from a hierarchical component model to a simplified class diagram in the OMEGA Deliverable D1.1.2. In this paper, we will justify our component model formally through compositional trace semantics and associated logics in Section 5.

Component interfaces come together as ports, which are the sole interaction points between components and correspond to unique classes within components. Communication between components occurs through these instantiated ports at runtime; these runtime objects are essentially class instances in a fundamental class diagram utilized by our component model.

Our components bear a resemblance to those outlined in UML 2.0 proposed by U2Partners, with shared objectives in the OMEGA project being to create a compatible OMEGA component model. However, we note semantic discrepancies which are expanded upon in this paper. Notably, unlike U2Partners' proposal where components themselves are instantiable, in our model, it is component ports that are instantiated. This mirrors OO practices and ensures the component remains an abstract software concept. Additionally, to maintain simplicity, we do not include explicit modeling of connectors, giving users the flexibility to either adopt UML 2.0 connectors or model connectors as components themselves.

Ports are seen as a hybrid of UML classes and interfaces, essentially a class with a defined interface but unnamed, where instantiation doesn't require knowing the actual class. A basic component comprises of classes and relations based on the OMEGA kernel model, with some classes linked to ports. A UML interface within such a component, needing external resources, should be fashioned as a component interfaceâ€”though designers may sometimes use external class libraries.

Statecharts labeled in OMEGA action language follow the format [guard] trigger/action. These consider standard OO dereferencing and include simple statements as detailed in the OMEGA kernel model document.

For formal modeling, we select a subset of UML 1.4, complemented with non-UML Live Sequence Charts (LSC). This paper extends the OMEGA UML subset with components. Our component diagrams are an architectural analogy to class diagrams, offering both definition and runtime perspectives through component and architectural diagrams, respectively.

The paper outlines formal trace semantics providing a semantic foundation for verifying component composition. It employs a translation relation on object diagrams, abstracting from platform-specific deployment.

It is expressly noted that component interaction is limited to port instances, with no direct service calls between the internal objects of different components.

We touch on using component models in OMEGA without full UML 2.0 tool support, suggesting class diagrams could proxy for component diagrams; however, designers must keep track of this dual usage. Likewise, object diagrams may represent architectural counterparts.

Finally, the components serve as an additional abstraction, simplifying our kernel model language. In OMEGA, all classes, active or passive, are treated uniformly, each with its thread of control and event queue, clustered only within the framework of components. Components, unlike in U2Partners' UML 2.0 model, do not act as instantiation units and do not possess unique runtime identities. Our approach of having instantiable port interfaces rather uniquely allows for multiple instances of ports with equivalent interfaces per component during runtime. These are analogous to connectors in UML 2.0.