Software and hardware systems are pervasive and increasingly intricate, posing challenges in developing flawless specifications necessary for their complexity. These systems not only expand in size but also must integrate with other intricate environments, heightening the risk of errors that can have severe consequences. As such, there is a growing demand for methodologies that can ensure the development of reliable computer systems. Formal methods, grounded in mathematics, offer rigorous strategies for designing, modeling, and verifying the correctness of these systems by using precise, unambiguous specifications defined by well-established syntax and semantic rules derived from mathematical principles. These principles are crucial for affirming systems' adherence to their intended properties and requirements.

Over the past years, case studies and real-world applications have underscored the value of formal methods in enhancing the quality of software and hardware, although their higher costs typically restrict their use to high-stakes environments where failures could result in loss of life or significant damage. Precise specifications, when validated against critical properties, can lead to the creation of accurate and efficient software.

Graph grammars emerge as an appealing tool for system specifications due to their visual nature and capacity to represent various types of vertices and edges through labels, attributes, or type graphs. This paper focuses on the use of a type graph for defining the admissible vertices and edges within a system, underpinned by a graph morphism that ensures the system adheres to these restrictions.

The behavior of a system described by graph grammar results from rule applications that navigate through possible system states. Essentially, a grammar encompasses a type graph, an initial state graph, and a set of transformation rules that express potential state transitions. Additionally, rules can be assigned names, forming a named set with each rule associated with a particular name.

For the rules to be applied, their left side, which represents the part of the system to be transformed, must be found within the current state graph. A derivation step then takes place, allowing the transition from one state to another by conforming to certain conditions: the dangling condition ensures that deleted vertices are not still connected by edges, and the identification condition ensures that only preservable vertices can be matched.

The notion of causality between rules is introduced, indicating that the creation of an entity by one rule can facilitate the application of another, reflecting the dependence of actions on necessary conditions. Addressing simultaneous applications requires consideration of potential conflicts, ensuring that no rule undermines the application of another through deletions.

In translating these concepts for practical application, dependencies and conflict management can be embedded directly into data structures when representing them in formal tools like Event-B. This necessitates alteration in the grammar's initial graphs and rule sides by adding new vertices that do not generate issues beyond their intended effects.

Moreover, the translation process may involve modifying rule naming strategies to allow seamless iteration cycles. New vertices are incorporated to manage dependencies and conflicts, with specific modifications to the type and initial graphs along with the rule sides.

Graph grammars provide an intuitive language for formally specifying and verifying complex system properties. While the language accommodates model checking and theorem proving techniques, there are gaps in the tool support for verifying properties of controlled graph grammars, which employ an auxiliary control structure to prescribe the order of rule applications.