The paper discusses the initial design of the autowrite tool, which was created to verify call-by-need properties of various examples. Initially, no alternative proofs were available. Autowrite executes tree automata constructions based on call-by-need theories and performs several operations on terms, term rewrite systems (TRSs), and tree automata.

In autowrite's first version, the graphical interface only provided access to call-by-need properties and some basic functionalities. The updated version introduces additional features, particularly enhancements related to TRSs. One significant update is the inclusion of direct manipulation capabilities for bottom-up tree automata, such as loading, saving, and performing Boolean operations. Additionally, the new version offers on-line timing information, and runtime performance has been significantly improved due to better data structure choices. These new features enable the testing of properties in examples for which simple proofs are not readily available.

The paper defines terms used in the context. A ground term is variable-free, and a linear term doesn't have repeated variable occurrences. A redex is an instance of the left-hand side of a rewrite rule, and a normal form is a term free of redexes. The set of all ground normal forms for a TRS R is expressed as NF(R). A linear TRS has linear terms on both sides of its rewrite rules. If a TRSâ€™s left-hand sides of rewrite rules are linear terms and there are no critical pairs, it is considered orthogonal. Orthogonal TRSs ensure that every term has at most one normal form.

The paper also outlines various approximation mappings, such as 'S', 'NV', and 'GR'. For a TRS R, the strong approximation S(R) replaces the right-hand side of each rewrite rule with a variable not present on the left-hand side. The non-variable approximation NV(R) substitutes variables on the right-hand sides with concrete values or terms.

The method involves using an automaton to determine whether a term is a normal form by ensuring the term is not recognized by the automaton. The complement of the automaton, which identifies reducible terms, is then used to verify recognition of the current term. The process ensures that the complement automaton does not recognize an empty language.

Lastly, the paper describes an incremental approach to building the automaton. It starts with rules that have a constant on the left-hand side, defining the initial accessible states. New rules are then computed based on the current accessible states, gradually expanding the set of states until no new states emerge. This incremental construction is essential to manage the complexity and computing demands of the problem.