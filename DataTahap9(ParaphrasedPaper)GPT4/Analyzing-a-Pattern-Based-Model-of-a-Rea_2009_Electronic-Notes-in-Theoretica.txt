This section provides a concise introduction to the SAVE component modeling language, which is part of the SAVECCM framework for designing component-based real-time and embedded systems. SAVECCM includes a graphical syntax and a formal semantics, although this paper only offers a brief informal summary due to space constraints. Readers seeking a full explanation of the language are directed elsewhere.

The language models processes with a probabilistic finite state machine (PFSM) that begins in a "start" state. The execution of transitions between states depends on the evaluation of associated guards; when multiple transitions are available, one is chosen at random. The "start" state is represented by a solid circle, and an exit control state is shown as a half-filled circle.

A run-to-completion (RTC) execution model is used, where a component carries out steps indivisibly, uninterrupted by any other activities. This approach simplifies the design process, eliminates deadlocks, and may reduce the number of possible interleavings, which can aid in verification and align the model more closely with actual implementation. Such an RTC model is also found in languages like Statecharts.

Statecharts and other behavior modeling methods use execution history to remember the last-visited state before an exit, allowing for direct re-entry upon resumption. This history mechanism is mimicked in Charon, a modeling framework for hybrid systems.

The pattern also accommodates execution history through an integer variable "h" that tracks the state history, excluding the "start" and "exit" states. Special transitions account for this variable when entering or exiting states.

For real-time and embedded systems, understanding a component's best and worst-case execution times is crucial. To model this, a time-related pattern with bounds on execution times is introduced.

This pattern assumes a component's execution time falls within a specific interval and that the component is annotated with these time bounds. An execution clock is reset upon starting and an intermediate "delay" state enforces the upper timing constraint, while the transition guard enforces the lower bound.

Drilling and testing are critical in the production cell context, as they ensure products are processed correctly and efficiently. Parallel processing occurs in the cell, and the system manages the cycle completion and rotation of a rotary disc to continue to the next processing phase, with no fixed period due to non-deterministic timing from tool signals.

The testing process involves a tester sensor with a two-time unit window to measure a drilled hole and determine the condition of the slot and product within.

The drill and test tool function with actuators and sensors to perform actions, while the disc operates with "wait" and "turning" states, managed through actuators, sensors, and timing clocks.

Finally, the approach to behavior specification is likened to the Statemate toolkit's statecharts, offering similar features like run-to-completion and execution history, although the proposed finite state machine (FSM) notation for component behaviors in this framework is not hierarchical.