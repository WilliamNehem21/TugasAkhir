The paper presents a method that automatically converts use cases described in a controlled subset of English, referred to as controlled natural language (CNL), into formal specifications using CSP process algebra. This translation is necessary because full natural language is too complex for mechanical transformation. The CNL is intentionally restrictive to ensure correct and unambiguous specifications suitable for automated conversion to CSP.

This research is part of a collaboration between CIn-UFPE and Motorola, named CInBTCRD, and the CNL is tailored to their specific domain. The formal CSP model produced is then used by other software tools within the project to automatically generate test cases in Java and manual test cases in CNL.

Unlike previous research which generally focuses on a single level of translation, this paper explores the translation of use cases at varying levels of abstraction. It illustrates this with user view and component view use cases, and examines how CSP's semantic models and refinement notions can define formal relationships between these views. Tools fully support the approach, including a Microsoft Word 2003 plug-in to verify CNL grammar adherence, and another tool to convert CNL into CSP. Additionally, a CSP model checker called FDR checks the refinement between user and component views.

The paper is organized as follows: Section 2 overviews the approach, Section 3 introduces CNL templates and corresponding tools, Section 4 describes the CNL-to-CSP translation, Section 5 discusses refinement relations between CSP models, and Section 6 concludes with contributions and further research suggestions.

In detail, CNL enables the writing of imperative and declarative sentences to describe actions and system characteristics. CNL's vocabulary is limited, and its grammar is defined through knowledge bases that map verbs and their complements to CSP channels and datatypes, thus increasing specification quality by preventing ambiguity.

Additionally, the paper discusses handling multiple possible user actions and system responses, the definition of execution flows (main, alternative, exception), and conditional situations. It also describes how components interact in the component view, and how execution flows and system state columns are applicable to both user and component views.

The case frame concept is crucial in relating verbs, terms, and modifiers in CNL to create proper sentences. The CNL maps verbs to CSP channel names and uses an ontology to define CSP datatypes. These mappings allow for sentence translation into CSP events.

The paper emphasizes the importance of consistent architectural views at different abstraction levels and describes how to relate and refine these views using CSP. The idea is that events from a more abstract model trigger the execution of related concrete events in a more detailed model, which allows for formal tracking of relationships between models.

The presented strategy, while initially explaining only two abstraction levels, can be extended to any number of views. The approach can also generate test cases based on system specifications and UML diagrams from CSP models. Future explorations could involve automated test case execution and test scripts generation, contributing to the overall automation of software testing processes associated with CSP-based specifications.