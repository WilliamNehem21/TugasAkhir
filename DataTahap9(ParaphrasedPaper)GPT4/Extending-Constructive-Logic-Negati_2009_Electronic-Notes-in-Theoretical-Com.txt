Our constructive negation technique integrates types and yields explicit values as outcomes, rather than constraints. We delve into the semantics and practical implementation for classical, finite constructive, and intensional negation, and provide examples and computational analysis.

Negation, not originally included in logic systems, introduces complexity but is indispensable across various domains like web semantics and databases. Despite its challenges, such as coroutining risks and managing constraints, our work seeks to offer a robust Prolog implementation to address a longstanding gap in this field.

Distinct from typing in languages like functional programming where well-typed programs are error-proof, logic programming may fail if types are misused. Our approach uses Horn clauses to define regular types, for example, lists of integers, using base types.

In logic assertions, preconditions must be met for a predicate to be called, and postconditions reflect the state after successful execution. These assertions, which may be user-specified or compiler-inferred, serve as type declarations.

The Ciao system, a Prolog programming environment, differentiates between modules and packages. While modules add code to imported programs, packages transform the importing program's code. Type checking in Ciao doesn't generate values for variables; we aim to enhance this aspect.

Our goal is to use pre-compiler type information at runtime. New packages we developed modify the initial code with clauses containing type details. The "add_types/3" function creates predicates to check argument types during execution.

Based on Chan's constructive negation proposal and subsequent refinements, we developed a new predicate, "cnegt/1," which adapts classical constructive negation to types, ensuring finite solutions through finiteness analysis.

We also implemented "cnegf/1" for finite constructive negation and then built "cnegf_t/1" for a typed version, both requiring our "gen_types" package.

The predicate "intnegt/1" negates goals for predicates with fully instantiated variables. We plan to extend this to handle universal quantification with types in future work.

Lastly, we provide an example of the "length/2" predicate for lists with even numbers, demonstrating our approach's utility in practical scenarios.