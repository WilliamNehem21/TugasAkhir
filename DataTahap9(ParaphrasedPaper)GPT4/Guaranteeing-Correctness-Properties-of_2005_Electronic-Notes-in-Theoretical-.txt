The Java Card platform is designed to create multi-application smart cards using a simplified version of Java that excludes certain features like concurrency, garbage collection, and several API functionalities. It supports the coexistence of multiple applications, or applets, such as a payment applet alongside a loyalty reward applet, by using the concept of an applet which extends the Java Card API class.

To enhance security and functionality, researchers at SICS's formal design techniques group have developed and utilized affordable and fully automated verification methods that could be employed by smart card systems during runtime. These methods assess if new applets are safe to load onto a card already containing other applets. The team's initial work involved using model checking to analyze inter-method calls on Java Card smart cards. The current paper expands this method to also address memory allocation issues, utilizing model checking and, when necessary, supplementing with a runtime monitor to ensure safe memory practices.

For analyzing Java Card applets, the team uses program graphs as an abstract representation of control flow within programs, with methods that can be efficiently calculated. These graphs are defined through pushdown systems, providing a suitable model for program execution with methods and potential recursion, and allowing for automatic model checking for Linear Temporal Logic (LTL) properties using tools like MOPED.

They also utilize SOOT, an external static analysis tool tailored for Java Card, to generate call graphs that primarily focus on the sequence of method calls, neglecting data and method call parameters. This process conservatively creates graphs, including potential method calls even when they might not occur during actual runtime, thus preserving LTL safety properties. The call graph generation is adapted to now include information about memory allocation through new and newarray instructions, which are represented in call graphs as synthetically generated method calls.

Further investigation of the applet bytecode revealed use of the Open Platform 5 personalization scheme, indicated by specific method calls. The paper discusses the refinement of properties to check that memory allocation only occurs before personalization. The study recognizes that memory may be allocated during certain method invocations but no personalization follows, which could be due to the applet managing state across process method calls. This highlights the potential for false positives due to data dependencies abstracted away during call graph generation.

For monitoring safe execution, the implementation must be considered in the context of the Java Card platform's limitations, such as the absence of threads. The researchers chose to directly integrate runtime monitor code with the applet's code using code instrumentation, ensuring any operation that could breach the safety policy is checked by monitor code. The same SOOT tool used for call graph extraction is also employed for the automatic instrumentation of Java Card programs, offering a high-level abstraction of Java Card bytecode and facilities for inserting new bytecode instructions within a method body.