The authors of the academic paper developed a way to analyze the control-flow and data-flow within Java source code using a declarative style. They achieved this by enhancing reference attribute grammars with circular and collection attributes and implemented their system using the JastAdd extensible Java compiler. Their method allows for concise and modular implementations that can be easily extended for further analyses. The implementation's performance was compared with an imperative counterpart, and preliminary results showed little to no difference in execution times, even on medium-sized Java applications.

The focus of their analyses is intraprocedural, meaning they are confined within single methods rather than across multiple methods, but they plan to expand this to interprocedural analysis in future work. A case study detecting dead assignments in Java programs demonstrated the efficiency of their approach, with the entire analysis requiring less than 340 lines of code and performing quickly on real-world applications.

The paper is structured to first introduce the control-flow analysis, then the data-flow analysis, followed by application examples, comparisons to related work, and a conclusion with an outline of future research directions.

In their approach, each element of the syntax (like if statements, while loops, and various expressions) is given specific rules that determine how they interact within the program's control flow.

Their efficient approach also compares favorably to existing frameworks like Soot, which provides powerful optimizations and analyses for Java bytecode but is not declarative, therefore requiring manual intervention for combining or extending analyses.

In conclusion, the paper presents a novel, declarative way to specify control-flow and data-flow analyses that are both efficient and extensible. Future work may see this approach applied to more complex analyses and other aspects of compiler backends, as well as domain-specific source-level analyses.