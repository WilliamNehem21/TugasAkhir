Parser combinators, which have a rich history in functional programming, are interpreted from an object-oriented viewpoint as methods (combinators) operating on objects that represent grammar productions, where each object is a parser corresponding to a specific part of the grammar. Combining parsers yields new parsers capable of recognizing more complex structures.

In object-oriented parser combinator frameworks, grammar rules are assigned to corresponding parsers. Common operations, like parsing digit and letter characters, use utility methods that recognize character ranges. Identifiers, however, present challenges as lexing (tokenizing) and parsing are not distinct, which is typically handled by a lexer to ignore whitespace and comments. To address this, a combinator is used which skips whitespace/comments before employing another parser.

Closures are sometimes criticized for reducing grammar clarity when used as arguments for combinators, though in some frameworks, misuse is dynamically detected. Nevertheless, using closures can introduce an asymmetry between the parsers and the argument closures.

Processing, such as creating an abstract syntax tree (AST), is necessary after merely accepting a language. An operator called 'wrapper:' is introduced for this purpose. It allows a parser to produce results different from what the parser would typically return, by passing the parser's results through a closure.

AST generation can be separated from grammar definition, enhancing clarity. However, naming the productions for debugging or error reporting can clutter the grammar and make the specifications redundant.

The paper illustrates a case where methods representing grammar productions in a subclass may not return subtypes of the superclass's method return types, which would normally be illegal in statically-typed languages. Yet, this design does not produce type errors during execution. By using type variables as wildcards, the framework allows for accurate type-checking of subclasses that generate ASTs.

To alleviate notational burden, an approach using self types and Java's wildcard construct is suggested, enabling accurate typing without specifying each type variable explicitly.

Although parser combinator libraries usually only parse context-free grammars, the paper hypothesizes that they could also parse context-sensitive grammars, as parsers in imperative languages can share state, overcoming the need for monadic combinators found in functional languages.

The paper references an existing Smalltalk parser combinator framework by Andrew Black, which was intentionally similar to Haskell's monadic parser combinator framework but doesnâ€™t support separate grammar and processing.