Goanna is a robust static analysis tool designed to detect bugs in C and C++ programs, which sets itself apart by leveraging the natively supported model checker NuSMV as its primary analysis mechanism. NuSMV enables Goanna to leverage a syntactic flow-sensitive program abstraction for greater flexibility in check writing and the capability to scale to large codebases. Within this paper, a novel pointer analysis strategy for C is introduced and its integration with the model checking method for interprocedural analysis is described, showcasing the approach's efficacy and accuracy through a case study.

Utilizing model checking for static analysis allows straightforward articulation of desired program properties using Computation Tree Logic (CTL), with the additional benefit of automatically producing counterexamples when these specifications are violated, aiding defect remediation.

While many static analyzers focus on intraprocedural analyses, often overlooking the impacts of procedure calls which can lead to program failures due to incorrect contexts or unexpected inputs, this paper outlines a method for interprocedural analysis of pointers in C using procedure summaries. These summaries enable the capture and reuse of a procedure's effect on program state each time the procedure is invoked, and are computed following an intraprocedural pointer analysis.

Goanna's methodology is broadly outlined, followed by a more specific discussion on model construction and translation into NuSMV's input language. The intraprocedural analysis framework, upon which Goanna is built, is thoroughly discussed as per the work of Fehnker et al. The paper details how the behavior of functions can be encapsulated using procedure summaries in relation to pointer analysis, and how combining this with Goanna's intraprocedural analysis framework helps to identify invalid memory accesses due to procedure calls, expanding on the intraprocedural model.

The paper evaluated the performance and effectiveness of intraprocedural pointer analysis and the summary-based interprocedural analysis via an analysis of OpenSSL 0.9.8d source directories. The discussion mentions that while performance issues were noted, particularly with files heavily utilizing preprocessor macros, the developed approach could still be successfully applied to substantial codebases. However, full application to the complete Firefox source code proved challenging due to extensive utilization of advanced C++ features like templates. The paper posits that performance can be improved by optimizing certain algorithms or by using incremental analysis, which only reanalyzes program portions affected by modified summaries, typically a small fraction of the overall code.

The paper closes by emphasizing the prevalence of pointer-related defects in software, particularly in languages like C that permit complex pointer operations and lack inherent pointer safety mechanisms. While purely syntactic program analysis can be efficient and effective, it also tends to produce a high number of false warnings. The integration of the new intraprocedural analysis improves upon the existing framework and complements well with incremental analyses. Although model checking aids static analysis by automatically generating counterexamples, interprocedural analysis with summaries makes this challenging. The challenges encountered during analysis are due to an absence of detailed information about the functions being called, suggesting a need for alternative approaches to resolve this issue.