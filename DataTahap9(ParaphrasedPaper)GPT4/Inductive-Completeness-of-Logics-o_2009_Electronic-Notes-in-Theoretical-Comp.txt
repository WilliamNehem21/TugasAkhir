The denotational semantics of typical programs can be understood as a relation that is defined through structural induction. By using the principles of canonical theories for inductive definitions, we explore the first-order theory of program semantics. This theory uses production rules as a means to build programs (introduction rules) and their opposite patterns as ways to dismantle them (elimination rules).

The advantage of this first-order approach is its simplicity and straightforwardness, which lends itself to better understanding, communication, and the application of automated theorem proving tools. It aligns with the historical practice of constructing program semantics through induction. By setting up an inductive definition for a programming language's semantics, we automatically gain an associated first-order inductive theory, enabling us to examine the logical completeness for that theory.

Our study is centered on guarded iterative programs, which are regular programs that incorporate conditionals and assignment statements as their basic operations. This helps us clearly distinguish fundamental programming concepts. These programs are designed to be flexible with regards to the specific vocabularies used, which can contain a finite number of identifiers for constants, functions, and relations, each with their assigned arities when necessary.

Established techniques exist that derive first-order inductive theories from a set of inductive definitions. The semantics of regular programs, in particular, follow an especially straightforward inductive definition, which operates through atomic production rules resembling natural deduction inferences with atomic premises and conclusions.

We denote the inductive theory associated with regular programs as IND(reg). In contexts where there is no confusion, we may drop the subscript and refer to the regular programs directly. There are also weaker theories of interestâ€”an elementary inductive theory (IND0) that only allows inductive elimination for first-order formulas, and a generative theory (GEN) that includes only the introduction rules without the elimination component.

It is notable that first-order proofs for certain completeness theorems do not depend on the generative rules of these inductive theories. Additionally, there is an observation that total correctness assertions do not employ the full scope of inductive elimination rules.

The difficulty with relative completeness arises not just because of the problem with non-expressive structures, for which inductive completeness is not a problem, but also with languages whose termination cannot be decided for certain structures. Nonetheless, assigning inductive definitions to the semantics of such programming languages is relatively easy, though it may require additional constructs.

Inductive definitions offer a more flexible and universally applicable framework for understanding program semantics compared to second-order models since they adapt directly to the constructs of the programming language in question. Once you have these inductive definitions, matching them with a program logic should follow more naturally.