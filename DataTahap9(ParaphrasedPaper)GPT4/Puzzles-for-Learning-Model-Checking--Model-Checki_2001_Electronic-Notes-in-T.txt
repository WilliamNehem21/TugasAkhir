Despite the necessity of formal methods in developing reliable hardware and software, this field remains opaque to non-experts, including many undergraduates studying closely related disciplines such as pure/applied mathematics and electrical/electronic engineering. These students often perceive formal methods as irrelevant because the presentation by computer scientists is not compelling. While popular mathematical journals exist to engage students and researchers, and the mathematics community is becoming increasingly interested in the appeal of applied mathematics, highlighted by the Society for Industrial and Applied Mathematics (SIAM) creating an educational section in their review, the concern is that formal methods are still seen as esoteric.

This concern should not lead to the conclusion that efforts to popularize formal methods theory are viewed negatively. Programs like the international summer schools in Marktoberdorf and the European summer schools in logic, language, and information exist, but their reach is limited to several hundred advanced students, junior scientists, or professors annually.

The authors suggest that a successful early and engaging introduction to formal methods could be achieved through educational games and puzzles that demonstrate their mathematical foundations. Examples from logic and computer science, such as the muddy children puzzle, synchronous attack, and Byzantine agreement, can motivate and elucidate basic theoretical concepts.

Drawing on experience as trainers for ACM regional programming contests, the authors have designed programming problems for undergraduates that incorporate these principles. These problems involve understanding power-set operations, labeled graphs, and variables to define a validity relation between states and formulas. Although this approach is mathematically sound, the proposed concrete models are impractical for computational reasons, as they lead to an exponential growth in possible positions and moves.

Because of the significance of program logics and model checking (the verification of finite state systems and other applications), model checkers must be highly reliable, especially given the automated nature of model checking. However, developing a polyvariant approach to model checking is costly in terms of time, space, and resources. Additionally, creating tests for model checking is inherently complex and is briefly mentioned as a problematic area.

Lastly, the paper highlights a recent academic contribution where a model checker, formally verified and implemented in the Caml programming language, was derived from an interactive proof in the Coq logic framework. This work, promisingly, is one of the rare instances where formal verification of model checkers has been documented.