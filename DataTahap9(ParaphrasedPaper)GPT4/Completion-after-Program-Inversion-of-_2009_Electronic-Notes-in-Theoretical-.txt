The academic paper discusses the challenge of computing the inverse of an n-ary function f, which involves finding possible inputs given an output. Two distinct methods for this are explored: inverse interpreters, which perform the computation directly, and inversion compilers, which convert programs to achieve the same goal.

Special rules often used in this sort of computation are ignored here, as they are not useful when working with functional programs that use a call-by-value approach; these rules are only relevant for term rewriting computations.

The paper then details, in section 5, the conditions needed for inversion compilers to successfully generate a specific type of term rewriting system (TRS) that reliably converges. The authors describe their method for implementing this process, including practical experiments with injective functions. The process is also adapted back into functional programs.

The discussion includes the idea that patterns in TRSs represent data structures via matching, which is especially important for achieving normal forms during innermost reductions. These patterns remain consistent up to variable renaming.

Further on, the authors investigate the use of completion procedures on TRSs generated by a partial inversion compiler. They test the performance of these procedures post-processing in various experiments.

For injective functions, it's specified that a condition must be met to ensure the resulting inverse TRSs will be terminating and convergent. The paper also examines the relationship between deterministic concurrent term rewriting systems (DCTRSs) and TRSs, showcasing a theorem relating to their properties which helps determine when completion procedures will be successful.

The paper concludes by emphasizing the utility of completion procedures for generating convergent inverse TRSs from injective ones. Interestingly, these procedures also help to check injectivity, because when a TRS is not injective, the completion process should fail. Although determining injectivity is generally undecidable, there are methods for certain cases.

The paper finally addresses an issue with translating TRSs into functional programs due to certain system characteristics, like special symbols or overlapping rules. The proposed modified completion procedure shows success in experimental cases, offering a promising approach for dealing with non-confluent yet innermost-confluent TRSs, even if the specifics of its broader applicability remain unknown.