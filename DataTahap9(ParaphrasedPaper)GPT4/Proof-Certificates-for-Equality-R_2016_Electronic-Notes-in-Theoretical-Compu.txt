Our system for establishing proof credentials scrutinizes the provability of Horn clauses, commonly applied in forming rules for properties like congruence, symmetry, and transitivity, as well as delineating redex lists. This allows for the strategic management of decision points within proofs through the use of simple programs known as experts. Utilizing various definitions of experts and index schemes, we can modularly outline all previously informally referenced proof evidence, along with additional ones.

Our proof checker’s design is straightforward, ensuring soundness across any configuration of experts.

We’ve introduced two new types:

- `type interp cert-> bool-> o.`
- `type bc cert-> bool-> bool-> o.`
- `type clause index-> bool-> o.`
- `type decidee cert-> cert-> index-> o.`
- `type impe cert-> cert-> cert-> o.`

Additionally, there are types defined for different arity relations:

- `type ar1( i-> i)-> int-> index.`
- `type ar2( i-> i-> i)-> int-> index.`
- `type ar3( i-> i-> i-> i)-> int-> index.`

Simple computations can be executed without scrutinizing the certificate terms' structure. Conversely, expert predicates typically inspect these terms to extract information useful for guiding the proof process, including substitution terms, indexes for stored formulas, or cut-formulas. It’s also important to note that if a predicate’s name ends with a capital C, it signifies a clerk; if it ends with a capital E, it signifies an expert. Store predicates function as clerks, while predicates connected to decide, release, and initial rules operate as experts.