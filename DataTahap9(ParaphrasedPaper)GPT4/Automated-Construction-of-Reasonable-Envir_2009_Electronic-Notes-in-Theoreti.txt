This paper discusses an approach for the efficient detection of concurrency errors, such as deadlocks and race conditions, in Java components utilizing the Java Pathfinder (JPF) model checker. The authors focus on generating an artificial environment automatically derived from a high-level model of component behavior. This model aids in creating an environment in which JPF can effectively find concurrency errors without being hindered by state explosion, which typically occurs due to numerous parallel threads or large data domains. However, the research only addresses issues arising from parallelism, not from big data domains.

The methodology involves applying analysis to each method in a Java class, creating control-flow graphs, and scanning Java bytecode to identify shared variable accesses. The number of accesses to shared variables is quantified as an average across control-flow paths for each method to approximate the complexity of concurrency. The paper describes an artificial environment approach allowing JPF to detect all errors and be constructed automatically, though such environments are prone to state explosion due to the creation of many parallel threads.

Experiments were conducted on two real-life Java components: the ConcurrentHashmap class and the Daisy file system, with the latter containing pre-inserted concurrency errors for evaluation. In the case of ConcurrentHashmap, the authors manually induced a race condition. Metrics measured in these experiments include the total time in seconds and memory consumption in MB required by JPF.

The results suggest that using ordered pairs or lists, which prioritize extreme sharing, may be the most efficient approach for detecting concurrency errors. However, the authors acknowledge that since the underlying metric employed is heuristic, these specific combinations may not yield the best outcomes for all components.

The paper indicates the lack of existing concurrency-related complexity metrics for modern object-oriented programming languages like Java and C++, noting that while there are methods for assessing the complexity of concurrent Ada programs, they are not suitable substitutes for the shared variable access (SVA) metric proposed by the authors.

Concluding, the technique detailed in the paper is designed for Java components but can be adapted to other languages which support multi-threaded program verification through an equivalent model checker.