The number of timetabling application instances has surged significantly in recent times. Timetabling involves distributing resources to various objects across a space-time matrix, aiming to fulfill several desired outcomes within certain limitations, in an effort to minimize the associated costs. Given the complexity of timetabling problems, which fall under the NP-complete category, they have traditionally been approached using one of four strategies: evolutionary computing, integer programming, constraint programming, and constraint logic programming.

In our study, we investigate a solution-finding strategy informed by the solution's structure. Our method starts by creating a preliminary seed, which is essentially a selective case of the broader search space and serves as a foundation for more traditional constraint-solving strategies like propagation and labeling. The advantage of our method over stochastic ones—such as evolutionary computing—is that it allows us to quickly reach an initial solution while still enabling a comprehensive search through the employment of effective constraint-solving tactics.

The structure of this paper is divided into sections detailing the specific timetabling case study, our programmed search strategy, system implementations with OPL 3.7 and TOY 2.1.0, performance comparisons, and finally, a section summarizing our findings and suggesting directions for future research.

The paper includes a case study involving the scheduling of workers who operate in different time slots under constraints related to qualification levels, mandatory rest periods after night shifts, and a regulatory framework pertaining to the number of work hours. Assignments of workers to time slots are governed by criteria like the need for a certain quantity of workers each day, the rotation of time slots, special arrangements for weekends and holidays, and provisions for covering absences.

Our devised approach begins with the creation of a seed by rotating time slots for team members per the work calendar while occasionally disregarding certain limitations. Although this seed may not initially satisfy all constraints, it serves as a useful jumping-off point for classical constraint-solving methods to carve out a feasible solution, especially if the seed is already close to a viable solution.

We present actual search algorithm code and discuss performance results obtained using TOY 2.1.0 and OPL 3.7 systems. Our findings show that generating an initial solution is rapid and that our search strategy is effective even when the seed is not a perfect solution, surpassing conventional constraint-solving techniques in speed.

Comparing the two systems, OPL delivered faster outcomes than TOY, attributed to differences like the absence of certain features in TOY, such as array indexing by decision variables and certain types of constraints. Despite OPL's superior performance, TOY offers a more cohesive syntax and integrated constraint system, which enhances program readability and development. However, TOY falls short as it lacks some features present in OPL and corners must be cut for implementation; nevertheless, TOY still performs quite well and is open-source versus OPL’s commercial nature.

We conclude by proposing future research avenues, suggesting enhancements like incorporating data structures that allow direct element access, memory usage optimizations, and the introduction of algebraic components for more concise constraint declarations and faster decision variable processing.