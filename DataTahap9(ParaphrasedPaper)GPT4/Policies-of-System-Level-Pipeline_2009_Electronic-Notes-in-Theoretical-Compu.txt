In research related to system modeling and simulation, it's often observed that moving towards more abstract models enhances performance. However, in software development, the trend can be the opposite; more abstract models can incur an "abstraction penalty," where performance diminishes after a certain point of abstraction. Addressing this penalty to optimize performance is a key objective for modelers.

The paper provides a comprehensive review of techniques and classifications for pipelining and hardware implementation strategies. Additionally, it acknowledges contributions by the compiler research community, which have formulated high-level notations to assist in generating instruction schedulers. The paper also references work that has proposed notations for pipeline specifications intended for downstream tools, along with methods for pipeline specification validation written in architectural description languages. Various methodologies, such as Petri nets and process algebra, are noted for their applications in modeling and simulating pipelines.

The discussion then shifts to SystemC, a discrete event modeling and simulation language used for the design of combined hardware/software systems. In SystemC, modules with ports connected by channels represent system components. Both standard channels for hardware components (e.g., sc_signal for wires) and more complex channels (e.g., blocking FIFOs) are available, along with custom user-defined channels. The internal mechanics of modules, which are essentially classes inheriting from sc_module, can contain threads (sc_thread) or methods (sc_method) that are triggered by event changes. SystemC is also associated with an extensive hardware data type library, inclusive of bit vectors and fixed-point data types.

The paper defines a "pipeline expression" as a representation of the path a transaction takes within a pipeline. For static pipelines, this path remains constant. For multi-function static pipelines, there can be multiple transaction types, each with distinct pathways. The authors highlight a performance modeling approach where a one nanosecond delay is hardcoded into a pipeline stage. To enhance generality, they suggest letting users specify delay intervals. However, this still assumes a simple delay model based on the "wait" statement. They suggest that for untimed models—which should incur no performance penalty during simulation—the compiler could eliminate wait calls. To manage this, they introduce two timing policies: TimedPolicy and UntimedPolicy, with the recognition that modelers can craft more sophisticated policies if necessary.

The citation provided references work by Ashok Halambi et al., outlining a language named "EXPRESSION," designed for exploring architectural concepts through adaptable compilers and simulators. This work has been published in the proceedings of the European Conference on Design, Automation and Test (DATE) by the IEEE Computer Society in March 1999.