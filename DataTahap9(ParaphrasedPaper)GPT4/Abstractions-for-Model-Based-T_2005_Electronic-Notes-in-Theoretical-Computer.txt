The paper discusses the role of abstractions in the context of model-based testing and software development. It examines how methods such as model checking and theorem proving utilize formalized abstractions, such as transition systems or behavioral models, to verify software. These techniques assume that the tested software is part of a well-behaved environment that matches the assumptions of the model. However, these verification technologies work on simplified versions of the real-world environment and cannot guarantee the environment's actual behavior.

The contribution of the paper is an examination and discussion of abstractions applicable to model-based testing and their relationship to other development models. It explores the nature and limitations of abstraction in development and testing, suggesting that both actual device testing and abstraction-based verification are necessary for ensuring software quality.

Abstractions can be automatic, where missing information is auto-inserted, or deliberate simplifications to keep the model manageable. These simplifications are often domain-specific, and the paper highlights the challenge of developing domain-specific abstractions that can be automatically translated to the concrete level by compilers and linkers.

The paper posits that focusing on abstractly specifying error-prone system parts can offer advantages by keeping test models small and manageable. However, caution is advisable when using the same models for both code generation and test case extraction.

Additionally, the paper includes case studies on testing protocols for smart cards and posix standards. It discusses issues of intense data abstraction, which can result in loss of necessary information for test case generation, the difficulty in detecting feature interactions with separate functional abstractions, and the problems that arise when using temporal abstractions in real-time and distributed systems.

Despite these limitations, the authors argue that model-based testing is a promising methodology for verifying complex systems and improving the quality of hardware and software.

The paper also reflects on how software engineering activities utilize abstractions in different forms, such as language constructs, runtime environment entities, library interfaces, and system architectures. It highlights the relationship between specifications—often informal and incomplete—and test models, which are derivations from the specifications that comprehensively implement the specified parts.

In conclusion, the paper suggests that while test models are crucial for verifying specific system aspects accurately, real-world testing and refined abstractions both play important roles in developing high-quality software systems.