This section provides a condensed introduction to the concept of graph transformation with cloning. Section 3 delves into the specific issue of statechart flattening. Section 4 discusses the use of graph transformation with cloning as a potential solution. The final section summarizes the findings of the paper.

The introductory commentary outlines graph transformation with cloning, directing readers to more comprehensive details elsewhere. This concept involves pattern-based rule schemes that represent countless rule instances through the cloning of subgraphs. The section goes on to detail the components that comprise the left and right sides of these rule schemes.

A rule scheme is identified as a double-pushout rule consisting of patterns as its left-hand side (LHS), interface, and right-hand side (RHS), and employs pattern morphisms, which extend the concept of graph morphisms. The RHS's cardinality variables must also appear in the LHS. A rule instance is created by binding the RHS variables to match the LHS values and then instantiating the patterns of the LHS, interface, and RHS.

The definition is further simplified: only events are considered, with no regard for firing conditions or actions. Additionally, transitions cannot extend across and-states or or-states, and the more complex treatment of competing transitions is disregarded, including the priority normally given to transitions from higher hierarchical levels in UML statecharts. Instead, non-determinism is presumed.

Section 2 explored rule schemes, which are now applied to define the individual transformation steps in flattening hierarchical statecharts, though the paper doesn't detail a full algorithm or a control program in a formal programming language. Instead, it relies on informal notation, emphasizing rule schemes and their role in graph-based programming, with further details of the algorithm provided in Section 3.

Conditions ensure the target and-state contains no nested and-states or or-states. For conciseness, the paper omits elementary rules. If the rule "mark bottom level and" fails to apply, the control simply moves on without it, indicating no valid bottom level and-state exists.

The paper concludes that it addresses statechart flattening as a case study for graph transformation-based programming, acknowledging that due to space constraints, only a simplified statechart representation is addressed. It mentions that other elements, such as history states, final states, firing conditions, transition actions, as well as entry and exit actions for hierarchical states, could be incorporated straightforwardly, with the intent to present a full specification in future work.