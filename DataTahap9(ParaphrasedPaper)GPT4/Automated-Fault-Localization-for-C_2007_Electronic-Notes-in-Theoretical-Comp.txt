This paper introduces an automated method for identifying and correcting faults in C programs. It capitalizes on model checking techniques, employing the bounded model checker CBMC on a modified version of the suspect program to discern components responsible for discrepancies between actual and intended software behavior. Experimental results support this approach's effectiveness.

Traditional debugging entails fault detection, localization, and correction. Despite prior research advancements in fault detection, less attention has been paid to fault localization and correction. This paper concentrates on localization, offering a unique approach to pinpoint the root causes of faults in C programs.

The process initiates with a faulty C program and a corresponding specification. When a counterexample surfaces—evidence the program dissatisfies the specification—this technique generates an extended program version with fixed inputs derived from the counterexample and integrates "abnormal predicates" for program components. Abnormal predicates indicate abnormal component functionality; the method involves substituting their behavior with new inputs to make the specification hold. The method employs model checking to identify components that cause faults and proposes necessary changes to rectify them.

Previous research included a game-based approach for debugging, able to localize faults and offer universal corrections. However, this approach, especially when extended to handle recursive Boolean programs, proves less efficient than the present method, where corrections apply specifically to individual counterexamples.

Other studies have focused not on fault location but on understanding failure characteristics, examining counterexamples to pinpoint error-inducing segments. These methods differentiate between a failure-inducing input and a successful one and analyze similar program runs for deeper causal insights.

The paper outlines the detailed procedure for using model checking in fault localization, with a specific implementation for localizing faults in C programs. It explains using the CBMC tool and the logic behind bounded model checking for software. It further elucidates how to hurdle potential issues like unwinding assertions, indicating when the unwinding depth for loops is sufficient.

The authors demonstrate their approach through two examples. One from the TCAS task of the Siemens test suite, a well-referenced benchmark in software testing literature. The suite includes various C program versions with deliberately introduced faults. The paper also explores the example of diagnosing and correcting a data structure implementation.

The paper concludes that the presented method effectively locates faults in C programs by enabling arbitrary changes to certain expressions in the context of specific counterexamples. The methodology suggests that computational efficiency could be improved by optimizing the underlying processes, such as parsing and internal program representation management, hinting at future work to perfect and streamline the approach further.