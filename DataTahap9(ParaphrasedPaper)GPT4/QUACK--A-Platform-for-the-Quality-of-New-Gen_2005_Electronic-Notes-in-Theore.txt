The paper describes enhancements to the Object Constraint Language (OCL) version 2.0 by introducing two new classes—Time and Offset—into its standard library. The Time class is used to model specific instances in time, while the Offset class represents the duration between time instances. Both classes are essential for incorporating temporal logic, enabling the expression of behaviors over time such as "always", "sometimes", and "until."

These new classes allow for the creation of time-quantitative statements, granting users the ability to specify constraints such as "Event B must happen no more than L time units after Event A." These time-related aspects can be modeled as either discrete or continuous, depending on the application, offering flexibility and richness in temporal expression.

OTL formulas, which are built using these classes, are assessed relative to an implicit current time. The Time class includes a primitive operation called 'eval' that enables the evaluation of OCL predicates at times other than the current moment. For example, when a Time object 't' and a predicate 'p' are given, the expression 't.eval(p)' would ascertain if predicate 'p' is true at the time represented by 't'.

The paper also discusses an extension of the Temporal Interoperability Language for Components (TILCO), referred to as Communicating TILCO (CTILCO). This extension offers a model for describing complex system interactions and the communication processes within them. Specifications in CTILCO are derived from multiple interconnected processes, and theorem proving can validate the correctness of these interactions.

Research in component-based real-time embedded systems has traditionally focused on the design phase and is only now beginning to consider real-time constraints such as deadlines, particularly in safety-critical systems. This practice has yet to yield significant practical results.

The Object Management Group (OMG) proposed the UML-RT profile for incorporating time, performance, and schedulability in the Unified Modeling Language (UML), although its suitability for component-based designs is limited. The QUACK methodology developed in the context of the paper offers an approach to specify and analyze real-time systems with multi-threaded components, each with their own scheduling strategies. This method guarantees that each component receives a minimum share of processor time and is shielded from other components.

The paper notes that setting up testing environments can be challenging due to the complexity and potential for error in configuring message interactions. To mitigate these issues, a technique is presented that creates default environments for each message level, reducing the possibility of error in the results.

The techniques discussed in the paper have been applied to various case studies, including systems from industrial partners, well-known literature examples, and public applications showcasing component technology. The preliminary results are encouraging, and the authors are looking to continue their experiments to improve their understanding and refine their methodologies.