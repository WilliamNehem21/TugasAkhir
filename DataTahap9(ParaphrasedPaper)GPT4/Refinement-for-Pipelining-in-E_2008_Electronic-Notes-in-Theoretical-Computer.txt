The AWE control systems team is conducting formal analysis on a hardware Java Virtual Machine (JVM) to study how the processor behaves based on the JVM's official documentation, which includes over 200 bytecodes. The paper discusses a smaller example for illustration but it is large enough to showcase challenges in developing pipelined hardware using refinement techniques.

The paper indicates that the formal methods ACL2 and Event-B share similarities, such as the use of a 'gluing invariant' in Event-B which corresponds to the 'refinement map' in ACL2. This invariant connects states in a refined (concrete) Event-B model to an abstract model, and refining often involves introducing new events.

The structure of the paper follows: it introduces Event-B and refinement, then an informal processor instruction set is given in Section 2. This section also details how the abstract Event-B specification for the given instruction set is constructed. It then describes how Event-B refinement is used to formalize a proposed pipelined hardware architecture, and a proceeding refinement proof exposes potential issues in the pipeline. Section 3 proposes 'event merging' as a solution to these issues, while Section 4 warns against too much merging, which can cause other problems.

The paper clarifies that it does not question the validity of the superposition refinement principle; rather, it focuses on formally refining an instruction set specification to hardware, albeit not to the granularity of languages like VHDL. However, the proposed refinement could be integrated into future methods that derive hardware from Event-B specifications.

An Event-B model comprises a static 'context' and a dynamic 'machine', with the machine 'seeing' the context, meaning it can access all of the context's sets, constants, and properties. The machine also outlines the state variables it contains, defines initial state values, and describes how state values change through events. The ultimate goal is to prove specification properties, which the invariant clause expresses. Proof obligations—created by the supporting tool—are then verified to ensure the specification's integrity.

Refinement in Event-B involves adding implementation details to an abstract specification without deviating from the abstract behavior. The context and machine can be refined separately, with context refinement involving additions of sets, constants, or properties, and machine refinement relying on a 'gluing invariant' that maintains a relationship between the abstract and refined models.

The events in an Event-B model are enabled based on certain conditions, such as whether the current instruction matches the expected opcode. For instance, an 'ADD' event would only be triggered if the instruction at the program counter signifies an addition operation, while branch instructions may have separate events based on the conditions they test (such as zero or non-zero values).

Finally, the paper illustrates that merging events can model pipeline behavior more accurately, uncover conflicts, and guide modifications to guards or the pipeline to ensure correct execution. Alternatively, redefining the abstract specification could be a solution but risks losing the connection to the informal instruction set description.