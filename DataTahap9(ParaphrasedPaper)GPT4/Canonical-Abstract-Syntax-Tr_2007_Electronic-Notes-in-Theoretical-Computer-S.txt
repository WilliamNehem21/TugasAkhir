This paper introduces GOM, a language for defining abstract syntax trees (ASTs) and for the automatic generation of a Java implementation of those trees. GOM is designed to enable users to specify the interface of data structures and ensure these structures remain in their canonical form according to a rewrite system. This guarantees that client programs only work with the normal forms of the respective rewrite system, a practice that is usually applied implicitly in many systems.

A distinctive feature of GOM is its independence from specific data structures, which necessitates the creation of a bridge between abstract algebraic data structures used in pattern matching and the concrete data structures used in implementations. Given an abstract definition, one must effectively implement a corresponding and efficient data structure in the target language, such as Java or C, as these languages do not offer native support for algebraic data types.

GOM also offers a way to define normalization functions for operations on data structures, ensuring all data handled by the user is normalized with respect to those functions. GOM's functionality encompasses that of other systems like ApiGen and VAS, emphasizing maximal sharing of data structure implementations. Additionally, GOM supports the visitor combinator pattern used by the strategy language of TOM.

TOM extends imperative programming languages with pattern matching, a feature naturally suited to languages used for manipulating structured entities like trees, hierarchized objects, or XML documents. TOM uses the concept of algebraic signatures to describe the construction of tree-like data structures, which includes the sorts of nodes and the operators that define children and node shapes.

Drawing from systems like ApiGen and VAS, GOM employs the ATerm Library to provide an efficient implementation of unsorted terms for C and Java. The generated data structures offer strong typing and subterm sharing, as well as support for the visitor combinator pattern to allow advanced tree traversal.

The paper then discusses an implementation example of a prover for the calculus of structures using GOM and TOM, illustrating how certain rules can be made intrinsic to the data structure for more efficient implementation and correctness. The paper also presents hooks as a means for implementing sorting and normalizing operations.

In summary, GOM is a low-level language for defining algebraic signatures and normalization systems, utilizing Java and TOM to define normalization rules. It allows for an efficient data structure implementation while preserving essential properties like maximal subterm sharing and strong typing. When used with TOM, GOM offers the advantage of integrating formal algebraic methods into widely used languages, contributing to the formal verification of algorithms via rewriting techniques while also producing a practical Java implementation.