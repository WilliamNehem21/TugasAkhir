The paper's structure is as follows:

1. Section 2 explains the need for tokenizing Java Card class files by contrasting the method resolution of Java Card class files with the process for Java Card Compiled Application Package (CAP) files.
2. Section 3 introduces the formal description, using the Prototype Verification System (PVS), of the class file and CAP formats, which are utilized by the CAP converter.
3. Section 4 details the creation and the proof of correctness for the tokenization process employed by the converter.
4. Section 5 focuses on the concept of componentization, specifically detailing how the constant pool component is created and implemented through the merging of constant pools from different classes within a package.

The PVS specifications of class file and CAP formats model them as abstract data types with defined constructors, associated recognizers, and accessors, significantly simplifying Java Card class and CAP files for the sake of formal analysis.

In their representation, class hierarchies appear as a forest structure that can be described using a node hierarchy, where each node consists of a class, its children, and its siblings.

Regarding the Java bytecode format, all constants (such as integers, strings, class, and method names) are stored in an array, known as a constant pool, which is unique per class. Within the methods' bytecode, each constant occurrence is substituted by its index within the constant pool.

Componentization in the Java Card involves partitioning a package of class files into various components. This paper concentrates on the process of creating a global package constant pool by merging the individual constant pools from each class in the hierarchy. Additionally, it outlines a correct offset function that locates constants within the global pool corresponding to their original class pools.

Within section 5.1, a theory is developed to address array copying and merging issues, which is then applied in section 5.2 to achieve the componentization function and its verification for class hierarchies.

For the proposed array copy function, a more precise type could be used to define its results, ensuring the correct outcome and original values in their respective places. The correctness of this function and its ability to concatenate two constant pools are supported by lemmas demonstrating that the copied array retains both the new and original values as intended.

An assumption is made for the componentization function that there exists a one-to-one correspondence between class names and classes. A main theorem asserts that for any valid class hierarchy, the contents of any class file constant pool can be accurately located within the global, componentized constant pool using the offset function.

However, proving this theorem leads to non-trivial proof obligations necessitating preliminary lemmas to establish that the offset function is complete with respect to class names and the calculations for offset are within the bounds of the global constant pool.

The paper presents the specification and verification of key algorithms in a CAP converter using PVS. These include the tokenization and componentization of Java Card class files. The tokenization process has been proven correct adhering to the constraints of the Java Card CAP format, and the componentization algorithm is specifically validated for merging constant pools.