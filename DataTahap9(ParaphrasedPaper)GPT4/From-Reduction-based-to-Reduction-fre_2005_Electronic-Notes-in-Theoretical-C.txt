This academic paper discusses a method to streamline the process of normalization for programming language terms by refocusing the traditional two-step decomposition and reassembly process into a single, direct refocus function within an abstract machine framework. The authors recount their positive experience with this approach, having applied it to both weak-head and full normalization of lambda-calculus. Through illustrative examples utilizing arithmetic expressions and terms from the free monoid, they detail how to transition from a reduction-based normalization function to a reduction-free normalization function, eliminating the need for the intermediate terms that are typically generated during the reduction process.

To illustrate their method for arithmetic expressions, they provide a detailed implementation of the reduction semantics in Standard ML. They demonstrate how to shift from a reduction-based normalization function to a reduction-free variant by transforming it into an abstract machine, which is eventually refunctionalized into a direct-style normalization function that no longer relies on reductions.

For the free monoid, the authors take a similar approach, defining reduction semantics for terms in the monoid and presenting a refocusing process that results in a traditional, reduction-free flatten function, equipped with an accumulator for efficient execution.

The paper underscores the systematic nature of constructing reduction-free normalization functions from reduction-based counterparts and emphasizes the broader applicability of this approach by referencing previous works on the lambda-calculus and continuation-passing style transformations.

The cited technical reports by Malgorzata Biernacka, Dariusz Biernacki, and Olivier Danvy provide foundational concepts for delimited continuations in the CPS hierarchy, while work by Danvy and Lasse R. Nielsen outlines the refocusing technique in reduction semantics. These contributions collectively aim to streamline computational processes and provide operational foundations for abstractions used in programming language semantics and transformations.