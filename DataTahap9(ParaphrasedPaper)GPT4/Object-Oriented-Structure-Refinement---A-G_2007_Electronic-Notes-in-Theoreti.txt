In the paper, the authors discuss modeling the structure of objects, their attributes, and their relationships within the Object Management Language (UML) as a class graph, while an instantiation of a class graph is referred to as an object graph. The class graph dictates the general characteristics of objects and their collaboration for use cases.

The main focus is defining these class graphs and object graphs as directed labeled graphs and examining how structural changes can preserve the ability to provide services. This concept is called structure refinement, which is a graph transformation that maintains (or improves) service provision capabilities. The authors offer a set of structure refinement rules and validate that these rules are both sound and complete for a specific type of structure refinement.

Structure refinement is emphasized as critical for maintaining and enhancing object-oriented design, making it more maintainable, reusable, and cohesive. They introduce a structure refinement calculus through graph transformations. The paper presents class declarations as directed labeled graphs, called class graphs, with nodes labeled as class or primitive data type names and edges labeled with attribute names or a symbol "q" for inheritance.

The paper is organized into five sections: Section 2 explains the representation of class declaration sections as directed labeled graphs. In Section 3, object graphs for class graphs are defined to represent system states, along with an operational semantics for programming commands based on these graphs. Section 4 talks about defining and understanding structure refinements between class graphs. Section 5 confirms the soundness of the identified refinement rules and their completeness in the context of structure refinement.

Additionally, the authors aim to simplify the semantics and refinement of object-oriented programs, making them more understandable and operationally viable, and to foster development tools to support object system development through transformations.

The paper also proposes operational semantics for object-oriented programming using graph theoretical notation, aligning the execution understanding of object programs with that of imperative programs. Further work intends to explore this operational semantics in more detail and create a Hoare logic for object-oriented programming that incorporates graph predicates.