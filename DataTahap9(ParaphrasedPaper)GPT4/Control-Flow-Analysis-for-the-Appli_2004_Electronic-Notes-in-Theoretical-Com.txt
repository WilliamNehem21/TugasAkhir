According to the intuitive semantics presented, in the first given example (a1), executing fst(x) at runtime results in retrieving a specific identifier (n2). In the second example (a2), a process demonstrates the generation of a new identifier (n2), its encryption using a private key (pri(n1)), and its transmission. Another process then receives the encrypted identifier, verifies the signature using the corresponding public key (pub(n1)), and utilizes the identifier (n2). For the process in example a2 to be successful, the expression that checks the signature (check(sign(n2, pri(n1)), pub(n1))) must resolve to 'ok', and the operation that strips the signature from the signed identifier (removesign(sign(n2, pri(n1)))) must yield the original identifier (n2).

Despite opting not to implement general substitution (general-subst), we recognize its importance and cannot simply dismiss it. Our goal is to avoid introducing new variables through left-to-right application of general substitution. However, we still need to allow for the removal of variables and applying substitution operations to contiguous processes through right-to-left application of general substitution. For this reason, we introduce a specific reduction relation.

There is no rule involving the '0' action because it signifies an inactive state incapable of performing any action. Furthermore, we observe that a conditional action only takes place when the terms are fully instantiated, and in other cases, it behaves idly like '0'. Similarly, inputs and outputs remain inactive, represented as '0', unless the subject is an established identifier (or becomes one through reduction).

In this paper, we confirm the soundness of the CFA outlined in Section 4 by aligning it with the formal semantics detailed in Section 3. This is done through a subject reduction proof. The majority of the proofs are founded on either structural or rule induction and are relatively straightforward. Where proofs are more complex, we only offer an outline.

The scenario involves two entities (A and B) who each share a unique long-term symmetric key with a trusted server (S). Entity A knows the key KAS, which is only shared with server S, while entity B has a unique key KBS, known only to B and S. Entity A creates another key (KAB) intended for shared use with B. To securely transmit this key, A encrypts it using the shared key with server S and sends it. The server S decrypts the received key and then re-encrypts it using the key shared with B (KBS), forwarding it to B. Entity B then receives this key from S along with an encrypted term (m) from A. Following this, the continuation B' (representing B's subsequent actions) involves decrypting the server's key followed by the decryption of term m.