Over the last decade and a half, numerous languages and models have been designed for coordination, offering formal methods to connect components and a framework for formal verification. This paper explores the verification aspect of the coordination language called Reo, which describes how components interact using a network of channels constructed by chaining together channel instances and nodes. Reo has been semantically characterized in various, yet compatible, methods.

The structure of the paper is as follows: Section 2 introduces Reo and constraint automata, which is the operational model for Reo networks. Section 3 discusses the syntactic and semantic features of the logic known as BTSL. Section 4 presents the primary steps of the BTSL model checking algorithm and our experience with its symbolic implementation; results from experiments are in Section 5, and Section 6 offers concluding remarks.

The BTSL model checking problem involves analyzing a Reo network, and potentially any related constraint automata that define the interfaces of components at network nodes, against a BTSL formula. The constraint automata can influence the behavior of the network by limiting possible transitions, thus affecting the nondeterminism within the network's automaton. When both sink and source nodes are connected to a component, these nodes are considered 'mixed nodes' and can impact the set of potential terminal states of the network. If nothing is known about the behavior of components, this detail can be omitted to consider all possible interactions of the network's nodes.

We tested the BTSL model checker on several examples and will detail two case studies here. All tests were run on a Pentium IV with 1.5GB RAM, using Mandriva Linux and a specific kernel version. The tool, written in C++ and utilizing binary decision diagrams libraries, found a deadlock scenario in one example where philosophers took one chopstick and waited indefinitely for the other; the deadlock was discovered through a backward analysis after 798 iterations but could be identified in only 403 steps within 13.92 seconds using a forward analysis.