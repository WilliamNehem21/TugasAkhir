Contemporary program verification tools commonly convert a target program and its specifications to a simpler, intermediate representation before generating verification conditions based on this representation. This approach enhances tool interoperability and helps in creating smaller, more manageable verification conditions. However, the translation process to the intermediate language is critical to the verifier's accuracy and has not been rigorously validated. This paper provides a formal analysis of converting a Java bytecode subset into an imperative intermediate language akin to BoogiePL, affirming the translation's correctness by ensuring that methods verifiable in the intermediate representation are also verifiable when applied directly to bytecode.

The verification process often involves a multi-step approach where the program and its specifications are translated into an intermediate form like guarded commands, BoogiePL, or the Why language. Tools such as Krakatoa and Caduceus can share components like the Why backend by standardizing on a common intermediate representation. The paper details the mapping of Java bytecode to an untyped BoogiePL-like language and validates the correctness of this transformation, showing that the verification conditions of the altered program are at least as stringent as the original's.

This untyped intermediate form is selected to keep the focus on core translation principles. BoogiePL is structured around a prelude and a sequence of procedures, the former defining the context with global variables, constants, axioms, and uninterpreted functions, and the latter housing specifications and implementations. The paper introduces a verification calculus but omits procedure specifications in conversions. The described translation eliminates back-edges in favor of assertions for loops, translates other control flow elements appropriately, and deals with method calls by accounting for potential side effects and abrupt terminations.

A proof of correctness is included for a significant subset of Java bytecode, with an overview of a case for an instruction like iload n. The process is detailed enough to handle exceptions and maintains reasonable complexity by using analogous state models for both the bytecode and BoogiePL translations, leveraging the guarantees provided by the bytecode verifier. Thus, the paper contributes to bridging a gap in the soundness assurance of various program verifiers.