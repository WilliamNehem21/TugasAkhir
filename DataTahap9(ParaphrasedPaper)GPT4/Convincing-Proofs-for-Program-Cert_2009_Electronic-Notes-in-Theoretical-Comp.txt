The paper discusses an approach that is similar to existing deductive methods employing the weakest precondition calculus, referencing tools like Caduceus/Why and Caveat, which are used for verifying C programs, particularly in critical applications. These tools strike a balance between automation and assurance, but they do not generate independently verifiable proofs of correctness for the original program. For instance, Caveat relies on in-house decision procedures and simplifications, while Caduceus/Why makes transformations on the program before producing verification conditions, thereby implying its correctness. These issues are addressed by the Proof-Carrying Code (PCC) framework and its extension, Foundational Proof-Carrying Code (FPCC), which involve formally verifying a program's proof before execution.

This paper is informed by the FPCC framework but deviates in significant ways due to specific criteria for convincing proofs. The authors choose to bypass formalizing operational semantics for all C operators and constructs and focus on the proof-checker's transparency instead of optimizing for compact proofs, as the latter's complexity could hinder certification. The paper claims novelty in producing a checkable proof in foundational logic for a substantial C program, in this case, an event-driven system protocol, without altering the C code and minimizing the Trusted Computing Base (TCB) to essentially a compiler and a machine.

The remainder of the paper illustrates the application of this process to prove the correctness of a complex communication protocol used in C for multitasking real-time data-flow applications within an event-based operating system. The protocol manages tasks with identifiers that are triggered by events, with computations presumed to be instantaneous, simplifying development by focusing solely on data-flow between tasks.

Much of the proof was automated, facilitated by a symbolic interpreter for C programs that was specifically developed. The interpreter records user interactions for conditional instructions and constructs a proof-term that incorporates proof obligations to be fulfilled later. Some parts, including inductions and demonstrations of independence, were manually executed with lemmata support.

The authors present their decision against using provers like PVS or B, as these do not produce separate proof-terms. Using them would have necessitated adding the prover to the TCB. They initially tried using the Coq proof assistant, which does generate proof-terms. However, they found its overhead, formalization complexity, and the abundance of proof obligations unsuitable for their aims. Moreover, Coq's proof-checker lacks certification, further complicating its use for this project.