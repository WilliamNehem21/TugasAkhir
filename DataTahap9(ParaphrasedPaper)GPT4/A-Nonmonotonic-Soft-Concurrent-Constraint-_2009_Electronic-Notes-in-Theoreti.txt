In this summarization, we present an updated version of the soft concurrent constraint programming language to enable changes in the constraint store that are not strictly additive. Our enhancements include the following operations: 'retract(c)', which removes the constraint 'c' from the store; 'update_x(c)', which first relaxes the constraints concerning the variables in set 'x' before adding the constraint 'c'; and 'nask(c)', which verifies if the constraint 'c' is not currently implied by the store. These modifications are proposed as a potential approach for managing resources like web services.

The origin of these ideas is found in previous works that have developed nonmonotonic frameworks for concurrent constraint programming, including the introduction of operations analogous to our 'nask' and 'update'. While prior research avoided adding further nondeterminism by tracking dependencies, our extension embraces additional nondeterminism, which we consider more aligned with the reality of interactions in open systems.

Classical soft concurrent constraint programming (SCCP) does not allow for the removal of constraints, so the focus is on pruning computations that excessively decrease consistency. In contrast, our nonmonotonic soft concurrent constraint programming (NMSCCP) includes the ability to remove constraints, potentially increasing consistency levels and negating the need for a fail agent. Thus, it is essential to ensure that the consistency does not surpass certain thresholds.

Our model incorporates parallelism and nondeterminism, with operators for each. In parallelism, an agent succeeds only if all its components succeed, using an interleaving approach similar to classical CCP. Nondeterminism is modeled by a rule that selects one of the agents with successful guards, leading to global nondeterminism.

One application example for 'nask' is in negotiation scenarios, where it can determine the absence of information and ensure policies remain valid within the store.

Nonmonotonicity has been studied in the context of crisp constraints within linear concurrent constraint programming and is related to service level agreement (SLA) negotiation models. Although some works address SLA negotiation, they either focus on interactions and QoS parameters or describe SLAs and their negotiation separately. In contrast, soft constraint systems can address both areas simultaneously.

We have opted to extend SCCP with soft constraints due to their ability to represent varying consistency levels and express preferences, fuzziness, and uncertainty. Embedding preference values directly within the language can effectively manage SLA negotiations, particularly when associating a given quality of service (QoS) with resources. Through the parameterization of the semiring structure, soft constraints are versatile enough to model a range of problems.