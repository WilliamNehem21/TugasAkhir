In this study, we introduce a novel method for verifying software based on an assertion language that enables users to define specific program properties through a logic program. This flexible assertion language can express a broad range of properties applicable to various types of programs. Once properties are articulated using user-defined predicates, we derive necessary inductive conditions for demonstrating partial program correctness, which we then have to substantiate.

Verification using these conditions poses challenges due to the complexity of efficiently determining their truth. However, we demonstrate that program transformation techniques, such as fold/unfold rules, can successfully establish these conditions. To do so, we modify the program syntactically while maintaining its intended meaning.

Existing literature reflects various approaches where assertion languages incorporate user-programmable properties, yet our strategy is distinct. Previous models have used assertions at runtime to compare program results against specifications dynamically; our model instead utilizes a syntactical approach to establish the conditions for partial correctness.

To validate program behavior against expected outcomes, we can employ methods based on abstract interpretation, which systematically derive conditions for verifying partial correctness across different property types. These methods benefit from the advantages of abstract interpretation, which includes defining a verification framework parameterized by the abstract property of interest.

While abstract domains from static analysis, such as modes and types, can be adopted for program verification to outline property approximations, this can result in a trade-off between precision and achieving finite specifications.

Allowing users to define properties via logic programs transcends the expressivity of traditional assertion languages with predefined properties. This paper addresses the potential of extensions to verification through such user-defined properties. In contrast to prior approaches that check assertions at runtime, our method aims to derive information on the intended behavior through syntactic transformations to substantiate verification conditions.

This paper presents various examples demonstrating how the proposed verification method operates, emphasizing that many conditions can be proven straightforwardly through a few unfolding steps, suggesting potential for automation or semi-automation in the process.

We illustrate the need for a system that can model partial answers to encapsulate infinite program behaviors; however, sufficient verification conditions remain consistent with those previously specified. Even though we confirm partial correctness concerning the specification, we recognize the limitations, noting that ensuring the verification of preconditions for every procedure call (call correctness) is beyond this method's guarantee.

We acknowledge the need for semantics accounting for natural number arithmetic to condense notation; this was chosen over using a first-order number representation and a user-defined predicate for arithmetic operations to utilize computed answer semantics.

Based on the examples provided, while some verification conditions are easily confirmed through basic transformation techniques like unfolding, others require more complex strategies like goal replacement. Nevertheless, the unfolding/fold proof method can often generate the necessary intermediate lemmata for these transformations. These insights indicate that the process of verifying conditions presented in our method can be semi-automated by leveraging recent advancements in logic program transformation systems.