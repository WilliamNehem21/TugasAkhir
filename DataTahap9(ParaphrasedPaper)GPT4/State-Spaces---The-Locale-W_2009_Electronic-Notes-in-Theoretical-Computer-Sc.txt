This paper discusses the fundamental importance of properly representing state spaces in the verification of imperative programs to ensure the effectiveness of the corresponding verification environment. It reviews various existing state space models, evaluating criteria such as strong typing, modularity, and scalability. Furthermore, it introduces an improved model based on the locale infrastructure of the proof assistant Isabelle that combines the strengths of earlier models while overcoming their weaknesses and offering more flexibility in combining state space components due to the modularity of locales.

However, the paper acknowledges that there is no one-size-fits-all solution for state space representation, and it cites the specific example of the Verisoft project where the authors encountered challenges in representing C0 program states as records within a general Hoare logic environment in Isabelle/HOL. They highlight the problems with compositionality and scalability when handling large verification tasks.

The paper outlines the basics of state space operations such as variable lookup and update, and the expression of frame conditions. The issue of strong typing is addressed, and how it structures the state in typed programming languages, suggesting a direct mapping of program types to HOL types to leverage the logic for program verification.

On modularity, the paper discusses the challenges of creating a uniform state representation for composite systems, where the direct composition of state spaces or a name-renaming calculus may be required. It critiques representations that handle diverse values, such as integers, booleans, and arrays with embedded type constructors, highlighting the potential lack of type safety and the overhead of dealing with type correctness during verification.

The authors criticize the use of records for state representation in Isabelle/HOL, pointing out issues with their scalability and technical difficulty in implementation, despite their advantages over raw tuples. They suggest alternative tuple nesting approaches for more balanced performance.

Finally, they describe the use of locales in Isabelle to compose and interpret procedures by merging and renaming locales, and providing two examples of the list reversal procedure for different applications. The paper concludes by advocating a state space representation approach that marries basic logical concepts with an extra-logical layer for type checking and notation in Isabelle, allowing a simpler logical model that avoids the complexities of dependent function types.