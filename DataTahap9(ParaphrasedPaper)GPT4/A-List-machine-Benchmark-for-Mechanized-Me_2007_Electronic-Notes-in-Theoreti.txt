This academic paper presents a new benchmark for assessing the capabilities of theorem-proving systems, particularly focusing on their effectiveness in proving compiler correctness. The authors emphasize the integration of proof with compiler implementations and suggest that significant progress can be made without the need to manage variable binders or perform alpha-conversion. The paper outlines specific metrics for evaluating mechanized metatheory systems and discusses solutions implemented using Coq and Twelf. Insights on the two systems are shared based on these implementations.

The authors describe a type system that assigns a list type to each variable at a given point in a program to ensure operation safety. They introduce list type refinements, such as nonempty and empty lists, to guarantee the correctness of operations like fetch-field, which require a nonempty list.

A sample program is presented, consisting of three basic blocks, demonstrating initialization and iterative processes with a loop and loop exit that halts the program. One instruction within block 1 is identified as dead code.

The paper discusses the use of Logical Framework (LF), in which one can compute on derivation trees and illustrates how a Prolog program can input a derivation tree for type-checking and output a derivation tree confirming the safety of a well-typed program. The authors explain the usage of machine-checked %mode and %total declarations in Twelf to specify input/output relationships and ensure comprehensive and non-terminating coverage of meta-programs.

Operational semantics are easily represented in both Twelf and Coq using inductive definitions. Coq provides additional flexibility to depict operations over mappings as either relations or functions.

Type-checking in Twelf is straightforward due to running the type system as a logic program, while in Coq, it is more complex because the type system specification is non-algorithmic, relying on the universal quantification over all variables to express environment subtyping.

The authors further explain how the modes in a logic program designate input and output arguments. They emphasize the importance of a termination check in the metatheorem to prevent infinite loops and to ensure that all cases are addressed.

In Coq, the soundness theorem for the type system is stated using conventional mathematical language. In contrast, Twelf achieves this through logical predicates that relate type-checking to the program's ability to run or halt, supported by the %mode and %total checks.

Type-checking in Coq involves a function using intermediate functions with monadic error propagation and efficient representation of environments to ensure O(n log n) complexity. The authors note Coq's capability to extract executable Caml code from Coq functions, yielding an industrial-strength type-checker with performance akin to hand-written Caml code.