In our previous research, we demonstrated the computational soundness of a non-confluent, call-by-value records calculus, through a novel proof technique involving diagrams that hinges on the "lift" and "project" properties. This method has since been elaborated into a series of abstract diagrammatic proof techniques. Our current paper does not address hidden record components and focuses exclusively on mutual recursion's computational soundness.

Lemma 3.4 establishes that if two expressions with their redexes are equal, then the expressions and their redexes must be individually equal. This implies that a record's component can only take one evaluation path. At the abstract level, while distinct classes may contain elements like constants with clear differences in meaning, lambda abstractions are typically classed together due to their indistinguishable nature until application.

Notwithstanding, transformations are considered meaning-preserving only if their results remain consistent across all possible record combinations. Hence, calculations must retain the actual function of abstractions when placed within records. The concept of record contexts encapsulates this idea, although its full details are excluded here due to space constraints.

Lemmas 4.1 and 4.2 confirm that each record either converges to a unique normal form or diverges consistently, treating labels bound to non-terminating processes as divergence. Thus, a term's meaning is determined by its evaluative result.

The extension and refinement of the lift and project technique suggest its utility, but applying this method to prove meaning preservation within our record system requires additional work.

The paper verifies that term reduction retains meaning through the use of marked redexes and residuals, in a process akin to that employed for the call-by-value calculus referenced in our earlier work. For substitution, the method assures that it sustains the record's outcome, leveraging an efficient evaluation strategy to ensure single evaluations per component.

Our findings confirm the computational soundness of the call-by-name calculus for records with recursive scope. As we look ahead, we aim to explore the application of our proof methods to more intricate systems with potential cyclic dependencies, like the letrec calculus, and advanced models that represent modules and linking. Additionally, we intend to compare our context method against alternative strategies for establishing computational soundness.