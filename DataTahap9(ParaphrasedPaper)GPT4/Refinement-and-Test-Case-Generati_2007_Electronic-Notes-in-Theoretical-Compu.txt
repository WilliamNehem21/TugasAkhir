The paper discusses fault-based testing, which entails generating test data aimed to reveal the absence of specific pre-identified faults. A well-known fault-based strategy is mutation testing, a process whereby faults are intentionally inserted into a program by modifying its source code. This paper applies the mutation testing approach to both specifications and programs.

The authors propose a theory designed to augment existing programming theories that traditionally focus on semantic concepts such as correctness and refinement. In contrast, their fault-centered testing theory spotlights the concept of faults, creating test data to expose their absence.

Following an introductory section, the paper outlines its structure. Section 2 briefly introduces the theory of designs and the concept of faulty design. The core contributions are in Sections 3 and 4, with the former presenting a semantic-level construction for generating test cases that locate errors in design, while the latter introduces an algebraic syntax-oriented method based on a programming language's algebraic properties. Section 5 discusses the results, related work, and future research prospects.

This paper focuses on model-oriented specifications, specifically using the Unifying Theories of Programming (UTP) design calculus to assign precise semantics to specifications. In this context, designs are a type of predicate that includes preconditions, postconditions, and an alphabet, which delineates the variables indicating the observable state before and after program execution.

The authors explore the relationship between test cases, designs, and programs via the concept of refinement. They interpret test cases as a kind of specification predicate with a denotational semantics, using non-refinement as a foundation for generating test cases. They argue that an implementation that passes test cases refines those test cases, which are abstractions of the implementation. This view extends to the specification level.

An example is provided to illustrate a program that locates the smallest element in an array, showcasing how guarded commands represent computation paths that progressively include more paths through approximations.

The paper establishes two key laws for test case generation. The first law asserts that a test case must be an abstraction of the original design but not of the faulty design, implying that no test case can be generated if the faulty design refines the original one. This law adapts a previous criterion from another mathematical framework, emphasizing the generality of the refinement-based testing theory.

The second law is more constructive and specialized for designs, applicable to specification languages with preconditions and postconditions. It leverages predicate operations to determine when designs do not refine one another and to generate test cases.

Lastly, the paper reviews related work by Tai and Su, who developed algorithms for identifying operator errors in test cases, and Burton, who designed a fault-based test case generator for Z specifications using a theorem prover and constraint solvers.