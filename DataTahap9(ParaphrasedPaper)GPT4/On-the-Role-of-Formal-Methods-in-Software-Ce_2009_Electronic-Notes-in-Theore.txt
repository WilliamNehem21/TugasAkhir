The academic paper presents a five-step methodology for confirming that a given piece of code fulfills a specified security property. The process involves formally proving that the system code refines the state machine corresponding to the TLS (Transport Layer Security) protocol. They simplify the verification process by categorizing kernel code into three types: event code, trusted code, and other code. Verification efforts focus on event code, which constitutes a minimal portion of the total code, thereby greatly reducing the verification workload.

A two-fold approach is used to show refinement: one, a mapping from code states to TLS states, and two, a correspondence between preconditions and postconditions in TLS events to those in the annotated event code. Both trusted code and other code are shown to be benign. The authors verify that the kernel code refines the TLS, and since the security properties of interest are preserved under refinement and are safety properties (except one), the kernel code is considered secure.

During certification, a natural language representation of the TLS facilitates communication between evaluators and the formal methods team, helping prevent misunderstandings. Despite the preference for formal specifications, translating the TLS into TAME (a formal language with PVS theory semantics) clarifies any ambiguities.

The success of the approach depends on security properties being preserved under refinement, which is true for safety properties. Most security properties examined are safety properties. The paper also notes that code annotations, such as preconditions and postconditions, while recommended for years and practiced in specific industries, are not widespread due to their labor-intensive nature. To remedy this, new techniques and tools are being developed to automate annotation checks and derivations.

Furthermore, the paper discusses the increasing prominence of constructing tests from formal specifications. A novel method involves generating test cases from preconditions and postconditions to affirm the code meets its specifications. This validation offers high confidence in the security and functional correctness of the source code. Research in this area suggests applying similar test generation techniques to languages like C could lead to the discovery of bugs and contribute to code reliability.