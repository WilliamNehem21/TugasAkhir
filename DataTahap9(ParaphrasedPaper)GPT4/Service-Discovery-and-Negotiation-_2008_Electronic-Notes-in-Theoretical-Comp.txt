This academic paper introduces COWS (Calculus for Orchestration of Web Services) as a formal methodology for defining and orchestrating web services while accounting for their dynamic behavior. The methodology is part of ongoing research efforts aimed at establishing process calculi that encapsulate the fundamental characteristics of service-oriented systems and facilitate the analysis of both qualitative and quantitative service properties.

The paper is structured as follows:

1. Section 2 outlines the syntax of COWS and offers a basic overview of its operational semantics.
2. Section 3 explores the application of COWS for concurrent constraint programming.
3. Section 4 examines simple communication protocols that use synchronization to create constraints between two parties.
4. Section 5 details how COWS can be applied to model a web hosting scenario, which exemplifies a common service-oriented architecture (SOA) scenario involving service-level agreements (SLAs) between organizations.
5. Section 6 presents variations on the concurrent constraint programming constructs discussed in section 3.
6. Section 7 concludes the paper with some final remarks.

The paper discusses how COWS utilizes constraints, which are relations between variables that provide information about possible variable values without being fully definitive, as multiple assignments can satisfy a constraint. It also mentions that to ensure progress in communications where an 'invoke' can synchronize repeatedly with the same 'receive' action without altering the 'store', a fairness assumption is necessary; meaning that if a synchronization producing consistent constraints is possible, it will eventually happen.

A key concept in COWS is the 'store', which is critical for the synchronization of 'invoke' and 'receive' actions. If the new constraints are compatible with the store, the synchronization occurs. If the value in the store is unchanged, new constraints are added, but if it is different, the process restarts with the new store value. This mechanism prevents divergence.

Lastly, the paper touches on the potential for creating robust protocols that avoid issues like starvation, suggesting the need for synchronization among multiple entities simultaneously, and acknowledging that balancing expressiveness with implementability presents a design challenge.