This paper introduces an enhancement to GATEL, a testing framework for LUSTRE/SCADE programs. The enhancement integrates state-machine descriptions into GATEL through a two-level upgrade that compiles these elements into expressions governed by multiple clocks. The paper's first significant contribution is developing explicit constraints that handle a hierarchy of clock types within GATEL. The second contribution outlines constraints that mirror state-machine attributes as per the SCADE compilation approach.

The paper has two objectives. Initially, it details the extension of GATEL to incorporate operations based on multiple clocks. Then, it suggests improvements hinging on the compilation process to fine-tune constraints related to state-machines. It starts with an explanation of the LUSTRE language and its related clock concepts, followed by an overview of how state-machines are translated to clocked programs. GATEL's basic mechanisms are introduced next, along with the primary updates made for expanding clock support. Specific deduction rules for state-machines are defined thereafter. A case study utilizing a simplified cruise control model is discussed to showcase the advancements of the new proposal compared to earlier versions.

The paper describes the use of an enumerated type that encapsulates state-machine states—one unique enumerator per state—and three types of flows that encode the dynamic behavior of the state-machine: "sel" for states that trigger strong transitions, "act" for states that evaluate state bodies and may prompt weak transitions, and "nxt" for defining the subsequent state. Without any strong or weak transitions, "act" equals "sel" or "nxt," respectively. These flows are generated from the state-machine's structure.

GATEL functions as a testing utility that utilizes resolution procedures centered around constraint programming interpretations of LUSTRE operators. Instead of directly handling clocked extensions, single-clock operators can be combined to simulate operations like "when," "merge," "pre," and "->". For example, the "x when(id, v)" can be imitated by a conditional expression, providing the default value when the clock isn't present and retaining the previous value when the clock occurs. Section 5 illustrates that a constraint logic programming (CLP) interpretation of this simulation is less effective than directly interpreting these operators.

The resolution engine, GATEL's core feature, works to create a matrix "m" comprising identifiers and cycles. This matrix accounts for logical variables associated with identifiers, with domains set based on their types. As cycles progress, the resolution engine expands the matrix and applies a standard CLP algorithm in a deterministic manner, alternating as necessary.

The paper discusses rules "init-t" and "init-f" for cycle management, with the former applying when the current cycle is at the peak of its clock type and in an initial state, while the latter applies when it isn't. It also notes that all clocks in a given state-machine appear at the same level within the clock hierarchy, which contains as many levels as there are nested state-machines.

Lastly, the paper proposes a constraint named "sm" that connects variables related to state transitions, managing new cycles created for active or selected states. This contribution is geared toward ensuring the consistency of states across transitions following specific rules.