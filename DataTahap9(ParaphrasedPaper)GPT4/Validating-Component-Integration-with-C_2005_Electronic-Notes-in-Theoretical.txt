The paper discusses the use of formal methods for specifying various properties such as invariance, event ordering, periodicity, and conditions of liveness and safety in systems. Traditional tools like temporal logics, timed state machines, and Petri nets have been used for these purposes. For complex systems, specifications are often broken down into smaller segments addressing specific sub-problems, with the ultimate goal of composing these segments to form the full system.

The paper introduces the use of Temporal Logic with Compositional Operators (TILCO) and its enhanced variant, Compositional TILCO (C-TILCO), which features compositional elements for temporal constraints. TILCO provides a consistent temporal model that covers both past and future events and has unique operators for expressing time-based statements, as well as expanded temporal operators (TILCO-X) and support for process communication (C-TILCO). C-TILCO enables the specification of intricate systems through decomposition into sub-processes and models communication between them. TILCO specifications are executable, meaning that the language can be used to implement real-time systems that generate outputs in real-time based on current inputs, communication, and the system's internal state. An execution tool, referred to as TILCO-Executor, can run segments of TILCO specifications.

In C-TILCO, multiple instances of the same process component can be incorporated within a global architecture, with each instance having its unique parameter values. Communication between processes is achieved using synchronously typed I/O ports in a manner similar to the Communication Sequential Processes (CSP) model, with a strict one-to-one connection through channels.

The system comprises communication nodes with a high-level interface for simple data transfer and protocol handling. Communication tokens are boolean and sent over dedicated channels. Messages are structured types containing origin and destination node identifiers.

The paper describes formulas for handling communication failures in channels using a backup ring. If a channel fails, a node will attempt to use the backup. If both primary and backup channels fail, the node can no longer communicate. Two predicates assess readiness after successful transmissions on either channel. A channel failure locks the port in a send state, leading to indefinite waiting for remote synchronization.

Synchronization between connected ports triggers token transmission, and in the event of a broken channel, tokens can be sent through a backup port, allowing the backup ring to carry the token.