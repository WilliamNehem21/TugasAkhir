Software maintenance is often the costliest phase of the software lifecycle. To address this, design patterns, or proven solutions to common design issues, have been introduced. They are well-regarded by the object-oriented programming community for simplifying design, comprehension, and software restructuring.

Despite their popularity, there is a deficiency in formalism within these techniques, which straddle the line between programming and design. The lack of formality means they're largely applied through trial and error, a process that is both laborious and fraught with potential mistakes. To combat this, we argue for automation or at least supportive tools in applying design patterns.

Proposed solutions like the pattern description languages cited in references [7,6] utilize a formal (graphical) language named Lepus for higher expressiveness. Lepus isn’t a random assortment of ideas; it's grounded in fundamental constructs common in object-oriented designs. This allows for straightforward articulation of established design patterns, such as the proxy, visitor, and composite, and for designers to adapt these patterns, invent new ones, or search for a combination of patterns effortlessly.

We support the philosophy behind Lepus but recognize its limitations, such as an inability to represent certain properties—like circular dependencies and antipatterns—which are crucial for identifying divergences in a complex design model. Moreover, Lepus currently only operates on code, not UML (Unified Modeling Language) diagrams.

Our paper presents a method to represent the collective class diagrams from a UML model as a graph, consisting of a set of classes and relationships. We omit full details like method properties and attributes for clarity.

Consider an antipattern not expressible in Lepus. We reference a pattern from example 3.5 earlier in the paper, where applying it enables the detection of cyclical relationships in the class diagram.

We're expanding our tool technically, focusing on interpreting class diagrams by analyzing source code, thus streamlining information extraction. This involves creating a source code parser and examining the resulting parse tree.

In summary, our paper introduces a formal language to define both design patterns and antipatterns. We provide a few key constructs that are fundamental in object-oriented design and language connectors to combine these elements as needed, offering a structured alternative to a disparate set of concepts. This language empowers users to specify common design patterns, personalize them, or create new pattern combinations with ease.