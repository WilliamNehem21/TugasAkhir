The importance of software quality is on the rise, and systematic testing is a key method for ensuring it. Yet, testing is often manual and inefficient, leading to potential errors, high costs, and time consumption. Model-Based Testing (MBT) has emerged as a technology to address these challenges by automating the generation of test suites from models, reducing costs, and improving testing effectiveness.

From an industrial view, MBT is seen as a means to enhance test quality while cutting down on expenses. While many tools automate test execution, they fall short in automatic test generation. Conversely, MBT excels by producing comprehensive test suites from models, hence supplementing automatic test execution.

Academically, MBT is an evolution of formal methods and verification techniques, reusing many formal concepts. While formal verification seeks to prove that a model of the system holds certain desired properties, MBT uses a verified model to show that the actual system implementation conforms to the model. Testing can expose defects but cannot definitively affirm error absence due to its limited scope.

A key advantage of MBT is its ability to automatically create numerous tests from a model. However, a robust theoretical foundation is necessary to ensure that the generated artifacts qualify as legitimate test cases. This underlying theory should clarify relationships between different MBT components and stipulate what constitutes a correct implementation, valid test cases, and a correct test generation algorithm.

Two crucial elements of this theory are a testing hypothesis and an implementation relation. A testing hypothesis links the black-box, real Implementation Under Test (IUT), which could be composed of software, hardware, or both, to the model world, positing that any real IUT can be represented within a model domain. The testing hypothesis allows treating IUTs as if they were formal models.

Building on the hypothesis, the implementation relation details when an IUT is correct concerning a specification model. This relation is vital for judging the validity of test cases and the accuracy of test generation algorithms, which must be evaluated against this relation.

Model-checking and MBT serve complementary goals. Model-checking ensures a model is valid and possesses specific properties, whereas MBT begins with a validated model to test the IUT's compliance. Both approaches need to be compatible for the properties verified in model-checking to be retained in the IUT.

The ioco implementation relation, which assumes IUTs behave like input-enabled labelled transition systems, has spawned various offshoots to address diverse testing aspects, such as real-time behavior, symbolic data, and environmental considerations.

Traditionally, MBT derives test cases from development models, but this approach only verifies, not validates the system. Validation requires including different stakeholder perspectives to ensure the system meets actual needs. Model-centric testing has successfully been employed in the automotive industry, where functions among various suppliers must be integrated and tested, demonstrating the practicality of the approach.

The challenge lies in keeping up with increasingly complex and larger systems during testing. Model-Based Systems Engineering (MBSE) addresses this complexity in production but quality assurance lags behind. Extensive MBT research shows its efficacy at component and system levels, emphasizing early lifecycle application to minimize repair costs.

Descriptive modeling with SysML activity diagrams and plain text descriptions provides a semi-formal approach that's easily communicated among engineers and non-engineers. An innovative, cross-domain tool framework is another path for MBT, promoting integration of various analysis and testing tools within a domain-independent testing framework, allowing for standard interfacing and seamless data integration among different tools.

In summary, as software systems grow in complexity, MBT offers a promising, theory-backed approach for improving software testing efficiency and quality, yet its full potential across the systems engineering lifecycle and various domains remains to be fully realized and adopted.