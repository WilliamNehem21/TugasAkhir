This paper's goal is to demonstrate the capability of the Alloy Analyzer for automatically verifying data refinement in Z notation. The paper establishes that the simulation rules for Z, which are already known to be sound and complete jointly, are translated into the Alloy language. This translation enables the use of the Alloy Analyzer to find the essential 'retrieve relation' between different data representations, and as a result, confirm refinement.

Refinement is a key practice in developing critical systems, where abstract models of the system are designed and analyzed, and it is crucial to ensure that the final implementation conforms to these abstract designs. Using the Z specification language, which involves set theory, logic, and relational calculus structured into 'schemas' consisting of variable declarations and constraints, refinement is precisely defined and determined.

The paper highlights the challenge in verifying refinement: identifying the correct retrieve relation, rather than applying the simulation rules. To address this, the paper presents a way to define refinement within the Alloy language. 

Only simple data types in Z are considered, which do not provide output or require input from operations, simplifying the translation to Alloy. The simulation rules for both forward and backward simulations are similar for blocking (behavioral) and non-blocking contexts. The main difference is that the correctness rule for backward simulation in a blocking context accounts for all concrete states, not just those corresponding to abstract states within an operation's domain.

Alloy simulation rules are defined to replicate those from Z, and the paper details how the Alloy Analyzer is leveraged to automatically check for refinement. To aid the Alloy Analyzer in identifying the retrieve relation, the states of the data types and their operations must be precisely represented within Alloy.

A practical example is provided in the paper where simple data types are defined in Z, translated into Alloy, and then analyzed by the Alloy Analyzer, which confirms the retrieve relation and thereby verifies refinement. The semantic model used corresponds to the one for data refinement in the blocking context.

The translation of these Z data types into Alloy includes considerations for operations and both the abstract and concrete state spaces. The Alloy analyzer automatically verifying the refinement is showcased with an example that includes two data types, A and C, and their respective operations. An initial non-deterministic choice is offered in data type A, while data type C may either deadlock or similarly provide a non-deterministic choice between operations. Both A and C deadlock after an operation occurs.

The paper concludes with a discussion about the effectiveness of the Alloy Analyzer for verifying the refinement of data types defined in Z, suggesting its suitability for the task based on the example provided.