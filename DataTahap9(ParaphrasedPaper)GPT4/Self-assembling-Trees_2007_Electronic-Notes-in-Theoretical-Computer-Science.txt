In this paper, the authors outline an innovative approach to develop distributed algorithms by simplifying complex problems. They suggest tackling easier problems first, then applying a generic distributed backtracking mechanism to those solutions. This approach is compared to the two-phase structure of NP problems—guessing and verification—as well as to other methods like simulated annealing and declarative programming. It’s particularly effective for consensus-based issues in highly distributed systems.

To illustrate their method, the authors focus on a simplified version of self-assembly processes, where parts autonomously and locally interact to form a predefined structure. They design an algorithm in Calculus of Communicating Systems (CCS) that models this by allowing simple parts to form complex structures without falling into a deadlock, which is a common challenge in distributed algorithms.

The CCS-based algorithm described is not a complete solution, as it can result in deadlocks. However, by translating this into Reversible CCS (RCCS), where actions can be undone, they achieve a working solution. Comparatively, a direct CCS solution that explicitly manages deadlocks is harder to understand, validate, and assumes more from the system’s computational capabilities.

There are limitations to this approach, as it is more suitable for problems that require complex consensus mechanisms and currently is only viable for problems that can be expressed in CCS. Notwithstanding, recent developments indicate that proper backtracking mechanisms can be extended to a broader class of agent-languages through the use of Structured Operational Semantics (SOS) and abstract frameworks like monoidal categories, which also apply to Petri nets.

The paper is comprehensive but discusses causality informally, referencing more detailed explanations in other papers. The authors show that while their CCS algorithm could deadlock, it remains correctly designed because its causal computations align with the intended specification, and thus can be considered correct in RCCS. They use bisimulation to assert the correctness of the algorithm with respect to the original specification.

The authors emphasize that a perfect bisimulation between the specification and the CCS-based algorithm’s labeled transition system (LTS) cannot be established. However, they argue that correctness is still achievable in RCCS because backtracking can undo incorrect actions even if an algorithm with purely non-deterministic nature cannot guarantee a solution.

The paper concludes by contrasting the RCCS algorithm's backtracking mechanism, which incrementally resolves problems to form the final structure, with a CCS algorithm that employs a top-down cancellation method to prevent deadlocked constructions. Although this sacrifice of distributed structure for greater control results in reduced efficiency, the RCCS algorithm's ability to partially backtrack offers a more flexible and effective resolution path compared to the more rigid CCS solution.