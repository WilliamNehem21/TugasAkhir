We present a refined escape analysis algorithm that aims to produce practical information for allocating memory using a region-based memory manager, improving on the algorithm proposed by Gay and Steensgaard. By blending both intraprocedural variable-based and interprocedural points-to analysis, we are striving for a balance between precision and scalability. Although our method is still under development, we demonstrate its application on common programming patterns and provide preliminary experimental results from a prototype on some benchmarks.

Numerous methods for Java escape analysis have been suggested, with the primary intent of stack allocation of objects and synchronization elimination. Some approaches analyze bytecode, which adds complexity because of Java's stack-based model. These methods use points-to analysis to ascertain if an object may leave a method's scope. Other methods offer quick but very conservative analysis by processing the program in static single assignment (SSA) form, transforming it into a set of linear constraints.

For region-based memory allocation in Java, some researchers use escape analysis coupled with method-call chains to dynamically allocate sites to regions, while others define a points-to analysis that classifies objects into regions based on their lifetimes, offering fine-grained control at the instruction level as opposed to the method level.

Our detailed escape analysis algorithm presupposes the program is in SSA form, where every variable is assigned only once, allowing for flow-insensitive analysis to have the depth of flow-sensitive analysis. We focus on local variables rather than constructing a detailed points-to graph, which would be costlier. Using abstract interpretation, we compute several properties for local variables and methods.

The "fielduse" concept indicates how local variables in a method "m" reference each other. If a variable "v" escapes through a field, but all variables related by "fielduse(v)" are captured, then "v" is also considered captured.

Our analysis is designed to work on selected portions of an application, using an "istobeprocessed" predicate to determine whether to analyze a method. If we choose not to analyze a method, perhaps because it's a native method or otherwise unavailable, we must be conservative in our assumptions about it.

For method parameters, we align the formal parameters with the actual arguments. If a parameter escapes in a method, we consider the corresponding actual argument to escape in the calling method. Otherwise, if a parameter is dereferenced within a method, without a points-to analysis for precision, we conservatively assume all objects pointed to by the argument escape.

While our preliminary tests on another program with a region-based memory manager show a 20% reduction in overall memory usage compared to using garbage collection alone, we have yet to fully instrument our benchmarks. The results are promising, as many allocation sites in the analyzed code were determined to be capturable. We allow users to select which classes to analyze, providing a way to customize the trade-off between analysis precision and performance based on specific application needs.