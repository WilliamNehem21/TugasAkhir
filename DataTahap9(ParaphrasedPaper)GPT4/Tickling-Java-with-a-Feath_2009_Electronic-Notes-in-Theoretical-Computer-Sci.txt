In this study, we explore the utility of Featherweight Java (FJ) as both a generator of test programs and an oracle for verifying the behavior of Java compilers, specifically targeting the Sun OpenJDK Java compiler (javac). FJ provides a simplified model of Java's syntax and type system, excluding many of Java's features, yet retains its essential object-oriented structure. Our goal is to generate non-isomorphic test cases based on FJ's grammar, prune redundancies considering name binding rules, and use coverage metrics to determine what proportion of javac's implementation can be effectively tested with FJ-derived tests.

Testing compilers and type checkers presents numerous challenges, as their development involves intricate code for handling complex languages and potential corner cases. Manual test creation and verification are laborious, error-prone, and may overlook subtle bugs due to human limitations.

We propose using the formal framework of FJ not only to generate test cases but also to serve as an automated oracle to verify the correctness of the tests. In sections 2 and 3 of the paper, we discuss the characteristics and limitations of FJ and describe how we generate test programs from FJ's grammar using a bounded, depth-first algorithm. We apply constraints on the number of classes, fields, methods, and expression complexity to prevent infinite searching.

Our test generation takes into account global name binding, organizing the generation into two phases to ensure the availability of names. In section 4, we detail how FJ type checker implementations serve as oracles, differentiating between programs that are acceptable in full Java but not in FJ. We observe that not all FJ programs are valid Java, primarily due to features absent in FJ.

We subject the OpenJDK javac to our test suite, measuring code coverage with the help of EMMA, a code coverage tool. Section 5 outlines our testing setup, while section 6 provides the results, revealing insights into how effective FJ tests are in terms of coverage and where increments in test suite size do not necessarily equate to significant coverage improvements in javac.

To verify our findings, we examine other studies, such as an experiment using Korat to test Java library data structures with bounded inputs. These other studies show high coverage and mutation scores, implying that rigorous testing is possible even with simpler, smaller test cases.

Overall, our work demonstrates the practical value of FJ-generated test programs in assessing Java compilers, though we acknowledge that complete coverage is unrealistic given FJ's abstraction. We conclude with a discussion on this approach's implications and potential areas for further exploration.