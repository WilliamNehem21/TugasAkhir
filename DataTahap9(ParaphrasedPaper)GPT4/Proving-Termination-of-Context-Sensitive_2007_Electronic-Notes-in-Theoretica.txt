Context-Sensitive Rewriting (CSR) sets limits on rewriting by preventing reductions on specific function arguments. It's a challenging and relevant task within term rewriting and programming languages to prove CSR's termination. Various strategies exist for establishing CSR termination, all of which have been incorporated into the latest iteration of the tool mu-term. Additionally, this paper discusses the integration of these methods to endow mu-term with an "expert" system capable of autonomously conducting termination proofs. The paper offers preliminary testing results of the toolâ€™s performance.

This document presumes the reader has a foundational understanding of term rewriting. For more detailed definitions and information, further reading is encouraged. Section 2 highlights the latest enhancements made to mu-term, Section 3 delves into the details of the termination expert, Section 4 reports on the tool's trial runs, and Section 5 wraps up the study with concluding thoughts and future research avenues.

Mu-term is programmed using Haskell and its graphical interface is done with wxHaskell. The system features over 45 Haskell modules and exceeds 14,000 lines of code. It can be run on various operating systems, including Linux, macOS, and Windows. The tool, along with installation instructions, can be found on the mu-term webpage. A new hybrid version for the .NET platform, blending Haskell and C#, is also available.

Regarding coefficients, mu-term adheres to the norms seen in similar tools, capping values at 0, 1, or 2, a decision drawn from user experience rather than any formal study directing coefficient limits based on specific CSR problems. In this version, the addition of the value 1 permits some use of rational coefficients. The "expert" employs a systematic approach to test different polynomial interpretations.

The current build of CSRPO operates on a custom-made incremental constraint solver, but there's potential for enhancement, such as converting the problem to a SAT-solving format. The team aims to further refine algorithms capable of solving polynomial constraints over real numbers to produce exact solutions, even if they aren't rational.