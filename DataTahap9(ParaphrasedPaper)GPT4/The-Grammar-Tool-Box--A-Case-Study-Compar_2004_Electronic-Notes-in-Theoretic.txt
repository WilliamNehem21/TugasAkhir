In recent years, there has been a growing interest within the computing community in advancing parsing methods beyond conventional techniques. Numerous parsing tools have been enhanced with additional capabilities like backtracking and lookahead mechanisms, both for top-down and bottom-up parsing strategies. These tools, including well-known ones such as Precc, PCCTS, ANTLR, and JavaCC, actually match strings against ordered grammars where the sequence of rules plays a critical role. However, it can be challenging to define the precise language recognized by such parsers, which can exhibit unexpected and complex behaviors. In particular, backtracking can result in exponential parsing times in the worst-case scenarios.

Despite this, modern computers can handle such behavior, making these techniques usable. Some Eiffel compilers, for example, use Earley parsers due to their flexibility with the use of expression separators. Other tools, like ASF+SDF, prioritize versatility, enabling parsing of ambiguous languages and providing support for representations like shared packed parse forests, which encode all potential parse outcomes efficiently. ASF+SDF achieves this through GLR (Generalized LR) parsing. Moreover, even GNU Bison, a widely used parser generator, has introduced a GLR parsing mode, signaling that advanced parsing techniques are becoming more mainstream, even though Bison's GLR implementation might not be fully production-ready yet.

The paper describes the introduction of GTB (Generalized Translator Builder), aimed at broadening the scope for implementing translators by structuring ways to conduct replicable experiments among different parsing techniques. GTB is flexible enough to replace traditional parser generators like YACC or RDP in a production setting as it can scripted to replicate their functionality.

Moreover, GTB has the ability to handle multiple grammars at once and can derive multiple grammars from a set of rules by selecting various starting points. GTB also has built-in functionality to construct grammar objects and automatically compute necessary grammar details such as 'first' and 'follow' sets, including automatic grammar augmentation where needed.

With GTB, one can generate sentential forms or full sentences using a grammar by specifying an expansion strategy (leftmost, rightmost, or random) and setting a limit to the output. Notably, GTB's generate function performs a breadth-first search and allows for the production of all sentential forms given no bound is set.

The paper also discusses the convenience of designing languages, with Pascal being close to LL(1) parsing except for certain ambiguities, while C is geared more towards LALR parsing. For instance, the IBM VS-COBOL grammar proved challenging when initially processed by GTB due to memory limitations, requiring simpler methods for recursion handling in the NFA (Non-deterministic Finite Automaton) construction.

Additionally, the authors present a separate tool, ebnf2bnf, which converts extended BNF grammars into BNF grammars. This process starts with constructing a grammar tree from the original, then performing controlled transformations based on annotations, and ultimately outputting the modified grammar, all while emphasizing the traceability of operations. This kind of conversion process, known as yacc-ification, has been explored in environments like ASF+SDF.