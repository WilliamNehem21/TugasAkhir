Debugging tools are essential for identifying the root causes of incorrect program outputs. When programming with declarative paradigms that include challenging operational techniques like constraint solving or lazy evaluation, traditional debugging methods based on low-level execution details fall short. Declarative debugging addresses this by using computation trees (CTs), which are constructed after the fact to map out the structure of a faulty computation as identified by the user.

Each node within a CT corresponds to an observable outcome reliant on the outcomes from its child nodes. Declarative debugging involves probing a CT to spot a defective nodeâ€”a node that yields an incorrect outcome although its children deliver correct outcomes. Finding such a node indicates an error in the respective part of the program. This search involves an external oracle, often the user augmented with semi-automatic tools, who possesses a sound understanding of the program's intended behavior or semantics.

The paper's subsequent sections unfold as follows: Section 2 provides a backdrop to understand the approach with a debugging example used consistently throughout the document for illustration purposes. Section 3 revisits the CFLP(D) framework, only as much as necessary to comprehend the paper's theoretical findings. Section 4 proposes a reliable method for declarative diagnosis of erroneous results in any properly functioning CFLP(D) system. Section 5 introduces the debugging tool DDT, which facilitates the process described earlier. Section or T OY addresses formal goal-solving calculi, including cutting-edge techniques like CDNC(D) calculus, that are coherent with the declarative semantics set out in the following subsection and serve as accurate representations for actual computations in the T OY system.

An example discussed in the paper shows a computed answer that is incorrect based on the program's assumed intended model. Computed answers usually involve constraints on the initial goal's variables, but goal-solving systems also handle constraints tied to intermediate variables not present in the initial goal. This internal information is also crucial for declarative debugging, which the paper suggests including.

Besides CDNC(D), other CFLP(D) calculi like CPPC(D) are known to be sound, which is a reasonable expectation for actual goal-solving systems such as Curry and T OY with their reliance on constrained lazy narrowing. A CPPC(D)-sound system is considered semantically sound per a specific definition provided in the paper.

Although the aforementioned theorem provides a theoretical base, it doesn't offer a hands-on method for pinpointing a faulty program rule. To tackle this issue, the paper suggests the usage of abridged CPPC(D) proof trees as CTs, with specific focus on a rule called DFP that is dependent on the program. By examining nodes in these abridged proof trees, or APPT(D)s, and their corresponding C-statements, one can identify buggy nodes and hence detect erroneous program rules, as shown in the paper's proofs.

In summary, the paper lays out a logical and semantic framework for the declarative diagnosis of incorrect outcomes in CFLP(D) systems. The methodology encompasses representing the erroneous computation through a condensed proof tree, the inspection of which leads to identifying a faulty program rule. The logical soundness of this diagnostic method is underpinned by a link between the proof trees and the program's semantics.