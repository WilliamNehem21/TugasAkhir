This paper discusses the challenges and solutions for analyzing and transforming embedded domain-specific languages (DSLs) when they are strongly typed and embedded within a host language. Specifically, the paper details how a library for transforming typed abstract syntax can be used to remove left recursion from a typed grammar description. It introduces the left-corner transformation algorithm, which is ideal for providing insight into similar transformation processes.

The paper describes a Template Haskell library that generates 'grammar a' type values and combines these at runtime to create a complete grammar, from which an efficient alternative to Haskell's standard 'read' function is derived. This transformation is not only compositional but also highly efficient with a computational complexity of O(n^2), where n is the sum of terminals and nonterminals.

The transformation process involves several steps. For each non-terminal, a function 'rules1' visits its productions, creating new productions through 'rule2a' and 'rule2b'. These new productions are then added to the transformed grammar, and the process repeats recursively until no new left-corner symbols are found. The algorithm performs a depth-first search to identify and handle the left-corner symbols by introducing new non-terminals and redefining existing ones to avoid left recursion.

The paper emphasizes the use of Generalized Algebraic Data Types (GADTs) and other advanced type system features unique to Haskell, such as existential and polymorphic types, to facilitate the transformation at runtime. Using these features, the transformation can be statically verified to an extent, while still separating types from values. The paper leverages lazy evaluation to efficiently manage information flow.

The authors highlight that their work is pioneering as it deals with run-time transformations of embedded DSLs represented as typed abstract syntax graphs, which is more complex than previous work focused on tree representations. The techniques they used are typical of dependently typed systems but are applied within the more general Haskell language, demonstrating the novel application and flexibility of Haskell's type system in practical, efficient language processing tasks.