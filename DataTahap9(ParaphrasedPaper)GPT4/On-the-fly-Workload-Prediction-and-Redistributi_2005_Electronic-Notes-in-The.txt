The study indicates that the use of timed automata, which incorporate real-time constraints through clocks within the automata framework, results in specific parallelization strategies and challenges for model checking different from those used in untimed scenarios. Traditional untimed model checkers utilize binary decision diagrams (BDDs), but for timed model checkers, difference bound matrices (DBMs) are the standard representation. These DBMs, despite being a symbolic state space representation, do not match conceptually with BDDs, making the parallelization techniques developed for BDD-based untimed model checkers unsuitable for the timed context.

The paper outlines the problems encountered in both asynchronous and synchronous model checking and introduces techniques to address these issues. It includes case studies where the new methods enhanced verification times and offers directions for future research.

It goes on to discuss the real cost of memory allocation (malloc()), pointing out that this cost can only be estimated due to factors such as memory fragmentation at the time of the call. Estimations based on rounded parameters and default values are used when exact matches are unavailable. Although this is a simplified estimation method, it provides a balance between accuracy and computational efficiency.

Timed automata are defined by their synchronized clocks that measure time elapsed between events. These automata are equipped with invariants and guards attached to their states and transitions, respectively. Transitions can involve clock resets, and the automata's evolution includes both transitions altering the current state and time passage while remaining in the same state, consistent with the location's invariant.

Properties of timed automata models are specified using TCTL formulas, often revolving around reachability issues. To address such queries, a technique called difference bound matrices (DBMs) is used to manage set representations, particularly for non-convex sets which are treated as unions of convex sets. The reachability analysis employs a backwards propagation of non-convex sets across the graph of control locations, seeking a fix point indicating whether initial states can reach target states, thus determining the reachability of these states. When target states are unreachable, the entire state space must be examined, which is considered the worst-case scenario in model checking.