In this paper, we apply our newly developed technique to two established models from the computer security field. We begin by examining the security model put forward by McLean, which aims to enhance the Bell and LaPadula model by addressing issues of joint access. Our analysis reveals that when certain simplifications are made to align the general joint access framework with the BLP model, it can lead to breaches in confidentiality.

Section 4 of the paper describes how the two different security policies are translated into a language extension called TOM, while Section 5 demonstrates the verification of these models and discusses optimizations that reduce the search space, thus improving the verification process's speed. The paper concludes in Section 6 with a comparison to other related work.

Bell and LaPadula's work laid the groundwork for mandatory access controls, particularly in military contexts. This paper focuses solely on the mandatory aspects unique to the BLP model and not on how the access control matrix is altered by subjects' actions.

Two fundamental properties underpin mandatory access control for BLP: the 'read-up, write-down' property, where a subject can only read objects at their level or below and write only to objects at their level or below, and the 'write-up' policy, which prevents the flow of information to lower-level objects.

While human users are trusted not to leak sensitive information, and a user with secret clearance could write an unclassified document, the same trust is not extended to programs, which might contain malicious code such as Trojan horses. Therefore, the 'write-up' policy prohibits high-security programs from writing to lower-security objects, regardless of discretionary access controls.

McLean's algebra of security is presented as an extension of the BLP model, introducing joint access, meaning that certain tasks demand concurrent action by multiple subjects, like launching a missile in the military domain.

TOM, a programming language extension, integrates pattern-matching features into classical imperative languages like Java, which is ideal for processing structured data such as trees/terms. TOM can seamlessly work with existing languages, using efficient runtime libraries like Java's collection framework.

An example provided demonstrates how TOM employs non-linear pattern matching to handle access control decisions based on security levels.

The paper also clarifies how security levels are structured in a totally ordered lattice and how the TOM language can be used to encode these levels.

A state is considered noncompliant with the BLP policy if it violates the established read or write conditions or is not 'write-up' secure. This compliance depends on the lattice of security levels defined within the TOM class that encodes the policy.

Finally, the concept of hooks in GOM is described. Hooks allow for the insertion of access events into a state representation, ensuring that implicit accesses are consistently captured and the state's canonical form is maintained.