The concept of subsystems provides a more general unit of modularization to complement components in software architectures. Interactions between components are managed through coordination, allowing each component or subsystem to be described by a self-contained logical theory. This modular approach also enables hierarchical organization within specifications, aiding in the localization of proof efforts to relevant parts, thereby simplifying reasoning about the system.

We discuss a prototypical language designed to explore hierarchical subsystems, emphasizing that while the language is not intended as a real Architecture Description Language (ADL), it serves as a tool for examining more abstract and declarative means of describing software architectures.

The underlying logic is a generalization of the Manna-Pnueli logic, allowing for state-dependent interpretation of symbols, but due to space limitations, details are omitted. Readers are directed to existing literature for further information on the original and our modified logic.

Specific actions for message handling in the system are described, such as `get` for receiving messages with conditions ensuring no overwriting of messages, `cons` for consuming messages addressed to the component, and the `rem()` operation for discarding non-addressed messages. Actions `prod` and `send` deal with message production and transmission, each governed by a set of axioms.

The design philosophy enforces that class definitions are encapsulated and independent, fostering logical reasoning about component properties in isolation. Communication between components is enabled through the notion of coordination, akin to the concept used in the 'community' model but with added flexibility. Associations, constituted by participant sets and interaction characterizing formulae, provide the framework for this coordination.

Previous work defined subsystems as complex, dynamic components comprising classes and connectors. We now propose an extended definition to allow hierarchical organization, enabling subsystems to include both class instances and simpler subsystem instances. Despite differences in complexity, the semantic description for both components and their aggregates remains consistent, which means there are no theoretical obstacles to recursive aggregation definitions.

We suggest an enriched notation for subsystems, adding a sort `name` with a large set of `name` constants to an existing abstract data type (ADT). These constants represent identifiers for the underlying components, and a subsystem signature comprises a name, sets of attributes and read variables typed by the new sort, and a finite number of operations.

To manage complexity in specifications and aid verification, modularization is crucial, but software tools are also necessary. The Stanford Temporal Prover (STEP) is one such tool being tested for proof assistance within our logic framework.