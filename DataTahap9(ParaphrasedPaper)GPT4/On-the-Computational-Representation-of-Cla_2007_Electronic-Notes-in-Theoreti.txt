The paper discusses a range of programming calculi designed to illustrate the computational elements of classical logic, as seen through the Curry-Howard correspondence with logical proof systems. These calculi vary in the logical primitives they employ, such as different logical connectives (like conjunction, disjunction, negation) and sometimes even more obscure ones, adapting their syntax and reduction rules accordingly. Implication often takes precedence due to its established computational analogy with function abstraction and application.

Nevertheless, some calculi, like Wadlerâ€™s, operate without using implication. With each addition of a syntactic construct, these programming calculi require corresponding logical rules for renaming through a process called a cut with a capsule, as demonstrated by the 'exp' and 'med' rules. Reduction rules for logical connectives need to define how cuts between the right and left introductions of the connective can be handled.

The principal rule is unique as it cannot be systematically derived without considering the specific connective in question. In regard to reduction rules, the principal logical rule for a connective becomes a primary focus.

The paper also points out that some binary connectives can be viewed as degenerate, as they might not utilize all of their inputs. The text refers to a hypothetical binary connective that only evaluates one of its two inputs, effectively functioning as a unary connective. The paper subsequently limits its interest to connectives of arity 2 or lower due to the complexity of analyzing higher arity.

The authors plan to extensively review binary connectives, looking into possible relationships and their computational ramifications, likr duality and how these relationships are preserved in computation. Additionally, they acknowledge that utilizing multiple logical connectives in term calculus could introduce untypeable cuts, i.e., instances where no reduction rule applies, potentially leading to untypeable normal forms containing such cuts.

Despite potential limitations like (t) and (id), the paper finds that the calculus can simulate reductions associated with various other connectives. When this occurs, the connective is deemed computationally expressible, independent of logical expressibility.

Looking closely at 'iff-terms', the paper discovers a rich structure allowing for diverse computational behaviors, which could possibly include novel behaviors. The paper also confirms that propagation and renaming rules, which handle cuts and connector renaming, operate uniformly across different syntactic structures of the term calculus. This confirms the rules' breadth and their ability to simulate the reductions of different connectives.