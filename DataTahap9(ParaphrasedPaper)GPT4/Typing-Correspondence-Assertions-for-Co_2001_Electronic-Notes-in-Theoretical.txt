The paper discusses a criterion for determining the safety of a program based on defined assertions at the beginning and end of the program. Safety is defined as every "end" event in a program's execution being preceded by a corresponding "begin" event, both of which are labeled identically. This definition is expanded upon in Section 5 of the paper.

Example 1 demonstrates how the protocol functions with a sender and receiver using a private channel, c, established as safe because it adheres to the handshake protocol.

The authors introduce a type and effect system, where types specify permissible operations on identifiers such as channels, and effects describe a process's potential end events that are not accompanied by corresponding begin events. They suggest using this system to ensure that every end event is covered by a prior begin event, akin to balancing credits and debits. A process with no remaining "debt" (end events without begin events) is deemed safe.

The safety concept implies that a "safe process" must have a trace including a begin event before any corresponding end event for every run. This idea is encapsulated in Theorem 5.2, stating that a process without effects is inherently safe. The theorem promises a method to compositional verify the safety of communication protocols, informed by the subject reduction stated in Theorem 5.1. The paper also acknowledges that proving the (proc cond) rule requires meticulous attention.

Type and effect systems were first introduced by Gifford and Lucassen for managing side-effects in functional programming and have since seen a wide range of applications, including concurrency, memory management, avoiding race conditions, and access control. The paper also references ongoing work applying these concepts to the security domain, specifically cryptographic protocols within spi-calculusâ€”a framework for understanding these interactions.

The companion paper extends this work to cryptographic protocols, emphasizing symmetric key cryptography and the introduction of a nonce type to prevent replay attacks. Lastly, the paper suggests future research directions, including developing type inference algorithms for these systems.