The challenge seems to be less complex when dealing with deterministic input automata, as deterministic tree languages are a well-defined yet narrower subset of all recognizable tree languages. Furthermore, it is feasible to determine whether a nondeterministic automaton can be converted into a deterministic one within exponential time. For determining the level of a tree language within the deterministic hierarchy, one can employ a method analogous to the one used for word automata, as mentioned in Remark 2.4. It's important to note, however, that the position of a deterministic tree language within a nondeterministic hierarchy may be significantly lower than its position in the deterministic hierarchy.

Considering a tree 't' from the tree set T(A), we can observe that there is a singular computation path, or run, of the deterministic automaton A^ when applied to 't'. This run identifies which parts of the tree are accepted by the various strongly connected components (SCCs) of A^. One could devise an automaton without any acceptance conditions, which computes the state of A^'s unique run on 't' at each node in the tree. The desired automaton that needs to be created will essentially be a combination of this state-computing automaton and separate (1, 2) automata designated for each SCC of A^. These (1, 2) automata are intended to verify whether all computation paths that indefinitely remain within any given SCC are accepted. By integrating these automata, a (1, 2) automaton that successfully recognizes the tree set T(A) can be realized.