This paper discusses the importance of understanding the "use" of components within proofs in theoretical computer science and how this understanding can enhance software maintenance and program modification. It posits formal definitions for the concept of "use" dependent on the calculus in question, allowing for explicit tracking of necessary or sufficient program parts for certain properties, which in turn provides a localized approach. Such locality is key to reusing proofs or their parts when making amendments to a program.

Programs are considered as textual objects, distinct from the algorithms or mathematical functions they implement. Maintaining software is thus equated with text updates. A common method in theoretical computer science for formal program analysis is to associate a programming language (S) with a formal framework (F) and interpret programs through a translation (T) into F. These frameworks cater to various aspects of programming languages, from denotational to operational semantics, though the discussed approach is not hindered by these details.

An example is given where adding new clauses to a program could potentially preserve the derivability of a fact that previously required a now-retracted axiom. By demonstrating that the necessary axiom can be re-derived in the new context, derivability is maintained.

The paper references the "Handbook of Theoretical Computer Science" for further reading on formal approaches to programming languages, notably those pioneered by Hoare. The ideas presented aim to be broadly applicable across formal frameworks, recognizing that tracking formula usage may be impractical in terms of resources for many computer programs. Nonetheless, the approach offers conceptual clarity and can be directly useful in various sectors.

Within this discussion, the paper touches on the optimal balance between the size of code transmitted over a network and the time required for local verification, underlining the relevance of differentiating between used and necessary proof components. In scenarios where a generated program includes case distinctions, systematic application of new information might allow for pruning these distinctions, potentially yielding a more efficient program.

Overall, the paper advocates for a proof-theoretic perspective on programming and the strategic utilization and maintenance of proofs in accordance with changes to programs.