Our research makes significant advancements in component-based software engineering by enhancing the reusability of components and automating the system construction process. This methodology is applicable not just to software components but also to hardware and hardware/software co-design. It allows for the selection and integration of components based on their functionalities, costs, and their role within the bigger system, sometimes requiring adaptor code for seamless integration.

The structure of the paper is as follows: Section 2 defines a "component" for our study. Section 3 overviews our component selection and integration strategy. Section 4 addresses preliminary concepts related to term rewriting and optimal code generation crucial for understanding our technique. A detailed explanation of our method is provided in Section 5. Section 6 outlines how we implemented our approach, while Section 7 delves into case studies. Section 8 compares our work with existing research, and we conclude in Section 9.

For instance, in Section 2, we explore how complex load operations involving addition and multiplication can map to either multiple simple commands or a single complex instruction. Similarly, doubling a number may use either a multiplication or a more efficient left-shift operation.

We combine term rewriting with A* search, enabling efficient searches while minimizing exploration based on heuristic functions that underestimate actual costs. Such heuristics can prevent combinatorial explosion, a significant issue in computational problems.

Finding the optimal solution in a search problem, like selecting the best route between two points, can be compared to identifying optimal terms in our context. Employing A* search with an admissible heuristic ensures timely and optimal solutions.

Selecting components for a set of services is NP-complete, and term rewriting can sometimes be undecidable. However, by focusing on ground terms and limiting rewriting rules, we can manage the resulting complexity for practical applications.

Our algorithm maintains a list of active terms, iterating to select the least expensive term, generating successors through rewrite rules, and stopping upon reaching a goal term.

The approach is implemented using ML due to its suitability for handling higher-order functions. Our implementation generates components and adaptors fulfilling system specifications, with terms managed through a generic datatype.

Heuristic functions significantly impact search efficiency: a small example with 4 services and 7 components yielded an optimal result with notably fewer visited nodes when using informed heuristics compared to uninformed search.

Two case studies are presented: an automotive system and an EJB-based software component system constructed as a chatterbot for handheld devices.

The component selection process is dynamic, adjusting constraints throughout the rewrite process, and the implementation automatically integrates selected components using adaptor code.

Lastly, we cite important contributions regarding the generation of adaptors, particularly modeling protocols with finite state automata to ensure properties like deadlock-freeness and liveness.

We conclude that by adopting compiler construction techniques, specifically for optimizing code generation, our algorithm efficiently constructs cost-optimal component systems driven by the applied heuristics. Our case studies underline the significance of a good heuristic in reducing the search space and enhancing the method's effectiveness.