As embedded systems become ever-present in modern technology, ranging from household devices to complex military applications, it's become increasingly vital to use formal methods to design these reactive systems. One popular method for verifying reactive systems is model checking, where a system's model (known as a Kripke structure) is checked against a set of desirable properties expressed in temporal logic. This is an automated process where the system either passes the verification or produces a counterexample if it fails the desired criteria.

However, many of these systems are "open" systems that continuously interact with their external environment, which introduces a mix of controllable system states and uncontrollable environment states. This has led to the realization that the traditional model checking may not suffice for these open systems, especially when dealing with branching formulas in their specifications. Instead, a modified approach called module checking is better suited here because it considers the asynchronous, uncontrollable nature of the environment.

Building on this understanding, we have enhanced an existing model checker called NuSMV to perform what we term "local module checking." We compared this approach to another method that determines the most extensive possible environment where a certain CTL (Computation Tree Logic) property still remains valid, showing that local module checking has performance advantages. Our benchmarks are based on NuSMV examples that feature both system and environment states.

The key difference between model and module checking is that the latter only considers the transitions initiated by the environment, rather than assuming every possible transition is always available. In open systems, states and transitions are divided into system-controlled and environment-controlled ones. Unlike global module checking, which checks a module against all possible environments, our local module checking searches for a single specific environment where the given CTL property holds true. Although this approach does not identify the largest environment where the property holds (as global module checking does), it's typically faster since generating the largest environment tends to take more time.

Our observations indicate that many modules can satisfy both the original property and its negation under different environments, with many models having multiple initial states. The local module checker demonstrated varying performance across models, typically taking longer for models with denser transition relations and shorter for sparser models, even when there were more reachable states. When the CTL formula was indeed satisfied by the model, the local module checker generally required slightly more time.