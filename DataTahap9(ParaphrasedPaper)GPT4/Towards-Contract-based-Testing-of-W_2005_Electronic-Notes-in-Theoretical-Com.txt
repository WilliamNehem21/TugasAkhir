The academic paper posits two foundational assumptions: The first is widely recognized, implying that various systems require a foundational level of testing which can usually be achieved through unit tests. The second assumption highlights the challenge of integration testing in loosely coupled distributed systems, suggesting that specifications must be comprehensive and informative due to the impracticality of such testing.

The main sections of the paper are laid out as follows: Section 2 delves deeper into the 'design by contract' approach. Section 3 applies this concept to web services and suggests portraying contracts via graph transformation rules for better visualization. Section 4 explores how contracts can facilitate the testing process, and Section 5 concludes the findings.

A contract specifies expectations of the involved parties without dictating the means of fulfillment. It often uses assertions—boolean expressions related to software entities asserting specific conditions during software operation, such as a positive integer value or a non-null reference.

At the implementation level, contracts comprise boolean expressions in programming languages, utilizing functions—like accessing fields or calling methods—and operators to denote pre-conditions and post-conditions.

Given that most web services are built using object-oriented languages, which typically only support syntactic contracts, the paper notes that languages like Eiffel offer inherent support for behavioral contracts with preconditions, postconditions, and invariants. To extend existing languages with behavioral contracts, one can use tools such as iContract, JML, or JContract for Java, with a provided example of JContract usage.

The paper also acknowledges difficulties with readability and writability for humans at the first two levels of contracts and proposes a more visual documentation and communication method at the model level. This aims to facilitate understanding and discussion among developers.

'Design by contract' is a formal rule-based method for specifying operation behavior and incorporating specification directly into code. This is further used to support testing by forming a basis for creating test cases and test oracles, which are important for functional or black-box testing to ensure the final product adheres to its specifications.

Instead of manually deriving test cases, the paper considers employing the JTest tool from Parasoft alongside JContract. JTest, a Java-based unit testing tool, aids in pre-integration component testing. JTest uses JContract's contracts at the implementation level to automatically generate test cases and verify output, thus enabling automated functional unit testing.