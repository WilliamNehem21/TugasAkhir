Many studies in the field of software coordination models and languages focus on enhancing interoperability. These studies have developed models based on either data or control-event orientation. A noteworthy recent advancement is the introduction of Reo, a model that employs connectors composed of communicating channels.

The expressiveness of both the Linda and Reo models has been assessed through different methodologies. Brogi and Jacquet conducted a comprehensive analysis on Linda, comparing it with other concurrent languages through modular embedding. When Reo was launched, Arbab illustrated its expressiveness by simulating various communication mechanisms in a straightforward and elegant manner. This paper aims to perform a comparative analysis between Linda and Reo models, contemplating both Linda's asynchronous behavior and Reo's synchronous behavior. Linda is premised on communication primitives interacting with a shared tuple space, while Reo uses primitives that operate on connectors made from diverse channels. To ensure a fair comparison, the paper will define two process calculi, one for each model.

The paper is structured as follows: an introduction to both interaction models, their semantics, the two process calculi, and their defining properties is provided in section 2. The comparison method and its implementation for both models are in section 3. The paper concludes with a summary and future research directions.

Reo's multitude of channel types can emulate other coordination models. The bag channel type allows write operations (with an unbounded buffer like a multiset) and nondeterministic read or take operations, thus emulating Linda's interaction with the store. Further in the paper, this relationship is substantiated.

A process algebra 'L' that includes Linda's communication primitives (to add, remove, or test for tuples) is discussed, alongside standard operators for prefix, choice, and parallel compositions, similar to CCS.

Another process algebra 'R' based on Reo's primitives (to write, take, or read from a connector) is proposed, where agents are built using prefix operators, nondeterministic choice, and parallel compositions. A formal syntax for 'R' is given, including the semantics of connectors that influence the operational semantics of R.

The paper further compares languages 'L' and 'R,' taking into account different versions of 'R' based on the connectors. The comparison uses the concept of modular embedding, analyzing the expressiveness of 'L' and 'R,' and establishing compilers for each, demonstrating the existence of modular embedding between the two.

For the asynchronous case, the expressive power of 'L' and 'R' is compared in the context of a specific connector 'LR.' Actions in 'R' are simplified by omitting connector ends in the notation. The parallel composition is represented as two independent processes in Linda with different labels, while the compiler for nondeterministic choice maintains the original process identifier to prevent synchronization between branches. The paper provides results to support the modularity of the embedding, satisfying properties that affirm the preservation of operators and observables through compiling.