Several methods exist for creating program visualizations. The simplest form is akin to a sequence of animated images, possibly using Flash, but such methods typically offer minimal interaction with the user. More flexible visual interpreters, such as Jeliot 3 and VIP, which are freely accessible for introductory programming education, allow for better user interaction.

A program visualization tool usually displays the program code within a window, potentially with brief embedded commentary. Its objective is to clarify program execution for learners, complemented by supplementary explanations that highlight important aspects.

To prevent instructional material from excessively lengthening the source code, it can be housed in a separate window, showing only instructions pertinent to the currently executed code line. This benefits students by allowing them to focus on detailed explanations as needed, while others can ignore them since they are not integrated into the visualization itself.

Improving instruction expressiveness, developers can annotate when instructions appear, such as only on the first encounter with a specific statement, potentially changing upon subsequent visits. This tailors instructions to be more engaging and useful, guiding students, for instance, during a function call.

Annotations, linked to program execution order, allow for expansive explanations but do not inherently support interactivity. If the tool allows for editing the visualized source code, it can facilitate interactive visualization exercises. Our proposition is to employ a visual interpreter that treats parts of the code as hidden, enabling the teacher to embed tests within these segments. For example, tests could execute a student-implemented function multiple times, providing feedback based on the outcomes.

During visualization, the input stream (cin) functions normally by requesting user input. However, during testing, it is typically undesirable to solicit input from the student, which could cause confusion and potentially enable cheating. Teachers should predetermine inputs to ensure rigorous testing.

Incorporating this functionality into an existing interpreter is seamless, as it leverages the same interpreter for hidden code tests. Subsequently, the tool may serve for both standard visualizations and those involving problem-solving.

While integrating tests into a visual interpreter, its efficiency must be considered. Although visual interpreters do not require high efficiency, as visualization should not be excessively quick, they should still execute hidden code tests within a reasonable timeframe. If delays occur, students should at least have a progress indicator to follow.

Annotating instructions within an interpreter-based visualization tool is straightforward. Using creativity, these instructions can create interactive exercise visualizations that encourage student participation. Adding this modest feature significantly expands the tool's pedagogical potential.