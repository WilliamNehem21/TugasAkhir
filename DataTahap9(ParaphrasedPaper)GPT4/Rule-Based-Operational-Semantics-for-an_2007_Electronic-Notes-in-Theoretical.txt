This paper discusses the operational semantics of programming languages, which generally come in two types: big-step and small-step semantics. Both types use deduction rules, but they often overly focus on values rather than memory states, which isn't ideal for imperative languages.

To address this, the paper introduces a rule-based style of semantics that merges small-step and big-step approaches while prioritizing the examination of memory states. This hybrid method explicitly defines the sequence of execution at a syntactical level and is beneficial for languages that manipulate state and have complex evaluation orders.

In conventional small-step semantics, atomic steps are presented as axioms, and reduction is handled within specific contexts, which can be complicated to define. To simplify, this paper suggests constraining rewrite rules to atomic stores, which guides the system to permit only one reduction at a time. The use of intermediate notations helps eliminate context rules by marking when the evaluation of an expression is in progress, thus dictating the sequence of evaluation.

The paper proposes three new semantic frameworks for a minimalistic imperative language that are more abstract than concrete machines but offer advantages over traditional approaches. These include using term rewriting models, clearly delineating the evaluation process, and creating a more balanced treatment between memory states and values.

The authors believe that this novel approach to semantics is promising and could facilitate the application of results and tools from rewriting theory to the semantics of programming languages. Moreover, it could serve as a better intermediary between high-level language specifications and practical implementations.