Demartini, Iosif, and Sisto have explored using the SPIN model checker for analysing Java multithreading by converting Java code into PROMELA language. Their work, aiming at source code verification through automatic abstraction for simplified modeling, has proven effectively in simple cases. Havelund and Pressburger improved upon this by expanding language support and testing on Java programs up to 2,000 lines. Both efforts faced challenges in translating Java's concurrency features, a concern not applicable to the C2EDL method.

Visser, Havelund, Brat, and Park advanced Java Pathfinder to its second version, crafting a dedicated Java model checker instead of translating Java to PROMELA like in its first iteration. In contrast, C2EDL does not design new model checking algorithms but employs models to use existing ones, showcasing its full automation on significant applications.

Another study by Esparza, Hansel, Rossmanith, and Schwoon introduced model checking algorithms for pushdown automata, opting for radical variable abstractions and dealing with infinite stacks, different from the finite state models used by C2EDL. Their impressive results on large flow graphs also contrast with the finite approach of C2EDL.

The development of RuleBase over eight years, although originally based on SMV, has now evolved to include minimal SMV code, retaining its garbage collection mechanism. To extend the translation process to C programs with complexities like pointers and recursive functions, mocking a compiler or starting from assembly or machine code could be theorized, yet practical application is hindered by the state explosion problem.

Using C2EDL, the garbage collection usage in SMV and RuleBase was examined. C2EDL's use of bit vectors and a limited stack depth facilitated the detection of programming bugs within RuleBase before conventional testing began, simplifying the debugging of difficult issues.

Problems found during testing of RuleBase's function `reduction()` exemplified the benefits of static problem identification through model checking, pinpointing source lines linked to failures instead of waiting for tests to fail unexpectedly. Nonetheless, the limitation to shallow stack depths means not all errors may be detected, and false positives can occur, suggesting that such methods are better suited for falsification rather than verification.

Acknowledgments in the paper include thanks to Ilan Beer for insights on the garbage collection mechanism solely as a function of the program counter and to Shoham Bendavid, Avigail Orni, and Yaron Wolfsthal for their review and valuable feedback.