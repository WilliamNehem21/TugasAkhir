This paper introduces a method for modifying non-recursive functional programs to eliminate square roots and division operations. The methodology ensures that the transformed code can be computed exactly, which is particularly relevant for systems that require precise computation, such as those in aerospace and safety-critical applications. The paper focuses on accepting various subsets of programming languages as input to the transformation and provides proof of correctness when dealing with the PVS (Prototype Verification System) language. For each function in the transformed code, there is a corresponding definition in the input code that describes how the transformed function behaves concerning the original one. 

The authors have built this system in OCaml and tested it on multiple algorithms from NASA's ACCoRD project. The paper discusses that while not all square roots and divisions can be removed (e.g., sqrt(2) still needs a rounded value), their removal from boolean expressions and definitions ensures control flow can be computed precisely, avoiding rounding errors.

The paper elaborates on the syntax and semantics of the language used, with expressions like 'let in' and 'let fun' and denotes how semantics are preserved through transformation. The authors also describe two techniques for eliminating square roots and division within boolean expressions to reduce complexity.

A key aspect of this transformation is the reduction in the size of the output file by factorizing large expressions into separate functions, improving maintainability, and allowing these functions to be shared among various program transformations. 

The authors provide an example of the transformation on the CD2D algorithm from NASA's ACCoRD project, an algorithm for detecting potential collisions between aircraft in two-dimensional space. They highlight how comparison operations within the algorithm are replaced with functions that encapsulate the necessary logic, making the output code longer but more precise.

Finally, the paper claims that the developed transformation allows more accurate computations by eliminating problematic operations and facilitating the use of decision procedures that previously could not handle square roots and divisions. The transformation assures that the semantics of the programs are maintained, providing a certifying mechanism that validates the correctness of the transformation process.