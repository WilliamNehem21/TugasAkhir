We suggest a new, more modular approach to create verification condition generators by employing concepts from monadic denotational semantics and generic programming. This method enables us to enhance existing verification condition generators to support new language features and also allows for additional functionalities like generating validation traces. We illustrate our technique with an example by augmenting a basic while language with an exception handling construct, which requires not only an extension to the logic but also a modification to its structure.

Developing and maintaining programming logics that realistically model languages is difficult. Few strategies exist for managing updates prompted by language modifications or feature introductions, and implementing these changes can be risky and prone to errors, potentially leading to inconsistencies within the logic.

Our approach offers numerous benefits. It is safer to use, allows for modifications to be toggled on and off as needed, and enables us to revert to the original logic implementation if necessary. Furthermore, it facilitates the creation of various partial logics, each applicable for more streamlined verification tasks.

We employ generic programming and monadic denotational semantics to represent our syntax-driven logic. Generic programming helps us abstract away from the concrete implementation of a program's abstract syntax. We use a generic fold to encapsulate recursive data-type processing, enabling us to separate the recursion pattern from the semantic computations.

Monadic denotational semantics was devised to isolate different concerns within denotational semantics. Its core principle is to define an abstract domain that allows different computations to combine uniformly. With a monadic domain, we can conceal certain aspects that don't influence specific parts of the logic, thereby maintaining the original logic code even when the underlying structure is expanded, which would typically impact the implementation of each rule in the logic.

The traditional code is not flexible to adapt. Converting it into an explicit algebra over the provided data type simplifies modifications. Implementing this algebra through a fold over the abstract syntax means creating separate functions for each language construct and using these as arguments to the generic fold. These functions define a language algebra, with the language's constructs acting as operations. Applying this fold results in a homomorphism between the initial algebra and the defined algebra.

Although effective, such an approach requires replacing the entire monad when making changes. A better solution would allow enhancements to an existing monad. Instead of traditional methods like distributive laws or monad transformers, we opt to use monadic coproducts, as suggested by LÃ¼th and Ghani.

We need to determine a target monad R for mapping operations. For this, we use a state-carrying monad that includes a tuple of expressions as state. This monad provides "get" and "put" functions to manage the state within the monad.

With this approach to building verification condition generators, several avenues for future research open up. Not only do we aim for a more modular implementation, but we also want to verify it formally, as demonstrated in prior work. We hypothesize that our method not only allows code reuse but also enables proof reuse, so that re-proving properties like soundness for a revised generator might not start from the base case every time. While this appears feasible for simpler languages, it's uncertain whether this scalability extends to languages with functions and application constructs.