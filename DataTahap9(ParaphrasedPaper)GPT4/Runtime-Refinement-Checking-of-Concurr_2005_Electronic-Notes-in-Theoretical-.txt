This paper discusses the use of state transition systems to define the behavior of concurrent data structures and methods to verify their correct implementation at runtime. In Section 2, the paper establishes the foundation for state transition systems and the concept of refinement. Section 3 applies these ideas to a concurrent multiset and demonstrates the proposed runtime verification method. Sections 4 and 5 delve into the runtime refinement verification process in detail.

The paper concentrates on data structures that multiple threads can access, specifically those implemented in object-oriented languages, by offering public methods. To distinguish these from internal methods, the authors introduce two sets of thread identifiers, one for application threads calling public methods and another for data structure threads handling internal tasks.

The paper defines atomic state transition systems, where runs are composed strictly of atomic actions, and deterministic systems, which produce unique runs for each trace. Additionally, the paper discusses the `insertpair` method of a multiset and the runtime verification of its implementation using commit actions, eliminating dependencies on the specific order of method calls and returns.

Extra effort is required from programmers to annotate implementations with commit points, which, in turn, allows efficient runtime refinement checks and possibly uncovers design flaws early on. The paper also notes that logging mechanisms used for recovery in distributed systems, such as in the Boxwood project, may be repurposed for verification.

The authors identify a need for a stronger correctness criterion beyond I/O refinement when testing, due to scheduling issues and differing concurrency behaviors under test workloads. They suggest a solution involving an auxiliary variable that captures the abstract state and allows for better error detection.

To effectively test and check implementations against their specifications, additional administrative overhead might be necessary. However, this could impact performance and concurrency, so the authors recommend optimizations like batching log entries for variables with exclusive access.

Finally, the paper presents a scenario where a multiset implementation fails to be linearizable and promotes runtime refinement checks as a powerful verification method. The authors conclude by noting their ongoing work in applying these techniques to real-world software design.