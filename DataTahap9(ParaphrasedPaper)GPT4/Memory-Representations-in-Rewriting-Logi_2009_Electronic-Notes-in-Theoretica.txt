In prior research, the performance impacts of specific design choices were assessed in the KOOL programming language, which adheres to pure object-oriented principles defined through rewriting logic semantics. The study particularly examined two aspects: treating all values as objects and employing a flat, global memory model. Performance advancements were achieved by revising these aspects, such as incorporating scalar values with automatic conversion to objects (auto-boxing) when necessary, and segmenting the memory into global and local pools to optimize multi-threaded memory access. These adjustments led to substantial improvements in both analysis and execution performance.

Furthermore, in the context of the SILF language, which lacks dynamic memory allocation and direct addressing, a different memory management approach was proposed. Instead of a flat memory model, a stack of memories was introduced, which aligns with the function call structure. Memory allocated for a specific function can be swiftly released upon return, reducing the overhead of managing memory and possibly enhancing efficiency.

Addressing garbage collection, the KLOCS operation requires careful consideration and modifications when introducing new language features that handle memory locations. An automated system to integrate garbage collection into a theoretical framework could minimize human error in updates.

Ensuring that garbage collection does not compromise the correctness of computation is also crucial. Only unreachable locations should be reclaimed by the garbage collector, leaving computation results unchanged. Proving correctness involves confirming: no roots are missed, all reachable locations are marked, values at such locations remain unaltered, and only unmarked locations are reclaimed.

This research ties into earlier studies on SILF and KOOL, where the focus was primarily on optimizing analysis performance, sometimes even at the cost of execution performance. The approach to memory management in KOOL and SILF, particularly the integration of garbage collection, aligns with broader research on memory management for pure object-oriented languages. While the mark-sweep garbage collector detailed in this paper is conceptually traditional and primarily distinguished by its formal definition in rewriting logic, it contributes to the extensive body of knowledge on garbage collection in computer science.