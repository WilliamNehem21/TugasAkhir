This paper is structured in the following manner: Section 2 discusses literature that is pertinent to this study. Section 3 outlines the design and implementation of IoTbench. Section 4 details the experiment configurations. Section 5 presents an analysis of the results obtained from the experiments. Lastly, Section 6 summarizes the findings and outlines avenues for future research.

CoreMark, established by Shay Gal-On at EEMBC in 2009, was intended to supplant Dhrystone as the benchmark standard in the industry. CoreMark boasts several strengths that have contributed to its widespread adoption. It features a compact, comprehensible set of code that can be easily ported across different systems. It circumvents the potential for code to be optimized away during compilation by incorporating data elements that necessitate computation at runtime. Additionally, CoreMark prescribes specific guidelines for code execution and a standardized reporting template, enabling the consistent comparison of performance across various processors.

The IoTbench benchmark suite encompasses tasks associated with list processing, matrix manipulation, and convolution operations. List processing is commonly employed in IoT applications for initial data cleanup and simple statistical evaluations, involving search and sort algorithms. IoT areas such as smart cities, homes, healthcare, and mobile technology rely on machine learning and deep learning for applications like voice control, image and text processing, and facial recognition. Consequently, convolution and matrix operations, fundamental to machine learning and deep learning, have been incorporated into IoTbench.

When dealing with data in IoT contexts, the dimensionality and data type requirements vary based on the application. Image data in computer vision is typically two-dimensional, while fields like medical imaging and video processing handle three-dimensional data. IoT scenarios dictate the choice of data types, often balancing computational resource constraints with prediction accuracy, such as opting for integer (int) precision over floating-point (float) calculations. Additionally, the volume of data varies; for instance, wearable devices produce large amounts of data for real-time monitoring of human physiological metrics.

List sorting within IoTbench is executed using a non-recursive implementation of merge sort, sorting elements based on their value or index. The sorting process groups every two elements, then progresses to larger groups, doubling its scope after each sorting pass until the whole list is ordered.

The gem5 simulator, a product of merging the M5 and gem projects, is a flexible, widely-used tool in academia, industry, and education for computer systems architecture research. It caters to both system-level architecture and processor microarchitecture modeling.

IoTbench is evaluated using the gem5 simulator, comparing the performance of the ARM and RISC-V instruction set architectures (ISAs) relevant to IoT systems. For ARM, we utilize the AArch64 execution state and the fixed-length 32-bit A64 instruction set. For RISC-V, we adopt the RV64GC configuration. The choice of ARM and RISC-V is based on their prevalence in the IoT sector. We also consider both in-order and out-of-order processor architectures. Cache sizes are set based on specifications from commercial processor companies like SiFive, using command-line options as per gem5's documentation.