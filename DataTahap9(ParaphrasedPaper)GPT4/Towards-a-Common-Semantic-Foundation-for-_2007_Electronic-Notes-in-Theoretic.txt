The completion of a use case involves the specification of extensions, which are alternative scenarios that may or may not satisfy the use case's objective. These extensions capture the full range of system behaviors, both ordinary and exceptional, crucial for a comprehensive understanding. Each extension begins with conditions related to the main scenario's steps.

User task modeling, a well-established method for user-centered UI design, depends on task sets as the principal input for UI design. By outlining tasks and inter-task relationships, user task models explain how users engage with the application. Rooted in activity theory, they describe actions changing artifacts to achieve goals.

Tasks are broken down hierarchically as a directed graph into sub-tasks and atomic actions, the latter being the bottom level (“leaf tasks”) actually executed by users or the system. Task execution order is structured through temporal operators like enabling (>>), choice ([]), concurrency (||), and disabling ([>), among others, each well-defined in task modeling literature.

Alur et al. and Katoen and Lambert have proposed different semantics for Message Sequence Charts (MSCs). Alur et al. focus on MSCs limited to message events, whereas Katoen and Lambert offer a broader, more complete semantics by mapping MSCs onto sets of partial order multisets (pomsets), which contain all variations that can be bijectively linked to a base labeled partially ordered set (lposet). Approaches using pomsets closely align with lposet-based methods.

Mizouni et al. introduced use case graphs as a preliminary step for use cases, creating directed, possibly cyclic graphs that depict use case actions and system states, simplifying the action sequence representation. They also detailed an algorithm for merging use case graphs into an Extended Finite State Machine (EFSM) based on shared states.

In use case modeling, state conditions restrict use case step executions, with pre-conditions defining required states for execution and extension triggers dependent on conditions. The semantic model must accommodate the concept of state to evaluate these conditions and map them to event occurrences.

This section exemplifies how ConcurTaskTrees (CTT) task models and use cases map onto sets of partially ordered sets (posets) by first reinforcing poset definitions, then defining operators over posets, and finally illustrating semantic functions that map use cases and task models to sets of posets.

To extract a task expression from a task model, an expression tree is made, with leaf-level actions as operands and temporal relations as operators. Inner nodes correspond to operators and have one or two children. The task expression is then mapped to a corresponding poset set.

The transformation of use cases into poset sets consists of two parts: first, converting the textual use case into an intermediate use case graph, and second, iteratively constructing a poset set from the use case graph. Posets are assigned to each transition in the graph, typically capturing a single event per use case step. This iterative transformation process ultimately simplifies the graph into an initial and final state system while combining posets along transitions. Attention is needed to address self-loops or pre-existing transitions between nodes.