The paper discusses the concept of Normalisation by Evaluation (NBE), first thoroughly investigated by Berger and Schwichtenberg around ten years prior. NBE is used to take a term from a programming language and find its normalized form by utilizing the language's semantic model. Functioning as a type-indexed function, it maps a semantic value back to a syntactically meaningful term at a particular type. The computation happens within the semantic model, but the end result is given as a syntactic expression.

The NBE approach was originally developed for practical purposes, specifically to give a syntactic representation to internal proof objects within the Minlog proof system at LMU Munich. The emphasis was on using Scheme's quote and unquote features for a native implementation of the NBE algorithm in the simply-typed lambda calculus.

This paper aims to demonstrate that NBE is also theoretically interesting in a rewriting context by illustrating how the algorithm can compute normal forms using limited computational resources, like Plotkin-style evaluation semantics. This reveals implications for practical applications in compiler technology. The authors propose a calculi for NBE that operates under different evaluation strategies, such as call-by-name (CBN), call-by-value (CBV), and call-by-whatever (CBW).

They argue that their method effectively illustrates the operational aspects of NBE calculation, making it more understandable and potentially useful for real-world programming language applications. The paper also touches on the soundness of the NBE method with respect to other typing paradigms and rewriting systems.

The authors introduce a two-level NBE-calculus to reflect the type theory of different evaluation settings. This framework separates semantics (indicated by overlines) and syntax (indicated by underlines), with interaction only permitted at the ground type to maintain analyticity. They clarify that maintaining the type-indexed nature of the NBE algorithm is essential to this separation.

Considering the selection of fresh variable names necessary for the reify and reflect processes, the paper offers a simple solution with two distinct types of variable names. It's also highlighted that the functions # and " do not compromise the structural integrity of the terms due to their inductive definition over types.

The authors conclude with practical demonstrations of the NBE machine in operation, providing examples of code execution and encouraging readers to consult their online resources for more details. They reference a work by Andrzej Filinski on type-directed partial evaluation, offering a semantic perspective and implying that NBE might contribute constructively to this field.