This paper addresses the concept of type systems in computing, where types are expressions that represent possibly infinite sets of ground terms. Regular term languages, known as regular types, are frequently utilized as types within these systems. However, most type systems opt for tuple distributive types, which are a less expressive subset of regular types that remain closed under tuple distribution.

The paper introduces an algorithm specifically designed to determine whether a given type expression represents an empty set of terms. It proposes that the subtyping problem can be simplified to this emptiness problem since their type language supports operations like union, intersection, and complement of sets. The paper assures the validity of this algorithm and examines its computational complexity. The algorithm is applicable to regular types that allow parameters in their definitions, and it accommodates polymorphism (both parametric and overloading) within these definitions. These types are notably beneficial for compilers and programming tools, such as debuggers, due to their straightforwardness for programmers. Type expressions within this system may also include set operators, which provide a succinct and intuitive way to depict regular types.

Despite the fact that existing theoretical advances for tree automata could be leveraged to manage regular term languages as types, direct application of tree automata emptiness algorithms is not feasible because type definitions might include parameters. Hence, constructing a new tree automaton for each emptiness check of a type expression would be inefficient. To address this, the paper offers a novel algorithm that interacts directly with type definitions, negating the need for repeated automaton construction.

The structure of the paper is as follows: it defines the language of type expressions and type definitions, introduces the emptiness testing algorithm, proves the algorithm's correctness, and elaborates on the algorithm's complexity. It concludes by summarizing the findings. The paper suggests an approach for ensuring algorithm termination by focusing on tabling conjunctive type expressions, facilitating the identification of empty implications among these expressions.

Complexity discussion is limited to the worst-case time complexity, which is assessed in terms of the number of nodes in the evaluation tree for the type expression being analyzed. The paper implies that by systematically addressing the tabling of expressions and focusing on conjunctive forms, the algorithm can efficiently deal with the problem, providing a significant contribution to the field for both theoretical understanding and practical application.