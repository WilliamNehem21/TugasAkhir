Tabu search-basedﬂeet scheduling of air ambulances for disaster response
Joseph Tassone*, Salimur Choudhury
Lakehead University, 955 Oliver Road, Thunder Bay, ON, P7B 5E1, Canada
ARTICLE INFO
Keywords:Air transportationCUDAFleet schedulingInteger linear programmingLocal searchTabu searchABSTRACT
Proper scheduling of air assets can be the difference between life and death for a patient. While poor schedulingcan be incredibly problematic during hospital transfers, it can be potentially catastrophic in the case of a disaster.These issues are ampliﬁed in the case of an air emergency medical service (EMS) system where populations aredispersed, and resources are limited. There are exact methodologies existing for scheduling missions, althoughactual calculation times can be quite signi ﬁcant given a large enough problem space. For this research, known coordinates of air and health facilities were used in conjunction with a formulated integer linear programmingmodel. This was the programmed through Gurobi so that performance could be compared against custom algo-rithmic solutions. Two methods were developed, one based on neighbourhood search and the other on Tabusearch. While both were able to achieve results quite close to the Gurobi solution, the Tabu search outperformedthe former algorithm. Additionally, it was able to do so in a greatly decreased time, with Gurobi being unable toresolve to optimal in larger examples. Parallel variations were also developed with the compute uni ﬁed device architecture (CUDA), though did not improve the timing given the smaller sample size.
1. IntroductionDisasters can strike at any time and in these scenarios, it can bedevastating if there is not an efﬁcient emergency medical service (EMS)system. While this can be problematic in a city-based environment, it iscatastrophic when considering a larger air ambulance system. Thesevehicles travel over much longer distances, through regions with verydispersed populations. While patient transfers may occur betweenpopulous areas, this is not guaranteed during a disaster. Additionally,many air ambulances have a rather small contingency [ 1] which must cover all missions within a certain time frame to be effective. It is criticalto accurately schedule vehicles in such a way that these potentially vastdistances can be managed, and patient lives can be secured.This work is a continuation of prior research which sought to opti-mize the staging and positioning of air assets [ 2]. Therefore, despite it being an independent methodology, it is also part of a greater problemdirected towards air ambulance management. This is not necessarilynew, as there have been several exact methodologies suggested previ-ously [3]. Though solving for optimal is not always unreasonable, sincescheduling is NP-hard, it becomes much more time consuming with anincrease in the solution space. The issue with this is compounded in acritical system like EMS where time can mean the difference between lifeand death. Near-optimal metaheuristics provide an effective alternativeas they achieve acceptable solutions in a much more manageable win-dow. In this research, known coordinates of air and health facilities wereutilized and aided in simulating an actual scheduling scenario. A missionin this case always began at a vehicle occupied base and returned to thesame base. Subsets of missions could be performed by each vehicle with arespective mission performing a pickup and delivery before continuing tothe next point. Two algorithmic solutions were developed for thisproblem and each was structured using a sequential and parallel meth-odology. For the latter, the Compute Uniﬁed Device Architecture (CUDA) platform was employed and timed against the former for each algorithm.Overall, the goal was to develop a model with integer linear program-ming and then formulate algorithms which could attain a similar solutionto the optimal.This paper is arranged as follows. Section 2describes the related work with a description of past techniques and solutions. Section 3outlines the modelling of the problem, emphasizing constraints and the objective.Section4displays the algorithmic solutions, describing the neighbour-hood and tabu search, as well as the initialization technique. Sections 5 and 6respectively show the results and conclude the paper.2. Related workFor scheduling problems, neighbourhood searches have been well-
* Corresponding author..E-mail address:jtasson2@lakeheadu.ca(J. Tassone).
Contents lists available atScienceDirect
Array
journal homepage:www.elsevier.com/journals/array/2590-0056/open-access-journal
https://doi.org/10.1016/j.array.2020.100047Received 21 July 2020; Received in revised form 15 October 2020; Accepted 27 October 2020Available online 11 November 20202590-0056/©2020 The Author(s). Published by Elsevier Inc. This is an open access article under the CC BY license ( http://creativecommons.org/licenses/by/4.0/ ).Array 8 (2020) 100047documented in achieving successful results. Da /C21glayan and Karakaya suggested a solution for scheduling ambulances following a disaster andformulated it as a capacitated vehicle routing problem (CVRP) [ 4]. In their research, they minimized the routes and then reduced the averagetravel time to health facilities. For this process they developed both agenetic algorithm and nearest-neighbour heuristic. Both operated inde-pendently and were compared in three different test cases. These werebased on capacity where light damage had 1 victim, medium damagecould have 1 to 8 victims, and heavy damage had beyond 8. While theauthors claimed that further study was required, when compared againstCVRP benchmarks the genetic algorithm achieved shorter distances. Thiswork does require additional testing, as there is a limitation in utilizing asingle facility and ambulance.Tabu search is another successful algorithm in scheduling, being anextension of the neighbourhood-based algorithms. In this type of solutionrecently explored neighbourhoods which improved the result areignored, preventing the risk of achieving only a local optimum [ 5]. Oberscheider and Hirsch utilized this methodology in conjunction withreal-patient data to ensure the efﬁcient transport of patients for lowerAustria’s Red Cross [6]. They developed an algorithm based on the staticmulti-depot heterogeneous dial-a-ride problem and generated allpossible combinations of patient deliveries considering a set of con-straints to solve it. For each prior generation, set partitioning was per-formed to achieve an initial solution and then these were inputted into aTabu search metaheuristic for optimization. The authors claim that thework is an improvement upon previous variations as it considersnon-static service times that depended on the combination of patients,their transport mode, the vehicle type, and the pickup or deliverylocations.Another research presented by Repoussis et al. formulated a mixedinteger linear programming model for the scheduling and routing of largecasualty disasters [7]. They sought to use a minimized amount of re-sources while also being able to achieve a reduced response time. Theirsolution was developed as a hybrid multi-start local search, involving anexact construction heuristic followed by an optimization by iterated Tabusearch. Initialization utilized a greedy technique for assignments andthen the problem in its reduced state was optimized. A high-quality upperbound was achieved and these were inputted into the Tabu search,repeating until the stopping condition was met.Most solutions involve sequential designs where a solution mustiteratively solve until reaching an optimal. While not a new trend, par-allelization has been utilized to achieve higher calculation speedsthrough the graphics processing unit [ 8]. The algorithms must be rede- veloped to take advantage of the multiple simultaneous threads and loopsare replaced by these to perform calculations. Additionally, threads aredivided into blocks which can be an issue in larger problems. In this casethread communication occurs within blocks, but synchronization cannothappen between them. For these scenarios block level design must beconsidered along with thread design. Regardless, the primary bottleneckis related to the kernel call to GPU when the problem space is smallenough. Race conditions are another potential issue, though CUDA pro-vides both shared memory and locks to deal with this problem [ 9]. While prior parallel research has been performed, it is limited interms of optimization problems of this type. Schulz et al. performed asurvey revealing a small amount of literature on applying GPU paralle-lization to local or Tabu search [10]. The same can be said when appliedto regional or air ambulance problems. Hussai et al. redeveloped theparticle swarm optimization algorithm by using CUDA to performpartially coalescing memory accesses [ 11]. When compared against benchmarks the new algorithm was able to gain a signi ﬁcant improve- ment in time compared to a similar sequential variation. Similarly, Fabrisand Krholing used benchmarks and applied CUDA to a co-evolutionarydifferential evolution algorithm for solving min-max optimization prob-lems [12]. Their research showed that the algorithm was able toconverge to a near optimal result, although in a much better time whenscaled up.3. ModelScheduling of air ambulances follows predetermined positions, whereambulances are already placed at bases. Time is also a factor as sched-uling relies on patients arriving at certain periods. This may be due tourgency from an incident or transfers for more specialized care. Whilethere are potentially many bases in an EMS system, this schedulingproblem only deals with the subset of bases that have vehicles assigned tothem. In general, unless otherwise speciﬁed, the scheduling problem treats the terms vehicles and bases as synonymous.
In this case a mission starts at a base and can be made up of at least asingle pickup and delivery. However, rather than a simple return to base,another mission may be assigned to that vehicle, where it will continuefrom the previous delivery to next pickup. Therefore, the schedule willconsist of each base being assigned a set of missions, followed by a returnto the original base. An example of this problem and all possible setupscan be seen inFig. 1. There are three bases, with four missions. So long asthe constraints are met, each base can have either as many missions aspossible assigned or none. Essentially, this means a base can be assignedone or more missions up to the maximum which require assignment.The potential bases consist of the following two sets:P: the set of allﬁxed-wing plane occupied bases with each being a 4-tuple of forma
k¼<ksϕ kψk>,a k2P8k¼1,…,4 k/C17base IDs/C17vehicle speedϕ
k/C17row coordinate of basek
ψk/C17column coordinate of basekH: the set of rotary-wing helicopter occupied bases with each being a4-tuple of form.h
k¼<ksϕ kψk>,hk2H8k¼5,…,12 k/C17base IDs/C17vehicle speedϕ
k/C17row coordinate of base k
ψk/C17column coordinate of base kThe set of all missions consists of:M: the set of all missions, with each being a 6-tuple of form.m
n¼<nϕ pψpϕdψdρ>,m n2M8nn/C17mission IDϕ
p/C17row coordinate of patient pick-up location
ψp/C17column coordinate of patient pick-up locationϕ
d/C17row coordinate of patient delivery location
ψd/C17column coordinate of patient delivery location
ρ¼/C261 if mission requires rotary/C0wing helicopter0 otherwiseSetsHandPare vehicle occupied bases, where both are constant andlocked to their speciﬁc coordinates. No other bases can be utilized andfollowing a set of missions there must be a return to the original base.Both sets are parts of the full set of bases which can be utilized, stated as P [H¼K. Additionally, rather than total distance, the travel time from oneposition to another is considered. Helicopters and planes travel atdifferent speeds, meaning that regardless of distances they will arrive atdifferent times. Therefore, speed must be considered for each set toperform accurate scheduling. Missions have speci ﬁc requirements where only a helicopter occupied base may perform certain missions.J. Tassone, S. Choudhury Array 8 (2020) 100047
2There are a set of variables for the problem with a summary show inTable 1.x
ijkis binary, where an instance will be 1 if a mission itojare connected and starting from basek. Additionally, the variableu
iis uti- lized for subtour elimination based on the Miller-Tucker-Zemlinconstraint [13]. For the exclusion of subtours the value can be i¼{1, …,n} for each basek. The model also considers a set of constants p,w
n,bk, andf
n. Bothpandw ncontribute to time constraints where pis the maximumﬂight time allowed by a vehicle in a day (10 h for the purposesof this research) andw
nis the time by which a vehicle must arrive at abase by. In the scheduling problem they are independent as once avehicle arrives for a mission it must wait until its respective w
nto continue to the next point. The constant ponly considers actual time in ﬂight and does not recognize waiting. Both b
kandf nare utilized for limiting certain bases to certain missions. b
kstates the type of vehicle that is at an individual base (0 for helicopter and 1 for plane), while f
nde- scribes the vehicle requirement that must be used for a mission (0 forhelicopter-only and 1 for any vehicle).In addition to distance calculations, the respective travel time isconsidered as determined by the speed of the vehicle. Based on knownstatistics about air ambulance vehicles, rotary-wing helicopters areassigned a speed of 300 km/h [14] andﬁxed-wing planes are assigned a speed of 500 km/h [15]. The matrixdis the result of the calculation, where the distance fromitojis determined and divided by the speed ofthe vehicle. The respective result is then placed into lwherel0is for helicopters andl
1is for planes. The distance is determined for a base asthe sum of each mission’s patient pick-up and delivery locations. Sincethis is not simulated data, Haversine distance is considered. The fullcalculation can be completed with the following:D
ij¼2rsin/C01/C18ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃsin
2/C16φ/C0φp
2/C17þcosðφÞcos/C0φp/C1sin2/C16ψ/C0ψp
2/C17r/C19(1)In the above formulaϕrepresents row locations, while
ψapplies to column location values.K
sis used to indicate a speciﬁc speed of a vehicle at a base, which is divided by the Haversine distance calculated. Theresulting matrix is of dimension (nþk)/C2(nþk)/C22 and referenced for achieving total travel time for each mission. The optimization modeltakes the following form:minimizeX
iX
jX
kxijkdijl;l¼b k (2)subject toX
iX
kxijk¼;8j (3)X
jX
kxijk¼;8i (4)X
ixink¼X
jxnjk;8k;n (5)X
ixijk/C201;8j;k (6)X
jxijk/C201;8i;k (7)X
iX
jxijkdijl/C20p;8k;l¼b k (8)
Fig. 1.Basic scheduling setup for missions and bases.
Table 1Summary of scheduling model variables.
Variable DescriptionxijkA binary decision variable determining whether a mission itojare connected, while starting and ending at base k dijlTime matrix where the distance from itojis divided by the speed of the vehicle of typelpConstant stating the maximumﬂight time allowed by each vehicle per day w
n Constant stating the time by which a vehicle must arrive at mission nby f
n Constant stating the vehicle requirement for a mission n(0 for helicopter- only and 1 for any vehicle)b
k Constant stating the vehicle situated at a base k(0 for helicopter and 1 for airplane)u
i Integer decision variable for the exclusion of subtours, the value is aranked order where a value i¼{1,…,n} for each basekJ. Tassone, S. Choudhury Array 8 (2020) 100047
3xijkdijl/C20x ijkwj;8j;k;l¼b k;i/C20n (9)x
ijk/C0d
ijlwi/C1/C20x
ijkwj;8j;k;l¼b k;i>n(10)x
ijkðbk/C0fiÞ/C200;8i;j;k (11)u
i/C0u jþn/C0x ijk/C1/C20n/C01;1/C20i6¼j/C20n;;8k(12)x
ijk¼0;ði6¼j;kÞ2K (13)x
ijk2f1;0g;8i;j;k (14)u
i2fi¼1;…;ng (15) Equation(2)describes the objective function, where the total timeﬂown by each vehicle to its assigned missions are minimized. Each set ’s d
ijlis summed based on its corresponding x ijkvariables which have a 1. The actual distance is determined by the constant b
k, where the index ofl equals the respective value. The objective function is also constrainedbased on the rules set by Equations(3)–(15). Each mission can only be completed once, constrained by Equations(3) and (4). Equation(5)guarantees route continuity, where eachmission must continue from one to the other along their assigned route.To ensure that missions leave and return to the same base, the modelconsiders Equations(6) and (7). As previously stated, vehicles can onlyﬂy so long which determined byp. The constraint for this is upheld byEquation(8)for each basekset of missions. The remaining time con-straints are determined by Equations (9) and (10). Theﬁrst is for when a vehicle is travelling from a base to a mission. In this case the base doesnot have a time limit and begins at 0. The second considers either amission to a mission, or a mission returning to a base. In the latter casethe limit is usually assumed to be correspond to the number of hours in aday. Regardless of travel time the vehicle must wait until that mission ’s time limit to travel to the next one. The distance summed with the pre-vious time limit must be less than the next mission ’s time limit. To force each mission to be correctly assigned to a valid base, themodel uses Equation(11). There is only one invalid permutation for thisassignment, where a plane is assigned to a helicopter-only mission. Thisis prevented as all other possibilities are forced to be less than or equal to0. The subtour elimination constraint is outlined by Equation (12)and uses the Miller-Tucker-Zemlin formulation. For this constraint, u
iis a variable associated with each mission and is used to eliminate sets that donot begin and end at a base. The variable is equal to the order in whicheach mission occurs for each base k, where the base begins at theﬁrst index [16]. To further limit the formulation, Equation (12)prevents bases from travelling to other bases other than themselves. Lastly,Equations(13) and (14) limit the values which can be assigned to eachvariable.4. AlgorithmAll the solutions within this section were designed with considerationof the constraints and variables in the scheduling model above. The al-gorithms each had a sequential and parallel CUDA implementation. Asthere were only minor changes within the algorithms, Algorithm 2 and 3are outlined as the sequential versions. Any other alterations are givenfollowing a description of each one.4.1. Scheduling initialization algorithmDue to the constraints, there is no guarantee that a randomizedinitialization will be able to generate a valid solution. Since vehicles mustﬂy under a certain period and within a particular limit there is anincreased difﬁculty in discovering a starting state. Therefore, Algorithm 1was developed toﬁnd an initialized organization for optimization. Toclarify, the algorithm is not designed toﬁnd a near-optimal solution, only to determine the existence of any solution. Essentially, the method willattempt to assign missions to bases and upon failure will perform swaps.This will improve the current result and may increase the chances ofﬁnding a valid permutation. If after so many attempts, it does not ﬁnd a solution it will report an error.The algorithm accepts a set of occupied bases and a set of mission dataas its input. Lines 1–4 show the constant data that must be abided byincluding the distance matrices for each respective vehicle type, themission times determining when a vehicle must arrive by, and the dailyﬂight limit for a vehicle. TheSolutionmatrix declared at line 5 will hold each mission with a row starting and ending with a base, and compatiblemissions will thenﬁll in between these indices. The remainder of thealgorithm is broken up into a section for helicopter-only mission as-signments (lines 6–42) and then a section for the remaining missions(lines 43–77). For both, the outer loops will only terminate once all areassigned.Theﬁrst step at line 8 is to determine the unassigned mission with thesmallest time limit. There is an urgency for this to be completed ﬁrst as the time limit constraint cannot be broken. As per line 9, every base willbe checked, and the current bestﬁt will be held inCurrentMin. The next set of lines follow the constraints set by the model, limiting which basescan accept a mission. If a base breaks any of the requirements, then thealgorithm continues to the next possible base. Lines 10 –12 ensure that only a helicopter occupied base may accept a helicopter-only mission.Lines 13–34 are the time limit constraints, ensuring that vehicle does notpass the arrival time set for a respective mission. This part is broken intotwo parts based on whether a base already has missions or has yet to haveone assigned to it. As the mission is being placed between two indices itmust consider the vehicle arriving at the new mission and the travel newmission to the next one. Additionally, once a vehicle arrives at a missionit must wait until that time limit to move on to the following. If it isstarting at a base the limit is 0 and not considered, while if it fromanother mission it must utilize the distance to the next plus the previoustime limit. If the vehicle is returning to a base then the time cannot pass apredetermined maximum limit, currently expressed as the number ofhours in the day. Lines 29–31 performs a check on the currentﬂight time of each set of missions. This constraint only considers actual ﬂight time and not the waiting enforced by the previous constraints. Once theserestrictions have been met, lines 32–34 check if the new assignment is animprovement over the prior. The result is saved if there has yet to be anupdate toCurrentMinor if the new value is smaller than the previous.IfCurrentMinhas a solution, then it is added to the Solutionmatrix at line 40. There is the possibility that following the loop there will be noavailable positions to place the mission. If this occurs, then lines 36 –37 attempt a reorganization toﬁnd a new valid permutation. These swapsare performed by Algorithm 2 and discussed below. The algorithmreturns an error if no reorganization is possible, no missions have beenassigned, or following reorganization the assignment fails.Lines 43–77 perform nearly the exact same process, with the excep-tion that there is no mission compatibility requirement. To validate thecorrect matrix to choose from, the algorithm includes a ﬂag called VehicleType(line 47). Each remaining check performs almost identicallyto the last section; however, theﬂag is used to ensure the correspondingdistance matrix matches the vehicle at each base.The addition of parallelism to this algorithm was simplistic, as raceconditions were only an issue for CurrentMin. CUDA operates through concurrent thread organization, so the loops at lines 7 and 44 couldinstead be replaced with their own threads. The continues are alsoreplaced as each thread controls its own base. This allowed the MinIndex to be checked simultaneously for each base. A mutex check was per-formed at line 32 to add toCurrentMinalong with the thread ID. At line 40, if the thread ID matched theCurrentMin, then it updated it with its solution. If there was currently no updated solution, a thread would beallocated to performing the swaps.J. Tassone, S. Choudhury Array 8 (2020) 100047
44.2. Neighbourhood searchﬂeet scheduling optimizationAlgorithm 2 accepts either the initialized or the partially completedata from Algorithm 1. The goal of the algorithm is to ﬁnd an organi- zation of missions and bases which minimizes the total travel time. Asalready discussed, the design of the previous algorithm was not to ﬁnd an optimal solution, only a valid one. Conversely, Algorithm 2 was formu-lated to be performed through multiple instances to minimize the totaltime to near optimal. Though the initialization method uses this algo-rithm, it only performs a single iteration to attempt a new result. Toensure that Algorithm 2 has a diverse set of possibilities, the loops at lines6 and 7 may be exchanged with random index permutation vectors.The algorithm functions by moving missions to new bases, essentiallyhaving another vehicle take responsibility for that mission. It will onlyend once no further improvement is found. If utilizing a set of permu-tation vectors, this means no better result is found in the current per-mutation and provides the opportunity for another iteration. A similar setof constraints from the previous algorithm are used and updates areperformed to theSolutionmatrix. There are four sets of loops with line 6allowing for looping through the bases and line 7 for looping through therespective missions assigned to a base. The loops at lines 9 and 17perform a similar function, though they are the corresponding positionsbeing move to.J. Tassone, S. Choudhury Array 8 (2020) 100047
5Like Algorithm 1, it includes aCurrentMinvariable for keeping track of the best current position for swapping. Once every valid combination is checked, theCurrentMinupdates theSolutionat line 43. Swapping within a base is restricted by lines 10–12, as the current order is already
Fig. 2.The movement of one mission to another base..(continued).J. Tassone, S. Choudhury Array 8 (2020) 100047
6constrained by the time. Additionally, certain planes cannot accepthelicopter-only missions as stated in lines 13 –15. There is aVehicleType ﬂag for determining which matrix to select from for the remainder of thealgorithm. This is based on the speciﬁc vehicle that is assigned.An example of the process can be seen in Fig. 2, where theﬁrst mission connected to base 1 is moved to base 2. Once a swap occurs base1 connects directly to mission 2, while the base 2 setup adds two newlinks between the new position of mission 1. During the movement, thenew position of the mission cannot force the vehicle ’sﬂight limit to be exceed, expressed by lines 18–20.Similarly, the new links must not exceed any of the time limits set bythe lines 21–36. This function is identical to the design of the previousalgorithm where the check depends on where the mission is being movedto. Again, a vehicle must wait until the current mission ’s time limit before proceeding, meaning each proceeding time limit must be considered inthe check. If the movement passes these requirements and is the currentbest option, then it is added toCurrentMinat line 38. Like the previous algorithm, this one can be made easily parallel bythe removal of the loop at line 9. This allows every base to be simulta-neously checked and for theCurrentMinto be updated with the best result quicker. The outer loop at line 6 could have instead been replaced,though this would have given a different value than the original, makingaccurate comparison difﬁcult. Either design can be run multiple timesand so long as an index ordering is done the solution may be improved.J. Tassone, S. Choudhury Array 8 (2020) 100047
74.3. Tabu searchﬂeet scheduling optimizationThis algorithm functions as a modiﬁcation of Algorithm 2, with a near identical design. The primary differences are the variables included atlines 5 and 6. TheTabuListprevents recently explored neighbourhoodsfrom being explored again. There is a chance that the algorithm maybecome locked into a local minimum, preventing optimum exploration ofthe space. Therefore, theTabuListhelps to prevent this, keeping certainregions restricted for several iterations based on the TabuCounter. During the iterative process if a region which has recently beenexplored is already in the list, then it is skipped as per lines 20 –27. The respective counter for each value is then reduced at the end of the currentiteration with line 56. Additionally, a value is added to TabuListonly if improves the value determined by lines 52 –55. If permutation vectors are used for the outter loops, then improvement may be discovered throughmultiple runs. In this case theTabuListvariable is maintained through proceeding iterations.The parallel implementation is identical to Algorithm 2. The innerloop at line 11 is replaced and continues are removed as each base re-ceives its own thread. Also like the previous, Algorithm 3 will result inthe exact same answer as the sequential variation. The updates are stillhandled by a single thread, which is determined by the best result inCurrentMin.J. Tassone, S. Choudhury Array 8 (2020) 100047
85. ResultsEight datasets were employed for testing the algorithms, all beingbased on known coordinates of air and health facilities. The Numba li-brary [17] was applied to speed up the programs through the JITcompiler. All programs, including Gurobi scripts, were tested with asystem containing 128 GBs of RAM with a 24 core Intel Core i9-7920XX-series processor. CUDA versions made use of a GeForce GTX 1080 Tigraphics card as well as the prior technologies mentioned.Each algorithm ran 10 times, with all results being summarized inFigs. 3 and 4andTables 2 and 3. A subset of each set of missions werechosen and divided from 12 to 33. 12 vehicles were used consisting of 8rotary-wing helicopters and 4ﬁxed-wing planes. The vehicle’s locations were locked to the bases and at the end of a set of missions each vehicleneeded to return to the same base. Time limits were randomly generatedfor each, needing to be completed within a 24-h period. This factor inaddition, to a 10-hﬂight limit, prevented sets from going over 33 mis-sions. While under the right circumstances it is possible for vehicles tocomplete beyond 33 missions in a day, it is highly unlikely and dif ﬁcult to generate a valid test scenario. Each method had a parallel and sequentialvariation, and both Algorithm 2 and 3 used Algorithm 1 for building astarting solution. For accurate comparison with the optimal, Gurobi wasemployed and tested upon the same data.Based on the values shown inFig. 3, the two optimization algorithms had similar results. All were consistently under 8% of the optimal, withsome becoming quite close for the higher mission sets. The Tabu searchdid perform better than the Neighbourhood search in a very comparabletime. The difference may not seem to be much based on the results inTable 3, though it should be noted that not a single case showed a betterresult for Neighbourhood search.Fig. 2does display that it is technically faster, though at these speeds this is a negligible difference. Despitesimilar values, the consistency in the results show that the Tabu search isa better option. Admittedly,Fig. 2does give the impression that upperand lower bounds are quite spread; however, the y-axis utilizes a verysmall incrementation. They are tight when further compared usingTable 3. Additionally, total travel time is being compared instead ofdistance. This means the summed values are much smaller, explainingwhy it is easier to get within a better percentage of the optimal.The Gurobi optimizer almost always managed to achieve an optimalsolution in a much slower time compared to the custom algorithms. Theproblem with scheduling is that it does not scale well, with larger mis-sions counts making the space exponentially more dif ﬁcult. While it was able to solve it in an acceptable time for missions below 24, anythingabove this became stuck. At points beyond 27 the gap between the upperand lower bounds stopped shrinking and the optimal was no longerimproving. The optimizer was set to stop running after 20,000 s which iswhyFig. 4shows the last three values as being the same. This problemshows the issue with Gurobi in a case where the optimal needs to bedetermined quickly, as there is not a guarantee it will ﬁnd it. This is not an unusal case in a disaster where timing can mean the difference be-tween life and death. In this scenario these custom algorithms may bemore reasonable, since in the case of 33 missions the Tabu search ach-ieved a better lower bound than the value Gurobi had solved at that pointin time. While in some cases it may be more useful to utilize the optimizerfor a smaller count, the difﬁculty of this problem and the fact that thecustom algorithms have a much faster runtime, does at least offer someadvantages to alternatives.Base on the results in bothFig. 4andTable 2, the CUDA variations does not offer a better option at this scale. Both sequential versions aresigniﬁcantly faster in all cases. The problem with CUDA at this level isthat the kernel call itself takes a lot of time to perform. It is possible tobundle everything into a single call, though it still will not be as fast as theother algorithms with these mission sizes. The CUDA implementation isabout the same for both algorithms and still signi ﬁcantly faster than Gurobi. It is possible that at a higher mission count the parallel imple-mentation may begin to outperform the sequential algorithms. Although,
as previously mentioned it is unlikely to have more than 33 missions in aday for this set of data, meaning the only option would be if it was forscheduling a much longer period. In any case, while not an unreasonable
Table 2Summary of total missions times.
Number of Missions Gurobi Runtime Neighbourhood Search Runtime Parallel Neighbourhood Search Runtime Tabu Search Runtime Parallel Tabu Search Run time12 1226 0.0153 0.548 0.0245 0.57815 2045 0.0244 0.532 0.0349 0.61518 2815 0.0322 0.544 0.0424 0.57521 5486 0.0446 0.519 0.0553 0.50724 9546 0.0499 0.611 0.0618 0.64227 N/A 0.0565 0.618 0.0675 0.56130 N/A 0.0581 0.599 0.0682 0.64533 N/A 0.0631 0.686 0.0689 0.611Fig. 3.Comparison of scheduling algorithms against the optimized solution.
Fig. 4.Comparison of scheduling runtimes.J. Tassone, S. Choudhury Array 8 (2020) 100047
9result, at this scale the sequential Tabu search is still the best option.6. ConclusionThe results demonstrate the convenience of these custom algorithmicsolutions. In all cases, Gurobi achieved an optimal in an increased time.Though not the universal, this is not acceptable in a disaster situationwhere time is not a luxury andﬂeet reorganization is required. In thesescenarios, algorithms approaching the optimal become more valuable.Both algorithms were quite close to the Gurobi solution, though the Tabuslightly outperformed in all cases. In the latter simulations the Tabu evenoutperformed the Gurobi which could not calculate an effective permu-tation before the time termination expired. While parallel optimizationmay be an option in a larger scheduling scenario, it was not animprovement in this case. The kernel call resulted in a bottleneck whichhindered any speedup gain. This should not eliminate the possibility ofusing this technique, though the situation should be considered. Overall,these algorithms can achieve acceptable results in an excellent time. Theyare adaptable to quick changes and can be run for multiple instances,displaying the effectiveness of this for the domain.Credit author statementJoseph Tassone: Conceptualization, Software, Methodology, Writing -Original Draft. Salimur Choudhury: Validation, Writing - Review & Editing, Funding acquisition, Supervision, Resources.Declaration of competing interestThe authors declare that they have no known competing ﬁnancial interests or personal relationships that could have appeared to in ﬂuence the work reported in this paper.AcknowledgementsThis research is supported by the respective NSERC Discovery Grantsfrom Dr.Salimur Choudhury. Additionally, the work was funded by a VectorInstitute Scholarships in AI from Joseph Tassone. Lastly, funding was alsoprovided by a NSERC CGSM award through Joseph Tassone.References[1] Ornge. Online,https://www.ornge.ca/home. [Accessed 10 November 2019]. [2]Tassone J, Pond G, Choudhury S. Algorithms for optimize. ﬂeet staging of air ambulances, Array 2020;7:100031. http://www.sciencedirect.com/science/article/pii/S2590005620300163ing. [3]Carnes TA, Henderson SG, Shmoys DB, Ahghari M, MacDonald RD. Mathematicalprogramming guides air-ambulance routing at ornge. Interfaces 2013;43(3):232 –9. [4]Da/C21glayan H, Karakaya M. An optimized ambulance dispatching solution forrescuing injures after disaster. Univ J Eng Sci 2016;4(3):50 –7. [5] Edelkamp S, Schr€odl S. Chapter 14 - selective search. In: Edelkamp S, Schr €odl S, editors. Heuristic search. San Francisco: Morgan Kaufmann; 2012. p. 633 –69. https://doi.org/10.1016/B978-0-12-372512-7.00014-6 . [6] M. Oberscheider, P. Hirsch, Analysis of the impact of different service levels on theworkload of an ambulance service provider, BMC Health Serv Res 16:487. doi:10.1186/s12913-016-1727-5.[7] Repoussis PP, Paraskevopoulos DC, Vazacopoulos A, Hupert N. Optimizingemergency preparedness and resource utilization in mass-casualty incidents. Eur JOper Res 2016;255(2):531–44.https://doi.org/10.1016/j.ejor.2016.05.047 . [8] Lee D, Dinov I, Dong B, Gutman B, Yanovsky I, Toga AW. Cuda optimizationstrategies for compute- and memory-bound neuroimaging algorithms. ComputMethods Progr Biomed 2012;106(3):175 –87.https://doi.org/10.1016/ j.cmpb.2010.10.013.[9] Cuda toolkit documentation v10.2.89. Nov 2019. https://docs.nvidia.com/cuda/ . [10] Schulz C, Hasle G, Brodtkorb AR, Hagen TR. Gpu computing in discreteoptimization. part ii: survey focused on routing problems. EURO J Transp Logist2013;2(1):159–86.https://doi.org/10.1007/s13676-013-0026-0 . [11] Hussain MM, Hattori H, Fujimoto N. A cuda implementation of the standard particleswarm optimization. In: 2016 18th international symposium on symbolic andnumeric algorithms for scientiﬁc computing (SYNASC); 2016. p. 219 –26.https:// doi.org/10.1109/SYNASC.2016.043 . [12] Fabris F, Krohling RA. A co-evolutionary differential evolution algorithm for solvingmin–max optimization problems implemented on gpu using ccuda. Expert Syst Appl2012;39(12):10324–33.https://doi.org/10.1016/j.eswa.2011.10.015 . [13] Desrochers M, Laporte G. Improvements and extensions to the miller-tucker-zemlinsubtour elimination constraints. Oper Res Lett 1991;10(1):27 –36.https://doi.org/ 10.1016/0167-6377(91)90083-2 . [14] The world’s best turboprop better than ever: pilatus reveals the pc-12 ngx, PilatusAircraft Ltd.[15] Aw139.https://www.leonardocompany.com/en/products/aw139 . [16] Ramos TRP, Gomes MI, P /C19ovoa APB. Multi-depot vehicle routing problem: acomparative study of alternative formulations. Int J Logist Res Appl 2019:1 –18.
https://doi.org/10.1080/13675567.2019.1630374 . 0 (0). [17] A high performance python compiler. http://numba.pydata.org/; 2018.Table 3Summary of total runtimes.
Number of Missions Optimal Distance Neighbourhood Search Tabu Search12 23.521 U: 25.495 L: 24.903A: 25.199U: 25.374L: 24.640A: 25.007 15 24.348 U: 25.771 L: 25.119A: 25.445U: 25.623L: 24.858A: 25.240 18 34.027 U: 36.834 L: 35.526A: 36.008U: 36.138L: 34.984A: 35.611 21 46.853 U: 49.801 L: 48.029A: 48.915U: 49.047L: 47.380A: 48.214 24 59.977 U: 62.365 L: 61.924A: 62.144U: 61.793L: 60.434A: 61.164 27 57.841 U: 62.393 L: 58.950A: 60.672U: 61.310L: 58.859A: 59.934 30 60.428 U: 63.904 L: 61.226A: 62.565U: 62.379L: 60.532A: 61.456 33 66.564 U: 68.221 L: 66.956A: 67.868U: 67.947L: 66.425A: 67.638J. Tassone, S. Choudhury Array 8 (2020) 100047
10