Design of a 4 DOF parallel robot arm and the ﬁrmware implementation
on embedded system to transplant pot seedlings
Rahul K., Hifjur Raheman ⁎, Vikas Paradkar
Agricultural & Food Engineering Department, Indian Institute of Technology Kharagpur, India
a b s t r a c t
a r t i c l e
i n f o
Article history:
Received 17 July 2020
Received in revised form 14 September 2020
Accepted 14 September 2020
Available online 21 September 2020
Keywords:
Robot ﬁrmware
Parallel robot arm
Automation
SoC microcontrollers, pot seedlings
This paper presents a ﬁrmware design and its implementation on a real time embedded system for driving a 4
DOF parallel robot arm. The ﬁrmware primarily comprised of two components to produce motion of the robot
arm: a) generation of continuous position coordinates and b) generation of actuating signals. These two compo-
nents were processed in two different microcontrollers with a common communication bus. The position gener-
ation algorithm produced and transmitted continuous position data to the motion generation algorithm in the
form of G-code strings by reading the input positions which were previously stored by the user in EEPROM mem-
ory of the microcontroller. The receipt of a handshake signal synchronized the data transmission between these
components through a communication bus. An LCD display and keypad were used as human-machine interface
(HMI) to communicate with the user to set the robot target coordinates. The mechanical structure of the robot
arm comprised of multiple links which were actuated by stepper motors. The workspace boundary were sensed
by limit switches. The kinematic equations represented the gripper position for the corresponding input joint an-
gles. A microcontroller was used to compute kinematic equations of the robot arm with the help of motion gen-
eration algorithm to generate actuation signals for the simultaneous movement of robot joints. The kinematic
equations were solved with the dual-core capability of the microcontroller using real time operating system
(RTOS), which made the computation faster with an average computation time of 198 μs per step. The developed
ﬁrmware was implemented and tested on a 4 DOF parallel manipulator using embedded microcontrollers for
continuous pickup and place of the paper pot seedlings for automating the metering of pot seedlings. The cycle
time taken for pickup and dropping of each seedling was 3.5 s with a success rate of 93.3%.
© 2020 The Authors. Publishing services by Elsevier B.V. on behalf of KeAi Communications Co. Ltd. This is an open
access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).
1. Introduction
A robotic system generally consists of a motion generating mechan-
ical hardware module, an electronic control module, a software module
that run a decision support system to drive the electromechanical actu-
ators and a communication protocol for data transfer within and outside
the system (Angeles, 1997). The electronic module would consist of em-
bedded microcontrollers, PLC's, or other advanced hardware such as
FPGA's to generate the actuating signals. These signals are then received
by the motor drivers to supply driving power to the actuators. Power
regulators are used to provide different operating power levels for
each component according to its working range. Also, multiple sensors
are used to monitor the environment (Joseph Raj et al., 2019) and the
robot operating parameters (position measuring devices such as en-
coders, limit switches and potentiometers) (Chen et al., 2018). The elec-
tromechanical actuators such as stepper and servo motors provide
driving torque to the robot joints through power transmission mecha-
nisms like gears, timing belts and pulleys with minimal backlash. The
robot ﬁrmware implemented on PC or embedded microcontroller
plays a crucial role in developing the necessary actuation signals by
making decisions through task allocation, algorithm computation and
data transmission. Among the various modules of the robotic system,
the ﬁrmware implemented on the embedded microcontroller decides
the control and action of each module to perform the predeﬁned
tasks. The typical function of a robot ﬁrmware is shown in Fig. 1.
The ﬁrmware can fetch and modify data from storage memory to per-
form the tasks according to the instructions provided by the user. It drives
the actuators by reading the sensors connected with the robotic system. It
decides to channel the data transfer either internally or externally to read,
write or display data through the required data bus.
1.1. Literature review
Robot operating system (ROS) is an open-source ﬁrmware architec-
ture, mainly designed for the development of robotic tools. It consists of
several libraries which are capable of performing complex tasks such as
navigation robots, multiple robot coordination assisted with machine
vision and sensor integration. Araujo et al. (2015) developed a mobile
robot platform using an Arduino board controlled by ROS. The control
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
⁎ Corresponding author.
E-mail address: hifjur@agfe.iitkgp.ac.in (H. Raheman).
https://doi.org/10.1016/j.aiia.2020.09.003
2589-7217/© 2020 The Authors. Publishing services by Elsevier B.V. on behalf of KeAi Communications Co. Ltd. This is an open access article under the CC BY license (http://
creativecommons.org/licenses/by/4.0/).
Contents lists available at ScienceDirect
Artiﬁcial Intelligence in Agriculture
journal homepage: http://www.keaipublishing.com/en/journals/artificial-
intelligence-in-agriculture/
logic was developed in a PC and the command signals were sent to
Arduino through a USB communication. This robot was built for educa-
tional purposes to demonstrate swarm robotics, multi-robot surveil-
lance and rescue tasks. The robot used an onboard camera to navigate
and send the environment data wirelessly. Kamel et al. (2017) devel-
oped a model in ROS for trajectory tracking technique for unmanned ae-
rial vehicles (UAV). Though ROS ﬁrmware architecture is designed for
solving complicated robotic operations, advanced hardware with high
computation power is required to deploy the code blocks developed
in ROS ﬁrmware. Therefore, still there is a requirement for a simple
and efﬁcient ﬁrmware structure that could be implemented on a com-
mercially available system on chip (SoC) microcontrollers.
The most notable open-source ﬁrmware available for driving a ro-
botic system using SoC is ‘Marlin’ ﬁrmware (Wijnen et al., 2016;
Kruger et al., 2018). Marlin is an open-source software constructed
using C++ language, dedicatedly developed for operating 3D printers
using embedded microcontrollers. Some typical functions of Marlin
ﬁrmware are: a) positioning the printing nozzle in x, y and z coordinates
according to the commanded locations by a slicing software, b) driving
the extruder for continuous feeding of the printing ﬁlament, c) heating
the ﬁlament and printing bed by PID control with the feedback of tem-
perature sensors. Marlin takes the input of NC (G-codes and M-codes)
codes (Arroyo et al., 2004) to operate the 3D printer, which produces
real 3D components by melting an input ﬁlament at high temperature
through an extruder. A list of essential G-codes for positioning the print-
ing nozzle of a 3D printer is given in Table 1.
Tiansong et al. (2019) developed a 3D printed 3 DOF serial robot
using open source Marlin ﬁrmware controlled by ATMEGA 1284P mi-
crocontroller. The robot was actuated by geometric codes generated
by Pronterface software installed on a desktop personal computer
(Surange and Gharat, 2016). Nejatimoharrami et al. (2017) developed
a liquid handling robot equipped with machine vision for automating
chemical handling. It is a gantry type robot controlled by Marlin ﬁrm-
ware installed on an Arduino Mega microcontroller board. Although
Marlin architecture could be modiﬁed for operating a robotic system
using commercial microcontrollers, it has several drawbacks such as:
Marlin software requires an additional system to input the positional
coordinates. Generally, the robots run by Marlin ﬁrmware uses an exter-
nal PC to generate the positional G-code strings. Also, the amount of
memory requirement of Marlin ﬁrmware is high because of additional
modules written for the functioning of 3D printer components. The op-
eration speed cannot be improved signiﬁcantly due to its core design
(3D printers does not require high operation speed) and it requires an
external code generation module to direct the actuators.
Many a researchers have been using Marlin ﬁrmware to develop a ro-
botic system to perform several useful tasks. This external software sup-
plies the necessary codes to manipulate the robotic system. It creates
difﬁculty in operating the robotic system in a hostile environment and
with space constraints. This paper presents a ﬁrmware architecture and
implementation algorithms to run a 4 DOF parallel robot, which could
be deployed in an embedded system that comprised of SoC
microcontrollers, HMI and electronic components which eliminated the
need of an external PC to generate the positional coordinates. To imple-
ment and validate the developed ﬁrmware, it was implemented on a
real time embedded hardware, a robot arm based vegetable transplanter
was selected to meter the seedlings of vegetables raised in paper pots.
1.2. Automation of vegetable transplantation
Vegetable transplanters are used in agriculture to simplify the man-
ual process of planting already grown seedlings in agricultural ﬁeld to
improve the yield and reduce drudgery of the human labor (Kumar
and Raheman, 2011; Dihingia et al., 2018). Pot seedling transplanters
generally consist of a seedlings pickup mechanism (extracts seedlings
from a feeding conveyor and place it into a drop tube one by one), con-
veying unit (to continuously transfer seedlings towards the pickup unit)
and a soil opening-closing unit. Researchers have been working on au-
tomating this mechanical transplanting process by including robots as
a picking mechanism to improve its efﬁciency and to reduce the input
power requirement (Hwang and Sistler, 1986; Hu et al., 2014; Rahul
et al., 2019). The robot used in these transplanters picked up seedlings
one by one from multiple numbers of ﬁxed pickup locations and
dropped it into a ﬁxed dropping point (Fig. 2).
To maintain a delicate picking without damaging the seedlings and
to drop the picked seedlings without collisions with other components
Table 1
List of essential G-codes for the nozzle spatial manipulation of 3D printer.
Code
Function
G00 X Y Z
Rapid linear movement
G01 X Y Z
Linear motion of nozzle at a speciﬁed speed
G28
Homing of X, Y and Z coordinates
G02 and G03
CW and CCW arc at a speciﬁed radius
Nomenclature
θa
Active arm joint angle
θp
Passive arm joint angle
θtr
Transmission angle
α
Passive arm angle with respect to active-passive joint
orientation
β
Active arm linear angle with horizontal
γ
Inner angle of active arm
C(x,y)
End effector position in Cartesian plane
COM bus Communication bus
EEPROM Electrically Erasable Programmable Read Only Memory
HMI
Human Machine Interface
k and s
Linear distance between origin of active arms and end
effector position
L1
Length of active arm
L2
Length of passive arm
LCD
Liquid crystal display
m
Horizontal distance between the active-passive joints
Mdep
Elbow position memory address for dropping position
Mdp
Dropping point memory address
Mpep
Elbow position memory address for pickup point
Mpp
Memory address of pickup position value
n
Vertical distance between the active passive joints
O
Origin of the robot axis
PGF
Position Generation Firmware
SGF
Signal Generation ﬁrmware
Fig. 1. Functions of a robot ﬁrmware.
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
173
of the transplanter, the manipulator needs to move from dropping point
(initial coordinates) to each of the pickup locations through a via point.
After picking, the manipulator again reaches the drop point through the
same via point. The via point is known as the approach point for each
pickup location. A systematic motion requirement of a robot for seed-
ling handling was reported by Rahul et al. (2019). The optimal robotic
path requires an approach point, gripping point and a dropping point.
The operational speed of picking should be lesser than the speed of ap-
proach and dropping. This entire problem for the robotic task is consid-
ered as a pick and place application with multiple ﬁxed pickup positions
and one drop point at variable operating speed. Hence, the hardware
and software embedded control system for the robot in an automated
transplanter requires the following features:
1) A user interface system to modify the robot motion coordinates and
its parameters without the aid of an external computer
2) A fault diagnosis system to detect the status of sensors and actuators
whenever required
3) Display of the operating parameters (i.e., number of droppings and
execution code received) through HMI
In this study, a robot control ﬁrmware was constructed and de-
ployed on a real time embedded system to control a 4 DOF parallel ma-
nipulator robotic system used for continuous pick and place operations
of paper pot seedlings in an agricultural ﬁeld. The details of its develop-
ments and its laboratory evaluation are given in the following sections.
2. Materials and methods
2.1. Firmware architecture of the robotic system
The proposed ﬁrmware architecture of the robot system is shown in
Fig. 3. It consisted of two components: 1) signal generation ﬁrmware
(SGF) and 2) position generation ﬁrmware (PGF).
A user interactive HMI was used to store or modify the data for pick
and place task such as the number of positions, approach point, pickup
point and dropping point in the EEPROM memory at their speciﬁed mem-
ory addresses. Also, an external communication bus was used to monitor
and control the robotic system by a remote computer. During the pick and
place operation, PGF read the position data (X, Y, Z location) from
EEPROM memory and compiled it into a G-code string (Ex. G01 X d1,
Yd2, Zd3; where dk is the kth position data). The generated G-code was
then sent to the SGF and waited for the handshake signal to indicate the
completion of the assigned task. The SGF read the input string and
interpreted the X, Y and Z position coordinates. The coordinates were
used to compute the trajectory points by Bresenham 3D line algorithm.
For each trajectory point, the algorithm calculated the inverse kinematics
of the robotic system (in this case, a planar parallel robot was selected) to
compute the joint angular positions at that instance. The required joint
motor actuation signals were generated and supplied to follow the
Fig. 3. Generalized ﬁrmware architecture of the robotic system.
Fig. 2. Robot pickup and drop positions with a via point trajectory.
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
174
trajectory at the speciﬁed linear speed of the manipulator. Further, accel-
eration at the beginning and deceleration at the end of the trajectory were
provided to maintain smooth actuation. Once, the manipulator reached
the target position, SGF sent a handshake signal to the PGF through serial
bus to continue the cycle for the next position.
2.2. Design of robot arm
The validation of the proposed ﬁrmware architecture for operating a
robotic system was made by a) designing the mechanical structure of
the robot arm, b) deriving the kinematic equations of the robot arm,
c) designing the embedded hardware to actuate the mechanical system
and d) implementing the ﬁrmware in a deployable SoC microcontroller
of the hardware. The following sections explain the practical implemen-
tation of the proposed ﬁrmware architecture.
2.2.1. Design of mechanical structure of robot arm
The 3D CAD model of a 4 DOF parallel robot arm is presented in
Fig. 4. It consisted of two active links those were driven by stepper mo-
tors through timing belt and pulley. One end of the two passive links
was joined together and the other ends were connected with the corre-
sponding active links. Thus the combined motion of the active joints
provided a planner manipulation in X and Y direction.
The arm assembly platform, which comprised the robot links and ac-
tuation stepper motors was mounted on the support frames through a
slider with a linear bearing that permitted motion only in ‘Z’ direction. An-
other stepper motor mounted on top of the frame drove a lead screw
coupled with the platform. Thus, the rotation of the stepper motor was
converted into a linear motion in Z direction. A parallel jaw gripper was
attached to the robot arm at the connecting point of the two passive links.
The gripper was made to open and close using a servo motor. An-
other servo motor mounted on the passive link was attached to the grip-
per to provide the rotary motion of the gripper in planner coordinates.
Four limit switches were provided at the robot arm frames to act as
sensing boundary of the robot arm. Two limit switches (limit switches
1 and 2) sensed the boundary position of the active robot joints. The
limit switches 3 and 4 detected the upper and lower boundary positions
of the platform, in Z-up and Z-down directions, respectively.
2.2.2. Inverse kinematics of the robot arm
The input joint angles θa1 and θa2 for the given gripper position were
computed with inverse kinematics. The geometric line diagram of the
parallel manipulator is shown in Fig. 5 with three operating regions to
visualize easily and to develop the implementable robot equations.
The regions are separated based on the position of the end effector,
i.e., C(x, y) in the planar space.
Using cosine rule in triangle O1AC (referring Fig. 5), the inner angle
of active arm 1.
γ1 ¼ acos L1
2−L2
2 þ k2
2 L1 k
 
!
where, k ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
ðx þ L0
Þ2 þ y2
q
ð1Þ
Similarly, using cosine rule at triangle O2DC, the inner angle of active
arm 2
Fig. 4. CAD model of the developed robot arm to implement the proposed ﬁrmware.
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
175
γ2 ¼ acos L1
2−L2
2 þ s2
2 L1 s
 
!
where, s ¼
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
ðx−L0
Þ2 þ y2
q
ð2Þ
Based on the location of the manipulator point ‘C’ within the region,
the active arm linear angle with horizontal (β1 and β2) varies as:
β1 ¼ atan
y
jL0 þ x
j
�
�
and β2
¼ atan
y
jL0−x
j
�
�
for the location of‘C’in region−2
ð3Þ
β1 ¼ atan
y
jL0 þ x
j
�
�
and β2
¼ π−atan
y
jL0−x
j
�
�
for the location of‘C’in region−1
ð4Þ
β1 ¼ π−atan
y
jL0 þ x
j
�
�
and β2
¼ π−atan
y
jL0−x
j
�
�
for the location of‘C’in region−3
ð5Þ
Fig. 5. Geometric line diagram of the manipulator with its operating regions.
Fig. 6. Block diagram of the electronic control circuit of the robot arm.
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
176
The active joint angles (θa1 and θa1) are determined by
θa1 ¼ β1 þ γ1
ð6Þ
θa2 ¼ β2−γ2
ð7Þ
The transmission angle inﬂuences the manipulator stability θtr be-
tween active and passive links and is directly proportional to the dis-
tance between points B and C; which is determined by using the
following equations.
The vertical distance of link, L1y ¼ L1 sin θa1
ð8Þ
The vertical distance of link, L2y ¼ L2 sin θa2
ð9Þ
Length between points B and C, LBC
¼ min L1y, L2y
�
�
þ abs L1y, L2y
�
�
2
ð10Þ
2.3. Design of embedded hardware for the robot arm
The electronic system incorporates the necessary hardware compo-
nents to realize the robot arm motion. The block diagram of electronic
components used and their associated connections are shown in
Fig. 6. The list of hardware components used with their speciﬁcations
and functions are summarized in Table 2.
The SGF ﬁrmware deployed on dual-core ESP 32 microcontroller actu-
ated the stepper motors of robot joint by supplying the essential signals to
the corresponding motor drivers. It calculated both robot kinematic and
trajectory equations. Limit switches were also connected to the ESP 32,
to sense the robot joints whenever it reached the robot boundary. The
PGF ﬁrmware installed on the Arduino Mega board took input from the
HMI keypad and displayed the necessary data through an LCD. The
Mega board also controlled the gripper open/close and wrist rotation of
the robot arm. A COM bus connected these two microcontrollers, trans-
ferred data between them. Buck converters provided the required DC
voltage to these electronic components for their operation and actuation.
2.4. Robot path planning
Robot path planning involves the generation of optimal reachable
points in spatial coordinates from the present position of the manipulator
to the target location. Command G00 (rapid motion) and G01 (motion of
Table 2
List of components used in electronic hardware.
Component
Speciﬁcations
Functions
ESP 32
Clock frequency: 240 MHz
CPU: 2 cores (32 bit),
Tensilica LX6
microprocessors
Memory: 520 Kib SRAM
Peripheral interfaces: 3
UART, 2 I2C
SGF ﬁrmware installed to drive the
robot joint actuators
Arduino
Mega
Clock frequency: 16 MHz
CPU: 8 bit ATMEGA 2560
Memory: 8Kb SRAM
Peripheral interfaces: 4
UART, 1 I2C
PGF ﬁrmware installed to generate and
supply the motion control codes
Buck
converter
Input: 36 V DC (max),
current: 5A (max)
Output: 5 V and 12 V
To supply recommended constant DC
power to actuators and
microcontrollers
HMI
Keypad
LCD
To receive input from the user and to
display the operating parameters
Actuators
NEMA 17 Stepper motors
and
Servo motors (up to 180°
rotation)
To provide driving torque to the robot
joints
Fig. 7. Flow diagram of robot kinematics computation through dual-core.
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
177
manipulator at speciﬁed speed) were used to move the end effector be-
tween the speciﬁed coordinates (X, Y and Z) with a straight-line trajectory
using Bresenham algorithm.
2.5. Computation of kinematic equations through dual-core
The robot kinematics involves the computation of complex geo-
metric equations to determine the angular positions and velocities
of the joints at minimal time. As discussed in the earlier section,
higher the resolution, better is the straight-line approximation, but
at the cost of increased computation. Hence, the processor needs to
calculate the kinematic equations at a higher speed to supply the ac-
tuation signals to the corresponding stepper motors. By utilizing the
advantage of dual-core computing capability of ESP 32 microcontrol-
ler, the complex algorithms were solved at a minimal time. Since all
the kinematic equations were required to be solved only by the SoC
microcontroller, the equations were divided into two parts, each
was computed individually in different cores and the results were
Fig. 8. User interactive menu sequence to store data in EEPROM memory.
Fig. 9. EEPROM memory stack and allocation of data in its associated storage locations.
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
178
combined to obtain the target angular position. The algorithm for en-
abling dual-core computation is given in Algorithm 1 and the block
diagram of dual-core computation is shown in Fig. 7. ESP32 was sup-
ported with RTOS (Real Time Operating System); thus multiple tasks
were created and ran those tasks simultaneously in different CPU
cores. Two sets of kinematic equations ran independently in cores
1 and 2 by using ‘Semaphore’ (give or take) function by deﬁning
global variables that shared common data between both the cores.
Finally, the computed data from both the cores were collected and
the target angular positions θa1 and θa2 were calculated.
Algorithm 1. Dual-core computation of kinematic equations.
2.6. Construction of position generation ﬁrmware
The position generation ﬁrmware produced the robot control codes
(G-codes) required for the actuation of the robot arm to perform a partic-
ular task (i.e., in this case, continuous pick and place application of pot
seedlings was considered). The generated signals were sent through the
internal serial communication bus (COM bus) of the robot controller
upon the receipt of handshake signals from the receiver. In order to pro-
duce the continuous control codes which perform pick and place task,
the controller was required to access the position data. Considering the
case of pick and place application as explained in the Introduction section,
the user could provide all the required position data at once which would
be stored in EEPROM memory. Then the controller could access the data
at any time repeatedly without consideration of power supply ON/OFF
criteria. Besides, provision was also made to change speciﬁc data in the
memory according to the user's requirement.
The position data storage for the robot actuation was made
through a user interactive menu-based system as shown in Fig. 8.
Navigation buttons of the keypad were used to change the menu se-
quence to access a particular address of the EEPROM memory
(Fig. 9). The number of pickup positions value was stored in memory
address Mpp by navigating the corresponding menu and by entering
a numeric entity. The dropping position data were stored in the
memory by directing to ‘End effector position’ in dropping position
menu. With the help of a keypad, the end effector could be moved
to the desired position and the corresponding coordinates (X and
Y) could be fetched from the SGF through COM bus to store the
dropping point data in memory address Mdp. Elbow position for the
dropping coordinate were stored in address Mdep. In this particular
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
179
application, there were multiple numbers of pickup points; which
required multiple end-effector coordinates and elbow positions.
These data were accessed and modiﬁed by the user by entering the
pickup position number ‘k’ in menu sequence which could access
the memory locations Mpdx(k), Mpdy(k) and Mpep(k) and these par-
ticular data were stored in the speciﬁc memory address.
Algorithm 2. Continuous pick and place operation.
The procedural steps for the continuous pick and place operation are
provided in Algorithm 2. It initialized the required variables and the
data for pick and place were fetched from the EEPROM memory
(Fig. 9). It generated the G code string required for the robot motion
for approach coordinates and transmitted the string to the SGF which
actuated the elbow and gripper. After the receipt of acknowledgement
signal from SGF, the algorithm generated strings for gripping and drop
coordinates for the pick and place of the present position. It
incremented the position data and actuated the robot until it was
equal to Mpp. The position data was again reset back to pick and place
from the initial point.
3. Results and discussion
3.1. Data entry through HMI
The HMI system was connected to the PGF microcontroller to display
data and to provide input to the SGF microcontroller for the actuation of
the robot arm. The developed HMI control for the robotic system, which
comprises an LCD display and Keypad is shown in Fig. 10. The buttons of
the keypad were conﬁgured for multiple functions (up, down, left, right,
select, back and numerical entries) to access the data.
The entry of position data in EEPROM memory of the PGF microcon-
troller is shown in Fig. 11. By navigating the menu system through the
up/down and select buttons user could obtain ‘Enter value’ tab in the
display (Fig. 11.a). User could change the number of pickup positions
by the buttons (Fig. 11.b). Then by pressing the select button, the en-
tered data were saved in the corresponding EEPROM memory location
of the microcontroller (Fig. 11.c). This updated data were used by the
PGF for the next operation cycle.
The data entry for the dropping position in the corresponding mem-
ory address of the EEPROM is shown in Fig. 12.
3.2. Operation of robot arm by the proposed ﬁrmware implemented on the
embedded microcontrollers
The developed ﬁrmware (both SGF and PGF) were deployed in SoC
microcontrollers of the embedded hardware and it was implemented
on a 4 DOF parallel robot (Fig. 13).
It consisted of ﬁve pickup positions and one dropping position. The
algorithm was tested for continuous pick and drop of pot seedlings
loaded on a feeding conveyor. Forty numbers of pot seedlings were
picked and dropped by rotating the feeding conveyor to supply pot
seedlings to the pickup positions. The average computation time (for
20 pickup positions i.e., four row of pot seedlings) required to solve
the kinematic equations were recorded. Function ‘micros ( )’ was used
in the kinematics code block within the SoC microcontrollers of three
different modes and the data were recorded. Table 3 presents the com-
parison of the average computation time to solve the computation of in-
verse kinematic equation in different modes.
It was found that, ESP 32 SoC microcontroller computed the kine-
matics at less time as compared to the utilization of widely used
Arduino board. Further, usage of dual-core capability through RTOS im-
proved the computation speed, which increased the operating speed.
3.3. Performance evaluation of the developed ﬁrmware implemented on the
hardware to pick and drop the pot seedlings
The robot arm was tested for seedling pickup and dropping. A total
of 40 pot seedlings were loaded on the cells of the feeding conveyor
for testing. The sequence of operation for picking and dropping of seed-
lings by the robotic arm is shown in Fig. 14(a–d).
The cycle time taken for pickup and dropping of each seedling was
3.5 s (which maintained delicate picking and dropping of pot seedlings
without any damage at an average of 17 seedlings per min which is
sufﬁcient for walk behind type vegetable transplanters, Kumar and
Raheman,
2011).
The
average
success
rate
(S ¼ Number of successfully picked seedlings
Totalnumberofseedlingsloaded
� 100Þ of the robot arm deployed
with the proposed ﬁrmware for three trials was computed as 93.3%.
3.4. Comparison of the proposed ﬁrmware and the associated hardware
with existing systems
It is required to compare the developed ﬁrmware and the hardware
on which the ﬁrmware was deployed. Table 4 presents the comparison
of various features of the developed ﬁrmware and the associated hard-
ware with the existing systems.
The SMC4-4-16A 16B CNC motion controller has built in ﬁrmware
and already well established in several industrial NC machines. In cost
wise this controller is not suitable for operating with agricultural ma-
chines. Compared to Raspberry pi based ROS system, the developed
ﬁrmware with its associated hardware is much lower in cost. Also, the
performance of the developed system proved that it is well suited for
metering pot seedling for transplanting.
4. Conclusions and future work
In this paper, design of a 4 DOF parallel robot arm, the development
of control ﬁrmware and the implementation of the developed ﬁrmware
on embedded system to handle paper pot seedlings for vegetable trans-
plantation were studied. A general design of a robot ﬁrmware was pro-
posed to produce control codes (G-codes) based on the predeﬁned user
input and motor actuation signals obtained for the internal commands
received, and by sensing the joint angular positions. An embedded elec-
tronic hardware was developed and deployed the proposed ﬁrmware to
generate control codes and actuation signals using SoC microcontrollers
(tested using ESP 32, Arduino Mega microcontrollers, LCD-Keypad HMI,
limit switch position sensors and the required power converters). 3D
Bresenham algorithm was used in the ﬁrmware to approximate the lin-
ear trajectory of the parallel robot in between initial and target
positions.
Region-based inverse kinematic equations were developed and im-
plemented in the robot ﬁrmware, coupled with the Bresenham line al-
gorithm to realize the linear trajectory of the robot in real time. The
Fig. 10. HMI system for the robot arm.
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
180
a) Navigate to positions
b) Numerical entry
c) Saving the data
Fig. 11. Modifying position data in memory through HMI.
a) Navigate to drop menu   b) Motor positions selection    c) Move the robot joint
Fig. 12. Setting of motor positions for drop point in memory through HMI.
Fig. 13. Robot arm actuated by the proposed ﬁrmware for pick and drop of pot seedlings.
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
181
kinematic equations were computed at a lesser time using the dual-core
capability of the ESP 32 microcontroller, which resulted in an average
computation time of 198 μs per step as compared to 276 μs and
4027 μs with single-core mode and other commercial microcontrollers.
A user interactive menu sequence was developed to store the position
data related to pick and drop in the EEPROM memory using HMI. The
developed ﬁrmware was successfully implemented on an embedded
hardware to pick and drop of pot seedlings loaded on a feeding con-
veyor using a parallel robot arm with an average cycle time of 3.5 s
with a success rate of 93.3%.
Declaration of competing interest
The authors declare that they have no known competing ﬁnancial
interests or personal relationships that could have appeared to inﬂu-
ence the work reported in this paper.
References
Angeles, J., 1997. Fundamentals of Robotic Mechanical Systems: Theory, Methods, and Al-
gorithms. 2nd edition. Springer-Verlag, New York.
Table 3
Time taken to solve the kinematic equation with different microcontrollers.
Device used
Average computation time per step (μs)
(For 20 different positions)
Arduino Mega
4027
ESP 32 (without dual-core)
276
ESP 32 (dual core enabled)
198
a) Manipulator approaching a seedling
b) Manipulator picked the seedling
c) Transferred the seedling to drop point
d) Released the seedling inside the 
seedling delivery tube
Fig. 14. Pick and drop of a pot seedling with robot arm under laboratory conditions.
Table 4
Comparison of developed ﬁrmware and its associated hardware with existing systems.
Robot control ﬁrmware with hardware
Cost (approx.)
Number of controllable axis
Applicability
Proposed system (Microcontrollers with HMI)
Rs. 1800
Up to 5 axis
Robotic applications
Raspberry pi with ROS and HMI
Rs. 4000
Up to 6 axis
Robotic applications
SMC4-4-16A 16B
Rs. 60,000
Up to 4 axis
Industrial CNC machines
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
182
Araujo, A., Portugal, D., Couceiro, M.S., Rocha, R.P., 2015. Integrating Arduino-based edu-
cational mobile robots in ROS. J. Intell. Robot. Syst. 77 (2), 281–298.
Arroyo G, Ochoa C, Silva J and Vidal G., 2004. Towards CNC Programming Using Haskell. In
Ibero-American Conference on Artiﬁcial Intelligence. Springer, Berlin, Heidelberg, pp.
386–396.
Chen, W., Khamis, H., Birznieks, I., Lepora, N.F., Redmond, S.J., 2018. Tactile sensors for fric-
tion estimation and incipient slip detection - toward dexterous robotic manipulation:
a review. IEEE Sensors J. 18 (22), 9049–9064.
Dihingia, P.C., Kumar, G.P., Sarma, P.K., Neog, P., 2018. Hand-fed vegetable transplanter for
use with a walk-behind-type hand tractor. International Journal of Vegetable Science
24 (3), 254–273.
Hu, J., Yan, X., Ma, J., Qi, C., Francis, K., Mao, H., 2014. Dimensional synthesis and kinemat-
ics simulation of a high-speed plug seedling transplanting robot. Comput. Electron.
Agric. 107, 64–72.
Hwang, H., Sistler, F.E., 1986. A robotic pepper transplanter. Appl. Eng. Agric. 2 (1), 2–5.
Joseph Raj, A.N., Sundaram, R., Mahesh, V.G., Zhuang, Z., Simeone, A., 2019. A multi-sensor
system for silkworm cocoon gender classiﬁcation via image processing and support
vector machine. Sensors. 19 (12), 2656.
Kamel, M., Stastny, T., Alexis, K., Siegwart, R., 2017. Model predictive control for trajectory
tracking of unmanned aerial vehicles using robot operating system. Robot Operating
System (ROS). Springer, Cham, pp. 3–39.
Kruger, J., Gu, W., Shen, H., Mukelabai, M., Hebig, R., Berger, T., 2018, February. Towards a
better understanding of software features and their characteristics: a case study of
marlin. Proceedings of the 12th International Workshop on Variability Modelling of
Software-Intensive Systems, pp. 105–112.
Kumar, G.P., Raheman, H., 2011. Development of a walk-behind type hand tractor
powered vegetable transplanter for paper pot seedlings. Biosyst. Eng. 110 (2),
189–197.
Nejatimoharrami, F., Faina, A., Jovanovic, A., St-Cyr, O., Chignell, M., Stoy, K., 2017. UI De-
sign for an Engineering Process: Programming Experiments on a Liquid Handling
Robot. In 2017 First IEEE International Conference on Robotic Computing (IRC).
IEEE, pp. 196–203.
Rahul, K., Raheman, H., Paradkar, V., 2019. Design and development of a 5R 2DOF parallel
robot arm for handling paper pot seedlings in a vegetable transplanter. Comput. Elec-
tron. Agric. 166, 105014.
Surange, V.G., Gharat, P.V., 2016. 3D printing process using fused deposition modelling
(FDM). Int. J. Res. Eng. Technol. (IRJET) 3, 1403–1406.
Tiansong, L., Feng, G., Yilong, Y., 2019. Design of low-cost desktop robot based on 3D
printing technology and open-source control system. 2019 IEEE 3rd Information
Technology, Networking, Electronic and Automation Control Conference (ITNEC).
IEEE, pp. 739–742.
Wijnen, B., Anzalone, G., Haselhuhn, A., Sanders, P., Pearce, J., 2016. Free and open-source
control software for 3-D motion and processing. Journal of Open Research Software 4,
e2. https://doi.org/10.5334/jors.78.
Rahul K. is persuing Master of Science at Indian Institute of Technology Kharagpur in Farm
Machinery specialization under Agricultural and Food Engineering Department. His re-
search focuses on implementation of robotics and automation in agricultural machinery.
He is also interested in artiﬁcial intelligence, machine vision and mechatronic system de-
sign.
Hifjur Raheman is a Professor in the Agricultural and Food Engineering Department of
Indian Institute of Technology Kharagpur, India. His research areas are use of robotics in
agri-machinery, renewable energy operated agricultural machinery, alternate fuels from
biomass (Biodiesel, producer gas) and bioelectricity production and tillage and traction
improvement in tractors and power tillers.
Vikas Paradkar is Ph.D Student, Specialization in Farm machinery and Power, Agricultural
and Food Engineering Department, Indian Institute of Technology Kharagpur, India. His re-
search focus is on implementation of robot in vegetable transplanter.
R. K., H. Raheman and V. Paradkar
Artiﬁcial Intelligence in Agriculture 4 (2020) 172–183
183
