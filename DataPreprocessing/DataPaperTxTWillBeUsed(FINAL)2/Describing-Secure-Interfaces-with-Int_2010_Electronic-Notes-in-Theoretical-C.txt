

Electronic Notes in Theoretical Computer Science 264 (2010) 107–123
www.elsevier.com/locate/entcs

Describing Secure Interfaces with Interface Automata 1
Matias Lee and Pedro R. D’Argenio2
FaMAF, Universidad Nacional de Co´rdoba, C´ordoba, Argentina Email: lee@famaf.unc.edu.ar, dargenio@famaf.unc.edu.ar


Abstract
Interface automata are a model that allows for the representation of stateful interfaces. In this paper we introduce a variant of interface automata, which we call interface structure for security (ISS), that allows for the modelling of security. We focus on the property of non interference, more precisely in bisimulation- based non interference for reactive systems. We define the notion of compatible interfaces in this setting meaning that they can be composed so that a secure interface can be synthesized from the composition. In fact, we provide an algorithm that determines whether an ISS can be made secure by controlling (more
specifically, pruning) some public input actions, and if so, synthesize the secure ISS. In addition, we also provide some sufficient conditions on the components ISS to ensure that their composition is secure (and hence no synthesis process is needed).


Introduction
A system interface includes all methods and ways that a system uses with the aim to interact with its environment. Nowadays, it is natural to see two or more system interacting to carry out difficult or complex tasks, for example, a web service can use information provided by other web service to offer a more complex new service.
Good interface description should allow the analysis of the interaction between several systems. This way, we can predict if the composed system can satisfy our requirements. From this moment, we use the terms “system” and “interface” to refer to the description/abstraction of the real system interface.
According to the requirements to be enforced on the system, different tools to model interfaces have been devised. For all these definitions, two interfaces are com- patible if, whenever they interact together, a new interface for the composition can be obtained so that it satisfies the desired requirement. Interface automata [6,5,7] is

1 Supported by ANPCyT PICT 26135 and SeCyT-UNC.
2 Also affiliated to CONICET

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.07.008






acceptT?
endT?


tJs tartT? t  nOk!  t 


logF?


logM?
zuJ1  mOn? u2 startM! u3 

 	
endM?


startM?
1 ,¸
endT!
2
ok!



logF!
4
	,¸
logF?

s4 nrewT?  s5 startT!  s6 
J, 
3
u5	u4 r
logM?

s7
logM!

Transaction Service
Transaction Processing Unit
Supervisor


acceptT?	acceptT?

	 s t u r mOn?	 s t u r startM;	 s t u

 1¸1

endT;
1 ¸¸
newT?

endM;
1 1 2
 4¸1

logM;
3

newT?


s t ,u ,¸¸
s t(u z

s t ,u ,

s t ,u ,
s t(u z


logF;

ok!

startT;

logM;

endT;

startT;

s3t4u1 ¸, nOk!	 s t Ju 

s7t1,u4,
s6t3u3 ¸, ok!	 s t Ju 

endT;
s t u ¸, logF;
The Composed System Interface

nOk!
s6t4u3 _.


Figure 1. A distributed transaction processing

a light-weight formalism that captures the temporal aspects of software component interfaces. The leading requirement in this framework is that communication is properly carried out in the sense that for every output one interacting component produces, the other component is ready to receive it. In Resource Interfaces [3] (a variant of interface automata) the resources to complete a task are limited, then two interfaces are not compatible if they need more resources than the available ones. Timed Interfaces [4] is another variant of interface automata that allows expressing time requirements. In this setting two interfaces are compatible if there is a way to use them together so that the composition also satisfy the time requirements.
In this work we define a new variant of interface automata that we call interface structure for security (ISS). In this setting there are two different types of actions. One type carries public or low conﬁdential information and the other carries private or high conﬁdential information. For simplicity, we call them low and high actions, respectively. Following this criteria, low actions are intended to be accessed by any user while the high actions can only be accessed by those users having the appropriate permission. In this context, the desired requirement is the so-called non-interference property [12]. Informally, this property states that users with no appropriate permission cannot deduce any kind of confidential information or activ- ity by only interacting through low actions. Therefore, we expect that compatible components, apart from communicating properly, can be composed in a way that the resulting interface is non interferent.

We illustrate this idea with an example that models a distributed transaction processing (see Fig. 1). The system has three components: a main server (Fig. 1a), a remote transaction processing unit (Fig. 1b), and a supervisor module (Fig. 1c). In its initial state the server is accepting transactions which can be known at the
request of input action acceptT? (at this point an acknowledgement should be ex- pected but we omit it for the sake of simplicity). As usual, outputs are suffixed by ! and inputs by ?. Each new transaction that arrives (newT? ) is sent to be remotely processed (startT!). Then, the server waits for this processing to end (endT? ) in
which case a new transaction may be processed. When in the initial state, a super- visory system may order to start monitoring (startM? ). At this moment transaction are processed as before, but after the remote processing ends, the result is logged
(logM!). After this, the supervisor may end the monitoring (endM? ). Notice that
the actions involving monitoring are intended to be private. (All high actions are underlined.) The transaction processing unit receives transactions (startT? ) and process them satisfactorily (ok!) or not (nOk!) in which case logs the failure (logF!). After this, it informs the result (endT!). All these actions are public. The super-
visor is intended to monitor the different kind of activities. Failed transactions can always be logged (logF? ). Besides, at an external requirement (mOn?), it may start (startM!) logging the activity of the server (logM? ). At a possible failed transaction (logF? in state u3) the activity of the server is logged (logM? at state u4) and the monitoring is ended (endM!).
It is important that occasional monitoring of the server is not revealed to normal users (for example monitoring may be used to understand users behavior). That is why all actions involving monitoring are confidential, while actions involving trans- actions (which are in the interest of the user) are public. It can actually be shown that each of the components of the system satisfies the non interference property in the sense that a user that can only observe low actions cannot distinguish whether a high action has been performed or not in any execution. More specifically, they satisfy the (bisimulation based) non interference relations defined by Focardi and Gorrieri [10]. Roughly, these characterizations state that a system is non interfer- ent whenever an instance of this system which does not perform any high action is weakly bisimilar [15] to another instance where high actions have been hidden.
Fig 1d represents the composition of the three component interfaces as defined in [7]. In the composition, synchronizing actions become hidden which is represented by a suffixed semicolon. Notoriously, this composition leads to a new interface that is not secure. We will explain precisely why after the formal concepts are introduced. By now, it is only important the question of whether a new composed interface that is non interferent can be synthesized from the composed interface automata of Fig 1d. If so, the component interfaces of Fig. 1 will be compatible.
In this article we provide an algorithm to determine whether two ISS are compat- ible and in this case we give an algorithm to synthesize the composed ISS satisfying non-interference. Actually, our algorithm only determines if an ISS can be made secure by controlling (more specifically, pruning) some low input actions, and if so, synthesize the secure ISS. We show that, though obtaining a secure ISS by control-

ling high input actions is possible in some occasion, there is no obvious pattern to determine this in general, let alone to synthesize a secure ISS.
In addition to this, we also provide some sufficient conditions on the components ISS to ensure that their composition is secure. Basically, these conditions require that the component ISS can be composed without missynchronizations and they are non-interferent under the same set of confidential actions as the composed ISS.
Related Work. To our knowledge, very little work has been developed in this same area. Cassez et al. [2] resolve a synthesis problem for trace-based non-interference (SNNI) [10]. They do not make difference between input and output action, and only confidential actions are controllable. [11] and [1] introduce synthesis algo- rithms for timed non-interference on timed automata. The setting is similar as before and in these cases, they study both trace-based and simulation-based timed non-interference. In [1], in particular they allow controllability of both public and confidential actions, but still they do not make distinction between controllable (input) and uncontrollable (output) actions.
Organization of the paper. Section 2 recalls interface automata. In Section 3 we define interface structures for security, the composition operation on them, and recall the bisimulation-based non interference properties of [10]. Section 4 introduces the different algorithms, and the sufficient conditions for compositionality are proved in Section 5. Section 6 concludes the paper. Omited proofs appear in [14].

Interface Automata
An interface automaton [6,5] is an automaton that models the interaction that a system component carries out with its environment. This interaction is performed by means of input and output actions. Input actions describe the behavior that the component expects (or assumes) from the environment. Output actions represent the behavior it communicates (or guarantees) to the environment. The automaton also describes the temporal ordering in which such interactions should take place. We also consider a third set of actions, the so called hidden actions, that are meant to represent internal non-determinism resulting from internal activity. In this section we recall the fundamentals of interface automata that we use in our paper.
Definition 2.1 An Interface Automaton (IA) is a tuple S = ⟨Q, q0, AI, AO, AH, −→⟩ where: (i) Q is a finite set of states with q0 ∈ Q being the initial state; (ii) AI , AO, and AH are the (pairwise disjoint) finite sets of input, output, and hidden actions, respectively, with A = AI ∪ AO ∪ AH ; and (iii) −→ ⊆ Q × A × Q is the transition relation that is required to be input deterministic (i.e. (q, a, q1), (q, a, q2) ∈ δ implies q1 = q2 for all a ∈ AI and q, q1, q2 ∈ Q). In general, we denote QS, AI , →S, etc. to indicate that they are the set of states, input actions, transitions, etc. of the IA S.
As usual, we denote q −→a  q' whenever (q, a, q') ∈ →− , q −→a  if there is q' s.t. q −→a  q',
and q−→/a  if this is not the case. An execution of S is a finite sequence q0 a0 q1 a1 ... qn

s.t. qi
∈ Q, ai
∈ A and q
a
i −→
qi+1
for 0 ≤ i < n. An execution is autonomous if all

their actions are output or hidden (the execution does not need stimulus from the environment to run).
Parallel composition is central to the hierarchical construction of systems. Given two interface automata, their composition defines a new interface that represents the way this new composed system interacts with its environment, hiding the com- munication between the components. It is particularly important to impose new restrictions to the composed interface so that the composed system behaves cor- rectly (i.e. safely ).
Composition of two IA is only defined if their actions are disjoint except when input actions of one of the IA coincide with some of the output actions of the other. Such actions are intended to synchronize in a communication.
Definition 2.2 Let S and T be two IA, and let shared(S, T ) = (AS ∩ AT ) be the set of shared actions. We say that S and T are composable whenever shared(S, T ) = 
(AI ∩ AO) ∪ (AO ∩ AI ).
S	T	S	T
The product of two composable IA S and T is defined pretty much as CSP parallel composition: (i) the state space of the product is the product of the set of states of the components, (ii) shared actions can only synchronize, i.e., both component should perform a transition with the same synchronizing label (one input, and the other output), and (iii) transitions with non-shared actions are interleaved. Besides, shared actions are hidden in the product.
Definition 2.3 Let S and T be composable IA. The product S ⊗ T is the interface automata defined by:
QS⊗T = QS × QT with q0	= (q0 , q0 );
S⊗T	S	T

AI
= AI ∪AI −shared(S, T ), AO
= AO ∪AO −shared(S, T ), and AH	=

S⊗T	S	T
S⊗T	S	T
S⊗T

AH ∪ AH ∪ shared(S, T ); and
S	T
(qS, qT ) −→a S⊗T (q' , q' ) if any of the following holds:
S	T
a ∈ AS − shared(S, T ), qS −→a S q' , and qT = q' ;
S	T
a ∈ AT − shared(S, T ), qT −→a S q' , and qS = q' ;
T	S
a ∈ shared(S, T ), qS −→a S q' , and qT −→a T q' .
S	T
There may be reachable states on S ⊗ T for which one of the components, say S, may produce an output shared action that the other is not ready to accept (i.e., its corresponding input is not available at the current state). Then S violates the input assumption of T and this is not acceptable. States like this are called error states.
Definition 2.4 Let S and T be composable IA. A product state (qS, qT ) ∈ QS⊗T
is an error state if there is an action a ∈ shared(S, T ) s.t. either a ∈ AO, qS−→a S and
qT −→/a	, or a ∈ AO, qT −→a T and qS−→/a  .
If the product S ⊗T does not contain any reachable error state, each component satisfies the interface of the other (i.e., the input assumptions) and are thus compat- ible. Instead, the presence of a reachable error state is evidence that one component

is violating the interface of the other. This may not be a major problem as long as the environment is able to restrain of producing an output (an input to S ⊗ T ) that leads the product to the error state. Of course, it may be the case that S ⊗ T does not provide any possible input to the environment and reaches autonomously (i.e., via output or hidden actions) to an error state. In such a case we say that S ⊗ T is incompatible.
Definition 2.5 Let S and T be composable IA and let S ⊗ T be its product. A state (qS, qT ) ∈ QS⊗T is an incompatible state if there is an error state reachable from (qS, qT ) through an autonomous execution. If a state is not incompatible, it is compatible. If the initial state of S ⊗ T is compatible, then S and T are compatible.
Finally, if two IA are compatible, it is possible to define the interface for the resulting composition. Such interface is the result of pruning all input transitions of the product that lead to incompatible states i.e. states from which an error state can be autonomously reached.
Definition 2.6 Let S and T be compatible IA. The composition S  T is the IA that results from S⊗T by removing all transition q −→a S⊗T q' s.t. (i) q is a compatible
state in S ⊗ T , (ii) a ∈ AI	, and (iii) q' is an incompatible state in S ⊗ T .
Let Sv, TP, and SU be the interfaces of Figs. 1a, 1b, and 1c, respectively. Sv and TP are compatible and Sv  TP = Sv ⊗ TP since Sv ⊗ TP does not contain error states. Sv  TP and SU are also compatible but, for instance, state s2t1u2 in

(Sv  TP) ⊗ SU, which is reached through s1t1u2 −n−e−w−T→?
s2t1u2, is an incompati-

ble state since it reaches the error state s3t4u2 through the autonomous execution

s t u
startT;
nOk!
newT?

2 1 2 −−−−→ s3t3u2 −−−→ s3t4u2. By removing transition s1t1u2 −−−−→ s2t1u2 and
some other, interface Sv  TP  SU is obtained (see Fig 1d).

Interface Structures for Security
In this section we extend IA to cope with security. For this purpose we separate visible actions in two classes: public or low actions, which can be observed and used by any user, and private or high actions, which are intended only for users with the appropriate clearance. According to this separation, we can characterize which components provide a secure manipulation of the information. We take the so-called non interference property [13] as such characterization. We first define interface structures for security (ISS for short) and later adapt the definition of non interference from [10] to our setting.
Definition 3.1 An Interface Structure for Security (ISS) is a tuple ⟨S, Ah, Al⟩
where S is an IA and Ah and Al are disjoint sets of actions s.t. Ah ∪ Al = AO ∪ AI .

If necessary, we will write Ah
and Al
instead of Ah and Al, respectively, and

write AX,m instead of AX ∩ Am with X ∈ {I, O} and m ∈ {h, l}. We will also lift nomenclature of IA to ISS whenever it holds for the underlying IA. For instance,

we say that two ISS ⟨S, Ah , Al ⟩ and ⟨T, Ah , Al ⟩ are composable whenever S and
S	S	T	T
T are composable.
Since it is expected that a low-level user cannot distinguish the occurrence of high actions, we expect that a system behaves the same when high actions are not performed or when high actions are considered as hidden actions. In this setting, by “behave the same” we mean that they are (weak) bisimilar. So, we recall the definition of the restriction and hiding operations and the notion of bisimulation.
Definition 3.2 Given an IA S and a set of actions X ⊆ AI ∪ AO, define:
S	S
the restriction of X in S by S\X = ⟨QS, q0 , AI − X, AO − X, AH, −→S\X⟩

where q −→a

S\X
S	S	S	S
q' iff q −→a S q' and a ∈/ X.

the hiding of X in S by S/X = ⟨QS, q0 , AI − X, AO − X, AH ∪ X, −→S⟩.
S	S	S	S
Given an ISS S = ⟨S, Ah , Al ⟩ define the restriction of X in S by S\X = ⟨S\X, Ah −
S	S	S
X, Al − X⟩ and the hiding of X in S by S/X = ⟨S/X, Ah − X, Al − X⟩.
S	S	S

We write q1 =⇒ε
qn+1 if there are actions a1, ··· , an ∈ AH and states q2, ··· qn ∈ Q,

n ≥ 1, s.t. qi
−a→i
qi+1
∈→−
for 1 ≤ i ≤ n or q1
= qn+1
. We write q =⇒a
q' if there

are q1 and q2 s.t. q =⇒ε
q1 −→a  q2 =⇒ε  q', and q =⇒aˆ
q' if q =⇒a  q' or a ∈ AH and q = q'.

Finally, we write q =⇒ε −→a
if there is q' s.t. q =⇒ε
q' and q' −→a .

Definition 3.3 Let S and T be IA. A relation R ⊆ QS ×QT is a (weak) bisimulation
between S and T if q0 R q0 and, for all qS ∈ QS and qT ∈ QT , qS R qT implies:

S
for all a ∈ AS and q'
T
∈ QS, qS −→a S q'
implies that there exists q'
∈ QT s.t.

qT =⇒aˆ T q'
and q'
S	S	T
R q' ; and

for all a ∈ AT and q'
∈ QT , qT
−→a T q'
implies that there exists q'
∈ QS s.t.

qS =⇒aˆ S q'
and q'
R q' .

We say that S and T are bisimilar, notation S ≈ T , if there is a bisimulation between S and T . Moreover, we say that two ISS S and T , and write S ≈ T , whenever the underlying IA are bisimilar.
The following definitions of non-interference are due to Focardi and Gorrieri [10].
Definition 3.4 Let S be an ISS. (i) S satisfies bisimulation-based strong non- deterministic non-interference (BSNNI) if S\Ah ≈ S/Ah. (ii) S satisfies bisimulation-based non-deterministic non-interference (BNNI) if S\Ah,I/Ah,O ≈ S/Ah.
Notice the difference between the two definitions. BSNNI represents the security property as we describe so far: a system satisfies BSNNI if a low-level user cannot distinguish (up to bisimulation) by means of low level actions (the only visible ones) whether the system performs high actions (so they are hidden) or not (high actions are restricted). BNNI is an apparently weaker notion. (Actually BNNI and BSNNI are incomparable [10].) In this case only input high actions are restricted since the low-level user cannot provide this type of actions; instead output high actions are only hidden since they still can autonomously occur. We also consider this second notion as it seems appropriate for IA where only input actions are controllable.

Parallel composition extends to ISS as follows.
Definition 3.5 Given two composable ISS, S = ⟨S, Ah , Al ⟩ and T = ⟨T, Ah , Al ⟩,
S	S	T	T
their composition, S  T , is defined by the ISS ⟨S	T, (Ah ∪Ah )−shared(S, T ), (Al ∪
S	T	S
Al ) − shared(S, T )⟩.
Returning to our running example, notice that the only high action in Sv  TP  SU is mOn?. We have already mention that Sv  TP  SU does not satisfy non
interference. In fact it does not satisfies BSNNI nor BNNI. (They agree in this example since Ah,O = ∅). In fact, there is no state in (Sv  TP  SU)\{mOn?} that is bisimilar to state s6t2u3 in (Sv  TP  SU)/{mOn?}. So, parallel composition
does not preserve BSNNI or BNNI in general.

Deriving Secure ISS
As we have just seen, the composition of secure interfaces may yield a new insecure interface. The question that arises then is: Is it possible to derive a secure interface out of the resulting composed interface? Notice that, in much the same spirit, a product of IA is adapted to obtain a safe composed interface whenever possible (see Def. 2.6). In this section we present an algorithm to derive an ISS satisfying BSNNI (or BNNI) out of a given ISS whenever possible. Since the method is similar in both cases, we focus on BSNNI.
Our algorithm is based on the algorithm of Fernandez and Mounier to check bisimulation on the fly [8,9]. Roughly, our algorithm works as follows: (i) IA are sat- urated adding all weak transitions =⇒aˆ ; (ii) a full synchronous product is constructed where transitions synchronize whenever they have the same label; (iii) whenever
there is a mismatching transition, a new transition is added on the product leading to a special fail state; (iv) if reaching a fail state is inevitable (we later define this properly) the IA are not bisimilar; if there is always a way to avoid reaching a fail
state, the IA are bisimilar.
The original algorithm stops as soon as it encounters an evidence that the IA are not bisimilar. We basically follow the same algorithm and check if S\Ah ≈ S/Ah, but construct the complete synchronous product regardless whether bisimulation fails. If the bisimulation check succeeds, then S satisfies BSNNI (see Theorem 4.5). If it does not succeed, then we provide an algorithm to decide whether S can be transformed into a secure ISS by pruning low input transitions. This decision mechanism categorizes non-bisimilar pair of states in three different classes: one in
which the pair of states can surely be transformed into bisimilar (May), a second class that definitely cannot be transformed into bisimilar (Fail), and a third class of undetermined pairs of states (Undet).  If the pair of the initial state of the
synchronous product fall into the first class, the ISS can be transformed into a non-interferent interface by pruning low input transitions. Otherwise, it cannot.
The algorithm to synthesize the secure ISS (once it is decided that it is possible) selects low input transitions to prune, prune them, and checks whether the resulting ISS is secure. If it is not, it is certainly the case that the initial state of the product

Table 1
Transitions for the saturation of S marking B (with α ∈ (AI ∪ AO ∪ AI ∪ AO) and x ∈ {ε, ε'})
S	S	S	S



ε	ε'
q −→a S q'  a ∈ AI ∪ AO
q −→a S q'  a ∈ B
q −→a S q'  a ∈ AH − B

q −→SB
q	q −→SB

q −→x
q

q' q' −→α
q −→a
q''

S
'
SB
q −→a
S
ε'	'
q −→SB q
q' a ∈ AI ∪ AO


q' −→x



q''

S
q −→ε	'
B

	SB	SB	


q −→α	q''
B
	SB	S	S	SB	
q −→a	q''
B


ISS is still in the May class and we can proceed by pruning again in the previously pruned ISS. This process is shown to terminate (see Theorem 4.10).
We first adapt Fernandez and Mounier’s algorithm to check bisimulation, then provide the algorithm to decide whether the ISS can be transformed into a secure one, and finally present the synthesis algorithm.

Checking bisimulation-based non-interference
A natural way to check weak bisimulation is to saturate the transition system, i.e.,
to add a new transition q −→a  q' to the model for each weak transition q =⇒a  q',
and then check strong bisimulation on the saturated transition system. This is the starting point of Fernandez and Mounier’s algorithm.
In our case, we will add some extra decoration to the actions on the saturated ISS in order to identify better the different categories of states. These decorations are nonetheless ignored to check bisimilarity. First, we map all hidden actions in AH to
ε and ε' (we call this two actions silent steps). This difference will eventually be so
that the abstracted high input actions (to calculate BNNI or BSNNI) are mapped
into ε' while all other hidden actions are mapped into ε which will be crucial to calculate the Undet class. Besides, we also mark some actions with · to indicate

that a transition q −→a
q is derived by saturating with one or more ε or ε' in front of

it (and maybe some behind it). That is, if q −→a  is valid in the saturation of the ISS
S, then q =⇒ε −→a  is valid in S. Notice, hence, that q −→a  is valid in the saturation of
the ISS S if and only if q −→a  is valid in S. We consider that · is idempotent (a = a)
and for all action a ∈ A, it creates a new action a. We say that a is marked and a
is not marked otherwise, i.e., if a /= a. For a set X of actions, let B = {a | a ∈ B}.
Definition 4.1 Let S be an IA and  B ⊆ AH . The saturation of S marking B is


the IA SB = ⟨QS, q0 , AI ∪ AI , AO ∪ AO, {ε, ε'}, −→ ⟩ where −→
is the smallest

S	S	S	S	S	SB	SB
relation satisfying rules in Table 1. Given an ISS S, its saturation marking B, SB,
is the ISS obtained by saturating the underlying IA.
The set B in previous definition is the set of hidden actions that we want to distinguish as ε'. This can be observed in the two rightmost upper rules in Table 1. Notice that the leftmost lower rule marks the action when it is preceded by an execution of a hidden action. Besides we do not consider saturation of silent steps with the exception of the self loop transitions (the two leftmost upper rules) since it is not needed. Apart from this exceptions, saturation works as usual. We remark

Table 2
Transitions for the synchronous product (a ∈ AI ∪ AO)


qS −→a S q'
qT −→a T q'
qS −→a S q'
qT −→a T q'
qS −→a S q'
qT −→a T q'


(qS, qT ) −→a S×T (q' , q' )
(q ,q ) −→a
(q' , q' )
(q ,q ) −→a
(q' , q' )


ε'	'
S  T
ε	'	ε
S  T
'	ε'
S×T	S  T
'	a
S  T	S×T	S  T
a	a	a

 qS −→S qS  qT −→T qT 
 qS −→S qS  qT −→T qT 
 qS −→S  qT −→/ T 
 qS−→/ S qT −→T 

ε'	'	'
ε'	'	'	(q ,q ) −→a
fail
(q ,q ) −→a
fail

(qS, qT ) −→S×T (qS, qT )
(qS, qT ) −→S×T (qS, qT )	S  T
S×T
S  T	S×T



that (q −→a 
B
q' iff q =⇒a S q') and (q −→a
q' iff q −→a =⇒ε S q')

The second part of the algorithm is to construct a synchronous product attending the missynchronization which leads to a distinguished state fail.  Moreover, we
should also take into account the different markings (namely ε' and ·).
Definition 4.2 Let S and T be two saturated IA with AX = AX = AX for X ∈
S	T
{I, O} and AH = AH = {ε, ε'}. The synchronous product of S and T is the IA S ×
S	T
T = ⟨(QS ×QT ) ∪{fail}, (q0 , q0 ), AI, AO, {ε, ε'}, −→S×T ⟩ where −→S×T is the smallest
S	T
relation satisfying rules in Table 2. Given S = ⟨S, Ah , Al ⟩ and T = ⟨T, Ah , Al ⟩
S	S	T	T
with S and T satisfying conditions above and Am = Am = Am for m ∈ {l, h}, then
S	T
the synchronous product of S and T is defined by the ISS S× T = ⟨S × T, Ah, Al⟩.
With the exception of the two rightmost lower rules in Table 2, all other rules state that the two states can perform some equally labeled action, possibly after many silent steps (recall that the interfaces are saturated). The last two rules say that if an interface can do a transition, and this transition cannot be simulated by the other one, even by using silent steps, then the system makes a transition to a special state called fail.
Notice that, unlike the product of Def. 2.3, the synchronous product synchronizes transition with the same name and the same type (input, output, or silent step). Moreover, transitions do not interleave. In fact, if one transition does not have a matching in the other component, the synchronization leads to a distinguished fail state. Since saturated IA have silent steps self-loops in all states, there is never a silent step leading to fail.
A state of the synchronous product that has a transition to fail represents a pair of states that are not bisimilar. This is evident since such transition is de- fined whenever a state has a transition that the other cannot simulate. The last step of Fernandez and Mounier’s algorithm is to propagate this failure backwards appropriately to identify non bisimilar pairs of states.
Definition 4.3 Let S × T be a synchronous product. We define the set NoPass ⊆
QS×T as NoPass = ∪∞ NoPassi where NoPassi is defined in Table 3. If q ∈ NoPass,
we say that the pair q does not pass the bisimulation test. Besides, we define the set Pass ⊆ QS×T as Pass = NoPassc. If q ∈ Pass, we say that the pair q pass the bisimulation test. If the initial state of an IA underlying an ISS S × T passes
(does not pass) the bisimulation test, we say that S× T passes (does not pass) the bisimulation test.

Table 3

a,a
Auxiliary definitions for NoPass (q −−→
q' is a shorthand for “q −→a
q' or q −→a
q'”.)


NoPass0 = {(qS, qT ): (qS, qT ) −→a S×T fail,a ∈ A}∪ {fail}

NoPassk+1 = NoPassk ∪	[
q−→a q' ∈(−→ ∪−→ )
NoPassk+1
q−→a q'

NoPassk+1
= {(q
,q ): ∀q'
: (q

a,a
,q )
(q' , q' ) ⇒ (q' , q' ) ∈ NoPassk}

a  '	S  T
T	S T
−−→ S T	S  T

qS −→qS
NoPassk+1

= {(q

,q ): ∀q'

: (q

a,a
,q )

(q' , q' ) ⇒ (q' , q' ) ∈ NoPassk}

a  '	S  T
S	S T
−−→ S T	S  T

qT −→qT

The proof of the following lemma is a variation of Fernandez and Mounier’s taking into account our modifications. For this reason we omit it.
Lemma 4.4 Let S and T be two ISS. Let B and B' be any two subsets of the hidden actions of S and T respectively. Then SB ×T B' passes the bisimulation test if and only if S ≈ T .
As an immediate corollary, there is a decision algorithm to check whether an ISS satisfies BSNNI (or BNNI). We state it in the following theorem.
Theorem 4.5 Let S = ⟨S, Ah, Al⟩ be an ISS.

S satisﬁes BSNNI iff (S\Ah)∅ × (S/Ah)Ah,I  passes the bisimulation test.
	
S satisﬁes BNNI iff ((S\Ah,I )/Ah,O)∅ ×(S/Ah)Ah,I passes the bisimulation test.
Synthesizing Secure ISS

Given an ISS S, suppose its synchronous product PS = (S\Ah)∅ × (S/Ah)Ah,I does not pass the simulation test. Notice that the behavior of an interface very much depends on the stimulus that it receives from its environment. Then one could ask if there is a set of stimulus (namely, inputs) such that, if they are forbidden, a secure interface is obtained. This idea repeats the spirit of the idea in the definition of the composition where we prune the set of input transitions that leads to the miscommunication (which is the “undesirable situation” in this case). In this section we provide a first method to find out whether an ISS S that is not secure (i.e., PS did not pass the bisimulation test) can be modified by pruning input transitions so that the result is. Then we use this method to define a new one that, provided S can be modified, so it synthesizes the resulting secure ISS by successively pruning input transitions.
In the previous section we defined the set NoPass containing states of the syn-
chronous product PS. This set contains pair of states that are not bisimilar. This set can in turn be devided in three disjoint subsets. The first subset (May) con-
tains pairs of states of PS such that if some low input transitions of S are pruned this pairs become bisimilar in the new product. Consider, for instance, that the

product contains the only transition (qS, qT ) −a→?
fail where a is low, and suppose

w.l.o.g., that qT −a→/ ? . By removing qS −a→?
the pair (qS, qT ) would become bisimilar.



s0	h!	 s2 
s0, s0
ε s0, s2
s0	h!	 s2 
s0, s0
ε s0, s2

a!
J¸ ,
h’?
J 
a!,a!
a!
ε
J, ¸s,	J 
a!
J, sa!
h’?
J 
a!,a!
a!,a!
ε'
J, ¸s,	J 

s1  s3
a!
b!
s4J 
s1, s1


a!,a!
s0, s3
b!
J 
fail
s1  s3
a!
b!
s4J 
s1, s1


a!,a!
s0, s3
b!
J 
fail

S1 and the synchronous product PS1
Figure 2.
S2 and the synchronous product PS2


In this case we say that (qS, qT ) may pass the bisimulation test. The second set (Fail) contains pairs of states that cannot be turned into bisimilar by pruning low input transitions. Consider the same example as before but now with an output:

(qS, qT ) −a→!
fail. Since the progress from (qS, qT ) is autonomous, there is no way

to control the execution of a! and hence (qS, qT ) will remain non-bisimilar. We say then that (qS, qT ) fails the bisimulation test. More generally, Fail contains those pairs that have an autonomous sequence to a fail state. The last set (Undet) con-
tains undetermined pair of states in the sense that they may become bisimilar if a high input transitions is removed.
The way to remove high input transitions is far from obvious. Consider example in Fig. 2a. On the left-hand side of Fig. 2a we depict the ISS S1, on the right-hand
side, the synchronous product PS1 (self ε and ε loops are omitted). S1 does not
'
satisfy BSNNI. It is easy to verify that s0s0 ∈ NoPass.  To avoid the backward

propagation of the failure induced by the missynchronization of transition s3 −→b
s4,

the only point of control is high input h’? in transition s
h’?
s . However, removing

2 −−→ 3
this transition in S1 has no impact at all as the new reduced ISS (having only states
s0, s1, s2 and the remaining transitions that connect them) does not satisfy BSNNI either. Of course, it is also possible that removing a high input transition does change the model to a secure one.  This is precisely the case of the example in

Fig. 2b which presents a slight variation of S . If transition s
h’?
s
is removed

1
in S2, the reduced model satisfies BSNNI.
2 −−→ 3

The difficulty on eliminating high input transitions lies on the fact that they are only present in one of the ISS of the synchronous product PS, namely, in (S/Ah)Ah,I . This is not the case of a low input transition  since the candidate to be removed come
from an effective synchronization between (S\Ah)∅ and (S/Ah) h,I . This can be
S
better seen in the formal definition of these sets.
Definition 4.6 Let S × T  be a synchronous product.	We define the sets
Fail, Undet, May ⊆ QS×T respectively by:
Fail = ∪∞ Faili where Faili is defined in the Table 5. If q ∈ Fail, we say that
the pair q fail the bisimulation test.
Undet = ∪∞ Undeti where Undeti is defined in the Table 6. If q ∈ Undet, we
say that the pair q is an undetermined state w.r.t the bisimulation test.
May = ∪∞ Mayi where Mayi is defined in the Table 7. If q ∈ May, we say
that the pair q may pass the bisimulation test.

Table 4
Ω is auxiliary to the definitions of Failk+1, Undetk+1 and Mayk+1


Ω(X, Λ, Ω')= Ω' ∪	[
q−→a q' ∈(−→ ∪−→ )
Ωq−→a q'

(X, Λ, Ω')

Ω	(X, Λ, Ω')= {(q
,q ) /∈ X : a ∈ Λ,q 
−→a
q' , (∀q'
: (q
a,a
,q )
(q' , q' ) ⇒ (q' , q' ) ∈ X ∪ Ω')}

q −→a q'
S  T	S
S	T	S
T −−→ S  T	S  T

S	S

Ω	(X, Λ, Ω')= {(q

,q ) /∈ X : a ∈ Λ,q 

−→a

q' , (∀q'

: (q

a,a
,q )

(q' , q' ) ⇒ (q' , q' ) ∈ X ∪ Ω')}

q −→a q'
S  T	T
T	S	S
T −−→ S  T	S  T


Table 5 Auxiliary definitions for Fail
Fail0 = {(qS, qT ): (qS, qT ) −→a S×T fail,a /∈ AI ∪ {ε'}}∪ {fail}	Failk+1 = Ω(∅, AO ∪ {ε}, Failk) Table 6
Auxiliary definitions for Undet


Undet 0 =	[
q−→a q' ∈(−→ ∪−→ )
Undet 0
q−→a q'

Undetk+1 = Ω(Fail, AO ∪ {ε, ε'}, Undetk)

0	ε'	'	'	ε'	'	'	'	'

Undet
'
qS −→qS
= {(qS, qT ) /∈ Fail : qS −→ qS, (∀qT : (qS, qT ) −→ (qS, qT ) ⇒ (qS, qT ) ∈ Fail)}

0	ε'	'	'	ε'	'	'	'	'

Undet
'
qT −→qT
= {(qS, qT ) /∈ Fail : qT −→ qT , (∀qS : (qS, qT ) −→ (qS, qT ) ⇒ (qS, qT ) ∈ Fail)}


Table 7
Auxiliary definitions for May



May0 =	[
q−→a q' ∈(−→ ∪−→ )
May0 a
q−→q'

Mayk+1 = Ω(Fail ∪ Undet, A, Mayk)

May0 a
q −→q'
= {(qS
, qT ) /∈ Fail ∪ Undet : qS
−→a
q' , (qS
, qT ) −→a

S×T
fail }

May0
q
S	S

−→a q'
= {(qS
, qT ) /∈ Fail ∪ Undet : qT
−→a
q' , (qS
, qT ) −→a

S×T
fail }

T	T

In general, if the initial state of the underlying IA of an ISS S × T may pass (fail, is undetermined w.r.t.) the bisimulation test, we say that S × T may pass (fail, is undetermined w.r.t.) the bisimulation test.
Sets Fail, Undet, and May form a partition of NoPass. The fact that they are disjoint is immediate from their definitions. The inclusion Fail ∪ Undet ∪ May ⊆ NoPass can be proved by routine induction.
Lemma 4.7 For any synchronous product PS, Fail ∪ Undet ∪ May = NoPass
Therefore, all pairs in Fail ∪ Undet ∪ May are not bisimilar. In the following we show that an ISS S that is not non-interferent, but whose synchronous product PS may pass the bisimulation test, can be controlled (in the sense that some low
input transitions will be forbidden) so that it results in a new reduced ISS S that is non-interferent.
First, we need to select which are the candidate input actions to be removed on

Table 8
Set of eliminable candidates.

EC(S) ={q −→a

q' : (∃qˆ : (q, qˆ) ∈ May0 a
q−→q'
∨ (qˆ, q) ∈ May0 a
q−→q'
)}∪

{q −→a
q' : (∃qˆ : (q, qˆ) ∈ May1 a
, (∀qˆ' : (q, qˆ) a,a
(q', qˆ') ⇒ (q', qˆ') ∈ Fail ∪ Undet)}∪


{q −→a
q−→q'
q' : (∃qˆ : (qˆ, q) ∈ May1 a
q−→q'


, (∀qˆ' : (qˆ, q) a,a

(qˆ', q') ⇒ (qˆ', q') ∈ Fail ∪ Undet)}






s0  h! s2 
	a?
s0	s0   ε  s2  
	a?
s0, s0   ε  s0, s2

a?	ε	a?
a?	a?
ε	a?
a?	ε	a?

s1J  s3J  vs4 z
s1J 
s1J a? s3J a? vs4rzz
s1,Js1  a? s0,Js3 a?
sz1,ts 4\

a?	b!
a?	b!
a?	b!

sJ c? sJ 
stJ  z c ?  sJ 
s z,Js z  c?  J 

S
S\{h!}
S/{h!}
PS

Figure 3.

these kind of ISS so that they becomes secure. So, if S is an ISS such that PS may pass the bisimulation test, the set EC(S) ⊆ −→∩ Q × Al,I × Q, defined in Table 8, is the set of eliminable candidates.
Notice that all transitions in EC(S) are indeed labeled with low input actions.
Moreover, all these transitions are involved in a synchronization that connects a
source pair that may pass the bisimulation test and a target pair that fails the bisimulation test. This can happen in three different manners. The first case is the basic case, in which one of the components of the pair can perform the transition but not the other. The other two are symmetric and consider the case in which both sides can perform an equally labeled transition but end up in a pair that fails or is undetermined.
As an example consider the ISS S in Fig. 3a. It only contains one private action, namely h!. Fig. 3b, 3c, and 3d, represents the different stages until the construction of the synchronous product PS. It is easy to see that S is not secure: S/{h!} can perform actions b! or c? after a? and some silents steps, while S\{h!}
cannot. Applying rules in Tables 3 to 7, we obtain that Pass = {(s1, s1)}, Fail =
{(s1, s4), fail} and May contains all remaining states in PS. It is also possible to

calculate that EC(S) = {s5 −c→?
s6, s2 −a→?
s4}. Notice that, if both transitions are

removed, the resulting ISS is indeed non-interferent (in fact, it suffices to remove

only s2 −a→?
s4).

An important result is that no new fail or undetermined pair of states is intro- duced by removing eliminable candidates. Moreover, if a pair of states is fail or undetermined in the synchronous product of the original ISS and it is also present in the synchronous product of the reduced ISS, then it is also fail or undetermined in this ISS. By the counter positive, this ensures that a synchronous product that passes or may pass the bisimulation test, will not fail or be undetermined after prun-
ing. In a sense, Lemma 4.8 below states that the sets Fail ∪ Undet and Pass ∪ May

remain invariant.
Lemma 4.8 Let £ be an ISS s.t. PS may pass the bisimulation test.	Let £'
be an ISS obtained by removing one transition in EC(£) from £ (i.e. —→S' =
—→S — {q —→a q'}, provided q —→a q' ∈ EC(£), and unreachable states are removed
form £').	Then:	(i) FailP ' ∪ UndetP '	= (FailP ∪ UndetP ) ∩ QP ' ; and
S	S	S	S	S
(ii) (PassPS ∪ MayPS ) ∩ QPS' = PassPS' ∪ MayP ' . (Subindices in FailPS , UndetPS ,
etc. indicate that these sets were obtained from the synchronous product PS.)
In addition, we have that all eliminable candidate transition in the original ISS that have not been removed somehow (either by explicit elimination or because they are not reachable anymore), are also eliminable candidates of the reduced ISS. This is stated in the following theorem.
Lemma 4.9 Let £ be an ISS s.t. PS may pass the bisimulation test. Let £' be the ISS obtained by removing one transition in EC(£) from £. Then EC(£) ∩ →— S' ⊆ EC(£').
The next theorem states the main result of this section. (As we mention in the introduction of this section, similar proofs will lead to a similar algorithm to synthesize interfaces satisfying BNNI whenever possible.)
Theorem 4.10 Let £ be an ISS s.t. PS may pass the bisimulation test. Then there exists a set —→χ of low input transitions such that, if £' is the ISS obtained from £ by removing all transitions in —→χ, £' satisﬁes BSNNI.
Proof Let £0 = £. For all k such that PSk does not pass the bisimulation test,
£k+1 be the ISS obtained by removing one transition tk ∈ EC(£k) from £k.
If this algorithm terminates, say at iteration K, then £K satisfies BSNNI (by Theorem 4.5 and Lemma 4.7) and —→χ = {tk ∈ EC(£k) | 0 ≤ k < K}.
Suppose this algorithm does not terminate. Since £ is finite, there must be a K'
K'
such that EC(£	) = ∅ and PSK' may pass the bisimulation test. (This is guaran-

teed by Lemma 4.8.ii.) Therefore MayP

SK'
/= ∅ and hence May0
SK
∪May1
SK
/= ∅.

If May0
SK
/= ∅, it is immediate that EC(£K' ) /= ∅ which is a contradiction. So,

suppose May0
SK
= ∅ and May1
SK
/= ∅. Then, there must be a transition q —→a q'

and a state qˆ such that either (q, qˆ) or (qˆ, q) is in May1 a
q—→q',P K'
. W.l.o.g. suppose

it is (q, qˆ). Then (q, qˆ) ∈/ Fail
PSK'
∪ UndetP	'
S


and 6qˆ' : (q, qˆ) a,a
(q', qˆ') : (q', qˆ') ∈/

Fail
SK
' ∪ UndetP
S
' ∪ May0
SK
= Fail
SK
' ∪ UndetP
S
' , since May0
SK
= ∅. But

then, necessarily a ∈ Al,I (otherwise (q', qˆ') ∈ Fail
SK
' ∪ UndetP
S
' ).	Hence

q —→a  q' ∈ EC(£K' ) which, again is a contradiction.	 
Compositional construction of secure interfaces
It is known from [10] that neither BNNI nor BSNNI are preserved by CSP-like parallel composition. This also extends to the composition of interface automata.



s h1 ? s h2 ! s h1 ? s 
t h1 !  t 
s ,t  h1;  s ,t 
h2 !  s ,t 

a!	a!	a!	a!	a!

sJh 1 ? sJ 
sJ 
s ,Jt  h1 ; s , Jt 

(a) S
(b) T
(c) S  T

Figure 4.

An example is reported in Fig. 4. In this brief section we report a small but yet important result: we give sufficient conditions to ensure that the composition of ISS results in a non-interferent ISS. Basically, these conditions require that (i) the component ISS are fully compatible, i.e. no error state is reached in the composition (in any way, not only autonomously), and (ii) they satisfy the non-interference property under the same set of confidential actions as the composed ISS. This is stated in the following theorem.
Theorem 5.1 Let £ = ⟨S, Ah , Al ⟩ and T  = ⟨T, Ah , Al ⟩ be two composable
S	S	T	T

ISS. Let £' = ⟨S, Ah
— shared(S, T ), Al  ∪ shared(S, T )⟩ and T ' = ⟨T, Ah —

shared(S, T ), Al ∪ shared(S, T )⟩. If £ ⊗ T has no reachable error states and £'
and T ' satisfy BSNNI (resp. BNNI) then £  T satisﬁes BSNNI (resp. BNNI).
In particular, notice that the £ ⊗ T in Fig 4 has no reachable error states (and hence it agrees with £  T ) but £ does not satisfy BSNNI nor BNNI if only
shared(S, T ) = {h1} is consider confidential (hence being out of the hypothesis of
the theorem).

Concluding remarks
We have presented a framework to manipulate stateful interfaces for security and their composition. We also provided a synthesis algorithm that decides whether an ISS can be turned into a secure ISS (namely, satisfying BSNNI or BNNI) by controlling low input transitions. In particular, this can be seen in the example of the introduction (Fig. 1d) where the distributed transaction processing can be turned
into secure by eliminating action acceptT?. (This can be derived with the algorithm
of Theorem 4.10.) However, as we saw extending controllability to all input actions
(including confidential actions) is much more difficult. This is something we are considering in our future work.
We also have shown that in certain non trivial cases, compositional construction of secure interfaces is possible. Yet, the requirements are still a little too restricting since ISS are suppose to be composed so that no error state (i.e. miscommunication) is reached. This will be always possible in input enabled interfaces, but the setting of interface automata is intended to drop this condition. A further study to relax this conditions is also worthwhile.
Finally, we are currently busy extending the idea of refinement of interface au- tomata to ISS and studying its relation to BSNNI and BNNI.
Acknowledgements: We thank the anonymous referees for their valuable remarks.

References
Benattar, G., F. Cassez, D. Lime and O. H. Roux, Synthesis of non-interferent timed systems, in:
J. Ouaknine and F. W. Vaandrager, editors, FORMATS, Lecture Notes in Computer Science 5813
(2009), pp. 28–42.
Cassez, F., J. Mullins and O. H. Roux, Synthesis of non-interferent systems, in: 4th Int. Conf. on Mathematical Methods, Models and Architectures for Computer Network Security (MMM-ACNS’07), Communications in Computer and Inform. Science 1 (2007), pp. 307–321.
Chakrabarti, A., L. de Alfaro, T. Henzinger and M. Stoelinga, Resource interfaces, in: Proceedings of the Third International Conference on Embedded Software (EMSOFT), LNCS, Springer, 2003, pp. 117–133.
de Alfaro, L., T. Henzinger and M. Stoelinga, Timed interfaces, in: Proceedings of the Second International Workshop on Embedded Software, LNCS, Springer, 2002, pp. 108–122.
de Alfaro, L. and T. A. Henzinger, Interface automata, in: ESEC / SIGSOFT FSE (2001), pp. 109–120.
de Alfaro, L. and T. A. Henzinger, Interface theories for component-based design, in: T. A. Henzinger and C. M. Kirsch, editors, EMSOFT, Lecture Notes in Computer Science 2211 (2001), pp. 148–165.
de Alfaro, L. and T. H. Henzinger, Interface-based design, in: M. B. et al., editor, Engineering Theories of Software-Intensive Systems, Nato Science Series (2005), pp. 83–104.
Fernandez, J.-C. and L. Mounier, “on the fly” verification of behavioural equivalences and preorders, in: Procs. of CAV ’91, LNCS 575 (1991), pp. 181–191.
Fernandez, J.-C., L. Mounier, C. Jard and T. J´eron, On-the-fly verification of finite transition systems, Formal Methods in System Design 1 (1992), pp. 251–273.
Focardi, R. and R. Gorrieri, Classification of security properties (part i: Information flow), in: Procs. of FOSAD 2000, LNCS 2171 (2001), pp. 331–396.
Gardey, G., J. Mullins and O. H. Roux, Non-interference control synthesis for security timed automata, Electr. Notes Theor. Comput. Sci. 180 (2007), pp. 35–53.
Goguen, J. A. and J. Meseguer, Security policies and security models, in: IEEE Symposium on Security and Privacy, 1982, pp. 11–20.
Goguen, J. A. and J. Meseguer, Security policies and security models, in: IEEE Symposium on Security and Privacy, 1982, pp. 11–20.
Lee, M. D. and P. R. D’Argenio, Estructura de interfaces para sistemas con seguridad multi-nivel., Tech. Rep. Serie A 2009/3, FaMAF, Universidad Nacional de C´ordoba (2009).
Milner, R., “Communication and Concurrency,” Prentice Hall International, 1989.
