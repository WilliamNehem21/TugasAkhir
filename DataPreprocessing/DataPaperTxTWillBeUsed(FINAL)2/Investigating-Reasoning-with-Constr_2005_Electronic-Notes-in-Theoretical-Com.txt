Electronic Notes in Theoretical Computer Science 127 (2005) 53–69  
www.elsevier.com/locate/entcs


Investigating Reasoning with Constraint Diagrams
Andrew Fish1,2  Jean Flower1,3
Visual Modelling Group University of Brighton Brighton BN2 4GJ, UK

Abstract
Constraint diagrams are a visual notation designed to express logical constraints. Augmenting the diagrams with a reading tree (effectively a partial ordering of quantifiers) ensures that each diagram has a unique semantic interpretation.
In this paper, we discuss examples of reasoning rules for augmented constraint diagrams which exhibit interesting properties or difficulties that can arise when developing rules for such a dia- grammatic system. We do not present a complete set of rules, but investigate the generic problems arising, providing solutions. One problem corresponds to the nesting of quantifiers and another relates to the domain of universal quantification. These issues may be an important considera- tion in the definition of other logical reasoning systems which explicitly represent quantification diagrammatically.
Keywords: Diagrammatic reasoning, constraint diagrams, logical inference.


Introduction
The constraint diagram notation [6] has only recently been given full for- mal semantics [2,3]. It is intended that constraint diagrams, used to express logical constraints, will be used by software engineers alongside the Unified Modelling Language (UML). A specification of a software component, given in diagrammatic form, can be matched against a requirement specification, again

1 This research was partially supported by UK EPSRC grant GR/R63516
2 Email: Andrew.Fish@brighton.ac.uk
3 Email: J.A.Flower@brighton.ac.uk



1571-0661 © 2005 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2004.08.047


in diagrammatic form. This matching up of component against requirement can be done by providing a logical argument between pre and post conditions on the component behaviour. Once the constraint diagram system is given a set of reasoning rules, the argument can be conducted, presented and verified at the syntactic level.
The language of constraint diagrams is rich in its expressiveness, and we would like to be able to reason between constraint diagrams using diagram transformations called reasoning rules. A sensible approach to designing such rules is clear - users are thinking of deleting, adding and editing the syntax of the diagram. The rules must be valid (i.e. if d1 can be transformed into d2 using a sequence of reasoning rules then the semantics of d1 entail those of d2). In this paper we describe a selection of rules which delete, add or edit the diagram syntax. The rules have been chosen to illustrate interesting properties that will recur for other rules in this system and are of wider interest to developers of other diagrammatic systems.

d1	d2
Fig. 1. Examples of constraint diagrams

Of course, reasoning could take place at the level of diagram semantics by writing proofs in first order predicate logic (FOPL). Some diagrammatic transformation rules correspond to simple FOPL transformations. However, some FOPL rules translate into complicated diagrammatic rules and some di- agrammatic transformations correspond to non-trivial FOPL transformations. To maintain the advantage gained by providing a formal diagrammatic nota- tion, we would like to reason between diagrams rather than between diagram semantics.
Work on reasoning rules for simple diagrammatic systems based on Euler diagrams has been undertaken [4,7,9]. A sound and complete reasoning sys- tem has been developed for spider diagrams [5], which form a subsystem of constraint diagrams (for an example of a spider diagram see d1 in figure 1). The expressiveness of spider diagrams is only equivalent to that of monadic first order predicate logic with equality [8], and so they are not very prac- tical for use in software modelling, as opposed to the much more expressive

constraint diagram system.
We will not present a complete set of reasoning rules for constraint di- agrams, but we investigate the generic issues arising in the development of rules. These considerations may be useful in any attempt to define similar diagrammatic logical reasoning systems.
In sections 3 and 4, we describe rules which have strong preconditions and are designed to make small changes to the diagram syntax. Giving strong preconditions makes it easier to assess whether the rules are valid (assists reasoning about the system). This makes it easier to describe the changes that take place when the rule is applied, and simple rules are useful for automatic proof-writing algorithms. However, simple rules are applicable in fewer cases (hindering reasoning with the system).
In section 5 we show how to combine simple rules to make derived rules which are more widely applicable. These derived rules may have complex effects upon a diagram, and an algorithm is followed to determine the outcome. Such algorithms for rules could be implemented in a software tool. We imagine a user presented with a diagram would be able to select a syntactic element in a diagram and be offered applicable rules. While the effects of derived rules may be rather complex to describe, the burden of work falls upon the tool developers and not with the users.
Background work
Formal syntax and semantics of the constraint diagram system can be found in [2,3]. We illustrate the concepts by examples.
Constraint diagrams: syntax
In figure 1 there are two constraint diagrams. The first, d1, has three given contours, labelled A, B and C, and five zones, one of which is shaded. There are two existential spiders, s and t. Spider s has two feet and its habitat is the pair of zones inside A. Spider t has only one foot and its habitat is the shaded zone. The second diagram, d2, includes a universal spider, x, with habitat inside A and two arrows labelled f and g. The arrow labelled f is sourced at x and has a derived contour as its target. Derived contours have no labels.
Constraint diagrams as described above can be ambiguous [3]. Augmenting the diagrams with a reading tree (essentially a partial order on the spiders in the diagrams) ensures a unique semantic interpretation: a reading which is a sentence in FOPL. In this paper, when we refer to a constraint diagram, we really refer to an augmented constraint diagram, which is a constraint diagram accompanied by a reading tree, as defined in [3].

Constraint diagrams: semantics
Informally, we describe the semantics of these pieces of syntax. Given con- tours represent sets and derived contours represent the image of a relation. Topological properties, such as disjointness and containment of contours are respected by the corresponding sets. Existential spiders represent existential quantification, universal spiders represent universal quantification and arrows represent relations. Shading in a zone places an upper bound on the cardi- nality of the corresponding set. Distinct spiders represent distinct elements.



d1	d2
 
x	s	s	x

Fig. 2. Constraint diagrams

Example 2.1 In figure 2, the diagrams d1 and d2 have different reading trees. The readings for d1 and d2 are
A ∩ B = ∅∧ ∀x ∈ A(x.f ⊆ B ∧ ∃s ∈ B − x.f ) and A ∩ B = ∅∧ ∃s ∈ B(∀x ∈ A(x.f ⊆ B − {s})).
In these expressions, the notation x.f is used to denote the relational image of x under the relation f .
The first part of these readings: A ∩ B = ∅ is known in general as the plane tiling condition [3,5]. It expresses the information we can deduce from the relative positioning of the given contours. In this case A and B are disjoint. All readings start with the plane tiling condition, but in this paper we have chosen to omit this part of the reading, for brevity. 4 The derived contours are not included in the plane tiling condition, and they are interpreted later in the reading (e.g. x.f ⊆ B). A derived contour may represent a collection of
sets: different sets x.f for different values of x.

4 Readers may notice that some reading trees appear to be disconnected (see figure 3, for example). This is because each tree includes a root node, corresponding to the plane tiling condition, which we omit from the figures. Furthermore, in this paper, any reading tree which consists of only the root node and one other node is omitted.



d1	d2
x 	x	y
y

Fig. 3. The effect of ordering nodes x and y

Example 2.2 In figure 3, the readings of d1 and d2 are
∀x ∈ A(x.f = C) ∧ ∀y ∈ B(y.g = D) and ∀x ∈ A(x.f = C ∧ ∀y ∈ B(y.g = D)).
In the reading tree of d1 the nodes x and y are unordered and so the quantifiers x and y are not nested in the reading. In d2, x is ordered before y and so the quantifiers are nested: y is in the scope of x. Therefore, the reading of d2 is true whenever the set corresponding to A is empty, whatever the relationship between y, g and D, but this is not the case for the reading of d1.
Diagram readings are FOPL sentences which may include phrases like
∀y ∈ A(...), which is a shorthand version of ∀y(y ∈ A ⇒ ...). These sentences are the kinds of assertions needed when modelling software systems in order to make statements about all objects of a certain type. When designing reasoning rules, we have to be constantly aware of the case where universal quantification can take place over an empty domain (the set A above).

Compound diagrams
We can build compound diagrams from unitary diagrams using the logical connectives and, or and not.

d2 = (d3 and d4)
d1

x
y 

Fig. 4. Compound constraint diagrams


Example 2.3 In figure 4, d1 is unitary, and is semantically equivalent to the compound diagram d2= d3 ∧ d4. Both have reading
∀x ∈ A(x.f = C) ∧ ∀y ∈ B(y.g = D).

Dependence of spiders and ordering in the reading tree
Dependence between spiders in a diagram is a syntactic condition which en- capsulates the need of the corresponding quantifiers to reference each other in the semantic interpretation. An ordering of nodes in a reading tree for a diagram places one of the corresponding quantifiers in the scope of the other. Say that a reading tree is valid for a diagram if it provides ordering between the nodes of dependent spiders. It may or may not provide ordering between independent spiders.
For example, in figure 2, spiders x and s are dependent in the diagrams, and so their nodes have to be ordered in the reading trees (allowing us to say s ∈ B − x.f , for example). However, in figure 3, the spiders x and y are independent and so they don’t have to be ordered in the tree.

Diagrammatic rules
Rules discussed in this section are purely diagrammatic, transforming a uni- tary diagram into another unitary diagram. These simple rules have strong preconditions and are designed to make small changes to the diagram syntax. We have, in some cases, written preconditions that are stronger than they need to be, in order to be able to describe the rule simply in a limited amount of space.
Erase shading
This rule can reduce dependence between spiders. There is no precondition on the rule; the existing reading tree will be valid after an application of the rule.
Example 3.1 In figure 5 the diagrams d1 and d2 have readings

∀x ∈ A(x.f ⊆ A ∩ B ∧ ∀y ∈ B(y.g ⊆ A ∩ B ∧ x.f ∩ y.g = ∅)),

and ∀x ∈ A(x.f ⊆ A ∩ B ∧ ∀y ∈ B(y.g ⊆ A ∩ B)).
In d1, the spiders x and y are dependent because of the shading. Both quan- tifiers must be in scope in order to assert that the shaded area is empty (x.f ∩ y.g = ∅). In d2, the spiders are independent.



d1	d2


erase shading


/

x	y


Fig. 5. Erasing shading
Add existential spider feet

d1	d2

add existential spider feet
/

Fig. 6. Adding existential spider feet

Example 3.2 Figure 6 shows the transformation of d1 with reading ∃s ∈
A ∩ B into d2 with reading ∃s ∈ A. This rule has enlarged the domain of s.
Enlarging the domain of a spider can introduce new dependencies. This provides a precondition on the rule: the reading tree for the premise diagram has to be valid for the conclusion diagram.
d1












x	s
y	t

Fig. 7. Existential spiders that cannot have certain feet added

Example 3.3 Figure 7 shows a case where neither of the existential spiders
s nor t can be extended into the habitat of the other. The reading tree has s


and t unordered and so the scopes of s and t are disjoint in the reading
∀x ∈ A(∃s ∈ C−D(s = x.f )) ∧ ∀y ∈ B(∃t ∈ D−C(t = y.g)).
If one tried to add a foot to s in the zone occupied by t, then there would be no way to say that s /= t because in this reading there is insuﬃcient nesting of quantiﬁers.
In both of the preceding examples, we considered the addition of single feet. Some spiders can have multiple feet added, even though those feet cannot be added individually.

d1	d2


add existential feet
/
x 	x
s 	s
Fig. 8. Adding multiple feet to an existential spider

Example 3.4 In figure 8, the readings of d1 and d2 are

∀x ∈ A(x.f ⊆ B) ∧ ∃s ∈ A ∩ B,

and ∀x ∈ A(x.f ⊆ B) ∧ ∃s ∈ A.
These feet could not have been added individually because x is not in the scope of s (nor vice versa) and we can not say that ∃s ∈ A∩ x.f , for example.

Delete existential spider
An existential spider s can be deleted if none of the following conditions hold:
s is the source or target of any arrow,
the habitat of s includes a shaded zone,
there is a universal spider x whose domain includes a foot of the spider s
and the node s is ordered before the node x in the tree.
Example 3.5 In figure 9, the readings of d1 and d2 are

∀x ∈ A(∃s ∈ A(s /= x ∧ ∃t ∈ A(x.f = t))),
and ∀x ∈ A(∃t ∈ A(x.f = t)).



d1	d2

delete existential spider
/
x	s	t	x	t
  	

Fig. 9. Deleting an existential spider
In d1, s is ordered after x in the tree, so s can be deleted from d1 to give d2. If the reading tree of d1 had been s → x → t then the reading would have been

∃s ∈ A(∀x ∈ A((s = x) ∨ (∃t ∈ A(x.f = t))))
and we would not have been able to delete s from the diagram.
We cannot deduce expression 2 from expression 3 because we would be inferring the stronger property ∃t ∈ A(x.f = t) from the weaker property (s = x) ∨ (∃t ∈ A(x.f = t)). This property strengthening prevents us from removing the spider s.
This is the first rule to affect the reading tree. The resulting tree is obtained by first adding edge a → b whenever there are edges a → s and s → b, and then deleting s from the tree.
Delete arrow
We can always delete an arrow which does not target a derived contour.
Derived contour targeted by a single arrow

d1	d2

delete arrow

/

Fig. 10. Deleting an arrow can delete a derived contour
If an arrow f targets a derived contour c, and no other arrow targets c
then c will be deleted when f is deleted. 5

5 After the deletion of a contour any partial shading (not occupying a complete zone) is erased and if there is a spider with more than one foot in a zone, those feet will be merged.


Example 3.6 In figure 10, d1 and d2 have readings

∃s ∈ A(s.f ⊆ A ∧ s.f = ∅)	and	∃s ∈ A.
The three preconditions on deletion of such an arrow and contour are:
there are no arrows emanating from the target contour,
the derived contour is not needed to describe the domain of any universal spider,
the reading tree for the premise diagram is valid for the conclusion diagram.


d1	d2






delete arrow

/





s	x	t	s	x	t

Fig. 11. Deleting an arrow can introduce dependence


Example 3.7 In figure 11 deleting g will delete the derived contour s.g, in- troducing a new dependence between x and t. The readings of d1 and d2 are

∃s ∈ B(s.g ⊆ D ∧ ∀x ∈ A(s.g ⊆ x.f ⊆ D ∧ ∃t ∈ C(t.h ⊆ s.g))),
and ∃s ∈ B(∀x ∈ A(x.f ⊆ D ∧ ∃t ∈ C(t.h ⊆ x.f ))).
Because the reading tree is still valid with the new dependence between x and t, we can delete g. If the reading tree had been x ← s → t (branched at s with x and t unordered) then the reading would have been

∃s ∈ B(s.g ⊆ D ∧ ∀x ∈ A(s.g ⊆ x.f ⊆ D) ∧ ∃t ∈ C(t.h ⊆ s.g)).

and g could not have been deleted from the diagram using this simple rule because there is insuﬃcient nesting of the quantiﬁers in the reading (x and t are not nested).

Derived contour targeted by multiple arrows
Suppose that a derived contour is the target of more than one arrow. The only precondition for delete arrow in this case is that we do not enlarge the domain of any universal spider.

d1	d2
 
x	y	z	x	y	z
	
Fig. 12. Deleting an arrow can delay the interpretation of a derived contour

Example 3.8 In figure 12, the readings of d1 and d2 are

∀x ∈ A(x.f ⊆ A ∩ B ∩ D ∧ ∀y ∈ B(y.g = x.f ∧ ∀z ∈ x.f (z.h = D))) and ∀x ∈ A(∀y ∈ B(y.g ⊆ A ∩ B ∩ D ∧ ∀z ∈ y.g(z.h = D))).
In d1, f targets a derived contour c, and f is used to interpret the contour (in the expression x.f ⊆ A ∩ B ∩ D). The contour c is interpreted using f rather than g because x was ordered before y in the reading tree. In d2, after deleting f , the derived contour c is interpreted later in the sentence (y.g ⊆ A∩B∩D) and y.g is used in place of x.f to refer to c in other assertions (such as ∀z ∈ y.g(z.h = D)). Say that we delayed the interpretation of c.
This delay of interpretation was possible because the reading tree ordered y before z. If the tree had been x → z → y then the readings would have been:

∀x ∈ A(x.f ⊆ A ∩ B ∩ D ∧ ∀z ∈ x.f (z.h = D ∧ ∀y ∈ B(y.g = x.f ))),

∀x ∈ A(∀z ∈ A ∩ B ∩ D(z.h = D ∧ ∀y ∈ B(y.g ⊆ A ∩ B ∩ D ∧ z ∈ y.g))) and the removal of f would have enlarged the domain of z to A ∩ B ∩ D.
Delete universal spider
A universal spider x cannot be deleted if there are any arrows sourced at x or targeted on x. A second precondition asserts that no spider can be ordered after x in the reading tree. This is because in the absence of any contextual information, the universal quantification could have an empty domain. If a universal spider x has another spider s ordered after x in the reading tree,


then the reading takes the form ...∀x ∈ A(...∃s ∈ B(...)). If the set A might be empty, we can not replace this by ...∃s ∈ B(...).
Transpose existential node labels
Suppose that in a reading tree there is exactly one edge emanating from exis- tential spider node s, which targets existential spider node t. Then the labels s and t can be swapped.


d1
d2


transpose existential node labels transpose existential
node labels


s	t	t	s
		

Fig. 13. Transposing existential node labels

Example 3.9 The readings of d1 and d2 in figure 13 are equivalent:
∃s ∈ A(s.f ⊆ B ∧ ∃t ∈ s.f (t.g = s)),
and ∃t ∈ B(∃s ∈ A(s = t.g ∧ t ∈ s.f ⊆ B)).

Move branch
Suppose that in a reading tree there are edges from spider p to spider q and from p to an existential spider s. Then the move branch rule deletes the edge from p to q and adds an edge from s to q.

d1	d2

move branch





s	t	s	t




Fig. 14. Moving a tree branch


Example 3.10 The readings of d1 and d2 in figure 14 differ only by the placing of brackets

∀x ∈ A(x.f ⊆ B ∧ ∃s ∈ x.f (∃t ∈ B − x.f ) ∧ ∀y ∈ A ∩ B(y.g = ∅))

∀x ∈ A(x.f ⊆ B ∧ ∃s ∈ x.f (∃t ∈ B − x.f ∧ ∀y ∈ A ∩ B(y.g = ∅)))
Rules which are diagrammatic and structural
The rules in this section change the syntax within unitary parts of a diagram, as well as the propositional-logic structure of the diagram.

Excluded middle
The excluded middle rule allows us to explicitly express the fact that a set either has no additional elements or some additional elements.


d1	


excluded middle
d2 = (d3 or d4)	






Fig. 15. An example of the excluded middle rule

Example 4.1 In figure 15, d1 and d2= d3 ∨ d4 are semantically equivalent. They have readings ∃s ∈ A and ∃s ∈ A(A − s = ∅) ∨ ∃s ∈ A(∃t ∈ A(t /= s)).
The precondition for the excluded middle rule is that the zone it is applied to can be described without reference to a universal spider.

d1 = (d2 or d3)
d4


Fig. 16. Excluded middle does not apply

Example 4.2 In figure 16, the readings of d1 and d4 are


	
∀x ∈ A(x.f ⊆ A ∧ x.f = ∅) ∨ ∀x ∈ A(x.f ⊆ A ∧ ∃s ∈ x.f ), and ∀x ∈ A(x.f ⊆ A).
The diagram d4 can be obtained from d1 by erasing shading from d2, deleting the spider s in d3 and using idempotency of ∨.
Diagrams d2 and d3 only differ from d4 by the addition of extra shading and an extra existential spider in x.f . But the disjunction d1= d2 ∨d3 cannot be deduced from d4, because, while it is true that, for each x, (x.f = ∅) or (∃s ∈ x.f ) holds, it is not necessarily the case that (x.f = ∅) for every x, or (∃s ∈ x.f ) for every x.
Split existential spider

d2 = (d3 or d4)
Fig. 17. Splitting an existential spider

Example 4.3 The readings of d1 and d2 in figure 17 are ∃s ∈ A(s.f = B) and ∃s ∈ C(s.f = B) ∨∃s ∈ A−C(s.f = B). These statements are equivalent (because C ⊆ A from the plane tiling condition).
An existential spider s can be split (see figure 17) provided that whenever s is ordered after a universal spider x in the reading tree, the spiders s and x are independent in the diagram.

d1 = (d2 or d3)

d4

/
x	s


Fig. 18. Split spider is not always applicable

Example 4.4 The readings of d1 and d4 in figure 18 are


	
∀x ∈ A(∃s ∈ B(x.f = s)) ∨ ∀x ∈ A(∃s ∈ A ∩ B(x.f = s)),

and ∀x ∈ A(∃s ∈ A(x.f = s)).
These two sentences are not equivalent, but d1 entails d4. The spider s is ordered after universal spider x in the tree but s and x are dependent, pre- venting us from reasoning from d4 to d1. 6 We can reason from d1 to d4 by applying add existential spider foot to s in both d2 and d3, followed by an application of idempotency of ∨.

Derived rules for tool-building
The rules in the previous section were designed to make only small changes to the diagram syntax and have stringent preconditions. However, we anticipate that users of the constraint diagram notation will prefer to use rules which can be applied more widely. If, for example, a user wishes to delete a given contour from a diagram, it is not very useful to refuse that request simply because of some failed precondition. A better response would be to automate the application of other rules like delete existential spider or delete arrow in order to prepare the diagram so that it complies with the relevant preconditions, where possible.
It is a non-trivial task to determine which syntactic elements need to be edited or deleted, and in which order, to prepare a diagram for a rule applica- tion. We do not expect this task to be undertaken by the users of the notation. It is intended to be implemented as part of a software tool for reasoning with constraint diagrams. The burden of work is with the tool-builders, and the users can simply apply rules using the tool which invokes algorithms behind the scenes.

d1	d2
s	t	x

Fig. 19. Iterative delete spider

6 In the spider diagram system, a useful step in proof strategies and rule development was the transformation of diagrams into α-diagrams in which all spiders have only one foot. The precondition on split existential spider prevents us from guaranteeing that every diagram can be transformed into an α-diagram.


Example 5.1 In figure 19, we revisit example 3.5. Spider s cannot be deleted from d1 using the delete existential spider rule defined in section 3.3 because s is ordered before x in the tree and s has a foot in the domain of x. To enable deletion of s, we have to delete x. In turn, in order to delete x, we have to delete f .


d1	d2






delete arrow (iterative)
/




x	s	t	x




Fig. 20. Iterative delete arrow

Example 5.2 In figure 20 we revisit example 3.7. The preconditions of delete arrow as defined in section 3.4 prevent us from deleting g, because it would introduce new dependence between spiders x and t in the diagram, but these are unordered in the tree. However, we can apply the move branch rule which orders x and t in the tree and then we can delete g.

Conclusion and further work
This work is progress towards the development of a sound and complete di- agrammatic reasoning system which is sufficiently expressive to be useful for software modelling. We highlight issues and subtleties which recur as valid rules are developed.
The following semantic issues will recur in the development of reasoning rules for other logical systems which explicitly express quantification diagram- matically:
insufficient nesting of quantifiers,
enlarged domain of quantification,
property strengthening,
empty domains.


The rules we have described have been given syntactic preconditions designed to resolve these semantic issues. The syntactic conditions may change from one rule to another, even if they are addressing the same semantic issue.
There are conflicting pressures concerning the simplicity of the rules. One group of users, those who are reasoning about the system (e.g. proving sound- ness, or generating automatic proof-writers) would like to use rules which make minimal changes to diagram syntax. However, such rules need to have stringent preconditions and can rarely be applied to a diagram.
A second group of users reason with diagrams to formulate software spec- ifications. A practical software tool would allow such users to apply rules easily. The software should be responsible for offering rules only when pre- conditions apply, and be able to provide conclusion diagrams which conform to post-conditions. For these users, the most useful kinds of rules have weak preconditions and complex postconditions. To balance these conflicting re- quirements, we developed two classes of rules: simple and iterative.
Future plans include defining reasoning rules in terms of graph transfor- mations, which may enable us to make use of existing results and tooling environments (see, for example, [1]) to conduct reasoning with constraint di- agrams.

References
AGG: The Attributed Graph Grammar System. Chief researcher: Gabi Taentzer. Web page
http://tfs.cs.tu-berlin.de/agg/, accessed 12th October 2004.
A. Fish, J. Flower and J. Howse. A reading algorithm for constraint diagrams. Symp. on human-centric computing languages and environments, pages 161–168, IEEE, 2003.
A. Fish, J. Flower and J. Howse. The semantics of augmented constraint diagrams. Submitted to JVLC, 2004.
E. Hammer. Logic and Visual Information. CSLI Publications, 1995.
J. Howse, F. Molina and J. Taylor. SD2: A sound and complete diagrammatic reasoning system.
Symp. on Visual Languages, pages 127–136, IEEE, 2000.
S. Kent. Constraint diagrams: Visualising invariants in object oriented models. OOPSLA97, SIGPLAN Notices, vol. 32, no. 10, pages 327–341, ACM, 1997.
S.-J. Shin. The Logical Status of Diagrams. Cambridge University Press, 1994.
G. Stapleton, J. Howse, J. Taylor and S. Thompson. What can spider diagrams say? International conference on the theory and application of diagrams, LNAI 2980, pages 122–127, Springer-Verlag, 2004.
N. Swoboda. Implementing Euler/Venn reasoning systems. In Diagrammatic Representation and Reasoning, M. Anderson, B. Meyer and P. Oliver, eds, pages 371–386, Springer-Verlag, 2001.
