

Electronic Notes in Theoretical Computer Science 240 (2009) 43–60
www.elsevier.com/locate/entcs

Formal Verification of Graph Grammars using Mathematical Induction
Simone Andr´e da Costa1
Departamento de Inform´atica Universidade Federal de Pelotas Pelotas, Brazil
Leila Ribeiro2
Instituto de Informa´tica Universidade Federal do Rio Grande do Sul
Porto Alegre, Brazil

Abstract
Graph grammars are a formal description technique suitable for the specification of distributed and reactive systems. Model-checking of graph grammars is currently supported by various approaches. However, in many situations the use of this technique can be very time and space consuming, hindering the verification of properties of many systems. This work proposes a relational and logical approach to graph grammars that allows formal verification of systems using mathematical induction. We use relational structures to define graph grammars and first-order logic to model graph transformations. This approach allows proving properties of systems with infinite state-spaces.
Keywords: Graph grammars, mathematical induction, formal verification.


Introduction
Reactive systems are usually characterized by several autonomous components that run in parallel and interact with each other, for example, via messages. The ver- ification of such systems is much more complex than sequential ones, since the interactions of independent components affect the behaviour of the whole system. To ensure that a reactive system works as expected, in addition to knowing that each component provides the required functionality, we also have to know how each component reacts to outside influences and how each component influences its out- side.

1 Email: scosta@inf.ufrgs.br
2 Email: leila@inf.ufrgs.br

1571-0661 © 2009 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2009.05.044

Graph grammars are a formal language suitable for the specification of reactive systems [11,18]. The basic idea of this formalism is to model the states of a system as graphs and describe the possible state changes as rules (whose left and right-hand sides are graphs). The behaviour of the system is expressed via applications of these rules to graphs, describing the current states of the system.
One way of analyzing graph grammar models is through model-checking. In
[10] a translation of a specific class of graph grammars, Object Based Graph Gram- mars (OBGG), to PROMELA was defined, which allows verification using the SPIN model checker [14]. [15] presents an approach to verify a timed extension of graph grammars, allowing the automatic verification of real-time systems using the UP- PAAL model checker [4]. Different approaches for model-checking other kinds of graph grammars can be found in [17].
Although model checking is an important analysis method, it has as disad- vantage the need to build the complete state space, which can lead to the state explosion problem. Much progress has been made to deal with this difficulty, and a lot of techniques have increased the size of the systems that could be verified [5]. Baldan and Ko¨nig proposed [2] approximating the behavior of (infinite-state) graph transformation systems by a chain of finite under- or over- approximations, at a specific level of accuracy of the full unfolding [1] of the system. However, as [12] emphasizes, these approaches that derive the model as approximations can result in inconclusive error reports or inconclusive verification reports.
Besides model checking, theorem proving [19] is another well-established ap- proach used to analyze systems for desired properties. Theorem proving [6] is a technique where both the system and its desired properties are expressed as formu- las in some mathematical logic. A logical description defines the system, establishing a set of axioms and inference rules. The process consists in finding a proof of the re- quired property from the axioms or intermediary lemmas of the system. In contrast to model checking, theorem proving can deal directly with infinite state spaces and it relies on techniques such as structural induction to prove over infinite domains. The use of this technique may require interaction with a human; however, the user often gains very useful perceptions into the system or the property being proved.
Each verification technique has arguments for and against its use, but we can say that model-checking and theorem proving are very complementary. Most of the existing approaches use model checkers to analyze properties of computations. Properties about reachable states are handled, if at all possible, only in very re- stricted ways. Our work aims to provide a means to prove structural properties of reachable graphs using the theorem proving technique. In order to accomplish this goal, we propose a logical approach to graph grammars that allows the ap- plication of the mathematical induction technique to analyze systems with infinite state-spaces. We have defined graph grammars using relational structures and used first-order logic to model rule applications. The approach proposed here is inspired by Courcelle’s research about logic and graphs [8].
Courcelle investigates in various papers [7,8,9] the representation of graphs and hypergraphs by relational structures as well as the expressiveness of its properties by

logical languages. In [7] the description of graph properties and the transformation of graphs in monadic second-order logic is proposed. However, these works are not particularly interested in effectively verifying the properties of graph transformation systems (GTSs). On the other hand, other authors have investigated the analysis of GTSs based on relational logic or set theory. Baresi and Spoletini [3] explore the formal language Alloy to find instances and counterexamples for models and GTSs. In fact, with Alloy, they only analyze the system for a finite scope, whose size is user-defined. Strecker [21], aiming to verify structural properties of GTSs, proposes a formalization of graph transformations in a set-theoretic model. Nevertheless, this work does not use a logical approach and it just presents a glimpse on how to reason about graph transformations.
The rest of the paper is organized as follows. In Section 2, we introduce graph grammars according to the SPO-approach [20]. In Section 3 we present our rep- resentation of graph grammars by relational structures and in Section 4 we use first-order formulas to define rule applications as graph grammar transformations. Finally, in Section 5 we use our approach to verify properties of systems specified in graph grammars through mathematical induction. Final remarks are given in Section 6.

Graph Grammar
Graph-based formal description techniques often present a friendly means of carry information in a compact and understandable way, and so can be easily followed by non-specialists on formal specification methods. Graph grammars generalize Chomsky grammars from strings to graphs: it specifies a system in terms of states, described by graphs, and state changes, described by rules having graphs at the left- and right-hand sides.
Definition 2.1 [Graph, Graph morphism] A graph G = (V ertG, EdgeG, srcG, trgG) consists of a set of vertices V ertG, a set of edges EdgeG, a source and a target function srcG, trgG : EdgeG → V ertG. We consider V ertG ∩ EdgeG = ∅. A (partial) graph morphism g : G → H from a graph G to a graph H is a tuple g = (gV ert, gEdge) consisting of two partial functions gV ert : V ertG → V ertH and gEdge : EdgeG → EdgeH which are weakly homomorphic, i.e., gV ert ◦ srcG ≥ srcH ◦gEdge and gV ert◦trgG ≥ trgH ◦gEdge. 3 A morphism g is called total/ injective if both components are total/ injective, respectively.
The weak commutativity used above means that everything that is preserved (mapped) by the morphism must be compatible. The term “weak” is used because the compatibility is just required on preserved items, not on all items. A typed graph is a graph equipped with a morphism tG to a fixed graph of types.
Definition 2.2 [Typed Graph, Typed Graph Morphism] A typed graph GT is a tuple GT = (G, tG,T ), where G and T are graphs and tG : G → T is a total graph

3 ≥ is the usual relation between partial functions meaning “more defined than”.

morphism called typing morphism. A typed graph morphism between graphs GT and HT with type graph T is a morphism g : G → H such that tG ≥ tH ◦ g (that is, g may only map elements of the same type).
A rule specifies a possible behaviour of the system. It consists of a left-hand side, describing items that must be present in a state to enable the rule application and a right-hand side, expressing items that will be present after the rule application. We require that rules do not collapse vertices or edges (are injective) and do not delete vertices.
Definition 2.3 [Rule] Let T be a graph. A rule with respect to T is an injective typed graph morphism α : LT → RT from a typed graph LT to a typed graph RT , such that αV ert : V ertL → V ertR is a total function on the set of vertices.
A graph grammar is composed of a type graph, characterizing the types of vertices and edges allowed in a system, an initial graph, representing the initial state of a system and a set of rules, describing the possible state changes that can occur in a system.
Definition 2.4 [Graph Grammar] A (typed) graph grammar is a tuple GG = (T, G0, R), such that, T is a type graph (the type of the grammar), G0 is a graph typed over T (the initial graph of the grammar) and R is a set of rules with respect to type T .
Given a rule α and a state G, we say that this rule is applicable in this state if there is a match m, that is, an image of the left-hand side of the rule in the state. The operational behaviour of a graph grammar is defined in terms of rule applications.
Definition 2.5 [Match, Rule Application] Given a rule α : LT → RT with respect to a type graph T , a match of a rule α in a typed graph GT is a total typed graph morphism m : LT → GT which is injective on edges. A rule application

(α,m)
=⇒ H
, or the application of α to a typed graph GT
at match m, generates a

typed graph HT = (H, tH ,T ), with H = (V ertH, EdgeH , srcH, trgH ), as follows.
Resulting graph H. The set of vertices and edges are defined by
V ertH = V ertG  (V ertR − αV ert(V ertL))
EdgeH = (EdgeG − mEdge(EdgeL))  EdgeR
and the source and target functions are given by
e ∈ (EdgeG − mEdge(EdgeL)) ⇒ srcH(e)= srcG(e), trgH (e)= trgG(e)
e ∈ EdgeR ⇒ srcH(e)= m(srcR(e)), trgH (e)= m(trgR(e)) where m : V ertR → V ertH is defined by
m(αV ert(v)) = mV ert(v) if v ∈ V ertL m(v)= v otherwise

Typing morphism. The morphism tH = (tH
H
Edge
) from H to T is specified as

v ∈ V ertG ⇒ tH v ∈ (V ertR − αV ert(V ertL)) ⇒ tH
e ∈ (EdgeG − mEdge(EdgeL)) ⇒ tH
(v) = tG
(v) = tR
(e) = tG
(v)
(v)
(e)

Edge
e ∈ EdgeR ⇒ tH
Edge
= tR
(e)

Intuitively, the application of α to G at the match m first removes from G the image of the edges in L. Then, graph G is extended by adding the new nodes in R (i.e., the nodes in V ertR − αV ert(V ertL)) and the edges of R. This construction can be described by a pushout in a suitable category of typed graphs.
Working Example: The Token Ring Protocol
We illustrate the use of graph grammars specifying the token-ring protocol. This protocol is used to control the access of various stations to a shared transmission medium in a ring topology network [22]. According to the protocol, a special bit pattern, called the token, is transmitted from station to station in only one direc- tion. When a station wants to send some content through the network, it waits for the token, holds it, and sends the message (data frame) to the ring. The message circulates the ring and all stations may copy its contents. When the message com- pletes the cycle, it is received by the originating station, which then removes the message from the ring and sends the token to the next station, restarting the cycle. If only one token exists, only one station may be transmitting at a given time. Here we will model a token-ring protocol in an environment in which new stations may be added at any time.
Figure 1 illustrates the graph grammar for the example. The type graph T de- fines a single type of node Node, and five types of edges Msg (Message), Tok (Token), Nxt (Next), Act (Active Station) and Stb (Standby Station). Node represents a net- work station and an edge Msg defines a frame of data. The stations are connected by edges of type Nxt. Tok (the token) represents a special signal which enables the station to start the transmission. Every station is either an active station (Act), meaning that the station is transmitting a message on the network, or a standby station (Stb). There can be only one active station on a ring at a time. The initial graph G0 defines a ring with three nodes named N01, N02, N03. Initially the Token (Tok01) is at station N01 and no station is transmitting information on the network (all the stations have a Stb edge).
The behaviour of the protocol is modeled by the rules. A standby node with a Tok edge may retain this edge and send a message, becoming an active station (rule α1), or pass the token to the next node (rule α2). When a message is received by a standby node, rule α3 can be applied and Msg is passed to the next node. If the receiving node is an active station, then rule α4 can be applied, removing Msg from the ring and sending the token (Tok edge) to the next station. Rule α5 is applied to insert a new station into the ring. This model has an infinite state-space and generates infinite computations.


	



Fig. 1. Type Graph, Initial Graph and Rules
Representation of Graph Grammars by Relational Structures
Aiming to define a theory that allows the formulation of properties and the develop- ment of proofs for systems specified as graph grammars, we propose a representation of graph grammars by relational structures (i.e., by structures with relations only). A relational structure [8] is a tuple formed by a set and by a family of relations over this set.
Definition 3.1 [Relational Structures] Let R be a finite set of relation symbols, where each R ∈ R has an associated positive integer called its arity, denoted by ρ(R). An R-structure is a tuple S = ⟨DS, (RS)R∈R⟩ such that DS is a possible empty set called the domain of S and each RS is a ρ(R)-ary relation on DS, i.e., a subset of Dρ(R). R(d1,... , dn) holds in S if and only if (d1,... , dn) ∈ RS, where d1,... , dn ∈ DS. The class of R-structures is denoted by STR(R).
We start by defining a relational structure to model graphs, and establishing a relational representation for graph morphisms, typed graphs and rules, which will later be used to build the relational structure associated to a graph grammar. Due to space limitations, proofs about the well-definedness of the relational representations were omitted. A relational structure representing a graph G is a tuple composed of a set, the domain of the structure, representing all vertices and edges of G and by two finite relations: a unary relation, vertG, defining the set of vertices of G and a ternary relation incG representing the incidence relation between vertices and edges of G.
Definition 3.2 [Relational Structure Representing a Graph] Let Rgr = {vert, inc}

be a set of relations, where vert is unary and inc is ternary. Given a graph G = (V ertG, EdgeG, srcG, trgG), a relational structure representing G is a Rgr- structure |G| = ⟨DG, (RG)R∈Rgr ⟩, where:
DG = VG ∪ EG is the union of sets of vertices and edges of G, respectively:
V ertG = VG and EdgeG = EG. We also require that VG ∩ EG = ∅;
vertG ⊆ VG, with x ∈ vertG iff x ∈ V ertG;
incG ⊆ EG × VG × VG, with (x, y, z) ∈ incG iff x ∈ EdgeG ∧ srcG(x) =
y ∧ trgG(x)= z;
Example 3.3 The typed graph G0 depicted in Figure 1 can be defined by the relational structure |G0| = ⟨V ertG0 ∪ EdgeG0, {vertG0, incG0}⟩, where vertG0 = {N 01,N 02,N 03}, incG0 = {(T ok01, N 01, N 01), (Stb01, N 01, N 01), (Nxt01, N 01, N 02), (Stb02,N 02,N 02), (Nxt02, N 02, N 03), (Stb03,N 03,N 03), (Nxt03,N 03,N 01)}.
The relational representation of a graph morphism g from a graph G toa graph H is obtained through two binary relations: one to relate vertices (gV ) and other to relate edges (gE). Since these relations just map vertices and edges names, we have to impose some restrictions to ensure that they represent a morphism. The existence condition states that if two vertices are related by gV then the first one must be a vertex of G and the second one a vertex of H, and if two edges are related by gE, then the first one must be an edge of G and the second one an edge of H. The commutativity condition assures that the mapping of edges preserves the mapping of source and target vertices.
Definition 3.4 [Relational Graph Morphism] Let |G| = ⟨VG ∪ EG, {vertG, incG}⟩ and |H| = ⟨VH ∪ EH, {vertH , incH }⟩ be Rgr-structures representing graphs. A relational graph morphism g from |G| to |H| is defined by a set g = {gV , gE} of binary relations where:
gV ⊆ VG × VH is a partial function that relates vertices of |G| to vertices of |H|;
gE ⊆ EG × EH is a partial function that relates edges of |G| to edges of |H|; such that the following conditions are satisfied:
Existence Conditions. ∀x, x' [ gV (x, x')] ⇒ vertG(x) ∧ vertH(x'); and
∀x, x' [ gE(x, x')] ⇒ ∃y, y', z, z'[incG(x, y, z) ∧ incH(x', y', z') ];
Commutativity Condition. ∀x, y, z, x', y', z',
[gE(x, x') ∧ incG(x, y, z) ∧ incH(x', y', z') ⇒ gV (y, y') ∧ gV (z, z')].
g is called total/ injective if relations gV and gE are total/ injective functions, respectively.
A typing morphism is a graph morphism that has the role of typing all elements of a graph G over a graph T . Thus, its relational definition is the same as graph morphisms, with the restriction that both relations must represent total functions.
Definition 3.5 [Relational Typing Morphism] Let |G| and |T | be Rgr-structures

representing graphs. A relational typing morphism tG from |G| over |T | is defined by a total relational graph morphism tG = {tGV , tGE } from |G| to |T |.
Example 3.6 The relational typing morphism from |G0| over |T |, both illustrated in Figure 1, is defined by tG0 = {tG0V , tG0E }, with tG0V = {(N 01,N ode), (N 02,N o- de), (N 03, Node)} and tG0E  = {(T ok01,T ok), (Stb01, Stb), (Stb02, Stb), (Stb03,
Stb), (Nxt01,N xt), (Nxt02,N xt), (Nxt03,N xt)}.
The relational representation of a typed graph GT = (G, tG,T ) is defined by two Rgr-structures representing G and T and by a relational typing morphism, which must satisfy a condition that guarantees that it defines the same typing morphism tG.
Definition 3.7 [Relational Representation of a Typed Graph] Given a typed graph

GT = (G, tG,T ) with tG = (tG
G
Edge
), a relational representation of GT is

given by a tuple |GT | = ⟨|G|, tG, |T |⟩ where:
|G| and |T | are Rgr-structures representing G and T respectively;
tG = {tGV , tGE } is a relational typing morphism from |G| over |T | that satisfies

the conditions: (x, y) ∈ tGV
G
V ert
(x) = y and (x, y) ∈ tGE
G
Edge
= y.

A relational graph morphism is also the basis of the relational definition of a rule from a graph L to a graph R. Since both graphs mapped by a rule are typed over the same graph T , a compatibility condition assures that the mappings of vertices and edges preserve types. Besides, rules must not collapse vertices or edges, nor delete vertices.
Definition 3.8 [Relational Rule] Let |L|, |R| and |T | be Rgr-structures represent- ing graphs and tL = {tLV , tLE } and tR = {tRV , tRE } be relational typing morphisms from |L| and |R| over |T |, respectively. A relational rule |α| from |L| to |R| is defined by an injective relational graph morphism |α| = {αV , αE}, such that the following conditions are satisfied:
αV is total;
Compatibility Condition. The mapping of vertices and edges preserves types:

∀x, x',y [αV (x, x') ∧ tL (x, y) ⇒ tR
V
∀x, x',y [αE(x, x') ∧ tL (x, y) ⇒ tR
(x', y)],
(x', y)].

E	E
Example 3.9 The relational rule α1 illustrated in Figure 1 is defined by |α1| =
{α1V , α1E }, where α1V  = {(N 11,N 13), (N 12,N 14)} and α1E = {(T ok11,T ok12),
(Nxt11,N xt12)}. The relational typing morphisms from L1 and R1 over T are re- spectively given by tL1V = {(N 11,N ode), (N 12,N ode)}, tL1E = {(T ok11,T ok), (Stb11, Stb), (Nxt11,N xt)} and tR1V  = {(N 13,N ode), (N 14,  Node)}, tR1E  =
{(T ok12, Tok), (Act11, Act), (Nxt12,N xt), (Msg11,M sg)}.
Given a rule α : LT → RT , its relational representation is given by the relational representation of typed graphs LT and RT , together with a relational rule which must define the same morphism given.

Definition 3.10 [Relational Representation of a Rule] Given a rule α : LT → RT ,
α = (αV ert, αEdge), a relational representation of α is given by a tuple ⟨|LT |, |α|,
|RT |⟩ where:
|LT | = ⟨|L|, tL, |T |⟩ and |RT | = ⟨|R|, tR, |T |⟩ are relational representations of typed graphs LT and RT , respectively;
|α| = {αV , αE} is a relational rule from |L| to |R| that satisfies the following conditions: (x, y) ∈ αV iff αV ert(x)= y and (x, y) ∈ αE iff αEdge(x)= y.

Given a graph grammar GG = (T, G0, R), we define a relational structure |GG| associated to it as a tuple composed of a set and a collection of relations. The set describes the domain of the structure. The relations define the type graph, the initial graph and the rules. The type graph is defined by relations of a Rgr- structure representing T . The initial graph G0, the left- and right-hand sides of rules are specified by relations of Rgr-structures representing graphs, which are typed over T by relational typing morphisms. Relational rules map the graphs of left-hand side and right-hand side of rules.

Definition 3.11 [Relational Structure Associated to a Graph Grammar] Let RGG = {vertT , incT , vertG0, incG0, tGOV , tG0E , (vertLi, incLi, tLiV , tLiE , vertRi, incRi, tRiV , tRiE , αiV , αiE )i∈{1,...,n}} be a set of relation symbols. Given a graph grammar GG = (T, G0, R) where |R| = n, the RGG-structure associated to GG, denoted by |GG|, is the tuple ⟨DGG, (rGG)r∈R  ⟩ 4 where
DGG = VGG ∪ EGG is the set of vertices and edges of the graph grammar, where: VGG ∩ EGG = ∅, VGG = VT ∪ VG0 ∪ (VLi ∪ VRi)i∈{1,...,n} and EGG = ET ∪ EG0 ∪ (ELi ∪ ERi)i∈{1,...,n}.
vertT and incT model the type graph. They are the relations of a Rgr-structure
|T | = ⟨VT ∪ ET , {vertT , incT }⟩ representing graph T .
vertG0, incG0, tG0V and tG0E model the initial graph typed over T , i.e., they are the relations that compose the relational representation of G0T .
Each collection (vertLi, incLi, tLiV , tLiE , vertRi, incRi, tRiV , tRiE , αiV , αiE ) defines a rule:
vertLi, incLi, tLiV and tLiE model the left-hand side of the rule, i. e., they are the relations of the relational representation of LiT .
vertRi, incRi, tRiV and tRiE model the right-hand side of the rule, i. e., they are the relations of the relational representation of RiT .
αiV and αiE are relations of the set |αi| which defines a relational rule from
|Li| to |Ri|, such that the tuple ⟨|LiT |, |αi|, |RiT |⟩ is a relational representation of rule αi : LiT → RiT .



4 In order to simplify the reading we omit the subscript GG in relations.

Rule Applications as First-Order Definable Trans- ductions
In this section, inspired in the definition of monadic second-order definable transduc- tion, introduced in [8], we show how to define rule applications as graph grammar transformations. This approach will allow a graph grammar theory to be defined, which will be later used to verify properties of distributed and reactive systems.
A monadic second-order definable transduction [8] replaces for graphs the notion of finite automaton used for transformations of words or trees. It is defined through a tuple (ϕ, ψ, (θq )q∈Q) of monadic second-order formulas [13] that specifies a Q- structure T based on an R-structure S. The first formula of the tuple, ϕ, establishes a condition to be satisfied in order to make the transduction possible. The following formula ψ define the domain of the relation T . Finally, for each relation q ∈ Q, a formula θ defines the elements of the T domain that belong to the relation. In the original definition, it is possible to make k copies of the original structure S before redefining the relations q, to obtain the new structure T . Next, we propound the definition of first-order definable transductions (via first-order formulas) without copies of the original structure, which is enough to represent rule applications as graph-grammar transformations.
Definition 4.1 [First-Order Definable Transduction] Let R and Q be two finite ranked sets of relation symbols. Let W be a finite set of set variables (parameters) and FO(R, W) be the set of first-order formulas over R, with free variables in W. A (Q, R)-definition scheme is a tuple Δ = (ϕ, ψ, (θq )q∈Q), where ϕ ∈ FO(R, W ), ψ ∈ FO(R, W∪ {x1}) and θq ∈ FO(R, W ∪ {x1,... , xρ(q)}).
These formulas are intended to define a structure T in STR(Q) from a structure S in STR(R) in the following way: let S ∈ STR(R) and γ be a W-assignment in S, a Q-structure T with domain DT ⊆ DS is defined in (S, γ) by Δ if:
(S, γ) |= ϕ. Formula ϕ establishes a condition to be fulfilled so that the trans- lation is possible. I.e., T is defined only if ϕ holds true in S for some γ.
DT = {d ∈ DS | (S, γ, d) |= ψ}. Assuming that (i) is satisfied, formula ψ defines the domain of T as the set of elements in the S domain that satisfy ψ for γ.

for each q ∈ Q, qT = {(d1,... , dt) ∈ Dt
| (S, γ, d1,... , dt) |= θq}, where

t = ρ(q). Formulas θq define the relation qT for each q ∈ Q.
Since T is associated in a unique way with S, γ and Δ whenever it is defined (when- ever (S, γ) |= ϕ) we can use the functional notation defΔ(S, γ) for T . A trans- duction defined by Δ is the relation defΔ := {(S, T ) | T = defΔ(S, γ) for some W-assignment γ in S}⊆ STR(R) × STR(Q). f ⊆ STR(R) × STR(Q) is a FO- definable transduction, if it is equal to defΔ, for some (Q, R)-definition scheme Δ. In the case where W = ∅ we say that f is definable without parameters.
A rule application may be described by a FO-definable transduction on rela- tional structures associated to graph grammars. The result of the transduction

over a graph grammar is another graph grammar whose initial state corresponds to the result of the application of a rule αi at a match m to the initial state of the original grammar. The other components of the grammar remain unchanged (i.e., the resulting grammar has the same type graph and rules of the original one). In order to define rule application as a FO-definable transduction, we first introduce the relational representation of a match. A relational match of a rule α (from L to R) in a graph G is a total relational graph morphism (from L to G) which is injec- tive on edges and preserves types (satisfies the match compatibility condition). The relational representation of a match m : LT → GT is then defined by two relational structures representing typed graphs LT and GT together with a relational match that must define the same morphism m given.
Definition 4.2 [Relational Match] Let |α| from |L| to |R| be a relational rule, where tL = {tLV , tLE } and tR = {tRV , tRE } are the relational typing morphisms from |L| and |R| over |T |, respectively. Let |G| be an Rgr-structure representing a graph G typed over |T | by the relational typing morphism tG = {tGV , tGE }. A relational match |m| of a rule |α| in |G| is defined by a total relational graph morphism |m| = {mV , mE} from |L| to |G|, such that the following conditions are satisfied:
mE is injective;
Match Compatibility Condition. The mapping of vertices and edges preserve

types:	∀x, x',y [mV (x, x') ∧ tL
(x, y) ⇒ tGV
(x', y)],

∀x, x',y [mE(x, x') ∧ tL
(x, y) ⇒ tGE
(x', y)].

Definition 4.3 [Relational Representation of a Match] Given a match m : LT →
GT , m = (mV ert, mEdge), a relational representation of m is given by a tuple
⟨|LT |, |m|, |GT |⟩ where:
|LT | = ⟨|L|, tL, |T |⟩ and |GT | = ⟨|G|, tG, |T |⟩ are relational representations of typed graphs LT and GT , respectively;
|m| = {mV , mE} is a relational match from |L| to |G| that satisfies the following conditions: (x, y) ∈ mV iff mV ert(x)= y and (x, y) ∈ mE iff mEdge(x)= y.
Now, a rule application is represented by a definable transduction (i.e., by a tuple of first-order formulas) that defines a RGG-structure |GG|' (i.e., a graph grammar) based on another RGG-structure |GG|. Before applying the transduction, we must first fix a relational rule |αi| of |GG| and a relational match |m| of |αi| in |G0| (initial graph of |GG|). Then, the RGG-definition scheme Δ = (ϕ, ψ, (θq )q∈RGG ) defines the relational structure |GG|' from |GG|, which corresponds to the same grammar, excepted that |G0|' (initial state of |GG|') represents the result of the application of |αi| at match |m| in |G0|. In Δ, ϕ ensures that |m| effectively defines a match, ψ defines the domain of the resulting grammar (the same of original grammar) and each formula θq, q ∈ RGG, defines the elements that will be present in relations qGG' , q ∈ RGG of the resulting grammar. In fact, the collection (θq) defines the structure associated to graph grammar |GG|'. Since the type graph and the rules remain unchanged, the formulas that define these components are constructed in

the obvious way (they are defined by relations of the original grammar). Formulas

θvertG0 , θincG0 , θtG0
, θtG0
that define the resulting graph of the rule application

are specified according to Definition 2.5. The following table presents the intuitive
meaning and the equivalent notation of the formulas used in θ specifications.


Definition 4.4 [Rule Application as FO-Definable Transduction] Let |GG| be a relational structure associated to a graph grammar with an additional requirement: the sets of edges and vertices of graphs |T |, |G0|, |Li| and |Ri| are disjoint. Given a relational rule |αi| = {αiV , αiE } from |Li| to |Ri| and a relational match |m| =
{mV , mE} of |αi| in |G0|, the transduction that maps a graph grammar |GG|
to a graph grammar |GG|', where |G0|' (initial state of |GG|') corresponds to the result of the application of rule |αi| at match |m| = {mV , mE} in |G0| (initial state of |GG|), is defined by Δ= (ϕ, ψ, (θq )q∈RGG ), with W = ∅, where:
ϕ expresses that |m| = {mV , mE} defines a relational match of |αi| in |G0|.
ψ is the Boolean constant true (same domain).
θvertT , θincT are, respectively, the formulas vertTGG (x) and incTGG (x, y, z) (same type graph).
θvertG0  is the formula vertG0GG (x) ∨ nvertRiGG (x) (see next table).
θincG0 (x, y, z) is the formula nincG0GG (x, y, z) ∨ nincRiGG (x, y, z).
θtG0 (x, t) is the formula nvertG0GG (x, t) ∨  nvertRiGG (x) ∧ tRiV GG (x, t) .

θtG0E (x, t) is the formula ntG0E GG (x, t) ∨ tRiE GG (x, t).

θvertLi , θincLi , θtLi
, θtLi
, θvertRi , θincRi , θtRi
, θtRi
, θαi
, θαi
are respectively

the formulas vertLiGG (x), incLiGG (x, y, z), tLiV GG (x, y), tLiE GG (x, y), vertRiGG (x), incRiGG (x, y, z), tRiV GG (x, y), tRiE GG (x, y), αiV GG (x, y) and αiE GG (x, y), for i = 1 .. n (same rules).
Proposition 4.5 The rule application as a FO-deﬁnable transduction is well- deﬁned.
Proof (Sketch) Let |GG|' be the result of the transduction applied to graph gram- mar |GG| corresponding to the application of relational rule |αi| at relational match
|m|. Considering that the given rule |αi| and the given match |m| are the relational representations of αi : LiT → RiT and m : LiT → G0T , respectively, and consider- ing HT = (H, tH ,T ) to be the typed graph obtained through the application of αi to graph G0T at match m (according to Definition 2.5) we have to show that:

vertT
' and incT	' are the relations of a Rgr-structure |T |' = ⟨V ' ∪ E' ,

GG	GG	T	T
{vertT	' , incT	' }⟩ representing graph T = (V ertT , EdgeT , srcT , trgT ).

vertG0	' and incG0
' are the relations of a Rgr-structure |G0|' = ⟨V ' ∪ E' ,

GG	GG
G0	G0

{vertG0	' , incG0	' }⟩ representing graph H = (V ertH, EdgeH , srcH, trgH).

tGOV
'	and tG0E	'	are from the set tG0
'	such that the tuple

GG	GG	GG
⟨|G0|', tG0	' , |T |'⟩ is a relational representation of the typed graph HT =
GG
(H, tH ,T ).
The graph grammar that results from the application of rule |αi| at match |m| in
|G0| (|GG| initial state) has its initial graph defined by relations vertT	' , incT	' ,
GG	GG

vertG0
' , incG0
' , tG0
' and tG0
' , whose elements are those of |GG|' domain

GG	GG
V GG
E GG

(same |GG| domain) that satisfy, respectively, the formulas θvertT , θincT , θvertG0 ,

θincG0 , θtG0
and θtG0
.  Such θ formulas are defined by |GG| relations, which

compose, according to Definition 3.11, relational representations of graphs, typed
graphs or rules. Following Definitions 3.2, 3.7 and 3.10 these relations will define the respective graphs, typed graphs and rules of the original grammar. We can also notice that the formulas θ that define the resulting graph are specified according to graph HT described in Definition 2.5. Consequently, the elements that satisfy the formulas will define the relational representation of HT .	 

Verifying Properties
The logical approach previously detailed allows the use of mathematical induction technique to verify properties of systems specified in graph grammars. Inspired by the standard procedure of Isabelle [16], we lay the foundation for future creation of a graph grammar theory that must define a data type named reachable graph and a standard library, which may be used to formulate properties and develop proofs. The data type reachable graph (reach gr ) of a graph grammar may be defined with two constructors, one for the initial graph G0 and another one for the operator ap(αi, m) that applies the rule αi at match m to a reachable graph

(obtaining a graph G0' according to the transduction defined in Section 4). The standard library must provide a collection of (recursive) functions that can be used to enunciate and prove desirable properties. For instance, we define two functions: one to determine the types of edges of a reachable graph and another to indicate if a reachable graph has a ring topology. Let |GG| be the relational structure associated to a graph grammar. 5
Types of Edges of a Reachable Graph. The types of edges of a reachable graph are recursively defined by:
tipE G0= {(x, t) | tG0E (x, t)}	(1)
tipE ap(αi, m) g = {(x, t) | tRiE (x, t) ∨ [(x, t) ∈ tipE g ∧ ∄w mEαi (w, x)]}	(2)
That is, if we consider the initial graph (1), typing is given by the relation tG0E of the relational structure. If we consider a graph obtained from applying rule αi at match m = {mVαi , mEαi } to graph g (2), the type of an edge is either the type of edges of right-hand side of the rule or a type of edge of graph g (in the latter case, the edge can not be image of the match).
Ring Topology in a Reachable Graph. Initially, we define the transitive closure

of edges of type t in a graph G, denoted by TCt
, by:

t
∀a, x, y, z [incG(a, x, y) ∧ tGE (a, t) → (x, y) ∈ TC	] ∧

[(x, y) ∈ TCt
∧ (y, z) ∈ TCt
→ (x, z) ∈ TCt	]

Then, we recursively define the function that indicates if a reachable graph has a ring topology of edges of type t:


Ringt G0 ≡ ∀x [vertG0(x) → (x, x) ∈ TCt
] ∧	(1’)

∧∀a, b, x, y, z [incG0(a, x, y) ∧ tG0E (a, t) ∧ incG0(b, x, z)∧
∧ tG0E (b, t) → a = b] ∧	(2’)

∧∀x, z [vertG0(x) ∧ vertG0(z) → (x, z) ∈ TCt
]	(3’)

Ringt ap(αi, m) g ≡ Ringt g ∧	(4’)
∧∀a, x, y, z, w [incLi(a, x, y) ∧ tLiE (a, t) ∧ αiV (x, z)∧

∧ αiV
(y, w) → (z, w) ∈ TCt
] ∧	(5’)

∧∀a, b, x, y, z [incRi(a, x, y) ∧ tRiE (a, t) ∧ incRi(b, x, z)∧
∧ tRiE (b, t) → a = b]	(6’)
That is, G0 has a ring topology if the following conditions are satisfied:
(1’) There is a cycle, i.e., every vertex of G0 has a path with origin and destination in itself;

5 Again, in what follows, we omit the subscript GG in relations, assuming that it is clear from context which grammar is under consideration.

(2’) There is no bifurcation of edges of type t in G0, i.e., if there are two edges of type t with origin at the same vertex, these edges are equal. This property guarantees that the paths of edges of type t in G0 are unique;
(3’) The graph is connected, i.e., from every vertex in G0 there is a path to all other vertices.
And, to have a graph with a ring topology resulting from the application of a rule
αi = {αiV , αiE } to a reachable graph, it must be guaranteed that:
(4’) The reachable graph has a ring structure;
(5’) For every edge a of type t going from x to y in Li there is a corresponding path in Ri starting at the image αiV of x and ending at the image αiV of y;
(6’) There is no bifurcation of edges of type t in Ri. This guarantees that the paths of edges of type t in Ri are unique.
Other functions could also be included in the library, such as, functions to define types of vertices of a reachable graph, cardinality of edges, cardinality of vertices and many others. Having established the theory, we describe the proof strategy used to demonstrate properties for a system specified in graph grammar. First, we must define the relational structure associated to the grammar (according to Definition 3.11). The relations of this structure define axioms that are used in the proofs. For example, considering |GG| = ⟨DGG, (R)R∈RGG ⟩ the relational structure associated to the grammar, we have R(x1,... , xn) ≡ true iff (x1,... , xn) ∈ R. Then we may state a goal to be proven using logic formulas. Properties about reachable states may be proven by induction, since this data type is recursively defined. The proof must be performed in the following way: first (base case), the property is verified for the initial graph (G0) and then, at the inductive step, the property is verified for every rule of the grammar applicable to a reachable graph g (i.e., for ap(αi, m) g), considering that the property is valid for g. This process may be semi-automated: it may proceed until a separate property or lemma is required, then we must establish the property or prove the lemma, and then the proof of the original goal can continue.
Now, we give two examples of proofs of properties for the Token Ring protocol: one about types of edges and another about the structure of reachable graphs.
Proposition 5.1 Any reachable graph has (only) one edge of the type T ok.
According to the definition of tipE, previously established in the library, the property to be proven can be enunciated by the formula:
∃!x [(x, Tok) ∈ tipE reach gr].

Proof. Basis: Here, the property is verified for the initial graph G0.
(1)
∃!x [(x, Tok) ∈ tipE G0] ≡ ∃!x [tG0E (x, Tok)] ≡ true.
The last equivalences may be verified automatically. Since the relational structure that defines the grammar has a single pair with the second component

T ok belonging to the relation tG0E (see Example 3.6), the logical expression must be evaluated to true.
Hypothesis ⇒ Inductive Step:  Assuming that ∃!x[(x, Tok) ∈ tipEreach gr], the proof reduces to five cases, depending on the rule that is applicable:
(2)
(i) ∃!x [(x, Tok) ∈ tipE ap(α1, m) reach gr)] ≡
∃!x [tR1E (x, Tok) ∨ [(x, Tok) ∈ tipE reach gr ∧ ∄w mEα1 (w, x)]].
Now it is necessary to inform if the edge x of type T ok of the reachable graph is an image of the match or not, when rule αi is applied. This can be done stating:
∀x (x, Tok) ∈ tipE reach gr,  ∃w mEαi (w, x) ⇔ ∃w tLiE (w, Tok)	(3)
According to (3), the edge of type T ok of the reachable graph will be an image of the match if and only if the left-hand side of the applied rule contains an edge of the type T ok. Then:
(3)
∃!x [tR1E (x, Tok) ∨ [(x, Tok) ∈ tipE reach gr ∧ ∄w mEα1 (w, x)]] ≡
∃!x [tR1E (x, Tok) ∨ [(x, Tok) ∈ tipE reach gr ∧ ∄w tL1E (w, Tok)]] ≡ true.
There is a (single) pair at the relation tR1E that has the second component T ok (see Example 3.9). Besides it is assumed by hypothesis that (x, Tok) ∈ tipE reach gr. Since expression ∄w mEα1 (w, x) is evaluated to false (there is a pair in relation tL1E that has the second component T ok), the complete formula may be automatically evaluated to true.
(ii−v) The proofs for rules α2, α3, α4 and α5 are analogous. It is important to notice that, since the property that informs if an edge of type T ok is the image of a match has already been stated, the verification for these rules may proceed automatically.	 
Proposition 5.2 Any reachable graph has a ring topology of edges of type Nxt.
Considering that the transitive closure of edges and the function that identifies a ring topology are previously defined in the library, the property to be proven can be enunciated as:


Proof. Basis:
RingNxt reach gr ≡ true.

RingNxt
def.
G0 ≡ ∀
x [vertG0
(x) → (x, x) ∈ TCNxt
] ∧	(1’)

∧∀a, b, x, y, z [incG0(a, x, y) ∧ tG0E (a, Nxt) ∧ incG0(b, x, z)∧
∧ tG0E (b, Nxt) → a = b] ∧	(2’)

∧∀x, z [vertG0(x) ∧ vertG0(z) → (x, z) ∈ TCNxt
] ≡	(3’)

≡ true
Considering that the result of the operation TCNxt

is the set {(N 01,N 02),

(N 02,N 03), (N 03,N 01), (N 01,N 03), (N 02,N 01), (N 03,N 02), (N 01,N 01), (N 02,
N 02), (N 03,N 03)}, (1’) and (3’) are satisfied. (2’) is also satisfied because there are no two edges of the type Nxt in G0 starting at the same vertex (see Examples

3.3 and 3.6).
Hypothesis ⇒ Inductive Step: RingNxt reach gr ≡ true ⇒
def.
(i) RingNxt ap(α1, m) reach gr ≡ RingNxt reach gr ∧	(4’)
∧∀a, x, y, z, w [incL1(a, x, y) ∧ tL1E (a, Nxt) ∧ α1V (x, z) ∧

∧ α1V
(y, w) → (z, w) ∈ TCNxt
R
] ∧	(5’)

∧∀a, b, x, y, z [incR1(a, x, y) ∧ tR1E (a, Nxt) ∧ incR1(b, x, z)∧
∧ tR1E (b, Nxt) → a = b] ≡	(6’)
≡ true
This property may be verified automatically: (4’) is valid by the induction hy-

pothesis; (5’) is valid by the result of the operation TCNxt
R
; and (6’) is valid because

there aren’t two edges of type Nxt starting at the same node in R1 (see Example
3.9).
(ii − v) The proofs for rules α2, α3, α4 and α5 are analogous.	 

Final Remarks
We have introduced a relational and logical approach to graph grammars to al- low the analysis of asynchronous distributed systems with infinite state space. In order to represent this specification language, we have used a relational structure to characterize a graph grammar and defined rule applications as first-order defin- able transductions. The main aim of this work is to enable the use of the theorem proving technique to prove properties about graph grammars, especially properties about reachable states.
We plan to extend the approach proposed here to specific classes of graph gram- mars such as, for example, object-based graph grammars [10], appropriate for the specification of object-based systems, or timed object-based graph grammars, suit- able to specify real time systems. In the first case, the set of vertices of the graph grammar must be partitioned in two subsets of objects and values (of abstract data types) and the set of edges should be replaced by a set of hyperedges that must be partitioned into sets of message and attribute edges. In the second case, we also have to add time stamps to the messages. This extension will allow the proof of properties usually not analyzed in model-checkers of object-based systems such as properties about the internal states of objects and their attributes. Another topic of future work is the implementation of the proposed approach using, for example, the Isabelle theorem prover [16].

References
Baldan, P., A. Corradini, U. Montanari and L. Ribeiro, Unfolding semantics of graph transformation, Inf. Comput. 205 (2007), pp. 733–782.

Baldan, P. and B. K¨onig, Approximating the behaviour of graph transformation systems, in: Proceedings of ICGT ’02 (International Conference on Graph Transformation), LNCS 2505 (2002), pp. 14–29.

Baresi, L. and P. Spoletini, On the use of Alloy to analyze graph transformation systems, in:
A. Corradini, H. Ehrig, U. Montanari, L. Ribeiro and G. Rozenberg, editors, ICGT, LNCS 4178
(2006), pp. 306–320.
Behrmann, G., A. David and K. G. Larsen, Tutorial on uppaal, in: Formal Methods for the Design of Real-Time Systems, LNCS 3185, Springer, 2004 pp. 200–236.
Clarke, E. M., O. Grumberg, S. Jha, Y. Lu and H. Veith, Progress on the state explosion problem in model checking, in: Informatics - 10 Years Back. 10 Years Ahead. (2001), pp. 176–194.
Clarke, E. M. and J. M. Wing, Formal methods: state of the art and future directions, ACM Computing Surveys 28 (1996), pp. 626–643.
Courcelle, B., Monadic second-order definable graph transductions: A survey., Theoretical Computer Science 126 (1994), pp. 53–75.
Courcelle, B., The expression of graph properties and graph transformations in monadic second-order logic., in: Rozenberg [20], pp. 313–400.
Courcelle, B., Recognizable sets of graphs, hypergraphs and relational structures: A survey., in:
C. Calude, E. Calude and M. J. Dinneen, editors, Developments in Language Theory, LNCS 3340
(2004), pp. 1–11.
Dotti, F. L., L. Foss, L. Ribeiro and O. M. Santos, Verification of distributed object-based systems, in: 6th International Conference on Formal Methods for Open Object-based Distributed Systems, LNCS 2884 (2003), pp. 261–275.
Dotti, F. L. and L. Ribeiro, Specification of mobile code systems using graph grammars, in: Formal Methods for Open Object-Based Distributed Systems, Kluwer, 2000 pp. 45–64.
Dwyer, M. B., J. Hatcliff, R. Robby, C. S. Pasareanu and W. Visser, Formal software analysis emerging trends in software model checking, in: FOSE ’07: 2007 Future of Software Engineering (2007), pp. 120– 136.
Gurevich, Y., Monadic second-order theories, in: J. Barwise and S. Feferman, editors, Model-Theoretic Logics, Springer, 1985 pp. 479–506.
Holzmann, G. J., The model checker Spin, IEEE Transactions on Software Engineering 23 (1997),
pp. 279–295.
Michelon, L., S. A. Costa and L. Ribeiro, Specification of real-time systems with graph grammars, in:
P. C. Masiero, editor, Brazilian Symposium on Software Engineering, 2006, pp. 97–112.
Nipkow, T., L. C. Paulson and M. Wenzel, “Isabelle/HOL — A Proof Assistant for Higher-Order Logic,” LNCS 2283, Springer, 2002.
Rensink, A., A´. Schmidt and D. Varr´o, Model checking graph transformations: A comparison of two approaches, in: Proc. ICGT 2004: Second International Conference on Graph Transformation, LNCS 3256 (2004), pp. 226–241.
Ribeiro, L., F. Dotti and R. Bardohl, A formal framework for the development of concurrent object- based systems, in: Formal Methods in Software and Systems Modeling, LNCS 3393 (2005), pp. 385–401.
Robinson, J. A. and A. Voronkov, editors, “Handbook of Automated Reasoning (in 2 volumes),” Elsevier and MIT Press, 2001.
Rozenberg, G., editor, “Handbook of Graph Grammars and Computing by Graph Transformations, Volume 1: Foundations,” World Scientific, 1997.
Strecker, M., Modeling and verifying graph transformations in proof assistants, Electronic Notes in Theoretical Computer Science 203 (2008), pp. 135–148.
Tanenbaum, A., “Computer Networks,” Prentice Hall, 2002.
