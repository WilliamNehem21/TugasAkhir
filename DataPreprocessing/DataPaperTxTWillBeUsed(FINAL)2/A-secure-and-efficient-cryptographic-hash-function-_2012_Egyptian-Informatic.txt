
ORIGINAL ARTICLE
A secure and eﬃcient cryptographic hash function based on NewFORK-256
Harshvardhan Tiwari *, Krishna Asawa

Department of Computer Science and Engineering, JIIT(Deemed University), Noida, U.P., India

Received 8 June 2012; revised 28 July 2012; accepted 23 August 2012
Available online 29 September 2012

Abstract Cryptographic hash functions serve as a fundamental building block of information security and are used in numerous security applications and protocols such as digital signature schemes, construction of MAC and random number generation, for ensuring data integrity and data origin authentication. Researchers have noticed serious security flaws and vulnerabilities in most widely used MD and SHA family hash functions. As a result hash functions from FORK fam- ily with longer digest value were considered as good alternatives for MD5 and SHA-1, but recent attacks against these hash functions have highlighted their weaknesses. In this paper we propose a dedicated hash function MNF-256 based on the design principle of NewFORK-256. It takes 512 bit message blocks and generates 256 bit hash value. A random sequence is added as an additional input to the compression function of MNF-256. Three branch parallel structure and secure com- pression function make MNF-256 an efficient, fast and secure hash function. Various simulation results indicate that MNF-256 is immune to common cryptanalytic attacks and faster than New- FORK-256.
© 2012 Faculty of Computers and Information, Cairo University. Production and hosting by Elsevier B.V. All rights reserved.



Introduction

Ensuring privacy and preventing integrity of a message are the basic goals of cryptography. Cryptographic hash functions re- main one of the most important cryptographic primitives, and they can be used to guarantee the security of many crypto-

* Corresponding author.
E-mail addresses: tiwari.harshvardhan@gmail.com (H. Tiwari), krish- na.asawa@jiit.ac.in (K. Asawa).
Peer review under responsibility of Faculty of Computers and Information, Cairo University.
graphic applications and protocols such as digital signature, random number generation, data source authentication, key update and derivation, message authentication code, integrity protection, malicious code recognition, SSL, TLS and S/ MIME. Cryptographic hash functions compress an input mes- sage of arbitrary length to an output with short fixed length, the hash code. Hash functions are classified into two classes: unkeyed hash function also known as Manipulation Detection Code (MDC) with single parameter – a message and keyed hash function with two distinct inputs – a message and secret key. Keyed hash functions are used to construct the MAC (Message Authentication Code). The MAC is widely used to provide data integrity and data origin authentication. The choice between a MAC and an MDC is application dependent. They are also classified as, namely hash functions based on


1110-8665 © 2012 Faculty of Computers and Information, Cairo University. Production and hosting by Elsevier B.V. All rights reserved. http://dx.doi.org/10.1016/j.eij.2012.08.003



block cipher, hash functions based on modular algorithm and dedicated hash functions. The motivation behind block cipher based schemes is the minimization of the effort to design and implement the hash functions and of the complexity of the equipment. Also the trust that one has in a certain block cipher (such as DES) can be transferred to a hash function. Particu- larly interesting from a theoretical point of view, modular algorithm based schemes are provably secure, in the sense that their security relies on the hardness of some mathematical problems such as number theory problems. Dedicated hash functions are specially designed from the scratch for the pur- pose of hashing a plain text with optimized performance and without being constrained to reusing existing system compo- nents such as block ciphers and modular arithmetic. These hash functions are not based on hard problems such as factor- ization and discrete logarithms. The most popular method of designing compression functions of dedicated hash functions is a serial successive iteration of a small step function [1,2]. Our proposed hash function comes under the last category.
Preimage resistance, second preimage resistance and colli- sion resistance are the three classical requirements for security of keyless hash functions. Properties preimage resistance, sec- ond preimage resistance and collision resistance are also known as one way, weak collision resistance and strong colli- sion resistance respectively. First of all, it needs to be compu- tationally infeasible to find the preimage X of H(X), when H(X) is given. This is called preimage resistance. Secondly, finding Y „ X with H(Y)= H(X), when X and H(X) are given, should also be infeasible. This property is called second preim- age resistance. Finally, it should be computationally infeasible to find any two distinct messages X and Y with H(X) = H(Y). This is called collision resistance. Additionally, a hash function is often required to behave indistinguishably from a random function. An ideal hash function that generates an n bit hash value requires evaluating about 2n/2 messages to find any pair of messages having the same hash value. This kind of brute- force search for hash functions is called a birthday attack. Also 2n hash computations are required for finding preimages and second preimages [3].
In this paper we have proposed a dedicated hash function MNF-256 that takes a message of arbitrary length and con- verts it into a 256 bit hash value. It is based on the design prin- ciple of NewFORK-256 [4]. The compression function of MNF-256 consists of three parallel branches; each branch compresses a sixteen 32 bit words to eight 32 bit words output. Each branch contains eight step operations. FORK-256 [5] and NewFORK-256, both hash functions built on Merkle- Damga˚ rd method [6]. In recent years, many attacks have been presented against these hash functions. The compression func- tion of the proposed hash function uses dithering design. Its padding and splitting of message is similar to Merkle-Dam- ga˚ rd construction. Dithering construction is obtained by pro- viding an additional input to the Merkle-Damga˚ rd construction. This design was given by Rivest [7]. The iterative structure of this design provides good resistance against some typical attacks such as birthday attack, meet-in-the middle at- tack and preimage attack. The compression function of MNF- 256 has three input parameters and one output parameter. The additional input parameter is a dither value. There are many ways to select dither value. Random numbers generated from Park–Miller algorithm [8] are used as dither value in the pro- posed algorithm. For each message block in the message, there
is different dither value sequence. For each message block 16 different 32 bit dither value generated, out of which each branch makes the use of eight 32 bit dither value according to the ordering rule. All the modifications made to overcome the recent attacks on FORK-256 and NewFORK-256.
The rest of this paper is organized as follows; Section 2 pre- sents the related work. The proposed hash function is pre- sented in Section 3. Section 4 contains the security analysis of MNF-256. The performance analysis of MNF-256 is pre- sented in Section 5. The paper is concluded in Section 6.

Related work

Merkle-Damga˚rd construction and its weaknesses

A typical way to build a hash function is to iteratively apply a fixed-input length compression function. Almost all modern hash functions are based on this principle and the most wide- spread application of an iterative construction is the Merkle- Damga˚ rd paradigm. Even though the paradigm lies on solid theoretical foundation, there have been some flaws exposed in the design, turning the MD construction into an insecure model. Several attacks have shown that the iterative paradigm is not equivalent to the random oracle model used in many security proofs of cryptographic protocols. In the MD method a message of arbitrary length is divided into l bit blocks (with a padding process on the last block), that are sequentially in- jected into an internal collision resistant compression function. The compression function generates an n bit intermediate di- gest using the input block and the previous intermediate result. The last intermediate digest is defined as the final n bit hash va- lue; after all input blocks are processed.
Length-extension attack: The well-known weakness of the property. If digests of messages M and M' collide then add- original Merkle-Damga˚ rd construction is a length extension H (M M ) =H (M ' M ). Even if we concatenate an original ing  a  common  suffix  also  leads  to  a  collision:
message with its length (M ' = M  length(M )) the attack is
valid because M' can be itself considered as an extendable message.
Multicollisions: The multicollision attacks were proposed by Joux [9]. The idea is to build collisions one after another,
which leads to 2k colliding messages after only k trials of the collision search. If a hash function has an iterative struc- ture, the attack can be always maintained. The actual com- plexity, however, depends on the size of the internal state.
Fixed point attacks: Dean [10] found that fix-points in the
compression function can be used for a second-preimage
attack against long messages. It is stated by Dean that for an iterative hash function, if the fix points of compression function can be calculated easily, then finding second-pre- images is easier than expected. Davies–Meyer construction fits this condition well. Kelsey and Schneier [11] extend this result.


Dither construction and its security against generic attacks

The main idea behind dithering hash function is to use an addi- tional input to the Merkle-Damga˚ rd hash construction in such



a way that this input will change the chaining values of the each stage. This in turn, makes the problem of finding the fixed points much harder and provides more protection against Dean’s attack and its extension under any circumstances. For a message M, divided into n-blocks each of length l, that
hash design can be formally represented as: IVi = f(mi, IVi—1, di—1), i = 1, 2,.. . , n, and di represents the dither value. The is, M = m1, m2,.. . , mn the ith chaining value for the dithering
procedure is shown in Fig. 1. The dither value is selected in
such a way that it is repetition free which in turn makes the chaining values of the hash function to be repetition free. Thus, finding fixed points become harder for an attacker. Hence, Dean’s attack and its extension can be restricted by the dithering hash construction. By inspecting the structure of the dithering hash function it is clear that there is no addi- tional effort required by the attacker to find multi-collisions just as in the case of the normal Merkle-Damga˚ rd hash con- struction. This construction is secure against general message expansion attack.

Brief history of dedicated hash functions

The MD4 [12] was proposed by Rivest in 1990. Most com- monly used hash functions are based on the design principles of MD4. MD5 [13] was also proposed by Rivest in 1992 as a strengthen version of MD4. Both MD4 and MD5 produce 128 bit message digest. MD5 is slightly slower than MD4. The design principles of MD4 are used in SHA family. SHA- 0 [14] was developed in 1993 by National Security Agency as the Secure Hash Standard and SHA-1 [15] was introduced in 1995 as a revision of SHA-0. SHA-1 was issued by NIST as FIPS PUB 180-1. Both SHA-0 and SHA-1 produce a message digest of 160 bit. NIST introduced new hash function standard FIPS PUB 180-2 in 2002. Three new hash functions, SHA-256, SHA-384 and SHA-512, collectively known as SHA-2 [16], have been specified in this standard. Later on another hash function SHA-224 was added to this standard. Another popu- lar hash function family is RIPEMD family. The RIPEMD family of hash functions was designed by combining sequential method and parallel structure. This method of designing is still reliable due to no effective attacks so far, except elementary versions of RIPEMD. The first RIPEMD hash function was introduced in 1992 under the European RIPE (RACE Integ- rity Primitives Evaluation) project. It produces 128 bit hash value. RIPEMD runs two almost identical copies of MD4 in parallel. Later two strengthen versions of RIPEMD are re- leased, RIPEMD-128 and RIPEMD-160 [17]. RIPEMD-128
also produces 128 bit message digest as its predecessor. Both

Figure 1	Dither construction.
RIPEMD-128 and RIPEMD-160 are extended to RIPEMD-
256 and RIPEMD-320 respectively. In 1998, MD4 was completely broken by Dobbertin [18]. In 2004, a team of researchers led by Wang, announced collisions in MD5 as well as collisions in other hash functions including MD4, RI- PEMD, and HAVAL-128 [19]. In 2005, they presented attacks against SHA-0 and SHA-1 [20].
FORK family hash functions can be viewed as the further extension of RIPEMD family. FORK-256 was the first hash function in FORK family, introduced in the first NIST hash workshop and at FSE 2006. Matusiewicz et al. attacked FORK-256 by using the fact that the functions f and g in the step operation were not bijective They used microcollisions to find collisions of 2-branch FORK-256 and collisions of full FORK-256 with complexity of 2126.6 [21]. Independently, Men- del et al. [22] published the collision-finding attack on 2-branch FORK-256 using microcollisions and raised possibility of its expansion. At FSE 2007, Matusiewicz et al. another attack which finds a collision with complexity of 2108. FORK-256 was optimized by Danda [23]. NewFORK-256 hash function was introduced in 2007. It includes bijective function in step operation. Saarinen presented collision attack against New- FORK-256 using meet-in-the-middle technique [24]. For this he used a method for finding messages that hash into a signif- icantly smaller subset of possible hash values. The complexity of this collision attack is 2112.9. This attack is also applicable for FORK-256.
In 2007 NIST introduced a public call for new crypto- graphic hash algorithms. The intent of the competition is to identify modern secure hash functions and to define the new SHA-3 family [25,26].

Short description of FORK family

The hash function FORK-256 was introduced at the first NIST hash workshop and at FSE 2006. Later, in 2007 the same team of researchers has published its improved version NewFORK-
256. In this new version they modified step operations, re- moved some additions and XORs and changed non-linear operations of FORK-256. The compression function of FORK-256 and NewFORK-256 consists of four independent branches. Each one of these branches takes in the 256 bit chaining value and a 512 bit message block to produce a 256 bit result. These four branch results are combined with the chaining value to produce the final compression function result. Both algorithms are entirely built on shift, XOR, and addition operations on 32 bit words. Notation for these oper- ations are shown in Table 1.
The four branches are structurally equivalent, but differ in scheduling of the message words and round constants. The Each branch is computed in eight steps, 0 6 k 6 7. Each step
utilizes two message words and two round constants. The scheduling of the message block words M0,..., M15 in each branch is given in Table 2. Each one of the four branches using







For NewFORK-256:

the same set of chaining variables CV = (A, B, C, D, E, F, G, H). The compression function updates the set of chaining vari-
Aj;k+1
= Hj;k
⊕ f(Ej;k
+ Mrj (2k+1)
+ bj;k
)n8;

ables according to the following relation:
Bj;k+1 = Aj;k + Mrj (2k) + aj;k;

CV  = CV +  [BRANCH1(CVi;R1(M)) + BRANCH2(CVi;R2(M))]⊕	(1)
C	= B  + f(A  + M	);

Round constants d0,.. . , d15 are given in Table 3 and their sche- dule in Table 4. FORK-256 uses following two 32 bit Boolean functions f and g:
f(x)= x + (xn7 ⊕ xn22) g(x)= x ⊕ (xn13 + xn27)
These Boolean functions were redefined for the NewFORK- 256 to avoid microcollisions as:
f(x)= x ⊕ (xn15 ⊕ xn27) g(x)= x ⊕ (xn7 + xn25)
For the BRANCHj (1 6 j 6 4), the message block is com- pressed as follows:

The chaining variable CVi is assigned to initial variables
Vj,0.

At kth step function (0 6 k 6 7), the output Vj,k+1 is com- puted as follows:
V j;k+1 = STEPj;k (V j;k ; Mrj (2k); Mrj (2k+1); aj;k ; bj;k ); V j;8  is the output of BRANCHj.
STEPj,k uses V j;k; Mrj (2k); Mrj (2k+1); aj;k; bj;k as inputs and generates the following output:
For FORK-256:
Aj;k+1 = Hj;k + g(Ej;k + Mrj (2k+1))n21 ⊕ f(Ej;k + Mrj (2k+1) + bj;k)n17;
Bj;k+1 = Aj;k + Mrj (2k) + aj;k;
Cj;k+1 = Bj;k + f(Aj;k + Mr (2k))⊕ g(Aj;k + Mr (2k) + aj;k);
Dj;k+1 = Cj;k + f(Aj;k + Mrj (2k))n13 ⊕ g(Aj;k + Mrj (2k) + aj;k);
Ej;k+1 = Dj;k ⊕ g(Aj;k + Mrj (2k) + aj;k)n17;
Fj;k+1 = Ej;k + Mrj (2k+1) + bj;k;
Gj;k+1 = Fj;k + g(Ej;k + Mrj (2k+1));
Hj;k+1 = Gj;k + g(Ej;k + Mrj (2k+1))n3 ⊕ f(Ej;k + Mrj (2k+1) + bj;k).
Proposed hash function

In this section we describe details of the proposed hash func- tion MNF-256. The MNF-256 is a cryptographic dedicated hash function, which compresses three input parameters: 512 bit message block, 256 bit chaining variables and 512 bit dither values into a 256 bit hash value. A structure of three parallel branches has been used in MNF-256. Each branch consists of eight step operations. The basic notations used in MNF-256 are shown in Table 1. The proposed algorithm in- cludes two main stages for the computation of 256 bit hash va- lue: first is preprocessing stage and second one is computation stage. Preprocessing stage contains three steps: message pad- ding, message parsing and initialization of eight chaining vari- ables. Padding procedure of the algorithm is exactly the same as that of SHA-1. In the parsing step the message is divided into N blocks of 512 bit, and the ith block of 512 bit is a con- catenation of sixteen 32 bit words. The initial hash value for

j	j
MNF-256 is the same as that of NewFork-256. The rest of

Dj;k+1 = Cj;k + f(Aj;k + Mrj (2k))n5 ⊕ g(Aj;k + Mrj (2k) + aj;k)n9;
Ej;k+1 = Dj;k + f(Aj;k + Mrj (2k))n17 ⊕ g(Aj;k + Mrj (2k) + aj;k)n21;
Fj;k+1 = Ej;k + Mrj (2k+1) + bj;k;
the algorithm details are as follows:
Message padding: The purpose of the message padding is to

Gj;k+1
= Fj;k
+ g(Ej;k
+ Mrj (2k+1)
)⊕ f(Ej;k
+ Mrj (2k+1)
+ bj;k);
make the total length of a padded message a multiple of
512. The message M is padded with one bit equal to 1 next

Hj;k+1 = Gj;k + g(Ej;k + Mrj (2k+1))n9 ⊕ f(Ej;k + Mrj (2k+1) + bj;k)n5.
to the least significant bit of the message followed by a var-

iable number of zero bits and then appends to the message the 64 bit original message length modulo 264, so that the total length of the padded message is the exact multiple of 512.
Parsing the padded message: Divide the padded message M
into a sequence of N 512 bit blocks. Each message block Mi
is expressed as sixteen 32 bit words.
Initialization of chaining variables: There are eight chaining variables A, B, C, D, E, F, G, H. These working variables in
each branch are initialized as follows: where



A0 = 0x6A09E667; B0 = 0xBB67AE85; C0 = 0x3C6EF372; D0 = 0xA54FF53A E0 = 0x510E527F; F0 = 0x9B05688C; G0 = 0x1F83D9AB; H0 = 0x5BE0CD19
Compression function: The compression function of MNF- 256 compresses 512 bit input message block, 256 bit chain-
ing variables and 512 bit dither values to a 256 bit hash value. Each message block Mi is divided into sixteen 32 bit words M0,..., M15 and compressed according to
Fig. 2, where Rj(M )= (Mrj (0); ... ; Mrj (15)); for 1 6 j 6 3;
is the permutation for the message words, selected from
Table 5. The chaining variable CVi is updated to CVi+1
according to following relation:

Branch function: Each BRANCHj for 1 6 j 6 3, is com- puted as follows:
Step 1: the chaining variable CVi is copied to initial var- iable Vj,0 for jth branch.
Step 2: at kth step of each branch for 0 6 k 6 7; the step
V j;k+1 = STEPj;k (V j;k ; Mrj (2k); Mrj (2k+1); aj;k ; bj;k ; dj;k ); function	STEPj,k	is	computed	as	follows: where aj,k and bj,k are constants and dj,k is the dither
input.
Constants: There are total 16 constant values. Each step uses two constant values. Values for constants are given
in Table 3. These constants are applied to each branch func- tion. These constants are used in each BRANCHj with dif- ferent order. Ordering of constants is shown in Table 6.
Step operation: The input Vj,k of STEPj,k is divided as
follows:
V j;k = (Aj;k ; Bj;k ; Cj;k ; Dj;k ; Ej;k ; F j;k ; Gj;k ; Hj;k )

([BRANCH (CV ;R (M)) + BRANCH (CV ;R (M))]⊕)
STEPj,k

uses V
j;k ; M
rj (2k); M
rj (2k+1)
; aj;k
; bj;k
; dj;k
as inputs

[BRANCH2(CVi;R2(M)) + BRANCH3(CVi;R3(M))]




Figure 2	Structure of compression function.










Aj;k+1 = Hj;k ⊕ f(Ej;k + Mrj (2k+1) + bj;k)n8 ⊕ dj;k; Bj;k+1 = Aj;k + Mrj (2k) + aj;k ⊕ dj;k;
Cj;k+1 = Bj;k + f(Aj;k + Mrj (2k))⊕ dj;k;
Dj;k+1 = Cj;k + f(Aj;k + Mrj (2k))n13 ⊕ g(Aj;k + Mrj (2k) + aj;k)⊕ dj;k;

Ej;k+1 = Dj;k ⊕ g(Aj;k + Mrj (2k) + aj;k)n17 ⊕ dj;k; Fj;k+1 = Ej;k + Mrj (2k+1) + bj;k ⊕ dj;k;
Gj;k+1 = Fj;k + g(Ej;k + Mrj (2k+1))⊕ dj;k;
Hj;k+1 = Gj;k + g(Ej;k + Mr (2k+1))n3 ⊕ f(Ej;k + Mr (2k+1) + bj;k)⊕ dj;k.
a = 16,807, m = 214,74,83,647, q = 127,773, r = 2836.
Step 2: compute the value of hi = seed div q; lo = seed mod
q.
t   =   a   *   lo   —  r   *   hi    . Step 3: then compute the corresponding test value: tes-
Step 4: save the new seed value. If test > 0, save test as new
seed value, otherwise save test + m. Step 5: output the new seed.
Step 6: iterate, and let the output seed be the new input seed.
Shifts: s bit left shift for a 32 bit string is denoted as X ns.
Four shift values: 13, 17, 3 and 8, have been used in the
computation of step operations. They are defined as fol-

lows:

The complete step operation is depicted in Fig. 3.

Dither values: For each message block Mi, there is a sequence of 16 different dither values. These dither values
are applied to each branch with a different order. Dither value ordering for different branches is shown in Table 7. These values are generated from Park–Miller algorithm. The Park–Miller algorithm is an efficient and fast algorithm for generating good random sequences. It is based on con-
gruential form: Sn+1 = aSnmod(231 — 1).. The steps of the
algorithm are described as follows:
S1 = X n13; S2 = X n17; S3 = X n3; S4 = X n8.
Nonlinear functions: MNF-256 uses two nonlinear func- tions, f and g in the computation of its step operations.
Among these two functions f is completely bijective. These functions are defined as follows:

f(x)= x ⊕ (xn15 ⊕ xn27). g(x)= x ⊕ (xn7 + xn25).
Table 8 summarizes the comparative analysis among the FORK-256, NewFORK-256 and MNF-256.






























Figure 3	Step operation.



Security analysis

First, if an attacker inserts the message difference to find a col- lision in 3-branch then, he expects the following: (D1 + D2) ¯ (D2 + D3) = 0, where, Di is the output difference of the BRANCHi. To obtain such a differential pattern the at- tacker should survey the following strategies:

Strategy-1: To construct a differential characteristic with a high probability for a branch function, say BRANCHi and then expects that, the operation of the output differences in the other branches D3 is equal to D1. Proposed hash func- tion is secure against this strategy because the outputs of each branch function are random; the probability of the
event is almost close to 2—256.
teristics such that: (D1 + D2)= —(D2 + D3). (This can be Strategy-2: To construct two different differential charac- generated for cancelling the first and second chaining values
to obtain the difference between the chaining values as zero, the required condition for generating an attack).

To find an attack using this strategy an attacker has to con- struct such a differential pattern of the message words. But, for any message words it is computationally hard to find such sequences.

Strategy-3: To insert the message difference which yields same message difference pattern in all the three branches and expect that, same differential characteristics occur simultaneously in three branches.

This strategy is relatively easy for an attacker. However, using the message word reordering this can be avoided just as in the case of FORK and NewFORK. Since the same message word reordering is used in the proposed hash functions same security level can be expected for it against this strategy. Moreover, using different operators (e.g. + and ¯) highly complicates the computation of good differential paths. Addition of mes- sage words, parallel mixing structure, rotation of registers
and addition of dither value made compression function stron- ger against different attacks.

Performance analysis

Hash result of a message

For the sake of simplicity, let us consider message, M (1 block, 512 bit), given by:

00112233 44556677 88990011 22334455 66778899
00112233 44556677 88990011 22334455 66778899
00112233 44556677 88990011 22334455 66778899
00112233
Branch1 output:
84fddde4 50791ee4 7f50dc6d b9fef233 8393a036 47d99fac 8dd26400 62363776
Branch2 output:
277310f3 cd9e88e8 9fbd0920 1e217775 2d4c7c1a 4c728465
de58849a a5e62d2c Branch3 output:
5c2c2978 f5f0b9c7 7fd9061c 70563438 88b387c4 6d950b4e
4cc746de ed33ab54 Final hash result:
50fa289 eb578341 1a07d8d5 a5ebdfeb a7661484 a1e5881a 4dcf854d a315f0fb


Randomness

We have taken an input message M of 512 bit length and com- puted corresponding hash value. By changing the ith bit of M, new modified messages Mi have been generated, for 1 6 i 6 512. Then we generated hash values of all these new messages and finally computed Hamming distances or changed bit numbers between hash values of original message and mod- ified messages. Ideally it should be 128. But we found that these Hamming distances were lying between 106 and 153 for above messages. Range of distances is given in Table 9.







206	H. Tiwari, K. Asawa

Average Hamming distance is 128.0234. Distribution of dis- tance is shown in Fig. 4.

Bit variance test


The bit variance test consists of measuring the impact on the digest bits by changing input message bits. Bits of an input message are changed and the corresponding message digests (for each changed input) are calculated. Finally from all the di- gests produced, the probability Pi for each digest bit to take on the value of 1 and 0 is measured. If Pi(1) = Pi(0) = 1/2, for all digest bits i 1 6 i 6 n, where n is the digest length, then the hash function under consideration has attained maximum per- formance in terms of the bit variance test. Therefore, the bit variance test actually measures the uniformity of each bit of the digest. Since it is computationally difficult to consider all input message bit changes, we have evaluated the results for only up to 513 files and found the following results:

Number of digests = 513.
Mean frequency of 1s (expected) = 256.50. Mean frequency of 1s (calculated) = 256.29.

The above analysis show that MNF-256 exhibits a reason- ably good avalanche effect. Thus it can be used for crypto-















Figure 4	Frequency distribution of distance.
Mean changed probability : P = (B/256)× 100%	(4)
Standard deviation of the changed bit number :
vuﬃﬃﬃﬃﬃ1ﬃﬃﬃﬃﬃﬃﬃﬃXﬃﬃﬃNﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ

graphic applications.

Statistical analysis of diffusion and confusion
DB = tN — 1
i=1
(B — B)2
(5)

In order to hide message redundancy, Shannon introduced dif- fusion and confusion. Diffusion means spreading out of the influence of a single plaintext bit so as to hide the statistical struc- ture of the plaintext. Confusion means the use of transforma- tions that complicate dependence of the statistics of ciphertext on the statistics of plaintext. They are two general principles to guide the design of practical cipher, including hash function. For the hash value in binary format, each bit is only 1 or 0. So the ideal diffusion effect should be that any tiny changes in initial conditions lead to the 50% changing probability of each bit.
We have performed the following diffusion and confusion test. A message is randomly chosen and hash value is gener- ated, then a bit in the message is randomly selected and toggled and a new hash value is generated. Two hash values are com- pared with each other and the number of changed bit is counted as Bi.
This kind of test is performed N (such as 512, 1024, 2048) times. We used four statistics for this: mean changed bit num- ber B, mean changed probability P, standard deviation of the changed bit number DB and standard deviation DP.
N
Standard deviation :
vuﬃﬃﬃﬃﬃ1ﬃﬃﬃﬃﬃﬃﬃﬃXﬃﬃﬃNﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ



where N is total statistic number. DB and DP indicate the sta- bility of diffusion and confusion. Through the tests with
N = 512, 1024, 2048, respectively, the corresponding data are listed in Table 10 .
Table 10 indicates that the mean changed bit number and changed percent are 127.94 and 49.97% respectively, which
are very close to the ideal value 128 and 50%. While DB and DP, indicating the stability of diffusion and confusion, is very little, which represent that the capability for diffusion and con-
fusion is stable.

Analysis of collision resistance

Collision attack is a typical algorithm-independent attack which can apply to any hash function. Collision resistance means that the hash results are identical to different random
initial input. Efforts required to find a pair of messages that re-

Mean changed bit number : B =  1	B
N i=1
(3)
sults to a same hash value for an n-bit hash function is 2n/2.



A secure and efficient cryptographic hash function based on NewFORK-256	207

Since the length of the hash value is 256 bits, requires 2128 operations to find a collision.
Moreover, in order to investigate the collision resistance capability of the hashing approach, we have performed two collision tests. In the first experiment, the hash value for a randomly chosen message is generated and stored in ASCII format. Then a bit in the message is selected randomly and tog- gled and thus a new hash value is then generated and stored in the same format. Two hash values are compared with each other and the number of character in this format with the same value at the same location in hash value is counted. The abso- lute difference of the two hash result is calculated by using the following formula:
XN




where ei and e' are the ith ASCII character of the original and
the new hash value, respectively, dec() converts the entries to
their equivalent decimal values. This kind of collision test is performed 2048 times. The maximum, minimum, mean values of AD are listed in Table 11.
In the second experiment, the hash value for a randomly chosen message is generated and stored in ASCII format sim- ilarly. This experiment concentrates on the possibility of collid- ing between every two hash results, thus every two hash results should be compared. The simulation is performed 2048 times. The plot of the distribution of the number of ASCII characters with the same value at same location is given in Fig. 5. Notice that the maximum number of equal entries in the Fig. 5 is 2. Besides, most of the entries are different in ASCII format. It shows that the hash algorithm proposed possesses a strong col- lision resistance capability.

Security against preimage and 2nd-preimage attacks

The one way structure of MNF-256 does not allow the recon- struction of the original message from a hash value. In general, collision resistance property provides second preimage resis- tance for a hash function. MNF-256 has shown good collision resistance. So both, preimage and 2nd-preimage attacks would require at least 2256 operations, implying that the proposed hash function has a strong resistance against such attacks.

Robustness against differential cryptanalysis

We studied the robustness of the proposed hash function against differential cryptanalysis. This attack analyzes the plaintext pairs along with their corresponding hashes pairs. For example, if the difference between 2 messages be 2 bits,
(i.e., say, d = 2) then the message digest pair difference d' for
the corresponding 2 message digests can be calculated. From
'
the distribution of d corresponding to different message pairs,
the standard deviation (r) is calculated. If r < 10%, then the hash function is secure against differential cryptanalysis. For

Figure 5 Distribution of the number of equal entries with the same value at the same location in the hash value.

the experiment input message of 10 bytes was considered. The experiments were run for all possible d = {1, 2, 4, 8, 16, 32} bit differences for an input message. The results in Table 12 show that the proposed hash function is secure against the dif- ferential attack.

Efficiency

The performance test has been carried out over an Intel Pen- tium 4 CPU at 1.47 GHz with 1 GB RAM according to the fol- lowing procedure: We select a message of size s bytes and generate 1000 random messages of same size. The hash func- tion is applied to each of these 1000 messages, measuring the time required to compute each of them. Finally, we take the average over 1000 samples. In order to compare with FORK-256 and NewFORK-256, the process has been re- peated for these algorithms. The average CPU computation times (in sec) obtained for FORK-256, NewFORK-256 and MNF-256 are listed in Table 13.

Conclusion

Proposed hash function generates 256 bit hash string. It has a parallel structure consist of three branches. Each branch




208	H. Tiwari, K. Asawa


computes eight step operations. Algorithm uses 16 constants and two nonlinear functions. Each branch makes the use of
16 message sub blocks and constants with different order. For making the whole structure complicated for the cryptana- lyst and secure against known attacks compression function uses three inputs. Dither values are used as third input. These dither values are random numbers generated through Park– Miller algorithm. The one way structure of the algorithm makes it strong against preimage and second preimage attack. Various tests have been performed to check the security level of hash function. The bit variance test has been performed for one bit changes. The result of bit variance test show that MNF-256 exhibits a reasonably good avalanche effect i.e. when a single input bit is complemented, each of the output bits changed with a probability of 0.5. Thus proposed hash function pass the bit variance test. The statistical analysis of MNF-256 indicates that it has strong and stable confusion and diffusion capability. The calculated mean changed bit number and mean changed probability are 127.94 and 49.97% respectively, both very close to the idle value 128 bit and 50% while standard deviation of the changed bit number and standard deviation are very little, which indicates the capability for confusion and diffusion is very stable. The colli- sion test is applied to 2048 different hash pairs. The maximum number of equal characters at the same location in two hash values is only 2. The calculated absolute difference/character of two hash values is 85.58, which is close to the theoretical va- lue 85.33 shows strong collision resistance. Simulation results and rigorous analysis of the hash function guarantee its secu- rity against differential and other common known attacks. Further, as future work, we try to improve its efficiency.

References

Schneier B. Applied cryptography. New York: John Wiley & Sons; 1996.
Bakhtiari S, Safavi-Naini R, Pieprzyk J. Cryptographic hash functions: a survey. Technical report 95-09, Department of Computer Science, University of Wollongong; 1995.
Menezes AJ, van Oorschot PC, Vanstone SA. Handbook of applied cryptography. CRC Press; 1997.
Hong D, Chang D, Sung J, Lee S, Hong S, Lee J, et al. NewFORK-256. Cryptology ePrint Archive, report 2007/185; 2007.
Hong D, Chang D, Sung J, Lee S, Hong S, Lee J, et al. A new dedicated 256-bit hash function: FORK-256. In: FSE’06, LNCS, vol. 4047; 2006. p. 195–209.
Damga˚ rd I. A design principle for hash functions. In: CRYPTO’89, LNCS, vol. 435; 1989. p. 416–27.
Rivest R. Abelian square-free dithering for iterated hash func- tions. In: ECRYPT hash function workshop; 2005. <http:// csrc.nist.gov/groups/ST/hash/documents/rivest-asf-paper.pdf>.
Park S, Miller K. Random number generators: good ones are hard to find. Commun ACM 1988;31(10):1192–201.
Joux A. Multicollisions in iterated hash functions. In: CRYPTO’04, LNCS, vol. 3152; 2004. p. 306–16.
Dean RD. Formal Aspects of Mobile Code Security. PhD thesis, Princeton University; 1999.
Kelsey J, Schneier B. Second preimages on n-bit hash functions for much less than 2nWork. In: EUROCRYPT’05, LNCS, vol. 3494; 2005. p. 474–90.
Rivest R. The MD4 message digest algorithm. In: CRYPTO’90, LNCS, vol. 537; 1991. p. 303–11.
Rivest R. The MD5 message digest algorithm, request for comments (RFC) 1321. Internet engineering task force; 1992.
NIST, Secure hash standard (SHS), federal information process- ing standards 180; 1993.
NIST, secure hash standard (SHS), federal information processing standards 180-1; 1995.
NIST, secure hash standard (SHS), federal information processing standards 180-2; 2002.
Preneel B, Bosselaers A, Dobbertin H. RIPEMD-160: a strength- ened version of RIPEMD. In: FSE’96, LNCS, vol. 1039; 1997. p. 71–82.
Dobbertin H. Cryptanalysis of MD4. J Cryptol 1998;11(4):253–71.
Wang X, Feng D, Lai X, Yu H. Collisions for Hash Functions MD4, MD5, HAVAL-128 and RIPEMD. Cryptology ePrint archive, report 2004/199; 2004.
Wang X, Yin YL, Yu H. Finding Collisions in the Full SHA-1. In: CRYPTO’05, LNCS, vol. 3621; 2005. p. 17–36.
Matusiewicz K, Contini S, Pieprzyk J. Weaknesses of the FORK- 256 compression function. Cryptology ePrint archive, report 2006/ 317; 2006.
Mendel F, Lano J, Preneel B. Cryptanalysis of reduced variants of the FORK-256 hash function. In: CT-RSA’07, LNCS, vol. 4377; 2006. p. 85–100.
Danda M. Design and analysis of hash functions. Master thesis, Victoria University; 2007.
Saarinen MO. A meet-in-the-middle collision attack against the new FORK-256. In: INDOCRYPT’07, LNCS, vol. 4859; 2007. p. 10–17.
Preneel B. The first 30 years of cryptographic hash functions and the NIST SHA-3 competition. In: RSA’10, LNCS, vol. 5985; 2010. p. 1–14.
Preneel B. The NIST SHA-3 competition: a perspective on the final year. In: AFRICACRYPT’11, LNCS, vol. 6737; 2011. p. 383–6.
