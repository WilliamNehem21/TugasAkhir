Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 305 (2014) 67–83
www.elsevier.com/locate/entcs

Extending Propositional Dynamic Logic for Petri Nets 1
Bruno Lopes a,2 Mario Benevides b,3
Edward Hermann Haeusler a,4
a Departamento de Inform´atica Pontif´ıcia Universidade Cat´olica do Rio de Janeiro
b Programa de Engenharia de Sistemas e Computa¸c˜ao Universidade Federal do Rio de Janeiro

Abstract
Propositional Dynamic Logic (PDL) is a multi-modal logic used for specifying and reasoning on sequential programs. Petri Nets is a widely used formalism to specify and analyze concurrent programs with a very intuitive graphical representation. Petri-PDL is an extension of PDL, whose programs are Petri Nets, which combines the advantages of both formalisms using a compositional and structural approach to deal with Petri Nets.
In this work we present an extension of Petri-PDL to deal with Stochastic Petri Nets, the DS3 logic. This system is an alternative to model performance evaluation in a compositional and structural approach. We discuss about its soundness, decidability and completeness regarding our semantics and present a proof of EXPTime-completeness of its SAT problem. A usage example is presented.
Keywords: Dynamic Logic, Petri Nets, Stochastic Petri Nets, program verification


Introduction
Random phenomena are ubiquitous to our everyday experience. Weather changing and equipment failures, mostly unpredictable, are familiar to anyone. Real-time and fault-tolerant computer systems have to consider these randomness phenomena and should be designed taking some environmental parameters into account. The designer of old multi-user backuping system considered the failure probability of the hard-disks logical (tracks and sectors) and physical (wr-heads) components to build a fault-tolerant driver able to provide a quality of service according to the

1 This work was supported by the Brazilian research agencies CNPq and CAPES. The reviewers provided useful suggestions which led to an improved version of the first manuscript.
2 Email: bvieira@inf.puc-rio.br
3 Email: mario@cos.ufrj.br
4 Email: hermann@inf.puc-rio.br

http://dx.doi.org/10.1016/j.entcs.2014.06.006
1571-0661/© 2014 Elsevier B.V. All rights reserved.

requirements. Of course this can be one of the simplest example in this field of modelling and performance evaluation 5 . This article describes our proposal of joining a logical formalism (Dynamic Modal Logic) and a Mathematical Modelling tool for describing Random phenomena (Stochastic Petri Nets) by allowing that a marked Stochastic Petri Net π and a property α describe a requirement ⟨π⟩α meaning that at least one expected behaviour of π satisfy α, or, [π]α meaning that every behaviour of π satisfy α. The verification of these properties can be viewed as a kind of qualitative evaluation of the probabilistic parameters determined for π at the designing phase.
We denote by DS3 the logic proposed here, where the ordinary Petri Net pro- grams are replaced by Stochastic Petri Net programs. We discuss soundness, decid- ability and completeness problems for DS3 with respect to our semantics and we present a polynomial reduction of the two-person corridor tiling game to DS3 SAT, hence showing its EXPTime-completeness.
In section 2 we present the theoretical and conceptual background motivating our proposal and briefly compare it with other approaches. Section 3 presents the technical Petri Net background; section 4 presents the DS3 logic and discuss its soundness, decidability and completeness with respect to our semantics and section 5 presents the two-person corridor tiling game reduction. A usage example is presented in section 6 and the conclusions and further work are in section 7.
Theoretical Background
Stochastic process is a mathematical modelling tool largely used for describing phe- nomena of a probabilistic nature as a function of time as a mandatory parame- ter [22]. Taking for free the definition of a probability space and random vari- able [15], a stochastic process {Y (t) : t ∈ [0, ∞)} is a family of random variables defined over the same probability space and taking values in the same state space. Thus, a stochastic process can be understood as a family of functions of time that raise sample paths, i.e. trajectories in the state space. General stochastic processes can be quite complex. Among them, those that have no memory of the trajectory to reach the present state 6 , also called Markov processes, have been widely consid- ered for modelling computational processes. Markov processes with a discrete state space are denominated Markov chains. If the time is continuous, the term Contin- uous Time Markov Chain (CTMC) is commonly used. CTMC are natural models of computing systems considered in environments subject to randomness (internal or external). CMTCs compete with Queueing networks as tools for modelling and performance evaluation. However, the later does not provide clean mechanisms to describe synchronization, blocking and forking (i.e. consumer splitting). On the other hand, Petri Nets are quite good on describing these last mentioned aspects of a system. The proposal of Stochastic Petri Nets (SPN) brought an equilibrium

5 The subarea of computer science that studies and develops tools and methods to help modelling and evaluating computer systems subject to work taking randomness phenomena into account.
6 Mathematically one require that Pr(Y (t) ≤ y : Y (tn)= yn ...Y (t0)= y0 )= Pr(Y (t) ≤ y : Y (tn)= yn), for t > tn ··· > t1 > t0.

between the modelling and the performance evaluation phases of systems designing. In [24] it is proposed SPNs, in order to avoid the translation of queueing networks defined in the modelling phase into complex CTMCs for the evaluation phase. In section 3 the definition of SPN requires that transitions are enabled according an exponential probability distribution (in fact a negative exponential distribution). This requirement is essential in order to ensure that the Stochastic process natu- rally derived from an SPN is a CTMC [27].
Dynamic Logics [9,13] are often used to deal with program reasoning and Propo- sitional Dynamic Logic (PDL) [9] is one of its most well-known variants. In PDL each program P corresponds to a modality [P ]. The formula [P ]α means that, af- ter every possible running of P , α holds, considering that P stops. Thus, ⟨P⟩α, a shortened form for ¬[P ]¬α), indicates that the property holds after some possible running of P . Dynamic Logics provide a large amount of systems and tools and can be used in Model Checking [5,11,17].
Petri Nets are not only a widely used formalism to deal with concurrent programs but also have an intuitive graphical interpretation. Taking advantage of this, Petri- PDL [1,18] replaces the conventional PDL programs by Marked Petri Net programs. So if π is a program with markup s, then the formula ⟨s, π⟩ϕ means that after the running of this program designed by its Petri Net which initial markup is s, ϕ will eventually be true (also possible a 2-like modality replacing the tags by brackets). As we have already discussed, ordinary Petri Nets are not able to express ran- dom phenomena in a precise way. For example a two processor system with a shared memory where each processor has a different clock cannot be modelled by an or- dinary Petri Net. This scenario may be taken as a problem of real time, or as a problem of productiveness. The latter turns out to be a probabilistic problem that can be modelled by a CTMC or by an SPN in a more elegant way. Thus, using probability attached to the transitions in the Petri Net is a way to obtain SPNs. The Dynamic Logic derived from this extended Petri Nets is our proposal. Stochastic Petri Nets are, hence, obtained by associating an exponentially distributed random variable to each ordinary Petri Net transition [12,26]. This random variable will control the firing rate of its transition. A transition will only fire when it is enabled and its timing achieves zero. This formalism has been used to deal with non-linear
time-modelling [3,14,21].
There are some other well-known stochastic approaches to PDL, but we be- lieve that the fact that the probabilistic feature present in each of these formalism was added in a non-structured way. We say that a probabilistic formalism is more structure than other, whenever the first has cleaner Markovian structures than the other. In this sense, the system P-Pr(DL) [6,7] which has no finite axiomatiza- tion, do not allow boolean combination of propositional variables and is defined only for regular programs is the less structured. Pr(DL) [8] which has the same limitations as P-Pr(DL) and is undecidable compares to the former. The system PPDL [16] computes the probability of a proposition being true in some state but the program is replaced by a measurable function, that is, its stochastic component is not compositional. Finally, PPDL> r [32] can only describe situations where

some probability is greater then a constant r ∈  and PPDL> 0 [31] that can only describe situations where some probability is greater then zero, showing how the parameters of the modelling impose restriction in the queries, reverting completely the role of a model in a formal verification.
Background
In this section, we present the Petri Net systems used throughout this work and a brief review of Stochastic Petri Nets.

Petri Net convention system
Petri-PDL uses the Petri Net model defined by de Almeida and Haeusler [4]. In this model there are only three types of transitions which define all valid Petri Nets due to its compositions. These basic Petri Nets are as in figure 1.

X

Z	X
X	Y


Type 1: t1
Y
Type 2: t2
Z
Type 3: t3

Fig. 1. Basic Petri Nets

To compose more complex Petri Nets from these three basic kinds of compo- sition, it is used a gluing procedure [4]. As an example, take the Petri Net of figure 2(a). It is a composition of the basic Petri Nets of figures 2(b), 2(c) and 2(d), where the same place names indicate that when gluing they will collapse.

Stochastic Petri Nets
A Stochastic Petri Net (SPN) [12,20,23,26] is a 5-tuple P = ⟨P, T, L, M0, Λ⟩, where P is a finite set of places, T is a finite set of transitions with P ∩ T = ∅ and P ∪ T /= ∅ and L is a function which defines directed edges between places and transitions and assigns a w ∈  , a multiplicative weight for the transition, as L : (P × T ) ∪ (T × P ) →  (in this work we assume w = 1 for all edges), M0 is the initial markup and Λ = λ1, λ2,..., λn the firing rates of each transition.
In an SPN the firing is determined by the markups and by the firing rate. To each transition ti ∈ T is associated a unique random variable with an exponential distribution with parameter λi ∈ Λ.
In the initial markup (M0) each transition getsa firing delay through an occur- rence of the random variable associated to it. Each firing delay is marking-dependent and the transition ti ∈ T firing rate at marking Mj is defined as λi(Mj) and its av- erage firing delay is [λi(Mj)]−1. After a firing, each previously non-marking-enabled


b
c	c

Composed Petri Net
Basic Petri Net Type 1


a	b
c	c

Basic Petri Net Type 2
Basic Petri Net Type 3

Fig. 2. Example of Petri Net composition with its basic Petri Nets
transition gets a new firing delay by sampling its associated random variable. A transition previously marking-enabled that keeps marking-enabled has its firing de- lay decreased in a constant speed. When a transition firing delay reaches zero, this transition fires.
We define the preset of t ∈ T , denoted by •t, as the set of all sk ∈ S that origins an edge to t. The postset of t, denoted by t• is defined as the set of all sl ∈ S that t origins an edge to. We say that a transition t is enabled if, and only if, there is at least one token in each place p ∈ •t.
Given a markup Mj of a Petri Net, a transition ti is enabled on Mj if and only if ∀x ∈ •ti, Mj(x) ≥ 1 and λi(Mj)= min(λ1(Mj), λ2(Mj),..., λn(Mj)), where •ti is the preset of ti. A new markup generated by setting a transition which is enabled is defined in the same way as in a Marked Petri Net, i.e.
⎧	•	•
Mj+1(x)= ⎪⎨ Mj(x)+1 ∀x ∈ t• \ •t .	(1)
⎪⎪⎩ Mj(x)	other case
A new firing delay for a transition ti for a markup Mj is defined as:
if ti fires then a new occurrence of the random variable associated with it is the new firing delay;
if ti was disabled and has just been enabled then a new occurrence of the random variable associated with it is the new firing delay;
other case, the value of the firing delay of ti must be decreased.

That is:
⎧⎪

⎧⎪ ⎧⎨ ∀x ∈ •t ,M (x) ≥ 1

i	j
⎪	⎪
⎪	⎪⎨ ⎩ λi(Mj) ≤ min(λ1(Mj),..., λn(Mj))

λ (M
) ⎪⎨ = newe(λi) if ⎪ or
(2)

i	j+1
⎪
⎪ ⎧⎨ ∃x ∈ •t ,M (x) < 1

i	j
⎪	⎪
⎪	⎩ ⎩ ∀x ∈ •ti, Mj+1(x) ≥ 1
⎪⎪⎩ < λi(Mj)	other case
where newe(λ) denotes a new occurrence of the random variable exponentially dis- tributed with parameter λ associated to ti.
The minimum of two random variables with parameters, respectively, λ1 and λ2, is a random variable with exponential distribution of parameter λ1 + λ2, the sojourn time in a marking Mj is a random variable exponentially distributed with mean

⎡	⎤−1
⎣	λi(Mj)⎦
.	(3)

i:∀k∈•ti,Mj (k)>0
As all random variables have an exponential distribution, then it is possible to compute the probability of an enabled transition ti to have the minimum firing delay (i.e. the probability of ti fires immediately) at a marking Mj:
λi(Mj)
Pr(ti | Mj)=	Σ λ (M ) .	(4)
k	j
k:∀l∈•tk,Mj (l)>0
To illustrate the usage of Stochastic Petri Nets, we can model a two processes system that share a resource. Process 1 is I/O bound and process 2 is CPU bound, as in figure 3(a). The great difference in the amount of requests of input can be modelled by setting the Λ values (i.e. λ1 > λ3). Figure 3(b) presents a simple parallel system modelled in a SPN where the tokens denote processes. The Λ values determines if it would be faster in some of the ways. The probability of a process goes from q1 to q2 instead of to q4 can be computed according to equation (4).
The DS3 logic
The language of DS3 is the same than the language of Petri-PDL. The difference is that the ordinary Petri Net program will be replaced by a Stochastic Petri Net program (more details on how to deal with its behaviour in the frame definition 4.4); it consists of
Propositional symbols: p, q. . . , where Φ is the set of all propositional symbols
Place names: e.g.: a, b, c, d . . .








q4	q5
q1

q2	q3
(a) A two processes system	(b) A simple parallel system
Fig. 3. Stochastic Petri Net examples
Transition types: T1 : at1b, T2 : abt2c and T3 : at3bc, each transition name has a unique type
Petri Net Composition symbol: ⊙
Sequence of names: S = {ϵ, s1, s2,... }, where ϵ is the empty sequence. We use the notation s < sj to denote that all names occurring in s also occur in sj.
Definition 4.1 Programs:
We use π to denote a Stochastic Petri Net program and s a sequence of names (the markup of π).
Basic programs: πb ::= at1b | at2bc | abt3c where ti is of type Ti,i = 1, 2, 3
Stochastic Petri Net Programs: π ::= s, πb | π ⊙ π
Definition 4.2 Formula
A Ð£3 formula is defined as: ϕ = p |T| чϕ | ϕ Λ ϕ | ⟨s, π⟩ϕ.
We use the standard abbreviations ⊥ ≡ чT, ϕ V φ ≡ ч(чϕ Λ чφ), ϕ → φ ≡ ч(ϕ Λ чφ) and [s, π]ϕ ≡ ч⟨s, π⟩чϕ, and π is a Stochastic Petri Net program with markup s.
The firing of a transition in Ð£3 is defined according to the firing function in definition 4.3.
Definition 4.3 We define the ﬁring function f : S × πb → S as follows
f (s, at b)= ⎧⎨ s1bs2, if s = s1as2	• f (s, at bc)= ⎧⎨ s1s2bc, if s = s1as2

⎩	ϵ, if a /< s
⎧⎨ s cs s , if s = s as bs
⎩	ϵ, if a /< s
f (ϵ, η) = ϵ, for all petri nets pro-

⎩	ϵ, if a, b /< s
Definition 4.4 Ð£3 Frame
A frame for Ð£3 is a 5-tuple 73 = ⟨W, Rπ, M, Π, Λ, δ⟩ where
W is a non-empty set of states

M : W → S
Π is a finite Stochastic Petri Net such that for any program π used in a modality,
π ∈ Π (i.e. π is a subnet of Π)
Λ(π)= ⟨λ1, λ2,..., λn⟩ is the sequence of  + values denoting the fire rate of each transition of π1 ⊙ π2 ⊙· · · ⊙ πn = π ∈ Π
δ(w, π)= ⟨d1, d2,..., dn⟩ is the sequence of firing delays of the program π ∈ Π in the world w ∈ W respectively for each program π1 ⊙ π2 ⊙···⊙ πn = π, satisfying the following conditions (let s = M (w) and r = M (v))
if wRπb v, f (r, πb)= ϵ then δ(w, πb)= δ(v, πb)
if f (s, πb) = ϵ, f (r, πb) /= ϵ and wRπb v, δ(v, πb) is an occurrence of a random variable of exponential distribution with parameter Λ(πb); by the inversion the- orem, δ(v, πb)= ln(1−u) where u is an occurrence of a uniform random variable
b
if f (s, πb) /= ϵ, f (r, πb) /= ϵ and wRπb v, δ(v, πb) < δ(w, πb)
Rα is a binary relation over W , for each basic program α ∈ πb, satisfying the following conditions (let s = M (w))
if f (s, α) /= ϵ and δ(w, α)= min(δ(w, Π)), wRαv iff f (s, α) < M (v)
if f (s, α)= ϵ or δ(w, α) /= min(δ(w, Π)), wRαv iff w = v
we inductively define a binary relation Rη, for each Petri Net program
η = η1 ⊙ η2 ⊙· · · ⊙ ηn, as
Rη = {(w, v) | Eηi, Eu such that si < M (u) and wRηi u
and δ(w, ηi)= min(δ(w, Π)) and uRηv}
where si = f (s, ηi), for all 1 ≤ i ≤ n.
Lemma 4.5 Reflexivity over empty occurrences
For any Petri Net program π, f (ϵ, π)= ϵ, Rє,π is reflexive.
Proof. This proof is straightforward from definitions 4.3 and 4.4.	2
Definition 4.6 Ð£3 Model
A model for Ð£3 is a pair M = ⟨73, V⟩, where 73 is a Ð£3 frame and V is a valuation function V : Φ → 2W .
Definition 4.7 Semantic notion of Ð£3
Let M3 be a model for Ð£3. The notion of satisfaction of a formula ϕ in M3
at a state w, denoted by M3,w H ϕ is inductively defined as follows.
M3,w H p iff w ∈ V(p)
M3,w H T always
M3,w H чϕ iff M3,w K ϕ
M3,w H ϕ1 Λ ϕ2 iff M3,w H ϕ1 and M3,w H ϕ2
M3,w H ⟨s, η⟩ϕ if there exists v ∈ W , wRηv and Pr(M3,v H ⟨s, ηb⟩ϕ | δ(v, Π)) > 0 where ηb is some basic program of η (i.e. after the running of η beginning in the world w, if there is a world v accessible from w by Rη, as in definition 4.4,

where η stops and ϕ holds)
If ϕ is satisfied in all states of M3 then ϕ is valid in M3, denoted by M3 H ϕ; and if ϕ is valid in any model then ϕ is valid, denoted by H ϕ.
Lemma 4.8 Truth Probability of a Modality
The probability of M3,w H ⟨s, πb⟩ϕ is (let s = M (w))
	δ(w, πb)	

Pr(M3,w H ⟨s, πb⟩ϕ | δ(w, Π)) =
Σ δ(w, π ) .

πb∈Π:f(s,πb)/=є
Proof. This proof is straightforward from relation (4) and definition 4.4.	2

Axiomatic System
We consider the following set of axioms and rules, where p and q are proposition symbols, ϕ and ψ are formulas, η = η1 ⊙ η2 ⊙· · · ⊙ ηn is a Petri Net program and π is a Marked Petri Net program.
(PL) Enough propositional logic tautologies
(K) [s, π](p → q) → ([s, π]p → [s, π]q)
(Du) [s, π]p ↔ ч⟨s, π⟩чp
(PC3) ⟨s, η⟩ϕ ↔ ⟨s, η1⟩⟨s1, η⟩ϕ V ⟨s, η2⟩⟨s2, η⟩ϕ V	V ⟨s, ηn⟩⟨sn, η⟩ϕ,
where si = f (s, ηi), for all 1 ≤ i ≤ n.
(R3c ) ⟨s, η⟩ϕ ↔ ϕ, if f (s, η)= ϵ
(Sub) If H ϕ, then H ϕσ, where σ uniformly substitutes proposition symbols by arbitrary formulas.
(MP) If H ϕ and H ϕ → ψ, then H ψ.
(Gen) If H ϕ, then H [s, π]ϕ.
Soundness
The axioms (PL), (K) and (Du) and the rules (Sub), (MP) and (Gen) are standard in the modal logic literature.
Lemma 4.9 Validity of Ð£3 axioms
H PC3
H Rє3 Proof.
H PC3:
Suppose that there is a world w from a model M3 = ⟨Wj, Rη, M, Π, Λ, δ, V⟩
where PC3 is false. For PC3 to be false in w, there are two cases:
Suppose M3,w H ⟨s, η⟩ϕ (1) and
M3,w /H ⟨s, η1⟩⟨s1, η⟩ϕ V ⟨s, η2⟩⟨s2, η⟩ϕ V	V ⟨s, ηn⟩⟨sn, η⟩ϕ (2).

iff there is a world v such that wRηv and Pr(M3,v H ⟨s, ηb⟩ϕ | δ(v, Π)) >
0 (3).
By definition 4.4 Rη = {(w, v) | Eηi, Eu such that si < M (u) and wRηi u and
δ(w, ηi)= min(δ(w, Π)) and uRηv},
from (3) M3,u H ⟨si, η⟩ϕ and M3,w H ⟨s, ηi⟩⟨si, η⟩ϕ, which implies that Pr(M3,w H ⟨s, η1⟩⟨s1, η⟩ϕV⟨s, η2⟩⟨s2, η⟩ϕV· · ·V⟨s, ηn⟩⟨sn, η⟩ϕ | δ(w, Π)) > 0 (4).
From (4) M3,w H ⟨s, η1⟩⟨s1, η⟩ϕV⟨s, η2⟩⟨s2, η⟩ϕV· · ·V⟨s, ηn⟩⟨sn, η⟩ϕ, which contradicts (2).
Suppose M3,w H ⟨s, η1⟩⟨s1, η⟩ϕ V ⟨s, η2⟩⟨s2, η⟩ϕ V· · ·V ⟨s, ηn⟩⟨sn, η⟩ϕ (2), iff for some i (1 ≤ i ≤ n), M, w H ⟨s, ηi⟩⟨si, η⟩ϕ iff
there is a u such that wRηi u, Pr(M3,w H ⟨s, η1⟩⟨s1, η⟩ϕ V ⟨s, η2⟩⟨s2, η⟩ϕ V
··· V ⟨s, ηn⟩⟨sn, η⟩ϕ | δ(w, Π)) > 0 (3)
iff there is a v such that uRηv and M3,v H ϕ (4).
By definition 4.4, (3) and (4) we have wRηv, Pr(M3,w H ⟨s, η1⟩⟨s1, η⟩ϕ V
⟨s, η2⟩⟨s2, η⟩ϕ V· · ·V ⟨s, ηn⟩⟨sn, η⟩ϕ | δ(w, Π)) > 0 and M3,v H ϕ. Thus,
M3,w H ⟨s, η⟩ϕ.
So, PC3 is valid.
H Rє3 :
Suppose that there is a world w from a model M3 = ⟨Wj, Rη, M, Π, Λ, δ, V⟩
where Rє is false. For Rє3 be false in w, there are two cases:
Suppose M3,w H ⟨ϵ, η⟩ϕ (1) and
M3,w /H ϕ (2)
iff there is a v such that wRє,η and Pr(M3,w H ⟨ϵ, η⟩ϕ | δ(w, Π)) > 0. As f (ϵ, η) = ϵ, by lemma 4.5, w = v, wRηw and M3,w H ϕ, which contradicts (2).
Suppose M3,w /H ⟨ϵ, η⟩ϕ (1) and
M3,w H ϕ (2). (1) iff Pr(M3,w H ⟨ϵ, η⟩ϕ | δ(w, Π)) = 0.
As f (ϵ, η) = ϵ, by lemma 4.5, wRηw and, by definition 4.4, M3,w K ϕ, which contradicts (2).
So, Rє3 is valid.	2
Completeness
As pointed out by the work of A. Mazurkiewicz [28,29], logics that deal with Petri Nets are usually incomplete, due to the possibility of a place always increasing its token amount (up to countable infinite). In order to being able to get decidability and completeness results we will restrict ourselves to a subset of Petri Nets we call normalised Petri Nets. Basically, a normalised Petri Net is a Petri Net composed as in section 3.1 which does not accumulate an infinity amount of tokens. From now on, we will consider only normalised Petri Nets.
The completeness proof for Ð£3 is done in the same way as in Blackburn et. al. [2], Harel et. al. [13] and Goldblatt [10].
Theorem 4.10 The Ð£3 logic is complete for normalised SPN programs

Proof. (Sketch)
The first step is to define the Fischer-Ladner closure (FL), where F L(ϕ) denotes the smallest set containing ϕ which is closed under sub formulae.
Then, given a Ð£3 formula ϕ and a Ð£3 model K3 = ⟨W, Rη, M, Π, Λ, δ, V⟩,
we define a new model Kϕ = ⟨W ϕ, Rϕ,M ϕ, Πϕ, Λϕ, δϕ, Vϕ⟩, the filtration of K  by
3	η	3
F L(ϕ), as follows.
The relation ≡ over the worlds of K3 is defined as
u ≡ v ↔ ∀φ ∈ F L(ϕ), Pr(K3,u H φ | δ(u, Π)) = Pr(K3,v H φ | δ(v, Π)) and the relation Rϕ is defined as
[u]Rϕ[v] ↔ (Euj ∈ [u] Λ Evj ∈ [v] Λ ujRηvj).
[u]= {v | v ≡ u}
W ϕ = {[u] | u ∈ W}
[u] ∈ Vϕ(p) iff u ∈ V(p)
M ϕ([u]) = ⟨s1, s2,... ⟩ where for all j ≥ 1, vj ∈ [u] iff M (vj)= sj
Πϕ =Π 
Λϕ =Λ 
δϕ([u], π)= ⟨d1, d2,..., dn⟩ where π = π1⊙π2⊙· · ·⊙πn and di = ∫ i h(δ(u, Π))du
where h is the function that decreases the firing delays, according to the stability process [12].
We show that the number of worlds (states) in a filtered model is finite, hence Ð£3 is decidable. Taking a Canonical Model of Ð£3 (a model where the set of worlds is the set of all maximal consistent sets of formulae) for a language L, CL =
⟨WL, RL,ML, ΠL, ΛL, δL, VL⟩, we prove that [s, π]ϕ ∈ u iff in all v such that uRLv,
π	π
ϕ ∈ v. Then we prove that for any w ∈ WL, w H ϕ iff ϕ ∈ w. Hence we may show
that if H ϕ then ▶ ϕ. The complete proof is available at http://www.tecmf.inf. puc-rio.br/BrunoLopes/Proofs.	2
Corollary 4.11 Petri-PDL completeness
As Petri-PDL is subsumed by the Ð£3 logic in the case where all transitions have the same ﬁring rate, then Petri-PDL is also complete for normalised Petri Nets.

Ð£3 Satisfiability complexity
In this section we present a polynomial reduction of a well-know EXPTime-complete problem to Ð£3 satisfiability (SAT) problem: the two-person corridor tiling game. The Ð£3 SAT problem concerns in determine if there is an interpretation that satisfies a Ð£3 formula.
Lemma 5.1 The satisﬁability of Ð£3 is EXPTime-hard.

Proof. The proof goes by reducing the two-person corridor tiling problem to the
Ð£3 SAT problem, following the methodology of Blackburn et al. [2].
In the two-person corridor tiling game, two players (Eloise and Abelard) must place square tiles in a grid so that colours match (each tile side may have a different color). The players begin with a finite amount of tiles (colours randomly defined) and the beginning of the grid has a special colour (say white) and there is a special tile for Eloise that if placed on column 1 then Eloise wins. When the game begins Eloise should put a tile in the column 0; in his turn, Abelard must place a tile in the following position on the grid. After the end of the row (for an instance n of the game, the game has n columns), the player must place a tile in the next row, column
0. If no player is able to make a valid move or there are no tiles then Abelard wins.
Given an instance T = (n, {T0,..., Ts+1}) of the two-person corridor tiling game where n is the width of the corridor and Ti are the tiling types, we will construct a formula ϕτ such that
If Eloise has a winning strategy, ϕτ is satisfiable at the root of some game tree for T (viewed as a regular Ð£3 model such that for a formula of size n the size of the model will be an where a > 1).
If ϕτ is satisfiable, then Eloise has a winning strategy in the game T .
The formula ϕτ can be computed in time polynomial in n and s.
The formula ϕτ describes the game and states necessary and sufficient conditions for Eloise to win. To construct ϕτ , we will use the following proposition letters:
t0,..., ts+1 to represent the tiles, where t0 is white;
p1,..., pn to indicate where the tile must be placed in the current round;
ci(t), 0 ≤ i ≤ n + 1, ∀t ∈ {t0,..., ts+1} to indicate the type t of previously placed tile in column i;
w to indicate that the current position is a winning position for Eloise.
The General schema of a Petri Net (η) that models the game is in figure 4, where there is one transition similar to R٨ for each row r such that 1 < r < n to denote that a new row has begun. The sequence s denotes the initial markup of the Petri Net, that is, one token in Row1 and the tokens needed to denote the initial set of pieces of Eloise and Abelard. Each place is described bellow.


EC Eloise can play EH Eloise has piece EP Eloise plays
AC Abelard can play
AH Abelard has piece
AP Abelard plays
Col1,. . . ,Coln Each column of the game
Row1,. . . ,Rown Each	row	of	the game

Then, the beginning of the game is described as e Λ p1 Λ c0(white) Λ c1(tI1 ) Λ
··· Λ cn(tIn ) Λ cn+1(white), where Ii, 1 ≤ i ≤ n denotes the initial tiles.
The set of formulas that rules the game is below.



Fig. 4. Schema of a Petri Net for tiling game

If Eloise does not have a piece to play at that moment, it is the turn of Abelard: (([s, η]φ ↔ φ) Λ ч([sj, η]φ ↔ φ) → [sj, η]φ, where sj is sequence who differs from s only by inverting EC and AC, and EH and AH;
If Abelard does not have a piece to play at that moment, it is the turn of Eloise: (([sj, η]φ ↔ φ) Λ ч([s, η]φ ↔ φ) → [sj, η]φ (from now on all formulas have omitted a disjunction with a formula ρ such that ρ differs from the corresponding formula only for changing s to sj in this enumeration of rules);
The referee has already placed white tiles in the columns 0 and n + 1: [s, η] col0(white) Λ coln+1(white);
The players must respect tiles colors: C(tj, t, tjj) ↔ right(tj) = left(T ) and down(Tj) = up(T jj) (e.g. C holds if the tile t can be placed on the right of tj and above tjj, where t, tj and tjj are the propositions correspondents to T , T j and T jj);
Ensures tile matching left and downwards: [s, η]((pi Λ ci—1(tj) Λ c(tjj)) →
[sj, η]  {ci(t) | C(tj, t, tjj)}), where 0 ≤ i ≤ n and, by convention,  ∅ = ⊥
Ensures matching of tiles placed on column n with white corridor: [s, η](p  →
[sj, η]  {cn(t) | right(T )= white})
The first position is a winning position for Eloise: w.
As Eloise has a winning strategy, then: [s, η](w → (c1(ts+1) V ([sj, η]чw) V
([sj, η]w))).
To ensure that the game is finite (e.g. if the game has no end, Abelard wins), the game is limited to N = ns+2 steps with no repetition, so: [s, η](counter = N ) → [sj, η]чw.
Then, ϕτ is the conjunction of all these formulas.
If Eloise has a winning strategy then there is a game tree such that ϕτ is sat- isfiable at its root seen as a Ð£3 model. So if Eloise has a winning strategy she can win in at most N steps. For a Ð£3 model M corresponding to this at-most-N

steps strategy it is straightforward to check ϕτ satisfiability at the root of M. Otherwise, if M,v H ϕτ , then Eloise has a winning strategy, encoded in M,
in the game T . As w is satisfied in v, Eloise can keep moving through winning positions that she is always able to choose. Hence if counter = N (e.g. the counter has reached), [s, η]чw is satisfied, so there are no more winning positions, but as c1(ts+1) is satisfied, so the winning tile was placed in the first step and Eloise has already won. The detailed list of formulas that are satisfied or not in each case is available at http://www.tecmf.inf.puc-rio.br/BrunoLopes/Proofs.
As it is possible to encode any m ≥ 2 in O(log m + 1) binary digits, N can be encoded in O(log ns+2), which corresponds to (s + 2) log n ≤ (s + 2)n. Then, it is polynomial in s and n. So, the two-person corridor tiling problem is polynomially reducible to the Ð£3 SAT problem. Hence, Ð£3 satisfiability is EXPTime-hard. 2
Theorem 5.2 Ð£3 satisﬁability problem is EXPTime-complete.
Proof. In a given play of the two-person corridor tiling game it is possible to keep track of the current assignments that have appeared. For n tiles there are at most 2n rounds Therefore there is an Alternating Turing Machine operating in polynomial space that determines whether Eloise or Abelard wins this given instance of the game. Since any polynomial time implementation on an Alternating Turing Machine can be done in ordinary Turing Machine using polynomial space, hence at most exponential time [30]. This shows that the upper bound is EXPTime. Concerning the lower bound, we know that tiling is EXPTime-complete [2] and we provided a polynomial reduction from tiling to Ð£3 SAT in lemma 5.1. So Ð£3 SAT problem is in EXPTime and then it is EXPTime-complete.	2
Corollary 5.3 Petri-PDL satisﬁability problem is EXPTime-complete.
Proof. As lemma 5.1 and theorem 5.2 use the same firing rate for all transitions, they are valid to Petri-PDL. So Petri-PDL SAT problem is EXPTime-complete. 2
Usage example
As a usage example take a Kanban system [25], a Just-In-Time based flow control method. The SPN designed in figure 5 represents a “cards” (the K tokens of place BB) flow of resources control with failure for a Kanban cell (a processing unit that may communicate with others). The place IB denotes the Input Buffer where the resources are stored (already with a card) before processed. If everything is OK (i.e. the place OK has a token) and the processing system is not busy (i.e. there is a token in place Id) then the resource is processed (the token goes to place B) and thereafter the resource goes to the Output Buffer (the place OB). The firing of F means that some failure occurred. When R fires it means that the system was repaired. The failure rate and the time to process the resources are controlled by the parameters of the random variables associated with the respective transitions. Modelling this scenario in a Ð£3 model M = ⟨W, Rπ, M, Π, Λ, δ⟩, we have the formula ⟨(s), Kt1IB ⊙ IB,Idt2B ⊙ B,OKt2l ⊙ lt3OK,x ⊙ xt3Id,OB ⊙ OBt1BB ⊙

BB


Fig. 5. A Kanban cell with failure
OKt1Error⊙Errort1Ok⟩ϕ where s is a sequence of names composed by K repetitions of “BB” and “OK” and ϕ is some property that holds after the running of this SPN. Verify if this formula holds in a world w of a model M (i.e. some transition may fires) is equivalent to compute the probability of some basic program fires is greater then zero, which reduces to the equation in lemma 4.8. To verify if it is possible process two resources in parallel, we see that after some of them begin to process (i.e. a token in place B), Id will not be in the sequence of names, so other resources can not begin their process unless a transition that restates a token to Id fires.
Verify if from a world w ∈ W it is possible that some resource begins its pro- cessing is equivalent to compute if Pr(M,w H ⟨r, IB,Idt2B ⊙ B⟩T | δ(w, Kt1IB ⊙ IB,Idt2B⊙B,OKt2l⊙lt3OK,x⊙xt3Id,OB⊙OBt1BB⊙OKt1Error⊙Errort1Ok))    > 0 where r = M (w). Using lemma 4.8 it is equivalent to verify if
δ(Idt2B ⊙ B)
Σ δ(w, π ) > 0
πb∈Π:ƒ(r,πb)/=є
where Π = Kt1IB ⊙ IB,Idt2B ⊙ B,OKt2l ⊙ lt3OK,x ⊙ xt3Id,OB ⊙ OBt1BB ⊙
OKt1Error ⊙ Errort1Ok and πb is a basic transition of Π.
Conclusions and further work
This work extends Petri-PDL, a Dynamic Logic conceived to reasoning about Marked Petri Nets, to a novel Dynamic Logic tailored to reasoning about Marked Stochastic Petri Nets, not only increasing its expressiveness but also presenting a modular and compositional approach to probabilistic modal logic. The system proposed aims to be an alternative to model performance evaluation.
We present a PDL which the programs are Marked Stochastic Petri Nets. Unlike previous approaches, which translate Petri Nets into Dynamic Logic, in our’s we have Stochastic Petri Nets encoded as programs of PDL yielding a new Dynamic Logic tailored to reasoning about Petri Nets in a more natural way.
We present an axiomatization to our logic and prove its soundness and complete- ness. Finally, we establish the decidability and finite model property and EXPTime- completeness of its SAT problem and provide usage examples of our approach.

Using Ð£3 it is possible to take advantage of systems that generate SPN auto- matically from UML diagrams [19], used in software specification, to verify proper- ties. The behaviour of the system can also be translated to a CTMC.
Further work include prospecting meaningful case studies to apply in concrete situations, propose a Natural Deduction and a Resolution systems for Ð£3 and investigate Model Checking and Automatic Theorem Prover to Ð£3.

References
Mario Benevides, Edward Haeusler, and Bruno Lopes. Propositional Dynamic Logic for Petri Nets. In
Annals of the 6th Workshop on Logical and Semantic Frameworks, with Applications, 2011.
P. Blackburn, M. de Rijke, and Y. Venema. Modal Logic. Theoretical Tracts in Computer Science. Cambridge University Press, 2001.
J. L. Coleman, W. Henderson, and P. G. Taylor. Product form equilibrium distributions and a convolution algorithm for Stochastic Petri Nets. Performance Evaluation, 26(3):159–180, 1996.
E. S. de Almeida and E. H. Haeusler. Proving properties in ordinary Petri Nets using LoRes logical language. Petri Net Newsletter, 57:23–36, 1999.
Giuseppe De Giacomo and Fabio Massacci. Combining deduction and model checking into tableaux and algorithms for Converse-PDL. Information and Computation, 160:2000, 1998.
Yishai A. Feldman. A decidable Propositional Probabilistic Dynamic Logic. In Proceedings of the fifteenth annual ACM symposium on Theory of computing, STOC ’83, pages 298–309. ACM, 1983.
Yishai A. Feldman. A decidable Propositional Dynamic Logic with explicit probabilities. Information and Control, 63(1-2):11–38, 1984.
Yishai A. Feldman and David Harel. A Probabilistic Dynamic Logic. Journal of Computer and System Sciences, 28(2):193–215, 1984.
Michael J. Fischer and Richard E. Ladner. Propositional Dynamic Logic of regular programs. Journal of Computer and System Sciences, 18:194–211, 1979.
R. Goldblatt. Parallel action: Concurrent Dynamic Logic with independent modalities. Studia Logica, 51:551–558, 1992.
Stefan G¨oller and Markus Lohrey. Infinite state model-checking of Propositional Dynamic Logics. In Zolt´an E´sik, editor, Computer Science Logic, volume 4207 of Lecture Notes in Computer Science, pages 349–364. Springer Berlin Heidelberg, 2006.
P. J. Haas. Stochastic Petri Nets: modelling, stability, simulation. Springer, 2002.
David Harel, Dexter Kozen, and Jerzy Tiuryn. Dynamic Logic. Foundations of Computing Series. MIT Press, 2000.
W. Henderson, D. Lucic, and P. G. Taylor. A net level performance analysis of Stochastic Petri Nets. The Journal of the Australian Mathematical Society. Series B. Applied Mathematics, 31(2):1446–8735, 2009.
Andrey N. Kolmogorov. Foundations of the Theory of Probability. Chelsea Publishing, 1956.
Dexter Kozen. A probabilistic PDL. In Proceedings of the fifteenth annual ACM symposium on Theory of computing, STOC ’83, pages 291–297. ACM, 1983.
Martin Lange. Model checking Propositional Dynamic Logic with all extras. Journal of Applied Logic, 4(1):39–49, 2006.
Bruno Lopes, Mario Benevides, and Edward Hermann Haeusler. Propositional dynamic logic for Petri Nets. Logic Journal of the IGPL, 2014.
Juan Pablo L´opez-Grao, Jos´e Merseguer, and Javier Campos. From UML Activity Diagrams to Stochastic Petri Nets: Application to software performance engineering. SIGSOFT Software Engineering Notes, 29(1):25–36, 2004.

Douglas Lyon. Using Stochastic Petri Nets for real-time nth-order stochastic composition. Computer Music Journal, 19(4):13–22, 1995.
Andrea Marin, Simonetta Balsamo, and Peter G. Harrison. Analysis of Stochastic Petri Nets with signals. Performance Evaluation, 69(11):551–572, 2012.
M. Ajmone Marsan. Stochastic Petri Nets: An elementary introduction. In Grzegorz Rozenberg, editor, Advances in Petri Nets 1989, volume 424 of Lecture Notes in Computer Science, pages 1–29. Springer Berlin Heidelberg, 1990.
M. Ajmone Marsan. Stochastic Petri Nets: an elementary introduction. In Advances in Petri Nets 1989, volume 429 of Lecture Notes in Computer Science, pages 1–29. Springer Berlin Heidelberg, 1990.
M. Ajmone Marsan, G. Balbo, and G. Conte. A class of Generalised Stochastic Petri Nets for the analysis of multiprocessor systems. ACM Transactions On Computer Systems, 2(1), 1984.
M. Ajmone Marsan, Gianfranco Balbo, Gianni Conte, Susanna Donatelli, and Giuliana Franceschinis.
Modelling with Generalised Stochastic Petri Nets. Wiley, 1995.
M. Ajmone Marsan and G. Chiola. On Petri Nets with deterministic and exponentially distributed firing times. In Grzegorz Rozenberg, editor, Advances in Petri Nets 1987, volume 266 of Lecture Notes in Computer Science, pages 132–145. Springer Berlin Heidelberg, 1987.
M. Ajmone Marsan and Giovanni Chiola. On Petri Nets with deterministic and exponentially distributed firing times. In Advances in Petri Nets 1987, pages 132–145. Springer Berlin Heidelberg, 1987.
Antoni Mazurkiewicz. Trace theory. In W. Brauer., W. Reisig, and G. Rozenberg, editors, Petri Nets: Applications and Relationships to Other Models of Concurrency, volume 255 of Lecture Notes in Computer Science, pages 278–324. Springer, 1987.
Antoni Mazurkiewicz. Basic notions of trace theory. In J. W. Bakker, W.-P. Roever, and G. Rozenberg, editors, Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency, volume 354 of Lecture Notes in Computer Science, pages 285–363. Springer, 1989.
Christos Papadimitriou. Computational Complexity. Addison-Wesley, 1994.
M. Tiomkin and J.A. Makowsky. Decidability of finite probabilistic Propositional Dynamic Logics.
Information and Computation, 94(2):180–203, 1991.
M.L. Tiomkin and J.A. Makowsky. Propositional Dynamic Logic with local assignment. Theoretical Computer Science, 36:71–87, 1985.
