

Electronic Notes in Theoretical Computer Science 264 (2010) 25–45
www.elsevier.com/locate/entcs

Categorifying Computations into Components via Arrows as Profunctors
Kazuyuki Asada	Ichiro Hasuo
Research Institute for Mathematical Sciences, Kyoto University, Japan PRESTO Research Promotion Program, Japan Science and Technology Agency http://www.kurims.kyoto-u.ac.jp/~{asada,ichiro}

Abstract
The notion of arrow by Hughes is an axiomatization of the algebraic structure possessed by structured computations in general. We claim that an arrow also serves as a basic component calculus for composing state-based systems as components—in fact, it is a categorified version of arrow that does so. In this paper, following the second author’s previous work with Heunen, Jacobs and Sokolova, we prove that a certain coalgebraic modeling of components—which generalizes Barbosa’s—indeed carries such arrow structure. Our coalgebraic modeling of components is parametrized by an arrow A that specifies computational struc- ture exhibited by components; it turns out that it is this arrow structure of A that is lifted and realizes the (categorified) arrow structure on components. The lifting is described using the first author’s recent characterization of an arrow as an internal strong monad in Prof , the bicategory of small categories and profunctors.
Keywords: algebra, arrow, coalgebra, component, computation, profunctor

Introduction
Arrow for Computation
In functional programming, the word computation often refers to a procedure which is not necessarily purely functional, typically involving some side-effect such as I/O, global state, non-termination and non-determinism. The most common way to organize such computations is by means of a (strong) monad [21], as is standard in Haskell. However side-effect—that is “structured output”—is not the only cause for the failure of pure functionality. A comonad can be used to encapsulate “structured input” [26]; the combination of a monad and a comonad via a distributive law can be used for input and output that are both structured. There are much more additional structure that a functional programmer would like to think of as “computations”; Hughes’ notion of arrow [13] is a general axiomatization of such. 1

1 The word “arrow” is reserved for Hughes’ notion throughout the paper. An “arrow” in a category will be called a morphism or a 1-cell.

1571-0661 © 2010 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2010.07.012

Let C be a Cartesian category of types and pure functions, in a functional programming sense. The notion of arrow over C is an algebraic one: it axiomatizes those operators which the set of computations should be equipped with, and those equations which those operators should satisfy. More specifically, an arrow A is
carried by a family of sets A(J, K) for each J, K ∈ C;
equipped with the following three families of operators arr, >>> and first:
arrf ∈ A(J, K)	for each morphism f : J → K in C,
>>>J,K,L

A(J, K) × A(K, L)
A(J, K)
−→	A(J, L)	for each J, K, L ∈ C,
firstJ,K,L
−→	A(J × L, K × L) for each J, K, L ∈ C;



that are subject to several equational axioms: among them is
(a >>>J,K,L b) >>>J,L,M c = a >>>J,K,M (b >>>K,L,M c)
for each a ∈ A(J, K),b ∈ A(K, L),c ∈ A(L, M ).


(>>>-Assoc)

The other axioms are presented later in Def. 3.1.
The intuitions are clear: presenting an A-computation from J to K by a box J  K , the three operators ensure that we can combine computations in the fol- lowing ways.
(Embedding of pure functions)	J	K

(Sequential composition)	 J
K	,
 >>>J,K,L J


(Sideline)

J


K firstJ,K,L


L	L

The (>>>-Assoc) axiom above, for example, ensures that the following compositions of three consecutive A-computations are identical.


=	J
K
M	(1)



A strong monad T on C induces an arrow AT by: AT (J, K) = C(J, TK) = Kl(T )(J, K). Here Kl(T ) denotes the Kleisli category (see e.g. Moggi [21]). Prior to arrows, the notion of Freyd category is devised as another axiomatization of algebraic properties that are expected from “computations” [19, 23]. The latter notion of Freyd category come with a stronger categorical flavor; in Jacobs et al. [16] it is shown to be equivalent to the notion of arrow.
Remark 1.1 The previous arguments are true as long as we think of an arrow as carried by sets, with A(J, K) being a set. This is our setting. However this is not an entirely satisfactory view in functional programming where one sees A as a type constructor—A(J, K) should rather be an object of C. In this case one can think of several variants of arrow and Freyd category. See Atkey [2]. The discussion later in the beginning of §5 is also relevant.

Arrow as Component Calculus
The current paper’s goal is to settle components as categoriﬁcation of computations, via (the algebraic theory of) arrows. Let us elaborate on this slogan.
A component here is in the sense of component calculi. Components are systems which, combined with one another by some component calculus, yield a bigger, more complicated system. This “divide-and-conquer” strategy brings order to design processes of large-scale systems that are otherwise messed up due to the very scale and complexity of the systems to be designed.
We follow the coalgebraic modeling of components in Barbosa [5]—which is also used in Hasuo et al. [11]—extending it later to an arrow-based modeling. In [5] a component is modeled as a coalgebra of the following type:
c : X −→ T (X × K) J	in Set.	(2)


Here J is the set of possible input to the component; K is that of possible output; X is the set of (internal) states of the component which is a state-
K

based machine; and T is a monad on Set that models the computational effect exhibited by the system. Overall, a coalgebraic component is a state-based system with specified input and output ports; it can be drawn as above on the right.
A crucial observation here is as follows. The notion of arrow in §1.1 is to ax- iomatize algebraic operators on computations as boxes—such as sequential com- position J a K b L . Then, by regarding such boxes as components rather than as computations, we can employ the axiomatization of arrow as algebraic structure on components—a component calculus—with which one can compose components. The calculus is a basic one that allows embedding of pure functions, sequential com- position and sideline. In fact in the second author’s previous work [11] with Heunen, Jacobs and Sokolova, such algebraic operators on coalgebraic components (2) are defined and shown to satisfy the equational axioms.

Categorifying Computations into Components
Despite this similarity between computations and components, there is one level gap between them: from sets to categories. Let A(J, K) denote the collection of coalgebraic components like in (2), with input-type J, output-type K and fixed effect T , but with varying state spaces X. Then it is just natural to include mor- phisms between coalgebras in the overall picture, as behavior-preserving maps (see e.g. Rutten [24]) between components. Hence A(J, K) is now a category, specifi- cally that of T ( × K) J -coalgebras. In contrast, with respect to computations there is no general notion of morphism between them, so the collection A(J, K) of A-computations is a set.
This step of categoriﬁcation [3] is not just for fun but in fact indispensable when we consider equational axioms. Later on we will concretely define the sequential

composition J
K
L of coalgebraic components with matching I/O types; at this

point we note that the state space of the composite is the product X × Y of the

state space X of c and Y of d. Now let us turn to the axiom
(c >>> d) >>>e = c >>> (d >>> e) .	(>>>-Assoc)
Denoting e’s state space by U , the state space of the LHS is (X × Y ) × U while that of the RHS is X ×(Y ×U ). These are, as sets, not identical! Therefore the axiom can be at best satisfied up-to an isomorphism between components as coalgebras (and it is the case, see [11]). We note this phenomenon that the notion of satisfaction of equational axioms gets relaxed—from up-to equality to up-to an isomorphism—is typical with categorification [3].
This additional structure obtained through categorification, namely morphisms between components, has been further exploited in [11]. There it is shown that fi- nal coalgebras—the notion that only makes sense in presence of morphisms between coalgebras—form an arrow that is internal to the “arrow” of components, realiz- ing an instance of the microcosm principle [4, 12]. An application of such nested algebraic structure (namely of arrows) is a compositionality result : the behavior of composed components can be computed from the behavior of each component.
We shall refer to the categorified notion of arrow—carried by components—as
categorical arrow.
Lifting of Arrow Structure via Profunctors
To summarize: computations carry algebraic structure of an arrow; components carry a categorified version of it. The contribution of the current paper is to make the relationship between computations and components more direct. This is by developing the following scenario:
given an arrow A,
we define the notion of (arrow-based) A-component which generalizes Barbosa’s modeling (2),
and we show that these A-components carry categorical arrow structure that is in fact a lifting of the original arrow structure of A.
Therefore: we categorify A-computations to A-components.
A weaker version of this scenario has been already presented in [11]. However the last lifting part was obscured in details of direct calculations. What is novel in this paper is to work in Prof , the bicategory of profunctors. In fact, it is one theme of this paper to demonstrate use of calculations in Prof .
The starting point for this profunctor approach is [16]. There the arr, >>>- fragment of arrow (without first) is identified with a monoid in the category [Cop × C, Set] of bifunctors, where the latter is equipped with suitable monoidal structure. This means—in terms of profunctors that will be described in §2—that an arrow A (without first) is a monad in Prof , in an internal sense like in Street [25].
What really made our profunctor approach feasible was a further observation by the first author [1]. There the remaining first operator—whose mathematical nature was buried away in its dinaturality—is identified with a certain 2-cell in Prof . In

fact, this 2-cell is a strength in an internal sense. Therefore an arrow (with its full set of operators, arr, >>> and first) is a strong monad in Prof . This observation pleasantly parallels the informal view of arrows as generalization of strong monads.
Organization of the Paper
In §2 we will introduce the necessary notions of dinatural transformation, (co)end and profunctor, in a rather leisurely pace. The two forms of the Yoneda lemma—the end- and coend-forms—are basic there. The materials there are essentially extracted from Kelly [17], which is a useful reference also in the current non-enriched (i.e. Set-enriched) setting. In §3 we follow [1, 16] and identify an arrow with an internal strong monad in Prof , setting Prof as our universe of discourse. In §4 we generalize Barbosa’s coalgebraic components into arrow-based components. The main result— arrow-based components form a categorical arrow—is stated there. Its actual proof is in the subsequent §5 which is devoted to manipulation of 2-cells in Prof .
Categorical Preliminaries
End and Coend
In the sequel we shall often encounter a functor of the type F : Cop×C → D, where a category C occurs twice with different variance. Given two such F, G : Cop ×C → D, a dinatural transformation ϕ : F ⇒ G consists of a family of morphisms in D
ϕX : F (X, X) −→ G(X, X)	for each X ∈ C
which is dinatural : for each morphism f : X → X' the following diagram commutes.


F (f,X)
F (X',X)
ϕ
F (X, X)  G (X, X) G(X,f )
 G (X, X')
(3)

F (X',f ) F (X',X') ϕ	G (X',X')G(f,X')
Note the difference from a natural transformation ψ : F ⇒ G. The latter consists of a greater number of morphisms in D: ψX,Y : F (X, Y ) → G(X, Y ) for each X, Y ∈ C. Two successive dinatural transformations ϕ1 : F1 ⇒ F2 and ϕ2 : F2 ⇒ F3 do not necessarily compose: dinaturality of each does not guarantee dinaturality of the obvious candidate of the composition (ϕ2 ◦ ϕ1)X = (ϕ2)X ◦ (ϕ1)X . This makes it a tricky business to organize dinatural transformations in a categorical manner.
Nevertheless, working with arrows, examples of dinaturality abound.
Dinaturality subsumes naturality: a natural transformation ψ : F ⇒ G : C → D can be thought of as a dinatural transformation, by presenting it as ψ : F ◦ π2 ⇒ G ◦ π2 : Cop × C → D. Here π2 : Cop × C → C is a projection.
(Co)end is the notion that is obtained by replacing naturality (for (co)cones) by dinaturality, in the definition of (co)limit. Precisely:
Definition 2.1 (End and coend) Let C, D be categories and F : Cop × C → D be a functor.

An end of F consists of an object  X∈C F (X, X) in D together with projections
πX :	X∈C F (X, X) −→ F (X, X)	for each X ∈ C
such that, for each morphism f : X → X' in C, the following diagram commutes.


∫X F (X, X)
πX'

πX
F (X',X') F (f,X')
 F (X, X')
F (X, X) F (X,f )

In other words: the family {πX }X∈C forms a dinatural transformation from the constant functor Δ( X F (X, X)) to the functor F . An end is defined to be a universal one among such data: given an object Y ∈ D and a dinatural transfor- mation ϕ : ΔY ⇒ F , there is a unique morphism f : Y → X F (X, X) such that πX ◦ f = ϕX for each X ∈ C.
A coend of F is a dual notion of an end. It consists of an object X∈C F (X, X) in D together with injections ιX : F (X, X) → X F (X, X) for each X ∈ C. Its universality, together with that of an end, can be written as follows.

f : Y −→ ∫
F (X, X)
f : ∫ X F (X, X) −→ Y





(Co)ends need not exist; they do exist for example when C is small and D is (co)complete. See below.
The reader is referred to Mac Lane [20, Chap. IX] for more on (co)ends. Described there is the way to transform a functor F : Cop ×C → D into F § : C§ → D, in such a way that the (co)end of F coincides with the (co)limit of F §. Therefore existence of (co)ends depends on the (co)completeness property of D. In fact (co)end subsumes (co)limit, just as dinaturality subsumes naturality. Therefore a useful notational convention is to denote (co)limits also as (co)ends: for example ColimX FX as X FX.
Recalling the construction of any limit by a product and an equalizer [20, §V.2], an intuition about an end	F (X, X) is as follows: it is the product	F (X, X)
which is “cut down” so as to satisfy dinaturality. Dually, a coend X F (X, X) is the coproduct  X F (X, X) quotiented modulo dinaturality.
Two Forms of the Yoneda Lemma
A typical example of an end arises as a set of (di)natural transformations. Given a small category C and functors F, G : Cop × C → Set, we obtain a bifunctor
[F (+, −), G(−, +)] : Cop × C −→ Set ,	(X, Y ) '−→ [F (Y, X), G(X, Y )] .	(4)
Here [S, T ] denotes the set of functions from S to T , i.e. an exponential in Set. Note the variance: since [−, +] is contravariant in its first argument, the variance of

arguments of F is opposed in (4). Taking this functor (4) as F in Def. 2.1, we define an end X [F (X, X), G(X, X)]. Such an end does exist when C is a small category, because Set has small limits (hence small ends).
Proposition 2.2 Let us denote the set of dinatural transformations from F to G
by Dinat(F, G). We have a canonical isomorphism in Set:
Dinat(F, G) −=→ ∫  [F (X, X), G(X, X)] .
X


Proof It is due to the following correspondences.
1 →  X [F (X, X) ,G (X, X)]
1 → [F (X, X) ,G (X, X)] dinatural in X F (X, X) → G (X, X) dinatural in X



(†)
(‡)

Here (†) is by Def. 2.1; dinaturality is preserved along (‡) because of the naturality of Currying.	□
The composite Dinat(F, G) →∼=	[F (X, X), G(X, X)]  π	[F (X, X), G(X, X)] car-
X	−→
ries a dinatural transformation ϕ to its X-component ϕX .
Since dinaturality subsumes naturality (§2.1), we have an immediate corollary:
Corollary 2.3 Let C be a small category and F, G : C → Set. By Nat(F, G) we denote the set of natural transformations F ⇒ G. We have
Nat(F, G) −=→ ∫ [FX, GX] .	□
X
The celebrated Yoneda lemma reduces the set Nat(C(X,  ),F ) of natural trans- formations into FX (see e.g. [6, 20]). Interpreted via Cor. 2.3, it yields:
Lemma 2.4 (The Yoneda lemma, end-form) Given a small category C and a func- tor F : C → Set, we have a canonical isomorphism

∫X'∈C
[C (X, X') ,FX'] −∼=→ FX .	□

The lemma becomes useful in the calculations below: it means an end on the LHS “cancels” with a hom-functor occurring in it.
From the end-form, we obtain the following coend-form. Its proof is straightfor- ward but illuminating. It allows us to “cancel” a coend with a hom-functor inside it.
Lemma 2.5 (The Yoneda lemma, coend-form) Given a small category C and a functor F : C → Set, we have a canonical isomorphism
∫ X'∈C FX' × C(X',X) −∼=→ FX .

Proof We have the following canonical isomorphisms, for each S ∈ Set.
 ∫ X' FX' × C(X',X) , S  →∼= ∫	 FX' × C(X',X) , S	(†)
X'
∼= ∫	'	'

Here (†) is because the hom-functor [ , S] turns a colimit into a limit [20, §V.4], hence a coend into an end. Obviously the composite isomorphism is natural in S; therefore we have shown that
y ∫ X' C(X',X) × FX'  −=→ y(FX)	: C −→ Set ,	(5)
where y : Cop → [C, Set] is the (contravariant) Yoneda embedding. By the Yoneda lemma the functor y is full and faithful; therefore it reflects isomorphisms. Hence (5) proves the claim.	□


Profunctor
Definition 2.6 Let C and D be small categories. A profunctor
P from C to D is a functor P : Dop × C → Set. It is denoted

		C −−ı→ D	 Dop × C −→ Set

by P : C −→ı D (see on the right).
The notion of profunctor is also called distributor, bimodule or module. For more
detailed treatment of profunctors see e.g. Benabou [7] and Borceux [9].
There are principally two ways to understand profunctors. One is as “general- ized relations”: profunctors are to functors what relations are to functions. The

differences between a profunctor P : C →−ı
D and a relation R : S →−ı
T are as follows.

A relation is two-valued: for each element s ∈ S and t ∈ T , R(s, t) is either empty (i.e. (s, t) /∈ R) or filled (i.e. (s, t) ∈ R). In contrast, a profunctor is valued with arbitrary sets, that is, P (Y, X) ∈ Set.
The functoriality of a profunctor P induces action of morphisms in C and D. For illustration let us depict an element p ∈ P (Y, X) by a box Y p X . Given two morphisms g : Y ' → Y in D and f : X → X' in C, functoriality of P yields
an element P (g, f )(p) ∈ P (Y ',X') (note the variance); the latter element is best depicted as follows.
(6)
The latter point motivates a different way of looking at profunctors: as general- ized modules as in the theory of rings. These generalized modules are carried by a family of sets {P (Y, X)}X∈C,Y ∈D, with left-action of C-arrows and right-action of D-arrows. Also notice the similarity between (6) and the diagrams in §1 for compu- tations/components. It is indeed this similarity that allows us to formalize arrows as certain profunctors (§3).
Definition 2.7 (Composition of profunctors) Given two successive profunctors P :

C →−ı
D and Q : D →−ı
E, their composition Q ◦ P : C →−ı
E is defined by the following

coend. For U ∈ E and X ∈ C,
(Q ◦ P )(U, X)=	Y ∈D Q(U, Y ) × P (Y, X) .
For profunctors as generalized relations, this composition operation corresponds to a relational composition: (S ◦ R) (x, z) if and only if ∃y. R (x, y) ∧ S (y, z) . For profunctors as modules, it corresponds to tensor product of modules. In any case, recall from §2.1 that the coend in Def. 2.7 is a coproduct  Y Q(U, Y ) × P (Y, X)—a
equivalence . This equivalence (dictated by dinaturality) intuitively says: the choice of intermediate Y ∈ D does not matter. Specifically, the equivalence is generated by the following relation; here f : Y → Y ' is a morphism in D.

  U

, Y '
X      U

Y	,
X   .

An appropriate notion of morphism between parallel profunctors	P
P, Q : C −→ı  D is provided by a natural transformation ψ : P ⇒ Q,

where P and Q are thought of as functors P, Q : Dop ×C → Set. All these data can be organized in a “2-categorical” manner as on the
C
D
Q

right. A problem now is that (horizontal) composition of 1-cells (i.e. profunctors) is not strictly associative: due to Def. 2.7 of composition by coends and products, associativity can be only ensured up-to coherent isomorphisms. The same goes for unitality; therefore profunctors form a bicategory (see [9]) instead of a 2-category.
Definition 2.8 (The bicategory Prof ) The bicategory Prof has small categories as 0-cells, profunctors as 1-cells and natural transformations between them as 2-cells.
The identity 1-cell C →−ı C is given by the hom-functor C(−, +) : Cop × C → Set; it
is the unit for composition because of the Yoneda lemma, coend-form (Lem. 2.5).
Some Properties of Prof
Here we describe some structural properties of Prof that will be exploited later, namely the direct image of a functor and tensor products in Prof . For the former, [7] is a principal reference; Fiore’s notes [10] are not specifically on profunctors but provide useful insights into relevant mathematical concepts.

A function f : S → T induces the direct image relation f∗ : S −→ı
T , defined by:

f∗(s, t) iff t = f (s). There is an analogous construction from functors to profunctors.

Definition 2.9 Let F : C → D be a functor between small categories. It gives rise to
the direct image profunctor F∗ : C −−ı→ D	by F∗(Y, X)= D(Y, FX) .
The mapping ( )∗ also applies to natural transformations in an obvious way; this determines a pseudo functor (see e.g. [9]) ( )∗ : Cat → Prof that embeds Cat in Prof .

Notations 2.10 Throughout the rest of the paper, the direct image F∗ of a functor
F shall be simply denoted by F . The identity profunctor id : C −→ı C—that is the
hom-functor—will be often denoted by C : C −→ı C.
The Cartesian product operator × in Cat lifts Prof ; given profunctors F : C→−ı
C' and G : D −→ı D', we define
F × G : C × D→−ı C' × D'	by	(F × G)(X',Y ', X,Y )= F (X',X) × G(Y ',Y ) .  (7)
The symbol × occurring in the last denotes the Cartesian product in Set. The lifted operator × in Prof makes it a “monoidal bicategory,” a notion whose precise definition involves delicate handling of coherence. We shall not do that in this paper. Nevertheless, we will need the following property.
Lemma 2.11 The operation × on Prof is bifunctorial: that is, given four profunc-

P
tors C→−ı
Q
D→−ı
P '
E and C →−ı
Q'
D' →−ı
E' we have (Q ◦ P )×(Q' ◦ P ') →∼=
(Q×Q') ◦ (P ×P ').

Proof This is due to the Fubini theorem for coends. See [20, §IX.8]	□
It is obvious that the operator × acts also on 2-cells (that are natural transfor- mations).
Arrows as Profunctors
We review the results in [1, 16] that identify Hughes’ notion of arrow with a pro- functor with additional algebraic structure.
First we present the precise definition of arrow. Usually it is defined over a Cartesian category C. However, since it is rather the monoidal structure of C that is essential, we shall work with a monoidal category.
Definition 3.1 (Arrow [13]) Given a monoidal category C = (C, ⊗,I), an arrow over C consists of carrier sets {A(J, K)}J,K∈C and operators arr, >>> and first as described in §1.1. The operators must satisfy the following equational axioms.
(a >>> b) >>>c = a >>> (b >>> c)	(>>>-Assoc)
arr (g ◦ f ) = arr f >>> arr g	(arr-Func1)
arr idJ >>>J,J,K a = a = a >>>J,K,K arr idK	(arr-Func2)
firstJ,K,I a >>> arr ρK = arr ρK >>> a	(ρ-Nat)
firstJ,K,L a >>> arr(idK ⊗ f ) = arr(idJ ⊗ f ) >>> firstJ,K,M a	(arr-Centr) (firstJ,K,L⊗M a) >>> (arr αK,L,M ) = (arr αJ,L,M ) >>> first(first a)	(α-Nat)
firstJ,K,L(arr f ) = arr(f ⊗ idL)	(arr-Premon)
firstJ,L,M (a >>> b) = (firstJ,K,M a) >>> (firstK,L,M b) (first-Func)


Here some subscripts are suppressed. The morphism ρ	: K ⊗ I →∼=
K is the right

unitor isomorphism; α denotes an associator isomorphism. The names of the axioms
hint their correspondence to the (premonoidal) structure of Freyd categories [19,23].
Next we introduce the corresponding construct in Prof , which we shall tenta- tively call a Prof -arrow.

Definition 3.2 Let C = (C, ⊗,I) be a small monoidal category. A Prof -arrow
over C is:
a profunctor A : C −→ı C,
equipped with natural transformations arr, >>>, first of the following types:



C

C	C
C ,
A




A
C	C2	A×C	C2
,


where all the diagrams are in Prof ,
subject to the equalities in Table 1. Recall Notations 2.10; for example the profunctor ⟨C,I⟩ in (first-ρ) is the functor ⟨C,I⟩ : X '→ (X, I), embedded in Prof by taking its direct image.

The notion of Prof -arrow is in fact a familiar one: it is an internal strong monad in Prof . Indeed, when one draws the same 2-cells in Cat instead of in Prof — replacing A by T , arr by ηT , >>> by μT and first by str'—the definition coincides with that of strong monad [18, 21]. 2 More specifically, the first two axioms in Table 1 are for the monad laws; and the remaining axioms asserts compatibility of strength with monoidal and monad structure. For example, the axiom (first->>>) interpreted in Cat is read as the commutativity of the following diagram.


T 2X ⊗ Y	str'
μT ⊗Y
T (TX ⊗ Y ) T str' T 2(X ⊗ Y )
μT

TX ⊗ Y	str'	T (X ⊗ Y )


Proposition 3.3 [1] For a monoidal category C that is small, the notion of arrow (Def. 3.1) and that of Prof -arrow (Def. 3.2) are equivalent.

Proof While the reader is referred to [1] for a detailed proof, we shall illustrate a few highlights in the correspondence between the two notions. We shall write arr',
>>>' and first' (with primes) for the three operators of a Prof -arrow (Def. 3.2), to distinguish them from the corresponding operators of an arrow (Def. 3.1).
Let us first observe that a 2-cell first' in Prof gives rise to the first operator in Def. 3.1. The former is an element of the LHS below, where >>> denotes composition


2 The corresponding strength operator str' is of the type str' : TX ⊗ Y → T (X ⊗ Y ), which is slightly different from the usual strength operator that is str : X ⊗ TY → T (X ⊗ Y ).




C



C


A



C	=	C


A





A



C	=	C	A



C
>>> A
C

arr
C
A



(Unit)

=	(Assoc)


C3	A×C×C





A

C3
C
=
⊗
C3	A×C×C	C3
C×⊗
C2 
⊗
C
A



C2	(first-α)

(C,I⟩
A×C
C	(C,I⟩
=
A×C

(first-ρ)



C×C



C2	A×C
⊗
C
A

A






C2	⊗	C
C2



C





A

C




C	(first-arr)

C2 A×C
C2 A×C C2
A×C
A×C



C
=
⊗	(first->>>)



A


Table 1
Equational axioms for Prof -arrow

of profunctors (Def. 2.7).
Nat (⊗ ◦ (A × C))(−, + , + ) , (A ◦ ⊗)(−, + , + )


∼= ∫

∼= ∫


X,K,Y
J,L C(X, J ⊗ L) × A(J, K) × C(L, Y ) ,
U A(X, U ) × C(U, K ⊗ Y )	by Def. 2.7, Def. 2.9 and (7)
 C(X, J ⊗ L) × A(J, K) × C(L, Y ) , ∫ U A(X, U ) × C(U, K ⊗ Y ) 


∼= X,K,Y,J,L  C(X, J ⊗ L),  A(J, K),  C(L, Y ) ,
∫ U A(X, U ) × C(U, K ⊗ Y )	by Currying

by canceling X, Y by Lem. 2.4 and U by Lem. 2.5
∼= NatJ,KDinatL A(J, K), A(J ⊗ L, K ⊗ L)	by Prop. 2.2 and Cor. 2.3.

Therefore a 2-cell first' in Prof gives rise to a family of functions A(J, K) → A(J ⊗ L, K ⊗ L) that is natural in J, K and dinatural in L. This is precisely the type of the first operator in Def. 3.1. The equational axioms of an arrow are indeed satisfied due to those of a Prof -arrow. We note that the axiom (arr-Centr) is satisfied not because of any specific axiom of a Prof -arrow, but because of the dinaturality of first' as a 2-cell in Prof .
For the reverse direction where an arrow induces a Prof -arrow, we have to equip the carrier {A(J, K)}J,K of an arrow with action of morphisms in C, rendering A into a functor Cop × C → Set. This is done with the help of arrow operators. Specifically, A(g, f )(a) := arrf >>>a >>> arrg, that is:
:=	.

Each of the arrow operators yield its corresponding Prof -arrow operator; the lat- ter’s (di)naturality is derived from the arrow axioms. So are the equational axioms for a Prof -arrow.	□
Prop. 3.3 offers a novel mathematical understanding of the notion of arrow. Its axiomatization seems to have stronger justifications than the original one (Def. 3.1) does. It also seems simpler than the treatment of first in Freyd categories which involves technicalities like premonoidal categories and central morphisms. It is this simplicity that is exploited in the rest of the paper.
When the base monoidal category C is symmetric—which is our setting in the sequel—we can obtain another sideline operator second.
Definition 3.4 Let A be an arrow over a small symmetric monoidal category (SMC) C. We define an extra operator second as the following 2-cell in Prof .



C2	C×A	C2
⊗	⇓ second	⊗	:=
C	C
A



⊗
C2	C×A	C2
	
⊗

A


(8)

Here the profunctor ⟨π2, π1⟩ is the direct image of the functor ⟨π2, π1⟩ : C2 → C2, mapping (X, Y ) to (Y, X) (cf. Notations 2.10).
Notations 3.5 In the above diagrams as well as elsewhere, there appear two differ- ent classes of iso 2-cells in Prof . One class is due to the unitality/associativity/symmetry of ⊗ on a monoidal base category C; they are iso 2-cells in Cat embedded in Prof via direct image (§2.4). Such iso 2-cells shall be filled explicitly with the ∼= sign, like the two on the RHS in (8).
The other class is due to the properties of the operation × on Prof , typically Lem. 2.11. Such iso 2-cells will be denoted by empty polygons, like the one on the RHS in (8).
Some calculations like in the proof of Prop. 3.3 reveal that this new operator

realizes a class of functions A(J, K)
secondJ,K,L
−→	A(L × J, L × K), that is graphically


J

secondJ,K,L  L	L


J	K
:=	.

J	K	L	L
Lemma 3.6 Between the first and second operators, the following equality holds.




C2
C3	C×A×C

C3


C2 =
C3	C×A×C
C×⊗	⇓ C×first
C2	C×A
⊗
C3
C×⊗
C2

A	A
Proof Use the equality (first-α) and the coherence for an SMC C.	□

Arrow-Based Components
In this section we develop the scenario in §1.4 in technical terms. First we introduce an arrow-based coalgebraic modeling of components.
Definition 4.1 (A-component) Let A be an arrow on Set, and J, K ∈ Set. An (arrow-based) A-component with input-type J, output-type K and computational structure A is a coalgebra for the functor A(J,  × K): Set → Set. That is,


J
K	as
A(J, X × K)
c	.
X

Here an arrow A is in the sense of Def. 3.1. There the base C of an arrow need not be small; thus we choose (Set, ×, 1) as C. Our modeling specializes to Barbosa’s (2) when we take as A a monad-based arrow AT (§1.1). Our modeling not only generalizes Barbosa’s one but also brings conceptual clarity to the subsequent arguments.
Our goal is to lift the arrow structure of A to the categorical arrow structure of
A-components. Let us make this goal precise.
Definition 4.2 (Categorical arrow) A categorical arrow consists of
a family {A(J, K)}J,K of carrier categories indexed by J, K ∈ Set;
(interpretation of) arrow operators arr, >>> and first (cf. Def. 3.1), namely functors


1
A(J, K) × A(K, L)
A(J, K)
arrf
−→	A(J, K)	for each function f : J → K in Set,
>>>J,K,L
−→	A(J, L)	for each J, K, L ∈ Set,
firstJ,K,L
−→	A(J × L, K × L) for each J, K, L ∈ Set.

Here the category 1 is the one-object and one-arrow (i.e. terminal) category; and
the operators are subject to the arrow axioms in Def. 3.1, up-to isomorphisms. For example, as to the axiom (>>>-Assoc), the following diagram must commute

up-to an isomorphism.
A(J, K) × A(K, L) × A(L, M )	>>>J,K,L×id id×>>>K,L,M		⇓ ∼=


A(J, L) × A(L, M )
>>>J,L,M



(9)

A(J, K) × A(K, M )	>>>J,K,M	A(J, M )
The graphical understanding of a categorical arrow is the same as that of an arrow; see §1.1. In §1.3 we described why it is natural and necessary to require the axioms be satisfied only up-to isomorphisms.
Remark 4.3 Satisfaction up-to isomorphisms raises a coherence issue. The precise coherence condition for categorical arrows is described in [11], in a more general form of coherence for categorical models of FP-theories. Although we shall not further discuss the coherence issue, the calculations later in §5 provide us a much better grip on it than the direct calculations in [11] do.
The notion of categorical arrow in Def. 4.2 could be formalized on any monoidal category C other than Set, although we do not need such additional generality.
The main contribution of this paper is the following result as well as its proof presented using the rest of the paper.
Theorem 4.4 (Main contribution) Let A be an arrow on Set. The categories
{ Coalg(A(J,  × K) )}J,K of A-components carry a categorical arrow.
On top of it, we can appeal to the formalization [11, 12] of the microcosm prin- ciple [4] to obtain the following compositionality result.
Corollary 4.5 In the setting of Thm. 4.4, assume further that for each J, K ∈ Set

the functor A(J,  × K) has a ﬁnal coalgebra ζ	: Z	∼=
× K).

J,K
The family {ZJ,K }J,K is canonically an arrow.
J,K → A(J, ZJ,K

Behaviors by coinduction are compositional with respect to arrow operators. For example, with respect to the operator >>>, this means the following. Given two A-components c : X → A(J, X × K) and d : Y → A(K, Y × L) with matching I/O types, the triangle (∗) below commutes.
A(J, (X × Y ) × L)  A(J, ZJ,L × L)

c>>>d
∼= final

X × Y 	behc>>>d	 Z
>>>Z
ZJ,K × ZK,L
Here c >>>d is “composition of components” using the categorical arrow struc- ture in Thm. 4.4; >>>Z is “composition of behaviors” derived in (i); and behc>>>d is the behavior map for the composed components induced by coin- duction (the square on the top).	□
In [11, 12] it is shown that algebraic structure carried by the categories of coalgebras—like the one in Thm 4.4—can be obtained by:

the same structure on the base categories, and
the lax compatibility of the signature functors with the relevant algebraic struc- ture.
In this case the algebraic structure on the base categories lifts to the categories of coalgebras. We shall follow this path. Restricting the general definitions and results in [11, 12] to the current setting, we obtain the following.
Definition 4.6 Let {FJ,K : Set → Set}J,K be a family of endofunctors, indexed by J, K ∈ Set. It is said to be a lax arrow functor if:
it is equipped with the following natural transformations
Farrf : 1 −→ FJ,K 1 ,
F>>>J,K,L : FJ,KX × FK,LY −→ FJ,L(X × Y ) , FfirstJ,K,L : FJ,K X −→ FJ×L,K×LX ,
each of which is natural in X, Y , for each J, K, L ∈ Set and each f : J → K in
Set;
that are subject to the equations in Table 2, that are parallel to those in Def. 3.1. The diagrams there are all in Set; obvious subscripts are suppressed.
A lax arrow functor therefore looks like an arrow (think of FJ,K(X) in place of
A(J, K)), but it carries an extra parameter (like X, Y or X × Y ) around.
Proposition 4.7 If {FJ,K}J,K is a lax arrow functor, then {Coalg(FJ,K )}J,K is canonically a categorical arrow.
Proof This follows from a general result like [11, Thm. 4.6]. Here we shall briefly illustrate what the categorical arrow {Coalg(FJ,K )}J,K looks like, by describing the sequential composition >>> : Coalg(FJ,K ) × Coalg(FK,L) −→ Coalg(FJ,L). Using F>>> in Def. 4.6 it is defined as follows.



  FJ,K X  FK,LY 


>>>

FJ,L(X × Y )
F>>>

c  ,	d
X	Y
'−→
FJ,K X × FK,LY
c×d
X × Y

The definitions are similar for the other arrow operators. The arrow axioms are satisfied due to the corresponding equational condition on the lax arrow functor.□
This proposition reduces our goal (Thm. 4.4) to showing that the family {A(J,  × K)}J,K is a lax arrow functor. This is what will be shown in the next section, through manipulation of 2-cells in Prof .
Calculations in Prof
There is one technical issue in front of us: the size issue. The 0-cells of Prof are
small categories; the smallness restriction is necessary for composition of profunctors




FJ,K X × FK,LY × FL,M U
F>>> ×id
FJ,L(X × Y ) × FL,M U
F>>>
 FJ,K X × FK,M (Y × U )

F>>>
1
(Farrf ,Farrg ⟩
FJ,K 1 × FK,L1
F>>>


Farr(g◦f )


~

FJ,M
((X × Y ) × U )	=∼
FJ,M
(X × (Y × U ))
FJ,L(1 × 1)
=	FJ,L1


	

FJ,K X
(Farr idJ ,id⟩
(id,Farr idK ⟩
FJ,K X × FK,K 1
F>>>
FJ,K X
Ffirst
(Farr π1 ,id⟩
FJ ×1,J 1 × FJ,K X
F>>>

FJ,J 1 × FJ,K X	id
F>>>
FJ,K (X × 1)
∼=
FJ ×1,K×1 X
(id,Farr π1 ⟩
FJ×1,K (1 × X)

FJ,L
(1 × X)	∼=	F
J,K X
FJ ×1,K×1
X × F
K×1,K 1	∼=

F>>>
FJ ×1,K
(X × 1)	=∼

FJ ×1,KX


	

FJ,K X
Ffirst
Ffirst
FJ ×L',K×L' X
(Farr(J×f ) ,id⟩
FJ,K X
Ffirst
Ffirst
FJ ×L,K×LX
Ffirst

FJ ×L,K×LX
FJ ×L,J ×L' 1
×FJ ×L',K×L' X
FJ ×(L×M ),K×(L×M ) X
(id,Farr α ⟩
F(J ×L)×M,(K×L)×M X
(Farr α,id⟩

(id,Farr(K×f )⟩
FJ ×L,K×LX
×FK×L,K×L' 1
F>>>
F>>>

FJ ×L,K×L' (1 × X)
FJ ×(L×M ),K×(L×M )X
×FK×(L×M ),(K×L)×M 1

F>>>
FJ ×(L×M ),(J ×L)×M 1
×F(J ×L)×M,(K×L)×M X
∼=
FJ ×(L×M ),(K×L)×M (1 × X)

FJ ×L,K×L' (X × 1)
∼=

FJ ×L,K×L' X

FJ ×(L×M ),(K×L)×M
(X × 1) =∼ F
∼=
J ×(L×M ),(K×L)×M X


	

Farrf
1
FJ,K 1
Ffirst
FJ ×L,K×L1
FJ,K X × FK,LY
F>>>
FJ,L(X × Y )
Ffirst×Ffirst



Ffirst
FJ ×M,K×M X × FK×M,L×M Y
F>>>
FJ ×M,L×M (X × Y )



Table 2
Equational axioms for lax arrow functors

to be well-defined (Def. 2.7). However, with Set being not small, the arrow A in Def. 4.1 cannot be a 1-cell in Prof . The arrow A needs to be based on Set so that A(J,  × K) is an endofunctor Set → Set.
In this paper we shall get round of the problem by pretending that Set is small.
There are two possible justifications.
We can resort to the category Ens of classes when it is needed—such as when we take composition of profunctors via a coend. This means upgrading all the sizes that appear in the definition of Prof : its 0-cells are locally small categories;
its 1-cells P : C −→ı  D are bifunctors Dop × C → Ens. In this case, in Def. 4.1,
we would restrict the arrow A to be small, in the sense that its image A(J, K)
restricts to Set. More detailed treatment is found in [1].

Setop × Set	A	Ens Set

We replace Set by some small cocomplete category defined internally in a suitable topos [14]. In other words, we develop our theory on top of a certain type theory which is modeled by such a topos.
In any case, we would like to isolate the size issue as much as possible. Therefore we shall first establish those technical results which hold for any small symmetric monoidal category (C, ⊗,I). These results are proved by manipulating 2-cells in Prof . After that we instantiate (C, ⊗,I) by (Set, ×, 1)—pretending that Set is small.
Definition 5.1 Let (C, ⊗,I) be a small SMC, and A be an arrow on it. There arise

three 2-cells in Prof —which we denote by FA , FA
and FA
—of the following

types.

C



C3 C×⊗ C2 C×A C2
A
arr
>>>
first


C3 ⊗×C C2 A×C C2

⊗×C
C	C2
A
⇓ F>>>
C
⊗
⊗


A

C	C×⊗
C2
	

⊗	A

Explicitly, these 2-cells are given by the following composites.


C	C3	C×⊗
⊗×C
C	C	C2
C2	C×A  C2


C C×

C3 ⊗×C C2 A×C C2
⊗

⊗	A
A	A
Here the 1-cell I ⊗  on the left is the direct image of the functor X '→ I ⊗ X (Notations 2.10); recall that I denotes the monoidal unit. Also recall Notations 3.5. The 2-cells arr, >>>, first, second are due to the arrow structure of A (Def. 3.2, 3.4).
The motivation for this definition is clear from the names of the 2-cells. In- deed, through some calculations in Prof and application of the Yoneda lemma, one

easily sees that the three 2-cells FA ,FA
,FA
are the same thing as (di)natural

transformations
arr
>>>
first



A
arr
FA
: C(J, K) −→ A(J, I ⊗ K) ,	natural in J, K;
: A(J, X ⊗ K) × A(K, Y ⊗ L) −→ A(J, (X ⊗ Y ) ⊗ L) ,

>>>J,K,L



A
firstJ,K,L
natural in J, L, X, Y , dinatural in K,
: A(J, X ⊗ K) −→ A(J ⊗ L, X ⊗ (K ⊗ L)) ,
natural in J, K, X, dinatural in L,

respectively. These (di)natural transformations bear clear similarity to the ones in Def. 4.6 when FJ,K is instantiated with A(J,  ⊗ K).
Let us now turn to equations.




C×C


C×C


A◦⊗
C×C C2	⊗	C	A	C

C2
(π ,I,π ⟩
C×(I⊗ )⇓ C×F A
(I,π1 ,π2 ⟩
~
(I,C⟩
3 C×⊗	2
(I,C⟩
2

1	2
∼=	3
C×⊗	2
arr
2
= C	id  C = ⇐	C
C	C	I⊗
A C×A	C

⇐	C
⊗×C
C
A
>>>
C×A  C
⊗
⊗×C
C2
⇓ F>>>
C
⊗	A
C	arr  C

C2	C
⊗


C	A	C
A
A◦⊗
⊗



C2 ×⊗
C4  C3
A
A

C2 ×A
 C3

C2 ×⊗
C4  C3
C2 ×A
 C3
C×⊗ C2
C×A C2
⊗×C2
C×⊗×C	C×⊗
⇓ C×F A


⊗×C
2
C3  ∼=  C3
=
C×⊗ C
2 >>>
C2 C×A C2

C3
⊗×C
C2
⊗×C
C2 
⊗
C×A
C

A
>>>


A
⊗
C  A  C




⊗×C2

A×C2
⊗×C2
4
A×C2
3  C3

C
C4  C3 
⇓ F A ×C
C3
⊗×C
C2 ×⊗
C×⊗

C3
C×⊗×C
⇐ C3 ⊗×C C×⊗
C2
⊗
first
C2 A×C C2
first	⊗
C	C
A
=	C3 ⊗×C
C×⊗
C2
⊗
C2

A



(C2 ,I⟩
C2


C3 ⊗×C C2


A×C


C2
C2 =

(C2 ,I⟩
C3

⊗×C

A×C

A
first
⊗	C

C2  C	C	A	C
⊗	A




C2
(I,C2 ⟩
C2
C2

(I⊗ )×C
C3	⊗×C	C2
⇓ F A ×C
A×C
=	C
C2	C×⊗

A
first
⊗	C	C
⊗	A

C2  C	C
⊗	A



C×⊗×C



C×A×C



⊗×C



A×C



C2 ×

C×⊗×C
C×A×C

⊗×C
A×C


⊗ = C3
4


C3
 C3 
2	A
>>>
⊗



⊗×

⊗


A


Table 3
C×⊗
C2
⊗×C

⊗	A

Equalities that hold for FA ,FA ,FA
arr >>>  first
Lemma 5.2 Let A be an arrow over a small SMC C. The three 2-cells FA ,FA
arr	>>>

A
first
in Def. 5.1 satisfy the equalities in Table 3; they are parallel to the equalities

in Def. 3.2.


Proof First expand the definitions of FA ,FA
and FA
, and then use the equa-

arr	>>>
first

tional axioms in Def. 3.2. One also needs Lem. 3.6.	□
The equalities in Table 3 might look complicated. However, coming up with them is rather routine work looking at Def. 5.1 and Def. 3.2.
We now instantiate (C, ⊗,I) with (Set, ×, 1), pretending Set to be small.

Lemma 5.3 Let A be an arrow Setop × Set → Set. The family {A(J,  × K)}J,K
of endofunctors is a lax arrow functor.
Proof The three 2-cells in Def. 5.1 provide the three natural transformations re- quired in Def. 4.6. The equations asserted in Def. 4.6 follow from those in Lem. 5.2. Checking all this is (laborious) routine work.	□
Combining Prop. 4.7 and Lem. 5.3, our main result Thm. 4.4 is proved.
Remark 5.4 A characterization of categorical arrows in the spirit of Prop. 3.3 can possibly yield a even more direct proof of Thm. 4.4. Unfortunately until now we lack necessary infrastructure such as a lifting result like Prop. 4.7. We are currently investigating possible formalization using fibered spans (see e.g. Jacobs [15]).
In Prof the trace operator for an arrow (loop in Paterson [22], see also Benton and Hyland [8]) can be formalized in a similar way to other operators like >>>. Its description as well as possible application to components will presented in another venue.
Acknowledgement
Thanks are due to Paul-Andr´e Melli`es for advocating the use of profunctors; and to Marcelo Fiore, Bart Jacobs and Bartek Klin for helpful discussions.

References
Asada, K., Arrows are strong monads (2009), preprint, urlwww.kurims.kyoto-u.ac.jp/ asada/papers/arrStrMnd.pdf.
Atkey, R., What is a categorical model of arrows?, in: V. Capretta and C. McBride, editors,
Mathematically Structured Functional Programming, 2008.
Baez, J. C. and J. Dolan, Categorification, Contemp. Math. 230 (1998), pp. 1–36.
Baez, J. C. and J. Dolan, Higher dimensional algebra III: n-categories and the algebra of opetopes, Adv. Math 135 (1998), pp. 145–206.
URL citeseer.ist.psu.edu/article/baez97higherdimensional.html
Barbosa, L., “Components as Coalgebras,” Ph.D. thesis, Univ. Minho (2001).
Barr, M. and C. Wells, “Toposes, Triples and Theories,” Springer, Berlin, 1985, available online.
B´enabou,	J.,	Distributors	at	work,	Lecture	notes	taken	by	T.	Streicher	(2000),
www.mathematik.tu-darmstadt.de/~streicher/FIBR/DiWo.pdf.gz  .
Benton, N. and M. Hyland, Traced premonoidal categories, Theoretical Informatics and Applications
37 (2003), pp. 273–299.
Borceux, F., “Handbook of Categorical Algebra,” Encyclopedia of Mathematics 50, 51 and 52, Cambridge Univ. Press, 1994.
Fiore, M., Rough notes on presheaves (2001), available online.
Hasuo, I., C. Heunen, B. Jacobs and A. Sokolova, Coalgebraic components in a many-sorted microcosm, in: A. Kurz, M. Lenisa and A. Tarlecki, editors, CALCO, Lect. Notes Comp. Sci. 5728 (2009), pp. 64–80.
Hasuo, I., B. Jacobs and A. Sokolova, The microcosm principle and concurrency in coalgebra, in:
Foundations of Software Science and Computation Structures, Lect. Notes Comp. Sci. 4962 (2008),
pp. 246–260.

Hughes, J., Generalising monads to arrows., Science of Comput. Progr. 37 (2000), pp. 67–111.
Hyland, J. M. E., A small complete category, Ann. Pure & Appl. Logic 40 (1988), pp. 135–165.
Jacobs, B., “Categorical Logic and Type Theory,” North Holland, Amsterdam, 1999.
Jacobs, B., C. Heunen and I. Hasuo, Categorical semantics for arrows, J. Funct. Progr. 19 (2009),
pp. 403–438.
Kelly, G. M., “Basic Concepts of Enriched Category Theory,” Number 64 in LMS, Cambridge Univ. Press, 1982, available online:
http://www.tac.mta.ca/tac/reprints/articles/10/tr10abs.html.
Kock, A., Monads on symmetric monoidal closed categories, Arch. Math. XXI (1970), pp. 1–10.
Levy, P. B., A. J. Power and H. Thielecke, Modelling environments in call-by-value programming languages, Inf. & Comp. 185 (2003), pp. 182–210.
Mac Lane, S., “Categories for the Working Mathematician,” Springer, Berlin, 1998, 2nd edition.
Moggi, E., Notions of computation and monads, Inf. & Comp. 93(1) (1991), pp. 55–92.
Paterson, R., A new notation for arrows, in: ICFP, 2001, pp. 229–240.
Power, J. and E. Robinson, Premonoidal categories and notions of computation., Math. Struct. in Comp. Sci. 7 (1997), pp. 453–468.
Rutten, J. J. M. M., Universal coalgebra: a theory of systems, Theor. Comp. Sci. 249 (2000), pp. 3–80.
Street, R., The formal theory of monads, Journ. of Pure & Appl. Algebra 2 (1972), pp. 149–169.
Uustalu, T. and V. Vene, Comonadic notions of computation, Elect. Notes in Theor. Comp. Sci. 203
(2008), pp. 263–284.
