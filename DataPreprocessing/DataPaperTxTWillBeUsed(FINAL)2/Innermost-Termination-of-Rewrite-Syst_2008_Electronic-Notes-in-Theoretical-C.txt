Electronic Notes in Theoretical Computer Science 204 (2008) 3–19	
www.elsevier.com/locate/entcs

Innermost Termination of Rewrite Systems by Labeling 1
Ren´e Thiemann2 Aart Middeldorp
Institute of Computer Science, University of Innsbruck 6020 Innsbruck, Austria

Abstract
Semantic labeling is a powerful transformation technique for proving termination of term rewrite systems. The semantic part is given by a model or a quasi-model of the rewrite rules. A variant of semantic labeling is predictive labeling where the quasi-model condition is only required for the usable rules. In this paper we investigate how semantic and predictive labeling can be used to prove innermost termination. Moreover, we show how to reduce the set of usable rules for predictive labeling even further, both in the termination and the innermost termination case.
Keywords: Innermost Termination, Predictive Labeling, Semantic Labeling, Term Rewriting, Termination


Introduction
We start our discussion by illustrating the limitations of existing versions of semantic and predictive labeling on a concrete example. Consider the following rewrite system R where x ÷ y generates a number between 0 and [ x ♩:


1 Supported by DFG (Deutsche Forschungsgemeinschaft) grant GI 274/5-1 and FWF (Austrian Science Fund) project P18763.
2 Most of the work reported in this paper was carried out while the first author was employed at the Research Group Computer Science 2 of the RWTH Aachen, Germany.

1571-0661 © 2008 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2008.03.050

Proving termination of R is a difficult task. Consider the recursive calls of ÷ and if in rules (9) and (12). Essentially, one has to find a well-founded order such that the argument x of if is larger than the argument x − y of ÷. To this end, one can use the fact that in the previous recursive call the terms y ≥ s(0) and x ≥ y are both reducible to true. This knowledge is important as for x = 0 or y = 0 the term x − y can be reduced to x. However, when using term orders one generates one separate constraint for each rule of R. Thus, the knowledge of a previous recursive call is not directly available when building the constraint for rule (12). For example, polynomial interpretations with negative coefficients [5] are not expressive enough to solve the constraints of rules (9) and (12).
To solve this problem one can use the technique of semantic labeling [9]. We can take an algebra A over natural numbers N where we use the natural interpretation for the symbols −, s, 0, false, true, and ≥, i.e., x −A y = max(x−y, 0), sA(x) = x+1, 0A = falseA = 0, trueA = 1, and x ≥A y = 1 if x ≥ y, and 0 otherwise. Now, we can also provide labeling functions lf which define how to label the function symbol f in a term f (t1,..., tn), depending on the value of their arguments. E.g., we can choose l÷(n, m) = n, lif(b1, b2, n, m) = b1b2 +max(n−m, 0), and we do not label the remaining symbols. Then by labeling we get the (infinite) TRS lab(R) consisting of (1)–(8) together with the following rules, for all i ≥ j ≥ 0:

x ÷i y → ifj(y ≥ s(0),x ≥ y, x, y)		(13) ifi(false, b, x, y) → div-by-zero	(14) ifi(true, false, x, y) → 0		(15)
ifi+1(true, true, x, y) → id-inc((x − y) ÷i y)	(16)

Termination of lab(R) is easily proved by LPO with precedence ··· N ÷n N ifn N
··· N ÷1 N if1 N ÷0 N if0 N id-inc N − N ≥ N s N 0 N true N false. The result of semantic labeling is that if the algebra A is a model of R then termination of lab(R) implies termination of R. However, it is impossible to give an interpretation id-incA such that A is a model of R, since there is a conflict between the rules (7) and (8).
One solution is to work with quasi-models where it is only required that the inter- pretation of each left-hand side of a rule is greater than or equal to the interpretation of the corresponding right-hand side. In [4] semantic labeling with quasi-models is extended to predictive labeling where A only has to be a quasi-model of the usable rules, the rules which define the function symbols that are needed to perform the labeling. In our example the usable rules are (1)–(6). And indeed A is a (quasi-) model of these rules. The problem when using quasi-models is the requirement that all interpretations have to be weakly monotone in all arguments. As −A is not weakly monotone (1 ≥ 0, but 3 −A 1 = 2 /≥ 3 = 3 −A 0) one cannot use the algebra A to prove termination of R.
As a matter of fact, R is not terminating:

s(0) ÷ id-inc(0) → if(id-inc(0) ≥ s(0), s(0) ≥ id-inc(0), s(0), id-inc(0))

→2 if(s(0) ≥ s(0), s(0) ≥ s(0), s(0), id-inc(0))
→4 if(true, true, s(0), id-inc(0))
→ id-inc((s(0) − id-inc(0)) ÷ id-inc(0))
→2 (s(0) − 0) ÷ id-inc(0) → s(0) ÷ id-inc(0) → · · ·
So there cannot be a version of predictive labeling with models and arbitrary in- terpretations. 3 Nevertheless, R is innermost terminating. Therefore we investigate whether one can use predictive labeling with models for innermost termination, where one can freely choose interpretations and where the algebra only has to be a model of the usable rules. As the previous results on predictive labeling only work for quasi-models, one cannot reuse them for innermost rewriting, e.g., Example 2.3 below shows that the main theorem of predictive labeling [4, Theorem 18] does not hold for innermost rewriting.
The remainder of this paper is organized as follows. In Section 2 we start the formal developments by recalling the basic definitions related to semantic labeling. We show that with respect to innermost termination semantic labeling is incom- plete for both models and quasi-models and unsound for quasi-models. Soundness for models does hold and is shown in Section 3. By adapting the idea of predictive labeling to the innermost case we show that the model requirement is only needed for the usable rules induced by the labeling. The next contribution (Section 4) is the integration of an argument ﬁlter, i.e., a mapping from function symbols to sets of argument positions, to obtain even less usable rules than in [4] for innermost termination. This idea was already used in [3] where argument filters are employed to increase the power of term orders. In the context of semantic labeling, argument filters are used to express which arguments are ignored in interpretation and label- ing functions. In Section 5 we return to termination. We show how to integrate argument filters with predictive labeling, resulting in a result that is strictly more powerful than the main theorem of [4]. Concluding remarks are given in Section 6.

Semantic Labeling for Innermost Termination
We assume that the reader is familiar with term rewriting [2]. Below we recall the basic definitions related to semantic labeling.
An algebra A over F is a pair (A, {fA}f∈F ) consisting of a carrier A and, for every n-ary function symbol f ∈ F, an interpretation function fA : An → A. Given an assignment α : V → A we write [α]A(t) for the interpretation of the term t. An algebra A is a model of a rewrite system if [α]A(l) = [α]A(r) for all rules l → r ∈R 
and all assignments α. If additionally, the carrier A is equipped with a well-founded order >A then A is a quasi-model if [α]A(l) ≥A [α]A(r) for all l → r ∈ R and all assignments α.
For each function symbol f there also is a corresponding set Lf ⊆ A of labels for f and if Lf is non-empty there also is a labeling function lf : An → Lf . The

3 This answers a question raised in [4].

labeled signature Flab consists of n-ary function symbols fa for every n-ary function symbol f ∈F and label a ∈ Lf together with all function symbols f ∈F such that Lf = ∅. The labeling function lf determines the label of the root symbol f of a term f (t1,..., tn) based on the values of the arguments t1,..., tn. For every assignment α : V → A the mapping labα : T (F, V) →T (Flab, V) is inductively defined as follows:

⎧⎪⎨t	if t is a variable,
 
fa(labα(t1),..., labα(tn))	if t = f (t1,..., tn) and Lf /= ∅
where a denotes the label lf ([α]A(t1),..., [α]A(tn)). The labeled TRS lab(R) over the signature Flab consists of the rules labα(l) → labα(r) for all l → r ∈ R and α : V → A. Moreover, if one uses quasi-models then one needs the set
Dec = {fa(x1,..., xn) → fb(x1,..., xn) | a, b ∈ Lf ,a >A b}

of decreasing rules. In this case every interpretation function fA and every labeling function lf has to be weakly monotone, i.e., if a ≥A a' then fA(a1,..., a,..., an) ≥A fA(a1,..., a',..., an) and similarly for lf .
Zantema [9] obtained the following results for semantic labeling.
Lemma 2.1 Let R be a TRS and A a non-empty algebra.
If A is a model of R then t →R u implies labα(t) →lab(R) labα(u).
If A is a quasi-model of R then t →R u implies labα(t) →+	labα(u).
From Lemma 2.1 one obtains that R is terminating if and only if lab(R) (∪ Dec) is terminating when A is a (quasi-)model of R. Completeness is achieved by remov- ing the labels of a possible infinite rewrite sequence of the labeled TRS. Soundness is proved by transforming a presupposed infinite rewrite sequence in R into an infinite rewrite sequence in lab(R) (∪ Dec). This transformation is achieved by ap- plying the labeling function labα(·) (for an arbitrary assignment α) to all terms in the infinite rewrite sequence of R. Hence, semantic labeling is sound and complete for termination with respect to both models and quasi-models.
As first new contribution we show that semantic labeling is incomplete for in- nermost termination (Example 2.2) and that it is not even sound when using quasi- models (Example 2.3). We write →i R for the innermost rewrite relation of R.
Example 2.2 Consider the TRS R:
if(true, x) → if(test-ab(x), x)	test-ab(a(x)) → test-b(x) a(b) → c		test-b(b) → true
Note that R is innermost terminating. The reason is that test-ab(x) can only be evaluated to true if x is instantiated with a(b). But this is not allowed as a(b) is not in normal form. We choose the algebra A with carrier A = {0, 1}, interpretations

ifA(x, y) = 0, bA = cA = trueA = 1, test-abA(x) = test-bA(x) = aA(x) = x, and order >A = ∅. Then A is a model (and thus also a quasi-model) of R. Choosing La = A, la(x) = x, and Lf = ∅ for all other function symbols f we get the following labeled TRS lab(R):
if(true, x) → if(test-ab(x), x)	test-ab(a0(x)) → test-b(x)	test-b(b) → true a1(b) → c	test-ab(a1(x)) → test-b(x)
There are no decreasing rules. The following reduction shows that lab(R) is not innermost terminating:
if(true, a0(b)) →lab(R) if(test-ab(a0(b)), a0(b)) →lab(R) if(test-b(b), a0(b))
→lab(R) if(true, a0(b)) →lab(R) ··· 

So semantic labeling is incomplete in the innermost case. The next example shows that semantic labeling with quasi-models is unsound in the innermost case.
Example 2.3 The TRS R = {f(a(b)) → f(a(b))} is obviously not innermost terminating. We choose the algebra A with carrier A = {0, 1}, interpretations bA = fA(x) = 1, aA(x) = x, and >A = >, which is a (quasi-)model of R. By taking Lb = Lf = ∅, La = A, and la(x) = x, we obtain the TRS lab(R) ∪ Dec
f(a1(b)) → f(a1(b))	a1(x) → a0(x)
This TRS is innermost terminating because the second rule prohibits an innermost rewrite step with the first rule.
The previous example does not show that semantic labeling with models is unsound for innermost termination because there are no decreasing rules when using models. Indeed, in the next section we show the soundness of semantic labeling with models for innermost termination. Actually, we prove a stronger results by incorporating usable rules.
Predictive Labeling for Innermost Termination
Semantic labeling requires that the algebra is a model of all rules. This is in contrast to predictive labeling where the model condition only has to be satisfied for the usable rules, a concept introduced in [1]. We slightly modify the definition of usable rules by integrating the labeling. Here, F un(t) denotes the set of all function symbols occurring in the term t.
Definition 3.1 Let R be a TRS and l a labeling. We define the set of usable symbols USl(t) ⊆ F of a term t inductively. If t ∈ V then USl(t) = ∅. If t = f (t1,..., tn) then USl(t) is the least set such that
USl(t1) ∪· · · ∪ USl(tn) ⊆ USl(t),
if Lf /= ∅ then F un(t1) ∪· · · ∪ Fun(tn) ⊆ USl(t), and

if l → r ∈R and root(l) ∈ USl(t) then F un(r) ⊆ USl(t). The usable symbols of R are defined as

USl(R) = 
L→r∈R
USl(r)

and the usable rules of R are defined as

Ul(R) = {l → r ∈R| root(l) ∈ USl(R)}.

It can be shown that USl(t) = Gl(t) for the corresponding definition of Gl in [4, Definition 5]. However, there is a difference in the definition of USl(R) and Gl(R) as in [4] both sides of a rule are considered, i.e., Gl(r) and Gl(l) are added for a rule l → r. The difference is illustrated in the following example.
Example 3.2 Consider the TRS R = {a → f(g(b)), g(a) → c}. Assuming Lf /= ∅ and Lg /= ∅, in [4] one obtains Gl(R) = {a, b, c, f, g} and thus both rules are usable. This is in contrast to Definition 3.1 where USl(R) = {b, c, g} and hence Ul(R) = {g(a) → c}. The advantage of our definition is obvious: we get less usable rules. However, the property in [4] that one only needs interpretations for the symbols in USl(R) is not valid anymore. To check the model condition for g(a) → c and to label g(a) we need an interpretation aA for a.
From now on we assume a fixed TRS R and just write USl instead of USl(R) and Ul instead of Ul(R). Essentially, the aim of predictive (resp. semantic) la- beling is to find a model for the usable (resp. all) rules and then try to prove innermost termination of lab(R) to ensure innermost termination of R. As argued between Lemma 2.1 and Example 2.2, soundness of semantic labeling is proved by transforming an infinite reduction t1 →R t2 →R ... into an infinite reduction labα(t1) →lab(R) labα(t2) →lab(R) ... by using Lemma 2.1(i). However, in the pre- dictive case this lemma does not hold if the algebra is not a model of all rules. To this end we consider a variant in which only reduction steps tσ →i R u are regarded where t satisfies USl(t) ⊆ USl and where σ is a normalized substitution, i.e., where σ(x) is in normal form for all x ∈ V.
Lemma 3.3 Let A be a model of Ul, let USl(t) ⊆ USl, and let σ be a normalized substitution. If tσ = C[lσ] →i R C[rσ] = u is a reduction with rule l → r ∈R then
labα(tσ) →i lab(R) labα(u),
there is a term t' such that u = t'σ and USl(t') ⊆ USl, and
F un(t) ⊆ USl implies both F un(t') ⊆ USl and [α]A(tσ) = [α]A(u).
Note that Lemma 3.3(i) and (ii) will allow us to transform innermost reductions of R into infinite innermost reductions of lab(R). This is needed for the proof of the main theorem of this section (Theorem 3.4). Property (iii) is only needed to prove Lemma 3.3.

Proof. We perform structural induction on t. As σ is a normalized substitution t
is not a variable, so let t = f (t1,..., tn). We first consider a root reduction, i.e.,
tσ = lσ →i R rσ = u.  Let σlab be the substitution labα ◦ σ and let ασ be the
assignment [α]A ◦ σ. We have labα(lσ) = labασ (l)σlab and therefore obtain (i):
labα(tσ) = labα(lσ) = labα (l)σlab →i lab(R) labα (r)σlab = labα(rσ) = labα(u).
Note that labeling does not introduce new redexes and hence the above reduction step is really an innermost step. The reason is that there are no decreasing rules as in Example 2.3. To obtain (ii) we choose t' = r. Then u = t'σ is obviously satisfied and USl(t') = USl(r) ⊆ USl follows by definition of USl. To prove (iii) let F un(t) ⊆ USl. Then f ∈ USl and thus l → r ∈ Ul. Moreover, by the closure property in Definition 3.1(iii) we conclude F un(r) ⊆ USl. As the rule is usable we know that A is a model of this rule. Hence we can finish the root reduction case:
[α]A(tσ) = [α]A(lσ) = [ασ]A(l) = [ασ]A(r) = [α]A(rσ) = [α]A(u).
Now we consider a reduction below the root: tiσ = C'[lσ] →i R C'[rσ] = ui and u = f (t1σ,..., ui,..., tnσ). By Definition 3.1(i) we have USl(ti) ⊆ USl(t) ⊆ USl. Hence, we can use the induction hypothesis for ti. To prove (i) we consider two cases. First, if Lf = ∅ then
labα(tσ) = f (labα(t1σ),..., labα(tiσ),..., labα(tnσ)) →i lab(R)
f (labα(t1σ),..., labα(ui),..., labα(tnσ)) = labα(u) directly proves (i). Otherwise, if Lf /= ∅ then
labα(tσ) = fa(labα(t1σ),..., labα(tiσ),..., labα(tnσ)) →i lab(R)
fa(labα(t1σ),..., labα(ui),..., labα(tnσ))
where a = lf ([α]A(t1σ),..., [α]A(tiσ),..., [α]A(tnσ)). It remains to show that
a = lf ([α]A(t1σ),..., [α]A(ui),..., [α]A(tnσ)). To this end it suffices to prove [α]A(tiσ) = [α]A(ui) which directly follows from the induction hypothesis (iii) since F un(ti) ⊆ USl(ti) ⊆ USl by Definition 3.1(ii).
To show (ii) we first get a term t' with t' σ = ui and USl(t' ) ⊆ USl by induc-
i	i	i
tion. We choose t' = f (t1,..., t' ,..., tn) and directly obtain t'σ = u. To prove
USl(t') ⊆ USl we define USk(t') to be like USl(t') where we only apply closure (iii) in Definition 3.1 at most k times. Then it suffices to prove USk(t') ⊆ USl for all k ∈ N which we do by an inner induction on k. We first consider closure (i). Here,
we use USl(t) ⊆ USl and Definition 3.1(i) to obtain USl(t1) ∪· · · ∪USl(tn) ⊆ USl.
Thus, USk(t1) ∪· · · ∪USk(t' ) ∪· · · ∪USk(tn) ⊆ USl is also satisfied. For closure (ii)
l	l  i	l
we only have to consider the case Lf /= ∅. From USl(t) ⊆ USl and Definition 3.1(ii)
we conclude F un(tj) ⊆ USl for all 1 ≤ j ≤ n. As F un(t' ) ⊆ USl by induction hypothesis (iii), we are done. For closure (iii) let f ∈ USk(t'). If f ∈ USk−1(t')
l	l
then we only have to apply the inner induction hypothesis. Otherwise, there is a rule l → r with root(l) ∈ USk−1(t') and f ∈ Fun(r). From the inner induction

hypothesis we obtain root(l) ∈ USl = L'→r' USl(r'). Thus, for some r' we have root(l) ∈ USl(r') and by Definition 3.1(iii) we know f ∈ USl(r'). But then f ∈ USl as well.
To finally prove (iii) we assume F un(t) ⊆ USl. Then obviously F un(ti) ⊆ USl. Thus, by induction hypothesis (iii) we know F un(t' ) ⊆ USl. So F un(t') ⊆ USl is a consequence of F un(t) ⊆ USl. Moreover, we also obtain [α]A(tiσ) = [α]A(ui) from the induction hypothesis (iii). Hence, we can finally prove (iii):

[α]A(tσ) = fA([α]A(t1σ),..., [α]A(tiσ),..., [α]A(tnσ))
= fA([α]A(t1σ),..., [α]A(ui),..., [α]A(tnσ)) = [α]A(u).

 

Theorem 3.4 If A is a model of Ul then innermost termination of lab(R) implies innermost termination of R.
Proof. Suppose R is not innermost terminating. Then there is a minimal non- terminating term s which is not innermost terminating. By renaming the variables of the rules used for the reductions we can assume that for every rewrite step in this infinite reduction the corresponding rule is instantiated by the same normalized substitution σ. By minimality of s, after a number of reductions there must be
a root step, i.e., s  i ∗ lσ →i R rσ for some rule l → r ∈ R where rσ is not
innermost terminating. By definition of USl we know USl(r) ⊆ USl. Hence, starting the infinite reduction with rσ we can now simulate every reduction step with the corresponding labeled term labα(rσ) using the labeled TRS lab(R).  If
rσ →i R r1 →i R r2 →i R ··· then by Lemma 3.3(ii) we obtain terms t1, t2,... such
that ri = tiσ and USl(ti) ⊆ USl. Using Lemma 3.3(i) we can finally prove that
lab(R) is not innermost terminating:

labα(rσ) →i lab(R) labα(r1) = labα(t1σ) →i lab(R) labα(r2) = labα(t2σ) →i lab(R) ... 



With Theorem 3.4 it is now possible to prove innermost termination of the leading example with the specified algebra and the specified LPO.

Improved Labeling for Innermost Termination
We first modify the leading example to show a limitation of predictive labeling. Afterwards we present an improvement to overcome this limitation.
Example 4.1 We consider a reformulated version of the TRS in the leading exam- ple which uses an accumulator. Let R consist of the rules (1)–(8) together with the

following rules:
quot(x, y) → ÷(x, y, 0)	(17)
÷(x, y, z) → if(y ≥ s(0),x ≥ y, x, y, z)	(18)
if(false, b, x, y, z) → div-by-zero	(19)
if(true, false, x, y, z) → z	(20)
if(true, true, x, y, z) → ÷(x − y, y, id-inc(z))	(21)
The problem is that we cannot apply Theorem 3.4 with the given algebra A; because id-inc now occurs below the labeled symbol ÷, the problematic rules (7) and (8) are usable and A is not a model of these rules. However, the labeling function l÷ ignores its third argument and thus, we do not need semantics for id-inc to compute
the label for ÷. Therefore, we would like to remove the id-inc-rules from the set of
usable rules. How this can be achieved is shown in the remainder of this section.
First, we need a notion to express which arguments of a function symbol should be ignored. To this end we use an argument ﬁlter which maps every symbol to the set of arguments that are not ignored. We further need a notion to express that an argument filter is suitable for an algebra and a labeling function. Argument filters were introduced in [1] and have been recently [3] used to reduce the usable rules in connection with the dependency pair method.
Definition 4.2 An argument ﬁlter is a mapping π : F → 2N such that π(f ) is a subset of {1,..., n} for all f ∈ F with arity n. The application of an argument filter π to a term t is denoted by π(t) and defined as follows:

π(t) =	t	if t is a variable
f (π(ti1 ),..., π(tik ))	if t = f (t1,..., tn) and π(f ) = {i1,..., ik}
An algebra A is π-conform if fA may depend on the i-th argument only if i ∈ π(f ). Similarly, a labeling function lf is π-conform if lf may depend on the i-th argument only if i ∈ π(f ).
From now on it is assumed that all algebras and labeling functions are π-conform. We refine Definition 3.1 to get less usable rules when regarding the argument filter.
Definition 4.3 Let R be a TRS, l a labeling, and π an argument filter. We define the set USl,π(t) ⊆ F of usable symbols with respect to π of a term t inductively. If t ∈V then USl,π(t) = ∅. If t = f (t1,..., tn) then USl,π(t) is the least set such that
USl,π(t1) ∪· · · ∪ USl,π(tn) ⊆ USl,π(t),
if Lf /= ∅ and i ∈ π(f ) then F un(π(ti)) ⊆ USl,π(t), and
if l → r ∈R and root(l) ∈ USl,π(t) then F un(π(r)) ⊆ USl,π(t).
The usable symbols USl,π(R) and the usable rules Ul,π(R) with respect to π are defined as

USl,π(R) = 
L→r∈R
USl,π(r)

and
Ul,π(R) = {l → r ∈R| root(l) ∈ USl,π(R)}.
As before, we assume a fixed TRS R and therefore just write USl,π and Ul,π for USl,π(R) and Ul,π(R). We now show how innermost termination of the TRS in Example 4.1 can be proved if one only has to find a model for the usable rules with respect to π.
Example 4.4 We choose π(÷) = {1, 2} and π(if) = {1, 2, 3, 4} in Example 4.1. Then A and the labeling functions are π-conform and the usable rules are (1)–
as in the leading example. We obtain a similar labeled TRS and termination is proved by a similar LPO. One only has to extend the precedence for the new
symbol quot by demanding quot N ÷i for all i ∈ N.
The only missing step is to extend the results of Lemma 3.3 and Theorem 3.4 to the refined version of usable rules in Definition 4.3.
Lemma 4.5 Let A be a model of Ul,π, let USl,π(t) ⊆ USl,π, and let σ be a nor- malized substation such that tσ = C[lσ] →i R C[rσ] = u for a rule l → r ∈ R. Then the following properties are satisﬁed:
labα(tσ) →i lab(R) labα(u),
there is a term t' such that u = t'σ and USl,π(t') ⊆ USl,π, and
F un(π(t)) ⊆ USl,π implies both F un(π(t')) ⊆ USl,π and [α]A(tσ) = [α]A(u).
Proof. The proof is completely similar to the proof of Lemma 3.3 where one re- places USl by USl,π, F un(t) by F un(π(t)), and Ul by Ul,π. Therefore, we only give the three additional cases which arise when considering reductions below the root. First, to prove (i) one has to show lf ([α]A(t1σ),..., [α]A(tiσ),..., [α]A(tnσ)) =
lf ([α]A(t1σ),..., [α]A(ui),..., [α]A(tnσ)) as before. If i ∈ π(f ) then one can con- clude F un(π(ti)) ⊆ USl,π and proceed as in the proof of Lemma 3.3. Otherwise, i ∈/ π(f ) and thus, the equality is valid as lf ignores its i-th argument. Second, to prove (ii) one has to show USl,π(t') ⊆ USl,π by looking at the closure prop- erties (i) and (ii) of Definition 4.3. When considering (ii) one cannot conclude F un(π(ti)) ⊆ USl,π if i ∈/ π(f ). However, in that case F un(π(t' )) ⊆ USl,π is not required to satisfy (ii). Finally, to prove (iii) one gets the additional case i ∈/ π(f ). Then F un(π(t')) = F un(π(t)) ⊆ USl,π as π(t) = π(t'). Moreover, using the fact that fA ignores its i-th argument immediately yields [α]A(tσ) = [α]A(u).	 
We are now ready to present the result about improved predictive labeling where under the assumption of π-conformity one only has to find a model for the usable rules with respect to π. As demonstrated in Example 4.1 and Example 4.4 this clearly extends Theorem 3.4.
Theorem 4.6 Let π be an argument ﬁlter. If A is a model of Ul,π and if both A and all labeling functions are π-conform then innermost termination of lab(R) implies innermost termination of R.

Proof. Just replace Lemma 3.3 by Lemma 4.5 in the proof of Theorem 3.4. 
A possible extension of Theorem 4.6 is to redefine Definition 4.3 such that USl,π(ti) ⊆ USl,π(t) is only required if i ∈ π(f ). However the following exam- ple shows that this extension is unsound.
Example 4.7 Consider the TRS {f(g(a)) → f(g(b)), b → a}. We choose the algebra with carrier A = {0, 1} and interpretations fA(x) = gA(x) = aA = 0 and bA = 1. For the labeling we use Lf = La = Lb = ∅, Lg = A, and lg(x) = x. Then both the algebra and the labeling functions are π-conform for the argument filter π defined by π(f) = π(a) = π(b) = ∅ and π(g) = {1}. However, using the alternative definition of USl,π(t) we get USl,π = ∅ and hence, A is a model for the usable rules. Thus, the extension cannot be sound as the labeled TRS
{f(g0(a)) → f(g1(b)), b → a} is terminating while R is not innermost terminating.
In the next section we combine the idea of usable rules with respect to an argument filter with predictive labeling for full rewriting.

Improved Predictive Labeling for Termination
As in [4], for improved predictive labeling in the termination case we do not allow arbitrary algebras but one has to use a so-called H-algebra ([4, Definition 8]).
Definition 5.1 Let A be an algebra and let >A be a well-founded order on the carrier A. We say that (A, >A) is a H-algebra if for all finite subsets X ⊆ A there exists a least upper bound  X of X in A.
In the remainder of this section we assume that R is a ﬁnitely branching TRS, π an argument filter, and (A, >A) a H-algebra such that all interpretations fA and all labeling functions lf are weakly monotone and π-conform, and Ul,π ⊆ ≥A.
As in the previous sections we cannot directly achieve the result of Lemma 2.1(ii) to transform infinite R reductions into infinite reductions of lab(R) ∪ Dec since A is not a quasi-model of all rules in R. Therefore, we introduce an alternative interpre- tation function [α]∗ (·) for all terminating terms (SN ) similar to [4, Definition 9]. However, one has to perform a minor modification due to the difference between USl and Gl, cf. Example 3.2.
Definition 5.2 Let t ∈ SN and α an assignment. We define the interpretation [α]∗ (t) inductively as follows where t' = fA([α]∗ (t1),..., [α]∗ (tn)):
A	A	A
⎧⎪⎨α(x)	if t is a variable,
⎪. {[α]∗ (u) | t →R u}∪ {t'}	if t = f (t1,..., tn) and f ∈/ USl,π.

Note that the recursion in the definition of [α]∗ (·) terminates because the union of →R and the proper superterm relation D is a well-founded relation on SN .

Further note that the operation	is applied only to finite sets as R is assumed to be finitely branching.
The induced labeling function [4, Definition 10] can be defined for terminating and for minimal non-terminating terms (T ∞) but not for arbitrary terms in T (F, V).
Definition 5.3 Let t ∈ SN ∪ T ∞ and α an assignment. We define the labeled term lab∗ (t) inductively as follows:
⎧⎪⎨t	if t is a variable,
 
α	α
where a = lf ([α]∗ (t1),..., [α]∗ (tn)).
A	A
The following lemma compares the predicted semantics of an instantiated ter- minating term to the original semantics of the uninstantiated term, in which the substitution becomes part of the assignment.
Definition 5.4 Given an assignment α and a substitution σ such that σ(x) ∈ SN

for all variables x, the assignment α∗
is defined as [α]∗
σ and the substitution

σlab∗
as lab∗ ◦ σ.

Lemma 5.5 If tσ ∈ SN then [α]∗ (tσ) ≥A [α∗ ] (t). If in addition F un(π(t)) ⊆

USl,π then [α]∗ (tσ) = [α∗ ]
A	σ A
(t).

A	σ A
Proof. We use structural induction on t. If t ∈V then


[α]∗ (tσ) = ([α]∗ ◦ σ)(t) = [α∗ ]
(t).

A	A	σ A
Suppose t = f (t1,..., tn). We distinguish two cases.
If f ∈ USl,π then
[α]∗ (tσ) = fA([α]∗ (t1σ),..., [α]∗ (tnσ)) ≥A

A	A	A
fA([α∗ ] (t1),..., [α∗ ] (tn)) = [α∗ ]
(t)

where the inequality follows from the induction hypothesis (note that tiσ ∈ SN
for all i = 1,..., n) and the weak monotonicity of fA. If F un(π(t)) ⊆ USl,π
and i ∈ π(f ) then F un(π(ti)) ⊆ USl,π and thus [α]∗ (tiσ) = [α∗ ] (ti) according
A	σ A
to the induction hypothesis. Since fA is π-conform, the inequality is turned into an equality.
If f ∈/ USl,π then
[α]∗ (tσ) = . {· · · }∪ {fA([α]∗ (t1σ),..., [α]∗ (tnσ))}
≥A fA([α]∗ (t1σ),..., [α]∗ (tnσ)) ≥A [α∗ ] (t)
A	A	σ A
again using weak monotonicity of fA and the induction hypothesis. As in this case F un(π(t)) /⊆ USl,π, we have already proved the second part of the lemma.

 
The next lemma does the same for labeled terms. Since the label of a function symbol only depends on the semantics of its arguments, we can only deal with terminating and minimal non-terminating terms.
Lemma 5.6 If tσ ∈ £U ∪ 7 ∞ then lab∗ (tσ) →∗	labα∗ (t)σlab∗ . If in addition

α
C£l,π(t) ⊆ C£l,π then lab∗ (tσ) = labα∗ (t)σlab∗ .
Dec	σ	α

α	σ	α
Proof. We use structural induction on t. If t is a variable then lab∗ (tσ) = tσlab∗ =
α	α
labα∗ (t)σlab∗ . Otherwise t = f (t1,..., tn). Note that t1,..., tn ∈ £U . The induc-
σ	α

tion hypothesis yields lab∗ (tiσ) →∗	labα∗ (ti)σlab∗
for all i = 1,..., n. Moreover,

α	Dec	σ	α
whenever C£l,π(t) ⊆ C£l,π then by Definition 4.3(i) C£l,π(ti) ⊆ C£l,π for every

i and thus lab∗ (tiσ) = labα∗ (ti)σlab∗
by the induction hypothesis. We distinguish

α	σ	α
three cases.
If Lf = ∅ then
lab∗ (tσ) = f (lab∗ (t1σ),..., lab∗ (tnσ))
α	α	α
→∗	f (labα∗ (t1)σlab∗ ,..., labα∗ (tn)σlab∗ )
Dec	σ	α	σ	α
= f (labα∗ (t1),..., labα∗ (tn))σlab∗
σ	σ	α
= labα∗ (f (t1,..., tn))σlab∗ .
σ	α
Of course, if C£l,π(t) ⊆ C£l,π then there are no reduction steps.
If Lf /= ∅ and C£l,π(t) /⊆ C£l,π then
lab∗ (tσ) = fa(lab∗ (t1σ),..., lab∗ (tnσ))
α	α	α
→∗	fa(labα∗ (t1)σlab∗ ,..., labα∗ (tn)σlab∗ )


and
Dec	σ	α	σ	α


labα∗ (t)σlab∗  = fb(labα∗ (t1),..., labα∗ (tn))σlab∗
σ	α	σ	σ	α
= fb(labα∗ (t1)σlab∗ ,..., labα∗ (tn)σlab∗ )
σ	α	σ	α


with a = lf ([α]∗ (t1σ),..., [α]∗ (tnσ)) and b = lf ([α∗ ] (t1),..., [α∗ ]
(tn)).

A	A	σ A	σ A
Lemma 5.5 yields [α]∗ (tiσ) ≥A [α∗ ] (ti) for all i = 1,..., n.  Because the
A	σ A
labeling function lf is weakly monotone in all its coordinates, a ≥A b. If
a >A b then Ðec contains the rewrite rule fa(x1,..., xn) → fb(x1,..., xn) and
thus (also if a = b) fa(labα∗ (t1)σlab∗ ,..., labα∗ (tn)σlab∗ ) →∗	labα∗ (t)σlab∗ .

σ
We conclude that lab∗ (tσ) →∗
α	σ
labα∗ (t)σlab∗ .
α	Dec	σ	α

α	Dec	σ	α
If Lf /= ∅ and C£l,π(t) ⊆ C£l,π then
lab∗ (tσ) = fa(lab∗ (t1σ),..., lab∗ (tnσ))
α	α	α
= fa(labα∗ (t1)σlab∗ ,..., labα∗ (tn)σlab∗ )
σ	α	σ	α
= fa(labα∗ (t1),..., labα∗ (tn))σlab∗
σ	σ	α

and
labα∗ (t)σlab∗  = fb(labα∗ (t1),..., labα∗ (tn))σlab∗
σ	α	σ	σ	α

with a = lf ([α]∗ (t1σ),..., [α]∗ (tnσ)) and b = lf ([α∗ ] (t1),..., [α∗ ]
(tn)). We

A	A	σ A	σ A
need to show that a = b. Because lf is π-conform, this amounts to showing
[α]∗ (tiσ) = [α∗ ] (ti) for i ∈ π(f ). If we can show that F un(π(ti)) ⊆ C£l,π,
A	σ A
this follows from Lemma 5.5. (Note that tiσ ∈ £U as tσ ∈ £U ∪ 7 ∞.) But this can directly be concluded from F un(π(ti)) ⊆ C£l,π(t) ⊆ C£l,π by closure property (ii) of Definition 4.3.
 
We further need to know that the predicted semantics decreases when rewriting.
Lemma 5.7 Let t, u ∈ £U. If t →R u then [α]∗ (t) ≥A [α]∗ (u).
A	A
Proof. We perform structural induction on t. Obviously, t is not a variable, so let
t = f (t1,..., tn). If f ∈/ C£l,π then
[α]∗ (t) = . {[α]∗ (v) | t →R v}∪ {· · · } ≥A [α]∗ (u)

since [α]∗ (u) ∈ {[α]∗ (v) | t →R v}. Thus, for the remaining proof we may assume
A	A
f ∈ C£l,π. We consider two cases.
First we consider a root reduction t = lσ →R rσ = u. As root(l) = root(t) = f ∈ C£l,π we know l → r ∈ Cl,π and F un(π(r)) ⊆ C£l,π due to closure property (iii) in Definition 4.3. From the assumption Cl,π ⊆ ≥A we infer l ≥A r. Using Lemma 5.5 we obtain
[α]∗ (t) = [α]∗ (lσ) ≥A [α∗ ] (l) ≥A [α∗ ] (r) = [α]∗ (rσ) = [α]∗ (u).
A	A	σ A	σ A	A	A
Next assume a reduction t →R f (t1,..., ui,..., tn) = u below the root where
ti →R ui. The induction hypothesis yields [α]∗ (ti) ≥A [α]∗ (ui) and thus
A	A
[α]∗ (t) =fA([α]∗ (t1),..., [α]A(ti),..., [α]A(tn)) ≥A
A	A
fA([α]∗ (t1),..., [α]A(ui),..., [α]A(tn)) = [α]∗ (u)
A	A

by weak monotonicity of fA.

We are now ready for the key lemma, which states that rewrite steps between terminating and minimal non-terminating terms can be labeled.
Lemma 5.8 Let t, u ∈ £U ∪ 7 ∞. If t →R u then lab∗ (t) →+	lab∗ (u).
α	lab(R)∪Dec	α
Proof. We use structural induction on t. Obviously t = f (t1,..., tn). For a root
reduction t = lσ →R rσ = u we infer lab∗ (t) = lab∗ (lσ) →∗	labα∗ (l)σlab∗ →lab(R)
α	α	Dec	σ	α
labα∗ (r)σlab∗  = lab∗ (rσ) = lab∗ (u) by Lemma 5.6.	Otherwise, we have u =
σ	α	α	α

f (t1,..., ui,..., tn) with ti →R ui. We obtain lab∗ (ti) →+	lab∗ (ui) from

α
the induction hypothesis. We distinguish two cases.
If Lf = ∅ then
lab(R)∪Dec	α

lab∗ (t) =f (lab∗ (t1),..., lab∗ (ti),..., lab∗ (tn)) →+

α	α	α
α	lab(R)∪Dec

f (lab∗ (t1),..., lab∗ (ui),..., lab∗ (tn)) = lab∗ (u).
α	α	α	α

If Lf /= ∅ then
lab∗ (t) =fa(lab∗ (t1),..., lab∗ (ti),..., lab∗ (tn)) →+

α	α	α
α	lab(R)∪Dec

fa(lab∗ (t1),..., lab∗ (ui),..., lab∗ (tn))
α	α	α
with a = lf ([α]∗ (t1),..., [α]∗ (ti),..., [α]∗ (tn)) and
A	A	A
lab∗ (u) = fb(lab∗ (t1),..., lab∗ (ui),..., lab∗ (tn))
α	α	α	α
with b = lf ([α]∗ (t1),..., [α]∗ (ui),..., [α]∗ (tn)). Because ti ∈ £U we can use
A	A	A
Lemma 5.7 to obtain [α]∗ (ti) ≥A [α]∗ (ui). Hence, a ≥A b by weak monotonic-
A	A
ity of lf and thus fa(lab∗ (t1),..., lab∗ (ui),..., lab∗ (tn)) →∗	lab∗ (u).
α	α	α	Dec	α

We now have all the ingredients to prove the soundness of improved predictive labeling for termination.
Theorem 5.9 Let R be a TRS, let π be an argument ﬁlter, and let (A, >A) be a H-algebra such that A is a quasi-model of Cl,π and all interpretation and labeling functions are weakly monotone and π-conform. If lab(R) ∪ Ðec is terminating then so is R.
Proof. Note that for every term t ∈ 7 ∞ there exist a rewrite rule l → r ∈ R,
a substitution σ, and a subterm u of r such that t −>→є ∗ lσ −→є	rσ Ḏ uσ and
lσ, uσ ∈7 ∞. Let α be an arbitrary assignment. We will apply lab∗ to the terms in
the above sequence. From Lemma 5.8 we obtain lab∗ (t) →∗	lab∗ (lσ). Since
α	lab(R)∪Dec	α
∞	є
rσ need not be an element of 7	, we cannot apply Lemma 5.8 to the step lσ −→ rσ.
Instead we use Lemma 5.6 to obtain lab∗ (lσ) →∗	labα∗ (l)σlab∗ . Since labα∗ (l) →
α	Dec	σ	α	σ
labα∗ (r) ∈ lab(R), labα∗ (l)σlab∗ →lab(R) labα∗ (r)σlab∗ . Because u is a subterm of r,
σ	σ	α	σ	α
labα∗ (r)σlab∗ Ḏ labα∗ (u)σlab∗ . From closure property (i) of Definition 4.3 we infer
σ	α	σ	α
C£l,π(u) ⊆ C£l,π(r). Since r is a right-hand side of a rewrite rule of R, C£l,π(r) ⊆
C£l,π. Hence C£l,π(u) ⊆ C£l,π. Lemma 5.6 now yields labα∗ (u)σlab∗ = lab∗ (uσ).
σ	α	α
Putting everything together, we obtain lab∗ (t) →+	· Ḏ lab∗ (uσ).  Now
α	lab(R)∪Dec	α
suppose that R is non-terminating. Then 7 ∞ is non-empty and thus there is an
infinite sequence t1 −>→є ∗ · −→є  · Ḏ t2 −>→є ∗ · −→є  · Ḏ ··· By the above argument, this sequence is transformed into


lab∗ (t1) →+
· Ḏ lab∗ (t2) →+
· Ḏ ··· 

α	lab(R)∪Dec	α	lab(R)∪Dec

By introducing appropriate contexts, the latter sequence gives rise to an infinite reduction in lab(R) ∪ Ðec, contradicting the assumption that R is terminating. 
We conclude this section with an example.
Example 5.10 Consider the TRS R consisting of (7), (8), and


nonZero(0) → false (22) nonZero(s(x)) → true	(23) p(s(x)) → x	(24)
p(0) → 0	(25)
random(x) → rand(x, 0)		(26) rand(x, y) → if(nonZero(x), x, y)	(27) if(false, x, y) → y		 (28)
if(true, x, y) → rand(p(x), id-inc(y))	(29)

Here, random(x) generates a random number between 0 and x. We use the algebra A with carrier N and natural interpretations pA(x) = max(x − 1, 0), sA(x) = x + 1, 0A = falseA = 0, trueA = 1, and nonZeroA(x) = 0 if x = 0, and 1 otherwise. If one takes the standard order > on N then A is a H-algebra and a quasi-model for rules (22)–(25). Moreover, for the labeling with Lrand = Lif = N, lrand(n, m) = n, lif(b, n, m) = b + max(n − 1, 0), and Lf = ∅ for all other function symbols, both A and the labeling functions are monotone. Consider the argument filtering π defined by π(rand) = {1} and π(f ) = {1,..., n} for all other function symbols f where n is the arity of f . Note that A and all labeling functions are π-conform. We have Cl,π = {(22)–(25)}. According to Theorem 5.9, termination of R follows from termination of lab(R) ∪ Ðec. The rules (for all j > i ≥ 0)
id-inc(x) → x		nonZero(0) → false id-inc(x) → s(x)	nonZero(s(x)) → true
p(s(x)) → x	random(x) → randi(x, 0)
p(0) → 0	randi(x, y) → ifi(nonZero(x), x, y)
ifi(false, x, y) → y	ifi+1(true, x, y) → randmax(i−1,0)(p(x), id-inc(y))
randj(x, y) → randi(x, y)	ifj(b, x, y) → ifi(b, x, y) of the latter TRS are oriented by LPO with precedence
random N ··· N rand1 N if1 N rand0 N if0 N nonZero N id-inc N p N s N true N false.
Conclusion
We have analyzed how the powerful technique of semantic labeling can be used to prove innermost termination. It turned out that semantic labeling can be used for models but not for quasi-models. We extended our results to predictive labeling such that one only has to find a model for the usable as opposed to all rules. This approach was further improved by incorporating argument filters. The latter extension was finally integrated with predictive labeling for termination.
The results presented in this paper should be implemented in order to test their effectiveness and combined with dependency pairs [1] to increase their applicability.

Semantic [9] and predictive [4] labeling with infinite (quasi-)models for termination have been implemented in the automatic termination prover TPA [6]. The under- lying theory is worked out in [8] and [7]. In the latter paper predictive labeling for termination is combined with dependency pairs. Modifying these results to cover innermost termination is straightforward. Incorporating argument filterings will in- crease the search space but otherwise poses no challenge. We anticipate that the power of TPA and other termination provers will be increased by the results of this paper.

References
Arts, T. and J. Giesl, Termination of term rewriting using dependency pairs, Theoretical Computer Science 236 (2000), pp. 133–178.
Baader, F. and T. Nipkow, “Term Rewriting and All That,” Cambridge University Press, 1998.
Giesl, J., R. Thiemann, P. Schneider-Kamp and S. Falke, Mechanizing and improving dependency pairs, Journal of Automated Reasoning 37 (2006), pp. 155–203.
Hirokawa, N. and A. Middeldorp, Predictive labeling, in: Proc. 17th International Conference on Rewriting Techniques and Applications, LNCS 4098, 2006, pp. 313–327.
Hirokawa, N. and A. Middeldorp, Tyrolean termination tool: Techniques and features, Information and Computation 205 (2007), pp. 474–511.
Koprowski, A., TPA: Termination proved automatically, in: Proc. 17th International Conference on Rewriting Techniques and Applications, LNCS, 2006, pp. 275–266.
Koprowski, A. and A. Middeldorp, Predictive labeling with dependency pairs using SAT, in: Proc. 21st International Conference on Automated Deduction, LNAI 4603, 2007, pp. 410–425.
Koprowski, A. and H. Zantema, Recursive path ordering for infinite labelled rewrite systems, in: Proc. 3rd International Joint Conference on Automated Reasoning, LNAI 4130, 2006, pp. 332–346.
Zantema, H., Termination of term rewriting by semantic labelling, Fundamenta Informaticae 24 (1995),
pp. 89–105.
