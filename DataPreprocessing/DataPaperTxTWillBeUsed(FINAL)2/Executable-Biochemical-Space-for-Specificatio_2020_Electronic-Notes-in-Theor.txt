Available online at www.sciencedirect.com


Electronic Notes in Theoretical Computer Science 350 (2020) 91–116
www.elsevier.com/locate/entcs
Executable Biochemical Space
for Specification and Analysis of Biochemical Systems
Matej Troja´k, David Sˇafra´nek, Luboˇs Brim
Systems Biology Laboratory, Masaryk University, Brno, Czech Republic
Jakub Sˇalagoviˇc, Jan Cˇerveny´
Global Change Research Centre AS CR, v. v. i., Brno, Czech Republic

Abstract
We present the second generation of a rule-based language called Biochemical Space Language (BCSL) that combines the advantages of different approaches and thus makes an effort to overcome several problems with existing solutions. The key aspect of the language is the level of abstraction it uses, which allows scalable and compact hierarchical specification of biochemical entities. This abstraction enables unique analysis techniques to reason about properties of models written in the language on the semantic and syntactic level.
Keywords: rule-based modelling, formal specification, static analysis

Introduction
Modelling complex systems in systems biology has to be conducted at several lev- els of abstraction that reflect well the known information [14]. At every level, the system has to be described rigorously in a formal language that allows avoiding misunderstood and ambiguous interpretations. The more complex the system is, the harder it is to describe it rigorously while not losing human-readability and compactness of the description at the same time. A modern biochemical system specification language that can be sufficiently employed in systems biology practice has to be hierarchical and executable. Hierarchical description allows expressing

Contact: xtrojak@fi.muni.cz or safranek@fi.muni.cz
This work has been supported by the Czech Science Foundation grant 18-00178S and Czech National Infrastructure grant LM2015055.

https://doi.org/10.1016/j.entcs.2020.06.006
1571-0661/© 2020 The Author(s). Published by Elsevier B.V.
This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).

individual system components at different levels of detail. Since not all biochem- ical structures are known in detail, the language has to support the expression of partial knowledge. On the other end, executability allows automatic assigning the description with appropriate formal (mathematical or programming) structures that enable simulation and exhaustive analysis of desired properties or revealing bugs in the description.
Traditional approaches used to describe biochemical systems are: (i) a chem- istry approach employing “mechanical” descriptions by chemical reactions or (ii) a mathematical approach using ordinary differential equations or other mathematical formalisms. The problem of both approaches is scalability in the description of the model and in its execution: even when the formulation of a model does not run into scalability issues, the execution or simulation might still be infeasible [24]. To that end, computer science offers a computational approach based on abstract languages with a variety of rigorous executable semantics. Relations among these approaches have been discussed in [4] and [12].
A promising computational approach is provided by rule-based modelling [7,9] and process-algebraic frameworks [4,5,23]. Rule-based models make a natural ex- tension of the mechanical reaction-based models used in chemistry. Instead of op- erating with objects, rule-based frameworks operate with types that allow avoiding the combinatorial explosion that occurs when underlying objects are specified di- rectly. The semantics of the model is given in terms of rules defined on given types. An important advantage of rule-based approach is that mathematical models can be automatically generated from them. In particular, instead of relying on a single mathematical formalism, different mathematical models can thus be obtained for a given model (e.g., ODEs [3], PDEs [1], chemical master equation or continuous-time Markov chains [19,25], reaction-diffusion systems [26], etc.).
Although rule-based models make a great alternative to mathematical models, they are not yet sufficiently used in practice. The reason is that existing formalisms rely on cryptic (symbolic) syntax and they are limited to a specific subset of inter- actions or are too abstract: BNGL [9] and Kappa [7] target protein-protein binding; BioSPI [23] and SPiM [22] use very elemental asymmetric binary synchronisation primitives; BioPEPA [5] adapts process-algebraic framework to chemical reactions while relaxing the compactness of combinatorial interactions; Chromar [13] utilises functional programming. These languages can be thus understood as low-level for- malisms that allow precise formal description and analysis of biological processes. Several high-level frameworks have been developed based on principles of these for- malisms: rxncon [24] focuses on regulatory interactions and allows construction of rules from experimental evidence, LBS [21] and LBS-κ [20] enrich rule-based framework with modularity, PySB [17] embeds Kappa and BNGL into Python, MetaKappa [6] extends Kappa language by hierarchical inheritance of agent sites, BioCHAM [2] explicitly separates rules from their mathematical semantics. None of these frameworks provides a sufficiently universal solution for description and annotation of heterogeneous biophysical processes integrated at the cellular level. Apparently, different approaches need to be combined accordingly to make a uni-

versal hierarchical modelling and annotation base that supports executability. The work presented in [18] targets bringing annotation standards into rule-based frame- works.
On the other end, SBML multi [29] transfers rule-based description into a uni- versal XML format that fixes the hierarchical structure of objects and modularity of rules. It moves the rule-based paradigm towards a standard technique of describ- ing biological systems. However, it does not directly solve the executability and advanced analysis issues that make an important aspect of rule-based frameworks. Our long-term aim is the development of a general modelling framework [16,27].
Together with general annotation format Biochemical Space [15], it respects the need for maintaining existing ODE models but allows to align them with a mecha- nistic rule-based description that is understandable by biologists, compact in size, executable in terms of allowing basic analysis tasks ensuring consistency of the de- scription, and provides links to existing bioinformatics annotation databases. Such a comprehensive solution allows supporting modellers effort in building mathematical models that have clear biochemical meaning and can be easily integrated. More- over, mechanistic descriptions can be later used as computational models having all advantages of rule-based modelling. To that end, we have pioneered an idea of combining advantages of rule-based modelling with the simplicity of chemical reac- tions by introducing the first prototype of a high-level rule-based language called Biochemical Space Language (BCSL), introduced in [8]. The language has been de- fined at the top of Kappa. BCSL aims at higher-level abstraction than Kappa that focuses on morphisms between protein binding sites. Therefore the Kappa-based formulation of BCSL has limited expressiveness and does not fit well the aims of our framework. Additionally, Kappa does not provide hierarchical description which is one of the key aspects of BCSL.
In this paper, BCSL is redefined and significantly improved with respect to the primary prototype presented in [8]: (i) hierarchical and composable object types and rules are defined without the need to encode them in an existing rule-based framework thus avoiding any loss of information, (ii) executable semantics of rules is defined directly at the level of the language thus making a base for unique analysis tasks specific for the considered level of abstraction, (iii) software tool is available to maintain and analyse BCSL specifications – BCSgen 1 . The new version of BCSL emphasises the following aspects: (i) human-readability (easy to read, write, and maintain), (ii) executability (formal executable semantics is defined allowing efficient static analysis and consistency checking), (iii) universality (principally different cel- lular processes can be sufficiently combined in a single specification), (iv) scalabil- ity (combinatorial explosion of the description is avoided), (v) hierarchy (object types are described hierarchically allowing compositional assembly from simpler structures). Moreover, we provide several static analysis techniques which take the advantage from the specific level of abstraction. They are aimed primarily at consis- tency checking, model reduction and reachability analysis. Particularly, rule redun- dancy elimination allows detecting unnecessary rules in the models, context-based

1 https://github.com/sybila/BCSgen

reduction and static non-reachability analysis uniquely deal with non-reachability in terms of preventing expensive transition system enumeration in cases when it is not necessarily needed. These techniques are demonstrated on a model of ﬁbroblast growth factor (FGF) signalling pathway and show practical impact in the field of static analysis.
Formal definition of Biochemical Space Language
In this section, we formally define Biochemical Space Language. At first, we define all the required objects (so called agents) and interactions among them (so called rules; for an example, see Figure 1), then we define syntax of the language and semantics of the BCSL models.

KaiC protein
KaiBC dimer


S{u}:: KaiC :: KaiBC ::cyt ⇒ S{p}:: KaiC :: KaiBC ::cyt


Serine residue (unphosphorylated)
Serine residue (phosphorylated)
cytosol


Fig. 1. An example of a rule. The rule describes the change of serine (S) amino acid residue from an unphosphorylated to phosphorylated state. Additionally, such phosphorylation can happen only when the serine is part of a KaiC protein, which occurs inside a protein complex of KaiC and KaiB proteins. The entire process is allowed only inside of cytosol (cyt) compartment.


Formal preliminaries
Before we proceed, we provide some basic definitions and notations in order to build the formal definition for the language.
Definition 2.1 (Multiset ) Multiset Ω isa pair (A, m) where A is a set and m : A→ N is a function from A to the set of natural numbers. The set A is called the reference set of elements. For each element a in A the multiplicity (that is, number of occurrences) of a is the number m(a).
Notation 2.2
Let S be a set. By ΩS we denote the set of all possible ﬁnite multisets (A, m)
such that A⊆ S.
Let O = (o1,..., on) be a tuple.
By Ω(O) we denote a multiset constructed from tuple O.
By σ(O) we denote a set of all possible permutations of length n of the tuple O.
By |Y | we denote (i) dimension of tuple Y or (ii) cardinality of (multi)set Y .

Definition 2.3 (Labelled transition system) Labelled transition system (LTS) L is a quadruple (S, A, T, s0) where S is a set of states, A is a set of labels, T ⊆ S×A×S is a transition relation, and s0 ∈ S is an initial state.
Definition 2.4 (Path in LTS ) Let L = (S, A, T, s0) be an LTS. We define path as a sequence of states s1s2s3 ... such that ∀si, si+1 : (si, a, si+1) ∈ T for some a ∈ A.
Definition 2.5 (Tuples concatenation) Let X = (x1,..., xn),Y = (y1,..., ym) be two tuples for some n, m ∈ N. Concatenation of two tuples, written X ++ Y , is defined as: X ++ Y = (x1,..., xn, y1,..., ym).
Definition 2.6 (Sum of concatenations) Let T = (T1, T2,..., Tn) be sequence of
tuples for some n ∈ N. Concatenation of sequence of tuples ++n  Ti is defined as:

n i=1
Ti = T1 ++ T2 ++ ... ++ Tn


Objects deﬁnition
Let NA, NT , Nδ, Nc be mutually exclusive finite sets of atomic names, structure names, states, and compartments respectively. Moreover, ε is a reserved symbol and does not belong to any of these sets.
For better readability, we provide examples of syntax for the most important objects with their definitions. The formal definition of syntax and the relation to the objects are given below (Sections 2.3 and 2.4).

Signature
Definition 2.7 (Signature) Atomic signature is a function ΣA : NA → 2Nδ that associates each atomic name to a set of state names. Similarly, structure signature is a function ΣT : NT → 2NA that associates each structure name to a set of atomic names.
Signatures define a set of allowed states for an atomic name and an allowed set of atomic names for a str ucture name. For example,  S} → {u, p}, Q → {a, i}  is

Atomic agent
Definition 2.8 (Atomic agent ) An atomic agent A is a pair (η, δ) where η ∈ NA is a name and δ ∈ Nδ ∪ {ε} is a state. The name and the state of the agent A is usually denoted by η(A) and δ(A), respectively.
Atomic agents are the simplest objects used for describing biological entities. Each atomic agent has its name and state. Allowed set of admissible states for the atomic agent (with additional empty ε state) is given by signature ΣA(η).
Definition 2.9 (Equality relation of atomic agents) Let A, Aj be atomic agents. A
is equal to Aj, written A = Aj, iff η(A)= η(Aj) ∧ δ(A)= δ(Aj).

Intuitively, the defined equality on atomic agents is an equivalence relation.
Notation 2.10 We use the symbol A to denote the universe of all possible atomic agents.
Atomic agents are usually used to express small biological entities which can change their state, for example, amino acids, small inorganic molecules, etc. Ex- amples of atomic agents are A1 = (S, u), written as S{u}, and A2 = (Q, ε), written as Q{ε}. Note the meaning of ε is the state is unknown or not important to be considered in a given context.
Definition 2.11 (Compatibility of atomic agents) Let A1, A2 be atomic agents. The agent A1 is compatible with agent A2, written A1  A2, if either A1 = A2 or η(A1)= η(A2) Λ δ(A1)= ε.
Compatibility of atomic agents is a key property defined between agents. An agent is compatible with anothet agent if they have the same name and they are in the same state or the first agent is in the unknown state. It provides a formal way to compare which agent is more detailed, i.e. its state is more specified.
Definition 2.12 (Fully speciﬁed atomic agent ) Let A ∈ A be an atomic agent. We say the agent A is fully speciﬁed, written ΔA, iff 6Aj ∈ A such that Aj /= A : ч(Aj  A).

Structure agent
Definition 2.13 (Structure agent ) We define a structure agent T as a pair (η, γ) where η ∈ NT is a name and γ ⊆ A is a set of atomic agents called partial compo- sition such that 6A, Aj ∈ γ : η(A) /= η(Aj). The name and the partial composition of the agent T is usually denoted by η(T) and γ(A), respectively.
A structure agent represents a biochemical object that is composed of several known atomic agents while we know that a composition is abstract and not necessar- ily complete. To incorporate this kind of abstraction into our language, a structure agent is defined to be labelled with a unique name and a set of atomic agents. This set is restricted according to the given structure signature with the same name as the structure agent.
Definition 2.14 (Equality relation of structure agents) Let T, Tj be structure agents.
T is equal to Tj, written T = Tj, iff η(T)= η(Tj) Λ γ(T)= γ(Tj).
Intuitively, the defined equality on structure agents is an equivalence relation. The key construct of a structure agent is partial composition defined as a set of atomic agents which are considered to be relevant parts of the structure agent. We allow this set to be empty with the meaning of a biological structure for which we do not know its composition.
Notation 2.15 We use symbol T to denote the universe of all possible structure agents.

A typical example of a structure agent is a protein where the atomic agents are amino acids that are of interest in the particular setting. Imagine that in our modelled system only three out of a few hundred amino acids are able to undergo some post-translational modifications, such as phosphorylation, metylation etc. It is suitable to model only these three amino acids instead of entire primary structure of the protein. Examples of structure agent are T1 = (K,{(S, p), (Q, i)}), written as K(S{p}, Q{i}), and T2 = (K,{(Q, a)}), written as K(Q{a}).
We define difference on the level of partial compositions of structure agents, which is necessary for definition of semantics below.
Definition 2.16 (Difference of partial compositions) Let γ, γj be partial composi- tions. We define difference of partial compositions γ g γj = {A | A ∈ γ Λ A /∈ γ ∩ γj} where γ ∩ γj = {A | A ∈ γ Λ ∃Aj ∈ γj : η(Aj)= η(A)}.
Definition 2.17 (Compatibility of structure agents) Let T1, T2 be structure agents. The agent T1 is compatible with agent T2, written T1  T2, iff either T1 = T2 or η(T1)= η(T2) Λ 6A1 ∈ γ(T1) ∃A2 ∈ γ(T2) : A1  A2.
Structure agents are compatible if it is possible to create pairs from atomic agents of composition of the first agent with the second ones such that these atomic agents are all unique. For such pairs, the agents in each pair must be compatible. It provides a formal way to compare which agent is more specified, i.e. particular states of atomic agents in partial composition are given or not.
Definition 2.18 (Fully speciﬁed structure agent ) Let T ∈ T be a complex agent. We say the agent T is fully speciﬁed, written ΔT, iff 6Tj ∈ T such that Tj /= T : ч(Tj  T).
Complex agent
A complex agent represents a non-trivial composite biochemical object that is induc- tively constructed from already known biological objects. In rule-based languages, this is usually defined by introducing bonds between individual biochemical objects. In BCSL we abstract from the detailed specification of bonds and we rather assume a complex as a coexistence of certain objects in a particular group. Moreover, a complex agent resides in a compartment which gives it a spatial position.
Definition 2.19 (Complex agent ) We define a complex agent X as a pair (μ, com) where μ ∈ (A ∪ T)n is a sequence of agents, com ∈ Nc is a compartment, and n ∈ N. The sequence and the compartment of the agent X is usually denoted by μ(X) and com(X), respectively.
The key element of a complex agent is sequence inductively constructed from existing agents. In contrast to partial composition in structure agent, we allow replication at the level of sequence (an agent of a certain name can appear more than once in a sequence). The order in the sequence is necessary to uniquely identify agents which are equal. On the other hand, when comparing two sequences, we do it regardless the order.

Definition 2.20 (Equality relation of complex agents) Let X, Xj be complex agents.
X is equal to Xj, written X = Xj, iff com(X)= com(Xj) Λ Ω(μ(X)) = Ω(μ(Xj)).
Intuitively, the defined equality on complex agents is an equivalence relation. Example of a complex agent is X = ((K,{(S, p), (Q, i)}), (S, p)), cell , written as K(S{p}, Q{i}).S{p} :: cell.
Notation 2.21 We use the symbol X to denote the universe of all possible complex agents.
The complex agents encapsulate other agents – an atomic or a structure agent cannot exist on its own (the case when only one item is in its sequence can occur). This guarantees each atomic and structure agent has indirectly given spatial location – the compartment.
Definition 2.22 (Compatibility of complex agents) Let X1, X2 be complex agents. The complex agent X1 is compatible with complex agent X2, written X1 X2, iff either X1 = X2 or com(X1) = com(X2) Λ ∃μj ∈ σ(μ(X2)) such that 6i ∈ [1, n] : μi(X)  μj,
where n is length of sequence which is the same for both sequences.
Complex agents are compatible if there exists a permutation of the sequence of the first agent such that individual agents on the same position in both sequences are compatible. It provides a formal way to compare which agent is more specified.
Definition 2.23 (Fully speciﬁed complex agent ) Let X ∈ X be a complex agent. We say the agent X is fully speciﬁed, written ΔX, iff 6Xj ∈ X such that Xj /= X : ч(Xj  X).
It worth noting that the complexes have no binding topology. While it provides many advantages, specifically when it comes to combinatorial explosion, it also has several drawbacks. The most important one is that we are not able to express structural modifications on the level of complexes. These have to be encoded using states.

Rule
Let us have a simple example of a rule:
K(S{u}).B(∅) :: cyt ⇒ K(S{p}) :: cyt + B(∅) :: cyt.
This rule dissociates a complex of K and B (both structure agents) to two separate agents while the structure agent K is changing the state of its atomic agent S from u to p. In order to describe the rule formally, we need to capture the relation between so-called left-hand side (the part before ⇒ symbol) and right-hand side (the part after ⇒ symbol). It is achieved by indexing the individual positions in the rule and creating index maps between them.
Definition 2.24 (Rule) We define a rule R as a quintuple (χ, ω, ι, ϕ, ψ) where:
χ ∈ Xn is a sequence of complex agents,
ω ∈ (A ∪ T)m is a sequence of atomic and structure agents,

ι ∈ {0,..., n} is an index determining the end of the left-hand side (LHS ) of
χ,
ϕ ∈ Nm is an index map from ω to χ,
ψ ∈ (({−} ∪ N)2)n is an index map from LHS to RHS
where n, m ∈ N, LHS = (χ1,..., χι) is the left-hand side, and RHS = (χι+1,..., χn) is the right-hand side.
The reason for this particular definition is that it is necessary to capture the relationship between the left-hand side and the right-hand side of the rule. This is done by enumerating all atomic and structure agents ω from sequence of complex agents χ. The index map ψ between the agents in ω determines pairs of agents from the left-hand side and the right-hand side which correspond to each other. It is possible that there are agents which do not have a pair (denoted by −) in the situation when the rule is modelling inflow from (resp. outflow to) the system. Another index map ϕ serves for relating agents from ω back to the original sequence of complexes χ. Finally, by index ι we determine the end of the left-hand side of the rule. Note the index is zero in the situation when there are no agents on the left-hand side.
Notation 2.25 We use symbol R to denote the universe of all possible rules.
Example of a rule is R = (χ, ω, ι, ϕ, ψ) where:
χ	=	• ω	=

⎡	 ((K,{(S, u)}), (B, ∅)), cyt ,	⎤
 	 

⎢	 ((A, ε)), cyt ,	⎥
⎡⎢⎣⎢
(K,{(S, u)}), (B, ∅), (C, ∅),
(D, i), (A, ε), (K,{(S, p)}),
(B, ∅), (C, ∅), (D, a), (A, ε), (H, u)
⎤⎥⎥⎦

⎢ ((K,{(S, p)}), (B, ∅), (C, ∅)), cyt ,⎥
ι =3 

⎢	 ((D, a), (A, ε)), cyt ,
ϕ = (2, 4, 5, 8, 10, 11)
⎥

writ⎣ten as:
 ((H, u)), cyt
ψ	=
[(1, 6); (2, 7); (3, 8); (4, 9); (5, 10); (−, 11)]

K(S{u}).B(∅) :: cyt + C(∅).D{i} :: cyt + A{ε} :: cyt ⇒ K(S{p}).B(∅).C(∅) :: cyt + D{a}.A{ε} ::
cyt + H{u} :: cyt
Not every rule makes sense. For example, a rule where not a single agent is changed or a rule where the relation between the left-hand and the right-hand side would not be clear. In order to avoid such cases we need to specify when a rule is well-formed, i.e. it makes sense semantically.
Definition 2.26 (Well-formed rule) Let R be a rule and i, j ∈ N. We say the rule
R = (χ, ω, ι, ϕ, ψ) is well-formed if all the following conditions hold:
at least one of conditions holds:
∃(i, j) ∈ ψ : ωi /= ωj,
|LHS (R)| /= |RHS (R)|,

∃i ∈ [1, ι]: com(χi) /= com(χι+i);
6(i, j) ∈ ψ : η(ωi)= η(ωj);
6(−, i) ∈ ψ : Δωi.
A rule is well-formed if it holds conditions given in Definition 2.26. The condi- tions basically claim that an agent has to change during the rule application. This is ensured by condition (i), where there are three options: (a) at least one pair of agents from LHS and RHS of the rule is different; (b) the lengths of the LHS and RHS are different, i.e. either a new agent is created or complex is formed/dissociated;
(c) a compartment is changed. Any combination of these sub-conditions is allowed. The second condition (ii) guarantees that the pairs of structure and atomic agents in ω of the rule have the same name. Please note the conditions (i) and (ii) do not apply to those agents in ω which do not have a pair on the other side of the rule. Finally, the condition (iii) claims that if there is an agent which does not have defined a pair via index map ψ (denoted by −), it is required to be a fully specified agent (but only in case of agent creation, it is not necessary for agent degradation).

Syntax
In this section, we define the syntax for the language, i.e. how we usually write it in order to make the notation easily writeable and readable. It corresponds to the examples given while defining agents and rules above.
Definition 2.27 (Grammar )

Atomic expressionStructure expression	Complex expression
α ::= η{s} | η{ε} τ ::= η(γ) | η(∅)	Γ ::= β1	βk :: c
η ::= n ∈ NA	γ ::= α1,..., αk	βi ::= α | τ
s ::= n ∈ Nδ	η ::= n ∈ NT	c ::= n ∈ Nc

Rule expression	Q ::= Γ1 + ... + Γn ⇒ Γn+1 + ... + Γm where m, n ∈ N0 Λ m > n and k ∈ N.
Translation function
Once we defined BCSL agents and rules and syntax for the language, we need to connect them in order to give semantic meaning to a model written in the syntax. For this purpose, we define translation function F (Definition 2.28). It is defined recursively according to the expression given as an argument.

Definition 2.28 (Translation function) We define translation function F according to the expression given in double square brackets J ... ) as follows:
FJ η{ε} )	=	(η, ε) ∈ A
FJ η{s} )	=	(η, s) ∈ A
FJ η(∅) )	=	(η, ∅) ∈ T
FJ η(a1,..., ak) )	=	η, { FJa1),..., FJak) } ∈ T
FJ α1 . . . . . αk :: c )	=	(FJ α1 ),..., FJ αk )), c ∈ X
FJ Γ1 + ... + Γn ⇒ Γn+1 + ... + Γm )	=	(χ, ω, ι, ϕ, ψ) ∈ R such that:
χ = FJ Γ1 ),..., FJ Γn ), FJ Γn+1 ),..., FJ Γm ) ,
ω = ++|χ| μ(χi),

ι = n,
ϕ = (J1,..., Jm) where Jk =



k i=1

|μ(χi)|,

{ (i, j) | i ∈ [1, ϕι] Λ j ∈ [ϕι + 1, |ω|] Λ |i − j| = ϕι } ∪ 
ψ =	{ (i, −) | i ∈ [k, ϕι] Λ k = |ω|− ϕι +1 | } ∪ 
⎪⎩{ (−, j) | j ∈ [k, |ω|] Λ k =2 × ϕι +1 }
where ψ is defined together with an ordering such that symbol j−j > k for every k ∈ N and all descending intervals in definition of ψ are ignored.
Note that the translation function works only on expressions defined in Defini- tion 2.27. The function recursively creates objects from given expressions. Every rule expression is first decomposed to LHS and RHS, and consequently each agent expression is translated to an object. The appropriate index maps are created from sequence of complexes χ and sequence of atomic and structure agents ω.

BCSL model
We proceed to the BCSL model definition. We always consider an initialised model, which means the definition contains an initial state of the system (a solution, Defi- nition 2.29). The definition of BCSL model also contains rules and signatures.
Definition 2.29 (Solution) Solution is a multiset S ∈ ΩX such that A is the reference set of S and 6X ∈A : ΔX.
Definition 2.30 (BCSL model ) We define BCSL model M as a quadruple (R, ΣA, ΣT, S) where R is a set of rules, ΣA is an atomic signature, ΣT is a structure signature, and
S is an initial solution.
A BCSL model is formed by a set of rules R, which define the behaviour of the model. The initial solution S defines the state of the model in the beginning.

Atomic signature ΣA defines allowed states for all atomic agents used in the rules. Finally, structure signature ΣT defines allowed atomic agents for all structure agents used in the rules.
Matching
At this point, we define matching, which will be used in the definition of semantics for a BCSL model M.
Definition 2.31 (Matching ) Let R = (χ, ω, ι, ϕ, ψ), r = (χj, ωj, ιj, ϕj, ψj) be two rules, S ∈ ΩX be a solution, and i, j ∈ N. Let |= ⊆ R × ΩX × R be the matching relation such that a tuple (R, S, r) ∈ |=, written R |=r S, iff
ι = ιj Λ ϕ = ϕj Λ ψ = ψj,
|χ| = |χj|Λ |ω| = |ωj|,
6i ∈ [1, |χ|]: χj  χi,
Ω(LHS (r)) = S,
6(i, j) ∈ ψ :

  ωj = ωj
if	ωi = ωj


i	j
(b) ωi ∈ T ⇒ γ(ωj) g γ(ωi)= γ(ωj ) g γ(ωj).
i	j
Remark 2.32 Note the rule r from the tuple (R, S, r) ∈ |= is so-called reaction, which is characterised as an instance of the rule R. For every rule in a model, it is possible to enumerate all potential reactions and this way convert a rule-based model to a reaction-based model.
Semantics
Definition 2.33 (Replacement ) Let →⊆ ΩX ×R×ΩX be the replacement relation
s.t. a tuple (S, R, Sj) ∈ →, written S →R Sj, iff ∃r ∈ R ∃x ⊆ S such that R |=r
x Λ Sj \ (S\ x)= Ω(RHS (r)).
Replacement relation defines how a solution is transformed according to a given rule. For a BCSL model M, rules yield a labelled transition system LTS(M) between solutions containing an edge S →R Sj. Note that we can achieve the equivalent behaviour if we first generate all possible reactions from the rules and apply replacement with them instead (a rule is just a generalised set of reactions).
Syntactic extensions
In this section, we define several syntactic extensions which increase the readability of the rule expressions. Note that each rule expression in an extended form can always be translated to basic form defined above (Section 2.3). All rule expressions containing the following extensions must be converted to basic form before the semantics can be applied. For better demonstration, we provide a running example,

which will go through all syntactic extensions (Running example 3.1). Please note there is no biological sense of the example model, its only purpose is to effectively demonstrate all defined syntactic extensions.
Running example 3.1 (The example model M)
KaiC(S{u},T {ε}).KaiC(S{ε},T {ε}).KaiC(S{ε},T {ε}) :: cyt ⇒
⇒ KaiC(S{p},T {ε}).KaiC(S{ε},T {ε}).KaiC(S{ε},T {ε}) :: cyt
KaiC(S{u},T {ε}).KaiB(∅) :: cyt ⇒ KaiC(S{p},T {ε}).KaiB(∅) :: cyt
KaiC(S{ε},T {ε}) :: cyt + KaiC(S{ε},T {ε}) :: cyt + KaiC(S{ε},T {ε}) :: cyt ⇒
⇒ KaiC(S{ε},T {ε}).KaiC(S{ε},T {ε}).KaiC(S{ε},T {ε}) :: cyt
KaiC(S{ε},T {ε}).KaiC(S{ε},T {ε}).KaiC(S{ε},T {ε}) :: cyt ⇒
⇒ KaiC(S{ε},T {ε}) :: cyt + KaiC(S{ε},T {ε}) :: cyt + KaiC(S{ε},T {ε}) ::
cyt
ΣA = , S → {u, p},T → {a, i} ,
ΣT = , KaiC → {S, T },KaiB →∅ ,
We omit the initial state definition just for simplicity of the example since all the extensions concern only rule expressions.

Partial composition context elimination
It is possible to omit all atomic expressions with unspecified state ε from partial compositions of structure agents (Running example 3.2). Such agent expressions do not give any additional information and whole partial composition can be recon- structed from the given signature.
Running example 3.2 (The example model M)
KaiC(S{u}).KaiC(∅).KaiC(∅) :: cyt ⇒ KaiC(S{p}).KaiC(∅).KaiC(∅) ::
cyt
KaiC(S{u}).KaiB(∅) :: cyt ⇒ KaiC(S{p}).KaiB(∅) :: cyt
KaiC(∅) :: cyt + KaiC(∅) :: cyt + KaiC(∅) :: cyt
⇒ KaiC(∅).KaiC(∅).KaiC(∅) :: cyt
KaiC(∅).KaiC(∅).KaiC(∅) :: cyt ⇒ KaiC(∅) :: cyt + KaiC(∅) :: cyt +
KaiC(∅) :: cyt
Additionally, this extension can go even further by omitting the (∅) part from structure agents completely (Running example 3.3). Since we have the structure signature ΣT defined, we can unambiguously determine which names belong to struc- ture agents and this syntactic part can be easily reconstructed.
Running example 3.3 (The example model M)
KaiC(S{u}).KaiC.KaiC :: cyt ⇒ KaiC(S{p}).KaiC.KaiC :: cyt
KaiC(S{u}).KaiB :: cyt ⇒ KaiC(S{p}).KaiB :: cyt
KaiC :: cyt + KaiC :: cyt + KaiC :: cyt ⇒ KaiC.KaiC.KaiC :: cyt

KaiC.KaiC.KaiC :: cyt ⇒ KaiC :: cyt + KaiC :: cyt + KaiC :: cyt
This syntactic extension brings a lot of readability to the syntax while preserving all information in the context of the model M.

Complex signature
We extend the model definition by complex signature ΣX (Running example 3.4). In this signature, there are defined aliases for valid complex expressions. Then, the original complex expressions are substituted by the aliases.
Running example 3.4 (The example model M)


Definition of complex signature ΣX
= ⎧⎨ KaiC3 :: cyt → KaiC.KaiC.KaiC :: cyt, ⎫⎬

KaiBC :: cyt → KaiC.KaiB :: cyt
KaiC(S{u}).KaiC.KaiC :: cyt ⇒ KaiC(S{p}).KaiC.KaiC :: cyt
KaiC(S{u}).KaiB :: cyt ⇒ KaiC(S{p}).KaiB :: cyt
KaiC :: cyt + KaiC :: cyt + KaiC :: cyt ⇒ KaiC3 :: cyt
KaiC3 :: cyt ⇒ KaiC :: cyt + KaiC :: cyt + KaiC :: cyt
The usage of the complex signature has its limitations. Once a context is spec- ified, the alias cannot be used. We will resolve this problem in the following exten- sions.

Directions
We allow rule expressions to be bi-directional – it is just a shortcut for two rule expressions and it can be converted to the basic rule expression form. A rule expression Q : l  ⇔ r can be written as two rule expressions Q1 : l  ⇒ r and Q2 : r ⇒ l (Running example 3.5).
Running example 3.5 (The example model M)
KaiC(S{u}).KaiC.KaiC :: cyt ⇒ KaiC(S{p}).KaiC.KaiC :: cyt
KaiC(S{u}).KaiB :: cyt ⇒ KaiC(S{p}).KaiB :: cyt
KaiC :: cyt + KaiC :: cyt + KaiC :: cyt ⇔ KaiC3 :: cyt
Definition of rules (iii) and (iv) from Running example 3.4 was replaced by one bi-directional rule (iii) in Running example 3.5.

Stoichiometry
For a rule expression of form:
β1 :: c + β2 :: c + ... + βn :: c ⇒ β1.β2	βn :: c
we can reorder both sides such that we get non-crossing partition P = B1/B2/.	/Bk

with k ≤ n from its indices [1,..., n] such that: 6B ∈ P 6β, βj ∈ B : β = βj and
6B, Bj ∈P 6β ∈ B 6βj ∈ Bj : β /= βj such that B /= Bj.
For the left-hand side β1 :: c+β2 :: c+.. .+βn :: c of the reordered rule expression we can replace all rule expressions [βi,..., βj] which belong to the same non-crossing partition B by notation ‘k βj, where β is a representative from βi,..., βj (they are all equivalent) and k is the number of the expressions in partition B (Running example 3.6). Note that this process is fully reversible – we can simply enumerate all expressions for each partition.
Running example 3.6 (The example model M) Definition of rule expressions:
KaiC(S{u}).KaiC.KaiC :: cyt ⇒ KaiC(S{p}).KaiC.KaiC :: cyt
KaiC(S{u}).KaiB :: cyt ⇒ KaiC(S{p}).KaiB :: cyt
3 KaiC :: cyt ⇔ KaiC3 :: cyt
Definition of rule expression (iii) from Running example 3.5 was replaced by a new rule expression using stoichiometry.

Locations
The localisation operator is intended for allowing an alternative way of expressing the hierarchically constructed agent expressions (Running example 3.8). The main idea is to allow zooming into individual parts of complex and structure expressions. For this purpose, we use a :: b notation such that a, b are arbitrary agents which satisfy one of the conditions given in Definition 3.7.
Definition 3.7 (Location conditions)
A :: T ⇔ there exists Aj ∈ γ(T) such that A  Aj,
A :: X ⇔ there exists Aj ∈ μ(X) such that A  Aj,
T :: X ⇔ there exists Tj ∈ μ(X) such that T  Tj.
For each pair of agents (α, β) with allowed ‘::’ operator between them, we can construct just one agent βj without the operator by taking the most left agent αj from full (resp. partial) composition of the agent β such that it is compatible with the agent α. Then, agent αj is merged with agent α and agent βj is constructed.
Running example 3.8 (The example model M)
S{u} :: KaiC :: KaiC3 :: cyt ⇒ S{p} :: KaiC :: KaiC3 :: cyt
S{u} :: KaiC :: KaiBC :: cyt ⇒ S{p} :: KaiC :: KaiBC :: cyt
3 KaiC :: cyt ⇔ KaiC3 :: cyt
Definition of rule expressions (i) and (ii) from Running example 3.6 was replaced using locations. The localisation operator allowed us to additionally use the complex signatures.

Variables
Rule expressions (i) and (ii) from Running example 3.8 are very similar except for the context of complex expression they take place in. We can substitute this context with a variable with a given domain.
In a rule expression, one agent expression might be referenced using a variable as a set of rule agent expressions it can be replaced with (Running example 3.9). Such an agent expression is referenced as ?X. Moreover, in the case when a ?X is used in a location, it must hold conditions from Definition 3.7.
Each rule expression associated with a variable can be easily written as several rule expressions where the variable is replaced with agent expression from the set of agent expressions attached to the variable. For simplicity, only one variable can be used per rule expression.
Running example 3.9 (The example model M)
S{u} :: KaiC :: ?X :: cyt ⇒ S{p} :: KaiC :: ?X :: cyt ; ?X = {KaiC3, KaiBC}
3 KaiC :: cyt ⇔ KaiC3 :: cyt
Definition of rule expressions (i) and (ii) from Running example 3.8 was replaced as a single rule expression with a variable.
This is the final syntactic extension. Compared to the original model (Running example 3.1), the resulting model is more concise and readable.
Static analysis
The BCS language offers interesting capabilities to provide several static analysis techniques of given models. These techniques are based on defined compatibility operator  , which formulates suitable properties for each type of agent.
Definition 4.1 (Ordering of agents) Let x1, x2 be two arbitrary agents. The com- patibility relation induces partial ordering of agents x1 and x2, written x1 ≤ x2, iff x1  x2.
Notation 4.2 The universe of complex agents X with partial order ≤ is a partially ordered set X≤.
The compatibility operator defines a partial order on A, T, and X sets. For our purposes, only partially ordered set X≤ is relevant. The reason is that complex agents actually encapsulate all the other agent types. However, partial order of the entire universe of complex agents is not very useful, since most of the agents cannot be compared by compatibility operator. We are interested in particular subsets where every two complex agents can be either compared directly or there exists an agent compatible with both of them.
Definition 4.3 (Compatible set ) A finite set X ⊆ X is a compatible set if:
6X1, X2 ∈X ∃Xj ∈X : X1  Xj Λ X2  Xj,

and for each finite set Xj ⊆ X such that X ∩ Xj = ∅ holds: 6X ∈X 6Xj ∈ Xj :
ч(X  Xj ∨ Xj  X).
Remark 4.4 The compatible set X inherits partial order of X≤ since it is its subset.
A compatible set X contains partially ordered complex agents such that they all have the same sequences in terms of agent names. Example of a compatible set is given in Figure 2.


Fig. 2. An example of a compatible set F . The set is formed by a complex in cyt compartment, which has only one structure agent K in its sequence. The structure agent K has allowed atomic agents T and S in its partial composition. These two atomic agents might occur in two states – u and p. The set is complete – there are all relevant agents bounded by compatibility operator.

Lemma 4.5 In every compatible set X, there always exists a global supremum
sup(X ).
Proof. The lemma follows from Deﬁnition 4.3 condition (i) which claims that there is a supremum (in terms of compatibility) for every two complex agents in the com- patible set X. Since there exists a supremum for every two items in the set and the set is ﬁnite, there must exist a global supremum for the entire set.	 
Lemma 4.6 For every complex agent X there exists exactly one compatible set X ⊆ 
X such that X ∈ X.
Proof. Let us assume a complex agent X belongs to two compatible sets, namely X ∈ X1, X2. From Deﬁnition 4.3 condition (i) follows that there exists a X1 ∈ X1 such that X  X1.
Next, the condition (ii) claims that no complex agent from X1 and no complex agent from X2 can be compatible. Namely, X1 ∈ X1 cannot be compatible with X ∈ X2. However, X and X1 are compatible (X X1). It follows X /∈ X2, which is a contradiction.	 
In practise, compatible sets can be used for finding non-trivial relationships between the rules (Section 4.1) and for static analysis on the level of complexes (Section 4.2).
Definition 4.7 (Compatible subset ) Let X ⊆ X be a compatible set and X ∈ X a complex agent. A set X ⊆ X is called compatible subset of X w.r.t. X if the following conditions hold:

6Xj ∈X : Xj  X Λ ΔXj,



/ EXjj ∈F \F : Xjj  X Λ ΔXjj.
Compatible subset formally defines all fully specified agents from the compatible set which are compatible with a given member of the set (i.e. there are no compatible agents with them in the set). Note that for any complex agent X there exists just one compatible subset. The reason follows from Lemma 4.6 and Definition 4.7.

Rule redundancy elimination
There might be cases where there are redundant rules in a model (Definition 4.8). These rules do not cause any semantic difference, only increase the size of the model. We provide a static method how to detect such rules and eventually delete them from the model. Please note the redundancy is relevant only in the qualitative context. In the quantitative context, the same rules with different kinetics might have their relevance, yet it is still useful to detect potential redundancies.
Definition 4.8 (Redundant rule) Let M1 = (Y∪{R}, ΣA, ΣT, £) and M2 = (Y, ΣA, ΣT, £) be BCSL models where R is a rule such that R /∈ Y. The rule R is redundant if LTS(M1)= LTS(M2).
The redundant rule R does not add any semantic information to the model. It generally means the LTSs produced from the models with and without the rule are equal.
Theorem 4.9 Let R = (χ, ω, ι, ϕ, ψ) and Rj = (χj, ωj, ιj, ϕj, ψj) be two rules such that |χ| = |χj| = n for some n ∈ N. The rule Rj is redundant if 6i ∈ [1, n]: χj  χi.
Proof. The problem whether the elimination of a redundant rule preserves seman- tics can be reduced to a simple question – if it holds for a single pair of complex agents for a position k in the appropriate rules, then it generally holds for entire rule, because the condition of redundancy holds for each pair of complexes indepen- dently.

Assume the complex agents Xk and Xj
both belong to the same compatible set

F since Xk  Xj , which follows from the condition of the theorem. We can create subsets F, Fj ⊆F for both complex agents respectively (Deﬁnition 4.7). Since the agents are compatible (Xk   Xj ), the compatible subset F w.r.t. agent Xk is subset
of the compatible subset Fj w.r.t. agent Xj ( F ⊆ Fj).
Applied generally on the entire rule, the produced set of reactions (using matching relation – Deﬁnition 2.31) from the redundant rule is actually a subset of reactions produced from the non-redundant rule.	 
In the proof, we used compatible sets of complex agents and the fact that we can generate reactions from the rules, while we are actually enumerating all agents from the compatible set which are compatible with original agent in the rule. This is demonstrated in Example 4.10.
Example 4.10 Redundant rule. Let us consider two rules:

K(S{u}).K :: cell ⇒ K(S{p}).K :: cell
K(S{u},T{i}).K	::	cell	⇒
K(S{p},T{i}).K :: cell
Considering structure signature ΣT(K)= {S, T} and atomic signatures ΣA(S)= 
{u, p} and ΣA(T )= {a, i}, the rule (i) produces following set of eight reactions:



K(S{u},T{a}).K(S{u},T{i}) :: cell ⇒ K(S{p},T{a}).K(S{u},T{i}) :: cell,
K(S{u},T{a}).K(S{p},T{a}) :: cell ⇒ K(S{p},T{a}).K(S{p},T{a}) :: cell,
K(S{u},T{a}).K(S{p},T{i}) :: cell ⇒ K(S{p},T{a}).K(S{p},T{i}) :: cell,
K(S{u},T{i}).K(S{u},T{a}) :: cell ⇒ K(S{p},T{i}).K(S{u},T{a}) :: cell,
K(S{u},T{i}).K(S{u},T{i}) :: cell ⇒ K(S{p},T{i}).K(S{u},T{i}) :: cell,
K(S{u},T{i}).K(S{p},T{a}) :: cell ⇒ K(S{p},T{i}).K(S{p},T{a}) :: cell,
K(S{u},T{i}).K(S{p},T{i}) :: cell ⇒ K(S{p},T{i}).K(S{p},T{i}) :: cell
while the rule (ii) produces set of four reactions:
⎪
⎪⎪⎬

⎪


⎪⎪




K(S{u},T{i}).K(S{u},T{i}) :: cell ⇒ K(S{p},T{i}).K(S{u},T{i}) :: cell,
K(S{u},T{i}).K(S{p},T{a}) :: cell ⇒ K(S{p},T{i}).K(S{p},T{a}) :: cell,
K(S{u},T{i}).K(S{p},T{i}) :: cell ⇒ K(S{p},T{i}).K(S{p},T{i}) :: cell
which is a subset of the previous one. It follows the rule (ii) is redundant.
⎪⎬

⎪⎪⎭


Context-based reduction
There might be cases when simplifying some details of the given BCSL model pre- serves some properties while making the analysis of the model simpler. This is particularly the case of dynamic analysis, where a minor change in the model speci- fication can dramatically affect the behaviour. To address the model simplification, we first define a function that simplifies rules and then define the notion of a reduced model and show what kind of information does it preserve.
Definition 4.11 (Rule reduction) Let R = (χ, ω, ι, ϕ, ψ) be a rule. We define a 
reduced rule Rj = (χj, ωj, ιj, ϕj, ψj) as a function θ(R) such that 6i ∈ [1, k] : χj =
sup(F ) where F is a compatible set such that χi ∈ F , length k = |χj| = |χ| (i.e. the number of complex agents in both rules is the same), and ι = ιj.
Definition 4.12 (Reduced model ) Let M = (Y, ΣA, ΣT, £) be an initial BCSL model. We define reduced model M = (Y, ΣA, ΣT, I) such that the following condi- tions hold:

for every rule R ∈ Y, θ(R) ∈ Y˜ and every rule in the reduced model is the
image by θ of a rule of the initial model;
for every complex agent X ∈ £, sup(F ) ∈ I where F is a compatible set such that X ∈ F and every complex agent in the reduced model is the image by sup(F ) of a complex agent of the initial model.
Reduced model M is created from the given BCSL model by reducing the con- text of complexes in the rules to the maximum level. This is achieved by taking supremum from compatible set F . This procedure can produce some not well- formed rules – such rules are omitted (Figure 3). Consequently, only rules cre- ating/destroying agents and complex formation/dissociation should remain. Since we are reducing context, the number of rules in the resulting model is equal to or smaller than the number of rules in the initial model.

Fig. 3. Examples of rule reductions. (left ) A rule of complex formation is reduced to a version where none of the states is specified. (right ) A rule of state change inside of a complex is reduced to a rule which is not well-formed. It violates the condition (i) of Definition 2.26 – an agent has to change during the rule application. Therefore it is removed from the reduced model.

Definition 4.13 (Compatibility of states) Let M be a BCSL model and s1, s2 two states from its LTS. The state s1 is compatible with state s2, written s1 s2, iff there exists a bijective function f : s1 → s2 such that 6X ∈ s1 : sup(F ) = f (X) where F ⊆ X is a compatible set w.r.t. X.
Definition 4.14 (Over-approximation of LTS ) Let LTS(M), LTS(Mj) be labelled transition systems of some BCSL models M, Mj. The LTS(Mj) is an over-approxi-
mation of LTS(M) if for every path ... sj sj sj ... sj ... in LTS(Mj) there exists a
1 2 3	n
path ... s1s2s3 ... sm ... in LTS(M) such that 6sj, sj	Esk, sl : (l > k Λ sk  sj Λ

sl  sj	).
i	i+1	i

A reduced model M is actually an over-approximation of a BCSL model M in the context of their LTSs (Definition 4.14). It can be used for some types of analyses which avoid combinatorial explosion of the initial model M.
Theorem 4.15 Let X be a complex agent, F be a compatible set w.r.t. X, M be
a given BCSL model, and M˜ be an appropriate reduced model of model M. If
supremum sup(F ) is non-reachable in LTS(M), then agent X is also non-reachable in the LTS(M).
Proof. Let us assume a complex agent sup(F ) is non-reachable in LTS(M), but
X ∈ F is reachable in LTS(M). Generally, there is a path formed from rules in

the LTS(M) such that we transform complex agents from initial agents to desired complex agent X. When we move to context of LTS(M), there is no such path for sup(F ).
According to Deﬁnition 4.12, for every such rule there exists a reduced rule, such that all interacting complexes are reduced to their suprema. Therefore, if we could apply an initial rule on a complex agent, we can do the same with reduced rule and its supremum. It follows there must exist such path also in LTS(M) and the complex agent sup(F ) is reachable, which is a contradiction.	 

When we are checking whether an agent is reachable in LTS(M) for given model M, we might first check whether the respective abstract agent (the supremum) is reachable in LTS(M) of the reduced model M. If this holds then we are still not certain about reachability of the agent in its initial form. This has to be checked in LTS(M). However, Theorem 4.15 states that agent which is not reachable in LTS(M) is also not reachable in LTS(M). The usage of the theorem is demon- strated in Section 5.

Static non-reachability analysis
Since we have defined the compatibility operator for agents, we can apply static non-reachability analysis before enumerating the entire transition system of the model M. We can use the fact that there has to exist a compatible agent on the right-hand side of a rule with the desired agent in order to construct it eventually. This analysis is independent of the initial state of the model. However, it is worth noting that we do not consider the trivial case when the desired agent is already in the initial state.
Theorem 4.16 Let M be a BCSL model and Y its set of rules. Let X be a complex agent. The complex agent X is non-reachable w.r.t. set of rules Y if the following holds: 6 R ∈Y 6i ∈ RHS (R): ч(χi  X), where R = (χ, ω, ι, ϕ, ψ).
Proof. Let us assume we have a path of states constructed by applying correspond- ing rules from Y where X is reachable. At some point on the path, we inevitably have to create a complex agent X2  X from a complex agent X1 applying a rule R.



It requires there has to be a complex agent Xj
in the rule which is compatible

with the complex agent X2. If there is no such agent, the agent X is non-reachable. 

Compared to dynamic non-reachability analysis, Theorem 4.16 completely avoids any combinatorial explosion and gives an answer only by checking structural prop- erties of rules. The usage of the theorem is demonstrated in Section 5.

Case study
We want to demonstrate practical purposes of static analysis defined in this paper. Yamada et al. model [28] is a model of ﬁbroblast growth factor (FGF) signalling pathway. The model represents a signalling pathway, which is typically a cascade of signal transduction. It means that incorrect behaviour on a particular point in the cascade will influence the rest of the pathway. The entire model written in BCSL syntax consists of 20 types of agents interacting in 57 rules. Most of proteins can undergo phosphorylation (state change from u to p on some amino acid residues). We consider initial conditions such that there are all required agents in one or two repetitions (in cases when there are required multiple agents to create complexes, e.g. FGF ). In such case, the number of reachable states can grow up to 272, which is too high to be effectively enumerated. In Figure 4, there is a fragment of the model required for our purposes, the whole model is available in Appendix A.
For example, we want to check whether agent
FRS (Thr{u}, Tyr {u}).FGF (Thr{u}).R.FGF (Thr{u}).R::cyt
is reachable for the given model. The agent is formed from FGF proteins which are unphosphorylated (u) on threonine residues (Thr ). With the traditional approach, we have to enumerate entire transition system of the model and then use model checking method to check it. In our case, we can check if it is non-reachable using static reachability analysis (Theorem 4.16). The conclusion is that there is no compatible agent on any right-hand side of the rules. It follows that the given complex agent is non-reachable.
Demonstration of context-based reduction (Theorem 4.15) is provided on the same model as in the previous case. We can compute with the entire model since we will reduce its context to the minimum. Applying the reduction, there are created 16 bidirectional rules (Figure 5). The size of transition system has significantly decreased – it has approximately six hundreds of states and two thousands of edges.
FGF + R ⇔ FGF .R
2 FGF .R ⇔ FGF .R.FGF .R

FGF (Thr{u}).R.FGF .R	⇔
FGF (Thr{p}).R.FGF .R
FRS (Thr{u})	+
FGF (Thr{p}).R.FGF (Thr{p}).R ⇒
Initial conditions:
2 FGF (Thr{u})
2 R

⇒ FRS (Thr{u}).FGF (Thr{p}).R.FGF (Thr{p}).R 1 FRS (Thr{u},Tyr{u})
FRS (Thr{u}).FGF .R.FGF .R ⇒
⇒	.
FRS (Thr{p}).FGF .R.FGF .R
.
Fig. 4. A fragment of Yamada et al. model [28] of FGF signalling pathway written in BCSL. All agents are residing in a cytosol cyt compartment, which are omitted for simplicity. The rule (iv) requires both threonine residues (Thr ) on FGF proteins to be phosphorylated (p). Basically, it is not possible to create a complex from FRS and unphosphorylated (u) FGF proteins. Full model is available in Appendix A.

For instance, we want check reachability of a complex agent
Raf (Thr{p}).ERK (Tyr{p},Thr{p})::cyt
in the initial model. We can first check whether its corresponding least specified agent Raf .ERK ::cyt is non-reachable in the reduced model. Since the transition system of the model is relatively small, it can be quite easily checked using dynamical model checking. The answer in this case is non-reachable, which means the original agent in non-reachable too.

Fig. 5. Yamada et al. model [28] after context-based reduction was applied. All agents are residing in a cytosol cyt compartment, which are omitted for simplicity. Original model is available in Appendix A.


Conclusions
We have presented the second generation of Biochemical Space Language, a novel high-level language for the hierarchical description of biological structures and mech- anistic description of chemical reactions by means of compact rules. With respect to the previous prototype [8] the language fully utilises the specific view on the biochemical structures and reactions and the level of abstraction is not lost by translating the language into a low-level formalism not capable of maintaining a hierarchy of object types at the adequate level of abstraction.
We have defined and consequently demonstrated on several case studies static analysis techniques that are unique for the level of abstraction the language uses. We have shown it is possible to detect redundant rules and answer some reachabil- ity queries statically. The potential of the language provides the basis for further static analysis that is enabled by the specific abstraction and rule-based approach. Compared to low-level languages, we can take advantage of the hierarchy and rela- tionships built among agents, as demonstrated in provided analysis techniques.
We are aware of necessity to deeply compare these defined relations with the concepts of other formalisms. Our notion of compatible sets has a relation to or- thogonal fragments in Kappa [11]. Despite the fact that on our level of abstraction we do not have binding sites, the compatible sets can be seen as a simplified ver- sion of orthogonal fragments operating only on the level of states. Similarly, the reduction of models (and consequently reachability analysis) can be related to de- contextualisation in Kappa [10]. The formulation of exact relationships is left for the future work.
We are planning to extend the language by quantitative aspects such that we enable simulations of the models. However, this is quite a challenging task since

writing a rate of the rule requires to express how particular agents from the rule participate in the rate while keeping the syntax readable and concise. We are also developing the tool BCSgen that is able to maintain and analyse BCSL specifications with its online version eBCSgen.

References
Andrews, S. S., Smoldyn: Particle-based Simulation with Rule-based Modeling, Improved Molecular Interaction and a Library Interface, Bioinformatics 33 (2017), pp. 710 – 717.
Calzone, L., F. Fages and S. Soliman, BIOCHAM: An Environment for Modelling Biological Systems and Formalizing Experimental Knowledge, Bioinformatics 22 (2006), pp. 1805–1807.
Camporesi, F., J. Feret and K. Q. Ly`, KaDE: A Tool to Compile Kappa Rules into (Reduced) ODE Models, in: International Conference on Computational Methods in Systems Biology, Springer, 2017,
pp. 291–299.
Cardelli, L., From Processes to ODEs by Chemistry, in: The 5th Ifip International Conference On Theoretical Computer Science (TCS 2008) (2008), pp. 261–281.
Ciocchetta, F. and J. Hillston, Bio-PEPA: A Framework for the Modelling and Analysis of Biological Systems, Theoretical Computer Science 410 (2009), pp. 3065–3084.
Danos, V., J. Feret, W. Fontana, R. Harmer and J. Krivine, Rule-Based Modelling and Model Perturbation, in: Transactions on Computational Systems Biology XI (2009), pp. 116–137.
Danos, V. and J. Krivine, Formal Molecular Biology Done in CCS-R, Electronic Notes in Theoretical Computer Science 180 (2007), pp. 31–49.
Dˇed, T., D. Sˇafr´anek, M. Troja´k, M. Klement, J. Sˇalagoviˇc and L. Brim, Formal Biochemical Space with Semantics in Kappa and BNGL, Electronic Notes in Theoretical Computer Science 326 (2016),
pp. 27–49, the 6th International Workshop on Static Analysis and Systems Biology, SASB 2015.
Faeder, J. R., M. L. Blinov, W. S. Hlavacek et al., Rule-based Modeling of Biochemical Systems With BioNetGen, Methods Mol Biol 500 (2009), pp. 113–167.
Feret, J., Reachability Analysis of Biological Signalling Pathways by Abstract Interpretation, in: Proceedings of the International Conference of Computational Methods in Sciences and Engineering, ICCMSE ’2007, Corfu, Greece, number 963.(2) in American Institute of Physics Conference Proceedings (2007), pp. 619–622.
Feret, J. and K. Q. Ly´, Reachability Analysis via Orthogonal Sets of Patterns, Electronic Notes in Theoretical Computer Science 335 (2018), pp. 27–48, 7th International Workshop on Static Analysis and Systems Biology (SASB 2016).
Fisher, J. and T. A. Henzinger, Executable Cell Biology, Nature biotechnology 25 (2007), p. 1239.
Honorato-Zimmer, R., A. J. Millar, G. D. Plotkin and A. Zardilis, Chromar, a Rule-based Language of Parameterised Objects, Theoretical Computer Science (2017).
Kitano, H., Computational Systems Biology, Nature 420 (2002), pp. 206 – 210.
Klement, M., T. Dˇed, D. Sˇafr´anek, J. Cˇerveny´, S. Mu¨ller and R. Steuer, Biochemical Space: A Framework for Systemic Annotation of Biological Models, Electronic Notes in Theoretical Computer Science 306 (2014), pp. 31–44.
Klement, M., D. Sˇafr´anek, T. Dˇed, A. Pejznoch, L. Nedbal, R. Steuer, J. Cˇerveny´ and S. Mu¨ller, A Comprehensive Web-based Platform for Domain-specific Biological Models (2013), pp. 61–67.
Lopez, C. F., J. L. Muhlich, J. A. Bachman and P. K. Sorger, Programming Biological Models in Python Using PySB, Molecular Systems Biology 9 (2013).
Misirli, G., M. Cavaliere, W. Waites, M. Pocock, C. Madsen, O. Gilfellon, R. Honorato-Zimmer,
P. Zuliani, V. Danos and A. Wipat, Annotation of Rule-based Models with Formal Semantics to Enable Creation, Analysis, Reuse and Visualization, Bioinformatics 32 (2015), pp. 908–917.

Paulev´e, L., S. Youssef, M. R. Lakin and A. Phillips, A Generic Abstract Machine for Stochastic
Process Calculi, in: Proceedings of the 8th International Conference on Computational Methods in Systems Biology, ACM, 2010, pp. 43–54.
Pedersen, M., A. Phillips and G. D. Plotkin, A High-level Language for Rule-based Modelling, Plos One 10 (2015), pp. 1–26.

Pedersen, M. and G. Plotkin, A Language for Biochemical Systems: Design and Formal Specification, in: Transactions on Computational Systems Biology XII: Special Issue on Modeling Methodologies, Springer Berlin Heidelberg, Berlin, Heidelberg, 2010 pp. 77–145.
Phillips, A. and L. Cardelli, Efficient, Correct Simulation of Biological Processes in the Stochastic Pi-calculus, in: International Conference on Computational Methods in Systems Biology (2007), pp. 184–199.
Regev, A. and E. Shapiro, Cells as Computation, in: International Conference on Computational Methods in Systems Biology, Springer, 2003, pp. 1–3.
Romers, J. C. and M. Krantz, rxncon 2.0: A Language for Executable Molecular Systems Biology, bioRxiv (2017).

Sneddon, M. W., J. R. Faeder and T. Emonet, Efficient Modeling, Simulation and Coarse-graining of Biological Complexity with NFsim, Nature Methods 8 (2011), pp. 177–183.

Sorokina, O., A. Sorokin, J. D. Armstrong and V. Danos, A Simulator for Spatially Extended Kappa Models, Bioinformatics 29 (2013), p. 3105.

Troj´ak, M., D. Sˇafr´anek, J. Hrabec, J. Sˇalagoviˇc, F. Romanovsk´a and J. Cˇerveny´, E-cyanobacterium.org: A Web-based Platform for Systems Biology of Cyanobacteria, in: Computational Methods in Systems Biology, LNBI 9859 (2016), pp. 316–322.

Yamada, S., T. Taketomi and A. Yoshimura, Model Analysis of Difference Between EGF Pathway and FGF Pathway, Biochemical and Biophysical Research Communications 314 (2004), pp. 1113–1120.

Zhang, F. and M. Meier-Schellersheim, SBML Level 3 Package: Multistate, Multicomponent and Multicompartment Species, Version 1, Release 1, Journal of Integrative Bioinformatics 15 (2018).

A	Model Yamada et al. 2004



