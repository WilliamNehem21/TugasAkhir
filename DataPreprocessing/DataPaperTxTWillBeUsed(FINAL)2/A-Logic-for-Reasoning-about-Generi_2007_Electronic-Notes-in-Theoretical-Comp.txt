Electronic Notes in Theoretical Computer Science 174 (2007) 3–18	
www.elsevier.com/locate/entcs

A Logic for Reasoning about Generic Judgments
Alwen Tiu
Australian National University and National ICT Australia

Abstract
This paper presents an extension of a proof system for encoding generic judgments, the logic FOλΔ∇ of Miller and Tiu, with an induction principle. The logic FOλΔ∇ is itself an extension of intuitionistic logic with fixed points and a “generic quantifier”, ∇, which is used to reason about the dynamics of bindings in
object systems encoded in the logic. A previous attempt to extend FOλΔ∇ with an induction principle has been unsuccessful in modeling some behaviours of bindings in inductive specifications. It turns out that this problem can be solved by relaxing some restrictions on ∇, in particular by adding the axiom B ≡ ∇x.B, where x is not free in B. We show that by adopting the equivariance principle, the presentation of the extended logic can be much simplified. Cut-elimination for the extended logic is stated, and some applications in reasoning about an object logic and a simply typed λ-calculus are illustrated.
Keywords: Proof theory, higher-order abstract syntax, logical frameworks.

Introduction
This paper aims at providing a framework for reasoning about specifications of deductive systems using higher-order abstract syntax [20]. Higher-order abstract syntax is a declarative approach to encoding syntax with bindings using Church’s simply typed λ-calculus. The main idea is to support the notions of α-equivalence and substitutions in the object syntax by operations in λ-calculus, in particular α-conversion and β-reduction. There are at least two approaches to higher-order abstract syntax. The functional programming approach encodes the object syntax as a data type, where the binding constructs in the object language are mapped to functions in the functional language. In this approach, terms in the object language become values of their corresponding types in the functional language. The proof search approach encodes object syntax as expressions in a logic whose terms are simply typed, and functions that act on the object terms are defined via relations, i.e., logic programs. There is a subtle difference between this approach and the former; in the proof search approach, the simple types are inhabited by well-formed expressions, instead of values as in the functional approach (i.e., the abstraction

1571-0661 © 2007 Elsevier B.V. Open access under CC BY-NC-ND license.
doi:10.1016/j.entcs.2007.01.016

type is inhabited by functions). The proof search approach is often referred to as λ- tree syntax [16], to distinguish it from the functional approach. This paper concerns the λ-tree syntax approach.
Specifications which use λ-tree syntax are often formalized using hypothetical and generic judgments in intuitionistic logic. It is enough to restrict to the fragment of first-order intuitionistic logic whose only formulas are those of hereditary Harrop formulas, which we will refer to as the HH logic. Consider for instance the problem of defining the data type for untyped λ-terms. One first introduces the following constants:
app : tm → tm → tm	abs : (tm → tm) → tm
where the type tm denotes the syntactic category of λ-terms and app and abs encode application and abstraction, respectively. The property of being a λ-term is then defined via the following theory:
  M  N (lam M ∧ lam N ⇒ lam (app M N )) &
  M ((  x.lam x ⇒ lam (M x)) ⇒ lam (abs M ))
where  is the universal quantifier and ⇒ is implication.
Reasoning about object systems encoded in HH is reduced to reasoning about the structure of proofs in HH. McDowell and Miller formalize this kind of reasoning in the logic FOλΔIN [10], which is an extension of first-order intuitionistic logic with fixed points and natural numbers induction. This is done by encoding the sequent calculus of HH inside FOλΔIN and prove properties about it. We refer to HH as object logic and FOλΔIN as meta logic. McDowell and Miller considered different styles of encoding and concluded that explicit representations of hypotheses and, more importantly, eigenvariables of the object logic are required in order to capture some statements about object logic provability in the meta logic [11]. One typical example involves the use of hypothetical and generic reasoning as follows: Suppose that the following formula is provable in HH.
  x.p xs ⇒  y.p y t ⇒ px t.
By inspection on the inference rules of HH, one observes that this is only possible if s and t are syntactically equal. This observation comes from the fact that the right introduction rule for universal quantifier, reading the rule bottom-up, introduces new constants, or eigenvariables. The quantified variables x and y will be replaced by distinct eigenvariables and hence the only matching hypothesis for pxt would be px s, and therefore s and t has to be equal. Let ▶HH F denote the provability of the formula F in HH. Then in the meta logic, we would want to be able to prove the statement:
∀s∀t.(▶HH  x.p xs ⇒  y.p y t ⇒ px t) ⊃ s = t.
The question is then how we would interpret the object logic eigenvariables in the meta logic. It is argued in [11] that the existing quantifiers in FOλΔIN cannot be

used to capture the behaviours of object logic eigenvariables directly. McDowell and Miller then resort to a non-logical encoding technique (in the sense that no logical connectives are used) which has some similar flavor to the use of de Bruijn indexes. The use of this encoding technique, however, has a consequence that substitutions in the object logic has to be formalized explicitly.
Motivated by the above mentioned limitation of FOλΔIN, Miller and Tiu later introduced a new quantifier ∇ to FOλΔIN which allows one to move the binders from the object logic to the meta logic. A generic judgment in the object logic, for instance ▶HH  x.G x is reflected in the meta logic as ∇x. ▶HH G x. More generally, object logic eigenvariables are ∇-quantified at the meta level. This meta logic, called FOλΔ∇ [17], allows one to perform case analyses on the provability of the object logic. Tiu later extended FOλΔ∇ with induction and co-induction rules, resulting in the logic Linc [25]. However, some inductive properties about the object logic are not provable in Linc, e.g, the implication
▶HH  x.G x ⊃ ∀t. ▶HH Gt 
which states the extensional property of object logic universal quantification.
The inductive proof of the formula (1) would require an induction hypothesis that quantifies over object logic signatures, i.e., it is a statement of the sort
“for all” →z, ∀H∇→z(▶HH  x.H →zx ⊃ ∀t. ▶HH H →z t)
where →z is a list of object logic eigenvariables occurring in the object sequents. An obvious extension to Linc to formalize this statement would be to allow for quantifi- cation over arbitrary lists of variables which act like variable contexts to the object logic. However this is technically non-trivial and may require complicated proof theory. In this paper we follow an easier but weaker approach, which is expressive enough to allow for inductive reasoning over object specifications involving bind- ings. Instead of having explicit quantification over variable contexts, we require every proposition to hold in any variable context. This effectively translates to admitting the following axiom in FOλΔ∇:
B ⊃ ∇x.B,	x is not free in B,
which is not provable in FOλΔ∇. Extensions to FOλΔ∇ have been previously proposed in a couple of previous works [5,2]. In both works, it is suggested that adding the following axioms
∇x∇y.B xy ⊃ ∇y∇x.B xy	and	B ≡ ∇x.B,
where x is not free in B in the second scheme, to FOλΔ∇ would result in a natural semantics for the extended logic. As it turns out, admitting these axioms would give a simpler proof theory too, compared to just having (2). We therefore adopt the axioms (3) in the extension of FOλΔ∇ discussed in the paper. This extended logic, called LGω, is obtained by extending FOλΔ∇ with natural number induction and with the axiom schemes (3). We show that inductive properties of λ-tree syntax specifications can be stated directly and in a purely logical fashion, and proved in LGω.

Relation to nominal logic
To guarantee good proof search behavior and syntactic consistency of the logic LGω (i.e., cut-elimination), the axiom schemes (3) need to be absorbed into the rules of the proof system of LGω. There are at least a couple of ways of achieving this. One way is to extend the proof system of FOλΔ∇ with some structural rules corresponding to the axioms (3). The other is to adopt the notion of equivariant predicates as in nominal logic [21], that is, provability of a predicate is invariant under permutations of names. We show here the second approach, which is simpler. The equivalent of the two formulations can be found in an extended version of the paper [26]. The equivariant principle is technically enforced by introducing a countably infinite set of name constants into the logic, and change the identity rule of the logic to allow equivalence under permutations of name constants:
π.B = π'.B'
Γ,B − B'	id

where π and π' are permutations on names. LGω is in fact very close to nominal logic, when we consider only the behaviours of logical connectives. In particular, the quantifier ∇ in LGω shares the same properties, in relation to other connectives of the logic, with the quantifier in nominal logic. However, there are two important differences in our approach. First, we do not attempt to redefine α-conversion and substitutions in LGω in terms of permutations (or swapping) and the notion of freshness as in nominal logic. Name swapping and freshness constraints are not part of the syntax of LGω. These notions are present only in the meta theory of the logic. In LGω, for example, variables are always considered to have empty support, that is, π.x = x for every permutation π. This is because we restrict substitutions to the “closed” ones, in the sense that no name constants can appear in the substitutions. A restricted form of open substitutions can be recovered indirectly at the meta theory of LGω. The fact that variables have empty support allows one to work with permutation free formulas and terms. So in LGω, we can prove that p x a ⊃ p x b, where a and b are names, without using explicit axioms of permutations and freshness. In nominal logic, one would prove this by using the swapping axiom p x a ⊃ p ((a b).x) ((a b).b), where (a b) denotes a swapping of a and b, and then show that (a b).x = x. The latter might not be valid if x is substituted by a, for example. The validity of this formula in nominal logic would therefore depend on the assumption on the support of x.
The second difference between LGω and nominal logic is that LGω allows closed terms (again, in the sense that no name constants appear in them) of type name, while in nominal logic, allowing such terms would lead to inconsistency [21]. As an example, the type tm in the encoding of λ-terms mentioned previously can be treated as a nominal type in LGω. This has an important consequence that we do not need to redefine the notion of substitutions for the encoded λ-terms, which is instead mapped to β-reduction in the meta language of LGω.
The rest of this paper is organized as follows. In Section 2 we introduce a proof system for LGω. Section 3 states some meta theories of LGω, in particular

cut-elimination and a translation from LGω without fixed points and induction to FOλ∇ with the axioms (3). Section 4 shows an encoding of HH logic in LGω and how some properties of the object logic can be formalized in LGω. Section 5 illustrates the use of HH to specify the typing judgments of λ-calculus and the evaluation relation on λ-terms. It also shows an example of reasoning about the encoded λ-calculus, by induction on the provability of the typing judgments in the object logic HH. Section 6 discusses some related and future work. The proofs of the main results in this paper can be in an extended version of the paper [26].

A logic for generic judgments
We first define the core fragment of the logic LGω which does not have fixed point rules or induction. The starting point is the logic FOλ∇ introduced in [17]. FOλ∇ is an extension of a subset of Church’s Simple Theory of Types in which formulas are given the type o. The core fragment of LGω, which we refer to as LG, shares the same set of connectives as FOλ∇, namely, ⊥, T, ∧, ∨, ⊃, ∀τ , ∃τ and ∇τ . The type τ in the quantifiers is restricted to that which does not contain the type o. Hence the logic is essentially first-order. We abbreviate (B ⊃ C) ∧ (C ⊃ B) as B ≡ C.
To enforce equivariant reasoning, we introduce a distinguished set of base types, called nominal types, which is denoted with N . Nominal types are ranged over by ι. We restrict the ∇ quantifier to nominal types. For each nominal type ι ∈ N , we assume an infinite number of constants of that type. These constants are called nominal constants. We denote the family of nominal constants by CN . The role of the nominal constants is to enforce the notion of equivariance: provability of formulas is invariant under permutations of nominal constants. Depending on the application, we might also assume a set of non-nominal constants, which is denoted by K.
We assume the usual notion of capture-avoiding substitutions. Substitutions are ranged over by θ and ρ. Application of substitutions is written in a postfix notation, e.g., tθ is an application of θ to the term t. Given two substitutions θ and θ', we denote their composition by θ ◦ θ' which is defined as t(θ ◦ θ') = (tθ)θ'. A typing context is a set of typed variables or constants. The judgment Δ ▶ t : τ denotes the fact that the term t has type the simple type τ , given the typing context Δ. Its operational semantics is the usual type system for Church’s simple type theory. A signature is a set of variables. A substitution θ respects a given signature Σ if there exists a set of typed variables Σ' such that for every x : τ ∈ Σ which is in the domain of θ, it holds that K∪ Σ' ▶ θ(x) : τ. We denote by Σθ the minimal set of variables satisfying the above condition. The substitution θ in this case is called a Σ-substitution. We assume that variables, free or bound, are of a different syntactic category from constants.
Definition 2.1 A permutation on CN is a bijection from CN to CN . The permu- tations on CN are ranged over by π. Application of a permutation π to a nominal constant a is denoted with π(a). We shall be concerned only with permutations which respect types, i.e., for every a : ι, π(a) : ι. Further, we shall also restrict to

permutations which are finite, that is, the set {a | π(a) /= a} is finite. Application of a permutation to an arbitrary term (or formula), written π.t, is defined as follows:
π.a = π(a), if a ∈ CN .	π.c = c,	if c /∈ CN .	π.x = x π.(M N )= (π.M ) (π.N )	π.(λx.M )= λx.(π.M )
A permutation involving only two nominal constants is called swapping. We use (a b), where a and b are constants of the same type, to denote the swapping {a '→ b, b '→ a}.
The support of a term (or formula) t, written supp(t), is the set of nominal constants appearing in it. It is clear from the above definition that if supp(t) is empty, then π.t = t for all π. The definition of Σ-substitution implies that for every θ and for every x ∈ Σ, θ(x) has empty support. Therefore Σ-substitutions and permutations commute, that is, (π.t)θ = π.(tθ).
A sequent in LGω is an expression of the form Σ; Γ − C where Σ is a signature and the formulas in Γ ∪ {C} are in βη-normal form. The free variables of Γ and C are among the variables in Σ. The inference rules for the core fragment of LGω, i.e., the logic LG, are given in Figure 1.
In the ∇L and ∇R rules, a denotes a nominal constant. In the ∃L and ∀R rules, we use raising [14] to encode the dependency of the quantified variable on the support of B, since we do not allow Σ-substitutions to mention any nominal constants. In the rules, the variable h has its type raised in the following way: suppose →c is the list c1 : ι1,... , cn : ιn and the quantified variable x is of type τ . Then the variable h is of type: ι1 → ι2 → ... → ιn → τ. This raising technique is similar to that of FOλΔ∇, and is used to encode explicitly the minimal support of the quantified variable. Its use prevents one from mixing the scopes of ∀ (dually, ∃) and ∇. That is, it prevents the formula ∀x∇y.p xy ≡ ∇y∀x.p xy, and its dual, to be proved.
Looking at the introduction rules for ∀ and ∃, one might notice the asymmetry between the left and the right introduction rules. The left rule for ∀ allows instanti- ations with terms containing any nominal constants while the raised variable in the right introduction rule of ∀ takes into account only those which are in the support of the quantified formula. However, we will see that we can extend the dependency of the raised variable to an arbitrary number of fresh nominal constants not in the support without affecting the provability of the sequent (see Lemma 3.5 and Lemma 3.6).
We now extend the logic LG with a proof theoretic notion of equality and fixed points, following on works by Hallnas and Schroeder-Heister [7,23], Girard [6] and McDowell and Miller [10]. The equality rules are as follows:
{Σθ; Γθ − Cθ | (λ→c.t)θ =βη (λ→c.s)θ}
Σ; Γ,s = t − C	eqL	Σ; Γ − t = t eqR
where supp(s = t)= {→c} and θ is a Σ-substitution in the eqL rule. In the eqL rule,

π.B = π'.B'


Σ; Γ,B — B' idπ
Σ; Γ — B  Σ; B, Δ — C


Σ; Γ, Δ — C	cut
Σ; Γ, ⊥ — C ⊥L	Σ; Γ — T TY
Σ; Γ, B, B — C cL
Σ; Γ,B — C

Σ; Γ, Bi — C
ΛL,i ∈ {1, 2}
Σ; Γ, B1 Λ B2 — C
Σ; Γ,B — C  Σ; Γ,D — C


Σ; Γ,B V D — C	VL
Σ; Γ — B  Σ; Γ,D — C
Σ; Γ — B  Σ; Γ — C
Σ; Γ — B Λ C	ΛY
Σ; Γ — Bi
VY,i ∈ {1, 2}
Σ; Γ — B1 V B2
Σ; Γ,B — C

Σ; Γ,B > D — C	> L	Σ; Γ — B > C > Y 

Σ, K, CN ▶ t : τ Σ; Γ, B[t/x] — C


Σ; Γ, 6τ x.B — C	6L
Σ; Γ, B[a/x] — C
∇L,a /∈ supp(B)
Σ; Γ, ∇x.B — C
Σ, h; Γ,B[h →c/x] — C
Σ, h;Γ — B[h →c/x]
6Y,h /∈ Σ, supp(B)= {→c}
Σ; Γ — 6x.B
Σ; Γ — B[a/x]
∇Y,a /∈ supp(B)
Σ; Γ — ∇x.B
Σ, K, CN ▶ t : τ Σ; Γ — B[t/x]

EL,h /∈ Σ, supp(B)= {→c}
Σ; Γ, Ex.B — C
Σ; Γ — Eτ x.B	EY



Fig. 1. The inference rules of LG
the substitution θ is a uniﬁer of λ→c.s and λ→c.t. Note that the λ-abstraction on →c in eqL is quite redundant, since Σ-substitutions cannot mention nominal constants and it will be equally valid to say that θ is a unifier of t and s. The use of λ’s in the rule is just to make it clear that the unification problem that arises in the rule is the usual higher-order unification and to conform with the formulations of equality rules in Linc [18,25].
We specify the premise of the rule as a set to mean that every element of the set is a premise. Since the terms s and t can be arbitrary higher-order terms, in general the set of their unifiers can be infinite. However, in some restricted cases, e.g., when λ→c.s and λ→c.t are higher-order pattern terms [13,19], if both terms are unifiable, then there exists a most general unifier. The applications we are considering are those which satisfy the higher-order pattern restrictions.
Definition 2.2 To each atomic formula, we associate a fixed point equation, or a deﬁnition clause, following the terminology of FOλΔ∇. A definition clause is
Δ
written ∀→x.p →x = B where the free variables of B are among →x. The predicate p →x
is called the head of the definition clause, and B is called the body. A deﬁnition is a set of definition clauses. We often omit the outer quantifiers when referring to a definition clause.
The introduction rules for defined atoms are as follows:

Σ; Γ, B[→t/→x] − C

def	Δ
Σ; Γ − B[→t/→x]	Δ

Σ; Γ,p →t − C
L,p →x = B
Σ; Γ − p →t	def R,p →x = B


In order to prove the cut-elimination theorem and the consistency of LGω, we allow only definition clauses which satisfy an equivariance preserving condition and a certain positivity condition, so as to guarantee the existence of fixed points.

Definition 2.3 We associate with each predicate symbol p a natural number, the
level of p. Given a formula B, its level lvl(B) is defined as follows:
lvl(p t¯)= lvl(p)
lvl(⊥)= lvl(T)=0 
lvl(B ∧ C)= lvl(B ∨ C)= max(lvl(B), lvl(C))
lvl(B ⊃ C)= max(lvl(B)+ 1, lvl(C))
lvl(∀x.B)= lvl(∇x.B)= lvl(∃x.B)= lvl(B).
Δ
A definition clause p →x = B is stratified if lvl(B) ≤ lvl(p) and supp(B) = ∅. We
consider only definition clauses which are stratified.
An example that violates the first restriction in Definition 2.3 is the definition
Δ
p = p ⊃ ⊥. In [23], Schroeder-Heister shows that admitting this definition in a logic
with contraction leads to inconsistency. To see why we need the second restriction
Δ
on name constants, consider the definition qx = (x = a), where a is a nominal
constant. Let b be a nominal constant different from a. Then qb is both true, since it is equivariant to qa and false, by the definition of fixed point.
In examples and applications, we often express definition clauses with patterns in the heads. Let us consider, for example, a definition clause for lists. We first introduce a type lst to denote lists of elements of type α, and the constants
nil : lst	::  : α → lst → lst
which denote the empty list and a constructor to build a list from an element of type α and another list. The latter will be written in the infix notation. The definition clause for lists is as follows.
Δ	'	'	'
list L = L = nil ∨ ∃αA∃lstL .L = (A :: L ) ∧ list L .
Using patterns, the above definition of lists can be rewritten as
Δ	Δ
list nil = T.	list (A :: L) = list L.
We shall often work directly with this patterned notation for definition clauses. For this purpose, we introduce the notion of patterned deﬁnitions. A patterned

deﬁnition clause is written ∀→x.H
Δ
= B where the free variables of H and B are

among →x. The stratification of definitions in Definition 2.3 applies to patterned definitions as well. Since the patterned definition clauses are not allowed to have free occurrences of nominal constants, in matching the heads of the clauses with an atomic formula in a sequent, we need to raise the variables of the clauses to account for nominal constants that are in the support of the introduced formula. Given a
Δ
patterned definition clause ∀x1 ... ∀xn.H = B its raised clause with respect to the
list of constants c1 : ι1 ... cn : ιn is
Δ
∀h1 ... ∀hn.H[h1 →c/x1,... , hn →c/xn] = B[h1 →c/x1,... , hn →c/xn].

The introduction rules for patterned definitions are


{Σθ; Bθ, Γθ − Cθ}θ
Σ; A, Γ − C
defL	Σ; Γ − Bθ def R
Σ; Γ − A



In the defL rule, B is the body of the raised patterned clause ∀x1
... ∀
Δ
xn.H = B

and (λ→c.H)θ = (λ→c.A)θ where {→c} is the support of A. In the def R rule, we match
A with the head of the clause, i.e., λ→c.A = (λ→c.H)θ. These patterned rules can be
derived using the non-patterned definition rules and the equality rules, as shown in [25].

Natural number induction.
We introduce a type nt to denote natural numbers, with the usual constants z : nt (zero) and s : nt → nt (the successor function), and a special predicate nat : nt → o. The rules for natural number induction are the same as those in FOλΔIN [10], which are the introduction rules for the predicate nat.
— Dz	j; Dj − D (sj)	Σ; Γ,D I − C

Σ; Γ, nat I − C	natL


Σ; Γ − nat z natR
Σ; Γ − nat I

Σ; Γ − nat (sI) natR

The logic LG extended with the equality, definitions and induction rules is re- ferred to as LGω.

The meta theory of LGω
In this section we investigate some properties of the logic LGω. We first look at the properties of the ∇ quantifier in relation to other connectives. The proof of the following proposition is straightforward by inspection on the rules of LG.
Proposition 3.1 The following formulas are provable in LG:
∇x.(Bx ∧ Cx) ≡ ∇x.Bx ∧ ∇x.Cx.
∇x.(Bx ⊃ Cx) ≡ ∇x.Bx ⊃ ∇x.Cx.
∇x.(Bx ∨ Cx) ≡ ∇x.Bx ∨ ∇x.Cx.
∇x.B ≡ B, provided that x is not free in B.
∇x∇y.Bxy ≡ ∇y∇x.Bxy.
∀x.Bx ⊃ ∇x.Bx.
∇x.Bx ⊃ ∃x.Bx.
The formulas (i) – (iii) are provable in FOλ∇. The proposition is true also in nominal logic with ∇ replaced by	.

The following properties concern the transformation of derivations. Provability is preserved under Σ-substitutions, permutations and a restricted form of name substitutions.
Lemma 3.2 Substitutions. Let Π be a proof of Σ; Γ − C and let θ be a Σ- substitution. Then there exists a proof Π' of Σθ; Γθ − Cθ.
Lemma 3.3 Permutations. Let Π be a proof of Σ; B1,... , Bn − B0. Then there exists a proof Π' of Σ; π1.B1,... , πn.Bn − π0.B0.
Lemma 3.4 Restricted name substitutions. Let Π be a proof of
Σ,x : ι; B1,... , Bn − B0.
Then there exists a proof of Π' of Σ; B1[a1/x],... , Bn[an/x] − B0[a0/x], where
ai /∈ supp(Bi) for each i ∈ {0,... , n}.
The next two lemmas are crucial to the cut-elimination proof: they allow one to reintroduce the symmetry between ∀L and ∀R, and dually, between ∃L and ∃R rules.
Lemma 3.5 Support extension. Let Π be a proof of Σ, h;Γ − B[h →a/x] where
{→a} = supp(B), h /∈ Σ and h is not free in Γ and B. Let →c be a ﬁnite list of nominal constants not in the support of B. Then there exists a proof Π' of Σ, h';Γ − B[h' →a→c/x].
Lemma 3.6 Support extension. Let Π be a proof of Σ, h; B[h →a/x], Γ − C where
{→a} = supp(B), h /∈ Σ and h is not free in Γ, B and C. Let →c be a ﬁnite list of nominal constants not in the support of B. Then there exists a proof Π' of Σ, h'; B[h' →a→c/x], Γ − C where h' /∈ Σ.
The main result on the meta theory of LGω is the cut-elimination theorem, from which the consistency of the logic follows.
Theorem 3.7 The cut rule is admissible in LGω.
Corollary 3.8 The logic LGω is consistent, i.e., it is not the case that both A and
A ⊃⊥ are provable.
Finally, we show that the formulation of LG is equivalent to FOλ∇ extended with the axiom schemes of name permutations and weakening.
Theorem 3.9 Let F be a formula which contains no occurrences of nominal con- stants. Then F is provable in FOλ∇ extended with the axiom schemes B ≡ ∇x.B and ∇x∇y.B xy ⊃ ∇y∇x.B xy if and only if F is provable in LG.

Encoding an object logic
We now consider an encoding of the logic HH mentioned in the introduction in
LGω. The encoding of this object logic has been done in FOλΔIN by McDowell and

seqI L tt seqI L ⟨A⟩
seq(sI) L (A & B)
Δ
= T.
Δ
= elem A L.
Δ
= seqI L A ∧ seqI L B.
Δ

seq(sI) L (A ⇒ B) = seqI (A :: L) B.

seq seq

(sI)
L ( 
L 
Δ
x.Gx) = ∇x.seqI
Δ ∃x.seq
L Gx. L Gx.

(sI)
x.Gx	=	I
Δ

seq(sI) L ⟨A⟩	= ∃B.prog A B ∧ seqI L B.

Fig. 2. Definition of an object logic.

Miller [11]. The formalization of the object logic properties in this section follows closely the FOλΔIN encoding. The only major difference is that we do not need an explicit encoding of eigenvariables; eigenvariables are mapped to nominal constants in the meta logic LGω.
The object logic formulas are generated by the following grammar.

D ::= A | G ⇒ A |  τ x.D
G ::= A | tt | G & G | A ⇒ G |  ι x.G |  τ .G

where A ranges over atomic (object-level) formula, ⇒, &,  and  denote impli- cation, conjunction, universal quantifier and existential quantifier, respectively. D and G represent definite clauses and goal formulas, respectively. Notice that in goal formulas, universal quantification is restricted to nominal types. The sequent rules for HH are the standard right introduction rules for the logical connectives plus the backchaining rule:
Γ, →x.G ⊃ A −→ Gθ	'
Γ, →x.G ⊃ A −→ A' bc, Aθ = A

This sequent system is complete for the HH fragment of intuitionistic logic, as a consequence of uniform provability of intuitionistic logic [15].
In order to encode the object-logic formulas into LGω, we first introduce some types and constants. The object logic formulas are given the type prp, while atomic formulas are given the type atm. The formulas of HH are encoded using the following constants:

⟨⟩ : atm → prp	&: prp → prp → prp		 τ : (ι → prp) → prp tt : prp	⇒: atm → prp → prp	 τ : (τ → prp) → prp
We denote the encoding of an object level formula A in LGω with [A]].

X, I2; seqI2 [p X] ⟨p a⟩ −⊥ 
∇L
X, I2; ∇y.seqI2 [p X] ⟨p y⟩ −⊥ 
defL
X, I1; seqI1 [p X] (  y.⟨p y⟩) −⊥ 
defL
X, I; seqI nil (p X ⇒  y.⟨p y⟩) −⊥ 

— ∀X∀I.(seqI nil (p X ⇒  y.⟨p y⟩) ⊃ ⊥)
∀R; ⊃R 
Fig. 3. A derivation in LGω.
Since the set of definite clauses in the sequents does not change in the proofs in HH, we will not put them explicitly in the HH sequents in their encoding in LGω. Hence hypotheses of HH sequents are lists of atomic formulas. The object logic sequent is represented using the predicate seq : nt → atmlist → prp → o where atmlist is the type for lists of atomic formulas, with the usual constructors nil and
:: . The natural number in the encoding of sequents will be used as a measure of the length of object logic proofs. Inductive properties about the provability in HH will be proved using this measure. An object sequent Γ −→ A is represented as the atomic formula (seqI [[Γ]] [[A]]) in LGω. We encode definite clauses using a predicate called prog : atm → prp → o. A definite clause  →x.G ⇒ A is encoded as the
Δ
definition clause ∀→x.prog A G = T. The patterned definition of the sequent rules of
HH is given in Figure 2. It uses the following definition clauses.


listi nil list L
Δ
= T.	list(s i) (A :: L)
Δ
= ∃i.nat i ∧ listi L.
Δ
Δ
= listi L.

Δ

elem A (A :: L) = T.	elem A (B :: L) = elem A L.

We refer to this definition together with the definition in Figure 2 as D(HH) and any additional definite clauses with D(prog).

Example:
The formula p X ⇒  y.p y is not provable in the empty theory, whatever the value of X is. This fact is formalized in LGω as the formula
∀X∀I.(seqI nil (p X ⇒   y.⟨p y⟩) ⊃ ⊥).

A partial derivation of this formula in LGω is shown in Figure 3. In the figure the notation [pX] stands for the list (pX :: nil). The derivation is completed by applying defL to the topmost sequent, resulting in two matching cases: the identity
rule and the backchaining rule. Since we assume no definite clauses, this leaves us with proving the sequent: X, I2; elem (p X) (p a :: nil) − ⊥. Applying defL to this sequent results in the sequent X, I2; elem (p X) nil − ⊥, since λa.p X and λa.p a are not unifiable. Another application of defL gives us empty premise and hence the sequent is provable.	 

It is straightforward to see that the structure of the HH proofs corresponds to the structure of proofs of its encoding in LGω; in particular, the backchaining rule in HH corresponds to the def R rule (for the patterned definition) in LGω. We now
state some properties of the encoding of HH in LGω.
Theorem 4.1 Let D(prog) be a deﬁnition corresponding to a set of deﬁnite clauses
P. Then the sequent P, Γ −→ G is derivable in HH if and only if seqi [[Γ]] [[G]] is derivable in LGω with the deﬁnition D(prog) ∪ D(HH) for some natural number i.

Theorem 4.2 The following formulas are provable in LGω with the deﬁnition of the object logic HH:
Structural rules: ∀L∀L'∀G∀i. nati ⊃ list L ⊃ list L'
(∀A.elem A L ⊃ elem A L') ⊃ seqi L G ⊃ seqi L' G.
Atomic cut: ∀L∀G∀A.list L ⊃ ∃i.(nat i ∧ seqi L (A ⇒ G)) ⊃
∃i.(nat i ∧ seqi L ⟨A⟩) ⊃ ∃i.nat i ∧ seqi L G.
Specialization: ∀L∀G∀i.nat i ⊃ list L ⊃ seq(s i) L ( G) ⊃ ∀x.seqi L (G x).

We conclude this section by a remark that ∇ is strictly speaking not necessary for capturing object logic provability, as Theorem 4.2 (3) shows, rather it is the use of nominal constants to model eigenvariables that allows that. The use of ∇, however, results in a more natural correspondence between the encoding of HH and its actual sequent proofs.


Reasoning about operational semantics
Following McDowell and Miller [11], we use the encoding of HH in LGω to specify and reason about the operational semantics of simply typed λ-calculus. Reasoning about more complicated languages like PCF can be done as well using a similar approach (see [11]).
We introduce a type ty to denote object-level types. The type tm denotes the object-level λ-terms and is considered a nominal type. The language of the (object- level) λ-terms is encoded using the following constants:

app : tm → tm → tm	abs : ty → (tm → tm) → tm

which denote application and abstraction, respectively. The object-level type con- structor, i.e., the ‘arrow’, is encoded via the constant ar : ty → ty → ty. Object-level base types are ranged over by α.
The evaluation relation and the typing judgments of the simply typed calculus

are given as definite clauses below.

eval (abs T M ) (abs T M ) ⇐ tt.
eval (app M N ) V ⇐  P  T.eval M (abs P T )& eval (P N ) V. typeof (abs T M ) (ar T T ') ⇐  x.typeof x T ⇒ typeof (Mx) T '.
typeof (app M N ) T ⇐  T '.typeof M (ar T ' T )& typeof N T '.

It is straightforward to translate these clauses to prog clauses.
We state a couple of properties here as formulas in LGω. In the following theorems, we use the notation L d G to denote the formula ∃i.nat i ∧ seqi L G. If L is nil we simply write dG.
Theorem 5.1 Subject reduction. The following formula is provable
∀M ∀V ∀T. d ⟨eval M V ⟩∧ d⟨typeof M T ⟩⊃ d⟨typeof V T ⟩.

A proof of a similar theorem is given in [11] for the untyped λ-term in the logic FOλΔIN. This proof can be adapted straightforwardly to give a proof for the above theorem. A more interesting property is the determinacy of type assignments, provided that the typing context is well-formed, that is, each variable in the context is assigned a unique type. The well-formedness of a typing context L is specified as the formula:
∀X∀T1∀T2.elem (typeof X T1) L ⊃ elem (typeof X T2) L ⊃ T1 = T2.
The above formula will be denoted by ctx L.
Theorem 5.2 The following formula is provable:
∀L∀X∀T1∀T2. list L ⊃ ctx L ⊃ L d ⟨typeof X T1⟩⊃ L d ⟨typeof X T2⟩⊃ T1 = T2.

Related and future work
There have been many previous related works in providing frameworks for higher- order abstract syntax, or more generally abstract syntax with bindings. A non- exhaustive list includes encoding in proof assistants like Coq [4], HOL [27], Is- abelle [28], and Twelf [24], categorical frameworks [8], the theory of contexts [9], nominal logic [21], and proof search frameworks [11,25]. The approach taken here is similar to the latter; the novelty of our work lies in the use of equivariance principle within the usual style of higher-order abstract syntax specifications. An immediate future work will be to implement the logic LGω, possibly on top of an existing proof assistant, and to perform large case studies, in particular, the problem sets put out in the POPLMark Challenge [1].

In the current work we show only the treatment of natural number induction. Extensions to iterated (co-)inductive definitions can be done in a similar way as in [18,25].
Semantics of LG. There have been several attempts at giving a semantics for the logic FOλ∇: Cheney and Gabbay proposed an encoding into nominal logic [5,2], Miculan and Yemane [12] gave a categorical semantics and Sch¨opp [22] gave a Tarski- style semantics and a categorical semantics for a classical version of FOλΔ∇. In these works, it is suggested that extending FOλ∇ with the axiom schemes (3) would result in a natural semantics for ∇. The works by Miculan and Yemane and Sch¨opp seem closer to the logic LG and could very well serve as a basis for finding a categorical model for LG. There are some similarities between LG and Nominal Logic, but the treatment of substitutions and the addition of closed terms of type name in LG make it not obvious whether the support models of Nominal Logic can be used for LG. We leave the investigation of support models for LG (or a classical version of LG), such as the ones in [21,3], as a future work.

Acknowledgement
The author would like to thank James Cheney for his many helpful remarks and suggestions, in particular those related to Nominal Logic, the anonymous referees for their useful and detailed comments, and also David Baelde, Alberto Momigliano, Michael Norrish and Brigitte Pientka for their comments on earlier drafts of the paper.

References
Aydemir, B. E., A. Bohannon, M. Fairbairn, J. N. Foster, B. C. Pierce, P. Sewell, D. Vytiniotis,
G. Washburn, S. Weirich and S. Zdancewic, Mechanized metatheory for the masses: the poplmark challenge, in: J. Hurd and T. Melham, editors, Theorem Proving in Higher Order Logics, 18th International Conference, Lecture Notes in Computer Science (2005), pp. 50–65.
Cheney, J., A simpler proof theory for nominal logic, in: Proc. FOSSACS’05, Lecture Notes in Computer Science 3441 (2005), pp. 379–394.
Cheney, J., Completeness and Herbrand theorems for nominal logic, Journal of Symbolic Logic 7 (2006),
pp. 299–320.
Despeyroux, J., A. Felty and A. Hirschowitz, Higher-order abstract syntax in Coq, in: Second International Conference on Typed Lambda Calculi and Applications, 1995, pp. 124–138.
Gabbay, M. J. and J. Cheney, A sequent calculus for nominal logic, in: Proc. 19th IEEE Symposium on Logic in Computer Science (LICS 2004), 2004, pp. 139–148.
Girard, J.-Y., A fixpoint theorem in linear logic (1992), email to the linear@cs.stanford.edu mailing list.
Halln¨as, L. and P. Schroeder-Heister, A proof-theoretic approach to logic programming. II. Programs as definitions, Journal of Logic and Computation 1 (1991), pp. 635–660.
Hofmann, M., Semantical analysis of higher-order abstract syntax, in: 14th Annual Symposium on Logic in Computer Science (1999), pp. 204–213.
Honsell, F., M. Miculan and I. Scagnetto, An axiomatic approach to metareasoning on systems in higher-order abstract syntax, in: Proc. ICALP’01, number 2076 in LNCS (2001), pp. 963–978.
McDowell, R. and D. Miller, Cut-elimination for a logic with definitions and induction, Theoretical Computer Science 232 (2000), pp. 91–119.

McDowell, R. and D. Miller, Reasoning with higher-order abstract syntax in a logical framework, ACM Transactions on Computational Logic 3 (2002), pp. 80–136.
Miculan, M. and K. Yemane, A unifying model of variables and names, in: Proc. FOSSACS’05, Lecture Notes in Computer Science 3441 (2005), pp. 170 – 186.
Miller, D., A logic programming language with lambda-abstraction, function variables, and simple unification, Journal of Logic and Computation 1 (1991), pp. 497–536.
Miller, D., Unification under a mixed prefix, Journal of Symbolic Computation 14 (1992), pp. 321–358.
Miller, D., G. Nadathur, F. Pfenning and A. Scedrov, Uniform proofs as a foundation for logic programming, Annals of Pure and Applied Logic 51 (1991), pp. 125–157.
Miller, D. and C. Palamidessi, Foundational aspects of syntax., ACM Comput. Surv. 31 (1999), p. 11.
Miller, D. and A. Tiu, A proof theory for generic judgments, ACM Trans. Comput. Logic 6 (2005),
pp. 749–783.
Momigliano, A. and A. Tiu, Induction and co-induction in sequent calculus, in: M. C. Stefano Berardi and F. Damiani, editors, Post-proceedings of TYPES 2003, number 3085 in LNCS, 2003, pp. 293 – 308.
Nipkow, T., Functional unification of higher-order patterns, in: M. Vardi, editor, Proc. 8th IEEE Symposium on Logic in Computer Science (LICS 1993) (1993), pp. 64–74.
Pfenning, F. and C. Elliott, Higher-order abstract syntax, in: Proceedings of the ACM-SIGPLAN Conference on Programming Language Design and Implementation (1988), pp. 199–208.
Pitts, A. M., Nominal logic, a first order theory of names and binding, Information and Computation
186 (2003), pp. 165–193.
Sch¨opp, U., Modelling generic judgments, in: Proceedings of Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP’06), 2006, pp. 1–16.
Schroeder-Heister, P., Cut-elimination in logics with definitional reflection, in: D. Pearce and
H. Wansing, editors, Nonclassical Logics and Information Processing, LNCS 619 (1992), pp. 146–171.
Schu¨rmann, C., “Automating the Meta Theory of Deductive Systems,” Ph.D. thesis, Carnegie Mellon University (2000).
Tiu, A., “A Logical Framework for Reasoning about Logical Specifications,” Ph.D. thesis, Pennsylvania State University (2004).
Tiu, A., A logic for reasoning about generic judgments (2006), extended version. Available on:
http://users.rsise.anu.edu.au/∼ tiu/lgext.pdf.
Urban, C. and M. Norrish, A formal treatment of the Barendregt Variable Convention in rule inductions, in: MERLIN ’05: Proceedings of the 3rd ACM SIGPLAN workshop on Mechanized reasoning about languages with variable binding (2005), pp. 25–32.
Urban, C. and C. Tasson, Nominal techniques in Isabelle/HOL, in: R. Nieuwenhuis, editor, Proceedings of the 20th International Conference on Automated Deduction (CADE), LNCS 3632 (2005), pp. 38–53.
